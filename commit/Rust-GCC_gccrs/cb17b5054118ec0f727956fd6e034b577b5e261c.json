{"sha": "cb17b5054118ec0f727956fd6e034b577b5e261c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2IxN2I1MDU0MTE4ZWMwZjcyNzk1NmZkNmUwMzRiNTc3YjVlMjYxYw==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2021-07-01T03:03:27Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2021-09-02T23:34:27Z"}, "message": "Fortran: TS 29113 testsuite\n\nAdd tests to exercise features added to Fortran via TS 29113, \"Further\nInteroperability of Fortran with C\":\n\nhttps://wg5-fortran.org/N1901-N1950/N1942.pdf\n\n2021-09-01  Sandra Loosemore  <sandra@codesourcery.com>\n\n\tgcc/testsuite/\n\t* gfortran.dg/c-interop/allocatable-dummy-c.c: New file.\n\t* gfortran.dg/c-interop/allocatable-dummy.f90: New file.\n\t* gfortran.dg/c-interop/allocatable-optional-pointer.f90: New file.\n\t* gfortran.dg/c-interop/allocate-c.c: New file.\n\t* gfortran.dg/c-interop/allocate-errors-c.c: New file.\n\t* gfortran.dg/c-interop/allocate-errors.f90: New file.\n\t* gfortran.dg/c-interop/allocate.f90: New file.\n\t* gfortran.dg/c-interop/argument-association-assumed-rank-1.f90:\n\tNew file.\n\t* gfortran.dg/c-interop/argument-association-assumed-rank-2.f90:\n\tNew file.\n\t* gfortran.dg/c-interop/argument-association-assumed-rank-3.f90:\n\tNew file.\n\t* gfortran.dg/c-interop/argument-association-assumed-rank-4.f90:\n\tNew file.\n\t* gfortran.dg/c-interop/argument-association-assumed-rank-5.f90:\n\tNew file.\n\t* gfortran.dg/c-interop/argument-association-assumed-rank-6.f90:\n\tNew file.\n\t* gfortran.dg/c-interop/argument-association-assumed-rank-7.f90:\n\tNew file.\n\t* gfortran.dg/c-interop/argument-association-assumed-rank-8.f90:\n\tNew file.\n\t* gfortran.dg/c-interop/assumed-type-dummy.f90: New file.\n\t* gfortran.dg/c-interop/c-interop.exp: New file.\n\t* gfortran.dg/c-interop/c1255-1.f90: New file.\n\t* gfortran.dg/c-interop/c1255-2.f90: New file.\n\t* gfortran.dg/c-interop/c1255a.f90: New file.\n\t* gfortran.dg/c-interop/c407a-1.f90: New file.\n\t* gfortran.dg/c-interop/c407a-2.f90: New file.\n\t* gfortran.dg/c-interop/c407b-1.f90: New file.\n\t* gfortran.dg/c-interop/c407b-2.f90: New file.\n\t* gfortran.dg/c-interop/c407c-1.f90: New file.\n\t* gfortran.dg/c-interop/c516.f90: New file.\n\t* gfortran.dg/c-interop/c524a.f90: New file.\n\t* gfortran.dg/c-interop/c535a-1.f90: New file.\n\t* gfortran.dg/c-interop/c535a-2.f90: New file.\n\t* gfortran.dg/c-interop/c535b-1.f90: New file.\n\t* gfortran.dg/c-interop/c535b-2.f90: New file.\n\t* gfortran.dg/c-interop/c535b-3.f90: New file.\n\t* gfortran.dg/c-interop/c535c-1.f90: New file.\n\t* gfortran.dg/c-interop/c535c-2.f90: New file.\n\t* gfortran.dg/c-interop/c535c-3.f90: New file.\n\t* gfortran.dg/c-interop/c535c-4.f90: New file.\n\t* gfortran.dg/c-interop/cf-descriptor-1-c.c: New file.\n\t* gfortran.dg/c-interop/cf-descriptor-1.f90: New file.\n\t* gfortran.dg/c-interop/cf-descriptor-2-c.c: New file.\n\t* gfortran.dg/c-interop/cf-descriptor-2.f90: New file.\n\t* gfortran.dg/c-interop/cf-descriptor-3-c.c: New file.\n\t* gfortran.dg/c-interop/cf-descriptor-3.f90: New file.\n\t* gfortran.dg/c-interop/cf-descriptor-4-c.c: New file.\n\t* gfortran.dg/c-interop/cf-descriptor-4.f90: New file.\n\t* gfortran.dg/c-interop/cf-descriptor-5-c.c: New file.\n\t* gfortran.dg/c-interop/cf-descriptor-5.f90: New file.\n\t* gfortran.dg/c-interop/cf-descriptor-6-c.c: New file.\n\t* gfortran.dg/c-interop/cf-descriptor-6.f90: New file.\n\t* gfortran.dg/c-interop/cf-descriptor-7-c.c: New file.\n\t* gfortran.dg/c-interop/cf-descriptor-7.f90: New file.\n\t* gfortran.dg/c-interop/cf-descriptor-8-c.c: New file.\n\t* gfortran.dg/c-interop/cf-descriptor-8.f90: New file.\n\t* gfortran.dg/c-interop/cf-out-descriptor-1-c.c: New file.\n\t* gfortran.dg/c-interop/cf-out-descriptor-1.f90: New file.\n\t* gfortran.dg/c-interop/cf-out-descriptor-2-c.c: New file.\n\t* gfortran.dg/c-interop/cf-out-descriptor-2.f90: New file.\n\t* gfortran.dg/c-interop/cf-out-descriptor-3-c.c: New file.\n\t* gfortran.dg/c-interop/cf-out-descriptor-3.f90: New file.\n\t* gfortran.dg/c-interop/cf-out-descriptor-4-c.c: New file.\n\t* gfortran.dg/c-interop/cf-out-descriptor-4.f90: New file.\n\t* gfortran.dg/c-interop/cf-out-descriptor-5-c.c: New file.\n\t* gfortran.dg/c-interop/cf-out-descriptor-5.f90: New file.\n\t* gfortran.dg/c-interop/cf-out-descriptor-6-c.c: New file.\n\t* gfortran.dg/c-interop/cf-out-descriptor-6.f90: New file.\n\t* gfortran.dg/c-interop/contiguous-1-c.c: New file.\n\t* gfortran.dg/c-interop/contiguous-1.f90: New file.\n\t* gfortran.dg/c-interop/contiguous-2-c.c: New file.\n\t* gfortran.dg/c-interop/contiguous-2.f90: New file.\n\t* gfortran.dg/c-interop/contiguous-3-c.c: New file.\n\t* gfortran.dg/c-interop/contiguous-3.f90: New file.\n\t* gfortran.dg/c-interop/deferred-character-1.f90: New file.\n\t* gfortran.dg/c-interop/deferred-character-2.f90: New file.\n\t* gfortran.dg/c-interop/dump-descriptors.c: New file.\n\t* gfortran.dg/c-interop/dump-descriptors.h: New file.\n\t* gfortran.dg/c-interop/establish-c.c: New file.\n\t* gfortran.dg/c-interop/establish-errors-c.c: New file.\n\t* gfortran.dg/c-interop/establish-errors.f90: New file.\n\t* gfortran.dg/c-interop/establish.f90: New file.\n\t* gfortran.dg/c-interop/explicit-interface.f90: New file.\n\t* gfortran.dg/c-interop/fc-descriptor-1-c.c: New file.\n\t* gfortran.dg/c-interop/fc-descriptor-1.f90: New file.\n\t* gfortran.dg/c-interop/fc-descriptor-2-c.c: New file.\n\t* gfortran.dg/c-interop/fc-descriptor-2.f90: New file.\n\t* gfortran.dg/c-interop/fc-descriptor-3-c.c: New file.\n\t* gfortran.dg/c-interop/fc-descriptor-3.f90: New file.\n\t* gfortran.dg/c-interop/fc-descriptor-4-c.c: New file.\n\t* gfortran.dg/c-interop/fc-descriptor-4.f90: New file.\n\t* gfortran.dg/c-interop/fc-descriptor-5-c.c: New file.\n\t* gfortran.dg/c-interop/fc-descriptor-5.f90: New file.\n\t* gfortran.dg/c-interop/fc-descriptor-6-c.c: New file.\n\t* gfortran.dg/c-interop/fc-descriptor-6.f90: New file.\n\t* gfortran.dg/c-interop/fc-descriptor-7-c.c: New file.\n\t* gfortran.dg/c-interop/fc-descriptor-7.f90: New file.\n\t* gfortran.dg/c-interop/fc-descriptor-8-c.c: New file.\n\t* gfortran.dg/c-interop/fc-descriptor-8.f90: New file.\n\t* gfortran.dg/c-interop/fc-descriptor-9-c.c: New file.\n\t* gfortran.dg/c-interop/fc-descriptor-9.f90: New file.\n\t* gfortran.dg/c-interop/fc-out-descriptor-1-c.c: New file.\n\t* gfortran.dg/c-interop/fc-out-descriptor-1.f90: New file.\n\t* gfortran.dg/c-interop/fc-out-descriptor-2-c.c: New file.\n\t* gfortran.dg/c-interop/fc-out-descriptor-2.f90: New file.\n\t* gfortran.dg/c-interop/fc-out-descriptor-3-c.c: New file.\n\t* gfortran.dg/c-interop/fc-out-descriptor-3.f90: New file.\n\t* gfortran.dg/c-interop/fc-out-descriptor-4-c.c: New file.\n\t* gfortran.dg/c-interop/fc-out-descriptor-4.f90: New file.\n\t* gfortran.dg/c-interop/fc-out-descriptor-5-c.c: New file.\n\t* gfortran.dg/c-interop/fc-out-descriptor-5.f90: New file.\n\t* gfortran.dg/c-interop/fc-out-descriptor-6-c.c: New file.\n\t* gfortran.dg/c-interop/fc-out-descriptor-6.f90: New file.\n\t* gfortran.dg/c-interop/fc-out-descriptor-7-c.c: New file.\n\t* gfortran.dg/c-interop/fc-out-descriptor-7.f90: New file.\n\t* gfortran.dg/c-interop/ff-descriptor-1.f90: New file.\n\t* gfortran.dg/c-interop/ff-descriptor-2.f90: New file.\n\t* gfortran.dg/c-interop/ff-descriptor-3.f90: New file.\n\t* gfortran.dg/c-interop/ff-descriptor-4.f90: New file.\n\t* gfortran.dg/c-interop/ff-descriptor-5.f90: New file.\n\t* gfortran.dg/c-interop/ff-descriptor-6.f90: New file.\n\t* gfortran.dg/c-interop/ff-descriptor-7.f90: New file.\n\t* gfortran.dg/c-interop/note-5-3.f90: New file.\n\t* gfortran.dg/c-interop/note-5-4-c.c: New file.\n\t* gfortran.dg/c-interop/note-5-4.f90: New file.\n\t* gfortran.dg/c-interop/optional-c.c: New file.\n\t* gfortran.dg/c-interop/optional.f90: New file.\n\t* gfortran.dg/c-interop/rank-class.f90: New file.\n\t* gfortran.dg/c-interop/rank.f90: New file.\n\t* gfortran.dg/c-interop/removed-restrictions-1.f90: New file.\n\t* gfortran.dg/c-interop/removed-restrictions-2.f90: New file.\n\t* gfortran.dg/c-interop/removed-restrictions-3.f90: New file.\n\t* gfortran.dg/c-interop/removed-restrictions-4.f90: New file.\n\t* gfortran.dg/c-interop/section-1-c.c: New file.\n\t* gfortran.dg/c-interop/section-1.f90: New file.\n\t* gfortran.dg/c-interop/section-1p.f90: New file.\n\t* gfortran.dg/c-interop/section-2-c.c: New file.\n\t* gfortran.dg/c-interop/section-2.f90: New file.\n\t* gfortran.dg/c-interop/section-2p.f90: New file.\n\t* gfortran.dg/c-interop/section-3-c.c: New file.\n\t* gfortran.dg/c-interop/section-3.f90: New file.\n\t* gfortran.dg/c-interop/section-3p.f90: New file.\n\t* gfortran.dg/c-interop/section-4-c.c: New file.\n\t* gfortran.dg/c-interop/section-4.f90: New file.\n\t* gfortran.dg/c-interop/section-errors-c.c: New file.\n\t* gfortran.dg/c-interop/section-errors.f90: New file.\n\t* gfortran.dg/c-interop/select-c.c: New file.\n\t* gfortran.dg/c-interop/select-errors-c.c: New file.\n\t* gfortran.dg/c-interop/select-errors.f90: New file.\n\t* gfortran.dg/c-interop/select.f90: New file.\n\t* gfortran.dg/c-interop/setpointer-c.c: New file.\n\t* gfortran.dg/c-interop/setpointer-errors-c.c: New file.\n\t* gfortran.dg/c-interop/setpointer-errors.f90: New file.\n\t* gfortran.dg/c-interop/setpointer.f90: New file.\n\t* gfortran.dg/c-interop/shape.f90: New file.\n\t* gfortran.dg/c-interop/size.f90: New file.\n\t* gfortran.dg/c-interop/tkr.f90: New file.\n\t* gfortran.dg/c-interop/typecodes-array-basic-c.c: New file.\n\t* gfortran.dg/c-interop/typecodes-array-basic.f90: New file.\n\t* gfortran.dg/c-interop/typecodes-array-char-c.c: New file.\n\t* gfortran.dg/c-interop/typecodes-array-char.f90: New file.\n\t* gfortran.dg/c-interop/typecodes-array-float128-c.c: New file.\n\t* gfortran.dg/c-interop/typecodes-array-float128.f90: New file.\n\t* gfortran.dg/c-interop/typecodes-array-int128-c.c: New file.\n\t* gfortran.dg/c-interop/typecodes-array-int128.f90: New file.\n\t* gfortran.dg/c-interop/typecodes-array-longdouble-c.c: New file.\n\t* gfortran.dg/c-interop/typecodes-array-longdouble.f90: New file.\n\t* gfortran.dg/c-interop/typecodes-sanity-c.c: New file.\n\t* gfortran.dg/c-interop/typecodes-sanity.f90: New file.\n\t* gfortran.dg/c-interop/typecodes-scalar-basic-c.c: New file.\n\t* gfortran.dg/c-interop/typecodes-scalar-basic.f90: New file.\n\t* gfortran.dg/c-interop/typecodes-scalar-float128-c.c: New file.\n\t* gfortran.dg/c-interop/typecodes-scalar-float128.f90: New file.\n\t* gfortran.dg/c-interop/typecodes-scalar-int128-c.c: New file.\n\t* gfortran.dg/c-interop/typecodes-scalar-int128.f90: New file.\n\t* gfortran.dg/c-interop/typecodes-scalar-longdouble-c.c: New file.\n\t* gfortran.dg/c-interop/typecodes-scalar-longdouble.f90: New file.\n\t* gfortran.dg/c-interop/ubound.f90: New file.\n\t* lib/target-supports.exp\n\t(check_effective_target_fortran_real_c_float128): New function.", "tree": {"sha": "b619cf5e99bc02167a87ff730ba692978ce18a41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b619cf5e99bc02167a87ff730ba692978ce18a41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb17b5054118ec0f727956fd6e034b577b5e261c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb17b5054118ec0f727956fd6e034b577b5e261c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb17b5054118ec0f727956fd6e034b577b5e261c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb17b5054118ec0f727956fd6e034b577b5e261c/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89cf858571c58a58ca51dbbf3975582ebab41e2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89cf858571c58a58ca51dbbf3975582ebab41e2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89cf858571c58a58ca51dbbf3975582ebab41e2d"}], "stats": {"total": 13731, "additions": 13731, "deletions": 0}, "files": [{"sha": "0ed09b5043fcd96c4d7ed674766e782a1514cfa3", "filename": "gcc/testsuite/gfortran.dg/c-interop/allocatable-dummy-c.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocatable-dummy-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocatable-dummy-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocatable-dummy-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,54 @@\n+#include <stdlib.h>\n+#include <stddef.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+struct t {\n+  float xyz[3];\n+  int id;\n+};\n+\n+extern void testit_f_bind_c (CFI_cdesc_t *a, float x, float y, float z);\n+extern void testit_c (CFI_cdesc_t *a, float x, float y, float z);\n+\n+void testit_c (CFI_cdesc_t *a, float x, float y, float z)\n+{\n+  struct t *tp;\n+\n+  /* Check that the allocatable dummy is unallocated on entry and do\n+     some other sanity checks.  */\n+  dump_CFI_cdesc_t (a);\n+  if (a->attribute != CFI_attribute_allocatable)\n+    abort ();\n+  if (a->rank)\n+    abort ();\n+  if (a->base_addr)\n+    abort ();\n+\n+  /* Allocate and initialize the output argument.  */\n+  CFI_allocate (a, NULL, NULL, 0);\n+  if (!a->base_addr)\n+    abort ();\n+  tp = (struct t *) CFI_address (a, NULL);\n+  tp->id = 42;\n+  tp->xyz[0] = 0.0;\n+  tp->xyz[1] = 0.0;\n+  tp->xyz[2] = 0.0;\n+\n+  /* Now call the Fortran function, which is supposed to automatically\n+     deallocate the object we just created above and point the descriptor\n+     at a different object.  */\n+  testit_f_bind_c (a, x, y, z);\n+\n+  /* Make sure we've got an allocated object, initialized as we\n+     expect.  */\n+  if (!a->base_addr)\n+    abort ();\n+  tp = (struct t *) CFI_address (a, NULL);\n+  if (tp->id != -1)\n+    abort ();\n+  if (tp->xyz[0] != x || tp->xyz[1] != y || tp->xyz[2] != z)\n+    abort ();\n+}"}, {"sha": "4161a30b16a4b96f90504c05c0824264f2700c51", "filename": "gcc/testsuite/gfortran.dg/c-interop/allocatable-dummy.f90", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocatable-dummy.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocatable-dummy.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocatable-dummy.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,98 @@\n+! PR 101308\n+! PR 92621(?)\n+! { dg-do run { xfail *-*-* } }\n+! { dg-additional-sources \"allocatable-dummy-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! TS 29113\n+! 6.3 Argument association\n+!\n+! When a Fortran procedure that has an INTENT(OUT) allocatable dummy\n+! argument is invoked by a C function, and the actual argument in the C\n+! function is the address of a C descriptor that describes an allocated\n+! allocatable variable, the variable is deallocated on entry to the\n+! Fortran procedure.  \n+\n+! When a C function is invoked from a Fortran procedure via an interface\n+! with an INTENT(OUT) allocatable dummy argument, and the actual\n+! argument in the reference to the C function is an allocated\n+! allocatable variable, the variable is deallocated on invocation\n+! (before execution of the C function begins).\n+\n+module m\n+  use iso_c_binding\n+\n+  type, bind (c) :: t\n+    real(C_FLOAT) :: xyz(3)\n+    integer(C_INT) :: id\n+  end type\n+\n+  interface\n+    subroutine testit_c (a, x, y, z) bind (c)\n+      use iso_c_binding\n+      import :: t\n+      type (t), allocatable, intent(out) :: a\n+      real(C_FLOAT), value, intent(in) :: x, y, z\n+    end subroutine\n+  end interface\n+\n+  contains\n+\n+    subroutine testit_f (a, x, y, z)\n+      type (t), allocatable, intent(out) :: a\n+      real(C_FLOAT), value, intent(in) :: x, y, z\n+      if (allocated (a))  stop 201\n+      allocate (a)\n+      a%id = 69\n+      a%xyz(1) = x\n+      a%xyz(2) = y\n+      a%xyz(3) = z\n+    end subroutine\n+\n+    subroutine testit_f_bind_c (a, x, y, z) bind (c)\n+      type (t), allocatable, intent(out) :: a\n+      real(C_FLOAT), value, intent(in) :: x, y, z\n+      if (allocated (a))  stop 301\n+      allocate (a)\n+      a%id = -1\n+      a%xyz(1) = x\n+      a%xyz(2) = y\n+      a%xyz(3) = z\n+    end subroutine\n+\n+end module\n+\n+program test\n+  use iso_c_binding\n+  use m\n+\n+  type (t), allocatable :: b\n+\n+  if (allocated (b))  stop 401\n+\n+  ! Try the regular Fortran test routine.\n+  allocate (b)\n+  call testit_f (b, 1.0, 2.0, 3.0)\n+  if (.not. allocated (b))  stop 402\n+  deallocate (b)\n+  if (allocated (b))  stop 403\n+\n+  ! Try the test routine written in Fortran with C binding.\n+  allocate (b)\n+  call testit_f_bind_c (b, 1.0, 2.0, 3.0)\n+  if (.not. allocated (b))  stop 404\n+  deallocate (b)\n+  if (allocated (b))  stop 405\n+\n+  ! Try the test routine written in C.  This calls testit_f_bind_c\n+  ! before returning, so make sure that's what we've got when returning.\n+  allocate (b)\n+  call testit_c (b, -1.0, -2.0, -3.0)\n+  if (.not. allocated (b))  stop 406\n+  if (b%id .ne. -1)  stop 407\n+  if (b%xyz(1) .ne. -1.0)  stop 408\n+  if (b%xyz(2) .ne. -2.0)  stop 408\n+  if (b%xyz(3) .ne. -3.0)  stop 408\n+  deallocate (b)\n+\n+end program"}, {"sha": "5a785b8a94d87b5bd769a5431698c65fd0cdb7aa", "filename": "gcc/testsuite/gfortran.dg/c-interop/allocatable-optional-pointer.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocatable-optional-pointer.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocatable-optional-pointer.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocatable-optional-pointer.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do compile}\n+!\n+! TS 29113\n+! 5.3 ALLOCATABLE, OPTIONAL, and POINTER attributes\n+! The ALLOCATABLE, OPTIONAL, and POINTER attributes may be specified \n+! for a dummy argument in a procedure interface that has the BIND \n+! attribute.\n+\n+subroutine test (a, b, c)\n+  integer, allocatable :: a\n+  integer, optional :: b\n+  integer, pointer :: c\n+\n+  interface\n+    subroutine ctest (aa, bb, cc) bind (c)\n+      integer, allocatable :: aa\n+      integer, optional :: bb\n+      integer, pointer :: cc\n+    end subroutine\n+  end interface\n+\n+  call ctest (a, b, c)\n+end subroutine"}, {"sha": "ed2d84f91a4261d6f5f49d626cd603d08c246c2a", "filename": "gcc/testsuite/gfortran.dg/c-interop/allocate-c.c", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocate-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocate-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocate-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,168 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+struct s {\n+  int i;\n+  double d;\n+};\n+\n+/* External entry point.  */\n+extern void ctest (void);\n+\n+void\n+ctest (void)\n+{\n+  CFI_CDESC_T(3) desc;\n+  CFI_cdesc_t *dv = (CFI_cdesc_t *) &desc;\n+  CFI_index_t ex[3], lb[3], ub[3];\n+  CFI_index_t sm;\n+  int i;\n+\n+  /* Allocate and deallocate a scalar.  */\n+  sm = sizeof (struct s);\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (dv, NULL, CFI_attribute_allocatable,\n+\t\t\t\t   CFI_type_struct, sm,\n+\t\t\t\t   0, NULL));\n+  check_CFI_status (\"CFI_allocate\",\n+\t\t    CFI_allocate (dv, NULL, NULL, 69));\n+  dump_CFI_cdesc_t (dv);\n+  if (dv->base_addr == NULL)\n+    abort ();\n+  /* The elem_len argument only overrides the initial value in the\n+     descriptor for character types.  */\n+  if (dv->elem_len != sm)\n+    abort ();\n+  check_CFI_status (\"CFI_deallocate\",\n+\t\t    CFI_deallocate (dv));\n+  /* The base_addr member of the C descriptor becomes a null pointer.  */\n+  if (dv->base_addr != NULL)\n+    abort ();\n+\n+  /* Try an array.  We are going to test the requirement that:\n+       The supplied lower and upper bounds override any current \n+       dimension information in the C descriptor.\n+     so we'll stuff different values in the descriptor to start with.  */\n+  ex[0] = 3;\n+  ex[1] = 4;\n+  ex[2] = 5;\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (dv, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_double, 0, 3, ex));\n+  lb[0] = 1;\n+  lb[1] = 2;\n+  lb[2] = 3;\n+  ub[0] = 10;\n+  ub[1] = 5;\n+  ub[2] = 10;\n+  sm = sizeof (double);\n+  check_CFI_status (\"CFI_allocate\",\n+\t\t    CFI_allocate (dv, lb, ub, 20));\n+  dump_CFI_cdesc_t (dv);\n+  if (dv->base_addr == NULL)\n+    abort ();\n+  /* The element sizes passed to both CFI_establish and CFI_allocate should\n+     have been ignored in favor of using the constant size of the type.  */\n+  if (dv->elem_len != sm)\n+    abort ();\n+\n+  /* Check extents and strides; we expect the allocated array to\n+     be contiguous so the stride computation should be straightforward\n+     no matter what the lower bound is.  */\n+  for (i = 0; i < 3; i++)\n+    {\n+      CFI_index_t extent = ub[i] - lb[i] + 1;\n+      if (dv->dim[i].lower_bound != lb[i])\n+\tabort ();\n+      if (dv->dim[i].extent != extent)\n+\tabort ();\n+      /* pr93524 */\n+      if (dv->dim[i].sm != sm)\n+\tabort ();\n+      sm *= extent;\n+    }\n+  check_CFI_status (\"CFI_deallocate\",\n+\t\t    CFI_deallocate (dv));\n+  if (dv->base_addr != NULL)\n+    abort ();\n+\n+  /* Similarly for a character array, except that we expect the\n+     elem_len provided to CFI_allocate to prevail.  We set the elem_len\n+     to the same size as the array element in the previous example, so\n+     the bounds and strides should all be the same.  */\n+  ex[0] = 3;\n+  ex[1] = 4;\n+  ex[2] = 5;\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (dv, NULL, CFI_attribute_allocatable,\n+\t\t\t\t   CFI_type_char, 4, 3, ex));\n+  lb[0] = 1;\n+  lb[1] = 2;\n+  lb[2] = 3;\n+  ub[0] = 10;\n+  ub[1] = 5;\n+  ub[2] = 10;\n+  sm = sizeof (double);\n+  check_CFI_status (\"CFI_allocate\",\n+\t\t    CFI_allocate (dv, lb, ub, sm));\n+  dump_CFI_cdesc_t (dv);\n+  if (dv->base_addr == NULL)\n+    abort ();\n+  if (dv->elem_len != sm)\n+    abort ();\n+\n+  /* Check extents and strides; we expect the allocated array to\n+     be contiguous so the stride computation should be straightforward\n+     no matter what the lower bound is.  */\n+  for (i = 0; i < 3; i++)\n+    {\n+      CFI_index_t extent = ub[i] - lb[i] + 1;\n+      if (dv->dim[i].lower_bound != lb[i])\n+\tabort ();\n+      if (dv->dim[i].extent != extent)\n+\tabort ();\n+      /* pr93524 */\n+      if (dv->dim[i].sm != sm)\n+\tabort ();\n+      sm *= extent;\n+    }\n+  check_CFI_status (\"CFI_deallocate\",\n+\t\t    CFI_deallocate (dv));\n+  if (dv->base_addr != NULL)\n+    abort ();\n+\n+  /* Signed char is not a Fortran character type.  Here we expect it to\n+     ignore the elem_len argument and use the size of the type.  */\n+  ex[0] = 3;\n+  ex[1] = 4;\n+  ex[2] = 5;\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (dv, NULL, CFI_attribute_allocatable,\n+\t\t\t\t   CFI_type_signed_char, 4, 3, ex));\n+  lb[0] = 1;\n+  lb[1] = 2;\n+  lb[2] = 3;\n+  ub[0] = 10;\n+  ub[1] = 5;\n+  ub[2] = 10;\n+  sm = sizeof (double);\n+  check_CFI_status (\"CFI_allocate\",\n+\t\t    CFI_allocate (dv, lb, ub, sm));\n+  dump_CFI_cdesc_t (dv);\n+  if (dv->base_addr == NULL)\n+    abort ();\n+  if (dv->elem_len != sizeof (signed char))\n+    abort ();\n+\n+  check_CFI_status (\"CFI_deallocate\",\n+\t\t    CFI_deallocate (dv));\n+  if (dv->base_addr != NULL)\n+    abort ();\n+\n+}\n+"}, {"sha": "3a81049ab151c889ff08afcd11c8dd28c1b48563", "filename": "gcc/testsuite/gfortran.dg/c-interop/allocate-errors-c.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocate-errors-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocate-errors-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocate-errors-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,109 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+struct s {\n+  int i;\n+  double d;\n+};\n+\n+static long buf[5][4][3];\n+\n+/* External entry point.  */\n+extern void ctest (void);\n+\n+void\n+ctest (void)\n+{\n+  int bad = 0;\n+  int status;\n+  CFI_CDESC_T(3) desc;\n+  CFI_cdesc_t *dv = (CFI_cdesc_t *) &desc;\n+  CFI_index_t ex[3], lb[3], ub[3];\n+  CFI_index_t sm;\n+\n+  /* On entry, the base_addr member of the C descriptor shall be a null\n+     pointer.  */\n+  sm = sizeof (struct s);\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (dv, NULL, CFI_attribute_allocatable,\n+\t\t\t\t   CFI_type_struct, sm,\n+\t\t\t\t   0, NULL));\n+  check_CFI_status (\"CFI_allocate\",\n+\t\t    CFI_allocate (dv, NULL, NULL, 69));\n+  status = CFI_allocate (dv, NULL, NULL, 42);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for CFI_allocate of already-allocated object\\n\");\n+      bad ++;\n+    }\n+  check_CFI_status (\"CFI_deallocate\",\n+\t\t    CFI_deallocate (dv));\n+\n+  /* The attribute member of the C descriptor shall have a value of\n+     CFI_attribute_allocatable or CFI_attribute_pointer.  */\n+  ex[0] = 3;\n+  ex[1] = 4;\n+  ex[2] = 5;\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (dv, NULL, CFI_attribute_other,\n+\t\t\t\t   CFI_type_long, 0, 3, ex));\n+  lb[0] = 1;\n+  lb[1] = 2;\n+  lb[2] = 3;\n+  ub[0] = 10;\n+  ub[1] = 5;\n+  ub[2] = 10;\n+  sm = sizeof (long);\n+  status = CFI_allocate (dv, lb, ub, 20);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for CFI_allocate of CFI_attribute_other object\\n\");\n+      bad ++;\n+    }\n+\n+  /* dv shall be the address of a C descriptor describing the object.\n+     It shall have been allocated using the same mechanism as the\n+     Fortran ALLOCATE statement.  */\n+  ex[0] = 3;\n+  ex[1] = 4;\n+  ex[2] = 5;\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (dv, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_long, 0, 3, ex));\n+  status = CFI_deallocate (dv);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for CFI_deallocate with null pointer\\n\");\n+      bad ++;\n+    }\n+\n+  /* This variant is disabled.  In theory it should be possible for\n+     the memory allocator to easily check for pointers outside the\n+     heap region, but libfortran just calls free() which has no provision\n+     for returning an error, and there is no other standard C interface\n+     to check the validity of a pointer in the C heap either.  */\n+#if 0  \n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (dv, buf, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_long, 0, 3, ex));\n+  status = CFI_deallocate (dv);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for CFI_deallocate with non-allocated pointer\\n\");\n+      bad ++;\n+    }\n+#endif\n+\n+  if (bad)\n+    abort ();\n+}\n+"}, {"sha": "a58d05a336816e6d5df3208de643a8670eb61982", "filename": "gcc/testsuite/gfortran.dg/c-interop/allocate-errors.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocate-errors.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocate-errors.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocate-errors.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do run }\n+! { dg-additional-sources \"allocate-errors-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-Wno-error -fcheck=all\" }\n+! { dg-warning \"command-line option '-fcheck=all' is valid for Fortran but not for C\" \"\" { target *-*-* } 0 }\n+!\n+! This program tests that the CFI_allocate and CFI_deallocate functions\n+! properly detect invalid arguments.  All the interesting things happen\n+! in the corresponding C code.\n+!\n+! The situation here seems to be that while TS29113 defines error codes for\n+! these functions, it doesn't actually require the implementation to detect\n+! those errors by saying the arguments \"shall be\" such-and-such, e.g. it is\n+! undefined behavior if they are not.  In gfortran you can enable some\n+! run-time checking by building with -fcheck=all.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+    subroutine ctest () bind (c)\n+    end subroutine\n+  end interface\n+\n+  call ctest ()\n+\n+end program"}, {"sha": "6878f04217215b2f8f5a2ebf6f32d55481a7c310", "filename": "gcc/testsuite/gfortran.dg/c-interop/allocate.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocate.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocate.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fallocate.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do run }\n+! { dg-additional-sources \"allocate-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program tests the CFI_allocate and CFI_deallocate functions.  \n+! All the interesting things happen in the corresponding C code.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+    subroutine ctest () bind (c)\n+    end subroutine\n+  end interface\n+\n+  call ctest ()\n+\n+end program"}, {"sha": "ee06cc77b63b011f8a4d277f6193e3af5cec7c67", "filename": "gcc/testsuite/gfortran.dg/c-interop/argument-association-assumed-rank-1.f90", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-1.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do run }\n+!\n+! TS 29113\n+! 6.3  Argument association\n+! An assumed-rank dummy argument may correspond to an actual argument of\n+! any rank. If the actual argument has rank zero, the dummy argument has\n+! rank zero; the shape is a zero-sized array and the LBOUND and UBOUND\n+! intrinsic functions, with no DIM argument, return zero-sized\n+! arrays.  [...]\n+\n+program test \n+\n+  call testit (42)\n+\n+contains\n+\n+  subroutine testit (x0)\n+    integer :: x0(..)\n+\n+    ! expect to have rank 0\n+    if (rank (x0) .ne. 0) stop 101\n+\n+    ! expect shape to be a zero-sized array\n+    if (size (shape (x0)) .ne. 0) stop 102\n+\n+    ! expect lbound and ubound functions to return zero-sized arrays\n+    if (size (lbound (x0)) .ne. 0) stop 103\n+    if (size (ubound (x0)) .ne. 0) stop 104\n+  end subroutine\n+\n+end program"}, {"sha": "4beeb8120c7df71a784c6a3b7767c182c4af9a26", "filename": "gcc/testsuite/gfortran.dg/c-interop/argument-association-assumed-rank-2.f90", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-2.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,48 @@\n+! { dg-do run }\n+!\n+! TS 29113\n+! 6.3  Argument association\n+! An assumed-rank dummy argument may correspond to an actual argument of\n+! any rank. [...] If the actual argument has rank greater than zero, the\n+! rank and extents of the dummy argument are assumed from the actual\n+! argument, including the lack of a final extent in the case of an\n+! assumed-size array. If the actual argument is an array and the dummy\n+! argument is allocatable or a pointer, the bounds of the dummy argument\n+! are assumed from the actual argument.\n+\n+program test \n+\n+  integer :: a(3, 4, 5)\n+  integer :: b(-3:3, 0:4, 2:5, 10:20)\n+\n+  call testit (a, rank(a), shape(a), lbound(a), ubound(a))\n+  call testit (b, rank(b), shape(b), lbound(b), ubound(b))\n+\n+contains\n+\n+  subroutine testit (x, r, s, l, u)\n+    integer :: x(..)\n+    integer :: r\n+    integer :: s(r)\n+    integer :: l(r)\n+    integer :: u(r)\n+\n+    ! expect rank to match\n+    if (rank (x) .ne. r) stop 101\n+\n+    ! expect shape to match\n+    if (size (shape (x)) .ne. r) stop 102\n+    if (any (shape (x) .ne. s))  stop 103\n+\n+    ! expect lbound and ubound functions to return rank-sized arrays.\n+    ! for non-pointer/non-allocatable arrays, bounds are normalized\n+    ! to be 1-based. \n+    if (size (lbound (x)) .ne. r) stop 104\n+    if (any (lbound (x) .ne. 1)) stop 105\n+\n+    if (size (ubound (x)) .ne. r) stop 106\n+    if (any (ubound (x) .ne. u - l + 1)) stop 107\n+    if (any (ubound (x) .ne. s)) stop 108\n+  end subroutine\n+\n+end program"}, {"sha": "c4b10100496c46c7eee22d1a0f73c03cd8ec6152", "filename": "gcc/testsuite/gfortran.dg/c-interop/argument-association-assumed-rank-3.f90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-3.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,51 @@\n+! { dg-do run }\n+!\n+! TS 29113\n+! 6.3  Argument association\n+! An assumed-rank dummy argument may correspond to an actual argument of\n+! any rank. [...] If the actual argument has rank greater than zero, the\n+! rank and extents of the dummy argument are assumed from the actual\n+! argument, including the lack of a final extent in the case of an\n+! assumed-size array. If the actual argument is an array and the dummy\n+! argument is allocatable or a pointer, the bounds of the dummy argument\n+! are assumed from the actual argument.\n+\n+program test \n+\n+  integer, target :: a(3, 4, 5)\n+  integer, target :: b(-3:3, 0:4, 2:5, 10:20)\n+  integer, pointer :: aa(:,:,:)\n+  integer, pointer :: bb(:,:,:,:)\n+  aa => a\n+  bb => b    \n+\n+  call testit (aa, rank(a), shape(a), lbound(a), ubound(a))\n+  call testit (bb, rank(b), shape(b), lbound(b), ubound(b))\n+\n+contains\n+\n+  subroutine testit (x, r, s, l, u)\n+    integer, pointer :: x(..)\n+    integer :: r\n+    integer :: s(r)\n+    integer :: l(r)\n+    integer :: u(r)\n+\n+    ! expect rank to match\n+    if (rank (x) .ne. r) stop 101\n+\n+    ! expect shape to match\n+    if (size (shape (x)) .ne. r) stop 102\n+    if (any (shape (x) .ne. s))  stop 103\n+\n+    ! expect lbound and ubound functions to return rank-sized arrays.\n+    ! for non-pointer/non-allocatable arrays, bounds are normalized\n+    ! to be 1-based. \n+    if (size (lbound (x)) .ne. r) stop 104\n+    if (any (lbound (x) .ne. l)) stop 105\n+\n+    if (size (ubound (x)) .ne. r) stop 106\n+    if (any (ubound (x) .ne. u)) stop 107\n+  end subroutine\n+\n+end program"}, {"sha": "9c92718fc7f852f7ca8869ecac6336fb575e98c6", "filename": "gcc/testsuite/gfortran.dg/c-interop/argument-association-assumed-rank-4.f90", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-4.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,50 @@\n+! { dg-do run }\n+!\n+! TS 29113\n+! 6.3  Argument association\n+! An assumed-rank dummy argument may correspond to an actual argument of\n+! any rank. [...] If the actual argument has rank greater than zero, the\n+! rank and extents of the dummy argument are assumed from the actual\n+! argument, including the lack of a final extent in the case of an\n+! assumed-size array. If the actual argument is an array and the dummy\n+! argument is allocatable or a pointer, the bounds of the dummy argument\n+! are assumed from the actual argument.\n+\n+program test \n+\n+  integer, allocatable :: a(:,:,:)\n+  integer, allocatable :: b(:,:,:,:)\n+\n+  allocate (a(3, 4, 5))\n+  allocate (b(-3:3, 0:4, 2:5, 10:20))\n+\n+  call testit (a, rank(a), shape(a), lbound(a), ubound(a))\n+  call testit (b, rank(b), shape(b), lbound(b), ubound(b))\n+\n+contains\n+\n+  subroutine testit (x, r, s, l, u)\n+    integer, allocatable :: x(..)\n+    integer :: r\n+    integer :: s(r)\n+    integer :: l(r)\n+    integer :: u(r)\n+\n+    ! expect rank to match\n+    if (rank (x) .ne. r) stop 101\n+\n+    ! expect shape to match\n+    if (size (shape (x)) .ne. r) stop 102\n+    if (any (shape (x) .ne. s))  stop 103\n+\n+    ! expect lbound and ubound functions to return rank-sized arrays.\n+    ! for non-pointer/non-allocatable arrays, bounds are normalized\n+    ! to be 1-based. \n+    if (size (lbound (x)) .ne. r) stop 104\n+    if (any (lbound (x) .ne. l)) stop 105\n+\n+    if (size (ubound (x)) .ne. r) stop 106\n+    if (any (ubound (x) .ne. u)) stop 107\n+  end subroutine\n+\n+end program"}, {"sha": "fd87225faefc70976a0667b91f607b73c03d0be7", "filename": "gcc/testsuite/gfortran.dg/c-interop/argument-association-assumed-rank-5.f90", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-5.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do run }\n+!\n+! TS 29113\n+! 6.3  Argument association\n+! An assumed-rank dummy argument may correspond to an actual argument of\n+! any rank. If the actual argument has rank zero, the dummy argument has\n+! rank zero; the shape is a zero-sized array and the LBOUND and UBOUND\n+! intrinsic functions, with no DIM argument, return zero-sized\n+! arrays.  [...]\n+\n+program test \n+\n+  call testit (42)\n+\n+contains\n+\n+  subroutine testit (x0) bind (c)\n+    integer :: x0(..)\n+\n+    ! expect to have rank 0\n+    if (rank (x0) .ne. 0) stop 101\n+\n+    ! expect shape to be a zero-sized array\n+    if (size (shape (x0)) .ne. 0) stop 102\n+\n+    ! expect lbound and ubound functions to return zero-sized arrays\n+    if (size (lbound (x0)) .ne. 0) stop 103\n+    if (size (ubound (x0)) .ne. 0) stop 104\n+  end subroutine\n+\n+end program"}, {"sha": "a65d43682529ba9b90fae1ba75d7a706fb73b14e", "filename": "gcc/testsuite/gfortran.dg/c-interop/argument-association-assumed-rank-6.f90", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-6.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,48 @@\n+! { dg-do run }\n+!\n+! TS 29113\n+! 6.3  Argument association\n+! An assumed-rank dummy argument may correspond to an actual argument of\n+! any rank. [...] If the actual argument has rank greater than zero, the\n+! rank and extents of the dummy argument are assumed from the actual\n+! argument, including the lack of a final extent in the case of an\n+! assumed-size array. If the actual argument is an array and the dummy\n+! argument is allocatable or a pointer, the bounds of the dummy argument\n+! are assumed from the actual argument.\n+\n+program test \n+\n+  integer :: a(3, 4, 5)\n+  integer :: b(-3:3, 0:4, 2:5, 10:20)\n+\n+  call testit (a, rank(a), shape(a), lbound(a), ubound(a))\n+  call testit (b, rank(b), shape(b), lbound(b), ubound(b))\n+\n+contains\n+\n+  subroutine testit (x, r, s, l, u) bind (c)\n+    integer :: x(..)\n+    integer :: r\n+    integer :: s(r)\n+    integer :: l(r)\n+    integer :: u(r)\n+\n+    ! expect rank to match\n+    if (rank (x) .ne. r) stop 101\n+\n+    ! expect shape to match\n+    if (size (shape (x)) .ne. r) stop 102\n+    if (any (shape (x) .ne. s))  stop 103\n+\n+    ! expect lbound and ubound functions to return rank-sized arrays.\n+    ! for non-pointer/non-allocatable arrays, bounds are normalized\n+    ! to be 1-based. \n+    if (size (lbound (x)) .ne. r) stop 104\n+    if (any (lbound (x) .ne. 1)) stop 105\n+\n+    if (size (ubound (x)) .ne. r) stop 106\n+    if (any (ubound (x) .ne. u - l + 1)) stop 107\n+    if (any (ubound (x) .ne. s)) stop 108\n+  end subroutine\n+\n+end program"}, {"sha": "819ee4f4b93523bcffcf003b94dce2fc05579338", "filename": "gcc/testsuite/gfortran.dg/c-interop/argument-association-assumed-rank-7.f90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-7.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,51 @@\n+! { dg-do run }\n+!\n+! TS 29113\n+! 6.3  Argument association\n+! An assumed-rank dummy argument may correspond to an actual argument of\n+! any rank. [...] If the actual argument has rank greater than zero, the\n+! rank and extents of the dummy argument are assumed from the actual\n+! argument, including the lack of a final extent in the case of an\n+! assumed-size array. If the actual argument is an array and the dummy\n+! argument is allocatable or a pointer, the bounds of the dummy argument\n+! are assumed from the actual argument.\n+\n+program test \n+\n+  integer, target :: a(3, 4, 5)\n+  integer, target :: b(-3:3, 0:4, 2:5, 10:20)\n+  integer, pointer :: aa(:,:,:)\n+  integer, pointer :: bb(:,:,:,:)\n+  aa => a\n+  bb => b    \n+\n+  call testit (aa, rank(a), shape(a), lbound(a), ubound(a))\n+  call testit (bb, rank(b), shape(b), lbound(b), ubound(b))\n+\n+contains\n+\n+  subroutine testit (x, r, s, l, u) bind (c)\n+    integer, pointer :: x(..)\n+    integer :: r\n+    integer :: s(r)\n+    integer :: l(r)\n+    integer :: u(r)\n+\n+    ! expect rank to match\n+    if (rank (x) .ne. r) stop 101\n+\n+    ! expect shape to match\n+    if (size (shape (x)) .ne. r) stop 102\n+    if (any (shape (x) .ne. s))  stop 103\n+\n+    ! expect lbound and ubound functions to return rank-sized arrays.\n+    ! for non-pointer/non-allocatable arrays, bounds are normalized\n+    ! to be 1-based. \n+    if (size (lbound (x)) .ne. r) stop 104\n+    if (any (lbound (x) .ne. l)) stop 105\n+\n+    if (size (ubound (x)) .ne. r) stop 106\n+    if (any (ubound (x) .ne. u)) stop 107\n+  end subroutine\n+\n+end program"}, {"sha": "d94a71b4a916a6729e78c24aea878cfe2b5b9f3f", "filename": "gcc/testsuite/gfortran.dg/c-interop/argument-association-assumed-rank-8.f90", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fargument-association-assumed-rank-8.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,50 @@\n+! { dg-do run }\n+!\n+! TS 29113\n+! 6.3  Argument association\n+! An assumed-rank dummy argument may correspond to an actual argument of\n+! any rank. [...] If the actual argument has rank greater than zero, the\n+! rank and extents of the dummy argument are assumed from the actual\n+! argument, including the lack of a final extent in the case of an\n+! assumed-size array. If the actual argument is an array and the dummy\n+! argument is allocatable or a pointer, the bounds of the dummy argument\n+! are assumed from the actual argument.\n+\n+program test \n+\n+  integer, allocatable :: a(:,:,:)\n+  integer, allocatable :: b(:,:,:,:)\n+\n+  allocate (a(3, 4, 5))\n+  allocate (b(-3:3, 0:4, 2:5, 10:20))\n+\n+  call testit (a, rank(a), shape(a), lbound(a), ubound(a))\n+  call testit (b, rank(b), shape(b), lbound(b), ubound(b))\n+\n+contains\n+\n+  subroutine testit (x, r, s, l, u) bind (c)\n+    integer, allocatable :: x(..)\n+    integer :: r\n+    integer :: s(r)\n+    integer :: l(r)\n+    integer :: u(r)\n+\n+    ! expect rank to match\n+    if (rank (x) .ne. r) stop 101\n+\n+    ! expect shape to match\n+    if (size (shape (x)) .ne. r) stop 102\n+    if (any (shape (x) .ne. s))  stop 103\n+\n+    ! expect lbound and ubound functions to return rank-sized arrays.\n+    ! for non-pointer/non-allocatable arrays, bounds are normalized\n+    ! to be 1-based. \n+    if (size (lbound (x)) .ne. r) stop 104\n+    if (any (lbound (x) .ne. l)) stop 105\n+\n+    if (size (ubound (x)) .ne. r) stop 106\n+    if (any (ubound (x) .ne. u)) stop 107\n+  end subroutine\n+\n+end program"}, {"sha": "a14c9a5970375efbba01ea432067b47e9bc8bf43", "filename": "gcc/testsuite/gfortran.dg/c-interop/assumed-type-dummy.f90", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fassumed-type-dummy.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fassumed-type-dummy.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fassumed-type-dummy.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,84 @@\n+! PR 101319\n+! { dg-do compile }\n+!\n+! TS 29113\n+! 6.3 Argument association\n+!\n+! An assumed-type dummy argument shall not correspond to an actual argument\n+! that is of a derived type that has type parameters, type-bound procedures,\n+! or final subroutines.\n+!\n+! In the 2018 Fortran standard, this requirement appears as:\n+!\n+! 15.5.2.4 Ordinary dummy variables\n+!\n+! If the actual argument is of a derived type that has type parameters,\n+! type-bound procedures, or final subroutines, the dummy argument shall \n+! not be assumed-type.\n+!\n+! This file contains code that is expected to produce errors.\n+\n+module m\n+\n+  ! basic derived type\n+  type :: t1\n+    real*8 :: xyz (3)\n+  end type\n+\n+  ! derived type with type parameters\n+  type t2 (k, l)\n+    integer, kind :: k\n+    integer, len :: l\n+    real(k) :: a(l)\n+  end type\n+\n+  ! derived type with a type-bound procedure\n+  type :: t3\n+    integer :: xyz(3)\n+    contains\n+      procedure, pass :: frob => frob_t3\n+  end type\n+\n+  ! derived type with a final subroutine\n+  type :: t4\n+    integer :: xyz(3)\n+    contains\n+      final :: final_t4\n+  end type\n+\n+contains\n+\n+  ! implementation of the type-bound procedure for t3 above\n+  subroutine frob_t3 (a)\n+    class (t3) :: a\n+    a%xyz = 0\n+  end subroutine\n+\n+  ! implementation of the final subroutine for t4 above\n+  subroutine final_t4 (a)\n+    type (t4) :: a\n+    a%xyz = 0\n+  end subroutine\n+\n+  ! useless subroutine with an assumed-type dummy.\n+  subroutine s1 (a)\n+    type(*) :: a\n+  end subroutine\n+\n+  ! test procedure\n+  subroutine testit\n+    type(t1) :: a1\n+    type(t2(8,20)) :: a2\n+    type(t3) :: a3\n+    type(t4) :: a4\n+\n+    call s1 (a1)  ! OK\n+    call s1 (a2)  ! { dg-error \"assumed-type dummy\" \"pr101319\" { xfail *-*-* } }\n+    call s1 (a3)  ! { dg-error \"assumed-type dummy\" }\n+    call s1 (a4)  ! { dg-error \"assumed-type dummy\" }\n+  end subroutine\n+\n+end module\n+\n+\n+"}, {"sha": "3bc2a9f2a604732cf4c10a242bcc2dab30192738", "filename": "gcc/testsuite/gfortran.dg/c-interop/c-interop.exp", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc-interop.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc-interop.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc-interop.exp?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,57 @@\n+# Copyright (C) 2005-2021 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gfortran-dg.exp\n+\n+# Initialize `dg'.\n+dg-init\n+\n+global gfortran_test_path\n+global gfortran_aux_module_flags\n+set gfortran_test_path $srcdir/$subdir\n+set gfortran_aux_module_flags \"-Werror -std=f2018\"\n+proc dg-compile-aux-modules { args } {\n+    global gfortran_test_path\n+    global gfortran_aux_module_flags\n+    if { [llength $args] != 2 } {\n+\terror \"dg-compile-aux-modules: needs one argument\"\n+\treturn\n+    }\n+\n+    set level [info level]\n+    if { [info procs dg-save-unknown] != [list] } {\n+\trename dg-save-unknown dg-save-unknown-level-$level\n+    }\n+\n+    dg-test $gfortran_test_path/[lindex $args 1] \"\" $gfortran_aux_module_flags\n+    # cleanup-modules is intentionally not invoked here.\n+\n+    if { [info procs dg-save-unknown-level-$level] != [list] } {\n+\trename dg-save-unknown-level-$level dg-save-unknown\n+    }\n+}\n+\n+# Main loop.\n+gfortran-dg-runtest [lsort \\\n+       [find $srcdir/$subdir *.\\[fF\\]{,90,95,03,08} ] ] \"\" \"-Werror\"\n+\n+# All done.\n+dg-finish"}, {"sha": "62fee2c4f50e9c256d8300ff24419c2edb1ad60a", "filename": "gcc/testsuite/gfortran.dg/c-interop/c1255-1.f90", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc1255-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc1255-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc1255-1.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,83 @@\n+! PR92482\n+! { dg-do compile }\n+!\n+! TS 29113\n+! C1255 (R1230) If proc-language-binding-spec is specified for a procedure,\n+! each dummy argument shall be an interoperable procedure (15.3.7) \n+! or a variable that is interoperable (15.3.5, 15.3.6), assumed shape, \n+! assumed rank, assumed type, of assumed character length, or has the \n+! ALLOCATABLE or POINTER attribute. If proc-language-binding-spec is \n+! specified for a function, the function result shall be an interoperable \n+! scalar variable.\n+\n+module m\n+\n+  interface\n+\n+    ! dummy is interoperable procedure\n+    subroutine s1 (x) bind (c)\n+      use ISO_C_BINDING\n+      implicit none\n+      interface\n+        function x (a, b) bind (c)\n+          use ISO_C_BINDING\n+          integer(C_INT) :: a, b\n+          integer(C_INT) :: x\n+        end function\n+      end interface\n+    end subroutine\n+\n+    ! dummy is interoperable variable\n+    subroutine s2 (x) bind (c)\n+      use ISO_C_BINDING\n+      implicit none\n+      integer(C_INT) :: x\n+    end subroutine\n+\n+    ! dummy is assumed-shape array variable\n+    subroutine s3 (x) bind (c)\n+      use ISO_C_BINDING\n+      implicit none\n+      integer(C_INT) :: x(:)\n+    end subroutine\n+\n+    ! dummy is an assumed-rank array variable\n+    subroutine s4 (x) bind (c)\n+      use ISO_C_BINDING\n+      implicit none\n+      integer(C_INT) :: x(..)\n+    end subroutine\n+\n+    ! dummy is assumed-type variable\n+    subroutine s5 (x) bind (c)\n+      use ISO_C_BINDING\n+      implicit none\n+      type(*) :: x\n+    end subroutine\n+\n+    ! dummy is assumed length character variable\n+    subroutine s6 (x) bind (c)  ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+      use ISO_C_BINDING\n+      implicit none\n+      character(len=*) :: x\n+    end subroutine\n+\n+    ! dummy has allocatable or pointer attribute\n+    subroutine s7 (x, y) bind (c)\n+      use ISO_C_BINDING\n+      implicit none\n+      integer(C_INT), allocatable :: x\n+      integer(C_INT), pointer :: y\n+    end subroutine\n+\n+    ! function result shall be an interoperable scalar variable\n+    function f (x) bind (c)\n+      use ISO_C_BINDING\n+      implicit none\n+      integer(C_INT) :: x\n+      integer(C_INT) :: f\n+    end function\n+\n+  end interface\n+end module\n+"}, {"sha": "0e5505a018359111a06569eaed5de6bd12782a3a", "filename": "gcc/testsuite/gfortran.dg/c-interop/c1255-2.f90", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc1255-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc1255-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc1255-2.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,106 @@\n+! { dg-do compile }\n+!\n+! TS 29113\n+! C1255 (R1230) If proc-language-binding-spec is specified for a procedure,\n+! each dummy argument shall be an interoperable procedure (15.3.7) \n+! or a variable that is interoperable (15.3.5, 15.3.6), assumed shape, \n+! assumed rank, assumed type, of assumed character length, or has the \n+! ALLOCATABLE or POINTER attribute. If proc-language-binding-spec is \n+! specified for a function, the function result shall be an interoperable \n+! scalar variable.\n+!\n+! This file contains code that is expected to produce errors.\n+\n+\n+module m1\n+   ! type to use for examples below\n+  type t\n+    integer :: foo\n+    real :: bar\n+  end type\n+end module\n+\n+module m2\n+\n+  interface\n+\n+    ! dummy is a procedure that is not interoperable\n+    subroutine s1 (x) bind (c)\n+      use ISO_C_BINDING\n+      use m1\n+      implicit none\n+      interface\n+        function x (a, b) bind (c)  ! { dg-error \"not C interoperable\" }\n+          use ISO_C_BINDING\n+          use m1\n+          integer(C_INT) :: a\n+          class(t) :: b  !\n+          integer(C_INT) :: x\n+        end function\n+      end interface\n+    end subroutine\n+\n+    ! dummy is of a type that is not interoperable\n+    subroutine s2 (x) bind (c)  ! { dg-error \"not C interoperable\" }\n+      use ISO_C_BINDING\n+      use m1\n+      implicit none\n+      class(t) :: x\n+    end subroutine\n+\n+    ! dummy is an array that is not of interoperable type and not\n+    ! assumed-shape or assumed-rank\n+    subroutine s3 (x) bind (c)  ! { dg-error \"not C interoperable\" }\n+      use ISO_C_BINDING\n+      use m1\n+      implicit none\n+      class(t) :: x(3, 3)\n+    end subroutine\n+\n+    subroutine s4 (n, x) bind (c)  ! { dg-error \"not C interoperable\" }\n+      use ISO_C_BINDING\n+      use m1\n+      implicit none\n+      integer(C_INT) :: n\n+      class(t) :: x(n)\n+    end subroutine\n+\n+    ! This fails with a bogus error even without C binding.\n+    subroutine s5 (x) bind (c)  ! { dg-error \"not C interoperable\" }\n+      use ISO_C_BINDING\n+      use m1\n+      implicit none\n+      class(t) :: x(*)  ! { dg-bogus \"not yet been implemented\" \"pr46991\" }\n+                        ! { dg-bogus \"has no IMPLICIT type\" \"pr46991\" { target \"*-*-*\" } 68 }\n+    end subroutine\n+\n+    subroutine s5a (x)\n+      use ISO_C_BINDING\n+      use m1\n+      implicit none\n+      class(t) :: x(*)  ! { dg-bogus \"not yet been implemented\" \"pr46991\" }\n+                        ! { dg-bogus \"has no IMPLICIT type\" \"pr46991\" { target \"*-*-*\" } 76 }\n+    end subroutine\n+\n+    ! function result is not a scalar\n+    function f (x) bind (c)  ! { dg-error \"not C interoperable\" }\n+      use ISO_C_BINDING\n+      use m1\n+      implicit none\n+      integer(C_INT) :: x\n+      type(t) :: f\n+    end function\n+\n+    ! function result is a type that is not interoperable\n+    function g (x) bind (c)  ! { dg-error \"BIND\\\\(C\\\\)\" }\n+      use ISO_C_BINDING\n+      use m1\n+      implicit none\n+      integer(C_INT) :: x\n+      integer(C_INT), allocatable :: g\n+    end function\n+\n+  end interface\n+\n+end module\n+"}, {"sha": "470ccaca0fd10b4c8b200cdd9ecb9d9edaada457", "filename": "gcc/testsuite/gfortran.dg/c-interop/c1255a.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc1255a.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc1255a.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc1255a.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do compile }\n+!\n+! TS 29113\n+! C1255a (R1230) A dummy argument of a procedure that has a \n+! proc-language-binding-spec shall not have both the OPTIONAL and\n+! VALUE attributes.\n+!\n+! This file contains code that is expected to produce errors.\n+\n+module m\n+\n+  interface\n+\n+    ! This one is OK.\n+    subroutine s1 (x, y) bind (c)\n+      use ISO_C_BINDING\n+      implicit none\n+      integer(C_INT) :: x\n+      integer(C_INT), optional :: y\n+    end subroutine\n+\n+    ! This one is OK too.\n+    subroutine s2 (x, y) bind (c)\n+      use ISO_C_BINDING\n+      implicit none\n+      integer(C_INT) :: x\n+      integer(C_INT), value :: y\n+    end subroutine\n+\n+    ! This one is bad.\n+    subroutine s3 (x, y) bind (c)    ! { dg-error \"BIND\\\\(C\\\\)\" }\n+      use ISO_C_BINDING\n+      implicit none\n+      integer(C_INT) :: x\n+      integer(C_INT), optional, value :: y\n+    end subroutine\n+\n+  end interface\n+\n+end module"}, {"sha": "f239a1e8c43f6b5690011d2cb9154d9d0814406f", "filename": "gcc/testsuite/gfortran.dg/c-interop/c407a-1.f90", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc407a-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc407a-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc407a-1.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,55 @@\n+! { dg-do compile}\n+!\n+! TS 29113\n+! C407a An assumed-type entity shall be a dummy variable that does not \n+! have the ALLOCATABLE, CODIMENSION, INTENT(OUT), POINTER, or VALUE \n+! attribute and is not an explicit-shape array.\n+!\n+! This test file contains tests that are expected to all pass.\n+\n+! Check basic usage with no attributes.\n+\n+module m\n+  interface\n+    subroutine g (a, b)\n+      implicit none\n+      type(*) :: a\n+      integer :: b\n+    end subroutine\n+  end interface\n+end module\n+\n+subroutine s0 (x)\n+  use m\n+  implicit none\n+  type(*) :: x\n+\n+  call g (x, 1)\n+end subroutine\n+\n+! Check that other attributes that can normally apply to dummy variables\n+! are allowed.\n+\n+subroutine s1 (a, b, c, d, e, f, g, h)\n+  implicit none\n+  type(*), asynchronous :: a\n+  type(*), contiguous :: b(:,:)\n+  type(*), dimension (:) :: c\n+  type(*), intent(in) :: d\n+  type(*), intent(inout) :: e\n+  type(*), optional :: f\n+  type(*), target :: g\n+  type(*), volatile :: h\n+\n+end subroutine\n+\n+! Check that non-explicit-shape arrays are allowed.\n+\n+subroutine s2 (a, b, c)\n+  implicit none\n+  type(*) :: a(:)  ! assumed-shape\n+  type(*) :: b(*)  ! assumed-size\n+  type(*) :: c(..) ! assumed-rank\n+\n+end subroutine\n+"}, {"sha": "9d8824d48d65549ed04eed2a906abd8ddc276615", "filename": "gcc/testsuite/gfortran.dg/c-interop/c407a-2.f90", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc407a-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc407a-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc407a-2.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,88 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-fcoarray=single\" }\n+!\n+! TS 29113\n+! C407a An assumed-type entity shall be a dummy variable that does not \n+! have the ALLOCATABLE, CODIMENSION, INTENT(OUT), POINTER, or VALUE \n+! attribute and is not an explicit-shape array.\n+!\n+! This test file contains tests that are expected to issue diagnostics\n+! for invalid code.\n+\n+! Check that diagnostics are issued when type(*) is used to declare things\n+! that are not dummy variables.\n+\n+subroutine s0 (a)\n+  implicit none\n+  integer :: a\n+\n+  integer :: goodlocal\n+  type(*) :: badlocal  ! { dg-error \"Assumed.type\" }\n+\n+  integer :: goodcommon\n+  type(*) :: badcommon  ! { dg-error \"Assumed.type\" }\n+  common /frob/ goodcommon, badcommon\n+\n+  integer :: goodstatic\n+  type(*) :: badstatic  ! { dg-error \"Assumed.type\" }\n+  save goodstatic, badstatic\n+\n+  block\n+    integer :: goodlocal2\n+    type(*) :: badlocal2  ! { dg-error \"Assumed.type\" }\n+  end block    \n+\n+end subroutine\n+\n+module m\n+  integer :: goodmodvar\n+  type(*) :: badmodvar ! { dg-error \"Assumed.type\" }\n+  save goodmodvar, badmodvar\n+\n+  type :: t\n+    integer :: goodcomponent\n+    type(*) :: badcomponent ! { dg-error \"Assumed.type\" }\n+  end type\n+end module\n+  \n+! Check that diagnostics are issued when type(*) is used in combination\n+! with the forbidden attributes.\n+\n+subroutine s1 (a) ! { dg-error \"Assumed.type\" }\n+  implicit none\n+  type(*), allocatable :: a\n+end subroutine\n+\n+subroutine s2 (b) ! { dg-error \"Assumed.type\" }\n+  implicit none\n+  type(*), codimension[*] :: b(:,:)\n+end subroutine\n+\n+subroutine s3 (c) ! { dg-error \"Assumed.type\" }\n+  implicit none\n+  type(*), intent(out) :: c\n+end subroutine\n+\n+subroutine s4 (d) ! { dg-error \"Assumed.type\" }\n+  implicit none\n+  type(*), pointer :: d\n+end subroutine\n+\n+subroutine s5 (e) ! { dg-error \"Assumed.type\" }\n+  implicit none\n+  type(*), value :: e\n+end subroutine\n+\n+! Check that diagnostics are issued when type(*) is used to declare\n+! a dummy variable that is an explicit-shape array.\n+\n+subroutine s6 (n, f) ! { dg-error \"Assumed.type\" }\n+  implicit none\n+  integer n\n+  type(*) :: f(n,n)\n+end subroutine\n+\n+subroutine s7 (g) ! { dg-error \"Assumed.type\" }\n+  implicit none\n+  type(*) :: g(10)\n+end subroutine"}, {"sha": "c9fc2b99647a751f345875e2828deb97b454e49f", "filename": "gcc/testsuite/gfortran.dg/c-interop/c407b-1.f90", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc407b-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc407b-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc407b-1.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,107 @@\n+! { dg-do compile}\n+!\n+! TS 29113\n+! C407b  An assumed-type variable name shall not appear in a designator\n+! or expression except as an actual argument corresponding to a dummy\n+! argument that is assumed-type, or as the first argument to any of\n+! the intrinsic and intrinsic module functions IS_CONTIGUOUS, LBOUND, \n+! PRESENT, RANK, SHAPE, SIZE, UBOUND, and C_LOC.\n+!\n+! This test file contains tests that are expected to all pass.\n+\n+! Check that passing an assumed-type variable as an actual argument \n+! corresponding to an assumed-type dummy works.\n+\n+module m\n+  interface\n+    subroutine g (a, b)\n+      implicit none\n+      type(*) :: a\n+      integer :: b\n+    end subroutine\n+  end interface\n+end module\n+\n+subroutine s0 (x)\n+  use m\n+  implicit none\n+  type(*) :: x\n+\n+  call g (x, 1)\n+end subroutine\n+\n+! Check that calls to the permitted intrinsic functions work.\n+\n+function test_is_contiguous (a)\n+  implicit none\n+  type(*) :: a(*)\n+  logical :: test_is_contiguous\n+\n+  test_is_contiguous = is_contiguous (a)\n+end function\n+\n+function test_lbound (a)\n+  implicit none\n+  type(*) :: a(:)\n+  integer :: test_lbound\n+\n+  test_lbound = lbound (a, 1)\n+end function\n+\n+function test_present (a)\n+  implicit none\n+  type(*), optional :: a(*)\n+  logical :: test_present\n+\n+  test_present = present (a)\n+end function\n+\n+function test_rank (a)\n+  implicit none\n+  type(*) :: a(*)\n+  integer :: test_rank\n+\n+  test_rank = rank (a)\n+end function\n+\n+function test_shape (a)\n+  implicit none\n+  type(*) :: a(:)  ! assumed-shape array so shape intrinsic works\n+  integer :: test_shape\n+\n+  integer :: temp, i\n+  integer, dimension (rank (a)) :: ashape\n+\n+  temp = 1\n+  ashape = shape (a)\n+  do i = 1, rank (a)\n+    temp = temp * ashape (i)\n+  end do\n+  test_shape = temp\n+end function\n+\n+function test_size (a)\n+  implicit none\n+  type(*) :: a(:)\n+  integer :: test_size\n+\n+  test_size = size (a)\n+end function\n+\n+function test_ubound (a)\n+  implicit none\n+  type(*) :: a(:)\n+  integer :: test_ubound\n+\n+  test_ubound = ubound (a, 1)\n+end function\n+\n+function test_c_loc (a)\n+  use iso_c_binding\n+  implicit none\n+  type(*), target :: a(*)\n+  type(c_ptr) :: test_c_loc\n+\n+  test_c_loc = c_loc (a)\n+end function\n+"}, {"sha": "3d3cd635279eac1f512c96619c33a5ed2c38cb81", "filename": "gcc/testsuite/gfortran.dg/c-interop/c407b-2.f90", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc407b-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc407b-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc407b-2.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,150 @@\n+! PR 101337\n+! { dg-do compile}\n+!\n+! TS 29113\n+! C407b  An assumed-type variable name shall not appear in a designator\n+! or expression except as an actual argument corresponding to a dummy\n+! argument that is assumed-type, or as the first argument to any of\n+! the intrinsic and intrinsic module functions IS_CONTIGUOUS, LBOUND, \n+! PRESENT, RANK, SHAPE, SIZE, UBOUND, and C_LOC.\n+!\n+! This file contains tests that are expected to give diagnostics.\n+\n+! Check that passing an assumed-type variable as an actual argument \n+! corresponding to a non-assumed-type dummy gives a diagnostic.\n+\n+module m\n+  interface\n+    subroutine f (a, b)\n+      implicit none\n+      integer :: a\n+      integer :: b\n+    end subroutine\n+    subroutine g (a, b)\n+      implicit none\n+      type(*) :: a\n+      integer :: b\n+    end subroutine\n+    subroutine h (a, b)\n+      implicit none\n+      type(*) :: a(*)\n+      integer :: b\n+    end subroutine\n+  end interface\n+end module\n+\n+subroutine s0 (x)\n+  use m\n+  implicit none\n+  type(*) :: x\n+\n+  call g (x, 1)\n+  call f (x, 1)  ! { dg-error \"Type mismatch\" }\n+  call h (x, 1)  ! { dg-error \"Rank mismatch\" }\n+end subroutine\n+\n+! Check that you can't use an assumed-type array variable in an array\n+! element or section designator.\n+\n+subroutine s1 (x, y)\n+  use m\n+  implicit none\n+  integer :: x(*)\n+  type(*) :: y(*)\n+\n+  call f (x(1), 1)\n+  call g (y(1), 1)  ! { dg-error \"Assumed.type\" }\n+  call h (y, 1)  ! ok\n+  call h (y(1:3:1), 1)  ! { dg-error \"Assumed.type\" }\n+end subroutine\n+\n+! Check that you can't use an assumed-type array variable in other\n+! expressions.  This is clearly not exhaustive since few operations\n+! are even plausible from a type perspective.\n+\n+subroutine s2 (x, y)\n+  implicit none\n+  type(*) :: x, y\n+  integer :: i\n+\n+  ! select type\n+  select type (x) ! { dg-error \"Assumed.type|Selector shall be polymorphic\" }\n+    type is (integer)\n+      i = 0\n+    type is (real)\n+      i = 1 \n+    class default\n+      i = -1\n+  end select\n+\n+  ! relational operations\n+  if (x & ! { dg-error \"Assumed.type\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+      .eq. y) then  ! { dg-error \"Assumed.type\" } \n+    return\n+  end if\n+  if (.not. (x & ! { dg-error \"Assumed.type\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+             .ne. y)) then  ! { dg-error \"Assumed.type\" } \n+    return\n+  end if\n+  if (.not. x) then  ! { dg-error \"Assumed.type\" } \n+    return\n+  end if\n+\n+  ! assignment\n+  x &  ! { dg-error \"Assumed.type\" } \n+    = y  ! { dg-error \"Assumed.type\" } \n+  i = x  ! { dg-error \"Assumed.type\" } \n+  y = i  ! { dg-error \"Assumed.type\" } \n+\n+  ! arithmetic\n+  i = x + 1  ! { dg-error \"Assumed.type\" } \n+  i = -y  ! { dg-error \"Assumed.type\" } \n+  i = (x & ! { dg-error \"Assumed.type\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+       + y)  ! { dg-error \"Assumed.type\" } \n+\n+  ! computed go to\n+  goto (10, 20, 30), x  ! { dg-error \"Assumed.type|must be a scalar integer\" }\n+10 continue\n+20 continue\n+30 continue\n+\n+  ! do loops\n+  do i = 1, x   ! { dg-error \"Assumed.type\" }\n+    continue\n+  end do\n+  do x = 1, i   ! { dg-error \"Assumed.type\" }\n+    continue\n+  end do\n+\n+end subroutine  \n+\n+! Check that calls to disallowed intrinsic functions produce a diagnostic.\n+! Again, this isn't exhaustive, there are just too many intrinsics and\n+! hardly any of them are plausible.\n+\n+subroutine s3 (x, y)\n+  implicit none\n+  type(*) :: x, y\n+  integer :: i\n+\n+  i = bit_size (x)  ! { dg-error \"Assumed.type\" }\n+  i = exponent (x)  ! { dg-error \"Assumed.type\" }\n+\n+  if (extends_type_of (x, &  ! { dg-error \"Assumed.type\" }\n+                       y)) then  ! { dg-error \"Assumed.type\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+    return\n+  end if\n+\n+  if (same_type_as (x, &  ! { dg-error \"Assumed.type\" }\n+                    y)) then  ! { dg-error \"Assumed.type\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+    return\n+  end if\n+\n+  i = storage_size (x)  ! { dg-error \"Assumed.type\" }\n+\n+  i = iand (x, &  ! { dg-error \"Assumed.type\" }\n+            y)    ! { dg-error \"Assumed.type\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+\n+  i = kind (x)  ! { dg-error \"Assumed.type\" }\n+\n+end subroutine  "}, {"sha": "e4da66adade351fc71e51a403040e0009d032082", "filename": "gcc/testsuite/gfortran.dg/c-interop/c407c-1.f90", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc407c-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc407c-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc407c-1.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,63 @@\n+! PR101333\n+! { dg-do compile}\n+!\n+! TS 29113\n+! C407c An assumed-type actual argument that corresponds to an\n+! assumed-rank dummy argument shall be assumed-shape or assumed-rank.\n+!\n+! This constraint is renumbered C711 in the 2018 Fortran standard.\n+\n+module m\n+  interface\n+    subroutine g (a, b)\n+      implicit none\n+      type(*) :: a(..)\n+      integer :: b\n+    end subroutine\n+  end interface\n+end module\n+\n+! Check that assumed-shape works.\n+\n+subroutine s0 (x)\n+  use m\n+  implicit none\n+  type(*) :: x(:)\n+\n+  call g (x, 1)\n+end subroutine\n+\n+! Check that assumed-rank works.\n+\n+subroutine s1 (x)\n+  use m\n+  implicit none\n+  type(*) :: x(..)\n+\n+  call g (x, 1)\n+end subroutine\n+\n+! Check that assumed-size gives an error.\n+\n+subroutine s2 (x)\n+  use m\n+  implicit none\n+  type(*) :: x(*)\n+\n+  call g (x, 1)  ! { dg-error \"Assumed.type\" \"pr101333\" { xfail *-*-* } }\n+end subroutine\n+\n+! Check that a scalar gives an error.\n+subroutine s3 (x)\n+  use m\n+  implicit none\n+  type(*) :: x\n+\n+  call g (x, 1)  ! { dg-error \"Assumed.type\" \"pr101333\" { xfail *-*-* } }\n+end subroutine\n+\n+! Explicit-shape assumed-type actual arguments are forbidden implicitly\n+! by c407a (C709 in the 2018 standard).  They're not allowed as dummy\n+! arguments, and assumed-type entities can only be declared as dummy\n+! arguments, so there is no other way to construct one to pass as an\n+! actual argument."}, {"sha": "208eb846ea562e5a5354fbe9b1f3a450787802e0", "filename": "gcc/testsuite/gfortran.dg/c-interop/c516.f90", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc516.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc516.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc516.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,67 @@\n+! PR 101320\n+! { dg-do compile }\n+!\n+! TS 29113\n+! C516  The ALLOCATABLE or POINTER attribute shall not be specified for\n+! a default-initialized dummy argument of a procedure that has a \n+! proc-language-binding-spec.\n+!\n+! This file contains code that is expected to produce errors.\n+\n+module m1\n+\n+  type, bind(c) :: t1\n+    integer :: a\n+    integer :: b\n+  end type\n+\n+\n+  type, bind(c) :: t2\n+    integer :: a = 0\n+    integer :: b = -1\n+  end type\n+\n+end module\n+\n+module m2\n+\n+  interface\n+\n+    ! good, no default initialization, no pointer/allocatable attribute\n+    subroutine s1a (x) bind (c)\n+      use m1\n+      type(t1), optional :: x\n+    end subroutine\n+\n+    ! good, no default initialization\n+    subroutine s1b (x) bind (c)\n+      use m1\n+      type(t1), allocatable, optional :: x\n+    end subroutine\n+\n+    ! good, no default initialization\n+    subroutine s1c (x) bind (c)\n+      use m1\n+      type(t1), pointer, optional :: x\n+    end subroutine\n+\n+    ! good, default initialization but no pointer/allocatable attribute\n+    subroutine s2a (x) bind (c)\n+      use m1\n+      type(t2), optional :: x\n+    end subroutine\n+\n+    ! bad, default initialization + allocatable\n+    subroutine s2b (x) bind (c)  ! { dg-error \"BIND\\\\(C\\\\)\" \"pr101320\" { xfail *-*-* } }\n+      use m1\n+      type(t2), allocatable, optional :: x\n+    end subroutine\n+\n+    ! bad, default initialization + pointer\n+    subroutine s2c (x) bind (c)  ! { dg-error \"BIND\\\\(C\\\\)\" \"pr101320\" { xfail *-*-* } }\n+      use m1\n+      type(t2), pointer, optional :: x\n+    end subroutine\n+\n+  end interface\n+end module"}, {"sha": "34abb72b325186ba36a24b97b18f98e00d5f2d5d", "filename": "gcc/testsuite/gfortran.dg/c-interop/c524a.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc524a.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc524a.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc524a.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,30 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-fcoarray=single\" }\n+!\n+! TS 29113\n+! C524a A coarray shall not be a dummy argument of a procedure that has \n+! a proc-language-binding-spec.\n+!\n+! This file contains code that is expected to produce errors.\n+\n+module m\n+\n+  interface\n+\n+    ! No C binding, this should be OK.\n+    subroutine s1 (x)\n+      use ISO_C_BINDING\n+      implicit none\n+      integer(C_INT), codimension[*] :: x(:,:)\n+    end subroutine\n+\n+    ! This one is bad.\n+    subroutine s2 (x) bind (c)  ! { dg-error \"BIND\\\\(C\\\\)\" }\n+      use ISO_C_BINDING\n+      implicit none\n+      integer(C_INT), codimension[*] :: x(:,:)\n+    end subroutine\n+\n+  end interface\n+end module\n+"}, {"sha": "5550cf24005a315031acfa6b5cdf655fed63f5bf", "filename": "gcc/testsuite/gfortran.dg/c-interop/c535a-1.f90", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535a-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535a-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535a-1.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,65 @@\n+! { dg-do compile}\n+!\n+! TS 29113\n+! C535a  An assumed-rank entity shall be a dummy variable that does not\n+! have the CODIMENSION or VALUE attribute.\n+! An assumed-rank object may have the CONTIGUOUS attribute.\n+!\n+! This test file contains tests that are expected to all pass.\n+\n+! Check basic usage with no attributes.\n+\n+module m\n+  type :: t\n+    integer :: i\n+    real :: f\n+  end type\n+end module\n+\n+subroutine s0 (a, b, c, d)\n+  use m\n+  implicit none\n+  integer :: a(..)\n+  real :: b(..)\n+  type(t) :: c(..)\n+  type(*) :: d(..)\n+end subroutine\n+\n+! Likewise with dimension attribute.\n+\n+subroutine s1 (a, b, c, d)\n+  use m\n+  implicit none\n+  integer, dimension(..) :: a\n+  real, dimension(..) :: b\n+  type(t), dimension(..) :: c\n+  type(*), dimension(..) :: d\n+end subroutine\n+\n+! Likewise with dimension statement.\n+\n+subroutine s2 (a, b, c, d)\n+  use m\n+  implicit none\n+  integer :: a\n+  real :: b\n+  type(t) :: c\n+  type(*) :: d\n+  dimension a(..), b(..), c(..), d(..)\n+end subroutine\n+\n+! Test that various other attributes are accepted.\n+\n+subroutine s3 (a, b, c, d, e, f, g, h, i, j)\n+  implicit none\n+  integer, allocatable :: a(..)\n+  integer, asynchronous :: b(..)\n+  integer, contiguous :: c(..)\n+  integer, intent(in) :: d(..)\n+  integer, intent(out) :: e(..)\n+  integer, intent(inout) :: f(..)\n+  integer, optional :: g(..)\n+  integer, pointer :: h(..)\n+  integer, target :: i(..)\n+  integer, volatile :: j(..)\n+end subroutine"}, {"sha": "026be4a55250f21fe5c3b320c17650fdaf6edb4c", "filename": "gcc/testsuite/gfortran.dg/c-interop/c535a-2.f90", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535a-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535a-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535a-2.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,78 @@\n+! { dg-do compile}\n+! { dg-additional-options \"-fcoarray=single\" }\n+!\n+! TS 29113\n+! C535a  An assumed-rank entity shall be a dummy variable that does not\n+! have the CODIMENSION or VALUE attribute.\n+! An assumed-rank object may have the CONTIGUOUS attribute.\n+!\n+\n+! This test file contains tests that are expected to issue diagnostics\n+! for invalid code.\n+\n+! Check that diagnostics are issued when dimension(..) is used to declare\n+! things that are not dummy variables.\n+\n+subroutine s0 (a)\n+  implicit none\n+  integer :: a\n+\n+  integer :: goodlocal\n+  integer :: badlocal1(..)  ! { dg-error \"Assumed.rank\" }\n+  integer, dimension(..) :: badlocal2  ! { dg-error \"Assumed.rank\" }\n+  integer :: badlocal3  ! { dg-error \"Assumed.rank\" }\n+  dimension badlocal3(..)\n+\n+  integer :: goodcommon\n+  integer :: badcommon1(..)  ! { dg-error \"Assumed.rank\" }\n+  integer, dimension(..) :: badcommon2  ! { dg-error \"Assumed.rank\" }\n+  integer :: badcommon3  ! { dg-error \"Assumed.rank\" }\n+  dimension badcommon3(..)\n+  common /frob/ goodcommon, badcommon1, badcommon2, badcommon3\n+\n+  integer :: goodstatic\n+  integer :: badstatic1(..)  ! { dg-error \"Assumed.rank\" }\n+  integer, dimension(..) :: badstatic2  ! { dg-error \"Assumed.rank\" }\n+  integer :: badstatic3  ! { dg-error \"Assumed.rank\" }\n+  dimension badstatic3(..)\n+  save goodstatic, badstatic1, badstatic2, badstatic3\n+\n+  block\n+    integer :: goodblocklocal\n+    integer :: badblocklocal1(..)  ! { dg-error \"Assumed.rank\" }\n+    integer, dimension(..) :: badblocklocal2  ! { dg-error \"Assumed.rank\" }\n+    integer :: badblocklocal3  ! { dg-error \"Assumed.rank\" }\n+    dimension badblocklocal3(..)\n+  end block    \n+\n+end subroutine\n+\n+module m\n+  integer :: goodmodvar\n+  integer :: badmodvar1(..)  ! { dg-error \"Assumed.rank\" }\n+  integer, dimension(..) :: badmodvar2  ! { dg-error \"Assumed.rank\" }\n+  integer :: badmodvar3  ! { dg-error \"Assumed.rank\" }\n+  dimension badmodvar3(..)\n+\n+  save goodmodvar, badmodvar1, badmodvar2, badmodvar3\n+\n+  type :: t\n+    integer :: goodcomponent\n+    integer :: badcomponent1(..)  ! { dg-error \"must have an explicit shape\" }\n+    integer, dimension(..) :: badcomponent2  ! { dg-error \"must have an explicit shape\" }\n+  end type\n+end module\n+  \n+! Check that diagnostics are issued when dimension(..) is used in combination\n+! with the forbidden attributes.\n+\n+subroutine s2 (b) ! { dg-error \"has no IMPLICIT type\" }\n+  implicit none\n+  integer, codimension[*] :: b(..) ! { dg-error \"assumed-rank array\" }\n+end subroutine\n+\n+subroutine s5 (e) ! { dg-error \"has no IMPLICIT type\" }\n+  implicit none\n+  integer, value :: e(..) ! { dg-error \"VALUE attribute conflicts with DIMENSION\" }\n+end subroutine\n+"}, {"sha": "3de77b0010653318ec214967a336fb298f631fa7", "filename": "gcc/testsuite/gfortran.dg/c-interop/c535b-1.f90", "status": "added", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535b-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535b-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535b-1.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,333 @@\n+! { dg-do compile}\n+! { dg-additional-options \"-fcoarray=single\" }\n+!\n+! TS 29113\n+! C535b An assumed-rank variable name shall not appear in a designator\n+! or expression except as an actual argument corresponding to a dummy \n+! argument that is assumed-rank, the argument of the C_LOC function\n+! in the ISO_C_BINDING intrinsic module, or the first argument in a\n+! reference to an intrinsic inquiry function.\n+!\n+! This has been renamed C838 in the Fortran 2018 standard, with C_SIZEOF\n+! and SELECT_RANK additionally added.\n+!\n+! This test file contains tests that are expected to all pass.\n+\n+! Check that passing an assumed-rank variable as an actual argument \n+! corresponding to an assumed-rank dummy works.\n+\n+module m\n+  interface\n+    subroutine g (a, b)\n+      implicit none\n+      real :: a(..)\n+      integer :: b\n+    end subroutine\n+  end interface\n+end module\n+\n+subroutine s0 (x)\n+  use m\n+  implicit none\n+  real :: x(..)\n+\n+  call g (x, 1)\n+end subroutine\n+\n+! Check that calls to the permitted intrinsic functions work.\n+\n+function test_c_loc (a)\n+  use iso_c_binding\n+  implicit none\n+  integer, target :: a(..)\n+  type(c_ptr) :: test_c_loc\n+\n+  test_c_loc = c_loc (a)\n+end function\n+\n+function test_allocated (a)\n+  implicit none\n+  integer, allocatable :: a(..)\n+  logical :: test_allocated\n+\n+  test_allocated = allocated (a)\n+end function\n+\n+! 2-argument forms of the associated intrinsic are tested in c535b-3.f90.\n+function test_associated (a)\n+  implicit none\n+  integer, pointer :: a(..)\n+  logical :: test_associated\n+\n+  test_associated = associated (a)\n+end function\n+\n+function test_bit_size (a)\n+  implicit none\n+  integer :: a(..)\n+  integer :: test_bit_size\n+\n+  test_bit_size = bit_size (a)\n+end function\n+\n+function test_digits (a)\n+  implicit none\n+  integer :: a(..)\n+  integer :: test_digits\n+\n+  test_digits = digits (a)\n+end function\n+\n+function test_epsilon (a)\n+  implicit none\n+  real :: a(..)\n+  real :: test_epsilon\n+\n+  test_epsilon = epsilon (a)\n+end function\n+\n+function test_huge (a)\n+  implicit none\n+  integer :: a(..)\n+  integer :: test_huge\n+\n+  test_huge = huge (a)\n+end function\n+\n+function test_is_contiguous (a)\n+  implicit none\n+  integer :: a(..)\n+  logical :: test_is_contiguous\n+\n+  test_is_contiguous = is_contiguous (a)\n+end function\n+\n+function test_kind (a)\n+  implicit none\n+  integer :: a(..)\n+  integer :: test_kind\n+\n+  test_kind = kind (a)\n+end function\n+\n+function test_lbound (a)\n+  implicit none\n+  integer :: a(..)\n+  integer :: test_lbound\n+\n+  test_lbound = lbound (a, 1)\n+end function\n+\n+function test_len1 (a)\n+  implicit none\n+  character(len=5) :: a(..)\n+  integer :: test_len1\n+\n+  test_len1 = len (a)\n+end function\n+\n+function test_len2 (a)\n+  implicit none\n+  character(len=*) :: a(..)\n+  integer :: test_len2\n+\n+  test_len2 = len (a)\n+end function\n+\n+function test_len3 (a)\n+  implicit none\n+  character(len=5), pointer :: a(..)\n+  integer :: test_len3\n+\n+  test_len3 = len (a)\n+end function\n+\n+function test_len4 (a)\n+  implicit none\n+  character(len=*), pointer :: a(..)\n+  integer :: test_len4\n+\n+  test_len4 = len (a)\n+end function\n+\n+function test_len5 (a)\n+  implicit none\n+  character(len=:), pointer :: a(..)\n+  integer :: test_len5\n+\n+  test_len5 = len (a)\n+end function\n+\n+function test_len6 (a)\n+  implicit none\n+  character(len=5), allocatable :: a(..)\n+  integer :: test_len6\n+\n+  test_len6 = len (a)\n+end function\n+\n+function test_len7 (a)\n+  implicit none\n+  character(len=*), allocatable :: a(..)\n+  integer :: test_len7\n+\n+  test_len7 = len (a)\n+end function\n+\n+function test_len8 (a)\n+  implicit none\n+  character(len=:), allocatable :: a(..)\n+  integer :: test_len8\n+\n+  test_len8 = len (a)\n+end function\n+\n+function test_maxexponent (a)\n+  implicit none\n+  real :: a(..)\n+  integer :: test_maxexponent\n+\n+  test_maxexponent = maxexponent (a)\n+end function\n+\n+function test_minexponent (a)\n+  implicit none\n+  real :: a(..)\n+  integer :: test_minexponent\n+\n+  test_minexponent = minexponent (a)\n+end function\n+\n+function test_new_line (a)\n+  implicit none\n+  character :: a(..)\n+  character :: test_new_line\n+\n+  test_new_line = new_line (a)\n+end function\n+\n+function test_precision (a)\n+  implicit none\n+  real :: a(..)\n+  integer :: test_precision\n+\n+  test_precision = precision (a)\n+end function\n+\n+function test_present (a, b, c)\n+  implicit none\n+  integer :: a, b\n+  integer, optional :: c(..)\n+  integer :: test_present\n+\n+  if (present (c)) then\n+    test_present = a\n+  else\n+    test_present = b\n+  end if\n+end function\n+\n+function test_radix (a)\n+  implicit none\n+  real :: a(..)\n+  integer :: test_radix\n+\n+  test_radix = radix (a)\n+end function\n+\n+function test_range (a)\n+  implicit none\n+  real :: a(..)\n+  integer :: test_range\n+\n+  test_range = range (a)\n+end function\n+\n+function test_rank (a)\n+  implicit none\n+  integer :: a(..)\n+  integer :: test_rank\n+\n+  test_rank = rank (a)\n+end function\n+\n+function test_shape (a)\n+  implicit none\n+  integer :: a(..)\n+  logical :: test_shape\n+\n+  test_shape = (rank (a) .eq. size (shape (a)))\n+end function\n+\n+function test_size (a)\n+  implicit none\n+  integer :: a(..)\n+  logical :: test_size\n+\n+  test_size = (size (a) .eq. product (shape (a)))\n+end function\n+\n+function test_storage_size (a)\n+  implicit none\n+  integer :: a(..)\n+  integer :: test_storage_size\n+\n+  test_storage_size = storage_size (a)\n+end function\n+\n+function test_tiny (a)\n+  implicit none\n+  real :: a(..)\n+  real :: test_tiny\n+\n+  test_tiny = tiny (a)\n+end function\n+\n+function test_ubound (a)\n+  implicit none\n+  integer :: a(..)\n+  integer :: test_ubound\n+\n+  test_ubound = ubound (a, 1)\n+end function\n+\n+! Note:  there are no tests for these inquiry functions that can't\n+! take an assumed-rank array argument for other reasons:\n+!\n+! coshape, lcobound, ucobound: requires CODIMENSION attribute, which is\n+!   not permitted on an assumed-rank variable.\n+!\n+! extends_type_of, same_type_as: require a class argument.\n+\n+\n+! F2018 additionally permits the first arg to C_SIZEOF to be\n+! assumed-rank (C838).\n+\n+function test_c_sizeof (a)\n+  use iso_c_binding\n+  implicit none\n+  integer :: a(..)\n+  integer :: test_c_sizeof\n+\n+  test_c_sizeof = c_sizeof (a)\n+end function\n+\n+! F2018 additionally permits an assumed-rank array as the selector\n+! in a SELECT RANK construct (C838).\n+\n+function test_select_rank (a)\n+  implicit none\n+  integer :: a(..)\n+  integer :: test_select_rank\n+\n+  select rank (a)\n+    rank (0)\n+      test_select_rank = 0\n+    rank (1)\n+      test_select_rank = 1\n+    rank (2)\n+      test_select_rank = 2\n+    rank default\n+      test_select_rank = -1\n+  end select\n+end function"}, {"sha": "7bff14fe9efe842baf603ed5556d809552c290df", "filename": "gcc/testsuite/gfortran.dg/c-interop/c535b-2.f90", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535b-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535b-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535b-2.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,387 @@\n+! PR 101334\n+! PR 101337\n+! { dg-do compile}\n+! { dg-additional-options \"-fcoarray=single\" }\n+!\n+! TS 29113\n+! C535b An assumed-rank variable name shall not appear in a designator\n+! or expression except as an actual argument corresponding to a dummy \n+! argument that is assumed-rank, the argument of the C_LOC function\n+! in the ISO_C_BINDING intrinsic module, or the first argument in a\n+! reference to an intrinsic inquiry function.\n+!\n+! This has been renamed C838 in the Fortran 2018 standard, with C_SIZEOF\n+! and SELECT_RANK additionally added.\n+!\n+! This test file contains tests that are expected to issue diagnostics\n+! for invalid code.\n+\n+! Check that passing an assumed-rank variable as an actual argument \n+! corresponding to a non-assumed-rank dummy gives a diagnostic.\n+\n+module m\n+  interface\n+    subroutine f (a, b)\n+      implicit none\n+      integer :: a\n+      integer :: b\n+    end subroutine\n+    subroutine g (a, b)\n+      implicit none\n+      integer :: a(..)\n+      integer :: b(..)\n+    end subroutine\n+    subroutine h (a, b)\n+      implicit none\n+      integer :: a(*)\n+      integer :: b(*)\n+    end subroutine\n+    subroutine i (a, b)\n+      implicit none\n+      integer :: a(:)\n+      integer :: b(:)\n+    end subroutine\n+    subroutine j (a, b)\n+      implicit none\n+      integer :: a(3,3)\n+      integer :: b(3,3)\n+    end subroutine\n+  end interface\n+end module\n+\n+subroutine test_calls (x, y)\n+  use m\n+  implicit none\n+  integer :: x(..), y(..)\n+\n+  ! Make sure each invalid argument produces a diagnostic.\n+  ! scalar dummies\n+  call f (x, &  ! { dg-error \"(A|a)ssumed.rank\" }\n+          y)  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+  ! assumed-rank dummies\n+  call g (x, y)  ! OK\n+  ! assumed-size dummies\n+  call h (x, &  ! { dg-error \"(A|a)ssumed.rank\" \"pr101334\" { xfail *-*-* } }\n+          y)  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+  ! assumed-shape dummies\n+  call i (x, &  ! { dg-error \"(A|a)ssumed.rank\" }\n+          y)  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+ ! fixed-size array dummies\n+  call j (x, &  ! { dg-error \"(A|a)ssumed.rank\" \"pr101334\" { xfail *-*-* } }\n+          y)  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+ ! { dg-bogus \"Actual argument contains too few elements\" \"pr101334\" { xfail *-*-* } .-2 }\n+end subroutine\n+\n+! Check that you can't use an assumed-rank array variable in an array\n+! element or section designator.\n+\n+subroutine test_designators (x)\n+  use m\n+  implicit none\n+  integer :: x(..)\n+\n+  call f (x(1), 1)  ! { dg-error \"(A|a)ssumed.rank\" }\n+  call g (x(1:3:1), &  ! { dg-error \"(A|a)ssumed.rank\" }\n+          x)  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+end subroutine\n+\n+! Check that you can't use an assumed-rank array variable in elemental\n+! expressions.  Make sure binary operators produce the error for either or\n+! both operands.\n+\n+subroutine test_expressions (a, b, c, l, m, n, x, y, z, p, q, r, s, i, j)\n+  implicit none\n+  integer :: a(..), b(..), c(..)\n+  logical :: l(..), m(..), n(..)\n+  integer :: x(s), y(s), z(s)\n+  logical :: p(s), q(s), r(s)\n+  integer :: s\n+  integer :: i\n+  logical :: j\n+\n+  ! Assignment\n+\n+  z = x  ! OK\n+  c &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = a  ! { dg-error \"(A|a)ssumed.rank\" }\n+  z = i  ! OK\n+  c = i  ! { dg-error \"(A|a)ssumed.rank\" }\n+\n+  r = p  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = l  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r = j  ! OK\n+  n = j  ! { dg-error \"(A|a)ssumed.rank\" }\n+\n+  ! Arithmetic\n+\n+  z = -x  ! OK\n+  c &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = -a  ! { dg-error \"(A|a)ssumed.rank\" }\n+  z = -i  ! OK\n+  c = -i  ! { dg-error \"(A|a)ssumed.rank\" }\n+\n+  z = x + y  ! OK\n+  c &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = a &  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+    + b  ! { dg-error \"(A|a)ssumed.rank\" }\n+  z = x + i  ! OK\n+  c &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = a + i  ! { dg-error \"(A|a)ssumed.rank\" }\n+  z = i + y  ! OK\n+  c &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = i + b  ! { dg-error \"(A|a)ssumed.rank\" }\n+\n+  z = x - y  ! OK\n+  c &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = a &  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+    - b  ! { dg-error \"(A|a)ssumed.rank\" }\n+  z = x - i  ! OK\n+  c &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = a - i  ! { dg-error \"(A|a)ssumed.rank\" }\n+  z = i - y  ! OK\n+  c &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = i - b  ! { dg-error \"(A|a)ssumed.rank\" }\n+\n+  z = x * y  ! OK\n+  c &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = a &  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+    * b  ! { dg-error \"(A|a)ssumed.rank\" }\n+  z = x * i  ! OK\n+  c &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = a * i  ! { dg-error \"(A|a)ssumed.rank\" }\n+  z = i * y  ! OK\n+  c &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = i * b  ! { dg-error \"(A|a)ssumed.rank\" }\n+\n+  z = x / y  ! OK\n+  c &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = a &  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+    / b  ! { dg-error \"(A|a)ssumed.rank\" }\n+  z = x / i  ! OK\n+  c &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = a / i  ! { dg-error \"(A|a)ssumed.rank\" }\n+  z = i / y  ! OK\n+  c &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = i / b  ! { dg-error \"(A|a)ssumed.rank\" }\n+\n+  z = x ** y  ! OK\n+  c &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = a &  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+    ** b  ! { dg-error \"(A|a)ssumed.rank\" }\n+  z = x ** i  ! OK\n+  c &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = a ** i  ! { dg-error \"(A|a)ssumed.rank\" }\n+  z = i ** y  ! OK\n+  c &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = i ** b  ! { dg-error \"(A|a)ssumed.rank\" }\n+\n+  ! Comparisons\n+\n+  r = x .eq. y  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = a &  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+    .eq. b  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r = x .eq. i  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = a .eq. i  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r = i .eq. y  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = i .eq. b  ! { dg-error \"(A|a)ssumed.rank\" }\n+\n+  r = x .ne. y  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = a &  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+    .ne. b  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r = x .ne. i  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = a .ne. i  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r = i .ne. y  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = i .ne. b  ! { dg-error \"(A|a)ssumed.rank\" }\n+\n+  r = x .lt. y  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = a &  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+    .lt. b  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r = x .lt. i  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = a .lt. i  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r = i .lt. y  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = i .lt. b  ! { dg-error \"(A|a)ssumed.rank\" }\n+\n+  r = x .le. y  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = a &  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+    .le. b  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r = x .le. i  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = a .le. i  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r = i .le. y  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = i .le. b  ! { dg-error \"(A|a)ssumed.rank\" }\n+\n+  r = x .gt. y  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = a &  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+    .gt. b  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r = x .gt. i  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = a .gt. i  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r = i .gt. y  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = i .gt. b  ! { dg-error \"(A|a)ssumed.rank\" }\n+\n+  r = x .ge. y  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = a &  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+    .ge. b  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r = x .ge. i  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = a .ge. i  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r = i .ge. y  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = i .ge. b  ! { dg-error \"(A|a)ssumed.rank\" }\n+\n+  ! Logical operators\n+\n+  r = .not. p  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = .not. l  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r = .not. j  ! OK\n+  n = .not. j  ! { dg-error \"(A|a)ssumed.rank\" }\n+\n+  r = p .and. q  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = l &  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+    .and. m  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r = p .and. j  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = l .and. j  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r = j .and. q  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = j .and. m  ! { dg-error \"(A|a)ssumed.rank\" }\n+\n+  r = p .or. q  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = l &  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+    .or. m  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r = p .or. j  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = l .or. j  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r = j .or. q  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = j .or. m  ! { dg-error \"(A|a)ssumed.rank\" }\n+\n+  r = p .eqv. q  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = l &  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+    .eqv. m  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r = p .eqv. j  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = l .eqv. j  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r = j .eqv. q  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = j .eqv. m  ! { dg-error \"(A|a)ssumed.rank\" }\n+\n+  r = p .neqv. q  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = l &  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+    .neqv. m  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r = p .neqv. j  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = l .neqv. j  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r = j .neqv. q  ! OK\n+  n &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = j .neqv. m  ! { dg-error \"(A|a)ssumed.rank\" }\n+\n+end subroutine  \n+\n+! Check that calls to disallowed intrinsic functions produce a diagnostic.\n+! There are 100+ \"elemental\" intrinsics defined in the standard, and\n+! 25+ \"transformational\" intrinsics that accept array operands, and that\n+! doesn't include intrinsics in the standard modules.  To keep the length of\n+! this test to something sane, check only a handful of these functions on \n+! the theory that related functions are probably implemented similarly and \n+! probably share the same argument-processing code.  \n+\n+subroutine test_intrinsics (i1, i2, r1, r2, c1, c2, l1, l2, s1, s2)\n+  implicit none\n+  integer :: i1(..), i2(..)\n+  real :: r1(..), r2(..)\n+  complex :: c1(..), c2(..)\n+  logical :: l1(..), l2(..)\n+  character :: s1(..), s2(..)\n+\n+  integer :: i\n+  real :: r\n+  logical :: l\n+\n+  ! trig, hyperbolic, other math functions\n+  r1 &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = atan2 (r1, &  ! { dg-error \"(A|a)ssumed.rank\" }\n+             r2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+  r1 &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = atan (r2)  ! { dg-error \"(A|a)ssumed.rank\" }\n+  c1 &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = atan (c2)  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r1 &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = cos (r2)  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r1 &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = exp (r2)  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r1 &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = sinh (r2)  ! { dg-error \"(A|a)ssumed.rank\" }\n+  \n+  ! bit operations\n+  l1 &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = blt (i1, &  ! { dg-error \"(A|a)ssumed.rank\" }\n+           i2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+  l1 &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = btest (i1, 0)  ! { dg-error \"(A|a)ssumed.rank\" }\n+  i1 &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = not (i2)  ! { dg-error \"(A|a)ssumed.rank\" }\n+  i1 &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = popcnt (i2)  ! { dg-error \"(A|a)ssumed.rank\" }\n+\n+  ! type conversions\n+  s1 &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = char (i1)  ! { dg-error \"(A|a)ssumed.rank\" }\n+  c1 &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = cmplx (r1, &  ! { dg-error \"(A|a)ssumed.rank\" }\n+             r2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+  i1 &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = floor (r1)  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r1 &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = real (c1)  ! { dg-error \"(A|a)ssumed.rank\" }\n+\n+  ! reductions\n+  l = any (l2)  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r = dot_product (r1, &  ! { dg-error \"(A|a)ssumed.rank\" }\n+                   r2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+  i = iall (i2, &  ! { dg-error \"(A|a)ssumed.rank\" }\n+            l2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+\n+  ! string operations\n+  s1 &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = adjustr (s2)  ! { dg-error \"(A|a)ssumed.rank\" }\n+  i1 &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = index (c1, &  ! { dg-error \"(A|a)ssumed.rank\" }\n+             c2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+\n+  ! misc\n+  i1 &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = cshift (i2, 4)  ! { dg-error \"(A|a)ssumed.rank\" }\n+  i = findloc (r1, 0.0)  ! { dg-error \"(A|a)ssumed.rank\" }\n+  r1 &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = matmul (r1, &  ! { dg-error \"(A|a)ssumed.rank\" }\n+              r2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+  r1 &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = reshape (r2, [10, 3])  ! { dg-error \"(A|a)ssumed.rank\" }\n+  i1 &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = sign (i1, &  ! { dg-error \"(A|a)ssumed.rank\" }\n+            i2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr101337, failure to diagnose both operands\" { xfail *-*-*} }\n+  s1 &  ! { dg-error \"(A|a)ssumed.rank\" }\n+    = transpose (s2)  ! { dg-error \"(A|a)ssumed.rank\" }\n+\n+end subroutine"}, {"sha": "6427bd658035ca8429133fe97853de3393bf70a4", "filename": "gcc/testsuite/gfortran.dg/c-interop/c535b-3.f90", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535b-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535b-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535b-3.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,79 @@\n+! PR 101334\n+! { dg-do compile}\n+! { dg-additional-options \"-fcoarray=single\" }\n+!\n+! TS 29113\n+! C535b An assumed-rank variable name shall not appear in a designator\n+! or expression except as an actual argument corresponding to a dummy \n+! argument that is assumed-rank, the argument of the C_LOC function\n+! in the ISO_C_BINDING intrinsic module, or the first argument in a\n+! reference to an intrinsic inquiry function.\n+!\n+! This has been renamed C838 in the Fortran 2018 standard, with C_SIZEOF\n+! and SELECT_RANK additionally added.\n+!\n+! This tests various forms of the 2-argument associated intrinsic.\n+\n+function test_associated2 (a, b)\n+  implicit none\n+  integer, pointer :: a(..)\n+  integer, target :: b(..)\n+  logical :: test_associated2\n+\n+  test_associated2 = associated (a, b) ! { dg-error \"Assumed.rank\" }\n+end function\n+\n+function test_associated3 (a, b)\n+  implicit none\n+  integer, pointer :: a(..)\n+  integer, target :: b\n+  logical :: test_associated3\n+\n+  test_associated3 = associated (a, b) ! { dg-bogus \"must be of rank -1\" \"pr101334\" { xfail *-*-* } }\n+end function\n+\n+function test_associated4 (a, b)\n+  implicit none\n+  integer, pointer :: a(..)\n+  integer, target :: b(:)\n+  logical :: test_associated4\n+\n+  test_associated4 = associated (a, b) ! { dg-bogus \"must be of rank -1\" \"pr101334\" { xfail *-*-* } }\n+end function\n+\n+function test_associated5 (a, b)\n+  implicit none\n+  integer, pointer :: a(..)\n+  integer, target :: b(20)\n+  logical :: test_associated5\n+\n+  test_associated5 = associated (a, b) ! { dg-bogus \"must be of rank -1\" \"pr101334\" { xfail *-*-* } }\n+end function\n+\n+function test_associated6 (a, b)\n+  implicit none\n+  integer, pointer :: a(..)\n+  integer, pointer :: b(..)\n+  logical :: test_associated6\n+\n+  test_associated6 = associated (a, b) ! { dg-error \"Assumed.rank\" }\n+end function\n+\n+function test_associated7 (a, b)\n+  implicit none\n+  integer, pointer :: a(..)\n+  integer, pointer :: b\n+  logical :: test_associated7\n+\n+  test_associated7 = associated (a, b) ! { dg-bogus \"must be of rank -1\" \"pr101334\" { xfail *-*-* } }\n+end function\n+\n+function test_associated8 (a, b)\n+  implicit none\n+  integer, pointer :: a(..)\n+  integer, pointer :: b(:)\n+  logical :: test_associated8\n+\n+  test_associated8 = associated (a, b) ! { dg-bogus \"must be of rank -1\" \"pr101334\" { xfail *-*-* } }\n+end function\n+"}, {"sha": "b4047139eaf027a07c2a55142ad42d7bdb3adc67", "filename": "gcc/testsuite/gfortran.dg/c-interop/c535c-1.f90", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-1.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,87 @@\n+! PR 54753\n+! { dg-do compile}\n+!\n+! TS 29113\n+! C535c If an assumed-size or nonallocatable nonpointer assumed-rank\n+! array is an actual argument corresponding to a dummy argument that \n+! is an INTENT(OUT) assumed-rank array, it shall not be polymorphic, [...].\n+!\n+! This constraint is numbered C839 in the Fortran 2018 standard.\n+!\n+! This test file contains tests that are expected to issue diagnostics\n+! for invalid code.\n+\n+module m\n+\n+  type :: t1\n+    integer :: id\n+    real :: xyz(3)\n+  end type\n+\n+contains\n+\n+  subroutine s1_nonpolymorphic (x, y)\n+    type(t1) :: x(..)\n+    type(t1), intent(out) :: y(..)\n+  end subroutine\n+\n+  subroutine s1_polymorphic (x, y)  ! { dg-bogus \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n+    class(t1) :: x(..)\n+    class(t1), intent(out) :: y(..)\n+  end subroutine\n+\n+  subroutine s1_unlimited_polymorphic (x, y)  ! { dg-bogus \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n+    class(*) :: x(..)\n+    class(*), intent(out) :: y(..)\n+  end subroutine\n+\n+  ! These calls should all be OK as they do not involve assumed-size or\n+  ! assumed-rank actual arguments.\n+  subroutine test_known_size (a1, a2, n)\n+    integer :: n\n+    type(t1) :: a1(n,n), a2(n)\n+\n+    call s1_nonpolymorphic (a1, a2)\n+    call s1_polymorphic (a1, a2)\n+    call s1_unlimited_polymorphic (a1, a2)\n+  end subroutine\n+\n+  ! The calls to the polymorphic functions should be rejected\n+  ! with an assumed-size array argument.\n+  subroutine test_assumed_size (a1, a2)\n+    type(t1) :: a1(*), a2(*)\n+\n+    call s1_nonpolymorphic (a1, a2)\n+    call s1_polymorphic (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n+    call s1_unlimited_polymorphic (a1, a2) ! { dg-error \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n+  end subroutine\n+\n+  ! These calls should be OK.\n+  subroutine test_assumed_rank_pointer (a1, a2)\n+    type(t1), pointer :: a1(..), a2(..)\n+\n+    call s1_nonpolymorphic (a1, a2)\n+    call s1_polymorphic (a1, a2)\n+    call s1_unlimited_polymorphic (a1, a2)\n+  end subroutine\n+\n+  ! These calls should be OK.\n+  subroutine test_assumed_rank_allocatable (a1, a2)\n+    type(t1), allocatable :: a1(..), a2(..)\n+\n+    call s1_nonpolymorphic (a1, a2)\n+    call s1_polymorphic (a1, a2)\n+    call s1_unlimited_polymorphic (a1, a2)\n+  end subroutine\n+  \n+  ! The calls to the polymorphic functions should be rejected\n+  ! with a nonallocatable nonpointer assumed-rank actual argument.\n+  subroutine test_assumed_rank_plain (a1, a2)\n+    type(t1) :: a1(..), a2(..)\n+\n+    call s1_nonpolymorphic (a1, a2)\n+    call s1_polymorphic (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n+    call s1_unlimited_polymorphic (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n+  end subroutine\n+\n+end module"}, {"sha": "db15ece98090375eb2dd3dbc13cc2bc49e199ed6", "filename": "gcc/testsuite/gfortran.dg/c-interop/c535c-2.f90", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-2.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,74 @@\n+! PR 54753\n+! { dg-do compile}\n+!\n+! TS 29113\n+! C535c If an assumed-size or nonallocatable nonpointer assumed-rank\n+! array is an actual argument corresponding to a dummy argument that \n+! is an INTENT(OUT) assumed-rank array, it shall not be [...] \n+! finalizable [...].\n+!\n+! This constraint is numbered C839 in the Fortran 2018 standard.\n+!\n+! This test file contains tests that are expected to issue diagnostics\n+! for invalid code.\n+\n+module m\n+\n+  type :: t1\n+    integer :: id\n+    real :: xyz(3)\n+  contains\n+    final :: finalize_t1\n+  end type\n+\n+contains\n+\n+  subroutine finalize_t1 (obj)\n+    type(t1) :: obj\n+  end subroutine\n+\n+  subroutine s1 (x, y)\n+    type(t1) :: x(..)\n+    type(t1), intent(out) :: y(..)\n+  end subroutine\n+\n+  ! This call should be OK as it does not involve assumed-size or\n+  ! assumed-rank actual arguments.\n+  subroutine test_known_size (a1, a2, n)\n+    integer :: n\n+    type(t1) :: a1(n,n), a2(n)\n+\n+    call s1 (a1, a2)\n+  end subroutine\n+\n+  ! Calls with an assumed-size array argument should be rejected.\n+  subroutine test_assumed_size (a1, a2)\n+    type(t1) :: a1(*), a2(*)\n+    \n+    call s1 (a1, a2)  !  { dg-error \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n+  end subroutine\n+\n+  ! This call should be OK.\n+  subroutine test_assumed_rank_pointer (a1, a2)\n+    type(t1), pointer :: a1(..), a2(..)\n+\n+    call s1 (a1, a2)\n+  end subroutine\n+\n+  ! This call should be OK.\n+  subroutine test_assumed_rank_allocatable (a1, a2)\n+    type(t1), allocatable :: a1(..), a2(..)\n+\n+    call s1 (a1, a2)\n+  end subroutine\n+  \n+  ! The call should be rejected with a nonallocatable nonpointer\n+  ! assumed-rank actual argument.\n+  subroutine test_assumed_rank_plain (a1, a2)\n+    type(t1) :: a1(..), a2(..)\n+\n+    call s1 (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n+  end subroutine\n+\n+end module\n+"}, {"sha": "5c224b1f8bd45806aa131395c40428d7d3d9431c", "filename": "gcc/testsuite/gfortran.dg/c-interop/c535c-3.f90", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-3.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,73 @@\n+! PR 54753\n+! { dg-do compile }\n+! { dg-ice \"pr54753\" }\n+!\n+! TS 29113\n+! C535c If an assumed-size or nonallocatable nonpointer assumed-rank\n+! array is an actual argument corresponding to a dummy argument that \n+! is an INTENT(OUT) assumed-rank array, it shall not be [...] \n+! of a type with an allocatable ultimate component [...].\n+!\n+! This constraint is numbered C839 in the Fortran 2018 standard.\n+!\n+! This test file contains tests that are expected to issue diagnostics\n+! for invalid code.\n+\n+module m\n+\n+  type :: t1\n+    integer :: id\n+    real :: xyz(3)\n+    character, allocatable :: notes\n+  end type\n+\n+contains\n+\n+  subroutine finalize_t1 (obj)\n+    type(t1) :: obj\n+  end subroutine\n+\n+  subroutine s1 (x, y)\n+    type(t1) :: x(..)\n+    type(t1), intent(out) :: y(..)\n+  end subroutine\n+\n+  ! This call should be OK as it does not involve assumed-size or\n+  ! assumed-rank actual arguments.\n+  subroutine test_known_size (a1, a2, n)\n+    integer :: n\n+    type(t1) :: a1(n,n), a2(n)\n+\n+    call s1 (a1, a2)\n+  end subroutine\n+\n+  ! Calls with an assumed-size array argument should be rejected.\n+  subroutine test_assumed_size (a1, a2)\n+    type(t1) :: a1(*), a2(*)\n+    \n+    call s1 (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n+  end subroutine\n+\n+  ! This call should be OK.\n+  subroutine test_assumed_rank_pointer (a1, a2)\n+    type(t1), pointer :: a1(..), a2(..)\n+\n+    call s1 (a1, a2)\n+  end subroutine\n+\n+  ! This call should be OK.\n+  subroutine test_assumed_rank_allocatable (a1, a2)\n+    type(t1), allocatable :: a1(..), a2(..)\n+\n+    call s1 (a1, a2)\n+  end subroutine\n+  \n+  ! The call should be rejected with a nonallocatable nonpointer\n+  ! assumed-rank actual argument.\n+  subroutine test_assumed_rank_plain (a1, a2)\n+    type(t1) :: a1(..), a2(..)\n+\n+    call s1 (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n+  end subroutine\n+\n+end module"}, {"sha": "ecbb18187dd73a347cdec0a36717ec16bb3a0733", "filename": "gcc/testsuite/gfortran.dg/c-interop/c535c-4.f90", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fc535c-4.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,73 @@\n+! PR 54753\n+! { dg-do compile }\n+! { dg-ice \"pr54753\" }\n+!\n+! TS 29113\n+! C535c If an assumed-size or nonallocatable nonpointer assumed-rank\n+! array is an actual argument corresponding to a dummy argument that \n+! is an INTENT(OUT) assumed-rank array, it shall not be [...] \n+! of a type for which default initialization is specified.\n+!\n+! This constraint is numbered C839 in the Fortran 2018 standard.\n+!\n+! This test file contains tests that are expected to issue diagnostics\n+! for invalid code.\n+\n+module m\n+\n+  type :: t1\n+    integer :: id\n+    real :: xyz(3)\n+    integer :: tag = -1\n+  end type\n+\n+contains\n+\n+  subroutine finalize_t1 (obj)\n+    type(t1) :: obj\n+  end subroutine\n+\n+  subroutine s1 (x, y)\n+    type(t1) :: x(..)\n+    type(t1), intent(out) :: y(..)\n+  end subroutine\n+\n+  ! This call should be OK as it does not involve assumed-size or\n+  ! assumed-rank actual arguments.\n+  subroutine test_known_size (a1, a2, n)\n+    integer :: n\n+    type(t1) :: a1(n,n), a2(n)\n+\n+    call s1 (a1, a2)\n+  end subroutine\n+\n+  ! Calls with an assumed-size array argument should be rejected.\n+  subroutine test_assumed_size (a1, a2)\n+    type(t1) :: a1(*), a2(*)\n+    \n+    call s1 (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n+  end subroutine\n+\n+  ! This call should be OK.\n+  subroutine test_assumed_rank_pointer (a1, a2)\n+    type(t1), pointer :: a1(..), a2(..)\n+\n+    call s1 (a1, a2)\n+  end subroutine\n+\n+  ! This call should be OK.\n+  subroutine test_assumed_rank_allocatable (a1, a2)\n+    type(t1), allocatable :: a1(..), a2(..)\n+\n+    call s1 (a1, a2)\n+  end subroutine\n+  \n+  ! The call should be rejected with a nonallocatable nonpointer\n+  ! assumed-rank actual argument.\n+  subroutine test_assumed_rank_plain (a1, a2)\n+    type(t1) :: a1(..), a2(..)\n+\n+    call s1 (a1, a2)  ! { dg-error \"(A|a)ssumed.rank\" \"pr54753\" { xfail *-*-* } }\n+  end subroutine\n+\n+end module"}, {"sha": "3ff3a8d1ec859a708176b69254f487a7b7117179", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-descriptor-1-c.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-1-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-1-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-1-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,91 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *a);\n+extern void ftest (CFI_cdesc_t *a, CFI_cdesc_t *b);\n+\n+struct m {\n+  int i;\n+  int j;\n+};\n+\n+#define imax 10\n+#define jmax 5\n+\n+void\n+ctest (CFI_cdesc_t *a)\n+{\n+  \n+  struct m bdata[imax][jmax];\n+  CFI_CDESC_T(2) bdesc;\n+  CFI_cdesc_t *b = (CFI_cdesc_t *) &bdesc;\n+  int i, j;\n+  CFI_index_t subscripts[2];\n+  struct m* mp;\n+\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+\n+  if (a->rank != 2)\n+    abort ();\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+  if (a->dim[0].lower_bound != 0)\n+    abort ();\n+  if (a->dim[0].extent != imax)\n+    abort ();\n+  if (a->dim[1].lower_bound != 0)\n+    abort ();\n+  if (a->dim[1].extent != jmax)\n+    abort ();\n+\n+  /* Transpose a's contents into bdata.  */\n+  for (j = 0; j < jmax; j++)\n+    {\n+      subscripts[1] = j;\n+      for (i = 0; i < imax; i++)\n+\t{\n+\t  subscripts[0] = i;\n+\t  mp = (struct m *) CFI_address (a, subscripts);\n+\t  if (mp->i != i + 1)\n+\t    abort ();\n+\t  if (mp->j != j + 1)\n+\t    abort ();\n+\t  bdata[i][j].i = mp->i;\n+\t  bdata[i][j].j = mp->j;\n+\t}\n+    }\n+\n+  /* Fill in bdesc.  */\n+  subscripts[0] = jmax;\n+  subscripts[1] = imax;\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (b, bdata, CFI_attribute_other,\n+\t\t\t\t   CFI_type_struct,\n+\t\t\t\t   sizeof (struct m), 2, subscripts));\n+  \n+  /* Sanity checking to make sure the descriptor has been initialized\n+     properly.  */\n+  dump_CFI_cdesc_t (b);\n+  if (b->version != CFI_VERSION)\n+    abort ();\n+  if (b->rank != 2)\n+    abort ();\n+  if (b->attribute != CFI_attribute_other)\n+    abort ();\n+  if (b->dim[0].lower_bound != 0)\n+    abort ();\n+  if (b->dim[0].extent != jmax)\n+    abort ();\n+  if (b->dim[1].lower_bound != 0)\n+    abort ();\n+  if (b->dim[1].extent != imax)\n+    abort ();\n+\n+  /* Call back into Fortran, passing both the a and b arrays.  */\n+  ftest (a, b);\n+}"}, {"sha": "f52a631b157424024e5de9335a4c95713ed6b7c7", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-descriptor-1.f90", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-1.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,66 @@\n+! { dg-do run }\n+! { dg-additional-sources \"cf-descriptor-1-c.c dump-descriptors.c\" }\n+!\n+! This program checks that building a descriptor for a fixed-size array\n+! in C works and that you can use it to call back into a Fortran function\n+! declared to have c binding, as an assumed-shape argument.\n+\n+module mm\n+  use iso_c_binding\n+  type, bind (c) :: m\n+    integer(C_INT) :: i, j\n+  end type\n+\n+  integer, parameter :: imax=10, jmax=5\n+end module\n+\n+subroutine ftest (a, b) bind (c, name=\"ftest\")\n+  use iso_c_binding\n+  use mm\n+  type(m) :: a(:,:), b(:,:)\n+  integer :: i, j\n+\n+  if (size (a,1) .ne. imax) stop 101\n+  if (size (a,2) .ne. jmax) stop 102\n+  if (size (b,1) .ne. jmax) stop 103\n+  if (size (b,2) .ne. imax) stop 104\n+\n+  do j = 1, jmax\n+    do i = 1, imax\n+      if (a(i,j)%i .ne. i) stop 201\n+      if (a(i,j)%j .ne. j) stop 202\n+      if (b(j,i)%i .ne. i) stop 203\n+      if (b(j,i)%j .ne. j) stop 204\n+    end do\n+  end do\n+end subroutine\n+\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  interface\n+    subroutine ctest (a) bind (c)\n+      use iso_c_binding\n+      use mm\n+      type(m) :: a(:,:)\n+    end subroutine\n+  end interface\n+\n+  type(m) :: aa(imax,jmax)\n+  integer :: i, j\n+  do j = 1, jmax\n+    do i = 1, imax\n+      aa(i,j)%i = i\n+      aa(i,j)%j = j\n+    end do\n+  end do\n+\n+  ! Pass the initialized array to a C function ctest, which will generate its\n+  ! transpose and call ftest with it.\n+\n+  call ctest (aa)\n+\n+end program"}, {"sha": "a4be5a71dfcc579316b139b0f8cb3b5a2627efe4", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-descriptor-2-c.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-2-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-2-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-2-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,91 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *a);\n+extern void ftest (CFI_cdesc_t *a, CFI_cdesc_t *b);\n+\n+struct m {\n+  int i;\n+  int j;\n+};\n+\n+#define imax 10\n+#define jmax 5\n+\n+void\n+ctest (CFI_cdesc_t *a)\n+{\n+  \n+  struct m bdata[imax][jmax];\n+  CFI_CDESC_T(2) bdesc;\n+  CFI_cdesc_t *b = (CFI_cdesc_t *) &bdesc;\n+  int i, j;\n+  CFI_index_t subscripts[2];\n+  struct m* mp;\n+\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+\n+  if (a->rank != 2)\n+    abort ();\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+  if (a->dim[0].lower_bound != 0)\n+    abort ();\n+  if (a->dim[0].extent != imax)\n+    abort ();\n+  if (a->dim[1].lower_bound != 0)\n+    abort ();\n+  if (a->dim[1].extent != jmax)\n+    abort ();\n+\n+  /* Transpose a's contents into bdata.  */\n+  for (j = 0; j < jmax; j++)\n+    {\n+      subscripts[1] = j;\n+      for (i = 0; i < imax; i++)\n+\t{\n+\t  subscripts[0] = i;\n+\t  mp = (struct m *) CFI_address (a, subscripts);\n+\t  if (mp->i != i + 1)\n+\t    abort ();\n+\t  if (mp->j != j + 1)\n+\t    abort ();\n+\t  bdata[i][j].i = mp->i;\n+\t  bdata[i][j].j = mp->j;\n+\t}\n+    }\n+\n+  /* Fill in bdesc.  */\n+  subscripts[0] = jmax;\n+  subscripts[1] = imax;\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (b, bdata, CFI_attribute_other,\n+\t\t\t\t   CFI_type_struct,\n+\t\t\t\t   sizeof (struct m), 2, subscripts));\n+\n+  /* Sanity checking to make sure the descriptor has been initialized\n+     properly.  */\n+  dump_CFI_cdesc_t (b);\n+  if (b->version != CFI_VERSION)\n+    abort ();\n+  if (b->rank != 2)\n+    abort ();\n+  if (b->attribute != CFI_attribute_other)\n+    abort ();\n+  if (b->dim[0].lower_bound != 0)\n+    abort ();\n+  if (b->dim[0].extent != jmax)\n+    abort ();\n+  if (b->dim[1].lower_bound != 0)\n+    abort ();\n+  if (b->dim[1].extent != imax)\n+    abort ();\n+\n+  /* Call back into Fortran, passing both the a and b arrays.  */\n+  ftest (a, b);\n+}"}, {"sha": "a4231fa60452183e709b0b9c83b26462911127ce", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-descriptor-2.f90", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-2.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,82 @@\n+! PR 93308\n+! { dg-do run }\n+! { dg-additional-sources \"cf-descriptor-2-c.c dump-descriptors.c\" }\n+!\n+! This program checks that building a descriptor for a fixed-size array\n+! in C works and that you can use it to call back into a Fortran function\n+! declared to have c binding, as an assumed-rank argument.\n+! \n+! Fixed by\n+! https://gcc.gnu.org/pipermail/gcc-patches/2021-June/572725.html\n+\n+module mm\n+  use iso_c_binding\n+  type, bind (c) :: m\n+    integer(C_INT) :: i, j\n+  end type\n+\n+  integer, parameter :: imax=10, jmax=5\n+end module\n+\n+subroutine ftest (a, b) bind (c, name=\"ftest\")\n+  use iso_c_binding\n+  use mm\n+  type(m) :: a(..), b(..)\n+  integer :: i, j\n+\n+  select rank (a)\n+    rank (2)\n+      select rank (b)\n+        rank (2)\n+\t  ! print *, lbound(a,1), ubound(a,1), lbound(a,2), ubound(a,2)\n+\t  ! print *, lbound(b,1), ubound(b,1), lbound(b,2), ubound(b,2)\n+          if (lbound (a,1) .ne. 1 .or. ubound (a,1) .ne. imax) stop 101\n+          if (lbound (a,2) .ne. 1 .or. ubound (a,2) .ne. jmax) stop 102\n+          if (lbound (b,1) .ne. 1 .or. ubound (b,1) .ne. jmax) stop 103\n+          if (lbound (b,2) .ne. 1 .or. ubound (b,2) .ne. imax) stop 104\n+\t  do j = 1, jmax\n+\t    do i = 1, imax\n+\t      print *, a(i,j)%i, a(i,j)%j, b(j,i)%i, b(j,i)%j\n+\t      if (a(i,j)%i .ne. i) stop 105\n+\t      if (a(i,j)%j .ne. j) stop 106\n+\t      if (b(j,i)%i .ne. i) stop 107\n+\t      if (b(j,i)%j .ne. j) stop 108\n+            end do\n+\t  end do\n+        rank default\n+          stop 106\n+      end select\n+    rank default\n+      stop 107\n+  end select\n+end subroutine\n+\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  interface\n+    subroutine ctest (a) bind (c)\n+      use iso_c_binding\n+      use mm\n+      type(m) :: a(..)\n+    end subroutine\n+  end interface\n+\n+  type(m) :: aa(imax,jmax)\n+  integer :: i, j\n+  do j = 1, jmax\n+    do i = 1, imax\n+      aa(i,j)%i = i\n+      aa(i,j)%j = j\n+    end do\n+  end do\n+\n+  ! Pass the initialized array to a C function ctest, which will generate its\n+  ! transpose and call ftest with it.\n+\n+  call ctest (aa)\n+\n+end program"}, {"sha": "b947377b2916c8f2add81a9b8fba094d5eccff5a", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-descriptor-3-c.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-3-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-3-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-3-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,92 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (int imagic, int jmagic);\n+extern void ftest (CFI_cdesc_t *a, CFI_cdesc_t *b, int initp);\n+\n+struct m {\n+  int i;\n+  int j;\n+};\n+\n+void\n+ctest (int imagic, int jmagic)\n+{\n+  CFI_CDESC_T(0) adesc;\n+  CFI_CDESC_T(0) bdesc;\n+  CFI_cdesc_t *a = (CFI_cdesc_t *) &adesc;\n+  CFI_cdesc_t *b = (CFI_cdesc_t *) &bdesc;\n+  struct m* mp;\n+\n+  /* Create the descriptor for a, then sanity-check it.  */\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (a, NULL, CFI_attribute_allocatable,\n+\t\t\t\t   CFI_type_struct,\n+\t\t\t\t   sizeof (struct m), 0, NULL));\n+  dump_CFI_cdesc_t (a);\n+  if (a->version != CFI_VERSION)\n+    abort ();\n+  if (a->rank != 0)\n+    abort ();\n+  if (a->attribute != CFI_attribute_allocatable)\n+    abort ();\n+  if (a->base_addr)\n+    abort ();\n+  if (a->elem_len != sizeof (struct m))\n+    abort ();\n+\n+  /* Likewise for b.  */\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (b, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_struct,\n+\t\t\t\t   sizeof (struct m), 0, NULL));\n+  dump_CFI_cdesc_t (b);\n+  if (b->version != CFI_VERSION)\n+    abort ();\n+  if (b->rank != 0)\n+    abort ();\n+  if (b->attribute != CFI_attribute_pointer)\n+    abort ();\n+  if (b->base_addr)\n+    abort ();\n+  if (b->elem_len != sizeof (struct m))\n+    abort ();\n+\n+  /* Call back into Fortran, passing the unallocated descriptors.  */\n+  ftest (a, b, 0);\n+\n+  /* Allocate and initialize both variables, and try again.  */\n+  check_CFI_status (\"CFI_allocate\",\n+\t\t    CFI_allocate (a, NULL, NULL, 0));\n+  dump_CFI_cdesc_t (a);\n+  if (!a->base_addr)\n+    abort ();\n+  if (a->elem_len != sizeof (struct m))\n+    abort ();\n+  ((struct m *)a->base_addr)->i = imagic;\n+  ((struct m *)a->base_addr)->j = jmagic;\n+\n+  check_CFI_status (\"CFI_allocate\",\n+\t\t    CFI_allocate (b, NULL, NULL, 0));\n+  dump_CFI_cdesc_t (b);\n+  if (!b->base_addr)\n+    abort ();\n+  if (b->elem_len != sizeof (struct m))\n+    abort ();\n+  ((struct m *)b->base_addr)->i = imagic + 1;\n+  ((struct m *)b->base_addr)->j = jmagic + 1;\n+\n+  ftest (a, b, 1);\n+\n+  /* Deallocate both objects and try again.  */\n+  check_CFI_status (\"CFI_deallocate\", CFI_deallocate (a));\n+  if (a->base_addr)\n+    abort ();\n+  check_CFI_status (\"CFI_deallocate\", CFI_deallocate (b));\n+  if (b->base_addr)\n+    abort ();\n+  ftest (a, b, 0);\n+}"}, {"sha": "7a0839503696df758c994dbcd50f296d72cd8a92", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-descriptor-3.f90", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-3.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,58 @@\n+! { dg-do run }\n+! { dg-additional-sources \"cf-descriptor-3-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program checks that building a descriptor for an allocatable\n+! or pointer scalar argument in C works and that you can use it to call \n+! back into a Fortran function declared to have c binding.\n+\n+module mm\n+  use iso_c_binding\n+  type, bind (c) :: m\n+    integer(C_INT) :: i, j\n+  end type\n+\n+  integer(C_INT), parameter :: imagic = 42, jmagic = 69\n+end module\n+\n+subroutine ftest (a, b, initp) bind (c, name=\"ftest\")\n+  use iso_c_binding\n+  use mm\n+  type(m), allocatable :: a\n+  type(m), pointer :: b\n+  integer(C_INT), value :: initp\n+\n+  if (rank(a) .ne. 0) stop 101\n+  if (rank(b) .ne. 0) stop 101\n+\n+  if (initp .ne. 0 .and. .not. allocated(a))  stop 102\n+  if (initp .eq. 0 .and. allocated(a)) stop 103\n+  if (initp .ne. 0 .and. .not. associated(b))  stop 104\n+  if (initp .eq. 0 .and. associated(b)) stop 105\n+\n+  if (initp .ne. 0) then\n+    if (a%i .ne. imagic) stop 201\n+    if (a%j .ne. jmagic) stop 202\n+    if (b%i .ne. imagic + 1) stop 203\n+    if (b%j .ne. jmagic + 1) stop 204\n+  end if\n+end subroutine\n+\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  interface\n+    subroutine ctest (i, j) bind (c)\n+      use iso_c_binding\n+      integer(C_INT), value :: i, j\n+    end subroutine\n+  end interface\n+\n+  ! ctest will call ftest with both an unallocated and allocated argument.\n+\n+  call ctest (imagic, jmagic)\n+\n+end program"}, {"sha": "b941318ed242b204a8a6b971d649141ac099670a", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-descriptor-4-c.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-4-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-4-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-4-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,112 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (int imagic, int jmagic);\n+extern void ftest (CFI_cdesc_t *a, CFI_cdesc_t *b, int initp);\n+\n+struct m {\n+  int i;\n+  int j;\n+};\n+\n+void\n+ctest (int imax, int jmax)\n+{\n+  CFI_CDESC_T(2) adesc;\n+  CFI_CDESC_T(2) bdesc;\n+  CFI_cdesc_t *a = (CFI_cdesc_t *) &adesc;\n+  CFI_cdesc_t *b = (CFI_cdesc_t *) &bdesc;\n+  struct m* mp;\n+  CFI_index_t lower[2], upper[2], subscripts[2];\n+  CFI_index_t i, j;\n+\n+  /* Create the descriptor for a, then sanity-check it.  */\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (a, NULL, CFI_attribute_allocatable,\n+\t\t\t\t   CFI_type_struct,\n+\t\t\t\t   sizeof (struct m), 2, NULL));\n+  dump_CFI_cdesc_t (a);\n+  if (a->version != CFI_VERSION)\n+    abort ();\n+  if (a->rank != 2)\n+    abort ();\n+  if (a->attribute != CFI_attribute_allocatable)\n+    abort ();\n+  if (a->base_addr)\n+    abort ();\n+  if (a->elem_len != sizeof (struct m))\n+    abort ();\n+\n+  /* Likewise for b.  */\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (b, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_struct,\n+\t\t\t\t   sizeof (struct m), 2, NULL));\n+  dump_CFI_cdesc_t (b);\n+  if (b->version != CFI_VERSION)\n+    abort ();\n+  if (b->rank != 2)\n+    abort ();\n+  if (b->attribute != CFI_attribute_pointer)\n+    abort ();\n+  if (b->base_addr)\n+    abort ();\n+  if (b->elem_len != sizeof (struct m))\n+    abort ();\n+\n+  /* Call back into Fortran, passing the unallocated descriptors.  */\n+  ftest (a, b, 0);\n+\n+  /* Allocate and initialize both variables, and try again.  */\n+  lower[0] = 1;\n+  lower[1] = 1;\n+  upper[0] = imax;\n+  upper[1] = jmax;\n+\n+  check_CFI_status (\"CFI_allocate\",\n+\t\t    CFI_allocate (a, lower, upper, 0));\n+  dump_CFI_cdesc_t (a);\n+  if (!a->base_addr)\n+    abort ();\n+  if (a->elem_len != sizeof (struct m))\n+    abort ();\n+\n+  upper[0] = jmax;\n+  upper[1] = imax;\n+  check_CFI_status (\"CFI_allocate\",\n+\t\t    CFI_allocate (b, lower, upper, 0));\n+  dump_CFI_cdesc_t (b);\n+  if (!b->base_addr)\n+    abort ();\n+  if (b->elem_len != sizeof (struct m))\n+    abort ();\n+\n+  for (i = 1; i <= imax; i++)\n+    for (j = 1; j <= jmax; j++)\n+      {\n+\tsubscripts[0] = i;\n+\tsubscripts[1] = j;\n+\tmp = (struct m *) CFI_address (a, subscripts);\n+\tmp->i = i;\n+\tmp->j = j;\n+\tsubscripts[0] = j;\n+\tsubscripts[1] = i;\n+\tmp = (struct m *) CFI_address (b, subscripts);\n+\tmp->i = i;\n+\tmp->j = j;\n+      }\n+\n+  ftest (a, b, 1);\n+\n+  /* Deallocate both objects and try again.  */\n+  check_CFI_status (\"CFI_deallocate\", CFI_deallocate (a));\n+  if (a->base_addr)\n+    abort ();\n+  check_CFI_status (\"CFI_deallocate\", CFI_deallocate (b));\n+  if (b->base_addr)\n+    abort ();\n+  ftest (a, b, 0);\n+}"}, {"sha": "c05f2e38dbc1ff39d86cd7047d65fc99932ee84e", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-descriptor-4.f90", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-4.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,73 @@\n+! { dg-do run }\n+! { dg-additional-sources \"cf-descriptor-4-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program checks that building a descriptor for an allocatable\n+! or pointer array argument in C works and that you can use it to call \n+! back into a Fortran function declared to have c binding.\n+\n+module mm\n+  use iso_c_binding\n+  type, bind (c) :: m\n+    integer(C_INT) :: i, j\n+  end type\n+\n+  integer(C_INT), parameter :: imax=3, jmax=6\n+end module\n+\n+subroutine ftest (a, b, initp) bind (c, name=\"ftest\")\n+  use iso_c_binding\n+  use mm\n+  type(m), allocatable :: a(:,:)\n+  type(m), pointer :: b(:,:)\n+  integer(C_INT), value :: initp\n+  integer :: i, j\n+\n+  if (rank(a) .ne. 2) stop 101\n+  if (rank(b) .ne. 2) stop 101\n+\n+  if (initp .ne. 0 .and. .not. allocated(a))  stop 102\n+  if (initp .eq. 0 .and. allocated(a)) stop 103\n+  if (initp .ne. 0 .and. .not. associated(b))  stop 104\n+  if (initp .eq. 0 .and. associated(b)) stop 105\n+\n+  if (initp .ne. 0) then\n+    if (lbound (a, 1) .ne. 1) stop 201\n+    if (lbound (a, 2) .ne. 1) stop 202\n+    if (lbound (b, 2) .ne. 1) stop 203\n+    if (lbound (b, 1) .ne. 1) stop 204\n+    if (ubound (a, 1) .ne. imax) stop 205\n+    if (ubound (a, 2) .ne. jmax) stop 206\n+    if (ubound (b, 2) .ne. imax) stop 207\n+    if (ubound (b, 1) .ne. jmax) stop 208\n+\n+    do i = 1, imax\n+      do j = 1, jmax\n+        if (a(i,j)%i .ne. i) stop 301\n+        if (a(i,j)%j .ne. j) stop 302\n+        if (b(j,i)%i .ne. i) stop 303\n+        if (b(j,i)%j .ne. j) stop 303\n+      end do\n+    end do\n+    \n+  end if\n+end subroutine\n+\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  interface\n+    subroutine ctest (i, j) bind (c)\n+      use iso_c_binding\n+      integer(C_INT), value :: i, j\n+    end subroutine\n+  end interface\n+\n+  ! ctest will call ftest with both an unallocated and allocated argument.\n+\n+  call ctest (imax, jmax)\n+\n+end program"}, {"sha": "0cd92e789009177c54e4e0ea1f8d1fa4f008aa98", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-descriptor-5-c.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-5-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-5-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-5-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,36 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (int n);\n+extern void ftest (CFI_cdesc_t *a, int n);\n+\n+void\n+ctest (int n)\n+{\n+  CFI_CDESC_T(0) adesc;\n+  CFI_cdesc_t *a = (CFI_cdesc_t *) &adesc;\n+  char *adata = (char *) alloca (n);\n+\n+  /* Fill in adesc.  */\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (a, adata, CFI_attribute_other,\n+\t\t\t\t   CFI_type_char, n, 0, NULL));\n+\n+  /* Sanity checking to make sure the descriptor has been initialized\n+     properly.  */\n+  dump_CFI_cdesc_t (a);\n+  if (a->version != CFI_VERSION)\n+    abort ();\n+  if (a->rank != 0)\n+    abort ();\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+  if (a->elem_len != n)\n+    abort ();\n+  \n+  /* Call back into Fortran.  */\n+  ftest (a, n);\n+}"}, {"sha": "f178bb8d73321a0f2ea5c0022cb8c26a01f0992f", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-descriptor-5.f90", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-5.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,31 @@\n+! PR92482\n+! { dg-do run }\n+! { dg-additional-sources \"cf-descriptor-5-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program checks that building a descriptor for a character object \n+! in C works and that you can use it to call back into a Fortran function \n+! with an assumed-length dummy that is declared with C binding.\n+\n+subroutine ftest (a, n) bind (c, name=\"ftest\")  ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+  use iso_c_binding\n+  character(kind=C_CHAR, len=*) :: a\n+  integer(C_INT), value :: n\n+\n+  if (len (a) .ne. n) stop 101\n+end subroutine\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+    subroutine ctest (n) bind (c)\n+      use iso_c_binding\n+      integer(C_INT), value :: n\n+    end subroutine\n+  end interface\n+\n+  call ctest (42)\n+\n+end program"}, {"sha": "168087be3aeb3e504f0464e5eab06866b40e4e76", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-descriptor-6-c.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-6-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-6-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-6-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,81 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *a, int lb1, int lb2, int ub1, int ub2, int step1, int step2);\n+extern void ftest (CFI_cdesc_t *b);\n+\n+struct m {\n+  int i;\n+  int j;\n+};\n+\n+void\n+ctest (CFI_cdesc_t *a, int lb1, int lb2, int ub1, int ub2,\n+       int step1, int step2)\n+{\n+  CFI_CDESC_T(2) bdesc;\n+  CFI_cdesc_t *b = (CFI_cdesc_t *) &bdesc;\n+  CFI_index_t lb[2], ub[2], step[2];\n+  int i, j;\n+\n+  fprintf (stderr, \"got new bound info (%d:%d:%d, %d:%d:%d)\\n\",\n+\t   lb1, ub1, step1, lb2, ub2, step2);\n+  lb[0] = lb1 - 1;\n+  lb[1] = lb2 - 1;\n+  ub[0] = ub1 - 1;\n+  ub[1] = ub2 - 1;\n+  step[0] = step1;\n+  step[1] = step2;\n+\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+\n+  if (a->rank != 2)\n+    abort ();\n+\n+  /* Fill in bdesc.  */\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (b, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_struct,\n+\t\t\t\t   sizeof (struct m), 2, NULL));\n+  check_CFI_status (\"CFI_section\",\n+\t\t    CFI_section (b, a, lb, ub, step));\n+  \n+  /* Sanity checking to make sure the descriptor has been initialized\n+     properly.  */\n+  dump_CFI_cdesc_t (b);\n+  if (b->version != CFI_VERSION)\n+    abort ();\n+  if (b->rank != 2)\n+    abort ();\n+  if (b->attribute != CFI_attribute_pointer)\n+    abort ();\n+  if (!b->base_addr)\n+    abort ();\n+  if (CFI_is_contiguous (b))\n+    abort ();\n+\n+  for (j = b->dim[1].lower_bound;\n+       j < b->dim[1].lower_bound + b->dim[1].extent;\n+       j++)\n+    {\n+      for (i = b->dim[0].lower_bound;\n+\t   i < b->dim[0].lower_bound + b->dim[0].extent;\n+\t   i++)\n+\t{\n+\t  CFI_index_t subscripts[2];\n+\t  struct m *mp;\n+\t  subscripts[0] = i;\n+\t  subscripts[1] = j;\n+\t  mp = (struct m *) CFI_address (b, subscripts);\n+\t  fprintf (stderr, \"b(%d,%d) = (%d,%d)\\n\", i, j, mp->i, mp->j);\n+\t}\n+    }\n+\n+  /* Call back into Fortran.  */\n+  ftest (b);\n+}"}, {"sha": "57164946090c2ceae405dc789f33063951393297", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-descriptor-6.f90", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-6.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,72 @@\n+! { dg-do run }\n+! { dg-additional-sources \"cf-descriptor-6-c.c dump-descriptors.c\" }\n+!\n+! This program tests passing the result of the CFI_section C library\n+! routine back to Fortran.  Most of the work happens on the C side.\n+\n+module mm\n+  use iso_c_binding\n+  type, bind (c) :: m\n+    integer(C_INT) :: i, j\n+  end type\n+\n+  integer, parameter :: imax=10, jmax=5\n+  integer, parameter :: ilb=2, jlb=1\n+  integer, parameter :: iub=8, jub=5\n+  integer, parameter :: istep=3, jstep=2\n+  integer, parameter :: isize=3, jsize=3\n+end module\n+\n+subroutine ftest (b) bind (c, name=\"ftest\")\n+  use iso_c_binding\n+  use mm\n+  type(m), pointer :: b(:,:)\n+  integer :: i, j, ii, jj\n+\n+  if (size (b, 1) .ne. isize) stop 103\n+  if (size (b, 2) .ne. jsize) stop 104\n+\n+  ! ii and jj iterate over the elements of b\n+  ! i and j iterate over the original array\n+  jj = lbound (b, 2)\n+  do j = jlb, jub, jstep\n+    ii = lbound (b, 1)\n+    do i = ilb, iub, istep\n+      if (b (ii, jj)%i .ne. i) stop 203\n+      if (b (ii, jj)%j .ne. j) stop 204\n+      ii = ii + 1\n+    end do\n+    jj = jj + 1\n+  end do\n+end subroutine\n+\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  interface\n+    subroutine ctest (a, lb1, lb2, ub1, ub2, step1, step2) bind (c)\n+      use iso_c_binding\n+      use mm\n+      type(m) :: a(:,:)\n+      integer(C_INT), value :: lb1, lb2, ub1, ub2, step1, step2\n+    end subroutine\n+  end interface\n+\n+  type(m), target :: aa(imax,jmax)\n+  integer :: i, j\n+  do j = 1, jmax\n+    do i = 1, imax\n+      aa(i,j)%i = i\n+      aa(i,j)%j = j\n+    end do\n+  end do\n+\n+  ! Pass the initialized array to a C function ctest, which will take\n+  ! a section of it and pass it to ftest.\n+\n+  call ctest (aa, ilb, jlb, iub, jub, istep, jstep)\n+\n+end program"}, {"sha": "1f23a64a4b5fe9755161f68033732d02c48a963d", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-descriptor-7-c.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-7-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-7-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-7-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,81 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <stddef.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *a);\n+extern void ftest (CFI_cdesc_t *iarray, CFI_cdesc_t *jarray);\n+\n+struct m {\n+  int i;\n+  int j;\n+};\n+\n+void\n+ctest (CFI_cdesc_t *a)\n+{\n+  CFI_CDESC_T(2) idesc;\n+  CFI_cdesc_t *iarray = (CFI_cdesc_t *) &idesc;\n+  CFI_CDESC_T(2) jdesc;\n+  CFI_cdesc_t *jarray = (CFI_cdesc_t *) &jdesc;\n+  int i, j;\n+\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+\n+  if (a->rank != 2)\n+    abort ();\n+\n+  /* Fill in the new descriptors.  */\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (iarray, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_int,\n+\t\t\t\t   sizeof (int), 2, NULL));\n+  check_CFI_status (\"CFI_select_part\",\n+\t\t    CFI_select_part (iarray, a, offsetof (struct m, i),\n+\t\t\t\t     sizeof (int)));\n+\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (jarray, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_int,\n+\t\t\t\t   sizeof (int), 2, NULL));\n+  check_CFI_status (\"CFI_select_part\",\n+\t\t    CFI_select_part (jarray, a, offsetof (struct m, j),\n+\t\t\t\t     sizeof (int)));\n+  \n+  /* Sanity checking to make sure the descriptor has been initialized\n+     properly.  */\n+  dump_CFI_cdesc_t (iarray);\n+  if (iarray->version != CFI_VERSION)\n+    abort ();\n+  if (iarray->rank != 2)\n+    abort ();\n+  if (iarray->attribute != CFI_attribute_pointer)\n+    abort ();\n+  if (!iarray->base_addr)\n+    abort ();\n+  if (iarray->dim[0].extent != a->dim[0].extent)\n+    abort ();\n+  if (iarray->dim[1].extent != a->dim[1].extent)\n+    abort ();\n+\n+  dump_CFI_cdesc_t (jarray);\n+  if (jarray->version != CFI_VERSION)\n+    abort ();\n+  if (jarray->rank != 2)\n+    abort ();\n+  if (jarray->attribute != CFI_attribute_pointer)\n+    abort ();\n+  if (!jarray->base_addr)\n+    abort ();\n+  if (jarray->dim[0].extent != a->dim[0].extent)\n+    abort ();\n+  if (jarray->dim[1].extent != a->dim[1].extent)\n+    abort ();\n+\n+  /* Call back into Fortran.  */\n+  ftest (iarray, jarray);\n+}"}, {"sha": "bc76b0eaa7292fe166b9949cf1c3ecda42cf7c66", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-descriptor-7.f90", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-7.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,74 @@\n+! { dg-do run }\n+! { dg-additional-sources \"cf-descriptor-7-c.c dump-descriptors.c\" }\n+!\n+! This program tests passing the result of the CFI_select_part C library \n+! routine back to Fortran.  Most of the work happens on the C side.\n+\n+module mm\n+  use iso_c_binding\n+  type, bind (c) :: m\n+    integer(C_INT) :: i, j\n+  end type\n+\n+  integer, parameter :: imax=10, jmax=5\n+end module\n+\n+subroutine ftest (iarray, jarray) bind (c, name=\"ftest\")\n+  use iso_c_binding\n+  use mm\n+  integer(C_INT), pointer :: iarray(:,:), jarray(:,:)\n+  \n+  integer :: i, j, i1, i2, j1, j2\n+\n+  ! iarray and jarray must have the same shape as the original array,\n+  ! but might be zero-indexed instead of one-indexed.\n+  if (size (iarray, 1) .ne. imax) stop 101\n+  if (size (iarray, 2) .ne. jmax) stop 102\n+  if (size (jarray, 1) .ne. imax) stop 103\n+  if (size (jarray, 2) .ne. jmax) stop 104\n+\n+  j1 = lbound(iarray, 2)\n+  j2 = lbound(jarray, 2)\n+  do j = 1, jmax\n+    i1 = lbound(iarray, 1)\n+    i2 = lbound(jarray, 1)\n+    do i = 1, imax\n+      if (iarray (i1, j1) .ne. i) stop 201\n+      if (jarray (i2, j2) .ne. j) stop 202\n+      i1 = i1 + 1\n+      i2 = i2 + 1\n+    end do\n+  j1 = j1 + 1\n+  j2 = j2 + 1\n+  end do\n+end subroutine\n+\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  interface\n+    subroutine ctest (a) bind (c)\n+      use iso_c_binding\n+      use mm\n+      type(m) :: a(:,:)\n+    end subroutine\n+  end interface\n+\n+  type(m), target :: aa(imax,jmax)\n+  integer :: i, j\n+  do j = 1, jmax\n+    do i = 1, imax\n+      aa(i,j)%i = i\n+      aa(i,j)%j = j\n+    end do\n+  end do\n+\n+  ! Pass the initialized array to a C function ctest, which will split it\n+  ! into i and j component arrays and pass them to ftest.\n+\n+  call ctest (aa)\n+\n+end program"}, {"sha": "49beee7f23bfe7e24f10c5181b13ca5ebec9d69b", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-descriptor-8-c.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-8-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-8-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-8-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,73 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *a);\n+extern void ftest1 (CFI_cdesc_t *a, int lb1, int lb2);\n+extern void ftest2 (CFI_cdesc_t *a);\n+\n+struct m {\n+  int i;\n+  int j;\n+};\n+\n+#define imax 10\n+#define jmax 5\n+\n+void\n+ctest (CFI_cdesc_t *a)\n+{\n+  \n+  CFI_CDESC_T(2) bdesc;\n+  CFI_cdesc_t *b = (CFI_cdesc_t *) &bdesc;\n+  int i, j;\n+  CFI_index_t subscripts[2];\n+  struct m* mp;\n+\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+\n+  if (a->rank != 2)\n+    abort ();\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+\n+  /* Fill in bdesc.  */\n+  subscripts[0] = a->dim[0].extent;\n+  subscripts[1] = a->dim[1].extent;\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (b, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_struct,\n+\t\t\t\t   sizeof (struct m), 2, subscripts));\n+\n+  /* Pass the unassociated pointer descriptor b back to Fortran for\n+     checking.  */\n+  dump_CFI_cdesc_t (b);\n+  ftest2 (b);\n+\n+  /* Point the descriptor b at the input argument array, and check that\n+     on the Fortran side.  */\n+  subscripts[0] = a->dim[0].lower_bound;\n+  subscripts[1] = a->dim[1].lower_bound;\n+  check_CFI_status (\"CFI_setpointer\",\n+\t\t    CFI_setpointer (b, a, subscripts));\n+  dump_CFI_cdesc_t (b);\n+  ftest1 (b, (int)subscripts[0], (int)subscripts[1]);\n+\n+  /* Diddle the lower bounds and try again.  */\n+  subscripts[0] = 42;\n+  subscripts[1] = -69;\n+  check_CFI_status (\"CFI_setpointer\",\n+\t\t    CFI_setpointer (b, b, subscripts));\n+  dump_CFI_cdesc_t (b);\n+  ftest1 (b, 42, -69);\n+\n+  /* Disassociate the pointer and check that.  */\n+  check_CFI_status (\"CFI_setpointer\",\n+\t\t    CFI_setpointer (b, NULL, NULL));\n+  dump_CFI_cdesc_t (b);\n+  ftest2 (b);\n+}"}, {"sha": "6b35e6e8a2f7c58a747e26760e7ece9ff0745a18", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-descriptor-8.f90", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-descriptor-8.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,78 @@\n+! { dg-do run }\n+! { dg-additional-sources \"cf-descriptor-8-c.c dump-descriptors.c\" }\n+!\n+! This program tests passing the result of the CFI_setpointer C library \n+! function back to Fortran.  Most of the  work happens on the C side.\n+\n+module mm\n+  use iso_c_binding\n+  type, bind (c) :: m\n+    integer(C_INT) :: i, j\n+  end type\n+\n+  integer, parameter :: imax=10, jmax=5\n+end module\n+\n+subroutine ftest1 (a, lb1, lb2) bind (c, name=\"ftest1\")\n+  use iso_c_binding\n+  use mm\n+  type(m), pointer :: a(:,:)\n+  integer(C_INT), value :: lb1, lb2\n+  integer :: i, j, ii, jj\n+\n+  if (size (a,1) .ne. imax) stop 101\n+  if (size (a,2) .ne. jmax) stop 102\n+  if (lbound (a, 1) .ne. lb1) stop 103\n+  if (lbound (a, 2) .ne. lb2) stop 104\n+\n+  if (.not. associated (a)) stop 105\n+\n+  jj = lb2\n+  do j = 1, jmax\n+    ii = lb1\n+    do i = 1, imax\n+      if (a(ii,jj)%i .ne. i) stop 201\n+      if (a(ii,jj)%j .ne. j) stop 202\n+      ii = ii + 1\n+    end do\n+  jj = jj + 1\n+  end do\n+end subroutine\n+\n+subroutine ftest2 (a) bind (c, name=\"ftest2\")\n+  use iso_c_binding\n+  use mm\n+  type(m), pointer :: a(:,:)\n+\n+  if (associated (a)) stop 301\n+end subroutine\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  interface\n+    subroutine ctest (a) bind (c)\n+      use iso_c_binding\n+      use mm\n+      type(m) :: a(:,:)\n+    end subroutine\n+  end interface\n+\n+  type(m), target :: aa(imax,jmax)\n+  integer :: i, j\n+  do j = 1, jmax\n+    do i = 1, imax\n+      aa(i,j)%i = i\n+      aa(i,j)%j = j\n+    end do\n+  end do\n+\n+  ! Pass the initialized array to a C function ctest, which will use it\n+  ! as the target of a pointer array with various bounds, calling\n+  ! ftest1 and ftest2 to check that CFI_setpointer did the right thing.\n+\n+  call ctest (aa)\n+\n+end program"}, {"sha": "366ec2b61443c75e52b540bcb411f0b1207d4055", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-out-descriptor-1-c.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-1-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-1-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-1-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,87 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *a, CFI_cdesc_t *b);\n+extern void ftest2 (CFI_cdesc_t *a, CFI_cdesc_t *b);\n+\n+struct m {\n+  int i;\n+  int j;\n+};\n+\n+#define imax 10\n+#define jmax 5\n+\n+void\n+ctest (CFI_cdesc_t *a, CFI_cdesc_t *b)\n+{\n+  CFI_index_t i, j;\n+  CFI_index_t s[2];\n+  struct m *mpa, *mpb;\n+  \n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+  if (a->rank != 2)\n+    abort ();\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+  if (a->dim[0].lower_bound != 0)\n+    abort ();\n+  if (a->dim[0].extent != imax)\n+    abort ();\n+  if (a->dim[1].lower_bound != 0)\n+    abort ();\n+  if (a->dim[1].extent != jmax)\n+    abort ();\n+\n+  dump_CFI_cdesc_t (b);\n+  if (b->rank != 2)\n+    abort ();\n+  if (b->attribute != CFI_attribute_other)\n+    abort ();\n+  if (b->dim[0].lower_bound != 0)\n+    abort ();\n+  if (b->dim[0].extent != jmax)\n+    abort ();\n+  if (b->dim[1].lower_bound != 0)\n+    abort ();\n+  if (b->dim[1].extent != imax)\n+    abort ();\n+\n+  /* Call back into Fortran, passing both the a and b arrays.  */\n+  ftest2 (a, b);\n+\n+  /* Check that we got a valid b array back.  */\n+  dump_CFI_cdesc_t (b);\n+  if (b->rank != 2)\n+    abort ();\n+  if (b->attribute != CFI_attribute_other)\n+    abort ();\n+  if (b->dim[0].lower_bound != 0)\n+    abort ();\n+  if (b->dim[0].extent != jmax)\n+    abort ();\n+  if (b->dim[1].lower_bound != 0)\n+    abort ();\n+  if (b->dim[1].extent != imax)\n+    abort ();\n+\n+  for (j = 0; j < jmax; j++)\n+    for (i = 0; i < imax; i++)\n+      {\n+\ts[0] = i;\n+\ts[1] = j;\n+\tmpa = (struct m *) CFI_address (a, s);\n+\ts[0] = j;\n+\ts[1] = i;\n+\tmpb = (struct m *) CFI_address (b, s);\n+\tif (mpa->i != mpb->i)\n+\t  abort ();\n+\tif (mpa->j != mpb->j)\n+\t  abort ();\n+      }\n+}"}, {"sha": "05fe26c8a590b4b84f489cdd9d460d83a69b7b24", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-out-descriptor-1.f90", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-1.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,174 @@\n+! { dg-do run }\n+! { dg-additional-sources \"cf-out-descriptor-1-c.c dump-descriptors.c\" }\n+!\n+! This program checks that calling a Fortran function with C binding and\n+! an intent(out) argument works from both C and Fortran.  For this\n+! test case the argument is an assumed-shape array.\n+\n+module mm\n+  use iso_c_binding\n+  type, bind (c) :: m\n+    integer(C_INT) :: i, j\n+  end type\n+\n+  integer, parameter :: imax=10, jmax=5\n+end module\n+\n+! frob has regular Fortran binding.  It transposes input array argument\n+! a into the intent(out) argument b.\n+\n+subroutine frob (a, b)\n+  use iso_c_binding\n+  use mm\n+  type(m) :: a(:,:)\n+  type(m), intent(out) ::  b(:,:)\n+  integer :: i, j\n+\n+  if (lbound (a, 1) .ne. lbound (b, 2)) stop 101\n+  if (lbound (a, 2) .ne. lbound (b, 1)) stop 102\n+  if (ubound (a, 1) .ne. ubound (b, 2)) stop 103\n+  if (ubound (a, 2) .ne. ubound (b, 1)) stop 104\n+\n+  do j = lbound (a, 2), ubound (a, 2)\n+    do i = lbound (a, 1), ubound (a, 1)\n+      b(j,i) = a(i,j)\n+    end do\n+  end do\n+end subroutine\n+\n+! check also has regular Fortran binding, and two input arguments.\n+\n+subroutine check (a, b)\n+  use iso_c_binding\n+  use mm\n+  type(m) :: a(:,:), b(:,:)\n+  integer :: i, j\n+\n+  if (lbound (a, 1) .ne. 1 .or. lbound (b, 2) .ne. 1) stop 101\n+  if (lbound (a, 2) .ne. 1 .or. lbound (b, 1) .ne. 1) stop 102\n+  if (ubound (a, 1) .ne. ubound (b, 2)) stop 103\n+  if (ubound (a, 2) .ne. ubound (b, 1)) stop 104\n+\n+  do j = 1, ubound (a, 2)\n+    do i = 1, ubound (a, 1)\n+      if (b(j,i)%i .ne. a(i,j)%i)  stop 105\n+      if (b(j,i)%j .ne. a(i,j)%j)  stop 106\n+    end do\n+  end do\n+end subroutine\n+\n+! ftest1 has C binding and calls frob.  This allows us to test intent(out)\n+! arguments passed back from Fortran binding to a Fortran function with C\n+! binding.\n+\n+subroutine ftest1 (a, b) bind (c, name=\"ftest1\")\n+  use iso_c_binding\n+  use mm\n+  type(m) :: a(:,:)\n+  type(m), intent(out) ::  b(:,:)\n+\n+  interface\n+    subroutine frob (a, b)\n+      use iso_c_binding\n+      use mm\n+      type(m) :: a(:,:)\n+      type(m), intent(out) ::  b(:,:)\n+    end subroutine\n+    subroutine check (a, b)\n+      use iso_c_binding\n+      use mm\n+      type(m) :: a(:,:), b(:,:)\n+    end subroutine\n+  end interface\n+\n+  call frob (a, b)\n+  call check (a, b)\n+end subroutine\n+\n+! ftest2 has C binding and calls ftest1.  This allows us to test intent(out)\n+! arguments passed between two Fortran functions with C binding.\n+\n+subroutine ftest2 (a, b) bind (c, name=\"ftest2\")\n+  use iso_c_binding\n+  use mm\n+  type(m) :: a(:,:)\n+  type(m), intent(out) ::  b(:,:)\n+\n+  interface\n+    subroutine ftest1 (a, b) bind (c, name=\"ftest1\")\n+      use iso_c_binding\n+      use mm\n+      type(m) :: a(:,:)\n+      type(m), intent(out) ::  b(:,:)\n+    end subroutine\n+    subroutine check (a, b)\n+      use iso_c_binding\n+      use mm\n+      type(m) :: a(:,:), b(:,:)\n+    end subroutine\n+  end interface\n+\n+  call ftest1 (a, b)\n+  call check (a, b)\n+end subroutine\n+\n+! main calls ftest2 directly and also indirectly from a C function ctest.\n+! The former allows us to test intent(out) arguments passed back from a\n+! Fortran routine with C binding to a regular Fortran routine, and the\n+! latter tests passing them back from Fortran to C and C to Fortran.\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  interface\n+    subroutine ftest2 (a, b) bind (c, name=\"ftest2\")\n+      use iso_c_binding\n+      use mm\n+      type(m) :: a(:,:)\n+      type(m), intent(out) ::  b(:,:)\n+    end subroutine\n+    subroutine ctest (a, b) bind (c)\n+      use iso_c_binding\n+      use mm\n+      type(m) :: a(:,:)\n+      type(m), intent(out) :: b(:,:)\n+    end subroutine\n+    subroutine check (a, b)\n+      use iso_c_binding\n+      use mm\n+      type(m) :: a(:,:), b(:,:)\n+    end subroutine\n+  end interface\n+\n+  type(m) :: aa(imax,jmax), bb(jmax,imax)\n+  integer :: i, j\n+\n+  ! initialize\n+  do j = 1, jmax\n+    do i = 1, imax\n+      aa(i,j)%i = i\n+      aa(i,j)%j = j\n+      bb(j,i)%i = -1\n+      bb(j,i)%j = -2\n+    end do\n+  end do\n+\n+  call ftest2 (aa, bb)\n+  call check (aa, bb)\n+\n+  ! initialize again\n+  do j = 1, jmax\n+    do i = 1, imax\n+      aa(i,j)%i = i\n+      aa(i,j)%j = j\n+      bb(j,i)%i = -1\n+      bb(j,i)%j = -2\n+    end do\n+  end do\n+\n+  call ctest (aa, bb)\n+  call check (aa, bb)\n+\n+end program"}, {"sha": "366ec2b61443c75e52b540bcb411f0b1207d4055", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-out-descriptor-2-c.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-2-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-2-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-2-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,87 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *a, CFI_cdesc_t *b);\n+extern void ftest2 (CFI_cdesc_t *a, CFI_cdesc_t *b);\n+\n+struct m {\n+  int i;\n+  int j;\n+};\n+\n+#define imax 10\n+#define jmax 5\n+\n+void\n+ctest (CFI_cdesc_t *a, CFI_cdesc_t *b)\n+{\n+  CFI_index_t i, j;\n+  CFI_index_t s[2];\n+  struct m *mpa, *mpb;\n+  \n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+  if (a->rank != 2)\n+    abort ();\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+  if (a->dim[0].lower_bound != 0)\n+    abort ();\n+  if (a->dim[0].extent != imax)\n+    abort ();\n+  if (a->dim[1].lower_bound != 0)\n+    abort ();\n+  if (a->dim[1].extent != jmax)\n+    abort ();\n+\n+  dump_CFI_cdesc_t (b);\n+  if (b->rank != 2)\n+    abort ();\n+  if (b->attribute != CFI_attribute_other)\n+    abort ();\n+  if (b->dim[0].lower_bound != 0)\n+    abort ();\n+  if (b->dim[0].extent != jmax)\n+    abort ();\n+  if (b->dim[1].lower_bound != 0)\n+    abort ();\n+  if (b->dim[1].extent != imax)\n+    abort ();\n+\n+  /* Call back into Fortran, passing both the a and b arrays.  */\n+  ftest2 (a, b);\n+\n+  /* Check that we got a valid b array back.  */\n+  dump_CFI_cdesc_t (b);\n+  if (b->rank != 2)\n+    abort ();\n+  if (b->attribute != CFI_attribute_other)\n+    abort ();\n+  if (b->dim[0].lower_bound != 0)\n+    abort ();\n+  if (b->dim[0].extent != jmax)\n+    abort ();\n+  if (b->dim[1].lower_bound != 0)\n+    abort ();\n+  if (b->dim[1].extent != imax)\n+    abort ();\n+\n+  for (j = 0; j < jmax; j++)\n+    for (i = 0; i < imax; i++)\n+      {\n+\ts[0] = i;\n+\ts[1] = j;\n+\tmpa = (struct m *) CFI_address (a, s);\n+\ts[0] = j;\n+\ts[1] = i;\n+\tmpb = (struct m *) CFI_address (b, s);\n+\tif (mpa->i != mpb->i)\n+\t  abort ();\n+\tif (mpa->j != mpb->j)\n+\t  abort ();\n+      }\n+}"}, {"sha": "3b166f46b5361bf1c553eda37d4ad2fbccbb52bd", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-out-descriptor-2.f90", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-2.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,157 @@\n+! { dg-do run }\n+! { dg-additional-sources \"cf-out-descriptor-2-c.c dump-descriptors.c\" }\n+!\n+! This program checks that calling a Fortran function with C binding and\n+! an intent(out) argument works from both C and Fortran.  For this\n+! test case the argument is an assumed-rank array.\n+\n+module mm\n+  use iso_c_binding\n+  type, bind (c) :: m\n+    integer(C_INT) :: i, j\n+  end type\n+\n+  integer, parameter :: imax=10, jmax=5\n+end module\n+\n+! The call chains we'll be testing will be\n+!   main -> ctest -> ftest1\n+!   main -> ftest2 -> ftest1\n+!   main -> ftest1\n+! where everything has \"c\" binding except main.\n+\n+! ftest1 has C binding and transposes a into b.\n+\n+subroutine ftest1 (a, b) bind (c, name=\"ftest1\")\n+  use iso_c_binding\n+  use mm\n+  type(m) :: a(..)\n+  type(m), intent(out) ::  b(..)\n+\n+  select rank (a)\n+    rank (2)\n+      select rank (b)\n+        rank (2)\n+          b = transpose (a)\n+        rank default\n+          stop 101\n+      end select\n+    rank default\n+      stop 102\n+  end select\n+end subroutine\n+\n+! ftest2 has C binding and calls ftest1.\n+\n+subroutine ftest2 (a, b) bind (c, name=\"ftest2\")\n+  use iso_c_binding\n+  use mm\n+  type(m) :: a(..)\n+  type(m), intent(out) ::  b(..)\n+\n+  interface\n+    subroutine ftest1 (a, b) bind (c, name=\"ftest1\")\n+      use iso_c_binding\n+      use mm\n+      type(m) :: a(..)\n+      type(m), intent(out) ::  b(..)\n+    end subroutine\n+  end interface\n+\n+  call ftest1 (a, b)\n+  if (rank (a) .ne. 2)  stop 201\n+  if (rank (b) .ne. 2)  stop 202\n+end subroutine\n+\n+! main calls ftest2 directly and also indirectly from a C function ctest.\n+! The former allows us to test intent(out) arguments passed back from a\n+! Fortran routine with C binding to a regular Fortran routine, and the\n+! latter tests passing them back from Fortran to C and C to Fortran.\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  interface\n+    subroutine ftest1 (a, b) bind (c, name=\"ftest2\")\n+      use iso_c_binding\n+      use mm\n+      type(m) :: a(..)\n+      type(m), intent(out) ::  b(..)\n+    end subroutine\n+    subroutine ftest2 (a, b) bind (c, name=\"ftest2\")\n+      use iso_c_binding\n+      use mm\n+      type(m) :: a(..)\n+      type(m), intent(out) ::  b(..)\n+    end subroutine\n+    subroutine ctest (a, b) bind (c, name=\"ctest\")\n+      use iso_c_binding\n+      use mm\n+      type(m) :: a(..)\n+      type(m), intent(out) :: b(..)\n+    end subroutine\n+  end interface\n+\n+  type(m) :: aa(imax,jmax), bb(jmax,imax)\n+  integer :: i, j\n+\n+  ! initialize\n+  do j = 1, jmax\n+    do i = 1, imax\n+      aa(i,j)%i = i\n+      aa(i,j)%j = j\n+      bb(j,i)%i = -1\n+      bb(j,i)%j = -2\n+    end do\n+  end do\n+\n+  ! frob and check\n+  call ftest1 (aa, bb)\n+  do j = 1, jmax\n+    do i = 1, imax\n+      if (aa(i,j)%i .ne. bb(j,i)%i) stop 301\n+      if (aa(i,j)%j .ne. bb(j,i)%j) stop 302\n+    end do\n+  end do\n+\n+  ! initialize again\n+  do j = 1, jmax\n+    do i = 1, imax\n+      aa(i,j)%i = i\n+      aa(i,j)%j = j\n+      bb(j,i)%i = -1\n+      bb(j,i)%j = -2\n+    end do\n+  end do\n+\n+  ! frob and check\n+  call ftest2 (aa, bb)\n+  do j = 1, jmax\n+    do i = 1, imax\n+      if (aa(i,j)%i .ne. bb(j,i)%i) stop 401\n+      if (aa(i,j)%j .ne. bb(j,i)%j) stop 402\n+    end do\n+  end do\n+\n+  ! initialize again\n+  do j = 1, jmax\n+    do i = 1, imax\n+      aa(i,j)%i = i\n+      aa(i,j)%j = j\n+      bb(j,i)%i = -1\n+      bb(j,i)%j = -2\n+    end do\n+  end do\n+\n+  ! frob and check\n+  call ctest (aa, bb)\n+  do j = 1, jmax\n+    do i = 1, imax\n+      if (aa(i,j)%i .ne. bb(j,i)%i) stop 501\n+      if (aa(i,j)%j .ne. bb(j,i)%j) stop 502\n+    end do\n+  end do\n+\n+end program"}, {"sha": "b04293eab0ce52cb5aa20c4f83398e03a6e481d5", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-out-descriptor-3-c.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-3-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-3-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-3-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,108 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (int imagic, int jmagic);\n+extern void frob (CFI_cdesc_t *a, CFI_cdesc_t *aa, CFI_cdesc_t *p);\n+\n+struct m {\n+  int i;\n+  int j;\n+};\n+\n+void\n+ctest (int imagic, int jmagic)\n+{\n+  CFI_CDESC_T(0) adesc;\n+  CFI_CDESC_T(0) aadesc;\n+  CFI_CDESC_T(0) bdesc;\n+  CFI_cdesc_t *a = (CFI_cdesc_t *) &adesc;\n+  CFI_cdesc_t *aa = (CFI_cdesc_t *) &aadesc;\n+  CFI_cdesc_t *b = (CFI_cdesc_t *) &bdesc;\n+\n+  /* Create and sanity-check descriptors.  */\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (a, NULL, CFI_attribute_allocatable,\n+\t\t\t\t   CFI_type_struct,\n+\t\t\t\t   sizeof (struct m), 0, NULL));\n+  dump_CFI_cdesc_t (a);\n+  if (a->version != CFI_VERSION)\n+    abort ();\n+  if (a->rank != 0)\n+    abort ();\n+  if (a->attribute != CFI_attribute_allocatable)\n+    abort ();\n+  if (a->base_addr)\n+    abort ();\n+  if (a->elem_len != sizeof (struct m))\n+    abort ();\n+\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (aa, NULL, CFI_attribute_allocatable,\n+\t\t\t\t   CFI_type_struct,\n+\t\t\t\t   sizeof (struct m), 0, NULL));\n+  dump_CFI_cdesc_t (aa);\n+  if (aa->version != CFI_VERSION)\n+    abort ();\n+  if (aa->rank != 0)\n+    abort ();\n+  if (aa->attribute != CFI_attribute_allocatable)\n+    abort ();\n+  if (aa->base_addr)\n+    abort ();\n+  if (aa->elem_len != sizeof (struct m))\n+    abort ();\n+  check_CFI_status (\"CFI_allocate\",\n+\t\t    CFI_allocate (aa, NULL, NULL, 0));\n+  ((struct m *)aa->base_addr)->i = 0;\n+  ((struct m *)aa->base_addr)->j = 0;\n+  \n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (b, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_struct,\n+\t\t\t\t   sizeof (struct m), 0, NULL));\n+  dump_CFI_cdesc_t (b);\n+  if (b->version != CFI_VERSION)\n+    abort ();\n+  if (b->rank != 0)\n+    abort ();\n+  if (b->attribute != CFI_attribute_pointer)\n+    abort ();\n+  if (b->base_addr)\n+    abort ();\n+  if (b->elem_len != sizeof (struct m))\n+    abort ();\n+\n+  /* Call back into Fortran, which will allocate and initialize the\n+     objects.  */\n+  frob (a, aa, b);\n+\n+  if (!a->base_addr)\n+    abort ();\n+  if (a->elem_len != sizeof (struct m))\n+    abort ();\n+  if (((struct m *)a->base_addr)->i != imagic)\n+    abort ();\n+  if (((struct m *)a->base_addr)->j != jmagic)\n+    abort ();\n+\n+  if (!aa->base_addr)\n+    abort ();\n+  if (aa->elem_len != sizeof (struct m))\n+    abort ();\n+  if (((struct m *)aa->base_addr)->i != imagic)\n+    abort ();\n+  if (((struct m *)aa->base_addr)->j != jmagic)\n+    abort ();\n+\n+  if (!b->base_addr)\n+    abort ();\n+  if (b->elem_len != sizeof (struct m))\n+    abort ();\n+  if (((struct m *)b->base_addr)->i != imagic)\n+    abort ();\n+  if (((struct m *)b->base_addr)->j != jmagic)\n+    abort ();\n+}"}, {"sha": "5e5f5955973e4547feffa674f5ce0e7b5f9a427f", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-out-descriptor-3.f90", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-3.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,134 @@\n+! PR 92621 (?)\n+! { dg-do run { xfail *-*-* } }\n+! { dg-additional-sources \"cf-out-descriptor-3-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program checks that calling a Fortran function with C binding and\n+! an intent(out) argument works from both C and Fortran.  For this\n+! test case the argument is an allocatable or pointer scalar.\n+\n+module mm\n+  use iso_c_binding\n+  type, bind (c) :: m\n+    integer(C_INT) :: i, j\n+  end type\n+\n+  integer, parameter :: imagic=-1, jmagic=42\n+\n+end module\n+\n+! The call chains being tested here are\n+!   main -> frob\n+!   main -> ftest -> frob\n+!   main -> ctest -> frob\n+! where everything other than main has C binding.\n+\n+! frob allocates and initializes its arguments.\n+! There are two allocatable dummies so that we can pass both\n+! unallocated (a) and allocated (aa).\n+\n+subroutine frob (a, aa, p) bind (c, name=\"frob\")\n+  use iso_c_binding\n+  use mm\n+  type(m), intent(out), allocatable :: a, aa\n+  type(m), intent(out), pointer :: p\n+\n+  if (allocated (a))  stop 101\n+  allocate (a)\n+  a%i = imagic\n+  a%j = jmagic\n+\n+  if (allocated (aa))  stop 102\n+  allocate (aa)\n+  aa%i = imagic\n+  aa%j = jmagic\n+\n+  ! association status of p is undefined on entry\n+  allocate (p)\n+  p%i = imagic\n+  p%j = jmagic\n+end subroutine\n+\n+subroutine ftest () bind (c, name=\"ftest\")\n+  use iso_c_binding\n+  use mm\n+  type(m), allocatable :: a, aa\n+  type(m), pointer :: p\n+\n+  interface\n+    subroutine frob (a, aa, p) bind (c, name=\"frob\")\n+      use iso_c_binding\n+      use mm\n+      type(m), intent(out), allocatable :: a, aa\n+      type(m), intent(out), pointer :: p\n+    end subroutine\n+  end interface\n+\n+  p => NULL ()\n+  allocate (aa)\n+  aa%i = 0\n+  aa%j = 0\n+  call frob (a, aa, p)\n+\n+  if (.not. allocated (a)) stop 201\n+  if (a%i .ne. imagic) stop 202\n+  if (a%j .ne. jmagic) stop 203\n+\n+  if (.not. allocated (aa)) stop 204\n+  if (a%i .ne. imagic) stop 205\n+  if (a%j .ne. jmagic) stop 206\n+\n+  if (.not. associated (p)) stop 207\n+  if (p%i .ne. imagic) stop 208\n+  if (p%j .ne. jmagic) stop 209\n+\n+end subroutine\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  interface\n+    subroutine frob (a, aa, p) bind (c, name=\"frob\")\n+      use iso_c_binding\n+      use mm\n+      type(m), intent(out), allocatable :: a, aa\n+      type(m), intent(out), pointer :: p\n+    end subroutine\n+    subroutine ftest () bind (c, name=\"ftest\")\n+      use iso_c_binding\n+      use mm\n+    end subroutine\n+    subroutine ctest (ii, jj) bind (c, name=\"ctest\")\n+      use iso_c_binding\n+      use mm\n+      integer(C_INT), value :: ii, jj\n+    end subroutine\n+  end interface\n+\n+  type(m), allocatable :: a, aa\n+  type(m), pointer :: p\n+\n+  p => NULL ()\n+  allocate (aa)\n+  aa%i = 0\n+  aa%j = 0\n+  call frob (a, aa, p)\n+\n+  if (.not. allocated (a)) stop 201\n+  if (a%i .ne. imagic) stop 202\n+  if (a%j .ne. jmagic) stop 203\n+\n+  if (.not. allocated (aa)) stop 204\n+  if (a%i .ne. imagic) stop 205\n+  if (a%j .ne. jmagic) stop 206\n+\n+  if (.not. associated (p)) stop 207\n+  if (p%i .ne. imagic) stop 208\n+  if (p%j .ne. jmagic) stop 209\n+\n+  call ftest\n+  call ctest (imagic, jmagic)\n+\n+end program"}, {"sha": "bf5db6f7bd7d49f4fc311f200cf607416adad768", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-out-descriptor-4-c.c", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-4-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-4-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-4-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,175 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (int imax, int jmax);\n+extern void frob (CFI_cdesc_t *a, CFI_cdesc_t *aa, CFI_cdesc_t *p);\n+\n+struct m {\n+  int i;\n+  int j;\n+};\n+\n+void\n+ctest (int imax, int jmax)\n+{\n+  CFI_CDESC_T(2) adesc;\n+  CFI_CDESC_T(2) aadesc;\n+  CFI_CDESC_T(2) bdesc;\n+  CFI_cdesc_t *a = (CFI_cdesc_t *) &adesc;\n+  CFI_cdesc_t *aa = (CFI_cdesc_t *) &aadesc;\n+  CFI_cdesc_t *b = (CFI_cdesc_t *) &bdesc;\n+  CFI_index_t i, j;\n+  CFI_index_t s[2];\n+  CFI_index_t lb[2], ub[2];\n+  struct m* mp;\n+\n+  /* Create and sanity-check a. */\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (a, NULL, CFI_attribute_allocatable,\n+\t\t\t\t   CFI_type_struct,\n+\t\t\t\t   sizeof (struct m), 2, NULL));\n+  dump_CFI_cdesc_t (a);\n+  if (a->version != CFI_VERSION)\n+    abort ();\n+  if (a->rank != 2)\n+    abort ();\n+  if (a->attribute != CFI_attribute_allocatable)\n+    abort ();\n+  if (a->base_addr)\n+    abort ();\n+  if (a->elem_len != sizeof (struct m))\n+    abort ();\n+\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (aa, NULL, CFI_attribute_allocatable,\n+\t\t\t\t   CFI_type_struct,\n+\t\t\t\t   sizeof (struct m), 2, NULL));\n+  dump_CFI_cdesc_t (aa);\n+  if (aa->version != CFI_VERSION)\n+    abort ();\n+  if (aa->rank != 2)\n+    abort ();\n+  if (aa->attribute != CFI_attribute_allocatable)\n+    abort ();\n+  if (aa->base_addr)\n+    abort ();\n+  if (aa->elem_len != sizeof (struct m))\n+    abort ();\n+\n+  /* aa is allocated/initialized so that we can confirm that it's\n+     magically deallocated when passed as intent(out).  */\n+  lb[0] = 0;\n+  lb[1] = 0;\n+  ub[0] = jmax;\n+  ub[1] = jmax;\n+  check_CFI_status (\"CFI_allocate\",\n+\t\t    CFI_allocate (aa, lb, ub, 0));\n+  for (j = 1; j <= jmax; j++)\n+    for (i = 1; i <= imax; i++)\n+      {\n+\ts[0] = j;\n+\ts[1] = i;\n+\tmp = (struct m *)CFI_address (aa, s);\n+\tmp->i = 0;\n+\tmp->j = 0;\n+      }\n+\n+  /* Likewise create and sanity-check b. */\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (b, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_struct,\n+\t\t\t\t   sizeof (struct m), 2, NULL));\n+  dump_CFI_cdesc_t (b);\n+  if (b->version != CFI_VERSION)\n+    abort ();\n+  if (b->rank != 2)\n+    abort ();\n+  if (b->attribute != CFI_attribute_pointer)\n+    abort ();\n+  if (b->base_addr)\n+    abort ();\n+  if (b->elem_len != sizeof (struct m))\n+    abort ();\n+\n+  /* Call back into Fortran, which will allocate and initialize the\n+     objects.  */\n+  frob (a, aa, b);\n+\n+  dump_CFI_cdesc_t (a);\n+  if (!a->base_addr)\n+    abort ();\n+  if (a->elem_len != sizeof (struct m))\n+    abort ();\n+  if (a->dim[0].lower_bound != 1)\n+    abort ();\n+  if (a->dim[0].extent != imax)\n+    abort ();\n+  if (a->dim[1].lower_bound != 1)\n+    abort ();\n+  if (a->dim[1].extent != jmax)\n+    abort ();\n+  for (j = 1; j <= jmax; j++)\n+    for (i = 1; i <= imax; i++)\n+      {\n+\ts[0] = i;\n+\ts[1] = j;\n+\tmp = (struct m *)CFI_address (a, s);\n+\tif (mp->i != i)\n+\t  abort ();\n+\tif (mp->j != j)\n+\t  abort ();\n+      }\n+\n+  dump_CFI_cdesc_t (aa);\n+  if (!aa->base_addr)\n+    abort ();\n+  if (aa->elem_len != sizeof (struct m))\n+    abort ();\n+  if (aa->dim[0].lower_bound != 1)\n+    abort ();\n+  if (aa->dim[0].extent != imax)\n+    abort ();\n+  if (aa->dim[1].lower_bound != 1)\n+    abort ();\n+  if (aa->dim[1].extent != jmax)\n+    abort ();\n+  for (j = 1; j <= jmax; j++)\n+    for (i = 1; i <= imax; i++)\n+      {\n+\ts[0] = i;\n+\ts[1] = j;\n+\tmp = (struct m *)CFI_address (aa, s);\n+\tif (mp->i != i)\n+\t  abort ();\n+\tif (mp->j != j)\n+\t  abort ();\n+      }\n+\n+  dump_CFI_cdesc_t (b);\n+  if (!b->base_addr)\n+    abort ();\n+  if (b->elem_len != sizeof (struct m))\n+    abort ();\n+  if (b->dim[0].lower_bound != 1)\n+    abort ();\n+  if (b->dim[0].extent != jmax)\n+    abort ();\n+  if (b->dim[1].lower_bound != 1)\n+    abort ();\n+  if (b->dim[1].extent != imax)\n+    abort ();\n+  for (j = 1; j <= jmax; j++)\n+    for (i = 1; i <= imax; i++)\n+      {\n+\ts[0] = j;\n+\ts[1] = i;\n+\tmp = (struct m *)CFI_address (b, s);\n+\tif (mp->i != i)\n+\t  abort ();\n+\tif (mp->j != j)\n+\t  abort ();\n+      }\n+}"}, {"sha": "082610c2da7f31def482e2f9fbfec9e12832224a", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-out-descriptor-4.f90", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-4.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,207 @@\n+! PR 92621 (?)\n+! { dg-do run { xfail *-*-* } }\n+! { dg-additional-sources \"cf-out-descriptor-4-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program checks that calling a Fortran function with C binding and\n+! an intent(out) argument works from both C and Fortran.  For this\n+! test case the argument is an allocatable or pointer array.\n+\n+module mm\n+  use iso_c_binding\n+  type, bind (c) :: m\n+    integer(C_INT) :: i, j\n+  end type\n+\n+  integer, parameter :: imax=5, jmax=10\n+\n+end module\n+\n+! The call chains being tested here are\n+!   main -> frob\n+!   main -> ftest -> frob\n+!   main -> ctest -> frob\n+! where everything other than main has C binding.\n+\n+! frob allocates and initializes its arguments.\n+! There are two allocatable dummies so that we can pass both\n+! unallocated (a) and allocated (aa).\n+\n+subroutine frob (a, aa, p) bind (c, name=\"frob\")\n+  use iso_c_binding\n+  use mm\n+  type(m), intent(out), allocatable :: a(:,:), aa(:,:)\n+  type(m), intent(out), pointer :: p(:,:)\n+  integer :: i, j\n+\n+  if (allocated (a))  stop 101\n+  allocate (a (imax, jmax))\n+  do j = 1, jmax\n+    do i = 1, imax\n+      a(i,j)%i = i\n+      a(i,j)%j = j\n+    end do\n+  end do\n+\n+  if (allocated (aa))  stop 102\n+  allocate (aa (imax, jmax))\n+  do j = 1, jmax\n+    do i = 1, imax\n+      aa(i,j)%i = i\n+      aa(i,j)%j = j\n+    end do\n+  end do\n+\n+  allocate (p (jmax, imax))\n+  do j = 1, jmax\n+    do i = 1, imax\n+      p(j,i)%i = i\n+      p(j,i)%j = j\n+    end do\n+  end do\n+end subroutine\n+\n+subroutine ftest () bind (c, name=\"ftest\")\n+  use iso_c_binding\n+  use mm\n+  type(m), allocatable :: a(:,:), aa(:,:)\n+  type(m), pointer :: p(:,:)\n+\n+  integer :: i, j\n+\n+  interface\n+    subroutine frob (a, aa, p) bind (c, name=\"frob\")\n+      use iso_c_binding\n+      use mm\n+      type(m), intent(out), allocatable :: a(:,:), aa(:,:)\n+      type(m), intent(out), pointer :: p(:,:)\n+    end subroutine\n+  end interface\n+\n+  p => NULL ()\n+  if (allocated (a) .or. allocated (aa)) stop 200\n+  allocate (aa (jmax, imax))\n+  do j = 1, jmax\n+    do i = 1, imax\n+      aa(j,i)%i = 0\n+      aa(j,i)%j = 0\n+    end do\n+  end do\n+  call frob (a, aa, p)\n+\n+  if (.not. allocated (a)) stop 201\n+  if (lbound (a, 1) .ne. 1) stop 202\n+  if (lbound (a, 2) .ne. 1) stop 203\n+  if (ubound (a, 1) .ne. imax) stop 204\n+  if (ubound (a, 2) .ne. jmax) stop 205\n+  do j = 1, jmax\n+    do i = 1, imax\n+      if (a(i,j)%i .ne. i) stop 206\n+      if (a(i,j)%j .ne. j) stop 207\n+    end do\n+  end do\n+\n+  if (.not. allocated (aa)) stop 211\n+  if (lbound (aa, 1) .ne. 1) stop 212\n+  if (lbound (aa, 2) .ne. 1) stop 213\n+  if (ubound (aa, 1) .ne. imax) stop 214\n+  if (ubound (aa, 2) .ne. jmax) stop 215\n+  do j = 1, jmax\n+    do i = 1, imax\n+      if (aa(i,j)%i .ne. i) stop 216\n+      if (aa(i,j)%j .ne. j) stop 217\n+    end do\n+  end do\n+\n+  if (.not. associated (p)) stop 221\n+  if (lbound (p, 1) .ne. 1) stop 222\n+  if (lbound (p, 2) .ne. 1) stop 223\n+  if (ubound (p, 1) .ne. jmax) stop 224\n+  if (ubound (p, 2) .ne. imax) stop 225\n+  do j = 1, jmax\n+    do i = 1, imax\n+      if (p(j,i)%i .ne. i) stop 226\n+      if (p(j,i)%j .ne. j) stop 227\n+    end do\n+  end do\n+\n+end subroutine\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  interface\n+    subroutine frob (a, aa, p) bind (c, name=\"frob\")\n+      use iso_c_binding\n+      use mm\n+      type(m), intent(out), allocatable :: a(:,:), aa(:,:)\n+      type(m), intent(out), pointer :: p(:,:)\n+    end subroutine\n+    subroutine ftest () bind (c, name=\"ftest\")\n+      use iso_c_binding\n+      use mm\n+    end subroutine\n+    subroutine ctest (ii, jj) bind (c, name=\"ctest\")\n+      use iso_c_binding\n+      use mm\n+      integer(C_INT), value :: ii, jj\n+    end subroutine\n+  end interface\n+\n+  type(m), allocatable :: a(:,:), aa(:,:)\n+  type(m), pointer :: p(:,:)\n+  integer :: i, j\n+\n+  p => NULL ()\n+  if (allocated (a) .or. allocated (aa)) stop 300\n+  allocate (aa (jmax, imax))\n+  do j = 1, jmax\n+    do i = 1, imax\n+      aa(j,i)%i = 0\n+      aa(j,i)%j = 0\n+    end do\n+  end do\n+  call frob (a, aa, p)\n+\n+  if (.not. allocated (a)) stop 301\n+  if (lbound (a, 1) .ne. 1) stop 302\n+  if (lbound (a, 2) .ne. 1) stop 303\n+  if (ubound (a, 1) .ne. imax) stop 304\n+  if (ubound (a, 2) .ne. jmax) stop 305\n+  do j = 1, jmax\n+    do i = 1, imax\n+      if (a(i,j)%i .ne. i) stop 306\n+      if (a(i,j)%j .ne. j) stop 307\n+    end do\n+  end do\n+\n+  if (.not. allocated (aa)) stop 311\n+  if (lbound (aa, 1) .ne. 1) stop 312\n+  if (lbound (aa, 2) .ne. 1) stop 313\n+  if (ubound (aa, 1) .ne. imax) stop 314\n+  if (ubound (aa, 2) .ne. jmax) stop 315\n+  do j = 1, jmax\n+    do i = 1, imax\n+      if (aa(i,j)%i .ne. i) stop 316\n+      if (aa(i,j)%j .ne. j) stop 317\n+    end do\n+  end do\n+\n+  if (.not. associated (p)) stop 321\n+  if (lbound (p, 1) .ne. 1) stop 322\n+  if (lbound (p, 2) .ne. 1) stop 323\n+  if (ubound (p, 1) .ne. jmax) stop 324\n+  if (ubound (p, 2) .ne. imax) stop 325\n+  do j = 1, jmax\n+    do i = 1, imax\n+      if (p(j,i)%i .ne. i) stop 326\n+      if (p(j,i)%j .ne. j) stop 327\n+    end do\n+  end do\n+\n+  call ftest\n+  call ctest (imax, jmax)\n+\n+end program"}, {"sha": "e5b37f353827327db34214a79b45dff92b04759b", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-out-descriptor-5-c.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-5-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-5-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-5-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,31 @@\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *a, int n);\n+extern void ftest (CFI_cdesc_t *a, int n);\n+\n+void\n+ctest (CFI_cdesc_t *a, int n)\n+{\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+\n+  /* The actual argument object on the Fortran side has length n and\n+     was passed as character(len=*).\n+     Make sure that matches what's in the descriptor.  */\n+  if (!a->base_addr)\n+    abort ();\n+  if (a->elem_len != n)\n+    abort ();\n+  if (a->rank != 0)\n+    abort ();\n+  if (a->type != CFI_type_char)\n+    abort ();\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+  ftest (a, n);\n+}"}, {"sha": "ff1e31d345f6e9887b0ca2f744f4619bd7f9c435", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-out-descriptor-5.f90", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-5.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,48 @@\n+! PR92482\n+! { dg-do run }\n+! { dg-additional-sources \"cf-out-descriptor-5-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program checks use of an assumed-length character dummy argument\n+! as an intent(out) parameter in subroutines with C binding.\n+\n+subroutine ftest (a, n) bind (c, name=\"ftest\")  ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+  use iso_c_binding\n+  character(kind=C_CHAR, len=*), intent(out) :: a\n+  integer(C_INT), value :: n\n+\n+  if (len (a) .ne. n) stop 101\n+  a = 'abcdefghijklmnopqrstuvwxyz'\n+end subroutine\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+    subroutine ctest (a, n) bind (c)  ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+      use iso_c_binding\n+      character(kind=C_CHAR, len=*), intent(out) :: a\n+      integer(C_INT), value :: n\n+    end subroutine\n+\n+    subroutine ftest (a, n) bind (c)  ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+      use iso_c_binding\n+      character(kind=C_CHAR, len=*), intent(out) :: a\n+      integer(C_INT), value :: n\n+    end subroutine\n+  end interface\n+\n+  character(kind=C_CHAR, len=42) :: aa\n+\n+  ! call ftest directly\n+  aa = '12345678910'\n+  call ftest (aa, 42)\n+  print *, aa\n+\n+  ! ctest calls ftest indirectly\n+  aa = '12345678910'\n+  call ctest (aa, 42)\n+  print *, aa\n+\n+end program"}, {"sha": "f8724b95e89c8f56f00eba93b19b495672c54010", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-out-descriptor-6-c.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-6-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-6-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-6-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,42 @@\n+#include <stdlib.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *a, int n);\n+extern void ftest (CFI_cdesc_t *a, int n);\n+\n+void\n+ctest (CFI_cdesc_t *a, int n)\n+{\n+  int i;\n+  CFI_index_t s[1];\n+\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+\n+  if (!a->base_addr)\n+    abort ();\n+  if (a->elem_len != sizeof(int))\n+    abort ();\n+  if (a->rank != 1)\n+    abort ();\n+  if (a->type != CFI_type_int)\n+    abort ();\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+  if (a->dim[0].lower_bound != 0)\n+    abort ();\n+  if (a->dim[0].extent != -1)\n+    abort ();\n+\n+  ftest (a, n);\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      s[0] = i;\n+      if (*((int *)CFI_address (a, s)) != i + 1)\n+\tabort ();\n+    }\n+}"}, {"sha": "b1a8c53b3e8c80ad3fd156af5ddacafcbb9b166f", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-out-descriptor-6.f90", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-6.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,115 @@\n+! Reported as pr94070.\n+! { dg-do run { xfail *-*-* } }\n+! { dg-additional-sources \"cf-out-descriptor-6-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program checks passing an assumed-size array as an intent(out)\n+! argument to a bind (c) Fortran function from both C and Fortran.\n+\n+! Assumed-size arrays are not passed by descriptor.  What we'll do\n+! for this test function is pass the assumed-size array as the actual\n+! argument corresponding to an assumed-rank dummy.  This is supposed to\n+! fill in the descriptor with information about the array present at\n+! the call site.\n+\n+subroutine ftest (a, n) bind (c, name=\"ftest\")\n+  use iso_c_binding\n+  integer(C_INT), intent(out) :: a(..)\n+  integer(C_INT), value :: n\n+  integer :: i\n+\n+  ! TS 29113\n+  ! 6.4.2 SIZE\n+  ! (1) for an assumed-rank object that is associated with an \n+  ! assumed-size array, the result has the value \u22121 if DIM is \n+  ! present and equal to the rank of ARRAY\n+  if (rank (a) .ne. 1) stop 102\n+  if (size (a, rank (a)) .ne. -1) stop 100\n+  if (lbound (a, rank (a)) .ne. 1) stop 101\n+\n+  select rank (a)\n+    rank (*)\n+      do i = 1, n\n+        a(i) = i\n+      end do\n+    rank default\n+      stop 102\n+  end select\n+end subroutine\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+    subroutine ctest (a, n) bind (c, name=\"ctest\")\n+      use iso_c_binding\n+      integer(C_INT), intent(out) :: a(..)\n+      integer(C_INT), value :: n\n+    end subroutine\n+    subroutine ftest (a, n) bind (c, name=\"ftest\")\n+      use iso_c_binding\n+      integer(C_INT), intent(out) :: a(..)\n+      integer(C_INT), value :: n\n+    end subroutine\n+  end interface\n+\n+  integer(C_INT), target :: aa(10)\n+\n+  ! To get an assumed-size array descriptor, we have to first pass the\n+  ! fixed-size array to a Fortran function with an assumed-size dummy,\n+  call ftest1 (aa, 10)  ! calls ftest\n+  call ftest2 (aa, 10)  ! has c binding, calls ftest\n+  call ftest3 (aa, 10)  ! calls ctest -> ftest\n+  call ftest4 (aa, 10)  ! has c binding, calls ctest -> ftest\n+\n+contains\n+\n+  subroutine ftest1 (a, n)\n+    use iso_c_binding\n+    integer(C_INT), intent(out) :: a(*)\n+    integer(C_INT), value :: n\n+    integer :: i\n+    a(1:n) = 0\n+    call ftest (a, n)\n+    do i = 1, n\n+      if (a (i) .ne. i) stop 200\n+    end do\n+  end subroutine\n+\n+  subroutine ftest2 (a, n) bind (c)\n+    use iso_c_binding\n+    integer(C_INT), intent(out) :: a(*)\n+    integer(C_INT), value :: n\n+    integer :: i\n+    a(1:n) = 0\n+    call ftest (a, n)\n+    do i = 1, n\n+      if (a (i) .ne. i) stop 201\n+    end do\n+  end subroutine\n+\n+  subroutine ftest3 (a, n)\n+    use iso_c_binding\n+    integer(C_INT), intent(out) :: a(*)\n+    integer(C_INT), value :: n\n+    integer :: i\n+    a(1:n) = 0\n+    call ctest (a, n)\n+    do i = 1, n\n+      if (a (i) .ne. i) stop 202\n+    end do\n+  end subroutine\n+\n+  subroutine ftest4 (a, n) bind (c)\n+    use iso_c_binding\n+    integer(C_INT), intent(out) :: a(*)\n+    integer(C_INT), value :: n\n+    integer :: i\n+    a(1:n) = 0\n+    call ctest (a, n)\n+    do i = 1, n\n+      if (a (i) .ne. i) stop 203\n+    end do\n+  end subroutine\n+end program"}, {"sha": "6b30da48e5fab8ed02c5e2e108df5b4f6f97666c", "filename": "gcc/testsuite/gfortran.dg/c-interop/contiguous-1-c.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-1-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-1-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-1-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,56 @@\n+#include <stdlib.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest1 (CFI_cdesc_t *a);\n+extern void ctest2 (CFI_cdesc_t *a);\n+\n+static void\n+ctest (CFI_cdesc_t *a)\n+{\n+  int i;\n+  int *p;\n+\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+\n+  /* Make sure we got a valid descriptor.  */\n+  if (!a->base_addr)\n+    abort ();\n+  if (a->elem_len != sizeof(int))\n+    abort ();\n+  if (a->rank != 1)\n+    abort ();\n+  if (a->type != CFI_type_int)\n+    abort ();\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+  if (a->dim[0].sm != sizeof(int))\n+    abort ();\n+  if (!CFI_is_contiguous (a))\n+    abort ();\n+\n+  /* Negate the elements of the array.  */\n+  p = (int *)a->base_addr;\n+  for (i = 0; i < a->dim[0].extent; i++)\n+    p[i] = -p[i];\n+}\n+\n+\n+/* The two entry points are declared differently on the C side, but both\n+   should do the same thing.  */\n+\n+void\n+ctest1 (CFI_cdesc_t *a)\n+{\n+  ctest (a);\n+}\n+\n+void\n+ctest2 (CFI_cdesc_t *a)\n+{\n+  ctest (a);\n+}\n+"}, {"sha": "fe1c98294cd5742c0a43976039b49c1d29824bdd", "filename": "gcc/testsuite/gfortran.dg/c-interop/contiguous-1.f90", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-1.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,67 @@\n+! { dg-do run }\n+! { dg-additional-sources \"contiguous-1-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! TS 29113\n+! 8.7 In an invocation of an interoperable procedure whose Fortran\n+! interface has an assumed-shape or assumed-rank dummy argument with the\n+! CONTIGUOUS attribute, the associated effective argument may be an\n+! array that is not contiguous or the address of a C descriptor for such\n+! an array. If the procedure is invoked from Fortran or the procedure is\n+! a Fortran procedure, the Fortran processor will handle the difference\n+! in contiguity. If the procedure is invoked from C and the procedure is\n+! a C procedure, the C code within the procedure shall be prepared to\n+! handle the situation of receiving a discontiguous argument.\n+!\n+! This program tests the cases where Fortran code passes a non-contiguous\n+! array section to a C function whose interface has the contiguous\n+! attribute.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+    ! ctest1 and ctest2 both negate the elements of their input array.\n+    subroutine ctest1 (a) bind (c)\n+      use iso_c_binding\n+      integer(C_INT), contiguous :: a(:)\n+    end subroutine\n+    subroutine ctest2 (a) bind (c)\n+      use iso_c_binding\n+      integer(C_INT), contiguous :: a(..)\n+    end subroutine\n+  end interface\n+\n+  integer(C_INT) :: aa(32)\n+  integer :: i\n+\n+  ! assumed-shape\n+  do i = 1, 32\n+    aa(i) = i\n+  end do\n+  call ctest1 (aa(4:12:2))\n+  do i = 1, 32\n+    if (i .ge. 4 .and. i .le. 12 .and. mod (i-4,2) .eq. 0) then\n+      if (aa (i) .ne. -i) stop 101\n+    else\n+      if (aa (i) .ne. i) stop 102\n+    end if\n+  end do\n+\n+  ! assumed-rank\n+  do i = 1, 32\n+    aa(i) = i\n+  end do\n+  call ctest2 (aa(7:19:3))\n+  do i = 1, 32\n+    if (i .ge. 7 .and. i .le. 19 .and. mod (i-7,3) .eq. 0) then\n+      if (aa (i) .ne. -i) stop 201\n+    else\n+      if (aa (i) .ne. i) stop 202\n+    end if\n+  end do\n+    \n+end program\n+\n+"}, {"sha": "5a8f3d6669f76355df6379275516f1eaf9b651d6", "filename": "gcc/testsuite/gfortran.dg/c-interop/contiguous-2-c.c", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-2-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-2-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-2-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,113 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest1 (CFI_cdesc_t *a);\n+extern void ctest2 (CFI_cdesc_t *a);\n+extern void ftest1 (CFI_cdesc_t *a, int first, int last, int step);\n+extern void ftest2 (CFI_cdesc_t *a, int first, int last, int step);\n+\n+#if 0\n+static void\n+dump_array (CFI_cdesc_t *a, const char *name, const char *note)\n+{\n+  int i;\n+\n+  fprintf (stderr, \"%s\\n\", note);\n+  for (i = 0; i < a->dim[0].extent; i++)\n+    {\n+      int j = i + a->dim[0].lower_bound;\n+      int elt;\n+      CFI_index_t sub[1];\n+      sub[0] = j;\n+      elt = *((int *) CFI_address (a, sub));\n+      fprintf (stderr, \"%s[%d] = %d\\n\", name, j, elt);\n+    }\n+  fprintf (stderr, \"\\n\");\n+}\n+#else\n+#define dump_array(a, name, note) \n+#endif\n+\n+static void\n+ctest (CFI_cdesc_t *a, int lb, int ub, int s,\n+       void (*fn) (CFI_cdesc_t *, int, int, int))\n+{\n+  CFI_CDESC_T(1) bdesc;\n+  CFI_cdesc_t *b = (CFI_cdesc_t *) &bdesc;\n+  CFI_index_t lb_array[1], ub_array[1], s_array[1];\n+  int i;\n+\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+\n+  /* Make sure we got a valid descriptor.  */\n+  if (!a->base_addr)\n+    abort ();\n+  if (a->elem_len != sizeof(int))\n+    abort ();\n+  if (a->rank != 1)\n+    abort ();\n+  if (a->type != CFI_type_int)\n+    abort ();\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+\n+  /* Create an array section and pass it to fn.  */\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (b, NULL, CFI_attribute_other,\n+\t\t\t\t   CFI_type_int,\n+\t\t\t\t   sizeof (int), 1, NULL));\n+  lb_array[0] = lb - 1 + a->dim[0].lower_bound;\n+  ub_array[0] = ub - 1 + a->dim[0].lower_bound;\n+  s_array[0] = s;\n+  check_CFI_status (\"CFI_section\",\n+\t\t    CFI_section (b, a, lb_array, ub_array, s_array));\n+  dump_CFI_cdesc_t (b);\n+  dump_array (b, \"b\", \"b after CFI_section\");\n+\n+  /* Pass it to the Fortran function fn.  */\n+  if (CFI_is_contiguous (b))\n+    abort ();\n+  (*fn) (b, lb, ub, s);\n+  dump_CFI_cdesc_t (b);\n+  dump_array (b, \"b\", \"b after calling Fortran fn\");\n+\n+  /* fn is supposed to negate the elements of the array section it\n+     receives.  Check that the original array has been updated.  */\n+  dump_array (a, \"a\", \"a after calling Fortran fn\");\n+  for (i = 0; i < a->dim[0].extent; i++)\n+    {\n+      int elt;\n+      int j = i + a->dim[0].lower_bound;\n+      CFI_index_t sub[1];\n+      sub[0] = j;\n+      elt = *((int *) CFI_address (a, sub));\n+      if (i + 1 >= lb && i + 1 <= ub && (i + 1 - lb) % s == 0)\n+\t{\n+          if (elt != - (i + 1))\n+\t    abort ();\n+\t}\n+      else if (elt != (i + 1))\n+\tabort ();\n+    }\n+}\n+\n+\n+/* Entry points for the Fortran side.  */\n+\n+void\n+ctest1 (CFI_cdesc_t *a)\n+{\n+  ctest (a, 5, 13, 2, ftest1);\n+}\n+\n+void\n+ctest2 (CFI_cdesc_t *a)\n+{\n+  ctest (a, 8, 20, 3, ftest2);\n+}\n+"}, {"sha": "bb8ba20a5b2b8cdf183cc427e0ef05e4d46ff608", "filename": "gcc/testsuite/gfortran.dg/c-interop/contiguous-2.f90", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-2.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,152 @@\n+! PR 101304\n+! { dg-do run { xfail *-*-* } }\n+! { dg-additional-sources \"contiguous-2-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! TS 29113\n+! 8.7 In an invocation of an interoperable procedure whose Fortran\n+! interface has an assumed-shape or assumed-rank dummy argument with the\n+! CONTIGUOUS attribute, the associated effective argument may be an\n+! array that is not contiguous or the address of a C descriptor for such\n+! an array. If the procedure is invoked from Fortran or the procedure is\n+! a Fortran procedure, the Fortran processor will handle the difference\n+! in contiguity. If the procedure is invoked from C and the procedure is\n+! a C procedure, the C code within the procedure shall be prepared to\n+! handle the situation of receiving a discontiguous argument.\n+!\n+! The wording is different in the 2018 standard, but the intent is more\n+! or less the same:\n+!\n+! When an interoperable Fortran procedure that is invoked from C has a \n+! dummy argument with the CONTIGUOUS attribute or that is an assumed-length \n+! CHARACTER explicit-shape or assumed-size array, and the actual argument \n+! is the address of a C descriptor for a discontiguous object, the Fortran \n+! processor shall handle the difference in contiguity.\n+!\n+! This program tests the cases where a Fortran procedure with C binding and\n+! a dummy array argument with the contiguous attribute is invoked from\n+! both C or Fortran.\n+\n+! ftest1 and ftest2 both negate the elements of their input array;\n+! this allows testing that modifications to the array contents get\n+! propagated back to the base array.\n+\n+module m\n+\n+  contains\n+\n+  subroutine ftest1 (a, first, last, step) bind (c)\n+    use iso_c_binding\n+    integer(C_INT), contiguous :: a(:)\n+    integer(C_INT), value :: first, last, step\n+    integer :: i, ival\n+\n+    ! Sanity checking that we got a contiguous array.  The direct call\n+    ! to is_contiguous might be optimized away, but the indirect one\n+    ! in check_contiguous shouldn't be.\n+    ! FIXME: is this correct?  \"the Fortran processor will handle the\n+    ! difference in contiguity\" may not mean that it's required to make\n+    ! the array contiguous, just that it can access it correctly?\n+    if (.not. is_contiguous (a)) stop 301\n+    call check_contiguous (a)\n+\n+    ! Sanity checking that we got the right input array contents.\n+    ! print *, 'a on entry to ftest1'\n+    ! do i = lbound(a, 1), ubound(a, 1)\n+    !   print *, 'a(', i, ') = ', a(i)\n+    ! end do\n+    ival = first\n+    do i = lbound(a, 1), ubound(a, 1)\n+      if (a (i) .ne. ival) then\n+        print *, 'a(', i, ') = ', a(i), '  expected ', ival\n+        stop 302\n+      end if\n+      a(i) = - a(i)\n+      ival = ival + step\n+    end do\n+  end subroutine\n+\n+  subroutine ftest2 (a, first, last, step) bind (c)\n+    use iso_c_binding\n+\n+    integer(C_INT), contiguous :: a(..)\n+    integer(C_INT), value :: first, last, step\n+\n+    select rank (a)\n+      rank (1)\n+        call ftest1 (a(:), first, last, step)\n+      rank default\n+        stop 303\n+    end select\n+  end subroutine\n+\n+  subroutine check_contiguous (a)\n+    use iso_c_binding\n+    integer(C_INT) :: a(..)\n+    if (.not. is_contiguous (a)) stop 304\n+  end subroutine\n+\n+end module\n+\n+\n+program testit\n+  use iso_c_binding\n+  use m\n+  implicit none\n+\n+  interface\n+    subroutine ctest1 (a) bind (c)\n+      use iso_c_binding\n+      integer(C_INT) :: a(:)\n+    end subroutine\n+    subroutine ctest2 (a) bind (c)\n+      use iso_c_binding\n+      integer(C_INT) :: a(..)\n+    end subroutine\n+  end interface\n+\n+  integer(C_INT) :: aa(32)\n+  integer :: i\n+\n+  ! assumed-shape, called from Fortran\n+  do i = 1, 32\n+    aa(i) = i\n+  end do\n+  call ftest1 (aa(4:12:2), 4, 12, 2)\n+  do i = 1, 32\n+    if (i .ge. 4 .and. i .le. 12 .and. mod (i-4,2) .eq. 0) then\n+      if (aa (i) .ne. -i) stop 101\n+    else\n+      if (aa (i) .ne. i) stop 102\n+    end if\n+  end do\n+\n+  ! assumed-shape, called from C code which will use the C interface\n+  ! to create a non-contiguous array section and pass it to ftest1.\n+  do i = 1, 32\n+    aa(i) = i\n+  end do\n+  call ctest1 (aa)\n+\n+  ! assumed-rank, called from Fortran\n+  do i = 1, 32\n+    aa(i) = i\n+  end do\n+  call ftest2 (aa(7:19:3), 7, 19, 3)\n+  do i = 1, 32\n+    if (i .ge. 7 .and. i .le. 19 .and. mod (i-7,3) .eq. 0) then\n+      if (aa (i) .ne. -i) stop 201\n+    else\n+      if (aa (i) .ne. i) stop 202\n+    end if\n+  end do\n+\n+  ! assumed-rank, called from C code which will use the C interface\n+  ! to create a non-contiguous array section and pass it to ftest2.\n+  do i = 1, 32\n+    aa(i) = i\n+  end do\n+  call ctest2 (aa)\n+\n+end program\n+"}, {"sha": "b124476f8f09487c3ae949577d93bd49b827107c", "filename": "gcc/testsuite/gfortran.dg/c-interop/contiguous-3-c.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-3-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-3-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-3-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,80 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest1 (CFI_cdesc_t *a, int first, int last, int step);\n+extern void ctest2 (CFI_cdesc_t *a, int first, int last, int step);\n+extern void ftest1 (CFI_cdesc_t *a, int first, int last, int step);\n+extern void ftest2 (CFI_cdesc_t *a, int first, int last, int step);\n+\n+#if 0\n+static void\n+dump_array (CFI_cdesc_t *a, const char *name, const char *note)\n+{\n+  int i;\n+\n+  fprintf (stderr, \"%s\\n\", note);\n+  for (i = 0; i < a->dim[0].extent; i++)\n+    {\n+      int j = i + a->dim[0].lower_bound;\n+      int elt;\n+      CFI_index_t sub[1];\n+      sub[0] = j;\n+      elt = *((int *) CFI_address (a, sub));\n+      fprintf (stderr, \"%s[%d] = %d\\n\", name, j, elt);\n+    }\n+  fprintf (stderr, \"\\n\");\n+}\n+#else\n+#define dump_array(a, name, note) \n+#endif\n+\n+static void\n+ctest (CFI_cdesc_t *a, int first, int last, int step,\n+       void (*fn) (CFI_cdesc_t *, int, int, int))\n+{\n+  int i;\n+\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+  dump_array (a, \"a\", \"a on input to ctest\");\n+\n+  /* Make sure we got a valid descriptor.  */\n+  if (!a->base_addr)\n+    abort ();\n+  if (a->elem_len != sizeof(int))\n+    abort ();\n+  if (a->rank != 1)\n+    abort ();\n+  if (a->type != CFI_type_int)\n+    abort ();\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+\n+  /* Pass it to the Fortran function fn.  */\n+  (*fn) (a, first, last, step);\n+  dump_CFI_cdesc_t (a);\n+  dump_array (a, \"a\", \"a after calling Fortran fn\");\n+}\n+\n+/* Entry points for the Fortran side.\n+   Note that the Fortran code has already created the array section\n+   and these functions were declared without the CONTIGUOUS attribute\n+   so they receive a non-contiguous array.  The magic is supposed to\n+   happen when we pass them back into a Fortran function declared with\n+   the CONTIGUOUS attribute.  */\n+\n+void\n+ctest1 (CFI_cdesc_t *a, int first, int last, int step)\n+{\n+  ctest (a, first, last, step, ftest1);\n+}\n+\n+void\n+ctest2 (CFI_cdesc_t *a, int first, int last, int step)\n+{\n+  ctest (a, first, last, step, ftest2);\n+}"}, {"sha": "9a6d66b14fda2e12ade51fd91817acf814a18c32", "filename": "gcc/testsuite/gfortran.dg/c-interop/contiguous-3.f90", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcontiguous-3.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,171 @@\n+! PR 101304\n+! { dg-do run { xfail *-*-* } }\n+! { dg-additional-sources \"contiguous-3-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! TS 29113\n+! 8.7 In an invocation of an interoperable procedure whose Fortran\n+! interface has an assumed-shape or assumed-rank dummy argument with the\n+! CONTIGUOUS attribute, the associated effective argument may be an\n+! array that is not contiguous or the address of a C descriptor for such\n+! an array. If the procedure is invoked from Fortran or the procedure is\n+! a Fortran procedure, the Fortran processor will handle the difference\n+! in contiguity. If the procedure is invoked from C and the procedure is\n+! a C procedure, the C code within the procedure shall be prepared to\n+! handle the situation of receiving a discontiguous argument.\n+!\n+! The wording is different in the 2018 standard, but the intent is more\n+! or less the same:\n+!\n+! When an interoperable Fortran procedure that is invoked from C has a \n+! dummy argument with the CONTIGUOUS attribute or that is an assumed-length \n+! CHARACTER explicit-shape or assumed-size array, and the actual argument \n+! is the address of a C descriptor for a discontiguous object, the Fortran \n+! processor shall handle the difference in contiguity.\n+!\n+! This program tests the cases where a Fortran procedure with C binding and\n+! a dummy array argument with the contiguous attribute is invoked from\n+! both C or Fortran.  It is similar to contiguous-2.f90 but here the array\n+! sections are created in Fortran even in the called-from-C case, rather\n+! than by calling CFI_section.\n+\n+! ftest1 and ftest2 both negate the elements of their input array;\n+! this allows testing that modifications to the array contents get\n+! propagated back to the base array.\n+\n+module m\n+\n+  contains\n+\n+  subroutine ftest1 (a, first, last, step) bind (c)\n+    use iso_c_binding\n+    integer(C_INT), contiguous :: a(:)\n+    integer(C_INT), value :: first, last, step\n+    integer :: i, ival\n+\n+    ! Sanity checking that we got a contiguous array.  The direct call\n+    ! to is_contiguous might be optimized away, but the indirect one\n+    ! in check_contiguous shouldn't be.\n+    ! FIXME: is this correct?  \"the Fortran processor will handle the\n+    ! difference in contiguity\" may not mean that it's required to make\n+    ! the array contiguous, just that it can access it correctly?\n+    if (.not. is_contiguous (a)) stop 301\n+    call check_contiguous (a)\n+\n+    ! Sanity checking that we got the right input array contents.\n+    ! print *, 'a on entry to ftest1'\n+    ! do i = lbound(a, 1), ubound(a, 1)\n+    !   print *, 'a(', i, ') = ', a(i)\n+    ! end do\n+    ival = first\n+    do i = lbound(a, 1), ubound(a, 1)\n+      if (a (i) .ne. ival) then\n+        print *, 'a(', i, ') = ', a(i), '  expected ', ival\n+        stop 302\n+      end if\n+      a(i) = - a(i)\n+      ival = ival + step\n+    end do\n+  end subroutine\n+\n+  subroutine ftest2 (a, first, last, step) bind (c)\n+    use iso_c_binding\n+\n+    integer(C_INT), contiguous :: a(..)\n+    integer(C_INT), value :: first, last, step\n+\n+    select rank (a)\n+      rank (1)\n+        call ftest1 (a(:), first, last, step)\n+      rank default\n+        stop 303\n+    end select\n+  end subroutine\n+\n+  subroutine check_contiguous (a)\n+    use iso_c_binding\n+    integer(C_INT) :: a(..)\n+    if (.not. is_contiguous (a)) stop 304\n+  end subroutine\n+\n+end module\n+\n+\n+program testit\n+  use iso_c_binding\n+  use m\n+  implicit none\n+\n+  ! Note ctest1 and ctest2 do not have the contiguous attribute on a.\n+  interface\n+    subroutine ctest1 (a, first, last, step) bind (c)\n+      use iso_c_binding\n+      integer(C_INT) :: a(:)\n+      integer(C_INT), value :: first, last, step\n+    end subroutine\n+    subroutine ctest2 (a, first, last, step) bind (c)\n+      use iso_c_binding\n+      integer(C_INT) :: a(..)\n+      integer(C_INT), value :: first, last, step\n+    end subroutine\n+  end interface\n+\n+  integer(C_INT) :: aa(32)\n+  integer :: i\n+\n+  ! assumed-shape, called from Fortran\n+  do i = 1, 32\n+    aa(i) = i\n+  end do\n+  call ftest1 (aa(4:12:2), 4, 12, 2)\n+  do i = 1, 32\n+    if (i .ge. 4 .and. i .le. 12 .and. mod (i-4,2) .eq. 0) then\n+      if (aa (i) .ne. -i) stop 101\n+    else\n+      if (aa (i) .ne. i) stop 102\n+    end if\n+  end do\n+\n+  ! assumed-shape, called indirectly from C code, using an array\n+  ! section created in Fortran instead of by CFI_section\n+  do i = 1, 32\n+    aa(i) = i\n+  end do\n+  call ctest1 (aa(5:13:2), 5, 13, 2)\n+  do i = 1, 32\n+    if (i .ge. 5 .and. i .le. 13 .and. mod (i-5,2) .eq. 0) then\n+      if (aa (i) .ne. -i) stop 103\n+    else\n+      if (aa (i) .ne. i) stop 104\n+    end if\n+  end do\n+\n+  ! assumed-rank, called from Fortran\n+  do i = 1, 32\n+    aa(i) = i\n+  end do\n+  call ftest2 (aa(7:19:3), 7, 19, 3)\n+  do i = 1, 32\n+    if (i .ge. 7 .and. i .le. 19 .and. mod (i-7,3) .eq. 0) then\n+      if (aa (i) .ne. -i) stop 201\n+    else\n+      if (aa (i) .ne. i) stop 202\n+    end if\n+  end do\n+\n+  ! assumed-rank, called indirectly from C code, using an array\n+  ! section created in Fortran instead of by CFI_section\n+  do i = 1, 32\n+    aa(i) = i\n+  end do\n+  call ctest2 (aa(8:20:3), 8, 20, 3)\n+  do i = 1, 32\n+    if (i .ge. 8 .and. i .le. 20 .and. mod (i-8,3) .eq. 0) then\n+      if (aa (i) .ne. -i) stop 203\n+    else\n+      if (aa (i) .ne. i) stop 204\n+    end if\n+  end do\n+\n+end program\n+"}, {"sha": "bd6d9cb3dd9c8b947429ad65785fefb4a3ad1a20", "filename": "gcc/testsuite/gfortran.dg/c-interop/deferred-character-1.f90", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fdeferred-character-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fdeferred-character-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fdeferred-character-1.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,76 @@\n+! PR92482\n+! { dg-do compile}\n+!\n+! TS 29113\n+! 8.7 Interoperability of procedures and procedure interfaces\n+! \n+! If a dummy argument in an interoperable interface is of type\n+! CHARACTER and is allocatable or a pointer, its character length shall\n+! be deferred.\n+!\n+! This test checks that this error is diagnosed and is supposed to fail.\n+\n+module m\n+  use iso_c_binding\n+\n+  interface\n+\n+    ! These are supposed to be OK\n+    subroutine good1 (x, n) bind (c)  ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+      use iso_c_binding\n+      character (kind=C_CHAR, len=:), allocatable :: x\n+      integer(C_INT), value :: n\n+    end subroutine\n+    subroutine good2 (x, n) bind (c)  ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+      use iso_c_binding\n+      character (kind=C_CHAR, len=:), pointer :: x\n+      integer(C_INT), value :: n\n+    end subroutine\n+\n+    ! These are supposed to fail.\n+    subroutine bad1 (x, n) bind (c)  ! { dg-error \"must have deferred length\" }\n+      use iso_c_binding\n+      character (kind=C_CHAR, len=*), allocatable :: x\n+      integer(C_INT), value :: n\n+    end subroutine\n+    subroutine bad2 (x, n) bind (c)  ! { dg-error \"must have deferred length\" }\n+      use iso_c_binding\n+      character (kind=C_CHAR, len=*), pointer :: x\n+      integer(C_INT), value :: n\n+    end subroutine\n+\n+    subroutine bad3 (x, n) bind (c)  ! { dg-error \"must have deferred length\" }\n+      use iso_c_binding\n+      character (kind=C_CHAR, len=80), allocatable :: x\n+      integer(C_INT), value :: n\n+    end subroutine\n+    subroutine bad4 (x, n) bind (c)  ! { dg-error \"must have deferred length\" }\n+      use iso_c_binding\n+      character (kind=C_CHAR, len=80), pointer :: x\n+      integer(C_INT), value :: n\n+    end subroutine\n+\n+    subroutine bad5 (x, n) bind (c)  ! { dg-error \"must have deferred length\" }\n+      use iso_c_binding\n+      character (kind=C_CHAR, len=1), allocatable :: x\n+      integer(C_INT), value :: n\n+    end subroutine\n+    subroutine bad6 (x, n) bind (c)  ! { dg-error \"must have deferred length\" }\n+      use iso_c_binding\n+      character (kind=C_CHAR, len=1), pointer :: x\n+      integer(C_INT), value :: n\n+    end subroutine\n+\n+    subroutine bad7 (x, n) bind (c)  ! { dg-error \"must have deferred length\" }\n+      use iso_c_binding\n+      character (kind=C_CHAR), allocatable :: x\n+      integer(C_INT), value :: n\n+    end subroutine\n+    subroutine bad8 (x, n) bind (c)  ! { dg-error \"must have deferred length\" }\n+      use iso_c_binding\n+      character (kind=C_CHAR), pointer :: x\n+      integer(C_INT), value :: n\n+    end subroutine\n+  end interface\n+\n+end module"}, {"sha": "9fd046def4ce7ccd4abf7b19646f21b47bca9633", "filename": "gcc/testsuite/gfortran.dg/c-interop/deferred-character-2.f90", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fdeferred-character-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fdeferred-character-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fdeferred-character-2.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,55 @@\n+! PR 92482\n+! { dg-do execute}\n+!\n+! TS 29113\n+! 8.7 Interoperability of procedures and procedure interfaces\n+! \n+! If a dummy argument in an interoperable interface is of type\n+! CHARACTER and is allocatable or a pointer, its character length shall\n+! be deferred.\n+\n+program testit\n+  use iso_c_binding\n+\n+  character (kind=C_CHAR, len=:), allocatable :: aa\n+  character (kind=C_CHAR, len=:), pointer :: pp\n+\n+\n+  pp => NULL ()\n+\n+  call frobf (aa, pp)\n+  if (.not. allocated (aa)) stop 101\n+  if (aa .ne. 'foo') stop 102\n+  if (.not. associated (pp)) stop 103\n+  if (pp .ne. 'bar') stop 104\n+\n+  pp => NULL ()\n+\n+  call frobc (aa, pp)\n+  if (.not. allocated (aa)) stop 101\n+  if (aa .ne. 'frog') stop 102\n+  if (.not. associated (pp)) stop 103\n+  if (pp .ne. 'toad') stop 104\n+\n+\n+  contains\n+\n+    subroutine frobf (a, p)\n+      use iso_c_binding\n+      character (kind=C_CHAR, len=:), allocatable :: a\n+      character (kind=C_CHAR, len=:), pointer :: p\n+      allocate (character(len=3) :: p)\n+      a = 'foo'\n+      p = 'bar'\n+    end subroutine\n+\n+    subroutine frobc (a, p) bind (c) ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+      use iso_c_binding\n+      character (kind=C_CHAR, len=:), allocatable :: a\n+      character (kind=C_CHAR, len=:), pointer :: p\n+      allocate (character(len=4) :: p)\n+      a = 'frog'\n+      p = 'toad'\n+    end subroutine\n+\n+end program"}, {"sha": "47e84e21c1350cbabd9fecd98e516684f653abcb", "filename": "gcc/testsuite/gfortran.dg/c-interop/dump-descriptors.c", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fdump-descriptors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fdump-descriptors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fdump-descriptors.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,195 @@\n+/* This file contains some useful routines for debugging problems with C\n+   descriptors.  Compiling it also acts as a test that the implementation of\n+   ISO_Fortran_binding.h provides all the types and constants specified in\n+   TS29113.  */\n+\n+#include <stdio.h>\n+#include <stddef.h>\n+#include <stdlib.h>\n+#include \"dump-descriptors.h\"\n+\n+void\n+dump_CFI_cdesc_t (CFI_cdesc_t *d)\n+{\n+  fprintf (stderr, \"<CFI_cdesc_t base_addr=%p elem_len=%ld version=%d\",\n+\t   d->base_addr, (long)(d->elem_len), d->version);\n+  fprintf (stderr, \"\\n  rank=\");\n+  dump_CFI_rank_t (d->rank);\n+  fprintf (stderr, \" type=\");\n+  dump_CFI_type_t (d->type);\n+  fprintf (stderr, \" attribute=\");\n+  dump_CFI_attribute_t (d->attribute);\n+  \n+  /* Dimension info may not be initialized if it's an allocatable\n+     or pointer descriptor with a null base_addr.  */\n+  if (d->rank > 0 && d->base_addr)\n+    {\n+      CFI_rank_t i;\n+      for (i = 0; i < d->rank; i++)\n+\t{\n+\t  if (i == 0)\n+\t    fprintf (stderr, \"\\n  dim=[\");\n+\t  else\n+\t    fprintf (stderr, \",\\n       \");\n+\t  dump_CFI_dim_t (d->dim + i);\n+\t}\n+      fprintf (stderr, \"]\");\n+    }\n+  fprintf (stderr, \">\\n\");\n+}\n+\n+void\n+dump_CFI_dim_t (CFI_dim_t *d)\n+{\n+  fprintf (stderr, \"<CFI_dim_t lower_bound=\");\n+  dump_CFI_index_t (d->lower_bound);\n+  fprintf (stderr, \" extent=\");\n+  dump_CFI_index_t (d->extent);\n+  fprintf (stderr, \" sm=\");\n+  dump_CFI_index_t (d->sm);\n+  fprintf (stderr, \">\");\n+}\n+\n+void\n+dump_CFI_attribute_t (CFI_attribute_t a)\n+{\n+  switch (a)\n+    {\n+    case CFI_attribute_pointer:\n+      fprintf (stderr, \"CFI_attribute_pointer\");\n+      break;\n+    case CFI_attribute_allocatable:\n+      fprintf (stderr, \"CFI_attribute_allocatable\");\n+      break;\n+    case CFI_attribute_other:\n+      fprintf (stderr, \"CFI_attribute_other\");\n+      break;\n+    default:\n+      fprintf (stderr, \"unknown(%d)\", (int)a);\n+      break;\n+    }\n+}\n+\n+void\n+dump_CFI_index_t (CFI_index_t i)\n+{\n+  fprintf (stderr, \"%ld\", (long)i);\n+}\n+\n+void\n+dump_CFI_rank_t (CFI_rank_t r)\n+{\n+  fprintf (stderr, \"%d\", (int)r);\n+}\n+\n+/* We can't use a switch statement to dispatch CFI_type_t because\n+   the type name macros may not be unique.  Iterate over a table\n+   instead.  */\n+\n+struct type_name_map {\n+  CFI_type_t t;\n+  const char *n;\n+};\n+\n+struct type_name_map type_names[] =\n+{\n+  { CFI_type_signed_char, \"CFI_type_signed_char\" },\n+  { CFI_type_short, \"CFI_type_short\" },\n+  { CFI_type_int, \"CFI_type_int\" },\n+  { CFI_type_long, \"CFI_type_long\" },\n+  { CFI_type_long_long, \"CFI_type_long_long\" },\n+  { CFI_type_size_t, \"CFI_type_size_t\" },\n+  { CFI_type_int8_t, \"CFI_type_int8_t\" },\n+  { CFI_type_int16_t, \"CFI_type_int16_t\" },\n+  { CFI_type_int32_t, \"CFI_type_int32_t\" },\n+  { CFI_type_int64_t, \"CFI_type_int64_t\" },\n+  { CFI_type_int_least8_t, \"CFI_type_int_least8_t\" },\n+  { CFI_type_int_least16_t, \"CFI_type_int_least16_t\" },\n+  { CFI_type_int_least32_t, \"CFI_type_int_least32_t\" },\n+  { CFI_type_int_least64_t, \"CFI_type_int_least64_t\" },\n+  { CFI_type_int_fast8_t, \"CFI_type_int_fast8_t\" },\n+  { CFI_type_int_fast16_t, \"CFI_type_int_fast16_t\" },\n+  { CFI_type_int_fast32_t, \"CFI_type_int_fast32_t\" },\n+  { CFI_type_int_fast64_t, \"CFI_type_int_fast64_t\" },\n+  { CFI_type_intmax_t, \"CFI_type_intmax_t\" },\n+  { CFI_type_intptr_t, \"CFI_type_intptr_t\" },\n+  { CFI_type_ptrdiff_t, \"CFI_type_ptrdiff_t\" },\n+  { CFI_type_float, \"CFI_type_float\" },\n+  { CFI_type_double, \"CFI_type_double\" },\n+  { CFI_type_long_double, \"CFI_type_long_double\" },\n+  { CFI_type_float_Complex, \"CFI_type_float_Complex\" },\n+  { CFI_type_double_Complex, \"CFI_type_double_Complex\" },\n+  { CFI_type_long_double_Complex, \"CFI_type_long_double_Complex\" },\n+  { CFI_type_Bool, \"CFI_type_Bool\" },\n+  { CFI_type_char, \"CFI_type_char\" },\n+  { CFI_type_cptr, \"CFI_type_cptr\" },\n+  { CFI_type_struct, \"CFI_type_struct\" },\n+  { CFI_type_other, \"CFI_type_other\" },\n+  /* Extension types */\n+  { CFI_type_int128_t, \"CFI_type_int128_t\" },\n+  { CFI_type_int_least128_t, \"CFI_type_int_least128_t\" },\n+  { CFI_type_int_fast128_t, \"CFI_type_int_fast128_t\" },\n+  { CFI_type_ucs4_char, \"CFI_type_ucs4_char\" },\n+  { CFI_type_float128, \"CFI_type_float128\" },\n+  { CFI_type_float128_Complex, \"CFI_type_float128_Complex\" },\n+  { CFI_type_cfunptr, \"CFI_type_cfunptr\" }\n+};\n+  \n+void\n+dump_CFI_type_t (CFI_type_t t)\n+{\n+  int i;\n+  for (i = 0; i < sizeof (type_names) / sizeof (struct type_name_map); i++)\n+    if (type_names[i].t == t)\n+      {\n+\tfprintf (stderr, \"%s\", type_names[i].n);\n+\treturn;\n+      }\n+  fprintf (stderr, \"unknown(%d)\", (int)t);\n+}\n+\n+void\n+check_CFI_status (const char *fn, int code)\n+{\n+  const char *msg;\n+  switch (code)\n+    {\n+    case CFI_SUCCESS:\n+      return;\n+    case CFI_ERROR_BASE_ADDR_NULL:\n+      msg = \"CFI_ERROR_BASE_ADDR_NULL\";\n+      break;\n+    case CFI_ERROR_BASE_ADDR_NOT_NULL:\n+      msg = \"CFI_ERROR_BASE_ADDR_NOT_NULL\";\n+      break;\n+    case CFI_INVALID_ELEM_LEN:\n+      msg = \"CFI_INVALID_ELEM_LEN\";\n+      break;\n+    case CFI_INVALID_RANK:\n+      msg = \"CFI_INVALID_RANK\";\n+      break;\n+    case CFI_INVALID_TYPE:\n+      msg = \"CFI_INVALID_TYPE\";\n+      break;\n+    case CFI_INVALID_ATTRIBUTE:\n+      msg = \"CFI_INVALID_ATTRIBUTE\";\n+      break;\n+    case CFI_INVALID_EXTENT:\n+      msg = \"CFI_INVALID_EXTENT\";\n+      break;\n+    case CFI_INVALID_DESCRIPTOR:\n+      msg = \"CFI_INVALID_DESCRIPTOR\";\n+      break;\n+    case CFI_ERROR_MEM_ALLOCATION:\n+      msg = \"CFI_ERROR_MEM_ALLOCATION\";\n+      break;\n+    case CFI_ERROR_OUT_OF_BOUNDS:\n+      msg = \"CFI_ERROR_OUT_OF_BOUNDS\";\n+      break;\n+    default:\n+      msg = \"unknown error\";\n+      break;\n+    }\n+  fprintf (stderr, \"%s returned %s\\n\", fn, msg);\n+  abort ();\n+}"}, {"sha": "52375a9bdaca783aeb735c98b3a4632627d8d877", "filename": "gcc/testsuite/gfortran.dg/c-interop/dump-descriptors.h", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fdump-descriptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fdump-descriptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fdump-descriptors.h?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,12 @@\n+/* Definitions of functions in dump-descriptors.c.  */\n+\n+#include \"ISO_Fortran_binding.h\"\n+\n+extern void dump_CFI_cdesc_t (CFI_cdesc_t *d);\n+extern void dump_CFI_dim_t (CFI_dim_t *d);\n+extern void dump_CFI_attribute_t (CFI_attribute_t a);\n+extern void dump_CFI_index_t (CFI_index_t i);\n+extern void dump_CFI_rank_t (CFI_rank_t r);\n+extern void dump_CFI_type_t (CFI_type_t t);\n+\n+void check_CFI_status (const char *fn, int code);"}, {"sha": "9e7900de7df1a64f29c05bbbcea69739e97dd254", "filename": "gcc/testsuite/gfortran.dg/c-interop/establish-c.c", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Festablish-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Festablish-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Festablish-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,134 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+/* For simplicity, point descriptors at a static buffer.  BUFSIZE should\n+   be large enough for any of the standard types and we'll use DIM0 and DIM1\n+   for array dimensions.  */\n+#define BUFSIZE 64\n+#define DIM0 3\n+#define DIM1 10\n+#define ARRAYBUFSIZE BUFSIZE * DIM0 * DIM1\n+static char *buf[ARRAYBUFSIZE] __attribute__ ((aligned (8)));\n+static CFI_index_t extents[] = {DIM0, DIM1};\n+\n+/* Magic number to use for elem_len field.  */\n+#define MAGIC_ELEM_LEN 20\n+\n+struct tc_info\n+{\n+  CFI_type_t typecode;\n+  char *name;\n+  size_t size;\n+};\n+\n+static struct tc_info tc_table[] =\n+{\n+  { CFI_type_signed_char, \"CFI_type_signed_char\", sizeof (signed char) },\n+  { CFI_type_short, \"CFI_type_short\", sizeof (short) },\n+  { CFI_type_int, \"CFI_type_int\", sizeof (int) },\n+  { CFI_type_long, \"CFI_type_long\", sizeof (long) },\n+  { CFI_type_long_long, \"CFI_type_long_long\", sizeof (long long) },\n+  { CFI_type_size_t, \"CFI_type_size_t\", sizeof (size_t) },\n+  { CFI_type_int8_t, \"CFI_type_int8_t\", sizeof (int8_t) },\n+  { CFI_type_int16_t, \"CFI_type_int16_t\", sizeof (int16_t) },\n+  { CFI_type_int32_t, \"CFI_type_int32_t\", sizeof (int32_t) },\n+  { CFI_type_int64_t, \"CFI_type_int64_t\", sizeof (int64_t) },\n+  { CFI_type_int_least8_t, \"CFI_type_int_least8_t\", sizeof (int_least8_t) },\n+  { CFI_type_int_least16_t, \"CFI_type_int_least16_t\", sizeof (int_least16_t) },\n+  { CFI_type_int_least32_t, \"CFI_type_int_least32_t\", sizeof (int_least32_t) },\n+  { CFI_type_int_least64_t, \"CFI_type_int_least64_t\", sizeof (int_least64_t) },\n+  { CFI_type_int_fast8_t, \"CFI_type_int_fast8_t\", sizeof (int_fast8_t) },\n+  { CFI_type_int_fast16_t, \"CFI_type_int_fast16_t\", sizeof (int_fast16_t) },\n+  { CFI_type_int_fast32_t, \"CFI_type_int_fast32_t\", sizeof (int_fast32_t) },\n+  { CFI_type_int_fast64_t, \"CFI_type_int_fast64_t\", sizeof (int_fast64_t) },\n+  { CFI_type_intmax_t, \"CFI_type_intmax_t\", sizeof (intmax_t) },\n+  { CFI_type_intptr_t, \"CFI_type_intptr_t\", sizeof (intptr_t) },\n+  { CFI_type_ptrdiff_t, \"CFI_type_ptrdiff_t\", sizeof (ptrdiff_t) },\n+  { CFI_type_float, \"CFI_type_float\", sizeof (float) },\n+  { CFI_type_double, \"CFI_type_double\", sizeof (double) },\n+  { CFI_type_long_double, \"CFI_type_long_double\", sizeof (long double) },\n+  { CFI_type_float_Complex, \"CFI_type_float_Complex\",\n+    sizeof (float _Complex) },\n+  { CFI_type_double_Complex, \"CFI_type_double_Complex\",\n+    sizeof (double _Complex) },\n+  { CFI_type_long_double_Complex, \"CFI_type_long_double_Complex\",\n+    sizeof (long double _Complex) },\n+  { CFI_type_Bool, \"CFI_type_Bool\", sizeof (_Bool) },\n+  { CFI_type_char, \"CFI_type_char\", sizeof (char) },\n+  { CFI_type_cptr, \"CFI_type_cptr\", sizeof (void *) },\n+  { CFI_type_struct, \"CFI_type_struct\", 0 },\n+  { CFI_type_other, \"CFI_type_other\", -1 }\n+};\n+\n+int\n+test_array (struct tc_info *tc, void *ptr, CFI_attribute_t attr)\n+{\n+  CFI_CDESC_T(2) desc;\n+  CFI_cdesc_t *a = (CFI_cdesc_t *) &desc;\n+  int bad = 0;\n+  size_t elem_len;\n+\n+  /* Initialize the descriptor to garbage values so we can confirm it's\n+     properly initialized with good ones later.  */\n+  memset (a, -1, sizeof(desc));\n+  \n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (a, ptr, attr, tc->typecode,\n+\t\t\t\t   MAGIC_ELEM_LEN, 2, extents));\n+\n+  /* elem_len is ignored unless type is CFI type struct, CFI type other, \n+     or a character type.  */\n+  if (tc->typecode == CFI_type_char\n+      || tc->typecode == CFI_type_struct\n+      || tc->typecode == CFI_type_other)\n+    elem_len = MAGIC_ELEM_LEN;\n+  else\n+    elem_len = tc->size;\n+\n+  if (a->elem_len != elem_len\n+      || a->base_addr != ptr\n+      || a->type != tc->typecode\n+      || a->version != CFI_VERSION\n+      || a->attribute != attr\n+      || a->rank != 2\n+      || (ptr &&\n+\t  /* extents parameter is ignored if ptr is null */\n+\t  (a->dim[0].lower_bound != 0\n+\t   || a->dim[0].extent != DIM0\n+\t   || a->dim[0].sm != elem_len\n+\t   || a->dim[1].lower_bound != 0\n+\t   || a->dim[1].extent != DIM1\n+\t   || a->dim[1].sm != elem_len*DIM0)))\n+    {\n+      fprintf (stderr, \"Bad array descriptor for %s:\\n\", tc->name);\n+      dump_CFI_cdesc_t (a);\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* External entry point.  */\n+extern void ctest_establish (void);\n+\n+void\n+ctest_establish (void)\n+{\n+  int ncodes = sizeof (tc_table) / sizeof (struct tc_info);\n+  int i;\n+  int bad = 0;\n+\n+  for (i = 0; i < ncodes; i++)\n+    {\n+      bad += test_array (&tc_table[i], (void *)buf, CFI_attribute_other);\n+      bad += test_array (&tc_table[i], NULL, CFI_attribute_allocatable);\n+      bad += test_array (&tc_table[i], (void *)buf, CFI_attribute_pointer);\n+    }\n+  if (bad)\n+    abort ();\n+}\n+"}, {"sha": "80976552db1e595f67c3243f555d97e9753650c7", "filename": "gcc/testsuite/gfortran.dg/c-interop/establish-errors-c.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Festablish-errors-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Festablish-errors-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Festablish-errors-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,120 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+/* For simplicity, point descriptors at a static buffer.  BUFSIZE should\n+   be large enough for any of the standard types and we'll use DIM0 and DIM1\n+   for array dimensions.  */\n+#define BUFSIZE 64\n+#define DIM0 3\n+#define DIM1 10\n+#define ARRAYBUFSIZE BUFSIZE * DIM0 * DIM1\n+static char *buf[ARRAYBUFSIZE] __attribute__ ((aligned (8)));\n+static CFI_index_t extents[] = {DIM0, DIM1};\n+\n+/* Magic number to use for elem_len field.  */\n+#define MAGIC_ELEM_LEN 20\n+\n+\n+/* External entry point.  */\n+extern void ctest (void);\n+\n+void\n+ctest (void)\n+{\n+  int bad = 0;\n+  int status;\n+  CFI_CDESC_T(2) desc;\n+  CFI_cdesc_t *a = (CFI_cdesc_t *) &desc;\n+\n+  /* If the attribute argument is CFI_attribute_allocatable,\n+     base_addr shall be a null pointer.  */\n+  status = CFI_establish (a, (void *)buf, CFI_attribute_allocatable,\n+\t\t\t  CFI_type_int, 0, 2, extents);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for non-null pointer with CFI_attribute_allocatable\\n\");\n+      bad ++;\n+    }\n+\n+  /* type shall have the value of one of the type codes in Table 18.4,\n+     or have a positive value corresponding to an interoperable C type. */\n+  status = CFI_establish (a, (void *)buf, CFI_attribute_other,\n+\t\t\t  CFI_type_other - 1, 0, 2, extents);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for invalid negative type code\\n\");\n+      bad ++;\n+    }\n+\n+  /* If the type is CFI_type_struct, CFI_type_other, or a Fortran\n+     character type, elem_len shall be greater than zero and equal to\n+     the storage size in bytes of an element of the object.  */\n+  status = CFI_establish (a, (void *)buf, CFI_attribute_other,\n+\t\t\t  CFI_type_struct, 0, 2, extents);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for invalid size with CFI_type_struct\\n\");\n+      bad ++;\n+    }\n+ \n+  status = CFI_establish (a, (void *)buf, CFI_attribute_other,\n+\t\t\t  CFI_type_char, 0, 2, extents);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for invalid size with CFI_type_char\\n\");\n+      bad ++;\n+    }\n+\n+  /* Rank shall be between 0 and CFI_MAX_RANK inclusive.  */\n+  status = CFI_establish (a, NULL, CFI_attribute_allocatable,\n+\t\t\t  CFI_type_int, 0, -1, extents);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for negative rank\\n\");\n+      bad ++;\n+    }\n+  status = CFI_establish (a, NULL, CFI_attribute_allocatable,\n+\t\t\t  CFI_type_int, 0, CFI_MAX_RANK + 1, extents);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for rank > CFI_MAX_RANK\\n\");\n+      bad ++;\n+    }\n+\n+  /* extents is ignored if the rank r is zero or if base_addr is a\n+     null pointer. Otherwise, it shall be the address of an array...  */\n+  status = CFI_establish (a, (void *)buf, CFI_attribute_other,\n+\t\t\t  CFI_type_int, 0, 2, NULL);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for null extents\\n\");\n+      bad ++;\n+    }\n+\n+  /* Extents shall all be nonnegative.  */\n+  extents[1] = -extents[1];\n+  status = CFI_establish (a, (void *)buf, CFI_attribute_other,\n+\t\t\t  CFI_type_int, 0, 2, extents);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for negative extents\\n\");\n+      bad ++;\n+    }\n+\n+  if (bad)\n+    abort ();\n+}\n+"}, {"sha": "307a2664b74344496befc3ab0e8c362c9dce8c1e", "filename": "gcc/testsuite/gfortran.dg/c-interop/establish-errors.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Festablish-errors.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Festablish-errors.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Festablish-errors.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,30 @@\n+! PR101317\n+! { dg-do run }\n+! { dg-additional-sources \"establish-errors-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-Wno-error -fcheck=all\" }\n+! { dg-warning \"command-line option '-fcheck=all' is valid for Fortran but not for C\" \"\" { target *-*-* } 0 }\n+!\n+! This program tests that the CFI_establish function properly detects\n+! invalid arguments.  All the interesting things happen in the \n+! corresponding C code.\n+!\n+! The situation here seems to be that while TS29113 defines error codes\n+! for CFI_establish, it doesn't actually require the implementation to detect\n+! those errors by saying the arguments \"shall be\" such-and-such, e.g. it is\n+! undefined behavior if they are not.  In gfortran you can enable some\n+! run-time checking by building with -fcheck=all.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+\n+    subroutine ctest () bind (c)\n+    end subroutine\n+\n+  end interface\n+\n+  call ctest ()\n+\n+end program"}, {"sha": "5b263abf51f2aa98d4c80d0847c3025b38e7eed8", "filename": "gcc/testsuite/gfortran.dg/c-interop/establish.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Festablish.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Festablish.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Festablish.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,35 @@\n+! PR 101305\n+! { dg-do run }\n+! { dg-additional-sources \"establish-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program tests the CFI_establish function.  All the interesting\n+! things happen in the corresponding C code.\n+\n+! Eventually we might want to make the C code pass the descriptors back to\n+! C-callable Fortran functions, but for now it just checks them internally.\n+\n+module mm\n+  use iso_c_binding\n+\n+  type, bind (c) :: s\n+    integer(C_INT) :: i, j\n+  end type\n+end module\n+  \n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  interface\n+\n+    subroutine ctest_establish () bind (c)\n+    end subroutine\n+\n+  end interface\n+\n+  call ctest_establish ()\n+\n+end program"}, {"sha": "a7eda825758f36077c739c181357be85fab3cdfe", "filename": "gcc/testsuite/gfortran.dg/c-interop/explicit-interface.f90", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fexplicit-interface.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fexplicit-interface.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fexplicit-interface.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,60 @@\n+! { dg-do compile }\n+!\n+! TS 29113\n+! 6.2 Explicit interface\n+! \n+! Additionally to the rules of subclause 12.4.2.2 of ISO/IEC 1539-1:2010,\n+! a procedure shall have an explicit interface if it has a dummy argument\n+! that is assumed-rank.\n+!\n+! NOTE 6.1\n+! An explicit interface is also required for a procedure if it has a\n+! dummy argument that is assumed-type because an assumed-type dummy \n+! argument is polymorphic.\n+!\n+! This file contains code that is expected to produce errors.\n+\n+module m1\n+\n+  interface\n+\n+    subroutine s1 (a)\n+      integer :: a(..)\n+    end subroutine\n+\n+    subroutine s2 (b)\n+      type(*) :: b\n+    end subroutine\n+\n+  end interface\n+\n+end module\n+\n+module m2\n+\n+  contains\n+\n+  ! This subroutine has an explicit interface, and so do the things\n+  ! it calls.\n+  subroutine good (a, b)\n+    use m1\n+    integer :: a(..)\n+    type (*) :: b\n+\n+    call s1 (a)\n+    call s2 (b)\n+  end subroutine\n+\n+  ! This subroutine has an explicit interface, but the things it calls don't.\n+  subroutine bad (a, b)\n+    use m1\n+    integer :: a(..)\n+    type (*) :: b\n+    external :: s3, s4\n+\n+    call s3 (a)  ! { dg-error \"Assumed-rank argument\" }\n+    call s4 (b)  ! { dg-error \"Assumed-type argument\" }\n+  end subroutine\n+\n+end module\n+"}, {"sha": "674f0bd6c4bd1556af6c5f3af37a381158a38ef6", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-1-c.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-1-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-1-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-1-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,46 @@\n+#include <stdlib.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *a);\n+\n+void\n+ctest (CFI_cdesc_t *a)\n+{\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+\n+  /* The actual argument on the Fortran side was declared as \n+       integer(C_INT) :: aa(10,-1:3)\n+     Make sure that matches what's in the descriptor.  Note that per\n+     section 18.5.3 in the 2018 standard, for a nonallocatable nonpointer\n+     array, the array dimensions in the descriptor reflect the shape of\n+     the array rather than the actual bounds; the lower_bound is required\n+     to be zero.  */\n+  if (!a->base_addr)\n+    abort ();\n+  if (a->elem_len != sizeof(int))\n+    abort ();\n+  if (a->rank != 2)\n+    abort ();\n+  if (a->type != CFI_type_int)\n+    abort ();\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+  if (a->dim[0].lower_bound != 0)\n+    abort ();\n+  if (a->dim[0].extent != 10)\n+    abort ();\n+  if (a->dim[0].sm != sizeof(int))\n+    abort ();\n+  if (a->dim[1].lower_bound != 0)\n+    abort ();\n+  if (a->dim[1].extent != 5)\n+    abort ();\n+  if (a->dim[1].sm != a->dim[0].extent * sizeof(int))\n+    abort ();\n+  if (!CFI_is_contiguous (a))\n+    abort ();\n+}"}, {"sha": "9a540eef021be2cb45af10a38a2da995c27c7f20", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-1.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-1.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do run }\n+! { dg-additional-sources \"fc-descriptor-1-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This checks that a C function declared to have an assumed-shape array\n+! argument can be called from Fortran and receives a correct descriptor.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+    subroutine ctest (a) bind (c)\n+      use iso_c_binding\n+      integer(C_INT) :: a(:,:)\n+    end subroutine\n+  end interface\n+\n+  integer(C_INT) :: aa(10,-1:3)\n+\n+  ! Test both passing the fixed-size array directly to the function\n+  ! with a C interface, and indirectly via a Fortran function with an\n+  ! assumed-shape dummy argument.\n+  call ctest (aa)\n+  call ftest (aa)\n+\n+contains\n+  subroutine ftest (a)\n+    use iso_c_binding\n+    integer(C_INT) :: a(:,:)\n+    call ctest (a)\n+  end subroutine\n+\n+end program"}, {"sha": "5ce0bfe91fe4a916c1b4156dd91486aed364073a", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-2-c.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-2-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-2-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-2-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,68 @@\n+#include <stdlib.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *a, int n);\n+\n+void\n+ctest (CFI_cdesc_t *a, int n)\n+{\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+\n+  if (!a->base_addr)\n+    abort ();\n+  if (a->elem_len != sizeof(float))\n+    abort ();\n+  if (a->type != CFI_type_float)\n+    abort ();\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+\n+  if (n == 1)\n+    {\n+      /* The actual argument on the Fortran side was declared as \n+\t real(C_FLOAT):: aa(100)  */\n+      if (a->rank != 1)\n+\tabort ();\n+      if (a->dim[0].lower_bound != 0)\n+\tabort ();\n+      if (a->dim[0].extent != 100)\n+\tabort ();\n+      if (a->dim[0].sm != sizeof(float))\n+\tabort ();\n+      if (!CFI_is_contiguous (a))\n+\tabort ();\n+    }\n+  else if (n == 3)\n+    {\n+      /* The actual argument on the Fortran side was declared as \n+\t real(C_FLOAT) :: bb(3,4,5)  */\n+      if (a->rank != 3)\n+\tabort ();\n+      if (a->dim[0].lower_bound != 0)\n+\tabort ();\n+      if (a->dim[0].extent != 3)\n+\tabort ();\n+      if (a->dim[0].sm != sizeof(float))\n+\tabort ();\n+      if (a->dim[1].lower_bound != 0)\n+\tabort ();\n+      if (a->dim[1].extent != 4)\n+\tabort ();\n+      if (a->dim[1].sm != a->dim[0].sm * a->dim[0].extent)\n+\tabort ();\n+      if (a->dim[2].lower_bound != 0)\n+\tabort ();\n+      if (a->dim[2].extent != 5)\n+\tabort ();\n+      if (a->dim[2].sm != a->dim[1].sm * a->dim[1].extent)\n+\tabort ();\n+      if (!CFI_is_contiguous (a))\n+\tabort ();\n+    }\n+  else\n+    abort ();\n+}"}, {"sha": "ec90735aacaee9ed3c44ef7dfcfc6ecb7b051cc3", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-2.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-2.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do run }\n+! { dg-additional-sources \"fc-descriptor-2-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program checks that a C function declared to take an assumed-rank\n+! array argument can be called from Fortran, and receives a correct\n+! descriptor.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+    subroutine ctest (a, n) bind (c)\n+      use iso_c_binding\n+      real(C_FLOAT) :: a(..)\n+      integer(C_INT), value :: n\n+    end subroutine\n+  end interface\n+\n+  real(C_FLOAT) :: aa(100)\n+  real(C_FLOAT) :: bb(3,4,5)\n+\n+  ! Test both passing the fixed-size array directly to the function\n+  ! with a C interface, and indirectly via a Fortran function with an\n+  ! assumed-rank dummy argument.\n+  call ctest (aa, 1)\n+  call ctest (bb, 3)\n+  call ftest (aa, 1)\n+  call ftest (bb, 3)\n+\n+contains\n+  subroutine ftest (a, n)\n+    use iso_c_binding\n+    real(C_FLOAT) :: a(..)\n+    integer, value :: n\n+    call ctest (a, n)\n+  end subroutine\n+\n+end program"}, {"sha": "a432ee4c42cd6acdfbeb97d8be8d325b73608373", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-3-c.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-3-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-3-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-3-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,42 @@\n+#include <stdlib.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *a, CFI_cdesc_t *b, int initp);\n+\n+void\n+ctest (CFI_cdesc_t *a, CFI_cdesc_t *b, int initp)\n+{\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+  dump_CFI_cdesc_t (b);\n+\n+  /* Make sure the descriptors match what we are expecting.  a is an\n+     allocatable derived type object, b is a pointer which points at a\n+     if initp is true.  */\n+  if (initp && !a->base_addr)\n+    abort ();\n+  else if (!initp && a->base_addr)\n+    abort ();\n+  if (a->base_addr != b->base_addr)\n+    abort ();\n+\n+  if (a->rank != 0)\n+    abort ();\n+  if (b->rank != 0)\n+    abort ();\n+  if (a->type != CFI_type_struct)\n+    abort ();\n+  if (b->type != CFI_type_struct)\n+    abort ();\n+  if (a->elem_len != 3 * 3 * sizeof(double))\n+    abort ();\n+  if (b->elem_len != 3 * 3 * sizeof(double))\n+    abort ();\n+  if (a->attribute != CFI_attribute_allocatable)\n+    abort ();\n+  if (b->attribute != CFI_attribute_pointer)\n+    abort ();\n+}"}, {"sha": "174d1e728fd9b0f68023cb67ce52b54b15d51ddf", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-3.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-3.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,37 @@\n+! PR 101308\n+! { dg-do run { xfail *-*-* } }\n+! { dg-additional-sources \"fc-descriptor-3-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program tests that pointer and allocatable scalar arguments are \n+! correctly passed by descriptor from Fortran code into C.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  type, bind (c) :: m\n+    real(C_DOUBLE) :: a(3, 3)\n+  end type\n+\n+  interface\n+    subroutine ctest (a, b, initp) bind (c)\n+      use iso_c_binding\n+      import m\n+      type(m), allocatable :: a\n+      type(m), pointer :: b\n+      integer(C_INT), value :: initp\n+    end subroutine\n+  end interface\n+\n+  type (m), allocatable, target :: aa\n+  type (m), pointer :: bb\n+\n+  ! Test both before and after allocation/pointer initialization.\n+  bb => null()\n+  call ctest (aa, bb, 0)\n+  allocate (aa)\n+  bb => aa\n+  call ctest (aa, bb, 1)\n+\n+end program"}, {"sha": "579e66d93766754c74ccfc342068f7c64d491841", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-4-c.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-4-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-4-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-4-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,57 @@\n+#include <stdlib.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *a, CFI_cdesc_t *b, int initp);\n+\n+void\n+ctest (CFI_cdesc_t *a, CFI_cdesc_t *b, int initp)\n+{\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+  dump_CFI_cdesc_t (b);\n+\n+  /* Make sure the descriptors match what we are expecting.  a is an\n+     allocatable derived type object, b is a pointer which points at a\n+     if initp is true.  */\n+  if (initp && !a->base_addr)\n+    abort ();\n+  else if (!initp && a->base_addr)\n+    abort ();\n+  if (a->base_addr != b->base_addr)\n+    abort ();\n+\n+  if (a->type != CFI_type_struct)\n+    abort ();\n+  if (b->type != CFI_type_struct)\n+    abort ();\n+  if (a->elem_len != 3 * 3 * sizeof(double))\n+    abort ();\n+  if (b->elem_len != 3 * 3 * sizeof(double))\n+    abort ();\n+  if (a->attribute != CFI_attribute_allocatable)\n+    abort ();\n+  if (b->attribute != CFI_attribute_pointer)\n+    abort ();\n+\n+  if (initp)\n+    /* The actual array is allocated with\n+         allocate (aa(3:7))\n+       Per 8.3.3 of TS29113, the lower_bound must reflect that.  */\n+    {\n+      if (a->rank != 1)\n+\tabort ();\n+      if (b->rank != 1)\n+\tabort ();\n+      if (a->dim[0].lower_bound != 3)\n+\tabort ();\n+      if (b->dim[0].lower_bound != 3)\n+\tabort ();\n+      if (a->dim[0].extent != 5)\n+\tabort ();\n+      if (b->dim[0].extent != 5)\n+\tabort ();\n+    }\n+}"}, {"sha": "db73dafe1d5b2db008a722914c0e0578115ab2fd", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-4.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-4.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do run }\n+! { dg-additional-sources \"fc-descriptor-4-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program tests that pointer and allocatable array arguments are \n+! correctly passed by descriptor from Fortran code into C.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  type, bind (c) :: m\n+    real(C_DOUBLE) :: a(3, 3)\n+  end type\n+\n+  interface\n+    subroutine ctest (a, b, initp) bind (c)\n+      use iso_c_binding\n+      import m\n+      type(m), allocatable :: a(:)\n+      type(m), pointer :: b(:)\n+      integer(C_INT), value :: initp\n+    end subroutine\n+  end interface\n+\n+  type (m), allocatable, target :: aa(:)\n+  type (m), pointer :: bb(:)\n+\n+  ! Test both before and after allocation/pointer initialization.\n+  bb => NULL ()\n+  call ctest (aa, bb, 0)\n+  allocate (aa(3:7))\n+  bb => aa\n+  call ctest (aa, bb, 1)\n+\n+end program"}, {"sha": "6f2718501d225ae4c6cc72752e4654637b7ee9cb", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-5-c.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-5-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-5-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-5-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,28 @@\n+#include <stdlib.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *a);\n+\n+void\n+ctest (CFI_cdesc_t *a)\n+{\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+\n+  /* The actual argument on the Fortran side was declared as \n+     character(len=20) :: aa\n+     Make sure that matches what's in the descriptor.  */\n+  if (!a->base_addr)\n+    abort ();\n+  if (a->elem_len != 20)\n+    abort ();\n+  if (a->rank != 0)\n+    abort ();\n+  if (a->type != CFI_type_char)\n+    abort ();\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+}"}, {"sha": "5ac406fdcc1ac8ae264deadcdb7b24b0b26ea623", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-5.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-5.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,35 @@\n+! PR92482\n+! { dg-do run }\n+! { dg-additional-sources \"fc-descriptor-5-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program tests it works to call a C function from Fortran with \n+! an assumed length character dummy.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+    subroutine ctest (a) bind (c) ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+      use iso_c_binding\n+      character(len=*,kind=C_CHAR) :: a\n+    end subroutine\n+  end interface\n+\n+  character(len=20,kind=C_CHAR) :: aa\n+\n+  ! Test both passing the fixed-length string directly to the function\n+  ! with a C interface, and indirectly via a Fortran function with an\n+  ! assumed-length dummy argument.\n+  call ctest (aa)\n+  call ftest (aa)\n+\n+contains\n+  subroutine ftest (a)\n+    use iso_c_binding\n+    character(len=*,kind=C_CHAR) :: a\n+    call ctest (a)\n+  end subroutine\n+\n+end program"}, {"sha": "875dbb8793020c5cf594eb255334bdebd00e4021", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-6-c.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-6-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-6-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-6-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,51 @@\n+#include <stdlib.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *a);\n+\n+void\n+ctest (CFI_cdesc_t *a)\n+{\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+\n+  /* The actual argument on the Fortran side was declared as \n+       integer(C_INT) :: aa(10,5:8)\n+     but was passed via other functions that variously describe it as\n+     having size (10,*), (10,1:*), or (10,5:*).  But, the spec says:\n+\n+       For a C descriptor of a nonallocatable nonpointer object, the\n+       value of the lower_bound member of each element of the dim member\n+       of the descriptor is zero.\n+\n+       In a C descriptor of an assumed-size array, the extent member of\n+       the last element of the dim member has the value \u22121.  */\n+\n+  if (!a->base_addr)\n+    abort ();\n+  if (a->elem_len != sizeof(int))\n+    abort ();\n+  if (a->rank != 2)\n+    abort ();\n+  if (a->type != CFI_type_int)\n+    abort ();\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+  if (a->dim[0].lower_bound != 0)\n+    abort ();\n+  if (a->dim[0].extent != 10)\n+    abort ();\n+  if (a->dim[0].sm != sizeof(int))\n+    abort ();\n+  if (a->dim[1].lower_bound != 0)\n+    abort ();\n+  if (a->dim[1].extent != -1)\n+    abort ();\n+  if (a->dim[1].sm != a->dim[0].extent * sizeof(int))\n+    abort ();\n+}\n+\n+"}, {"sha": "8c544d18402a2629503ea4b397489a03415830a4", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-6.f90", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-6.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,50 @@\n+! Reported as pr94070.\n+! { dg-do run { xfail *-*-* } }\n+! { dg-additional-sources \"fc-descriptor-6-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program checks that an assumed-size array argument can be passed\n+! to a C function via a descriptor, and that the argument descriptor\n+! received by C correctly identifies it as assumed-size.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  ! Assumed-size arrays are not passed by descriptor.  What we'll do\n+  ! for this test function is bind an assumed-rank dummy\n+  ! to the assumed-size array.  This is supposed to fill in the descriptor\n+  ! with information about the array present at the call site.\n+  interface\n+    subroutine ctest (a) bind (c)\n+      use iso_c_binding\n+      integer(C_INT) :: a(..)\n+    end subroutine\n+  end interface\n+\n+  integer(C_INT), target :: aa(10,5:8)\n+\n+  ! To get an assumed-size array descriptor, we have to first pass the\n+  ! fixed-size array to a Fortran function with an assumed-size dummy,\n+  call ftest1 (aa)\n+  call ftest2 (aa)\n+  call ftest3 (aa)\n+\n+contains\n+  subroutine ftest1 (a)\n+    use iso_c_binding\n+    integer(C_INT) :: a(10,*)\n+    call ctest (a)\n+  end subroutine\n+  subroutine ftest2 (a)\n+    use iso_c_binding\n+    integer(C_INT) :: a(10,5:*)\n+    call ctest (a)\n+  end subroutine\n+  subroutine ftest3 (a)\n+    use iso_c_binding\n+    integer(C_INT) :: a(10,1:*)\n+    call ctest (a)\n+  end subroutine\n+\n+end program"}, {"sha": "81d826f276fad8da5f1afa43dfb42662678c3059", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-7-c.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-7-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-7-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-7-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,46 @@\n+#include <stdlib.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *a);\n+\n+void\n+ctest (CFI_cdesc_t *a)\n+{\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+\n+  /* We expect to get an array of shape (5,10) that may not be\n+     contiguous.  */\n+  if (!a->base_addr)\n+    abort ();\n+  if (a->elem_len != sizeof(int))\n+    abort ();\n+  if (a->rank != 2)\n+    abort ();\n+  if (a->type != CFI_type_int)\n+    abort ();\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+  if (a->dim[0].lower_bound != 0)\n+    abort ();\n+  if (a->dim[0].extent != 5)\n+    abort ();\n+  if (a->dim[1].lower_bound != 0)\n+    abort ();\n+  if (a->dim[1].extent != 10)\n+    abort ();\n+\n+  /* There shall be an ordering of the dimensions such that the absolute\n+     value of the sm member of the first dimension is not less than the \n+     elem_len member of the C descriptor and the absolute value of the sm \n+     member of each subsequent dimension is not less than the absolute \n+     value of the sm member of the previous dimension multiplied\n+     by the extent of the previous dimension.  */\n+  if (abs (a->dim[0].sm) < a->elem_len)\n+    abort ();\n+  if (abs (a->dim[1].sm) < abs (a->dim[0].sm) * a->dim[0].extent)\n+    abort ();\n+}"}, {"sha": "5be72e7e01cf3849f4ee9eb338e10f21c259c401", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-7.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-7.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,37 @@\n+! PR 101309\n+! { dg-do run { xfail *-*-* } }\n+! { dg-additional-sources \"fc-descriptor-7-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program tests passing arrays that may not be contiguous through\n+! descriptors to C functions as assumed-shape arguments.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+    subroutine ctest (a) bind (c)\n+      use iso_c_binding\n+      integer(C_INT), intent (in) :: a(:,:)\n+    end subroutine\n+  end interface\n+\n+  integer(C_INT), target :: aa(10,5)\n+  integer(C_INT), target :: bb(10,10)\n+\n+  ! Test both calling the C function directly, and via another function\n+  ! that takes an assumed-shape argument.\n+  call ctest (transpose (aa))\n+  call ftest (transpose (aa))\n+  call ctest (bb(2:10:2, :))\n+  call ftest (bb(2:10:2, :))\n+\n+contains\n+  subroutine ftest (a)\n+    use iso_c_binding\n+    integer(C_INT), intent(in) :: a(:,:)\n+    call ctest (a)\n+  end subroutine\n+\n+end program"}, {"sha": "8adf8e31036570fa8fda3808a08d994bcd488048", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-8-c.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-8-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-8-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-8-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,20 @@\n+/* TS29113 8.3.1: ISO_Fortran_binding.h may be included more than once.  */\n+\n+#include <stdlib.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+#include <ISO_Fortran_binding.h>\n+\n+extern void ctest (CFI_cdesc_t *a);\n+\n+void\n+ctest (CFI_cdesc_t *a)\n+{\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+\n+  if (a->version != CFI_VERSION)\n+    abort ();\n+}"}, {"sha": "42345ad945c44cff16a41ccd82c59b0e192f58c6", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-8.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-8.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do run }\n+! { dg-additional-sources \"fc-descriptor-8-c.c dump-descriptors.c\" }\n+!\n+! Check that C descriptors have the version field set correctly.\n+! This program is just a stub to create a descriptor and pass it to the\n+! C function, which does the actual test.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+    subroutine ctest (a) bind (c)\n+      use iso_c_binding\n+      integer(C_INT) :: a(:,:)\n+    end subroutine\n+  end interface\n+\n+  integer(C_INT) :: aa(10,-1:3)\n+  call ctest (aa)\n+\n+end program"}, {"sha": "05e6581eeb8d624d8a37c3882781318fc4e88a21", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-9-c.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-9-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-9-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-9-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,42 @@\n+/* 8.3.1: ISO_Fortran_binding.h may be included more than once.  */\n+\n+#include <stdlib.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *a);\n+\n+struct descriptor_fixed_part {\n+  void *base_addr;\n+  size_t elem_len;\n+  int version;\n+};\n+\n+void\n+ctest (CFI_cdesc_t *a)\n+{\n+  struct descriptor_fixed_part *f = (struct descriptor_fixed_part *) a;\n+\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+\n+  /* The first three members of the structure shall be base_addr,\n+     elem_len, and version in that order.  */\n+  if (&(a->base_addr) != &(f->base_addr))\n+    abort ();\n+  if (&(a->elem_len) != &(f->elem_len))\n+    abort ();\n+  if (&(a->version) != &(f->version))\n+    abort ();\n+\n+  /* The final member shall be dim, with the other members after version\n+     and before dim in any order.  */\n+  if ((void *)&(a->rank) >= (void *)a->dim)\n+    abort ();\n+  if ((void *)&(a->type) >= (void *)a->dim)\n+    abort ();\n+  if ((void *)&(a->attribute) >= (void *)a->dim)\n+    abort ();\n+}"}, {"sha": "e54f677ec7571e5ef9409e0f676371e56970ed0a", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-9.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-9.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do run }\n+! { dg-additional-sources \"fc-descriptor-9-c.c dump-descriptors.c\" }\n+!\n+! Check that C descriptors follow the layout restrictions described in\n+! section 8.3.3 of TS29113.\n+! This program is just a stub to create a descriptor and pass it to the\n+! C function, which does the actual test.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+    subroutine ctest (a) bind (c)\n+      use iso_c_binding\n+      integer(C_INT) :: a(:,:)\n+    end subroutine\n+  end interface\n+\n+  integer(C_INT) :: aa(10,-1:3)\n+  call ctest (aa)\n+\n+end program"}, {"sha": "18b37e193cb2cdd6cb51a450c757f3bbd581130b", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-out-descriptor-1-c.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-1-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-1-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-1-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,52 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (int imax, int jmax, CFI_cdesc_t *a);\n+\n+struct m {\n+  int i;\n+  int j;\n+};\n+\n+void\n+ctest (int imax, int jmax, CFI_cdesc_t *a)\n+{\n+  \n+  int i, j;\n+  CFI_index_t subscripts[2];\n+  struct m* mp;\n+\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+\n+  if (a->rank != 2)\n+    abort ();\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+  if (a->dim[0].lower_bound != 0)\n+    abort ();\n+  if (a->dim[0].extent != imax)\n+    abort ();\n+  if (a->dim[1].lower_bound != 0)\n+    abort ();\n+  if (a->dim[1].extent != jmax)\n+    abort ();\n+\n+  /* Fill in the contents of a.  a is zero-based but we want the ->i and ->j\n+     members of each element to be numbered starting from 1.  */\n+  for (j = 0; j < jmax; j++)\n+    {\n+      subscripts[1] = j;\n+      for (i = 0; i < imax; i++)\n+\t{\n+\t  subscripts[0] = i;\n+\t  mp = (struct m *) CFI_address (a, subscripts);\n+\t  mp->i = i + 1;\n+\t  mp->j = j + 1;\n+\t}\n+    }\n+}"}, {"sha": "d0c30b5591da1171276729ce38e0471beaede682", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-out-descriptor-1.f90", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-1.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,66 @@\n+! { dg-do run }\n+! { dg-additional-sources \"fc-out-descriptor-1-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program checks that passing a fixed-size array as an intent(out)\n+! assumed-shape argument to a C function called from Fortran works.  \n+\n+module mm\n+  use iso_c_binding\n+  type, bind (c) :: m\n+    integer(C_INT) :: i, j\n+  end type\n+\n+  integer, parameter :: imax=10, jmax=5\n+end module\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  interface\n+    subroutine ctest (ii, jj, a) bind (c)\n+      use iso_c_binding\n+      use mm\n+      integer(C_INT), value :: ii, jj\n+      type(m), intent(out) :: a(:,:)\n+    end subroutine\n+  end interface\n+\n+  type(m) :: aa(imax,jmax)\n+  integer :: i, j\n+\n+  ! initialize the array to all zeros; ctest will overwrite it.\n+  do j = 1, jmax\n+    do i = 1, imax\n+      aa(i,j)%i = 0\n+      aa(i,j)%j = 0\n+    end do\n+  end do    \n+\n+  call ctest (imax, jmax, aa)\n+  call verify (aa)\n+\n+contains\n+subroutine verify (a)\n+  use iso_c_binding\n+  use mm\n+  type(m) :: a(:,:)\n+  integer :: i, j\n+\n+  if (rank (a) .ne. 2) stop 100\n+  if (lbound (a, 1) .ne. 1) stop 101\n+  if (lbound (a, 2) .ne. 1) stop 102\n+  if (ubound (a, 1) .ne. imax) stop 103\n+  if (ubound (a, 2) .ne. jmax) stop 104\n+\n+  do j = 1, jmax\n+    do i = 1, imax\n+      if (a(i,j)%i .ne. i) stop 201\n+      if (a(i,j)%j .ne. j) stop 202\n+    end do\n+  end do\n+end subroutine\n+\n+end program"}, {"sha": "18b37e193cb2cdd6cb51a450c757f3bbd581130b", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-out-descriptor-2-c.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-2-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-2-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-2-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,52 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (int imax, int jmax, CFI_cdesc_t *a);\n+\n+struct m {\n+  int i;\n+  int j;\n+};\n+\n+void\n+ctest (int imax, int jmax, CFI_cdesc_t *a)\n+{\n+  \n+  int i, j;\n+  CFI_index_t subscripts[2];\n+  struct m* mp;\n+\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+\n+  if (a->rank != 2)\n+    abort ();\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+  if (a->dim[0].lower_bound != 0)\n+    abort ();\n+  if (a->dim[0].extent != imax)\n+    abort ();\n+  if (a->dim[1].lower_bound != 0)\n+    abort ();\n+  if (a->dim[1].extent != jmax)\n+    abort ();\n+\n+  /* Fill in the contents of a.  a is zero-based but we want the ->i and ->j\n+     members of each element to be numbered starting from 1.  */\n+  for (j = 0; j < jmax; j++)\n+    {\n+      subscripts[1] = j;\n+      for (i = 0; i < imax; i++)\n+\t{\n+\t  subscripts[0] = i;\n+\t  mp = (struct m *) CFI_address (a, subscripts);\n+\t  mp->i = i + 1;\n+\t  mp->j = j + 1;\n+\t}\n+    }\n+}"}, {"sha": "87cfb6ecbd89da4a728ceccc2df025c9383ec84d", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-out-descriptor-2.f90", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-2.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,66 @@\n+! { dg-do run }\n+! { dg-additional-sources \"fc-out-descriptor-2-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program checks that passing a fixed-size array as an intent(out)\n+! assumed-rank argument to a C function called from Fortran works.  \n+\n+module mm\n+  use iso_c_binding\n+  type, bind (c) :: m\n+    integer(C_INT) :: i, j\n+  end type\n+\n+  integer, parameter :: imax=10, jmax=5\n+end module\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  interface\n+    subroutine ctest (ii, jj, a) bind (c)\n+      use iso_c_binding\n+      use mm\n+      integer(C_INT), value :: ii, jj\n+      type(m), intent(out) :: a(..)\n+    end subroutine\n+  end interface\n+\n+  type(m) :: aa(imax,jmax)\n+  integer :: i, j\n+\n+  ! initialize the array to all zeros; ctest will overwrite it.\n+  do j = 1, jmax\n+    do i = 1, imax\n+      aa(i,j)%i = 0\n+      aa(i,j)%j = 0\n+    end do\n+  end do    \n+\n+  call ctest (imax, jmax, aa)\n+  call verify (aa)\n+\n+contains\n+subroutine verify (a)\n+  use iso_c_binding\n+  use mm\n+  type(m) :: a(:,:)\n+  integer :: i, j\n+\n+  if (rank (a) .ne. 2) stop 100\n+  if (lbound (a, 1) .ne. 1) stop 101\n+  if (lbound (a, 2) .ne. 1) stop 102\n+  if (ubound (a, 1) .ne. imax) stop 103\n+  if (ubound (a, 2) .ne. jmax) stop 104\n+\n+  do j = 1, jmax\n+    do i = 1, imax\n+      if (a(i,j)%i .ne. i) stop 201\n+      if (a(i,j)%j .ne. j) stop 202\n+    end do\n+  end do\n+end subroutine\n+\n+end program"}, {"sha": "7de226e107ca2de5dba0270399d61edf71be2fca", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-out-descriptor-3-c.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-3-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-3-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-3-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,71 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest1 (int iinit, int jinit, CFI_cdesc_t *p);\n+extern void ctest2 (int iinit, int jinit, CFI_cdesc_t *a);\n+\n+struct m {\n+  int i;\n+  int j;\n+};\n+\n+void\n+ctest1 (int iinit, int jinit, CFI_cdesc_t *p)\n+{\n+  struct m *mp;\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (p);\n+\n+  if (p->rank != 0)\n+    abort ();\n+  if (p->attribute != CFI_attribute_pointer)\n+    abort ();\n+  if (p->type != CFI_type_struct)\n+    abort ();\n+\n+  check_CFI_status (\"CFI_allocate\",\n+\t\t    CFI_allocate (p, NULL, NULL, sizeof (struct m)));\n+\n+  if (p->base_addr == NULL)\n+    abort ();\n+\n+  mp = (struct m *) CFI_address (p, NULL);\n+  mp->i = iinit;\n+  mp->j = jinit;\n+}\n+\n+\n+void\n+ctest2 (int iinit, int jinit, CFI_cdesc_t *a)\n+{\n+  struct m *mp;\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+\n+  if (a->rank != 0)\n+    abort ();\n+  if (a->attribute != CFI_attribute_allocatable)\n+    abort ();\n+  if (a->type != CFI_type_struct)\n+    abort ();\n+\n+  /* The intent(out) allocatable array is supposed to be deallocated\n+     automatically on entry, if it was previously allocated.  */\n+  if (a->base_addr)\n+    abort ();  \n+\n+  check_CFI_status (\"CFI_allocate\",\n+\t\t    CFI_allocate (a, NULL, NULL, sizeof (struct m)));\n+\n+  if (a->base_addr == NULL)\n+    abort ();\n+\n+  mp = (struct m *) CFI_address (a, NULL);\n+  mp->i = iinit;\n+  mp->j = jinit;\n+}"}, {"sha": "c555ada7996daaa3f6170aa8892d035c663d09db", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-out-descriptor-3.f90", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-3.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,59 @@\n+! PR 101308\n+! { dg-do run { xfail *-*-* } }\n+! { dg-additional-sources \"fc-out-descriptor-3-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program checks that passing an allocatable or pointer scalar\n+! as an intent(out) argument to a C function called from Fortran works.  \n+\n+module mm\n+  use iso_c_binding\n+  type, bind (c) :: m\n+    integer(C_INT) :: i, j\n+  end type\n+\n+  integer(C_INT), parameter :: iinit = 42, jinit = 12345\n+\n+end module\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  interface\n+    subroutine ctest1 (ii, jj, p) bind (c)\n+      use iso_c_binding\n+      use mm\n+      integer(C_INT), value :: ii, jj\n+      type(m), intent(out), pointer :: p\n+    end subroutine\n+    subroutine ctest2 (ii, jj, a) bind (c)\n+      use iso_c_binding\n+      use mm\n+      integer(C_INT), value :: ii, jj\n+      type(m), intent(out), allocatable :: a\n+    end subroutine\n+  end interface\n+\n+  type(m), pointer :: p\n+  type(m), allocatable :: a\n+\n+  ! The association status of the intent(out) pointer argument is supposed\n+  ! to become undefined on entry to the called procedure.  \n+  p => NULL ()\n+  call ctest1 (iinit, jinit, p)\n+  if (.not. associated (p)) stop 101\n+  if (p%i .ne. iinit) stop 102\n+  if (p%j .ne. jinit) stop 103\n+\n+  ! The intent(out) argument is supposed to be deallocated automatically\n+  ! on entry to the called function.\n+  allocate (a)\n+  a%i = 0\n+  a%j = 0\n+  call ctest2 (iinit, jinit, a)\n+  if (.not. allocated (a)) stop 201\n+  if (a%i .ne. iinit) stop 202\n+  if (a%j .ne. jinit) stop 203\n+end program"}, {"sha": "6e1324b56d19ac8354abd99703048183c4488765", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-out-descriptor-4-c.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-4-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-4-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-4-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,96 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest1 (int imin, int imax, int jmin, int jmax, CFI_cdesc_t *p);\n+extern void ctest2 (int imin, int imax, int jmin, int jmax, CFI_cdesc_t *a);\n+\n+struct m {\n+  int i;\n+  int j;\n+};\n+\n+void\n+ctest1 (int imin, int imax, int jmin, int jmax, CFI_cdesc_t *p)\n+{\n+  struct m *mp;\n+  int i, j;\n+  CFI_index_t lb[2], ub[2], s[2];\n+\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (p);\n+\n+  if (p->rank != 2)\n+    abort ();\n+  if (p->attribute != CFI_attribute_pointer)\n+    abort ();\n+  if (p->type != CFI_type_struct)\n+    abort ();\n+\n+  lb[0] = imin;\n+  lb[1] = jmin;\n+  ub[0] = imax;\n+  ub[1] = jmax;\n+  check_CFI_status (\"CFI_allocate\",\n+\t\t    CFI_allocate (p, lb, ub, sizeof (struct m)));\n+\n+  if (p->base_addr == NULL)\n+    abort ();\n+\n+  for (j = jmin; j <= jmax; j++)\n+    for (i = imin; i <= imax; i++)\n+      {\n+\ts[0] = i;\n+\ts[1] = j;\n+\tmp = (struct m *) CFI_address (p, s);\n+\tmp->i = i;\n+\tmp->j = j;\n+      }\n+}\n+\n+void\n+ctest2 (int imin, int imax, int jmin, int jmax, CFI_cdesc_t *a)\n+{\n+  struct m *mp;\n+  int i, j;\n+  CFI_index_t lb[2], ub[2], s[2];\n+\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+\n+  if (a->rank != 2)\n+    abort ();\n+  if (a->attribute != CFI_attribute_allocatable)\n+    abort ();\n+  if (a->type != CFI_type_struct)\n+    abort ();\n+\n+  /* Intent(out) argument is supposed to be deallocated automatically\n+     on entry.  */\n+  if (a->base_addr)\n+    abort ();\n+\n+  lb[0] = imin;\n+  lb[1] = jmin;\n+  ub[0] = imax;\n+  ub[1] = jmax;\n+  check_CFI_status (\"CFI_allocate\",\n+\t\t    CFI_allocate (a, lb, ub, sizeof (struct m)));\n+\n+  if (a->base_addr == NULL)\n+    abort ();\n+\n+  for (j = jmin; j <= jmax; j++)\n+    for (i = imin; i <= imax; i++)\n+      {\n+\ts[0] = i;\n+\ts[1] = j;\n+\tmp = (struct m *) CFI_address (a, s);\n+\tmp->i = i;\n+\tmp->j = j;\n+      }\n+}"}, {"sha": "b4f6654c2e18482eea096126c3af2b6b577ddda9", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-out-descriptor-4.f90", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-4.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,75 @@\n+! PR 92621 (?)\n+! { dg-do run { xfail *-*-* } }\n+! { dg-additional-sources \"fc-out-descriptor-4-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program checks that passing an allocatable or pointer array\n+! as an intent(out) argument to a C function called from Fortran works.  \n+\n+module mm\n+  use iso_c_binding\n+  type, bind (c) :: m\n+    integer(C_INT) :: i, j\n+  end type\n+\n+  integer(C_INT), parameter :: imin = 5, imax = 10, jmin = -10, jmax = -1\n+\n+end module\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  interface\n+    subroutine ctest1 (i0, ii, j0, jj, p) bind (c)\n+      use iso_c_binding\n+      use mm\n+      integer(C_INT), value :: i0, ii, j0, jj\n+      type(m), intent(out), pointer :: p(:,:)\n+    end subroutine\n+    subroutine ctest2 (i0, ii, j0, jj, a) bind (c)\n+      use iso_c_binding\n+      use mm\n+      integer(C_INT), value :: i0, ii, j0, jj\n+      type(m), intent(out), allocatable :: a(:,:)\n+    end subroutine\n+  end interface\n+\n+  type(m), pointer :: p(:,:)\n+  type(m), allocatable :: a(:,:)\n+  integer :: i, j\n+\n+  p => NULL ()\n+  call ctest1 (imin, imax, jmin, jmax, p)\n+  if (.not. associated (p)) stop 101\n+  if (rank(p) .ne. 2) stop 102\n+  if (lbound (p, 1) .ne. imin) stop 103\n+  if (ubound (p, 1) .ne. imax) stop 104\n+  if (lbound (p, 2) .ne. jmin) stop 105\n+  if (ubound (p, 2) .ne. jmax) stop 106\n+  do j = jmin, jmax\n+    do i = imin, imax\n+      if (p(i,j)%i .ne. i) stop 107\n+      if (p(i,j)%j .ne. j) stop 108\n+    end do\n+  end do\n+\n+  ! The intent(out) argument is supposed to be deallocated automatically\n+  ! on entry to the called function.\n+  allocate (a (jmin:jmax,imin:imax))\n+  if (.not. allocated (a)) stop 201\n+  call ctest2 (imin, imax, jmin, jmax, a)\n+  if (.not. allocated (a)) stop 201\n+  if (rank(a) .ne. 2) stop 202\n+  if (lbound (a, 1) .ne. imin) stop 203\n+  if (ubound (a, 1) .ne. imax) stop 204\n+  if (lbound (a, 2) .ne. jmin) stop 205\n+  if (ubound (a, 2) .ne. jmax) stop 206\n+  do j = jmin, jmax\n+    do i = imin, imax\n+      if (a(i,j)%i .ne. i) stop 207\n+      if (a(i,j)%j .ne. j) stop 208\n+    end do\n+  end do\n+end program"}, {"sha": "337bc22d1f91abe1eaa8e7e7b394e7a44b532c56", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-out-descriptor-5-c.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-5-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-5-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-5-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,30 @@\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *a);\n+\n+void\n+ctest (CFI_cdesc_t *a)\n+{\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+\n+  /* The character object passed as the argument was declared on the\n+     Fortran side as character(len=26) :: aa\n+     Make sure that matches what's in the descriptor.  */\n+  if (!a->base_addr)\n+    abort ();\n+  if (a->elem_len != 26)\n+    abort ();\n+  if (a->rank != 0)\n+    abort ();\n+  if (a->type != CFI_type_char)\n+    abort ();\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+  strncpy ((char *)a->base_addr, \"0123456789\", 10);\n+}"}, {"sha": "836683bd97197c795ad8c04d787132705016b96e", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-out-descriptor-5.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-5.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,35 @@\n+! PR92482\n+! { dg-do run }\n+! { dg-additional-sources \"fc-out-descriptor-5-c.c dump-descriptors.c\" }\n+!\n+! This program checks that you can call a C function declared with an\n+! assumed-length character dummy from Fortran.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+    subroutine ctest (a) bind (c)  ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+      use iso_c_binding\n+      character(len=*,kind=C_CHAR), intent(out) :: a\n+    end subroutine\n+  end interface\n+\n+  character(len=26,kind=C_CHAR) :: aa\n+  aa = 'abcdefghijklmnopqrstuvwxyz'\n+\n+  ! Test both passing the fixed-length-string directly to the function\n+  ! with a C interface, and indirectly via a Fortran function with an\n+  ! assumed-length dummy argument.\n+  call ctest (aa)\n+  call ftest (aa)\n+\n+contains\n+  subroutine ftest (a) bind (c) ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+    use iso_c_binding\n+    character(len=*,kind=C_CHAR), intent(out) :: a\n+    call ctest (a)\n+  end subroutine\n+\n+end program"}, {"sha": "2711a98aa0ad2362402beea1214a189038730cfc", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-out-descriptor-6-c.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-6-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-6-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-6-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,50 @@\n+#include <stdlib.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *a);\n+\n+void\n+ctest (CFI_cdesc_t *a)\n+{\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  dump_CFI_cdesc_t (a);\n+\n+  /* The actual argument on the Fortran side was declared as \n+       integer(C_INT) :: aa(10,5:8)\n+     but was passed via other functions that variously describe it as\n+     having size (10,*), (10,1:*), or (10,5:*) before calling this function\n+     with an assumed-rank array dummy.  But, the spec says:\n+\n+       For a C descriptor of a nonallocatable nonpointer object, the\n+       value of the lower_bound member of each element of the dim member\n+       of the descriptor is zero.\n+\n+       In a C descriptor of an assumed-size array, the extent member of\n+       the last element of the dim member has the value \u22121.  */\n+\n+  if (!a->base_addr)\n+    abort ();\n+  if (a->elem_len != sizeof(int))\n+    abort ();\n+  if (a->rank != 2)\n+    abort ();\n+  if (a->type != CFI_type_int)\n+    abort ();\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+  if (a->dim[0].lower_bound != 0)\n+    abort ();\n+  if (a->dim[0].extent != 10)\n+    abort ();\n+  if (a->dim[0].sm != sizeof(int))\n+    abort ();\n+  if (a->dim[1].lower_bound != 0)\n+    abort ();\n+  if (a->dim[1].extent != -1)\n+    abort ();\n+  if (a->dim[1].sm != a->dim[0].extent * sizeof(int))\n+    abort ();\n+}"}, {"sha": "d0c3904e27edbb71774725ea81ed3bd6886393d7", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-out-descriptor-6.f90", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-6.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,49 @@\n+! Reported as pr94070.\n+! { dg-do run { xfail *-*-* } }\n+! { dg-additional-sources \"fc-out-descriptor-6-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program checks passing an assumed-size array argument via descriptor\n+! from Fortran to C.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  ! Assumed-size arrays are not passed by descriptor.  What we'll do\n+  ! for this test function is bind an assumed-rank dummy to an\n+  ! assumed-size array.  This is supposed to fill in the descriptor\n+  ! with information about the array present at the call site.\n+  interface\n+    subroutine ctest (a) bind (c)\n+      use iso_c_binding\n+      integer(C_INT), intent(out) :: a(..)\n+    end subroutine\n+  end interface\n+\n+  integer(C_INT), target :: aa(10,5:8)\n+\n+  ! To get an assumed-size array descriptor, we have to first pass the\n+  ! fixed-size array to a Fortran function with an assumed-size dummy.\n+  call ftest1 (aa)\n+  call ftest2 (aa)\n+  call ftest3 (aa)\n+\n+contains\n+  subroutine ftest1 (a)\n+    use iso_c_binding\n+    integer(C_INT) :: a(10,*)\n+    call ctest (a)\n+  end subroutine\n+  subroutine ftest2 (a)\n+    use iso_c_binding\n+    integer(C_INT) :: a(10,5:*)\n+    call ctest (a)\n+  end subroutine\n+  subroutine ftest3 (a)\n+    use iso_c_binding\n+    integer(C_INT) :: a(10,1:*)\n+    call ctest (a)\n+  end subroutine\n+\n+end program"}, {"sha": "be9fc928bed838199a78906eb5fc929ceaa8396e", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-out-descriptor-7-c.c", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-7-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-7-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-7-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,136 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+struct m {\n+  int i;\n+  int j;\n+};\n+\n+extern void ctest (CFI_cdesc_t *a, int lb1, int ub1, int s1,\n+\t\t   int lb2, int ub2, int s2, CFI_cdesc_t *b);\n+\n+/* Check array b against the section of array a defined by the given\n+   bounds.  */\n+static void\n+check_array (CFI_cdesc_t *a, CFI_cdesc_t *b,\n+             int lb1, int ub1, int s1, int lb2, int ub2, int s2)\n+{\n+  int bad = 0;\n+  int i, ii, j, jj;\n+  CFI_index_t sub[2];\n+  struct m *ap, *bp;\n+\n+  for (j = lb2, jj = b->dim[1].lower_bound; j <= ub2; jj++, j += s2)\n+    for (i = lb1, ii = b->dim[0].lower_bound; i <= ub1; ii++, i += s1)\n+      {\n+\tsub[0] = i;\n+\tsub[1] = j;\n+\tap = (struct m *) CFI_address (a, sub);\n+\tsub[0] = ii;\n+\tsub[1] = jj;\n+\tbp = (struct m *) CFI_address (b, sub);\n+#if 0\n+\tfprintf (stderr, \"b(%d,%d) = (%d,%d) expecting (%d,%d)\\n\",\n+\t\t ii, jj, bp->i, bp->j, ap->i, ap->j);\n+#endif\n+\tif (ap->i != bp->i || ap->j != bp->j)\n+\t  bad = 1;\n+      }\n+  if (bad)\n+    abort ();\n+}\n+\n+void\n+ctest (CFI_cdesc_t *a, int lb1, int ub1, int s1,\n+       int lb2, int ub2, int s2, CFI_cdesc_t *b)\n+{\n+  CFI_index_t lb[2], ub[2], s[2];\n+  CFI_index_t i, j;\n+\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  fprintf (stderr, \"input arrays\\n\");\n+  dump_CFI_cdesc_t (a);\n+  dump_CFI_cdesc_t (b);\n+\n+  /* We expect to get a zero-based input array of shape (10,5).  */\n+  if (a->rank != 2)\n+    abort ();\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+  if (a->type != CFI_type_struct)\n+    abort ();\n+  if (a->dim[0].lower_bound != 0)\n+    abort ();\n+  if (a->dim[0].extent != 10)\n+    abort ();\n+  if (a->dim[1].lower_bound != 0)\n+    abort ();\n+  if (a->dim[1].extent != 5)\n+    abort ();\n+\n+  /* The output descriptor has to agree with the input descriptor.  */\n+  if (b->rank != 2)\n+    abort ();\n+  if (b->attribute != CFI_attribute_pointer)\n+    abort ();\n+  if (b->type != CFI_type_struct)\n+    abort ();\n+  if (b->elem_len != a->elem_len)\n+    abort ();\n+\n+  /* Point b at a, keeping the 0-based bounds.  */\n+  check_CFI_status (\"CFI_setpointer\",\n+\t\t    CFI_setpointer (b, a, NULL));\n+  fprintf (stderr, \"After initializing b\\n\");\n+  dump_CFI_cdesc_t (b);\n+  if (b->dim[0].lower_bound != 0)\n+    abort ();\n+  if (b->dim[1].lower_bound != 0)\n+    abort ();\n+  check_array (a, b,\n+               a->dim[0].lower_bound,\n+               a->dim[0].lower_bound + a->dim[0].extent - 1,\n+               1,\n+               a->dim[1].lower_bound,\n+               a->dim[1].lower_bound + a->dim[1].extent - 1,\n+               1);\n+\n+  /* Take a section of the array.  The bounds passed in to this function\n+     assume the array is 1-based in both dimensions, so subtract 1.  */\n+  lb[0] = b->dim[0].lower_bound + lb1 - 1;\n+  lb[1] = b->dim[1].lower_bound + lb2 - 1;\n+  ub[0] = b->dim[0].lower_bound + ub1 - 1;\n+  ub[1] = b->dim[1].lower_bound + ub2 - 1;\n+  s[0] = s1;\n+  s[1] = s2;\n+  check_CFI_status (\"CFI_section\",\n+\t\t    CFI_section (b, b, lb, ub, s));\n+  fprintf (stderr, \"After CFI_section\\n\");\n+  dump_CFI_cdesc_t (b);\n+  check_array (a, b,\n+               a->dim[0].lower_bound + lb1 - 1,\n+               a->dim[0].lower_bound + ub1 - 1,\n+               s1,\n+               a->dim[1].lower_bound + lb2 - 1,\n+               a->dim[1].lower_bound + ub2 - 1,\n+               s2);\n+\n+  /* Adjust b to be 1-based.  */\n+  lb[0] = 1;\n+  lb[1] = 1;\n+  fprintf (stderr, \"After rebasing b again\\n\");\n+  check_CFI_status (\"CFI_setpointer\",\n+\t\t    CFI_setpointer (b, b, lb));\n+  dump_CFI_cdesc_t (b);\n+  check_array (a, b,\n+               a->dim[0].lower_bound + lb1 - 1,\n+               a->dim[0].lower_bound + ub1 - 1,\n+               s1,\n+               a->dim[1].lower_bound + lb2 - 1,\n+               a->dim[1].lower_bound + ub2 - 1,\n+               s2);\n+}"}, {"sha": "209f96f51eac37d9460ab768702d79d6a76d19b3", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-out-descriptor-7.f90", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-out-descriptor-7.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,71 @@\n+! PR 101310\n+! { dg-do run }\n+! { dg-additional-sources \"fc-out-descriptor-7-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program checks that returning a noncontiguous array as an intent(out)\n+! argument to a C function called from Fortran works.  \n+\n+module mm\n+  use iso_c_binding\n+  type, bind (c) :: m\n+    integer(C_INT) :: i, j\n+  end type\n+\n+  integer(C_INT), parameter :: imax = 10, jmax=5\n+\n+end module\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  interface\n+    ! ctest points b at a section of array a defined by the\n+    ! indicated bounds and steps.  The returned array is 1-based.\n+    subroutine ctest (a, lb1, ub1, s1, lb2, ub2, s2, b) bind (c)\n+      use iso_c_binding\n+      use mm\n+      type(m), target :: a(:,:)\n+      integer(C_INT), value :: lb1, ub1, s1, lb2, ub2, s2\n+      type(m), intent(out), pointer :: b(:,:)\n+    end subroutine\n+  end interface\n+\n+  type(m), target :: a(imax, jmax)\n+  type(m), pointer :: b(:,:)\n+  integer :: i, j, ii, jj\n+\n+  do j = 1, jmax\n+    do i = 1, imax\n+      a(i,j)%i = i\n+      a(i,j)%j = j\n+    end do\n+  end do\n+\n+  b => NULL ()\n+  ! resulting array is 1-based and has shape (3,3)\n+  call ctest (a, 2, 8, 3, 1, 5, 2, b)\n+  if (.not. associated (b)) stop 101\n+  if (rank(b) .ne. 2) stop 102\n+  if (lbound (b, 1) .ne. 1) stop 103\n+  if (ubound (b, 1) .ne. 3) stop 104\n+  if (lbound (b, 2) .ne. 1) stop 105\n+  if (ubound (b, 2) .ne. 3) stop 106\n+\n+  ! check that the returned array b contains the expected elements\n+  ! from array a.\n+  jj = lbound (b, 2)\n+  do j = 1, 5, 2\n+    ii = lbound (b, 1)\n+    do i = 2, 8, 3\n+      if (b(ii,jj)%i .ne. i) stop 107\n+      if (b(ii,jj)%j .ne. j) stop 108\n+      ii = ii + 1\n+    end do\n+    jj = jj + 1\n+  end do\n+\n+end program\n+"}, {"sha": "d42900163a2769c60dc560ea56b7181b7fc53df1", "filename": "gcc/testsuite/gfortran.dg/c-interop/ff-descriptor-1.f90", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-1.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,123 @@\n+! { dg-do run }\n+!\n+! This program checks that passing arrays as assumed-shape dummies to\n+! and from Fortran functions with C binding works.\n+\n+module mm\n+  use iso_c_binding\n+  type, bind (c) :: m\n+    integer(C_INT) :: i, j\n+  end type\n+\n+  integer, parameter :: imax=10, jmax=5\n+end module\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  type(m) :: aa(imax,jmax)\n+  integer :: i, j\n+  do j = 1, jmax\n+    do i = 1, imax\n+      aa(i,j)%i = i\n+      aa(i,j)%j = j\n+    end do\n+  end do\n+\n+  call testc (aa)\n+  call testf (aa)\n+\n+contains\n+\n+  ! C binding version\n+\n+  subroutine checkc (a, b) bind (c)\n+    use iso_c_binding\n+    use mm\n+    type(m) :: a(:,:), b(:,:)\n+    integer :: i, j\n+\n+    if (size (a,1) .ne. imax) stop 101\n+    if (size (a,2) .ne. jmax) stop 102\n+    if (size (b,1) .ne. jmax) stop 103\n+    if (size (b,2) .ne. imax) stop 104\n+\n+    do j = 1, jmax\n+      do i = 1, imax\n+        if (a(i,j)%i .ne. i) stop 105\n+        if (a(i,j)%j .ne. j) stop 106\n+        if (b(j,i)%i .ne. i) stop 107\n+        if (b(j,i)%j .ne. j) stop 108\n+      end do\n+    end do\n+  end subroutine\n+\n+  ! Fortran binding version\n+  subroutine checkf (a, b)\n+    use iso_c_binding\n+    use mm\n+    type(m) :: a(:,:), b(:,:)\n+    integer :: i, j\n+\n+    if (size (a,1) .ne. imax) stop 201\n+    if (size (a,2) .ne. jmax) stop 202\n+    if (size (b,1) .ne. jmax) stop 203\n+    if (size (b,2) .ne. imax) stop 204\n+\n+    do j = 1, jmax\n+      do i = 1, imax\n+        if (a(i,j)%i .ne. i) stop 205\n+        if (a(i,j)%j .ne. j) stop 206\n+        if (b(j,i)%i .ne. i) stop 207\n+        if (b(j,i)%j .ne. j) stop 208\n+      end do\n+    end do\n+  end subroutine\n+\n+  ! C binding version\n+  subroutine testc (a) bind (c)\n+    use iso_c_binding\n+    use mm\n+    type(m) :: a(:,:)\n+    type(m) :: b(jmax, imax)\n+    integer :: i, j\n+\n+    if (size (a,1) .ne. imax) stop 301\n+    if (size (a,2) .ne. jmax) stop 302\n+    do j = 1, jmax\n+      do i = 1, imax\n+        b(j,i)%i  = a(i,j)%i\n+        b(j,i)%j  = a(i,j)%j\n+      end do\n+    end do\n+\n+    ! Call both the C and Fortran binding check functions\n+    call checkc (a, b)\n+    call checkf (a, b)\n+  end subroutine\n+\n+  ! Fortran binding version\n+  subroutine testf (a)\n+    use iso_c_binding\n+    use mm\n+    type(m) :: a(:,:)\n+    type(m) :: b(jmax, imax)\n+    integer :: i, j\n+\n+    if (size (a,1) .ne. imax) stop 401\n+    if (size (a,2) .ne. jmax) stop 402\n+    do j = 1, jmax\n+      do i = 1, imax\n+        b(j,i)%i  = a(i,j)%i\n+        b(j,i)%j  = a(i,j)%j\n+      end do\n+    end do\n+\n+    ! Call both the C and Fortran binding check functions\n+    call checkc (a, b)\n+    call checkf (a, b)\n+  end subroutine\n+\n+end program"}, {"sha": "d9b495732ea586d2a98d32464c12227b5c6c35ee", "filename": "gcc/testsuite/gfortran.dg/c-interop/ff-descriptor-2.f90", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-2.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,97 @@\n+! { dg-do run }\n+!\n+! This program checks that passing arrays as assumed-rank dummies to\n+! and from Fortran functions with C binding works.\n+\n+module mm\n+  use iso_c_binding\n+  type, bind (c) :: m\n+    integer(C_INT) :: i, j\n+  end type\n+\n+  integer, parameter :: imax=10, jmax=5\n+end module\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  type(m) :: aa(imax,jmax)\n+  integer :: i, j\n+  do j = 1, jmax\n+    do i = 1, imax\n+      aa(i,j)%i = i\n+      aa(i,j)%j = j\n+    end do\n+  end do\n+\n+  call testc (aa)\n+  call testf (aa)\n+\n+contains\n+\n+  ! C binding version\n+\n+  subroutine checkc (a, b) bind (c)\n+    use iso_c_binding\n+    use mm\n+    type(m) :: a(..), b(..)\n+\n+    if (rank (a) .ne. 2) stop 101\n+    if (rank (b) .ne. 2) stop 102\n+    if (size (a,1) .ne. imax) stop 103\n+    if (size (a,2) .ne. jmax) stop 104\n+    if (size (b,1) .ne. jmax) stop 105\n+    if (size (b,2) .ne. imax) stop 106\n+\n+  end subroutine\n+\n+  ! Fortran binding version\n+  subroutine checkf (a, b)\n+    use iso_c_binding\n+    use mm\n+    type(m) :: a(..), b(..)\n+\n+    if (rank (a) .ne. 2) stop 201\n+    if (rank (b) .ne. 2) stop 202\n+    if (size (a,1) .ne. imax) stop 203\n+    if (size (a,2) .ne. jmax) stop 204\n+    if (size (b,1) .ne. jmax) stop 205\n+    if (size (b,2) .ne. imax) stop 206\n+\n+  end subroutine\n+\n+  ! C binding version\n+  subroutine testc (a) bind (c)\n+    use iso_c_binding\n+    use mm\n+    type(m) :: a(..)\n+    type(m) :: b(jmax, imax)\n+\n+    if (rank (a) .ne. 2) stop 301\n+    if (size (a,1) .ne. imax) stop 302\n+    if (size (a,2) .ne. jmax) stop 303\n+\n+    ! Call both the C and Fortran binding check functions\n+    call checkc (a, b)\n+    call checkf (a, b)\n+  end subroutine\n+\n+  ! Fortran binding version\n+  subroutine testf (a)\n+    use iso_c_binding\n+    use mm\n+    type(m) :: a(..)\n+    type(m) :: b(jmax, imax)\n+\n+    if (rank (a) .ne. 2) stop 401\n+    if (size (a,1) .ne. imax) stop 402\n+    if (size (a,2) .ne. jmax) stop 403\n+\n+    ! Call both the C and Fortran binding check functions\n+    call checkc (a, b)\n+    call checkf (a, b)\n+  end subroutine\n+\n+end program"}, {"sha": "13ec8510d9332d184c679d12d5d2f054200fc3a8", "filename": "gcc/testsuite/gfortran.dg/c-interop/ff-descriptor-3.f90", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-3.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,148 @@\n+! { dg-do run }\n+!\n+! This program checks that passing allocatable and pointer scalars to\n+! and from Fortran functions with C binding works.\n+\n+module mm\n+  use iso_c_binding\n+  type, bind (c) :: m\n+    integer(C_INT) :: i, j\n+  end type\n+\n+  integer, parameter :: imagic=-1, jmagic=42\n+end module\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  type(m), allocatable :: a\n+  type(m), target :: t\n+  type(m), pointer :: p\n+\n+  p => NULL()\n+\n+  call testc (a, t, p)\n+  call testf (a, t, p)\n+\n+contains\n+\n+  ! C binding version\n+\n+  subroutine checkc (a, t, p, initp) bind (c)\n+    use iso_c_binding\n+    use mm\n+    type(m), allocatable :: a\n+    type(m), target :: t\n+    type(m), pointer :: p\n+    logical, value :: initp\n+\n+    if (initp) then\n+      if (.not. allocated (a)) stop 101\n+      if (a%i .ne. imagic) stop 102\n+      if (a%j .ne. jmagic) stop 103\n+      if (.not. associated (p)) stop 104\n+      if (.not. associated (p, t)) stop 105\n+      if (p%i .ne. imagic) stop 106\n+      if (p%j .ne. jmagic) stop 107\n+    else\n+      if (allocated (a)) stop 108\n+      if (associated (p)) stop 109\n+    end if\n+\n+    if (rank (a) .ne. 0) stop 110\n+    if (rank (t) .ne. 0) stop 111\n+    if (rank (p) .ne. 0) stop 112\n+\n+  end subroutine\n+\n+  ! Fortran binding version\n+  subroutine checkf (a, t, p, initp)\n+    use iso_c_binding\n+    use mm\n+    type(m), allocatable :: a\n+    type(m), target :: t\n+    type(m), pointer :: p\n+    logical, value :: initp\n+\n+    if (initp) then\n+      if (.not. allocated (a)) stop 201\n+      if (a%i .ne. imagic) stop 202\n+      if (a%j .ne. jmagic) stop 203\n+      if (.not. associated (p)) stop 204\n+      if (.not. associated (p, t)) stop 205\n+      if (p%i .ne. imagic) stop 206\n+      if (p%j .ne. jmagic) stop 207\n+    else\n+      if (allocated (a)) stop 208\n+      if (associated (p)) stop 209\n+    end if\n+\n+    if (rank (a) .ne. 0) stop 210\n+    if (rank (t) .ne. 0) stop 211\n+    if (rank (p) .ne. 0) stop 212\n+\n+  end subroutine\n+\n+  ! C binding version\n+  subroutine testc (a, t, p) bind (c)\n+    use iso_c_binding\n+    use mm\n+    type(m), allocatable :: a\n+    type(m), target :: t\n+    type(m), pointer :: p\n+\n+    ! Call both the C and Fortran binding check functions\n+    call checkc (a, t, p, .false.)\n+    call checkf (a, t, p, .false.)\n+\n+    ! Allocate/associate and check again.\n+    allocate (a)\n+    a%i = imagic\n+    a%j = jmagic\n+    p => t\n+    t%i = imagic\n+    t%j = jmagic\n+    call checkc (a, t, p, .true.)\n+    call checkf (a, t, p, .true.)\n+\n+    ! Reset and check a third time.\n+    deallocate (a)\n+    p => NULL ()\n+    call checkc (a, t, p, .false.)\n+    call checkf (a, t, p, .false.)\n+\n+  end subroutine\n+\n+  ! Fortran binding version\n+  subroutine testf (a, t, p)\n+    use iso_c_binding\n+    use mm\n+    type(m), allocatable :: a\n+    type(m), target :: t\n+    type(m), pointer :: p\n+\n+    ! Call both the C and Fortran binding check functions\n+    call checkc (a, t, p, .false.)\n+    call checkf (a, t, p, .false.)\n+\n+    ! Allocate/associate and check again.\n+    allocate (a)\n+    a%i = imagic\n+    a%j = jmagic\n+    p => t\n+    t%i = imagic\n+    t%j = jmagic\n+    call checkc (a, t, p, .true.)\n+    call checkf (a, t, p, .true.)\n+\n+    ! Reset and check a third time.\n+    deallocate (a)\n+    p => NULL ()\n+    call checkc (a, t, p, .false.)\n+    call checkf (a, t, p, .false.)\n+\n+  end subroutine\n+\n+end program"}, {"sha": "fd15d0687f1fea1fc8e720e728059edfcc56fe76", "filename": "gcc/testsuite/gfortran.dg/c-interop/ff-descriptor-4.f90", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-4.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,198 @@\n+! { dg-do run }\n+!\n+! This program checks that passing allocatable and pointer arrays to\n+! and from Fortran functions with C binding works.\n+\n+module mm\n+  use iso_c_binding\n+  type, bind (c) :: m\n+    integer(C_INT) :: i, j\n+  end type\n+end module\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  type(m), allocatable :: a(:)\n+  type(m), target :: t(3,10)\n+  type(m), pointer :: p(:,:)\n+\n+  p => NULL()\n+\n+  call testc (a, t, p)\n+  call testf (a, t, p)\n+\n+contains\n+\n+  ! C binding version\n+\n+  subroutine checkc (a, t, p, initp) bind (c)\n+    use iso_c_binding\n+    use mm\n+    type(m), allocatable :: a(:)\n+    type(m), target :: t(3,10)\n+    type(m), pointer :: p(:,:)\n+    logical, value :: initp\n+    integer :: i, j\n+\n+    if (rank (a) .ne. 1) stop 101\n+    if (rank (t) .ne. 2) stop 102\n+    if (rank (p) .ne. 2) stop 103\n+\n+    if (initp) then\n+      if (.not. allocated (a)) stop 104\n+      if (.not. associated (p)) stop 105\n+      if (.not. associated (p, t)) stop 106\n+      if (size (a, 1) .ne. 5) stop 107\n+      if (size (p, 1) .ne. 3) stop 108\n+      if (size (p, 2) .ne. 10) stop 109\n+    else\n+      if (allocated (a)) stop 121\n+      if (associated (p)) stop 122\n+    end if\n+\n+  end subroutine\n+\n+  ! Fortran binding version\n+  subroutine checkf (a, t, p, initp)\n+    use iso_c_binding\n+    use mm\n+    type(m), allocatable :: a(:)\n+    type(m), target :: t(3,10)\n+    type(m), pointer :: p(:,:)\n+    logical, value :: initp\n+    integer :: i, j\n+\n+    if (rank (a) .ne. 1) stop 201\n+    if (rank (t) .ne. 2) stop 202\n+    if (rank (p) .ne. 2) stop 203\n+\n+    if (initp) then\n+      if (.not. allocated (a)) stop 204\n+      if (.not. associated (p)) stop 205\n+      if (.not. associated (p, t)) stop 206\n+      if (size (a, 1) .ne. 5) stop 207\n+      if (size (p, 1) .ne. 3) stop 208\n+      if (size (p, 2) .ne. 10) stop 209\n+    else\n+      if (allocated (a)) stop 221\n+      if (associated (p)) stop 222\n+    end if\n+\n+  end subroutine\n+\n+  ! C binding version\n+  subroutine allocatec (a, t, p) bind (c)\n+    use iso_c_binding\n+    use mm\n+    type(m), allocatable :: a(:)\n+    type(m), target :: t(3,10)\n+    type(m), pointer :: p(:,:)\n+\n+    allocate (a(10:20))\n+    p => t\n+  end subroutine\n+\n+  ! Fortran binding version\n+  subroutine allocatef (a, t, p) bind (c)\n+    use iso_c_binding\n+    use mm\n+    type(m), allocatable :: a(:)\n+    type(m), target :: t(3,10)\n+    type(m), pointer :: p(:,:)\n+\n+    allocate (a(5:15))\n+    p => t\n+  end subroutine\n+\n+  ! C binding version\n+  subroutine testc (a, t, p) bind (c)\n+    use iso_c_binding\n+    use mm\n+    type(m), allocatable :: a(:)\n+    type(m), target :: t(3,10)\n+    type(m), pointer :: p(:,:)\n+\n+    ! Call both the C and Fortran binding check functions\n+    call checkc (a, t, p, .false.)\n+    call checkf (a, t, p, .false.)\n+\n+    ! Allocate/associate and check again.\n+    allocate (a(5))\n+    p => t\n+    call checkc (a, t, p, .true.)\n+    call checkf (a, t, p, .true.)\n+\n+    ! Reset and check a third time.\n+    deallocate (a)\n+    p => NULL ()\n+    call checkc (a, t, p, .false.)\n+    call checkf (a, t, p, .false.)\n+\n+    ! Allocate/associate inside a function with Fortran binding.\n+    call allocatef (a, t, p)\n+    if (.not. allocated (a)) stop 301\n+    if (.not. associated (p)) stop 302\n+    if (lbound (a, 1) .ne. 5) stop 303\n+    if (ubound (a, 1) .ne. 15) stop 304\n+    deallocate (a)\n+    p => NULL ()\n+\n+    ! Allocate/associate inside a function with C binding.\n+    call allocatec (a, t, p)\n+    if (.not. allocated (a)) stop 311\n+    if (.not. associated (p)) stop 312\n+    if (lbound (a, 1) .ne. 10) stop 313\n+    if (ubound (a, 1) .ne. 20) stop 314\n+    deallocate (a)\n+    p => NULL ()\n+\n+  end subroutine\n+\n+  ! Fortran binding version\n+  subroutine testf (a, t, p)\n+    use iso_c_binding\n+    use mm\n+    type(m), allocatable :: a(:)\n+    type(m), target :: t(3,10)\n+    type(m), pointer :: p(:,:)\n+\n+    ! Call both the C and Fortran binding check functions\n+    call checkc (a, t, p, .false.)\n+    call checkf (a, t, p, .false.)\n+\n+    ! Allocate/associate and check again.\n+    allocate (a(5))\n+    p => t\n+    call checkc (a, t, p, .true.)\n+    call checkf (a, t, p, .true.)\n+\n+    ! Reset and check a third time.\n+    deallocate (a)\n+    p => NULL ()\n+    call checkc (a, t, p, .false.)\n+    call checkf (a, t, p, .false.)\n+\n+    ! Allocate/associate inside a function with Fortran binding.\n+    call allocatef (a, t, p)\n+    if (.not. allocated (a))  stop 401\n+    if (.not. associated (p)) stop 402\n+    if (lbound (a, 1) .ne. 5) stop 403\n+    if (ubound (a, 1) .ne. 15) stop 404\n+    deallocate (a)\n+    p => NULL ()\n+\n+    ! Allocate/associate inside a function with C binding.\n+    call allocatec (a, t, p)\n+    if (.not. allocated (a))  stop 411\n+    if (.not. associated (p)) stop 412\n+    if (lbound (a, 1) .ne. 10) stop 413\n+    if (ubound (a, 1) .ne. 20) stop 414\n+    deallocate (a)\n+    p => NULL ()\n+\n+  end subroutine\n+\n+end program"}, {"sha": "2420b7d3731df52c6b59ab95af674d0fea3fc74a", "filename": "gcc/testsuite/gfortran.dg/c-interop/ff-descriptor-5.f90", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-5.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,61 @@\n+! PR92482\n+! { dg-do run }\n+!\n+! This program checks that passing arrays as assumed-length character\n+! dummies to and from Fortran functions with C binding works.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  character(len=26,kind=C_CHAR) :: aa\n+\n+  call testc (aa)\n+  call testf (aa)\n+\n+contains\n+\n+  ! C binding version\n+\n+  subroutine checkc (a) bind (c) ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+    use iso_c_binding\n+    character(len=*,kind=C_CHAR) :: a\n+\n+    if (rank (a) .ne. 0) stop 101\n+    if (len (a) .ne. 26) stop 102\n+    if (a .ne. 'abcdefghijklmnopqrstuvwxyz') stop 103\n+  end subroutine\n+\n+  ! Fortran binding version\n+  subroutine checkf (a)\n+    use iso_c_binding\n+    character(len=*,kind=C_CHAR) :: a\n+\n+    if (rank (a) .ne. 0) stop 201\n+    if (len (a) .ne. 26) stop 202\n+    if (a .ne. 'abcdefghijklmnopqrstuvwxyz') stop 203\n+  end subroutine\n+\n+  ! C binding version\n+  subroutine testc (a) bind (c) ! { dg-bogus \"Sorry\" \"pr92482\" { xfail *-*-* } }\n+    use iso_c_binding\n+    character(len=*,kind=C_CHAR) :: a\n+\n+    ! Call both the C and Fortran binding check functions\n+    a = 'abcdefghijklmnopqrstuvwxyz'\n+    call checkc (a)\n+    call checkf (a)\n+  end subroutine\n+\n+  ! Fortran binding version\n+  subroutine testf (a)\n+    use iso_c_binding\n+    character(len=*,kind=C_CHAR) :: a\n+\n+    ! Call both the C and Fortran binding check functions\n+    a = 'abcdefghijklmnopqrstuvwxyz'\n+    call checkc (a)\n+    call checkf (a)\n+  end subroutine\n+\n+end program"}, {"sha": "8b1167e65fe4d77fc432284e5f2ab70f6ebdeb03", "filename": "gcc/testsuite/gfortran.dg/c-interop/ff-descriptor-6.f90", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-6.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,71 @@\n+! Reported as pr94070.\n+! { dg-do run { xfail *-*-* } }\n+!\n+! This program checks that passing assumed-size arrays to\n+! and from Fortran functions with C binding works.\n+!\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  ! Assumed-size arrays are not passed by descriptor.  What we'll do\n+  ! for this test function is bind an assumed-rank dummy\n+  ! to the assumed-size array.  This is supposed to fill in the descriptor\n+  ! with information about the array present at the call site.\n+  interface\n+    subroutine ctest (a) bind (c)\n+      use iso_c_binding\n+      integer(C_INT) :: a(..)\n+    end subroutine\n+  end interface\n+\n+  integer(C_INT), target :: aa(10,5:8)\n+\n+  ! To get an assumed-size array descriptor, we have to first pass the\n+  ! fixed-size array to a Fortran function with an assumed-size dummy,\n+  call ftest1 (aa)\n+  call ftest2 (aa)\n+  call ftest3 (aa)\n+\n+contains\n+  subroutine ftest1 (a)\n+    use iso_c_binding\n+    integer(C_INT) :: a(10,*)\n+    call testf (a)\n+    call testc (a)\n+  end subroutine\n+  subroutine ftest2 (a)\n+    use iso_c_binding\n+    integer(C_INT) :: a(10,5:*)\n+    call testf (a)\n+    call testc (a)\n+  end subroutine\n+  subroutine ftest3 (a) bind (c)\n+    use iso_c_binding\n+    integer(C_INT) :: a(10,1:*)\n+    call testf (a)\n+    call testc (a)\n+  end subroutine\n+\n+  subroutine testf (a)\n+    use iso_c_binding\n+    integer(C_INT) :: a(..)\n+    if (rank (a) .ne. 2)  stop 101\n+    print *, size (a, 1), size (a, 2)\n+    if (size (a, 1) .ne. 10) stop 102\n+    if (size (a, 2) .ne. -1) stop 103\n+    if (any (lbound (a) .eq. 0)) stop 104\n+  end subroutine\n+\n+  subroutine testc (a) bind (c)\n+    use iso_c_binding\n+    integer(C_INT) :: a(..)\n+    if (rank (a) .ne. 2)  stop 201\n+    print *, size (a, 1), size (a, 2)\n+    if (size (a, 1) .ne. 10) stop 202\n+    if (size (a, 2) .ne. -1) stop 203\n+    if (any (lbound (a) .eq. 0)) stop 204\n+  end subroutine\n+\n+end program"}, {"sha": "3d3c77216ca0d7203de8710aa75bf58c11e2ac75", "filename": "gcc/testsuite/gfortran.dg/c-interop/ff-descriptor-7.f90", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fff-descriptor-7.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,89 @@\n+! { dg-do run }\n+!\n+! Test that arrays that may not be contiguous can be passed both ways\n+! between Fortran subroutines with C and Fortran binding conventions.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  integer(C_INT), target :: aa(10,5)\n+  integer(C_INT), target :: bb(10,10)\n+\n+  integer :: i, j, n\n+\n+  ! Test both C and Fortran binding.\n+  n = 0\n+  do j = 1, 10\n+    do i = 1, 5\n+      aa(j,i) = n\n+      n = n + 1\n+    end do\n+  end do\n+  call testc (transpose (aa))\n+  call testf (transpose (aa))\n+\n+  bb = -1\n+  n = 0\n+  do j = 1, 10\n+    do i = 2, 10, 2\n+      bb(i,j) = n\n+      n = n + 1\n+    end do\n+  end do\n+  call testc (bb(2:10:2, :))\n+  call testf (bb(2:10:2, :))\n+\n+contains\n+\n+  subroutine testc (a) bind (c)\n+    use iso_c_binding\n+    integer(C_INT), intent(in) :: a(:,:)\n+    call checkc (a)\n+    call checkf (a)\n+  end subroutine\n+\n+  subroutine testf (a)\n+    use iso_c_binding\n+    integer(C_INT), intent(in) :: a(:,:)\n+    call checkc (a)\n+    call checkf (a)\n+  end subroutine\n+\n+  subroutine checkc (a) bind (c)\n+    use iso_c_binding\n+    integer(C_INT), intent(in) :: a(:,:)\n+    integer :: i, j, n\n+\n+    if (rank (a) .ne. 2) stop 101\n+    if (size (a, 1) .ne. 5) stop 102\n+    if (size (a, 2) .ne. 10) stop 103\n+\n+    n = 0\n+    do j = 1, 10\n+      do i = 1, 5\n+        if (a(i,j) .ne. n) stop 104\n+        n = n + 1\n+      end do\n+    end do\n+  end subroutine\n+\n+  subroutine checkf (a)\n+    use iso_c_binding\n+    integer(C_INT), intent(in) :: a(:,:)\n+    integer :: i, j, n\n+\n+    if (rank (a) .ne. 2) stop 101\n+    if (size (a, 1) .ne. 5) stop 102\n+    if (size (a, 2) .ne. 10) stop 103\n+\n+    n = 0\n+    do j = 1, 10\n+      do i = 1, 5\n+        if (a(i,j) .ne. n) stop 104\n+        n = n + 1\n+      end do\n+    end do\n+  end subroutine\n+\n+end program"}, {"sha": "253f0efd1edfa4d518a3f7a6e34798b0a8d1f368", "filename": "gcc/testsuite/gfortran.dg/c-interop/note-5-3.f90", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fnote-5-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fnote-5-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fnote-5-3.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,55 @@\n+! { dg-do run }\n+!\n+! TS 29113\n+! NOTE 5.3\n+! The intrinsic inquiry function RANK can be used to inquire about the \n+! rank of a data object. The rank of an assumed-rank object is zero if \n+! the rank of the corresponding actual argument is zero.\n+\n+program test\n+\n+  integer ::  scalar, array_1d(10), array_2d(3, 3)\n+\n+  call testit (scalar, array_1d, array_2d)\n+\n+contains\n+\n+  function test_rank (a)\n+    integer :: test_rank\n+    integer :: a(..)\n+\n+    test_rank = rank (a)\n+  end function\n+\n+  subroutine testit (a0, a1, a2)\n+    integer :: a0(..), a1(..), a2(..)\n+\n+    integer, target :: b0, b1(10), b2(3, 3)\n+    integer, allocatable :: c0, c1(:), c2(:,:)\n+    integer, pointer :: d0, d1(:), d2(:,:)\n+\n+    ! array descriptor passed from caller through testit to test_rank\n+    if (test_rank (a0) .ne. 0) stop 100\n+    if (test_rank (a1) .ne. 1) stop 101\n+    if (test_rank (a2) .ne. 2) stop 102\n+\n+    ! array descriptor created locally here, fixed size\n+    if (test_rank (b0) .ne. 0) stop 200\n+    if (test_rank (b1) .ne. 1) stop 201\n+    if (test_rank (b2) .ne. 2) stop 202\n+\n+    ! allocatable arrays don't actually have to be allocated.\n+    if (test_rank (c0) .ne. 0) stop 300\n+    if (test_rank (c1) .ne. 1) stop 301\n+    if (test_rank (c2) .ne. 2) stop 302\n+\n+    ! pointer arrays do need to point at something.\n+    d0 => b0\n+    d1 => b1\n+    d2 => b2\n+    if (test_rank (d0) .ne. 0) stop 400\n+    if (test_rank (d1) .ne. 1) stop 401\n+    if (test_rank (d2) .ne. 2) stop 402\n+\n+  end subroutine\n+end program"}, {"sha": "ab278460a580e645923e672bf803c77fb70fdcbb", "filename": "gcc/testsuite/gfortran.dg/c-interop/note-5-4-c.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fnote-5-4-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fnote-5-4-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fnote-5-4-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,10 @@\n+#include <ISO_Fortran_binding.h>\n+\n+extern int test_rank (CFI_cdesc_t *a);\n+\n+int test_rank (CFI_cdesc_t *a)\n+{\n+  if (!a)\n+    return -1;  /* Should not happen.  */\n+  return a->rank;\n+}"}, {"sha": "9f3fc8e2ca7ab1b7aab859f8718693e98f17b03b", "filename": "gcc/testsuite/gfortran.dg/c-interop/note-5-4.f90", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fnote-5-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fnote-5-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fnote-5-4.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,63 @@\n+! { dg-do run }\n+! { dg-additional-sources note-5-4-c.c }\n+!\n+! TS 29113\n+! NOTE 5.4\n+! Assumed rank is an attribute of a Fortran dummy argument. When a C\n+! function is invoked with an actual argument that corresponds to an \n+! assumed-rank dummy argument in a Fortran interface for that C function,\n+! the corresponding formal parameter is the address of a descriptor of \n+! type CFI_cdesc_t (8.7). The rank member of the descriptor provides the\n+! rank of the actual argument. The C function should therefore be able\n+! to handle any rank. On each invocation, the rank is available to it.\n+\n+program test\n+\n+  interface\n+    function test_rank (a) bind (c, name=\"test_rank\")\n+      integer :: test_rank\n+      integer :: a(..)\n+    end function\n+  end interface\n+\n+  integer ::  scalar, array_1d(10), array_2d(3, 3)\n+\n+  call testit (scalar, array_1d, array_2d)\n+\n+contains\n+\n+  subroutine testit (a0, a1, a2)\n+    integer :: a0(..), a1(..), a2(..)\n+\n+    integer, target :: b0, b1(10), b2(3, 3)\n+    integer, allocatable :: c0, c1(:), c2(:,:)\n+    integer, pointer :: d0, d1(:), d2(:,:)\n+\n+    ! array descriptor passed from caller through testit to test_rank\n+    if (test_rank (a0) .ne. 0) stop 100\n+    if (test_rank (a1) .ne. 1) stop 101\n+    if (test_rank (a2) .ne. 2) stop 102\n+\n+    ! array descriptor created locally here, fixed size\n+    if (test_rank (b0) .ne. 0) stop 200\n+    if (test_rank (b1) .ne. 1) stop 201\n+    if (test_rank (b2) .ne. 2) stop 202\n+\n+    ! allocatables\n+    allocate (c0)\n+    allocate (c1 (10))\n+    allocate (c2 (3, 3))\n+    if (test_rank (c0) .ne. 0) stop 300\n+    if (test_rank (c1) .ne. 1) stop 301\n+    if (test_rank (c2) .ne. 2) stop 302\n+\n+    ! pointers\n+    d0 => b0\n+    d1 => b1\n+    d2 => b2\n+    if (test_rank (d0) .ne. 0) stop 400\n+    if (test_rank (d1) .ne. 1) stop 401\n+    if (test_rank (d2) .ne. 2) stop 402\n+\n+  end subroutine\n+end program"}, {"sha": "9612d283486d8bf2d4e9763a9f3db29dfac52908", "filename": "gcc/testsuite/gfortran.dg/c-interop/optional-c.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Foptional-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Foptional-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Foptional-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,82 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ftest (int n, CFI_cdesc_t *a, int *b, char *c, double *d);\n+extern void ctest1 (CFI_cdesc_t *a, int *b, char *c, double *d);\n+extern void ctest2 (int n, CFI_cdesc_t *a, int *b, char *c, double *d);\n+\n+static void *aa;\n+static int *bb;\n+static char *cc;\n+static double *dd; \n+\n+extern void\n+ctest1 (CFI_cdesc_t *a, int *b, char *c, double *d)\n+{\n+  /* Cache all the pointer arguments for later use by ctest2.  */\n+  aa = a->base_addr;\n+  bb = b;\n+  cc = c;\n+  dd = d;\n+\n+  /* Test calling back into Fortran.  */\n+  ftest (0, NULL, NULL, NULL, NULL);\n+  ftest (1, a, NULL, NULL, NULL);\n+  ftest (2, a, b, NULL, NULL);\n+  ftest (3, a, b, c, NULL);\n+  ftest (4, a, b, c, d);\n+}\n+\n+extern void\n+ctest2 (int n, CFI_cdesc_t *a, int *b, char *c, double *d)\n+{\n+  if (n >= 1)\n+    {\n+      if (!a)\n+\tabort ();\n+      if (a->base_addr != aa)\n+\tabort ();\n+    }\n+  else\n+    if (a)\n+      abort ();\n+\n+  if (n >= 2)\n+    {\n+      if (!b)\n+\tabort ();\n+      if (*b != *bb)\n+\tabort ();\n+    }\n+  else\n+    if (b)\n+      abort ();\n+\n+  if (n >= 3)\n+    {\n+      if (!c)\n+\tabort ();\n+      if (*c != *cc)\n+\tabort ();\n+    }\n+  else\n+    if (c)\n+      abort ();\n+\n+  if (n >= 4)\n+    {\n+      if (!d)\n+\tabort ();\n+      if (*d != *dd)\n+\tabort ();\n+    }\n+  else\n+    if (d)\n+      abort ();\n+\n+}\n+\n+"}, {"sha": "2a304108c38084228d796fabf94a35e3c7022025", "filename": "gcc/testsuite/gfortran.dg/c-interop/optional.f90", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Foptional.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Foptional.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Foptional.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,114 @@\n+! { dg-do run }\n+! { dg-additional-sources \"optional-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! TS 29113\n+! 8.7 An absent actual argument in a reference to an interoperable\n+! procedure is indicated by a corresponding formal parameter with the\n+! value of a null pointer. An absent optional dummy argument in a\n+! reference to an interoperable procedure from a C function is indicated\n+! by a corresponding argument with the value of a null pointer.\n+\n+module m\n+  use iso_c_binding\n+  integer(C_INT) :: aa(32)\n+  integer(C_INT) :: bb\n+  character(C_CHAR) :: cc\n+  real(C_DOUBLE) :: dd\n+end module\n+\n+subroutine ftest (n, a, b, c, d) bind (c)\n+  use iso_c_binding\n+  use m\n+  implicit none\n+  integer(C_INT), value :: n\n+  integer(C_INT), optional :: a(:)\n+  integer(C_INT), optional :: b\n+  character(C_CHAR), optional :: c\n+  real(C_DOUBLE), optional :: d\n+\n+  if (n .ge. 1) then\n+    if (.not. present (a)) stop 101\n+    if (any (a .ne. aa)) stop 201\n+  else\n+    if (present (a)) stop 301\n+  end if\n+\n+  if (n .ge. 2) then\n+    if (.not. present (b)) stop 102\n+    if (b .ne. bb) stop 201\n+  else\n+    if (present (b)) stop 302\n+  end if\n+\n+  if (n .ge. 3) then\n+    if (.not. present (c)) stop 103\n+    if (c .ne. cc) stop 201\n+  else\n+    if (present (c)) stop 303\n+  end if\n+\n+  if (n .ge. 4) then\n+    if (.not. present (d)) stop 104\n+    if (d .ne. dd) stop 201\n+  else\n+    if (present (d)) stop 304\n+  end if\n+end subroutine\n+\n+program testit\n+  use iso_c_binding\n+  use m\n+  implicit none\n+\n+  interface\n+    subroutine ctest1 (a, b, c, d) bind (c)\n+      use iso_c_binding\n+      integer(C_INT) :: a(:)\n+      integer(C_INT) :: b\n+      character(C_CHAR) :: c\n+      real(C_DOUBLE) :: d\n+    end subroutine\n+    subroutine ctest2 (n, a, b, c, d) bind (c)\n+      use iso_c_binding\n+      integer(C_INT), value :: n\n+      integer(C_INT), optional :: a(:)\n+      integer(C_INT), optional :: b\n+      character(C_CHAR), optional :: c\n+      real(C_DOUBLE), optional :: d\n+    end subroutine\n+    subroutine ftest (n, a, b, c, d) bind (c)\n+      use iso_c_binding\n+      integer(C_INT), value :: n\n+      integer(C_INT), optional :: a(:)\n+      integer(C_INT), optional :: b\n+      character(C_CHAR), optional :: c\n+      real(C_DOUBLE), optional :: d\n+    end subroutine\n+  end interface\n+\n+\n+  ! Initialize the variables above.\n+  integer :: i\n+  do i = 1, 32\n+    aa(i) = i\n+  end do\n+  bb = 42\n+  cc = '$'\n+  dd = acos(-1.D0)\n+\n+  call ftest (0)\n+  call ftest (1, aa)\n+  call ftest (2, aa, bb)\n+  call ftest (3, aa, bb, cc)\n+  call ftest (4, aa, bb, cc, dd)\n+\n+  call ctest1 (aa, bb, cc, dd)\n+  call ctest2 (0)\n+  call ctest2 (1, aa)\n+  call ctest2 (2, aa, bb)\n+  call ctest2 (3, aa, bb, cc)\n+  call ctest2 (4, aa, bb, cc, dd)\n+\n+end program\n+"}, {"sha": "bbf1839e35961307fbe97bdad9149d37cd31c0e0", "filename": "gcc/testsuite/gfortran.dg/c-interop/rank-class.f90", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Frank-class.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Frank-class.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Frank-class.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,88 @@\n+! { dg-do run }\n+!\n+! TS 29113\n+! 7.2 RANK (A)\n+! Description. Rank of a data object.\n+! Class. Inquiry function.\n+! Argument.\n+! A shall be a scalar or array of any type.\n+! Result Characteristics. Default integer scalar.\n+! Result Value. The result is the rank of A.\n+\n+module m\n+\n+  type :: base\n+    integer :: a, b\n+  end type\n+\n+  type, extends (base) :: derived\n+    integer :: c\n+  end type\n+end module\n+\n+program test \n+  use m\n+\n+  ! Define some arrays for testing.\n+  type(derived), target :: x1(5)\n+  type(derived) :: y1(0:9)\n+  type(derived), pointer :: p1(:)\n+  type(derived), allocatable :: a1(:)\n+  type(derived), target :: x3(2,3,4)\n+  type(derived) :: y3(0:1,-3:-1,4)\n+  type(derived), pointer :: p3(:,:,:)\n+  type(derived), allocatable :: a3(:,:,:)\n+  type(derived) :: x\n+\n+  ! Test the 1-dimensional arrays.\n+  if (rank (x1) .ne. 1) stop 201\n+  call testit (x1, 1)\n+  if (rank (y1) .ne. 1) stop 202\n+  call testit (y1, 1)\n+  if (rank (p1) .ne. 1) stop 203\n+  p1 => x1\n+  call testit (p1, 1)\n+  if (rank (p1) .ne. 1) stop 204\n+  if (rank (a1) .ne. 1) stop 205\n+  allocate (a1(5))\n+  if (rank (a1) .ne. 1) stop 206\n+  call testit (a1, 1)\n+\n+  ! Test the multi-dimensional arrays.\n+  if (rank (x3) .ne. 3) stop 207\n+  call testit (x3, 3)\n+  if (rank (y3) .ne. 3) stop 208\n+  if (rank (p3) .ne. 3) stop 209\n+  p3 => x3\n+  call testit (p3, 3)\n+  if (rank (p3) .ne. 3) stop 210\n+  if (rank (a3) .ne. 3) stop 211\n+  allocate (a3(2,3,4))\n+  call testit (a3, 3)\n+  if (rank (a3) .ne. 3) stop 212\n+\n+  ! Test scalars.\n+  if (rank (x) .ne. 0) stop 213\n+  call testit (x, 0)\n+  call test0 (x)\n+  if (rank (x1(1)) .ne. 0) stop 215\n+  call test0 (x1(1))\n+\n+contains\n+\n+  subroutine testit (a, r)\n+    use m\n+    class(base) :: a(..)\n+    integer :: r\n+\n+    if (r .ne. rank(a))  stop 101\n+  end subroutine\n+\n+  subroutine test0 (a)\n+    use m\n+    class(base) :: a(..)\n+    if (rank (a) .ne. 0) stop 103\n+    call testit (a, 0)\n+  end subroutine\n+\n+end program"}, {"sha": "9bae575a9cdf490337c766e48ef42c5c1bd115fb", "filename": "gcc/testsuite/gfortran.dg/c-interop/rank.f90", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Frank.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Frank.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Frank.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,99 @@\n+! { dg-do run }\n+!\n+! TS 29113\n+! 7.2 RANK (A)\n+! Description. Rank of a data object.\n+! Class. Inquiry function.\n+! Argument.\n+! A shall be a scalar or array of any type.\n+! Result Characteristics. Default integer scalar.\n+! Result Value. The result is the rank of A.\n+\n+program test \n+\n+  ! Define some arrays for testing.\n+  integer, target :: x1(5)\n+  integer :: y1(0:9)\n+  integer, pointer :: p1(:)\n+  integer, allocatable :: a1(:)\n+  integer, target :: x3(2,3,4)\n+  integer :: y3(0:1,-3:-1,4)\n+  integer, pointer :: p3(:,:,:)\n+  integer, allocatable :: a3(:,:,:)\n+  integer :: x\n+\n+  ! Test the 1-dimensional arrays.\n+  if (rank (x1) .ne. 1) stop 201\n+  call testit (x1, 1)\n+  call test1 (x1)\n+  if (rank (y1) .ne. 1) stop 202\n+  call testit (y1, 1)\n+  call test1 (y1)\n+  if (rank (p1) .ne. 1) stop 203\n+  p1 => x1\n+  call testit (p1, 1)\n+  if (rank (p1) .ne. 1) stop 204\n+  call test1 (p1)\n+  if (rank (a1) .ne. 1) stop 205\n+  allocate (a1(5))\n+  if (rank (a1) .ne. 1) stop 206\n+  call testit (a1, 1)\n+  call test1 (a1)\n+\n+  ! Test the multi-dimensional arrays.\n+  if (rank (x3) .ne. 3) stop 207\n+  call testit (x3, 3)\n+  call test1 (x3)\n+  call test3 (x3, 1, 2, 1, 3)\n+  if (rank (y3) .ne. 3) stop 208\n+  call test3 (y3, 0, 1, -3, -1)\n+  if (rank (p3) .ne. 3) stop 209\n+  p3 => x3\n+  call testit (p3, 3)\n+  call test1 (p3)\n+  if (rank (p3) .ne. 3) stop 210\n+  call test3 (p3, 1, 2, 1, 3)\n+  if (rank (a3) .ne. 3) stop 211\n+  allocate (a3(2,3,4))\n+  call testit (a3, 3)\n+  call test1 (a3)\n+  if (rank (a3) .ne. 3) stop 212\n+  call test3 (a3, 1, 2, 1, 3)\n+\n+  ! Test scalars.\n+  if (rank (x) .ne. 0) stop 213\n+  call testit (x, 0)\n+  call test0 (x)\n+  if (rank (-1) .ne. 0) stop 214\n+  call test0 (-1)\n+  if (rank (x1(1)) .ne. 0) stop 215\n+  call test0 (x1(1))\n+\n+contains\n+\n+  subroutine testit (a, r)\n+    integer :: a(..)\n+    integer :: r\n+\n+    if (r .ne. rank(a))  stop 101\n+  end subroutine\n+\n+  subroutine test0 (a)\n+    integer :: a(..)\n+    if (rank (a) .ne. 0) stop 103\n+    call testit (a, 0)\n+  end subroutine\n+\n+  subroutine test1 (a)\n+    integer :: a(*)\n+    call testit (a, 1)\n+  end subroutine\n+\n+  subroutine test3 (a, l1, u1, l2, u2)\n+    implicit none\n+    integer :: l1, u1, l2, u2\n+    integer :: a(l1:u1, l2:u2, *)\n+    call testit (a, 3)\n+  end subroutine\n+\n+end program"}, {"sha": "d2155ec6eeb00e2383f2372ed79dfa6f91e103c5", "filename": "gcc/testsuite/gfortran.dg/c-interop/removed-restrictions-1.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fremoved-restrictions-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fremoved-restrictions-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fremoved-restrictions-1.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do compile}\n+!\n+! TS 29113\n+! 8.1 Removed restrictions on ISO_C_BINDING module procedures\n+! \n+! The subroutine C_F_POINTER from the intrinsic module ISO_C_BINDING has\n+! the restriction in ISO/IEC 1539- 1:2010 that if FPTR is an array, it\n+! shall be of interoperable type.\n+!\n+! [...]\n+!\n+! These restrictions are removed.\n+\n+module m\n+  use ISO_C_BINDING\n+  implicit none\n+\n+  ! An obvious example of a type that isn't interoperable is a\n+  ! derived type without a bind(c) clause.\n+\n+  integer :: buflen\n+  parameter (buflen=256)\n+\n+  type :: packet\n+    integer :: size\n+    integer(1) :: buf(buflen)\n+  end type\n+\n+contains\n+\n+  subroutine test (ptr, n, packets)\n+    type(C_PTR), intent(in) :: ptr\n+    integer, intent(in) :: n\n+    type(packet), pointer, intent(out) :: packets(:)\n+\n+    integer :: s(1)\n+    s(1) = n\n+\n+    call c_f_pointer (ptr, packets, s)\n+  end subroutine\n+end module"}, {"sha": "3c49de3715221c76c08674c68c9ab27d22e6fdfb", "filename": "gcc/testsuite/gfortran.dg/c-interop/removed-restrictions-2.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fremoved-restrictions-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fremoved-restrictions-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fremoved-restrictions-2.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,35 @@\n+! { dg-do compile}\n+!\n+! TS 29113\n+! 8.1 Removed restrictions on ISO_C_BINDING module procedures\n+! \n+! The function C_F_PROCPOINTER from the intrinsic module ISO_C_BINDING\n+! has the restriction in ISO/IEC 1539-1:2010 that CPTR and FPTR shall\n+! not be the C address and interface of a noninteroperable Fortran\n+! procedure.\n+!\n+! [...]\n+!\n+! These restrictions are removed.\n+\n+module m\n+  use ISO_C_BINDING\n+  implicit none\n+\n+  ! Declare a non-interoperable Fortran procedure interface.\n+  abstract interface\n+    function foo (x, y)\n+      integer :: foo\n+      integer, intent (in) :: x, y\n+    end function\n+  end interface\n+\n+contains\n+\n+  subroutine test (cptr, fptr)\n+    type(C_FUNPTR), intent(in) :: cptr\n+    procedure (foo), pointer, intent(out) :: fptr\n+\n+    call c_f_procpointer (cptr, fptr)\n+  end subroutine\n+end module"}, {"sha": "b429e8052c9fdd43d6235ee685de7067d7665607", "filename": "gcc/testsuite/gfortran.dg/c-interop/removed-restrictions-3.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fremoved-restrictions-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fremoved-restrictions-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fremoved-restrictions-3.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do compile}\n+!\n+! TS 29113\n+! 8.1 Removed restrictions on ISO_C_BINDING module procedures\n+! \n+! The function C_LOC from the intrinsic module ISO_C_BINDING has the\n+! restriction in ISO/IEC 1539-1:2010 that if X is an array, it shall \n+! be of interoperable type.\n+!\n+! [...]\n+!\n+! These restrictions are removed.\n+\n+module m\n+  use ISO_C_BINDING\n+  implicit none\n+\n+  ! An obvious example of a type that isn't interoperable is a\n+  ! derived type without a bind(c) clause.\n+\n+  integer :: buflen\n+  parameter (buflen=256)\n+\n+  type :: packet\n+    integer :: size\n+    integer(1) :: buf(buflen)\n+  end type\n+\n+contains\n+\n+  subroutine test (packets, ptr)\n+    type(packet), pointer, intent(in) :: packets(:)\n+    type(C_PTR), intent(out) :: ptr\n+\n+    ptr = c_loc (packets)\n+  end subroutine\n+end module"}, {"sha": "b44defd40e1c1a737a39c35d89024b15c9773ed7", "filename": "gcc/testsuite/gfortran.dg/c-interop/removed-restrictions-4.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fremoved-restrictions-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fremoved-restrictions-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fremoved-restrictions-4.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do compile}\n+!\n+! TS 29113\n+! 8.1 Removed restrictions on ISO_C_BINDING module procedures\n+! \n+! [...]\n+!\n+! The function C_FUNLOC from the intrinsic module ISO_C_BINDING has\n+! the restriction in ISO/IEC 1539-1:2010 that its argument shall be\n+! interoperable.\n+!\n+! These restrictions are removed.\n+\n+module m\n+  use ISO_C_BINDING\n+  implicit none\n+\n+  ! Declare a non-interoperable Fortran procedure interface.\n+  abstract interface\n+    function foo (x, y)\n+      integer :: foo\n+      integer, intent (in) :: x, y\n+    end function\n+  end interface\n+\n+contains\n+\n+  subroutine test (fptr, cptr)\n+    procedure (foo), pointer, intent(in) :: fptr\n+    type(C_FUNPTR), intent(out) :: cptr\n+\n+    cptr = c_funloc (fptr)\n+  end subroutine\n+end module"}, {"sha": "7da86a4f2b3123be5f215bc4976f3a4228d5b6be", "filename": "gcc/testsuite/gfortran.dg/c-interop/section-1-c.c", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-1-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-1-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-1-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,135 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *a, int lb, int ub, int s, CFI_cdesc_t *r);\n+\n+/* Take a section of array A.  OFF is the start index of A on the Fortran\n+   side and the bounds LB and UB for the section to take are relative to \n+   that base index.  Store the result in R, which is supposed to be a pointer\n+   array with lower bound 1.  */\n+   \n+void\n+ctest (CFI_cdesc_t *a, int lb, int ub, int s, CFI_cdesc_t *r)\n+{\n+  CFI_index_t lb_array[1], ub_array[1], s_array[1];\n+  CFI_index_t i, o;\n+\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  fprintf (stderr, \"\\n%s: lb=%d  ub=%d  s=%d\\n\",\n+\t   (a->attribute == CFI_attribute_other) ? \"non-pointer\" : \"pointer\",\n+\t   lb, ub, s);  \n+  dump_CFI_cdesc_t (a);\n+  dump_CFI_cdesc_t (r);\n+\n+  /* Make sure we got a valid input descriptor.  */\n+  if (!a->base_addr)\n+    abort ();\n+  if (a->elem_len != sizeof(int))\n+    abort ();\n+  if (a->rank != 1)\n+    abort ();\n+  if (a->type != CFI_type_int)\n+    abort ();\n+  if (a->attribute == CFI_attribute_other)\n+    {\n+      if (a->dim[0].lower_bound != 0)\n+\tabort ();\n+      /* Adjust the 1-based bounds.  */\n+      lb = lb - 1;\n+      ub = ub - 1;\n+    }\n+  /* For pointer arrays, the bounds use the same indexing as the lower\n+     bound in the array descriptor.  */\n+\n+  /* Make sure we got a valid output descriptor.  */\n+  if (r->base_addr)\n+    abort ();\n+  if (r->elem_len != sizeof(int))\n+    abort ();\n+  if (r->rank != 1)\n+    abort ();\n+  if (r->type != CFI_type_int)\n+    abort ();\n+  if (r->attribute != CFI_attribute_pointer)\n+    abort ();\n+\n+  /* Create an array section.  */\n+  lb_array[0] = lb;\n+  ub_array[0] = ub;\n+  s_array[0] = s;\n+\n+  check_CFI_status (\"CFI_section\",\n+\t\t    CFI_section (r, a, lb_array, ub_array, s_array));\n+\n+  /* Check that the output descriptor is correct.  */\n+  dump_CFI_cdesc_t (r);\n+  if (!r->base_addr)\n+    abort ();\n+  if (r->elem_len != sizeof(int))\n+    abort ();\n+  if (r->rank != 1)\n+    abort ();\n+  if (r->type != CFI_type_int)\n+    abort ();\n+  if (r->attribute != CFI_attribute_pointer)\n+    abort ();\n+\n+  /* Check the contents of the output array.  */\n+#if 0\n+  for (o = r->dim[0].lower_bound, i = lb;\n+       (s > 0 ? i <= ub : i >= ub);\n+       o++, i += s)\n+    {\n+      int *input = (int *) CFI_address (a, &i);\n+      int *output = (int *) CFI_address (r, &o);\n+      fprintf (stderr, \"a(%d) = %d, r(%d) = %d\\n\",\n+\t       (int)i, *input, (int)o, *output);\n+    }\n+#endif\n+  for (o = r->dim[0].lower_bound, i = lb;\n+       (s > 0 ? i <= ub : i >= ub);\n+       o++, i += s)\n+    {\n+      int *input = (int *) CFI_address (a, &i);\n+      int *output = (int *) CFI_address (r, &o);\n+      if (*input != *output)\n+\tabort ();\n+    }\n+\n+  /* Force the output array to be 1-based.  */\n+  lb_array[0] = 1;\n+  check_CFI_status (\"CFI_setpointer\", CFI_setpointer (r, r, lb_array));\n+  /* Check that the output descriptor is correct.  */\n+  dump_CFI_cdesc_t (r);\n+  if (!r->base_addr)\n+    abort ();\n+  if (r->elem_len != sizeof(int))\n+    abort ();\n+  if (r->rank != 1)\n+    abort ();\n+  if (r->type != CFI_type_int)\n+    abort ();\n+  if (r->attribute != CFI_attribute_pointer)\n+    abort ();\n+  if (r->dim[0].lower_bound != 1)\n+    abort ();\n+\n+  /* Check the contents of the output array again.  */\n+  for (o = r->dim[0].lower_bound, i = lb;\n+       (s > 0 ? i <= ub : i >= ub);\n+       o++, i += s)\n+    {\n+      int *input = (int *) CFI_address (a, &i);\n+      int *output = (int *) CFI_address (r, &o);\n+      if (*input != *output)\n+\tabort ();\n+    }\n+\n+}\n+\n+\n+"}, {"sha": "4e54116d08c0e4d4147acba2afa5dc193ffa5ac7", "filename": "gcc/testsuite/gfortran.dg/c-interop/section-1.f90", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-1.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,71 @@\n+! { dg-do run }\n+! { dg-additional-sources \"section-1-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program tests basic use of the CFI_section C library function on\n+! a 1-dimensional non-pointer/non-allocatable array, passed as an\n+! assumed-shape dummy.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+    subroutine ctest (a, lb, ub, s, r) bind (c)\n+      use iso_c_binding\n+      integer(C_INT), target :: a(:)\n+      integer(C_INT), value :: lb, ub, s\n+      integer(C_INT), pointer, intent(out) :: r(:)\n+    end subroutine\n+\n+  end interface\n+\n+  integer(C_INT), target :: aa(32)\n+  integer :: i\n+\n+  ! Initialize the test array by numbering its elements.\n+  do i = 1, 32\n+    aa(i) = i\n+  end do\n+\n+  ! Try some cases with non-pointer input arrays.\n+  call test (aa, 1, 32, 5, 13, 2)      ! basic test\n+  call test (aa, 4, 35, 5, 13, 2)      ! non-default lower bound\n+  call test (aa, 1, 32, 32, 16, -2)    ! negative step\n+\n+contains\n+\n+  ! Test function for non-pointer array AA.\n+  ! LO and HI are the bounds for the entire array.\n+  ! LB, UB, and S describe the section to take, and use the\n+  ! same indexing as LO and HI.\n+  subroutine test (aa, lo, hi, lb, ub, s)\n+    integer :: aa(lo:hi)\n+    integer :: lo, hi, lb, ub, s\n+\n+    integer(C_INT), pointer :: rr(:)\n+    integer :: i, o\n+\n+    ! Call the C function to put a section in rr.\n+    ! The C function expects the section bounds to be 1-based.\n+    nullify (rr)\n+    call ctest (aa, lb - lo + 1, ub - lo + 1, s, rr)\n+\n+    ! Make sure the original array has not been modified.\n+    do i = lo, hi\n+      if (aa(i) .ne. i - lo + 1) stop 103\n+    end do\n+\n+    ! Make sure the output array has the expected bounds and elements.\n+    if (.not. associated (rr)) stop 111\n+    if (lbound (rr, 1) .ne. 1) stop 112\n+    if (ubound (rr, 1) .ne. (ub - lb)/s + 1) stop 113\n+    o = 1\n+    do i = lb, ub, s\n+      if (rr(o) .ne. i - lo + 1) stop 114\n+      o = o + 1\n+    end do\n+  end subroutine\n+\n+end program\n+"}, {"sha": "e4831268a1e1ba1ff237558cedad4d0a79c5d3dc", "filename": "gcc/testsuite/gfortran.dg/c-interop/section-1p.f90", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-1p.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-1p.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-1p.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,75 @@\n+! PR 101310\n+! { dg-do run }\n+! { dg-additional-sources \"section-1-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program tests basic use of the CFI_section C library function on\n+! a 1-dimensional pointer array.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+    subroutine ctest (p, lb, ub, s, r) bind (c)\n+      use iso_c_binding\n+      integer(C_INT), pointer :: p(:)\n+      integer(C_INT), value :: lb, ub, s\n+      integer(C_INT), pointer, intent(out) :: r(:)\n+    end subroutine\n+\n+  end interface\n+\n+  integer(C_INT), target :: aa(32)\n+  integer :: i\n+\n+  ! Initialize the test array by numbering its elements.\n+  do i = 1, 32\n+    aa(i) = i\n+  end do\n+\n+  call test_p (aa, 0, 31, 15, 24, 3)   ! zero lower bound\n+  call test_p (aa, 1, 32, 16, 25, 3)   ! non-zero lower bound\n+  call test_p (aa, 4, 35, 16, 25, 3)   ! some other lower bound\n+  call test_p (aa, 1, 32, 32, 16, -2)  ! negative step\n+  stop\n+\n+contains\n+\n+  ! Test function for non-pointer array AA.\n+  ! LO and HI are the bounds for the entire array.\n+  ! LB, UB, and S describe the section to take, and use the\n+  ! same indexing as LO and HI.\n+  subroutine test_p (aa, lo, hi, lb, ub, s)\n+    integer, target :: aa(1:hi-lo+1)\n+    integer :: lo, hi, lb, ub, s\n+\n+    integer(C_INT), pointer :: pp(:), rr(:)\n+    integer :: i, o\n+\n+    pp(lo:hi) => aa\n+    if (lbound (pp, 1) .ne. lo) stop 121\n+    if (ubound (pp, 1) .ne. hi) stop 122\n+    nullify (rr)\n+    call ctest (pp, lb, ub, s, rr)\n+\n+    ! Make sure the input pointer array has not been modified.\n+    if (lbound (pp, 1) .ne. lo) stop 144\n+    if (ubound (pp, 1) .ne. hi) stop 145\n+    do i = lo, hi\n+      if (pp(i) .ne. i - lo + 1) stop 146\n+    end do\n+\n+    ! Make sure the output array has the expected bounds and elements.\n+    if (.not. associated (rr)) stop 151\n+    if (lbound (rr, 1) .ne. 1) stop 152\n+    if (ubound (rr, 1) .ne. (ub - lb)/s + 1) stop 153\n+    o = 1\n+    do i = lb, ub, s\n+      if (rr(o) .ne. i - lo + 1) stop 154\n+      o = o + 1\n+    end do\n+  end subroutine\n+\n+end program\n+"}, {"sha": "f1ff12715ee5acd26105dd69c4183863f52cc8f1", "filename": "gcc/testsuite/gfortran.dg/c-interop/section-2-c.c", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-2-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-2-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-2-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,175 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+struct m {\n+  int x, y;\n+};\n+\n+extern void ctest (CFI_cdesc_t *a, int lb0, int lb1,\n+\t\t   int ub0, int ub1, int s0, int s1, CFI_cdesc_t *r);\n+\n+/* Take a section of array A.  OFF is the start index of A on the Fortran\n+   side and the bounds LB and UB for the section to take are relative to \n+   that base index.  Store the result in R, which is supposed to be a pointer\n+   array with lower bound 1.  */\n+   \n+void\n+ctest (CFI_cdesc_t *a, int lb0, int lb1,\n+\t\t   int ub0, int ub1, int s0, int s1, CFI_cdesc_t *r)\n+{\n+  CFI_index_t lb_array[2], ub_array[2], s_array[2];\n+  int i0, i1, o0, o1;\n+\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  fprintf (stderr, \"\\n%s: lb0=%d  lb1=%d  ub0=%d  ub1=%d  s0=%d  s1=%d\\n\",\n+\t   (a->attribute == CFI_attribute_other) ? \"non-pointer\" : \"pointer\",\n+\t   lb0, lb1, ub0, ub1, s0, s1);  \n+  if (lb0 == ub0 || lb1 == ub1)\n+    abort ();\n+  dump_CFI_cdesc_t (a);\n+  dump_CFI_cdesc_t (r);\n+\n+  /* Make sure we got a valid input descriptor.  */\n+  if (!a->base_addr)\n+    abort ();\n+  if (a->elem_len != sizeof(struct m))\n+    abort ();\n+  if (a->rank != 2)\n+    abort ();\n+  if (a->type != CFI_type_struct)\n+    abort ();\n+  if (a->attribute == CFI_attribute_other)\n+    {\n+      if (a->dim[0].lower_bound != 0)\n+\tabort ();\n+      /* Adjust the 1-based bounds.  */\n+      lb0 = lb0 - 1;\n+      lb1 = lb1 - 1;\n+      ub0 = ub0 - 1;\n+      ub1 = ub1 - 1;\n+    }\n+  /* For pointer arrays, the bounds use the same indexing as the lower\n+     bound in the array descriptor.  */\n+\n+  /* Make sure we got a valid output descriptor.  */\n+  if (r->base_addr)\n+    abort ();\n+  if (r->elem_len != sizeof(struct m))\n+    abort ();\n+  if (r->rank != 2)\n+    abort ();\n+  if (r->type != CFI_type_struct)\n+    abort ();\n+  if (r->attribute != CFI_attribute_pointer)\n+    abort ();\n+\n+  /* Create an array section.  */\n+  lb_array[0] = lb0;\n+  lb_array[1] = lb1;\n+  ub_array[0] = ub0;\n+  ub_array[1] = ub1;\n+  s_array[0] = s0;\n+  s_array[1] = s1;\n+\n+  check_CFI_status (\"CFI_section\",\n+\t\t    CFI_section (r, a, lb_array, ub_array, s_array));\n+\n+  /* Check that the output descriptor is correct.  */\n+  dump_CFI_cdesc_t (r);\n+  if (!r->base_addr)\n+    abort ();\n+  if (r->elem_len != sizeof(struct m))\n+    abort ();\n+  if (r->rank != 2)\n+    abort ();\n+  if (r->type != CFI_type_struct)\n+    abort ();\n+  if (r->attribute != CFI_attribute_pointer)\n+    abort ();\n+\n+  /* Check the contents of the output array.  */\n+#if 0\n+  for (o1 = r->dim[1].lower_bound, i1 = lb1;\n+       (s1 > 0 ? i1 <= ub1 : i1 >= ub1);\n+       o1++, i1 += s1)\n+    for (o0 = r->dim[0].lower_bound, i0 = lb0;\n+\t (s0 > 0 ? i0 <= ub0 : i0 >= ub0);\n+\t o0++, i0 += s0)\n+      {\n+\tCFI_index_t index[2];\n+\tstruct m *input, *output;\n+\tindex[0] = i0;\n+\tindex[1] = i1;\n+\tinput = (struct m *) CFI_address (a, index);\n+\tindex[0] = o0;\n+\tindex[1] = o1;\n+\toutput = (struct m *) CFI_address (r, index);\n+\tfprintf (stderr, \"a(%d,%d) = (%d,%d), r(%d,%d) = (%d,%d)\\n\",\n+\t\t i0, i1, input->x, input->y, o0, o1, output->x, output->y);\n+      }\n+#endif\n+  for (o1 = r->dim[1].lower_bound, i1 = lb1;\n+       (s1 > 0 ? i1 <= ub1 : i1 >= ub1);\n+       o1++, i1 += s1)\n+    for (o0 = r->dim[0].lower_bound, i0 = lb0;\n+\t (s0 > 0 ? i0 <= ub0 : i0 >= ub0);\n+\t o0++, i0 += s0)\n+      {\n+\tCFI_index_t index[2];\n+\tstruct m *input, *output;\n+\tindex[0] = i0;\n+\tindex[1] = i1;\n+\tinput = (struct m *) CFI_address (a, index);\n+\tindex[0] = o0;\n+\tindex[1] = o1;\n+\toutput = (struct m *) CFI_address (r, index);\n+\tif (input->x != output->x || input->y != output->y)\n+\t  abort ();\n+      }\n+\n+  /* Force the output array to be 1-based.  */\n+  lb_array[0] = 1;\n+  lb_array[1] = 1;\n+  check_CFI_status (\"CFI_setpointer\", CFI_setpointer (r, r, lb_array));\n+  /* Check that the output descriptor is correct.  */\n+  dump_CFI_cdesc_t (r);\n+  if (!r->base_addr)\n+    abort ();\n+  if (r->elem_len != sizeof(struct m))\n+    abort ();\n+  if (r->rank != 2)\n+    abort ();\n+  if (r->type != CFI_type_struct)\n+    abort ();\n+  if (r->attribute != CFI_attribute_pointer)\n+    abort ();\n+  if (r->dim[0].lower_bound != 1)\n+    abort ();\n+\n+  /* Check the contents of the output array again.  */\n+  for (o1 = r->dim[1].lower_bound, i1 = lb1;\n+       (s1 > 0 ? i1 <= ub1 : i1 >= ub1);\n+       o1++, i1 += s1)\n+    for (o0 = r->dim[0].lower_bound, i0 = lb0;\n+\t (s0 > 0 ? i0 <= ub0 : i0 >= ub0);\n+\t o0++, i0 += s0)\n+      {\n+\tCFI_index_t index[2];\n+\tstruct m *input, *output;\n+\tindex[0] = i0;\n+\tindex[1] = i1;\n+\tinput = (struct m *) CFI_address (a, index);\n+\tindex[0] = o0;\n+\tindex[1] = o1;\n+\toutput = (struct m *) CFI_address (r, index);\n+\tif (input->x != output->x || input->y != output->y)\n+\t  abort ();\n+      }\n+}\n+\n+\n+"}, {"sha": "73ad9ecd3b89d04e0778d3394494be9591a919a0", "filename": "gcc/testsuite/gfortran.dg/c-interop/section-2.f90", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-2.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,102 @@\n+! { dg-do run }\n+! { dg-additional-sources \"section-2-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program tests basic use of the CFI_section C library function on\n+! a 2-dimensional non-pointer array.\n+\n+module mm\n+  use ISO_C_BINDING\n+  type, bind (c) :: m\n+    integer(C_INT) :: x, y\n+  end type\n+end module\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  interface\n+    subroutine ctest (a, lb0, lb1, ub0, ub1, s0, s1, r) bind (c)\n+      use iso_c_binding\n+      use mm\n+      type(m), target :: a(:,:)\n+      integer(C_INT), value :: lb0, lb1, ub0, ub1, s0, s1\n+      type(m), pointer, intent(out) :: r(:,:)\n+    end subroutine\n+\n+  end interface\n+\n+  type(m), target :: aa(10, 20)\n+  integer :: i0, i1\n+\n+  ! Initialize the test array by numbering its elements.\n+  do i1 = 1, 20\n+    do i0 = 1, 10\n+      aa(i0, i1)%x = i0\n+      aa(i0, i1)%y = i1\n+    end do\n+  end do\n+\n+  call test (aa, 4, 3, 10, 15, 2, 3)       ! basic test\n+  call test (aa, 10, 15, 4, 3, -2, -3)     ! negative step\n+  stop\n+\n+contains\n+\n+  ! Test function for non-pointer array AA.\n+  ! LB, UB, and S describe the section to take.\n+  subroutine test (aa, lb0, lb1, ub0, ub1, s0, s1)\n+    use mm\n+    type(m) :: aa(10,20)\n+    integer :: lb0, lb1, ub0, ub1, s0, s1\n+\n+    type(m), pointer :: rr(:,:)\n+    integer :: i0, i1, o0, o1\n+    integer, parameter :: hi0 = 10\n+    integer, parameter :: hi1 = 20\n+\n+    ! Make sure the original array is OK.\n+    do i1 = 1, hi1\n+      do i0 = 1, hi0\n+        if (aa(i0,i1)%x .ne. i0) stop 101\n+        if (aa(i0,i1)%y .ne. i1) stop 101\n+      end do\n+    end do\n+\n+    ! Call the C function to put a section in rr.\n+    ! The C function expects the section bounds to be 1-based.\n+    nullify (rr)\n+    call ctest (aa, lb0, lb1, ub0, ub1, s0, s1, rr)\n+\n+    ! Make sure the original array has not been modified.\n+    do i1 = 1, hi1\n+      do i0 = 1, hi0\n+        if (aa(i0,i1)%x .ne. i0) stop 103\n+        if (aa(i0,i1)%y .ne. i1) stop 103\n+      end do\n+    end do\n+\n+    ! Make sure the output array has the expected bounds and elements.\n+    if (.not. associated (rr)) stop 111\n+    if (lbound (rr, 1) .ne. 1) stop 112\n+    if (lbound (rr, 2) .ne. 1) stop 112\n+    if (ubound (rr, 1) .ne. (ub0 - lb0)/s0 + 1) stop 113\n+    if (ubound (rr, 2) .ne. (ub1 - lb1)/s1 + 1) stop 113\n+    o1 = 1\n+    do i1 = lb1, ub1, s1\n+      o0 = 1\n+      do i0 = lb0, ub0, s0\n+        ! print 999, o0, o1, rr(o0,o1)%x, rr(o0,01)%y\n+\t! 999 format ('rr(', i3, ',', i3, ') = (', i3, ',', i3, ')')\n+        if (rr(o0,o1)%x .ne. i0) stop 114\n+        if (rr(o0,o1)%y .ne. i1) stop 114\n+        o0 = o0 + 1\n+      end do\n+      o1 = o1 + 1\n+    end do\n+  end subroutine\n+\n+end program\n+"}, {"sha": "f8a174591fa0144f0500ceb5e7a33e170118ca8c", "filename": "gcc/testsuite/gfortran.dg/c-interop/section-2p.f90", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-2p.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-2p.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-2p.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,104 @@\n+! PR 101310\n+! { dg-do run }\n+! { dg-additional-sources \"section-2-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program tests basic use of the CFI_section C library function on\n+! a 2-dimensional pointer array.\n+\n+module mm\n+  use ISO_C_BINDING\n+  type, bind (c) :: m\n+    integer(C_INT) :: x, y\n+  end type\n+end module\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  interface\n+    subroutine ctest (p, lb0, lb1, ub0, ub1, s0, s1, r) bind (c)\n+      use iso_c_binding\n+      use mm\n+      type(m), pointer :: p(:,:)\n+      integer(C_INT), value :: lb0, lb1, ub0, ub1, s0, s1\n+      type(m), pointer, intent(out) :: r(:,:)\n+    end subroutine\n+\n+  end interface\n+\n+  type(m), target :: aa(10, 20)\n+  integer :: i0, i1\n+\n+  ! Initialize the test array by numbering its elements.\n+  do i1 = 1, 20\n+    do i0 = 1, 10\n+      aa(i0, i1)%x = i0\n+      aa(i0, i1)%y = i1\n+    end do\n+  end do\n+\n+  call test (aa, 0, 0, 3, 2, 9, 14, 2, 3)       ! zero lower bound\n+  call test (aa, 1, 1, 4, 3, 10, 15, 2, 3)      ! lower bound 1\n+  call test (aa, 6, 11, 9, 13, 15, 25, 2, 3)    ! other lower bound\n+  call test (aa, 1, 1, 10, 15, 4, 3, -2, -3)    ! negative step\n+  stop\n+\n+contains\n+\n+  ! Test function for pointer array AA.\n+  ! The bounds of the array are adjusted so it is based at (LO0,LO1).\n+  ! LB, UB, and S describe the section of the adjusted array to take.\n+  subroutine test (aa, lo0, lo1, lb0, lb1, ub0, ub1, s0, s1)\n+    use mm\n+    type(m), target :: aa(1:10, 1:20)\n+    integer :: lo0, lo1, lb0, lb1, ub0, ub1, s0, s1\n+\n+    type(m), pointer :: pp(:,:), rr(:,:)\n+    integer :: i0, i1, o0, o1\n+    integer :: hi0, hi1\n+    hi0 = lo0 + 10 - 1\n+    hi1 = lo1 + 20 - 1\n+\n+    pp(lo0:,lo1:) => aa\n+    if (lbound (pp, 1) .ne. lo0) stop 121\n+    if (lbound (pp, 2) .ne. lo1) stop 121\n+    if (ubound (pp, 1) .ne. hi0) stop 122\n+    if (ubound (pp, 2) .ne. hi1) stop 122\n+    nullify (rr)\n+    call ctest (pp, lb0, lb1, ub0, ub1, s0, s1, rr)\n+\n+    ! Make sure the input pointer array has not been modified.\n+    if (lbound (pp, 1) .ne. lo0) stop 131\n+    if (ubound (pp, 1) .ne. hi0) stop 132\n+    if (lbound (pp, 2) .ne. lo1) stop 133\n+    if (ubound (pp, 2) .ne. hi1) stop 134\n+    do i1 = lo1, hi1\n+      do i0 = lo0, hi0\n+        if (pp(i0,i1)%x .ne. i0 - lo0 + 1) stop 135\n+        if (pp(i0,i1)%y .ne. i1 - lo1 + 1) stop 136\n+      end do\n+    end do\n+\n+    ! Make sure the output array has the expected bounds and elements.\n+    if (.not. associated (rr)) stop 141\n+    if (lbound (rr, 1) .ne. 1) stop 142\n+    if (lbound (rr, 2) .ne. 1) stop 142\n+    if (ubound (rr, 1) .ne. (ub0 - lb0)/s0 + 1) stop 143\n+    if (ubound (rr, 2) .ne. (ub1 - lb1)/s1 + 1) stop 143\n+    o1 = 1\n+    do i1 = lb1, ub1, s1\n+      o0 = 1\n+      do i0 = lb0, ub0, s0\n+        if (rr(o0,o1)%x .ne. i0 - lo0 + 1) stop 144\n+        if (rr(o0,o1)%y .ne. i1 - lo1 + 1) stop 144\n+        o0 = o0 + 1\n+      end do\n+      o1 = o1 + 1\n+    end do\n+  end subroutine\n+\n+end program\n+"}, {"sha": "819b58fbe3d29c8bfe04f15ecbf1d4c345c70688", "filename": "gcc/testsuite/gfortran.dg/c-interop/section-3-c.c", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-3-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-3-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-3-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,235 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+struct m {\n+  int x, y;\n+};\n+\n+extern void ctest (CFI_cdesc_t *a, int lb0, int lb1,\n+\t\t   int ub0, int ub1, int s0, int s1, CFI_cdesc_t *r);\n+\n+/* Take a section of array A.  OFF is the start index of A on the Fortran\n+   side and the bounds LB and UB for the section to take are relative to \n+   that base index.  Store the result in R, which is supposed to be a pointer\n+   array with lower bound 1.  */\n+   \n+void\n+ctest (CFI_cdesc_t *a, int lb0, int lb1,\n+\t\t   int ub0, int ub1, int s0, int s1, CFI_cdesc_t *r)\n+{\n+  CFI_index_t lb_array[2], ub_array[2], s_array[2];\n+  int i0, i1, o0, o1;\n+\n+  /* Dump the descriptor contents to test that we can access the fields\n+     correctly, etc.  */\n+  fprintf (stderr, \"\\n%s: lb0=%d  lb1=%d  ub0=%d  ub1=%d  s0=%d  s1=%d\\n\",\n+\t   (a->attribute == CFI_attribute_other) ? \"non-pointer\" : \"pointer\",\n+\t   lb0, lb1, ub0, ub1, s0, s1);  \n+  if (! (lb0 == ub0 || lb1 == ub1))\n+    abort ();\n+  dump_CFI_cdesc_t (a);\n+  dump_CFI_cdesc_t (r);\n+\n+  /* Make sure we got a valid input descriptor.  */\n+  if (!a->base_addr)\n+    abort ();\n+  if (a->elem_len != sizeof(struct m))\n+    abort ();\n+  if (a->rank != 2)\n+    abort ();\n+  if (a->type != CFI_type_struct)\n+    abort ();\n+  if (a->attribute == CFI_attribute_other)\n+    {\n+      if (a->dim[0].lower_bound != 0)\n+\tabort ();\n+      /* Adjust the 1-based bounds.  */\n+      lb0 = lb0 - 1;\n+      lb1 = lb1 - 1;\n+      ub0 = ub0 - 1;\n+      ub1 = ub1 - 1;\n+    }\n+  /* For pointer arrays, the bounds use the same indexing as the lower\n+     bound in the array descriptor.  */\n+\n+  /* Make sure we got a valid output descriptor.  */\n+  if (r->base_addr)\n+    abort ();\n+  if (r->elem_len != sizeof(struct m))\n+    abort ();\n+  if (r->rank != 1)\n+    abort ();\n+  if (r->type != CFI_type_struct)\n+    abort ();\n+  if (r->attribute != CFI_attribute_pointer)\n+    abort ();\n+\n+  /* Create an array section.  */\n+  lb_array[0] = lb0;\n+  lb_array[1] = lb1;\n+  ub_array[0] = ub0;\n+  ub_array[1] = ub1;\n+  s_array[0] = s0;\n+  s_array[1] = s1;\n+\n+  check_CFI_status (\"CFI_section\",\n+\t\t    CFI_section (r, a, lb_array, ub_array, s_array));\n+\n+  /* Check that the output descriptor is correct.  */\n+  dump_CFI_cdesc_t (r);\n+  if (!r->base_addr)\n+    abort ();\n+  if (r->elem_len != sizeof(struct m))\n+    abort ();\n+  if (r->rank != 1)\n+    abort ();\n+  if (r->type != CFI_type_struct)\n+    abort ();\n+  if (r->attribute != CFI_attribute_pointer)\n+    abort ();\n+\n+  /* Check the contents of the output array.  */\n+#if 0\n+  if (lb1 == ub1)\n+    {\n+      /* Output is 1-d array that varies in dimension 0.  */\n+      for (o0 = r->dim[0].lower_bound, i0 = lb0;\n+\t   (s0 > 0 ? i0 <= ub0 : i0 >= ub0);\n+\t   o0++, i0 += s0)\n+\t{\n+\t  CFI_index_t index[2];\n+\t  struct m *input, *output;\n+\t  index[0] = i0;\n+\t  index[1] = lb1;\n+\t  input = (struct m *) CFI_address (a, index);\n+\t  index[0] = o0;\n+\t  output = (struct m *) CFI_address (r, index);\n+\t  fprintf (stderr, \"a(%d,%d) = (%d,%d), r(%d) = (%d,%d)\\n\",\n+\t\t   i0, lb1, input->x, input->y, o0, output->x, output->y);\n+\t}\n+    }\n+  else if (lb0 == ub0)\n+    {\n+      /* Output is 1-d array that varies in dimension 1.  */\n+      for (o1 = r->dim[0].lower_bound, i1 = lb1;\n+\t   (s1 > 0 ? i1 <= ub1 : i1 >= ub1);\n+\t   o1++, i1 += s1)\n+\t{\n+\t  CFI_index_t index[2];\n+\t  struct m *input, *output;\n+\t  index[0] = lb0;\n+\t  index[1] = i1;\n+\t  input = (struct m *) CFI_address (a, index);\n+\t  index[0] = o1;\n+\t  output = (struct m *) CFI_address (r, index);\n+\t  fprintf (stderr, \"a(%d,%d) = (%d,%d), r(%d) = (%d,%d)\\n\",\n+\t\t   lb0, i1, input->x, input->y, o1, output->x, output->y);\n+\t}\n+    }\n+  else\n+    abort ();\n+#endif\n+  if (lb1 == ub1)\n+    {\n+      /* Output is 1-d array that varies in dimension 0.  */\n+      for (o0 = r->dim[0].lower_bound, i0 = lb0;\n+\t   (s0 > 0 ? i0 <= ub0 : i0 >= ub0);\n+\t   o0++, i0 += s0)\n+\t{\n+\t  CFI_index_t index[2];\n+\t  struct m *input, *output;\n+\t  index[0] = i0;\n+\t  index[1] = lb1;\n+\t  input = (struct m *) CFI_address (a, index);\n+\t  index[0] = o0;\n+\t  output = (struct m *) CFI_address (r, index);\n+\t  if (input->x != output->x || input->y != output->y)\n+\t    abort ();\n+\t}\n+    }\n+  else if (lb0 == ub0)\n+    {\n+      /* Output is 1-d array that varies in dimension 1.  */\n+      for (o1 = r->dim[0].lower_bound, i1 = lb1;\n+\t   (s1 > 0 ? i1 <= ub1 : i1 >= ub1);\n+\t   o1++, i1 += s1)\n+\t{\n+\t  CFI_index_t index[2];\n+\t  struct m *input, *output;\n+\t  index[0] = lb0;\n+\t  index[1] = i1;\n+\t  input = (struct m *) CFI_address (a, index);\n+\t  index[0] = o1;\n+\t  output = (struct m *) CFI_address (r, index);\n+\t  if (input->x != output->x || input->y != output->y)\n+\t    abort ();\n+\t}\n+    }\n+  else\n+    abort ();\n+\n+  /* Force the output array to be 1-based.  */\n+  lb_array[0] = 1;\n+  lb_array[1] = 1;\n+  check_CFI_status (\"CFI_setpointer\", CFI_setpointer (r, r, lb_array));\n+  /* Check that the output descriptor is correct.  */\n+  dump_CFI_cdesc_t (r);\n+  if (!r->base_addr)\n+    abort ();\n+  if (r->elem_len != sizeof(struct m))\n+    abort ();\n+  if (r->rank != 1)\n+    abort ();\n+  if (r->type != CFI_type_struct)\n+    abort ();\n+  if (r->attribute != CFI_attribute_pointer)\n+    abort ();\n+  if (r->dim[0].lower_bound != 1)\n+    abort ();\n+\n+  /* Check the contents of the output array again.  */\n+  if (lb1 == ub1)\n+    {\n+      /* Output is 1-d array that varies in dimension 0.  */\n+      for (o0 = r->dim[0].lower_bound, i0 = lb0;\n+\t   (s0 > 0 ? i0 <= ub0 : i0 >= ub0);\n+\t   o0++, i0 += s0)\n+\t{\n+\t  CFI_index_t index[2];\n+\t  struct m *input, *output;\n+\t  index[0] = i0;\n+\t  index[1] = lb1;\n+\t  input = (struct m *) CFI_address (a, index);\n+\t  index[0] = o0;\n+\t  output = (struct m *) CFI_address (r, index);\n+\t  if (input->x != output->x || input->y != output->y)\n+\t    abort ();\n+\t}\n+    }\n+  else if (lb0 == ub0)\n+    {\n+      /* Output is 1-d array that varies in dimension 1.  */\n+      for (o1 = r->dim[0].lower_bound, i1 = lb1;\n+\t   (s1 > 0 ? i1 <= ub1 : i1 >= ub1);\n+\t   o1++, i1 += s1)\n+\t{\n+\t  CFI_index_t index[2];\n+\t  struct m *input, *output;\n+\t  index[0] = lb0;\n+\t  index[1] = i1;\n+\t  input = (struct m *) CFI_address (a, index);\n+\t  index[0] = o1;\n+\t  output = (struct m *) CFI_address (r, index);\n+\t  if (input->x != output->x || input->y != output->y)\n+\t    abort ();\n+\t}\n+    }\n+  else\n+    abort ();\n+}\n+\n+\n+"}, {"sha": "c690c50b67c7622a35e1eb47689a824f86a7c7c1", "filename": "gcc/testsuite/gfortran.dg/c-interop/section-3.f90", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-3.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,103 @@\n+! PR 101310\n+! { dg-do run }\n+! { dg-additional-sources \"section-3-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program tests basic use of the CFI_section C library function to\n+! take a slice of a 2-dimensional non-pointer array.\n+\n+module mm\n+  use ISO_C_BINDING\n+  type, bind (c) :: m\n+    integer(C_INT) :: x, y\n+  end type\n+end module\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  interface\n+    subroutine ctest (a, lb0, lb1, ub0, ub1, s0, s1, r) bind (c)\n+      use iso_c_binding\n+      use mm\n+      type(m), target :: a(:,:)\n+      integer(C_INT), value :: lb0, lb1, ub0, ub1, s0, s1\n+      type(m), pointer, intent(out) :: r(:)\n+    end subroutine\n+\n+  end interface\n+\n+  type(m), target :: aa(10, 20)\n+  integer :: i0, i1\n+\n+  ! Initialize the test array by numbering its elements.\n+  do i1 = 1, 20\n+    do i0 = 1, 10\n+      aa(i0, i1)%x = i0\n+      aa(i0, i1)%y = i1\n+    end do\n+  end do\n+\n+  call test (aa, 3, 1, 3, 20, 0, 1)        ! full slice 0\n+  call test (aa, 1, 8, 10, 8, 1, 0)        ! full slice 1\n+  call test (aa, 3, 5, 3, 14, 0, 3)        ! partial slice 0\n+  call test (aa, 2, 8, 10, 8, 2, 0)        ! partial slice 1\n+  call test (aa, 3, 14, 3, 5, 0, -3)       ! backwards slice 0\n+  call test (aa, 10, 8, 2, 8, -2, 0)       ! backwards slice 1\n+\n+contains\n+\n+  ! Test function for non-pointer array AA.\n+  ! LB, UB, and S describe the section to take.\n+  subroutine test (aa, lb0, lb1, ub0, ub1, s0, s1)\n+    use mm\n+    type(m) :: aa(10,20)\n+    integer :: lb0, lb1, ub0, ub1, s0, s1\n+\n+    type(m), pointer :: rr(:)\n+    integer :: i0, i1, o0, o1\n+    integer, parameter :: hi0 = 10\n+    integer, parameter :: hi1 = 20\n+\n+    ! Check the bounds actually specify a \"slice\" rather than a subarray.\n+    if (lb0 .ne. ub0 .and. lb1 .ne. ub1)  stop 100\n+\n+    ! Call the C function to put a section in rr.\n+    ! The C function expects the section bounds to be 1-based.\n+    nullify (rr)\n+    call ctest (aa, lb0, lb1, ub0, ub1, s0, s1, rr)\n+\n+    ! Make sure the original array has not been modified.\n+    do i1 = 1, hi1\n+      do i0 = 1, hi0\n+        if (aa(i0,i1)%x .ne. i0) stop 103\n+        if (aa(i0,i1)%y .ne. i1) stop 103\n+      end do\n+    end do\n+\n+    ! Make sure the output array has the expected bounds and elements.\n+    if (.not. associated (rr)) stop 111\n+    if (lbound (rr, 1) .ne. 1) stop 112\n+    if (ub0 .eq. lb0) then\n+      if (ubound (rr, 1) .ne. (ub1 - lb1)/s1 + 1) stop 113\n+      o1 = 1\n+      do i1 = lb1, ub1, s1\n+        if (rr(o1)%x .ne. lb0) stop 114\n+        if (rr(o1)%y .ne. i1) stop 114\n+\to1 = o1 + 1\n+      end do\n+    else\n+      if (ubound (rr, 1) .ne. (ub0 - lb0)/s0 + 1) stop 113\n+      o0 = 1\n+      do i0 = lb0, ub0, s0\n+        if (rr(o0)%x .ne. i0) stop 114\n+        if (rr(o0)%y .ne. lb1) stop 114\n+\to0 = o0 + 1\n+      end do\n+    end if\n+  end subroutine\n+\n+end program\n+"}, {"sha": "9562b03d992bbc77f1314f7b86fc221fdd11fc9c", "filename": "gcc/testsuite/gfortran.dg/c-interop/section-3p.f90", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-3p.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-3p.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-3p.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,127 @@\n+! PR 101310\n+! { dg-do run }\n+! { dg-additional-sources \"section-3-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program tests basic use of the CFI_section C library function to\n+! take a slice of a 2-dimensional pointer array.\n+\n+module mm\n+  use ISO_C_BINDING\n+  type, bind (c) :: m\n+    integer(C_INT) :: x, y\n+  end type\n+end module\n+\n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  interface\n+    subroutine ctest (p, lb0, lb1, ub0, ub1, s0, s1, r) bind (c)\n+      use iso_c_binding\n+      use mm\n+      type(m), pointer :: p(:,:)\n+      integer(C_INT), value :: lb0, lb1, ub0, ub1, s0, s1\n+      type(m), pointer, intent(out) :: r(:)\n+    end subroutine\n+\n+  end interface\n+\n+  type(m), target :: aa(10, 20)\n+  integer :: i0, i1\n+\n+  ! Initialize the test array by numbering its elements.\n+  do i1 = 1, 20\n+    do i0 = 1, 10\n+      aa(i0, i1)%x = i0\n+      aa(i0, i1)%y = i1\n+    end do\n+  end do\n+\n+  ! Zero lower bound\n+  call test (aa, 0, 0, 2, 0, 2, 19, 0, 1)        ! full slice 0\n+  call test (aa, 0, 0, 0, 7, 9, 7, 1, 0)         ! full slice 1\n+  call test (aa, 0, 0, 2, 4, 2, 13, 0, 3)        ! partial slice 0\n+  call test (aa, 0, 0, 1, 7, 9, 7, 2, 0)         ! partial slice 1\n+  call test (aa, 0, 0, 2, 13, 2, 4, 0, -3)       ! backwards slice 0\n+  call test (aa, 0, 0, 9, 7, 1, 7, -2, 0)        ! backwards slice 1\n+\n+  ! Lower bound 1\n+  call test (aa, 1, 1, 3, 1, 3, 20, 0, 1)        ! full slice 0\n+  call test (aa, 1, 1, 1, 8, 10, 8, 1, 0)        ! full slice 1\n+  call test (aa, 1, 1, 3, 5, 3, 14, 0, 3)        ! partial slice 0\n+  call test (aa, 1, 1, 2, 8, 10, 8, 2, 0)        ! partial slice 1\n+  call test (aa, 1, 1, 3, 14, 3, 5, 0, -3)       ! backwards slice 0\n+  call test (aa, 1, 1, 10, 8, 2, 8, -2, 0)       ! backwards slice 1\n+\n+  ! Some other lower bound\n+  call test (aa, 2, 3, 4, 3, 4, 22, 0, 1)        ! full slice 0\n+  call test (aa, 2, 3, 2, 10, 11, 10, 1, 0)      ! full slice 1\n+  call test (aa, 2, 3, 4, 7, 4, 16, 0, 3)        ! partial slice 0\n+  call test (aa, 2, 3, 3, 10, 11, 10, 2, 0)      ! partial slice 1\n+  call test (aa, 2, 3, 4, 16, 4, 7, 0, -3)       ! backwards slice 0\n+  call test (aa, 2, 3, 11, 10, 3, 10, -2, 0)     ! backwards slice 1\n+\n+contains\n+\n+  subroutine test (aa, lo0, lo1, lb0, lb1, ub0, ub1, s0, s1)\n+    use mm\n+    type(m), target :: aa(10,20)\n+    integer :: lo0, lo1, lb0, lb1, ub0, ub1, s0, s1\n+\n+    type(m), pointer :: pp(:,:), rr(:)\n+    integer :: i0, i1, o0, o1\n+\n+    integer :: hi0, hi1\n+    hi0 = lo0 + 10 - 1\n+    hi1 = lo1 + 20 - 1\n+\n+    ! Check the bounds actually specify a \"slice\" rather than a subarray.\n+    if (lb0 .ne. ub0 .and. lb1 .ne. ub1)  stop 100\n+\n+    pp(lo0:,lo1:) => aa\n+    if (lbound (pp, 1) .ne. lo0) stop 121\n+    if (lbound (pp, 2) .ne. lo1) stop 121\n+    if (ubound (pp, 1) .ne. hi0) stop 122\n+    if (ubound (pp, 2) .ne. hi1) stop 122\n+    nullify (rr)\n+    call ctest (pp, lb0, lb1, ub0, ub1, s0, s1, rr)\n+\n+    ! Make sure the input pointer array has not been modified.\n+    if (lbound (pp, 1) .ne. lo0) stop 131\n+    if (ubound (pp, 1) .ne. hi0) stop 132\n+    if (lbound (pp, 2) .ne. lo1) stop 133\n+    if (ubound (pp, 2) .ne. hi1) stop 134\n+    do i1 = lo1, hi1\n+      do i0 = lo0, hi0\n+        if (pp(i0,i1)%x .ne. i0 - lo0 + 1) stop 135\n+        if (pp(i0,i1)%y .ne. i1 - lo1 + 1) stop 136\n+      end do\n+    end do\n+\n+    ! Make sure the output array has the expected bounds and elements.\n+    if (.not. associated (rr)) stop 111\n+    if (lbound (rr, 1) .ne. 1) stop 112\n+    if (ub0 .eq. lb0) then\n+      if (ubound (rr, 1) .ne. (ub1 - lb1)/s1 + 1) stop 113\n+      o1 = 1\n+      do i1 = lb1, ub1, s1\n+        if (rr(o1)%x .ne. lb0 - lo0 + 1) stop 114\n+        if (rr(o1)%y .ne. i1 - lo1 + 1) stop 114\n+\to1 = o1 + 1\n+      end do\n+    else\n+      if (ubound (rr, 1) .ne. (ub0 - lb0)/s0 + 1) stop 113\n+      o0 = 1\n+      do i0 = lb0, ub0, s0\n+        if (rr(o0)%x .ne. i0 - lo0 + 1) stop 114\n+        if (rr(o0)%y .ne. lb1 - lo1 + 1) stop 114\n+\to0 = o0 + 1\n+      end do\n+    end if\n+  end subroutine\n+\n+end program\n+"}, {"sha": "07248a5ebfee155fec038618b369fd2554356209", "filename": "gcc/testsuite/gfortran.dg/c-interop/section-4-c.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-4-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-4-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-4-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,101 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+struct m {\n+  int i, j, k, l;\n+};\n+\n+extern void ctest (void);\n+\n+#define IMAX 6\n+#define JMAX 8\n+#define KMAX 10\n+#define LMAX 12\n+\n+static struct m buffer[LMAX][KMAX][JMAX][IMAX];\n+\n+static void\n+check_element (struct m *mp, int i, int j, int k, int l)\n+{\n+#if 0\n+  fprintf (stderr, \"expected (%d, %d, %d, %d), got (%d, %d, %d, %d)\\n\",\n+\t   i, j, k, l, mp->i, mp->j, mp->k, mp->l);\n+#endif  \n+  if (mp->i != i || mp->j != j || mp->k != k || mp->l != l)\n+    abort ();\n+}\n+\n+void\n+ctest (void)\n+{\n+  CFI_CDESC_T(4) sdesc;\n+  CFI_cdesc_t *source = (CFI_cdesc_t *) &sdesc;\n+  CFI_CDESC_T(4) rdesc;\n+  CFI_cdesc_t *result = (CFI_cdesc_t *) &rdesc;\n+  CFI_index_t extents[4] = { IMAX, JMAX, KMAX, LMAX };\n+  CFI_index_t lb[4], ub[4], s[4];\n+  int i, j, k, l;\n+  int ii, jj, kk, ll;\n+\n+  /* Initialize the buffer to uniquely label each element.  */\n+  for (i = 0; i < IMAX; i++)\n+    for (j = 0; j < JMAX; j++)\n+      for (k = 0; k < KMAX; k++)\n+\tfor (l = 0; l < LMAX; l++)\n+\t  {\n+\t    buffer[l][k][j][i].i = i;\n+\t    buffer[l][k][j][i].j = j;\n+\t    buffer[l][k][j][i].k = k;\n+\t    buffer[l][k][j][i].l = l;\n+\t  }\n+\n+  /* Establish the source array.  */\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (source, (void *)buffer,\n+\t\t\t\t   CFI_attribute_pointer, CFI_type_struct,\n+\t\t\t\t   sizeof (struct m), 4, extents));\n+\n+  /* Try taking a degenerate section (single element).  */\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (result, NULL,\n+\t\t\t\t   CFI_attribute_pointer, CFI_type_struct,\n+\t\t\t\t   sizeof (struct m), 0, NULL));\n+  lb[0] = 3; lb[1] = 4; lb[2] = 5; lb[3] = 6;\n+  ub[0] = 3; ub[1] = 4; ub[2] = 5; ub[3] = 6;\n+  s[0] = 0; s[1] = 0; s[2] = 0; s[3] = 0;\n+  check_CFI_status (\"CFI_section\",\n+\t\t    CFI_section (result, source, lb, ub, s));\n+  dump_CFI_cdesc_t (result);\n+  check_element ((struct m *)result->base_addr, 3, 4, 5, 6);\n+\n+  /* Try taking a 2d chunk out of the 4d array.  */\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (result, NULL,\n+\t\t\t\t   CFI_attribute_pointer, CFI_type_struct,\n+\t\t\t\t   sizeof (struct m), 2, NULL));\n+  lb[0] = 1; lb[1] = 2; lb[2] = 3; lb[3] = 4;\n+  ub[0] = 1; ub[1] = JMAX - 2; ub[2] = 3; ub[3] = LMAX - 2;\n+  s[0] = 0; s[1] = 2; s[2] = 0; s[3] = 3;\n+  check_CFI_status (\"CFI_section\",\n+\t\t    CFI_section (result, source, lb, ub, s));\n+  dump_CFI_cdesc_t (result);\n+\n+  i = lb[0];\n+  k = lb[2];\n+  for (j = lb[1], jj = result->dim[0].lower_bound;\n+       j <= ub[1];\n+       j += s[1], jj++)\n+    for (l = lb[3], ll = result->dim[1].lower_bound;\n+\t l <= ub[3];\n+\t l += s[3], ll++)\n+      {\n+\tCFI_index_t subscripts[2];\n+\tsubscripts[0] = jj;\n+\tsubscripts[1] = ll;\n+\tcheck_element ((struct m *) CFI_address (result, subscripts),\n+\t\t       i, j, k, l);\n+      }\n+}"}, {"sha": "2300e6184f93fbed51159235f3b8927fdbc4c64b", "filename": "gcc/testsuite/gfortran.dg/c-interop/section-4.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-4.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,23 @@\n+! PR 101310\n+! { dg-do run }\n+! { dg-additional-sources \"section-4-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program tests various scenarios with using CFI_section to extract\n+! a section with rank less than the source array.  Everything interesting\n+! happens on the C side.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+    subroutine ctest () bind (c)\n+      use iso_c_binding\n+    end subroutine\n+\n+  end interface\n+\n+  call ctest ()\n+\n+end program"}, {"sha": "67be7d52121df26d441ff04723d3e0b05abea4f2", "filename": "gcc/testsuite/gfortran.dg/c-interop/section-errors-c.c", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-errors-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-errors-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-errors-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,149 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+/* For simplicity, point descriptors at a static buffer.  */\n+#define BUFSIZE 256\n+static char *buf[BUFSIZE] __attribute__ ((aligned (8)));\n+static CFI_index_t extents[] = {10};\n+\n+/* External entry point.  The arguments are descriptors for input arrays;\n+   we'll construct new descriptors for the outputs of CFI_section.  */\n+extern void ctest (void);\n+\n+void\n+ctest (void)\n+{\n+  int bad = 0;\n+  int status;\n+  CFI_CDESC_T(1) sdesc;\n+  CFI_cdesc_t *source = (CFI_cdesc_t *) &sdesc;\n+  CFI_CDESC_T(3) rdesc;\n+  CFI_cdesc_t *result = (CFI_cdesc_t *) &rdesc;\n+  CFI_index_t lb = 2;\n+  CFI_index_t ub = 8;\n+  CFI_index_t step = 2;\n+  CFI_index_t zstep = 0;\n+\n+  /* Use a 1-d integer source array for the first few tests.  */\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (source, (void *)buf, CFI_attribute_other,\n+\t\t\t\t   CFI_type_int, 0, 1, extents));\n+\n+  /* result shall be the address of a C descriptor with rank equal\n+     to the rank of source minus the number of zero strides.  */\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_int, 0, 0, NULL));\n+  status = CFI_section (result, source, &lb, &ub, &step);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for rank mismatch (too small)\\n\");\n+      bad ++;\n+    }\n+\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_int, 0, 1, NULL));\n+  status = CFI_section (result, source, &lb, &lb, &zstep);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for rank mismatch (zero stride)\\n\");\n+      bad ++;\n+    }\n+\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_int, 0, 3, NULL));\n+  status = CFI_section (result, source, &lb, &ub, &step);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for rank mismatch (too large)\\n\");\n+      bad ++;\n+    }\n+\n+  /* The attribute member [of result] shall have the value\n+     CFI_attribute_other or CFI_attribute_pointer.  */\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_allocatable,\n+\t\t\t\t   CFI_type_int, 0, 1, NULL));\n+  status = CFI_section (result, source, &lb, &ub, &step);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for CFI_attribute_allocatable result\\n\");\n+      bad ++;\n+    }\n+\n+  /* source shall be the address of a C descriptor that describes a\n+     nonallocatable nonpointer array, an allocated allocatable array,\n+     or an associated array pointer.  */\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (source, NULL, CFI_attribute_allocatable,\n+\t\t\t\t   CFI_type_int, 0, 1, NULL));\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_int, 0, 1, NULL));\n+  status = CFI_section (result, source, &lb, &ub, &step);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for unallocated allocatable source array\\n\");\n+      bad ++;\n+    }\n+\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (source, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_int, 0, 1, NULL));\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_int, 0, 1, NULL));\n+  status = CFI_section (result, source, &lb, &ub, &step);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for unassociated pointer source array\\n\");\n+      bad ++;\n+    }\n+\n+  /* The corresponding values of the elem_len and type members shall\n+     be the same in the C descriptors with the addresses source\n+     and result.  */\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (source, (void *)buf, CFI_attribute_other,\n+\t\t\t\t   CFI_type_struct,\n+\t\t\t\t   sizeof(int), 1, extents));\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_struct,\n+\t\t\t\t   2*sizeof (int), 1, NULL));\n+  status = CFI_section (result, source, &lb, &ub, &step);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for elem_len mismatch\\n\");\n+      bad ++;\n+    }\n+\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_int, 0, 1, NULL));\n+  status = CFI_section (result, source, &lb, &ub, &step);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for type mismatch\\n\");\n+      bad ++;\n+    }\n+\n+  if (bad)\n+    abort ();\n+}\n+"}, {"sha": "28328b799b309e1bf33d0b3ef1619e3be26a9d4d", "filename": "gcc/testsuite/gfortran.dg/c-interop/section-errors.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-errors.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-errors.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsection-errors.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do run }\n+! { dg-additional-sources \"section-errors-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-Wno-error -fcheck=all\" }\n+! { dg-warning \"command-line option '-fcheck=all' is valid for Fortran but not for C\" \"\" { target *-*-* } 0 }\n+!\n+! This program tests that the CFI_section function properly detects\n+! invalid arguments.  All the interesting things happen in the \n+! corresponding C code.\n+!\n+! The situation here seems to be that while TS29113 defines error codes\n+! for CFI_section, it doesn't actually require the implementation to detect\n+! those errors by saying the arguments \"shall be\" such-and-such, e.g. it is\n+! undefined behavior if they are not.  In gfortran you can enable some\n+! run-time checking by building with -fcheck=all.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+    subroutine ctest () bind (c)\n+    end subroutine\n+  end interface\n+\n+  call ctest ()\n+\n+end program"}, {"sha": "663ac0d34b33cf611d77beb8b39a0cb43415c644", "filename": "gcc/testsuite/gfortran.dg/c-interop/select-c.c", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fselect-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fselect-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fselect-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,138 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+/* Declare some source arrays.  */\n+struct ss {\n+  char c[4];\n+  signed char b[4];\n+  int i, j, k;\n+} s[10][5][3];\n+\n+char c[10][16];\n+\n+double _Complex dc[10];\n+\n+CFI_index_t extents3[] = {3,5,10};\n+CFI_index_t extents1[] = {10};\n+\n+/* External entry point.  */\n+extern void ctest (void);\n+\n+void\n+ctest (void)\n+{\n+  CFI_CDESC_T(3) sdesc;\n+  CFI_cdesc_t *source = (CFI_cdesc_t *) &sdesc;\n+  CFI_CDESC_T(3) rdesc;\n+  CFI_cdesc_t *result = (CFI_cdesc_t *) &rdesc;\n+  size_t offset;\n+\n+  /* Extract an array of structure elements.  */\n+  offset = offsetof (struct ss, j);\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (source, (void *)s, CFI_attribute_other,\n+\t\t\t\t   CFI_type_struct,\n+\t\t\t\t   sizeof (struct ss), 3, extents3));\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_int, 0, 3, NULL));\n+  check_CFI_status (\"CFI_select_part\",\n+\t\t    CFI_select_part (result, source, offset, 0));\n+  dump_CFI_cdesc_t (source);\n+  dump_CFI_cdesc_t (result);\n+\n+  if (result->elem_len != sizeof (int))\n+    abort ();\n+  if (result->base_addr != source->base_addr + offset)\n+    abort ();\n+  if (result->dim[0].extent != source->dim[0].extent)\n+    abort ();\n+  if (result->dim[0].sm != source->dim[0].sm)\n+    abort ();\n+  if (result->dim[1].extent != source->dim[1].extent)\n+    abort ();\n+  if (result->dim[1].sm != source->dim[1].sm)\n+    abort ();\n+  if (result->dim[2].extent != source->dim[2].extent)\n+    abort ();\n+  if (result->dim[2].sm != source->dim[2].sm)\n+    abort ();\n+\n+  /* Check that we use the given elem_size for char but not for\n+     signed char, which is considered an integer type instead of a Fortran\n+     character type.  */\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_char, 4, 3, NULL));\n+  if (result->elem_len != 4)\n+    abort ();\n+  offset = offsetof (struct ss, c);\n+  check_CFI_status (\"CFI_select_part\",\n+\t\t    CFI_select_part (result, source, offset, 4));\n+  if (result->elem_len != 4)\n+    abort ();\n+\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_signed_char, 4, 3, NULL));\n+  if (result->elem_len != sizeof (signed char))\n+    abort ();\n+  offset = offsetof (struct ss, c);\n+  check_CFI_status (\"CFI_select_part\",\n+\t\t    CFI_select_part (result, source, offset, 4));\n+  if (result->elem_len != sizeof (signed char))\n+    abort ();\n+\n+  /* Extract an array of character substrings.  */\n+  offset = 2;\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (source, (void *)c, CFI_attribute_other,\n+\t\t\t\t   CFI_type_char, 16, 1, extents1));\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_char, 8, 1, NULL));\n+  check_CFI_status (\"CFI_select_part\",\n+\t\t    CFI_select_part (result, source, offset, 8));\n+  dump_CFI_cdesc_t (source);\n+  dump_CFI_cdesc_t (result);\n+\n+  if (result->elem_len != 8)\n+    abort ();\n+  if (result->base_addr != source->base_addr + offset)\n+    abort ();\n+  if (result->dim[0].extent != source->dim[0].extent)\n+    abort ();\n+  if (result->dim[0].sm != source->dim[0].sm)\n+    abort ();\n+\n+  /* Extract an array the imaginary parts of complex numbers.\n+     Note that the use of __imag__ to obtain the imaginary part as\n+     an lvalue is a GCC extension.  */\n+  offset = (void *)&(__imag__ dc[0]) - (void *)&(dc[0]);\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (source, (void *)dc, CFI_attribute_other,\n+\t\t\t\t   CFI_type_double_Complex,\n+\t\t\t\t   0, 1, extents1));\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_double, 0, 1, NULL));\n+  check_CFI_status (\"CFI_select_part\",\n+\t\t    CFI_select_part (result, source, offset, 0));\n+  dump_CFI_cdesc_t (source);\n+  dump_CFI_cdesc_t (result);\n+\n+  if (result->elem_len != sizeof (double))\n+    abort ();\n+  if (result->base_addr != source->base_addr + offset)\n+    abort ();\n+  if (result->dim[0].extent != source->dim[0].extent)\n+    abort ();\n+  if (result->dim[0].sm != source->dim[0].sm)\n+    abort ();\n+}\n+"}, {"sha": "7eb815ea31bd2da1914ef0fcf891e10b640f6dc6", "filename": "gcc/testsuite/gfortran.dg/c-interop/select-errors-c.c", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fselect-errors-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fselect-errors-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fselect-errors-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,125 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+/* Source is an array of structs.  */\n+struct ss {\n+  int i, j;\n+  char c[16];\n+  double _Complex dc;\n+} s[10];\n+\n+CFI_index_t extents[] = {10};\n+\n+/* External entry point.  */\n+extern void ctest (void);\n+\n+void\n+ctest (void)\n+{\n+  int bad = 0;\n+  int status;\n+  CFI_CDESC_T(1) sdesc;\n+  CFI_cdesc_t *source = (CFI_cdesc_t *) &sdesc;\n+  CFI_CDESC_T(3) rdesc;\n+  CFI_cdesc_t *result = (CFI_cdesc_t *) &rdesc;\n+\n+  /* Create a descriptor for the source array.  */\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (source, (void *)s, CFI_attribute_other,\n+\t\t\t\t   CFI_type_struct,\n+\t\t\t\t   sizeof (struct ss), 1, extents));\n+\n+  /* The attribute member of result shall have the value\n+     CFI_attribute_other or CFI_attribute_pointer.  */\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_allocatable,\n+\t\t\t\t   CFI_type_int, 0, 1, NULL));\n+  status = CFI_select_part (result, source, offsetof (struct ss, j), 0);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for CFI_attribute_allocatable result\\n\");\n+      bad ++;\n+    }\n+\n+  /* The rank member of the result C descriptor shall have the same value\n+     as the rank member of the C descriptor at the address specified\n+     by source.  */\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_int, 0, 0, NULL));\n+  status = CFI_select_part (result, source, offsetof (struct ss, j), 0);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for rank mismatch (too small)\\n\");\n+      bad ++;\n+    }\n+\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_int, 0, 3, NULL));\n+  status = CFI_select_part (result, source, offsetof (struct ss, j), 0);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for rank mismatch (too large)\\n\");\n+      bad ++;\n+    }\n+\n+  /* The value of displacement shall be between 0 and source->elem_len - 1\n+     inclusive. */\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_int, 0, 1, NULL));\n+  status = CFI_select_part (result, source, -8, 0);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for negative displacement\\n\");\n+      bad ++;\n+    }\n+  status = CFI_select_part (result, source, source->elem_len, 0);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for too-large displacement\\n\");\n+      bad ++;\n+    }\n+\n+  /* source shall be the address of a C descriptor for a nonallocatable\n+     nonpointer array, an allocated allocatable array, or an associated\n+     array pointer.  */\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (source, NULL, CFI_attribute_allocatable,\n+\t\t\t\t   CFI_type_struct,\n+\t\t\t\t   sizeof (struct ss), 1, NULL));\n+  status = CFI_select_part (result, source, offsetof (struct ss, j), 0);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for unallocated allocatable source array\\n\");\n+      bad ++;\n+    }\n+\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (source, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_struct,\n+\t\t\t\t   sizeof (struct ss), 1, NULL));\n+  status = CFI_select_part (result, source, offsetof (struct ss, j), 0);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for unassociated pointer source array\\n\");\n+      bad ++;\n+    }\n+\n+  if (bad)\n+    abort ();\n+}\n+"}, {"sha": "b719c9e68679a0ea7f006161fef444455c9d4e32", "filename": "gcc/testsuite/gfortran.dg/c-interop/select-errors.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fselect-errors.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fselect-errors.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fselect-errors.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do run }\n+! { dg-additional-sources \"select-errors-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-Wno-error -fcheck=all\" }\n+! { dg-warning \"command-line option '-fcheck=all' is valid for Fortran but not for C\" \"\" { target *-*-* } 0 }\n+!\n+! This program tests that the CFI_select_part function properly detects\n+! invalid arguments.  All the interesting things happen in the \n+! corresponding C code.\n+!\n+! The situation here seems to be that while TS29113 defines error codes for\n+! CFI_select_part, it doesn't actually require the implementation to detect\n+! those errors by saying the arguments \"shall be\" such-and-such, e.g. it is\n+! undefined behavior if they are not.  In gfortran you can enable some\n+! run-time checking by building with -fcheck=all.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+    subroutine ctest () bind (c)\n+    end subroutine\n+  end interface\n+\n+  call ctest ()\n+\n+end program"}, {"sha": "133385e3c1f0dfc2f40f96913e0e107387028e44", "filename": "gcc/testsuite/gfortran.dg/c-interop/select.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fselect.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fselect.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fselect.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do run }\n+! { dg-additional-sources \"select-c.c dump-descriptors.c\" }\n+!\n+! This program tests the CFI_select_part function.  All the interesting\n+! things happen in the corresponding C code.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+    subroutine ctest () bind (c)\n+    end subroutine\n+  end interface\n+\n+  call ctest ()\n+\n+end program"}, {"sha": "249cb2bcd87cf04b38702692153e9d5d60deedab", "filename": "gcc/testsuite/gfortran.dg/c-interop/setpointer-c.c", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsetpointer-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsetpointer-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsetpointer-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,78 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+static int a[10][5][3];\n+static CFI_index_t extents[] = {3, 5, 10};\n+static CFI_index_t lb1[] = {1, 2, 3};\n+static CFI_index_t lb2[] = {0, 1, -10};\n+\n+/* External entry point.  */\n+extern void ctest (void);\n+\n+void\n+ctest (void)\n+{\n+  CFI_CDESC_T(3) sdesc;\n+  CFI_cdesc_t *source = (CFI_cdesc_t *) &sdesc;\n+  CFI_CDESC_T(3) rdesc;\n+  CFI_cdesc_t *result = (CFI_cdesc_t *) &rdesc;\n+\n+  /* Create descriptors.  */\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (source, (void *)a, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_int, 0, 3, extents));\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_int, 0, 3, NULL));\n+\n+  /* Use setpointer to adjust the bounds of source in place.  */\n+  check_CFI_status (\"CFI_setpointer\",\n+\t\t    CFI_setpointer (source, source, lb1));\n+  dump_CFI_cdesc_t (source);\n+  if (source->dim[0].lower_bound != lb1[0])\n+    abort ();\n+  if (source->dim[1].lower_bound != lb1[1])\n+    abort ();\n+  if (source->dim[2].lower_bound != lb1[2])\n+    abort ();\n+\n+  /* Use setpointer to copy the pointer and bounds from source.  */\n+  check_CFI_status (\"CFI_setpointer\",\n+\t\t    CFI_setpointer (result, source, NULL));\n+  dump_CFI_cdesc_t (result);\n+  if (result->base_addr != source->base_addr)\n+    abort ();\n+  if (result->dim[0].lower_bound != source->dim[0].lower_bound)\n+    abort ();\n+  if (result->dim[1].lower_bound != source->dim[1].lower_bound)\n+    abort ();\n+  if (result->dim[2].lower_bound != source->dim[2].lower_bound)\n+    abort ();\n+\n+  /* Use setpointer to nullify result.  */\n+  check_CFI_status (\"CFI_setpointer\",\n+\t\t    CFI_setpointer (result, NULL, NULL));\n+  dump_CFI_cdesc_t (result);\n+  if (result->base_addr)\n+    abort ();\n+\n+  /* Use setpointer to copy the pointer from source, but use\n+     different bounds.  */\n+  check_CFI_status (\"CFI_setpointer\",\n+\t\t    CFI_setpointer (result, source, lb2));\n+  dump_CFI_cdesc_t (source);\n+  if (result->base_addr != source->base_addr)\n+    abort ();\n+  if (result->dim[0].lower_bound != lb2[0])\n+    abort ();\n+  if (result->dim[1].lower_bound != lb2[1])\n+    abort ();\n+  if (result->dim[2].lower_bound != lb2[2])\n+    abort ();\n+}\n+"}, {"sha": "7931e1ebf5126ee0ef15865f9b3a0f0338d27940", "filename": "gcc/testsuite/gfortran.dg/c-interop/setpointer-errors-c.c", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsetpointer-errors-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsetpointer-errors-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsetpointer-errors-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,127 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+static int a[10][5][3];\n+static CFI_index_t extents[] = {3, 5, 10};\n+\n+/* External entry point.  */\n+extern void ctest (void);\n+\n+void\n+ctest (void)\n+{\n+  int bad = 0;\n+  int status;\n+  CFI_CDESC_T(3) sdesc;\n+  CFI_cdesc_t *source = (CFI_cdesc_t *) &sdesc;\n+  CFI_CDESC_T(3) rdesc;\n+  CFI_cdesc_t *result = (CFI_cdesc_t *) &rdesc;\n+\n+  /* result shall be the address of a C descriptor for a Fortran pointer.  */\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (source, (void *)a, CFI_attribute_other,\n+\t\t\t\t   CFI_type_int, 0, 3, extents));\n+\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_allocatable,\n+\t\t\t\t   CFI_type_int, 0, 3, NULL));\n+  status = CFI_setpointer (result, source, NULL);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for CFI_attribute_allocatable result\\n\");\n+      bad ++;\n+    }\n+\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_other,\n+\t\t\t\t   CFI_type_int, 0, 3, NULL));\n+  status = CFI_setpointer (result, source, NULL);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for CFI_attribute_other result\\n\");\n+      bad ++;\n+    }\n+\n+  /* source shall be a null pointer or the address of a C descriptor\n+     for an allocated allocatable object, a data pointer object, or a\n+     nonallocatable nonpointer data object that is not an\n+     assumed-size array.  */\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_int, 0, 3, NULL));\n+\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (source, NULL, CFI_attribute_allocatable,\n+\t\t\t\t   CFI_type_int, 0, 3, NULL));\n+  status = CFI_setpointer (result, source, NULL);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for unallocated allocatable source\\n\");\n+      bad ++;\n+    }\n+\n+  /* CFI_establish rejects negative extents, so we can't use it to make\n+     an assumed-size array, so hack the descriptor by hand.  Yuck.  */\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (source, (void *)a, CFI_attribute_other,\n+\t\t\t\t   CFI_type_int, 0, 3, extents));\n+  source->dim[2].extent = -1;\n+  status = CFI_setpointer (result, source, NULL);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for assumed-size source array\\n\");\n+      bad ++;\n+    }\n+  \n+  /* If source is not a null pointer, the corresponding values of the\n+     elem_len, rank, and type members shall be the same in the C\n+     descriptors with the addresses source and result.  */\n+  check_CFI_status (\"CFI_establish\",\n+\t\t    CFI_establish (source, (void *)a, CFI_attribute_other,\n+\t\t\t\t   CFI_type_char, sizeof(int), 3, extents));\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_char, 1, 3, NULL));\n+  status = CFI_setpointer (result, source, NULL);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for elem_len mismatch\\n\");\n+      bad ++;\n+    }\n+\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_char, sizeof(int), 1, NULL));\n+  status = CFI_setpointer (result, source, NULL);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for rank mismatch\\n\");\n+      bad ++;\n+    }\n+\n+  check_CFI_status (\"CFI_establish\", \n+\t\t    CFI_establish (result, NULL, CFI_attribute_pointer,\n+\t\t\t\t   CFI_type_int, 0, 3, NULL));\n+  status = CFI_setpointer (result, source, NULL);\n+  if (status == CFI_SUCCESS)\n+    {\n+      fprintf (stderr,\n+\t       \"no error for type mismatch\\n\");\n+      bad ++;\n+    }\n+\n+  if (bad)\n+    abort ();\n+}\n+"}, {"sha": "84a01ce16b120d0547f731adc1224b1a416a7377", "filename": "gcc/testsuite/gfortran.dg/c-interop/setpointer-errors.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsetpointer-errors.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsetpointer-errors.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsetpointer-errors.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,28 @@\n+! PR 101317\n+! { dg-do run }\n+! { dg-additional-sources \"setpointer-errors-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-Wno-error -fcheck=all\" }\n+! { dg-warning \"command-line option '-fcheck=all' is valid for Fortran but not for C\" \"\" { target *-*-* } 0 }\n+!\n+! This program tests that the CFI_setpointer function properly detects\n+! invalid arguments.  All the interesting things happen in the \n+! corresponding C code.\n+!\n+! The situation here seems to be that while TS29113 defines error codes for\n+! CFI_setpointer, it doesn't actually require the implementation to detect\n+! those errors by saying the arguments \"shall be\" such-and-such, e.g. it is\n+! undefined behavior if they are not.  In gfortran you can enable some\n+! run-time checking by building with -fcheck=all.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+    subroutine ctest () bind (c)\n+    end subroutine\n+  end interface\n+\n+  call ctest ()\n+\n+end program"}, {"sha": "57ef183df32a60bb8fa37cdd1e1db397b612ec55", "filename": "gcc/testsuite/gfortran.dg/c-interop/setpointer.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsetpointer.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsetpointer.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsetpointer.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do run }\n+! { dg-additional-sources \"setpointer-c.c dump-descriptors.c\" }\n+!\n+! This program tests the CFI_setpointer function.  All the interesting\n+! things happen in the corresponding C code.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+    subroutine ctest () bind (c)\n+    end subroutine\n+  end interface\n+\n+  call ctest ()\n+\n+end program"}, {"sha": "dd790bbca90435efd3ea0bcd533f6f6db3d32700", "filename": "gcc/testsuite/gfortran.dg/c-interop/shape.f90", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fshape.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fshape.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fshape.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,77 @@\n+! { dg-do run }\n+!\n+! TS 29113\n+! 6.4.1  SHAPE\n+!\n+! The description of the intrinsic function SHAPE in ISO/IEC 1539-1:2010\n+! is changed for an assumed-rank array that is associated with an\n+! assumed-size array; an assumed-size array has no shape, but in this\n+! case the result has a value equal to \n+! [ (SIZE (ARRAY, I, KIND), I=1,RANK (ARRAY)) ] \n+! with KIND omitted from SIZE if it was omitted from SHAPE.\n+!\n+! The idea here is that the main program passes some arrays to a test\n+! subroutine with an assumed-size dummy, which in turn passes that to a\n+! subroutine with an assumed-rank dummy.\n+\n+program test \n+\n+  ! Define some arrays for testing.\n+  integer, target :: x1(5)\n+  integer :: y1(0:9)\n+  integer, pointer :: p1(:)\n+  integer, allocatable :: a1(:)\n+  integer, target :: x3(2,3,4)\n+  integer :: y3(0:1,-3:-1,4)\n+  integer, pointer :: p3(:,:,:)\n+  integer, allocatable :: a3(:,:,:)\n+\n+  ! Test the 1-dimensional arrays.\n+  call test1 (x1)\n+  call test1 (y1)\n+  p1 => x1\n+  call test1 (p1)\n+  allocate (a1(5))\n+  call test1 (a1)\n+\n+  ! Test the multi-dimensional arrays.\n+  call test3 (x3, 1, 2, 1, 3)\n+  call test3 (y3, 0, 1, -3, -1)\n+  p3 => x3\n+  call test3 (p3, 1, 2, 1, 3)\n+  allocate (a3(2,3,4))\n+  call test3 (a3, 1, 2, 1, 3)\n+\n+contains\n+\n+  subroutine testit (a)\n+    integer :: a(..)\n+    \n+    integer :: r\n+    r = rank(a)\n+\n+    block\n+      integer :: s(r)\n+      s = shape(a)\n+      do i = 1, r\n+        if (s(i) .ne. size(a,i)) stop 101\n+      end do\n+    end block\n+\n+  end subroutine\n+\n+  subroutine test1 (a)\n+    integer :: a(*)\n+\n+    call testit (a)\n+  end subroutine\n+\n+  subroutine test3 (a, l1, u1, l2, u2)\n+    implicit none\n+    integer :: l1, u1, l2, u2\n+    integer :: a(l1:u1, l2:u2, *)\n+\n+    call testit (a)\n+  end subroutine\n+\n+end program"}, {"sha": "6c6699701bfcb72edd4cec821aa0750c719e61c3", "filename": "gcc/testsuite/gfortran.dg/c-interop/size.f90", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsize.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsize.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsize.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,106 @@\n+! Reported as pr94070.\n+! { dg-do run { xfail *-*-* } }\n+!\n+! TS 29113\n+! 6.4.2 SIZE\n+!\n+! The description of the intrinsic function SIZE in ISO/IEC 1539-1:2010\n+! is changed in the following cases:\n+!\n+! (1) for an assumed-rank object that is associated with an assumed-size\n+! array, the result has the value \u22121 if DIM is present and equal to the\n+! rank of ARRAY, and a negative value that is equal to \n+! PRODUCT ( [ (SIZE (ARRAY, I, KIND), I=1, RANK (ARRAY)) ] ) \n+! if DIM is not present;\n+!\n+! (2) for an assumed-rank object that is associated with a scalar, the\n+! result has the value 1.\n+!\n+! The idea here is that the main program passes some arrays to a test\n+! subroutine with an assumed-size dummy, which in turn passes that to a\n+! subroutine with an assumed-rank dummy.\n+\n+program test \n+\n+  ! Define some arrays for testing.\n+  integer, target :: x1(5)\n+  integer :: y1(0:9)\n+  integer, pointer :: p1(:)\n+  integer, allocatable :: a1(:)\n+  integer, target :: x3(2,3,4)\n+  integer :: y3(0:1,-3:-1,4)\n+  integer, pointer :: p3(:,:,:)\n+  integer, allocatable :: a3(:,:,:)\n+  integer :: x\n+\n+  ! Test the 1-dimensional arrays.\n+  call test1 (x1)\n+  call test1 (y1)\n+  p1 => x1\n+  call test1 (p1)\n+  allocate (a1(5))\n+  call test1 (a1)\n+\n+  ! Test the multi-dimensional arrays.\n+  call test3 (x3, 1, 2, 1, 3)\n+  call test3 (y3, 0, 1, -3, -1)\n+  p3 => x3\n+  call test3 (p3, 1, 2, 1, 3)\n+  allocate (a3(2,3,4))\n+  call test3 (a3, 1, 2, 1, 3)\n+\n+  ! Test scalars.\n+  call test0 (x)\n+  call test0 (-1)\n+  call test0 (x1(1))\n+\n+contains\n+\n+  subroutine testit (a, r, sizes)\n+    integer :: a(..)\n+    integer :: r\n+    integer :: sizes(r)\n+    \n+    integer :: totalsize, thissize\n+    totalsize = 1\n+\n+    if (r .ne. rank(a))  stop 101\n+\n+    do i = 1, r\n+      thissize = size (a, i)\n+      print *, 'got size ', thissize, ' expected ', sizes(i)\n+      if (thissize .ne. sizes(i)) stop 102\n+      totalsize = totalsize * thissize\n+    end do\n+\n+    if (size(a) .ne. totalsize) stop 103\n+  end subroutine\n+\n+  subroutine test0 (a)\n+    integer :: a(..)\n+\n+    if (size (a) .ne. 1) stop 103\n+  end subroutine\n+\n+  subroutine test1 (a)\n+    integer :: a(*)\n+\n+    integer :: sizes(1)\n+    sizes(1) = -1\n+    call testit (a, 1, sizes)\n+  end subroutine\n+\n+  subroutine test3 (a, l1, u1, l2, u2)\n+    implicit none\n+    integer :: l1, u1, l2, u2\n+    integer :: a(l1:u1, l2:u2, *)\n+\n+    integer :: sizes(3)\n+    sizes(1) = u1 - l1 + 1\n+    sizes(2) = u2 - l2 + 1\n+    sizes(3) = -1\n+\n+    call testit (a, 3, sizes)\n+  end subroutine\n+\n+end program"}, {"sha": "c0c0d7e86f833c587733ef38550031ca76147e29", "filename": "gcc/testsuite/gfortran.dg/c-interop/tkr.f90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftkr.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftkr.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftkr.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,46 @@\n+! { dg-do compile}\n+!\n+! TS 29113\n+! The definition of TKR compatible in paragraph 2 of subclause 12.4.3.4.5 \n+! of ISO/IEC 1539-1:2010 is changed to:\n+!\n+! A dummy argument is type, kind, and rank compatible, or TKR compatible, \n+! with another dummy argument if the first is type compatible with the \n+! second, the kind type parameters of the first have the same values as \n+! the corresponding kind type parameters of the second, and both have the\n+! same rank or either is assumed-rank.\n+!\n+! This test file contains tests that are expected to issue diagnostics\n+! for invalid code.\n+\n+module m\n+\n+interface foo\n+  subroutine foo_1 (x)  ! { dg-error \"Ambiguous interfaces\" }\n+    integer :: x(..)\n+  end subroutine\n+  subroutine foo_2 (x)  ! { dg-error \"Ambiguous interfaces\" }\n+    integer :: x(:, :)\n+  end subroutine\n+end interface\n+\n+interface bar\n+  subroutine bar_1 (x)  ! { dg-error \"Ambiguous interfaces\" }\n+    integer :: x(..)\n+  end subroutine\n+  subroutine bar_2 (x)  ! { dg-error \"Ambiguous interfaces\" }\n+    integer :: x(..)\n+  end subroutine\n+end interface\n+\n+interface baz\n+  subroutine baz_1 (x)  ! { dg-error \"Ambiguous interfaces\" }\n+    integer :: x\n+  end subroutine\n+  subroutine baz_2 (x)  ! { dg-error \"Ambiguous interfaces\" }\n+    integer :: x(..)\n+  end subroutine\n+end interface\n+\n+end module\n+"}, {"sha": "34bf218b2b2e378759cddae5437afcc0b4267045", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-array-basic-c.c", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-basic-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-basic-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-basic-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,169 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest_int1 (CFI_cdesc_t *arg_int,\n+\t\t\tCFI_cdesc_t *arg_short,\n+\t\t\tCFI_cdesc_t *arg_long,\n+\t\t\tCFI_cdesc_t *arg_long_long,\n+\t\t\tCFI_cdesc_t *arg_signed_char);\n+\n+extern void ctest_int2 (CFI_cdesc_t *arg_int8,\n+\t\t\tCFI_cdesc_t *arg_int16,\n+\t\t\tCFI_cdesc_t *arg_int32,\n+\t\t\tCFI_cdesc_t *arg_int64);\n+\n+extern void ctest_int3 (CFI_cdesc_t *arg_least8,\n+\t\t\tCFI_cdesc_t *arg_least16,\n+\t\t\tCFI_cdesc_t *arg_least32,\n+\t\t\tCFI_cdesc_t *arg_least64);\n+\n+extern void ctest_int4 (CFI_cdesc_t *arg_fast8,\n+\t\t\tCFI_cdesc_t *arg_fast16,\n+\t\t\tCFI_cdesc_t *arg_fast32,\n+\t\t\tCFI_cdesc_t *arg_fast64);\n+\n+extern void ctest_int5 (CFI_cdesc_t *arg_size,\n+\t\t\tCFI_cdesc_t *arg_intmax,\n+\t\t\tCFI_cdesc_t *arg_intptr,\n+\t\t\tCFI_cdesc_t *arg_ptrdiff);\n+\n+extern void ctest_real (CFI_cdesc_t *arg_float,\n+\t\t\tCFI_cdesc_t *arg_double);\n+\n+extern void ctest_complex (CFI_cdesc_t *arg_float_complex,\n+\t\t\t   CFI_cdesc_t *arg_double_complex);\n+\n+extern void ctest_misc (CFI_cdesc_t *arg_bool,\n+\t\t\tCFI_cdesc_t *arg_cptr,\n+\t\t\tCFI_cdesc_t *arg_cfunptr,\n+\t\t\tCFI_cdesc_t *arg_struct);\n+\n+/* Sanity check the type info in the descriptor a.  */\n+\n+static void\n+check (CFI_cdesc_t *a, size_t size, int typecode)\n+{\n+  dump_CFI_cdesc_t (a);\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+  if (a->base_addr == NULL)\n+    abort ();\n+  if (a->rank != 1)\n+    abort ();\n+  if (size && a->elem_len != size)\n+    abort ();\n+  if (a->type != typecode)\n+    abort ();\n+}\n+\n+\n+/* Test that the basic integer types correspond correctly.  */\n+void\n+ctest_int1 (CFI_cdesc_t *arg_int,\n+\t    CFI_cdesc_t *arg_short,\n+\t    CFI_cdesc_t *arg_long,\n+\t    CFI_cdesc_t *arg_long_long,\n+\t    CFI_cdesc_t *arg_signed_char)\n+{\n+  check (arg_int, sizeof (int), CFI_type_int);\n+  check (arg_short, sizeof (short), CFI_type_short);\n+  check (arg_long, sizeof (long), CFI_type_long);\n+  check (arg_long_long, sizeof (long long int), CFI_type_long_long);\n+  check (arg_signed_char, sizeof (signed char), CFI_type_signed_char);\n+}\n+\n+/* Test the integer types of explicit sizes.  */\n+void\n+ctest_int2 (CFI_cdesc_t *arg_int8,\n+\t    CFI_cdesc_t *arg_int16,\n+\t    CFI_cdesc_t *arg_int32,\n+\t    CFI_cdesc_t *arg_int64)\n+{\n+  check (arg_int8, sizeof (int8_t), CFI_type_int8_t);\n+  check (arg_int16, sizeof (int16_t), CFI_type_int16_t);\n+  check (arg_int32, sizeof (int32_t), CFI_type_int32_t);\n+  check (arg_int64, sizeof (int64_t), CFI_type_int64_t);\n+}\n+\n+/* Check the int_least*_t types.  */\n+\n+void\n+ctest_int3 (CFI_cdesc_t *arg_least8,\n+\t    CFI_cdesc_t *arg_least16,\n+\t    CFI_cdesc_t *arg_least32,\n+\t    CFI_cdesc_t *arg_least64)\n+{\n+  check (arg_least8, sizeof (int_least8_t), CFI_type_int_least8_t);\n+  check (arg_least16, sizeof (int_least16_t), CFI_type_int_least16_t);\n+  check (arg_least32, sizeof (int_least32_t), CFI_type_int_least32_t);\n+  check (arg_least64, sizeof (int_least64_t), CFI_type_int_least64_t);\n+}\n+\n+/* Check the int_fast*_t types.  */\n+void\n+ctest_int4 (CFI_cdesc_t *arg_fast8,\n+\t    CFI_cdesc_t *arg_fast16,\n+\t    CFI_cdesc_t *arg_fast32,\n+\t    CFI_cdesc_t *arg_fast64)\n+{\n+  check (arg_fast8, sizeof (int_fast8_t), CFI_type_int_fast8_t);\n+  check (arg_fast16, sizeof (int_fast16_t), CFI_type_int_fast16_t);\n+  check (arg_fast32, sizeof (int_fast32_t), CFI_type_int_fast32_t);\n+  check (arg_fast64, sizeof (int_fast64_t), CFI_type_int_fast64_t);\n+}\n+\n+/* Check the \"purposeful\" integer types.  */\n+void\n+ctest_int5 (CFI_cdesc_t *arg_size,\n+\t    CFI_cdesc_t *arg_intmax,\n+\t    CFI_cdesc_t *arg_intptr,\n+\t    CFI_cdesc_t *arg_ptrdiff)\n+{\n+  check (arg_size, sizeof (size_t), CFI_type_size_t);\n+  check (arg_intmax, sizeof (intmax_t), CFI_type_intmax_t);\n+  check (arg_intptr, sizeof (intptr_t), CFI_type_intptr_t);\n+  check (arg_ptrdiff, sizeof (ptrdiff_t), CFI_type_ptrdiff_t);\n+}\n+\n+/* Check the floating-point types.  */\n+void\n+ctest_real (CFI_cdesc_t *arg_float,\n+\t    CFI_cdesc_t *arg_double)\n+{\n+  check (arg_float, sizeof (float), CFI_type_float);\n+  check (arg_double, sizeof (double), CFI_type_double);\n+}\n+\n+/* Likewise for the complex types.  */\n+void\n+ctest_complex (CFI_cdesc_t *arg_float_complex,\n+\t       CFI_cdesc_t *arg_double_complex)\n+{\n+  check (arg_float_complex, sizeof (float _Complex),\n+\t CFI_type_float_Complex);\n+  check (arg_double_complex, sizeof (double _Complex),\n+\t CFI_type_double_Complex);\n+}\n+\n+/* Misc types.  */\n+void\n+ctest_misc (CFI_cdesc_t *arg_bool,\n+\t    CFI_cdesc_t *arg_cptr,\n+\t    CFI_cdesc_t *arg_cfunptr,\n+\t    CFI_cdesc_t *arg_struct)\n+{\n+  struct m\n+  {\n+    int i, j;\n+  };\n+\n+  check (arg_bool, sizeof (_Bool), CFI_type_Bool);\n+  check (arg_cptr, sizeof (void *), CFI_type_cptr);\n+  check (arg_cfunptr, sizeof (void (*)(void)), CFI_type_cfunptr);\n+  check (arg_struct, sizeof (struct m), CFI_type_struct);\n+}"}, {"sha": "a91a6e85be94ee80c60bf2ba392114b455481e64", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-array-basic.f90", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-basic.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-basic.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-basic.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,151 @@\n+! PR 101305\n+! PR 100917\n+! { dg-do run }\n+! { dg-additional-sources \"typecodes-array-basic-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program tests that kind constants in the ISO_C_BINDING\n+! module result in the right type field in arguments passed by descriptor,\n+! also matching the size of the corresponding C type.  We use \n+! assumed-rank arrays to force the use of a descriptor.\n+!\n+! Some types are tested in their own testcases to allow conditionalization\n+! for target-specific support or xfailing to track bugs.\n+\n+module mm\n+  use iso_c_binding\n+\n+  type, bind (c) :: s\n+    integer(C_INT) :: i, j\n+  end type\n+end module\n+  \n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  interface\n+\n+    subroutine ctest_int1 (arg_int, arg_short, arg_long, arg_long_long, &\n+                           arg_signed_char) bind (c)\n+      use iso_c_binding\n+      integer(C_INT) :: arg_int(:)\n+      integer(C_SHORT) :: arg_short(:)\n+      integer(C_LONG) :: arg_long(:)\n+      integer(C_LONG_LONG) :: arg_long_long(:)\n+      integer(C_SIGNED_CHAR) :: arg_signed_char(:)\n+    end subroutine\n+\n+    subroutine ctest_int2 (arg_int8, arg_int16, arg_int32, arg_int64) bind (c)\n+      use iso_c_binding\n+      integer(C_INT8_T) :: arg_int8(:)\n+      integer(C_INT16_T) :: arg_int16(:)\n+      integer(C_INT32_T) :: arg_int32(:)\n+      integer(C_INT64_T) :: arg_int64(:)\n+    end subroutine\n+\n+    subroutine ctest_int3 (arg_least8, arg_least16, arg_least32, &\n+                           arg_least64) bind (c)\n+      use iso_c_binding\n+      integer(C_INT_LEAST8_T) :: arg_least8(:)\n+      integer(C_INT_LEAST16_T) :: arg_least16(:)\n+      integer(C_INT_LEAST32_T) :: arg_least32(:)\n+      integer(C_INT_LEAST64_T) :: arg_least64(:)\n+    end subroutine\n+\n+    subroutine ctest_int4 (arg_fast8, arg_fast16, arg_fast32, &\n+                           arg_fast64) bind (c)\n+      use iso_c_binding\n+      integer(C_INT_FAST8_T) :: arg_fast8(:)\n+      integer(C_INT_FAST16_T) :: arg_fast16(:)\n+      integer(C_INT_FAST32_T) :: arg_fast32(:)\n+      integer(C_INT_FAST64_T) :: arg_fast64(:)\n+    end subroutine\n+\n+    subroutine ctest_int5 (arg_size, arg_intmax, arg_intptr, &\n+                           arg_ptrdiff) bind (c)\n+      use iso_c_binding\n+      integer(C_SIZE_T) :: arg_size(:)\n+      integer(C_INTMAX_T) :: arg_intmax(:)\n+      integer(C_INTPTR_T) :: arg_intptr(:)\n+      integer(C_PTRDIFF_T) :: arg_ptrdiff(:)\n+    end subroutine\n+\n+    subroutine ctest_real (arg_float, arg_double) bind (c)\n+      use iso_c_binding\n+      real(C_FLOAT) :: arg_float(:)\n+      real(C_DOUBLE) :: arg_double(:)\n+    end subroutine\n+\n+    subroutine ctest_complex (arg_float_complex, arg_double_complex) &\n+                             bind (c)\n+      use iso_c_binding\n+      complex(C_FLOAT_COMPLEX) :: arg_float_complex(:)\n+      complex(C_DOUBLE_COMPLEX) :: arg_double_complex(:)\n+    end subroutine\n+\n+    subroutine ctest_misc (arg_bool, arg_cptr, arg_cfunptr, &\n+                           arg_struct) bind (c)\n+      use iso_c_binding\n+      use mm\n+      logical(C_BOOL) :: arg_bool(:)\n+      type(C_PTR) :: arg_cptr(:)\n+      type(C_FUNPTR) :: arg_cfunptr(:)\n+      type(s) :: arg_struct(:)\n+    end subroutine\n+\n+  end interface\n+\n+  integer(C_INT) :: var_int(4)\n+  integer(C_SHORT) :: var_short(4)\n+  integer(C_LONG) :: var_long(4)\n+  integer(C_LONG_LONG) :: var_long_long(4)\n+  integer(C_SIGNED_CHAR) :: var_signed_char(4)\n+  integer(C_INT8_T) :: var_int8(4)\n+  integer(C_INT16_T) :: var_int16(4)\n+  integer(C_INT32_T) :: var_int32(4)\n+  integer(C_INT64_T) :: var_int64(4)\n+  integer(C_INT_LEAST8_T) :: var_least8(4)\n+  integer(C_INT_LEAST16_T) :: var_least16(4)\n+  integer(C_INT_LEAST32_T) :: var_least32(4)\n+  integer(C_INT_LEAST64_T) :: var_least64(4)\n+  integer(C_INT_FAST8_T) :: var_fast8(4)\n+  integer(C_INT_FAST16_T) :: var_fast16(4)\n+  integer(C_INT_FAST32_T) :: var_fast32(4)\n+  integer(C_INT_FAST64_T) :: var_fast64(4)\n+  integer(C_SIZE_T) :: var_size(4)\n+  integer(C_INTMAX_T) :: var_intmax(4)\n+  integer(C_INTPTR_T) :: var_intptr(4)\n+  integer(C_PTRDIFF_T) :: var_ptrdiff(4)\n+  real(C_FLOAT) :: var_float(4)\n+  real(C_DOUBLE) :: var_double(4)\n+  complex(C_FLOAT_COMPLEX) :: var_float_complex(4)\n+  complex(C_DOUBLE_COMPLEX) :: var_double_complex(4)\n+  logical(C_BOOL) :: var_bool(4)\n+  type(C_PTR) :: var_cptr(4)\n+  type(C_FUNPTR) :: var_cfunptr(4)\n+  type(s) :: var_struct(4)\n+\n+  call ctest_int1 (var_int, var_short, var_long, var_long_long, &\n+                   var_signed_char)\n+\n+  call ctest_int2 (var_int8, var_int16, var_int32, var_int64)\n+\n+  call ctest_int3 (var_least8, var_least16, var_least32, var_least64)\n+\n+  call ctest_int4 (var_fast8, var_fast16, var_fast32, var_fast64)\n+\n+  call ctest_int5 (var_size, var_intmax, var_intptr, var_ptrdiff)\n+\n+  call ctest_real (var_float, var_double)\n+\n+  call ctest_complex (var_float_complex, var_double_complex)\n+\n+  call ctest_misc (var_bool, var_cptr, var_cfunptr, var_struct)\n+\n+  ! FIXME: how do you pass something that corresponds to CFI_type_other?\n+  ! The Fortran front end complains if you try to pass something that\n+  ! isn't interoperable, such as a derived type object without bind(c).\n+\n+end program"}, {"sha": "c69d2242865e0f0348e7bea226ac140b5a9bb3f3", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-array-char-c.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-char-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-char-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-char-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,35 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest_1 (CFI_cdesc_t *arg_char, CFI_cdesc_t *arg_ucs4);\n+\n+/* Sanity check the type info in the descriptor a.  */\n+\n+static void\n+check (CFI_cdesc_t *a, size_t size, int typecode)\n+{\n+  dump_CFI_cdesc_t (a);\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+  if (a->base_addr == NULL)\n+    abort ();\n+  if (a->rank != 1)\n+    abort ();\n+  if (size && a->elem_len != size)\n+    abort ();\n+  if (a->type != typecode)\n+    abort ();\n+}\n+\n+void\n+ctest_1 (CFI_cdesc_t *arg_char, CFI_cdesc_t *arg_ucs4)\n+{\n+  check (arg_char, 1, CFI_type_char);\n+  check (arg_ucs4, 4, CFI_type_ucs4_char);\n+}\n+"}, {"sha": "ede9fb6039a92e68f93ba3ac614373b8d7b02a8f", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-array-char.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-char.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-char.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-char.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,37 @@\n+! PR 101305\n+! PR 92482\n+! { dg-do run }\n+! { dg-additional-sources \"typecodes-array-char-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program tests that the character kind constants provided by\n+! gfortran's ISO_C_BINDING module result in the right type field in\n+! arguments passed by descriptor, also matching the size of the corresponding\n+! C type.  We use assumed-shape arrays to force the use of a descriptor.\n+!\n+! FIXME: because of PR92482, we can only test len=1 characters.  This\n+! test should be extended once that bug is fixed.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  integer, parameter :: ucs4  = selected_char_kind ('ISO_10646')\n+\n+  interface\n+\n+    subroutine ctest_1 (arg_cchar, arg_ucs4) bind (c)\n+      use iso_c_binding\n+      integer, parameter :: ucs4  = selected_char_kind ('ISO_10646')\n+      character(kind=C_CHAR) :: arg_cchar(:)\n+      character(kind=ucs4) :: arg_ucs4(:)\n+    end subroutine\n+\n+  end interface\n+\n+  character(kind=C_CHAR) :: var_cchar(4)\n+  character(kind=ucs4) :: var_ucs4(4)\n+\n+  call ctest_1 (var_cchar, var_ucs4)\n+\n+end program"}, {"sha": "d081febaaf44fe3fdfa35daf67f1d91ddc840001", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-array-float128-c.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-float128-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-float128-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-float128-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,38 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *arg_float128,\n+\t\t   CFI_cdesc_t *arg_complex128);\n+\n+\n+/* Sanity check the type info in the descriptor a.  */\n+\n+static void\n+check (CFI_cdesc_t *a, size_t size, int typecode)\n+{\n+  dump_CFI_cdesc_t (a);\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+  if (a->base_addr == NULL)\n+    abort ();\n+  if (a->rank != 1)\n+    abort ();\n+  if (size && a->elem_len != size)\n+    abort ();\n+  if (a->type != typecode)\n+    abort ();\n+}\n+\n+void\n+ctest (CFI_cdesc_t *arg_float128,\n+       CFI_cdesc_t *arg_complex128)\n+{\n+  check (arg_float128, sizeof (__float128), CFI_type_float128);\n+  check (arg_complex128, sizeof (__float128) * 2,\n+\t CFI_type_float128_Complex);\n+}"}, {"sha": "907877b923e3c6176dace999da55868f0dd0a068", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-array-float128.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-float128.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-float128.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-float128.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,34 @@\n+! PR 101305\n+! PR 100914\n+! PR 100917\n+! Fails on x86 targets where sizeof(long double) == 16 (PR100917).\n+! { dg-do run { xfail { { x86_64*-*-* i?86*-*-* } && longdouble128 } } }\n+! { dg-require-effective-target fortran_real_c_float128 }\n+! { dg-additional-sources \"typecodes-array-float128-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program tests that the vendor extension kind constants provided by\n+! gfortran's ISO_C_BINDING module result in the right type field in\n+! arguments passed by descriptor, also matching the size of the corresponding\n+! C type.  We use assumed-shape arrays to force the use of a descriptor.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+\n+    subroutine ctest (arg_float128, arg_complex128) bind (c)\n+      use iso_c_binding\n+      real(C_FLOAT128) :: arg_float128(:)\n+      complex(C_FLOAT128_COMPLEX) :: arg_complex128(:)\n+    end subroutine\n+\n+  end interface\n+\n+  real(C_FLOAT128) :: var_float128(4)\n+  complex(C_FLOAT128_COMPLEX) :: var_complex128(4)\n+\n+  call ctest (var_float128, var_complex128)\n+\n+end program"}, {"sha": "f6f8c751c48fdae9aa106d4b73c292a8d465ebbd", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-array-int128-c.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-int128-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-int128-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-int128-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,40 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *arg_int128,\n+\t\t   CFI_cdesc_t *arg_least128,\n+\t\t   CFI_cdesc_t *arg_fast128);\n+\n+/* Sanity check the type info in the descriptor a.  */\n+\n+static void\n+check (CFI_cdesc_t *a, size_t size, int typecode)\n+{\n+  dump_CFI_cdesc_t (a);\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+  if (a->base_addr == NULL)\n+    abort ();\n+  if (a->rank != 1)\n+    abort ();\n+  if (size && a->elem_len != size)\n+    abort ();\n+  if (a->type != typecode)\n+    abort ();\n+}\n+\n+void\n+ctest (CFI_cdesc_t *arg_int128,\n+       CFI_cdesc_t *arg_least128,\n+       CFI_cdesc_t *arg_fast128)\n+{\n+  check (arg_int128, sizeof (__int128), CFI_type_int128_t);\n+  check (arg_least128, sizeof (__int128), CFI_type_int_least128_t);\n+  check (arg_fast128, sizeof (__int128), CFI_type_int_fast128_t);\n+}\n+"}, {"sha": "671c544edfeb770d8360014234bf0fb3040cc33d", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-array-int128.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-int128.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-int128.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-int128.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,33 @@\n+! PR 101305\n+! { dg-do run }\n+! { dg-require-effective-target fortran_integer_16 }\n+! { dg-additional-sources \"typecodes-array-int128-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program tests that 128-bit integer kind constants provided by\n+! gfortran's ISO_C_BINDING module result in the right type field in\n+! arguments passed by descriptor, also matching the size of the corresponding\n+! C type.  We use assumed-shape arrays to force the use of a descriptor.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+\n+    subroutine ctest (arg_int128, arg_least128, arg_fast128) bind (c)\n+      use iso_c_binding\n+      integer(C_INT128_T) :: arg_int128(:)\n+      integer(C_INT_LEAST128_T) :: arg_least128(:)\n+      integer(C_INT_FAST128_T) :: arg_fast128(:)\n+    end subroutine\n+\n+  end interface\n+\n+  integer(C_INT128_T) :: var_int128(4)\n+  integer(C_INT_LEAST128_T) :: var_least128(4)\n+  integer(C_INT_FAST128_T) :: var_fast128(4)\n+\n+  call ctest (var_int128, var_least128, var_fast128)\n+\n+end program"}, {"sha": "e47e4e3cead6d58ece0c4f3eada49cee0c89eb5f", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-array-longdouble-c.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-longdouble-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-longdouble-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-longdouble-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,37 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *arg_long_double,\n+\t\t   CFI_cdesc_t *arg_long_double_complex);\n+\n+/* Sanity check the type info in the descriptor a.  */\n+\n+static void\n+check (CFI_cdesc_t *a, size_t size, int typecode)\n+{\n+  dump_CFI_cdesc_t (a);\n+  if (a->attribute != CFI_attribute_other)\n+    abort ();\n+  if (a->base_addr == NULL)\n+    abort ();\n+  if (a->rank != 1)\n+    abort ();\n+  if (size && a->elem_len != size)\n+    abort ();\n+  if (a->type != typecode)\n+    abort ();\n+}\n+\n+void\n+ctest (CFI_cdesc_t *arg_long_double,\n+       CFI_cdesc_t *arg_long_double_complex)\n+{\n+  check (arg_long_double, sizeof (long double), CFI_type_long_double);\n+  check (arg_long_double_complex, sizeof (long double _Complex),\n+\t CFI_type_long_double_Complex);\n+}"}, {"sha": "100071fd500e29b817c7579bf1f600698d7011bc", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-array-longdouble.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-longdouble.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-longdouble.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-array-longdouble.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,32 @@\n+! PR 101305\n+! PR 100917\n+! { dg-do run }\n+! { dg-additional-sources \"typecodes-array-longdouble-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program tests that long double kind constants in the ISO_C_BINDING\n+! module result in the right type field in arguments passed by descriptor,\n+! also matching the size of the corresponding C type.  We use \n+! assumed-rank arrays to force the use of a descriptor.\n+\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+\n+    subroutine ctest (arg_long_double, arg_long_double_complex) bind (c)\n+      use iso_c_binding\n+      real(C_LONG_DOUBLE) :: arg_long_double(:)\n+      complex(C_LONG_DOUBLE_COMPLEX) :: arg_long_double_complex(:)\n+    end subroutine\n+\n+  end interface\n+\n+  real(C_LONG_DOUBLE) :: var_long_double(4)\n+  complex(C_LONG_DOUBLE_COMPLEX) :: var_long_double_complex(4)\n+\n+  call ctest (var_long_double, var_long_double_complex)\n+\n+end program"}, {"sha": "a1d044b8040f5fb1e0301e3cebbf828ad07ed8b4", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-sanity-c.c", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-sanity-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-sanity-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-sanity-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,179 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include <ISO_Fortran_binding.h>\n+\n+extern void ctest_typecodes (void);\n+\n+/* Do sanity checking on the CFI_type_* macros.  In particular, make sure\n+   that if two type codes have the same value, they represent objects of the\n+   same size.  */\n+\n+struct tc_info\n+{\n+  CFI_type_t typecode;\n+  char *name;\n+  size_t size;\n+  int extension;\n+};\n+\n+static struct tc_info tc_table[] =\n+{\n+  /* Extension types.\n+     Note there is no portable C equivalent type for CFI_type_ucs4_char type\n+     (4-byte Unicode characters), and GCC rejects \"__float128 _Complex\",\n+     so this is kind of hacky...  */\n+#if CFI_type_int128_t > 0\n+  { CFI_type_int128_t, \"CFI_type_int128_t\",\n+    sizeof (__int128), 1 },\n+  { CFI_type_int_least128_t, \"CFI_type_int_least128_t\",\n+    sizeof (__int128), 1 },\n+  { CFI_type_int_fast128_t, \"CFI_type_int_fast128_t\",\n+    sizeof (__int128), 1 },\n+#endif\n+#if CFI_type_ucs4_char > 0  \n+  { CFI_type_ucs4_char, \"CFI_type_ucs4_char\", 4, 1 },\n+#endif\n+#if CFI_type_float128 > 0  \n+  { CFI_type_float128, \"CFI_type_float128\",\n+    sizeof (__float128), 1 },\n+  { CFI_type_float128_Complex, \"CFI_type_float128_Complex\",\n+    sizeof (__float128) * 2, 1 },\n+#endif\n+#if CFI_type_cfunptr > 0  \n+  { CFI_type_cfunptr, \"CFI_type_cfunptr\",\n+    sizeof (void (*)(void)), 1 },\n+#endif\n+\n+  /* Standard types.  */\n+  { CFI_type_signed_char, \"CFI_type_signed_char\",\n+    sizeof (signed char), 0, },\n+  { CFI_type_short, \"CFI_type_short\",\n+    sizeof (short), 0 },\n+  { CFI_type_int, \"CFI_type_int\",\n+    sizeof (int), 0 },\n+  { CFI_type_long, \"CFI_type_long\",\n+    sizeof (long), 0 },\n+  { CFI_type_long_long, \"CFI_type_long_long\",\n+    sizeof (long long), 0 },\n+  { CFI_type_size_t, \"CFI_type_size_t\",\n+    sizeof (size_t), 0 },\n+  { CFI_type_int8_t, \"CFI_type_int8_t\",\n+    sizeof (int8_t), 0 },\n+  { CFI_type_int16_t, \"CFI_type_int16_t\",\n+    sizeof (int16_t), 0 },\n+  { CFI_type_int32_t, \"CFI_type_int32_t\",\n+    sizeof (int32_t), 0 },\n+  { CFI_type_int64_t, \"CFI_type_int64_t\",\n+    sizeof (int64_t), 0 },\n+  { CFI_type_int_least8_t, \"CFI_type_int_least8_t\",\n+    sizeof (int_least8_t), 0 },\n+  { CFI_type_int_least16_t, \"CFI_type_int_least16_t\",\n+    sizeof (int_least16_t), 0 },\n+  { CFI_type_int_least32_t, \"CFI_type_int_least32_t\",\n+    sizeof (int_least32_t), 0 },\n+  { CFI_type_int_least64_t, \"CFI_type_int_least64_t\",\n+    sizeof (int_least64_t), 0 },\n+  { CFI_type_int_fast8_t, \"CFI_type_int_fast8_t\",\n+    sizeof (int_fast8_t), 0 },\n+  { CFI_type_int_fast16_t, \"CFI_type_int_fast16_t\",\n+    sizeof (int_fast16_t), 0 },\n+  { CFI_type_int_fast32_t, \"CFI_type_int_fast32_t\",\n+    sizeof (int_fast32_t), 0 },\n+  { CFI_type_int_fast64_t, \"CFI_type_int_fast64_t\",\n+    sizeof (int_fast64_t), 0 },\n+  { CFI_type_intmax_t, \"CFI_type_intmax_t\",\n+    sizeof (intmax_t), 0 },\n+  { CFI_type_intptr_t, \"CFI_type_intptr_t\",\n+    sizeof (intptr_t), 0 },\n+  { CFI_type_ptrdiff_t, \"CFI_type_ptrdiff_t\",\n+    sizeof (ptrdiff_t), 0 },\n+  { CFI_type_float, \"CFI_type_float\",\n+    sizeof (float), 0 },\n+  { CFI_type_double, \"CFI_type_double\",\n+    sizeof (double), 0 },\n+  { CFI_type_long_double, \"CFI_type_long_double\",\n+    sizeof (long double), 0 },\n+  { CFI_type_float_Complex, \"CFI_type_float_Complex\",\n+    sizeof (float _Complex), 0 },\n+  { CFI_type_double_Complex, \"CFI_type_double_Complex\",\n+    sizeof (double _Complex), 0 },\n+  { CFI_type_long_double_Complex, \"CFI_type_long_double_Complex\",\n+    sizeof (long double _Complex), 0 },\n+  { CFI_type_Bool, \"CFI_type_Bool\",\n+    sizeof (_Bool), 0 },\n+  { CFI_type_char, \"CFI_type_char\",\n+    sizeof (char), 0 },\n+  { CFI_type_cptr, \"CFI_type_cptr\",\n+    sizeof (void *), 0 },\n+  { CFI_type_struct, \"CFI_type_struct\", 0, 0 },\n+  { CFI_type_other, \"CFI_type_other\", -1, 0, }\n+};\n+\n+void\n+ctest_typecodes (void)\n+{\n+  int ncodes = sizeof (tc_table) / sizeof (struct tc_info);\n+  int i, j;\n+  int bad = 0;\n+\n+  for (i = 0; i < ncodes; i++)\n+    for (j = i + 1; j < ncodes; j++)\n+      if (tc_table[i].typecode == tc_table[j].typecode\n+\t  && tc_table[i].typecode > 0\n+\t  && (tc_table[i].size != tc_table[j].size))\n+\t{\n+\t  fprintf (stderr,\n+\t\t   \"type codes have the same value %d but different sizes\\n\",\n+\t\t   (int) tc_table[i].typecode);\n+\t  fprintf (stderr, \"  %s size %d\\n\",\n+\t\t   tc_table[i].name, (int) tc_table[i].size);\n+\t  fprintf (stderr, \"  %s size %d\\n\",\n+\t\t   tc_table[j].name, (int) tc_table[j].size);\n+\t  bad = 1;\n+\t}\n+\n+  /* TS29113 Section 8.3.4: The value for CFI_type_other shall be negative\n+     and distinct from all other type specifiers.  If a C type is not\n+     interoperable with a Fortran type and kind supported by the\n+     Fortran processor, its macro shall evaluate to a negative value.\n+     Otherwise, the value for an intrinsic type shall be positive.\n+\n+     In the case of GCC, we expect that all the standard intrinsic\n+     types are supported by both Fortran and C, so they should all be\n+     positive except for CFI_type_other.  Non-standard ones may have a\n+     value -2.  */\n+    \n+  for (i = 0; i < ncodes; i++)\n+    {\n+      if (tc_table[i].typecode == CFI_type_other)\n+\t{\n+\t  if (tc_table[i].typecode >= 0)\n+\t    {\n+\t      fprintf (stderr, \"%s value %d is not negative\\n\",\n+\t\t       tc_table[i].name, (int)tc_table[i].typecode);\n+\t      bad = 1;\n+\t    }\n+\t  if (strcmp (tc_table[i].name, \"CFI_type_other\"))\n+\t    {\n+\t      fprintf (stderr, \"%s has the same value %d as CFI_type_other\\n\",\n+\t\t       tc_table[i].name, (int)CFI_type_other);\n+\t      bad = 1;\n+\t    }\n+\t}\n+      else if (tc_table[i].typecode == -2 && tc_table[i].extension)\n+\t/* Unsupported extension type on this target; this is OK  */\n+\t;\n+      else if (tc_table[i].typecode <= 0)\n+\t{\n+\t  fprintf (stderr, \"%s value %d is not positive\\n\",\n+\t\t   tc_table[i].name, (int)tc_table[i].typecode);\n+\t  bad = 1;\n+\t}\n+    }\n+\n+  if (bad)\n+    abort ();\n+}"}, {"sha": "7dcc62d916c69760dc96d9444e6d58809c4869d0", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-sanity.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-sanity.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-sanity.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-sanity.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,24 @@\n+! PR 101305\n+! { dg-do run }\n+! { dg-additional-sources \"typecodes-sanity-c.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program does sanity checking on the CFI_type_* macros.  All\n+! of the interesting things happen on the C side.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  integer, parameter :: ucs4  = selected_char_kind ('ISO_10646')\n+\n+  interface\n+\n+    subroutine ctest_typecodes () bind (c)\n+    end subroutine\n+\n+  end interface\n+\n+  call ctest_typecodes ()\n+\n+end program"}, {"sha": "fe1a10a1aace387112d91d5045ced8404ce0f56c", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-scalar-basic-c.c", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-basic-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-basic-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-basic-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,168 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest_int1 (CFI_cdesc_t *arg_int,\n+\t\t\tCFI_cdesc_t *arg_short,\n+\t\t\tCFI_cdesc_t *arg_long,\n+\t\t\tCFI_cdesc_t *arg_long_long,\n+\t\t\tCFI_cdesc_t *arg_signed_char);\n+\n+extern void ctest_int2 (CFI_cdesc_t *arg_int8,\n+\t\t\tCFI_cdesc_t *arg_int16,\n+\t\t\tCFI_cdesc_t *arg_int32,\n+\t\t\tCFI_cdesc_t *arg_int64);\n+\n+extern void ctest_int3 (CFI_cdesc_t *arg_least8,\n+\t\t\tCFI_cdesc_t *arg_least16,\n+\t\t\tCFI_cdesc_t *arg_least32,\n+\t\t\tCFI_cdesc_t *arg_least64);\n+\n+extern void ctest_int4 (CFI_cdesc_t *arg_fast8,\n+\t\t\tCFI_cdesc_t *arg_fast16,\n+\t\t\tCFI_cdesc_t *arg_fast32,\n+\t\t\tCFI_cdesc_t *arg_fast64);\n+\n+extern void ctest_int5 (CFI_cdesc_t *arg_size,\n+\t\t\tCFI_cdesc_t *arg_intmax,\n+\t\t\tCFI_cdesc_t *arg_intptr,\n+\t\t\tCFI_cdesc_t *arg_ptrdiff);\n+\n+extern void ctest_real (CFI_cdesc_t *arg_float,\n+\t\t\tCFI_cdesc_t *arg_double);\n+\n+extern void ctest_complex (CFI_cdesc_t *arg_float_complex,\n+\t\t\t   CFI_cdesc_t *arg_double_complex);\n+\n+extern void ctest_misc (CFI_cdesc_t *arg_bool,\n+\t\t\tCFI_cdesc_t *arg_cptr,\n+\t\t\tCFI_cdesc_t *arg_cfunptr,\n+\t\t\tCFI_cdesc_t *arg_struct);\n+\n+/* Sanity check the type info in the descriptor a.  */\n+\n+static void\n+check (CFI_cdesc_t *a, size_t size, int typecode)\n+{\n+  dump_CFI_cdesc_t (a);\n+  if (a->attribute != CFI_attribute_pointer)\n+    abort ();\n+  if (a->base_addr != NULL)\n+    abort ();\n+  if (a->rank != 0)\n+    abort ();\n+  if (size && a->elem_len != size)\n+    abort ();\n+  if (a->type != typecode)\n+    abort ();\n+}\n+\n+\n+/* Test that the basic integer types correspond correctly.  */\n+void\n+ctest_int1 (CFI_cdesc_t *arg_int,\n+\t    CFI_cdesc_t *arg_short,\n+\t    CFI_cdesc_t *arg_long,\n+\t    CFI_cdesc_t *arg_long_long,\n+\t    CFI_cdesc_t *arg_signed_char)\n+{\n+  check (arg_int, sizeof (int), CFI_type_int);\n+  check (arg_short, sizeof (short), CFI_type_short);\n+  check (arg_long, sizeof (long), CFI_type_long);\n+  check (arg_long_long, sizeof (long long int), CFI_type_long_long);\n+  check (arg_signed_char, sizeof (signed char), CFI_type_signed_char);\n+}\n+\n+/* Test the integer types of explicit sizes.  */\n+void\n+ctest_int2 (CFI_cdesc_t *arg_int8,\n+\t    CFI_cdesc_t *arg_int16,\n+\t    CFI_cdesc_t *arg_int32,\n+\t    CFI_cdesc_t *arg_int64)\n+{\n+  check (arg_int8, sizeof (int8_t), CFI_type_int8_t);\n+  check (arg_int16, sizeof (int16_t), CFI_type_int16_t);\n+  check (arg_int32, sizeof (int32_t), CFI_type_int32_t);\n+  check (arg_int64, sizeof (int64_t), CFI_type_int64_t);\n+}\n+\n+/* Check the int_least*_t types.  */\n+\n+void\n+ctest_int3 (CFI_cdesc_t *arg_least8,\n+\t    CFI_cdesc_t *arg_least16,\n+\t    CFI_cdesc_t *arg_least32,\n+\t    CFI_cdesc_t *arg_least64)\n+{\n+  check (arg_least8, sizeof (int_least8_t), CFI_type_int_least8_t);\n+  check (arg_least16, sizeof (int_least16_t), CFI_type_int_least16_t);\n+  check (arg_least32, sizeof (int_least32_t), CFI_type_int_least32_t);\n+  check (arg_least64, sizeof (int_least64_t), CFI_type_int_least64_t);\n+}\n+\n+/* Check the int_fast*_t types.  */\n+void\n+ctest_int4 (CFI_cdesc_t *arg_fast8,\n+\t    CFI_cdesc_t *arg_fast16,\n+\t    CFI_cdesc_t *arg_fast32,\n+\t    CFI_cdesc_t *arg_fast64)\n+{\n+  check (arg_fast8, sizeof (int_fast8_t), CFI_type_int_fast8_t);\n+  check (arg_fast16, sizeof (int_fast16_t), CFI_type_int_fast16_t);\n+  check (arg_fast32, sizeof (int_fast32_t), CFI_type_int_fast32_t);\n+  check (arg_fast64, sizeof (int_fast64_t), CFI_type_int_fast64_t);\n+}\n+\n+/* Check the \"purposeful\" integer types.  */\n+void\n+ctest_int5 (CFI_cdesc_t *arg_size,\n+\t    CFI_cdesc_t *arg_intmax,\n+\t    CFI_cdesc_t *arg_intptr,\n+\t    CFI_cdesc_t *arg_ptrdiff)\n+{\n+  check (arg_size, sizeof (size_t), CFI_type_size_t);\n+  check (arg_intmax, sizeof (intmax_t), CFI_type_intmax_t);\n+  check (arg_intptr, sizeof (intptr_t), CFI_type_intptr_t);\n+  check (arg_ptrdiff, sizeof (ptrdiff_t), CFI_type_ptrdiff_t);\n+}\n+\n+/* Check the floating-point types.  */\n+void\n+ctest_real (CFI_cdesc_t *arg_float,\n+\t    CFI_cdesc_t *arg_double)\n+{\n+  check (arg_float, sizeof (float), CFI_type_float);\n+  check (arg_double, sizeof (double), CFI_type_double);\n+}\n+\n+/* Likewise for the complex types.  */\n+void\n+ctest_complex (CFI_cdesc_t *arg_float_complex,\n+\t       CFI_cdesc_t *arg_double_complex)\n+{\n+  check (arg_float_complex, sizeof (float _Complex),\n+\t CFI_type_float_Complex);\n+  check (arg_double_complex, sizeof (double _Complex),\n+\t CFI_type_double_Complex);\n+}\n+\n+/* Misc types.  */\n+void\n+ctest_misc (CFI_cdesc_t *arg_bool,\n+\t    CFI_cdesc_t *arg_cptr,\n+\t    CFI_cdesc_t *arg_cfunptr,\n+\t    CFI_cdesc_t *arg_struct)\n+{\n+  struct m\n+  {\n+    int i, j;\n+  };\n+\n+  check (arg_bool, sizeof (_Bool), CFI_type_Bool);\n+  check (arg_cptr, sizeof (void *), CFI_type_cptr);\n+  check (arg_struct, sizeof (struct m), CFI_type_struct);\n+}"}, {"sha": "5f7446826a8802b9b637a2715fac3bf84f286731", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-scalar-basic.f90", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-basic.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-basic.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-basic.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,160 @@\n+! PR 101305\n+! PR 100917\n+! xfailed due to PR 101308\n+! { dg-do run { xfail *-*-* } }\n+! { dg-additional-sources \"typecodes-scalar-basic-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program tests that kind constants in the ISO_C_BINDING\n+! module result in the right type field in arguments passed by descriptor,\n+! also matching the size of the corresponding C type.  We use pointers\n+! to force the use of a descriptor.\n+!\n+! Some types are tested in their own testcases to allow conditionalization\n+! for target-specific support or xfailing to track bugs.\n+\n+module mm\n+  use iso_c_binding\n+\n+  type, bind (c) :: s\n+    integer(C_INT) :: i, j\n+  end type\n+end module\n+  \n+program testit\n+  use iso_c_binding\n+  use mm\n+  implicit none\n+\n+  interface\n+\n+    subroutine ctest_int1 (arg_int, arg_short, arg_long, arg_long_long, &\n+                           arg_signed_char) bind (c)\n+      use iso_c_binding\n+      integer(C_INT), pointer :: arg_int\n+      integer(C_SHORT), pointer :: arg_short\n+      integer(C_LONG), pointer :: arg_long\n+      integer(C_LONG_LONG), pointer :: arg_long_long\n+      integer(C_SIGNED_CHAR), pointer :: arg_signed_char\n+    end subroutine\n+\n+    subroutine ctest_int2 (arg_int8, arg_int16, arg_int32, arg_int64) bind (c)\n+      use iso_c_binding\n+      integer(C_INT8_T), pointer :: arg_int8\n+      integer(C_INT16_T), pointer :: arg_int16\n+      integer(C_INT32_T), pointer :: arg_int32\n+      integer(C_INT64_T), pointer :: arg_int64\n+    end subroutine\n+\n+    subroutine ctest_int3 (arg_least8, arg_least16, arg_least32, &\n+                           arg_least64) bind (c)\n+      use iso_c_binding\n+      integer(C_INT_LEAST8_T), pointer :: arg_least8\n+      integer(C_INT_LEAST16_T), pointer :: arg_least16\n+      integer(C_INT_LEAST32_T), pointer :: arg_least32\n+      integer(C_INT_LEAST64_T), pointer :: arg_least64\n+    end subroutine\n+\n+    subroutine ctest_int4 (arg_fast8, arg_fast16, arg_fast32, &\n+                           arg_fast64) bind (c)\n+      use iso_c_binding\n+      integer(C_INT_FAST8_T), pointer :: arg_fast8\n+      integer(C_INT_FAST16_T), pointer :: arg_fast16\n+      integer(C_INT_FAST32_T), pointer :: arg_fast32\n+      integer(C_INT_FAST64_T), pointer :: arg_fast64\n+    end subroutine\n+\n+    subroutine ctest_int5 (arg_size, arg_intmax, arg_intptr, &\n+                           arg_ptrdiff) bind (c)\n+      use iso_c_binding\n+      integer(C_SIZE_T), pointer :: arg_size\n+      integer(C_INTMAX_T), pointer :: arg_intmax\n+      integer(C_INTPTR_T), pointer :: arg_intptr\n+      integer(C_PTRDIFF_T), pointer :: arg_ptrdiff\n+    end subroutine\n+\n+    subroutine ctest_real (arg_float, arg_double) bind (c)\n+      use iso_c_binding\n+      real(C_FLOAT), pointer :: arg_float\n+      real(C_DOUBLE), pointer :: arg_double\n+    end subroutine\n+\n+    subroutine ctest_complex (arg_float_complex, arg_double_complex) &\n+                             bind (c)\n+      use iso_c_binding\n+      complex(C_FLOAT_COMPLEX), pointer :: arg_float_complex\n+      complex(C_DOUBLE_COMPLEX), pointer :: arg_double_complex\n+    end subroutine\n+\n+    subroutine ctest_misc (arg_bool, arg_cptr, arg_cfunptr, arg_struct) &\n+                          bind (c)\n+      use iso_c_binding\n+      use mm\n+      logical(C_BOOL), pointer :: arg_bool\n+      type(C_PTR), pointer :: arg_cptr\n+      type(C_FUNPTR), pointer :: arg_cfunptr\n+      type(s), pointer :: arg_struct\n+    end subroutine\n+\n+  end interface\n+\n+  integer(C_INT), pointer :: var_int\n+  integer(C_SHORT), pointer :: var_short\n+  integer(C_LONG), pointer :: var_long\n+  integer(C_LONG_LONG), pointer :: var_long_long\n+  integer(C_SIGNED_CHAR), pointer :: var_signed_char\n+  integer(C_INT8_T), pointer :: var_int8\n+  integer(C_INT16_T), pointer :: var_int16\n+  integer(C_INT32_T), pointer :: var_int32\n+  integer(C_INT64_T), pointer :: var_int64\n+  integer(C_INT_LEAST8_T), pointer :: var_least8\n+  integer(C_INT_LEAST16_T), pointer :: var_least16\n+  integer(C_INT_LEAST32_T), pointer :: var_least32\n+  integer(C_INT_LEAST64_T), pointer :: var_least64\n+  integer(C_INT_FAST8_T), pointer :: var_fast8\n+  integer(C_INT_FAST16_T), pointer :: var_fast16\n+  integer(C_INT_FAST32_T), pointer :: var_fast32\n+  integer(C_INT_FAST64_T), pointer :: var_fast64\n+  integer(C_SIZE_T), pointer :: var_size\n+  integer(C_INTMAX_T), pointer :: var_intmax\n+  integer(C_INTPTR_T), pointer :: var_intptr\n+  integer(C_PTRDIFF_T), pointer :: var_ptrdiff\n+  real(C_FLOAT), pointer :: var_float\n+  real(C_DOUBLE), pointer :: var_double\n+  complex(C_FLOAT_COMPLEX), pointer :: var_float_complex\n+  complex(C_DOUBLE_COMPLEX), pointer :: var_double_complex\n+  logical(C_BOOL), pointer :: var_bool\n+  type(C_PTR), pointer :: var_cptr\n+  type(C_FUNPTR), pointer :: var_cfunptr\n+  type(s), pointer :: var_struct\n+\n+  nullify (var_int, var_short, var_long, var_long_long, var_signed_char)\n+  call ctest_int1 (var_int, var_short, var_long, var_long_long, &\n+                   var_signed_char)\n+\n+  nullify (var_int8, var_int16, var_int32, var_int64)\n+  call ctest_int2 (var_int8, var_int16, var_int32, var_int64)\n+\n+  nullify (var_least8, var_least16, var_least32, var_least64)\n+  call ctest_int3 (var_least8, var_least16, var_least32, var_least64)\n+\n+  nullify (var_fast8, var_fast16, var_fast32, var_fast64)\n+  call ctest_int4 (var_fast8, var_fast16, var_fast32, var_fast64)\n+\n+  nullify (var_size, var_intmax, var_intptr, var_ptrdiff)\n+  call ctest_int5 (var_size, var_intmax, var_intptr, var_ptrdiff)\n+\n+  nullify (var_float, var_double)\n+  call ctest_real (var_float, var_double)\n+\n+  nullify (var_float_complex, var_double_complex)\n+  call ctest_complex (var_float_complex, var_double_complex)\n+\n+  nullify (var_bool, var_cptr, var_cfunptr, var_struct)\n+  call ctest_misc (var_bool, var_cptr, var_cfunptr, var_struct)\n+\n+  ! FIXME: how do you pass something that corresponds to CFI_type_other?\n+  ! The Fortran front end complains if you try to pass something that\n+  ! isn't interoperable, such as a derived type object without bind(c).\n+\n+end program"}, {"sha": "f1833aab9fb36b4df01baa4a737dac9ab0116b8b", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-scalar-float128-c.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-float128-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-float128-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-float128-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,38 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *arg_float128,\n+\t\t   CFI_cdesc_t *arg_complex128);\n+\n+/* Sanity check the type info in the descriptor a.  */\n+\n+static void\n+check (CFI_cdesc_t *a, size_t size, int typecode)\n+{\n+  dump_CFI_cdesc_t (a);\n+  if (a->attribute != CFI_attribute_pointer)\n+    abort ();\n+  if (a->base_addr != NULL)\n+    abort ();\n+  if (a->rank != 0)\n+    abort ();\n+  if (size && a->elem_len != size)\n+    abort ();\n+  if (a->type != typecode)\n+    abort ();\n+}\n+\n+void\n+ctest (CFI_cdesc_t *arg_float128,\n+       CFI_cdesc_t *arg_complex128)\n+{\n+  check (arg_float128, sizeof (__float128), CFI_type_float128);\n+  check (arg_complex128, sizeof (__float128) * 2,\n+\t CFI_type_float128_Complex);\n+}\n+"}, {"sha": "edf91450ff86368d28ac5f1f14cc7e4534cdd882", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-scalar-float128.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-float128.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-float128.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-float128.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,34 @@\n+! xfailed due to PR 101308\n+! PR 101305\n+! PR 100914\n+! { dg-do run { xfail *-*-* } }\n+! { dg-require-effective-target fortran_real_c_float128 }\n+! { dg-additional-sources \"typecodes-scalar-float128-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program tests that the vendor extension kind constants provided by\n+! gfortran's ISO_C_BINDING module result in the right type field in\n+! arguments passed by descriptor,also matching the size of the corresponding\n+! C type.  We use pointers to force the use of a descriptor.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+\n+    subroutine ctest (arg_float128, arg_complex128) bind (c)\n+      use iso_c_binding\n+      real(C_FLOAT128), pointer :: arg_float128\n+      complex(C_FLOAT128_COMPLEX), pointer :: arg_complex128\n+    end subroutine\n+\n+  end interface\n+\n+  real(C_FLOAT128), pointer :: var_float128\n+  complex(C_FLOAT128_COMPLEX), pointer :: var_complex128\n+\n+  nullify (var_float128, var_complex128)\n+  call ctest (var_float128, var_complex128)\n+\n+end program"}, {"sha": "db071080eb2fa4ff5aaec5d0c55f34dbbfe8ea97", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-scalar-int128-c.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-int128-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-int128-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-int128-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,41 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *arg_int128,\n+\t\t   CFI_cdesc_t *arg_least128,\n+\t\t   CFI_cdesc_t *arg_fast128);\n+\n+/* Sanity check the type info in the descriptor a.  */\n+\n+static void\n+check (CFI_cdesc_t *a, size_t size, int typecode)\n+{\n+  dump_CFI_cdesc_t (a);\n+  if (a->attribute != CFI_attribute_pointer)\n+    abort ();\n+  if (a->base_addr != NULL)\n+    abort ();\n+  if (a->rank != 0)\n+    abort ();\n+  if (size && a->elem_len != size)\n+    abort ();\n+  if (a->type != typecode)\n+    abort ();\n+}\n+\n+void\n+ctest (CFI_cdesc_t *arg_int128,\n+       CFI_cdesc_t *arg_least128,\n+       CFI_cdesc_t *arg_fast128)\n+{\n+  check (arg_int128, sizeof (__int128), CFI_type_int128_t);\n+  check (arg_least128, sizeof (__int128), CFI_type_int_least128_t);\n+  check (arg_fast128, sizeof (__int128), CFI_type_int_fast128_t);\n+}\n+\n+"}, {"sha": "5f3c7e1ccf7330e5ddda536a1342fea0184b0b49", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-scalar-int128.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-int128.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-int128.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-int128.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,35 @@\n+! PR 101305\n+! xfailed due to PR 101308\n+! { dg-do run { xfail *-*-* } }\n+! { dg-require-effective-target fortran_integer_16 }\n+! { dg-additional-sources \"typecodes-scalar-int128-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program tests that 128-bit integer kind constants provided by\n+! gfortran's ISO_C_BINDING module result in the right type field in\n+! arguments passed by descriptor, also matching the size of the corresponding\n+! C type.  We use pointers to force the use of a descriptor.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+\n+    subroutine ctest (arg_int128, arg_least128, arg_fast128) bind (c)\n+      use iso_c_binding\n+      integer(C_INT128_T), pointer :: arg_int128\n+      integer(C_INT_LEAST128_T), pointer :: arg_least128\n+      integer(C_INT_FAST128_T), pointer :: arg_fast128\n+    end subroutine\n+\n+  end interface\n+\n+  integer(C_INT128_T), pointer :: var_int128\n+  integer(C_INT_LEAST128_T), pointer :: var_least128\n+  integer(C_INT_FAST128_T), pointer :: var_fast128\n+\n+  nullify (var_int128, var_least128, var_fast128)\n+  call ctest (var_int128, var_least128, var_fast128)\n+\n+end program"}, {"sha": "a52122f930f89fc7cc00e359394bf1d3483d8b17", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-scalar-longdouble-c.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-longdouble-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-longdouble-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-longdouble-c.c?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,37 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include <ISO_Fortran_binding.h>\n+#include \"dump-descriptors.h\"\n+\n+extern void ctest (CFI_cdesc_t *arg_long_double,\n+\t\t   CFI_cdesc_t *arg_long_double_complex);\n+\n+/* Sanity check the type info in the descriptor a.  */\n+\n+static void\n+check (CFI_cdesc_t *a, size_t size, int typecode)\n+{\n+  dump_CFI_cdesc_t (a);\n+  if (a->attribute != CFI_attribute_pointer)\n+    abort ();\n+  if (a->base_addr != NULL)\n+    abort ();\n+  if (a->rank != 0)\n+    abort ();\n+  if (size && a->elem_len != size)\n+    abort ();\n+  if (a->type != typecode)\n+    abort ();\n+}\n+\n+void\n+ctest (CFI_cdesc_t *arg_long_double,\n+       CFI_cdesc_t *arg_long_double_complex)\n+{\n+  check (arg_long_double, sizeof (long double), CFI_type_long_double);\n+  check (arg_long_double_complex, sizeof (long double _Complex),\n+\t CFI_type_long_double_Complex);\n+}"}, {"sha": "c32e01218b68ff45ab19fb306a1e474fe04db20b", "filename": "gcc/testsuite/gfortran.dg/c-interop/typecodes-scalar-longdouble.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-longdouble.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-longdouble.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ftypecodes-scalar-longdouble.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,33 @@\n+! xfailed due to PR 101308\n+! PR 101305\n+! PR 100917\n+! { dg-do run { xfail *-*-* } }\n+! { dg-additional-sources \"typecodes-scalar-longdouble-c.c dump-descriptors.c\" }\n+! { dg-additional-options \"-g\" }\n+!\n+! This program tests that long double kind constants in the ISO_C_BINDING\n+! module result in the right type field in arguments passed by descriptor,\n+! also matching the size of the corresponding C type.  We use pointers\n+! to force the use of a descriptor.\n+\n+program testit\n+  use iso_c_binding\n+  implicit none\n+\n+  interface\n+\n+    subroutine ctest (arg_long_double, arg_long_double_complex) bind (c)\n+      use iso_c_binding\n+      real(C_LONG_DOUBLE), pointer :: arg_long_double\n+      complex(C_LONG_DOUBLE_COMPLEX), pointer :: arg_long_double_complex\n+    end subroutine\n+\n+  end interface\n+\n+  real(C_LONG_DOUBLE), pointer :: var_long_double\n+  complex(C_LONG_DOUBLE_COMPLEX), pointer :: var_long_double_complex\n+\n+  nullify (var_long_double, var_long_double_complex)\n+  call ctest (var_long_double, var_long_double_complex)\n+\n+end program"}, {"sha": "37e073f692cd0b2214d51a90d0e55602bcf51cf8", "filename": "gcc/testsuite/gfortran.dg/c-interop/ubound.f90", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fubound.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fubound.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fubound.f90?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -0,0 +1,129 @@\n+! { dg-do run }\n+!\n+! TS 29113\n+! 6.4.3  UBOUND\n+!\n+! The description of the intrinsic function UBOUND in ISO/IEC\n+! 1539-1:2010 is changed for an assumed-rank object that is associated\n+! with an assumed-size array; the result of UBOUND (ARRAY, RANK(ARRAY),\n+! KIND) has a value equal to LBOUND (ARRAY, RANK (ARRAY), KIND) \u22122 with\n+! KIND omitted from LBOUND if it was omitted from UBOUND.\n+!\n+! NOTE 6.2  \n+! If LBOUND or UBOUND is invoked for an assumed-rank object that is\n+! associated with a scalar and DIM is absent, the result is a zero-sized\n+! array. LBOUND or UBOUND cannot be invoked for an assumed-rank object\n+! that is associated with a scalar if DIM is present because the rank of\n+! a scalar is zero and DIM must be \u2265 1.\n+!\n+! The idea here is that the main program passes some arrays to a test\n+! subroutine with an assumed-size dummy, which in turn passes that to a\n+! subroutine with an assumed-rank dummy.\n+\n+program test \n+\n+  ! Define some arrays for testing.\n+  integer, target :: x1(5)\n+  integer :: y1(0:9)\n+  integer, pointer :: p1(:)\n+  integer, allocatable :: a1(:)\n+  integer, target :: x3(2,3,4)\n+  integer :: y3(0:1,-3:-1,4)\n+  integer, pointer :: p3(:,:,:)\n+  integer, allocatable :: a3(:,:,:)\n+  integer :: x\n+\n+  ! Test the 1-dimensional arrays.\n+  call test1 (x1)\n+  call testit2(x1, shape(x1))\n+  call test1 (y1)\n+  call testit2(y1, shape(y1))\n+  p1 => x1\n+  call testit2(p1, shape(p1))\n+  call testit2p(p1, lbound(p1), shape(p1))\n+  call test1 (p1)\n+  p1(77:) => x1\n+  call testit2p(p1, [77], shape(p1))\n+  allocate (a1(5))\n+  call testit2(a1, shape(a1))\n+  call testit2a(a1, lbound(a1), shape(a1))\n+  call test1 (a1)\n+  deallocate(a1)\n+  allocate (a1(-38:5))\n+  call test1 (a1)\n+  call testit2(a1, shape(a1))\n+  call testit2a(a1, [-38], shape(a1))\n+\n+  ! Test the multi-dimensional arrays.\n+  call test3 (x3, 1, 2, 1, 3)\n+  call test3 (y3, 0, 1, -3, -1)\n+  p3 => x3\n+  call test3 (p3, 1, 2, 1, 3)\n+  allocate (a3(2,3,4))\n+  call test3 (a3, 1, 2, 1, 3)\n+\n+  ! Test some scalars.\n+  call test0 (x)\n+  call test0 (-1)\n+  call test0 (x1(1))\n+\n+contains\n+\n+  subroutine testit (a)\n+    integer :: a(..)\n+    integer :: r\n+    r = rank(a)\n+    if (any (lbound (a) .ne. 1)) stop 101\n+    if (ubound (a, r) .ne. -1) stop 102\n+  end subroutine\n+\n+  subroutine testit2(a, shape)\n+    integer :: a(..)\n+    integer :: shape(:)\n+    if (rank(a) /= size(shape)) stop 111\n+    if (any (lbound(a) /= 1)) stop 112\n+    if (any (ubound(a) /= shape)) stop 113\n+  end subroutine\n+\n+  subroutine testit2a(a,lbound2,  shape2)\n+    integer, allocatable :: a(..)\n+    integer :: lbound2(:), shape2(:)\n+    if (rank(a) /= size(shape2)) stop 121\n+    if (any (lbound(a) /= lbound2)) stop 122\n+    if (any (ubound(a) /= lbound2 + shape2 - 1)) stop 123\n+    if (any (shape(a) /= shape2)) stop 124\n+    if (sum (shape(a)) /= size(a)) stop 125\n+  end subroutine\n+\n+  subroutine testit2p(a, lbound2, shape2)\n+    integer, pointer :: a(..)\n+    integer :: lbound2(:), shape2(:)\n+    if (rank(a) /= size(shape2)) stop 131\n+    if (any (lbound(a) /= lbound2)) stop 132\n+    if (any (ubound(a) /= lbound2 + shape2 - 1)) stop 133\n+    if (any (shape(a) /= shape2)) stop 134\n+    if (sum (shape(a)) /= size(a)) stop 135\n+  end subroutine \n+\n+  subroutine test0 (a)\n+    integer :: a(..)\n+    if (rank (a) .ne. 0) stop 141\n+    if (size (lbound (a)) .ne. 0) stop 142\n+    if (size (ubound (a)) .ne. 0) stop 143\n+  end subroutine\n+\n+  subroutine test1 (a)\n+    integer :: a(*)\n+\n+    call testit (a)\n+  end subroutine\n+\n+  subroutine test3 (a, l1, u1, l2, u2)\n+    implicit none\n+    integer :: l1, u1, l2, u2\n+    integer :: a(l1:u1, l2:u2, *)\n+\n+    call testit (a)\n+  end subroutine\n+\n+end program"}, {"sha": "ad8f01152f2e8b4cbf5441ccea59593bbd365251", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb17b5054118ec0f727956fd6e034b577b5e261c/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=cb17b5054118ec0f727956fd6e034b577b5e261c", "patch": "@@ -1576,6 +1576,22 @@ proc check_effective_target_fortran_real_10 { } {\n     }]\n }\n \n+# Return 1 if the target supports Fortran real kind C_FLOAT128,\n+# 0 otherwise.  This differs from check_effective_target_fortran_real_16\n+# because __float128 has the additional requirement that it be the\n+# 128-bit IEEE encoding; even if __float128 is available in C, it may not\n+# have a corresponding Fortran kind on targets (PowerPC) that use some \n+# other encoding for long double/TFmode/real(16).\n+proc check_effective_target_fortran_real_c_float128 { } {\n+    return [check_no_compiler_messages fortran_real_c_float128 executable {\n+\t! Fortran\n+\tuse iso_c_binding\n+\treal(kind=c_float128) :: x\n+\tx = cos (x)\n+\tend\n+    }]\n+}\n+\n # Return 1 if the target supports Fortran's IEEE modules,\n # 0 otherwise.\n #"}]}