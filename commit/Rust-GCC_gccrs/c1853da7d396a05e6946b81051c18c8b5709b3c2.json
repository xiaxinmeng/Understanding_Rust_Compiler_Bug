{"sha": "c1853da7d396a05e6946b81051c18c8b5709b3c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzE4NTNkYTdkMzk2YTA1ZTY5NDZiODEwNTFjMThjOGI1NzA5YjNjMg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2003-05-04T22:09:48Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2003-05-04T22:09:48Z"}, "message": "expr.c (store_field): Don't clobber TEMP in shift: it might be a variable.\n\n\t* expr.c (store_field): Don't clobber TEMP in shift: it might be\n\ta variable.\n\t(get_inner_reference): Don't go through a VIEW_CONVERT_EXPR\n\twhose purpose is to step up the alignment.\n\t(expand_expr, case ADDR_EXPR): Force LO_SUM into memory, just like REG.\n\nFrom-SVN: r66465", "tree": {"sha": "b8640fda4af09633acae350d1bc8ba846aa08da9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8640fda4af09633acae350d1bc8ba846aa08da9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1853da7d396a05e6946b81051c18c8b5709b3c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1853da7d396a05e6946b81051c18c8b5709b3c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1853da7d396a05e6946b81051c18c8b5709b3c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1853da7d396a05e6946b81051c18c8b5709b3c2/comments", "author": null, "committer": null, "parents": [{"sha": "41dd7402adb27e783c5d928f5c53cf221c5c6eb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41dd7402adb27e783c5d928f5c53cf221c5c6eb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41dd7402adb27e783c5d928f5c53cf221c5c6eb5"}], "stats": {"total": 24, "additions": 21, "deletions": 3}, "files": [{"sha": "669001dfdbbae30d46a1ba517d387440328c1460", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1853da7d396a05e6946b81051c18c8b5709b3c2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1853da7d396a05e6946b81051c18c8b5709b3c2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c1853da7d396a05e6946b81051c18c8b5709b3c2", "patch": "@@ -1,5 +1,11 @@\n 2003-05-04  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* expr.c (store_field): Don't clobber TEMP in shift: it might be\n+\ta variable.\n+\t(get_inner_reference): Don't go through a VIEW_CONVERT_EXPR\n+\twhose purpose is to step up the alignment.\n+\t(expand_expr, case ADDR_EXPR): Force LO_SUM into memory, just like REG.\n+\n \t* stor-layout.c (compute_record_mode): Relax restriction\n \ton fields crossing word boundaries forcing BLKmode.\n "}, {"sha": "ba7db159d97b813c714092b32892472145e62ada", "filename": "gcc/expr.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1853da7d396a05e6946b81051c18c8b5709b3c2/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1853da7d396a05e6946b81051c18c8b5709b3c2/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c1853da7d396a05e6946b81051c18c8b5709b3c2", "patch": "@@ -5648,7 +5648,7 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode, unsignedp, type,\n \ttemp = expand_shift (RSHIFT_EXPR, GET_MODE (temp), temp,\n \t\t\t     size_int (GET_MODE_BITSIZE (GET_MODE (temp))\n \t\t\t\t       - bitsize),\n-\t\t\t     temp, 1);\n+\t\t\t     NULL_RTX, 1);\n \n       /* Unless MODE is VOIDmode or BLKmode, convert TEMP to\n \t MODE.  */\n@@ -5888,8 +5888,20 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n \n \t  continue;\n \t}\n+\n+      /* We can go inside most conversions: all NON_VALUE_EXPRs, all normal\n+\t conversions that don't change the mode, and all view conversions\n+\t except those that need to \"step up\" the alignment.  */\n       else if (TREE_CODE (exp) != NON_LVALUE_EXPR\n-\t       && TREE_CODE (exp) != VIEW_CONVERT_EXPR\n+\t       && ! (TREE_CODE (exp) == VIEW_CONVERT_EXPR\n+\t\t     && ! ((TYPE_ALIGN (TREE_TYPE (exp))\n+\t\t\t    > TYPE_ALIGN (TREE_TYPE (TREE_OPERAND (exp, 0))))\n+\t\t\t   && STRICT_ALIGNMENT\n+\t\t\t   && (TYPE_ALIGN (TREE_TYPE (TREE_OPERAND (exp, 0)))\n+\t\t\t       < BIGGEST_ALIGNMENT)\n+\t\t\t   && (TYPE_ALIGN_OK (TREE_TYPE (exp))\n+\t\t\t       || TYPE_ALIGN_OK (TREE_TYPE\n+\t\t\t\t\t\t (TREE_OPERAND (exp, 0))))))\n \t       && ! ((TREE_CODE (exp) == NOP_EXPR\n \t\t      || TREE_CODE (exp) == CONVERT_EXPR)\n \t\t     && (TYPE_MODE (TREE_TYPE (exp))\n@@ -9245,7 +9257,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t   op0);\n \t  else if (GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG\n \t\t   || GET_CODE (op0) == CONCAT || GET_CODE (op0) == ADDRESSOF\n-\t\t   || GET_CODE (op0) == PARALLEL)\n+\t\t   || GET_CODE (op0) == PARALLEL || GET_CODE (op0) == LO_SUM)\n \t    {\n \t      /* If the operand is a SAVE_EXPR, we can deal with this by\n \t\t forcing the SAVE_EXPR into memory.  */"}]}