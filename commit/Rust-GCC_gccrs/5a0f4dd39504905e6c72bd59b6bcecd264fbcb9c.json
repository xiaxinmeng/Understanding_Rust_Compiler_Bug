{"sha": "5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWEwZjRkZDM5NTA0OTA1ZTZjNzJiZDU5YjZiY2VjZDI2NGZiY2I5Yw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-05-16T10:43:33Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-05-16T10:43:33Z"}, "message": "omp-low.c (extract_omp_for_data): For collapsed loops...\n\n\t* omp-low.c (extract_omp_for_data): For collapsed loops,\n\tif at least one of the loops is known at compile time to\n\titerate zero times, set count to 0.\n\t(expand_omp_regimplify_p): New function.\n\t(expand_omp_for_generic): For collapsed loops, if at least\n\tone of the loops isn't known to iterate at least once,\n\tadd runtime check with setting count to 0.\n\t(expand_omp_for_static_nochunk, expand_omp_for_static_chunk):\n\tFor unsigned types if it isn't known at compile time that\n\tthe loop will iterate at least once, add runtime check to bypass\n\tthe whole loop if initial condition isn't true.\n\n\t* testsuite/libgomp.c/loop-13.c: New test.\n\t* testsuite/libgomp.c/loop-14.c: New test.\n\t* testsuite/libgomp.c/loop-15.c: New test.\n\t* testsuite/libgomp.c++/loop-13.C: New test.\n\t* testsuite/libgomp.c++/loop-14.C: New test.\n\t* testsuite/libgomp.c++/loop-15.C: New test.\n\nFrom-SVN: r198966", "tree": {"sha": "bb79795b8f80069dd0b22d37e59aa3d81ee9f34d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb79795b8f80069dd0b22d37e59aa3d81ee9f34d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e3753785835fdb4c96f901c7d158a38b1c5c2f78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3753785835fdb4c96f901c7d158a38b1c5c2f78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3753785835fdb4c96f901c7d158a38b1c5c2f78"}], "stats": {"total": 989, "additions": 983, "deletions": 6}, "files": [{"sha": "4f36ac9762bdb90b024373de29b457ffc8a34da1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c", "patch": "@@ -1,3 +1,17 @@\n+2013-05-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* omp-low.c (extract_omp_for_data): For collapsed loops,\n+\tif at least one of the loops is known at compile time to\n+\titerate zero times, set count to 0.\n+\t(expand_omp_regimplify_p): New function.\n+\t(expand_omp_for_generic): For collapsed loops, if at least\n+\tone of the loops isn't known to iterate at least once,\n+\tadd runtime check with setting count to 0.\n+\t(expand_omp_for_static_nochunk, expand_omp_for_static_chunk):\n+\tFor unsigned types if it isn't known at compile time that\n+\tthe loop will iterate at least once, add runtime check to bypass\n+\tthe whole loop if initial condition isn't true.\n+\n 2013-05-16  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* varasm.c (default_use_anchors_for_symbol_p): Use decl_replaceable_p."}, {"sha": "2cae478fcb9e4c44c8f9414c72840bc0757fccdf", "filename": "gcc/omp-low.c", "status": "modified", "additions": 192, "deletions": 6, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c", "patch": "@@ -398,11 +398,16 @@ extract_omp_for_data (gimple for_stmt, struct omp_for_data *fd,\n \n       if (collapse_count && *collapse_count == NULL)\n \t{\n-\t  if ((i == 0 || count != NULL_TREE)\n-\t      && TREE_CODE (TREE_TYPE (loop->v)) == INTEGER_TYPE\n-\t      && TREE_CONSTANT (loop->n1)\n-\t      && TREE_CONSTANT (loop->n2)\n-\t      && TREE_CODE (loop->step) == INTEGER_CST)\n+\t  t = fold_binary (loop->cond_code, boolean_type_node,\n+\t\t\t   fold_convert (TREE_TYPE (loop->v), loop->n1),\n+\t\t\t   fold_convert (TREE_TYPE (loop->v), loop->n2));\n+\t  if (t && integer_zerop (t))\n+\t    count = build_zero_cst (long_long_unsigned_type_node);\n+\t  else if ((i == 0 || count != NULL_TREE)\n+\t\t   && TREE_CODE (TREE_TYPE (loop->v)) == INTEGER_TYPE\n+\t\t   && TREE_CONSTANT (loop->n1)\n+\t\t   && TREE_CONSTANT (loop->n2)\n+\t\t   && TREE_CODE (loop->step) == INTEGER_CST)\n \t    {\n \t      tree itype = TREE_TYPE (loop->v);\n \n@@ -435,7 +440,7 @@ extract_omp_for_data (gimple for_stmt, struct omp_for_data *fd,\n \t      if (TREE_CODE (count) != INTEGER_CST)\n \t\tcount = NULL_TREE;\n \t    }\n-\t  else\n+\t  else if (count && !integer_zerop (count))\n \t    count = NULL_TREE;\n \t}\n     }\n@@ -3387,6 +3392,25 @@ optimize_omp_library_calls (gimple entry_stmt)\n       }\n }\n \n+/* Callback for expand_omp_build_assign.  Return non-NULL if *tp needs to be\n+   regimplified.  */\n+\n+static tree\n+expand_omp_regimplify_p (tree *tp, int *walk_subtrees, void *)\n+{\n+  tree t = *tp;\n+\n+  /* Any variable with DECL_VALUE_EXPR needs to be regimplified.  */\n+  if (TREE_CODE (t) == VAR_DECL && DECL_HAS_VALUE_EXPR_P (t))\n+    return t;\n+\n+  if (TREE_CODE (t) == ADDR_EXPR)\n+    recompute_tree_invariant_for_addr_expr (t);\n+\n+  *walk_subtrees = !TYPE_P (t) && !DECL_P (t);\n+  return NULL_TREE;\n+}\n+\n /* Expand the OpenMP parallel or task directive starting at REGION.  */\n \n static void\n@@ -3662,22 +3686,29 @@ expand_omp_taskreg (struct omp_region *region)\n \n     we generate pseudocode\n \n+\tif (__builtin_expect (N32 cond3 N31, 0)) goto Z0;\n \tif (cond3 is <)\n \t  adj = STEP3 - 1;\n \telse\n \t  adj = STEP3 + 1;\n \tcount3 = (adj + N32 - N31) / STEP3;\n+\tif (__builtin_expect (N22 cond2 N21, 0)) goto Z0;\n \tif (cond2 is <)\n \t  adj = STEP2 - 1;\n \telse\n \t  adj = STEP2 + 1;\n \tcount2 = (adj + N22 - N21) / STEP2;\n+\tif (__builtin_expect (N12 cond1 N11, 0)) goto Z0;\n \tif (cond1 is <)\n \t  adj = STEP1 - 1;\n \telse\n \t  adj = STEP1 + 1;\n \tcount1 = (adj + N12 - N11) / STEP1;\n \tcount = count1 * count2 * count3;\n+\tgoto Z1;\n+    Z0:\n+\tcount = 0;\n+    Z1:\n \tmore = GOMP_loop_foo_start (0, count, 1, CHUNK, &istart0, &iend0);\n \tif (more) goto L0; else goto L3;\n     L0:\n@@ -3785,13 +3816,61 @@ expand_omp_for_generic (struct omp_region *region,\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n   if (fd->collapse > 1)\n     {\n+      basic_block zero_iter_bb = NULL;\n+      int first_zero_iter = -1;\n+\n       /* collapsed loops need work for expansion in SSA form.  */\n       gcc_assert (!gimple_in_ssa_p (cfun));\n       counts = (tree *) alloca (fd->collapse * sizeof (tree));\n       for (i = 0; i < fd->collapse; i++)\n \t{\n \t  tree itype = TREE_TYPE (fd->loops[i].v);\n \n+\t  if (SSA_VAR_P (fd->loop.n2)\n+\t      && ((t = fold_binary (fd->loops[i].cond_code, boolean_type_node,\n+\t\t\t\t    fold_convert (itype, fd->loops[i].n1),\n+\t\t\t\t    fold_convert (itype, fd->loops[i].n2)))\n+\t\t  == NULL_TREE || !integer_onep (t)))\n+\t    {\n+\t      tree n1, n2;\n+\t      n1 = fold_convert (itype, unshare_expr (fd->loops[i].n1));\n+\t      n1 = force_gimple_operand_gsi (&gsi, n1, true, NULL_TREE,\n+\t\t\t\t\t     true, GSI_SAME_STMT);\n+\t      n2 = fold_convert (itype, unshare_expr (fd->loops[i].n2));\n+\t      n2 = force_gimple_operand_gsi (&gsi, n2, true, NULL_TREE,\n+\t\t\t\t\t     true, GSI_SAME_STMT);\n+\t      stmt = gimple_build_cond (fd->loops[i].cond_code, n1, n2,\n+\t\t\t\t\tNULL_TREE, NULL_TREE);\n+\t      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+\t      if (walk_tree (gimple_cond_lhs_ptr (stmt),\n+\t\t\t     expand_omp_regimplify_p, NULL, NULL)\n+\t\t  || walk_tree (gimple_cond_rhs_ptr (stmt),\n+\t\t\t\texpand_omp_regimplify_p, NULL, NULL))\n+\t\t{\n+\t\t  gsi = gsi_for_stmt (stmt);\n+\t\t  gimple_regimplify_operands (stmt, &gsi);\n+\t\t}\n+\t      e = split_block (entry_bb, stmt);\n+\t      if (zero_iter_bb == NULL)\n+\t\t{\n+\t\t  first_zero_iter = i;\n+\t\t  zero_iter_bb = create_empty_bb (entry_bb);\n+\t\t  if (current_loops)\n+\t\t    add_bb_to_loop (zero_iter_bb, entry_bb->loop_father);\n+\t\t  gsi = gsi_after_labels (zero_iter_bb);\n+\t\t  stmt = gimple_build_assign (fd->loop.n2,\n+\t\t\t\t\t      build_zero_cst (type));\n+\t\t  gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+\t\t  set_immediate_dominator (CDI_DOMINATORS, zero_iter_bb,\n+\t\t\t\t\t   entry_bb);\n+\t\t}\n+\t      ne = make_edge (entry_bb, zero_iter_bb, EDGE_FALSE_VALUE);\n+\t      ne->probability = REG_BR_PROB_BASE / 2000 - 1;\n+\t      e->flags = EDGE_TRUE_VALUE;\n+\t      e->probability = REG_BR_PROB_BASE - ne->probability;\n+\t      entry_bb = e->dest;\n+\t      gsi = gsi_last_bb (entry_bb);\n+\t    }\n \t  if (POINTER_TYPE_P (itype))\n \t    itype = signed_type_for (itype);\n \t  t = build_int_cst (itype, (fd->loops[i].cond_code == LT_EXPR\n@@ -3836,6 +3915,23 @@ expand_omp_for_generic (struct omp_region *region,\n \t      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n \t    }\n \t}\n+      if (zero_iter_bb)\n+\t{\n+\t  /* Some counts[i] vars might be uninitialized if\n+\t     some loop has zero iterations.  But the body shouldn't\n+\t     be executed in that case, so just avoid uninit warnings.  */\n+\t  for (i = first_zero_iter; i < fd->collapse; i++)\n+\t    if (SSA_VAR_P (counts[i]))\n+\t      TREE_NO_WARNING (counts[i]) = 1;\n+\t  gsi_prev (&gsi);\n+\t  e = split_block (entry_bb, gsi_stmt (gsi));\n+\t  entry_bb = e->dest;\n+\t  make_edge (zero_iter_bb, entry_bb, EDGE_FALLTHRU);\n+\t  gsi = gsi_last_bb (entry_bb);\n+\t  set_immediate_dominator (CDI_DOMINATORS, entry_bb,\n+\t\t\t\t   get_immediate_dominator (CDI_DOMINATORS,\n+\t\t\t\t\t\t\t    zero_iter_bb));\n+\t}\n     }\n   if (in_combined_parallel)\n     {\n@@ -4169,6 +4265,7 @@ expand_omp_for_generic (struct omp_region *region,\n \n    where COND is \"<\" or \">\", we generate pseudocode\n \n+\tif ((__typeof (V)) -1 > 0 && N2 cond N1) goto L2;\n \tif (cond is <)\n \t  adj = STEP - 1;\n \telse\n@@ -4229,6 +4326,50 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   gsi = gsi_last_bb (entry_bb);\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n \n+  t = fold_binary (fd->loop.cond_code, boolean_type_node,\n+\t\t   fold_convert (type, fd->loop.n1),\n+\t\t   fold_convert (type, fd->loop.n2));\n+  if (TYPE_UNSIGNED (type)\n+      && (t == NULL_TREE || !integer_onep (t)))\n+    {\n+      tree n1, n2;\n+      n1 = fold_convert (type, unshare_expr (fd->loop.n1));\n+      n1 = force_gimple_operand_gsi (&gsi, n1, true, NULL_TREE,\n+\t\t\t\t     true, GSI_SAME_STMT);\n+      n2 = fold_convert (type, unshare_expr (fd->loop.n2));\n+      n2 = force_gimple_operand_gsi (&gsi, n2, true, NULL_TREE,\n+\t\t\t\t     true, GSI_SAME_STMT);\n+      stmt = gimple_build_cond (fd->loop.cond_code, n1, n2,\n+\t\t\t\tNULL_TREE, NULL_TREE);\n+      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+      if (walk_tree (gimple_cond_lhs_ptr (stmt),\n+\t\t     expand_omp_regimplify_p, NULL, NULL)\n+\t  || walk_tree (gimple_cond_rhs_ptr (stmt),\n+\t\t\texpand_omp_regimplify_p, NULL, NULL))\n+\t{\n+\t  gsi = gsi_for_stmt (stmt);\n+\t  gimple_regimplify_operands (stmt, &gsi);\n+\t}\n+      ep = split_block (entry_bb, stmt);\n+      ep->flags = EDGE_TRUE_VALUE;\n+      entry_bb = ep->dest;\n+      ep->probability = REG_BR_PROB_BASE - (REG_BR_PROB_BASE / 2000 - 1);\n+      ep = make_edge (ep->src, fin_bb, EDGE_FALSE_VALUE);\n+      ep->probability = REG_BR_PROB_BASE / 2000 - 1;\n+      if (gimple_in_ssa_p (cfun))\n+\t{\n+\t  int dest_idx = find_edge (entry_bb, fin_bb)->dest_idx;\n+\t  for (gsi = gsi_start_phis (fin_bb);\n+\t       !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      gimple phi = gsi_stmt (gsi);\n+\t      add_phi_arg (phi, gimple_phi_arg_def (phi, dest_idx),\n+\t\t\t   ep, UNKNOWN_LOCATION);\n+\t    }\n+\t}\n+      gsi = gsi_last_bb (entry_bb);\n+    }\n+\n   t = build_call_expr (builtin_decl_explicit (BUILT_IN_OMP_GET_NUM_THREADS), 0);\n   t = fold_convert (itype, t);\n   nthreads = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n@@ -4395,6 +4536,7 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n \n    where COND is \"<\" or \">\", we generate pseudocode\n \n+\tif ((__typeof (V)) -1 > 0 && N2 cond N1) goto L2;\n \tif (cond is <)\n \t  adj = STEP - 1;\n \telse\n@@ -4460,6 +4602,50 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n   si = gsi_last_bb (entry_bb);\n   gcc_assert (gimple_code (gsi_stmt (si)) == GIMPLE_OMP_FOR);\n \n+  t = fold_binary (fd->loop.cond_code, boolean_type_node,\n+\t\t   fold_convert (type, fd->loop.n1),\n+\t\t   fold_convert (type, fd->loop.n2));\n+  if (TYPE_UNSIGNED (type)\n+      && (t == NULL_TREE || !integer_onep (t)))\n+    {\n+      tree n1, n2;\n+      n1 = fold_convert (type, unshare_expr (fd->loop.n1));\n+      n1 = force_gimple_operand_gsi (&si, n1, true, NULL_TREE,\n+\t\t\t\t     true, GSI_SAME_STMT);\n+      n2 = fold_convert (type, unshare_expr (fd->loop.n2));\n+      n2 = force_gimple_operand_gsi (&si, n2, true, NULL_TREE,\n+\t\t\t\t     true, GSI_SAME_STMT);\n+      stmt = gimple_build_cond (fd->loop.cond_code, n1, n2,\n+\t\t\t\tNULL_TREE, NULL_TREE);\n+      gsi_insert_before (&si, stmt, GSI_SAME_STMT);\n+      if (walk_tree (gimple_cond_lhs_ptr (stmt),\n+\t\t     expand_omp_regimplify_p, NULL, NULL)\n+\t  || walk_tree (gimple_cond_rhs_ptr (stmt),\n+\t\t\texpand_omp_regimplify_p, NULL, NULL))\n+\t{\n+\t  si = gsi_for_stmt (stmt);\n+\t  gimple_regimplify_operands (stmt, &si);\n+\t}\n+      se = split_block (entry_bb, stmt);\n+      se->flags = EDGE_TRUE_VALUE;\n+      entry_bb = se->dest;\n+      se->probability = REG_BR_PROB_BASE - (REG_BR_PROB_BASE / 2000 - 1);\n+      se = make_edge (se->src, fin_bb, EDGE_FALSE_VALUE);\n+      se->probability = REG_BR_PROB_BASE / 2000 - 1;\n+      if (gimple_in_ssa_p (cfun))\n+\t{\n+\t  int dest_idx = find_edge (entry_bb, fin_bb)->dest_idx;\n+\t  for (si = gsi_start_phis (fin_bb);\n+\t       !gsi_end_p (si); gsi_next (&si))\n+\t    {\n+\t      gimple phi = gsi_stmt (si);\n+\t      add_phi_arg (phi, gimple_phi_arg_def (phi, dest_idx),\n+\t\t\t   se, UNKNOWN_LOCATION);\n+\t    }\n+\t}\n+      si = gsi_last_bb (entry_bb);\n+    }\n+\n   t = build_call_expr (builtin_decl_explicit (BUILT_IN_OMP_GET_NUM_THREADS), 0);\n   t = fold_convert (itype, t);\n   nthreads = force_gimple_operand_gsi (&si, t, true, NULL_TREE,"}, {"sha": "8b81b27f934f4aa393b5004297d63fd7a0a1ee64", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c", "patch": "@@ -1,3 +1,12 @@\n+2013-05-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.c/loop-13.c: New test.\n+\t* testsuite/libgomp.c/loop-14.c: New test.\n+\t* testsuite/libgomp.c/loop-15.c: New test.\n+\t* testsuite/libgomp.c++/loop-13.C: New test.\n+\t* testsuite/libgomp.c++/loop-14.C: New test.\n+\t* testsuite/libgomp.c++/loop-15.C: New test.\n+\n 2013-02-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/56217"}, {"sha": "31572be0f2617242e1f83a6dbc0c78493a1b7edd", "filename": "libgomp/testsuite/libgomp.c++/loop-13.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-13.C?ref=5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c", "patch": "@@ -0,0 +1,3 @@\n+/* { dg-do run } */\n+\n+#include \"../libgomp.c/loop-13.c\""}, {"sha": "ba2856ac105d0e4cd09d986659ad43f12c326346", "filename": "libgomp/testsuite/libgomp.c++/loop-14.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-14.C?ref=5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c", "patch": "@@ -0,0 +1,3 @@\n+/* { dg-do run } */\n+\n+#include \"../libgomp.c/loop-14.c\""}, {"sha": "9bde48e3ac80a92eeccf7d804213d4b67d605860", "filename": "libgomp/testsuite/libgomp.c++/loop-15.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-15.C?ref=5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c", "patch": "@@ -0,0 +1,3 @@\n+/* { dg-do run } */\n+\n+#include \"../libgomp.c/loop-15.c\""}, {"sha": "997c628fae62fa54fbe980b26053c12b8162899a", "filename": "libgomp/testsuite/libgomp.c/loop-13.c", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-13.c?ref=5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c", "patch": "@@ -0,0 +1,253 @@\n+/* { dg-do run } */\n+\n+volatile int ji = 100, ki = 2;\n+volatile unsigned int ju = 100, ku = 2;\n+volatile long long int jll = 100, kll = 2;\n+volatile unsigned long long int jull = 100, kull = 2;\n+unsigned long long l;\n+\n+void\n+f0 (void)\n+{\n+  int i, j, k;\n+  unsigned int j2, k2;\n+  #pragma omp for reduction(+: l)\n+  for (i = ji; i < ki; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l)\n+  for (i = ji; i < ki; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3)\n+  for (j = 0; j < 4; j++)\n+    for (i = ji; i < ki; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3)\n+  for (j = 0; j < 4; j++)\n+    for (i = ji; i < ki; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = ji; i < ki; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = ji; i < ki; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3)\n+  for (j = 0; j < 4; j++)\n+    for (i = ji; i < ki; i++)\n+      for (k = ki + 10; k < ji - 10; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3)\n+  for (j = ki + 10; j < ji - 10; j++)\n+    for (i = ji; i < ki; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+}\n+\n+void\n+f1 (void)\n+{\n+  unsigned int i, j, k;\n+  int j2, k2;\n+  #pragma omp for reduction(+: l)\n+  for (i = ju; i < ku; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l)\n+  for (i = ju; i < ku; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3)\n+  for (j = 0; j < 4; j++)\n+    for (i = ju; i < ku; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3)\n+  for (j = 0; j < 4; j++)\n+    for (i = ju; i < ku; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = ju; i < ku; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = ju; i < ku; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3)\n+  for (j = 0; j < 4; j++)\n+    for (i = ju; i < ku; i++)\n+      for (k = ku; k < ju; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3)\n+  for (j = ku; j < ju; j++)\n+    for (i = ju; i < ku; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+}\n+\n+void\n+f2 (void)\n+{\n+  long long int i, j, k;\n+  unsigned long long int j2, k2;\n+  #pragma omp for reduction(+: l)\n+  for (i = jll; i < kll; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l)\n+  for (i = jll; i < kll; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3)\n+  for (j = 0; j < 4; j++)\n+    for (i = jll; i < kll; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3)\n+  for (j = 0; j < 4; j++)\n+    for (i = jll; i < kll; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = jll; i < kll; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = jll; i < kll; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3)\n+  for (j = 0; j < 4; j++)\n+    for (i = jll; i < kll; i++)\n+      for (k = kll; k < jll; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3)\n+  for (j = kll; j < jll; j++)\n+    for (i = jll; i < kll; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+}\n+\n+void\n+f3 (void)\n+{\n+  unsigned long long int i, j, k;\n+  long long int j2, k2;\n+  #pragma omp for reduction(+: l)\n+  for (i = jull; i < kull; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l)\n+  for (i = jull; i < kull; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3)\n+  for (j = 0; j < 4; j++)\n+    for (i = jull; i < kull; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3)\n+  for (j = 0; j < 4; j++)\n+    for (i = jull; i < kull; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = jull; i < kull; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = jull; i < kull; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3)\n+  for (j = 0; j < 4; j++)\n+    for (i = jull; i < kull; i++)\n+      for (k = kull; k < jull; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3)\n+  for (j = kull; j < jull; j++)\n+    for (i = jull; i < kull; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+}\n+\n+int\n+main ()\n+{\n+  f0 ();\n+  f1 ();\n+  f2 ();\n+  f3 ();\n+  return 0;\n+}"}, {"sha": "b8a163c3cc7aed6b20e36c376a51c7e949bd3417", "filename": "libgomp/testsuite/libgomp.c/loop-14.c", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-14.c?ref=5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c", "patch": "@@ -0,0 +1,253 @@\n+/* { dg-do run } */\n+\n+volatile int ji = 100, ki = 2;\n+volatile unsigned int ju = 100, ku = 2;\n+volatile long long int jll = 100, kll = 2;\n+volatile unsigned long long int jull = 100, kull = 2;\n+unsigned long long l;\n+\n+void\n+f0 (void)\n+{\n+  int i, j, k;\n+  unsigned int j2, k2;\n+  #pragma omp for reduction(+: l) schedule(static, 2)\n+  for (i = ji; i < ki; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) schedule(static, 2)\n+  for (i = ji; i < ki; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j = 0; j < 4; j++)\n+    for (i = ji; i < ki; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j = 0; j < 4; j++)\n+    for (i = ji; i < ki; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = ji; i < ki; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = ji; i < ki; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j = 0; j < 4; j++)\n+    for (i = ji; i < ki; i++)\n+      for (k = ki + 10; k < ji - 10; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j = ki + 10; j < ji - 10; j++)\n+    for (i = ji; i < ki; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+}\n+\n+void\n+f1 (void)\n+{\n+  unsigned int i, j, k;\n+  int j2, k2;\n+  #pragma omp for reduction(+: l) schedule(static, 2)\n+  for (i = ju; i < ku; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) schedule(static, 2)\n+  for (i = ju; i < ku; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j = 0; j < 4; j++)\n+    for (i = ju; i < ku; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j = 0; j < 4; j++)\n+    for (i = ju; i < ku; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = ju; i < ku; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = ju; i < ku; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j = 0; j < 4; j++)\n+    for (i = ju; i < ku; i++)\n+      for (k = ku; k < ju; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j = ku; j < ju; j++)\n+    for (i = ju; i < ku; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+}\n+\n+void\n+f2 (void)\n+{\n+  long long int i, j, k;\n+  unsigned long long int j2, k2;\n+  #pragma omp for reduction(+: l) schedule(static, 2)\n+  for (i = jll; i < kll; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) schedule(static, 2)\n+  for (i = jll; i < kll; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j = 0; j < 4; j++)\n+    for (i = jll; i < kll; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j = 0; j < 4; j++)\n+    for (i = jll; i < kll; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = jll; i < kll; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = jll; i < kll; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j = 0; j < 4; j++)\n+    for (i = jll; i < kll; i++)\n+      for (k = kll; k < jll; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j = kll; j < jll; j++)\n+    for (i = jll; i < kll; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+}\n+\n+void\n+f3 (void)\n+{\n+  unsigned long long int i, j, k;\n+  long long int j2, k2;\n+  #pragma omp for reduction(+: l) schedule(static, 2)\n+  for (i = jull; i < kull; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) schedule(static, 2)\n+  for (i = jull; i < kull; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j = 0; j < 4; j++)\n+    for (i = jull; i < kull; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j = 0; j < 4; j++)\n+    for (i = jull; i < kull; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = jull; i < kull; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = jull; i < kull; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j = 0; j < 4; j++)\n+    for (i = jull; i < kull; i++)\n+      for (k = kull; k < jull; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(static, 2)\n+  for (j = kull; j < jull; j++)\n+    for (i = jull; i < kull; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+}\n+\n+int\n+main ()\n+{\n+  f0 ();\n+  f1 ();\n+  f2 ();\n+  f3 ();\n+  return 0;\n+}"}, {"sha": "e7cf3fc4699b7d06efe920b3581186c7cbd5480f", "filename": "libgomp/testsuite/libgomp.c/loop-15.c", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-15.c?ref=5a0f4dd39504905e6c72bd59b6bcecd264fbcb9c", "patch": "@@ -0,0 +1,253 @@\n+/* { dg-do run } */\n+\n+volatile int ji = 100, ki = 2;\n+volatile unsigned int ju = 100, ku = 2;\n+volatile long long int jll = 100, kll = 2;\n+volatile unsigned long long int jull = 100, kull = 2;\n+unsigned long long l;\n+\n+void\n+f0 (void)\n+{\n+  int i, j, k;\n+  unsigned int j2, k2;\n+  #pragma omp for reduction(+: l) schedule(runtime)\n+  for (i = ji; i < ki; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) schedule(runtime)\n+  for (i = ji; i < ki; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j = 0; j < 4; j++)\n+    for (i = ji; i < ki; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j = 0; j < 4; j++)\n+    for (i = ji; i < ki; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = ji; i < ki; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = ji; i < ki; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j = 0; j < 4; j++)\n+    for (i = ji; i < ki; i++)\n+      for (k = ki + 10; k < ji - 10; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j = ki + 10; j < ji - 10; j++)\n+    for (i = ji; i < ki; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+}\n+\n+void\n+f1 (void)\n+{\n+  unsigned int i, j, k;\n+  int j2, k2;\n+  #pragma omp for reduction(+: l) schedule(runtime)\n+  for (i = ju; i < ku; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) schedule(runtime)\n+  for (i = ju; i < ku; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j = 0; j < 4; j++)\n+    for (i = ju; i < ku; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j = 0; j < 4; j++)\n+    for (i = ju; i < ku; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = ju; i < ku; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = ju; i < ku; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j = 0; j < 4; j++)\n+    for (i = ju; i < ku; i++)\n+      for (k = ku; k < ju; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j = ku; j < ju; j++)\n+    for (i = ju; i < ku; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+}\n+\n+void\n+f2 (void)\n+{\n+  long long int i, j, k;\n+  unsigned long long int j2, k2;\n+  #pragma omp for reduction(+: l) schedule(runtime)\n+  for (i = jll; i < kll; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) schedule(runtime)\n+  for (i = jll; i < kll; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j = 0; j < 4; j++)\n+    for (i = jll; i < kll; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j = 0; j < 4; j++)\n+    for (i = jll; i < kll; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = jll; i < kll; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = jll; i < kll; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j = 0; j < 4; j++)\n+    for (i = jll; i < kll; i++)\n+      for (k = kll; k < jll; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j = kll; j < jll; j++)\n+    for (i = jll; i < kll; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+}\n+\n+void\n+f3 (void)\n+{\n+  unsigned long long int i, j, k;\n+  long long int j2, k2;\n+  #pragma omp for reduction(+: l) schedule(runtime)\n+  for (i = jull; i < kull; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) schedule(runtime)\n+  for (i = jull; i < kull; i++)\n+    l++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j = 0; j < 4; j++)\n+    for (i = jull; i < kull; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j = 0; j < 4; j++)\n+    for (i = jull; i < kull; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = jull; i < kull; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j2 = 0; j2 < 4; j2++)\n+    for (i = jull; i < kull; i++)\n+      for (k2 = 0; k2 < 5; k2 += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j = 0; j < 4; j++)\n+    for (i = jull; i < kull; i++)\n+      for (k = kull; k < jull; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+  #pragma omp parallel for reduction(+: l) collapse(3) schedule(runtime)\n+  for (j = kull; j < jull; j++)\n+    for (i = jull; i < kull; i++)\n+      for (k = 0; k < 5; k += 2)\n+\tl++;\n+  if (l != 0)\n+    __builtin_abort ();\n+}\n+\n+int\n+main ()\n+{\n+  f0 ();\n+  f1 ();\n+  f2 ();\n+  f3 ();\n+  return 0;\n+}"}]}