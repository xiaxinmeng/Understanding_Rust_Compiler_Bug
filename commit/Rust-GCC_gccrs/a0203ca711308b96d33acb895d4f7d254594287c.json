{"sha": "a0203ca711308b96d33acb895d4f7d254594287c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAyMDNjYTcxMTMwOGI5NmQzM2FjYjg5NWQ0ZjdkMjU0NTk0Mjg3Yw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2005-11-09T20:13:41Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2005-11-09T20:13:41Z"}, "message": "re PR other/4372 (#pragma weak pthread* inclusion causes applications to crash without a linker error when one forgets to link with -lpthread)\n\nPR other/4372\n* tree.h (IDENTIFIER_TRANSPARENT_ALIAS): New.\n(TREE_DEPRECATED): Adjust comment.  Check for a DECL.\n* c-common.c (handle_weakref_attribute): New.\n(c_common_attribute_table): Add weakref.\n* configure.ac (HAVE_GAS_WEAKREF): Check for weakref support\nin the assembler.\n* configure, config.in: Rebuilt.\n* defaults.h (ASM_OUTPUT_WEAKREF): Define if HAVE_GAS_WEAKREF.\n* doc/extend.texi: Document weakref attribute.\n* varasm.c (ultimate_transparent_alias_target): New\n(assemble_name): Use it.\n(weak_finish_1): Split out of...\n(weak_finish): ... and deal with weakrefs in...\n(weakref_targets): ... new list.\n(globalize_decl): Clean up weakref_targets.\n(do_assemble_alias): Handle weakrefs.\n(finish_aliases_1): Do not reject weakrefs to external symbols.\n(assemble_alias): Handle weakrefs.\n\nFrom-SVN: r106703", "tree": {"sha": "cdc3a1f501856957bef831df0b91b2b381edd2b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cdc3a1f501856957bef831df0b91b2b381edd2b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0203ca711308b96d33acb895d4f7d254594287c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0203ca711308b96d33acb895d4f7d254594287c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0203ca711308b96d33acb895d4f7d254594287c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0203ca711308b96d33acb895d4f7d254594287c/comments", "author": null, "committer": null, "parents": [{"sha": "317adebb1faac58d50f0e44906aa18edaf663759", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/317adebb1faac58d50f0e44906aa18edaf663759", "html_url": "https://github.com/Rust-GCC/gccrs/commit/317adebb1faac58d50f0e44906aa18edaf663759"}], "stats": {"total": 663, "additions": 628, "deletions": 35}, "files": [{"sha": "cdbf858843cf000f12fc1b903432c0dcc965b7d2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a0203ca711308b96d33acb895d4f7d254594287c", "patch": "@@ -1,3 +1,25 @@\n+2005-11-09  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR other/4372\n+\t* tree.h (IDENTIFIER_TRANSPARENT_ALIAS): New.\n+\t(TREE_DEPRECATED): Adjust comment.  Check for a DECL.\n+\t* c-common.c (handle_weakref_attribute): New.\n+\t(c_common_attribute_table): Add weakref.\n+\t* configure.ac (HAVE_GAS_WEAKREF): Check for weakref support\n+\tin the assembler.\n+\t* configure, config.in: Rebuilt.\n+\t* defaults.h (ASM_OUTPUT_WEAKREF): Define if HAVE_GAS_WEAKREF.\n+\t* doc/extend.texi: Document weakref attribute.\n+\t* varasm.c (ultimate_transparent_alias_target): New\n+\t(assemble_name): Use it.\n+\t(weak_finish_1): Split out of...\n+\t(weak_finish): ... and deal with weakrefs in...\n+\t(weakref_targets): ... new list.\n+\t(globalize_decl): Clean up weakref_targets.\n+\t(do_assemble_alias): Handle weakrefs.\n+\t(finish_aliases_1): Do not reject weakrefs to external symbols.\n+\t(assemble_alias): Handle weakrefs.\n+\n 2005-11-09  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/24716"}, {"sha": "450184110969651d91bbc547018ec60576238597", "filename": "gcc/c-common.c", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=a0203ca711308b96d33acb895d4f7d254594287c", "patch": "@@ -520,6 +520,7 @@ static tree handle_section_attribute (tree *, tree, tree, int, bool *);\n static tree handle_aligned_attribute (tree *, tree, tree, int, bool *);\n static tree handle_weak_attribute (tree *, tree, tree, int, bool *) ;\n static tree handle_alias_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_weakref_attribute (tree *, tree, tree, int, bool *) ;\n static tree handle_visibility_attribute (tree *, tree, tree, int,\n \t\t\t\t\t bool *);\n static tree handle_tls_model_attribute (tree *, tree, tree, int,\n@@ -599,6 +600,8 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_weak_attribute },\n   { \"alias\",                  1, 1, true,  false, false,\n \t\t\t      handle_alias_attribute },\n+  { \"weakref\",                0, 1, true,  false, false,\n+\t\t\t      handle_weakref_attribute },\n   { \"no_instrument_function\", 0, 0, true,  false, false,\n \t\t\t      handle_no_instrument_function_attribute },\n   { \"malloc\",                 0, 0, true,  false, false,\n@@ -4742,7 +4745,10 @@ handle_alias_attribute (tree *node, tree name, tree args,\n \tDECL_INITIAL (decl) = error_mark_node;\n       else\n \t{\n-\t  DECL_EXTERNAL (decl) = 0;\n+\t  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl)))\n+\t    DECL_EXTERNAL (decl) = 1;\n+\t  else\n+\t    DECL_EXTERNAL (decl) = 0;\n \t  TREE_STATIC (decl) = 1;\n \t}\n     }\n@@ -4755,6 +4761,40 @@ handle_alias_attribute (tree *node, tree name, tree args,\n   return NULL_TREE;\n }\n \n+/* Handle a \"weakref\" attribute; arguments as in struct\n+   attribute_spec.handler.  */\n+\n+static tree\n+handle_weakref_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n+\t\t\t  int flags, bool *no_add_attrs)\n+{\n+  tree attr = NULL_TREE;\n+\n+  /* The idea here is that `weakref(\"name\")' mutates into `weakref,\n+     alias(\"name\")', and weakref without arguments, in turn,\n+     implicitly adds weak. */\n+\n+  if (args)\n+    {\n+      attr = tree_cons (get_identifier (\"alias\"), args, attr);\n+      attr = tree_cons (get_identifier (\"weakref\"), NULL_TREE, attr);\n+\n+      *no_add_attrs = true;\n+    }\n+  else\n+    {\n+      if (lookup_attribute (\"alias\", DECL_ATTRIBUTES (*node)))\n+\terror (\"%Jweakref attribute must appear before alias attribute\",\n+\t       *node);\n+\n+      attr = tree_cons (get_identifier (\"weak\"), NULL_TREE, attr);\n+    }\n+\n+  decl_attributes (node, attr, flags);\n+\n+  return NULL_TREE;\n+}\n+\n /* Handle an \"visibility\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "3577c8c1d221f54e77a3ed370c74b46c74fb572e", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=a0203ca711308b96d33acb895d4f7d254594287c", "patch": "@@ -744,6 +744,12 @@\n #endif\n \n \n+/* Define if your assembler supports .weakref. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_GAS_WEAKREF\n+#endif\n+\n+\n /* Define to 1 if you have the `getchar_unlocked' function. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_GETCHAR_UNLOCKED"}, {"sha": "ba43b58a4c944441362a550e56fc35271e9548e3", "filename": "gcc/configure", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=a0203ca711308b96d33acb895d4f7d254594287c", "patch": "@@ -13988,6 +13988,43 @@ _ACEOF\n \n fi\n \n+echo \"$as_me:$LINENO: checking assembler for .weakref\" >&5\n+echo $ECHO_N \"checking assembler for .weakref... $ECHO_C\" >&6\n+if test \"${gcc_cv_as_weakref+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  gcc_cv_as_weakref=no\n+    if test $in_tree_gas = yes; then\n+    if test $gcc_cv_gas_vers -ge `expr \\( \\( 2 \\* 1000 \\) + 17 \\) \\* 1000 + 0`\n+  then gcc_cv_as_weakref=yes\n+fi\n+  elif test x$gcc_cv_as != x; then\n+    echo '\t.weakref foobar, barfnot' > conftest.s\n+    if { ac_try='$gcc_cv_as  -o conftest.o conftest.s >&5'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }\n+    then\n+\tgcc_cv_as_weakref=yes\n+    else\n+      echo \"configure: failed program was\" >&5\n+      cat conftest.s >&5\n+    fi\n+    rm -f conftest.o conftest.s\n+  fi\n+fi\n+echo \"$as_me:$LINENO: result: $gcc_cv_as_weakref\" >&5\n+echo \"${ECHO_T}$gcc_cv_as_weakref\" >&6\n+if test $gcc_cv_as_weakref = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_GAS_WEAKREF 1\n+_ACEOF\n+\n+fi\n+\n echo \"$as_me:$LINENO: checking assembler for .nsubspa comdat\" >&5\n echo $ECHO_N \"checking assembler for .nsubspa comdat... $ECHO_C\" >&6\n if test \"${gcc_cv_as_nsubspa_comdat+set}\" = set; then"}, {"sha": "5cee180e02190d96e5d745706051c3ba16f3d47f", "filename": "gcc/configure.ac", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=a0203ca711308b96d33acb895d4f7d254594287c", "patch": "@@ -1947,6 +1947,11 @@ gcc_GAS_CHECK_FEATURE([.weak], gcc_cv_as_weak,\n  [\t.weak foobar],,\n [AC_DEFINE(HAVE_GAS_WEAK, 1, [Define if your assembler supports .weak.])])\n \n+gcc_GAS_CHECK_FEATURE([.weakref], gcc_cv_as_weakref,\n+ [2,17,0],,\n+ [\t.weakref foobar, barfnot],,\n+[AC_DEFINE(HAVE_GAS_WEAKREF, 1, [Define if your assembler supports .weakref.])])\n+\n gcc_GAS_CHECK_FEATURE([.nsubspa comdat], gcc_cv_as_nsubspa_comdat,\n  [2,15,91],,\n  [\t.SPACE $TEXT$"}, {"sha": "9d82960e9876a07ec40ce148803ebdbebc5189b2", "filename": "gcc/defaults.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=a0203ca711308b96d33acb895d4f7d254594287c", "patch": "@@ -166,6 +166,27 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #endif\n #endif\n \n+/* This is how we tell the assembler that a symbol is a weak alias to\n+   another symbol that doesn't require the other symbol to be defined.\n+   Uses of the former will turn into weak uses of the latter, i.e.,\n+   uses that, in case the latter is undefined, will not cause errors,\n+   and will add it to the symbol table as weak undefined.  However, if\n+   the latter is referenced directly, a strong reference prevails.  */\n+#ifndef ASM_OUTPUT_WEAKREF\n+#if defined HAVE_GAS_WEAKREF\n+#define ASM_OUTPUT_WEAKREF(FILE, NAME, VALUE)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"\\t.weakref\\t\");\t\t\t\t\t\\\n+      assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+      fprintf ((FILE), \",\");\t\t\t\t\t\t\\\n+      assemble_name ((FILE), (VALUE));\t\t\t\t\t\\\n+      fprintf ((FILE), \"\\n\");\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+#endif\n+#endif\n+\n /* How to emit a .type directive.  */\n #ifndef ASM_OUTPUT_TYPE_DIRECTIVE\n #if defined TYPE_ASM_OP && defined TYPE_OPERAND_FMT"}, {"sha": "a796da6268500ed2f49edb079ff1430ea9705f6c", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=a0203ca711308b96d33acb895d4f7d254594287c", "patch": "@@ -2364,6 +2364,38 @@ also be used with non-function declarations.  Weak symbols are supported\n for ELF targets, and also for a.out targets when using the GNU assembler\n and linker.\n \n+@item weakref\n+@itemx weakref (\"@var{target}\")\n+@cindex @code{weakref} attribute\n+The @code{weakref} attribute marks a declaration as a weak reference.\n+Without arguments, it should be accompanied by an @code{alias} attribute\n+naming the target symbol.  Optionally, the @var{target} may be given as\n+an argument to @code{weakref} itself.  In either case, @code{weakref}\n+implicitly marks the declaration as @code{weak}.  Without a\n+@var{target}, given as an argument to @code{weakref} or to @code{alias},\n+@code{weakref} is equivalent to @code{weak}.\n+\n+@smallexample\n+extern int x() __attribute__ ((weakref (\"y\")));\n+/* is equivalent to... */\n+extern int x() __attribute__ ((weak, weakref, alias (\"y\")));\n+/* and to... */\n+extern int x() __attribute__ ((weakref));\n+extern int x() __attribute__ ((alias (\"y\")));\n+@end smallexample\n+\n+A weak reference is an alias that does not by itself require a\n+definition to be given for the target symbol.  If the target symbol is\n+only referenced through weak references, then the becomes a @code{weak}\n+undefined symbol.  If it is directly referenced, however, then such\n+strong references prevail, and a definition will be required for the\n+symbol, not necessarily in the same translation unit.\n+\n+The effect is equivalent to moving all references to the alias to a\n+separate translation unit, renaming the alias to the aliased symbol,\n+declaring it as weak, compiling the two separate translation units and\n+performing a reloadable link on them.\n+\n @item externally_visible\n @cindex @code{externally_visible} attribute.\n This attribute, attached to a global variable or function nullify"}, {"sha": "43444c85dc00fbb518715a09baaffec657c6caad", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a0203ca711308b96d33acb895d4f7d254594287c", "patch": "@@ -1,3 +1,9 @@\n+2005-11-09  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR other/4372\n+\t* gcc.dg/attr-weakref-1.c, gcc.dg/attr-weakref-1a.c: New test.\n+\t* g++.old-deja/g++.abi/vtable2.C: Use weakref instead of alias.\n+\n 2005-11-09  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/24716"}, {"sha": "a36cf0e7f175aef57e861b7c144f4d42b0d3ab25", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vtable2.C", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable2.C?ref=a0203ca711308b96d33acb895d4f7d254594287c", "patch": "@@ -1,5 +1,4 @@\n // { dg-do run  }\n-// { dg-require-alias \"\" }\n // { dg-options \"-fno-strict-aliasing\" }\n // Origin: Mark Mitchell <mark@codesourcery.com>\n \n@@ -125,8 +124,11 @@ void S4::s1 ()\n // These are tricks to allow us to get raw function pointers for\n // member functions.\n extern \"C\" {\n-  void S3_s3 () __attribute__((__alias__ (\"_ZN2S32s3Ev\")));\n-  void S4_s1 () __attribute__((__alias__ (\"_ZN2S42s1Ev\")));\n+  /* We can use weakref here without dg-require-weak, because we know\n+     the symbols are defined, so we don't actually issue the .weak\n+     directives.  */\n+  void S3_s3 () __attribute__((__weakref__ (\"_ZN2S32s3Ev\")));\n+  void S4_s1 () __attribute__((__weakref__ (\"_ZN2S42s1Ev\")));\n }\n \n // IA-64 uses function descriptors not function pointers in its vtables."}, {"sha": "df58be96c1350079ce9bc57449554fc479039427", "filename": "gcc/testsuite/gcc.dg/attr-weakref-1.c", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-weakref-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-weakref-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-weakref-1.c?ref=a0203ca711308b96d33acb895d4f7d254594287c", "patch": "@@ -0,0 +1,226 @@\n+// { dg-do run }\n+// { dg-additional-sources \" attr-weakref-1a.c\" }\n+// { dg-require-weak \"\" }\n+// { dg-options \"-O2\" }\n+\n+// Copyright 2005 Free Software Foundation, Inc.\n+// Contributed by Alexandre Oliva <aoliva@redhat.com>\n+\n+// Torture test for weakrefs.  The first letter of an identifier\n+// indicates whether/how it is defined; the second letter indicates\n+// whether it is part of a variable or function test; the number that\n+// follows is a test counter, and a letter that may follow enables\n+// multiple identifiers within the same test (e.g., multiple weakrefs\n+// or pointers to the same identifier).\n+\n+// Identifiers starting with W are weakrefs; those with p are\n+// pointers; those with g are global definitions; those with l are\n+// local definitions; those with w are expected to be weak undefined\n+// in the symbol table; those with u are expected to be marked as\n+// non-weak undefined in the symbol table.\n+\n+#include <stdlib.h>\n+\n+#define USED __attribute__((used))\n+\n+typedef int vtype;\n+\n+extern vtype wv1;\n+extern vtype Wv1a __attribute__((weakref (\"wv1\")));\n+static vtype *pv1a USED = &Wv1a;\n+extern vtype Wv1b __attribute__((weak, weakref, alias (\"wv1\")));\n+static vtype *pv1b USED = &Wv1b;\n+extern vtype Wv1c __attribute__((weakref));\n+extern vtype Wv1c __attribute__((alias (\"wv1\")));\n+static vtype *pv1c USED = &Wv1c;\n+\n+vtype gv2;\n+extern vtype Wv2a __attribute__((weakref (\"gv2\")));\n+static vtype *pv2a USED = &Wv2a;\n+\n+static vtype lv3;\n+extern vtype Wv3a __attribute__((weakref (\"lv3\")));\n+static vtype *pv3a USED = &Wv3a;\n+\n+extern vtype uv4;\n+extern vtype Wv4a __attribute__((weakref (\"uv4\")));\n+static vtype *pv4a USED = &Wv4a;\n+static vtype *pv4 USED = &uv4;\n+\n+extern vtype Wv5a __attribute__((weakref (\"uv5\")));\n+static vtype *pv5a USED = &Wv5a;\n+extern vtype uv5;\n+static vtype *pv5 USED = &uv5;\n+\n+extern vtype Wv6a __attribute__((weakref (\"wv6\")));\n+static vtype *pv6a USED = &Wv6a;\n+extern vtype wv6;\n+\n+extern vtype Wv7a __attribute__((weakref (\"uv7\")));\n+static vtype* USED fv7 (void) {\n+  return &Wv7a;\n+}\n+extern vtype uv7;\n+static vtype* USED fv7a (void) {\n+  return &uv7;\n+}\n+\n+extern vtype uv8;\n+static vtype* USED fv8a (void) {\n+  return &uv8;\n+}\n+extern vtype Wv8a __attribute__((weakref (\"uv8\")));\n+static vtype* USED fv8 (void) {\n+  return &Wv8a;\n+}\n+\n+extern vtype wv9 __attribute__((weak));\n+extern vtype Wv9a __attribute__((weakref (\"wv9\")));\n+static vtype *pv9a USED = &Wv9a;\n+\n+extern vtype Wv10a __attribute__((weakref (\"Wv10b\")));\n+extern vtype Wv10b __attribute__((weakref (\"Wv10c\")));\n+extern vtype Wv10c __attribute__((weakref (\"Wv10d\")));\n+extern vtype Wv10d __attribute__((weakref (\"wv10\")));\n+extern vtype wv10;\n+\n+extern vtype wv11;\n+extern vtype Wv11d __attribute__((weakref (\"wv11\")));\n+extern vtype Wv11c __attribute__((weakref (\"Wv11d\")));\n+extern vtype Wv11b __attribute__((weakref (\"Wv11c\")));\n+extern vtype Wv11a __attribute__((weakref (\"Wv11b\")));\n+\n+extern vtype Wv12 __attribute__((weakref (\"wv12\")));\n+extern vtype wv12 __attribute__((weak));\n+\n+extern vtype Wv13 __attribute__((weakref (\"wv13\")));\n+extern vtype wv13 __attribute__((weak));\n+\n+extern vtype Wv14a __attribute__((weakref (\"wv14\")));\n+extern vtype Wv14b __attribute__((weakref (\"wv14\")));\n+extern vtype wv14 __attribute__((weak));\n+\n+typedef void ftype(void);\n+\n+extern ftype wf1;\n+extern ftype Wf1a __attribute__((weakref (\"wf1\")));\n+static ftype *pf1a USED = &Wf1a;\n+extern ftype Wf1b __attribute__((weak, weakref, alias (\"wf1\")));\n+static ftype *pf1b USED = &Wf1b;\n+extern ftype Wf1c __attribute__((weakref));\n+extern ftype Wf1c __attribute__((alias (\"wf1\")));\n+static ftype *pf1c USED = &Wf1c;\n+\n+void gf2(void) {}\n+extern ftype Wf2a __attribute__((weakref (\"gf2\")));\n+static ftype *pf2a USED = &Wf2a;\n+\n+static void lf3(void) {}\n+extern ftype Wf3a __attribute__((weakref (\"lf3\")));\n+static ftype *pf3a USED = &Wf3a;\n+\n+extern ftype uf4;\n+extern ftype Wf4a __attribute__((weakref (\"uf4\")));\n+static ftype *pf4a USED = &Wf4a;\n+static ftype *pf4 USED = &uf4;\n+\n+extern ftype Wf5a __attribute__((weakref (\"uf5\")));\n+static ftype *pf5a USED = &Wf5a;\n+extern ftype uf5;\n+static ftype *pf5 USED = &uf5;\n+\n+extern ftype Wf6a __attribute__((weakref (\"wf6\")));\n+static ftype *pf6a USED = &Wf6a;\n+extern ftype wf6;\n+\n+extern ftype Wf7a __attribute__((weakref (\"uf7\")));\n+static ftype* USED ff7 (void) {\n+  return &Wf7a;\n+}\n+extern ftype uf7;\n+static ftype* USED ff7a (void) {\n+  return &uf7;\n+}\n+\n+extern ftype uf8;\n+static ftype* USED ff8a (void) {\n+  return &uf8;\n+}\n+extern ftype Wf8a __attribute__((weakref (\"uf8\")));\n+static ftype* USED ff8 (void) {\n+  return &Wf8a;\n+}\n+\n+extern ftype wf9 __attribute__((weak));\n+extern ftype Wf9a __attribute__((weakref (\"wf9\")));\n+static ftype *pf9a USED = &Wf9a;\n+\n+extern ftype Wf10a __attribute__((weakref (\"Wf10b\")));\n+extern ftype Wf10b __attribute__((weakref (\"Wf10c\")));\n+extern ftype Wf10c __attribute__((weakref (\"Wf10d\")));\n+extern ftype Wf10d __attribute__((weakref (\"wf10\")));\n+extern ftype wf10;\n+\n+extern ftype wf11;\n+extern ftype Wf11d __attribute__((weakref (\"wf11\")));\n+extern ftype Wf11c __attribute__((weakref (\"Wf11d\")));\n+extern ftype Wf11b __attribute__((weakref (\"Wf11c\")));\n+extern ftype Wf11a __attribute__((weakref (\"Wf11b\")));\n+\n+extern ftype Wf12 __attribute__((weakref (\"wf12\")));\n+extern ftype wf12 __attribute__((weak));\n+\n+extern ftype Wf13 __attribute__((weakref (\"wf13\")));\n+extern ftype wf13 __attribute__((weak));\n+\n+extern ftype Wf14a __attribute__((weakref (\"wf14\")));\n+extern ftype Wf14b __attribute__((weakref (\"wf14\")));\n+extern ftype wf14 __attribute__((weak));\n+\n+#define chk(p) do { if (!p) abort (); } while (0)\n+\n+int main () {\n+  chk (!pv1a);\n+  chk (!pv1b);\n+  chk (!pv1c);\n+  chk (pv2a);\n+  chk (pv3a);\n+  chk (pv4a);\n+  chk (pv4);\n+  chk (pv5a);\n+  chk (pv5);\n+  chk (!pv6a);\n+  chk (fv7 ());\n+  chk (fv7a ());\n+  chk (fv8 ());\n+  chk (fv8a ());\n+  chk (!pv9a);\n+  chk (!&Wv10a);\n+  chk (!&Wv11a);\n+  chk (!&Wv12);\n+  chk (!&wv12);\n+  chk (!&wv13);\n+  chk (!&Wv14a);\n+\n+  chk (!pf1a);\n+  chk (!pf1b);\n+  chk (!pf1c);\n+  chk (pf2a);\n+  chk (pf3a);\n+  chk (pf4a);\n+  chk (pf4);\n+  chk (pf5a);\n+  chk (pf5);\n+  chk (!pf6a);\n+  chk (ff7 ());\n+  chk (ff7a ());\n+  chk (ff8 ());\n+  chk (ff8a ());\n+  chk (!pf9a);\n+  chk (!&Wf10a);\n+  chk (!&Wf11a);\n+  chk (!&Wf12);\n+  chk (!&wf12);\n+  chk (!&wf13);\n+  chk (!&Wf14a);\n+}"}, {"sha": "5ce1e4e72da1952762aef0c296ab53a3399b1094", "filename": "gcc/testsuite/gcc.dg/attr-weakref-1a.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-weakref-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-weakref-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-weakref-1a.c?ref=a0203ca711308b96d33acb895d4f7d254594287c", "patch": "@@ -0,0 +1,8 @@\n+int uv4;\n+int uv5;\n+int uv7;\n+int uv8;\n+void uf4 (void) {}\n+void uf5 (void) {}\n+void uf7 (void) {}\n+void uf8 (void) {}"}, {"sha": "0df8b3c28d194c70ba7801f7a816ed8156876f75", "filename": "gcc/tree.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a0203ca711308b96d33acb895d4f7d254594287c", "patch": "@@ -428,6 +428,9 @@ struct tree_common GTY(())\n \tTREE_DEPRECATED in\n \t   ..._DECL\n \n+\tIDENTIFIER_TRANSPARENT_ALIAS in\n+\t   IDENTIFIER_NODE\n+\n    visited:\n \n    \tUsed in tree traversals to mark visited nodes.\n@@ -1042,9 +1045,15 @@ extern void tree_operand_check_failed (int, enum tree_code,\n    In a BLOCK node, this is BLOCK_HANDLER_BLOCK.  */\n #define TREE_PROTECTED(NODE) ((NODE)->common.protected_flag)\n \n-/* Nonzero in an IDENTIFIER_NODE if the use of the name is defined as a\n+/* Nonzero in a _DECL if the use of the name is defined as a\n    deprecated feature by __attribute__((deprecated)).  */\n-#define TREE_DEPRECATED(NODE) ((NODE)->common.deprecated_flag)\n+#define TREE_DEPRECATED(NODE) \\\n+  ((NODE)->common.deprecated_flag)\n+\n+/* Nonzero in an IDENTIFIER_NODE if the name is a local alias, whose\n+   uses are to be substituted for uses of the TREE_CHAINed identifier.  */\n+#define IDENTIFIER_TRANSPARENT_ALIAS(NODE) \\\n+  (IDENTIFIER_NODE_CHECK (NODE)->common.deprecated_flag)\n \n /* Value of expression is function invariant.  A strict subset of\n    TREE_CONSTANT, such an expression is constant over any one function"}, {"sha": "f9fa0fdf181215761dbf4cf695f44a99ca98c7ba", "filename": "gcc/varasm.c", "status": "modified", "additions": 208, "deletions": 29, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0203ca711308b96d33acb895d4f7d254594287c/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=a0203ca711308b96d33acb895d4f7d254594287c", "patch": "@@ -1995,6 +1995,23 @@ mark_decl_referenced (tree decl)\n      which do not need to be marked.  */\n }\n \n+static inline tree\n+ultimate_transparent_alias_target (tree *alias)\n+{\n+  tree target = *alias;\n+\n+  if (IDENTIFIER_TRANSPARENT_ALIAS (target))\n+    {\n+      gcc_assert (TREE_CHAIN (target));\n+      target = ultimate_transparent_alias_target (&TREE_CHAIN (target));\n+      gcc_assert (! IDENTIFIER_TRANSPARENT_ALIAS (target)\n+\t\t  && ! TREE_CHAIN (target));\n+      *alias = target;\n+    }\n+\n+  return target;\n+}\n+\n /* Output to FILE (an assembly file) a reference to NAME.  If NAME\n    starts with a *, the rest of NAME is output verbatim.  Otherwise\n    NAME is transformed in a target-specific way (usually by the\n@@ -2024,7 +2041,12 @@ assemble_name (FILE *file, const char *name)\n \n   id = maybe_get_identifier (real_name);\n   if (id)\n-    mark_referenced (id);\n+    {\n+      mark_referenced (id);\n+      ultimate_transparent_alias_target (&id);\n+      name = IDENTIFIER_POINTER (id);\n+      gcc_assert (! TREE_CHAIN (id));\n+    }\n \n   assemble_name_raw (file, name);\n }\n@@ -4464,35 +4486,121 @@ declare_weak (tree decl)\n   mark_weak (decl);\n }\n \n-/* Emit any pending weak declarations.  */\n-\n-void\n-weak_finish (void)\n+static void\n+weak_finish_1 (tree decl)\n {\n-  tree t;\n-\n-  for (t = weak_decls; t; t = TREE_CHAIN (t))\n-    {\n-      tree decl = TREE_VALUE (t);\n #if defined (ASM_WEAKEN_DECL) || defined (ASM_WEAKEN_LABEL)\n-      const char *const name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+  const char *const name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n #endif\n \n-      if (! TREE_USED (decl))\n-\tcontinue;\n+  if (! TREE_USED (decl))\n+    return;\n+\n+  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl))\n+      && lookup_attribute (\"alias\", DECL_ATTRIBUTES (decl)))\n+    return;\n \n #ifdef ASM_WEAKEN_DECL\n-      ASM_WEAKEN_DECL (asm_out_file, decl, name, NULL);\n+  ASM_WEAKEN_DECL (asm_out_file, decl, name, NULL);\n #else\n #ifdef ASM_WEAKEN_LABEL\n-      ASM_WEAKEN_LABEL (asm_out_file, name);\n+  ASM_WEAKEN_LABEL (asm_out_file, name);\n #else\n #ifdef ASM_OUTPUT_WEAK_ALIAS\n-      warning (0, \"only weak aliases are supported in this configuration\");\n-      return;\n+  {\n+    static bool warn_once = 0;\n+    if (! warn_once)\n+      {\n+\twarning (0, \"only weak aliases are supported in this configuration\");\n+\twarn_once = 1;\n+      }\n+    return;\n+  }\n+#endif\n #endif\n #endif\n+}\n+\n+/* This TREE_LIST contains weakref targets.  */\n+\n+static GTY(()) tree weakref_targets;\n+\n+/* Forward declaration.  */\n+static tree find_decl_and_mark_needed (tree decl, tree target);\n+\n+/* Emit any pending weak declarations.  */\n+\n+void\n+weak_finish (void)\n+{\n+  tree t;\n+\n+  for (t = weakref_targets; t; t = TREE_CHAIN (t))\n+    {\n+      tree alias_decl = TREE_PURPOSE (t);\n+      tree target = ultimate_transparent_alias_target (&TREE_VALUE (t));\n+\n+      if (! TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (alias_decl)))\n+\t/* Remove alias_decl from the weak list, but leave entries for\n+\t   the target alone.  */\n+\ttarget = NULL_TREE;\n+#ifndef ASM_OUTPUT_WEAKREF\n+      else if (! TREE_SYMBOL_REFERENCED (target))\n+\t{\n+# ifdef ASM_WEAKEN_LABEL\n+\t  ASM_WEAKEN_LABEL (asm_out_file, IDENTIFIER_POINTER (target));\n+# else\n+\t  tree decl = find_decl_and_mark_needed (alias_decl, target);\n+\n+\t  if (! decl)\n+\t    {\n+\t      decl = build_decl (TREE_CODE (alias_decl), target,\n+\t\t\t\t TREE_TYPE (alias_decl));\n+\n+\t      DECL_EXTERNAL (decl) = 1;\n+\t      TREE_PUBLIC (decl) = 1;\n+\t      DECL_ARTIFICIAL (decl) = 1;\n+\t      TREE_NOTHROW (decl) = TREE_NOTHROW (alias_decl);\n+\t      TREE_USED (decl) = 1;\n+\t    }\n+\n+\t  weak_finish_1 (decl);\n+# endif\n+\t}\n #endif\n+\n+      {\n+\ttree *p;\n+\ttree t2;\n+\n+\t/* Remove the alias and the target from the pending weak list\n+\t   so that we do not emit any .weak directives for the former,\n+\t   nor multiple .weak directives for the latter.  */\n+\tfor (p = &weak_decls; (t2 = *p) ; )\n+\t  {\n+\t    if (TREE_VALUE (t2) == alias_decl\n+\t\t|| target == DECL_ASSEMBLER_NAME (TREE_VALUE (t2)))\n+\t      *p = TREE_CHAIN (t2);\n+\t    else\n+\t      p = &TREE_CHAIN (t2);\n+\t  }\n+\n+\t/* Remove other weakrefs to the same target, to speed things up.  */\n+\tfor (p = &TREE_CHAIN (t); (t2 = *p) ; )\n+\t  {\n+\t    if (target == ultimate_transparent_alias_target (&TREE_VALUE (t2)))\n+\t      *p = TREE_CHAIN (t2);\n+\t    else\n+\t      p = &TREE_CHAIN (t2);\n+\t  }\n+      }\n+    }\n+\n+  for (t = weak_decls; t; t = TREE_CHAIN (t))\n+    {\n+      tree decl = TREE_VALUE (t);\n+\n+      weak_finish_1 (decl);\n     }\n }\n \n@@ -4523,6 +4631,18 @@ globalize_decl (tree decl)\n \t  else\n \t    p = &TREE_CHAIN (t);\n \t}\n+\n+\t/* Remove weakrefs to the same target from the pending weakref\n+\t   list, for the same reason.  */\n+\tfor (p = &weakref_targets; (t = *p) ; )\n+\t  {\n+\t    if (DECL_ASSEMBLER_NAME (decl)\n+\t\t== ultimate_transparent_alias_target (&TREE_VALUE (t)))\n+\t      *p = TREE_CHAIN (t);\n+\t    else\n+\t      p = &TREE_CHAIN (t);\n+\t  }\n+\n       return;\n     }\n #elif defined(ASM_MAKE_LABEL_LINKONCE)\n@@ -4596,14 +4716,35 @@ find_decl_and_mark_needed (tree decl, tree target)\n    tree node is DECL to have the value of the tree node TARGET.  */\n \n static void\n-do_assemble_alias (tree decl, tree target ATTRIBUTE_UNUSED)\n+do_assemble_alias (tree decl, tree target)\n {\n   if (TREE_ASM_WRITTEN (decl))\n     return;\n \n   TREE_ASM_WRITTEN (decl) = 1;\n   TREE_ASM_WRITTEN (DECL_ASSEMBLER_NAME (decl)) = 1;\n \n+  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl)))\n+    {\n+      ultimate_transparent_alias_target (&target);\n+\n+      if (!TREE_SYMBOL_REFERENCED (target))\n+\tweakref_targets = tree_cons (decl, target, weakref_targets);\n+\n+#ifdef ASM_OUTPUT_WEAKREF\n+      ASM_OUTPUT_WEAKREF (asm_out_file,\n+\t\t\t  IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)),\n+\t\t\t  IDENTIFIER_POINTER (target));\n+#else\n+      if (!SUPPORTS_WEAK)\n+\t{\n+\t  error (\"%Jweakref is not supported in this configuration\", decl);\n+\t  return;\n+\t}\n+#endif\n+      return;\n+    }\n+\n #ifdef ASM_OUTPUT_DEF\n   /* Make name accessible from other files, if appropriate.  */\n \n@@ -4638,6 +4779,17 @@ do_assemble_alias (tree decl, tree target ATTRIBUTE_UNUSED)\n \t*p = TREE_CHAIN (t);\n       else\n \tp = &TREE_CHAIN (t);\n+\n+    /* Remove weakrefs to the same target from the pending weakref\n+       list, for the same reason.  */\n+    for (p = &weakref_targets; (t = *p) ; )\n+      {\n+\tif (DECL_ASSEMBLER_NAME (decl)\n+\t    == ultimate_transparent_alias_target (&TREE_VALUE (t)))\n+\t  *p = TREE_CHAIN (t);\n+\telse\n+\t  p = &TREE_CHAIN (t);\n+      }\n   }\n #endif\n }\n@@ -4657,9 +4809,13 @@ finish_aliases_1 (void)\n \n       target_decl = find_decl_and_mark_needed (p->decl, p->target);\n       if (target_decl == NULL)\n-\terror (\"%q+D aliased to undefined symbol %qs\",\n-\t       p->decl, IDENTIFIER_POINTER (p->target));\n-      else if (DECL_EXTERNAL (target_decl))\n+\t{\n+\t  if (! lookup_attribute (\"weakref\", DECL_ATTRIBUTES (p->decl)))\n+\t    error (\"%q+D aliased to undefined symbol %qs\",\n+\t\t   p->decl, IDENTIFIER_POINTER (p->target));\n+\t}\n+      else if (DECL_EXTERNAL (target_decl)\n+\t       && ! lookup_attribute (\"weakref\", DECL_ATTRIBUTES (p->decl)))\n \terror (\"%q+D aliased to external symbol %qs\",\n \t       p->decl, IDENTIFIER_POINTER (p->target));\n     }\n@@ -4688,19 +4844,41 @@ void\n assemble_alias (tree decl, tree target)\n {\n   tree target_decl;\n+  bool is_weakref = false;\n \n+  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl)))\n+    {\n+      tree alias = DECL_ASSEMBLER_NAME (decl);\n+\n+      is_weakref = true;\n+\n+      ultimate_transparent_alias_target (&target);\n+\n+      if (alias == target)\n+\terror (\"%Jweakref %qD ultimately targets itself\", decl, decl);\n+      else\n+\t{\n+#ifndef ASM_OUTPUT_WEAKREF\n+\t  IDENTIFIER_TRANSPARENT_ALIAS (alias) = 1;\n+\t  TREE_CHAIN (alias) = target;\n+#endif\n+\t}\n+    }\n+  else\n+    {\n #if !defined (ASM_OUTPUT_DEF)\n # if !defined(ASM_OUTPUT_WEAK_ALIAS) && !defined (ASM_WEAKEN_DECL)\n-  error (\"%Jalias definitions not supported in this configuration\", decl);\n-  return;\n-# else\n-  if (!DECL_WEAK (decl))\n-    {\n-      error (\"%Jonly weak aliases are supported in this configuration\", decl);\n+      error (\"%Jalias definitions not supported in this configuration\", decl);\n       return;\n-    }\n+# else\n+      if (!DECL_WEAK (decl))\n+\t{\n+\t  error (\"%Jonly weak aliases are supported in this configuration\", decl);\n+\t  return;\n+\t}\n # endif\n #endif\n+    }\n \n   /* We must force creation of DECL_RTL for debug info generation, even though\n      we don't use it here.  */\n@@ -4710,7 +4888,8 @@ assemble_alias (tree decl, tree target)\n   /* A quirk of the initial implementation of aliases required that the user\n      add \"extern\" to all of them.  Which is silly, but now historical.  Do\n      note that the symbol is in fact locally defined.  */\n-  DECL_EXTERNAL (decl) = 0;\n+  if (! is_weakref)\n+    DECL_EXTERNAL (decl) = 0;\n \n   /* Allow aliases to aliases.  */\n   if (TREE_CODE (decl) == FUNCTION_DECL)"}]}