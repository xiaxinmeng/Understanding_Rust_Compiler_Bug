{"sha": "4d3814a514c4854cdc44242d383ea245c413b1d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQzODE0YTUxNGM0ODU0Y2RjNDQyNDJkMzgzZWEyNDVjNDEzYjFkNQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-10-05T10:42:24Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-10-05T10:42:24Z"}, "message": "value-prof.c (gimple_divmod_fixed_value): Work on SSA form.\n\n2010-10-05  Richard Guenther  <rguenther@suse.de>\n\n\t* value-prof.c (gimple_divmod_fixed_value): Work on SSA form.\n\t(gimple_mod_pow2): Likewise.\n\t(gimple_mod_subtract): Likewise.\n\t(gimple_ic): Likewise.\n\t(gimple_stringop_fixed_value): Likewise.\n\t* tree-profile.c (tree_init_edge_profiler): Mark profile\n\tfunctions nothrow and leaf.\n\t(add_abnormal_goto_call_edges): Remove.\n\t(tree_gen_edge_profiler): Work on SSA form.\n\t(tree_gen_ic_profiler): Likewise.  Simplify.\n\t(do_tree_profiling): Update SSA form.\n\t(pass_tree_profile): Remove.\n\t(do_tree_profiling): Likewise.\n\t(gate_tree_profile_ipa): New function.\n\t(pass_ipa_tree_profile): New.\n\t(tree_profiling): Re-write as IPA pass.  Properly drop const/pure\n\tstate of instrumented functions.\n\t* passes.c (init_optimization_passes): Remove early non-SSA\n\tinlining.  Move profiling after early optimizations.\n\t* ipa-inline.c (cgraph_gate_ipa_early_inlining): Remove.\n\t(pass_ipa_early_inline): Likewise.\n\t* tree-pass.h (pass_ipa_early_inline): Remove.\n\t(pass_tree_profile): Likewise.\n\t(pass_ipa_tree_profile): Declare.\n\n\t* gcc.dg/tree-prof/val-prof-1.c: Adjust.\n\t* gcc.dg/tree-prof/val-prof-2.c: Likewise.\n\t* gcc.dg/tree-prof/val-prof-3.c: Likewise.\n\t* gcc.dg/tree-prof/val-prof-4.c: Likewise.\n\t* gcc.dg/tree-prof/val-prof-5.c: Likewise.\n\t* gcc.dg/tree-prof/val-prof-7.c: Likewise.\n\t* gcc.dg/tree-prof/stringop-1.c: Likewise.\n\t* gcc.dg/tree-prof/stringop-2.c: Likewise.\n\t* gcc.dg/tree-prof/ic-misattribution-1.c: Likewise.\n\t* gcc.dg/tree-prof/indir-call-prof.c: Likewise.\n\t* gcc.dg/tree-prof/update-loopch.c: Likewise.\n\t* g++.dg/tree-prof/indir-call-prof.C: Likewise.\n\t* g++.dg/tree-prof/inline_mismatch_args.C: Likewise.\n\t* gcc.dg/tree-prof/tracer-1.c: Likewise.\n\t* gcc.dg/tree-ssa/inline-4.c: Likewise.\n\t* gcc.dg/tree-ssa/inline-3.c: Likewise.\n\t* gcc.dg/tree-ssa/20080530.c: Likewise.\n\t* g++.dg/tree-ssa/inline-3.C: Likewise.\n\t* g++.dg/tree-ssa/inline-1.C: Likewise.\n\t* g++.dg/tree-ssa/inline-2.C: Likewise.\n\t* gcc.dg/profile-dir-1.c: Likewise.\n\t* gcc.dg/profile-dir-2.c: Likewise.\n\t* gcc.dg/profile-dir-3.c: Likewise.\n\nFrom-SVN: r164986", "tree": {"sha": "ff7a8ef56d2fdbc4a060af939444fce16b626c97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff7a8ef56d2fdbc4a060af939444fce16b626c97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d3814a514c4854cdc44242d383ea245c413b1d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d3814a514c4854cdc44242d383ea245c413b1d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d3814a514c4854cdc44242d383ea245c413b1d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d3814a514c4854cdc44242d383ea245c413b1d5/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "65b1d8ea3ed53d03f92a614c93faf637fa708772", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65b1d8ea3ed53d03f92a614c93faf637fa708772", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65b1d8ea3ed53d03f92a614c93faf637fa708772"}], "stats": {"total": 633, "additions": 375, "deletions": 258}, "files": [{"sha": "7304d1ef85884344365eba34d952ed1247aea7e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,3 +1,30 @@\n+2010-10-05  Richard Guenther  <rguenther@suse.de>\n+\n+\t* value-prof.c (gimple_divmod_fixed_value): Work on SSA form.\n+\t(gimple_mod_pow2): Likewise.\n+\t(gimple_mod_subtract): Likewise.\n+\t(gimple_ic): Likewise.\n+\t(gimple_stringop_fixed_value): Likewise.\n+\t* tree-profile.c (tree_init_edge_profiler): Mark profile\n+\tfunctions nothrow and leaf.\n+\t(add_abnormal_goto_call_edges): Remove.\n+\t(tree_gen_edge_profiler): Work on SSA form.\n+\t(tree_gen_ic_profiler): Likewise.  Simplify.\n+\t(do_tree_profiling): Update SSA form.\n+\t(pass_tree_profile): Remove.\n+\t(do_tree_profiling): Likewise.\n+\t(gate_tree_profile_ipa): New function.\n+\t(pass_ipa_tree_profile): New.\n+\t(tree_profiling): Re-write as IPA pass.  Properly drop const/pure\n+\tstate of instrumented functions.\n+\t* passes.c (init_optimization_passes): Remove early non-SSA\n+\tinlining.  Move profiling after early optimizations.\n+\t* ipa-inline.c (cgraph_gate_ipa_early_inlining): Remove.\n+\t(pass_ipa_early_inline): Likewise.\n+\t* tree-pass.h (pass_ipa_early_inline): Remove.\n+\t(pass_tree_profile): Likewise.\n+\t(pass_ipa_tree_profile): Declare.\n+\n 2010-10-05  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n             Christian Borntraeger  <Christian.Borntraeger@de.ibm.com>\n "}, {"sha": "8d9db0b16e3e50b1812a65ee744c99af061d1975", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1841,36 +1841,6 @@ struct gimple_opt_pass pass_early_inline =\n  }\n };\n \n-/* When inlining shall be performed.  */\n-static bool\n-cgraph_gate_ipa_early_inlining (void)\n-{\n-  return (flag_early_inlining\n-\t  && !in_lto_p\n-\t  && (flag_branch_probabilities || flag_test_coverage\n-\t      || profile_arc_flag));\n-}\n-\n-/* IPA pass wrapper for early inlining pass.  We need to run early inlining\n-   before tree profiling so we have stand alone IPA pass for doing so.  */\n-struct simple_ipa_opt_pass pass_ipa_early_inline =\n-{\n- {\n-  SIMPLE_IPA_PASS,\n-  \"einline_ipa\",\t\t\t/* name */\n-  cgraph_gate_ipa_early_inlining,\t/* gate */\n-  NULL,\t\t\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_INLINE_HEURISTICS,\t\t\t/* tv_id */\n-  0,\t                                /* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_cgraph \t\t        /* todo_flags_finish */\n- }\n-};\n \n /* See if statement might disappear after inlining.  We are not terribly\n    sophisficated, basically looking for simple abstraction penalty wrappers.  */"}, {"sha": "1308ce954f0084e9460dc68e5dbd7bb05918a001", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -746,18 +746,10 @@ init_optimization_passes (void)\n   p = &all_small_ipa_passes;\n   NEXT_PASS (pass_ipa_free_lang_data);\n   NEXT_PASS (pass_ipa_function_and_variable_visibility);\n-  NEXT_PASS (pass_ipa_early_inline);\n-    {\n-      struct opt_pass **p = &pass_ipa_early_inline.pass.sub;\n-      NEXT_PASS (pass_early_inline);\n-      NEXT_PASS (pass_inline_parameters);\n-      NEXT_PASS (pass_rebuild_cgraph_edges);\n-    }\n   NEXT_PASS (pass_early_local_passes);\n     {\n       struct opt_pass **p = &pass_early_local_passes.pass.sub;\n       NEXT_PASS (pass_fixup_cfg);\n-      NEXT_PASS (pass_tree_profile);\n       NEXT_PASS (pass_init_datastructures);\n       NEXT_PASS (pass_expand_omp);\n \n@@ -802,6 +794,7 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_rebuild_cgraph_edges);\n       NEXT_PASS (pass_inline_parameters);\n     }\n+  NEXT_PASS (pass_ipa_tree_profile);\n   NEXT_PASS (pass_ipa_increase_alignment);\n   NEXT_PASS (pass_ipa_matrix_reorg);\n   NEXT_PASS (pass_ipa_lower_emutls);"}, {"sha": "3471b51c2f6977de2795eb26ced08c3ab21fd4d4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,3 +1,29 @@\n+2010-10-05  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-prof/val-prof-1.c: Adjust.\n+\t* gcc.dg/tree-prof/val-prof-2.c: Likewise.\n+\t* gcc.dg/tree-prof/val-prof-3.c: Likewise.\n+\t* gcc.dg/tree-prof/val-prof-4.c: Likewise.\n+\t* gcc.dg/tree-prof/val-prof-5.c: Likewise.\n+\t* gcc.dg/tree-prof/val-prof-7.c: Likewise.\n+\t* gcc.dg/tree-prof/stringop-1.c: Likewise.\n+\t* gcc.dg/tree-prof/stringop-2.c: Likewise.\n+\t* gcc.dg/tree-prof/ic-misattribution-1.c: Likewise.\n+\t* gcc.dg/tree-prof/indir-call-prof.c: Likewise.\n+\t* gcc.dg/tree-prof/update-loopch.c: Likewise.\n+\t* g++.dg/tree-prof/indir-call-prof.C: Likewise.\n+\t* g++.dg/tree-prof/inline_mismatch_args.C: Likewise.\n+\t* gcc.dg/tree-prof/tracer-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/inline-4.c: Likewise.\n+\t* gcc.dg/tree-ssa/inline-3.c: Likewise.\n+\t* gcc.dg/tree-ssa/20080530.c: Likewise.\n+\t* g++.dg/tree-ssa/inline-3.C: Likewise.\n+\t* g++.dg/tree-ssa/inline-1.C: Likewise.\n+\t* g++.dg/tree-ssa/inline-2.C: Likewise.\n+\t* gcc.dg/profile-dir-1.c: Likewise.\n+\t* gcc.dg/profile-dir-2.c: Likewise.\n+\t* gcc.dg/profile-dir-3.c: Likewise.\n+\n 2010-10-05  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/45877"}, {"sha": "80b41865c0c4ac456d833a0dcc271ff843554d49", "filename": "gcc/testsuite/g++.dg/tree-prof/indir-call-prof.C", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Findir-call-prof.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Findir-call-prof.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Findir-call-prof.C?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 -fdump-tree-optimized -fdump-tree-tree_profile\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -fdump-ipa-tree_profile_ipa\" } */\n \n struct A {\n   A () {}\n@@ -15,6 +15,7 @@ struct B : public A {\n   { return 1; }\n };\n \n+void * __attribute__((noinline,noclone)) wrap (void *p) { return p; }\n int\n main (void)\n {\n@@ -23,17 +24,16 @@ main (void)\n   \n   A* p;\n \n-  p = &a;\n+  p = (A *)wrap ((void *)&a);\n   p->AA ();\n \n-  p = &b;\n+  p = (B *)wrap ((void *)&b);\n   p->AA ();\n   \n   return 0;\n }\n \n-/* { dg-final-use { scan-tree-dump \"Indirect call -> direct call.* AA transformation on insn\" \"tree_profile\"} } */\n-/* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */                                                                                \n-/* { dg-final-use { cleanup-tree-dump \"optimized\" } } */                                                                                              \n-/* { dg-final-use { cleanup-tree-dump \"tree_profile\" } } */                                                                                           \n-\n+/* { dg-final-use { scan-ipa-dump \"Indirect call -> direct call.* AA transformation on insn\" \"tree_profile_ipa\" } } */\n+/* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\" } } */\n+/* { dg-final-use { cleanup-tree-dump \"optimized\" } } */\n+/* { dg-final-use { cleanup-ipa-dump \"tree_profile_ipa\" } } */"}, {"sha": "0049a5df96cee2894f62990c84416f0429c1de44", "filename": "gcc/testsuite/g++.dg/tree-prof/inline_mismatch_args.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Finline_mismatch_args.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Finline_mismatch_args.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Finline_mismatch_args.C?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 -fdump-tree-einline2\" } */\n+/* { dg-options \"-O2 -fdump-tree-einline\" } */\n class DocId {\n  public:\n  DocId() { }\n@@ -31,6 +31,6 @@ int main(void)\n  baz.Bar(&baz, gid);\n  return 0;\n }\n-/* { dg-final-use { scan-tree-dump \"Inlining .*Super::Foo\" \"einline2\"} } */                                                                                \n-/* { dg-final-use { scan-tree-dump-not \"mismatched arguments\" \"einline2\"} } */                                                                 \n+/* { dg-final-use { scan-tree-dump \"Inlining .*Super::Foo\" \"einline\" } } */\n+/* { dg-final-use { scan-tree-dump-not \"mismatched arguments\" \"einline\" } } */\n /* { dg-final-use { cleanup-tree-dump \"einline2\" } } */"}, {"sha": "95b7d0609e96c39296b33bf0ee48ec7a850ee2bc", "filename": "gcc/testsuite/g++.dg/tree-ssa/inline-1.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Finline-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Finline-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Finline-1.C?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-einline2\" } */\n+/* { dg-options \"-O2 -fdump-tree-einline\" } */\n /* { dg-add-options bind_pic_locally } */\n \n namespace std {\n@@ -31,6 +31,6 @@ int main(int argc, char **argv)\n   foreach (argv, argv + argc, inline_me_too);\n }\n \n-/* { dg-final { scan-tree-dump-times \"Inlining void inline_me\\\\(\" 1 \"einline2\"} } */\n-/* { dg-final { scan-tree-dump-times \"Inlining void inline_me_too\\\\(\" 1 \"einline2\"} } */\n-/* { dg-final { cleanup-tree-dump \"einline2\" } } */\n+/* { dg-final { scan-tree-dump-times \"Inlining void inline_me\\\\(\" 1 \"einline\"} } */\n+/* { dg-final { scan-tree-dump-times \"Inlining void inline_me_too\\\\(\" 1 \"einline\"} } */\n+/* { dg-final { cleanup-tree-dump \"einline\" } } */"}, {"sha": "656cba0312c907475886145e30869e21071106a1", "filename": "gcc/testsuite/g++.dg/tree-ssa/inline-2.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Finline-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Finline-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Finline-2.C?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-einline2\" } */\n+/* { dg-options \"-O2 -fdump-tree-einline\" } */\n /* { dg-add-options bind_pic_locally } */\n \n namespace std {\n@@ -31,6 +31,6 @@ int main(int argc, char **argv)\n   foreach (argv, argv + argc, inline_me_too);\n }\n \n-/* { dg-final { scan-tree-dump-times \"Inlining void inline_me\\\\(\" 1 \"einline2\"} } */\n-/* { dg-final { scan-tree-dump-times \"Inlining void inline_me_too\\\\(\" 1 \"einline2\"} } */\n-/* { dg-final { cleanup-tree-dump \"einline2\" } } */\n+/* { dg-final { scan-tree-dump-times \"Inlining void inline_me\\\\(\" 1 \"einline\"} } */\n+/* { dg-final { scan-tree-dump-times \"Inlining void inline_me_too\\\\(\" 1 \"einline\"} } */\n+/* { dg-final { cleanup-tree-dump \"einline\" } } */"}, {"sha": "57d175c44163209bba388388e9e4fd0f1ba756e2", "filename": "gcc/testsuite/g++.dg/tree-ssa/inline-3.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Finline-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Finline-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Finline-3.C?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-einline2\" } */\n+/* { dg-options \"-O2 -fdump-tree-einline\" } */\n /* { dg-add-options bind_pic_locally } */\n \n #include <algorithm>\n@@ -26,6 +26,6 @@ int main(int argc, char **argv)\n   std::for_each (argv, argv + argc, inline_me_too);\n }\n \n-/* { dg-final { scan-tree-dump-times \"Inlining void inline_me\\\\(\" 1 \"einline2\"} } */\n-/* { dg-final { scan-tree-dump-times \"Inlining void inline_me_too\\\\(\" 1 \"einline2\"} } */\n-/* { dg-final { cleanup-tree-dump \"einline2\" } } */\n+/* { dg-final { scan-tree-dump-times \"Inlining void inline_me\\\\(\" 1 \"einline\"} } */\n+/* { dg-final { scan-tree-dump-times \"Inlining void inline_me_too\\\\(\" 1 \"einline\"} } */\n+/* { dg-final { cleanup-tree-dump \"einline\" } } */"}, {"sha": "62f31303142c2d2e9db5edd5077f831e9e134957", "filename": "gcc/testsuite/gcc.dg/profile-dir-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Fprofile-dir-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Fprofile-dir-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fprofile-dir-1.c?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,11 +1,11 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O -fprofile-generate=. -fdump-tree-tree_profile\" } */\n-/* { dg-final { scan-tree-dump \" ./profile-dir-1.gcda\" \"tree_profile\" } } */\n+/* { dg-options \"-O -fprofile-generate=. -fdump-ipa-tree_profile_ipa\" } */\n+/* { dg-final { scan-ipa-dump \" ./profile-dir-1.gcda\" \"tree_profile_ipa\" } } */\n \n int\n main(void)\n {\n   return 0;\n }\n \n-/* { dg-final { cleanup-tree-dump \"tree_profile\" } } */\n+/* { dg-final { cleanup-ipa-dump \"tree_profile_ipa\" } } */"}, {"sha": "7bad03c5c0464b02afe52f9e9ed7a121098e4410", "filename": "gcc/testsuite/gcc.dg/profile-dir-2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Fprofile-dir-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Fprofile-dir-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fprofile-dir-2.c?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,11 +1,11 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O -fprofile-generate -fdump-tree-tree_profile\" } */\n-/* { dg-final { scan-tree-dump \"/profile-dir-2.gcda\" \"tree_profile\" } } */\n+/* { dg-options \"-O -fprofile-generate -fdump-ipa-tree_profile_ipa\" } */\n+/* { dg-final { scan-ipa-dump \"/profile-dir-2.gcda\" \"tree_profile_ipa\" } } */\n \n int\n main(void)\n {\n   return 0;\n }\n \n-/* { dg-final { cleanup-tree-dump \"tree_profile\" } } */\n+/* { dg-final { cleanup-ipa-dump \"tree_profile_ipa\" } } */"}, {"sha": "a4622233dc7716c2f1bc8b1e7552180adddc013d", "filename": "gcc/testsuite/gcc.dg/profile-dir-3.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Fprofile-dir-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Fprofile-dir-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fprofile-dir-3.c?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,11 +1,11 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O -fprofile-generate -fprofile-dir=. -fdump-tree-tree_profile\" } */\n-/* { dg-final { scan-tree-dump \" ./profile-dir-3.gcda\" \"tree_profile\" } } */\n+/* { dg-options \"-O -fprofile-generate -fprofile-dir=. -fdump-ipa-tree_profile_ipa\" } */\n+/* { dg-final { scan-ipa-dump \" ./profile-dir-3.gcda\" \"tree_profile_ipa\" } } */\n \n int\n main(void)\n {\n   return 0;\n }\n \n-/* { dg-final { cleanup-tree-dump \"tree_profile\" } } */\n+/* { dg-final { cleanup-ipa-dump \"tree_profile_ipa\" } } */"}, {"sha": "94a5953c9f25bc2844472516f0ee049a1862e4f8", "filename": "gcc/testsuite/gcc.dg/tree-prof/ic-misattribution-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fic-misattribution-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fic-misattribution-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fic-misattribution-1.c?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 -fdump-tree-tree_profile\" } */\n+/* { dg-options \"-O2 -fdump-ipa-tree_profile_ipa\" } */\n /* { dg-additional-sources \"ic-misattribution-1a.c\" } */\n \n extern void other_caller (void);\n@@ -15,5 +15,5 @@ caller(void (*func) (void))\n   func ();\n }\n \n-/* { dg-final-use { scan-tree-dump \"hist->count 1 hist->all 1\" \"tree_profile\" } } */\n-/* { dg-final-use { cleanup-tree-dump \"tree_profile\" } } */\n+/* { dg-final-use { scan-ipa-dump \"hist->count 1 hist->all 1\" \"tree_profile_ipa\" } } */\n+/* { dg-final-use { cleanup-ipa-dump \"tree_profile_ipa\" } } */"}, {"sha": "8f7508b49606834a885472d69b0ca5b817c5db5a", "filename": "gcc/testsuite/gcc.dg/tree-prof/indir-call-prof.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Findir-call-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Findir-call-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Findir-call-prof.c?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 -fdump-tree-optimized -fdump-tree-tree_profile\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -fdump-ipa-tree_profile_ipa\" } */\n \n static int a1 (void)\n {\n@@ -37,9 +37,7 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final-use { scan-tree-dump \"Indirect call -> direct call.* a1 transformation on insn\" \"tree_profile\"} } */\n-/* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */                                                                                \n-/* { dg-final-use { cleanup-tree-dump \"optimized\" } } */                                                                                              \n-/* { dg-final-use { cleanup-tree-dump \"tree_profile\" } } */\n-                                                                                           \n-\n+/* { dg-final-use { scan-ipa-dump \"Indirect call -> direct call.* a1 transformation on insn\" \"tree_profile_ipa\"} } */\n+/* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */\n+/* { dg-final-use { cleanup-tree-dump \"optimized\" } } */\n+/* { dg-final-use { cleanup-ipa-dump \"tree_profile_ipa\" } } */"}, {"sha": "fe200c82f22b420f127144d7385e8e8d3539d197", "filename": "gcc/testsuite/gcc.dg/tree-prof/stringop-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-1.c?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 -fdump-tree-optimized -fdump-tree-tree_profile\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -fdump-ipa-tree_profile_ipa\" } */\n int a[1000];\n int b[1000];\n int size=1;\n@@ -13,10 +13,10 @@ main()\n     }\n    return 0;\n }\n-/* { dg-final-use { scan-tree-dump \"Single value 4 stringop\" \"tree_profile\"} } */\n+/* { dg-final-use { scan-ipa-dump \"Single value 4 stringop\" \"tree_profile_ipa\"} } */\n /* Really this ought to simplify into assignment, but we are not there yet.  */\n /* a[0] = b[0] is what we fold the resulting memcpy into.  */\n /* { dg-final-use { scan-tree-dump \" = MEM.*&b\" \"optimized\"} } */\n /* { dg-final-use { scan-tree-dump \"MEM.*&a\\\\\\] = \" \"optimized\"} } */\n /* { dg-final-use { cleanup-tree-dump \"optimized\" } } */\n-/* { dg-final-use { cleanup-tree-dump \"tree_profile\" } } */\n+/* { dg-final-use { cleanup-ipa-dump \"tree_profile_ipa\" } } */"}, {"sha": "aa951c97c74c1a749870f9fb8c3cfb09700ee573", "filename": "gcc/testsuite/gcc.dg/tree-prof/stringop-2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-2.c?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 -fdump-tree-optimized -fdump-tree-tree_profile\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -fdump-ipa-tree_profile_ipa\" } */\n int a[1000];\n int b[1000];\n int size=1;\n@@ -13,8 +13,8 @@ main()\n     }\n    return 0;\n }\n-/* { dg-final-use { scan-tree-dump \"Single value 4 stringop\" \"tree_profile\"} } */\n+/* { dg-final-use { scan-ipa-dump \"Single value 4 stringop\" \"tree_profile_ipa\"} } */\n /* The versioned memset of size 4 should be optimized to an assignment.  */\n /* { dg-final-use { scan-tree-dump \"a\\\\\\[0\\\\\\] = 168430090\" \"optimized\"} } */\n /* { dg-final-use { cleanup-tree-dump \"optimized\" } } */\n-/* { dg-final-use { cleanup-tree-dump \"tree_profile\" } } */\n+/* { dg-final-use { cleanup-ipa-dump \"tree_profile_ipa\" } } */"}, {"sha": "385a1a5c2f3e39b3e3868db1c2b33687c7273d11", "filename": "gcc/testsuite/gcc.dg/tree-prof/tracer-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Ftracer-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Ftracer-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Ftracer-1.c?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,8 +1,8 @@\n /* { dg-options \"-O2 -ftracer -fdump-tree-tracer\" } */\n-main ()\n+volatile int a, b, c;\n+int main ()\n {\n   int i;\n-  int a, b, c;\n   for (i = 0; i < 1000; i++)\n     {\n       if (i % 17)\n@@ -14,5 +14,5 @@ main ()\n   return 0;\n }\n /* Superblock formation should produce two copies of the increment of c */\n-/* { dg-final-generate { scan-tree-dump-times \"goto <bb 6>;\" 2 \"tracer\" } } */\n+/* { dg-final-generate { scan-tree-dump-times \"c =\" 2 \"tracer\" } } */\n /* { dg-final-use { cleanup-tree-dump \"tracer\" } } */"}, {"sha": "6b7dbd418a8d9dc77ce54709965f4e6f9f04e671", "filename": "gcc/testsuite/gcc.dg/tree-prof/update-loopch.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fupdate-loopch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fupdate-loopch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fupdate-loopch.c?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 -fdump-tree-tree_profile-blocks -fdump-tree-optimized-blocks\" } */\n+/* { dg-options \"-O2 -fdump-ipa-tree_profile_ipa-blocks -fdump-tree-optimized-blocks\" } */\n int max = 33333;\n int a[8];\n int\n@@ -14,8 +14,8 @@ main ()\n /* Loop header copying will peel away the initial conditional, so the loop body\n    is once reached directly from entry point of function, rest via loopback\n    edge.  */\n-/* { dg-final-use { scan-tree-dump \"count:33333\" \"tree_profile\"} } */\n+/* { dg-final-use { scan-ipa-dump \"count:33333\" \"tree_profile_ipa\"} } */\n /* { dg-final-use { scan-tree-dump \"count:33332\" \"optimized\"} } */\n /* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */\n-/* { dg-final-use { cleanup-tree-dump \"tree_profile\" } } */\n+/* { dg-final-use { cleanup-ipa-dump \"tree_profile_ipa\" } } */\n /* { dg-final-use { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "181b3d184432d15f86323915b659c0e8b30a540d", "filename": "gcc/testsuite/gcc.dg/tree-prof/val-prof-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-1.c?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 -fdump-tree-optimized -fdump-tree-tree_profile\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -fdump-ipa-tree_profile_ipa\" } */\n int a[1000];\n int b = 256;\n int c = 257;\n@@ -15,8 +15,8 @@ main ()\n     }\n   return 0;\n }\n-/* { dg-final-use { scan-tree-dump \"Div.mod by constant n=257 transformation on insn\" \"tree_profile\"} } */\n+/* { dg-final-use { scan-ipa-dump \"Div.mod by constant n_\\[0-9\\]*=257 transformation on insn\" \"tree_profile_ipa\"} } */\n /* { dg-final-use { scan-tree-dump \"if \\\\(n_\\[0-9\\]* != 257\\\\)\" \"optimized\"} } */\n /* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */\n /* { dg-final-use { cleanup-tree-dump \"optimized\" } } */\n-/* { dg-final-use { cleanup-tree-dump \"tree_profile\" } } */\n+/* { dg-final-use { cleanup-ipa-dump \"tree_profile_ipa\" } } */"}, {"sha": "f96255d0c191393eebc557214c5f57acc4d16481", "filename": "gcc/testsuite/gcc.dg/tree-prof/val-prof-2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-2.c?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 -fdump-tree-optimized -fdump-tree-tree_profile\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -fdump-ipa-tree_profile_ipa\" } */\n unsigned int a[1000];\n unsigned int b = 256;\n unsigned int c = 1024;\n@@ -23,10 +23,10 @@ main ()\n     }\n   return 0;\n }\n-/* { dg-final-use { scan-tree-dump \"Mod power of 2 transformation on insn\" \"tree_profile\"} } */\n+/* { dg-final-use { scan-ipa-dump \"Mod power of 2 transformation on insn\" \"tree_profile_ipa\" } } */\n /* This is part of code checking that n is power of 2, so we are sure that the transformation\n    didn't get optimized out.  */\n /* { dg-final-use { scan-tree-dump \"n_\\[0-9\\]* \\\\+ 0xffff\" \"optimized\"} } */\n /* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */\n /* { dg-final-use { cleanup-tree-dump \"optimized\" } } */\n-/* { dg-final-use { cleanup-tree-dump \"tree_profile\" } } */\n+/* { dg-final-use { cleanup-ipa-dump \"tree_profile_ipa\" } } */"}, {"sha": "802dbf02af4098573511e20fc738ba777685ef3e", "filename": "gcc/testsuite/gcc.dg/tree-prof/val-prof-3.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-3.c?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 -fdump-tree-optimized -fdump-tree-tree_profile\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -fdump-ipa-tree_profile_ipa\" } */\n unsigned int a[1000];\n unsigned int b = 257;\n unsigned int c = 1023;\n@@ -23,10 +23,10 @@ main ()\n     }\n   return 0;\n }\n-/* { dg-final-use { scan-tree-dump \"Mod subtract transformation on insn\" \"tree_profile\"} } */\n+/* { dg-final-use { scan-ipa-dump \"Mod subtract transformation on insn\" \"tree_profile_ipa\" } } */\n /* This is part of code checking that n is greater than the divisor so we are sure that it\n    didn't get optimized out.  */\n /* { dg-final-use { scan-tree-dump \"if \\\\(n_\\[0-9\\]* \\\\>\" \"optimized\"} } */\n /* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */\n /* { dg-final-use { cleanup-tree-dump \"optimized\" } } */\n-/* { dg-final-use { cleanup-tree-dump \"tree_profile\" } } */\n+/* { dg-final-use { cleanup-ipa-dump \"tree_profile_ipa\" } } */"}, {"sha": "d4d3085aa4e6a8ab11a0026346d9fd1e2c2a2abb", "filename": "gcc/testsuite/gcc.dg/tree-prof/val-prof-4.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-4.c?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 -fdump-tree-optimized -fdump-tree-tree_profile\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -fdump-ipa-tree_profile_ipa\" } */\n unsigned int a[1000];\n unsigned int b = 999;\n unsigned int c = 1002;\n@@ -23,10 +23,10 @@ main ()\n     }\n   return 0;\n }\n-/* { dg-final-use { scan-tree-dump \"Mod subtract transformation on insn\" \"tree_profile\"} } */\n+/* { dg-final-use { scan-ipa-dump \"Mod subtract transformation on insn\" \"tree_profile_ipa\" } } */\n /* This is part of code checking that n is greater than the divisor so we are sure that it\n    didn't get optimized out.  */\n /* { dg-final-use { scan-tree-dump \"if \\\\(n_\\[0-9\\]* \\\\>\" \"optimized\"} } */\n /* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */\n /* { dg-final-use { cleanup-tree-dump \"optimized\" } } */\n-/* { dg-final-use { cleanup-tree-dump \"tree_profile\" } } */\n+/* { dg-final-use { cleanup-ipa-dump \"tree_profile_ipa\" } } */"}, {"sha": "581f4d54a43fecca483c995148f9a9d178306401", "filename": "gcc/testsuite/gcc.dg/tree-prof/val-prof-5.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-5.c?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 -fdump-tree-optimized -fdump-tree-tree_profile\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -fdump-ipa-tree_profile_ipa\" } */\n int a[1000];\n int b=997;\n main()\n@@ -11,7 +11,7 @@ main()\n \t\t\ta[i]/=b;\n \treturn 0;\n }\n-/* { dg-final-use { scan-tree-dump \"Div.mod by constant b.*=997 transformation on insn\" \"tree_profile\"} } */\n+/* { dg-final-use { scan-ipa-dump \"Div.mod by constant b.*=997 transformation on insn\" \"tree_profile_ipa\" } } */\n /* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */\n /* { dg-final-use { cleanup-tree-dump \"optimized\" } } */\n-/* { dg-final-use { cleanup-tree-dump \"tree_profile\" } } */\n+/* { dg-final-use { cleanup-ipa-dump \"tree_profile_ipa\" } } */"}, {"sha": "664b62039fc8b9dcc77e3ae1d276eedb58b0b243", "filename": "gcc/testsuite/gcc.dg/tree-prof/val-prof-7.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-7.c?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 -fdump-tree-tree_profile -mtune=core2\" } */\n+/* { dg-options \"-O2 -fdump-ipa-tree_profile_ipa -mtune=core2\" } */\n /* { dg-skip-if \"\" { ! { i?86-*-* x86_64-*-* } } { \"*\" } { \"\" } } */\n \n #include <strings.h>\n@@ -22,5 +22,5 @@ int main() {\n   return 0;\n }\n \n-/* { dg-final-use { scan-tree-dump \"Single value 8 stringop transformation on bzero\" \"tree_profile\"} } */\n-/* { dg-final-use { cleanup-tree-dump \"tree_profile\" } } */\n+/* { dg-final-use { scan-ipa-dump \"Single value 8 stringop transformation on bzero\" \"tree_profile_ipa\" } } */\n+/* { dg-final-use { cleanup-ipa-dump \"tree_profile_ipa\" } } */"}, {"sha": "bf222fee155a067289ac2bee87a18c81074e96c5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20080530.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20080530.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20080530.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20080530.c?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -18,5 +18,5 @@ baz (void)\n   return 6;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Inlining foo into baz\" 0 \"einline2\"} } */\n-/* { dg-final { cleanup-tree-dump \"einline2\" } } */\n+/* { dg-final { scan-tree-dump-times \"Inlining foo into baz\" 0 \"einline\"} } */\n+/* { dg-final { cleanup-tree-dump \"einline\" } } */"}, {"sha": "ff140ed54142f4d805e2033af8cd4a776ae31b4e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/inline-3.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Finline-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Finline-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Finline-3.c?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-einline2\" } */\n+/* { dg-options \"-O2 -fdump-tree-einline\" } */\n /* { dg-add-options bind_pic_locally } */\n \n extern void inlined ();\n@@ -27,6 +27,6 @@ inline_me_too (void)\n {\n   inlined();\n }\n-/* { dg-final { scan-tree-dump-times \"Inlining inline_me \" 1 \"einline2\"} } */\n-/* { dg-final { scan-tree-dump-times \"Inlining inline_me_too \" 1 \"einline2\"} } */\n-/* { dg-final { cleanup-tree-dump \"einline2\" } } */\n+/* { dg-final { scan-tree-dump-times \"Inlining inline_me \" 1 \"einline\"} } */\n+/* { dg-final { scan-tree-dump-times \"Inlining inline_me_too \" 1 \"einline\"} } */\n+/* { dg-final { cleanup-tree-dump \"einline\" } } */"}, {"sha": "1e700ef0227ae68f3fdd6772c715758d61323876", "filename": "gcc/testsuite/gcc.dg/tree-ssa/inline-4.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Finline-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Finline-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Finline-4.c?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-einline2\" } */\n+/* { dg-options \"-O2 -fdump-tree-einline\" } */\n /* { dg-add-options bind_pic_locally } */\n \n extern int rand(void);\n@@ -23,5 +23,5 @@ int main()\n     }\n }\n \n-/* { dg-final { scan-tree-dump \"Inlining get_data_for into main\" \"einline2\" } } */\n-/* { dg-final { cleanup-tree-dump \"einline2\" } } */\n+/* { dg-final { scan-tree-dump \"Inlining get_data_for into main\" \"einline\" } } */\n+/* { dg-final { cleanup-tree-dump \"einline\" } } */"}, {"sha": "a87a7706f77c4e3584388d19d975f57bb887cb48", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -353,7 +353,6 @@ extern struct gimple_opt_pass pass_lower_eh;\n extern struct gimple_opt_pass pass_lower_eh_dispatch;\n extern struct gimple_opt_pass pass_lower_resx;\n extern struct gimple_opt_pass pass_build_cfg;\n-extern struct gimple_opt_pass pass_tree_profile;\n extern struct gimple_opt_pass pass_early_tree_profile;\n extern struct gimple_opt_pass pass_referenced_vars;\n extern struct gimple_opt_pass pass_cleanup_eh;\n@@ -447,7 +446,7 @@ extern struct gimple_opt_pass pass_split_functions;\n /* IPA Passes */\n extern struct simple_ipa_opt_pass pass_ipa_lower_emutls;\n extern struct simple_ipa_opt_pass pass_ipa_function_and_variable_visibility;\n-extern struct simple_ipa_opt_pass pass_ipa_early_inline;\n+extern struct simple_ipa_opt_pass pass_ipa_tree_profile;\n \n extern struct simple_ipa_opt_pass pass_early_local_passes;\n "}, {"sha": "5b7c12bad4d485c204f37384fc68f961eefeaf0f", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 185, "deletions": 115, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -120,6 +120,10 @@ tree_init_edge_profiler (void)\n       tree_interval_profiler_fn\n \t      = build_fn_decl (\"__gcov_interval_profiler\",\n \t\t\t\t     interval_profiler_fn_type);\n+      TREE_NOTHROW (tree_interval_profiler_fn) = 1;\n+      DECL_ATTRIBUTES (tree_interval_profiler_fn)\n+\t= tree_cons (get_identifier (\"leaf\"), NULL,\n+\t\t     DECL_ATTRIBUTES (tree_interval_profiler_fn));\n \n       /* void (*) (gcov_type *, gcov_type)  */\n       pow2_profiler_fn_type\n@@ -128,6 +132,10 @@ tree_init_edge_profiler (void)\n \t\t\t\t\t  NULL_TREE);\n       tree_pow2_profiler_fn = build_fn_decl (\"__gcov_pow2_profiler\",\n \t\t\t\t\t\t   pow2_profiler_fn_type);\n+      TREE_NOTHROW (tree_pow2_profiler_fn) = 1;\n+      DECL_ATTRIBUTES (tree_pow2_profiler_fn)\n+\t= tree_cons (get_identifier (\"leaf\"), NULL,\n+\t\t     DECL_ATTRIBUTES (tree_pow2_profiler_fn));\n \n       /* void (*) (gcov_type *, gcov_type)  */\n       one_value_profiler_fn_type\n@@ -137,6 +145,10 @@ tree_init_edge_profiler (void)\n       tree_one_value_profiler_fn\n \t      = build_fn_decl (\"__gcov_one_value_profiler\",\n \t\t\t\t     one_value_profiler_fn_type);\n+      TREE_NOTHROW (tree_one_value_profiler_fn) = 1;\n+      DECL_ATTRIBUTES (tree_one_value_profiler_fn)\n+\t= tree_cons (get_identifier (\"leaf\"), NULL,\n+\t\t     DECL_ATTRIBUTES (tree_one_value_profiler_fn));\n \n       tree_init_ic_make_global_vars ();\n \n@@ -149,16 +161,30 @@ tree_init_edge_profiler (void)\n       tree_indirect_call_profiler_fn\n \t      = build_fn_decl (\"__gcov_indirect_call_profiler\",\n \t\t\t\t     ic_profiler_fn_type);\n+      TREE_NOTHROW (tree_indirect_call_profiler_fn) = 1;\n+      DECL_ATTRIBUTES (tree_indirect_call_profiler_fn)\n+\t= tree_cons (get_identifier (\"leaf\"), NULL,\n+\t\t     DECL_ATTRIBUTES (tree_indirect_call_profiler_fn));\n+\n       /* void (*) (gcov_type *, gcov_type)  */\n       average_profiler_fn_type\n \t      = build_function_type_list (void_type_node,\n \t\t\t\t\t  gcov_type_ptr, gcov_type_node, NULL_TREE);\n       tree_average_profiler_fn\n \t      = build_fn_decl (\"__gcov_average_profiler\",\n \t\t\t\t     average_profiler_fn_type);\n+      TREE_NOTHROW (tree_average_profiler_fn) = 1;\n+      DECL_ATTRIBUTES (tree_average_profiler_fn)\n+\t= tree_cons (get_identifier (\"leaf\"), NULL,\n+\t\t     DECL_ATTRIBUTES (tree_average_profiler_fn));\n       tree_ior_profiler_fn\n \t      = build_fn_decl (\"__gcov_ior_profiler\",\n \t\t\t\t     average_profiler_fn_type);\n+      TREE_NOTHROW (tree_ior_profiler_fn) = 1;\n+      DECL_ATTRIBUTES (tree_ior_profiler_fn)\n+\t= tree_cons (get_identifier (\"leaf\"), NULL,\n+\t\t     DECL_ATTRIBUTES (tree_ior_profiler_fn));\n+\n       /* LTO streamer needs assembler names.  Because we create these decls\n          late, we need to initialize them by hand.  */\n       DECL_ASSEMBLER_NAME (tree_interval_profiler_fn);\n@@ -170,20 +196,6 @@ tree_init_edge_profiler (void)\n     }\n }\n \n-/* New call was added, make goto call edges if neccesary.  */\n-\n-static void\n-add_abnormal_goto_call_edges (gimple_stmt_iterator gsi)\n-{\n-  gimple stmt = gsi_stmt (gsi);\n-\n-  if (!stmt_can_make_abnormal_goto (stmt))\n-    return;\n-  if (!gsi_end_p (gsi))\n-    split_block (gimple_bb (stmt), stmt);\n-  make_abnormal_goto_edges (gimple_bb (stmt), true);\n-}\n-\n /* Output instructions as GIMPLE trees to increment the edge\n    execution count, and insert them on E.  We rely on\n    gsi_insert_on_edge to preserve the order.  */\n@@ -197,13 +209,15 @@ tree_gen_edge_profiler (int edgeno, edge e)\n   /* We share one temporary variable declaration per function.  This\n      gets re-set in tree_profiling.  */\n   if (gcov_type_tmp_var == NULL_TREE)\n-    gcov_type_tmp_var = create_tmp_var (gcov_type_node, \"PROF_edge_counter\");\n+    gcov_type_tmp_var = create_tmp_reg (gcov_type_node, \"PROF_edge_counter\");\n   ref = tree_coverage_counter_ref (GCOV_COUNTER_ARCS, edgeno);\n   one = build_int_cst (gcov_type_node, 1);\n   stmt1 = gimple_build_assign (gcov_type_tmp_var, ref);\n+  gimple_assign_set_lhs (stmt1, make_ssa_name (gcov_type_tmp_var, stmt1));\n   stmt2 = gimple_build_assign_with_ops (PLUS_EXPR, gcov_type_tmp_var,\n-\t\t\t\t\tgcov_type_tmp_var, one);\n-  stmt3 = gimple_build_assign (unshare_expr (ref), gcov_type_tmp_var);\n+\t\t\t\t\tgimple_assign_lhs (stmt1), one);\n+  gimple_assign_set_lhs (stmt2, make_ssa_name (gcov_type_tmp_var, stmt2));\n+  stmt3 = gimple_build_assign (unshare_expr (ref), gimple_assign_lhs (stmt2));\n   gsi_insert_on_edge (e, stmt1);\n   gsi_insert_on_edge (e, stmt2);\n   gsi_insert_on_edge (e, stmt3);\n@@ -246,7 +260,6 @@ tree_gen_interval_profiler (histogram_value value, unsigned tag, unsigned base)\n   call = gimple_build_call (tree_interval_profiler_fn, 4,\n \t\t\t    ref_ptr, val, start, steps);\n   gsi_insert_before (&gsi, call, GSI_NEW_STMT);\n-  add_abnormal_goto_call_edges (gsi);\n }\n \n /* Output instructions as GIMPLE trees to increment the power of two histogram\n@@ -267,7 +280,6 @@ tree_gen_pow2_profiler (histogram_value value, unsigned tag, unsigned base)\n   val = prepare_instrumented_value (&gsi, value);\n   call = gimple_build_call (tree_pow2_profiler_fn, 2, ref_ptr, val);\n   gsi_insert_before (&gsi, call, GSI_NEW_STMT);\n-  add_abnormal_goto_call_edges (gsi);\n }\n \n /* Output instructions as GIMPLE trees for code to find the most common value.\n@@ -288,7 +300,6 @@ tree_gen_one_value_profiler (histogram_value value, unsigned tag, unsigned base)\n   val = prepare_instrumented_value (&gsi, value);\n   call = gimple_build_call (tree_one_value_profiler_fn, 2, ref_ptr, val);\n   gsi_insert_before (&gsi, call, GSI_NEW_STMT);\n-  add_abnormal_goto_call_edges (gsi);\n }\n \n \n@@ -316,10 +327,11 @@ tree_gen_ic_profiler (histogram_value value, unsigned tag, unsigned base)\n     __gcov_indirect_call_callee = (void *) indirect call argument;\n    */\n \n-  tmp1 = create_tmp_var (ptr_void, \"PROF\");\n+  tmp1 = create_tmp_reg (ptr_void, \"PROF\");\n   stmt1 = gimple_build_assign (ic_gcov_type_ptr_var, ref_ptr);\n   stmt2 = gimple_build_assign (tmp1, unshare_expr (value->hvalue.value));\n-  stmt3 = gimple_build_assign (ic_void_ptr_var, tmp1);\n+  gimple_assign_set_lhs (stmt2, make_ssa_name (tmp1, stmt2));\n+  stmt3 = gimple_build_assign (ic_void_ptr_var, gimple_assign_lhs (stmt2));\n \n   gsi_insert_before (&gsi, stmt1, GSI_SAME_STMT);\n   gsi_insert_before (&gsi, stmt2, GSI_SAME_STMT);\n@@ -337,51 +349,38 @@ tree_gen_ic_func_profiler (void)\n {\n   struct cgraph_node * c_node = cgraph_node (current_function_decl);\n   gimple_stmt_iterator gsi;\n-  edge e;\n-  basic_block bb;\n-  edge_iterator ei;\n   gimple stmt1, stmt2;\n-  tree tree_uid, cur_func, counter_ptr, ptr_var;\n+  tree tree_uid, cur_func, counter_ptr, ptr_var, void0;\n \n   if (cgraph_only_called_directly_p (c_node))\n     return;\n \n   tree_init_edge_profiler ();\n \n-  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n-    {\n-      tree void0;\n-\n-      bb = split_edge (e);\n-      gsi = gsi_start_bb (bb);\n-\n-      cur_func = force_gimple_operand_gsi (&gsi,\n-\t\t\t\t\t   build_addr (current_function_decl,\n-\t\t\t\t\t\t       current_function_decl),\n-\t\t\t\t\t   true, NULL_TREE,\n-\t\t\t\t\t   true, GSI_NEW_STMT);\n-      counter_ptr = force_gimple_operand_gsi (&gsi, ic_gcov_type_ptr_var,\n-\t\t\t\t\t      true, NULL_TREE, false,\n-\t\t\t\t\t      GSI_NEW_STMT);\n-      ptr_var = force_gimple_operand_gsi (&gsi, ic_void_ptr_var,\n-\t\t\t\t\t  true, NULL_TREE, false,\n-\t\t\t\t\t  GSI_NEW_STMT);\n-      tree_uid = build_int_cst (gcov_type_node, c_node->pid);\n-      stmt1 = gimple_build_call (tree_indirect_call_profiler_fn, 4,\n-\t\t\t\t counter_ptr, tree_uid, cur_func, ptr_var);\n-      gsi_insert_after (&gsi, stmt1, GSI_NEW_STMT);\n-      gcc_assert (EDGE_COUNT (bb->succs) == 1);\n-      bb = split_edge (EDGE_I (bb->succs, 0));\n-      add_abnormal_goto_call_edges (gsi);\n-\n-      gsi = gsi_start_bb (bb);\n-      /* Set __gcov_indirect_call_callee to 0,\n-         so that calls from other modules won't get misattributed\n-\t to the last caller of the current callee. */\n-      void0 = build_int_cst (build_pointer_type (void_type_node), 0);\n-      stmt2 = gimple_build_assign (ic_void_ptr_var, void0);\n-      gsi_insert_after (&gsi, stmt2, GSI_NEW_STMT);\n-    }\n+  gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR));\n+\n+  cur_func = force_gimple_operand_gsi (&gsi,\n+\t\t\t\t       build_addr (current_function_decl,\n+\t\t\t\t\t\t   current_function_decl),\n+\t\t\t\t       true, NULL_TREE,\n+\t\t\t\t       true, GSI_SAME_STMT);\n+  counter_ptr = force_gimple_operand_gsi (&gsi, ic_gcov_type_ptr_var,\n+\t\t\t\t\t  true, NULL_TREE, true,\n+\t\t\t\t\t  GSI_SAME_STMT);\n+  ptr_var = force_gimple_operand_gsi (&gsi, ic_void_ptr_var,\n+\t\t\t\t      true, NULL_TREE, true,\n+\t\t\t\t      GSI_SAME_STMT);\n+  tree_uid = build_int_cst (gcov_type_node, c_node->pid);\n+  stmt1 = gimple_build_call (tree_indirect_call_profiler_fn, 4,\n+\t\t\t     counter_ptr, tree_uid, cur_func, ptr_var);\n+  gsi_insert_before (&gsi, stmt1, GSI_SAME_STMT);\n+\n+  /* Set __gcov_indirect_call_callee to 0,\n+     so that calls from other modules won't get misattributed\n+     to the last caller of the current callee. */\n+  void0 = build_int_cst (build_pointer_type (void_type_node), 0);\n+  stmt2 = gimple_build_assign (ic_void_ptr_var, void0);\n+  gsi_insert_before (&gsi, stmt2, GSI_SAME_STMT);\n }\n \n /* Output instructions as GIMPLE trees for code to find the most common value\n@@ -420,7 +419,6 @@ tree_gen_average_profiler (histogram_value value, unsigned tag, unsigned base)\n   val = prepare_instrumented_value (&gsi, value);\n   call = gimple_build_call (tree_average_profiler_fn, 2, ref_ptr, val);\n   gsi_insert_before (&gsi, call, GSI_NEW_STMT);\n-  add_abnormal_goto_call_edges (gsi);\n }\n \n /* Output instructions as GIMPLE trees to increment the ior histogram\n@@ -441,81 +439,153 @@ tree_gen_ior_profiler (histogram_value value, unsigned tag, unsigned base)\n   val = prepare_instrumented_value (&gsi, value);\n   call = gimple_build_call (tree_ior_profiler_fn, 2, ref_ptr, val);\n   gsi_insert_before (&gsi, call, GSI_NEW_STMT);\n-  add_abnormal_goto_call_edges (gsi);\n }\n \n-/* Return 1 if tree-based profiling is in effect, else 0.\n-   If it is, set up hooks for tree-based profiling.\n-   Gate for pass_tree_profile.  */\n-\n-static bool\n-do_tree_profiling (void)\n-{\n-  if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n-    {\n-      tree_register_profile_hooks ();\n-      gimple_register_value_prof_hooks ();\n-      return true;\n-    }\n-  return false;\n-}\n+/* Profile all functions in the callgraph.  */\n \n static unsigned int\n tree_profiling (void)\n {\n+  struct cgraph_node *node;\n+\n   /* Don't profile functions produced at destruction time, particularly\n      the gcov datastructure initializer.  Don't profile if it has been\n      already instrumented either (when OpenMP expansion creates\n      child function from already instrumented body).  */\n-  if (cgraph_state == CGRAPH_STATE_FINISHED\n-      || cfun->after_tree_profile)\n+  if (cgraph_state == CGRAPH_STATE_FINISHED)\n     return 0;\n \n-  /* Don't profile functions produced for builtin stuff.  */\n-  if (DECL_SOURCE_LOCATION (current_function_decl) == BUILTINS_LOCATION)\n-    return 0;\n+  tree_register_profile_hooks ();\n+  gimple_register_value_prof_hooks ();\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      if (!node->analyzed\n+\t  || !gimple_has_body_p (node->decl)\n+\t  || !(!node->clone_of || node->decl != node->clone_of->decl))\n+\tcontinue;\n+\n+      /* Don't profile functions produced for builtin stuff.  */\n+      if (DECL_SOURCE_LOCATION (node->decl) == BUILTINS_LOCATION\n+\t  || DECL_STRUCT_FUNCTION (node->decl)->after_tree_profile)\n+\tcontinue;\n+\n+      push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+      current_function_decl = node->decl;\n+\n+      /* Re-set global shared temporary variable for edge-counters.  */\n+      gcov_type_tmp_var = NULL_TREE;\n+\n+      branch_prob ();\n+\n+      if (! flag_branch_probabilities\n+\t  && flag_profile_values)\n+\ttree_gen_ic_func_profiler ();\n+\n+      if (flag_branch_probabilities\n+\t  && flag_profile_values\n+\t  && flag_value_profile_transformations)\n+\tvalue_profile_transformations ();\n+\n+      /* The above could hose dominator info.  Currently there is\n+\t none coming in, this is a safety valve.  It should be\n+\t easy to adjust it, if and when there is some.  */\n+      free_dominance_info (CDI_DOMINATORS);\n+      free_dominance_info (CDI_POST_DOMINATORS);\n+\n+      current_function_decl = NULL;\n+      pop_cfun ();\n+    }\n+\n+  /* Drop pure/const flags from instrumented functions.  */\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      if (!node->analyzed\n+\t  || !gimple_has_body_p (node->decl)\n+\t  || !(!node->clone_of || node->decl != node->clone_of->decl))\n+\tcontinue;\n+\n+      /* Don't profile functions produced for builtin stuff.  */\n+      if (DECL_SOURCE_LOCATION (node->decl) == BUILTINS_LOCATION\n+\t  || DECL_STRUCT_FUNCTION (node->decl)->after_tree_profile)\n+\tcontinue;\n+\n+      cgraph_set_readonly_flag (node, false);\n+      cgraph_set_pure_flag (node, false);\n+      cgraph_set_looping_const_or_pure_flag (node, false);\n+    }\n+\n+  /* Update call statements and rebuild the cgraph.  */\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      basic_block bb;\n+\n+      if (!node->analyzed\n+\t  || !gimple_has_body_p (node->decl)\n+\t  || !(!node->clone_of || node->decl != node->clone_of->decl))\n+\tcontinue;\n+\n+      /* Don't profile functions produced for builtin stuff.  */\n+      if (DECL_SOURCE_LOCATION (node->decl) == BUILTINS_LOCATION\n+\t  || DECL_STRUCT_FUNCTION (node->decl)->after_tree_profile)\n+\tcontinue;\n+\n+      push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+      current_function_decl = node->decl;\n+\n+      FOR_EACH_BB (bb)\n+\t{\n+\t  gimple_stmt_iterator gsi;\n+\t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      gimple stmt = gsi_stmt (gsi);\n+\t      if (is_gimple_call (stmt))\n+\t\tupdate_stmt (stmt);\n+\t    }\n+\t}\n+\n+      cfun->after_tree_profile = 1;\n+      update_ssa (TODO_update_ssa);\n+\n+      rebuild_cgraph_edges ();\n+\n+      current_function_decl = NULL;\n+      pop_cfun ();\n+    }\n \n-  /* Re-set global shared temporary variable for edge-counters.  */\n-  gcov_type_tmp_var = NULL_TREE;\n-\n-  branch_prob ();\n-\n-  if (! flag_branch_probabilities\n-      && flag_profile_values)\n-    tree_gen_ic_func_profiler ();\n-\n-  if (flag_branch_probabilities\n-      && flag_profile_values\n-      && flag_value_profile_transformations)\n-    value_profile_transformations ();\n-  /* The above could hose dominator info.  Currently there is\n-     none coming in, this is a safety valve.  It should be\n-     easy to adjust it, if and when there is some.  */\n-  free_dominance_info (CDI_DOMINATORS);\n-  free_dominance_info (CDI_POST_DOMINATORS);\n-  cfun->after_tree_profile = 1;\n   return 0;\n }\n \n-struct gimple_opt_pass pass_tree_profile =\n+/* When profile instrumentation, use or test coverage shall be performed.  */\n+\n+static bool\n+gate_tree_profile_ipa (void)\n+{\n+  return (!in_lto_p\n+\t  && (flag_branch_probabilities || flag_test_coverage\n+\t      || profile_arc_flag));\n+}\n+\n+struct simple_ipa_opt_pass pass_ipa_tree_profile =\n {\n  {\n-  GIMPLE_PASS,\n-  \"tree_profile\",\t\t\t/* name */\n-  do_tree_profiling,\t\t\t/* gate */\n-  tree_profiling,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_BRANCH_PROB,\t\t\t/* tv_id */\n-  PROP_gimple_leh | PROP_cfg,\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_verify_stmts | TODO_dump_func\t/* todo_flags_finish */\n+  SIMPLE_IPA_PASS,\n+  \"tree_profile_ipa\",                  /* name */\n+  gate_tree_profile_ipa,               /* gate */\n+  tree_profiling,                      /* execute */\n+  NULL,                                /* sub */\n+  NULL,                                /* next */\n+  0,                                   /* static_pass_number */\n+  TV_IPA_PROFILE,                      /* tv_id */\n+  0,                                   /* properties_required */\n+  0,                                   /* properties_provided */\n+  0,                                   /* properties_destroyed */\n+  0,                                   /* todo_flags_start */\n+  TODO_dump_func                       /* todo_flags_finish */\n  }\n };\n \n+\n struct profile_hooks tree_profile_hooks =\n {\n   tree_init_edge_profiler,       /* init_edge_profiler */"}, {"sha": "b0cc13bb9aaa438265e0d8c53afa93ca1e58cc26", "filename": "gcc/value-prof.c", "status": "modified", "additions": 56, "deletions": 22, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3814a514c4854cdc44242d383ea245c413b1d5/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=4d3814a514c4854cdc44242d383ea245c413b1d5", "patch": "@@ -558,7 +558,7 @@ gimple_divmod_fixed_value (gimple stmt, tree value, int prob, gcov_type count,\n \t\t\t   gcov_type all)\n {\n   gimple stmt1, stmt2, stmt3;\n-  tree tmp1, tmp2, tmpv;\n+  tree tmp0, tmp1, tmp2, tmpv;\n   gimple bb1end, bb2end, bb3end;\n   basic_block bb, bb2, bb3, bb4;\n   tree optype, op1, op2;\n@@ -576,19 +576,22 @@ gimple_divmod_fixed_value (gimple stmt, tree value, int prob, gcov_type count,\n   bb = gimple_bb (stmt);\n   gsi = gsi_for_stmt (stmt);\n \n-  tmpv = create_tmp_var (optype, \"PROF\");\n-  tmp1 = create_tmp_var (optype, \"PROF\");\n-  stmt1 = gimple_build_assign (tmpv, fold_convert (optype, value));\n+  tmpv = create_tmp_reg (optype, \"PROF\");\n+  tmp0 = make_ssa_name (tmpv, NULL);\n+  tmp1 = make_ssa_name (tmpv, NULL);\n+  stmt1 = gimple_build_assign (tmp0, fold_convert (optype, value));\n+  SSA_NAME_DEF_STMT (tmp0) = stmt1;\n   stmt2 = gimple_build_assign (tmp1, op2);\n-  stmt3 = gimple_build_cond (NE_EXPR, tmp1, tmpv, NULL_TREE, NULL_TREE);\n+  SSA_NAME_DEF_STMT (tmp1) = stmt2;\n+  stmt3 = gimple_build_cond (NE_EXPR, tmp1, tmp0, NULL_TREE, NULL_TREE);\n   gsi_insert_before (&gsi, stmt1, GSI_SAME_STMT);\n   gsi_insert_before (&gsi, stmt2, GSI_SAME_STMT);\n   gsi_insert_before (&gsi, stmt3, GSI_SAME_STMT);\n   bb1end = stmt3;\n \n-  tmp2 = create_tmp_var (optype, \"PROF\");\n+  tmp2 = make_rename_temp (optype, \"PROF\");\n   stmt1 = gimple_build_assign_with_ops (gimple_assign_rhs_code (stmt), tmp2,\n-\t\t\t\t\top1, tmpv);\n+\t\t\t\t\top1, tmp0);\n   gsi_insert_before (&gsi, stmt1, GSI_SAME_STMT);\n   bb2end = stmt1;\n \n@@ -711,7 +714,7 @@ static tree\n gimple_mod_pow2 (gimple stmt, int prob, gcov_type count, gcov_type all)\n {\n   gimple stmt1, stmt2, stmt3, stmt4;\n-  tree tmp2, tmp3;\n+  tree tmp2, tmp3, tmpv;\n   gimple bb1end, bb2end, bb3end;\n   basic_block bb, bb2, bb3, bb4;\n   tree optype, op1, op2;\n@@ -729,12 +732,15 @@ gimple_mod_pow2 (gimple stmt, int prob, gcov_type count, gcov_type all)\n   bb = gimple_bb (stmt);\n   gsi = gsi_for_stmt (stmt);\n \n-  result = create_tmp_var (optype, \"PROF\");\n-  tmp2 = create_tmp_var (optype, \"PROF\");\n-  tmp3 = create_tmp_var (optype, \"PROF\");\n+  result = make_rename_temp (optype, \"PROF\");\n+  tmpv = create_tmp_var (optype, \"PROF\");\n+  tmp2 = make_ssa_name (tmpv, NULL);\n+  tmp3 = make_ssa_name (tmpv, NULL);\n   stmt2 = gimple_build_assign_with_ops (PLUS_EXPR, tmp2, op2,\n \t\t\t\t\tbuild_int_cst (optype, -1));\n+  SSA_NAME_DEF_STMT (tmp2) = stmt2;\n   stmt3 = gimple_build_assign_with_ops (BIT_AND_EXPR, tmp3, tmp2, op2);\n+  SSA_NAME_DEF_STMT (tmp3) = stmt3;\n   stmt4 = gimple_build_cond (NE_EXPR, tmp3, build_int_cst (optype, 0),\n \t\t\t     NULL_TREE, NULL_TREE);\n   gsi_insert_before (&gsi, stmt2, GSI_SAME_STMT);\n@@ -881,10 +887,11 @@ gimple_mod_subtract (gimple stmt, int prob1, int prob2, int ncounts,\n   bb = gimple_bb (stmt);\n   gsi = gsi_for_stmt (stmt);\n \n-  result = create_tmp_var (optype, \"PROF\");\n-  tmp1 = create_tmp_var (optype, \"PROF\");\n+  result = make_rename_temp (optype, \"PROF\");\n+  tmp1 = make_ssa_name (create_tmp_var (optype, \"PROF\"), NULL);\n   stmt1 = gimple_build_assign (result, op1);\n   stmt2 = gimple_build_assign (tmp1, op2);\n+  SSA_NAME_DEF_STMT (tmp1) = stmt2;\n   stmt3 = gimple_build_cond (LT_EXPR, result, tmp1, NULL_TREE, NULL_TREE);\n   gsi_insert_before (&gsi, stmt1, GSI_SAME_STMT);\n   gsi_insert_before (&gsi, stmt2, GSI_SAME_STMT);\n@@ -1092,7 +1099,7 @@ gimple_ic (gimple icall_stmt, struct cgraph_node *direct_call,\n \t   int prob, gcov_type count, gcov_type all)\n {\n   gimple dcall_stmt, load_stmt, cond_stmt;\n-  tree tmp1, tmpv, tmp;\n+  tree tmp0, tmp1, tmpv, tmp;\n   basic_block cond_bb, dcall_bb, icall_bb, join_bb;\n   tree optype = build_pointer_type (void_type_node);\n   edge e_cd, e_ci, e_di, e_dj, e_ij;\n@@ -1102,20 +1109,26 @@ gimple_ic (gimple icall_stmt, struct cgraph_node *direct_call,\n   cond_bb = gimple_bb (icall_stmt);\n   gsi = gsi_for_stmt (icall_stmt);\n \n-  tmpv = create_tmp_var (optype, \"PROF\");\n-  tmp1 = create_tmp_var (optype, \"PROF\");\n+  tmpv = create_tmp_reg (optype, \"PROF\");\n+  tmp0 = make_ssa_name (tmpv, NULL);\n+  tmp1 = make_ssa_name (tmpv, NULL);\n   tmp = unshare_expr (gimple_call_fn (icall_stmt));\n-  load_stmt = gimple_build_assign (tmpv, tmp);\n+  load_stmt = gimple_build_assign (tmp0, tmp);\n+  SSA_NAME_DEF_STMT (tmp0) = load_stmt;\n   gsi_insert_before (&gsi, load_stmt, GSI_SAME_STMT);\n \n   tmp = fold_convert (optype, build_addr (direct_call->decl,\n \t\t\t\t\t  current_function_decl));\n   load_stmt = gimple_build_assign (tmp1, tmp);\n+  SSA_NAME_DEF_STMT (tmp1) = load_stmt;\n   gsi_insert_before (&gsi, load_stmt, GSI_SAME_STMT);\n \n-  cond_stmt = gimple_build_cond (EQ_EXPR, tmp1, tmpv, NULL_TREE, NULL_TREE);\n+  cond_stmt = gimple_build_cond (EQ_EXPR, tmp1, tmp0, NULL_TREE, NULL_TREE);\n   gsi_insert_before (&gsi, cond_stmt, GSI_SAME_STMT);\n \n+  gimple_set_vdef (icall_stmt, NULL_TREE);\n+  gimple_set_vuse (icall_stmt, NULL_TREE);\n+  update_stmt (icall_stmt);\n   dcall_stmt = gimple_copy (icall_stmt);\n   gimple_call_set_fndecl (dcall_stmt, direct_call->decl);\n   gsi_insert_before (&gsi, dcall_stmt, GSI_SAME_STMT);\n@@ -1151,6 +1164,21 @@ gimple_ic (gimple icall_stmt, struct cgraph_node *direct_call,\n   e_ij->probability = REG_BR_PROB_BASE;\n   e_ij->count = all - count;\n \n+  /* Insert PHI node for the call result if necessary.  */\n+  if (gimple_call_lhs (icall_stmt)\n+      && TREE_CODE (gimple_call_lhs (icall_stmt)) == SSA_NAME)\n+    {\n+      tree result = gimple_call_lhs (icall_stmt);\n+      gimple phi = create_phi_node (result, join_bb);\n+      SSA_NAME_DEF_STMT (result) = phi;\n+      gimple_call_set_lhs (icall_stmt,\n+\t\t\t   make_ssa_name (SSA_NAME_VAR (result), icall_stmt));\n+      add_phi_arg (phi, gimple_call_lhs (icall_stmt), e_ij, UNKNOWN_LOCATION);\n+      gimple_call_set_lhs (dcall_stmt,\n+\t\t\t   make_ssa_name (SSA_NAME_VAR (result), dcall_stmt));\n+      add_phi_arg (phi, gimple_call_lhs (dcall_stmt), e_dj, UNKNOWN_LOCATION);\n+    }\n+\n   /* Fix eh edges */\n   lp_nr = lookup_stmt_eh_lp (icall_stmt);\n   if (lp_nr != 0)\n@@ -1289,7 +1317,7 @@ gimple_stringop_fixed_value (gimple vcall_stmt, tree icall_size, int prob,\n \t\t\t     gcov_type count, gcov_type all)\n {\n   gimple tmp_stmt, cond_stmt, icall_stmt;\n-  tree tmp1, tmpv, vcall_size, optype;\n+  tree tmp0, tmp1, tmpv, vcall_size, optype;\n   basic_block cond_bb, icall_bb, vcall_bb, join_bb;\n   edge e_ci, e_cv, e_iv, e_ij, e_vj;\n   gimple_stmt_iterator gsi;\n@@ -1307,16 +1335,22 @@ gimple_stringop_fixed_value (gimple vcall_stmt, tree icall_size, int prob,\n   optype = TREE_TYPE (vcall_size);\n \n   tmpv = create_tmp_var (optype, \"PROF\");\n-  tmp1 = create_tmp_var (optype, \"PROF\");\n-  tmp_stmt = gimple_build_assign (tmpv, fold_convert (optype, icall_size));\n+  tmp0 = make_ssa_name (tmpv, NULL);\n+  tmp1 = make_ssa_name (tmpv, NULL);\n+  tmp_stmt = gimple_build_assign (tmp0, fold_convert (optype, icall_size));\n+  SSA_NAME_DEF_STMT (tmp0) = tmp_stmt;\n   gsi_insert_before (&gsi, tmp_stmt, GSI_SAME_STMT);\n \n   tmp_stmt = gimple_build_assign (tmp1, vcall_size);\n+  SSA_NAME_DEF_STMT (tmp1) = tmp_stmt;\n   gsi_insert_before (&gsi, tmp_stmt, GSI_SAME_STMT);\n \n-  cond_stmt = gimple_build_cond (EQ_EXPR, tmp1, tmpv, NULL_TREE, NULL_TREE);\n+  cond_stmt = gimple_build_cond (EQ_EXPR, tmp1, tmp0, NULL_TREE, NULL_TREE);\n   gsi_insert_before (&gsi, cond_stmt, GSI_SAME_STMT);\n \n+  gimple_set_vdef (vcall_stmt, NULL);\n+  gimple_set_vuse (vcall_stmt, NULL);\n+  update_stmt (vcall_stmt);\n   icall_stmt = gimple_copy (vcall_stmt);\n   gimple_call_set_arg (icall_stmt, size_arg, icall_size);\n   gsi_insert_before (&gsi, icall_stmt, GSI_SAME_STMT);"}]}