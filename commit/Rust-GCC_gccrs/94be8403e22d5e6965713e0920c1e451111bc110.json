{"sha": "94be8403e22d5e6965713e0920c1e451111bc110", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRiZTg0MDNlMjJkNWU2OTY1NzEzZTA5MjBjMWU0NTExMTFiYzExMA==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2002-12-23T23:44:47Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2002-12-23T23:44:47Z"}, "message": "* call.c (tourney, build_field_call, equal_functions, joust)\n\t(compare_ics, build_over_call, build_java_interface_fn_ref)\n\t(convert_like_real, op_error, build_object_call, resolve_args)\n\t(build_vfield_ref, check_dtor_name, build_scoped_method_call)\n\t(build_addr_func, build_call, build_method_call, null_ptr_cst_p)\n\t(sufficient_parms_p, build_conv, non_reference, strip_top_quals)\n\t(standard_conversion, reference_related_p)\n\t(reference_compatible_p, convert_class_to_reference)\n\t(direct_reference_binding, reference_binding)\n\t(implicit_conversion, is_complete, promoted_arithmetic_type_p)\n\t(add_template_conv_candidate, any_viable, any_strictly_viable)\n\t(build_this, splice_viable, print_z_candidates)\n\t(build_user_type_conversion, build_new_function_call)\n\t(conditional_conversion, build_conditional_expr, build_new_op)\n\t(build_op_delete_call, enforce_access, call_builtin_trap)\n\t(convert_arg_to_ellipsis, build_x_va_arg, cxx_type_promotes_to)\n\t(convert_default_arg, type_passed_as, convert_for_arg_passing)\n\t(in_charge_arg_for_name, is_properly_derived_from)\n\t(maybe_handle_implicit_object, maybe_handle_ref_bind)\n\t(source_type, add_warning, can_convert, can_convert_arg)\n\t(perform_implicit_conversion, can_convert_arg_bad)\n\t(initialize_reference, add_conv_candidate)\n\t(add_template_candidate_real, add_template_candidate): Ansify.\n\nFrom-SVN: r60458", "tree": {"sha": "07bc770b89e100b9ec961bf81290406b8627de22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07bc770b89e100b9ec961bf81290406b8627de22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94be8403e22d5e6965713e0920c1e451111bc110", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94be8403e22d5e6965713e0920c1e451111bc110", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94be8403e22d5e6965713e0920c1e451111bc110", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94be8403e22d5e6965713e0920c1e451111bc110/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c9693e96d4921c6abe1ff9c0a48022962206fced", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9693e96d4921c6abe1ff9c0a48022962206fced", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9693e96d4921c6abe1ff9c0a48022962206fced"}], "stats": {"total": 582, "additions": 242, "deletions": 340}, "files": [{"sha": "5776e5c470e390dc3fa0fc7e364c0946f42c13bf", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be8403e22d5e6965713e0920c1e451111bc110/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be8403e22d5e6965713e0920c1e451111bc110/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=94be8403e22d5e6965713e0920c1e451111bc110", "patch": "@@ -1,3 +1,29 @@\n+2002-12-23  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* call.c (tourney, build_field_call, equal_functions, joust) \n+\t(compare_ics, build_over_call, build_java_interface_fn_ref) \n+\t(convert_like_real, op_error, build_object_call, resolve_args) \n+\t(build_vfield_ref, check_dtor_name, build_scoped_method_call) \n+\t(build_addr_func, build_call, build_method_call, null_ptr_cst_p) \n+\t(sufficient_parms_p, build_conv, non_reference, strip_top_quals) \n+\t(standard_conversion, reference_related_p) \n+\t(reference_compatible_p, convert_class_to_reference) \n+\t(direct_reference_binding, reference_binding) \n+\t(implicit_conversion, is_complete, promoted_arithmetic_type_p) \n+\t(add_template_conv_candidate, any_viable, any_strictly_viable) \n+\t(build_this, splice_viable, print_z_candidates) \n+\t(build_user_type_conversion, build_new_function_call) \n+\t(conditional_conversion, build_conditional_expr, build_new_op) \n+\t(build_op_delete_call, enforce_access, call_builtin_trap) \n+\t(convert_arg_to_ellipsis, build_x_va_arg, cxx_type_promotes_to) \n+\t(convert_default_arg, type_passed_as, convert_for_arg_passing) \n+\t(in_charge_arg_for_name, is_properly_derived_from) \n+\t(maybe_handle_implicit_object, maybe_handle_ref_bind) \n+\t(source_type, add_warning, can_convert, can_convert_arg) \n+\t(perform_implicit_conversion, can_convert_arg_bad) \n+\t(initialize_reference, add_conv_candidate) \n+\t(add_template_candidate_real, add_template_candidate): Ansify.\n+\n 2002-12-22  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/8572"}, {"sha": "f1d46ba06bf8be4b189d67c8c5408755f6c22e61", "filename": "gcc/cp/call.c", "status": "modified", "additions": 187, "deletions": 311, "changes": 498, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be8403e22d5e6965713e0920c1e451111bc110/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be8403e22d5e6965713e0920c1e451111bc110/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=94be8403e22d5e6965713e0920c1e451111bc110", "patch": "@@ -40,74 +40,72 @@ Boston, MA 02111-1307, USA.  */\n \n extern int inhibit_warnings;\n \n-static tree build_field_call PARAMS ((tree, tree, tree));\n-static struct z_candidate * tourney PARAMS ((struct z_candidate *));\n-static int equal_functions PARAMS ((tree, tree));\n-static int joust PARAMS ((struct z_candidate *, struct z_candidate *, int));\n-static int compare_ics PARAMS ((tree, tree));\n-static tree build_over_call PARAMS ((struct z_candidate *, tree, int));\n-static tree build_java_interface_fn_ref PARAMS ((tree, tree));\n+static tree build_field_call (tree, tree, tree);\n+static struct z_candidate * tourney (struct z_candidate *);\n+static int equal_functions (tree, tree);\n+static int joust (struct z_candidate *, struct z_candidate *, bool);\n+static int compare_ics (tree, tree);\n+static tree build_over_call (struct z_candidate *, tree, int);\n+static tree build_java_interface_fn_ref (tree, tree);\n #define convert_like(CONV, EXPR) \\\n   convert_like_real ((CONV), (EXPR), NULL_TREE, 0, 0)\n #define convert_like_with_context(CONV, EXPR, FN, ARGNO) \\\n   convert_like_real ((CONV), (EXPR), (FN), (ARGNO), 0)\n-static tree convert_like_real PARAMS ((tree, tree, tree, int, int));\n-static void op_error PARAMS ((enum tree_code, enum tree_code, tree, tree,\n-\t\t\t    tree, const char *));\n-static tree build_object_call PARAMS ((tree, tree));\n-static tree resolve_args PARAMS ((tree));\n-static struct z_candidate * build_user_type_conversion_1\n-\tPARAMS ((tree, tree, int));\n-static void print_z_candidates PARAMS ((struct z_candidate *));\n-static tree build_this PARAMS ((tree));\n-static struct z_candidate * splice_viable PARAMS ((struct z_candidate *));\n-static int any_viable PARAMS ((struct z_candidate *));\n-static int any_strictly_viable PARAMS ((struct z_candidate *));\n-static struct z_candidate * add_template_candidate\n-\tPARAMS ((struct z_candidate *, tree, tree, tree, tree, tree, \n-\t\t tree, tree, int, unification_kind_t));\n-static struct z_candidate * add_template_candidate_real\n-\tPARAMS ((struct z_candidate *, tree, tree, tree, tree, tree, \n-\t\t tree, tree, int, tree, unification_kind_t));\n-static struct z_candidate * add_template_conv_candidate \n-        PARAMS ((struct z_candidate *, tree, tree, tree, tree, tree, tree));\n-static struct z_candidate * add_builtin_candidates\n-\tPARAMS ((struct z_candidate *, enum tree_code, enum tree_code,\n-\t       tree, tree *, int));\n-static struct z_candidate * add_builtin_candidate\n-\tPARAMS ((struct z_candidate *, enum tree_code, enum tree_code,\n-\t       tree, tree, tree, tree *, tree *, int));\n-static int is_complete PARAMS ((tree));\n-static struct z_candidate * build_builtin_candidate \n-\tPARAMS ((struct z_candidate *, tree, tree, tree, tree *, tree *,\n-\t       int));\n-static struct z_candidate * add_conv_candidate \n-\tPARAMS ((struct z_candidate *, tree, tree, tree, tree, tree));\n-static struct z_candidate * add_function_candidate \n+static tree convert_like_real (tree, tree, tree, int, int);\n+static void op_error (enum tree_code, enum tree_code, tree, tree,\n+\t\t\t    tree, const char *);\n+static tree build_object_call (tree, tree);\n+static tree resolve_args (tree);\n+static struct z_candidate *build_user_type_conversion_1 (tree, tree, int);\n+static void print_z_candidates (struct z_candidate *);\n+static tree build_this (tree);\n+static struct z_candidate *splice_viable (struct z_candidate *);\n+static bool any_viable (struct z_candidate *);\n+static bool any_strictly_viable (struct z_candidate *);\n+static struct z_candidate *add_template_candidate\n+        (struct z_candidate *, tree, tree, tree, tree, tree, \n+         tree, tree, int, unification_kind_t);\n+static struct z_candidate *add_template_candidate_real\n+\t(struct z_candidate *, tree, tree, tree, tree, tree, \n+           tree, tree, int, tree, unification_kind_t);\n+static struct z_candidate *add_template_conv_candidate \n+        (struct z_candidate *, tree, tree, tree, tree, tree, tree);\n+static struct z_candidate *add_builtin_candidates\n+\t(struct z_candidate *, enum tree_code, enum tree_code,\n+\t       tree, tree *, int);\n+static struct z_candidate *add_builtin_candidate\n+\t(struct z_candidate *, enum tree_code, enum tree_code,\n+\t       tree, tree, tree, tree *, tree *, int);\n+static bool is_complete (tree);\n+static struct z_candidate *build_builtin_candidate \n+\t(struct z_candidate *, tree, tree, tree, tree *, tree *,\n+\t       int);\n+static struct z_candidate *add_conv_candidate \n+\t(struct z_candidate *, tree, tree, tree, tree, tree);\n+static struct z_candidate *add_function_candidate \n \t(struct z_candidate *, tree, tree, tree, tree, tree, int);\n-static tree implicit_conversion PARAMS ((tree, tree, tree, int));\n-static tree standard_conversion PARAMS ((tree, tree, tree));\n-static tree reference_binding PARAMS ((tree, tree, tree, int));\n-static tree non_reference PARAMS ((tree));\n-static tree build_conv PARAMS ((enum tree_code, tree, tree));\n-static int is_subseq PARAMS ((tree, tree));\n-static tree maybe_handle_ref_bind PARAMS ((tree*));\n-static void maybe_handle_implicit_object PARAMS ((tree*));\n+static tree implicit_conversion (tree, tree, tree, int);\n+static tree standard_conversion (tree, tree, tree);\n+static tree reference_binding (tree, tree, tree, int);\n+static tree non_reference (tree);\n+static tree build_conv (enum tree_code, tree, tree);\n+static bool is_subseq (tree, tree);\n+static tree maybe_handle_ref_bind (tree *);\n+static void maybe_handle_implicit_object (tree *);\n static struct z_candidate *add_candidate \n         (struct z_candidate *, tree, tree, tree, tree, int);\n-static tree source_type PARAMS ((tree));\n-static void add_warning PARAMS ((struct z_candidate *, struct z_candidate *));\n-static int reference_related_p PARAMS ((tree, tree));\n-static int reference_compatible_p PARAMS ((tree, tree));\n-static tree convert_class_to_reference PARAMS ((tree, tree, tree));\n-static tree direct_reference_binding PARAMS ((tree, tree));\n-static int promoted_arithmetic_type_p PARAMS ((tree));\n-static tree conditional_conversion PARAMS ((tree, tree));\n-static tree call_builtin_trap PARAMS ((void));\n+static tree source_type (tree);\n+static void add_warning (struct z_candidate *, struct z_candidate *);\n+static bool reference_related_p (tree, tree);\n+static bool reference_compatible_p (tree, tree);\n+static tree convert_class_to_reference (tree, tree, tree);\n+static tree direct_reference_binding (tree, tree);\n+static bool promoted_arithmetic_type_p (tree);\n+static tree conditional_conversion (tree, tree);\n+static tree call_builtin_trap (void);\n \n tree\n-build_vfield_ref (datum, type)\n-     tree datum, type;\n+build_vfield_ref (tree datum, tree type)\n {\n   if (datum == error_mark_node)\n     return error_mark_node;\n@@ -163,15 +161,14 @@ build_field_call (tree instance_ptr, tree decl, tree parms)\n    (a BIT_NOT_EXPR) matches BASETYPE.  The operand of NAME can take many\n    forms...  */\n \n-int\n-check_dtor_name (basetype, name)\n-     tree basetype, name;\n+bool\n+check_dtor_name (tree basetype, tree name)\n {\n   name = TREE_OPERAND (name, 0);\n \n   /* Just accept something we've already complained about.  */\n   if (name == error_mark_node)\n-    return 1;\n+    return true;\n \n   if (TREE_CODE (name) == TYPE_DECL)\n     name = TREE_TYPE (name);\n@@ -194,21 +191,20 @@ check_dtor_name (basetype, name)\n \n      NAME will be a class template.  */\n   else if (DECL_CLASS_TEMPLATE_P (name))\n-    return 0;\n+    return false;\n   else\n     abort ();\n \n   if (name && TYPE_MAIN_VARIANT (basetype) == TYPE_MAIN_VARIANT (name))\n-    return 1;\n-  return 0;\n+    return true;\n+  return false;\n }\n \n /* Build a method call of the form `EXP->SCOPES::NAME (PARMS)'.\n    This is how virtual function calls are avoided.  */\n \n tree\n-build_scoped_method_call (exp, basetype, name, parms)\n-     tree exp, basetype, name, parms;\n+build_scoped_method_call (tree exp, tree basetype, tree name, tree parms)\n {\n   /* Because this syntactic form does not allow\n      a pointer to a base class to be `stolen',\n@@ -315,8 +311,7 @@ build_scoped_method_call (exp, basetype, name, parms)\n    pointer-to-member function.  */\n \n tree\n-build_addr_func (function)\n-     tree function;\n+build_addr_func (tree function)\n {\n   tree type = TREE_TYPE (function);\n \n@@ -351,8 +346,7 @@ build_addr_func (function)\n    (TYPE_PTRMEMFUNC_P) must be handled by our callers.  */\n \n tree\n-build_call (function, parms)\n-     tree function, parms;\n+build_call (tree function, tree parms)\n {\n   int is_constructor = 0;\n   int nothrow;\n@@ -464,9 +458,8 @@ extern int n_build_method_call;\n #endif\n \n tree\n-build_method_call (instance, name, parms, basetype_path, flags)\n-     tree instance, name, parms, basetype_path;\n-     int flags;\n+build_method_call (tree instance, tree name, tree parms,\n+                   tree basetype_path, int flags)\n {\n   tree fn;\n   tree object_type;\n@@ -635,39 +628,35 @@ struct z_candidate GTY(()) {\n #define USER_CONV_CAND(NODE) WRAPPER_ZC (TREE_OPERAND (NODE, 1))\n #define USER_CONV_FN(NODE) (USER_CONV_CAND (NODE)->fn)\n \n-int\n-null_ptr_cst_p (t)\n-     tree t;\n+bool\n+null_ptr_cst_p (tree t)\n {\n   /* [conv.ptr]\n \n      A null pointer constant is an integral constant expression\n      (_expr.const_) rvalue of integer type that evaluates to zero.  */\n   if (t == null_node\n       || (CP_INTEGRAL_TYPE_P (TREE_TYPE (t)) && integer_zerop (t)))\n-    return 1;\n-  return 0;\n+    return true;\n+  return false;\n }\n \n \n /* Returns nonzero if PARMLIST consists of only default parms and/or\n    ellipsis.  */\n \n-int\n-sufficient_parms_p (parmlist)\n-     tree parmlist;\n+bool\n+sufficient_parms_p (tree parmlist)\n {\n   for (; parmlist && parmlist != void_list_node;\n        parmlist = TREE_CHAIN (parmlist))\n     if (!TREE_PURPOSE (parmlist))\n-      return 0;\n-  return 1;\n+      return false;\n+  return true;\n }\n \n static tree\n-build_conv (code, type, from)\n-     enum tree_code code;\n-     tree type, from;\n+build_conv (enum tree_code code, tree type, tree from)\n {\n   tree t;\n   int rank = ICS_STD_RANK (from);\n@@ -706,17 +695,15 @@ build_conv (code, type, from)\n    Otherwise, return T itself.  */\n \n static tree\n-non_reference (t)\n-     tree t;\n+non_reference (tree t)\n {\n   if (TREE_CODE (t) == REFERENCE_TYPE)\n     t = TREE_TYPE (t);\n   return t;\n }\n \n tree\n-strip_top_quals (t)\n-     tree t;\n+strip_top_quals (tree t)\n {\n   if (TREE_CODE (t) == ARRAY_TYPE)\n     return t;\n@@ -728,18 +715,17 @@ strip_top_quals (t)\n    also pass the expression EXPR to convert from.  */\n \n static tree\n-standard_conversion (to, from, expr)\n-     tree to, from, expr;\n+standard_conversion (tree to, tree from, tree expr)\n {\n   enum tree_code fcode, tcode;\n   tree conv;\n-  int fromref = 0;\n+  bool fromref = false;\n \n   if (TREE_CODE (to) == REFERENCE_TYPE)\n     to = TREE_TYPE (to);\n   if (TREE_CODE (from) == REFERENCE_TYPE)\n     {\n-      fromref = 1;\n+      fromref = true;\n       from = TREE_TYPE (from);\n     }\n   to = strip_top_quals (to);\n@@ -943,10 +929,8 @@ standard_conversion (to, from, expr)\n \n /* Returns nonzero if T1 is reference-related to T2.  */\n \n-static int\n-reference_related_p (t1, t2)\n-     tree t1;\n-     tree t2;\n+static bool\n+reference_related_p (tree t1, tree t2)\n {\n   t1 = TYPE_MAIN_VARIANT (t1);\n   t2 = TYPE_MAIN_VARIANT (t2);\n@@ -963,10 +947,8 @@ reference_related_p (t1, t2)\n \n /* Returns nonzero if T1 is reference-compatible with T2.  */\n \n-static int\n-reference_compatible_p (t1, t2)\n-     tree t1;\n-     tree t2;\n+static bool\n+reference_compatible_p (tree t1, tree t2)\n {\n   /* [dcl.init.ref]\n \n@@ -981,10 +963,7 @@ reference_compatible_p (t1, t2)\n    converted to T as in [over.match.ref].  */\n \n static tree\n-convert_class_to_reference (t, s, expr)\n-     tree t;\n-     tree s;\n-     tree expr;\n+convert_class_to_reference (tree t, tree s, tree expr)\n {\n   tree conversions;\n   tree arglist;\n@@ -1095,9 +1074,7 @@ convert_class_to_reference (t, s, expr)\n    Return a conversion sequence for this binding.  */\n \n static tree\n-direct_reference_binding (type, conv)\n-     tree type;\n-     tree conv;\n+direct_reference_binding (tree type, tree conv)\n {\n   tree t = TREE_TYPE (type);\n \n@@ -1136,15 +1113,13 @@ direct_reference_binding (type, conv)\n    the conversion returned.  */\n \n static tree\n-reference_binding (rto, rfrom, expr, flags)\n-     tree rto, rfrom, expr;\n-     int flags;\n+reference_binding (tree rto, tree rfrom, tree expr, int flags)\n {\n   tree conv = NULL_TREE;\n   tree to = TREE_TYPE (rto);\n   tree from = rfrom;\n-  int related_p;\n-  int compatible_p;\n+  bool related_p;\n+  bool compatible_p;\n   cp_lvalue_kind lvalue_p = clk_none;\n \n   if (TREE_CODE (to) == FUNCTION_TYPE && expr && type_unknown_p (expr))\n@@ -1289,9 +1264,7 @@ reference_binding (rto, rfrom, expr, flags)\n    significant.  */\n \n static tree\n-implicit_conversion (to, from, expr, flags)\n-     tree to, from, expr;\n-     int flags;\n+implicit_conversion (tree to, tree from, tree expr, int flags)\n {\n   tree conv;\n   struct z_candidate *cand;\n@@ -1498,12 +1471,8 @@ add_function_candidate (struct z_candidate *candidates,\n    instead of the function.  */\n \n static struct z_candidate *\n-add_conv_candidate (candidates, fn, obj, arglist, access_path,\n-\t\t    conversion_path)\n-     struct z_candidate *candidates;\n-     tree fn, obj, arglist;\n-     tree access_path;\n-     tree conversion_path;\n+add_conv_candidate (struct z_candidate *candidates, tree fn, tree obj,\n+                    tree arglist, tree access_path, tree conversion_path)\n {\n   tree totype = TREE_TYPE (TREE_TYPE (fn));\n   int i, len, viable, flags;\n@@ -1568,12 +1537,9 @@ add_conv_candidate (candidates, fn, obj, arglist, access_path,\n }\n \n static struct z_candidate *\n-build_builtin_candidate (candidates, fnname, type1, type2,\n-\t\t\t args, argtypes, flags)\n-     struct z_candidate *candidates;\n-     tree fnname, type1, type2, *args, *argtypes;\n-     int flags;\n-\n+build_builtin_candidate (struct z_candidate *candidates, tree fnname,\n+                         tree type1, tree type2, tree *args, tree *argtypes,\n+                         int flags)\n {\n   tree t, convs;\n   int viable = 1, i;\n@@ -1619,18 +1585,16 @@ build_builtin_candidate (candidates, fnname, type1, type2,\n \t\t\tviable);\n }\n \n-static int\n-is_complete (t)\n-     tree t;\n+static bool\n+is_complete (tree t)\n {\n   return COMPLETE_TYPE_P (complete_type (t));\n }\n \n /* Returns nonzero if TYPE is a promoted arithmetic type.  */\n \n-static int\n-promoted_arithmetic_type_p (type)\n-     tree type;\n+static bool\n+promoted_arithmetic_type_p (tree type)\n {\n   /* [over.built]\n \n@@ -1655,12 +1619,9 @@ promoted_arithmetic_type_p (type)\n    CODE (TYPE1, TYPE1) and CODE (TYPE2, TYPE2).  */\n \n static struct z_candidate *\n-add_builtin_candidate (candidates, code, code2, fnname, type1, type2,\n-\t\t       args, argtypes, flags)\n-     struct z_candidate *candidates;\n-     enum tree_code code, code2;\n-     tree fnname, type1, type2, *args, *argtypes;\n-     int flags;\n+add_builtin_candidate (struct z_candidate *candidates, enum tree_code code,\n+                       enum tree_code code2, tree fnname, tree type1,\n+                       tree type2, tree *args, tree *argtypes, int flags)\n {\n   switch (code)\n     {\n@@ -2054,8 +2015,7 @@ add_builtin_candidate (candidates, code, code2, fnname, type1, type2,\n }\n \n tree\n-type_decays_to (type)\n-     tree type;\n+type_decays_to (tree type)\n {\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     return build_pointer_type (TREE_TYPE (type));\n@@ -2078,11 +2038,9 @@ type_decays_to (type)\n    filter out the invalid set.  */\n \n static struct z_candidate *\n-add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n-     struct z_candidate *candidates;\n-     enum tree_code code, code2;\n-     tree fnname, *args;\n-     int flags;\n+add_builtin_candidates (struct z_candidate *candidates, enum tree_code code,\n+                        enum tree_code code2, tree fnname, tree *args,\n+                        int flags)\n {\n   int ref1, i;\n   int enum_p = 0;\n@@ -2253,16 +2211,11 @@ add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n    add_conv_candidate.  */\n \n static struct z_candidate*\n-add_template_candidate_real (candidates, tmpl, ctype, explicit_targs,\n-\t\t\t     arglist, return_type, access_path,\n-\t\t\t     conversion_path, flags, obj, strict)\n-     struct z_candidate *candidates;\n-     tree tmpl, ctype, explicit_targs, arglist, return_type;\n-     tree access_path;\n-     tree conversion_path;\n-     int flags;\n-     tree obj;\n-     unification_kind_t strict;\n+add_template_candidate_real (struct z_candidate *candidates, tree tmpl,\n+                             tree ctype, tree explicit_targs, tree arglist,\n+                             tree return_type, tree access_path,\n+\t\t\t     tree conversion_path, int flags, tree obj,\n+                             unification_kind_t strict)\n {\n   int ntparms = DECL_NTPARMS (tmpl);\n   tree targs = make_tree_vec (ntparms);\n@@ -2357,15 +2310,10 @@ add_template_candidate_real (candidates, tmpl, ctype, explicit_targs,\n \n \n static struct z_candidate *\n-add_template_candidate (candidates, tmpl, ctype, explicit_targs, \n-\t\t\targlist, return_type, access_path, \n-\t\t\tconversion_path, flags, strict)\n-     struct z_candidate *candidates;\n-     tree tmpl, ctype, explicit_targs, arglist, return_type;\n-     tree access_path;\n-     tree conversion_path;\n-     int flags;\n-     unification_kind_t strict;\n+add_template_candidate (struct z_candidate *candidates, tree tmpl, tree ctype,\n+                        tree explicit_targs, tree arglist, tree return_type,\n+                        tree access_path, tree conversion_path, int flags,\n+                        unification_kind_t strict)\n {\n   return \n     add_template_candidate_real (candidates, tmpl, ctype,\n@@ -2376,12 +2324,9 @@ add_template_candidate (candidates, tmpl, ctype, explicit_targs,\n \n \n static struct z_candidate *\n-add_template_conv_candidate (candidates, tmpl, obj, arglist, return_type,\n-\t\t\t     access_path, conversion_path)\n-     struct z_candidate *candidates;\n-     tree tmpl, obj, arglist, return_type;\n-     tree access_path;\n-     tree conversion_path;\n+add_template_conv_candidate (struct z_candidate *candidates, tree tmpl,\n+                             tree obj, tree arglist, tree return_type,\n+\t\t\t     tree access_path, tree conversion_path)\n {\n   return \n     add_template_candidate_real (candidates, tmpl, NULL_TREE, NULL_TREE,\n@@ -2390,29 +2335,26 @@ add_template_conv_candidate (candidates, tmpl, obj, arglist, return_type,\n }\n \n \n-static int\n-any_viable (cands)\n-     struct z_candidate *cands;\n+static bool\n+any_viable (struct z_candidate *cands)\n {\n   for (; cands; cands = cands->next)\n     if (pedantic ? cands->viable == 1 : cands->viable)\n-      return 1;\n-  return 0;\n+      return true;\n+  return false;\n }\n \n-static int\n-any_strictly_viable (cands)\n-     struct z_candidate *cands;\n+static bool\n+any_strictly_viable (struct z_candidate *cands)\n {\n   for (; cands; cands = cands->next)\n     if (cands->viable == 1)\n-      return 1;\n-  return 0;\n+      return true;\n+  return false;\n }\n \n static struct z_candidate *\n-splice_viable (cands)\n-     struct z_candidate *cands;\n+splice_viable (struct z_candidate *cands)\n {\n   struct z_candidate **p = &cands;\n \n@@ -2428,16 +2370,14 @@ splice_viable (cands)\n }\n \n static tree\n-build_this (obj)\n-     tree obj;\n+build_this (tree obj)\n {\n   /* Fix this to work on non-lvalues.  */\n   return build_unary_op (ADDR_EXPR, obj, 0);\n }\n \n static void\n-print_z_candidates (candidates)\n-     struct z_candidate *candidates;\n+print_z_candidates (struct z_candidate *candidates)\n {\n   const char *str = \"candidates are:\";\n   for (; candidates; candidates = candidates->next)\n@@ -2473,9 +2413,7 @@ print_z_candidates (candidates)\n    per [dcl.init.ref], so we ignore temporary bindings.  */\n \n static struct z_candidate *\n-build_user_type_conversion_1 (totype, expr, flags)\n-     tree totype, expr;\n-     int flags;\n+build_user_type_conversion_1 (tree totype, tree expr, int flags)\n {\n   struct z_candidate *candidates, *cand;\n   tree fromtype = TREE_TYPE (expr);\n@@ -2645,9 +2583,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n }\n \n tree\n-build_user_type_conversion (totype, expr, flags)\n-     tree totype, expr;\n-     int flags;\n+build_user_type_conversion (tree totype, tree expr, int flags)\n {\n   struct z_candidate *cand\n     = build_user_type_conversion_1 (totype, expr, flags);\n@@ -2664,8 +2600,7 @@ build_user_type_conversion (totype, expr, flags)\n /* Do any initial processing on the arguments to a function call.  */\n \n static tree\n-resolve_args (args)\n-     tree args;\n+resolve_args (tree args)\n {\n   tree t;\n   for (t = args; t; t = TREE_CHAIN (t))\n@@ -2691,8 +2626,7 @@ resolve_args (args)\n    with the ARGS.  */\n       \n tree\n-build_new_function_call (fn, args)\n-     tree fn, args;\n+build_new_function_call (tree fn, tree args)\n {\n   struct z_candidate *candidates = 0, *cand;\n   tree explicit_targs = NULL_TREE;\n@@ -2775,8 +2709,7 @@ build_new_function_call (fn, args)\n }\n \n static tree\n-build_object_call (obj, args)\n-     tree obj, args;\n+build_object_call (tree obj, tree args)\n {\n   struct z_candidate *candidates = 0, *cand;\n   tree fns, convs, mem_args = NULL_TREE;\n@@ -2886,10 +2819,8 @@ build_object_call (obj, args)\n }\n \n static void\n-op_error (code, code2, arg1, arg2, arg3, problem)\n-     enum tree_code code, code2;\n-     tree arg1, arg2, arg3;\n-     const char *problem;\n+op_error (enum tree_code code, enum tree_code code2,\n+          tree arg1, tree arg2, tree arg3, const char *problem)\n {\n   const char *opname;\n \n@@ -2925,9 +2856,7 @@ op_error (code, code2, arg1, arg2, arg3, problem)\n    convert E1 to E2 in [expr.cond].  */\n \n static tree\n-conditional_conversion (e1, e2)\n-     tree e1;\n-     tree e2;\n+conditional_conversion (tree e1, tree e2)\n {\n   tree t1 = non_reference (TREE_TYPE (e1));\n   tree t2 = non_reference (TREE_TYPE (e2));\n@@ -2987,16 +2916,13 @@ conditional_conversion (e1, e2)\n    arguments to the conditional expression.  */\n \n tree\n-build_conditional_expr (arg1, arg2, arg3)\n-     tree arg1;\n-     tree arg2;\n-     tree arg3;\n+build_conditional_expr (tree arg1, tree arg2, tree arg3)\n {\n   tree arg2_type;\n   tree arg3_type;\n   tree result;\n   tree result_type = NULL_TREE;\n-  int lvalue_p = 1;\n+  bool lvalue_p = true;\n   struct z_candidate *candidates = 0;\n   struct z_candidate *cand;\n \n@@ -3071,7 +2997,7 @@ build_conditional_expr (arg1, arg2, arg3)\n \t  return error_mark_node;\n \t}\n \n-      lvalue_p = 0;\n+      lvalue_p = false;\n       goto valid_operands;\n     }\n   /* [expr.cond]\n@@ -3145,7 +3071,7 @@ build_conditional_expr (arg1, arg2, arg3)\n      cv-qualified) class type, overload resolution is used to\n      determine the conversions (if any) to be applied to the operands\n      (_over.match.oper_, _over.built_).  */\n-  lvalue_p = 0;\n+  lvalue_p = false;\n   if (!same_type_p (arg2_type, arg3_type)\n       && (CLASS_TYPE_P (arg2_type) || CLASS_TYPE_P (arg3_type)))\n     {\n@@ -3320,10 +3246,7 @@ build_conditional_expr (arg1, arg2, arg3)\n }\n \n tree\n-build_new_op (code, flags, arg1, arg2, arg3)\n-     enum tree_code code;\n-     int flags;\n-     tree arg1, arg2, arg3;\n+build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n {\n   struct z_candidate *candidates = 0, *cand;\n   tree fns, mem_arglist = NULL_TREE, arglist, fnname;\n@@ -3714,10 +3637,8 @@ build_new_op (code, flags, arg1, arg2, arg3)\n    PLACEMENT is the corresponding placement new call, or NULL_TREE.  */\n \n tree\n-build_op_delete_call (code, addr, size, flags, placement)\n-     enum tree_code code;\n-     tree addr, size, placement;\n-     int flags;\n+build_op_delete_call (enum tree_code code, tree addr, tree size,\n+                      int flags, tree placement)\n {\n   tree fn = NULL_TREE;\n   tree fns, fnname, fntype, argtypes, args, type;\n@@ -3853,15 +3774,10 @@ build_op_delete_call (code, addr, size, flags, placement)\n    BASETYPE_PATH, give an error.  The most derived class in\n    BASETYPE_PATH is the one used to qualify DECL.  */\n \n-int\n-enforce_access (basetype_path, decl)\n-     tree basetype_path;\n-     tree decl;\n+bool\n+enforce_access (tree basetype_path, tree decl)\n {\n-  int accessible;\n-\n-  accessible = accessible_p (basetype_path, decl);\n-  if (!accessible)\n+  if (!accessible_p (basetype_path, decl))\n     {\n       if (TREE_PRIVATE (decl))\n \tcp_error_at (\"`%+#D' is private\", decl);\n@@ -3870,10 +3786,10 @@ enforce_access (basetype_path, decl)\n       else\n \tcp_error_at (\"`%+#D' is inaccessible\", decl);\n       error (\"within this context\");\n-      return 0;\n+      return false;\n     }\n \n-  return 1;\n+  return true;\n }\n \n /* Perform the conversions in CONVS on the expression EXPR. \n@@ -3883,11 +3799,7 @@ enforce_access (basetype_path, decl)\n    reference binding will be applied, positive otherwise.  */\n \n static tree\n-convert_like_real (convs, expr, fn, argnum, inner)\n-     tree convs, expr;\n-     tree fn;\n-     int argnum;\n-     int inner;\n+convert_like_real (tree convs, tree expr, tree fn, int argnum, int inner)\n {\n   int savew, savee;\n \n@@ -4104,7 +4016,7 @@ convert_like_real (convs, expr, fn, argnum, inner)\n /* Build a call to __builtin_trap which can be used in an expression.  */\n \n static tree\n-call_builtin_trap ()\n+call_builtin_trap (void)\n {\n   tree fn = get_identifier (\"__builtin_trap\");\n   if (IDENTIFIER_GLOBAL_VALUE (fn))\n@@ -4122,8 +4034,7 @@ call_builtin_trap ()\n    Return the converted value.  */\n \n tree\n-convert_arg_to_ellipsis (arg)\n-     tree arg;\n+convert_arg_to_ellipsis (tree arg)\n {\n   if (TREE_CODE (TREE_TYPE (arg)) == REAL_TYPE\n       && (TYPE_PRECISION (TREE_TYPE (arg))\n@@ -4153,9 +4064,7 @@ call will abort at runtime\",\n /* va_arg (EXPR, TYPE) is a builtin. Make sure it is not abused.  */\n \n tree\n-build_x_va_arg (expr, type)\n-     tree expr;\n-     tree type;\n+build_x_va_arg (tree expr, tree type)\n {\n   if (processing_template_decl)\n     return build_min (VA_ARG_EXPR, type, expr);\n@@ -4180,8 +4089,7 @@ build_x_va_arg (expr, type)\n    type, or the passed type if there is no change.  */\n \n tree\n-cxx_type_promotes_to (type)\n-     tree type;\n+cxx_type_promotes_to (tree type)\n {\n   tree promote;\n \n@@ -4203,11 +4111,7 @@ cxx_type_promotes_to (type)\n    conversions.  Return the converted value.  */\n \n tree\n-convert_default_arg (type, arg, fn, parmnum)\n-     tree type;\n-     tree arg;\n-     tree fn;\n-     int parmnum;\n+convert_default_arg (tree type, tree arg, tree fn, int parmnum)\n {\n   if (TREE_CODE (arg) == DEFAULT_ARG)\n     {\n@@ -4258,8 +4162,7 @@ convert_default_arg (type, arg, fn, parmnum)\n    type TYPE.  */\n \n tree\n-type_passed_as (type)\n-     tree type;\n+type_passed_as (tree type)\n {\n   /* Pass classes with copy ctors by invisible reference.  */\n   if (TREE_ADDRESSABLE (type))\n@@ -4275,8 +4178,7 @@ type_passed_as (type)\n /* Actually perform the appropriate conversion.  */\n \n tree\n-convert_for_arg_passing (type, val)\n-     tree type, val;\n+convert_for_arg_passing (tree type, tree val)\n {\n   if (val == error_mark_node)\n     ;\n@@ -4296,10 +4198,7 @@ convert_for_arg_passing (type, val)\n    bitmask of various LOOKUP_* flags which apply to the call itself.  */\n \n static tree\n-build_over_call (cand, args, flags)\n-     struct z_candidate *cand;\n-     tree args;\n-     int flags;\n+build_over_call (struct z_candidate *cand, tree args, int flags)\n {\n   tree fn = cand->fn;\n   tree convs = cand->convs;\n@@ -4551,8 +4450,7 @@ static GTY(()) tree java_iface_lookup_fn;\n    _Jv_LookupInterfaceMethodIdx().  */\n \n static tree\n-build_java_interface_fn_ref (fn, instance)\n-    tree fn, instance;\n+build_java_interface_fn_ref (tree fn, tree instance)\n {\n   tree lookup_args, lookup_fn, method, idx;\n   tree klass_ref, iface, iface_ref;\n@@ -4613,8 +4511,7 @@ build_java_interface_fn_ref (fn, instance)\n    call to a function with the indicated NAME.  */\n \n tree\n-in_charge_arg_for_name (name)\n-     tree name;\n+in_charge_arg_for_name (tree name)\n {\n   if (name == base_ctor_identifier\n       || name == base_dtor_identifier)\n@@ -4915,12 +4812,11 @@ build_new_method_call (tree instance, tree fns, tree args,\n   return call;\n }\n \n-/* Returns nonzero iff standard conversion sequence ICS1 is a proper\n+/* Returns true iff standard conversion sequence ICS1 is a proper\n    subsequence of ICS2.  */\n \n-static int\n-is_subseq (ics1, ics2)\n-     tree ics1, ics2;\n+static bool\n+is_subseq (tree ics1, tree ics2)\n {\n   /* We can assume that a conversion of the same code\n      between the same types indicates a subsequence since we only get\n@@ -4943,29 +4839,27 @@ is_subseq (ics1, ics2)\n \t   ICS2.  We can get a USER_CONV when we are comparing the\n \t   second standard conversion sequence of two user conversion\n \t   sequences.  */\n-\treturn 0;\n+\treturn false;\n \n       ics2 = TREE_OPERAND (ics2, 0);\n \n       if (TREE_CODE (ics2) == TREE_CODE (ics1)\n \t  && same_type_p (TREE_TYPE (ics2), TREE_TYPE (ics1))\n \t  && same_type_p (TREE_TYPE (TREE_OPERAND (ics2, 0)),\n \t\t\t     TREE_TYPE (TREE_OPERAND (ics1, 0))))\n-\treturn 1;\n+\treturn true;\n     }\n }\n \n /* Returns nonzero iff DERIVED is derived from BASE.  The inputs may\n    be any _TYPE nodes.  */\n \n-int\n-is_properly_derived_from (derived, base)\n-     tree derived;\n-     tree base;\n+bool\n+is_properly_derived_from (tree derived, tree base)\n {\n   if (!IS_AGGR_TYPE_CODE (TREE_CODE (derived))\n       || !IS_AGGR_TYPE_CODE (TREE_CODE (base)))\n-    return 0;\n+    return false;\n \n   /* We only allow proper derivation here.  The DERIVED_FROM_P macro\n      considers every class derived from itself.  */\n@@ -4980,8 +4874,7 @@ is_properly_derived_from (derived, base)\n    modify it accordingly.  */\n \n static void\n-maybe_handle_implicit_object (ics)\n-     tree* ics;\n+maybe_handle_implicit_object (tree *ics)\n {\n   if (ICS_THIS_FLAG (*ics))\n     {\n@@ -5016,8 +4909,7 @@ maybe_handle_implicit_object (ics)\n    leave *ICS unchanged and return NULL_TREE.  */\n \n static tree\n-maybe_handle_ref_bind (ics)\n-     tree* ics;\n+maybe_handle_ref_bind (tree *ics)\n {\n   if (TREE_CODE (*ics) == REF_BIND)\n     {\n@@ -5040,8 +4932,7 @@ maybe_handle_ref_bind (ics)\n       0: ics1 and ics2 are indistinguishable */\n \n static int\n-compare_ics (ics1, ics2)\n-     tree ics1, ics2;\n+compare_ics (tree ics1, tree ics2)\n {\n   tree from_type1;\n   tree from_type2;\n@@ -5377,8 +5268,7 @@ compare_ics (ics1, ics2)\n /* The source type for this standard conversion sequence.  */\n \n static tree\n-source_type (t)\n-     tree t;\n+source_type (tree t)\n {\n   for (;; t = TREE_OPERAND (t, 0))\n     {\n@@ -5395,8 +5285,7 @@ source_type (t)\n    is actually used.  */\n \n static void\n-add_warning (winner, loser)\n-     struct z_candidate *winner, *loser;\n+add_warning (struct z_candidate *winner, struct z_candidate *loser)\n {\n   winner->warnings = tree_cons (NULL_TREE,\n \t\t\t\tbuild_zc_wrapper (loser),\n@@ -5408,9 +5297,7 @@ add_warning (winner, loser)\n    both are extern \"C\".  */\n \n static inline int\n-equal_functions (fn1, fn2)\n-     tree fn1;\n-     tree fn2;\n+equal_functions (tree fn1, tree fn2)\n {\n   if (DECL_LOCAL_FUNCTION_P (fn1) || DECL_LOCAL_FUNCTION_P (fn2)\n       || DECL_EXTERN_C_FUNCTION_P (fn1))\n@@ -5426,9 +5313,7 @@ equal_functions (fn1, fn2)\n       0: cand1 and cand2 are indistinguishable */\n \n static int\n-joust (cand1, cand2, warn)\n-     struct z_candidate *cand1, *cand2;\n-     int warn;\n+joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n {\n   int winner = 0;\n   int i, off1 = 0, off2 = 0, len;\n@@ -5702,8 +5587,7 @@ joust (cand1, cand2, warn)\n    algorithm.  */\n \n static struct z_candidate *\n-tourney (candidates)\n-     struct z_candidate *candidates;\n+tourney (struct z_candidate *candidates)\n {\n   struct z_candidate *champ = candidates, *challenger;\n   int fate;\n@@ -5754,31 +5638,27 @@ tourney (candidates)\n \n /* Returns nonzero if things of type FROM can be converted to TO.  */\n \n-int\n-can_convert (to, from)\n-     tree to, from;\n+bool\n+can_convert (tree to, tree from)\n {\n   return can_convert_arg (to, from, NULL_TREE);\n }\n \n /* Returns nonzero if ARG (of type FROM) can be converted to TO.  */\n \n-int\n-can_convert_arg (to, from, arg)\n-     tree to, from, arg;\n+bool\n+can_convert_arg (tree to, tree from, tree arg)\n {\n   tree t = implicit_conversion (to, from, arg, LOOKUP_NORMAL);\n   return (t && ! ICS_BAD_FLAG (t));\n }\n \n /* Like can_convert_arg, but allows dubious conversions as well.  */\n \n-int\n-can_convert_arg_bad (to, from, arg)\n-     tree to, from, arg;\n+bool\n+can_convert_arg_bad (tree to, tree from, tree arg)\n {\n-  tree t = implicit_conversion (to, from, arg, LOOKUP_NORMAL);\n-  return !!t;\n+  return implicit_conversion (to, from, arg, LOOKUP_NORMAL) != 0;\n }\n \n /* Convert EXPR to TYPE.  Return the converted expression.\n@@ -5788,9 +5668,7 @@ can_convert_arg_bad (to, from, arg)\n    doing a bad conversion, convert_like will complain.  */\n \n tree\n-perform_implicit_conversion (type, expr)\n-     tree type;\n-     tree expr;\n+perform_implicit_conversion (tree type, tree expr)\n {\n   tree conv;\n   \n@@ -5812,9 +5690,7 @@ perform_implicit_conversion (type, expr)\n    expression.  */\n \n tree\n-initialize_reference (type, expr)\n-     tree type;\n-     tree expr;\n+initialize_reference (tree type, tree expr)\n {\n   tree conv;\n "}, {"sha": "121aabac9e41ed55bd7271cfc9ca88514436e0f6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be8403e22d5e6965713e0920c1e451111bc110/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be8403e22d5e6965713e0920c1e451111bc110/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=94be8403e22d5e6965713e0920c1e451111bc110", "patch": "@@ -3535,39 +3535,40 @@ extern operator_name_info_t operator_name_info[];\n extern operator_name_info_t assignment_operator_name_info[];\n \n /* in call.c */\n-extern int check_dtor_name\t\t\tPARAMS ((tree, tree));\n+extern bool check_dtor_name (tree, tree);\n extern int get_arglist_len_in_bytes\t\tPARAMS ((tree));\n \n extern tree build_vfield_ref\t\t\tPARAMS ((tree, tree));\n-extern tree build_scoped_method_call\t\tPARAMS ((tree, tree, tree, tree));\n+extern tree build_scoped_method_call (tree, tree, tree, tree);\n extern tree build_conditional_expr\t\tPARAMS ((tree, tree, tree));\n-extern tree build_addr_func\t\t\tPARAMS ((tree));\n-extern tree build_call\t\t\t\tPARAMS ((tree, tree));\n-extern tree build_method_call\t\t\tPARAMS ((tree, tree, tree, tree, int));\n-extern int null_ptr_cst_p\t\t\tPARAMS ((tree));\n-extern int sufficient_parms_p                   PARAMS ((tree));\n-extern tree type_decays_to\t\t\tPARAMS ((tree));\n-extern tree build_user_type_conversion\t\tPARAMS ((tree, tree, int));\n-extern tree build_new_function_call\t\tPARAMS ((tree, tree));\n-extern tree build_new_method_call               (tree, tree, tree, tree, int);\n-extern tree build_special_member_call           (tree, tree, tree, tree, int);\n-extern tree build_new_op\t\t\tPARAMS ((enum tree_code, int, tree, tree, tree));\n-extern tree build_op_delete_call\t\tPARAMS ((enum tree_code, tree, tree, int, tree));\n-extern int can_convert\t\t\t\tPARAMS ((tree, tree));\n-extern int can_convert_arg\t\t\tPARAMS ((tree, tree, tree));\n-extern int can_convert_arg_bad\t\t\tPARAMS ((tree, tree, tree));\n-extern int enforce_access                       PARAMS ((tree, tree));\n-extern tree convert_default_arg                 PARAMS ((tree, tree, tree, int));\n-extern tree convert_arg_to_ellipsis             PARAMS ((tree));\n-extern tree build_x_va_arg                      PARAMS ((tree, tree));\n-extern tree cxx_type_promotes_to\t\tPARAMS ((tree));\n-extern tree type_passed_as                      PARAMS ((tree));\n-extern tree convert_for_arg_passing             PARAMS ((tree, tree));\n+extern tree build_addr_func (tree);\n+extern tree build_call (tree, tree);\n+extern tree build_method_call (tree, tree, tree, tree, int);\n+extern bool null_ptr_cst_p (tree);\n+extern bool sufficient_parms_p (tree);\n+extern tree type_decays_to (tree);\n+extern tree build_user_type_conversion (tree, tree, int);\n+extern tree build_new_function_call (tree, tree);\n+extern tree build_new_method_call (tree, tree, tree, tree, int);\n+extern tree build_special_member_call (tree, tree, tree, tree, int);\n+extern tree build_new_op (enum tree_code, int, tree, tree, tree);\n+extern tree build_op_delete_call (enum tree_code, tree, tree, int, tree);\n+extern bool can_convert (tree, tree);\n+extern bool can_convert_arg (tree, tree, tree);\n+extern bool can_convert_arg_bad (tree, tree, tree);\n+extern bool enforce_access (tree, tree);\n+extern tree convert_default_arg (tree, tree, tree, int);\n+extern tree convert_arg_to_ellipsis (tree);\n+extern tree build_x_va_arg (tree, tree);\n+extern tree cxx_type_promotes_to (tree);\n+extern tree type_passed_as (tree);\n+extern tree convert_for_arg_passing (tree, tree);\n extern tree cp_convert_parm_for_inlining        PARAMS ((tree, tree, tree));\n-extern int is_properly_derived_from             PARAMS ((tree, tree));\n-extern tree initialize_reference                PARAMS ((tree, tree));\n-extern tree strip_top_quals                     PARAMS ((tree));\n-extern tree perform_implicit_conversion         PARAMS ((tree, tree));\n+extern bool is_properly_derived_from (tree, tree);\n+extern tree initialize_reference (tree, tree);\n+extern tree strip_top_quals (tree);\n+extern tree perform_implicit_conversion (tree, tree);\n+extern tree in_charge_arg_for_name (tree);\n \n /* in class.c */\n extern tree build_base_path\t\t\tPARAMS ((enum tree_code, tree, tree, int));\n@@ -3611,7 +3612,6 @@ extern void invalidate_class_lookup_cache       PARAMS ((void));\n extern void maybe_note_name_used_in_class       PARAMS ((tree, tree));\n extern void note_name_declared_in_class         PARAMS ((tree, tree));\n extern tree get_vtbl_decl_for_binfo             PARAMS ((tree));\n-extern tree in_charge_arg_for_name              PARAMS ((tree));\n extern tree get_vtt_name                        PARAMS ((tree));\n extern tree get_primary_binfo                   PARAMS ((tree));\n "}]}