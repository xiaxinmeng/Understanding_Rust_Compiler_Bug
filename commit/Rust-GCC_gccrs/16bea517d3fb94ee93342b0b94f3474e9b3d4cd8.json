{"sha": "16bea517d3fb94ee93342b0b94f3474e9b3d4cd8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZiZWE1MTdkM2ZiOTRlZTkzMzQyYjBiOTRmMzQ3NGU5YjNkNGNkOA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-02-24T22:19:23Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-02-24T22:19:23Z"}, "message": "Correct typos and formatting problems.\n\n(add_constant, current_function_pretend_args_size,\nflag_traditional, table_lab): Delete unnecessary declarations.\n(sh_cpu): Change type from attr_cpu to processor_type.\n(need_slot, output_shift, lshiftrt_insns, howshift,\npop_operand): Delete.\n(print_operand, output_branch): Delete calls to need_slot.\n(synth_constant): Comment that it doesn't work.\n(output_movedouble): Handle PRE_DEC dest not POST_INC dest.\n(output_options): Don't use flag_traditional.\n(shift_insns): Correct numbers to optimal sequences.\n(shift_amounts): New table.\n(shift_insns_rtx): New function.\n(shiftinsns): Combine LSHIFTRT and ASHIFT cases.\n(shiftcosts): Return true costs of shifts instead of estimate of 1.\n(gen_ashift): Handle negative shift amounts.  Call gen_lshrsi3_m\nfor single bit LSHIFTRT, and gen_lshrisi3_k for multiple bit shifts.\n(gen_shifty_op): Handle negative shift amounts at top.  Generate\noptimal sequences for ASHIFT and LSHIFTRT.\n(find_barrier): Correct pattern for matching mova instructions.\n(general_movsrc_operand): Delete redundant test for (MEM LABEL_REF).\nDon't reject POST_INC address for size > 4.\n(general_movdst_operand): Don't reject PRE_DEC address for size > 4.\n\nFrom-SVN: r9062", "tree": {"sha": "ec557c626347b8ed741b1b8a8e604642ba01a936", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec557c626347b8ed741b1b8a8e604642ba01a936"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16bea517d3fb94ee93342b0b94f3474e9b3d4cd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16bea517d3fb94ee93342b0b94f3474e9b3d4cd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16bea517d3fb94ee93342b0b94f3474e9b3d4cd8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16bea517d3fb94ee93342b0b94f3474e9b3d4cd8/comments", "author": null, "committer": null, "parents": [{"sha": "994295f28a1382db2aa78f698f7829713fe06837", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/994295f28a1382db2aa78f698f7829713fe06837", "html_url": "https://github.com/Rust-GCC/gccrs/commit/994295f28a1382db2aa78f698f7829713fe06837"}], "stats": {"total": 715, "additions": 269, "deletions": 446}, "files": [{"sha": "0754336813fead02bcdcda8098130e9ba40bdb61", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 269, "deletions": 446, "changes": 715, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bea517d3fb94ee93342b0b94f3474e9b3d4cd8/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bea517d3fb94ee93342b0b94f3474e9b3d4cd8/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=16bea517d3fb94ee93342b0b94f3474e9b3d4cd8", "patch": "@@ -1,4 +1,4 @@\n-/* Output routines for GCC for Hitachi Super-H\n+/* Output routines for GCC for Hitachi Super-H.\n    Copyright (C) 1993, 1994 Free Software Foundation, Inc.\n \n    This file is part of GNU CC.\n@@ -17,8 +17,7 @@\n    along with GNU CC; see the file COPYING.  If not, write to\n    the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n-\n-/* Contributed by Steve Chamberlain (sac@cygnus.com) */\n+/* Contributed by Steve Chamberlain (sac@cygnus.com).  */\n \n #include <stdio.h>\n #include \"assert.h\"\n@@ -41,21 +40,14 @@\n #define MSW (TARGET_LITTLE_ENDIAN ? 1 : 0)\n #define LSW (TARGET_LITTLE_ENDIAN ? 0 : 1)\n \n-\n-static rtx add_constant ();\n-\n int pragma_interrupt;\n int pragma_trapa;\n \n int current_function_anonymous_args;\n-extern int current_function_pretend_args_size;\n+\n extern char *version_string;\n-extern int flag_traditional;\n \n static rtx shiftsyms[32];\n-struct rtx_def *table_lab;\n-enum attr_cpu sh_cpu;\t\t/* target cpu */\n-\n \n char *max_si;\n char *max_hi;\n@@ -64,14 +56,17 @@ int  max_count_hi;\n \n /* Global variables for machine-dependent things. */\n \n+/* Which cpu are we scheduling for.  */\n+enum processor_type sh_cpu;\n+\n /* Saved operands from the last compare to use when we generate an scc\n-   or bcc insn. */\n+   or bcc insn.  */\n \n rtx sh_compare_op0;\n rtx sh_compare_op1;\n \n /* Provides the class number of the smallest class containing\n-   reg number */\n+   reg number.  */\n \n int regno_reg_class[FIRST_PSEUDO_REGISTER] =\n {\n@@ -84,7 +79,7 @@ int regno_reg_class[FIRST_PSEUDO_REGISTER] =\n };\n \n /* Provide reg_class from a letter such as appears in the machine\n-   description. */\n+   description.  */\n \n enum reg_class reg_class_from_letter[] =\n {\n@@ -99,8 +94,7 @@ enum reg_class reg_class_from_letter[] =\n \n /* Value is 1 if register/mode pair is acceptable on SH.  Even\n    registers can hold DIs and DF values. The rest can only hold\n-   SI's efficiently  */\n-\n+   SI's efficiently.  */\n \n #define REG_ODD \\\n  (  (1 << (int) QImode)  | (1 << (int) HImode) | (1 << (int) SImode)\t\\\n@@ -128,18 +122,16 @@ static int lf = 100;\n \n \n /* Number of bytes pushed for anonymous args, used to pass information\n-   between expand_prologue and expand_epilogue. */\n+   between expand_prologue and expand_epilogue.  */\n static int extra_push;\n \f\n-\n-\n void\n push (rn)\n      int rn;\n {\n   rtx x ;\n   x=  emit_insn (gen_push (gen_rtx (REG, SImode, rn)));\n-  REG_NOTES (x) = gen_rtx (EXPR_LIST, REG_INC, \n+  REG_NOTES (x) = gen_rtx (EXPR_LIST, REG_INC,\n \t\t\t   gen_rtx(REG, SImode, STACK_POINTER_REGNUM), 0);\n }\n \n@@ -149,12 +141,11 @@ pop (rn)\n {\n   rtx x;\n   x =  emit_insn (gen_pop (gen_rtx (REG, SImode, rn)));\n-  REG_NOTES (x) = gen_rtx (EXPR_LIST, REG_INC, \n+  REG_NOTES (x) = gen_rtx (EXPR_LIST, REG_INC,\n \t\t\t   gen_rtx(REG, SImode, STACK_POINTER_REGNUM), 0);\n }\n \n-\n-/* Adjust the stack and return the number of bytes taken to do it */\n+/* Adjust the stack and return the number of bytes taken to do it.  */\n static rtx lastreg;\n int lastval;\n static void\n@@ -182,7 +173,7 @@ output_stack_adjust (size)\n \n \n /* Generate code to push the regs specified in the mask, and return\n-   the number of bytes the insns take. */\n+   the number of bytes the insns take.  */\n \n static void\n push_regs (mask)\n@@ -202,7 +193,7 @@ push_regs (mask)\n \n /* Print an instruction which would have gone into a delay slot after\n    another instruction, but couldn't because the other instruction expanded\n-   into a sequence where putting the slot insn at the end wouldn't work. */\n+   into a sequence where putting the slot insn at the end wouldn't work.  */\n \n static void\n print_slot (insn)\n@@ -219,8 +210,7 @@ print_slot (insn)\n \n    If doing a pragma interrupt function, then push all regs used by the function,\n    and if we call another function (we can tell by looking at PR), make sure that all the\n-   regs it clobbers are safe too.\n- */\n+   regs it clobbers are safe too.  */\n static int\n calc_live_regs (count_ptr)\n      int *count_ptr;\n@@ -239,7 +229,7 @@ calc_live_regs (count_ptr)\n \n       if (pragma_interrupt && !pragma_trapa)\n \t{\n-\t  /* Need to save all the regs ever live */\n+\t  /* Need to save all the regs ever live.  */\n \t  if ((regs_ever_live[reg]\n \t       || (call_used_regs[reg] && regs_ever_live[PR_REG]))\n \t      && reg != 15)\n@@ -250,7 +240,7 @@ calc_live_regs (count_ptr)\n \t}\n       else\n \t{\n-\t  /* Only push those regs which are used and need to be saved */\n+\t  /* Only push those regs which are used and need to be saved.  */\n \t  if (regs_ever_live[reg] && !call_used_regs[reg])\n \t    {\n \t      count++;\n@@ -264,19 +254,7 @@ calc_live_regs (count_ptr)\n   return live_regs_mask;\n }\n \f\n-/* This returns true if INSN is a conditional branch whose delay slot\n-   has been filled.  This indicates that it must be a bf.s/bt.s.\n-\n-   ??? This function could be eliminated.  */\n-\n-static int\n-need_slot (insn)\n-     rtx insn;\n-{\n-  return insn;\n-}\n-\n-/* Print the operand address in x to the stream */\n+/* Print the operand address in x to the stream.  */\n \n void\n print_operand_address (stream, x)\n@@ -295,7 +273,7 @@ print_operand_address (stream, x)\n \n \tif (GET_CODE (base) != REG)\n \t  {\n-\t    /* Ensure that BASE is a register (one of them must be). */\n+\t    /* Ensure that BASE is a register (one of them must be).  */\n \t    rtx temp = base;\n \t    base = index;\n \t    index = temp;\n@@ -347,7 +325,7 @@ print_operand_address (stream, x)\n    'S'  print the MSW of a dp value - changes if in little endian\n    'O'  print a constant without the #\n    'M'  print a constant as its negative\n-   'N'  print insides of a @++ or @-- o */\n+   'N'  print insides of a @++ or @-- o  */\n \n void\n print_operand (stream, x, code)\n@@ -358,7 +336,7 @@ print_operand (stream, x, code)\n   switch (code)\n     {\n     case '.':\n-      if (need_slot (final_sequence))\n+      if (final_sequence)\n \tfprintf (stream, \".s\");\n       break;\n     case '@':\n@@ -368,7 +346,7 @@ print_operand (stream, x, code)\n \tfprintf (stream, \"rts\");\n       break;\n     case '#':\n-      /* Output a nop if there's nothing in the delay slot */\n+      /* Output a nop if there's nothing in the delay slot.  */\n       if (dbr_sequence_length () == 0)\n \t{\n \t  fprintf (stream, \"\\n\\tnop\");\n@@ -384,7 +362,7 @@ print_operand (stream, x, code)\n       fputs (reg_names[REGNO (XEXP (XEXP (x, 0), 0))], (stream));\n       break;\n     case 'R':\n-      /* LSW of a double */\n+      /* LSW of a double.  */\n       switch (GET_CODE (x))\n \t{\n \tcase REG:\n@@ -396,7 +374,7 @@ print_operand (stream, x, code)\n \t}\n       break;\n     case 'T':\n-      /* Next word of a double */\n+      /* Next word of a double.  */\n       switch (GET_CODE (x))\n \t{\n \tcase REG:\n@@ -408,7 +386,7 @@ print_operand (stream, x, code)\n \t}\n       break;\n     case 'S':\n-      /* MSW of a double */\n+      /* MSW of a double.  */\n       switch (GET_CODE (x))\n \t{\n \tcase REG:\n@@ -437,7 +415,6 @@ print_operand (stream, x, code)\n     }\n }\n \f\n-\n static int\n sextb (x)\n   int x;\n@@ -478,9 +455,10 @@ sextb (x)\n \n    ??? Can add cases using swap.b and swap.w.\n    Can add cases using andi to get `1s 1s 1s 0NNNNNN1'.\n-   Can add many more cases for TARGET_CLEN3, but doubt their usefulness.\n+   Can add many more cases for TARGET_CLEN3, but doubt their usefulness.  */\n \n-*/\n+/* ??? This function does not do anything useful, because the sequences\n+   it emits are later eliminated by combine.  */\n \n static int\n synth_constant (operands, mode)\n@@ -489,7 +467,7 @@ synth_constant (operands, mode)\n {\n   rtx dst;\n   int i = INTVAL (operands[1]) & 0xffffffff;\n-    \n+\n   if (CONST_OK_FOR_I (i))\n     return 0;\n \n@@ -508,52 +486,52 @@ synth_constant (operands, mode)\n     }\n \n \n-  /*  00000000 00000000 11111111 1NNNNNNNN load and zero extend word      */\n+  /* 00000000 00000000 11111111 1NNNNNNNN load and zero extend word.  */\n   if ((i & 0xffffff80) == 0x0000ff80)\n     {\n       emit_move_insn (dst, GEN_INT (sextb (i)));\n       emit_insn (gen_zero_extendhisi2 (dst, gen_lowpart (HImode, dst)));\n     }\n-  /*    00000000 00000000 00000000 1NNNNNNNN load and zero extend byte */\n+  /* 00000000 00000000 00000000 1NNNNNNNN load and zero extend byte.  */\n   else if ((i & 0xffffff80) == 0x00000080)\n     {\n       emit_move_insn (dst, GEN_INT (sextb (i)));\n       emit_insn (gen_zero_extendqisi2 (dst, gen_lowpart (QImode, dst)));\n     }\n-  /*   00000000 00000000 00000000 NNNNNNNN0 load and shift by 1\n-       11111111 11111111 11111111 NNNNNNNN0 load and shift by 1 */\n+  /* 00000000 00000000 00000000 NNNNNNNN0 load and shift by 1\n+     11111111 11111111 11111111 NNNNNNNN0 load and shift by 1.  */\n   else if ((i & 0xffffff01) == 0\n \t   || (i & 0xffffff01) == 0xffffff00)\n     {\n       emit_move_insn (dst, GEN_INT (sextb (i >> 1)));\n       emit_insn (gen_ashlsi3_k (dst, dst, GEN_INT (1)));\n     }\n-  /*   00000000 00000000 0000000N NNNNNNN00 load and shift by 2\n-       11111111 11111111 1111111N NNNNNNN00 load and shift by 2*/\n+  /* 00000000 00000000 0000000N NNNNNNN00 load and shift by 2\n+     11111111 11111111 1111111N NNNNNNN00 load and shift by 2.  */\n   else if ((i & 0xfffffe03) == 0\n \t   || (i & 0xfffffe03) == 0xfffffe00)\n     {\n       emit_move_insn (dst, GEN_INT (sextb (i >> 2)));\n       emit_insn (gen_ashlsi3_k (dst, dst, GEN_INT (2)));\n     }\n-  /*   00000000 00000000 0NNNNNNN 000000000 load and shift by 8\n-       11111111 11111111 1NNNNNNN 000000000 load and shift by 8 */\n+  /* 00000000 00000000 0NNNNNNN 000000000 load and shift by 8\n+     11111111 11111111 1NNNNNNN 000000000 load and shift by 8.  */\n \n   else if ((i & 0xffff80ff) == 0\n \t   || (i & 0xffff80ff) == 0xffff8000)\n     {\n       emit_move_insn (dst, GEN_INT (sextb (i >> 8)));\n       emit_insn (gen_ashlsi3_k (dst, dst, GEN_INT (8)));\n     }\n-  /*     00000000 0NNNNNNN 00000000 000000000 load and shift by 16\n-\t 11111111 1NNNNNNN 00000000 000000000 load and shift by 16 */\n+  /* 00000000 0NNNNNNN 00000000 000000000 load and shift by 16\n+     11111111 1NNNNNNN 00000000 000000000 load and shift by 16.  */\n   else if ((i & 0xff80ffff) == 0x00000000\n \t   || (i & 0xff80ffff) == 0xff800000)\n     {\n       emit_move_insn (dst, GEN_INT (sextb (i >> 16)));\n       emit_insn (gen_ashlsi3_k (dst, dst, GEN_INT (16)));\n     }\n-  /*   00000000 00000000 0NNNNNNN 0NNNNNNNN load shift 8 and add */\n+  /* 00000000 00000000 0NNNNNNN 0NNNNNNNN load shift 8 and add.  */\n   else if ((i & 0xffff8080) == 0 && TARGET_CLEN3)\n     {\n       emit_move_insn (dst, GEN_INT (sextb (i >> 8)));\n@@ -565,9 +543,9 @@ synth_constant (operands, mode)\n \n   if (mode == DImode)\n     {\n-      /* Moving from SI to DI, we've got to zero out the high part */\n+      /* Moving from SI to DI, we've got to zero out the high part.  */\n \n-      emit_insn (gen_rtx (SET, VOIDmode, \n+      emit_insn (gen_rtx (SET, VOIDmode,\n \t\t\t  gen_rtx (SUBREG, SImode, operands[0], 0),\n \t\t\t  dst));\n       emit_insn (gen_rtx (SET, VOIDmode,\n@@ -592,7 +570,6 @@ synth_constant (operands, mode)\n    OPERANDS[2] is the size.\n    OPERANDS[3] is the alignment safe to use.  */\n \n-\n int\n expand_block_move (operands)\n      rtx *operands;\n@@ -602,11 +579,11 @@ expand_block_move (operands)\n   int bytes = (constp ? INTVAL (operands[2]) : 0);\n   enum machine_mode mode;\n \n-  /* IF odd then fail */\n+  /* If odd then fail.  */\n   if (!constp || bytes <= 0)\n     return 0;\n \n-  /* Don't expand if we'd make the code bigger and we don't want big code */\n+  /* Don't expand if we'd make the code bigger and we don't want big code.  */\n \n   if (bytes > 8 && TARGET_SMALLCODE)\n     return 0;\n@@ -659,7 +636,7 @@ expand_block_move (operands)\n       /* r6 controls the size of the move, 16 is decremented from it\n \t for each 64 bytes moved, then the -ve bit is used as an index into a\n \t list of move instructions like this:\n-\t\n+\n \t {\n \t do {\n \t *dst++ = *src++;\n@@ -670,7 +647,7 @@ expand_block_move (operands)\n \t *dst++ = *src++;\n \t size -= 16;\n \t } while (size > 0);\n-\t\n+\n \t switch (size)\n \t {\n \t case -15:\n@@ -686,9 +663,10 @@ expand_block_move (operands)\n \t ;\n \t }\n \t }\n-\t\n+\n \t eg, a 72 byte move would be set up with size(r6) = 14, for one\n-\t iteration through the big while loop, and a switch of -2 for the last part  */\n+\t iteration through the big while loop, and a switch of -2 for the\n+\t last part.  */\n \n       {\n \tint final_switch = 16 - ((bytes / 4) % 16);\n@@ -704,7 +682,7 @@ expand_block_move (operands)\n \n /* Prepare operands for a move define_expand; specifically, one of the\n    operands must be in a register.  Take this chance to remove\n-   addressing modes which can't be coped with very well. */\n+   addressing modes which can't be coped with very well.  */\n \n int\n prepare_move_operands (operands, mode)\n@@ -716,7 +694,7 @@ prepare_move_operands (operands, mode)\n \t   && !register_operand (operands[1], mode))\n \t  || GET_CODE (operands[1]) == PLUS))\n     {\n-      /* copy the source to a register */\n+      /* Copy the source to a register.  */\n       operands[1] = copy_to_mode_reg (mode, operands[1]);\n     }\n   if ((mode == SImode || mode == HImode || mode == QImode)\n@@ -795,7 +773,7 @@ prepare_scc_operands (code)\n       || REGNO (sh_compare_op0) != T_REG)\n     {\n       int newcode = code;\n-      /* First need a compare insn */\n+      /* First need a compare insn.  */\n       switch (code)\n \t{\n \tcase NE:\n@@ -835,15 +813,12 @@ prepare_scc_operands (code)\n   return gen_rtx (REG, SImode, T_REG);\n }\n \f\n-\n-/* Functions to output assembly code. */\n+/* Functions to output assembly code.  */\n \n /* Return a sequence of instructions to perform DI or DF move.\n \n    Since the SH cannot move a DI or DF in one instruction, we have\n-   to take care when we see overlapping source and dest registers.\n-\n- */\n+   to take care when we see overlapping source and dest registers.  */\n \n char *\n output_movedouble (insn, operands, mode)\n@@ -855,21 +830,18 @@ output_movedouble (insn, operands, mode)\n   rtx src = operands[1];\n \n   if (GET_CODE (dst) == MEM\n-      && GET_CODE (XEXP (dst, 0)) == POST_INC)\n+      && GET_CODE (XEXP (dst, 0)) == PRE_DEC)\n     {\n-      operands[0] = XEXP (XEXP (dst, 0), 0);\n-      return \"mov.l\t%T1,@(4,%0)\\n\\tmov.l\t%1,@%0\\n\\tadd\t#8,%0\";\n+      return \"mov.l\t%T1,%0\\n\\tmov.l\t%1,%0\";\n     }\n   if (register_operand (dst, mode)\n       && register_operand (src, mode))\n     {\n       if (REGNO (src) == MACH_REG)\n \treturn \"sts\tmach,%S0\\n\\tsts\tmacl,%R0\";\n \n-      /*\n-         when mov.d r1,r2 do r2->r3 then r1->r2\n-         when mov.d r1,r0 do r1->r0 then r2->r1\n-       */\n+      /* when mov.d r1,r2 do r2->r3 then r1->r2\n+         when mov.d r1,r0 do r1->r0 then r2->r1  */\n \n       if (REGNO (src) + 1 == REGNO (dst))\n \treturn \"mov\t%T1,%T0\\n\\tmov\t%1,%0\";\n@@ -949,7 +921,7 @@ output_movedouble (insn, operands, mode)\n \t    }\n \t  else\n \t    {\n-\t      /* Copy into dreg first. */\n+\t      /* Copy into dreg first.  */\n \t      fprintf (asm_out_file, \"\tmov.l\t@(%s),%s\\n\",\n \t\t       reg_names[ptrreg1],\n \t\t       reg_names[dreg]);\n@@ -963,94 +935,17 @@ output_movedouble (insn, operands, mode)\n \t  return \"\";\n \t}\n \n-      /* Work out the safe way to copy */\n+      /* Work out the safe way to copy.  */\n       if (dreg == ptrreg1)\n \t{\n-\t  /* Copy into the second half first */\n+\t  /* Copy into the second half first.  */\n \t  return \"mov.l\t%T1,%T0\\n\\tmov.l\t%1,%0\";\n \t}\n     }\n \n   return \"mov.l\t%1,%0\\n\\tmov.l\t%T1,%T0\";\n }\n \n-/* Emit assembly to shift reg by k bits */\n-\n-char *\n-output_shift (string, reg, k, code)\n-     char *string;\n-     rtx reg;\n-     rtx k;\n-     int code;\n-\n-{\n-  int s = INTVAL (k);\n-  if (s < 0)\n-    {\n-      s = -s;\n-      switch (code)\n-\t{\n-\tcase LSHIFTRT:\n-\tcase ASHIFTRT:\n-\t  code = ASHIFT;\n-\t  break;\n-\tcase ASHIFT:\n-\t  code = ASHIFTRT;\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-    }\n-  if (code == ASHIFT && s == 31)\n-    {\n-      /* Shift left by 31 moving into the t bit, clearing and rotating the other way */\n-\n-      fprintf (asm_out_file, \"\\trotr\tr%d\\n\", REGNO (reg));\n-      fprintf (asm_out_file, \"\\tmov\t#0,r%d\\n\", REGNO (reg));\n-      fprintf (asm_out_file, \"\\trotcr\tr%d\\n\", REGNO (reg));\n-      s = 0;\n-    }\n-\n-  if (code == LSHIFTRT && s == 31)\n-    {\n-      fprintf (asm_out_file, \"\\trotl\tr%d\\n\", REGNO (reg));\n-      fprintf (asm_out_file, \"\\tmov\t#0,r%d\\n\", REGNO (reg));\n-      fprintf (asm_out_file, \"\\trotcl\tr%d\\n\", REGNO (reg));\n-      s = 0;\n-    }\n-\n-  while (s)\n-    {\n-      char *out;\n-      int d;\n-\n-      if (s >= 16)\n-\t{\n-\t  d = 16;\n-\t  out = \"16\";\n-\t}\n-      else if (s >= 8)\n-\t{\n-\t  d = 8;\n-\t  out = \"8\";\n-\t}\n-      else if (s >= 2)\n-\t{\n-\t  d = 2;\n-\t  out = \"2\";\n-\t}\n-      else\n-\t{\n-\t  d = 1;\n-\t  out = \"\";\n-\t}\n-      fprintf (asm_out_file, \"\\t%s%s\\tr%d\\n\", string, out, REGNO (reg));\n-      s -= d;\n-    }\n-  return \"\";\n-}\n-\n-\n void\n function_epilogue (stream, size)\n      FILE *stream;\n@@ -1064,15 +959,15 @@ function_epilogue (stream, size)\n    attribute.\n \n    This gets tricky if we have an insn in the delay slot of a branch\n-   and the branch needs more than 1 insn to complete. */\n+   and the branch needs more than 1 insn to complete.  */\n \n int pending_const_table;\n \n  /* We can't tell if we need a register as a scratch for the jump\n     until after branch shortening, and then it's too late to allocate a\n     register the 'proper' way.  These instruction sequences are rare\n     anyway, so to avoid always using a reg up from our limited set, we'll\n-    grab one when we need one on output. */\n+    grab one when we need one on output.  */\n \n char *\n output_far_jump (insn, op)\n@@ -1086,7 +981,7 @@ output_far_jump (insn, op)\n       /* Something to go in what would have been the delay\n \t slot if this had been a short branch. Make sure the\n \t reg we use to generate the branch target address\n-\t doesn't conflict */\n+\t doesn't conflict.  */\n \n       int i;\n       rtx vec[2];\n@@ -1141,12 +1036,12 @@ output_branch (logic, insn)\n     case 6:\n       /* A branch with an unfilled delay slot.  */\n     case 8:\n-      /* Branch in range -4092..+4098 bytes */\n+      /* Branch in range -4092..+4098 bytes.  */\n       {\n \trtx oldop = recog_operand[0];\n \n \n-\tif (need_slot (final_sequence))\n+\tif (final_sequence)\n \t  {\n \t    fprintf (asm_out_file, \"\\tb%c.s\\tLF%d\\n\", logic ? 'f' : 't',\n \t\t     label);\n@@ -1170,11 +1065,11 @@ output_branch (logic, insn)\n     case 16:\n       /* A branch with an unfilled delay slot.  */\n     case 18:\n-      /* Branches a long way away */\n+      /* Branches a long way away.  */\n       {\n \trtx oldop = recog_operand[0];\n \n-\tif (need_slot (final_sequence))\n+\tif (final_sequence)\n \t  {\n \t    fprintf (asm_out_file, \"\\tb%c.s\\tLF%d\\n\", logic ? 'f' : 't', label);\n \t    print_slot (final_sequence);\n@@ -1193,7 +1088,6 @@ output_branch (logic, insn)\n   return \"bad\";\n }\n \f\n-\n /* The SH cannot load a large constant into a register, constants have to\n    come from a pc relative load.  The reference of a pc relative load\n    instruction must be less than 1k infront of the instruction.  This\n@@ -1246,22 +1140,20 @@ output_branch (logic, insn)\n    L3:.long value\n    L4:.long value\n \n-   Then the second move becomes the target for the shortening process.\n-\n- */\n+   Then the second move becomes the target for the shortening process.  */\n \n typedef struct\n {\n-  rtx value;\t\t\t/* Value in table */\n-  rtx label;\t\t\t/* Label of value */\n-  enum machine_mode mode;\t/* Mode of value */\n+  rtx value;\t\t\t/* Value in table.  */\n+  rtx label;\t\t\t/* Label of value.  */\n+  enum machine_mode mode;\t/* Mode of value.  */\n }\n \n pool_node;\n \n /* The maximum number of constants that can fit into one pool, since\n    the pc relative range is 0...1020 bytes and constants are at least 4\n-   bytes long */\n+   bytes long.  */\n \n #define MAX_POOL_SIZE (1020/4)\n static pool_node pool_vector[MAX_POOL_SIZE];\n@@ -1276,7 +1168,7 @@ add_constant (x, mode)\n {\n   int i;\n   rtx lab;\n-  /* First see if we've already got it */\n+  /* First see if we've already got it.  */\n \n   for (i = 0; i < pool_size; i++)\n     {\n@@ -1293,7 +1185,7 @@ add_constant (x, mode)\n \t}\n     }\n \n-  /* Need a new one */\n+  /* Need a new one.  */\n \n   pool_vector[pool_size].value = x;\n   lab = gen_label_rtx ();\n@@ -1303,7 +1195,7 @@ add_constant (x, mode)\n   return lab;\n }\n \n-/* Dump out interesting debug info */\n+/* Dump out interesting debug info.  */\n \n void\n final_prescan_insn (insn, opvec, noperands)\n@@ -1374,8 +1266,6 @@ output_options (file, f_options, f_len, W_options, W_len,\n     pos = output_option (file, sep, \"-O\", \"\", indent, pos, max);\n   if (write_symbols != NO_DEBUG)\n     pos = output_option (file, sep, \"-g\", \"\", indent, pos, max);\n-  if (flag_traditional)\n-    pos = output_option (file, sep, \"-traditional\", \"\", indent, pos, max);\n   if (profile_flag)\n     pos = output_option (file, sep, \"-p\", \"\", indent, pos, max);\n   if (profile_block_flag)\n@@ -1428,53 +1318,81 @@ output_file_start (file, f_options, f_len, W_options, W_len)\n \t\t  pos, 75, \" \", \"\\n! \", \"\\n\\n\");\n }\n \f\n+/* Actual number of instructions used to make a shift by N.  */\n+char ashiftrt_insns[] =\n+  { 0,1,2,3,4,5,8,8,8,8,8,8,8,8,8,8,2,3,4,5,8,8,8,8,8,8,8,8,8,8,8,2};\n+\n+/* Left shift and logical right shift are the same.  */\n+char shift_insns[]    =\n+  { 0,1,1,2,2,3,3,4,1,2,2,3,3,4,3,3,1,2,2,3,3,4,3,3,2,3,3,4,4,4,3,3};\n+/* Individual shift amounts needed to get the above length sequences.\n+   One bit right shifts clobber the T bit, so when possible, put one bit\n+   shifts in the middle of the sequence, so the ends are eligible for\n+   branch delay slots.  */\n+short shift_amounts[32][5] = {\n+  {0}, {1}, {2}, {2, 1},\n+  {2, 2}, {2, 1, 2}, {2, 2, 2}, {2, 2, 1, 2},\n+  {8}, {8, 1}, {8, 2}, {8, 1, 2},\n+  {8, 2, 2}, {8, 2, 1, 2}, {8, -2, 8}, {8, -1, 8},\n+  {16}, {16, 1}, {16, 2}, {16, 1, 2},\n+  {16, 2, 2}, {16, 2, 1, 2}, {16, -2, 8}, {16, -1, 8},\n+  {16, 8}, {16, 1, 8}, {16, 8, 2}, {16, 8, 1, 2},\n+  {16, 8, 2, 2}, {16, -1, -2, 8}, {16, -2, 16}, {16, -1, 16}};\n+\n+/* This is used in length attributes in sh.md to help compute the length\n+   of arbitrary constant shift instructions.  */\n \n-/* Actual number of instructions used to make a shift by N */\n-char ashiftrt_insns[] = { 0,1,2,3,4,5,8,8,8,8,8,8,8,8,8,8,2,3,4,5,8,8,8,8,8,8,8,8,8,8,8,2};\n-char lshiftrt_insns[] = { 0,1,1,2,2,3,3,4,1,2,2,3,3,4,4,5,1,2,2,3,3,4,4,5,2,3,3,4,4,5,5,6};\n-char shift_insns[]    = { 0,1,1,2,2,3,3,4,1,2,2,3,3,4,4,5,1,2,2,3,3,4,4,5,2,3,3,4,4,5,5,6};\n+int\n+shift_insns_rtx (insn)\n+     rtx insn;\n+{\n+  rtx set_src = SET_SRC (XVECEXP (PATTERN (insn), 0, 0));\n+  int shift_count = INTVAL (XEXP (set_src, 1));\n+  enum rtx_code shift_code = GET_CODE (set_src);\n \n-int \n+  switch (shift_code)\n+    {\n+    case ASHIFTRT:\n+      return ashiftrt_insns[shift_count];\n+    case LSHIFTRT:\n+    case ASHIFT:\n+      return shift_insns[shift_count];\n+    default:\n+      abort();\n+    }\n+}\n+\n+int\n shiftinsns (shift, n)\n enum rtx_code shift;\n int n;\n {\n-  switch (shift) \n+  switch (shift)\n     {\n     case ASHIFTRT:\n       return ashiftrt_insns[n];\n     case LSHIFTRT:\n-      return lshiftrt_insns[n];\n     case ASHIFT:\n       return shift_insns[n];\n     default:\n       abort();\n     }\n }\n \n-\n-\n-/* Return the cost of a shift */\n+/* Return the cost of a shift.  */\n \n int\n shiftcosts (RTX)\n      rtx RTX;\n {\n-  /* If shift by a non constant, then this will be expensive. */\n-  if (GET_CODE (XEXP (RTX, 1)) != CONST_INT) \n+  /* If shift by a non constant, then this will be expensive.  */\n+  if (GET_CODE (XEXP (RTX, 1)) != CONST_INT)\n     {\n       return 20;\n     }\n \n-  /* otherwise, it will be very cheap if by one of the constants\n-     we can cope with. */\n-\n-  if (CONST_OK_FOR_K (INTVAL (XEXP (RTX, 1))))\n-    return 1;\n-  /* otherwise it will be several insns, but we pretend that it will be more than\n-     just the components, so that combine doesn't glue together a load of shifts into\n-     one shift which has to be emitted as a bunch anyway - breaking scheduling */\n-  return 1;\n+  /* Otherwise, return the true cost in instructions.  */\n+  return shiftinsns (GET_CODE (RTX), INTVAL (XEXP (RTX, 1)));\n }\n \n int\n@@ -1485,47 +1403,16 @@ andcosts (RTX)\n   if (GET_CODE (XEXP (RTX, 1)) != CONST_INT)\n     return 2;\n   i = INTVAL (XEXP (RTX, 1));\n-  /* And can use the extend insns cheaply */\n+  /* And can use the extend insns cheaply.  */\n   if (i == 0xff || i == 0xffff)\n     return 2;\n-  /* Any small constant is reasonably cheap - but requires r0 */\n+  /* Any small constant is reasonably cheap - but requires r0.  */\n   if (CONST_OK_FOR_I (i))\n     return 3;\n   return 5;\n }\n \n-int \n-howshift (i)\n-     int i;\n-{\n-  int total = 0;\n-  while (i > 0)\n-    {\n-      if (i >= 16)\n-\t{\n-\t  total++;\n-\t  i -= 16;\n-\t}\n-      else if (i >= 8)\n-\t{\n-\t  total++;\n-\t  i -= 8;\n-\t}\n-      else if (i >= 2)\n-\t{\n-\t  total++;\n-\t  i -= 2;\n-\t}\n-      else if (i >= 1)\n-\t{\n-\t  total++;\n-\t  i--;\n-\t}\n-    }\n-  return total;\n-}\n-\n-/* Return the cost of a multiply */\n+/* Return the cost of a multiply.  */\n int\n multcosts (RTX)\n      rtx RTX;\n@@ -1534,36 +1421,49 @@ multcosts (RTX)\n     {\n       /* We have a mul insn, so we can never take more than the mul and the\n \t read of the mac reg, but count more because of the latency and extra\n-\t reg usage */\n+\t reg usage.  */\n       if (TARGET_SMALLCODE)\n \treturn 2;\n       return 3;\n     }\n \n   /* If we're aiming at small code, then just count the number of\n-     insns in a multiply call sequence */\n+     insns in a multiply call sequence.  */\n   if (TARGET_SMALLCODE)\n     return 6;\n \n-  /* Otherwise count all the insns in the routine we'd be calling too */\n+  /* Otherwise count all the insns in the routine we'd be calling too.  */\n   return 20;\n }\n \n-/* Code to expand a shift */\n+/* Code to expand a shift.  */\n \n void\n gen_ashift (type, n, reg)\n      int type;\n      int n;\n      rtx reg;\n {\n+  /* Negative values here come from the shift_amounts array.  */\n+  if (n < 0)\n+    {\n+      if (type == ASHIFT)\n+\ttype = LSHIFTRT;\n+      else\n+\ttype = ASHIFT;\n+      n = -n;\n+    }\n+\n   switch (type)\n     {\n     case ASHIFTRT:\n       emit_insn (gen_ashrsi3_k (reg, reg, GEN_INT (n)));\n       break;\n     case LSHIFTRT:\n-      emit_insn (gen_lshrsi3_k (reg, reg, GEN_INT (n)));\n+      if (n == 1)\n+\temit_insn (gen_lshrsi3_m (reg, reg, GEN_INT (n)));\n+      else\n+\temit_insn (gen_lshrsi3_k (reg, reg, GEN_INT (n)));\n       break;\n     case ASHIFT:\n       emit_insn (gen_ashlsi3_k (reg, reg, GEN_INT (n)));\n@@ -1576,115 +1476,81 @@ gen_shifty_op (code, operands)\n      int code;\n      rtx *operands;\n {\n-  rtx wrk = gen_reg_rtx (SImode);\n-  rtx t;\n+  rtx wrk, t;\n   char *func;\n+  int value = INTVAL (operands[2]);\n \n-  if (GET_CODE (operands[2]) == CONST_INT)\n+  /* ??? All of this code to handle negative shift counts here and elsewhere\n+     looks wrong.  */\n+  if (value < 0)\n     {\n-      int value = INTVAL (operands[2]);\n-    top:\n+      value = -value;\n+      if (code == ASHIFT)\n+\tcode = LSHIFTRT;\n+      else\n+\tcode = ASHIFT;\n+    }\n \n-      switch (code)\n+  switch (code)\n+    {\n+      /* ??? This code should be moved elsewhere.  */\n+    case ASHIFTRT:\n+      wrk = gen_reg_rtx (SImode);\n+\n+      if (value == 31)\n \t{\n-\tcase ASHIFTRT:\n-\t  if (value < 0)\n-\t    {\n-\t      code = ASHIFT;\n-\t      value = -value;\n-\t      goto top;\n-\t    }\n-\t  if (value == 31)\n-\t    {\n-\t      emit_insn (gen_ashrsi2_31 (operands[0], operands[1]));\n-\t      return 1;\n-\t    }\n-\t  else if (value >= 16 && value <= 19) \n-\t    {\n-\t      emit_insn (gen_ashrsi2_16 (wrk, operands[1]));\n-\t      value -= 16;\n-\t      while (value --)\n-\t\tgen_ashift (ASHIFTRT,1, wrk);\n-\t      emit_move_insn (operands[0], wrk);\n-\t      return 1;\n-\t    }\t  \n-\t  /* Expand a short sequence inline, longer call a magic routine */\n-\t  if (value <= 5)\n-\t    {\n-\t      emit_move_insn (wrk, operands[1]);\n-\t      while (value--)\n-\t\t{\n-\t\t  gen_ashift (ASHIFTRT, 1, wrk);\n-\t\t}\n-\t      emit_move_insn (operands[0], wrk);\n-\t      return 1;\n-\t    }\n-\t  t = gen_reg_rtx (Pmode);\n-\t  /*  Load the value into an arg reg and call a helper */\n-\t  emit_move_insn (gen_rtx (REG, SImode, 4), operands[1]);\n-\t  if (!shiftsyms[value])\n-\t    {\n-\t      func = xmalloc (18);\n-\t      sprintf (func, \"__ashiftrt_r4_%d\", value);\n-\t      shiftsyms[value] = gen_rtx (SYMBOL_REF, Pmode, func);\n-\t    }\n-\t  emit_move_insn (t, shiftsyms[value]);\n-\t  emit_insn (gen_ashrsi3_n (GEN_INT (value), t));\n-\t  emit_move_insn (operands[0], gen_rtx (REG, SImode, 4));\n+\t  emit_insn (gen_ashrsi2_31 (operands[0], operands[1]));\n \t  return 1;\n-\n-\tcase ASHIFT:\n-\t  if (value < 0)\n-\t    {\n-\t      code = LSHIFTRT;\n-\t      value = -value;\n-\t      goto top;\n-\t    }\n-\t  /* Fall through */\n-\tcase LSHIFTRT:\n-\n-\t  if (value < 0)\n-\t    {\n-\t      code = ASHIFT;\n-\t      value = -value;\n-\t      goto top;\n-\t    }\n-\n+\t}\n+      else if (value >= 16 && value <= 19)\n+\t{\n+\t  emit_insn (gen_ashrsi2_16 (wrk, operands[1]));\n+\t  value -= 16;\n+\t  while (value --)\n+\t    gen_ashift (ASHIFTRT,1, wrk);\n+\t  emit_move_insn (operands[0], wrk);\n+\t  return 1;\n+\t}\n+      /* Expand a short sequence inline, longer call a magic routine.  */\n+      if (value <= 5)\n+\t{\n \t  emit_move_insn (wrk, operands[1]);\n-\t  while (value)\n+\t  while (value--)\n \t    {\n-\t      if (value >= 16)\n-\t\t{\n-\t\t  gen_ashift (code, 16, wrk);\n-\t\t  value -= 16;\n-\t\t}\n-\t      else if (value >= 8)\n-\t\t{\n-\t\t  gen_ashift (code, 8, wrk);\n-\t\t  value -= 8;\n-\t\t}\n-\t      else if (value >= 2)\n-\t\t{\n-\t\t  gen_ashift (code, 2, wrk);\n-\t\t  value -= 2;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  gen_ashift (code, 1, wrk);\n-\t\t  value--;\n-\t\t}\n+\t      gen_ashift (ASHIFTRT, 1, wrk);\n \t    }\n \t  emit_move_insn (operands[0], wrk);\n \t  return 1;\n+\t}\n+      t = gen_reg_rtx (Pmode);\n+      /* Load the value into an arg reg and call a helper.  */\n+      emit_move_insn (gen_rtx (REG, SImode, 4), operands[1]);\n+      if (!shiftsyms[value])\n+\t{\n+\t  func = xmalloc (18);\n+\t  sprintf (func, \"__ashiftrt_r4_%d\", value);\n+\t  shiftsyms[value] = gen_rtx (SYMBOL_REF, Pmode, func);\n+\t}\n+      emit_move_insn (t, shiftsyms[value]);\n+      emit_insn (gen_ashrsi3_n (GEN_INT (value), t));\n+      emit_move_insn (operands[0], gen_rtx (REG, SImode, 4));\n+      return 1;\n \n+    case ASHIFT:\n+    case LSHIFTRT:\n+      /* ??? There are two instruction sequences for 31 bit shifts,\n+\t but we do not support them currently.  */\n+\t{\n+\t  int max = shiftinsns (code, value);\n+\t  int i;\n+\t  for (i = 0; i < max; i++)\n+\t    gen_ashift (code, shift_amounts[value][i], operands[0]);\n \t}\n     }\n-\n-  return 0;\n }\n \n /* Dump out any constants accumulated in the final pass -\n-   which will only be labels */\n+   which will only be labels.  */\n char *\n output_jump_label_table ()\n {\n@@ -1704,7 +1570,8 @@ output_jump_label_table ()\n \n   return \"\";\n }\n-/* Output the literal table */\n+\n+/* Output the literal table.  */\n \n static void\n dump_table (scan)\n@@ -1714,7 +1581,7 @@ dump_table (scan)\n   int need_align = 1;\n \n \n-  /* Do two passes, first time dump out the HI sized constants */\n+  /* Do two passes, first time dump out the HI sized constants.  */\n \n   for (i = 0; i < pool_size; i++)\n     {\n@@ -1771,17 +1638,15 @@ dump_table (scan)\n   pool_size = 0;\n }\n \n+/* Non zero if the src operand needs to be fixed up.  */\n \n-\n-/* Non zero if the src operand needs to be fixed up */\n-static\n-int\n+static int\n fixit (src, mode)\n      rtx src;\n      enum machine_mode mode;\n {\n   if (mode == QImode)\n-    return 0;\t\t\t/* QIs never need to be fixed */\n+    return 0;\t\t\t/* QIs never need to be fixed.  */\n   if (GET_CODE (src) == CONST)\n     return 1;\n \n@@ -1799,7 +1664,7 @@ fixit (src, mode)\n }\n \n /* Return Non-zero if constant would be an ok source for a\n-   mov.w instead of a mov.l */\n+   mov.w instead of a mov.l.  */\n int\n hi_const (src)\n      rtx src;\n@@ -1815,7 +1680,8 @@ hi_const (src)\n }\n \n /* Find the last barrier less than MAX_COUNT bytes from FROM, or create one.\n-   If an HI move is found, then make sure that MAX_COUNT_HI isn't broken from that one. */\n+   If an HI move is found, then make sure that MAX_COUNT_HI isn't broken from\n+   that one.  */\n \n /* ??? It would be good to put constant pool tables between a case jump and\n    the jump table.  This fails for two reasons.  First, there is no\n@@ -1846,7 +1712,7 @@ find_barrier (from)\n \t  found_barrier = from;\n \t}\n       /* Count the length of this insn - we assume that all moves will\n-\t be 2 bytes long, except the DIs */\n+\t be 2 bytes long, except the DIs.  */\n \n       if (GET_CODE (from) == INSN\n \t  && GET_CODE (PATTERN (from)) == SET\n@@ -1866,11 +1732,10 @@ find_barrier (from)\n \t  inc = get_attr_length (from);\n \t}\n \n-      /* ??? This isn't correct anymore.  The mova RTL has changed.  */\n       if (GET_CODE (from) == INSN\n \t  && GET_CODE (PATTERN (from)) == SET\n-\t  && GET_CODE (SET_DEST (PATTERN (from))) == REG\n-\t  && GET_CODE (SET_SRC (PATTERN (from))) == LABEL_REF)\n+\t  && GET_CODE (SET_SRC (PATTERN (from))) == UNSPEC\n+\t  && XINT (SET_SRC (PATTERN (from)), 1) == 1)\n \tfound_mova = from;\n       else if (GET_CODE (from) == JUMP_INSN\n \t       && (GET_CODE (PATTERN (from)) == ADDR_VEC\n@@ -1891,10 +1756,10 @@ find_barrier (from)\n \n   if (!found_barrier)\n     {\n-      /* We didn't find a barrier in time to \n-\t dump our stuff, so we'll make one */\n+      /* We didn't find a barrier in time to\n+\t dump our stuff, so we'll make one.  */\n       rtx label = gen_label_rtx ();\n-      /* Walk back to be just before any jump */\n+      /* Walk back to be just before any jump.  */\n       from = PREV_INSN (from);\n       while (GET_CODE (from) == JUMP_INSN\n \t     || GET_CODE (from) == NOTE\n@@ -1911,7 +1776,7 @@ find_barrier (from)\n   return found_barrier;\n }\n \n-/* Non zero if the insn is a move instruction which needs to be fixed. */\n+/* Non zero if the insn is a move instruction which needs to be fixed.  */\n \n static\n int\n@@ -1937,7 +1802,7 @@ broken_move (insn)\n /* Exported to toplev.c\n \n    Scan the function looking for move instructions which have to be changed to\n-   pcrel loads and insert the literal tables. */\n+   pcrel loads and insert the literal tables.  */\n \n void\n machine_dependent_reorg (first)\n@@ -1949,11 +1814,11 @@ machine_dependent_reorg (first)\n       if (broken_move (insn))\n \t{\n \t  /* This is a broken move instruction, scan ahead looking for\n-\t     a barrier to stick the constant table behind */\n+\t     a barrier to stick the constant table behind.  */\n \t  rtx scan;\n \t  rtx barrier = find_barrier (insn);\n \n-\t  /* Now find all the moves between the points and modify them */\n+\t  /* Now find all the moves between the points and modify them.  */\n \t  for (scan = insn; scan != barrier; scan = NEXT_INSN (scan))\n \t    {\n \t      if (broken_move (scan))\n@@ -1965,11 +1830,12 @@ machine_dependent_reorg (first)\n \t\t  rtx lab;\n \t\t  rtx newinsn;\n \t\t  rtx newsrc;\n-\t\t  /* This is a broken move instruction, add it to the pool */\n+\t\t  /* This is a broken move instruction, add it to the pool.  */\n \n \t\t  if (mode == SImode && hi_const (src))\n \t\t    {\n-\t\t      /* This is an HI source, clobber the dest to get the mode right too */\n+\t\t      /* This is an HI source, clobber the dest to get the\n+\t\t\t mode right too.  */\n \t\t      int offset = 0;\n \t\t      mode = HImode;\n \t\t      while (GET_CODE (dst) == SUBREG)\n@@ -1986,15 +1852,15 @@ machine_dependent_reorg (first)\n \t\t  /* Build a jump insn wrapper around the move instead\n \t\t     of an ordinary insn, because we want to have room for\n \t\t     the target label rtx in fld[7], which an ordinary\n-\t\t     insn doesn't have. */\n+\t\t     insn doesn't have.  */\n \t\t  newinsn = emit_jump_insn_after (gen_rtx (SET, VOIDmode,\n \t\t\t\t\t\t\tdst, newsrc), scan);\n \t\t  JUMP_LABEL (newinsn) = lab;\n \n-\t\t  /* But it's still an ordinary insn */\n+\t\t  /* But it's still an ordinary insn.  */\n \t\t  PUT_CODE (newinsn, INSN);\n \n-\t\t  /* Kill old insn */\n+\t\t  /* Kill old insn.  */\n \t\t  delete_insn (scan);\n \t\t  scan = newinsn;\n \t\t}\n@@ -2004,7 +1870,7 @@ machine_dependent_reorg (first)\n     }\n }\n \n-/* Called from the md file, set up the operands of a compare instruction */\n+/* Called from the md file, set up the operands of a compare instruction.  */\n \n void\n from_compare (operands, code)\n@@ -2013,7 +1879,7 @@ from_compare (operands, code)\n {\n   if (code != EQ && code != NE)\n     {\n-      /* Force args into regs, since we can't use constants here */\n+      /* Force args into regs, since we can't use constants here.  */\n       sh_compare_op0 = force_reg (SImode, sh_compare_op0);\n       if (sh_compare_op1 != const0_rtx\n \t  || code == GTU  || code == GEU || code == LTU || code == LEU)\n@@ -2023,7 +1889,7 @@ from_compare (operands, code)\n   operands[2] = sh_compare_op1;\n }\n \n-/* Non-zero if x is EQ or NE */\n+/* Non-zero if x is EQ or NE.  */\n \n int\n equality_operator (x, mode)\n@@ -2034,31 +1900,27 @@ equality_operator (x, mode)\n   return (code == EQ || code == NE);\n }\n \n- /* Framefull frame looks like:\n-\n-    arg-5\n-    arg-4\n-    [ if current_function_anonymous_args\n-    arg-3\n-    arg-2\n-    arg-1\n-    arg-0 ]\n-    saved-fp\n-    saved-r10\n-    saved-r11\n-    saved-r12\n-    saved-pr\n-    local-n\n-    ..\n-    local-1\n-    local-0        <- fp points here\n-\n-  */\n-\n+/* Framefull frame looks like:\n+\n+   arg-5\n+   arg-4\n+   [ if current_function_anonymous_args\n+   arg-3\n+   arg-2\n+   arg-1\n+   arg-0 ]\n+   saved-fp\n+   saved-r10\n+   saved-r11\n+   saved-r12\n+   saved-pr\n+   local-n\n+   ..\n+   local-1\n+   local-0        <- fp points here.  */\n \n  /* Code to generate prologue and epilogue sequences */\n \n-\n void\n sh_expand_prologue ()\n {\n@@ -2068,7 +1930,7 @@ sh_expand_prologue ()\n   live_regs_mask = calc_live_regs (&d);\n \n   /* We have pretend args if we had an object sent partially in registers\n-     and partially on the stack - eg a large structure */\n+     and partially on the stack - eg a large structure.  */\n   output_stack_adjust (-current_function_pretend_args_size);\n \n   extra_push = 0;\n@@ -2079,7 +1941,7 @@ sh_expand_prologue ()\n     {\n       current_function_anonymous_args = 0;\n \n-      /* Push arg regs as if they'd been provided by caller in stack */\n+      /* Push arg regs as if they'd been provided by caller in stack.  */\n       for (i = 0; i < NPARM_REGS; i++)\n \t{\n \t  int rn = NPARM_REGS + FIRST_PARM_REG - i - 1;\n@@ -2110,14 +1972,14 @@ sh_expand_epilogue ()\n   int d, i;\n \n   live_regs_mask = calc_live_regs (&d);\n-  \n+\n   if (frame_pointer_needed)\n     {\n       emit_insn (gen_movsi (stack_pointer_rtx, frame_pointer_rtx));\n     }\n   output_stack_adjust (get_frame_size ());\n \n-  /* Pop all the registers */\n+  /* Pop all the registers.  */\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n@@ -2156,14 +2018,14 @@ initial_elimination_offset (from, to)\n     }\n   if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n     {\n-      /* Initial gap between fp and sp is 0 */\n+      /* Initial gap between fp and sp is 0.  */\n       return 0;\n     }\n   abort ();\n }\n \n /* Handle machine specific pragmas to be semi-compatible with Hitachi\n-   compiler  */\n+   compiler.  */\n \n int\n handle_pragma (file)\n@@ -2198,7 +2060,7 @@ handle_pragma (file)\n   return c;\n }\n \f\n-/* insn expand helpers */\n+/* Insn expand helpers.  */\n \n /* Emit insns to perform a call.  */\n \n@@ -2231,24 +2093,17 @@ expand_acall (isa_retval, operands)\n \n }\n \f\n-\n-/* Predicates used by the templates */\n-\n+/* Predicates used by the templates.  */\n \n /* Returns 1 if OP can be source of a simple move operation.\n    Same as general_operand, but a LABEL_REF is valid, PRE_DEC is\n-   invalid as are subregs of system registers. */\n+   invalid as are subregs of system registers.  */\n \n int\n general_movsrc_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  /* Any MEM(label_ref) is ok, that's a pcrel load */\n-  if (GET_CODE (op) == MEM\n-      && GET_CODE (XEXP (op, 0)) == LABEL_REF)\n-    return 1;\n-\n   if (GET_CODE (op) == MEM)\n     {\n       rtx inside = XEXP (op, 0);\n@@ -2262,17 +2117,12 @@ general_movsrc_operand (op, mode)\n \t  && GET_CODE (XEXP (inside,0)) == LABEL_REF\n \t  && GET_CODE (XEXP (inside,1)) == CONST_INT)\n \treturn 1;\n-      \n-      /* No post inc allowed */\n+\n+      /* Only post inc allowed.  */\n       if (GET_CODE (inside) == POST_DEC\n \t  || GET_CODE (inside) == PRE_INC\n \t  || GET_CODE (inside) == PRE_DEC)\n \treturn 0;\n-\n-      /* Can't do that with large modes */\n-      if (GET_CODE (inside) == POST_INC\n-\t  && GET_MODE_SIZE (mode) > 4)\n-\treturn 0;\n     }\n \n   if ((mode == QImode || mode == HImode)\n@@ -2293,18 +2143,13 @@ general_movdst_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  /* No pre dec allowed */\n+  /* Only pre dec allowed.  */\n   if (GET_CODE (op) == MEM\n       && (GET_CODE (XEXP (op, 0)) == PRE_INC\n \t  || GET_CODE (XEXP (op, 0)) == POST_INC\n \t  || GET_CODE (XEXP (op, 0)) == POST_DEC))\n     return 0;\n \n-  if (GET_CODE (op) == MEM\n-      && GET_CODE (XEXP (op, 0)) == PRE_DEC\n-      && GET_MODE_SIZE (mode) > 4)\n-    return 0;\n-\n   return general_operand (op, mode);\n }\n \n@@ -2322,28 +2167,6 @@ byte_index_operand (op, mode)\n \t  && INTVAL (op) <= 15);\n }\n \n-/* Returns 1 if OP is a pop operand.   */\n-\n-int\n-pop_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-\n-  if (GET_MODE (op) != mode)\n-    return 0;\n-\n-  op = XEXP (op, 0);\n-\n-  if (GET_CODE (op) != POST_INC)\n-    return 0;\n-\n-  return XEXP (op, 0) == stack_pointer_rtx;\n-}\n-\n-\n /* Returns 1 if OP is a normal arithmetic register.  */\n \n int\n@@ -2421,18 +2244,18 @@ arith_reg_or_0_operand (op, mode)\n }\n \n \n-/* Returns 1 if OP is a valid count operand for a shift operation. */\n-int \n+/* Returns 1 if OP is a valid count operand for a shift operation.  */\n+int\n shiftby_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (immediate_operand (op, mode)) \n+  if (immediate_operand (op, mode))\n     return 1;\n   return 0;\n }\n \n-/* Returns 1 if OP is a valid source operand for a logical operation. */\n+/* Returns 1 if OP is a valid source operand for a logical operation.  */\n \n int\n logical_operand (op, mode)\n@@ -2478,7 +2301,7 @@ sh_function_arg (cum, mode, type, named)\n \t{\n \t  return (((type) == 0 || !TREE_ADDRESSABLE ((tree) (type)))\n \t\t  ? gen_rtx (REG, (mode),\n-\t\t\t     (FIRST_PARM_REG + rr)) \n+\t\t\t     (FIRST_PARM_REG + rr))\n \t\t  : 0);\n \n \t}"}]}