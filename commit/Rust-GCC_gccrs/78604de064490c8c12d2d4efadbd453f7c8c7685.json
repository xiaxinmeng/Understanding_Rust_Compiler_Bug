{"sha": "78604de064490c8c12d2d4efadbd453f7c8c7685", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg2MDRkZTA2NDQ5MGM4YzEyZDJkNGVmYWRiZDQ1M2Y3YzhjNzY4NQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-02-12T13:55:04Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-02-12T13:55:04Z"}, "message": "re PR tree-optimization/84037 (Speed regression of polyhedron benchmark since r256644)\n\n2018-02-12  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/84037\n\t* tree-vect-slp.c (vect_analyze_slp_cost): Add visited\n\tparameter, move visited init to caller.\n\t(vect_slp_analyze_operations): Separate cost from validity\n\tcheck, initialize visited once for all instances.\n\t(vect_schedule_slp): Analyze map to CSE vectorized nodes once\n\tfor all instances.\n\t* tree-vect-stmts.c (vect_model_simple_cost): Make early\n\tout an assert.\n\t(vect_model_promotion_demotion_cost): Likewise.\n\t(vectorizable_bswap): Guard cost modeling with !slp_node\n\tinstead of !PURE_SLP_STMT to avoid double-counting on hybrid\n\tSLP stmts.\n\t(vectorizable_call): Likewise.\n\t(vectorizable_conversion): Likewise.\n\t(vectorizable_assignment): Likewise.\n\t(vectorizable_shift): Likewise.\n\t(vectorizable_operation): Likewise.\n\t(vectorizable_store): Likewise.\n\t(vectorizable_load): Likewise.\n\t(vectorizable_condition): Likewise.\n\t(vectorizable_comparison): Likewise.\n\nFrom-SVN: r257588", "tree": {"sha": "41fce6fcdbb10087cd790b2c526e4f049acc8858", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41fce6fcdbb10087cd790b2c526e4f049acc8858"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78604de064490c8c12d2d4efadbd453f7c8c7685", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78604de064490c8c12d2d4efadbd453f7c8c7685", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78604de064490c8c12d2d4efadbd453f7c8c7685", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78604de064490c8c12d2d4efadbd453f7c8c7685/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e1f30526731145b3d047c6eede48915ad36a0921", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1f30526731145b3d047c6eede48915ad36a0921", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1f30526731145b3d047c6eede48915ad36a0921"}], "stats": {"total": 105, "additions": 70, "deletions": 35}, "files": [{"sha": "5a264391268281e1a0cd55ed51207106e0c596df", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78604de064490c8c12d2d4efadbd453f7c8c7685/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78604de064490c8c12d2d4efadbd453f7c8c7685/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78604de064490c8c12d2d4efadbd453f7c8c7685", "patch": "@@ -1,3 +1,28 @@\n+2018-02-12  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/84037\n+\t* tree-vect-slp.c (vect_analyze_slp_cost): Add visited\n+\tparameter, move visited init to caller.\n+\t(vect_slp_analyze_operations): Separate cost from validity\n+\tcheck, initialize visited once for all instances.\n+\t(vect_schedule_slp): Analyze map to CSE vectorized nodes once\n+\tfor all instances.\n+\t* tree-vect-stmts.c (vect_model_simple_cost): Make early\n+\tout an assert.\n+\t(vect_model_promotion_demotion_cost): Likewise.\n+\t(vectorizable_bswap): Guard cost modeling with !slp_node\n+\tinstead of !PURE_SLP_STMT to avoid double-counting on hybrid\n+\tSLP stmts.\n+\t(vectorizable_call): Likewise.\n+\t(vectorizable_conversion): Likewise.\n+\t(vectorizable_assignment): Likewise.\n+\t(vectorizable_shift): Likewise.\n+\t(vectorizable_operation): Likewise.\n+\t(vectorizable_store): Likewise.\n+\t(vectorizable_load): Likewise.\n+\t(vectorizable_condition): Likewise.\n+\t(vectorizable_comparison): Likewise.\n+\n 2018-02-12  Paolo Bonzini <bonzini@gnu.org>\n \n \tPR sanitizer/84307"}, {"sha": "73aa2271b531021bab52472a85e276de766a64d1", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78604de064490c8c12d2d4efadbd453f7c8c7685/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78604de064490c8c12d2d4efadbd453f7c8c7685/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=78604de064490c8c12d2d4efadbd453f7c8c7685", "patch": "@@ -2003,17 +2003,13 @@ vect_analyze_slp_cost_1 (slp_instance instance, slp_tree node,\n /* Compute the cost for the SLP instance INSTANCE.  */\n \n static void\n-vect_analyze_slp_cost (slp_instance instance, void *data)\n+vect_analyze_slp_cost (slp_instance instance, void *data, scalar_stmts_set_t *visited)\n {\n   stmt_vector_for_cost body_cost_vec, prologue_cost_vec;\n   unsigned ncopies_for_cost;\n   stmt_info_for_cost *si;\n   unsigned i;\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"=== vect_analyze_slp_cost ===\\n\");\n-\n   /* Calculate the number of vector stmts to create based on the unrolling\n      factor (number of vectors is 1 if NUNITS >= GROUP_SIZE, and is\n      GROUP_SIZE / NUNITS otherwise.  */\n@@ -2050,11 +2046,9 @@ vect_analyze_slp_cost (slp_instance instance, void *data)\n \n   prologue_cost_vec.create (10);\n   body_cost_vec.create (10);\n-  scalar_stmts_set_t *visited = new scalar_stmts_set_t ();\n   vect_analyze_slp_cost_1 (instance, SLP_INSTANCE_TREE (instance),\n \t\t\t   &prologue_cost_vec, &body_cost_vec,\n \t\t\t   ncopies_for_cost, visited);\n-  delete visited;\n \n   /* Record the prologue costs, which were delayed until we were\n      sure that SLP was successful.  */\n@@ -2871,13 +2865,19 @@ vect_slp_analyze_operations (vec_info *vinfo)\n           vinfo->slp_instances.ordered_remove (i);\n \t}\n       else\n-\t{\n-\t  /* Compute the costs of the SLP instance.  */\n-\t  vect_analyze_slp_cost (instance, vinfo->target_cost_data);\n-\t  i++;\n-\t}\n+\ti++;\n     }\n \n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"=== vect_analyze_slp_cost ===\\n\");\n+\n+  /* Compute the costs of the SLP instances.  */\n+  scalar_stmts_set_t *visited = new scalar_stmts_set_t ();\n+  for (i = 0; vinfo->slp_instances.iterate (i, &instance); ++i)\n+    vect_analyze_slp_cost (instance, vinfo->target_cost_data, visited);\n+  delete visited;\n+\n   return !vinfo->slp_instances.is_empty ();\n }\n \n@@ -4246,19 +4246,20 @@ vect_schedule_slp (vec_info *vinfo)\n   unsigned int i;\n   bool is_store = false;\n \n+\n+  scalar_stmts_to_slp_tree_map_t *bst_map\n+    = new scalar_stmts_to_slp_tree_map_t ();\n   slp_instances = vinfo->slp_instances;\n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     {\n       /* Schedule the tree of INSTANCE.  */\n-      scalar_stmts_to_slp_tree_map_t *bst_map\n-\t= new scalar_stmts_to_slp_tree_map_t ();\n       is_store = vect_schedule_slp_instance (SLP_INSTANCE_TREE (instance),\n                                              instance, bst_map);\n-      delete bst_map;\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n                          \"vectorizing stmts using SLP.\\n\");\n     }\n+  delete bst_map;\n \n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     {"}, {"sha": "a98e0e5e2593bb4a46a1d338f8750c8bbbb004bb", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78604de064490c8c12d2d4efadbd453f7c8c7685/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78604de064490c8c12d2d4efadbd453f7c8c7685/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=78604de064490c8c12d2d4efadbd453f7c8c7685", "patch": "@@ -826,8 +826,7 @@ vect_model_simple_cost (stmt_vec_info stmt_info, int ncopies,\n   int inside_cost = 0, prologue_cost = 0;\n \n   /* The SLP costs were already calculated during SLP tree build.  */\n-  if (PURE_SLP_STMT (stmt_info))\n-    return;\n+  gcc_assert (!PURE_SLP_STMT (stmt_info));\n \n   /* Cost the \"broadcast\" of a scalar operand in to a vector operand.\n      Use scalar_to_vec to cost the broadcast, as elsewhere in the vector\n@@ -864,8 +863,7 @@ vect_model_promotion_demotion_cost (stmt_vec_info stmt_info,\n   void *target_cost_data;\n \n   /* The SLP costs were already calculated during SLP tree build.  */\n-  if (PURE_SLP_STMT (stmt_info))\n-    return;\n+  gcc_assert (!PURE_SLP_STMT (stmt_info));\n \n   if (loop_vinfo)\n     target_cost_data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n@@ -2891,7 +2889,7 @@ vectorizable_bswap (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location, \"=== vectorizable_bswap ===\"\n                          \"\\n\");\n-      if (! PURE_SLP_STMT (stmt_info))\n+      if (! slp_node)\n \t{\n \t  add_stmt_cost (stmt_info->vinfo->target_cost_data,\n \t\t\t 1, vector_stmt, stmt_info, 0, vect_prologue);\n@@ -3210,10 +3208,13 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location, \"=== vectorizable_call ===\"\n                          \"\\n\");\n-      vect_model_simple_cost (stmt_info, ncopies, dt, ndts, NULL, NULL);\n-      if (ifn != IFN_LAST && modifier == NARROW && !slp_node)\n-\tadd_stmt_cost (stmt_info->vinfo->target_cost_data, ncopies / 2,\n-\t\t       vec_promote_demote, stmt_info, 0, vect_body);\n+      if (!slp_node)\n+\t{\n+\t  vect_model_simple_cost (stmt_info, ncopies, dt, ndts, NULL, NULL);\n+\t  if (ifn != IFN_LAST && modifier == NARROW && !slp_node)\n+\t    add_stmt_cost (stmt_info->vinfo->target_cost_data, ncopies / 2,\n+\t\t\t   vec_promote_demote, stmt_info, 0, vect_body);\n+\t}\n \n       return true;\n     }\n@@ -4742,17 +4743,20 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (code == FIX_TRUNC_EXPR || code == FLOAT_EXPR)\n         {\n \t  STMT_VINFO_TYPE (stmt_info) = type_conversion_vec_info_type;\n-\t  vect_model_simple_cost (stmt_info, ncopies, dt, ndts, NULL, NULL);\n+\t  if (!slp_node)\n+\t    vect_model_simple_cost (stmt_info, ncopies, dt, ndts, NULL, NULL);\n \t}\n       else if (modifier == NARROW)\n \t{\n \t  STMT_VINFO_TYPE (stmt_info) = type_demotion_vec_info_type;\n-\t  vect_model_promotion_demotion_cost (stmt_info, dt, multi_step_cvt);\n+\t  if (!slp_node)\n+\t    vect_model_promotion_demotion_cost (stmt_info, dt, multi_step_cvt);\n \t}\n       else\n \t{\n \t  STMT_VINFO_TYPE (stmt_info) = type_promotion_vec_info_type;\n-\t  vect_model_promotion_demotion_cost (stmt_info, dt, multi_step_cvt);\n+\t  if (!slp_node)\n+\t    vect_model_promotion_demotion_cost (stmt_info, dt, multi_step_cvt);\n \t}\n       interm_types.release ();\n       return true;\n@@ -5149,7 +5153,8 @@ vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n                          \"=== vectorizable_assignment ===\\n\");\n-      vect_model_simple_cost (stmt_info, ncopies, dt, ndts, NULL, NULL);\n+      if (!slp_node)\n+\tvect_model_simple_cost (stmt_info, ncopies, dt, ndts, NULL, NULL);\n       return true;\n     }\n \n@@ -5513,7 +5518,8 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n                          \"=== vectorizable_shift ===\\n\");\n-      vect_model_simple_cost (stmt_info, ncopies, dt, ndts, NULL, NULL);\n+      if (!slp_node)\n+\tvect_model_simple_cost (stmt_info, ncopies, dt, ndts, NULL, NULL);\n       return true;\n     }\n \n@@ -5836,7 +5842,8 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n                          \"=== vectorizable_operation ===\\n\");\n-      vect_model_simple_cost (stmt_info, ncopies, dt, ndts, NULL, NULL);\n+      if (!slp_node)\n+\tvect_model_simple_cost (stmt_info, ncopies, dt, ndts, NULL, NULL);\n       return true;\n     }\n \n@@ -6240,7 +6247,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n       STMT_VINFO_TYPE (stmt_info) = store_vec_info_type;\n       /* The SLP costs are calculated during SLP analysis.  */\n-      if (!PURE_SLP_STMT (stmt_info))\n+      if (!slp_node)\n \tvect_model_store_cost (stmt_info, ncopies, memory_access_type,\n \t\t\t       vls_type, NULL, NULL, NULL);\n       return true;\n@@ -7451,7 +7458,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n       STMT_VINFO_TYPE (stmt_info) = load_vec_info_type;\n       /* The SLP costs are calculated during SLP analysis.  */\n-      if (!PURE_SLP_STMT (stmt_info))\n+      if (! slp_node)\n \tvect_model_load_cost (stmt_info, ncopies, memory_access_type,\n \t\t\t      NULL, NULL, NULL);\n       return true;\n@@ -8673,7 +8680,8 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (expand_vec_cond_expr_p (vectype, comp_vectype,\n \t\t\t\t     cond_code))\n \t{\n-\t  vect_model_simple_cost (stmt_info, ncopies, dts, ndts, NULL, NULL);\n+\t  if (!slp_node)\n+\t    vect_model_simple_cost (stmt_info, ncopies, dts, ndts, NULL, NULL);\n \t  return true;\n \t}\n       return false;\n@@ -9037,8 +9045,9 @@ vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (!vec_stmt)\n     {\n       STMT_VINFO_TYPE (stmt_info) = comparison_vec_info_type;\n-      vect_model_simple_cost (stmt_info, ncopies * (1 + (bitop2 != NOP_EXPR)),\n-\t\t\t      dts, ndts, NULL, NULL);\n+      if (!slp_node)\n+\tvect_model_simple_cost (stmt_info, ncopies * (1 + (bitop2 != NOP_EXPR)),\n+\t\t\t\tdts, ndts, NULL, NULL);\n       if (bitop1 == NOP_EXPR)\n \treturn expand_vec_cmp_expr_p (vectype, mask_type, code);\n       else"}]}