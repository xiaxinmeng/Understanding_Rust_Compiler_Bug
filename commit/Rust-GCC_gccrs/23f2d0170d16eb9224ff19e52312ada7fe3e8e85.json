{"sha": "23f2d0170d16eb9224ff19e52312ada7fe3e8e85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNmMmQwMTcwZDE2ZWI5MjI0ZmYxOWU1MjMxMmFkYTdmZTNlOGU4NQ==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael.morin@tele2.fr", "date": "2009-01-04T13:01:12Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2009-01-04T13:01:12Z"}, "message": "re PR fortran/38536 (ICE with C_LOC in resolve.c due to not properly going through expr->ref)\n\n2009-01-04  Mikael Morin  <mikael.morin@tele2.fr>\n\n\tPR fortran/38536\n\t* gfortran.h (gfc_is_data_pointer): Added prototype\n\t* resolve.c (gfc_iso_c_func_interface):\n\tUse gfc_is_data_pointer to test for pointer attribute.\n\t* dependency.c (gfc_is_data_pointer):\n\tSupport pointer-returning functions.\n\n2009-01-04  Mikael Morin  <mikael.morin@tele2.fr>\n\n\tPR fortran/38536\n\t* gfortran.dg/c_loc_tests_13.f90: New test.\n\t* gfortran.dg/c_loc_tests_14.f90: New test.\n\nFrom-SVN: r143050", "tree": {"sha": "5735583d91215ed5ce6a12d11b3ab4d7aaafce06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5735583d91215ed5ce6a12d11b3ab4d7aaafce06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23f2d0170d16eb9224ff19e52312ada7fe3e8e85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23f2d0170d16eb9224ff19e52312ada7fe3e8e85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23f2d0170d16eb9224ff19e52312ada7fe3e8e85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23f2d0170d16eb9224ff19e52312ada7fe3e8e85/comments", "author": null, "committer": null, "parents": [{"sha": "1a8c13b33ce1470d5a291063a5f5d0beebf421ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a8c13b33ce1470d5a291063a5f5d0beebf421ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a8c13b33ce1470d5a291063a5f5d0beebf421ee"}], "stats": {"total": 110, "additions": 72, "deletions": 38}, "files": [{"sha": "e3c652c6c0c2dd9d3b74bbcb5d64cb2b14753357", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23f2d0170d16eb9224ff19e52312ada7fe3e8e85/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23f2d0170d16eb9224ff19e52312ada7fe3e8e85/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=23f2d0170d16eb9224ff19e52312ada7fe3e8e85", "patch": "@@ -1,3 +1,12 @@\n+2009-01-04  Mikael Morin  <mikael.morin@tele2.fr>\n+\n+\tPR fortran/38536\n+\t* gfortran.h (gfc_is_data_pointer): Added prototype\n+\t* resolve.c (gfc_iso_c_func_interface):\n+\tUse gfc_is_data_pointer to test for pointer attribute.\n+\t* dependency.c (gfc_is_data_pointer):\n+\tSupport pointer-returning functions.\n+\n 2009-01-03  Daniel Franke  <franke.daniel@gmail.com>\n \n \t* symbol.c (save_symbol): Don't SAVE function results."}, {"sha": "639d6e3b747cf93eac23e78b75a858a78f7cbf6e", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23f2d0170d16eb9224ff19e52312ada7fe3e8e85/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23f2d0170d16eb9224ff19e52312ada7fe3e8e85/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=23f2d0170d16eb9224ff19e52312ada7fe3e8e85", "patch": "@@ -422,16 +422,20 @@ gfc_ref_needs_temporary_p (gfc_ref *ref)\n }\n \n \n-static int\n+int\n gfc_is_data_pointer (gfc_expr *e)\n {\n   gfc_ref *ref;\n \n-  if (e->expr_type != EXPR_VARIABLE)\n+  if (e->expr_type != EXPR_VARIABLE && e->expr_type != EXPR_FUNCTION)\n     return 0;\n \n+  /* No subreference if it is a function  */\n+  gcc_assert (e->expr_type == EXPR_VARIABLE || !e->ref);\n+\n   if (e->symtree->n.sym->attr.pointer)\n     return 1;\n+\n   for (ref = e->ref; ref; ref = ref->next)\n     if (ref->type == REF_COMPONENT && ref->u.c.component->attr.pointer)\n       return 1;"}, {"sha": "bb2230df8d8603d2194775aaebac3b9754c6a91f", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23f2d0170d16eb9224ff19e52312ada7fe3e8e85/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23f2d0170d16eb9224ff19e52312ada7fe3e8e85/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=23f2d0170d16eb9224ff19e52312ada7fe3e8e85", "patch": "@@ -2579,6 +2579,7 @@ void gfc_global_used (gfc_gsymbol *, locus *);\n \n /* dependency.c */\n int gfc_dep_compare_expr (gfc_expr *, gfc_expr *);\n+int gfc_is_data_pointer (gfc_expr *);\n \n /* check.c */\n gfc_try gfc_check_same_strlen (const gfc_expr*, const gfc_expr*, const char*);"}, {"sha": "27a4d997b7a9b241b7e426a681cbfc0df6188167", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 5, "deletions": 36, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23f2d0170d16eb9224ff19e52312ada7fe3e8e85/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23f2d0170d16eb9224ff19e52312ada7fe3e8e85/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=23f2d0170d16eb9224ff19e52312ada7fe3e8e85", "patch": "@@ -2047,12 +2047,10 @@ gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   char binding_label[GFC_MAX_BINDING_LABEL_LEN + 1];\n-  int optional_arg = 0;\n+  int optional_arg = 0, is_pointer = 0;\n   gfc_try retval = SUCCESS;\n   gfc_symbol *args_sym;\n   gfc_typespec *arg_ts;\n-  gfc_ref *parent_ref;\n-  gfc_ref *curr_ref;\n \n   if (args->expr->expr_type == EXPR_CONSTANT\n       || args->expr->expr_type == EXPR_OP\n@@ -2070,32 +2068,8 @@ gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n      the actual expression could be a part-ref of the expr symbol.  */\n   arg_ts = &(args->expr->ts);\n \n-  /* Get the parent reference (if any) for the expression.  This happens for\n-     cases such as a%b%c.  */\n-  parent_ref = args->expr->ref;\n-  curr_ref = NULL;\n-  if (parent_ref != NULL)\n-    {\n-      curr_ref = parent_ref->next;\n-      while (curr_ref != NULL && curr_ref->next != NULL)\n-        {\n-\t  parent_ref = curr_ref;\n-\t  curr_ref = curr_ref->next;\n-\t}\n-    }\n-\n-  /* If curr_ref is non-NULL, we had a part-ref expression.  If the curr_ref\n-     is for a REF_COMPONENT, then we need to use it as the parent_ref for\n-     the name, etc.  Otherwise, the current parent_ref should be correct.  */\n-  if (curr_ref != NULL && curr_ref->type == REF_COMPONENT)\n-    parent_ref = curr_ref;\n-\n-  if (parent_ref == args->expr->ref)\n-    parent_ref = NULL;\n-  else if (parent_ref != NULL && parent_ref->type != REF_COMPONENT)\n-    gfc_internal_error (\"Unexpected expression reference type in \"\n-\t\t\t\"gfc_iso_c_func_interface\");\n-\n+  is_pointer = gfc_is_data_pointer (args->expr);\n+    \n   if (sym->intmod_sym_id == ISOCBINDING_ASSOCIATED)\n     {\n       /* If the user gave two args then they are providing something for\n@@ -2137,10 +2111,7 @@ gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n       else if (sym->intmod_sym_id == ISOCBINDING_LOC)\n         {\n           /* Make sure we have either the target or pointer attribute.  */\n-\t  if (!(args_sym->attr.target)\n-\t      && !(args_sym->attr.pointer)\n-\t      && (parent_ref == NULL ||\n-\t\t  !parent_ref->u.c.component->attr.pointer))\n+\t  if (!args_sym->attr.target && !is_pointer)\n             {\n               gfc_error_now (\"Parameter '%s' to '%s' at %L must be either \"\n                              \"a TARGET or an associated pointer\",\n@@ -2223,9 +2194,7 @@ gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n \t\t\t  }\n                     }\n                 }\n-              else if ((args_sym->attr.pointer == 1 ||\n-\t\t\t(parent_ref != NULL \n-\t\t\t && parent_ref->u.c.component->attr.pointer))\n+              else if (is_pointer\n \t\t       && is_scalar_expr_ptr (args->expr) != SUCCESS)\n                 {\n                   /* Case 1c, section 15.1.2.5, J3/04-007: an associated"}, {"sha": "a1d4eb00161bb3089780dadd06706c7f43987cd1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23f2d0170d16eb9224ff19e52312ada7fe3e8e85/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23f2d0170d16eb9224ff19e52312ada7fe3e8e85/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=23f2d0170d16eb9224ff19e52312ada7fe3e8e85", "patch": "@@ -1,3 +1,9 @@\n+2009-01-04  Mikael Morin  <mikael.morin@tele2.fr>\n+\n+\tPR fortran/38536\n+\t* gfortran.dg/c_loc_tests_13.f90: New test.\n+\t* gfortran.dg/c_loc_tests_14.f90: New test.\n+\n 2009-01-03  Daniel Franke  <franke.daniel@gmail.com>\n \n \t* gfortran.dg/func_result_4.f90: New."}, {"sha": "62bfe0a3caa8be3fe2c3320731b119001e507c72", "filename": "gcc/testsuite/gfortran.dg/c_loc_tests_13.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23f2d0170d16eb9224ff19e52312ada7fe3e8e85/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23f2d0170d16eb9224ff19e52312ada7fe3e8e85/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_13.f90?ref=23f2d0170d16eb9224ff19e52312ada7fe3e8e85", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do compile }\n+!\n+! PR fortran/38536  \n+! Consecutive array and substring references rejected as C_LOC argument\n+!\n+! contributed by Scot Breitenfield <brtnfld@hdfgroup.org>\n+\n+  USE ISO_C_BINDING\n+  TYPE test\n+     CHARACTER(LEN=2), DIMENSION(1:2) :: c\n+  END TYPE test\n+  TYPE(test), TARGET :: chrScalar\n+  TYPE(C_PTR) :: f_ptr\n+\n+  f_ptr = C_LOC(chrScalar%c(1)(1:1))\n+  END"}, {"sha": "ec455eca924beb589148a1b5892e57b6c30e8cda", "filename": "gcc/testsuite/gfortran.dg/c_loc_tests_14.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23f2d0170d16eb9224ff19e52312ada7fe3e8e85/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_14.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23f2d0170d16eb9224ff19e52312ada7fe3e8e85/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_14.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_14.f90?ref=23f2d0170d16eb9224ff19e52312ada7fe3e8e85", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do compile }\n+!\n+! PR fortran/38536\n+! Accept as argument to C_LOC a subcomponent accessed through a pointer.\n+\n+  USE ISO_C_BINDING\n+\n+  IMPLICIT NONE\n+  TYPE test3\n+          INTEGER, DIMENSION(5) :: b\n+  END TYPE test3\n+\n+  TYPE test2\n+          TYPE(test3), DIMENSION(:), POINTER :: a\n+  END TYPE test2\n+\n+  TYPE test\n+          TYPE(test2), DIMENSION(2) :: c\n+  END TYPE test\n+\n+  TYPE(test) :: chrScalar\n+  TYPE(C_PTR) :: f_ptr\n+  TYPE(test3), TARGET :: d(3)\n+\n+\n+  chrScalar%c(1)%a => d\n+  f_ptr = C_LOC(chrScalar%c(1)%a(1)%b(1))\n+  end\n+"}]}