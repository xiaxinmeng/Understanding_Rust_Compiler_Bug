{"sha": "b3db7ef158c0e7b8bde40aa4c962d16d255c3ffd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNkYjdlZjE1OGMwZTdiOGJkZTQwYWE0Yzk2MmQxNmQyNTVjM2ZmZA==", "commit": {"author": {"name": "Sascha Brawer", "email": "brawer@dandelis.ch", "date": "2004-01-07T14:42:04Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-01-07T14:42:04Z"}, "message": "DefaultBoundedRangeModel.java: Documented API.\n\n2004-01-07  Sascha Brawer  <brawer@dandelis.ch>\n\n\t* javax/swing/DefaultBoundedRangeModel.java: Documented API.\n\t(changeEvent): Create event object on demand.\n\t(DefaultBoundedRangeModel, toString, setValue, setExtent,\n\tsetMinimum, setMaximum, setValueIsAdjusting, setRangeProperties,\n\tfireStateChanged): Re-written.\n\t* javax/swing/event/EventListenerList.java: Reformatted, document\n\ttypical usage.\n\t(toString): Implemented.\n\t(getListeners): Re-written.\n\t(remove): Re-written.\n\t(add): Re-written.\n\t(NO_LISTENERS): New singleton field.\n\t(listenerList): Declare as transient; document.\n\t(serialVersionUID): Document.\n\t(getListenerCount(Class)): More efficient implementation,\n\talso accepts null argument.  Improve Javadoc.\n\t(getListenerCount()): Remove unnecessary cast; docfix.\n\t* javax/swing/undo/UndoableEditSupport.java:\n\tRe-format, document.\n\t(UndoableEditSupport): Set realSource field. Improve documentation.\n\t(_postEdit): Iterate over cloned listener vector.\n\t(toString): Don't emit realSource.\n\t(beginUpdate, endUpdate): Support nested updates.\n\t(postEdit): Use compound edit if present.\n\nFrom-SVN: r75505", "tree": {"sha": "c031ffd0a3d166fbfd7642e5bd4082ad4a86b79c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c031ffd0a3d166fbfd7642e5bd4082ad4a86b79c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3db7ef158c0e7b8bde40aa4c962d16d255c3ffd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3db7ef158c0e7b8bde40aa4c962d16d255c3ffd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3db7ef158c0e7b8bde40aa4c962d16d255c3ffd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3db7ef158c0e7b8bde40aa4c962d16d255c3ffd/comments", "author": null, "committer": null, "parents": [{"sha": "b48a0c1869fe5fe1508efa31f80dd11f0d3fdef0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b48a0c1869fe5fe1508efa31f80dd11f0d3fdef0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b48a0c1869fe5fe1508efa31f80dd11f0d3fdef0"}], "stats": {"total": 1100, "additions": 682, "deletions": 418}, "files": [{"sha": "ef0504857c37b75fe1468317fd3acf9c8480ebfc", "filename": "libjava/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3db7ef158c0e7b8bde40aa4c962d16d255c3ffd/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3db7ef158c0e7b8bde40aa4c962d16d255c3ffd/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=b3db7ef158c0e7b8bde40aa4c962d16d255c3ffd", "patch": "@@ -1,3 +1,30 @@\n+2004-01-07  Sascha Brawer  <brawer@dandelis.ch>\n+\n+\t* javax/swing/DefaultBoundedRangeModel.java: Documented API.\n+\t(changeEvent): Create event object on demand.\n+\t(DefaultBoundedRangeModel, toString, setValue, setExtent,\n+\tsetMinimum, setMaximum, setValueIsAdjusting, setRangeProperties,\n+\tfireStateChanged): Re-written.\n+\t* javax/swing/event/EventListenerList.java: Reformatted, document\n+\ttypical usage.\n+\t(toString): Implemented.\n+\t(getListeners): Re-written.\n+\t(remove): Re-written.\n+\t(add): Re-written.\n+\t(NO_LISTENERS): New singleton field.\n+\t(listenerList): Declare as transient; document.\n+\t(serialVersionUID): Document.\n+\t(getListenerCount(Class)): More efficient implementation,\n+\talso accepts null argument.  Improve Javadoc.\n+\t(getListenerCount()): Remove unnecessary cast; docfix.\n+\t* javax/swing/undo/UndoableEditSupport.java:\n+\tRe-format, document.\n+\t(UndoableEditSupport): Set realSource field. Improve documentation.\n+\t(_postEdit): Iterate over cloned listener vector.\n+\t(toString): Don't emit realSource.\n+\t(beginUpdate, endUpdate): Support nested updates.\n+\t(postEdit): Use compound edit if present.\n+\n 2004-01-06  Graydon Hoare  <graydon@redhat.com>\n \n \t* java/awt/Container.java (swapComponents): Add forgotten"}, {"sha": "8ca178dd55185be1b77832f574ca272eb6cc0007", "filename": "libjava/javax/swing/DefaultBoundedRangeModel.java", "status": "modified", "additions": 277, "deletions": 157, "changes": 434, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3db7ef158c0e7b8bde40aa4c962d16d255c3ffd/libjava%2Fjavax%2Fswing%2FDefaultBoundedRangeModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3db7ef158c0e7b8bde40aa4c962d16d255c3ffd/libjava%2Fjavax%2Fswing%2FDefaultBoundedRangeModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FDefaultBoundedRangeModel.java?ref=b3db7ef158c0e7b8bde40aa4c962d16d255c3ffd", "patch": "@@ -1,5 +1,6 @@\n-/* DefaultBoundedRangeModel.java --\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+/* DefaultBoundedRangeModel.java -- Default implementation\n+   of BoundedRangeModel.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -43,306 +44,425 @@\n import javax.swing.event.ChangeListener;\n import javax.swing.event.EventListenerList;\n \n+\n /**\n- * DefaultBoundedRangeModel\n- * @author\tAndrew Selkirk\n- * @version\t1.0\n+ * A default implementation of BoundedRangeModel.\n+ *\n+ * @author <a href=\"mailto:aselkirk@sympatico.ca\">Andrew Selkirk</a>\n+ * @author <a href=\"mailto:brawer@dandelis.ch\">Sascha Brawer</a>\n  */\n public class DefaultBoundedRangeModel\n   implements BoundedRangeModel, Serializable\n {\n+  /**\n+   * The identifier of this class in object serialization. Verified\n+   * using the serialver tool of Sun J2SE 1.4.1_01.\n+   */\n   static final long serialVersionUID = 5034068491295259790L;\n \n+\n   /**\n-   * changeEvent\n+   * An event that is sent to all registered {@link ChangeListener}s\n+   * when the state of this range model has changed.\n+   *\n+   * <p>The event object is created on demand, the first time it\n+   * is actually needed.\n+   *\n+   * @see #fireStateChanged()\n    */\n-  protected transient ChangeEvent changeEvent = new ChangeEvent (this);\n+  protected transient ChangeEvent changeEvent;\n+\n \n   /**\n-   * listenerList\n+   * The list of the currently registered EventListeners.\n    */\n-  protected EventListenerList listenerList = new EventListenerList ();\n+  protected EventListenerList listenerList = new EventListenerList();\n+\n \n   /**\n-   * value\n+   * The current value of the range model, which is always between\n+   * {@link #minimum} and ({@link #maximum} - {@link #extent}). In a\n+   * scroll bar visualization of a {@link BoundedRangeModel}, the\n+   * <code>value</code> is displayed as the position of the thumb.\n    */\n   private int value;\n \n+\n   /**\n-   * extent\n+   * The current extent of the range model, which is a number greater\n+   * than or equal to zero. In a scroll bar visualization of a {@link\n+   * BoundedRangeModel}, the <code>extent</code> is displayed as the\n+   * size of the thumb.\n    */\n   private int extent;\n \n+\n   /**\n-   * minimum\n+   * The current minimum value of the range model, which is always\n+   * less than or equal to {@link #maximum}.\n    */\n   private int minimum;\n \n+\n   /**\n-   * maximum\n+   * The current maximum value of the range model, which is always\n+   * greater than or equal to {@link #minimum}.\n    */\n   private int maximum;\n \n+\n   /**\n-   * isAdjusting\n+   * A property that indicates whether the value of this {@link\n+   * BoundedRangeModel} is going to change in the immediate future.\n    */\n   private boolean isAdjusting;\n \n+\n   /**\n-   * Constructor DefaultBoundedRangeModel\n+   * Constructs a <code>DefaultBoundedRangeModel</code> with default\n+   * values for the properties. The properties <code>value</code>,\n+   * <code>extent</code> and <code>minimum</code> will be initialized\n+   * to zero; <code>maximum</code> will be set to 100; the property\n+   * <code>valueIsAdjusting</code> will be <code>false</code>.\n    */\n-  public DefaultBoundedRangeModel ()\n+  public DefaultBoundedRangeModel()\n   {\n-    setRangeProperties (0, 0, 0, 100, false);\n+    // The fields value, extent, minimum have the default value 0, and\n+    // isAdjusting is already false. These fields no not need to be\n+    // set explicitly.\n+    maximum = 100;\n   }\n \n+\n   /**\n-   * Constructor DefaultBoundedRangeModel\n-   * @param value TODO\n-   * @param extent TODO\n-   * @param minimum TODO\n-   * @param maximum TODO\n+   * Constructs a <code>DefaultBoundedRangeModel</code> with the\n+   * specified values for some properties.\n+   *\n+   * @param value the initial value of the range model, which must be\n+   * a number between <code>minimum</code> and <code>(maximum -\n+   * extent)</code>. In a scroll bar visualization of a {@link\n+   * BoundedRangeModel}, the <code>value</code> is displayed as the\n+   * position of the thumb.\n+   *\n+   * @param extent the initial extent of the range model, which is a\n+   * number greater than or equal to zero. In a scroll bar\n+   * visualization of a {@link BoundedRangeModel}, the\n+   * <code>extent</code> is displayed as the size of the thumb.\n+   *\n+   * @param minimum the initial minimal value of the range model.\n+   *\n+   * @param maximum the initial maximal value of the range model.\n+   *\n+   * @throws IllegalArgumentException if the following condition is\n+   * not satisfied: <code>minimum <= value <= value + extent <=\n+   * maximum</code>.\n    */\n-  public DefaultBoundedRangeModel (int value, int extent, int minimum,\n+  public DefaultBoundedRangeModel(int value, int extent, int minimum,\n                                   int maximum)\n   {\n-    setRangeProperties(value, extent, minimum, maximum, false);\n+    if (!(minimum <= value && extent >= 0 && (value + extent) <= maximum))\n+      throw new IllegalArgumentException();\n+\n+    this.value = value;\n+    this.extent = extent;\n+    this.minimum = minimum;\n+    this.maximum = maximum;\n+\n+    // The isAdjusting field already has a false value by default.\n   }\n \n+\n   /**\n-   * toString\n-   * @returns String\n+   * Returns a string with all relevant properties of this range\n+   * model.\n    */\n-  public String toString ()\n+  public String toString()\n   {\n-    return null; // TODO\n+    return getClass().getName()\n+      + \"[value=\" + value\n+      + \", extent=\" + extent\n+      + \", min=\" + minimum\n+      + \", max=\" + maximum\n+      + \", adj=\" + isAdjusting\n+      + ']';\n   }\n \n+\n   /**\n-   * getValue\n-   * @returns int\n+   * Returns the current value of this bounded range model.  In a\n+   * scroll bar visualization of a {@link BoundedRangeModel}, the\n+   * <code>value</code> is displayed as the position of the thumb.\n    */\n-  public int getValue ()\n+  public int getValue()\n   {\n     return value;\n   }\n \n+\n   /**\n-   * setValue\n-   * @param value TODO\n+   * Changes the current value of this bounded range model. In a\n+   * scroll bar visualization of a {@link BoundedRangeModel}, the\n+   * <code>value</code> is displayed as the position of the thumb;\n+   * changing the <code>value</code> of a scroll bar&#x2019;s model\n+   * thus moves the thumb to a different position.\n    */\n-  public void setValue (int value)\n+  public void setValue(int value)\n   {\n-    // Validate Constraints\n-    if (minimum > value ||\n-        value > (value + extent) ||\n-        (value + extent) > maximum)\n+    value = Math.max(minimum, value);\n+    if (value + extent > maximum)\n+      value = maximum - extent;\n+\n+    if (value != this.value)\n       {\n-        throw new IllegalArgumentException (\"Invalid value property set\");\n+        this.value = value;\n+        fireStateChanged();\n       }\n-\t\t\n-    // Set Value\n-    this.value = value;\n-\n-    // Notification\n-    fireStateChanged ();\n   }\n \n+\n   /**\n-   * getExtent\n-   * @returns int\n+   * Returns the current extent of this bounded range model, which is\n+   * a number greater than or equal to zero. In a scroll bar\n+   * visualization of a {@link BoundedRangeModel}, the\n+   * <code>extent</code> is displayed as the size of the thumb.\n    */\n-  public int getExtent ()\n+  public int getExtent()\n   {\n     return extent;\n   }\n \n+\n   /**\n-   * setExtent\n-   * @param extent TODO\n+   * Changes the current extent of this bounded range model. In a\n+   * scroll bar visualization of a {@link BoundedRangeModel}, the\n+   * <code>extent</code> is displayed as the size of the thumb.\n+   *\n+   * @param extent the new extent of the range model, which is a\n+   * number greater than or equal to zero.\n    */\n-  public void setExtent (int extent)\n+  public void setExtent(int extent)\n   {\n-    // Validate Constraints\n-    if (minimum > value ||\n-        value > (value + extent) ||\n-        (value + extent) > maximum)\n+    extent = Math.max(extent, 0);\n+    if (value + extent > maximum)\n+      extent = maximum - value;\n+\n+    if (extent != this.extent)\n       {\n-        throw new IllegalArgumentException(\"Invalid extent property set\");\n+        this.extent = extent;\n+        fireStateChanged();\n       }\n-\n-    // Set Extent\n-    this.extent = extent;\n-\t\t\n-    // Notification\n-    fireStateChanged ();\n   }\n \n+\n   /**\n-   * getMinimum\n-   * @returns int\n+   * Returns the current minimal value of this bounded range model.\n    */\n-  public int getMinimum ()\n+  public int getMinimum()\n   {\n     return minimum;\n   }\n \n+\n   /**\n-   * setMinimum\n-   * @param minimum TODO\n+   * Changes the current minimal value of this bounded range model.\n+   *\n+   * @param minimum the new minimal value.\n    */\n-  public void setMinimum (int minimum)\n+  public void setMinimum(int minimum)\n   {\n-    // Validate Constraints\n-    if (minimum > value ||\n-        value > (value + extent) ||\n-        (value + extent) > maximum)\n-      {\n-        throw new IllegalArgumentException(\"Invalid minimum property set\");\n-      }\n-\t\t\n-    // Set Minimum\n-    this.minimum = minimum;\n-\t\t\n-    // Notification\n-    fireStateChanged ();\n+    int value, maximum;\n+\n+    maximum = Math.max(minimum, this.maximum);\n+    value = Math.max(minimum, this.value);\n+\n+    setRangeProperties(value, extent, minimum, maximum, isAdjusting);\n   }\n \n+\n   /**\n-   * getMaximum\n-   * @returns int\n+   * Returns the current maximal value of this bounded range model.\n    */\n-  public int getMaximum() {\n-\t\treturn maximum;\n+  public int getMaximum()\n+  {\n+    return maximum;\n   }\n \n+\n   /**\n-   * setMaximum\n-   * @param maximum TODO\n+   * Changes the current maximal value of this bounded range model.\n+   *\n+   * @param maximum the new maximal value.\n    */\n-  public void setMaximum (int maximum)\n+  public void setMaximum(int maximum)\n   {\n-    // Validate Constraints\n-    if (minimum > value ||\n-        value > (value + extent) ||\n-        (value + extent) > maximum)\n-      {\n-        throw new IllegalArgumentException (\"Invalid maximum property set\");\n-      }\n+    int value, extent, minimum;\n \n-    // Set Maximum\n-    this.maximum = maximum;\n+    minimum = Math.min(this.minimum, maximum);\n+    extent = Math.min(this.extent, maximum - minimum);\n+    value = Math.min(this.value, maximum - extent);\n \n-    // Notification\n-    fireStateChanged ();\n+    setRangeProperties(value, extent, minimum, maximum, isAdjusting);\n   }\n \n+\n   /**\n-   * getValueIsAdjusting\n-   * @returns boolean\n+   * Returns whether or not the value of this bounded range model is\n+   * going to change in the immediate future. Scroll bars set this\n+   * property to <code>true</code> while the thumb is being dragged\n+   * around; when the mouse is relased, they set the property to\n+   * <code>false</code> and post a final {@link ChangeEvent}.\n+   *\n+   * @returns <code>true</code> if the value will change soon again;\n+   * <code>false</code> if the value will probably not change soon.\n    */\n-  public boolean getValueIsAdjusting ()\n+  public boolean getValueIsAdjusting()\n   {\n     return isAdjusting;\n   }\n \n+\n   /**\n-   * setValueIsAdjusting\n-   * @param isAdjusting TODO\n+   * Specifies whether or not the value of this bounded range model is\n+   * going to change in the immediate future. Scroll bars set this\n+   * property to <code>true</code> while the thumb is being dragged\n+   * around; when the mouse is relased, they set the property to\n+   * <code>false</code>.\n+   *\n+   * @param isAdjusting <code>true</code> if the value will change\n+   * soon again; <code>false</code> if the value will probably not\n+   * change soon.\n    */\n-  public void setValueIsAdjusting (boolean isAdjusting)\n+  public void setValueIsAdjusting(boolean isAdjusting)\n   {\n-    // Set isAdjusting\n-    this.isAdjusting = isAdjusting;\n+    if (isAdjusting == this.isAdjusting)\n+      return;\n \n-    // Notification\n+    this.isAdjusting = isAdjusting;\n     fireStateChanged();\n   }\n \n+\n   /**\n    * setRangeProperties\n-   * @param value TODO\n-   * @param extent TODO\n-   * @param minimum TODO\n-   * @param maximum TODO\n-   * @param isAdjusting TODO\n+   *\n+   * @param value the new value of the range model.  In a scroll bar\n+   * visualization of a {@link BoundedRangeModel}, the\n+   * <code>value</code> is displayed as the position of the thumb.\n+   *\n+   * @param extent the new extent of the range model, which is a\n+   * number greater than or equal to zero. In a scroll bar\n+   * visualization of a {@link BoundedRangeModel}, the\n+   * <code>extent</code> is displayed as the size of the thumb.\n+   *\n+   * @param minimum the new minimal value of the range model.\n+   *\n+   * @param maximum the new maximal value of the range model.\n+\n+   * @param isAdjusting whether or not the value of this bounded range\n+   * model is going to change in the immediate future. Scroll bars set\n+   * this property to <code>true</code> while the thumb is being\n+   * dragged around; when the mouse is relased, they set the property\n+   * to <code>false</code>.\n    */\n-  public void setRangeProperties (int value, int extent, int minimum,\n-                                  int maximum, boolean isAdjusting)\n+  public void setRangeProperties(int value, int extent, int minimum,\n+                                 int maximum, boolean isAdjusting)\n   {\n-    // Validate Constraints\n-    if (minimum > value ||\n-        value > (value + extent) ||\n-        (value + extent) > maximum)\n-      {\n-        throw new IllegalArgumentException (\"Invalid property set\");\n-      }\n+    minimum = Math.min(Math.min(minimum, maximum), value);\n+    maximum = Math.max(value, maximum);\n+    if (extent + value > maximum)\n+      extent = maximum - value;\n+    extent = Math.max(0, extent);\n+\n+    if ((value == this.value)\n+        && (extent == this.extent)\n+        && (minimum == this.minimum)\n+        && (maximum == this.maximum)\n+        && (isAdjusting == this.isAdjusting))\n+      return;\n \n-    // Set Data\n     this.value = value;\n     this.extent = extent;\n     this.minimum = minimum;\n     this.maximum = maximum;\n     this.isAdjusting = isAdjusting;\n \t\t\n-    // Notification\n-    fireStateChanged ();\n+    fireStateChanged();\n   }\n \n+\n   /**\n-   * addChangeListener\n-   * @param listener TODO\n+   * Subscribes a ChangeListener to state changes.\n+   *\n+   * @param listener the listener to be subscribed.\n    */\n-  public void addChangeListener (ChangeListener listener)\n+  public void addChangeListener(ChangeListener listener)\n   {\n-    listenerList.add (ChangeListener.class, listener);\n+    listenerList.add(ChangeListener.class, listener);\n   }\n \n+\n   /**\n-   * removeChangeListener\n-   * @param listener TODO\n+   * Cancels the subscription of a ChangeListener.\n+   *\n+   * @param listener the listener to be unsubscribed.\n    */\n-  public void removeChangeListener (ChangeListener listener)\n+  public void removeChangeListener(ChangeListener listener)\n   {\n-    listenerList.remove (ChangeListener.class, listener);\n+    listenerList.remove(ChangeListener.class, listener);\n   }\n \n+\n   /**\n-   * fireStateChanged\n+   * Sends a {@link ChangeEvent} to any registered {@link\n+   * ChangeListener}s.\n+   *\n+   * @see #addChangeListener(ChangeListener)\n+   * @see #removeChangeListener(ChangeListener)\n    */\n-  protected void fireStateChanged ()\n+  protected void fireStateChanged()\n   {\n-    // Variables\n-    ChangeListener listener;\n-    ChangeListener[] listeners;\n-    int index;\n-\n-    // Get Listeners\n-    listeners = getChangeListeners ();\n-\n-    // Process Listeners\n-    for (index = 0; index < listeners.length; index++)\n-    {\n-      listener = listeners [index];\n-      listener.stateChanged (changeEvent);\n-    }\n+    Object[] listeners;\n+\n+    listeners = listenerList.getListenerList();\n+    for (int i = listeners.length - 2; i >= 0; i -= 2)\n+      if (listeners[i] == ChangeListener.class)\n+        {\n+          if (changeEvent == null)\n+            changeEvent = new ChangeEvent(this);\n+          ((ChangeListener) listeners[i + 1]).stateChanged(changeEvent);\n+        }\n   }\n \n+\n   /**\n-   * getListeners\n-   * @param c TODO\n-   * @returns EventListener[]\n+   * Retrieves the current listeners of the specified class.\n+   *\n+   * @param c the class of listeners; usually {@link\n+   * ChangeListener}<code>.class</code>.\n+   *\n+   * @return an array with the currently subscribed listeners, or\n+   * an empty array if there are currently no listeners.\n+   *\n+   * @since 1.3\n    */\n-  public EventListener[] getListeners (Class listenerType)\n+  public EventListener[] getListeners(Class listenerType)\n   {\n-    return listenerList.getListeners (listenerType);\n+    return listenerList.getListeners(listenerType);\n   }\n \n+\n   /**\n-   * getChangeListeners\n+   * Returns all <code>ChangeListeners</code> that are currently\n+   * subscribed for changes to this\n+   * <code>DefaultBoundedRangeModel</code>.\n+   *\n+   * @return an array with the currently subscribed listeners, or\n+   * an empty array if there are currently no listeners.\n+   *\n+   * @since 1.4\n    */\n-  public ChangeListener[] getChangeListeners ()\n+  public ChangeListener[] getChangeListeners()\n   {\n-    return (ChangeListener[]) getListeners (ChangeListener.class);\n+    return (ChangeListener[]) getListeners(ChangeListener.class);\n   }\n }"}, {"sha": "e7294afcef4ae4de0cba7e6c8db705572adff0d4", "filename": "libjava/javax/swing/event/EventListenerList.java", "status": "modified", "additions": 256, "deletions": 196, "changes": 452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3db7ef158c0e7b8bde40aa4c962d16d255c3ffd/libjava%2Fjavax%2Fswing%2Fevent%2FEventListenerList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3db7ef158c0e7b8bde40aa4c962d16d255c3ffd/libjava%2Fjavax%2Fswing%2Fevent%2FEventListenerList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fevent%2FEventListenerList.java?ref=b3db7ef158c0e7b8bde40aa4c962d16d255c3ffd", "patch": "@@ -1,5 +1,5 @@\n /* EventListenerList.java --\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,206 +37,266 @@\n \n package javax.swing.event;\n \n-// Imports\n import java.io.Serializable;\n+import java.lang.reflect.Array;\n import java.util.EventListener;\n \n+\n /**\n- * EventListenerList\n- * @author Andrew Selkirk\n+ * A utility class for keeping track of {@link EventListener}s.\n+ *\n+ * <p><b>Example for using this class:</b>\n+ *\n+ * <blockquote><pre> import java.util.EventListener;\n+ * import javax.swing.event.EventListenerList;\n+ *\n+ * class Foo\n+ * {\n+ *   protected final EventListenerList listeners = new EventListenerList();\n+ *   protected BarClosedEvent barClosedEvent = null;\n+ *\n+ *   public void addBarListener(BarListener l)\n+ *   {\n+ *     listeners.<a href=\"#add(java.lang.Class, java.util.EventListener)\"\n+ *               >add</a>(BarListener.class, l);\n+ *   }\n+ *\n+ *   public void removeBarListener(BarListener l)\n+ *   {\n+ *     listeners.<a href=\"#remove(java.lang.Class, java.util.EventListener)\"\n+ *               >remove</a>(BarListener.class, l);\n+ *   }\n+ *\n+ *   protected void fireBarClosedEvent()\n+ *   {\n+ *     Object[] l = listeners.<a href=\"#getListenerList()\"\n+ *                            >getListenerList()</a>;\n+ *\n+ *     for (int i = l.length - 2; i >= 0; i -= 2)\n+ *       if (l[i] == BarListener.class)\n+ *         {\n+ *           // Create the event on demand, when it is needed the first time.\n+ *           if (barClosedEvent == null)\n+ *             barClosedEvent = new BarClosedEvent(this);\n+ *\n+ *           ((BarClosedListener) l[i + 1]).barClosed(barClosedEvent);\n+ *         }\n+ *   }\n+ * }</pre></blockquote>\n+ *\n+ * @author <a href=\"mailto:aselkirk@sympatico.ca\">Andrew Selkirk</a>\n+ * @author <a href=\"mailto:brawer@dandelis.ch\">Sascha Brawer</a>\n  */\n-public class EventListenerList extends Object implements Serializable\n+public class EventListenerList\n+  implements Serializable\n {\n+  /**\n+   * An ID for serializing instances of this class; verified with the\n+   * serialver tool of Sun J2SE 1.4.1_01.\n+   */\n   static final long serialVersionUID = -5677132037850737084L;\n \n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\t\n-\t/**\n-\t * Listener list\n-\t */\n-\tprotected\tObject[]\tlistenerList\t= null;\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\t\n-\t/**\n-\t * EventListenerList constructor\n-\t */\n-\tpublic EventListenerList() {\n-\t\tlistenerList = new Object[0];\n-\t} // EventListenerList()\n-\n-\t\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Add Listener\n-\t * @param t Class type\n-\t * @param listener Listener to add\n-\t */\n-\tpublic void add(Class t, EventListener listener) {\n-\n-\t\t// Variables\n-\t\tObject[]\t\tlist;\n-\t\tint\t\t\t\tindex;\n-\t\tClass\t\t\tcheckClass;\n-\t\tEventListener\tcheckListener;\n-\n-\t\t// Create New list in anticipation that listener is not present\n-\t\tlist = new Object[listenerList.length + 2];\n-\n-\t\t// Search through list looking for listener\n-\t\tfor (index = 0; index < listenerList.length; index += 2) {\n-\t\t\tcheckClass = (Class) listenerList[index];\n-\t\t\tcheckListener = (EventListener) listenerList[index + 1];\n-\t\t\tif (checkClass.equals(t) == true &&\n-\t\t\t\tcheckListener.equals(listener) == true) {\n-\t\t\t\treturn;\n-\t\t\t} // if\n-\t\t} // for\n-\n-\t\t// Add Listener\n-\t\tlist[listenerList.length] = t;\n-\t\tlist[listenerList.length + 1] = listener;\n-\n-\t\t// Replace Listener List\n-\t\tlistenerList = list;\n-\n-\t} // add()\n-\n-\t/**\n-\t * Get the total number of listeners\n-\t * @return Count of listeners\n-\t */\n-\tpublic int getListenerCount() {\n-\t\treturn (int) listenerList.length / 2;\n-\t} // getListenerCount\n-\n-\t/**\n-\t * Get the number of listeners of a particular type\n-\t * @param t Class type to count\n-\t * @returns Count of the specified listeners\n-\t */\n-\tpublic int getListenerCount(Class t) {\n-\n-\t\t// Variables\n-\t\tint\t\tindex;\n-\t\tint\t\tcount;\n-\t\tString\tname;\n-\n-\t\t// Loop through entire list\n-\t\tcount = 0;\n-\t\tname  = t.getName();\n-\t\tfor (index = 0; index < listenerList.length; index += 2) {\n-\t\t\tif (((Class) listenerList[index]).getName().equals(name) == true) {\n-\t\t\t\tcount += 1;\n-\t\t\t}\n-\t\t} // for: index\n-\n-\t\t// Return Count\n-\t\treturn count;\n-\n-\t} // getListenerCount()\n-\n-\t/**\n-\t * Get a list of listenerType/listener pairs\n-\t * @returns Listener list\n-\t */\n-\tpublic Object[] getListenerList() {\n-\t\treturn listenerList;\n-\t} // getListenerList()\n-\n-\t/**\n-\t * Get list of listeners of a particular type\n-\t * @param c Class type\n-\t * @returns List of listeners of the specified type\n-\t */\n-\tpublic EventListener[] getListeners(Class c) {\n-\n-\t\t// Variables\n-\t\tint\t\t\t\t\tcount;\n-\t\tEventListener[]\t\tlist;\n-\t\tString\t\t\t\tname;\n-\t\tint\t\t\t\t\tindex;\n-\n-\t\t// Get count of listeners\n-\t\tcount = getListenerCount(c);\n-\n-\t\t// Create Event Listener list\n-\t\tlist = new EventListener[count];\n-\n-\t\t// Construct List\n-\t\tcount = 0;\n-\t\tname  = c.getName();\n-\t\tfor (index = 0; index < listenerList.length; index += 2) {\n-\t\t\tif (((Class) listenerList[index]).getName().equals(name) == true) {\n-\t\t\t\tlist[count] = (EventListener) listenerList[index];\n-\t\t\t\tcount += 1;\n-\t\t\t} // if\n-\t\t} // for: index\n-\n-\t\t// Return List\n-\t\treturn list;\n-\n-\t} // getListeners()\n-\n-\t/**\n-\t * Remove a listener\n-\t * @param t Class type\n-\t * @param listener Listener to be removed\n-\t */\n-\tpublic void remove(Class t, EventListener listener) {\n-\n-\t\t// Variables\n-\t\tObject[]\t\tlist;\n-\t\tint\t\t\t\tindex;\n-\t\tClass\t\t\tcheckClass;\n-\t\tEventListener\tcheckListener;\n-\t\tint\t\t\t\tpointer;\n-\t\tboolean\t\t\tfound;\n-\n-\t\t// Create New list in anticipation that listener is not present\n-\t\tif (listenerList.length == 0) {\n-\t\t\treturn;\n-\t\t} // if\n-\t\tlist = new Object[listenerList.length - 2];\n-\n-\t\t// Search through list looking for listener\n-\t\tpointer = 0;\n-\t\tfound = false;\n-\t\tfor (index = 0; index < listenerList.length - 2; index += 2) {\n-\t\t\tcheckClass = (Class) listenerList[index];\n-\t\t\tcheckListener = (EventListener) listenerList[index + 1];\n-\t\t\tif (checkClass.equals(t) == false ||\n-\t\t\t\tcheckListener.equals(listener) == false) {\n-\t\t\t\tlist[pointer] = checkClass;\n-\t\t\t\tlist[pointer + 1] = checkListener;\n-\t\t\t\tpointer += 2;\n-\t\t\t} else {\n-\t\t\t\tfound = true;\n-\t\t\t} // if\n-\t\t} // for\n-\n-\t\t// Replace Listener List\n-\t\tif (found == true) {\n-\t\t\tlistenerList = list;\n-\t\t} // if\n-\n-\t} // remove()\n-\n-\t/**\n-\t * Get a string representation\n-\t * @returns String representation\n-\t */\n-\tpublic String toString() {\n-\t\treturn null; // TODO\n-\t} // toString()\n-\n-\n-} // EventListenerList\n+\n+  /**\n+   * An empty array that is shared by all instances of this class that\n+   * have no listeners.\n+   */\n+  private static final Object[] NO_LISTENERS = new Object[0];\n+  \n+  \n+  /**\n+   * An array with all currently registered listeners.  The array has\n+   * twice as many elements as there are listeners.  For an even\n+   * integer <code>i</code>, <code>listenerList[i]</code> indicates\n+   * the registered class, and <code>listenerList[i+1]</code> is the\n+   * listener.\n+   */\n+  protected transient Object[] listenerList = NO_LISTENERS;\n+\n+  \n+  /**\n+   * EventListenerList constructor\n+   */\n+  public EventListenerList()\n+  {\n+  }\n+\n+\n+  /**\n+   * Registers a listener of a specific type.\n+   *\n+   * @param t the type of the listener.\n+   *\n+   * @param listener the listener to add, which must be an instance of\n+   * <code>t</code>, or of a subclass of <code>t</code>.\n+   *\n+   * @throws IllegalArgumentException if <code>listener</code> is not\n+   * an instance of <code>t</code> (or a subclass thereof).\n+   *\n+   * @throws Exception if <code>t</code> is <code>null</code>.\n+   */\n+  public void add(Class t, EventListener listener)\n+  {\n+    int oldLength;\n+    Object[] newList;\n+\n+    if (listener == null)\n+      return;\n+\n+    if (!t.isInstance(listener))\n+      throw new IllegalArgumentException();\n+\n+    oldLength = listenerList.length;\n+    newList = new Object[oldLength + 2];\n+    if (oldLength > 0)\n+      System.arraycopy(listenerList, 0, newList, 0, oldLength);\n+\n+    newList[oldLength] = t;\n+    newList[oldLength + 1] = listener;\n+    listenerList = newList;\n+  }\n+\n+\n+  /**\n+   * Determines the number of listeners.\n+   */\n+  public int getListenerCount()\n+  {\n+    return listenerList.length / 2;\n+  }\n+\n+\n+  /**\n+   * Determines the number of listeners of a particular class.\n+   *\n+   * @param t the type of listeners to be counted. In order to get\n+   * counted, a subscribed listener must be exactly of class\n+   * <code>t</code>. Thus, subclasses of <code>t</code> will not be\n+   * counted.\n+   */\n+  public int getListenerCount(Class t)\n+  {\n+    int result = 0;\n+    for (int i = 0; i < listenerList.length; i += 2)\n+      if (t == listenerList[i])\n+        ++result;\n+\n+    return result;\n+  }\n+\n+\n+  /**\n+   * Get a list of listenerType/listener pairs\n+   * @returns Listener list\n+   */\n+  public Object[] getListenerList()\n+  {\n+    return listenerList;\n+  }\n+\n+\n+  /**\n+   * Retrieves the currently subscribed listeners of a particular\n+   * type.  For a listener to be returned, it must have been\n+   * registered with exactly the type <code>c</code>; subclasses are\n+   * not considered equal.\n+   *\n+   * <p>The returned array can always be cast to <code>c[]</code>.\n+   * Since it is a newly allocated copy, the caller may arbitrarily\n+   * modify the array.\n+   *\n+   * @param c the class which was passed to {@link #add}.\n+   *\n+   * @throws ClassCastException if <code>c</code> does not implement\n+   * the {@link EventListener} interface.\n+   *\n+   * @throws NullPointerException if <code>c</code> is\n+   * <code>null</code>.\n+   *\n+   * @returns an array of <code>c</code> whose elements are the\n+   * currently subscribed listeners of the specified type.  If there\n+   * are no such listeners, an empty array is returned.\n+   *\n+   * @since 1.3\n+   */\n+  public EventListener[] getListeners(Class c)\n+  {\n+    int count, f;\n+    EventListener[] result;\n+\n+    count = getListenerCount(c);\n+    result = (EventListener[]) Array.newInstance(c, count);\n+    f = 0;\n+    for (int i = 0; i < listenerList.length; i += 2)\n+      if (listenerList[i] == c)\n+        result[f++] = (EventListener) listenerList[i + 1];\n+    \n+    return result;\n+  }\n+\n+\n+  /**\n+   * Removes a listener of a specific type.\n+   *\n+   * @param t the type of the listener.\n+   *\n+   * @param listener the listener to remove, which must be an instance\n+   * of <code>t</code>, or of a subclass of <code>t</code>.\n+   *\n+   * @throws IllegalArgumentException if <code>listener</code> is not\n+   * an instance of <code>t</code> (or a subclass thereof).\n+   *\n+   * @throws Exception if <code>t</code> is <code>null</code>.\n+   */\n+  public void remove(Class t, EventListener listener)\n+  {\n+    Object[] oldList, newList;\n+    int oldLength;\n+\n+    if (listener == null)\n+      return;\n+\n+    if (!t.isInstance(listener))\n+      throw new IllegalArgumentException();\n+\n+    oldList = listenerList;\n+    oldLength = oldList.length;\n+    for (int i = 0; i < oldLength; i += 2)\n+      if (oldList[i] == t && oldList[i + 1] == listener)\n+        {\n+          if (oldLength == 2)\n+            newList = NO_LISTENERS;\n+          else\n+            {\n+              newList = new Object[oldLength - 2];\n+              if (i > 0)\n+                System.arraycopy(oldList, 0, newList, 0, i);\n+              if (i < oldLength - 2)\n+                System.arraycopy(oldList, i + 2, newList, i,\n+                                 oldLength - 2 - i);\n+            }\n+          listenerList = newList;\n+          return;\n+        }\n+  }\n+\n+\n+  /**\n+   * Returns a string representation of this object that may be useful\n+   * for debugging purposes.\n+   */\n+  public String toString()\n+  {\n+    StringBuffer buf = new StringBuffer(\"EventListenerList: \");\n+    buf.append(listenerList.length / 2);\n+    buf.append(\" listeners: \");\n+    for (int i = 0; i < listenerList.length; i += 2)\n+      {\n+        buf.append(\" type \");\n+        buf.append(((Class) listenerList[i]).getName());\n+        buf.append(\" listener \");\n+        buf.append(listenerList[i + 1]);\n+      }\n+    return buf.toString();\n+  }\n+}"}, {"sha": "7f7bb8e83e74dc68a24740c4a7afdb38d0707893", "filename": "libjava/javax/swing/undo/UndoableEditSupport.java", "status": "modified", "additions": 122, "deletions": 65, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3db7ef158c0e7b8bde40aa4c962d16d255c3ffd/libjava%2Fjavax%2Fswing%2Fundo%2FUndoableEditSupport.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3db7ef158c0e7b8bde40aa4c962d16d255c3ffd/libjava%2Fjavax%2Fswing%2Fundo%2FUndoableEditSupport.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fundo%2FUndoableEditSupport.java?ref=b3db7ef158c0e7b8bde40aa4c962d16d255c3ffd", "patch": "@@ -1,5 +1,5 @@\n /* UndoableEditSupport.java --\n-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,177 +38,234 @@\n \n package javax.swing.undo;\n \n+import java.util.Iterator;\n import java.util.Vector;\n import javax.swing.event.UndoableEditEvent;\n import javax.swing.event.UndoableEditListener;\n \n+\n /**\n- * UndoableEditSupport\n- * @author\tAndrew Selkirk\n+ * A helper class for supporting {@link\n+ * javax.swing.event.UndoableEditListener}.\n+ *\n+ * @author <a href=\"mailto:aselkirk@sympatico.ca\">Andrew Selkirk</a>\n+ * @author <a href=\"mailto:brawer@dandelis.ch\">Sascha Brawer</a>\n  */\n public class UndoableEditSupport\n {\n-\n-  //-------------------------------------------------------------\n-  // Variables --------------------------------------------------\n-  //-------------------------------------------------------------\n-\n   /**\n-   * updateLevel\n+   * The number of times that {@link #beginUpdate()} has been called\n+   * without a matching call to {@link #endUpdate()}.\n    */\n   protected int updateLevel;\n \n+\n   /**\n    * compoundEdit\n    */\n   protected CompoundEdit compoundEdit;\n \n+\n   /**\n-   * listeners\n+   * The currently registered listeners.\n    */\n   protected Vector listeners = new Vector();\n \n+\n   /**\n-   * realSource\n+   * The source of the broadcast UndoableEditEvents.\n    */\n   protected Object realSource;\n \n \n-  //-------------------------------------------------------------\n-  // Initialization ---------------------------------------------\n-  //-------------------------------------------------------------\n-\n   /**\n-   * Constructor UndoableEditSupport\n+   * Constructs a new helper for broadcasting UndoableEditEvents.  The\n+   * events will indicate the newly constructed\n+   * <code>UndoableEditSupport</code> instance as their source.\n+   *\n+   * @see #UndoableEditSupport(java.lang.Object)\n    */\n   public UndoableEditSupport()\n   {\n+    realSource = this;\n   }\n \n+\n   /**\n-   * Constructor UndoableEditSupport\n-   * @param object TODO\n+   * Constructs a new helper for broadcasting UndoableEditEvents.\n+   *\n+   * @param realSource the source of the UndoableEditEvents that will\n+   * be broadcast by this helper. If <code>realSource</code> is\n+   * <code>null</code>, the events will indicate the newly constructed\n+   * <code>UndoableEditSupport</code> instance as their source.\n    */\n-  public UndoableEditSupport(Object object)\n+  public UndoableEditSupport(Object realSource)\n   {\n-    realSource = object;\n+    if (realSource == null)\n+      realSource = this;\n+    this.realSource = realSource;\n   }\n \n \n-  //-------------------------------------------------------------\n-  // Methods ----------------------------------------------------\n-  //-------------------------------------------------------------\n-\n   /**\n-   * toString\n-   * @returns String\n+   * Returns a string representation of this object that may be useful\n+   * for debugging.\n    */\n   public String toString()\n   {\n-    return (super.toString() + \" realSource: \" + realSource\n-\t    + \" updateLevel: \" + updateLevel);\n+    // Note that often, this.realSource == this. Therefore, dumping\n+    // realSource without additional checks may lead to infinite\n+    // recursion. See Classpath bug #7119.\n+    return super.toString() + \" updateLevel: \" + updateLevel\n+      + \" listeners: \" + listeners + \" compoundEdit: \" + compoundEdit;\n   }\n \n+\n   /**\n-   * Add a listener.\n-   * @param val the listener\n+   * Registers a listener.\n+   *\n+   * @param val the listener to be added.\n    */\n   public synchronized void addUndoableEditListener(UndoableEditListener val)\n   {\n     listeners.add(val);\n   }\n \n+\n   /**\n-   * Remove a listener.\n-   * @param val the listener\n+   * Unregisters a listener.\n+   * @param val the listener to be removed.\n    */\n   public synchronized void removeUndoableEditListener(UndoableEditListener val)\n   {\n     listeners.removeElement(val);\n   }\n \n+\n   /**\n-   * Return an array of all listeners.\n-   * @returns all the listeners\n+   * Returns an array containing the currently registered listeners.\n    */\n   public synchronized UndoableEditListener[] getUndoableEditListeners()\n   {\n     UndoableEditListener[] result = new UndoableEditListener[listeners.size()];\n     return (UndoableEditListener[]) listeners.toArray(result);\n   }\n \n+\n   /**\n-   * _postEdit\n-   * @param value0 TODO\n+   * Notifies all registered listeners that an {@link\n+   * UndoableEditEvent} has occured.\n+   *\n+   * <p><b>Lack of Thread Safety:</b> It is <em>not</em> safe to call\n+   * this method from concurrent threads, unless the call is protected\n+   * by a synchronization on this <code>UndoableEditSupport</code>\n+   * instance.\n+   *\n+   * @param edit the edit action to be posted.\n    */\n   protected void _postEdit(UndoableEdit edit)\n   {\n-    UndoableEditEvent event = new UndoableEditEvent(realSource, edit);\n-    int max = listeners.size();\n-    for (int i = 0; i < max; ++i)\n-      {\n-\tUndoableEditListener l\n-\t  = (UndoableEditListener) (listeners.elementAt(i));\n-\tl.undoableEditHappened(event);\n-      }\n+    UndoableEditEvent event;\n+    Iterator iter;\n+\n+    // Do nothing if we have no listeners.\n+    if (listeners.isEmpty())\n+      return;\n+\n+    event = new UndoableEditEvent(realSource, edit);\n+\n+    // We clone the vector because this allows listeners to register\n+    // or unregister listeners in their undoableEditHappened method.\n+    // Otherwise, this would throw exceptions (in the case of\n+    // Iterator, a java.util.ConcurrentModificationException; in the\n+    // case of a direct loop over the Vector elements, some\n+    // index-out-of-bounds exception).\n+    iter = ((Vector) listeners.clone()).iterator();\n+    while (iter.hasNext())\n+      ((UndoableEditListener) iter.next()).undoableEditHappened(event);\n   }\n \n+\n   /**\n-   * postEdit\n-   * @param value0 TODO\n+   * If {@link #beginEdit} has been called (so that the current\n+   * update level is greater than zero), adds the specified edit\n+   * to {@link #compoundEdit}. Otherwise, notify listeners of the\n+   * edit by calling {@link #_postEdit(UndoableEdit)}.\n+   *\n+   * <p><b>Thread Safety:</b> It is safe to call this method from any\n+   * thread without external synchronization.\n+   *\n+   * @param edit the edit action to be posted.\n    */\n   public synchronized void postEdit(UndoableEdit edit)\n   {\n-    if (compoundEdit == null)\n+    if (compoundEdit != null)\n       compoundEdit.addEdit(edit);\n     else\n       _postEdit(edit);\n   }\n \n+\n   /**\n-   * getUpdateLevel\n-   * @returns int\n+   * Returns the current update level.\n    */\n   public int getUpdateLevel()\n   {\n     return updateLevel;\n   }\n \n+\n   /**\n-   * beginUpdate\n+   * Starts a (possibly nested) update session. If the current update\n+   * level is zero, {@link #compoundEdit} is set to the result of the\n+   * {@link #createCompoundEdit} method. In any case, the update level\n+   * is increased by one.\n+   *\n+   * <p><b>Thread Safety:</b> It is safe to call this method from any\n+   * thread without external synchronization.\n    */\n   public synchronized void beginUpdate()\n   {\n-    if (compoundEdit != null)\n-      {\n-\t// FIXME: what?  We can't push a new one.  This isn't even\n-\t// documented anyway.\n-\tendUpdate();\n-      }\n-\n-    compoundEdit = createCompoundEdit();\n+    if (compoundEdit == null)\n+      compoundEdit = createCompoundEdit();\n     ++updateLevel;\n   }\n \n+\n   /**\n-   * createCompoundEdit\n-   * @returns CompoundEdit\n+   * Creates a new instance of {@link #CompoundEdit}. Called by {@link\n+   * #beginUpdate}. If a subclass wants {@link #beginUpdate} to work\n+   * on a specific {@link #compoundEdit}, it should override this\n+   * method.\n+   *\n+   * @returns a newly created instance of {@link #CompoundEdit}.\n    */\n   protected CompoundEdit createCompoundEdit()\n   {\n     return new CompoundEdit();\n   }\n \n+\n   /**\n-   * endUpdate\n+   * Ends an update session. If the terminated session was the\n+   * outermost session, {@link #compoundEdit} will receive an\n+   * <code>end</code> message, and {@link #_postEdit} gets called in\n+   * order to notify any listeners. Finally, the\n+   * <code>compoundEdit</code> is discarded.\n+   *\n+   * <p><b>Thread Safety:</b> It is safe to call this method from any\n+   * thread without external synchronization.\n    */\n   public synchronized void endUpdate()\n   {\n-    // FIXME: assert updateLevel == 1;\n+    if (updateLevel == 0)\n+      throw new IllegalStateException();\n+\n+    if (--updateLevel > 0)\n+      return;\n+\n     compoundEdit.end();\n-    CompoundEdit c = compoundEdit;\n+    _postEdit(compoundEdit);\n     compoundEdit = null;\n-    --updateLevel;\n-    _postEdit(c);\n   }\n }"}]}