{"sha": "f119b4e6319031e72d02f6b1c7088cb3b7710e2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjExOWI0ZTYzMTkwMzFlNzJkMDJmNmIxYzcwODhjYjNiNzcxMGUyZA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-05-16T18:56:19Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-05-17T09:14:39Z"}, "message": "More refactoring of tree-vrp.c.\n\nNew class live_names to maintain the set of SSA names live.\n\nFix whitespace in vrp_insert.\n\nMove a few more methods related to ASSERT_EXPR insertion into vrp_insert.", "tree": {"sha": "24e6cc17281830a1770659f49f9b999b6b3969f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24e6cc17281830a1770659f49f9b999b6b3969f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f119b4e6319031e72d02f6b1c7088cb3b7710e2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f119b4e6319031e72d02f6b1c7088cb3b7710e2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f119b4e6319031e72d02f6b1c7088cb3b7710e2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f119b4e6319031e72d02f6b1c7088cb3b7710e2d/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65d44272bd988f695a9b5fa7e1b88c266c3089cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65d44272bd988f695a9b5fa7e1b88c266c3089cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65d44272bd988f695a9b5fa7e1b88c266c3089cb"}], "stats": {"total": 416, "additions": 247, "deletions": 169}, "files": [{"sha": "1e0330d9d55fc288c5954522192f73d68fa085d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f119b4e6319031e72d02f6b1c7088cb3b7710e2d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f119b4e6319031e72d02f6b1c7088cb3b7710e2d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f119b4e6319031e72d02f6b1c7088cb3b7710e2d", "patch": "@@ -1,3 +1,18 @@\n+2020-05-17  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* tree-vrp.c (class live_names): New.\n+\t(live_on_edge): Move into live_names.\n+\t(build_assert_expr_for): Move into vrp_insert.\n+\t(find_assert_locations_in_bb): Rename from\n+\tfind_assert_locations_1.\n+\t(process_assert_insertions_for): Move into vrp_insert.\n+\t(compare_assert_loc): Same.\n+\t(remove_range_assertions): Same.\n+\t(dump_asserts_for): Rename to vrp_insert::dump.\n+\t(debug_asserts_for): Rename to vrp_insert::debug.\n+\t(dump_all_asserts): Rename to vrp_insert::dump.\n+\t(debug_all_asserts): Rename to vrp_insert::debug.\n+\n 2020-05-17  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* tree-vrp.c (class vrp_prop): Move check_all_array_refs,"}, {"sha": "e4bc774dd508d2ddc18b2193f99b7da7ed1fb108", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 232, "deletions": 169, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f119b4e6319031e72d02f6b1c7088cb3b7710e2d/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f119b4e6319031e72d02f6b1c7088cb3b7710e2d/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=f119b4e6319031e72d02f6b1c7088cb3b7710e2d", "patch": "@@ -68,6 +68,99 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"range-op.h\"\n \n+/* Set of SSA names found live during the RPO traversal of the function\n+   for still active basic-blocks.  */\n+class live_names\n+{\n+public:\n+  live_names ();\n+  ~live_names ();\n+  void set (tree, basic_block);\n+  void clear (tree, basic_block);\n+  void merge (basic_block dest, basic_block src);\n+  bool live_on_block_p (tree, basic_block);\n+  bool live_on_edge_p (tree, edge);\n+  bool block_has_live_names_p (basic_block);\n+  void clear_block (basic_block);\n+\n+private:\n+  sbitmap *live;\n+  unsigned num_blocks;\n+  void init_bitmap_if_needed (basic_block);\n+};\n+\n+void\n+live_names::init_bitmap_if_needed (basic_block bb)\n+{\n+  unsigned i = bb->index;\n+  if (!live[i])\n+    {\n+      live[i] = sbitmap_alloc (num_ssa_names);\n+      bitmap_clear (live[i]);\n+    }\n+}\n+\n+bool\n+live_names::block_has_live_names_p (basic_block bb)\n+{\n+  unsigned i = bb->index;\n+  return live[i] && bitmap_empty_p (live[i]);\n+}\n+\n+void\n+live_names::clear_block (basic_block bb)\n+{\n+  unsigned i = bb->index;\n+  if (live[i])\n+    {\n+      sbitmap_free (live[i]);\n+      live[i] = NULL;\n+    }\n+}\n+\n+void\n+live_names::merge (basic_block dest, basic_block src)\n+{\n+  init_bitmap_if_needed (dest);\n+  init_bitmap_if_needed (src);\n+  bitmap_ior (live[dest->index], live[dest->index], live[src->index]);\n+}\n+\n+void\n+live_names::set (tree name, basic_block bb)\n+{\n+  init_bitmap_if_needed (bb);\n+  bitmap_set_bit (live[bb->index], SSA_NAME_VERSION (name));\n+}\n+\n+void\n+live_names::clear (tree name, basic_block bb)\n+{\n+  unsigned i = bb->index;\n+  if (live[i])\n+    bitmap_clear_bit (live[i], SSA_NAME_VERSION (name));\n+}\n+\n+live_names::live_names ()\n+{\n+  num_blocks = last_basic_block_for_fn (cfun);\n+  live = XCNEWVEC (sbitmap, num_blocks);\n+}\n+\n+live_names::~live_names ()\n+{\n+  for (unsigned i = 0; i < num_blocks; ++i)\n+    if (live[i])\n+      sbitmap_free (live[i]);\n+  XDELETEVEC (live);\n+}\n+\n+bool\n+live_names::live_on_block_p (tree name, basic_block bb)\n+{\n+  return (live[bb->index]\n+\t  && bitmap_bit_p (live[bb->index], SSA_NAME_VERSION (name)));\n+}\n \n \n /* Location information for ASSERT_EXPRs.  Each instance of this\n@@ -102,114 +195,121 @@ struct assert_locus\n \n class vrp_insert\n {\n-  public:\n-\n-    vrp_insert (struct function *fn)\n-      {\n-\tfun = fn;\n-      }\n-\n-    /* Traverse the flowgraph looking for conditional jumps to insert range\n-       expressions.  These range expressions are meant to provide information\n-       to optimizations that need to reason in terms of value ranges.  They\n-       will not be expanded into RTL.  See method implementation comment\n-       for example.  */\n-    void insert_range_assertions ();\n-\n-\n-    /* Dump all the registered assertions for all the names to FILE.  */\n-    void dump_all_asserts (FILE *);\n-\n-    /* Dump all the registered assertions for NAME to FILE.  */\n-    void dump_asserts_for (FILE *file, tree name);\n-\n-    /* Dump all the registered assertions for NAME to stderr.  */\n-    DEBUG_FUNCTION void debug_asserts_for (tree name)\n-      {\n-\tdump_asserts_for (stderr, name);\n-      }\n-\n-    DEBUG_FUNCTION void debug_all_asserts ()\n-      {\n-\tdump_all_asserts (stderr);\n-      }\n-\n-  private:\n-    /* Set of SSA names found live during the RPO traversal of the function\n-       for still active basic-blocks.  */\n-    sbitmap *live;\n-\n-    /* Function to work on.  */\n-    struct function *fun;\n-\n-    /* If bit I is present, it means that SSA name N_i has a list of\n-       assertions that should be inserted in the IL.  */\n-    bitmap need_assert_for;\n-\n-    /* Array of locations lists where to insert assertions.  ASSERTS_FOR[I]\n-       holds a list of ASSERT_LOCUS_T nodes that describe where\n-       ASSERT_EXPRs for SSA name N_I should be inserted.  */\n-    assert_locus **asserts_for;\n-\n-    /* Return true if the SSA name NAME is live on the edge E.  */\n-    bool live_on_edge (edge e, tree name);\n-\n-    /* Finish found ASSERTS for E and register them at GSI.  */\n-    void finish_register_edge_assert_for (edge e, gimple_stmt_iterator gsi,\n-\t\t\t\t\t  vec<assert_info> &asserts);\n-\n-    /* Determine whether the outgoing edges of BB should receive an\n-       ASSERT_EXPR for each of the operands of BB's LAST statement.\n-       The last statement of BB must be a SWITCH_EXPR.\n-\n-       If any of the sub-graphs rooted at BB have an interesting use of\n-       the predicate operands, an assert location node is added to the\n-       list of assertions for the corresponding operands.  */\n-    void find_switch_asserts (basic_block bb, gswitch *last);\n-\n-\n-    /* Do an RPO walk over the function computing SSA name liveness\n-       on-the-fly and deciding on assert expressions to insert.  */\n-    void find_assert_locations ();\n+public:\n+  vrp_insert (struct function *fn) : fun (fn) { }\n \n-    /* Traverse all the statements in block BB looking for statements that\n-       may generate useful assertions for the SSA names in their operand.\n-       See method implementation comentary for more information.  */\n-    void find_assert_locations_1 (basic_block bb, sbitmap live);\n+  /* Traverse the flowgraph looking for conditional jumps to insert range\n+     expressions.  These range expressions are meant to provide information\n+     to optimizations that need to reason in terms of value ranges.  They\n+     will not be expanded into RTL.  See method implementation comment\n+     for example.  */\n+  void insert_range_assertions ();\n \n-    /* Determine whether the outgoing edges of BB should receive an\n-       ASSERT_EXPR for each of the operands of BB's LAST statement.\n-       The last statement of BB must be a COND_EXPR.\n+  /* Convert range assertion expressions into the implied copies and\n+     copy propagate away the copies.  */\n+  void remove_range_assertions ();\n \n-       If any of the sub-graphs rooted at BB have an interesting use of\n-       the predicate operands, an assert location node is added to the\n-       list of assertions for the corresponding operands.  */\n-    void find_conditional_asserts (basic_block bb, gcond *last);\n+  /* Dump all the registered assertions for all the names to FILE.  */\n+  void dump (FILE *);\n \n+  /* Dump all the registered assertions for NAME to FILE.  */\n+  void dump (FILE *file, tree name);\n \n-    /* Process all the insertions registered for every name N_i registered\n-       in NEED_ASSERT_FOR.  The list of assertions to be inserted are\n-       found in ASSERTS_FOR[i].  */\n+  /* Dump all the registered assertions for NAME to stderr.  */\n+  void debug (tree name)\n+  {\n+    dump (stderr, name);\n+  }\n \n-    void process_assert_insertions ();\n+  /* Dump all the registered assertions for all the names to stderr.  */\n+  void debug ()\n+  {\n+    dump (stderr);\n+  }\n \n+private:\n+  /* Set of SSA names found live during the RPO traversal of the function\n+     for still active basic-blocks.  */\n+  live_names live;\n \n-    /* If NAME doesn't have an ASSERT_EXPR registered for asserting\n-       'EXPR COMP_CODE VAL' at a location that dominates block BB or\n-       E->DEST, then register this location as a possible insertion point\n-       for ASSERT_EXPR <NAME, EXPR COMP_CODE VAL>.\n+  /* Function to work on.  */\n+  struct function *fun;\n \n-       BB, E and SI provide the exact insertion point for the new\n-       ASSERT_EXPR.  If BB is NULL, then the ASSERT_EXPR is to be inserted\n-       on edge E.  Otherwise, if E is NULL, the ASSERT_EXPR is inserted on\n-       BB.  If SI points to a COND_EXPR or a SWITCH_EXPR statement, then E\n-       must not be NULL.  */\n-    void register_new_assert_for (tree name, tree expr,\n-\t\t\t\t  enum tree_code comp_code,\n-\t\t\t\t  tree val,\n-\t\t\t\t  basic_block bb,\n-\t\t\t\t  edge e,\n-\t\t\t\t  gimple_stmt_iterator si);\n+  /* If bit I is present, it means that SSA name N_i has a list of\n+     assertions that should be inserted in the IL.  */\n+  bitmap need_assert_for;\n+\n+  /* Array of locations lists where to insert assertions.  ASSERTS_FOR[I]\n+     holds a list of ASSERT_LOCUS_T nodes that describe where\n+     ASSERT_EXPRs for SSA name N_I should be inserted.  */\n+  assert_locus **asserts_for;\n+\n+  /* Return true if the SSA name NAME is live on the edge E.  */\n+  bool live_on_edge (edge e, tree name);\n+\n+  /* Finish found ASSERTS for E and register them at GSI.  */\n+  void finish_register_edge_assert_for (edge e, gimple_stmt_iterator gsi,\n+\t\t\t\t\tvec<assert_info> &asserts);\n+\n+  /* Determine whether the outgoing edges of BB should receive an\n+     ASSERT_EXPR for each of the operands of BB's LAST statement.  The\n+     last statement of BB must be a SWITCH_EXPR.\n+\n+     If any of the sub-graphs rooted at BB have an interesting use of\n+     the predicate operands, an assert location node is added to the\n+     list of assertions for the corresponding operands.  */\n+  void find_switch_asserts (basic_block bb, gswitch *last);\n+\n+  /* Do an RPO walk over the function computing SSA name liveness\n+     on-the-fly and deciding on assert expressions to insert.  */\n+  void find_assert_locations ();\n+\n+  /* Traverse all the statements in block BB looking for statements that\n+     may generate useful assertions for the SSA names in their operand.\n+     See method implementation comentary for more information.  */\n+  void find_assert_locations_in_bb (basic_block bb);\n+\n+  /* Determine whether the outgoing edges of BB should receive an\n+     ASSERT_EXPR for each of the operands of BB's LAST statement.\n+     The last statement of BB must be a COND_EXPR.\n+\n+     If any of the sub-graphs rooted at BB have an interesting use of\n+     the predicate operands, an assert location node is added to the\n+     list of assertions for the corresponding operands.  */\n+  void find_conditional_asserts (basic_block bb, gcond *last);\n+\n+  /* Process all the insertions registered for every name N_i registered\n+     in NEED_ASSERT_FOR.  The list of assertions to be inserted are\n+     found in ASSERTS_FOR[i].  */\n+  void process_assert_insertions ();\n+\n+  /* If NAME doesn't have an ASSERT_EXPR registered for asserting\n+     'EXPR COMP_CODE VAL' at a location that dominates block BB or\n+     E->DEST, then register this location as a possible insertion point\n+     for ASSERT_EXPR <NAME, EXPR COMP_CODE VAL>.\n+\n+     BB, E and SI provide the exact insertion point for the new\n+     ASSERT_EXPR.  If BB is NULL, then the ASSERT_EXPR is to be inserted\n+     on edge E.  Otherwise, if E is NULL, the ASSERT_EXPR is inserted on\n+     BB.  If SI points to a COND_EXPR or a SWITCH_EXPR statement, then E\n+     must not be NULL.  */\n+  void register_new_assert_for (tree name, tree expr,\n+\t\t\t\tenum tree_code comp_code,\n+\t\t\t\ttree val, basic_block bb,\n+\t\t\t\tedge e, gimple_stmt_iterator si);\n+\n+  /* Given a COND_EXPR COND of the form 'V OP W', and an SSA name V,\n+     create a new SSA name N and return the assertion assignment\n+     'N = ASSERT_EXPR <V, V OP W>'.  */\n+  gimple *build_assert_expr_for (tree cond, tree v);\n+\n+  /* Create an ASSERT_EXPR for NAME and insert it in the location\n+     indicated by LOC.  Return true if we made any edge insertions.  */\n+  bool process_assert_insertions_for (tree name, assert_locus *loc);\n+\n+  /* Qsort callback for sorting assert locations.  */\n+  template <bool stable> static int compare_assert_loc (const void *,\n+\t\t\t\t\t\t\tconst void *);\n };\n \n void\n@@ -419,10 +519,9 @@ debug (const value_range_equiv &vr)\n /* Return true if the SSA name NAME is live on the edge E.  */\n \n bool\n-vrp_insert::live_on_edge (edge e, tree name)\n+live_names::live_on_edge_p (tree name, edge e)\n {\n-  return (live[e->dest->index]\n-\t  && bitmap_bit_p (live[e->dest->index], SSA_NAME_VERSION (name)));\n+  return live_on_block_p (name, e->dest);\n }\n \n \n@@ -1380,8 +1479,8 @@ range_fold_unary_expr (value_range *vr,\n    create a new SSA name N and return the assertion assignment\n    'N = ASSERT_EXPR <V, V OP W>'.  */\n \n-static gimple *\n-build_assert_expr_for (tree cond, tree v)\n+gimple *\n+vrp_insert::build_assert_expr_for (tree cond, tree v)\n {\n   tree a;\n   gassign *assertion;\n@@ -1460,15 +1559,10 @@ infer_value_range (gimple *stmt, tree op, tree_code *comp_code_p, tree *val_p)\n   return false;\n }\n \n-\n-void debug_asserts_for (tree);\n-void dump_all_asserts (FILE *);\n-void debug_all_asserts (void);\n-\n /* Dump all the registered assertions for NAME to FILE.  */\n \n void\n-vrp_insert::dump_asserts_for (FILE *file, tree name)\n+vrp_insert::dump (FILE *file, tree name)\n {\n   assert_locus *loc;\n \n@@ -1499,22 +1593,20 @@ vrp_insert::dump_asserts_for (FILE *file, tree name)\n   fprintf (file, \"\\n\");\n }\n \n-\n /* Dump all the registered assertions for all the names to FILE.  */\n \n void\n-vrp_insert::dump_all_asserts (FILE *file)\n+vrp_insert::dump (FILE *file)\n {\n   unsigned i;\n   bitmap_iterator bi;\n \n   fprintf (file, \"\\nASSERT_EXPRs to be inserted\\n\\n\");\n   EXECUTE_IF_SET_IN_BITMAP (need_assert_for, 0, i, bi)\n-    dump_asserts_for (file, ssa_name (i));\n+    dump (file, ssa_name (i));\n   fprintf (file, \"\\n\");\n }\n \n-\n /* Dump assert_info structure.  */\n \n void\n@@ -2704,7 +2796,7 @@ vrp_insert::finish_register_edge_assert_for (edge e, gimple_stmt_iterator gsi,\n   for (unsigned i = 0; i < asserts.length (); ++i)\n     /* Only register an ASSERT_EXPR if NAME was found in the sub-graph\n        reachable from E.  */\n-    if (live_on_edge (e, asserts[i].name))\n+    if (live.live_on_edge_p (asserts[i].name, e))\n       register_new_assert_for (asserts[i].name, asserts[i].expr,\n \t\t\t       asserts[i].comp_code, asserts[i].val,\n \t\t\t       NULL, e, gsi);\n@@ -2874,7 +2966,7 @@ vrp_insert::find_switch_asserts (basic_block bb, gswitch *last)\n \n   XDELETEVEC (ci);\n \n-  if (!live_on_edge (default_edge, op))\n+  if (!live.live_on_edge_p (op, default_edge))\n     return;\n \n   /* Now register along the default label assertions that correspond to the\n@@ -3005,7 +3097,7 @@ vrp_insert::find_switch_asserts (basic_block bb, gswitch *last)\n    P_4 will receive an ASSERT_EXPR.  */\n \n void\n-vrp_insert::find_assert_locations_1 (basic_block bb, sbitmap live)\n+vrp_insert::find_assert_locations_in_bb (basic_block bb)\n {\n   gimple *last;\n \n@@ -3048,7 +3140,7 @@ vrp_insert::find_assert_locations_1 (basic_block bb, sbitmap live)\n \n \t  /* If op is not live beyond this stmt, do not bother to insert\n \t     asserts for it.  */\n-\t  if (!bitmap_bit_p (live, SSA_NAME_VERSION (op)))\n+\t  if (!live.live_on_block_p (op, bb))\n \t    continue;\n \n \t  /* If OP is used in such a way that we can infer a value\n@@ -3081,7 +3173,7 @@ vrp_insert::find_assert_locations_1 (basic_block bb, sbitmap live)\n \t\t      /* Note we want to register the assert for the\n \t\t\t operand of the NOP_EXPR after SI, not after the\n \t\t\t conversion.  */\n-\t\t      if (bitmap_bit_p (live, SSA_NAME_VERSION (t)))\n+\t\t      if (live.live_on_block_p (t, bb))\n \t\t\tregister_new_assert_for (t, t, comp_code, value,\n \t\t\t\t\t\t bb, NULL, si);\n \t\t    }\n@@ -3093,9 +3185,9 @@ vrp_insert::find_assert_locations_1 (basic_block bb, sbitmap live)\n \n       /* Update live.  */\n       FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_USE)\n-\tbitmap_set_bit (live, SSA_NAME_VERSION (op));\n+\tlive.set (op, bb);\n       FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_DEF)\n-\tbitmap_clear_bit (live, SSA_NAME_VERSION (op));\n+\tlive.clear (op, bb);\n     }\n \n   /* Traverse all PHI nodes in BB, updating live.  */\n@@ -3114,10 +3206,10 @@ vrp_insert::find_assert_locations_1 (basic_block bb, sbitmap live)\n \t{\n \t  tree arg = USE_FROM_PTR (arg_p);\n \t  if (TREE_CODE (arg) == SSA_NAME)\n-\t    bitmap_set_bit (live, SSA_NAME_VERSION (arg));\n+\t    live.set (arg, bb);\n \t}\n \n-      bitmap_clear_bit (live, SSA_NAME_VERSION (res));\n+      live.clear (res, bb);\n     }\n }\n \n@@ -3132,7 +3224,6 @@ vrp_insert::find_assert_locations (void)\n   int *last_rpo = XCNEWVEC (int, last_basic_block_for_fn (fun));\n   int rpo_cnt, i;\n \n-  live = XCNEWVEC (sbitmap, last_basic_block_for_fn (fun));\n   rpo_cnt = pre_and_rev_post_order_compute (NULL, rpo, false);\n   for (i = 0; i < rpo_cnt; ++i)\n     bb_rpo[rpo[i]] = i;\n@@ -3153,14 +3244,7 @@ vrp_insert::find_assert_locations (void)\n \t    continue;\n \t  tree arg = gimple_phi_arg_def (phi, j);\n \t  if (TREE_CODE (arg) == SSA_NAME)\n-\t    {\n-\t      if (live[i] == NULL)\n-\t\t{\n-\t\t  live[i] = sbitmap_alloc (num_ssa_names);\n-\t\t  bitmap_clear (live[i]);\n-\t\t}\n-\t      bitmap_set_bit (live[i], SSA_NAME_VERSION (arg));\n-\t    }\n+\t    live.set (arg, loop->latch);\n \t}\n     }\n \n@@ -3170,18 +3254,12 @@ vrp_insert::find_assert_locations (void)\n       edge e;\n       edge_iterator ei;\n \n-      if (!live[rpo[i]])\n-\t{\n-\t  live[rpo[i]] = sbitmap_alloc (num_ssa_names);\n-\t  bitmap_clear (live[rpo[i]]);\n-\t}\n-\n       /* Process BB and update the live information with uses in\n          this block.  */\n-      find_assert_locations_1 (bb, live[rpo[i]]);\n+      find_assert_locations_in_bb (bb);\n \n       /* Merge liveness into the predecessor blocks and free it.  */\n-      if (!bitmap_empty_p (live[rpo[i]]))\n+      if (!live.block_has_live_names_p (bb))\n \t{\n \t  int pred_rpo = i;\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n@@ -3190,12 +3268,7 @@ vrp_insert::find_assert_locations (void)\n \t      if ((e->flags & EDGE_DFS_BACK) || pred == ENTRY_BLOCK)\n \t\tcontinue;\n \n-\t      if (!live[pred])\n-\t\t{\n-\t\t  live[pred] = sbitmap_alloc (num_ssa_names);\n-\t\t  bitmap_clear (live[pred]);\n-\t\t}\n-\t      bitmap_ior (live[pred], live[pred], live[rpo[i]]);\n+\t      live.merge (e->src, bb);\n \n \t      if (bb_rpo[pred] < pred_rpo)\n \t\tpred_rpo = bb_rpo[pred];\n@@ -3206,36 +3279,25 @@ vrp_insert::find_assert_locations (void)\n \t  last_rpo[rpo[i]] = pred_rpo;\n \t}\n       else\n-\t{\n-\t  sbitmap_free (live[rpo[i]]);\n-\t  live[rpo[i]] = NULL;\n-\t}\n+\tlive.clear_block (bb);\n \n       /* We can free all successors live bitmaps if all their\n          predecessors have been visited already.  */\n       FOR_EACH_EDGE (e, ei, bb->succs)\n-\tif (last_rpo[e->dest->index] == i\n-\t    && live[e->dest->index])\n-\t  {\n-\t    sbitmap_free (live[e->dest->index]);\n-\t    live[e->dest->index] = NULL;\n-\t  }\n+\tif (last_rpo[e->dest->index] == i)\n+\t  live.clear_block (e->dest);\n     }\n \n   XDELETEVEC (rpo);\n   XDELETEVEC (bb_rpo);\n   XDELETEVEC (last_rpo);\n-  for (i = 0; i < last_basic_block_for_fn (fun); ++i)\n-    if (live[i])\n-      sbitmap_free (live[i]);\n-  XDELETEVEC (live);\n }\n \n /* Create an ASSERT_EXPR for NAME and insert it in the location\n    indicated by LOC.  Return true if we made any edge insertions.  */\n \n-static bool\n-process_assert_insertions_for (tree name, assert_locus *loc)\n+bool\n+vrp_insert::process_assert_insertions_for (tree name, assert_locus *loc)\n {\n   /* Build the comparison expression NAME_i COMP_CODE VAL.  */\n   gimple *stmt;\n@@ -3299,8 +3361,8 @@ process_assert_insertions_for (tree name, assert_locus *loc)\n    on the other side some pointers might be NULL.  */\n \n template <bool stable>\n-static int\n-compare_assert_loc (const void *pa, const void *pb)\n+int\n+vrp_insert::compare_assert_loc (const void *pa, const void *pb)\n {\n   assert_locus * const a = *(assert_locus * const *)pa;\n   assert_locus * const b = *(assert_locus * const *)pb;\n@@ -3376,7 +3438,7 @@ vrp_insert::process_assert_insertions ()\n   int num_asserts = 0;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    dump_all_asserts (dump_file);\n+    dump (dump_file);\n \n   EXECUTE_IF_SET_IN_BITMAP (need_assert_for, 0, i, bi)\n     {\n@@ -4348,8 +4410,8 @@ maybe_set_nonzero_bits (edge e, tree var)\n    any pass.  This is made somewhat more complex by the need for\n    multiple ranges to be associated with one SSA_NAME.  */\n \n-static void\n-remove_range_assertions (struct function *fun)\n+void\n+vrp_insert::remove_range_assertions ()\n {\n   basic_block bb;\n   gimple_stmt_iterator si;\n@@ -5375,7 +5437,8 @@ execute_vrp (struct function *fun, bool warn_array_bounds_p)\n   /* ???  This ends up using stale EDGE_DFS_BACK for liveness computation.\n      Inserting assertions may split edges which will invalidate\n      EDGE_DFS_BACK.  */\n-  vrp_insert (fun).insert_range_assertions ();\n+  vrp_insert assert_engine (fun);\n+  assert_engine.insert_range_assertions ();\n \n   threadedge_initialize_values ();\n \n@@ -5411,7 +5474,7 @@ execute_vrp (struct function *fun, bool warn_array_bounds_p)\n   /* ASSERT_EXPRs must be removed before finalizing jump threads\n      as finalizing jump threads calls the CFG cleanup code which\n      does not properly handle ASSERT_EXPRs.  */\n-  remove_range_assertions (fun);\n+  assert_engine.remove_range_assertions ();\n \n   /* If we exposed any new variables, go ahead and put them into\n      SSA form now, before we handle jump threading.  This simplifies"}]}