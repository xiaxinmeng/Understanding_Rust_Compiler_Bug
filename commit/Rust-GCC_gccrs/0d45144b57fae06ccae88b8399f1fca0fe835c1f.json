{"sha": "0d45144b57fae06ccae88b8399f1fca0fe835c1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ0NTE0NGI1N2ZhZTA2Y2NhZTg4YjgzOTlmMWZjYTBmZTgzNWMxZg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-09-08T00:25:05Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-09-08T00:25:05Z"}, "message": "bb-reorder.c (fixup_reorder_chain): Add jump in new block after switch for CASE_DROPS_THROUGH.\n\n        * bb-reorder.c (fixup_reorder_chain): Add jump in new block\n        after switch for CASE_DROPS_THROUGH.\n\nFrom-SVN: r36253", "tree": {"sha": "fffc9d3f30288a72c893b63295a8637a7ea41c8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fffc9d3f30288a72c893b63295a8637a7ea41c8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d45144b57fae06ccae88b8399f1fca0fe835c1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d45144b57fae06ccae88b8399f1fca0fe835c1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d45144b57fae06ccae88b8399f1fca0fe835c1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d45144b57fae06ccae88b8399f1fca0fe835c1f/comments", "author": null, "committer": null, "parents": [{"sha": "7f586614b6d7aff9d8af781e7510ed12b7b0fd50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f586614b6d7aff9d8af781e7510ed12b7b0fd50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f586614b6d7aff9d8af781e7510ed12b7b0fd50"}], "stats": {"total": 32, "additions": 21, "deletions": 11}, "files": [{"sha": "c35e8e492049b5b9ff89ec8ad55c8f87428e3f67", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d45144b57fae06ccae88b8399f1fca0fe835c1f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d45144b57fae06ccae88b8399f1fca0fe835c1f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d45144b57fae06ccae88b8399f1fca0fe835c1f", "patch": "@@ -1,3 +1,8 @@\n+2000-09-07  Richard Henderson  <rth@cygnus.com>\n+\n+\t* bb-reorder.c (fixup_reorder_chain): Add jump in new block\n+\tafter switch for CASE_DROPS_THROUGH.\n+\n 2000-09-07  Richard Henderson  <rth@cygnus.com>\n \n \t* loop.c (strength_reduce): Call check_ext_dependant_givs."}, {"sha": "c6b996edc744147451e39f4183976a67fcbe2590", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d45144b57fae06ccae88b8399f1fca0fe835c1f/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d45144b57fae06ccae88b8399f1fca0fe835c1f/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=0d45144b57fae06ccae88b8399f1fca0fe835c1f", "patch": "@@ -549,7 +549,7 @@ fixup_reorder_chain ()\n   for (bb = BASIC_BLOCK (0); bb ; bb = RBI (bb)->next)\n     {\n       edge e_fall, e_taken, e;\n-      rtx jump_insn, barrier_insn;\n+      rtx jump_insn, barrier_insn, bb_end_insn;\n       basic_block nb;\n \n       if (bb->succ == NULL)\n@@ -564,9 +564,10 @@ fixup_reorder_chain ()\n \telse if (! (e->flags & EDGE_EH))\n \t  e_taken = e;\n \n-      if (GET_CODE (bb->end) == JUMP_INSN)\n+      bb_end_insn = bb->end;\n+      if (GET_CODE (bb_end_insn) == JUMP_INSN)\n \t{\n-\t  if (any_uncondjump_p (bb->end))\n+\t  if (any_uncondjump_p (bb_end_insn))\n \t    {\n \t      /* If the destination is still not next, nothing to do.  */\n \t      if (RBI (bb)->index + 1 != RBI (e_taken->dest)->index)\n@@ -582,7 +583,7 @@ fixup_reorder_chain ()\n \t\t\t bb->index, RBI (bb)->index);\n \t      continue;\n \t    }\n-\t  else if (any_condjump_p (bb->end))\n+\t  else if (any_condjump_p (bb_end_insn))\n \t    {\n \t      /* If the old fallthru is still next, nothing to do.  */\n \t      if (RBI (bb)->index + 1 == RBI (e_fall->dest)->index\n@@ -596,10 +597,11 @@ fixup_reorder_chain ()\n \t\t edge based on known or assumed probability.  */\n \t      if (RBI (bb)->index + 1 != RBI (e_taken->dest)->index)\n \t\t{\n-\t\t  rtx note = find_reg_note (bb->end, REG_BR_PROB, 0);\n+\t\t  rtx note = find_reg_note (bb_end_insn, REG_BR_PROB, 0);\n \t\t  if (note\n \t\t      && INTVAL (XEXP (note, 0)) < REG_BR_PROB_BASE / 2\n-\t\t      && invert_jump (bb->end, label_for_bb (e_fall->dest), 0))\n+\t\t      && invert_jump (bb_end_insn,\n+\t\t\t\t      label_for_bb (e_fall->dest), 0))\n \t\t    {\n \t\t      e_fall->flags &= ~EDGE_FALLTHRU;\n \t\t      e_taken->flags |= EDGE_FALLTHRU;\n@@ -609,14 +611,15 @@ fixup_reorder_chain ()\n \n \t      /* Otherwise we can try to invert the jump.  This will \n \t\t basically never fail, however, keep up the pretense.  */\n-\t      else if (invert_jump (bb->end, label_for_bb (e_fall->dest), 0))\n+\t      else if (invert_jump (bb_end_insn,\n+\t\t\t\t    label_for_bb (e_fall->dest), 0))\n \t\t{\n \t\t  e_fall->flags &= ~EDGE_FALLTHRU;\n \t\t  e_taken->flags |= EDGE_FALLTHRU;\n \t\t  continue;\n \t\t}\n \t    }\n-\t  else if (returnjump_p (bb->end))\n+\t  else if (returnjump_p (bb_end_insn))\n \t    continue;\n \t  else\n \t    {\n@@ -629,8 +632,10 @@ fixup_reorder_chain ()\n \t\t tablejump, the fallthru block should not have moved.  */\n \t      if (RBI (bb)->index + 1 == RBI (e_fall->dest)->index)\n \t\tcontinue;\n-#endif\n+\t      bb_end_insn = skip_insns_after_block (bb);\n+#else\n \t      abort ();\n+#endif\n \t    }\n \t}\n       else\n@@ -653,7 +658,7 @@ fixup_reorder_chain ()\n \t    {\n \t      e_fall->flags &= ~EDGE_FALLTHRU;\n \n-\t      jump_insn = emit_jump_to_block_after (e_fall->dest, bb->end);\n+\t      jump_insn = emit_jump_to_block_after (e_fall->dest, bb_end_insn);\n \t      bb->end = jump_insn;\n \t      barrier_insn = emit_barrier_after (jump_insn);\n \t      RBI (bb)->eff_end = barrier_insn;\n@@ -664,7 +669,7 @@ fixup_reorder_chain ()\n       /* We got here if we need to add a new jump insn in a new block\n \t across the edge e_fall.  */\n \n-      jump_insn = emit_jump_to_block_after (e_fall->dest, bb->end);\n+      jump_insn = emit_jump_to_block_after (e_fall->dest, bb_end_insn);\n       barrier_insn = emit_barrier_after (jump_insn);\n \n       VARRAY_GROW (basic_block_info, ++n_basic_blocks);"}]}