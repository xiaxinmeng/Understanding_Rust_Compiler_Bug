{"sha": "a2061c0d6183d357a981f9f59b01690772a8131d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTIwNjFjMGQ2MTgzZDM1N2E5ODFmOWY1OWIwMTY5MDc3MmE4MTMxZA==", "commit": {"author": {"name": "Geoff Keating", "email": "geoffk@cygnus.com", "date": "2000-07-27T00:15:23Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2000-07-27T00:15:23Z"}, "message": "emit-rtl.c (gen_lowpart_common): Handle cross-compiling between 64-bit and 32-bit machines.\n\n* emit-rtl.c (gen_lowpart_common) [REAL_ARITHMETIC]: Handle\ncross-compiling between 64-bit and 32-bit machines.\n\nFrom-SVN: r35275", "tree": {"sha": "c04dec35ea5c372419fbf5e3397ea35e89d562ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c04dec35ea5c372419fbf5e3397ea35e89d562ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2061c0d6183d357a981f9f59b01690772a8131d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2061c0d6183d357a981f9f59b01690772a8131d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2061c0d6183d357a981f9f59b01690772a8131d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2061c0d6183d357a981f9f59b01690772a8131d/comments", "author": null, "committer": null, "parents": [{"sha": "75cdbeb8b6e67e5fecd9daab6c748d927a3b7ccf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75cdbeb8b6e67e5fecd9daab6c748d927a3b7ccf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75cdbeb8b6e67e5fecd9daab6c748d927a3b7ccf"}], "stats": {"total": 165, "additions": 100, "deletions": 65}, "files": [{"sha": "bb2835d9b574ad9c7cce64ef9b8f4cfdabeb9b54", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2061c0d6183d357a981f9f59b01690772a8131d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2061c0d6183d357a981f9f59b01690772a8131d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a2061c0d6183d357a981f9f59b01690772a8131d", "patch": "@@ -1,3 +1,8 @@\n+2000-07-26  Geoffrey Keating  <geoffk@cygnus.com>\n+\n+\t* emit-rtl.c (gen_lowpart_common) [REAL_ARITHMETIC]: Handle\n+\tcross-compiling between 64-bit and 32-bit machines.\n+\n 2000-07-27  Richard Henderson  <rth@cygnus.com>\n \n \t* config/ia64/ia64.md (movqicc_astep, movqi_internal_astep): New."}, {"sha": "a34e6bbc5f9936a2e0f0a4758f77ffa04f44593f", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 95, "deletions": 65, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2061c0d6183d357a981f9f59b01690772a8131d/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2061c0d6183d357a981f9f59b01690772a8131d/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=a2061c0d6183d357a981f9f59b01690772a8131d", "patch": "@@ -793,6 +793,7 @@ gen_lowpart_common (mode, x)\n \t}\n     }\n \n+#ifndef REAL_ARITHMETIC\n   /* If X is an integral constant but we want it in floating-point, it\n      must be the case that we have a union of an integer and a floating-point\n      value.  If the machine-parameters allow it, simulate that union here\n@@ -806,23 +807,12 @@ gen_lowpart_common (mode, x)\n \t   && GET_MODE_SIZE (mode) == UNITS_PER_WORD\n \t   && GET_CODE (x) == CONST_INT\n \t   && sizeof (float) * HOST_BITS_PER_CHAR == HOST_BITS_PER_WIDE_INT)\n-#ifdef REAL_ARITHMETIC\n-    {\n-      REAL_VALUE_TYPE r;\n-      HOST_WIDE_INT i;\n-\n-      i = INTVAL (x);\n-      r = REAL_VALUE_FROM_TARGET_SINGLE (i);\n-      return CONST_DOUBLE_FROM_REAL_VALUE (r, mode);\n-    }\n-#else\n     {\n       union {HOST_WIDE_INT i; float d; } u;\n \n       u.i = INTVAL (x);\n       return CONST_DOUBLE_FROM_REAL_VALUE (u.d, mode);\n     }\n-#endif\n   else if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n \t     && HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)\n \t    || flag_pretend_float)\n@@ -832,28 +822,6 @@ gen_lowpart_common (mode, x)\n \t   && GET_MODE (x) == VOIDmode\n \t   && (sizeof (double) * HOST_BITS_PER_CHAR\n \t       == 2 * HOST_BITS_PER_WIDE_INT))\n-#ifdef REAL_ARITHMETIC\n-    {\n-      REAL_VALUE_TYPE r;\n-      HOST_WIDE_INT i[2];\n-      HOST_WIDE_INT low, high;\n-\n-      if (GET_CODE (x) == CONST_INT)\n-\tlow = INTVAL (x), high = low >> (HOST_BITS_PER_WIDE_INT -1);\n-      else\n-\tlow = CONST_DOUBLE_LOW (x), high = CONST_DOUBLE_HIGH (x);\n-\n-      /* REAL_VALUE_TARGET_DOUBLE takes the addressing order of the\n-\t target machine.  */\n-      if (WORDS_BIG_ENDIAN)\n-\ti[0] = high, i[1] = low;\n-      else\n-\ti[0] = low, i[1] = high;\n-\n-      r = REAL_VALUE_FROM_TARGET_DOUBLE (i);\n-      return CONST_DOUBLE_FROM_REAL_VALUE (r, mode);\n-    }\n-#else\n     {\n       union {HOST_WIDE_INT i[2]; double d; } u;\n       HOST_WIDE_INT low, high;\n@@ -871,38 +839,6 @@ gen_lowpart_common (mode, x)\n \n       return CONST_DOUBLE_FROM_REAL_VALUE (u.d, mode);\n     }\n-#endif\n-\n-  /* We need an extra case for machines where HOST_BITS_PER_WIDE_INT is the\n-     same as sizeof (double) or when sizeof (float) is larger than the\n-     size of a word on the target machine.  */\n-#ifdef REAL_ARITHMETIC\n-  else if (mode == SFmode && GET_CODE (x) == CONST_INT)\n-    {\n-      REAL_VALUE_TYPE r;\n-      HOST_WIDE_INT i;\n-\n-      i = INTVAL (x);\n-      r = REAL_VALUE_FROM_TARGET_SINGLE (i);\n-      return CONST_DOUBLE_FROM_REAL_VALUE (r, mode);\n-    }\n-  else if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n-\t     && HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)\n-\t    || flag_pretend_float)\n-\t   && GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t   && GET_MODE_SIZE (mode) == UNITS_PER_WORD\n-\t   && GET_CODE (x) == CONST_INT\n-\t   && (sizeof (double) * HOST_BITS_PER_CHAR\n-\t       == HOST_BITS_PER_WIDE_INT))\n-    {\n-      REAL_VALUE_TYPE r;\n-      HOST_WIDE_INT i;\n-\n-      i = INTVAL (x);\n-      r = REAL_VALUE_FROM_TARGET_DOUBLE (&i);\n-      return CONST_DOUBLE_FROM_REAL_VALUE (r, mode);\n-    }\n-#endif\n \n   /* Similarly, if this is converting a floating-point value into a\n      single-word integer.  Only do this is the host and target parameters are\n@@ -941,6 +877,100 @@ gen_lowpart_common (mode, x)\n \t  && highpart && GET_CODE (highpart) == CONST_INT)\n \treturn immed_double_const (INTVAL (lowpart), INTVAL (highpart), mode);\n     }\n+#else /* ifndef REAL_ARITHMETIC */\n+\n+  /* When we have a FP emulator, we can handle all conversions between\n+     FP and integer operands.  This simplifies reload because it\n+     doesn't have to deal with constructs like (subreg:DI\n+     (const_double:SF ...)) or (subreg:DF (const_int ...)).  */\n+\n+  else if (mode == SFmode\n+\t   && GET_CODE (x) == CONST_INT)\n+    {\n+      REAL_VALUE_TYPE r;\n+      HOST_WIDE_INT i;\n+\n+      i = INTVAL (x);\n+      r = REAL_VALUE_FROM_TARGET_SINGLE (i);\n+      return CONST_DOUBLE_FROM_REAL_VALUE (r, mode);\n+    }\n+  else if (mode == DFmode\n+\t   && (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE)\n+\t   && GET_MODE (x) == VOIDmode)\n+    {\n+      REAL_VALUE_TYPE r;\n+      HOST_WIDE_INT i[2];\n+      HOST_WIDE_INT low, high;\n+\n+      if (GET_CODE (x) == CONST_INT)\n+\t{\n+\t  low = INTVAL (x);\n+\t  high = low >> (HOST_BITS_PER_WIDE_INT - 1);\n+\t}\n+      else\n+\t{\n+\t  low = CONST_DOUBLE_LOW (x); \n+\t  high = CONST_DOUBLE_HIGH (x);\n+\t}\n+\n+      /* REAL_VALUE_TARGET_DOUBLE takes the addressing order of the\n+\t target machine.  */\n+      if (WORDS_BIG_ENDIAN)\n+\ti[0] = high, i[1] = low;\n+      else\n+\ti[0] = low, i[1] = high;\n+\n+      r = REAL_VALUE_FROM_TARGET_DOUBLE (i);\n+      return CONST_DOUBLE_FROM_REAL_VALUE (r, mode);\n+    }\n+  else if ((GET_MODE_CLASS (mode) == MODE_INT\n+\t    || GET_MODE_CLASS (mode) == MODE_PARTIAL_INT)\n+\t   && GET_CODE (x) == CONST_DOUBLE\n+\t   && GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+    {\n+      REAL_VALUE_TYPE r;\n+      long i[4];  /* Only the low 32 bits of each 'long' are used.  */\n+      int endian = WORDS_BIG_ENDIAN ? 1 : 0;\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+      switch (GET_MODE (x))\n+\t{\n+\tcase SFmode:\n+\t  REAL_VALUE_TO_TARGET_SINGLE (r, i[endian]);\n+\t  i[1-endian] = 0;\n+\t  break;\n+\tcase DFmode:\n+\t  REAL_VALUE_TO_TARGET_DOUBLE (r, i);\n+\t  break;\n+#if LONG_DOUBLE_TYPE_SIZE == 96\n+\tcase XFmode:\n+#else\n+\tcase TFmode:\n+#endif\n+\t  REAL_VALUE_TO_TARGET_LONG_DOUBLE (r, i);\n+\t  break;\n+\tdefault:\n+\t  abort();\n+\t}\n+\n+      /* Now, pack the 32-bit elements of the array into a CONST_DOUBLE\n+\t and return it.  */\n+#if HOST_BITS_PER_WIDE_INT == 32\n+      return immed_double_const (i[endian], i[1-endian], mode);\n+#else\n+      if (HOST_BITS_PER_WIDE_INT != 64)\n+\tabort();\n+      for (c = 0; c < 4; c++)\n+\ti[c] &= 0xffffffffL;\n+      \n+      return immed_double_const (i[endian*3] | \n+\t\t\t\t (((HOST_WIDE_INT) i[1+endian]) << 32),\n+\t\t\t\t i[2-endian] |\n+\t\t\t\t (((HOST_WIDE_INT) i[3-endian*3]) << 32),\n+\t\t\t\t mode);\n+#endif\n+    }\n+#endif /* ifndef REAL_ARITHMETIC */\n \n   /* Otherwise, we can't do this.  */\n   return 0;"}]}