{"sha": "d65a80fd559aca749b54eb6affd71d2d84f410f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDY1YTgwZmQ1NTlhY2E3NDliNTRlYjZhZmZkNzFkMmQ4NGY0MTBmOA==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2017-01-13T09:34:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-13T09:34:48Z"}, "message": "atree.adb (Allocate_Initialize_Node): A newly created node is no longer marked as Ghost at this level.\n\n2017-01-13  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* atree.adb (Allocate_Initialize_Node): A newly created node is\n\tno longer marked as Ghost at this level.\n\t(Mark_New_Ghost_Node): New routine.\n\t(New_Copy): Mark the copy as Ghost.\n\t(New_Entity): Mark the entity as Ghost.\n\t(New_Node): Mark the node as Ghost.\n\t* einfo.adb (Is_Checked_Ghost_Entity): This attribute can now\n\tapply to unanalyzed entities.\n\t(Is_Ignored_Ghost_Entity): This attribute can now apply to unanalyzed\n\tentities.\n\t(Set_Is_Checked_Ghost_Entity): This attribute now\n\tapplies to all entities as well as unanalyzed entities.\n\t(Set_Is_Ignored_Ghost_Entity): This attribute now applies to\n\tall entities as well as unanalyzed entities.\n\t* expander.adb Add with and use clauses for Ghost.\n\t(Expand): Install and revert the Ghost region associated with the node\n\tbeing expanded.\n\t* exp_ch3.adb (Expand_Freeze_Array_Type): Remove all Ghost-related code.\n\t(Expand_Freeze_Class_Wide_Type): Remoe all Ghost-related code.\n\t(Expand_Freeze_Enumeration_Type): Remove all Ghost-related code.\n\t(Expand_Freeze_Record_Type): Remove all Ghost-related code.\n\t(Freeze_Type): Install and revert the Ghost region associated\n\twith the type being frozen.\n\t* exp_ch5.adb Remove with and use clauses for Ghost.\n\t(Expand_N_Assignment_Statement): Remove all Ghost-related code.\n\t* exp_ch6.adb Remove with and use clauses for Ghost.\n\t(Expand_N_Procedure_Call_Statement): Remove all Ghost-relatd code.\n\t(Expand_N_Subprogram_Body): Remove all Ghost-related code.\n\t* exp_ch7.adb (Build_Invariant_Procedure_Body): Install and revert the\n\tGhost region of the working type.\n\t(Build_Invariant_Procedure_Declaration): Install and revert\n\tthe Ghost region of the working type.\n\t(Expand_N_Package_Body): Remove all Ghost-related code.\n\t* exp_ch8.adb Remove with and use clauses for Ghost.\n\t(Expand_N_Exception_Renaming_Declaration): Remove all Ghost-related\n\tcode.\n\t(Expand_N_Object_Renaming_Declaration): Remove all Ghost-related code.\n\t(Expand_N_Package_Renaming_Declaration): Remove all Ghost-related code.\n\t(Expand_N_Subprogram_Renaming_Declaration): Remove all Ghost-related\n\tcode.\n\t* exp_ch13.adb Remove with and use clauses for Ghost.\n\t(Expand_N_Freeze_Entity): Remove all Ghost-related code.\n\t* exp_disp.adb (Make_DT): Install and revert the Ghost region of\n\tthe tagged type. Move the generation of various entities within\n\tthe Ghost region of the type.\n\t* exp_prag.adb Remove with and use clauses for Ghost.\n\t(Expand_Pragma_Check): Remove all Ghost-related code.\n\t(Expand_Pragma_Contract_Cases): Remove all Ghost-related code.\n\t(Expand_Pragma_Initial_Condition): Remove all Ghost-related code.\n\t(Expand_Pragma_Loop_Variant): Remove all Ghost-related code.\n\t* exp_util.adb (Build_DIC_Procedure_Body): Install\n\tand revert the Ghost region of the working types.\n\t(Build_DIC_Procedure_Declaration): Install and revert the\n\tGhost region of the working type.\n\t(Make_Invariant_Call): Install and revert the Ghost region of the\n\tassociated type.\n\t(Make_Predicate_Call): Reimplemented. Install and revert the\n\tGhost region of the associated type.\n\t* freeze.adb (Freeze_Entity): Install and revert the Ghost region\n\tof the entity being frozen.\n\t(New_Freeze_Node): Removed.\n\t* ghost.adb Remove with and use clauses for Opt.\n\t(Check_Ghost_Completion): Update the parameter profile\n\tand all references to formal parameters.\n\t(Ghost_Entity): Update the comment on usage.\n\t(Install_Ghost_Mode): New routines.\n\t(Is_Ghost_Assignment): New routine.\n\t(Is_Ghost_Declaration): New routine.\n\t(Is_Ghost_Pragma): New routine.\n\t(Is_Ghost_Procedure_Call): New routine.\n\t(Is_Ghost_Renaming): Removed.\n\t(Is_OK_Declaration): Reimplemented.\n\t(Is_OK_Pragma): Reimplemented.\n\t(Is_OK_Statement): Reimplemented.\n\t(Is_Subject_To_Ghost): Update the comment on usage.\n\t(Mark_And_Set_Ghost_Assignment): New routine.\n\t(Mark_And_Set_Ghost_Body): New routine.\n\t(Mark_And_Set_Ghost_Completion): New routine.\n\t(Mark_And_Set_Ghost_Declaration): New routine.\n\t(Mark_And_Set_Ghost_Instantiation): New routine.\n\t(Mark_And_Set_Ghost_Procedure_Call): New routine.\n\t(Mark_Full_View_As_Ghost): Removed.\n\t(Mark_Ghost_Declaration_Or_Body): New routine.\n\t(Mark_Ghost_Pragma): New routine.\n\t(Mark_Ghost_Renaming): New routine.\n\t(Mark_Pragma_As_Ghost): Removed.\n\t(Mark_Renaming_As_Ghost): Removed.\n\t(Propagate_Ignored_Ghost_Code): Update the comment on usage.\n\t(Prune_Node): Freeze nodes no longer need special pruning, they\n\tare processed by the general ignored Ghost code mechanism.\n\t(Restore_Ghost_Mode): New routine.\n\t(Set_Ghost_Mode): Reimplemented.\n\t(Set_Ghost_Mode_From_Entity): Removed.\n\t* ghost.ads Add with and use clauses for Ghost.\n\t(Check_Ghost_Completion): Update the parameter profile\n\talong with the comment on usage.\n\t(Install_Ghost_Mode): New routine.\n\t(Is_Ghost_Assignment): New routine.\n\t(Is_Ghost_Declaration): New routine.\n\t(Is_Ghost_Pragma): New routine.\n\t(Is_Ghost_Procedure_Call): New routine.\n\t(Mark_And_Set_Ghost_Assignment): New routine.\n\t(Mark_And_Set_Ghost_Body): New routine.\n\t(Mark_And_Set_Ghost_Completion): New routine.\n\t(Mark_And_Set_Ghost_Declaration): New routine.\n\t(Mark_And_Set_Ghost_Instantiation): New routine.\n\t(Mark_And_Set_Ghost_Procedure_Call): New routine.\n\t(Mark_Full_View_As_Ghost): Removed.\n\t(Mark_Ghost_Pragma): New routine.\n\t(Mark_Ghost_Renaming): New routine.\n\t(Mark_Pragma_As_Ghost): Removed.\n\t(Mark_Renaming_As_Ghost): Removed.\n\t(Restore_Ghost_Mode): New routine.\n\t(Set_Ghost_Mode): Redefined.\n\t(Set_Ghost_Mode_From_Entity): Removed.\n\t* sem.adb (Analyze): Install and revert the Ghost region of the\n\tnode being analyzed.\n\t(Do_Analyze): Change the way a clean Ghost\n\tregion is installed and reverted.\n\t* sem_ch3.adb (Analyze_Full_Type_Declaration): Remove\n\tall Ghost-related code.\n\t(Analyze_Incomplete_Type_Decl): Remove all Ghost-related code.\n\t(Analyze_Number_Declaration): Remove all Ghost-related code.\n\t(Analyze_Object_Declaration): Install and revert the Ghost region of\n\ta deferred object declaration's completion.\n\t(Array_Type_Declaration): Remove all Ghost-related code.\n\t(Build_Derived_Type): Update the comment on\n\tthe propagation of Ghost attributes from a parent to a derived type.\n\t(Derive_Subprogram): Remove all Ghost-related code.\n\t(Make_Class_Wide_Type): Remove all Ghost-related code.\n\t(Make_Implicit_Base): Remove all Ghost-related code.\n\t(Process_Full_View): Install and revert the Ghost region of\n\tthe partial view.  There is no longer need to check the Ghost\n\tcompletion here.\n\t* sem_ch5.adb (Analyze_Assignment): Install and revert the Ghost\n\tregion of the left hand side.\n\t* sem_ch6.adb (Analyze_Abstract_Subprogram_Declaration): Remove\n\tall Ghost-related code.\n\t(Analyze_Expression_Function): Remove all Ghost-related code.\n\t(Analyze_Generic_Subprogram_Body): Remove all Ghost-related code.\n\t(Analyze_Procedure_Call): Install and revert the Ghost region of\n\tthe procedure being called.\n\t(Analyze_Subprogram_Body_Helper): Install and revert the Ghost\n\tregion of the spec or body.\n\t(Analyze_Subprogram_Declaration): Remove all Ghost-related code.\n\t(Build_Subprogram_Declaration): Remove all Ghost-related code.\n\t(Find_Corresponding_Spec): Remove all Ghost-related code.\n\t(Process_Formals): Remove all Ghost-related code.\n\t* sem_ch7.adb (Analyze_Package_Body_Helper): Install and revert\n\tthe Ghost region of the spec.\n\t(Analyze_Package_Declaration): Remove all Ghost-related code.\n\t* sem_ch8.adb (Analyze_Exception_Renaming): Mark a renaming as\n\tGhost when it aliases a Ghost entity.\n\t(Analyze_Generic_Renaming): Mark a renaming as Ghost when it aliases\n\ta Ghost entity.\n\t(Analyze_Object_Renaming): Mark a renaming as Ghost when\n\tit aliases a Ghost entity.\n\t(Analyze_Package_Renaming): Mark a renaming as Ghost when it aliases\n\ta Ghost entity.\n\t(Analyze_Subprogram_Renaming): Mark a renaming as Ghost when it\n\taliases a Ghost entity.\n\t* sem_ch11.adb Remove with and use clauses for Ghost.\n\t(Analyze_Exception_Declaration): Remove all Ghost-related code.\n\t* sem_ch12.adb (Analyze_Generic_Package_Declaration): Remove all\n\tGhost-related code.\n\t(Analyze_Generic_Subprogram_Declaration): Remove all Ghost-related\n\tcode.\n\t(Analyze_Package_Instantiation): Install and revert the Ghost region\n\tof the package instantiation.\n\t(Analyze_Subprogram_Instantiation): Install\n\tand revert the Ghost region of the subprogram instantiation.\n\t(Instantiate_Package_Body): Code clean up. Install and revert the\n\tGhost region of the package body.\n\t(Instantiate_Subprogram_Body): Code clean up. Install and revert the\n\tGhost region of the subprogram body.\n\t* sem_ch13.adb (Build_Predicate_Functions): Install\n\tand revert the Ghost region of the related type.\n\t(Build_Predicate_Function_Declaration): Code clean up. Install\n\tand rever the Ghost region of the related type.\n\t* sem_prag.adb (Analyze_Contract_Cases_In_Decl_Part):\n\tInstall and revert the Ghost region of the pragma.\n\t(Analyze_Initial_Condition_In_Decl_Part): Install and revert the\n\tGhost region of the pragma.\n\t(Analyze_Pragma): Install and revert the Ghost region of various\n\tpragmas.  Mark a pragma as Ghost when it is related to a Ghost entity\n\tor encloses a Ghost entity.\n\t(Analyze_Pre_Post_Condition): Install and revert the Ghost\n\tregion of the pragma.\n\t(Analyze_Pre_Post_Condition_In_Decl_Part): Install and revert the\n\tGhost region of the pragma.\n\t* sem_res.adb (Resolve): Remove all Ghost-related code.\n\t* sem_util.adb (Is_Declaration): Reimplemented.\n\t(Is_Declaration_Other_Than_Renaming): New routine.\n\t* sem_util.ads (Is_Declaration_Other_Than_Renaming): New routine.\n\t* sinfo.adb (Is_Checked_Ghost_Pragma): New routine.\n\t(Is_Ghost_Pragma): Removed.\n\t(Is_Ignored_Ghost_Pragma): New routine.\n\t(Set_Is_Checked_Ghost_Pragma): New routine.\n\t(Set_Is_Ghost_Pragma): Removed.\n\t(Set_Is_Ignored_Ghost_Pragma): New routine.\n\t* sinfo.ads: Update the documentation on Ghost mode and\n\tGhost regions.\tNew attributes Is_Checked_Ghost_Pragma\n\tand Is_Ignored_Ghost_Pragma along with usages in nodes.\n\tRemove attribute Is_Ghost_Pragma along with usages in nodes.\n\t(Is_Checked_Ghost_Pragma): New routine along with pragma Inline.\n\t(Is_Ghost_Pragma): Removed along with pragma Inline.\n\t(Is_Ignored_Ghost_Pragma): New routine along with pragma Inline.\n\t(Set_Is_Checked_Ghost_Pragma): New routine along with pragma Inline.\n\t(Set_Is_Ghost_Pragma): Removed along with pragma Inline.\n\t(Set_Is_Ignored_Ghost_Pragma): New routine along with pragma Inline.\n\nFrom-SVN: r244395", "tree": {"sha": "5dd4560e392930b55539c9078451e000762bf3ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5dd4560e392930b55539c9078451e000762bf3ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d65a80fd559aca749b54eb6affd71d2d84f410f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d65a80fd559aca749b54eb6affd71d2d84f410f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d65a80fd559aca749b54eb6affd71d2d84f410f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d65a80fd559aca749b54eb6affd71d2d84f410f8/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3c3b9090f86bef51e5b023616d1cfdcfa39f82b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c3b9090f86bef51e5b023616d1cfdcfa39f82b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c3b9090f86bef51e5b023616d1cfdcfa39f82b7"}], "stats": {"total": 3184, "additions": 1752, "deletions": 1432}, "files": [{"sha": "9c04b307d1e9f7514aa82c67a731b11186655f93", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -1,3 +1,216 @@\n+2017-01-13  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* atree.adb (Allocate_Initialize_Node): A newly created node is\n+\tno longer marked as Ghost at this level.\n+\t(Mark_New_Ghost_Node): New routine.\n+\t(New_Copy): Mark the copy as Ghost.\n+\t(New_Entity): Mark the entity as Ghost.\n+\t(New_Node): Mark the node as Ghost.\n+\t* einfo.adb (Is_Checked_Ghost_Entity): This attribute can now\n+\tapply to unanalyzed entities.\n+\t(Is_Ignored_Ghost_Entity): This attribute can now apply to unanalyzed\n+\tentities.\n+\t(Set_Is_Checked_Ghost_Entity): This attribute now\n+\tapplies to all entities as well as unanalyzed entities.\n+\t(Set_Is_Ignored_Ghost_Entity): This attribute now applies to\n+\tall entities as well as unanalyzed entities.\n+\t* expander.adb Add with and use clauses for Ghost.\n+\t(Expand): Install and revert the Ghost region associated with the node\n+\tbeing expanded.\n+\t* exp_ch3.adb (Expand_Freeze_Array_Type): Remove all Ghost-related code.\n+\t(Expand_Freeze_Class_Wide_Type): Remoe all Ghost-related code.\n+\t(Expand_Freeze_Enumeration_Type): Remove all Ghost-related code.\n+\t(Expand_Freeze_Record_Type): Remove all Ghost-related code.\n+\t(Freeze_Type): Install and revert the Ghost region associated\n+\twith the type being frozen.\n+\t* exp_ch5.adb Remove with and use clauses for Ghost.\n+\t(Expand_N_Assignment_Statement): Remove all Ghost-related code.\n+\t* exp_ch6.adb Remove with and use clauses for Ghost.\n+\t(Expand_N_Procedure_Call_Statement): Remove all Ghost-relatd code.\n+\t(Expand_N_Subprogram_Body): Remove all Ghost-related code.\n+\t* exp_ch7.adb (Build_Invariant_Procedure_Body): Install and revert the\n+\tGhost region of the working type.\n+\t(Build_Invariant_Procedure_Declaration): Install and revert\n+\tthe Ghost region of the working type.\n+\t(Expand_N_Package_Body): Remove all Ghost-related code.\n+\t* exp_ch8.adb Remove with and use clauses for Ghost.\n+\t(Expand_N_Exception_Renaming_Declaration): Remove all Ghost-related\n+\tcode.\n+\t(Expand_N_Object_Renaming_Declaration): Remove all Ghost-related code.\n+\t(Expand_N_Package_Renaming_Declaration): Remove all Ghost-related code.\n+\t(Expand_N_Subprogram_Renaming_Declaration): Remove all Ghost-related\n+\tcode.\n+\t* exp_ch13.adb Remove with and use clauses for Ghost.\n+\t(Expand_N_Freeze_Entity): Remove all Ghost-related code.\n+\t* exp_disp.adb (Make_DT): Install and revert the Ghost region of\n+\tthe tagged type. Move the generation of various entities within\n+\tthe Ghost region of the type.\n+\t* exp_prag.adb Remove with and use clauses for Ghost.\n+\t(Expand_Pragma_Check): Remove all Ghost-related code.\n+\t(Expand_Pragma_Contract_Cases): Remove all Ghost-related code.\n+\t(Expand_Pragma_Initial_Condition): Remove all Ghost-related code.\n+\t(Expand_Pragma_Loop_Variant): Remove all Ghost-related code.\n+\t* exp_util.adb (Build_DIC_Procedure_Body): Install\n+\tand revert the Ghost region of the working types.\n+\t(Build_DIC_Procedure_Declaration): Install and revert the\n+\tGhost region of the working type.\n+\t(Make_Invariant_Call): Install and revert the Ghost region of the\n+\tassociated type.\n+\t(Make_Predicate_Call): Reimplemented. Install and revert the\n+\tGhost region of the associated type.\n+\t* freeze.adb (Freeze_Entity): Install and revert the Ghost region\n+\tof the entity being frozen.\n+\t(New_Freeze_Node): Removed.\n+\t* ghost.adb Remove with and use clauses for Opt.\n+\t(Check_Ghost_Completion): Update the parameter profile\n+\tand all references to formal parameters.\n+\t(Ghost_Entity): Update the comment on usage.\n+\t(Install_Ghost_Mode): New routines.\n+\t(Is_Ghost_Assignment): New routine.\n+\t(Is_Ghost_Declaration): New routine.\n+\t(Is_Ghost_Pragma): New routine.\n+\t(Is_Ghost_Procedure_Call): New routine.\n+\t(Is_Ghost_Renaming): Removed.\n+\t(Is_OK_Declaration): Reimplemented.\n+\t(Is_OK_Pragma): Reimplemented.\n+\t(Is_OK_Statement): Reimplemented.\n+\t(Is_Subject_To_Ghost): Update the comment on usage.\n+\t(Mark_And_Set_Ghost_Assignment): New routine.\n+\t(Mark_And_Set_Ghost_Body): New routine.\n+\t(Mark_And_Set_Ghost_Completion): New routine.\n+\t(Mark_And_Set_Ghost_Declaration): New routine.\n+\t(Mark_And_Set_Ghost_Instantiation): New routine.\n+\t(Mark_And_Set_Ghost_Procedure_Call): New routine.\n+\t(Mark_Full_View_As_Ghost): Removed.\n+\t(Mark_Ghost_Declaration_Or_Body): New routine.\n+\t(Mark_Ghost_Pragma): New routine.\n+\t(Mark_Ghost_Renaming): New routine.\n+\t(Mark_Pragma_As_Ghost): Removed.\n+\t(Mark_Renaming_As_Ghost): Removed.\n+\t(Propagate_Ignored_Ghost_Code): Update the comment on usage.\n+\t(Prune_Node): Freeze nodes no longer need special pruning, they\n+\tare processed by the general ignored Ghost code mechanism.\n+\t(Restore_Ghost_Mode): New routine.\n+\t(Set_Ghost_Mode): Reimplemented.\n+\t(Set_Ghost_Mode_From_Entity): Removed.\n+\t* ghost.ads Add with and use clauses for Ghost.\n+\t(Check_Ghost_Completion): Update the parameter profile\n+\talong with the comment on usage.\n+\t(Install_Ghost_Mode): New routine.\n+\t(Is_Ghost_Assignment): New routine.\n+\t(Is_Ghost_Declaration): New routine.\n+\t(Is_Ghost_Pragma): New routine.\n+\t(Is_Ghost_Procedure_Call): New routine.\n+\t(Mark_And_Set_Ghost_Assignment): New routine.\n+\t(Mark_And_Set_Ghost_Body): New routine.\n+\t(Mark_And_Set_Ghost_Completion): New routine.\n+\t(Mark_And_Set_Ghost_Declaration): New routine.\n+\t(Mark_And_Set_Ghost_Instantiation): New routine.\n+\t(Mark_And_Set_Ghost_Procedure_Call): New routine.\n+\t(Mark_Full_View_As_Ghost): Removed.\n+\t(Mark_Ghost_Pragma): New routine.\n+\t(Mark_Ghost_Renaming): New routine.\n+\t(Mark_Pragma_As_Ghost): Removed.\n+\t(Mark_Renaming_As_Ghost): Removed.\n+\t(Restore_Ghost_Mode): New routine.\n+\t(Set_Ghost_Mode): Redefined.\n+\t(Set_Ghost_Mode_From_Entity): Removed.\n+\t* sem.adb (Analyze): Install and revert the Ghost region of the\n+\tnode being analyzed.\n+\t(Do_Analyze): Change the way a clean Ghost\n+\tregion is installed and reverted.\n+\t* sem_ch3.adb (Analyze_Full_Type_Declaration): Remove\n+\tall Ghost-related code.\n+\t(Analyze_Incomplete_Type_Decl): Remove all Ghost-related code.\n+\t(Analyze_Number_Declaration): Remove all Ghost-related code.\n+\t(Analyze_Object_Declaration): Install and revert the Ghost region of\n+\ta deferred object declaration's completion.\n+\t(Array_Type_Declaration): Remove all Ghost-related code.\n+\t(Build_Derived_Type): Update the comment on\n+\tthe propagation of Ghost attributes from a parent to a derived type.\n+\t(Derive_Subprogram): Remove all Ghost-related code.\n+\t(Make_Class_Wide_Type): Remove all Ghost-related code.\n+\t(Make_Implicit_Base): Remove all Ghost-related code.\n+\t(Process_Full_View): Install and revert the Ghost region of\n+\tthe partial view.  There is no longer need to check the Ghost\n+\tcompletion here.\n+\t* sem_ch5.adb (Analyze_Assignment): Install and revert the Ghost\n+\tregion of the left hand side.\n+\t* sem_ch6.adb (Analyze_Abstract_Subprogram_Declaration): Remove\n+\tall Ghost-related code.\n+\t(Analyze_Expression_Function): Remove all Ghost-related code.\n+\t(Analyze_Generic_Subprogram_Body): Remove all Ghost-related code.\n+\t(Analyze_Procedure_Call): Install and revert the Ghost region of\n+\tthe procedure being called.\n+\t(Analyze_Subprogram_Body_Helper): Install and revert the Ghost\n+\tregion of the spec or body.\n+\t(Analyze_Subprogram_Declaration): Remove all Ghost-related code.\n+\t(Build_Subprogram_Declaration): Remove all Ghost-related code.\n+\t(Find_Corresponding_Spec): Remove all Ghost-related code.\n+\t(Process_Formals): Remove all Ghost-related code.\n+\t* sem_ch7.adb (Analyze_Package_Body_Helper): Install and revert\n+\tthe Ghost region of the spec.\n+\t(Analyze_Package_Declaration): Remove all Ghost-related code.\n+\t* sem_ch8.adb (Analyze_Exception_Renaming): Mark a renaming as\n+\tGhost when it aliases a Ghost entity.\n+\t(Analyze_Generic_Renaming): Mark a renaming as Ghost when it aliases\n+\ta Ghost entity.\n+\t(Analyze_Object_Renaming): Mark a renaming as Ghost when\n+\tit aliases a Ghost entity.\n+\t(Analyze_Package_Renaming): Mark a renaming as Ghost when it aliases\n+\ta Ghost entity.\n+\t(Analyze_Subprogram_Renaming): Mark a renaming as Ghost when it\n+\taliases a Ghost entity.\n+\t* sem_ch11.adb Remove with and use clauses for Ghost.\n+\t(Analyze_Exception_Declaration): Remove all Ghost-related code.\n+\t* sem_ch12.adb (Analyze_Generic_Package_Declaration): Remove all\n+\tGhost-related code.\n+\t(Analyze_Generic_Subprogram_Declaration): Remove all Ghost-related\n+\tcode.\n+\t(Analyze_Package_Instantiation): Install and revert the Ghost region\n+\tof the package instantiation.\n+\t(Analyze_Subprogram_Instantiation): Install\n+\tand revert the Ghost region of the subprogram instantiation.\n+\t(Instantiate_Package_Body): Code clean up. Install and revert the\n+\tGhost region of the package body.\n+\t(Instantiate_Subprogram_Body): Code clean up. Install and revert the\n+\tGhost region of the subprogram body.\n+\t* sem_ch13.adb (Build_Predicate_Functions): Install\n+\tand revert the Ghost region of the related type.\n+\t(Build_Predicate_Function_Declaration): Code clean up. Install\n+\tand rever the Ghost region of the related type.\n+\t* sem_prag.adb (Analyze_Contract_Cases_In_Decl_Part):\n+\tInstall and revert the Ghost region of the pragma.\n+\t(Analyze_Initial_Condition_In_Decl_Part): Install and revert the\n+\tGhost region of the pragma.\n+\t(Analyze_Pragma): Install and revert the Ghost region of various\n+\tpragmas.  Mark a pragma as Ghost when it is related to a Ghost entity\n+\tor encloses a Ghost entity.\n+\t(Analyze_Pre_Post_Condition): Install and revert the Ghost\n+\tregion of the pragma.\n+\t(Analyze_Pre_Post_Condition_In_Decl_Part): Install and revert the\n+\tGhost region of the pragma.\n+\t* sem_res.adb (Resolve): Remove all Ghost-related code.\n+\t* sem_util.adb (Is_Declaration): Reimplemented.\n+\t(Is_Declaration_Other_Than_Renaming): New routine.\n+\t* sem_util.ads (Is_Declaration_Other_Than_Renaming): New routine.\n+\t* sinfo.adb (Is_Checked_Ghost_Pragma): New routine.\n+\t(Is_Ghost_Pragma): Removed.\n+\t(Is_Ignored_Ghost_Pragma): New routine.\n+\t(Set_Is_Checked_Ghost_Pragma): New routine.\n+\t(Set_Is_Ghost_Pragma): Removed.\n+\t(Set_Is_Ignored_Ghost_Pragma): New routine.\n+\t* sinfo.ads: Update the documentation on Ghost mode and\n+\tGhost regions.\tNew attributes Is_Checked_Ghost_Pragma\n+\tand Is_Ignored_Ghost_Pragma along with usages in nodes.\n+\tRemove attribute Is_Ghost_Pragma along with usages in nodes.\n+\t(Is_Checked_Ghost_Pragma): New routine along with pragma Inline.\n+\t(Is_Ghost_Pragma): Removed along with pragma Inline.\n+\t(Is_Ignored_Ghost_Pragma): New routine along with pragma Inline.\n+\t(Set_Is_Checked_Ghost_Pragma): New routine along with pragma Inline.\n+\t(Set_Is_Ghost_Pragma): Removed along with pragma Inline.\n+\t(Set_Is_Ignored_Ghost_Pragma): New routine along with pragma Inline.\n+\n 2017-01-12  Tristan Gingold  <gingold@adacore.com>\n \n \t* s-mmap.ads, s-mmap.adb, s-mmosin-unix.ads, s-mmosin-unix.adb,"}, {"sha": "1444fcb6dfefc0a712d08b2f341c8d53fb5d0741", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 42, "deletions": 12, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -549,16 +549,20 @@ package body Atree is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Fix_Parents (Ref_Node, Fix_Node : Node_Id);\n-   --  Fixup parent pointers for the syntactic children of Fix_Node after\n-   --  a copy, setting them to Fix_Node when they pointed to Ref_Node.\n-\n    function Allocate_Initialize_Node\n      (Src            : Node_Id;\n       With_Extension : Boolean) return Node_Id;\n    --  Allocate a new node or node extension. If Src is not empty, the\n    --  information for the newly-allocated node is copied from it.\n \n+   procedure Fix_Parents (Ref_Node, Fix_Node : Node_Id);\n+   --  Fixup parent pointers for the syntactic children of Fix_Node after a\n+   --  copy, setting them to Fix_Node when they pointed to Ref_Node.\n+\n+   procedure Mark_New_Ghost_Node (N : Node_Or_Entity_Id);\n+   --  Mark arbitrary node or entity N as Ghost when it is created within a\n+   --  Ghost region.\n+\n    ------------------------------\n    -- Allocate_Initialize_Node --\n    ------------------------------\n@@ -594,13 +598,6 @@ package body Atree is\n          Node_Count := Node_Count + 1;\n       end if;\n \n-      --  Mark the node as ignored Ghost if it is created in an ignored Ghost\n-      --  region.\n-\n-      if Ghost_Mode = Ignore then\n-         Set_Is_Ignored_Ghost_Node (New_Id);\n-      end if;\n-\n       --  Clear Check_Actuals to False\n \n       Set_Check_Actuals (New_Id, False);\n@@ -1432,7 +1429,6 @@ package body Atree is\n    -----------------\n \n    procedure Fix_Parents (Ref_Node, Fix_Node : Node_Id) is\n-\n       procedure Fix_Parent (Field : Union_Id);\n       --  Fixup one parent pointer. Field is checked to see if it points to\n       --  a node, list, or element list that has a parent that points to\n@@ -1590,6 +1586,28 @@ package body Atree is\n       Orig_Nodes.Release;\n    end Lock;\n \n+   -------------------------\n+   -- Mark_New_Ghost_Node --\n+   -------------------------\n+\n+   procedure Mark_New_Ghost_Node (N : Node_Or_Entity_Id) is\n+   begin\n+      --  The Ghost node is created within a Ghost region\n+\n+      if Ghost_Mode = Check then\n+         if Nkind (N) in N_Entity then\n+            Set_Is_Checked_Ghost_Entity (N);\n+         end if;\n+\n+      elsif Ghost_Mode = Ignore then\n+         if Nkind (N) in N_Entity then\n+            Set_Is_Ignored_Ghost_Entity (N);\n+         end if;\n+\n+         Set_Is_Ignored_Ghost_Node (N);\n+      end if;\n+   end Mark_New_Ghost_Node;\n+\n    ----------------------------\n    -- Mark_Rewrite_Insertion --\n    ----------------------------\n@@ -1630,6 +1648,10 @@ package body Atree is\n          --  aspects if this is required for the particular situation.\n \n          Set_Has_Aspects (New_Id, False);\n+\n+         --  Mark the copy as Ghost depending on the current Ghost region\n+\n+         Mark_New_Ghost_Node (New_Id);\n       end if;\n \n       return New_Id;\n@@ -1662,6 +1684,10 @@ package body Atree is\n       Nodes.Table (Ent).Sloc   := New_Sloc;\n       pragma Debug (New_Node_Debugging_Output (Ent));\n \n+      --  Mark the new entity as Ghost depending on the current Ghost region\n+\n+      Mark_New_Ghost_Node (Ent);\n+\n       return Ent;\n    end New_Entity;\n \n@@ -1690,6 +1716,10 @@ package body Atree is\n          Current_Error_Node := Nod;\n       end if;\n \n+      --  Mark the new node as Ghost depending on the current Ghost region\n+\n+      Mark_New_Ghost_Node (Nod);\n+\n       return Nod;\n    end New_Node;\n "}, {"sha": "c2146756843bc06624126d9c570aaab82e04275b", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 12, "deletions": 28, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -2093,7 +2093,10 @@ package body Einfo is\n \n    function Is_Checked_Ghost_Entity (Id : E) return B is\n    begin\n-      pragma Assert (Nkind (Id) in N_Entity);\n+      --  Allow this attribute to appear on non-analyzed entities\n+\n+      pragma Assert (Nkind (Id) in N_Entity\n+        or else Ekind (Id) = E_Void);\n       return Flag277 (Id);\n    end Is_Checked_Ghost_Entity;\n \n@@ -2280,7 +2283,10 @@ package body Einfo is\n \n    function Is_Ignored_Ghost_Entity (Id : E) return B is\n    begin\n-      pragma Assert (Nkind (Id) in N_Entity);\n+      --  Allow this attribute to appear on non-analyzed entities\n+\n+      pragma Assert (Nkind (Id) in N_Entity\n+        or else Ekind (Id) = E_Void);\n       return Flag278 (Id);\n    end Is_Ignored_Ghost_Entity;\n \n@@ -5161,20 +5167,9 @@ package body Einfo is\n \n    procedure Set_Is_Checked_Ghost_Entity (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Is_Formal (Id)\n-        or else Is_Object (Id)\n-        or else Is_Package_Or_Generic_Package (Id)\n-        or else Is_Subprogram_Or_Generic_Subprogram (Id)\n-        or else Is_Type (Id)\n-        or else Ekind (Id) = E_Abstract_State\n-        or else Ekind (Id) = E_Component\n-        or else Ekind (Id) = E_Discriminant\n-        or else Ekind (Id) = E_Exception\n-        or else Ekind (Id) = E_Package_Body\n-        or else Ekind (Id) = E_Subprogram_Body\n-\n-        --  Allow this attribute to appear on non-analyzed entities\n+      --  Allow this attribute to appear on non-analyzed entities\n \n+      pragma Assert (Nkind (Id) in N_Entity\n         or else Ekind (Id) = E_Void);\n       Set_Flag277 (Id, V);\n    end Set_Is_Checked_Ghost_Entity;\n@@ -5377,20 +5372,9 @@ package body Einfo is\n \n    procedure Set_Is_Ignored_Ghost_Entity (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Is_Formal (Id)\n-        or else Is_Object (Id)\n-        or else Is_Package_Or_Generic_Package (Id)\n-        or else Is_Subprogram_Or_Generic_Subprogram (Id)\n-        or else Is_Type (Id)\n-        or else Ekind (Id) = E_Abstract_State\n-        or else Ekind (Id) = E_Component\n-        or else Ekind (Id) = E_Discriminant\n-        or else Ekind (Id) = E_Exception\n-        or else Ekind (Id) = E_Package_Body\n-        or else Ekind (Id) = E_Subprogram_Body\n-\n-        --  Allow this attribute to appear on non-analyzed entities\n+      --  Allow this attribute to appear on non-analyzed entities\n \n+      pragma Assert (Nkind (Id) in N_Entity\n         or else Ekind (Id) = E_Void);\n       Set_Flag278 (Id, V);\n    end Set_Is_Ignored_Ghost_Entity;"}, {"sha": "1c170e210b42b50bc6ab765b3ff85617fa5e5e46", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -32,7 +32,6 @@ with Exp_Imgv; use Exp_Imgv;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n-with Ghost;    use Ghost;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n@@ -345,10 +344,8 @@ package body Exp_Ch13 is\n             Insert_Action (N,\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => Temp_Id,\n-                Object_Definition =>\n-                  New_Occurrence_Of (Expr_Typ, Loc),\n-                Expression =>\n-                  Relocate_Node (Expr)));\n+                Object_Definition   => New_Occurrence_Of (Expr_Typ, Loc),\n+                Expression          => Relocate_Node (Expr)));\n \n             New_Expr := New_Occurrence_Of (Temp_Id, Loc);\n             Set_Etype (New_Expr, Expr_Typ);\n@@ -371,19 +368,13 @@ package body Exp_Ch13 is\n    procedure Expand_N_Freeze_Entity (N : Node_Id) is\n       E : constant Entity_Id := Entity (N);\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n       Decl           : Node_Id;\n       Delete         : Boolean := False;\n       E_Scope        : Entity_Id;\n       In_Other_Scope : Boolean;\n       In_Outer_Scope : Boolean;\n \n    begin\n-      --  Ensure that all freezing activities are properly flagged as Ghost\n-\n-      Set_Ghost_Mode_From_Entity (E);\n-\n       --  If there are delayed aspect specifications, we insert them just\n       --  before the freeze node. They are already analyzed so we don't need\n       --  to reanalyze them (they were analyzed before the type was frozen),\n@@ -451,14 +442,12 @@ package body Exp_Ch13 is\n          --  statement, insert them back into the tree now.\n \n          Explode_Initialization_Compound_Statement (E);\n-         Ghost_Mode := Save_Ghost_Mode;\n          return;\n \n       --  Only other items requiring any front end action are types and\n       --  subprograms.\n \n       elsif not Is_Type (E) and then not Is_Subprogram (E) then\n-         Ghost_Mode := Save_Ghost_Mode;\n          return;\n       end if;\n \n@@ -470,7 +459,6 @@ package body Exp_Ch13 is\n \n       if No (E_Scope) then\n          Check_Error_Detected;\n-         Ghost_Mode := Save_Ghost_Mode;\n          return;\n       end if;\n \n@@ -688,7 +676,6 @@ package body Exp_Ch13 is\n       --  whether we are inside a (possibly nested) call to this procedure.\n \n       Inside_Freezing_Actions := Inside_Freezing_Actions - 1;\n-      Ghost_Mode := Save_Ghost_Mode;\n    end Expand_N_Freeze_Entity;\n \n    -------------------------------------------"}, {"sha": "93ae83fd23340ac76f415f3f6809f1ac23bbf22b", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 4, "deletions": 37, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -4361,13 +4361,7 @@ package body Exp_Ch3 is\n       Base     : constant Entity_Id := Base_Type (Typ);\n       Comp_Typ : constant Entity_Id := Component_Type (Typ);\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n    begin\n-      --  Ensure that all freezing activities are properly flagged as Ghost\n-\n-      Set_Ghost_Mode_From_Entity (Typ);\n-\n       if not Is_Bit_Packed_Array (Typ) then\n \n          --  If the component contains tasks, so does the array type. This may\n@@ -4435,8 +4429,6 @@ package body Exp_Ch3 is\n       then\n          Build_Array_Init_Proc (Base, N);\n       end if;\n-\n-      Ghost_Mode := Save_Ghost_Mode;\n    end Expand_Freeze_Array_Type;\n \n    -----------------------------------\n@@ -4477,8 +4469,6 @@ package body Exp_Ch3 is\n       Typ  : constant Entity_Id := Entity (N);\n       Root : constant Entity_Id := Root_Type (Typ);\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n    --  Start of processing for Expand_Freeze_Class_Wide_Type\n \n    begin\n@@ -4511,15 +4501,10 @@ package body Exp_Ch3 is\n          return;\n       end if;\n \n-      --  Ensure that all freezing activities are properly flagged as Ghost\n-\n-      Set_Ghost_Mode_From_Entity (Typ);\n-\n       --  Create the body of TSS primitive Finalize_Address. This automatically\n       --  sets the TSS entry for the class-wide type.\n \n       Make_Finalize_Address_Body (Typ);\n-      Ghost_Mode := Save_Ghost_Mode;\n    end Expand_Freeze_Class_Wide_Type;\n \n    ------------------------------------\n@@ -4530,8 +4515,6 @@ package body Exp_Ch3 is\n       Typ : constant Entity_Id  := Entity (N);\n       Loc : constant Source_Ptr := Sloc (Typ);\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n       Arr           : Entity_Id;\n       Ent           : Entity_Id;\n       Fent          : Entity_Id;\n@@ -4546,10 +4529,6 @@ package body Exp_Ch3 is\n       pragma Warnings (Off, Func);\n \n    begin\n-      --  Ensure that all freezing activities are properly flagged as Ghost\n-\n-      Set_Ghost_Mode_From_Entity (Typ);\n-\n       --  Various optimizations possible if given representation is contiguous\n \n       Is_Contiguous := True;\n@@ -4832,11 +4811,8 @@ package body Exp_Ch3 is\n          Set_Debug_Info_Off (Fent);\n       end if;\n \n-      Ghost_Mode := Save_Ghost_Mode;\n-\n    exception\n       when RE_Not_Available =>\n-         Ghost_Mode := Save_Ghost_Mode;\n          return;\n    end Expand_Freeze_Enumeration_Type;\n \n@@ -4848,8 +4824,6 @@ package body Exp_Ch3 is\n       Typ      : constant Node_Id := Entity (N);\n       Typ_Decl : constant Node_Id := Parent (Typ);\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n       Comp        : Entity_Id;\n       Comp_Typ    : Entity_Id;\n       Predef_List : List_Id;\n@@ -4867,10 +4841,6 @@ package body Exp_Ch3 is\n    --  Start of processing for Expand_Freeze_Record_Type\n \n    begin\n-      --  Ensure that all freezing activities are properly flagged as Ghost\n-\n-      Set_Ghost_Mode_From_Entity (Typ);\n-\n       --  Build discriminant checking functions if not a derived type (for\n       --  derived types that are not tagged types, always use the discriminant\n       --  checking functions of the parent type). However, for untagged types\n@@ -5291,8 +5261,6 @@ package body Exp_Ch3 is\n             end loop;\n          end;\n       end if;\n-\n-      Ghost_Mode := Save_Ghost_Mode;\n    end Expand_Freeze_Record_Type;\n \n    ------------------------------------\n@@ -7135,18 +7103,17 @@ package body Exp_Ch3 is\n       --  Local variables\n \n       Def_Id : constant Entity_Id := Entity (N);\n+      Mode   : Ghost_Mode_Type;\n       Result : Boolean := False;\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n    --  Start of processing for Freeze_Type\n \n    begin\n       --  The type being frozen may be subject to pragma Ghost. Set the mode\n       --  now to ensure that any nodes generated during freezing are properly\n       --  marked as Ghost.\n \n-      Set_Ghost_Mode (N, Def_Id);\n+      Set_Ghost_Mode (Def_Id, Mode);\n \n       --  Process any remote access-to-class-wide types designating the type\n       --  being frozen.\n@@ -7474,12 +7441,12 @@ package body Exp_Ch3 is\n          Build_Invariant_Procedure_Body (Def_Id);\n       end if;\n \n-      Ghost_Mode := Save_Ghost_Mode;\n+      Restore_Ghost_Mode (Mode);\n       return Result;\n \n    exception\n       when RE_Not_Available =>\n-         Ghost_Mode := Save_Ghost_Mode;\n+         Restore_Ghost_Mode (Mode);\n          return False;\n    end Freeze_Type;\n "}, {"sha": "ffe4b5cfbdc67dfd43e74e0f4ad66da5308b6a2f", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -38,7 +38,6 @@ with Exp_Dbug; use Exp_Dbug;\n with Exp_Pakd; use Exp_Pakd;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n-with Ghost;    use Ghost;\n with Inline;   use Inline;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n@@ -1613,15 +1612,7 @@ package body Exp_Ch5 is\n       Typ  : constant Entity_Id  := Underlying_Type (Etype (Lhs));\n       Exp  : Node_Id;\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n    begin\n-      --  The assignment statement is Ghost when the left hand side is Ghost.\n-      --  Set the mode now to ensure that any nodes generated during expansion\n-      --  are properly marked as Ghost.\n-\n-      Set_Ghost_Mode (N);\n-\n       --  Special case to check right away, if the Componentwise_Assignment\n       --  flag is set, this is a reanalysis from the expansion of the primitive\n       --  assignment procedure for a tagged type, and all we need to do is to\n@@ -1631,7 +1622,6 @@ package body Exp_Ch5 is\n \n       if Componentwise_Assignment (N) then\n          Expand_Assign_Record (N);\n-         Ghost_Mode := Save_Ghost_Mode;\n          return;\n       end if;\n \n@@ -1723,7 +1713,6 @@ package body Exp_Ch5 is\n                Rewrite (N, Call);\n                Analyze (N);\n \n-               Ghost_Mode := Save_Ghost_Mode;\n                return;\n             end if;\n          end;\n@@ -1812,8 +1801,8 @@ package body Exp_Ch5 is\n             loop\n                Set_Analyzed (Exp, False);\n \n-               if Nkind_In\n-                   (Exp, N_Selected_Component, N_Indexed_Component)\n+               if Nkind_In (Exp, N_Indexed_Component,\n+                                 N_Selected_Component)\n                then\n                   Exp := Prefix (Exp);\n                else\n@@ -1874,7 +1863,6 @@ package body Exp_Ch5 is\n          Rewrite (N, Make_Null_Statement (Loc));\n          Analyze (N);\n \n-         Ghost_Mode := Save_Ghost_Mode;\n          return;\n       end if;\n \n@@ -2099,7 +2087,6 @@ package body Exp_Ch5 is\n \n          if not Crep then\n             Expand_Bit_Packed_Element_Set (N);\n-            Ghost_Mode := Save_Ghost_Mode;\n             return;\n \n          --  Change of representation case\n@@ -2198,7 +2185,6 @@ package body Exp_Ch5 is\n                   --  expansion, since they would be missed in -gnatc mode ???\n \n                   Error_Msg_N (\"assignment not available on limited type\", N);\n-                  Ghost_Mode := Save_Ghost_Mode;\n                   return;\n                end if;\n \n@@ -2401,7 +2387,6 @@ package body Exp_Ch5 is\n             --  it with all checks suppressed.\n \n             Analyze (N, Suppress => All_Checks);\n-            Ghost_Mode := Save_Ghost_Mode;\n             return;\n          end Tagged_Case;\n \n@@ -2419,15 +2404,13 @@ package body Exp_Ch5 is\n             end loop;\n \n             Expand_Assign_Array (N, Actual_Rhs);\n-            Ghost_Mode := Save_Ghost_Mode;\n             return;\n          end;\n \n       --  Record types\n \n       elsif Is_Record_Type (Typ) then\n          Expand_Assign_Record (N);\n-         Ghost_Mode := Save_Ghost_Mode;\n          return;\n \n       --  Scalar types. This is where we perform the processing related to the\n@@ -2540,11 +2523,8 @@ package body Exp_Ch5 is\n          end if;\n       end if;\n \n-      Ghost_Mode := Save_Ghost_Mode;\n-\n    exception\n       when RE_Not_Available =>\n-         Ghost_Mode := Save_Ghost_Mode;\n          return;\n    end Expand_N_Assignment_Statement;\n "}, {"sha": "77b8ad2679d2d4c4877a827bc284d334a1fa0d33", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -44,7 +44,6 @@ with Exp_Pakd;  use Exp_Pakd;\n with Exp_Tss;   use Exp_Tss;\n with Exp_Util;  use Exp_Util;\n with Freeze;    use Freeze;\n-with Ghost;     use Ghost;\n with Inline;    use Inline;\n with Lib;       use Lib;\n with Namet;     use Namet;\n@@ -5188,17 +5187,8 @@ package body Exp_Ch6 is\n    ---------------------------------------\n \n    procedure Expand_N_Procedure_Call_Statement (N : Node_Id) is\n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n    begin\n-      --  The procedure call is Ghost when the name is Ghost. Set the mode now\n-      --  to ensure that any nodes generated during expansion are properly set\n-      --  as Ghost.\n-\n-      Set_Ghost_Mode (N);\n-\n       Expand_Call (N);\n-      Ghost_Mode := Save_Ghost_Mode;\n    end Expand_N_Procedure_Call_Statement;\n \n    --------------------------------------\n@@ -5358,8 +5348,6 @@ package body Exp_Ch6 is\n \n       --  Local variables\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n       Except_H : Node_Id;\n       L        : List_Id;\n       Spec_Id  : Entity_Id;\n@@ -5390,13 +5378,6 @@ package body Exp_Ch6 is\n          end if;\n       end if;\n \n-      --  The subprogram body is Ghost when it is stand alone and subject to\n-      --  pragma Ghost or the corresponding spec is Ghost. To accomodate both\n-      --  cases, set the mode now to ensure that any nodes generated during\n-      --  expansion are marked as Ghost.\n-\n-      Set_Ghost_Mode (N, Spec_Id);\n-\n       --  Set L to either the list of declarations if present, or to the list\n       --  of statements if no declarations are present. This is used to insert\n       --  new stuff at the start.\n@@ -5518,7 +5499,6 @@ package body Exp_Ch6 is\n               Make_Handled_Sequence_Of_Statements (Loc,\n                 Statements => New_List (Make_Null_Statement (Loc))));\n \n-            Ghost_Mode := Save_Ghost_Mode;\n             return;\n          end if;\n       end if;\n@@ -5543,7 +5523,7 @@ package body Exp_Ch6 is\n       begin\n          if not Acts_As_Spec (N)\n            and then Nkind (Parent (Parent (Spec_Id))) /=\n-             N_Subprogram_Body_Stub\n+                      N_Subprogram_Body_Stub\n          then\n             null;\n \n@@ -5631,8 +5611,6 @@ package body Exp_Ch6 is\n       --  Set to encode entity names in package body before gigi is called\n \n       Qualify_Entity_Names (N);\n-\n-      Ghost_Mode := Save_Ghost_Mode;\n    end Expand_N_Subprogram_Body;\n \n    -----------------------------------"}, {"sha": "6b994aabd97507213d5570e6717465258c8c0ba1", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 22, "deletions": 39, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -4353,9 +4353,8 @@ package body Exp_Ch7 is\n \n       --  Local variables\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n       Dummy        : Entity_Id;\n+      Mode         : Ghost_Mode_Type;\n       Priv_Item    : Node_Id;\n       Proc_Body    : Node_Id;\n       Proc_Body_Id : Entity_Id;\n@@ -4406,6 +4405,11 @@ package body Exp_Ch7 is\n          Work_Typ := Corresponding_Concurrent_Type (Work_Typ);\n       end if;\n \n+      --  The working type may be subject to pragma Ghost. Set the mode now to\n+      --  ensure that the invariant procedure is properly marked as Ghost.\n+\n+      Set_Ghost_Mode (Work_Typ, Mode);\n+\n       --  The type must either have invariants of its own, inherit class-wide\n       --  invariants from parent types or interfaces, or be an array or record\n       --  type whose components have invariants.\n@@ -4416,7 +4420,7 @@ package body Exp_Ch7 is\n       --  inherited by implementing types.\n \n       if Is_Interface (Work_Typ) then\n-         return;\n+         goto Leave;\n       end if;\n \n       --  Obtain both views of the type\n@@ -4445,7 +4449,7 @@ package body Exp_Ch7 is\n             --  Nothing to do because the processing of the underlying full\n             --  view already checked the invariants of the partial view.\n \n-            return;\n+            goto Leave;\n          end if;\n \n          --  Create a declaration for the \"partial\" invariant procedure if it\n@@ -4482,14 +4486,9 @@ package body Exp_Ch7 is\n       --  Nothing to do if the invariant procedure already has a body\n \n       if Present (Corresponding_Body (Proc_Decl)) then\n-         return;\n+         goto Leave;\n       end if;\n \n-      --  The working type may be subject to pragma Ghost. Set the mode now to\n-      --  ensure that the invariant procedure is properly marked as Ghost.\n-\n-      Set_Ghost_Mode_From_Entity (Work_Typ);\n-\n       --  Emulate the environment of the invariant procedure by installing\n       --  its scope and formal parameters. Note that this is not needed, but\n       --  having the scope of the invariant procedure installed helps with\n@@ -4667,7 +4666,8 @@ package body Exp_Ch7 is\n          Append_Freeze_Action (Work_Typ, Proc_Body);\n       end if;\n \n-      Ghost_Mode := Save_Ghost_Mode;\n+   <<Leave>>\n+      Restore_Ghost_Mode (Mode);\n    end Build_Invariant_Procedure_Body;\n \n    -------------------------------------------\n@@ -4680,8 +4680,7 @@ package body Exp_Ch7 is\n    is\n       Loc : constant Source_Ptr := Sloc (Typ);\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n+      Mode      : Ghost_Mode_Type;\n       Proc_Decl : Node_Id;\n       Proc_Id   : Entity_Id;\n       Proc_Nam  : Name_Id;\n@@ -4725,6 +4724,11 @@ package body Exp_Ch7 is\n          Work_Typ := Corresponding_Concurrent_Type (Work_Typ);\n       end if;\n \n+      --  The working type may be subject to pragma Ghost. Set the mode now to\n+      --  ensure that the invariant procedure is properly marked as Ghost.\n+\n+      Set_Ghost_Mode (Work_Typ, Mode);\n+\n       --  The type must either have invariants of its own, inherit class-wide\n       --  invariants from parent or interface types, or be an array or record\n       --  type whose components have invariants.\n@@ -4735,26 +4739,21 @@ package body Exp_Ch7 is\n       --  inherited by implementing types.\n \n       if Is_Interface (Work_Typ) then\n-         return;\n+         goto Leave;\n \n       --  Nothing to do if the type already has a \"partial\" invariant procedure\n \n       elsif Partial_Invariant then\n          if Present (Partial_Invariant_Procedure (Work_Typ)) then\n-            return;\n+            goto Leave;\n          end if;\n \n       --  Nothing to do if the type already has a \"full\" invariant procedure\n \n       elsif Present (Invariant_Procedure (Work_Typ)) then\n-         return;\n+         goto Leave;\n       end if;\n \n-      --  The working type may be subject to pragma Ghost. Set the mode now to\n-      --  ensure that the invariant procedure is properly marked as Ghost.\n-\n-      Set_Ghost_Mode_From_Entity (Work_Typ);\n-\n       --  The caller requests the declaration of the \"partial\" invariant\n       --  procedure.\n \n@@ -4791,13 +4790,6 @@ package body Exp_Ch7 is\n          Set_Needs_Debug_Info (Proc_Id);\n       end if;\n \n-      --  Mark the invariant procedure explicitly as Ghost because it does not\n-      --  come from source.\n-\n-      if Ghost_Mode > None then\n-         Set_Is_Ghost_Entity (Proc_Id);\n-      end if;\n-\n       --  Obtain all views of the input type\n \n       Get_Views (Work_Typ, Priv_Typ, Full_Typ, Full_Base, CRec_Typ);\n@@ -4868,7 +4860,8 @@ package body Exp_Ch7 is\n          Insert_After_And_Analyze (Typ_Decl, Proc_Decl);\n       end if;\n \n-      Ghost_Mode := Save_Ghost_Mode;\n+   <<Leave>>\n+      Restore_Ghost_Mode (Mode);\n    end Build_Invariant_Procedure_Declaration;\n \n    ---------------------\n@@ -5835,15 +5828,7 @@ package body Exp_Ch7 is\n       Spec_Id : constant Entity_Id := Corresponding_Spec (N);\n       Fin_Id  : Entity_Id;\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n    begin\n-      --  The package body is Ghost when the corresponding spec is Ghost. Set\n-      --  the mode now to ensure that any nodes generated during expansion are\n-      --  properly marked as Ghost.\n-\n-      Set_Ghost_Mode (N, Spec_Id);\n-\n       --  This is done only for non-generic packages\n \n       if Ekind (Spec_Id) = E_Package then\n@@ -5899,8 +5884,6 @@ package body Exp_Ch7 is\n             end;\n          end if;\n       end if;\n-\n-      Ghost_Mode := Save_Ghost_Mode;\n    end Expand_N_Package_Body;\n \n    ----------------------------------"}, {"sha": "9a4e5e53d1b945e90b0fe6edab8dbb9a227d1622", "filename": "gcc/ada/exp_ch8.adb", "status": "modified", "additions": 1, "deletions": 47, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fexp_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fexp_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch8.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -30,7 +30,6 @@ with Exp_Ch6;  use Exp_Ch6;\n with Exp_Dbug; use Exp_Dbug;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n-with Ghost;    use Ghost;\n with Namet;    use Namet;\n with Nmake;    use Nmake;\n with Nlists;   use Nlists;\n@@ -50,25 +49,14 @@ package body Exp_Ch8 is\n    ---------------------------------------------\n \n    procedure Expand_N_Exception_Renaming_Declaration (N : Node_Id) is\n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n       Decl : Node_Id;\n \n    begin\n-      --  The exception renaming declaration is Ghost when it is subject to\n-      --  pragma Ghost or renames a Ghost entity. To accomodate both cases, set\n-      --  the mode now to ensure that any nodes generated during expansion are\n-      --  properly marked as Ghost.\n-\n-      Set_Ghost_Mode (N);\n-\n       Decl := Debug_Renaming_Declaration (N);\n \n       if Present (Decl) then\n          Insert_Action (N, Decl);\n       end if;\n-\n-      Ghost_Mode := Save_Ghost_Mode;\n    end Expand_N_Exception_Renaming_Declaration;\n \n    ------------------------------------------\n@@ -161,20 +149,9 @@ package body Exp_Ch8 is\n          end if;\n       end Evaluation_Required;\n \n-      --  Local variables\n-\n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n    --  Start of processing for Expand_N_Object_Renaming_Declaration\n \n    begin\n-      --  The object renaming declaration is Ghost when it is subject to pragma\n-      --  Ghost or renames a Ghost entity. To accomodate both cases, set the\n-      --  mode now to ensure that any nodes generated during expansion are\n-      --  properly marked as Ghost.\n-\n-      Set_Ghost_Mode (N);\n-\n       --  Perform name evaluation if required\n \n       if Evaluation_Required (Nam) then\n@@ -217,27 +194,16 @@ package body Exp_Ch8 is\n       if Present (Decl) then\n          Insert_Action (N, Decl);\n       end if;\n-\n-      Ghost_Mode := Save_Ghost_Mode;\n    end Expand_N_Object_Renaming_Declaration;\n \n    -------------------------------------------\n    -- Expand_N_Package_Renaming_Declaration --\n    -------------------------------------------\n \n    procedure Expand_N_Package_Renaming_Declaration (N : Node_Id) is\n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n       Decl : Node_Id;\n \n    begin\n-      --  The package renaming declaration is Ghost when it is subject to\n-      --  pragma Ghost or renames a Ghost entity. To accomodate both cases,\n-      --  set the mode now to ensure that any nodes generated during expansion\n-      --  are properly marked as Ghost.\n-\n-      Set_Ghost_Mode (N);\n-\n       Decl := Debug_Renaming_Declaration (N);\n \n       if Present (Decl) then\n@@ -276,8 +242,6 @@ package body Exp_Ch8 is\n             Insert_Action (N, Decl);\n          end if;\n       end if;\n-\n-      Ghost_Mode := Save_Ghost_Mode;\n    end Expand_N_Package_Renaming_Declaration;\n \n    ----------------------------------------------\n@@ -327,19 +291,11 @@ package body Exp_Ch8 is\n \n       --  Local variables\n \n-      Nam             : constant Node_Id         := Name (N);\n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n+      Nam : constant Node_Id := Name (N);\n \n    --  Start of processing for Expand_N_Subprogram_Renaming_Declaration\n \n    begin\n-      --  The subprogram renaming declaration is Ghost when it is subject to\n-      --  pragma Ghost or renames a Ghost entity. To accomodate both cases, set\n-      --  the mode now to ensure that any nodes created during expansion are\n-      --  properly flagged as ignored Ghost.\n-\n-      Set_Ghost_Mode (N);\n-\n       --  When the prefix of the name is a function call, we must force the\n       --  call to be made by removing side effects from the call, since we\n       --  must only call the function once.\n@@ -403,8 +359,6 @@ package body Exp_Ch8 is\n             end if;\n          end;\n       end if;\n-\n-      Ghost_Mode := Save_Ghost_Mode;\n    end Expand_N_Subprogram_Renaming_Declaration;\n \n end Exp_Ch8;"}, {"sha": "034e199e2e73c8027a8d2fca61acf9d03c42b3fe", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 53, "deletions": 58, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -4367,71 +4367,62 @@ package body Exp_Disp is\n \n       --  Local variables\n \n-      Elab_Code          : constant List_Id := New_List;\n-      Result             : constant List_Id := New_List;\n-      Tname              : constant Name_Id := Chars (Typ);\n+      Elab_Code : constant List_Id := New_List;\n+      Result    : constant List_Id := New_List;\n+      Tname     : constant Name_Id := Chars (Typ);\n+\n+      --  The following name entries are used by Make_DT to generate a number\n+      --  of entities related to a tagged type. These entities may be generated\n+      --  in a scope other than that of the tagged type declaration, and if\n+      --  the entities for two tagged types with the same name happen to be\n+      --  generated in the same scope, we have to take care to use different\n+      --  names. This is achieved by means of a unique serial number appended\n+      --  to each generated entity name.\n+\n+      Name_DT           : constant Name_Id :=\n+                            New_External_Name (Tname, 'T', Suffix_Index => -1);\n+      Name_Exname       : constant Name_Id :=\n+                            New_External_Name (Tname, 'E', Suffix_Index => -1);\n+      Name_HT_Link      : constant Name_Id :=\n+                            New_External_Name (Tname, 'H', Suffix_Index => -1);\n+      Name_Predef_Prims : constant Name_Id :=\n+                            New_External_Name (Tname, 'R', Suffix_Index => -1);\n+      Name_SSD          : constant Name_Id :=\n+                            New_External_Name (Tname, 'S', Suffix_Index => -1);\n+      Name_TSD          : constant Name_Id :=\n+                            New_External_Name (Tname, 'B', Suffix_Index => -1);\n+\n       AI                 : Elmt_Id;\n       AI_Tag_Elmt        : Elmt_Id;\n       AI_Tag_Comp        : Elmt_Id;\n+      DT                 : Entity_Id;\n       DT_Aggr_List       : List_Id;\n       DT_Constr_List     : List_Id;\n       DT_Ptr             : Entity_Id;\n+      Exname             : Entity_Id;\n+      HT_Link            : Entity_Id;\n       ITable             : Node_Id;\n       I_Depth            : Nat := 0;\n       Iface_Table_Node   : Node_Id;\n+      Mode               : Ghost_Mode_Type;\n       Name_ITable        : Name_Id;\n       Nb_Predef_Prims    : Nat := 0;\n       Nb_Prim            : Nat := 0;\n       New_Node           : Node_Id;\n       Num_Ifaces         : Nat := 0;\n       Parent_Typ         : Entity_Id;\n+      Predef_Prims       : Entity_Id;\n       Prim               : Entity_Id;\n       Prim_Elmt          : Elmt_Id;\n       Prim_Ops_Aggr_List : List_Id;\n+      SSD                : Entity_Id;\n       Suffix_Index       : Int;\n       Typ_Comps          : Elist_Id;\n       Typ_Ifaces         : Elist_Id;\n+      TSD                : Entity_Id;\n       TSD_Aggr_List      : List_Id;\n       TSD_Tags_List      : List_Id;\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n-      --  The following name entries are used by Make_DT to generate a number\n-      --  of entities related to a tagged type. These entities may be generated\n-      --  in a scope other than that of the tagged type declaration, and if\n-      --  the entities for two tagged types with the same name happen to be\n-      --  generated in the same scope, we have to take care to use different\n-      --  names. This is achieved by means of a unique serial number appended\n-      --  to each generated entity name.\n-\n-      Name_DT           : constant Name_Id :=\n-                            New_External_Name (Tname, 'T', Suffix_Index => -1);\n-      Name_Exname       : constant Name_Id :=\n-                            New_External_Name (Tname, 'E', Suffix_Index => -1);\n-      Name_HT_Link      : constant Name_Id :=\n-                            New_External_Name (Tname, 'H', Suffix_Index => -1);\n-      Name_Predef_Prims : constant Name_Id :=\n-                            New_External_Name (Tname, 'R', Suffix_Index => -1);\n-      Name_SSD          : constant Name_Id :=\n-                            New_External_Name (Tname, 'S', Suffix_Index => -1);\n-      Name_TSD          : constant Name_Id :=\n-                            New_External_Name (Tname, 'B', Suffix_Index => -1);\n-\n-      --  Entities built with above names\n-\n-      DT           : constant Entity_Id :=\n-                       Make_Defining_Identifier (Loc, Name_DT);\n-      Exname       : constant Entity_Id :=\n-                       Make_Defining_Identifier (Loc, Name_Exname);\n-      HT_Link      : constant Entity_Id :=\n-                       Make_Defining_Identifier (Loc, Name_HT_Link);\n-      Predef_Prims : constant Entity_Id :=\n-                       Make_Defining_Identifier (Loc, Name_Predef_Prims);\n-      SSD          : constant Entity_Id :=\n-                       Make_Defining_Identifier (Loc, Name_SSD);\n-      TSD          : constant Entity_Id :=\n-                       Make_Defining_Identifier (Loc, Name_TSD);\n-\n    --  Start of processing for Make_DT\n \n    begin\n@@ -4441,27 +4432,25 @@ package body Exp_Disp is\n       --  the mode now to ensure that any nodes generated during dispatch table\n       --  creation are properly marked as Ghost.\n \n-      Set_Ghost_Mode (Declaration_Node (Typ), Typ);\n+      Set_Ghost_Mode (Typ, Mode);\n \n       --  Handle cases in which there is no need to build the dispatch table\n \n       if Has_Dispatch_Table (Typ)\n         or else No (Access_Disp_Table (Typ))\n         or else Is_CPP_Class (Typ)\n       then\n-         Ghost_Mode := Save_Ghost_Mode;\n-         return Result;\n+         goto Leave;\n \n       elsif No_Run_Time_Mode then\n          Error_Msg_CRT (\"tagged types\", Typ);\n-         Ghost_Mode := Save_Ghost_Mode;\n-         return Result;\n+         goto Leave;\n \n       elsif not RTE_Available (RE_Tag) then\n          Append_To (Result,\n            Make_Object_Declaration (Loc,\n-             Defining_Identifier => Node (First_Elmt\n-                                           (Access_Disp_Table (Typ))),\n+             Defining_Identifier =>\n+               Node (First_Elmt (Access_Disp_Table (Typ))),\n              Object_Definition   => New_Occurrence_Of (RTE (RE_Tag), Loc),\n              Constant_Present    => True,\n              Expression =>\n@@ -4470,8 +4459,7 @@ package body Exp_Disp is\n \n          Analyze_List (Result, Suppress => All_Checks);\n          Error_Msg_CRT (\"tagged types\", Typ);\n-         Ghost_Mode := Save_Ghost_Mode;\n-         return Result;\n+         goto Leave;\n       end if;\n \n       --  Ensure that the value of Max_Predef_Prims defined in a-tags is\n@@ -4481,18 +4469,23 @@ package body Exp_Disp is\n       if RTE_Available (RE_Interface_Data) then\n          if Max_Predef_Prims /= 15 then\n             Error_Msg_N (\"run-time library configuration error\", Typ);\n-            Ghost_Mode := Save_Ghost_Mode;\n-            return Result;\n+            goto Leave;\n          end if;\n       else\n          if Max_Predef_Prims /= 9 then\n             Error_Msg_N (\"run-time library configuration error\", Typ);\n             Error_Msg_CRT (\"tagged types\", Typ);\n-            Ghost_Mode := Save_Ghost_Mode;\n-            return Result;\n+            goto Leave;\n          end if;\n       end if;\n \n+      DT           := Make_Defining_Identifier (Loc, Name_DT);\n+      Exname       := Make_Defining_Identifier (Loc, Name_Exname);\n+      HT_Link      := Make_Defining_Identifier (Loc, Name_HT_Link);\n+      Predef_Prims := Make_Defining_Identifier (Loc, Name_Predef_Prims);\n+      SSD          := Make_Defining_Identifier (Loc, Name_SSD);\n+      TSD          := Make_Defining_Identifier (Loc, Name_TSD);\n+\n       --  Initialize Parent_Typ handling private types\n \n       Parent_Typ := Etype (Typ);\n@@ -4695,7 +4688,7 @@ package body Exp_Disp is\n                Set_SCIL_Entity (New_Node, Typ);\n                Set_SCIL_Node (Last (Result), New_Node);\n \n-               goto Early_Exit_For_SCIL;\n+               goto Leave_SCIL;\n \n                --  Gnat2scil has its own implementation of dispatch tables,\n                --  different than what is being implemented here. Generating\n@@ -4772,7 +4765,7 @@ package body Exp_Disp is\n                Set_SCIL_Entity (New_Node, Typ);\n                Set_SCIL_Node (Last (Result), New_Node);\n \n-               goto Early_Exit_For_SCIL;\n+               goto Leave_SCIL;\n \n                --  Gnat2scil has its own implementation of dispatch tables,\n                --  different than what is being implemented here. Generating\n@@ -6238,13 +6231,15 @@ package body Exp_Disp is\n          end;\n       end if;\n \n-      <<Early_Exit_For_SCIL>>\n+   <<Leave_SCIL>>\n \n       --  Register the tagged type in the call graph nodes table\n \n       Register_CG_Node (Typ);\n \n-      Ghost_Mode := Save_Ghost_Mode;\n+   <<Leave>>\n+      Restore_Ghost_Mode (Mode);\n+\n       return Result;\n    end Make_DT;\n "}, {"sha": "858c632275ed9f0fbad29d3e27a5a49e1092b85e", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 6, "deletions": 49, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -32,7 +32,6 @@ with Errout;   use Errout;\n with Exp_Ch11; use Exp_Ch11;\n with Exp_Util; use Exp_Util;\n with Expander; use Expander;\n-with Ghost;    use Ghost;\n with Inline;   use Inline;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n@@ -317,24 +316,15 @@ package body Exp_Prag is\n       --  Assert_Failure, so that coverage analysis tools can relate the\n       --  call to the failed check.\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n    begin\n       --  Nothing to do if pragma is ignored\n \n       if Is_Ignored (N) then\n          return;\n       end if;\n \n-      --  Pragmas Assert, Assert_And_Cut, Assume, Check and Loop_Invariant are\n-      --  Ghost when they apply to a Ghost entity. Set the mode now to ensure\n-      --  that any nodes generated during expansion are properly flagged as\n-      --  Ghost.\n-\n-      Set_Ghost_Mode (N);\n-\n-      --  Since this check is active, we rewrite the pragma into a\n-      --  corresponding if statement, and then analyze the statement.\n+      --  Since this check is active, rewrite the pragma into a corresponding\n+      --  if statement, and then analyze the statement.\n \n       --  The normal case expansion transforms:\n \n@@ -492,12 +482,9 @@ package body Exp_Prag is\n          elsif Nam = Name_Assert then\n             Error_Msg_N (\"?A?assertion will fail at run time\", N);\n          else\n-\n             Error_Msg_N (\"?A?check will fail at run time\", N);\n          end if;\n       end if;\n-\n-      Ghost_Mode := Save_Ghost_Mode;\n    end Expand_Pragma_Check;\n \n    ---------------------------------\n@@ -997,8 +984,6 @@ package body Exp_Prag is\n       Aggr : constant Node_Id :=\n                Expression (First (Pragma_Argument_Associations (CCs)));\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n       Case_Guard    : Node_Id;\n       CG_Checks     : Node_Id;\n       CG_Stmts      : List_Id;\n@@ -1032,12 +1017,6 @@ package body Exp_Prag is\n          return;\n       end if;\n \n-      --  The contract cases is Ghost when it applies to a Ghost entity. Set\n-      --  the mode now to ensure that any nodes generated during expansion are\n-      --  properly flagged as Ghost.\n-\n-      Set_Ghost_Mode (CCs);\n-\n       --  The expansion of contract cases is quite distributed as it produces\n       --  various statements to evaluate the case guards and consequences. To\n       --  preserve the original context, set the Is_Assertion_Expr flag. This\n@@ -1272,7 +1251,6 @@ package body Exp_Prag is\n       Append_To (Stmts, Conseq_Checks);\n \n       In_Assertion_Expr := In_Assertion_Expr - 1;\n-      Ghost_Mode := Save_Ghost_Mode;\n    end Expand_Pragma_Contract_Cases;\n \n    ---------------------------------------\n@@ -1372,15 +1350,14 @@ package body Exp_Prag is\n    -------------------------------------\n \n    procedure Expand_Pragma_Initial_Condition (Spec_Or_Body : Node_Id) is\n-      Loc       : constant Source_Ptr := Sloc (Spec_Or_Body);\n+      Loc : constant Source_Ptr := Sloc (Spec_Or_Body);\n+\n       Check     : Node_Id;\n       Expr      : Node_Id;\n       Init_Cond : Node_Id;\n       List      : List_Id;\n       Pack_Id   : Entity_Id;\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n    begin\n       if Nkind (Spec_Or_Body) = N_Package_Body then\n          Pack_Id := Corresponding_Spec (Spec_Or_Body);\n@@ -1419,12 +1396,6 @@ package body Exp_Prag is\n \n       Init_Cond := Get_Pragma (Pack_Id, Pragma_Initial_Condition);\n \n-      --  The initial condition is Ghost when it applies to a Ghost entity. Set\n-      --  the mode now to ensure that any nodes generated during expansion are\n-      --  properly flagged as Ghost.\n-\n-      Set_Ghost_Mode (Init_Cond);\n-\n       --  The caller should check whether the package is subject to pragma\n       --  Initial_Condition.\n \n@@ -1437,7 +1408,6 @@ package body Exp_Prag is\n       --  runtime check as it will repeat the illegality.\n \n       if Error_Posted (Init_Cond) or else Error_Posted (Expr) then\n-         Ghost_Mode := Save_Ghost_Mode;\n          return;\n       end if;\n \n@@ -1455,8 +1425,6 @@ package body Exp_Prag is\n \n       Append_To (List, Check);\n       Analyze (Check);\n-\n-      Ghost_Mode := Save_Ghost_Mode;\n    end Expand_Pragma_Initial_Condition;\n \n    ------------------------------------\n@@ -1632,8 +1600,8 @@ package body Exp_Prag is\n \n          --  Local variables\n \n-         Expr     : constant Node_Id := Expression (Variant);\n-         Expr_Typ : constant Entity_Id := Etype (Expr);\n+         Expr     : constant Node_Id    := Expression (Variant);\n+         Expr_Typ : constant Entity_Id  := Etype (Expr);\n          Loc      : constant Source_Ptr := Sloc (Expr);\n          Loop_Loc : constant Source_Ptr := Sloc (Loop_Stmt);\n          Curr_Id  : Entity_Id;\n@@ -1804,10 +1772,6 @@ package body Exp_Prag is\n          end if;\n       end Process_Variant;\n \n-      --  Local variables\n-\n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n    --  Start of processing for Expand_Pragma_Loop_Variant\n \n    begin\n@@ -1820,12 +1784,6 @@ package body Exp_Prag is\n          return;\n       end if;\n \n-      --  The loop variant is Ghost when it applies to a Ghost entity. Set\n-      --  the mode now to ensure that any nodes generated during expansion\n-      --  are properly flagged as Ghost.\n-\n-      Set_Ghost_Mode (N);\n-\n       --  The expansion of Loop_Variant is quite distributed as it produces\n       --  various statements to capture and compare the arguments. To preserve\n       --  the original context, set the Is_Assertion_Expr flag. This aids the\n@@ -1896,7 +1854,6 @@ package body Exp_Prag is\n       --  for documentation purposes. It will be ignored by the backend.\n \n       In_Assertion_Expr := In_Assertion_Expr - 1;\n-      Ghost_Mode := Save_Ghost_Mode;\n    end Expand_Pragma_Loop_Variant;\n \n    --------------------------------"}, {"sha": "82970136f0fb30e32816c70256c4cfc19140431a", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 34, "deletions": 49, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -1712,12 +1712,11 @@ package body Exp_Util is\n \n       Loc : constant Source_Ptr := Sloc (Typ);\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n       DIC_Prag     : Node_Id;\n       DIC_Typ      : Entity_Id;\n       Dummy_1      : Entity_Id;\n       Dummy_2      : Entity_Id;\n+      Mode         : Ghost_Mode_Type;\n       Proc_Body    : Node_Id;\n       Proc_Body_Id : Entity_Id;\n       Proc_Decl    : Node_Id;\n@@ -1749,6 +1748,11 @@ package body Exp_Util is\n          Work_Typ := Corresponding_Concurrent_Type (Work_Typ);\n       end if;\n \n+      --  The working type may be subject to pragma Ghost. Set the mode now to\n+      --  ensure that the DIC procedure is properly marked as Ghost.\n+\n+      Set_Ghost_Mode (Work_Typ, Mode);\n+\n       --  The working type must be either define a DIC pragma of its own or\n       --  inherit one from a parent type.\n \n@@ -1767,7 +1771,7 @@ package body Exp_Util is\n       --  argument is \"null\".\n \n       if not Is_Verifiable_DIC_Pragma (DIC_Prag) then\n-         return;\n+         goto Leave;\n       end if;\n \n       --  The working type may lack a DIC procedure declaration. This may be\n@@ -1799,14 +1803,9 @@ package body Exp_Util is\n       --  Nothing to do if the DIC procedure already has a body\n \n       if Present (Corresponding_Body (Proc_Decl)) then\n-         return;\n+         goto Leave;\n       end if;\n \n-      --  The working type may be subject to pragma Ghost. Set the mode now to\n-      --  ensure that the DIC procedure is properly marked as Ghost.\n-\n-      Set_Ghost_Mode_From_Entity (Work_Typ);\n-\n       --  Emulate the environment of the DIC procedure by installing its scope\n       --  and formal parameters.\n \n@@ -1917,7 +1916,8 @@ package body Exp_Util is\n          Append_Freeze_Action (Work_Typ, Proc_Body);\n       end if;\n \n-      Ghost_Mode := Save_Ghost_Mode;\n+   <<Leave>>\n+      Restore_Ghost_Mode (Mode);\n    end Build_DIC_Procedure_Body;\n \n    -------------------------------------\n@@ -1927,10 +1927,9 @@ package body Exp_Util is\n    procedure Build_DIC_Procedure_Declaration (Typ : Entity_Id) is\n       Loc : constant Source_Ptr := Sloc (Typ);\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n       DIC_Prag  : Node_Id;\n       DIC_Typ   : Entity_Id;\n+      Mode      : Ghost_Mode_Type;\n       Proc_Decl : Node_Id;\n       Proc_Id   : Entity_Id;\n       Typ_Decl  : Node_Id;\n@@ -1973,6 +1972,11 @@ package body Exp_Util is\n          Work_Typ := Corresponding_Concurrent_Type (Work_Typ);\n       end if;\n \n+      --  The working type may be subject to pragma Ghost. Set the mode now to\n+      --  ensure that the DIC procedure is properly marked as Ghost.\n+\n+      Set_Ghost_Mode (Work_Typ, Mode);\n+\n       --  The type must be either subject to a DIC pragma or inherit one from a\n       --  parent type.\n \n@@ -1991,19 +1995,14 @@ package body Exp_Util is\n       --  argument is \"null\".\n \n       if not Is_Verifiable_DIC_Pragma (DIC_Prag) then\n-         return;\n+         goto Leave;\n \n       --  Nothing to do if the type already has a DIC procedure\n \n       elsif Present (DIC_Procedure (Work_Typ)) then\n-         return;\n+         goto Leave;\n       end if;\n \n-      --  The working type may be subject to pragma Ghost. Set the mode now to\n-      --  ensure that the DIC procedure is properly marked as Ghost.\n-\n-      Set_Ghost_Mode_From_Entity (Work_Typ);\n-\n       Proc_Id :=\n         Make_Defining_Identifier (Loc,\n           Chars =>\n@@ -2025,13 +2024,6 @@ package body Exp_Util is\n          Set_Needs_Debug_Info (Proc_Id);\n       end if;\n \n-      --  Mark the DIC procedure explicitly as Ghost because it does not come\n-      --  from source.\n-\n-      if Ghost_Mode > None then\n-         Set_Is_Ghost_Entity (Proc_Id);\n-      end if;\n-\n       --  Obtain all views of the input type\n \n       Get_Views (Work_Typ, Priv_Typ, Full_Typ, Full_Base, CRec_Typ);\n@@ -2106,7 +2098,8 @@ package body Exp_Util is\n          Insert_After_And_Analyze (Typ_Decl, Proc_Decl);\n       end if;\n \n-      Ghost_Mode := Save_Ghost_Mode;\n+   <<Leave>>\n+      Restore_Ghost_Mode (Mode);\n    end Build_DIC_Procedure_Declaration;\n \n    --------------------------\n@@ -7816,8 +7809,9 @@ package body Exp_Util is\n    -------------------------\n \n    function Make_Invariant_Call (Expr : Node_Id) return Node_Id is\n-      Loc     : constant Source_Ptr := Sloc (Expr);\n-      Typ     : constant Entity_Id  := Base_Type (Etype (Expr));\n+      Loc : constant Source_Ptr := Sloc (Expr);\n+      Typ : constant Entity_Id  := Base_Type (Etype (Expr));\n+\n       Proc_Id : Entity_Id;\n \n    begin\n@@ -7910,45 +7904,36 @@ package body Exp_Util is\n       Expr : Node_Id;\n       Mem  : Boolean := False) return Node_Id\n    is\n-      Loc  : constant Source_Ptr := Sloc (Expr);\n-      Call : Node_Id;\n-      PFM  : Entity_Id;\n+      Loc : constant Source_Ptr := Sloc (Expr);\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n+      Call    : Node_Id;\n+      Func_Id : Entity_Id;\n+      Mode    : Ghost_Mode_Type;\n \n    begin\n       pragma Assert (Present (Predicate_Function (Typ)));\n \n       --  The related type may be subject to pragma Ghost. Set the mode now to\n       --  ensure that the call is properly marked as Ghost.\n \n-      Set_Ghost_Mode_From_Entity (Typ);\n+      Set_Ghost_Mode (Typ, Mode);\n \n       --  Call special membership version if requested and available\n \n-      if Mem then\n-         PFM := Predicate_Function_M (Typ);\n-\n-         if Present (PFM) then\n-            Call :=\n-              Make_Function_Call (Loc,\n-                Name                   => New_Occurrence_Of (PFM, Loc),\n-                Parameter_Associations => New_List (Relocate_Node (Expr)));\n-\n-            Ghost_Mode := Save_Ghost_Mode;\n-            return Call;\n-         end if;\n+      if Mem and then Present (Predicate_Function_M (Typ)) then\n+         Func_Id := Predicate_Function_M (Typ);\n+      else\n+         Func_Id := Predicate_Function (Typ);\n       end if;\n \n       --  Case of calling normal predicate function\n \n       Call :=\n         Make_Function_Call (Loc,\n-          Name                   =>\n-            New_Occurrence_Of (Predicate_Function (Typ), Loc),\n+          Name                   => New_Occurrence_Of (Func_Id, Loc),\n           Parameter_Associations => New_List (Relocate_Node (Expr)));\n \n-      Ghost_Mode := Save_Ghost_Mode;\n+      Restore_Ghost_Mode (Mode);\n       return Call;\n    end Make_Predicate_Call;\n "}, {"sha": "64192b7989d35585cbd6b4f90bdfc647ecfd9502", "filename": "gcc/ada/expander.adb", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fexpander.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fexpander.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexpander.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -41,6 +41,7 @@ with Exp_Ch11;  use Exp_Ch11;\n with Exp_Ch12;  use Exp_Ch12;\n with Exp_Ch13;  use Exp_Ch13;\n with Exp_Prag;  use Exp_Prag;\n+with Ghost;     use Ghost;\n with Opt;       use Opt;\n with Rtsfind;   use Rtsfind;\n with Sem;       use Sem;\n@@ -77,6 +78,8 @@ package body Expander is\n    ------------\n \n    procedure Expand (N : Node_Id) is\n+      Mode : Ghost_Mode_Type;\n+\n    begin\n       --  If we were analyzing a default expression (or other spec expression)\n       --  the Full_Analysis flag must be off. If we are in expansion mode then\n@@ -88,6 +91,11 @@ package body Expander is\n           and then (Full_Analysis or else not Expander_Active)\n           and then not (Inside_A_Generic and then Expander_Active));\n \n+      --  Establish the Ghost mode of the context to ensure that any generated\n+      --  nodes during expansion are marked as Ghost.\n+\n+      Set_Ghost_Mode (N, Mode);\n+\n       --  The GNATprove_Mode flag indicates that a light expansion for formal\n       --  verification should be used. This expansion is never done inside\n       --  generics, because otherwise, this breaks the name resolution\n@@ -105,7 +113,7 @@ package body Expander is\n          --  needed, and in general cannot be done correctly, in this mode, so\n          --  we are all done.\n \n-         return;\n+         goto Leave;\n \n       --  There are three reasons for the Expander_Active flag to be false\n \n@@ -140,7 +148,7 @@ package body Expander is\n             Pop_Scope;\n          end if;\n \n-         return;\n+         goto Leave;\n \n       else\n          begin\n@@ -482,7 +490,7 @@ package body Expander is\n \n          exception\n             when RE_Not_Available =>\n-               return;\n+               goto Leave;\n          end;\n \n          --  Set result as analyzed and then do a possible transient wrap. The\n@@ -510,6 +518,9 @@ package body Expander is\n \n          Debug_A_Exit (\"expanding  \", N, \"  (done)\");\n       end if;\n+\n+   <<Leave>>\n+      Restore_Ghost_Mode (Mode);\n    end Expand;\n \n    ---------------------------"}, {"sha": "c601ac02ae7fd0c100803ae2f3679e43a2046fff", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 34, "deletions": 79, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -2071,9 +2071,6 @@ package body Freeze is\n       --  Determine whether an arbitrary entity is subject to Boolean aspect\n       --  Import and its value is specified as True.\n \n-      function New_Freeze_Node return Node_Id;\n-      --  Create a new freeze node for entity E\n-\n       procedure Wrap_Imported_Subprogram (E : Entity_Id);\n       --  If E is an entity for an imported subprogram with pre/post-conditions\n       --  then this procedure will create a wrapper to ensure that proper run-\n@@ -2283,14 +2280,12 @@ package body Freeze is\n \n                   if Convention (Rec_Type) = Convention_C then\n                      Error_Msg_N\n-                       (\"?x?discriminated record has no direct \" &\n-                        \"equivalent in C\",\n-                        A2);\n+                       (\"?x?discriminated record has no direct equivalent in \"\n+                        & \"C\", A2);\n                   else\n                      Error_Msg_N\n-                       (\"?x?discriminated record has no direct \" &\n-                        \"equivalent in C++\",\n-                        A2);\n+                       (\"?x?discriminated record has no direct equivalent in \"\n+                        & \"C++\", A2);\n                   end if;\n \n                   Error_Msg_NE\n@@ -4703,39 +4698,6 @@ package body Freeze is\n          return False;\n       end Has_Boolean_Aspect_Import;\n \n-      ---------------------\n-      -- New_Freeze_Node --\n-      ---------------------\n-\n-      function New_Freeze_Node return Node_Id is\n-         Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-         Result          : Node_Id;\n-\n-      begin\n-         --  Handle the case where an ignored Ghost subprogram freezes the type\n-         --  of one of its formals. The type can either be non-Ghost or checked\n-         --  Ghost. Since the freeze node for the type is generated in the\n-         --  context of the subprogram, the node will be incorrectly flagged as\n-         --  ignored Ghost and erroneously removed from the tree.\n-\n-         --    type Typ is ...;\n-         --    procedure Ignored_Ghost_Proc (Formal : Typ) with Ghost;\n-\n-         --  Reset the Ghost mode to \"none\". This preserves the freeze node.\n-\n-         if Ghost_Mode = Ignore\n-           and then not Is_Ignored_Ghost_Entity (E)\n-           and then not Is_Ignored_Ghost_Node (E)\n-         then\n-            Ghost_Mode := None;\n-         end if;\n-\n-         Result := New_Node (N_Freeze_Entity, Loc);\n-\n-         Ghost_Mode := Save_Ghost_Mode;\n-         return Result;\n-      end New_Freeze_Node;\n-\n       ------------------------------\n       -- Wrap_Imported_Subprogram --\n       ------------------------------\n@@ -4927,7 +4889,7 @@ package body Freeze is\n \n       --  Local variables\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n+      Mode : Ghost_Mode_Type;\n \n    --  Start of processing for Freeze_Entity\n \n@@ -4936,7 +4898,7 @@ package body Freeze is\n       --  now to ensure that any nodes generated during freezing are properly\n       --  flagged as Ghost.\n \n-      Set_Ghost_Mode_From_Entity (E);\n+      Set_Ghost_Mode (E, Mode);\n \n       --  We are going to test for various reasons why this entity need not be\n       --  frozen here, but in the case of an Itype that's defined within a\n@@ -4953,14 +4915,12 @@ package body Freeze is\n       --  Do not freeze if already frozen since we only need one freeze node\n \n       if Is_Frozen (E) then\n-         Ghost_Mode := Save_Ghost_Mode;\n-         return No_List;\n+         Result := No_List;\n+         goto Leave;\n \n       elsif Ekind (E) = E_Generic_Package then\n          Result := Freeze_Generic_Entities (E);\n-\n-         Ghost_Mode := Save_Ghost_Mode;\n-         return Result;\n+         goto Leave;\n \n       --  It is improper to freeze an external entity within a generic because\n       --  its freeze node will appear in a non-valid context. The entity will\n@@ -4974,8 +4934,8 @@ package body Freeze is\n             Analyze_Aspects_At_Freeze_Point (E);\n          end if;\n \n-         Ghost_Mode := Save_Ghost_Mode;\n-         return No_List;\n+         Result := No_List;\n+         goto Leave;\n \n       --  AI05-0213: A formal incomplete type does not freeze the actual. In\n       --  the instance, the same applies to the subtype renaming the actual.\n@@ -4985,20 +4945,20 @@ package body Freeze is\n         and then No (Full_View (Base_Type (E)))\n         and then Ada_Version >= Ada_2012\n       then\n-         Ghost_Mode := Save_Ghost_Mode;\n-         return No_List;\n+         Result := No_List;\n+         goto Leave;\n \n       --  Formal subprograms are never frozen\n \n       elsif Is_Formal_Subprogram (E) then\n-         Ghost_Mode := Save_Ghost_Mode;\n-         return No_List;\n+         Result := No_List;\n+         goto Leave;\n \n       --  Generic types are never frozen as they lack delayed semantic checks\n \n       elsif Is_Generic_Type (E) then\n-         Ghost_Mode := Save_Ghost_Mode;\n-         return No_List;\n+         Result := No_List;\n+         goto Leave;\n \n       --  Do not freeze a global entity within an inner scope created during\n       --  expansion. A call to subprogram E within some internal procedure\n@@ -5031,8 +4991,8 @@ package body Freeze is\n                   then\n                      exit;\n                   else\n-                     Ghost_Mode := Save_Ghost_Mode;\n-                     return No_List;\n+                     Result := No_List;\n+                     goto Leave;\n                   end if;\n                end if;\n \n@@ -5067,8 +5027,8 @@ package body Freeze is\n             end loop;\n \n             if No (S) then\n-               Ghost_Mode := Save_Ghost_Mode;\n-               return No_List;\n+               Result := No_List;\n+               goto Leave;\n             end if;\n          end;\n       end if;\n@@ -5153,8 +5113,7 @@ package body Freeze is\n \n             if not Is_Internal (E) and then Do_Freeze_Profile then\n                if not Freeze_Profile (E) then\n-                  Ghost_Mode := Save_Ghost_Mode;\n-                  return Result;\n+                  goto Leave;\n                end if;\n             end if;\n \n@@ -5336,8 +5295,8 @@ package body Freeze is\n                and then not Has_Delayed_Freeze (E))\n          then\n             Check_Compile_Time_Size (E);\n-            Ghost_Mode := Save_Ghost_Mode;\n-            return No_List;\n+            Result := No_List;\n+            goto Leave;\n          end if;\n \n          --  Check for error of Type_Invariant'Class applied to an untagged\n@@ -5607,8 +5566,7 @@ package body Freeze is\n \n             if not Is_Frozen (Root_Type (E)) then\n                Set_Is_Frozen (E, False);\n-               Ghost_Mode := Save_Ghost_Mode;\n-               return Result;\n+               goto Leave;\n             end if;\n \n             --  The equivalent type associated with a class-wide subtype needs\n@@ -5749,8 +5707,7 @@ package body Freeze is\n               and then not Present (Full_View (E))\n             then\n                Set_Is_Frozen (E, False);\n-               Ghost_Mode := Save_Ghost_Mode;\n-               return Result;\n+               goto Leave;\n \n             --  Case of full view present\n \n@@ -5841,8 +5798,7 @@ package body Freeze is\n                   Set_RM_Size   (E, RM_Size (Full_View (E)));\n                end if;\n \n-               Ghost_Mode := Save_Ghost_Mode;\n-               return Result;\n+               goto Leave;\n \n             --  Case of underlying full view present\n \n@@ -5871,8 +5827,7 @@ package body Freeze is\n \n                Check_Debug_Info_Needed (E);\n \n-               Ghost_Mode := Save_Ghost_Mode;\n-               return Result;\n+               goto Leave;\n \n             --  Case of no full view present. If entity is derived or subtype,\n             --  it is safe to freeze, correctness depends on the frozen status\n@@ -5885,8 +5840,8 @@ package body Freeze is\n \n             else\n                Set_Is_Frozen (E, False);\n-               Ghost_Mode := Save_Ghost_Mode;\n-               return No_List;\n+               Result := No_List;\n+               goto Leave;\n             end if;\n \n          --  For access subprogram, freeze types of all formals, the return\n@@ -5933,8 +5888,7 @@ package body Freeze is\n          --  generic processing), so we never need freeze nodes for them.\n \n          if Is_Generic_Type (E) then\n-            Ghost_Mode := Save_Ghost_Mode;\n-            return Result;\n+            goto Leave;\n          end if;\n \n          --  Some special processing for non-generic types to complete\n@@ -6465,7 +6419,7 @@ package body Freeze is\n             Set_Sloc (F_Node, Loc);\n \n          else\n-            F_Node := New_Freeze_Node;\n+            F_Node := New_Node (N_Freeze_Entity, Loc);\n             Set_Freeze_Node (E, F_Node);\n             Set_Access_Types_To_Process (F_Node, No_Elist);\n             Set_TSS_Elist (F_Node, No_Elist);\n@@ -6547,7 +6501,8 @@ package body Freeze is\n          end if;\n       end if;\n \n-      Ghost_Mode := Save_Ghost_Mode;\n+   <<Leave>>\n+      Restore_Ghost_Mode (Mode);\n       return Result;\n    end Freeze_Entity;\n "}, {"sha": "b55cff633dbf8dd180c835998bc51eaaf7345e1a", "filename": "gcc/ada/ghost.adb", "status": "modified", "additions": 592, "deletions": 243, "changes": 835, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fghost.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fghost.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fghost.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -33,7 +33,6 @@ with Lib;      use Lib;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n-with Opt;      use Opt;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Disp; use Sem_Disp;\n@@ -65,20 +64,30 @@ package body Ghost is\n    -----------------------\n \n    function Ghost_Entity (N : Node_Id) return Entity_Id;\n-   --  Subsidiary to Check_Ghost_Context and Set_Ghost_Mode. Find the entity of\n-   --  a reference to a Ghost entity. Return Empty if there is no such entity.\n+   --  Find the entity of a reference to a Ghost entity. Return Empty if there\n+   --  is no such entity.\n+\n+   procedure Install_Ghost_Mode (Mode : Name_Id);\n+   --  Install a specific Ghost mode denoted by Mode by setting global variable\n+   --  Ghost_Mode.\n \n    function Is_Subject_To_Ghost (N : Node_Id) return Boolean;\n-   --  Subsidiary to routines Is_OK_xxx and Set_Ghost_Mode. Determine whether\n-   --  declaration or body N is subject to aspect or pragma Ghost. Use this\n-   --  routine in cases where [source] pragma Ghost has not been analyzed yet,\n-   --  but the context needs to establish the \"ghostness\" of N.\n+   --  Determine whether declaration or body N is subject to aspect or pragma\n+   --  Ghost. This routine must be used in cases where pragma Ghost has not\n+   --  been analyzed yet, but the context needs to establish the \"ghostness\"\n+   --  of N.\n+\n+   procedure Mark_Ghost_Declaration_Or_Body\n+     (N    : Node_Id;\n+      Mode : Name_Id);\n+   --  Mark the defining entity of declaration or body N as Ghost depending on\n+   --  mode Mode. Mark all formals parameters when N denotes a subprogram or a\n+   --  body.\n \n    procedure Propagate_Ignored_Ghost_Code (N : Node_Id);\n-   --  Subsidiary to routines Mark_xxx_As_Ghost and Set_Ghost_Mode_From_xxx.\n-   --  Signal all enclosing scopes that they now contain ignored Ghost code.\n-   --  Add the compilation unit containing N to table Ignored_Ghost_Units for\n-   --  post processing.\n+   --  Signal all enclosing scopes that they now contain at least one ignored\n+   --  Ghost node denoted by N. Add the compilation unit containing N to table\n+   --  Ignored_Ghost_Units for post processing.\n \n    ----------------------------\n    -- Add_Ignored_Ghost_Unit --\n@@ -112,34 +121,37 @@ package body Ghost is\n    ----------------------------\n \n    procedure Check_Ghost_Completion\n-     (Partial_View : Entity_Id;\n-      Full_View    : Entity_Id)\n+     (Prev_Id  : Entity_Id;\n+      Compl_Id : Entity_Id)\n    is\n       Policy : constant Name_Id := Policy_In_Effect (Name_Ghost);\n \n    begin\n+      --  Nothing to do if one of the views is missing\n+\n+      if No (Prev_Id) or else No (Compl_Id) then\n+         null;\n+\n       --  The Ghost policy in effect at the point of declaration and at the\n       --  point of completion must match (SPARK RM 6.9(14)).\n \n-      if Is_Checked_Ghost_Entity (Partial_View)\n+      elsif Is_Checked_Ghost_Entity (Prev_Id)\n         and then Policy = Name_Ignore\n       then\n-         Error_Msg_Sloc := Sloc (Full_View);\n+         Error_Msg_Sloc := Sloc (Compl_Id);\n \n-         Error_Msg_N (\"incompatible ghost policies in effect\", Partial_View);\n-         Error_Msg_N (\"\\& declared with ghost policy `Check`\", Partial_View);\n-         Error_Msg_N (\"\\& completed # with ghost policy `Ignore`\",\n-                                                               Partial_View);\n+         Error_Msg_N (\"incompatible ghost policies in effect\", Prev_Id);\n+         Error_Msg_N (\"\\& declared with ghost policy `Check`\", Prev_Id);\n+         Error_Msg_N (\"\\& completed # with ghost policy `Ignore`\", Prev_Id);\n \n-      elsif Is_Ignored_Ghost_Entity (Partial_View)\n+      elsif Is_Ignored_Ghost_Entity (Prev_Id)\n         and then Policy = Name_Check\n       then\n-         Error_Msg_Sloc := Sloc (Full_View);\n+         Error_Msg_Sloc := Sloc (Compl_Id);\n \n-         Error_Msg_N (\"incompatible ghost policies in effect\",  Partial_View);\n-         Error_Msg_N (\"\\& declared with ghost policy `Ignore`\", Partial_View);\n-         Error_Msg_N (\"\\& completed # with ghost policy `Check`\",\n-                                                                Partial_View);\n+         Error_Msg_N (\"incompatible ghost policies in effect\", Prev_Id);\n+         Error_Msg_N (\"\\& declared with ghost policy `Ignore`\", Prev_Id);\n+         Error_Msg_N (\"\\& completed # with ghost policy `Check`\", Prev_Id);\n       end if;\n    end Check_Ghost_Completion;\n \n@@ -165,23 +177,31 @@ package body Ghost is\n          function Is_OK_Declaration (Decl : Node_Id) return Boolean;\n          --  Determine whether node Decl is a suitable context for a reference\n          --  to a Ghost entity. To qualify as such, Decl must either\n-         --    1) Be subject to pragma Ghost\n-         --    2) Rename a Ghost entity\n+         --\n+         --    * Define a Ghost entity\n+         --\n+         --    * Be subject to pragma Ghost\n \n          function Is_OK_Pragma (Prag : Node_Id) return Boolean;\n          --  Determine whether node Prag is a suitable context for a reference\n          --  to a Ghost entity. To qualify as such, Prag must either\n-         --    1) Be an assertion expression pragma\n-         --    2) Denote pragma Global, Depends, Initializes, Refined_Global,\n-         --       Refined_Depends or Refined_State\n-         --    3) Specify an aspect of a Ghost entity\n-         --    4) Contain a reference to a Ghost entity\n+         --\n+         --    * Be an assertion expression pragma\n+         --\n+         --    * Denote pragma Global, Depends, Initializes, Refined_Global,\n+         --      Refined_Depends or Refined_State.\n+         --\n+         --    * Specify an aspect of a Ghost entity\n+         --\n+         --    * Contain a reference to a Ghost entity\n \n          function Is_OK_Statement (Stmt : Node_Id) return Boolean;\n          --  Determine whether node Stmt is a suitable context for a reference\n          --  to a Ghost entity. To qualify as such, Stmt must either\n-         --    1) Denote a call to a Ghost procedure\n-         --    2) Denote an assignment statement whose target is Ghost\n+         --\n+         --    * Denote a procedure call to a Ghost procedure\n+         --\n+         --    * Denote an assignment statement whose target is Ghost\n \n          -----------------------\n          -- Is_OK_Declaration --\n@@ -192,10 +212,6 @@ package body Ghost is\n             --  Determine whether node N appears in the profile of a subprogram\n             --  body.\n \n-            function Is_Ghost_Renaming (Ren_Decl : Node_Id) return Boolean;\n-            --  Determine whether node Ren_Decl denotes a renaming declaration\n-            --  with a Ghost name.\n-\n             --------------------------------\n             -- In_Subprogram_Body_Profile --\n             --------------------------------\n@@ -216,23 +232,6 @@ package body Ghost is\n                    and then Nkind (Parent (Spec)) = N_Subprogram_Body;\n             end In_Subprogram_Body_Profile;\n \n-            -----------------------\n-            -- Is_Ghost_Renaming --\n-            -----------------------\n-\n-            function Is_Ghost_Renaming (Ren_Decl : Node_Id) return Boolean is\n-               Nam_Id : Entity_Id;\n-\n-            begin\n-               if Is_Renaming_Declaration (Ren_Decl) then\n-                  Nam_Id := Ghost_Entity (Name (Ren_Decl));\n-\n-                  return Present (Nam_Id) and then Is_Ghost_Entity (Nam_Id);\n-               end if;\n-\n-               return False;\n-            end Is_Ghost_Renaming;\n-\n             --  Local variables\n \n             Subp_Decl : Node_Id;\n@@ -241,20 +240,8 @@ package body Ghost is\n          --  Start of processing for Is_OK_Declaration\n \n          begin\n-            if Is_Declaration (Decl) then\n-\n-               --  A renaming declaration is Ghost when it renames a Ghost\n-               --  entity.\n-\n-               if Is_Ghost_Renaming (Decl) then\n-                  return True;\n-\n-               --  The declaration may not have been analyzed yet, determine\n-               --  whether it is subject to pragma Ghost.\n-\n-               elsif Is_Subject_To_Ghost (Decl) then\n-                  return True;\n-               end if;\n+            if Is_Ghost_Declaration (Decl) then\n+               return True;\n \n             --  Special cases\n \n@@ -303,7 +290,7 @@ package body Ghost is\n                      --  OK as long as the initial declaration is Ghost.\n \n                      if Nkind (Subp_Decl) = N_Expression_Function then\n-                        return Is_Subject_To_Ghost (Subp_Decl);\n+                        return Is_Ghost_Declaration (Subp_Decl);\n                      end if;\n                   end if;\n \n@@ -358,8 +345,6 @@ package body Ghost is\n \n             --  Local variables\n \n-            Arg      : Node_Id;\n-            Arg_Id   : Entity_Id;\n             Prag_Id  : Pragma_Id;\n             Prag_Nam : Name_Id;\n \n@@ -399,21 +384,6 @@ package body Ghost is\n                                        Name_Refined_State)\n                then\n                   return True;\n-\n-               --  Otherwise a normal pragma is Ghost when it encloses a Ghost\n-               --  name (SPARK RM 6.9(3)).\n-\n-               else\n-                  Arg := First (Pragma_Argument_Associations (Prag));\n-                  while Present (Arg) loop\n-                     Arg_Id := Ghost_Entity (Get_Pragma_Arg (Arg));\n-\n-                     if Present (Arg_Id) and then Is_Ghost_Entity (Arg_Id) then\n-                        return True;\n-                     end if;\n-\n-                     Next (Arg);\n-                  end loop;\n                end if;\n             end if;\n \n@@ -425,18 +395,17 @@ package body Ghost is\n          ---------------------\n \n          function Is_OK_Statement (Stmt : Node_Id) return Boolean is\n-            Nam_Id : Entity_Id;\n-\n          begin\n-            --  An assignment statement or a procedure call is Ghost when the\n-            --  name denotes a Ghost entity.\n+            --  An assignment statement is Ghost when the target is a Ghost\n+            --  entity.\n \n-            if Nkind_In (Stmt, N_Assignment_Statement,\n-                               N_Procedure_Call_Statement)\n-            then\n-               Nam_Id := Ghost_Entity (Name (Stmt));\n+            if Nkind (Stmt) = N_Assignment_Statement then\n+               return Is_Ghost_Assignment (Stmt);\n \n-               return Present (Nam_Id) and then Is_Ghost_Entity (Nam_Id);\n+            --  A procedure call is Ghost when it calls a Ghost procedure\n+\n+            elsif Nkind (Stmt) = N_Procedure_Call_Statement then\n+               return Is_Ghost_Procedure_Call (Stmt);\n \n             --  Special cases\n \n@@ -829,7 +798,7 @@ package body Ghost is\n       Ref : Node_Id;\n \n    begin\n-      --  When the reference extracts a subcomponent, recover the related\n+      --  When the reference denotes a subcomponent, recover the related\n       --  object (SPARK RM 6.9(1)).\n \n       Ref := N;\n@@ -881,6 +850,96 @@ package body Ghost is\n       Ignored_Ghost_Units.Init;\n    end Initialize;\n \n+   ------------------------\n+   -- Install_Ghost_Mode --\n+   ------------------------\n+\n+   procedure Install_Ghost_Mode (Mode : Ghost_Mode_Type) is\n+   begin\n+      Ghost_Mode := Mode;\n+   end Install_Ghost_Mode;\n+\n+   procedure Install_Ghost_Mode (Mode : Name_Id) is\n+   begin\n+      if Mode = Name_Check then\n+         Ghost_Mode := Check;\n+\n+      elsif Mode = Name_Ignore then\n+         Ghost_Mode := Ignore;\n+\n+      elsif Mode = Name_None then\n+         Ghost_Mode := None;\n+      end if;\n+   end Install_Ghost_Mode;\n+\n+   -------------------------\n+   -- Is_Ghost_Assignment --\n+   -------------------------\n+\n+   function Is_Ghost_Assignment (N : Node_Id) return Boolean is\n+      Id : Entity_Id;\n+\n+   begin\n+      --  An assignment statement is Ghost when its target denotes a Ghost\n+      --  entity.\n+\n+      if Nkind (N) = N_Assignment_Statement then\n+         Id := Ghost_Entity (Name (N));\n+\n+         return Present (Id) and then Is_Ghost_Entity (Id);\n+      end if;\n+\n+      return False;\n+   end Is_Ghost_Assignment;\n+\n+   --------------------------\n+   -- Is_Ghost_Declaration --\n+   --------------------------\n+\n+   function Is_Ghost_Declaration (N : Node_Id) return Boolean is\n+      Id : Entity_Id;\n+\n+   begin\n+      --  A declaration is Ghost when it elaborates a Ghost entity or is\n+      --  subject to pragma Ghost.\n+\n+      if Is_Declaration (N) then\n+         Id := Defining_Entity (N);\n+\n+         return Is_Ghost_Entity (Id) or else Is_Subject_To_Ghost (N);\n+      end if;\n+\n+      return False;\n+   end Is_Ghost_Declaration;\n+\n+   ---------------------\n+   -- Is_Ghost_Pragma --\n+   ---------------------\n+\n+   function Is_Ghost_Pragma (N : Node_Id) return Boolean is\n+   begin\n+      return Is_Checked_Ghost_Pragma (N) or else Is_Ignored_Ghost_Pragma (N);\n+   end Is_Ghost_Pragma;\n+\n+   -----------------------------\n+   -- Is_Ghost_Procedure_Call --\n+   -----------------------------\n+\n+   function Is_Ghost_Procedure_Call (N : Node_Id) return Boolean is\n+      Id : Entity_Id;\n+\n+   begin\n+      --  A procedure call is Ghost when it invokes a Ghost procedure\n+\n+      if Nkind (N) = N_Procedure_Call_Statement then\n+         Id := Ghost_Entity (Name (N));\n+\n+         return Present (Id) and then Is_Ghost_Entity (Id);\n+      end if;\n+\n+      return False;\n+   end Is_Ghost_Procedure_Call;\n+\n    -------------------------\n    -- Is_Subject_To_Ghost --\n    -------------------------\n@@ -1021,66 +1080,399 @@ package body Ghost is\n       Ignored_Ghost_Units.Release;\n    end Lock;\n \n+   -----------------------------------\n+   -- Mark_And_Set_Ghost_Assignment --\n+   -----------------------------------\n+\n+   procedure Mark_And_Set_Ghost_Assignment\n+     (N    : Node_Id;\n+      Mode : out Ghost_Mode_Type)\n+   is\n+      Id : Entity_Id;\n+\n+   begin\n+      --  Save the previous Ghost mode in effect\n+\n+      Mode := Ghost_Mode;\n+\n+      --  An assignment statement becomes Ghost when its target denotes a Ghost\n+      --  object. Install the Ghost mode of the target.\n+\n+      Id := Ghost_Entity (Name (N));\n+\n+      if Present (Id) then\n+         if Is_Checked_Ghost_Entity (Id) then\n+            Install_Ghost_Mode (Check);\n+\n+         elsif Is_Ignored_Ghost_Entity (Id) then\n+            Install_Ghost_Mode (Ignore);\n+\n+            Set_Is_Ignored_Ghost_Node (N);\n+            Propagate_Ignored_Ghost_Code (N);\n+         end if;\n+      end if;\n+   end Mark_And_Set_Ghost_Assignment;\n+\n    -----------------------------\n-   -- Mark_Full_View_As_Ghost --\n+   -- Mark_And_Set_Ghost_Body --\n    -----------------------------\n \n-   procedure Mark_Full_View_As_Ghost\n-     (Priv_Typ : Entity_Id;\n-      Full_Typ : Entity_Id)\n+   procedure Mark_And_Set_Ghost_Body\n+     (N       : Node_Id;\n+      Spec_Id : Entity_Id;\n+      Mode    : out Ghost_Mode_Type)\n    is\n-      Full_Decl : constant Node_Id := Declaration_Node (Full_Typ);\n+      Body_Id : constant Entity_Id := Defining_Entity (N);\n+      Policy  : Name_Id := No_Name;\n \n    begin\n-      if Is_Checked_Ghost_Entity (Priv_Typ) then\n-         Set_Is_Checked_Ghost_Entity (Full_Typ);\n+      --  Save the previous Ghost mode in effect\n+\n+      Mode := Ghost_Mode;\n+\n+      --  A body becomes Ghost when it is subject to aspect or pragma Ghost\n \n-      elsif Is_Ignored_Ghost_Entity (Priv_Typ) then\n-         Set_Is_Ignored_Ghost_Entity (Full_Typ);\n-         Set_Is_Ignored_Ghost_Node (Full_Decl);\n-         Propagate_Ignored_Ghost_Code (Full_Decl);\n+      if Is_Subject_To_Ghost (N) then\n+         Policy := Policy_In_Effect (Name_Ghost);\n+\n+      --  A body declared within a Ghost region is automatically Ghost\n+      --  (SPARK RM 6.9(2)).\n+\n+      elsif Ghost_Mode = Check then\n+         Policy := Name_Check;\n+\n+      elsif Ghost_Mode = Ignore then\n+         Policy := Name_Ignore;\n+\n+      --  Inherit the \"ghostness\" of the previous declaration when the body\n+      --  acts as a completion.\n+\n+      elsif Present (Spec_Id) then\n+         if Is_Checked_Ghost_Entity (Spec_Id) then\n+            Policy := Name_Check;\n+\n+         elsif Is_Ignored_Ghost_Entity (Spec_Id) then\n+            Policy := Name_Ignore;\n+         end if;\n       end if;\n-   end Mark_Full_View_As_Ghost;\n \n-   --------------------------\n-   -- Mark_Pragma_As_Ghost --\n-   --------------------------\n+      --  The Ghost policy in effect at the point of declaration and at the\n+      --  point of completion must match (SPARK RM 6.9(14)).\n+\n+      Check_Ghost_Completion\n+        (Prev_Id  => Spec_Id,\n+         Compl_Id => Body_Id);\n+\n+      --  Mark the body as its formals as Ghost\n+\n+      Mark_Ghost_Declaration_Or_Body (N, Policy);\n+\n+      --  Install the appropriate Ghost mode\n+\n+      Install_Ghost_Mode (Policy);\n+   end Mark_And_Set_Ghost_Body;\n+\n+   -----------------------------------\n+   -- Mark_And_Set_Ghost_Completion --\n+   -----------------------------------\n \n-   procedure Mark_Pragma_As_Ghost\n-     (Prag       : Node_Id;\n-      Context_Id : Entity_Id)\n+   procedure Mark_And_Set_Ghost_Completion\n+     (N       : Node_Id;\n+      Prev_Id : Entity_Id;\n+      Mode    : out Ghost_Mode_Type)\n    is\n+      Compl_Id : constant Entity_Id := Defining_Entity (N);\n+      Policy   : Name_Id := No_Name;\n+\n    begin\n-      if Is_Checked_Ghost_Entity (Context_Id) then\n-         Set_Is_Ghost_Pragma (Prag);\n+      --  Save the previous Ghost mode in effect\n+\n+      Mode := Ghost_Mode;\n+\n+      --  A completion elaborated in a Ghost region is automatically Ghost\n+      --  (SPARK RM 6.9(2)).\n+\n+      if Ghost_Mode = Check then\n+         Policy := Name_Check;\n+\n+      elsif Ghost_Mode = Ignore then\n+         Policy := Name_Ignore;\n+\n+      --  The completion becomes Ghost when its initial declaration is also\n+      --  Ghost.\n+\n+      elsif Is_Checked_Ghost_Entity (Prev_Id) then\n+         Policy := Name_Check;\n \n-      elsif Is_Ignored_Ghost_Entity (Context_Id) then\n-         Set_Is_Ghost_Pragma (Prag);\n-         Set_Is_Ignored_Ghost_Node (Prag);\n-         Propagate_Ignored_Ghost_Code (Prag);\n+      elsif Is_Ignored_Ghost_Entity (Prev_Id) then\n+         Policy := Name_Ignore;\n       end if;\n-   end Mark_Pragma_As_Ghost;\n \n-   ----------------------------\n-   -- Mark_Renaming_As_Ghost --\n-   ----------------------------\n+      --  The Ghost policy in effect at the point of declaration and at the\n+      --  point of completion must match (SPARK RM 6.9(14)).\n+\n+      Check_Ghost_Completion\n+        (Prev_Id  => Prev_Id,\n+         Compl_Id => Compl_Id);\n+\n+      --  Mark the completion as Ghost\n+\n+      Mark_Ghost_Declaration_Or_Body (N, Policy);\n+\n+      --  Install the appropriate Ghost mode\n+\n+      Install_Ghost_Mode (Policy);\n+   end Mark_And_Set_Ghost_Completion;\n \n-   procedure Mark_Renaming_As_Ghost\n-     (Ren_Decl : Node_Id;\n-      Nam_Id   : Entity_Id)\n+   ------------------------------------\n+   -- Mark_And_Set_Ghost_Declaration --\n+   ------------------------------------\n+\n+   procedure Mark_And_Set_Ghost_Declaration\n+     (N    : Node_Id;\n+      Mode : out Ghost_Mode_Type)\n    is\n-      Ren_Id : constant Entity_Id := Defining_Entity (Ren_Decl);\n+      Par_Id : Entity_Id;\n+      Policy : Name_Id := No_Name;\n \n    begin\n-      if Is_Checked_Ghost_Entity (Nam_Id) then\n-         Set_Is_Checked_Ghost_Entity (Ren_Id);\n+      --  Save the previous Ghost mode in effect\n+\n+      Mode := Ghost_Mode;\n+\n+      --  A declaration becomes Ghost when it is subject to aspect or pragma\n+      --  Ghost.\n+\n+      if Is_Subject_To_Ghost (N) then\n+         Policy := Policy_In_Effect (Name_Ghost);\n+\n+      --  A declaration elaborated in a Ghost region is automatically Ghost\n+      --  (SPARK RM 6.9(2)).\n+\n+      elsif Ghost_Mode = Check then\n+         Policy := Name_Check;\n+\n+      elsif Ghost_Mode = Ignore then\n+         Policy := Name_Ignore;\n+\n+      --  A child package or subprogram declaration becomes Ghost when its\n+      --  parent is Ghost (SPARK RM 6.9(2)).\n \n-      elsif Is_Ignored_Ghost_Entity (Nam_Id) then\n-         Set_Is_Ignored_Ghost_Entity (Ren_Id);\n-         Set_Is_Ignored_Ghost_Node (Ren_Decl);\n-         Propagate_Ignored_Ghost_Code (Ren_Decl);\n+      elsif Nkind_In (N, N_Generic_Function_Renaming_Declaration,\n+                         N_Generic_Package_Declaration,\n+                         N_Generic_Package_Renaming_Declaration,\n+                         N_Generic_Procedure_Renaming_Declaration,\n+                         N_Generic_Subprogram_Declaration,\n+                         N_Package_Declaration,\n+                         N_Package_Renaming_Declaration,\n+                         N_Subprogram_Declaration,\n+                         N_Subprogram_Renaming_Declaration)\n+        and then Present (Parent_Spec (N))\n+      then\n+         Par_Id := Defining_Entity (Unit (Parent_Spec (N)));\n+\n+         if Is_Checked_Ghost_Entity (Par_Id) then\n+            Policy := Name_Check;\n+\n+         elsif Is_Ignored_Ghost_Entity (Par_Id) then\n+            Policy := Name_Ignore;\n+         end if;\n+      end if;\n+\n+      --  Mark the declaration and its formals as Ghost\n+\n+      Mark_Ghost_Declaration_Or_Body (N, Policy);\n+\n+      --  Install the appropriate Ghost mode\n+\n+      Install_Ghost_Mode (Policy);\n+   end Mark_And_Set_Ghost_Declaration;\n+\n+   --------------------------------------\n+   -- Mark_And_Set_Ghost_Instantiation --\n+   --------------------------------------\n+\n+   procedure Mark_And_Set_Ghost_Instantiation\n+     (N      : Node_Id;\n+      Gen_Id : Entity_Id;\n+      Mode   : out Ghost_Mode_Type)\n+   is\n+      Policy : Name_Id := No_Name;\n+\n+   begin\n+      --  Save the previous Ghost mode in effect\n+\n+      Mode := Ghost_Mode;\n+\n+      --  An instantiation becomes Ghost when it is subject to pragma Ghost\n+\n+      if Is_Subject_To_Ghost (N) then\n+         Policy := Policy_In_Effect (Name_Ghost);\n+\n+      --  An instantiation declaration within a Ghost region is automatically\n+      --  Ghost (SPARK RM 6.9(2)).\n+\n+      elsif Ghost_Mode = Check then\n+         Policy := Name_Check;\n+\n+      elsif Ghost_Mode = Ignore then\n+         Policy := Name_Ignore;\n+\n+      --  Inherit the \"ghostness\" of the generic unit\n+\n+      elsif Is_Checked_Ghost_Entity (Gen_Id) then\n+         Policy := Name_Check;\n+\n+      elsif Is_Ignored_Ghost_Entity (Gen_Id) then\n+         Policy := Name_Ignore;\n+      end if;\n+\n+      --  Mark the instantiation as Ghost\n+\n+      Mark_Ghost_Declaration_Or_Body (N, Policy);\n+\n+      --  Install the appropriate Ghost mode\n+\n+      Install_Ghost_Mode (Policy);\n+   end Mark_And_Set_Ghost_Instantiation;\n+\n+   ---------------------------------------\n+   -- Mark_And_Set_Ghost_Procedure_Call --\n+   ---------------------------------------\n+\n+   procedure Mark_And_Set_Ghost_Procedure_Call\n+     (N    : Node_Id;\n+      Mode : out Ghost_Mode_Type)\n+   is\n+      Id : Entity_Id;\n+\n+   begin\n+      --  Save the previous Ghost mode in effect\n+\n+      Mode := Ghost_Mode;\n+\n+      --  A procedure call becomes Ghost when the procedure being invoked is\n+      --  Ghost. Install the Ghost mode of the procedure.\n+\n+      Id := Ghost_Entity (Name (N));\n+\n+      if Present (Id) then\n+         if Is_Checked_Ghost_Entity (Id) then\n+            Install_Ghost_Mode (Check);\n+\n+         elsif Is_Ignored_Ghost_Entity (Id) then\n+            Install_Ghost_Mode (Ignore);\n+\n+            Set_Is_Ignored_Ghost_Node (N);\n+            Propagate_Ignored_Ghost_Code (N);\n+         end if;\n+      end if;\n+   end Mark_And_Set_Ghost_Procedure_Call;\n+\n+   ------------------------------------\n+   -- Mark_Ghost_Declaration_Or_Body --\n+   ------------------------------------\n+\n+   procedure Mark_Ghost_Declaration_Or_Body\n+     (N    : Node_Id;\n+      Mode : Name_Id)\n+   is\n+      Id : constant Entity_Id := Defining_Entity (N);\n+\n+      Mark_Formals : Boolean := False;\n+      Param        : Node_Id;\n+      Param_Id     : Entity_Id;\n+\n+   begin\n+      --  Mark the related node and its entity\n+\n+      if Mode = Name_Check then\n+         Mark_Formals := True;\n+         Set_Is_Checked_Ghost_Entity (Id);\n+\n+      elsif Mode = Name_Ignore then\n+         Mark_Formals := True;\n+         Set_Is_Ignored_Ghost_Entity (Id);\n+         Set_Is_Ignored_Ghost_Node (N);\n+         Propagate_Ignored_Ghost_Code (N);\n+      end if;\n+\n+      --  Mark all formal parameters when the related node denotes a subprogram\n+      --  or a body. The traversal is performed via the specification because\n+      --  the related subprogram or body may be unanalyzed.\n+\n+      --  ??? could extra formal parameters cause a Ghost leak?\n+\n+      if Mark_Formals\n+        and then Nkind_In (N, N_Abstract_Subprogram_Declaration,\n+                              N_Formal_Abstract_Subprogram_Declaration,\n+                              N_Formal_Concrete_Subprogram_Declaration,\n+                              N_Generic_Subprogram_Declaration,\n+                              N_Subprogram_Body,\n+                              N_Subprogram_Body_Stub,\n+                              N_Subprogram_Declaration,\n+                              N_Subprogram_Renaming_Declaration)\n+      then\n+         Param := First (Parameter_Specifications (Specification (N)));\n+         while Present (Param) loop\n+            Param_Id := Defining_Entity (Param);\n+\n+            if Mode = Name_Check then\n+               Set_Is_Checked_Ghost_Entity (Param_Id);\n+\n+            elsif Mode = Name_Ignore then\n+               Set_Is_Ignored_Ghost_Entity (Param_Id);\n+            end if;\n+\n+            Next (Param);\n+         end loop;\n+      end if;\n+   end Mark_Ghost_Declaration_Or_Body;\n+\n+   -----------------------\n+   -- Mark_Ghost_Pragma --\n+   -----------------------\n+\n+   procedure Mark_Ghost_Pragma\n+     (N  : Node_Id;\n+      Id : Entity_Id)\n+   is\n+   begin\n+      --  A pragma becomes Ghost when it encloses a Ghost entity or relates to\n+      --  a Ghost entity.\n+\n+      if Is_Checked_Ghost_Entity (Id) then\n+         Set_Is_Checked_Ghost_Pragma (N);\n+\n+      elsif Is_Ignored_Ghost_Entity (Id) then\n+         Set_Is_Ignored_Ghost_Pragma (N);\n+         Set_Is_Ignored_Ghost_Node (N);\n+         Propagate_Ignored_Ghost_Code (N);\n+      end if;\n+   end Mark_Ghost_Pragma;\n+\n+   -------------------------\n+   -- Mark_Ghost_Renaming --\n+   -------------------------\n+\n+   procedure Mark_Ghost_Renaming\n+     (N  : Node_Id;\n+      Id : Entity_Id)\n+   is\n+      Policy : Name_Id := No_Name;\n+\n+   begin\n+      --  A renaming becomes Ghost when it renames a Ghost entity\n+\n+      if Is_Checked_Ghost_Entity (Id) then\n+         Policy := Name_Check;\n+\n+      elsif Is_Ignored_Ghost_Entity (Id) then\n+         Policy := Name_Ignore;\n       end if;\n-   end Mark_Renaming_As_Ghost;\n+\n+      Mark_Ghost_Declaration_Or_Body (N, Policy);\n+   end Mark_Ghost_Renaming;\n \n    ----------------------------------\n    -- Propagate_Ignored_Ghost_Code --\n@@ -1091,7 +1483,7 @@ package body Ghost is\n       Scop : Entity_Id;\n \n    begin\n-      --  Traverse the parent chain looking for blocks, packages and\n+      --  Traverse the parent chain looking for blocks, packages, and\n       --  subprograms or their respective bodies.\n \n       Nod := Parent (N);\n@@ -1187,17 +1579,6 @@ package body Ghost is\n                Prune (N);\n                return Skip;\n \n-            --  A freeze node for an ignored ghost entity must be pruned as\n-            --  well, to prevent meaningless references in the back end.\n-\n-            --  ??? the freeze node itself should be ignored ghost\n-\n-            elsif Nkind (N) = N_Freeze_Entity\n-              and then Is_Ignored_Ghost_Entity (Entity (N))\n-            then\n-               Prune (N);\n-               return Skip;\n-\n             --  Scoping constructs such as blocks, packages, subprograms and\n             --  bodies offer some flexibility with respect to pruning.\n \n@@ -1249,134 +1630,102 @@ package body Ghost is\n       end loop;\n    end Remove_Ignored_Ghost_Code;\n \n+   ------------------------\n+   -- Restore_Ghost_Mode --\n+   ------------------------\n+\n+   procedure Restore_Ghost_Mode (Mode : Ghost_Mode_Type) is\n+   begin\n+      Ghost_Mode := Mode;\n+   end Restore_Ghost_Mode;\n+\n    --------------------\n    -- Set_Ghost_Mode --\n    --------------------\n \n-   procedure Set_Ghost_Mode (N : Node_Id; Id : Entity_Id := Empty) is\n-      procedure Set_From_Entity (Ent_Id : Entity_Id);\n-      --  Set the value of global variable Ghost_Mode depending on the mode of\n-      --  entity Ent_Id.\n-\n-      procedure Set_From_Policy;\n-      --  Set the value of global variable Ghost_Mode depending on the current\n-      --  Ghost policy in effect.\n-\n-      ---------------------\n-      -- Set_From_Entity --\n-      ---------------------\n-\n-      procedure Set_From_Entity (Ent_Id : Entity_Id) is\n-      begin\n-         Set_Ghost_Mode_From_Entity (Ent_Id);\n-\n-         if Is_Ignored_Ghost_Entity (Ent_Id) then\n-            Set_Is_Ignored_Ghost_Node (N);\n-            Propagate_Ignored_Ghost_Code (N);\n-         end if;\n-      end Set_From_Entity;\n+   procedure Set_Ghost_Mode\n+     (N    : Node_Or_Entity_Id;\n+      Mode : out Ghost_Mode_Type)\n+   is\n+      procedure Set_Ghost_Mode_From_Entity (Id : Entity_Id);\n+      --  Install the Ghost mode of entity Id\n \n-      ---------------------\n-      -- Set_From_Policy --\n-      ---------------------\n-\n-      procedure Set_From_Policy is\n-         Policy : constant Name_Id := Policy_In_Effect (Name_Ghost);\n+      --------------------------------\n+      -- Set_Ghost_Mode_From_Entity --\n+      --------------------------------\n \n+      procedure Set_Ghost_Mode_From_Entity (Id : Entity_Id) is\n       begin\n-         if Policy = Name_Check then\n-            Ghost_Mode := Check;\n-\n-         elsif Policy = Name_Ignore then\n-            Ghost_Mode := Ignore;\n-\n-            Set_Is_Ignored_Ghost_Node (N);\n-            Propagate_Ignored_Ghost_Code (N);\n+         if Is_Checked_Ghost_Entity (Id) then\n+            Install_Ghost_Mode (Check);\n+         elsif Is_Ignored_Ghost_Entity (Id) then\n+            Install_Ghost_Mode (Ignore);\n+         else\n+            Install_Ghost_Mode (None);\n          end if;\n-      end Set_From_Policy;\n+      end Set_Ghost_Mode_From_Entity;\n \n       --  Local variables\n \n-      Nam_Id : Entity_Id;\n+      Id : Entity_Id;\n \n    --  Start of processing for Set_Ghost_Mode\n \n    begin\n-      --  The input node denotes one of the many declaration kinds that may be\n-      --  subject to pragma Ghost.\n-\n-      if Is_Declaration (N) then\n-         if Is_Subject_To_Ghost (N) then\n-            Set_From_Policy;\n+      --  Save the previous Ghost mode in effect\n \n-         --  The declaration denotes the completion of a deferred constant,\n-         --  pragma Ghost appears on the partial declaration.\n+      Mode := Ghost_Mode;\n \n-         elsif Nkind (N) = N_Object_Declaration\n-           and then Constant_Present (N)\n-           and then Present (Id)\n-         then\n-            Set_From_Entity (Id);\n+      --  The Ghost mode of an assignment statement depends on the Ghost mode\n+      --  of the target.\n \n-         --  The declaration denotes the full view of a private type, pragma\n-         --  Ghost appears on the partial declaration.\n+      if Nkind (N) = N_Assignment_Statement then\n+         Id := Ghost_Entity (Name (N));\n \n-         elsif Nkind (N) = N_Full_Type_Declaration\n-           and then Is_Private_Type (Defining_Entity (N))\n-           and then Present (Id)\n-         then\n-            Set_From_Entity (Id);\n+         if Present (Id) then\n+            Set_Ghost_Mode_From_Entity (Id);\n          end if;\n \n-      --  The input denotes an assignment or a procedure call. In this case\n-      --  the Ghost mode is dictated by the name of the construct.\n+      --  The Ghost mode of a body or a declaration depends on the Ghost mode\n+      --  of its defining entity.\n \n-      elsif Nkind_In (N, N_Assignment_Statement,\n-                         N_Procedure_Call_Statement)\n-      then\n-         Nam_Id := Ghost_Entity (Name (N));\n+      elsif Is_Body (N) or else Is_Declaration (N) then\n+         Set_Ghost_Mode_From_Entity (Defining_Entity (N));\n \n-         if Present (Nam_Id) then\n-            Set_From_Entity (Nam_Id);\n-         end if;\n+      --  The Ghost mode of an entity depends on the entity itself\n \n-      --  The input denotes a package or subprogram body\n+      elsif Nkind (N) in N_Entity then\n+         Set_Ghost_Mode_From_Entity (N);\n \n-      elsif Nkind_In (N, N_Package_Body, N_Subprogram_Body) then\n-         if (Present (Id) and then Is_Ghost_Entity (Id))\n-           or else Is_Subject_To_Ghost (N)\n-         then\n-            Set_From_Policy;\n-         end if;\n+      --  The Ghost mode of a [generic] freeze node depends on the Ghost mode\n+      --  of the entity being frozen.\n+\n+      elsif Nkind_In (N, N_Freeze_Entity, N_Freeze_Generic_Entity) then\n+         Set_Ghost_Mode_From_Entity (Entity (N));\n \n-      --  The input denotes a pragma\n+      --  The Ghost mode of a pragma depends on the associated entity. The\n+      --  property is encoded in the pragma itself.\n \n-      elsif Nkind (N) = N_Pragma and then Is_Ghost_Pragma (N) then\n-         if Is_Ignored_Ghost_Node (N) then\n-            Ghost_Mode := Ignore;\n+      elsif Nkind (N) = N_Pragma then\n+         if Is_Checked_Ghost_Pragma (N) then\n+            Install_Ghost_Mode (Check);\n+         elsif Is_Ignored_Ghost_Pragma (N) then\n+            Install_Ghost_Mode (Ignore);\n          else\n-            Ghost_Mode := Check;\n+            Install_Ghost_Mode (None);\n          end if;\n \n-      --  The input denotes a freeze node\n+      --  The Ghost mode of a procedure call depends on the Ghost mode of the\n+      --  procedure being invoked.\n \n-      elsif Nkind (N) = N_Freeze_Entity and then Present (Id) then\n-         Set_From_Entity (Id);\n-      end if;\n-   end Set_Ghost_Mode;\n+      elsif Nkind (N) = N_Procedure_Call_Statement then\n+         Id := Ghost_Entity (Name (N));\n \n-   --------------------------------\n-   -- Set_Ghost_Mode_From_Entity --\n-   --------------------------------\n-\n-   procedure Set_Ghost_Mode_From_Entity (Id : Entity_Id) is\n-   begin\n-      if Is_Checked_Ghost_Entity (Id) then\n-         Ghost_Mode := Check;\n-      elsif Is_Ignored_Ghost_Entity (Id) then\n-         Ghost_Mode := Ignore;\n+         if Present (Id) then\n+            Set_Ghost_Mode_From_Entity (Id);\n+         end if;\n       end if;\n-   end Set_Ghost_Mode_From_Entity;\n+   end Set_Ghost_Mode;\n \n    -------------------------\n    -- Set_Is_Ghost_Entity --"}, {"sha": "d5f11dfd6fd05a0334941241a5121641821a74ad", "filename": "gcc/ada/ghost.ads", "status": "modified", "additions": 139, "deletions": 57, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fghost.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fghost.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fghost.ads?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2014-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2014-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,6 +26,7 @@\n --  This package contains routines that deal with the static and runtime\n --  semantics of Ghost entities.\n \n+with Opt;   use Opt;\n with Types; use Types;\n \n package Ghost is\n@@ -35,13 +36,15 @@ package Ghost is\n    --  post processing.\n \n    procedure Check_Ghost_Completion\n-     (Partial_View : Entity_Id;\n-      Full_View    : Entity_Id);\n-   --  Verify that the Ghost policy of a full view or a completion is the same\n-   --  as the Ghost policy of the partial view. Emit an error if this is not\n-   --  the case.\n-\n-   procedure Check_Ghost_Context (Ghost_Id : Entity_Id; Ghost_Ref : Node_Id);\n+     (Prev_Id  : Entity_Id;\n+      Compl_Id : Entity_Id);\n+   --  Verify that the Ghost policy of initial entity Prev_Id is compatible\n+   --  with the Ghost policy of completing entity Compl_Id. Emit an error if\n+   --  this is not the case.\n+\n+   procedure Check_Ghost_Context\n+     (Ghost_Id  : Entity_Id;\n+      Ghost_Ref : Node_Id);\n    --  Determine whether node Ghost_Ref appears within a Ghost-friendly context\n    --  where Ghost entity Ghost_Id can safely reside.\n \n@@ -71,70 +74,149 @@ package Ghost is\n    procedure Initialize;\n    --  Initialize internal tables\n \n-   procedure Lock;\n-   --  Lock internal tables before calling backend\n+   procedure Install_Ghost_Mode (Mode : Ghost_Mode_Type);\n+   --  Set the value of global variable Ghost_Mode depending on the Ghost\n+   --  policy denoted by Mode.\n \n-   procedure Mark_Full_View_As_Ghost\n-     (Priv_Typ : Entity_Id;\n-      Full_Typ : Entity_Id);\n-   --  Set all Ghost-related attributes of type Full_Typ depending on the Ghost\n-   --  mode of incomplete or private type Priv_Typ.\n+   function Is_Ghost_Assignment (N : Node_Id) return Boolean;\n+   --  Determine whether arbitrary node N denotes an assignment statement whose\n+   --  target is a Ghost entity.\n \n-   procedure Mark_Pragma_As_Ghost\n-     (Prag       : Node_Id;\n-      Context_Id : Entity_Id);\n-   --  Set all Ghost-related attributes of pragma Prag if its context denoted\n-   --  by Id is a Ghost entity.\n+   function Is_Ghost_Declaration (N : Node_Id) return Boolean;\n+   --  Determine whether arbitrary node N denotes a declaration which defines\n+   --  a Ghost entity.\n \n-   procedure Mark_Renaming_As_Ghost\n-     (Ren_Decl : Node_Id;\n-      Nam_Id   : Entity_Id);\n-   --  Set all Ghost-related attributes of renaming declaration Ren_Decl if its\n-   --  renamed name denoted by Nam_Id is a Ghost entity.\n+   function Is_Ghost_Pragma (N : Node_Id) return Boolean;\n+   --  Determine whether arbitrary node N denotes a pragma which encloses a\n+   --  Ghost entity or is associated with a Ghost entity.\n \n-   procedure Remove_Ignored_Ghost_Code;\n-   --  Remove all code marked as ignored Ghost from the trees of all qualifying\n-   --  units (SPARK RM 6.9(4)).\n-   --\n-   --  WARNING: this is a separate front end pass, care should be taken to keep\n-   --  it optimized.\n+   function Is_Ghost_Procedure_Call (N : Node_Id) return Boolean;\n+   --  Determine whether arbitrary node N denotes a procedure call invoking a\n+   --  Ghost procedure.\n \n-   procedure Set_Ghost_Mode (N : Node_Id; Id : Entity_Id := Empty);\n-   --  Set the value of global variable Ghost_Mode depending on the following\n-   --  scenarios:\n+   procedure Lock;\n+   --  Lock internal tables before calling backend\n+\n+   procedure Mark_And_Set_Ghost_Assignment\n+     (N    : Node_Id;\n+      Mode : out Ghost_Mode_Type);\n+   --  Mark assignment statement N as Ghost when:\n+   --\n+   --    * The left hand side denotes a Ghost entity\n+   --\n+   --  Install the Ghost mode of the assignment statement. Mode is the Ghost\n+   --  mode in effect prior to processing the assignment. This routine starts\n+   --  a Ghost region and must be used in conjunction with Restore_Ghost_Mode.\n+\n+   procedure Mark_And_Set_Ghost_Body\n+     (N       : Node_Id;\n+      Spec_Id : Entity_Id;\n+      Mode    : out Ghost_Mode_Type);\n+   --  Mark package or subprogram body N as Ghost when:\n+   --\n+   --    * The body is subject to pragma Ghost\n+   --\n+   --    * The body completes a previous declaration whose spec denoted by\n+   --      Spec_Id is a Ghost entity.\n+   --\n+   --    * The body appears within a Ghost region\n    --\n-   --    If N is a declaration, determine whether N is subject to pragma Ghost.\n-   --    If this is the case, the Ghost_Mode is set based on the current Ghost\n-   --    policy in effect. Special cases:\n+   --  Install the Ghost mode of the body. Mode is the Ghost mode prior to\n+   --  processing the body. This routine starts a Ghost region and must be\n+   --  used in conjunction with Restore_Ghost_Mode.\n+\n+   procedure Mark_And_Set_Ghost_Completion\n+     (N       : Node_Id;\n+      Prev_Id : Entity_Id;\n+      Mode    : out Ghost_Mode_Type);\n+   --  Mark completion N of a deferred constant or private type [extension]\n+   --  Ghost when:\n    --\n-   --      N is the completion of a deferred constant, the Ghost_Mode is set\n-   --      based on the mode of partial declaration entity denoted by Id.\n+   --    * The entity of the previous declaration denoted by Prev_Id is Ghost\n    --\n-   --      N is the full view of a private type, the Ghost_Mode is set based\n-   --      on the mode of the partial declaration entity denoted by Id.\n+   --    * The completion appears within a Ghost region\n    --\n-   --    If N is an assignment statement or a procedure call, the Ghost_Mode is\n-   --    set based on the mode of the name.\n+   --  Install the Ghost mode of the completion. Mode is the Ghost mode prior\n+   --  to processing the completion. This routine starts a Ghost region and\n+   --  must be used in conjunction with Restore_Ghost_Mode.\n+\n+   procedure Mark_And_Set_Ghost_Declaration\n+     (N    : Node_Id;\n+      Mode : out Ghost_Mode_Type);\n+   --  Mark declaration N as Ghost when:\n    --\n-   --    If N denotes a package or a subprogram body, the Ghost_Mode is set to\n-   --    the current Ghost policy in effect if the body is subject to Ghost or\n-   --    the corresponding spec denoted by Id is a Ghost entity.\n+   --    * The declaration is subject to pragma Ghost\n    --\n-   --    If N is a pragma, the Ghost_Mode is set based on the mode of the\n-   --    pragma.\n+   --    * The declaration denotes a child package or subprogram and the parent\n+   --      is a Ghost unit.\n    --\n-   --    If N is a freeze node, the Global_Mode is set based on the mode of\n-   --    entity Id.\n+   --    * The declaration appears within a Ghost region\n    --\n-   --  WARNING: the caller must save and restore the value of Ghost_Mode in a\n-   --  a stack-like fasion as this routine may override the existing value.\n+   --  Install the Ghost mode of the declaration. Mode is the Ghost mode prior\n+   --  to processing the declaration. This routine starts a Ghost region and\n+   --  must be used in conjunction with Restore_Ghost_Mode.\n+\n+   procedure Mark_And_Set_Ghost_Instantiation\n+     (N      : Node_Id;\n+      Gen_Id : Entity_Id;\n+      Mode   : out Ghost_Mode_Type);\n+   --  Mark instantiation N as Ghost when:\n+   --\n+   --    * The instantiation is subject to pragma Ghost\n+   --\n+   --    * The generic template denoted by Gen_Id is Ghost\n+   --\n+   --    * The instantiation appears within a Ghost region\n+   --\n+   --  Install the Ghost mode of the instantiation. Mode is the Ghost mode\n+   --  prior to processing the instantiation. This routine starts a Ghost\n+   --  region and must be used in conjunction with Restore_Ghost_Mode.\n+\n+   procedure Mark_And_Set_Ghost_Procedure_Call\n+     (N    : Node_Id;\n+      Mode : out Ghost_Mode_Type);\n+   --  Mark procedure call N as Ghost when:\n+   --\n+   --    * The procedure being invoked is a Ghost entity\n+   --\n+   --  Install the Ghost mode of the procedure call. Mode is the Ghost mode\n+   --  prior to processing the procedure call. This routine starts a Ghost\n+   --  region and must be used in conjunction with Restore_Ghost_Mode.\n+\n+   procedure Mark_Ghost_Pragma\n+     (N  : Node_Id;\n+      Id : Entity_Id);\n+   --  Mark pragma N as Ghost when:\n+   --\n+   --    * The pragma encloses Ghost entity Id\n+   --\n+   --    * The pragma is associated with Ghost entity Id\n \n-   procedure Set_Ghost_Mode_From_Entity (Id : Entity_Id);\n-   --  Set the valye of global variable Ghost_Mode depending on the mode of\n-   --  entity Id.\n+   procedure Mark_Ghost_Renaming\n+     (N  : Node_Id;\n+      Id : Entity_Id);\n+   --  Mark renaming declaration N as Ghost when:\n    --\n-   --  WARNING: the caller must save and restore the value of Ghost_Mode in a\n-   --  a stack-like fasion as this routine may override the existing value.\n+   --    * Renamed entity Id denotes a Ghost entity\n+\n+   procedure Remove_Ignored_Ghost_Code;\n+   --  Remove all code marked as ignored Ghost from the trees of all qualifying\n+   --  units (SPARK RM 6.9(4)).\n+   --\n+   --  WARNING: this is a separate front end pass, care should be taken to keep\n+   --  it optimized.\n+\n+   procedure Restore_Ghost_Mode (Mode : Ghost_Mode_Type);\n+   --  Terminate a Ghost region by restoring the Ghost mode prior to the\n+   --  region denoted by Mode. This routine must be used in conjunction\n+   --  with Mark_And_Set_xxx routines as well as Set_Ghost_Mode.\n+\n+   procedure Set_Ghost_Mode\n+     (N    : Node_Or_Entity_Id;\n+      Mode : out Ghost_Mode_Type);\n+   --  Install the Ghost mode of arbitrary node N. Mode is the Ghost mode prior\n+   --  to processing the node. This routine starts a Ghost region and must be\n+   --  used in conjunction with Restore_Ghost_Mode.\n \n    procedure Set_Is_Ghost_Entity (Id : Entity_Id);\n    --  Set the relevant Ghost attributes of entity Id depending on the current"}, {"sha": "75d6e3904b43657f064b758e99d54c4b0e8a032e", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -98,7 +98,8 @@ package body Sem is\n    -------------\n \n    procedure Analyze (N : Node_Id) is\n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n+      Mode     : Ghost_Mode_Type;\n+      Mode_Set : Boolean := False;\n \n    begin\n       Debug_A_Entry (\"analyzing  \", N);\n@@ -115,7 +116,8 @@ package body Sem is\n       --  marked as Ghost.\n \n       if Is_Declaration (N) then\n-         Set_Ghost_Mode (N);\n+         Mark_And_Set_Ghost_Declaration (N, Mode);\n+         Mode_Set := True;\n       end if;\n \n       --  Otherwise processing depends on the node kind\n@@ -747,7 +749,9 @@ package body Sem is\n          Expand_SPARK_Potential_Renaming (N);\n       end if;\n \n-      Ghost_Mode := Save_Ghost_Mode;\n+      if Mode_Set then\n+         Restore_Ghost_Mode (Mode);\n+      end if;\n    end Analyze;\n \n    --  Version with check(s) suppressed\n@@ -1351,7 +1355,7 @@ package body Sem is\n \n          --  Set up a clean environment before analyzing\n \n-         Ghost_Mode          := None;\n+         Install_Ghost_Mode (None);\n          Outer_Generic_Scope := Empty;\n          Scope_Suppress      := Suppress_Options;\n          Scope_Stack.Table\n@@ -1373,7 +1377,7 @@ package body Sem is\n \n          Pop_Scope;\n          Restore_Scope_Stack (List);\n-         Ghost_Mode := Save_Ghost_Mode;\n+         Restore_Ghost_Mode (Save_Ghost_Mode);\n          Style_Max_Line_Length := Save_Max_Line;\n       end Do_Analyze;\n "}, {"sha": "3e71b543c97bef929f41811c9c409fdef197ceeb", "filename": "gcc/ada/sem_ch11.adb", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch11.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -27,7 +27,6 @@ with Atree;    use Atree;\n with Checks;   use Checks;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n-with Ghost;    use Ghost;\n with Lib;      use Lib;\n with Lib.Xref; use Lib.Xref;\n with Namet;    use Namet;\n@@ -67,13 +66,6 @@ package body Sem_Ch11 is\n       Set_Is_Statically_Allocated (Id);\n       Set_Is_Pure                 (Id, PF);\n \n-      --  An exception declared within a Ghost region is automatically Ghost\n-      --  (SPARK RM 6.9(2)).\n-\n-      if Ghost_Mode > None then\n-         Set_Is_Ghost_Entity (Id);\n-      end if;\n-\n       if Has_Aspects (N) then\n          Analyze_Aspect_Specifications (N, Id);\n       end if;"}, {"sha": "89b5586a5ff75692bc3ae06c64806389c1c87704", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 93, "deletions": 65, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -3331,13 +3331,6 @@ package body Sem_Ch12 is\n       Set_Ekind  (Id, E_Generic_Package);\n       Set_Etype  (Id, Standard_Void_Type);\n \n-      --  A generic package declared within a Ghost region is rendered Ghost\n-      --  (SPARK RM 6.9(2)).\n-\n-      if Ghost_Mode > None then\n-         Set_Is_Ghost_Entity (Id);\n-      end if;\n-\n       --  Analyze aspects now, so that generated pragmas appear in the\n       --  declarations before building and analyzing the generic copy.\n \n@@ -3548,13 +3541,6 @@ package body Sem_Ch12 is\n          Set_Etype (Id, Standard_Void_Type);\n       end if;\n \n-      --  A generic subprogram declared within a Ghost region is rendered Ghost\n-      --  (SPARK RM 6.9(2)).\n-\n-      if Ghost_Mode > None then\n-         Set_Is_Ghost_Entity (Id);\n-      end if;\n-\n       --  For a library unit, we have reconstructed the entity for the unit,\n       --  and must reset it in the library tables. We also make sure that\n       --  Body_Required is set properly in the original compilation unit node.\n@@ -3676,6 +3662,8 @@ package body Sem_Ch12 is\n \n       --  Local declarations\n \n+      Mode : Ghost_Mode_Type;\n+\n       Vis_Prims_List : Elist_Id := No_Elist;\n       --  List of primitives made temporarily visible in the instantiation\n       --  to match the visibility of the formal type\n@@ -3746,6 +3734,13 @@ package body Sem_Ch12 is\n       Check_Generic_Child_Unit (Gen_Id, Parent_Installed);\n       Gen_Unit := Entity (Gen_Id);\n \n+      --  A package instantiation is Ghost when it is subject to pragma Ghost\n+      --  or the generic template is Ghost. Set the mode now to ensure that\n+      --  any nodes generated during analysis and expansion are marked as\n+      --  Ghost.\n+\n+      Mark_And_Set_Ghost_Instantiation (N, Gen_Unit, Mode);\n+\n       --  Verify that it is the name of a generic package\n \n       --  A visibility glitch: if the instance is a child unit and the generic\n@@ -4437,6 +4432,8 @@ package body Sem_Ch12 is\n          Analyze_Aspect_Specifications (N, Act_Decl_Id);\n       end if;\n \n+      Restore_Ghost_Mode (Mode);\n+\n    exception\n       when Instantiation_Error =>\n          if Parent_Installed then\n@@ -4451,6 +4448,8 @@ package body Sem_Ch12 is\n          SPARK_Mode               := Save_SM;\n          SPARK_Mode_Pragma        := Save_SMP;\n          Style_Check              := Save_Style_Check;\n+\n+         Restore_Ghost_Mode (Mode);\n    end Analyze_Package_Instantiation;\n \n    --------------------------\n@@ -5084,6 +5083,8 @@ package body Sem_Ch12 is\n \n       --  Local variables\n \n+      Mode : Ghost_Mode_Type;\n+\n       Save_IPSM : constant Boolean := Ignore_Pragma_SPARK_Mode;\n       --  Save flag Ignore_Pragma_SPARK_Mode for restore on exit\n \n@@ -5126,6 +5127,13 @@ package body Sem_Ch12 is\n       Check_Generic_Child_Unit (Gen_Id, Parent_Installed);\n       Gen_Unit := Entity (Gen_Id);\n \n+      --  A subprogram instantiation is Ghost when it is subject to pragma\n+      --  Ghost or the generic template is Ghost. Set the mode now to ensure\n+      --  that any nodes generated during analysis and expansion are marked as\n+      --  Ghost.\n+\n+      Mark_And_Set_Ghost_Instantiation (N, Gen_Unit, Mode);\n+\n       Generate_Reference (Gen_Unit, Gen_Id);\n \n       if Nkind (Gen_Id) = N_Identifier\n@@ -5137,7 +5145,7 @@ package body Sem_Ch12 is\n \n       if Etype (Gen_Unit) = Any_Type then\n          Restore_Env;\n-         return;\n+         goto Leave;\n       end if;\n \n       --  Verify that it is a generic subprogram of the right kind, and that\n@@ -5322,8 +5330,8 @@ package body Sem_Ch12 is\n                      Error_Msg_NE\n                        (\"access parameter& is controlling,\", N, Formal);\n                      Error_Msg_NE\n-                       (\"\\corresponding parameter of & must be \"\n-                       & \"explicitly null-excluding\", N, Gen_Id);\n+                       (\"\\corresponding parameter of & must be explicitly \"\n+                        & \"null-excluding\", N, Gen_Id);\n                   end if;\n \n                   Next_Formal (Formal);\n@@ -5386,6 +5394,8 @@ package body Sem_Ch12 is\n          Analyze_Aspect_Specifications (N, Act_Decl_Id);\n       end if;\n \n+      Restore_Ghost_Mode (Mode);\n+\n    exception\n       when Instantiation_Error =>\n          if Parent_Installed then\n@@ -5399,6 +5409,8 @@ package body Sem_Ch12 is\n          Ignore_Pragma_SPARK_Mode := Save_IPSM;\n          SPARK_Mode               := Save_SM;\n          SPARK_Mode_Pragma        := Save_SMP;\n+\n+         Restore_Ghost_Mode (Mode);\n    end Analyze_Subprogram_Instantiation;\n \n    -------------------------\n@@ -10780,32 +10792,17 @@ package body Sem_Ch12 is\n       Body_Optional : Boolean := False)\n    is\n       Act_Decl    : constant Node_Id    := Body_Info.Act_Decl;\n+      Act_Decl_Id : constant Entity_Id  := Defining_Entity (Act_Decl);\n+      Act_Spec    : constant Node_Id    := Specification (Act_Decl);\n       Inst_Node   : constant Node_Id    := Body_Info.Inst_Node;\n-      Loc         : constant Source_Ptr := Sloc (Inst_Node);\n-\n       Gen_Id      : constant Node_Id    := Name (Inst_Node);\n       Gen_Unit    : constant Entity_Id  := Get_Generic_Entity (Inst_Node);\n       Gen_Decl    : constant Node_Id    := Unit_Declaration_Node (Gen_Unit);\n-      Act_Spec    : constant Node_Id    := Specification (Act_Decl);\n-      Act_Decl_Id : constant Entity_Id  := Defining_Entity (Act_Spec);\n+      Loc         : constant Source_Ptr := Sloc (Inst_Node);\n \n       Save_IPSM        : constant Boolean := Ignore_Pragma_SPARK_Mode;\n       Save_Style_Check : constant Boolean := Style_Check;\n \n-      Act_Body      : Node_Id;\n-      Act_Body_Id   : Entity_Id;\n-      Act_Body_Name : Node_Id;\n-      Gen_Body      : Node_Id;\n-      Gen_Body_Id   : Node_Id;\n-      Par_Ent       : Entity_Id := Empty;\n-      Par_Vis       : Boolean   := False;\n-\n-      Parent_Installed : Boolean := False;\n-\n-      Vis_Prims_List : Elist_Id := No_Elist;\n-      --  List of primitives made temporarily visible in the instantiation\n-      --  to match the visibility of the formal type\n-\n       procedure Check_Initialized_Types;\n       --  In a generic package body, an entity of a generic private type may\n       --  appear uninitialized. This is suspicious, unless the actual is a\n@@ -10874,6 +10871,23 @@ package body Sem_Ch12 is\n          end loop;\n       end Check_Initialized_Types;\n \n+      --  Local variables\n+\n+      Act_Body      : Node_Id;\n+      Act_Body_Id   : Entity_Id;\n+      Act_Body_Name : Node_Id;\n+      Gen_Body      : Node_Id;\n+      Gen_Body_Id   : Node_Id;\n+      Mode          : Ghost_Mode_Type;\n+      Par_Ent       : Entity_Id := Empty;\n+      Par_Vis       : Boolean   := False;\n+\n+      Parent_Installed : Boolean := False;\n+\n+      Vis_Prims_List : Elist_Id := No_Elist;\n+      --  List of primitives made temporarily visible in the instantiation\n+      --  to match the visibility of the formal type.\n+\n    --  Start of processing for Instantiate_Package_Body\n \n    begin\n@@ -10886,6 +10900,12 @@ package body Sem_Ch12 is\n          return;\n       end if;\n \n+      --  The package being instantiated may be subject to pragma Ghost. Set\n+      --  the mode now to ensure that any nodes generated during instantiation\n+      --  are properly marked as Ghost.\n+\n+      Set_Ghost_Mode (Act_Decl_Id, Mode);\n+\n       Expander_Mode_Save_And_Set (Body_Info.Expander_Status);\n \n       --  Re-establish the state of information on which checks are suppressed.\n@@ -10911,7 +10931,7 @@ package body Sem_Ch12 is\n          if not Unit_Requires_Body (Defining_Entity (Gen_Decl))\n            and then Body_Optional\n          then\n-            return;\n+            goto Leave;\n          else\n             Load_Parent_Of_Generic\n               (Inst_Node, Specification (Gen_Decl), Body_Optional);\n@@ -11175,6 +11195,9 @@ package body Sem_Ch12 is\n       end if;\n \n       Expander_Mode_Restore;\n+\n+   <<Leave>>\n+      Restore_Ghost_Mode (Mode);\n    end Instantiate_Package_Body;\n \n    ---------------------------------\n@@ -11186,13 +11209,12 @@ package body Sem_Ch12 is\n       Body_Optional : Boolean := False)\n    is\n       Act_Decl    : constant Node_Id    := Body_Info.Act_Decl;\n+      Act_Decl_Id : constant Entity_Id  := Defining_Entity (Act_Decl);\n       Inst_Node   : constant Node_Id    := Body_Info.Inst_Node;\n-      Loc         : constant Source_Ptr := Sloc (Inst_Node);\n       Gen_Id      : constant Node_Id    := Name (Inst_Node);\n       Gen_Unit    : constant Entity_Id  := Get_Generic_Entity (Inst_Node);\n       Gen_Decl    : constant Node_Id    := Unit_Declaration_Node (Gen_Unit);\n-      Act_Decl_Id : constant Entity_Id  :=\n-                      Defining_Unit_Name (Specification (Act_Decl));\n+      Loc         : constant Source_Ptr := Sloc (Inst_Node);\n       Pack_Id     : constant Entity_Id  :=\n                       Defining_Unit_Name (Parent (Act_Decl));\n \n@@ -11204,6 +11226,7 @@ package body Sem_Ch12 is\n       Act_Body_Id : Entity_Id;\n       Gen_Body    : Node_Id;\n       Gen_Body_Id : Node_Id;\n+      Mode        : Ghost_Mode_Type;\n       Pack_Body   : Node_Id;\n       Par_Ent     : Entity_Id := Empty;\n       Par_Vis     : Boolean   := False;\n@@ -11222,6 +11245,12 @@ package body Sem_Ch12 is\n          return;\n       end if;\n \n+      --  The subprogram being instantiated may be subject to pragma Ghost. Set\n+      --  the mode now to ensure that any nodes generated during instantiation\n+      --  are properly marked as Ghost.\n+\n+      Set_Ghost_Mode (Act_Decl_Id, Mode);\n+\n       Expander_Mode_Save_And_Set (Body_Info.Expander_Status);\n \n       --  Re-establish the state of information on which checks are suppressed.\n@@ -11248,7 +11277,7 @@ package body Sem_Ch12 is\n             Set_Interface_Name (Act_Decl_Id, Interface_Name (Gen_Unit));\n             Set_Convention     (Act_Decl_Id, Convention     (Gen_Unit));\n             Set_Has_Completion (Act_Decl_Id);\n-            return;\n+            goto Leave;\n \n          --  For other cases, compile the body\n \n@@ -11273,12 +11302,11 @@ package body Sem_Ch12 is\n             if Expander_Active\n               and then Operating_Mode = Generate_Code\n             then\n-               Error_Msg_N\n-                 (\"missing proper body for instantiation\", Gen_Body);\n+               Error_Msg_N (\"missing proper body for instantiation\", Gen_Body);\n             end if;\n \n             Set_Has_Completion (Act_Decl_Id);\n-            return;\n+            goto Leave;\n          end if;\n \n          Save_Env (Gen_Unit, Act_Decl_Id);\n@@ -11410,27 +11438,25 @@ package body Sem_Ch12 is\n         and then Nkind (Parent (Inst_Node)) /= N_Compilation_Unit\n       then\n          if Body_Optional then\n-            return;\n+            goto Leave;\n \n          elsif Ekind (Act_Decl_Id) = E_Procedure then\n             Act_Body :=\n               Make_Subprogram_Body (Loc,\n-                 Specification              =>\n-                   Make_Procedure_Specification (Loc,\n-                     Defining_Unit_Name         =>\n-                       Make_Defining_Identifier (Loc, Chars (Act_Decl_Id)),\n-                       Parameter_Specifications =>\n-                       New_Copy_List\n-                         (Parameter_Specifications (Parent (Act_Decl_Id)))),\n-\n-                 Declarations               => Empty_List,\n-                 Handled_Statement_Sequence =>\n-                   Make_Handled_Sequence_Of_Statements (Loc,\n-                     Statements =>\n-                       New_List (\n-                         Make_Raise_Program_Error (Loc,\n-                           Reason =>\n-                             PE_Access_Before_Elaboration))));\n+                Specification              =>\n+                  Make_Procedure_Specification (Loc,\n+                    Defining_Unit_Name       =>\n+                      Make_Defining_Identifier (Loc, Chars (Act_Decl_Id)),\n+                    Parameter_Specifications =>\n+                      New_Copy_List\n+                        (Parameter_Specifications (Parent (Act_Decl_Id)))),\n+\n+                Declarations               => Empty_List,\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements => New_List (\n+                      Make_Raise_Program_Error (Loc,\n+                        Reason => PE_Access_Before_Elaboration))));\n \n          else\n             Ret_Expr :=\n@@ -11444,9 +11470,9 @@ package body Sem_Ch12 is\n               Make_Subprogram_Body (Loc,\n                 Specification =>\n                   Make_Function_Specification (Loc,\n-                     Defining_Unit_Name         =>\n+                     Defining_Unit_Name       =>\n                        Make_Defining_Identifier (Loc, Chars (Act_Decl_Id)),\n-                       Parameter_Specifications =>\n+                     Parameter_Specifications =>\n                        New_Copy_List\n                          (Parameter_Specifications (Parent (Act_Decl_Id))),\n                      Result_Definition =>\n@@ -11455,9 +11481,8 @@ package body Sem_Ch12 is\n                   Declarations               => Empty_List,\n                   Handled_Statement_Sequence =>\n                     Make_Handled_Sequence_Of_Statements (Loc,\n-                      Statements =>\n-                        New_List\n-                          (Make_Simple_Return_Statement (Loc, Ret_Expr))));\n+                      Statements => New_List (\n+                        Make_Simple_Return_Statement (Loc, Ret_Expr))));\n          end if;\n \n          Pack_Body :=\n@@ -11471,6 +11496,9 @@ package body Sem_Ch12 is\n       end if;\n \n       Expander_Mode_Restore;\n+\n+   <<Leave>>\n+      Restore_Ghost_Mode (Mode);\n    end Instantiate_Subprogram_Body;\n \n    ----------------------"}, {"sha": "bb57ad07b717d51511f456f545f2e50337385125", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 26, "deletions": 41, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -8524,7 +8524,7 @@ package body Sem_Ch13 is\n \n       --  Local variables\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n+      Mode : Ghost_Mode_Type;\n \n    --  Start of processing for Build_Predicate_Functions\n \n@@ -8541,7 +8541,7 @@ package body Sem_Ch13 is\n       --  The related type may be subject to pragma Ghost. Set the mode now to\n       --  ensure that the predicate functions are properly marked as Ghost.\n \n-      Set_Ghost_Mode_From_Entity (Typ);\n+      Set_Ghost_Mode (Typ, Mode);\n \n       --  Prepare to construct predicate expression\n \n@@ -8647,20 +8647,12 @@ package body Sem_Ch13 is\n             FBody : Node_Id;\n \n          begin\n-\n             --  The predicate function is shared between views of a type\n \n             if Is_Private_Type (Typ) and then Present (Full_View (Typ)) then\n                Set_Predicate_Function (Full_View (Typ), SId);\n             end if;\n \n-            --  Mark the predicate function explicitly as Ghost because it does\n-            --  not come from source.\n-\n-            if Ghost_Mode > None then\n-               Set_Is_Ghost_Entity (SId);\n-            end if;\n-\n             --  Build function body\n \n             Spec :=\n@@ -8743,13 +8735,6 @@ package body Sem_Ch13 is\n                   Set_Predicate_Function_M (Full_View (Typ), SId);\n                end if;\n \n-               --  Mark the predicate function explicitly as Ghost because it\n-               --  does not come from source.\n-\n-               if Ghost_Mode > None then\n-                  Set_Is_Ghost_Entity (SId);\n-               end if;\n-\n                Spec :=\n                  Make_Function_Specification (Loc,\n                    Defining_Unit_Name       => SId,\n@@ -8902,7 +8887,7 @@ package body Sem_Ch13 is\n          end;\n       end if;\n \n-      Ghost_Mode := Save_Ghost_Mode;\n+      Restore_Ghost_Mode (Mode);\n    end Build_Predicate_Functions;\n \n    ------------------------------------------\n@@ -8914,45 +8899,45 @@ package body Sem_Ch13 is\n    is\n       Loc : constant Source_Ptr := Sloc (Typ);\n \n-      Object_Entity : constant Entity_Id :=\n-                        Make_Defining_Identifier (Loc,\n-                          Chars => New_Internal_Name ('I'));\n-\n-      --  The formal parameter of the function\n+      Func_Decl : Node_Id;\n+      Func_Id   : Entity_Id;\n+      Mode      : Ghost_Mode_Type;\n+      Spec      : Node_Id;\n \n-      SId : constant Entity_Id :=\n-              Make_Defining_Identifier (Loc,\n-                Chars => New_External_Name (Chars (Typ), \"Predicate\"));\n+   begin\n+      --  The related type may be subject to pragma Ghost. Set the mode now to\n+      --  ensure that the predicate functions are properly marked as Ghost.\n \n-      --  The entity for the function spec\n+      Set_Ghost_Mode (Typ, Mode);\n \n-      FDecl : Node_Id;\n-      Spec  : Node_Id;\n+      Func_Id :=\n+        Make_Defining_Identifier (Loc,\n+          Chars => New_External_Name (Chars (Typ), \"Predicate\"));\n \n-   begin\n       Spec :=\n         Make_Function_Specification (Loc,\n-          Defining_Unit_Name       => SId,\n+          Defining_Unit_Name       => Func_Id,\n           Parameter_Specifications => New_List (\n             Make_Parameter_Specification (Loc,\n-              Defining_Identifier => Object_Entity,\n+              Defining_Identifier => Make_Temporary (Loc, 'I'),\n               Parameter_Type      => New_Occurrence_Of (Typ, Loc))),\n           Result_Definition        =>\n             New_Occurrence_Of (Standard_Boolean, Loc));\n \n-      FDecl := Make_Subprogram_Declaration (Loc, Specification => Spec);\n+      Func_Decl := Make_Subprogram_Declaration (Loc, Specification => Spec);\n \n-      Set_Ekind (SId, E_Function);\n-      Set_Etype (SId, Standard_Boolean);\n-      Set_Is_Internal (SId);\n-      Set_Is_Predicate_Function (SId);\n-      Set_Predicate_Function (Typ, SId);\n+      Set_Ekind (Func_Id, E_Function);\n+      Set_Etype (Func_Id, Standard_Boolean);\n+      Set_Is_Internal (Func_Id);\n+      Set_Is_Predicate_Function (Func_Id);\n+      Set_Predicate_Function (Typ, Func_Id);\n \n-      Insert_After (Parent (Typ), FDecl);\n+      Insert_After (Parent (Typ), Func_Decl);\n+      Analyze (Func_Decl);\n \n-      Analyze (FDecl);\n+      Restore_Ghost_Mode (Mode);\n \n-      return FDecl;\n+      return Func_Decl;\n    end Build_Predicate_Function_Declaration;\n \n    -----------------------------------------"}, {"sha": "99d8b58982ee21d862af9af92996936779bbe5cb", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 29, "deletions": 113, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -2824,13 +2824,6 @@ package body Sem_Ch3 is\n       if not Analyzed (T) then\n          Set_Analyzed (T);\n \n-         --  A type declared within a Ghost region is automatically Ghost\n-         --  (SPARK RM 6.9(2)).\n-\n-         if Ghost_Mode > None then\n-            Set_Is_Ghost_Entity (T);\n-         end if;\n-\n          case Nkind (Def) is\n             when N_Access_To_Subprogram_Definition =>\n                Access_Subprogram_Declaration (T, Def);\n@@ -3072,13 +3065,6 @@ package body Sem_Ch3 is\n       Set_Is_First_Subtype (T, True);\n       Set_Etype (T, T);\n \n-      --  An incomplete type declared within a Ghost region is automatically\n-      --  Ghost (SPARK RM 6.9(2)).\n-\n-      if Ghost_Mode > None then\n-         Set_Is_Ghost_Entity (T);\n-      end if;\n-\n       --  Ada 2005 (AI-326): Minimum decoration to give support to tagged\n       --  incomplete types.\n \n@@ -3186,13 +3172,6 @@ package body Sem_Ch3 is\n       Generate_Definition (Id);\n       Enter_Name (Id);\n \n-      --  A number declared within a Ghost region is automatically Ghost\n-      --  (SPARK RM 6.9(2)).\n-\n-      if Ghost_Mode > None then\n-         Set_Is_Ghost_Entity (Id);\n-      end if;\n-\n       --  This is an optimization of a common case of an integer literal\n \n       if Nkind (E) = N_Integer_Literal then\n@@ -3435,8 +3414,9 @@ package body Sem_Ch3 is\n \n       --  Local variables\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-      Related_Id      : Entity_Id;\n+      Mode       : Ghost_Mode_Type;\n+      Mode_Set   : Boolean := False;\n+      Related_Id : Entity_Id;\n \n    --  Start of processing for Analyze_Object_Declaration\n \n@@ -3501,14 +3481,14 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n-      --  The object declaration is Ghost when it is subject to pragma Ghost or\n-      --  completes a deferred Ghost constant. Set the mode now to ensure that\n-      --  any nodes generated during analysis and expansion are properly marked\n-      --  as Ghost.\n+      if Present (Prev_Entity) then\n+\n+         --  The object declaration is Ghost when it completes a deferred Ghost\n+         --  constant.\n \n-      Set_Ghost_Mode (N, Prev_Entity);\n+         Mark_And_Set_Ghost_Completion (N, Prev_Entity, Mode);\n+         Mode_Set := True;\n \n-      if Present (Prev_Entity) then\n          Constant_Redeclaration (Id, N, T);\n \n          Generate_Reference (Prev_Entity, Id, 'c');\n@@ -3802,8 +3782,7 @@ package body Sem_Ch3 is\n            and then Analyzed (N)\n            and then No (Expression (N))\n          then\n-            Ghost_Mode := Save_Ghost_Mode;\n-            return;\n+            goto Leave;\n          end if;\n \n          --  If E is null and has been replaced by an N_Raise_Constraint_Error\n@@ -4061,23 +4040,6 @@ package body Sem_Ch3 is\n                   Set_Ekind (Id, E_Variable);\n                end if;\n \n-               --  An object declared within a Ghost region is automatically\n-               --  Ghost (SPARK RM 6.9(2)).\n-\n-               if Ghost_Mode > None then\n-                  Set_Is_Ghost_Entity (Id);\n-\n-                  --  The Ghost policy in effect at the point of declaration\n-                  --  and at the point of completion must match\n-                  --  (SPARK RM 6.9(14)).\n-\n-                  if Present (Prev_Entity)\n-                    and then Is_Ghost_Entity (Prev_Entity)\n-                  then\n-                     Check_Ghost_Completion (Prev_Entity, Id);\n-                  end if;\n-               end if;\n-\n                Rewrite (N,\n                  Make_Object_Renaming_Declaration (Loc,\n                    Defining_Identifier => Id,\n@@ -4087,9 +4049,7 @@ package body Sem_Ch3 is\n                Set_Renamed_Object (Id, E);\n                Freeze_Before (N, T);\n                Set_Is_Frozen (Id);\n-\n-               Ghost_Mode := Save_Ghost_Mode;\n-               return;\n+               goto Leave;\n \n             else\n                --  Ensure that the generated subtype has a unique external name\n@@ -4263,22 +4223,6 @@ package body Sem_Ch3 is\n       Init_Esize                   (Id);\n       Set_Optimize_Alignment_Flags (Id);\n \n-      --  An object declared within a Ghost region is automatically Ghost\n-      --  (SPARK RM 6.9(2)).\n-\n-      if Ghost_Mode > None\n-        or else (Present (Prev_Entity) and then Is_Ghost_Entity (Prev_Entity))\n-      then\n-         Set_Is_Ghost_Entity (Id);\n-\n-         --  The Ghost policy in effect at the point of declaration and at the\n-         --  point of completion must match (SPARK RM 6.9(14)).\n-\n-         if Present (Prev_Entity) and then Is_Ghost_Entity (Prev_Entity) then\n-            Check_Ghost_Completion (Prev_Entity, Id);\n-         end if;\n-      end if;\n-\n       --  Deal with aliased case\n \n       if Aliased_Present (N) then\n@@ -4481,7 +4425,9 @@ package body Sem_Ch3 is\n          Check_No_Hidden_State (Id);\n       end if;\n \n-      Ghost_Mode := Save_Ghost_Mode;\n+      if Mode_Set then\n+         Restore_Ghost_Mode (Mode);\n+      end if;\n    end Analyze_Object_Declaration;\n \n    ---------------------------\n@@ -5501,13 +5447,13 @@ package body Sem_Ch3 is\n    procedure Array_Type_Declaration (T : in out Entity_Id; Def : Node_Id) is\n       Component_Def : constant Node_Id := Component_Definition (Def);\n       Component_Typ : constant Node_Id := Subtype_Indication (Component_Def);\n+      P             : constant Node_Id := Parent (Def);\n       Element_Type  : Entity_Id;\n       Implicit_Base : Entity_Id;\n       Index         : Node_Id;\n-      Related_Id    : Entity_Id := Empty;\n       Nb_Index      : Nat;\n-      P             : constant Node_Id := Parent (Def);\n       Priv          : Entity_Id;\n+      Related_Id    : Entity_Id := Empty;\n \n    begin\n       if Nkind (Def) = N_Constrained_Array_Definition then\n@@ -5563,8 +5509,8 @@ package body Sem_Ch3 is\n          then\n             declare\n                Loc   : constant Source_Ptr := Sloc (Def);\n-               New_E : Entity_Id;\n                Decl  : Entity_Id;\n+               New_E : Entity_Id;\n \n             begin\n                New_E := Make_Temporary (Loc, 'T');\n@@ -5705,12 +5651,6 @@ package body Sem_Ch3 is\n \n          Propagate_Concurrent_Flags (Implicit_Base, Element_Type);\n \n-         --  Inherit the \"ghostness\" from the constrained array type\n-\n-         if Ghost_Mode > None or else Is_Ghost_Entity (T) then\n-            Set_Is_Ghost_Entity (Implicit_Base);\n-         end if;\n-\n       --  Unconstrained array case\n \n       else\n@@ -6188,12 +6128,6 @@ package body Sem_Ch3 is\n          Copy_Array_Base_Type_Attributes (Implicit_Base, Parent_Base);\n \n          Set_Has_Delayed_Freeze (Implicit_Base, True);\n-\n-         --  Inherit the \"ghostness\" from the parent base type\n-\n-         if Ghost_Mode > None or else Is_Ghost_Entity (Parent_Base) then\n-            Set_Is_Ghost_Entity (Implicit_Base);\n-         end if;\n       end Make_Implicit_Base;\n \n    --  Start of processing for Build_Derived_Array_Type\n@@ -9132,7 +9066,7 @@ package body Sem_Ch3 is\n       --  (anonymous) base type.\n \n       if Has_Predicates (Parent_Type)\n-        or else  Has_Predicates (First_Subtype (Parent_Type))\n+        or else Has_Predicates (First_Subtype (Parent_Type))\n       then\n          Set_Has_Predicates (Derived_Type);\n       end if;\n@@ -9148,8 +9082,9 @@ package body Sem_Ch3 is\n          Set_May_Inherit_Delayed_Rep_Aspects (Derived_Type);\n       end if;\n \n-      --  Propagate the attributes related to pragma Ghost from the parent type\n-      --  to the derived type or type extension (SPARK RM 6.9(9)).\n+      --  A derived type becomes Ghost when its parent type is also Ghost\n+      --  (SPARK RM 6.9(9)). Note that the Ghost-related attributes are not\n+      --  directly inherited because the Ghost policy in effect may differ.\n \n       if Is_Ghost_Entity (Parent_Type) then\n          Set_Is_Ghost_Entity (Derived_Type);\n@@ -14936,12 +14871,6 @@ package body Sem_Ch3 is\n          Set_Alias (New_Subp, Actual_Subp);\n       end if;\n \n-      --  Inherit the \"ghostness\" from the parent subprogram\n-\n-      if Is_Ghost_Entity (Alias (New_Subp)) then\n-         Set_Is_Ghost_Entity (New_Subp);\n-      end if;\n-\n       --  Derived subprograms of a tagged type must inherit the convention\n       --  of the parent subprogram (a requirement of AI-117). Derived\n       --  subprograms of untagged types simply get convention Ada by default.\n@@ -18346,12 +18275,6 @@ package body Sem_Ch3 is\n       --  The class-wide type of a class-wide type is itself (RM 3.9(14))\n \n       Set_Class_Wide_Type (CW_Type, CW_Type);\n-\n-      --  Inherit the \"ghostness\" from the root tagged type\n-\n-      if Ghost_Mode > None or else Is_Ghost_Entity (T) then\n-         Set_Is_Ghost_Entity (CW_Type);\n-      end if;\n    end Make_Class_Wide_Type;\n \n    ----------------\n@@ -19584,11 +19507,14 @@ package body Sem_Ch3 is\n \n       Full_Indic  : Node_Id;\n       Full_Parent : Entity_Id;\n+      Mode        : Ghost_Mode_Type;\n       Priv_Parent : Entity_Id;\n \n    --  Start of processing for Process_Full_View\n \n    begin\n+      Mark_And_Set_Ghost_Completion (N, Priv_T, Mode);\n+\n       --  First some sanity checks that must be done after semantic\n       --  decoration of the full view and thus cannot be placed with other\n       --  similar checks in Find_Type_Name\n@@ -19701,7 +19627,7 @@ package body Sem_Ch3 is\n          --  error situation [7.3(8)].\n \n          if Priv_Parent = Any_Type or else Full_Parent = Any_Type then\n-            return;\n+            goto Leave;\n \n          --  Ada 2005 (AI-251): Interfaces in the full type can be given in\n          --  any order. Therefore we don't have to check that its parent must\n@@ -20053,7 +19979,7 @@ package body Sem_Ch3 is\n                         Next_Elmt (Prim_Elmt);\n                      end loop;\n \n-                     return;\n+                     goto Leave;\n                   end;\n \n                --  For non-concurrent types, transfer explicit primitives, but\n@@ -20190,19 +20116,6 @@ package body Sem_Ch3 is\n          Set_Has_Specified_Stream_Output (Full_T);\n       end if;\n \n-      if Is_Ghost_Entity (Priv_T) then\n-\n-         --  The Ghost policy in effect at the point of declaration and at the\n-         --  point of completion must match (SPARK RM 6.9(14)).\n-\n-         Check_Ghost_Completion (Priv_T, Full_T);\n-\n-         --  Propagate the attributes related to pragma Ghost from the private\n-         --  to the full view.\n-\n-         Mark_Full_View_As_Ghost (Priv_T, Full_T);\n-      end if;\n-\n       --  Propagate Default_Initial_Condition-related attributes from the\n       --  partial view to the full view and its base type.\n \n@@ -20251,6 +20164,9 @@ package body Sem_Ch3 is\n             Set_Predicate_Function (Full_T, Predicate_Function (Priv_T));\n          end if;\n       end if;\n+\n+   <<Leave>>\n+      Restore_Ghost_Mode (Mode);\n    end Process_Full_View;\n \n    -----------------------------------"}, {"sha": "620b562bc2cfa2e8c4493fba1608c4258bb8c403", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -270,7 +270,7 @@ package body Sem_Ch5 is\n \n       --  Local variables\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n+      Mode : Ghost_Mode_Type;\n \n    --  Start of processing for Analyze_Assignment\n \n@@ -287,7 +287,7 @@ package body Sem_Ch5 is\n       --  Ghost entity. Set the mode now to ensure that any nodes generated\n       --  during analysis and expansion are properly marked as Ghost.\n \n-      Set_Ghost_Mode (N);\n+      Mark_And_Set_Ghost_Assignment (N, Mode);\n       Analyze (Rhs);\n \n       --  Ensure that we never do an assignment on a variable marked as\n@@ -356,8 +356,8 @@ package body Sem_Ch5 is\n \n                                     if PIt = No_Interp then\n                                        Error_Msg_N\n-                                         (\"ambiguous left-hand side\"\n-                                            & \" in assignment\", Lhs);\n+                                         (\"ambiguous left-hand side in \"\n+                                          & \"assignment\", Lhs);\n                                        exit;\n                                     else\n                                        Resolve (Prefix (Lhs), PIt.Typ);\n@@ -392,8 +392,7 @@ package body Sem_Ch5 is\n             Error_Msg_N\n               (\"no valid types for left-hand side for assignment\", Lhs);\n             Kill_Lhs;\n-            Ghost_Mode := Save_Ghost_Mode;\n-            return;\n+            goto Leave;\n          end if;\n       end if;\n \n@@ -464,21 +463,20 @@ package body Sem_Ch5 is\n                   --  effect (AARM D.5.2 (5/2)).\n \n                   if Locking_Policy /= 'C' then\n-                     Error_Msg_N (\"assignment to the attribute PRIORITY has \" &\n-                                  \"no effect??\", Lhs);\n-                     Error_Msg_N (\"\\since no Locking_Policy has been \" &\n-                                  \"specified??\", Lhs);\n+                     Error_Msg_N\n+                       (\"assignment to the attribute PRIORITY has no effect??\",\n+                        Lhs);\n+                     Error_Msg_N\n+                       (\"\\since no Locking_Policy has been specified??\", Lhs);\n                   end if;\n \n-                  Ghost_Mode := Save_Ghost_Mode;\n-                  return;\n+                  goto Leave;\n                end if;\n             end if;\n          end;\n \n          Diagnose_Non_Variable_Lhs (Lhs);\n-         Ghost_Mode := Save_Ghost_Mode;\n-         return;\n+         goto Leave;\n \n       --  Error of assigning to limited type. We do however allow this in\n       --  certain cases where the front end generates the assignments.\n@@ -497,17 +495,14 @@ package body Sem_Ch5 is\n             Explain_Limited_Type (T1, Lhs);\n          end if;\n \n-         Ghost_Mode := Save_Ghost_Mode;\n-         return;\n+         goto Leave;\n \n       --  A class-wide type may be a limited view. This illegal case is not\n       --  caught by previous checks.\n \n-      elsif Ekind (T1) = E_Class_Wide_Type\n-        and then From_Limited_With (T1)\n-      then\n+      elsif Ekind (T1) = E_Class_Wide_Type and then From_Limited_With (T1) then\n          Error_Msg_NE (\"invalid use of limited view of&\", Lhs, T1);\n-         return;\n+         goto Leave;\n \n       --  Enforce RM 3.9.3 (8): the target of an assignment operation cannot be\n       --  abstract. This is only checked when the assignment Comes_From_Source,\n@@ -545,8 +540,7 @@ package body Sem_Ch5 is\n       then\n          Error_Msg_N (\"invalid use of incomplete type\", Lhs);\n          Kill_Lhs;\n-         Ghost_Mode := Save_Ghost_Mode;\n-         return;\n+         goto Leave;\n       end if;\n \n       --  Now we can complete the resolution of the right hand side\n@@ -563,17 +557,15 @@ package body Sem_Ch5 is\n \n       if Rhs = Error then\n          Kill_Lhs;\n-         Ghost_Mode := Save_Ghost_Mode;\n-         return;\n+         goto Leave;\n       end if;\n \n       T2 := Etype (Rhs);\n \n       if not Covers (T1, T2) then\n          Wrong_Type (Rhs, Etype (Lhs));\n          Kill_Lhs;\n-         Ghost_Mode := Save_Ghost_Mode;\n-         return;\n+         goto Leave;\n       end if;\n \n       --  Ada 2005 (AI-326): In case of explicit dereference of incomplete\n@@ -600,8 +592,7 @@ package body Sem_Ch5 is\n \n       if T1 = Any_Type or else T2 = Any_Type then\n          Kill_Lhs;\n-         Ghost_Mode := Save_Ghost_Mode;\n-         return;\n+         goto Leave;\n       end if;\n \n       --  If the rhs is class-wide or dynamically tagged, then require the lhs\n@@ -693,8 +684,7 @@ package body Sem_Ch5 is\n             --  to reset Is_True_Constant, and desirable for xref purposes.\n \n             Note_Possible_Modification (Lhs, Sure => True);\n-            Ghost_Mode := Save_Ghost_Mode;\n-            return;\n+            goto Leave;\n \n          --  If we know the right hand side is non-null, then we convert to the\n          --  target type, since we don't need a run time check in that case.\n@@ -914,7 +904,9 @@ package body Sem_Ch5 is\n       end;\n \n       Analyze_Dimension (N);\n-      Ghost_Mode := Save_Ghost_Mode;\n+\n+   <<Leave>>\n+      Restore_Ghost_Mode (Mode);\n    end Analyze_Assignment;\n \n    -----------------------------"}, {"sha": "9d8792ac1579ee9eb9de5f11557556c5d52a993a", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 39, "deletions": 110, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -233,13 +233,6 @@ package body Sem_Ch6 is\n \n       Set_Categorization_From_Scope (Subp_Id, Scop);\n \n-      --  An abstract subprogram declared within a Ghost region is rendered\n-      --  Ghost (SPARK RM 6.9(2)).\n-\n-      if Ghost_Mode > None then\n-         Set_Is_Ghost_Entity (Subp_Id);\n-      end if;\n-\n       if Ekind (Scope (Subp_Id)) = E_Protected_Type then\n          Error_Msg_N (\"abstract subprogram not allowed in protected type\", N);\n \n@@ -502,15 +495,6 @@ package body Sem_Ch6 is\n \n          Set_Is_Inlined (Defining_Entity (N));\n \n-         --  If the expression function is Ghost, mark its body entity as\n-         --  Ghost too. This avoids spurious errors on unanalyzed body entities\n-         --  of expression functions, which are not yet marked as ghost, yet\n-         --  identified as the Corresponding_Body of the ghost declaration.\n-\n-         if Is_Ghost_Entity (Def_Id) then\n-            Set_Is_Ghost_Entity (Defining_Entity (New_Body));\n-         end if;\n-\n          --  Establish the linkages between the spec and the body. These are\n          --  used when the expression function acts as the prefix of attribute\n          --  'Access in order to freeze the original expression which has been\n@@ -1264,19 +1248,6 @@ package body Sem_Ch6 is\n          Set_Is_Obsolescent (Body_Id, Is_Obsolescent (Gen_Id));\n          Set_Scope          (Body_Id, Scope (Gen_Id));\n \n-         --  Inherit the \"ghostness\" of the generic spec. Note that this\n-         --  property is not directly inherited as the body may be subject\n-         --  to a different Ghost assertion policy.\n-\n-         if Ghost_Mode > None or else Is_Ghost_Entity (Gen_Id) then\n-            Set_Is_Ghost_Entity (Body_Id);\n-\n-            --  The Ghost policy in effect at the point of declaration and at\n-            --  the point of completion must match (SPARK RM 6.9(14)).\n-\n-            Check_Ghost_Completion (Gen_Id, Body_Id);\n-         end if;\n-\n          Check_Fully_Conformant (Body_Id, Gen_Id, Body_Id);\n \n          if Nkind (N) = N_Subprogram_Body_Stub then\n@@ -1559,10 +1530,9 @@ package body Sem_Ch6 is\n       Loc     : constant Source_Ptr := Sloc (N);\n       P       : constant Node_Id    := Name (N);\n       Actual  : Node_Id;\n+      Mode    : Ghost_Mode_Type;\n       New_N   : Node_Id;\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n    --  Start of processing for Analyze_Procedure_Call\n \n    begin\n@@ -1604,7 +1574,7 @@ package body Sem_Ch6 is\n       --  Set the mode now to ensure that any nodes generated during analysis\n       --  and expansion are properly marked as Ghost.\n \n-      Set_Ghost_Mode (N);\n+      Mark_And_Set_Ghost_Procedure_Call (N, Mode);\n \n       --  Otherwise analyze the parameters\n \n@@ -1628,7 +1598,7 @@ package body Sem_Ch6 is\n          if Present (Actuals) then\n             Error_Msg_N\n               (\"no parameters allowed for this call\", First (Actuals));\n-            return;\n+            goto Leave;\n          end if;\n \n          Set_Etype (N, Standard_Void_Type);\n@@ -1638,8 +1608,7 @@ package body Sem_Ch6 is\n         and then Is_Record_Type (Etype (Entity (P)))\n         and then Remote_AST_I_Dereference (P)\n       then\n-         Ghost_Mode := Save_Ghost_Mode;\n-         return;\n+         goto Leave;\n \n       elsif Is_Entity_Name (P)\n         and then Ekind (Entity (P)) /= E_Entry_Family\n@@ -1775,17 +1744,17 @@ package body Sem_Ch6 is\n          Error_Msg_N (\"invalid procedure or entry call\", N);\n       end if;\n \n-      Ghost_Mode := Save_Ghost_Mode;\n+   <<Leave>>\n+      Restore_Ghost_Mode (Mode);\n    end Analyze_Procedure_Call;\n \n    ------------------------------\n    -- Analyze_Return_Statement --\n    ------------------------------\n \n    procedure Analyze_Return_Statement (N : Node_Id) is\n-\n-      pragma Assert (Nkind_In (N, N_Simple_Return_Statement,\n-                                  N_Extended_Return_Statement));\n+      pragma Assert (Nkind_In (N, N_Extended_Return_Statement,\n+                                  N_Simple_Return_Statement));\n \n       Returns_Object : constant Boolean :=\n                          Nkind (N) = N_Extended_Return_Statement\n@@ -2489,12 +2458,7 @@ package body Sem_Ch6 is\n          Body_Id := Analyze_Subprogram_Specification (Body_Spec);\n \n          --  Ensure that the generated corresponding spec and original body\n-         --  share the same Ghost and SPARK_Mode attributes.\n-\n-         Set_Is_Checked_Ghost_Entity\n-           (Body_Id, Is_Checked_Ghost_Entity (Spec_Id));\n-         Set_Is_Ignored_Ghost_Entity\n-           (Body_Id, Is_Ignored_Ghost_Entity (Spec_Id));\n+         --  share the same SPARK_Mode attributes.\n \n          Set_SPARK_Pragma (Body_Id, SPARK_Pragma (Spec_Id));\n          Set_SPARK_Pragma_Inherited\n@@ -3131,7 +3095,8 @@ package body Sem_Ch6 is\n \n       --  Local variables\n \n-      Save_Ghost_Mode   : constant Ghost_Mode_Type := Ghost_Mode;\n+      Mode     : Ghost_Mode_Type;\n+      Mode_Set : Boolean := False;\n \n    --  Start of processing for Analyze_Subprogram_Body_Helper\n \n@@ -3183,7 +3148,9 @@ package body Sem_Ch6 is\n             --  the mode now to ensure that any nodes generated during analysis\n             --  and expansion are properly marked as Ghost.\n \n-            Set_Ghost_Mode          (N, Spec_Id);\n+            Mark_And_Set_Ghost_Body (N, Spec_Id, Mode);\n+            Mode_Set := True;\n+\n             Set_Is_Compilation_Unit (Body_Id, Is_Compilation_Unit (Spec_Id));\n             Set_Is_Child_Unit       (Body_Id, Is_Child_Unit       (Spec_Id));\n \n@@ -3194,15 +3161,13 @@ package body Sem_Ch6 is\n                Check_Missing_Return;\n             end if;\n \n-            Ghost_Mode := Save_Ghost_Mode;\n-            return;\n+            goto Leave;\n \n-         else\n-            --  Previous entity conflicts with subprogram name. Attempting to\n-            --  enter name will post error.\n+         --  Otherwise a previous entity conflicts with the subprogram name.\n+         --  Attempting to enter name will post error.\n \n+         else\n             Enter_Name (Body_Id);\n-            Ghost_Mode := Save_Ghost_Mode;\n             return;\n          end if;\n \n@@ -3213,7 +3178,6 @@ package body Sem_Ch6 is\n       --  analysis.\n \n       elsif Prev_Id = Body_Id and then Has_Completion (Body_Id) then\n-         Ghost_Mode := Save_Ghost_Mode;\n          return;\n \n       else\n@@ -3230,7 +3194,8 @@ package body Sem_Ch6 is\n                --  Ghost. Set the mode now to ensure that any nodes generated\n                --  during analysis and expansion are properly marked as Ghost.\n \n-               Set_Ghost_Mode (N, Spec_Id);\n+               Mark_And_Set_Ghost_Body (N, Spec_Id, Mode);\n+               Mode_Set := True;\n \n             else\n                Spec_Id := Find_Corresponding_Spec (N);\n@@ -3240,7 +3205,8 @@ package body Sem_Ch6 is\n                --  Ghost. Set the mode now to ensure that any nodes generated\n                --  during analysis and expansion are properly marked as Ghost.\n \n-               Set_Ghost_Mode (N, Spec_Id);\n+               Mark_And_Set_Ghost_Body (N, Spec_Id, Mode);\n+               Mode_Set := True;\n \n                --  In GNATprove mode, if the body has no previous spec, create\n                --  one so that the inlining machinery can operate properly.\n@@ -3304,8 +3270,7 @@ package body Sem_Ch6 is\n             --  If this is a duplicate body, no point in analyzing it\n \n             if Error_Posted (N) then\n-               Ghost_Mode := Save_Ghost_Mode;\n-               return;\n+               goto Leave;\n             end if;\n \n             --  A subprogram body should cause freezing of its own declaration,\n@@ -3342,7 +3307,8 @@ package body Sem_Ch6 is\n             --  the mode now to ensure that any nodes generated during analysis\n             --  and expansion are properly marked as Ghost.\n \n-            Set_Ghost_Mode (N, Spec_Id);\n+            Mark_And_Set_Ghost_Body (N, Spec_Id, Mode);\n+            Mode_Set := True;\n          end if;\n       end if;\n \n@@ -3394,7 +3360,7 @@ package body Sem_Ch6 is\n          --  function.\n \n          Set_Is_Immediately_Visible (Corresponding_Spec (N), False);\n-         return;\n+         goto Leave;\n       end if;\n \n       --  If a separate spec is present, then deal with freezing issues\n@@ -3445,26 +3411,12 @@ package body Sem_Ch6 is\n \n          if Is_Abstract_Subprogram (Spec_Id) then\n             Error_Msg_N (\"an abstract subprogram cannot have a body\", N);\n-            Ghost_Mode := Save_Ghost_Mode;\n-            return;\n+            goto Leave;\n \n          else\n             Set_Convention (Body_Id, Convention (Spec_Id));\n             Set_Has_Completion (Spec_Id);\n \n-            --  Inherit the \"ghostness\" of the subprogram spec. Note that this\n-            --  property is not directly inherited as the body may be subject\n-            --  to a different Ghost assertion policy.\n-\n-            if Ghost_Mode > None or else Is_Ghost_Entity (Spec_Id) then\n-               Set_Is_Ghost_Entity (Body_Id);\n-\n-               --  The Ghost policy in effect at the point of declaration and\n-               --  at the point of completion must match (SPARK RM 6.9(14)).\n-\n-               Check_Ghost_Completion (Spec_Id, Body_Id);\n-            end if;\n-\n             if Is_Protected_Type (Scope (Spec_Id)) then\n                Prot_Typ := Scope (Spec_Id);\n             end if;\n@@ -3518,8 +3470,7 @@ package body Sem_Ch6 is\n             if not Conformant\n               and then not Mode_Conformant (Body_Id, Spec_Id)\n             then\n-               Ghost_Mode := Save_Ghost_Mode;\n-               return;\n+               goto Leave;\n             end if;\n          end if;\n \n@@ -3630,13 +3581,6 @@ package body Sem_Ch6 is\n \n          New_Overloaded_Entity (Body_Id);\n \n-         --  A subprogram body declared within a Ghost region is automatically\n-         --  Ghost (SPARK RM 6.9(2)).\n-\n-         if Ghost_Mode > None then\n-            Set_Is_Ghost_Entity (Body_Id);\n-         end if;\n-\n          if Nkind (N) /= N_Subprogram_Body_Stub then\n             Set_Acts_As_Spec (N);\n             Generate_Definition (Body_Id);\n@@ -3759,8 +3703,7 @@ package body Sem_Ch6 is\n             Analyze_Aspect_Specifications_On_Body_Or_Stub (N);\n          end if;\n \n-         Ghost_Mode := Save_Ghost_Mode;\n-         return;\n+         goto Leave;\n       end if;\n \n       --  Handle inlining\n@@ -4182,7 +4125,8 @@ package body Sem_Ch6 is\n       --  Check for variables that are never modified\n \n       declare\n-         E1, E2 : Entity_Id;\n+         E1 : Entity_Id;\n+         E2 : Entity_Id;\n \n       begin\n          --  If there is a separate spec, then transfer Never_Set_In_Source\n@@ -4247,7 +4191,10 @@ package body Sem_Ch6 is\n          Set_Directly_Designated_Type (Etype (Spec_Id), Desig_View);\n       end if;\n \n-      Ghost_Mode := Save_Ghost_Mode;\n+   <<Leave>>\n+      if Mode_Set then\n+         Restore_Ghost_Mode (Mode);\n+      end if;\n    end Analyze_Subprogram_Body_Helper;\n \n    ------------------------------------\n@@ -4309,13 +4256,6 @@ package body Sem_Ch6 is\n          Set_SPARK_Pragma_Inherited (Designator);\n       end if;\n \n-      --  A subprogram declared within a Ghost region is automatically Ghost\n-      --  (SPARK RM 6.9(2)).\n-\n-      if Ghost_Mode > None then\n-         Set_Is_Ghost_Entity (Designator);\n-      end if;\n-\n       if Debug_Flag_C then\n          Write_Str (\"==> subprogram spec \");\n          Write_Name (Chars (Designator));\n@@ -8197,10 +8137,6 @@ package body Sem_Ch6 is\n \n                   Set_Convention (Designator, Convention (E));\n \n-                  if Is_Ghost_Entity (E) then\n-                     Set_Is_Ghost_Entity (Designator);\n-                  end if;\n-\n                   --  Skip past subprogram bodies and subprogram renamings that\n                   --  may appear to have a matching spec, but that aren't fully\n                   --  conformant with it. That can occur in cases where an\n@@ -9762,8 +9698,8 @@ package body Sem_Ch6 is\n                   Set_Is_Primitive (S);\n                   Check_Private_Overriding (B_Typ);\n \n-                  --  The Ghost policy in effect at the point of declaration of\n-                  --  a tagged type and a primitive operation must match\n+                  --  The Ghost policy in effect at the point of declaration\n+                  --  or a tagged type and a primitive operation must match\n                   --  (SPARK RM 6.9(16)).\n \n                   Check_Ghost_Primitive (S, B_Typ);\n@@ -9795,8 +9731,8 @@ package body Sem_Ch6 is\n                   Set_Has_Primitive_Operations (B_Typ);\n                   Check_Private_Overriding (B_Typ);\n \n-                  --  The Ghost policy in effect at the point of declaration of\n-                  --  a tagged type and a primitive operation must match\n+                  --  The Ghost policy in effect at the point of declaration\n+                  --  of a tagged type and a primitive operation must match\n                   --  (SPARK RM 6.9(16)).\n \n                   Check_Ghost_Primitive (S, B_Typ);\n@@ -11058,13 +10994,6 @@ package body Sem_Ch6 is\n \n          Set_Etype (Formal, Formal_Type);\n \n-         --  A formal parameter declared within a Ghost region is automatically\n-         --  Ghost (SPARK RM 6.9(2)).\n-\n-         if Ghost_Mode > None then\n-            Set_Is_Ghost_Entity (Formal);\n-         end if;\n-\n          --  Deal with default expression if present\n \n          Default := Expression (Param_Spec);"}, {"sha": "f5c02c8fa52a4b6908b33b7464b7ba2cf4354dff", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 3, "deletions": 34, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -537,10 +537,10 @@ package body Sem_Ch7 is\n \n       --  Local variables\n \n-      Save_Ghost_Mode  : constant Ghost_Mode_Type := Ghost_Mode;\n       Body_Id          : Entity_Id;\n       HSS              : Node_Id;\n       Last_Spec_Entity : Entity_Id;\n+      Mode             : Ghost_Mode_Type;\n       New_N            : Node_Id;\n       Pack_Decl        : Node_Id;\n       Spec_Id          : Entity_Id;\n@@ -643,7 +643,7 @@ package body Sem_Ch7 is\n       --  the mode now to ensure that any nodes generated during analysis and\n       --  expansion are properly flagged as ignored Ghost.\n \n-      Set_Ghost_Mode (N, Spec_Id);\n+      Mark_And_Set_Ghost_Body (N, Spec_Id, Mode);\n \n       Set_Is_Compilation_Unit (Body_Id, Is_Compilation_Unit (Spec_Id));\n       Style.Check_Identifier (Body_Id, Spec_Id);\n@@ -738,19 +738,6 @@ package body Sem_Ch7 is\n          Set_SPARK_Aux_Pragma_Inherited (Body_Id);\n       end if;\n \n-      --  Inherit the \"ghostness\" of the package spec. Note that this property\n-      --  is not directly inherited as the body may be subject to a different\n-      --  Ghost assertion policy.\n-\n-      if Ghost_Mode > None or else Is_Ghost_Entity (Spec_Id) then\n-         Set_Is_Ghost_Entity (Body_Id);\n-\n-         --  The Ghost policy in effect at the point of declaration and at the\n-         --  point of completion must match (SPARK RM 6.9(14)).\n-\n-         Check_Ghost_Completion (Spec_Id, Body_Id);\n-      end if;\n-\n       Set_Categorization_From_Pragmas (N);\n \n       Install_Visible_Declarations (Spec_Id);\n@@ -942,7 +929,7 @@ package body Sem_Ch7 is\n          end if;\n       end if;\n \n-      Ghost_Mode := Save_Ghost_Mode;\n+      Restore_Ghost_Mode (Mode);\n    end Analyze_Package_Body_Helper;\n \n    ---------------------------------\n@@ -951,7 +938,6 @@ package body Sem_Ch7 is\n \n    procedure Analyze_Package_Declaration (N : Node_Id) is\n       Id  : constant Node_Id := Defining_Entity (N);\n-      Par : constant Node_Id := Parent_Spec (N);\n \n       Is_Comp_Unit : constant Boolean :=\n                        Nkind (Parent (N)) = N_Compilation_Unit;\n@@ -983,16 +969,6 @@ package body Sem_Ch7 is\n          Set_SPARK_Aux_Pragma_Inherited (Id);\n       end if;\n \n-      --  A package declared within a Ghost refion is automatically Ghost. A\n-      --  child package is Ghost when its parent is Ghost (SPARK RM 6.9(2)).\n-\n-      if Ghost_Mode > None\n-        or else (Present (Par)\n-                  and then Is_Ghost_Entity (Defining_Entity (Unit (Par))))\n-      then\n-         Set_Is_Ghost_Entity (Id);\n-      end if;\n-\n       --  Analyze aspect specifications immediately, since we need to recognize\n       --  things like Pure early enough to diagnose violations during analysis.\n \n@@ -1793,13 +1769,6 @@ package body Sem_Ch7 is\n       New_Private_Type (N, Id, N);\n       Set_Depends_On_Private (Id);\n \n-      --  A type declared within a Ghost region is automatically Ghost\n-      --  (SPARK RM 6.9(2)).\n-\n-      if Ghost_Mode > None then\n-         Set_Is_Ghost_Entity (Id);\n-      end if;\n-\n       if Has_Aspects (N) then\n          Analyze_Aspect_Specifications (N, Id);\n       end if;"}, {"sha": "86eed89bd7bce7a1bbceec32f6ad5bacaa7d1b2f", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 85, "deletions": 57, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -575,7 +575,7 @@ package body Sem_Ch8 is\n          --  The exception renaming declaration may become Ghost if it renames\n          --  a Ghost entity.\n \n-         Mark_Renaming_As_Ghost (N, Entity (Nam));\n+         Mark_Ghost_Renaming (N, Entity (Nam));\n       else\n          Error_Msg_N (\"invalid exception name in renaming\", Nam);\n       end if;\n@@ -658,10 +658,8 @@ package body Sem_Ch8 is\n       K : Entity_Kind)\n    is\n       New_P : constant Entity_Id := Defining_Entity (N);\n-      Old_P : Entity_Id;\n-\n       Inst  : Boolean := False;\n-      --  Prevent junk warning\n+      Old_P : Entity_Id;\n \n    begin\n       if Name (N) = Error then\n@@ -705,17 +703,17 @@ package body Sem_Ch8 is\n             Set_Renamed_Object (New_P, Old_P);\n          end if;\n \n+         --  The generic renaming declaration may become Ghost if it renames a\n+         --  Ghost entity.\n+\n+         Mark_Ghost_Renaming (N, Old_P);\n+\n          Set_Is_Pure          (New_P, Is_Pure          (Old_P));\n          Set_Is_Preelaborated (New_P, Is_Preelaborated (Old_P));\n \n          Set_Etype (New_P, Etype (Old_P));\n          Set_Has_Completion (New_P);\n \n-         --  The generic renaming declaration may become Ghost if it renames a\n-         --  Ghost entity.\n-\n-         Mark_Renaming_As_Ghost (N, Old_P);\n-\n          if In_Open_Scopes (Old_P) then\n             Error_Msg_N (\"within its scope, generic denotes its instance\", N);\n          end if;\n@@ -840,7 +838,15 @@ package body Sem_Ch8 is\n       --  already-analyzed expression.\n \n       if Nkind (Nam) = N_Selected_Component and then Analyzed (Nam) then\n-         T := Etype (Nam);\n+\n+         --  The object renaming declaration may become Ghost if it renames a\n+         --  Ghost entity.\n+\n+         if Is_Entity_Name (Nam) then\n+            Mark_Ghost_Renaming (N, Entity (Nam));\n+         end if;\n+\n+         T   := Etype (Nam);\n          Dec := Build_Actual_Subtype_Of_Component (Etype (Nam), Nam);\n \n          if Present (Dec) then\n@@ -860,6 +866,13 @@ package body Sem_Ch8 is\n          T := Entity (Subtype_Mark (N));\n          Analyze (Nam);\n \n+         --  The object renaming declaration may become Ghost if it renames a\n+         --  Ghost entity.\n+\n+         if Is_Entity_Name (Nam) then\n+            Mark_Ghost_Renaming (N, Entity (Nam));\n+         end if;\n+\n          --  Reject renamings of conversions unless the type is tagged, or\n          --  the conversion is implicit (which can occur for cases of anonymous\n          --  access types in Ada 2012).\n@@ -928,12 +941,20 @@ package body Sem_Ch8 is\n       --  Ada 2005 (AI-230/AI-254): Access renaming\n \n       else pragma Assert (Present (Access_Definition (N)));\n-         T := Access_Definition\n-                (Related_Nod => N,\n-                 N           => Access_Definition (N));\n+         T :=\n+           Access_Definition\n+             (Related_Nod => N,\n+              N           => Access_Definition (N));\n \n          Analyze (Nam);\n \n+         --  The object renaming declaration may become Ghost if it renames a\n+         --  Ghost entity.\n+\n+         if Is_Entity_Name (Nam) then\n+            Mark_Ghost_Renaming (N, Entity (Nam));\n+         end if;\n+\n          --  Ada 2005 AI05-105: if the declaration has an anonymous access\n          --  type, the renamed object must also have an anonymous type, and\n          --  this is a name resolution rule. This was implicit in the last part\n@@ -1071,7 +1092,6 @@ package body Sem_Ch8 is\n                     (\"\\suggest using an initialized constant \"\n                      & \"object instead?R?\", Nam);\n                end if;\n-\n          end case;\n       end if;\n \n@@ -1296,13 +1316,6 @@ package body Sem_Ch8 is\n          Set_Is_True_Constant    (Id, True);\n       end if;\n \n-      --  The object renaming declaration may become Ghost if it renames a\n-      --  Ghost entity.\n-\n-      if Is_Entity_Name (Nam) then\n-         Mark_Renaming_As_Ghost (N, Entity (Nam));\n-      end if;\n-\n       --  The entity of the renaming declaration needs to reflect whether the\n       --  renamed object is volatile. Is_Volatile is set if the renamed object\n       --  is volatile in the RM legality sense.\n@@ -1393,7 +1406,7 @@ package body Sem_Ch8 is\n          else\n             Error_Msg_Sloc := Sloc (Old_P);\n             Error_Msg_NE\n-             (\"expect package name in renaming, found& declared#\",\n+              (\"expect package name in renaming, found& declared#\",\n                Name (N), Old_P);\n          end if;\n \n@@ -1418,19 +1431,18 @@ package body Sem_Ch8 is\n             Set_Renamed_Object (New_P, Old_P);\n          end if;\n \n-         Set_Has_Completion (New_P);\n+         --  The package renaming declaration may become Ghost if it renames a\n+         --  Ghost entity.\n \n-         Set_First_Entity (New_P, First_Entity (Old_P));\n-         Set_Last_Entity  (New_P, Last_Entity  (Old_P));\n+         Mark_Ghost_Renaming (N, Old_P);\n+\n+         Set_Has_Completion (New_P);\n+         Set_First_Entity   (New_P, First_Entity (Old_P));\n+         Set_Last_Entity    (New_P, Last_Entity  (Old_P));\n          Set_First_Private_Entity (New_P, First_Private_Entity (Old_P));\n          Check_Library_Unit_Renaming (N, Old_P);\n          Generate_Reference (Old_P, Name (N));\n \n-         --  The package renaming declaration may become Ghost if it renames a\n-         --  Ghost entity.\n-\n-         Mark_Renaming_As_Ghost (N, Old_P);\n-\n          --  If the renaming is in the visible part of a package, then we set\n          --  Renamed_In_Spec for the renamed package, to prevent giving\n          --  warnings about no entities referenced. Such a warning would be\n@@ -2574,8 +2586,8 @@ package body Sem_Ch8 is\n            and then Expander_Active\n          then\n             declare\n-               Stream_Prim : Entity_Id;\n                Prefix_Type : constant Entity_Id := Entity (Prefix (Nam));\n+               Stream_Prim : Entity_Id;\n \n             begin\n                --  The class-wide forms of the stream attributes are not\n@@ -2610,13 +2622,13 @@ package body Sem_Ch8 is\n                        Find_Optional_Prim_Op (Prefix_Type, TSS_Stream_Write);\n                   when others      =>\n                      Error_Msg_N\n-                       (\"attribute must be a primitive\"\n-                         & \" dispatching operation\", Nam);\n+                       (\"attribute must be a primitive dispatching operation\",\n+                        Nam);\n                      return;\n                end case;\n \n-               --  If no operation was found, and the type is limited,\n-               --  the user should have defined one.\n+               --  If no operation was found, and the type is limited, the user\n+               --  should have defined one.\n \n                if No (Stream_Prim) then\n                   if Is_Limited_Type (Prefix_Type) then\n@@ -2655,8 +2667,8 @@ package body Sem_Ch8 is\n          end if;\n       end if;\n \n-      --  Check whether this declaration corresponds to the instantiation\n-      --  of a formal subprogram.\n+      --  Check whether this declaration corresponds to the instantiation of a\n+      --  formal subprogram.\n \n       --  If this is an instantiation, the corresponding actual is frozen and\n       --  error messages can be made more precise. If this is a default\n@@ -2677,8 +2689,8 @@ package body Sem_Ch8 is\n          --  is an external axiomatization on the package.\n \n          if CW_Actual\n-            and then Box_Present (Inst_Node)\n-            and then not\n+           and then Box_Present (Inst_Node)\n+           and then not\n              (GNATprove_Mode\n                and then\n                  Present (Containing_Package_With_Ext_Axioms (Formal_Spec)))\n@@ -2691,11 +2703,17 @@ package body Sem_Ch8 is\n            and then not Is_Overloaded (Nam)\n          then\n             Old_S := Entity (Nam);\n+\n+            --  The subprogram renaming declaration may become Ghost if it\n+            --  renames a Ghost entity.\n+\n+            Mark_Ghost_Renaming (N, Old_S);\n+\n             New_S := Analyze_Subprogram_Specification (Spec);\n \n             --  Operator case\n \n-            if Ekind (Entity (Nam)) = E_Operator then\n+            if Ekind (Old_S) = E_Operator then\n \n                --  Box present\n \n@@ -2729,9 +2747,9 @@ package body Sem_Ch8 is\n                        and then Hidden /= Old_S\n                      then\n                         Error_Msg_Sloc := Sloc (Hidden);\n-                        Error_Msg_N (\"default subprogram is resolved \" &\n-                                     \"in the generic declaration \" &\n-                                     \"(RM 12.6(17))??\", N);\n+                        Error_Msg_N\n+                          (\"default subprogram is resolved in the generic \"\n+                           & \"declaration (RM 12.6(17))??\", N);\n                         Error_Msg_NE (\"\\and will not use & #??\", N, Hidden);\n                      end if;\n                   end;\n@@ -2740,6 +2758,14 @@ package body Sem_Ch8 is\n \n          else\n             Analyze (Nam);\n+\n+            --  The subprogram renaming declaration may become Ghost if it\n+            --  renames a Ghost entity.\n+\n+            if Is_Entity_Name (Nam) then\n+               Mark_Ghost_Renaming (N, Entity (Nam));\n+            end if;\n+\n             New_S := Analyze_Subprogram_Specification (Spec);\n          end if;\n \n@@ -2749,6 +2775,13 @@ package body Sem_Ch8 is\n \n          Analyze (Nam);\n \n+         --  The subprogram renaming declaration may become Ghost if it renames\n+         --  a Ghost entity.\n+\n+         if Is_Entity_Name (Nam) then\n+            Mark_Ghost_Renaming (N, Entity (Nam));\n+         end if;\n+\n          --  The renaming defines a new overloaded entity, which is analyzed\n          --  like a subprogram declaration.\n \n@@ -2845,8 +2878,9 @@ package body Sem_Ch8 is\n                Error_Msg_NE\n                  (\"subprogram& overrides inherited operation\",\n                     N, Rename_Spec);\n-            elsif\n-              Style_Check and then not Must_Override (Specification (N))\n+\n+            elsif Style_Check\n+              and then not Must_Override (Specification (N))\n             then\n                Style.Missing_Overriding (N, Rename_Spec);\n             end if;\n@@ -3025,11 +3059,6 @@ package body Sem_Ch8 is\n          Set_Is_Pure          (New_S, Is_Pure          (Entity (Nam)));\n          Set_Is_Preelaborated (New_S, Is_Preelaborated (Entity (Nam)));\n \n-         --  The subprogram renaming declaration may become Ghost if it renames\n-         --  a Ghost entity.\n-\n-         Mark_Renaming_As_Ghost (N, Entity (Nam));\n-\n          --  Ada 2005 (AI-423): Check the consistency of null exclusions\n          --  between a subprogram and its correct renaming.\n \n@@ -3068,8 +3097,8 @@ package body Sem_Ch8 is\n                    not Is_Abstract_Type (Find_Dispatching_Type (Old_S)))\n          then\n             Error_Msg_N\n-              (\"renamed entity cannot be \"\n-               & \"subprogram that requires overriding (RM 8.5.4 (5.1))\", N);\n+              (\"renamed entity cannot be subprogram that requires overriding \"\n+               & \"(RM 8.5.4 (5.1))\", N);\n          end if;\n       end if;\n \n@@ -3124,7 +3153,7 @@ package body Sem_Ch8 is\n                then\n                   Error_Msg_N\n                     (\"subprogram in renaming_as_body cannot be intrinsic\",\n-                       Name (N));\n+                     Name (N));\n                end if;\n \n                Set_Has_Completion (Rename_Spec);\n@@ -3364,8 +3393,7 @@ package body Sem_Ch8 is\n                then\n                   Error_Msg_Node_2 := T1;\n                   Error_Msg_NE\n-                    (\"default & on & is not directly visible\",\n-                      Nam, Nam);\n+                    (\"default & on & is not directly visible\", Nam, Nam);\n                end if;\n             end;\n          end if;\n@@ -3396,8 +3424,8 @@ package body Sem_Ch8 is\n                then\n                   Error_Msg_N (\"access parameter is controlling,\", New_F);\n                   Error_Msg_NE\n-                    (\"\\corresponding parameter of& \"\n-                     & \"must be explicitly null excluding\", New_F, Old_S);\n+                    (\"\\corresponding parameter of& must be explicitly null \"\n+                     & \"excluding\", New_F, Old_S);\n                end if;\n \n                Next_Formal (Old_F);"}, {"sha": "513b19b88744c8ac4f5399489749ca4522eff349", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 131, "deletions": 133, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -459,9 +459,8 @@ package body Sem_Prag is\n \n       CCases : constant Node_Id := Expression (Get_Argument (N, Spec_Id));\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n       CCase         : Node_Id;\n+      Mode          : Ghost_Mode_Type;\n       Restore_Scope : Boolean := False;\n \n    --  Start of processing for Analyze_Contract_Cases_In_Decl_Part\n@@ -478,7 +477,7 @@ package body Sem_Prag is\n       --  point of analysis may not necessarily be the same. Use the mode in\n       --  effect at the point of declaration.\n \n-      Set_Ghost_Mode (N);\n+      Set_Ghost_Mode (N, Mode);\n \n       --  Single and multiple contract cases must appear in aggregate form. If\n       --  this is not the case, then either the parser of the analysis of the\n@@ -524,8 +523,8 @@ package body Sem_Prag is\n          Error_Msg_N (\"wrong syntax for constract cases\", N);\n       end if;\n \n-      Ghost_Mode := Save_Ghost_Mode;\n       Set_Is_Analyzed_Pragma (N);\n+      Restore_Ghost_Mode (Mode);\n    end Analyze_Contract_Cases_In_Decl_Part;\n \n    ----------------------------------\n@@ -2656,7 +2655,7 @@ package body Sem_Prag is\n       Pack_Id   : constant Entity_Id := Defining_Entity (Pack_Decl);\n       Expr      : constant Node_Id   := Expression (Get_Argument (N, Pack_Id));\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n+      Mode : Ghost_Mode_Type;\n \n    begin\n       --  Do not analyze the pragma multiple times\n@@ -2670,16 +2669,16 @@ package body Sem_Prag is\n       --  point of analysis may not necessarily be the same. Use the mode in\n       --  effect at the point of declaration.\n \n-      Set_Ghost_Mode (N);\n+      Set_Ghost_Mode (N, Mode);\n \n       --  The expression is preanalyzed because it has not been moved to its\n       --  final place yet. A direct analysis may generate side effects and this\n       --  is not desired at this point.\n \n       Preanalyze_Assert_Expression (Expr, Standard_Boolean);\n-      Ghost_Mode := Save_Ghost_Mode;\n-\n       Set_Is_Analyzed_Pragma (N);\n+\n+      Restore_Ghost_Mode (Mode);\n    end Analyze_Initial_Condition_In_Decl_Part;\n \n    --------------------------------------\n@@ -4133,7 +4132,7 @@ package body Sem_Prag is\n          --  A pragma that applies to a Ghost entity becomes Ghost for the\n          --  purposes of legality checks and removal of ignored Ghost code.\n \n-         Mark_Pragma_As_Ghost (N, Spec_Id);\n+         Mark_Ghost_Pragma (N, Spec_Id);\n          Ensure_Aggregate_Form (Get_Argument (N, Spec_Id));\n       end Analyze_Depends_Global;\n \n@@ -4316,16 +4315,16 @@ package body Sem_Prag is\n \n          Subp_Id := Defining_Entity (Subp_Decl);\n \n+         --  A pragma that applies to a Ghost entity becomes Ghost for the\n+         --  purposes of legality checks and removal of ignored Ghost code.\n+\n+         Mark_Ghost_Pragma (N, Subp_Id);\n+\n          --  Chain the pragma on the contract for further processing by\n          --  Analyze_Pre_Post_Condition_In_Decl_Part.\n \n          Add_Contract_Item (N, Defining_Entity (Subp_Decl));\n \n-         --  A pragma that applies to a Ghost entity becomes Ghost for the\n-         --  purposes of legality checks and removal of ignored Ghost code.\n-\n-         Mark_Pragma_As_Ghost (N, Subp_Id);\n-\n          --  Fully analyze the pragma when it appears inside an entry or\n          --  subprogram body because it cannot benefit from forward references.\n \n@@ -4446,7 +4445,7 @@ package body Sem_Prag is\n          --  A pragma that applies to a Ghost entity becomes Ghost for the\n          --  purposes of legality checks and removal of ignored Ghost code.\n \n-         Mark_Pragma_As_Ghost (N, Spec_Id);\n+         Mark_Ghost_Pragma (N, Spec_Id);\n \n          if Nam_In (Pname, Name_Refined_Depends, Name_Refined_Global) then\n             Ensure_Aggregate_Form (Get_Argument (N, Spec_Id));\n@@ -4510,7 +4509,7 @@ package body Sem_Prag is\n                   --  the purposes of legality checks and removal of ignored\n                   --  Ghost code.\n \n-                  Mark_Pragma_As_Ghost (N, Arg_Id);\n+                  Mark_Ghost_Pragma (N, Arg_Id);\n \n                   --  Capture the entity of the first Ghost variable being\n                   --  processed for error detection purposes.\n@@ -4684,7 +4683,7 @@ package body Sem_Prag is\n                      --  for the purposes of legality checks and removal of\n                      --  ignored Ghost code.\n \n-                     Mark_Pragma_As_Ghost (N, Arg_Id);\n+                     Mark_Ghost_Pragma (N, Arg_Id);\n \n                      --  Capture the entity of the first Ghost name being\n                      --  processed for error detection purposes.\n@@ -6793,13 +6792,12 @@ package body Sem_Prag is\n             return;\n          end if;\n \n-         E    := Entity (E_Arg);\n-         Decl := Declaration_Node (E);\n+         E := Entity (E_Arg);\n \n          --  A pragma that applies to a Ghost entity becomes Ghost for the\n          --  purposes of legality checks and removal of ignored Ghost code.\n \n-         Mark_Pragma_As_Ghost (N, E);\n+         Mark_Ghost_Pragma (N, E);\n \n          --  Check duplicate before we chain ourselves\n \n@@ -6856,6 +6854,8 @@ package body Sem_Prag is\n \n          --  Now check appropriateness of the entity\n \n+         Decl := Declaration_Node (E);\n+\n          if Is_Type (E) then\n             if Rep_Item_Too_Early (E, N)\n                  or else\n@@ -8358,7 +8358,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, Def_Id);\n+            Mark_Ghost_Pragma (N, Def_Id);\n             Kill_Size_Check_Code (Def_Id);\n             Note_Possible_Modification (Get_Pragma_Arg (Arg2), Sure => False);\n          end if;\n@@ -9006,7 +9006,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, Subp);\n+            Mark_Ghost_Pragma (N, Subp);\n \n             --  Capture the entity of the first Ghost subprogram being\n             --  processed for error detection purposes.\n@@ -9266,7 +9266,7 @@ package body Sem_Prag is\n          --  A pragma that applies to a Ghost entity becomes Ghost for the\n          --  purposes of legality checks and removal of ignored Ghost code.\n \n-         Mark_Pragma_As_Ghost (N, Handler);\n+         Mark_Ghost_Pragma (N, Handler);\n          Set_Is_Interrupt_Handler (Handler);\n \n          pragma Assert (Ekind (Prot_Typ) = E_Protected_Type);\n@@ -9759,7 +9759,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, E);\n+            Mark_Ghost_Pragma (N, E);\n \n             --  Enforce RM 11.5(7) which requires that for a pragma that\n             --  appears within a package spec, the named entity must be\n@@ -11216,6 +11216,12 @@ package body Sem_Prag is\n \n             Pack_Id := Defining_Entity (Pack_Decl);\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Ghost_Pragma (N, Pack_Id);\n+            Ensure_Aggregate_Form (Get_Argument (N, Pack_Id));\n+\n             --  Chain the pragma on the contract for completeness\n \n             Add_Contract_Item (N, Pack_Id);\n@@ -11231,13 +11237,6 @@ package body Sem_Prag is\n             --  Analyze all these pragmas in the order outlined above\n \n             Analyze_If_Present (Pragma_SPARK_Mode);\n-\n-            --  A pragma that applies to a Ghost entity becomes Ghost for the\n-            --  purposes of legality checks and removal of ignored Ghost code.\n-\n-            Mark_Pragma_As_Ghost (N, Pack_Id);\n-            Ensure_Aggregate_Form (Get_Argument (N, Pack_Id));\n-\n             States := Expression (Get_Argument (N, Pack_Id));\n \n             --  Multiple non-null abstract states appear as an aggregate\n@@ -11484,7 +11483,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, Lib_Entity);\n+            Mark_Ghost_Pragma (N, Lib_Entity);\n \n             --  This pragma should only apply to a RCI unit (RM E.2.3(23))\n \n@@ -11560,7 +11559,7 @@ package body Sem_Prag is\n                if Is_Entity_Name (Get_Pragma_Arg (Nam_Arg))\n                  and then Present (Entity (Get_Pragma_Arg (Nam_Arg)))\n                then\n-                  Mark_Pragma_As_Ghost (N, Entity (Get_Pragma_Arg (Nam_Arg)));\n+                  Mark_Ghost_Pragma (N, Entity (Get_Pragma_Arg (Nam_Arg)));\n                end if;\n \n                --  Not allowed in compiler units (bootstrap issues)\n@@ -12111,16 +12110,16 @@ package body Sem_Prag is\n \n             if Ekind (Obj_Id) = E_Variable then\n \n-               --  Chain the pragma on the contract for further processing by\n-               --  Analyze_External_Property_In_Decl_Part.\n-\n-               Add_Contract_Item (N, Obj_Id);\n-\n                --  A pragma that applies to a Ghost entity becomes Ghost for\n                --  the purposes of legality checks and removal of ignored Ghost\n                --  code.\n \n-               Mark_Pragma_As_Ghost (N, Obj_Id);\n+               Mark_Ghost_Pragma (N, Obj_Id);\n+\n+               --  Chain the pragma on the contract for further processing by\n+               --  Analyze_External_Property_In_Decl_Part.\n+\n+               Add_Contract_Item (N, Obj_Id);\n \n                --  Analyze the Boolean expression (if any)\n \n@@ -12202,7 +12201,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, Nm);\n+            Mark_Ghost_Pragma (N, Nm);\n \n             if not Is_Remote_Call_Interface (C_Ent)\n               and then not Is_Remote_Types (C_Ent)\n@@ -12322,7 +12321,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, E);\n+            Mark_Ghost_Pragma (N, E);\n             Check_Duplicate_Pragma (E);\n \n             if Rep_Item_Too_Early (E, N)\n@@ -12471,16 +12470,15 @@ package body Sem_Prag is\n             Cname : Name_Id;\n             Eloc  : Source_Ptr;\n             Expr  : Node_Id;\n+            Mode  : Ghost_Mode_Type;\n             Str   : Node_Id;\n \n-            Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n          begin\n             --  Pragma Check is Ghost when it applies to a Ghost entity. Set\n             --  the mode now to ensure that any nodes generated during analysis\n             --  and expansion are marked as Ghost.\n \n-            Set_Ghost_Mode (N);\n+            Set_Ghost_Mode (N, Mode);\n \n             GNAT_Pragma;\n             Check_At_Least_N_Arguments (2);\n@@ -12677,7 +12675,7 @@ package body Sem_Prag is\n                In_Assertion_Expr := In_Assertion_Expr - 1;\n             end if;\n \n-            Ghost_Mode := Save_Ghost_Mode;\n+            Restore_Ghost_Mode (Mode);\n          end Check;\n \n          --------------------------\n@@ -13175,14 +13173,14 @@ package body Sem_Prag is\n                return;\n             end if;\n \n-            --  Chain the pragma on the contract for completeness\n-\n-            Add_Contract_Item (N, Obj_Id);\n-\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, Obj_Id);\n+            Mark_Ghost_Pragma (N, Obj_Id);\n+\n+            --  Chain the pragma on the contract for completeness\n+\n+            Add_Contract_Item (N, Obj_Id);\n \n             --  Analyze the Boolean expression (if any)\n \n@@ -13287,17 +13285,17 @@ package body Sem_Prag is\n \n             Spec_Id := Unique_Defining_Entity (Subp_Decl);\n \n-            --  Chain the pragma on the contract for further processing by\n-            --  Analyze_Contract_Cases_In_Decl_Part.\n-\n-            Add_Contract_Item (N, Defining_Entity (Subp_Decl));\n-\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, Spec_Id);\n+            Mark_Ghost_Pragma (N, Spec_Id);\n             Ensure_Aggregate_Form (Get_Argument (N, Spec_Id));\n \n+            --  Chain the pragma on the contract for further processing by\n+            --  Analyze_Contract_Cases_In_Decl_Part.\n+\n+            Add_Contract_Item (N, Defining_Entity (Subp_Decl));\n+\n             --  Fully analyze the pragma when it appears inside an entry\n             --  or subprogram body because it cannot benefit from forward\n             --  references.\n@@ -13361,7 +13359,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, E);\n+            Mark_Ghost_Pragma (N, E);\n          end Convention;\n \n          ---------------------------\n@@ -13832,7 +13830,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, Typ);\n+            Mark_Ghost_Pragma (N, Typ);\n \n             --  The pragma signals that the type defines its own DIC assertion\n             --  expression.\n@@ -13961,7 +13959,7 @@ package body Sem_Prag is\n                      --  for the purposes of legality checks and removal of\n                      --  ignored Ghost code.\n \n-                     Mark_Pragma_As_Ghost (N, Entity (Pool));\n+                     Mark_Ghost_Pragma (N, Entity (Pool));\n \n                   else\n                      Error_Pragma_Arg\n@@ -14145,7 +14143,7 @@ package body Sem_Prag is\n                   --  the purposes of legality checks and removal of ignored\n                   --  Ghost code.\n \n-                  Mark_Pragma_As_Ghost (N, E);\n+                  Mark_Ghost_Pragma (N, E);\n \n                   if (Is_First_Subtype (E)\n                       and then\n@@ -14194,7 +14192,7 @@ package body Sem_Prag is\n                --  the purposes of legality checks and removal of ignored Ghost\n                --  code.\n \n-               Mark_Pragma_As_Ghost (N, Ent);\n+               Mark_Ghost_Pragma (N, Ent);\n \n                --  The expression must be analyzed in the special manner\n                --  described in \"Handling of Default and Per-Object\n@@ -14420,7 +14418,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, Cunit_Ent);\n+            Mark_Ghost_Pragma (N, Cunit_Ent);\n \n             if Nkind_In (Unit (Cunit_Node), N_Package_Body,\n                                             N_Subprogram_Body)\n@@ -14612,7 +14610,7 @@ package body Sem_Prag is\n                --  the purposes of legality checks and removal of ignored Ghost\n                --  code.\n \n-               Mark_Pragma_As_Ghost (N, Def_Id);\n+               Mark_Ghost_Pragma (N, Def_Id);\n \n                if Ekind (Def_Id) /= E_Constant then\n                   Note_Possible_Modification\n@@ -15032,6 +15030,13 @@ package body Sem_Prag is\n                return;\n             end if;\n \n+            --  Mark the pragma as Ghost if the related subprogram is also\n+            --  Ghost. This also ensures that any expansion performed further\n+            --  below will produce Ghost nodes.\n+\n+            Spec_Id := Unique_Defining_Entity (Subp_Decl);\n+            Mark_Ghost_Pragma (N, Spec_Id);\n+\n             --  Chain the pragma on the contract for completeness\n \n             Add_Contract_Item (N, Defining_Entity (Subp_Decl));\n@@ -15042,13 +15047,6 @@ package body Sem_Prag is\n \n             Analyze_If_Present (Pragma_SPARK_Mode);\n \n-            --  Mark the pragma as Ghost if the related subprogram is also\n-            --  Ghost. This also ensures that any expansion performed further\n-            --  below will produce Ghost nodes.\n-\n-            Spec_Id := Unique_Defining_Entity (Subp_Decl);\n-            Mark_Pragma_As_Ghost (N, Spec_Id);\n-\n             --  Examine the formals of the related subprogram\n \n             Formal := First_Formal (Spec_Id);\n@@ -15123,7 +15121,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, E);\n+            Mark_Ghost_Pragma (N, E);\n \n             Note_Possible_Modification\n               (Get_Pragma_Arg (Arg2), Sure => False);\n@@ -15211,7 +15209,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, Typ);\n+            Mark_Ghost_Pragma (N, Typ);\n \n             --  If it's an access-to-subprogram type (in particular, not a\n             --  subtype), set the flag on that type.\n@@ -16112,7 +16110,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, E);\n+            Mark_Ghost_Pragma (N, E);\n \n             --  Check duplicate before we chain ourselves\n \n@@ -16218,6 +16216,11 @@ package body Sem_Prag is\n \n             Pack_Id := Defining_Entity (Pack_Decl);\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Ghost_Pragma (N, Pack_Id);\n+\n             --  Chain the pragma on the contract for further processing by\n             --  Analyze_Initial_Condition_In_Decl_Part.\n \n@@ -16236,11 +16239,6 @@ package body Sem_Prag is\n             Analyze_If_Present (Pragma_SPARK_Mode);\n             Analyze_If_Present (Pragma_Abstract_State);\n             Analyze_If_Present (Pragma_Initializes);\n-\n-            --  A pragma that applies to a Ghost entity becomes Ghost for the\n-            --  purposes of legality checks and removal of ignored Ghost code.\n-\n-            Mark_Pragma_As_Ghost (N, Pack_Id);\n          end Initial_Condition;\n \n          ------------------------\n@@ -16332,6 +16330,12 @@ package body Sem_Prag is\n \n             Pack_Id := Defining_Entity (Pack_Decl);\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Ghost_Pragma (N, Pack_Id);\n+            Ensure_Aggregate_Form (Get_Argument (N, Pack_Id));\n+\n             --  Chain the pragma on the contract for further processing by\n             --  Analyze_Initializes_In_Decl_Part.\n \n@@ -16349,13 +16353,6 @@ package body Sem_Prag is\n \n             Analyze_If_Present (Pragma_SPARK_Mode);\n             Analyze_If_Present (Pragma_Abstract_State);\n-\n-            --  A pragma that applies to a Ghost entity becomes Ghost for the\n-            --  purposes of legality checks and removal of ignored Ghost code.\n-\n-            Mark_Pragma_As_Ghost (N, Pack_Id);\n-            Ensure_Aggregate_Form (Get_Argument (N, Pack_Id));\n-\n             Analyze_If_Present (Pragma_Initial_Condition);\n          end Initializes;\n \n@@ -16903,7 +16900,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, Typ);\n+            Mark_Ghost_Pragma (N, Typ);\n \n             --  The pragma defines a type-specific invariant, the type is said\n             --  to have invariants of its \"own\".\n@@ -17253,7 +17250,7 @@ package body Sem_Prag is\n                   --  the purposes of legality checks and removal of ignored\n                   --  Ghost code.\n \n-                  Mark_Pragma_As_Ghost (N, Ent);\n+                  Mark_Ghost_Pragma (N, Ent);\n \n                --  Subprograms\n \n@@ -17277,7 +17274,7 @@ package body Sem_Prag is\n                            --  Ghost for the purposes of legality checks and\n                            --  removal of ignored Ghost code.\n \n-                           Mark_Pragma_As_Ghost (N, Ent);\n+                           Mark_Ghost_Pragma (N, Ent);\n \n                            --  Capture the entity of the first Ghost subprogram\n                            --  being processed for error detection purposes.\n@@ -17685,7 +17682,7 @@ package body Sem_Prag is\n             --  Ghost. This also ensures that any expansion performed further\n             --  below will produce Ghost nodes.\n \n-            Mark_Pragma_As_Ghost (N, Entry_Id);\n+            Mark_Ghost_Pragma (N, Entry_Id);\n \n             --  Analyze the Integer expression\n \n@@ -17866,7 +17863,7 @@ package body Sem_Prag is\n                      --  for the purposes of legality checks and removal of\n                      --  ignored Ghost code.\n \n-                     Mark_Pragma_As_Ghost (N, E);\n+                     Mark_Ghost_Pragma (N, E);\n \n                      --  Capture the entity of the first Ghost procedure being\n                      --  processed for error detection purposes.\n@@ -18110,7 +18107,7 @@ package body Sem_Prag is\n                --  the purposes of legality checks and removal of ignored Ghost\n                --  code.\n \n-               Mark_Pragma_As_Ghost (N, E);\n+               Mark_Ghost_Pragma (N, E);\n \n                --  Entity name was given\n \n@@ -18514,7 +18511,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, Typ);\n+            Mark_Ghost_Pragma (N, Typ);\n \n             if not Is_Array_Type (Typ) and then not Is_Record_Type (Typ) then\n                Error_Pragma (\"pragma% must specify array or record type\");\n@@ -18737,12 +18734,11 @@ package body Sem_Prag is\n             end if;\n \n             Item_Id := Defining_Entity (Stmt);\n-            Encap   := Get_Pragma_Arg (Arg1);\n \n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, Item_Id);\n+            Mark_Ghost_Pragma (N, Item_Id);\n \n             --  Chain the pragma on the contract for further processing by\n             --  Analyze_Part_Of_In_Decl_Part or for completeness.\n@@ -18762,6 +18758,8 @@ package body Sem_Prag is\n             --  instantiation.\n \n             else\n+               Encap := Get_Pragma_Arg (Arg1);\n+\n                --  Detect any discrepancies between the placement of the\n                --  constant or package instantiation with respect to state\n                --  space and the encapsulating state.\n@@ -18888,7 +18886,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, Ent);\n+            Mark_Ghost_Pragma (N, Ent);\n \n             --  The pragma may come from an aspect on a private declaration,\n             --  even if the freeze point at which this is analyzed in the\n@@ -18976,13 +18974,12 @@ package body Sem_Prag is\n                end if;\n \n                Ent := Entity (Get_Pragma_Arg (Arg1));\n-               Decl := Parent (Ent);\n \n                --  A pragma that applies to a Ghost entity becomes Ghost for\n                --  the purposes of legality checks and removal of ignored Ghost\n                --  code.\n \n-               Mark_Pragma_As_Ghost (N, Ent);\n+               Mark_Ghost_Pragma (N, Ent);\n \n                --  Check for duplication before inserting in list of\n                --  representation items.\n@@ -18993,6 +18990,8 @@ package body Sem_Prag is\n                   return;\n                end if;\n \n+               Decl := Parent (Ent);\n+\n                if Present (Expression (Decl)) then\n                   Error_Pragma_Arg\n                     (\"object for pragma% cannot have initialization\", Arg1);\n@@ -19197,7 +19196,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, Typ);\n+            Mark_Ghost_Pragma (N, Typ);\n \n             --  The remaining processing is simply to link the pragma on to\n             --  the rep item chain, for processing when the type is frozen.\n@@ -19249,7 +19248,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, Typ);\n+            Mark_Ghost_Pragma (N, Typ);\n \n             --  The remaining processing is simply to link the pragma on to\n             --  the rep item chain, for processing when the type is frozen.\n@@ -19284,7 +19283,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, Ent);\n+            Mark_Ghost_Pragma (N, Ent);\n             Check_Duplicate_Pragma (Ent);\n \n             --  This filters out pragmas inside generic parents that show up\n@@ -19919,7 +19918,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, Ent);\n+            Mark_Ghost_Pragma (N, Ent);\n \n             if not Debug_Flag_U then\n                Set_Is_Pure (Ent);\n@@ -19958,7 +19957,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, E);\n+            Mark_Ghost_Pragma (N, E);\n \n             if Present (E) then\n                loop\n@@ -20303,6 +20302,11 @@ package body Sem_Prag is\n \n             Spec_Id := Corresponding_Spec (Pack_Decl);\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Ghost_Pragma (N, Spec_Id);\n+\n             --  Chain the pragma on the contract for further processing by\n             --  Analyze_Refined_State_In_Decl_Part.\n \n@@ -20313,11 +20317,6 @@ package body Sem_Prag is\n \n             Analyze_If_Present (Pragma_SPARK_Mode);\n \n-            --  A pragma that applies to a Ghost entity becomes Ghost for the\n-            --  purposes of legality checks and removal of ignored Ghost code.\n-\n-            Mark_Pragma_As_Ghost (N, Spec_Id);\n-\n             --  State refinement is allowed only when the corresponding package\n             --  declaration has non-null pragma Abstract_State. Refinement not\n             --  enforced when SPARK checks are suppressed (SPARK RM 7.2.2(3)).\n@@ -20401,7 +20400,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, E);\n+            Mark_Ghost_Pragma (N, E);\n \n             if Nkind (Parent (E)) = N_Formal_Type_Declaration\n               and then Ekind (E) = E_General_Access_Type\n@@ -20446,7 +20445,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, Cunit_Ent);\n+            Mark_Ghost_Pragma (N, Cunit_Ent);\n \n             if K = N_Package_Declaration\n               or else K = N_Generic_Package_Declaration\n@@ -20488,7 +20487,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, Cunit_Ent);\n+            Mark_Ghost_Pragma (N, Cunit_Ent);\n \n             if not Nkind_In (Unit (Cunit_Node), N_Package_Declaration,\n                                                 N_Generic_Package_Declaration)\n@@ -20688,7 +20687,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, Cunit_Ent);\n+            Mark_Ghost_Pragma (N, Cunit_Ent);\n \n             if not Nkind_In (Unit (Cunit_Node), N_Package_Declaration,\n                                                 N_Generic_Package_Declaration)\n@@ -20740,7 +20739,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, Typ);\n+            Mark_Ghost_Pragma (N, Typ);\n \n             --  We require the pragma to apply to a type declared in a package\n             --  declaration, but not (immediately) within a package body.\n@@ -21922,7 +21921,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, Nam_Id);\n+            Mark_Ghost_Pragma (N, Nam_Id);\n             Set_Debug_Info_Off (Nam_Id);\n          end Suppress_Debug_Info;\n \n@@ -21965,7 +21964,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, E);\n+            Mark_Ghost_Pragma (N, E);\n \n             if not Is_Type (E) and then Ekind (E) /= E_Variable then\n                Error_Pragma_Arg\n@@ -22366,16 +22365,16 @@ package body Sem_Prag is\n \n             Subp_Id := Defining_Entity (Subp_Decl);\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Ghost_Pragma (N, Subp_Id);\n+\n             --  Chain the pragma on the contract for further processing by\n             --  Analyze_Test_Case_In_Decl_Part.\n \n             Add_Contract_Item (N, Subp_Id);\n \n-            --  A pragma that applies to a Ghost entity becomes Ghost for the\n-            --  purposes of legality checks and removal of ignored Ghost code.\n-\n-            Mark_Pragma_As_Ghost (N, Subp_Id);\n-\n             --  Preanalyze the original aspect argument \"Name\" for ASIS or for\n             --  a generic subprogram to properly capture global references.\n \n@@ -22449,7 +22448,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, E);\n+            Mark_Ghost_Pragma (N, E);\n \n             if Rep_Item_Too_Early (E, N)\n                  or else\n@@ -22598,7 +22597,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, Typ);\n+            Mark_Ghost_Pragma (N, Typ);\n \n             if Typ = Any_Type\n               or else Rep_Item_Too_Early (Typ, N)\n@@ -22759,7 +22758,7 @@ package body Sem_Prag is\n             --  A pragma that applies to a Ghost entity becomes Ghost for the\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Mark_Pragma_As_Ghost (N, E_Id);\n+            Mark_Ghost_Pragma (N, E_Id);\n             Set_Universal_Aliasing (Implementation_Base_Type (E_Id));\n             Record_Rep_Item (E_Id, N);\n          end Universal_Alias;\n@@ -22835,7 +22834,7 @@ package body Sem_Prag is\n                      --  for the purposes of legality checks and removal of\n                      --  ignored Ghost code.\n \n-                     Mark_Pragma_As_Ghost (N, Arg_Id);\n+                     Mark_Ghost_Pragma (N, Arg_Id);\n \n                      --  Capture the entity of the first Ghost type being\n                      --  processed for error detection purposes.\n@@ -23069,6 +23068,11 @@ package body Sem_Prag is\n                return;\n             end if;\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Ghost_Pragma (N, Spec_Id);\n+\n             --  Chain the pragma on the contract for completeness\n \n             Add_Contract_Item (N, Spec_Id);\n@@ -23079,11 +23083,6 @@ package body Sem_Prag is\n \n             Analyze_If_Present (Pragma_SPARK_Mode);\n \n-            --  A pragma that applies to a Ghost entity becomes Ghost for the\n-            --  purposes of legality checks and removal of ignored Ghost code.\n-\n-            Mark_Pragma_As_Ghost (N, Spec_Id);\n-\n             --  A volatile function cannot override a non-volatile function\n             --  (SPARK RM 7.1.2(15)). Overriding checks are usually performed\n             --  in New_Overloaded_Entity, however at that point the pragma has\n@@ -23634,9 +23633,8 @@ package body Sem_Prag is\n       Spec_Id   : constant Entity_Id := Unique_Defining_Entity (Subp_Decl);\n       Expr      : constant Node_Id   := Expression (Get_Argument (N, Spec_Id));\n \n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n       Errors        : Nat;\n+      Mode          : Ghost_Mode_Type;\n       Restore_Scope : Boolean := False;\n \n    --  Start of processing for Analyze_Pre_Post_Condition_In_Decl_Part\n@@ -23653,7 +23651,7 @@ package body Sem_Prag is\n       --  point of analysis may not necessarily be the same. Use the mode in\n       --  effect at the point of declaration.\n \n-      Set_Ghost_Mode (N);\n+      Set_Ghost_Mode (N, Mode);\n \n       --  Ensure that the subprogram and its formals are visible when analyzing\n       --  the expression of the pragma.\n@@ -23722,9 +23720,9 @@ package body Sem_Prag is\n       --  subprogram subject to pragma Inline_Always.\n \n       Check_Postcondition_Use_In_Inlined_Subprogram (N, Spec_Id);\n-      Ghost_Mode := Save_Ghost_Mode;\n-\n       Set_Is_Analyzed_Pragma (N);\n+\n+      Restore_Ghost_Mode (Mode);\n    end Analyze_Pre_Post_Condition_In_Decl_Part;\n \n    ------------------------------------------"}, {"sha": "fc377a952fddc6197650ed5924f1721d050ca3b4", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -1996,25 +1996,13 @@ package body Sem_Res is\n          return;\n       end Resolution_Failed;\n \n-      --  Local variables\n-\n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n    --  Start of processing for Resolve\n \n    begin\n       if N = Error then\n          return;\n       end if;\n \n-      --  A declaration may be subject to pragma Ghost. Set the mode now to\n-      --  ensure that any nodes generated during analysis and expansion are\n-      --  marked as Ghost.\n-\n-      if Is_Declaration (N) then\n-         Set_Ghost_Mode (N);\n-      end if;\n-\n       --  Access attribute on remote subprogram cannot be used for a non-remote\n       --  access-to-subprogram type.\n \n@@ -2130,15 +2118,13 @@ package body Sem_Res is\n       if Analyzed (N) then\n          Debug_A_Exit (\"resolving  \", N, \"  (done, already analyzed)\");\n          Analyze_Dimension (N);\n-         Ghost_Mode := Save_Ghost_Mode;\n          return;\n \n       --  Any case of Any_Type as the Etype value means that we had a\n       --  previous error.\n \n       elsif Etype (N) = Any_Type then\n          Debug_A_Exit (\"resolving  \", N, \"  (done, Etype = Any_Type)\");\n-         Ghost_Mode := Save_Ghost_Mode;\n          return;\n       end if;\n \n@@ -2578,7 +2564,6 @@ package body Sem_Res is\n             then\n                Resolve (N, Full_View (Typ));\n                Set_Etype (N, Typ);\n-               Ghost_Mode := Save_Ghost_Mode;\n                return;\n \n             --  Check for an aggregate. Sometimes we can get bogus aggregates\n@@ -2687,7 +2672,6 @@ package body Sem_Res is\n             if Address_Integer_Convert_OK (Typ, Etype (N)) then\n                Rewrite (N, Unchecked_Convert_To (Typ, Relocate_Node (N)));\n                Analyze_And_Resolve (N, Typ);\n-               Ghost_Mode := Save_Ghost_Mode;\n                return;\n \n             --  Under relaxed RM semantics silently replace occurrences of null\n@@ -2725,8 +2709,8 @@ package body Sem_Res is\n \n                      Error_Msg_Node_2 := Typ;\n                      Error_Msg_NE\n-                       (\"no visible interpretation of& \"\n-                        & \"matches expected type&\", N, Subp_Name);\n+                       (\"no visible interpretation of& matches expected type&\",\n+                        N, Subp_Name);\n                   end;\n \n                   if All_Errors_Mode then\n@@ -2758,14 +2742,12 @@ package body Sem_Res is\n          end if;\n \n          Resolution_Failed;\n-         Ghost_Mode := Save_Ghost_Mode;\n          return;\n \n       --  Test if we have more than one interpretation for the context\n \n       elsif Ambiguous then\n          Resolution_Failed;\n-         Ghost_Mode := Save_Ghost_Mode;\n          return;\n \n       --  Only one intepretation\n@@ -2838,7 +2820,6 @@ package body Sem_Res is\n            and then Present (Entity (N))\n            and then Ekind (Entity (N)) /= E_Operator\n          then\n-\n             if not Is_Predefined_Op (Entity (N)) then\n                Rewrite_Operator_As_Call (N, Entity (N));\n \n@@ -2853,14 +2834,12 @@ package body Sem_Res is\n                --  Rewrite_Renamed_Operator.\n \n                if Analyzed (N) then\n-                  Ghost_Mode := Save_Ghost_Mode;\n                   return;\n                end if;\n             end if;\n          end if;\n \n          case N_Subexpr'(Nkind (N)) is\n-\n             when N_Aggregate => Resolve_Aggregate                (N, Ctx_Type);\n \n             when N_Allocator => Resolve_Allocator                (N, Ctx_Type);\n@@ -3003,7 +2982,6 @@ package body Sem_Res is\n          if Nkind (N) not in N_Subexpr then\n             Debug_A_Exit (\"resolving  \", N, \"  (done)\");\n             Expand (N);\n-            Ghost_Mode := Save_Ghost_Mode;\n             return;\n          end if;\n \n@@ -3038,8 +3016,6 @@ package body Sem_Res is\n \n          Expand (N);\n       end if;\n-\n-      Ghost_Mode := Save_Ghost_Mode;\n    end Resolve;\n \n    -------------"}, {"sha": "f9efdab2c0db7dc73dfab1f3e1ae338d367bea30", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -12074,33 +12074,38 @@ package body Sem_Util is\n    --------------------\n \n    function Is_Declaration (N : Node_Id) return Boolean is\n+   begin\n+      return\n+        Is_Declaration_Other_Than_Renaming (N)\n+          or else Is_Renaming_Declaration (N);\n+   end Is_Declaration;\n+\n+   ----------------------------------------\n+   -- Is_Declaration_Other_Than_Renaming --\n+   ----------------------------------------\n+\n+   function Is_Declaration_Other_Than_Renaming (N : Node_Id) return Boolean is\n    begin\n       case Nkind (N) is\n          when N_Abstract_Subprogram_Declaration        |\n               N_Exception_Declaration                  |\n-              N_Exception_Renaming_Declaration         |\n+              N_Expression_Function                    |\n               N_Full_Type_Declaration                  |\n-              N_Generic_Function_Renaming_Declaration  |\n               N_Generic_Package_Declaration            |\n-              N_Generic_Package_Renaming_Declaration   |\n-              N_Generic_Procedure_Renaming_Declaration |\n               N_Generic_Subprogram_Declaration         |\n               N_Number_Declaration                     |\n               N_Object_Declaration                     |\n-              N_Object_Renaming_Declaration            |\n               N_Package_Declaration                    |\n-              N_Package_Renaming_Declaration           |\n               N_Private_Extension_Declaration          |\n               N_Private_Type_Declaration               |\n               N_Subprogram_Declaration                 |\n-              N_Subprogram_Renaming_Declaration        |\n               N_Subtype_Declaration                    =>\n             return True;\n \n          when others                                   =>\n             return False;\n       end case;\n-   end Is_Declaration;\n+   end Is_Declaration_Other_Than_Renaming;\n \n    --------------------------------\n    -- Is_Declared_Within_Variant --"}, {"sha": "2088e7f691e7c56a983ab04c86fe42bb31f9a156", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -1361,6 +1361,9 @@ package Sem_Util is\n    function Is_Declaration (N : Node_Id) return Boolean;\n    --  Determine whether arbitrary node N denotes a declaration\n \n+   function Is_Declaration_Other_Than_Renaming (N : Node_Id) return Boolean;\n+   --  Determine whether arbitrary node N denotes a non-renaming declaration\n+\n    function Is_Declared_Within_Variant (Comp : Entity_Id) return Boolean;\n    --  Returns True iff component Comp is declared within a variant part\n "}, {"sha": "2ded5b82759661e7bd16556606da7174aa9092c7", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -1809,6 +1809,14 @@ package body Sinfo is\n       return Flag11 (N);\n    end Is_Checked;\n \n+   function Is_Checked_Ghost_Pragma\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Pragma);\n+      return Flag3 (N);\n+   end Is_Checked_Ghost_Pragma;\n+\n    function Is_Component_Left_Opnd\n       (N : Node_Id) return Boolean is\n    begin\n@@ -1917,22 +1925,22 @@ package body Sinfo is\n       return Flag2 (N);\n    end Is_Generic_Contract_Pragma;\n \n-   function Is_Ghost_Pragma\n+   function Is_Ignored\n       (N : Node_Id) return Boolean is\n    begin\n       pragma Assert (False\n+        or else NT (N).Nkind = N_Aspect_Specification\n         or else NT (N).Nkind = N_Pragma);\n-      return Flag3 (N);\n-   end Is_Ghost_Pragma;\n+      return Flag9 (N);\n+   end Is_Ignored;\n \n-   function Is_Ignored\n+   function Is_Ignored_Ghost_Pragma\n       (N : Node_Id) return Boolean is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Aspect_Specification\n         or else NT (N).Nkind = N_Pragma);\n-      return Flag9 (N);\n-   end Is_Ignored;\n+      return Flag8 (N);\n+   end Is_Ignored_Ghost_Pragma;\n \n    function Is_In_Discriminant_Check\n       (N : Node_Id) return Boolean is\n@@ -5088,6 +5096,14 @@ package body Sinfo is\n       Set_Flag11 (N, Val);\n    end Set_Is_Checked;\n \n+   procedure Set_Is_Checked_Ghost_Pragma\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Pragma);\n+      Set_Flag3 (N, Val);\n+   end Set_Is_Checked_Ghost_Pragma;\n+\n    procedure Set_Is_Component_Left_Opnd\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -5196,22 +5212,22 @@ package body Sinfo is\n       Set_Flag2 (N, Val);\n    end Set_Is_Generic_Contract_Pragma;\n \n-   procedure Set_Is_Ghost_Pragma\n+   procedure Set_Is_Ignored\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n       pragma Assert (False\n+        or else NT (N).Nkind = N_Aspect_Specification\n         or else NT (N).Nkind = N_Pragma);\n-      Set_Flag3 (N, Val);\n-   end Set_Is_Ghost_Pragma;\n+      Set_Flag9 (N, Val);\n+   end Set_Is_Ignored;\n \n-   procedure Set_Is_Ignored\n+   procedure Set_Is_Ignored_Ghost_Pragma\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Aspect_Specification\n         or else NT (N).Nkind = N_Pragma);\n-      Set_Flag9 (N, Val);\n-   end Set_Is_Ignored;\n+      Set_Flag8 (N, Val);\n+   end Set_Is_Ignored_Ghost_Pragma;\n \n    procedure Set_Is_In_Discriminant_Check\n       (N : Node_Id; Val : Boolean := True) is"}, {"sha": "dd1aec58036f7c0a13c7706fb79d3d06309726fd", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 95, "deletions": 26, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d65a80fd559aca749b54eb6affd71d2d84f410f8/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=d65a80fd559aca749b54eb6affd71d2d84f410f8", "patch": "@@ -528,26 +528,81 @@ package Sinfo is\n    -- Ghost Mode --\n    ----------------\n \n-   --  When a declaration is subject to pragma Ghost, it establishes a Ghost\n-   --  region depending on the Ghost assertion policy in effect at the point\n-   --  of declaration. This region is temporal and starts right before the\n-   --  analysis of the Ghost declaration and ends after its expansion. The\n-   --  values of global variable Opt.Ghost_Mode are as follows:\n+   --  The SPARK RM 6.9 defines two classes of constructs - Ghost entities and\n+   --  Ghost statements. The intent of the feature is to treat Ghost constructs\n+   --  as non-existent when Ghost assertion policy Ignore is in effect.\n+\n+   --  The corresponding nodes which map to Ghost constructs are:\n+\n+   --    Ghost entities\n+   --      Declaration nodes\n+   --      N_Package_Body\n+   --      N_Subprogram_Body\n+\n+   --    Ghost statements\n+   --      N_Assignment_Statement\n+   --      N_Procedure_Call_Statement\n+   --      N_Pragma\n+\n+   --  In addition, the compiler treats instantiations as Ghost entities\n+\n+   --  To achieve the removal of ignored Ghost constructs, the compiler relies\n+   --  on global variable Ghost_Mode and a mechanism called \"Ghost regions\".\n+   --  The values of the global variable are as follows:\n \n    --    1. Check - All static semantics as defined in SPARK RM 6.9 are in\n-   --       effect.\n+   --       effect. The Ghost region has mode Check.\n \n    --    2. Ignore - Same as Check, ignored Ghost code is not present in ALI\n-   --       files, object files as well as the final executable.\n+   --       files, object files, and the final executable. The Ghost region\n+   --       has mode Ignore.\n+\n+   --    3. None - No Ghost region is in effect\n+\n+   --  A Ghost region is a compiler operating mode, similar to Check_Syntax,\n+   --  however a region is much more finely grained and depends on the policy\n+   --  in effect. The region starts prior to the analysis of a Ghost construct\n+   --  and ends immediately after its expansion. The region is established as\n+   --  follows:\n+\n+   --    1. Declarations - Prior to analysis, if the declaration is subject to\n+   --       pragma Ghost.\n+\n+   --    2. Renaming declarations - Same as 1) or when the renamed entity is\n+   --       Ghost.\n \n-   --  To achieve the runtime semantics of \"Ignore\", the compiler marks each\n-   --  node created during an ignored Ghost region and signals all enclosing\n-   --  scopes that such a node resides within. The compilation unit where the\n-   --  node resides is also added to an auxiliary table for post processing.\n+   --    3. Completing declarations - Same as 1) or when the declaration is\n+   --       partially analyzed and the declaration completes a Ghost entity.\n+\n+   --    4. N_Package_Body, N_Subprogram_Body - Same as 1) or when the body is\n+   --       partially analyzed and completes a Ghost entity.\n+\n+   --    5. N_Assignment_Statement - After the left hand side is analyzed and\n+   --       references a Ghost entity.\n+\n+   --    6. N_Procedure_Call_Statement - After the name is analyzed and denotes\n+   --       a Ghost procedure.\n+\n+   --    7. N_Pragma - During analysis, when the related entity is Ghost or the\n+   --       pragma encloses a Ghost entity.\n+\n+   --    8. Instantiations - Save as 1) or when the instantiation is partially\n+   --       analyzed and the generic template is Ghost.\n+\n+   --  Routines Mark_And_Set_Ghost_xxx install a new Ghost region and routine\n+   --  Restore_Ghost_Mode ends a Ghost region. A region may be reinstalled\n+   --  similar to scopes for decoupled expansion such as the generation of\n+   --  dispatch tables or the creation of a predicate function.\n+\n+   --  If the mode of a Ghost region is Ignore, any newly created nodes as well\n+   --  as source entities are marked as ignored Ghost. In additon, the marking\n+   --  process signals all enclosing scopes that an ignored Ghost node resides\n+   --  within. The compilation unit where the node resides is also added to an\n+   --  auxiliary table for post processing.\n \n    --  After the analysis and expansion of all compilation units takes place\n    --  as well as the instantiation of all inlined [generic] bodies, the GNAT\n-   --  driver initiates a separate pass which removes all ignored Ghost code\n+   --  driver initiates a separate pass which removes all ignored Ghost nodes\n    --  from all units stored in the auxiliary table.\n \n    --------------------\n@@ -1581,6 +1636,11 @@ package Sinfo is\n    --    be further modified (in some cases these flags are copied when a\n    --    pragma is rewritten).\n \n+   --  Is_Checked_Ghost_Pragma (Flag3-Sem)\n+   --    This flag is present in N_Pragma nodes. It is set when the pragma is\n+   --    related to a checked Ghost entity or encloses a checked Ghost entity.\n+   --    This flag has no relation to Is_Checked.\n+\n    --  Is_Component_Left_Opnd  (Flag13-Sem)\n    --  Is_Component_Right_Opnd (Flag14-Sem)\n    --    Present in concatenation nodes, to indicate that the corresponding\n@@ -1651,11 +1711,6 @@ package Sinfo is\n    --      Refined_State\n    --      Test_Case\n \n-   --  Is_Ghost_Pragma (Flag3-Sem)\n-   --    This flag is present in N_Pragma nodes. It is set when the pragma is\n-   --    either declared within a Ghost construct or it applies to a Ghost\n-   --    construct.\n-\n    --  Is_Ignored (Flag9-Sem)\n    --    A flag set in an N_Aspect_Specification or N_Pragma node if there was\n    --    a Check_Policy or Assertion_Policy (or in the case of a Debug_Pragma)\n@@ -1670,6 +1725,11 @@ package Sinfo is\n    --    aspect/pragma is fully analyzed and checked for other syntactic\n    --    and semantic errors, but it does not have any semantic effect.\n \n+   --  Is_Ignored_Ghost_Pragma (Flag8-Sem)\n+   --    This flag is present in N_Pragma nodes. It is set when the pragma is\n+   --    related to an ignored Ghost entity or encloses ignored Ghost entity.\n+   --    This flag has no relation to Is_Ignored.\n+\n    --  Is_In_Discriminant_Check (Flag11-Sem)\n    --    This flag is present in a selected component, and is used to indicate\n    --    that the reference occurs within a discriminant check. The\n@@ -2519,11 +2579,12 @@ package Sinfo is\n       --  Import_Interface_Present (Flag16-Sem)\n       --  Is_Analyzed_Pragma (Flag5-Sem)\n       --  Is_Checked (Flag11-Sem)\n+      --  Is_Checked_Ghost_Pragma (Flag3-Sem)\n       --  Is_Delayed_Aspect (Flag14-Sem)\n       --  Is_Disabled (Flag15-Sem)\n       --  Is_Generic_Contract_Pragma (Flag2-Sem)\n-      --  Is_Ghost_Pragma (Flag3-Sem)\n       --  Is_Ignored (Flag9-Sem)\n+      --  Is_Ignored_Ghost_Pragma (Flag8-Sem)\n       --  Is_Inherited_Pragma (Flag4-Sem)\n       --  Split_PPC (Flag17) set if corresponding aspect had Split_PPC set\n       --  Uneval_Old_Accept (Flag7-Sem)\n@@ -9364,6 +9425,9 @@ package Sinfo is\n    function Is_Checked\n      (N : Node_Id) return Boolean;    -- Flag11\n \n+   function Is_Checked_Ghost_Pragma\n+     (N : Node_Id) return Boolean;    -- Flag3\n+\n    function Is_Component_Left_Opnd\n      (N : Node_Id) return Boolean;    -- Flag13\n \n@@ -9403,12 +9467,12 @@ package Sinfo is\n    function Is_Generic_Contract_Pragma\n      (N : Node_Id) return Boolean;    -- Flag2\n \n-   function Is_Ghost_Pragma\n-     (N : Node_Id) return Boolean;    -- Flag3\n-\n    function Is_Ignored\n      (N : Node_Id) return Boolean;    -- Flag9\n \n+   function Is_Ignored_Ghost_Pragma\n+     (N : Node_Id) return Boolean;    -- Flag8\n+\n    function Is_In_Discriminant_Check\n      (N : Node_Id) return Boolean;    -- Flag11\n \n@@ -10414,6 +10478,9 @@ package Sinfo is\n    procedure Set_Is_Checked\n      (N : Node_Id; Val : Boolean := True);    -- Flag11\n \n+   procedure Set_Is_Checked_Ghost_Pragma\n+     (N : Node_Id; Val : Boolean := True);    -- Flag3\n+\n    procedure Set_Is_Component_Left_Opnd\n      (N : Node_Id; Val : Boolean := True);    -- Flag13\n \n@@ -10453,12 +10520,12 @@ package Sinfo is\n    procedure Set_Is_Generic_Contract_Pragma\n      (N : Node_Id; Val : Boolean := True);    -- Flag2\n \n-   procedure Set_Is_Ghost_Pragma\n-     (N : Node_Id; Val : Boolean := True);    -- Flag3\n-\n    procedure Set_Is_Ignored\n      (N : Node_Id; Val : Boolean := True);    -- Flag9\n \n+   procedure Set_Is_Ignored_Ghost_Pragma\n+     (N : Node_Id; Val : Boolean := True);    -- Flag8\n+\n    procedure Set_Is_In_Discriminant_Check\n      (N : Node_Id; Val : Boolean := True);    -- Flag11\n \n@@ -12865,6 +12932,7 @@ package Sinfo is\n    pragma Inline (Is_Asynchronous_Call_Block);\n    pragma Inline (Is_Boolean_Aspect);\n    pragma Inline (Is_Checked);\n+   pragma Inline (Is_Checked_Ghost_Pragma);\n    pragma Inline (Is_Component_Left_Opnd);\n    pragma Inline (Is_Component_Right_Opnd);\n    pragma Inline (Is_Controlling_Actual);\n@@ -12878,8 +12946,8 @@ package Sinfo is\n    pragma Inline (Is_Finalization_Wrapper);\n    pragma Inline (Is_Folded_In_Parser);\n    pragma Inline (Is_Generic_Contract_Pragma);\n-   pragma Inline (Is_Ghost_Pragma);\n    pragma Inline (Is_Ignored);\n+   pragma Inline (Is_Ignored_Ghost_Pragma);\n    pragma Inline (Is_In_Discriminant_Check);\n    pragma Inline (Is_Inherited_Pragma);\n    pragma Inline (Is_Machine_Number);\n@@ -13210,6 +13278,7 @@ package Sinfo is\n    pragma Inline (Set_Is_Asynchronous_Call_Block);\n    pragma Inline (Set_Is_Boolean_Aspect);\n    pragma Inline (Set_Is_Checked);\n+   pragma Inline (Set_Is_Checked_Ghost_Pragma);\n    pragma Inline (Set_Is_Component_Left_Opnd);\n    pragma Inline (Set_Is_Component_Right_Opnd);\n    pragma Inline (Set_Is_Controlling_Actual);\n@@ -13223,8 +13292,8 @@ package Sinfo is\n    pragma Inline (Set_Is_Finalization_Wrapper);\n    pragma Inline (Set_Is_Folded_In_Parser);\n    pragma Inline (Set_Is_Generic_Contract_Pragma);\n-   pragma Inline (Set_Is_Ghost_Pragma);\n    pragma Inline (Set_Is_Ignored);\n+   pragma Inline (Set_Is_Ignored_Ghost_Pragma);\n    pragma Inline (Set_Is_In_Discriminant_Check);\n    pragma Inline (Set_Is_Inherited_Pragma);\n    pragma Inline (Set_Is_Machine_Number);"}]}