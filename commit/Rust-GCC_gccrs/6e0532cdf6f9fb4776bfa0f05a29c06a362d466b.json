{"sha": "6e0532cdf6f9fb4776bfa0f05a29c06a362d466b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUwNTMyY2RmNmY5ZmI0Nzc2YmZhMGYwNWEyOWMwNmEzNjJkNDY2Yg==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2002-08-24T22:46:19Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2002-08-24T22:46:19Z"}, "message": "Makefile.am (libgcj_la_SOURCES): Remove name-finder.cc.\n\n        * Makefile.am (libgcj_la_SOURCES): Remove name-finder.cc.\n        (core_java_source_files): Add VMThrowable.java and NameFinder.java\n        (nat_source_files): Remove natThrowable.cc, add natVMThrowable.cc\n        and natNameFinder.cc.\n        * Makefile.in: Regenerate.\n        * prims.cc: Use trace_enabled from VMThrowable.\n        * name-finder.cc: Removed.\n        * gcj/javaprims.h: Add class VMThrowable.\n        * gnu/gcj/runtime/NameFinder.java: New file.\n        * gnu/gcj/runtime/natNameFinder.cc: Likewise.\n        * include/name-finder.h: Removed.\n        * java/lang/Throwable.java (printStackTrace (PrintStream)): Use new\n        method stackTraceString().\n        (printStackTrace (PrintWriter)): Likewise.\n        (stackTraceString): Complete rewrite of old printStackTrace using\n        StringBuffer.\n        (stackTraceStringBuffer): New helper method for stackTraceString().\n        (fillInStackTrace): Delegate to VMTrowable.\n        (getStackTrace): Likewise.\n        (getStackTrace0): Removed.\n        (trace_enabled, stackTraceBytes): Moved to new VMThrowable.java.\n        (setStackTrace): Copy given array.\n        * java/lang/natThrowable.cc: Removed (replaced by natVMThrowable).\n        * java/lang/VMThrowable.java: New class.\n        * java/lang/natVMThrowable.cc: New file.\n\nFrom-SVN: r56556", "tree": {"sha": "2194f5746d8d192d6202800f3df90a8ccb1675e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2194f5746d8d192d6202800f3df90a8ccb1675e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b/comments", "author": null, "committer": null, "parents": [{"sha": "4906d5d83e08494b70297808d6818faffd89c2a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4906d5d83e08494b70297808d6818faffd89c2a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4906d5d83e08494b70297808d6818faffd89c2a0"}], "stats": {"total": 1466, "additions": 821, "deletions": 645}, "files": [{"sha": "71b789ff50d25b9c18e5200932bc1a81b2aa6a88", "filename": "libjava/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=6e0532cdf6f9fb4776bfa0f05a29c06a362d466b", "patch": "@@ -1,3 +1,31 @@\n+2002-08-24  Mark Wielaard <mark@klomp.org>\n+\n+\t* Makefile.am (libgcj_la_SOURCES): Remove name-finder.cc.\n+\t(core_java_source_files): Add VMThrowable.java and NameFinder.java\n+\t(nat_source_files): Remove natThrowable.cc, add natVMThrowable.cc\n+\tand natNameFinder.cc.\n+\t* Makefile.in: Regenerate.\n+\t* prims.cc: Use trace_enabled from VMThrowable.\n+\t* name-finder.cc: Removed.\n+\t* gcj/javaprims.h: Add class VMThrowable.\n+\t* gnu/gcj/runtime/NameFinder.java: New file.\n+\t* gnu/gcj/runtime/natNameFinder.cc: Likewise.\n+\t* include/name-finder.h: Removed.\n+\t* java/lang/Throwable.java (printStackTrace (PrintStream)): Use new\n+\tmethod stackTraceString().\n+\t(printStackTrace (PrintWriter)): Likewise.\n+\t(stackTraceString): Complete rewrite of old printStackTrace using\n+\tStringBuffer.\n+\t(stackTraceStringBuffer): New helper method for stackTraceString().\n+\t(fillInStackTrace): Delegate to VMTrowable.\n+\t(getStackTrace): Likewise.\n+\t(getStackTrace0): Removed. \n+\t(trace_enabled, stackTraceBytes): Moved to new VMThrowable.java.\n+\t(setStackTrace): Copy given array.\n+\t* java/lang/natThrowable.cc: Removed (replaced by natVMThrowable).\n+\t* java/lang/VMThrowable.java: New class.\n+\t* java/lang/natVMThrowable.cc: New file.\n+\n 2003-08-23  Michael Koch  <konqueror@gmx.de>\n \n \t* java/net/URLConnection.java,"}, {"sha": "ef10fe91c0d24a15e91ca007ee8b1d38cfbb2ebf", "filename": "libjava/Makefile.am", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=6e0532cdf6f9fb4776bfa0f05a29c06a362d466b", "patch": "@@ -128,7 +128,7 @@ javao_files = $(java_source_files:.java=.lo) \\\n x_javao_files = $(x_java_source_files:.java=.lo)\n \n libgcj_la_SOURCES = prims.cc jni.cc exception.cc \\\n-\tresolve.cc defineclass.cc interpret.cc name-finder.cc verify.cc \\\n+\tresolve.cc defineclass.cc interpret.cc verify.cc \\\n \t$(nat_source_files)\n EXTRA_libgcj_la_SOURCES = boehm.cc nogc.cc posix-threads.cc no-threads.cc \\\n \twin32-threads.cc posix.cc win32.cc \\\n@@ -1527,6 +1527,7 @@ java/lang/VerifyError.java \\\n java/lang/VirtualMachineError.java \\\n java/lang/VMClassLoader.java \\\n java/lang/VMSecurityManager.java \\\n+java/lang/VMThrowable.java \\\n java/lang/Void.java \\\n java/io/BufferedInputStream.java \\\n java/io/BufferedOutputStream.java \\\n@@ -1687,6 +1688,7 @@ gnu/gcj/runtime/FileDeleter.java \\\n gnu/gcj/runtime/FinalizerThread.java \\\n gnu/gcj/runtime/FirstThread.java \\\n gnu/gcj/runtime/JNIWeakRef.java \\\n+gnu/gcj/runtime/NameFinder.java \\\n gnu/gcj/runtime/SharedLibLoader.java \\\n gnu/gcj/runtime/StringBuffer.java \\\n gnu/gcj/runtime/VMClassLoader.java \\\n@@ -2204,6 +2206,7 @@ gnu/gcj/io/shs.cc \\\n gnu/gcj/protocol/core/natCoreInputStream.cc \\\n gnu/gcj/runtime/natFinalizerThread.cc \\\n gnu/gcj/runtime/natFirstThread.cc \\\n+gnu/gcj/runtime/natNameFinder.cc \\\n gnu/gcj/runtime/natSharedLibLoader.cc \\\n gnu/gcj/runtime/natStringBuffer.cc \\\n java/io/natFile.cc \\\n@@ -2223,7 +2226,7 @@ java/lang/natString.cc \\\n java/lang/natStringBuffer.cc \\\n java/lang/natSystem.cc \\\n java/lang/natThread.cc \\\n-java/lang/natThrowable.cc \\\n+java/lang/natVMThrowable.cc \\\n java/lang/ref/natReference.cc \\\n java/lang/reflect/natArray.cc \\\n java/lang/reflect/natConstructor.cc \\"}, {"sha": "2de61223dc67f58ab786b393515dad33cc068178", "filename": "libjava/Makefile.in", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=6e0532cdf6f9fb4776bfa0f05a29c06a362d466b", "patch": "@@ -195,7 +195,7 @@ javao_files = $(java_source_files:.java=.lo) \\\n x_javao_files = $(x_java_source_files:.java=.lo)\n \n libgcj_la_SOURCES = prims.cc jni.cc exception.cc \\\n-\tresolve.cc defineclass.cc interpret.cc name-finder.cc verify.cc \\\n+\tresolve.cc defineclass.cc interpret.cc verify.cc \\\n \t$(nat_source_files)\n \n EXTRA_libgcj_la_SOURCES = boehm.cc nogc.cc posix-threads.cc no-threads.cc \\\n@@ -1294,6 +1294,7 @@ java/lang/VerifyError.java \\\n java/lang/VirtualMachineError.java \\\n java/lang/VMClassLoader.java \\\n java/lang/VMSecurityManager.java \\\n+java/lang/VMThrowable.java \\\n java/lang/Void.java \\\n java/io/BufferedInputStream.java \\\n java/io/BufferedOutputStream.java \\\n@@ -1449,6 +1450,7 @@ gnu/gcj/runtime/FileDeleter.java \\\n gnu/gcj/runtime/FinalizerThread.java \\\n gnu/gcj/runtime/FirstThread.java \\\n gnu/gcj/runtime/JNIWeakRef.java \\\n+gnu/gcj/runtime/NameFinder.java \\\n gnu/gcj/runtime/SharedLibLoader.java \\\n gnu/gcj/runtime/StringBuffer.java \\\n gnu/gcj/runtime/VMClassLoader.java \\\n@@ -1965,6 +1967,7 @@ gnu/gcj/io/shs.cc \\\n gnu/gcj/protocol/core/natCoreInputStream.cc \\\n gnu/gcj/runtime/natFinalizerThread.cc \\\n gnu/gcj/runtime/natFirstThread.cc \\\n+gnu/gcj/runtime/natNameFinder.cc \\\n gnu/gcj/runtime/natSharedLibLoader.cc \\\n gnu/gcj/runtime/natStringBuffer.cc \\\n java/io/natFile.cc \\\n@@ -1984,7 +1987,7 @@ java/lang/natString.cc \\\n java/lang/natStringBuffer.cc \\\n java/lang/natSystem.cc \\\n java/lang/natThread.cc \\\n-java/lang/natThrowable.cc \\\n+java/lang/natVMThrowable.cc \\\n java/lang/ref/natReference.cc \\\n java/lang/reflect/natArray.cc \\\n java/lang/reflect/natConstructor.cc \\\n@@ -2123,15 +2126,15 @@ X_LIBS = @X_LIBS@\n X_EXTRA_LIBS = @X_EXTRA_LIBS@\n X_PRE_LIBS = @X_PRE_LIBS@\n libgcj_la_OBJECTS =  prims.lo jni.lo exception.lo resolve.lo \\\n-defineclass.lo interpret.lo name-finder.lo verify.lo gnu/gcj/natCore.lo \\\n+defineclass.lo interpret.lo verify.lo gnu/gcj/natCore.lo \\\n gnu/gcj/convert/JIS0208_to_Unicode.lo \\\n gnu/gcj/convert/JIS0212_to_Unicode.lo gnu/gcj/convert/Unicode_to_JIS.lo \\\n gnu/gcj/convert/natIconv.lo gnu/gcj/convert/natInput_EUCJIS.lo \\\n gnu/gcj/convert/natInput_SJIS.lo gnu/gcj/convert/natOutput_EUCJIS.lo \\\n gnu/gcj/convert/natOutput_SJIS.lo gnu/gcj/io/natSimpleSHSStream.lo \\\n gnu/gcj/io/shs.lo gnu/gcj/protocol/core/natCoreInputStream.lo \\\n gnu/gcj/runtime/natFinalizerThread.lo gnu/gcj/runtime/natFirstThread.lo \\\n-gnu/gcj/runtime/natSharedLibLoader.lo \\\n+gnu/gcj/runtime/natNameFinder.lo gnu/gcj/runtime/natSharedLibLoader.lo \\\n gnu/gcj/runtime/natStringBuffer.lo java/io/natFile.lo \\\n java/io/natFileDescriptor.lo java/io/natObjectInputStream.lo \\\n java/io/natObjectOutputStream.lo java/lang/natCharacter.lo \\\n@@ -2140,7 +2143,7 @@ java/lang/natConcreteProcess.lo java/lang/natDouble.lo \\\n java/lang/natFloat.lo java/lang/natMath.lo java/lang/natObject.lo \\\n java/lang/natRuntime.lo java/lang/natString.lo \\\n java/lang/natStringBuffer.lo java/lang/natSystem.lo \\\n-java/lang/natThread.lo java/lang/natThrowable.lo \\\n+java/lang/natThread.lo java/lang/natVMThrowable.lo \\\n java/lang/ref/natReference.lo java/lang/reflect/natArray.lo \\\n java/lang/reflect/natConstructor.lo java/lang/reflect/natField.lo \\\n java/lang/reflect/natMethod.lo java/net/natInetAddress.lo \\\n@@ -2246,11 +2249,13 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/gcj/runtime/FileDeleter.P \\\n .deps/gnu/gcj/runtime/FinalizerThread.P \\\n .deps/gnu/gcj/runtime/FirstThread.P .deps/gnu/gcj/runtime/JNIWeakRef.P \\\n+.deps/gnu/gcj/runtime/NameFinder.P \\\n .deps/gnu/gcj/runtime/SharedLibLoader.P \\\n .deps/gnu/gcj/runtime/StringBuffer.P \\\n .deps/gnu/gcj/runtime/VMClassLoader.P \\\n .deps/gnu/gcj/runtime/natFinalizerThread.P \\\n .deps/gnu/gcj/runtime/natFirstThread.P \\\n+.deps/gnu/gcj/runtime/natNameFinder.P \\\n .deps/gnu/gcj/runtime/natSharedLibLoader.P \\\n .deps/gnu/gcj/runtime/natStringBuffer.P .deps/gnu/gcj/xlib/Clip.P \\\n .deps/gnu/gcj/xlib/Colormap.P .deps/gnu/gcj/xlib/Display.P \\\n@@ -2813,8 +2818,9 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/lang/UnsupportedClassVersionError.P \\\n .deps/java/lang/UnsupportedOperationException.P \\\n .deps/java/lang/VMClassLoader.P .deps/java/lang/VMSecurityManager.P \\\n-.deps/java/lang/VerifyError.P .deps/java/lang/VirtualMachineError.P \\\n-.deps/java/lang/Void.P .deps/java/lang/dtoa.P .deps/java/lang/e_acos.P \\\n+.deps/java/lang/VMThrowable.P .deps/java/lang/VerifyError.P \\\n+.deps/java/lang/VirtualMachineError.P .deps/java/lang/Void.P \\\n+.deps/java/lang/dtoa.P .deps/java/lang/e_acos.P \\\n .deps/java/lang/e_asin.P .deps/java/lang/e_atan2.P \\\n .deps/java/lang/e_exp.P .deps/java/lang/e_fmod.P \\\n .deps/java/lang/e_log.P .deps/java/lang/e_pow.P \\\n@@ -2828,7 +2834,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/lang/natMath.P .deps/java/lang/natObject.P \\\n .deps/java/lang/natRuntime.P .deps/java/lang/natString.P \\\n .deps/java/lang/natStringBuffer.P .deps/java/lang/natSystem.P \\\n-.deps/java/lang/natThread.P .deps/java/lang/natThrowable.P \\\n+.deps/java/lang/natThread.P .deps/java/lang/natVMThrowable.P \\\n .deps/java/lang/ref/PhantomReference.P .deps/java/lang/ref/Reference.P \\\n .deps/java/lang/ref/ReferenceQueue.P \\\n .deps/java/lang/ref/SoftReference.P .deps/java/lang/ref/WeakReference.P \\\n@@ -3468,17 +3474,17 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/javax/transaction/UserTransaction.P \\\n .deps/javax/transaction/xa/XAException.P \\\n .deps/javax/transaction/xa/XAResource.P \\\n-.deps/javax/transaction/xa/Xid.P .deps/jni.P .deps/name-finder.P \\\n-.deps/no-threads.P .deps/nogc.P .deps/org/w3c/dom/Attr.P \\\n-.deps/org/w3c/dom/CDATASection.P .deps/org/w3c/dom/CharacterData.P \\\n-.deps/org/w3c/dom/Comment.P .deps/org/w3c/dom/DOMException.P \\\n-.deps/org/w3c/dom/DOMImplementation.P .deps/org/w3c/dom/Document.P \\\n-.deps/org/w3c/dom/DocumentFragment.P .deps/org/w3c/dom/DocumentType.P \\\n-.deps/org/w3c/dom/Element.P .deps/org/w3c/dom/Entity.P \\\n-.deps/org/w3c/dom/EntityReference.P .deps/org/w3c/dom/NamedNodeMap.P \\\n-.deps/org/w3c/dom/Node.P .deps/org/w3c/dom/NodeList.P \\\n-.deps/org/w3c/dom/Notation.P .deps/org/w3c/dom/ProcessingInstruction.P \\\n-.deps/org/w3c/dom/Text.P .deps/org/w3c/dom/ranges/DocumentRange.P \\\n+.deps/javax/transaction/xa/Xid.P .deps/jni.P .deps/no-threads.P \\\n+.deps/nogc.P .deps/org/w3c/dom/Attr.P .deps/org/w3c/dom/CDATASection.P \\\n+.deps/org/w3c/dom/CharacterData.P .deps/org/w3c/dom/Comment.P \\\n+.deps/org/w3c/dom/DOMException.P .deps/org/w3c/dom/DOMImplementation.P \\\n+.deps/org/w3c/dom/Document.P .deps/org/w3c/dom/DocumentFragment.P \\\n+.deps/org/w3c/dom/DocumentType.P .deps/org/w3c/dom/Element.P \\\n+.deps/org/w3c/dom/Entity.P .deps/org/w3c/dom/EntityReference.P \\\n+.deps/org/w3c/dom/NamedNodeMap.P .deps/org/w3c/dom/Node.P \\\n+.deps/org/w3c/dom/NodeList.P .deps/org/w3c/dom/Notation.P \\\n+.deps/org/w3c/dom/ProcessingInstruction.P .deps/org/w3c/dom/Text.P \\\n+.deps/org/w3c/dom/ranges/DocumentRange.P \\\n .deps/org/w3c/dom/ranges/Range.P \\\n .deps/org/w3c/dom/ranges/RangeException.P \\\n .deps/org/w3c/dom/traversal/DocumentTraversal.P \\"}, {"sha": "3378a9faf6688bfdd8df9bac6f611c86cc4facb4", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=6e0532cdf6f9fb4776bfa0f05a29c06a362d466b", "patch": "@@ -211,6 +211,7 @@ extern \"Java\"\n       class UnsupportedOperationException;\n       class VMClassLoader;\n       class VMSecurityManager;\n+      class VMThrowable;\n       class VerifyError;\n       class VirtualMachineError;\n       class Void;"}, {"sha": "60f47ac64fecf7a4dd4a3fa2bdd2617c38de219c", "filename": "libjava/gnu/gcj/runtime/NameFinder.java", "status": "added", "additions": 407, "deletions": 0, "changes": 407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b/libjava%2Fgnu%2Fgcj%2Fruntime%2FNameFinder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b/libjava%2Fgnu%2Fgcj%2Fruntime%2FNameFinder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FNameFinder.java?ref=6e0532cdf6f9fb4776bfa0f05a29c06a362d466b", "patch": "@@ -0,0 +1,407 @@\n+/* NameFinder.java -- Translates addresses to StackTraceElements.\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.runtime;\n+\n+import gnu.gcj.RawData;\n+\n+import java.lang.StringBuffer;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.io.IOException;\n+import java.io.File;\n+\n+/**\n+ * Helper class that translates addresses (represented as longs) to a\n+ * StackTraceElement array.\n+ *\n+ * There are a couple of system properties that can be set to manipulate the\n+ * result (all default to true):\n+ * <li>\n+ * <ul><code>gnu.gcj.runtime.NameFinder.demangle</code>\n+ *     Whether names should be demangled.</ul>\n+ * <ul><code>gnu.gcj.runtime.NameFinder.sanitize</code></ul>\n+ *     Whether calls to initialize exceptions and starting the runtime system\n+ *     should be removed from the stack trace. Only done when names are\n+ *     demangled.</ul>\n+ * <ul><code>gnu.gcj.runtime.NameFinder.remove_unknown</code>\n+ *     Wheter calls to unknown functions (class and method names are unknown)\n+ *     should be removed from the stack trace. Only done when the stack is\n+ *     sanitized.</ul>\n+ * <ul><code>gnu.gcj.runtime.NameFinder.use_addr2line</code>\n+ *     Wheter an external process (addr2line or addr2name.awk) should be used\n+ *     as fallback to convert the addresses to function names when the runtime\n+ *     is unable to do it through <code>dladdr</code>.</ul>\n+ * </li>\n+ *\n+ * <code>close()</code> should be called to get rid of all resources.\n+ *\n+ * This class is used from <code>java.lang.VMThrowable</code>.\n+ *\n+ * Currently the <code>lookup(long[])</code> method is not thread safe.\n+ * It can easily be made thread safe by synchronizing access to all external\n+ * processes when used.\n+ *   \n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+public class NameFinder\n+{\n+  // Set these to false when not needed.\n+  private static final boolean demangle\n+\t  = Boolean.valueOf(System.getProperty\n+\t\t(\"gnu.gcj.runtime.NameFinder.demangle\", \"true\")\n+\t    ).booleanValue();\n+  private static final boolean sanitize\n+\t  = Boolean.valueOf(System.getProperty\n+\t\t(\"gnu.gcj.runtime.NameFinder.sanitize\", \"true\")\n+\t    ).booleanValue();\n+  private static final boolean remove_unknown\n+\t  = Boolean.valueOf(System.getProperty\n+\t\t(\"gnu.gcj.runtime.NameFinder.remove_unknown\", \"true\")\n+\t    ).booleanValue();\n+  private static final boolean use_addr2line\n+\t  = Boolean.valueOf(System.getProperty\n+\t\t(\"gnu.gcj.runtime.NameFinder.use_addr2line\", \"true\")\n+\t    ).booleanValue();\n+\n+  /**\n+   * The name of the currently running executable.\n+   */\n+  private final String executable;\n+\n+  /**\n+   * Process used for demangling names.\n+   */\n+  private Process cppfilt;\n+\n+  private BufferedWriter cppfiltOut;\n+  private BufferedReader cppfiltIn;\n+\n+  /**\n+   * Process used for translating addresses to function/file names.\n+   */\n+  private Process addr2line;\n+\n+  private BufferedWriter addr2lineOut;\n+  private BufferedReader addr2lineIn;\n+\n+  /**\n+   * Creates a new NameFinder. Call close to get rid of any resources\n+   * created while using the <code>lookup</code> methods.\n+   */\n+  public NameFinder()\n+  {\n+    executable = getExecutable();\n+    Runtime runtime = Runtime.getRuntime();\n+    if (demangle)\n+    {\n+      try\n+\t{\n+\t  String[] exec = new String[] {\"c++filt\", \"-s\", \"java\"};\n+\t  cppfilt = runtime.exec(exec);\n+\t  cppfiltIn = new BufferedReader\n+\t\t\t(new InputStreamReader(cppfilt.getInputStream()));\n+\t  cppfiltOut = new BufferedWriter\n+\t\t\t(new OutputStreamWriter(cppfilt.getOutputStream()));\n+\t}\n+      catch (IOException ioe)\n+        {\n+\t  if (cppfilt != null)\n+\t    cppfilt.destroy();\n+\t  cppfilt = null;\n+\t}\n+    }\n+\n+    if (use_addr2line)\n+      {\n+\ttry\n+\t  {\n+\t    String[] exec = new String[] {\"addr2line\", \"-f\", \"-e\", executable};\n+\t    addr2line = runtime.exec(exec);\n+\t  }\n+\tcatch (IOException ioe)\n+\t  {\n+\t    try\n+\t      {\n+\t\tString[] exec = new String[] {\"addr2name.awk\", executable};\n+\t\taddr2line = runtime.exec(exec);\n+\t      }\n+\t    catch (IOException ioe2) { addr2line = null; }\n+\t  }\n+\n+\tif (addr2line != null)\n+\t  {\n+\t    try\n+\t      {\n+\t\taddr2lineIn = new BufferedReader\n+\t\t\t(new InputStreamReader(addr2line.getInputStream()));\n+\t\taddr2lineOut = new BufferedWriter\n+\t\t\t(new OutputStreamWriter(addr2line.getOutputStream()));\n+\t      }\n+\t    catch (IOException ioe)\n+\t      {  \n+\t\taddr2line.destroy();\n+\t\taddr2line = null;\n+\t      }\n+\t  }\n+      }\n+  }\n+\n+  /**\n+   * Returns the name of the currently running process.\n+   */\n+  native private static String getExecutable();\n+\n+  /**\n+   * Tries to use dladdr to create the nth StackTraceElement from the given\n+   * addresses. Returns null on failure.\n+   */\n+  native private StackTraceElement dladdrLookup(RawData addrs, int n);\n+\n+  /**\n+   * Returns the nth element from the stack as a hex encoded String.\n+   */\n+  native private String getAddrAsString(RawData addrs, int n);\n+\n+  /**\n+   * Creates the nth StackTraceElement from the given native stacktrace.\n+   */\n+  private StackTraceElement lookup(RawData addrs, int n)\n+  {\n+    StackTraceElement result;\n+\n+    result = dladdrLookup(addrs, n);\n+    if (result == null)\n+      {\n+\tString name = null;\n+\tString file = null;\n+\tString hex = getAddrAsString(addrs, n);\n+\t\n+\tif (addr2line != null)\n+\t  {\n+\t    try\n+\t      {\n+\t\taddr2lineOut.write(hex);\n+\t\taddr2lineOut.newLine();\n+\t\taddr2lineOut.flush();\n+\t\tname = addr2lineIn.readLine();\n+\t\tfile = addr2lineIn.readLine();\n+\t      }\n+\t    catch (IOException ioe) { addr2line = null; }\n+\t  }\n+\n+\tif (name == null || \"??\".equals(name))\n+\t  name = hex;\n+\n+\tresult = createStackTraceElement(name, file);\n+      }\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Given an Throwable and a native stacktrace returns an array of\n+   * StackTraceElement containing class, method, file and linenumbers.\n+   */\n+  public StackTraceElement[] lookup(Throwable t, RawData addrs, int length)\n+  {\n+    StackTraceElement[] elements = new StackTraceElement[length];\n+    for (int i=0; i < length; i++)\n+      elements[i] = lookup(addrs, i);\n+\n+    if (demangle && sanitize)\n+      return sanitizeStack(elements, t);\n+    else\n+      return elements;\n+  }\n+\n+  \n+  /**\n+   * Removes calls to initialize exceptions and the runtime system from\n+   * the stack trace including stack frames of which nothing usefull is known.\n+   * Throw away the top of the stack till we find the constructor(s)\n+   * of this Throwable or at least the contructors of java.lang.Throwable\n+   * or the actual fillInStackTrace call.\n+   * Also throw away from the top everything before and including a runtime\n+   * _Jv_Throw call.\n+   */\n+  private static StackTraceElement[] sanitizeStack(StackTraceElement[] elements,\n+\t\t\t\t\t\t   Throwable t)\n+  {\n+    StackTraceElement[] stack;\n+\n+    String className = t.getClass().getName();\n+    String consName;\n+    int lastDot = className.lastIndexOf('.');\n+    if (lastDot == -1)\n+      consName = className + '(';\n+    else\n+      consName = className.substring(lastDot + 1) + '(';\n+\n+    int unknown = 0;\n+    int last_throw = -1;\n+    int length = elements.length;\n+    int end = length-1;\n+    for (int i = 0; i < length; i++)\n+      {\n+\tString CName = elements[i].getClassName();\n+\tString MName = elements[i].getMethodName();\n+\tif ((CName == null && MName != null && MName.startsWith(\"_Jv_Throw\"))\n+\t  ||\n+\t   (CName != null\n+\t    && (CName.equals(className)\n+\t\t|| CName.equals(\"java.lang.Throwable\")\n+\t\t|| CName.equals(\"java.lang.VMThrowable\"))\n+\t    && MName != null\n+\t    && (MName.startsWith(consName)\n+\t\t|| MName.startsWith(\"Throwable(\")\n+\t\t|| MName.startsWith(\"fillInStackTrace(\"))))\n+\t  last_throw = i;\n+\telse if (remove_unknown && CName == null \n+\t\t && (MName == null || MName.startsWith(\"0x\")))\n+\t  unknown++;\n+\telse if (\"main(java.lang.String[])\".equals(MName))\n+\t  {\n+\t    end = i;\n+\t    break;\n+\t  }\n+      }\n+    int begin = last_throw+1;\n+\n+    // Now filter out everything at the start and the end that is not part\n+    // of the \"normal\" user program including any elements that have no\n+    // usefull information whatsoever unless that means we filter out all info.\n+    int nr_elements = end-begin-unknown+1;\n+    if ((begin > 0 || end < length-1 || unknown > 0) && nr_elements > 0)\n+      {\n+\tstack = new StackTraceElement[nr_elements];\n+\tint pos =0;\n+\tfor (int i=begin; i<=end; i++)\n+\t  {\n+\t    String MName;\n+\t    if (unknown == 0\n+\t\t|| !(elements[i].getClassName() == null\n+\t\t     && ((MName = elements[i].getMethodName()) == null\n+\t\t\t || MName.startsWith(\"0x\"))))\n+\t      {\n+\t\tstack[pos] = elements[i];\n+\t\tpos++;\n+\t      }\n+\t  }\n+      }\n+    else\n+      stack = elements;\n+\n+    return stack;\n+  }\n+\n+  /**\n+   * Creates a StackTraceElement given a string and a filename.\n+   * Splits the given string into the class and method part.\n+   * The string name will be a demangled to a fully qualified java method\n+   * string. The string file will be decomposed into a file name and possibly\n+   * a line number. The name should never be null, but the file may be if it\n+   * is unknown.\n+   */\n+  private StackTraceElement createStackTraceElement(String name, String file)\n+  {\n+    if (!demangle)\n+      return new StackTraceElement(file, -1, null, name, false);\n+\n+    String s = demangleName(name);\n+    String methodName = s;\n+    String className = null;\n+    int bracket = s.indexOf('(');\n+    if (bracket > 0)\n+      {\n+\tint dot = s.lastIndexOf('.', bracket);\n+\tif (dot > 0)\n+\t  {\n+\t    className = s.substring(0, dot);\n+\t    methodName = s.substring(dot+1, s.length());\n+\t  }\n+      }\n+\n+    String fileName = file;\n+    int line = -1;\n+    if (fileName != null)\n+      {\n+\tint colon = file.indexOf(':');\n+\tif (colon > 0)\n+\t  {\n+\t    fileName = file.substring(0, colon);\n+\t    try\n+\t      {\n+\t\tline = Integer.parseInt(file.substring(colon+1, file.length()));\n+\t      }\n+\t    catch (NumberFormatException nfe) { /* ignore */ }\n+\t  }\n+\n+\tif (line == 0)\n+\t  line =-1;\n+\n+\tif (\"\".equals(fileName) || \"??\".equals(fileName))\n+\t  fileName = null;\n+\telse if (fileName != null)\n+\t  {\n+\t    try\n+\t      {\n+\t\tfileName = new File(fileName).getCanonicalPath();\n+\t      }\n+\t    catch (IOException ioe) { /* ignore */ }\n+\t  }\n+      }\n+\n+    return new StackTraceElement(fileName, line, className, methodName, false);\n+  }\n+\n+  /**\n+   * Demangles the given String if possible. Returns the demangled String or\n+   * the original string if demangling is impossible.\n+   */\n+  private String demangleName(String s)\n+  {\n+    if (cppfilt != null)\n+    {\n+      try\n+\t{\n+\t  cppfiltOut.write(s);\n+\t  cppfiltOut.newLine();\n+\t  cppfiltOut.flush();\n+\t  return cppfiltIn.readLine();\n+\t}\n+      catch (IOException ioe) { cppfilt.destroy(); cppfilt = null; }\n+    }\n+\n+    return s;\n+  }\n+\n+  /**\n+   * Releases all resources used by this NameFinder.\n+   */\n+  public void close()\n+  {\n+    if (cppfilt != null)\n+      cppfilt.destroy();\n+\n+    if (addr2line != null)\n+      addr2line.destroy();\n+  }\n+\n+  /**\n+   * Calls close to get rid of all resources.\n+   */\n+  protected void finalize()\n+  {\n+    close();\n+  }\n+}"}, {"sha": "42cc164c3242c897ebaef6b58bc441c06e53b6ac", "filename": "libjava/gnu/gcj/runtime/natNameFinder.cc", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatNameFinder.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatNameFinder.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatNameFinder.cc?ref=6e0532cdf6f9fb4776bfa0f05a29c06a362d466b", "patch": "@@ -0,0 +1,84 @@\n+// natNameFinder.cc - native helper methods for NameFiner.java\n+\n+/* Copyright (C) 2002  Free Software Foundation, Inc\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+/**\n+ * @author Mark Wielaard (mark@klomp.org)\n+ * Based on the old name-finder.cc by Andrew Haley <aph@cygnus.com>.\n+ */\n+\n+#include <config.h>\n+\n+#include <gcj/cni.h>\n+#include <jvm.h>\n+#include <java/lang/String.h>\n+#include <java/lang/StackTraceElement.h>\n+\n+#include <gnu/gcj/runtime/NameFinder.h>\n+\n+#ifdef HAVE_DLFCN_H\n+#include <dlfcn.h>\n+#endif\n+\n+java::lang::String*\n+gnu::gcj::runtime::NameFinder::getExecutable (void)\n+{\n+    return JvNewStringLatin1 (_Jv_ThisExecutable ());\n+}\n+\n+java::lang::String*\n+gnu::gcj::runtime::NameFinder::getAddrAsString(RawData* addrs, jint n)\n+{\n+  void **p = (void **) addrs;\n+  typedef unsigned word_t __attribute ((mode (word)));\n+  word_t w = (word_t) p[n];\n+  int digits = sizeof (void *) * 2;\n+  char hex[digits+5];\n+\n+  strcpy (hex, \"0x\");\n+  for (int i = digits - 1; i >= 0; i--)\n+    {\n+      int digit = w % 16;\n+\n+      w /= 16;\n+      hex[i+2] = digit > 9 ? 'a' + digit - 10 : '0' + digit;\n+    }\n+  hex [digits+2] = 0;\n+\n+  return JvNewStringLatin1(hex);\n+}\n+\n+java::lang::StackTraceElement*\n+gnu::gcj::runtime::NameFinder::dladdrLookup(RawData* addrs, jint n)\n+{\n+#if defined (HAVE_DLFCN_H) && defined (HAVE_DLADDR)\n+  extern char **_Jv_argv;\n+  char name[1024];\n+  char file_name[1024];\n+  void **stack = (void **) addrs;\n+  void* p = stack[n];\n+  Dl_info dl_info;\n+   \n+  if (dladdr (p, &dl_info))\n+    {\n+      if (dl_info.dli_fname)\n+        strncpy (file_name, dl_info.dli_fname, sizeof file_name);\n+      if (dl_info.dli_sname)\n+        strncpy (name, dl_info.dli_sname, sizeof name);\n+     \n+     /* Don't trust dladdr() if the address is from the main program. */\n+     if (dl_info.dli_fname != NULL\n+         && dl_info.dli_sname != NULL\n+         && (_Jv_argv == NULL || strcmp (file_name, _Jv_argv[0]) != 0))\n+       return createStackTraceElement (JvNewStringLatin1 (name),\n+\t\t\t\t       JvNewStringLatin1 (file_name));\n+    }\n+#endif\n+  return NULL;\n+}"}, {"sha": "67ae0587fb017b0f48e422a7281a6d0fc0099347", "filename": "libjava/include/name-finder.h", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4906d5d83e08494b70297808d6818faffd89c2a0/libjava%2Finclude%2Fname-finder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4906d5d83e08494b70297808d6818faffd89c2a0/libjava%2Finclude%2Fname-finder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fname-finder.h?ref=4906d5d83e08494b70297808d6818faffd89c2a0", "patch": "@@ -1,103 +0,0 @@\n-// name-finder.h - Convert addresses to names\n-\n-/* Copyright (C) 2000, 2002  Free Software Foundation, Inc\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-/**\n- * @author Andrew Haley <aph@cygnus.com>\n- * @date Jan 6  2000\n- */\n-\n-#include <gcj/cni.h>\n-#include <jvm.h>\n-\n-#include <sys/types.h>\n-\n-#ifdef HAVE_SYS_WAIT_H\n-#include <sys/wait.h>\n-#endif\n-\n-#include <string.h>\n-#include <stdio.h>\n-\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#endif\n-\n-#include <java/lang/StackTraceElement.h>\n-\n-/* _Jv_name_finder is a class wrapper around a mechanism that can\n-   convert addresses of methods to their names and the names of files\n-   in which they appear. */\n-\n-class _Jv_name_finder\n-{\n-public:  \n-  _Jv_name_finder (char *executable);\n-  ~_Jv_name_finder ()\n-    {\n-#if defined (HAVE_PIPE) && defined (HAVE_FORK)\n-      myclose (f_pipe[0]);\n-      myclose (f_pipe[1]);\n-      myclose (b_pipe[0]);\n-      myclose (b_pipe[1]);\n-      if (b_pipe_fd != NULL)\n-\tfclose (b_pipe_fd);\n-\n-      myclose (f2_pipe[0]);\n-      myclose (f2_pipe[1]);\n-      myclose (b2_pipe[0]);\n-      myclose (b2_pipe[1]);\n-      if (b2_pipe_fd != NULL)\n-\tfclose (b2_pipe_fd);\n-\n-      if (pid >= 0)\n-\t{\n-\t  int wstat;\n-\t  // We don't care about errors here.\n-\t  waitpid (pid, &wstat, 0);\n-\t}\n-\n-      if (pid2 >= 0)\n-\t{\n-\t  int wstat;\n-\t  // We don't care about errors here.\n-\t  waitpid (pid2, &wstat, 0);\n-\t}\n-#endif\n-    }\n-\n-/* Given a pointer to a function or method, try to convert it into a\n-   name and the appropriate line and source file.  The caller passes\n-   the code pointer in p.\n-\n-   Returns NULL if the lookup fails.  Even if this happens, the field\n-   hex will have been correctly filled in with the pointer. */\n-\n-  java::lang::StackTraceElement* lookup (void *p);\n-\n-  char hex[sizeof (void *) * 2 + 5];\n-\n-private:\n-  void toHex (void *p);\n-  java::lang::StackTraceElement* createStackTraceElement(char *s, char *f);\n-#if defined (HAVE_PIPE) && defined (HAVE_FORK)\n-  pid_t pid, pid2;\n-  int f_pipe[2], b_pipe[2], f2_pipe[2], b2_pipe[2];\n-  FILE *b_pipe_fd, *b2_pipe_fd;\n-  int demangling_error, lookup_error;\n-\n-  // Close a descriptor only if it has not been closed.\n-  void myclose (int fd)\n-  {\n-    if (fd != -1)\n-      close (fd);\n-  }\n-\n-#endif\n-};"}, {"sha": "613f43ffe9b32c71d9dfaa5f1b11850e2e9da580", "filename": "libjava/java/lang/Throwable.java", "status": "modified", "additions": 97, "deletions": 63, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b/libjava%2Fjava%2Flang%2FThrowable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b/libjava%2Fjava%2Flang%2FThrowable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThrowable.java?ref=6e0532cdf6f9fb4776bfa0f05a29c06a362d466b", "patch": "@@ -46,11 +46,6 @@\n import java.io.IOException;\n import java.io.OutputStream;\n \n-/**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date October 30, 1998 \n- */\n-\n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n  * Status: Sufficient for compiled code, but methods applicable to\n@@ -116,7 +111,7 @@\n  * @author Tom Tromey\n  * @author Eric Blake <ebb9@email.byu.edu>\n  * @since 1.0\n- * @status still missing 1.4 functionality\n+ * @status updated to 1.4\n  */\n public class Throwable implements Serializable\n {\n@@ -130,7 +125,7 @@ public class Throwable implements Serializable\n    *\n    * @serial specific details about the exception, may be null\n    */\n-  private String detailMessage;\n+  private final String detailMessage;\n \n   /**\n    * The cause of the throwable, including null for an unknown or non-chained\n@@ -374,7 +369,7 @@ public void printStackTrace()\n    */\n   public void printStackTrace(PrintStream s)\n   {\n-    printStackTrace(new PrintWriter(s));\n+    s.print(stackTraceString());\n   }\n \n   /**\n@@ -409,72 +404,88 @@ public void printStackTrace(PrintStream s)\n    */\n   public void printStackTrace (PrintWriter pw)\n   {\n-    // First line\n-    pw.println(toString());\n+    pw.print(stackTraceString());\n+  }\n \n-    // The stacktrace\n+  private static final String nl = System.getProperty(\"line.separator\");\n+  // Create whole stack trace in a stringbuffer so we don't have to print\n+  // it line by line. This prevents printing multiple stack traces from\n+  // different threads to get mixed up when written to the same PrintWriter.\n+  private String stackTraceString()\n+  {\n+    StringBuffer sb = new StringBuffer();\n+\n+    // Main stacktrace\n     StackTraceElement[] stack = getStackTrace();\n-    if (stack == null || stack.length == 0)\n-      {\n-\tpw.println(\"   <<No stacktrace available>>\");\n-\treturn;\n-      }\n-    else\n-      {\n-\tfor (int i = 0; i < stack.length; i++)\n-\t  pw.println(\"   at \" + stack[i]);\n-      }\n+    stackTraceStringBuffer(sb, this.toString(), stack, 0);\n \n     // The cause(s)\n     Throwable cause = getCause();\n     while (cause != null)\n       {\n-        // Cause first line\n-        pw.println(\"Caused by: \" + cause);\n+\t// Cause start first line\n+        sb.append(\"Caused by: \");\n \n         // Cause stacktrace\n         StackTraceElement[] parentStack = stack;\n         stack = cause.getStackTrace();\n-\tif (stack == null || stack.length == 0)\n-\t  {\n-\t    pw.println(\"   <<No stacktrace available>>\");\n-\t  }\n-\telse if (parentStack == null || parentStack.length == 0)\n-\t  {\n-\t    for (int i = 0; i < stack.length; i++)\n-\t      pw.println(\"   at \" + stack[i]);\n-\t  }\n+\tif (parentStack == null || parentStack.length == 0)\n+\t  stackTraceStringBuffer(sb, cause.toString(), stack, 0);\n \telse\n \t  {\n-\t    boolean equal = false; // Is rest of stack equal to parent frame?\n-\t    for (int i = 0; i < stack.length && ! equal; i++)\n+\t    int equal = 0; // Count how many of the last stack frames are equal\n+\t    int frame = stack.length-1;\n+\t    int parentFrame = parentStack.length-1;\n+\t    while (frame > 0 && parentFrame > 0)\n \t      {\n-\t\t// Check if we already printed the rest of the stack\n-\t\t// since it was the tail of the parent stack\n-\t\tint remaining = stack.length - i;\n-\t\tint element = i;\n-\t\tint parentElement = parentStack.length - remaining;\n-\t\tequal = parentElement >= 0\n-\t\t      && parentElement < parentStack.length; // be optimistic\n-\t\twhile (equal && element < stack.length)\n+\t\tif (stack[frame].equals(parentStack[parentFrame]))\n \t\t  {\n-\t\t    if (stack[element].equals(parentStack[parentElement]))\n-\t\t      {\n-\t\t\telement++;\n-\t\t\tparentElement++;\n-\t\t      }\n-\t\t    else\n-\t\t      equal = false;\n+\t\t    equal++;\n+\t\t    frame--;\n+\t\t    parentFrame--;\n \t\t  }\n-\t\t// Print stacktrace element or indicate the rest is equal \n-\t\tif (! equal)\n-\t\t  pw.println(\"   at \" + stack[i]);\n \t\telse\n-\t\t  pw.println(\"   ...\" + remaining + \" more\");\n+\t\t  break;\n \t      }\n+\t    stackTraceStringBuffer(sb, cause.toString(), stack, equal);\n \t  }\n         cause = cause.getCause();\n       }\n+\n+    return sb.toString();\n+  }\n+\n+  // Adds to the given StringBuffer a line containing the name and\n+  // all stacktrace elements minus the last equal ones.\n+  private static void stackTraceStringBuffer(StringBuffer sb, String name,\n+\t\t\t\t\tStackTraceElement[] stack, int equal)\n+  {\n+    // (finish) first line\n+    sb.append(name);\n+    sb.append(nl);\n+\n+    // The stacktrace\n+    if (stack == null || stack.length == 0)\n+      {\n+\tsb.append(\"   <<No stacktrace available>>\");\n+\tsb.append(nl);\n+      }\n+    else\n+      {\n+\tfor (int i = 0; i < stack.length-equal; i++)\n+\t  {\n+\t    sb.append(\"   at \");\n+\t    sb.append(stack[i] == null ? \"<<Unknown>>\" : stack[i].toString());\n+\t    sb.append(nl);\n+\t  }\n+\tif (equal > 0)\n+\t  {\n+\t    sb.append(\"   ...\");\n+\t    sb.append(equal);\n+\t    sb.append(\" more\");\n+\t    sb.append(nl);\n+\t  }\n+      }\n   }\n \n   /**\n@@ -483,7 +494,13 @@ else if (parentStack == null || parentStack.length == 0)\n    * @return this same throwable\n    * @see #printStackTrace()\n    */\n-  public native Throwable fillInStackTrace();\n+  public Throwable fillInStackTrace()\n+  {\n+    vmState = VMThrowable.fillInStackTrace(this);\n+    stackTrace = null; // Should be regenerated when used.\n+\n+    return this;\n+  }\n \n   /**\n    * Provides access to the information printed in {@link #printStackTrace()}.\n@@ -499,7 +516,13 @@ else if (parentStack == null || parentStack.length == 0)\n   public StackTraceElement[] getStackTrace()\n   {\n     if (stackTrace == null)\n-      stackTrace = getStackTrace0();\n+      if (vmState == null)\n+\tstackTrace = new StackTraceElement[0];\n+      else \n+\t{\n+\t  stackTrace = vmState.getStackTrace(this);\n+\t  vmState = null; // No longer needed\n+\t}\n \n     return stackTrace;\n   }\n@@ -508,22 +531,33 @@ public StackTraceElement[] getStackTrace()\n    * Change the stack trace manually. This method is designed for remote\n    * procedure calls, which intend to alter the stack trace before or after\n    * serialization according to the context of the remote call.\n+   * <p>\n+   * The contents of the given stacktrace is copied so changes to the\n+   * original * array do not change the stack trace elements of this\n+   * throwable.\n    *\n    * @param stackTrace the new trace to use\n    * @throws NullPointerException if stackTrace is null or has null elements\n    * @since 1.4\n    */\n   public void setStackTrace(StackTraceElement[] stackTrace)\n   {\n-    for (int i = stackTrace.length; --i >= 0; )\n+    int i = stackTrace.length;\n+    StackTraceElement[] st = new StackTraceElement[i];\n+\n+    while (--i >= 0)\n       if (stackTrace[i] == null)\n-        throw new NullPointerException();\n-    this.stackTrace = stackTrace;\n-  }\n+\tthrow new NullPointerException();\n+      else\n+\tst[i] = stackTrace[i];\n \n-  private native final StackTraceElement[] getStackTrace0 ();\n+    this.stackTrace = st;\n+  }\n \n-  // Setting this flag to false prevents fillInStackTrace() from running.\n-  static boolean trace_enabled = true;\n-  private transient byte stackTraceBytes[];\n+  /**\n+   * VM state when fillInStackTrace was called.\n+   * Used by getStackTrace() to get an array of StackTraceElements.\n+   * Cleared when no longer needed.\n+   */\n+  private transient VMThrowable vmState;\n }"}, {"sha": "0a2c9229649b9985e45a08aafcd6452761a474fc", "filename": "libjava/java/lang/VMThrowable.java", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b/libjava%2Fjava%2Flang%2FVMThrowable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b/libjava%2Fjava%2Flang%2FVMThrowable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FVMThrowable.java?ref=6e0532cdf6f9fb4776bfa0f05a29c06a362d466b", "patch": "@@ -0,0 +1,97 @@\n+/* java.lang.VMThrowable -- VM support methods for Throwable.\n+   Copyright (C) 1998, 1999, 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.lang;\n+\n+import gnu.gcj.runtime.NameFinder;\n+\n+/**\n+ * VM dependant state and support methods Throwabele.\n+ * It is deliberately package local and final and should only be accessed\n+ * by the Throwable class.\n+ * <p>\n+ * This is the version used by libgcj (http://gcc.gnu.org/java/).\n+ *\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+final class VMThrowable\n+{\n+  private gnu.gcj.RawData stackTraceAddrs;\n+  private int length;\n+\n+  /**\n+   * Private contructor, create VMThrowables with fillInStackTrace();\n+   */\n+  private VMThrowable() { }\n+\n+  /**\n+   * Fill in the stack trace with the current execution stack.\n+   * Called by <code>Throwable.fillInStackTrace()</code> to get the state of\n+   * the VM. Can return null when the VM does not support caputing the VM\n+   * execution state.\n+   *\n+   * @return a new VMThrowable containing the current execution stack trace.\n+   * @see Throwable#fillInStackTrace()\n+   */\n+  static native VMThrowable fillInStackTrace(Throwable t);\n+\n+  /**\n+   * Returns an <code>StackTraceElement</code> array based on the execution\n+   * state of the VM as captured by <code>fillInStackTrace</code>.\n+   * Called by <code>Throwable.getStackTrace()</code>.\n+   *\n+   * @return a non-null but possible zero length array of StackTraceElement.\n+   * @see Throwable#getStackTrace()\n+   */\n+  StackTraceElement[] getStackTrace(Throwable t)\n+  {\n+    StackTraceElement[] result;\n+    if (stackTraceAddrs != null)\n+      {\n+\tNameFinder nameFinder = new NameFinder();\n+\tresult = nameFinder.lookup(t, stackTraceAddrs, length);\n+\tnameFinder.close();\n+      }\n+    else\n+      result = new StackTraceElement[0];\n+\n+    return result;\n+  }\n+\n+  // Setting this flag to false prevents fillInStackTrace() from running.\n+  static boolean trace_enabled = true;\n+}"}, {"sha": "c2f7d1b8d8dc3d02371415270b3edbe72cf3d61e", "filename": "libjava/java/lang/natThrowable.cc", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4906d5d83e08494b70297808d6818faffd89c2a0/libjava%2Fjava%2Flang%2FnatThrowable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4906d5d83e08494b70297808d6818faffd89c2a0/libjava%2Fjava%2Flang%2FnatThrowable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatThrowable.cc?ref=4906d5d83e08494b70297808d6818faffd89c2a0", "patch": "@@ -1,99 +0,0 @@\n-// natThrowable.cc - Superclass for all exceptions.\n-\n-/* Copyright (C) 2000  Free Software Foundation, Inc\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-/**\n- * @author Andrew Haley <aph@cygnus.com>\n- * @date Jan 6  2000\n- */\n-\n-#include <config.h>\n-\n-#include <string.h>\n-\n-#include <gcj/cni.h>\n-#include <jvm.h>\n-#include <java/lang/Object.h>\n-#include <java-threads.h>\n-#include <java/lang/Throwable.h>\n-#include <java/lang/StackTraceElement.h>\n-#include <java/io/PrintStream.h>\n-#include <java/io/PrintWriter.h>\n-#include <java/io/IOException.h>\n-\n-#include <sys/types.h>\n-\n-#include <stdlib.h>\n-#include <stdio.h>\n-\n-#include <unistd.h>\n-\n-#ifdef HAVE_EXECINFO_H\n-#include <execinfo.h>\n-#endif\n-\n-#include <name-finder.h>\n-\n-/* FIXME: size of the stack trace is limited to 128 elements.  It's\n-   undoubtedly sensible to limit the stack trace, but 128 is rather\n-   arbitrary.  It may be better to configure this.  */\n-\n-java::lang::Throwable *\n-java::lang::Throwable::fillInStackTrace (void)\n-{\n-  if (! trace_enabled)\n-    return this;\n-#if defined (HAVE_BACKTRACE)\n-  void *p[128];\n-  \n-  // We subtract 1 from the number of elements because we don't want\n-  // to include the call to fillInStackTrace in the trace.\n-  int n = backtrace (p, 128) - 1;  \n-\n-  if (n > 0)\n-    {\n-      // We copy the array below to deal with alignment issues.\n-      stackTraceBytes = JvNewByteArray (n * sizeof p[0]);\n-      memcpy (elements (stackTraceBytes), p+1, (n * sizeof p[0]));\n-    }\n-\n-#endif\n-\n-  return this;\n-}\n-\n-JArray<java::lang::StackTraceElement*> *\n-java::lang::Throwable::getStackTrace0 ()\n-{\n-#ifdef HAVE_BACKTRACE\n-  if (!stackTraceBytes)\n-    return NULL;\n-\n-  int depth = stackTraceBytes->length / sizeof (void *);\n-  void *p[depth];\n-  // This memcpy is esential; it ensures that the array of void* is\n-  // correctly aligned.\n-  memcpy (p, elements (stackTraceBytes), sizeof p);\n-\n-  JArray<java::lang::StackTraceElement*> *result;\n-  java::lang::StackTraceElement** el;\n-  result = reinterpret_cast <JArray<java::lang::StackTraceElement *>*>\n-    (JvNewObjectArray (depth, &java::lang::StackTraceElement::class$, NULL));\n-  el = elements (result);\n-\n-  _Jv_name_finder finder (_Jv_ThisExecutable ());\n-\n-  for (int i = 0; i < depth; i++)\n-    el[i] = finder.lookup (p[i]);\n-\n-  return result;\n-#else\n-  return NULL;\n-#endif /* HAVE_BACKTRACE */\n-}"}, {"sha": "358bab7f13b39149565ba988dc96d696d50ab4ef", "filename": "libjava/java/lang/natVMThrowable.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b/libjava%2Fjava%2Flang%2FnatVMThrowable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b/libjava%2Fjava%2Flang%2FnatVMThrowable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatVMThrowable.cc?ref=6e0532cdf6f9fb4776bfa0f05a29c06a362d466b", "patch": "@@ -0,0 +1,73 @@\n+// natVMThrowable.cc - native helper methods for Throwable\n+\n+/* Copyright (C) 2000, 2002  Free Software Foundation, Inc\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+/**\n+ * @author Andrew Haley <aph@cygnus.com>\n+ * @author Mark Wielaard <mark@klomp.org>\n+ *\n+ * Native helper methods for VM specific Throwable support.\n+ */\n+\n+#include <config.h>\n+\n+#include <string.h>\n+\n+#include <jvm.h>\n+#include <gcj/cni.h>\n+#include <gnu/gcj/RawData.h>\n+#include <java/lang/Object.h>\n+#include <java-threads.h>\n+#include <java/lang/Throwable.h>\n+#include <java/lang/VMThrowable.h>\n+\n+#include <sys/types.h>\n+\n+#include <stdlib.h>\n+\n+#include <unistd.h>\n+\n+#ifdef HAVE_EXECINFO_H\n+#include <execinfo.h>\n+#endif\n+\n+/* FIXME: size of the stack trace is limited to 128 elements.  It's\n+   undoubtedly sensible to limit the stack trace, but 128 is rather\n+   arbitrary.  It may be better to configure this.  */\n+\n+java::lang::VMThrowable *\n+java::lang::VMThrowable::fillInStackTrace (java::lang::Throwable* t)\n+{\n+  if (! trace_enabled)\n+    return NULL;\n+#if defined (HAVE_BACKTRACE)\n+  VMThrowable* state = new VMThrowable;\n+  void *p[128];\n+  \n+  // We subtract 1 from the number of elements because we don't want\n+  // to include the calls to fillInStackTrace in the trace.\n+  int n = backtrace (p, 128) - 1;  \n+\n+  void **addrs;\n+  if (n > 0)\n+    {\n+      state->length = n;\n+      addrs = (void **) _Jv_Malloc (n * sizeof p[0]);\n+      while (n--)\n+\taddrs[n] = p[n];\n+    }\n+  else\n+    addrs = NULL;\n+\n+  state->stackTraceAddrs = reinterpret_cast<gnu::gcj::RawData *> (addrs);\n+\n+  return state;\n+#endif\n+  return NULL;\n+}"}, {"sha": "2d383aaa2508f5c1e5c928910e21fedd0ad5c290", "filename": "libjava/name-finder.cc", "status": "removed", "additions": 0, "deletions": 356, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4906d5d83e08494b70297808d6818faffd89c2a0/libjava%2Fname-finder.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4906d5d83e08494b70297808d6818faffd89c2a0/libjava%2Fname-finder.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fname-finder.cc?ref=4906d5d83e08494b70297808d6818faffd89c2a0", "patch": "@@ -1,356 +0,0 @@\n-// name-finder.cc - Convert addresses to names\n-\n-/* Copyright (C) 2000, 2002  Free Software Foundation, Inc\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-/**\n- * @author Andrew Haley <aph@cygnus.com>\n- * @date Jan 6  2000\n- */\n-\n-/* _Jv_name_finder is a class wrapper around a mechanism that can\n-   convert address of methods to their names and the names of files in\n-   which they appear.\n-\n-   Right now, the only implementation of this involves running a copy\n-   of addr2line, but at some point it is worth building this\n-   functionality into libgcj, if only for embedded systems.  */\n-\n-\n-#ifndef _GNU_SOURCE\n-#define _GNU_SOURCE 1\n-#endif\n-\n-#include <config.h>\n-\n-#include <string.h>\n-\n-#include <gcj/cni.h>\n-#include <jvm.h>\n-#include <java/lang/Object.h>\n-#include <java-threads.h>\n-#include <java/lang/Throwable.h>\n-#include <java/io/PrintStream.h>\n-#include <java/io/PrintWriter.h>\n-\n-#include <sys/types.h>\n-\n-#include <stdlib.h>\n-#include <stdio.h>\n-\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#endif\n-\n-#ifdef HAVE_DLFCN_H\n-#include <dlfcn.h>\n-#endif\n-\n-#include <name-finder.h>\n-\n-/* Create a new name finder which will perform address lookups on an\n-   executable. */\n-\n-_Jv_name_finder::_Jv_name_finder (char *executable)\n-{\n-#if defined (HAVE_PIPE) && defined (HAVE_FORK) && defined (HAVE_EXECVP)\n-  demangling_error = lookup_error = 0;\n-\n-  // Initialize file descriptors so that shutdown works properly.\n-  f_pipe[0] = -1;\n-  f_pipe[1] = -1;\n-  b_pipe[0] = -1;\n-  b_pipe[1] = -1;\n-  b_pipe_fd = NULL;\n-\n-  f2_pipe[0] = -1;\n-  f2_pipe[1] = -1;\n-  b2_pipe[0] = -1;\n-  b2_pipe[1] = -1;\n-  b2_pipe_fd = NULL;\n-\n-  // addr2line helper process.\n-\n-  char *argv[5];\n-  {\n-    int arg = 0;\n-#ifdef __ia64__\n-    argv[arg++] = \"addr2name.awk\";\n-#else\n-    argv[arg++] = \"addr2line\";\n-    argv[arg++] = \"-f\";\n-    argv[arg++] = \"-e\";\n-#endif\n-    argv[arg++] = executable;\n-    argv[arg] = NULL;\n-  }\n-\n-  lookup_error |= pipe (f_pipe) < 0;\n-  lookup_error |= pipe (b_pipe) < 0;\n-\n-  if (lookup_error)\n-    return;\n-\n-  pid = fork ();\n-  if (pid == 0)\n-    {\n-      close (f_pipe[1]);\n-      close (b_pipe[0]);\n-      dup2 (f_pipe[0], fileno (stdin));\n-      dup2 (b_pipe[1], fileno (stdout));\n-      execvp (argv[0], argv);\n-      _exit (127);\n-    }\n-\n-  // Close child end of pipes.  Set local descriptors to -1 so we\n-  // don't try to close the fd again.\n-  close (f_pipe [0]);\n-  f_pipe[0] = -1;\n-  close (b_pipe [1]);\n-  b_pipe[1] = -1;\n-\n-  if (pid < 0)\n-    {\n-      lookup_error |= 1; \n-      return;\n-    }\n-\n-  b_pipe_fd = fdopen (b_pipe[0], \"r\");\n-  lookup_error |= !b_pipe_fd;\n-\n-  if (! lookup_error)\n-    {\n-      // Don't try to close the fd twice.\n-      b_pipe[0] = -1;\n-    }\n-\n-  // c++filt helper process.\n-  \n-  char *argv2[4];\n-  argv2[0] = \"c++filt\";\n-  argv2[1] = \"-s\";\n-  argv2[2] = \"java\";\n-  argv2[3] = NULL;\n-\n-  demangling_error |= pipe (f2_pipe) < 0;\n-  demangling_error |= pipe (b2_pipe) < 0;\n-\n-  if (demangling_error)\n-    return;\n-\n-  pid2 = fork ();\n-  if (pid2 == 0)\n-    {\n-      close (f2_pipe[1]);\n-      close (b2_pipe[0]);\n-      dup2 (f2_pipe[0], fileno (stdin));\n-      dup2 (b2_pipe[1], fileno (stdout));\n-      execvp (argv2[0], argv2);\n-      _exit (127);\n-    }\n-\n-  // Close child end of pipes.  Set local descriptors to -1 so we\n-  // don't try to close the fd again.\n-  close (f2_pipe [0]);\n-  f2_pipe[0] = -1;\n-  close (b2_pipe [1]);\n-  b2_pipe[1] = -1;\n-\n-  if (pid2 < 0)\n-    {\n-      demangling_error |= 1; \n-      return;\n-    }\n-\n-  b2_pipe_fd = fdopen (b2_pipe[0], \"r\");\n-  demangling_error |= !b2_pipe_fd;\n-\n-  if (! demangling_error)\n-    {\n-      // Don't try to close the fd twice.\n-      b2_pipe[0] = -1;\n-    }\n-#endif\n-}\n-\n-/* Convert a pointer to hex. */\n-\n-void\n-_Jv_name_finder::toHex (void *p)\n-{\n-  typedef unsigned word_t __attribute ((mode (word)));\n-  word_t n = (word_t) p;\n-  int digits = sizeof (void *) * 2;\n-\n-  strcpy (hex, \"0x\");\n-  for (int i = digits - 1; i >= 0; i--)\n-    {\n-      int digit = n % 16;\n-      \n-      n /= 16;\n-      hex[i+2] = digit > 9 ? 'a' + digit - 10 : '0' + digit; \n-    }\n-  hex [digits+2] = 0;\n-}   \n-\n-/* Creates a StackTraceElement given a string and a filename.\n-   Splits the given string into the class and method part.\n-   The string s will be a demangled to a fully qualified java method string.\n-   The string f will be decomposed into a file name and a possible line number.\n-   The given strings will be altered.  */\n-\n-java::lang::StackTraceElement*\n-_Jv_name_finder::createStackTraceElement(char *s, char *f)\n-{\n-  char *c;\n-  char *class_name = NULL;\n-  char *method_name = NULL;\n-\n-#if defined (HAVE_PIPE) && defined (HAVE_FORK) && defined (HAVE_EXECVP)\n-  if (demangling_error)\n-    goto fail;\n-\n-  demangling_error |= write (f2_pipe[1], s, strlen (s)) < 0;\n-  if (demangling_error)\n-    goto fail;\n-  demangling_error |= write (f2_pipe[1], \"\\n\", 1) < 0;\n-  if (demangling_error)\n-    goto fail;\n-\n-  char name[1024];\n-  demangling_error |= (fgets (name, sizeof name, b2_pipe_fd) == NULL);\n-  if (demangling_error)\n-    goto fail;\n-\n-  c = strchr (name, '\\n');\n-  if (c)\n-    *c = 0;\n-  s = name;\n-#endif\n-\n-  c = strchr (s, '(');\n-  if (c)\n-    {\n-      while(c-->s)\n-\tif (*c == '.')\n-\t  break;\n-\n-      if (*c == '.')\n-\t{\n-\t  *c = 0;\n-\t  class_name = s;\n-\t  method_name = c+1;\n-\t}\n-      else\n-\t{\n-\t  class_name = NULL;\n-\t  method_name = s;\n-\t}\n-    }\n-  else\n-    {\n-      class_name = NULL;\n-      method_name = s;\n-    }\n-\n-  // Get line number\n-  int line_number;\n-  c = strrchr (f, ':');\n-  if (c)\n-    {\n-      if (c[1] != 0)\n-\tline_number = atoi(c+1);\n-      else\n-\tline_number = -1;\n-      *c = 0;\n-    }\n-  else\n-    {\n-      line_number = -1;\n-      c = strchr (f, '\\n');\n-      if (c)\n-\t*c = 0;\n-    }\n-\n- fail:\n-  return new java::lang::StackTraceElement(\n-\t\t  f ? JvNewStringLatin1 (f) : NULL,\n-\t\t  line_number,\n-\t\t  class_name ? JvNewStringLatin1 (class_name) : NULL,\n-\t\t  JvNewStringLatin1 (method_name ? method_name : s),\n-\t\t  false);\n-}\n-\n-/* Given a pointer to a function or method, try to convert it into a\n-   name and the appropriate line and source file.  The caller passes\n-   the code pointer in p.\n-\n-   Returns false if the lookup fails.  Even if this happens, the field\n-   he will have been correctly filled in with the pointer.  */\n-\n-java::lang::StackTraceElement*\n-_Jv_name_finder::lookup (void *p)\n-{\n-  extern char **_Jv_argv;\n-  toHex (p);\n-      \n-  char name[1024];\n-  char file_name[1024];\n-\n-  file_name[0] = 0;\n-\n-#if defined (HAVE_DLFCN_H) && defined (HAVE_DLADDR)\n-  {\n-    Dl_info dl_info;\n-    \n-    if (dladdr (p, &dl_info))\n-      {\n-        if (dl_info.dli_fname)\n-\t  strncpy (file_name, dl_info.dli_fname, sizeof file_name);\n-\tif (dl_info.dli_sname)\n-\t  strncpy (name, dl_info.dli_sname, sizeof name);\n-       \n-       /* Don't trust dladdr() if the address is from the main program. */\n-       if (dl_info.dli_fname != NULL\n-           && dl_info.dli_sname != NULL\n-\t   && (_Jv_argv == NULL || strcmp (file_name, _Jv_argv[0]) != 0))\n-         return createStackTraceElement (name, file_name);\n-      }\n-  }\n-#endif\n-\n-  memcpy (name, hex, strlen (hex) + 1);\n-\n-#if defined (HAVE_PIPE) && defined (HAVE_FORK) && defined (HAVE_EXECVP)\n-  if (lookup_error)\n-    goto fail;\n-\n-  lookup_error |= write (f_pipe[1], hex, strlen (hex)) < 0;\n-  if (lookup_error)\n-    goto fail;\n-  lookup_error |= write (f_pipe[1], \"\\n\", 1) < 0;\n-  if (lookup_error)\n-    goto fail;\n-\n-  lookup_error |= (fgets (name, sizeof name, b_pipe_fd) == NULL);\n-  if (lookup_error)\n-    goto fail;\n-  lookup_error |= (fgets (file_name, sizeof file_name, b_pipe_fd) == NULL);\n-  if (lookup_error)\n-    goto fail;\n-\n-  {\n-    char *newline = strchr (name, '\\n');\n-    if (newline)\n-      *newline = 0;\n-  }\n-#endif /* defined (HAVE_PIPE) && defined (HAVE_FORK) && defined (HAVE_EXECVP) */\n-\n- fail:\n-  return (createStackTraceElement (name, file_name));\n-}"}, {"sha": "710139bab067f0f6da39495ab6c729e5057346a6", "filename": "libjava/prims.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b/libjava%2Fprims.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0532cdf6f9fb4776bfa0f05a29c06a362d466b/libjava%2Fprims.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fprims.cc?ref=6e0532cdf6f9fb4776bfa0f05a29c06a362d466b", "patch": "@@ -53,6 +53,7 @@ details.  */\n #include <java/lang/NullPointerException.h>\n #include <java/lang/OutOfMemoryError.h>\n #include <java/lang/System.h>\n+#include <java/lang/VMThrowable.h>\n #include <java/lang/reflect/Modifier.h>\n #include <java/io/PrintStream.h>\n #include <java/lang/UnsatisfiedLinkError.h>\n@@ -910,8 +911,8 @@ _Jv_CreateJavaVM (void* /*vm_args*/)\n   _Jv_InitPrimClass (&_Jv_voidClass,    \"void\",    'V', 0, &_Jv_voidVTable);\n \n   // Turn stack trace generation off while creating exception objects.\n-  _Jv_InitClass (&java::lang::Throwable::class$);\n-  java::lang::Throwable::trace_enabled = 0;\n+  _Jv_InitClass (&java::lang::VMThrowable::class$);\n+  java::lang::VMThrowable::trace_enabled = 0;\n   \n   INIT_SEGV;\n #ifdef HANDLE_FPE\n@@ -923,7 +924,7 @@ _Jv_CreateJavaVM (void* /*vm_args*/)\n \n   no_memory = new java::lang::OutOfMemoryError;\n \n-  java::lang::Throwable::trace_enabled = 1;\n+  java::lang::VMThrowable::trace_enabled = 1;\n \n #ifdef USE_LTDL\n   LTDL_SET_PRELOADED_SYMBOLS ();"}]}