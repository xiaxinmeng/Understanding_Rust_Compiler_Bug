{"sha": "4ef1e524fd87a679f5da06116029c66a84daac80", "node_id": "C_kwDOANBUbNoAKDRlZjFlNTI0ZmQ4N2E2NzlmNWRhMDYxMTYwMjljNjZhODRkYWFjODA", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-24T16:39:47Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-27T15:39:51Z"}, "message": "Remove old VRP jump threader code.\n\nThere's a lot of code that melts away without the ASSERT_EXPR based jump\nthreader.  Also, I cleaned up the include files as part of the process.\n\ngcc/ChangeLog:\n\n\t* tree-vrp.c (lhs_of_dominating_assert): Remove.\n\t(class vrp_jt_state): Remove.\n\t(class vrp_jt_simplifier): Remove.\n\t(vrp_jt_simplifier::simplify): Remove.\n\t(class vrp_jump_threader): Remove.\n\t(vrp_jump_threader::vrp_jump_threader): Remove.\n\t(vrp_jump_threader::~vrp_jump_threader): Remove.\n\t(vrp_jump_threader::before_dom_children): Remove.\n\t(vrp_jump_threader::after_dom_children): Remove.", "tree": {"sha": "ada15418e18e47a6d9c653ea5bd0839e68c27a9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ada15418e18e47a6d9c653ea5bd0839e68c27a9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ef1e524fd87a679f5da06116029c66a84daac80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ef1e524fd87a679f5da06116029c66a84daac80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ef1e524fd87a679f5da06116029c66a84daac80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ef1e524fd87a679f5da06116029c66a84daac80/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0288527f47cec6698b31ccb3210816415506009e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0288527f47cec6698b31ccb3210816415506009e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0288527f47cec6698b31ccb3210816415506009e"}], "stats": {"total": 308, "additions": 7, "deletions": 301}, "files": [{"sha": "5aded5edb119bf0874e802bdccbe669e03edfebb", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 7, "deletions": 301, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ef1e524fd87a679f5da06116029c66a84daac80/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ef1e524fd87a679f5da06116029c66a84daac80/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=4ef1e524fd87a679f5da06116029c66a84daac80", "patch": "@@ -21,54 +21,34 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n-#include \"backend.h\"\n-#include \"insn-codes.h\"\n-#include \"rtl.h\"\n+#include \"basic-block.h\"\n+#include \"bitmap.h\"\n+#include \"sbitmap.h\"\n+#include \"options.h\"\n+#include \"dominance.h\"\n+#include \"function.h\"\n+#include \"cfg.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n-#include \"cfghooks.h\"\n #include \"tree-pass.h\"\n #include \"ssa.h\"\n-#include \"optabs-tree.h\"\n #include \"gimple-pretty-print.h\"\n-#include \"flags.h\"\n #include \"fold-const.h\"\n-#include \"stor-layout.h\"\n-#include \"calls.h\"\n #include \"cfganal.h\"\n-#include \"gimple-fold.h\"\n-#include \"tree-eh.h\"\n #include \"gimple-iterator.h\"\n-#include \"gimple-walk.h\"\n #include \"tree-cfg.h\"\n #include \"tree-ssa-loop-manip.h\"\n #include \"tree-ssa-loop-niter.h\"\n-#include \"tree-ssa-loop.h\"\n #include \"tree-into-ssa.h\"\n-#include \"tree-ssa.h\"\n #include \"cfgloop.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"tree-ssa-propagate.h\"\n-#include \"tree-chrec.h\"\n-#include \"tree-ssa-threadupdate.h\"\n-#include \"tree-ssa-scopedtables.h\"\n #include \"tree-ssa-threadedge.h\"\n-#include \"omp-general.h\"\n-#include \"target.h\"\n-#include \"case-cfn-macros.h\"\n-#include \"alloc-pool.h\"\n #include \"domwalk.h\"\n-#include \"tree-cfgcleanup.h\"\n-#include \"stringpool.h\"\n-#include \"attribs.h\"\n #include \"vr-values.h\"\n-#include \"builtins.h\"\n-#include \"range-op.h\"\n-#include \"value-range-equiv.h\"\n #include \"gimple-array-bounds.h\"\n #include \"gimple-range.h\"\n #include \"gimple-range-path.h\"\n-#include \"tree-ssa-dom.h\"\n \n /* Set of SSA names found live during the RPO traversal of the function\n    for still active basic-blocks.  */\n@@ -2349,34 +2329,6 @@ stmt_interesting_for_vrp (gimple *stmt)\n   return false;\n }\n \n-\n-/* Return the LHS of any ASSERT_EXPR where OP appears as the first\n-   argument to the ASSERT_EXPR and in which the ASSERT_EXPR dominates\n-   BB.  If no such ASSERT_EXPR is found, return OP.  */\n-\n-static tree\n-lhs_of_dominating_assert (tree op, basic_block bb, gimple *stmt)\n-{\n-  imm_use_iterator imm_iter;\n-  gimple *use_stmt;\n-  use_operand_p use_p;\n-\n-  if (TREE_CODE (op) == SSA_NAME)\n-    {\n-      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, op)\n-\t{\n-\t  use_stmt = USE_STMT (use_p);\n-\t  if (use_stmt != stmt\n-\t      && gimple_assign_single_p (use_stmt)\n-\t      && TREE_CODE (gimple_assign_rhs1 (use_stmt)) == ASSERT_EXPR\n-\t      && TREE_OPERAND (gimple_assign_rhs1 (use_stmt), 0) == op\n-\t      && dominated_by_p (CDI_DOMINATORS, bb, gimple_bb (use_stmt)))\n-\t    return gimple_assign_lhs (use_stmt);\n-\t}\n-    }\n-  return op;\n-}\n-\n /* Searches the case label vector VEC for the index *IDX of the CASE_LABEL\n    that includes the value VAL.  The search is restricted to the range\n    [START_IDX, n - 1] where n is the size of VEC.\n@@ -4163,252 +4115,6 @@ vrp_folder::fold_stmt (gimple_stmt_iterator *si)\n   return simplifier.simplify (si);\n }\n \n-class vrp_jt_state : public jt_state\n-{\n-public:\n-  vrp_jt_state (const_and_copies *copies, avail_exprs_stack *avails)\n-    : m_copies (copies), m_avails (avails)\n-  {\n-  }\n-  void push (edge e) override\n-  {\n-    m_copies->push_marker ();\n-    m_avails->push_marker ();\n-    jt_state::push (e);\n-  }\n-  void pop () override\n-  {\n-    m_copies->pop_to_marker ();\n-    m_avails->pop_to_marker ();\n-    jt_state::pop ();\n-  }\n-  void register_equiv (tree dest, tree src, bool) override\n-  {\n-    m_copies->record_const_or_copy (dest, src);\n-  }\n-  void register_equivs_edge (edge e) override\n-  {\n-    record_temporary_equivalences (e, m_copies, m_avails);\n-  }\n-  void record_ranges_from_stmt (gimple *, bool) override\n-  {\n-  }\n-private:\n-  const_and_copies *m_copies;\n-  avail_exprs_stack *m_avails;\n-};\n-\n-class vrp_jt_simplifier : public jt_simplifier\n-{\n-public:\n-  vrp_jt_simplifier (vr_values *v, avail_exprs_stack *avails)\n-    : m_vr_values (v), m_avail_exprs_stack (avails) { }\n-\n-private:\n-  tree simplify (gimple *, gimple *, basic_block, jt_state *) override;\n-  vr_values *m_vr_values;\n-  avail_exprs_stack *m_avail_exprs_stack;\n-};\n-\n-tree\n-vrp_jt_simplifier::simplify (gimple *stmt, gimple *within_stmt,\n-\t\t\t     basic_block bb, jt_state *)\n-{\n-  /* First see if the conditional is in the hash table.  */\n-  tree cached_lhs = m_avail_exprs_stack->lookup_avail_expr (stmt, false, true);\n-  if (cached_lhs && is_gimple_min_invariant (cached_lhs))\n-    return cached_lhs;\n-\n-  /* Next see if we can solve it with VRP's internal structures.  */\n-  if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n-    {\n-      tree op0 = gimple_cond_lhs (cond_stmt);\n-      op0 = lhs_of_dominating_assert (op0, bb, stmt);\n-\n-      tree op1 = gimple_cond_rhs (cond_stmt);\n-      op1 = lhs_of_dominating_assert (op1, bb, stmt);\n-\n-      simplify_using_ranges simplifier (m_vr_values);\n-      return simplifier.vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n-\t\t\t\t\t\t  op0, op1, within_stmt);\n-    }\n-  if (gswitch *switch_stmt = dyn_cast <gswitch *> (stmt))\n-    {\n-      tree op = gimple_switch_index (switch_stmt);\n-      if (TREE_CODE (op) != SSA_NAME)\n-\treturn NULL_TREE;\n-\n-      op = lhs_of_dominating_assert (op, bb, stmt);\n-\n-      const value_range_equiv *vr = m_vr_values->get_value_range (op);\n-      return find_case_label_range (switch_stmt, vr);\n-    }\n-\n-  /* Finally, try vr_values.  */\n-  if (gassign *assign_stmt = dyn_cast <gassign *> (stmt))\n-    {\n-      tree lhs = gimple_assign_lhs (assign_stmt);\n-      if (TREE_CODE (lhs) == SSA_NAME\n-\t  && (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n-\t      || POINTER_TYPE_P (TREE_TYPE (lhs)))\n-\t  && stmt_interesting_for_vrp (stmt))\n-\t{\n-\t  edge dummy_e;\n-\t  tree dummy_tree;\n-\t  value_range_equiv new_vr;\n-\t  m_vr_values->extract_range_from_stmt (stmt, &dummy_e, &dummy_tree,\n-\t\t\t\t\t\t&new_vr);\n-\t  tree singleton;\n-\t  if (new_vr.singleton_p (&singleton))\n-\t    return singleton;\n-\t}\n-    }\n-  return NULL;\n-}\n-\n-/* Blocks which have more than one predecessor and more than\n-   one successor present jump threading opportunities, i.e.,\n-   when the block is reached from a specific predecessor, we\n-   may be able to determine which of the outgoing edges will\n-   be traversed.  When this optimization applies, we are able\n-   to avoid conditionals at runtime and we may expose secondary\n-   optimization opportunities.\n-\n-   This class is effectively a driver for the generic jump\n-   threading code.  It basically just presents the generic code\n-   with edges that may be suitable for jump threading.\n-\n-   Unlike DOM, we do not iterate VRP if jump threading was successful.\n-   While iterating may expose new opportunities for VRP, it is expected\n-   those opportunities would be very limited and the compile time cost\n-   to expose those opportunities would be significant.\n-\n-   As jump threading opportunities are discovered, they are registered\n-   for later realization.  */\n-\n-class vrp_jump_threader : public dom_walker\n-{\n-public:\n-  vrp_jump_threader (function *, vr_values *);\n-  ~vrp_jump_threader ();\n-\n-  void thread_jumps ()\n-  {\n-    walk (m_fun->cfg->x_entry_block_ptr);\n-  }\n-\n-  void thread_through_all_blocks ()\n-  {\n-    // FIXME: Put this in the destructor?\n-    m_threader->thread_through_all_blocks (false);\n-  }\n-\n-private:\n-  virtual edge before_dom_children (basic_block);\n-  virtual void after_dom_children (basic_block);\n-\n-  function *m_fun;\n-  vr_values *m_vr_values;\n-  const_and_copies *m_const_and_copies;\n-  avail_exprs_stack *m_avail_exprs_stack;\n-  hash_table<expr_elt_hasher> *m_avail_exprs;\n-  vrp_jt_simplifier *m_simplifier;\n-  jump_threader *m_threader;\n-  jt_state *m_state;\n-};\n-\n-vrp_jump_threader::vrp_jump_threader (struct function *fun, vr_values *v)\n-  : dom_walker (CDI_DOMINATORS, REACHABLE_BLOCKS)\n-{\n-  /* Ugh.  When substituting values earlier in this pass we can wipe\n-     the dominance information.  So rebuild the dominator information\n-     as we need it within the jump threading code.  */\n-  calculate_dominance_info (CDI_DOMINATORS);\n-\n-  /* We do not allow VRP information to be used for jump threading\n-     across a back edge in the CFG.  Otherwise it becomes too\n-     difficult to avoid eliminating loop exit tests.  Of course\n-     EDGE_DFS_BACK is not accurate at this time so we have to\n-     recompute it.  */\n-  mark_dfs_back_edges ();\n-\n-  /* Allocate our unwinder stack to unwind any temporary equivalences\n-     that might be recorded.  */\n-  m_const_and_copies = new const_and_copies ();\n-\n-  m_fun = fun;\n-  m_vr_values = v;\n-  m_avail_exprs = new hash_table<expr_elt_hasher> (1024);\n-  m_avail_exprs_stack = new avail_exprs_stack (m_avail_exprs);\n-  m_state = new vrp_jt_state (m_const_and_copies, m_avail_exprs_stack);\n-\n-  m_simplifier = new vrp_jt_simplifier (m_vr_values, m_avail_exprs_stack);\n-  m_threader = new jump_threader (m_simplifier, m_state);\n-}\n-\n-vrp_jump_threader::~vrp_jump_threader ()\n-{\n-  /* We do not actually update the CFG or SSA graphs at this point as\n-     ASSERT_EXPRs are still in the IL and cfg cleanup code does not\n-     yet handle ASSERT_EXPRs gracefully.  */\n-  delete m_const_and_copies;\n-  delete m_avail_exprs;\n-  delete m_avail_exprs_stack;\n-  delete m_simplifier;\n-  delete m_threader;\n-  delete m_state;\n-}\n-\n-/* Called before processing dominator children of BB.  We want to look\n-   at ASSERT_EXPRs and record information from them in the appropriate\n-   tables.\n-\n-   We could look at other statements here.  It's not seen as likely\n-   to significantly increase the jump threads we discover.  */\n-\n-edge\n-vrp_jump_threader::before_dom_children (basic_block bb)\n-{\n-  gimple_stmt_iterator gsi;\n-\n-  m_avail_exprs_stack->push_marker ();\n-  m_const_and_copies->push_marker ();\n-  for (gsi = gsi_start_nondebug_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple *stmt = gsi_stmt (gsi);\n-      if (gimple_assign_single_p (stmt)\n-         && TREE_CODE (gimple_assign_rhs1 (stmt)) == ASSERT_EXPR)\n-\t{\n-\t  tree rhs1 = gimple_assign_rhs1 (stmt);\n-\t  tree cond = TREE_OPERAND (rhs1, 1);\n-\t  tree inverted = invert_truthvalue (cond);\n-\t  vec<cond_equivalence> p;\n-\t  p.create (3);\n-\t  record_conditions (&p, cond, inverted);\n-\t  for (unsigned int i = 0; i < p.length (); i++)\n-\t    m_avail_exprs_stack->record_cond (&p[i]);\n-\n-\t  tree lhs = gimple_assign_lhs (stmt);\n-\t  m_const_and_copies->record_const_or_copy (lhs,\n-\t\t\t\t\t\t    TREE_OPERAND (rhs1, 0));\n-\t  p.release ();\n-\t  continue;\n-\t}\n-      break;\n-    }\n-  return NULL;\n-}\n-\n-/* Called after processing dominator children of BB.  This is where we\n-   actually call into the threader.  */\n-void\n-vrp_jump_threader::after_dom_children (basic_block bb)\n-{\n-  m_threader->thread_outgoing_edges (bb);\n-  m_avail_exprs_stack->pop_to_marker ();\n-  m_const_and_copies->pop_to_marker ();\n-}\n-\n /* STMT is a conditional at the end of a basic block.\n \n    If the conditional is of the form SSA_NAME op constant and the SSA_NAME"}]}