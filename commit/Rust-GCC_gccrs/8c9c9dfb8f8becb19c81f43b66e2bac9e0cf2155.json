{"sha": "8c9c9dfb8f8becb19c81f43b66e2bac9e0cf2155", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM5YzlkZmI4ZjhiZWNiMTljODFmNDNiNjZlMmJhYzllMGNmMjE1NQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-02-13T11:37:10Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-02-13T11:37:10Z"}, "message": "2003-02-13  Michael Koch  <konqueror@gmx.de>\n\n\t* java/nio/ByteBuffer.java\n\t(endian): New member variable.\n\t(get): New methods.\n\t(equals): New method.\n\t(compareTo): New method.\n\t(order): New methods.\n\t(compact): New method.\n\t(isDirect): New method.\n\t(slice): New method.\n\t(duplicate): New method.\n\t(asReadOnlyBuffer): New method.\n\t(asCharBuffer): New method.\n\t(asDoubleBuffer): New method.\n\t(asFloatBuffer): New method.\n\t(asIntBuffer): New method.\n\t(asLongBuffer): New method.\n\t(asShortBuffer): New method.\n\t(get*): New methods.\n\t(put*): New methods.\n\t(toString): New method.\n\t* java/nio/CharBuffer.java\n\t(CharBuffer): Implement Comparable instead of Cloneable.\n\t(get): May not be final.\n\t(put): May not be final.\n\nFrom-SVN: r62836", "tree": {"sha": "5b903191e57ede180ab487238157c0bd1149dd24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b903191e57ede180ab487238157c0bd1149dd24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c9c9dfb8f8becb19c81f43b66e2bac9e0cf2155", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c9c9dfb8f8becb19c81f43b66e2bac9e0cf2155", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c9c9dfb8f8becb19c81f43b66e2bac9e0cf2155", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c9c9dfb8f8becb19c81f43b66e2bac9e0cf2155/comments", "author": null, "committer": null, "parents": [{"sha": "4cce66c3d7ac10f6fa40fe39867c504cba19ff1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cce66c3d7ac10f6fa40fe39867c504cba19ff1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cce66c3d7ac10f6fa40fe39867c504cba19ff1f"}], "stats": {"total": 434, "additions": 428, "deletions": 6}, "files": [{"sha": "72491438c12b77fcd3616afdb3988ac40bb80cf7", "filename": "libjava/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c9c9dfb8f8becb19c81f43b66e2bac9e0cf2155/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c9c9dfb8f8becb19c81f43b66e2bac9e0cf2155/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=8c9c9dfb8f8becb19c81f43b66e2bac9e0cf2155", "patch": "@@ -1,3 +1,30 @@\n+2003-02-13  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/nio/ByteBuffer.java\n+\t(endian): New member variable.\n+\t(get): New methods.\n+\t(equals): New method.\n+\t(compareTo): New method.\n+\t(order): New methods.\n+\t(compact): New method.\n+\t(isDirect): New method.\n+\t(slice): New method.\n+\t(duplicate): New method.\n+\t(asReadOnlyBuffer): New method.\n+\t(asCharBuffer): New method.\n+\t(asDoubleBuffer): New method.\n+\t(asFloatBuffer): New method.\n+\t(asIntBuffer): New method.\n+\t(asLongBuffer): New method.\n+\t(asShortBuffer): New method.\n+\t(get*): New methods.\n+\t(put*): New methods.\n+\t(toString): New method.\n+\t* java/nio/CharBuffer.java\n+\t(CharBuffer): Implement Comparable instead of Cloneable.\n+\t(get): May not be final.\n+\t(put): May not be final.\n+\t\n 2002-02-13  Ranjit Mathew  <rmathew@hotmail.com>\n \n \t* gnu/gcj/runtime/NameFinder.java (createStackTraceElement): Use"}, {"sha": "8b7c60130192afb691a7e37afa5fb6977bae84b3", "filename": "libjava/java/nio/ByteBuffer.java", "status": "modified", "additions": 396, "deletions": 1, "changes": 397, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c9c9dfb8f8becb19c81f43b66e2bac9e0cf2155/libjava%2Fjava%2Fnio%2FByteBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c9c9dfb8f8becb19c81f43b66e2bac9e0cf2155/libjava%2Fjava%2Fnio%2FByteBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FByteBuffer.java?ref=8c9c9dfb8f8becb19c81f43b66e2bac9e0cf2155", "patch": "@@ -44,6 +44,8 @@\n  */\n public abstract class ByteBuffer extends Buffer implements Comparable\n {\n+  private ByteOrder endian = ByteOrder.BIG_ENDIAN;\n+\n   int offset;\n   byte[] backing_buffer;\n   \n@@ -87,6 +89,51 @@ final public static ByteBuffer wrap (byte[] array)\n     super (capacity, limit, position, mark);\n   }\n \n+  /**\n+   * This method transfers bytes from this buffer into\n+   * the given destination array.\n+   *\n+   * @param dst The destination array\n+   * @param offset The offset within the array of the first byte to be written;\n+   * must be non-negative and no larger than dst.length.\n+   * @param length The maximum number of bytes to be written to the given array;\n+   * must be non-negative and no larger than dst.length - offset.\n+   *\n+   * @exception BufferUnderflowException If there are fewer than length bytes\n+   * remaining in this buffer.\n+   * @exception IndexOutOfBoundsException - If the preconditions on the offset\n+   * and length parameters do not hold.\n+   */\n+  public ByteBuffer get (byte[] dst, int offset, int length)\n+  {\n+    if ((offset < 0)\n+        || (offset > dst.length)\n+        || (length < 0)\n+        || (length > (dst.length - offset)))\n+      throw new IndexOutOfBoundsException ();\n+\n+    for (int i = offset; i < offset + length; i++)\n+      {\n+        dst [i] = get();\n+      }\n+\n+    return this;\n+  }\n+\n+  /**\n+   * This method transfers bytes from this buffer into the given\n+   * destination array.\n+   *\n+   * @param dst The byte array to write into.\n+   *\n+   * @exception BufferUnderflowException If there are fewer than dst.length\n+   * bytes remaining in this buffer.\n+   */\n+  public ByteBuffer get (byte[] dst)\n+  {\n+    return get (dst, 0, dst.length);\n+  }\n+ \n   /**\n    * Writes the content of src into the buffer.\n    *\n@@ -200,7 +247,79 @@ public final int arrayOffset ()\n   }\n   \n   /**\n-   * Relative get method.\n+   * Tells whether or not this buffer is equal to another object.\n+   */\n+  public boolean equals (Object obj)\n+  {\n+    if (obj != null &&\n+        obj instanceof ByteBuffer)\n+      {\n+        return compareTo (obj) == 0;\n+      }\n+    \n+    return false;\n+  }\n+ \n+  /**\n+   * Compares this buffer to another object.\n+   *\n+   * @exception ClassCastException If the argument is not a byte buffer\n+   */\n+  public int compareTo (Object obj)\n+  {\n+    ByteBuffer a = (ByteBuffer) obj;\n+\n+    if (a.remaining() != remaining())\n+      {\n+        return 1;\n+      }\n+   \n+    if (! hasArray() ||\n+        ! a.hasArray())\n+      {\n+        return 1;\n+      }\n+   \n+    int r = remaining();\n+    int i1 = position ();\n+    int i2 = a.position ();\n+   \n+    for (int i = 0; i < r; i++)\n+      {\n+        int t = (int) (get (i1) - a.get (i2));\n+   \n+        if (t != 0)\n+          {\n+            return (int) t;\n+          }\n+      }\n+  \n+    return 0;\n+  }\n+\n+  /**\n+   * Retrieves this buffer's byte order.\n+   */  \n+  public final ByteOrder order()\n+  {\n+    return endian;\n+  }\n+  \n+  /**\n+   * Modifies this buffer's byte order.\n+   */\n+  public final ByteBuffer order (ByteOrder endian)\n+  {\n+    this.endian = endian;\n+    return this;\n+  }\n+  \n+  /**\n+   * Reads the byte at this buffer's current position,\n+   * and then increments the position.\n+   *\n+   * @exception BufferUnderflowException If the buffer's current position\n+   * is not smaller than its limit.\n    */\n   public abstract byte get ();\n   \n@@ -212,4 +331,280 @@ public final int arrayOffset ()\n    * @exception ReadOnlyBufferException If this buffer is read-only.\n    */\n   public abstract ByteBuffer put (byte b);\n+  \n+  /**\n+   * Absolute get method.\n+   *\n+   * @exception IndexOutOfBoundsException FIXME\n+   */\n+  public abstract byte get (int index);\n+  \n+  /**\n+   * Absolute put method.\n+   *\n+   * @exception ReadOnlyBufferException If this buffer is read-only\n+   * @exception IndexOutOfBoundsException FIXME\n+   */\n+  public abstract ByteBuffer put (int index, byte b);\n+  \n+  /**\n+   * Compacts this buffer.\n+   *\n+   * @exception ReadOnlyBufferException If this buffer is read-only\n+   */\n+  public abstract ByteBuffer compact();\n+\n+  /**\n+   * Tells whether or not this buffer is direct.\n+   */\n+  public abstract boolean isDirect();\n+  \n+  /**\n+   * Creates a new byte buffer whose content is a shared subsequence of this\n+   * buffer's content.\n+   */\n+  public abstract ByteBuffer slice();\n+  \n+  /**\n+   * Creates a new byte buffer that shares this buffer's content.\n+   */\n+  public abstract ByteBuffer duplicate();\n+  \n+  /**\n+   * Creates a new, read-only byte buffer that shares this buffer's content.\n+   */\n+  public abstract ByteBuffer asReadOnlyBuffer();\n+ \n+  /**\n+   * Creates a view of this byte buffer as a short buffer.\n+   */\n+  public abstract ShortBuffer asShortBuffer();\n+  \n+  /**\n+   * Creates a view of this byte buffer as a char buffer.\n+   */\n+  public abstract CharBuffer asCharBuffer();\n+  \n+  /**\n+   * Creates a view of this byte buffer as an integer buffer.\n+   */\n+  public abstract IntBuffer asIntBuffer();\n+  \n+  /**\n+   * Creates a view of this byte buffer as a long buffer.\n+   */\n+  public abstract LongBuffer asLongBuffer();\n+  \n+  /**\n+   * Creates a view of this byte buffer as a float buffer.\n+   */\n+  public abstract FloatBuffer asFloatBuffer();\n+  \n+  /**\n+   * Creates a view of this byte buffer as a double buffer.\n+   */\n+  public abstract DoubleBuffer asDoubleBuffer();\n+\n+  /**\n+   * Relative get method for reading a character value.\n+   *\n+   * @exception BufferUnderflowException  If there are fewer than two bytes\n+   * remaining in this buffer.\n+   */\n+  public abstract char getChar();\n+  \n+  /**\n+   * Relative put method for writing a character value.\n+   *\n+   * @exception BufferOverflowException If this buffer's current position is\n+   * not smaller than its limit.\n+   */\n+  public abstract ByteBuffer putChar(char value);\n+  \n+  /**\n+   * Absolute get method for reading a character value.\n+   *\n+   * @exception IndexOutOfBoundsException If there are fewer than two bytes\n+   * remaining in this buffer\n+   */\n+  public abstract char getChar(int index);\n+  \n+  /**\n+   * Absolute put method for writing a character value.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit, minus one.\n+   */\n+  public abstract ByteBuffer putChar(int index, char value);\n+  \n+  /**\n+   * Relative get method for reading a short value.\n+   *\n+   * @exception BufferUnderflowException If index is negative or not smaller\n+   * than the buffer's limit, minus one.\n+   */\n+  public abstract short getShort();\n+  \n+  /**\n+   * Relative put method for writing a short value.\n+   *\n+   * @exception BufferOverflowException If this buffer's current position is\n+   * not smaller than its limit.\n+   */\n+  public abstract ByteBuffer putShort(short value);\n+  \n+  /**\n+   * Absolute get method for reading a short value.\n+   *\n+   * @exception IndexOutOfBoundsException If there are fewer than two bytes\n+   * remaining in this buffer\n+   */\n+  public abstract short getShort(int index);\n+ \n+  /**\n+   * Absolute put method for writing a short value.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit, minus one.\n+   */\n+  public abstract ByteBuffer putShort(int index, short value);\n+  \n+  /**\n+   * Relative get method for reading an integer value.\n+   *\n+   * @exception BufferUnderflowException If there are fewer than four bytes\n+   * remaining in this buffer.\n+   */\n+  public abstract int getInt();\n+  \n+  /**\n+   * Relative put method for writing an integer value.\n+   *\n+   * @exception BufferOverflowException If this buffer's current position is\n+   * not smaller than its limit.\n+   */\n+  public abstract ByteBuffer putInt(int value);\n+  \n+  /**\n+   * Absolute get method for reading an integer value.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit, minus three.\n+   */\n+  public abstract int getInt(int index);\n+  \n+  /**\n+   * Absolute put method for writing an integer value.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit, minus three.\n+   */\n+  public abstract ByteBuffer putInt(int index, int value);\n+  \n+  /**\n+   * Relative get method for reading a long value.\n+   *\n+   * @exception BufferUnderflowException If there are fewer than eight bytes\n+   * remaining in this buffer.\n+   */\n+  public abstract long getLong();\n+  \n+  /**\n+   * Relative put method for writing a long value.\n+   *\n+   * @exception BufferOverflowException If this buffer's current position is\n+   * not smaller than its limit.\n+   */\n+  public abstract ByteBuffer putLong(long value);\n+  \n+  /**\n+   * Absolute get method for reading a long value.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit, minus seven.\n+   */\n+  public abstract long getLong(int index);\n+  \n+  /**\n+   * Absolute put method for writing a float value.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit, minus seven.\n+   */\n+  public abstract ByteBuffer putLong(int index, long value);\n+  \n+  /**\n+   * Relative get method for reading a float value.\n+   *\n+   * @exception BufferUnderflowException If there are fewer than four bytes\n+   * remaining in this buffer.\n+   */\n+  public abstract float getFloat();\n+  \n+  /**\n+   * Relative put method for writing a float value.\n+   *\n+   * @exception BufferOverflowException If there are fewer than four bytes\n+   * remaining in this buffer.\n+   */\n+  public abstract ByteBuffer putFloat(float value);\n+  \n+  /**\n+   * Absolute get method for reading a float value.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit, minus three.\n+   */\n+  public abstract float getFloat(int index);\n+  \n+  /**\n+   * Relative put method for writing a float value.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit, minus three.\n+   */\n+  public abstract ByteBuffer putFloat(int index, float value);\n+  \n+  /**\n+   * Relative get method for reading a double value.\n+   *\n+   * @exception BufferUnderflowException If there are fewer than eight bytes\n+   * remaining in this buffer.\n+   */\n+  public abstract double getDouble();\n+  \n+  /**\n+   * Relative put method for writing a double value.\n+   *\n+   * @exception BufferOverflowException If this buffer's current position is\n+   * not smaller than its limit.\n+   */\n+  public abstract ByteBuffer putDouble(double value);\n+  \n+  /**\n+   * Absolute get method for reading a double value.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit, minus seven.\n+   */\n+  public abstract double getDouble(int index);\n+  \n+  /**\n+   * Absolute put method for writing a double value.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit, minus seven.\n+   */\n+  public abstract ByteBuffer putDouble(int index, double value);\n+\n+  /**\n+   * Returns a string summarizing the state of this buffer.\n+   */\n+  public String toString ()\n+  {\n+    return getClass ().getName () +\n+\t    \"[pos=\" + position () +\n+\t    \" lim=\" + limit () +\n+\t    \" cap=\" + capacity () + \"]\";\n+  }\n }"}, {"sha": "9d61be90b040c54f558b46b48757377d6e7e0bb2", "filename": "libjava/java/nio/CharBuffer.java", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c9c9dfb8f8becb19c81f43b66e2bac9e0cf2155/libjava%2Fjava%2Fnio%2FCharBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c9c9dfb8f8becb19c81f43b66e2bac9e0cf2155/libjava%2Fjava%2Fnio%2FCharBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FCharBuffer.java?ref=8c9c9dfb8f8becb19c81f43b66e2bac9e0cf2155", "patch": "@@ -43,7 +43,7 @@\n  * @since 1.4\n  */\n public abstract class CharBuffer extends Buffer\n-  implements Cloneable, CharSequence\n+  implements Comparable, CharSequence\n {\n   protected char [] backing_buffer;\n   \n@@ -119,7 +119,7 @@ final public static CharBuffer wrap (char[] array)\n    * @exception IndexOutOfBoundsException If the preconditions on the offset\n    * and length parameters do not hold\n    */\n-  final public CharBuffer get (char[] dst, int offset, int length)\n+  public CharBuffer get (char[] dst, int offset, int length)\n   {\n     for (int i = offset; i < offset + length; i++)\n       {\n@@ -135,7 +135,7 @@ final public CharBuffer get (char[] dst, int offset, int length)\n    * @exception BufferUnderflowException If there are fewer than length\n    * characters remaining in this buffer.\n    */\n-  final public CharBuffer get (char[] dst)\n+  public CharBuffer get (char[] dst)\n   {\n     return get (dst, 0, dst.length);\n   }\n@@ -146,7 +146,7 @@ final public CharBuffer get (char[] dst)\n    * @exception IllegalArgumentException If the source buffer is this buffer.\n    * @exception ReadOnlyBufferException If this buffer is read-only.\n    */\n-  final public CharBuffer put (CharBuffer src)\n+  public CharBuffer put (CharBuffer src)\n   {\n     if (src == this)\n       throw new IllegalArgumentException ();\n@@ -168,7 +168,7 @@ final public CharBuffer put (CharBuffer src)\n    * and length parameters do not hold\n    * @exception ReadOnlyBufferException If this buffer is read-only.\n    */\n-  final public CharBuffer put (char[] src, int offset, int length)\n+  public CharBuffer put (char[] src, int offset, int length)\n   {\n     if (offset < 0\n         || offset >= src.length"}]}