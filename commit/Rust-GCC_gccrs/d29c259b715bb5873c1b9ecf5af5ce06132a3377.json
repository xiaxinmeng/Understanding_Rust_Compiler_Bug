{"sha": "d29c259b715bb5873c1b9ecf5af5ce06132a3377", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI5YzI1OWI3MTViYjU4NzNjMWI5ZWNmNWFmNWNlMDYxMzJhMzM3Nw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-01-19T09:42:11Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-01-19T09:42:11Z"}, "message": "stupid.c: Die die die.\n\n\t* stupid.c: Die die die.\n\t* Makefile.in (OBJS): Remove stupid.o.\n\t(stupid.o): Likewise.\n\n\t* except.c (emit_eh_context): Don't emit USEs for stupid.\n\t* explow.c (probe_stack_range): Likewise.\n\t* flags.h (obey_regdecls): Remove.\n\t* flow.c (find_basic_blocks): Don't run try_merge_blocks\n\twhen not optimizing.\n\t(life_analysis): Limit data collection when not optimizing.\n\t(mark_regs_live_at_end): Always mark the return value registers.\n\t(mark_used_regs): Remove dummy RETURN case.\n\t(print_rtl_with_bb): Don't consult obey_regdecls.\n\t* function.c (use_variable, use_variable_after): Remove.\n\t(assign_parms): Consult optimize not obey_regdecls.\n\t(expand_function_start): Don't emit USEs for stupid.\n\t(expand_function_end): Likewise.\n\t* global.c (build_insn_chain): Export.\n\t* integrate.c (expand_inline_function): Kill return-value USE\n\thandling code.\n\t* jump.c (jump_optimize_1): Do simple jump optimizations and\n\tdead code elimination.\n\t(calculate_can_reach_end): Remove check_deleted argument.\n\t(delete_insn): Patch out insns even when not optimizing.\n\t* local-alloc.c (block_alloc): Don't do tying when not optimizing.\n\t* rtl.h (use_variable, use_variable_after): Remove declarations.\n\t(build_insn_chain): Declare.\n\t* stmt.c (expand_value_return): Don't emit USEs for stupid.\n\t(expand_end_bindings): Likewise.\n\t(expand_decl): Likewise.  Consult optimize not obey_regdecls.\n\t* toplev.c (obey_regdecls): Remove.\n\t(rest_of_compilation): Don't set it.  Kill stupid in favour of\n\tflow1, local-alloc, and reload.\n\t(main): Don't set obey_regdecls.\n\n\t* config/nextstep.c (handle_pragma): Likewise.\n\n\t* alpha/alpha.md (allocate_stack): Don't emit USEs for stupid.\n\n\t* arm/arm.h (CONDITIONAL_REGISTER_USAGE): Don't fix reg 0 for stupid.\n\nFrom-SVN: r31499", "tree": {"sha": "1279f2c86a2d7f56c162a81d8ff2ce20872bda4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1279f2c86a2d7f56c162a81d8ff2ce20872bda4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d29c259b715bb5873c1b9ecf5af5ce06132a3377", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d29c259b715bb5873c1b9ecf5af5ce06132a3377", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d29c259b715bb5873c1b9ecf5af5ce06132a3377", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d29c259b715bb5873c1b9ecf5af5ce06132a3377/comments", "author": null, "committer": null, "parents": [{"sha": "301e21af2c964ac3f7505d5bf9a45d2fe812ff29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/301e21af2c964ac3f7505d5bf9a45d2fe812ff29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/301e21af2c964ac3f7505d5bf9a45d2fe812ff29"}], "stats": {"total": 1145, "additions": 120, "deletions": 1025}, "files": [{"sha": "50211e64333a550d4f4cbac9bfc83f41688524af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d29c259b715bb5873c1b9ecf5af5ce06132a3377", "patch": "@@ -1,3 +1,46 @@\n+2000-01-19  Richard Henderson  <rth@cygnus.com>\n+\n+\t* stupid.c: Die die die.\n+\t* Makefile.in (OBJS): Remove stupid.o.\n+\t(stupid.o): Likewise.\n+\n+\t* except.c (emit_eh_context): Don't emit USEs for stupid.\n+\t* explow.c (probe_stack_range): Likewise.\n+\t* flags.h (obey_regdecls): Remove.\n+\t* flow.c (find_basic_blocks): Don't run try_merge_blocks\n+\twhen not optimizing.\n+\t(life_analysis): Limit data collection when not optimizing.\n+\t(mark_regs_live_at_end): Always mark the return value registers.\n+\t(mark_used_regs): Remove dummy RETURN case.\n+\t(print_rtl_with_bb): Don't consult obey_regdecls.\n+\t* function.c (use_variable, use_variable_after): Remove.\n+\t(assign_parms): Consult optimize not obey_regdecls.\n+\t(expand_function_start): Don't emit USEs for stupid.\n+\t(expand_function_end): Likewise.\n+\t* global.c (build_insn_chain): Export.\n+\t* integrate.c (expand_inline_function): Kill return-value USE\n+\thandling code.\n+\t* jump.c (jump_optimize_1): Do simple jump optimizations and\n+\tdead code elimination.\n+\t(calculate_can_reach_end): Remove check_deleted argument.\n+\t(delete_insn): Patch out insns even when not optimizing.\n+\t* local-alloc.c (block_alloc): Don't do tying when not optimizing.\n+\t* rtl.h (use_variable, use_variable_after): Remove declarations.\n+\t(build_insn_chain): Declare.\n+\t* stmt.c (expand_value_return): Don't emit USEs for stupid.\n+\t(expand_end_bindings): Likewise.\n+\t(expand_decl): Likewise.  Consult optimize not obey_regdecls.\n+\t* toplev.c (obey_regdecls): Remove.\n+\t(rest_of_compilation): Don't set it.  Kill stupid in favour of\n+\tflow1, local-alloc, and reload.\n+\t(main): Don't set obey_regdecls.\n+\n+\t* config/nextstep.c (handle_pragma): Likewise.\n+\n+\t* alpha/alpha.md (allocate_stack): Don't emit USEs for stupid.\n+\n+\t* arm/arm.h (CONDITIONAL_REGISTER_USAGE): Don't fix reg 0 for stupid.\n+\n 2000-01-18  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* alpha-protos.h: PROTO -> PARAMS."}, {"sha": "66e06b79e67589432371047c8ebc0bf4672df176", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d29c259b715bb5873c1b9ecf5af5ce06132a3377", "patch": "@@ -667,7 +667,7 @@ OBJS = diagnostic.o \\\n  function.o stmt.o except.o expr.o calls.o expmed.o explow.o optabs.o real.o \\\n  builtins.o intl.o varasm.o rtl.o print-rtl.o rtlanal.o emit-rtl.o genrtl.o \\\n  dbxout.o sdbout.o dwarfout.o dwarf2out.o xcoffout.o bitmap.o alias.o gcse.o \\\n- integrate.o jump.o cse.o loop.o unroll.o flow.o stupid.o combine.o varray.o \\\n+ integrate.o jump.o cse.o loop.o unroll.o flow.o combine.o varray.o \\\n  regclass.o regmove.o local-alloc.o global.o reload.o reload1.o caller-save.o \\\n  insn-peep.o reorg.o haifa-sched.o final.o recog.o reg-stack.o \\\n  insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o lcm.o \\\n@@ -1546,8 +1546,6 @@ integrate.o : integrate.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n jump.o : jump.c $(CONFIG_H) system.h $(RTL_H) flags.h hard-reg-set.h $(REGS_H) \\\n    insn-config.h insn-flags.h $(RECOG_H) $(EXPR_H) real.h except.h function.h \\\n    toplev.h insn-attr.h\n-stupid.o : stupid.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h \\\n-   $(BASIC_BLOCK_H) insn-config.h reload.h flags.h function.h toplev.h\n \n simplify-rtx.o : simplify-rtx.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\"}, {"sha": "7adee1d313398ae74fe634b18e7a179c88550030", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=d29c259b715bb5873c1b9ecf5af5ce06132a3377", "patch": "@@ -5116,8 +5116,6 @@\n       emit_insn (gen_adddi3 (tmp, tmp, GEN_INT(-8192)));\n       emit_insn (gen_cmpdi (tmp, want));\n       emit_jump_insn (gen_bgtu (loop_label));\n-      if (obey_regdecls)\n-\tgen_rtx_USE (VOIDmode, tmp);\n \n       memref = gen_rtx_MEM (DImode, want);\n       MEM_VOLATILE_P (memref) = 1;"}, {"sha": "33f5932a8f4ad57e4325f5ca9f088193e9bc5323", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=d29c259b715bb5873c1b9ecf5af5ce06132a3377", "patch": "@@ -736,14 +736,8 @@ extern const char * structure_size_string;\n #define SUBTARGET_CONDITIONAL_REGISTER_USAGE\n #endif\n \n-/* If doing stupid life analysis, avoid a bug causing a return value r0 to be\n-   trampled.  This effectively reduces the number of available registers by 1.\n-   XXX It is a hack, I know.\n-   XXX Is this still needed?  */\n #define CONDITIONAL_REGISTER_USAGE  \\\n {\t\t\t\t\t\t\t\\\n-  if (obey_regdecls)\t\t\t\t\t\\\n-    fixed_regs[0] = 1;\t\t\t\t\t\\\n   if (TARGET_SOFT_FLOAT)\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n       int regno;\t\t\t\t\t\\"}, {"sha": "f7d85bdad2786120c702b3233ba2fa427088af86", "filename": "gcc/config/nextstep.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Fconfig%2Fnextstep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Fconfig%2Fnextstep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnextstep.c?ref=d29c259b715bb5873c1b9ecf5af5ce06132a3377", "patch": "@@ -61,13 +61,13 @@ handle_pragma (p_getc, p_ungetc, pname)\n \n   if (strcmp (pname, \"CC_OPT_ON\") == 0)\n     {\n-      optimize = 1, obey_regdecls = 0;\n+      optimize = 1;\n       warning (\"optimization turned on\");\n       retval = 1;\n     }\n   else if (strcmp (pname, \"CC_OPT_OFF\") == 0)\n     {\n-      optimize = 0, obey_regdecls = 1;\n+      optimize = 0;\n       warning (\"optimization turned off\");\n       retval = 1;\n     }\n@@ -76,13 +76,7 @@ handle_pragma (p_getc, p_ungetc, pname)\n       extern int initial_optimize_flag;\n \n       if (optimize != initial_optimize_flag)\n-\t{\n-\t  if (initial_optimize_flag)\n-\t    obey_regdecls = 0;\n-\t  else\n-\t    obey_regdecls = 1;\n-\t  optimize = initial_optimize_flag;\n-\t}\n+\toptimize = initial_optimize_flag;\n       warning (\"optimization level restored\");\n       retval = 1;\n     }"}, {"sha": "8fdc9c9a7649f439c652bebd64dbd7a274c87ac5", "filename": "gcc/except.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=d29c259b715bb5873c1b9ecf5af5ce06132a3377", "patch": "@@ -2364,14 +2364,6 @@ emit_eh_context ()\n \t    end_sequence ();\n \n \t    emit_insns_before (insns, insn);\n-\n-            /* At -O0, we must make the context register stay alive so\n-               that the stupid.c register allocator doesn't get confused. */\n-            if (obey_regdecls != 0)\n-              {\n-                insns = gen_rtx_USE (GET_MODE (XEXP (reg,0)), XEXP (reg,0));\n-                emit_insn_before (insns, get_last_insn ());\n-              }\n \t  }\n       }\n }"}, {"sha": "1f76dcf081dd629b28b61dd5d1f886d5a6f0f4e5", "filename": "gcc/explow.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=d29c259b715bb5873c1b9ecf5af5ce06132a3377", "patch": "@@ -1556,10 +1556,6 @@ probe_stack_range (first, size)\n       emit_note (NULL_PTR, NOTE_INSN_LOOP_END);\n       emit_label (end_lab);\n \n-      /* If will be doing stupid optimization, show test_addr is still live. */\n-      if (obey_regdecls)\n-\temit_insn (gen_rtx_USE (VOIDmode, test_addr));\n-\n       emit_stack_probe (last_addr);\n     }\n }"}, {"sha": "8b8e995e5eb7a525ead57ddd4ef32b15931df0be", "filename": "gcc/flags.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=d29c259b715bb5873c1b9ecf5af5ce06132a3377", "patch": "@@ -57,11 +57,6 @@ extern int optimize;\n \n extern int optimize_size;\n \n-/* Nonzero means do stupid register allocation.  -noreg.\n-   Currently, this is 1 if `optimize' is 0.  */\n-\n-extern int obey_regdecls;\n-\n /* Don't print functions as they are compiled and don't print\n    times taken by the various passes.  -quiet.  */\n "}, {"sha": "ac5d204350dab9e6f522d33ca301b21f6b598fb9", "filename": "gcc/flow.c", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=d29c259b715bb5873c1b9ecf5af5ce06132a3377", "patch": "@@ -436,7 +436,8 @@ find_basic_blocks (f, nregs, file, do_cleanup)\n       delete_unreachable_blocks ();\n       move_stray_eh_region_notes ();\n       record_active_eh_regions (f);\n-      try_merge_blocks ();\n+      if (optimize)\n+\ttry_merge_blocks ();\n     }\n \n   /* Mark critical edges.  */\n@@ -2447,9 +2448,14 @@ life_analysis (f, nregs, file, remove_dead_code)\n   /* We want alias analysis information for local dead store elimination.  */\n   init_alias_analysis ();\n \n-  flags = PROP_FINAL;\n-  if (! remove_dead_code)\n-    flags &= ~(PROP_SCAN_DEAD_CODE | PROP_KILL_DEAD_CODE);\n+  if (! optimize)\n+    flags = PROP_DEATH_NOTES | PROP_REG_INFO;\n+  else\n+    {\n+      flags = PROP_FINAL;\n+      if (! remove_dead_code)\n+\tflags &= ~(PROP_SCAN_DEAD_CODE | PROP_KILL_DEAD_CODE);\n+    }\n   life_analysis_1 (f, nregs, flags);\n \n   if (! reload_completed)\n@@ -2835,15 +2841,9 @@ mark_regs_live_at_end (set)\n     }\n \n   /* Mark function return value.  */\n-  /* ??? Only do this after reload.  Consider a non-void function that\n-     omits a return statement.  Across that edge we'll have the return\n-     register live, and no set for it.  Thus the return register will\n-     be live back through the CFG to the entry, and thus we die.  A\n-     possible solution is to emit a clobber at exits without returns.  */\n \n   type = TREE_TYPE (DECL_RESULT (current_function_decl));\n-  if (reload_completed\n-      && type != void_type_node)\n+  if (type != void_type_node)\n     {\n       rtx outgoing;\n \n@@ -4643,12 +4643,6 @@ mark_used_regs (needed, live, x, flags, insn)\n       }\n       break;\n \n-    case RETURN:\n-      /* ??? This info should have been gotten from mark_regs_live_at_end,\n-\t as applied to the EXIT block, and propagated along the edge that\n-\t connects this block to the EXIT.  */\n-      break;\n-\n     case ASM_OPERANDS:\n     case UNSPEC_VOLATILE:\n     case TRAP_IF:\n@@ -5112,8 +5106,7 @@ print_rtl_with_bb (outf, rtx_first)\n \n \t  if (in_bb_p[INSN_UID(tmp_rtx)] == NOT_IN_BB\n \t      && GET_CODE (tmp_rtx) != NOTE\n-\t      && GET_CODE (tmp_rtx) != BARRIER\n-\t      && ! obey_regdecls)\n+\t      && GET_CODE (tmp_rtx) != BARRIER)\n \t    fprintf (outf, \";; Insn is not within a basic block\\n\");\n \t  else if (in_bb_p[INSN_UID(tmp_rtx)] == IN_MULTIPLE_BB)\n \t    fprintf (outf, \";; Insn is in multiple basic blocks\\n\");"}, {"sha": "9006d16dd9b9d093be87b90ea3a3e7a8969cfd73", "filename": "gcc/function.c", "status": "modified", "additions": 8, "deletions": 81, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=d29c259b715bb5873c1b9ecf5af5ce06132a3377", "patch": "@@ -3916,45 +3916,6 @@ delete_handlers ()\n     }\n }\n \f\n-/* Output a USE for any register use in RTL.\n-   This is used with -noreg to mark the extent of lifespan\n-   of any registers used in a user-visible variable's DECL_RTL.  */\n-\n-void\n-use_variable (rtl)\n-     rtx rtl;\n-{\n-  if (GET_CODE (rtl) == REG)\n-    /* This is a register variable.  */\n-    emit_insn (gen_rtx_USE (VOIDmode, rtl));\n-  else if (GET_CODE (rtl) == MEM\n-\t   && GET_CODE (XEXP (rtl, 0)) == REG\n-\t   && (REGNO (XEXP (rtl, 0)) < FIRST_VIRTUAL_REGISTER\n-\t       || REGNO (XEXP (rtl, 0)) > LAST_VIRTUAL_REGISTER)\n-\t   && XEXP (rtl, 0) != current_function_internal_arg_pointer)\n-    /* This is a variable-sized structure.  */\n-    emit_insn (gen_rtx_USE (VOIDmode, XEXP (rtl, 0)));\n-}\n-\n-/* Like use_variable except that it outputs the USEs after INSN\n-   instead of at the end of the insn-chain.  */\n-\n-void\n-use_variable_after (rtl, insn)\n-     rtx rtl, insn;\n-{\n-  if (GET_CODE (rtl) == REG)\n-    /* This is a register variable.  */\n-    emit_insn_after (gen_rtx_USE (VOIDmode, rtl), insn);\n-  else if (GET_CODE (rtl) == MEM\n-\t   && GET_CODE (XEXP (rtl, 0)) == REG\n-\t   && (REGNO (XEXP (rtl, 0)) < FIRST_VIRTUAL_REGISTER\n-\t       || REGNO (XEXP (rtl, 0)) > LAST_VIRTUAL_REGISTER)\n-\t   && XEXP (rtl, 0) != current_function_internal_arg_pointer)\n-    /* This is a variable-sized structure.  */\n-    emit_insn_after (gen_rtx_USE (VOIDmode, XEXP (rtl, 0)), insn);\n-}\n-\f\n int\n max_parm_reg_num ()\n {\n@@ -4495,7 +4456,8 @@ assign_parms (fndecl)\n \t    }\n \t  DECL_RTL (parm) = stack_parm;\n \t}\n-      else if (! ((obey_regdecls && ! DECL_REGISTER (parm)\n+      else if (! ((! optimize\n+\t\t   && ! DECL_REGISTER (parm)\n \t\t   && ! DECL_INLINE (fndecl))\n \t\t  /* layout_decl may set this.  */\n \t\t  || TREE_ADDRESSABLE (parm)\n@@ -4579,7 +4541,8 @@ assign_parms (fndecl)\n \t  /* If we were passed a pointer but the actual value\n \t     can safely live in a register, put it in one.  */\n \t  if (passed_pointer && TYPE_MODE (TREE_TYPE (parm)) != BLKmode\n-\t      && ! ((obey_regdecls && ! DECL_REGISTER (parm)\n+\t      && ! ((! optimize\n+\t\t     && ! DECL_REGISTER (parm)\n \t\t     && ! DECL_INLINE (fndecl))\n \t\t    /* layout_decl may set this.  */\n \t\t    || TREE_ADDRESSABLE (parm)\n@@ -6064,32 +6027,19 @@ expand_function_start (subr, parms_have_cleanups)\n      as opposed to parm setup.  */\n   emit_note (NULL_PTR, NOTE_INSN_FUNCTION_BEG);\n \n-  /* If doing stupid allocation, mark parms as born here.  */\n-\n   if (GET_CODE (get_last_insn ()) != NOTE)\n     emit_note (NULL_PTR, NOTE_INSN_DELETED);\n   parm_birth_insn = get_last_insn ();\n \n-  if (obey_regdecls)\n-    {\n-      for (i = LAST_VIRTUAL_REGISTER + 1; i < max_parm_reg; i++)\n-\tuse_variable (regno_reg_rtx[i]);\n-\n-      if (current_function_internal_arg_pointer != virtual_incoming_args_rtx)\n-\tuse_variable (current_function_internal_arg_pointer);\n-    }\n-\n   context_display = 0;\n   if (current_function_needs_context)\n     {\n       /* Fetch static chain values for containing functions.  */\n       tem = decl_function_context (current_function_decl);\n-      /* If not doing stupid register allocation copy the static chain\n-\t pointer into a pseudo.  If we have small register classes, copy\n-\t the value from memory if static_chain_incoming_rtx is a REG.  If\n-\t we do stupid register allocation, we use the stack address\n-\t generated above.  */\n-      if (tem && ! obey_regdecls)\n+      /* Copy the static chain pointer into a pseudo.  If we have\n+\t small register classes, copy the value from memory if\n+\t static_chain_incoming_rtx is a REG.  */\n+      if (tem)\n \t{\n \t  /* If the static chain originally came in a register, put it back\n \t     there, then move it out in the next insn.  The reason for\n@@ -6349,27 +6299,6 @@ expand_function_end (filename, line, end_bindings)\n      until next function's body starts.  */\n   immediate_size_expand--;\n \n-  /* If doing stupid register allocation,\n-     mark register parms as dying here.  */\n-\n-  if (obey_regdecls)\n-    {\n-      rtx tem;\n-      for (i = LAST_VIRTUAL_REGISTER + 1; i < max_parm_reg; i++)\n-\tuse_variable (regno_reg_rtx[i]);\n-\n-      /* Likewise for the regs of all the SAVE_EXPRs in the function.  */\n-\n-      for (tem = save_expr_regs; tem; tem = XEXP (tem, 1))\n-\t{\n-\t  use_variable (XEXP (tem, 0));\n-\t  use_variable_after (XEXP (tem, 0), parm_birth_insn);\n-\t}\n-\n-      if (current_function_internal_arg_pointer != virtual_incoming_args_rtx)\n-\tuse_variable (current_function_internal_arg_pointer);\n-    }\n-\n   clear_pending_stack_adjust ();\n   do_pending_stack_adjust ();\n \n@@ -6488,7 +6417,6 @@ expand_function_end (filename, line, end_bindings)\n \t\t  GET_MODE (DECL_RTL (DECL_RESULT (current_function_decl))));\n       emit_move_insn (real_decl_result,\n \t\t      DECL_RTL (DECL_RESULT (current_function_decl)));\n-      emit_insn (gen_rtx_USE (VOIDmode, real_decl_result));\n \n       /* The delay slot scheduler assumes that current_function_return_rtx\n \t holds the hard register containing the return value, not a temporary\n@@ -6522,7 +6450,6 @@ expand_function_end (filename, line, end_bindings)\n       REG_FUNCTION_VALUE_P (outgoing) = 1;\n \n       emit_move_insn (outgoing, value_address);\n-      use_variable (outgoing);\n     }\n \n   /* If this is an implementation of __throw, do what's necessary to "}, {"sha": "7fdc0bed722d4980bf5503b8494c92d2c70e01d0", "filename": "gcc/global.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=d29c259b715bb5873c1b9ecf5af5ce06132a3377", "patch": "@@ -305,7 +305,6 @@ static void dump_conflicts\tPARAMS ((FILE *));\n static void reg_becomes_live\tPARAMS ((rtx, rtx, void *));\n static void reg_dies\t\tPARAMS ((int, enum machine_mode,\n \t\t\t\t       struct insn_chain *));\n-static void build_insn_chain\tPARAMS ((rtx));\n \f\n /* Perform allocation of pseudo-registers not allocated by local_alloc.\n    FILE is a file to output debugging information on,\n@@ -1757,7 +1756,7 @@ reg_dies (regno, mode, chain)\n \n /* Walk the insns of the current function and build reload_insn_chain,\n    and record register life information.  */\n-static void\n+void\n build_insn_chain (first)\n      rtx first;\n {"}, {"sha": "8b3fff718a575be8122476dcccfeeb7e3e534368", "filename": "gcc/integrate.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=d29c259b715bb5873c1b9ecf5af5ce06132a3377", "patch": "@@ -1099,13 +1099,6 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t  pattern = PATTERN (insn);\n \t  set = single_set (insn);\n \t  copy = 0;\n-\t  if (GET_CODE (pattern) == USE\n-\t      && GET_CODE (XEXP (pattern, 0)) == REG\n-\t      && REG_FUNCTION_VALUE_P (XEXP (pattern, 0)))\n-\t    /* The (USE (REG n)) at return from the function should\n-\t       be ignored since we are changing (REG n) into\n-\t       inline_target.  */\n-\t    break;\n \n \t  /* If the inline fn needs eh context, make sure that\n \t     the current fn has one. */"}, {"sha": "9028be1ae6d6d79b2b628889f3cce3b605a83ee5", "filename": "gcc/jump.c", "status": "modified", "additions": 12, "deletions": 31, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=d29c259b715bb5873c1b9ecf5af5ce06132a3377", "patch": "@@ -112,7 +112,7 @@ static void delete_barrier_successors\tPARAMS ((rtx));\n static void mark_all_labels\t\tPARAMS ((rtx, int));\n static rtx delete_unreferenced_labels\tPARAMS ((rtx));\n static void delete_noop_moves\t\tPARAMS ((rtx));\n-static int calculate_can_reach_end\tPARAMS ((rtx, int, int));\n+static int calculate_can_reach_end\tPARAMS ((rtx, int));\n static int duplicate_loop_exit_test\tPARAMS ((rtx));\n static void find_cross_jump\t\tPARAMS ((rtx, rtx, int, rtx *, rtx *));\n static void do_cross_jump\t\tPARAMS ((rtx, rtx, rtx));\n@@ -232,24 +232,8 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \n   last_insn = delete_unreferenced_labels (f);\n \n-  if (optimize == 0)\n-    {\n-      /* CAN_REACH_END is persistent for each function.  Once set it should\n-\t not be cleared.  This is especially true for the case where we\n-\t delete the NOTE_FUNCTION_END note.  CAN_REACH_END is cleared by\n-\t the front-end before compiling each function.  */\n-      if (calculate_can_reach_end (last_insn, 1, 0))\n-\tcan_reach_end = 1;\n-\n-      /* Zero the \"deleted\" flag of all the \"deleted\" insns.  */\n-      for (insn = f; insn; insn = NEXT_INSN (insn))\n-\tINSN_DELETED_P (insn) = 0;\n-      \n-      goto end;\n-    }\n-\n #ifdef HAVE_return\n-  if (HAVE_return)\n+  if (optimize && HAVE_return)\n     {\n       /* If we fall through to the epilogue, see if we can insert a RETURN insn\n \t in front of it.  If the machine allows it at this point (we might be\n@@ -275,7 +259,7 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n      This helps some of the optimizations below by having less insns\n      being jumped around.  */\n \n-  if (! reload_completed && after_regscan)\n+  if (optimize && ! reload_completed && after_regscan)\n     for (insn = f; insn; insn = next)\n       {\n \trtx set = single_set (insn);\n@@ -389,6 +373,9 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \t\t}\n \t    }\n \n+\t  if (! optimize)\n+\t    continue;\n+\n \t  /* If a jump references the end of the function, try to turn\n \t     it into a RETURN insn, possibly a conditional one.  */\n \t  if (JUMP_LABEL (insn) != 0\n@@ -986,7 +973,7 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \t     CALL_INSN, which some machines, such as the ARC, can do, but\n \t     this is a very minor optimization.  */\n \t  if (this_is_condjump && ! this_is_simplejump\n-\t      && cse_not_expected && optimize > 0 && ! reload_completed\n+\t      && cse_not_expected && ! reload_completed\n \t      && BRANCH_COST > 2\n \t      && can_reverse_comparison_p (XEXP (SET_SRC (PATTERN (insn)), 0),\n \t\t\t\t\t   insn))\n@@ -2008,8 +1995,6 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n #endif\n \t  else\n \t    {\n-\t      /* Detect a jump to a jump.  */\n-\n \t      /* Look for   if (foo) bar; else break;  */\n \t      /* The insns look like this:\n \t\t insn = condjump label1;\n@@ -2300,7 +2285,7 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n      not be cleared.  This is especially true for the case where we\n      delete the NOTE_FUNCTION_END note.  CAN_REACH_END is cleared by\n      the front-end before compiling each function.  */\n-  if (calculate_can_reach_end (last_insn, 0, 1))\n+  if (calculate_can_reach_end (last_insn, optimize != 0))\n     can_reach_end = 1;\n \n end:\n@@ -2711,9 +2696,8 @@ delete_noop_moves (f)\n    if we find it.  */\n \n static int\n-calculate_can_reach_end (last, check_deleted, delete_final_note)\n+calculate_can_reach_end (last, delete_final_note)\n      rtx last;\n-     int check_deleted;\n      int delete_final_note;\n {\n   rtx insn = last;\n@@ -2751,9 +2735,7 @@ calculate_can_reach_end (last, check_deleted, delete_final_note)\n   /* See if we backed up to the appropriate type of note.  */\n   if (insn != NULL_RTX\n       && GET_CODE (insn) == NOTE\n-      && NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_END\n-      && (check_deleted == 0\n-\t  || ! INSN_DELETED_P (insn)))\n+      && NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_END)\n     {\n       if (delete_final_note)\n \tdelete_insn (insn);\n@@ -4320,8 +4302,7 @@ delete_insn (insn)\n \n   /* Don't delete user-declared labels.  Convert them to special NOTEs\n      instead.  */\n-  if (was_code_label && LABEL_NAME (insn) != 0\n-      && optimize && ! dont_really_delete)\n+  if (was_code_label && LABEL_NAME (insn) != 0 && ! dont_really_delete)\n     {\n       PUT_CODE (insn, NOTE);\n       NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED_LABEL;\n@@ -4347,7 +4328,7 @@ delete_insn (insn)\n \n   /* Patch out INSN (and the barrier if any) */\n \n-  if (optimize && ! dont_really_delete)\n+  if (! dont_really_delete)\n     {\n       if (prev)\n \t{"}, {"sha": "a8bb1e110960605bda2f7bb809db919351bcb4b9", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=d29c259b715bb5873c1b9ecf5af5ce06132a3377", "patch": "@@ -1110,7 +1110,8 @@ block_alloc (b)\n \n \t     If tying is done, WIN is set nonzero.  */\n \n-\t  if (recog_data.n_operands > 1\n+\t  if (optimize\n+\t      && recog_data.n_operands > 1\n \t      && recog_data.constraints[0][0] == '='\n \t      && recog_data.constraints[0][1] != '&')\n \t    {\n@@ -1194,7 +1195,8 @@ block_alloc (b)\n \t     destination register won't have had a quantity number\n \t     assigned, since that would prevent combining.  */\n \n-\t  if (GET_CODE (PATTERN (insn)) == CLOBBER\n+\t  if (optimize\n+\t      && GET_CODE (PATTERN (insn)) == CLOBBER\n \t      && (r0 = XEXP (PATTERN (insn), 0),\n \t\t  GET_CODE (r0) == REG)\n \t      && (link = find_reg_note (insn, REG_LIBCALL, NULL_RTX)) != 0"}, {"sha": "22ad556423c1ec788e55b184ff82f0a8e2547ecd", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=d29c259b715bb5873c1b9ecf5af5ce06132a3377", "patch": "@@ -1503,12 +1503,10 @@ extern void record_excess_regs\t\tPARAMS ((rtx, rtx, rtx *));\n extern void reposition_prologue_and_epilogue_notes\tPARAMS ((rtx));\n extern void thread_prologue_and_epilogue_insns\t\tPARAMS ((rtx));\n extern int prologue_epilogue_contains\t\t\tPARAMS ((rtx));\n-extern void use_variable\t\t\t\tPARAMS ((rtx));\n extern HOST_WIDE_INT get_frame_size\t\t\tPARAMS ((void));\n extern void preserve_rtl_expr_result\t\t\tPARAMS ((rtx));\n extern void mark_temp_addr_taken\t\t\tPARAMS ((rtx));\n extern void update_temp_slot_address\t\t\tPARAMS ((rtx, rtx));\n-extern void use_variable_after\t\t\t\tPARAMS ((rtx, rtx));\n extern void purge_addressof\t\t\t\tPARAMS ((rtx));\n \n /* In reload.c */\n@@ -1562,6 +1560,7 @@ extern void dump_global_regs\t\tPARAMS ((FILE *));\n #ifdef HARD_CONST\n extern void retry_global_alloc\t\tPARAMS ((int, HARD_REG_SET));\n #endif\n+extern void build_insn_chain\t\tPARAMS ((rtx));\n \n /* In regclass.c */\n extern int reg_classes_intersect_p\tPARAMS ((enum reg_class, enum reg_class));"}, {"sha": "865095361198734b7d7eae6f713c0b03e432584c", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=d29c259b715bb5873c1b9ecf5af5ce06132a3377", "patch": "@@ -2722,8 +2722,6 @@ expand_value_return (val)\n \temit_move_insn (return_reg, val);\n     }\n \n-  diddle_return_value (USE);\n-\n   /* Does any pending block have cleanups?  */\n \n   while (block && block->data.block.cleanups == 0)\n@@ -3689,14 +3687,6 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n     /* Get rid of the beginning-mark if we don't make an end-mark.  */\n     NOTE_LINE_NUMBER (thisblock->data.block.first_insn) = NOTE_INSN_DELETED;\n \n-  /* If doing stupid register allocation, make sure lives of all\n-     register variables declared here extend thru end of scope.  */\n-\n-  if (obey_regdecls)\n-    for (decl = vars; decl; decl = TREE_CHAIN (decl))\n-      if (TREE_CODE (decl) == VAR_DECL && DECL_RTL (decl))\n-\tuse_variable (DECL_RTL (decl));\n-\n   /* Restore the temporary level of TARGET_EXPRs.  */\n   target_temp_slot_level = thisblock->data.block.block_target_temp_slot_level;\n \n@@ -3757,7 +3747,7 @@ expand_decl (decl)\n \t\t&& TREE_CODE (type) == REAL_TYPE)\n \t   && ! TREE_THIS_VOLATILE (decl)\n \t   && ! TREE_ADDRESSABLE (decl)\n-\t   && (DECL_REGISTER (decl) || ! obey_regdecls)\n+\t   && (DECL_REGISTER (decl) || optimize)\n \t   /* if -fcheck-memory-usage, check all variables.  */\n \t   && ! current_function_check_memory_usage)\n     {\n@@ -3889,15 +3879,7 @@ expand_decl (decl)\n   if (TREE_READONLY (decl))\n     RTX_UNCHANGING_P (DECL_RTL (decl)) = 1;\n #endif\n-\n-  /* If doing stupid register allocation, make sure life of any\n-     register variable starts here, at the start of its scope.  */\n-\n-  if (obey_regdecls)\n-    use_variable (DECL_RTL (decl));\n }\n-\n-\n \f\n /* Emit code to perform the initialization of a declaration DECL.  */\n "}, {"sha": "6e36b49922bb7e7ac9f6059f875a6b6fb0e5f5c9", "filename": "gcc/stupid.c", "status": "removed", "additions": 0, "deletions": 761, "changes": 761, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/301e21af2c964ac3f7505d5bf9a45d2fe812ff29/gcc%2Fstupid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/301e21af2c964ac3f7505d5bf9a45d2fe812ff29/gcc%2Fstupid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstupid.c?ref=301e21af2c964ac3f7505d5bf9a45d2fe812ff29", "patch": "@@ -1,761 +0,0 @@\n-/* Dummy data flow analysis for GNU compiler in nonoptimizing mode.\n-   Copyright (C) 1987, 91, 94-96, 98, 99, 2000 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-/* This file performs stupid register allocation, which is used\n-   when cc1 gets the -noreg switch (which is when cc does not get -O).\n-\n-   Stupid register allocation goes in place of the flow_analysis,\n-   local_alloc and global_alloc passes.  combine_instructions cannot\n-   be done with stupid allocation because the data flow info that it needs\n-   is not computed here.\n-\n-   In stupid allocation, the only user-defined variables that can\n-   go in registers are those declared \"register\".  They are assumed\n-   to have a life span equal to their scope.  Other user variables\n-   are given stack slots in the rtl-generation pass and are not\n-   represented as pseudo regs.  A compiler-generated temporary\n-   is assumed to live from its first mention to its last mention.\n-\n-   Since each pseudo-reg's life span is just an interval, it can be\n-   represented as a pair of numbers, each of which identifies an insn by\n-   its position in the function (number of insns before it).  The first\n-   thing done for stupid allocation is to compute such a number for each\n-   insn.  It is called the suid.  Then the life-interval of each\n-   pseudo reg is computed.  Then the pseudo regs are ordered by priority\n-   and assigned hard regs in priority order.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-\n-#include \"rtl.h\"\n-#include \"hard-reg-set.h\"\n-#include \"basic-block.h\"\n-#include \"regs.h\"\n-#include \"function.h\"\n-#include \"insn-config.h\"\n-#include \"reload.h\"\n-#include \"flags.h\"\n-#include \"toplev.h\"\n-#include \"tm_p.h\"\n-\f\n-/* Vector mapping INSN_UIDs to suids.\n-   The suids are like uids but increase monotonically always.\n-   We use them to see whether a subroutine call came\n-   between a variable's birth and its death.  */\n-\n-static int *uid_suid;\n-\n-/* Get the suid of an insn.  */\n-\n-#define INSN_SUID(INSN) (uid_suid[INSN_UID (INSN)])\n-\n-/* Record the suid of the last CALL_INSN\n-   so we can tell whether a pseudo reg crosses any calls.  */\n-\n-static int last_call_suid;\n-\n-/* Record the suid of the last NOTE_INSN_SETJMP\n-   so we can tell whether a pseudo reg crosses any setjmp.  */\n-\n-static int last_setjmp_suid;\n-\n-/* Element N is suid of insn where life span of pseudo reg N ends.\n-   Element is  0 if register N has not been seen yet on backward scan.  */\n-\n-static int *reg_where_dead;\n-\n-/* Likewise, but point to the insn_chain structure of the insn at which\n-   the reg dies.  */\n-static struct insn_chain **reg_where_dead_chain;\n-\n-/* Element N is suid of insn where life span of pseudo reg N begins.  */\n-static int *reg_where_born_exact;\n-\n-/* Element N is 1 if the birth of pseudo reg N is due to a CLOBBER, \n-   0 otherwise.  */\n-static int *reg_where_born_clobber;\n-\n-/* Return the suid of the insn where the register is born, or the suid\n-   of the insn before if the birth is due to a CLOBBER.  */\n-#define REG_WHERE_BORN(N) \\\n-  (reg_where_born_exact[(N)] - reg_where_born_clobber[(N)])\n-\n-/* Numbers of pseudo-regs to be allocated, highest priority first.  */\n-\n-static int *reg_order;\n-\n-/* Indexed by reg number (hard or pseudo), nonzero if register is live\n-   at the current point in the instruction stream.  */\n-\n-static char *regs_live;\n-\n-/* Indexed by reg number, nonzero if reg was used in a SUBREG that changes\n-   its size.  */\n-\n-static char *regs_change_size;\n-\n-/* Indexed by reg number, nonzero if reg crosses a setjmp.  */\n-\n-static char *regs_crosses_setjmp;\n-\n-/* Indexed by insn's suid, the set of hard regs live after that insn.  */\n-\n-static HARD_REG_SET *after_insn_hard_regs;\n-\n-/* Record that hard reg REGNO is live after insn INSN.  */\n-\n-#define MARK_LIVE_AFTER(INSN,REGNO)  \\\n-  SET_HARD_REG_BIT (after_insn_hard_regs[INSN_SUID (INSN)], (REGNO))\n-\n-static int stupid_reg_compare\tPARAMS ((const PTR,const PTR));\n-static int stupid_find_reg\tPARAMS ((int, enum reg_class, enum machine_mode,\n-\t\t\t\t       int, int, int));\n-static void stupid_mark_refs\tPARAMS ((rtx, struct insn_chain *));\n-static void find_clobbered_regs\tPARAMS ((rtx, rtx, void *));\n-static void mark_hard_ref\tPARAMS ((rtx, int, struct insn_chain *));\n-\f\n-/* For communication between stupid_life_analysis and find_clobbered_regs.  */\n-static struct insn_chain *current_chain;\n-\n-/* This function, called via note_stores, marks any hard registers that are\n-   clobbered in an insn as being live in the live_throughout field\n-   of the appropriate insn_chain structure.  */\n-\n-static void\n-find_clobbered_regs (reg, setter, data)\n-     rtx reg, setter;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  int regno, nregs;\n-  if (setter == 0 || GET_CODE (setter) != CLOBBER)\n-    return;\n-\n-  if (GET_CODE (reg) == SUBREG)\n-    reg = SUBREG_REG (reg);\n-\n-  if (GET_CODE (reg) != REG)\n-    return;\n-  regno = REGNO (reg);\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    return;\n-\n-  if (GET_MODE (reg) == VOIDmode)\n-    abort ();\n-  else\n-    nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n-  while (nregs-- > 0)\n-    {\n-      SET_REGNO_REG_SET (&current_chain->live_throughout, regno++);\n-    }\n-}\n-\f\n-/* Stupid life analysis is for the case where only variables declared\n-   `register' go in registers.  For this case, we mark all\n-   pseudo-registers that belong to register variables as\n-   dying in the last instruction of the function, and all other\n-   pseudo registers as dying in the last place they are referenced.\n-   Hard registers are marked as dying in the last reference before\n-   the end or before each store into them.  */\n-\n-void\n-stupid_life_analysis (f, nregs, file)\n-     rtx f;\n-     int nregs;\n-     FILE *file;\n-{\n-  register int i;\n-  register rtx last, insn;\n-  int max_uid, max_suid;\n-\n-  current_function_has_computed_jump = 0;\n-\n-  bzero (regs_ever_live, sizeof regs_ever_live);\n-\n-  regs_live = (char *) xmalloc (nregs);\n-\n-  /* First find the last real insn, and count the number of insns,\n-     and assign insns their suids.  */\n-\n-  for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n-    if (INSN_UID (insn) > i)\n-      i = INSN_UID (insn);\n-\n-  max_uid = i + 1;\n-  uid_suid = (int *) xmalloc ((i + 1) * sizeof (int));\n-\n-  /* Compute the mapping from uids to suids.\n-     Suids are numbers assigned to insns, like uids,\n-     except that suids increase monotonically through the code.  */\n-\n-  last = 0;\t\t\t/* In case of empty function body */\n-  for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n-    {\n-      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n-\tlast = insn;\n-\n-      INSN_SUID (insn) = ++i;\n-    }\n-\n-  last_call_suid = i + 1;\n-  last_setjmp_suid = i + 1;\n-  max_suid = i + 1;\n-\n-  max_regno = nregs;\n-\n-  /* Allocate tables to record info about regs.  */\n-\n-  reg_where_dead = (int *) xcalloc (nregs, sizeof (int));\n-  reg_where_born_exact = (int *) xcalloc (nregs, sizeof (int));\n-  reg_where_born_clobber = (int *) xcalloc (nregs, sizeof (int));\n-  reg_where_dead_chain = (struct insn_chain **)\n-    xcalloc (nregs, sizeof (struct insn_chain *));\n-  reg_order = (int *) xcalloc (nregs, sizeof (int));\n-  regs_change_size = (char *) xcalloc (nregs, sizeof (char));\n-  regs_crosses_setjmp = (char *) xcalloc (nregs, sizeof (char));\n-\n-  /* Allocate the reg_renumber array */\n-  allocate_reg_info (max_regno, FALSE, TRUE);\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    reg_renumber[i] = i;\n-\n-  after_insn_hard_regs =\n-    (HARD_REG_SET *) xcalloc (max_suid, sizeof (HARD_REG_SET));\n-\n-  /* Allocate and zero out many data structures\n-     that will record the data from lifetime analysis.  */\n-\n-  allocate_reg_life_data ();\n-  allocate_bb_life_data ();\n-\n-  for (i = 0; i < max_regno; i++)\n-    REG_N_DEATHS (i) = 1;\n-\n-  bzero (regs_live, nregs);\n-\n-  /* Find where each pseudo register is born and dies,\n-     by scanning all insns from the end to the start\n-     and noting all mentions of the registers.\n-\n-     Also find where each hard register is live\n-     and record that info in after_insn_hard_regs.\n-     regs_live[I] is 1 if hard reg I is live\n-     at the current point in the scan.  \n-   \n-     Build reload_insn_chain while we're walking the insns.  */\n-\n-  reload_insn_chain = 0;\n-  for (insn = last; insn; insn = PREV_INSN (insn))\n-    {\n-      register HARD_REG_SET *p = after_insn_hard_regs + INSN_SUID (insn);\n-      struct insn_chain *chain = 0;\n-\n-      /* Copy the info in regs_live into the element of after_insn_hard_regs\n-\t for the current position in the rtl code.  */\n-\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\tif (regs_live[i])\n-\t  SET_HARD_REG_BIT (*p, i);\n-\n-      if (GET_CODE (insn) != NOTE && GET_CODE (insn) != BARRIER)\n-\t{\n-\t  chain = new_insn_chain ();\n-\t  if (reload_insn_chain)\n-\t    reload_insn_chain->prev = chain;\n-\t  chain->next = reload_insn_chain;\n-\t  chain->prev = 0;\n-\t  reload_insn_chain = chain;\n-\t  chain->block = 0;\n-\t  chain->insn = insn;\n-\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t    if (regs_live[i])\n-\t      SET_REGNO_REG_SET (&chain->live_throughout, i);\n-\t}\n-\n-      /* Update which hard regs are currently live\n-\t and also the birth and death suids of pseudo regs\n-\t based on the pattern of this insn.  */\n-\n-      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n-\tstupid_mark_refs (PATTERN (insn), chain);\n-\n-      if (GET_CODE (insn) == NOTE\n-\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)\n-\tlast_setjmp_suid = INSN_SUID (insn);\n-\n-      /* Mark all call-clobbered regs as dead after each call insn so that\n-\t a pseudo whose life span includes this insn will not go in one of\n-\t them.  If the function contains a non-local goto, mark all hard\n-\t registers dead (except for stack related bits).\n-\n-\t Then mark those regs as all dead for the continuing scan\n-\t of the insns before the call.  */\n-\n-      if (GET_CODE (insn) == CALL_INSN)\n-\t{\n-\t  last_call_suid = INSN_SUID (insn);\n-\n-\t  if (current_function_has_nonlocal_label)\n-\t    {\n-\t      IOR_COMPL_HARD_REG_SET (after_insn_hard_regs[last_call_suid],\n-\t\t\t\t      fixed_reg_set);\n-\t      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t\tif (! fixed_regs[i])\n-\t          regs_live[i] = 0;\n-\t    }\n-\t  else\n-\t    {\n-\t      IOR_HARD_REG_SET (after_insn_hard_regs[last_call_suid],\n-\t\t\t\tcall_used_reg_set);\n-\t      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t        if (call_used_regs[i])\n-\t          regs_live[i] = 0;\n-\t    }\n-\n-\t  /* It is important that this be done after processing the insn's\n-\t     pattern because we want the function result register to still\n-\t     be live if it's also used to pass arguments.  */\n-\t  stupid_mark_refs (CALL_INSN_FUNCTION_USAGE (insn), chain);\n-\t}\n-\n-      if (GET_CODE (insn) != NOTE && GET_CODE (insn) != BARRIER)\n-\t{\t  \n-\t  /* The regs_live array doesn't say anything about hard registers\n-\t     clobbered by this insn.  So we need an extra pass over the\n-\t     pattern.  */\n-\t  current_chain = chain;\n-\t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n-\t    note_stores (PATTERN (insn), find_clobbered_regs, NULL);\n-\t}\n-\n-      if (GET_CODE (insn) == JUMP_INSN && computed_jump_p (insn))\n-\tcurrent_function_has_computed_jump = 1;\n-    }\n-\n-  /* Now decide the order in which to allocate the pseudo registers.  */\n-\n-  for (i = LAST_VIRTUAL_REGISTER + 1; i < max_regno; i++)\n-    reg_order[i] = i;\n-\n-  qsort (&reg_order[LAST_VIRTUAL_REGISTER + 1],\n-\t max_regno - LAST_VIRTUAL_REGISTER - 1, sizeof (int),\n-\t stupid_reg_compare);\n-\n-  /* Now, in that order, try to find hard registers for those pseudo regs.  */\n-\n-  for (i = LAST_VIRTUAL_REGISTER + 1; i < max_regno; i++)\n-    {\n-      register int r = reg_order[i];\n-\n-      /* Some regnos disappear from the rtl.  Ignore them to avoid crash. \n-\t Also don't allocate registers that cross a setjmp, or live across\n-\t a call if this function receives a nonlocal goto.\n-\t Also ignore registers we didn't see during the scan.  */\n-      if (regno_reg_rtx[r] == 0 || regs_crosses_setjmp[r]\n-\t  || (reg_where_born_exact[r] == 0 && reg_where_dead[r] == 0)\n-\t  || (REG_N_CALLS_CROSSED (r) > 0 \n-\t      && current_function_has_nonlocal_label))\n-\tcontinue;\n-\n-      /* Now find the best hard-register class for this pseudo register */\n-      if (N_REG_CLASSES > 1)\n-\treg_renumber[r] = stupid_find_reg (REG_N_CALLS_CROSSED (r), \n-\t\t\t\t\t   reg_preferred_class (r),\n-\t\t\t\t\t   PSEUDO_REGNO_MODE (r),\n-\t\t\t\t\t   REG_WHERE_BORN (r),\n-\t\t\t\t\t   reg_where_dead[r],\n-\t\t\t\t\t   regs_change_size[r]);\n-\n-      /* If no reg available in that class, try alternate class.  */\n-      if (reg_renumber[r] == -1 && reg_alternate_class (r) != NO_REGS)\n-\treg_renumber[r] = stupid_find_reg (REG_N_CALLS_CROSSED (r),\n-\t\t\t\t\t   reg_alternate_class (r),\n-\t\t\t\t\t   PSEUDO_REGNO_MODE (r),\n-\t\t\t\t\t   REG_WHERE_BORN (r),\n-\t\t\t\t\t   reg_where_dead[r],\n-\t\t\t\t\t   regs_change_size[r]);\n-    }\n-\n-  /* Fill in the pseudo reg life information into the insn chain.  */\n-  for (i = LAST_VIRTUAL_REGISTER + 1; i < max_regno; i++)\n-    {\n-      struct insn_chain *chain;\n-      int regno;\n-\n-      regno = reg_renumber[i];\n-      if (regno < 0)\n-\tcontinue;\n-\n-      chain = reg_where_dead_chain[i];\n-      SET_REGNO_REG_SET (&chain->dead_or_set, i);\n-\n-      while ((chain = chain->prev)\n-\t     && INSN_SUID (chain->insn) > reg_where_born_exact[i])\n-\tSET_REGNO_REG_SET (&chain->live_throughout, i);\n-\n-      if (chain)\n-\tSET_REGNO_REG_SET (&chain->dead_or_set, i);\n-    }\n-\n-  if (file)\n-    dump_flow_info (file);\n-\n-  free (regs_live);\n-  free (uid_suid);\n-  free (reg_where_dead);\n-  free (reg_where_born_exact);\n-  free (reg_where_born_clobber);\n-  free (reg_where_dead_chain);\n-  free (reg_order);\n-  free (regs_change_size);\n-  free (regs_crosses_setjmp);\n-  free (after_insn_hard_regs);\n-}\n-\n-/* Comparison function for qsort.\n-   Returns -1 (1) if register *R1P is higher priority than *R2P.  */\n-\n-static int\n-stupid_reg_compare (r1p, r2p)\n-     const PTR r1p;\n-     const PTR r2p;\n-{\n-  register int r1 = *(const int *)r1p, r2 = *(const int *)r2p;\n-  register int len1 = reg_where_dead[r1] - REG_WHERE_BORN (r1);\n-  register int len2 = reg_where_dead[r2] - REG_WHERE_BORN (r2);\n-  int tem;\n-\n-  tem = len2 - len1;\n-  if (tem != 0)\n-    return tem;\n-\n-  tem = REG_N_REFS (r1) - REG_N_REFS (r2);\n-  if (tem != 0)\n-    return tem;\n-\n-  /* If regs are equally good, sort by regno,\n-     so that the results of qsort leave nothing to chance.  */\n-  return r1 - r2;\n-}\n-\f\n-/* Find a block of SIZE words of hard registers in reg_class CLASS\n-   that can hold a value of machine-mode MODE\n-     (but actually we test only the first of the block for holding MODE)\n-   currently free from after insn whose suid is BORN_INSN\n-   through the insn whose suid is DEAD_INSN,\n-   and return the number of the first of them.\n-   Return -1 if such a block cannot be found.\n-\n-   If CALL_PRESERVED is nonzero, insist on registers preserved\n-   over subroutine calls, and return -1 if cannot find such.\n-\n-   If CHANGES_SIZE is nonzero, it means this register was used as the\n-   operand of a SUBREG that changes its size.  */\n-\n-static int\n-stupid_find_reg (call_preserved, class, mode,\n-\t\t born_insn, dead_insn, changes_size)\n-     int call_preserved;\n-     enum reg_class class;\n-     enum machine_mode mode;\n-     int born_insn, dead_insn;\n-     int changes_size ATTRIBUTE_UNUSED;\n-{\n-  register int i, ins;\n-#ifdef HARD_REG_SET\n-  register\t\t/* Declare them register if they are scalars.  */\n-#endif\n-    HARD_REG_SET used, this_reg;\n-#ifdef ELIMINABLE_REGS\n-  static struct {int from, to; } eliminables[] = ELIMINABLE_REGS;\n-#endif\n-\n-  /* If this register's life is more than 5,000 insns, we probably\n-     can't allocate it, so don't waste the time trying.  This avoids\n-     quadratic behavior on programs that have regularly-occurring\n-     SAVE_EXPRs.  */\n-  if (dead_insn > born_insn + 5000)\n-    return -1;\n-\n-  COPY_HARD_REG_SET (used,\n-\t\t     call_preserved ? call_used_reg_set : fixed_reg_set);\n-\n-#ifdef ELIMINABLE_REGS\n-  for (i = 0; i < (int)(sizeof eliminables / sizeof eliminables[0]); i++)\n-    SET_HARD_REG_BIT (used, eliminables[i].from);\n-#if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-  SET_HARD_REG_BIT (used, HARD_FRAME_POINTER_REGNUM);\n-#endif\n-#else\n-  SET_HARD_REG_BIT (used, FRAME_POINTER_REGNUM);\n-#endif\n-\n-  for (ins = born_insn; ins < dead_insn; ins++)\n-    IOR_HARD_REG_SET (used, after_insn_hard_regs[ins]);\n-\n-#ifdef STACK_REGS\n-  if (current_function_has_computed_jump)\n-    for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n-      SET_HARD_REG_BIT (used, i);\n-#endif\n-  \n-  IOR_COMPL_HARD_REG_SET (used, reg_class_contents[(int) class]);\n-\n-#ifdef CLASS_CANNOT_CHANGE_SIZE\n-  if (changes_size)\n-    IOR_HARD_REG_SET (used,\n-\t\t      reg_class_contents[(int) CLASS_CANNOT_CHANGE_SIZE]);\n-#endif\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-#ifdef REG_ALLOC_ORDER\n-      int regno = reg_alloc_order[i];\n-#else\n-      int regno = i;\n-#endif\n-\n-      if (! TEST_HARD_REG_BIT (used, regno)\n-\t  && HARD_REGNO_MODE_OK (regno, mode))\n-\t{\n-\t  register int j;\n-\t  register int size1 = HARD_REGNO_NREGS (regno, mode);\n-\t  for (j = 1; j < size1 && ! TEST_HARD_REG_BIT (used, regno + j); j++);\n-\t  if (j == size1)\n-\t    {\n-\t      CLEAR_HARD_REG_SET (this_reg);\n-\t      while (--j >= 0)\n-\t\tSET_HARD_REG_BIT (this_reg, regno + j);\n-\t      for (ins = born_insn; ins < dead_insn; ins++)\n-\t\t{\n-\t\t  IOR_HARD_REG_SET (after_insn_hard_regs[ins], this_reg);\n-\t\t}\n-\t      return regno;\n-\t    }\n-#ifndef REG_ALLOC_ORDER\n-\t  i += j;\t\t/* Skip starting points we know will lose */\n-#endif\n-\t}\n-    }\n-\n-  return -1;\n-}\n-\f\n-/* Note that REG is being set or referenced, and add the appropriate\n-   REG_DEAD / REG_UNUSED note(s).  For sets, LIVE_BEFORE_P will be 0,\n-   while for references, LIVE_BEFORE_P will be 1.\n-   INSN is the instruction that the reg notes have to be added to.  */\n-static void\n-mark_hard_ref (reg, live_before_p, chain)\n-     rtx reg;\n-     int live_before_p;\n-     struct insn_chain *chain;\n-{\n-  /* Hard reg: mark it live for continuing scan of previous insns.  */\n-  int regno = REGNO (reg);\n-  char *live = regs_live;\n-  register int j;\n-  int nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n-\n-  for (j = nregs - 1; j >= 0; j--)\n-    {\n-      if (! fixed_regs[regno+j]\n-\t  && (! live_before_p || ! live[regno+j]))\n-\tSET_REGNO_REG_SET (&chain->dead_or_set, regno+j);\n-      regs_ever_live[regno+j] = 1;\n-      live[regno+j] = live_before_p;\n-    }\n-}\n-\n-/* Walk X, noting all assignments and references to registers\n-   and recording what they imply about life spans.\n-   INSN is the current insn, supplied so we can find its suid.  */\n-\n-static void\n-stupid_mark_refs (x, chain)\n-     rtx x;\n-     struct insn_chain *chain;\n-{\n-  register RTX_CODE code;\n-  register const char *fmt;\n-  register int regno, i;\n-  rtx insn = chain->insn;\n-\n-  if (x == 0)\n-    return;\n-\n-  code = GET_CODE (x);\n-\n-  if (code == SET || code == CLOBBER)\n-    {\n-      if (SET_DEST (x) != 0\n-\t  && (GET_CODE (SET_DEST (x)) == REG\n-\t      || (GET_CODE (SET_DEST (x)) == SUBREG\n-\t\t  && GET_CODE (SUBREG_REG (SET_DEST (x))) == REG\n-\t\t  && (REGNO (SUBREG_REG (SET_DEST (x)))\n-\t\t      >= FIRST_PSEUDO_REGISTER))))\n-\t{\n-\t  /* Register is being assigned.  */\n-\t  rtx reg = SET_DEST (x);\n-\n-\t  /* If setting a SUBREG, we treat the entire reg as being set.  */\n-\t  if (GET_CODE (SET_DEST (x)) == SUBREG)\n-\t    reg = SUBREG_REG (reg);\n-\n-\t  regno = REGNO (reg);\n-\n-\t  /* For hard regs, update the where-live info.  */\n-\t  if (regno < FIRST_PSEUDO_REGISTER)\n-\t    {\n-\t      register int j\n-\t\t= HARD_REGNO_NREGS (regno, GET_MODE (SET_DEST (x)));\n-\n-\t      mark_hard_ref (reg, 0, chain);\n-\n-\t      while (--j >= 0)\n-\t\t{\n-\t\t  /* The following line is for unused outputs;\n-\t\t     they do get stored even though never used again.  */\n-\t\t  MARK_LIVE_AFTER (insn, regno+j);\n-\n-\t\t  CLEAR_REGNO_REG_SET (&chain->live_throughout, regno + j);\n-\n-\t\t  /* When a hard reg is clobbered, mark it in use\n-\t\t     just before this insn, so it is live all through.  */\n-\t\t  if (code == CLOBBER && INSN_SUID (insn) > 0)\n-\t\t    SET_HARD_REG_BIT (after_insn_hard_regs[INSN_SUID (insn) - 1],\n-\t\t\t\t      regno+j);\n-\t\t}\n-\t    }\n-\t  /* For pseudo regs, record where born, where dead, number of\n-\t     times used, and whether live across a call.  */\n-\t  else\n-\t    {\n-\t      /* Update the life-interval bounds of this pseudo reg.  */\n-\n-\t      /* When a pseudo-reg is CLOBBERed, it is born just before\n-\t\t the clobbering insn.  When setting, just after.  */\n-\t      int where_born = INSN_SUID (insn) - (code == CLOBBER);\n-\n-\t      reg_where_born_exact[regno] = INSN_SUID (insn);\n-\t      reg_where_born_clobber[regno] = (code == CLOBBER);\n-\n-\t      if (reg_where_dead_chain[regno] == 0)\n-\t\treg_where_dead_chain[regno] = chain;\n-\n-\t      /* The reg must live at least one insn even\n-\t\t in it is never again used--because it has to go\n-\t\t in SOME hard reg.  Mark it as dying after the current\n-\t\t insn so that it will conflict with any other outputs of\n-\t\t this insn.  */\n-\t      if (reg_where_dead[regno] < where_born + 2)\n-\t\t{\n-\t\t  reg_where_dead[regno] = where_born + 2;\n-\t\t  regs_live[regno] = 1;\n-\t\t}\n-\n-\t      /* Count the refs of this reg.  */\n-\t      REG_N_REFS (regno)++;\n-\n-\t      if (last_call_suid < reg_where_dead[regno])\n-\t\tREG_N_CALLS_CROSSED (regno) += 1;\n-\n-\t      if (last_setjmp_suid < reg_where_dead[regno])\n-\t\tregs_crosses_setjmp[regno] = 1;\n-\n-\t      /* If this register is clobbered or it is only used in\n-\t\t this insn and is only set, mark it unused.  We have\n-\t\t to do this even when not optimizing so that MD patterns\n-\t\t which count on this behavior (e.g., it not causing an\n-\t\t output reload on an insn setting CC) will operate\n-\t\t correctly.  */\n-\t      if (GET_CODE (SET_DEST (x)) == REG\n-\t\t  && (code == CLOBBER\n-\t\t      || (REGNO_FIRST_UID (regno) == INSN_UID (insn)\n-\t\t\t  && REGNO_LAST_UID (regno) == INSN_UID (insn)\n-\t\t\t  && ! reg_mentioned_p (SET_DEST (x),\n-\t\t\t\t\t\tSET_SRC (x)))))\n-\t\tREG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_UNUSED,\n-\t\t\t\t\t\t      SET_DEST (x),\n-\t\t\t\t\t\t      REG_NOTES (insn));\n-\t    }\n-\t}\n-\n-      /* Record references from the value being set,\n-\t or from addresses in the place being set if that's not a reg.\n-\t If setting a SUBREG, we treat the entire reg as *used*.  */\n-      if (code == SET)\n-\t{\n-\t  stupid_mark_refs (SET_SRC (x), chain);\n-\t  if (GET_CODE (SET_DEST (x)) != REG)\n-\t    stupid_mark_refs (SET_DEST (x), chain);\n-\t}\n-      return;\n-    }\n-\n-  else if (code == SUBREG\n-\t   && GET_CODE (SUBREG_REG (x)) == REG\n-\t   && REGNO (SUBREG_REG (x)) >= FIRST_PSEUDO_REGISTER\n-\t   && (GET_MODE_SIZE (GET_MODE (x))\n-\t       != GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n-\t   && (INTEGRAL_MODE_P (GET_MODE (x))\n-\t       || INTEGRAL_MODE_P (GET_MODE (SUBREG_REG (x)))))\n-    regs_change_size[REGNO (SUBREG_REG (x))] = 1;\n-\n-  /* Register value being used, not set.  */\n-\n-  else if (code == REG)\n-    {\n-      regno = REGNO (x);\n-      if (regno < FIRST_PSEUDO_REGISTER)\n-\t/* Hard reg: mark it live for continuing scan of previous insns.  */\n-\tmark_hard_ref (x, 1, chain);\n-      else\n-\t{\n-\t  /* Pseudo reg: record first use, last use and number of uses.  */\n-\n-\t  reg_where_born_exact[regno] = INSN_SUID (insn);\n-\t  reg_where_born_clobber[regno] = 0;\n-\t  REG_N_REFS (regno)++;\n-\t  if (regs_live[regno] == 0)\n-\t    {\n-\t      regs_live[regno] = 1;\n-\t      reg_where_dead[regno] = INSN_SUID (insn);\n-\t      reg_where_dead_chain[regno] = chain;\n-\t    }\n-\t}\n-      return;\n-    }\n-\n-  /* Recursive scan of all other rtx's.  */\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\tstupid_mark_refs (XEXP (x, i), chain);\n-      else if (fmt[i] == 'E')\n-\t{\n-\t  register int j;\n-\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t    stupid_mark_refs (XVECEXP (x, i, j), chain);\n-\t}\n-    }\n-}"}, {"sha": "c77ea7a53131803ac30bae3146e4ff44136fafd3", "filename": "gcc/toplev.c", "status": "modified", "additions": 34, "deletions": 64, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29c259b715bb5873c1b9ecf5af5ce06132a3377/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=d29c259b715bb5873c1b9ecf5af5ce06132a3377", "patch": "@@ -362,11 +362,6 @@ int pedantic = 0;\n \n int in_system_header = 0;\n \n-/* Nonzero means do stupid register allocation.\n-   Currently, this is 1 if `optimize' is 0.  */\n-\n-int obey_regdecls = 0;\n-\n /* Don't print functions as they are compiled and don't print\n    times taken by the various passes.  -quiet.  */\n \n@@ -3207,13 +3202,6 @@ rest_of_compilation (decl)\n \tggc_collect ();\n     }\n \n-  /* Now we choose between stupid (pcc-like) register allocation\n-     (if we got the -noreg switch and not -opt)\n-     and smart register allocation.  */\n-\n-  if (optimize > 0)\t\t/* Stupid allocation probably won't work */\n-    obey_regdecls = 0;\t\t/* if optimizations being done.  */\n-\n   regclass_init ();\n \n   /* Print function header into flow dump now\n@@ -3222,34 +3210,23 @@ rest_of_compilation (decl)\n   if (flow_dump)\n     open_dump_file (\".08.flow\", decl_printable_name (decl, 2));\n   \n-  if (obey_regdecls)\n-    {\n-      TIMEVAR (flow_time,\n-\t       {\n-\t\t regclass (insns, max_reg_num (), NULL);\n-\t\t stupid_life_analysis (insns, max_reg_num (),\n-\t\t\t\t       rtl_dump_file);\n-\t       });\n-    }\n-  else\n-    {\n-      /* Do control and data flow analysis,\n-\t and write some of the results to dump file.  */\n+  /* Do control and data flow analysis; wrote some of the results to\n+     the dump file.  */\n \n-      TIMEVAR\n-\t(flow_time,\n-\t {\n-\t   find_basic_blocks (insns, max_reg_num (), rtl_dump_file, 1);\n-\t   calculate_loop_depth (rtl_dump_file);\n-\t   life_analysis (insns, max_reg_num (), rtl_dump_file, 1);\n-\t });\n+  TIMEVAR\n+    (flow_time,\n+     {\n+       find_basic_blocks (insns, max_reg_num (), rtl_dump_file, 1);\n+       if (optimize)\n+\t calculate_loop_depth (rtl_dump_file);\n+       life_analysis (insns, max_reg_num (), rtl_dump_file, 1);\n+     });\n \n-      if (warn_uninitialized || extra_warnings)\n-\t{\n-\t  uninitialized_vars_warning (DECL_INITIAL (decl));\n-          if (extra_warnings)\n-\t    setjmp_args_warning ();\n-\t}\n+  if (warn_uninitialized || extra_warnings)\n+    {\n+      uninitialized_vars_warning (DECL_INITIAL (decl));\n+      if (extra_warnings)\n+\tsetjmp_args_warning ();\n     }\n \n   /* Dump rtl after flow analysis.  */\n@@ -3344,24 +3321,20 @@ rest_of_compilation (decl)\n   if (local_reg_dump)\n     open_dump_file (\".12.lreg\", decl_printable_name (decl, 2));\n \n-  /* Unless we did stupid register allocation,\n-     allocate pseudo-regs that are used only within 1 basic block. \n+  /* Allocate pseudo-regs that are used only within 1 basic block. \n \n      RUN_JUMP_AFTER_RELOAD records whether or not we need to rerun the\n      jump optimizer after register allocation and reloading are finished.  */\n \n-  if (!obey_regdecls)\n-    TIMEVAR (local_alloc_time,\n-\t     {\n-\t       /* We recomputed reg usage as part of updating the rest\n-\t\t  of life info during sched.  */\n-\t       if (! flag_schedule_insns)\n-\t\t recompute_reg_usage (insns, ! optimize_size);\n-\t       regclass (insns, max_reg_num (), rtl_dump_file);\n-\t       rebuild_label_notes_after_reload = local_alloc ();\n-\t     });\n-  else\n-    rebuild_label_notes_after_reload = 0;\n+  TIMEVAR (local_alloc_time,\n+\t   {\n+\t     /* We recomputed reg usage as part of updating the rest\n+\t\tof life info during sched.  */\n+\t     if (! flag_schedule_insns)\n+\t       recompute_reg_usage (insns, ! optimize_size);\n+\t     regclass (insns, max_reg_num (), rtl_dump_file);\n+\t     rebuild_label_notes_after_reload = local_alloc ();\n+\t   });\n \n   /* Dump rtl code after allocating regs within basic blocks.  */\n \n@@ -3381,19 +3354,20 @@ rest_of_compilation (decl)\n   if (global_reg_dump)\n     open_dump_file (\".13.greg\", decl_printable_name (decl, 2));\n \n-  /* Unless we did stupid register allocation,\n-     allocate remaining pseudo-regs, then do the reload pass\n-     fixing up any insns that are invalid.  */\n+  /* If optimizing, allocate remaining pseudo-regs.  Do the reload\n+     pass fixing up any insns that are invalid.  */\n \n   TIMEVAR (global_alloc_time,\n \t   {\n-\t     if (!obey_regdecls)\n+\t     if (optimize)\n \t       failure = global_alloc (rtl_dump_file);\n \t     else\n-\t       failure = reload (insns, 0, rtl_dump_file);\n+\t       {\n+\t\t build_insn_chain (insns);\n+\t\t failure = reload (insns, 0, rtl_dump_file);\n+\t       }\n \t   });\n \n-\n   if (failure)\n     goto exit_rest_of_compilation;\n \n@@ -3507,10 +3481,8 @@ rest_of_compilation (decl)\n     = optimize > 0 && only_leaf_regs_used () && leaf_function_p ();\n #endif\n \n-  /* One more attempt to remove jumps to .+1\n-     left by dead-store-elimination.\n-     Also do cross-jumping this time\n-     and delete no-op move insns.  */\n+  /* One more attempt to remove jumps to .+1 left by dead-store elimination. \n+     Also do cross-jumping this time and delete no-op move insns.  */\n \n   if (optimize > 0)\n     {\n@@ -4573,8 +4545,6 @@ main (argc, argv)\n \t}\n     }\n \n-  obey_regdecls = (optimize == 0);\n-\n   if (optimize >= 1)\n     {\n       flag_defer_pop = 1;"}]}