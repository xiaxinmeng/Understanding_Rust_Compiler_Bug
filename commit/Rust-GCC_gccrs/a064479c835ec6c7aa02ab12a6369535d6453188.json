{"sha": "a064479c835ec6c7aa02ab12a6369535d6453188", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA2NDQ3OWM4MzVlYzZjN2FhMDJhYjEyYTYzNjk1MzVkNjQ1MzE4OA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-07-06T17:08:42Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-07-06T17:08:42Z"}, "message": "vec.h (VEC_embedded_alloc): Remove.\n\n\t* vec.h (VEC_embedded_alloc): Remove.\n\t(VEC_embedded_size, VEC_embedded_init): New.\n\t(VEC_alloc, VEC_reserve, VEC_safe_push, VEC_safe_insert): Add\n\tMEM_STAT_INFO.\n\t(VEC_truncate): New.\n\t(vec_p_reserve, vec_o_reserve): Add MEM_STAT_DECL.\n\t(vec_embedded_alloc): Remove.\n\t* vec.c (vec_p_reserve, vec_o_reserve): Add MEM_STAT_DECL, adjust.\n\t(vec_embedded_alloc): Remove.\n\nFrom-SVN: r84159", "tree": {"sha": "2a4815255fa1826a8c800c509c09b3d8a467970b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a4815255fa1826a8c800c509c09b3d8a467970b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a064479c835ec6c7aa02ab12a6369535d6453188", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a064479c835ec6c7aa02ab12a6369535d6453188", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a064479c835ec6c7aa02ab12a6369535d6453188", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a064479c835ec6c7aa02ab12a6369535d6453188/comments", "author": null, "committer": null, "parents": [{"sha": "9bc813131482755edb213ddb5308c15f123c81c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bc813131482755edb213ddb5308c15f123c81c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bc813131482755edb213ddb5308c15f123c81c0"}], "stats": {"total": 171, "additions": 101, "deletions": 70}, "files": [{"sha": "9c65170f8bc743b7c5b37e62e888c5a3ef479826", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a064479c835ec6c7aa02ab12a6369535d6453188/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a064479c835ec6c7aa02ab12a6369535d6453188/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a064479c835ec6c7aa02ab12a6369535d6453188", "patch": "@@ -1,3 +1,15 @@\n+2004-07-06  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* vec.h (VEC_embedded_alloc): Remove.\n+\t(VEC_embedded_size, VEC_embedded_init): New.\n+\t(VEC_alloc, VEC_reserve, VEC_safe_push, VEC_safe_insert): Add\n+\tMEM_STAT_INFO.\n+\t(VEC_truncate): New.\n+\t(vec_p_reserve, vec_o_reserve): Add MEM_STAT_DECL.\n+\t(vec_embedded_alloc): Remove.\n+\t* vec.c (vec_p_reserve, vec_o_reserve): Add MEM_STAT_DECL, adjust.\n+\t(vec_embedded_alloc): Remove.\n+\n 2004-07-06  Mark Mitchell  <mark@codesourcery.com>\n \n \t* Makefile.in (langhooks.o): Do not depend on gt-langhooks.h."}, {"sha": "01faf52bd78aeedf2e64499b5e64a7ccd28ce9a4", "filename": "gcc/vec.c", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a064479c835ec6c7aa02ab12a6369535d6453188/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a064479c835ec6c7aa02ab12a6369535d6453188/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=a064479c835ec6c7aa02ab12a6369535d6453188", "patch": "@@ -39,10 +39,11 @@ struct vec_prefix\n    exponentially.  VEC can be NULL, to create a new vector.  */\n \n void *\n-vec_p_reserve (void *vec, size_t reserve)\n+vec_p_reserve (void *vec, size_t reserve MEM_STAT_DECL)\n {\n   return vec_o_reserve (vec, reserve,\n-\t\t\toffsetof (struct vec_prefix, vec), sizeof (void *));\n+\t\t\toffsetof (struct vec_prefix, vec), sizeof (void *)\n+\t\t\tPASS_MEM_STAT);\n }\n \n /* Ensure there are at least RESERVE free slots in VEC, if RESERVE !=\n@@ -52,7 +53,8 @@ vec_p_reserve (void *vec, size_t reserve)\n    consistes of ELT_SIZE sized elements.  */\n \n void *\n-vec_o_reserve (void *vec, size_t reserve, size_t vec_offset, size_t elt_size)\n+vec_o_reserve (void *vec, size_t reserve, size_t vec_offset, size_t elt_size\n+\t       MEM_STAT_DECL)\n {\n   struct vec_prefix *pfx = vec;\n   size_t alloc;\n@@ -64,7 +66,8 @@ vec_o_reserve (void *vec, size_t reserve, size_t vec_offset, size_t elt_size)\n   \n   if (!pfx || pfx->alloc < alloc)\n     {\n-      vec = ggc_realloc (vec, vec_offset + alloc * elt_size);\n+      vec = ggc_realloc_stat (vec, vec_offset + alloc * elt_size\n+\t\t\t      PASS_MEM_STAT);\n       ((struct vec_prefix *)vec)->alloc = alloc;\n       if (!pfx)\n \t((struct vec_prefix *)vec)->num = 0;\n@@ -73,23 +76,6 @@ vec_o_reserve (void *vec, size_t reserve, size_t vec_offset, size_t elt_size)\n   return vec;\n }\n \n-/* Allocate a structure which contains a vector as a trailing element.\n-   The vector is at STRUCT_OFFSET offset within the struct and the\n-   vector's array is at VEC_OFFSET offset within the vector.  */\n-\n-void *\n-vec_embedded_alloc (size_t struct_offset, size_t vec_offset,\n-\t\t    size_t elt_size, size_t reserve)\n-{\n-  void *ptr = ggc_alloc (struct_offset + vec_offset + elt_size * reserve);\n-  struct vec_prefix *pfx = (struct vec_prefix *)((char *)ptr + struct_offset);\n-\n-  pfx->num = 0;\n-  pfx->alloc = reserve;\n-\n-  return ptr;\n-}\n-\n #if ENABLE_CHECKING\n /* Issue a vector domain error, and then fall over.  */\n "}, {"sha": "2e0ab8e0bf85ed0b73d7ac740b3d7d31b3d77743", "filename": "gcc/vec.h", "status": "modified", "additions": 82, "deletions": 49, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a064479c835ec6c7aa02ab12a6369535d6453188/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a064479c835ec6c7aa02ab12a6369535d6453188/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=a064479c835ec6c7aa02ab12a6369535d6453188", "patch": "@@ -44,12 +44,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    object itself.  This means you cannot have variables or fields of\n    vector type -- always use a pointer to a vector.  The one exception\n    is the final field of a structure, which could be a vector type.\n-   You will have to use the embedded_alloc call to create such\n-   objects, and they will probably not be resizeable (so don't use the\n-   'safe' allocation variants).  The trailing array idiom is used\n-   (rather than a pointer to an array of data), because, if we allow\n-   NULL to also represent an empty vector, empty vectors occupy\n-   minimal space in the structure containing them.\n+   You will have to use the embedded_size & embedded_init calls to\n+   create such objects, and they will probably not be resizeable (so\n+   don't use the 'safe' allocation variants).  The trailing array\n+   idiom is used (rather than a pointer to an array of data), because,\n+   if we allow NULL to also represent an empty vector, empty vectors\n+   occupy minimal space in the structure containing them.\n \n    Each operation that increases the number of active elements is\n    available in 'quick' and 'safe' variants.  The former presumes that\n@@ -61,7 +61,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    elements with the 'quick' operation.\n \n    You should prefer the push and pop operations, as they append and\n-   remove from the end of the vector.  The insert and remove\n+   remove from the end of the vector. If you need to remove several\n+   items in one go, use the truncate operation.  The insert and remove\n    operations allow you to change elements in the middle of the\n    vector.  There are two remove operations, one which preserves the\n    element ordering 'ordered_remove', and one which does not\n@@ -134,23 +135,24 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    VEC(T) *VEC_T_alloc(size_t reserve);\n \n    Allocate a new vector with space for RESERVE objects.  */\n-#define VEC_alloc(TDEF,A)\t\t(VEC_OP(TDEF,alloc)(A))\n+#define VEC_alloc(TDEF,A)\t\t(VEC_OP(TDEF,alloc)(A MEM_STAT_INFO))\n \n-/* Allocate new vector offset within a structure\n-   void *VEC_T_embedded_alloc(size_t offset, size_t reserve);\n-\n-   Allocate a new vector which is at offset OFFSET within a structure,\n-   and with space for RESERVE objects.  Return a pointer to the start\n-   of the structure containing the vector.  Naturally, the vector must\n-   be the last member of the structure.  */\n-#define VEC_embedded_alloc(TDEF,O,A)\t(VEC_OP(TDEF,embedded_alloc)(O,A))\n+/* Use these to determine the required size and initialization of a\n+   vector embedded within another structure (as the final member).\n+   \n+   size_t VEC_T_embedded_size(size_t reserve);\n+   void VEC_T_embedded_init(VEC(T) *v, size_t reserve);\n+   \n+   These allow the caller to perform the memory allocation.  */\n+#define VEC_embedded_size(TDEF,A) (VEC_OP(TDEF,embedded_size)(A))\n+#define VEC_embedded_init(TDEF,O,A) (VEC_OP(TDEF,embedded_init)(O,A))\n \n /* Reserve space.\n    void VEC_T_reserve(VEC(T) *&v, size_t reserve);\n \n    Ensure that V has at least RESERVE slots available.  Note this can\n    cause V to be reallocated.  */\n-#define VEC_reserve(TDEF,V,R)\t\t(VEC_OP(TDEF,reserve)(&(V),R))\n+#define VEC_reserve(TDEF,V,R)\t\t(VEC_OP(TDEF,reserve)(&(V),R MEM_STAT_INFO))\n \n /* Push object with no reallocation\n    T *VEC_T_quick_push (VEC(T) *v, T obj); // Pointer\n@@ -169,7 +171,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    Push a new element onto the end, returns a pointer to the slot\n    filled in. For object vectors, the new value can be NULL, in which\n    case NO initialization is performed.  Reallocates V, if needed.  */\n-#define VEC_safe_push(TDEF,V,O)\t\t(VEC_OP(TDEF,safe_push)(&(V),O))\n+#define VEC_safe_push(TDEF,V,O)\t\t(VEC_OP(TDEF,safe_push)(&(V),O MEM_STAT_INFO))\n \n /* Pop element off end\n    T VEC_T_pop (VEC(T) *v);\t\t// Pointer\n@@ -179,6 +181,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    pointer vectors.  */\n #define VEC_pop(TDEF,V)\t\t\t(VEC_OP(TDEF,pop)(V))\n \n+/* Truncate to specific length\n+   void VEC_T_truncate (VEC(T) *v, size_t len);\n+   \n+   Set the length as specified.  This is an O(1) operation.  */\n+#define VEC_truncate(TDEF,V,I)\t\t(VEC_OP(TDEF,truncate)(V,I))\n+\n /* Replace element\n    T VEC_T_replace (VEC(T) *v, size_t ix, T val); // Pointer\n    T *VEC_T_replace (VEC(T) *v, size_t ix, T *val);  // Object\n@@ -208,7 +216,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    to the slot created.  For vectors of object, the new value can be\n    NULL, in which case no initialization of the inserted slot takes\n    place. Reallocate V, if necessary.  */\n-#define VEC_safe_insert(TDEF,V,I,O)\t(VEC_OP(TDEF,safe_insert)(&(V),I,O))\n+#define VEC_safe_insert(TDEF,V,I,O)\t(VEC_OP(TDEF,safe_insert)(&(V),I,O MEM_STAT_INFO))\n      \n /* Remove element retaining order\n    T VEC_T_ordered_remove (VEC(T) *v, size_t ix); // Pointer\n@@ -229,12 +237,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define VEC_unordered_remove(TDEF,V,I)\t(VEC_OP(TDEF,unordered_remove)(V,I))\n \n #if !IN_GENGTYPE\n-#include \"auto-host.h\"\n-\n /* Reallocate an array of elements with prefix.  */\n-extern void *vec_p_reserve (void *, size_t);\n-extern void *vec_o_reserve (void *, size_t, size_t, size_t);\n-extern void *vec_embedded_alloc (size_t, size_t, size_t, size_t);\n+extern void *vec_p_reserve (void *, size_t MEM_STAT_DECL);\n+extern void *vec_o_reserve (void *, size_t, size_t, size_t MEM_STAT_DECL);\n \n #if ENABLE_CHECKING\n extern void vec_assert_fail (const char *, const char *,\n@@ -304,23 +309,29 @@ static inline TDEF VEC_OP (TDEF,iterate)\t\t  \t     \t  \\\n   return vec_ && ix_ < vec_->num ? vec_->vec[ix_] : NULL;\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline VEC (TDEF) *VEC_OP (TDEF,alloc)\t\t       \t\t  \\\n+static inline VEC (TDEF) *VEC_OP (TDEF,alloc MEM_STAT_DECL)\t\t  \\\n      (size_t alloc_)\t\t\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  return vec_p_reserve (NULL, alloc_ - !alloc_);\t\t\t  \\\n+  return vec_p_reserve (NULL, alloc_ - !alloc_ PASS_MEM_STAT);\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline void *VEC_OP (TDEF,embedded_alloc)\t\t\t  \\\n-     (size_t offset_, size_t alloc_)\t\t\t\t\t  \\\n+static inline size_t VEC_OP (TDEF,embedded_size)\t\t\t  \\\n+     (size_t alloc_)\t\t\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  return vec_embedded_alloc (offset_, offsetof (VEC(TDEF),vec),\t\t  \\\n-\t\t\t     sizeof (TDEF), alloc_);\t\t\t  \\\n+  return offsetof (VEC(TDEF),vec) + alloc_ * sizeof(TDEF);\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline void VEC_OP (TDEF,embedded_init)\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, size_t alloc_)\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  vec_->num = 0;\t\t\t\t\t\t\t  \\\n+  vec_->alloc = alloc_;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP (TDEF,reserve)\t       \t\t\t  \\\n-     (VEC (TDEF) **vec_, size_t alloc_)\t\t\t\t\t  \\\n+     (VEC (TDEF) **vec_, size_t alloc_ MEM_STAT_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  *vec_ = vec_p_reserve (*vec_, alloc_);\t\t\t\t  \\\n+  *vec_ = vec_p_reserve (*vec_, alloc_ PASS_MEM_STAT);\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF *VEC_OP (TDEF,quick_push)\t\t\t\t  \\\n@@ -336,10 +347,10 @@ static inline TDEF *VEC_OP (TDEF,quick_push)\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF *VEC_OP (TDEF,safe_push)\t\t\t\t  \\\n-     (VEC (TDEF) **vec_, TDEF obj_)\t\t\t\t\t  \\\n+     (VEC (TDEF) **vec_, TDEF obj_ MEM_STAT_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   if (!*vec_ || (*vec_)->num == (*vec_)->alloc)\t\t\t\t  \\\n-    VEC_OP (TDEF,reserve) (vec_, ~(size_t)0);\t\t\t\t  \\\n+    VEC_OP (TDEF,reserve) (vec_, ~(size_t)0 PASS_MEM_STAT);\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   return VEC_OP (TDEF,quick_push) (*vec_, obj_);\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n@@ -355,6 +366,13 @@ static inline TDEF VEC_OP (TDEF,pop)\t\t\t\t\t  \\\n   return obj_;\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n+static inline void VEC_OP (TDEF,truncate)\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, size_t size_)\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (vec_->num >= size_, \"truncate\", TDEF);\t\t\t  \\\n+  vec_->num = size_;\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n static inline TDEF VEC_OP (TDEF,replace)\t\t  \t     \t  \\\n      (VEC (TDEF) *vec_, size_t ix_, TDEF obj_)\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n@@ -382,10 +400,10 @@ static inline TDEF *VEC_OP (TDEF,quick_insert)\t\t     \t  \t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF *VEC_OP (TDEF,safe_insert)\t\t     \t  \t  \\\n-     (VEC (TDEF) **vec_, size_t ix_, TDEF obj_)       \t\t\t  \\\n+     (VEC (TDEF) **vec_, size_t ix_, TDEF obj_ MEM_STAT_DECL)\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   if (!*vec_ || (*vec_)->num == (*vec_)->alloc)\t\t\t\t  \\\n-    VEC_OP (TDEF,reserve) (vec_, ~(size_t)0);\t\t\t\t  \\\n+    VEC_OP (TDEF,reserve) (vec_, ~(size_t)0 PASS_MEM_STAT);\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   return VEC_OP (TDEF,quick_insert) (*vec_, ix_, obj_);\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n@@ -458,24 +476,32 @@ static inline TDEF *VEC_OP (TDEF,iterate)\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline VEC (TDEF) *VEC_OP (TDEF,alloc)      \t\t\t  \\\n-     (size_t alloc_)\t\t\t\t\t\t\t  \\\n+     (size_t alloc_ MEM_STAT_DECL)\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   return vec_o_reserve (NULL, alloc_ - !alloc_,\t\t\t\t  \\\n-\t\t\toffsetof (VEC(TDEF),vec), sizeof (TDEF));\t  \\\n+\t\t\toffsetof (VEC(TDEF),vec), sizeof (TDEF)\t\t  \\\n+\t\t\tPASS_MEM_STAT);\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline size_t VEC_OP (TDEF,embedded_size)\t\t\t  \\\n+     (size_t alloc_)\t\t\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  return offsetof (VEC(TDEF),vec) + alloc_ * sizeof(TDEF);\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline void *VEC_OP (TDEF,embedded_alloc)\t\t\t  \\\n-     (size_t offset_, size_t alloc_)\t\t\t\t\t  \\\n+static inline void VEC_OP (TDEF,embedded_init)\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, size_t alloc_)\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  return vec_embedded_alloc (offset_, offsetof (VEC(TDEF),vec),\t\t  \\\n-\t\t\t     sizeof (TDEF), alloc_);\t\t\t  \\\n+  vec_->num = 0;\t\t\t\t\t\t\t  \\\n+  vec_->alloc = alloc_;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP (TDEF,reserve)\t       \t\t\t  \\\n-     (VEC (TDEF) **vec_, size_t alloc_)\t\t\t\t\t  \\\n+     (VEC (TDEF) **vec_, size_t alloc_ MEM_STAT_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   *vec_ = vec_o_reserve (*vec_, alloc_,\t\t\t\t\t  \\\n-\t\t\t offsetof (VEC(TDEF),vec), sizeof (TDEF));\t  \\\n+\t\t\t offsetof (VEC(TDEF),vec), sizeof (TDEF)\t  \\\n+\t\t\t PASS_MEM_STAT);\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF *VEC_OP (TDEF,quick_push)\t\t\t\t  \\\n@@ -492,10 +518,10 @@ static inline TDEF *VEC_OP (TDEF,quick_push)\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF *VEC_OP (TDEF,safe_push)\t\t\t\t  \\\n-     (VEC (TDEF) **vec_, const TDEF *obj_)\t\t\t\t  \\\n+     (VEC (TDEF) **vec_, const TDEF *obj_ MEM_STAT_DECL)\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   if (!*vec_ || (*vec_)->num == (*vec_)->alloc)\t\t\t\t  \\\n-    VEC_OP (TDEF,reserve) (vec_, ~(size_t)0);\t\t\t\t  \\\n+    VEC_OP (TDEF,reserve) (vec_, ~(size_t)0 PASS_MEM_STAT);\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   return VEC_OP (TDEF,quick_push) (*vec_, obj_);\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n@@ -504,7 +530,14 @@ static inline void VEC_OP (TDEF,pop)\t\t\t\t\t  \\\n      (VEC (TDEF) *vec_)\t\t\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   VEC_ASSERT (vec_->num, \"pop\", TDEF);\t\t\t\t\t  \\\n-  vec_->vec[--vec_->num];\t\t\t\t\t\t  \\\n+  --vec_->num;\t\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline void VEC_OP (TDEF,truncate)\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, size_t size_)\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  VEC_ASSERT (vec_->num >= size_, \"truncate\", TDEF);\t\t\t  \\\n+  vec_->num = size_;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF *VEC_OP (TDEF,replace)\t\t\t\t  \\\n@@ -536,10 +569,10 @@ static inline TDEF *VEC_OP (TDEF,quick_insert)\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF *VEC_OP (TDEF,safe_insert)\t\t     \t  \t  \\\n-     (VEC (TDEF) **vec_, size_t ix_, const TDEF *obj_)\t\t\t  \\\n+     (VEC (TDEF) **vec_, size_t ix_, const TDEF *obj_ MEM_STAT_DECL)\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   if (!*vec_ || (*vec_)->num == (*vec_)->alloc)\t\t\t\t  \\\n-    VEC_OP (TDEF,reserve) (vec_, ~(size_t)0);\t\t\t\t  \\\n+    VEC_OP (TDEF,reserve) (vec_, ~(size_t)0 PASS_MEM_STAT);\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   return VEC_OP (TDEF,quick_insert) (*vec_, ix_, obj_);\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\"}]}