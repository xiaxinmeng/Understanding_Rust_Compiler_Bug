{"sha": "3d8ca53dd9b4c42b07ef974f92c3c4553cce3a79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q4Y2E1M2RkOWI0YzQyYjA3ZWY5NzRmOTJjM2M0NTUzY2NlM2E3OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-02T18:28:06Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-02T18:28:06Z"}, "message": "Make more use of rtx_vector_builder\n\nThis patch makes various bits of CONST_VECTOR-building code use\nrtx_vector_builder, operating directly on a specific encoding.\n\n2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* expr.c: Include rtx-vector-builder.h.\n\t(const_vector_mask_from_tree): Use rtx_vector_builder and operate\n\tdirectly on the tree encoding.\n\t(const_vector_from_tree): Likewise.\n\t* optabs.c: Include rtx-vector-builder.h.\n\t(expand_vec_perm_var): Use rtx_vector_builder and create a repeating\n\tsequence of \"u\" values.\n\t* vec-perm-indices.c: Include rtx-vector-builder.h.\n\t(vec_perm_indices_to_rtx): Use rtx_vector_builder and operate\n\tdirectly on the vec_perm_indices encoding.\n\nFrom-SVN: r256103", "tree": {"sha": "a24895a3e9e27d5d1711474f8246f92559d37b64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a24895a3e9e27d5d1711474f8246f92559d37b64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d8ca53dd9b4c42b07ef974f92c3c4553cce3a79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d8ca53dd9b4c42b07ef974f92c3c4553cce3a79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d8ca53dd9b4c42b07ef974f92c3c4553cce3a79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d8ca53dd9b4c42b07ef974f92c3c4553cce3a79/comments", "author": null, "committer": null, "parents": [{"sha": "3877c560656f4961cc50952c3bba3c40812c36c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3877c560656f4961cc50952c3bba3c40812c36c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3877c560656f4961cc50952c3bba3c40812c36c3"}], "stats": {"total": 98, "additions": 50, "deletions": 48}, "files": [{"sha": "32396b98c647413726430ae2606130442404abd8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8ca53dd9b4c42b07ef974f92c3c4553cce3a79/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8ca53dd9b4c42b07ef974f92c3c4553cce3a79/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d8ca53dd9b4c42b07ef974f92c3c4553cce3a79", "patch": "@@ -1,3 +1,16 @@\n+2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* expr.c: Include rtx-vector-builder.h.\n+\t(const_vector_mask_from_tree): Use rtx_vector_builder and operate\n+\tdirectly on the tree encoding.\n+\t(const_vector_from_tree): Likewise.\n+\t* optabs.c: Include rtx-vector-builder.h.\n+\t(expand_vec_perm_var): Use rtx_vector_builder and create a repeating\n+\tsequence of \"u\" values.\n+\t* vec-perm-indices.c: Include rtx-vector-builder.h.\n+\t(vec_perm_indices_to_rtx): Use rtx_vector_builder and operate\n+\tdirectly on the vec_perm_indices encoding.\n+\n 2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* doc/rtl.texi (const_vector): Describe new encoding scheme."}, {"sha": "a84c02f41a93e431c859d137618885156b1751b7", "filename": "gcc/expr.c", "status": "modified", "additions": 25, "deletions": 38, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8ca53dd9b4c42b07ef974f92c3c4553cce3a79/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8ca53dd9b4c42b07ef974f92c3c4553cce3a79/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=3d8ca53dd9b4c42b07ef974f92c3c4553cce3a79", "patch": "@@ -61,6 +61,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-chkp.h\"\n #include \"rtl-chkp.h\"\n #include \"ccmp.h\"\n+#include \"rtx-vector-builder.h\"\n \n \n /* If this is nonzero, we do not bother generating VOLATILE\n@@ -11797,32 +11798,25 @@ try_tablejump (tree index_type, tree index_expr, tree minval, tree range,\n static rtx\n const_vector_mask_from_tree (tree exp)\n {\n-  rtvec v;\n-  unsigned i, units;\n-  tree elt;\n-  machine_mode inner, mode;\n-\n-  mode = TYPE_MODE (TREE_TYPE (exp));\n-  units = VECTOR_CST_NELTS (exp);\n-  inner = GET_MODE_INNER (mode);\n-\n-  v = rtvec_alloc (units);\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n+  machine_mode inner = GET_MODE_INNER (mode);\n \n-  for (i = 0; i < units; ++i)\n+  rtx_vector_builder builder (mode, VECTOR_CST_NPATTERNS (exp),\n+\t\t\t      VECTOR_CST_NELTS_PER_PATTERN (exp));\n+  unsigned int count = builder.encoded_nelts ();\n+  for (unsigned int i = 0; i < count; ++i)\n     {\n-      elt = VECTOR_CST_ELT (exp, i);\n-\n+      tree elt = VECTOR_CST_ELT (exp, i);\n       gcc_assert (TREE_CODE (elt) == INTEGER_CST);\n       if (integer_zerop (elt))\n-\tRTVEC_ELT (v, i) = CONST0_RTX (inner);\n+\tbuilder.quick_push (CONST0_RTX (inner));\n       else if (integer_onep (elt)\n \t       || integer_minus_onep (elt))\n-\tRTVEC_ELT (v, i) = CONSTM1_RTX (inner);\n+\tbuilder.quick_push (CONSTM1_RTX (inner));\n       else\n \tgcc_unreachable ();\n     }\n-\n-  return gen_rtx_CONST_VECTOR (mode, v);\n+  return builder.build ();\n }\n \n /* EXP is a VECTOR_CST in which each element is either all-zeros or all-ones.\n@@ -11852,40 +11846,33 @@ const_scalar_mask_from_tree (scalar_int_mode mode, tree exp)\n static rtx\n const_vector_from_tree (tree exp)\n {\n-  rtvec v;\n-  unsigned i, units;\n-  tree elt;\n-  machine_mode inner, mode;\n-\n-  mode = TYPE_MODE (TREE_TYPE (exp));\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n \n   if (initializer_zerop (exp))\n     return CONST0_RTX (mode);\n \n   if (VECTOR_BOOLEAN_TYPE_P (TREE_TYPE (exp)))\n     return const_vector_mask_from_tree (exp);\n \n-  units = VECTOR_CST_NELTS (exp);\n-  inner = GET_MODE_INNER (mode);\n-\n-  v = rtvec_alloc (units);\n+  machine_mode inner = GET_MODE_INNER (mode);\n \n-  for (i = 0; i < units; ++i)\n+  rtx_vector_builder builder (mode, VECTOR_CST_NPATTERNS (exp),\n+\t\t\t      VECTOR_CST_NELTS_PER_PATTERN (exp));\n+  unsigned int count = builder.encoded_nelts ();\n+  for (unsigned int i = 0; i < count; ++i)\n     {\n-      elt = VECTOR_CST_ELT (exp, i);\n-\n+      tree elt = VECTOR_CST_ELT (exp, i);\n       if (TREE_CODE (elt) == REAL_CST)\n-\tRTVEC_ELT (v, i) = const_double_from_real_value (TREE_REAL_CST (elt),\n-\t\t\t\t\t\t\t inner);\n+\tbuilder.quick_push (const_double_from_real_value (TREE_REAL_CST (elt),\n+\t\t\t\t\t\t\t  inner));\n       else if (TREE_CODE (elt) == FIXED_CST)\n-\tRTVEC_ELT (v, i) = CONST_FIXED_FROM_FIXED_VALUE (TREE_FIXED_CST (elt),\n-\t\t\t\t\t\t\t inner);\n+\tbuilder.quick_push (CONST_FIXED_FROM_FIXED_VALUE (TREE_FIXED_CST (elt),\n+\t\t\t\t\t\t\t  inner));\n       else\n-\tRTVEC_ELT (v, i) = immed_wide_int_const (wi::to_poly_wide (elt),\n-\t\t\t\t\t\t inner);\n+\tbuilder.quick_push (immed_wide_int_const (wi::to_poly_wide (elt),\n+\t\t\t\t\t\t  inner));\n     }\n-\n-  return gen_rtx_CONST_VECTOR (mode, v);\n+  return builder.build ();\n }\n \n /* Build a decl for a personality function given a language prefix.  */"}, {"sha": "c3ee454f726fb97bb5faa347a5c6cdaf957708ae", "filename": "gcc/optabs.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8ca53dd9b4c42b07ef974f92c3c4553cce3a79/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8ca53dd9b4c42b07ef974f92c3c4553cce3a79/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=3d8ca53dd9b4c42b07ef974f92c3c4553cce3a79", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"emit-rtl.h\"\n #include \"recog.h\"\n #include \"diagnostic-core.h\"\n+#include \"rtx-vector-builder.h\"\n \n /* Include insn-config.h before expr.h so that HAVE_conditional_move\n    is properly defined.  */\n@@ -5609,7 +5610,6 @@ expand_vec_perm_var (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n   enum insn_code icode;\n   unsigned int i, w, u;\n   rtx tmp, sel_qi;\n-  rtvec vec;\n \n   w = GET_MODE_SIZE (mode);\n   u = GET_MODE_UNIT_SIZE (mode);\n@@ -5661,10 +5661,10 @@ expand_vec_perm_var (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n   /* Add the byte offset to each byte element.  */\n   /* Note that the definition of the indicies here is memory ordering,\n      so there should be no difference between big and little endian.  */\n-  vec = rtvec_alloc (w);\n-  for (i = 0; i < w; ++i)\n-    RTVEC_ELT (vec, i) = GEN_INT (i % u);\n-  tmp = gen_rtx_CONST_VECTOR (qimode, vec);\n+  rtx_vector_builder byte_indices (qimode, u, 1);\n+  for (i = 0; i < u; ++i)\n+    byte_indices.quick_push (GEN_INT (i));\n+  tmp = byte_indices.build ();\n   sel_qi = expand_simple_binop (qimode, PLUS, sel, tmp,\n \t\t\t\tsel, 0, OPTAB_DIRECT);\n   gcc_assert (sel_qi != NULL);"}, {"sha": "8b6f412ba5fee0bfd418df5e3f368b2cb84badb1", "filename": "gcc/vec-perm-indices.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8ca53dd9b4c42b07ef974f92c3c4553cce3a79/gcc%2Fvec-perm-indices.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8ca53dd9b4c42b07ef974f92c3c4553cce3a79/gcc%2Fvec-perm-indices.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec-perm-indices.c?ref=3d8ca53dd9b4c42b07ef974f92c3c4553cce3a79", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"memmodel.h\"\n #include \"emit-rtl.h\"\n #include \"selftest.h\"\n+#include \"rtx-vector-builder.h\"\n \n /* Switch to a new permutation vector that selects between NINPUTS vector\n    inputs that have NELTS_PER_INPUT elements each.  Take the elements of the\n@@ -223,11 +224,12 @@ vec_perm_indices_to_rtx (machine_mode mode, const vec_perm_indices &indices)\n {\n   gcc_assert (GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n \t      && GET_MODE_NUNITS (mode) == indices.length ());\n-  unsigned int nelts = indices.length ();\n-  rtvec v = rtvec_alloc (nelts);\n-  for (unsigned int i = 0; i < nelts; ++i)\n-    RTVEC_ELT (v, i) = gen_int_mode (indices[i], GET_MODE_INNER (mode));\n-  return gen_rtx_CONST_VECTOR (mode, v);\n+  rtx_vector_builder sel (mode, indices.encoding ().npatterns (),\n+\t\t\t  indices.encoding ().nelts_per_pattern ());\n+  unsigned int encoded_nelts = sel.encoded_nelts ();\n+  for (unsigned int i = 0; i < encoded_nelts; i++)\n+    sel.quick_push (gen_int_mode (indices[i], GET_MODE_INNER (mode)));\n+  return sel.build ();\n }\n \n #if CHECKING_P"}]}