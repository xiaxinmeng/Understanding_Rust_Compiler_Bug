{"sha": "dbcc9f08d5631a29708cf859689a46a1895111fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJjYzlmMDhkNTYzMWEyOTcwOGNmODU5Njg5YTQ2YTE4OTUxMTFmYQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2011-05-10T17:20:46Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2011-05-10T17:20:46Z"}, "message": "Fix PRs 48857, 48495\n\nFrom-SVN: r173624", "tree": {"sha": "290741946669cfd5c76d3d81e604ada17d7410f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/290741946669cfd5c76d3d81e604ada17d7410f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbcc9f08d5631a29708cf859689a46a1895111fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbcc9f08d5631a29708cf859689a46a1895111fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbcc9f08d5631a29708cf859689a46a1895111fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbcc9f08d5631a29708cf859689a46a1895111fa/comments", "author": null, "committer": null, "parents": [{"sha": "8242dd04b79486c5890e599caa9c492eac38c2f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8242dd04b79486c5890e599caa9c492eac38c2f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8242dd04b79486c5890e599caa9c492eac38c2f8"}], "stats": {"total": 129, "additions": 84, "deletions": 45}, "files": [{"sha": "fb479a43e0f2f0f0296a70b533a33c1dded4efdf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbcc9f08d5631a29708cf859689a46a1895111fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbcc9f08d5631a29708cf859689a46a1895111fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dbcc9f08d5631a29708cf859689a46a1895111fa", "patch": "@@ -1,3 +1,27 @@\n+2011-05-10  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/48857, 48495\n+\t* config/rs6000/rs6000.h (VSX_SCALAR_MODE): Delete.\n+\t(VSX_MODE): Ditto.\n+\t(VSX_MOVE_MODE): Ditto.\n+\t(ALTIVEC_OR_VSX_VECTOR_MODE): New macro, combine all Altivec and\n+\tVSX vector types.  Add V2DImode.\n+\t(HARD_REGNO_CALLER_SAVE_MODE): Use it instead of\n+\tALTIVEC_VECTOR_MODE and VSX_VECTOR_MODE calls.\n+\t(MODES_TIEABLE_P): Ditto.\n+\n+\t* config/rs6000/rs6000.c (rs6000_emit_move): Use\n+\tALTIVEC_OR_VSX_MODE instead of ALTIVEC_VECTOR_MODE and\n+\tVSX_VECTOR_MODE.\n+\t(init_cumulative_args): Ditto.\n+\t(rs6000_function_arg_boundary): Ditto.\n+\t(rs6000_function_arg_advance_1): Ditto.\n+\t(rs6000_function_arg): Ditto.\n+\t(rs6000_function_ok_for_sibcall): Ditto.\n+\t(emit_frame_save): Ditto.\n+\t(rs6000_function_value): Ditto.\n+\t(rs6000_libcall_value): Ditto.\n+\n 2011-05-10  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config.gcc (i[34567]86-*-darwin*, x86_64-*-darwin*): Add"}, {"sha": "ea272fcaad6418c8e0c75c90a486782350e700cc", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbcc9f08d5631a29708cf859689a46a1895111fa/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbcc9f08d5631a29708cf859689a46a1895111fa/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=dbcc9f08d5631a29708cf859689a46a1895111fa", "patch": "@@ -7597,7 +7597,7 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n \n /* Nonzero if we can use an AltiVec register to pass this arg.  */\n #define USE_ALTIVEC_FOR_ARG_P(CUM,MODE,TYPE,NAMED)\t\t\\\n-  ((ALTIVEC_VECTOR_MODE (MODE) || VSX_VECTOR_MODE (MODE))\t\\\n+  (ALTIVEC_OR_VSX_VECTOR_MODE (MODE)\t\t\t\t\\\n    && (CUM)->vregno <= ALTIVEC_ARG_MAX_REG\t\t\t\\\n    && TARGET_ALTIVEC_ABI\t\t\t\t\t\\\n    && (NAMED))\n@@ -7797,8 +7797,7 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n \t    }\n \t  if (SCALAR_FLOAT_MODE_P (return_mode))\n \t    rs6000_passes_float = true;\n-\t  else if (ALTIVEC_VECTOR_MODE (return_mode)\n-\t\t   || VSX_VECTOR_MODE (return_mode)\n+\t  else if (ALTIVEC_OR_VSX_VECTOR_MODE (return_mode)\n \t\t   || SPE_VECTOR_MODE (return_mode))\n \t    rs6000_passes_vector = true;\n \t}\n@@ -7896,7 +7895,7 @@ function_arg_padding (enum machine_mode mode, const_tree type)\n    existing library interfaces.\n \n    Doubleword align SPE vectors.\n-   Quadword align Altivec vectors.\n+   Quadword align Altivec/VSX vectors.\n    Quadword align large synthetic vector types.   */\n \n static unsigned int\n@@ -7913,7 +7912,7 @@ rs6000_function_arg_boundary (enum machine_mode mode, const_tree type)\n \t       && int_size_in_bytes (type) >= 8\n \t       && int_size_in_bytes (type) < 16))\n     return 64;\n-  else if ((ALTIVEC_VECTOR_MODE (mode) || VSX_VECTOR_MODE (mode))\n+  else if (ALTIVEC_OR_VSX_VECTOR_MODE (mode)\n \t   || (type && TREE_CODE (type) == VECTOR_TYPE\n \t       && int_size_in_bytes (type) >= 16))\n     return 128;\n@@ -8133,7 +8132,7 @@ rs6000_function_arg_advance_1 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n     {\n       if (SCALAR_FLOAT_MODE_P (mode))\n \trs6000_passes_float = true;\n-      else if (named && (ALTIVEC_VECTOR_MODE (mode) || VSX_VECTOR_MODE (mode)))\n+      else if (named && ALTIVEC_OR_VSX_VECTOR_MODE (mode))\n \trs6000_passes_vector = true;\n       else if (SPE_VECTOR_MODE (mode)\n \t       && !cum->stdarg\n@@ -8143,8 +8142,7 @@ rs6000_function_arg_advance_1 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n #endif\n \n   if (TARGET_ALTIVEC_ABI\n-      && (ALTIVEC_VECTOR_MODE (mode)\n-\t  || VSX_VECTOR_MODE (mode)\n+      && (ALTIVEC_OR_VSX_VECTOR_MODE (mode)\n \t  || (type && TREE_CODE (type) == VECTOR_TYPE\n \t      && int_size_in_bytes (type) == 16)))\n     {\n@@ -8762,8 +8760,7 @@ rs6000_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n     else\n       return gen_rtx_REG (mode, cum->vregno);\n   else if (TARGET_ALTIVEC_ABI\n-\t   && (ALTIVEC_VECTOR_MODE (mode)\n-\t       || VSX_VECTOR_MODE (mode)\n+\t   && (ALTIVEC_OR_VSX_VECTOR_MODE (mode)\n \t       || (type && TREE_CODE (type) == VECTOR_TYPE\n \t\t   && int_size_in_bytes (type) == 16)))\n     {\n@@ -19036,14 +19033,12 @@ rs6000_function_ok_for_sibcall (tree decl, tree exp)\n \t here.  */\n       FOREACH_FUNCTION_ARGS(fntype, type, args_iter)\n \tif (TREE_CODE (type) == VECTOR_TYPE\n-\t    && (ALTIVEC_VECTOR_MODE (TYPE_MODE (type))\n-\t\t|| VSX_VECTOR_MODE (TYPE_MODE (type))))\n+\t    && ALTIVEC_OR_VSX_VECTOR_MODE (TYPE_MODE (type)))\n \t  nvreg++;\n \n       FOREACH_FUNCTION_ARGS(TREE_TYPE (current_function_decl), type, args_iter)\n \tif (TREE_CODE (type) == VECTOR_TYPE\n-\t    && (ALTIVEC_VECTOR_MODE (TYPE_MODE (type))\n-\t\t|| VSX_VECTOR_MODE (TYPE_MODE (type))))\n+\t    && ALTIVEC_OR_VSX_VECTOR_MODE (TYPE_MODE (type)))\n \t  nvreg--;\n \n       if (nvreg > 0)\n@@ -19756,7 +19751,7 @@ emit_frame_save (rtx frame_reg, rtx frame_ptr, enum machine_mode mode,\n \n   /* Some cases that need register indexed addressing.  */\n   if ((TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (mode))\n-      || (TARGET_VSX && VSX_VECTOR_MODE (mode))\n+      || (TARGET_VSX && ALTIVEC_OR_VSX_VECTOR_MODE (mode))\n       || (TARGET_E500_DOUBLE && mode == DFmode)\n       || (TARGET_SPE_ABI\n \t  && SPE_VECTOR_MODE (mode)\n@@ -27042,13 +27037,12 @@ rs6000_function_value (const_tree valtype,\n   else if (TREE_CODE (valtype) == COMPLEX_TYPE\n \t   && targetm.calls.split_complex_arg)\n     return rs6000_complex_function_value (mode);\n+  /* VSX is a superset of Altivec and adds V2DImode/V2DFmode.  Since the same\n+     return register is used in both cases, and we won't see V2DImode/V2DFmode\n+     for pure altivec, combine the two cases.  */\n   else if (TREE_CODE (valtype) == VECTOR_TYPE\n \t   && TARGET_ALTIVEC && TARGET_ALTIVEC_ABI\n-\t   && ALTIVEC_VECTOR_MODE (mode))\n-    regno = ALTIVEC_ARG_RETURN;\n-  else if (TREE_CODE (valtype) == VECTOR_TYPE\n-\t   && TARGET_VSX && TARGET_ALTIVEC_ABI\n-\t   && VSX_VECTOR_MODE (mode))\n+\t   && ALTIVEC_OR_VSX_VECTOR_MODE (mode))\n     regno = ALTIVEC_ARG_RETURN;\n   else if (TARGET_E500_DOUBLE && TARGET_HARD_FLOAT\n \t   && (mode == DFmode || mode == DCmode\n@@ -27088,12 +27082,12 @@ rs6000_libcall_value (enum machine_mode mode)\n \t   && TARGET_HARD_FLOAT && TARGET_FPRS\n            && ((TARGET_SINGLE_FLOAT && mode == SFmode) || TARGET_DOUBLE_FLOAT))\n     regno = FP_ARG_RETURN;\n-  else if (ALTIVEC_VECTOR_MODE (mode)\n+  /* VSX is a superset of Altivec and adds V2DImode/V2DFmode.  Since the same\n+     return register is used in both cases, and we won't see V2DImode/V2DFmode\n+     for pure altivec, combine the two cases.  */\n+  else if (ALTIVEC_OR_VSX_VECTOR_MODE (mode)\n \t   && TARGET_ALTIVEC && TARGET_ALTIVEC_ABI)\n     regno = ALTIVEC_ARG_RETURN;\n-  else if (VSX_VECTOR_MODE (mode)\n-\t   && TARGET_VSX && TARGET_ALTIVEC_ABI)\n-    regno = ALTIVEC_ARG_RETURN;\n   else if (COMPLEX_MODE_P (mode) && targetm.calls.split_complex_arg)\n     return rs6000_complex_function_value (mode);\n   else if (TARGET_E500_DOUBLE && TARGET_HARD_FLOAT"}, {"sha": "646d9d3b7aa0aacaca4331870aa4c0dcd4dc13ab", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbcc9f08d5631a29708cf859689a46a1895111fa/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbcc9f08d5631a29708cf859689a46a1895111fa/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=dbcc9f08d5631a29708cf859689a46a1895111fa", "patch": "@@ -994,10 +994,9 @@ extern unsigned rs6000_pointer_size;\n \n /* When setting up caller-save slots (MODE == VOIDmode) ensure we allocate\n    enough space to account for vectors in FP regs. */\n-#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE)\t\\\n-  (TARGET_VSX\t\t\t\t\t\t\\\n-   && ((MODE) == VOIDmode || VSX_VECTOR_MODE (MODE)\t\\\n-       || ALTIVEC_VECTOR_MODE (MODE))\t\t\t\\\n+#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE)\t\t\t\\\n+  (TARGET_VSX\t\t\t\t\t\t\t\t\\\n+   && ((MODE) == VOIDmode || ALTIVEC_OR_VSX_VECTOR_MODE (MODE))\t\t\\\n    && FP_REGNO_P (REGNO)\t\t\t\t\\\n    ? V2DFmode\t\t\t\t\t\t\\\n    : choose_hard_reg_mode ((REGNO), (NREGS), false))\n@@ -1013,25 +1012,16 @@ extern unsigned rs6000_pointer_size;\n \t ((MODE) == V4SFmode\t\t\\\n \t  || (MODE) == V2DFmode)\t\\\n \n-#define VSX_SCALAR_MODE(MODE)\t\t\\\n-\t((MODE) == DFmode)\n-\n-#define VSX_MODE(MODE)\t\t\t\\\n-\t(VSX_VECTOR_MODE (MODE)\t\t\\\n-\t || VSX_SCALAR_MODE (MODE))\n-\n-#define VSX_MOVE_MODE(MODE)\t\t\\\n-\t(VSX_VECTOR_MODE (MODE)\t\t\\\n-\t || VSX_SCALAR_MODE (MODE)\t\\\n-\t || ALTIVEC_VECTOR_MODE (MODE)\t\\\n-\t || (MODE) == TImode)\n-\n #define ALTIVEC_VECTOR_MODE(MODE)\t\\\n \t ((MODE) == V16QImode\t\t\\\n \t  || (MODE) == V8HImode\t\t\\\n \t  || (MODE) == V4SFmode\t\t\\\n \t  || (MODE) == V4SImode)\n \n+#define ALTIVEC_OR_VSX_VECTOR_MODE(MODE)\t\t\t\t\\\n+  (ALTIVEC_VECTOR_MODE (MODE) || VSX_VECTOR_MODE (MODE)\t\t\t\\\n+   || (MODE) == V2DImode)\n+\n #define SPE_VECTOR_MODE(MODE)\t\t\\\n \t((MODE) == V4HImode          \t\\\n          || (MODE) == V2SFmode          \\\n@@ -1067,10 +1057,10 @@ extern unsigned rs6000_pointer_size;\n    ? ALTIVEC_VECTOR_MODE (MODE2)\t\t\\\n    : ALTIVEC_VECTOR_MODE (MODE2)\t\t\\\n    ? ALTIVEC_VECTOR_MODE (MODE1)\t\t\\\n-   : VSX_VECTOR_MODE (MODE1)\t\t\t\\\n-   ? VSX_VECTOR_MODE (MODE2)\t\t\t\\\n-   : VSX_VECTOR_MODE (MODE2)\t\t\t\\\n-   ? VSX_VECTOR_MODE (MODE1)\t\t\t\\\n+   : ALTIVEC_OR_VSX_VECTOR_MODE (MODE1)\t\t\\\n+   ? ALTIVEC_OR_VSX_VECTOR_MODE (MODE2)\t\t\\\n+   : ALTIVEC_OR_VSX_VECTOR_MODE (MODE2)\t\t\\\n+   ? ALTIVEC_OR_VSX_VECTOR_MODE (MODE1)\t\t\\\n    : 1)\n \n /* Post-reload, we can't use any new AltiVec registers, as we already"}, {"sha": "0d85506a18524b3f27d1aaac53e7b98249318492", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbcc9f08d5631a29708cf859689a46a1895111fa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbcc9f08d5631a29708cf859689a46a1895111fa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dbcc9f08d5631a29708cf859689a46a1895111fa", "patch": "@@ -1,3 +1,9 @@\n+2011-05-10  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/48857\n+\t* gcc.target/powerpc/pr48857.c: New file, make sure V2DI arguments\n+\tare passed and returned in vector registers.\n+\n 2011-05-10  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.dg/tree-ssa/ssa-fre-2.c: Disable forwprop."}, {"sha": "e8201c037dee20f9763c50297a47a7cad101f12a", "filename": "gcc/testsuite/gcc.target/powerpc/pr48857.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbcc9f08d5631a29708cf859689a46a1895111fa/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr48857.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbcc9f08d5631a29708cf859689a46a1895111fa/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr48857.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr48857.c?ref=dbcc9f08d5631a29708cf859689a46a1895111fa", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O2 -mcpu=power7 -mabi=altivec\" } */\n+/* { dg-final { scan-assembler-times \"lxvd2x\" 1 } } */\n+/* { dg-final { scan-assembler-times \"stxvd2x\" 1 } } */\n+/* { dg-final { scan-assembler-not \"ld\" } } */\n+/* { dg-final { scan-assembler-not \"lwz\" } } */\n+/* { dg-final { scan-assembler-not \"stw\" } } */\n+/* { dg-final { scan-assembler-not \"addi\" } } */\n+\n+typedef vector long long v2di_type;\n+\n+v2di_type\n+return_v2di (v2di_type *ptr)\n+{\n+  return *ptr;\t\t/* should generate lxvd2x 34,0,3.  */\n+}\n+\n+void\n+pass_v2di (v2di_type arg, v2di_type *ptr)\n+{\n+  *ptr = arg;\t\t/* should generate stxvd2x 34,0,{3,5}.  */\n+}\n+"}]}