{"sha": "495499daead6ed7050db2af715fabd4f472595cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk1NDk5ZGFlYWQ2ZWQ3MDUwZGIyYWY3MTVmYWJkNGY0NzI1OTVjZA==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2009-06-28T17:01:16Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2009-06-28T17:01:16Z"}, "message": "expr.c (expand_expr_real_1): Just use do_store_flag.\n\n2009-06-28  Paolo Bonzini  <bonzini@gnu.org>\n\n        * expr.c (expand_expr_real_1): Just use do_store_flag.\n        (do_store_flag): Drop support for TRUTH_NOT_EXPR.  Use\n        emit_store_flag_force.\n        * expmed.c (emit_store_flag_force): Copy here trick\n        previously in expand_expr_real_1.  Try reversing the comparison.\n        (emit_store_flag_1): Work if target is NULL.\n        (emit_store_flag): Work if target is NULL, using the result mode\n        from the comparison.  Use split_comparison, restructure final part\n        to simplify conditionals.\n\nFrom-SVN: r149032", "tree": {"sha": "c4b677b4f4b96faeeeb3b82fdd95454ff8e7e03d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4b677b4f4b96faeeeb3b82fdd95454ff8e7e03d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/495499daead6ed7050db2af715fabd4f472595cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/495499daead6ed7050db2af715fabd4f472595cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/495499daead6ed7050db2af715fabd4f472595cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/495499daead6ed7050db2af715fabd4f472595cd/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "337e5d984b3037470d90ebc6973d0b921ce9036e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/337e5d984b3037470d90ebc6973d0b921ce9036e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/337e5d984b3037470d90ebc6973d0b921ce9036e"}], "stats": {"total": 353, "additions": 226, "deletions": 127}, "files": [{"sha": "96bd8cf1a71385df2dd57f337853587952605762", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/495499daead6ed7050db2af715fabd4f472595cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/495499daead6ed7050db2af715fabd4f472595cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=495499daead6ed7050db2af715fabd4f472595cd", "patch": "@@ -1,3 +1,15 @@\n+2009-06-28  Paolo Bonzini  <bonzini@gnu.org>\n+\n+        * expr.c (expand_expr_real_1): Just use do_store_flag.\n+        (do_store_flag): Drop support for TRUTH_NOT_EXPR.  Use\n+        emit_store_flag_force.\n+        * expmed.c (emit_store_flag_force): Copy here trick\n+        previously in expand_expr_real_1.  Try reversing the comparison.\n+        (emit_store_flag_1): Work if target is NULL.\n+        (emit_store_flag): Work if target is NULL, using the result mode\n+        from the comparison.  Use split_comparison, restructure final part\n+        to simplify conditionals.\n+\n 2009-06-28  Paolo Bonzini  <bonzini@gnu.org>\n \n         * builtins.c (expand_errno_check): Use do_compare_rtx_and_jump."}, {"sha": "9c76a6d9fb7c49a9a46529de420dc0bfbaba7a67", "filename": "gcc/expmed.c", "status": "modified", "additions": 208, "deletions": 43, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/495499daead6ed7050db2af715fabd4f472595cd/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/495499daead6ed7050db2af715fabd4f472595cd/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=495499daead6ed7050db2af715fabd4f472595cd", "patch": "@@ -5112,14 +5112,18 @@ expand_and (enum machine_mode mode, rtx op0, rtx op1, rtx target)\n     emit_move_insn (target, tem);\n   return target;\n }\n-\f\n+\n /* Helper function for emit_store_flag.  */\n static rtx\n emit_store_flag_1 (rtx target, rtx subtarget, enum machine_mode mode,\n \t\t   int normalizep)\n {\n   rtx op0;\n-  enum machine_mode target_mode = GET_MODE (target);\n+  enum machine_mode target_mode;\n+\n+  if (!target)\n+    target = gen_reg_rtx (GET_MODE (subtarget));\n+  target_mode = GET_MODE (target);\n   \n   /* If we are converting to a wider mode, first convert to\n      TARGET_MODE, then normalize.  This produces better combining\n@@ -5206,9 +5210,10 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n   rtx subtarget;\n   enum insn_code icode;\n   enum machine_mode compare_mode;\n-  enum machine_mode target_mode = GET_MODE (target);\n+  enum machine_mode target_mode = target ? GET_MODE (target) : VOIDmode;\n   enum mode_class mclass;\n-  rtx tem;\n+  enum rtx_code rcode;\n+  rtx tem, trueval;\n   rtx last;\n   rtx pattern, comparison;\n \n@@ -5312,10 +5317,13 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n     {\n       subtarget = target;\n \n+      if (!target)\n+\ttarget_mode = mode;\n+\n       /* If the result is to be wider than OP0, it is best to convert it\n \t first.  If it is to be narrower, it is *incorrect* to convert it\n \t first.  */\n-      if (GET_MODE_SIZE (target_mode) > GET_MODE_SIZE (mode))\n+      else if (GET_MODE_SIZE (target_mode) > GET_MODE_SIZE (mode))\n \t{\n \t  op0 = convert_modes (target_mode, mode, op0, 0);\n \t  mode = target_mode;\n@@ -5372,10 +5380,12 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t      continue;\n \t    }\n \n-\t  subtarget = target;\n-\t  if (optimize || !(insn_data[(int) icode].operand[0].predicate\n-\t\t\t    (subtarget, result_mode)))\n+\t  if (!target\n+\t      || optimize\n+\t      || !(insn_data[(int) icode].operand[0].predicate (target, result_mode)))\n \t    subtarget = gen_reg_rtx (result_mode);\n+\t  else\n+\t    subtarget = target;\n \n \t  pattern = GEN_FCN (icode) (subtarget, comparison, x, y);\n \n@@ -5393,23 +5403,118 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \n   last = get_last_insn ();\n \n+  /* If we reached here, we can't do this with a scc insn, however there\n+     are some comparisons that can be done in other ways.  Don't do any\n+     of these cases if branches are very cheap.  */\n+  if (BRANCH_COST (optimize_insn_for_speed_p (), false) == 0)\n+    return 0;\n+\n+  /* See what we need to return.  We can only return a 1, -1, or the\n+     sign bit.  */\n+\n+  if (normalizep == 0)\n+    {\n+      if (STORE_FLAG_VALUE == 1 || STORE_FLAG_VALUE == -1)\n+\tnormalizep = STORE_FLAG_VALUE;\n+\n+      else if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n+\t       && ((STORE_FLAG_VALUE & GET_MODE_MASK (mode))\n+\t\t   == (unsigned HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1)))\n+\t;\n+      else\n+\treturn 0;\n+    }\n+\n   /* If optimizing, use different pseudo registers for each insn, instead\n      of reusing the same pseudo.  This leads to better CSE, but slows\n      down the compiler, since there are more pseudos */\n   subtarget = (!optimize\n \t       && (target_mode == mode)) ? target : NULL_RTX;\n+  trueval = GEN_INT (normalizep ? normalizep : STORE_FLAG_VALUE);\n+\n+  /* For floating-point comparisons, try the reverse comparison or try\n+     changing the \"orderedness\" of the comparison.  */\n+  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    {\n+      enum rtx_code first_code;\n+      bool and_them;\n+\n+      rcode = reverse_condition_maybe_unordered (code);\n+      if (can_compare_p (rcode, mode, ccp_store_flag)\n+          && (code == ORDERED || code == UNORDERED\n+\t      || (! HONOR_NANS (mode) && (code == LTGT || code == UNEQ))\n+\t      || (! HONOR_SNANS (mode) && (code == EQ || code == NE))))\n+\t{\n+\t  /* For the reverse comparison, use either an addition or a XOR.  */\n+\t  if ((STORE_FLAG_VALUE == 1 && normalizep == -1)\n+\t      || (STORE_FLAG_VALUE == -1 && normalizep == 1))\n+\t    {\n+\t      tem = emit_store_flag (subtarget, rcode, op0, op1, mode, 0,\n+\t\t\t\t     STORE_FLAG_VALUE);\n+\t      if (tem)\n+                return expand_binop (target_mode, add_optab, tem,\n+\t\t\t\t     GEN_INT (normalizep),\n+\t\t\t\t     target, 0, OPTAB_WIDEN);\n+\t    }\n+\t  else\n+\t    {\n+\t      tem = emit_store_flag (subtarget, rcode, op0, op1, mode, 0,\n+\t\t\t\t     normalizep);\n+\t      if (tem)\n+                return expand_binop (target_mode, xor_optab, tem, trueval,\n+\t\t\t\t     target, INTVAL (trueval) >= 0, OPTAB_WIDEN);\n+\t    }\n+\t}\n+\n+      delete_insns_since (last);\n+\n+      /* Cannot split ORDERED and UNORDERED, only try the above trick.   */\n+      if (code == ORDERED || code == UNORDERED)\n+\treturn 0;\n+\t\n+      and_them = split_comparison (code, mode, &first_code, &code);\n+\n+      /* If there are no NaNs, the first comparison should always fall through.\n+         Effectively change the comparison to the other one.  */\n+      if (!HONOR_NANS (mode))\n+\t{\n+          gcc_assert (first_code == (and_them ? ORDERED : UNORDERED));\n+\t  return emit_store_flag (target, code, op0, op1, mode, 0, normalizep);\n+\t}\n+\n+#ifdef HAVE_conditional_move\n+      /* Try using a setcc instruction for ORDERED/UNORDERED, followed by a\n+\t conditional move.  */\n+      tem = emit_store_flag (subtarget, first_code, op0, op1, mode, 0, normalizep);\n+      if (tem == 0)\n+\treturn 0;\n+\n+      if (and_them)\n+        tem = emit_conditional_move (target, code, op0, op1, mode,\n+\t\t\t\t     tem, const0_rtx, GET_MODE (tem), 0);\n+      else\n+        tem = emit_conditional_move (target, code, op0, op1, mode,\n+\t\t\t\t     trueval, tem, GET_MODE (tem), 0);\n+\n+      if (tem == 0)\n+        delete_insns_since (last);\n+      return tem;\n+#else\n+      return 0;\n+#endif\n+    }\n \n-  /* If we reached here, we can't do this with a scc insn.  However, there\n-     are some comparisons that can be done directly.  For example, if\n-     this is an equality comparison of integers, we can try to exclusive-or\n+  /* The remaining tricks only apply to integer comparisons.  */\n+\n+  if (GET_MODE_CLASS (mode) != MODE_INT)\n+    return 0;\n+\n+  /* If this is an equality comparison of integers, we can try to exclusive-or\n      (or subtract) the two operands and use a recursive call to try the\n      comparison with zero.  Don't do any of these cases if branches are\n      very cheap.  */\n \n-  if (BRANCH_COST (optimize_insn_for_speed_p (),\n-\t\t   false) > 0\n-      && GET_MODE_CLASS (mode) == MODE_INT && (code == EQ || code == NE)\n-      && op1 != const0_rtx)\n+  if ((code == EQ || code == NE) && op1 != const0_rtx)\n     {\n       tem = expand_binop (mode, xor_optab, op0, op1, subtarget, 1,\n \t\t\t  OPTAB_WIDEN);\n@@ -5420,40 +5525,57 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n       if (tem != 0)\n \ttem = emit_store_flag (target, code, tem, const0_rtx,\n \t\t\t       mode, unsignedp, normalizep);\n-      if (tem == 0)\n-\tdelete_insns_since (last);\n-      return tem;\n+      if (tem != 0)\n+\treturn tem;\n+\n+      delete_insns_since (last);\n+    }\n+\n+  /* For integer comparisons, try the reverse comparison.  However, for\n+     small X and if we'd have anyway to extend, implementing \"X != 0\"\n+     as \"-(int)X >> 31\" is still cheaper than inverting \"(int)X == 0\".  */\n+  rcode = reverse_condition (code);\n+  if (can_compare_p (rcode, mode, ccp_store_flag)\n+      && ! (optab_handler (cstore_optab, mode)->insn_code == CODE_FOR_nothing\n+\t    && code == NE\n+\t    && GET_MODE_SIZE (mode) < UNITS_PER_WORD\n+\t    && op1 == const0_rtx))\n+    {\n+      /* Again, for the reverse comparison, use either an addition or a XOR.  */\n+      if ((STORE_FLAG_VALUE == 1 && normalizep == -1)\n+\t  || (STORE_FLAG_VALUE == -1 && normalizep == 1))\n+\t{\n+\t  tem = emit_store_flag (subtarget, rcode, op0, op1, mode, 0,\n+\t\t\t\t STORE_FLAG_VALUE);\n+\t  if (tem != 0)\n+            tem = expand_binop (target_mode, add_optab, tem,\n+\t\t\t\tGEN_INT (normalizep), target, 0, OPTAB_WIDEN);\n+\t}\n+      else\n+\t{\n+\t  tem = emit_store_flag (subtarget, rcode, op0, op1, mode, 0,\n+\t\t\t\t normalizep);\n+\t  if (tem != 0)\n+            tem = expand_binop (target_mode, xor_optab, tem, trueval, target,\n+\t\t\t\tINTVAL (trueval) >= 0, OPTAB_WIDEN);\n+\t}\n+\n+      if (tem != 0)\n+\treturn tem;\n+      delete_insns_since (last);\n     }\n \n   /* Some other cases we can do are EQ, NE, LE, and GT comparisons with\n      the constant zero.  Reject all other comparisons at this point.  Only\n      do LE and GT if branches are expensive since they are expensive on\n      2-operand machines.  */\n \n-  if (BRANCH_COST (optimize_insn_for_speed_p (),\n-\t\t   false) == 0\n-      || GET_MODE_CLASS (mode) != MODE_INT || op1 != const0_rtx\n+  if (op1 != const0_rtx\n       || (code != EQ && code != NE\n \t  && (BRANCH_COST (optimize_insn_for_speed_p (),\n \t\t\t   false) <= 1 || (code != LE && code != GT))))\n     return 0;\n \n-  /* See what we need to return.  We can only return a 1, -1, or the\n-     sign bit.  */\n-\n-  if (normalizep == 0)\n-    {\n-      if (STORE_FLAG_VALUE == 1 || STORE_FLAG_VALUE == -1)\n-\tnormalizep = STORE_FLAG_VALUE;\n-\n-      else if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t       && ((STORE_FLAG_VALUE & GET_MODE_MASK (mode))\n-\t\t   == (unsigned HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1)))\n-\t;\n-      else\n-\treturn 0;\n-    }\n-\n   /* Try to put the result of the comparison in the sign bit.  Assume we can't\n      do the necessary operation below.  */\n \n@@ -5555,7 +5677,9 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \n   if (tem)\n     {\n-      if (GET_MODE (tem) != target_mode)\n+      if (!target)\n+        ;\n+      else if (GET_MODE (tem) != target_mode)\n \t{\n \t  convert_move (target, tem, 0);\n \t  tem = target;\n@@ -5579,27 +5703,68 @@ emit_store_flag_force (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t\t       enum machine_mode mode, int unsignedp, int normalizep)\n {\n   rtx tem, label;\n+  rtx trueval, falseval;\n \n   /* First see if emit_store_flag can do the job.  */\n   tem = emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep);\n   if (tem != 0)\n     return tem;\n \n-  if (normalizep == 0)\n-    normalizep = 1;\n+  if (!target)\n+    target = gen_reg_rtx (word_mode);\n \n-  /* If this failed, we have to do this with set/compare/jump/set code.  */\n+  /* If this failed, we have to do this with set/compare/jump/set code.\n+     For foo != 0, if foo is in OP0, just replace it with 1 if nonzero.  */\n+  trueval = normalizep ? GEN_INT (normalizep) : const1_rtx;\n+  if (code == NE \n+      && GET_MODE_CLASS (mode) == MODE_INT\n+      && REG_P (target)\n+      && op0 == target\n+      && op1 == const0_rtx)\n+    {\n+      label = gen_label_rtx ();\n+      do_compare_rtx_and_jump (target, const0_rtx, EQ, unsignedp,\n+\t\t\t       mode, NULL_RTX, NULL_RTX, label);\n+      emit_move_insn (target, trueval);\n+      emit_label (label);\n+      return target;\n+    }\n \n   if (!REG_P (target)\n       || reg_mentioned_p (target, op0) || reg_mentioned_p (target, op1))\n     target = gen_reg_rtx (GET_MODE (target));\n \n-  emit_move_insn (target, const1_rtx);\n+  /* Jump in the right direction if the target cannot implement CODE\n+     but can jump on its reverse condition.  */\n+  falseval = const0_rtx;\n+  if (! can_compare_p (code, mode, ccp_jump)\n+      && (! FLOAT_MODE_P (mode)\n+          || code == ORDERED || code == UNORDERED\n+          || (! HONOR_NANS (mode) && (code == LTGT || code == UNEQ))\n+          || (! HONOR_SNANS (mode) && (code == EQ || code == NE))))\n+    {\n+      enum rtx_code rcode;\n+      if (FLOAT_MODE_P (mode))\n+        rcode = reverse_condition_maybe_unordered (code);\n+      else\n+        rcode = reverse_condition (code);\n+\n+      /* Canonicalize to UNORDERED for the libcall.  */\n+      if (can_compare_p (rcode, mode, ccp_jump)\n+          || (code == ORDERED && ! can_compare_p (ORDERED, mode, ccp_jump)))\n+\t{\n+\t  falseval = trueval;\n+\t  trueval = const0_rtx;\n+\t  code = rcode;\n+\t}\n+    }\n+\n+  emit_move_insn (target, trueval);\n   label = gen_label_rtx ();\n   do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode, NULL_RTX,\n \t\t\t   NULL_RTX, label);\n \n-  emit_move_insn (target, const0_rtx);\n+  emit_move_insn (target, falseval);\n   emit_label (label);\n \n   return target;"}, {"sha": "d390b0a2cd029f26b235ef8dde66ac3614ed2597", "filename": "gcc/expr.c", "status": "modified", "additions": 6, "deletions": 84, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/495499daead6ed7050db2af715fabd4f472595cd/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/495499daead6ed7050db2af715fabd4f472595cd/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=495499daead6ed7050db2af715fabd4f472595cd", "patch": "@@ -9109,50 +9109,9 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       temp = do_store_flag (exp,\n \t\t\t    modifier != EXPAND_STACK_PARM ? target : NULL_RTX,\n \t\t\t    tmode != VOIDmode ? tmode : mode);\n-      if (temp != 0)\n-\treturn temp;\n-\n-      /* For foo != 0, load foo, and if it is nonzero load 1 instead.  */\n-      if (code == NE_EXPR && integer_zerop (TREE_OPERAND (exp, 1))\n-\t  && original_target\n-\t  && REG_P (original_target)\n-\t  && (GET_MODE (original_target)\n-\t      == TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)))))\n-\t{\n-\t  temp = expand_expr (TREE_OPERAND (exp, 0), original_target,\n-\t\t\t      VOIDmode, EXPAND_NORMAL);\n-\n-\t  /* If temp is constant, we can just compute the result.  */\n-\t  if (CONST_INT_P (temp))\n-\t    {\n-\t      if (INTVAL (temp) != 0)\n-\t        emit_move_insn (target, const1_rtx);\n-\t      else\n-\t        emit_move_insn (target, const0_rtx);\n-\n-\t      return target;\n-\t    }\n-\n-\t  if (temp != original_target)\n-\t    {\n-\t      enum machine_mode mode1 = GET_MODE (temp);\n-\t      if (mode1 == VOIDmode)\n-\t\tmode1 = tmode != VOIDmode ? tmode : mode;\n-\n-\t      temp = copy_to_mode_reg (mode1, temp);\n-\t    }\n-\n-\t  op1 = gen_label_rtx ();\n-\t  emit_cmp_and_jump_insns (temp, const0_rtx, EQ, NULL_RTX,\n-\t\t\t\t   GET_MODE (temp), unsignedp, op1);\n-\t  emit_move_insn (temp, const1_rtx);\n-\t  emit_label (op1);\n-\t  return temp;\n-\t}\n+      gcc_assert (temp);\n+      return temp;\n \n-      /* If no set-flag instruction, must generate a conditional store\n-\t into a temporary variable.  Drop through and handle this\n-\t like && and ||.  */\n       /* Although TRUTH_{AND,OR}IF_EXPR aren't present in GIMPLE, they\n \t are occassionally created by folding during expansion.  */\n     case TRUTH_ANDIF_EXPR:\n@@ -9751,8 +9710,7 @@ string_constant (tree arg, tree *ptr_offset)\n }\n \f\n /* Generate code to calculate EXP using a store-flag instruction\n-   and return an rtx for the result.  EXP is either a comparison\n-   or a TRUTH_NOT_EXPR whose operand is a comparison.\n+   and return an rtx for the result.  EXP is a comparison.\n \n    If TARGET is nonzero, store the result there if convenient.\n \n@@ -9774,19 +9732,9 @@ do_store_flag (tree exp, rtx target, enum machine_mode mode)\n   tree arg0, arg1, type;\n   tree tem;\n   enum machine_mode operand_mode;\n-  int invert = 0;\n   int unsignedp;\n   rtx op0, op1;\n   rtx subtarget = target;\n-  rtx result, label;\n-\n-  /* If this is a TRUTH_NOT_EXPR, set a flag indicating we must invert the\n-     result at the end.  We can't simply invert the test since it would\n-     have already been inverted if it were valid.  This case occurs for\n-     some floating-point comparisons.  */\n-\n-  if (TREE_CODE (exp) == TRUTH_NOT_EXPR)\n-    invert = 1, exp = TREE_OPERAND (exp, 0);\n \n   arg0 = TREE_OPERAND (exp, 0);\n   arg1 = TREE_OPERAND (exp, 1);\n@@ -9916,10 +9864,6 @@ do_store_flag (tree exp, rtx target, enum machine_mode mode)\n \t\t\t  target, VOIDmode, EXPAND_NORMAL);\n     }\n \n-  /* Now see if we are likely to be able to do this.  Return if not.  */\n-  if (! can_compare_p (code, operand_mode, ccp_store_flag))\n-    return 0;\n-\n   if (! get_subtarget (target)\n       || GET_MODE (subtarget) != operand_mode)\n     subtarget = 0;\n@@ -9929,31 +9873,9 @@ do_store_flag (tree exp, rtx target, enum machine_mode mode)\n   if (target == 0)\n     target = gen_reg_rtx (mode);\n \n-  result = emit_store_flag (target, code, op0, op1,\n-\t\t\t    operand_mode, unsignedp, 1);\n-\n-  if (result)\n-    {\n-      if (invert)\n-\tresult = expand_binop (mode, xor_optab, result, const1_rtx,\n-\t\t\t       result, 0, OPTAB_LIB_WIDEN);\n-      return result;\n-    }\n-\n-  /* If this failed, we have to do this with set/compare/jump/set code.  */\n-  if (!REG_P (target)\n-      || reg_mentioned_p (target, op0) || reg_mentioned_p (target, op1))\n-    target = gen_reg_rtx (GET_MODE (target));\n-\n-  emit_move_insn (target, invert ? const0_rtx : const1_rtx);\n-  label = gen_label_rtx ();\n-  do_compare_rtx_and_jump (op0, op1, code, unsignedp, operand_mode, NULL_RTX,\n-\t\t\t   NULL_RTX, label);\n-\n-  emit_move_insn (target, invert ? const1_rtx : const0_rtx);\n-  emit_label (label);\n-\n-  return target;\n+  /* Try a cstore if possible.  */\n+  return emit_store_flag_force (target, code, op0, op1,\n+\t\t\t        operand_mode, unsignedp, 1);\n }\n \f\n "}]}