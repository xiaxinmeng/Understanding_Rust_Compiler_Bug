{"sha": "f8862a1b2afad9d107ad505de2bf554705ebdb38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg4NjJhMWIyYWZhZDlkMTA3YWQ1MDVkZTJiZjU1NDcwNWViZGIzOA==", "commit": {"author": {"name": "Damian Rouson", "email": "damian@sourceryinstitute.org", "date": "2018-01-26T20:14:09Z"}, "committer": {"name": "Alessandro Fanfarillo", "email": "afanfa@gcc.gnu.org", "date": "2018-01-26T20:14:09Z"}, "message": "Partial Failed Images patch\n\nCo-Authored-By: Alessandro Fanfarillo <fanfarillo.gcc@gmail.com>\nCo-Authored-By: Soren Rasmussen <s.c.rasmussen@gmail.com>\n\nFrom-SVN: r257105", "tree": {"sha": "77fadaa9edcf35dc620e4fc70fd49c750295acd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77fadaa9edcf35dc620e4fc70fd49c750295acd5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8862a1b2afad9d107ad505de2bf554705ebdb38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8862a1b2afad9d107ad505de2bf554705ebdb38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8862a1b2afad9d107ad505de2bf554705ebdb38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8862a1b2afad9d107ad505de2bf554705ebdb38/comments", "author": {"login": "rouson", "id": 13108868, "node_id": "MDQ6VXNlcjEzMTA4ODY4", "avatar_url": "https://avatars.githubusercontent.com/u/13108868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rouson", "html_url": "https://github.com/rouson", "followers_url": "https://api.github.com/users/rouson/followers", "following_url": "https://api.github.com/users/rouson/following{/other_user}", "gists_url": "https://api.github.com/users/rouson/gists{/gist_id}", "starred_url": "https://api.github.com/users/rouson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rouson/subscriptions", "organizations_url": "https://api.github.com/users/rouson/orgs", "repos_url": "https://api.github.com/users/rouson/repos", "events_url": "https://api.github.com/users/rouson/events{/privacy}", "received_events_url": "https://api.github.com/users/rouson/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "deece1aa0135de487e7846025efbc8f6cd79ffe2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/deece1aa0135de487e7846025efbc8f6cd79ffe2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/deece1aa0135de487e7846025efbc8f6cd79ffe2"}], "stats": {"total": 834, "additions": 756, "deletions": 78}, "files": [{"sha": "9a2cc320991d84f9737eccf16196f25f7686c687", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -1,3 +1,49 @@\n+2018-01-26  Damian Rouson  <damian@sourceryinstitute.org>\n+\tAlessandro Fanfarillo  <fanfarillo.gcc@gmail.com>\n+\tSoren Rasmussen  <s.c.rasmussen@gmail.com>\n+\n+\tPartial support for Fortran 2018 teams features.\n+\n+\t* array.c (gfc_match_array_ref): add team attribute in coarray\n+\ttransfers.\n+\t* check.c (gfc_check_get_team, gfc_check_team_number): add new\n+\tfunctions for get_team and team_number.\n+\t* dump-parse-tree.c (show_code_node): add new statements: form team,\n+\tchange team, end team, and sync team.\n+\t* expr.c (gfc_find_team_co): add new function.\n+\t* gfortran.h: add new statements.\n+\t* intrinsic.c (add_functions): add get_team and team_number functions.\n+\t* intrinsic.h: add get_team and team_number prototypes for check,\n+\tsimplify, and resolve.\n+\t* iresolve.c (gfc_resolve_get_team, gfc_resolve_team_number): add new\n+\tfunctions.\n+\t* iso-fortran-env.def: add the team_type derived type.\n+\t* match.c (gfc_match_if, gfc_match_form_team, gfc_match_team_number)\n+\t(gfc_match_end_team, gfc_match_sync_team, gfc_match_change_team):\n+\tadd change team, end team, form team, sync team match and functions.\n+\t* match.h: add new prototypes for change team, end team, form team,\n+\tand sync team.\n+\t* parse.c (decode_statement): add cases for change team, end team,\n+\tform team, and sync team.\n+\t* resolve.c: add cases for exec form team, change team, end team, and\n+\tsync team.\n+\t* simplify.c (gfc_simplify_get_team): add new function for get team.\n+\t* st.c (gfc_free_statement): add cases exec for change team, end team,\n+\tform team, sync team.\n+\t* trans-decl.c (gfor_fndecl_caf_form_team)\n+\t(gfor_fndecl_caf_change_team, gfor_fndecl_caf_end_team)\n+\t(gfor_fndecl_caf_sync_team, gfor_fndecl_caf_get_team)\n+\t(gfor_fndecl_caf_team_number): add functions and definitions.\n+\t* trans-intrinsic.c (conv_caf_send, conv_intrinsic_team_number): add\n+\tnew function and team_type argument support.\n+\t* trans-stmt.c (gfc_trans_form_team, gfc_trans_change_team)\n+\t(gfc_trans_end_team, gfc_trans_sync_team): add new functions.\n+\t* trans-stmt.h: add new prototypes.\n+\t* trans-types.c (gfc_get_derived_type): check condition for team_type.\n+\t* trans.c (trans_code): new exec cases for form team, change team, end\n+\tteam, and sync team.\n+\t* trans.h: add new prototypes.\n+\n 2018-01-26  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/83998"}, {"sha": "22a5ddc59de50f7345e331e7138ddd19858c8627", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -158,6 +158,7 @@ gfc_match_array_ref (gfc_array_ref *ar, gfc_array_spec *as, int init,\n   bool matched_bracket = false;\n   gfc_expr *tmp;\n   bool stat_just_seen = false;\n+  bool team_just_seen = false;\n \n   memset (ar, '\\0', sizeof (*ar));\n \n@@ -235,8 +236,21 @@ gfc_match_array_ref (gfc_array_ref *ar, gfc_array_spec *as, int init,\n       if (m == MATCH_ERROR)\n \treturn MATCH_ERROR;\n \n+      team_just_seen = false;\n       stat_just_seen = false;\n-      if (gfc_match(\" , stat = %e\",&tmp) == MATCH_YES && ar->stat == NULL)\n+      if (gfc_match (\" , team = %e\", &tmp) == MATCH_YES && ar->team == NULL)\n+\t{\n+\t  ar->team = tmp;\n+\t  team_just_seen = true;\n+\t}\n+\n+      if (ar->team && !team_just_seen)\n+\t{\n+\t  gfc_error (\"TEAM= attribute in %C misplaced\");\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      if (gfc_match (\" , stat = %e\",&tmp) == MATCH_YES && ar->stat == NULL)\n \t{\n \t  ar->stat = tmp;\n \t  stat_just_seen = true;"}, {"sha": "dbb1aa02111391148e7d2fec8283d419ded39e90", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -1252,6 +1252,20 @@ gfc_check_failed_or_stopped_images (gfc_expr *team, gfc_expr *kind)\n }\n \n \n+bool\n+gfc_check_get_team (gfc_expr *level)\n+{\n+  if (level)\n+    {\n+      gfc_error (\"%qs argument of %qs intrinsic at %L not yet supported\",\n+\t\t gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n+\t\t &level->where);\n+      return false;\n+    }\n+  return true;\n+}\n+\n+\n bool\n gfc_check_atomic_cas (gfc_expr *atom, gfc_expr *old, gfc_expr *compare,\n \t\t      gfc_expr *new_val,  gfc_expr *stat)\n@@ -2264,7 +2278,7 @@ gfc_check_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n \t      return false;\n \t    }\n \t}\n-      \n+\n       if (array->rank == 1 || boundary->rank == 0)\n \t{\n \t  if (!scalar_check (boundary, 2))\n@@ -2313,7 +2327,7 @@ gfc_check_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n \tcase BT_COMPLEX:\n \tcase BT_CHARACTER:\n \t  break;\n-\t  \n+\n \tdefault:\n \t  gfc_error (\"Missing %qs argument to %qs intrinsic at %L for %qs \"\n \t\t     \"of type %qs\", gfc_current_intrinsic_arg[2]->name,\n@@ -5274,6 +5288,33 @@ gfc_check_num_images (gfc_expr *distance, gfc_expr *failed)\n }\n \n \n+bool\n+gfc_check_team_number (gfc_expr *team)\n+{\n+  if (flag_coarray == GFC_FCOARRAY_NONE)\n+    {\n+      gfc_fatal_error (\"Coarrays disabled at %C, use %<-fcoarray=%> to enable\");\n+      return false;\n+    }\n+\n+  if (team)\n+    {\n+      if (team->ts.type != BT_DERIVED\n+\t  || team->ts.u.derived->from_intmod != INTMOD_ISO_FORTRAN_ENV\n+\t  || team->ts.u.derived->intmod_sym_id != ISOFORTRAN_TEAM_TYPE)\n+\t {\n+\t   gfc_error (\"TEAM argument at %L to the intrinsic TEAM_NUMBER \"\n+\t   \t      \"shall be of type TEAM_TYPE\", &team->where);\n+\t   return false;\n+\t }\n+    }\n+  else\n+    return true;\n+\n+  return true;\n+}\n+\n+\n bool\n gfc_check_this_image (gfc_expr *coarray, gfc_expr *dim, gfc_expr *distance)\n {"}, {"sha": "0de2a0f1d6a25b92012d121a82895c52d3959c4f", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -1868,6 +1868,22 @@ show_code_node (int level, gfc_code *c)\n       fputs (\"FAIL IMAGE \", dumpfile);\n       break;\n \n+    case EXEC_CHANGE_TEAM:\n+      fputs (\"CHANGE TEAM\", dumpfile);\n+      break;\n+\n+    case EXEC_END_TEAM:\n+      fputs (\"END TEAM\", dumpfile);\n+      break;\n+\n+    case EXEC_FORM_TEAM:\n+      fputs (\"FORM TEAM\", dumpfile);\n+      break;\n+\n+    case EXEC_SYNC_TEAM:\n+      fputs (\"SYNC TEAM\", dumpfile);\n+      break;\n+\n     case EXEC_SYNC_ALL:\n       fputs (\"SYNC ALL \", dumpfile);\n       if (c->expr2 != NULL)"}, {"sha": "40f20c96ea513020273d9dd640dab323ebfbdc20", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -5060,7 +5060,25 @@ gfc_ref_this_image (gfc_ref *ref)\n }\n \n gfc_expr *\n-gfc_find_stat_co(gfc_expr *e)\n+gfc_find_team_co (gfc_expr *e)\n+{\n+  gfc_ref *ref;\n+\n+  for (ref = e->ref; ref; ref = ref->next)\n+    if (ref->type == REF_ARRAY && ref->u.ar.codimen > 0)\n+      return ref->u.ar.team;\n+\n+  if (e->value.function.actual->expr)\n+    for (ref = e->value.function.actual->expr->ref; ref;\n+\t ref = ref->next)\n+      if (ref->type == REF_ARRAY && ref->u.ar.codimen > 0)\n+\treturn ref->u.ar.team;\n+\n+  return NULL;\n+}\n+\n+gfc_expr *\n+gfc_find_stat_co (gfc_expr *e)\n {\n   gfc_ref *ref;\n "}, {"sha": "f35430dcd20771d89c54f2d8b9b32a0d2c81baf4", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -263,7 +263,8 @@ enum gfc_statement\n   ST_OMP_TASKLOOP_SIMD, ST_OMP_END_TASKLOOP_SIMD, ST_OMP_ORDERED_DEPEND,\n   ST_PROCEDURE, ST_GENERIC, ST_CRITICAL, ST_END_CRITICAL,\n   ST_GET_FCN_CHARACTERISTICS, ST_LOCK, ST_UNLOCK, ST_EVENT_POST,\n-  ST_EVENT_WAIT,ST_FAIL_IMAGE,ST_NONE\n+  ST_EVENT_WAIT, ST_FAIL_IMAGE, ST_FORM_TEAM, ST_CHANGE_TEAM,\n+  ST_END_TEAM, ST_SYNC_TEAM, ST_NONE\n };\n \n /* Types of interfaces that we can have.  Assignment interfaces are\n@@ -455,6 +456,7 @@ enum gfc_isym_id\n   GFC_ISYM_GETGID,\n   GFC_ISYM_GETLOG,\n   GFC_ISYM_GETPID,\n+  GFC_ISYM_GET_TEAM,\n   GFC_ISYM_GETUID,\n   GFC_ISYM_GMTIME,\n   GFC_ISYM_HOSTNM,\n@@ -597,6 +599,7 @@ enum gfc_isym_id\n   GFC_ISYM_SYSTEM_CLOCK,\n   GFC_ISYM_TAN,\n   GFC_ISYM_TANH,\n+  GFC_ISYM_TEAM_NUMBER,\n   GFC_ISYM_THIS_IMAGE,\n   GFC_ISYM_TIME,\n   GFC_ISYM_TIME8,\n@@ -1913,6 +1916,7 @@ typedef struct gfc_array_ref\n   int dimen;\t\t\t/* # of components in the reference */\n   int codimen;\n   bool in_allocate;\t\t/* For coarray checks. */\n+  gfc_expr *team;\n   gfc_expr *stat;\n   locus where;\n   gfc_array_spec *as;\n@@ -2497,6 +2501,7 @@ enum gfc_exec_op\n   EXEC_OPEN, EXEC_CLOSE, EXEC_WAIT,\n   EXEC_READ, EXEC_WRITE, EXEC_IOLENGTH, EXEC_TRANSFER, EXEC_DT_END,\n   EXEC_BACKSPACE, EXEC_ENDFILE, EXEC_INQUIRE, EXEC_REWIND, EXEC_FLUSH,\n+  EXEC_FORM_TEAM, EXEC_CHANGE_TEAM, EXEC_END_TEAM, EXEC_SYNC_TEAM,\n   EXEC_LOCK, EXEC_UNLOCK, EXEC_EVENT_POST, EXEC_EVENT_WAIT, EXEC_FAIL_IMAGE,\n   EXEC_OACC_KERNELS_LOOP, EXEC_OACC_PARALLEL_LOOP, EXEC_OACC_ROUTINE,\n   EXEC_OACC_PARALLEL, EXEC_OACC_KERNELS, EXEC_OACC_DATA, EXEC_OACC_HOST_DATA,\n@@ -3223,6 +3228,7 @@ bool gfc_is_coarray (gfc_expr *);\n int gfc_get_corank (gfc_expr *);\n bool gfc_has_ultimate_allocatable (gfc_expr *);\n bool gfc_has_ultimate_pointer (gfc_expr *);\n+gfc_expr* gfc_find_team_co (gfc_expr *);\n gfc_expr* gfc_find_stat_co (gfc_expr *);\n gfc_expr* gfc_build_intrinsic_call (gfc_namespace *, gfc_isym_id, const char*,\n \t\t\t\t    locus, unsigned, ...);"}, {"sha": "a47de4131389f166f187119b0fc5c62553d930be", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 43, "deletions": 32, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -860,7 +860,7 @@ add_sym_5s (const char *name, gfc_isym_id id, enum klass cl, bt type, int kind,\n \t    int kind3, int optional3, sym_intent intent3, const char *a4,\n \t    bt type4, int kind4, int optional4, sym_intent intent4,\n \t    const char *a5, bt type5, int kind5, int optional5,\n-\t    sym_intent intent5) \n+\t    sym_intent intent5)\n {\n   gfc_check_f cf;\n   gfc_simplify_f sf;\n@@ -1246,7 +1246,8 @@ add_functions (void)\n     *num = \"number\", *tm = \"time\", *nm = \"name\", *md = \"mode\",\n     *vl = \"values\", *p1 = \"path1\", *p2 = \"path2\", *com = \"command\",\n     *ca = \"coarray\", *sub = \"sub\", *dist = \"distance\", *failed=\"failed\",\n-    *c_ptr_1 = \"c_ptr_1\", *c_ptr_2 = \"c_ptr_2\", *back = \"back\";\n+    *c_ptr_1 = \"c_ptr_1\", *c_ptr_2 = \"c_ptr_2\", *back = \"back\",\n+    *team = \"team\", *image = \"image\", *level = \"level\";\n \n   int di, dr, dd, dl, dc, dz, ii;\n \n@@ -1282,8 +1283,8 @@ add_functions (void)\n \t     NULL, gfc_simplify_abs, gfc_resolve_abs,\n \t     a, BT_COMPLEX, dz, REQUIRED);\n \n-  add_sym_1 (\"zabs\", GFC_ISYM_ABS, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dd, GFC_STD_GNU, \n-\t     NULL, gfc_simplify_abs, gfc_resolve_abs, \n+  add_sym_1 (\"zabs\", GFC_ISYM_ABS, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dd, GFC_STD_GNU,\n+\t     NULL, gfc_simplify_abs, gfc_resolve_abs,\n \t     a, BT_COMPLEX, dd, REQUIRED);\n \n   make_alias (\"cdabs\", GFC_STD_GNU);\n@@ -1344,8 +1345,8 @@ add_functions (void)\n   make_alias (\"imag\", GFC_STD_GNU);\n   make_alias (\"imagpart\", GFC_STD_GNU);\n \n-  add_sym_1 (\"dimag\", GFC_ISYM_AIMAG, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dd, GFC_STD_GNU, \n-\t     NULL, gfc_simplify_aimag, gfc_resolve_aimag, \n+  add_sym_1 (\"dimag\", GFC_ISYM_AIMAG, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dd, GFC_STD_GNU,\n+\t     NULL, gfc_simplify_aimag, gfc_resolve_aimag,\n \t     z, BT_COMPLEX, dd, REQUIRED);\n \n   make_generic (\"aimag\", GFC_ISYM_AIMAG, GFC_STD_F77);\n@@ -1397,7 +1398,7 @@ add_functions (void)\n \t     x, BT_REAL, dd, REQUIRED);\n \n   make_generic (\"asin\", GFC_ISYM_ASIN, GFC_STD_F77);\n-  \n+\n   add_sym_1 (\"asinh\", GFC_ISYM_ASINH, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dr,\n \t     GFC_STD_F2008, gfc_check_fn_rc2008, gfc_simplify_asinh,\n \t     gfc_resolve_asinh, x, BT_REAL, dr, REQUIRED);\n@@ -1428,7 +1429,7 @@ add_functions (void)\n \t     y, BT_REAL, dr, REQUIRED, x, BT_REAL, dr, REQUIRED);\n \n   make_generic (\"atan\", GFC_ISYM_ATAN, GFC_STD_F77);\n-  \n+\n   add_sym_1 (\"atanh\", GFC_ISYM_ATANH, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dr,\n \t     GFC_STD_F2008, gfc_check_fn_rc2008, gfc_simplify_atanh,\n \t     gfc_resolve_atanh, x, BT_REAL, dr, REQUIRED);\n@@ -1448,7 +1449,7 @@ add_functions (void)\n \t     y, BT_REAL, dd, REQUIRED, x, BT_REAL, dd, REQUIRED);\n \n   make_generic (\"atan2\", GFC_ISYM_ATAN2, GFC_STD_F77);\n-  \n+\n   /* Bessel and Neumann functions for G77 compatibility.  */\n   add_sym_1 (\"besj0\", GFC_ISYM_J0, CLASS_ELEMENTAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_GNU,\n \t     gfc_check_fn_r, gfc_simplify_bessel_j0, gfc_resolve_g77_math1,\n@@ -1613,7 +1614,7 @@ add_functions (void)\n \n   make_generic (\"cmplx\", GFC_ISYM_CMPLX, GFC_STD_F77);\n \n-  add_sym_0 (\"command_argument_count\", GFC_ISYM_COMMAND_ARGUMENT_COUNT, CLASS_INQUIRY, \n+  add_sym_0 (\"command_argument_count\", GFC_ISYM_COMMAND_ARGUMENT_COUNT, CLASS_INQUIRY,\n \t     ACTUAL_NO, BT_INTEGER, di, GFC_STD_F2003, NULL, NULL, NULL);\n \n   make_generic (\"command_argument_count\", GFC_ISYM_COMMAND_ARGUMENT_COUNT,\n@@ -1639,7 +1640,7 @@ add_functions (void)\n \t     z, BT_COMPLEX, dz, REQUIRED);\n \n   add_sym_1 (\"dconjg\", GFC_ISYM_CONJG, CLASS_ELEMENTAL, ACTUAL_YES, BT_COMPLEX, dd, GFC_STD_GNU,\n-\t     NULL, gfc_simplify_conjg, gfc_resolve_conjg, \n+\t     NULL, gfc_simplify_conjg, gfc_resolve_conjg,\n \t     z, BT_COMPLEX, dd, REQUIRED);\n \n   make_generic (\"conjg\", GFC_ISYM_CONJG, GFC_STD_F77);\n@@ -1657,7 +1658,7 @@ add_functions (void)\n \t     x, BT_COMPLEX, dz, REQUIRED);\n \n   add_sym_1 (\"zcos\", GFC_ISYM_COS, CLASS_ELEMENTAL, ACTUAL_YES, BT_COMPLEX, dd, GFC_STD_GNU,\n-\t     NULL, gfc_simplify_cos, gfc_resolve_cos, \n+\t     NULL, gfc_simplify_cos, gfc_resolve_cos,\n \t     x, BT_COMPLEX, dd, REQUIRED);\n \n   make_alias (\"cdcos\", GFC_STD_GNU);\n@@ -1826,7 +1827,7 @@ add_functions (void)\n \t     x, BT_COMPLEX, dz, REQUIRED);\n \n   add_sym_1 (\"zexp\", GFC_ISYM_EXP, CLASS_ELEMENTAL, ACTUAL_YES, BT_COMPLEX, dd,  GFC_STD_GNU,\n-\t     NULL, gfc_simplify_exp, gfc_resolve_exp, \n+\t     NULL, gfc_simplify_exp, gfc_resolve_exp,\n \t     x, BT_COMPLEX, dd, REQUIRED);\n \n   make_alias (\"cdexp\", GFC_STD_GNU);\n@@ -1850,8 +1851,8 @@ add_functions (void)\n \t     ACTUAL_NO, BT_INTEGER, dd, GFC_STD_F2008_TS,\n \t     gfc_check_failed_or_stopped_images,\n \t     gfc_simplify_failed_or_stopped_images,\n-\t     gfc_resolve_failed_images, \"team\", BT_VOID, di, OPTIONAL,\n-\t     \"kind\", BT_INTEGER, di, OPTIONAL);\n+\t     gfc_resolve_failed_images, team, BT_VOID, di, OPTIONAL,\n+\t     kind, BT_INTEGER, di, OPTIONAL);\n \n   add_sym_0 (\"fdate\",  GFC_ISYM_FDATE, CLASS_IMPURE, ACTUAL_NO, BT_CHARACTER,\n \t     dc, GFC_STD_GNU, NULL, NULL, gfc_resolve_fdate);\n@@ -1944,6 +1945,11 @@ add_functions (void)\n \n   make_generic (\"getpid\", GFC_ISYM_GETPID, GFC_STD_GNU);\n \n+  add_sym_1 (\"get_team\", GFC_ISYM_GET_TEAM, CLASS_TRANSFORMATIONAL,\n+\t     ACTUAL_NO, BT_INTEGER, di, GFC_STD_F2008_TS,\n+\t     gfc_check_get_team, NULL, gfc_resolve_get_team,\n+\t     level, BT_INTEGER, di, OPTIONAL);\n+\n   add_sym_0 (\"getuid\", GFC_ISYM_GETUID, CLASS_IMPURE, ACTUAL_NO, BT_INTEGER,\n \t     di, GFC_STD_GNU, NULL, NULL, gfc_resolve_getuid);\n \n@@ -2096,8 +2102,8 @@ add_functions (void)\n \n   add_sym_2 (\"image_status\", GFC_ISYM_IMAGE_STATUS, CLASS_ELEMENTAL, ACTUAL_NO,\n \t     BT_INTEGER, di, GFC_STD_F2008_TS, gfc_check_image_status,\n-\t     gfc_simplify_image_status, gfc_resolve_image_status, \"image\",\n-\t     BT_INTEGER, di, REQUIRED, \"team\", BT_VOID, di, OPTIONAL);\n+\t     gfc_simplify_image_status, gfc_resolve_image_status, image,\n+\t     BT_INTEGER, di, REQUIRED, team, BT_VOID, di, OPTIONAL);\n \n   /* The resolution function for INDEX is called gfc_resolve_index_func\n      because the name gfc_resolve_index is already used in resolve.c.  */\n@@ -2345,7 +2351,7 @@ add_functions (void)\n \t     p1, BT_CHARACTER, dc, REQUIRED, p2, BT_CHARACTER, dc, REQUIRED);\n \n   make_generic (\"link\", GFC_ISYM_LINK, GFC_STD_GNU);\n-  \n+\n   add_sym_1 (\"log\", GFC_ISYM_LOG, CLASS_ELEMENTAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F77,\n \t     gfc_check_fn_rc, gfc_simplify_log, gfc_resolve_log,\n \t     x, BT_REAL, dr, REQUIRED);\n@@ -2543,7 +2549,7 @@ add_functions (void)\n \t       ar, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL,\n \t       msk, BT_LOGICAL, dl, OPTIONAL, kind, BT_INTEGER, di, OPTIONAL,\n \t       back, BT_LOGICAL, dl, OPTIONAL);\n-\t       \n+\n   make_generic (\"minloc\", GFC_ISYM_MINLOC, GFC_STD_F95);\n \n   add_sym_3red (\"minval\", GFC_ISYM_MINVAL, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F95,\n@@ -2747,7 +2753,7 @@ add_functions (void)\n \t     p1, BT_CHARACTER, dc, REQUIRED, p2, BT_CHARACTER, dc, REQUIRED);\n \n   make_generic (\"rename\", GFC_ISYM_RENAME, GFC_STD_GNU);\n-  \n+\n   add_sym_2 (\"repeat\", GFC_ISYM_REPEAT, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_CHARACTER, dc, GFC_STD_F95,\n \t     gfc_check_repeat, gfc_simplify_repeat, gfc_resolve_repeat,\n \t     stg, BT_CHARACTER, dc, REQUIRED, ncopies, BT_INTEGER, di, REQUIRED);\n@@ -2957,7 +2963,7 @@ add_functions (void)\n \t     x, BT_UNKNOWN, 0, REQUIRED);\n   make_from_module();\n \n-  /* COMPILER_OPTIONS and COMPILER_VERSION are part of ISO_FORTRAN_ENV.  */  \n+  /* COMPILER_OPTIONS and COMPILER_VERSION are part of ISO_FORTRAN_ENV.  */\n   add_sym_0 (\"compiler_options\", GFC_ISYM_COMPILER_OPTIONS, CLASS_INQUIRY,\n \t     ACTUAL_NO, BT_CHARACTER, dc, GFC_STD_F2008,\n \t     NULL, gfc_simplify_compiler_options, NULL);\n@@ -3013,16 +3019,16 @@ add_functions (void)\n \t     ACTUAL_NO, BT_INTEGER, dd, GFC_STD_F2008_TS,\n \t     gfc_check_failed_or_stopped_images,\n \t     gfc_simplify_failed_or_stopped_images,\n-\t     gfc_resolve_stopped_images, \"team\", BT_VOID, di, OPTIONAL,\n-\t     \"kind\", BT_INTEGER, di, OPTIONAL);\n+\t     gfc_resolve_stopped_images, team, BT_VOID, di, OPTIONAL,\n+\t     kind, BT_INTEGER, di, OPTIONAL);\n \n   add_sym_2 (\"storage_size\", GFC_ISYM_STORAGE_SIZE, CLASS_INQUIRY, ACTUAL_NO,\n \t     BT_INTEGER, di, GFC_STD_F2008,\n \t     gfc_check_storage_size, gfc_simplify_storage_size,\n \t     gfc_resolve_storage_size,\n \t     a, BT_UNKNOWN, 0, REQUIRED,\n \t     kind, BT_INTEGER, di, OPTIONAL);\n-  \n+\n   add_sym_3red (\"sum\", GFC_ISYM_SUM, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F95,\n \t\tgfc_check_product_sum, gfc_simplify_sum, gfc_resolve_sum,\n \t\tar, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL,\n@@ -3062,6 +3068,11 @@ add_functions (void)\n \n   make_generic (\"tanh\", GFC_ISYM_TANH, GFC_STD_F77);\n \n+  add_sym_1 (\"team_number\", GFC_ISYM_TEAM_NUMBER, CLASS_TRANSFORMATIONAL,\n+\t     ACTUAL_YES, BT_INTEGER, di, GFC_STD_F2008_TS,\n+\t     gfc_check_team_number, NULL, gfc_resolve_team_number,\n+\t     team, BT_DERIVED, di, OPTIONAL);\n+\n   add_sym_3 (\"this_image\", GFC_ISYM_THIS_IMAGE, CLASS_INQUIRY, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F2008,\n \t     gfc_check_this_image, gfc_simplify_this_image, gfc_resolve_this_image,\n \t     ca, BT_REAL, dr, OPTIONAL, dm, BT_INTEGER, ii, OPTIONAL,\n@@ -3158,11 +3169,11 @@ add_functions (void)\n \t     bck, BT_LOGICAL, dl, OPTIONAL, kind, BT_INTEGER, di, OPTIONAL);\n \n   make_generic (\"verify\", GFC_ISYM_VERIFY, GFC_STD_F95);\n-    \n+\n   add_sym_1 (\"loc\", GFC_ISYM_LOC, CLASS_IMPURE, ACTUAL_NO, BT_INTEGER, ii,\n \t     GFC_STD_GNU, gfc_check_loc, NULL, gfc_resolve_loc,\n \t     x, BT_UNKNOWN, 0, REQUIRED);\n-\t\t\n+\n   make_generic (\"loc\", GFC_ISYM_LOC, GFC_STD_GNU);\n \n   if (flag_dec_math)\n@@ -4544,11 +4555,11 @@ check_specific (gfc_intrinsic_sym *specific, gfc_expr *expr, int error_flag)\n       first_expr = arg->expr;\n \n       for ( ; arg && arg->expr; arg = arg->next, n++)\n-\tif (!gfc_check_conformance (first_expr, arg->expr, \n+\tif (!gfc_check_conformance (first_expr, arg->expr,\n \t\t\t\t    \"arguments '%s' and '%s' for \"\n-\t\t\t\t    \"intrinsic '%s'\", \n-\t\t\t\t    gfc_current_intrinsic_arg[0]->name, \n-\t\t\t\t    gfc_current_intrinsic_arg[n]->name, \n+\t\t\t\t    \"intrinsic '%s'\",\n+\t\t\t\t    gfc_current_intrinsic_arg[0]->name,\n+\t\t\t\t    gfc_current_intrinsic_arg[n]->name,\n \t\t\t\t    gfc_current_intrinsic))\n \t  return false;\n     }\n@@ -5153,12 +5164,12 @@ gfc_warn_intrinsic_shadow (const gfc_symbol* sym, bool in_module, bool func)\n   /* Try to find an intrinsic of the same name.  */\n   if (func)\n     isym = gfc_find_function (sym->name);\n-  else  \n+  else\n     isym = gfc_find_subroutine (sym->name);\n \n   /* If no intrinsic was found with this name or it's not included in the\n      selected standard, everything's fine.  */\n-  if (!isym || !gfc_check_intrinsic_standard (isym, NULL, true, \n+  if (!isym || !gfc_check_intrinsic_standard (isym, NULL, true,\n \t\t\t\t\t      sym->declared_at))\n     return;\n "}, {"sha": "a483bfa0c7b2b2f584eaa9c61efa84aa0310ea58", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -83,6 +83,7 @@ bool gfc_check_fn_r (gfc_expr *);\n bool gfc_check_fn_rc (gfc_expr *);\n bool gfc_check_fn_rc2008 (gfc_expr *);\n bool gfc_check_fnum (gfc_expr *);\n+bool gfc_check_get_team (gfc_expr *);\n bool gfc_check_hostnm (gfc_expr *);\n bool gfc_check_huge (gfc_expr *);\n bool gfc_check_hypot (gfc_expr *, gfc_expr *);\n@@ -169,6 +170,7 @@ bool gfc_check_stat (gfc_expr *, gfc_expr *);\n bool gfc_check_storage_size (gfc_expr *, gfc_expr *);\n bool gfc_check_sum (gfc_expr *, gfc_expr *, gfc_expr *);\n bool gfc_check_symlnk (gfc_expr *, gfc_expr *);\n+bool gfc_check_team_number (gfc_expr *);\n bool gfc_check_transf_bit_intrins (gfc_actual_arglist *);\n bool gfc_check_transfer (gfc_expr *, gfc_expr *, gfc_expr *);\n bool gfc_check_transpose (gfc_expr *);\n@@ -300,6 +302,7 @@ gfc_expr *gfc_simplify_float (gfc_expr *);\n gfc_expr *gfc_simplify_floor (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_fraction (gfc_expr *);\n gfc_expr *gfc_simplify_gamma (gfc_expr *);\n+gfc_expr *gfc_simplify_get_team (gfc_expr *);\n gfc_expr *gfc_simplify_huge (gfc_expr *);\n gfc_expr *gfc_simplify_hypot (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_iachar (gfc_expr *, gfc_expr *);\n@@ -498,6 +501,7 @@ void gfc_resolve_gamma (gfc_expr *, gfc_expr *);\n void gfc_resolve_getcwd (gfc_expr *, gfc_expr *);\n void gfc_resolve_getgid (gfc_expr *);\n void gfc_resolve_getpid (gfc_expr *);\n+void gfc_resolve_get_team (gfc_expr *, gfc_expr *);\n void gfc_resolve_getuid (gfc_expr *);\n void gfc_resolve_hostnm (gfc_expr *, gfc_expr *);\n void gfc_resolve_hypot (gfc_expr *, gfc_expr *, gfc_expr *);\n@@ -595,6 +599,7 @@ void gfc_resolve_symlnk (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_system (gfc_expr *, gfc_expr *);\n void gfc_resolve_tan (gfc_expr *, gfc_expr *);\n void gfc_resolve_tanh (gfc_expr *, gfc_expr *);\n+void gfc_resolve_team_number (gfc_expr *, gfc_expr *);\n void gfc_resolve_this_image (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_time (gfc_expr *);\n void gfc_resolve_time8 (gfc_expr *);"}, {"sha": "21344321709469dd2944778fb4da85d5da0fbda2", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 48, "deletions": 22, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -36,10 +36,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"constructor.h\"\n #include \"arith.h\"\n \n-/* Given printf-like arguments, return a stable version of the result string. \n+/* Given printf-like arguments, return a stable version of the result string.\n \n    We already have a working, optimized string hashing table in the form of\n-   the identifier table.  Reusing this table is likely not to be wasted, \n+   the identifier table.  Reusing this table is likely not to be wasted,\n    since if the function name makes it to the gimple output of the frontend,\n    we'll have to create the identifier anyway.  */\n \n@@ -316,7 +316,7 @@ gfc_resolve_aint (gfc_expr *f, gfc_expr *a, gfc_expr *kind)\n {\n   gfc_typespec ts;\n   gfc_clear_ts (&ts);\n-  \n+\n   f->ts.type = a->ts.type;\n   f->ts.kind = (kind == NULL) ? a->ts.kind : mpz_get_si (kind->value.integer);\n \n@@ -363,7 +363,7 @@ gfc_resolve_anint (gfc_expr *f, gfc_expr *a, gfc_expr *kind)\n {\n   gfc_typespec ts;\n   gfc_clear_ts (&ts);\n-  \n+\n   f->ts.type = a->ts.type;\n   f->ts.kind = (kind == NULL) ? a->ts.kind : mpz_get_si (kind->value.integer);\n \n@@ -458,7 +458,7 @@ gfc_resolve_besn (gfc_expr *f, gfc_expr *n, gfc_expr *x)\n {\n   gfc_typespec ts;\n   gfc_clear_ts (&ts);\n-  \n+\n   f->ts = x->ts;\n   if (n->ts.kind != gfc_c_int_kind)\n     {\n@@ -475,7 +475,7 @@ gfc_resolve_bessel_n2 (gfc_expr *f, gfc_expr *n1, gfc_expr *n2, gfc_expr *x)\n {\n   gfc_typespec ts;\n   gfc_clear_ts (&ts);\n-  \n+\n   f->ts = x->ts;\n   f->rank = 1;\n   if (n1->expr_type == EXPR_CONSTANT && n2->expr_type == EXPR_CONSTANT)\n@@ -811,7 +811,7 @@ gfc_resolve_cshift (gfc_expr *f, gfc_expr *array, gfc_expr *shift,\n   m = gfc_default_integer_kind;\n   if (dim != NULL)\n     m = m < dim->ts.kind ? dim->ts.kind : m;\n-  \n+\n   /* Convert shift to at least m, so we don't need\n       kind=1 and kind=2 versions of the library functions.  */\n   if (shift->ts.kind < m)\n@@ -822,7 +822,7 @@ gfc_resolve_cshift (gfc_expr *f, gfc_expr *array, gfc_expr *shift,\n       ts.kind = m;\n       gfc_convert_type_warn (shift, &ts, 2, 0);\n     }\n- \n+\n   if (dim != NULL)\n     {\n       if (dim->expr_type != EXPR_CONSTANT && dim->symtree != NULL\n@@ -861,7 +861,7 @@ gfc_resolve_ctime (gfc_expr *f, gfc_expr *time)\n {\n   gfc_typespec ts;\n   gfc_clear_ts (&ts);\n-  \n+\n   f->ts.type = BT_CHARACTER;\n   f->ts.kind = gfc_default_character_kind;\n \n@@ -976,7 +976,7 @@ gfc_resolve_eoshift (gfc_expr *f, gfc_expr *array, gfc_expr *shift,\n   m = gfc_default_integer_kind;\n   if (dim != NULL)\n     m = m < dim->ts.kind ? dim->ts.kind : m;\n-  \n+\n   /* Convert shift to at least m, so we don't need\n       kind=1 and kind=2 versions of the library functions.  */\n   if (shift->ts.kind < m)\n@@ -987,7 +987,7 @@ gfc_resolve_eoshift (gfc_expr *f, gfc_expr *array, gfc_expr *shift,\n       ts.kind = m;\n       gfc_convert_type_warn (shift, &ts, 2, 0);\n     }\n- \n+\n   if (dim != NULL)\n     {\n       if (dim->expr_type != EXPR_CONSTANT && dim->symtree != NULL\n@@ -1225,7 +1225,7 @@ void\n gfc_resolve_iand (gfc_expr *f, gfc_expr *i, gfc_expr *j)\n {\n   /* If the kind of i and j are different, then g77 cross-promoted the\n-     kinds to the largest value.  The Fortran 95 standard requires the \n+     kinds to the largest value.  The Fortran 95 standard requires the\n      kinds to match.  */\n   if (i->ts.kind != j->ts.kind)\n     {\n@@ -1316,7 +1316,7 @@ void\n gfc_resolve_ieor (gfc_expr *f, gfc_expr *i, gfc_expr *j)\n {\n   /* If the kind of i and j are different, then g77 cross-promoted the\n-     kinds to the largest value.  The Fortran 95 standard requires the \n+     kinds to the largest value.  The Fortran 95 standard requires the\n      kinds to match.  */\n   if (i->ts.kind != j->ts.kind)\n     {\n@@ -1335,7 +1335,7 @@ void\n gfc_resolve_ior (gfc_expr *f, gfc_expr *i, gfc_expr *j)\n {\n   /* If the kind of i and j are different, then g77 cross-promoted the\n-     kinds to the largest value.  The Fortran 95 standard requires the \n+     kinds to the largest value.  The Fortran 95 standard requires the\n      kinds to match.  */\n   if (i->ts.kind != j->ts.kind)\n     {\n@@ -1435,7 +1435,7 @@ gfc_resolve_isatty (gfc_expr *f, gfc_expr *u)\n {\n   gfc_typespec ts;\n   gfc_clear_ts (&ts);\n-  \n+\n   f->ts.type = BT_LOGICAL;\n   f->ts.kind = gfc_default_integer_kind;\n   if (u->ts.kind != gfc_c_int_kind)\n@@ -1642,7 +1642,7 @@ gfc_resolve_matmul (gfc_expr *f, gfc_expr *a, gfc_expr *b)\n \t  mpz_init_set (f->shape[0], b->shape[1]);\n \t}\n     }\n-  else \n+  else\n     {\n       /* b->rank == 1 and a->rank == 2 here, all other cases have\n \t been caught in check.c.   */\n@@ -2961,6 +2961,19 @@ gfc_resolve_image_status (gfc_expr *f, gfc_expr *image ATTRIBUTE_UNUSED,\n }\n \n \n+/* Resolve get_team ().  */\n+\n+void\n+gfc_resolve_get_team (gfc_expr *f, gfc_expr *level ATTRIBUTE_UNUSED)\n+{\n+  static char get_team[] = \"_gfortran_caf_get_team\";\n+  f->rank = 0;\n+  f->ts.type = BT_INTEGER;\n+  f->ts.kind = gfc_default_integer_kind;\n+  f->value.function.name = get_team;\n+}\n+\n+\n /* Resolve image_index (...).  */\n \n void\n@@ -2991,6 +3004,19 @@ gfc_resolve_stopped_images (gfc_expr *f, gfc_expr *team ATTRIBUTE_UNUSED,\n }\n \n \n+/* Resolve team_number (team).  */\n+\n+void\n+gfc_resolve_team_number (gfc_expr *f, gfc_expr *team ATTRIBUTE_UNUSED)\n+{\n+  static char team_number[] = \"_gfortran_caf_team_number\";\n+  f->rank = 0;\n+  f->ts.type = BT_INTEGER;\n+  f->ts.kind = gfc_default_integer_kind;\n+  f->value.function.name = team_number;\n+}\n+\n+\n void\n gfc_resolve_this_image (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n \t\t\tgfc_expr *distance ATTRIBUTE_UNUSED)\n@@ -3180,7 +3206,7 @@ gfc_resolve_ttynam (gfc_expr *f, gfc_expr *unit)\n {\n   gfc_typespec ts;\n   gfc_clear_ts (&ts);\n-  \n+\n   f->ts.type = BT_CHARACTER;\n   f->ts.kind = gfc_default_character_kind;\n \n@@ -3399,7 +3425,7 @@ gfc_resolve_random_number (gfc_code *c)\n     name = gfc_get_string (PREFIX (\"random_r%d\"), kind);\n   else\n     name = gfc_get_string (PREFIX (\"arandom_r%d\"), kind);\n-  \n+\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n@@ -3444,7 +3470,7 @@ gfc_resolve_kill_sub (gfc_code *c)\n   name = gfc_get_string (PREFIX (\"kill_i%d_sub\"), kind);\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n-    \n+\n \n void\n gfc_resolve_link_sub (gfc_code *c)\n@@ -3777,7 +3803,7 @@ gfc_resolve_ctime_sub (gfc_code *c)\n {\n   gfc_typespec ts;\n   gfc_clear_ts (&ts);\n-  \n+\n   /* ctime TIME argument is a INTEGER(KIND=8), says the doc */\n   if (c->ext.actual->expr->ts.kind != 8)\n     {\n@@ -3961,7 +3987,7 @@ gfc_resolve_fput_sub (gfc_code *c)\n }\n \n \n-void \n+void\n gfc_resolve_fseek_sub (gfc_code *c)\n {\n   gfc_expr *unit;\n@@ -4035,7 +4061,7 @@ gfc_resolve_ttynam_sub (gfc_code *c)\n {\n   gfc_typespec ts;\n   gfc_clear_ts (&ts);\n-  \n+\n   if (c->ext.actual->expr->ts.kind != gfc_c_int_kind)\n     {\n       ts.type = BT_INTEGER;"}, {"sha": "25f9e0991ba39cd71b1dcf9c03e71eada4a1df43", "filename": "gcc/fortran/iso-fortran-env.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fiso-fortran-env.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fiso-fortran-env.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fiso-fortran-env.def?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -128,6 +128,11 @@ NAMED_DERIVED_TYPE (ISOFORTRAN_EVENT_TYPE, \"event_type\", \\\n \t\t    ?  get_int_kind_from_node (ptr_type_node)\n \t\t    : gfc_default_integer_kind, GFC_STD_F2008_TS)\n \n+NAMED_DERIVED_TYPE (ISOFORTRAN_TEAM_TYPE, \"team_type\", \\\n+\t\t    flag_coarray == GFC_FCOARRAY_LIB\n+\t\t    ? get_int_kind_from_node (ptr_type_node)\n+\t\t    : gfc_default_integer_kind, GFC_STD_F2008_TS)\n+\n #undef NAMED_INTCST\n #undef NAMED_KINDARRAY\n #undef NAMED_FUNCTION"}, {"sha": "cf44fabb2397340afa658933b8fc544ab23341f9", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -1596,18 +1596,21 @@ gfc_match_if (gfc_statement *if_type)\n   match (\"assign\", gfc_match_assign, ST_LABEL_ASSIGNMENT)\n   match (\"backspace\", gfc_match_backspace, ST_BACKSPACE)\n   match (\"call\", gfc_match_call, ST_CALL)\n+  match (\"change team\", gfc_match_change_team, ST_CHANGE_TEAM)\n   match (\"close\", gfc_match_close, ST_CLOSE)\n   match (\"continue\", gfc_match_continue, ST_CONTINUE)\n   match (\"cycle\", gfc_match_cycle, ST_CYCLE)\n   match (\"deallocate\", gfc_match_deallocate, ST_DEALLOCATE)\n   match (\"end file\", gfc_match_endfile, ST_END_FILE)\n+  match (\"end team\", gfc_match_end_team, ST_END_TEAM)\n   match (\"error stop\", gfc_match_error_stop, ST_ERROR_STOP)\n   match (\"event post\", gfc_match_event_post, ST_EVENT_POST)\n   match (\"event wait\", gfc_match_event_wait, ST_EVENT_WAIT)\n   match (\"exit\", gfc_match_exit, ST_EXIT)\n   match (\"fail image\", gfc_match_fail_image, ST_FAIL_IMAGE)\n   match (\"flush\", gfc_match_flush, ST_FLUSH)\n   match (\"forall\", match_simple_forall, ST_FORALL)\n+  match (\"form team\", gfc_match_form_team, ST_FORM_TEAM)\n   match (\"go to\", gfc_match_goto, ST_GOTO)\n   match (\"if\", match_arithmetic_if, ST_ARITHMETIC_IF)\n   match (\"inquire\", gfc_match_inquire, ST_INQUIRE)\n@@ -1624,6 +1627,7 @@ gfc_match_if (gfc_statement *if_type)\n   match (\"sync all\", gfc_match_sync_all, ST_SYNC_CALL);\n   match (\"sync images\", gfc_match_sync_images, ST_SYNC_IMAGES);\n   match (\"sync memory\", gfc_match_sync_memory, ST_SYNC_MEMORY);\n+  match (\"sync team\", gfc_match_sync_team, ST_SYNC_TEAM)\n   match (\"unlock\", gfc_match_unlock, ST_UNLOCK)\n   match (\"where\", match_simple_where, ST_WHERE)\n   match (\"write\", gfc_match_write, ST_WRITE)\n@@ -3348,6 +3352,131 @@ gfc_match_fail_image (void)\n   return MATCH_ERROR;\n }\n \n+/* Match a FORM TEAM statement.  */\n+\n+match\n+gfc_match_form_team (void)\n+{\n+  match m;\n+  gfc_expr *teamid,*team;\n+\n+  if (!gfc_notify_std (GFC_STD_F2008_TS, \"FORM TEAM statement at %C\"))\n+    return MATCH_ERROR;\n+\n+  if (gfc_match_char ('(') == MATCH_NO)\n+    goto syntax;\n+\n+  new_st.op = EXEC_FORM_TEAM;\n+\n+  if (gfc_match (\"%e\", &teamid) != MATCH_YES)\n+    goto syntax;\n+  m = gfc_match_char (',');\n+  if (m == MATCH_ERROR)\n+    goto syntax;\n+  if (gfc_match (\"%e\", &team) != MATCH_YES)\n+    goto syntax;\n+\n+  m = gfc_match_char (')');\n+  if (m == MATCH_NO)\n+    goto syntax;\n+\n+  new_st.expr1 = teamid;\n+  new_st.expr2 = team;\n+\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_syntax_error (ST_FORM_TEAM);\n+\n+  return MATCH_ERROR;\n+}\n+\n+/* Match a CHANGE TEAM statement.  */\n+\n+match\n+gfc_match_change_team (void)\n+{\n+  match m;\n+  gfc_expr *team;\n+\n+  if (!gfc_notify_std (GFC_STD_F2008_TS, \"CHANGE TEAM statement at %C\"))\n+    return MATCH_ERROR;\n+\n+  if (gfc_match_char ('(') == MATCH_NO)\n+    goto syntax;\n+\n+  new_st.op = EXEC_CHANGE_TEAM;\n+\n+  if (gfc_match (\"%e\", &team) != MATCH_YES)\n+    goto syntax;\n+\n+  m = gfc_match_char (')');\n+  if (m == MATCH_NO)\n+    goto syntax;\n+\n+  new_st.expr1 = team;\n+\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_syntax_error (ST_CHANGE_TEAM);\n+\n+  return MATCH_ERROR;\n+}\n+\n+/* Match a END TEAM statement.  */\n+\n+match\n+gfc_match_end_team (void)\n+{\n+  if (!gfc_notify_std (GFC_STD_F2008_TS, \"END TEAM statement at %C\"))\n+    return MATCH_ERROR;\n+\n+  if (gfc_match_char ('(') == MATCH_YES)\n+    goto syntax;\n+\n+  new_st.op = EXEC_END_TEAM;\n+\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_syntax_error (ST_END_TEAM);\n+\n+  return MATCH_ERROR;\n+}\n+\n+/* Match a SYNC TEAM statement.  */\n+\n+match\n+gfc_match_sync_team (void)\n+{\n+  match m;\n+  gfc_expr *team;\n+\n+  if (!gfc_notify_std (GFC_STD_F2008_TS, \"SYNC TEAM statement at %C\"))\n+    return MATCH_ERROR;\n+\n+  if (gfc_match_char ('(') == MATCH_NO)\n+    goto syntax;\n+\n+  new_st.op = EXEC_SYNC_TEAM;\n+\n+  if (gfc_match (\"%e\", &team) != MATCH_YES)\n+    goto syntax;\n+\n+  m = gfc_match_char (')');\n+  if (m == MATCH_NO)\n+    goto syntax;\n+\n+  new_st.expr1 = team;\n+\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_syntax_error (ST_SYNC_TEAM);\n+\n+  return MATCH_ERROR;\n+}\n \n /* Match LOCK/UNLOCK statement. Syntax:\n      LOCK ( lock-variable [ , lock-stat-list ] )"}, {"sha": "418542bd5a64864591d51d7ec71488501fd6624b", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -74,6 +74,10 @@ match gfc_match_event_post (void);\n match gfc_match_event_wait (void);\n match gfc_match_critical (void);\n match gfc_match_fail_image (void);\n+match gfc_match_change_team (void);\n+match gfc_match_end_team (void);\n+match gfc_match_form_team (void);\n+match gfc_match_sync_team (void);\n match gfc_match_block (void);\n match gfc_match_associate (void);\n match gfc_match_do (void);"}, {"sha": "a3693a192f0e3085b839ce2ffa65276d27254aeb", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -451,6 +451,7 @@ decode_statement (void)\n \n     case 'c':\n       match (\"call\", gfc_match_call, ST_CALL);\n+      match (\"change team\", gfc_match_change_team, ST_CHANGE_TEAM);\n       match (\"close\", gfc_match_close, ST_CLOSE);\n       match (\"continue\", gfc_match_continue, ST_CONTINUE);\n       match (\"contiguous\", gfc_match_contiguous, ST_ATTR_DECL);\n@@ -470,6 +471,7 @@ decode_statement (void)\n \n     case 'e':\n       match (\"end file\", gfc_match_endfile, ST_END_FILE);\n+      match (\"end team\", gfc_match_end_team, ST_END_TEAM);\n       match (\"exit\", gfc_match_exit, ST_EXIT);\n       match (\"else\", gfc_match_else, ST_ELSE);\n       match (\"else where\", gfc_match_elsewhere, ST_ELSEWHERE);\n@@ -491,6 +493,7 @@ decode_statement (void)\n       match (\"fail image\", gfc_match_fail_image, ST_FAIL_IMAGE);\n       match (\"final\", gfc_match_final_decl, ST_FINAL);\n       match (\"flush\", gfc_match_flush, ST_FLUSH);\n+      match (\"form team\", gfc_match_form_team, ST_FORM_TEAM);\n       match (\"format\", gfc_match_format, ST_FORMAT);\n       break;\n \n@@ -558,6 +561,7 @@ decode_statement (void)\n       match (\"sync all\", gfc_match_sync_all, ST_SYNC_ALL);\n       match (\"sync images\", gfc_match_sync_images, ST_SYNC_IMAGES);\n       match (\"sync memory\", gfc_match_sync_memory, ST_SYNC_MEMORY);\n+      match (\"sync team\", gfc_match_sync_team, ST_SYNC_TEAM);\n       break;\n \n     case 't':\n@@ -1503,6 +1507,8 @@ next_statement (void)\n   case ST_OMP_TARGET_EXIT_DATA: case ST_OMP_ORDERED_DEPEND: \\\n   case ST_ERROR_STOP: case ST_SYNC_ALL: \\\n   case ST_SYNC_IMAGES: case ST_SYNC_MEMORY: case ST_LOCK: case ST_UNLOCK: \\\n+  case ST_FORM_TEAM: case ST_CHANGE_TEAM: \\\n+  case ST_END_TEAM: case ST_SYNC_TEAM: \\\n   case ST_EVENT_POST: case ST_EVENT_WAIT: case ST_FAIL_IMAGE: \\\n   case ST_OACC_UPDATE: case ST_OACC_WAIT: case ST_OACC_CACHE: \\\n   case ST_OACC_ENTER_DATA: case ST_OACC_EXIT_DATA\n@@ -1834,6 +1840,18 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_FAIL_IMAGE:\n       p = \"FAIL IMAGE\";\n       break;\n+    case ST_CHANGE_TEAM:\n+      p = \"CHANGE TEAM\";\n+      break;\n+    case ST_END_TEAM:\n+      p = \"END TEAM\";\n+      break;\n+    case ST_FORM_TEAM:\n+      p = \"FORM TEAM\";\n+      break;\n+    case ST_SYNC_TEAM:\n+      p = \"SYNC TEAM\";\n+      break;\n     case ST_END_ASSOCIATE:\n       p = \"END ASSOCIATE\";\n       break;"}, {"sha": "8078005d976c043596b2cd4aa522fdadb480d12d", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -11101,6 +11101,10 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  break;\n \n \tcase EXEC_FAIL_IMAGE:\n+\tcase EXEC_FORM_TEAM:\n+\tcase EXEC_CHANGE_TEAM:\n+\tcase EXEC_END_TEAM:\n+\tcase EXEC_SYNC_TEAM:\n \t  break;\n \n \tcase EXEC_ENTRY:"}, {"sha": "2458956055b8917b1dfb15d3bff0fb7901c8af33", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -2892,6 +2892,30 @@ gfc_simplify_failed_or_stopped_images (gfc_expr *team ATTRIBUTE_UNUSED,\n }\n \n \n+gfc_expr *\n+gfc_simplify_get_team (gfc_expr *level ATTRIBUTE_UNUSED)\n+{\n+  if (flag_coarray == GFC_FCOARRAY_NONE)\n+    {\n+      gfc_current_locus = *gfc_current_intrinsic_where;\n+      gfc_fatal_error (\"Coarrays disabled at %C, use %<-fcoarray=%> to enable\");\n+      return &gfc_bad_expr;\n+    }\n+\n+  if (flag_coarray == GFC_FCOARRAY_SINGLE)\n+    {\n+      gfc_expr *result;\n+      result = gfc_get_array_expr (BT_INTEGER, gfc_default_integer_kind, &gfc_current_locus);\n+      result->rank = 0;\n+      return result;\n+    }\n+\n+  /* For fcoarray = lib no simplification is possible, because it is not known\n+     what images failed or are stopped at compile time.  */\n+  return NULL;\n+}\n+\n+\n gfc_expr *\n gfc_simplify_float (gfc_expr *a)\n {\n@@ -3058,7 +3082,7 @@ gfc_simplify_fraction (gfc_expr *x)\n \n #if MPFR_VERSION < MPFR_VERSION_NUM(3,1,0)\n \n-  /* MPFR versions before 3.1.0 do not include mpfr_frexp.  \n+  /* MPFR versions before 3.1.0 do not include mpfr_frexp.\n      TODO: remove the kludge when MPFR 3.1.0 or newer will be required */\n \n   if (mpfr_sgn (x->value.real) == 0)\n@@ -7348,7 +7372,7 @@ gfc_simplify_transfer (gfc_expr *source, gfc_expr *mold, gfc_expr *size)\n \t|| !gfc_is_constant_expr (size))\n     return NULL;\n \n-  if (!gfc_calculate_transfer_sizes (source, mold, size, &source_size, \n+  if (!gfc_calculate_transfer_sizes (source, mold, size, &source_size,\n \t\t\t\t     &result_size, &result_length))\n     return NULL;\n "}, {"sha": "7603cbd94adcbd4a467218fbb09c4c37d02b3bfd", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -121,6 +121,10 @@ gfc_free_statement (gfc_code *p)\n     case EXEC_EVENT_POST:\n     case EXEC_EVENT_WAIT:\n     case EXEC_FAIL_IMAGE:\n+    case EXEC_CHANGE_TEAM:\n+    case EXEC_END_TEAM:\n+    case EXEC_FORM_TEAM:\n+    case EXEC_SYNC_TEAM:\n       break;\n \n     case EXEC_BLOCK:"}, {"sha": "9b0b2a14b8db458f7c01fa21e910bcbf5ba3496e", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 43, "deletions": 5, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -157,6 +157,12 @@ tree gfor_fndecl_caf_fail_image;\n tree gfor_fndecl_caf_failed_images;\n tree gfor_fndecl_caf_image_status;\n tree gfor_fndecl_caf_stopped_images;\n+tree gfor_fndecl_caf_form_team;\n+tree gfor_fndecl_caf_change_team;\n+tree gfor_fndecl_caf_end_team;\n+tree gfor_fndecl_caf_sync_team;\n+tree gfor_fndecl_caf_get_team;\n+tree gfor_fndecl_caf_team_number;\n tree gfor_fndecl_co_broadcast;\n tree gfor_fndecl_co_max;\n tree gfor_fndecl_co_min;\n@@ -3363,7 +3369,7 @@ gfc_build_intrinsic_function_decls (void)\n \t    jtype = gfc_get_int_type (ikinds[jkind]);\n \t    if (itype && jtype)\n \t      {\n-\t\tsprintf(name, PREFIX(\"pow_i%d_i%d\"), ikinds[ikind],\n+\t\tsprintf (name, PREFIX(\"pow_i%d_i%d\"), ikinds[ikind],\n \t\t\tikinds[jkind]);\n \t\tgfor_fndecl_math_powi[jkind][ikind].integer =\n \t\t  gfc_build_library_function_decl (get_identifier (name),\n@@ -3378,7 +3384,7 @@ gfc_build_intrinsic_function_decls (void)\n \t    rtype = gfc_get_real_type (rkinds[rkind]);\n \t    if (rtype && itype)\n \t      {\n-\t\tsprintf(name, PREFIX(\"pow_r%d_i%d\"), rkinds[rkind],\n+\t\tsprintf (name, PREFIX(\"pow_r%d_i%d\"), rkinds[rkind],\n \t\t\tikinds[ikind]);\n \t\tgfor_fndecl_math_powi[rkind][ikind].real =\n \t\t  gfc_build_library_function_decl (get_identifier (name),\n@@ -3390,7 +3396,7 @@ gfc_build_intrinsic_function_decls (void)\n \t    ctype = gfc_get_complex_type (rkinds[rkind]);\n \t    if (ctype && itype)\n \t      {\n-\t\tsprintf(name, PREFIX(\"pow_c%d_i%d\"), rkinds[rkind],\n+\t\tsprintf (name, PREFIX(\"pow_c%d_i%d\"), rkinds[rkind],\n \t\t\tikinds[ikind]);\n \t\tgfor_fndecl_math_powi[rkind][ikind].cmplx =\n \t\t  gfc_build_library_function_decl (get_identifier (name),\n@@ -3642,10 +3648,10 @@ gfc_build_builtin_function_decls (void)\n \tboolean_type_node, pint_type);\n \n       gfor_fndecl_caf_send = gfc_build_library_function_decl_with_spec (\n-\tget_identifier (PREFIX(\"caf_send\")), \".R.RRRRRRW\", void_type_node, 10,\n+\tget_identifier (PREFIX(\"caf_send\")), \".R.RRRRRRWR\", void_type_node, 11,\n \tpvoid_type_node, size_type_node, integer_type_node, pvoid_type_node,\n \tpvoid_type_node, pvoid_type_node, integer_type_node, integer_type_node,\n-\tboolean_type_node, pint_type);\n+\tboolean_type_node, pint_type, pvoid_type_node);\n \n       gfor_fndecl_caf_sendget = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"caf_sendget\")), \".R.RRRR.RRRRRR\",\n@@ -3769,6 +3775,38 @@ gfc_build_builtin_function_decls (void)\n \t    void_type_node, 3, pvoid_type_node, ppvoid_type_node,\n \t    integer_type_node);\n \n+      gfor_fndecl_caf_form_team\n+\t= gfc_build_library_function_decl_with_spec (\n+\t    get_identifier (PREFIX(\"caf_form_team\")), \"RWR\",\n+\t    void_type_node, 3, integer_type_node, ppvoid_type_node,\n+\t    integer_type_node);\n+\n+      gfor_fndecl_caf_change_team\n+\t= gfc_build_library_function_decl_with_spec (\n+\t    get_identifier (PREFIX(\"caf_change_team\")), \"RR\",\n+\t    void_type_node, 2, ppvoid_type_node,\n+\t    integer_type_node);\n+\n+      gfor_fndecl_caf_end_team\n+\t= gfc_build_library_function_decl (\n+\t    get_identifier (PREFIX(\"caf_end_team\")), void_type_node, 0);\n+\n+      gfor_fndecl_caf_get_team\n+\t= gfc_build_library_function_decl_with_spec (\n+\t    get_identifier (PREFIX(\"caf_get_team\")), \"R\",\n+\t    void_type_node, 1, integer_type_node);\n+\n+      gfor_fndecl_caf_sync_team\n+\t= gfc_build_library_function_decl_with_spec (\n+\t    get_identifier (PREFIX(\"caf_sync_team\")), \"RR\",\n+\t    void_type_node, 2, ppvoid_type_node,\n+\t    integer_type_node);\n+\n+      gfor_fndecl_caf_team_number\n+      \t= gfc_build_library_function_decl_with_spec (\n+      \t    get_identifier (PREFIX(\"caf_team_number\")), \"R\",\n+      \t    integer_type_node, 1, integer_type_node);\n+\n       gfor_fndecl_caf_image_status\n \t= gfc_build_library_function_decl_with_spec (\n \t    get_identifier (PREFIX(\"caf_image_status\")), \"RR\","}, {"sha": "9cc4f3389476ec35a77c196f6c661907edd47e16", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 66, "deletions": 10, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -1846,11 +1846,11 @@ gfc_conv_intrinsic_caf_get (gfc_se *se, gfc_expr *expr, tree lhs, tree lhs_kind,\n \n static tree\n conv_caf_send (gfc_code *code) {\n-  gfc_expr *lhs_expr, *rhs_expr, *tmp_stat;\n+  gfc_expr *lhs_expr, *rhs_expr, *tmp_stat, *tmp_team;\n   gfc_se lhs_se, rhs_se;\n   stmtblock_t block;\n   tree caf_decl, token, offset, image_index, tmp, lhs_kind, rhs_kind;\n-  tree may_require_tmp, src_stat, dst_stat;\n+  tree may_require_tmp, src_stat, dst_stat, dst_team;\n   tree lhs_type = NULL_TREE;\n   tree vec = null_pointer_node, rhs_vec = null_pointer_node;\n   symbol_attribute lhs_caf_attr, rhs_caf_attr;\n@@ -1866,6 +1866,7 @@ conv_caf_send (gfc_code *code) {\n   lhs_caf_attr = gfc_caf_attr (lhs_expr);\n   rhs_caf_attr = gfc_caf_attr (rhs_expr);\n   src_stat = dst_stat = null_pointer_node;\n+  dst_team = null_pointer_node;\n \n   /* LHS.  */\n   gfc_init_se (&lhs_se, NULL);\n@@ -2077,6 +2078,18 @@ conv_caf_send (gfc_code *code) {\n       gfc_add_block_to_block (&block, &stat_se.post);\n     }\n \n+  tmp_team = gfc_find_team_co (lhs_expr);\n+\n+  if (tmp_team)\n+    {\n+      gfc_se team_se;\n+      gfc_init_se (&team_se, NULL);\n+      gfc_conv_expr_reference (&team_se, tmp_team);\n+      dst_team = team_se.expr;\n+      gfc_add_block_to_block (&block, &team_se.pre);\n+      gfc_add_block_to_block (&block, &team_se.post);\n+    }\n+\n   if (!gfc_is_coindexed (rhs_expr))\n     {\n       if (lhs_caf_attr.alloc_comp || lhs_caf_attr.pointer_comp)\n@@ -2092,10 +2105,10 @@ conv_caf_send (gfc_code *code) {\n \t\t\t\t     may_require_tmp, dst_realloc, src_stat);\n \t  }\n       else\n-\ttmp = build_call_expr_loc (input_location, gfor_fndecl_caf_send, 10,\n+\ttmp = build_call_expr_loc (input_location, gfor_fndecl_caf_send, 11,\n \t\t\t\t   token, offset, image_index, lhs_se.expr, vec,\n \t\t\t\t   rhs_se.expr, lhs_kind, rhs_kind,\n-\t\t\t\t   may_require_tmp, src_stat);\n+\t\t\t\t   may_require_tmp, src_stat, dst_team);\n     }\n   else\n     {\n@@ -2432,6 +2445,48 @@ conv_intrinsic_image_status (gfc_se *se, gfc_expr *expr)\n   se->expr = tmp;\n }\n \n+static void\n+conv_intrinsic_team_number (gfc_se *se, gfc_expr *expr)\n+{\n+  unsigned int num_args;\n+\n+  tree *args, tmp;\n+\n+  num_args = gfc_intrinsic_argument_list_length (expr);\n+  args = XALLOCAVEC (tree, num_args);\n+  gfc_conv_intrinsic_function_args (se, expr, args, num_args);\n+\n+  if (flag_coarray ==\n+      GFC_FCOARRAY_SINGLE && expr->value.function.actual->expr)\n+    {\n+      tree arg;\n+\n+      arg = gfc_evaluate_now (args[0], &se->pre);\n+      tmp = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n+      \t\t\t     fold_convert (integer_type_node, arg),\n+      \t\t\t     integer_one_node);\n+      tmp = fold_build3_loc (input_location, COND_EXPR, integer_type_node,\n+      \t\t\t     tmp, integer_zero_node,\n+      \t\t\t     build_int_cst (integer_type_node,\n+      \t\t\t\t\t    GFC_STAT_STOPPED_IMAGE));\n+    }\n+  else if (flag_coarray == GFC_FCOARRAY_SINGLE)\n+    {\n+      // the value -1 represents that no team has been created yet\n+      tmp = build_int_cst (integer_type_node, -1);\n+    }\n+  else if (flag_coarray == GFC_FCOARRAY_LIB && expr->value.function.actual->expr)\n+    tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_team_number, 1,\n+\t\t\t       args[0], build_int_cst (integer_type_node, -1));\n+  else if (flag_coarray == GFC_FCOARRAY_LIB)\n+    tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_team_number, 1,\n+\t\tinteger_zero_node, build_int_cst (integer_type_node, -1));\n+  else\n+    gcc_unreachable ();\n+\n+  se->expr = tmp;\n+}\n+\n \n static void\n trans_image_index (gfc_se * se, gfc_expr *expr)\n@@ -2553,7 +2608,6 @@ trans_image_index (gfc_se * se, gfc_expr *expr)\n \t\t\t      build_int_cst (type, 0), tmp);\n }\n \n-\n static void\n trans_num_images (gfc_se * se, gfc_expr *expr)\n {\n@@ -2581,7 +2635,6 @@ trans_num_images (gfc_se * se, gfc_expr *expr)\n     }\n   else\n     failed = build_int_cst (integer_type_node, -1);\n-\n   tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_num_images, 2,\n \t\t\t     distance, failed);\n   se->expr = fold_convert (gfc_get_int_type (gfc_default_integer_kind), tmp);\n@@ -3000,7 +3053,6 @@ conv_intrinsic_stride (gfc_se * se, gfc_expr * expr)\n   se->expr = gfc_conv_descriptor_stride_get (desc, tmp);\n }\n \n-\n static void\n gfc_conv_intrinsic_abs (gfc_se * se, gfc_expr * expr)\n {\n@@ -4584,7 +4636,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \n   /* Special case for character maxloc.  Remove unneeded actual\n      arguments, then call a library function.  */\n-  \n+\n   if (arrayexpr->ts.type == BT_CHARACTER)\n     {\n       gfc_actual_arglist *a, *b;\n@@ -6099,7 +6151,6 @@ conv_generic_with_optional_char_arg (gfc_se* se, gfc_expr* expr,\n   gfc_free_symbol (sym);\n }\n \n-\n /* The length of a character string.  */\n static void\n gfc_conv_intrinsic_len (gfc_se * se, gfc_expr * expr)\n@@ -8662,7 +8713,7 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n \t    case GFC_ISYM_MINLOC:\n \t      gfc_conv_intrinsic_minmaxloc (se, expr, LT_EXPR);\n \t      break;\n-\t      \n+\n \t    case GFC_ISYM_MAXLOC:\n \t      gfc_conv_intrinsic_minmaxloc (se, expr, GT_EXPR);\n \t      break;\n@@ -9190,6 +9241,10 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_intrinsic_arith (se, expr, PLUS_EXPR, false);\n       break;\n \n+    case GFC_ISYM_TEAM_NUMBER:\n+      conv_intrinsic_team_number (se, expr);\n+      break;\n+\n     case GFC_ISYM_TRANSFER:\n       if (se->ss && se->ss->info->useflags)\n \t/* Access the previously obtained result.  */\n@@ -9587,6 +9642,7 @@ gfc_is_intrinsic_libcall (gfc_expr * expr)\n \n     case GFC_ISYM_CSHIFT:\n     case GFC_ISYM_EOSHIFT:\n+    case GFC_ISYM_GET_TEAM:\n     case GFC_ISYM_FAILED_IMAGES:\n     case GFC_ISYM_STOPPED_IMAGES:\n     case GFC_ISYM_PACK:"}, {"sha": "573fd4818d47a011124aa515889255f00444ac26", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -696,6 +696,110 @@ gfc_trans_fail_image (gfc_code *code ATTRIBUTE_UNUSED)\n     }\n }\n \n+/* Translate the FORM TEAM statement.  */\n+\n+tree\n+gfc_trans_form_team (gfc_code *code)\n+{\n+  if (flag_coarray == GFC_FCOARRAY_LIB)\n+    {\n+      gfc_se argse;\n+      tree team_id,team_type;\n+      gfc_init_se (&argse, NULL);\n+      gfc_conv_expr_val (&argse, code->expr1);\n+      team_id = fold_convert (integer_type_node, argse.expr);\n+      gfc_init_se (&argse, NULL);\n+      gfc_conv_expr_val (&argse, code->expr2);\n+      team_type = gfc_build_addr_expr (ppvoid_type_node, argse.expr);\n+\n+      return build_call_expr_loc (input_location,\n+\t\t\t\t  gfor_fndecl_caf_form_team, 3,\n+\t\t\t\t  team_id, team_type,\n+\t\t\t\t  build_int_cst (integer_type_node, 0));\n+    }\n+  else\n+    {\n+      const char *name = gfc_get_string (PREFIX (\"exit_i%d\"), 4);\n+      gfc_symbol *exsym = gfc_get_intrinsic_sub_symbol (name);\n+      tree tmp = gfc_get_symbol_decl (exsym);\n+      return build_call_expr_loc (input_location, tmp, 1, integer_zero_node);\n+    }\n+}\n+\n+/* Translate the CHANGE TEAM statement.  */\n+\n+tree\n+gfc_trans_change_team (gfc_code *code)\n+{\n+  if (flag_coarray == GFC_FCOARRAY_LIB)\n+    {\n+      gfc_se argse;\n+      tree team_type;\n+\n+      gfc_init_se (&argse, NULL);\n+      gfc_conv_expr_val (&argse, code->expr1);\n+      team_type = gfc_build_addr_expr (ppvoid_type_node, argse.expr);\n+\n+      return build_call_expr_loc (input_location,\n+\t\t\t\t  gfor_fndecl_caf_change_team, 2, team_type,\n+\t\t\t\t  build_int_cst (integer_type_node, 0));\n+    }\n+  else\n+    {\n+      const char *name = gfc_get_string (PREFIX (\"exit_i%d\"), 4);\n+      gfc_symbol *exsym = gfc_get_intrinsic_sub_symbol (name);\n+      tree tmp = gfc_get_symbol_decl (exsym);\n+      return build_call_expr_loc (input_location, tmp, 1, integer_zero_node);\n+    }\n+}\n+\n+/* Translate the END TEAM statement.  */\n+\n+tree\n+gfc_trans_end_team (gfc_code *code ATTRIBUTE_UNUSED)\n+{\n+  if (flag_coarray == GFC_FCOARRAY_LIB)\n+    {\n+      return build_call_expr_loc (input_location,\n+\t\t\t\t  gfor_fndecl_caf_end_team, 1,\n+\t\t\t\t  build_int_cst (pchar_type_node, 0));\n+    }\n+  else\n+    {\n+      const char *name = gfc_get_string (PREFIX (\"exit_i%d\"), 4);\n+      gfc_symbol *exsym = gfc_get_intrinsic_sub_symbol (name);\n+      tree tmp = gfc_get_symbol_decl (exsym);\n+      return build_call_expr_loc (input_location, tmp, 1, integer_zero_node);\n+    }\n+}\n+\n+/* Translate the SYNC TEAM statement.  */\n+\n+tree\n+gfc_trans_sync_team (gfc_code *code)\n+{\n+  if (flag_coarray == GFC_FCOARRAY_LIB)\n+    {\n+      gfc_se argse;\n+      tree team_type;\n+\n+      gfc_init_se (&argse, NULL);\n+      gfc_conv_expr_val (&argse, code->expr1);\n+      team_type = gfc_build_addr_expr (ppvoid_type_node, argse.expr);\n+\n+      return build_call_expr_loc (input_location,\n+\t\t\t\t  gfor_fndecl_caf_sync_team, 2,\n+\t\t\t\t  team_type,\n+\t\t\t\t  build_int_cst (integer_type_node, 0));\n+    }\n+  else\n+    {\n+      const char *name = gfc_get_string (PREFIX (\"exit_i%d\"), 4);\n+      gfc_symbol *exsym = gfc_get_intrinsic_sub_symbol (name);\n+      tree tmp = gfc_get_symbol_decl (exsym);\n+      return build_call_expr_loc (input_location, tmp, 1, integer_zero_node);\n+    }\n+}\n \n tree\n gfc_trans_lock_unlock (gfc_code *code, gfc_exec_op op)"}, {"sha": "c798c80e7a7e3028d5f68c84255220e6bb3c0f97", "filename": "gcc/fortran/trans-stmt.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Ftrans-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Ftrans-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.h?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -58,6 +58,10 @@ tree gfc_trans_lock_unlock (gfc_code *, gfc_exec_op);\n tree gfc_trans_event_post_wait (gfc_code *, gfc_exec_op);\n tree gfc_trans_fail_image (gfc_code *);\n tree gfc_trans_forall (gfc_code *);\n+tree gfc_trans_form_team (gfc_code *);\n+tree gfc_trans_change_team (gfc_code *);\n+tree gfc_trans_end_team (gfc_code *);\n+tree gfc_trans_sync_team (gfc_code *);\n tree gfc_trans_where (gfc_code *);\n tree gfc_trans_allocate (gfc_code *);\n tree gfc_trans_deallocate (gfc_code *);"}, {"sha": "b15a4b2595263210af19a1612f71ae321cab25c8", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -2545,12 +2545,14 @@ gfc_get_derived_type (gfc_symbol * derived, int codimen)\n       || (flag_coarray == GFC_FCOARRAY_LIB\n \t  && derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n \t  && (derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE\n-\t      || derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)))\n+\t      || derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE\n+\t      || derived->intmod_sym_id == ISOFORTRAN_TEAM_TYPE)))\n     return ptr_type_node;\n \n   if (flag_coarray != GFC_FCOARRAY_LIB\n       && derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n-      && derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)\n+      && (derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE\n+\t  || derived->intmod_sym_id == ISOFORTRAN_TEAM_TYPE))\n     return gfc_get_int_type (gfc_default_integer_kind);\n \n   if (derived && derived->attr.flavor == FL_PROCEDURE"}, {"sha": "aa10fbb405a12319512f3f3070dd3a6ffb7de7a8", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -1972,6 +1972,22 @@ trans_code (gfc_code * code, tree cond)\n \t  res = gfc_trans_forall (code);\n \t  break;\n \n+\tcase EXEC_FORM_TEAM:\n+\t  res = gfc_trans_form_team (code);\n+\t  break;\n+\n+\tcase EXEC_CHANGE_TEAM:\n+\t  res = gfc_trans_change_team (code);\n+\t  break;\n+\n+\tcase EXEC_END_TEAM:\n+\t  res = gfc_trans_end_team (code);\n+\t  break;\n+\n+\tcase EXEC_SYNC_TEAM:\n+\t  res = gfc_trans_sync_team (code);\n+\t  break;\n+\n \tcase EXEC_WHERE:\n \t  res = gfc_trans_where (code);\n \t  break;"}, {"sha": "2ada8057735bd3da418f0b5753204b3731e0a7da", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -837,6 +837,12 @@ extern GTY(()) tree gfor_fndecl_caf_fail_image;\n extern GTY(()) tree gfor_fndecl_caf_failed_images;\n extern GTY(()) tree gfor_fndecl_caf_image_status;\n extern GTY(()) tree gfor_fndecl_caf_stopped_images;\n+extern GTY(()) tree gfor_fndecl_caf_form_team;\n+extern GTY(()) tree gfor_fndecl_caf_change_team;\n+extern GTY(()) tree gfor_fndecl_caf_end_team;\n+extern GTY(()) tree gfor_fndecl_caf_get_team;\n+extern GTY(()) tree gfor_fndecl_caf_sync_team;\n+extern GTY(()) tree gfor_fndecl_caf_team_number;\n extern GTY(()) tree gfor_fndecl_co_broadcast;\n extern GTY(()) tree gfor_fndecl_co_max;\n extern GTY(()) tree gfor_fndecl_co_min;"}, {"sha": "730b14885086737f57e55aaf5c393a09d55fafca", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -1,3 +1,14 @@\n+2018-01-26  Damian Rouson  <damian@sourceryinstitute.org>\n+\tAlessandro Fanfarillo  <fanfarillo.gcc@gmail.com>\n+\tSoren Rasmussen  <s.c.rasmussen@gmail.com>\n+\n+\tFortran 2018 teams tests.\n+\n+\t* gfortran.dg/team_number_1.f90: new test for team_number.\n+\t* gfortran.dg/team_change_1.f90: new test for change team.\n+\t* gfortran.dg/team_end_1.f90: new test for end team.\n+\t* gfortran.dg/team_form_1.f90: new test for form team.\n+\n 2018-01-26  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/83998"}, {"sha": "1dd42082b04a4c3a70fd4ac649adb424b8bfd236", "filename": "gcc/testsuite/gfortran.dg/team_change_1.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ftestsuite%2Fgfortran.dg%2Fteam_change_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ftestsuite%2Fgfortran.dg%2Fteam_change_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fteam_change_1.f90?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! Tests if change team worked\n+!\n+  use iso_fortran_env, only : team_type\n+  implicit none\n+  type(team_type) team\n+  integer new_team\n+\n+  new_team = mod(this_image(),2)+1\n+\n+  form team (new_team,team)\n+    change team (team)\n+    if (team_number()/=new_team) call abort\n+  end team\n+\n+end"}, {"sha": "5a05b7fc87ddae264119e0df8ac4afbe47a8c26e", "filename": "gcc/testsuite/gfortran.dg/team_end_1.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ftestsuite%2Fgfortran.dg%2Fteam_end_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ftestsuite%2Fgfortran.dg%2Fteam_end_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fteam_end_1.f90?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! Tests if team_number intrinsic fucntion works\n+!\n+  use iso_fortran_env, only : team_type\n+  implicit none\n+  type(team_type) :: team\n+  integer, parameter :: standard_initial_value=-1\n+\n+  associate(new_team => mod(this_image(),2)+1)\n+    form team (new_team,team)\n+      change team (team)\n+    end team\n+  end associate\n+\n+  if (team_number()/=standard_initial_value) call abort\n+end"}, {"sha": "fd492f6ed84fc4d17fa10ec2d118372c4ee0f855", "filename": "gcc/testsuite/gfortran.dg/team_form_1.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ftestsuite%2Fgfortran.dg%2Fteam_form_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ftestsuite%2Fgfortran.dg%2Fteam_form_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fteam_form_1.f90?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! Tests if form team works\n+!\n+  use iso_fortran_env, only : team_type\n+  implicit none\n+  type(team_type) :: team\n+\n+  form team (mod(this_image(),2)+1,team)\n+\n+end"}, {"sha": "242ea507088f19cb17568b2782225304bf47b14b", "filename": "gcc/testsuite/gfortran.dg/team_number_1.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ftestsuite%2Fgfortran.dg%2Fteam_number_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8862a1b2afad9d107ad505de2bf554705ebdb38/gcc%2Ftestsuite%2Fgfortran.dg%2Fteam_number_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fteam_number_1.f90?ref=f8862a1b2afad9d107ad505de2bf554705ebdb38", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! Tests if team_number intrinsic fucntion works\n+!\n+  use iso_fortran_env, only : team_type\n+  implicit none\n+  type(team_type) team\n+  integer, parameter :: standard_initial_value=-1\n+  integer new_team\n+\n+  if (team_number()/=standard_initial_value) call abort\n+\n+  new_team = mod(this_image(),2)+1\n+  form team (new_team,team)\n+    change team (team)\n+    if (team_number()/=new_team) call abort\n+  end team\n+\n+  if (team_number()/=standard_initial_value) call abort\n+\n+end"}]}