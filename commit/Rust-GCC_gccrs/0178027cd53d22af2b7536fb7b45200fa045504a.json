{"sha": "0178027cd53d22af2b7536fb7b45200fa045504a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE3ODAyN2NkNTNkMjJhZjJiNzUzNmZiN2I0NTIwMGZhMDQ1NTA0YQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2005-09-21T16:32:10Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-09-21T16:32:10Z"}, "message": "expmed.c (alg_code): Add alg_impossible.\n\n\t* expmed.c (alg_code): Add alg_impossible.\n\t(alg_hash_entry): Add cost.\n\t(synth_mult): Record alg_impossible in the hash table if\n\tmultiplication by a given integer is impossble within the\n\tlimit.  Speed up using alg_impossible.\n\nFrom-SVN: r104492", "tree": {"sha": "256237c71a8a62ab6f19ccf11c3ed0d9a8a2ca63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/256237c71a8a62ab6f19ccf11c3ed0d9a8a2ca63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0178027cd53d22af2b7536fb7b45200fa045504a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0178027cd53d22af2b7536fb7b45200fa045504a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0178027cd53d22af2b7536fb7b45200fa045504a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0178027cd53d22af2b7536fb7b45200fa045504a/comments", "author": null, "committer": null, "parents": [{"sha": "1bf83ca3ddc1d6f98ea66a39eef82642ef200062", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bf83ca3ddc1d6f98ea66a39eef82642ef200062", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bf83ca3ddc1d6f98ea66a39eef82642ef200062"}], "stats": {"total": 104, "additions": 83, "deletions": 21}, "files": [{"sha": "fcf3edf2db5d703cfbfba89ed534e2ecd7f5fa45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0178027cd53d22af2b7536fb7b45200fa045504a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0178027cd53d22af2b7536fb7b45200fa045504a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0178027cd53d22af2b7536fb7b45200fa045504a", "patch": "@@ -1,3 +1,11 @@\n+2005-09-21  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* expmed.c (alg_code): Add alg_impossible.\n+\t(alg_hash_entry): Add cost.\n+\t(synth_mult): Record alg_impossible in the hash table if\n+\tmultiplication by a given integer is impossble within the\n+\tlimit.  Speed up using alg_impossible.\n+\n 2005-09-20  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* tree-ssa-structalias.c (get_constraint_for_component_ref): Add"}, {"sha": "27a8b9b1bca5176a58a667e741d80173f10a862e", "filename": "gcc/expmed.c", "status": "modified", "additions": 75, "deletions": 21, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0178027cd53d22af2b7536fb7b45200fa045504a/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0178027cd53d22af2b7536fb7b45200fa045504a/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=0178027cd53d22af2b7536fb7b45200fa045504a", "patch": "@@ -2286,10 +2286,18 @@ expand_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n   return temp;\n }\n \f\n-enum alg_code { alg_unknown, alg_zero, alg_m, alg_shift,\n-\t\t  alg_add_t_m2, alg_sub_t_m2,\n-\t\t  alg_add_factor, alg_sub_factor,\n-\t\t  alg_add_t2_m, alg_sub_t2_m };\n+enum alg_code {\n+  alg_unknown,\n+  alg_zero,\n+  alg_m, alg_shift,\n+  alg_add_t_m2,\n+  alg_sub_t_m2,\n+  alg_add_factor,\n+  alg_sub_factor,\n+  alg_add_t2_m,\n+  alg_sub_t2_m,\n+  alg_impossible\n+};\n \n /* This structure holds the \"cost\" of a multiply sequence.  The\n    \"cost\" field holds the total rtx_cost of every operator in the\n@@ -2363,6 +2371,11 @@ struct alg_hash_entry {\n \n   /* The best multiplication algorithm for t.  */\n   enum alg_code alg;\n+\n+  /* The cost of multiplication if ALG_CODE is not alg_impossible.\n+     Otherwise, the cost within which multiplication by T is\n+     impossible.  */\n+  struct mult_cost cost;\n };\n \n /* The number of cache/hash entries.  */\n@@ -2465,29 +2478,57 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       && alg_hash[hash_index].mode == mode\n       && alg_hash[hash_index].alg != alg_unknown)\n     {\n-      cache_hit = true;\n       cache_alg = alg_hash[hash_index].alg;\n-      switch (cache_alg)\n+\n+      if (cache_alg == alg_impossible)\n \t{\n-\tcase alg_shift:\n-\t  goto do_alg_shift;\n+\t  /* The cache tells us that it's impossible to synthesize\n+\t     multiplication by T within alg_hash[hash_index].cost.  */\n+\t  if (!CHEAPER_MULT_COST (&alg_hash[hash_index].cost, cost_limit))\n+\t    /* COST_LIMIT is at least as restrictive as the one\n+\t       recorded in the hash table, in which case we have no\n+\t       hope of synthesizing a multiplication.  Just\n+\t       return.  */\n+\t    return;\n+\n+\t  /* If we get here, COST_LIMIT is less restrictive than the\n+\t     one recorded in the hash table, so we may be able to\n+\t     synthesize a multiplication.  Proceed as if we didn't\n+\t     have the cache entry.  */\n+\t}\n+      else\n+\t{\n+\t  if (CHEAPER_MULT_COST (cost_limit, &alg_hash[hash_index].cost))\n+\t    /* The cached algorithm shows that this multiplication\n+\t       requires more cost than COST_LIMIT.  Just return.  This\n+\t       way, we don't clobber this cache entry with\n+\t       alg_impossible but retain useful information.  */\n+\t    return;\n \n-\tcase alg_add_t_m2:\n-\tcase alg_sub_t_m2:\n-\t  goto do_alg_addsub_t_m2;\n+\t  cache_hit = true;\n \n-\tcase alg_add_factor:\n-\tcase alg_sub_factor:\n-\t  goto do_alg_addsub_factor;\n+\t  switch (cache_alg)\n+\t    {\n+\t    case alg_shift:\n+\t      goto do_alg_shift;\n \n-\tcase alg_add_t2_m:\n-\t  goto do_alg_add_t2_m;\n+\t    case alg_add_t_m2:\n+\t    case alg_sub_t_m2:\n+\t      goto do_alg_addsub_t_m2;\n \n-\tcase alg_sub_t2_m:\n-\t  goto do_alg_sub_t2_m;\n+\t    case alg_add_factor:\n+\t    case alg_sub_factor:\n+\t      goto do_alg_addsub_factor;\n \n-\tdefault:\n-\t  gcc_unreachable ();\n+\t    case alg_add_t2_m:\n+\t      goto do_alg_add_t2_m;\n+\n+\t    case alg_sub_t2_m:\n+\t      goto do_alg_sub_t2_m;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n \t}\n     }\n \n@@ -2740,14 +2781,27 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n  done:\n   /* If best_cost has not decreased, we have not found any algorithm.  */\n   if (!CHEAPER_MULT_COST (&best_cost, cost_limit))\n-    return;\n+    {\n+      /* We failed to find an algorithm.  Record alg_impossible for\n+\t this case (that is, <T, MODE, COST_LIMIT>) so that next time\n+\t we are asked to find an algorithm for T within the same or\n+\t lower COST_LIMIT, we can immediately return to the\n+\t caller.  */\n+      alg_hash[hash_index].t = t;\n+      alg_hash[hash_index].mode = mode;\n+      alg_hash[hash_index].alg = alg_impossible;\n+      alg_hash[hash_index].cost = *cost_limit;\n+      return;\n+    }\n \n   /* Cache the result.  */\n   if (!cache_hit)\n     {\n       alg_hash[hash_index].t = t;\n       alg_hash[hash_index].mode = mode;\n       alg_hash[hash_index].alg = best_alg->op[best_alg->ops];\n+      alg_hash[hash_index].cost.cost = best_cost.cost;\n+      alg_hash[hash_index].cost.latency = best_cost.latency;\n     }\n \n   /* If we are getting a too long sequence for `struct algorithm'"}]}