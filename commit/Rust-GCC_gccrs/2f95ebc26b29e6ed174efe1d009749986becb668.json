{"sha": "2f95ebc26b29e6ed174efe1d009749986becb668", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY5NWViYzI2YjI5ZTZlZDE3NGVmZTFkMDA5NzQ5OTg2YmVjYjY2OA==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1993-12-24T03:13:01Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1993-12-24T03:13:01Z"}, "message": "(iorscc): New recognizer.\n\n2 new recognizers for sub;subb.  1 new recognizer for addi;subb.\n(movstrsi): Remove predicates.  Set inline threshold to 8.\n(umulsidi3): Change predicates to nonimmediate_operand.\nNew recognizer for multiply-by-immediate.\n(andsi3): Add `!' for register alternative.\n(vdepi_ior, vdepi_and): New recognizers.\n(vextru rx,1,ry, vextrs rx,1,ry): New recognizers.\n(call, call_value): If PIC, emit USE for for\nPIC_OFFSET_TABLE_REGNUM.  Use PIC_OFFSET_TABLE_REGNUM rather than 19.\n\nFrom-SVN: r6294", "tree": {"sha": "160410a0ea503452caa71d30e25ed0fa917a04af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/160410a0ea503452caa71d30e25ed0fa917a04af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f95ebc26b29e6ed174efe1d009749986becb668", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f95ebc26b29e6ed174efe1d009749986becb668", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f95ebc26b29e6ed174efe1d009749986becb668", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f95ebc26b29e6ed174efe1d009749986becb668/comments", "author": null, "committer": null, "parents": [{"sha": "5a1c10de98acd4aa12483d1d09878c4f1e634973", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a1c10de98acd4aa12483d1d09878c4f1e634973", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a1c10de98acd4aa12483d1d09878c4f1e634973"}], "stats": {"total": 381, "additions": 246, "deletions": 135}, "files": [{"sha": "472110ff9743428a5d85bbb582aba3971a1869bf", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 246, "deletions": 135, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f95ebc26b29e6ed174efe1d009749986becb668/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f95ebc26b29e6ed174efe1d009749986becb668/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=2f95ebc26b29e6ed174efe1d009749986becb668", "patch": "@@ -74,7 +74,7 @@\n \t\t(const_string \"true\")\n \t\t(const_string \"false\")))\n \n-;; For calls and millicode calls.  Allow unconditional branches in the \n+;; For calls and millicode calls.  Allow unconditional branches in the\n ;; delay slot.\n (define_attr \"in_call_delay\" \"false,true\"\n   (cond [(and (eq_attr \"type\" \"!uncond_branch,branch,cbranch,fbranch,call,dyncall,multi,milli\")\n@@ -86,7 +86,6 @@\n \t\t\t (const_string \"true\")\n \t\t\t (const_string \"false\"))]\n \t(const_string \"false\")))\n-\t\n \n \n ;; Unconditional branch, call, and millicode call delay slot description.\n@@ -109,8 +108,8 @@\n ;; backward branches nullify false.  If the direction is unknown\n ;; then nullification is not allowed.\n (define_delay (eq_attr \"type\" \"cbranch\")\n-  [(eq_attr \"in_branch_delay\" \"true\") \n-   (and (eq_attr \"in_nullified_branch_delay\" \"true\") \n+  [(eq_attr \"in_branch_delay\" \"true\")\n+   (and (eq_attr \"in_nullified_branch_delay\" \"true\")\n \t(attr_flag \"forward\"))\n    (and (eq_attr \"in_nullified_branch_delay\" \"true\")\n \t(attr_flag \"backward\"))])\n@@ -215,22 +214,22 @@\n }\")\n \n (define_insn \"\"\n- [(set (reg:CCFP 0)\n-       (match_operator:CCFP 2 \"comparison_operator\"\n-\t\t\t    [(match_operand:SF 0 \"reg_or_0_operand\" \"fxG\")\n-\t\t\t     (match_operand:SF 1 \"reg_or_0_operand\" \"fxG\")]))]\n- \"\"\n- \"fcmp,sgl,%Y2 %r0,%r1\"\n- [(set_attr \"type\" \"fpcc\")])\n+  [(set (reg:CCFP 0)\n+\t(match_operator:CCFP 2 \"comparison_operator\"\n+\t\t\t     [(match_operand:SF 0 \"reg_or_0_operand\" \"fxG\")\n+\t\t\t      (match_operand:SF 1 \"reg_or_0_operand\" \"fxG\")]))]\n+  \"\"\n+  \"fcmp,sgl,%Y2 %r0,%r1\"\n+  [(set_attr \"type\" \"fpcc\")])\n \n (define_insn \"\"\n- [(set (reg:CCFP 0)\n-       (match_operator:CCFP 2 \"comparison_operator\"\n-\t\t\t    [(match_operand:DF 0 \"reg_or_0_operand\" \"fxG\")\n-\t\t\t     (match_operand:DF 1 \"reg_or_0_operand\" \"fxG\")]))]\n- \"\"\n- \"fcmp,dbl,%Y2 %r0,%r1\"\n- [(set_attr \"type\" \"fpcc\")])\n+  [(set (reg:CCFP 0)\n+\t(match_operator:CCFP 2 \"comparison_operator\"\n+\t\t\t     [(match_operand:DF 0 \"reg_or_0_operand\" \"fxG\")\n+\t\t\t      (match_operand:DF 1 \"reg_or_0_operand\" \"fxG\")]))]\n+  \"\"\n+  \"fcmp,dbl,%Y2 %r0,%r1\"\n+  [(set_attr \"type\" \"fpcc\")])\n \n ;; scc insns.\n \n@@ -379,19 +378,32 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(match_operator:SI 3 \"comparison_operator\"\n \t\t\t   [(match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t    (match_operand:SI 2  \"arith11_operand\" \"rI\")]))]\n+\t\t\t    (match_operand:SI 2 \"arith11_operand\" \"rI\")]))]\n   \"\"\n   \"com%I2clr,%B3 %2,%1,%0\\;ldi 1,%0\"\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"iorscc\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (match_operator:SI 3 \"comparison_operator\"\n+\t\t\t\t   [(match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t    (match_operand:SI 2 \"arith11_operand\" \"rI\")])\n+\t\t(match_operator:SI 6 \"comparison_operator\"\n+\t\t\t\t   [(match_operand:SI 4 \"register_operand\" \"r\")\n+\t\t\t\t    (match_operand:SI 5 \"arith11_operand\" \"rI\")])))]\n+  \"\"\n+  \"com%I2clr,%S3 %2,%1,0\\;com%I2clr,%B6 %5,%4,%0\\;ldi 1,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"8\")])\n+\n ;; Combiner patterns for common operations performed with the output\n-;; from an scc insn (negscc and incscc).  \n+;; from an scc insn (negscc and incscc).\n (define_insn \"negscc\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(neg:SI (match_operator:SI 3 \"comparison_operator\"\n \t       [(match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t(match_operand:SI 2  \"arith11_operand\" \"rI\")])))]\n+\t\t(match_operand:SI 2 \"arith11_operand\" \"rI\")])))]\n   \"\"\n   \"com%I2clr,%B3 %2,%1,%0\\;ldi -1,%0\"\n   [(set_attr \"type\" \"binary\")\n@@ -461,6 +473,17 @@\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t    (gtu:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t    (match_operand:SI 3 \"arith11_operand\" \"rI\")))\n+\t\t  (match_operand:SI 4 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"sub%I3 %3,%2,0\\;subb %1,%4,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"8\")])\n+\n ; This need only accept registers for op3, since canonicalization\n ; replaces ltu with leu when op3 is an integer.\n (define_insn \"\"\n@@ -473,6 +496,17 @@\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t    (ltu:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t    (match_operand:SI 3 \"register_operand\" \"r\")))\n+\t\t  (match_operand:SI 4 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"sub %2,%3,0\\;subb %1,%4,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"8\")])\n+\n ; Match only integers for op3 here.  This is used as canonical form of the\n ; ltu pattern when op3 is an integer.  Don't match registers since we can't\n ; make better code than the general incscc pattern.\n@@ -486,6 +520,17 @@\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t    (leu:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t    (match_operand:SI 3 \"int11_operand\" \"I\")))\n+\t\t  (match_operand:SI 4 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"addi %k3,%2,0\\;subb %1,%4,%0\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"8\")])\n+\n (define_insn \"decscc\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(minus:SI (match_operand:SI 1 \"register_operand\" \"0,?r\")\n@@ -762,7 +807,7 @@\n \n \n ;; Note a long backward conditional branch with an annulled delay slot\n-;; has a length of 12.  \n+;; has a length of 12.\n (define_insn \"\"\n   [(set (pc)\n \t(if_then_else\n@@ -774,11 +819,11 @@\n   \"\"\n   \"*\n {\n-  return output_cbranch (operands, INSN_ANNULLED_BRANCH_P (insn), \n+  return output_cbranch (operands, INSN_ANNULLED_BRANCH_P (insn),\n \t\t\t get_attr_length (insn), 0, insn);\n }\"\n [(set_attr \"type\" \"cbranch\")\n- (set (attr \"length\") \n+ (set (attr \"length\")\n     (if_then_else (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n \t\t      (const_int 8188))\n            (const_int 4)\n@@ -797,11 +842,11 @@\n   \"\"\n   \"*\n {\n-  return output_cbranch (operands, INSN_ANNULLED_BRANCH_P (insn), \n+  return output_cbranch (operands, INSN_ANNULLED_BRANCH_P (insn),\n \t\t\t get_attr_length (insn), 1, insn);\n }\"\n [(set_attr \"type\" \"cbranch\")\n- (set (attr \"length\") \n+ (set (attr \"length\")\n     (if_then_else (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n \t\t      (const_int 8188))\n            (const_int 4)\n@@ -820,13 +865,13 @@\n   \"\"\n   \"*\n {\n-  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn), \n-\t\t\t get_attr_length (insn), \n+  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn),\n+\t\t\t get_attr_length (insn),\n \t\t\t (operands[3] != pc_rtx),\n \t\t\t insn, 0);\n }\"\n [(set_attr \"type\" \"cbranch\")\n- (set (attr \"length\") \n+ (set (attr \"length\")\n     (if_then_else (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n \t\t      (const_int 8188))\n            (const_int 4)\n@@ -844,13 +889,13 @@\n   \"\"\n   \"*\n {\n-  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn), \n-\t\t\t get_attr_length (insn), \n+  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn),\n+\t\t\t get_attr_length (insn),\n \t\t\t (operands[3] != pc_rtx),\n \t\t\t insn, 1);\n }\"\n [(set_attr \"type\" \"cbranch\")\n- (set (attr \"length\") \n+ (set (attr \"length\")\n     (if_then_else (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n \t\t      (const_int 8188))\n            (const_int 4)\n@@ -944,9 +989,9 @@\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"reg_or_nonsymb_mem_operand\" \n+  [(set (match_operand:SI 0 \"reg_or_nonsymb_mem_operand\"\n \t\t\t\t\"=r,r,r,r,r,Q,*q,!fx,fx,*T\")\n-\t(match_operand:SI 1 \"move_operand\" \n+\t(match_operand:SI 1 \"move_operand\"\n \t\t\t\t\"rM,J,N,K,Q,rM,rM,!fxM,*T,fx\"))]\n   \"register_operand (operands[0], SImode)\n    || reg_or_0_operand (operands[1], SImode)\"\n@@ -984,7 +1029,7 @@\n ;; seem to be a way around it.  Only recognize it while reloading.\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"&=r\")\n-\t(mem:SI (plus:SI (plus:SI \n+\t(mem:SI (plus:SI (plus:SI\n \t\t\t    (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t\t     (const_int 4))\n \t\t\t    (match_operand:SI 2 \"register_operand\" \"r\"))\n@@ -1038,7 +1083,7 @@\n   [(set (match_operand:SI 3 \"register_operand\" \"r\")\n \t(mem:SI (match_operand:SI 1 \"register_operand\" \"0\")))\n    (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_dup 1) \n+\t(plus:SI (match_dup 1)\n \t\t (match_operand:SI 2 \"post_cint_operand\" \"\")))]\n   \"\"\n   \"*\n@@ -1054,7 +1099,7 @@\n   [(set (mem:SI (match_operand:SI 1 \"register_operand\" \"0\"))\n \t(match_operand:SI 3 \"reg_or_0_operand\" \"rM\"))\n    (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_dup 1) \n+\t(plus:SI (match_dup 1)\n \t\t (match_operand:SI 2 \"post_cint_operand\" \"\")))]\n   \"\"\n   \"*\n@@ -1096,15 +1141,15 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n \t(high:SI (match_operand 1 \"\" \"\")))]\n-  \"symbolic_operand(operands[1], Pmode)\n+  \"symbolic_operand (operands[1], Pmode)\n    && ! function_label_operand (operands[1])\n    && ! read_only_operand (operands[1])\"\n   \"@\n    addil L'%G1,%%r27\"\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"4\")])\n \n-;; This is for use in the prologue/epilogue code.  We need it \n+;; This is for use in the prologue/epilogue code.  We need it\n ;; to add large constants to a stack pointer or frame pointer.\n ;; Because of the additional %r1 pressure, we probably do not\n ;; want to use this in general code, so make it available\n@@ -1162,7 +1207,7 @@\n ;; Now that a symbolic_address plus a constant is broken up early\n ;; in the compilation phase (for better CSE) we need a special\n ;; combiner pattern to load the symbolic address plus the constant\n-;; in only 2 instructions. (For cases where the symbolic address \n+;; in only 2 instructions. (For cases where the symbolic address\n ;; was not a common subexpression.)\n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -1215,7 +1260,7 @@\n ;; seem to be a way around it.  Only recognize it while reloading.\n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=&r\")\n-\t(mem:HI (plus:SI (plus:SI \n+\t(mem:HI (plus:SI (plus:SI\n \t\t\t    (mult:SI (match_operand:SI 2 \"register_operand\" \"r\")\n \t\t\t\t     (const_int 2))\n \t\t\t    (match_operand:SI 1 \"register_operand\" \"r\"))\n@@ -1323,8 +1368,8 @@\n ;; that anything generated as this insn will be recognized as one\n ;; and that it will not successfully combine with anything.\n (define_expand \"movstrsi\"\n-  [(parallel [(set (mem:BLK (match_operand:BLK 0 \"general_operand\" \"\"))\n-\t\t   (mem:BLK (match_operand:BLK 1 \"general_operand\" \"\")))\n+  [(parallel [(set (mem:BLK (match_operand:BLK 0 \"\" \"\"))\n+\t\t   (mem:BLK (match_operand:BLK 1 \"\" \"\")))\n \t      (clobber (match_dup 0))\n \t      (clobber (match_dup 1))\n \t      (clobber (match_dup 4))\n@@ -1340,7 +1385,7 @@\n      runtime and make the optimal decisions.  */\n      if (INTVAL (operands[3]) < 4\n \t && (GET_CODE (operands[2]) != CONST_INT\n-\t     || (INTVAL (operands[2]) / INTVAL (operands[3]) > 16)))\n+\t     || (INTVAL (operands[2]) / INTVAL (operands[3]) > 8)))\n        FAIL;\n \n   operands[0] = copy_to_mode_reg (SImode, XEXP (operands[0], 0));\n@@ -1375,7 +1420,7 @@\n ;;\n ;; For integer registers we use ldil;ldo to set the appropriate\n ;; value.\n-;; \n+;;\n ;; This must come before the movdf pattern, and it must be present\n ;; to handle obscure reloading cases.\n (define_insn \"\"\n@@ -1407,7 +1452,7 @@\n    || reg_or_0_operand (operands[1], DFmode)\"\n   \"*\n {\n-  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]) \n+  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1])\n       || operands[1] == CONST0_RTX (DFmode))\n     return output_fp_move_double (operands);\n   return output_move_double (operands);\n@@ -1429,11 +1474,11 @@\n ;; is the frame pointer.  This is a kludge, but there doesn't\n ;; seem to be a way around it.  Only recognize it while reloading.\n ;; Ugh. Output is a FP register; so we need to earlyclobber something\n-;; else as a temporary. \n+;; else as a temporary.\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=fx\")\n-\t(mem:DF (plus:SI \n-\t\t  (plus:SI \n+\t(mem:DF (plus:SI\n+\t\t  (plus:SI\n \t\t    (mult:SI (match_operand:SI 1 \"register_operand\" \"+&r\")\n \t\t\t     (const_int 8))\n \t\t    (match_operand:SI 2 \"register_operand\" \"r\"))\n@@ -1463,10 +1508,10 @@\n ;; is the frame pointer.  This is a kludge, but there doesn't\n ;; seem to be a way around it.  Only recognize it while reloading.\n ;; Ugh. Output is a FP register; so we need to earlyclobber something\n-;; else as a temporary. \n+;; else as a temporary.\n (define_insn \"\"\n-  [(set (mem:DF (plus:SI \n-\t\t  (plus:SI \n+  [(set (mem:DF (plus:SI\n+\t\t  (plus:SI\n \t\t     (mult:SI (match_operand:SI 1 \"register_operand\" \"+&r\")\n \t\t\t      (const_int 8))\n \t\t     (match_operand:SI 2 \"register_operand\" \"r\"))\n@@ -1605,7 +1650,7 @@\n ;;\n ;; For integer registers we use ldil;ldo to set the appropriate\n ;; value.\n-;; \n+;;\n ;; This must come before the movsf pattern, and it must be present\n ;; to handle obscure reloading cases.\n (define_insn \"\"\n@@ -1659,11 +1704,11 @@\n ;; is the frame pointer.  This is a kludge, but there doesn't\n ;; seem to be a way around it.  Only recognize it while reloading.\n ;; Ugh. Output is a FP register; so we need to earlyclobber something\n-;; else as a temporary. \n+;; else as a temporary.\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=fx\")\n-\t(mem:SF (plus:SI \n-\t\t  (plus:SI \n+\t(mem:SF (plus:SI\n+\t\t  (plus:SI\n \t\t    (mult:SI (match_operand:SI 1 \"register_operand\" \"+&r\")\n \t\t\t     (const_int 4))\n \t\t    (match_operand:SI 2 \"register_operand\" \"r\"))\n@@ -1693,10 +1738,10 @@\n ;; is the frame pointer.  This is a kludge, but there doesn't\n ;; seem to be a way around it.  Only recognize it while reloading.\n ;; Ugh. Output is a FP register; so we need to earlyclobber something\n-;; else as a temporary. \n+;; else as a temporary.\n (define_insn \"\"\n-  [(set (mem:SF (plus:SI \n-\t\t  (plus:SI \n+  [(set (mem:SF (plus:SI\n+\t\t  (plus:SI\n \t\t     (mult:SI (match_operand:SI 1 \"register_operand\" \"+&r\")\n \t\t\t      (const_int 4))\n \t\t     (match_operand:SI 2 \"register_operand\" \"r\"))\n@@ -1930,7 +1975,7 @@\n \t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t (match_operand:SI 2 \"const_int_operand\" \"\")))\n    (clobber (match_operand:SI 4 \"register_operand\" \"\"))]\n-  \"! cint_ok_for_move (INTVAL (operands[2])) \n+  \"! cint_ok_for_move (INTVAL (operands[2]))\n    && VAL_14_BITS_P (INTVAL (operands[2]) >> 1)\"\n   [(set (match_dup 4) (plus:SI (match_dup 1) (match_dup 2)))\n    (set (match_dup 0) (plus:SI (match_dup 4) (match_dup 3)))]\n@@ -1975,7 +2020,7 @@\n       operands[2] = GEN_INT (INTVAL (operands[2]) / 8);\n       operands[3] = GEN_INT (8);\n     }\n-  else \n+  else\n     FAIL;\n }\")\n \n@@ -2037,13 +2082,21 @@\n }\")\n \n (define_insn \"umulsidi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n-\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"x\"))\n-\t\t (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"x\"))))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=x\")\n+\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"x\"))\n+\t\t (zero_extend:DI (match_operand:SI 2 \"nonimmediate_operand\" \"x\"))))]\n   \"TARGET_SNAKE && ! TARGET_DISABLE_FPREGS\"\n   \"xmpyu %1,%2,%0\"\n   [(set_attr \"type\" \"fpmul\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=x\")\n+\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"x\"))\n+\t\t (match_operand:DI 2 \"uint32_operand\" \"x\")))]\n+  \"TARGET_SNAKE && ! TARGET_DISABLE_FPREGS\"\n+  \"xmpyu %1,%R2,%0\"\n+  [(set_attr \"type\" \"fpmul\")])\n+\n (define_insn \"\"\n   [(set (reg:SI 29) (mult:SI (reg:SI 26) (reg:SI 25)))\n    (clobber (match_operand:SI 0 \"register_operand\" \"=a\"))\n@@ -2095,10 +2148,10 @@\n    (clobber (reg:SI 26))\n    (clobber (reg:SI 25))\n    (clobber (reg:SI 31))]\n- \"\"\n- \"*\n- return output_div_insn (operands, 0, insn);\"\n- [(set_attr \"type\" \"milli\")])\n+  \"\"\n+  \"*\n+   return output_div_insn (operands, 0, insn);\"\n+  [(set_attr \"type\" \"milli\")])\n \n (define_expand \"udivsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n@@ -2124,7 +2177,7 @@\n \t\t\t\t gen_rtx (UDIV, SImode,\n \t\t\t\t\t  gen_rtx (REG, SImode, 26),\n \t\t\t\t\t  gen_rtx (REG, SImode, 25))),\n-\t\t     gen_rtx (CLOBBER, VOIDmode, operands[3]), \n+\t\t     gen_rtx (CLOBBER, VOIDmode, operands[3]),\n \t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 26)),\n \t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 25)),\n \t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 31)))));\n@@ -2140,10 +2193,10 @@\n    (clobber (reg:SI 26))\n    (clobber (reg:SI 25))\n    (clobber (reg:SI 31))]\n- \"\"\n- \"*\n- return output_div_insn (operands, 1, insn);\"\n- [(set_attr \"type\" \"milli\")])\n+  \"\"\n+  \"*\n+   return output_div_insn (operands, 1, insn);\"\n+  [(set_attr \"type\" \"milli\")])\n \n (define_expand \"modsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n@@ -2167,7 +2220,7 @@\n \t\t\t     gen_rtx (MOD, SImode,\n \t\t\t\t      gen_rtx (REG, SImode, 26),\n \t\t\t\t      gen_rtx (REG, SImode, 25))),\n-\t\t gen_rtx (CLOBBER, VOIDmode, operands[3]), \n+\t\t gen_rtx (CLOBBER, VOIDmode, operands[3]),\n \t\t gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 26)),\n \t\t gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 25)),\n \t\t gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 31)))));\n@@ -2208,7 +2261,7 @@\n \t\t\t     gen_rtx (UMOD, SImode,\n \t\t\t\t      gen_rtx (REG, SImode, 26),\n \t\t\t\t      gen_rtx (REG, SImode, 25))),\n-\t\t gen_rtx (CLOBBER, VOIDmode, operands[3]), \n+\t\t gen_rtx (CLOBBER, VOIDmode, operands[3]),\n \t\t gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 26)),\n \t\t gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 25)),\n \t\t gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 31)))));\n@@ -2252,9 +2305,11 @@\n   \"and %1,%2,%0\\;and %R1,%R2,%R0\"\n   [(set_attr \"length\" \"8\")])\n \n+; The ! for op1 makes reload prefer zdepi instead of loading a huge\n+; constant with ldil;ldo.\n (define_insn \"andsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"%r,0\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%!r,0\")\n \t\t(match_operand:SI 2 \"and_operand\" \"rO,P\")))]\n   \"\"\n   \"* return output_and (operands); \"\n@@ -2563,7 +2618,7 @@\n \t  emit_insn (gen_zvdep32 (operands[0], operands[1], temp));\n       DONE;\n     }\n-  /* Make sure both inputs are not constants, \n+  /* Make sure both inputs are not constants,\n      the recognizer can't handle that.  */\n   operands[1] = force_reg (SImode, operands[1]);\n }\")\n@@ -2607,6 +2662,36 @@\n   return \\\"zvdepi %1,%2,%0\\\";\n }\")\n \n+(define_insn \"vdepi_ior\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (ashift:SI (match_operand:SI 1 \"const_int_operand\" \"\")\n+\t\t\t   (minus:SI (const_int 31)\n+\t\t\t\t     (match_operand:SI 2 \"register_operand\" \"q\")))\n+\t\t(match_operand:SI 3 \"register_operand\" \"0\")))]\n+  ; accept ...0001...1, can this be generalized?\n+  \"exact_log2 (INTVAL (operands[1]) + 1) >= 0\"\n+  \"*\n+{\n+  int x = INTVAL (operands[1]);\n+  operands[2] = GEN_INT (exact_log2 (x + 1));\n+  return \\\"vdepi -1,%2,%0\\\";\n+}\")\n+\n+(define_insn \"vdepi_and\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (rotate:SI (match_operand:SI 1 \"const_int_operand\" \"\")\n+\t\t\t   (minus:SI (const_int 31)\n+\t\t\t\t     (match_operand:SI 2 \"register_operand\" \"q\")))\n+\t\t(match_operand:SI 3 \"register_operand\" \"0\")))]\n+  ; this can be generalized...!\n+  \"INTVAL (operands[1]) == -2\"\n+  \"*\n+{\n+  int x = INTVAL (operands[1]);\n+  operands[2] = GEN_INT (exact_log2 ((~x) + 1));\n+  return \\\"vdepi 0,%2,%0\\\";\n+}\")\n+\n (define_expand \"ashrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n@@ -2730,7 +2815,7 @@\n   \"bv%* 0(%%r2)\"\n   [(set_attr \"type\" \"branch\")])\n \n-;; Use a different pattern for functions which have non-trivial \n+;; Use a different pattern for functions which have non-trivial\n ;; epilogues so as not to confuse jump and reorg.\n (define_insn \"return_internal\"\n   [(use (reg:SI 2))\n@@ -2749,7 +2834,7 @@\n   \"\"\n   \"\n {\n-  /* Try to use the trivial return first.  Else use the full \n+  /* Try to use the trivial return first.  Else use the full\n      epilogue.  */\n   if (hppa_can_use_return_insn_p ())\n    emit_jump_insn (gen_return ());\n@@ -2785,7 +2870,7 @@\n    (set (attr \"length\")\n     (cond [(eq (symbol_ref \"jump_in_call_delay (insn)\") (const_int 0))\n \t   (const_int 4)\n-;; If the jump is in the delay slot of a call, then its length depends \n+;; If the jump is in the delay slot of a call, then its length depends\n ;; on whether or not we can add the proper offset to %r2 with an ldo\n ;; instruction.\n \t   (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n@@ -2853,22 +2938,26 @@\n       return \\\"sub,>> %0,%1,0\\;blr,n %0,0\\;b,n %l3\\\";\n     }\n }\"\n- [(set_attr \"length\" \"12\")])\n+  [(set_attr \"length\" \"12\")])\n \n ;; Need nops for the calls because execution is supposed to continue\n ;; past; we don't want to nullify an instruction that we need.\n ;;- jump to subroutine\n \n (define_expand \"call\"\n- [(parallel [(call (match_operand:SI 0 \"\" \"\")\n-\t\t   (match_operand 1 \"\" \"\"))\n-\t     (clobber (reg:SI 2))])]\n- \"\"\n- \"\n+  [(parallel [(call (match_operand:SI 0 \"\" \"\")\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (clobber (reg:SI 2))])]\n+  \"\"\n+  \"\n {\n   rtx op;\n-  \n-  if (TARGET_LONG_CALLS) \n+\n+  if (flag_pic)\n+    emit_insn (gen_rtx (USE, VOIDmode,\n+\t\t\tgen_rtx (REG, Pmode, PIC_OFFSET_TABLE_REGNUM)));\n+\n+  if (TARGET_LONG_CALLS)\n     op = force_reg (SImode, XEXP (operands[0], 0));\n   else\n     op = XEXP (operands[0], 0);\n@@ -2888,34 +2977,35 @@\n       if (!hppa_save_pic_table_rtx)\n \thppa_save_pic_table_rtx = gen_reg_rtx (Pmode);\n       emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t  gen_rtx (REG, Pmode, 19), hppa_save_pic_table_rtx));\n+\t\t\t  gen_rtx (REG, Pmode, PIC_OFFSET_TABLE_REGNUM),\n+\t\t\t  hppa_save_pic_table_rtx));\n     }\n   DONE;\n }\")\n \n (define_insn \"call_internal_symref\"\n- [(call (mem:SI (match_operand:SI 0 \"call_operand_address\" \"\"))\n-\t(match_operand 1 \"\" \"i\"))\n-  (clobber (reg:SI 2))\n-  (use (const_int 0))]\n- \"! TARGET_LONG_CALLS\"\n- \"*\n+  [(call (mem:SI (match_operand:SI 0 \"call_operand_address\" \"\"))\n+\t (match_operand 1 \"\" \"i\"))\n+   (clobber (reg:SI 2))\n+   (use (const_int 0))]\n+  \"! TARGET_LONG_CALLS\"\n+  \"*\n {\n   output_arg_descriptor (insn);\n   return output_call (insn, operands[0], gen_rtx (REG, SImode, 2));\n }\"\n- [(set_attr \"type\" \"call\")\n-  (set_attr \"length\" \"4\")])\n+  [(set_attr \"type\" \"call\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"call_internal_reg\"\n- [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"r\"))\n-\t(match_operand 1 \"\" \"i\"))\n-  (clobber (reg:SI 2))\n-  (use (const_int 1))]\n- \"\"\n- \"copy %r0,%%r22\\;.CALL\\\\tARGW0=GR\\;bl $$dyncall,%%r31\\;copy %%r31,%%r2\"\n- [(set_attr \"type\" \"dyncall\")\n-  (set_attr \"length\" \"12\")])\n+  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"r\"))\n+\t (match_operand 1 \"\" \"i\"))\n+   (clobber (reg:SI 2))\n+   (use (const_int 1))]\n+  \"\"\n+  \"copy %r0,%%r22\\;.CALL\\\\tARGW0=GR\\;bl $$dyncall,%%r31\\;copy %%r31,%%r2\"\n+  [(set_attr \"type\" \"dyncall\")\n+   (set_attr \"length\" \"12\")])\n \n (define_expand \"call_value\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n@@ -2927,8 +3017,12 @@\n   \"\n {\n   rtx op;\n-  \n-  if (TARGET_LONG_CALLS) \n+\n+  if (flag_pic)\n+    emit_insn (gen_rtx (USE, VOIDmode,\n+\t\t\tgen_rtx (REG, Pmode, PIC_OFFSET_TABLE_REGNUM)));\n+\n+  if (TARGET_LONG_CALLS)\n     op = force_reg (SImode, XEXP (operands[1], 0));\n   else\n     op = XEXP (operands[1], 0);\n@@ -2949,7 +3043,8 @@\n       if (!hppa_save_pic_table_rtx)\n \thppa_save_pic_table_rtx = gen_reg_rtx (Pmode);\n       emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t  gen_rtx (REG, Pmode, 19), hppa_save_pic_table_rtx));\n+\t\t\t  gen_rtx (REG, Pmode, PIC_OFFSET_TABLE_REGNUM),\n+\t\t\t  hppa_save_pic_table_rtx));\n     }\n   DONE;\n }\")\n@@ -2967,8 +3062,8 @@\n   output_arg_descriptor (insn);\n   return output_call (insn, operands[1], gen_rtx (REG, SImode, 2));\n }\"\n- [(set_attr \"type\" \"call\")\n-  (set_attr \"length\" \"4\")])\n+  [(set_attr \"type\" \"call\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"call_value_internal_reg\"\n   [(set (match_operand 0 \"\" \"=rfx\")\n@@ -2979,8 +3074,8 @@\n   ;;- Don't use operand 1 for most machines.\n   \"\"\n   \"copy %r1,%%r22\\;.CALL\\\\tARGW0=GR\\;bl $$dyncall,%%r31\\;copy %%r31,%%r2\"\n- [(set_attr \"type\" \"dyncall\")\n-  (set_attr \"length\" \"12\")])\n+  [(set_attr \"type\" \"dyncall\")\n+   (set_attr \"length\" \"12\")])\n \n ;; Call subroutine returning any type.\n \n@@ -3019,8 +3114,8 @@\n (define_insn \"indirect_jump\"\n   [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n   \"\"\n- \"bv%* 0(%0)\"\n- [(set_attr \"type\" \"branch\")])\n+  \"bv%* 0(%0)\"\n+  [(set_attr \"type\" \"branch\")])\n \n (define_insn \"extzv\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -3030,6 +3125,14 @@\n   \"\"\n   \"extru %1,%3+%2-1,%2,%0\")\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:SI 3 \"register_operand\" \"q\")))]\n+  \"\"\n+  \"vextru %1,1,%0\")\n+\n (define_insn \"extv\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n@@ -3038,6 +3141,14 @@\n   \"\"\n   \"extrs %1,%3+%2-1,%2,%0\")\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:SI 3 \"register_operand\" \"q\")))]\n+  \"\"\n+  \"vextrs %1,1,%0\")\n+\n (define_insn \"insv\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r,r\")\n \t\t\t (match_operand:SI 1 \"uint5_operand\" \"\")\n@@ -3082,7 +3193,7 @@\n    (clobber (match_scratch:SI 4 \"=X,r,r\"))]\n   \"\"\n   \"* return output_dbra (operands, insn, which_alternative); \"\n-;; Do not expect to understand this the first time through.  \n+;; Do not expect to understand this the first time through.\n [(set_attr \"type\" \"cbranch,multi,multi\")\n  (set (attr \"length\")\n       (if_then_else (eq_attr \"alternative\" \"0\")\n@@ -3098,31 +3209,31 @@\n ;; Extra goo to deal with additional reload insns.\n \t(if_then_else (eq_attr \"alternative\" \"1\")\n \t  (if_then_else (lt (match_dup 3) (pc))\n-\t    (if_then_else \n+\t    (if_then_else\n \t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 24))))\n \t\t  (const_int 8188))\n \t      (const_int 24)\n \t      (const_int 28))\n-\t    (if_then_else \n+\t    (if_then_else\n \t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n \t\t  (const_int 8188))\n \t      (const_int 24)\n \t      (const_int 28)))\n ;; Loop counter in memory case.\n ;; Extra goo to deal with additional reload insns.\n \t(if_then_else (lt (match_dup 3) (pc))\n-\t  (if_then_else \n+\t  (if_then_else\n \t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))\n \t\t(const_int 8188))\n \t    (const_int 12)\n \t    (const_int 16))\n-\t  (if_then_else \n+\t  (if_then_else\n \t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n \t\t(const_int 8188))\n \t    (const_int 12)\n \t    (const_int 16))))))])\n \n-;; Simply another variant of the dbra pattern.  More restrictive \n+;; Simply another variant of the dbra pattern.  More restrictive\n ;; in testing the comparison operator as it must worry about overflow\n ;; problems.\n (define_insn \"\"\n@@ -3138,7 +3249,7 @@\n    (clobber (match_scratch:SI 4 \"=X,r,r\"))]\n   \"INTVAL (operands[5]) == - INTVAL (operands[1])\"\n \"* return output_dbra (operands, insn, which_alternative);\"\n-;; Do not expect to understand this the first time through.  \n+;; Do not expect to understand this the first time through.\n [(set_attr \"type\" \"cbranch,multi,multi\")\n  (set (attr \"length\")\n       (if_then_else (eq_attr \"alternative\" \"0\")\n@@ -3154,25 +3265,25 @@\n ;; Extra goo to deal with additional reload insns.\n \t(if_then_else (eq_attr \"alternative\" \"1\")\n \t  (if_then_else (lt (match_dup 3) (pc))\n-\t    (if_then_else \n+\t    (if_then_else\n \t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 24))))\n \t\t  (const_int 8188))\n \t      (const_int 24)\n \t      (const_int 28))\n-\t    (if_then_else \n+\t    (if_then_else\n \t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n \t\t  (const_int 8188))\n \t      (const_int 24)\n \t      (const_int 28)))\n ;; Loop counter in memory case.\n ;; Extra goo to deal with additional reload insns.\n \t(if_then_else (lt (match_dup 3) (pc))\n-\t  (if_then_else \n+\t  (if_then_else\n \t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))\n \t\t(const_int 8188))\n \t    (const_int 12)\n \t    (const_int 16))\n-\t  (if_then_else \n+\t  (if_then_else\n \t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n \t\t(const_int 8188))\n \t    (const_int 12)\n@@ -3189,7 +3300,7 @@\n \t(match_dup 1))]\n   \"\"\n \"* return output_movb (operands, insn, which_alternative, 0); \"\n-;; Do not expect to understand this the first time through.  \n+;; Do not expect to understand this the first time through.\n [(set_attr \"type\" \"cbranch,multi,multi\")\n  (set (attr \"length\")\n       (if_then_else (eq_attr \"alternative\" \"0\")\n@@ -3205,19 +3316,19 @@\n ;; Extra goo to deal with additional reload insns.\n \t(if_then_else (eq_attr \"alternative\" \"1\")\n \t  (if_then_else (lt (match_dup 3) (pc))\n-\t    (if_then_else \n+\t    (if_then_else\n \t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))\n \t\t  (const_int 8188))\n \t      (const_int 12)\n \t      (const_int 16))\n-\t    (if_then_else \n+\t    (if_then_else\n \t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n \t\t  (const_int 8188))\n \t      (const_int 12)\n \t      (const_int 16)))\n ;; Loop counter in memory case.\n ;; Extra goo to deal with additional reload insns.\n-\t(if_then_else \n+\t(if_then_else\n \t  (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n \t      (const_int 8188))\n \t  (const_int 8)\n@@ -3235,7 +3346,7 @@\n \t(match_dup 1))]\n   \"\"\n \"* return output_movb (operands, insn, which_alternative, 1); \"\n-;; Do not expect to understand this the first time through.  \n+;; Do not expect to understand this the first time through.\n [(set_attr \"type\" \"cbranch,multi,multi\")\n  (set (attr \"length\")\n       (if_then_else (eq_attr \"alternative\" \"0\")\n@@ -3251,25 +3362,25 @@\n ;; Extra goo to deal with additional reload insns.\n \t(if_then_else (eq_attr \"alternative\" \"1\")\n \t  (if_then_else (lt (match_dup 3) (pc))\n-\t    (if_then_else \n+\t    (if_then_else\n \t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))\n \t\t  (const_int 8188))\n \t      (const_int 12)\n \t      (const_int 16))\n-\t    (if_then_else \n+\t    (if_then_else\n \t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n \t\t  (const_int 8188))\n \t      (const_int 12)\n \t      (const_int 16)))\n ;; Loop counter in memory case.\n ;; Extra goo to deal with additional reload insns.\n-\t(if_then_else \n+\t(if_then_else\n \t  (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n \t      (const_int 8188))\n \t  (const_int 8)\n \t  (const_int 12)))))])\n \n-;; The next four peepholes take advantage of the new 5 operand \n+;; The next four peepholes take advantage of the new 5 operand\n ;; fmpy{add,sub} instructions available on 1.1 CPUS.  Basically\n ;; fmpyadd performs a multiply and add/sub of independent operands\n ;; at the same time.  Because the operands must be independent\n@@ -3301,7 +3412,7 @@\n     }\n }\")\n \n-(define_peephole \n+(define_peephole\n   [(set (match_operand 3 \"register_operand\" \"+fx\")\n \t(plus (match_operand 4 \"register_operand\" \"fx\")\n \t      (match_operand 5 \"register_operand\" \"fx\")))"}]}