{"sha": "3b3ba9f0a65598ed634f1ae8451ee31ba9759627", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2IzYmE5ZjBhNjU1OThlZDYzNGYxYWU4NDUxZWUzMWJhOTc1OTYyNw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-03-03T01:39:03Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-03-03T01:39:03Z"}, "message": "call.c, [...]: Remove nsubsts parm from *type_unification* and unify.\n\n\t* call.c, class.c, pt.c, cp-tree.h: Remove nsubsts parm from\n\t*type_unification* and unify.\n\nFrom-SVN: r18377", "tree": {"sha": "58a7694de10a17b84291e79e9b5628147ddd317e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58a7694de10a17b84291e79e9b5628147ddd317e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b3ba9f0a65598ed634f1ae8451ee31ba9759627", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b3ba9f0a65598ed634f1ae8451ee31ba9759627", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b3ba9f0a65598ed634f1ae8451ee31ba9759627", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b3ba9f0a65598ed634f1ae8451ee31ba9759627/comments", "author": null, "committer": null, "parents": [{"sha": "d9f1e3dad53f3d81c23f51faa6465272acbf22a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9f1e3dad53f3d81c23f51faa6465272acbf22a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9f1e3dad53f3d81c23f51faa6465272acbf22a4"}], "stats": {"total": 88, "additions": 43, "deletions": 45}, "files": [{"sha": "d8adeecfda0ad90d1e796932b9e92e941d71be8c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b3ba9f0a65598ed634f1ae8451ee31ba9759627/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b3ba9f0a65598ed634f1ae8451ee31ba9759627/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3b3ba9f0a65598ed634f1ae8451ee31ba9759627", "patch": "@@ -1,3 +1,8 @@\n+Tue Mar  3 01:38:17 1998  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* call.c, class.c, pt.c, cp-tree.h: Remove nsubsts parm from\n+\t*type_unification* and unify.\n+\n Mon Mar  2 12:11:06 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* parse.y (explicit_template_type): Remove TEMPLATE keyword."}, {"sha": "276b32e7750886c1f6477f99e1799b8ab4c1162f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b3ba9f0a65598ed634f1ae8451ee31ba9759627/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b3ba9f0a65598ed634f1ae8451ee31ba9759627/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=3b3ba9f0a65598ed634f1ae8451ee31ba9759627", "patch": "@@ -2849,7 +2849,7 @@ build_overload_call_real (fnname, parms, flags, final_cp, require_complete)\n \t  i = type_unification (DECL_INNERMOST_TEMPLATE_PARMS (function),\n \t\t\t\t&TREE_VEC_ELT (targs, 0),\n \t\t\t\tTYPE_ARG_TYPES (TREE_TYPE (function)),\n-\t\t\t\tparms, NULL_TREE, &template_cost, 0, 0);\n+\t\t\t\tparms, NULL_TREE, 0, 0);\n \t  if (i == 0)\n \t    {\n \t      function = instantiate_template (function, targs);"}, {"sha": "22062e9c2ea8deebdf6fd54f72a757442f89620a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b3ba9f0a65598ed634f1ae8451ee31ba9759627/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b3ba9f0a65598ed634f1ae8451ee31ba9759627/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=3b3ba9f0a65598ed634f1ae8451ee31ba9759627", "patch": "@@ -5167,12 +5167,11 @@ instantiate_type (lhstype, rhs, complain)\n \t\t  {\n \t\t    int n = DECL_NTPARMS (elem);\n \t\t    tree t = make_scratch_vec (n);\n-\t\t    int i, d = 0;\n+\t\t    int i;\n \t\t    i = type_unification\n \t\t      (DECL_INNERMOST_TEMPLATE_PARMS (elem), \n \t\t       &TREE_VEC_ELT (t, 0), TYPE_ARG_TYPES (TREE_TYPE (elem)),\n-\t\t       TYPE_ARG_TYPES (lhstype), explicit_targs, &d,\n-\t\t       1, 1);\n+\t\t       TYPE_ARG_TYPES (lhstype), explicit_targs, 1, 1);\n \t\t    if (i == 0)\n \t\t      {\n \t\t\tif (save_elem)\n@@ -5183,7 +5182,7 @@ instantiate_type (lhstype, rhs, complain)\n \t\t\tsave_elem = instantiate_template (elem, t);\n \t\t\t/* Check the return type.  */\n \t\t\tif (! comptypes (TREE_TYPE (lhstype),\n-\t\t\t\t\t TREE_TYPE (TREE_TYPE (save_elem)), 1))\n+\t\t\t\t\t TREE_TYPE (TREE_TYPE (t)), 1))\n \t\t\t  save_elem = 0;\n \t\t      }\n \t\t  }"}, {"sha": "5f346b51488c54da9224641f6378147edf0586ba", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b3ba9f0a65598ed634f1ae8451ee31ba9759627/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b3ba9f0a65598ed634f1ae8451ee31ba9759627/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3b3ba9f0a65598ed634f1ae8451ee31ba9759627", "patch": "@@ -2442,7 +2442,7 @@ extern tree instantiate_class_template\t\tPROTO((tree));\n extern tree instantiate_template\t\tPROTO((tree, tree));\n extern void overload_template_name\t\tPROTO((tree));\n extern int fn_type_unification                  PROTO((tree, tree, tree, tree, tree, int, tree));\n-extern int type_unification\t\t\tPROTO((tree, tree *, tree, tree, tree, int *, int, int));\n+extern int type_unification\t\t\tPROTO((tree, tree *, tree, tree, tree, int, int));\n struct tinst_level *tinst_for_decl\t\tPROTO((void));\n extern void mark_decl_instantiated\t\tPROTO((tree, int));\n extern int more_specialized\t\t\tPROTO((tree, tree, tree));"}, {"sha": "3a3db96cce6f4edcef6b2f78333266167fadde03", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 33, "deletions": 39, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b3ba9f0a65598ed634f1ae8451ee31ba9759627/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b3ba9f0a65598ed634f1ae8451ee31ba9759627/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=3b3ba9f0a65598ed634f1ae8451ee31ba9759627", "patch": "@@ -69,7 +69,7 @@ static tree saved_trees;\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-static int unify PROTO((tree, tree *, int, tree, tree, int *, int));\n+static int unify PROTO((tree, tree *, int, tree, tree, int));\n static void add_pending_template PROTO((tree));\n static int push_tinst_level PROTO((tree));\n static tree classtype_mangled_name PROTO((tree));\n@@ -81,7 +81,7 @@ static tree get_class_bindings PROTO((tree, tree, tree, tree));\n static tree coerce_template_parms PROTO((tree, tree, tree, int, int, int));\n static tree tsubst_enum\tPROTO((tree, tree, tree *));\n static tree add_to_template_args PROTO((tree, tree));\n-static int  type_unification_real PROTO((tree, tree *, tree, tree, int*,\n+static int  type_unification_real PROTO((tree, tree *, tree, tree,\n \t\t\t\t\t int, int, int));\n static void note_template_header PROTO((int));\n static tree maybe_fold_nontype_arg PROTO((tree));\n@@ -542,7 +542,6 @@ determine_specialization (template_id, decl, targs_out,\n   for (; fn != NULL_TREE; \n        fn = overloaded ? DECL_CHAIN (fn) : NULL_TREE)\n     {\n-      int dummy = 0;\n       tree tmpl;\n \n       if (!need_member_template \n@@ -576,7 +575,7 @@ determine_specialization (template_id, decl, targs_out,\n \t\t\t\tNULL_TREE,\n \t\t\t\tNULL_TREE,  \n \t\t\t\ttargs_in,\n-\t\t\t\t&dummy, 1, 1);\n+\t\t\t\t1, 1);\n       \n \t  if (i == 0) \n \t    /* Unification was successful.  */\n@@ -5024,7 +5023,7 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n      int strict;\n      tree extra_fn_arg;\n {\n-  int i, dummy = 0;\n+  int i;\n   tree fn_arg_types = TYPE_ARG_TYPES (TREE_TYPE (fn));\n   tree decl_arg_types = args;\n \n@@ -5051,7 +5050,7 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n \t\t\tfn_arg_types,\n \t\t\tdecl_arg_types,\n \t\t\texplicit_targs,\n-\t\t\t&dummy, strict, 0);\n+\t\t\tstrict, 0);\n \n   return i;\n }\n@@ -5081,10 +5080,10 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n    addresses, explicit instantiation, and more_specialized).  */\n \n int\n-type_unification (tparms, targs, parms, args, targs_in, nsubsts,\n+type_unification (tparms, targs, parms, args, targs_in,\n \t\t  strict, allow_incomplete)\n      tree tparms, *targs, parms, args, targs_in;\n-     int *nsubsts, strict, allow_incomplete;\n+     int strict, allow_incomplete;\n {\n   int ntparms = TREE_VEC_LENGTH (tparms);\n   tree arg;\n@@ -5112,7 +5111,7 @@ type_unification (tparms, targs, parms, args, targs_in, nsubsts,\n \ttargs[i] = build1 (NOP_EXPR, NULL_TREE, TREE_VEC_ELT (arg_vec, i));\n     }\n   \n-  r = type_unification_real (tparms, targs, parms, args, nsubsts, 0,\n+  r = type_unification_real (tparms, targs, parms, args, 0,\n \t\t\t     strict, allow_incomplete); \n \n   for (i = 0, arg = targs_in; \n@@ -5126,10 +5125,10 @@ type_unification (tparms, targs, parms, args, targs_in, nsubsts,\n \n \n static int\n-type_unification_real (tparms, targs, parms, args, nsubsts, subr,\n+type_unification_real (tparms, targs, parms, args, subr,\n \t\t       strict, allow_incomplete)\n      tree tparms, *targs, parms, args;\n-     int *nsubsts, subr, strict, allow_incomplete;\n+     int subr, strict, allow_incomplete;\n {\n   tree parm, arg;\n   int i;\n@@ -5202,20 +5201,19 @@ type_unification_real (tparms, targs, parms, args, nsubsts, subr,\n \t      && TREE_TYPE (arg) == unknown_type_node\n \t      && TREE_CODE (TREE_VALUE (arg)) == TEMPLATE_DECL)\n \t    {\n-\t      int nsubsts, ntparms;\n+\t      int ntparms;\n \t      tree *targs;\n \n \t      /* Have to back unify here */\n \t      arg = TREE_VALUE (arg);\n-\t      nsubsts = 0;\n \t      ntparms = DECL_NTPARMS (arg);\n \t      targs = (tree *) alloca (sizeof (tree) * ntparms);\n \t      parm = expr_tree_cons (NULL_TREE, parm, NULL_TREE);\n \t      return \n \t\ttype_unification (DECL_INNERMOST_TEMPLATE_PARMS (arg), \n \t\t\t\t  targs,\n \t\t\t\t  TYPE_ARG_TYPES (TREE_TYPE (arg)),\n-\t\t\t\t  parm, NULL_TREE, &nsubsts, strict,\n+\t\t\t\t  parm, NULL_TREE, strict,\n \t\t\t\t  allow_incomplete); \n \t    }\n \t  arg = TREE_TYPE (arg);\n@@ -5241,7 +5239,7 @@ type_unification_real (tparms, targs, parms, args, nsubsts, subr,\n \t    arg = TYPE_MAIN_VARIANT (arg);\n \t}\n \n-      switch (unify (tparms, targs, ntparms, parm, arg, nsubsts, strict))\n+      switch (unify (tparms, targs, ntparms, parm, arg, strict))\n \t{\n \tcase 0:\n \t  break;\n@@ -5272,9 +5270,9 @@ type_unification_real (tparms, targs, parms, args, nsubsts, subr,\n /* Tail recursion is your friend.  */\n \n static int\n-unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n+unify (tparms, targs, ntparms, parm, arg, strict)\n      tree tparms, *targs, parm, arg;\n-     int *nsubsts, ntparms, strict;\n+     int ntparms, strict;\n {\n   int idx;\n \n@@ -5301,7 +5299,6 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n       return 0;\n \n     case TEMPLATE_TYPE_PARM:\n-      (*nsubsts)++;\n       idx = TEMPLATE_TYPE_IDX (parm);\n       /* Check for mixed types and values.  */\n       if (TREE_CODE (TREE_VALUE (TREE_VEC_ELT (tparms, idx))) != TYPE_DECL)\n@@ -5344,7 +5341,6 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n       return 0;\n \n     case TEMPLATE_TEMPLATE_PARM:\n-      (*nsubsts)++;\n       idx = TEMPLATE_TYPE_IDX (parm);\n       /* Check for mixed types and values.  */\n       if (TREE_CODE (TREE_VALUE (TREE_VEC_ELT (tparms, idx))) != TEMPLATE_DECL)\n@@ -5397,7 +5393,7 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n \t\t/* This argument can be deduced.  */\n \n \t\tif (unify (tparms, targs, ntparms, t, \n-\t\t\t   TREE_VEC_ELT (argvec, i), nsubsts, strict))\n+\t\t\t   TREE_VEC_ELT (argvec, i), strict))\n \t\t  return 1;\n \t      }\n \t  }\n@@ -5416,7 +5412,6 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n       return 0;\n \n     case TEMPLATE_PARM_INDEX:\n-      (*nsubsts)++;\n       idx = TEMPLATE_PARM_IDX (parm);\n       if (targs[idx])\n \t{\n@@ -5435,18 +5430,18 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n     case POINTER_TYPE:\n       if (TREE_CODE (arg) == RECORD_TYPE && TYPE_PTRMEMFUNC_FLAG (arg))\n \treturn unify (tparms, targs, ntparms, parm,\n-\t\t      TYPE_PTRMEMFUNC_FN_TYPE (arg), nsubsts, strict);\n+\t\t      TYPE_PTRMEMFUNC_FN_TYPE (arg), strict);\n \n       if (TREE_CODE (arg) != POINTER_TYPE)\n \treturn 1;\n       return unify (tparms, targs, ntparms, TREE_TYPE (parm), TREE_TYPE (arg),\n-\t\t    nsubsts, strict);\n+\t\t    strict);\n \n     case REFERENCE_TYPE:\n       if (TREE_CODE (arg) == REFERENCE_TYPE)\n \targ = TREE_TYPE (arg);\n       return unify (tparms, targs, ntparms, TREE_TYPE (parm), arg,\n-\t\t    nsubsts, strict);\n+\t\t    strict);\n \n     case ARRAY_TYPE:\n       if (TREE_CODE (arg) != ARRAY_TYPE)\n@@ -5456,10 +5451,10 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n \treturn 1;\n       if (TYPE_DOMAIN (parm) != NULL_TREE\n \t  && unify (tparms, targs, ntparms, TYPE_DOMAIN (parm),\n-\t\t    TYPE_DOMAIN (arg), nsubsts, strict) != 0)\n+\t\t    TYPE_DOMAIN (arg), strict) != 0)\n \treturn 1;\n       return unify (tparms, targs, ntparms, TREE_TYPE (parm), TREE_TYPE (arg),\n-\t\t    nsubsts, strict);\n+\t\t    strict);\n \n     case REAL_TYPE:\n     case COMPLEX_TYPE:\n@@ -5473,11 +5468,11 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n \t{\n \t  if (TYPE_MIN_VALUE (parm) && TYPE_MIN_VALUE (arg)\n \t      && unify (tparms, targs, ntparms, TYPE_MIN_VALUE (parm),\n-\t\t\tTYPE_MIN_VALUE (arg), nsubsts, strict))\n+\t\t\tTYPE_MIN_VALUE (arg), strict))\n \t    return 1;\n \t  if (TYPE_MAX_VALUE (parm) && TYPE_MAX_VALUE (arg)\n \t      && unify (tparms, targs, ntparms, TYPE_MAX_VALUE (parm),\n-\t\t\tTYPE_MAX_VALUE (arg), nsubsts, strict))\n+\t\t\tTYPE_MAX_VALUE (arg), strict))\n \t    return 1;\n \t}\n       else if (TREE_CODE (parm) == REAL_TYPE\n@@ -5505,7 +5500,7 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n \tt2 = TREE_OPERAND (parm, 1);\n \treturn unify (tparms, targs, ntparms, t1,\n \t\t      fold (build (PLUS_EXPR, integer_type_node, arg, t2)),\n-\t\t      nsubsts, strict);\n+\t\t      strict);\n       }\n \n     case TREE_VEC:\n@@ -5518,15 +5513,15 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n \tfor (i = TREE_VEC_LENGTH (parm) - 1; i >= 0; i--)\n \t  if (unify (tparms, targs, ntparms,\n \t\t     TREE_VEC_ELT (parm, i), TREE_VEC_ELT (arg, i),\n-\t\t     nsubsts, strict))\n+\t\t     strict))\n \t    return 1;\n \treturn 0;\n       }\n \n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_FLAG (parm))\n \treturn unify (tparms, targs, ntparms, TYPE_PTRMEMFUNC_FN_TYPE (parm),\n-\t\t      arg, nsubsts, strict);\n+\t\t      arg, strict);\n \n       /* Allow trivial conversions.  */\n       if (TREE_CODE (arg) != RECORD_TYPE\n@@ -5547,7 +5542,7 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n \t    return 1;\n \n \t  return unify (tparms, targs, ntparms, CLASSTYPE_TI_ARGS (parm),\n-\t\t\tCLASSTYPE_TI_ARGS (t), nsubsts, strict);\n+\t\t\tCLASSTYPE_TI_ARGS (t), strict);\n \t}\n       else if (TYPE_MAIN_VARIANT (parm) != TYPE_MAIN_VARIANT (arg))\n \treturn 1;\n@@ -5563,20 +5558,20 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n \treturn 1;\n      check_args:\n       if (unify (tparms, targs, ntparms, TREE_TYPE (parm),\n-\t\t TREE_TYPE (arg), nsubsts, strict))\n+\t\t TREE_TYPE (arg), strict))\n \treturn 1;\n       return type_unification_real (tparms, targs, TYPE_ARG_TYPES (parm),\n-\t\t\t\t    TYPE_ARG_TYPES (arg), nsubsts, 1, \n+\t\t\t\t    TYPE_ARG_TYPES (arg), 1, \n \t\t\t\t    strict, 0);\n \n     case OFFSET_TYPE:\n       if (TREE_CODE (arg) != OFFSET_TYPE)\n \treturn 1;\n       if (unify (tparms, targs, ntparms, TYPE_OFFSET_BASETYPE (parm),\n-\t\t TYPE_OFFSET_BASETYPE (arg), nsubsts, strict))\n+\t\t TYPE_OFFSET_BASETYPE (arg), strict))\n \treturn 1;\n       return unify (tparms, targs, ntparms, TREE_TYPE (parm),\n-\t\t    TREE_TYPE (arg), nsubsts, strict);\n+\t\t    TREE_TYPE (arg), strict);\n \n     case CONST_DECL:\n       if (arg != decl_constant_value (parm))\n@@ -5736,7 +5731,7 @@ static tree\n get_class_bindings (tparms, parms, args, outer_args)\n      tree tparms, parms, args, outer_args;\n {\n-  int i, dummy, ntparms = TREE_VEC_LENGTH (tparms);\n+  int i, ntparms = TREE_VEC_LENGTH (tparms);\n   tree vec = make_temp_vec (ntparms);\n \n   if (outer_args)\n@@ -5748,8 +5743,7 @@ get_class_bindings (tparms, parms, args, outer_args)\n   for (i = 0; i < TREE_VEC_LENGTH (parms); ++i)\n     {\n       switch (unify (tparms, &TREE_VEC_ELT (vec, 0), ntparms,\n-\t\t     TREE_VEC_ELT (parms, i), TREE_VEC_ELT (args, i),\n-\t\t     &dummy, 1))\n+\t\t     TREE_VEC_ELT (parms, i), TREE_VEC_ELT (args, i), 1))\n \t{\n \tcase 0:\n \t  break;"}]}