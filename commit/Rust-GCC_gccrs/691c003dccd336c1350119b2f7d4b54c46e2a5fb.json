{"sha": "691c003dccd336c1350119b2f7d4b54c46e2a5fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkxYzAwM2RjY2QzMzZjMTM1MDExOWIyZjdkNGI1NGM0NmUyYTVmYg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-10-31T17:08:58Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-10-31T17:08:58Z"}, "message": "90th Cygnus<->FSF quick merge\n\nFrom-SVN: r13082", "tree": {"sha": "f482dabe3bf5332dad7f8b35b91fd4b491d5841f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f482dabe3bf5332dad7f8b35b91fd4b491d5841f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/691c003dccd336c1350119b2f7d4b54c46e2a5fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/691c003dccd336c1350119b2f7d4b54c46e2a5fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/691c003dccd336c1350119b2f7d4b54c46e2a5fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/691c003dccd336c1350119b2f7d4b54c46e2a5fb/comments", "author": null, "committer": null, "parents": [{"sha": "cced4d25eadca69195cc6f854b4e67a981a0faae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cced4d25eadca69195cc6f854b4e67a981a0faae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cced4d25eadca69195cc6f854b4e67a981a0faae"}], "stats": {"total": 232, "additions": 98, "deletions": 134}, "files": [{"sha": "b5cf22ac60ba5362dfabace6cebe72a117b1f0db", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/691c003dccd336c1350119b2f7d4b54c46e2a5fb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/691c003dccd336c1350119b2f7d4b54c46e2a5fb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=691c003dccd336c1350119b2f7d4b54c46e2a5fb", "patch": "@@ -1,3 +1,31 @@\n+Mon Oct 28 12:45:05 1996  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* typeck.c (signed_or_unsigned_type): If the given type already\n+\tas the correct signedness, then just return it.\n+\n+        * typeck.c ({un,}signed_type): If can't do anything, call\n+        signed_or_unsigned_type.\n+\n+Thu Oct 24 14:21:59 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* decl2.c (copy_assignment_arg_p): Don't buy the farm if\n+\tcurrent_class_type is NULL.\n+\n+Wed Oct 23 00:43:10 1996  Jason Merrill  <jason@gerbil.cygnus.com>\n+\n+\t* class.c (finish_struct_1): Avoid empty structs by adding a field\n+ \tso layout_type gets the mode right.\n+\n+\t* typeck.c (c_expand_return): Drastically simplify.\n+\n+Mon Oct 21 22:34:02 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck.c (decay_conversion): Handle overloaded methods.\n+\n+Fri Oct 18 16:03:48 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* call.c (build_over_call): A TARGET_EXPR has side-effects.\n+\n Thu Oct 17 11:31:59 1996  Mike Stump  <mrs@cygnus.com>\n \n \t* cvt.c (convert_to_pointer_force): Add code to support pointer to"}, {"sha": "80258c0fc613035c6d18136fb7d256239725fc17", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/691c003dccd336c1350119b2f7d4b54c46e2a5fb/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/691c003dccd336c1350119b2f7d4b54c46e2a5fb/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=691c003dccd336c1350119b2f7d4b54c46e2a5fb", "patch": "@@ -5099,7 +5099,9 @@ build_over_call (fn, convs, args, flags)\n \t    {\n \t      val = build (VAR_DECL, DECL_CONTEXT (fn));\n \t      layout_decl (val, 0);\n-\t      return build (TARGET_EXPR, DECL_CONTEXT (fn), val, arg, 0, 0);\n+\t      val = build (TARGET_EXPR, DECL_CONTEXT (fn), val, arg, 0, 0);\n+\t      TREE_SIDE_EFFECTS (val) = 1;\n+\t      return val;\n \t    }\n \t}\n       else if (! real_lvalue_p (arg)"}, {"sha": "28391dc7cb2af816533dd416dc9f00bcd087b1a7", "filename": "gcc/cp/class.c", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/691c003dccd336c1350119b2f7d4b54c46e2a5fb/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/691c003dccd336c1350119b2f7d4b54c46e2a5fb/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=691c003dccd336c1350119b2f7d4b54c46e2a5fb", "patch": "@@ -3051,6 +3051,7 @@ finish_struct_1 (t, warn_anon)\n   tree t_binfo = TYPE_BINFO (t);\n   tree access_decls = NULL_TREE;\n   int aggregate = 1;\n+  int empty = 1;\n \n   if (warn_anon && code != UNION_TYPE && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n     pedwarn (\"anonymous class type not used to declare any objects\");\n@@ -3215,7 +3216,10 @@ finish_struct_1 (t, warn_anon)\n       GNU_xref_member (current_class_name, x);\n \n       if (TREE_CODE (x) == FIELD_DECL)\n-\tDECL_PACKED (x) |= TYPE_PACKED (t);\n+\t{\n+\t  DECL_PACKED (x) |= TYPE_PACKED (t);\n+\t  empty = 0;\n+\t}\n \n       /* Handle access declarations.  */\n       if (TREE_CODE (x) == USING_DECL)\n@@ -3767,6 +3771,7 @@ finish_struct_1 (t, warn_anon)\n       else\n \tfields = vfield;\n #endif\n+      empty = 0;\n       vfields = chainon (vfields, CLASSTYPE_AS_LIST (t));\n     }\n \n@@ -3836,18 +3841,22 @@ finish_struct_1 (t, warn_anon)\n       /* Don't re-use old size.  */\n       DECL_SIZE (base_layout_decl) = NULL_TREE;\n     }\n+  else if (empty)\n+    {\n+      /* C++: do not let empty structures exist.  */\n+      tree decl = build_lang_field_decl\n+\t(FIELD_DECL, NULL_TREE, char_type_node);\n+      TREE_CHAIN (decl) = TYPE_FIELDS (t);\n+      TYPE_FIELDS (t) = decl;\n+    }\n \n   layout_type (t);\n \n   finish_struct_anon (t);\n \n-  if (n_baseclasses)\n+  if (n_baseclasses || empty)\n     TYPE_FIELDS (t) = TREE_CHAIN (TYPE_FIELDS (t));\n \n-  /* C++: do not let empty structures exist.  */\n-  if (integer_zerop (TYPE_SIZE (t)))\n-    TYPE_SIZE (t) = TYPE_SIZE (char_type_node);\n-\n   /* Set the TYPE_DECL for this type to contain the right\n      value for DECL_OFFSET, so that we can use it as part\n      of a COMPONENT_REF for multiple inheritance.  */"}, {"sha": "4bd06a36fdcd14e4f7f50dd63089bd60ee0e0f1b", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/691c003dccd336c1350119b2f7d4b54c46e2a5fb/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/691c003dccd336c1350119b2f7d4b54c46e2a5fb/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=691c003dccd336c1350119b2f7d4b54c46e2a5fb", "patch": "@@ -1672,6 +1672,9 @@ copy_assignment_arg_p (parmtype, virtualp)\n      tree parmtype;\n      int virtualp;\n {\n+  if (current_class_type == NULL_TREE)\n+    return 0;\n+\n   if (TREE_CODE (parmtype) == REFERENCE_TYPE)\n     parmtype = TREE_TYPE (parmtype);\n "}, {"sha": "4c876f6304ae5dea19ce2316df7b89d80faf4882", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 49, "deletions": 127, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/691c003dccd336c1350119b2f7d4b54c46e2a5fb/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/691c003dccd336c1350119b2f7d4b54c46e2a5fb/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=691c003dccd336c1350119b2f7d4b54c46e2a5fb", "patch": "@@ -1210,7 +1210,8 @@ unsigned_type (type)\n     return unsigned_intHI_type_node;\n   if (type1 == intQI_type_node)\n     return unsigned_intQI_type_node;\n-  return type;\n+\n+  return signed_or_unsigned_type (1, type);\n }\n \n /* Return a signed type the same as TYPE in other respects.  */\n@@ -1238,7 +1239,8 @@ signed_type (type)\n     return intHI_type_node;\n   if (type1 == unsigned_intQI_type_node)\n     return intQI_type_node;\n-  return type;\n+\n+  return signed_or_unsigned_type (0, type);\n }\n \n /* Return a type the same as TYPE except unsigned or\n@@ -1249,8 +1251,10 @@ signed_or_unsigned_type (unsignedp, type)\n      int unsignedp;\n      tree type;\n {\n-  if (! INTEGRAL_TYPE_P (type))\n+  if (! INTEGRAL_TYPE_P (type)\n+      || TREE_UNSIGNED (type) == unsignedp)\n     return type;\n+\n   if (TYPE_PRECISION (type) == TYPE_PRECISION (signed_char_type_node))\n     return unsignedp ? unsigned_char_type_node : signed_char_type_node;\n   if (TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node)) \n@@ -1445,6 +1449,12 @@ decay_conversion (exp)\n \n       type = TREE_TYPE (type);\n       code = TREE_CODE (type);\n+\n+      if (type == unknown_type_node)\n+\t{\n+\t  cp_pedwarn (\"assuming & on overloaded member function\");\n+\t  return build_unary_op (ADDR_EXPR, exp, 0);\n+\t}\n     }\n \n   if (code == REFERENCE_TYPE)\n@@ -7018,7 +7028,6 @@ c_expand_return (retval)\n   extern tree dtor_label, ctor_label;\n   tree result = DECL_RESULT (current_function_decl);\n   tree valtype = TREE_TYPE (result);\n-  int returns_value = 1;\n \n   if (TREE_THIS_VOLATILE (current_function_decl))\n     warning (\"function declared `noreturn' has a `return' statement\");\n@@ -7074,20 +7083,20 @@ c_expand_return (retval)\n   else if (DECL_CONSTRUCTOR_P (current_function_decl)\n \t   && retval != current_class_ptr)\n     {\n-      error (\"return from a constructor: use `this = ...' instead\");\n+      if (flag_this_is_variable)\n+\terror (\"return from a constructor: use `this = ...' instead\");\n+      else\n+\terror (\"return from a constructor\");\n       retval = current_class_ptr;\n     }\n \n   if (valtype == NULL_TREE || TREE_CODE (valtype) == VOID_TYPE)\n     {\n       current_function_returns_null = 1;\n-      /* We do this here so we'll avoid a warning about how the function\n-\t \"may or may not return a value\" in finish_function.  */\n-      returns_value = 0;\n-\n-      if (retval)\n+      if (pedantic || TREE_CODE (TREE_TYPE (retval)) != VOID_TYPE)\n \tpedwarn (\"`return' with a value, in function returning void\");\n       expand_return (retval);\n+      return;\n     }\n   /* Add some useful error checking for C++.  */\n   else if (TREE_CODE (valtype) == REFERENCE_TYPE)\n@@ -7168,143 +7177,56 @@ c_expand_return (retval)\n      (3) If an X(X&) constructor is defined, the return\n      value must be returned via that.  */\n \n-  /* If we're returning in a register, we can't initialize the\n-     return value from a TARGET_EXPR.  */\n-  if (TREE_CODE (retval) == TARGET_EXPR\n-      && TYPE_MAIN_VARIANT (TREE_TYPE (retval)) == TYPE_MAIN_VARIANT (valtype)\n-      && ! current_function_returns_struct)\n-    retval = expand_target_expr (retval);\n-\n   if (retval == result\n-      /* Watch out for constructors, which \"return\" aggregates\n-\t via initialization, but which otherwise \"return\" a pointer.  */\n       || DECL_CONSTRUCTOR_P (current_function_decl))\n+    /* It's already done for us.  */;\n+  else if (TYPE_MODE (TREE_TYPE (retval)) == VOIDmode)\n     {\n-      /* This is just an error--it's already been reported.  */\n-      if (TYPE_SIZE (valtype) == NULL_TREE)\n-\treturn;\n-\n-      if (TYPE_MODE (valtype) != BLKmode\n-\t  && any_pending_cleanups (1))\n-\tretval = get_temp_regvar (valtype, retval);\n-    }\n-  else if (IS_AGGR_TYPE (valtype) && current_function_returns_struct)\n-    {\n-      expand_aggr_init (result, retval, 0, LOOKUP_ONLYCONVERTING);\n-      expand_cleanups_to (NULL_TREE);\n-      DECL_INITIAL (result) = NULL_TREE;\n+      pedwarn (\"return of void value in function returning non-void\");\n+      expand_expr_stmt (retval);\n       retval = 0;\n     }\n   else\n     {\n-      if (TYPE_MODE (valtype) == VOIDmode)\n-\t{\n-\t  if (TYPE_MODE (TREE_TYPE (result)) != VOIDmode\n-\t      && warn_return_type)\n-\t    warning (\"return of void value in function returning non-void\");\n-\t  expand_expr_stmt (retval);\n-\t  retval = 0;\n-\t  result = 0;\n-\t}\n-      else if (TYPE_MODE (valtype) != BLKmode\n-\t       && any_pending_cleanups (1))\n-\t{\n-\t  retval = get_temp_regvar (valtype, retval);\n-\t  expand_cleanups_to (NULL_TREE);\n-\t  result = 0;\n-\t}\n-      else\n+      /* We already did this above for refs, don't do it again.  */\n+      if (TREE_CODE (valtype) != REFERENCE_TYPE)\n+\tretval = convert_for_initialization (NULL_TREE, valtype, retval,\n+\t\t\t\t\t     LOOKUP_NORMAL,\n+\t\t\t\t\t     \"return\", NULL_TREE, 0);\n+\n+      /* We can't initialize a register from a NEW_EXPR.  */\n+      if (! current_function_returns_struct\n+\t  && TREE_CODE (retval) == TARGET_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (retval, 0)) == NEW_EXPR)\n+\tretval = build (COMPOUND_EXPR, TREE_TYPE (retval), retval,\n+\t\t\tTREE_OPERAND (retval, 0));\n+\n+      if (retval == error_mark_node)\n \t{\n-\t  /* We already did this above, don't do it again.  */\n-\t  if (TREE_CODE (valtype) != REFERENCE_TYPE)\n-\t    retval = convert_for_initialization (result, valtype, retval,\n-\t\t\t\t\t\t LOOKUP_NORMAL,\n-\t\t\t\t\t\t \"return\", NULL_TREE, 0);\n-\t  DECL_INITIAL (result) = NULL_TREE;\n+\t  /* Avoid warning about control reaching end of function.  */\n+\t  expand_null_return ();\n+\t  return;\n \t}\n-      if (retval == error_mark_node)\n-\treturn;\n     }\n \n-  emit_queue ();\n-\n   if (retval != NULL_TREE\n       && TREE_CODE_CLASS (TREE_CODE (retval)) == 'd'\n       && cond_stack == 0 && loop_stack == 0 && case_stack == 0)\n     current_function_return_value = retval;\n \n-  if (result)\n+  if (ctor_label && TREE_CODE (ctor_label) != ERROR_MARK)\n     {\n-      /* Everything's great--RETVAL is in RESULT.  */\n-      if (original_result_rtx)\n-\t{\n-\t  store_expr (result, original_result_rtx, 0);\n-\t  expand_cleanups_to (NULL_TREE);\n-\t  use_variable (DECL_RTL (result));\n-\t  if (ctor_label  && TREE_CODE (ctor_label) != ERROR_MARK)\n-\t    expand_goto (ctor_label);\n-\t  else\n-\t    expand_null_return ();\n-\t}\n-      else if (retval && retval != result)\n-\t{\n-\t  /* Clear this out so the later call to decl_function_context\n-\t     won't end up bombing on us.  */\n-\t  if (DECL_CONTEXT (result) == error_mark_node)\n-\t    DECL_CONTEXT (result) = NULL_TREE;\n-\t  /* Here is where we finally get RETVAL into RESULT.\n-\t     `expand_return' does the magic of protecting\n-\t     RESULT from cleanups.  */\n-\t  retval = fold (build1 (CLEANUP_POINT_EXPR, TREE_TYPE (result),\n-\t\t\t\t retval));\n-\t  /* This part _must_ come second, because expand_return looks for\n-\t     the INIT_EXPR as the toplevel node only.  :-( */\n-\t  retval = build (INIT_EXPR, TREE_TYPE (result), result, retval);\n-\t  TREE_SIDE_EFFECTS (retval) = 1;\n-\t  expand_return (retval);\n-\t}\n-      else\n-\texpand_return (result);\n+      /* Here RETVAL is CURRENT_CLASS_PTR, so there's nothing to do.  */\n+      expand_goto (ctor_label);\n     }\n-  else\n+\n+  if (retval && retval != result)\n     {\n-      /* We may still need to put RETVAL into RESULT.  */\n-      result = DECL_RESULT (current_function_decl);\n-      if (original_result_rtx)\n-\t{\n-\t  /* Here we have a named return value that went\n-\t     into memory.  We can compute RETVAL into that.  */\n-\t  if (retval)\n-\t    expand_assignment (result, retval, 0, 0);\n-\t  else\n-\t    store_expr (result, original_result_rtx, 0);\n-\t  result = make_tree (TREE_TYPE (result), original_result_rtx);\n-\t}\n-      else if (ctor_label && TREE_CODE (ctor_label) != ERROR_MARK)\n-\t{\n-\t  /* Here RETVAL is CURRENT_CLASS_PTR, so there's nothing to do.  */\n-\t  expand_goto (ctor_label);\n-\t}\n-      else if (retval)\n-\t{\n-\t  /* Here is where we finally get RETVAL into RESULT.\n-\t     `expand_return' does the magic of protecting\n-\t     RESULT from cleanups.  */\n-\t  result = build (INIT_EXPR, TREE_TYPE (result), result, retval);\n-\t  TREE_SIDE_EFFECTS (result) = 1;\n-\t  expand_return (result);\n-\t}\n-      else if (TYPE_MODE (TREE_TYPE (result)) != VOIDmode)\n-\texpand_return (result);\n+      result = build (INIT_EXPR, TREE_TYPE (result), result, retval);\n+      TREE_SIDE_EFFECTS (result) = 1;\n     }\n-\n-  current_function_returns_value = returns_value;\n-\n-  /* One way to clear out cleanups that EXPR might\n-     generate.  Note that this code will really be\n-     dead code, but that is ok--cleanups that were\n-     needed were handled by the magic of `return'.  */\n-  expand_cleanups_to (NULL_TREE);\n+  expand_return (result);\n+  current_function_returns_value = 1;\n }\n \f\n /* Start a C switch statement, testing expression EXP."}]}