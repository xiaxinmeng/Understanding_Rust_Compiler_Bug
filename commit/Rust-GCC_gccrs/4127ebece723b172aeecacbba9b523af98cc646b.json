{"sha": "4127ebece723b172aeecacbba9b523af98cc646b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDEyN2ViZWNlNzIzYjE3MmFlZWNhY2JiYTliNTIzYWY5OGNjNjQ2Yg==", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2020-01-31T19:36:51Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-11T09:53:48Z"}, "message": "[Ada] Allow specifying volatility refinement aspects for types\n\n2020-06-11  Steve Baird  <baird@adacore.com>\n\ngcc/ada/\n\n\t* contracts.adb (Add_Contract_Item): Support specifying\n\tvolatility refinement aspects for types.\n\t(Analyze_Contracts): Add call to Analyze_Type_Contract in the\n\tcase of a contract for a type.\n\t(Freeze_Contracts): Add call to Analyze_Type_Contract in the\n\tcase of a contract for a type.\n\t(Check_Type_Or_Object_External_Properties): A new procedure\n\twhich performs the work that needs to be done for both object\n\tdeclarations and types.\n\t(Analyze_Object_Contract): Add a call to\n\tCheck_Type_Or_Object_External_Properties and remove the code in\n\tthis procedure which did much of the work that is now performed\n\tby that call.\n\t(Analyze_Type_Contract): Implement this new routine as nothing\n\tmore than a call to Check_Type_Or_Object_External_Properties.\n\t* contracts.ads: Update comment for Add_Contract_To_Item because\n\ttypes can have contracts.  Follow (questionable) precedent and\n\tdeclare new routine Analyze_Type_Contract as visible (following\n\texample of Analyze_Object_Contract), despite the fact that it is\n\tnever called from outside of the package where it is declared.\n\t* einfo.adb (Contract, Set_Contract): Id argument can be a type;\n\tsupport this case.\n\t(Write_Field34_Name): Field name is \"contract\" for a type.\n\t* einfo.ads: Update comment describing Contract attribute.\n\t* sem_ch3.adb (Build_Derived_Numeric_Type): Is_Volatile should\n\treturn same answer for all subtypes of a given type. Thus, when\n\tbuilding the base type for something like type Volatile_1_To_10\n\tis range 1 .. 10 with Volatile; that basetype should be marked\n\tas being volatile.\n\t(Access_Type_Declaration): Add SPARK-specific legality check\n\tthat the designated type of an access type shall be compatible\n\twith respect to volatility with the access type.\n\t* sem_ch12.adb (Check_Shared_Variable_Control_Aspects): Add\n\tSPARK-specific legality check that an actual type parameter in\n\tan instantiation shall be compatible with respect to volatility\n\twith the corresponding formal type.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Perform checks\n\tfor aspect specs for the 4 volatility refinement aspects that\n\twere already being performed for all language-defined aspects.\n\t* sem_prag.adb (Analyze_External_Property_In_Decl_Part,\n\tAnalyze_Pragma): External properties (other than No_Caching) may\n\tbe specified for a type, including a generic formal type.\n\t* sem_util.ads: Declare new subprograms - Async_Readers_Enabled,\n\tAsync_Writers_Enabled, Effective_Reads, Effective_Writes, and\n\tCheck_Volatility_Compatibility.\n\t* sem_util.adb (Async_Readers_Enabled, Async_Writers_Enabled,\n\tEffective_Reads, Effective_Writes): Initial implementation of\n\tnew functions for querying aspect values.\n\t(Check_Volatility_Compatibility): New procedure intended for use\n\tin checking all SPARK legality rules of the form \"<> shall be\n\tcompatible with respect to volatility with <>\".\n\t(Has_Enabled_Property): Update comment because Item_Id can be a\n\ttype.  Change name of nested Variable_Has_Enabled_Property\n\tfunction to Type_Or_Variable_Has_Enabled_Property; add a\n\tparameter to that function because recursion may be needed,\n\te.g., in the case of a derived typ).  Cope with the case where\n\tthe argument to Has_Enabled_Property is a type.", "tree": {"sha": "ffd5413ee672b35ffeb55a9ca9600804ed1d3238", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffd5413ee672b35ffeb55a9ca9600804ed1d3238"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4127ebece723b172aeecacbba9b523af98cc646b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4127ebece723b172aeecacbba9b523af98cc646b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4127ebece723b172aeecacbba9b523af98cc646b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4127ebece723b172aeecacbba9b523af98cc646b/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c25b7838090b7ff130b74b22b00ab09d59a5dd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c25b7838090b7ff130b74b22b00ab09d59a5dd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c25b7838090b7ff130b74b22b00ab09d59a5dd2"}], "stats": {"total": 831, "additions": 647, "deletions": 184}, "files": [{"sha": "42f36d5909cab662af8d50048271b9eab092a956", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 290, "deletions": 101, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4127ebece723b172aeecacbba9b523af98cc646b/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4127ebece723b172aeecacbba9b523af98cc646b/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=4127ebece723b172aeecacbba9b523af98cc646b", "patch": "@@ -61,6 +61,11 @@ package body Contracts is\n    --\n    --    Part_Of\n \n+   procedure Check_Type_Or_Object_External_Properties\n+     (Type_Or_Obj_Id : Entity_Id);\n+   --  Perform checking of external properties pragmas that is common to both\n+   --  type declarations and object declarations.\n+\n    procedure Expand_Subprogram_Contract (Body_Id : Entity_Id);\n    --  Expand the contracts of a subprogram body and its correspoding spec (if\n    --  any). This routine processes all [refined] pre- and postconditions as\n@@ -244,18 +249,33 @@ package body Contracts is\n             raise Program_Error;\n          end if;\n \n-      --  Protected units, the applicable pragmas are:\n-      --    Part_Of\n-\n-      elsif Ekind (Id) = E_Protected_Type then\n-         if Prag_Nam = Name_Part_Of then\n-            Add_Classification;\n+      --  The four volatility refinement pragmas are ok for all types.\n+      --  Part_Of is ok for task types and protected types.\n+      --  Depends and Global are ok for task types.\n+\n+      elsif Is_Type (Id) then\n+         declare\n+            Is_OK : constant Boolean :=\n+              Nam_In (Prag_Nam, Name_Async_Readers,\n+                                Name_Async_Writers,\n+                                Name_Effective_Reads,\n+                                Name_Effective_Writes)\n+              or else (Ekind (Id) = E_Task_Type\n+                         and Nam_In (Prag_Nam, Name_Part_Of,\n+                                               Name_Depends,\n+                                               Name_Global))\n+              or else (Ekind (Id) = E_Protected_Type\n+                         and Prag_Nam = Name_Part_Of);\n+         begin\n+            if Is_OK then\n+               Add_Classification;\n+            else\n \n-         --  The pragma is not a proper contract item\n+               --  The pragma is not a proper contract item\n \n-         else\n-            raise Program_Error;\n-         end if;\n+               raise Program_Error;\n+            end if;\n+         end;\n \n       --  Subprogram bodies, the applicable pragmas are:\n       --    Postcondition\n@@ -299,16 +319,6 @@ package body Contracts is\n       --    Global\n       --    Part_Of\n \n-      elsif Ekind (Id) = E_Task_Type then\n-         if Nam_In (Prag_Nam, Name_Depends, Name_Global, Name_Part_Of) then\n-            Add_Classification;\n-\n-         --  The pragma is not a proper contract item\n-\n-         else\n-            raise Program_Error;\n-         end if;\n-\n       --  Variables, the applicable pragmas are:\n       --    Async_Readers\n       --    Async_Writers\n@@ -338,6 +348,9 @@ package body Contracts is\n          else\n             raise Program_Error;\n          end if;\n+\n+      else\n+         raise Program_Error;\n       end if;\n    end Add_Contract_Item;\n \n@@ -430,6 +443,15 @@ package body Contracts is\n             end;\n          end if;\n \n+         if Nkind_In (Decl, N_Full_Type_Declaration,\n+                            N_Private_Type_Declaration,\n+                            N_Task_Type_Declaration,\n+                            N_Protected_Type_Declaration,\n+                            N_Formal_Type_Declaration)\n+         then\n+            Analyze_Type_Contract (Defining_Identifier (Decl));\n+         end if;\n+\n          Next (Decl);\n       end loop;\n    end Analyze_Contracts;\n@@ -720,6 +742,233 @@ package body Contracts is\n       end if;\n    end Analyze_Entry_Or_Subprogram_Contract;\n \n+   ----------------------------------------------\n+   -- Check_Type_Or_Object_External_Properties --\n+   ----------------------------------------------\n+\n+   procedure Check_Type_Or_Object_External_Properties\n+     (Type_Or_Obj_Id : Entity_Id)\n+   is\n+      function Decl_Kind (Is_Type     : Boolean;\n+                          Object_Kind : String) return String;\n+      --  Returns \"type\" or Object_Kind, depending on Is_Type\n+\n+      ---------------\n+      -- Decl_Kind --\n+      ---------------\n+\n+      function Decl_Kind (Is_Type     : Boolean;\n+                          Object_Kind : String) return String is\n+      begin\n+         if Is_Type then\n+            return \"type\";\n+         else\n+            return Object_Kind;\n+         end if;\n+      end Decl_Kind;\n+\n+      Is_Type_Id : constant Boolean := Is_Type (Type_Or_Obj_Id);\n+\n+      --  Local variables\n+\n+      AR_Val       : Boolean := False;\n+      AW_Val       : Boolean := False;\n+      ER_Val       : Boolean := False;\n+      EW_Val       : Boolean := False;\n+      Seen         : Boolean := False;\n+      Prag         : Node_Id;\n+      Obj_Typ      : Entity_Id;\n+\n+   --  Start of processing for Check_Type_Or_Object_External_Properties\n+\n+   begin\n+      --  Analyze all external properties\n+\n+      if Is_Type_Id then\n+         Obj_Typ := Type_Or_Obj_Id;\n+\n+         --  If the parent type of a derived type is volatile\n+         --  then the derived type inherits volatility-related flags.\n+\n+         if Is_Derived_Type (Type_Or_Obj_Id) then\n+            declare\n+               Parent_Type : constant Entity_Id :=\n+                 Etype (Base_Type (Type_Or_Obj_Id));\n+            begin\n+               if Is_Effectively_Volatile (Parent_Type) then\n+                  AR_Val := Async_Readers_Enabled (Parent_Type);\n+                  AW_Val := Async_Writers_Enabled (Parent_Type);\n+                  ER_Val := Effective_Reads_Enabled (Parent_Type);\n+                  EW_Val := Effective_Writes_Enabled (Parent_Type);\n+               end if;\n+            end;\n+         end if;\n+      else\n+         Obj_Typ := Etype (Type_Or_Obj_Id);\n+      end if;\n+\n+      Prag := Get_Pragma (Type_Or_Obj_Id, Pragma_Async_Readers);\n+\n+      if Present (Prag) then\n+         declare\n+            Saved_AR_Val : constant Boolean := AR_Val;\n+         begin\n+            Analyze_External_Property_In_Decl_Part (Prag, AR_Val);\n+            Seen := True;\n+            if Saved_AR_Val and not AR_Val then\n+               Error_Msg_N\n+                 (\"illegal non-confirming Async_Readers specification\",\n+                  Prag);\n+            end if;\n+         end;\n+      end if;\n+\n+      Prag := Get_Pragma (Type_Or_Obj_Id, Pragma_Async_Writers);\n+\n+      if Present (Prag) then\n+         declare\n+            Saved_AW_Val : constant Boolean := AW_Val;\n+         begin\n+            Analyze_External_Property_In_Decl_Part (Prag, AW_Val);\n+            Seen := True;\n+            if Saved_AW_Val and not AW_Val then\n+               Error_Msg_N\n+                 (\"illegal non-confirming Async_Writers specification\",\n+                  Prag);\n+            end if;\n+         end;\n+      end if;\n+\n+      Prag := Get_Pragma (Type_Or_Obj_Id, Pragma_Effective_Reads);\n+\n+      if Present (Prag) then\n+         declare\n+            Saved_ER_Val : constant Boolean := ER_Val;\n+         begin\n+            Analyze_External_Property_In_Decl_Part (Prag, ER_Val);\n+            Seen := True;\n+            if Saved_ER_Val and not ER_Val then\n+               Error_Msg_N\n+                 (\"illegal non-confirming Effective_Reads specification\",\n+                  Prag);\n+            end if;\n+         end;\n+      end if;\n+\n+      Prag := Get_Pragma (Type_Or_Obj_Id, Pragma_Effective_Writes);\n+\n+      if Present (Prag) then\n+         declare\n+            Saved_EW_Val : constant Boolean := EW_Val;\n+         begin\n+            Analyze_External_Property_In_Decl_Part (Prag, EW_Val);\n+            Seen := True;\n+            if Saved_EW_Val and not EW_Val then\n+               Error_Msg_N\n+                 (\"illegal non-confirming Effective_Writes specification\",\n+                  Prag);\n+            end if;\n+         end;\n+      end if;\n+\n+      --  Verify the mutual interaction of the various external properties\n+\n+      if Seen then\n+         Check_External_Properties\n+           (Type_Or_Obj_Id, AR_Val, AW_Val, ER_Val, EW_Val);\n+      end if;\n+\n+      --  The following checks are relevant only when SPARK_Mode is on, as\n+      --  they are not standard Ada legality rules. Internally generated\n+      --  temporaries are ignored.\n+\n+      if SPARK_Mode = On and then Comes_From_Source (Type_Or_Obj_Id) then\n+         if Is_Effectively_Volatile (Type_Or_Obj_Id) then\n+\n+            --  The declaration of an effectively volatile object or type must\n+            --  appear at the library level (SPARK RM 7.1.3(3), C.6(6)).\n+\n+            if not Is_Library_Level_Entity (Type_Or_Obj_Id) then\n+               Error_Msg_N\n+                 (\"effectively volatile \"\n+                    & Decl_Kind (Is_Type     => Is_Type_Id,\n+                                 Object_Kind => \"variable\")\n+                    & \" & must be declared at library level \"\n+                    & \"(SPARK RM 7.1.3(3))\", Type_Or_Obj_Id);\n+\n+            --  An object of a discriminated type cannot be effectively\n+            --  volatile except for protected objects (SPARK RM 7.1.3(5)).\n+\n+            elsif Has_Discriminants (Obj_Typ)\n+              and then not Is_Protected_Type (Obj_Typ)\n+            then\n+               Error_Msg_N\n+                (\"discriminated \"\n+                   & Decl_Kind (Is_Type     => Is_Type_Id,\n+                                Object_Kind => \"object\")\n+                   & \" & cannot be volatile\",\n+                 Type_Or_Obj_Id);\n+            end if;\n+\n+            --  An object decl shall be compatible with respect to volatility\n+            --  with its type (SPARK RM 7.1.3(2)).\n+\n+            if not Is_Type_Id then\n+               if Is_Effectively_Volatile  (Obj_Typ) then\n+                  Check_Volatility_Compatibility\n+                    (Type_Or_Obj_Id, Obj_Typ,\n+                     \"volatile object\", \"its type\",\n+                     Srcpos_Bearer => Type_Or_Obj_Id);\n+               end if;\n+\n+            --  A component of a composite type (in this case, the composite\n+            --  type is an array type) shall be compatible with respect to\n+            --  volatility with the composite type (SPARK RM 7.1.3(6)).\n+\n+            elsif Is_Array_Type (Obj_Typ) then\n+               Check_Volatility_Compatibility\n+                 (Component_Type (Obj_Typ), Obj_Typ,\n+                  \"component type\", \"its enclosing array type\",\n+                  Srcpos_Bearer => Obj_Typ);\n+\n+            --  A component of a composite type (in this case, the composite\n+            --  type is a record type) shall be compatible with respect to\n+            --  volatility with the composite type (SPARK RM 7.1.3(6)).\n+\n+            elsif Is_Record_Type (Obj_Typ) then\n+               declare\n+                  Comp : Entity_Id := First_Component (Obj_Typ);\n+               begin\n+                  while Present (Comp) loop\n+                     Check_Volatility_Compatibility\n+                       (Etype (Comp), Obj_Typ,\n+                        \"record component \" & Get_Name_String (Chars (Comp)),\n+                        \"its enclosing record type\",\n+                        Srcpos_Bearer => Comp);\n+                     Next_Component (Comp);\n+                  end loop;\n+               end;\n+            end if;\n+\n+         --  The type or object is not effectively volatile\n+\n+         else\n+            --  A non-effectively volatile type cannot have effectively\n+            --  volatile components (SPARK RM 7.1.3(6)).\n+\n+            if Is_Type_Id\n+              and then not Is_Effectively_Volatile (Type_Or_Obj_Id)\n+              and then Has_Volatile_Component (Type_Or_Obj_Id)\n+            then\n+               Error_Msg_N\n+                 (\"non-volatile type & cannot have volatile\"\n+                    & \" components\",\n+                  Type_Or_Obj_Id);\n+            end if;\n+         end if;\n+      end if;\n+   end Check_Type_Or_Object_External_Properties;\n+\n    -----------------------------\n    -- Analyze_Object_Contract --\n    -----------------------------\n@@ -738,15 +987,10 @@ package body Contracts is\n       Saved_SMP : constant Node_Id         := SPARK_Mode_Pragma;\n       --  Save the SPARK_Mode-related data to restore on exit\n \n-      AR_Val   : Boolean := False;\n-      AW_Val   : Boolean := False;\n-      ER_Val   : Boolean := False;\n-      EW_Val   : Boolean := False;\n       NC_Val   : Boolean := False;\n       Items    : Node_Id;\n       Prag     : Node_Id;\n       Ref_Elmt : Elmt_Id;\n-      Seen     : Boolean := False;\n \n    begin\n       --  The loop parameter in an element iterator over a formal container\n@@ -813,41 +1057,8 @@ package body Contracts is\n \n       else pragma Assert (Ekind (Obj_Id) = E_Variable);\n \n-         --  Analyze all external properties\n-\n-         Prag := Get_Pragma (Obj_Id, Pragma_Async_Readers);\n-\n-         if Present (Prag) then\n-            Analyze_External_Property_In_Decl_Part (Prag, AR_Val);\n-            Seen := True;\n-         end if;\n-\n-         Prag := Get_Pragma (Obj_Id, Pragma_Async_Writers);\n-\n-         if Present (Prag) then\n-            Analyze_External_Property_In_Decl_Part (Prag, AW_Val);\n-            Seen := True;\n-         end if;\n-\n-         Prag := Get_Pragma (Obj_Id, Pragma_Effective_Reads);\n-\n-         if Present (Prag) then\n-            Analyze_External_Property_In_Decl_Part (Prag, ER_Val);\n-            Seen := True;\n-         end if;\n-\n-         Prag := Get_Pragma (Obj_Id, Pragma_Effective_Writes);\n-\n-         if Present (Prag) then\n-            Analyze_External_Property_In_Decl_Part (Prag, EW_Val);\n-            Seen := True;\n-         end if;\n-\n-         --  Verify the mutual interaction of the various external properties\n-\n-         if Seen then\n-            Check_External_Properties (Obj_Id, AR_Val, AW_Val, ER_Val, EW_Val);\n-         end if;\n+         Check_Type_Or_Object_External_Properties\n+           (Type_Or_Obj_Id => Obj_Id);\n \n          --  Analyze the non-external volatility property No_Caching\n \n@@ -911,47 +1122,6 @@ package body Contracts is\n          else\n             Check_Missing_Part_Of (Obj_Id);\n          end if;\n-\n-         --  The following checks are relevant only when SPARK_Mode is on, as\n-         --  they are not standard Ada legality rules. Internally generated\n-         --  temporaries are ignored.\n-\n-         if SPARK_Mode = On and then Comes_From_Source (Obj_Id) then\n-            if Is_Effectively_Volatile (Obj_Id) then\n-\n-               --  The declaration of an effectively volatile object must\n-               --  appear at the library level (SPARK RM 7.1.3(3), C.6(6)).\n-\n-               if not Is_Library_Level_Entity (Obj_Id) then\n-                  Error_Msg_N\n-                    (\"volatile variable & must be declared at library level \"\n-                     & \"(SPARK RM 7.1.3(3))\", Obj_Id);\n-\n-               --  An object of a discriminated type cannot be effectively\n-               --  volatile except for protected objects (SPARK RM 7.1.3(5)).\n-\n-               elsif Has_Discriminants (Obj_Typ)\n-                 and then not Is_Protected_Type (Obj_Typ)\n-               then\n-                  Error_Msg_N\n-                    (\"discriminated object & cannot be volatile\", Obj_Id);\n-               end if;\n-\n-            --  The object is not effectively volatile\n-\n-            else\n-               --  A non-effectively volatile object cannot have effectively\n-               --  volatile components (SPARK RM 7.1.3(6)).\n-\n-               if not Is_Effectively_Volatile (Obj_Id)\n-                 and then Has_Volatile_Component (Obj_Typ)\n-               then\n-                  Error_Msg_N\n-                    (\"non-volatile object & cannot have volatile components\",\n-                     Obj_Id);\n-               end if;\n-            end if;\n-         end if;\n       end if;\n \n       --  Common checks\n@@ -1304,6 +1474,16 @@ package body Contracts is\n       Restore_SPARK_Mode (Saved_SM, Saved_SMP);\n    end Analyze_Task_Contract;\n \n+   ---------------------------\n+   -- Analyze_Type_Contract --\n+   ---------------------------\n+\n+   procedure Analyze_Type_Contract (Type_Id : Entity_Id) is\n+   begin\n+      Check_Type_Or_Object_External_Properties\n+        (Type_Or_Obj_Id => Type_Id);\n+   end Analyze_Type_Contract;\n+\n    -----------------------------\n    -- Create_Generic_Contract --\n    -----------------------------\n@@ -2757,6 +2937,15 @@ package body Contracts is\n                Analyze_Task_Contract (Defining_Entity (Decl));\n             end if;\n \n+            if Nkind_In (Decl, N_Full_Type_Declaration,\n+                               N_Private_Type_Declaration,\n+                               N_Task_Type_Declaration,\n+                               N_Protected_Type_Declaration,\n+                               N_Formal_Type_Declaration)\n+            then\n+               Analyze_Type_Contract (Defining_Identifier (Decl));\n+            end if;\n+\n             Prev (Decl);\n          end loop;\n       end Freeze_Contracts;"}, {"sha": "9e7b95569fc28ee6f9123f0ac372f6a228e94e1f", "filename": "gcc/ada/contracts.ads", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4127ebece723b172aeecacbba9b523af98cc646b/gcc%2Fada%2Fcontracts.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4127ebece723b172aeecacbba9b523af98cc646b/gcc%2Fada%2Fcontracts.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.ads?ref=4127ebece723b172aeecacbba9b523af98cc646b", "patch": "@@ -33,8 +33,8 @@ package Contracts is\n    procedure Add_Contract_Item (Prag : Node_Id; Id : Entity_Id);\n    --  Add pragma Prag to the contract of a constant, entry, entry family,\n    --  [generic] package, package body, protected unit, [generic] subprogram,\n-   --  subprogram body, variable or task unit denoted by Id. The following are\n-   --  valid pragmas:\n+   --  subprogram body, variable, task unit, or type denoted by Id.\n+   --  The following are valid pragmas:\n    --\n    --    Abstract_State\n    --    Async_Readers\n@@ -114,6 +114,19 @@ package Contracts is\n    --  Freeze_Id is the entity of a [generic] package body or a [generic]\n    --  subprogram body which \"freezes\" the contract of Obj_Id.\n \n+   procedure Analyze_Type_Contract (Type_Id : Entity_Id);\n+   --  Analyze all delayed pragmas chained on the contract of object Obj_Id as\n+   --  if they appeared at the end of the declarative region. The pragmas to be\n+   --  considered are:\n+   --\n+   --    Async_Readers\n+   --    Async_Writers\n+   --    Effective_Reads\n+   --    Effective_Writes\n+   --\n+   --  In the case of a protected or task type, there will also be\n+   --  a call to Analyze_Protected_Contract or Analyze_Task_Contract.\n+\n    procedure Analyze_Package_Body_Contract\n      (Body_Id   : Entity_Id;\n       Freeze_Id : Entity_Id := Empty);"}, {"sha": "83beff6f0f14e0ffd7c04cba420388a9764b92d7", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4127ebece723b172aeecacbba9b523af98cc646b/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4127ebece723b172aeecacbba9b523af98cc646b/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=4127ebece723b172aeecacbba9b523af98cc646b", "patch": "@@ -1291,6 +1291,8 @@ package body Einfo is\n                        E_Package,\n                        E_Package_Body)\n            or else\n+         Is_Type (Id)                         --  types\n+           or else\n          Ekind (Id) = E_Void);                --  special purpose\n       return Node34 (Id);\n    end Contract;\n@@ -4146,6 +4148,10 @@ package body Einfo is\n          Ekind_In (Id, E_Generic_Package,     --  packages\n                        E_Package,\n                        E_Package_Body)\n+\n+           or else\n+         Is_Type (Id)                         -- types\n+\n            or else\n          Ekind (Id) = E_Void);                --  special purpose\n       Set_Node34 (Id, V);\n@@ -11271,11 +11277,10 @@ package body Einfo is\n             | E_Package\n             | E_Package_Body\n             | E_Procedure\n-            | E_Protected_Type\n             | E_Subprogram_Body\n             | E_Task_Body\n-            | E_Task_Type\n             | E_Variable\n+            | Type_Kind\n             | E_Void\n          =>\n             Write_Str (\"Contract\");"}, {"sha": "75474cd232dca84fcefc57bca4004440b0c4ab58", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4127ebece723b172aeecacbba9b523af98cc646b/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4127ebece723b172aeecacbba9b523af98cc646b/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=4127ebece723b172aeecacbba9b523af98cc646b", "patch": "@@ -744,9 +744,9 @@ package Einfo is\n \n --    Contract (Node34)\n --       Defined in constant, entry, entry family, operator, [generic] package,\n---       package body, protected type, [generic] subprogram, subprogram body,\n---       variable and task type entities. Points to the contract of the entity,\n---       holding various assertion items and data classifiers.\n+--       package body, protected unit, [generic] subprogram, subprogram body,\n+--       variable, task unit, and type entities. Points to the contract of the\n+--       entity, holding various assertion items and data classifiers.\n \n --    Contract_Wrapper (Node25)\n --       Defined in entry and entry family entities. Set only when the entry"}, {"sha": "e366531d9bcc1876f560801a94ab1052c687f847", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4127ebece723b172aeecacbba9b523af98cc646b/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4127ebece723b172aeecacbba9b523af98cc646b/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=4127ebece723b172aeecacbba9b523af98cc646b", "patch": "@@ -11315,6 +11315,44 @@ package body Sem_Ch12 is\n                Actual);\n          end if;\n \n+         --  Check actual/formal compatibility with respect to the four\n+         --  volatility refinement aspects.\n+\n+         declare\n+            Actual_Obj : Entity_Id;\n+            N          : Node_Id := Actual;\n+         begin\n+            --  Similar to Sem_Util.Get_Enclosing_Object, but treat\n+            --  pointer dereference like component selection.\n+            loop\n+               if Is_Entity_Name (N) then\n+                  Actual_Obj := Entity (N);\n+                  exit;\n+               end if;\n+\n+               case Nkind (N) is\n+                  when N_Indexed_Component\n+                     | N_Selected_Component\n+                     | N_Slice\n+                     | N_Explicit_Dereference\n+                  =>\n+                     N := Prefix (N);\n+\n+                  when N_Type_Conversion =>\n+                     N := Expression (N);\n+\n+                  when others =>\n+                     Actual_Obj := Etype (N);\n+                     exit;\n+               end case;\n+            end loop;\n+\n+            Check_Volatility_Compatibility\n+              (Actual_Obj, A_Gen_Obj, \"actual object\",\n+               \"its corresponding formal object of mode in out\",\n+               Srcpos_Bearer => Actual);\n+         end;\n+\n       --  Formal in-parameter\n \n       else\n@@ -11510,6 +11548,7 @@ package body Sem_Ch12 is\n         and then Present (Actual)\n         and then Is_Object_Reference (Actual)\n         and then Is_Effectively_Volatile_Object (Actual)\n+        and then not Is_Effectively_Volatile (A_Gen_Obj)\n       then\n          Error_Msg_N\n            (\"volatile object cannot act as actual in generic instantiation\",\n@@ -12480,6 +12519,14 @@ package body Sem_Ch12 is\n                  (\"actual for& must have Independent_Components specified\",\n                      Actual, A_Gen_T);\n             end if;\n+\n+            --  Check actual/formal compatibility with respect to the four\n+            --  volatility refinement aspects.\n+\n+            Check_Volatility_Compatibility\n+              (Act_T, A_Gen_T,\n+               \"actual type\", \"its corresponding formal type\",\n+               Srcpos_Bearer => Act_T);\n          end if;\n       end Check_Shared_Variable_Control_Aspects;\n "}, {"sha": "4b042d8b678c695dbaea6f1b1dd8931c30f85c84", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4127ebece723b172aeecacbba9b523af98cc646b/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4127ebece723b172aeecacbba9b523af98cc646b/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=4127ebece723b172aeecacbba9b523af98cc646b", "patch": "@@ -2180,7 +2180,12 @@ package body Sem_Ch13 is\n \n             --  Check some general restrictions on language defined aspects\n \n-            if not Implementation_Defined_Aspect (A_Id) then\n+            if not Implementation_Defined_Aspect (A_Id)\n+              or else A_Id = Aspect_Async_Readers\n+              or else A_Id = Aspect_Async_Writers\n+              or else A_Id = Aspect_Effective_Reads\n+              or else A_Id = Aspect_Effective_Reads\n+            then\n                Error_Msg_Name_1 := Nam;\n \n                --  Not allowed for renaming declarations. Examine the original\n@@ -2209,6 +2214,10 @@ package body Sem_Ch13 is\n                      and then A_Id /= Aspect_Atomic_Components\n                      and then A_Id /= Aspect_Independent_Components\n                      and then A_Id /= Aspect_Volatile_Components\n+                     and then A_Id /= Aspect_Async_Readers\n+                     and then A_Id /= Aspect_Async_Writers\n+                     and then A_Id /= Aspect_Effective_Reads\n+                     and then A_Id /= Aspect_Effective_Reads\n                   then\n                      Error_Msg_N\n                        (\"aspect % not allowed for formal type declaration\","}, {"sha": "f38d6e798bab3194d7405c859699e35e27ebb08b", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4127ebece723b172aeecacbba9b523af98cc646b/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4127ebece723b172aeecacbba9b523af98cc646b/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=4127ebece723b172aeecacbba9b523af98cc646b", "patch": "@@ -1398,6 +1398,26 @@ package body Sem_Ch3 is\n          Set_Is_Tagged_Type (T, False);\n       end if;\n \n+      --  For SPARK, check that the designated type is compatible with\n+      --  respect to volatility with the access type.\n+\n+      if SPARK_Mode /= Off\n+         and then Comes_From_Source (T)\n+      then\n+         --  ??? UNIMPLEMENTED\n+         --  In the case where the designated type is incomplete at this point,\n+         --  performing this check here is harmless but the check will need to\n+         --  be repeated when the designated type is complete.\n+\n+         --  The preceding call to Comes_From_Source is needed because the\n+         --  FE sometimes introduces implicitly declared access types. See,\n+         --  for example, the expansion of nested_po.ads in OA28-015.\n+\n+         Check_Volatility_Compatibility\n+           (Full_Desig, T, \"designated type\", \"access type\",\n+            Srcpos_Bearer => T);\n+      end if;\n+\n       Set_Etype (T, T);\n \n       --  If the type has appeared already in a with_type clause, it is frozen\n@@ -7265,6 +7285,7 @@ package body Sem_Ch3 is\n       Set_First_Rep_Item (Implicit_Base, First_Rep_Item (Parent_Base));\n       Set_Parent         (Implicit_Base, Parent (Derived_Type));\n       Set_Is_Known_Valid (Implicit_Base, Is_Known_Valid (Parent_Base));\n+      Set_Is_Volatile    (Implicit_Base, Is_Volatile    (Parent_Base));\n \n       --  Set RM Size for discrete type or decimal fixed-point type\n       --  Ordinary fixed-point is excluded, why???"}, {"sha": "05171d45208e7f8ced2c9fadd3149b1a32c89753", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 48, "deletions": 19, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4127ebece723b172aeecacbba9b523af98cc646b/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4127ebece723b172aeecacbba9b523af98cc646b/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=4127ebece723b172aeecacbba9b523af98cc646b", "patch": "@@ -2123,7 +2123,8 @@ package body Sem_Prag is\n                & \"\"\"No_Caching\"\" (SPARK RM 7.1.2(6))\", N);\n          else\n             SPARK_Msg_N\n-              (\"external property % must apply to a volatile object\", N);\n+              (\"external property % must apply to a volatile type or object\",\n+               N);\n          end if;\n \n       --  Pragma No_Caching should only apply to volatile variables of\n@@ -7847,6 +7848,7 @@ package body Sem_Prag is\n            and then Prag_Id = Pragma_Volatile\n            and then not Nkind_In (Original_Node (Decl),\n                                   N_Full_Type_Declaration,\n+                                  N_Formal_Type_Declaration,\n                                   N_Object_Declaration,\n                                   N_Single_Protected_Declaration,\n                                   N_Single_Task_Declaration)\n@@ -13476,41 +13478,65 @@ package body Sem_Prag is\n             | Pragma_No_Caching\n          =>\n          Async_Effective : declare\n-            Obj_Decl : Node_Id;\n-            Obj_Id   : Entity_Id;\n-\n+            Obj_Or_Type_Decl : Node_Id;\n+            Obj_Or_Type_Id   : Entity_Id;\n          begin\n             GNAT_Pragma;\n             Check_No_Identifiers;\n             Check_At_Most_N_Arguments  (1);\n \n-            Obj_Decl := Find_Related_Context (N, Do_Checks => True);\n-\n-            --  Object declaration\n-\n-            if Nkind (Obj_Decl) /= N_Object_Declaration then\n-               Pragma_Misplaced;\n-               return;\n+            Obj_Or_Type_Decl := Find_Related_Context (N, Do_Checks => True);\n+\n+            --  Pragma must apply to a object declaration or to a type\n+            --  declaration (only the former in the No_Caching case).\n+            --  Original_Node is necessary to account for untagged derived\n+            --  types that are rewritten as subtypes of their\n+            --  respective root types.\n+\n+            if Nkind (Obj_Or_Type_Decl) /= N_Object_Declaration then\n+               if (Prag_Id = Pragma_No_Caching)\n+                  or not Nkind_In (Original_Node (Obj_Or_Type_Decl),\n+                                   N_Full_Type_Declaration,\n+                                   N_Private_Type_Declaration,\n+                                   N_Formal_Type_Declaration,\n+                                   N_Task_Type_Declaration,\n+                                   N_Protected_Type_Declaration)\n+               then\n+                  Pragma_Misplaced;\n+                  return;\n+               end if;\n             end if;\n \n-            Obj_Id := Defining_Entity (Obj_Decl);\n+            Obj_Or_Type_Id := Defining_Entity (Obj_Or_Type_Decl);\n \n             --  Perform minimal verification to ensure that the argument is at\n-            --  least a variable. Subsequent finer grained checks will be done\n-            --  at the end of the declarative region the contains the pragma.\n+            --  least a variable or a type. Subsequent finer grained checks\n+            --  will be done at the end of the declarative region that\n+            --  contains the pragma.\n \n-            if Ekind (Obj_Id) = E_Variable then\n+            if Ekind (Obj_Or_Type_Id) = E_Variable or Is_Type (Obj_Or_Type_Id)\n+            then\n+\n+               --  In the case of a type, pragma is a type-related\n+               --  representation item and so requires checks common to\n+               --  all type-related representation items.\n+\n+               if Is_Type (Obj_Or_Type_Id)\n+                 and then Rep_Item_Too_Late (Obj_Or_Type_Id, N)\n+               then\n+                  return;\n+               end if;\n \n                --  A pragma that applies to a Ghost entity becomes Ghost for\n                --  the purposes of legality checks and removal of ignored Ghost\n                --  code.\n \n-               Mark_Ghost_Pragma (N, Obj_Id);\n+               Mark_Ghost_Pragma (N, Obj_Or_Type_Id);\n \n                --  Chain the pragma on the contract for further processing by\n                --  Analyze_External_Property_In_Decl_Part.\n \n-               Add_Contract_Item (N, Obj_Id);\n+               Add_Contract_Item (N, Obj_Or_Type_Id);\n \n                --  Analyze the Boolean expression (if any)\n \n@@ -13521,7 +13547,8 @@ package body Sem_Prag is\n             --  Otherwise the external property applies to a constant\n \n             else\n-               Error_Pragma (\"pragma % must apply to a volatile object\");\n+               Error_Pragma\n+                 (\"pragma % must apply to a volatile type or object\");\n             end if;\n          end Async_Effective;\n \n@@ -30170,7 +30197,9 @@ package body Sem_Prag is\n \n          --  Skip internally generated code\n \n-         elsif not Comes_From_Source (Stmt) then\n+         elsif not Comes_From_Source (Stmt)\n+           and then not Comes_From_Source (Original_Node (Stmt))\n+         then\n \n             --  The anonymous object created for a single concurrent type is a\n             --  suitable context."}, {"sha": "76eb6653fb10349390a103549d4127ee6095f82f", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 185, "deletions": 44, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4127ebece723b172aeecacbba9b523af98cc646b/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4127ebece723b172aeecacbba9b523af98cc646b/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=4127ebece723b172aeecacbba9b523af98cc646b", "patch": "@@ -116,8 +116,8 @@ package body Sem_Util is\n      (Item_Id  : Entity_Id;\n       Property : Name_Id) return Boolean;\n    --  Subsidiary to routines Async_xxx_Enabled and Effective_xxx_Enabled.\n-   --  Determine whether an abstract state or a variable denoted by entity\n-   --  Item_Id has enabled property Property.\n+   --  Determine whether the state abstraction, variable, or type denoted by\n+   --  entity Item_Id has enabled property Property.\n \n    function Has_Null_Extension (T : Entity_Id) return Boolean;\n    --  T is a derived tagged type. Check whether the type extension is null.\n@@ -4911,6 +4911,96 @@ package body Sem_Util is\n       end if;\n    end Check_Unused_Body_States;\n \n+   ------------------------------------\n+   -- Check_Volatility_Compatibility --\n+   ------------------------------------\n+\n+   procedure Check_Volatility_Compatibility\n+     (Id1, Id2                     : Entity_Id;\n+      Description_1, Description_2 : String;\n+      Srcpos_Bearer                : Node_Id) is\n+\n+   begin\n+      if SPARK_Mode /= On then\n+         return;\n+      end if;\n+\n+      declare\n+         AR1 : constant Boolean := Async_Readers_Enabled (Id1);\n+         AW1 : constant Boolean := Async_Writers_Enabled (Id1);\n+         ER1 : constant Boolean := Effective_Reads_Enabled (Id1);\n+         EW1 : constant Boolean := Effective_Writes_Enabled (Id1);\n+         AR2 : constant Boolean := Async_Readers_Enabled (Id2);\n+         AW2 : constant Boolean := Async_Writers_Enabled (Id2);\n+         ER2 : constant Boolean := Effective_Reads_Enabled (Id2);\n+         EW2 : constant Boolean := Effective_Writes_Enabled (Id2);\n+\n+         AR_Check_Failed : constant Boolean := AR1 and not AR2;\n+         AW_Check_Failed : constant Boolean := AW1 and not AW2;\n+         ER_Check_Failed : constant Boolean := ER1 and not ER2;\n+         EW_Check_Failed : constant Boolean := EW1 and not EW2;\n+\n+         package Failure_Description is\n+            procedure Note_If_Failure\n+              (Failed : Boolean; Aspect_Name : String);\n+            --  If Failed is False, do nothing.\n+            --  If Failed is True, add Aspect_Name to the failure description.\n+\n+            function Failure_Text return String;\n+            --  returns accumulated list of failing aspects\n+         end Failure_Description;\n+\n+         package body Failure_Description is\n+            Description_Buffer : Bounded_String;\n+\n+            ---------------------\n+            -- Note_If_Failure --\n+            ---------------------\n+\n+            procedure Note_If_Failure\n+              (Failed : Boolean; Aspect_Name : String) is\n+            begin\n+               if Failed then\n+                  if Description_Buffer.Length /= 0 then\n+                     Append (Description_Buffer, \", \");\n+                  end if;\n+                  Append (Description_Buffer, Aspect_Name);\n+               end if;\n+            end Note_If_Failure;\n+\n+            ------------------\n+            -- Failure_Text --\n+            ------------------\n+\n+            function Failure_Text return String is\n+            begin\n+               return +Description_Buffer;\n+            end Failure_Text;\n+         end Failure_Description;\n+\n+         use Failure_Description;\n+      begin\n+         if AR_Check_Failed\n+           or AW_Check_Failed\n+           or ER_Check_Failed\n+           or EW_Check_Failed\n+         then\n+            Note_If_Failure (AR_Check_Failed, \"Async_Readers\");\n+            Note_If_Failure (AW_Check_Failed, \"Async_Writers\");\n+            Note_If_Failure (ER_Check_Failed, \"Effective_Reads\");\n+            Note_If_Failure (EW_Check_Failed, \"Effective_Writes\");\n+\n+            Error_Msg_N\n+              (Description_1\n+                 & \" and \"\n+                 & Description_2\n+                 & \" are not compatible with respect to volatility due to \"\n+                 & Failure_Text,\n+               Srcpos_Bearer);\n+         end if;\n+      end;\n+   end Check_Volatility_Compatibility;\n+\n    -----------------\n    -- Choice_List --\n    -----------------\n@@ -11036,28 +11126,26 @@ package body Sem_Util is\n      (Item_Id  : Entity_Id;\n       Property : Name_Id) return Boolean\n    is\n-      function Protected_Object_Has_Enabled_Property return Boolean;\n-      --  Determine whether a protected object denoted by Item_Id has the\n-      --  property enabled.\n+      function Protected_Type_Or_Variable_Has_Enabled_Property return Boolean;\n+      --  Determine whether a protected type or variable denoted by Item_Id\n+      --  has the property enabled.\n \n       function State_Has_Enabled_Property return Boolean;\n       --  Determine whether a state denoted by Item_Id has the property enabled\n \n-      function Variable_Has_Enabled_Property return Boolean;\n-      --  Determine whether a variable denoted by Item_Id has the property\n-      --  enabled.\n-\n-      -------------------------------------------\n-      -- Protected_Object_Has_Enabled_Property --\n-      -------------------------------------------\n+      function Type_Or_Variable_Has_Enabled_Property\n+        (Item_Id : Entity_Id) return Boolean;\n+      --  Determine whether type or variable denoted by Item_Id has the\n+      --  property enabled.\n \n-      function Protected_Object_Has_Enabled_Property return Boolean is\n-         Constits     : constant Elist_Id := Part_Of_Constituents (Item_Id);\n-         Constit_Elmt : Elmt_Id;\n-         Constit_Id   : Entity_Id;\n+      -----------------------------------------------------\n+      -- Protected_Type_Or_Variable_Has_Enabled_Property --\n+      -----------------------------------------------------\n \n+      function Protected_Type_Or_Variable_Has_Enabled_Property return Boolean\n+      is\n       begin\n-         --  Protected objects always have the properties Async_Readers and\n+         --  Protected entities always have the properties Async_Readers and\n          --  Async_Writers (SPARK RM 7.1.2(16)).\n \n          if Property = Name_Async_Readers\n@@ -11069,21 +11157,30 @@ package body Sem_Util is\n          --  properties Effective_Reads and Effective_Writes\n          --  (SPARK RM 7.1.2(16)).\n \n-         elsif Present (Constits) then\n-            Constit_Elmt := First_Elmt (Constits);\n-            while Present (Constit_Elmt) loop\n-               Constit_Id := Node (Constit_Elmt);\n+         elsif Is_Single_Protected_Object (Item_Id) then\n+            declare\n+               Constit_Elmt : Elmt_Id;\n+               Constit_Id   : Entity_Id;\n+               Constits     : constant Elist_Id\n+                 := Part_Of_Constituents (Item_Id);\n+            begin\n+               if Present (Constits) then\n+                  Constit_Elmt := First_Elmt (Constits);\n+                  while Present (Constit_Elmt) loop\n+                     Constit_Id := Node (Constit_Elmt);\n+\n+                     if Has_Enabled_Property (Constit_Id, Property) then\n+                        return True;\n+                     end if;\n \n-               if Has_Enabled_Property (Constit_Id, Property) then\n-                  return True;\n+                     Next_Elmt (Constit_Elmt);\n+                  end loop;\n                end if;\n-\n-               Next_Elmt (Constit_Elmt);\n-            end loop;\n+            end;\n          end if;\n \n          return False;\n-      end Protected_Object_Has_Enabled_Property;\n+      end Protected_Type_Or_Variable_Has_Enabled_Property;\n \n       --------------------------------\n       -- State_Has_Enabled_Property --\n@@ -11245,11 +11342,13 @@ package body Sem_Util is\n          return False;\n       end State_Has_Enabled_Property;\n \n-      -----------------------------------\n-      -- Variable_Has_Enabled_Property --\n-      -----------------------------------\n+      -------------------------------------------\n+      -- Type_Or_Variable_Has_Enabled_Property --\n+      -------------------------------------------\n \n-      function Variable_Has_Enabled_Property return Boolean is\n+      function Type_Or_Variable_Has_Enabled_Property\n+        (Item_Id : Entity_Id) return Boolean\n+      is\n          function Is_Enabled (Prag : Node_Id) return Boolean;\n          --  Determine whether property pragma Prag (if present) denotes an\n          --  enabled property.\n@@ -11297,7 +11396,11 @@ package body Sem_Util is\n          EW : constant Node_Id :=\n                 Get_Pragma (Item_Id, Pragma_Effective_Writes);\n \n-      --  Start of processing for Variable_Has_Enabled_Property\n+         Is_Derived_Type_With_Volatile_Parent_Type : constant Boolean :=\n+           Is_Derived_Type (Item_Id)\n+           and then Is_Effectively_Volatile (Etype (Base_Type (Item_Id)));\n+\n+      --  Start of processing for Type_Or_Variable_Has_Enabled_Property\n \n       begin\n          --  A non-effectively volatile object can never possess external\n@@ -11312,31 +11415,65 @@ package body Sem_Util is\n          --  property is enabled when the flag evaluates to True or the flag is\n          --  missing altogether.\n \n-         elsif Property = Name_Async_Readers    and then Is_Enabled (AR) then\n-            return True;\n+         elsif Property = Name_Async_Readers    and then Present (AR) then\n+            return Is_Enabled (AR);\n \n-         elsif Property = Name_Async_Writers    and then Is_Enabled (AW) then\n-            return True;\n+         elsif Property = Name_Async_Writers    and then Present (AW) then\n+            return Is_Enabled (AW);\n \n-         elsif Property = Name_Effective_Reads  and then Is_Enabled (ER) then\n-            return True;\n+         elsif Property = Name_Effective_Reads  and then Present (ER) then\n+            return Is_Enabled (ER);\n \n-         elsif Property = Name_Effective_Writes and then Is_Enabled (EW) then\n-            return True;\n+         elsif Property = Name_Effective_Writes and then Present (EW) then\n+            return Is_Enabled (EW);\n+\n+         --  If other properties are set explicitly, then this one is set\n+         --  implicitly to False, except in the case of a derived type\n+         --  whose parent type is volatile (in that case, we will inherit\n+         --  from the parent type, below).\n+\n+         elsif (Present (AR)\n+           or else Present (AW)\n+           or else Present (ER)\n+           or else Present (EW))\n+           and then not Is_Derived_Type_With_Volatile_Parent_Type\n+         then\n+            return False;\n+\n+         --  For a private type, may need to look at the full view\n+\n+         elsif Is_Private_Type (Item_Id) and then Present (Full_View (Item_Id))\n+         then\n+            return Type_Or_Variable_Has_Enabled_Property (Full_View (Item_Id));\n+\n+         --  For a derived type whose parent type is volatile, the\n+         --  property may be inherited (but ignore a non-volatile parent).\n+\n+         elsif Is_Derived_Type_With_Volatile_Parent_Type then\n+            return Type_Or_Variable_Has_Enabled_Property\n+              (First_Subtype (Etype (Base_Type (Item_Id))));\n+\n+         --  If not specified explicitly for an object and the type\n+         --  is effectively volatile, then take result from the type.\n+\n+         elsif not Is_Type (Item_Id)\n+           and then Is_Effectively_Volatile (Etype (Item_Id))\n+         then\n+            return Has_Enabled_Property (Etype (Item_Id), Property);\n \n          --  The implicit case lacks all property pragmas\n \n          elsif No (AR) and then No (AW) and then No (ER) and then No (EW) then\n             if Is_Protected_Type (Etype (Item_Id)) then\n-               return Protected_Object_Has_Enabled_Property;\n+               return Protected_Type_Or_Variable_Has_Enabled_Property;\n             else\n                return True;\n             end if;\n \n          else\n             return False;\n          end if;\n-      end Variable_Has_Enabled_Property;\n+      end Type_Or_Variable_Has_Enabled_Property;\n \n    --  Start of processing for Has_Enabled_Property\n \n@@ -11348,15 +11485,19 @@ package body Sem_Util is\n          return State_Has_Enabled_Property;\n \n       elsif Ekind (Item_Id) = E_Variable then\n-         return Variable_Has_Enabled_Property;\n+         return Type_Or_Variable_Has_Enabled_Property (Item_Id);\n+\n+      elsif Is_Type (Item_Id) then\n+         return Type_Or_Variable_Has_Enabled_Property\n+           (Item_Id => First_Subtype (Item_Id));\n \n       --  By default, protected objects only have the properties Async_Readers\n       --  and Async_Writers. If they have Part_Of components, they also inherit\n       --  their properties Effective_Reads and Effective_Writes\n       --  (SPARK RM 7.1.2(16)).\n \n       elsif Ekind (Item_Id) = E_Protected_Object then\n-         return Protected_Object_Has_Enabled_Property;\n+         return Protected_Type_Or_Variable_Has_Enabled_Property;\n \n       --  Otherwise a property is enabled when the related item is effectively\n       --  volatile."}, {"sha": "74fa2a63dbe9adfaa5d2592fac0a1831501ff5b5", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4127ebece723b172aeecacbba9b523af98cc646b/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4127ebece723b172aeecacbba9b523af98cc646b/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=4127ebece723b172aeecacbba9b523af98cc646b", "patch": "@@ -157,14 +157,12 @@ package Sem_Util is\n    --  force an error).\n \n    function Async_Readers_Enabled (Id : Entity_Id) return Boolean;\n-   --  Given the entity of an abstract state or a variable, determine whether\n-   --  Id is subject to external property Async_Readers and if it is, the\n-   --  related expression evaluates to True.\n+   --  Id should be the entity of a state abstraction, a variable, or a type.\n+   --  Returns True iff Id is subject to external property Async_Readers.\n \n    function Async_Writers_Enabled (Id : Entity_Id) return Boolean;\n-   --  Given the entity of an abstract state or a variable, determine whether\n-   --  Id is subject to external property Async_Writers and if it is, the\n-   --  related expression evaluates to True.\n+   --  Id should be the entity of a state abstraction, a variable, or a type.\n+   --  Returns True iff Id is subject to external property Async_Writers.\n \n    function Available_Full_View_Of_Component (T : Entity_Id) return Boolean;\n    --  If at the point of declaration an array type has a private or limited\n@@ -456,6 +454,19 @@ package Sem_Util is\n    --  and the context is external to the protected operation, to warn against\n    --  a possible unlocked access to data.\n \n+   procedure Check_Volatility_Compatibility\n+     (Id1, Id2                     : Entity_Id;\n+      Description_1, Description_2 : String;\n+      Srcpos_Bearer                : Node_Id);\n+   --  Id1 and Id2 should each be the entity of a state abstraction, a\n+   --  variable, or a type (i.e., something suitable for passing to\n+   --  Async_Readers_Enabled and similar functions).\n+   --  Does nothing if SPARK_Mode /= On. Otherwise, flags a legality violation\n+   --  if one or more of the four volatility-related aspects is False for Id1\n+   --  and True for Id2. The two descriptions are included in the error message\n+   --  text; the source position for the generated message is determined by\n+   --  Srcpos_Bearer.\n+\n    function Choice_List (N : Node_Id) return List_Id;\n    --  Utility to retrieve the choices of a Component_Association or the\n    --  Discrete_Choices of an Iterated_Component_Association. For various\n@@ -664,14 +675,12 @@ package Sem_Util is\n    --  are looked through.\n \n    function Effective_Reads_Enabled (Id : Entity_Id) return Boolean;\n-   --  Given the entity of an abstract state or a variable, determine whether\n-   --  Id is subject to external property Effective_Reads and if it is, the\n-   --  related expression evaluates to True.\n+   --  Id should be the entity of a state abstraction, a variable, or a type.\n+   --  Returns True iff Id is subject to external property Effective_Reads.\n \n    function Effective_Writes_Enabled (Id : Entity_Id) return Boolean;\n-   --  Given the entity of an abstract state or a variable, determine whether\n-   --  Id is subject to external property Effective_Writes and if it is, the\n-   --  related expression evaluates to True.\n+   --  Id should be the entity of a state abstraction, a variable, or a type.\n+   --  Returns True iff Id is subject to external property Effective_Writes.\n \n    function Enclosing_Comp_Unit_Node (N : Node_Id) return Node_Id;\n    --  Returns the enclosing N_Compilation_Unit node that is the root of a"}]}