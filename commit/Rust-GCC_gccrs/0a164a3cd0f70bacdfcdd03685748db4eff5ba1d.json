{"sha": "0a164a3cd0f70bacdfcdd03685748db4eff5ba1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGExNjRhM2NkMGY3MGJhY2RmY2RkMDM2ODU3NDhkYjRlZmY1YmExZA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-12-16T11:34:08Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-12-16T11:34:08Z"}, "message": "re PR fortran/31213 (ICE on valid code with gfortran)\n\n2007-12-16  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/31213\n\tPR fortran/33888\n\tPR fortran/33998\n\t* trans-array.c (gfc_trans_array_constructor_value): If the\n\titerator variable does not have a backend_decl, use a local\n\ttemporary.\n\t(get_elemental_fcn_charlen): New function to map the character\n\tlength of an elemental function onto its actual arglist.\n\t(gfc_conv_expr_descriptor): Call the above so that the size of\n\tthe temporary can be evaluated.\n\t* trans-expr.c : Include arith.h and change prototype of\n\tgfc_apply_interface_mapping_to_expr to return void.  Change all\n\treferences to gfc_apply_interface_mapping_to_expr accordingly.\n\t(gfc_free_interface_mapping): Free the 'expr' field.\n\t(gfc_add_interface_mapping): Add an argument for the actual\n\targument expression. This is copied to the 'expr' field of the\n\tmapping.  Only stabilize the backend_decl if the se is present.\n\tCopy the character length expression and only add it's backend\n\tdeclaration if se is present.  Return without working on the\n\tbackend declaration for the new symbol if se is not present.\n\t(gfc_map_intrinsic_function) : To simplify intrinsics 'len',\n\t'size', 'ubound' and 'lbound' and then to map the result.\n\t(gfc_map_fcn_formal_to_actual): Performs the formal to actual\n\tmapping for the case of a function found in a specification\n\texpression in the interface being mapped.\n\t(gfc_apply_interface_mapping_to_ref): Remove seen_result and\n\tall its references. Remove the inline simplification of LEN\n\tand call gfc_map_intrinsic_function instead.  Change the\n\torder of mapping of the actual arguments and simplifying\n\tintrinsic functions.  Finally, if a function maps to an\n\tactual argument, call gfc_map_fcn_formal_to_actual.\n\t(gfc_conv_function_call): Add 'e' to the call to\n\tgfc_add_interface_mapping.\n\t* dump-parse-tree.c (gfc_show_symbol_n): New function for\n\tdiagnostic purposes.\n\t* gfortran.h : Add prototype for gfc_show_symbol_n.\n\t* trans.h : Add 'expr' field to gfc_add_interface_mapping.\n\tAdd 'expr' to prototype for gfc_show_symbol_n.\n\t* resolve.c (resolve_generic_f0): Set specific function as\n\treferenced.\n\n2007-12-16  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/31213\n\tPR fortran/33888\n\tPR fortran/33998\n\t* gfortran.dg/mapping_1.f90: New test.\n\t* gfortran.dg/mapping_2.f90: New test.\n\t* gfortran.dg/mapping_3.f90: New test.\n\nFrom-SVN: r130988", "tree": {"sha": "c6e129ef80118a2e0bb434b7c9e4f55264aa7514", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6e129ef80118a2e0bb434b7c9e4f55264aa7514"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d/comments", "author": null, "committer": null, "parents": [{"sha": "30c6f45db68721a709f3cb135b821d10f38970fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30c6f45db68721a709f3cb135b821d10f38970fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30c6f45db68721a709f3cb135b821d10f38970fc"}], "stats": {"total": 482, "additions": 445, "deletions": 37}, "files": [{"sha": "50425ab4b9d55b249e515bf4495c29b030fa4254", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0a164a3cd0f70bacdfcdd03685748db4eff5ba1d", "patch": "@@ -1,3 +1,46 @@\n+2007-12-16  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/31213\n+\tPR fortran/33888\n+\tPR fortran/33998\n+\t* trans-array.c (gfc_trans_array_constructor_value): If the\n+\titerator variable does not have a backend_decl, use a local\n+\ttemporary.\n+\t(get_elemental_fcn_charlen): New function to map the character\n+\tlength of an elemental function onto its actual arglist.\n+\t(gfc_conv_expr_descriptor): Call the above so that the size of\n+\tthe temporary can be evaluated.\n+\t* trans-expr.c : Include arith.h and change prototype of\n+\tgfc_apply_interface_mapping_to_expr to return void.  Change all\n+\treferences to gfc_apply_interface_mapping_to_expr accordingly.\n+\t(gfc_free_interface_mapping): Free the 'expr' field.\n+\t(gfc_add_interface_mapping): Add an argument for the actual\n+\targument expression. This is copied to the 'expr' field of the\n+\tmapping.  Only stabilize the backend_decl if the se is present.\n+\tCopy the character length expression and only add it's backend\n+\tdeclaration if se is present.  Return without working on the\n+\tbackend declaration for the new symbol if se is not present.\n+\t(gfc_map_intrinsic_function) : To simplify intrinsics 'len',\n+\t'size', 'ubound' and 'lbound' and then to map the result.\n+\t(gfc_map_fcn_formal_to_actual): Performs the formal to actual\n+\tmapping for the case of a function found in a specification\n+\texpression in the interface being mapped.\n+\t(gfc_apply_interface_mapping_to_ref): Remove seen_result and\n+\tall its references. Remove the inline simplification of LEN\n+\tand call gfc_map_intrinsic_function instead.  Change the\n+\torder of mapping of the actual arguments and simplifying\n+\tintrinsic functions.  Finally, if a function maps to an\n+\tactual argument, call gfc_map_fcn_formal_to_actual.\n+\t(gfc_conv_function_call): Add 'e' to the call to\n+\tgfc_add_interface_mapping.\n+\t* dump-parse-tree.c (gfc_show_symbol_n): New function for\n+\tdiagnostic purposes.\n+\t* gfortran.h : Add prototype for gfc_show_symbol_n.\n+\t* trans.h : Add 'expr' field to gfc_add_interface_mapping.\n+\tAdd 'expr' to prototype for gfc_show_symbol_n.\n+\t* resolve.c (resolve_generic_f0): Set specific function as\n+\treferenced.\n+\n 2007-12-14  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/34438"}, {"sha": "ea83da76cff90518f36eacf774698a3575bb4540", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=0a164a3cd0f70bacdfcdd03685748db4eff5ba1d", "patch": "@@ -731,6 +731,17 @@ gfc_show_symbol (gfc_symbol *sym)\n }\n \n \n+/* Show a symbol for diagnostic purposes. */\n+void\n+gfc_show_symbol_n (const char * msg, gfc_symbol *sym)\n+{\n+  if (msg)\n+    gfc_status (msg);\n+  gfc_show_symbol (sym);\n+  gfc_status_char ('\\n');\n+}\n+\n+\n /* Show a user-defined operator.  Just prints an operator\n    and the name of the associated subroutine, really.  */\n "}, {"sha": "54c6ad859e751e63c9bec6402e88f9018ddcb754", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=0a164a3cd0f70bacdfcdd03685748db4eff5ba1d", "patch": "@@ -2364,6 +2364,7 @@ void gfc_show_namelist (gfc_namelist *);\n void gfc_show_namespace (gfc_namespace *);\n void gfc_show_ref (gfc_ref *);\n void gfc_show_symbol (gfc_symbol *);\n+void gfc_show_symbol_n (const char *, gfc_symbol *);\n void gfc_show_typespec (gfc_typespec *);\n \n /* parse.c */"}, {"sha": "0df0aa78bcd4d4b2172575e121afc9d9b19f6507", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=0a164a3cd0f70bacdfcdd03685748db4eff5ba1d", "patch": "@@ -1425,6 +1425,8 @@ resolve_generic_f0 (gfc_expr *expr, gfc_symbol *sym)\n \t  else if (s->result != NULL && s->result->as != NULL)\n \t    expr->rank = s->result->as->rank;\n \n+\t  gfc_set_sym_referenced (expr->value.function.esym);\n+\n \t  return MATCH_YES;\n \t}\n "}, {"sha": "2ebb36545796981827770f016cf8ba3aa40edbb6", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=0a164a3cd0f70bacdfcdd03685748db4eff5ba1d", "patch": "@@ -1225,10 +1225,21 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \n \t  loopbody = gfc_finish_block (&body);\n \n-\t  gfc_init_se (&se, NULL);\n-\t  gfc_conv_expr (&se, c->iterator->var);\n-\t  gfc_add_block_to_block (pblock, &se.pre);\n-\t  loopvar = se.expr;\n+\t  if (c->iterator->var->symtree->n.sym->backend_decl)\n+\t    {\n+\t      gfc_init_se (&se, NULL);\n+\t      gfc_conv_expr (&se, c->iterator->var);\n+\t      gfc_add_block_to_block (pblock, &se.pre);\n+\t      loopvar = se.expr;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* If the iterator appears in a specification expression in\n+\t\t an interface mapping, we need to make a temp for the loop\n+\t\t variable because it is not declared locally.  */\n+\t      loopvar = gfc_typenode_for_spec (&c->iterator->var->ts);\n+\t      loopvar = gfc_create_var (loopvar, \"loopvar\");\n+\t    }\n \n \t  /* Make a temporary, store the current value in that\n \t     and return it, once the loop is done.  */\n@@ -4491,6 +4502,47 @@ gfc_get_dataptr_offset (stmtblock_t *block, tree parm, tree desc, tree offset,\n }\n \n \n+/* gfc_conv_expr_descriptor needs the character length of elemental\n+   functions before the function is called so that the size of the\n+   temporary can be obtained.  The only way to do this is to convert\n+   the expression, mapping onto the actual arguments.  */\n+static void\n+get_elemental_fcn_charlen (gfc_expr *expr, gfc_se *se)\n+{\n+  gfc_interface_mapping mapping;\n+  gfc_formal_arglist *formal;\n+  gfc_actual_arglist *arg;\n+  gfc_se tse;\n+\n+  formal = expr->symtree->n.sym->formal;\n+  arg = expr->value.function.actual;\n+  gfc_init_interface_mapping (&mapping);\n+\n+  /* Set se = NULL in the calls to the interface mapping, to supress any\n+     backend stuff.  */\n+  for (; arg != NULL; arg = arg->next, formal = formal ? formal->next : NULL)\n+    {\n+      if (!arg->expr)\n+\tcontinue;\n+      if (formal->sym)\n+\tgfc_add_interface_mapping (&mapping, formal->sym, NULL, arg->expr);\n+    }\n+\n+  gfc_init_se (&tse, NULL);\n+\n+  /* Build the expression for the character length and convert it.  */\n+  gfc_apply_interface_mapping (&mapping, &tse, expr->ts.cl->length);\n+\n+  gfc_add_block_to_block (&se->pre, &tse.pre);\n+  gfc_add_block_to_block (&se->post, &tse.post);\n+  tse.expr = fold_convert (gfc_charlen_type_node, tse.expr);\n+  tse.expr = fold_build2 (MAX_EXPR, gfc_charlen_type_node, tse.expr,\n+\t\t\t  build_int_cst (gfc_charlen_type_node, 0));\n+  expr->ts.cl->backend_decl = tse.expr;\n+  gfc_free_interface_mapping (&mapping);\n+}\n+\n+\n /* Convert an array for passing as an actual argument.  Expressions and\n    vector subscripts are evaluated and stored in a temporary, which is then\n    passed.  For whole arrays the descriptor is passed.  For array sections\n@@ -4624,6 +4676,10 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t{\n \t  /* Elemental function.  */\n \t  need_tmp = 1;\n+\t  if (expr->ts.type == BT_CHARACTER\n+\t\t&& expr->ts.cl->length->expr_type != EXPR_CONSTANT)\n+\t    get_elemental_fcn_charlen (expr, se);\n+\n \t  info = NULL;\n \t}\n       else"}, {"sha": "e33df0fe0bba152431b7dd06b03eead74405b0d9", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 182, "deletions": 32, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=0a164a3cd0f70bacdfcdd03685748db4eff5ba1d", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"flags.h\"\n #include \"gfortran.h\"\n+#include \"arith.h\"\n #include \"trans.h\"\n #include \"trans-const.h\"\n #include \"trans-types.h\"\n@@ -43,7 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dependency.h\"\n \n static tree gfc_trans_structure_assign (tree dest, gfc_expr * expr);\n-static int gfc_apply_interface_mapping_to_expr (gfc_interface_mapping *,\n+static void gfc_apply_interface_mapping_to_expr (gfc_interface_mapping *,\n \t\t\t\t\t\t gfc_expr *);\n \n /* Copy the scalarization loop variables.  */\n@@ -1417,6 +1418,7 @@ gfc_free_interface_mapping (gfc_interface_mapping * mapping)\n     {\n       nextsym = sym->next;\n       gfc_free_symbol (sym->new->n.sym);\n+      gfc_free_expr (sym->expr);\n       gfc_free (sym->new);\n       gfc_free (sym);\n     }\n@@ -1521,7 +1523,8 @@ gfc_set_interface_mapping_bounds (stmtblock_t * block, tree type, tree desc)\n \n void\n gfc_add_interface_mapping (gfc_interface_mapping * mapping,\n-\t\t\t   gfc_symbol * sym, gfc_se * se)\n+\t\t\t   gfc_symbol * sym, gfc_se * se,\n+\t\t\t   gfc_expr *expr)\n {\n   gfc_interface_sym_mapping *sm;\n   tree desc;\n@@ -1539,6 +1542,7 @@ gfc_add_interface_mapping (gfc_interface_mapping * mapping,\n   new_sym->attr.pointer = sym->attr.pointer;\n   new_sym->attr.allocatable = sym->attr.allocatable;\n   new_sym->attr.flavor = sym->attr.flavor;\n+  new_sym->attr.function = sym->attr.function;\n \n   /* Create a fake symtree for it.  */\n   root = NULL;\n@@ -1551,26 +1555,32 @@ gfc_add_interface_mapping (gfc_interface_mapping * mapping,\n   sm->next = mapping->syms;\n   sm->old = sym;\n   sm->new = new_symtree;\n+  sm->expr = gfc_copy_expr (expr);\n   mapping->syms = sm;\n \n   /* Stabilize the argument's value.  */\n-  se->expr = gfc_evaluate_now (se->expr, &se->pre);\n+  if (!sym->attr.function && se)\n+    se->expr = gfc_evaluate_now (se->expr, &se->pre);\n \n   if (sym->ts.type == BT_CHARACTER)\n     {\n       /* Create a copy of the dummy argument's length.  */\n       new_sym->ts.cl = gfc_get_interface_mapping_charlen (mapping, sym->ts.cl);\n+      sm->expr->ts.cl = new_sym->ts.cl;\n \n       /* If the length is specified as \"*\", record the length that\n \t the caller is passing.  We should use the callee's length\n \t in all other cases.  */\n-      if (!new_sym->ts.cl->length)\n+      if (!new_sym->ts.cl->length && se)\n \t{\n \t  se->string_length = gfc_evaluate_now (se->string_length, &se->pre);\n \t  new_sym->ts.cl->backend_decl = se->string_length;\n \t}\n     }\n \n+  if (!se)\n+    return;\n+\n   /* Use the passed value as-is if the argument is a function.  */\n   if (sym->attr.flavor == FL_PROCEDURE)\n     value = se->expr;\n@@ -1706,21 +1716,161 @@ gfc_apply_interface_mapping_to_ref (gfc_interface_mapping * mapping,\n }\n \n \n+/* Convert intrinsic function calls into result expressions.  */\n+static bool\n+gfc_map_intrinsic_function (gfc_expr *expr, gfc_interface_mapping * mapping)\n+{\n+  gfc_symbol *sym;\n+  gfc_expr *new_expr;\n+  gfc_expr *arg1;\n+  gfc_expr *arg2;\n+  int d, dup;\n+\n+  arg1 = expr->value.function.actual->expr;\n+  if (expr->value.function.actual->next)\n+    arg2 = expr->value.function.actual->next->expr;\n+  else\n+    arg2 = NULL;\n+\n+  sym  = arg1->symtree->n.sym;\n+\n+  if (sym->attr.dummy)\n+    return false;\n+\n+  new_expr = NULL;\n+\n+  switch (expr->value.function.isym->id)\n+    {\n+    case GFC_ISYM_LEN:\n+      /* TODO figure out why this condition is necessary.  */\n+      if (sym->attr.function\n+\t    && arg1->ts.cl->length->expr_type != EXPR_CONSTANT\n+\t    && arg1->ts.cl->length->expr_type != EXPR_VARIABLE)\n+\treturn false;\n+\n+      new_expr = gfc_copy_expr (arg1->ts.cl->length);\n+      break;\n+\n+    case GFC_ISYM_SIZE:\n+      if (!sym->as)\n+\treturn false;\n+\n+      if (arg2 && arg2->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  dup = mpz_get_si (arg2->value.integer);\n+\t  d = dup - 1;\n+\t}\n+      else\n+\t{\n+\t  dup = sym->as->rank;\n+\t  d = 0;\n+\t}\n+\n+      for (; d < dup; d++)\n+\t{\n+\t  gfc_expr *tmp;\n+\t  tmp = gfc_add (gfc_copy_expr (sym->as->upper[d]), gfc_int_expr (1));\n+\t  tmp = gfc_subtract (tmp, gfc_copy_expr (sym->as->lower[d]));\n+\t  if (new_expr)\n+\t    new_expr = gfc_multiply (new_expr, tmp);\n+\t  else\n+\t    new_expr = tmp;\n+\t}\n+      break;\n+\n+    case GFC_ISYM_LBOUND:\n+    case GFC_ISYM_UBOUND:\n+\t/* TODO These implementations of lbound and ubound do not limit if\n+\t   the size < 0, according to F95's 13.14.53 and 13.14.113.  */\n+\n+      if (!sym->as)\n+\treturn false;\n+\n+      if (arg2 && arg2->expr_type == EXPR_CONSTANT)\n+\td = mpz_get_si (arg2->value.integer) - 1;\n+      else\n+\t/* TODO: If the need arises, this could produce an array of\n+\t   ubound/lbounds.  */\n+\tgcc_unreachable ();\n+\n+      if (expr->value.function.isym->id == GFC_ISYM_LBOUND)\n+\tnew_expr = gfc_copy_expr (sym->as->lower[d]);\n+      else\n+\tnew_expr = gfc_copy_expr (sym->as->upper[d]);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  gfc_apply_interface_mapping_to_expr (mapping, new_expr);\n+  if (!new_expr)\n+    return false;\n+\n+  gfc_replace_expr (expr, new_expr);\n+  return true;\n+}\n+\n+\n+static void\n+gfc_map_fcn_formal_to_actual (gfc_expr *expr, gfc_expr *map_expr,\n+\t\t\t      gfc_interface_mapping * mapping)\n+{\n+  gfc_formal_arglist *f;\n+  gfc_actual_arglist *actual;\n+\n+  actual = expr->value.function.actual;\n+  f = map_expr->symtree->n.sym->formal;\n+\n+  for (; f && actual; f = f->next, actual = actual->next)\n+    {\n+      if (!actual->expr)\n+\tcontinue;\n+\n+      gfc_add_interface_mapping (mapping, f->sym, NULL, actual->expr);\n+    }\n+\n+  if (map_expr->symtree->n.sym->attr.dimension)\n+    {\n+      int d;\n+      gfc_array_spec *as;\n+\n+      as = gfc_copy_array_spec (map_expr->symtree->n.sym->as);\n+\n+      for (d = 0; d < as->rank; d++)\n+\t{\n+\t  gfc_apply_interface_mapping_to_expr (mapping, as->lower[d]);\n+\t  gfc_apply_interface_mapping_to_expr (mapping, as->upper[d]);\n+\t}\n+\n+      expr->value.function.esym->as = as;\n+    }\n+\n+  if (map_expr->symtree->n.sym->ts.type == BT_CHARACTER)\n+    {\n+      expr->value.function.esym->ts.cl->length\n+\t= gfc_copy_expr (map_expr->symtree->n.sym->ts.cl->length);\n+\n+      gfc_apply_interface_mapping_to_expr (mapping,\n+\t\t\texpr->value.function.esym->ts.cl->length);\n+    }\n+}\n+\n+\n /* EXPR is a copy of an expression that appeared in the interface\n    associated with MAPPING.  Walk it recursively looking for references to\n    dummy arguments that MAPPING maps to actual arguments.  Replace each such\n    reference with a reference to the associated actual argument.  */\n \n-static int\n+static void\n gfc_apply_interface_mapping_to_expr (gfc_interface_mapping * mapping,\n \t\t\t\t     gfc_expr * expr)\n {\n   gfc_interface_sym_mapping *sym;\n   gfc_actual_arglist *actual;\n-  int seen_result = 0;\n \n   if (!expr)\n-    return 0;\n+    return;\n \n   /* Copying an expression does not copy its length, so do that here.  */\n   if (expr->ts.type == BT_CHARACTER && expr->ts.cl)\n@@ -1733,17 +1883,21 @@ gfc_apply_interface_mapping_to_expr (gfc_interface_mapping * mapping,\n   gfc_apply_interface_mapping_to_ref (mapping, expr->ref);\n \n   /* ...and to the expression's symbol, if it has one.  */\n-  if (expr->symtree)\n-    for (sym = mapping->syms; sym; sym = sym->next)\n-      if (sym->old == expr->symtree->n.sym)\n-\texpr->symtree = sym->new;\n+  /* TODO Find out why the condition on expr->symtree had to be moved into\n+     the loop rather than being ouside it, as originally.  */\n+  for (sym = mapping->syms; sym; sym = sym->next)\n+    if (expr->symtree && sym->old == expr->symtree->n.sym)\n+      {\n+\tif (sym->new->n.sym->backend_decl)\n+\t  expr->symtree = sym->new;\n+\telse if (sym->expr)\n+\t  gfc_replace_expr (expr, gfc_copy_expr (sym->expr));\n+      }\n \n-  /* ...and to subexpressions in expr->value.  */\n+      /* ...and to subexpressions in expr->value.  */\n   switch (expr->expr_type)\n     {\n     case EXPR_VARIABLE:\n-      if (expr->symtree->n.sym->attr.result)\n-\tseen_result = 1;\n     case EXPR_CONSTANT:\n     case EXPR_NULL:\n     case EXPR_SUBSTRING:\n@@ -1755,35 +1909,31 @@ gfc_apply_interface_mapping_to_expr (gfc_interface_mapping * mapping,\n       break;\n \n     case EXPR_FUNCTION:\n+      for (actual = expr->value.function.actual; actual; actual = actual->next)\n+\tgfc_apply_interface_mapping_to_expr (mapping, actual->expr);\n+\n       if (expr->value.function.esym == NULL\n \t    && expr->value.function.isym != NULL\n-\t    && expr->value.function.isym->id == GFC_ISYM_LEN\n-\t    && expr->value.function.actual->expr->expr_type == EXPR_VARIABLE\n-\t    && gfc_apply_interface_mapping_to_expr (mapping,\n-\t\t\texpr->value.function.actual->expr))\n-\t{\n-\t  gfc_expr *new_expr;\n-\t  new_expr = gfc_copy_expr (expr->value.function.actual->expr->ts.cl->length);\n-\t  *expr = *new_expr;\n-\t  gfc_free (new_expr);\n-\t  gfc_apply_interface_mapping_to_expr (mapping, expr);\n-\t  break;\n-\t}\n+\t    && expr->value.function.actual->expr->symtree\n+\t    && gfc_map_intrinsic_function (expr, mapping))\n+\tbreak;\n \n       for (sym = mapping->syms; sym; sym = sym->next)\n \tif (sym->old == expr->value.function.esym)\n-\t  expr->value.function.esym = sym->new->n.sym;\n-\n-      for (actual = expr->value.function.actual; actual; actual = actual->next)\n-\tgfc_apply_interface_mapping_to_expr (mapping, actual->expr);\n+\t  {\n+\t    expr->value.function.esym = sym->new->n.sym;\n+\t    gfc_map_fcn_formal_to_actual (expr, sym->expr, mapping);\n+\t    expr->value.function.esym->result = sym->new->n.sym;\n+\t  }\n       break;\n \n     case EXPR_ARRAY:\n     case EXPR_STRUCTURE:\n       gfc_apply_interface_mapping_to_cons (mapping, expr->value.constructor);\n       break;\n     }\n-  return seen_result;\n+\n+  return;\n }\n \n \n@@ -2351,7 +2501,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t}\n \n       if (fsym && need_interface_mapping)\n-\tgfc_add_interface_mapping (&mapping, fsym, &parmse);\n+\tgfc_add_interface_mapping (&mapping, fsym, &parmse, e);\n \n       gfc_add_block_to_block (&se->pre, &parmse.pre);\n       gfc_add_block_to_block (&post, &parmse.post);"}, {"sha": "9ccf5713bee38342dfbe90e877a475aed3a5fe74", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=0a164a3cd0f70bacdfcdd03685748db4eff5ba1d", "patch": "@@ -695,6 +695,7 @@ typedef struct gfc_interface_sym_mapping\n   struct gfc_interface_sym_mapping *next;\n   gfc_symbol *old;\n   gfc_symtree *new;\n+  gfc_expr *expr;\n }\n gfc_interface_sym_mapping;\n \n@@ -716,7 +717,7 @@ gfc_interface_mapping;\n void gfc_init_interface_mapping (gfc_interface_mapping *);\n void gfc_free_interface_mapping (gfc_interface_mapping *);\n void gfc_add_interface_mapping (gfc_interface_mapping *,\n-\t\t\t\tgfc_symbol *, gfc_se *);\n+\t\t\t\tgfc_symbol *, gfc_se *, gfc_expr *);\n void gfc_finish_interface_mapping (gfc_interface_mapping *,\n \t\t\t\t   stmtblock_t *, stmtblock_t *);\n void gfc_apply_interface_mapping (gfc_interface_mapping *,"}, {"sha": "dd3ce1f30fcf0641ccab028cb3026f31f20973fe", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0a164a3cd0f70bacdfcdd03685748db4eff5ba1d", "patch": "@@ -1,3 +1,12 @@\n+2007-12-16  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/31213\n+\tPR fortran/33888\n+\tPR fortran/33998\n+\t* gfortran.dg/mapping_1.f90: New test.\n+\t* gfortran.dg/mapping_2.f90: New test.\n+\t* gfortran.dg/mapping_3.f90: New test.\n+\n 2007-12-16  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \tPR rtl-optimization/34415"}, {"sha": "02042c026267764bac330a2ac5043f7f2633ee3a", "filename": "gcc/testsuite/gfortran.dg/mapping_1.f90", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d/gcc%2Ftestsuite%2Fgfortran.dg%2Fmapping_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d/gcc%2Ftestsuite%2Fgfortran.dg%2Fmapping_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmapping_1.f90?ref=0a164a3cd0f70bacdfcdd03685748db4eff5ba1d", "patch": "@@ -0,0 +1,70 @@\n+! { dg-do run }\n+! Tests the fix for PR31213, which exposed rather a lot of\n+! bugs - see the PR and the ChangeLog.\n+!\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+!\n+module mykinds\n+  implicit none\n+  integer, parameter :: ik1 = selected_int_kind (2)\n+  integer, parameter :: ik2 = selected_int_kind (4)\n+  integer, parameter :: dp = selected_real_kind (15,300)\n+end module mykinds\n+\n+module spec_xpr\n+  use mykinds\n+  implicit none\n+  integer(ik2) c_size\n+contains\n+  pure function tricky (str,ugly)\n+    character(*), intent(in) :: str\n+    integer(ik1) :: ia_ik1(len(str))\n+    interface yoagly\n+      pure function ugly(n)\n+        use mykinds\n+        implicit none\n+        integer, intent(in) :: n\n+        complex(dp) :: ugly(3*n+2)\n+      end function ugly\n+    end interface yoagly\n+    logical :: la(size (yoagly (size (ia_ik1))))\n+    integer :: i\n+    character(tricky_helper ((/(.TRUE., i=1, size (la))/)) + c_size) :: tricky\n+\n+    tricky = transfer (yoagly (1), tricky)\n+  end function tricky\n+\n+  pure function tricky_helper (lb)\n+    logical, intent(in) :: lb(:)\n+    integer :: tricky_helper\n+    tricky_helper = 2 * size (lb) + 3\n+  end function tricky_helper\n+end module spec_xpr\n+\n+module xtra_fun\n+  implicit none\n+contains\n+  pure function butt_ugly(n)\n+    use mykinds\n+    implicit none\n+    integer, intent(in) :: n\n+    complex(dp) :: butt_ugly(3*n+2)\n+    real(dp) pi, sq2\n+\n+    pi = 4 * atan (1.0_dp)\n+    sq2 = sqrt (2.0_dp)\n+    butt_ugly = cmplx (pi, sq2, dp)\n+  end function butt_ugly\n+end module xtra_fun\n+\n+program spec_test\n+  use mykinds\n+  use spec_xpr\n+  use xtra_fun\n+  implicit none\n+  character(54) :: chr\n+\n+  c_size = 5\n+  if (tricky ('Help me', butt_ugly) .ne. transfer (butt_ugly (1), chr)) call abort ()\n+end program spec_test\n+! { dg-final { cleanup-modules \"mykinds spec_xpr xtra_fun\" } }"}, {"sha": "7611c42925e01a233ae742b5741b648b7bb58133", "filename": "gcc/testsuite/gfortran.dg/mapping_2.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d/gcc%2Ftestsuite%2Fgfortran.dg%2Fmapping_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d/gcc%2Ftestsuite%2Fgfortran.dg%2Fmapping_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmapping_2.f90?ref=0a164a3cd0f70bacdfcdd03685748db4eff5ba1d", "patch": "@@ -0,0 +1,32 @@\n+! { dg-do run }\n+! Tests the fix for PR33998, in which the chain of expressions\n+! determining the character length of my_string were not being\n+! resolved by the formal to actual mapping.\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+module test\n+   implicit none\n+   contains\n+      function my_string(x)\n+         integer i\n+         real, intent(in) :: x(:)\n+         character(0) h4(1:minval([(1,i=1,0)],1))\n+         character(0) sv1(size(x,1):size(h4))\n+         character(0) sv2(2*lbound(sv1,1):size(h4))\n+         character(lbound(sv2,1)-3) my_string\n+\n+         do i = 1, len(my_string)\n+            my_string(i:i) = achar(modulo(i-1,10)+iachar('0'))\n+         end do\n+      end function my_string\n+end module test\n+\n+program len_test\n+   use test\n+   implicit none\n+   real x(7)\n+\n+   if (my_string(x) .ne. \"01234567890\") call abort ()\n+end program len_test\n+! { dg-final { cleanup-modules \"test\" } }"}, {"sha": "318ec00c02778f2446752e4aba0744457eadb2a1", "filename": "gcc/testsuite/gfortran.dg/mapping_3.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d/gcc%2Ftestsuite%2Fgfortran.dg%2Fmapping_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a164a3cd0f70bacdfcdd03685748db4eff5ba1d/gcc%2Ftestsuite%2Fgfortran.dg%2Fmapping_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmapping_3.f90?ref=0a164a3cd0f70bacdfcdd03685748db4eff5ba1d", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do run }\n+! Tests the fix for PR33888, in which the character length of\n+! the elemental function myfunc was not being calculated before\n+! the temporary for the array result was allocated.\n+!\n+! Contributed by Walter Spector <w6ws@earthlink.net>\n+!\n+program ftn95bug\n+  implicit none\n+\n+  character(8) :: indata(4) =  &\n+              (/ '12344321', '98766789', 'abcdefgh', 'ABCDEFGH' /)\n+\n+  call process (myfunc (indata))  ! <- This caused a gfortran ICE !\n+\n+contains\n+\n+  elemental function myfunc (s)\n+    character(*), intent(in) :: s\n+    character(len (s)) :: myfunc\n+\n+    myfunc = s\n+\n+  end function\n+\n+  subroutine process (strings)\n+    character(*), intent(in) :: strings(:)\n+\n+    if (any (strings .ne. indata)) call abort ()\n+\n+  end subroutine\n+\n+end program"}]}