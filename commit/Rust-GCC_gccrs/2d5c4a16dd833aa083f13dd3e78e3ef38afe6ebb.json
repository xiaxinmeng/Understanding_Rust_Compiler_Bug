{"sha": "2d5c4a16dd833aa083f13dd3e78e3ef38afe6ebb", "node_id": "C_kwDOANBUbNoAKDJkNWM0YTE2ZGQ4MzNhYTA4M2YxM2RkM2U3OGUzZWYzOGFmZTZlYmI", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-12T08:35:16Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-12T08:35:16Z"}, "message": "range-op: Implement floating point division fold_range [PR107569]\n\nHere is the floating point division fold_range implementation,\nas I wrote in the last mail, we could outline some of the common parts\ninto static methods with descriptive names and share them between\nfoperator_div and foperator_mult.\n\nRegressions are\n+FAIL: gcc.dg/pr95115.c execution test\n+FAIL: libphobos.phobos/std/math/hardware.d execution test\n+FAIL: libphobos.phobos_shared/std/math/hardware.d execution test\nThe first test is we have:\n  # RANGE [frange] double [] +-NAN\n  _3 =  Inf /  Inf;\n  if (_3 ord _3)\n    goto <bb 3>; [INV]\n  else\n    goto <bb 4>; [INV]\n\n  <bb 3> :\n  abort ();\n\n  <bb 4> :\nbefore evrp, the range is correct, Inf / Inf is known NAN of unknown\nsign.  evrp correctly folds _3 ord _3 into false and the\n  _3 =  Inf /  Inf;\nremains in the IL, but then comes dse1 and removes it as dead\nstatement.  So, I think yet another example of the PR107608 problems\nwhere DCE? removes dead statements which raise floating point exceptions.\nAnd -fno-delete-dead-exceptions doesn't help.\n\n2022-11-12  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/107569\n\t* range-op-float.cc (foperator_div): New class.\n\t(floating_op_table::floating_op_table): Use foperator_div\n\tfor RDIV_EXPR.", "tree": {"sha": "35c7d90ab5aa975e7b283f3070b02f4dca0d5c40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35c7d90ab5aa975e7b283f3070b02f4dca0d5c40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d5c4a16dd833aa083f13dd3e78e3ef38afe6ebb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d5c4a16dd833aa083f13dd3e78e3ef38afe6ebb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d5c4a16dd833aa083f13dd3e78e3ef38afe6ebb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d5c4a16dd833aa083f13dd3e78e3ef38afe6ebb/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f7f9edd28d75a85a33599978f23811e679e443d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f7f9edd28d75a85a33599978f23811e679e443d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f7f9edd28d75a85a33599978f23811e679e443d"}], "stats": {"total": 178, "additions": 178, "deletions": 0}, "files": [{"sha": "047f3606ff61c4d2781dbb9baeaaee57cda69e15", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d5c4a16dd833aa083f13dd3e78e3ef38afe6ebb/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d5c4a16dd833aa083f13dd3e78e3ef38afe6ebb/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=2d5c4a16dd833aa083f13dd3e78e3ef38afe6ebb", "patch": "@@ -2086,6 +2086,183 @@ class foperator_mult : public range_operator_float\n   }\n } fop_mult;\n \n+class foperator_div : public range_operator_float\n+{\n+  void rv_fold (REAL_VALUE_TYPE &lb, REAL_VALUE_TYPE &ub, bool &maybe_nan,\n+\t\ttree type,\n+\t\tconst REAL_VALUE_TYPE &lh_lb,\n+\t\tconst REAL_VALUE_TYPE &lh_ub,\n+\t\tconst REAL_VALUE_TYPE &rh_lb,\n+\t\tconst REAL_VALUE_TYPE &rh_ub,\n+\t\trelation_kind) const final override\n+  {\n+    // +-0.0 / +-0.0 or +-INF / +-INF is a known NAN.\n+    if ((real_iszero (&lh_lb)\n+\t && real_iszero (&lh_ub)\n+\t && real_iszero (&rh_lb)\n+\t && real_iszero (&rh_ub))\n+\t|| (real_isinf (&lh_lb)\n+\t    && real_isinf (&lh_ub, real_isneg (&lh_lb))\n+\t    && real_isinf (&rh_lb)\n+\t    && real_isinf (&rh_ub, real_isneg (&rh_lb))))\n+      {\n+\treal_nan (&lb, \"\", 0, TYPE_MODE (type));\n+\tub = lb;\n+\tmaybe_nan = true;\n+\treturn;\n+      }\n+\n+    bool both_maybe_zero = false;\n+    bool both_maybe_inf = false;\n+    bool must_have_signbit_zero = false;\n+    bool must_have_signbit_nonzero = false;\n+\n+    // If +-0.0 is in both ranges, it is a maybe NAN.\n+    if (real_compare (LE_EXPR, &lh_lb, &dconst0)\n+\t&& real_compare (GE_EXPR, &lh_ub, &dconst0)\n+\t&& real_compare (LE_EXPR, &rh_lb, &dconst0)\n+\t&& real_compare (GE_EXPR, &rh_ub, &dconst0))\n+      {\n+\tboth_maybe_zero = true;\n+\tmaybe_nan = true;\n+      }\n+    // If +-INF is in both ranges, it is a maybe NAN.\n+    else if ((real_isinf (&lh_lb) || real_isinf (&lh_ub))\n+\t     && (real_isinf (&rh_lb) || real_isinf (&rh_ub)))\n+      {\n+\tboth_maybe_inf = true;\n+\tmaybe_nan = true;\n+      }\n+    else\n+      maybe_nan = false;\n+\n+    if (real_isneg (&lh_lb) == real_isneg (&lh_ub)\n+\t&& real_isneg (&rh_lb) == real_isneg (&rh_ub))\n+      {\n+\tif (real_isneg (&lh_lb) == real_isneg (&rh_ub))\n+\t  must_have_signbit_zero = true;\n+\telse\n+\t  must_have_signbit_nonzero = true;\n+      }\n+\n+    // If dividend must be zero, the range is just +-0\n+    // (including if the divisor is +-INF).\n+    // If divisor must be +-INF, the range is just +-0\n+    // (including if the dividend is zero).\n+    if ((real_iszero (&lh_lb) && real_iszero (&lh_ub))\n+\t|| real_isinf (&rh_lb, false)\n+\t|| real_isinf (&rh_ub, true))\n+      {\n+\tub = lb = dconst0;\n+\t// If all the boundary signs are the same, [+0.0, +0.0].\n+\tif (must_have_signbit_zero)\n+\t  ;\n+\t// If divisor and dividend must have different signs,\n+\t// [-0.0, -0.0].\n+\telse if (must_have_signbit_nonzero)\n+\t  ub = lb = real_value_negate (&dconst0);\n+\t// Otherwise -> [-0.0, +0.0].\n+\telse\n+\t  lb = real_value_negate (&dconst0);\n+\treturn;\n+      }\n+\n+    // If divisor must be zero, the range is just +-INF\n+    // (including if the dividend is +-INF).\n+    // If dividend must be +-INF, the range is just +-INF\n+    // (including if the dividend is zero).\n+    if ((real_iszero (&rh_lb) && real_iszero (&rh_ub))\n+\t|| real_isinf (&lh_lb, false)\n+\t|| real_isinf (&lh_ub, true))\n+      {\n+\t// If all the boundary signs are the same, [+INF, +INF].\n+\tif (must_have_signbit_zero)\n+\t  ub = lb = dconstinf;\n+\t// If divisor and dividend must have different signs,\n+\t// [-INF, -INF].\n+\telse if (must_have_signbit_nonzero)\n+\t  ub = lb = dconstninf;\n+\t// Otherwise -> [-INF, +INF] (-INF or +INF).\n+\telse\n+\t  {\n+\t    lb = dconstninf;\n+\t    ub = dconstinf;\n+\t  }\n+\treturn;\n+      }\n+\n+    // Otherwise if both operands may be zero, divisor could be\n+    // nextafter(0.0, +-1.0) and dividend +-0.0\n+    // in which case result is going to INF or vice versa and\n+    // result +0.0.  So, all we can say for that case is if the\n+    // signs of divisor and dividend are always the same we have\n+    // [+0.0, +INF], if they are always different we have\n+    // [-INF, -0.0].  If they vary, VARING.\n+    // If both may be +-INF, divisor could be INF and dividend FLT_MAX,\n+    // in which case result is going to INF or vice versa and\n+    // result +0.0.  So, all we can say for that case is if the\n+    // signs of divisor and dividend are always the same we have\n+    // [+0.0, +INF], if they are always different we have\n+    // [-INF, -0.0].  If they vary, VARYING.\n+    if (both_maybe_zero || both_maybe_inf)\n+      {\n+\tif (must_have_signbit_zero)\n+\t  {\n+\t    lb = dconst0;\n+\t    ub = dconstinf;\n+\t  }\n+\telse if (must_have_signbit_nonzero)\n+\t  {\n+\t    lb = dconstninf;\n+\t    ub = real_value_negate (&dconst0);\n+\t  }\n+\telse\n+\t  {\n+\t    lb = dconstninf;\n+\t    ub = dconstinf;\n+\t  }\n+\treturn;\n+      }\n+\n+    REAL_VALUE_TYPE cp[8];\n+    // Do a cross-division.  At this point none of the divisions should\n+    // produce a NAN.\n+    gcc_assert (!maybe_nan);\n+    frange_arithmetic (RDIV_EXPR, type, cp[0], lh_lb, rh_lb, dconstninf);\n+    frange_arithmetic (RDIV_EXPR, type, cp[1], lh_lb, rh_ub, dconstninf);\n+    frange_arithmetic (RDIV_EXPR, type, cp[2], lh_ub, rh_lb, dconstninf);\n+    frange_arithmetic (RDIV_EXPR, type, cp[3], lh_ub, rh_ub, dconstninf);\n+    frange_arithmetic (RDIV_EXPR, type, cp[4], lh_lb, rh_lb, dconstinf);\n+    frange_arithmetic (RDIV_EXPR, type, cp[5], lh_lb, rh_ub, dconstinf);\n+    frange_arithmetic (RDIV_EXPR, type, cp[6], lh_ub, rh_lb, dconstinf);\n+    frange_arithmetic (RDIV_EXPR, type, cp[7], lh_ub, rh_ub, dconstinf);\n+\n+    for (int i = 1; i < 4; ++i)\n+      {\n+\tif (real_less (&cp[i], &cp[0])\n+\t    || (real_iszero (&cp[0]) && real_isnegzero (&cp[i])))\n+\t  std::swap (cp[i], cp[0]);\n+\tif (real_less (&cp[4], &cp[i + 4])\n+\t    || (real_isnegzero (&cp[4]) && real_iszero (&cp[i + 4])))\n+\t  std::swap (cp[i + 4], cp[4]);\n+      }\n+    lb = cp[0];\n+    ub = cp[4];\n+\n+    // If divisor may be zero (but is not known to be only zero),\n+    // and dividend can't be zero, the range can go up to -INF or +INF\n+    // depending on the signs.\n+    if (real_compare (LE_EXPR, &rh_lb, &dconst0)\n+\t&& real_compare (GE_EXPR, &rh_ub, &dconst0))\n+      {\n+\tif (!must_have_signbit_zero)\n+\t  real_inf (&lb, true);\n+\tif (!must_have_signbit_nonzero)\n+\t  real_inf (&ub, false);\n+      }\n+  }\n+} fop_div;\n+\n // Instantiate a range_op_table for floating point operations.\n static floating_op_table global_floating_table;\n \n@@ -2121,6 +2298,7 @@ floating_op_table::floating_op_table ()\n   set (PLUS_EXPR, fop_plus);\n   set (MINUS_EXPR, fop_minus);\n   set (MULT_EXPR, fop_mult);\n+  set (RDIV_EXPR, fop_div);\n }\n \n // Return a pointer to the range_operator_float instance, if there is"}]}