{"sha": "6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "node_id": "C_kwDOANBUbNoAKDZjMDM5OTM3OGU3N2QwMjk2MmU1ZDQ5ZjdiNzJkNmZhOGViZTVlMDc", "commit": {"author": {"name": "Chung-Lin Tang", "email": "cltang@codesourcery.com", "date": "2021-12-08T15:58:55Z"}, "committer": {"name": "Chung-Lin Tang", "email": "cltang@codesourcery.com", "date": "2021-12-08T16:01:10Z"}, "message": "OpenMP 5.0: Remove array section base-pointer mapping semantics and other front-end adjustments\n\nThis patch implements three pieces of functionality:\n\n(1) Adjust array section mapping to have standards conforming behavior,\nmapping array sections should *NOT* also map the base-pointer:\n\nstruct S { int *ptr; ... };\nstruct S s;\n\nInstead of generating this during gimplify:\n                              map(to:*_1 [len: 400]) map(attach:s.ptr [bias: 0])\n\nNow, adjust to:\n\n(i.e. do not map the base-pointer together. The attach operation is still\ngenerated, and if s.ptr is already mapped prior, attachment will happen)\n\nThe correct way of achieving the base-pointer-also-mapped behavior would be to\nuse:\n\n(A small Fortran front-end patch to trans-openmp.c:gfc_trans_omp_array_section\n is also included, which removes generation of a GOMP_MAP_ALWAYS_POINTER for\n array types, which appears incorrect and causes a regression in\n libgomp.fortranlibgomp.fortran/struct-elem-map-1.f90)\n\n(2) Related to the first item above, are fixes in libgomp/target.c to not\noverwrite attached pointers when handling device<->host copies, mainly for the\n\"always\" case.\n\n(3) The third is a set of changes to the C/C++ front-ends to extend the allowed\ncomponent access syntax in map clauses. These changes are enabled for both\nOpenACC and OpenMP.\n\ngcc/c/ChangeLog:\n\n\t* c-parser.c (struct omp_dim): New struct type for use inside\n\tc_parser_omp_variable_list.\n\t(c_parser_omp_variable_list): Allow multiple levels of array and\n\tcomponent accesses in array section base-pointer expression.\n\t(c_parser_omp_clause_to): Set 'allow_deref' to true in call to\n\tc_parser_omp_var_list_parens.\n\t(c_parser_omp_clause_from): Likewise.\n\t* c-typeck.c (handle_omp_array_sections_1): Extend allowed range\n\tof base-pointer expressions involving INDIRECT/MEM/ARRAY_REF and\n\tPOINTER_PLUS_EXPR.\n\t(c_finish_omp_clauses): Extend allowed ranged of expressions\n\tinvolving INDIRECT/MEM/ARRAY_REF and POINTER_PLUS_EXPR.\n\ngcc/cp/ChangeLog:\n\n\t* parser.c (struct omp_dim): New struct type for use inside\n\tcp_parser_omp_var_list_no_open.\n\t(cp_parser_omp_var_list_no_open): Allow multiple levels of array and\n\tcomponent accesses in array section base-pointer expression.\n\t(cp_parser_omp_all_clauses): Set 'allow_deref' to true in call to\n\tcp_parser_omp_var_list for to/from clauses.\n\t* semantics.c (handle_omp_array_sections_1): Extend allowed range\n\tof base-pointer expressions involving INDIRECT/MEM/ARRAY_REF and\n\tPOINTER_PLUS_EXPR.\n\t(handle_omp_array_sections): Adjust pointer map generation of\n\treferences.\n\t(finish_omp_clauses): Extend allowed ranged of expressions\n\tinvolving INDIRECT/MEM/ARRAY_REF and POINTER_PLUS_EXPR.\n\ngcc/fortran/ChangeLog:\n\n\t* trans-openmp.c (gfc_trans_omp_array_section): Do not generate\n\tGOMP_MAP_ALWAYS_POINTER map for main array maps of ARRAY_TYPE type.\n\ngcc/ChangeLog:\n\n\t* gimplify.c (extract_base_bit_offset): Add 'tree *offsetp' parameter,\n\taccomodate case where 'offset' return of get_inner_reference is\n\tnon-NULL.\n\t(is_or_contains_p): Further robustify conditions.\n\t(omp_target_reorder_clauses): In alloc/to/from sorting phase, also\n\tmove following GOMP_MAP_ALWAYS_POINTER maps along.  Add new sorting\n\tphase where we make sure pointers with an attach/detach map are ordered\n\tcorrectly.\n\t(gimplify_scan_omp_clauses): Add modifications to avoid creating\n\tGOMP_MAP_STRUCT and associated alloc map for attach/detach maps.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/goacc/deep-copy-arrayofstruct.c: Adjust testcase.\n\t* c-c++-common/gomp/target-enter-data-1.c: New testcase.\n\t* c-c++-common/gomp/target-implicit-map-2.c: New testcase.\n\nlibgomp/ChangeLog:\n\n\t* target.c (gomp_map_vars_existing): Make sure attached pointer is\n\tnot overwritten during cross-host/device copying.\n\t(gomp_update): Likewise.\n\t(gomp_exit_data): Likewise.\n\t* testsuite/libgomp.c++/target-11.C: Adjust testcase.\n\t* testsuite/libgomp.c++/target-12.C: Likewise.\n\t* testsuite/libgomp.c++/target-15.C: Likewise.\n\t* testsuite/libgomp.c++/target-16.C: Likewise.\n\t* testsuite/libgomp.c++/target-17.C: Likewise.\n\t* testsuite/libgomp.c++/target-21.C: Likewise.\n\t* testsuite/libgomp.c++/target-23.C: Likewise.\n\t* testsuite/libgomp.c/target-23.c: Likewise.\n\t* testsuite/libgomp.c/target-29.c: Likewise.\n\t* testsuite/libgomp.c-c++-common/target-implicit-map-2.c: New testcase.", "tree": {"sha": "1b5644f24197dedde1aa8dbf1d8b983d14ab5b19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b5644f24197dedde1aa8dbf1d8b983d14ab5b19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/comments", "author": {"login": "cltang", "id": 4055966, "node_id": "MDQ6VXNlcjQwNTU5NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/4055966?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cltang", "html_url": "https://github.com/cltang", "followers_url": "https://api.github.com/users/cltang/followers", "following_url": "https://api.github.com/users/cltang/following{/other_user}", "gists_url": "https://api.github.com/users/cltang/gists{/gist_id}", "starred_url": "https://api.github.com/users/cltang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cltang/subscriptions", "organizations_url": "https://api.github.com/users/cltang/orgs", "repos_url": "https://api.github.com/users/cltang/repos", "events_url": "https://api.github.com/users/cltang/events{/privacy}", "received_events_url": "https://api.github.com/users/cltang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cltang", "id": 4055966, "node_id": "MDQ6VXNlcjQwNTU5NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/4055966?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cltang", "html_url": "https://github.com/cltang", "followers_url": "https://api.github.com/users/cltang/followers", "following_url": "https://api.github.com/users/cltang/following{/other_user}", "gists_url": "https://api.github.com/users/cltang/gists{/gist_id}", "starred_url": "https://api.github.com/users/cltang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cltang/subscriptions", "organizations_url": "https://api.github.com/users/cltang/orgs", "repos_url": "https://api.github.com/users/cltang/repos", "events_url": "https://api.github.com/users/cltang/events{/privacy}", "received_events_url": "https://api.github.com/users/cltang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b49d50a27428e9de0ae2913651a6379744f3067", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b49d50a27428e9de0ae2913651a6379744f3067", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b49d50a27428e9de0ae2913651a6379744f3067"}], "stats": {"total": 908, "additions": 752, "deletions": 156}, "files": [{"sha": "e99c84776f149d1b603cc9ffe1e2cbfe1c2052cb", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 49, "deletions": 5, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "patch": "@@ -12989,19 +12989,29 @@ c_parser_oacc_wait_list (c_parser *parser, location_t clause_loc, tree list)\n    The optional ALLOW_DEREF argument is true if list items can use the deref\n    (->) operator.  */\n \n+struct omp_dim\n+{\n+  tree low_bound, length;\n+  location_t loc;\n+  bool no_colon;\n+  omp_dim (tree lb, tree len, location_t lo, bool nc)\n+  : low_bound (lb), length (len), loc (lo), no_colon (nc) {}\n+};\n+\n static tree\n c_parser_omp_variable_list (c_parser *parser,\n \t\t\t    location_t clause_loc,\n \t\t\t    enum omp_clause_code kind, tree list,\n \t\t\t    bool allow_deref = false)\n {\n+  auto_vec<omp_dim> dims;\n+  bool array_section_p;\n   auto_vec<c_token> tokens;\n   unsigned int tokens_avail = 0;\n   bool first = true;\n \n   while (1)\n     {\n-      bool array_section_p = false;\n       if (kind == OMP_CLAUSE_DEPEND || kind == OMP_CLAUSE_AFFINITY)\n \t{\n \t  if (c_parser_next_token_is_not (parser, CPP_NAME)\n@@ -13120,6 +13130,7 @@ c_parser_omp_variable_list (c_parser *parser,\n \t    case OMP_CLAUSE_MAP:\n \t    case OMP_CLAUSE_FROM:\n \t    case OMP_CLAUSE_TO:\n+\t    start_component_ref:\n \t      while (c_parser_next_token_is (parser, CPP_DOT)\n \t\t     || (allow_deref\n \t\t\t && c_parser_next_token_is (parser, CPP_DEREF)))\n@@ -13147,9 +13158,13 @@ c_parser_omp_variable_list (c_parser *parser,\n \t    case OMP_CLAUSE_REDUCTION:\n \t    case OMP_CLAUSE_IN_REDUCTION:\n \t    case OMP_CLAUSE_TASK_REDUCTION:\n+\t      array_section_p = false;\n+\t      dims.truncate (0);\n \t      while (c_parser_next_token_is (parser, CPP_OPEN_SQUARE))\n \t\t{\n+\t\t  location_t loc = UNKNOWN_LOCATION;\n \t\t  tree low_bound = NULL_TREE, length = NULL_TREE;\n+\t\t  bool no_colon = false;\n \n \t\t  c_parser_consume_token (parser);\n \t\t  if (!c_parser_next_token_is (parser, CPP_COLON))\n@@ -13160,9 +13175,13 @@ c_parser_omp_variable_list (c_parser *parser,\n \t\t      expr = convert_lvalue_to_rvalue (expr_loc, expr,\n \t\t\t\t\t\t       false, true);\n \t\t      low_bound = expr.value;\n+\t\t      loc = expr_loc;\n \t\t    }\n \t\t  if (c_parser_next_token_is (parser, CPP_CLOSE_SQUARE))\n-\t\t    length = integer_one_node;\n+\t\t    {\n+\t\t      length = integer_one_node;\n+\t\t      no_colon = true;\n+\t\t    }\n \t\t  else\n \t\t    {\n \t\t      /* Look for `:'.  */\n@@ -13191,8 +13210,33 @@ c_parser_omp_variable_list (c_parser *parser,\n \t\t      break;\n \t\t    }\n \n-\t\t  t = tree_cons (low_bound, length, t);\n+\t\t  dims.safe_push (omp_dim (low_bound, length, loc, no_colon));\n+\t\t}\n+\n+\t      if (t != error_mark_node)\n+\t\t{\n+\t\t  if ((kind == OMP_CLAUSE_MAP\n+\t\t       || kind == OMP_CLAUSE_FROM\n+\t\t       || kind == OMP_CLAUSE_TO)\n+\t\t      && !array_section_p\n+\t\t      && (c_parser_next_token_is (parser, CPP_DOT)\n+\t\t\t  || (allow_deref\n+\t\t\t      && c_parser_next_token_is (parser,\n+\t\t\t\t\t\t\t CPP_DEREF))))\n+\t\t    {\n+\t\t      for (unsigned i = 0; i < dims.length (); i++)\n+\t\t\t{\n+\t\t\t  gcc_assert (dims[i].length == integer_one_node);\n+\t\t\t  t = build_array_ref (dims[i].loc,\n+\t\t\t\t\t       t, dims[i].low_bound);\n+\t\t\t}\n+\t\t      goto start_component_ref;\n+\t\t    }\n+\t\t  else\n+\t\t    for (unsigned i = 0; i < dims.length (); i++)\n+\t\t      t = tree_cons (dims[i].low_bound, dims[i].length, t);\n \t\t}\n+\n \t      if ((kind == OMP_CLAUSE_DEPEND || kind == OMP_CLAUSE_AFFINITY)\n \t\t  && t != error_mark_node\n \t\t  && parser->tokens_avail != 2)\n@@ -16439,7 +16483,7 @@ c_parser_omp_clause_device_type (c_parser *parser, tree list)\n static tree\n c_parser_omp_clause_to (c_parser *parser, tree list)\n {\n-  return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_TO, list);\n+  return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_TO, list, true);\n }\n \n /* OpenMP 4.0:\n@@ -16448,7 +16492,7 @@ c_parser_omp_clause_to (c_parser *parser, tree list)\n static tree\n c_parser_omp_clause_from (c_parser *parser, tree list)\n {\n-  return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_FROM, list);\n+  return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_FROM, list, true);\n }\n \n /* OpenMP 4.0:"}, {"sha": "78a6c68aaa6acf9e442d3c0bd5f7f19512b5e3ea", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 74, "deletions": 13, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "patch": "@@ -13220,6 +13220,18 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t\t    t, omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t  return error_mark_node;\n \t}\n+      while (TREE_CODE (t) == INDIRECT_REF)\n+\t{\n+\t  t = TREE_OPERAND (t, 0);\n+\t  STRIP_NOPS (t);\n+\t  if (TREE_CODE (t) == POINTER_PLUS_EXPR)\n+\t    t = TREE_OPERAND (t, 0);\n+\t}\n+      while (TREE_CODE (t) == COMPOUND_EXPR)\n+\t{\n+\t  t = TREE_OPERAND (t, 1);\n+\t  STRIP_NOPS (t);\n+\t}\n       if (TREE_CODE (t) == COMPONENT_REF\n \t  && (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n \t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TO\n@@ -13241,10 +13253,14 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t\t  return error_mark_node;\n \t\t}\n \t      t = TREE_OPERAND (t, 0);\n-\t      if (TREE_CODE (t) == MEM_REF)\n+\t      while (TREE_CODE (t) == MEM_REF\n+\t\t     || TREE_CODE (t) == INDIRECT_REF\n+\t\t     || TREE_CODE (t) == ARRAY_REF)\n \t\t{\n \t\t  t = TREE_OPERAND (t, 0);\n \t\t  STRIP_NOPS (t);\n+\t\t  if (TREE_CODE (t) == POINTER_PLUS_EXPR)\n+\t\t    t = TREE_OPERAND (t, 0);\n \t\t}\n \t      if (ort == C_ORT_ACC && TREE_CODE (t) == MEM_REF)\n \t\t{\n@@ -13533,15 +13549,25 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t  return error_mark_node;\n \t}\n       /* If there is a pointer type anywhere but in the very first\n-\t array-section-subscript, the array section can't be contiguous.  */\n+\t array-section-subscript, the array section could be non-contiguous.  */\n       if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n \t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_AFFINITY\n \t  && TREE_CODE (TREE_CHAIN (t)) == TREE_LIST)\n \t{\n-\t  error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t    \"array section is not contiguous in %qs clause\",\n-\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n-\t  return error_mark_node;\n+\t  /* If any prior dimension has a non-one length, then deem this\n+\t     array section as non-contiguous.  */\n+\t  for (tree d = TREE_CHAIN (t); TREE_CODE (d) == TREE_LIST;\n+\t       d = TREE_CHAIN (d))\n+\t    {\n+\t      tree d_length = TREE_VALUE (d);\n+\t      if (d_length == NULL_TREE || !integer_onep (d_length))\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"array section is not contiguous in %qs clause\",\n+\t\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t  return error_mark_node;\n+\t\t}\n+\t    }\n \t}\n     }\n   else\n@@ -14890,13 +14916,20 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t  if (TREE_CODE (t) == COMPONENT_REF\n \t\t      && TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n \t\t    {\n-\t\t      while (TREE_CODE (t) == COMPONENT_REF)\n-\t\t\tt = TREE_OPERAND (t, 0);\n-\t\t      if (TREE_CODE (t) == MEM_REF)\n+\t\t      do\n \t\t\t{\n \t\t\t  t = TREE_OPERAND (t, 0);\n-\t\t\t  STRIP_NOPS (t);\n+\t\t\t  if (TREE_CODE (t) == MEM_REF\n+\t\t\t      || TREE_CODE (t) == INDIRECT_REF)\n+\t\t\t    {\n+\t\t\t      t = TREE_OPERAND (t, 0);\n+\t\t\t      STRIP_NOPS (t);\n+\t\t\t      if (TREE_CODE (t) == POINTER_PLUS_EXPR)\n+\t\t\t\tt = TREE_OPERAND (t, 0);\n+\t\t\t    }\n \t\t\t}\n+\t\t      while (TREE_CODE (t) == COMPONENT_REF);\n+\n \t\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n \t\t\t  && OMP_CLAUSE_MAP_IMPLICIT (c)\n \t\t\t  && (bitmap_bit_p (&map_head, DECL_UID (t))\n@@ -14963,14 +14996,32 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t       bias) to zero here, so it is not set erroneously to the pointer\n \t       size later on in gimplify.c.  */\n \t    OMP_CLAUSE_SIZE (c) = size_zero_node;\n+\t  while (TREE_CODE (t) == INDIRECT_REF\n+\t\t || TREE_CODE (t) == ARRAY_REF)\n+\t    {\n+\t      t = TREE_OPERAND (t, 0);\n+\t      STRIP_NOPS (t);\n+\t      if (TREE_CODE (t) == POINTER_PLUS_EXPR)\n+\t\tt = TREE_OPERAND (t, 0);\n+\t    }\n+\t  while (TREE_CODE (t) == COMPOUND_EXPR)\n+\t    {\n+\t      t = TREE_OPERAND (t, 1);\n+\t      STRIP_NOPS (t);\n+\t    }\n \t  indir_component_ref_p = false;\n \t  if (TREE_CODE (t) == COMPONENT_REF\n-\t      && TREE_CODE (TREE_OPERAND (t, 0)) == MEM_REF)\n+\t      && (TREE_CODE (TREE_OPERAND (t, 0)) == MEM_REF\n+\t\t  || TREE_CODE (TREE_OPERAND (t, 0)) == INDIRECT_REF\n+\t\t  || TREE_CODE (TREE_OPERAND (t, 0)) == ARRAY_REF))\n \t    {\n \t      t = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n \t      indir_component_ref_p = true;\n \t      STRIP_NOPS (t);\n+\t      if (TREE_CODE (t) == POINTER_PLUS_EXPR)\n+\t\tt = TREE_OPERAND (t, 0);\n \t    }\n+\n \t  if (TREE_CODE (t) == COMPONENT_REF\n \t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE__CACHE_)\n \t    {\n@@ -15006,7 +15057,7 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t      break;\n \t\t    }\n \t\t  t = TREE_OPERAND (t, 0);\n-\t\t  if (ort == C_ORT_ACC && TREE_CODE (t) == MEM_REF)\n+\t\t  if (TREE_CODE (t) == MEM_REF)\n \t\t    {\n \t\t      if (maybe_ne (mem_ref_offset (t), 0))\n \t\t\terror_at (OMP_CLAUSE_LOCATION (c),\n@@ -15015,6 +15066,15 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t      else\n \t\t\tt = TREE_OPERAND (t, 0);\n \t\t    }\n+\t\t  while (TREE_CODE (t) == MEM_REF\n+\t\t\t || TREE_CODE (t) == INDIRECT_REF\n+\t\t\t || TREE_CODE (t) == ARRAY_REF)\n+\t\t    {\n+\t\t      t = TREE_OPERAND (t, 0);\n+\t\t      STRIP_NOPS (t);\n+\t\t      if (TREE_CODE (t) == POINTER_PLUS_EXPR)\n+\t\t\tt = TREE_OPERAND (t, 0);\n+\t\t    }\n \t\t}\n \t      if (remove)\n \t\tbreak;\n@@ -15086,7 +15146,8 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t    \"%qD appears more than once in data clauses\", t);\n \t\t  remove = true;\n \t\t}\n-\t      else if (bitmap_bit_p (&map_head, DECL_UID (t)))\n+\t      else if (bitmap_bit_p (&map_head, DECL_UID (t))\n+\t\t       && !bitmap_bit_p (&map_field_head, DECL_UID (t)))\n \t\t{\n \t\t  if (ort == C_ORT_ACC)\n \t\t    error_at (OMP_CLAUSE_LOCATION (c),"}, {"sha": "6f273bfe21fd84733b60024c36fadd5551777244", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 50, "deletions": 4, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "patch": "@@ -36406,11 +36406,22 @@ check_no_duplicate_clause (tree clauses, enum omp_clause_code code,\n    The optional ALLOW_DEREF argument is true if list items can use the deref\n    (->) operator.  */\n \n+struct omp_dim\n+{\n+  tree low_bound, length;\n+  location_t loc;\n+  bool no_colon;\n+  omp_dim (tree lb, tree len, location_t lo, bool nc)\n+    : low_bound (lb), length (len), loc (lo), no_colon (nc) {}\n+};\n+\n static tree\n cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t\t\t\ttree list, bool *colon,\n \t\t\t\tbool allow_deref = false)\n {\n+  auto_vec<omp_dim> dims;\n+  bool array_section_p;\n   cp_token *token;\n   bool saved_colon_corrects_to_scope_p = parser->colon_corrects_to_scope_p;\n   if (colon)\n@@ -36491,6 +36502,7 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t    case OMP_CLAUSE_MAP:\n \t    case OMP_CLAUSE_FROM:\n \t    case OMP_CLAUSE_TO:\n+\t    start_component_ref:\n \t      while (cp_lexer_next_token_is (parser->lexer, CPP_DOT)\n \t\t     || (allow_deref\n \t\t\t && cp_lexer_next_token_is (parser->lexer, CPP_DEREF)))\n@@ -36514,14 +36526,19 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t    case OMP_CLAUSE_REDUCTION:\n \t    case OMP_CLAUSE_IN_REDUCTION:\n \t    case OMP_CLAUSE_TASK_REDUCTION:\n+\t      array_section_p = false;\n+\t      dims.truncate (0);\n \t      while (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_SQUARE))\n \t\t{\n+\t\t  location_t loc = UNKNOWN_LOCATION;\n \t\t  tree low_bound = NULL_TREE, length = NULL_TREE;\n+\t\t  bool no_colon = false;\n \n \t\t  parser->colon_corrects_to_scope_p = false;\n \t\t  cp_lexer_consume_token (parser->lexer);\n \t\t  if (!cp_lexer_next_token_is (parser->lexer, CPP_COLON))\n \t\t    {\n+\t\t      loc = cp_lexer_peek_token (parser->lexer)->location;\n \t\t      low_bound = cp_parser_expression (parser);\n \t\t      /* Later handling is not prepared to see through these.  */\n \t\t      gcc_checking_assert (!location_wrapper_p (low_bound));\n@@ -36530,7 +36547,10 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t\t    parser->colon_corrects_to_scope_p\n \t\t      = saved_colon_corrects_to_scope_p;\n \t\t  if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_SQUARE))\n-\t\t    length = integer_one_node;\n+\t\t    {\n+\t\t      length = integer_one_node;\n+\t\t      no_colon = true;\n+\t\t    }\n \t\t  else\n \t\t    {\n \t\t      /* Look for `:'.  */\n@@ -36543,6 +36563,8 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t\t\t}\n \t\t      if (kind == OMP_CLAUSE_DEPEND || kind == OMP_CLAUSE_AFFINITY)\n \t\t\tcp_parser_commit_to_tentative_parse (parser);\n+\t\t      else\n+\t\t\tarray_section_p = true;\n \t\t      if (!cp_lexer_next_token_is (parser->lexer,\n \t\t\t\t\t\t   CPP_CLOSE_SQUARE))\n \t\t\t{\n@@ -36561,8 +36583,30 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t\t      goto skip_comma;\n \t\t    }\n \n-\t\t  decl = tree_cons (low_bound, length, decl);\n+\t\t  dims.safe_push (omp_dim (low_bound, length, loc, no_colon));\n \t\t}\n+\n+\t      if ((kind == OMP_CLAUSE_MAP\n+\t\t   || kind == OMP_CLAUSE_FROM\n+\t\t   || kind == OMP_CLAUSE_TO)\n+\t\t  && !array_section_p\n+\t\t  && (cp_lexer_next_token_is (parser->lexer, CPP_DOT)\n+\t\t      || (allow_deref\n+\t\t\t  && cp_lexer_next_token_is (parser->lexer,\n+\t\t\t\t\t\t     CPP_DEREF))))\n+\t\t{\n+\t\t  for (unsigned i = 0; i < dims.length (); i++)\n+\t\t    {\n+\t\t      gcc_assert (dims[i].length == integer_one_node);\n+\t\t      decl = build_array_ref (dims[i].loc,\n+\t\t\t\t\t      decl, dims[i].low_bound);\n+\t\t    }\n+\t\t  goto start_component_ref;\n+\t\t}\n+\t      else\n+\t\tfor (unsigned i = 0; i < dims.length (); i++)\n+\t\t  decl = tree_cons (dims[i].low_bound, dims[i].length, decl);\n+\n \t      break;\n \t    default:\n \t      break;\n@@ -40064,11 +40108,13 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t    clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_TO_DECLARE,\n \t\t\t\t\t      clauses);\n \t  else\n-\t    clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_TO, clauses);\n+\t    clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_TO, clauses,\n+\t\t\t\t\t      true);\n \t  c_name = \"to\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_FROM:\n-\t  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_FROM, clauses);\n+\t  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_FROM, clauses,\n+\t\t\t\t\t    true);\n \t  c_name = \"from\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_UNIFORM:"}, {"sha": "cdf63c15e21c75f37fdd3a32b01e713d5386beba", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 121, "deletions": 23, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "patch": "@@ -5025,6 +5025,18 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t  && TREE_CODE (TREE_OPERAND (t, 0)) == COMPONENT_REF)\n \tt = TREE_OPERAND (t, 0);\n       ret = t;\n+      while (TREE_CODE (t) == INDIRECT_REF)\n+\t{\n+\t  t = TREE_OPERAND (t, 0);\n+\t  STRIP_NOPS (t);\n+\t  if (TREE_CODE (t) == POINTER_PLUS_EXPR)\n+\t    t = TREE_OPERAND (t, 0);\n+\t}\n+      while (TREE_CODE (t) == COMPOUND_EXPR)\n+\t{\n+\t  t = TREE_OPERAND (t, 1);\n+\t  STRIP_NOPS (t);\n+\t}\n       if (TREE_CODE (t) == COMPONENT_REF\n \t  && (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n \t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TO\n@@ -5049,10 +5061,14 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t\t  return error_mark_node;\n \t\t}\n \t      t = TREE_OPERAND (t, 0);\n-\t      if (TREE_CODE (t) == INDIRECT_REF)\n+\t      while (TREE_CODE (t) == MEM_REF\n+\t\t     || TREE_CODE (t) == INDIRECT_REF\n+\t\t     || TREE_CODE (t) == ARRAY_REF)\n \t\t{\n \t\t  t = TREE_OPERAND (t, 0);\n \t\t  STRIP_NOPS (t);\n+\t\t  if (TREE_CODE (t) == POINTER_PLUS_EXPR)\n+\t\t    t = TREE_OPERAND (t, 0);\n \t\t}\n \t    }\n \t  if (REFERENCE_REF_P (t))\n@@ -5336,15 +5352,25 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t  return error_mark_node;\n \t}\n       /* If there is a pointer type anywhere but in the very first\n-\t array-section-subscript, the array section can't be contiguous.  */\n+\t array-section-subscript, the array section could be non-contiguous.  */\n       if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_AFFINITY\n \t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n \t  && TREE_CODE (TREE_CHAIN (t)) == TREE_LIST)\n \t{\n-\t  error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t    \"array section is not contiguous in %qs clause\",\n-\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n-\t  return error_mark_node;\n+\t  /* If any prior dimension has a non-one length, then deem this\n+\t     array section as non-contiguous.  */\n+\t  for (tree d = TREE_CHAIN (t); TREE_CODE (d) == TREE_LIST;\n+\t       d = TREE_CHAIN (d))\n+\t    {\n+\t      tree d_length = TREE_VALUE (d);\n+\t      if (d_length == NULL_TREE || !integer_onep (d_length))\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"array section is not contiguous in %qs clause\",\n+\t\t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t  return error_mark_node;\n+\t\t}\n+\t    }\n \t}\n     }\n   else\n@@ -5615,16 +5641,37 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n \t    default:\n \t      break;\n \t    }\n+\t  bool reference_always_pointer = true;\n \t  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t      OMP_CLAUSE_MAP);\n \t  if (TREE_CODE (t) == COMPONENT_REF)\n-\t    OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_ATTACH_DETACH);\n+\t    {\n+\t      OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_ATTACH_DETACH);\n+\n+\t      if ((ort & C_ORT_OMP_DECLARE_SIMD) == C_ORT_OMP\n+\t\t  && TYPE_REF_P (TREE_TYPE (t)))\n+\t\t{\n+\t\t  if (TREE_CODE (TREE_TYPE (TREE_TYPE (t))) == ARRAY_TYPE)\n+\t\t    OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_ALWAYS_POINTER);\n+\t\t  else\n+\t\t    t = convert_from_reference (t);\n+\n+\t\t  reference_always_pointer = false;\n+\t\t}\n+\t    }\n \t  else if (REFERENCE_REF_P (t)\n \t\t   && TREE_CODE (TREE_OPERAND (t, 0)) == COMPONENT_REF)\n \t    {\n-\t      t = TREE_OPERAND (t, 0);\n-\t      gomp_map_kind k = (ort == C_ORT_ACC) ? GOMP_MAP_ATTACH_DETACH\n-\t\t\t\t\t\t   : GOMP_MAP_ALWAYS_POINTER;\n+\t      gomp_map_kind k;\n+\t      if ((ort & C_ORT_OMP_DECLARE_SIMD) == C_ORT_OMP\n+\t\t  && TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE)\n+\t\tk = GOMP_MAP_ATTACH_DETACH;\n+\t      else\n+\t\t{\n+\t\t  t = TREE_OPERAND (t, 0);\n+\t\t  k = (ort == C_ORT_ACC\n+\t\t       ? GOMP_MAP_ATTACH_DETACH : GOMP_MAP_ALWAYS_POINTER);\n+\t\t}\n \t      OMP_CLAUSE_SET_MAP_KIND (c2, k);\n \t    }\n \t  else\n@@ -5648,8 +5695,10 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n \t  OMP_CLAUSE_SIZE (c2) = t;\n \t  OMP_CLAUSE_CHAIN (c2) = OMP_CLAUSE_CHAIN (c);\n \t  OMP_CLAUSE_CHAIN (c) = c2;\n+\n \t  ptr = OMP_CLAUSE_DECL (c2);\n-\t  if (OMP_CLAUSE_MAP_KIND (c2) != GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t  if (reference_always_pointer\n+\t      && OMP_CLAUSE_MAP_KIND (c2) != GOMP_MAP_FIRSTPRIVATE_POINTER\n \t      && TYPE_REF_P (TREE_TYPE (ptr))\n \t      && INDIRECT_TYPE_P (TREE_TYPE (TREE_TYPE (ptr))))\n \t    {\n@@ -7850,15 +7899,22 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t  if (TREE_CODE (t) == COMPONENT_REF\n \t\t      && TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n \t\t    {\n-\t\t      while (TREE_CODE (t) == COMPONENT_REF)\n-\t\t\tt = TREE_OPERAND (t, 0);\n-\t\t      if (REFERENCE_REF_P (t))\n-\t\t\tt = TREE_OPERAND (t, 0);\n-\t\t      if (TREE_CODE (t) == INDIRECT_REF)\n+\t\t      do\n \t\t\t{\n \t\t\t  t = TREE_OPERAND (t, 0);\n-\t\t\t  STRIP_NOPS (t);\n+\t\t\t  if (REFERENCE_REF_P (t))\n+\t\t\t    t = TREE_OPERAND (t, 0);\n+\t\t\t  if (TREE_CODE (t) == MEM_REF\n+\t\t\t      || TREE_CODE (t) == INDIRECT_REF)\n+\t\t\t    {\n+\t\t\t      t = TREE_OPERAND (t, 0);\n+\t\t\t      STRIP_NOPS (t);\n+\t\t\t      if (TREE_CODE (t) == POINTER_PLUS_EXPR)\n+\t\t\t\tt = TREE_OPERAND (t, 0);\n+\t\t\t    }\n \t\t\t}\n+\t\t      while (TREE_CODE (t) == COMPONENT_REF);\n+\n \t\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n \t\t\t  && OMP_CLAUSE_MAP_IMPLICIT (c)\n \t\t\t  && (bitmap_bit_p (&map_head, DECL_UID (t))\n@@ -7929,15 +7985,33 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      && TREE_CODE (TREE_OPERAND (t, 0)) == COMPONENT_REF)\n \t    {\n \t      t = TREE_OPERAND (t, 0);\n-\t      OMP_CLAUSE_DECL (c) = t;\n+\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+\t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ATTACH_DETACH)\n+\t\tOMP_CLAUSE_DECL (c) = t;\n+\t    }\n+\t  while (TREE_CODE (t) == INDIRECT_REF\n+\t\t || TREE_CODE (t) == ARRAY_REF)\n+\t    {\n+\t      t = TREE_OPERAND (t, 0);\n+\t      STRIP_NOPS (t);\n+\t      if (TREE_CODE (t) == POINTER_PLUS_EXPR)\n+\t\tt = TREE_OPERAND (t, 0);\n+\t    }\n+\t  while (TREE_CODE (t) == COMPOUND_EXPR)\n+\t    {\n+\t      t = TREE_OPERAND (t, 1);\n+\t      STRIP_NOPS (t);\n \t    }\n \t  indir_component_ref_p = false;\n \t  if (TREE_CODE (t) == COMPONENT_REF\n-\t      && TREE_CODE (TREE_OPERAND (t, 0)) == INDIRECT_REF)\n+\t      && (TREE_CODE (TREE_OPERAND (t, 0)) == INDIRECT_REF\n+\t\t  || TREE_CODE (TREE_OPERAND (t, 0)) == ARRAY_REF))\n \t    {\n \t      t = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n \t      indir_component_ref_p = true;\n \t      STRIP_NOPS (t);\n+\t      if (TREE_CODE (t) == POINTER_PLUS_EXPR)\n+\t\tt = TREE_OPERAND (t, 0);\n \t    }\n \t  if (TREE_CODE (t) == COMPONENT_REF\n \t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE__CACHE_)\n@@ -7972,6 +8046,24 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t      break;\n \t\t    }\n \t\t  t = TREE_OPERAND (t, 0);\n+\t\t  if (TREE_CODE (t) == MEM_REF)\n+\t\t    {\n+\t\t      if (maybe_ne (mem_ref_offset (t), 0))\n+\t\t\terror_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t  \"cannot dereference %qE in %qs clause\", t,\n+\t\t\t\t  omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n+\t\t      else\n+\t\t\tt = TREE_OPERAND (t, 0);\n+\t\t    }\n+\t\t  while (TREE_CODE (t) == MEM_REF\n+\t\t\t || TREE_CODE (t) == INDIRECT_REF\n+\t\t\t || TREE_CODE (t) == ARRAY_REF)\n+\t\t    {\n+\t\t      t = TREE_OPERAND (t, 0);\n+\t\t      STRIP_NOPS (t);\n+\t\t      if (TREE_CODE (t) == POINTER_PLUS_EXPR)\n+\t\t\tt = TREE_OPERAND (t, 0);\n+\t\t    }\n \t\t}\n \t      if (remove)\n \t\tbreak;\n@@ -8069,7 +8161,8 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t    \"%qD appears more than once in data clauses\", t);\n \t\t  remove = true;\n \t\t}\n-\t      else if (bitmap_bit_p (&map_head, DECL_UID (t)))\n+\t      else if (bitmap_bit_p (&map_head, DECL_UID (t))\n+\t\t       && !bitmap_bit_p (&map_field_head, DECL_UID (t)))\n \t\t{\n \t\t  if (ort == C_ORT_ACC)\n \t\t    error_at (OMP_CLAUSE_LOCATION (c),\n@@ -8116,8 +8209,13 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  else\n \t    {\n \t      bitmap_set_bit (&map_head, DECL_UID (t));\n-\t      if (t != OMP_CLAUSE_DECL (c)\n-\t\t  && TREE_CODE (OMP_CLAUSE_DECL (c)) == COMPONENT_REF)\n+\n+\t      tree decl = OMP_CLAUSE_DECL (c);\n+\t      if (t != decl\n+\t\t  && (TREE_CODE (decl) == COMPONENT_REF\n+\t\t      || (INDIRECT_REF_P (decl)\n+\t\t\t  && TREE_CODE (TREE_OPERAND (decl, 0)) == COMPONENT_REF\n+\t\t\t  && TYPE_REF_P (TREE_TYPE (TREE_OPERAND (decl, 0))))))\n \t\tbitmap_set_bit (&map_field_head, DECL_UID (t));\n \t    }\n \thandle_map_references:\n@@ -8146,7 +8244,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\t      OMP_CLAUSE_MAP);\n \t\t  if (TREE_CODE (t) == COMPONENT_REF)\n-\t\t    OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_ATTACH_DETACH);\n+\t\t    OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_ALWAYS_POINTER);\n \t\t  else\n \t\t    OMP_CLAUSE_SET_MAP_KIND (c2,\n \t\t\t\t\t     GOMP_MAP_FIRSTPRIVATE_REFERENCE);"}, {"sha": "d8229a5ac30570b9c9c9c137645d87497dfe2195", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "patch": "@@ -2460,6 +2460,9 @@ gfc_trans_omp_array_section (stmtblock_t *block, gfc_omp_namelist *n,\n \t\t\t       TREE_TYPE (TREE_TYPE (decl)),\n \t\t\t       decl, offset, NULL_TREE, NULL_TREE);\n \t  OMP_CLAUSE_DECL (node) = offset;\n+\n+\t  if (ptr_kind == GOMP_MAP_ALWAYS_POINTER)\n+\t    return;\n \t}\n       else\n \t{"}, {"sha": "b118c72f62c43d3cd67f1c6ba36e3786529acb12", "filename": "gcc/gimplify.c", "status": "modified", "additions": 187, "deletions": 33, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "patch": "@@ -8660,7 +8660,7 @@ insert_struct_comp_map (enum tree_code code, tree c, tree struct_node,\n \n static tree\n extract_base_bit_offset (tree base, tree *base_ref, poly_int64 *bitposp,\n-\t\t\t poly_offset_int *poffsetp)\n+\t\t\t poly_offset_int *poffsetp, tree *offsetp)\n {\n   tree offset;\n   poly_int64 bitsize, bitpos;\n@@ -8707,10 +8707,11 @@ extract_base_bit_offset (tree base, tree *base_ref, poly_int64 *bitposp,\n       && TREE_CODE (TREE_TYPE (TREE_OPERAND (base, 0))) == REFERENCE_TYPE)\n     base = TREE_OPERAND (base, 0);\n \n-  gcc_assert (offset == NULL_TREE || poly_int_tree_p (offset));\n-\n-  if (offset)\n-    poffset = wi::to_poly_offset (offset);\n+  if (offset && poly_int_tree_p (offset))\n+    {\n+      poffset = wi::to_poly_offset (offset);\n+      offset = NULL_TREE;\n+    }\n   else\n     poffset = 0;\n \n@@ -8719,6 +8720,7 @@ extract_base_bit_offset (tree base, tree *base_ref, poly_int64 *bitposp,\n \n   *bitposp = bitpos;\n   *poffsetp = poffset;\n+  *offsetp = offset;\n \n   /* Set *BASE_REF if BASE was a dereferenced reference variable.  */\n   if (base_ref && orig_base != base)\n@@ -8732,12 +8734,22 @@ extract_base_bit_offset (tree base, tree *base_ref, poly_int64 *bitposp,\n static bool\n is_or_contains_p (tree expr, tree base_ptr)\n {\n-  while (expr != base_ptr)\n-    if (TREE_CODE (base_ptr) == COMPONENT_REF)\n-      base_ptr = TREE_OPERAND (base_ptr, 0);\n-    else\n-      break;\n-  return expr == base_ptr;\n+  if ((TREE_CODE (expr) == INDIRECT_REF && TREE_CODE (base_ptr) == MEM_REF)\n+      || (TREE_CODE (expr) == MEM_REF && TREE_CODE (base_ptr) == INDIRECT_REF))\n+    return operand_equal_p (TREE_OPERAND (expr, 0),\n+\t\t\t    TREE_OPERAND (base_ptr, 0));\n+  while (!operand_equal_p (expr, base_ptr))\n+    {\n+      if (TREE_CODE (base_ptr) == COMPOUND_EXPR)\n+\tbase_ptr = TREE_OPERAND (base_ptr, 1);\n+      if (TREE_CODE (base_ptr) == COMPONENT_REF\n+\t  || TREE_CODE (base_ptr) == POINTER_PLUS_EXPR\n+\t  || TREE_CODE (base_ptr) == SAVE_EXPR)\n+\tbase_ptr = TREE_OPERAND (base_ptr, 0);\n+      else\n+\tbreak;\n+    }\n+  return operand_equal_p (expr, base_ptr);\n }\n \n /* Implement OpenMP 5.x map ordering rules for target directives. There are\n@@ -8817,21 +8829,107 @@ omp_target_reorder_clauses (tree *list_p)\n \t    tree base_ptr = TREE_OPERAND (decl, 0);\n \t    STRIP_TYPE_NOPS (base_ptr);\n \t    for (unsigned int j = i + 1; j < atf.length (); j++)\n-\t      {\n-\t\ttree *cp2 = atf[j];\n-\t\ttree decl2 = OMP_CLAUSE_DECL (*cp2);\n-\t\tif (is_or_contains_p (decl2, base_ptr))\n-\t\t  {\n-\t\t    /* Move *cp2 to before *cp.  */\n-\t\t    tree c = *cp2;\n-\t\t    *cp2 = OMP_CLAUSE_CHAIN (c);\n-\t\t    OMP_CLAUSE_CHAIN (c) = *cp;\n-\t\t    *cp = c;\n-\t\t    atf[j] = NULL;\n+\t      if (atf[j])\n+\t\t{\n+\t\t  tree *cp2 = atf[j];\n+\t\t  tree decl2 = OMP_CLAUSE_DECL (*cp2);\n+\n+\t\t  decl2 = OMP_CLAUSE_DECL (*cp2);\n+\t\t  if (is_or_contains_p (decl2, base_ptr))\n+\t\t    {\n+\t\t      /* Move *cp2 to before *cp.  */\n+\t\t      tree c = *cp2;\n+\t\t      *cp2 = OMP_CLAUSE_CHAIN (c);\n+\t\t      OMP_CLAUSE_CHAIN (c) = *cp;\n+\t\t      *cp = c;\n+\n+\t\t      if (*cp2 != NULL_TREE\n+\t\t\t  && OMP_CLAUSE_CODE (*cp2) == OMP_CLAUSE_MAP\n+\t\t\t  && OMP_CLAUSE_MAP_KIND (*cp2) == GOMP_MAP_ALWAYS_POINTER)\n+\t\t\t{\n+\t\t\t  tree c2 = *cp2;\n+\t\t\t  *cp2 = OMP_CLAUSE_CHAIN (c2);\n+\t\t\t  OMP_CLAUSE_CHAIN (c2) = OMP_CLAUSE_CHAIN (c);\n+\t\t\t  OMP_CLAUSE_CHAIN (c) = c2;\n+\t\t\t}\n+\n+\t\t      atf[j] = NULL;\n \t\t  }\n-\t      }\n+\t\t}\n \t  }\n       }\n+\n+  /* For attach_detach map clauses, if there is another map that maps the\n+     attached/detached pointer, make sure that map is ordered before the\n+     attach_detach.  */\n+  atf.truncate (0);\n+  for (tree *cp = list_p; *cp; cp = &OMP_CLAUSE_CHAIN (*cp))\n+    if (OMP_CLAUSE_CODE (*cp) == OMP_CLAUSE_MAP)\n+      {\n+\t/* Collect alloc, to, from, to/from clauses, and\n+\t   always_pointer/attach_detach clauses.  */\n+\tgomp_map_kind k = OMP_CLAUSE_MAP_KIND (*cp);\n+\tif (k == GOMP_MAP_ALLOC\n+\t    || k == GOMP_MAP_TO\n+\t    || k == GOMP_MAP_FROM\n+\t    || k == GOMP_MAP_TOFROM\n+\t    || k == GOMP_MAP_ALWAYS_TO\n+\t    || k == GOMP_MAP_ALWAYS_FROM\n+\t    || k == GOMP_MAP_ALWAYS_TOFROM\n+\t    || k == GOMP_MAP_ATTACH_DETACH\n+\t    || k == GOMP_MAP_ALWAYS_POINTER)\n+\t  atf.safe_push (cp);\n+      }\n+\n+  for (unsigned int i = 0; i < atf.length (); i++)\n+    if (atf[i])\n+      {\n+\ttree *cp = atf[i];\n+\ttree ptr = OMP_CLAUSE_DECL (*cp);\n+\tSTRIP_TYPE_NOPS (ptr);\n+\tif (OMP_CLAUSE_MAP_KIND (*cp) == GOMP_MAP_ATTACH_DETACH)\n+\t  for (unsigned int j = i + 1; j < atf.length (); j++)\n+\t    {\n+\t      tree *cp2 = atf[j];\n+\t      tree decl2 = OMP_CLAUSE_DECL (*cp2);\n+\t      if (OMP_CLAUSE_MAP_KIND (*cp2) != GOMP_MAP_ATTACH_DETACH\n+\t\t  && OMP_CLAUSE_MAP_KIND (*cp2) != GOMP_MAP_ALWAYS_POINTER\n+\t\t  && is_or_contains_p (decl2, ptr))\n+\t\t{\n+\t\t  /* Move *cp2 to before *cp.  */\n+\t\t  tree c = *cp2;\n+\t\t  *cp2 = OMP_CLAUSE_CHAIN (c);\n+\t\t  OMP_CLAUSE_CHAIN (c) = *cp;\n+\t\t  *cp = c;\n+\t\t  atf[j] = NULL;\n+\n+\t\t  /* If decl2 is of the form '*decl2_opnd0', and followed by an\n+\t\t     ALWAYS_POINTER or ATTACH_DETACH of 'decl2_opnd0', move the\n+\t\t     pointer operation along with *cp2. This can happen for C++\n+\t\t     reference sequences.  */\n+\t\t  if (j + 1 < atf.length ()\n+\t\t      && (TREE_CODE (decl2) == INDIRECT_REF\n+\t\t\t  || TREE_CODE (decl2) == MEM_REF))\n+\t\t    {\n+\t\t      tree *cp3 = atf[j + 1];\n+\t\t      tree decl3 = OMP_CLAUSE_DECL (*cp3);\n+\t\t      tree decl2_opnd0 = TREE_OPERAND (decl2, 0);\n+\t\t      if ((OMP_CLAUSE_MAP_KIND (*cp3) == GOMP_MAP_ALWAYS_POINTER\n+\t\t\t   || OMP_CLAUSE_MAP_KIND (*cp3) == GOMP_MAP_ATTACH_DETACH)\n+\t\t\t  && operand_equal_p (decl3, decl2_opnd0))\n+\t\t\t{\n+\t\t\t  /* Also move *cp3 to before *cp.  */\n+\t\t\t  c = *cp3;\n+\t\t\t  *cp2 = OMP_CLAUSE_CHAIN (c);\n+\t\t\t  OMP_CLAUSE_CHAIN (c) = *cp;\n+\t\t\t  *cp = c;\n+\t\t\t  atf[j + 1] = NULL;\n+\t\t\t  j += 1;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+      }\n }\n \n /* DECL is supposed to have lastprivate semantics in the outer contexts\n@@ -8923,6 +9021,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n   struct gimplify_omp_ctx *ctx, *outer_ctx;\n   tree c;\n   hash_map<tree_operand_hash, tree> *struct_map_to_clause = NULL;\n+  hash_map<tree_operand_hash, tree *> *struct_seen_clause = NULL;\n   hash_set<tree> *struct_deref_set = NULL;\n   tree *prev_list_p = NULL, *orig_list_p = list_p;\n   int handled_depend_iterators = -1;\n@@ -9398,6 +9497,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t}\n \t      bool indir_p = false;\n \t      bool component_ref_p = false;\n+\t      tree indir_base = NULL_TREE;\n \t      tree orig_decl = decl;\n \t      tree decl_ref = NULL_TREE;\n \t      if ((region_type & (ORT_ACC | ORT_TARGET | ORT_TARGET_DATA)) != 0\n@@ -9416,6 +9516,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t      == POINTER_TYPE))\n \t\t\t{\n \t\t\t  indir_p = true;\n+\t\t\t  indir_base = decl;\n \t\t\t  decl = TREE_OPERAND (decl, 0);\n \t\t\t  STRIP_NOPS (decl);\n \t\t\t}\n@@ -9462,7 +9563,9 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t       != GOMP_MAP_POINTER)\n \t\t\t   || OMP_CLAUSE_DECL (next_clause) != decl)\n \t\t      && (!struct_deref_set\n-\t\t\t  || !struct_deref_set->contains (decl)))\n+\t\t\t  || !struct_deref_set->contains (decl))\n+\t\t      && (!struct_map_to_clause\n+\t\t\t  || !struct_map_to_clause->get (indir_base)))\n \t\t    {\n \t\t      if (!struct_deref_set)\n \t\t\tstruct_deref_set = new hash_set<tree> ();\n@@ -9506,7 +9609,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t      if ((DECL_P (decl)\n \t\t   || (component_ref_p\n \t\t       && (INDIRECT_REF_P (decl)\n-\t\t\t   || TREE_CODE (decl) == MEM_REF)))\n+\t\t\t   || TREE_CODE (decl) == MEM_REF\n+\t\t\t   || TREE_CODE (decl) == ARRAY_REF)))\n \t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_TO_PSET\n \t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ATTACH\n \t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_DETACH\n@@ -9541,7 +9645,15 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t  remove = true;\n \t\t\t  break;\n \t\t\t}\n-\t\t      if (OMP_CLAUSE_CHAIN (*prev_list_p) != c)\n+\n+\t\t      /* The below prev_list_p based error recovery code is\n+\t\t\t currently no longer valid for OpenMP.  */\n+\t\t      if (code != OMP_TARGET\n+\t\t\t  && code != OMP_TARGET_DATA\n+\t\t\t  && code != OMP_TARGET_UPDATE\n+\t\t\t  && code != OMP_TARGET_ENTER_DATA\n+\t\t\t  && code != OMP_TARGET_EXIT_DATA\n+\t\t\t  && OMP_CLAUSE_CHAIN (*prev_list_p) != c)\n \t\t\t{\n \t\t\t  tree ch = OMP_CLAUSE_CHAIN (*prev_list_p);\n \t\t\t  if (ch == NULL_TREE || OMP_CLAUSE_CHAIN (ch) != c)\n@@ -9554,13 +9666,15 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \n \t\t  poly_offset_int offset1;\n \t\t  poly_int64 bitpos1;\n+\t\t  tree tree_offset1;\n \t\t  tree base_ref;\n \n \t\t  tree base\n \t\t    = extract_base_bit_offset (OMP_CLAUSE_DECL (c), &base_ref,\n-\t\t\t\t\t       &bitpos1, &offset1);\n+\t\t\t\t\t       &bitpos1, &offset1,\n+\t\t\t\t\t       &tree_offset1);\n \n-\t\t  gcc_assert (base == decl);\n+\t\t  bool do_map_struct = (base == decl && !tree_offset1);\n \n \t\t  splay_tree_node n\n \t\t    = (DECL_P (decl)\n@@ -9592,6 +9706,32 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t      OMP_CLAUSE_SET_MAP_KIND (c, k);\n \t\t      has_attachments = true;\n \t\t    }\n+\n+\t\t  /* We currently don't handle non-constant offset accesses wrt to\n+\t\t     GOMP_MAP_STRUCT elements.  */\n+\t\t  if (!do_map_struct)\n+\t\t    goto skip_map_struct;\n+\n+\t\t  /* Nor for attach_detach for OpenMP.  */\n+\t\t  if ((code == OMP_TARGET\n+\t\t       || code == OMP_TARGET_DATA\n+\t\t       || code == OMP_TARGET_UPDATE\n+\t\t       || code == OMP_TARGET_ENTER_DATA\n+\t\t       || code == OMP_TARGET_EXIT_DATA)\n+\t\t      && attach_detach)\n+\t\t    {\n+\t\t      if (DECL_P (decl))\n+\t\t\t{\n+\t\t\t  if (struct_seen_clause == NULL)\n+\t\t\t    struct_seen_clause\n+\t\t\t      = new hash_map<tree_operand_hash, tree *>;\n+\t\t\t  if (!struct_seen_clause->get (decl))\n+\t\t\t    struct_seen_clause->put (decl, list_p);\n+\t\t\t}\n+\n+\t\t      goto skip_map_struct;\n+\t\t    }\n+\n \t\t  if ((DECL_P (decl)\n \t\t       && (n == NULL || (n->value & GOVD_MAP) == 0))\n \t\t      || (!DECL_P (decl)\n@@ -9631,9 +9771,14 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t      struct_map_to_clause->put (decl, l);\n \t\t      if (ptr || attach_detach)\n \t\t\t{\n-\t\t\t  insert_struct_comp_map (code, c, l, *prev_list_p,\n+\t\t\t  tree **sc = (struct_seen_clause\n+\t\t\t\t       ? struct_seen_clause->get (decl)\n+\t\t\t\t       : NULL);\n+\t\t\t  tree *insert_node_pos = sc ? *sc : prev_list_p;\n+\n+\t\t\t  insert_struct_comp_map (code, c, l, *insert_node_pos,\n \t\t\t\t\t\t  NULL);\n-\t\t\t  *prev_list_p = l;\n+\t\t\t  *insert_node_pos = l;\n \t\t\t  prev_list_p = NULL;\n \t\t\t}\n \t\t      else\n@@ -9719,9 +9864,11 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t    tree sc_decl = OMP_CLAUSE_DECL (*sc);\n \t\t\t    poly_offset_int offsetn;\n \t\t\t    poly_int64 bitposn;\n+\t\t\t    tree tree_offsetn;\n \t\t\t    tree base\n \t\t\t      = extract_base_bit_offset (sc_decl, NULL,\n-\t\t\t\t\t\t\t &bitposn, &offsetn);\n+\t\t\t\t\t\t\t &bitposn, &offsetn,\n+\t\t\t\t\t\t\t &tree_offsetn);\n \t\t\t    if (base != decl)\n \t\t\t      break;\n \t\t\t    if (scp)\n@@ -9809,16 +9956,21 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t  continue;\n \t\t\t}\n \t\t    }\n+\t\tskip_map_struct:\n+\t\t  ;\n \t\t}\n \t      else if ((code == OACC_ENTER_DATA\n \t\t\t|| code == OACC_EXIT_DATA\n \t\t\t|| code == OACC_DATA\n \t\t\t|| code == OACC_PARALLEL\n \t\t\t|| code == OACC_KERNELS\n-\t\t\t|| code == OACC_SERIAL)\n+\t\t\t|| code == OACC_SERIAL\n+\t\t\t|| code == OMP_TARGET_ENTER_DATA\n+\t\t\t|| code == OMP_TARGET_EXIT_DATA)\n \t\t       && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH_DETACH)\n \t\t{\n-\t\t  gomp_map_kind k = (code == OACC_EXIT_DATA\n+\t\t  gomp_map_kind k = ((code == OACC_EXIT_DATA\n+\t\t\t\t      || code == OMP_TARGET_EXIT_DATA)\n \t\t\t\t     ? GOMP_MAP_DETACH : GOMP_MAP_ATTACH);\n \t\t  OMP_CLAUSE_SET_MAP_KIND (c, k);\n \t\t}\n@@ -10650,6 +10802,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \n   ctx->clauses = *orig_list_p;\n   gimplify_omp_ctxp = ctx;\n+  if (struct_seen_clause)\n+    delete struct_seen_clause;\n   if (struct_map_to_clause)\n     delete struct_map_to_clause;\n   if (struct_deref_set)"}, {"sha": "4247607b61c3777b91845ed952835fbcb5efeb5d", "filename": "gcc/testsuite/c-c++-common/goacc/deep-copy-arrayofstruct.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdeep-copy-arrayofstruct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdeep-copy-arrayofstruct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdeep-copy-arrayofstruct.c?ref=6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "patch": "@@ -37,13 +37,12 @@ int main(int argc, char* argv[])\n     {\n       int j, k;\n       for (k = 0; k < S; k++)\n-#pragma acc parallel loop copy(m[k].a[0:N]) /* { dg-error \"expected .\\\\\\). before .\\\\\\.. token\" } */\n+#pragma acc parallel loop copy(m[k].a[0:N])\n         for (j = 0; j < N; j++)\n           m[k].a[j]++;\n \n       for (k = 0; k < S; k++)\n-#pragma acc parallel loop copy(m[k].b[0:N], m[k].c[5:N-10]) /* { dg-error \"expected .\\\\\\). before .\\\\\\.. token\" } */\n-\t/* { dg-error \".m. appears more than once in data clauses\" \"\" { target c++ } .-1 } */\n+#pragma acc parallel loop copy(m[k].b[0:N], m[k].c[5:N-10])\n \tfor (j = 0; j < N; j++)\n \t  {\n \t    m[k].b[j]++;"}, {"sha": "ce766d29e2dc245cffde13c5a771e14d6c365c0e", "filename": "gcc/testsuite/c-c++-common/gomp/target-enter-data-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-enter-data-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-enter-data-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-enter-data-1.c?ref=6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+struct bar\n+{\n+  int num_vectors;\n+  double *vectors;\n+};\n+\n+struct foo\n+{\n+  int num_vectors;\n+  struct bar *bars;\n+  double **vectors;\n+};\n+\n+void func (struct foo *f, int n, int m)\n+{\n+  #pragma omp target enter data map (to: f->vectors[m][:n])\n+  #pragma omp target enter data map (to: f->bars[n].vectors[:m])\n+  #pragma omp target enter data map (to: f->bars[n].vectors[:f->bars[n].num_vectors])\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"map\\\\(to:\\\\*_\\[0-9\\]+ \\\\\\[len: _\\[0-9\\]+\\\\\\]\\\\) map\\\\(attach:\\[^-\\]+->vectors \\\\\\[bias: \\[^\\]\\]+\\\\\\]\\\\)\" 3 \"gimple\" } } */"}, {"sha": "3aa1a8fc55ecc5868974496cc940b941846984f0", "filename": "gcc/testsuite/c-c++-common/gomp/target-implicit-map-2.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-implicit-map-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-implicit-map-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-implicit-map-2.c?ref=6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdump-tree-gimple\" } */\n+#include <stdlib.h>\n+\n+#define N 10\n+\n+struct S\n+{\n+  int a, b;\n+  int *ptr;\n+  int c, d;\n+};\n+\n+int\n+main (void)\n+{\n+  struct S a;\n+  a.ptr = (int *) malloc (sizeof (int) * N);\n+\n+  for (int i = 0; i < N; i++)\n+    a.ptr[i] = 0;\n+\n+  #pragma omp target enter data map(to: a.ptr, a.ptr[:N])\n+\n+  #pragma omp target\n+  for (int i = 0; i < N; i++)\n+    a.ptr[i] += 1;\n+\n+  #pragma omp target update from(a.ptr[:N])\n+\n+  for (int i = 0; i < N; i++)\n+    if (a.ptr[i] != 1)\n+      abort ();\n+\n+  #pragma omp target map(a.ptr[:N])\n+  for (int i = 0; i < N; i++)\n+    a.ptr[i] += 1;\n+\n+  #pragma omp target update from(a.ptr[:N])\n+\n+  for (int i = 0; i < N; i++)\n+    if (a.ptr[i] != 2)\n+      abort ();\n+\n+  #pragma omp target exit data map(from:a.ptr, a.ptr[:N])\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* map\\(tofrom:a \\[len: [0-9]+\\]\\[implicit\\]\\)} \"gimple\" } } */\n+\n+/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* map\\(tofrom:a \\[len: [0-9]+\\]\\[implicit\\]\\) map\\(tofrom:\\*_[0-9]+ \\[len: [0-9]+\\]\\) map\\(attach:a\\.ptr \\[bias: 0\\]\\)} \"gimple\" } } */"}, {"sha": "040acbfb7ed830b5439c7b70b6ea5529bf188bf0", "filename": "libgomp/target.c", "status": "modified", "additions": 88, "deletions": 21, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "patch": "@@ -581,11 +581,30 @@ gomp_map_vars_existing (struct gomp_device_descr *devicep,\n \t address/length adjustment is a TODO.  */\n       assert (!implicit_subset);\n \n-      gomp_copy_host2dev (devicep, aq,\n-\t\t\t  (void *) (oldn->tgt->tgt_start + oldn->tgt_offset\n-\t\t\t\t    + newn->host_start - oldn->host_start),\n-\t\t\t  (void *) newn->host_start,\n-\t\t\t  newn->host_end - newn->host_start, false, cbuf);\n+      if (oldn->aux && oldn->aux->attach_count)\n+\t{\n+\t  /* We have to be careful not to overwrite still attached pointers\n+\t     during the copyback to host.  */\n+\t  uintptr_t addr = newn->host_start;\n+\t  while (addr < newn->host_end)\n+\t    {\n+\t      size_t i = (addr - oldn->host_start) / sizeof (void *);\n+\t      if (oldn->aux->attach_count[i] == 0)\n+\t\tgomp_copy_host2dev (devicep, aq,\n+\t\t\t\t    (void *) (oldn->tgt->tgt_start\n+\t\t\t\t\t      + oldn->tgt_offset\n+\t\t\t\t\t      + addr - oldn->host_start),\n+\t\t\t\t    (void *) addr,\n+\t\t\t\t    sizeof (void *), false, cbuf);\n+\t      addr += sizeof (void *);\n+\t    }\n+\t}\n+      else\n+\tgomp_copy_host2dev (devicep, aq,\n+\t\t\t    (void *) (oldn->tgt->tgt_start + oldn->tgt_offset\n+\t\t\t\t      + newn->host_start - oldn->host_start),\n+\t\t\t    (void *) newn->host_start,\n+\t\t\t    newn->host_end - newn->host_start, false, cbuf);\n     }\n \n   gomp_increment_refcount (oldn, refcount_set);\n@@ -2009,17 +2028,45 @@ gomp_update (struct gomp_device_descr *devicep, size_t mapnum, void **hostaddrs,\n \t\t\t    (void *) n->host_end);\n \t      }\n \n-\n-\t    void *hostaddr = (void *) cur_node.host_start;\n-\t    void *devaddr = (void *) (n->tgt->tgt_start + n->tgt_offset\n-\t\t\t\t      + cur_node.host_start - n->host_start);\n-\t    size_t size = cur_node.host_end - cur_node.host_start;\n-\n-\t    if (GOMP_MAP_COPY_TO_P (kind & typemask))\n-\t      gomp_copy_host2dev (devicep, NULL, devaddr, hostaddr, size,\n-\t\t\t\t  false, NULL);\n-\t    if (GOMP_MAP_COPY_FROM_P (kind & typemask))\n-\t      gomp_copy_dev2host (devicep, NULL, hostaddr, devaddr, size);\n+\t    if (n->aux && n->aux->attach_count)\n+\t      {\n+\t\tuintptr_t addr = cur_node.host_start;\n+\t\twhile (addr < cur_node.host_end)\n+\t\t  {\n+\t\t    /* We have to be careful not to overwrite still attached\n+\t\t       pointers during host<->device updates.  */\n+\t\t    size_t i = (addr - cur_node.host_start) / sizeof (void *);\n+\t\t    if (n->aux->attach_count[i] == 0)\n+\t\t      {\n+\t\t\tvoid *devaddr = (void *) (n->tgt->tgt_start\n+\t\t\t\t\t\t  + n->tgt_offset\n+\t\t\t\t\t\t  + addr - n->host_start);\n+\t\t\tif (GOMP_MAP_COPY_TO_P (kind & typemask))\n+\t\t\t  gomp_copy_host2dev (devicep, NULL,\n+\t\t\t\t\t      devaddr, (void *) addr,\n+\t\t\t\t\t      sizeof (void *), false, NULL);\n+\t\t\tif (GOMP_MAP_COPY_FROM_P (kind & typemask))\n+\t\t\t  gomp_copy_dev2host (devicep, NULL,\n+\t\t\t\t\t      (void *) addr, devaddr,\n+\t\t\t\t\t      sizeof (void *));\n+\t\t      }\n+\t\t    addr += sizeof (void *);\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\tvoid *hostaddr = (void *) cur_node.host_start;\n+\t\tvoid *devaddr = (void *) (n->tgt->tgt_start + n->tgt_offset\n+\t\t\t\t\t  + cur_node.host_start\n+\t\t\t\t\t  - n->host_start);\n+\t\tsize_t size = cur_node.host_end - cur_node.host_start;\n+\n+\t\tif (GOMP_MAP_COPY_TO_P (kind & typemask))\n+\t\t  gomp_copy_host2dev (devicep, NULL, devaddr, hostaddr, size,\n+\t\t\t\t      false, NULL);\n+\t\tif (GOMP_MAP_COPY_FROM_P (kind & typemask))\n+\t\t  gomp_copy_dev2host (devicep, NULL, hostaddr, devaddr, size);\n+\t      }\n \t  }\n       }\n   gomp_mutex_unlock (&devicep->lock);\n@@ -2932,11 +2979,31 @@ gomp_exit_data (struct gomp_device_descr *devicep, size_t mapnum,\n \n \t  if ((kind == GOMP_MAP_FROM && do_copy)\n \t      || kind == GOMP_MAP_ALWAYS_FROM)\n-\t    gomp_copy_dev2host (devicep, NULL, (void *) cur_node.host_start,\n-\t\t\t\t(void *) (k->tgt->tgt_start + k->tgt_offset\n-\t\t\t\t\t  + cur_node.host_start\n-\t\t\t\t\t  - k->host_start),\n-\t\t\t\tcur_node.host_end - cur_node.host_start);\n+\t    {\n+\t      if (k->aux && k->aux->attach_count)\n+\t\t{\n+\t\t  /* We have to be careful not to overwrite still attached\n+\t\t     pointers during the copyback to host.  */\n+\t\t  uintptr_t addr = k->host_start;\n+\t\t  while (addr < k->host_end)\n+\t\t    {\n+\t\t      size_t i = (addr - k->host_start) / sizeof (void *);\n+\t\t      if (k->aux->attach_count[i] == 0)\n+\t\t\tgomp_copy_dev2host (devicep, NULL, (void *) addr,\n+\t\t\t\t\t    (void *) (k->tgt->tgt_start\n+\t\t\t\t\t\t      + k->tgt_offset\n+\t\t\t\t\t\t      + addr - k->host_start),\n+\t\t\t\t\t    sizeof (void *));\n+\t\t      addr += sizeof (void *);\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tgomp_copy_dev2host (devicep, NULL, (void *) cur_node.host_start,\n+\t\t\t\t    (void *) (k->tgt->tgt_start + k->tgt_offset\n+\t\t\t\t\t      + cur_node.host_start\n+\t\t\t\t\t      - k->host_start),\n+\t\t\t\t    cur_node.host_end - cur_node.host_start);\n+\t    }\n \n \t  /* Structure elements lists are removed altogether at once, which\n \t     may cause immediate deallocation of the target_mem_desc, causing"}, {"sha": "87c2980b4b5bfe603779e7b617f69bc6f7b806d5", "filename": "libgomp/testsuite/libgomp.c++/target-11.C", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-11.C?ref=6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "patch": "@@ -23,9 +23,11 @@ foo ()\n   e = c + 18;\n   D s = { a, b + 2, { 0, a + 16, 0, d }, c + 3, e };\n   int err = 0;\n-  #pragma omp target map (to:s.v.b[0:z + 7], s.template u[z + 1:z + 4]) \\\n-\t\t     map (tofrom:s.s[3:3], s. template v. template d[z + 1:z + 3]) \\\n-\t\t     map (from: s.w[z:4], s.x[1:3], err) private (i)\n+  #pragma omp target map (to: s.v.b, s.v.b[0:z + 7])\t\t\t\\\n+\t\t     map (s.template u, s.template u[z + 1:z + 4])\t\\\n+\t\t     map (tofrom: s.s, s.s[3:3])\t\t\t\\\n+\t\t     map (tofrom: s. template v. template d[z + 1:z + 3])\\\n+\t\t     map (from: s.w, s.w[z:4], s.x, s.x[1:3], err) private (i)\n   {\n     err = 0;\n     for (i = 0; i < 7; i++)\n@@ -80,9 +82,9 @@ main ()\n   e = c + 18;\n   S s = { a, b + 2, { 0, a + 16, 0, d }, c + 3, e };\n   int err = 0;\n-  #pragma omp target map (to:s.v.b[0:z + 7], s.u[z + 1:z + 4]) \\\n-\t\t     map (tofrom:s.s[3:3], s.v.d[z + 1:z + 3]) \\\n-\t\t     map (from: s.w[z:4], s.x[1:3], err) private (i)\n+  #pragma omp target map (to: s.v.b, s.v.b[0:z + 7], s.u, s.u[z + 1:z + 4]) \\\n+\t\t     map (tofrom: s.s, s.s[3:3], s.v.d[z + 1:z + 3])\t\t\\\n+\t\t     map (from: s.w, s.w[z:4], s.x, s.x[1:3], err) private (i)\n   {\n     err = 0;\n     for (i = 0; i < 7; i++)"}, {"sha": "480e479c26295a1612c08bd7fed740dbf68497e9", "filename": "libgomp/testsuite/libgomp.c++/target-12.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-12.C?ref=6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "patch": "@@ -53,7 +53,7 @@ main ()\n   int u[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }, err = 0;\n   S s = { 9, u + 3, { 10, 11, 12, 13, 14 } };\n   int *v = u + 4;\n-  #pragma omp target enter data map (to: s.s, s.u[0:5]) map (alloc: s.v[1:3])\n+  #pragma omp target enter data map (to: s.s, s.u, s.u[0:5]) map (alloc: s.v[1:3])\n   s.s++;\n   u[3]++;\n   s.v[1]++;"}, {"sha": "53626b2547ec2e36c665f94c985126de531020a6", "filename": "libgomp/testsuite/libgomp.c++/target-15.C", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-15.C?ref=6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "patch": "@@ -14,7 +14,7 @@ foo (S s)\n     d = id;\n \n   int err;\n-  #pragma omp target map(tofrom: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3]) map(to: sep) map(from: err)\n+  #pragma omp target map(tofrom: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3]) map(to: sep) map(from: err)\n   {\n     err = s.a != 11 || s.b[0] != 12 || s.b[1] != 13;\n     err |= s.c[1] != 15 || s.c[2] != 16 || s.d[-2] != 18 || s.d[-1] != 19 || s.d[0] != 20;\n@@ -48,7 +48,7 @@ foo (S s)\n \t  || omp_target_is_present (&s.h, d)\n \t  || omp_target_is_present (&s.h[2], d)))\n     abort ();\n-  #pragma omp target data map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  #pragma omp target data map(alloc: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3])\n   {\n     if (!omp_target_is_present (&s.a, d)\n \t|| !omp_target_is_present (s.b, d)\n@@ -61,8 +61,8 @@ foo (S s)\n \t|| !omp_target_is_present (&s.h, d)\n \t|| !omp_target_is_present (&s.h[2], d))\n       abort ();\n-    #pragma omp target update to(s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n-    #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3]) map(from: err)\n+    #pragma omp target update to(s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3])\n+    #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3]) map(from: err)\n     {\n       err = s.a != 50 || s.b[0] != 49 || s.b[1] != 48;\n       err |= s.c[1] != 47 || s.c[2] != 46 || s.d[-2] != 45 || s.d[-1] != 44 || s.d[0] != 43;\n@@ -73,7 +73,7 @@ foo (S s)\n       s.e = 25; s.f[0] = 26; s.f[1] = 27; s.g[1] = 28; s.g[2] = 29;\n       s.h[2] = 30; s.h[3] = 31; s.h[4] = 32;\n     }\n-    #pragma omp target update from(s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+    #pragma omp target update from(s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3])\n   }\n   if (sep\n       && (omp_target_is_present (&s.a, d)\n@@ -97,7 +97,7 @@ foo (S s)\n   s.c[1] = 36; s.c[2] = 37; s.d[-2] = 38; s.d[-1] = 39; s.d[0] = 40;\n   s.e = 41; s.f[0] = 42; s.f[1] = 43; s.g[1] = 44; s.g[2] = 45;\n   s.h[2] = 46; s.h[3] = 47; s.h[4] = 48;\n-  #pragma omp target enter data map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  #pragma omp target enter data map(alloc: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3])\n   if (!omp_target_is_present (&s.a, d)\n       || !omp_target_is_present (s.b, d)\n       || !omp_target_is_present (&s.c[1], d)\n@@ -109,8 +109,8 @@ foo (S s)\n       || !omp_target_is_present (&s.h, d)\n       || !omp_target_is_present (&s.h[2], d))\n     abort ();\n-  #pragma omp target enter data map(always, to: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n-  #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3]) map(from: err)\n+  #pragma omp target enter data map(always, to: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3])\n+  #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3]) map(from: err)\n   {\n     err = s.a != 33 || s.b[0] != 34 || s.b[1] != 35;\n     err |= s.c[1] != 36 || s.c[2] != 37 || s.d[-2] != 38 || s.d[-1] != 39 || s.d[0] != 40;\n@@ -121,7 +121,7 @@ foo (S s)\n     s.e = 31; s.f[0] = 40; s.f[1] = 39; s.g[1] = 38; s.g[2] = 37;\n     s.h[2] = 36; s.h[3] = 35; s.h[4] = 34;\n   }\n-  #pragma omp target exit data map(always, from: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  #pragma omp target exit data map(always, from: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3])\n   if (!omp_target_is_present (&s.a, d)\n       || !omp_target_is_present (s.b, d)\n       || !omp_target_is_present (&s.c[1], d)\n@@ -133,7 +133,7 @@ foo (S s)\n       || !omp_target_is_present (&s.h, d)\n       || !omp_target_is_present (&s.h[2], d))\n     abort ();\n-  #pragma omp target exit data map(release: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  #pragma omp target exit data map(release: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3])\n   if (sep\n       && (omp_target_is_present (&s.a, d)\n \t  || omp_target_is_present (s.b, d)"}, {"sha": "b8be7cc922f587fdf32992b90cf084bd8ee56e5f", "filename": "libgomp/testsuite/libgomp.c++/target-16.C", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-16.C?ref=6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "patch": "@@ -16,7 +16,7 @@ foo (S<C, I, L, UC, SH> s)\n     d = id;\n \n   int err;\n-  #pragma omp target map(tofrom: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3]) map(to: sep) map(from: err)\n+  #pragma omp target map(tofrom: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3]) map(to: sep) map(from: err)\n   {\n     err = s.a != 11 || s.b[0] != 12 || s.b[1] != 13;\n     err |= s.c[1] != 15 || s.c[2] != 16 || s.d[-2] != 18 || s.d[-1] != 19 || s.d[0] != 20;\n@@ -50,7 +50,7 @@ foo (S<C, I, L, UC, SH> s)\n \t  || omp_target_is_present (&s.h, d)\n \t  || omp_target_is_present (&s.h[2], d)))\n     abort ();\n-  #pragma omp target data map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  #pragma omp target data map(alloc: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3])\n   {\n     if (!omp_target_is_present (&s.a, d)\n \t|| !omp_target_is_present (s.b, d)\n@@ -63,8 +63,8 @@ foo (S<C, I, L, UC, SH> s)\n \t|| !omp_target_is_present (&s.h, d)\n \t|| !omp_target_is_present (&s.h[2], d))\n       abort ();\n-    #pragma omp target update to(s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n-    #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3]) map(from: err)\n+    #pragma omp target update to(s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3])\n+    #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3]) map(from: err)\n     {\n       err = s.a != 50 || s.b[0] != 49 || s.b[1] != 48;\n       err |= s.c[1] != 47 || s.c[2] != 46 || s.d[-2] != 45 || s.d[-1] != 44 || s.d[0] != 43;\n@@ -75,7 +75,7 @@ foo (S<C, I, L, UC, SH> s)\n       s.e = 25; s.f[0] = 26; s.f[1] = 27; s.g[1] = 28; s.g[2] = 29;\n       s.h[2] = 30; s.h[3] = 31; s.h[4] = 32;\n     }\n-    #pragma omp target update from(s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+    #pragma omp target update from(s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3])\n   }\n   if (sep\n       && (omp_target_is_present (&s.a, d)\n@@ -99,7 +99,7 @@ foo (S<C, I, L, UC, SH> s)\n   s.c[1] = 36; s.c[2] = 37; s.d[-2] = 38; s.d[-1] = 39; s.d[0] = 40;\n   s.e = 41; s.f[0] = 42; s.f[1] = 43; s.g[1] = 44; s.g[2] = 45;\n   s.h[2] = 46; s.h[3] = 47; s.h[4] = 48;\n-  #pragma omp target enter data map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  #pragma omp target enter data map(alloc: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3])\n   if (!omp_target_is_present (&s.a, d)\n       || !omp_target_is_present (s.b, d)\n       || !omp_target_is_present (&s.c[1], d)\n@@ -111,8 +111,8 @@ foo (S<C, I, L, UC, SH> s)\n       || !omp_target_is_present (&s.h, d)\n       || !omp_target_is_present (&s.h[2], d))\n     abort ();\n-  #pragma omp target enter data map(always, to: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n-  #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3]) map(from: err)\n+  #pragma omp target enter data map(always, to: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3])\n+  #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3]) map(from: err)\n   {\n     err = s.a != 33 || s.b[0] != 34 || s.b[1] != 35;\n     err |= s.c[1] != 36 || s.c[2] != 37 || s.d[-2] != 38 || s.d[-1] != 39 || s.d[0] != 40;\n@@ -123,7 +123,7 @@ foo (S<C, I, L, UC, SH> s)\n     s.e = 31; s.f[0] = 40; s.f[1] = 39; s.g[1] = 38; s.g[2] = 37;\n     s.h[2] = 36; s.h[3] = 35; s.h[4] = 34;\n   }\n-  #pragma omp target exit data map(always, from: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  #pragma omp target exit data map(always, from: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3])\n   if (!omp_target_is_present (&s.a, d)\n       || !omp_target_is_present (s.b, d)\n       || !omp_target_is_present (&s.c[1], d)\n@@ -135,7 +135,7 @@ foo (S<C, I, L, UC, SH> s)\n       || !omp_target_is_present (&s.h, d)\n       || !omp_target_is_present (&s.h[2], d))\n     abort ();\n-  #pragma omp target exit data map(release: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  #pragma omp target exit data map(release: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3])\n   if (sep\n       && (omp_target_is_present (&s.a, d)\n \t  || omp_target_is_present (s.b, d)"}, {"sha": "f97476aafc4b7c72ffedfef691e1f170d7db7714", "filename": "libgomp/testsuite/libgomp.c++/target-17.C", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-17.C?ref=6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "patch": "@@ -16,7 +16,7 @@ foo (S<C, I, L, UCR, CAR, SH, IPR> s)\n     d = id;\n \n   int err;\n-  #pragma omp target map(tofrom: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3]) map(to: sep) map(from: err)\n+  #pragma omp target map(tofrom: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3]) map(to: sep) map(from: err)\n   {\n     err = s.a != 11 || s.b[0] != 12 || s.b[1] != 13;\n     err |= s.c[1] != 15 || s.c[2] != 16 || s.d[-2] != 18 || s.d[-1] != 19 || s.d[0] != 20;\n@@ -50,7 +50,7 @@ foo (S<C, I, L, UCR, CAR, SH, IPR> s)\n \t  || omp_target_is_present (&s.h, d)\n \t  || omp_target_is_present (&s.h[2], d)))\n     abort ();\n-  #pragma omp target data map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  #pragma omp target data map(alloc: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3])\n   {\n     if (!omp_target_is_present (&s.a, d)\n \t|| !omp_target_is_present (s.b, d)\n@@ -63,8 +63,8 @@ foo (S<C, I, L, UCR, CAR, SH, IPR> s)\n \t|| !omp_target_is_present (&s.h, d)\n \t|| !omp_target_is_present (&s.h[2], d))\n       abort ();\n-    #pragma omp target update to(s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n-    #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3]) map(from: err)\n+    #pragma omp target update to(s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3])\n+    #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3]) map(from: err)\n     {\n       err = s.a != 50 || s.b[0] != 49 || s.b[1] != 48;\n       err |= s.c[1] != 47 || s.c[2] != 46 || s.d[-2] != 45 || s.d[-1] != 44 || s.d[0] != 43;\n@@ -75,7 +75,7 @@ foo (S<C, I, L, UCR, CAR, SH, IPR> s)\n       s.e = 25; s.f[0] = 26; s.f[1] = 27; s.g[1] = 28; s.g[2] = 29;\n       s.h[2] = 30; s.h[3] = 31; s.h[4] = 32;\n     }\n-    #pragma omp target update from(s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+    #pragma omp target update from(s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3])\n   }\n   if (sep\n       && (omp_target_is_present (&s.a, d)\n@@ -99,7 +99,7 @@ foo (S<C, I, L, UCR, CAR, SH, IPR> s)\n   s.c[1] = 36; s.c[2] = 37; s.d[-2] = 38; s.d[-1] = 39; s.d[0] = 40;\n   s.e = 41; s.f[0] = 42; s.f[1] = 43; s.g[1] = 44; s.g[2] = 45;\n   s.h[2] = 46; s.h[3] = 47; s.h[4] = 48;\n-  #pragma omp target enter data map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  #pragma omp target enter data map(alloc: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3])\n   if (!omp_target_is_present (&s.a, d)\n       || !omp_target_is_present (s.b, d)\n       || !omp_target_is_present (&s.c[1], d)\n@@ -111,8 +111,8 @@ foo (S<C, I, L, UCR, CAR, SH, IPR> s)\n       || !omp_target_is_present (&s.h, d)\n       || !omp_target_is_present (&s.h[2], d))\n     abort ();\n-  #pragma omp target enter data map(always, to: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n-  #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3]) map(from: err)\n+  #pragma omp target enter data map(always, to: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3])\n+  #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3]) map(from: err)\n   {\n     err = s.a != 33 || s.b[0] != 34 || s.b[1] != 35;\n     err |= s.c[1] != 36 || s.c[2] != 37 || s.d[-2] != 38 || s.d[-1] != 39 || s.d[0] != 40;\n@@ -123,7 +123,7 @@ foo (S<C, I, L, UCR, CAR, SH, IPR> s)\n     s.e = 31; s.f[0] = 40; s.f[1] = 39; s.g[1] = 38; s.g[2] = 37;\n     s.h[2] = 36; s.h[3] = 35; s.h[4] = 34;\n   }\n-  #pragma omp target exit data map(always, from: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  #pragma omp target exit data map(always, from: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3])\n   if (!omp_target_is_present (&s.a, d)\n       || !omp_target_is_present (s.b, d)\n       || !omp_target_is_present (&s.c[1], d)\n@@ -135,7 +135,7 @@ foo (S<C, I, L, UCR, CAR, SH, IPR> s)\n       || !omp_target_is_present (&s.h, d)\n       || !omp_target_is_present (&s.h[2], d))\n     abort ();\n-  #pragma omp target exit data map(release: s.a, s.b, s.c[1:2], s.d[-2:3], s.e, s.f, s.g[1:2], s.h[2:3])\n+  #pragma omp target exit data map(release: s.a, s.b, s.c[1:2], s.d, s.d[-2:3], s.e, s.f, s.g[1:2], s.h, s.h[2:3])\n   if (sep\n       && (omp_target_is_present (&s.a, d)\n \t  || omp_target_is_present (s.b, d)"}, {"sha": "da17b5745decf5f61b6d7637f7e1ebdca2e1ab11", "filename": "libgomp/testsuite/libgomp.c++/target-21.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-21.C?ref=6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "patch": "@@ -7,7 +7,7 @@ void\n foo (S s)\n {\n   int err;\n-  #pragma omp target map (s.x[0:N], s.y[0:N]) map (s.t.t[16:3]) map (from: err)\n+  #pragma omp target map (s.x[0:N], s.y, s.y[0:N]) map (s.t.t[16:3]) map (from: err)\n   {\n     err = s.x[2] != 28 || s.y[2] != 37 || s.t.t[17] != 81;\n     s.x[2]++;\n@@ -38,7 +38,7 @@ void\n foo2 (S &s)\n {\n   int err;\n-  #pragma omp target map (s.x[N:10], s.y[N:10]) map (from: err) map (s.t.t[N+16:N+3])\n+  #pragma omp target map (s.x[N:10], s.y, s.y[N:10]) map (from: err) map (s.t.t[N+16:N+3])\n   {\n     err = s.x[2] != 30 || s.y[2] != 38 || s.t.t[17] != 81;\n     s.x[2]++;\n@@ -69,7 +69,7 @@ void\n foo3 (U s)\n {\n   int err;\n-  #pragma omp target map (s.x[0:10], s.y[0:10]) map (from: err) map (s.t.t[16:3])\n+  #pragma omp target map (s.x[0:10], s.y, s.y[0:10]) map (from: err) map (s.t.t[16:3])\n   {\n     err = s.x[2] != 32 || s.y[2] != 39 || s.t.t[17] != 82;\n     s.x[2]++;\n@@ -100,7 +100,7 @@ void\n foo4 (U &s)\n {\n   int err;\n-  #pragma omp target map (s.x[0:10], s.y[0:10]) map (from: err) map (s.t.t[16:3])\n+  #pragma omp target map (s.x[0:10], s.y, s.y[0:10]) map (from: err) map (s.t.t[16:3])\n   {\n     err = s.x[2] != 34 || s.y[2] != 40 || s.t.t[17] != 82;\n     s.x[2]++;"}, {"sha": "63d343624b0cfffd742942536511a7caa3e06d89", "filename": "libgomp/testsuite/libgomp.c++/target-23.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-23.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-23.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-23.C?ref=6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "patch": "@@ -16,13 +16,13 @@ main (void)\n     s->data[i] = 0;\n \n   #pragma omp target enter data map(to: s)\n-  #pragma omp target enter data map(to: s->data[:SZ])\n+  #pragma omp target enter data map(to: s->data, s->data[:SZ])\n   #pragma omp target\n   {\n     for (int i = 0; i < SZ; i++)\n       s->data[i] = i;\n   }\n-  #pragma omp target exit data map(from: s->data[:SZ])\n+  #pragma omp target exit data map(from: s->data, s->data[:SZ])\n   #pragma omp target exit data map(from: s)\n \n   for (int i = 0; i < SZ; i++)"}, {"sha": "974a9786c3f6f46889b2d317b6457e39a4da72e2", "filename": "libgomp/testsuite/libgomp.c-c++-common/target-implicit-map-2.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-implicit-map-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-implicit-map-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-implicit-map-2.c?ref=6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "patch": "@@ -0,0 +1,46 @@\n+#include <stdlib.h>\n+\n+#define N 10\n+\n+struct S\n+{\n+  int a, b;\n+  int *ptr;\n+  int c, d;\n+};\n+\n+int\n+main (void)\n+{\n+  struct S a;\n+  a.ptr = (int *) malloc (sizeof (int) * N);\n+\n+  for (int i = 0; i < N; i++)\n+    a.ptr[i] = 0;\n+\n+  #pragma omp target enter data map(to: a.ptr, a.ptr[:N])\n+\n+  #pragma omp target\n+  for (int i = 0; i < N; i++)\n+    a.ptr[i] += 1;\n+\n+  #pragma omp target update from(a.ptr[:N])\n+\n+  for (int i = 0; i < N; i++)\n+    if (a.ptr[i] != 1)\n+      abort ();\n+\n+  #pragma omp target map(a.ptr[:N])\n+  for (int i = 0; i < N; i++)\n+    a.ptr[i] += 1;\n+\n+  #pragma omp target update from(a.ptr[:N])\n+\n+  for (int i = 0; i < N; i++)\n+    if (a.ptr[i] != 2)\n+      abort ();\n+\n+  #pragma omp target exit data map(from:a.ptr, a.ptr[:N])\n+\n+  return 0;\n+}"}, {"sha": "d56b13acf82583015e88d8bcf7810653b023f201", "filename": "libgomp/testsuite/libgomp.c/target-23.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-23.c?ref=6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "patch": "@@ -8,7 +8,7 @@ main ()\n   int u[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }, err = 0;\n   struct S s = { 9, u + 3, { 10, 11, 12, 13, 14 } };\n   int *v = u + 4;\n-  #pragma omp target enter data map (to: s.s, s.u[0:5]) map (alloc: s.v[1:3])\n+  #pragma omp target enter data map (to: s.s, s.u, s.u[0:5]) map (alloc: s.v[1:3])\n   s.s++;\n   u[3]++;\n   s.v[1]++;"}, {"sha": "4a2866498112cf632c5397a67e313491add321f7", "filename": "libgomp/testsuite/libgomp.c/target-29.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c0399378e77d02962e5d49f7b72d6fa8ebe5e07/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-29.c?ref=6c0399378e77d02962e5d49f7b72d6fa8ebe5e07", "patch": "@@ -14,7 +14,7 @@ foo (struct S s)\n     d = id;\n \n   int err;\n-  #pragma omp target map(tofrom: s.a, s.b, s.c[1:2], s.d[-2:3]) map(to: sep) map(from: err)\n+  #pragma omp target map(tofrom: s.a, s.b, s.c[1:2], s.d, s.d[-2:3]) map(to: sep) map(from: err)\n   {\n     err = s.a != 11 || s.b[0] != 12 || s.b[1] != 13;\n     err |= s.c[1] != 15 || s.c[2] != 16 || s.d[-2] != 18 || s.d[-1] != 19 || s.d[0] != 20;\n@@ -35,23 +35,23 @@ foo (struct S s)\n \t  || omp_target_is_present (s.d, d)\n \t  || omp_target_is_present (&s.d[-2], d)))\n     abort ();\n-  #pragma omp target data map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3])\n+  #pragma omp target data map(alloc: s.a, s.b, s.c[1:2], s.d, s.d[-2:3])\n   {\n     if (!omp_target_is_present (&s.a, d)\n \t|| !omp_target_is_present (s.b, d)\n \t|| !omp_target_is_present (&s.c[1], d)\n \t|| !omp_target_is_present (s.d, d)\n \t|| !omp_target_is_present (&s.d[-2], d))\n       abort ();\n-    #pragma omp target update to(s.a, s.b, s.c[1:2], s.d[-2:3])\n-    #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3]) map(from: err)\n+    #pragma omp target update to(s.a, s.b, s.c[1:2], s.d, s.d[-2:3])\n+    #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d, s.d[-2:3]) map(from: err)\n     {\n       err = s.a != 50 || s.b[0] != 49 || s.b[1] != 48;\n       err |= s.c[1] != 47 || s.c[2] != 46 || s.d[-2] != 45 || s.d[-1] != 44 || s.d[0] != 43;\n       s.a = 17; s.b[0] = 18; s.b[1] = 19;\n       s.c[1] = 20; s.c[2] = 21; s.d[-2] = 22; s.d[-1] = 23; s.d[0] = 24;\n     }\n-    #pragma omp target update from(s.a, s.b, s.c[1:2], s.d[-2:3])\n+    #pragma omp target update from(s.a, s.b, s.c[1:2], s.d, s.d[-2:3])\n   }\n   if (sep\n       && (omp_target_is_present (&s.a, d)\n@@ -66,29 +66,29 @@ foo (struct S s)\n   if (err) abort ();\n   s.a = 33; s.b[0] = 34; s.b[1] = 35;\n   s.c[1] = 36; s.c[2] = 37; s.d[-2] = 38; s.d[-1] = 39; s.d[0] = 40;\n-  #pragma omp target enter data map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3])\n+  #pragma omp target enter data map(alloc: s.a, s.b, s.c[1:2], s.d, s.d[-2:3])\n   if (!omp_target_is_present (&s.a, d)\n       || !omp_target_is_present (s.b, d)\n       || !omp_target_is_present (&s.c[1], d)\n       || !omp_target_is_present (s.d, d)\n       || !omp_target_is_present (&s.d[-2], d))\n     abort ();\n-  #pragma omp target enter data map(always, to: s.a, s.b, s.c[1:2], s.d[-2:3])\n-  #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d[-2:3]) map(from: err)\n+  #pragma omp target enter data map(always, to: s.a, s.b, s.c[1:2], s.d, s.d[-2:3])\n+  #pragma omp target map(alloc: s.a, s.b, s.c[1:2], s.d, s.d[-2:3]) map(from: err)\n   {\n     err = s.a != 33 || s.b[0] != 34 || s.b[1] != 35;\n     err |= s.c[1] != 36 || s.c[2] != 37 || s.d[-2] != 38 || s.d[-1] != 39 || s.d[0] != 40;\n     s.a = 49; s.b[0] = 48; s.b[1] = 47;\n     s.c[1] = 46; s.c[2] = 45; s.d[-2] = 44; s.d[-1] = 43; s.d[0] = 42;\n   }\n-  #pragma omp target exit data map(always, from: s.a, s.b, s.c[1:2], s.d[-2:3])\n+  #pragma omp target exit data map(always, from: s.a, s.b, s.c[1:2], s.d, s.d[-2:3])\n   if (!omp_target_is_present (&s.a, d)\n       || !omp_target_is_present (s.b, d)\n       || !omp_target_is_present (&s.c[1], d)\n       || !omp_target_is_present (s.d, d)\n       || !omp_target_is_present (&s.d[-2], d))\n     abort ();\n-  #pragma omp target exit data map(release: s.a, s.b, s.c[1:2], s.d[-2:3])\n+  #pragma omp target exit data map(release: s.a, s.b, s.c[1:2], s.d, s.d[-2:3])\n   if (sep\n       && (omp_target_is_present (&s.a, d)\n \t  || omp_target_is_present (s.b, d)"}]}