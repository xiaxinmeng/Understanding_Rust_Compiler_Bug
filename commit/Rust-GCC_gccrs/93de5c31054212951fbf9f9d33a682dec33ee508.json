{"sha": "93de5c31054212951fbf9f9d33a682dec33ee508", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNkZTVjMzEwNTQyMTI5NTFmYmY5ZjlkMzNhNjgyZGVjMzNlZTUwOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-07-06T10:42:43Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-07-06T10:42:43Z"}, "message": "jump.c (duplicate_loop_exit_test): Don't refuse to copy a section of code just because it contains...\n\n\t* jump.c (duplicate_loop_exit_test): Don't refuse to copy a\n\tsection of code just because it contains\n\tNOTE_INSN_BLOCK_{BEG,END}.\n\t* stmt.c (expand_end_loop): Likewise.  Also, don't refuse to\n\tmove CALL_INSNs or CODE_LABELs.  When moving code, don't move\n\tNOTE_INSN_BLOCK_{BEG,END}.\n\nFrom-SVN: r20952", "tree": {"sha": "23abcf9527415695d37f8c220d258fcacd15df14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23abcf9527415695d37f8c220d258fcacd15df14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93de5c31054212951fbf9f9d33a682dec33ee508", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93de5c31054212951fbf9f9d33a682dec33ee508", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93de5c31054212951fbf9f9d33a682dec33ee508", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93de5c31054212951fbf9f9d33a682dec33ee508/comments", "author": null, "committer": null, "parents": [{"sha": "561252fd0b6b7cd09474ff374fd1599cc5f43a2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/561252fd0b6b7cd09474ff374fd1599cc5f43a2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/561252fd0b6b7cd09474ff374fd1599cc5f43a2c"}], "stats": {"total": 163, "additions": 143, "deletions": 20}, "files": [{"sha": "5898e8053b9ce467872e4d24e713ba9b42592156", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93de5c31054212951fbf9f9d33a682dec33ee508/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93de5c31054212951fbf9f9d33a682dec33ee508/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=93de5c31054212951fbf9f9d33a682dec33ee508", "patch": "@@ -1,3 +1,12 @@\n+Mon Jul  6 10:42:05 1998  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* jump.c (duplicate_loop_exit_test): Don't refuse to copy a\n+\tsection of code just because it contains\n+\tNOTE_INSN_BLOCK_{BEG,END}.\n+\t* stmt.c (expand_end_loop): Likewise.  Also, don't refuse to \n+\tmove CALL_INSNs or CODE_LABELs.  When moving code, don't move\n+\tNOTE_INSN_BLOCK_{BEG,END}.\n+\n Mon Jul  6 09:38:15 1998  Mark Mitchell  <mark@markmitchell.com>\n \n \t* cse.c (CSE_ADDRESS_COST): New macro, based on ADDRESS_COST, but "}, {"sha": "389a6ff1e6441c4c22f178068411d1a70ebe5729", "filename": "gcc/jump.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93de5c31054212951fbf9f9d33a682dec33ee508/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93de5c31054212951fbf9f9d33a682dec33ee508/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=93de5c31054212951fbf9f9d33a682dec33ee508", "patch": "@@ -2403,10 +2403,18 @@ duplicate_loop_exit_test (loop_start)\n \t     This can be avoided by checking here for NOTE_INSN_LOOP_CONT.  */\n \n \t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG\n-\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG\n-\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END\n \t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_CONT)\n \t    return 0;\n+\n+\t  if (optimize < 2\n+\t      && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG\n+\t\t  || NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END))\n+\t    /* If we were to duplicate this code, we would not move\n+\t       the BLOCK notes, and so debugging the moved code would\n+\t       be difficult.  Thus, we only move the code with -O2 or\n+\t       higher.  */\n+\t    return 0;\n+\n \t  break;\n \tcase JUMP_INSN:\n \tcase INSN:"}, {"sha": "18ca944ee2d816232212d52397132114e4cdc1e9", "filename": "gcc/stmt.c", "status": "modified", "additions": 124, "deletions": 18, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93de5c31054212951fbf9f9d33a682dec33ee508/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93de5c31054212951fbf9f9d33a682dec33ee508/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=93de5c31054212951fbf9f9d33a682dec33ee508", "patch": "@@ -1923,43 +1923,117 @@ expand_end_loop ()\n \n   do_pending_stack_adjust ();\n \n-  /* If optimizing, perhaps reorder the loop.  If the loop\n-     starts with a conditional exit, roll that to the end\n-     where it will optimize together with the jump back.\n-\n-     We look for the last conditional branch to the exit that we encounter\n-     before hitting 30 insns or a CALL_INSN.  If we see an unconditional\n-     branch to the exit first, use it.\n-\n-     We must also stop at NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes\n-     because moving them is not valid.  */\n-\n+  /* If optimizing, perhaps reorder the loop.  If the loop starts with\n+     a loop exit, roll that to the end where it will optimize together\n+     with the jump back.\n+\n+     We look for the conditional branch to the exit, except that once\n+     we find such a branch, we don't look past 30 instructions.\n+\n+     In more detail, if the loop presently looks like this (in pseudo-C):\n+\n+         start_label:\n+         if (test) goto end_label;\n+\t body;\n+\t goto start_label;\n+\t end_label;\n+\t \n+     transform it to look like:\n+\n+         goto start_label;\n+         newstart_label:\n+\t body;\n+\t start_label:\n+\t if (test) goto end_label;\n+\t goto newstart_label;\n+\t end_label;\n+\n+     Here, the `test' may actually consist of some reasonably complex\n+     code, terminating in a test.  */\n   if (optimize\n       &&\n       ! (GET_CODE (insn) == JUMP_INSN\n \t && GET_CODE (PATTERN (insn)) == SET\n \t && SET_DEST (PATTERN (insn)) == pc_rtx\n \t && GET_CODE (SET_SRC (PATTERN (insn))) == IF_THEN_ELSE))\n     {\n+      int eh_regions = 0;\n+\n       /* Scan insns from the top of the loop looking for a qualified\n \t conditional exit.  */\n       for (insn = NEXT_INSN (loop_stack->data.loop.start_label); insn;\n \t   insn = NEXT_INSN (insn))\n \t{\n-\t  if (GET_CODE (insn) == CALL_INSN || GET_CODE (insn) == CODE_LABEL)\n-\t    break;\n+\t  if (GET_CODE (insn) == NOTE) \n+\t    {\n+\t      if (optimize < 2\n+\t\t  && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG\n+\t\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END))\n+\t\t/* The code that actually moves the exit test will\n+\t\t   carefully leave BLOCK notes in their original\n+\t\t   location.  That means, however, that we can't debug\n+\t\t   the exit test itself.  So, we refuse to move code\n+\t\t   containing BLOCK notes at low optimization levels.  */\n+\t\tbreak;\n+\n+\t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG)\n+\t\t++eh_regions;\n+\t      else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END)\n+\t\t{\n+\t\t  --eh_regions;\n+\t\t  if (eh_regions < 0) \n+\t\t    /* We've come to the end of an EH region, but\n+\t\t       never saw the beginning of that region.  That\n+\t\t       means that an EH region begins before the top\n+\t\t       of the loop, and ends in the middle of it.  The\n+\t\t       existence of such a situation violates a basic\n+\t\t       assumption in this code, since that would imply\n+\t\t       that even when EH_REGIONS is zero, we might\n+\t\t       move code out of an exception region.  */\n+\t\t    abort ();\n+\t\t}\n \n-\t  if (GET_CODE (insn) == NOTE\n-\t      && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG\n-\t\t  || NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END))\n-\t    break;\n+\t      /* We already know this INSN is a NOTE, so there's no\n+\t\t point in looking at it to see if it's a JUMP.  */\n+\t      continue;\n+\t    }\n \n \t  if (GET_CODE (insn) == JUMP_INSN || GET_CODE (insn) == INSN)\n \t    num_insns++;\n \n \t  if (last_test_insn && num_insns > 30)\n \t    break;\n \n+\t  if (eh_regions > 0) \n+\t    /* We don't want to move a partial EH region.  Consider:\n+\n+\t\t  while ( ( { try {\n+\t\t\t\tif (cond ()) 0;\t\n+\t\t\t\telse {\n+\t\t\t\t  bar();\n+\t\t\t\t  1;\n+\t\t\t\t}\n+\t\t\t      } catch (...) { \n+\t\t\t\t1;\n+\t\t\t      } )) {\n+\t\t     body;\n+\t\t  } \n+\n+\t        This isn't legal C++, but here's what it's supposed to\n+\t        mean: if cond() is true, stop looping.  Otherwise,\n+\t        call bar, and keep looping.  In addition, if cond\n+\t        throws an exception, catch it and keep looping. Such\n+\t        constructs are certainy legal in LISP.  \n+\n+\t\tWe should not move the `if (cond()) 0' test since then\n+\t\tthe EH-region for the try-block would be broken up.\n+\t\t(In this case we would the EH_BEG note for the `try'\n+\t\tand `if cond()' but not the call to bar() or the\n+\t\tEH_END note.)  \n+\n+\t        So we don't look for tests within an EH region.  */\n+\t    continue;\n+\n \t  if (GET_CODE (insn) == JUMP_INSN && GET_CODE (PATTERN (insn)) == SET\n \t      && SET_DEST (PATTERN (insn)) == pc_rtx\n \t      && GET_CODE (SET_SRC (PATTERN (insn))) == IF_THEN_ELSE\n@@ -1994,6 +2068,7 @@ expand_end_loop ()\n \t     to jump to there.  */\n \t  register rtx newstart_label = gen_label_rtx ();\n \t  register rtx start_move = start_label;\n+\t  rtx next_insn;\n \n \t  /* If the start label is preceded by a NOTE_INSN_LOOP_CONT note,\n \t     then we want to move this note also.  */\n@@ -2003,7 +2078,38 @@ expand_end_loop ()\n \t    start_move = PREV_INSN (start_move);\n \n \t  emit_label_after (newstart_label, PREV_INSN (start_move));\n-\t  reorder_insns (start_move, last_test_insn, get_last_insn ());\n+\n+\t  /* Actually move the insns.  Start at the beginning, and\n+\t     keep copying insns until we've copied the\n+\t     last_test_insn.  */\n+\t  for (insn = start_move; insn; insn = next_insn)\n+\t    {\n+\t      /* Figure out which insn comes after this one.  We have\n+\t\t to do this before we move INSN.  */\n+\t      if (insn == last_test_insn)\n+\t\t/* We've moved all the insns.  */\n+\t\tnext_insn = NULL_RTX;\n+\t      else\n+\t\tnext_insn = NEXT_INSN (insn);\n+\n+\t      if (GET_CODE (insn) == NOTE\n+\t\t  && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG\n+\t\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END))\n+\t\t/* We don't want to move NOTE_INSN_BLOCK_BEGs or\n+\t\t   NOTE_INSN_BLOCK_ENDs because the correct generation\n+\t\t   of debugging information depends on these appearing\n+\t\t   in the same order in the RTL and in the tree\n+\t\t   structure, where they are represented as BLOCKs.\n+\t\t   So, we don't move block notes.  Of course, moving\n+\t\t   the code inside the block is likely to make it\n+\t\t   impossible to debug the instructions in the exit\n+\t\t   test, but such is the price of optimization.  */\n+\t\tcontinue;\n+\n+\t      /* Move the INSN.  */\n+\t      reorder_insns (insn, insn, get_last_insn ());\n+\t    }\n+\n \t  emit_jump_insn_after (gen_jump (start_label),\n \t\t\t\tPREV_INSN (newstart_label));\n \t  emit_barrier_after (PREV_INSN (newstart_label));"}]}