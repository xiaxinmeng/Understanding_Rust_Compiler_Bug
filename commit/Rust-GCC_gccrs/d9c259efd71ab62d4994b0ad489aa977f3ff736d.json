{"sha": "d9c259efd71ab62d4994b0ad489aa977f3ff736d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDljMjU5ZWZkNzFhYjYyZDQ5OTRiMGFkNDg5YWE5NzdmM2ZmNzM2ZA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-07-28T15:01:28Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-07-28T15:01:28Z"}, "message": "tree-predcom.c: Revise general description of the pass.\n\n\t* tree-predcom.c: Revise general description of the pass.\n\t(enum chain_type): New enum type for store elimination.\n\t(struct chain): New field supporting store elimination.\n\t(struct component): Ditto.\n\t(dump_chain): Dump store-stores chain.\n\t(release_chain): Release resources.\n\t(split_data_refs_to_components): Compute and create component\n\tcontains only stores for elimination.\n\t(get_chain_last_ref_at): New function.\n\t(make_invariant_chain): Initialization.\n\t(make_rooted_chain): Specify chain type in parameter and record it.\n\t(add_looparound_copies): Skip for store-stores chain.\n\t(determine_roots_comp): Compute type of chain and pass it to\n\tmake_rooted_chain.\n\t(initialize_root_vars_store_elim_2): New function.\n\t(finalize_eliminated_stores): New function.\n\t(remove_stmt): Handle store for elimination.\n\t(execute_pred_commoning_chain): Execute predictive commoning on\n\tstore-store chains.\n\t(determine_unroll_factor): Skip unroll for store-stores chain.\n\t(prepare_initializers_chain_store_elim): New function.\n\t(prepare_initializers_chain): Hanlde store-store chain.\n\t(prepare_finalizers_chain, prepare_finalizers): New function.\n\t(tree_predictive_commoning_loop): Return integer value indicating\n\tif loop is unrolled or lcssa form is corrupted.\n\t(tree_predictive_commoning): Rewrite for lcssa form if necessary.\n\n\tgcc/testsuite\n\t* gcc.dg/tree-ssa/predcom-dse-1.c: New test.\n\t* gcc.dg/tree-ssa/predcom-dse-2.c: New test.\n\t* gcc.dg/tree-ssa/predcom-dse-3.c: New test.\n\t* gcc.dg/tree-ssa/predcom-dse-4.c: New test.\n\t* gcc.dg/tree-ssa/predcom-dse-5.c: New test.\n\t* gcc.dg/tree-ssa/predcom-dse-6.c: New test.\n\t* gcc.dg/tree-ssa/predcom-dse-7.c: New test.\n\t* gcc.dg/tree-ssa/predcom-dse-8.c: New test.\n\t* gcc.dg/tree-ssa/predcom-dse-9.c: New test.\n\t* gcc.dg/tree-ssa/predcom-dse-10.c: New test.\n\t* gcc.dg/tree-ssa/predcom-dse-11.c: New test.\n\nFrom-SVN: r250669", "tree": {"sha": "8918dfc6533dbf8fd1dcca5c1ef42a87166ecc13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8918dfc6533dbf8fd1dcca5c1ef42a87166ecc13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9c259efd71ab62d4994b0ad489aa977f3ff736d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9c259efd71ab62d4994b0ad489aa977f3ff736d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9c259efd71ab62d4994b0ad489aa977f3ff736d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9c259efd71ab62d4994b0ad489aa977f3ff736d/comments", "author": null, "committer": null, "parents": [{"sha": "10dfaf9a3ba779d219148b863fc94f5fccd15302", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10dfaf9a3ba779d219148b863fc94f5fccd15302", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10dfaf9a3ba779d219148b863fc94f5fccd15302"}], "stats": {"total": 1252, "additions": 1206, "deletions": 46}, "files": [{"sha": "fa27b96739ab176a732c690c43d8fcdc608fbff8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d9c259efd71ab62d4994b0ad489aa977f3ff736d", "patch": "@@ -1,3 +1,32 @@\n+2017-07-28  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-predcom.c: Revise general description of the pass.\n+\t(enum chain_type): New enum type for store elimination.\n+\t(struct chain): New field supporting store elimination.\n+\t(struct component): Ditto.\n+\t(dump_chain): Dump store-stores chain.\n+\t(release_chain): Release resources.\n+\t(split_data_refs_to_components): Compute and create component\n+\tcontains only stores for elimination.\n+\t(get_chain_last_ref_at): New function.\n+\t(make_invariant_chain): Initialization.\n+\t(make_rooted_chain): Specify chain type in parameter and record it.\n+\t(add_looparound_copies): Skip for store-stores chain.\n+\t(determine_roots_comp): Compute type of chain and pass it to\n+\tmake_rooted_chain.\n+\t(initialize_root_vars_store_elim_2): New function.\n+\t(finalize_eliminated_stores): New function.\n+\t(remove_stmt): Handle store for elimination.\n+\t(execute_pred_commoning_chain): Execute predictive commoning on\n+\tstore-store chains.\n+\t(determine_unroll_factor): Skip unroll for store-stores chain.\n+\t(prepare_initializers_chain_store_elim): New function.\n+\t(prepare_initializers_chain): Hanlde store-store chain.\n+\t(prepare_finalizers_chain, prepare_finalizers): New function.\n+\t(tree_predictive_commoning_loop): Return integer value indicating\n+\tif loop is unrolled or lcssa form is corrupted.\n+\t(tree_predictive_commoning): Rewrite for lcssa form if necessary.\n+\n 2017-07-28  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-predcom.c (initialize_root): Delete."}, {"sha": "e0c6bbec8c105325ed1cdd2c0c2996527f582347", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d9c259efd71ab62d4994b0ad489aa977f3ff736d", "patch": "@@ -1,3 +1,17 @@\n+2017-07-28  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcc.dg/tree-ssa/predcom-dse-1.c: New test.\n+\t* gcc.dg/tree-ssa/predcom-dse-2.c: New test.\n+\t* gcc.dg/tree-ssa/predcom-dse-3.c: New test.\n+\t* gcc.dg/tree-ssa/predcom-dse-4.c: New test.\n+\t* gcc.dg/tree-ssa/predcom-dse-5.c: New test.\n+\t* gcc.dg/tree-ssa/predcom-dse-6.c: New test.\n+\t* gcc.dg/tree-ssa/predcom-dse-7.c: New test.\n+\t* gcc.dg/tree-ssa/predcom-dse-8.c: New test.\n+\t* gcc.dg/tree-ssa/predcom-dse-9.c: New test.\n+\t* gcc.dg/tree-ssa/predcom-dse-10.c: New test.\n+\t* gcc.dg/tree-ssa/predcom-dse-11.c: New test.\n+\n 2017-07-28  Martin Liska  <mliska@suse.cz>\n \n \tPR sanitizer/81340"}, {"sha": "d3a2339e55e550831f481aa9b8743b165d0e485f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/predcom-dse-1.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-1.c?ref=d9c259efd71ab62d4994b0ad489aa977f3ff736d", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-inline -fpredictive-commoning -fdump-tree-pcom-details\" } */\n+\n+int arr[105] = {2, 3, 5, 7, 11};\n+int result0[10] = {2, 3, 5, 7, 11};\n+int result1[10] = {0, -1, 5, -2, 11, 0};\n+int result2[10] = {0, 0, -1, -2, -2, 0};\n+int result3[10] = {0, 0, 0, -1, -2, -2, 0};\n+int result4[10] = {0, 0, 0, 0, -1, -2, -2, 0};\n+int result100[105] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -2, -2, 0};\n+\n+extern void abort (void);\n+\n+void __attribute__((noinline)) foo (int *a, int len)\n+{\n+  int i;\n+  for (i = 0; i < len; i++)\n+    {\n+      a[i] = 0;\n+      a[i + 1] = -1;\n+      a[i + 3] = -2;\n+    }\n+}\n+\n+void check (int *a, int *res, int len)\n+{\n+  int i;\n+\n+  for (i = 0; i < len; i++)\n+    if (a[i] != res[i])\n+      abort ();\n+}\n+\n+int main (void)\n+{\n+  foo (arr, 0);\n+  check (arr, result0, 10);\n+\n+  foo (arr, 1);\n+  check (arr, result1, 10);\n+\n+  foo (arr, 2);\n+  check (arr, result2, 10);\n+\n+  foo (arr, 3);\n+  check (arr, result3, 10);\n+\n+  foo (arr, 4);\n+  check (arr, result4, 10);\n+\n+  foo (arr, 100);\n+  check (arr, result100, 105);\n+\n+  return 0;\n+}\n+/* { dg-final { scan-tree-dump \"Store-stores chain\" \"pcom\"} } */"}, {"sha": "bd5575d9502fe10100b7c7c1036aa0d0cd6661ad", "filename": "gcc/testsuite/gcc.dg/tree-ssa/predcom-dse-10.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-10.c?ref=d9c259efd71ab62d4994b0ad489aa977f3ff736d", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-inline -fpredictive-commoning -fdump-tree-pcom-details\" } */\n+\n+int arr[105] = {2, 3, 5, 7, 11};\n+int result0[10] = {2, 3, 5, 7, 11};\n+int result1[10] = {0, 3, 5, -2, 11, 0};\n+\n+extern void abort (void);\n+\n+void __attribute__((noinline)) foo (int *a, int len, int flag)\n+{\n+  int i;\n+  for (i = 0; i < len; i++)\n+    {\n+      a[i] = 0;\n+      if (flag)\n+        a[i + 1] = -1;\n+      a[i + 3] = -2;\n+    }\n+}\n+\n+void check (int *a, int *res, int len)\n+{\n+  int i;\n+\n+  for (i = 0; i < len; i++)\n+    if (a[i] != res[i])\n+      abort ();\n+}\n+\n+int main (void)\n+{\n+  int i;\n+\n+  foo (arr, 0, 0);\n+  check (arr, result0, 10);\n+\n+  foo (arr, 1, 0);\n+  check (arr, result1, 10);\n+\n+  return 0;\n+}\n+/* { dg-final { scan-tree-dump-not \"Store-stores chain\" \"pcom\"} } */\n+"}, {"sha": "9e496f68a1210fef98567d4be1652da2a7cf3509", "filename": "gcc/testsuite/gcc.dg/tree-ssa/predcom-dse-11.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-11.c?ref=d9c259efd71ab62d4994b0ad489aa977f3ff736d", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-inline -fpredictive-commoning -fdump-tree-pcom-details\" } */\n+\n+int arr[105] = {2, 3, 5, 7, 11};\n+int x[105] = {2, 3, 5, 7, 11};\n+int result0[10] = {2, 3, 5, 7, 11};\n+int result1[10] = {0, 0, 0, 0, 0, 0, -1, -2, -2};\n+\n+extern void abort (void);\n+\n+int __attribute__((noinline)) foo (int * __restrict__ a, int * __restrict__ b, int len, int flag)\n+{\n+  int i, sum = 0;\n+  for (i = 0; i < len; i++)\n+    {\n+      a[i] = 0;\n+      b[i + 2] = i;\n+      a[i + 1] = -1;\n+      sum += b[i];\n+      a[i + 3] = -2;\n+    }\n+  return sum;\n+}\n+\n+void check (int *a, int *res, int len, int sum, int val)\n+{\n+  int i;\n+\n+  if (sum != val)\n+    abort ();\n+\n+  for (i = 0; i < len; i++)\n+    if (a[i] != res[i])\n+      abort ();\n+}\n+\n+int main (void)\n+{\n+  int i, sum;\n+\n+  sum = foo (arr, x, 0, 0);\n+  check (arr, result0, 10, sum, 0);\n+\n+  sum = foo (arr, x, 6, 0);\n+  check (arr, result1, 10, sum, 11);\n+\n+  return 0;\n+}\n+/* { dg-final { scan-tree-dump \"Store-stores chain\" \"pcom\"} } */\n+/* { dg-final { scan-tree-dump \"Store-loads chain\" \"pcom\"} } */\n+"}, {"sha": "c48d438e9e0967c8bb430c5c102b5eae2a3fc15d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/predcom-dse-2.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-2.c?ref=d9c259efd71ab62d4994b0ad489aa977f3ff736d", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-inline -fpredictive-commoning -fdump-tree-pcom-details\" } */\n+\n+int arr[105] = {2, 3, 5, 7, 11};\n+int result0[10] = {2, 3, 5, 7, 11};\n+int result1[10] = {0, 3, -1, -2, 11, 0};\n+int result2[10] = {0, 0, -1, -1, -2, 0};\n+int result3[10] = {0, 0, 0, -1, -1, -2, 0};\n+int result4[10] = {0, 0, 0, 0, -1, -1, -2, 0};\n+int result100[105] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -2, 0};\n+\n+extern void abort (void);\n+\n+void __attribute__((noinline)) foo (int *a, int len)\n+{\n+  int i;\n+  for (i = 0; i < len; i++)\n+    {\n+      a[i] = 0;\n+      a[i + 2] = -1;\n+      a[i + 3] = -2;\n+    }\n+}\n+\n+void check (int *a, int *res, int len)\n+{\n+  int i;\n+\n+  for (i = 0; i < len; i++)\n+    if (a[i] != res[i])\n+      abort ();\n+}\n+\n+int main (void)\n+{\n+  foo (arr, 0);\n+  check (arr, result0, 10);\n+\n+  foo (arr, 1);\n+  check (arr, result1, 10);\n+\n+  foo (arr, 2);\n+  check (arr, result2, 10);\n+\n+  foo (arr, 3);\n+  check (arr, result3, 10);\n+\n+  foo (arr, 4);\n+  check (arr, result4, 10);\n+\n+  foo (arr, 100);\n+  check (arr, result100, 105);\n+\n+  return 0;\n+}\n+/* { dg-final { scan-tree-dump \"Store-stores chain\" \"pcom\"} } */"}, {"sha": "9c2736cd0ad20d5749e2c20070d93ac476b69990", "filename": "gcc/testsuite/gcc.dg/tree-ssa/predcom-dse-3.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-3.c?ref=d9c259efd71ab62d4994b0ad489aa977f3ff736d", "patch": "@@ -0,0 +1,108 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-inline -fpredictive-commoning -fdump-tree-pcom-details\" } */\n+\n+int arr1[105] = {2, 3, 5, 7, 11, 13, 0};\n+int arr2[105] = {2, 3, 5, 7, 11, 13, 0};\n+int arr3[105] = {2, 3, 5, 7, 11, 13, 0};\n+int arr4[105] = {2, 3, 5, 7, 11, 13, 0};\n+int result1[105] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -2, -3, 0};\n+int result2[105] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -2, 0};\n+int result3[105] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -2, -2, 0};\n+int result4[105] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, 0};\n+\n+extern void abort (void);\n+\n+void check (int *a, int *res, int len)\n+{\n+  int i;\n+\n+  for (i = 0; i < len; i++)\n+    if (a[i] != res[i])\n+      abort ();\n+}\n+\n+void __attribute__((noinline)) foo1 (int *a)\n+{\n+  int i;\n+  for (i = 0; i < 100; i++)\n+    {\n+      a[i] = 0;\n+      a[i + 1] = -1;\n+      a[i + 2] = -2;\n+      a[i + 3] = -3;\n+    }\n+}\n+\n+void __attribute__((noinline)) foo2 (int *a)\n+{\n+  int i;\n+  for (i = 0; i < 100; i++)\n+    {\n+      a[i] = 0;\n+      a[i + 2] = -1;\n+      a[i + 3] = -2;\n+    }\n+}\n+\n+void __attribute__((noinline)) foo3 (int *a)\n+{\n+  int i;\n+  for (i = 0; i < 100; i++)\n+    {\n+      a[i] = 0;\n+      a[i + 1] = -1;\n+      a[i + 3] = -2;\n+    }\n+}\n+\n+void __attribute__((noinline)) foo4 (int *a)\n+{\n+  int i;\n+  for (i = 0; i < 100; i++)\n+    {\n+      a[i] = 0;\n+      a[i + 3] = -1;\n+    }\n+}\n+\n+int main (void)\n+{\n+  foo1 (arr1);\n+  check (arr1, result1, 105);\n+\n+  foo2 (arr2);\n+  check (arr2, result2, 105);\n+\n+  foo3 (arr3);\n+  check (arr3, result3, 105);\n+\n+  foo4 (arr4);\n+  check (arr4, result4, 105);\n+\n+  return 0;\n+}\n+/* { dg-final { scan-tree-dump-times \"Store-stores chain\" 4 \"pcom\"} } */"}, {"sha": "302425a17ccde05447cf2d735cad411e029aaaea", "filename": "gcc/testsuite/gcc.dg/tree-ssa/predcom-dse-4.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-4.c?ref=d9c259efd71ab62d4994b0ad489aa977f3ff736d", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-inline -fpredictive-commoning -fdump-tree-pcom-details\" } */\n+\n+int arr[105] = {2, 3, 5, 7, 11};\n+int result0[10] = {2, 3, 5, 7, 11};\n+int result1[10] = {0, 3, 5, -1, 11, 0};\n+int result2[10] = {0, 0, 5, -1, -1, 0};\n+int result3[10] = {0, 0, 0, -1, -1, -1, 0};\n+int result4[10] = {0, 0, 0, 0, -1, -1, -1, 0};\n+int result100[105] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, 0};\n+\n+extern void abort (void);\n+\n+void __attribute__((noinline)) foo (int *a, int len)\n+{\n+  int i;\n+  for (i = 0; i < len; i++)\n+    {\n+      a[i] = 0;\n+      a[i + 3] = -1;\n+    }\n+}\n+\n+void check (int *a, int *res, int len)\n+{\n+  int i;\n+\n+  for (i = 0; i < len; i++)\n+    if (a[i] != res[i])\n+      abort ();\n+}\n+\n+int main (void)\n+{\n+  foo (arr, 0);\n+  check (arr, result0, 10);\n+\n+  foo (arr, 1);\n+  check (arr, result1, 10);\n+\n+  foo (arr, 2);\n+  check (arr, result2, 10);\n+\n+  foo (arr, 3);\n+  check (arr, result3, 10);\n+\n+  foo (arr, 4);\n+  check (arr, result4, 10);\n+\n+  foo (arr, 100);\n+  check (arr, result100, 105);\n+\n+  return 0;\n+}\n+/* { dg-final { scan-tree-dump \"Store-stores chain\" \"pcom\"} } */"}, {"sha": "a13d56098bef1286cd6b64078abc4acb98647253", "filename": "gcc/testsuite/gcc.dg/tree-ssa/predcom-dse-5.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-5.c?ref=d9c259efd71ab62d4994b0ad489aa977f3ff736d", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-inline -fpredictive-commoning -fdump-tree-pcom-details\" } */\n+\n+int arr[105] = {2, 3, 5, 7, 11};\n+int result0[10] = {2, 3, 5, 7, 11};\n+int result1[10] = {0, -1, -2, -3, 11, 0};\n+int result2[10] = {0, 0, -1, -2, -3, 0};\n+int result3[10] = {0, 0, 0, -1, -2, -3, 0};\n+int result4[10] = {0, 0, 0, 0, -1, -2, -3, 0};\n+int result100[105] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -2, -3, 0};\n+\n+extern void abort (void);\n+\n+void __attribute__((noinline)) foo (int *a, int len)\n+{\n+  int i;\n+  for (i = 0; i < len; i++)\n+    {\n+      a[i] = 0;\n+      a[i + 1] = -1;\n+      a[i + 2] = -2;\n+      a[i + 3] = -3;\n+    }\n+}\n+\n+void check (int *a, int *res, int len)\n+{\n+  int i;\n+\n+  for (i = 0; i < len; i++)\n+    if (a[i] != res[i])\n+      abort ();\n+}\n+\n+int main (void)\n+{\n+  foo (arr, 0);\n+  check (arr, result0, 10);\n+\n+  foo (arr, 1);\n+  check (arr, result1, 10);\n+\n+  foo (arr, 2);\n+  check (arr, result2, 10);\n+\n+  foo (arr, 3);\n+  check (arr, result3, 10);\n+\n+  foo (arr, 4);\n+  check (arr, result4, 10);\n+\n+  foo (arr, 100);\n+  check (arr, result100, 105);\n+\n+  return 0;\n+}\n+/* { dg-final { scan-tree-dump \"Store-stores chain\" \"pcom\"} } */"}, {"sha": "63d6c8f33b0d3600c2fd7b56ad213cdb4d8ecb0a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/predcom-dse-6.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-6.c?ref=d9c259efd71ab62d4994b0ad489aa977f3ff736d", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-inline -fpredictive-commoning -fdump-tree-pcom-details\" } */\n+\n+int arr[105] = {2, 3, 5, 7, 11, 13, 17, 19};\n+int result0[10] = {2, 3, 5, 7, 11, 13, 17, 19};\n+int result1[10] = {0, -1, -2, -3, -4, -5, 17, 19};\n+int result2[10] = {0, 0, -1, -2, -3, -4, -5, 19};\n+int result3[10] = {0, 0, 0, -1, -2, -3, -4, -5};\n+int result4[10] = {0, 0, 0, 0, -1, -2, -3, -4, -5};\n+int result100[105] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -2, -3, -4, -5};\n+\n+extern void abort (void);\n+\n+void __attribute__((noinline)) foo (int *a, int len)\n+{\n+  int i;\n+  for (i = 0; i < len; i++)\n+    {\n+      a[i] = 0;\n+      a[i + 1] = -1;\n+      a[i + 2] = -2;\n+      a[i + 3] = -3;\n+      a[i + 4] = -4;\n+      a[i + 5] = -5;\n+    }\n+}\n+\n+void check (int *a, int *res, int len)\n+{\n+  int i;\n+\n+  for (i = 0; i < len; i++)\n+    if (a[i] != res[i])\n+      abort ();\n+}\n+\n+int main (void)\n+{\n+  foo (arr, 0);\n+  check (arr, result0, 10);\n+\n+  foo (arr, 1);\n+  check (arr, result1, 10);\n+\n+  foo (arr, 2);\n+  check (arr, result2, 10);\n+\n+  foo (arr, 3);\n+  check (arr, result3, 10);\n+\n+  foo (arr, 4);\n+  check (arr, result4, 10);\n+\n+  foo (arr, 100);\n+  check (arr, result100, 105);\n+\n+  return 0;\n+}\n+/* { dg-final { scan-tree-dump \"Store-stores chain\" \"pcom\"} } */"}, {"sha": "0bde6e6dced4e372c2950636e033e9acbf2b22a8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/predcom-dse-7.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-7.c?ref=d9c259efd71ab62d4994b0ad489aa977f3ff736d", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-inline -fpredictive-commoning -fdump-tree-pcom-details\" } */\n+\n+int arr[105] = {2, 3, 5, 7, 11, 13, 17, 19};\n+int result0[10] = {2, 3, 5, 7, 11, 13, 17, 19};\n+int result1[10] = {0, -1, 5, -3, 11, -5, 17, 19};\n+int result2[10] = {0, 0, -1, -3, -3, -5, -5, 19};\n+int result3[10] = {0, 0, 0, -1, -3, -3, -5, -5};\n+int result4[10] = {0, 0, 0, 0, -1, -3, -3, -5, -5};\n+int result100[105] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -3, -3, -5, -5};\n+\n+extern void abort (void);\n+\n+void __attribute__((noinline)) foo (int *a, int len)\n+{\n+  int i;\n+  for (i = 0; i < len; i++)\n+    {\n+      a[i] = 0;\n+      a[i + 1] = -1;\n+      a[i + 3] = -3;\n+      a[i + 5] = -5;\n+    }\n+}\n+\n+void check (int *a, int *res, int len)\n+{\n+  int i;\n+\n+  for (i = 0; i < len; i++)\n+    if (a[i] != res[i])\n+      abort ();\n+}\n+\n+int main (void)\n+{\n+  foo (arr, 0);\n+  check (arr, result0, 10);\n+\n+  foo (arr, 1);\n+  check (arr, result1, 10);\n+\n+  foo (arr, 2);\n+  check (arr, result2, 10);\n+\n+  foo (arr, 3);\n+  check (arr, result3, 10);\n+\n+  foo (arr, 4);\n+  check (arr, result4, 10);\n+\n+  foo (arr, 100);\n+  check (arr, result100, 105);\n+\n+  return 0;\n+}\n+/* { dg-final { scan-tree-dump \"Store-stores chain\" \"pcom\"} } */"}, {"sha": "45ffd25c424e965d805672f4220ac864c9943623", "filename": "gcc/testsuite/gcc.dg/tree-ssa/predcom-dse-8.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-8.c?ref=d9c259efd71ab62d4994b0ad489aa977f3ff736d", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-inline -fpredictive-commoning -fdump-tree-pcom-details\" } */\n+\n+int arr[105] = {2, 3, 5, 7, 11, 13, 17, 19};\n+int result0[10] = {2, 3, 5, 7, 11, 13, 17, 19};\n+int result1[10] = {0, 3, 5, 7, 11, -5, 17, 19};\n+int result2[10] = {0, 0, 5, 7, 11, -5, -5, 19};\n+int result3[10] = {0, 0, 0, 7, 11, -5, -5, -5};\n+int result4[10] = {0, 0, 0, 0, 11, -5, -5, -5, -5};\n+int result100[105] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -5, -5, -5, -5, -5};\n+\n+extern void abort (void);\n+\n+void __attribute__((noinline)) foo (int *a, int len)\n+{\n+  int i;\n+  for (i = 0; i < len; i++)\n+    {\n+      a[i] = 0;\n+      a[i + 5] = -5;\n+    }\n+}\n+\n+void check (int *a, int *res, int len)\n+{\n+  int i;\n+\n+  for (i = 0; i < len; i++)\n+    if (a[i] != res[i])\n+      abort ();\n+}\n+\n+int main (void)\n+{\n+  foo (arr, 0);\n+  check (arr, result0, 10);\n+\n+  foo (arr, 1);\n+  check (arr, result1, 10);\n+\n+  foo (arr, 2);\n+  check (arr, result2, 10);\n+\n+  foo (arr, 3);\n+  check (arr, result3, 10);\n+\n+  foo (arr, 4);\n+  check (arr, result4, 10);\n+\n+  foo (arr, 100);\n+  check (arr, result100, 105);\n+\n+  return 0;\n+}"}, {"sha": "1c4e3140309a60c67229aa53efa65fa92426f820", "filename": "gcc/testsuite/gcc.dg/tree-ssa/predcom-dse-9.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-dse-9.c?ref=d9c259efd71ab62d4994b0ad489aa977f3ff736d", "patch": "@@ -0,0 +1,90 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-inline -fpredictive-commoning -fdump-tree-pcom-details\" } */\n+\n+int arr1[105] = {2, 3, 5, 7, 11, 13, 17, 19};\n+int arr2[105] = {2, 3, 5, 7, 11, 13, 17, 19};\n+int arr3[105] = {2, 3, 5, 7, 11, 13, 17, 19};\n+\n+int result1[105] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -2, -3, -4, -5};\n+int result2[105] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -3, -3, -5, -5};\n+int result3[105] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -5, -5, -5, -5, -5};\n+\n+extern void abort (void);\n+\n+void __attribute__((noinline)) foo1 (int *a)\n+{\n+  int i;\n+  for (i = 0; i < 100; i++)\n+    {\n+      a[i] = 0;\n+      a[i + 1] = -1;\n+      a[i + 2] = -2;\n+      a[i + 3] = -3;\n+      a[i + 4] = -4;\n+      a[i + 5] = -5;\n+    }\n+}\n+\n+void __attribute__((noinline)) foo2 (int *a)\n+{\n+  int i;\n+  for (i = 0; i < 100; i++)\n+    {\n+      a[i] = 0;\n+      a[i + 1] = -1;\n+      a[i + 3] = -3;\n+      a[i + 5] = -5;\n+    }\n+}\n+\n+void __attribute__((noinline)) foo3 (int *a)\n+{\n+  int i;\n+  for (i = 0; i < 100; i++)\n+    {\n+      a[i] = 0;\n+      a[i + 5] = -5;\n+    }\n+}\n+\n+void check (int *a, int *res, int len)\n+{\n+  int i;\n+\n+  for (i = 0; i < len; i++)\n+    if (a[i] != res[i])\n+      abort ();\n+}\n+\n+int main (void)\n+{\n+  foo1 (arr1);\n+  check (arr1, result1, 10);\n+\n+  foo2 (arr2);\n+  check (arr2, result2, 10);\n+\n+  foo3 (arr3);\n+  check (arr3, result3, 10);\n+\n+  return 0;\n+}\n+/* { dg-final { scan-tree-dump \"Store-stores chain\" \"pcom\"} } */"}, {"sha": "ac0d0d0948472e0edbf93e807bb21202993a4abe", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 434, "deletions": 46, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9c259efd71ab62d4994b0ad489aa977f3ff736d/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=d9c259efd71ab62d4994b0ad489aa977f3ff736d", "patch": "@@ -156,29 +156,45 @@ along with GCC; see the file COPYING3.  If not see\n           b[10] = x;\n        }\n \n-   TODO -- stores killing other stores can be taken into account, e.g.,\n-   for (i = 0; i < n; i++)\n-     {\n-       a[i] = 1;\n-       a[i+2] = 2;\n-     }\n+   Apart from predictive commoning on Load-Load and Store-Load chains, we\n+   also support Store-Store chains -- stores killed by other store can be\n+   eliminated.  Given below example:\n+\n+     for (i = 0; i < n; i++)\n+       {\n+\t a[i] = 1;\n+\t a[i+2] = 2;\n+       }\n \n-   can be replaced with\n+   It can be replaced with:\n \n-   t0 = a[0];\n-   t1 = a[1];\n-   for (i = 0; i < n; i++)\n-     {\n-       a[i] = 1;\n-       t2 = 2;\n-       t0 = t1;\n-       t1 = t2;\n-     }\n-   a[n] = t0;\n-   a[n+1] = t1;\n+     t0 = a[0];\n+     t1 = a[1];\n+     for (i = 0; i < n; i++)\n+       {\n+\t a[i] = 1;\n+\t t2 = 2;\n+\t t0 = t1;\n+\t t1 = t2;\n+       }\n+     a[n] = t0;\n+     a[n+1] = t1;\n \n-   The interesting part is that this would generalize store motion; still, since\n-   sm is performed elsewhere, it does not seem that important.\n+   If the loop runs more than 1 iterations, it can be further simplified into:\n+\n+     for (i = 0; i < n; i++)\n+       {\n+\t a[i] = 1;\n+       }\n+     a[n] = 2;\n+     a[n+1] = 2;\n+\n+   The interesting part is this can be viewed either as general store motion\n+   or general dead store elimination in either intra/inter-iterations way.\n+\n+   TODO: For now, we don't support store-store chains in multi-exit loops.  We\n+   force to not unroll in case of store-store chain even if other chains might\n+   ask for unroll.\n \n    Predictive commoning can be generalized for arbitrary computations (not\n    just memory loads), and also nontrivial transfer functions (e.g., replacing\n@@ -265,6 +281,9 @@ enum chain_type\n   /* Root of the chain is store, the rest are loads.  */\n   CT_STORE_LOAD,\n \n+  /* There are only stores in the chain.  */\n+  CT_STORE_STORE,\n+\n   /* A combination of two chains.  */\n   CT_COMBINATION\n };\n@@ -294,9 +313,15 @@ typedef struct chain\n   /* Initializers for the variables.  */\n   vec<tree> inits;\n \n+  /* Finalizers for the eliminated stores.  */\n+  vec<tree> finis;\n+\n   /* gimple stmts intializing the initial variables of the chain.  */\n   gimple_seq init_seq;\n \n+  /* gimple stmts finalizing the eliminated stores of the chain.  */\n+  gimple_seq fini_seq;\n+\n   /* True if there is a use of a variable with the maximal distance\n      that comes after the root in the loop.  */\n   unsigned has_max_use_after : 1;\n@@ -334,6 +359,10 @@ struct component\n   /* What we know about the step of the references in the component.  */\n   enum ref_step_type comp_step;\n \n+  /* True if all references in component are stores and we try to do\n+     intra/inter loop iteration dead store elimination.  */\n+  bool eliminate_store_p;\n+\n   /* Next component in the list.  */\n   struct component *next;\n };\n@@ -404,6 +433,10 @@ dump_chain (FILE *file, chain_p chain)\n       chain_type = \"Store-loads\";\n       break;\n \n+    case CT_STORE_STORE:\n+      chain_type = \"Store-stores\";\n+      break;\n+\n     case CT_COMBINATION:\n       chain_type = \"Combination\";\n       break;\n@@ -517,6 +550,10 @@ release_chain (chain_p chain)\n   if (chain->init_seq)\n     gimple_seq_discard (chain->init_seq);\n \n+  chain->finis.release ();\n+  if (chain->fini_seq)\n+    gimple_seq_discard (chain->fini_seq);\n+\n   free (chain);\n }\n \n@@ -719,6 +756,8 @@ split_data_refs_to_components (struct loop *loop,\n   struct data_dependence_relation *ddr;\n   struct component *comp_list = NULL, *comp;\n   dref dataref;\n+  /* Don't do store elimination if loop has multiple exit edges.  */\n+  bool eliminate_store_p = single_exit (loop) != NULL;\n   basic_block last_always_executed = last_always_executed_block (loop);\n \n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n@@ -761,6 +800,14 @@ split_data_refs_to_components (struct loop *loop,\n \n       dra = DDR_A (ddr);\n       drb = DDR_B (ddr);\n+\n+      /* Don't do store elimination if there is any unknown dependence for\n+\t any store data reference.  */\n+      if ((DR_IS_WRITE (dra) || DR_IS_WRITE (drb))\n+\t  && (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know\n+\t      || DDR_NUM_DIST_VECTS (ddr) == 0))\n+\teliminate_store_p = false;\n+\n       ia = component_of (comp_father, (unsigned) (size_t) dra->aux);\n       ib = component_of (comp_father, (unsigned) (size_t) drb->aux);\n       if (ia == ib)\n@@ -800,10 +847,28 @@ split_data_refs_to_components (struct loop *loop,\n \t      continue;\n \t    }\n \t}\n+      else if (DR_IS_WRITE (dra) && DR_IS_WRITE (drb)\n+\t       && ia != bad && ib != bad\n+\t       && !determine_offset (dra, drb, &dummy_off))\n+\t{\n+\t  merge_comps (comp_father, comp_size, bad, ia);\n+\t  merge_comps (comp_father, comp_size, bad, ib);\n+\t  continue;\n+\t}\n \n       merge_comps (comp_father, comp_size, ia, ib);\n     }\n \n+  if (eliminate_store_p)\n+    {\n+      tree niters = number_of_latch_executions (loop);\n+\n+      /* Don't do store elimination if niters info is unknown because stores\n+\t in the last iteration can't be eliminated and we need to recover it\n+\t after loop.  */\n+      eliminate_store_p = (niters != NULL_TREE && niters != chrec_dont_know);\n+    }\n+\n   comps = XCNEWVEC (struct component *, n);\n   bad = component_of (comp_father, n);\n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n@@ -818,6 +883,7 @@ split_data_refs_to_components (struct loop *loop,\n \t{\n \t  comp = XCNEW (struct component);\n \t  comp->refs.create (comp_size[ca]);\n+\t  comp->eliminate_store_p = eliminate_store_p;\n \t  comps[ca] = comp;\n \t}\n \n@@ -832,6 +898,8 @@ split_data_refs_to_components (struct loop *loop,\n \t\t\t\tgimple_bb (dataref->stmt));\n       dataref->pos = comp->refs.length ();\n       comp->refs.quick_push (dataref);\n+      if (DR_IS_READ (dr))\n+\tcomp->eliminate_store_p = false;\n     }\n \n   for (i = 0; i < n; i++)\n@@ -956,6 +1024,21 @@ get_chain_root (chain_p chain)\n   return chain->refs[0];\n }\n \n+/* Given CHAIN, returns the last ref at DISTANCE, or NULL if it doesn't\n+   exist.  */\n+\n+static inline dref\n+get_chain_last_ref_at (chain_p chain, unsigned distance)\n+{\n+  unsigned i;\n+\n+  for (i = chain->refs.length (); i > 0; i--)\n+    if (distance == chain->refs[i - 1]->distance)\n+      break;\n+\n+  return (i > 0) ? chain->refs[i - 1] : NULL;\n+}\n+\n /* Adds REF to the chain CHAIN.  */\n \n static void\n@@ -1008,23 +1091,27 @@ make_invariant_chain (struct component *comp)\n       chain->all_always_accessed &= ref->always_accessed;\n     }\n \n+  chain->inits = vNULL;\n+  chain->finis = vNULL;\n+\n   return chain;\n }\n \n-/* Make a new chain rooted at REF.  */\n+/* Make a new chain of type TYPE rooted at REF.  */\n \n static chain_p\n-make_rooted_chain (dref ref)\n+make_rooted_chain (dref ref, enum chain_type type)\n {\n   chain_p chain = XCNEW (struct chain);\n \n-  chain->type = DR_IS_READ (ref->ref) ? CT_LOAD : CT_STORE_LOAD;\n-\n+  chain->type = type;\n   chain->refs.safe_push (ref);\n   chain->all_always_accessed = ref->always_accessed;\n-\n   ref->distance = 0;\n \n+  chain->inits = vNULL;\n+  chain->finis = vNULL;\n+\n   return chain;\n }\n \n@@ -1199,6 +1286,9 @@ add_looparound_copies (struct loop *loop, chain_p chain)\n   dref ref, root = get_chain_root (chain);\n   gphi *phi;\n \n+  if (chain->type == CT_STORE_STORE)\n+    return;\n+\n   FOR_EACH_VEC_ELT (chain->refs, i, ref)\n     {\n       phi = find_looparound_phi (loop, ref, root);\n@@ -1223,6 +1313,7 @@ determine_roots_comp (struct loop *loop,\n   dref a;\n   chain_p chain = NULL;\n   widest_int last_ofs = 0;\n+  enum chain_type type;\n \n   /* Invariants are handled specially.  */\n   if (comp->comp_step == RS_INVARIANT)\n@@ -1239,7 +1330,8 @@ determine_roots_comp (struct loop *loop,\n   comp->refs.qsort (order_drefs);\n   FOR_EACH_VEC_ELT (comp->refs, i, a)\n     {\n-      if (!chain || DR_IS_WRITE (a->ref)\n+      if (!chain\n+\t  || (!comp->eliminate_store_p && DR_IS_WRITE (a->ref))\n \t  || wi::leu_p (MAX_DISTANCE, a->offset - last_ofs))\n \t{\n \t  if (nontrivial_chain_p (chain))\n@@ -1249,7 +1341,13 @@ determine_roots_comp (struct loop *loop,\n \t    }\n \t  else\n \t    release_chain (chain);\n-\t  chain = make_rooted_chain (a);\n+\n+\t  if (DR_IS_READ (a->ref))\n+\t    type = CT_LOAD;\n+\t  else\n+\t    type = comp->eliminate_store_p ? CT_STORE_STORE : CT_STORE_LOAD;\n+\n+\t  chain = make_rooted_chain (a, type);\n \t  last_ofs = a->offset;\n \t  continue;\n \t}\n@@ -1536,6 +1634,114 @@ initialize_root_vars (struct loop *loop, chain_p chain, bitmap tmp_vars)\n     }\n }\n \n+/* Creates root variables for store elimination CHAIN in which stores for\n+   elimination store loop variant values.  In this case, we may need to\n+   load root variables before LOOP and propagate it with PHI nodes.  Uids\n+   of the newly created root variables are marked in TMP_VARS.  */\n+\n+static void\n+initialize_root_vars_store_elim_2 (struct loop *loop,\n+\t\t\t\t   chain_p chain, bitmap tmp_vars)\n+{\n+  unsigned i, n = chain->length;\n+  tree ref, init, var, next, val, phi_result;\n+  gimple *stmt;\n+  gimple_seq stmts;\n+\n+  chain->vars.create (n);\n+\n+  ref = DR_REF (get_chain_root (chain)->ref);\n+  for (i = 0; i < n; i++)\n+    {\n+      var = predcom_tmp_var (ref, i, tmp_vars);\n+      chain->vars.quick_push (var);\n+    }\n+\n+  FOR_EACH_VEC_ELT (chain->vars, i, var)\n+    chain->vars[i] = make_ssa_name (var);\n+\n+  /* Root values are either rhs operand of stores to be eliminated, or\n+     loaded from memory before loop.  */\n+  auto_vec<tree> vtemps;\n+  vtemps.safe_grow_cleared (n);\n+  for (i = 0; i < n; i++)\n+    {\n+      init = get_init_expr (chain, i);\n+      if (init == NULL_TREE)\n+\t{\n+\t  /* Root value is rhs operand of the store to be eliminated if\n+\t     it isn't loaded from memory before loop.  */\n+\t  dref a = get_chain_last_ref_at (chain, i);\n+\t  val = gimple_assign_rhs1 (a->stmt);\n+\t  if (TREE_CLOBBER_P (val))\n+\t    val = get_or_create_ssa_default_def (cfun, SSA_NAME_VAR (var));\n+\n+\t  vtemps[n - i - 1] = val;\n+\t}\n+      else\n+\t{\n+\t  edge latch = loop_latch_edge (loop);\n+\t  edge entry = loop_preheader_edge (loop);\n+\n+\t  /* Root value is loaded from memory before loop, we also need\n+\t     to add PHI nodes to propagate the value across iterations.  */\n+\t  init = force_gimple_operand (init, &stmts, true, NULL_TREE);\n+\t  if (stmts)\n+\t    gsi_insert_seq_on_edge_immediate (entry, stmts);\n+\n+\t  next = chain->vars[n - i];\n+\t  phi_result = copy_ssa_name (next);\n+\t  gphi *phi = create_phi_node (phi_result, loop->header);\n+\t  add_phi_arg (phi, init, entry, UNKNOWN_LOCATION);\n+\t  add_phi_arg (phi, next, latch, UNKNOWN_LOCATION);\n+\t  vtemps[n - i - 1] = phi_result;\n+\t}\n+    }\n+\n+  /* Find the insertion position.  */\n+  dref last = get_chain_root (chain);\n+  for (i = 0; i < chain->refs.length (); i++)\n+    {\n+      if (chain->refs[i]->pos > last->pos)\n+\tlast = chain->refs[i];\n+    }\n+\n+  gimple_stmt_iterator gsi = gsi_for_stmt (last->stmt);\n+\n+  /* Insert statements copying root value to root variable.  */\n+  for (i = 0; i < n; i++)\n+    {\n+      var = chain->vars[i];\n+      val = vtemps[i];\n+      stmt = gimple_build_assign (var, val);\n+      gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n+    }\n+}\n+\n+/* Generates stores for CHAIN's eliminated stores in LOOP's last\n+   (CHAIN->length - 1) iterations.  */\n+\n+static void\n+finalize_eliminated_stores (struct loop *loop, chain_p chain)\n+{\n+  unsigned i, n = chain->length;\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      tree var = chain->vars[i];\n+      tree fini = chain->finis[n - i - 1];\n+      gimple *stmt = gimple_build_assign (fini, var);\n+\n+      gimple_seq_add_stmt_without_update (&chain->fini_seq, stmt);\n+    }\n+\n+  if (chain->fini_seq)\n+    {\n+      gsi_insert_seq_on_edge_immediate (single_exit (loop), chain->fini_seq);\n+      chain->fini_seq = NULL;\n+    }\n+}\n+\n /* Initializes a variable for load motion for ROOT and prepares phi nodes and\n    initialization on entry to LOOP if necessary.  The ssa name for the variable\n    is stored in VARS.  If WRITTEN is true, also a phi node to copy its value\n@@ -1704,10 +1910,17 @@ remove_stmt (gimple *stmt)\n       bsi = gsi_for_stmt (stmt);\n \n       name = gimple_assign_lhs (stmt);\n-      gcc_assert (TREE_CODE (name) == SSA_NAME);\n-\n-      next = single_nonlooparound_use (name);\n-      reset_debug_uses (stmt);\n+      if (TREE_CODE (name) == SSA_NAME)\n+\t{\n+\t  next = single_nonlooparound_use (name);\n+\t  reset_debug_uses (stmt);\n+\t}\n+      else\n+\t{\n+\t  /* This is a store to be eliminated.  */\n+\t  gcc_assert (gimple_vdef (stmt) != NULL);\n+\t  next = NULL;\n+\t}\n \n       unlink_stmt_vdef (stmt);\n       gsi_remove (&bsi, true);\n@@ -1727,9 +1940,9 @@ remove_stmt (gimple *stmt)\n \n static void\n execute_pred_commoning_chain (struct loop *loop, chain_p chain,\n-\t\t\t     bitmap tmp_vars)\n+\t\t\t      bitmap tmp_vars)\n {\n-  unsigned i;\n+  unsigned i, n;\n   dref a;\n   tree var;\n   bool in_lhs;\n@@ -1740,6 +1953,27 @@ execute_pred_commoning_chain (struct loop *loop, chain_p chain,\n \t compute the values of the expression (except for the root one).\n \t We delay this until after all chains are processed.  */\n     }\n+  else if (chain->type == CT_STORE_STORE)\n+    {\n+      if (chain->length > 0)\n+\t{\n+\t  /* For inter-iteration store elimination chain, set up the\n+\t     variables by loading from memory before loop, copying from rhs\n+\t     of stores for elimination and propagate it with PHI nodes.  */\n+\t  initialize_root_vars_store_elim_2 (loop, chain, tmp_vars);\n+\n+\t  /* For inter-iteration store elimination chain, stores at each\n+\t     distance in loop's last (chain->length - 1) iterations can't\n+\t     be eliminated, because there is no following killing store.\n+\t     We need to generate these stores after loop.  */\n+\t  finalize_eliminated_stores (loop, chain);\n+\t}\n+\n+      /* Eliminate the stores killed by following store.  */\n+      n = chain->refs.length ();\n+      for (i = 0; i < n - 1; i++)\n+\tremove_stmt (chain->refs[i]->stmt);\n+    }\n   else\n     {\n       /* For non-combined chains, set up the variables that hold its value.  */\n@@ -1773,6 +2007,9 @@ determine_unroll_factor (vec<chain_p> chains)\n     {\n       if (chain->type == CT_INVARIANT)\n \tcontinue;\n+      /* For now we can't handle unrolling when eliminating stores.  */\n+      else if (chain->type == CT_STORE_STORE)\n+\treturn 1;\n \n       if (chain->combined)\n \t{\n@@ -2419,6 +2656,65 @@ try_combine_chains (vec<chain_p> *chains)\n     }\n }\n \n+/* Prepare initializers for store elimination CHAIN in LOOP.  Returns false\n+   if this is impossible because one of these initializers may trap, true\n+   otherwise.  */\n+\n+static bool\n+prepare_initializers_chain_store_elim (struct loop *, chain_p chain)\n+{\n+  unsigned i, n = chain->length;\n+\n+  /* For now we can't eliminate stores if some of them are conditional\n+     executed.  */\n+  if (!chain->all_always_accessed)\n+    return false;\n+\n+  /* Nothing to intialize for intra-iteration store elimination.  */\n+  if (n == 0 && chain->type == CT_STORE_STORE)\n+    return true;\n+\n+  chain->inits.create (n);\n+  chain->inits.safe_grow_cleared (n);\n+\n+  /* For store eliminatin chain like below:\n+\n+     for (i = 0; i < len; i++)\n+       {\n+\t a[i] = 1;\n+\t // a[i + 1] = ...\n+\t a[i + 2] = 3;\n+       }\n+\n+     store to a[i + 1] is missed in loop body, it acts like bubbles.  The\n+     content of a[i + 1] remain the same if the loop iterates fewer times\n+     than chain->length.  We need to set up root variables for such stores\n+     by loading from memory before loop.  Note we only need to load bubble\n+     elements because loop body is guaranteed to be executed at least once\n+     after loop's preheader edge.  */\n+  auto_vec<bool> bubbles;\n+  bubbles.safe_grow_cleared (n + 1);\n+  for (i = 0; i < chain->refs.length (); i++)\n+    bubbles[chain->refs[i]->distance] = true;\n+\n+  struct data_reference *dr = get_chain_root (chain)->ref;\n+  for (i = 0; i < n; i++)\n+    {\n+      if (bubbles[i])\n+\tcontinue;\n+\n+      gimple_seq stmts = NULL;\n+\n+      tree init = ref_at_iteration (dr, (int) 0 - i, &stmts);\n+      if (stmts)\n+\tgimple_seq_add_seq_without_update (&chain->init_seq, stmts);\n+\n+      chain->inits[i] = init;\n+    }\n+\n+  return true;\n+}\n+\n /* Prepare initializers for CHAIN in LOOP.  Returns false if this is\n    impossible because one of these initializers may trap, true otherwise.  */\n \n@@ -2431,6 +2727,9 @@ prepare_initializers_chain (struct loop *loop, chain_p chain)\n   dref laref;\n   edge entry = loop_preheader_edge (loop);\n \n+  if (chain->type == CT_STORE_STORE)\n+    return prepare_initializers_chain_store_elim (loop, chain);\n+\n   /* Find the initializers for the variables, and check that they cannot\n      trap.  */\n   chain->inits.create (n);\n@@ -2494,6 +2793,90 @@ prepare_initializers (struct loop *loop, vec<chain_p> chains)\n     }\n }\n \n+/* Generates finalizer memory references for CHAIN in LOOP.  Returns true\n+   if finalizer code for CHAIN can be generated, otherwise false.  */\n+\n+static bool\n+prepare_finalizers_chain (struct loop *loop, chain_p chain)\n+{\n+  unsigned i, n = chain->length;\n+  struct data_reference *dr = get_chain_root (chain)->ref;\n+  tree fini, niters = number_of_latch_executions (loop);\n+\n+  /* For now we can't eliminate stores if some of them are conditional\n+     executed.  */\n+  if (!chain->all_always_accessed)\n+    return false;\n+\n+  chain->finis.create (n);\n+  for (i = 0; i < n; i++)\n+    chain->finis.quick_push (NULL_TREE);\n+\n+  /* We never use looparound phi node for store elimination chains.  */\n+\n+  /* Find the finalizers for the variables, and check that they cannot\n+     trap.  */\n+  for (i = 0; i < n; i++)\n+    {\n+      gimple_seq stmts = NULL;\n+      gcc_assert (chain->finis[i] == NULL_TREE);\n+\n+      if (TREE_CODE (niters) != INTEGER_CST && TREE_CODE (niters) != SSA_NAME)\n+\t{\n+\t  niters = copy_node (niters);\n+\t  niters = force_gimple_operand (niters, &stmts, true, NULL);\n+\t  if (stmts)\n+\t    {\n+\t      gimple_seq_add_seq_without_update (&chain->fini_seq, stmts);\n+\t      stmts = NULL;\n+\t    }\n+\t}\n+      fini = ref_at_iteration (dr, (int) 0 - i, &stmts, niters);\n+      if (stmts)\n+\tgimple_seq_add_seq_without_update (&chain->fini_seq, stmts);\n+\n+      chain->finis[i] = fini;\n+    }\n+\n+  return true;\n+}\n+\n+/* Generates finalizer memory reference for CHAINS in LOOP.  Returns true\n+   if finalizer code generation for CHAINS breaks loop closed ssa form.  */\n+\n+static bool\n+prepare_finalizers (struct loop *loop, vec<chain_p> chains)\n+{\n+  chain_p chain;\n+  unsigned i;\n+  bool loop_closed_ssa = false;\n+\n+  for (i = 0; i < chains.length ();)\n+    {\n+      chain = chains[i];\n+\n+      /* Finalizer is only necessary for inter-iteration store elimination\n+\t chains.  */\n+      if (chain->length == 0 || chain->type != CT_STORE_STORE)\n+\t{\n+\t  i++;\n+\t  continue;\n+\t}\n+\n+      if (prepare_finalizers_chain (loop, chain))\n+\t{\n+\t  i++;\n+\t  loop_closed_ssa = true;\n+\t}\n+      else\n+\t{\n+\t  release_chain (chain);\n+\t  chains.unordered_remove (i);\n+\t}\n+    }\n+  return loop_closed_ssa;\n+}\n+\n /* Insert all initializing gimple stmts into loop's entry edge.  */\n \n static void\n@@ -2510,10 +2893,11 @@ insert_init_seqs (struct loop *loop, vec<chain_p> chains)\n       }\n }\n \n-/* Performs predictive commoning for LOOP.  Returns true if LOOP was\n-   unrolled.  */\n+/* Performs predictive commoning for LOOP.  Sets bit 1<<0 of return value\n+   if LOOP was unrolled; Sets bit 1<<1 of return value if loop closed ssa\n+   form was corrupted.  */\n \n-static bool\n+static unsigned\n tree_predictive_commoning_loop (struct loop *loop)\n {\n   vec<data_reference_p> datarefs;\n@@ -2522,7 +2906,7 @@ tree_predictive_commoning_loop (struct loop *loop)\n   vec<chain_p> chains = vNULL;\n   unsigned unroll_factor;\n   struct tree_niter_desc desc;\n-  bool unroll = false;\n+  bool unroll = false, loop_closed_ssa = false;\n   edge exit;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2534,7 +2918,7 @@ tree_predictive_commoning_loop (struct loop *loop)\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"Loop iterates only 1 time, nothing to do.\\n\");\n \n-      return false;\n+      return 0;\n     }\n \n   /* Find the data references and split them into components according to their\n@@ -2549,7 +2933,7 @@ tree_predictive_commoning_loop (struct loop *loop)\n \tfprintf (dump_file, \"Cannot analyze data dependencies\\n\");\n       free_data_refs (datarefs);\n       free_dependence_relations (dependences);\n-      return false;\n+      return 0;\n     }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2562,7 +2946,7 @@ tree_predictive_commoning_loop (struct loop *loop)\n     {\n       free_data_refs (datarefs);\n       free_affine_expand_cache (&name_expansions);\n-      return false;\n+      return 0;\n     }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2587,6 +2971,7 @@ tree_predictive_commoning_loop (struct loop *loop)\n       goto end;\n     }\n   prepare_initializers (loop, chains);\n+  loop_closed_ssa = prepare_finalizers (loop, chains);\n \n   /* Try to combine the chains that are always worked with together.  */\n   try_combine_chains (&chains);\n@@ -2648,31 +3033,34 @@ end: ;\n \n   free_affine_expand_cache (&name_expansions);\n \n-  return unroll;\n+  return (unroll ? 1 : 0) | (loop_closed_ssa ? 2 : 0);\n }\n \n /* Runs predictive commoning.  */\n \n unsigned\n tree_predictive_commoning (void)\n {\n-  bool unrolled = false;\n   struct loop *loop;\n-  unsigned ret = 0;\n+  unsigned ret = 0, changed = 0;\n \n   initialize_original_copy_tables ();\n   FOR_EACH_LOOP (loop, LI_ONLY_INNERMOST)\n     if (optimize_loop_for_speed_p (loop))\n       {\n-\tunrolled |= tree_predictive_commoning_loop (loop);\n+\tchanged |= tree_predictive_commoning_loop (loop);\n       }\n+  free_original_copy_tables ();\n \n-  if (unrolled)\n+  if (changed > 0)\n     {\n       scev_reset ();\n+\n+      if (changed > 1)\n+\trewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n+\n       ret = TODO_cleanup_cfg;\n     }\n-  free_original_copy_tables ();\n \n   return ret;\n }"}]}