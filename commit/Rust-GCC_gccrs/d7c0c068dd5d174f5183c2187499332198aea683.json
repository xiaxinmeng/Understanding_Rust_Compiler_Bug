{"sha": "d7c0c068dd5d174f5183c2187499332198aea683", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdjMGMwNjhkZDVkMTc0ZjUxODNjMjE4NzQ5OTMzMjE5OGFlYTY4Mw==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2009-11-02T14:30:39Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2009-11-02T14:30:39Z"}, "message": "re PR tree-optimization/41857 (Loop optimizer breaks __ea pointers with -mea64)\n\ngcc/\n\tPR tree-optimization/41857\n\t* tree-flow.h (rewrite_use_address): Add BASE_HINT argument.\n\t* tree-ssa-loop-ivopts.c (rewrite_use_address): Pass base hint\n\tto create_mem_ref.\n\t* tree-ssa-address.c (move_hint_to_base): New function.\n\t(most_expensive_mult_to_index): Add TYPE argument.  Use mode and\n\taddress space associated with TYPE.\n\t(addr_to_parts): Add TYPE and BASE_HINT arguments.  Pass TYPE to\n\tmost_expensive_mult_to_index.  Call move_hint_to_base.\n\t(create_mem_ref): Add BASE_HINT argument.  Pass BASE_HINT and\n\tTYPE to addr_to_parts.\n\ngcc/testsuite/\n\tPR tree-optimization/41857\n\t* gcc.target/spu/ea/pr41857.c: New file.\n\nFrom-SVN: r153810", "tree": {"sha": "f4baec2a8f727693a22c86047fb07064f6e86319", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4baec2a8f727693a22c86047fb07064f6e86319"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7c0c068dd5d174f5183c2187499332198aea683", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7c0c068dd5d174f5183c2187499332198aea683", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7c0c068dd5d174f5183c2187499332198aea683", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7c0c068dd5d174f5183c2187499332198aea683/comments", "author": null, "committer": null, "parents": [{"sha": "2b93f88dc57229e8e6d8fd6a868d3f54f8e7b43e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b93f88dc57229e8e6d8fd6a868d3f54f8e7b43e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b93f88dc57229e8e6d8fd6a868d3f54f8e7b43e"}], "stats": {"total": 127, "additions": 111, "deletions": 16}, "files": [{"sha": "3b64aed951c884d895e00ab0ab794932708115bb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c0c068dd5d174f5183c2187499332198aea683/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c0c068dd5d174f5183c2187499332198aea683/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d7c0c068dd5d174f5183c2187499332198aea683", "patch": "@@ -1,3 +1,17 @@\n+2009-11-02  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\tPR tree-optimization/41857\n+\t* tree-flow.h (rewrite_use_address): Add BASE_HINT argument.\n+\t* tree-ssa-loop-ivopts.c (rewrite_use_address): Pass base hint\n+\tto create_mem_ref.\n+\t* tree-ssa-address.c (move_hint_to_base): New function.\n+\t(most_expensive_mult_to_index): Add TYPE argument.  Use mode and\n+\taddress space associated with TYPE.\n+\t(addr_to_parts): Add TYPE and BASE_HINT arguments.  Pass TYPE to\n+\tmost_expensive_mult_to_index.  Call move_hint_to_base.\n+\t(create_mem_ref): Add BASE_HINT argument.  Pass BASE_HINT and\n+\tTYPE to addr_to_parts.\n+\n 2009-11-02  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/41750"}, {"sha": "2d1378aa7a9d443474cbd27ebaad99e7703ef440", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c0c068dd5d174f5183c2187499332198aea683/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c0c068dd5d174f5183c2187499332198aea683/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d7c0c068dd5d174f5183c2187499332198aea683", "patch": "@@ -1,3 +1,8 @@\n+2009-11-02  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\tPR tree-optimization/41857\n+\t* gcc.target/spu/ea/pr41857.c: New file.\n+\n 2009-11-02  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/41750"}, {"sha": "17710674cf6d504b12a5973ef9e2887dae180e9c", "filename": "gcc/testsuite/gcc.target/spu/ea/pr41857.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c0c068dd5d174f5183c2187499332198aea683/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fpr41857.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c0c068dd5d174f5183c2187499332198aea683/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fpr41857.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fpr41857.c?ref=d7c0c068dd5d174f5183c2187499332198aea683", "patch": "@@ -0,0 +1,29 @@\n+/* Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this file; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* { dg-do compile } */\n+\n+__ea char *strchr_ea (__ea const char *s, int c);\n+__ea char *foo (__ea char *s)\n+{\n+  __ea char *ret = s;\n+  int i;\n+\n+  for (i = 0; i < 3; i++)\n+    ret = strchr_ea (ret, s[i]);\n+ \n+  return ret;\n+}"}, {"sha": "40fad2dd5562e0263e313b34fa54356d0f77d1a9", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c0c068dd5d174f5183c2187499332198aea683/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c0c068dd5d174f5183c2187499332198aea683/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=d7c0c068dd5d174f5183c2187499332198aea683", "patch": "@@ -921,7 +921,7 @@ struct mem_address\n \n struct affine_tree_combination;\n tree create_mem_ref (gimple_stmt_iterator *, tree, \n-\t\t     struct affine_tree_combination *, bool);\n+\t\t     struct affine_tree_combination *, tree, bool);\n rtx addr_for_mem_ref (struct mem_address *, addr_space_t, bool);\n void get_address_description (tree, struct mem_address *);\n tree maybe_fold_tmr (tree);"}, {"sha": "37bce5e2d2e5849345e5489d8d08b973f7bc963c", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 45, "deletions": 14, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c0c068dd5d174f5183c2187499332198aea683/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c0c068dd5d174f5183c2187499332198aea683/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=d7c0c068dd5d174f5183c2187499332198aea683", "patch": "@@ -392,6 +392,33 @@ move_fixed_address_to_symbol (struct mem_address *parts, aff_tree *addr)\n   aff_combination_remove_elt (addr, i);\n }\n \n+/* If ADDR contains an instance of BASE_HINT, move it to PARTS->base.  */\n+\n+static void\n+move_hint_to_base (tree type, struct mem_address *parts, tree base_hint,\n+\t\t   aff_tree *addr)\n+{\n+  unsigned i;\n+  tree val = NULL_TREE;\n+\n+  for (i = 0; i < addr->n; i++)\n+    {\n+      if (!double_int_one_p (addr->elts[i].coef))\n+\tcontinue;\n+\n+      val = addr->elts[i].val;\n+      if (operand_equal_p (val, base_hint, 0))\n+\tbreak;\n+    }\n+\n+  if (i == addr->n)\n+    return;\n+\n+  /* Cast value to appropriate pointer type.  */\n+  parts->base = fold_convert (build_pointer_type (type), val);\n+  aff_combination_remove_elt (addr, i);\n+}\n+\n /* If ADDR contains an address of a dereferenced pointer, move it to\n    PARTS->base.  */\n \n@@ -453,9 +480,11 @@ add_to_parts (struct mem_address *parts, tree elt)\n    element(s) to PARTS.  */\n \n static void\n-most_expensive_mult_to_index (struct mem_address *parts, aff_tree *addr,\n-\t\t\t      bool speed)\n+most_expensive_mult_to_index (tree type, struct mem_address *parts,\n+\t\t\t      aff_tree *addr, bool speed)\n {\n+  addr_space_t as = TYPE_ADDR_SPACE (type);\n+  enum machine_mode address_mode = targetm.addr_space.address_mode (as);\n   HOST_WIDE_INT coef;\n   double_int best_mult, amult, amult_neg;\n   unsigned best_mult_cost = 0, acost;\n@@ -469,15 +498,12 @@ most_expensive_mult_to_index (struct mem_address *parts, aff_tree *addr,\n       if (!double_int_fits_in_shwi_p (addr->elts[i].coef))\n \tcontinue;\n \n-      /* FIXME: Should use the correct memory mode rather than Pmode.  */\n-\n       coef = double_int_to_shwi (addr->elts[i].coef);\n       if (coef == 1\n-\t  || !multiplier_allowed_in_address_p (coef, Pmode,\n-\t\t\t\t\t       ADDR_SPACE_GENERIC))\n+\t  || !multiplier_allowed_in_address_p (coef, TYPE_MODE (type), as))\n \tcontinue;\n \n-      acost = multiply_by_cost (coef, Pmode, speed);\n+      acost = multiply_by_cost (coef, address_mode, speed);\n \n       if (acost > best_mult_cost)\n \t{\n@@ -520,8 +546,10 @@ most_expensive_mult_to_index (struct mem_address *parts, aff_tree *addr,\n   parts->step = double_int_to_tree (sizetype, best_mult);\n }\n \n-/* Splits address ADDR into PARTS.\n-   \n+/* Splits address ADDR for a memory access of type TYPE into PARTS.\n+   If BASE_HINT is non-NULL, it specifies an SSA name to be used\n+   preferentially as base of the reference.\n+\n    TODO -- be more clever about the distribution of the elements of ADDR\n    to PARTS.  Some architectures do not support anything but single\n    register in address, possibly with a small integer offset; while\n@@ -530,7 +558,8 @@ most_expensive_mult_to_index (struct mem_address *parts, aff_tree *addr,\n    addressing modes is useless.  */\n \n static void\n-addr_to_parts (aff_tree *addr, struct mem_address *parts, bool speed)\n+addr_to_parts (tree type, aff_tree *addr, tree base_hint,\n+\t       struct mem_address *parts, bool speed)\n {\n   tree part;\n   unsigned i;\n@@ -550,12 +579,14 @@ addr_to_parts (aff_tree *addr, struct mem_address *parts, bool speed)\n \n   /* First move the most expensive feasible multiplication\n      to index.  */\n-  most_expensive_mult_to_index (parts, addr, speed);\n+  most_expensive_mult_to_index (type, parts, addr, speed);\n \n   /* Try to find a base of the reference.  Since at the moment\n      there is no reliable way how to distinguish between pointer and its\n      offset, this is just a guess.  */\n-  if (!parts->symbol)\n+  if (!parts->symbol && base_hint)\n+    move_hint_to_base (type, parts, base_hint, addr);\n+  if (!parts->symbol && !parts->base)\n     move_pointer_to_base (parts, addr);\n \n   /* Then try to process the remaining elements.  */\n@@ -592,13 +623,13 @@ gimplify_mem_ref_parts (gimple_stmt_iterator *gsi, struct mem_address *parts)\n \n tree\n create_mem_ref (gimple_stmt_iterator *gsi, tree type, aff_tree *addr,\n-\t\tbool speed)\n+\t\ttree base_hint, bool speed)\n {\n   tree mem_ref, tmp;\n   tree atype;\n   struct mem_address parts;\n \n-  addr_to_parts (addr, &parts, speed);\n+  addr_to_parts (type, addr, base_hint, &parts, speed);\n   gimplify_mem_ref_parts (gsi, &parts);\n   mem_ref = create_mem_ref_raw (type, &parts);\n   if (mem_ref)"}, {"sha": "e89ee0e4ce829c3ff8a9ef310f2eb2822664b161", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7c0c068dd5d174f5183c2187499332198aea683/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7c0c068dd5d174f5183c2187499332198aea683/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=d7c0c068dd5d174f5183c2187499332198aea683", "patch": "@@ -5510,14 +5510,30 @@ rewrite_use_address (struct ivopts_data *data,\n {\n   aff_tree aff;\n   gimple_stmt_iterator bsi = gsi_for_stmt (use->stmt);\n+  tree base_hint = NULL_TREE;\n   tree ref;\n   bool ok;\n \n   ok = get_computation_aff (data->current_loop, use, cand, use->stmt, &aff);\n   gcc_assert (ok);\n   unshare_aff_combination (&aff);\n \n-  ref = create_mem_ref (&bsi, TREE_TYPE (*use->op_p), &aff, data->speed);\n+  /* To avoid undefined overflow problems, all IV candidates use unsigned\n+     integer types.  The drawback is that this makes it impossible for\n+     create_mem_ref to distinguish an IV that is based on a memory object\n+     from one that represents simply an offset.\n+\n+     To work around this problem, we pass a hint to create_mem_ref that\n+     indicates which variable (if any) in aff is an IV based on a memory\n+     object.  Note that we only consider the candidate.  If this is not\n+     based on an object, the base of the reference is in some subexpression\n+     of the use -- but these will use pointer types, so they are recognized\n+     by the create_mem_ref heuristics anyway.  */\n+  if (cand->iv->base_object)\n+    base_hint = var_at_stmt (data->current_loop, cand, use->stmt);\n+\n+  ref = create_mem_ref (&bsi, TREE_TYPE (*use->op_p), &aff, base_hint,\n+\t\t\tdata->speed);\n   copy_ref_info (ref, *use->op_p);\n   *use->op_p = ref;\n }"}]}