{"sha": "100e3acbe2886e01c8afc80a650045f289700776", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTAwZTNhY2JlMjg4NmUwMWM4YWZjODBhNjUwMDQ1ZjI4OTcwMDc3Ng==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-01-21T20:52:44Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-01-21T20:52:44Z"}, "message": "stmt.c (same_case_target_p): New function to determine whether two case labels branch to the same target.\n\n\n\t* stmt.c (same_case_target_p): New function to determine whether\n\ttwo case labels branch to the same target.  Split out from...\n\t(group_case_nodes): ... here.  Use same_case_target_p instead.\n\t(strip_default_case_nodes): Remove explicit case nodes\n\tthat branch to the default destination.\n\t(expand_end_case_type): Call strip_default_case_nodes after\n\tgroup_case_nodes, to simplify the case-list before we count it.\n\tOnly generate table_label RTX when actually needed.  Try to share\n\tthiscase->exit_label and thiscase->data.case_stmt.default_label\n\twhen a switch has no explicit default case.  Simplify test for\n\tconstant index.\n\nFrom-SVN: r61570", "tree": {"sha": "b346c633f75c76e38b841d3081fc309025372972", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b346c633f75c76e38b841d3081fc309025372972"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/100e3acbe2886e01c8afc80a650045f289700776", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/100e3acbe2886e01c8afc80a650045f289700776", "html_url": "https://github.com/Rust-GCC/gccrs/commit/100e3acbe2886e01c8afc80a650045f289700776", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/100e3acbe2886e01c8afc80a650045f289700776/comments", "author": null, "committer": null, "parents": [{"sha": "ed695c8e6c3371ba166afb48b7b69a1083bcb1e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed695c8e6c3371ba166afb48b7b69a1083bcb1e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed695c8e6c3371ba166afb48b7b69a1083bcb1e8"}], "stats": {"total": 92, "additions": 79, "deletions": 13}, "files": [{"sha": "1c46fdfbfc6a8cc37a117b9ad68d73740072a556", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/100e3acbe2886e01c8afc80a650045f289700776/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/100e3acbe2886e01c8afc80a650045f289700776/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=100e3acbe2886e01c8afc80a650045f289700776", "patch": "@@ -1,3 +1,17 @@\n+2003-01-21  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* stmt.c (same_case_target_p): New function to determine whether\n+\ttwo case labels branch to the same target.  Split out from...\n+\t(group_case_nodes): ... here.  Use same_case_target_p instead.\n+\t(strip_default_case_nodes): Remove explicit case nodes\n+\tthat branch to the default destination.\n+\t(expand_end_case_type): Call strip_default_case_nodes after\n+\tgroup_case_nodes, to simplify the case-list before we count it.\n+\tOnly generate table_label RTX when actually needed.  Try to share\n+\tthiscase->exit_label and thiscase->data.case_stmt.default_label\n+\twhen a switch has no explicit default case.  Simplify test for\n+\tconstant index.\n+\n 2003-01-21  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.md (*negsf2_h8300): Use \\\\t instead of"}, {"sha": "043b752cb4539ed8e6b859c4d61541fba3538eaa", "filename": "gcc/stmt.c", "status": "modified", "additions": 65, "deletions": 13, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/100e3acbe2886e01c8afc80a650045f289700776/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/100e3acbe2886e01c8afc80a650045f289700776/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=100e3acbe2886e01c8afc80a650045f289700776", "patch": "@@ -418,6 +418,8 @@ static void expand_cleanups\t\tPARAMS ((tree, tree, int, int));\n static void check_seenlabel\t\tPARAMS ((void));\n static void do_jump_if_equal\t\tPARAMS ((rtx, rtx, rtx, int));\n static int estimate_case_costs\t\tPARAMS ((case_node_ptr));\n+static bool same_case_target_p\t\tPARAMS ((rtx, rtx));\n+static void strip_default_case_nodes\tPARAMS ((case_node_ptr *, rtx));\n static void group_case_nodes\t\tPARAMS ((case_node_ptr));\n static void balance_case_nodes\t\tPARAMS ((case_node_ptr *,\n \t\t\t\t\t       case_node_ptr));\n@@ -5201,13 +5203,13 @@ expand_end_case_type (orig_index, orig_type)\n   rtx before_case, end;\n   struct nesting *thiscase = case_stack;\n   tree index_expr, index_type;\n+  bool exit_done = false;\n   int unsignedp;\n \n   /* Don't crash due to previous errors.  */\n   if (thiscase == NULL)\n     return;\n \n-  table_label = gen_label_rtx ();\n   index_expr = thiscase->data.case_stmt.index_expr;\n   index_type = TREE_TYPE (index_expr);\n   unsignedp = TREE_UNSIGNED (index_type);\n@@ -5247,6 +5249,13 @@ expand_end_case_type (orig_index, orig_type)\n \t{\n \t  thiscase->data.case_stmt.default_label\n \t    = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+\t  /* Share the exit label if possible.  */\n+          if (thiscase->exit_label)\n+\t    {\n+\t      SET_DECL_RTL (thiscase->data.case_stmt.default_label,\n+\t\t\t    thiscase->exit_label);\n+\t      exit_done = true;\n+\t    }\n \t  expand_label (thiscase->data.case_stmt.default_label);\n \t}\n       default_label = label_rtx (thiscase->data.case_stmt.default_label);\n@@ -5260,6 +5269,8 @@ expand_end_case_type (orig_index, orig_type)\n \n       /* Simplify the case-list before we count it.  */\n       group_case_nodes (thiscase->data.case_stmt.case_list);\n+      strip_default_case_nodes (&thiscase->data.case_stmt.case_list,\n+\t\t\t\tdefault_label);\n \n       /* Get upper and lower bounds of case values.\n \t Also convert all the case values to the index expr's data type.  */\n@@ -5321,9 +5332,7 @@ expand_end_case_type (orig_index, orig_type)\n #ifndef ASM_OUTPUT_ADDR_DIFF_ELT\n \t       || flag_pic\n #endif\n-\t       || TREE_CODE (index_expr) == INTEGER_CST\n-\t       || (TREE_CODE (index_expr) == COMPOUND_EXPR\n-\t\t   && TREE_CODE (TREE_OPERAND (index_expr, 1)) == INTEGER_CST))\n+\t       || TREE_CONSTANT (index_expr))\n \t{\n \t  index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n \n@@ -5406,6 +5415,7 @@ expand_end_case_type (orig_index, orig_type)\n \t}\n       else\n \t{\n+\t  table_label = gen_label_rtx ();\n \t  if (! try_casesi (index_type, index_expr, minval, range,\n \t\t\t    table_label, default_label))\n \t    {\n@@ -5487,7 +5497,7 @@ expand_end_case_type (orig_index, orig_type)\n   else\n     end_cleanup_deferral ();\n \n-  if (thiscase->exit_label)\n+  if (thiscase->exit_label && !exit_done)\n     emit_label (thiscase->exit_label);\n \n   POPSTACK (case_stack);\n@@ -5617,6 +5627,54 @@ estimate_case_costs (node)\n   return 1;\n }\n \n+/* Determine whether two case labels branch to the same target.  */\n+\n+static bool\n+same_case_target_p (l1, l2)\n+     rtx l1, l2;\n+{\n+  rtx i1, i2;\n+\n+  if (l1 == l2)\n+    return true;\n+\n+  i1 = next_real_insn (l1);\n+  i2 = next_real_insn (l2);\n+  if (i1 == i2)\n+    return true;\n+\n+  if (i1 && simplejump_p (i1))\n+    {\n+      l1 = XEXP (SET_SRC (PATTERN (i1)), 0);\n+    }\n+\n+  if (i2 && simplejump_p (i2))\n+    {\n+      l2 = XEXP (SET_SRC (PATTERN (i2)), 0);\n+    }\n+  return l1 == l2;\n+}\n+\n+/* Delete nodes that branch to the default label from a list of\n+   case nodes.  Eg. case 5: default: becomes just default:  */\n+\n+static void\n+strip_default_case_nodes (prev, deflab)\n+     case_node_ptr *prev;\n+     rtx deflab;\n+{\n+  case_node_ptr ptr;\n+\n+  while (*prev)\n+    {\n+      ptr = *prev;\n+      if (same_case_target_p (label_rtx (ptr->code_label), deflab))\n+\t*prev = ptr->right;\n+      else\n+\tprev = &ptr->right;\n+    }\n+}\n+\n /* Scan an ordered list of case nodes\n    combining those with consecutive values or ranges.\n \n@@ -5630,19 +5688,13 @@ group_case_nodes (head)\n \n   while (node)\n     {\n-      rtx lb = next_real_insn (label_rtx (node->code_label));\n-      rtx lb2;\n+      rtx lab = label_rtx (node->code_label);\n       case_node_ptr np = node;\n \n       /* Try to group the successors of NODE with NODE.  */\n       while (((np = np->right) != 0)\n \t     /* Do they jump to the same place?  */\n-\t     && ((lb2 = next_real_insn (label_rtx (np->code_label))) == lb\n-\t\t || (lb != 0 && lb2 != 0\n-\t\t     && simplejump_p (lb)\n-\t\t     && simplejump_p (lb2)\n-\t\t     && rtx_equal_p (SET_SRC (PATTERN (lb)),\n-\t\t\t\t     SET_SRC (PATTERN (lb2)))))\n+\t     && same_case_target_p (label_rtx (np->code_label), lab)\n \t     /* Are their ranges consecutive?  */\n \t     && tree_int_cst_equal (np->low,\n \t\t\t\t    fold (build (PLUS_EXPR,"}]}