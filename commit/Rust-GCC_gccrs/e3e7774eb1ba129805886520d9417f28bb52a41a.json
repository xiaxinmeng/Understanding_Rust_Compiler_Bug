{"sha": "e3e7774eb1ba129805886520d9417f28bb52a41a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNlNzc3NGViMWJhMTI5ODA1ODg2NTIwZDk0MTdmMjhiYjUyYTQxYQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "1998-02-13T14:40:09Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1998-02-13T14:40:09Z"}, "message": "Fix C++ irix6 -g compiler abort.\n\n\t* dwarf2out.c (decl_scope_node): New type.\n\t(decl_scope_table): Change type to use it.\n\t(decl_scope_table_allocated, decl_scope_depth): Change type to int.\n\t(push_decl_scope): Use new type.  New locals containing_scope, i.\n\tAdd code to handle setting previous field.\n\t(scope_die_for): Change type of local i to int.  Add code to use\n\tprevious field.\n\t(dwarf2out_init): Use new type.\n\nFrom-SVN: r17969", "tree": {"sha": "fc80a2042acd394f841c86122e291c53a8eced9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc80a2042acd394f841c86122e291c53a8eced9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3e7774eb1ba129805886520d9417f28bb52a41a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3e7774eb1ba129805886520d9417f28bb52a41a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3e7774eb1ba129805886520d9417f28bb52a41a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3e7774eb1ba129805886520d9417f28bb52a41a/comments", "author": null, "committer": null, "parents": [{"sha": "8017079182d9bc07dca83a8d10f1e52ee8c245ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8017079182d9bc07dca83a8d10f1e52ee8c245ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8017079182d9bc07dca83a8d10f1e52ee8c245ec"}], "stats": {"total": 84, "additions": 71, "deletions": 13}, "files": [{"sha": "ee4987913d2543741e1f909f63cae7fa04a3a65f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3e7774eb1ba129805886520d9417f28bb52a41a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3e7774eb1ba129805886520d9417f28bb52a41a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e3e7774eb1ba129805886520d9417f28bb52a41a", "patch": "@@ -1,3 +1,14 @@\n+Fri Feb 13 14:38:34 1998  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* dwarf2out.c (decl_scope_node): New type.\n+\t(decl_scope_table): Change type to use it.\n+\t(decl_scope_table_allocated, decl_scope_depth): Change type to int.\n+\t(push_decl_scope): Use new type.  New locals containing_scope, i.\n+\tAdd code to handle setting previous field.\n+\t(scope_die_for): Change type of local i to int.  Add code to use\n+\tprevious field.\n+\t(dwarf2out_init): Use new type.\n+\n 1998-02-13  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* except.c (emit_throw): Lose throw_used."}, {"sha": "a1462354379b1f223f83b545955732b470addd09", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 60, "deletions": 13, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3e7774eb1ba129805886520d9417f28bb52a41a/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3e7774eb1ba129805886520d9417f28bb52a41a/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=e3e7774eb1ba129805886520d9417f28bb52a41a", "patch": "@@ -2235,18 +2235,29 @@ static unsigned decl_die_table_in_use;\n    decl_die_table.  */\n #define DECL_DIE_TABLE_INCREMENT 256\n \n+/* Structure used for the decl_scope table.  scope is the current declaration\n+   scope, and previous is the entry that is the parent of this scope.  This\n+   is usually but not always the immediately preceeding entry.  */\n+\n+typedef struct decl_scope_struct\n+{\n+  tree scope;\n+  int previous;\n+}\n+decl_scope_node;\n+\n /* A pointer to the base of a table of references to declaration\n    scopes.  This table is a display which tracks the nesting\n    of declaration scopes at the current scope and containing\n    scopes.  This table is used to find the proper place to\n    define type declaration DIE's.  */\n-static tree *decl_scope_table;\n+static decl_scope_node *decl_scope_table;\n \n /* Number of elements currently allocated for the decl_scope_table.  */\n-static unsigned decl_scope_table_allocated;\n+static int decl_scope_table_allocated;\n \n /* Current level of nesting of declaration scopes.  */\n-static unsigned decl_scope_depth;\n+static int decl_scope_depth;\n \n /* Size (in elements) of increments by which we may expand the\n    decl_scope_table.  */\n@@ -7481,16 +7492,50 @@ static void\n push_decl_scope (scope)\n      tree scope;\n {\n+  tree containing_scope;\n+  int i;\n+\n   /* Make room in the decl_scope_table, if necessary.  */\n   if (decl_scope_table_allocated == decl_scope_depth)\n     {\n       decl_scope_table_allocated += DECL_SCOPE_TABLE_INCREMENT;\n       decl_scope_table\n-\t= (tree *) xrealloc (decl_scope_table,\n-\t\t\t     decl_scope_table_allocated * sizeof (tree));\n+\t= (decl_scope_node *) xrealloc (decl_scope_table,\n+\t\t\t\t\t(decl_scope_table_allocated\n+\t\t\t\t\t * sizeof (decl_scope_node)));\n     }\n \n-  decl_scope_table[decl_scope_depth++] = scope;\n+  decl_scope_table[decl_scope_depth].scope = scope;\n+\n+  /* Sometimes, while recursively emitting subtypes within a class type,\n+     we end up recuring on a subtype at a higher level then the current\n+     subtype.  In such a case, we need to search the decl_scope_table to\n+     find the parent of this subtype.  */\n+\n+  if (TREE_CODE_CLASS (TREE_CODE (scope)) == 't')\n+    containing_scope = TYPE_CONTEXT (scope);\n+  else\n+    containing_scope = NULL_TREE;\n+\n+  /* The normal case.  */\n+  if (decl_scope_depth == 0\n+      || containing_scope == NULL_TREE\n+      || containing_scope == decl_scope_table[decl_scope_depth - 1].scope)\n+    decl_scope_table[decl_scope_depth].previous = decl_scope_depth - 1;\n+  else\n+    {\n+      /* We need to search for the containing_scope.  */\n+      for (i = 0; i < decl_scope_depth; i++)\n+\tif (decl_scope_table[i].scope == containing_scope)\n+\t  break;\n+\n+      if (i == decl_scope_depth)\n+\tabort ();\n+      else\n+\tdecl_scope_table[decl_scope_depth].previous = i;\n+    }\n+\n+  decl_scope_depth++;\n }\n \n /* Return the DIE for the scope the immediately contains this declaration.  */\n@@ -7502,7 +7547,7 @@ scope_die_for (t, context_die)\n {\n   register dw_die_ref scope_die = NULL;\n   register tree containing_scope;\n-  register unsigned long i;\n+  register int i;\n \n   /* Walk back up the declaration tree looking for a place to define\n      this type.  */\n@@ -7523,12 +7568,13 @@ scope_die_for (t, context_die)\n     scope_die = comp_unit_die;\n   else\n     {\n-      for (i = decl_scope_depth, scope_die = context_die;\n-\t   i > 0 && decl_scope_table[i - 1] != containing_scope;\n-\t   scope_die = scope_die->die_parent, --i)\n+      for (i = decl_scope_depth - 1, scope_die = context_die;\n+\t   i >= 0 && decl_scope_table[i].scope != containing_scope;\n+\t   (scope_die = scope_die->die_parent,\n+\t    i = decl_scope_table[i].previous))\n \t;\n \n-      if (i == 0)\n+      if (i < 0)\n \t{\n \t  if (scope_die != comp_unit_die\n \t      || TREE_CODE_CLASS (TREE_CODE (containing_scope)) != 't')\n@@ -9651,9 +9697,10 @@ dwarf2out_init (asm_out_file, main_input_filename)\n \n   /* Allocate the initial hunk of the decl_scope_table.  */\n   decl_scope_table\n-    = (tree *) xmalloc (DECL_SCOPE_TABLE_INCREMENT * sizeof (tree));\n+    = (decl_scope_node *) xmalloc (DECL_SCOPE_TABLE_INCREMENT\n+\t\t\t\t   * sizeof (decl_scope_node));\n   bzero ((char *) decl_scope_table,\n-\t DECL_SCOPE_TABLE_INCREMENT * sizeof (tree));\n+\t DECL_SCOPE_TABLE_INCREMENT * sizeof (decl_scope_node));\n   decl_scope_table_allocated = DECL_SCOPE_TABLE_INCREMENT;\n   decl_scope_depth = 0;\n "}]}