{"sha": "a35156057510d1933a0dab5d8bd2837bfd28fa8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM1MTU2MDU3NTEwZDE5MzNhMGRhYjVkOGJkMjgzN2JmZDI4ZmE4Yw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-07-05T16:58:42Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-05T16:58:42Z"}, "message": "vax: Emit prologue as rtl.\n\nNot that there's much rtl to emit, since the CALL instruction\ninterpreting the procedure entry mask does almost all the work.\nHowever, it means we're no longer emitting dwarf2 via the\ntext-based entry points.\n\n        * config/vax/vax.md (define_c_enum unspecv): New.  Define the\n        VUNSPEC_* constants here instead of via define_constants.\n        (VUNSPEC_PEM): New constant.\n        (procedure_entry_mask): New insn.\n        (prologue): New expander.\n        * config/vax/vax.c (vax_add_reg_cfa_offset): New.\n        (vax_expand_prologue): Rename from vax_output_function_prologue;\n        emit rtl instead of text.\n        (TARGET_ASM_FUNCTION_PROLOGUE): Remove.\n        (print_operand): Add 'x' prefix.\n\nFrom-SVN: r175869", "tree": {"sha": "d26efcb3f3bb2cf3b1382dd4bc39ae8709b427a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d26efcb3f3bb2cf3b1382dd4bc39ae8709b427a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a35156057510d1933a0dab5d8bd2837bfd28fa8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a35156057510d1933a0dab5d8bd2837bfd28fa8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a35156057510d1933a0dab5d8bd2837bfd28fa8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a35156057510d1933a0dab5d8bd2837bfd28fa8c/comments", "author": null, "committer": null, "parents": [{"sha": "96241349e9948c61321566dbdfc77623ca2666e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96241349e9948c61321566dbdfc77623ca2666e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96241349e9948c61321566dbdfc77623ca2666e4"}], "stats": {"total": 125, "additions": 97, "deletions": 28}, "files": [{"sha": "4b3438a51f5a1a9347772fc8ba24e7e44a80f1cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a35156057510d1933a0dab5d8bd2837bfd28fa8c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a35156057510d1933a0dab5d8bd2837bfd28fa8c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a35156057510d1933a0dab5d8bd2837bfd28fa8c", "patch": "@@ -1,3 +1,16 @@\n+2011-07-05  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/vax/vax.md (define_c_enum unspecv): New.  Define the\n+\tVUNSPEC_* constants here instead of via define_constants.\n+\t(VUNSPEC_PEM): New constant.\n+\t(procedure_entry_mask): New insn.\n+\t(prologue): New expander.\n+\t* config/vax/vax.c (vax_add_reg_cfa_offset): New.\n+\t(vax_expand_prologue): Rename from vax_output_function_prologue;\n+\temit rtl instead of text.\n+\t(TARGET_ASM_FUNCTION_PROLOGUE): Remove.\n+\t(print_operand): Add 'x' prefix.\n+\n 2011-07-05  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR middle-end/47715"}, {"sha": "3f24794331401260f70c9f46016751508b17517c", "filename": "gcc/config/vax/vax-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a35156057510d1933a0dab5d8bd2837bfd28fa8c/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a35156057510d1933a0dab5d8bd2837bfd28fa8c/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax-protos.h?ref=a35156057510d1933a0dab5d8bd2837bfd28fa8c", "patch": "@@ -20,6 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n \n extern bool legitimate_constant_address_p (rtx);\n extern bool vax_mode_dependent_address_p (rtx);\n+extern void vax_expand_prologue (void);\n \n #ifdef RTX_CODE\n extern const char *cond_name (rtx);"}, {"sha": "13a45158f94fc6c1230916805ff2203183e54d44", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 62, "deletions": 24, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a35156057510d1933a0dab5d8bd2837bfd28fa8c/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a35156057510d1933a0dab5d8bd2837bfd28fa8c/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=a35156057510d1933a0dab5d8bd2837bfd28fa8c", "patch": "@@ -48,7 +48,6 @@ along with GCC; see the file COPYING3.  If not see\n \n static void vax_option_override (void);\n static bool vax_legitimate_address_p (enum machine_mode, rtx, bool);\n-static void vax_output_function_prologue (FILE *, HOST_WIDE_INT);\n static void vax_file_start (void);\n static void vax_init_libfuncs (void);\n static void vax_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n@@ -70,9 +69,6 @@ static int vax_return_pops_args (tree, tree, int);\n #undef TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.word\\t\"\n \n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE vax_output_function_prologue\n-\n #undef TARGET_ASM_FILE_START\n #define TARGET_ASM_FILE_START vax_file_start\n #undef TARGET_ASM_FILE_START_APP_OFF\n@@ -137,6 +133,17 @@ vax_option_override (void)\n #endif\n }\n \n+static void\n+vax_add_reg_cfa_offset (rtx insn, int offset, rtx src)\n+{\n+  rtx x;\n+\n+  x = plus_constant (frame_pointer_rtx, offset);\n+  x = gen_rtx_MEM (SImode, x);\n+  x = gen_rtx_SET (VOIDmode, x, src);\n+  add_reg_note (insn, REG_CFA_OFFSET, x);\n+}\n+\n /* Generate the assembly code for function entry.  FILE is a stdio\n    stream to output the code to.  SIZE is an int: how many units of\n    temporary storage to allocate.\n@@ -146,38 +153,67 @@ vax_option_override (void)\n    used in the function.  This function is responsible for knowing\n    which registers should not be saved even if used.  */\n \n-static void\n-vax_output_function_prologue (FILE * file, HOST_WIDE_INT size)\n+void\n+vax_expand_prologue (void)\n {\n-  int regno;\n+  int regno, offset;\n   int mask = 0;\n+  HOST_WIDE_INT size;\n+  rtx insn;\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n       mask |= 1 << regno;\n \n-  fprintf (file, \"\\t.word 0x%x\\n\", mask);\n+  insn = emit_insn (gen_procedure_entry_mask (GEN_INT (mask)));\n+  RTX_FRAME_RELATED_P (insn) = 1;\n \n-  if (dwarf2out_do_frame ())\n-    {\n-      const char *label = dwarf2out_cfi_label (false);\n-      int offset = 0;\n+  /* The layout of the CALLG/S stack frame is follows:\n \n-      for (regno = FIRST_PSEUDO_REGISTER-1; regno >= 0; --regno)\n-\tif (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n-\t  dwarf2out_reg_save (label, regno, offset -= 4);\n+\t\t<- CFA, AP\n+\tr11\n+\tr10\n+\t...\tRegisters saved as specified by MASK\n+\tr3\n+\tr2\n+\treturn-addr\n+\told fp\n+\told ap\n+\told psw\n+\tzero\n+\t\t<- FP, SP\n \n-      dwarf2out_reg_save (label, PC_REGNUM, offset -= 4);\n-      dwarf2out_reg_save (label, FRAME_POINTER_REGNUM, offset -= 4);\n-      dwarf2out_reg_save (label, ARG_POINTER_REGNUM, offset -= 4);\n-      dwarf2out_def_cfa (label, FRAME_POINTER_REGNUM, -(offset - 4));\n-    }\n+     The rest of the prologue will adjust the SP for the local frame.  */\n+\n+  vax_add_reg_cfa_offset (insn, 4, arg_pointer_rtx);\n+  vax_add_reg_cfa_offset (insn, 8, frame_pointer_rtx);\n+  vax_add_reg_cfa_offset (insn, 12, pc_rtx);\n+\n+  offset = 16;\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (mask & (1 << regno))\n+      {\n+\tvax_add_reg_cfa_offset (insn, offset, gen_rtx_REG (SImode, regno));\n+\toffset += 4;\n+      }\n+\n+  /* Because add_reg_note pushes the notes, adding this last means that\n+     it will be processed first.  This is required to allow the other\n+     notes be interpreted properly.  */\n+  add_reg_note (insn, REG_CFA_DEF_CFA,\n+\t\tplus_constant (frame_pointer_rtx, offset));\n \n+  /* Allocate the local stack frame.  */\n+  size = get_frame_size ();\n   size -= STARTING_FRAME_OFFSET;\n-  if (size >= 64)\n-    asm_fprintf (file, \"\\tmovab %wd(%Rsp),%Rsp\\n\", -size);\n-  else if (size)\n-    asm_fprintf (file, \"\\tsubl2 $%wd,%Rsp\\n\", size);\n+  emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t stack_pointer_rtx, GEN_INT (-size)));\n+\n+  /* Do not allow instructions referencing local stack memory to be\n+     scheduled before the frame is allocated.  This is more pedantic\n+     than anything else, given that VAX does not currently have a\n+     scheduling description.  */\n+  emit_insn (gen_blockage ());\n }\n \n /* When debugging with stabs, we want to output an extra dummy label\n@@ -485,6 +521,8 @@ print_operand (FILE *file, rtx x, int code)\n     fprintf (file, \"$%d\", (int) (0xff & - INTVAL (x)));\n   else if (code == 'M' && CONST_INT_P (x))\n     fprintf (file, \"$%d\", ~((1 << INTVAL (x)) - 1));\n+  else if (code == 'x' && CONST_INT_P (x))\n+    fprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (x));\n   else if (REG_P (x))\n     fprintf (file, \"%s\", reg_names[REGNO (x)]);\n   else if (MEM_P (x))"}, {"sha": "32f50fd33679b9e3b4c8bae4b0eeb2102c16a245", "filename": "gcc/config/vax/vax.md", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a35156057510d1933a0dab5d8bd2837bfd28fa8c/gcc%2Fconfig%2Fvax%2Fvax.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a35156057510d1933a0dab5d8bd2837bfd28fa8c/gcc%2Fconfig%2Fvax%2Fvax.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.md?ref=a35156057510d1933a0dab5d8bd2837bfd28fa8c", "patch": "@@ -29,11 +29,15 @@\n \n ;; UNSPEC_VOLATILE usage:\n \n-(define_constants\n-  [(VUNSPEC_BLOCKAGE 0)\t    ; `blockage' insn to prevent scheduling across an\n+(define_c_enum \"unspecv\" [\n+  VUNSPEC_BLOCKAGE \t    ; 'blockage' insn to prevent scheduling across an\n \t\t\t    ; insn in the code.\n-   (VUNSPEC_SYNC_ISTREAM 1) ; sequence of insns to sync the I-stream\n-   (VAX_AP_REGNUM 12)\t    ; Register 12 contains the argument pointer\n+  VUNSPEC_SYNC_ISTREAM      ; sequence of insns to sync the I-stream\n+  VUNSPEC_PEM\t\t    ; 'procedure_entry_mask' insn.\n+])\n+\n+(define_constants\n+  [(VAX_AP_REGNUM 12)\t    ; Register 12 contains the argument pointer\n    (VAX_FP_REGNUM 13)\t    ; Register 13 contains the frame pointer\n    (VAX_SP_REGNUM 14)\t    ; Register 14 contains the stack pointer\n    (VAX_PC_REGNUM 15)\t    ; Register 15 contains the program counter\n@@ -1409,11 +1413,24 @@\n   \"\"\n   \"\")\n \n+(define_insn \"procedure_entry_mask\"\n+  [(unspec_volatile [(match_operand 0 \"const_int_operand\")] VUNSPEC_PEM)]\n+  \"\"\n+  \".word %x0\")\n+\n (define_insn \"return\"\n   [(return)]\n   \"\"\n   \"ret\")\n \n+(define_expand \"prologue\"\n+  [(const_int 0)]\n+  \"\"\n+{\n+  vax_expand_prologue ();\n+  DONE;\n+})\n+\n (define_expand \"epilogue\"\n   [(return)]\n   \"\""}]}