{"sha": "6e3f07241c343ba0d1c2023af0be57704d93a5be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUzZjA3MjQxYzM0M2JhMGQxYzIwMjNhZjBiZTU3NzA0ZDkzYTViZQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-23T02:20:18Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-23T02:20:18Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r822", "tree": {"sha": "6c522ec05e3993be4154cf581fe03905c95f2968", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c522ec05e3993be4154cf581fe03905c95f2968"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e3f07241c343ba0d1c2023af0be57704d93a5be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e3f07241c343ba0d1c2023af0be57704d93a5be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e3f07241c343ba0d1c2023af0be57704d93a5be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e3f07241c343ba0d1c2023af0be57704d93a5be/comments", "author": null, "committer": null, "parents": [{"sha": "8e148befe9b2356cc3390b04b8fc20c0a61a4e29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e148befe9b2356cc3390b04b8fc20c0a61a4e29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e148befe9b2356cc3390b04b8fc20c0a61a4e29"}], "stats": {"total": 160, "additions": 84, "deletions": 76}, "files": [{"sha": "b335dce09955c5863aa1b19f5e8c34b1c7897eee", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 84, "deletions": 76, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e3f07241c343ba0d1c2023af0be57704d93a5be/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e3f07241c343ba0d1c2023af0be57704d93a5be/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=6e3f07241c343ba0d1c2023af0be57704d93a5be", "patch": "@@ -478,8 +478,8 @@ get_static_reference (interface)\n static tree\n create_builtin_decl (code, type, name)\n      enum tree_code code;\n-     char *name;\n      tree type;\n+     char *name;\n {\n   tree decl = build_decl (code, get_identifier (name), type);\n   if (code == VAR_DECL)\n@@ -744,7 +744,7 @@ forward_declare_categories ()\n \t  implementation_context = impent->imp_context;\n \t  impent->class_decl\n \t    = create_builtin_decl (VAR_DECL, objc_category_template,\n-\t\t\t\t   synth_id_with_class_suffix (\"_OBJC_CATEGORY\"));\n+\t\t\t\t   IDENTIFIER_POINTER (synth_id_with_class_suffix (\"_OBJC_CATEGORY\")));\n \t}\n     }\n   implementation_context = sav;\n@@ -2284,15 +2284,27 @@ static tree\n synth_id_with_class_suffix (preamble)\n      char *preamble;\n {\n+  char *string;\n   if (TREE_CODE (implementation_context) == IMPLEMENTATION_TYPE)\n-    sprintf (utlbuf, \"%s_%s\", preamble,\n-\t     IDENTIFIER_POINTER (CLASS_NAME (implementation_context)));\n+    {\n+      string = (char *) alloca (strlen (preamble)\n+\t\t\t\t+ strlen (IDENTIFIER_POINTER (CLASS_NAME (implementation_context)))\n+\t\t\t\t+ 3);\n+      sprintf (string, \"%s_%s\", preamble,\n+\t       IDENTIFIER_POINTER (CLASS_NAME (implementation_context)));\n+    }\n   else\n-    /* we have a category */\n-    sprintf (utlbuf, \"%s_%s_%s\", preamble,\n-\t     IDENTIFIER_POINTER (CLASS_NAME (implementation_context)),\n-\t     IDENTIFIER_POINTER (CLASS_SUPER_NAME (implementation_context)));\n-  return get_identifier (utlbuf);\n+    {\n+      /* we have a category */\n+      string = (char *) alloca (strlen (preamble)\n+\t\t\t\t+ strlen (IDENTIFIER_POINTER (CLASS_NAME (implementation_context)))\n+\t\t\t\t+ strlen (IDENTIFIER_POINTER (CLASS_SUPER_NAME (implementation_context)))\n+\t\t\t\t+ 3);\n+      sprintf (string, \"%s_%s_%s\", preamble,\n+\t       IDENTIFIER_POINTER (CLASS_NAME (implementation_context)),\n+\t       IDENTIFIER_POINTER (CLASS_SUPER_NAME (implementation_context)));\n+    }\n+  return get_identifier (string);\n }\n \n /*\n@@ -3594,21 +3606,29 @@ finish_class (class)\n   else if (TREE_CODE (class) == INTERFACE_TYPE)\n     {\n       tree decl_specs;\n+      char *string = (char *) alloca (strlen (IDENTIFIER_POINTER (CLASS_NAME (class))) + 3);\n \n       /* extern struct objc_object *_<my_name>; */\n \n-      sprintf (utlbuf, \"_%s\", IDENTIFIER_POINTER (CLASS_NAME (class)));\n+      sprintf (string, \"_%s\", IDENTIFIER_POINTER (CLASS_NAME (class)));\n \n       decl_specs = build_tree_list (NULLT, ridpointers[(int) RID_EXTERN]);\n       decl_specs = tree_cons (NULLT, objc_object_reference, decl_specs);\n-      define_decl (build1 (INDIRECT_REF, NULLT, get_identifier (utlbuf)), decl_specs);\n+      define_decl (build1 (INDIRECT_REF, NULLT, get_identifier (string)),\n+\t\t   decl_specs);\n     }\n }\n \f\n+/* \"Encode\" a data type into a string, whichg rows  in util_obstack.\n+   ??? What is the FORMAT?  */\n+\n+#error rms is in middle of changing this part\n+\n+/* Encode a pointer type.  */\n+\n static void\n-encode_pointer (type, str, format)\n+encode_pointer (type, format)\n      tree type;\n-     char *str;\n      int format;\n {\n   tree pointer_to = TREE_TYPE (type);\n@@ -3620,21 +3640,21 @@ encode_pointer (type, str, format)\n \t{\n \t  char *name = IDENTIFIER_POINTER (TYPE_NAME (pointer_to));\n \n-\t  if ((strcmp (name, TAG_OBJECT) == 0) || /* '@' */\n-\t      (TREE_STATIC_TEMPLATE (pointer_to)))\n+\t  if ((strcmp (name, TAG_OBJECT) == 0) /* '@' */\n+\t      || TREE_STATIC_TEMPLATE (pointer_to))\n \t    {\n-\t      strcat (str, \"@\");\n+\t      obstack_1grow (&util_obstack, '@');\n \t      return;\n \t    }\n \t  else if (strcmp (name, TAG_CLASS) == 0) /* '#' */\n \t    {\n-\t      strcat (str, \"#\");\n+\t      obstack_1grow (&util_obstack, '#');\n \t      return;\n \t    }\n #ifndef OBJC_INT_SELECTORS\n \t  else if (strcmp (name, TAG_SELECTOR) == 0) /* ':' */\n \t    {\n-\t      strcat (str, \":\");\n+\t      obstack_1grow (&util_obstack, ':');\n \t      return;\n \t    }\n #endif /* OBJC_INT_SELECTORS */\n@@ -3643,46 +3663,46 @@ encode_pointer (type, str, format)\n   else if (TREE_CODE (pointer_to) == INTEGER_TYPE\n \t   && TYPE_MODE (pointer_to) == QImode)\n     {\n-      strcat (str, \"*\");\n+      obstack_1grow (&util_obstack, '*');\n       return;\n     }\n \n   /* we have a type that does not get special treatment... */\n \n   /* NeXT extension */\n-  strcat (str, \"^\");\n+  obstack_1grow (&util_obstack, '^');\n   encode_type (pointer_to, str, format);\n }\n \n static void\n-encode_array (type, str, format)\n+encode_array (type, format)\n      tree type;\n-     char *str;\n      int format;\n {\n   tree anIntCst = TYPE_SIZE (type);\n   tree array_of = TREE_TYPE (type);\n+  char buffer[40];\n \n   /* An incomplete array is treated like a pointer.  */\n   if (anIntCst == NULL)\n     {\n       /* split for obvious reasons.  North-Keys 30 Mar 1991 */\n-      encode_pointer (type, str, format);\n+      encode_pointer (type, format);\n       return;\n     }\n   \n-  sprintf (str + strlen (str), \"[%d\",\n+  sprintf (buffer, \"[%d\",\n \t   TREE_INT_CST_LOW (anIntCst)\n \t   / TREE_INT_CST_LOW (TYPE_SIZE (array_of)));\n-  encode_type (array_of, str, format);\n-  strcat (str, \"]\");\n+  obstack_grow (&util_obstack, buffer, strlen (buffer));\n+  encode_type (array_of, format);\n+  obstack_1grow (&util_obstack, ']');\n   return;\n }\n \f\n static void\n-encode_aggregate (type, str, format)\n+encode_aggregate (type, format)\n      tree type;\n-     char *str;\n      int format;\n {\n   enum tree_code code = TREE_CODE (type);\n@@ -3691,77 +3711,65 @@ encode_aggregate (type, str, format)\n     {\n     case RECORD_TYPE:\n       {\n-\tif (str[strlen (str)-1] == '^')\n+\tif (*obstack_next_free (&util_obstack) == '^'\n+\t    || format !=  OBJC_ENCODE_INLINE_DEFS)\n \t  {\n-\t    /* we have a reference - this is a NeXT extension */\n+\t    /* we have a reference - this is a NeXT extension--\n+\t       or we don't want the details.  */\n             if (TYPE_NAME (type)\n \t\t&& (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE))\n-\t      sprintf (str + strlen (str), \"{%s}\",\n-\t\t       IDENTIFIER_POINTER (TYPE_NAME (type)));\n-\t    else\t\t/* we have an untagged structure or a typedef */\n-\t      sprintf (str + strlen (str), \"{?}\");\n+\t      {\n+\t\tobstack_1grow (&util_obstack, '{');\n+\t\tobstack_grow (&util_obstack,\n+\t\t\t      IDENTIFIER_POINTER (TYPE_NAME (type)),\n+\t\t\t      strlen (IDENTIFIER_POINTER (TYPE_NAME (type))));\n+\t\tobstack_1grow (&util_obstack, '}');\n+\t      }\n+\t    else /* we have an untagged structure or a typedef */\n+\t      obstack_grow (&util_obstack, \"{?}\");\n \t  }\n \telse\n \t  {\n \t    tree fields = TYPE_FIELDS (type);\n-\n-            if (format == OBJC_ENCODE_INLINE_DEFS)\n-              {\n-\t\tstrcat (str, \"{\");\n-\t\tfor ( ; fields; fields = TREE_CHAIN (fields))\n-\t\t  encode_field_decl (fields, str, format);\n-\t\tstrcat (str, \"}\");\n-              }\n-            else\n-              {\n-\t\tif (TYPE_NAME (type)\n-\t\t    && (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE))\n-\t\t  sprintf (str + strlen (str), \"{%s}\",\n-\t\t\t   IDENTIFIER_POINTER (TYPE_NAME (type)));\n-\t\telse\t\t/* we have an untagged structure or a typedef */\n-\t\t  sprintf (str + strlen (str), \"{?}\");\n-              }\n+\t    obstack_1grow (&util_obstack, '{');\n+\t    for ( ; fields; fields = TREE_CHAIN (fields))\n+\t      encode_field_decl (fields, format);\n+\t    obstack_1grow (&util_obstack, '}');\n \t  }\n \tbreak;\n       }\n     case UNION_TYPE:\n       {\n-\tif (str[strlen (str)-1] == '^')\n+\tif (*obstack_next_free (&util_obstack) == '^'\n+\t    || format !=  OBJC_ENCODE_INLINE_DEFS)\n \t  {\n+\t    /* we have a reference - this is a NeXT extension--\n+\t       or we don't want the details.  */\n             if (TYPE_NAME (type)\n \t\t&& (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE))\n-\t      /* we have a reference - this is a NeXT extension */\n-\t      sprintf (str + strlen (str), \"(%s)\",\n-\t\t       IDENTIFIER_POINTER (TYPE_NAME (type)));\n-\t    else\t\t/* we have an untagged structure */\n-\t      sprintf (str + strlen (str), \"(?)\");\n+\t      {\n+\t\tobstack_1grow (&util_obstack, '<');\n+\t\tobstack_grow (&util_obstack,\n+\t\t\t      IDENTIFIER_POINTER (TYPE_NAME (type)),\n+\t\t\t      strlen (IDENTIFIER_POINTER (TYPE_NAME (type))));\n+\t\tobstack_1grow (&util_obstack, '>');\n+\t      }\n+\t    else /* we have an untagged structure or a typedef */\n+\t      obstack_grow (&util_obstack, \"<?>\");\n \t  }\n \telse\n \t  {\n \t    tree fields = TYPE_FIELDS (type);\n-\n-            if (format == OBJC_ENCODE_INLINE_DEFS)\n-              {\n-\t\tstrcat (str, \"(\");\n-\t\tfor ( ; fields; fields = TREE_CHAIN (fields))\n-\t\t  encode_field_decl (fields, str, format);\n-\t\tstrcat (str, \")\");\n-              }\n-            else\n-              {\n-\t\tif (TYPE_NAME (type) &&\n-\t\t    (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE))\n-\t\t  /* we have a reference - this is a NeXT extension */\n-\t\t  sprintf (str + strlen (str), \"(%s)\",\n-\t\t\t   IDENTIFIER_POINTER (TYPE_NAME (type)));\n-\t\telse\t\t/* we have an untagged structure */\n-\t\t  sprintf (str + strlen (str), \"(?)\");\n-              }\n+\t    obstack_1grow (&util_obstack, '<');\n+\t    for ( ; fields; fields = TREE_CHAIN (fields))\n+\t      encode_field_decl (fields, format);\n+\t    obstack_1grow (&util_obstack, '>');\n \t  }\n \tbreak;\n       }\n+\n     case ENUMERAL_TYPE:\n-      strcat (str, \"i\");\n+      obstack_1grow (&util_obstack, 'i');\n       break;\n     }\n }"}]}