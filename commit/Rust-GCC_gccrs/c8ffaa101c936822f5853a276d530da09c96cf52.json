{"sha": "c8ffaa101c936822f5853a276d530da09c96cf52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzhmZmFhMTAxYzkzNjgyMmY1ODUzYTI3NmQ1MzBkYTA5Yzk2Y2Y1Mg==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-14T15:00:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-14T15:00:47Z"}, "message": "Merge #672\n\n672: Initial autoderef support for method calls r=philberty a=philberty\n\nThe commit message contains more detail but this reference is good:\r\nhttps://doc.rust-lang.org/nightly/nomicon/dot-operator.html\r\n\r\nThis is not 100% complete since we do not yet support operator overloading\r\nso we will require an update to support the Deref operator overload for\r\nmore complex types.\r\n\r\nFixes: #241\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "d393eecd5333696158e868e907ae93f7530de8ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d393eecd5333696158e868e907ae93f7530de8ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8ffaa101c936822f5853a276d530da09c96cf52", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhQLkfCRBK7hj4Ov3rIwAAvcAIAEah7LFijdSJId6zVof3iVlW\neO+so2xNubMglzgY+rB0+MKTQzWbY8BVOfeF9wVXtKoCYTDLV+4gwvJJMJthE5dH\nAvOHH2Mv6GeGHX0KoX3UOO73InixUecsWforTKOZW12q7x0QL3ixfsDtmQ/vsGKp\nJgcPHQvi3nNThYsOKCvlY9629PtX4dLqcZLCXxIvp8sbOWjQE+v93wpo+3xdYMjE\nF3LeigywJCBvkUO6dTZsjKCu4XEcSciH5NySf/yl0ktWqWrZaJSy1K0OEv7Avbo2\nE5kbt7HhZKqDU3OibgXB3BWOb4DYzqqfhDnTKTofeKtinOSxtT8nSqwbfQ3FC3o=\n=opzK\n-----END PGP SIGNATURE-----\n", "payload": "tree d393eecd5333696158e868e907ae93f7530de8ec\nparent c644ee4c4351e3590f5396e94ec24ad7b828a954\nparent 002313b343746f8c72b62522e48e04fa0953b2d0\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1631631647 +0000\ncommitter GitHub <noreply@github.com> 1631631647 +0000\n\nMerge #672\n\n672: Initial autoderef support for method calls r=philberty a=philberty\n\nThe commit message contains more detail but this reference is good:\r\nhttps://doc.rust-lang.org/nightly/nomicon/dot-operator.html\r\n\r\nThis is not 100% complete since we do not yet support operator overloading\r\nso we will require an update to support the Deref operator overload for\r\nmore complex types.\r\n\r\nFixes: #241\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8ffaa101c936822f5853a276d530da09c96cf52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8ffaa101c936822f5853a276d530da09c96cf52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8ffaa101c936822f5853a276d530da09c96cf52/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c644ee4c4351e3590f5396e94ec24ad7b828a954", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c644ee4c4351e3590f5396e94ec24ad7b828a954", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c644ee4c4351e3590f5396e94ec24ad7b828a954"}, {"sha": "002313b343746f8c72b62522e48e04fa0953b2d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/002313b343746f8c72b62522e48e04fa0953b2d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/002313b343746f8c72b62522e48e04fa0953b2d0"}], "stats": {"total": 525, "additions": 481, "deletions": 44}, "files": [{"sha": "5214b1d9c967a57ffa05b0652a2766d61b082392", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=c8ffaa101c936822f5853a276d530da09c96cf52", "patch": "@@ -277,6 +277,32 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n   // method receiver\n   Bexpression *self = CompileExpr::Compile (expr.get_receiver ().get (), ctx);\n   rust_assert (self != nullptr);\n+\n+  // lookup the autoderef mappings\n+  std::vector<Resolver::Adjustment> *adjustments = nullptr;\n+  ok = ctx->get_tyctx ()->lookup_autoderef_mappings (\n+    expr.get_mappings ().get_hirid (), &adjustments);\n+  rust_assert (ok);\n+\n+  for (auto &adjustment : *adjustments)\n+    {\n+      switch (adjustment.get_type ())\n+\t{\n+\tcase Resolver::Adjustment::AdjustmentType::IMM_REF:\n+\tcase Resolver::Adjustment::AdjustmentType::MUT_REF:\n+\t  self = ctx->get_backend ()->address_expression (\n+\t    self, expr.get_receiver ()->get_locus ());\n+\t  break;\n+\n+\tcase Resolver::Adjustment::AdjustmentType::DEREF_REF:\n+\t  Btype *expected_type\n+\t    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n+\t  self = ctx->get_backend ()->indirect_expression (\n+\t    expected_type, self, true, /* known_valid*/\n+\t    expr.get_receiver ()->get_locus ());\n+\t  break;\n+\t}\n+    }\n   args.push_back (self);\n \n   // normal args"}, {"sha": "5c70b2cbad486d751495096b6911a9d28256c8d4", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=c8ffaa101c936822f5853a276d530da09c96cf52", "patch": "@@ -403,17 +403,26 @@ ASTLoweringBase::lower_generic_args (AST::GenericArgs &args)\n HIR::SelfParam\n ASTLoweringBase::lower_self (AST::SelfParam &self)\n {\n-  HIR::Type *type = self.has_type ()\n-\t\t      ? ASTLoweringType::translate (self.get_type ().get ())\n-\t\t      : nullptr;\n-\n   auto crate_num = mappings->get_current_crate ();\n   Analysis::NodeMapping mapping (crate_num, self.get_node_id (),\n \t\t\t\t mappings->get_next_hir_id (crate_num),\n \t\t\t\t mappings->get_next_localdef_id (crate_num));\n \n-  return HIR::SelfParam (mapping, std::unique_ptr<HIR::Type> (type),\n-\t\t\t self.get_is_mut (), self.get_locus ());\n+  if (self.has_type ())\n+    {\n+      HIR::Type *type = ASTLoweringType::translate (self.get_type ().get ());\n+      return HIR::SelfParam (mapping, std::unique_ptr<HIR::Type> (type),\n+\t\t\t     self.get_is_mut (), self.get_locus ());\n+    }\n+  else if (!self.get_has_ref ())\n+    {\n+      return HIR::SelfParam (mapping, std::unique_ptr<HIR::Type> (nullptr),\n+\t\t\t     self.get_is_mut (), self.get_locus ());\n+    }\n+\n+  AST::Lifetime l = self.get_lifetime ();\n+  return HIR::SelfParam (mapping, lower_lifetime (l), self.get_is_mut (),\n+\t\t\t self.get_locus ());\n }\n \n void"}, {"sha": "0b2cf10ab69675d4bd55c2d6e3527f437e5c94ac", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=c8ffaa101c936822f5853a276d530da09c96cf52", "patch": "@@ -310,10 +310,10 @@ struct SelfParam\n public:\n   enum ImplicitSelfKind\n   {\n-    IMM,\n-    MUT,\n-    IMM_REF,\n-    MUT_REF,\n+    IMM,     // self\n+    MUT,     // mut self\n+    IMM_REF, // &self\n+    MUT_REF, // &mut self\n     NONE\n   };\n "}, {"sha": "7a9083d1287f15af7ac3ebb98e787596e106b8e9", "filename": "gcc/rust/typecheck/rust-autoderef.h", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h?ref=c8ffaa101c936822f5853a276d530da09c96cf52", "patch": "@@ -0,0 +1,74 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AUTODEREF\n+#define RUST_AUTODEREF\n+\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class Adjustment\n+{\n+public:\n+  enum AdjustmentType\n+  {\n+    IMM_REF,\n+    MUT_REF,\n+    DEREF_REF\n+  };\n+\n+  Adjustment (AdjustmentType type, TyTy::BaseType *expected)\n+    : type (type), expected (expected)\n+  {}\n+\n+  AdjustmentType get_type () const { return type; }\n+\n+  TyTy::BaseType *get_expected () const { return expected; }\n+\n+  std::string as_string () const\n+  {\n+    return Adjustment::type_string (get_type ()) + \"->\"\n+\t   + get_expected ()->debug_str ();\n+  }\n+\n+  static std::string type_string (AdjustmentType type)\n+  {\n+    switch (type)\n+      {\n+      case AdjustmentType::IMM_REF:\n+\treturn \"IMM_REF\";\n+      case AdjustmentType::MUT_REF:\n+\treturn \"MUT_REF\";\n+      case AdjustmentType::DEREF_REF:\n+\treturn \"DEREF_REF\";\n+      }\n+    gcc_unreachable ();\n+    return \"\";\n+  }\n+\n+private:\n+  AdjustmentType type;\n+  TyTy::BaseType *expected;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AUTODEREF"}, {"sha": "6743862cd51dd904c5242f3d20ffc70b2397bc26", "filename": "gcc/rust/typecheck/rust-hir-dot-operator.h", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h?ref=c8ffaa101c936822f5853a276d530da09c96cf52", "patch": "@@ -0,0 +1,182 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_DOT_OPERATOR\n+#define RUST_HIR_DOT_OPERATOR\n+\n+#include \"rust-hir-path-probe.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+// lookup if method exists for current type\n+// if exists: done\n+// if not: check again for auto-ref and auto-mut-ref\n+// deref and start again with 1.*/\n+\n+// https://doc.rust-lang.org/nightly/nomicon/dot-operator.html\n+\n+class MethodResolution\n+{\n+public:\n+  static PathProbeCandidate *\n+  Select (std::vector<PathProbeCandidate> &candidates, TyTy::BaseType *receiver,\n+\t  std::vector<Adjustment> &adjustments)\n+  {\n+    TyTy::BaseType *r = receiver;\n+    while (true)\n+      {\n+\tPathProbeCandidate *c = nullptr;\n+\n+\t// 1. try raw\n+\tc = Try (candidates, r);\n+\tif (c != nullptr)\n+\t  return c;\n+\n+\t// 2. try ref\n+\tTyTy::ReferenceType *r1\n+\t  = new TyTy::ReferenceType (r->get_ref (), TyTy::TyVar (r->get_ref ()),\n+\t\t\t\t     false);\n+\tc = Try (candidates, r1);\n+\tif (c != nullptr)\n+\t  {\n+\t    adjustments.push_back (\n+\t      Adjustment (Adjustment::AdjustmentType::IMM_REF, r1));\n+\t    return c;\n+\t  }\n+\n+\t// 3. try mut ref\n+\tTyTy::ReferenceType *r2\n+\t  = new TyTy::ReferenceType (r->get_ref (), TyTy::TyVar (r->get_ref ()),\n+\t\t\t\t     true);\n+\tc = Try (candidates, r2);\n+\tif (c != nullptr)\n+\t  {\n+\t    adjustments.push_back (\n+\t      Adjustment (Adjustment::AdjustmentType::MUT_REF, r2));\n+\t    return c;\n+\t  }\n+\n+\t// 4. deref to to 1, if cannot deref then quit\n+\tbool can_deref = r->get_kind () == TyTy::TypeKind::REF;\n+\tif (!can_deref)\n+\t  return nullptr;\n+\n+\t// FIXME this needs to use deref trait and fall back to unsized to\n+\t// remove array syntax\n+\n+\tTyTy::ReferenceType *rr = static_cast<TyTy::ReferenceType *> (r);\n+\tr = rr->get_base ();\n+\tadjustments.push_back (\n+\t  Adjustment (Adjustment::AdjustmentType::DEREF_REF, r));\n+      }\n+    return nullptr;\n+  }\n+\n+private:\n+  static PathProbeCandidate *Try (std::vector<PathProbeCandidate> &candidates,\n+\t\t\t\t  const TyTy::BaseType *receiver)\n+  {\n+    TypeCheckContext *context = TypeCheckContext::get ();\n+\n+    // probe impls\n+    for (auto &c : candidates)\n+      {\n+\tbool is_func = c.type == PathProbeCandidate::CandidateType::IMPL_FUNC;\n+\tHIR::ImplBlock *block = c.item.impl.parent;\n+\tif (is_func && !block->has_trait_ref ())\n+\t  {\n+\t    HIR::Function *func\n+\t      = static_cast<HIR::Function *> (c.item.impl.impl_item);\n+\n+\t    TyTy::BaseType *lookup = nullptr;\n+\t    bool ok = context->lookup_type (func->get_mappings ().get_hirid (),\n+\t\t\t\t\t    &lookup);\n+\t    rust_assert (ok);\n+\t    rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+\n+\t    TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n+\t    if (fn->is_method ())\n+\t      {\n+\t\tTyTy::BaseType *fn_self = fn->get_self_type ();\n+\t\tif (receiver->can_eq (fn_self, false))\n+\t\t  {\n+\t\t    return &c;\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+\n+    // probe trait impls\n+    for (auto &c : candidates)\n+      {\n+\tbool is_func = c.type == PathProbeCandidate::CandidateType::IMPL_FUNC;\n+\tHIR::ImplBlock *block = c.item.impl.parent;\n+\tif (is_func && block->has_trait_ref ())\n+\t  {\n+\t    HIR::Function *func\n+\t      = static_cast<HIR::Function *> (c.item.impl.impl_item);\n+\n+\t    TyTy::BaseType *lookup = nullptr;\n+\t    bool ok = context->lookup_type (func->get_mappings ().get_hirid (),\n+\t\t\t\t\t    &lookup);\n+\t    rust_assert (ok);\n+\t    rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+\n+\t    TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n+\t    if (fn->is_method ())\n+\t      {\n+\t\tTyTy::BaseType *fn_self = fn->get_self_type ();\n+\t\tif (receiver->can_eq (fn_self, false))\n+\t\t  {\n+\t\t    return &c;\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+\n+    // probe trait bounds\n+    for (auto &c : candidates)\n+      {\n+\tbool is_func = c.type == PathProbeCandidate::CandidateType::TRAIT_FUNC;\n+\tif (is_func)\n+\t  {\n+\t    const TraitItemReference *item_ref = c.item.trait.item_ref;\n+\t    TyTy::BaseType *lookup = item_ref->get_tyty ();\n+\t    rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+\n+\t    TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n+\t    if (fn->is_method ())\n+\t      {\n+\t\tTyTy::BaseType *fn_self = fn->get_self_type ();\n+\t\tif (receiver->can_eq (fn_self, false))\n+\t\t  {\n+\t\t    return &c;\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+\n+    return nullptr;\n+  }\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_DOT_OPERATOR"}, {"sha": "07d4f9082f4074df96277de76c589c9f6b9eadaa", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 39, "deletions": 21, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=c8ffaa101c936822f5853a276d530da09c96cf52", "patch": "@@ -30,6 +30,7 @@\n #include \"rust-hir-const-fold.h\"\n #include \"rust-hir-trait-resolve.h\"\n #include \"rust-hir-type-bounds.h\"\n+#include \"rust-hir-dot-operator.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -207,7 +208,7 @@ class TypeCheckExpr : public TypeCheckBase\n   {\n     auto receiver_tyty\n       = TypeCheckExpr::Resolve (expr.get_receiver ().get (), false);\n-    if (receiver_tyty == nullptr)\n+    if (receiver_tyty->get_kind () == TyTy::TypeKind::ERROR)\n       {\n \trust_error_at (expr.get_receiver ()->get_locus (),\n \t\t       \"failed to resolve receiver in MethodCallExpr\");\n@@ -216,50 +217,67 @@ class TypeCheckExpr : public TypeCheckBase\n \n     context->insert_receiver (expr.get_mappings ().get_hirid (), receiver_tyty);\n \n+    // in order to probe of the correct type paths we need the root type, which\n+    // strips any references\n+    TyTy::BaseType *root = receiver_tyty->get_root ();\n+\n     // https://doc.rust-lang.org/reference/expressions/method-call-expr.html\n     // method resolution is complex in rust once we start handling generics and\n     // traits. For now we only support looking up the valid name in impl blocks\n     // which is simple. There will need to be adjustments to ensure we can turn\n     // the receiver into borrowed references etc\n \n-    bool reciever_is_generic\n-      = receiver_tyty->get_kind () == TyTy::TypeKind::PARAM;\n+    bool reciever_is_generic = root->get_kind () == TyTy::TypeKind::PARAM;\n     bool probe_bounds = true;\n     bool probe_impls = !reciever_is_generic;\n     bool ignore_mandatory_trait_items = !reciever_is_generic;\n \n     auto candidates\n-      = PathProbeType::Probe (receiver_tyty,\n-\t\t\t      expr.get_method_name ().get_segment (),\n+      = PathProbeType::Probe (root, expr.get_method_name ().get_segment (),\n \t\t\t      probe_impls, probe_bounds,\n \t\t\t      ignore_mandatory_trait_items);\n-    if (candidates.size () == 0)\n+    if (candidates.empty ())\n       {\n \trust_error_at (expr.get_locus (),\n-\t\t       \"failed to resolve the PathExprSegment to any Method\");\n+\t\t       \"failed to resolve the PathExprSegment to any item\");\n \treturn;\n       }\n-    else if (candidates.size () > 1)\n+\n+    std::vector<Adjustment> adjustments;\n+    PathProbeCandidate *resolved_candidate\n+      = MethodResolution::Select (candidates, receiver_tyty, adjustments);\n+    if (resolved_candidate == nullptr)\n       {\n-\tReportMultipleCandidateError::Report (\n-\t  candidates, expr.get_method_name ().get_segment (),\n-\t  expr.get_method_name ().get_locus ());\n+\tif (candidates.size () > 1)\n+\t  {\n+\t    // not sure if this is the correct error here\n+\t    ReportMultipleCandidateError::Report (\n+\t      candidates, expr.get_method_name ().get_segment (),\n+\t      expr.get_method_name ().get_locus ());\n+\t  }\n+\telse\n+\t  {\n+\t    rust_error_at (expr.get_locus (), \"failed to resolve method\");\n+\t  }\n \treturn;\n       }\n \n-    auto resolved_candidate = candidates.at (0);\n-    TyTy::BaseType *lookup_tyty = resolved_candidate.ty;\n+    // store the adjustments for code-generation to know what to do\n+    context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\tstd::move (adjustments));\n+\n+    TyTy::BaseType *lookup_tyty = resolved_candidate->ty;\n     NodeId resolved_node_id\n-      = resolved_candidate.is_impl_candidate ()\n-\t  ? resolved_candidate.item.impl.impl_item->get_impl_mappings ()\n+      = resolved_candidate->is_impl_candidate ()\n+\t  ? resolved_candidate->item.impl.impl_item->get_impl_mappings ()\n \t      .get_nodeid ()\n-\t  : resolved_candidate.item.trait.item_ref->get_mappings ()\n+\t  : resolved_candidate->item.trait.item_ref->get_mappings ()\n \t      .get_nodeid ();\n \n     if (lookup_tyty->get_kind () != TyTy::TypeKind::FNDEF)\n       {\n \tRichLocation r (expr.get_method_name ().get_locus ());\n-\tr.add_range (resolved_candidate.locus);\n+\tr.add_range (resolved_candidate->locus);\n \trust_error_at (r, \"associated impl item is not a method\");\n \treturn;\n       }\n@@ -269,14 +287,14 @@ class TypeCheckExpr : public TypeCheckBase\n     if (!fn->is_method ())\n       {\n \tRichLocation r (expr.get_method_name ().get_locus ());\n-\tr.add_range (resolved_candidate.locus);\n+\tr.add_range (resolved_candidate->locus);\n \trust_error_at (r, \"associated function is not a method\");\n \treturn;\n       }\n \n-    if (receiver_tyty->get_kind () == TyTy::TypeKind::ADT)\n+    if (root->get_kind () == TyTy::TypeKind::ADT)\n       {\n-\tTyTy::ADTType *adt = static_cast<TyTy::ADTType *> (receiver_tyty);\n+\tTyTy::ADTType *adt = static_cast<TyTy::ADTType *> (root);\n \tif (adt->has_substitutions () && fn->needs_substitution ())\n \t  {\n \t    // consider the case where we have:\n@@ -298,7 +316,7 @@ class TypeCheckExpr : public TypeCheckBase\n \t    // default types GenericParams on impl blocks since these must\n \t    // always be at the end of the list\n \n-\t    auto s = fn->get_self_type ();\n+\t    auto s = fn->get_self_type ()->get_root ();\n \t    rust_assert (s->can_eq (adt, false));\n \t    rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n \t    TyTy::ADTType *self_adt = static_cast<TyTy::ADTType *> (s);"}, {"sha": "94674ad2190fe65551474653e87e0f585574282e", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=c8ffaa101c936822f5853a276d530da09c96cf52", "patch": "@@ -220,10 +220,45 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n \tHIR::IdentifierPattern *self_pattern = new HIR::IdentifierPattern (\n \t  \"self\", self_param.get_locus (), self_param.is_ref (),\n \t  self_param.is_mut (), std::unique_ptr<HIR::Pattern> (nullptr));\n-\tcontext->insert_type (self_param.get_mappings (), self->clone ());\n+\n+\t// might have a specified type\n+\tTyTy::BaseType *self_type = nullptr;\n+\tif (self_param.has_type ())\n+\t  {\n+\t    std::unique_ptr<HIR::Type> &specified_type = self_param.get_type ();\n+\t    self_type = TypeCheckType::Resolve (specified_type.get ());\n+\t  }\n+\telse\n+\t  {\n+\t    switch (self_param.get_self_kind ())\n+\t      {\n+\t      case HIR::SelfParam::IMM:\n+\t      case HIR::SelfParam::MUT:\n+\t\tself_type = self->clone ();\n+\t\tbreak;\n+\n+\t      case HIR::SelfParam::IMM_REF:\n+\t\tself_type = new TyTy::ReferenceType (\n+\t\t  self_param.get_mappings ().get_hirid (),\n+\t\t  TyTy::TyVar (self->get_ref ()), false);\n+\t\tbreak;\n+\n+\t      case HIR::SelfParam::MUT_REF:\n+\t\tself_type = new TyTy::ReferenceType (\n+\t\t  self_param.get_mappings ().get_hirid (),\n+\t\t  TyTy::TyVar (self->get_ref ()), true);\n+\t\tbreak;\n+\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t\treturn;\n+\t      }\n+\t  }\n+\n+\tcontext->insert_type (self_param.get_mappings (), self_type);\n \tparams.push_back (\n \t  std::pair<HIR::Pattern *, TyTy::BaseType *> (self_pattern,\n-\t\t\t\t\t\t       self->clone ()));\n+\t\t\t\t\t\t       self_type));\n       }\n \n     for (auto &param : function.get_function_params ())\n@@ -242,6 +277,7 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n       function.get_mappings ().get_defid (), function.get_function_name (),\n       function.is_method () ? FNTYPE_IS_METHOD_FLAG : FNTYPE_DEFAULT_FLAGS,\n       ABI::RUST, std::move (params), ret_type, std::move (substitutions));\n+\n     context->insert_type (function.get_mappings (), fnType);\n   }\n "}, {"sha": "0cd6883958d7e5a5959f82967bd2a10479646505", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=c8ffaa101c936822f5853a276d530da09c96cf52", "patch": "@@ -529,10 +529,43 @@ TraitItemReference::get_type_from_fn (/*const*/ HIR::TraitItemFunc &fn) const\n \t\t\t\t      self_param.is_ref (),\n \t\t\t\t      self_param.is_mut (),\n \t\t\t\t      std::unique_ptr<HIR::Pattern> (nullptr));\n-      context->insert_type (self_param.get_mappings (), self->clone ());\n+      // might have a specified type\n+      TyTy::BaseType *self_type = nullptr;\n+      if (self_param.has_type ())\n+\t{\n+\t  std::unique_ptr<HIR::Type> &specified_type = self_param.get_type ();\n+\t  self_type = TypeCheckType::Resolve (specified_type.get ());\n+\t}\n+      else\n+\t{\n+\t  switch (self_param.get_self_kind ())\n+\t    {\n+\t    case HIR::SelfParam::IMM:\n+\t    case HIR::SelfParam::MUT:\n+\t      self_type = self->clone ();\n+\t      break;\n+\n+\t    case HIR::SelfParam::IMM_REF:\n+\t      self_type = new TyTy::ReferenceType (\n+\t\tself_param.get_mappings ().get_hirid (),\n+\t\tTyTy::TyVar (self->get_ref ()), false);\n+\t      break;\n+\n+\t    case HIR::SelfParam::MUT_REF:\n+\t      self_type = new TyTy::ReferenceType (\n+\t\tself_param.get_mappings ().get_hirid (),\n+\t\tTyTy::TyVar (self->get_ref ()), true);\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t      return nullptr;\n+\t    }\n+\t}\n+\n+      context->insert_type (self_param.get_mappings (), self_type);\n       params.push_back (\n-\tstd::pair<HIR::Pattern *, TyTy::BaseType *> (self_pattern,\n-\t\t\t\t\t\t     self->clone ()));\n+\tstd::pair<HIR::Pattern *, TyTy::BaseType *> (self_pattern, self_type));\n     }\n \n   for (auto &param : function.get_function_params ())"}, {"sha": "bcad5dbe7ab9dfa878b47deb342f60accce4898f", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=c8ffaa101c936822f5853a276d530da09c96cf52", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-hir-map.h\"\n #include \"rust-tyty.h\"\n #include \"rust-hir-trait-ref.h\"\n+#include \"rust-autoderef.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -183,6 +184,24 @@ class TypeCheckContext\n     return UNKNOWN_HIRID;\n   }\n \n+  void insert_autoderef_mappings (HirId id,\n+\t\t\t\t  std::vector<Adjustment> &&adjustments)\n+  {\n+    rust_assert (autoderef_mappings.find (id) == autoderef_mappings.end ());\n+    autoderef_mappings.emplace (id, std::move (adjustments));\n+  }\n+\n+  bool lookup_autoderef_mappings (HirId id,\n+\t\t\t\t  std::vector<Adjustment> **adjustments)\n+  {\n+    auto it = autoderef_mappings.find (id);\n+    if (it == autoderef_mappings.end ())\n+      return false;\n+\n+    *adjustments = &it->second;\n+    return true;\n+  }\n+\n private:\n   TypeCheckContext ();\n \n@@ -200,6 +219,9 @@ class TypeCheckContext\n     associated_traits_to_impls;\n \n   std::map<HirId, HirId> associated_type_mappings;\n+\n+  // adjustment mappings\n+  std::map<HirId, std::vector<Adjustment>> autoderef_mappings;\n };\n \n class TypeResolution"}, {"sha": "ef981cc11d7ea8235e6c4e986406979b5f3a46d4", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=c8ffaa101c936822f5853a276d530da09c96cf52", "patch": "@@ -112,6 +112,18 @@ BaseType::inherit_bounds (\n     }\n }\n \n+BaseType *\n+BaseType::get_root ()\n+{\n+  BaseType *root = this;\n+  while (root->get_kind () == TyTy::REF)\n+    {\n+      ReferenceType *r = static_cast<ReferenceType *> (root);\n+      root = r->get_base ();\n+    }\n+  return root;\n+}\n+\n TyVar::TyVar (HirId ref) : ref (ref)\n {\n   // ensure this reference is defined within the context"}, {"sha": "a7eb13248ee9fd218c31a2258bfc388bf9cfadc3", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=c8ffaa101c936822f5853a276d530da09c96cf52", "patch": "@@ -221,8 +221,7 @@ class BaseType : public TypeBoundsMappings\n \n   // Unify two types. Returns a pointer to the newly-created unified ty, or\n   // nullptr if the two ty cannot be unified. The caller is responsible for\n-  // releasing the memory of the returned ty. using ignore_errors alows for a\n-  // can_eq style unification\n+  // releasing the memory of the returned ty.\n   virtual BaseType *unify (BaseType *other) = 0;\n \n   // similar to unify but does not actually perform type unification but\n@@ -312,6 +311,8 @@ class BaseType : public TypeBoundsMappings\n \t\tdebug_str ().c_str ());\n   }\n \n+  BaseType *get_root ();\n+\n protected:\n   BaseType (HirId ref, HirId ty_ref, TypeKind kind,\n \t    std::set<HirId> refs = std::set<HirId> ())\n@@ -1146,8 +1147,7 @@ class FnType : public BaseType, public SubstitutionRef\n   BaseType *get_self_type () const\n   {\n     rust_assert (is_method ());\n-    // FIXME this will need updated when we support coercion for & mut self etc\n-    return get_params ().at (0).second;\n+    return param_at (0).second;\n   }\n \n   std::vector<std::pair<HIR::Pattern *, BaseType *>> &get_params ()"}, {"sha": "cce4ecfb68388367c86029533ea4e8c97fff4cc7", "filename": "gcc/testsuite/rust/compile/method1.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmethod1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmethod1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmethod1.rs?ref=c8ffaa101c936822f5853a276d530da09c96cf52", "patch": "@@ -1,15 +1,13 @@\n struct Foo(i32);\n-\n impl Foo {\n     fn test() {}\n }\n \n pub fn main() {\n-    // { dg-error {expected \\[\\(\\)\\] got \\[<tyty::error>\\]} \"\" { target *-*-* } .-1 }\n     let a;\n     a = Foo(123);\n \n-    a.test()\n-    // { dg-error \"associated function is not a method\" \"\" { target *-*-* } .-1 }\n+    a.test();\n+    // { dg-error \"failed to resolve method\" \"\" { target *-*-* } .-1 }\n     // { dg-error {failed to type resolve expression} \"\" { target *-*-* } .-2 }\n }"}, {"sha": "6af6133939b37f7ae5d8a913682b036cb31adaf9", "filename": "gcc/testsuite/rust/execute/torture/method1.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmethod1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8ffaa101c936822f5853a276d530da09c96cf52/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmethod1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmethod1.rs?ref=c8ffaa101c936822f5853a276d530da09c96cf52", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-output \"124\\n458\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+struct Foo(i32);\n+impl Foo {\n+    fn bar(&self, i: i32) {\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, self.0 + i);\n+        }\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a = Foo(123);\n+    a.bar(1);\n+\n+    let b = &Foo(456);\n+    b.bar(2);\n+\n+    0\n+}"}]}