{"sha": "6fae7eda968db658c280ad6f94fe6906a15af0c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZhZTdlZGE5NjhkYjY1OGMyODBhZDZmOTRmZTY5MDZhMTVhZjBjOQ==", "commit": {"author": {"name": "Kwok Cheung Yeung", "email": "kcy@codesourcery.com", "date": "2020-11-18T19:24:36Z"}, "committer": {"name": "Kwok Cheung Yeung", "email": "kcy@codesourcery.com", "date": "2020-11-18T19:24:36Z"}, "message": "openmp: Retire nest-var ICV for OpenMP 5.1\n\nThis removes the nest-var ICV, expressing nesting in terms of the\nmax-active-levels-var ICV instead.  The max-active-levels-var ICV\nis now per data environment rather than per device.\n\n2020-11-18  Kwok Cheung Yeung  <kcy@codesourcery.com>\n\n\tlibgomp/\n\t* env.c (gomp_global_icv): Remove nest_var field.  Add\n\tmax_active_levels_var field.\n\t(gomp_max_active_levels_var): Remove.\n\t(parse_boolean): Return true on success.\n\t(handle_omp_display_env): Express OMP_NESTED in terms of\n\tmax_active_levels_var.  Change format specifier for\n\tmax_active_levels_var.\n\t(initialize_env): Set max_active_levels_var from\n\tOMP_MAX_ACTIVE_LEVELS, OMP_NESTED, OMP_NUM_THREADS and\n\tOMP_PROC_BIND.\n\t* icv.c (omp_set_nested): Express in terms of\n\tmax_active_levels_var.\n\t(omp_get_nested): Likewise.\n\t(omp_set_max_active_levels): Use max_active_levels_var field instead\n\tof gomp_max_active_levels_var.\n\t(omp_get_max_active_levels): Likewise.\n\t* libgomp.h (struct gomp_task_icv): Remove nest_var field.  Add\n\tmax_active_levels_var field.\n\t(gomp_supported_active_levels): Set to UCHAR_MAX.\n\t(gomp_max_active_levels_var): Delete.\n\t* libgomp.texi (omp_get_nested): Update documentation.\n\t(omp_set_nested): Likewise.\n\t(OMP_MAX_ACTIVE_LEVELS): Likewise.\n\t(OMP_NESTED): Likewise.\n\t(OMP_NUM_THREADS): Likewise.\n\t(OMP_PROC_BIND): Likewise.\n\t* parallel.c (gomp_resolve_num_threads): Replace reference\n\tto nest_var with max_active_levels_var.  Use max_active_levels_var\n\tfield instead of gomp_max_active_levels_var.", "tree": {"sha": "0453cb6dd1c52f71b96326f558695408e62e4607", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0453cb6dd1c52f71b96326f558695408e62e4607"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fae7eda968db658c280ad6f94fe6906a15af0c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fae7eda968db658c280ad6f94fe6906a15af0c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fae7eda968db658c280ad6f94fe6906a15af0c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fae7eda968db658c280ad6f94fe6906a15af0c9/comments", "author": {"login": "k-yeung", "id": 16960193, "node_id": "MDQ6VXNlcjE2OTYwMTkz", "avatar_url": "https://avatars.githubusercontent.com/u/16960193?v=4", "gravatar_id": "", "url": "https://api.github.com/users/k-yeung", "html_url": "https://github.com/k-yeung", "followers_url": "https://api.github.com/users/k-yeung/followers", "following_url": "https://api.github.com/users/k-yeung/following{/other_user}", "gists_url": "https://api.github.com/users/k-yeung/gists{/gist_id}", "starred_url": "https://api.github.com/users/k-yeung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/k-yeung/subscriptions", "organizations_url": "https://api.github.com/users/k-yeung/orgs", "repos_url": "https://api.github.com/users/k-yeung/repos", "events_url": "https://api.github.com/users/k-yeung/events{/privacy}", "received_events_url": "https://api.github.com/users/k-yeung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "k-yeung", "id": 16960193, "node_id": "MDQ6VXNlcjE2OTYwMTkz", "avatar_url": "https://avatars.githubusercontent.com/u/16960193?v=4", "gravatar_id": "", "url": "https://api.github.com/users/k-yeung", "html_url": "https://github.com/k-yeung", "followers_url": "https://api.github.com/users/k-yeung/followers", "following_url": "https://api.github.com/users/k-yeung/following{/other_user}", "gists_url": "https://api.github.com/users/k-yeung/gists{/gist_id}", "starred_url": "https://api.github.com/users/k-yeung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/k-yeung/subscriptions", "organizations_url": "https://api.github.com/users/k-yeung/orgs", "repos_url": "https://api.github.com/users/k-yeung/repos", "events_url": "https://api.github.com/users/k-yeung/events{/privacy}", "received_events_url": "https://api.github.com/users/k-yeung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "965e0cc371b292190f69f23ab9d35c8a20b13076", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/965e0cc371b292190f69f23ab9d35c8a20b13076", "html_url": "https://github.com/Rust-GCC/gccrs/commit/965e0cc371b292190f69f23ab9d35c8a20b13076"}], "stats": {"total": 130, "additions": 90, "deletions": 40}, "files": [{"sha": "5a49ae611bde289852d5c4a196c16a586be26679", "filename": "libgomp/env.c", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fae7eda968db658c280ad6f94fe6906a15af0c9/libgomp%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fae7eda968db658c280ad6f94fe6906a15af0c9/libgomp%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fenv.c?ref=6fae7eda968db658c280ad6f94fe6906a15af0c9", "patch": "@@ -68,12 +68,11 @@ struct gomp_task_icv gomp_global_icv = {\n   .run_sched_chunk_size = 1,\n   .default_device_var = 0,\n   .dyn_var = false,\n-  .nest_var = false,\n+  .max_active_levels_var = 1,\n   .bind_var = omp_proc_bind_false,\n   .target_data = NULL\n };\n \n-unsigned long gomp_max_active_levels_var = gomp_supported_active_levels;\n bool gomp_cancel_var = false;\n enum gomp_target_offload_t gomp_target_offload_var\n   = GOMP_TARGET_OFFLOAD_DEFAULT;\n@@ -959,16 +958,17 @@ parse_spincount (const char *name, unsigned long long *pvalue)\n }\n \n /* Parse a boolean value for environment variable NAME and store the\n-   result in VALUE.  */\n+   result in VALUE.  Return true if one was present and it was\n+   successfully parsed.  */\n \n-static void\n+static bool\n parse_boolean (const char *name, bool *value)\n {\n   const char *env;\n \n   env = getenv (name);\n   if (env == NULL)\n-    return;\n+    return false;\n \n   while (isspace ((unsigned char) *env))\n     ++env;\n@@ -987,7 +987,11 @@ parse_boolean (const char *name, bool *value)\n   while (isspace ((unsigned char) *env))\n     ++env;\n   if (*env != '\\0')\n-    gomp_error (\"Invalid value for environment variable %s\", name);\n+    {\n+      gomp_error (\"Invalid value for environment variable %s\", name);\n+      return false;\n+    }\n+  return true;\n }\n \n /* Parse the OMP_WAIT_POLICY environment variable and return the value.  */\n@@ -1252,7 +1256,7 @@ handle_omp_display_env (unsigned long stacksize, int wait_policy)\n   fprintf (stderr, \"  OMP_DYNAMIC = '%s'\\n\",\n \t   gomp_global_icv.dyn_var ? \"TRUE\" : \"FALSE\");\n   fprintf (stderr, \"  OMP_NESTED = '%s'\\n\",\n-\t   gomp_global_icv.nest_var ? \"TRUE\" : \"FALSE\");\n+\t   gomp_global_icv.max_active_levels_var > 1 ? \"TRUE\" : \"FALSE\");\n \n   fprintf (stderr, \"  OMP_NUM_THREADS = '%lu\", gomp_global_icv.nthreads_var);\n   for (i = 1; i < gomp_nthreads_var_list_len; i++)\n@@ -1344,8 +1348,8 @@ handle_omp_display_env (unsigned long stacksize, int wait_policy)\n \t   wait_policy > 0 ? \"ACTIVE\" : \"PASSIVE\");\n   fprintf (stderr, \"  OMP_THREAD_LIMIT = '%u'\\n\",\n \t   gomp_global_icv.thread_limit_var);\n-  fprintf (stderr, \"  OMP_MAX_ACTIVE_LEVELS = '%lu'\\n\",\n-\t   gomp_max_active_levels_var);\n+  fprintf (stderr, \"  OMP_MAX_ACTIVE_LEVELS = '%u'\\n\",\n+\t   gomp_global_icv.max_active_levels_var);\n \n   fprintf (stderr, \"  OMP_CANCELLATION = '%s'\\n\",\n \t   gomp_cancel_var ? \"TRUE\" : \"FALSE\");\n@@ -1410,23 +1414,19 @@ static void __attribute__((constructor))\n initialize_env (void)\n {\n   unsigned long thread_limit_var, stacksize = GOMP_DEFAULT_STACKSIZE;\n+  unsigned long max_active_levels_var;\n   int wait_policy;\n \n   /* Do a compile time check that mkomp_h.pl did good job.  */\n   omp_check_defines ();\n \n   parse_schedule ();\n   parse_boolean (\"OMP_DYNAMIC\", &gomp_global_icv.dyn_var);\n-  parse_boolean (\"OMP_NESTED\", &gomp_global_icv.nest_var);\n   parse_boolean (\"OMP_CANCELLATION\", &gomp_cancel_var);\n   parse_boolean (\"OMP_DISPLAY_AFFINITY\", &gomp_display_affinity_var);\n   parse_int (\"OMP_DEFAULT_DEVICE\", &gomp_global_icv.default_device_var, true);\n   parse_target_offload (\"OMP_TARGET_OFFLOAD\", &gomp_target_offload_var);\n   parse_int (\"OMP_MAX_TASK_PRIORITY\", &gomp_max_task_priority_var, true);\n-  parse_unsigned_long (\"OMP_MAX_ACTIVE_LEVELS\", &gomp_max_active_levels_var,\n-\t\t       true);\n-  if (gomp_max_active_levels_var > gomp_supported_active_levels)\n-    gomp_max_active_levels_var = gomp_supported_active_levels;\n   gomp_def_allocator = parse_allocator ();\n   if (parse_unsigned_long (\"OMP_THREAD_LIMIT\", &thread_limit_var, false))\n     {\n@@ -1451,6 +1451,22 @@ initialize_env (void)\n \t\t      &gomp_bind_var_list_len)\n       && gomp_global_icv.bind_var == omp_proc_bind_false)\n     ignore = true;\n+  if (parse_unsigned_long (\"OMP_MAX_ACTIVE_LEVELS\",\n+\t\t\t   &max_active_levels_var, true))\n+    gomp_global_icv.max_active_levels_var\n+      = (max_active_levels_var > gomp_supported_active_levels)\n+\t? gomp_supported_active_levels : max_active_levels_var;\n+  else\n+    {\n+      bool nested = true;\n+\n+      /* OMP_NESTED is deprecated in OpenMP 5.0.  */\n+      if (parse_boolean (\"OMP_NESTED\", &nested))\n+\tgomp_global_icv.max_active_levels_var\n+\t  = nested ? gomp_supported_active_levels : 1;\n+      else if (gomp_nthreads_var_list_len > 1 || gomp_bind_var_list_len > 1)\n+\tgomp_global_icv.max_active_levels_var = gomp_supported_active_levels;\n+    }\n   /* Make sure OMP_PLACES and GOMP_CPU_AFFINITY env vars are always\n      parsed if present in the environment.  If OMP_PROC_BIND was set\n      explicitly to false, don't populate places list though.  If places"}, {"sha": "c0c0305102f6151ec80272311d33dbe6e4b52458", "filename": "libgomp/icv.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fae7eda968db658c280ad6f94fe6906a15af0c9/libgomp%2Ficv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fae7eda968db658c280ad6f94fe6906a15af0c9/libgomp%2Ficv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ficv.c?ref=6fae7eda968db658c280ad6f94fe6906a15af0c9", "patch": "@@ -57,14 +57,18 @@ void\n omp_set_nested (int val)\n {\n   struct gomp_task_icv *icv = gomp_icv (true);\n-  icv->nest_var = val;\n+  if (val)\n+    icv->max_active_levels_var = gomp_supported_active_levels;\n+  else if (icv->max_active_levels_var > 1)\n+    icv->max_active_levels_var = 1;\n }\n \n int\n omp_get_nested (void)\n {\n   struct gomp_task_icv *icv = gomp_icv (false);\n-  return icv->nest_var;\n+  return (icv->max_active_levels_var > 1\n+\t  && icv->max_active_levels_var > omp_get_active_level ());\n }\n #pragma GCC diagnostic pop\n \n@@ -120,17 +124,20 @@ omp_set_max_active_levels (int max_levels)\n {\n   if (max_levels >= 0)\n     {\n+      struct gomp_task_icv *icv = gomp_icv (true);\n+\n       if (max_levels <= gomp_supported_active_levels)\n-\tgomp_max_active_levels_var = max_levels;\n+\ticv->max_active_levels_var = max_levels;\n       else\n-\tgomp_max_active_levels_var = gomp_supported_active_levels;\n+\ticv->max_active_levels_var = gomp_supported_active_levels;\n     }\n }\n \n int\n omp_get_max_active_levels (void)\n {\n-  return gomp_max_active_levels_var;\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  return icv->max_active_levels_var;\n }\n \n int"}, {"sha": "070d29c969ef835643cc6774819705f7702359e8", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fae7eda968db658c280ad6f94fe6906a15af0c9/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fae7eda968db658c280ad6f94fe6906a15af0c9/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=6fae7eda968db658c280ad6f94fe6906a15af0c9", "patch": "@@ -428,7 +428,7 @@ struct gomp_task_icv\n   int default_device_var;\n   unsigned int thread_limit_var;\n   bool dyn_var;\n-  bool nest_var;\n+  unsigned char max_active_levels_var;\n   char bind_var;\n   /* Internal ICV.  */\n   struct target_mem_desc *target_data;\n@@ -441,13 +441,12 @@ enum gomp_target_offload_t\n   GOMP_TARGET_OFFLOAD_DISABLED\n };\n \n-#define gomp_supported_active_levels INT_MAX\n+#define gomp_supported_active_levels UCHAR_MAX\n \n extern struct gomp_task_icv gomp_global_icv;\n #ifndef HAVE_SYNC_BUILTINS\n extern gomp_mutex_t gomp_managed_threads_lock;\n #endif\n-extern unsigned long gomp_max_active_levels_var;\n extern bool gomp_cancel_var;\n extern enum gomp_target_offload_t gomp_target_offload_var;\n extern int gomp_max_task_priority_var;"}, {"sha": "473b191ae14b2adbc436ed542161bc453071be59", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fae7eda968db658c280ad6f94fe6906a15af0c9/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fae7eda968db658c280ad6f94fe6906a15af0c9/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=6fae7eda968db658c280ad6f94fe6906a15af0c9", "patch": "@@ -487,10 +487,20 @@ This function returns @code{true} if nested parallel regions are\n enabled, @code{false} otherwise.  Here, @code{true} and @code{false}\n represent their language-specific counterparts.\n \n-Nested parallel regions may be initialized at startup by the \n-@env{OMP_NESTED} environment variable or at runtime using\n-@code{omp_set_nested}.  If undefined, nested parallel regions are\n-disabled by default.\n+The state of nested parallel regions at startup depends on several\n+environment variables.  If @env{OMP_MAX_ACTIVE_LEVELS} is defined\n+and is set to greater than one, then nested parallel regions will be\n+enabled.  If not defined, then the value of the @env{OMP_NESTED}\n+environment variable will be followed if defined.  If neither are\n+defined, then if either @env{OMP_NUM_THREADS} or @env{OMP_PROC_BIND}\n+are defined with a list of more than one value, then nested parallel\n+regions are enabled.  If none of these are defined, then nested parallel\n+regions are disabled by default.\n+\n+Nested parallel regions can be enabled or disabled at runtime using\n+@code{omp_set_nested}, or by setting the maximum number of nested\n+regions with @code{omp_set_max_active_levels} to one to disable, or\n+above one to enable.\n \n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n@@ -503,7 +513,8 @@ disabled by default.\n @end multitable\n \n @item @emph{See also}:\n-@ref{omp_set_nested}, @ref{OMP_NESTED}\n+@ref{omp_set_max_active_levels}, @ref{omp_set_nested},\n+@ref{OMP_MAX_ACTIVE_LEVELS}, @ref{OMP_NESTED}\n \n @item @emph{Reference}:\n @uref{https://www.openmp.org, OpenMP specification v4.5}, Section 3.2.11.\n@@ -964,6 +975,10 @@ are allowed to create new teams.  The function takes the language-specific\n equivalent of @code{true} and @code{false}, where @code{true} enables \n dynamic adjustment of team sizes and @code{false} disables it.\n \n+Enabling nested parallel regions will also set the maximum number of\n+active nested regions to the maximum supported.  Disabling nested parallel\n+regions will set the maximum number of active nested regions to one.\n+\n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n @item @emph{Prototype}: @tab @code{void omp_set_nested(int nested);}\n@@ -976,7 +991,8 @@ dynamic adjustment of team sizes and @code{false} disables it.\n @end multitable\n \n @item @emph{See also}:\n-@ref{OMP_NESTED}, @ref{omp_get_nested}\n+@ref{omp_get_nested}, @ref{omp_set_max_active_levels},\n+@ref{OMP_MAX_ACTIVE_LEVELS}, @ref{OMP_NESTED}\n \n @item @emph{Reference}:\n @uref{https://www.openmp.org, OpenMP specification v4.5}, Section 3.2.10.\n@@ -1502,10 +1518,14 @@ disabled by default.\n @item @emph{Description}:\n Specifies the initial value for the maximum number of nested parallel\n regions.  The value of this variable shall be a positive integer.\n-If undefined, the number of active levels is unlimited.\n+If undefined, then if @env{OMP_NESTED} is defined and set to true, or\n+if @env{OMP_NUM_THREADS} or @env{OMP_PROC_BIND} are defined and set to\n+a list with more than one item, the maximum number of nested parallel\n+regions will be initialized to the largest number supported, otherwise\n+it will be set to one.\n \n @item @emph{See also}:\n-@ref{omp_set_max_active_levels}\n+@ref{omp_set_max_active_levels}, @ref{OMP_NESTED}\n \n @item @emph{Reference}: \n @uref{https://www.openmp.org, OpenMP specification v4.5}, Section 4.9\n@@ -1541,11 +1561,16 @@ integer, and zero is allowed.  If undefined, the default priority is\n @item @emph{Description}:\n Enable or disable nested parallel regions, i.e., whether team members\n are allowed to create new teams.  The value of this environment variable \n-shall be @code{TRUE} or @code{FALSE}.  If undefined, nested parallel \n-regions are disabled by default.\n+shall be @code{TRUE} or @code{FALSE}.  If set to @code{TRUE}, the number\n+of maximum active nested regions supported will by default be set to the\n+maximum supported, otherwise it will be set to one.  If\n+@env{OMP_MAX_ACTIVE_LEVELS} is defined, its setting will override this\n+setting.  If both are undefined, nested parallel regions are enabled if\n+@env{OMP_NUM_THREADS} or @env{OMP_PROC_BINDS} are defined to a list with\n+more than one item, otherwise they are disabled by default.\n \n @item @emph{See also}:\n-@ref{omp_set_nested}\n+@ref{omp_set_max_active_levels}, @ref{omp_set_nested}\n \n @item @emph{Reference}: \n @uref{https://www.openmp.org, OpenMP specification v4.5}, Section 4.6\n@@ -1561,11 +1586,12 @@ regions are disabled by default.\n @item @emph{Description}:\n Specifies the default number of threads to use in parallel regions.  The \n value of this variable shall be a comma-separated list of positive integers;\n-the value specified the number of threads to use for the corresponding nested\n-level.  If undefined one thread per CPU is used.\n+the value specifies the number of threads to use for the corresponding nested\n+level.  Specifying more than one item in the list will automatically enable\n+nesting by default.  If undefined one thread per CPU is used.\n \n @item @emph{See also}:\n-@ref{omp_set_num_threads}\n+@ref{omp_set_num_threads}, @ref{OMP_NESTED}\n \n @item @emph{Reference}: \n @uref{https://www.openmp.org, OpenMP specification v4.5}, Section 4.2\n@@ -1586,13 +1612,15 @@ the thread affinity policy for the corresponding nesting level.  With\n @code{MASTER} the worker threads are in the same place partition as the\n master thread.  With @code{CLOSE} those are kept close to the master thread\n in contiguous place partitions.  And with @code{SPREAD} a sparse distribution\n-across the place partitions is used.\n+across the place partitions is used.  Specifying more than one item in the\n+list will automatically enable nesting by default.\n \n When undefined, @env{OMP_PROC_BIND} defaults to @code{TRUE} when\n @env{OMP_PLACES} or @env{GOMP_CPU_AFFINITY} is set and @code{FALSE} otherwise.\n \n @item @emph{See also}:\n-@ref{OMP_PLACES}, @ref{GOMP_CPU_AFFINITY}, @ref{omp_get_proc_bind}\n+@ref{omp_get_proc_bind}, @ref{GOMP_CPU_AFFINITY},\n+@ref{OMP_NESTED}, @ref{OMP_PLACES}\n \n @item @emph{Reference}:\n @uref{https://www.openmp.org, OpenMP specification v4.5}, Section 4.4"}, {"sha": "ebce49223fe38c0d760f3e7639616f47e9b2b110", "filename": "libgomp/parallel.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fae7eda968db658c280ad6f94fe6906a15af0c9/libgomp%2Fparallel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fae7eda968db658c280ad6f94fe6906a15af0c9/libgomp%2Fparallel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fparallel.c?ref=6fae7eda968db658c280ad6f94fe6906a15af0c9", "patch": "@@ -53,11 +53,11 @@ gomp_resolve_num_threads (unsigned specified, unsigned count)\n   /* Accelerators with fixed thread counts require this to return 1 for\n      nested parallel regions.  */\n #if !defined(__AMDGCN__) && !defined(__nvptx__)\n-      && !icv->nest_var\n+      && icv->max_active_levels_var <= 1\n #endif\n       )\n     return 1;\n-  else if (thr->ts.active_level >= gomp_max_active_levels_var)\n+  else if (thr->ts.active_level >= icv->max_active_levels_var)\n     return 1;\n \n   /* If NUM_THREADS not specified, use nthreads_var.  */"}]}