{"sha": "2a1448f2763a72c83e2ec496f78243a975b0d44e", "node_id": "C_kwDOANBUbNoAKDJhMTQ0OGYyNzYzYTcyYzgzZTJlYzQ5NmY3ODI0M2E5NzViMGQ0NGU", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-08T07:07:23Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-08T09:13:13Z"}, "message": "lto/106540 - fix LTO tree input wrt dwarf2out_register_external_die\n\nI've revisited the earlier two workarounds for dwarf2out_register_external_die\ngetting duplicate entries.  It turns out that r11-525-g03d90a20a1afcb\nadded dref_queue pruning to lto_input_tree but decl reading uses that\nto stream in DECL_INITIAL even when in the middle of SCC streaming.\nWhen that SCC then gets thrown away we can end up with debug nodes\nregistered which isn't supposed to happen.  The following adjusts\nthe DECL_INITIAL streaming to go the in-SCC way, using lto_input_tree_1,\nsince no SCCs are expected at this point, just refs.\n\n\tPR lto/106540\n\tPR lto/106334\n\t* dwarf2out.cc (dwarf2out_register_external_die): Restore\n\toriginal assert.\n\t* lto-streamer-in.cc (lto_read_tree_1): Use lto_input_tree_1\n\tto input DECL_INITIAL, avoiding to commit drefs.", "tree": {"sha": "9ab30d7711c8b408b831ca51087fa98c4c27fc45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ab30d7711c8b408b831ca51087fa98c4c27fc45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a1448f2763a72c83e2ec496f78243a975b0d44e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a1448f2763a72c83e2ec496f78243a975b0d44e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a1448f2763a72c83e2ec496f78243a975b0d44e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a1448f2763a72c83e2ec496f78243a975b0d44e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2633c8d8f338f1e2b53d3757f3edf4179bfcc218", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2633c8d8f338f1e2b53d3757f3edf4179bfcc218", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2633c8d8f338f1e2b53d3757f3edf4179bfcc218"}], "stats": {"total": 14, "additions": 6, "deletions": 8}, "files": [{"sha": "e3920c898f5f7a1ace25cd44ed4cc30025fa35de", "filename": "gcc/dwarf2out.cc", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1448f2763a72c83e2ec496f78243a975b0d44e/gcc%2Fdwarf2out.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1448f2763a72c83e2ec496f78243a975b0d44e/gcc%2Fdwarf2out.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.cc?ref=2a1448f2763a72c83e2ec496f78243a975b0d44e", "patch": "@@ -6069,12 +6069,7 @@ dwarf2out_register_external_die (tree decl, const char *sym,\n \n   if (!external_die_map)\n     external_die_map = hash_map<tree, sym_off_pair>::create_ggc (1000);\n-  /* When we do tree merging during WPA or with -flto-partition=none we\n-     can end up re-using GC memory as there's currently no way to unregister\n-     external DIEs.  Ideally we'd register them only after merging finished\n-     but allowing override here is easiest.  See PR106334.  */\n-  gcc_checking_assert (!(in_lto_p && !flag_wpa)\n-\t\t       || !external_die_map->get (decl));\n+  gcc_checking_assert (!external_die_map->get (decl));\n   sym_off_pair p = { IDENTIFIER_POINTER (get_identifier (sym)), off };\n   external_die_map->put (decl, p);\n }"}, {"sha": "a7dad70363f7a26c2e9dc497a0bb3a56f54930d0", "filename": "gcc/lto-streamer-in.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1448f2763a72c83e2ec496f78243a975b0d44e/gcc%2Flto-streamer-in.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1448f2763a72c83e2ec496f78243a975b0d44e/gcc%2Flto-streamer-in.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.cc?ref=2a1448f2763a72c83e2ec496f78243a975b0d44e", "patch": "@@ -1699,11 +1699,14 @@ lto_read_tree_1 (class lto_input_block *ib, class data_in *data_in, tree expr)\n   /* Read all the pointer fields in EXPR.  */\n   streamer_read_tree_body (ib, data_in, expr);\n \n-  /* Read any LTO-specific data not read by the tree streamer.  */\n+  /* Read any LTO-specific data not read by the tree streamer.  Do not use\n+     stream_read_tree here since that flushes the dref_queue in mids of\n+     SCC reading.  */\n   if (DECL_P (expr)\n       && TREE_CODE (expr) != FUNCTION_DECL\n       && TREE_CODE (expr) != TRANSLATION_UNIT_DECL)\n-    DECL_INITIAL (expr) = stream_read_tree (ib, data_in);\n+    DECL_INITIAL (expr)\n+      = lto_input_tree_1 (ib, data_in, streamer_read_record_start (ib), 0);\n \n   /* Stream references to early generated DIEs.  Keep in sync with the\n      trees handled in dwarf2out_register_external_die.  */"}]}