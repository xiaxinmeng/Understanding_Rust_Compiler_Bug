{"sha": "cd0a10dd991395eec0a2661a85da31d52ac831fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2QwYTEwZGQ5OTEzOTVlZWMwYTI2NjFhODVkYTMxZDUyYWM4MzFmYw==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2007-04-24T14:45:08Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2007-04-24T14:45:08Z"}, "message": "dwarf2out.c (field_byte_offset): Move the existing logic under the control of PCC_BITFIELD_TYPE_MATTERS and just...\n\n\t* dwarf2out.c (field_byte_offset): Move the existing logic\n\tunder the control of PCC_BITFIELD_TYPE_MATTERS and just use\n\tthe bit offset of the field if !PCC_BITFIELD_TYPE_MATTERS.\n\nFrom-SVN: r124104", "tree": {"sha": "0243363339de73595a942443e24524dcf5922a41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0243363339de73595a942443e24524dcf5922a41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd0a10dd991395eec0a2661a85da31d52ac831fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd0a10dd991395eec0a2661a85da31d52ac831fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd0a10dd991395eec0a2661a85da31d52ac831fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd0a10dd991395eec0a2661a85da31d52ac831fc/comments", "author": null, "committer": null, "parents": [{"sha": "6b8846f8346cc2cf513c3958d66649a3e9d639b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b8846f8346cc2cf513c3958d66649a3e9d639b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b8846f8346cc2cf513c3958d66649a3e9d639b4"}], "stats": {"total": 176, "additions": 98, "deletions": 78}, "files": [{"sha": "9912ca74258e7a7f08b018b8bbae1c2b040987a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0a10dd991395eec0a2661a85da31d52ac831fc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0a10dd991395eec0a2661a85da31d52ac831fc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd0a10dd991395eec0a2661a85da31d52ac831fc", "patch": "@@ -1,3 +1,9 @@\n+2007-04-24  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* dwarf2out.c (field_byte_offset): Move the existing logic\n+\tunder the control of PCC_BITFIELD_TYPE_MATTERS and just use\n+\tthe bit offset of the field if !PCC_BITFIELD_TYPE_MATTERS.\n+\n 2007-04-24  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \tPR target/31641"}, {"sha": "8c9d028d2f64681880a81e094bd2458675fa1c55", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 92, "deletions": 78, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0a10dd991395eec0a2661a85da31d52ac831fc/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0a10dd991395eec0a2661a85da31d52ac831fc/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=cd0a10dd991395eec0a2661a85da31d52ac831fc", "patch": "@@ -9694,29 +9694,14 @@ round_up_to_align (HOST_WIDE_INT t, unsigned int align)\n static HOST_WIDE_INT\n field_byte_offset (tree decl)\n {\n-  unsigned int type_align_in_bits;\n-  unsigned int decl_align_in_bits;\n-  unsigned HOST_WIDE_INT type_size_in_bits;\n   HOST_WIDE_INT object_offset_in_bits;\n-  tree type;\n-  tree field_size_tree;\n   HOST_WIDE_INT bitpos_int;\n-  HOST_WIDE_INT deepest_bitpos;\n-  unsigned HOST_WIDE_INT field_size_in_bits;\n \n   if (TREE_CODE (decl) == ERROR_MARK)\n     return 0;\n \n   gcc_assert (TREE_CODE (decl) == FIELD_DECL);\n \n-  type = field_type (decl);\n-  field_size_tree = DECL_SIZE (decl);\n-\n-  /* The size could be unspecified if there was an error, or for\n-     a flexible array member.  */\n-  if (! field_size_tree)\n-    field_size_tree = bitsize_zero_node;\n-\n   /* We cannot yet cope with fields whose positions are variable, so\n      for now, when we see such things, we simply return 0.  Someday, we may\n      be able to handle such cases, but it will be damn difficult.  */\n@@ -9725,76 +9710,105 @@ field_byte_offset (tree decl)\n \n   bitpos_int = int_bit_position (decl);\n \n-  /* If we don't know the size of the field, pretend it's a full word.  */\n-  if (host_integerp (field_size_tree, 1))\n-    field_size_in_bits = tree_low_cst (field_size_tree, 1);\n-  else\n-    field_size_in_bits = BITS_PER_WORD;\n-\n-  type_size_in_bits = simple_type_size_in_bits (type);\n-  type_align_in_bits = simple_type_align_in_bits (type);\n-  decl_align_in_bits = simple_decl_align_in_bits (decl);\n-\n-  /* The GCC front-end doesn't make any attempt to keep track of the starting\n-     bit offset (relative to the start of the containing structure type) of the\n-     hypothetical \"containing object\" for a bit-field.  Thus, when computing\n-     the byte offset value for the start of the \"containing object\" of a\n-     bit-field, we must deduce this information on our own. This can be rather\n-     tricky to do in some cases.  For example, handling the following structure\n-     type definition when compiling for an i386/i486 target (which only aligns\n-     long long's to 32-bit boundaries) can be very tricky:\n+#ifdef PCC_BITFIELD_TYPE_MATTERS\n+  if (PCC_BITFIELD_TYPE_MATTERS)\n+    {\n+      tree type;\n+      tree field_size_tree;\n+      HOST_WIDE_INT deepest_bitpos;\n+      unsigned HOST_WIDE_INT field_size_in_bits;\n+      unsigned int type_align_in_bits;\n+      unsigned int decl_align_in_bits;\n+      unsigned HOST_WIDE_INT type_size_in_bits;\n+\n+      type = field_type (decl);\n+      field_size_tree = DECL_SIZE (decl);\n+\n+      /* The size could be unspecified if there was an error, or for\n+         a flexible array member.  */\n+      if (! field_size_tree)\n+        field_size_tree = bitsize_zero_node;\n+\n+      /* If we don't know the size of the field, pretend it's a full word.  */\n+      if (host_integerp (field_size_tree, 1))\n+        field_size_in_bits = tree_low_cst (field_size_tree, 1);\n+      else\n+        field_size_in_bits = BITS_PER_WORD;\n+\n+      type_size_in_bits = simple_type_size_in_bits (type);\n+      type_align_in_bits = simple_type_align_in_bits (type);\n+      decl_align_in_bits = simple_decl_align_in_bits (decl);\n+\n+      /* The GCC front-end doesn't make any attempt to keep track of the\n+         starting bit offset (relative to the start of the containing\n+         structure type) of the hypothetical \"containing object\" for a\n+         bit-field.  Thus, when computing the byte offset value for the\n+         start of the \"containing object\" of a bit-field, we must deduce\n+         this information on our own. This can be rather tricky to do in\n+         some cases.  For example, handling the following structure type\n+         definition when compiling for an i386/i486 target (which only\n+         aligns long long's to 32-bit boundaries) can be very tricky:\n \n \t struct S { int field1; long long field2:31; };\n \n-     Fortunately, there is a simple rule-of-thumb which can be used in such\n-     cases.  When compiling for an i386/i486, GCC will allocate 8 bytes for the\n-     structure shown above.  It decides to do this based upon one simple rule\n-     for bit-field allocation.  GCC allocates each \"containing object\" for each\n-     bit-field at the first (i.e. lowest addressed) legitimate alignment\n-     boundary (based upon the required minimum alignment for the declared type\n-     of the field) which it can possibly use, subject to the condition that\n-     there is still enough available space remaining in the containing object\n-     (when allocated at the selected point) to fully accommodate all of the\n-     bits of the bit-field itself.\n-\n-     This simple rule makes it obvious why GCC allocates 8 bytes for each\n-     object of the structure type shown above.  When looking for a place to\n-     allocate the \"containing object\" for `field2', the compiler simply tries\n-     to allocate a 64-bit \"containing object\" at each successive 32-bit\n-     boundary (starting at zero) until it finds a place to allocate that 64-\n-     bit field such that at least 31 contiguous (and previously unallocated)\n-     bits remain within that selected 64 bit field.  (As it turns out, for the\n-     example above, the compiler finds it is OK to allocate the \"containing\n-     object\" 64-bit field at bit-offset zero within the structure type.)\n-\n-     Here we attempt to work backwards from the limited set of facts we're\n-     given, and we try to deduce from those facts, where GCC must have believed\n-     that the containing object started (within the structure type). The value\n-     we deduce is then used (by the callers of this routine) to generate\n-     DW_AT_location and DW_AT_bit_offset attributes for fields (both bit-fields\n-     and, in the case of DW_AT_location, regular fields as well).  */\n-\n-  /* Figure out the bit-distance from the start of the structure to the\n-     \"deepest\" bit of the bit-field.  */\n-  deepest_bitpos = bitpos_int + field_size_in_bits;\n-\n-  /* This is the tricky part.  Use some fancy footwork to deduce where the\n-     lowest addressed bit of the containing object must be.  */\n-  object_offset_in_bits = deepest_bitpos - type_size_in_bits;\n-\n-  /* Round up to type_align by default.  This works best for bitfields.  */\n-  object_offset_in_bits\n-    = round_up_to_align (object_offset_in_bits, type_align_in_bits);\n-\n-  if (object_offset_in_bits > bitpos_int)\n-    {\n-      /* Sigh, the decl must be packed.  */\n+         Fortunately, there is a simple rule-of-thumb which can be used\n+         in such cases.  When compiling for an i386/i486, GCC will\n+         allocate 8 bytes for the structure shown above.  It decides to\n+         do this based upon one simple rule for bit-field allocation.\n+         GCC allocates each \"containing object\" for each bit-field at\n+         the first (i.e. lowest addressed) legitimate alignment boundary\n+         (based upon the required minimum alignment for the declared\n+         type of the field) which it can possibly use, subject to the\n+         condition that there is still enough available space remaining\n+         in the containing object (when allocated at the selected point)\n+         to fully accommodate all of the bits of the bit-field itself.\n+\n+         This simple rule makes it obvious why GCC allocates 8 bytes for\n+         each object of the structure type shown above.  When looking\n+         for a place to allocate the \"containing object\" for `field2',\n+         the compiler simply tries to allocate a 64-bit \"containing\n+         object\" at each successive 32-bit boundary (starting at zero)\n+         until it finds a place to allocate that 64- bit field such that\n+         at least 31 contiguous (and previously unallocated) bits remain\n+         within that selected 64 bit field.  (As it turns out, for the\n+         example above, the compiler finds it is OK to allocate the\n+         \"containing object\" 64-bit field at bit-offset zero within the\n+         structure type.)\n+\n+         Here we attempt to work backwards from the limited set of facts\n+         we're given, and we try to deduce from those facts, where GCC\n+         must have believed that the containing object started (within\n+         the structure type). The value we deduce is then used (by the\n+         callers of this routine) to generate DW_AT_location and\n+         DW_AT_bit_offset attributes for fields (both bit-fields and, in\n+         the case of DW_AT_location, regular fields as well).  */\n+\n+      /* Figure out the bit-distance from the start of the structure to\n+         the \"deepest\" bit of the bit-field.  */\n+      deepest_bitpos = bitpos_int + field_size_in_bits;\n+\n+      /* This is the tricky part.  Use some fancy footwork to deduce\n+         where the lowest addressed bit of the containing object must\n+         be.  */\n       object_offset_in_bits = deepest_bitpos - type_size_in_bits;\n \n-      /* Round up to decl_align instead.  */\n+      /* Round up to type_align by default.  This works best for\n+         bitfields.  */\n       object_offset_in_bits\n-\t= round_up_to_align (object_offset_in_bits, decl_align_in_bits);\n+        = round_up_to_align (object_offset_in_bits, type_align_in_bits);\n+\n+      if (object_offset_in_bits > bitpos_int)\n+        {\n+          object_offset_in_bits = deepest_bitpos - type_size_in_bits;\n+\n+          /* Round up to decl_align instead.  */\n+          object_offset_in_bits\n+            = round_up_to_align (object_offset_in_bits, decl_align_in_bits);\n+        }\n     }\n+  else\n+#endif\n+    object_offset_in_bits = bitpos_int;\n \n   return object_offset_in_bits / BITS_PER_UNIT;\n }"}]}