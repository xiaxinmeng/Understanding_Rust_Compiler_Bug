{"sha": "7f1c539c954e77bb4015ab1fc64ea4966a2bf011", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2YxYzUzOWM5NTRlNzdiYjQwMTVhYjFmYzY0ZWE0OTY2YTJiZjAxMQ==", "commit": {"author": {"name": "Kai Tietz", "email": "kai.tietz@onevision.com", "date": "2009-01-30T08:45:35Z"}, "committer": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2009-01-30T08:45:35Z"}, "message": "i386.c (ix86_can_use_return_insn_p): Check for nsseregs.\n\n2009-01-30  Kai Tietz  <kai.tietz@onevision.com>\n\n\tPR/39002\n\t* config/i386/i386.c (ix86_can_use_return_insn_p): Check for nsseregs.\n\t(ix86_expand_epilogue): Take nsseregs in account to use proper restore\n\tmethod.\n\nFrom-SVN: r143780", "tree": {"sha": "37567d93f6ee8c6190c0acce3d93f2b01bf32a14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37567d93f6ee8c6190c0acce3d93f2b01bf32a14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f1c539c954e77bb4015ab1fc64ea4966a2bf011", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f1c539c954e77bb4015ab1fc64ea4966a2bf011", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f1c539c954e77bb4015ab1fc64ea4966a2bf011", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f1c539c954e77bb4015ab1fc64ea4966a2bf011/comments", "author": null, "committer": null, "parents": [{"sha": "e2b861f4ca4dd76b73b9230d51723f737e2bb8a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2b861f4ca4dd76b73b9230d51723f737e2bb8a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2b861f4ca4dd76b73b9230d51723f737e2bb8a1"}], "stats": {"total": 17, "additions": 12, "deletions": 5}, "files": [{"sha": "a6ae12652470e89e38bb0e668d60d52b30cdb9dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1c539c954e77bb4015ab1fc64ea4966a2bf011/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1c539c954e77bb4015ab1fc64ea4966a2bf011/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7f1c539c954e77bb4015ab1fc64ea4966a2bf011", "patch": "@@ -1,3 +1,10 @@\n+2009-01-30  Kai Tietz  <kai.tietz@onevision.com>\n+\n+\tPR/39002\n+\t* config/i386/i386.c (ix86_can_use_return_insn_p): Check for nsseregs.\n+\t(ix86_expand_epilogue): Take nsseregs in account to use proper restore\n+\tmethod.\n+\n 2009-01-29  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* ira-color.c (allocno_reload_assign): Update comments."}, {"sha": "c60ec5ab35e564cbc7da51526708b0306e9820c6", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1c539c954e77bb4015ab1fc64ea4966a2bf011/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1c539c954e77bb4015ab1fc64ea4966a2bf011/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7f1c539c954e77bb4015ab1fc64ea4966a2bf011", "patch": "@@ -7138,7 +7138,7 @@ ix86_can_use_return_insn_p (void)\n     return 0;\n \n   ix86_compute_frame_layout (&frame);\n-  return frame.to_allocate == 0 && frame.nregs == 0;\n+  return frame.to_allocate == 0 && (frame.nregs + frame.nsseregs) == 0;\n }\n \f\n /* Value should be nonzero if functions must have frame pointers.\n@@ -8293,14 +8293,14 @@ ix86_expand_epilogue (int style)\n      are no registers to restore.  We also use this code when TARGET_USE_LEAVE\n      and there is exactly one register to pop. This heuristic may need some\n      tuning in future.  */\n-  if ((!sp_valid && frame.nregs <= 1)\n+  if ((!sp_valid && (frame.nregs + frame.nsseregs) <= 1)\n       || (TARGET_EPILOGUE_USING_MOVE\n \t  && cfun->machine->use_fast_prologue_epilogue\n-\t  && (frame.nregs > 1 || frame.to_allocate))\n-      || (frame_pointer_needed && !frame.nregs && frame.to_allocate)\n+\t  && ((frame.nregs + frame.nsseregs) > 1 || frame.to_allocate))\n+      || (frame_pointer_needed && !(frame.nregs + frame.nsseregs) && frame.to_allocate)\n       || (frame_pointer_needed && TARGET_USE_LEAVE\n \t  && cfun->machine->use_fast_prologue_epilogue\n-\t  && frame.nregs == 1)\n+\t  && (frame.nregs + frame.nsseregs) == 1)\n       || crtl->calls_eh_return)\n     {\n       /* Restore registers.  We can use ebp or esp to address the memory"}]}