{"sha": "4172a8e33873fc9c93121fccfa97d5d22aff1537", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE3MmE4ZTMzODczZmM5YzkzMTIxZmNjZmE5N2Q1ZDIyYWZmMTUzNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-12-21T13:51:03Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-12-21T13:51:03Z"}, "message": "[multiple changes]\n\n2011-12-21  Vincent Celier  <celier@adacore.com>\n\n\t* prj-nmsc.adb (Report_No_Sources): Remove argument Lang. Report\n\tno sources even for languages that are not allowed.\n\t(Add_Source): Get the source even when the language is not allowed.\n\n2011-12-21  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch6.adb (Process_Formals): Add defensive code.\n\n2011-12-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch7.adb, sem_ch13.adb (Analyze_Package_Specification): Build the\n\tinvariant procedure of a type declaration that is a completion and has\n\taspect specifications.\n\t(Build_Invariant_Procedure): If the procedure is built for a\n\ttype declaration that is a completion, analyze body expliitly\n\tbecause all private declarations have been already analyzed.\n\n2011-12-21  Claire Dross  <dross@adacore.com>\n\n\t* a-cfdlli.adb, a-cfhase.adb, a-cforma.adb, a-cforse.adb,\n\ta-cofove.adb: Minor reformating on formal containers\n\n2011-12-21  Vincent Celier  <celier@adacore.com>\n\n\t* makeutl.adb (Mains.Complete_Mains.Do_Complete): Remove\n\tany main that is not in the list of restricted languages.\n\t(Insert_Project_Sources.Do_Insert): Only add sources of languages\n\tin the list of restricted languages.\n\n2011-12-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_res.adb (Valid_Conversion): A type conversion is valid when\n\tthe target type is an anonymous access type and the operand is a\n\trewriting of an allocator. The conversion is typically inserted\n\twhen the designated type is an interface.\n\n2011-12-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch9.adb (Establish_Task_Master): If the enclosing block\n\thas no declarations, create new declarative list for it.\n\n2011-12-21  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-rbtgbk.adb (Generic_Conditional_Insert): Fixed incorrect comment.\n\nFrom-SVN: r182586", "tree": {"sha": "3954a53c4489b3a57bd7059ad7f7285d618d3db4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3954a53c4489b3a57bd7059ad7f7285d618d3db4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4172a8e33873fc9c93121fccfa97d5d22aff1537", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4172a8e33873fc9c93121fccfa97d5d22aff1537", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4172a8e33873fc9c93121fccfa97d5d22aff1537", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4172a8e33873fc9c93121fccfa97d5d22aff1537/comments", "author": null, "committer": null, "parents": [{"sha": "1c1631789db78470153d892bb17be385ff82088b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c1631789db78470153d892bb17be385ff82088b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c1631789db78470153d892bb17be385ff82088b"}], "stats": {"total": 255, "additions": 180, "deletions": 75}, "files": [{"sha": "64de1d4b41751727df45e0c2ac9d6c1fad198dda", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4172a8e33873fc9c93121fccfa97d5d22aff1537", "patch": "@@ -1,3 +1,50 @@\n+2011-12-21  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-nmsc.adb (Report_No_Sources): Remove argument Lang. Report\n+\tno sources even for languages that are not allowed.\n+\t(Add_Source): Get the source even when the language is not allowed.\n+\n+2011-12-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch6.adb (Process_Formals): Add defensive code.\n+\n+2011-12-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch7.adb, sem_ch13.adb (Analyze_Package_Specification): Build the\n+\tinvariant procedure of a type declaration that is a completion and has\n+\taspect specifications.\n+\t(Build_Invariant_Procedure): If the procedure is built for a\n+\ttype declaration that is a completion, analyze body expliitly\n+\tbecause all private declarations have been already analyzed.\n+\n+2011-12-21  Claire Dross  <dross@adacore.com>\n+\n+\t* a-cfdlli.adb, a-cfhase.adb, a-cforma.adb, a-cforse.adb,\n+\ta-cofove.adb: Minor reformating on formal containers\n+\n+2011-12-21  Vincent Celier  <celier@adacore.com>\n+\n+\t* makeutl.adb (Mains.Complete_Mains.Do_Complete): Remove\n+\tany main that is not in the list of restricted languages.\n+\t(Insert_Project_Sources.Do_Insert): Only add sources of languages\n+\tin the list of restricted languages.\n+\n+2011-12-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_res.adb (Valid_Conversion): A type conversion is valid when\n+\tthe target type is an anonymous access type and the operand is a\n+\trewriting of an allocator. The conversion is typically inserted\n+\twhen the designated type is an interface.\n+\n+2011-12-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch9.adb (Establish_Task_Master): If the enclosing block\n+\thas no declarations, create new declarative list for it.\n+\n+2011-12-21  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* a-rbtgbk.adb (Generic_Conditional_Insert): Fixed incorrect comment.\n+\n 2011-12-21  Yannick Moy  <moy@adacore.com>\n \n \t* sem_ch13.adb (Analyze_Attribute_Definition_Clause): Do not"}, {"sha": "404c66359db53cc833ca1a27a64d2427eedbef91", "filename": "gcc/ada/a-cfdlli.adb", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fa-cfdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fa-cfdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.adb?ref=4172a8e33873fc9c93121fccfa97d5d22aff1537", "patch": "@@ -1403,15 +1403,7 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       pragma Assert\n         (Vet (Container, Position), \"bad cursor in Replace_Element\");\n \n-      declare\n-         N : Node_Array renames Container.Nodes;\n-      begin\n-         N (Position.Node).Element := New_Item;\n-      end;\n-\n-      --  Above is peculiar, why not simply\n-      --  Container.Nodes (Position.Node).Element := New_Item ???\n-\n+      Container.Nodes (Position.Node).Element := New_Item;\n    end Replace_Element;\n \n    ----------------------"}, {"sha": "fe6706bcd43d30d4e3df9eabf3c924b1cf5a6dce", "filename": "gcc/ada/a-cfhase.adb", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fa-cfhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fa-cfhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.adb?ref=4172a8e33873fc9c93121fccfa97d5d22aff1537", "patch": "@@ -1471,7 +1471,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       --  Start of processing for Union\n \n    begin\n-\n       if Target'Address = Source'Address then\n          return;\n       end if;\n@@ -1646,7 +1645,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          X : Count_Type;\n \n       begin\n-\n          Key_Keys.Delete_Key_Sans_Free (Container, Key, X);\n \n          if X = 0 then\n@@ -1768,7 +1766,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n          N    : Nodes_Type renames Container.Nodes;\n \n       begin\n-\n          if Position.Node = 0 then\n             raise Constraint_Error with\n               \"Position cursor equals No_Element\";"}, {"sha": "ce361a1a2b0e836cc0f1b5f813ceb5125b6e87a4", "filename": "gcc/ada/a-cforma.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fa-cforma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fa-cforma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.adb?ref=4172a8e33873fc9c93121fccfa97d5d22aff1537", "patch": "@@ -1025,7 +1025,6 @@ package body Ada.Containers.Formal_Ordered_Maps is\n                                              Element : Element_Type))\n    is\n    begin\n-\n       if not Has_Element (Container, Position) then\n          raise Constraint_Error with\n            \"Position cursor of Query_Element has no element\";"}, {"sha": "9872f2ce30e2fd542ddfa7ecf75d72ae8987183d", "filename": "gcc/ada/a-cforse.adb", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fa-cforse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fa-cforse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforse.adb?ref=4172a8e33873fc9c93121fccfa97d5d22aff1537", "patch": "@@ -452,11 +452,7 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       pragma Assert (Vet (Container, Position.Node),\n                      \"bad cursor in Element\");\n \n-      declare\n-         N : Tree_Types.Nodes_Type renames Container.Nodes;\n-      begin\n-         return N (Position.Node).Element;\n-      end;\n+      return Container.Nodes (Position.Node).Element;\n    end Element;\n \n    -------------------------"}, {"sha": "8900e054cb818a7cf53d0892513dac2b9565be22", "filename": "gcc/ada/a-cofove.adb", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fa-cofove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fa-cofove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.adb?ref=4172a8e33873fc9c93121fccfa97d5d22aff1537", "patch": "@@ -540,7 +540,6 @@ package body Ada.Containers.Formal_Vectors is\n       Last : constant Index_Type := Last_Index (Container);\n \n    begin\n-\n       K := Count_Type (Int (Index) - Int (No_Index));\n       for Indx in Index .. Last loop\n          if Get_Element (Container, K) = Item then\n@@ -628,7 +627,6 @@ package body Ada.Containers.Formal_Vectors is\n \n       procedure Merge (Target, Source : in out Vector) is\n       begin\n-\n          declare\n             TA : Elements_Array renames Target.Elements;\n             SA : Elements_Array renames Source.Elements;\n@@ -1326,7 +1324,6 @@ package body Ada.Containers.Formal_Vectors is\n       N : constant Count_Type := Length (Source);\n \n    begin\n-\n       if Target'Address = Source'Address then\n          return;\n       end if;\n@@ -1543,7 +1540,6 @@ package body Ada.Containers.Formal_Vectors is\n       New_Item  : Element_Type)\n    is\n    begin\n-\n       if Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n@@ -1568,7 +1564,6 @@ package body Ada.Containers.Formal_Vectors is\n       New_Item  : Element_Type)\n    is\n    begin\n-\n       if not Position.Valid then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n@@ -1932,7 +1927,6 @@ package body Ada.Containers.Formal_Vectors is\n       L : Natural renames Container.Lock;\n \n    begin\n-\n       if Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       end if;"}, {"sha": "e270abf1402cddd92ae611d10f3825ca40d58eb3", "filename": "gcc/ada/a-rbtgbk.adb", "status": "modified", "additions": 41, "deletions": 10, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fa-rbtgbk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fa-rbtgbk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rbtgbk.adb?ref=4172a8e33873fc9c93121fccfa97d5d22aff1537", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -140,8 +140,22 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Keys is\n       N : Nodes_Type renames Tree.Nodes;\n \n    begin\n-      Y := 0;\n+      --  This is a \"conditional\" insertion, meaning that the insertion request\n+      --  can \"fail\" in the sense that no new node is created. If the Key is\n+      --  equivalent to an existing node, then we return the existing node and\n+      --  Inserted is set to False. Otherwise, we allocate a new node (via\n+      --  Insert_Post) and Inserted is set to True.\n+\n+      --  Note that we are testing for equivalence here, not equality. Key must\n+      --  be strictly less than its next neighbor, and strictly greater than\n+      --  its previous neighbor, in order for the conditional insertion to\n+      --  succeed.\n+\n+      --  We search the tree to find the nearest neighbor of Key, which is\n+      --  either the smallest node greater than Key (Inserted is True), or the\n+      --  largest node less or equivalent to Key (Inserted is False).\n \n+      Y := 0;\n       X := Tree.Root;\n       Inserted := True;\n       while X /= 0 loop\n@@ -150,33 +164,50 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Keys is\n          X := (if Inserted then Ops.Left (N (X)) else Ops.Right (N (X)));\n       end loop;\n \n-      --  If Inserted is True, then this means either that Tree is\n-      --  empty, or there was a least one node (strictly) greater than\n-      --  Key. Otherwise, it means that Key is equal to or greater than\n-      --  every node.\n-\n       if Inserted then\n+\n+         --  Either Tree is empty, or Key is less than Y. If Y is the first\n+         --  node in the tree, then there are no other nodes that we need to\n+         --  search for, and we insert a new node into the tree.\n+\n          if Y = Tree.First then\n             Insert_Post (Tree, Y, True, Node);\n             return;\n          end if;\n \n+         --  Y is the next nearest-neighbor of Key. We know that Key is not\n+         --  equivalent to Y (because Key is strictly less than Y), so we move\n+         --  to the previous node, the nearest-neighbor just smaller or\n+         --  equivalent to Key.\n+\n          Node := Ops.Previous (Tree, Y);\n \n       else\n+         --  Y is the previous nearest-neighbor of Key. We know that Key is not\n+         --  less than Y, which means either that Key is equivalent to Y, or\n+         --  greater than Y.\n+\n          Node := Y;\n       end if;\n \n-      --  Here Node has a value that is less than or equal to Key. We\n-      --  now have to resolve whether Key is equal to or greater than\n-      --  Node, which determines whether the insertion succeeds.\n+      --  Key is equivalent to or greater than Node. We must resolve which is\n+      --  the case, to determine whether the conditional insertion succeeds.\n \n       if Is_Greater_Key_Node (Key, N (Node)) then\n+\n+         --  Key is strictly greater than Node, which means that Key is not\n+         --  equivalent to Node. In this case, the insertion succeeds, and we\n+         --  insert a new node into the tree.\n+\n          Insert_Post (Tree, Y, Inserted, Node);\n          Inserted := True;\n          return;\n       end if;\n \n+      --  Key is equivalent to Node. This is a conditional insertion, so we do\n+      --  not insert a new node in this case. We return the existing node and\n+      --  report that no insertion has occurred.\n+\n       Inserted := False;\n    end Generic_Conditional_Insert;\n "}, {"sha": "8cd39b9a1f109b4ad39e84af5e6a90103b7cce59", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=4172a8e33873fc9c93121fccfa97d5d22aff1537", "patch": "@@ -5086,10 +5086,21 @@ package body Exp_Ch9 is\n \n    procedure Establish_Task_Master (N : Node_Id) is\n       Call : Node_Id;\n+\n    begin\n       if Restriction_Active (No_Task_Hierarchy) = False then\n          Call := Build_Runtime_Call (Sloc (N), RE_Enter_Master);\n-         Prepend_To (Declarations (N), Call);\n+\n+         --  The block may have no declarations, and nevertheless be a task\n+         --  master, if it contains a call that may return an object that\n+         --  contains tasks.\n+\n+         if No (Declarations (N)) then\n+            Set_Declarations (N, New_List (Call));\n+         else\n+            Prepend_To (Declarations (N), Call);\n+         end if;\n+\n          Analyze (Call);\n       end if;\n    end Establish_Task_Master;"}, {"sha": "119bcbd2a1d81ebe87676e7b8734fd03ea71917e", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 44, "deletions": 25, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=4172a8e33873fc9c93121fccfa97d5d22aff1537", "patch": "@@ -1539,6 +1539,8 @@ package body Makeutl is\n          procedure Do_Complete\n            (Project : Project_Id; Tree : Project_Tree_Ref)\n          is\n+            J : Integer;\n+\n          begin\n             if Mains.Number_Of_Mains (Tree) > 0\n               or else Mains.Count_Of_Mains_With_No_Tree > 0\n@@ -1547,7 +1549,8 @@ package body Makeutl is\n                --  files we will be adding extra files at the end, and there's\n                --  no need to process them in turn.\n \n-               for J in reverse Names.First .. Names.Last loop\n+               J := Names.Last;\n+               loop\n                   declare\n                      File        : Main_Info       := Names.Table (J);\n                      Main_Id     : File_Name_Type  := File.File;\n@@ -1637,35 +1640,47 @@ package body Makeutl is\n                         end if;\n \n                         if Source /= No_Source then\n+                           if not Is_Allowed_Language\n+                                    (Source.Language.Name)\n+                           then\n+                              --  Remove any main that is not in the list of\n+                              --  restricted languages.\n \n-                           --  If we have found a multi-unit source file but\n-                           --  did not specify an index initially, we'll need\n-                           --  to compile all the units from the same source\n-                           --  file.\n+                              Names.Table (J .. Names.Last - 1) :=\n+                                Names.Table (J + 1 .. Names.Last);\n+                              Names.Set_Last (Names.Last - 1);\n \n-                           if Source.Index /= 0 and then File.Index = 0 then\n-                              Add_Multi_Unit_Sources (File.Tree, Source);\n-                           end if;\n+                           else\n+                              --  If we have found a multi-unit source file but\n+                              --  did not specify an index initially, we'll\n+                              --  need to compile all the units from the same\n+                              --  source file.\n \n-                           --  Now update the original Main, otherwise it will\n-                           --  be reported as not found.\n+                              if Source.Index /= 0 and then File.Index = 0 then\n+                                 Add_Multi_Unit_Sources (File.Tree, Source);\n+                              end if;\n \n-                           Debug_Output\n-                             (\"found main in project\", Source.Project.Name);\n-                           Names.Table (J).File    := Source.File;\n-                           Names.Table (J).Project := Source.Project;\n+                              --  Now update the original Main, otherwise it\n+                              --  will be reported as not found.\n \n-                           if Names.Table (J).Tree = null then\n-                              Names.Table (J).Tree := File.Tree;\n+                              Debug_Output\n+                                (\"found main in project\", Source.Project.Name);\n+                              Names.Table (J).File    := Source.File;\n+                              Names.Table (J).Project := Source.Project;\n \n-                              Builder_Data (File.Tree).Number_Of_Mains :=\n-                                Builder_Data (File.Tree).Number_Of_Mains + 1;\n-                              Mains.Count_Of_Mains_With_No_Tree :=\n-                                Mains.Count_Of_Mains_With_No_Tree - 1;\n-                           end if;\n+                              if Names.Table (J).Tree = null then\n+                                 Names.Table (J).Tree := File.Tree;\n \n-                           Names.Table (J).Source  := Source;\n-                           Names.Table (J).Index   := Source.Index;\n+                                 Builder_Data (File.Tree).Number_Of_Mains :=\n+                                   Builder_Data (File.Tree).Number_Of_Mains\n+                                                                         + 1;\n+                                 Mains.Count_Of_Mains_With_No_Tree :=\n+                                   Mains.Count_Of_Mains_With_No_Tree - 1;\n+                              end if;\n+\n+                              Names.Table (J).Source  := Source;\n+                              Names.Table (J).Index   := Source.Index;\n+                           end if;\n \n                         elsif File.Location /= No_Location then\n \n@@ -1684,6 +1699,9 @@ package body Makeutl is\n                         end if;\n                      end if;\n                   end;\n+\n+                  J := J - 1;\n+                  exit when J < Names.First;\n                end loop;\n             end if;\n \n@@ -2781,10 +2799,11 @@ package body Makeutl is\n                Source := Prj.Element (Iter);\n                exit when Source = No_Source;\n \n-               if Is_Compilable (Source)\n+               if Is_Allowed_Language (Source.Language.Name)\n+                 and then Is_Compilable (Source)\n                  and then\n                    (All_Projects\n-                    or else Is_Extending (Project, Source.Project))\n+                     or else Is_Extending (Project, Source.Project))\n                  and then not Source.Locally_Removed\n                  and then Source.Replaced_By = No_Source\n                  and then"}, {"sha": "c3cb4b6e351d33e6d21538d2a12ca0bb398c1b09", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=4172a8e33873fc9c93121fccfa97d5d22aff1537", "patch": "@@ -486,7 +486,6 @@ package body Prj.Nmsc is\n \n    procedure Report_No_Sources\n      (Project      : Project_Id;\n-      Lang         : Name_Id;\n       Lang_Name    : String;\n       Data         : Tree_Processing_Data;\n       Location     : Source_Ptr;\n@@ -643,13 +642,6 @@ package body Prj.Nmsc is\n       Source_To_Replace : Source_Id := No_Source;\n \n    begin\n-      --  Nothing to do if the language is not one of the restricted ones\n-\n-      if not Is_Allowed_Language (Lang_Id.Name) then\n-         Id := No_Source;\n-         return;\n-      end if;\n-\n       --  Check if the same file name or unit is used in the prj tree\n \n       Add_Src := True;\n@@ -7809,7 +7801,6 @@ package body Prj.Nmsc is\n                   if Source = No_Source then\n                      Report_No_Sources\n                        (Project.Project,\n-                        Language.Name,\n                         Get_Name_String (Language.Display_Name),\n                         Data,\n                         Project.Source_List_File_Location,\n@@ -8256,15 +8247,13 @@ package body Prj.Nmsc is\n \n    procedure Report_No_Sources\n      (Project      : Project_Id;\n-      Lang         : Name_Id;\n       Lang_Name    : String;\n       Data         : Tree_Processing_Data;\n       Location     : Source_Ptr;\n       Continuation : Boolean := False)\n    is\n    begin\n-      if Is_Allowed_Language (Lang) then\n-         case Data.Flags.When_No_Sources is\n+      case Data.Flags.When_No_Sources is\n          when Silent =>\n             null;\n \n@@ -8283,8 +8272,7 @@ package body Prj.Nmsc is\n                   Error_Msg (Data.Flags, Msg, Location, Project);\n                end if;\n             end;\n-         end case;\n-      end if;\n+      end case;\n    end Report_No_Sources;\n \n    ----------------------"}, {"sha": "6ffe9f2e15fd683dd8ebd8f1119d2f659e51678a", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=4172a8e33873fc9c93121fccfa97d5d22aff1537", "patch": "@@ -4738,6 +4738,14 @@ package body Sem_Ch13 is\n             --  (this is an error that will be caught elsewhere);\n \n             Append_To (Private_Decls, PBody);\n+\n+            --  If the invariant appears on the full view of a type, the\n+            --  analysis of the private part is complete, and we must\n+            --  analyze the new body explicitly.\n+\n+            if In_Private_Part (Current_Scope) then\n+               Analyze (PBody);\n+            end if;\n          end if;\n       end if;\n    end Build_Invariant_Procedure;"}, {"sha": "4286c0d71497d944bdcf65f424bf7b917da424b1", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=4172a8e33873fc9c93121fccfa97d5d22aff1537", "patch": "@@ -9552,6 +9552,12 @@ package body Sem_Ch6 is\n             Num_Out_Params := Num_Out_Params + 1;\n          end if;\n \n+         --  Skip remaining processing if formal type was in error\n+\n+         if Etype (Formal) = Any_Type or else Error_Posted (Formal) then\n+            goto Next_Parameter;\n+         end if;\n+\n          --  Force call by reference if aliased\n \n          if Is_Aliased (Formal) then\n@@ -9573,6 +9579,7 @@ package body Sem_Ch6 is\n             Set_Mechanism (Formal, By_Reference);\n          end if;\n \n+      <<Next_Parameter>>\n          Next (Param_Spec);\n       end loop;\n "}, {"sha": "094837be97c226515f94c2b1adbf43f13ba62537", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=4172a8e33873fc9c93121fccfa97d5d22aff1537", "patch": "@@ -1378,6 +1378,16 @@ package body Sem_Ch7 is\n               (\"full view of & does not have preelaborable initialization\", E);\n          end if;\n \n+         --  An invariant may appear on a full view of a type\n+\n+         if Is_Type (E)\n+           and then Has_Private_Declaration (E)\n+           and then Nkind (Parent (E)) = N_Full_Type_Declaration\n+           and then Has_Aspects (Parent (E))\n+         then\n+            Build_Invariant_Procedure (E, N);\n+         end if;\n+\n          Next_Entity (E);\n       end loop;\n "}, {"sha": "c25a305daab41a624410dca47fcbed069d6a5d8e", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4172a8e33873fc9c93121fccfa97d5d22aff1537/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=4172a8e33873fc9c93121fccfa97d5d22aff1537", "patch": "@@ -10719,7 +10719,13 @@ package body Sem_Res is\n          --  check is not enforced when within an instance body, since the\n          --  RM requires such cases to be caught at run time.\n \n-         if Ekind (Target_Type) /= E_Anonymous_Access_Type then\n+         --  If the operand is a rewriting of an allocator no check is needed\n+         --  because there are no accessibility issues.\n+\n+         if Nkind (Original_Node (N)) = N_Allocator then\n+            null;\n+\n+         elsif Ekind (Target_Type) /= E_Anonymous_Access_Type then\n             if Type_Access_Level (Opnd_Type) >\n                Deepest_Type_Access_Level (Target_Type)\n             then"}]}