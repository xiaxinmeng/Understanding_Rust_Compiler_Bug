{"sha": "005326029f35b4271c5274114a17126039fe18a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA1MzI2MDI5ZjM1YjQyNzFjNTI3NDExNGExNzEyNjAzOWZlMThhMA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2002-02-12T04:35:58Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2002-02-12T04:35:58Z"}, "message": "stl_algo (__stl_threshold): Declare external.\n\n\n2002-02-11   Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/bits/stl_algo (__stl_threshold): Declare external.\n\t(__stl_chunk_size): Same.\n\t* include/bits/stl_bvector.h (__WORD_BIT): Same.\n\t* include/bits/stl_tree.h (_S_rb_tree_red): Same.\n\t(_S_rb_tree_black): Same.\n\t* src/stl-inst.cc (__stl_threshold): Define.\n\t(__stl_chunk_size): Same.\n\t(__WORD_BIT): Same.\n\t(_S_rb_tree_red): Same.\n\t(_S_rb_tree_black): Same.\n\n\t* config/io/basic_file_libio.h (__basic_file): Add declarations.\n\t* include/bits/basic_file.h: Remove.\n\t* config/io/c_io_stdio.h: Remove _GLIBCPP_BASIC_FILE_ENCAPSULATION\n\tDeclare generic types, specialization.\n        * config/io/basic_file_stdio.cc: Definitions.\n\t* config/io/c_io_libio.h: Remove _GLIBCPP_BASIC_FILE_INHERITANCE.\n\tDeclare generic types.\n\t* include/Makefile.am (bits_headers): Remove basic_file.h.\n\t(extra_target_headers): Change basic_file_model.h to basic_file.h.\n\t(stamp-target): Same.\n\n\t* include/bits/stl_alloc.h: Tweaks.\n\t* include/bits/localefwd.h: Same.\n\nFrom-SVN: r49697", "tree": {"sha": "6750061c80a84c0a89a69b65f0ed46a83e85c2b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6750061c80a84c0a89a69b65f0ed46a83e85c2b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/005326029f35b4271c5274114a17126039fe18a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/005326029f35b4271c5274114a17126039fe18a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/005326029f35b4271c5274114a17126039fe18a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/005326029f35b4271c5274114a17126039fe18a0/comments", "author": null, "committer": null, "parents": [{"sha": "1febeb40bfbd7970e5b7b74ddd9d06b2dff4de12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1febeb40bfbd7970e5b7b74ddd9d06b2dff4de12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1febeb40bfbd7970e5b7b74ddd9d06b2dff4de12"}], "stats": {"total": 4004, "additions": 2080, "deletions": 1924}, "files": [{"sha": "7c8a20f25f0bf6ed101be21a231dd9e2ece4ca2b", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=005326029f35b4271c5274114a17126039fe18a0", "patch": "@@ -1,3 +1,30 @@\n+2002-02-11   Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/bits/stl_algo (__stl_threshold): Declare external.\t\n+\t(__stl_chunk_size): Same.\n+\t* include/bits/stl_bvector.h (__WORD_BIT): Same.\n+\t* include/bits/stl_tree.h (_S_rb_tree_red): Same.\n+\t(_S_rb_tree_black): Same.\n+\t* src/stl-inst.cc (__stl_threshold): Define.\n+\t(__stl_chunk_size): Same.\n+\t(__WORD_BIT): Same.\n+\t(_S_rb_tree_red): Same.\n+\t(_S_rb_tree_black): Same.\n+\t\n+\t* config/io/basic_file_libio.h (__basic_file): Add declarations.\n+\t* include/bits/basic_file.h: Remove.\n+\t* config/io/c_io_stdio.h: Remove _GLIBCPP_BASIC_FILE_ENCAPSULATION\n+\tDeclare generic types, specialization.\n+        * config/io/basic_file_stdio.cc: Definitions.   \n+\t* config/io/c_io_libio.h: Remove _GLIBCPP_BASIC_FILE_INHERITANCE.\n+\tDeclare generic types.\n+\t* include/Makefile.am (bits_headers): Remove basic_file.h.\n+\t(extra_target_headers): Change basic_file_model.h to basic_file.h.\n+\t(stamp-target): Same.\n+\n+\t* include/bits/stl_alloc.h: Tweaks.\n+\t* include/bits/localefwd.h: Same.\t\n+\n 2002-02-11  Aaron W LaFramboise  <AWLaFramboise@aol.com>\n \n \t* include/bits/locale_facets.tcc (collate::do_hash): Fix.\n@@ -17,7 +44,7 @@\n \tgenerate, generate_n, remove_copy, remove_copy_if, remove, remove_if,\n \tunique, unique_copy, reverse, reverse_copy):  Doxygenate.\n \n-2002-02-08   Benjamin Kosnik  <bkoz@redhat.com>\n+2002-02-08  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* include/bits/locale_facets.h\n \t(numpunct<_CharT>::_M_initialize_numpunct): Remove definition."}, {"sha": "594b84dfc0813a16978da82178890734c8c22327", "filename": "libstdc++-v3/aclocal.m4", "status": "modified", "additions": 346, "deletions": 182, "changes": 528, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Faclocal.m4?ref=005326029f35b4271c5274114a17126039fe18a0", "patch": "@@ -2017,6 +2017,24 @@ fi\n \n \n \n+#serial 1\n+# This test replaces the one in autoconf.\n+# Currently this macro should have the same name as the autoconf macro\n+# because gettext's gettext.m4 (distributed in the automake package)\n+# still uses it.  Otherwise, the use in gettext.m4 makes autoheader\n+# give these diagnostics:\n+#   configure.in:556: AC_TRY_COMPILE was called before AC_ISC_POSIX\n+#   configure.in:556: AC_TRY_RUN was called before AC_ISC_POSIX\n+\n+undefine([AC_ISC_POSIX])\n+\n+AC_DEFUN([AC_ISC_POSIX],\n+  [\n+    dnl This test replaces the obsolescent AC_ISC_POSIX kludge.\n+    AC_CHECK_LIB(cposix, strerror, [LIBS=\"$LIBS -lcposix\"])\n+  ]\n+)\n+\n # Add --enable-maintainer-mode option to configure.\n # From Jim Meyering\n \n@@ -2058,9 +2076,37 @@ fi])\n # but which still want to provide support for the GNU gettext functionality.\n # Please note that the actual code is *not* freely available.\n \n-# serial 5\n-\n-AC_DEFUN(AM_WITH_NLS,\n+# serial 9\n+\n+dnl Usage: AM_WITH_NLS([TOOLSYMBOL], [NEEDSYMBOL], [LIBDIR]).\n+dnl If TOOLSYMBOL is specified and is 'use-libtool', then a libtool library\n+dnl    $(top_builddir)/intl/libintl.la will be created (shared and/or static,\n+dnl    depending on --{enable,disable}-{shared,static} and on the presence of\n+dnl    AM-DISABLE-SHARED). Otherwise, a static library\n+dnl    $(top_builddir)/intl/libintl.a will be created.\n+dnl If NEEDSYMBOL is specified and is 'need-ngettext', then GNU gettext\n+dnl    implementations (in libc or libintl) without the ngettext() function\n+dnl    will be ignored.\n+dnl LIBDIR is used to find the intl libraries.  If empty,\n+dnl    the value `$(top_builddir)/intl/' is used.\n+dnl\n+dnl The result of the configuration is one of three cases:\n+dnl 1) GNU gettext, as included in the intl subdirectory, will be compiled\n+dnl    and used.\n+dnl    Catalog format: GNU --> install in $(datadir)\n+dnl    Catalog extension: .mo after installation, .gmo in source tree\n+dnl 2) GNU gettext has been found in the system's C library.\n+dnl    Catalog format: GNU --> install in $(datadir)\n+dnl    Catalog extension: .mo after installation, .gmo in source tree\n+dnl 3) No internationalization, always use English msgid.\n+dnl    Catalog format: none\n+dnl    Catalog extension: none\n+dnl The use of .gmo is historical (it was needed to avoid overwriting the\n+dnl GNU format catalogs when building on a platform with an X/Open gettext),\n+dnl but we keep it in order not to force irrelevant filename changes on the\n+dnl maintainers.\n+dnl\n+AC_DEFUN([AM_WITH_NLS],\n   [AC_MSG_CHECKING([whether NLS is requested])\n     dnl Default is enabled NLS\n     AC_ARG_ENABLE(nls,\n@@ -2069,11 +2115,15 @@ AC_DEFUN(AM_WITH_NLS,\n     AC_MSG_RESULT($USE_NLS)\n     AC_SUBST(USE_NLS)\n \n+    BUILD_INCLUDED_LIBINTL=no\n     USE_INCLUDED_LIBINTL=no\n+    INTLLIBS=\n \n     dnl If we use NLS figure out what method\n     if test \"$USE_NLS\" = \"yes\"; then\n-      AC_DEFINE(ENABLE_NLS)\n+      AC_DEFINE(ENABLE_NLS, 1,\n+        [Define to 1 if translation of program messages to the user's native language\n+   is requested.])\n       AC_MSG_CHECKING([whether included gettext is requested])\n       AC_ARG_WITH(included-gettext,\n         [  --with-included-gettext use the GNU gettext library included here],\n@@ -2084,89 +2134,74 @@ AC_DEFUN(AM_WITH_NLS,\n       nls_cv_use_gnu_gettext=\"$nls_cv_force_use_gnu_gettext\"\n       if test \"$nls_cv_force_use_gnu_gettext\" != \"yes\"; then\n         dnl User does not insist on using GNU NLS library.  Figure out what\n-        dnl to use.  If gettext or catgets are available (in this order) we\n-        dnl use this.  Else we have to fall back to GNU NLS library.\n-\tdnl catgets is only used if permitted by option --with-catgets.\n-\tnls_cv_header_intl=\n-\tnls_cv_header_libgt=\n+        dnl to use.  If GNU gettext is available we use this.  Else we have\n+        dnl to fall back to GNU NLS library.\n \tCATOBJEXT=NONE\n \n+        dnl Add a version number to the cache macros.\n+        define(gt_cv_func_gnugettext_libc, [gt_cv_func_gnugettext]ifelse([$2], need-ngettext, 2, 1)[_libc])\n+        define(gt_cv_func_gnugettext_libintl, [gt_cv_func_gnugettext]ifelse([$2], need-ngettext, 2, 1)[_libintl])\n+\n \tAC_CHECK_HEADER(libintl.h,\n-\t  [AC_CACHE_CHECK([for gettext in libc], gt_cv_func_gettext_libc,\n-\t    [AC_TRY_LINK([#include <libintl.h>], [return (int) gettext (\"\")],\n-\t       gt_cv_func_gettext_libc=yes, gt_cv_func_gettext_libc=no)])\n-\n-\t   if test \"$gt_cv_func_gettext_libc\" != \"yes\"; then\n-\t     AC_CHECK_LIB(intl, bindtextdomain,\n-\t       [AC_CACHE_CHECK([for gettext in libintl],\n-\t\t gt_cv_func_gettext_libintl,\n-\t\t [AC_CHECK_LIB(intl, gettext,\n-\t\t  gt_cv_func_gettext_libintl=yes,\n-\t\t  gt_cv_func_gettext_libintl=no)],\n-\t\t gt_cv_func_gettext_libintl=no)])\n+\t  [AC_CACHE_CHECK([for GNU gettext in libc], gt_cv_func_gnugettext_libc,\n+\t    [AC_TRY_LINK([#include <libintl.h>\n+extern int _nl_msg_cat_cntr;],\n+\t       [bindtextdomain (\"\", \"\");\n+return (int) gettext (\"\")]ifelse([$2], need-ngettext, [ + (int) ngettext (\"\", \"\", 0)], [])[ + _nl_msg_cat_cntr],\n+\t       gt_cv_func_gnugettext_libc=yes,\n+\t       gt_cv_func_gnugettext_libc=no)])\n+\n+\t   if test \"$gt_cv_func_gnugettext_libc\" != \"yes\"; then\n+\t     AC_CACHE_CHECK([for GNU gettext in libintl],\n+\t       gt_cv_func_gnugettext_libintl,\n+\t       [gt_save_LIBS=\"$LIBS\"\n+\t\tLIBS=\"$LIBS -lintl $LIBICONV\"\n+\t\tAC_TRY_LINK([#include <libintl.h>\n+extern int _nl_msg_cat_cntr;],\n+\t\t  [bindtextdomain (\"\", \"\");\n+return (int) gettext (\"\")]ifelse([$2], need-ngettext, [ + (int) ngettext (\"\", \"\", 0)], [])[ + _nl_msg_cat_cntr],\n+\t\t  gt_cv_func_gnugettext_libintl=yes,\n+\t\t  gt_cv_func_gnugettext_libintl=no)\n+\t\tLIBS=\"$gt_save_LIBS\"])\n \t   fi\n \n-\t   if test \"$gt_cv_func_gettext_libc\" = \"yes\" \\\n-\t      || test \"$gt_cv_func_gettext_libintl\" = \"yes\"; then\n-\t      AC_DEFINE(HAVE_GETTEXT)\n-\t      AM_PATH_PROG_WITH_TEST(MSGFMT, msgfmt,\n-\t\t[test -z \"`$ac_dir/$ac_word -h 2>&1 | grep 'dv '`\"], no)dnl\n-\t      if test \"$MSGFMT\" != \"no\"; then\n-\t\tAC_CHECK_FUNCS(dcgettext)\n-\t\tAC_PATH_PROG(GMSGFMT, gmsgfmt, $MSGFMT)\n-\t\tAM_PATH_PROG_WITH_TEST(XGETTEXT, xgettext,\n-\t\t  [test -z \"`$ac_dir/$ac_word -h 2>&1 | grep '(HELP)'`\"], :)\n-\t\tAC_TRY_LINK(, [extern int _nl_msg_cat_cntr;\n-\t\t\t       return _nl_msg_cat_cntr],\n-\t\t  [CATOBJEXT=.gmo\n-\t\t   DATADIRNAME=share],\n-\t\t  [CATOBJEXT=.mo\n-\t\t   DATADIRNAME=lib])\n-\t\tINSTOBJEXT=.mo\n-\t      fi\n-\t    fi\n-\t    if test \"$gt_cv_func_gettext_libintl\" = \"yes\"; then\n-\t\tINTLLIBS='-lintl'\n-\t    fi\n+\t   dnl If an already present or preinstalled GNU gettext() is found,\n+\t   dnl use it.  But if this macro is used in GNU gettext, and GNU\n+\t   dnl gettext is already preinstalled in libintl, we update this\n+\t   dnl libintl.  (Cf. the install rule in intl/Makefile.in.)\n+\t   if test \"$gt_cv_func_gnugettext_libc\" = \"yes\" \\\n+\t      || { test \"$gt_cv_func_gnugettext_libintl\" = \"yes\" \\\n+\t\t   && test \"$PACKAGE\" != gettext; }; then\n+\t     AC_DEFINE(HAVE_GETTEXT, 1,\n+               [Define if the GNU gettext() function is already present or preinstalled.])\n+\n+\t     if test \"$gt_cv_func_gnugettext_libintl\" = \"yes\"; then\n+\t       dnl If iconv() is in a separate libiconv library, then anyone\n+\t       dnl linking with libintl{.a,.so} also needs to link with\n+\t       dnl libiconv.\n+\t       INTLLIBS=\"-lintl $LIBICONV\"\n+\t     fi\n+\n+\t     gt_save_LIBS=\"$LIBS\"\n+\t     LIBS=\"$LIBS $INTLLIBS\"\n+\t     AC_CHECK_FUNCS(dcgettext)\n+\t     LIBS=\"$gt_save_LIBS\"\n+\n+\t     AM_PATH_PROG_WITH_TEST(MSGFMT, msgfmt,\n+\t       [test -z \"`$ac_dir/$ac_word -h 2>&1 | grep 'dv '`\"], no)dnl\n+\t     if test \"$MSGFMT\" != \"no\"; then\n+\t       AC_PATH_PROG(GMSGFMT, gmsgfmt, $MSGFMT)\n+\t     fi\n+\n+\t     AM_PATH_PROG_WITH_TEST(XGETTEXT, xgettext,\n+\t       [test -z \"`$ac_dir/$ac_word -h 2>&1 | grep '(HELP)'`\"], :)\n+\n+\t     CATOBJEXT=.gmo\n+\t   fi\n \t])\n \n         if test \"$CATOBJEXT\" = \"NONE\"; then\n-\t  AC_MSG_CHECKING([whether catgets can be used])\n-\t  AC_ARG_WITH(catgets,\n-\t    [  --with-catgets          use catgets functions if available],\n-\t    nls_cv_use_catgets=$withval, nls_cv_use_catgets=no)\n-\t  AC_MSG_RESULT($nls_cv_use_catgets)\n-\n-\t  if test \"$nls_cv_use_catgets\" = \"yes\"; then\n-\t    dnl No gettext in C library.  Try catgets next.\n-\t    AC_CHECK_LIB(i, main)\n-\t    AC_CHECK_FUNC(catgets,\n-\t      [AC_DEFINE(HAVE_CATGETS)\n-\t       INTLOBJS=\"\\$(CATOBJS)\"\n-\t       AC_PATH_PROG(GENCAT, gencat, no)dnl\n-\t       if test \"$GENCAT\" != \"no\"; then\n-\t\t AC_PATH_PROG(GMSGFMT, gmsgfmt, no)\n-\t\t if test \"$GMSGFMT\" = \"no\"; then\n-\t\t   AM_PATH_PROG_WITH_TEST(GMSGFMT, msgfmt,\n-\t\t    [test -z \"`$ac_dir/$ac_word -h 2>&1 | grep 'dv '`\"], no)\n-\t\t fi\n-\t\t AM_PATH_PROG_WITH_TEST(XGETTEXT, xgettext,\n-\t\t   [test -z \"`$ac_dir/$ac_word -h 2>&1 | grep '(HELP)'`\"], :)\n-\t\t USE_INCLUDED_LIBINTL=yes\n-\t\t CATOBJEXT=.cat\n-\t\t INSTOBJEXT=.cat\n-\t\t DATADIRNAME=lib\n-\t\t INTLDEPS='$(top_builddir)/intl/libintl.a'\n-\t\t INTLLIBS=$INTLDEPS\n-\t\t LIBS=`echo $LIBS | sed -e 's/-lintl//'`\n-\t\t nls_cv_header_intl=intl/libintl.h\n-\t\t nls_cv_header_libgt=intl/libgettext.h\n-\t       fi])\n-\t  fi\n-        fi\n-\n-        if test \"$CATOBJEXT\" = \"NONE\"; then\n-\t  dnl Neither gettext nor catgets in included in the C library.\n+\t  dnl GNU gettext is not found in the C library.\n \t  dnl Fall back on GNU gettext library.\n \t  nls_cv_use_gnu_gettext=yes\n         fi\n@@ -2181,15 +2216,11 @@ AC_DEFUN(AM_WITH_NLS,\n         AM_PATH_PROG_WITH_TEST(XGETTEXT, xgettext,\n \t  [test -z \"`$ac_dir/$ac_word -h 2>&1 | grep '(HELP)'`\"], :)\n         AC_SUBST(MSGFMT)\n+\tBUILD_INCLUDED_LIBINTL=yes\n \tUSE_INCLUDED_LIBINTL=yes\n         CATOBJEXT=.gmo\n-        INSTOBJEXT=.mo\n-        DATADIRNAME=share\n-\tINTLDEPS='$(top_builddir)/intl/libintl.a'\n-\tINTLLIBS=$INTLDEPS\n-\tLIBS=`echo $LIBS | sed -e 's/-lintl//'`\n-        nls_cv_header_intl=intl/libintl.h\n-        nls_cv_header_libgt=intl/libgettext.h\n+\tINTLLIBS=\"ifelse([$3],[],\\$(top_builddir)/intl,[$3])/libintl.ifelse([$1], use-libtool, [l], [])a $LIBICONV\"\n+\tLIBS=`echo \" $LIBS \" | sed -e 's/ -lintl / /' -e 's/^ //' -e 's/ $//'`\n       fi\n \n       dnl Test whether we really found GNU xgettext.\n@@ -2205,25 +2236,73 @@ AC_DEFUN(AM_WITH_NLS,\n \tfi\n       fi\n \n-      # We need to process the po/ directory.\n+      dnl We need to process the po/ directory.\n       POSUB=po\n-    else\n-      DATADIRNAME=share\n-      nls_cv_header_intl=intl/libintl.h\n-      nls_cv_header_libgt=intl/libgettext.h\n     fi\n-    AC_LINK_FILES($nls_cv_header_libgt, $nls_cv_header_intl)\n     AC_OUTPUT_COMMANDS(\n-     [case \"$CONFIG_FILES\" in *po/Makefile.in*)\n-        sed -e \"/POTFILES =/r po/POTFILES\" po/Makefile.in > po/Makefile\n-      esac])\n+     [for ac_file in $CONFIG_FILES; do\n+        # Support \"outfile[:infile[:infile...]]\"\n+        case \"$ac_file\" in\n+          *:*) ac_file=`echo \"$ac_file\"|sed 's%:.*%%'` ;;\n+        esac\n+        # PO directories have a Makefile.in generated from Makefile.in.in.\n+        case \"$ac_file\" in */Makefile.in)\n+          # Adjust a relative srcdir.\n+          ac_dir=`echo \"$ac_file\"|sed 's%/[^/][^/]*$%%'`\n+          ac_dir_suffix=\"/`echo \"$ac_dir\"|sed 's%^\\./%%'`\"\n+          ac_dots=`echo \"$ac_dir_suffix\"|sed 's%/[^/]*%../%g'`\n+          case \"$ac_given_srcdir\" in\n+            .)  top_srcdir=`echo $ac_dots|sed 's%/$%%'` ;;\n+            /*) top_srcdir=\"$ac_given_srcdir\" ;;\n+            *)  top_srcdir=\"$ac_dots$ac_given_srcdir\" ;;\n+          esac\n+          if test -f \"$ac_given_srcdir/$ac_dir/POTFILES.in\"; then\n+            rm -f \"$ac_dir/POTFILES\"\n+            echo creating \"$ac_dir/POTFILES\"\n+            sed -e \"/^#/d\" -e \"/^[ \t]*\\$/d\" -e \"s,.*,     $top_srcdir/& \\\\\\\\,\" -e \"\\$s/\\(.*\\) \\\\\\\\/\\1/\" < \"$ac_given_srcdir/$ac_dir/POTFILES.in\" > \"$ac_dir/POTFILES\"\n+            echo creating \"$ac_dir/Makefile\"\n+            sed -e \"/POTFILES =/r $ac_dir/POTFILES\" \"$ac_dir/Makefile.in\" > \"$ac_dir/Makefile\"\n+          fi\n+          ;;\n+        esac\n+      done])\n \n \n-    # If this is used in GNU gettext we have to set USE_NLS to `yes'\n-    # because some of the sources are only built for this goal.\n+    dnl If this is used in GNU gettext we have to set BUILD_INCLUDED_LIBINTL\n+    dnl to 'yes' because some of the testsuite requires it.\n     if test \"$PACKAGE\" = gettext; then\n-      USE_NLS=yes\n-      USE_INCLUDED_LIBINTL=yes\n+      BUILD_INCLUDED_LIBINTL=yes\n+    fi\n+\n+    dnl intl/plural.c is generated from intl/plural.y. It requires bison,\n+    dnl because plural.y uses bison specific features. It requires at least\n+    dnl bison-1.26 because earlier versions generate a plural.c that doesn't\n+    dnl compile.\n+    dnl bison is only needed for the maintainer (who touches plural.y). But in\n+    dnl order to avoid separate Makefiles or --enable-maintainer-mode, we put\n+    dnl the rule in general Makefile. Now, some people carelessly touch the\n+    dnl files or have a broken \"make\" program, hence the plural.c rule will\n+    dnl sometimes fire. To avoid an error, defines BISON to \":\" if it is not\n+    dnl present or too old.\n+    AC_CHECK_PROGS([INTLBISON], [bison])\n+    if test -z \"$INTLBISON\"; then\n+      ac_verc_fail=yes\n+    else\n+      dnl Found it, now check the version.\n+      AC_MSG_CHECKING([version of bison])\n+changequote(<<,>>)dnl\n+      ac_prog_version=`$INTLBISON --version 2>&1 | sed -n 's/^.*GNU Bison .* \\([0-9]*\\.[0-9.]*\\).*$/\\1/p'`\n+      case $ac_prog_version in\n+        '') ac_prog_version=\"v. ?.??, bad\"; ac_verc_fail=yes;;\n+        1.2[6-9]* | 1.[3-9][0-9]* | [2-9].*)\n+changequote([,])dnl\n+           ac_prog_version=\"$ac_prog_version, ok\"; ac_verc_fail=no;;\n+        *) ac_prog_version=\"$ac_prog_version, bad\"; ac_verc_fail=yes;;\n+      esac\n+      AC_MSG_RESULT([$ac_prog_version])\n+    fi\n+    if test $ac_verc_fail = yes; then\n+      INTLBISON=:\n     fi\n \n     dnl These rules are solely for the distribution goal.  While doing this\n@@ -2235,22 +2314,38 @@ AC_DEFUN(AM_WITH_NLS,\n     done\n \n     dnl Make all variables we use known to autoconf.\n+    AC_SUBST(BUILD_INCLUDED_LIBINTL)\n     AC_SUBST(USE_INCLUDED_LIBINTL)\n     AC_SUBST(CATALOGS)\n     AC_SUBST(CATOBJEXT)\n-    AC_SUBST(DATADIRNAME)\n     AC_SUBST(GMOFILES)\n-    AC_SUBST(INSTOBJEXT)\n-    AC_SUBST(INTLDEPS)\n     AC_SUBST(INTLLIBS)\n     AC_SUBST(INTLOBJS)\n     AC_SUBST(POFILES)\n     AC_SUBST(POSUB)\n+\n+    dnl For backward compatibility. Some configure.ins may be using this.\n+    nls_cv_header_intl=\n+    nls_cv_header_libgt=\n+\n+    dnl For backward compatibility. Some Makefiles may be using this.\n+    DATADIRNAME=share\n+    AC_SUBST(DATADIRNAME)\n+\n+    dnl For backward compatibility. Some Makefiles may be using this.\n+    INSTOBJEXT=.mo\n+    AC_SUBST(INSTOBJEXT)\n+\n+    dnl For backward compatibility. Some Makefiles may be using this.\n+    GENCAT=gencat\n+    AC_SUBST(GENCAT)\n   ])\n \n-AC_DEFUN(AM_GNU_GETTEXT,\n+dnl Usage: Just like AM_WITH_NLS, which see.\n+AC_DEFUN([AM_GNU_GETTEXT],\n   [AC_REQUIRE([AC_PROG_MAKE_SET])dnl\n    AC_REQUIRE([AC_PROG_CC])dnl\n+   AC_REQUIRE([AC_CANONICAL_HOST])dnl\n    AC_REQUIRE([AC_PROG_RANLIB])dnl\n    AC_REQUIRE([AC_ISC_POSIX])dnl\n    AC_REQUIRE([AC_HEADER_STDC])dnl\n@@ -2260,32 +2355,40 @@ AC_DEFUN(AM_GNU_GETTEXT,\n    AC_REQUIRE([AC_TYPE_SIZE_T])dnl\n    AC_REQUIRE([AC_FUNC_ALLOCA])dnl\n    AC_REQUIRE([AC_FUNC_MMAP])dnl\n+   AC_REQUIRE([jm_GLIBC21])dnl\n \n-   AC_CHECK_HEADERS([argz.h limits.h locale.h nl_types.h malloc.h string.h \\\n-unistd.h sys/param.h])\n-   AC_CHECK_FUNCS([getcwd munmap putenv setenv setlocale strchr strcasecmp \\\n-strdup __argz_count __argz_stringify __argz_next])\n-\n-   if test \"${ac_cv_func_stpcpy+set}\" != \"set\"; then\n-     AC_CHECK_FUNCS(stpcpy)\n-   fi\n-   if test \"${ac_cv_func_stpcpy}\" = \"yes\"; then\n-     AC_DEFINE(HAVE_STPCPY)\n-   fi\n+   AC_CHECK_HEADERS([argz.h limits.h locale.h nl_types.h malloc.h stddef.h \\\n+stdlib.h string.h unistd.h sys/param.h])\n+   AC_CHECK_FUNCS([feof_unlocked fgets_unlocked getcwd getegid geteuid \\\n+getgid getuid mempcpy munmap putenv setenv setlocale stpcpy strchr strcasecmp \\\n+strdup strtoul tsearch __argz_count __argz_stringify __argz_next])\n \n+   AM_ICONV\n+   AM_LANGINFO_CODESET\n    AM_LC_MESSAGES\n-   AM_WITH_NLS\n+   AM_WITH_NLS([$1],[$2],[$3])\n \n    if test \"x$CATOBJEXT\" != \"x\"; then\n      if test \"x$ALL_LINGUAS\" = \"x\"; then\n        LINGUAS=\n      else\n        AC_MSG_CHECKING(for catalogs to be installed)\n        NEW_LINGUAS=\n-       for lang in ${LINGUAS=$ALL_LINGUAS}; do\n-         case \"$ALL_LINGUAS\" in\n-          *$lang*) NEW_LINGUAS=\"$NEW_LINGUAS $lang\" ;;\n-         esac\n+       for presentlang in $ALL_LINGUAS; do\n+         useit=no\n+         for desiredlang in ${LINGUAS-$ALL_LINGUAS}; do\n+           # Use the presentlang catalog if desiredlang is\n+           #   a. equal to presentlang, or\n+           #   b. a variant of presentlang (because in this case,\n+           #      presentlang can be used as a fallback for messages\n+           #      which are not translated in the desiredlang catalog).\n+           case \"$desiredlang\" in\n+             \"$presentlang\"*) useit=yes;;\n+           esac\n+         done\n+         if test $useit = yes; then\n+           NEW_LINGUAS=\"$NEW_LINGUAS $presentlang\"\n+         fi\n        done\n        LINGUAS=$NEW_LINGUAS\n        AC_MSG_RESULT($LINGUAS)\n@@ -2297,47 +2400,8 @@ strdup __argz_count __argz_stringify __argz_next])\n      fi\n    fi\n \n-   dnl The reference to <locale.h> in the installed <libintl.h> file\n-   dnl must be resolved because we cannot expect the users of this\n-   dnl to define HAVE_LOCALE_H.\n-   if test $ac_cv_header_locale_h = yes; then\n-     INCLUDE_LOCALE_H=\"#include <locale.h>\"\n-   else\n-     INCLUDE_LOCALE_H=\"\\\n-/* The system does not provide the header <locale.h>.  Take care yourself.  */\"\n-   fi\n-   AC_SUBST(INCLUDE_LOCALE_H)\n-\n-   dnl Determine which catalog format we have (if any is needed)\n-   dnl For now we know about two different formats:\n-   dnl   Linux libc-5 and the normal X/Open format\n-   test -d intl || mkdir intl\n-   if test \"$CATOBJEXT\" = \".cat\"; then\n-     AC_CHECK_HEADER(linux/version.h, msgformat=linux, msgformat=xopen)\n-\n-     dnl Transform the SED scripts while copying because some dumb SEDs\n-     dnl cannot handle comments.\n-     sed -e '/^#/d' $srcdir/intl/$msgformat-msg.sed > intl/po2msg.sed\n-   fi\n-   dnl po2tbl.sed is always needed.\n-   sed -e '/^#.*[^\\\\]$/d' -e '/^#$/d' \\\n-     $srcdir/intl/po2tbl.sed.in > intl/po2tbl.sed\n-\n-   dnl In the intl/Makefile.in we have a special dependency which makes\n-   dnl only sense for gettext.  We comment this out for non-gettext\n-   dnl packages.\n-   if test \"$PACKAGE\" = \"gettext\"; then\n-     GT_NO=\"#NO#\"\n-     GT_YES=\n-   else\n-     GT_NO=\n-     GT_YES=\"#YES#\"\n-   fi\n-   AC_SUBST(GT_NO)\n-   AC_SUBST(GT_YES)\n-\n    dnl If the AC_CONFIG_AUX_DIR macro for autoconf is used we possibly\n-   dnl find the mkinstalldirs script in another subdir but ($top_srcdir).\n+   dnl find the mkinstalldirs script in another subdir but $(top_srcdir).\n    dnl Try to locate is.\n    MKINSTALLDIRS=\n    if test -n \"$ac_aux_dir\"; then\n@@ -2348,25 +2412,9 @@ strdup __argz_count __argz_stringify __argz_next])\n    fi\n    AC_SUBST(MKINSTALLDIRS)\n \n-   dnl *** For now the libtool support in intl/Makefile is not for real.\n-   l=\n-   AC_SUBST(l)\n-\n-   dnl Generate list of files to be processed by xgettext which will\n-   dnl be included in po/Makefile.\n-   test -d po || mkdir po\n-   if test \"x$srcdir\" != \"x.\"; then\n-     if test \"x`echo $srcdir | sed 's@/.*@@'`\" = \"x\"; then\n-       posrcprefix=\"$srcdir/\"\n-     else\n-       posrcprefix=\"../$srcdir/\"\n-     fi\n-   else\n-     posrcprefix=\"../\"\n-   fi\n-   rm -f po/POTFILES\n-   sed -e \"/^#/d\" -e \"/^\\$/d\" -e \"s,.*,\t$posrcprefix& \\\\\\\\,\" -e \"\\$s/\\(.*\\) \\\\\\\\/\\1/\" \\\n-\t< $srcdir/po/POTFILES.in > po/POTFILES\n+   dnl Enable libtool support if the surrounding package wishes it.\n+   INTL_LIBTOOL_SUFFIX_PREFIX=ifelse([$1], use-libtool, [l], [])\n+   AC_SUBST(INTL_LIBTOOL_SUFFIX_PREFIX)\n   ])\n \n # Search path for a program which passes the given test.\n@@ -2381,7 +2429,7 @@ strdup __argz_count __argz_stringify __argz_next])\n \n dnl AM_PATH_PROG_WITH_TEST(VARIABLE, PROG-TO-CHECK-FOR,\n dnl   TEST-PERFORMED-ON-FOUND_PROGRAM [, VALUE-IF-NOT-FOUND [, PATH]])\n-AC_DEFUN(AM_PATH_PROG_WITH_TEST,\n+AC_DEFUN([AM_PATH_PROG_WITH_TEST],\n [# Extract the first word of \"$2\", so it can be a program name with args.\n set dummy $2; ac_word=[$]2\n AC_MSG_CHECKING([for $ac_word])\n@@ -2417,6 +2465,121 @@ fi\n AC_SUBST($1)dnl\n ])\n \n+#serial 2\n+\n+# Test for the GNU C Library, version 2.1 or newer.\n+# From Bruno Haible.\n+\n+AC_DEFUN([jm_GLIBC21],\n+  [\n+    AC_CACHE_CHECK(whether we are using the GNU C Library 2.1 or newer,\n+      ac_cv_gnu_library_2_1,\n+      [AC_EGREP_CPP([Lucky GNU user],\n+\t[\n+#include <features.h>\n+#ifdef __GNU_LIBRARY__\n+ #if (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 1) || (__GLIBC__ > 2)\n+  Lucky GNU user\n+ #endif\n+#endif\n+\t],\n+\tac_cv_gnu_library_2_1=yes,\n+\tac_cv_gnu_library_2_1=no)\n+      ]\n+    )\n+    AC_SUBST(GLIBC21)\n+    GLIBC21=\"$ac_cv_gnu_library_2_1\"\n+  ]\n+)\n+\n+#serial AM2\n+\n+dnl From Bruno Haible.\n+\n+AC_DEFUN([AM_ICONV],\n+[\n+  dnl Some systems have iconv in libc, some have it in libiconv (OSF/1 and\n+  dnl those with the standalone portable GNU libiconv installed).\n+\n+  AC_ARG_WITH([libiconv-prefix],\n+[  --with-libiconv-prefix=DIR  search for libiconv in DIR/include and DIR/lib], [\n+    for dir in `echo \"$withval\" | tr : ' '`; do\n+      if test -d $dir/include; then CPPFLAGS=\"$CPPFLAGS -I$dir/include\"; fi\n+      if test -d $dir/lib; then LDFLAGS=\"$LDFLAGS -L$dir/lib\"; fi\n+    done\n+   ])\n+\n+  AC_CACHE_CHECK(for iconv, am_cv_func_iconv, [\n+    am_cv_func_iconv=\"no, consider installing GNU libiconv\"\n+    am_cv_lib_iconv=no\n+    AC_TRY_LINK([#include <stdlib.h>\n+#include <iconv.h>],\n+      [iconv_t cd = iconv_open(\"\",\"\");\n+       iconv(cd,NULL,NULL,NULL,NULL);\n+       iconv_close(cd);],\n+      am_cv_func_iconv=yes)\n+    if test \"$am_cv_func_iconv\" != yes; then\n+      am_save_LIBS=\"$LIBS\"\n+      LIBS=\"$LIBS -liconv\"\n+      AC_TRY_LINK([#include <stdlib.h>\n+#include <iconv.h>],\n+        [iconv_t cd = iconv_open(\"\",\"\");\n+         iconv(cd,NULL,NULL,NULL,NULL);\n+         iconv_close(cd);],\n+        am_cv_lib_iconv=yes\n+        am_cv_func_iconv=yes)\n+      LIBS=\"$am_save_LIBS\"\n+    fi\n+  ])\n+  if test \"$am_cv_func_iconv\" = yes; then\n+    AC_DEFINE(HAVE_ICONV, 1, [Define if you have the iconv() function.])\n+    AC_MSG_CHECKING([for iconv declaration])\n+    AC_CACHE_VAL(am_cv_proto_iconv, [\n+      AC_TRY_COMPILE([\n+#include <stdlib.h>\n+#include <iconv.h>\n+extern\n+#ifdef __cplusplus\n+\"C\"\n+#endif\n+#if defined(__STDC__) || defined(__cplusplus)\n+size_t iconv (iconv_t cd, char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);\n+#else\n+size_t iconv();\n+#endif\n+], [], am_cv_proto_iconv_arg1=\"\", am_cv_proto_iconv_arg1=\"const\")\n+      am_cv_proto_iconv=\"extern size_t iconv (iconv_t cd, $am_cv_proto_iconv_arg1 char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);\"])\n+    am_cv_proto_iconv=`echo \"[$]am_cv_proto_iconv\" | tr -s ' ' | sed -e 's/( /(/'`\n+    AC_MSG_RESULT([$]{ac_t:-\n+         }[$]am_cv_proto_iconv)\n+    AC_DEFINE_UNQUOTED(ICONV_CONST, $am_cv_proto_iconv_arg1,\n+      [Define as const if the declaration of iconv() needs const.])\n+  fi\n+  LIBICONV=\n+  if test \"$am_cv_lib_iconv\" = yes; then\n+    LIBICONV=\"-liconv\"\n+  fi\n+  AC_SUBST(LIBICONV)\n+])\n+\n+#serial AM1\n+\n+dnl From Bruno Haible.\n+\n+AC_DEFUN([AM_LANGINFO_CODESET],\n+[\n+  AC_CACHE_CHECK([for nl_langinfo and CODESET], am_cv_langinfo_codeset,\n+    [AC_TRY_LINK([#include <langinfo.h>],\n+      [char* cs = nl_langinfo(CODESET);],\n+      am_cv_langinfo_codeset=yes,\n+      am_cv_langinfo_codeset=no)\n+    ])\n+  if test $am_cv_langinfo_codeset = yes; then\n+    AC_DEFINE(HAVE_LANGINFO_CODESET, 1,\n+      [Define if you have <langinfo.h> and nl_langinfo(CODESET).])\n+  fi\n+])\n+\n # Check whether LC_MESSAGES is available in <locale.h>.\n # Ulrich Drepper <drepper@cygnus.com>, 1995.\n #\n@@ -2425,15 +2588,16 @@ AC_SUBST($1)dnl\n # but which still want to provide support for the GNU gettext functionality.\n # Please note that the actual code is *not* freely available.\n \n-# serial 1\n+# serial 2\n \n-AC_DEFUN(AM_LC_MESSAGES,\n+AC_DEFUN([AM_LC_MESSAGES],\n   [if test $ac_cv_header_locale_h = yes; then\n     AC_CACHE_CHECK([for LC_MESSAGES], am_cv_val_LC_MESSAGES,\n       [AC_TRY_LINK([#include <locale.h>], [return LC_MESSAGES],\n        am_cv_val_LC_MESSAGES=yes, am_cv_val_LC_MESSAGES=no)])\n     if test $am_cv_val_LC_MESSAGES = yes; then\n-      AC_DEFINE(HAVE_LC_MESSAGES)\n+      AC_DEFINE(HAVE_LC_MESSAGES, 1,\n+        [Define if your <locale.h> file defines LC_MESSAGES.])\n     fi\n   fi])\n "}, {"sha": "4908342858c4f8523274e0b504521a5416725b77", "filename": "libstdc++-v3/config.h.in", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig.h.in?ref=005326029f35b4271c5274114a17126039fe18a0", "patch": "@@ -3,9 +3,6 @@\n /* Define if you have a working `mmap' system call.  */\n #undef HAVE_MMAP\n \n-/* Define if you need to in order for stat and other things to work.  */\n-#undef _POSIX_SOURCE\n-\n // Define if GCC supports weak symbols.\n #undef _GLIBCPP_SUPPORTS_WEAK\n \n@@ -702,6 +699,9 @@\n /* Define if you have the <nan.h> header file.  */\n #undef HAVE_NAN_H\n \n+/* Define if you have the <stdlib.h> header file.  */\n+#undef HAVE_STDLIB_H\n+\n /* Define if you have the <sys/isa_defs.h> header file.  */\n #undef HAVE_SYS_ISA_DEFS_H\n \n@@ -711,6 +711,9 @@\n /* Define if you have the <sys/resource.h> header file.  */\n #undef HAVE_SYS_RESOURCE_H\n \n+/* Define if you have the <sys/stat.h> header file.  */\n+#undef HAVE_SYS_STAT_H\n+\n /* Define if you have the <sys/types.h> header file.  */\n #undef HAVE_SYS_TYPES_H\n "}, {"sha": "57d83c49d009d1276f42164723f2c45deb58862c", "filename": "libstdc++-v3/config/io/basic_file_libio.h", "status": "modified", "additions": 214, "deletions": 1, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fbasic_file_libio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fbasic_file_libio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fbasic_file_libio.h?ref=005326029f35b4271c5274114a17126039fe18a0", "patch": "@@ -1,6 +1,6 @@\n // Wrapper of C-language FILE struct -*- C++ -*-\n \n-// Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,10 +31,221 @@\n // ISO C++ 14882: 27.8  File-based streams\n //\n \n+/** @file basic_file.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#ifndef _CPP_BASIC_FILE\n+#define _CPP_BASIC_FILE 1\n+\n+#pragma GCC system_header\n+\n+#include <bits/c++config.h>\n+#include <ios>\n #include <libioP.h>\n \n namespace std \n {\n+  // Ulrich is going to make some detailed comment here, explaining\n+  // all this unpleasantness, providing detailed performance analysis\n+  // as to why we have to do all this lame vtable hacking instead of a\n+  // sane, function-based approach. This verbiage will provide a clear\n+  // and detailed description of the whole object-layout,\n+  // vtable-swapping, sordid history of this hack.\n+  template<typename _CharT>\n+    struct __basic_file_base: public __c_file_type\n+    {\n+      virtual \n+      ~__basic_file_base() { };\n+\n+      virtual int \n+      overflow(int __c = EOF) = 0;\n+\n+      virtual int \n+      underflow() = 0;\n+\n+      virtual int \n+      uflow() = 0;\n+\n+      virtual int \n+      pbackfail(int __c) = 0;\n+\n+      virtual streamsize \n+      xsputn(const _CharT* __s, streamsize __n) = 0;\n+\n+      virtual streamsize \n+      xsgetn(_CharT* __s, streamsize __n) = 0;\n+\n+      virtual streamoff\n+      seekoff(streamoff __off, ios_base::seekdir __way,\n+\t      ios_base::openmode __mode = ios_base::in | ios_base::out) = 0;\n+\n+      virtual streamoff\n+      seekpos(streamoff __pos, \n+\t      ios_base::openmode __mode = ios_base::in | ios_base::out) = 0;\n+\n+      virtual streambuf* \n+      setbuf(_CharT* __b, int __len) = 0;\n+\n+      virtual int \n+      sync() = 0;\n+\n+      virtual int \n+      doallocate() = 0;\n+\n+      virtual streamsize \n+      sys_read(_CharT* __s, streamsize __n) = 0;\n+\n+      virtual streamsize \n+      sys_write(const _CharT* __s, streamsize __n) = 0;\n+\n+      virtual streamoff\n+      sys_seek(streamoff __off, ios_base::seekdir __way) = 0;\n+\n+      virtual int \n+      sys_close() = 0;\n+\n+      virtual int \n+      sys_stat(void* __v) = 0;\n+\n+      virtual int \n+      showmanyc() = 0;\n+\n+      virtual void \n+      imbue(void* __v) = 0;\n+    };\n+\n+  // Some of these member functions are based on libio/filebuf.cc.\n+  // Also note that the order and number of virtual functions has to precisely\n+  // match the order and number in the _IO_jump_t struct defined in libioP.h.\n+  template<typename _CharT>\n+    class __basic_file: public __basic_file_base<_CharT>\n+    {\n+# ifdef _GLIBCPP_USE_WCHAR_T\n+      __c_wfile_type\t_M_wfile;\n+# endif\n+\n+    public:\n+      __basic_file(__c_lock* __lock = 0);\n+      \n+      void \n+      _M_open_mode(ios_base::openmode __mode, int& __p_mode, int& __rw_mode, \n+\t\t   char* __c_mode);\n+      \n+      // Equivalent to the normal fopen function.\n+      __basic_file* \n+      open(const char* __name, ios_base::openmode __mode, int __prot = 0664);\n+\n+      // Used for opening the standard streams, cin, cout, cerr, clog,\n+      // and their wide-stream equivalents. Instead of calling open, it\n+      // just sets\n+      //  - for libio:  __c_file_type->_fileno and the respective _flags bits\n+      //  - for stdio:  _M_cfile = __file and some internal flags\n+      // and returns.\n+      __basic_file*\n+      sys_open(__c_file_type* __file, ios_base::openmode __mode);\n+\n+      _CharT\n+      sys_getc();\n+\n+      _CharT\n+      sys_ungetc(_CharT);\n+\n+      __basic_file* \n+      close(); \n+\n+      bool \n+      is_open();\n+\n+      int \n+      fd();\n+\n+      // NB: Must match FILE specific jump table starting here--this\n+      // means all virtual functions starting with the dtor must match,\n+      // slot by slot. For glibc-based dystems, this means the _IO_FILE\n+      // as the FILE struct and _IO_jump_t as the jump table.\n+      virtual \n+      ~__basic_file(); // Takes the place of __finish.\n+\n+      virtual int \n+      overflow(int __c = EOF);\n+\n+      virtual int \n+      underflow();\n+\n+      virtual int \n+      uflow();\n+\n+      virtual int \n+      pbackfail(int __c);\n+\n+      // A complex \"write\" function that sets all of __c_file_type's\n+      // pointers and associated data members correctly and manages its\n+      // relation to the external byte sequence.\n+      virtual streamsize \n+      xsputn(const _CharT* __s, streamsize __n);\n+\n+      // A complex \"read\" function that sets all of __c_file_type's\n+      // pointers and associated data members correctly and manages its\n+      // relation to the external byte sequence.\n+      virtual streamsize \n+      xsgetn(_CharT* __s, streamsize __n);\n+\n+      // A complex \"seekoff\" function that sets all of __c_file_type's\n+      // pointers and associated data members correctly and manages its\n+      // relation to the external byte sequence.\n+      virtual streamoff\n+      seekoff(streamoff __off, ios_base::seekdir __way,\n+\t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n+\n+      // A complex \"seekpos\" function that sets all of __c_file_type's\n+      // pointers and associated data members correctly and manages its\n+      // relation to the external byte sequence.\n+      virtual streamoff\n+      seekpos(streamoff __pos, \n+\t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n+\n+      virtual streambuf* \n+      setbuf(_CharT* __b, int __len);\n+\n+      virtual int \n+      sync();\n+\n+      virtual int \n+      doallocate();\n+\n+      // A simple read function for the external byte sequence, that\n+      // does no mucking around with or setting of the pointers or flags\n+      // in __c_file_type.\n+      virtual streamsize \n+      sys_read(_CharT* __s, streamsize __n);\n+\n+      // A simple write function for the external byte sequence, that\n+      // does no mucking around with or setting of the pointers or flags\n+      // in __c_file_type.\n+      virtual streamsize \n+      sys_write(const _CharT* __s, streamsize __n);\n+\n+      // A simple seek function for the external byte sequence, that\n+      // does no mucking around with or setting of the pointers or flags\n+      // in __c_file_type.\n+      virtual streamoff\n+      sys_seek(streamoff __off, ios_base::seekdir __way);\n+\n+      virtual int \n+      sys_close();\n+\n+      virtual int \n+      sys_stat(void* __v);\n+\n+      virtual int \n+      showmanyc();\n+\n+      virtual void \n+      imbue(void* __v);\n+    };\n+\n   // __basic_file<char> specializations\n   template<>\n     __basic_file<char>::__basic_file(__c_lock* __lock);\n@@ -283,3 +494,5 @@ namespace std\n     void \n     __basic_file<_CharT>::imbue(void* /*__v*/) { }\n }  // namespace std\n+\n+#endif\t// _CPP_BASIC_FILE"}, {"sha": "50da49e1cbaada8daf0f6d42333e983ac5f594d1", "filename": "libstdc++-v3/config/io/basic_file_stdio.cc", "status": "modified", "additions": 121, "deletions": 5, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fbasic_file_stdio.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fbasic_file_stdio.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fbasic_file_stdio.cc?ref=005326029f35b4271c5274114a17126039fe18a0", "patch": "@@ -1,6 +1,6 @@\n // Wrapper of C-language FILE struct -*- C++ -*-\n \n-// Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -35,8 +35,124 @@\n \n namespace std \n {\n-  template class __basic_file<char>;\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-  template class __basic_file<wchar_t>;\n-#endif\n+  // Definitions for __basic_file<char>.\n+  __basic_file<char>::__basic_file(__c_lock* /*__lock*/) \n+  : _M_cfile(NULL), _M_cfile_created(false) { }\n+\n+  __basic_file<char>::~__basic_file()\n+  {\n+    if (this->is_open())\n+      {\n+\tfflush(_M_cfile);\n+\tthis->close();\n+      }\n+  }\n+      \n+  void \n+  __basic_file<char>::_M_open_mode(ios_base::openmode __mode, int&, int&, \n+\t\t\t\t   char* __c_mode)\n+  {  \n+    bool __testb = __mode & ios_base::binary;\n+    bool __testi = __mode & ios_base::in;\n+    bool __testo = __mode & ios_base::out;\n+    bool __testt = __mode & ios_base::trunc;\n+    bool __testa = __mode & ios_base::app;\n+      \n+    if (!__testi && __testo && !__testt && !__testa)\n+      strcpy(__c_mode, \"w\");\n+    if (!__testi && __testo && !__testt && __testa)\n+      strcpy(__c_mode, \"a\");\n+    if (!__testi && __testo && __testt && !__testa)\n+      strcpy(__c_mode, \"w\");\n+    if (__testi && !__testo && !__testt && !__testa)\n+      strcpy(__c_mode, \"r\");\n+    if (__testi && __testo && !__testt && !__testa)\n+      strcpy(__c_mode, \"r+\");\n+    if (__testi && __testo && __testt && !__testa)\n+      strcpy(__c_mode, \"w+\");\n+    if (__testb)\n+      strcat(__c_mode, \"b\");\n+  }\n+  \n+  __basic_file<char>*\n+  __basic_file<char>::sys_open(__c_file_type* __file, ios_base::openmode) \n+  {\n+    __basic_file* __ret = NULL;\n+    if (!this->is_open() && __file)\n+      {\n+\t_M_cfile = __file;\n+\t_M_cfile_created = false;\n+\t__ret = this;\n+      }\n+    return __ret;\n+  }\n+\n+  char\n+  __basic_file<char>::sys_getc() { return getc (_M_cfile); }\n+  \n+  char\n+  __basic_file<char>::sys_ungetc(char __s) { return ungetc (__s, _M_cfile); }\n+  \n+  __basic_file<char>* \n+  __basic_file<char>::open(const char* __name, ios_base::openmode __mode, \n+\t\t\t   int /*__prot*/)\n+  {\n+    __basic_file* __ret = NULL;\n+    int __p_mode = 0;\n+    int __rw_mode = 0;\n+    char __c_mode[4];\n+      \n+    _M_open_mode(__mode, __p_mode, __rw_mode, __c_mode);\n+\n+    if (!this->is_open())\n+      {\n+\tif ((_M_cfile = fopen(__name, __c_mode)))\n+\t  {\n+\t    _M_cfile_created = true;\n+\t    __ret = this;\n+\t  }\n+      }\n+    return __ret;\n+  }\n+  \n+  bool \n+  __basic_file<char>::is_open() { return _M_cfile != 0; }\n+  \n+  int \n+  __basic_file<char>::fd() { return fileno(_M_cfile) ; }\n+  \n+  __basic_file<char>* \n+  __basic_file<char>::close()\n+  { \n+    __basic_file* __retval = static_cast<__basic_file*>(NULL);\n+    if (_M_cfile_created && fclose(_M_cfile))\n+      __retval = this;\n+    return __retval;\n+  }\n+ \n+  streamsize \n+  __basic_file<char>::xsgetn(char* __s, streamsize __n)\n+  { return fread(__s, 1, __n, _M_cfile); }\n+  \n+  streamsize \n+  __basic_file<char>::xsputn(const char* __s, streamsize __n)\n+  { return fwrite(__s, 1, __n, _M_cfile); }\n+  \n+  streamoff\n+  __basic_file<char>::seekoff(streamoff __off, ios_base::seekdir __way, \n+\t\t\t      ios_base::openmode /*__mode*/)\n+  { \n+    fseek(_M_cfile, __off, __way); \n+    return ftell(_M_cfile); \n+  }\n+\n+  streamoff\n+  __basic_file<char>::seekpos(streamoff __pos, ios_base::openmode /*__mode*/)\n+  { \n+    fseek(_M_cfile, __pos, ios_base::beg); \n+    return ftell(_M_cfile); \n+  }\n+  \n+  int \n+  __basic_file<char>::sync() { return fflush(_M_cfile); }\n }  // namespace std"}, {"sha": "cfc0b4622ad60b05b3534973872103f16f732ee8", "filename": "libstdc++-v3/config/io/basic_file_stdio.h", "status": "modified", "additions": 58, "deletions": 203, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fbasic_file_stdio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fbasic_file_stdio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fbasic_file_stdio.h?ref=005326029f35b4271c5274114a17126039fe18a0", "patch": "@@ -1,6 +1,6 @@\n // Wrapper of C-language FILE struct -*- C++ -*-\n \n-// Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,226 +31,81 @@\n // ISO C++ 14882: 27.8  File-based streams\n //\n \n-namespace std \n-{\n-  // Generic definitions for __basic_file\n-  template<typename _CharT>\n-    __basic_file<_CharT>::__basic_file(__c_lock* /*__lock*/) \n-    : _M_cfile(NULL), _M_cfile_created(false) { }\n+/** @file basic_file.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n \n-  template<typename _CharT>\n-    __basic_file<_CharT>::~__basic_file()\n-    {\n-      if (this->is_open())\n-\t{\n-\t  fflush(_M_cfile);\n-\t  this->close();\n-\t}\n-    }\n-      \n-  template<typename _CharT>\n-    void \n-    __basic_file<_CharT>::_M_open_mode(ios_base::openmode __mode, \n-\t\t\t\t       int& /*__p_mode*/, int& /*__rw_mode*/, \n-\t\t\t\t       char* __c_mode)\n-    {  \n-      bool __testb = __mode & ios_base::binary;\n-      bool __testi = __mode & ios_base::in;\n-      bool __testo = __mode & ios_base::out;\n-      bool __testt = __mode & ios_base::trunc;\n-      bool __testa = __mode & ios_base::app;\n-      \n-      if (!__testi && __testo && !__testt && !__testa)\n-\tstrcpy(__c_mode, \"w\");\n-      if (!__testi && __testo && !__testt && __testa)\n-\tstrcpy(__c_mode, \"a\");\n-      if (!__testi && __testo && __testt && !__testa)\n-\tstrcpy(__c_mode, \"w\");\n-      if (__testi && !__testo && !__testt && !__testa)\n-\tstrcpy(__c_mode, \"r\");\n-      if (__testi && __testo && !__testt && !__testa)\n-\tstrcpy(__c_mode, \"r+\");\n-      if (__testi && __testo && __testt && !__testa)\n-\tstrcpy(__c_mode, \"w+\");\n-      if (__testb)\n-\tstrcat(__c_mode, \"b\");\n-    }\n-  \n-  template<typename _CharT>\n-    __basic_file<_CharT>*\n-    __basic_file<_CharT>::sys_open(__c_file_type* __file, ios_base::openmode) \n-    {\n-      __basic_file* __ret = NULL;\n+#ifndef _CPP_BASIC_FILE\n+#define _CPP_BASIC_FILE 1\n \n-      if (!this->is_open() && __file)\n-\t{\n-\t  _M_cfile = __file;\n-\t  _M_cfile_created = false;\n-\t  __ret = this;\n-\t}\n+#pragma GCC system_header\n \n-      return __ret;\n-    }\n+#include <bits/c++config.h>\n+#include <ios>\n \n+namespace std \n+{\n+  // Generic declaration.\n   template<typename _CharT>\n-    _CharT\n-    __basic_file<_CharT>::sys_getc()\n-    {\n-      return getc (_M_cfile);\n-    }\n+    class __basic_file; \n \n-  template<typename _CharT>\n-    _CharT\n-    __basic_file<_CharT>::sys_ungetc(_CharT __s)\n+  // Specialization.\n+  template<>\n+    class __basic_file<char>\n     {\n-      return ungetc (__s, _M_cfile);\n-    }\n-  \n-  template<typename _CharT>\n-    __basic_file<_CharT>* \n-    __basic_file<_CharT>::open(const char* __name, ios_base::openmode __mode, \n-\t\t\t       int /*__prot*/)\n-    {\n-      __basic_file* __ret = NULL;\n-      int __p_mode = 0;\n-      int __rw_mode = 0;\n-      char __c_mode[4];\n-      \n-      _M_open_mode(__mode, __p_mode, __rw_mode, __c_mode);\n-\n-      if (!this->is_open())\n-\t{\n-\t  if ((_M_cfile = fopen(__name, __c_mode)))\n-\t    {\n-\t      _M_cfile_created = true;\n-\t      __ret = this;\n-\t    }\n-\t}\n-      return __ret;\n-    }\n-  \n-  template<typename _CharT>\n-    bool \n-    __basic_file<_CharT>::is_open() { return _M_cfile != 0; }\n-  \n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::fd() { return fileno(_M_cfile) ; }\n-  \n-  template<typename _CharT>\n-    __basic_file<_CharT>* \n-    __basic_file<_CharT>::close()\n-    { \n-      __basic_file* __retval = static_cast<__basic_file*>(NULL);\n-      if (_M_cfile_created && fclose(_M_cfile))\n-\t__retval = this;\n-      return __retval;\n-    }\n- \n-  template<typename _CharT>\n-    streamsize \n-    __basic_file<_CharT>::xsgetn(_CharT* __s, streamsize __n)\n-    { return fread(__s, 1, __n, _M_cfile); }\n+      // Underlying data source/sink.\n+      __c_file_type* \t_M_cfile;\n+      // True iff we opened _M_cfile, and thus must close it ourselves.\n+      bool \t\t_M_cfile_created;\n \n-  template<typename _CharT>\n-    streamsize \n-    __basic_file<_CharT>::xsputn(const _CharT* __s, streamsize __n)\n-    { return fwrite(__s, 1, __n, _M_cfile); }\n- \n-  template<typename _CharT>\n-    streamoff\n-    __basic_file<_CharT>::seekoff(streamoff __off, ios_base::seekdir __way, \n-\t\t\t\t  ios_base::openmode /*__mode*/)\n-    { fseek(_M_cfile, __off, __way); return ftell(_M_cfile); }\n+    public:\n+      __basic_file(__c_lock* __lock = 0);\n+      \n+      void \n+      _M_open_mode(ios_base::openmode __mode, int& __p_mode, int& __rw_mode, \n+\t\t   char* __c_mode);\n+      \n+      __basic_file* \n+      open(const char* __name, ios_base::openmode __mode, int __prot = 0664);\n \n-  template<typename _CharT>\n-    streamoff\n-    __basic_file<_CharT>::seekpos(streamoff __pos, \n-\t\t\t\t  ios_base::openmode /*__mode*/)\n-    { fseek(_M_cfile, __pos, ios_base::beg); return ftell(_M_cfile); }\n+      __basic_file*\n+      sys_open(__c_file_type* __file, ios_base::openmode __mode);\n \n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::sync()\n-    { return fflush(_M_cfile); }\n+      char\n+      sys_getc();\n \n-  // NB: Unused.\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::overflow(int /*__c*/) \n-    { return EOF; }\n+      char\n+      sys_ungetc(char);\n \n-  // NB: Unused.\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::underflow()  \n-    { return EOF; } \n+      __basic_file* \n+      close(); \n \n-  // NB: Unused.\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::uflow()  \n-    { return EOF; }\n+      bool \n+      is_open();\n \n-  // NB: Unused.\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::pbackfail(int /*__c*/) \n-    { return EOF; } \n- \n- // NB: Unused.\n-  template<typename _CharT>\n-    streambuf* \n-    __basic_file<_CharT>::setbuf(_CharT* /*__b*/, int /*__len*/)\n-    { return reinterpret_cast<streambuf*>(this); }\n+      int \n+      fd();\n \n-  // NB: Unused.\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::doallocate() \n-    { return EOF; }\n+      ~__basic_file();\n \n-  // NB: Unused.\n-  template<typename _CharT>\n-    streamsize \n-    __basic_file<_CharT>::sys_read(_CharT* __s, streamsize __n) \n-    { return fread(__s, 1, __n, _M_cfile); }\n+      streamsize \n+      xsputn(const char* __s, streamsize __n);\n \n-  // NB: Unused.    \n-  template<typename _CharT>\n-    streamsize \n-    __basic_file<_CharT>::sys_write(const _CharT* __s, streamsize __n) \n-    { return fwrite(__s, 1, __n, _M_cfile); }\n-\n-  // NB: Unused.\n-  template<typename _CharT>\n-    streamoff\n-    __basic_file<_CharT>::sys_seek(streamoff __pos, ios_base::seekdir __way)\n-    { \n-      fseek(_M_cfile, __pos, __way); \n-      return ftell(_M_cfile); \n-    }\n-  \n-  // NB: Unused.\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::sys_close() \n-    { return fclose(_M_cfile); }\n+      streamsize \n+      xsgetn(char* __s, streamsize __n);\n \n-  // NB: Unused.\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::sys_stat(void* /*__v*/) \n-    { return EOF; }\n+      streamoff\n+      seekoff(streamoff __off, ios_base::seekdir __way,\n+\t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n \n-  // NB: Unused.\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::showmanyc() \n-    { return EOF; }\n+      streamoff\n+      seekpos(streamoff __pos, \n+\t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n \n-  // NB: Unused.\n-  template<typename _CharT>\n-    void \n-    __basic_file<_CharT>::imbue(void* /*__v*/) { }\n+      int \n+      sync();\n+    };\n }  // namespace std\n+\n+#endif\t// _CPP_BASIC_FILE"}, {"sha": "acf65207f18b5b25203d0ba4fef9ef44ccc314a0", "filename": "libstdc++-v3/config/io/c_io_libio.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fc_io_libio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fc_io_libio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fc_io_libio.h?ref=005326029f35b4271c5274114a17126039fe18a0", "patch": "@@ -1,6 +1,6 @@\n // underlying io library  -*- C++ -*-\n \n-// Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -55,7 +55,6 @@ namespace std\n #endif\n \n // from basic_file.h\n-#define _GLIBCPP_BASIC_FILE_INHERITANCE 1\n   typedef _IO_FILE \t__c_file_type;\n   typedef _IO_wide_data __c_wfile_type;\n "}, {"sha": "de61da4de7e8a5749d8fb8552a4ad761e7ed652c", "filename": "libstdc++-v3/config/io/c_io_stdio.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fc_io_stdio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fc_io_stdio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fc_io_stdio.h?ref=005326029f35b4271c5274114a17126039fe18a0", "patch": "@@ -1,6 +1,6 @@\n // underlying io library  -*- C++ -*-\n \n-// Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -49,7 +49,6 @@ namespace std\n   typedef __gthread_mutex_t __c_lock;\n \n // for basic_file.h\n-#define _GLIBCPP_BASIC_FILE_ENCAPSULATION 1\n   typedef FILE __c_file_type;\n \n // for ios_base.h"}, {"sha": "844ab0ccdad47cc1e8af8df9d9c3be42f1303172", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 1049, "deletions": 1014, "changes": 2063, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=005326029f35b4271c5274114a17126039fe18a0"}, {"sha": "32a0c049f2902ed2ae224c64b16cf0a3f1208e1b", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=005326029f35b4271c5274114a17126039fe18a0", "patch": "@@ -34,7 +34,6 @@ glibcpp_builddir=@glibcpp_builddir@\n bits_srcdir = ${glibcpp_srcdir}/include/bits\n bits_builddir = ./bits\n bits_headers = \\\n-\t${bits_srcdir}/basic_file.h \\\n \t${bits_srcdir}/basic_ios.h \\\n \t${bits_srcdir}/basic_ios.tcc \\\n \t${bits_srcdir}/basic_string.h \\\n@@ -278,7 +277,7 @@ target_headers = \\\n \t${glibcpp_srcdir}/@CPU_LIMITS_INC_SRCDIR@/cpu_limits.h \n # These extra_target_headers files are all built with ad hoc naming rules.\n extra_target_headers = \\\n-\t${target_builddir}/basic_file_model.h \\\n+\t${target_builddir}/basic_file.h \\\n \t${target_builddir}/c++config.h \\\n \t${target_builddir}/c++io.h \\\n \t${target_builddir}/c++locale.h \\\n@@ -360,7 +359,7 @@ stamp-target: ${target_headers} ${target_builddir}\n \t@cd ${target_builddir} ;\\\n \tif [ ! -f stamp-target ]; then \\\n \t  @LN_S@ ${target_headers} . || true ;\\\n-\t  @LN_S@ ${glibcpp_srcdir}/@BASIC_FILE_H@ basic_file_model.h || true ;\\\n+\t  @LN_S@ ${glibcpp_srcdir}/@BASIC_FILE_H@ basic_file.h || true ;\\\n \t  @LN_S@ ${glibcpp_srcdir}/@CSTDIO_H@ c++io.h || true ;\\\n \t  @LN_S@ ${glibcpp_srcdir}/@CLOCALE_H@ c++locale.h || true ;\\\n \t  @LN_S@ ${glibcpp_srcdir}/@CMESSAGES_H@ messages_members.h || true ;\\"}, {"sha": "858a7d9c2992d02803edf6a355b14ea726ccf330", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=005326029f35b4271c5274114a17126039fe18a0", "patch": "@@ -159,7 +159,6 @@ glibcpp_builddir = @glibcpp_builddir@\n bits_srcdir = ${glibcpp_srcdir}/include/bits\n bits_builddir = ./bits\n bits_headers = \\\n-\t${bits_srcdir}/basic_file.h \\\n \t${bits_srcdir}/basic_ios.h \\\n \t${bits_srcdir}/basic_ios.tcc \\\n \t${bits_srcdir}/basic_string.h \\\n@@ -412,7 +411,7 @@ target_headers = \\\n \n # These extra_target_headers files are all built with ad hoc naming rules.\n extra_target_headers = \\\n-\t${target_builddir}/basic_file_model.h \\\n+\t${target_builddir}/basic_file.h \\\n \t${target_builddir}/c++config.h \\\n \t${target_builddir}/c++io.h \\\n \t${target_builddir}/c++locale.h \\\n@@ -611,7 +610,7 @@ stamp-target: ${target_headers} ${target_builddir}\n \t@cd ${target_builddir} ;\\\n \tif [ ! -f stamp-target ]; then \\\n \t  @LN_S@ ${target_headers} . || true ;\\\n-\t  @LN_S@ ${glibcpp_srcdir}/@BASIC_FILE_H@ basic_file_model.h || true ;\\\n+\t  @LN_S@ ${glibcpp_srcdir}/@BASIC_FILE_H@ basic_file.h || true ;\\\n \t  @LN_S@ ${glibcpp_srcdir}/@CSTDIO_H@ c++io.h || true ;\\\n \t  @LN_S@ ${glibcpp_srcdir}/@CLOCALE_H@ c++locale.h || true ;\\\n \t  @LN_S@ ${glibcpp_srcdir}/@CMESSAGES_H@ messages_members.h || true ;\\"}, {"sha": "51dde5bc4c3c8414d315668c3de3be957ae2ffaf", "filename": "libstdc++-v3/include/bits/basic_file.h", "status": "removed", "additions": 0, "deletions": 264, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1febeb40bfbd7970e5b7b74ddd9d06b2dff4de12/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_file.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1febeb40bfbd7970e5b7b74ddd9d06b2dff4de12/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_file.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_file.h?ref=1febeb40bfbd7970e5b7b74ddd9d06b2dff4de12", "patch": "@@ -1,264 +0,0 @@\n-// Wrapper of C-language FILE struct -*- C++ -*-\n-\n-// Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-//\n-// ISO C++ 14882: 27.8  File-based streams\n-//\n-\n-/** @file basic_file.h\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-#ifndef _CPP_BASIC_FILE\n-#define _CPP_BASIC_FILE\t\t1\n-\n-#pragma GCC system_header\n-\n-#include <bits/c++config.h>\n-#include <ios>\n-\n-namespace std \n-{\n-  // Ulrich is going to make some detailed comment here, explaining\n-  // all this unpleasantness, providing detailed performance analysis\n-  // as to why we have to do all this lame vtable hacking instead of a\n-  // sane, function-based approach. This verbiage will provide a clear\n-  // and detailed description of the whole object-layout,\n-  // vtable-swapping, sordid history of this hack.\n-  template<typename _CharT>\n-    struct __basic_file_base: public __c_file_type\n-    {\n-      virtual \n-      ~__basic_file_base() { };\n-\n-      virtual int \n-      overflow(int __c = EOF) = 0;\n-\n-      virtual int \n-      underflow() = 0;\n-\n-      virtual int \n-      uflow() = 0;\n-\n-      virtual int \n-      pbackfail(int __c) = 0;\n-\n-      virtual streamsize \n-      xsputn(const _CharT* __s, streamsize __n) = 0;\n-\n-      virtual streamsize \n-      xsgetn(_CharT* __s, streamsize __n) = 0;\n-\n-      virtual streamoff\n-      seekoff(streamoff __off, ios_base::seekdir __way,\n-\t      ios_base::openmode __mode = ios_base::in | ios_base::out) = 0;\n-\n-      virtual streamoff\n-      seekpos(streamoff __pos, \n-\t      ios_base::openmode __mode = ios_base::in | ios_base::out) = 0;\n-\n-      virtual streambuf* \n-      setbuf(_CharT* __b, int __len) = 0;\n-\n-      virtual int \n-      sync() = 0;\n-\n-      virtual int \n-      doallocate() = 0;\n-\n-      virtual streamsize \n-      sys_read(_CharT* __s, streamsize __n) = 0;\n-\n-      virtual streamsize \n-      sys_write(const _CharT* __s, streamsize __n) = 0;\n-\n-      virtual streamoff\n-      sys_seek(streamoff __off, ios_base::seekdir __way) = 0;\n-\n-      virtual int \n-      sys_close() = 0;\n-\n-      virtual int \n-      sys_stat(void* __v) = 0;\n-\n-      virtual int \n-      showmanyc() = 0;\n-\n-      virtual void \n-      imbue(void* __v) = 0;\n-    };\n-\n-  // Some of these member functions are based on libio/filebuf.cc.\n-  // Also note that the order and number of virtual functions has to precisely\n-  // match the order and number in the _IO_jump_t struct defined in libioP.h.\n-  template<typename _CharT>\n-#ifdef _GLIBCPP_BASIC_FILE_INHERITANCE\n-    class __basic_file: public __basic_file_base<_CharT>\n-#else\n-    class __basic_file\n-#endif\n-    {\n-#if _GLIBCPP_BASIC_FILE_ENCAPSULATION\n-      // underlying data source/sink\n-      __c_file_type* \t_M_cfile;\n-      // true iff we opened _M_cfile, and thus must close it ourselves\n-      bool \t\t_M_cfile_created;\n-#else\n-# ifdef _GLIBCPP_USE_WCHAR_T\n-      __c_wfile_type\t_M_wfile;\n-# endif\n-#endif \n-\n-    public:\n-      __basic_file(__c_lock* __lock = 0);\n-      \n-      void \n-      _M_open_mode(ios_base::openmode __mode, int& __p_mode, int& __rw_mode, \n-\t\t   char* __c_mode);\n-      \n-      // Equivalent to the normal fopen function.\n-      __basic_file* \n-      open(const char* __name, ios_base::openmode __mode, int __prot = 0664);\n-\n-      // Used for opening the standard streams, cin, cout, cerr, clog,\n-      // and their wide-stream equivalents. Instead of calling open, it\n-      // just sets\n-      //  - for libio:  __c_file_type->_fileno and the respective _flags bits\n-      //  - for stdio:  _M_cfile = __file and some internal flags\n-      // and returns.\n-      __basic_file*\n-      sys_open(__c_file_type* __file, ios_base::openmode __mode);\n-\n-      _CharT\n-      sys_getc();\n-\n-      _CharT\n-      sys_ungetc(_CharT);\n-\n-      __basic_file* \n-      close(); \n-\n-      bool \n-      is_open();\n-\n-      int \n-      fd();\n-\n-      // NB: Must match FILE specific jump table starting here--this\n-      // means all virtual functions starting with the dtor must match,\n-      // slot by slot. For glibc-based dystems, this means the _IO_FILE\n-      // as the FILE struct and _IO_jump_t as the jump table.\n-      virtual \n-      ~__basic_file(); // Takes the place of __finish.\n-\n-      virtual int \n-      overflow(int __c = EOF);\n-\n-      virtual int \n-      underflow();\n-\n-      virtual int \n-      uflow();\n-\n-      virtual int \n-      pbackfail(int __c);\n-\n-      // A complex \"write\" function that sets all of __c_file_type's\n-      // pointers and associated data members correctly and manages its\n-      // relation to the external byte sequence.\n-      virtual streamsize \n-      xsputn(const _CharT* __s, streamsize __n);\n-\n-      // A complex \"read\" function that sets all of __c_file_type's\n-      // pointers and associated data members correctly and manages its\n-      // relation to the external byte sequence.\n-      virtual streamsize \n-      xsgetn(_CharT* __s, streamsize __n);\n-\n-      // A complex \"seekoff\" function that sets all of __c_file_type's\n-      // pointers and associated data members correctly and manages its\n-      // relation to the external byte sequence.\n-      virtual streamoff\n-      seekoff(streamoff __off, ios_base::seekdir __way,\n-\t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n-\n-      // A complex \"seekpos\" function that sets all of __c_file_type's\n-      // pointers and associated data members correctly and manages its\n-      // relation to the external byte sequence.\n-      virtual streamoff\n-      seekpos(streamoff __pos, \n-\t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n-\n-      virtual streambuf* \n-      setbuf(_CharT* __b, int __len);\n-\n-      virtual int \n-      sync();\n-\n-      virtual int \n-      doallocate();\n-\n-      // A simple read function for the external byte sequence, that\n-      // does no mucking around with or setting of the pointers or flags\n-      // in __c_file_type.\n-      virtual streamsize \n-      sys_read(_CharT* __s, streamsize __n);\n-\n-      // A simple write function for the external byte sequence, that\n-      // does no mucking around with or setting of the pointers or flags\n-      // in __c_file_type.\n-      virtual streamsize \n-      sys_write(const _CharT* __s, streamsize __n);\n-\n-      // A simple seek function for the external byte sequence, that\n-      // does no mucking around with or setting of the pointers or flags\n-      // in __c_file_type.\n-      virtual streamoff\n-      sys_seek(streamoff __off, ios_base::seekdir __way);\n-\n-      virtual int \n-      sys_close();\n-\n-      virtual int \n-      sys_stat(void* __v);\n-\n-      virtual int \n-      showmanyc();\n-\n-      virtual void \n-      imbue(void* __v);\n-    };\n-} // namespace std\n-\n-// Now include the bits that are dependent on the underlying I/O\n-// model chosen at configure time.\n-#include <bits/basic_file_model.h>\n-\n-#endif\t// _CPP_BASIC_FILE"}, {"sha": "913484cbb7f49bc011bbb89150d635ade5ce3c16", "filename": "libstdc++-v3/include/bits/basic_string.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h?ref=005326029f35b4271c5274114a17126039fe18a0", "patch": "@@ -119,7 +119,6 @@ namespace std\n       //   4. All fields==0 is an empty string, given the extra storage\n       //      beyond-the-end for a null terminator; thus, the shared\n       //      empty string representation needs no constructor.\n-\n       struct _Rep\n       {\n \t// Types:"}, {"sha": "896cd02afa72276e2fff49fe1e394fe7bf734a81", "filename": "libstdc++-v3/include/bits/basic_string.tcc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc?ref=005326029f35b4271c5274114a17126039fe18a0", "patch": "@@ -44,14 +44,14 @@\n namespace std\n {\n   template<typename _CharT, typename _Traits, typename _Alloc>\n-    const _CharT \n+    const typename basic_string<_CharT, _Traits, _Alloc>::size_type \n     basic_string<_CharT, _Traits, _Alloc>::\n-    _Rep::_S_terminal = _CharT();\n+    _Rep::_S_max_size = (((npos - sizeof(_Rep))/sizeof(_CharT)) - 1) / 4;\n \n   template<typename _CharT, typename _Traits, typename _Alloc>\n-    const typename basic_string<_CharT, _Traits, _Alloc>::size_type \n+    const _CharT \n     basic_string<_CharT, _Traits, _Alloc>::\n-    _Rep::_S_max_size = (((npos - sizeof(_Rep))/sizeof(_CharT)) - 1) / 4;\n+    _Rep::_S_terminal = _CharT();\n \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     const typename basic_string<_CharT, _Traits, _Alloc>::size_type"}, {"sha": "172adae2e04dd7f6ccbf3c5c501b33a01e33b7a9", "filename": "libstdc++-v3/include/bits/localefwd.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocalefwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocalefwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocalefwd.h?ref=005326029f35b4271c5274114a17126039fe18a0", "patch": "@@ -446,7 +446,7 @@ namespace std\n     // NB: There is no accessor for _M_index because it may be used\n     // before the constructor is run; the effect of calling a member\n     // function (even an inline) would be undefined.\n-    mutable size_t \t_M_index;\n+    mutable size_t \t\t_M_index;\n \n     // Last id number assigned\n     static _Atomic_word \t_S_highwater;   "}, {"sha": "1eee7b37b1152f78e96acc9fb3fbb4ddee1ef17b", "filename": "libstdc++-v3/include/bits/stl_algo.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h?ref=005326029f35b4271c5274114a17126039fe18a0", "patch": "@@ -1775,7 +1775,7 @@ __result, __binary_pred, _IterType());\n       }\n     }\n \n-  const int __stl_threshold = 16;\n+  extern const int __stl_threshold;\n \n   // sort() and its auxiliary functions.\n \n@@ -2060,7 +2060,7 @@ __result, __binary_pred, _IterType());\n \t    __comp);\n     }\n \n-  const int __stl_chunk_size = 7;\n+  extern const int __stl_chunk_size;\n \n   template<typename _RandomAccessIter, typename _Distance>\n     void"}, {"sha": "7a4d9e9e4a6b6f6b5d1994e5d84a835f57b78b54", "filename": "libstdc++-v3/include/bits/stl_alloc.h", "status": "modified", "additions": 231, "deletions": 224, "changes": 455, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h?ref=005326029f35b4271c5274114a17126039fe18a0", "patch": "@@ -1,6 +1,6 @@\n // Allocators -*- C++ -*-\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -321,267 +321,274 @@ typedef __mem_interface __single_client_alloc;\n  *  @endmaint\n  *  (See @link Allocators allocators info @endlink for more.)\n */\n-template <bool __threads, int __inst>\n-class __default_alloc_template\n-{\n+template<bool __threads, int __inst>\n+  class __default_alloc_template\n+  {\n+  private:\n+    enum {_ALIGN = 8};\n+    enum {_MAX_BYTES = 128};\n+    enum {_NFREELISTS = _MAX_BYTES / _ALIGN};\n+    \n+    union _Obj \n+    {\n+      union _Obj* _M_free_list_link;\n+      char        _M_client_data[1];    // The client sees this.\n+    };\n \n-private:\n-  enum {_ALIGN = 8};\n-  enum {_MAX_BYTES = 128};\n-  enum {_NFREELISTS = _MAX_BYTES / _ALIGN};\n+    static _Obj* volatile \t_S_free_list[_NFREELISTS]; \n \n-  static size_t\n-  _S_round_up(size_t __bytes) \n-    { return (((__bytes) + (size_t) _ALIGN-1) & ~((size_t) _ALIGN - 1)); }\n+    // Chunk allocation state.\n+    static char* \t\t_S_start_free;\n+    static char* \t\t_S_end_free;\n+    static size_t \t\t_S_heap_size;\n+    \n+    static _STL_mutex_lock \t_S_node_allocator_lock;\n \n-  union _Obj {\n-    union _Obj* _M_free_list_link;\n-    char        _M_client_data[1];    // The client sees this.\n-  };\n+    static size_t\n+    _S_round_up(size_t __bytes) \n+    { return (((__bytes) + (size_t) _ALIGN-1) & ~((size_t) _ALIGN - 1)); }\n \n-  static _Obj* volatile _S_free_list[]; \n-  static size_t _S_freelist_index(size_t __bytes)\n+    static size_t \n+    _S_freelist_index(size_t __bytes)\n     { return (((__bytes) + (size_t)_ALIGN-1)/(size_t)_ALIGN - 1); }\n \n-  // Returns an object of size __n, and optionally adds to size __n free list.\n-  static void* _S_refill(size_t __n);\n-  // Allocates a chunk for nobjs of size size.  nobjs may be reduced\n-  // if it is inconvenient to allocate the requested number.\n-  static char* _S_chunk_alloc(size_t __size, int& __nobjs);\n-\n-  // Chunk allocation state.\n-  static char* _S_start_free;\n-  static char* _S_end_free;\n-  static size_t _S_heap_size;\n-\n-  static _STL_mutex_lock _S_node_allocator_lock;\n+    // Returns an object of size __n, and optionally adds to size __n\n+    // free list.\n+    static void* \n+    _S_refill(size_t __n);\n \n-  // It would be nice to use _STL_auto_lock here.  But we need a test whether\n-  // threads are in use.\n-  class _Lock {\n+    // Allocates a chunk for nobjs of size size.  nobjs may be reduced\n+    // if it is inconvenient to allocate the requested number.\n+    static char* \n+    _S_chunk_alloc(size_t __size, int& __nobjs);\n+    \n+    // It would be nice to use _STL_auto_lock here.  But we need a\n+    // test whether threads are in use.\n+    class _Lock \n+    {\n     public:\n       _Lock() { if (__threads) _S_node_allocator_lock._M_acquire_lock(); }\n       ~_Lock() { if (__threads) _S_node_allocator_lock._M_release_lock(); }\n-  } __attribute__ ((__unused__));\n-  friend class _Lock;\n-\n-public:\n-\n-  // __n must be > 0\n-  static void* allocate(size_t __n)\n-  {\n-    void* __ret = 0;\n+    } __attribute__ ((__unused__));\n+    friend class _Lock;\n+    \n+  public:\n+    // __n must be > 0\n+    static void* \n+    allocate(size_t __n)\n+    {\n+      void* __ret = 0;\n+      \n+      if (__n > (size_t) _MAX_BYTES) \n+\t__ret = __mem_interface::allocate(__n);\n+      else \n+\t{\n+\t  _Obj* volatile* __my_free_list = _S_free_list \n+\t    + _S_freelist_index(__n);\n+\t  // Acquire the lock here with a constructor call.  This\n+\t  // ensures that it is released in exit or during stack\n+\t  // unwinding.\n+\t  _Lock __lock_instance;\n+\t  _Obj* __restrict__ __result = *__my_free_list;\n+\t  if (__result == 0)\n+\t    __ret = _S_refill(_S_round_up(__n));\n+\t  else \n+\t    {\n+\t      *__my_free_list = __result -> _M_free_list_link;\n+\t      __ret = __result;\n+\t    }\n+\t}\n+      return __ret;\n+    };\n \n-    if (__n > (size_t) _MAX_BYTES) \n-      __ret = __mem_interface::allocate(__n);\n-    else \n-      {\n-\t_Obj* volatile* __my_free_list = _S_free_list + _S_freelist_index(__n);\n-\t// Acquire the lock here with a constructor call.  This ensures that\n-\t// it is released in exit or during stack unwinding.\n-\t_Lock __lock_instance;\n-\t_Obj* __restrict__ __result = *__my_free_list;\n-\tif (__result == 0)\n-\t  __ret = _S_refill(_S_round_up(__n));\n-\telse \n-\t  {\n-\t    *__my_free_list = __result -> _M_free_list_link;\n-\t    __ret = __result;\n-\t  }\n-      }\n+    // __p may not be 0\n+    static void \n+    deallocate(void* __p, size_t __n)\n+    {\n+      if (__n > (size_t) _MAX_BYTES)\n+\t__mem_interface::deallocate(__p, __n);\n+      else \n+\t{\n+\t  _Obj* volatile*  __my_free_list\n+\t    = _S_free_list + _S_freelist_index(__n);\n+\t  _Obj* __q = (_Obj*)__p;\n+\t  \n+\t  // Acquire the lock here with a constructor call.  This ensures that\n+\t  // it is released in exit or during stack unwinding.\n+\t  _Lock __lock_instance;\n+\t  __q -> _M_free_list_link = *__my_free_list;\n+\t  *__my_free_list = __q;\n+\t}\n+    }\n     \n-    return __ret;\n+    static void* \n+    reallocate(void* __p, size_t __old_sz, size_t __new_sz);\n   };\n \n-  // __p may not be 0\n-  static void deallocate(void* __p, size_t __n)\n-  {\n-    if (__n > (size_t) _MAX_BYTES)\n-      __mem_interface::deallocate(__p, __n);\n-    else \n-      {\n-\t_Obj* volatile*  __my_free_list\n-          = _S_free_list + _S_freelist_index(__n);\n-\t_Obj* __q = (_Obj*)__p;\n-\t\n-\t// Acquire the lock here with a constructor call.  This ensures that\n-\t// it is released in exit or during stack unwinding.\n-\t_Lock __lock_instance;\n-\t__q -> _M_free_list_link = *__my_free_list;\n-\t*__my_free_list = __q;\n-      }\n-  }\n-  \n-  static void* reallocate(void* __p, size_t __old_sz, size_t __new_sz);\n-};\n \n+  template<bool __threads, int __inst>\n+    inline bool \n+    operator==(const __default_alloc_template<__threads, __inst>&,\n+\t       const __default_alloc_template<__threads, __inst>&)\n+    { return true; }\n \n-template <bool __threads, int __inst>\n-inline bool operator==(const __default_alloc_template<__threads, __inst>&,\n-                       const __default_alloc_template<__threads, __inst>&)\n-{\n-  return true;\n-}\n-\n-template <bool __threads, int __inst>\n-inline bool operator!=(const __default_alloc_template<__threads, __inst>&,\n-                       const __default_alloc_template<__threads, __inst>&)\n-{\n-  return false;\n-}\n-\n+  template<bool __threads, int __inst>\n+    inline bool \n+    operator!=(const __default_alloc_template<__threads, __inst>&,\n+\t       const __default_alloc_template<__threads, __inst>&)\n+    { return false; }\n \n-// We allocate memory in large chunks in order to avoid fragmenting the\n-// malloc heap (or whatever __mem_interface is using) too much.  We assume\n-// that __size is properly aligned.  We hold the allocation lock.\n-template <bool __threads, int __inst>\n-char*\n-__default_alloc_template<__threads, __inst>::_S_chunk_alloc(size_t __size, \n-                                                            int& __nobjs)\n-{\n-    char* __result;\n-    size_t __total_bytes = __size * __nobjs;\n-    size_t __bytes_left = _S_end_free - _S_start_free;\n \n-    if (__bytes_left >= __total_bytes) \n+  // We allocate memory in large chunks in order to avoid fragmenting the\n+  // malloc heap (or whatever __mem_interface is using) too much.  We assume\n+  // that __size is properly aligned.  We hold the allocation lock.\n+  template<bool __threads, int __inst>\n+    char*\n+    __default_alloc_template<__threads, __inst>::_S_chunk_alloc(size_t __size, \n+\t\t\t\t\t\t\t\tint& __nobjs)\n+    {\n+      char* __result;\n+      size_t __total_bytes = __size * __nobjs;\n+      size_t __bytes_left = _S_end_free - _S_start_free;\n+      \n+      if (__bytes_left >= __total_bytes) \n       {\n         __result = _S_start_free;\n         _S_start_free += __total_bytes;\n         return(__result);\n       } \n-    else if (__bytes_left >= __size) \n-      {\n-        __nobjs = (int)(__bytes_left/__size);\n-        __total_bytes = __size * __nobjs;\n-        __result = _S_start_free;\n-        _S_start_free += __total_bytes;\n-        return(__result);\n-    } \n-    else \n-      {\n-        size_t __bytes_to_get = \n-\t  2 * __total_bytes + _S_round_up(_S_heap_size >> 4);\n-        // Try to make use of the left-over piece.\n-        if (__bytes_left > 0) \n-\t  {\n-\t    _Obj* volatile* __my_free_list =\n-\t      _S_free_list + _S_freelist_index(__bytes_left);\n-\t    \n-\t    ((_Obj*)_S_start_free) -> _M_free_list_link = *__my_free_list;\n-\t    *__my_free_list = (_Obj*)_S_start_free;\n-\t  }\n-        _S_start_free = (char*) __mem_interface::allocate(__bytes_to_get);\n-        if (0 == _S_start_free) \n-\t  {\n-            size_t __i;\n-            _Obj* volatile* __my_free_list;\n-\t    _Obj* __p;\n-            // Try to make do with what we have.  That can't hurt.  We\n-            // do not try smaller requests, since that tends to result\n-            // in disaster on multi-process machines.\n-\t    __i = __size;\n-            for (; __i <= (size_t) _MAX_BYTES; __i += (size_t) _ALIGN) \n-\t      {\n-                __my_free_list = _S_free_list + _S_freelist_index(__i);\n-                __p = *__my_free_list;\n-                if (0 != __p) \n-\t\t  {\n-\t\t    *__my_free_list = __p -> _M_free_list_link;\n-\t\t    _S_start_free = (char*)__p;\n-                    _S_end_free = _S_start_free + __i;\n-                    return(_S_chunk_alloc(__size, __nobjs));\n-                    // Any leftover piece will eventually make it to the\n-                    // right free list.\n-\t\t  }\n-\t      }\n-\t    _S_end_free = 0;\t// In case of exception.\n-            _S_start_free = (char*)__mem_interface::allocate(__bytes_to_get);\n-            // This should either throw an exception or remedy the situation.\n-            // Thus we assume it succeeded.\n-\t  }\n-        _S_heap_size += __bytes_to_get;\n-        _S_end_free = _S_start_free + __bytes_to_get;\n-        return(_S_chunk_alloc(__size, __nobjs));\n-      }\n-}\n-\n-\n-// Returns an object of size __n, and optionally adds to \"size __n\"'s free list.\n-// We assume that __n is properly aligned.  We hold the allocation lock.\n-template <bool __threads, int __inst>\n-void*\n-__default_alloc_template<__threads, __inst>::_S_refill(size_t __n)\n-{\n-    int __nobjs = 20;\n-    char* __chunk = _S_chunk_alloc(__n, __nobjs);\n-    _Obj* volatile* __my_free_list;\n-    _Obj* __result;\n-    _Obj* __current_obj;\n-    _Obj* __next_obj;\n-    int __i;\n-\n-    if (1 == __nobjs) return(__chunk);\n-    __my_free_list = _S_free_list + _S_freelist_index(__n);\n-\n-    /* Build free list in chunk */\n+      else if (__bytes_left >= __size) \n+\t{\n+\t  __nobjs = (int)(__bytes_left/__size);\n+\t  __total_bytes = __size * __nobjs;\n+\t  __result = _S_start_free;\n+\t  _S_start_free += __total_bytes;\n+\t  return(__result);\n+\t} \n+      else \n+\t{\n+\t  size_t __bytes_to_get = \n+\t    2 * __total_bytes + _S_round_up(_S_heap_size >> 4);\n+\t  // Try to make use of the left-over piece.\n+\t  if (__bytes_left > 0) \n+\t    {\n+\t      _Obj* volatile* __my_free_list =\n+\t\t_S_free_list + _S_freelist_index(__bytes_left);\n+\t      \n+\t      ((_Obj*)_S_start_free) -> _M_free_list_link = *__my_free_list;\n+\t      *__my_free_list = (_Obj*)_S_start_free;\n+\t    }\n+\t  _S_start_free = (char*) __mem_interface::allocate(__bytes_to_get);\n+\t  if (0 == _S_start_free) \n+\t    {\n+\t      size_t __i;\n+\t      _Obj* volatile* __my_free_list;\n+\t      _Obj* __p;\n+\t      // Try to make do with what we have.  That can't hurt.  We\n+\t      // do not try smaller requests, since that tends to result\n+\t      // in disaster on multi-process machines.\n+\t      __i = __size;\n+\t      for (; __i <= (size_t) _MAX_BYTES; __i += (size_t) _ALIGN) \n+\t\t{\n+\t\t  __my_free_list = _S_free_list + _S_freelist_index(__i);\n+\t\t  __p = *__my_free_list;\n+\t\t  if (0 != __p) \n+\t\t    {\n+\t\t      *__my_free_list = __p -> _M_free_list_link;\n+\t\t      _S_start_free = (char*)__p;\n+\t\t      _S_end_free = _S_start_free + __i;\n+\t\t      return(_S_chunk_alloc(__size, __nobjs));\n+\t\t      // Any leftover piece will eventually make it to the\n+\t\t      // right free list.\n+\t\t    }\n+\t\t}\n+\t      _S_end_free = 0;\t// In case of exception.\n+\t      _S_start_free = (char*)__mem_interface::allocate(__bytes_to_get);\n+\t      // This should either throw an exception or remedy the situation.\n+\t      // Thus we assume it succeeded.\n+\t    }\n+\t  _S_heap_size += __bytes_to_get;\n+\t  _S_end_free = _S_start_free + __bytes_to_get;\n+\t  return(_S_chunk_alloc(__size, __nobjs));\n+\t}\n+    }\n+  \n+  \n+  // Returns an object of size __n, and optionally adds to \"size\n+  // __n\"'s free list.  We assume that __n is properly aligned.  We\n+  // hold the allocation lock.\n+  template<bool __threads, int __inst>\n+    void*\n+    __default_alloc_template<__threads, __inst>::_S_refill(size_t __n)\n+    {\n+      int __nobjs = 20;\n+      char* __chunk = _S_chunk_alloc(__n, __nobjs);\n+      _Obj* volatile* __my_free_list;\n+      _Obj* __result;\n+      _Obj* __current_obj;\n+      _Obj* __next_obj;\n+      int __i;\n+      \n+      if (1 == __nobjs) return(__chunk);\n+      __my_free_list = _S_free_list + _S_freelist_index(__n);\n+      \n+      /* Build free list in chunk */\n       __result = (_Obj*)__chunk;\n       *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);\n       for (__i = 1; ; __i++) {\n         __current_obj = __next_obj;\n         __next_obj = (_Obj*)((char*)__next_obj + __n);\n         if (__nobjs - 1 == __i) {\n-            __current_obj -> _M_free_list_link = 0;\n-            break;\n+\t  __current_obj -> _M_free_list_link = 0;\n+\t  break;\n         } else {\n-            __current_obj -> _M_free_list_link = __next_obj;\n+\t  __current_obj -> _M_free_list_link = __next_obj;\n         }\n       }\n-    return(__result);\n-}\n-\n+      return(__result);\n+    }\n \n-template <bool threads, int inst>\n-void*\n-__default_alloc_template<threads, inst>::reallocate(void* __p,\n-                                                    size_t __old_sz,\n-                                                    size_t __new_sz)\n-{\n-    void* __result;\n-    size_t __copy_sz;\n \n-    if (__old_sz > (size_t) _MAX_BYTES && __new_sz > (size_t) _MAX_BYTES) {\n+  template<bool threads, int inst>\n+    void*\n+    __default_alloc_template<threads, inst>::reallocate(void* __p, \n+\t\t\t\t\t\t\tsize_t __old_sz,\n+\t\t\t\t\t\t\tsize_t __new_sz)\n+    {\n+      void* __result;\n+      size_t __copy_sz;\n+      \n+      if (__old_sz > (size_t) _MAX_BYTES && __new_sz > (size_t) _MAX_BYTES) {\n         return(realloc(__p, __new_sz));\n+      }\n+      if (_S_round_up(__old_sz) == _S_round_up(__new_sz)) return(__p);\n+      __result = allocate(__new_sz);\n+      __copy_sz = __new_sz > __old_sz? __old_sz : __new_sz;\n+      memcpy(__result, __p, __copy_sz);\n+      deallocate(__p, __old_sz);\n+      return(__result);\n     }\n-    if (_S_round_up(__old_sz) == _S_round_up(__new_sz)) return(__p);\n-    __result = allocate(__new_sz);\n-    __copy_sz = __new_sz > __old_sz? __old_sz : __new_sz;\n-    memcpy(__result, __p, __copy_sz);\n-    deallocate(__p, __old_sz);\n-    return(__result);\n-}\n-\n-template <bool __threads, int __inst>\n+  \n+  template<bool __threads, int __inst>\n   _STL_mutex_lock\n   __default_alloc_template<__threads, __inst>::_S_node_allocator_lock\n-    __STL_MUTEX_INITIALIZER;\n-\n-template <bool __threads, int __inst>\n-char* __default_alloc_template<__threads, __inst>::_S_start_free = 0;\n-\n-template <bool __threads, int __inst>\n-char* __default_alloc_template<__threads, __inst>::_S_end_free = 0;\n-\n-template <bool __threads, int __inst>\n-size_t __default_alloc_template<__threads, __inst>::_S_heap_size = 0;\n-\n-template <bool __threads, int __inst>\n-typename __default_alloc_template<__threads, __inst>::_Obj* volatile\n-__default_alloc_template<__threads, __inst> ::_S_free_list[\n-    __default_alloc_template<__threads, __inst>::_NFREELISTS ];\n-\n-\n-typedef __default_alloc_template<true, 0>    __alloc;\n-typedef __default_alloc_template<false, 0>   __single_client_alloc;\n+  __STL_MUTEX_INITIALIZER;\n+  \n+  template<bool __threads, int __inst>\n+  char* __default_alloc_template<__threads, __inst>::_S_start_free = 0;\n+  \n+  template<bool __threads, int __inst>\n+  char* __default_alloc_template<__threads, __inst>::_S_end_free = 0;\n+  \n+  template<bool __threads, int __inst>\n+  size_t __default_alloc_template<__threads, __inst>::_S_heap_size = 0;\n+  \n+  template<bool __threads, int __inst>\n+  typename __default_alloc_template<__threads, __inst>::_Obj* volatile\n+  __default_alloc_template<__threads, __inst>::_S_free_list[_NFREELISTS];\n+  \n+  typedef __default_alloc_template<true, 0>    __alloc;\n+  typedef __default_alloc_template<false, 0>   __single_client_alloc;\n \n \n #endif /* ! __USE_MALLOC */"}, {"sha": "66c7e2de59442bb4f6ab4ebe85c8023ce228351b", "filename": "libstdc++-v3/include/bits/stl_bvector.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h?ref=005326029f35b4271c5274114a17126039fe18a0", "patch": "@@ -1,6 +1,6 @@\n // bit_vector and vector<bool> specialization -*- C++ -*-\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -63,8 +63,7 @@\n \n namespace std\n { \n-\n-static const int __WORD_BIT = int(CHAR_BIT*sizeof(unsigned int));\n+  extern const int __WORD_BIT;\n \n struct _Bit_reference {\n   unsigned int* _M_p;"}, {"sha": "ef50c9ee38a673061ff7f43dbd9d43a84a7dbd9c", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=005326029f35b4271c5274114a17126039fe18a0", "patch": "@@ -1,6 +1,6 @@\n // RB tree implementation -*- C++ -*-\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -90,10 +90,9 @@ iterators invalidated are those referring to the deleted node.\n \n namespace std\n { \n-\n-typedef bool _Rb_tree_Color_type;\n-const _Rb_tree_Color_type _S_rb_tree_red = false;\n-const _Rb_tree_Color_type _S_rb_tree_black = true;\n+  typedef bool _Rb_tree_Color_type;\n+  extern const _Rb_tree_Color_type _S_rb_tree_red; // false\n+  extern const _Rb_tree_Color_type _S_rb_tree_black; // true\n \n struct _Rb_tree_node_base\n {"}, {"sha": "43cef9e6d2ce17584d6474ee969748e90ffccad8", "filename": "libstdc++-v3/src/stl-inst.cc", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Fsrc%2Fstl-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005326029f35b4271c5274114a17126039fe18a0/libstdc%2B%2B-v3%2Fsrc%2Fstl-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fstl-inst.cc?ref=005326029f35b4271c5274114a17126039fe18a0", "patch": "@@ -1,6 +1,6 @@\n // Explicit instantiation file.\n \n-// Copyright (C) 1999, 2001 Free Software Foundation, Inc.\n+// Copyright (C) 1999, 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -35,9 +35,16 @@\n #include <memory>\n #include <vector>\n #include <ostream>\n+#include <map>\n \n namespace std\n {\n+  const int __stl_threshold = 16;\n+  const int __stl_chunk_size = 7;\n+  const int __WORD_BIT = int(CHAR_BIT*sizeof(unsigned int));\n+  const _Rb_tree_Color_type _S_rb_tree_red = false;\n+  const _Rb_tree_Color_type _S_rb_tree_black = true;\n+\n   template class __malloc_alloc_template<0>;\n \n #ifndef __USE_MALLOC"}]}