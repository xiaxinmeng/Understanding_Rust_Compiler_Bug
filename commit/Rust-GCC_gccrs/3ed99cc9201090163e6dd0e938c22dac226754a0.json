{"sha": "3ed99cc9201090163e6dd0e938c22dac226754a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VkOTljYzkyMDEwOTAxNjNlNmRkMGU5MzhjMjJkYWMyMjY3NTRhMA==", "commit": {"author": {"name": "Adrian Straetling", "email": "straetling@de.ibm.com", "date": "2005-05-09T18:12:25Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2005-05-09T18:12:25Z"}, "message": "s390-protos.h: (s390_match_ccmode...\n\n2005-05-09  Adrian Straetling  <straetling@de.ibm.com>\n\n\t* config/s390/s390-protos.h: (s390_match_ccmode,\n\ts390_match_ccmode_set, reg_used_in_mem_p,\n\tsymbolic_reference_mentioned_p, tls_symbolic_reference_mentioned_p,\n\tlegitimate_la_operand_p, preferred_la_operand_p,\n\ts390_short_displacement, addr_generation_dependency_p,\n\tlegitimate_reload_constant_p, legitimate_address_p): Change return type\n\tinto 'bool'.\n\t(s390_tm_ccmode): Change type of parameter \"mixed\" into 'bool'.\n\t* config/s390/s390.c: (s390_match_ccmode,\n\tsymbolic_reference_mentioned_p, tls_symbolic_reference_mentioned_p,\n\tlegitimate_reload_constant_p): Change return type into 'bool'.\n\t(preferred_la_operand_p,legitimate_la_operand_p, legitimate_address_p):\n\tLikewise.  Additionally adapted comment.\n\t(s390_extra_constraint_p): Change Comment to reflect 'int' return type.\n\t(s390_tm_ccmode): Change type of parameter \"mixed\" into 'bool'.\n\t(s390_decompose_address): Change the type of the internal flags\n\t\"pointer\", \"base_ptr\", \"indx_ptr\", and the return value into 'bool'.\n\t(struct s390_address): Change type of \"pointer\" into bool.\n\t* config/s390/s390.md: (\"*tmdi_reg\", \"*tmsi_reg\", \"tm<mode>_full\"):\n\tAdapt calls for 's390_tm_ccmode' to the new signature.\n\nFrom-SVN: r99463", "tree": {"sha": "c447c33129b6a8354048ec4204273b1c90da2398", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c447c33129b6a8354048ec4204273b1c90da2398"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ed99cc9201090163e6dd0e938c22dac226754a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ed99cc9201090163e6dd0e938c22dac226754a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ed99cc9201090163e6dd0e938c22dac226754a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ed99cc9201090163e6dd0e938c22dac226754a0/comments", "author": null, "committer": null, "parents": [{"sha": "ab96de7ea659d9cdb6eb218739c8d24d4856f789", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab96de7ea659d9cdb6eb218739c8d24d4856f789", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab96de7ea659d9cdb6eb218739c8d24d4856f789"}], "stats": {"total": 196, "additions": 108, "deletions": 88}, "files": [{"sha": "2c303acddd80725693f39c2d296458f3760da524", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed99cc9201090163e6dd0e938c22dac226754a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed99cc9201090163e6dd0e938c22dac226754a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ed99cc9201090163e6dd0e938c22dac226754a0", "patch": "@@ -1,3 +1,26 @@\n+2005-05-09  Adrian Straetling  <straetling@de.ibm.com>\n+\n+\t* config/s390/s390-protos.h: (s390_match_ccmode,\n+\ts390_match_ccmode_set, reg_used_in_mem_p,\n+\tsymbolic_reference_mentioned_p, tls_symbolic_reference_mentioned_p,\n+\tlegitimate_la_operand_p, preferred_la_operand_p,\n+\ts390_short_displacement, addr_generation_dependency_p,\n+\tlegitimate_reload_constant_p, legitimate_address_p): Change return type\n+\tinto 'bool'.\n+\t(s390_tm_ccmode): Change type of parameter \"mixed\" into 'bool'. \n+\t* config/s390/s390.c: (s390_match_ccmode,\n+\tsymbolic_reference_mentioned_p, tls_symbolic_reference_mentioned_p,\n+\tlegitimate_reload_constant_p): Change return type into 'bool'.\n+\t(preferred_la_operand_p,legitimate_la_operand_p, legitimate_address_p):\n+\tLikewise.  Additionally adapted comment.  \n+\t(s390_extra_constraint_p): Change Comment to reflect 'int' return type.\n+\t(s390_tm_ccmode): Change type of parameter \"mixed\" into 'bool'. \n+\t(s390_decompose_address): Change the type of the internal flags\n+\t\"pointer\", \"base_ptr\", \"indx_ptr\", and the return value into 'bool'.\n+\t(struct s390_address): Change type of \"pointer\" into bool.\n+\t* config/s390/s390.md: (\"*tmdi_reg\", \"*tmsi_reg\", \"tm<mode>_full\"):\n+\tAdapt calls for 's390_tm_ccmode' to the new signature.\n+\n 2005-05-09  Adrian Straetling  <straetling@de.ibm.com>\n \n \t* config/s390/s390.c: (s390_match_ccmode_set,"}, {"sha": "e1aa8275e0d2b7a6a954edd498c34da84fca4928", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed99cc9201090163e6dd0e938c22dac226754a0/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed99cc9201090163e6dd0e938c22dac226754a0/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=3ed99cc9201090163e6dd0e938c22dac226754a0", "patch": "@@ -39,20 +39,20 @@ extern bool s390_split_ok_p (rtx, rtx, enum machine_mode, int);\n extern bool s390_offset_p (rtx, rtx, rtx);\n extern int tls_symbolic_operand (rtx);\n \n-extern int s390_match_ccmode (rtx, enum machine_mode);\n-extern enum machine_mode s390_tm_ccmode (rtx, rtx, int);\n+extern bool s390_match_ccmode (rtx, enum machine_mode);\n+extern enum machine_mode s390_tm_ccmode (rtx, rtx, bool);\n extern enum machine_mode s390_select_ccmode (enum rtx_code, rtx, rtx);\n extern void s390_canonicalize_comparison (enum rtx_code *, rtx *, rtx *);\n extern rtx s390_emit_compare (enum rtx_code, rtx, rtx);\n extern void s390_emit_jump (rtx, rtx);\n-extern int symbolic_reference_mentioned_p (rtx);\n-extern int tls_symbolic_reference_mentioned_p (rtx);\n-extern int legitimate_la_operand_p (rtx);\n-extern int preferred_la_operand_p (rtx, rtx);\n+extern bool symbolic_reference_mentioned_p (rtx);\n+extern bool tls_symbolic_reference_mentioned_p (rtx);\n+extern bool legitimate_la_operand_p (rtx);\n+extern bool preferred_la_operand_p (rtx, rtx);\n extern int legitimate_pic_operand_p (rtx);\n extern int legitimate_constant_p (rtx);\n-extern int legitimate_reload_constant_p (rtx);\n-extern int legitimate_address_p (enum machine_mode, rtx, int);\n+extern bool legitimate_reload_constant_p (rtx);\n+extern bool legitimate_address_p (enum machine_mode, rtx, int);\n extern rtx legitimize_pic_address (rtx, rtx);\n extern rtx legitimize_address (rtx, rtx, enum machine_mode);\n extern rtx legitimize_reload_address (rtx, enum machine_mode, int, int);"}, {"sha": "4b3e86b7d4dcb7790d769f7e39ecf7bcef89c267", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 73, "deletions": 76, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed99cc9201090163e6dd0e938c22dac226754a0/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed99cc9201090163e6dd0e938c22dac226754a0/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=3ed99cc9201090163e6dd0e938c22dac226754a0", "patch": "@@ -177,7 +177,7 @@ struct s390_address\n   rtx base;\n   rtx indx;\n   rtx disp;\n-  int pointer;\n+  bool pointer;\n };\n \n /* Which cpu are we tuning for.  */\n@@ -259,7 +259,7 @@ struct machine_function GTY(())\n    the source and destination have matching CC modes and that\n    CC mode is at least as constrained as REQ_MODE.  */\n \n-static int\n+static bool\n s390_match_ccmode_set (rtx set, enum machine_mode req_mode)\n {\n   enum machine_mode set_mode;\n@@ -312,14 +312,14 @@ s390_match_ccmode_set (rtx set, enum machine_mode req_mode)\n    CC mode is at least as constrained as REQ_MODE.\n    If REQ_MODE is VOIDmode, always return false.  */\n \n-int\n+bool\n s390_match_ccmode (rtx insn, enum machine_mode req_mode)\n {\n   int i;\n \n   /* s390_tm_ccmode returns VOIDmode to indicate failure.  */\n   if (req_mode == VOIDmode)\n-    return 0;\n+    return false;\n \n   if (GET_CODE (PATTERN (insn)) == SET)\n     return s390_match_ccmode_set (PATTERN (insn), req_mode);\n@@ -330,10 +330,10 @@ s390_match_ccmode (rtx insn, enum machine_mode req_mode)\n           rtx set = XVECEXP (PATTERN (insn), 0, i);\n           if (GET_CODE (set) == SET)\n             if (!s390_match_ccmode_set (set, req_mode))\n-              return 0;\n+              return false;\n         }\n \n-  return 1;\n+  return true;\n }\n \n /* If a test-under-mask instruction can be used to implement\n@@ -344,7 +344,7 @@ s390_match_ccmode (rtx insn, enum machine_mode req_mode)\n    if the instruction cannot (TM).  */\n \n enum machine_mode\n-s390_tm_ccmode (rtx op1, rtx op2, int mixed)\n+s390_tm_ccmode (rtx op1, rtx op2, bool mixed)\n {\n   int bit0, bit1;\n \n@@ -1243,12 +1243,12 @@ s390_safe_attr_type (rtx insn)\n \n /* Return true if DISP is a valid short displacement.  */\n \n-static int\n+static bool\n s390_short_displacement (rtx disp)\n {\n   /* No displacement is OK.  */\n   if (!disp)\n-    return 1;\n+    return true;\n \n   /* Integer displacement in range.  */\n   if (GET_CODE (disp) == CONST_INT)\n@@ -1259,20 +1259,20 @@ s390_short_displacement (rtx disp)\n       && GET_CODE (XEXP (disp, 0)) == UNSPEC\n       && (XINT (XEXP (disp, 0), 1) == UNSPEC_GOT\n           || XINT (XEXP (disp, 0), 1) == UNSPEC_GOTNTPOFF))\n-    return 0;\n+    return false;\n \n   /* All other symbolic constants are literal pool references,\n      which are OK as the literal pool must be small.  */\n   if (GET_CODE (disp) == CONST)\n-    return 1;\n+    return true;\n \n-  return 0;\n+  return false;\n }\n \n /* Decompose a RTL expression ADDR for a memory address into\n    its components, returned in OUT.\n \n-   Returns 0 if ADDR is not a valid memory address, nonzero\n+   Returns false if ADDR is not a valid memory address, true\n    otherwise.  If OUT is NULL, don't return the components,\n    but check for validity only.\n \n@@ -1288,9 +1288,9 @@ s390_decompose_address (register rtx addr, struct s390_address *out)\n   rtx indx = NULL_RTX;\n   rtx disp = NULL_RTX;\n   rtx orig_disp;\n-  int pointer = FALSE;\n-  int base_ptr = FALSE;\n-  int indx_ptr = FALSE;\n+  bool pointer = false;\n+  bool base_ptr = false;\n+  bool indx_ptr = false;\n \n   /* Decompose address into base + index + displacement.  */\n \n@@ -1328,7 +1328,7 @@ s390_decompose_address (register rtx addr, struct s390_address *out)\n \n       else\n \t{\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n \n@@ -1367,7 +1367,7 @@ s390_decompose_address (register rtx addr, struct s390_address *out)\n       else if (!indx)\n         indx = gen_rtx_REG (Pmode, BASE_REGNUM);\n       else\n-        return FALSE;\n+        return false;\n \n       /* Mark up the displacement.  */\n       disp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, disp),\n@@ -1386,7 +1386,7 @@ s390_decompose_address (register rtx addr, struct s390_address *out)\n \t\t\t\t     gen_rtvec (1, XVECEXP (base, 0, 0)),\n \t\t\t\t     UNSPEC_LTREL_OFFSET);\n \t    else\n-\t      return FALSE;\n+\t      return false;\n \n \t    base = gen_rtx_REG (Pmode, BASE_REGNUM);\n \t    break;\n@@ -1396,11 +1396,11 @@ s390_decompose_address (register rtx addr, struct s390_address *out)\n \t    break;\n \n \t  default:\n-\t    return FALSE;\n+\t    return false;\n \t  }\n \n       if (GET_CODE (base) != REG || GET_MODE (base) != Pmode)\n-\treturn FALSE;\n+\treturn false;\n \n       if (REGNO (base) == BASE_REGNUM\n \t  || REGNO (base) == STACK_POINTER_REGNUM\n@@ -1411,7 +1411,7 @@ s390_decompose_address (register rtx addr, struct s390_address *out)\n \t  || REGNO (base) == ARG_POINTER_REGNUM\n           || (flag_pic\n               && REGNO (base) == PIC_OFFSET_TABLE_REGNUM))\n-        pointer = base_ptr = TRUE;\n+        pointer = base_ptr = true;\n     }\n \n   /* Validate index register.  */\n@@ -1426,7 +1426,7 @@ s390_decompose_address (register rtx addr, struct s390_address *out)\n \t\t\t\t     gen_rtvec (1, XVECEXP (indx, 0, 0)),\n \t\t\t\t     UNSPEC_LTREL_OFFSET);\n \t    else\n-\t      return FALSE;\n+\t      return false;\n \n \t    indx = gen_rtx_REG (Pmode, BASE_REGNUM);\n \t    break;\n@@ -1436,11 +1436,11 @@ s390_decompose_address (register rtx addr, struct s390_address *out)\n \t    break;\n \n \t  default:\n-\t    return FALSE;\n+\t    return false;\n \t  }\n \n       if (GET_CODE (indx) != REG || GET_MODE (indx) != Pmode)\n-\treturn FALSE;\n+\treturn false;\n \n       if (REGNO (indx) == BASE_REGNUM\n \t  || REGNO (indx) == STACK_POINTER_REGNUM\n@@ -1451,7 +1451,7 @@ s390_decompose_address (register rtx addr, struct s390_address *out)\n \t  || REGNO (indx) == ARG_POINTER_REGNUM\n           || (flag_pic\n               && REGNO (indx) == PIC_OFFSET_TABLE_REGNUM))\n-        pointer = indx_ptr = TRUE;\n+        pointer = indx_ptr = true;\n     }\n \n   /* Prefer to use pointer as base, not index.  */\n@@ -1480,12 +1480,12 @@ s390_decompose_address (register rtx addr, struct s390_address *out)\n \t  && base != return_address_pointer_rtx \n \t  && indx != return_address_pointer_rtx)\n \tif (!DISP_IN_RANGE (offset))\n-\t  return FALSE;\n+\t  return false;\n     }\n   else\n     {\n       /* All the special cases are pointers.  */\n-      pointer = TRUE;\n+      pointer = true;\n \n       /* In the small-PIC case, the linker converts @GOT\n          and @GOTNTPOFF offsets to possible displacements.  */\n@@ -1517,18 +1517,18 @@ s390_decompose_address (register rtx addr, struct s390_address *out)\n \t\t exceed the size of the constant pool entry.  */\n \t      rtx sym = XVECEXP (disp, 0, 0);\n \t      if (offset >= GET_MODE_SIZE (get_pool_mode (sym)))\n-\t\treturn FALSE;\n+\t\treturn false;\n \n               orig_disp = plus_constant (orig_disp, offset);\n \t    }\n         }\n \n       else\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if (!base && !indx)\n-    pointer = TRUE;\n+    pointer = true;\n \n   if (out)\n     {\n@@ -1538,7 +1538,7 @@ s390_decompose_address (register rtx addr, struct s390_address *out)\n       out->pointer = pointer;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Return true if CODE is a valid address without index.  */\n@@ -1556,7 +1556,7 @@ s390_legitimate_address_without_index_p (rtx op)\n   return true;\n }\n \n-/* Return true if OP is a valid operand for a C constraint.  */\n+/* Return 1 if OP is a valid operand for a C constraint, 0 else.  */\n \n int\n s390_extra_constraint_str (rtx op, int c, const char * str)\n@@ -1996,7 +1996,7 @@ s390_split_access_reg (rtx reg, rtx *lo, rtx *hi)\n \n /* Return true if OP contains a symbol reference */\n \n-int\n+bool\n symbolic_reference_mentioned_p (rtx op)\n {\n   register const char *fmt;\n@@ -2026,7 +2026,7 @@ symbolic_reference_mentioned_p (rtx op)\n \n /* Return true if OP contains a reference to a thread-local symbol.  */\n \n-int\n+bool\n tls_symbolic_reference_mentioned_p (rtx op)\n {\n   register const char *fmt;\n@@ -2044,14 +2044,14 @@ tls_symbolic_reference_mentioned_p (rtx op)\n \n \t  for (j = XVECLEN (op, i) - 1; j >= 0; j--)\n \t    if (tls_symbolic_reference_mentioned_p (XVECEXP (op, i, j)))\n-\t      return 1;\n+\t      return true;\n \t}\n \n       else if (fmt[i] == 'e' && tls_symbolic_reference_mentioned_p (XEXP (op, i)))\n-\treturn 1;\n+\treturn true;\n     }\n \n-  return 0;\n+  return false;\n }\n \n \n@@ -2172,31 +2172,31 @@ s390_cannot_force_const_mem (rtx x)\n    a constant that would need to be forced to the literal pool\n    before it can be used as operand.  */\n \n-int\n+bool\n legitimate_reload_constant_p (register rtx op)\n {\n   /* Accept la(y) operands.  */\n   if (GET_CODE (op) == CONST_INT\n       && DISP_IN_RANGE (INTVAL (op)))\n-    return 1;\n+    return true;\n \n   /* Accept l(g)hi operands.  */\n   if (GET_CODE (op) == CONST_INT\n       && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), 'K', \"K\"))\n-    return 1;\n+    return true;\n \n   /* Accept lliXX operands.  */\n   if (TARGET_ZARCH\n       && s390_single_part (op, DImode, HImode, 0) >= 0)\n-  return 1;\n+  return true;\n \n   /* Accept larl operands.  */\n   if (TARGET_CPU_ZARCH\n       && larl_operand (op, VOIDmode))\n-    return 1;\n+    return true;\n \n   /* Everything else cannot be handled without reload.  */\n-  return 0;\n+  return false;\n }\n \n /* Given an rtx OP being reloaded into a reg required to be in class CLASS,\n@@ -2343,56 +2343,53 @@ s390_expand_plus_operand (register rtx target, register rtx src,\n }\n \n \n-/* Return nonzero if ADDR is a valid memory address.\n+/* Return true if ADDR is a valid memory address.\n    STRICT specifies whether strict register checking applies.  */\n \n-int\n+bool\n legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t      register rtx addr, int strict)\n {\n   struct s390_address ad;\n   if (!s390_decompose_address (addr, &ad))\n-    return FALSE;\n+    return false;\n \n   if (strict)\n     {\n       if (ad.base && !REG_OK_FOR_BASE_STRICT_P (ad.base))\n-\treturn FALSE;\n+\treturn false;\n       if (ad.indx && !REG_OK_FOR_INDEX_STRICT_P (ad.indx))\n-\treturn FALSE;\n+\treturn false;\n     }\n   else\n     {\n       if (ad.base && !REG_OK_FOR_BASE_NONSTRICT_P (ad.base))\n-\treturn FALSE;\n+\treturn false;\n       if (ad.indx && !REG_OK_FOR_INDEX_NONSTRICT_P (ad.indx))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n-/* Return 1 if OP is a valid operand for the LA instruction.\n+/* Return true if OP is a valid operand for the LA instruction.\n    In 31-bit, we need to prove that the result is used as an\n    address, as LA performs only a 31-bit addition.  */\n \n-int\n+bool\n legitimate_la_operand_p (register rtx op)\n {\n   struct s390_address addr;\n   if (!s390_decompose_address (op, &addr))\n-    return FALSE;\n-\n-  if (TARGET_64BIT || addr.pointer)\n-    return TRUE;\n+    return false;\n \n-  return FALSE;\n+  return (TARGET_64BIT || addr.pointer);\n }\n \n-/* Return 1 if it is valid *and* preferable to use LA to\n+/* Return true if it is valid *and* preferable to use LA to\n    compute the sum of OP1 and OP2.  */\n \n-int\n+bool\n preferred_la_operand_p (rtx op1, rtx op2)\n {\n   struct s390_address addr;\n@@ -2401,23 +2398,23 @@ preferred_la_operand_p (rtx op1, rtx op2)\n     op1 = gen_rtx_PLUS (Pmode, op1, op2);\n \n   if (!s390_decompose_address (op1, &addr))\n-    return FALSE;\n+    return false;\n   if (addr.base && !REG_OK_FOR_BASE_STRICT_P (addr.base))\n-    return FALSE;\n+    return false;\n   if (addr.indx && !REG_OK_FOR_INDEX_STRICT_P (addr.indx))\n-    return FALSE;\n+    return false;\n \n   if (!TARGET_64BIT && !addr.pointer)\n-    return FALSE;\n+    return false;\n \n   if (addr.pointer)\n-    return TRUE;\n+    return true;\n \n   if ((addr.base && REG_P (addr.base) && REG_POINTER (addr.base))\n       || (addr.indx && REG_P (addr.indx) && REG_POINTER (addr.indx)))\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n /* Emit a forced load-address operation to load SRC into DST.\n@@ -3950,7 +3947,7 @@ s390_assemble_integer (rtx x, unsigned int size, int aligned_p)\n /* Returns true if register REGNO is used  for forming\n    a memory address in expression X.  */\n \n-static int\n+static bool\n reg_used_in_mem_p (int regno, rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n@@ -3961,35 +3958,35 @@ reg_used_in_mem_p (int regno, rtx x)\n     {\n       if (refers_to_regno_p (regno, regno+1,\n \t\t\t     XEXP (x, 0), 0))\n-\treturn 1;\n+\treturn true;\n     }\n   else if (code == SET\n \t   && GET_CODE (SET_DEST (x)) == PC)\n     {\n       if (refers_to_regno_p (regno, regno+1,\n \t\t\t     SET_SRC (x), 0))\n-\treturn 1;\n+\treturn true;\n     }\n \n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e'\n \t  && reg_used_in_mem_p (regno, XEXP (x, i)))\n-\treturn 1;\n+\treturn true;\n \n       else if (fmt[i] == 'E')\n \tfor (j = 0; j < XVECLEN (x, i); j++)\n \t  if (reg_used_in_mem_p (regno, XVECEXP (x, i, j)))\n-\t    return 1;\n+\t    return true;\n     }\n-  return 0;\n+  return false;\n }\n \n /* Returns true if expression DEP_RTX sets an address register\n    used by instruction INSN to address memory.  */\n \n-static int\n+static bool\n addr_generation_dependency_p (rtx dep_rtx, rtx insn)\n {\n   rtx target, pat;\n@@ -4027,7 +4024,7 @@ addr_generation_dependency_p (rtx dep_rtx, rtx insn)\n \t    return reg_used_in_mem_p (regno, PATTERN (insn));\n \t}\n     }\n-  return 0;\n+  return false;\n }\n \n /* Return 1, if dep_insn sets register used in insn in the agen unit.  */"}, {"sha": "9a666a8ec7c051eeea6bbef4c7d0baa4caf1b211", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed99cc9201090163e6dd0e938c22dac226754a0/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed99cc9201090163e6dd0e938c22dac226754a0/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=3ed99cc9201090163e6dd0e938c22dac226754a0", "patch": "@@ -364,7 +364,7 @@\n         (compare (and:QI (match_operand:QI 0 \"memory_operand\" \"Q,S\")\n                          (match_operand:QI 1 \"immediate_operand\" \"n,n\"))\n                  (match_operand:QI 2 \"immediate_operand\" \"n,n\")))]\n-  \"s390_match_ccmode (insn, s390_tm_ccmode (operands[1], operands[2], 0))\"\n+  \"s390_match_ccmode (insn, s390_tm_ccmode (operands[1], operands[2], false))\"\n   \"@\n    tm\\t%S0,%b1\n    tmy\\t%S0,%b1\"\n@@ -377,7 +377,7 @@\n \t\t\t\t\t     \"N0HD0,N1HD0,N2HD0,N3HD0\"))\n                  (match_operand:DI 2 \"immediate_operand\" \"n,n,n,n\")))]\n   \"TARGET_64BIT\n-   && s390_match_ccmode (insn, s390_tm_ccmode (operands[1], operands[2], 1))\n+   && s390_match_ccmode (insn, s390_tm_ccmode (operands[1], operands[2], true))\n    && s390_single_part (operands[1], DImode, HImode, 0) >= 0\"\n   \"@\n    tmhh\\t%0,%i1\n@@ -391,7 +391,7 @@\n         (compare (and:SI (match_operand:SI 0 \"nonimmediate_operand\" \"d,d\")\n                          (match_operand:SI 1 \"immediate_operand\" \"N0HS0,N1HS0\"))\n                  (match_operand:SI 2 \"immediate_operand\" \"n,n\")))]\n-  \"s390_match_ccmode (insn, s390_tm_ccmode (operands[1], operands[2], 1))\n+  \"s390_match_ccmode (insn, s390_tm_ccmode (operands[1], operands[2], true))\n    && s390_single_part (operands[1], SImode, HImode, 0) >= 0\"\n   \"@\n    tmh\\t%0,%i1\n@@ -402,7 +402,7 @@\n   [(set (reg CC_REGNUM)\n         (compare (match_operand:HQI 0 \"register_operand\" \"d\")\n                  (match_operand:HQI 1 \"immediate_operand\" \"n\")))]\n-  \"s390_match_ccmode (insn, s390_tm_ccmode (constm1_rtx, operands[1], 1))\"\n+  \"s390_match_ccmode (insn, s390_tm_ccmode (constm1_rtx, operands[1], true))\"\n   \"tml\\t%0,<max_uint>\"\n   [(set_attr \"op_type\" \"RI\")])\n "}]}