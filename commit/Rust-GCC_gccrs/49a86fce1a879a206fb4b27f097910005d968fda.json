{"sha": "49a86fce1a879a206fb4b27f097910005d968fda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDlhODZmY2UxYTg3OWEyMDZmYjRiMjdmMDk3OTEwMDA1ZDk2OGZkYQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-04-02T20:03:18Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-04-04T16:15:15Z"}, "message": "c++: Refrain from using replace_placeholders in constexpr evaluation [PR94205]\n\nThis removes the use of replace_placeholders in cxx_eval_constant_expression\n(which is causing the new test lambda-this6.C to ICE due to replace_placeholders\nmutating the shared TARGET_EXPR_INITIAL tree which then trips up the\ngimplifier).\n\nIn its place, this patch adds a 'parent' field to constexpr_ctx which is used to\nstore a pointer to an outer constexpr_ctx that refers to another object under\nconstruction.  With this new field, we can beef up lookup_placeholder to resolve\nPLACEHOLDER_EXPRs which refer to former objects under construction, which fixes\nPR94205 without needing to do replace_placeholders.  Also we can now respect the\nCONSTRUCTOR_PLACEHOLDER_BOUNDARY flag when resolving PLACEHOLDER_EXPRs, and\ndoing so fixes the constexpr analogue of PR79937.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/94205\n\tPR c++/79937\n\t* constexpr.c (struct constexpr_ctx): New field 'parent'.\n\t(cxx_eval_bare_aggregate): Propagate CONSTRUCTOR_PLACEHOLDER_BOUNDARY\n\tflag from the original constructor to the reduced constructor.\n\t(lookup_placeholder): Prefer to return the outermost matching object\n\tby recursively calling lookup_placeholder on the 'parent' context,\n\tbut don't cross CONSTRUCTOR_PLACEHOLDER_BOUNDARY constructors.\n\t(cxx_eval_constant_expression): Link the 'ctx' context to the 'new_ctx'\n\tcontext via 'new_ctx.parent' when being expanded without an explicit\n\ttarget.  Don't call replace_placeholders.\n\t(cxx_eval_outermost_constant_expr): Initialize 'ctx.parent' to NULL.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/94205\n\tPR c++/79937\n\t* g++.dg/cpp1y/pr79937-5.C: New test.\n\t* g++.dg/cpp1z/lambda-this6.C: New test.", "tree": {"sha": "12bed14c9db0a934c281b3c82703588d322faf56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12bed14c9db0a934c281b3c82703588d322faf56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49a86fce1a879a206fb4b27f097910005d968fda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49a86fce1a879a206fb4b27f097910005d968fda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49a86fce1a879a206fb4b27f097910005d968fda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49a86fce1a879a206fb4b27f097910005d968fda/comments", "author": null, "committer": null, "parents": [{"sha": "37244b217a7329792f4ec48027f63cf5010b0ea8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37244b217a7329792f4ec48027f63cf5010b0ea8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37244b217a7329792f4ec48027f63cf5010b0ea8"}], "stats": {"total": 97, "additions": 89, "deletions": 8}, "files": [{"sha": "686128a7ebad4172e51dfccbea12f8abb7b4ba80", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a86fce1a879a206fb4b27f097910005d968fda/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a86fce1a879a206fb4b27f097910005d968fda/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=49a86fce1a879a206fb4b27f097910005d968fda", "patch": "@@ -1,5 +1,18 @@\n 2020-04-04  Patrick Palka  <ppalka@redhat.com>\n \n+\tPR c++/94205\n+\tPR c++/79937\n+\t* constexpr.c (struct constexpr_ctx): New field 'parent'.\n+\t(cxx_eval_bare_aggregate): Propagate CONSTRUCTOR_PLACEHOLDER_BOUNDARY\n+\tflag from the original constructor to the reduced constructor.\n+\t(lookup_placeholder): Prefer to return the outermost matching object\n+\tby recursively calling lookup_placeholder on the 'parent' context,\n+\tbut don't cross CONSTRUCTOR_PLACEHOLDER_BOUNDARY constructors.\n+\t(cxx_eval_constant_expression): Link the 'ctx' context to the 'new_ctx'\n+\tcontext via 'new_ctx.parent' when being expanded without an explicit\n+\ttarget.  Don't call replace_placeholders.\n+\t(cxx_eval_outermost_constant_expr): Initialize 'ctx.parent' to NULL.\n+\n \tPR c++/94219\n \tPR c++/94205\n \t* constexpr.c (get_or_insert_ctor_field): Split out (while adding"}, {"sha": "96497ab85d782a5374d9682074f0c8e43c4ee327", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a86fce1a879a206fb4b27f097910005d968fda/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a86fce1a879a206fb4b27f097910005d968fda/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=49a86fce1a879a206fb4b27f097910005d968fda", "patch": "@@ -1076,6 +1076,9 @@ struct constexpr_ctx {\n   tree object;\n   /* If inside SWITCH_EXPR.  */\n   constexpr_switch_state *css_state;\n+  /* The aggregate initialization context inside which this one is nested.  This\n+     is used by lookup_placeholder to resolve PLACEHOLDER_EXPRs.  */\n+  const constexpr_ctx *parent;\n \n   /* Whether we should error on a non-constant expression or fail quietly.\n      This flag needs to be here, but some of the others could move to global\n@@ -3841,6 +3844,9 @@ cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,\n   vec<constructor_elt, va_gc> **p = &CONSTRUCTOR_ELTS (ctx->ctor);\n   vec_alloc (*p, vec_safe_length (v));\n \n+  if (CONSTRUCTOR_PLACEHOLDER_BOUNDARY (t))\n+    CONSTRUCTOR_PLACEHOLDER_BOUNDARY (ctx->ctor) = 1;\n+\n   unsigned i;\n   tree index, value;\n   bool constant_p = true;\n@@ -5303,6 +5309,12 @@ lookup_placeholder (const constexpr_ctx *ctx, bool lval, tree type)\n   if (!ctx)\n     return NULL_TREE;\n \n+  /* Prefer the outermost matching object, but don't cross\n+     CONSTRUCTOR_PLACEHOLDER_BOUNDARY constructors.  */\n+  if (ctx->ctor && !CONSTRUCTOR_PLACEHOLDER_BOUNDARY (ctx->ctor))\n+    if (tree outer_ob = lookup_placeholder (ctx->parent, lval, type))\n+      return outer_ob;\n+\n   /* We could use ctx->object unconditionally, but using ctx->ctor when we\n      can is a minor optimization.  */\n   if (!lval && ctx->ctor && same_type_p (TREE_TYPE (ctx->ctor), type))\n@@ -5606,19 +5618,16 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t    r = *p;\n \t    break;\n \t  }\n-\ttree init = TARGET_EXPR_INITIAL (t);\n \tif ((AGGREGATE_TYPE_P (type) || VECTOR_TYPE_P (type)))\n \t  {\n-\t    if (ctx->object)\n-\t      /* If the initializer contains any PLACEHOLDER_EXPR, we need to\n-\t\t resolve them before we create a new CONSTRUCTOR for the\n-\t\t temporary.  */\n-\t      init = replace_placeholders (init, ctx->object);\n-\n \t    /* We're being expanded without an explicit target, so start\n \t       initializing a new object; expansion with an explicit target\n \t       strips the TARGET_EXPR before we get here.  */\n \t    new_ctx = *ctx;\n+\t    /* Link CTX to NEW_CTX so that lookup_placeholder can resolve\n+\t       any PLACEHOLDER_EXPR within the initializer that refers to the\n+\t       former object under construction.  */\n+\t    new_ctx.parent = ctx;\n \t    new_ctx.ctor = build_constructor (type, NULL);\n \t    CONSTRUCTOR_NO_CLEARING (new_ctx.ctor) = true;\n \t    new_ctx.object = slot;\n@@ -6472,7 +6481,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n   bool overflow_p = false;\n \n   constexpr_global_ctx global_ctx;\n-  constexpr_ctx ctx = { &global_ctx, NULL, NULL, NULL, NULL, NULL,\n+  constexpr_ctx ctx = { &global_ctx, NULL, NULL, NULL, NULL, NULL, NULL,\n \t\t\tallow_non_constant, strict,\n \t\t\tmanifestly_const_eval || !allow_non_constant,\n \t\t\tuid_sensitive };"}, {"sha": "7b2d3c6edb1f29d045cd0351942283596ef091a3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a86fce1a879a206fb4b27f097910005d968fda/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a86fce1a879a206fb4b27f097910005d968fda/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=49a86fce1a879a206fb4b27f097910005d968fda", "patch": "@@ -1,5 +1,10 @@\n 2020-04-04  Patrick Palka  <ppalka@redhat.com>\n \n+\tPR c++/94205\n+\tPR c++/79937\n+\t* g++.dg/cpp1y/pr79937-5.C: New test.\n+\t* g++.dg/cpp1z/lambda-this6.C: New test.\n+\n \tPR c++/94219\n \tPR c++/94205\n \t* g++.dg/cpp1y/constexpr-nsdmi3.C: New test."}, {"sha": "cbf0115d5bbb5227e6f77b896a181f9c7e474c2d", "filename": "gcc/testsuite/g++.dg/cpp1y/pr79937-5.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a86fce1a879a206fb4b27f097910005d968fda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr79937-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a86fce1a879a206fb4b27f097910005d968fda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr79937-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr79937-5.C?ref=49a86fce1a879a206fb4b27f097910005d968fda", "patch": "@@ -0,0 +1,42 @@\n+// PR c++/79937\n+// This is a constexpr adaptation of pr79937-3.C and pr79937-4.C.\n+// { dg-do compile { target c++14 } }\n+\n+struct X {\n+  unsigned i;\n+  unsigned n = i;\n+};\n+\n+constexpr X bar(X x) {\n+  return x;\n+}\n+\n+struct Y\n+{\n+  static constexpr Y bar(Y y) { return y; }\n+  unsigned i;\n+  unsigned n = bar(Y{2,i}).n;\n+};\n+\n+constexpr X x { 1, bar(X{2}).n };\n+static_assert(x.n == 2, \"\");\n+\n+constexpr Y y { 1 };\n+static_assert(y.n == 1, \"\");\n+\n+struct Z {\n+  unsigned i;\n+  unsigned n = i;\n+  unsigned m = i;\n+};\n+\n+constexpr Z\n+baz (Z z)\n+{\n+  if (z.i != 1 || z.n != 2 || z.m != 1)\n+    __builtin_abort ();\n+  return z;\n+}\n+\n+constexpr Z z = baz (Z {1, Z {2}.n});\n+static_assert(z.i == 1 && z.n == 2 && z.m == 1, \"\");"}, {"sha": "76f067d374d2a98c68757bf7f696be19eaa60b77", "filename": "gcc/testsuite/g++.dg/cpp1z/lambda-this6.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a86fce1a879a206fb4b27f097910005d968fda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Flambda-this6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a86fce1a879a206fb4b27f097910005d968fda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Flambda-this6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Flambda-this6.C?ref=49a86fce1a879a206fb4b27f097910005d968fda", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile { target c++17 } }\n+\n+struct S\n+{\n+  int a = [this] { return 6; } ();\n+};\n+\n+S\n+foo()\n+{\n+  return {};\n+}"}]}