{"sha": "b34c78814983ef7dcb1b6baacb335836c960ac15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM0Yzc4ODE0OTgzZWY3ZGNiMWI2YmFhY2IzMzU4MzZjOTYwYWMxNQ==", "commit": {"author": {"name": "Jason Thorpe", "email": "thorpej@wasabisystems.com", "date": "2002-05-23T15:48:05Z"}, "committer": {"name": "Jason Thorpe", "email": "thorpej@gcc.gnu.org", "date": "2002-05-23T15:48:05Z"}, "message": "c-common.c (warn_nonnull): Declare.\n\n* c-common.c (warn_nonnull): Declare.\n(c_common_attribute_table): Add \"nonnull\" attribute.\n(handle_nonnull_attribute, check_function_nonnull, nonnull_check_p,\ncheck_nonnull_arg, get_nonnull_operand, check_function_arguments,\ncheck_function_arguments_recurse): New functions.\n* c-common.h (warn_nonnull): Declare extern.\n(check_function_arguments, check_function_arguments_recurse): New\nprototypes.\n* c-decl.c (c_decode_option): Add -Wnonnull option.\n* c-format.c (set_Wformat): Set warn_nonnull if enabling\nformat checking.\n(format_check_context): New structure.\n(check_format_info_recurse): Remove recursion and rename to...\n(check_format_arg): ...this.  Update comment.\n(check_format_info): Use check_function_arguments_recurse.\n* c-typeck.c (build_function_call): Call check_function_arguments\ninstead of check_function_format.\n* doc/extend.texi: Document \"nonnull\" attribute.\n* doc/invoke.texi: Docuemnt -Wnonnull option.\n* testsuite/gcc.dg/nonnull-1.c: New test.\n* testsuite/gcc.dg/nonnull-2.c: New test.\n\nFrom-SVN: r53790", "tree": {"sha": "ec1ff9d3e5c1ac88998d2453691cca3c42bc0416", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec1ff9d3e5c1ac88998d2453691cca3c42bc0416"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b34c78814983ef7dcb1b6baacb335836c960ac15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b34c78814983ef7dcb1b6baacb335836c960ac15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b34c78814983ef7dcb1b6baacb335836c960ac15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b34c78814983ef7dcb1b6baacb335836c960ac15/comments", "author": null, "committer": null, "parents": [{"sha": "9547983155087b81454e9149ad37c2945f8137b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9547983155087b81454e9149ad37c2945f8137b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9547983155087b81454e9149ad37c2945f8137b9"}], "stats": {"total": 572, "additions": 468, "deletions": 104}, "files": [{"sha": "be5370c4eae899d56f4761453d38cd8dd11e0691", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34c78814983ef7dcb1b6baacb335836c960ac15/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34c78814983ef7dcb1b6baacb335836c960ac15/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b34c78814983ef7dcb1b6baacb335836c960ac15", "patch": "@@ -1,3 +1,27 @@\n+2002-05-23  Jason Thorpe  <thorpej@wasabisystems.com>\n+\n+\t* c-common.c (warn_nonnull): Declare.\n+\t(c_common_attribute_table): Add \"nonnull\" attribute.\n+\t(handle_nonnull_attribute, check_function_nonnull, nonnull_check_p,\n+\tcheck_nonnull_arg, get_nonnull_operand, check_function_arguments,\n+\tcheck_function_arguments_recurse): New functions.\n+\t* c-common.h (warn_nonnull): Declare extern.\n+\t(check_function_arguments, check_function_arguments_recurse): New\n+\tprototypes.\n+\t* c-decl.c (c_decode_option): Add -Wnonnull option.\n+\t* c-format.c (set_Wformat): Set warn_nonnull if enabling\n+\tformat checking.\n+\t(format_check_context): New structure.\n+\t(check_format_info_recurse): Remove recursion and rename to...\n+\t(check_format_arg): ...this.  Update comment.\n+\t(check_format_info): Use check_function_arguments_recurse.\n+\t* c-typeck.c (build_function_call): Call check_function_arguments\n+\tinstead of check_function_format.\n+\t* doc/extend.texi: Document \"nonnull\" attribute.\n+\t* doc/invoke.texi: Docuemnt -Wnonnull option.\n+\t* testsuite/gcc.dg/nonnull-1.c: New test.\n+\t* testsuite/gcc.dg/nonnull-2.c: New test.\n+\n 2002-05-23  David S. Miller  <davem@redhat.com>\n \n \t* basic-block.h (CLEANUP_NO_INSN_DEL): Define it."}, {"sha": "006a831cf3c2fb23276d47a58a0b3cbae7573d8e", "filename": "gcc/c-common.c", "status": "modified", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34c78814983ef7dcb1b6baacb335836c960ac15/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34c78814983ef7dcb1b6baacb335836c960ac15/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=b34c78814983ef7dcb1b6baacb335836c960ac15", "patch": "@@ -230,6 +230,11 @@ int warn_sequence_point;\n /* Nonzero means to warn about compile-time division by zero.  */\n int warn_div_by_zero = 1;\n \n+/* Warn about NULL being passed to argument slots marked as requiring\n+   non-NULL.  */ \n+      \n+int warn_nonnull;\n+\n /* The elements of `ridpointers' are identifier nodes for the reserved\n    type names and storage classes.  It is indexed by a RID_... value.  */\n tree *ridpointers;\n@@ -344,8 +349,17 @@ static tree handle_deprecated_attribute\tPARAMS ((tree *, tree, tree, int,\n \t\t\t\t\t\t bool *));\n static tree handle_vector_size_attribute PARAMS ((tree *, tree, tree, int,\n \t\t\t\t\t\t  bool *));\n+static tree handle_nonnull_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n static tree vector_size_helper PARAMS ((tree, tree));\n \n+static void check_function_nonnull\tPARAMS ((tree, tree));\n+static void check_nonnull_arg\t\tPARAMS ((void *, tree,\n+\t\t\t\t\t\t unsigned HOST_WIDE_INT));\n+static bool nonnull_check_p\t\tPARAMS ((tree, unsigned HOST_WIDE_INT));\n+static bool get_nonnull_operand\t\tPARAMS ((tree,\n+\t\t\t\t\t\t unsigned HOST_WIDE_INT *));\n+\n /* Table of machine-independent attributes common to all C-like languages.  */\n const struct attribute_spec c_common_attribute_table[] =\n {\n@@ -406,6 +420,8 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_vector_size_attribute },\n   { \"visibility\",\t      1, 1, true,  false, false,\n \t\t\t      handle_visibility_attribute },\n+  { \"nonnull\",                0, -1, false, true, true,\n+\t\t\t      handle_nonnull_attribute },\n   { NULL,                     0, 0, false, false, false, NULL }\n };\n \n@@ -5599,3 +5615,280 @@ vector_size_helper (type, bottom)\n \n   return outer;\n }\n+\n+/* Handle the \"nonnull\" attribute.  */\n+static tree\n+handle_nonnull_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name ATTRIBUTE_UNUSED;\n+     tree args;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree type = *node;\n+  unsigned HOST_WIDE_INT attr_arg_num;\n+\n+  /* If no arguments are specified, all pointer arguments should be\n+     non-null.  Veryify a full prototype is given so that the arguments\n+     will have the correct types when we actually check them later.  */\n+  if (! args)\n+    {\n+      if (! TYPE_ARG_TYPES (type))\n+\t{\n+\t  error (\"nonnull attribute without arguments on a non-prototype\");\n+          *no_add_attrs = true;\n+\t}\n+      return NULL_TREE;\n+    }\n+\n+  /* Argument list specified.  Verify that each argument number references\n+     a pointer argument.  */\n+  for (attr_arg_num = 1; args; args = TREE_CHAIN (args))\n+    {\n+      tree argument;\n+      unsigned HOST_WIDE_INT arg_num, ck_num;\n+\n+      if (! get_nonnull_operand (TREE_VALUE (args), &arg_num))\n+\t{\n+\t  error (\"nonnull argument has invalid operand number (arg %lu)\",\n+\t\t (unsigned long) attr_arg_num);\n+\t  *no_add_attrs = true;\n+\t  return NULL_TREE;\n+\t}\n+\n+      argument = TYPE_ARG_TYPES (type);\n+      if (argument)\n+\t{\n+\t  for (ck_num = 1; ; ck_num++)\n+\t    {\n+\t      if (! argument || ck_num == arg_num)\n+\t\tbreak;\n+\t      argument = TREE_CHAIN (argument);\n+\t    }\n+\n+          if (! argument\n+\t      || TREE_CODE (TREE_VALUE (argument)) == VOID_TYPE)\n+\t    {\n+\t      error (\"nonnull argument with out-of-range operand number (arg %lu, operand %lu)\",\n+\t\t     (unsigned long) attr_arg_num, (unsigned long) arg_num);\n+\t      *no_add_attrs = true;\n+\t      return NULL_TREE;\n+\t    }\n+\n+          if (TREE_CODE (TREE_VALUE (argument)) != POINTER_TYPE)\n+\t    {\n+\t      error (\"nonnull argument references non-pointer operand (arg %lu, operand %lu)\",\n+\t\t   (unsigned long) attr_arg_num, (unsigned long) arg_num);\n+\t      *no_add_attrs = true;\n+\t      return NULL_TREE;\n+\t    }\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Check the argument list of a function call for null in argument slots\n+   that are marked as requiring a non-null pointer argument.  */\n+\n+static void\n+check_function_nonnull (attrs, params)\n+     tree attrs;\n+     tree params;\n+{\n+  tree a, args, param;\n+  int param_num;\n+\n+  for (a = attrs; a; a = TREE_CHAIN (a))\n+    {\n+      if (is_attribute_p (\"nonnull\", TREE_PURPOSE (a)))\n+\t{\n+          args = TREE_VALUE (a);\n+\n+          /* Walk the argument list.  If we encounter an argument number we\n+             should check for non-null, do it.  If the attribute has no args,\n+             then every pointer argument is checked (in which case the check\n+\t     for pointer type is done in check_nonnull_arg).  */\n+          for (param = params, param_num = 1; ;\n+               param_num++, param = TREE_CHAIN (param))\n+            {\n+              if (! param)\n+        \tbreak;\n+              if (! args || nonnull_check_p (args, param_num))\n+        \tcheck_function_arguments_recurse (check_nonnull_arg, NULL,\n+        \t\t\t\t\t  TREE_VALUE (param),\n+        \t\t\t\t\t  param_num);\n+            }\n+\t}\n+    }\n+}\n+\n+/* Helper for check_function_nonnull; given a list of operands which\n+   must be non-null in ARGS, determine if operand PARAM_NUM should be\n+   checked.  */\n+\n+static bool\n+nonnull_check_p (args, param_num)\n+     tree args;\n+     unsigned HOST_WIDE_INT param_num;\n+{\n+  unsigned HOST_WIDE_INT arg_num;\n+\n+  for (; args; args = TREE_CHAIN (args))\n+    {\n+      if (! get_nonnull_operand (TREE_VALUE (args), &arg_num))\n+        abort ();\n+\n+      if (arg_num == param_num)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* Check that the function argument PARAM (which is operand number\n+   PARAM_NUM) is non-null.  This is called by check_function_nonnull\n+   via check_function_arguments_recurse.  */\n+\n+static void\n+check_nonnull_arg (ctx, param, param_num)\n+     void *ctx ATTRIBUTE_UNUSED;\n+     tree param;\n+     unsigned HOST_WIDE_INT param_num;\n+{\n+  /* Just skip checking the argument if it's not a pointer.  This can\n+     happen if the \"nonnull\" attribute was given without an operand\n+     list (which means to check every pointer argument).  */\n+\n+  if (TREE_CODE (TREE_TYPE (param)) != POINTER_TYPE)\n+    return;\n+\n+  if (integer_zerop (param))\n+    warning (\"null argument where non-null required (arg %lu)\",\n+             (unsigned long) param_num);\n+}\n+\n+/* Helper for nonnull attribute handling; fetch the operand number\n+   from the attribute argument list.  */\n+\n+static bool\n+get_nonnull_operand (arg_num_expr, valp)\n+     tree arg_num_expr;\n+     unsigned HOST_WIDE_INT *valp;\n+{\n+  /* Strip any conversions from the arg number and verify they\n+     are constants.  */\n+  while (TREE_CODE (arg_num_expr) == NOP_EXPR\n+\t || TREE_CODE (arg_num_expr) == CONVERT_EXPR\n+\t || TREE_CODE (arg_num_expr) == NON_LVALUE_EXPR)\n+    arg_num_expr = TREE_OPERAND (arg_num_expr, 0);\n+\n+  if (TREE_CODE (arg_num_expr) != INTEGER_CST\n+      || TREE_INT_CST_HIGH (arg_num_expr) != 0)\n+    return false;\n+\n+  *valp = TREE_INT_CST_LOW (arg_num_expr);\n+  return true;\n+}\n+\f\n+/* Check for valid arguments being passed to a function.  */\n+void\n+check_function_arguments (attrs, params)\n+     tree attrs;\n+     tree params;\n+{\n+  /* Check for null being passed in a pointer argument that must be\n+     non-null.  We also need to do this if format checking is enabled.  */\n+\n+  if (warn_nonnull)\n+    check_function_nonnull (attrs, params);\n+\n+  /* Check for errors in format strings.  */\n+\n+  if (warn_format)\n+    check_function_format (NULL, attrs, params);\n+}\n+\n+/* Generic argument checking recursion routine.  PARAM is the argument to\n+   be checked.  PARAM_NUM is the number of the argument.  CALLBACK is invoked\n+   once the argument is resolved.  CTX is context for the callback.  */\n+void\n+check_function_arguments_recurse (callback, ctx, param, param_num)\n+     void (*callback) PARAMS ((void *, tree, unsigned HOST_WIDE_INT));\n+     void *ctx;\n+     tree param;\n+     unsigned HOST_WIDE_INT param_num;\n+{\n+  if (TREE_CODE (param) == NOP_EXPR)\n+    {\n+      /* Strip coercion.  */\n+      check_function_arguments_recurse (callback, ctx,\n+\t\t\t\t        TREE_OPERAND (param, 0), param_num);\n+      return;\n+    }\n+\n+  if (TREE_CODE (param) == CALL_EXPR)\n+    {\n+      tree type = TREE_TYPE (TREE_TYPE (TREE_OPERAND (param, 0)));\n+      tree attrs;\n+      bool found_format_arg = false;\n+\n+      /* See if this is a call to a known internationalization function\n+\t that modifies a format arg.  Such a function may have multiple\n+\t format_arg attributes (for example, ngettext).  */\n+\n+      for (attrs = TYPE_ATTRIBUTES (type);\n+\t   attrs;\n+\t   attrs = TREE_CHAIN (attrs))\n+\tif (is_attribute_p (\"format_arg\", TREE_PURPOSE (attrs)))\n+\t  {\n+\t    tree inner_args;\n+\t    tree format_num_expr;\n+\t    int format_num;\n+\t    int i;\n+\n+\t    /* Extract the argument number, which was previously checked\n+\t       to be valid.  */\n+\t    format_num_expr = TREE_VALUE (TREE_VALUE (attrs));\n+\t    while (TREE_CODE (format_num_expr) == NOP_EXPR\n+\t\t   || TREE_CODE (format_num_expr) == CONVERT_EXPR\n+\t\t   || TREE_CODE (format_num_expr) == NON_LVALUE_EXPR)\n+\t      format_num_expr = TREE_OPERAND (format_num_expr, 0);\n+\n+\t    if (TREE_CODE (format_num_expr) != INTEGER_CST\n+\t\t|| TREE_INT_CST_HIGH (format_num_expr) != 0)\n+\t      abort ();\n+\n+\t    format_num = TREE_INT_CST_LOW (format_num_expr);\n+\n+\t    for (inner_args = TREE_OPERAND (param, 1), i = 1;\n+\t\t inner_args != 0;\n+\t\t inner_args = TREE_CHAIN (inner_args), i++)\n+\t      if (i == format_num)\n+\t\t{\n+\t\t  check_function_arguments_recurse (callback, ctx,\n+\t\t\t\t\t\t    TREE_VALUE (inner_args),\n+\t\t\t\t\t\t    param_num);\n+\t\t  found_format_arg = true;\n+\t\t  break;\n+\t\t}\n+\t  }\n+\n+      /* If we found a format_arg attribute and did a recursive check,\n+\t we are done with checking this argument.  Otherwise, we continue\n+\t and this will be considered a non-literal.  */\n+      if (found_format_arg)\n+\treturn;\n+    }\n+\n+  if (TREE_CODE (param) == COND_EXPR)\n+    {\n+      /* Check both halves of the conditional expression.  */\n+      check_function_arguments_recurse (callback, ctx,\n+\t\t\t\t        TREE_OPERAND (param, 1), param_num);\n+      check_function_arguments_recurse (callback, ctx,\n+\t\t\t\t        TREE_OPERAND (param, 2), param_num);\n+      return;\n+    }\n+\n+  (*callback) (ctx, param, param_num);\n+}"}, {"sha": "834d78520dc0a5f3bed6a1dc050e3160eb4a57a6", "filename": "gcc/c-common.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34c78814983ef7dcb1b6baacb335836c960ac15/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34c78814983ef7dcb1b6baacb335836c960ac15/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=b34c78814983ef7dcb1b6baacb335836c960ac15", "patch": "@@ -426,6 +426,11 @@ extern int warn_format_nonliteral;\n \n extern int warn_format_security;\n \n+/* Warn about NULL being passed to argument slots marked as requiring\n+   non-NULL.  */\n+\n+extern int warn_nonnull;\n+\n /* Warn about possible violations of sequence point rules.  */\n \n extern int warn_sequence_point;\n@@ -522,6 +527,12 @@ extern const char *fname_as_string\t\tPARAMS ((int));\n extern tree fname_decl\t\t\t\tPARAMS ((unsigned, tree));\n extern const char *fname_string\t\t\tPARAMS ((unsigned));\n \n+extern void check_function_arguments\t\tPARAMS ((tree, tree));\n+extern void check_function_arguments_recurse\tPARAMS ((void (*) (void *,\n+\t\t\t\t\t\t\t\t   tree,\n+\t\t\t\t\t\t\t\t   unsigned HOST_WIDE_INT),\n+\t\t\t\t\t\t\t void *, tree,\n+\t\t\t\t\t\t\t unsigned HOST_WIDE_INT));\n extern void check_function_format\t\tPARAMS ((int *, tree, tree));\n extern void set_Wformat\t\t\t\tPARAMS ((int));\n extern tree handle_format_attribute\t\tPARAMS ((tree *, tree, tree,"}, {"sha": "3dcb05540ec7c712ee28c372dca21c46defc8425", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34c78814983ef7dcb1b6baacb335836c960ac15/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34c78814983ef7dcb1b6baacb335836c960ac15/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=b34c78814983ef7dcb1b6baacb335836c960ac15", "patch": "@@ -489,6 +489,7 @@ c_decode_option (argc, argv)\n     { \"missing-prototypes\", &warn_missing_prototypes },\n     { \"multichar\", &warn_multichar },\n     { \"nested-externs\", &warn_nested_externs },\n+    { \"nonnull\", &warn_nonnull },\n     { \"parentheses\", &warn_parentheses },\n     { \"pointer-arith\", &warn_pointer_arith },\n     { \"redundant-decls\", &warn_redundant_decls },"}, {"sha": "b3640c50190e502100152be7d1b331346a4c9d84", "filename": "gcc/c-format.c", "status": "modified", "additions": 35, "deletions": 95, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34c78814983ef7dcb1b6baacb335836c960ac15/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34c78814983ef7dcb1b6baacb335836c960ac15/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=b34c78814983ef7dcb1b6baacb335836c960ac15", "patch": "@@ -71,6 +71,9 @@ set_Wformat (setting)\n       warn_format_nonliteral = setting;\n       warn_format_security = setting;\n     }\n+  /* Make sure not to disable -Wnonnull if -Wformat=0 is specified.  */\n+  if (setting)\n+    warn_nonnull = setting;\n }\n \n \f\n@@ -900,10 +903,16 @@ typedef struct\n   int number_other;\n } format_check_results;\n \n+typedef struct\n+{\n+  format_check_results *res;\n+  function_format_info *info;\n+  tree params;\n+  int *status;\n+} format_check_context;\n+\n static void check_format_info\tPARAMS ((int *, function_format_info *, tree));\n-static void check_format_info_recurse PARAMS ((int *, format_check_results *,\n-\t\t\t\t\t       function_format_info *, tree,\n-\t\t\t\t\t       tree, unsigned HOST_WIDE_INT));\n+static void check_format_arg\tPARAMS ((void *, tree, unsigned HOST_WIDE_INT));\n static void check_format_info_main PARAMS ((int *, format_check_results *,\n \t\t\t\t\t    function_format_info *,\n \t\t\t\t\t    const char *, int, tree,\n@@ -1294,6 +1303,7 @@ check_format_info (status, info, params)\n      function_format_info *info;\n      tree params;\n {\n+  format_check_context format_ctx;\n   unsigned HOST_WIDE_INT arg_num;\n   tree format_tree;\n   format_check_results res;\n@@ -1320,7 +1330,13 @@ check_format_info (status, info, params)\n   res.number_unterminated = 0;\n   res.number_other = 0;\n \n-  check_format_info_recurse (status, &res, info, format_tree, params, arg_num);\n+  format_ctx.res = &res;\n+  format_ctx.info = info;\n+  format_ctx.params = params;\n+  format_ctx.status = status;\n+\n+  check_function_arguments_recurse (check_format_arg, &format_ctx,\n+\t\t\t\t    format_tree, arg_num);\n \n   if (res.number_non_literal > 0)\n     {\n@@ -1377,110 +1393,34 @@ check_format_info (status, info, params)\n     status_warning (status, \"unterminated format string\");\n }\n \n-\n-/* Recursively check a call to a format function.  FORMAT_TREE is the\n-   format parameter, which may be a conditional expression in which\n-   both halves should be checked.  ARG_NUM is the number of the\n-   format argument; PARAMS points just after it in the argument list.  */\n+/* Callback from check_function_arguments_recurse to check a\n+   format string.  FORMAT_TREE is the format parameter.  ARG_NUM\n+   is the number of the format argument.  CTX points to a\n+   format_check_context.  */\n \n static void\n-check_format_info_recurse (status, res, info, format_tree, params, arg_num)\n-     int *status;\n-     format_check_results *res;\n-     function_format_info *info;\n+check_format_arg (ctx, format_tree, arg_num)\n+     void *ctx;\n      tree format_tree;\n-     tree params;\n      unsigned HOST_WIDE_INT arg_num;\n {\n+  format_check_context *format_ctx = ctx;\n+  format_check_results *res = format_ctx->res;\n+  function_format_info *info = format_ctx->info;\n+  tree params = format_ctx->params;\n+  int *status = format_ctx->status;\n+\n   int format_length;\n   HOST_WIDE_INT offset;\n   const char *format_chars;\n   tree array_size = 0;\n   tree array_init;\n \n-  if (TREE_CODE (format_tree) == NOP_EXPR)\n-    {\n-      /* Strip coercion.  */\n-      check_format_info_recurse (status, res, info,\n-\t\t\t\t TREE_OPERAND (format_tree, 0), params,\n-\t\t\t\t arg_num);\n-      return;\n-    }\n-\n-  if (TREE_CODE (format_tree) == CALL_EXPR)\n-    {\n-      tree type = TREE_TYPE (TREE_TYPE (TREE_OPERAND (format_tree, 0)));\n-      tree attrs;\n-      bool found_format_arg = false;\n-\n-      /* See if this is a call to a known internationalization function\n-\t that modifies the format arg.  Such a function may have multiple\n-\t format_arg attributes (for example, ngettext).  */\n-\n-      for (attrs = TYPE_ATTRIBUTES (type);\n-\t   attrs;\n-\t   attrs = TREE_CHAIN (attrs))\n-\tif (is_attribute_p (\"format_arg\", TREE_PURPOSE (attrs)))\n-\t  {\n-\t    tree inner_args;\n-\t    tree format_num_expr;\n-\t    int format_num;\n-\t    int i;\n-\n-\t    /* Extract the argument number, which was previously checked\n-\t       to be valid.  */\n-\t    format_num_expr = TREE_VALUE (TREE_VALUE (attrs));\n-\t    while (TREE_CODE (format_num_expr) == NOP_EXPR\n-\t\t   || TREE_CODE (format_num_expr) == CONVERT_EXPR\n-\t\t   || TREE_CODE (format_num_expr) == NON_LVALUE_EXPR)\n-\t      format_num_expr = TREE_OPERAND (format_num_expr, 0);\n-\n-\t    if (TREE_CODE (format_num_expr) != INTEGER_CST\n-\t\t|| TREE_INT_CST_HIGH (format_num_expr) != 0)\n-\t      abort ();\n-\n-\t    format_num = TREE_INT_CST_LOW (format_num_expr);\n-\n-\t    for (inner_args = TREE_OPERAND (format_tree, 1), i = 1;\n-\t\t inner_args != 0;\n-\t\t inner_args = TREE_CHAIN (inner_args), i++)\n-\t      if (i == format_num)\n-\t\t{\n-\t\t  check_format_info_recurse (status, res, info,\n-\t\t\t\t\t     TREE_VALUE (inner_args), params,\n-\t\t\t\t\t     arg_num);\n-\t\t  found_format_arg = true;\n-\t\t  break;\n-\t\t}\n-\t  }\n-\n-      /* If we found a format_arg attribute and did a recursive check,\n-\t we are done with checking this format string.  Otherwise, we\n-\t continue and this will count as a non-literal format string.  */\n-      if (found_format_arg)\n-\treturn;\n-    }\n-\n-  if (TREE_CODE (format_tree) == COND_EXPR)\n-    {\n-      /* Check both halves of the conditional expression.  */\n-      check_format_info_recurse (status, res, info,\n-\t\t\t\t TREE_OPERAND (format_tree, 1), params,\n-\t\t\t\t arg_num);\n-      check_format_info_recurse (status, res, info,\n-\t\t\t\t TREE_OPERAND (format_tree, 2), params,\n-\t\t\t\t arg_num);\n-      return;\n-    }\n-\n   if (integer_zerop (format_tree))\n     {\n-      /* FIXME: this warning should go away once Marc Espie's\n-\t __attribute__((nonnull)) patch is in.  Instead, checking for\n-\t nonnull attributes should probably change this function to act\n-\t specially if info == NULL and add a res->number_null entry for\n-\t that case, or maybe add a function pointer to be called at\n-\t the end instead of hardcoding check_format_info_main.  */\n+      /* FIXME: instead of warning about a null format string here,\n+\t functions for which we want to perform this check should be\n+\t marked with the \"nonnull\" attribute on the appropriate arguments.  */\n       status_warning (status, \"null format string\");\n \n       /* Skip to first argument to check, so we can see if this format"}, {"sha": "76ebc3416d940accb317ad75a72a0c3f1607fbb1", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34c78814983ef7dcb1b6baacb335836c960ac15/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34c78814983ef7dcb1b6baacb335836c960ac15/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=b34c78814983ef7dcb1b6baacb335836c960ac15", "patch": "@@ -1576,10 +1576,9 @@ build_function_call (function, params)\n   coerced_params\n     = convert_arguments (TYPE_ARG_TYPES (fntype), params, name, fundecl);\n \n-  /* Check for errors in format strings.  */\n+  /* Check that the arguments to the function are valid.  */\n \n-  if (warn_format)\n-    check_function_format (NULL, TYPE_ATTRIBUTES (fntype), coerced_params);\n+  check_function_arguments (TYPE_ATTRIBUTES (fntype), coerced_params);\n \n   /* Recognize certain built-in functions so we can make tree-codes\n      other than CALL_EXPR.  We do this when it enables fold-const.c"}, {"sha": "301db237124e0e96168a860082720944f35e126e", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34c78814983ef7dcb1b6baacb335836c960ac15/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34c78814983ef7dcb1b6baacb335836c960ac15/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=b34c78814983ef7dcb1b6baacb335836c960ac15", "patch": "@@ -1869,6 +1869,7 @@ the enclosing block.\n @cindex @code{volatile} applied to function\n @cindex @code{const} applied to function\n @cindex functions with @code{printf}, @code{scanf}, @code{strftime} or @code{strfmon} style arguments\n+@cindex functions with non-null pointer arguments\n @cindex functions that are passed arguments in registers on the 386\n @cindex functions that pop the argument stack on the 386\n @cindex functions that do not pop the argument stack on the 386\n@@ -1885,11 +1886,11 @@ attributes are currently defined for functions on all targets:\n @code{pure}, @code{const},\n @code{format}, @code{format_arg}, @code{no_instrument_function},\n @code{section}, @code{constructor}, @code{destructor}, @code{used},\n-@code{unused}, @code{deprecated}, @code{weak}, @code{malloc}, and\n-@code{alias}.  Several other attributes are defined for functions on\n-particular target systems.  Other attributes, including @code{section}\n-are supported for variables declarations (@pxref{Variable Attributes})\n-and for types (@pxref{Type Attributes}).\n+@code{unused}, @code{deprecated}, @code{weak}, @code{malloc},\n+@code{alias}, and @code{nonnull}.  Several other attributes are defined\n+for functions on particular target systems.  Other attributes, including\n+@code{section} are supported for variables declarations\n+(@pxref{Variable Attributes}) and for types (@pxref{Type Attributes}).\n \n You may also specify attributes with @samp{__} preceding and following\n each keyword.  This allows you to use them in header files without\n@@ -2101,6 +2102,35 @@ requested by @option{-ansi} or an appropriate @option{-std} option, or\n @option{-ffreestanding} is used.  @xref{C Dialect Options,,Options\n Controlling C Dialect}.\n \n+@item nonnull (@var{arg-index,...})\n+@cindex @code{nonnull} function attribute\n+The @code{nonnull} attribute specifies that some function parameters should\n+be non-null pointers.  For instance, the declaration:\n+\n+@smallexample\n+extern void *\n+my_memcpy (void *dest, const void *src, size_t len)\n+\t__attribute__((nonnull (1, 2)));\n+@end smallexample\n+\n+@noindent\n+causes the compiler to check that, in calls to @code{my_memcpy},\n+arguments @var{dest} and @var{src} are non-null.  If the compiler\n+determines that a null pointer is passed in an argument slot marked\n+as non-null, and the @option{-Wnonnull} option is enabled, a warning\n+is issued.  The compiler may also choose to make optimizations based\n+on the knowledge that certain function arguments will not be null.\n+\n+If no argument index list is given to the @code{nonnull} attribute,\n+all pointer arguments are marked as non-null.  To illustrate, the\n+following declaration is equivalent to the previous example:\n+\n+@smallexample\n+extern void *\n+my_memcpy (void *dest, const void *src, size_t len)\n+\t__attribute__((nonnull));\n+@end smallexample\n+\n @item no_instrument_function\n @cindex @code{no_instrument_function} function attribute\n @opindex finstrument-functions"}, {"sha": "1ab9cb39f9850f41858222bc38a22deca9ef0095", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34c78814983ef7dcb1b6baacb335836c960ac15/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34c78814983ef7dcb1b6baacb335836c960ac15/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b34c78814983ef7dcb1b6baacb335836c960ac15", "patch": "@@ -225,7 +225,7 @@ in the following sections.\n -Wmain  -Wmissing-braces  -Wmissing-declarations @gol\n -Wmissing-format-attribute  -Wmissing-noreturn @gol\n -Wno-multichar  -Wno-format-extra-args  -Wno-format-y2k @gol\n--Wno-import  -Wpacked  -Wpadded @gol\n+-Wno-import  -Wnonnull  -Wpacked  -Wpadded @gol\n -Wparentheses  -Wpointer-arith  -Wredundant-decls @gol\n -Wreturn-type  -Wsequence-point  -Wshadow @gol\n -Wsign-compare  -Wswitch  -Wswitch-default -Wswitch-enum @gol\n@@ -1842,6 +1842,9 @@ in the selected standard version (but not for @code{strfmon} formats,\n since those are not in any version of the C standard).  @xref{C Dialect\n Options,,Options Controlling C Dialect}.\n \n+Since @option{-Wformat} also checks for null format arguments for\n+several functions, @option{-Wformat} also implies @option{-Wnonnull}.\n+\n @option{-Wformat} is included in @option{-Wall}.  For more control over some\n aspects of format checking, the options @option{-Wno-format-y2k},\n @option{-Wno-format-extra-args}, @option{-Wno-format-zero-length},\n@@ -1896,6 +1899,14 @@ Enable @option{-Wformat} plus format checks not included in\n @option{-Wformat}.  Currently equivalent to @samp{-Wformat\n -Wformat-nonliteral -Wformat-security}.\n \n+@item -Wnonnull\n+@opindex Wnonnull\n+Enable warning about passing a null pointer for arguments marked as\n+requiring a non-null value by the @code{nonnull} function attribute.\n+\n+@option{-Wnonnull} is included in @option{-Wall} and @option{-Wformat}.  It\n+can be disabled with the @option{-Wno-nonnull} option.\n+\n @item -Wimplicit-int\n @opindex Wimplicit-int\n Warn when a declaration does not specify a type."}, {"sha": "51a8a3373ee12bee58ff771a9c39996c1eee6282", "filename": "gcc/testsuite/gcc.dg/nonnull-1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34c78814983ef7dcb1b6baacb335836c960ac15/gcc%2Ftestsuite%2Fgcc.dg%2Fnonnull-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34c78814983ef7dcb1b6baacb335836c960ac15/gcc%2Ftestsuite%2Fgcc.dg%2Fnonnull-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnonnull-1.c?ref=b34c78814983ef7dcb1b6baacb335836c960ac15", "patch": "@@ -0,0 +1,39 @@\n+/* Test for the \"nonnull\" function attribute.  */\n+/* Origin: Jason Thorpe <thorpej@wasabisystems.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wnonnull\" } */\n+\n+#include <stddef.h>\n+\n+extern void func1 (char *, char *, int) __attribute__((nonnull));\n+\n+extern void func2 (char *, char *) __attribute__((nonnull(1)));\n+\n+extern void func3 (char *, int, char *, int)\n+  __attribute__((nonnull(1,3)));\n+\n+extern void func4 (char *, char *) __attribute__((nonnull(1)))\n+  __attribute__((nonnull(2)));\n+\n+void\n+foo (int i1, int i2, int i3, char *cp1, char *cp2, char *cp3)\n+{\n+  func1(cp1, cp2, i1);\n+\n+  func1(NULL, cp2, i1); /* { dg-warning \"null\" \"null with argless nonnull 1\" } */\n+  func1(cp1, NULL, i1); /* { dg-warning \"null\" \"null with argless nonnull 2\" } */\n+  func1(cp1, cp2, 0);\n+\n+  func2(cp1, NULL);\n+  func2(NULL, cp1); /* { dg-warning \"null\" \"null with single explicit nonnull\" } */\n+\n+  func3(NULL, i2, cp3, i3); /* { dg-warning \"null\" \"null with explicit nonnull 1\" } */\n+  func3(cp3, i2, NULL, i3); /* { dg-warning \"null\" \"null with explicit nonnull 3\" } */\n+\n+  func1(i1 ? cp1 : NULL, cp2, i3); /* { dg-warning \"null\" \"null with cond expr rhs\" } */\n+  func1(i1 ? NULL : cp1, cp2, i3); /* { dg-warning \"null\" \"null with cond expr lhs\" } */\n+  func1(i1 ? (i2 ? cp1 : NULL) : cp2, cp3, i3); /* { dg-warning \"null\" \"null with nested cond expr\" } */\n+\n+  func4(NULL, cp1); /* { dg-warning \"null\" \"null with multiple attributes 1\" } */\n+  func4(cp1, NULL); /* { dg-warning \"null\" \"null with multiple attributes 2\" } */\n+}"}, {"sha": "bd36d232d38995d9176ebf4fb9936b13233a4836", "filename": "gcc/testsuite/gcc.dg/nonnull-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34c78814983ef7dcb1b6baacb335836c960ac15/gcc%2Ftestsuite%2Fgcc.dg%2Fnonnull-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34c78814983ef7dcb1b6baacb335836c960ac15/gcc%2Ftestsuite%2Fgcc.dg%2Fnonnull-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnonnull-2.c?ref=b34c78814983ef7dcb1b6baacb335836c960ac15", "patch": "@@ -0,0 +1,16 @@\n+/* Test for the invalid use of the \"nonnull\" function attribute.  */\n+/* Origin: Jason Thorpe <thorpej@wasabisystems.com> */\n+/* { dg-do compile } */\n+\n+extern void func1 () __attribute__((nonnull)); /* { dg-error \"without arguments\" } */\n+\n+extern void func2 (char *) __attribute__((nonnull(2))); /* { dg-error \"out-of-range operand\" } */\n+\n+extern void func3 (char *) __attribute__((nonnull(foo))); /* { dg-error \"invalid operand number\" } */\n+\n+extern void func4 (int) __attribute__((nonnull(1))); /* { dg-error \"references non-pointer\" } */\n+\n+void\n+foo (void)\n+{\n+}"}]}