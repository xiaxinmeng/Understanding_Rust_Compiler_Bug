{"sha": "97baacba963c06e3d0e33cde04e7e687671e60e7", "node_id": "C_kwDOANBUbNoAKDk3YmFhY2JhOTYzYzA2ZTNkMGUzM2NkZTA0ZTdlNjg3NjcxZTYwZTc", "commit": {"author": {"name": "Immad Mir", "email": "mirimmad17@gmail.com", "date": "2022-07-02T16:39:37Z"}, "committer": {"name": "Immad Mir", "email": "mirimmad17@gmail.com", "date": "2022-07-02T16:44:26Z"}, "message": "analyzer: implement five new warnings for misuse of POSIX file descriptor APIs [PR106003].\n\nThis patch adds a new state machine to the analyzer for checking usage of POSIX file descriptor\nAPIs with five new warnings.\n\nIt adds:\n- check for FD leaks (CWE 775).\n- check for double \"close\" of a FD (CWE-1341).\n- check for read/write of a closed file descriptor.\n- check whether a file descriptor was used without being checked for validity.\n- check for read/write of a descriptor opened for just writing/reading.\n\ngcc/ChangeLog:\n\tPR analyzer/106003\n\t* Makefile.in (ANALYZER_OBJS): Add sm-fd.o.\n\t* doc/invoke.texi:  Add -Wanalyzer-fd-double-close, -Wanalyzer-fd-leak,\n\t-Wanalyzer-fd-access-mode-mismatch, -Wanalyzer-fd-use-without-check,\n\t-Wanalyzer-fd-use-after-close.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/106003\n\t* analyzer.opt (Wanalyzer-fd-leak): New option.\n\t(Wanalyzer-fd-access-mode-mismatch): New option.\n\t(Wanalyzer-fd-use-without-check): New option.\n\t(Wanalyzer-fd-double-close): New option.\n\t(Wanalyzer-fd-use-after-close): New option.\n\t* sm.h (make_fd_state_machine): New decl.\n\t* sm.cc (make_checkers): Call make_fd_state_machine.\n\t* sm-fd.cc: New file.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/106003\n\t* gcc.dg/analyzer/fd-1.c: New test.\n\t* gcc.dg/analyzer/fd-2.c: New test.\n\t* gcc.dg/analyzer/fd-3.c: New test.\n\t* gcc.dg/analyzer/fd-4.c: New test.", "tree": {"sha": "d6ffcc9ecb70cc37ca2f55e11834ff8b942f1edd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6ffcc9ecb70cc37ca2f55e11834ff8b942f1edd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97baacba963c06e3d0e33cde04e7e687671e60e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97baacba963c06e3d0e33cde04e7e687671e60e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97baacba963c06e3d0e33cde04e7e687671e60e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97baacba963c06e3d0e33cde04e7e687671e60e7/comments", "author": {"login": "mirimmad", "id": 18097348, "node_id": "MDQ6VXNlcjE4MDk3MzQ4", "avatar_url": "https://avatars.githubusercontent.com/u/18097348?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mirimmad", "html_url": "https://github.com/mirimmad", "followers_url": "https://api.github.com/users/mirimmad/followers", "following_url": "https://api.github.com/users/mirimmad/following{/other_user}", "gists_url": "https://api.github.com/users/mirimmad/gists{/gist_id}", "starred_url": "https://api.github.com/users/mirimmad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mirimmad/subscriptions", "organizations_url": "https://api.github.com/users/mirimmad/orgs", "repos_url": "https://api.github.com/users/mirimmad/repos", "events_url": "https://api.github.com/users/mirimmad/events{/privacy}", "received_events_url": "https://api.github.com/users/mirimmad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mirimmad", "id": 18097348, "node_id": "MDQ6VXNlcjE4MDk3MzQ4", "avatar_url": "https://avatars.githubusercontent.com/u/18097348?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mirimmad", "html_url": "https://github.com/mirimmad", "followers_url": "https://api.github.com/users/mirimmad/followers", "following_url": "https://api.github.com/users/mirimmad/following{/other_user}", "gists_url": "https://api.github.com/users/mirimmad/gists{/gist_id}", "starred_url": "https://api.github.com/users/mirimmad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mirimmad/subscriptions", "organizations_url": "https://api.github.com/users/mirimmad/orgs", "repos_url": "https://api.github.com/users/mirimmad/repos", "events_url": "https://api.github.com/users/mirimmad/events{/privacy}", "received_events_url": "https://api.github.com/users/mirimmad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed974488991256c50f151ccfb271e198072dfc4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed974488991256c50f151ccfb271e198072dfc4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed974488991256c50f151ccfb271e198072dfc4d"}], "stats": {"total": 1160, "additions": 1160, "deletions": 0}, "files": [{"sha": "69ac81a1e458cc20e3345b0e1b36d3899da48bbc", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97baacba963c06e3d0e33cde04e7e687671e60e7/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97baacba963c06e3d0e33cde04e7e687671e60e7/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=97baacba963c06e3d0e33cde04e7e687671e60e7", "patch": "@@ -1273,6 +1273,7 @@ ANALYZER_OBJS = \\\n \tanalyzer/region-model-reachability.o \\\n \tanalyzer/sm.o \\\n \tanalyzer/sm-file.o \\\n+\tanalyzer/sm-fd.o \\\n \tanalyzer/sm-malloc.o \\\n \tanalyzer/sm-pattern-test.o \\\n \tanalyzer/sm-sensitive.o \\"}, {"sha": "8ef6a6fa13cdfc13089087d688c8fea4dfc47a94", "filename": "gcc/analyzer/analyzer.opt", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97baacba963c06e3d0e33cde04e7e687671e60e7/gcc%2Fanalyzer%2Fanalyzer.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97baacba963c06e3d0e33cde04e7e687671e60e7/gcc%2Fanalyzer%2Fanalyzer.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.opt?ref=97baacba963c06e3d0e33cde04e7e687671e60e7", "patch": "@@ -66,6 +66,26 @@ Wanalyzer-exposure-through-output-file\n Common Var(warn_analyzer_exposure_through_output_file) Init(1) Warning\n Warn about code paths in which sensitive data is written to a file.\n \n+Wanalyzer-fd-access-mode-mismatch\n+Common Var(warn_analyzer_fd_mode_mismatch) Init(1) Warning\n+Warn about code paths in which read on a write-only file descriptor is attempted, or vice versa.\n+\n+Wanalyzer-fd-double-close\n+Common Var(warn_analyzer_fd_double_close) Init(1) Warning\n+Warn about code paths in which a file descriptor can be closed more than once.\n+\n+Wanalyzer-fd-leak\n+Common Var(warn_analyzer_fd_leak) Init(1) Warning\n+Warn about code paths in which a file descriptor is not closed.\n+\n+Wanalyzer-fd-use-after-close\n+Common Var(warn_analyzer_fd_use_after_close) Init(1) Warning\n+Warn about code paths in which a read or write is performed on a closed file descriptor.\n+\n+Wanalyzer-fd-use-without-check\n+Common Var(warn_analyzer_fd_use_without_check) Init(1) Warning\n+Warn about code paths in which a file descriptor is used without being checked for validity.\n+\n Wanalyzer-file-leak\n Common Var(warn_analyzer_file_leak) Init(1) Warning\n Warn about code paths in which a stdio FILE is not closed."}, {"sha": "4058ac53308ddf911b9549c031560bc5489e8f6b", "filename": "gcc/analyzer/sm-fd.cc", "status": "added", "additions": 847, "deletions": 0, "changes": 847, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97baacba963c06e3d0e33cde04e7e687671e60e7/gcc%2Fanalyzer%2Fsm-fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97baacba963c06e3d0e33cde04e7e687671e60e7/gcc%2Fanalyzer%2Fsm-fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-fd.cc?ref=97baacba963c06e3d0e33cde04e7e687671e60e7", "patch": "@@ -0,0 +1,847 @@\n+/* A state machine for detecting misuses of POSIX file descriptor APIs.\r\n+   Copyright (C) 2019-2022 Free Software Foundation, Inc.\r\n+   Contributed by Immad Mir <mir@sourceware.org>.\r\n+\r\n+This file is part of GCC.\r\n+\r\n+GCC is free software; you can redistribute it and/or modify it\r\n+under the terms of the GNU General Public License as published by\r\n+the Free Software Foundation; either version 3, or (at your option)\r\n+any later version.\r\n+\r\n+GCC is distributed in the hope that it will be useful, but\r\n+WITHOUT ANY WARRANTY; without even the implied warranty of\r\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n+General Public License for more details.\r\n+\r\n+You should have received a copy of the GNU General Public License\r\n+along with GCC; see the file COPYING3.  If not see\r\n+<http://www.gnu.org/licenses/>.  */\r\n+\r\n+#include \"config.h\"\r\n+#include \"system.h\"\r\n+#include \"coretypes.h\"\r\n+#include \"tree.h\"\r\n+#include \"function.h\"\r\n+#include \"basic-block.h\"\r\n+#include \"gimple.h\"\r\n+#include \"options.h\"\r\n+#include \"diagnostic-path.h\"\r\n+#include \"diagnostic-metadata.h\"\r\n+#include \"function.h\"\r\n+#include \"json.h\"\r\n+#include \"analyzer/analyzer.h\"\r\n+#include \"diagnostic-event-id.h\"\r\n+#include \"analyzer/analyzer-logging.h\"\r\n+#include \"analyzer/sm.h\"\r\n+#include \"analyzer/pending-diagnostic.h\"\r\n+#include \"analyzer/function-set.h\"\r\n+#include \"analyzer/analyzer-selftests.h\"\r\n+#include \"tristate.h\"\r\n+#include \"selftest.h\"\r\n+#include \"analyzer/call-string.h\"\r\n+#include \"analyzer/program-point.h\"\r\n+#include \"analyzer/store.h\"\r\n+#include \"analyzer/region-model.h\"\r\n+\r\n+#if ENABLE_ANALYZER\r\n+\r\n+namespace ana {\r\n+\r\n+namespace {\r\n+\r\n+/* An enum for distinguishing between three different access modes. */\r\n+\r\n+enum access_mode\r\n+{\r\n+  READ_WRITE,\r\n+  READ_ONLY,\r\n+  WRITE_ONLY\r\n+};\r\n+\r\n+class fd_state_machine : public state_machine\r\n+{\r\n+public:\r\n+  fd_state_machine (logger *logger);\r\n+\r\n+  bool\r\n+  inherited_state_p () const final override\r\n+  {\r\n+    return false;\r\n+  }\r\n+\r\n+  state_machine::state_t\r\n+  get_default_state (const svalue *sval) const final override\r\n+  {\r\n+    if (tree cst = sval->maybe_get_constant ())\r\n+      {\r\n+        if (TREE_CODE (cst) == INTEGER_CST)\r\n+          {\r\n+            int val = TREE_INT_CST_LOW (cst);\r\n+            if (val >= 0)\r\n+              return m_constant_fd;\r\n+            else\r\n+              return m_invalid;\r\n+          }\r\n+      }\r\n+    return m_start;\r\n+  }\r\n+\r\n+  bool on_stmt (sm_context *sm_ctxt, const supernode *node,\r\n+                const gimple *stmt) const final override;\r\n+\r\n+  void on_condition (sm_context *sm_ctxt, const supernode *node,\r\n+                     const gimple *stmt, const svalue *lhs, const tree_code op,\r\n+                     const svalue *rhs) const final override;\r\n+\r\n+  bool can_purge_p (state_t s) const final override;\r\n+  pending_diagnostic *on_leak (tree var) const final override;\r\n+\r\n+  bool is_unchecked_fd_p (state_t s) const;\r\n+  bool is_valid_fd_p (state_t s) const;\r\n+  bool is_closed_fd_p (state_t s) const;\r\n+  bool is_constant_fd_p (state_t s) const;\r\n+  bool is_readonly_fd_p (state_t s) const;\r\n+  bool is_writeonly_fd_p (state_t s) const;\r\n+  enum access_mode get_access_mode_from_flag (int flag) const;\r\n+\r\n+  /* State for a constant file descriptor (>= 0) */\r\n+  state_t m_constant_fd;\r\n+\r\n+  /* States representing a file descriptor that hasn't yet been\r\n+    checked for validity after opening, for three different\r\n+    access modes.  */\r\n+  state_t m_unchecked_read_write;\r\n+\r\n+  state_t m_unchecked_read_only;\r\n+\r\n+  state_t m_unchecked_write_only;\r\n+\r\n+  /* States for representing a file descriptor that is known to be valid (>=\r\n+    0), for three different access modes.*/\r\n+  state_t m_valid_read_write;\r\n+\r\n+  state_t m_valid_read_only;\r\n+\r\n+  state_t m_valid_write_only;\r\n+\r\n+  /* State for a file descriptor that is known to be invalid (< 0). */\r\n+  state_t m_invalid;\r\n+\r\n+  /* State for a file descriptor that has been closed.*/\r\n+  state_t m_closed;\r\n+\r\n+  /* State for a file descriptor that we do not want to track anymore . */\r\n+  state_t m_stop;\r\n+\r\n+private:\r\n+  void on_open (sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\r\n+                const gcall *call) const;\r\n+  void on_close (sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\r\n+                 const gcall *call) const;\r\n+  void on_read (sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\r\n+                const gcall *call, const tree callee_fndecl) const;\r\n+  void on_write (sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\r\n+                 const gcall *call, const tree callee_fndecl) const;\r\n+  void check_for_open_fd (sm_context *sm_ctxt, const supernode *node,\r\n+                          const gimple *stmt, const gcall *call,\r\n+                          const tree callee_fndecl,\r\n+                          enum access_direction access_fn) const;\r\n+\r\n+  void make_valid_transitions_on_condition (sm_context *sm_ctxt,\r\n+                                            const supernode *node,\r\n+                                            const gimple *stmt,\r\n+                                            const svalue *lhs) const;\r\n+  void make_invalid_transitions_on_condition (sm_context *sm_ctxt,\r\n+                                              const supernode *node,\r\n+                                              const gimple *stmt,\r\n+                                              const svalue *lhs) const;\r\n+};\r\n+\r\n+/* Base diagnostic class relative to fd_state_machine. */\r\n+class fd_diagnostic : public pending_diagnostic\r\n+{\r\n+public:\r\n+  fd_diagnostic (const fd_state_machine &sm, tree arg) : m_sm (sm), m_arg (arg)\r\n+  {\r\n+  }\r\n+\r\n+  bool\r\n+  subclass_equal_p (const pending_diagnostic &base_other) const override\r\n+  {\r\n+    return same_tree_p (m_arg, ((const fd_diagnostic &)base_other).m_arg);\r\n+  }\r\n+\r\n+  label_text\r\n+  describe_state_change (const evdesc::state_change &change) override\r\n+  {\r\n+    if (change.m_old_state == m_sm.get_start_state ()\r\n+        && m_sm.is_unchecked_fd_p (change.m_new_state))\r\n+      {\r\n+        if (change.m_new_state == m_sm.m_unchecked_read_write)\r\n+          return change.formatted_print (\"opened here as read-write\");\r\n+\r\n+        if (change.m_new_state == m_sm.m_unchecked_read_only)\r\n+          return change.formatted_print (\"opened here as read-only\");\r\n+\r\n+        if (change.m_new_state == m_sm.m_unchecked_write_only)\r\n+          return change.formatted_print (\"opened here as write-only\");\r\n+      }\r\n+\r\n+    if (change.m_new_state == m_sm.m_closed)\r\n+      return change.formatted_print (\"closed here\");\r\n+\r\n+    if (m_sm.is_unchecked_fd_p (change.m_old_state)\r\n+        && m_sm.is_valid_fd_p (change.m_new_state))\r\n+      {\r\n+        if (change.m_expr)\r\n+          return change.formatted_print (\r\n+              \"assuming %qE is a valid file descriptor (>= 0)\", change.m_expr);\r\n+        else\r\n+          return change.formatted_print (\"assuming a valid file descriptor\");\r\n+      }\r\n+\r\n+    if (m_sm.is_unchecked_fd_p (change.m_old_state)\r\n+        && change.m_new_state == m_sm.m_invalid)\r\n+      {\r\n+        if (change.m_expr)\r\n+          return change.formatted_print (\r\n+              \"assuming %qE is an invalid file descriptor (< 0)\",\r\n+              change.m_expr);\r\n+        else\r\n+          return change.formatted_print (\"assuming an invalid file descriptor\");\r\n+      }\r\n+\r\n+    return label_text ();\r\n+  }\r\n+\r\n+protected:\r\n+  const fd_state_machine &m_sm;\r\n+  tree m_arg;\r\n+};\r\n+\r\n+class fd_leak : public fd_diagnostic\r\n+{\r\n+public:\r\n+  fd_leak (const fd_state_machine &sm, tree arg) : fd_diagnostic (sm, arg) {}\r\n+\r\n+  const char *\r\n+  get_kind () const final override\r\n+  {\r\n+    return \"fd_leak\";\r\n+  }\r\n+\r\n+  int\r\n+  get_controlling_option () const final override\r\n+  {\r\n+    return OPT_Wanalyzer_fd_leak;\r\n+  }\r\n+\r\n+  bool\r\n+  emit (rich_location *rich_loc) final override\r\n+  {\r\n+    /*CWE-775: Missing Release of File Descriptor or Handle after Effective\r\n+      Lifetime\r\n+     */\r\n+    diagnostic_metadata m;\r\n+    m.add_cwe (775);\r\n+    if (m_arg)\r\n+      return warning_meta (rich_loc, m, get_controlling_option (),\r\n+                           \"leak of file descriptor %qE\", m_arg);\r\n+    else\r\n+      return warning_meta (rich_loc, m, get_controlling_option (),\r\n+                           \"leak of file descriptor\");\r\n+  }\r\n+\r\n+  label_text\r\n+  describe_state_change (const evdesc::state_change &change) final override\r\n+  {\r\n+    if (m_sm.is_unchecked_fd_p (change.m_new_state))\r\n+      {\r\n+        m_open_event = change.m_event_id;\r\n+        return label_text::borrow (\"opened here\");\r\n+      }\r\n+\r\n+    return fd_diagnostic::describe_state_change (change);\r\n+  }\r\n+\r\n+  label_text\r\n+  describe_final_event (const evdesc::final_event &ev) final override\r\n+  {\r\n+    if (m_open_event.known_p ())\r\n+      {\r\n+        if (ev.m_expr)\r\n+          return ev.formatted_print (\"%qE leaks here; was opened at %@\",\r\n+                                     ev.m_expr, &m_open_event);\r\n+        else\r\n+          return ev.formatted_print (\"leaks here; was opened at %@\",\r\n+                                     &m_open_event);\r\n+      }\r\n+    else\r\n+      {\r\n+        if (ev.m_expr)\r\n+          return ev.formatted_print (\"%qE leaks here\", ev.m_expr);\r\n+        else\r\n+          return ev.formatted_print (\"leaks here\");\r\n+      }\r\n+  }\r\n+\r\n+private:\r\n+  diagnostic_event_id_t m_open_event;\r\n+};\r\n+\r\n+class fd_access_mode_mismatch : public fd_diagnostic\r\n+{\r\n+public:\r\n+  fd_access_mode_mismatch (const fd_state_machine &sm, tree arg,\r\n+                           enum access_direction fd_dir,\r\n+                           const tree callee_fndecl)\r\n+      : fd_diagnostic (sm, arg), m_fd_dir (fd_dir),\r\n+        m_callee_fndecl (callee_fndecl)\r\n+\r\n+  {\r\n+  }\r\n+\r\n+  const char *\r\n+  get_kind () const final override\r\n+  {\r\n+    return \"fd_access_mode_mismatch\";\r\n+  }\r\n+\r\n+  int\r\n+  get_controlling_option () const final override\r\n+  {\r\n+    return OPT_Wanalyzer_fd_access_mode_mismatch;\r\n+  }\r\n+\r\n+  bool\r\n+  emit (rich_location *rich_loc) final override\r\n+  {\r\n+    switch (m_fd_dir)\r\n+      {\r\n+      case DIR_READ:\r\n+        return warning_at (rich_loc, get_controlling_option (),\r\n+                           \"%qE on %<read-only%> file descriptor %qE\",\r\n+                           m_callee_fndecl, m_arg);\r\n+      case DIR_WRITE:\r\n+        return warning_at (rich_loc, get_controlling_option (),\r\n+                           \"%qE on %<write-only%> file descriptor %qE\",\r\n+                           m_callee_fndecl, m_arg);\r\n+      default:\r\n+        gcc_unreachable ();\r\n+      }\r\n+  }\r\n+\r\n+  bool\r\n+  subclass_equal_p (const pending_diagnostic &base_other) const override\r\n+  {\r\n+    const fd_access_mode_mismatch &sub_other\r\n+        = (const fd_access_mode_mismatch &)base_other;\r\n+    return (same_tree_p (m_arg, sub_other.m_arg)\r\n+            && m_callee_fndecl == sub_other.m_callee_fndecl\r\n+            && m_fd_dir == sub_other.m_fd_dir);\r\n+  }\r\n+\r\n+  label_text\r\n+  describe_final_event (const evdesc::final_event &ev) final override\r\n+  {\r\n+    switch (m_fd_dir)\r\n+      {\r\n+      case DIR_READ:\r\n+        return ev.formatted_print (\"%qE on %<read-only%> file descriptor %qE\",\r\n+                                   m_callee_fndecl, m_arg);\r\n+      case DIR_WRITE:\r\n+        return ev.formatted_print (\"%qE on %<write-only%> file descriptor %qE\",\r\n+                                   m_callee_fndecl, m_arg);\r\n+      default:\r\n+        gcc_unreachable ();\r\n+      }\r\n+  }\r\n+\r\n+private:\r\n+  enum access_direction m_fd_dir;\r\n+  const tree m_callee_fndecl;\r\n+};\r\n+\r\n+class double_close : public fd_diagnostic\r\n+{\r\n+public:\r\n+  double_close (const fd_state_machine &sm, tree arg) : fd_diagnostic (sm, arg)\r\n+  {\r\n+  }\r\n+\r\n+  const char *\r\n+  get_kind () const final override\r\n+  {\r\n+    return \"double_close\";\r\n+  }\r\n+\r\n+  int\r\n+  get_controlling_option () const final override\r\n+  {\r\n+    return OPT_Wanalyzer_fd_double_close;\r\n+  }\r\n+  bool\r\n+  emit (rich_location *rich_loc) final override\r\n+  {\r\n+    diagnostic_metadata m;\r\n+    // CWE-1341: Multiple Releases of Same Resource or Handle\r\n+    m.add_cwe (1341);\r\n+    return warning_meta (rich_loc, m, get_controlling_option (),\r\n+                         \"double %<close%> of file descriptor %qE\", m_arg);\r\n+  }\r\n+\r\n+  label_text\r\n+  describe_state_change (const evdesc::state_change &change) override\r\n+  {\r\n+    if (m_sm.is_unchecked_fd_p (change.m_new_state))\r\n+      return label_text::borrow (\"opened here\");\r\n+\r\n+    if (change.m_new_state == m_sm.m_closed)\r\n+      {\r\n+        m_first_close_event = change.m_event_id;\r\n+        return change.formatted_print (\"first %qs here\", \"close\");\r\n+      }\r\n+    return fd_diagnostic::describe_state_change (change);\r\n+  }\r\n+\r\n+  label_text\r\n+  describe_final_event (const evdesc::final_event &ev) final override\r\n+  {\r\n+    if (m_first_close_event.known_p ())\r\n+      return ev.formatted_print (\"second %qs here; first %qs was at %@\",\r\n+                                 \"close\", \"close\", &m_first_close_event);\r\n+    return ev.formatted_print (\"second %qs here\", \"close\");\r\n+  }\r\n+\r\n+private:\r\n+  diagnostic_event_id_t m_first_close_event;\r\n+};\r\n+\r\n+class fd_use_after_close : public fd_diagnostic\r\n+{\r\n+public:\r\n+  fd_use_after_close (const fd_state_machine &sm, tree arg,\r\n+                      const tree callee_fndecl)\r\n+      : fd_diagnostic (sm, arg), m_callee_fndecl (callee_fndecl)\r\n+  {\r\n+  }\r\n+\r\n+  const char *\r\n+  get_kind () const final override\r\n+  {\r\n+    return \"fd_use_after_close\";\r\n+  }\r\n+\r\n+  int\r\n+  get_controlling_option () const final override\r\n+  {\r\n+    return OPT_Wanalyzer_fd_use_after_close;\r\n+  }\r\n+\r\n+  bool\r\n+  emit (rich_location *rich_loc) final override\r\n+  {\r\n+    return warning_at (rich_loc, get_controlling_option (),\r\n+                       \"%qE on closed file descriptor %qE\", m_callee_fndecl,\r\n+                       m_arg);\r\n+  }\r\n+\r\n+  label_text\r\n+  describe_state_change (const evdesc::state_change &change) override\r\n+  {\r\n+    if (m_sm.is_unchecked_fd_p (change.m_new_state))\r\n+      return label_text::borrow (\"opened here\");\r\n+\r\n+    if (change.m_new_state == m_sm.m_closed)\r\n+      return change.formatted_print (\"closed here\");\r\n+\r\n+    return fd_diagnostic::describe_state_change (change);\r\n+  }\r\n+\r\n+  label_text\r\n+  describe_final_event (const evdesc::final_event &ev) final override\r\n+  {\r\n+    return ev.formatted_print (\"%qE on closed file descriptor %qE here\",\r\n+                               m_callee_fndecl, m_arg);\r\n+  }\r\n+\r\n+private:\r\n+  const tree m_callee_fndecl;\r\n+};\r\n+\r\n+class unchecked_use_of_fd : public fd_diagnostic\r\n+{\r\n+public:\r\n+  unchecked_use_of_fd (const fd_state_machine &sm, tree arg,\r\n+                       const tree callee_fndecl)\r\n+      : fd_diagnostic (sm, arg), m_callee_fndecl (callee_fndecl)\r\n+  {\r\n+  }\r\n+\r\n+  const char *\r\n+  get_kind () const final override\r\n+  {\r\n+    return \"unchecked_use_of_fd\";\r\n+  }\r\n+\r\n+  int\r\n+  get_controlling_option () const final override\r\n+  {\r\n+    return OPT_Wanalyzer_fd_use_without_check;\r\n+  }\r\n+\r\n+  bool\r\n+  emit (rich_location *rich_loc) final override\r\n+  {\r\n+    return warning_at (rich_loc, get_controlling_option (),\r\n+                       \"%qE on possibly invalid file descriptor %qE\",\r\n+                       m_callee_fndecl, m_arg);\r\n+  }\r\n+\r\n+  bool\r\n+  subclass_equal_p (const pending_diagnostic &base_other) const override\r\n+  {\r\n+    const unchecked_use_of_fd &sub_other\r\n+        = (const unchecked_use_of_fd &)base_other;\r\n+    return (same_tree_p (m_arg, sub_other.m_arg)\r\n+            && m_callee_fndecl == sub_other.m_callee_fndecl);\r\n+  }\r\n+\r\n+  label_text\r\n+  describe_state_change (const evdesc::state_change &change) override\r\n+  {\r\n+    if (m_sm.is_unchecked_fd_p (change.m_new_state))\r\n+      {\r\n+        m_first_open_event = change.m_event_id;\r\n+        return label_text::borrow (\"opened here\");\r\n+      }\r\n+\r\n+    return fd_diagnostic::describe_state_change (change);\r\n+  }\r\n+\r\n+  label_text\r\n+  describe_final_event (const evdesc::final_event &ev) final override\r\n+  {\r\n+    if (m_first_open_event.known_p ())\r\n+      return ev.formatted_print (\r\n+          \"%qE could be invalid: unchecked value from %@\", m_arg,\r\n+          &m_first_open_event);\r\n+    else\r\n+      return ev.formatted_print (\"%qE could be invalid\", m_arg);\r\n+  }\r\n+\r\n+private:\r\n+  diagnostic_event_id_t m_first_open_event;\r\n+  const tree m_callee_fndecl;\r\n+};\r\n+\r\n+fd_state_machine::fd_state_machine (logger *logger)\r\n+    : state_machine (\"file-descriptor\", logger),\r\n+      m_constant_fd (add_state (\"fd-constant\")),\r\n+      m_unchecked_read_write (add_state (\"fd-unchecked-read-write\")),\r\n+      m_unchecked_read_only (add_state (\"fd-unchecked-read-only\")),\r\n+      m_unchecked_write_only (add_state (\"fd-unchecked-write-only\")),\r\n+      m_invalid (add_state (\"fd-invalid\")),\r\n+      m_valid_read_write (add_state (\"fd-valid-read-write\")),\r\n+      m_valid_read_only (add_state (\"fd-valid-read-only\")),\r\n+      m_valid_write_only (add_state (\"fd-valid-write-only\")),\r\n+      m_closed (add_state (\"fd-closed\")), m_stop (add_state (\"fd-stop\"))\r\n+{\r\n+}\r\n+\r\n+bool\r\n+fd_state_machine::is_unchecked_fd_p (state_t s) const\r\n+{\r\n+  return (s == m_unchecked_read_write\r\n+       || s == m_unchecked_read_only\r\n+       || s == m_unchecked_write_only);\r\n+}\r\n+\r\n+bool\r\n+fd_state_machine::is_valid_fd_p (state_t s) const\r\n+{\r\n+  return (s == m_valid_read_write\r\n+       || s == m_valid_read_only\r\n+       || s == m_valid_write_only);\r\n+}\r\n+\r\n+enum access_mode\r\n+fd_state_machine::get_access_mode_from_flag (int flag) const\r\n+{\r\n+  /* FIXME: this code assumes the access modes on the host and\r\n+          target are the same, which in practice might not be the case. */\r\n+\r\n+  if ((flag & O_ACCMODE) == O_RDONLY)\r\n+    {\r\n+      return READ_ONLY;\r\n+    }\r\n+  else if ((flag & O_ACCMODE) == O_WRONLY)\r\n+    {\r\n+      return WRITE_ONLY;\r\n+    }\r\n+  return READ_WRITE;\r\n+}\r\n+\r\n+bool\r\n+fd_state_machine::is_readonly_fd_p (state_t state) const\r\n+{\r\n+  return (state == m_unchecked_read_only || state == m_valid_read_only);\r\n+}\r\n+\r\n+bool\r\n+fd_state_machine::is_writeonly_fd_p (state_t state) const\r\n+{\r\n+  return (state == m_unchecked_write_only || state == m_valid_write_only);\r\n+}\r\n+\r\n+bool\r\n+fd_state_machine::is_closed_fd_p (state_t state) const\r\n+{\r\n+  return (state == m_closed);\r\n+}\r\n+\r\n+bool\r\n+fd_state_machine::is_constant_fd_p (state_t state) const\r\n+{\r\n+  return (state == m_constant_fd);\r\n+}\r\n+\r\n+bool\r\n+fd_state_machine::on_stmt (sm_context *sm_ctxt, const supernode *node,\r\n+                           const gimple *stmt) const\r\n+{\r\n+  if (const gcall *call = dyn_cast<const gcall *> (stmt))\r\n+    if (tree callee_fndecl = sm_ctxt->get_fndecl_for_call (call))\r\n+      {\r\n+        if (is_named_call_p (callee_fndecl, \"open\", call, 2))\r\n+          {\r\n+            on_open (sm_ctxt, node, stmt, call);\r\n+            return true;\r\n+          } //  \"open\"\r\n+\r\n+        if (is_named_call_p (callee_fndecl, \"close\", call, 1))\r\n+          {\r\n+            on_close (sm_ctxt, node, stmt, call);\r\n+            return true;\r\n+          } //  \"close\"\r\n+\r\n+        if (is_named_call_p (callee_fndecl, \"write\", call, 3))\r\n+          {\r\n+            on_write (sm_ctxt, node, stmt, call, callee_fndecl);\r\n+            return true;\r\n+          } // \"write\"\r\n+\r\n+        if (is_named_call_p (callee_fndecl, \"read\", call, 3))\r\n+          {\r\n+            on_read (sm_ctxt, node, stmt, call, callee_fndecl);\r\n+            return true;\r\n+          } // \"read\"\r\n+      }\r\n+\r\n+  return false;\r\n+}\r\n+\r\n+void\r\n+fd_state_machine::on_open (sm_context *sm_ctxt, const supernode *node,\r\n+                           const gimple *stmt, const gcall *call) const\r\n+{\r\n+  tree lhs = gimple_call_lhs (call);\r\n+  if (lhs)\r\n+    {\r\n+      tree arg = gimple_call_arg (call, 1);\r\n+      if (TREE_CODE (arg) == INTEGER_CST)\r\n+        {\r\n+          int flag = TREE_INT_CST_LOW (arg);\r\n+          enum access_mode mode = get_access_mode_from_flag (flag);\r\n+\r\n+          switch (mode)\r\n+            {\r\n+            case READ_ONLY:\r\n+              sm_ctxt->on_transition (node, stmt, lhs, m_start,\r\n+                                      m_unchecked_read_only);\r\n+              break;\r\n+            case WRITE_ONLY:\r\n+              sm_ctxt->on_transition (node, stmt, lhs, m_start,\r\n+                                      m_unchecked_write_only);\r\n+              break;\r\n+            default:\r\n+              sm_ctxt->on_transition (node, stmt, lhs, m_start,\r\n+                                      m_unchecked_read_write);\r\n+            }\r\n+        }\r\n+    }\r\n+  else\r\n+    {\r\n+      sm_ctxt->warn (node, stmt, NULL_TREE, new fd_leak (*this, NULL_TREE));\r\n+    }\r\n+}\r\n+\r\n+void\r\n+fd_state_machine::on_close (sm_context *sm_ctxt, const supernode *node,\r\n+                            const gimple *stmt, const gcall *call) const\r\n+{\r\n+  tree arg = gimple_call_arg (call, 0);\r\n+  state_t state = sm_ctxt->get_state (stmt, arg);\r\n+  tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\r\n+\r\n+  sm_ctxt->on_transition (node, stmt, arg, m_start, m_closed);\r\n+  sm_ctxt->on_transition (node, stmt, arg, m_unchecked_read_write, m_closed);\r\n+  sm_ctxt->on_transition (node, stmt, arg, m_unchecked_read_only, m_closed);\r\n+  sm_ctxt->on_transition (node, stmt, arg, m_unchecked_write_only, m_closed);\r\n+  sm_ctxt->on_transition (node, stmt, arg, m_valid_read_write, m_closed);\r\n+  sm_ctxt->on_transition (node, stmt, arg, m_valid_read_only, m_closed);\r\n+  sm_ctxt->on_transition (node, stmt, arg, m_valid_write_only, m_closed);\r\n+  sm_ctxt->on_transition (node, stmt, arg, m_constant_fd, m_closed);\r\n+\r\n+  if (is_closed_fd_p (state))\r\n+    {\r\n+      sm_ctxt->warn (node, stmt, arg, new double_close (*this, diag_arg));\r\n+      sm_ctxt->set_next_state (stmt, arg, m_stop);\r\n+    }\r\n+}\r\n+void\r\n+fd_state_machine::on_read (sm_context *sm_ctxt, const supernode *node,\r\n+                           const gimple *stmt, const gcall *call,\r\n+                           const tree callee_fndecl) const\r\n+{\r\n+  check_for_open_fd (sm_ctxt, node, stmt, call, callee_fndecl, DIR_READ);\r\n+}\r\n+void\r\n+fd_state_machine::on_write (sm_context *sm_ctxt, const supernode *node,\r\n+                            const gimple *stmt, const gcall *call,\r\n+                            const tree callee_fndecl) const\r\n+{\r\n+  check_for_open_fd (sm_ctxt, node, stmt, call, callee_fndecl, DIR_WRITE);\r\n+}\r\n+\r\n+void\r\n+fd_state_machine::check_for_open_fd (\r\n+    sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\r\n+    const gcall *call, const tree callee_fndecl,\r\n+    enum access_direction callee_fndecl_dir) const\r\n+{\r\n+  tree arg = gimple_call_arg (call, 0);\r\n+  tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\r\n+  state_t state = sm_ctxt->get_state (stmt, arg);\r\n+\r\n+  if (is_closed_fd_p (state))\r\n+    {\r\n+      sm_ctxt->warn (node, stmt, arg,\r\n+                     new fd_use_after_close (*this, diag_arg, callee_fndecl));\r\n+    }\r\n+\r\n+  else\r\n+    {\r\n+      if (!(is_valid_fd_p (state) || (state == m_stop)))\r\n+        {\r\n+          if (!is_constant_fd_p (state))\r\n+            sm_ctxt->warn (\r\n+                node, stmt, arg,\r\n+                new unchecked_use_of_fd (*this, diag_arg, callee_fndecl));\r\n+        }\r\n+      switch (callee_fndecl_dir)\r\n+        {\r\n+        case DIR_READ:\r\n+          if (is_writeonly_fd_p (state))\r\n+            {\r\n+              tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\r\n+              sm_ctxt->warn (node, stmt, arg,\r\n+                             new fd_access_mode_mismatch (\r\n+                                 *this, diag_arg, DIR_WRITE, callee_fndecl));\r\n+            }\r\n+\r\n+          break;\r\n+        case DIR_WRITE:\r\n+\r\n+          if (is_readonly_fd_p (state))\r\n+            {\r\n+              tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\r\n+              sm_ctxt->warn (node, stmt, arg,\r\n+                             new fd_access_mode_mismatch (\r\n+                                 *this, diag_arg, DIR_READ, callee_fndecl));\r\n+            }\r\n+          break;\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+void\r\n+fd_state_machine::on_condition (sm_context *sm_ctxt, const supernode *node,\r\n+                                const gimple *stmt, const svalue *lhs,\r\n+                                enum tree_code op, const svalue *rhs) const\r\n+{\r\n+  if (tree cst = rhs->maybe_get_constant ())\r\n+    {\r\n+      if (TREE_CODE (cst) == INTEGER_CST)\r\n+        {\r\n+          int val = TREE_INT_CST_LOW (cst);\r\n+          if (val == -1)\r\n+            {\r\n+              if (op == NE_EXPR)\r\n+                make_valid_transitions_on_condition (sm_ctxt, node, stmt, lhs);\r\n+\r\n+              else if (op == EQ_EXPR)\r\n+                make_invalid_transitions_on_condition (sm_ctxt, node, stmt,\r\n+                                                       lhs);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+  if (rhs->all_zeroes_p ())\r\n+    {\r\n+      if (op == GE_EXPR)\r\n+        make_valid_transitions_on_condition (sm_ctxt, node, stmt, lhs);\r\n+      else if (op == LT_EXPR)\r\n+        make_invalid_transitions_on_condition (sm_ctxt, node, stmt, lhs);\r\n+    }\r\n+}\r\n+\r\n+void\r\n+fd_state_machine::make_valid_transitions_on_condition (sm_context *sm_ctxt,\r\n+                                                       const supernode *node,\r\n+                                                       const gimple *stmt,\r\n+                                                       const svalue *lhs) const\r\n+{\r\n+  sm_ctxt->on_transition (node, stmt, lhs, m_unchecked_read_write,\r\n+                          m_valid_read_write);\r\n+  sm_ctxt->on_transition (node, stmt, lhs, m_unchecked_read_only,\r\n+                          m_valid_read_only);\r\n+  sm_ctxt->on_transition (node, stmt, lhs, m_unchecked_write_only,\r\n+                          m_valid_write_only);\r\n+}\r\n+\r\n+void\r\n+fd_state_machine::make_invalid_transitions_on_condition (\r\n+    sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\r\n+    const svalue *lhs) const\r\n+{\r\n+  sm_ctxt->on_transition (node, stmt, lhs, m_unchecked_read_write, m_invalid);\r\n+  sm_ctxt->on_transition (node, stmt, lhs, m_unchecked_read_only, m_invalid);\r\n+  sm_ctxt->on_transition (node, stmt, lhs, m_unchecked_write_only, m_invalid);\r\n+}\r\n+\r\n+bool\r\n+fd_state_machine::can_purge_p (state_t s) const\r\n+{\r\n+  if (is_unchecked_fd_p (s) || is_valid_fd_p (s))\r\n+    return false;\r\n+  else\r\n+    return true;\r\n+}\r\n+\r\n+pending_diagnostic *\r\n+fd_state_machine::on_leak (tree var) const\r\n+{\r\n+  return new fd_leak (*this, var);\r\n+}\r\n+} // namespace\r\n+\r\n+state_machine *\r\n+make_fd_state_machine (logger *logger)\r\n+{\r\n+  return new fd_state_machine (logger);\r\n+}\r\n+} // namespace ana\r\n+\r\n+#endif // ENABLE_ANALYZER\n\\ No newline at end of file"}, {"sha": "24c20b894cdd31afd947e6a4a3bb8ec28725b576", "filename": "gcc/analyzer/sm.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97baacba963c06e3d0e33cde04e7e687671e60e7/gcc%2Fanalyzer%2Fsm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97baacba963c06e3d0e33cde04e7e687671e60e7/gcc%2Fanalyzer%2Fsm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.cc?ref=97baacba963c06e3d0e33cde04e7e687671e60e7", "patch": "@@ -167,6 +167,7 @@ make_checkers (auto_delete_vec <state_machine> &out, logger *logger)\n {\n   out.safe_push (make_malloc_state_machine (logger));\n   out.safe_push (make_fileptr_state_machine (logger));\n+  out.safe_push (make_fd_state_machine (logger));\n   /* The \"taint\" checker must be explicitly enabled (as it currently\n      leads to state explosions that stop the other checkers working).  */\n   if (flag_analyzer_checker)"}, {"sha": "e80ef1fac37748bc86abc4c8bd69f23d043f9af5", "filename": "gcc/analyzer/sm.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97baacba963c06e3d0e33cde04e7e687671e60e7/gcc%2Fanalyzer%2Fsm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97baacba963c06e3d0e33cde04e7e687671e60e7/gcc%2Fanalyzer%2Fsm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.h?ref=97baacba963c06e3d0e33cde04e7e687671e60e7", "patch": "@@ -301,6 +301,7 @@ extern state_machine *make_sensitive_state_machine (logger *logger);\n extern state_machine *make_signal_state_machine (logger *logger);\n extern state_machine *make_pattern_test_state_machine (logger *logger);\n extern state_machine *make_va_list_state_machine (logger *logger);\n+extern state_machine *make_fd_state_machine (logger *logger);\n \n } // namespace ana\n "}, {"sha": "d86e45ac98221648a636a95ce09347fa452fac50", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97baacba963c06e3d0e33cde04e7e687671e60e7/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97baacba963c06e3d0e33cde04e7e687671e60e7/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=97baacba963c06e3d0e33cde04e7e687671e60e7", "patch": "@@ -9742,6 +9742,11 @@ Enabling this option effectively enables the following warnings:\n -Wanalyzer-double-fclose @gol\n -Wanalyzer-double-free @gol\n -Wanalyzer-exposure-through-output-file @gol\n+-Wanalyzer-fd-access-mode-mismatch @gol\n+-Wanalyzer-fd-double-close @gol\n+-Wanalyzer-fd-leak @gol\n+-Wanalyzer-fd-use-after-close @gol\n+-Wanalyzer-fd-use-without-check @gol\n -Wanalyzer-file-leak @gol\n -Wanalyzer-free-of-non-heap @gol\n -Wanalyzer-malloc-leak @gol\n@@ -9816,6 +9821,56 @@ This diagnostic warns for paths through the code in which a\n security-sensitive value is written to an output file\n (such as writing a password to a log file).\n \n+@item -Wno-analyzer-fd-access-mode-mismatch\n+@opindex Wanalyzer-fd-access-mode-mismatch\n+@opindex Wno-analyzer-fd-access-mode-mismatch\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-fd-access-mode-mismatch}\n+to disable it.\n+\n+This diagnostic warns for paths through code in which a \n+@code{read} on a write-only file descriptor is attempted, or vice versa\n+\n+@item -Wno-analyzer-fd-double-close\n+@opindex Wanalyzer-fd-double-close\n+@opindex Wno-analyzer-fd-double-close\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-fd-double-close}\n+to disable it.\n+\n+This diagnostic warns for paths through code in which a \n+file descriptor can be closed more than once.\n+\n+@item -Wno-analyzer-fd-leak\n+@opindex Wanalyzer-fd-leak\n+@opindex Wno-analyzer-fd-leak\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-fd-leak}\n+to disable it.\n+\n+This diagnostic warns for paths through code in which an \n+open file descriptor is leaked.\n+\n+@item -Wno-analyzer-fd-use-after-close\n+@opindex Wanalyzer-fd-use-after-close\n+@opindex Wno-analyzer-fd-use-after-close\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-fd-use-after-close}\n+to disable it.\n+\n+This diagnostic warns for paths through code in which a \n+read or write is called on a closed file descriptor.\n+\n+@item -Wno-analyzer-fd-use-without-check\n+@opindex Wanalyzer-fd-use-without-check\n+@opindex Wno-analyzer-fd-use-without-check\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-fd-use-without-check}\n+to disable it.\n+\n+This diagnostic warns for paths through code in which a \n+file descriptor is used without being checked for validity.\n+\n @item -Wno-analyzer-file-leak\n @opindex Wanalyzer-file-leak\n @opindex Wno-analyzer-file-leak"}, {"sha": "8a72e63833ce3b2965879a37ab4eb04052e657fb", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97baacba963c06e3d0e33cde04e7e687671e60e7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97baacba963c06e3d0e33cde04e7e687671e60e7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-1.c?ref=97baacba963c06e3d0e33cde04e7e687671e60e7", "patch": "@@ -0,0 +1,39 @@\n+int open(const char *, int mode);\n+#define O_RDONLY 0\n+#define O_WRONLY 1\n+#define O_RDWR 2\n+\n+void\n+test_1 (const char *path)\n+{\n+  int fd = open (path, O_RDONLY); /* { dg-message \"\\\\(1\\\\) opened here\" } */\n+  return; /* { dg-warning \"leak of file descriptor 'fd' \\\\\\[CWE-775\\\\\\]\" \"warning\" } */\n+ /* { dg-message \"\\\\(2\\\\) 'fd' leaks here; was opened at \\\\(1\\\\)\" \"event\" { target *-*-* } .-1 } */\n+}   \n+\n+void\n+test_2 (const char *path)\n+{\n+  int fd = open (path, O_RDWR); /* { dg-message \"\\\\(1\\\\) opened here\" } */\n+  if (fd >= 0) /* { dg-message \"\\\\(2\\\\) assuming 'fd' is a valid file descriptor\" \"event1\" } */\n+  /* { dg-message \"\\\\(3\\\\) following 'true' branch \\\\(when 'fd >= 0'\\\\)...\" \"event2\" { target *-*-* } .-1 } */\n+  {\n+    return; /* { dg-warning \"leak of file descriptor 'fd' \\\\\\[CWE-775\\\\\\]\" \"warning\" } */\n+    /* { dg-message \"\\\\(4\\\\) ...to here\" \"event1\" { target *-*-* } .-1 } */\n+    /* { dg-message \"\\\\(5\\\\) 'fd' leaks here; was opened at \\\\(1\\\\)\" \"event2\" { target *-*-* } .-2 } */\n+  } \n+}\n+\n+void\n+test_3 (const char *path)\n+{\n+  int fd = open (path, O_WRONLY); /* { dg-message \"\\\\(1\\\\) opened here\" } */\n+  return; /* { dg-warning \"leak of file descriptor 'fd' \\\\\\[CWE-775\\\\\\]\" \"warning\" } */\n+}\n+\n+void test_4 (const char *path)\n+{\n+  open(path, O_RDONLY); /* { dg-warning \"leak of file descriptor \\\\\\[CWE-775\\\\\\]\" } */\n+  /* { dg-message \"\\\\(1\\\\) leaks here\" \"\" { target *-*-* } .-1 } */\n+}\n+"}, {"sha": "96ccf2f7ba82ec7ced2a18a0fa33a30ca0bff061", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-2.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97baacba963c06e3d0e33cde04e7e687671e60e7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97baacba963c06e3d0e33cde04e7e687671e60e7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-2.c?ref=97baacba963c06e3d0e33cde04e7e687671e60e7", "patch": "@@ -0,0 +1,49 @@\n+int open(const char *, int mode);\r\n+void close(int fd);\r\n+#define O_RDONLY 0\r\n+#define O_WRONLY 1\r\n+#define O_RDWR 2\r\n+#define STDIN 0\r\n+\r\n+void \r\n+test_1 (const char *path)\r\n+{\r\n+    int fd = open (path, O_RDWR); /* { dg-message \"\\\\(1\\\\) opened here\" } */\r\n+    close (fd); /* { dg-message \"\\\\(2\\\\) first 'close' here\" \"event1\" } */\r\n+    close (fd); /* { dg-warning \"double 'close' of file descriptor 'fd' \\\\\\[CWE-1341\\\\\\]\" \"warning\" } */\r\n+    /* { dg-message \"\\\\(3\\\\) second 'close' here; first 'close' was at \\\\(2\\\\)\" \"event2\" { target *-*-* } .-1 } */\r\n+}\r\n+\r\n+void \r\n+test_2 (const char *path)\r\n+{\r\n+    int fd = open (path, O_RDWR); /* { dg-message \"\\\\(1\\\\) opened here\" } */\r\n+    if (fd < 0) /* { dg-message \"\\\\(2\\\\) assuming 'fd' is a valid file descriptor \\\\(>= 0\\\\)\" \"event1\" } */\r\n+    /* { dg-message \"\\\\(3\\\\) following 'false' branch \\\\(when 'fd >= 0'\\\\)...\" \"event2\" { target *-*-* } .-1 } */\r\n+        return;\r\n+    close (fd); /* { dg-message \"\\\\(4\\\\) ...to here\" \"event1\" } */\r\n+    /* { dg-message \"\\\\(5\\\\) first 'close' here\" \"event2\" { target *-*-* } .-1 } */\r\n+    close (fd); /* { dg-warning \"double 'close' of file descriptor 'fd' \\\\\\[CWE-1341\\\\\\]\" \"warning\" } */\r\n+    /* {dg-message \"\\\\(6\\\\) second 'close' here; first was at \\\\(5\\\\)\" \"\" { target *-*-* } .-1 } */\r\n+}\r\n+\r\n+void\r\n+test_3 ()\r\n+{\r\n+    /* FD 0 is stdin at the entry to \"main\" and thus read-only, but we have no\r\n+    guarantees here that it hasn't been closed and then reopened for\r\n+    writing, so we can't issue a warning */\r\n+    \r\n+    int fd = STDIN;\r\n+    close(fd); /* { dg-message \"\\\\(1\\\\) first 'close' here\" } */\r\n+    close(fd); /* { dg-warning \"double 'close' of file descriptor 'fd' \\\\\\[CWE-1341\\\\\\]\" \"warning\" } */\r\n+     /* { dg-message \"\\\\(2\\\\) second 'close' here; first 'close' was at \\\\(1\\\\)\" \"event2\" { target *-*-* } .-1 } */\r\n+}\r\n+\r\n+void\r\n+test_4 ()\r\n+{\r\n+    int fd = -1;\r\n+    close(fd);\r\n+    close(fd);\r\n+}\n\\ No newline at end of file"}, {"sha": "40fc8af27b5a059ad08ecc9a6e15cd8f3cfe22a9", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-3.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97baacba963c06e3d0e33cde04e7e687671e60e7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97baacba963c06e3d0e33cde04e7e687671e60e7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-3.c?ref=97baacba963c06e3d0e33cde04e7e687671e60e7", "patch": "@@ -0,0 +1,85 @@\n+int open(const char *, int mode);\r\n+void close(int fd);\r\n+int write (int fd, void *buf, int nbytes);\r\n+int read (int fd, void *buf, int nbytes);\r\n+int some_condition();\r\n+\r\n+#define O_RDONLY 0\r\n+#define O_WRONLY 1\r\n+#define O_RDWR 2\r\n+#define STDIN 0\r\n+#define O_NOATIME 262144\r\n+\r\n+void\r\n+test_1 (const char *path, void *buf)\r\n+{\r\n+    int fd = open (path, O_RDWR); /* { dg-message \"\\\\(1\\\\) opened here\" } */\r\n+    write (fd, buf, 1); /* { dg-message \"\\\\(2\\\\) 'fd' could be invalid: unchecked value from \\\\(1\\\\)\" } */\r\n+    /* { dg-warning \"'write' on possibly invalid file descriptor 'fd'\" \"warning\" { target *-*-* } .-1 } */\r\n+    close(fd);\r\n+}\r\n+\r\n+void\r\n+test_2 (const char *path, void *buf)\r\n+{\r\n+    int fd = open (path, O_RDWR); /* { dg-message \"\\\\(1\\\\) opened here\" } */\r\n+    read (fd, buf, 1); /* { dg-message \"\\\\(2\\\\) 'fd' could be invalid: unchecked value from \\\\(1\\\\)\" } */\r\n+    /* { dg-warning \"'read' on possibly invalid file descriptor 'fd'\" \"warning\" { target *-*-* } .-1 } */\r\n+    close (fd);\r\n+}\r\n+\r\n+void \r\n+test_3 (void *buf)\r\n+{\r\n+    int fd = -1;\r\n+    read (fd, buf, 1); /* { dg-warning \"'read' on possibly invalid file descriptor 'fd'\" } */\r\n+    /* { dg-message \"\\\\(1\\\\) 'fd' could be invalid\" \"\" { target *-*-* } .-1 } */\r\n+}\r\n+\r\n+void\r\n+test_4 (void *buf)\r\n+{\r\n+    int fd = STDIN;\r\n+    read (fd, buf, 1);\r\n+    close(fd);\r\n+}\r\n+\r\n+void\r\n+test_5 (char *path, void *buf)\r\n+{\r\n+    int flags = O_RDONLY;\r\n+    if (some_condition())\r\n+        flags |= O_NOATIME;\r\n+    int fd = open (path, flags);\r\n+    read (fd, buf, 1); /* { dg-warning \"'read' on possibly invalid file descriptor 'fd'\" } */\r\n+    /* { dg-message \"\\\\(1\\\\) 'fd' could be invalid\" \"\" { target *-*-* } .-1 } */\r\n+    close (fd);   \r\n+}\r\n+\r\n+\r\n+void\r\n+test_6 (char *path, void *buf)\r\n+{\r\n+    int fd = open (path, O_RDONLY);\r\n+    if (fd != -1)\r\n+    {\r\n+        read (fd, buf, 1);\r\n+    }\r\n+    close (fd);\r\n+}\r\n+\r\n+\r\n+void\r\n+test_7 (char *path, void *buf)\r\n+{\r\n+    int fd = open (path, O_RDWR); /* { dg-message \"\\\\(1\\\\) opened here\" } */\r\n+    if (fd != -1) /* { dg-message \"\\\\(2\\\\) assuming 'fd' is an invalid file descriptor \\\\(< 0\\\\)\" } */\r\n+    {\r\n+        read (fd, buf, 1);\r\n+    } else\r\n+    {\r\n+        write (fd, buf, 1); /* { dg-warning \"'write' on possibly invalid file descriptor 'fd'\" } */\r\n+        \r\n+    }\r\n+    close(fd);\r\n+}\n\\ No newline at end of file"}, {"sha": "a973704f403dbccf034e2365fa268a71ca73f453", "filename": "gcc/testsuite/gcc.dg/analyzer/fd-4.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97baacba963c06e3d0e33cde04e7e687671e60e7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97baacba963c06e3d0e33cde04e7e687671e60e7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffd-4.c?ref=97baacba963c06e3d0e33cde04e7e687671e60e7", "patch": "@@ -0,0 +1,62 @@\n+int open(const char *, int mode);\r\n+void close(int fd);\r\n+int write (int fd, void *buf, int nbytes);\r\n+int read (int fd, void *buf, int nbytes);\r\n+\r\n+#define O_RDONLY 0\r\n+#define O_WRONLY 1\r\n+#define O_RDWR 2\r\n+\r\n+\r\n+void\r\n+test_1 (const char *path, void *buf)\r\n+{\r\n+    int fd = open (path, O_RDONLY); /* { dg-message \"opened here as read-only\" } */\r\n+    if (fd >= 0) /* { dg-message \"assuming 'fd' is a valid file descriptor \\\\(>= 0\\\\)\" \"event1\" } */\r\n+    /* { dg-message \"following 'true' branch \\\\(when 'fd >= 0'\\\\)...\" \"event2\" { target *-*-* } .-1 } */\r\n+    {\r\n+        write (fd, buf, 1); /* { dg-warning \"'write' on 'read-only' file descriptor 'fd'\" \"warning\" } */\r\n+        /* { dg-message \"\\\\(4\\\\) ...to here\" \"event1\" { target *-*-* } .-1 } */\r\n+        /* { dg-message \"\\\\(5\\\\) 'write' on 'read-only' file descriptor 'fd'\" \"event2\" { target *-*-* } .-2 } */\r\n+        close (fd);\r\n+    }\r\n+}\r\n+\r\n+void\r\n+test_2 (const char *path, void *buf)\r\n+{\r\n+    int fd = open (path, O_WRONLY); /* { dg-message \"opened here as write-only\" } */\r\n+    if (fd >= 0) /* { dg-message \"assuming 'fd' is a valid file descriptor \\\\(>= 0\\\\)\" \"event1\" } */\r\n+    /* { dg-message \"following 'true' branch \\\\(when 'fd >= 0'\\\\)...\" \"event2\" { target *-*-* } .-1 } */\r\n+    {\r\n+        read (fd, buf, 1); /* { dg-warning \"'read' on 'write-only' file descriptor 'fd'\" \"warning\" } */\r\n+        /* { dg-message \"\\\\(4\\\\) ...to here\" \"event1\" { target *-*-* } .-1 } */\r\n+        /* { dg-message \"\\\\(5\\\\) 'read' on 'write-only' file descriptor 'fd'\" \"event2\" { target *-*-* } .-2 } */\r\n+        close (fd);\r\n+    }\r\n+}\r\n+\r\n+\r\n+void \r\n+test_3 (const char *path, void *buf)\r\n+{\r\n+    int fd = open (path, O_RDWR); /* { dg-message \"\\\\(1\\\\) opened here\" } */\r\n+    if (fd >= 0)\r\n+    {\r\n+        close(fd); /* {dg-message \"\\\\(2\\\\) closed here\"} */\r\n+        read(fd, buf, 1); /* { dg-warning \"'read' on closed file descriptor 'fd'\" }  */\r\n+        /* {dg-message \"\\\\(3\\\\) 'read' on closed file descriptor 'fd' here\" \"\" {target *-*-*} .-1 } */\r\n+    }\r\n+}\r\n+\r\n+void \r\n+test_4 (const char *path, void *buf)\r\n+{\r\n+    int fd = open (path, O_RDWR); /* { dg-message \"\\\\(1\\\\) opened here\" } */\r\n+    if (fd >= 0)\r\n+    {\r\n+        close(fd); /* {dg-message \"\\\\(2\\\\) closed here\"} */\r\n+        write(fd, buf, 1); /* { dg-warning \"'write' on closed file descriptor 'fd'\" }  */\r\n+        /* {dg-message \"\\\\(3\\\\) 'write' on closed file descriptor 'fd' here\" \"\" {target *-*-*} .-1 } */\r\n+    }\r\n+}\r"}]}