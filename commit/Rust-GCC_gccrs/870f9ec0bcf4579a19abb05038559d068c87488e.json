{"sha": "870f9ec0bcf4579a19abb05038559d068c87488e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODcwZjllYzBiY2Y0NTc5YTE5YWJiMDUwMzg1NTlkMDY4Yzg3NDg4ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-08-11T23:10:10Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-08-11T23:10:10Z"}, "message": "ia64.c (do_spill): Pass cfa offset to move expander.\n\n        * config/ia64/ia64.c (do_spill): Pass cfa offset to move expander.\n        (do_restore): Likewise.\n        (gen_movdi_x, gen_fr_spill_x, gen_fr_restore_x): New.\n        (ia64_expand_prologue, ia64_expand_epilogue): Use them.\n        (rtx_needs_barrier): Track actual bit manipulation for\n        ar.unat moves, gr_spill, and gr_restore.\n        (emit_insn_group_barriers): Special case gr_spill/gr_restore.\n        (process_set): Don't handle varargs spills.\n        * config/ia64/ia64.md (gr_spill): Accept cfa offset.  Emit\n        .mem.offset here instead of in process_set.\n        (gr_restore): Likewise.\n\nFrom-SVN: r35648", "tree": {"sha": "493a5dd75f8f9269cb5fe74405478def2830c851", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/493a5dd75f8f9269cb5fe74405478def2830c851"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/870f9ec0bcf4579a19abb05038559d068c87488e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/870f9ec0bcf4579a19abb05038559d068c87488e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/870f9ec0bcf4579a19abb05038559d068c87488e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/870f9ec0bcf4579a19abb05038559d068c87488e/comments", "author": null, "committer": null, "parents": [{"sha": "dc329d293894ba51b1630a2d41c8e23e1478893b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc329d293894ba51b1630a2d41c8e23e1478893b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc329d293894ba51b1630a2d41c8e23e1478893b"}], "stats": {"total": 205, "additions": 133, "deletions": 72}, "files": [{"sha": "fd7d85677a2004e5db30e25bfb33e6d7e0780c45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/870f9ec0bcf4579a19abb05038559d068c87488e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/870f9ec0bcf4579a19abb05038559d068c87488e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=870f9ec0bcf4579a19abb05038559d068c87488e", "patch": "@@ -1,3 +1,17 @@\n+2000-08-11  Richard Henderson  <rth@cygnus.com>\n+\n+\t* config/ia64/ia64.c (do_spill): Pass cfa offset to move expander.\n+\t(do_restore): Likewise.\n+\t(gen_movdi_x, gen_fr_spill_x, gen_fr_restore_x): New.\n+\t(ia64_expand_prologue, ia64_expand_epilogue): Use them.\n+\t(rtx_needs_barrier): Track actual bit manipulation for \n+\tar.unat moves, gr_spill, and gr_restore.\n+\t(emit_insn_group_barriers): Special case gr_spill/gr_restore.\n+\t(process_set): Don't handle varargs spills.\n+\t* config/ia64/ia64.md (gr_spill): Accept cfa offset.  Emit\n+\t.mem.offset here instead of in process_set.\n+\t(gr_restore): Likewise.\n+\n 2000-08-11  Richard Henderson  <rth@cygnus.com>\n \n \t* config/ia64/ia64.h (PROMOTE_MODE): Only extend to SImode."}, {"sha": "f090402eda43ffa108b18ceed5e504d95351e4f4", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 99, "deletions": 54, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/870f9ec0bcf4579a19abb05038559d068c87488e/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/870f9ec0bcf4579a19abb05038559d068c87488e/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=870f9ec0bcf4579a19abb05038559d068c87488e", "patch": "@@ -103,8 +103,8 @@ static void ia64_compute_frame_size PARAMS ((HOST_WIDE_INT));\n static void setup_spill_pointers PARAMS ((int, rtx, HOST_WIDE_INT));\n static void finish_spill_pointers PARAMS ((void));\n static rtx spill_restore_mem PARAMS ((rtx, HOST_WIDE_INT));\n-static void do_spill PARAMS ((rtx (*)(rtx, rtx), rtx, HOST_WIDE_INT, rtx));\n-static void do_restore PARAMS ((rtx (*)(rtx, rtx), rtx, HOST_WIDE_INT));\n+static void do_spill PARAMS ((rtx (*)(rtx, rtx, rtx), rtx, HOST_WIDE_INT, rtx));\n+static void do_restore PARAMS ((rtx (*)(rtx, rtx, rtx), rtx, HOST_WIDE_INT));\n \n static enum machine_mode hfa_element_mode PARAMS ((tree, int));\n static void fix_range PARAMS ((const char *));\n@@ -1281,14 +1281,14 @@ spill_restore_mem (reg, cfa_off)\n \n static void\n do_spill (move_fn, reg, cfa_off, frame_reg)\n-     rtx (*move_fn) PARAMS ((rtx, rtx));\n+     rtx (*move_fn) PARAMS ((rtx, rtx, rtx));\n      rtx reg, frame_reg;\n      HOST_WIDE_INT cfa_off;\n {\n   rtx mem, insn;\n \n   mem = spill_restore_mem (reg, cfa_off);\n-  insn = emit_insn ((*move_fn) (mem, reg));\n+  insn = emit_insn ((*move_fn) (mem, reg, GEN_INT (cfa_off)));\n \n   if (frame_reg)\n     {\n@@ -1324,13 +1324,41 @@ do_spill (move_fn, reg, cfa_off, frame_reg)\n \n static void\n do_restore (move_fn, reg, cfa_off)\n-     rtx (*move_fn) PARAMS ((rtx, rtx));\n+     rtx (*move_fn) PARAMS ((rtx, rtx, rtx));\n      rtx reg;\n      HOST_WIDE_INT cfa_off;\n {\n-  emit_insn ((*move_fn) (reg, spill_restore_mem (reg, cfa_off)));\n+  emit_insn ((*move_fn) (reg, spill_restore_mem (reg, cfa_off),\n+\t\t\t GEN_INT (cfa_off)));\n }\n \n+/* Wrapper functions that discards the CONST_INT spill offset.  These\n+   exist so that we can give gr_spill/gr_fill the offset they need and\n+   use a consistant function interface.  */\n+\n+static rtx\n+gen_movdi_x (dest, src, offset)\n+     rtx dest, src;\n+     rtx offset ATTRIBUTE_UNUSED;\n+{\n+  return gen_movdi (dest, src);\n+}\n+\n+static rtx\n+gen_fr_spill_x (dest, src, offset)\n+     rtx dest, src;\n+     rtx offset ATTRIBUTE_UNUSED;\n+{\n+  return gen_fr_spill (dest, src);\n+}\n+\n+static rtx\n+gen_fr_restore_x (dest, src, offset)\n+     rtx dest, src;\n+     rtx offset ATTRIBUTE_UNUSED;\n+{\n+  return gen_fr_restore (dest, src);\n+}\n \n /* Called after register allocation to add any instructions needed for the\n    prologue.  Using a prologue insn is favored compared to putting all of the\n@@ -1532,11 +1560,7 @@ ia64_expand_prologue ()\n   for (regno = GR_ARG_FIRST + 7; n_varargs > 0; --n_varargs, --regno)\n     {\n       reg = gen_rtx_REG (DImode, regno);\n-\n-      /* ??? These aren't really \"frame related\" in the unwind sense,\n-\t but marking them so gives us the chance to emit .mem.offset\n-\t markers so that we don't get assembler WAW warnings.  */\n-      do_spill (gen_gr_spill, reg, cfa_off += 8, reg);\n+      do_spill (gen_gr_spill, reg, cfa_off += 8, NULL_RTX);\n     }\n \n   /* Locate the bottom of the register save area.  */\n@@ -1571,7 +1595,7 @@ ia64_expand_prologue ()\n \t  alt_regno = next_scratch_gr_reg ();\n \t  alt_reg = gen_rtx_REG (DImode, alt_regno);\n \t  insn = emit_move_insn (alt_reg, reg);\n-\t  do_spill (gen_movdi, alt_reg, cfa_off, reg);\n+\t  do_spill (gen_movdi_x, alt_reg, cfa_off, reg);\n \t  cfa_off -= 8;\n \t}\n     }\n@@ -1581,7 +1605,7 @@ ia64_expand_prologue ()\n       && current_frame_info.reg_save_ar_unat == 0)\n     {\n       reg = gen_rtx_REG (DImode, AR_UNAT_REGNUM);\n-      do_spill (gen_movdi, ar_unat_save_reg, cfa_off, reg);\n+      do_spill (gen_movdi_x, ar_unat_save_reg, cfa_off, reg);\n       cfa_off -= 8;\n     }\n \n@@ -1592,7 +1616,7 @@ ia64_expand_prologue ()\n       && ! current_function_is_leaf)\n     {\n       reg = gen_rtx_REG (DImode, AR_PFS_REGNUM);\n-      do_spill (gen_movdi, ar_pfs_save_reg, cfa_off, reg);\n+      do_spill (gen_movdi_x, ar_pfs_save_reg, cfa_off, reg);\n       cfa_off -= 8;\n     }\n \n@@ -1615,7 +1639,7 @@ ia64_expand_prologue ()\n \t  alt_regno = next_scratch_gr_reg ();\n \t  alt_reg = gen_rtx_REG (DImode, alt_regno);\n \t  emit_move_insn (alt_reg, reg);\n-\t  do_spill (gen_movdi, alt_reg, cfa_off, reg);\n+\t  do_spill (gen_movdi_x, alt_reg, cfa_off, reg);\n \t  cfa_off -= 8;\n \t}\n     }\n@@ -1655,7 +1679,7 @@ ia64_expand_prologue ()\n \t  alt_regno = next_scratch_gr_reg ();\n \t  alt_reg = gen_rtx_REG (DImode, alt_regno);\n \t  emit_move_insn (alt_reg, reg);\n-\t  do_spill (gen_movdi, alt_reg, cfa_off, reg);\n+\t  do_spill (gen_movdi_x, alt_reg, cfa_off, reg);\n \t  cfa_off -= 8;\n \t}\n     }\n@@ -1668,7 +1692,7 @@ ia64_expand_prologue ()\n \talt_reg = gen_rtx_REG (DImode, alt_regno);\n \treg = gen_rtx_REG (DImode, regno);\n \temit_move_insn (alt_reg, reg);\n-\tdo_spill (gen_movdi, alt_reg, cfa_off, reg);\n+\tdo_spill (gen_movdi_x, alt_reg, cfa_off, reg);\n \tcfa_off -= 8;\n       }\n \n@@ -1679,7 +1703,7 @@ ia64_expand_prologue ()\n         if (cfa_off & 15)\n \t  abort ();\n \treg = gen_rtx_REG (XFmode, regno);\n-\tdo_spill (gen_fr_spill, reg, cfa_off, reg);\n+\tdo_spill (gen_fr_spill_x, reg, cfa_off, reg);\n \tcfa_off -= 16;\n       }\n \n@@ -1736,7 +1760,7 @@ ia64_expand_epilogue ()\n \t{\n \t  alt_regno = next_scratch_gr_reg ();\n \t  alt_reg = gen_rtx_REG (DImode, alt_regno);\n-\t  do_restore (gen_movdi, alt_reg, cfa_off);\n+\t  do_restore (gen_movdi_x, alt_reg, cfa_off);\n \t  cfa_off -= 8;\n \t}\n       reg = gen_rtx_REG (DImode, PR_REG (0));\n@@ -1757,7 +1781,7 @@ ia64_expand_epilogue ()\n \t  alt_regno = next_scratch_gr_reg ();\n \t  ar_unat_save_reg = gen_rtx_REG (DImode, alt_regno);\n \t  current_frame_info.gr_used_mask |= 1 << alt_regno;\n-\t  do_restore (gen_movdi, ar_unat_save_reg, cfa_off);\n+\t  do_restore (gen_movdi_x, ar_unat_save_reg, cfa_off);\n \t  cfa_off -= 8;\n \t}\n     }\n@@ -1774,7 +1798,7 @@ ia64_expand_epilogue ()\n     {\n       alt_regno = next_scratch_gr_reg ();\n       alt_reg = gen_rtx_REG (DImode, alt_regno);\n-      do_restore (gen_movdi, alt_reg, cfa_off);\n+      do_restore (gen_movdi_x, alt_reg, cfa_off);\n       cfa_off -= 8;\n       reg = gen_rtx_REG (DImode, AR_PFS_REGNUM);\n       emit_move_insn (reg, alt_reg);\n@@ -1788,7 +1812,7 @@ ia64_expand_epilogue ()\n \t{\n \t  alt_regno = next_scratch_gr_reg ();\n \t  alt_reg = gen_rtx_REG (DImode, alt_regno);\n-\t  do_restore (gen_movdi, alt_reg, cfa_off);\n+\t  do_restore (gen_movdi_x, alt_reg, cfa_off);\n \t  cfa_off -= 8;\n \t}\n       reg = gen_rtx_REG (DImode, AR_LC_REGNUM);\n@@ -1819,7 +1843,7 @@ ia64_expand_epilogue ()\n \t{\n \t  alt_regno = next_scratch_gr_reg ();\n \t  alt_reg = gen_rtx_REG (DImode, alt_regno);\n-\t  do_restore (gen_movdi, alt_reg, cfa_off);\n+\t  do_restore (gen_movdi_x, alt_reg, cfa_off);\n \t  cfa_off -= 8;\n \t}\n       reg = gen_rtx_REG (DImode, BR_REG (0));\n@@ -1831,7 +1855,7 @@ ia64_expand_epilogue ()\n       {\n \talt_regno = next_scratch_gr_reg ();\n \talt_reg = gen_rtx_REG (DImode, alt_regno);\n-\tdo_restore (gen_movdi, alt_reg, cfa_off);\n+\tdo_restore (gen_movdi_x, alt_reg, cfa_off);\n \tcfa_off -= 8;\n \treg = gen_rtx_REG (DImode, regno);\n \temit_move_insn (reg, alt_reg);\n@@ -1844,7 +1868,7 @@ ia64_expand_epilogue ()\n         if (cfa_off & 15)\n \t  abort ();\n \treg = gen_rtx_REG (XFmode, regno);\n-\tdo_restore (gen_fr_restore, reg, cfa_off);\n+\tdo_restore (gen_fr_restore_x, reg, cfa_off);\n \tcfa_off -= 16;\n       }\n \n@@ -3172,7 +3196,8 @@ ia64_override_options ()\n /* This is used for volatile asms which may require a stop bit immediately\n    before and after them.  */\n #define REG_VOLATILE\t(FIRST_PSEUDO_REGISTER + 2)\n-#define NUM_REGS\t(FIRST_PSEUDO_REGISTER + 3)\n+#define AR_UNAT_BIT_0\t(FIRST_PSEUDO_REGISTER + 3)\n+#define NUM_REGS\t(AR_UNAT_BIT_0 + 64)\n \n /* For each register, we keep track of how many times it has been\n    written in the current instruction group.  If a register is written\n@@ -3545,7 +3570,13 @@ rtx_needs_barrier (x, flags, pred)\n       x = SUBREG_REG (x);\n       /* FALLTHRU */\n     case REG:\n-      need_barrier = rws_access_reg (x, flags, pred);\n+      if (REGNO (x) == AR_UNAT_REGNUM)\n+\t{\n+\t  for (i = 0; i < 64; ++i)\n+\t    need_barrier |= rws_access_regno (AR_UNAT_BIT_0 + i, flags, pred);\n+\t}\n+      else\n+\tneed_barrier = rws_access_reg (x, flags, pred);\n       break;\n \n     case MEM:\n@@ -3601,11 +3632,19 @@ rtx_needs_barrier (x, flags, pred)\n     case UNSPEC:\n       switch (XINT (x, 1))\n \t{\n-\t  /* ??? For the st8.spill/ld8.fill instructions, we can ignore unat\n-\t     dependencies as long as we don't have both a spill and fill in\n-\t     the same instruction group.  We need to check for that.  */\n \tcase 1: /* st8.spill */\n \tcase 2: /* ld8.fill */\n+\t  {\n+\t    HOST_WIDE_INT offset = INTVAL (XVECEXP (x, 0, 1));\n+\t    HOST_WIDE_INT bit = (offset >> 3) & 63;\n+\n+\t    need_barrier = rtx_needs_barrier (XVECEXP (x, 0, 0), flags, pred);\n+\t    new_flags.is_write = (XINT (x, 1) == 1);\n+\t    need_barrier |= rws_access_regno (AR_UNAT_BIT_0 + bit,\n+\t\t\t\t\t      new_flags, pred);\n+\t    break;\n+\t  }\n+\t  \n \tcase 3: /* stf.spill */\n \tcase 4: /* ldf.spill */\n \tcase 8: /* popcnt */\n@@ -3773,16 +3812,36 @@ emit_insn_group_barriers (insns)\n \t    {\n \t      rtx pat = PATTERN (insn);\n \n-\t      /* We play dependency tricks with the epilogue in order to\n-\t\t get proper schedules.  Undo this for dv analysis.  */\n-\t      if (INSN_CODE (insn) == CODE_FOR_epilogue_deallocate_stack)\n-\t\tpat = XVECEXP (pat, 0, 0);\n-\n-\t      /* ??? Similarly, the pattern we use for br.cloop\n-\t\t confuses the code above.  The second element of the\n-\t\t vector is representative.  */\n-\t      else if (INSN_CODE (insn) == CODE_FOR_doloop_end_internal)\n-\t\tpat = XVECEXP (pat, 0, 1);\n+\t      /* Ug.  Hack hacks hacked elsewhere.  */\n+\t      switch (INSN_CODE (insn))\n+\t\t{\n+\t\t  /* We play dependency tricks with the epilogue in order\n+\t\t     to get proper schedules.  Undo this for dv analysis.  */\n+\t\tcase CODE_FOR_epilogue_deallocate_stack:\n+\t\t  pat = XVECEXP (pat, 0, 0);\n+\t\t  break;\n+\n+\t\t  /* The pattern we use for br.cloop confuses the code above.\n+\t\t     The second element of the vector is representative.  */\n+\t\tcase CODE_FOR_doloop_end_internal:\n+\t\t  pat = XVECEXP (pat, 0, 1);\n+\t\t  break;\n+\n+\t\t  /* We include ar.unat in the rtl pattern so that sched2\n+\t\t     does not move the ar.unat save/restore after/before\n+\t\t     a gr spill/fill.  However, we special case these\n+\t\t     insns based on their unspec number so as to model\n+\t\t     their precise ar.unat bit operations.  If we pass on\n+\t\t     the use/clobber of the whole ar.unat register we'll\n+\t\t     waste this effort.  */\n+\t\tcase CODE_FOR_gr_spill_internal:\n+\t\tcase CODE_FOR_gr_restore_internal:\n+\t\t  pat = XVECEXP (pat, 0, 0);\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n \n \t      memset (rws_insn, 0, sizeof (rws_insn));\n \t      need_barrier |= rtx_needs_barrier (pat, flags, 0);\n@@ -4235,20 +4294,6 @@ process_set (asm_out_file, pat)\n \tcase GR_REG (7):\n \t  fprintf (asm_out_file, \"\\t.save.g 0x%x\\n\",\n \t\t   1 << (src_regno - GR_REG (4)));\n-\t  /* FALLTHRU */\n-\n-\tcase GR_ARG_FIRST + 0:\n-\tcase GR_ARG_FIRST + 1:\n-\tcase GR_ARG_FIRST + 2:\n-\tcase GR_ARG_FIRST + 3:\n-\tcase GR_ARG_FIRST + 4:\n-\tcase GR_ARG_FIRST + 5:\n-\tcase GR_ARG_FIRST + 6:\n-\tcase GR_ARG_FIRST + 7:\n-\t  /* ??? These aren't really \"frame related\" in the unwind sense,\n-\t     but marking them so gives us the chance to emit .mem.offset\n-\t     markers so that we don't get assembler WAW warnings.  */\n-\t  fprintf (asm_out_file, \"\\t.mem.offset %ld, 0\\n\", off);\n \t  return 1;\n \n \tcase BR_REG (1):"}, {"sha": "1b72bfdc7fbb03dd2fe292995fc0acdd8e37ecaa", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/870f9ec0bcf4579a19abb05038559d068c87488e/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/870f9ec0bcf4579a19abb05038559d068c87488e/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=870f9ec0bcf4579a19abb05038559d068c87488e", "patch": "@@ -3435,36 +3435,38 @@\n \n ;; Modifies ar.unat\n (define_expand \"gr_spill\"\n-  [(parallel\n-     [(set (match_operand:DI 0 \"memory_operand\" \"=m\")\n-\t   (unspec:DI [(match_operand:DI 1 \"register_operand\" \"r\")] 1))\n-      (clobber (match_dup 2))])]\n+  [(parallel [(set (match_operand:DI 0 \"memory_operand\" \"=m\")\n+\t\t   (unspec:DI [(match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t       (match_operand:DI 2 \"const_int_operand\" \"\")] 1))\n+\t      (clobber (match_dup 3))])]\n   \"\"\n-  \"operands[2] = gen_rtx_REG (DImode, AR_UNAT_REGNUM);\")\n+  \"operands[3] = gen_rtx_REG (DImode, AR_UNAT_REGNUM);\")\n \n-(define_insn \"*gr_spill_internal\"\n+(define_insn \"gr_spill_internal\"\n   [(set (match_operand:DI 0 \"memory_operand\" \"=m\")\n-\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"r\")] 1))\n-   (clobber (match_operand:DI 2 \"register_operand\" \"\"))]\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t    (match_operand:DI 2 \"const_int_operand\" \"\")] 1))\n+   (clobber (match_operand:DI 3 \"register_operand\" \"\"))]\n   \"\"\n-  \"st8.spill %0 = %1%P0\"\n+  \".mem.offset %2, 0\\;st8.spill %0 = %1%P0\"\n   [(set_attr \"type\" \"M\")])\n \n ;; Reads ar.unat\n (define_expand \"gr_restore\"\n-  [(parallel\n-     [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t   (unspec:DI [(match_operand:DI 1 \"memory_operand\" \"m\")] 2))\n-      (use (match_dup 2))])]\n+  [(parallel [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t\t   (unspec:DI [(match_operand:DI 1 \"memory_operand\" \"m\")\n+\t\t\t       (match_operand:DI 2 \"const_int_operand\" \"\")] 2))\n+\t      (use (match_dup 3))])]\n   \"\"\n-  \"operands[2] = gen_rtx_REG (DImode, AR_UNAT_REGNUM);\")\n+  \"operands[3] = gen_rtx_REG (DImode, AR_UNAT_REGNUM);\")\n \n-(define_insn \"*gr_restore_internal\"\n+(define_insn \"gr_restore_internal\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(unspec:DI [(match_operand:DI 1 \"memory_operand\" \"m\")] 2))\n-   (use (match_operand:DI 2 \"register_operand\" \"\"))]\n+\t(unspec:DI [(match_operand:DI 1 \"memory_operand\" \"m\")\n+\t\t    (match_operand:DI 2 \"const_int_operand\" \"\")] 2))\n+   (use (match_operand:DI 3 \"register_operand\" \"\"))]\n   \"\"\n-  \"ld8.fill %0 = %1%P1\"\n+  \".mem.offset %2, 0\\;ld8.fill %0 = %1%P1\"\n   [(set_attr \"type\" \"M\")])\n \n (define_insn \"fr_spill\""}]}