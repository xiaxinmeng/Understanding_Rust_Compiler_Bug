{"sha": "aa9b151a9e3630f78c1517d016fa26dc3277b506", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE5YjE1MWE5ZTM2MzBmNzhjMTUxN2QwMTZmYTI2ZGMzMjc3YjUwNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-06T14:15:51Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-06T14:15:51Z"}, "message": "[multiple changes]\n\n2014-02-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Refined_Pragma): Remove\n\tlocal variable Pack_Spec. Refinement pragmas may now apply to\n\tbodies of both visible and private subprograms.\n\n2014-02-06  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_attr.adb (Expand_Loop_Entry_Attribute):\n\tMinor change (Attr => N) (Expand_Pred_Succ): New name\n\tExpand_Pred_Succ_Attribute (Expand_N_Attribute_Reference, case\n\tMax): Expand into if expression if Modify_Tree_For_C mode.\n\t(Expand_N_Attribute_Reference, case Min): ditto\n\t* sinfo.ads: Modify_Tree_For_C takes care of expanding Min and\n\tMax attributes.\n\n2014-02-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Object_Declaration): Do not generate\n\tpredicate check if this is an internal declaration with\n\tNo_Initialization set, as for an expanded aggregate component.\n\n2014-02-06  Doug Rupp  <rupp@adacore.com>\n\n\t* init.c (__gnat_default_resignal_p) [VMS]: Test for and resignal\n\tconditions with severity of \"SUCCESS\" or \"INFORMATIONAL\".\n\nFrom-SVN: r207559", "tree": {"sha": "9121eed3cc9e18844443e36baf95569cbf947a08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9121eed3cc9e18844443e36baf95569cbf947a08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa9b151a9e3630f78c1517d016fa26dc3277b506", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa9b151a9e3630f78c1517d016fa26dc3277b506", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa9b151a9e3630f78c1517d016fa26dc3277b506", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa9b151a9e3630f78c1517d016fa26dc3277b506/comments", "author": null, "committer": null, "parents": [{"sha": "85d6bf87cf2812afff625248bec3b34172cf4ccb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85d6bf87cf2812afff625248bec3b34172cf4ccb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85d6bf87cf2812afff625248bec3b34172cf4ccb"}], "stats": {"total": 188, "additions": 146, "deletions": 42}, "files": [{"sha": "d9ca753c25bdb5bb0535d86cc8cfa3d5d841e271", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa9b151a9e3630f78c1517d016fa26dc3277b506/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa9b151a9e3630f78c1517d016fa26dc3277b506/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=aa9b151a9e3630f78c1517d016fa26dc3277b506", "patch": "@@ -1,3 +1,30 @@\n+2014-02-06  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Refined_Pragma): Remove\n+\tlocal variable Pack_Spec. Refinement pragmas may now apply to\n+\tbodies of both visible and private subprograms.\n+\n+2014-02-06  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_attr.adb (Expand_Loop_Entry_Attribute):\n+\tMinor change (Attr => N) (Expand_Pred_Succ): New name\n+\tExpand_Pred_Succ_Attribute (Expand_N_Attribute_Reference, case\n+\tMax): Expand into if expression if Modify_Tree_For_C mode.\n+\t(Expand_N_Attribute_Reference, case Min): ditto\n+\t* sinfo.ads: Modify_Tree_For_C takes care of expanding Min and\n+\tMax attributes.\n+\n+2014-02-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Object_Declaration): Do not generate\n+\tpredicate check if this is an internal declaration with\n+\tNo_Initialization set, as for an expanded aggregate component.\n+\n+2014-02-06  Doug Rupp  <rupp@adacore.com>\n+\n+\t* init.c (__gnat_default_resignal_p) [VMS]: Test for and resignal\n+\tconditions with severity of \"SUCCESS\" or \"INFORMATIONAL\".\n+\n 2014-02-06  Yannick Moy  <moy@adacore.com>\n \n \t* sem_prag.adb (Analyze_Pragma): Analyze pragma"}, {"sha": "c54fb788903e735e8f72ceb336304afd6d8291fc", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 91, "deletions": 26, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa9b151a9e3630f78c1517d016fa26dc3277b506/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa9b151a9e3630f78c1517d016fa26dc3277b506/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=aa9b151a9e3630f78c1517d016fa26dc3277b506", "patch": "@@ -136,11 +136,11 @@ package body Exp_Attr is\n    --  that takes two floating-point arguments. The function to be called\n    --  is always the same as the attribute name.\n \n-   procedure Expand_Loop_Entry_Attribute (Attr : Node_Id);\n+   procedure Expand_Loop_Entry_Attribute (N : Node_Id);\n    --  Handle the expansion of attribute 'Loop_Entry. As a result, the related\n    --  loop may be converted into a conditional block. See body for details.\n \n-   procedure Expand_Pred_Succ (N : Node_Id);\n+   procedure Expand_Pred_Succ_Attribute (N : Node_Id);\n    --  Handles expansion of Pred or Succ attributes for case of non-real\n    --  operand with overflow checking required.\n \n@@ -657,7 +657,7 @@ package body Exp_Attr is\n    -- Expand_Loop_Entry_Attribute --\n    ---------------------------------\n \n-   procedure Expand_Loop_Entry_Attribute (Attr : Node_Id) is\n+   procedure Expand_Loop_Entry_Attribute (N : Node_Id) is\n       procedure Build_Conditional_Block\n         (Loc       : Source_Ptr;\n          Cond      : Node_Id;\n@@ -730,8 +730,8 @@ package body Exp_Attr is\n \n       --  Local variables\n \n-      Exprs     : constant List_Id   := Expressions (Attr);\n-      Pref      : constant Node_Id   := Prefix (Attr);\n+      Exprs     : constant List_Id   := Expressions (N);\n+      Pref      : constant Node_Id   := Prefix (N);\n       Typ       : constant Entity_Id := Etype (Pref);\n       Blk       : Node_Id;\n       Decls     : List_Id;\n@@ -760,7 +760,7 @@ package body Exp_Attr is\n       --  internally generated loops for quantified expressions.\n \n       else\n-         Loop_Stmt := Attr;\n+         Loop_Stmt := N;\n          while Present (Loop_Stmt) loop\n             if Nkind (Loop_Stmt) = N_Loop_Statement\n               and then Present (Identifier (Loop_Stmt))\n@@ -1002,7 +1002,7 @@ package body Exp_Attr is\n \n       --  Step 4: Analyze all bits\n \n-      Rewrite (Attr, New_Reference_To (Temp_Id, Loc));\n+      Rewrite (N, New_Reference_To (Temp_Id, Loc));\n \n       Installed := Current_Scope = Scope (Loop_Id);\n \n@@ -1028,7 +1028,7 @@ package body Exp_Attr is\n          Analyze (Temp_Decl);\n       end if;\n \n-      Analyze (Attr);\n+      Analyze (N);\n \n       if not Installed then\n          Pop_Scope;\n@@ -3616,6 +3616,44 @@ package body Exp_Attr is\n          Analyze_And_Resolve (N, Typ);\n       end Mantissa;\n \n+      ---------\n+      -- Max --\n+      ---------\n+\n+      when Attribute_Max =>\n+\n+         --  Max is handled by the back end (except that static cases have\n+         --  already been evaluated during semantic processing, but anyway\n+         --  the back end should not count on this). The one bit of special\n+         --  processing required in the normal case is that this attribute\n+         --  typically generates conditionals in the code, so we must check\n+         --  the relevant restriction.\n+\n+         Check_Restriction (No_Implicit_Conditionals, N);\n+\n+         --  In Modify_Tree_For_C mode, we rewrite as an if expression\n+\n+         if Modify_Tree_For_C then\n+            declare\n+               Loc   : constant Source_Ptr := Sloc (N);\n+               Typ   : constant Entity_Id  := Etype (N);\n+               Expr  : constant Node_Id    := First (Expressions (N));\n+               Left  : constant Node_Id    := Relocate_Node (Expr);\n+               Right : constant Node_Id    := Relocate_Node (Next (Expr));\n+\n+            begin\n+               Rewrite (N,\n+                 Make_If_Expression (Loc,\n+                   Expressions => New_List (\n+                     Make_Op_Ge (Loc,\n+                       Left_Opnd  => Left,\n+                       Right_Opnd => Right),\n+                     Duplicate_Subexpr_No_Checks (Left),\n+                     Duplicate_Subexpr_No_Checks (Right))));\n+               Analyze_And_Resolve (N, Typ);\n+            end;\n+         end if;\n+\n       ----------------------------------\n       -- Max_Size_In_Storage_Elements --\n       ----------------------------------\n@@ -3703,6 +3741,44 @@ package body Exp_Attr is\n             Set_Renamed_Subprogram (Pref, Alias (Entity (Pref)));\n          end if;\n \n+      ---------\n+      -- Min --\n+      ---------\n+\n+      when Attribute_Min =>\n+\n+         --  Min is handled by the back end (except that static cases have\n+         --  already been evaluated during semantic processing, but anyway\n+         --  the back end should not count on this). The one bit of special\n+         --  processing required in the normal case is that this attribute\n+         --  typically generates conditionals in the code, so we must check\n+         --  the relevant restriction.\n+\n+         Check_Restriction (No_Implicit_Conditionals, N);\n+\n+         --  In Modify_Tree_For_C mode, we rewrite as an if expression\n+\n+         if Modify_Tree_For_C then\n+            declare\n+               Loc   : constant Source_Ptr := Sloc (N);\n+               Typ   : constant Entity_Id  := Etype (N);\n+               Expr  : constant Node_Id    := First (Expressions (N));\n+               Left  : constant Node_Id    := Relocate_Node (Expr);\n+               Right : constant Node_Id    := Relocate_Node (Next (Expr));\n+\n+            begin\n+               Rewrite (N,\n+                 Make_If_Expression (Loc,\n+                   Expressions => New_List (\n+                     Make_Op_Le (Loc,\n+                       Left_Opnd  => Left,\n+                       Right_Opnd => Right),\n+                     Duplicate_Subexpr_No_Checks (Left),\n+                     Duplicate_Subexpr_No_Checks (Right))));\n+               Analyze_And_Resolve (N, Typ);\n+            end;\n+         end if;\n+\n       ---------\n       -- Mod --\n       ---------\n@@ -4378,7 +4454,7 @@ package body Exp_Attr is\n            or else Do_Range_Check (First (Exprs))\n          then\n             Set_Do_Range_Check (First (Exprs), False);\n-            Expand_Pred_Succ (N);\n+            Expand_Pred_Succ_Attribute (N);\n          end if;\n       end Pred;\n \n@@ -5426,7 +5502,7 @@ package body Exp_Attr is\n            or else Do_Range_Check (First (Exprs))\n          then\n             Set_Do_Range_Check (First (Exprs), False);\n-            Expand_Pred_Succ (N);\n+            Expand_Pred_Succ_Attribute (N);\n          end if;\n       end Succ;\n \n@@ -6438,17 +6514,6 @@ package body Exp_Attr is\n       when Attribute_Component_Size =>\n          null;\n \n-      --  The following attributes are handled by the back end (except that\n-      --  static cases have already been evaluated during semantic processing,\n-      --  but in any case the back end should not count on this). The one bit\n-      --  of special processing required is that these attributes typically\n-      --  generate conditionals in the code, so we need to check the relevant\n-      --  restriction.\n-\n-      when Attribute_Max                          |\n-           Attribute_Min                          =>\n-         Check_Restriction (No_Implicit_Conditionals, N);\n-\n       --  The following attributes are handled by the back end (except that\n       --  static cases have already been evaluated during semantic processing,\n       --  but in any case the back end should not count on this).\n@@ -6552,9 +6617,9 @@ package body Exp_Attr is\n          return;\n    end Expand_N_Attribute_Reference;\n \n-   ----------------------\n-   -- Expand_Pred_Succ --\n-   ----------------------\n+   --------------------------------\n+   -- Expand_Pred_Succ_Attribute --\n+   --------------------------------\n \n    --  For typ'Pred (exp), we generate the check\n \n@@ -6570,7 +6635,7 @@ package body Exp_Attr is\n    --  statement or the expression of an object declaration, where the flag\n    --  Suppress_Assignment_Checks is set for the assignment/declaration.\n \n-   procedure Expand_Pred_Succ (N : Node_Id) is\n+   procedure Expand_Pred_Succ_Attribute (N : Node_Id) is\n       Loc  : constant Source_Ptr := Sloc (N);\n       P    : constant Node_Id    := Parent (N);\n       Cnam : Name_Id;\n@@ -6598,7 +6663,7 @@ package body Exp_Attr is\n                      Attribute_Name => Cnam)),\n              Reason => CE_Overflow_Check_Failed));\n       end if;\n-   end Expand_Pred_Succ;\n+   end Expand_Pred_Succ_Attribute;\n \n    -----------------------------\n    -- Expand_Update_Attribute --"}, {"sha": "fb94198b1e2038455ebbb2b5123b74026a24d484", "filename": "gcc/ada/init.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa9b151a9e3630f78c1517d016fa26dc3277b506/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa9b151a9e3630f78c1517d016fa26dc3277b506/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=aa9b151a9e3630f78c1517d016fa26dc3277b506", "patch": "@@ -809,6 +809,7 @@ void (*__gnat_ctrl_c_handler) (void) = 0;\n /* Masks for facility identification. */\n #define FAC_MASK  \t\t0x0fff0000\n #define DECADA_M_FACILITY\t0x00310000\n+#define SEVERITY_MASK\t\t0x7\n \n /* Define macro symbols for the VMS conditions that become Ada exceptions.\n    It would be better to just include <ssdef.h> */\n@@ -1068,6 +1069,9 @@ __gnat_default_resignal_p (int code)\n     if ((code & FAC_MASK) == facility_resignal_table [i])\n       return 1;\n \n+  if ((code & SEVERITY_MASK) == 1 || (code & SEVERITY_MASK) == 3)\n+    return 1;\n+\n   for (i = 0, iexcept = 0;\n        cond_resignal_table [i]\n \t&& !(iexcept = LIB$MATCH_COND (&code, &cond_resignal_table [i]));"}, {"sha": "c763bd60b235226da75c1d5a661262cde72bae60", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa9b151a9e3630f78c1517d016fa26dc3277b506/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa9b151a9e3630f78c1517d016fa26dc3277b506/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=aa9b151a9e3630f78c1517d016fa26dc3277b506", "patch": "@@ -3551,10 +3551,13 @@ package body Sem_Ch3 is\n \n       --  We need a predicate check if the type has predicates, and if either\n       --  there is an initializing expression, or for default initialization\n-      --  when we have at least one case of an explicit default initial value.\n+      --  when we have at least one case of an explicit default initial value\n+      --  and then this is not an internal declaration whose initialization\n+      --  comes later (as for an aggregate expansion).\n \n       if not Suppress_Assignment_Checks (N)\n         and then Present (Predicate_Function (T))\n+        and then not No_Initialization (N)\n         and then\n           (Present (E)\n             or else"}, {"sha": "1f46ae2222b9353bb5bbb80c43999e4aa2e043e8", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa9b151a9e3630f78c1517d016fa26dc3277b506/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa9b151a9e3630f78c1517d016fa26dc3277b506/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=aa9b151a9e3630f78c1517d016fa26dc3277b506", "patch": "@@ -3616,7 +3616,6 @@ package body Sem_Prag is\n          Legal   : out Boolean)\n       is\n          Body_Decl : Node_Id;\n-         Pack_Spec : Node_Id;\n          Spec_Decl : Node_Id;\n \n       begin\n@@ -3676,14 +3675,10 @@ package body Sem_Prag is\n                                  N_Generic_Subprogram_Declaration,\n                                  N_Subprogram_Declaration));\n \n-         Pack_Spec := Parent (Spec_Decl);\n-\n-         if Nkind (Pack_Spec) /= N_Package_Specification\n-           or else List_Containing (Spec_Decl) /=\n-                     Visible_Declarations (Pack_Spec)\n-         then\n+         if Nkind (Parent (Spec_Decl)) /= N_Package_Specification then\n             Error_Pragma\n-              (\"pragma % must apply to the body of a visible subprogram\");\n+              (\"pragma % must apply to the body of a subprogram declared in a \"\n+               & \"package specification\");\n             return;\n          end if;\n \n@@ -12622,13 +12617,14 @@ package body Sem_Prag is\n                Freeze_Before (N, Entity (Name (Call)));\n             end if;\n \n-            Rewrite (N, Make_Implicit_If_Statement (N,\n-              Condition       => Cond,\n-              Then_Statements => New_List (\n-                Make_Block_Statement (Loc,\n-                  Handled_Statement_Sequence =>\n-                    Make_Handled_Sequence_Of_Statements (Loc,\n-                      Statements => New_List (Relocate_Node (Call)))))));\n+            Rewrite (N,\n+              Make_Implicit_If_Statement (N,\n+                Condition       => Cond,\n+                Then_Statements => New_List (\n+                  Make_Block_Statement (Loc,\n+                    Handled_Statement_Sequence =>\n+                      Make_Handled_Sequence_Of_Statements (Loc,\n+                        Statements => New_List (Relocate_Node (Call)))))));\n             Analyze (N);\n \n             --  Ignore pragma Debug in GNATprove mode. Do this rewriting"}, {"sha": "0405c647697db41d2770fdc6aab6b2a6495315c7", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa9b151a9e3630f78c1517d016fa26dc3277b506/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa9b151a9e3630f78c1517d016fa26dc3277b506/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=aa9b151a9e3630f78c1517d016fa26dc3277b506", "patch": "@@ -549,6 +549,9 @@ package Sinfo is\n    --  not make sense from a user point-of-view, and that cross-references that\n    --  do not lead to data dependences for subprograms can be safely ignored.\n \n+   --  In addition pragma Debug statements are removed from the tree (rewritten\n+   --  to NULL stmt), since they should be taken into account in flow analysis.\n+\n    -----------------------\n    -- Check Flag Fields --\n    -----------------------\n@@ -636,6 +639,9 @@ package Sinfo is\n    --    less than the word size (since other values are not well-defined in\n    --    C). This is done using an explicit test if necessary.\n \n+   --    Min and Max attributes are expanded into equivalent if expressions,\n+   --    dealing properly with side effect issues.\n+\n    ------------------------------------\n    -- Description of Semantic Fields --\n    ------------------------------------\n@@ -3589,6 +3595,9 @@ package Sinfo is\n       --  Must_Be_Byte_Aligned (Flag14)\n       --  plus fields for expression\n \n+      --  Note: in Modify_Tree_For_C mode, Max and Min attributes are expanded\n+      --  into equivalent if expressions, properly taking care of side effects.\n+\n       ---------------------------------\n       -- 4.1.4  Attribute Designator --\n       ---------------------------------"}]}