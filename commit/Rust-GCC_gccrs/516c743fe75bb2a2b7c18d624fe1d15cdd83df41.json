{"sha": "516c743fe75bb2a2b7c18d624fe1d15cdd83df41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE2Yzc0M2ZlNzViYjJhMmI3YzE4ZDYyNGZlMWQxNWNkZDgzZGY0MQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-09-30T10:36:22Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-09-30T10:36:22Z"}, "message": "re PR middle-end/37491 (Revision 140257 causes vectorizer tests failures)\n\n2008-09-30  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/37491\n\t* tree-vect-transform.c (vect_create_data_ref_ptr): Properly\n\tbuild restrict-qualified pointers.\n\t(vectorizable_store): Move alias check later.\n\t(vectorizable_load): Likewise.\n\nFrom-SVN: r140781", "tree": {"sha": "9277d051246aa8a70b05fac59a05828ec9383fe4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9277d051246aa8a70b05fac59a05828ec9383fe4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/516c743fe75bb2a2b7c18d624fe1d15cdd83df41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/516c743fe75bb2a2b7c18d624fe1d15cdd83df41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/516c743fe75bb2a2b7c18d624fe1d15cdd83df41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/516c743fe75bb2a2b7c18d624fe1d15cdd83df41/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "626c34b5c945cc9c577bd0509d297b81df083d3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/626c34b5c945cc9c577bd0509d297b81df083d3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/626c34b5c945cc9c577bd0509d297b81df083d3f"}], "stats": {"total": 56, "additions": 32, "deletions": 24}, "files": [{"sha": "b9042e658a04a8de51e8a00412f0d06b85dacf67", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516c743fe75bb2a2b7c18d624fe1d15cdd83df41/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516c743fe75bb2a2b7c18d624fe1d15cdd83df41/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=516c743fe75bb2a2b7c18d624fe1d15cdd83df41", "patch": "@@ -1,3 +1,11 @@\n+2008-09-30  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/37491\n+\t* tree-vect-transform.c (vect_create_data_ref_ptr): Properly\n+\tbuild restrict-qualified pointers.\n+\t(vectorizable_store): Move alias check later.\n+\t(vectorizable_load): Likewise.\n+\n 2008-09-30  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* c-common.c (empty_if_body_warning): Remove."}, {"sha": "1e7538ab8a1e2fde2a0ce926a2d75ac7eccf6ad6", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/516c743fe75bb2a2b7c18d624fe1d15cdd83df41/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/516c743fe75bb2a2b7c18d624fe1d15cdd83df41/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=516c743fe75bb2a2b7c18d624fe1d15cdd83df41", "patch": "@@ -1077,8 +1077,19 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop,\n   else\n     vect_ptr_type = build_pointer_type (vectype);\n \n+  if (TREE_CODE (DR_BASE_ADDRESS (dr)) == SSA_NAME\n+      && TYPE_RESTRICT (TREE_TYPE (DR_BASE_ADDRESS (dr))))\n+    vect_ptr_type = build_qualified_type (vect_ptr_type, TYPE_QUAL_RESTRICT);\n   vect_ptr = vect_get_new_vect_var (vect_ptr_type, vect_pointer_var,\n                                     get_name (base_name));\n+  if (TREE_CODE (DR_BASE_ADDRESS (dr)) == SSA_NAME\n+      && TYPE_RESTRICT (TREE_TYPE (DR_BASE_ADDRESS (dr))))\n+    {\n+      get_alias_set (base_name);\n+      DECL_POINTER_ALIAS_SET (vect_ptr)\n+\t= DECL_POINTER_ALIAS_SET (SSA_NAME_VAR (DR_BASE_ADDRESS (dr)));\n+    }\n+\n   add_referenced_var (vect_ptr);\n \n   /** (2) Add aliasing information to the new vector-pointer:\n@@ -1175,7 +1186,7 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop,\n \n       create_iv (vect_ptr_init,\n \t\t fold_convert (vect_ptr_type, step),\n-\t\t NULL_TREE, loop, &incr_gsi, insert_after,\n+\t\t vect_ptr, loop, &incr_gsi, insert_after,\n \t\t &indx_before_incr, &indx_after_incr);\n       incr = gsi_stmt (incr_gsi);\n       set_vinfo_for_stmt (incr, new_stmt_vec_info (incr, loop_vinfo));\n@@ -1206,7 +1217,7 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop,\n     {\n       standard_iv_increment_position (containing_loop, &incr_gsi,\n \t\t\t\t      &insert_after);\n-      create_iv (vptr, fold_convert (vect_ptr_type, DR_STEP (dr)), NULL_TREE, \n+      create_iv (vptr, fold_convert (vect_ptr_type, DR_STEP (dr)), vect_ptr, \n \t\t containing_loop, &incr_gsi, insert_after, &indx_before_incr,\n \t\t &indx_after_incr);\n       incr = gsi_stmt (incr_gsi);\n@@ -5190,17 +5201,6 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       return false;\n     }\n \n-  /* If accesses through a pointer to vectype do not alias the original\n-     memory reference we have a problem.  This should never be the case.  */\n-  if (get_alias_set (vectype) != get_alias_set (scalar_dest)\n-      && !alias_set_subset_of (get_alias_set (vectype), \n-                               get_alias_set (scalar_dest)))\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"???  vector type does not alias scalar type\");\n-      return false;\n-    }\n-\n   /* The scalar rhs type needs to be trivially convertible to the vector\n      component type.  This should always be the case.  */\n   if (!useless_type_conversion_p (TREE_TYPE (vectype), TREE_TYPE (op)))\n@@ -5440,6 +5440,12 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t    vec_oprnd = VEC_index (tree, result_chain, i);\n \n \t  data_ref = build_fold_indirect_ref (dataref_ptr);\n+\t  /* If accesses through a pointer to vectype do not alias the original\n+\t     memory reference we have a problem.  This should never happen.  */\n+\t  gcc_assert (get_alias_set (data_ref) == get_alias_set (gimple_assign_lhs (stmt))\n+\t\t      || alias_set_subset_of (get_alias_set (data_ref), \n+\t\t\t\t\t      get_alias_set (gimple_assign_lhs (stmt))));\n+\n \t  /* Arguments are ready. Create the new vector stmt.  */\n \t  new_stmt = gimple_build_assign (data_ref, vec_oprnd);\n \t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n@@ -6399,17 +6405,6 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       return false;\n     }\n \n-  /* If accesses through a pointer to vectype do not alias the original\n-     memory reference we have a problem.  This should never happen.  */\n-  if (get_alias_set (vectype) != get_alias_set (gimple_assign_rhs1 (stmt))\n-      && !alias_set_subset_of (get_alias_set (vectype),\n-                               get_alias_set (gimple_assign_rhs1 (stmt))))\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"???  vector type does not alias scalar type\");\n-      return false;\n-    }\n-\n   /* The vector component type needs to be trivially convertible to the\n      scalar lhs.  This should always be the case.  */\n   if (!useless_type_conversion_p (TREE_TYPE (scalar_dest), TREE_TYPE (vectype)))\n@@ -6673,6 +6668,11 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t    default:\n \t      gcc_unreachable ();\n \t    }\n+\t  /* If accesses through a pointer to vectype do not alias the original\n+\t     memory reference we have a problem.  This should never happen.  */\n+\t  gcc_assert (get_alias_set (data_ref) == get_alias_set (gimple_assign_rhs1 (stmt))\n+\t\t      || alias_set_subset_of (get_alias_set (data_ref),\n+\t\t\t\t\t      get_alias_set (gimple_assign_rhs1 (stmt))));\n \t  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n \t  new_stmt = gimple_build_assign (vec_dest, data_ref);\n \t  new_temp = make_ssa_name (vec_dest, new_stmt);"}]}