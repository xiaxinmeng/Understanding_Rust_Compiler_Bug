{"sha": "8ad6aff3037a4896ab9b488365f509cd2532b209", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFkNmFmZjMwMzdhNDg5NmFiOWI0ODgzNjVmNTA5Y2QyNTMyYjIwOQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2007-10-29T18:27:38Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-10-29T18:27:38Z"}, "message": "tree-flow-inline.h (get_subvar_at): Use binary search.\n\n2007-10-29  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-flow-inline.h (get_subvar_at): Use binary search.\n\t(get_first_overlapping_subvar): New function to binary search\n\tfor the first overlapping subvar.\n\t* tree-ssa-operands.c (add_vars_for_offset): Strip down to\n\tjust handle adding subvars for a pointed-to subvar.  Optimize\n\tand use get_first_overlapping_subvar.\n\t(add_vars_for_bitmap): Fold into single caller.\n\t(add_virtual_operand): Streamline, inherit add_vars_for_bitmap\n\tand non pointed-to bits of add_vars_for_offset.\n\nFrom-SVN: r129727", "tree": {"sha": "c1b0567e0bc3a2faf2e843ff14afa359047427ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1b0567e0bc3a2faf2e843ff14afa359047427ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ad6aff3037a4896ab9b488365f509cd2532b209", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ad6aff3037a4896ab9b488365f509cd2532b209", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ad6aff3037a4896ab9b488365f509cd2532b209", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ad6aff3037a4896ab9b488365f509cd2532b209/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bcf49b9e570cb574f49c67f0e102bf8f1a6e92f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcf49b9e570cb574f49c67f0e102bf8f1a6e92f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcf49b9e570cb574f49c67f0e102bf8f1a6e92f4"}], "stats": {"total": 222, "additions": 150, "deletions": 72}, "files": [{"sha": "f452aeaf37a704b7b6fcc6122079d87f0bf7b4fd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad6aff3037a4896ab9b488365f509cd2532b209/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad6aff3037a4896ab9b488365f509cd2532b209/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8ad6aff3037a4896ab9b488365f509cd2532b209", "patch": "@@ -1,3 +1,15 @@\n+2007-10-29  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-flow-inline.h (get_subvar_at): Use binary search.\n+\t(get_first_overlapping_subvar): New function to binary search\n+\tfor the first overlapping subvar.\n+\t* tree-ssa-operands.c (add_vars_for_offset): Strip down to\n+\tjust handle adding subvars for a pointed-to subvar.  Optimize\n+\tand use get_first_overlapping_subvar.\n+\t(add_vars_for_bitmap): Fold into single caller.\n+\t(add_virtual_operand): Streamline, inherit add_vars_for_bitmap\n+\tand non pointed-to bits of add_vars_for_offset.\n+\n 2007-10-29  Revital Eres  <eres@il.ibm.com> \n \n \t* modulo-sched.c (sms_schedule): Add DF_UD_CHAIN problem."}, {"sha": "4669588558ee3f9bd200f8d67d54b3c50a12689e", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 75, "deletions": 4, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad6aff3037a4896ab9b488365f509cd2532b209/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad6aff3037a4896ab9b488365f509cd2532b209/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=8ad6aff3037a4896ab9b488365f509cd2532b209", "patch": "@@ -1610,17 +1610,88 @@ static inline tree\n get_subvar_at (tree var, unsigned HOST_WIDE_INT offset)\n {\n   subvar_t sv = get_subvars_for_var (var);\n-  unsigned int i;\n+  int low, high;\n+\n+  low = 0;\n+  high = VEC_length (tree, sv) - 1;\n+  while (low <= high)\n+    {\n+      int mid = (low + high) / 2;\n+      tree subvar = VEC_index (tree, sv, mid);\n+      if (SFT_OFFSET (subvar) == offset)\n+\treturn subvar;\n+      else if (SFT_OFFSET (subvar) < offset)\n+\tlow = mid + 1;\n+      else\n+\thigh = mid - 1;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+\n+/* Return the first subvariable in SV that overlaps [offset, offset + size[.\n+   NULL_TREE is returned, if there is no overlapping subvariable, else *I\n+   is set to the index in the SV vector of the first overlap.  */\n+\n+static inline tree\n+get_first_overlapping_subvar (subvar_t sv, unsigned HOST_WIDE_INT offset,\n+\t\t\t      unsigned HOST_WIDE_INT size, unsigned int *i)\n+{\n+  int low = 0;\n+  int high = VEC_length (tree, sv) - 1;\n+  int mid;\n   tree subvar;\n \n-  /* ???  Binary search would be possible here.  */\n-  for (i = 0; VEC_iterate (tree, sv, i, subvar); ++i)\n-    if (SFT_OFFSET (subvar) == offset)\n+  if (low > high)\n+    return NULL_TREE;\n+\n+  /* Binary search for offset.  */\n+  do\n+    {\n+      mid = (low + high) / 2;\n+      subvar = VEC_index (tree, sv, mid);\n+      if (SFT_OFFSET (subvar) == offset)\n+\t{\n+\t  *i = mid;\n+\t  return subvar;\n+\t}\n+      else if (SFT_OFFSET (subvar) < offset)\n+\tlow = mid + 1;\n+      else\n+\thigh = mid - 1;\n+    }\n+  while (low <= high);\n+\n+  /* As we didn't find a subvar with offset, adjust to return the\n+     first overlapping one.  */\n+  if (SFT_OFFSET (subvar) < offset\n+      && SFT_OFFSET (subvar) + SFT_SIZE (subvar) <= offset)\n+    {\n+      mid += 1;\n+      if ((unsigned)mid >= VEC_length (tree, sv))\n+\treturn NULL_TREE;\n+      subvar = VEC_index (tree, sv, mid);\n+    }\n+  else if (SFT_OFFSET (subvar) > offset\n+\t   && size <= SFT_OFFSET (subvar) - offset)\n+    {\n+      mid -= 1;\n+      if (mid < 0)\n+\treturn NULL_TREE;\n+      subvar = VEC_index (tree, sv, mid);\n+    }\n+\n+  if (overlap_subvar (offset, size, subvar, NULL))\n+    {\n+      *i = mid;\n       return subvar;\n+    }\n \n   return NULL_TREE;\n }\n \n+\n /* Return true if V is a tree that we can have subvars for.\n    Normally, this is any aggregate type.  Also complex\n    types which are not gimple registers can have subvars.  */"}, {"sha": "1203a47faab1c551a19a3d52b7f4ec022b64f961", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 63, "deletions": 68, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad6aff3037a4896ab9b488365f509cd2532b209/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad6aff3037a4896ab9b488365f509cd2532b209/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=8ad6aff3037a4896ab9b488365f509cd2532b209", "patch": "@@ -1386,89 +1386,46 @@ access_can_touch_variable (tree ref, tree alias, HOST_WIDE_INT offset,\n    This is necessary because foop only actually points to foo's first\n    member, so that is all the points-to set contains.  However, an access\n    to foop->a may be touching some single SFT if we have created some\n-   SFT's for a structure.  If AS_PTO is false, just add VAR to the vops.  */\n+   SFT's for a structure.  */\n \n static bool\n-add_vars_for_offset (tree full_ref, tree var, HOST_WIDE_INT offset,\n-\t\t     HOST_WIDE_INT size, bool is_call_site, bool is_def,\n-\t\t     bool as_pto)\n+add_vars_for_offset (tree var,\n+\t\t     unsigned HOST_WIDE_INT offset, unsigned HOST_WIDE_INT size,\n+\t\t     bool is_def, bitmap mpt_vars)\n {\n   bool added = false;\n+  tree subvar;\n   subvar_t sv;\n   unsigned int i;\n-  tree subvar;\n \n+  /* Adjust offset by the pointed-to location.  */\n+  offset += SFT_OFFSET (var);\n \n-  /* Call-clobbered tags may have non-call-clobbered\n-     symbols in their alias sets.  Ignore them if we are\n-     adding VOPs for a call site.  */\n-  if (is_call_site && !is_call_clobbered (var))\n+  /* Add all subvars of var that overlap with the access.\n+     Binary search for the first relevant SFT.  */\n+  sv = get_subvars_for_var (SFT_PARENT_VAR (var));\n+  if (!get_first_overlapping_subvar (sv, offset, size, &i))\n     return false;\n \n-  /* For SFTs we have to consider all subvariables of the parent var.  */\n-  if (TREE_CODE (var) != STRUCT_FIELD_TAG\n-      || !as_pto)\n+  for (; VEC_iterate (tree, sv, i, subvar); ++i)\n     {\n-      /* If we do not know the full reference tree or if the access is\n-\t unspecified [0, -1], we cannot prune it.  Otherwise try doing\n-\t so using access_can_touch_variable.  */\n-      if (full_ref\n-\t  && !(offset == 0 && size == -1)\n-\t  && !access_can_touch_variable (full_ref, var, offset, size))\n-\treturn false;\n-\n-      if (is_def)\n-\tappend_vdef (var);\n-      else\n-\tappend_vuse (var);\n-      return true;\n-    }\n-\n-  sv = get_subvars_for_var (SFT_PARENT_VAR (var));\n-  for (i = 0; VEC_iterate (tree, sv, i, subvar); ++i)\n-    {\n-      /* Once we hit the end of the parts that could touch,\n-\t stop looking.  */\n-      if (size != -1\n-\t  && SFT_OFFSET (var) + offset + size <= SFT_OFFSET (subvar))\n+      if (size <= SFT_OFFSET (subvar) - offset)\n \tbreak;\n-      if (overlap_subvar (SFT_OFFSET (var) + offset, size, subvar, NULL))\n+\n+      /* Avoid adding a SFT that is contained in the same MPT as the\n+\t pointed-to location as this MPT will be added as alias anyway.  */\n+      if (!mpt_vars\n+\t  || !bitmap_bit_p (mpt_vars, DECL_UID (subvar)))\n \t{\n-\t  added = true;\n \t  if (is_def)\n \t    append_vdef (subvar);\n \t  else\n \t    append_vuse (subvar);\n \t}\n+      added = true;\n     }\n-  return added;\n-}\n \n-/* Consider all SFTs in ALIASES as points-to location and add virtual\n-   operands for the SFT parent var for the access FULL_REF at OFFSET\n-   and size SIZE.  IS_CALL_SITE is true if the stmt of the reference is\n-   a call.  IS_DEF is true if we should add VDEF virtual operands,\n-   otherwise we'll add VUSEs.  *NONE_ADDED is set to false once the first\n-   virtual operand was added.  */\n-\n-static void\n-add_vars_for_bitmap (bitmap aliases, tree full_ref,\n-\t\t     HOST_WIDE_INT offset, HOST_WIDE_INT size,\n-\t\t     bool is_call_site, bool is_def, bool *none_added)\n-{\n-  bitmap_iterator bi;\n-  unsigned int i;\n-\n-  EXECUTE_IF_SET_IN_BITMAP (aliases, 0, i, bi)\n-    {\n-      tree al = referenced_var (i);\n-\n-      gcc_assert (TREE_CODE (al) != MEMORY_PARTITION_TAG);\n-\n-      if (TREE_CODE (al) == STRUCT_FIELD_TAG)\n-\t*none_added &= !add_vars_for_offset (full_ref, al, offset, size,\n-\t\t\t\t\t     is_call_site, is_def, true);\n-    }\n+  return added;\n }\n \n /* Add VAR to the virtual operands array.  FLAGS is as in\n@@ -1552,11 +1509,49 @@ add_virtual_operand (tree var, stmt_ann_t s_ann, int flags,\n \t     But only if we start with NMT aliases.  */\n \t  if (TREE_CODE (al) == MEMORY_PARTITION_TAG\n \t      && TREE_CODE (var) == NAME_MEMORY_TAG)\n-\t    add_vars_for_bitmap (MPT_SYMBOLS (al), full_ref, offset, size,\n-\t\t\t\t is_call_site, flags & opf_def, &none_added);\n-\t  none_added &= !add_vars_for_offset (full_ref, al, offset, size,\n-\t\t\t\t\t      is_call_site, flags & opf_def,\n-\t\t\t\t\t      TREE_CODE (var) == NAME_MEMORY_TAG);\n+\t    {\n+\t      bitmap_iterator bi;\n+\t      unsigned int i;\n+\n+\t      EXECUTE_IF_SET_IN_BITMAP (MPT_SYMBOLS (al), 0, i, bi)\n+\t\t{\n+\t\t  tree ptsft = referenced_var (i);\n+\n+\t\t  if (TREE_CODE (ptsft) == STRUCT_FIELD_TAG)\n+\t\t    none_added &= !add_vars_for_offset (ptsft, offset, size,\n+\t\t\t\t\t\t\tflags & opf_def,\n+\t\t\t\t\t\t\tMPT_SYMBOLS (al));\n+\t\t}\n+\t    }\n+\n+\t  /* For SFTs we have to consider all subvariables of the parent var\n+\t     if it is a potential points-to location.  */\n+\t  if (TREE_CODE (al) == STRUCT_FIELD_TAG\n+\t      && TREE_CODE (var) == NAME_MEMORY_TAG)\n+\t    none_added &= !add_vars_for_offset (al, offset, size,\n+\t\t\t\t\t        flags & opf_def, NULL);\n+\t  else\n+\t    {\n+\t      /* Call-clobbered tags may have non-call-clobbered\n+\t\t symbols in their alias sets.  Ignore them if we are\n+\t\t adding VOPs for a call site.  */\n+\t      if (is_call_site && !is_call_clobbered (al))\n+\t\t continue;\n+\n+\t      /* If we do not know the full reference tree or if the access is\n+\t\t unspecified [0, -1], we cannot prune it.  Otherwise try doing\n+\t\t so using access_can_touch_variable.  */\n+\t      if (full_ref\n+\t\t  && !(offset == 0 && size == -1)\n+\t\t  && !access_can_touch_variable (full_ref, al, offset, size))\n+\t\tcontinue;\n+\n+\t      if (flags & opf_def)\n+\t\tappend_vdef (al);\n+\t      else\n+\t\tappend_vuse (al);\n+\t      none_added = false;\n+\t    }\n \t}\n \n       if (flags & opf_def)"}]}