{"sha": "a31844688a498c9f57ea71be5180da3e697b919e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMxODQ0Njg4YTQ5OGM5ZjU3ZWE3MWJlNTE4MGRhM2U2OTdiOTE5ZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1995-05-04T21:25:31Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1995-05-04T21:25:31Z"}, "message": "Make collect demangle\n\nFrom-SVN: r9573", "tree": {"sha": "d5cd65fb4395c72a796b852f8a232c7bca3a2253", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5cd65fb4395c72a796b852f8a232c7bca3a2253"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a31844688a498c9f57ea71be5180da3e697b919e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a31844688a498c9f57ea71be5180da3e697b919e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a31844688a498c9f57ea71be5180da3e697b919e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a31844688a498c9f57ea71be5180da3e697b919e/comments", "author": null, "committer": null, "parents": [{"sha": "1a62528312e1af15fc74a8507a61aa500d118fc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a62528312e1af15fc74a8507a61aa500d118fc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a62528312e1af15fc74a8507a61aa500d118fc7"}], "stats": {"total": 3381, "additions": 3307, "deletions": 74}, "files": [{"sha": "6aaa3ebf9e7a6f96573ef125921bdce810d3c294", "filename": "gcc/Makefile.in", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a31844688a498c9f57ea71be5180da3e697b919e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a31844688a498c9f57ea71be5180da3e697b919e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=a31844688a498c9f57ea71be5180da3e697b919e", "patch": "@@ -1034,16 +1034,31 @@ ld: collect2\n \tln collect2$(exeext) ld$(exeext) > /dev/null 2>&1 \\\n \t   || cp collect2$(exeext) ld$(exeext)\n \n-collect2 : collect2.o version.o $(LIBDEPS)\n+collect2 : collect2.o cplus-dem.o underscore.o version.o $(LIBDEPS)\n # Don't try modifying collect2 (aka ld) in place--it might be linking this.\n \t-rm -f collect2\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o collect2 collect2.o version.o $(LIBS)\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o collect2 collect2.o cplus-dem.o \\\n+\t  underscore.o version.o $(LIBS)\n \n-collect2.o : collect2.c $(CONFIG_H) gstab.h\n+collect2.o : collect2.c $(CONFIG_H) gstab.h obstack.h demangle.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES)  \\\n-\t-DTARGET_MACHINE=\\\"$(target)\\\" \\\n+\t-DTARGET_MACHINE=\\\"$(target)\\\" $(MAYBE_USE_COLLECT2) \\\n \t-c `echo $(srcdir)/collect2.c | sed 's,^\\./,,'`\n \n+cplus-dem.o: cplus-dem.c demangle.h\n+\n+underscore.c: $(GCC_PASSES)\n+\techo \"int xxy_us_dummy;\" >dummy.c\n+\t$(GCC_FOR_TARGET) -S dummy.c\n+\techo '/*WARNING: This file is automatically generated!*/' >underscore.t\n+\tif grep _xxy_us_dummy dummy.s > /dev/null ; then \\\n+\t  echo \"int prepends_underscore = 1;\" >>underscore.t; \\\n+\telse \\\n+\t  echo \"int prepends_underscore = 0;\" >>underscore.t; \\\n+\tfi\n+\t$(srcdir)/move-if-change underscore.t underscore.c\n+\t-rm -f dummy.c dummy.s\n+\n # Objective C language specific files.\n \n objc-parse.o : $(srcdir)/objc-parse.c $(CONFIG_H) $(TREE_H) c-lex.h \\"}, {"sha": "065178b23e326f1351a7a74632adce2b6fb476f6", "filename": "gcc/collect2.c", "status": "modified", "additions": 195, "deletions": 70, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a31844688a498c9f57ea71be5180da3e697b919e/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a31844688a498c9f57ea71be5180da3e697b919e/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=a31844688a498c9f57ea71be5180da3e697b919e", "patch": "@@ -55,13 +55,16 @@ char *strerror();\n #define COLLECT\n \n #include \"config.h\"\n+#include \"demangle.h\"\n \n-#ifndef __STDC__\n-#define generic char\n-#define const\n+#include \"obstack.h\"\n \n-#else\n-#define generic void\n+/* Obstack allocation and deallocation routines.  */\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+\n+#if !defined (__STDC__) && !defined (const)\n+#define const\n #endif\n \n #ifdef USG\n@@ -193,9 +196,15 @@ char *strerror();\n #define SYMBOL__MAIN __main\n #endif\n \n-#if defined (LDD_SUFFIX) || defined (SUNOS4_SHARED_LIBRARIES)\n+#if defined (LDD_SUFFIX) || SUNOS4_SHARED_LIBRARIES\n #define SCAN_LIBRARIES\n #endif\n+\n+#ifdef USE_COLLECT2\n+int do_collecting = 1;\n+#else\n+int do_collecting = 0;\n+#endif\n \f\n /* Linked lists of constructor and destructor names. */\n \n@@ -228,26 +237,35 @@ extern char *sys_siglist[];\n #endif\n extern char *version_string;\n \n-static int vflag;\t\t\t/* true if -v */\n+int vflag;\t\t\t\t/* true if -v */\n static int rflag;\t\t\t/* true if -r */\n static int strip_flag;\t\t\t/* true if -s */\n \n-static int debug;\t\t\t/* true if -debug */\n+int debug;\t\t\t\t/* true if -debug */\n \n static int shared_obj;\t\t        /* true if -shared */\n \n static int   temp_filename_length;\t/* Length of temp_filename */\n static char *temp_filename;\t\t/* Base of temp filenames */\n static char *c_file;\t\t\t/* <xxx>.c for constructor/destructor list. */\n static char *o_file;\t\t\t/* <xxx>.o for constructor/destructor list. */\n+char *ldout;\t\t\t\t/* File for ld errors.  */\n static char *output_file;\t\t/* Output file for ld.  */\n static char *nm_file_name;\t\t/* pathname of nm */\n static char *ldd_file_name;\t\t/* pathname of ldd (or equivalent) */\n static char *strip_file_name;\t\t/* pathname of strip */\n+char *c_file_name;\t\t        /* pathname of gcc */\n \n static struct head constructors;\t/* list of constructors found */\n static struct head destructors;\t\t/* list of destructors found */\n \n+struct obstack temporary_obstack;\n+struct obstack permanent_obstack;\n+char * temporary_firstobj;\n+\n+/* Defined in the automatically-generated underscore.c.  */\n+extern int prepends_underscore;\n+\n extern char *getenv ();\n extern char *mktemp ();\n extern FILE *fdopen ();\n@@ -268,7 +286,9 @@ struct path_prefix\n   char *name;                 /* Name of this list (used in config stuff) */\n };\n \n-static void my_exit\t\tPROTO((int));\n+void collect_exit\t\tPROTO((int));\n+void collect_execute\t\tPROTO((char *, char **, char *));\n+void dump_file\t\t\tPROTO((char *));\n static void handler\t\tPROTO((int));\n static int is_ctor_dtor\t\tPROTO((char *));\n static void choose_temp_base\tPROTO((void));\n@@ -286,11 +306,12 @@ static void write_c_file\tPROTO((FILE *, char *));\n static void scan_prog_file\tPROTO((char *, enum pass));\n static void scan_libraries\tPROTO((char *));\n \n-generic *xcalloc ();\n-generic *xmalloc ();\n+char *xcalloc ();\n+char *xmalloc ();\n \n extern char *index ();\n extern char *rindex ();\n+extern void free ();\n \f\n #ifdef NO_DUP2\n int\n@@ -338,8 +359,8 @@ my_strerror (e)\n \f\n /* Delete tempfiles and exit function.  */\n \n-static void\n-my_exit (status)\n+void\n+collect_exit (status)\n      int status;\n {\n   if (c_file != 0 && c_file[0])\n@@ -348,6 +369,12 @@ my_exit (status)\n   if (o_file != 0 && o_file[0])\n     maybe_unlink (o_file);\n \n+  if (ldout != 0 && ldout[0])\n+    {\n+      dump_file (ldout);\n+      maybe_unlink (ldout);\n+    }\n+\n   if (status != 0 && output_file != 0 && output_file[0])\n     maybe_unlink (output_file);\n \n@@ -357,7 +384,7 @@ my_exit (status)\n \f\n /* Die when sys call fails. */\n \n-static void\n+void\n fatal_perror (string, arg1, arg2, arg3)\n      char *string, *arg1, *arg2, *arg3;\n {\n@@ -366,24 +393,24 @@ fatal_perror (string, arg1, arg2, arg3)\n   fprintf (stderr, \"collect2: \");\n   fprintf (stderr, string, arg1, arg2, arg3);\n   fprintf (stderr, \": %s\\n\", my_strerror (e));\n-  my_exit (1);\n+  collect_exit (1);\n }\n \n /* Just die. */\n \n-static void\n+void\n fatal (string, arg1, arg2, arg3)\n      char *string, *arg1, *arg2, *arg3;\n {\n   fprintf (stderr, \"collect2: \");\n   fprintf (stderr, string, arg1, arg2, arg3);\n   fprintf (stderr, \"\\n\");\n-  my_exit (1);\n+  collect_exit (1);\n }\n \n /* Write error message.  */\n \n-static void\n+void\n error (string, arg1, arg2, arg3, arg4)\n      char *string, *arg1, *arg2, *arg3, *arg4;\n {\n@@ -412,33 +439,54 @@ handler (signo)\n   if (o_file != 0 && o_file[0])\n     maybe_unlink (o_file);\n \n+  if (ldout != 0 && ldout[0])\n+    maybe_unlink (ldout);\n+\n   signal (signo, SIG_DFL);\n   kill (getpid (), signo);\n }\n \n \f\n-generic *\n+char *\n xcalloc (size1, size2)\n      int size1, size2;\n {\n-  generic *ptr = (generic *) calloc (size1, size2);\n+  char *ptr = (char *) calloc (size1, size2);\n   if (ptr)\n     return ptr;\n \n   fatal (\"out of memory\");\n-  return (generic *)0;\n+  return (char *)0;\n }\n \n-generic *\n+char *\n xmalloc (size)\n-     int size;\n+     unsigned size;\n {\n-  generic *ptr = (generic *) malloc (size);\n+  char *ptr = (char *) malloc (size);\n   if (ptr)\n     return ptr;\n \n   fatal (\"out of memory\");\n-  return (generic *)0;\n+  return (char *)0;\n+}\n+\n+char *\n+xrealloc (ptr, size)\n+     char *ptr;\n+     unsigned size;\n+{\n+  register char *value = (char *) realloc (ptr, size);\n+  if (value == 0)\n+    fatal (\"virtual memory exhausted\");\n+  return value;\n+}\n+\n+int\n+file_exists (name)\n+     char *name;\n+{\n+  return access (name, R_OK) == 0;\n }\n \n /* Make a copy of a string INPUT with size SIZE.  */\n@@ -454,6 +502,63 @@ savestring (input, size)\n   return output;\n }\n \f\n+void\n+dump_file (name)\n+     char *name;\n+{\n+  FILE *stream = fopen (name, \"r\");\n+  int no_demangle = !! getenv (\"COLLECT_NO_DEMANGLE\");\n+\n+  if (stream == 0)\n+    return;\n+  while (1)\n+    {\n+      int c;\n+      while (c = getc (stream),\n+\t     c != EOF && (isalnum (c) || c == '_' || c == '$' || c == '.'))\n+\tobstack_1grow (&temporary_obstack, c);\n+      if (obstack_object_size (&temporary_obstack) > 0)\n+\t{\n+\t  char *word, *p, *result;\n+\t  obstack_1grow (&temporary_obstack, '\\0');\n+\t  word = obstack_finish (&temporary_obstack);\n+\n+\t  if (*word == '.')\n+\t    ++word, putc ('.', stderr);\n+\t  p = word;\n+\t  if (*p == '_' && prepends_underscore)\n+\t    ++p;\n+\n+\t  if (no_demangle)\n+\t    result = 0;\n+\t  else\n+\t    result = cplus_demangle (p, DMGL_PARAMS | DMGL_ANSI);\n+\n+\t  if (result)\n+\t    {\n+\t      int diff;\n+\t      fputs (result, stderr);\n+\n+\t      diff = strlen (word) - strlen (result);\n+\t      while (diff > 0)\n+\t\t--diff, putc (' ', stderr);\n+\t      while (diff < 0 && c == ' ')\n+\t\t++diff, c = getc (stream);\n+\n+\t      free (result);\n+\t    }\n+\t  else\n+\t    fputs (word, stderr);\n+\n+\t  fflush (stderr);\n+\t  obstack_free (&temporary_obstack, temporary_firstobj);\n+\t}\n+      if (c == EOF)\n+\tbreak;\n+      putc (c, stderr);\n+    }\n+}\n+\f\n /* Decide whether the given symbol is:\n    a constructor (1), a destructor (2), or neither (0).  */\n \n@@ -799,10 +904,7 @@ main (argc, argv)\n   char *full_ld_suffix\t= ld_suffix;\n   char *real_ld_suffix\t= \"real-ld\";\n   char *full_real_ld_suffix = real_ld_suffix;\n-#if 0\n-  char *gld_suffix\t= \"gld\";\n-  char *full_gld_suffix\t= gld_suffix;\n-#endif\n+  char *collect_ld_suffix = \"collect-ld\";\n   char *nm_suffix\t= \"nm\";\n   char *full_nm_suffix\t= nm_suffix;\n   char *gnm_suffix\t= \"gnm\";\n@@ -818,7 +920,6 @@ main (argc, argv)\n   char *arg;\n   FILE *outf;\n   char *ld_file_name;\n-  char *c_file_name;\n   char *collect_name;\n   char *collect_names;\n   char *p;\n@@ -840,6 +941,11 @@ main (argc, argv)\n \n   output_file = \"a.out\";\n \n+  obstack_begin (&temporary_obstack, 0);\n+  obstack_begin (&permanent_obstack, 0);\n+  temporary_firstobj = (char *) obstack_alloc (&temporary_obstack, 0);\n+  current_demangling_style = gnu_demangling;\n+\n   /* We must check that we do not call ourselves in an infinite\n      recursion loop. We append the name used for us to the COLLECT_NAMES\n      environment variable.\n@@ -992,21 +1098,11 @@ main (argc, argv)\n   ld_file_name = find_a_file (&path, REAL_LD_FILE_NAME);\n   if (ld_file_name == 0)\n #endif\n-#if 0\n-  /* Search the (target-specific) compiler dirs for `gld'.  */\n-  ld_file_name = find_a_file (&cpath, gld_suffix);\n-  /* Search the ordinary system bin directories\n-     for `gld' (if native linking) or `TARGET-gld' (if cross).  */\n-  if (ld_file_name == 0)\n-    ld_file_name = find_a_file (&path, full_gld_suffix);\n-#else\n-  ld_file_name = 0;\n-#endif\n-  /* Likewise for `real-ld'.  */\n+  /* Search the (target-specific) compiler dirs for ld'.  */\n+  ld_file_name = find_a_file (&cpath, real_ld_suffix);\n+  /* Likewise for `collect-ld'.  */\n   if (ld_file_name == 0)\n-    ld_file_name = find_a_file (&cpath, real_ld_suffix);\n-  if (ld_file_name == 0)\n-    ld_file_name = find_a_file (&path, full_real_ld_suffix);\n+    ld_file_name = find_a_file (&cpath, collect_ld_suffix);\n   /* Search the compiler directories for `ld'.  We have protection against\n      recursive calls in find_a_file.  */\n   if (ld_file_name == 0)\n@@ -1087,6 +1183,8 @@ main (argc, argv)\n   choose_temp_base ();\n   c_file = xcalloc (temp_filename_length + sizeof (\".c\"), 1);\n   o_file = xcalloc (temp_filename_length + sizeof (\".o\"), 1);\n+  ldout = xmalloc (temp_filename_length + sizeof (\".ld\"));\n+  sprintf (ldout, \"%s.ld\", temp_filename);\n   sprintf (c_file, \"%s.c\", temp_filename);\n   sprintf (o_file, \"%s.o\", temp_filename);\n   *c_ptr++ = c_file_name;\n@@ -1144,7 +1242,7 @@ main (argc, argv)\n \t      break;\n \n \t    case 's':\n-\t      if (arg[2] == '\\0')\n+\t      if (arg[2] == '\\0' && do_collecting)\n \t\t{\n \t\t  /* We must strip after the nm run, otherwise C++ linking\n \t\t     won't work.  Thus we strip in the second ld run, or\n@@ -1206,7 +1304,7 @@ main (argc, argv)\n     }\n \n   *c_ptr++ = c_file;\n-  *c_ptr = *ld1 = *ld2 = (char *)0;\n+  *object = *c_ptr = *ld1 = *ld2 = (char *)0;\n \n   if (vflag)\n     {\n@@ -1260,17 +1358,22 @@ main (argc, argv)\n       fprintf (stderr, \"\\n\");\n     }\n \n-  /* Load the program, searching all libraries.\n-     Examine the namelist with nm and search it for static constructors\n-     and destructors to call.\n-     Write the constructor and destructor tables to a .s file and reload. */\n+  /* Load the program, searching all libraries.  */\n \n-  fork_execute (\"ld\", ld1_argv);\n+  collect_execute (\"ld\", ld1_argv, ldout);\n+  do_wait (\"ld\");\n+  dump_file (ldout);\n+  unlink (ldout);\n \n-  /* If -r, don't build the constructor or destructor list, just return now. */\n-  if (rflag)\n+  /* If -r or they'll be run via some other method, don't build the\n+     constructor or destructor list, just return now. */\n+  if (rflag || ! do_collecting)\n     return 0;\n \n+  /* Examine the namelist with nm and search it for static constructors\n+     and destructors to call.\n+     Write the constructor and destructor tables to a .s file and reload. */\n+\n #ifdef COLLECT_SCAN_OBJECTS\n   /* The AIX linker will discard static constructors in object files if\n      nothing else in the file is referenced, so look at them first.  */\n@@ -1347,8 +1450,8 @@ main (argc, argv)\n \f\n /* Wait for a process to finish, and exit if a non-zero status is found. */\n \n-static void\n-do_wait (prog)\n+int\n+collect_wait (prog)\n      char *prog;\n {\n   int status;\n@@ -1372,28 +1475,35 @@ do_wait (prog)\n \t\t (status & 0200) ? \", core dumped\" : \"\");\n #endif\n \n-\t  my_exit (127);\n+\t  collect_exit (127);\n \t}\n \n       if (WIFEXITED (status))\n-\t{\n-\t  int ret = WEXITSTATUS (status);\n-\t  if (ret != 0)\n-\t    {\n-\t      error (\"%s returned %d exit status\", prog, ret);\n-\t      my_exit (ret);\n-\t    }\n-\t}\n+\treturn WEXITSTATUS (status);\n+    }\n+  return 0;\n+}\n+\n+static void\n+do_wait (prog)\n+     char *prog;\n+{\n+  int ret = collect_wait (prog);\n+  if (ret != 0)\n+    {\n+      error (\"%s returned %d exit status\", prog, ret);\n+      collect_exit (ret);\n     }\n }\n \n \f\n /* Fork and execute a program, and wait for the reply.  */\n \n-static void\n-fork_execute (prog, argv)\n+void\n+collect_execute (prog, argv, redir)\n      char *prog;\n      char **argv;\n+     char *redir;\n {\n   int pid;\n \n@@ -1434,13 +1544,28 @@ fork_execute (prog, argv)\n \n   if (pid == 0)\t\t\t/* child context */\n     {\n+      if (redir)\n+\t{\n+\t  unlink (redir);\n+\t  if (freopen (redir, \"a\", stdout) == NULL)\n+\t    fatal_perror (\"redirecting stdout\");\n+\t  if (freopen (redir, \"a\", stderr) == NULL)\n+\t    fatal_perror (\"redirecting stderr\");\n+\t}\n+\n       execvp (argv[0], argv);\n       fatal_perror (\"executing %s\", prog);\n     }\n+}\n \n+static void\n+fork_execute (prog, argv)\n+     char *prog;\n+     char **argv;\n+{\n+  collect_execute (prog, argv, NULL);\n   do_wait (prog);\n }\n-\n \f\n /* Unlink a file unless we are debugging.  */\n \n@@ -1831,7 +1956,7 @@ scan_prog_file (prog_name, which_pass)\n #endif\n }\n \n-#ifdef SUNOS4_SHARED_LIBRARIES\n+#if SUNOS4_SHARED_LIBRARIES\n \n /* Routines to scan the SunOS 4 _DYNAMIC structure to find shared libraries\n    that the output file depends upon and their initialization/finalization\n@@ -3000,10 +3125,10 @@ end_file (ptr)\n \t    fatal (\"wrote %ld bytes, expected %ld, to %s\", len, ptr->size, ptr->name);\n \t}\n \n-      free ((generic *)ptr->start);\n+      free (ptr->start);\n     }\n \n-  free ((generic *)ptr);\n+  free (ptr);\n }\n \n #endif /* OBJECT_FORMAT_ROSE */"}, {"sha": "b56e34e251780707a5470130be9304a654e12115", "filename": "gcc/cplus-dem.c", "status": "added", "additions": 2986, "deletions": 0, "changes": 2986, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a31844688a498c9f57ea71be5180da3e697b919e/gcc%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a31844688a498c9f57ea71be5180da3e697b919e/gcc%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcplus-dem.c?ref=a31844688a498c9f57ea71be5180da3e697b919e", "patch": "@@ -0,0 +1,2986 @@\n+/* Demangler for GNU C++ \n+   Copyright 1989, 1991, 1994, 1995 Free Software Foundation, Inc.\n+   Written by James Clark (jjc@jclark.uucp)\n+   Rewritten by Fred Fish (fnf@cygnus.com) for ARM and Lucid demangling\n+   \n+This file is part of the libiberty library.\n+Libiberty is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+Libiberty is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libiberty; see the file COPYING.LIB.  If\n+not, write to the Free Software Foundation, Inc., 675 Mass Ave,\n+Cambridge, MA 02139, USA.  */\n+\n+/* This file exports two functions; cplus_mangle_opname and cplus_demangle.\n+\n+   This file imports xmalloc and xrealloc, which are like malloc and\n+   realloc except that they generate a fatal error if there is no\n+   available memory. */\n+\n+#include <ctype.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <demangle.h>\n+#undef CURRENT_DEMANGLING_STYLE\n+#define CURRENT_DEMANGLING_STYLE work->options\n+\n+extern char *xmalloc PARAMS((unsigned));\n+extern char *xrealloc PARAMS((char *, unsigned));\n+extern char *strstr ();\n+\n+/* In order to allow a single demangler executable to demangle strings\n+   using various common values of CPLUS_MARKER, as well as any specific\n+   one set at compile time, we maintain a string containing all the\n+   commonly used ones, and check to see if the marker we are looking for\n+   is in that string.  CPLUS_MARKER is usually '$' on systems where the\n+   assembler can deal with that.  Where the assembler can't, it's usually\n+   '.' (but on many systems '.' is used for other things).  We put the\n+   current defined CPLUS_MARKER first (which defaults to '$'), followed\n+   by the next most common value, followed by an explicit '$' in case\n+   the value of CPLUS_MARKER is not '$'.\n+\n+   We could avoid this if we could just get g++ to tell us what the actual\n+   cplus marker character is as part of the debug information, perhaps by\n+   ensuring that it is the character that terminates the gcc<n>_compiled\n+   marker symbol (FIXME). */\n+\n+#if !defined (CPLUS_MARKER)\n+#define CPLUS_MARKER '$'\n+#endif\n+\n+enum demangling_styles current_demangling_style = gnu_demangling;\n+\n+static char cplus_markers[] = { CPLUS_MARKER, '.', '$', '\\0' };\n+\n+void\n+set_cplus_marker_for_demangling (ch)\n+     int ch;\n+{\n+    cplus_markers[0] = ch;\n+}\n+\n+/* Stuff that is shared between sub-routines.\n+ * Using a shared structure allows cplus_demangle to be reentrant. */\n+\n+struct work_stuff\n+{\n+  int options;\n+  char **typevec;\n+  int ntypes;\n+  int typevec_size;\n+  int constructor;\n+  int destructor;\n+  int static_type;\t/* A static member function */\n+  int const_type;\t/* A const member function */\n+};\n+\n+#define PRINT_ANSI_QUALIFIERS (work -> options & DMGL_ANSI)\n+#define PRINT_ARG_TYPES       (work -> options & DMGL_PARAMS)\n+\n+static const struct optable\n+{\n+  const char *in;\n+  const char *out;\n+  int flags;\n+} optable[] = {\n+  {\"nw\",\t  \" new\",\tDMGL_ANSI},\t/* new (1.92,\t ansi) */\n+  {\"dl\",\t  \" delete\",\tDMGL_ANSI},\t/* new (1.92,\t ansi) */\n+  {\"new\",\t  \" new\",\t0},\t\t/* old (1.91,\t and 1.x) */\n+  {\"delete\",\t  \" delete\",\t0},\t\t/* old (1.91,\t and 1.x) */\n+  {\"vn\",\t  \" new []\",\tDMGL_ANSI},\t/* GNU, pending ansi */\n+  {\"vd\",\t  \" delete []\",\tDMGL_ANSI},\t/* GNU, pending ansi */\n+  {\"as\",\t  \"=\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"ne\",\t  \"!=\",\t\tDMGL_ANSI},\t/* old, ansi */\n+  {\"eq\",\t  \"==\",\t\tDMGL_ANSI},\t/* old,\tansi */\n+  {\"ge\",\t  \">=\",\t\tDMGL_ANSI},\t/* old,\tansi */\n+  {\"gt\",\t  \">\",\t\tDMGL_ANSI},\t/* old,\tansi */\n+  {\"le\",\t  \"<=\",\t\tDMGL_ANSI},\t/* old,\tansi */\n+  {\"lt\",\t  \"<\",\t\tDMGL_ANSI},\t/* old,\tansi */\n+  {\"plus\",\t  \"+\",\t\t0},\t\t/* old */\n+  {\"pl\",\t  \"+\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"apl\",\t  \"+=\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"minus\",\t  \"-\",\t\t0},\t\t/* old */\n+  {\"mi\",\t  \"-\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"ami\",\t  \"-=\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"mult\",\t  \"*\",\t\t0},\t\t/* old */\n+  {\"ml\",\t  \"*\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"amu\",\t  \"*=\",\t\tDMGL_ANSI},\t/* ansi (ARM/Lucid) */\n+  {\"aml\",\t  \"*=\",\t\tDMGL_ANSI},\t/* ansi (GNU/g++) */\n+  {\"convert\",\t  \"+\",\t\t0},\t\t/* old (unary +) */\n+  {\"negate\",\t  \"-\",\t\t0},\t\t/* old (unary -) */\n+  {\"trunc_mod\",\t  \"%\",\t\t0},\t\t/* old */\n+  {\"md\",\t  \"%\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"amd\",\t  \"%=\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"trunc_div\",\t  \"/\",\t\t0},\t\t/* old */\n+  {\"dv\",\t  \"/\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"adv\",\t  \"/=\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"truth_andif\", \"&&\",\t\t0},\t\t/* old */\n+  {\"aa\",\t  \"&&\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"truth_orif\",  \"||\",\t\t0},\t\t/* old */\n+  {\"oo\",\t  \"||\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"truth_not\",\t  \"!\",\t\t0},\t\t/* old */\n+  {\"nt\",\t  \"!\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"postincrement\",\"++\",\t0},\t\t/* old */\n+  {\"pp\",\t  \"++\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"postdecrement\",\"--\",\t0},\t\t/* old */\n+  {\"mm\",\t  \"--\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"bit_ior\",\t  \"|\",\t\t0},\t\t/* old */\n+  {\"or\",\t  \"|\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"aor\",\t  \"|=\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"bit_xor\",\t  \"^\",\t\t0},\t\t/* old */\n+  {\"er\",\t  \"^\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"aer\",\t  \"^=\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"bit_and\",\t  \"&\",\t\t0},\t\t/* old */\n+  {\"ad\",\t  \"&\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"aad\",\t  \"&=\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"bit_not\",\t  \"~\",\t\t0},\t\t/* old */\n+  {\"co\",\t  \"~\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"call\",\t  \"()\",\t\t0},\t\t/* old */\n+  {\"cl\",\t  \"()\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"alshift\",\t  \"<<\",\t\t0},\t\t/* old */\n+  {\"ls\",\t  \"<<\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"als\",\t  \"<<=\",\tDMGL_ANSI},\t/* ansi */\n+  {\"arshift\",\t  \">>\",\t\t0},\t\t/* old */\n+  {\"rs\",\t  \">>\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"ars\",\t  \">>=\",\tDMGL_ANSI},\t/* ansi */\n+  {\"component\",\t  \"->\",\t\t0},\t\t/* old */\n+  {\"pt\",\t  \"->\",\t\tDMGL_ANSI},\t/* ansi; Lucid C++ form */\n+  {\"rf\",\t  \"->\",\t\tDMGL_ANSI},\t/* ansi; ARM/GNU form */\n+  {\"indirect\",\t  \"*\",\t\t0},\t\t/* old */\n+  {\"method_call\",  \"->()\",\t0},\t\t/* old */\n+  {\"addr\",\t  \"&\",\t\t0},\t\t/* old (unary &) */\n+  {\"array\",\t  \"[]\",\t\t0},\t\t/* old */\n+  {\"vc\",\t  \"[]\",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"compound\",\t  \", \",\t\t0},\t\t/* old */\n+  {\"cm\",\t  \", \",\t\tDMGL_ANSI},\t/* ansi */\n+  {\"cond\",\t  \"?:\",\t\t0},\t\t/* old */\n+  {\"cn\",\t  \"?:\",\t\tDMGL_ANSI},\t/* psuedo-ansi */\n+  {\"max\",\t  \">?\",\t\t0},\t\t/* old */\n+  {\"mx\",\t  \">?\",\t\tDMGL_ANSI},\t/* psuedo-ansi */\n+  {\"min\",\t  \"<?\",\t\t0},\t\t/* old */\n+  {\"mn\",\t  \"<?\",\t\tDMGL_ANSI},\t/* psuedo-ansi */\n+  {\"nop\",\t  \"\",\t\t0},\t\t/* old (for operator=) */\n+  {\"rm\",\t  \"->*\",\tDMGL_ANSI}\t/* ansi */\n+};\n+\n+\n+typedef struct string\t\t/* Beware: these aren't required to be */\n+{\t\t\t\t/*  '\\0' terminated. */\n+  char *b;\t\t\t/* pointer to start of string */\n+  char *p;\t\t\t/* pointer after last character */\n+  char *e;\t\t\t/* pointer after end of allocated space */\n+} string;\n+\n+#define STRING_EMPTY(str)\t((str) -> b == (str) -> p)\n+#define PREPEND_BLANK(str)\t{if (!STRING_EMPTY(str)) \\\n+\t\t\t\t   string_prepend(str, \" \");}\n+#define APPEND_BLANK(str)\t{if (!STRING_EMPTY(str)) \\\n+\t\t\t\t   string_append(str, \" \");}\n+\n+#define ARM_VTABLE_STRING \"__vtbl__\"\t/* Lucid/ARM virtual table prefix */\n+#define ARM_VTABLE_STRLEN 8\t\t/* strlen (ARM_VTABLE_STRING) */\n+\n+/* Prototypes for local functions */\n+\n+static char *\n+mop_up PARAMS ((struct work_stuff *, string *, int));\n+\n+#if 0\n+static int\n+demangle_method_args PARAMS ((struct work_stuff *work, const char **, string *));\n+#endif\n+\n+static int\n+demangle_template PARAMS ((struct work_stuff *work, const char **, string *,\n+\t\t\t   string *));\n+\n+static int\n+demangle_qualified PARAMS ((struct work_stuff *, const char **, string *,\n+\t\t\t    int, int));\n+\n+static int\n+demangle_class PARAMS ((struct work_stuff *, const char **, string *));\n+\n+static int\n+demangle_fund_type PARAMS ((struct work_stuff *, const char **, string *));\n+\n+static int\n+demangle_signature PARAMS ((struct work_stuff *, const char **, string *));\n+\n+static int\n+demangle_prefix PARAMS ((struct work_stuff *, const char **, string *));\n+\n+static int\n+gnu_special PARAMS ((struct work_stuff *, const char **, string *));\n+\n+static int\n+arm_special PARAMS ((struct work_stuff *, const char **, string *));\n+\n+static void\n+string_need PARAMS ((string *, int));\n+\n+static void\n+string_delete PARAMS ((string *));\n+\n+static void\n+string_init PARAMS ((string *));\n+\n+static void\n+string_clear PARAMS ((string *));\n+\n+#if 0\n+static int\n+string_empty PARAMS ((string *));\n+#endif\n+\n+static void\n+string_append PARAMS ((string *, const char *));\n+\n+static void\n+string_appends PARAMS ((string *, string *));\n+\n+static void\n+string_appendn PARAMS ((string *, const char *, int));\n+\n+static void\n+string_prepend PARAMS ((string *, const char *));\n+\n+static void\n+string_prependn PARAMS ((string *, const char *, int));\n+\n+static int\n+get_count PARAMS ((const char **, int *));\n+\n+static int\n+consume_count PARAMS ((const char **));\n+\n+static int\n+demangle_args PARAMS ((struct work_stuff *, const char **, string *));\n+\n+static int\n+do_type PARAMS ((struct work_stuff *, const char **, string *));\n+\n+static int\n+do_arg PARAMS ((struct work_stuff *, const char **, string *));\n+\n+static void\n+demangle_function_name PARAMS ((struct work_stuff *, const char **, string *,\n+\t\t\t\tconst char *));\n+\n+static void\n+remember_type PARAMS ((struct work_stuff *, const char *, int));\n+\n+static void\n+forget_types PARAMS ((struct work_stuff *));\n+\n+static void\n+string_prepends PARAMS ((string *, string *));\n+\n+/*  Translate count to integer, consuming tokens in the process.\n+    Conversion terminates on the first non-digit character.\n+    Trying to consume something that isn't a count results in\n+    no consumption of input and a return of 0. */\n+\n+static int\n+consume_count (type)\n+    const char **type;\n+{\n+    int count = 0;\n+\n+    while (isdigit (**type))\n+      {\n+\tcount *= 10;\n+\tcount += **type - '0';\n+\t(*type)++;\n+      }\n+    return (count);\n+}\n+\n+int\n+cplus_demangle_opname (opname, result, options)\n+     char *opname;\n+     char *result;\n+     int options;\n+{\n+  int len, i, len1, ret;\n+  string type;\n+  struct work_stuff work[1];\n+  const char *tem;\n+\n+  len = strlen(opname);\n+  result[0] = '\\0';\n+  ret = 0;\n+  work->options = options;\n+  \n+  if (opname[0] == '_' && opname[1] == '_'\n+\t  && opname[2] == 'o' && opname[3] == 'p')\n+    {\n+      /* ANSI.  */\n+      /* type conversion operator.  */\n+      tem = opname + 4;\n+      if (do_type (work, &tem, &type))\n+\t{\n+\t  strcat (result, \"operator \");\n+\t  strncat (result, type.b, type.p - type.b);\n+\t  string_delete (&type);\n+\t  ret = 1;\n+\t}\n+    }\n+  else if (opname[0] == '_' && opname[1] == '_'\n+\t   && opname[2] >= 'a' && opname[2] <= 'z'\n+\t   && opname[3] >= 'a' && opname[3] <= 'z')\n+    {\n+      if (opname[4] == '\\0')\n+\t{\n+\t  /* Operator.  */\n+\t  for (i = 0; i < sizeof (optable) / sizeof (optable[0]); i++)\n+\t    {\n+\t      if (strlen (optable[i].in) == 2\n+\t\t  && memcmp (optable[i].in, opname + 2, 2) == 0)\n+\t\t{\n+\t\t  strcat (result, \"operator\");\n+\t\t  strcat (result, optable[i].out);\n+\t\t  ret = 1;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (opname[2] == 'a' && opname[5] == '\\0')\n+\t    {\n+\t      /* Assignment. */\n+\t      for (i = 0; i < sizeof (optable) / sizeof (optable[0]); i++)\n+\t\t{\n+\t\t  if (strlen (optable[i].in) == 3\n+\t\t      && memcmp (optable[i].in, opname + 2, 3) == 0)\n+\t\t    {\n+\t\t      strcat (result, \"operator\");\n+\t\t      strcat (result, optable[i].out);\n+\t\t      ret = 1;\n+\t\t      break;\n+\t\t    }\t\t      \n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else if (len >= 3 \n+      && opname[0] == 'o'\n+      && opname[1] == 'p'\n+      && strchr (cplus_markers, opname[2]) != NULL)\n+    {\n+      /* see if it's an assignment expression */\n+      if (len >= 10 /* op$assign_ */\n+\t  && memcmp (opname + 3, \"assign_\", 7) == 0)\n+\t{\n+\t  for (i = 0; i < sizeof (optable) / sizeof (optable[0]); i++)\n+\t    {\n+\t      len1 = len - 10;\n+\t      if (strlen (optable[i].in) == len1\n+\t\t  && memcmp (optable[i].in, opname + 10, len1) == 0)\n+\t\t{\n+\t\t  strcat (result, \"operator\");\n+\t\t  strcat (result, optable[i].out);\n+\t\t  strcat (result, \"=\");\n+\t\t  ret = 1;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (i = 0; i < sizeof (optable) / sizeof (optable[0]); i++)\n+\t    {\n+\t      len1 = len - 3;\n+\t      if (strlen (optable[i].in) == len1 \n+\t\t  && memcmp (optable[i].in, opname + 3, len1) == 0)\n+\t\t{\n+\t\t  strcat (result, \"operator\");\n+\t\t  strcat (result, optable[i].out);\n+\t\t  ret = 1;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else if (len >= 5 && memcmp (opname, \"type\", 4) == 0\n+\t   && strchr (cplus_markers, opname[4]) != NULL)\n+    {\n+      /* type conversion operator */\n+      tem = opname + 5;\n+      if (do_type (work, &tem, &type))\n+\t{\n+\t  strcat (result, \"operator \");\n+\t  strncat (result, type.b, type.p - type.b);\n+\t  string_delete (&type);\n+\t  ret = 1;\n+\t}\n+    }\n+  return ret;\n+\n+}\n+/* Takes operator name as e.g. \"++\" and returns mangled\n+   operator name (e.g. \"postincrement_expr\"), or NULL if not found.\n+\n+   If OPTIONS & DMGL_ANSI == 1, return the ANSI name;\n+   if OPTIONS & DMGL_ANSI == 0, return the old GNU name.  */\n+\n+char *\n+cplus_mangle_opname (opname, options)\n+     char *opname;\n+     int options;\n+{\n+  int i;\n+  int len;\n+\n+  len = strlen (opname);\n+  for (i = 0; i < sizeof (optable) / sizeof (optable[0]); i++)\n+    {\n+      if (strlen (optable[i].out) == len\n+\t  && (options & DMGL_ANSI) == (optable[i].flags & DMGL_ANSI)\n+\t  && memcmp (optable[i].out, opname, len) == 0)\n+\treturn ((char *)optable[i].in);\n+    }\n+  return (0);\n+}\n+\n+/* check to see whether MANGLED can match TEXT in the first TEXT_LEN\n+   characters. */\n+\n+int cplus_match (mangled, text, text_len)\n+     const char *mangled;\n+     char *text;\n+     int text_len;\n+{\n+  if (strncmp (mangled, text, text_len) != 0) {\n+    return(0); /* cannot match either */\n+  } else {\n+    return(1); /* matches mangled, may match demangled */\n+  }\n+}\n+\n+/* char *cplus_demangle (const char *mangled, int options)\n+\n+   If MANGLED is a mangled function name produced by GNU C++, then\n+   a pointer to a malloced string giving a C++ representation\n+   of the name will be returned; otherwise NULL will be returned.\n+   It is the caller's responsibility to free the string which\n+   is returned.\n+\n+   The OPTIONS arg may contain one or more of the following bits:\n+\n+   \tDMGL_ANSI\tANSI qualifiers such as `const' and `void' are\n+\t\t\tincluded.\n+\tDMGL_PARAMS\tFunction parameters are included.\n+\n+   For example,\n+   \n+   cplus_demangle (\"foo__1Ai\", DMGL_PARAMS)\t\t=> \"A::foo(int)\"\n+   cplus_demangle (\"foo__1Ai\", DMGL_PARAMS | DMGL_ANSI)\t=> \"A::foo(int)\"\n+   cplus_demangle (\"foo__1Ai\", 0)\t\t\t=> \"A::foo\"\n+\n+   cplus_demangle (\"foo__1Afe\", DMGL_PARAMS)\t\t=> \"A::foo(float,...)\"\n+   cplus_demangle (\"foo__1Afe\", DMGL_PARAMS | DMGL_ANSI)=> \"A::foo(float,...)\"\n+   cplus_demangle (\"foo__1Afe\", 0)\t\t\t=> \"A::foo\"\n+\n+   Note that any leading underscores, or other such characters prepended by\n+   the compilation system, are presumed to have already been stripped from\n+   MANGLED.  */\n+\n+char *\n+cplus_demangle (mangled, options)\n+     const char *mangled;\n+     int options;\n+{\n+  string decl;\n+  int success = 0;\n+  struct work_stuff work[1];\n+  char *demangled = NULL;\n+\n+  if ((mangled != NULL) && (*mangled != '\\0'))\n+    {\n+      memset ((char *) work, 0, sizeof (work));\n+      work -> options = options;\n+      if ((work->options & DMGL_STYLE_MASK) == 0)\n+\twork->options |= (int)current_demangling_style & DMGL_STYLE_MASK;\n+      \n+      string_init (&decl);\n+\n+      /* First check to see if gnu style demangling is active and if the\n+\t string to be demangled contains a CPLUS_MARKER.  If so, attempt to\n+\t recognize one of the gnu special forms rather than looking for a\n+\t standard prefix.  In particular, don't worry about whether there\n+\t is a \"__\" string in the mangled string.  Consider \"_$_5__foo\" for\n+\t example. */\n+\n+      if ((AUTO_DEMANGLING || GNU_DEMANGLING))\n+\t{\n+\t  success = gnu_special (work, &mangled, &decl);\n+\t}\n+      if (!success)\n+\t{\n+\t  success = demangle_prefix (work, &mangled, &decl);\n+\t}\n+      if (success && (*mangled != '\\0'))\n+\t{\n+\t  success = demangle_signature (work, &mangled, &decl);\n+\t}\n+      if (work->constructor == 2)\n+        {\n+          string_prepend(&decl, \"global constructors keyed to \");\n+          work->constructor = 0;\n+        }\n+      else if (work->destructor == 2)\n+        {\n+          string_prepend(&decl, \"global destructors keyed to \");\n+          work->destructor = 0;\n+        }\n+      demangled = mop_up (work, &decl, success);\n+    }\n+  return (demangled);\n+}\n+\n+static char *\n+mop_up (work, declp, success)\n+     struct work_stuff *work;\n+     string *declp;\n+     int success;\n+{\n+  char *demangled = NULL;\n+\n+  /* Discard the remembered types, if any. */\n+  \n+  forget_types (work);\n+  if (work -> typevec != NULL)\n+    {\n+      free ((char *) work -> typevec);\n+    }\n+  \n+  /* If demangling was successful, ensure that the demangled string is null\n+     terminated and return it.  Otherwise, free the demangling decl. */\n+  \n+  if (!success)\n+    {\n+      string_delete (declp);\n+    }\n+  else\n+    {\n+      string_appendn (declp, \"\", 1);\n+      demangled = declp -> b;\n+    }\n+  return (demangled);\n+}\n+\n+/*\n+\n+LOCAL FUNCTION\n+\n+\tdemangle_signature -- demangle the signature part of a mangled name\n+\n+SYNOPSIS\n+\n+\tstatic int\n+\tdemangle_signature (struct work_stuff *work, const char **mangled,\n+\t\t\t    string *declp);\n+\n+DESCRIPTION\n+\n+\tConsume and demangle the signature portion of the mangled name.\n+\n+\tDECLP is the string where demangled output is being built.  At\n+\tentry it contains the demangled root name from the mangled name\n+\tprefix.  I.E. either a demangled operator name or the root function\n+\tname.  In some special cases, it may contain nothing.\n+\n+\t*MANGLED points to the current unconsumed location in the mangled\n+\tname.  As tokens are consumed and demangling is performed, the\n+\tpointer is updated to continuously point at the next token to\n+\tbe consumed.\n+\n+\tDemangling GNU style mangled names is nasty because there is no\n+\texplicit token that marks the start of the outermost function\n+\targument list.\n+*/\n+\n+static int\n+demangle_signature (work, mangled, declp)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string *declp;\n+{\n+  int success = 1;\n+  int func_done = 0;\n+  int expect_func = 0;\n+  const char *oldmangled = NULL;\n+  string trawname;\n+  string tname;\n+\n+  while (success && (**mangled != '\\0'))\n+    {\n+      switch (**mangled)\n+\t{\n+\t  case 'Q':\n+\t    oldmangled = *mangled;\n+\t    success = demangle_qualified (work, mangled, declp, 1, 0);\n+\t    if (success)\n+\t      {\n+\t\tremember_type (work, oldmangled, *mangled - oldmangled);\n+\t      }\n+\t    if (AUTO_DEMANGLING || GNU_DEMANGLING)\n+\t      {\n+\t\texpect_func = 1;\n+\t      }\n+\t    oldmangled = NULL;\n+\t    break;\n+\t  \n+\t  case 'S':\n+\t    /* Static member function */\n+\t    if (oldmangled == NULL)\n+\t      {\n+\t\toldmangled = *mangled;\n+\t      }\n+\t    (*mangled)++;\n+\t    work -> static_type = 1;\n+\t    break;\n+\n+\t  case 'C':\n+\t    /* a const member function */\n+\t    if (oldmangled == NULL)\n+\t      {\n+\t\toldmangled = *mangled;\n+\t      }\n+\t    (*mangled)++;\n+\t    work -> const_type = 1;\n+\t    break;\n+\t  \n+\t  case '0': case '1': case '2': case '3': case '4':\n+\t  case '5': case '6': case '7': case '8': case '9':\n+\t    if (oldmangled == NULL)\n+\t      {\n+\t\toldmangled = *mangled;\n+\t      }\n+\t    success = demangle_class (work, mangled, declp);\n+\t    if (success)\n+\t      {\n+\t\tremember_type (work, oldmangled, *mangled - oldmangled);\n+\t      }\n+\t    if (AUTO_DEMANGLING || GNU_DEMANGLING)\n+\t      {\n+\t\texpect_func = 1;\n+\t      }\n+\t    oldmangled = NULL;\n+\t    break;\n+\t  \n+\t  case 'F':\n+\t    /* Function */\n+\t    /* ARM style demangling includes a specific 'F' character after\n+\t     the class name.  For GNU style, it is just implied.  So we can\n+\t     safely just consume any 'F' at this point and be compatible\n+\t     with either style. */\n+\n+\t    oldmangled = NULL;\n+\t    func_done = 1;\n+\t    (*mangled)++;\n+\n+\t    /* For lucid/ARM style we have to forget any types we might\n+\t       have remembered up to this point, since they were not argument\n+\t       types.  GNU style considers all types seen as available for\n+\t       back references.  See comment in demangle_args() */\n+\n+\t    if (LUCID_DEMANGLING || ARM_DEMANGLING)\n+\t      {\n+\t\tforget_types (work);\n+\t      }\n+\t    success = demangle_args (work, mangled, declp);\n+\t    break;\n+\t  \n+\t  case 't':\n+\t    /* G++ Template */\n+\t    string_init(&trawname); \n+\t    string_init(&tname);\n+            if (oldmangled == NULL)\n+              {\n+                oldmangled = *mangled;\n+              }\n+\t    success = demangle_template (work, mangled, &tname, &trawname);\n+            if (success)\n+              {\n+                remember_type (work, oldmangled, *mangled - oldmangled);\n+              }\n+\t    string_append(&tname, \"::\");\n+\t    string_prepends(declp, &tname);\n+  \t    if (work -> destructor & 1)\n+    \t      {\n+      \t\tstring_prepend (&trawname, \"~\");\n+      \t\tstring_appends (declp, &trawname);\n+\t\twork->destructor -= 1;\n+    \t      }\n+  \t    if ((work->constructor & 1) || (work->destructor & 1))\n+    \t      {\n+      \t\tstring_appends (declp, &trawname);\n+\t\twork->constructor -= 1;\n+              }\n+\t    string_delete(&trawname);\n+\t    string_delete(&tname);\n+\t    oldmangled = NULL;\n+\t    expect_func = 1;\n+\t    break;\n+\n+\t  case '_':\n+\t    /* At the outermost level, we cannot have a return type specified,\n+\t       so if we run into another '_' at this point we are dealing with\n+\t       a mangled name that is either bogus, or has been mangled by\n+\t       some algorithm we don't know how to deal with.  So just\n+\t       reject the entire demangling. */\n+\t    success = 0;\n+\t    break;\n+\n+\t  default:\n+\t    if (AUTO_DEMANGLING || GNU_DEMANGLING)\n+\t      {\n+\t\t/* Assume we have stumbled onto the first outermost function\n+\t\t   argument token, and start processing args. */\n+\t\tfunc_done = 1;\n+\t\tsuccess = demangle_args (work, mangled, declp);\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* Non-GNU demanglers use a specific token to mark the start\n+\t\t   of the outermost function argument tokens.  Typically 'F',\n+\t\t   for ARM-demangling, for example.  So if we find something\n+\t\t   we are not prepared for, it must be an error. */\n+\t\tsuccess = 0;\n+\t      }\n+\t    break;\n+\t}\n+/*\n+      if (AUTO_DEMANGLING || GNU_DEMANGLING)\n+*/\n+\t{\n+\t  if (success && expect_func)\n+\t    {\n+\t      func_done = 1;\n+\t      success = demangle_args (work, mangled, declp);\n+\t    }\n+\t}\n+    }\n+  if (success && !func_done)\n+    {\n+      if (AUTO_DEMANGLING || GNU_DEMANGLING)\n+\t{\n+\t  /* With GNU style demangling, bar__3foo is 'foo::bar(void)', and\n+\t     bar__3fooi is 'foo::bar(int)'.  We get here when we find the\n+\t     first case, and need to ensure that the '(void)' gets added to\n+\t     the current declp.  Note that with ARM, the first case\n+\t     represents the name of a static data member 'foo::bar',\n+\t     which is in the current declp, so we leave it alone. */\n+\t  success = demangle_args (work, mangled, declp);\n+\t}\n+    }\n+  if (success && work -> static_type && PRINT_ARG_TYPES)\n+    {\n+      string_append (declp, \" static\");\n+    }\n+  if (success && work -> const_type && PRINT_ARG_TYPES)\n+    {\n+      string_append (declp, \" const\");\n+    }\n+  return (success);\n+}\n+\n+#if 0\n+\n+static int\n+demangle_method_args (work, mangled, declp)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string *declp;\n+{\n+  int success = 0;\n+\n+  if (work -> static_type)\n+    {\n+      string_append (declp, *mangled + 1);\n+      *mangled += strlen (*mangled);\n+      success = 1;\n+    }\n+  else\n+    {\n+      success = demangle_args (work, mangled, declp);\n+    }\n+  return (success);\n+}\n+\n+#endif\n+\n+static int\n+demangle_template (work, mangled, tname, trawname)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string *tname;\n+     string *trawname;\n+{\n+  int i;\n+  int is_pointer;\n+  int is_real;\n+  int is_integral;\n+  int is_char;\n+  int is_bool;\n+  int r;\n+  int need_comma = 0;\n+  int success = 0;\n+  int done;\n+  const char *old_p;\n+  const char *start;\n+  int symbol_len;\n+  string temp;\n+\n+  (*mangled)++;\n+  start = *mangled;\n+  /* get template name */\n+  if ((r = consume_count (mangled)) == 0 || strlen (*mangled) < r)\n+    {\n+      return (0);\n+    }\n+  if (trawname)\n+    string_appendn (trawname, *mangled, r);\n+  string_appendn (tname, *mangled, r);\n+  *mangled += r;\n+  string_append (tname, \"<\");\n+  /* get size of template parameter list */\n+  if (!get_count (mangled, &r))\n+    {\n+      return (0);\n+    }\n+  for (i = 0; i < r; i++)\n+    {\n+      if (need_comma)\n+\t{\n+\t  string_append (tname, \", \");\n+\t}\n+      /* Z for type parameters */\n+      if (**mangled == 'Z')\n+\t{\n+\t  (*mangled)++;\n+\t  /* temp is initialized in do_type */\n+\t  success = do_type (work, mangled, &temp);\n+\t  if (success)\n+\t    {\n+\t      string_appends (tname, &temp);\n+\t    }\n+\t  string_delete(&temp);\n+\t  if (!success)\n+\t    {\n+\t      break;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* otherwise, value parameter */\n+\t  old_p  = *mangled;\n+\t  is_pointer = 0;\n+\t  is_real = 0;\n+\t  is_integral = 0;\n+          is_char = 0;\n+\t  done = 0;\n+\t  /* temp is initialized in do_type */\n+\t  success = do_type (work, mangled, &temp);\n+/*\n+\t  if (success)\n+\t    {\n+\t      string_appends (tname, &temp);\n+\t    }\n+*/\n+\t  string_delete(&temp);\n+\t  if (!success)\n+\t    {\n+\t      break;\n+\t    }\n+/*\n+\t  string_append (tname, \"=\");\n+*/\n+\t  while (*old_p && !done)\n+\t    {\t\n+\t      switch (*old_p)\n+\t\t{\n+\t\t  case 'P':\n+\t\t  case 'p':\n+\t\t  case 'R':\n+\t\t    done = is_pointer = 1;\n+\t\t    break;\n+\t\t  case 'C':\t/* const */\n+\t\t  case 'S':\t/* explicitly signed [char] */\n+\t\t  case 'U':\t/* unsigned */\n+\t\t  case 'V':\t/* volatile */\n+\t\t  case 'F':\t/* function */\n+\t\t  case 'M':\t/* member function */\n+\t\t  case 'O':\t/* ??? */\n+\t\t    old_p++;\n+\t\t    continue;\n+\t\t  case 'Q':\t/* qualified name */\n+                    done = is_integral = 1;\n+                    break;\n+\t\t  case 'T':\t/* remembered type */\n+\t\t    abort ();\n+\t\t    break;\n+\t\t  case 'v':\t/* void */\n+\t\t    abort ();\n+\t\t    break;\n+\t\t  case 'x':\t/* long long */\n+\t\t  case 'l':\t/* long */\n+\t\t  case 'i':\t/* int */\n+\t\t  case 's':\t/* short */\n+\t\t  case 'w':\t/* wchar_t */\n+\t\t    done = is_integral = 1;\n+\t\t    break;\n+\t\t  case 'b':\t/* bool */\n+\t\t    done = is_bool = 1;\n+\t\t    break;\n+\t\t  case 'c':\t/* char */\n+\t\t    done = is_char = 1;\n+\t\t    break;\n+\t\t  case 'r':\t/* long double */\n+\t\t  case 'd':\t/* double */\n+\t\t  case 'f':\t/* float */\n+\t\t    done = is_real = 1;\n+\t\t    break;\n+\t\t  default:\n+\t\t    /* it's probably user defined type, let's assume\n+\t\t       it's integeral, it seems hard to figure out\n+\t\t       what it really is */\n+\t\t    done = is_integral = 1;\n+\t\t}\n+\t    }\n+\t  if (is_integral)\n+\t    {\n+\t      if (**mangled == 'm')\n+\t\t{\n+\t\t  string_appendn (tname, \"-\", 1);\n+\t\t  (*mangled)++;\n+\t\t}\n+\t      while (isdigit (**mangled))\t\n+\t\t{\n+\t\t  string_appendn (tname, *mangled, 1);\n+\t\t  (*mangled)++;\n+\t\t}\n+\t    }\n+\t  else if (is_char)\n+\t    {\n+            char tmp[2];\n+            int val;\n+              if (**mangled == 'm')\n+                {\n+                  string_appendn (tname, \"-\", 1);\n+                  (*mangled)++;\n+                }\n+\t      string_appendn (tname, \"'\", 1);\n+              val = consume_count(mangled);\n+\t      if (val == 0)\n+\t\t{\n+\t\t  success = 0;\n+\t\t  break;\n+                }\n+              tmp[0] = (char)val;\n+              tmp[1] = '\\0';\n+              string_appendn (tname, &tmp[0], 1);\n+\t      string_appendn (tname, \"'\", 1);\n+\t    }\n+\t  else if (is_bool)\n+\t    {\n+\t      int val = consume_count (mangled);\n+\t      if (val == 0)\n+\t\tstring_appendn (tname, \"false\", 5);\n+\t      else if (val == 1)\n+\t\tstring_appendn (tname, \"true\", 4);\n+\t      else\n+\t\tsuccess = 0;\n+\t    }\n+\t  else if (is_real)\n+\t    {\n+\t      if (**mangled == 'm')\n+\t\t{\n+\t\t  string_appendn (tname, \"-\", 1);\n+\t\t  (*mangled)++;\n+\t\t}\n+\t      while (isdigit (**mangled))\t\n+\t\t{\n+\t\t  string_appendn (tname, *mangled, 1);\n+\t\t  (*mangled)++;\n+\t\t}\n+\t      if (**mangled == '.') /* fraction */\n+\t\t{\n+\t\t  string_appendn (tname, \".\", 1);\n+\t\t  (*mangled)++;\n+\t\t  while (isdigit (**mangled))\t\n+\t\t    {\n+\t\t      string_appendn (tname, *mangled, 1);\n+\t\t      (*mangled)++;\n+\t\t    }\n+\t\t}\n+\t      if (**mangled == 'e') /* exponent */\n+\t\t{\n+\t\t  string_appendn (tname, \"e\", 1);\n+\t\t  (*mangled)++;\n+\t\t  while (isdigit (**mangled))\t\n+\t\t    {\n+\t\t      string_appendn (tname, *mangled, 1);\n+\t\t      (*mangled)++;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else if (is_pointer)\n+\t    {\n+\t      if (!get_count (mangled, &symbol_len))\n+\t\t{\n+\t\t  success = 0;\n+\t\t  break;\n+\t\t}\n+\t      string_appendn (tname, *mangled, symbol_len);\n+\t      *mangled += symbol_len;\n+\t    }\n+\t}\n+      need_comma = 1;\n+    }\n+  if (tname->p[-1] == '>')\n+    string_append (tname, \" \");\n+  string_append (tname, \">\");\n+  \n+/*\n+      if (work -> static_type)\n+\t{\n+\t  string_append (declp, *mangled + 1);\n+\t  *mangled += strlen (*mangled);\n+\t  success = 1;\n+\t}\n+      else\n+\t{\n+\t  success = demangle_args (work, mangled, declp);\n+\t}\n+    }\n+*/\n+  return (success);\n+}\n+\n+static int\n+arm_pt (work, mangled, n, anchor, args)\n+     struct work_stuff *work;\n+     const char *mangled;\n+     int n;\n+     const char **anchor, **args;\n+{\n+  /* ARM template? */\n+  if (ARM_DEMANGLING && (*anchor = strstr(mangled, \"__pt__\")))\n+    {\n+\tint len;\n+        *args = *anchor + 6;\n+\tlen = consume_count (args);\n+        if (*args + len == mangled + n && **args == '_')\n+\t  {\n+\t    ++*args;\n+\t    return 1;\n+\t  }\n+    }\n+  return 0;\n+}\n+\n+static void\n+demangle_arm_pt (work, mangled, n, declp)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     int n;\n+     string *declp;\n+{\n+  const char *p;\n+  const char *args;\n+  const char *e = *mangled + n;\n+\n+  /* ARM template? */\n+  if (arm_pt (work, *mangled, n, &p, &args))\n+  {\n+    string arg;\n+    string_init (&arg);\n+    string_appendn (declp, *mangled, p - *mangled);\n+    string_append (declp, \"<\");\n+    /* should do error checking here */\n+    while (args < e) {\n+      string_clear (&arg);\n+      do_type (work, &args, &arg);\n+      string_appends (declp, &arg);\n+      string_append (declp, \",\");\n+    }\n+    string_delete (&arg);\n+    --declp->p;\n+    string_append (declp, \">\");\n+  }\n+  else\n+  {\n+    string_appendn (declp, *mangled, n);\n+  }\n+  *mangled += n;\n+}\n+\n+static int\n+demangle_class_name (work, mangled, declp)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string *declp;\n+{\n+  int n;\n+  int success = 0;\n+\n+  n = consume_count (mangled);\n+  if (strlen (*mangled) >= n)\n+  {\n+    demangle_arm_pt (work, mangled, n, declp);\n+    success = 1;\n+  }\n+\n+  return (success);\n+}\n+\n+/*\n+\n+LOCAL FUNCTION\n+\n+\tdemangle_class -- demangle a mangled class sequence\n+\n+SYNOPSIS\n+\n+\tstatic int\n+\tdemangle_class (struct work_stuff *work, const char **mangled,\n+\t\t\tstrint *declp)\n+\n+DESCRIPTION\n+\n+\tDECLP points to the buffer into which demangling is being done.\n+\n+\t*MANGLED points to the current token to be demangled.  On input,\n+\tit points to a mangled class (I.E. \"3foo\", \"13verylongclass\", etc.)\n+\tOn exit, it points to the next token after the mangled class on\n+\tsuccess, or the first unconsumed token on failure.\n+\n+\tIf the constRUCTOR or DESTRUCTOR flags are set in WORK, then\n+\twe are demangling a constructor or destructor.  In this case\n+\twe prepend \"class::class\" or \"class::~class\" to DECLP.\n+\n+\tOtherwise, we prepend \"class::\" to the current DECLP.\n+\n+\tReset the constructor/destructor flags once they have been\n+\t\"consumed\".  This allows demangle_class to be called later during\n+\tthe same demangling, to do normal class demangling.\n+\n+\tReturns 1 if demangling is successful, 0 otherwise.\n+\n+*/\n+\n+static int\n+demangle_class (work, mangled, declp)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string *declp;\n+{\n+  int success = 0;\n+  string class_name;\n+\n+  string_init (&class_name);\n+  if (demangle_class_name (work, mangled, &class_name))\n+    {\n+      if ((work->constructor & 1) || (work->destructor & 1))\n+\t{\n+\t  string_prepends (declp, &class_name);\n+\t  if (work -> destructor & 1)\n+\t    {\n+\t      string_prepend (declp, \"~\");\n+              work -> destructor -= 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      work -> constructor -= 1; \n+\t    }\n+\t}\n+      string_prepend (declp, \"::\");\n+      string_prepends (declp, &class_name);\n+      success = 1;\n+    }\n+  string_delete (&class_name);\n+  return (success);\n+}\n+\n+/*\n+\n+LOCAL FUNCTION\n+\n+\tdemangle_prefix -- consume the mangled name prefix and find signature\n+\n+SYNOPSIS\n+\n+\tstatic int\n+\tdemangle_prefix (struct work_stuff *work, const char **mangled,\n+\t\t\t string *declp);\n+\n+DESCRIPTION\n+\n+\tConsume and demangle the prefix of the mangled name.\n+\n+\tDECLP points to the string buffer into which demangled output is\n+\tplaced.  On entry, the buffer is empty.  On exit it contains\n+\tthe root function name, the demangled operator name, or in some\n+\tspecial cases either nothing or the completely demangled result.\n+\n+\tMANGLED points to the current pointer into the mangled name.  As each\n+\ttoken of the mangled name is consumed, it is updated.  Upon entry\n+\tthe current mangled name pointer points to the first character of\n+\tthe mangled name.  Upon exit, it should point to the first character\n+\tof the signature if demangling was successful, or to the first\n+\tunconsumed character if demangling of the prefix was unsuccessful.\n+\t\n+\tReturns 1 on success, 0 otherwise.\n+ */\n+\n+static int\n+demangle_prefix (work, mangled, declp)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string *declp;\n+{\n+  int success = 1;\n+  const char *scan;\n+  int i;\n+\n+  if (strlen(*mangled) >= 11 && strncmp(*mangled, \"_GLOBAL_\", 8) == 0)\n+    {\n+      char *marker = strchr (cplus_markers, (*mangled)[8]);\n+      if (marker != NULL && *marker == (*mangled)[10])\n+\t{\n+\t  if ((*mangled)[9] == 'D')\n+\t    {\n+\t      /* it's a GNU global destructor to be executed at program exit */\n+\t      (*mangled) += 11;\n+\t      work->destructor = 2;\n+\t      if (gnu_special (work, mangled, declp))\n+\t\treturn success;\n+\t    }\n+\t  else if ((*mangled)[9] == 'I')\n+\t    {\n+\t      /* it's a GNU global constructor to be executed at program init */\n+\t      (*mangled) += 11;\n+\t      work->constructor = 2;\n+\t      if (gnu_special (work, mangled, declp))\n+\t\treturn success;\n+\t    }\n+\t}\n+    }\n+  else if (ARM_DEMANGLING && strncmp(*mangled, \"__std__\", 7) == 0)\n+    {\n+      /* it's a ARM global destructor to be executed at program exit */\n+      (*mangled) += 7;\n+      work->destructor = 2;\n+    }\n+  else if (ARM_DEMANGLING && strncmp(*mangled, \"__sti__\", 7) == 0)\n+    {\n+      /* it's a ARM global constructor to be executed at program initial */\n+      (*mangled) += 7;\n+      work->constructor = 2;\n+    }\n+\n+/*  This block of code is a reduction in strength time optimization\n+    of:\n+    \tscan = strstr (*mangled, \"__\"); */\n+\n+  {\n+    scan = *mangled;\n+\n+    do {\n+      scan = strchr (scan, '_');\n+    } while (scan != NULL && *++scan != '_');\n+\n+    if (scan != NULL) --scan;\n+  }\n+\n+  if (scan != NULL)\n+    {\n+      /* We found a sequence of two or more '_', ensure that we start at\n+\t the last pair in the sequence. */\n+      i = strspn (scan, \"_\");\n+      if (i > 2)\n+\t{\n+\t  scan += (i - 2); \n+\t}\n+    }\n+ \n+  if (scan == NULL)\n+    {\n+      success = 0;\n+    }\n+  else if (work -> static_type)\n+    {\n+      if (!isdigit (scan[0]) && (scan[0] != 't'))\n+\t{\n+\t  success = 0;\n+\t}\n+    }\n+  else if ((scan == *mangled) &&\n+\t   (isdigit (scan[2]) || (scan[2] == 'Q') || (scan[2] == 't')))\n+    {\n+      /* The ARM says nothing about the mangling of local variables.\n+\t But cfront mangles local variables by prepending __<nesting_level>\n+\t to them. As an extension to ARM demangling we handle this case.  */\n+      if ((LUCID_DEMANGLING || ARM_DEMANGLING) && isdigit (scan[2]))\n+\t{\n+\t  *mangled = scan + 2;\n+\t  consume_count (mangled);\n+\t  string_append (declp, *mangled);\n+\t  *mangled += strlen (*mangled);\n+\t  success = 1; \n+\t}\n+      else\n+\t{\n+\t  /* A GNU style constructor starts with __[0-9Qt].  But cfront uses\n+\t     names like __Q2_3foo3bar for nested type names.  So don't accept\n+\t     this style of constructor for cfront demangling.  */\n+\t  if (!(LUCID_DEMANGLING || ARM_DEMANGLING))\n+\t    work -> constructor += 1;\n+\t  *mangled = scan + 2;\n+\t}\n+    }\n+  else if ((scan == *mangled) && !isdigit (scan[2]) && (scan[2] != 't'))\n+    {\n+      /* Mangled name starts with \"__\".  Skip over any leading '_' characters,\n+\t then find the next \"__\" that separates the prefix from the signature.\n+\t */\n+      if (!(ARM_DEMANGLING || LUCID_DEMANGLING)\n+\t  || (arm_special (work, mangled, declp) == 0))\n+\t{\n+\t  while (*scan == '_')\n+\t    {\n+\t      scan++;\n+\t    }\n+\t  if ((scan = strstr (scan, \"__\")) == NULL || (*(scan + 2) == '\\0'))\n+\t    {\n+\t      /* No separator (I.E. \"__not_mangled\"), or empty signature\n+\t\t (I.E. \"__not_mangled_either__\") */\n+\t      success = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      demangle_function_name (work, mangled, declp, scan);\n+\t    }\n+\t}\n+    }\n+  else if (ARM_DEMANGLING && scan[2] == 'p' && scan[3] == 't')\n+    {\n+      /* Cfront-style parameterized type.  Handled later as a signature. */\n+      success = 1;\n+\n+      /* ARM template? */\n+      demangle_arm_pt (work, mangled, strlen (*mangled), declp);\n+    }\n+  else if (*(scan + 2) != '\\0')\n+    {\n+      /* Mangled name does not start with \"__\" but does have one somewhere\n+\t in there with non empty stuff after it.  Looks like a global\n+\t function name. */\n+      demangle_function_name (work, mangled, declp, scan);\n+    }\n+  else\n+    {\n+      /* Doesn't look like a mangled name */\n+      success = 0;\n+    }\n+\n+  if (!success && (work->constructor == 2 || work->destructor == 2))\n+    {\n+      string_append (declp, *mangled);\n+      *mangled += strlen (*mangled);\n+      success = 1;\n+    } \n+  return (success);\n+}\n+\n+/*\n+\n+LOCAL FUNCTION\n+\n+\tgnu_special -- special handling of gnu mangled strings\n+\n+SYNOPSIS\n+\n+\tstatic int\n+\tgnu_special (struct work_stuff *work, const char **mangled,\n+\t\t     string *declp);\n+\n+\n+DESCRIPTION\n+\n+\tProcess some special GNU style mangling forms that don't fit\n+\tthe normal pattern.  For example:\n+\n+\t\t_$_3foo\t\t(destructor for class foo)\n+\t\t_vt$foo\t\t(foo virtual table)\n+\t\t_vt$foo$bar\t(foo::bar virtual table)\n+\t\t__vt_foo\t(foo virtual table, new style with thunks)\n+\t\t_3foo$varname\t(static data member)\n+\t\t_Q22rs2tu$vw\t(static data member)\n+\t\t__t6vector1Zii\t(constructor with template)\n+\t\t__thunk_4__$_7ostream (virtual function thunk)\n+ */\n+\n+static int\n+gnu_special (work, mangled, declp)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string *declp;\n+{\n+  int n;\n+  int success = 1;\n+  const char *p;\n+\n+  if ((*mangled)[0] == '_'\n+      && strchr (cplus_markers, (*mangled)[1]) != NULL\n+      && (*mangled)[2] == '_')\n+    {\n+      /* Found a GNU style destructor, get past \"_<CPLUS_MARKER>_\" */\n+      (*mangled) += 3;\n+      work -> destructor += 1;\n+    }\n+  else if ((*mangled)[0] == '_'\n+\t   && (((*mangled)[1] == '_'\n+\t\t&& (*mangled)[2] == 'v'\n+\t\t&& (*mangled)[3] == 't'\n+\t\t&& (*mangled)[4] == '_')\n+\t     || ((*mangled)[1] == 'v'\n+\t\t && (*mangled)[2] == 't'\n+\t\t && strchr (cplus_markers, (*mangled)[3]) != NULL)))\n+    {\n+      /* Found a GNU style virtual table, get past \"_vt<CPLUS_MARKER>\"\n+         and create the decl.  Note that we consume the entire mangled\n+\t input string, which means that demangle_signature has no work\n+\t to do. */\n+      if ((*mangled)[2] == 'v')\n+\t(*mangled) += 5; /* New style, with thunks: \"__vt_\" */\n+      else\n+\t(*mangled) += 4; /* Old style, no thunks: \"_vt<CPLUS_MARKER>\" */\n+      while (**mangled != '\\0')\n+\t{\n+\t  p = strpbrk (*mangled, cplus_markers);\n+\t  switch (**mangled)\n+\t    {\n+\t    case 'Q':\n+\t      success = demangle_qualified (work, mangled, declp, 0, 1);\n+\t      break;\n+\t    case 't':\n+\t      success = demangle_template (work, mangled, declp, 0);\n+\t      break;\n+\t    default:\n+\t      if (isdigit(*mangled[0]))\n+\t\t{\n+\t\t  n = consume_count(mangled);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  n = strcspn (*mangled, cplus_markers);\n+\t\t}\n+\t      string_appendn (declp, *mangled, n);\n+\t      (*mangled) += n;\n+\t    }\n+\n+\t  if (success && ((p == NULL) || (p == *mangled)))\n+\t    {\n+\t      if (p != NULL)\n+\t\t{\n+\t\t  string_append (declp, \"::\");\n+\t\t  (*mangled)++;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      success = 0;\n+\t      break;\n+\t    }\n+\t}\n+      if (success)\n+\tstring_append (declp, \" virtual table\");\n+    }\n+  else if ((*mangled)[0] == '_'\n+\t   && (strchr(\"0123456789Qt\", (*mangled)[1]) != NULL)\n+\t   && (p = strpbrk (*mangled, cplus_markers)) != NULL)\n+    {\n+      /* static data member, \"_3foo$varname\" for example */\n+      (*mangled)++;\n+      switch (**mangled)\n+\t{\n+\t  case 'Q':\n+\t    success = demangle_qualified (work, mangled, declp, 0, 1);\n+\t    break;\n+\t  case 't':\n+\t    success = demangle_template (work, mangled, declp, 0);\n+\t    break;\n+\t  default:\n+\t    n = consume_count (mangled);\n+\t    string_appendn (declp, *mangled, n);\n+\t    (*mangled) += n;\n+\t}\n+      if (success && (p == *mangled))\n+\t{\n+\t  /* Consumed everything up to the cplus_marker, append the\n+\t     variable name. */\n+\t  (*mangled)++;\n+\t  string_append (declp, \"::\");\n+\t  n = strlen (*mangled);\n+\t  string_appendn (declp, *mangled, n);\n+\t  (*mangled) += n;\n+\t}\n+      else\n+\t{\n+\t  success = 0;\n+\t}\n+    }\n+  else if (strncmp (*mangled, \"__thunk_\", 8) == 0)\n+    {\n+      int delta = ((*mangled) += 8, consume_count (mangled));\n+      char *method = cplus_demangle (++*mangled, work->options);\n+      if (method)\n+\t{\n+\t  char buf[50];\n+\t  sprintf (buf, \"virtual function thunk (delta:%d) for \", -delta);\n+\t  string_append (declp, buf);\n+\t  string_append (declp, method);\n+\t  free (method);\n+\t  n = strlen (*mangled);\n+\t  (*mangled) += n;\n+\t}\n+      else\n+\t{\n+\t  success = 0;\n+\t}\n+    }\n+  else\n+    {\n+      success = 0;\n+    }\n+  return (success);\n+}\n+\n+/*\n+\n+LOCAL FUNCTION\n+\n+\tarm_special -- special handling of ARM/lucid mangled strings\n+\n+SYNOPSIS\n+\n+\tstatic int\n+\tarm_special (struct work_stuff *work, const char **mangled,\n+\t\t\tstring *declp);\n+\n+\n+DESCRIPTION\n+\n+\tProcess some special ARM style mangling forms that don't fit\n+\tthe normal pattern.  For example:\n+\n+\t\t__vtbl__3foo\t\t(foo virtual table)\n+\t\t__vtbl__3foo__3bar\t(bar::foo virtual table)\n+\n+ */\n+\n+static int\n+arm_special (work, mangled, declp)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string *declp;\n+{\n+  int n;\n+  int success = 1;\n+  const char *scan;\n+\n+  if (strncmp (*mangled, ARM_VTABLE_STRING, ARM_VTABLE_STRLEN) == 0)\n+    {\n+      /* Found a ARM style virtual table, get past ARM_VTABLE_STRING\n+         and create the decl.  Note that we consume the entire mangled\n+\t input string, which means that demangle_signature has no work\n+\t to do. */\n+      scan = *mangled + ARM_VTABLE_STRLEN;\n+      while (*scan != '\\0')        /* first check it can be demangled */\n+        {\n+          n = consume_count (&scan);\n+          if (n==0)\n+\t    {\n+\t      return (0);           /* no good */\n+\t    }\n+          scan += n;\n+          if (scan[0] == '_' && scan[1] == '_')\n+\t    {\n+\t      scan += 2;\n+\t    }\n+        }\n+      (*mangled) += ARM_VTABLE_STRLEN;\n+      while (**mangled != '\\0')\n+\t{\n+\t  n = consume_count (mangled);\n+\t  string_prependn (declp, *mangled, n);\n+\t  (*mangled) += n;\n+\t  if ((*mangled)[0] == '_' && (*mangled)[1] == '_')\n+\t    {\n+\t      string_prepend (declp, \"::\");\n+\t      (*mangled) += 2;\n+\t    }\n+\t}\n+      string_append (declp, \" virtual table\");\n+    }\n+  else\n+    {\n+      success = 0;\n+    }\n+  return (success);\n+}\n+\n+/*\n+\n+LOCAL FUNCTION\n+\n+\tdemangle_qualified -- demangle 'Q' qualified name strings\n+\n+SYNOPSIS\n+\n+\tstatic int\n+\tdemangle_qualified (struct work_stuff *, const char *mangled,\n+\t\t\t    string *result, int isfuncname, int append);\n+\n+DESCRIPTION\n+\n+\tDemangle a qualified name, such as \"Q25Outer5Inner\" which is\n+\tthe mangled form of \"Outer::Inner\".  The demangled output is\n+\tprepended or appended to the result string according to the\n+\tstate of the append flag.\n+\n+\tIf isfuncname is nonzero, then the qualified name we are building\n+\tis going to be used as a member function name, so if it is a\n+\tconstructor or destructor function, append an appropriate\n+\tconstructor or destructor name.  I.E. for the above example,\n+\tthe result for use as a constructor is \"Outer::Inner::Inner\"\n+\tand the result for use as a destructor is \"Outer::Inner::~Inner\".\n+\n+BUGS\n+\n+\tNumeric conversion is ASCII dependent (FIXME).\n+\n+ */\n+\n+static int\n+demangle_qualified (work, mangled, result, isfuncname, append)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string *result;\n+     int isfuncname;\n+     int append;\n+{\n+  int qualifiers;\n+  int namelength;\n+  int success = 1;\n+  const char *p;\n+  char num[2];\n+  string temp;\n+\n+  string_init (&temp);\n+  switch ((*mangled)[1])\n+    {\n+    case '_':\n+      /* GNU mangled name with more than 9 classes.  The count is preceded\n+\t by an underscore (to distinguish it from the <= 9 case) and followed\n+\t by an underscore.  */\n+      p = *mangled + 2;\n+      qualifiers = atoi (p);\n+      if (!isdigit (*p) || *p == '0')\n+\tsuccess = 0;\n+\n+      /* Skip the digits.  */\n+      while (isdigit (*p))\n+\t++p;\n+\n+      if (*p != '_')\n+\tsuccess = 0;\n+\n+      *mangled = p + 1;\n+      break;\n+\n+    case '1':\n+    case '2':\n+    case '3':\n+    case '4':\n+    case '5':\n+    case '6':\n+    case '7':\n+    case '8':\n+    case '9':\n+      /* The count is in a single digit.  */\n+      num[0] = (*mangled)[1];\n+      num[1] = '\\0';\n+      qualifiers = atoi (num);\n+\n+      /* If there is an underscore after the digit, skip it.  This is\n+\t said to be for ARM-qualified names, but the ARM makes no\n+\t mention of such an underscore.  Perhaps cfront uses one.  */\n+      if ((*mangled)[2] == '_')\n+\t{\n+\t  (*mangled)++;\n+\t}\n+      (*mangled) += 2;\n+      break;\n+\n+    case '0':\n+    default:\n+      success = 0;\n+    }\n+\n+  if (!success)\n+    return success;\n+\n+  /* Pick off the names and collect them in the temp buffer in the order\n+     in which they are found, separated by '::'. */\n+\n+  while (qualifiers-- > 0)\n+    {\n+      if (*mangled[0] == '_') \n+\t*mangled = *mangled + 1;\n+      if (*mangled[0] == 't')\n+\t{\n+\t  success = demangle_template(work, mangled, &temp, 0);\n+\t  if (!success) break;\n+\t}\n+      else\n+        {\t\n+\t  namelength = consume_count (mangled);\n+      \t  if (strlen (*mangled) < namelength)\n+\t    {\n+\t    /* Simple sanity check failed */\n+\t       success = 0;\n+\t       break;\n+\t    }\n+      \t  string_appendn (&temp, *mangled, namelength);\n+      \t  *mangled += namelength;\n+\t}\n+      if (qualifiers > 0)\n+        {\n+          string_appendn (&temp, \"::\", 2);\n+        }\n+    }\n+\n+  /* If we are using the result as a function name, we need to append\n+     the appropriate '::' separated constructor or destructor name.\n+     We do this here because this is the most convenient place, where\n+     we already have a pointer to the name and the length of the name. */\n+\n+  if (isfuncname && (work->constructor & 1 || work->destructor & 1))\n+    {\n+      string_appendn (&temp, \"::\", 2);\n+      if (work -> destructor & 1)\n+\t{\n+\t  string_append (&temp, \"~\");\n+\t}\n+      string_appendn (&temp, (*mangled) - namelength, namelength);\n+    }\n+\n+  /* Now either prepend the temp buffer to the result, or append it, \n+     depending upon the state of the append flag. */\n+\n+  if (append)\n+    {\n+      string_appends (result, &temp);\n+    }\n+  else\n+    {\n+      if (!STRING_EMPTY (result))\n+\t{\n+\t  string_appendn (&temp, \"::\", 2);\n+\t}\n+      string_prepends (result, &temp);\n+    }\n+\n+  string_delete (&temp);\n+  return (success);\n+}\n+\n+/*\n+\n+LOCAL FUNCTION\n+\n+\tget_count -- convert an ascii count to integer, consuming tokens\n+\n+SYNOPSIS\n+\n+\tstatic int\n+\tget_count (const char **type, int *count)\n+\n+DESCRIPTION\n+\n+\tReturn 0 if no conversion is performed, 1 if a string is converted.\n+*/\n+\n+static int\n+get_count (type, count)\n+     const char **type;\n+     int *count;\n+{\n+  const char *p;\n+  int n;\n+\n+  if (!isdigit (**type))\n+    {\n+      return (0);\n+    }\n+  else\n+    {\n+      *count = **type - '0';\n+      (*type)++;\n+      if (isdigit (**type))\n+\t{\n+\t  p = *type;\n+\t  n = *count;\n+\t  do \n+\t    {\n+\t      n *= 10;\n+\t      n += *p - '0';\n+\t      p++;\n+\t    } \n+\t  while (isdigit (*p));\n+\t  if (*p == '_')\n+\t    {\n+\t      *type = p + 1;\n+\t      *count = n;\n+\t    }\n+\t}\n+    }\n+  return (1);\n+}\n+\n+/* result will be initialised here; it will be freed on failure */\n+\n+static int\n+do_type (work, mangled, result)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string *result;\n+{\n+  int n;\n+  int done;\n+  int success;\n+  string decl;\n+  const char *remembered_type;\n+  int constp;\n+  int volatilep;\n+\n+  string_init (&decl);\n+  string_init (result);\n+\n+  done = 0;\n+  success = 1;\n+  while (success && !done)\n+    {\n+      int member;\n+      switch (**mangled)\n+\t{\n+\n+\t/* A pointer type */\n+\tcase 'P':\n+\tcase 'p':\n+\t  (*mangled)++;\n+\t  string_prepend (&decl, \"*\");\n+\t  break;\n+\n+\t/* A reference type */\n+\tcase 'R':\n+\t  (*mangled)++;\n+\t  string_prepend (&decl, \"&\");\n+\t  break;\n+\n+\t/* An array */\n+\tcase 'A':\n+\t  {\n+\t    const char *p = ++(*mangled);\n+\n+\t    string_prepend (&decl, \"(\");\n+\t    string_append (&decl, \")[\");\n+\t    /* Copy anything up until the next underscore (the size of the\n+\t       array).  */\n+\t    while (**mangled && **mangled != '_')\n+\t      ++(*mangled);\n+\t    if (**mangled == '_')\n+\t      {\n+\t\tstring_appendn (&decl, p, *mangled - p);\n+\t\tstring_append (&decl, \"]\");             \n+\t\t*mangled += 1;\n+\t      }\n+\t    else\n+\t      success = 0;\n+\t    break;\n+\t  }\n+\n+\t/* A back reference to a previously seen type */\n+\tcase 'T':\n+\t  (*mangled)++;\n+\t  if (!get_count (mangled, &n) || n >= work -> ntypes)\n+\t    {\n+\t      success = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      remembered_type = work -> typevec[n];\n+\t      mangled = &remembered_type;\n+\t    }\n+\t  break;\n+\n+\t/* A function */\n+\tcase 'F':\n+\t  (*mangled)++;\n+\t  if (!STRING_EMPTY (&decl) && decl.b[0] == '*')\n+\t    {\n+\t      string_prepend (&decl, \"(\");\n+\t      string_append (&decl, \")\");\n+\t    }\n+\t  /* After picking off the function args, we expect to either find the\n+\t     function return type (preceded by an '_') or the end of the\n+\t     string. */\n+\t  if (!demangle_args (work, mangled, &decl)\n+\t      || (**mangled != '_' && **mangled != '\\0'))\n+\t    {\n+\t      success = 0;\n+\t    }\n+\t  if (success && (**mangled == '_'))\n+\t    {\n+\t      (*mangled)++;\n+\t    }\n+\t  break;\n+\n+\tcase 'M':\n+\tcase 'O':\n+\t  {\n+\t    constp = 0;\n+\t    volatilep = 0;\n+\n+\t    member = **mangled == 'M';\n+\t    (*mangled)++;\n+\t    if (!isdigit (**mangled))\n+\t      {\n+\t\tsuccess = 0;\n+\t\tbreak;\n+\t      }\n+\t    n = consume_count (mangled);\n+\t    if (strlen (*mangled) < n)\n+\t      {\n+\t\tsuccess = 0;\n+\t\tbreak;\n+\t      }\n+\t    string_append (&decl, \")\");\n+\t    string_prepend (&decl, \"::\");\n+\t    string_prependn (&decl, *mangled, n);\n+\t    string_prepend (&decl, \"(\");\n+\t    *mangled += n;\n+\t    if (member)\n+\t      {\n+\t\tif (**mangled == 'C')\n+\t\t  {\n+\t\t    (*mangled)++;\n+\t\t    constp = 1;\n+\t\t  }\n+\t\tif (**mangled == 'V')\n+\t\t  {\n+\t\t    (*mangled)++;\n+\t\t    volatilep = 1;\n+\t\t  }\n+\t\tif (*(*mangled)++ != 'F')\n+\t\t  {\n+\t\t    success = 0;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    if ((member && !demangle_args (work, mangled, &decl))\n+\t\t|| **mangled != '_')\n+\t      {\n+\t\tsuccess = 0;\n+\t\tbreak;\n+\t      }\n+\t    (*mangled)++;\n+\t    if (! PRINT_ANSI_QUALIFIERS)\n+\t      {\n+\t\tbreak;\n+\t      }\n+\t    if (constp)\n+\t      {\n+\t\tAPPEND_BLANK (&decl);\n+\t\tstring_append (&decl, \"const\");\n+\t      }\n+\t    if (volatilep)\n+\t      {\n+\t\tAPPEND_BLANK (&decl);\n+\t\tstring_append (&decl, \"volatile\");\n+\t      }\n+\t    break;\n+\t  }\n+        case 'G':\n+\t    (*mangled)++;\n+\t    break;\n+\n+\tcase 'C':\n+\t  (*mangled)++;\n+/*\n+\t  if ((*mangled)[1] == 'P')\n+\t    {\n+*/\n+\t      if (PRINT_ANSI_QUALIFIERS)\n+\t\t{\n+\t\t  if (!STRING_EMPTY (&decl))\n+\t\t    {\n+\t\t      string_prepend (&decl, \" \");\n+\t\t    }\n+\t\t  string_prepend (&decl, \"const\");\n+\t\t}\n+\t      break;\n+/*\n+\t    }\n+*/\n+\n+\t  /* fall through */\n+\tdefault:\n+\t  done = 1;\n+\t  break;\n+\t}\n+    }\n+\n+  switch (**mangled)\n+    {\n+      /* A qualified name, such as \"Outer::Inner\". */\n+      case 'Q':\n+        success = demangle_qualified (work, mangled, result, 0, 1);\n+\tbreak;\n+\n+      default:\n+\tsuccess = demangle_fund_type (work, mangled, result);\n+\tbreak;\n+    }\n+\n+  if (success)\n+    {\n+      if (!STRING_EMPTY (&decl))\n+\t{\n+\t  string_append (result, \" \");\n+\t  string_appends (result, &decl);\n+\t}\n+    }\n+  else\n+    {\n+      string_delete (result);\n+    }\n+  string_delete (&decl);\n+  return (success);\n+}\n+\n+/* Given a pointer to a type string that represents a fundamental type\n+   argument (int, long, unsigned int, etc) in TYPE, a pointer to the\n+   string in which the demangled output is being built in RESULT, and\n+   the WORK structure, decode the types and add them to the result.\n+\n+   For example:\n+\n+   \t\"Ci\"\t=>\t\"const int\"\n+\t\"Sl\"\t=>\t\"signed long\"\n+\t\"CUs\"\t=>\t\"const unsigned short\"\n+\n+   */\n+\n+static int\n+demangle_fund_type (work, mangled, result)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string *result;\n+{\n+  int done = 0;\n+  int success = 1;\n+\n+  /* First pick off any type qualifiers.  There can be more than one. */\n+\n+  while (!done)\n+    {\n+      switch (**mangled)\n+\t{\n+\t  case 'C':\n+\t    (*mangled)++;\n+\t    if (PRINT_ANSI_QUALIFIERS)\n+\t      {\n+\t\tAPPEND_BLANK (result);\n+\t\tstring_append (result, \"const\");\n+\t      }\n+\t    break;\n+\t  case 'U':\n+\t    (*mangled)++;\n+\t    APPEND_BLANK (result);\n+\t    string_append (result, \"unsigned\");\n+\t    break;\n+\t  case 'S': /* signed char only */\n+\t    (*mangled)++;\n+\t    APPEND_BLANK (result);\n+\t    string_append (result, \"signed\");\n+\t    break;\n+\t  case 'V':\n+\t    (*mangled)++;\n+\t    if (PRINT_ANSI_QUALIFIERS)\n+\t      {\n+\t\tAPPEND_BLANK (result);\n+\t\tstring_append (result, \"volatile\");\n+\t      }\n+\t    break;\n+\t  default:\n+\t    done = 1;\n+\t    break;\n+\t}\n+    }\n+\n+  /* Now pick off the fundamental type.  There can be only one. */\n+\n+  switch (**mangled)\n+    {\n+      case '\\0':\n+      case '_':\n+\tbreak;\n+      case 'v':\n+\t(*mangled)++;\n+\tAPPEND_BLANK (result);\n+\tstring_append (result, \"void\");\n+\tbreak;\n+      case 'x':\n+\t(*mangled)++;\n+\tAPPEND_BLANK (result);\n+\tstring_append (result, \"long long\");\n+\tbreak;\n+      case 'l':\n+\t(*mangled)++;\n+\tAPPEND_BLANK (result);\n+\tstring_append (result, \"long\");\n+\tbreak;\n+      case 'i':\n+\t(*mangled)++;\n+\tAPPEND_BLANK (result);\n+\tstring_append (result, \"int\");\n+\tbreak;\n+      case 's':\n+\t(*mangled)++;\n+\tAPPEND_BLANK (result);\n+\tstring_append (result, \"short\");\n+\tbreak;\n+      case 'b':\n+\t(*mangled)++;\n+\tAPPEND_BLANK (result);\n+\tstring_append (result, \"bool\");\n+\tbreak;\n+      case 'c':\n+\t(*mangled)++;\n+\tAPPEND_BLANK (result);\n+\tstring_append (result, \"char\");\n+\tbreak;\n+      case 'w':\n+\t(*mangled)++;\n+\tAPPEND_BLANK (result);\n+\tstring_append (result, \"wchar_t\");\n+\tbreak;\n+      case 'r':\n+\t(*mangled)++;\n+\tAPPEND_BLANK (result);\n+\tstring_append (result, \"long double\");\n+\tbreak;\n+      case 'd':\n+\t(*mangled)++;\n+\tAPPEND_BLANK (result);\n+\tstring_append (result, \"double\");\n+\tbreak;\n+      case 'f':\n+\t(*mangled)++;\n+\tAPPEND_BLANK (result);\n+\tstring_append (result, \"float\");\n+\tbreak;\n+      case 'G':\n+\t(*mangled)++;\n+\tif (!isdigit (**mangled))\n+\t  {\n+\t    success = 0;\n+\t    break;\n+\t  }\n+\t/* fall through */\n+      /* An explicit type, such as \"6mytype\" or \"7integer\" */\n+      case '0':\n+      case '1':\n+      case '2':\n+      case '3':\n+      case '4':\n+      case '5':\n+      case '6':\n+      case '7':\n+      case '8':\n+      case '9':\n+\tAPPEND_BLANK (result);\n+\tif (!demangle_class_name (work, mangled, result)) {\n+\t  --result->p;\n+\t  success = 0;\n+\t}\n+\tbreak;\n+      case 't':\n+        success = demangle_template(work,mangled, result, 0);\n+        break;\n+      default:\n+\tsuccess = 0;\n+\tbreak;\n+      }\n+\n+  return (success);\n+}\n+\n+/* `result' will be initialized in do_type; it will be freed on failure */\n+\n+static int\n+do_arg (work, mangled, result)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string *result;\n+{\n+  const char *start = *mangled;\n+\n+  if (!do_type (work, mangled, result))\n+    {\n+      return (0);\n+    }\n+  else\n+    {\n+      remember_type (work, start, *mangled - start);\n+      return (1);\n+    }\n+}\n+\n+static void\n+remember_type (work, start, len)\n+     struct work_stuff *work;\n+     const char *start;\n+     int len;\n+{\n+  char *tem;\n+\n+  if (work -> ntypes >= work -> typevec_size)\n+    {\n+      if (work -> typevec_size == 0)\n+\t{\n+\t  work -> typevec_size = 3;\n+\t  work -> typevec =\n+\t    (char **) xmalloc (sizeof (char *) * work -> typevec_size);\n+\t}\n+      else\n+\t{\n+\t  work -> typevec_size *= 2;\n+\t  work -> typevec =\n+\t    (char **) xrealloc ((char *)work -> typevec,\n+\t\t\t\tsizeof (char *) * work -> typevec_size);\n+\t}\n+    }\n+  tem = xmalloc (len + 1);\n+  memcpy (tem, start, len);\n+  tem[len] = '\\0';\n+  work -> typevec[work -> ntypes++] = tem;\n+}\n+\n+/* Forget the remembered types, but not the type vector itself. */\n+\n+static void\n+forget_types (work)\n+     struct work_stuff *work;\n+{\n+  int i;\n+\n+  while (work -> ntypes > 0)\n+    {\n+      i = --(work -> ntypes);\n+      if (work -> typevec[i] != NULL)\n+\t{\n+\t  free (work -> typevec[i]);\n+\t  work -> typevec[i] = NULL;\n+\t}\n+    }\n+}\n+\n+/* Process the argument list part of the signature, after any class spec\n+   has been consumed, as well as the first 'F' character (if any).  For\n+   example:\n+\n+   \"__als__3fooRT0\"\t\t=>\tprocess \"RT0\"\n+   \"complexfunc5__FPFPc_PFl_i\"\t=>\tprocess \"PFPc_PFl_i\"\n+\n+   DECLP must be already initialised, usually non-empty.  It won't be freed\n+   on failure.\n+\n+   Note that g++ differs significantly from ARM and lucid style mangling\n+   with regards to references to previously seen types.  For example, given\n+   the source fragment:\n+\n+     class foo {\n+       public:\n+       foo::foo (int, foo &ia, int, foo &ib, int, foo &ic);\n+     };\n+\n+     foo::foo (int, foo &ia, int, foo &ib, int, foo &ic) { ia = ib = ic; }\n+     void foo (int, foo &ia, int, foo &ib, int, foo &ic) { ia = ib = ic; }\n+\n+   g++ produces the names:\n+\n+     __3fooiRT0iT2iT2\n+     foo__FiR3fooiT1iT1\n+\n+   while lcc (and presumably other ARM style compilers as well) produces:\n+\n+     foo__FiR3fooT1T2T1T2\n+     __ct__3fooFiR3fooT1T2T1T2\n+\n+   Note that g++ bases it's type numbers starting at zero and counts all\n+   previously seen types, while lucid/ARM bases it's type numbers starting\n+   at one and only considers types after it has seen the 'F' character\n+   indicating the start of the function args.  For lucid/ARM style, we\n+   account for this difference by discarding any previously seen types when\n+   we see the 'F' character, and subtracting one from the type number\n+   reference.\n+\n+ */\n+\n+static int\n+demangle_args (work, mangled, declp)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string *declp;\n+{\n+  string arg;\n+  int need_comma = 0;\n+  int r;\n+  int t;\n+  const char *tem;\n+  char temptype;\n+\n+  if (PRINT_ARG_TYPES)\n+    {\n+      string_append (declp, \"(\");\n+      if (**mangled == '\\0')\n+\t{\n+\t  string_append (declp, \"void\");\n+\t}\n+    }\n+\n+  while (**mangled != '_' && **mangled != '\\0' && **mangled != 'e')\n+    {\n+      if ((**mangled == 'N') || (**mangled == 'T'))\n+\t{\n+\t  temptype = *(*mangled)++;\n+\t  \n+\t  if (temptype == 'N')\n+\t    {\n+\t      if (!get_count (mangled, &r))\n+\t\t{\n+\t\t  return (0);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      r = 1;\n+\t    }\n+          if (ARM_DEMANGLING && work -> ntypes >= 10)\n+            {\n+              /* If we have 10 or more types we might have more than a 1 digit\n+                 index so we'll have to consume the whole count here. This\n+                 will loose if the next thing is a type name preceeded by a\n+                 count but it's impossible to demangle that case properly\n+                 anyway. Eg if we already have 12 types is T12Pc \"(..., type1,\n+                 anyway. Eg if we already have 12 types is T12Pc \"(..., type1,\n+                 Pc, ...)\"  or \"(..., type12, char *, ...)\" */\n+              if ((t = consume_count(mangled)) == 0)\n+                {\n+                  return (0);\n+                }\n+            }\n+          else\n+\t    {\n+\t      if (!get_count (mangled, &t))\n+\t    \t{\n+\t          return (0);\n+\t    \t}\n+\t    }\n+\t  if (LUCID_DEMANGLING || ARM_DEMANGLING)\n+\t    {\n+\t      t--;\n+\t    }\n+\t  /* Validate the type index.  Protect against illegal indices from\n+\t     malformed type strings. */\n+\t  if ((t < 0) || (t >= work -> ntypes))\n+\t    {\n+\t      return (0);\n+\t    }\n+\t  while (--r >= 0)\n+\t    {\n+\t      tem = work -> typevec[t];\n+\t      if (need_comma && PRINT_ARG_TYPES)\n+\t\t{\n+\t\t  string_append (declp, \", \");\n+\t\t}\n+\t      if (!do_arg (work, &tem, &arg))\n+\t\t{\n+\t\t  return (0);\n+\t\t}\n+\t      if (PRINT_ARG_TYPES)\n+\t\t{\n+\t\t  string_appends (declp, &arg);\n+\t\t}\n+\t      string_delete (&arg);\n+\t      need_comma = 1;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (need_comma & PRINT_ARG_TYPES)\n+\t    {\n+\t      string_append (declp, \", \");\n+\t    }\n+\t  if (!do_arg (work, mangled, &arg))\n+\t    {\n+\t      return (0);\n+\t    }\n+\t  if (PRINT_ARG_TYPES)\n+\t    {\n+\t      string_appends (declp, &arg);\n+\t    }\n+\t  string_delete (&arg);\n+\t  need_comma = 1;\n+\t}\n+    }\n+\n+  if (**mangled == 'e')\n+    {\n+      (*mangled)++;\n+      if (PRINT_ARG_TYPES)\n+\t{\n+\t  if (need_comma)\n+\t    {\n+\t      string_append (declp, \",\");\n+\t    }\n+\t  string_append (declp, \"...\");\n+\t}\n+    }\n+\n+  if (PRINT_ARG_TYPES)\n+    {\n+      string_append (declp, \")\");\n+    }\n+  return (1);\n+}\n+\n+static void\n+demangle_function_name (work, mangled, declp, scan)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string *declp;\n+     const char *scan;\n+{\n+  int i;\n+  int len;\n+  string type;\n+  const char *tem;\n+\n+  string_appendn (declp, (*mangled), scan - (*mangled));\n+  string_need (declp, 1);\n+  *(declp -> p) = '\\0';\n+\n+  /* Consume the function name, including the \"__\" separating the name\n+     from the signature.  We are guaranteed that SCAN points to the\n+     separator. */\n+\n+  (*mangled) = scan + 2;\n+\n+  if (LUCID_DEMANGLING || ARM_DEMANGLING)\n+    {\n+\n+      /* See if we have an ARM style constructor or destructor operator.\n+\t If so, then just record it, clear the decl, and return.\n+\t We can't build the actual constructor/destructor decl until later,\n+\t when we recover the class name from the signature. */\n+\n+      if (strcmp (declp -> b, \"__ct\") == 0)\n+\t{\n+\t  work -> constructor += 1;\n+\t  string_clear (declp);\n+\t  return;\n+\t}\n+      else if (strcmp (declp -> b, \"__dt\") == 0)\n+\t{\n+\t  work -> destructor += 1;\n+\t  string_clear (declp);\n+\t  return;\n+\t}\n+    }\n+\n+  if (declp->p - declp->b >= 3 \n+      && declp->b[0] == 'o'\n+      && declp->b[1] == 'p'\n+      && strchr (cplus_markers, declp->b[2]) != NULL)\n+    {\n+      /* see if it's an assignment expression */\n+      if (declp->p - declp->b >= 10 /* op$assign_ */\n+\t  && memcmp (declp->b + 3, \"assign_\", 7) == 0)\n+\t{\n+\t  for (i = 0; i < sizeof (optable) / sizeof (optable[0]); i++)\n+\t    {\n+\t      len = declp->p - declp->b - 10;\n+\t      if (strlen (optable[i].in) == len\n+\t\t  && memcmp (optable[i].in, declp->b + 10, len) == 0)\n+\t\t{\n+\t\t  string_clear (declp);\n+\t\t  string_append (declp, \"operator\");\n+\t\t  string_append (declp, optable[i].out);\n+\t\t  string_append (declp, \"=\");\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (i = 0; i < sizeof (optable) / sizeof (optable[0]); i++)\n+\t    {\n+\t      int len = declp->p - declp->b - 3;\n+\t      if (strlen (optable[i].in) == len \n+\t\t  && memcmp (optable[i].in, declp->b + 3, len) == 0)\n+\t\t{\n+\t\t  string_clear (declp);\n+\t\t  string_append (declp, \"operator\");\n+\t\t  string_append (declp, optable[i].out);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else if (declp->p - declp->b >= 5 && memcmp (declp->b, \"type\", 4) == 0\n+\t   && strchr (cplus_markers, declp->b[4]) != NULL)\n+    {\n+      /* type conversion operator */\n+      tem = declp->b + 5;\n+      if (do_type (work, &tem, &type))\n+\t{\n+\t  string_clear (declp);\n+\t  string_append (declp, \"operator \");\n+\t  string_appends (declp, &type);\n+\t  string_delete (&type);\n+\t}\n+    }\n+  else if (declp->b[0] == '_' && declp->b[1] == '_'\n+\t  && declp->b[2] == 'o' && declp->b[3] == 'p')\n+    {\n+      /* ANSI.  */\n+      /* type conversion operator.  */\n+      tem = declp->b + 4;\n+      if (do_type (work, &tem, &type))\n+\t{\n+\t  string_clear (declp);\n+\t  string_append (declp, \"operator \");\n+\t  string_appends (declp, &type);\n+\t  string_delete (&type);\n+\t}\n+    }\n+  else if (declp->b[0] == '_' && declp->b[1] == '_'\n+\t   && declp->b[2] >= 'a' && declp->b[2] <= 'z'\n+\t   && declp->b[3] >= 'a' && declp->b[3] <= 'z')\n+    {\n+      if (declp->b[4] == '\\0')\n+\t{\n+\t  /* Operator.  */\n+\t  for (i = 0; i < sizeof (optable) / sizeof (optable[0]); i++)\n+\t    {\n+\t      if (strlen (optable[i].in) == 2\n+\t\t  && memcmp (optable[i].in, declp->b + 2, 2) == 0)\n+\t\t{\n+\t\t  string_clear (declp);\n+\t\t  string_append (declp, \"operator\");\n+\t\t  string_append (declp, optable[i].out);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (declp->b[2] == 'a' && declp->b[5] == '\\0')\n+\t    {\n+\t      /* Assignment. */\n+\t      for (i = 0; i < sizeof (optable) / sizeof (optable[0]); i++)\n+\t\t{\n+\t\t  if (strlen (optable[i].in) == 3\n+\t\t      && memcmp (optable[i].in, declp->b + 2, 3) == 0)\n+\t\t    {\n+\t\t      string_clear (declp);\n+\t\t      string_append (declp, \"operator\");\n+\t\t      string_append (declp, optable[i].out);\n+\t\t      break;\n+\t\t    }\t\t      \n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* a mini string-handling package */\n+\n+static void\n+string_need (s, n)\n+     string *s;\n+     int n;\n+{\n+  int tem;\n+\n+  if (s->b == NULL)\n+    {\n+      if (n < 32)\n+\t{\n+\t  n = 32;\n+\t}\n+      s->p = s->b = xmalloc (n);\n+      s->e = s->b + n;\n+    }\n+  else if (s->e - s->p < n)\n+    {\n+      tem = s->p - s->b;\n+      n += tem;\n+      n *= 2;\n+      s->b = xrealloc (s->b, n);\n+      s->p = s->b + tem;\n+      s->e = s->b + n;\n+    }\n+}\n+\n+static void\n+string_delete (s)\n+     string *s;\n+{\n+  if (s->b != NULL)\n+    {\n+      free (s->b);\n+      s->b = s->e = s->p = NULL;\n+    }\n+}\n+\n+static void\n+string_init (s)\n+     string *s;\n+{\n+  s->b = s->p = s->e = NULL;\n+}\n+\n+static void \n+string_clear (s)\n+     string *s;\n+{\n+  s->p = s->b;\n+}\n+\n+#if 0\n+\n+static int\n+string_empty (s)\n+     string *s;\n+{\n+  return (s->b == s->p);\n+}\n+\n+#endif\n+\n+static void\n+string_append (p, s)\n+     string *p;\n+     const char *s;\n+{\n+  int n;\n+  if (s == NULL || *s == '\\0')\n+    return;\n+  n = strlen (s);\n+  string_need (p, n);\n+  memcpy (p->p, s, n);\n+  p->p += n;\n+}\n+\n+static void\n+string_appends (p, s)\n+     string *p, *s;\n+{\n+  int n;\n+\n+  if (s->b != s->p)\n+    {\n+      n = s->p - s->b;\n+      string_need (p, n);\n+      memcpy (p->p, s->b, n);\n+      p->p += n;\n+    }\n+}\n+\n+static void\n+string_appendn (p, s, n)\n+     string *p;\n+     const char *s;\n+     int n;\n+{\n+  if (n != 0)\n+    {\n+      string_need (p, n);\n+      memcpy (p->p, s, n);\n+      p->p += n;\n+    }\n+}\n+\n+static void\n+string_prepend (p, s)\n+     string *p;\n+     const char *s;\n+{\n+  if (s != NULL && *s != '\\0')\n+    {\n+      string_prependn (p, s, strlen (s));\n+    }\n+}\n+\n+static void\n+string_prepends (p, s)\n+     string *p, *s;\n+{\n+  if (s->b != s->p)\n+    {\n+      string_prependn (p, s->b, s->p - s->b);\n+    }\n+}\n+\n+static void\n+string_prependn (p, s, n)\n+     string *p;\n+     const char *s;\n+     int n;\n+{\n+  char *q;\n+\n+  if (n != 0)\n+    {\n+      string_need (p, n);\n+      for (q = p->p - 1; q >= p->b; q--)\n+\t{\n+\t  q[n] = q[0];\n+\t}\n+      memcpy (p->b, s, n);\n+      p->p += n;\n+    }\n+}\n+\n+/* To generate a standalone demangler program for testing purposes,\n+   just compile and link this file with -DMAIN and libiberty.a.  When\n+   run, it demangles each command line arg, or each stdin string, and\n+   prints the result on stdout. */\n+\n+#ifdef MAIN\n+\n+static void\n+demangle_it (mangled_name)\n+  char *mangled_name;\n+{\n+  char *result;\n+\n+  result = cplus_demangle (mangled_name, DMGL_PARAMS | DMGL_ANSI);\n+  if (result == NULL)\n+    {\n+      printf (\"%s\\n\", mangled_name);\n+    }\n+  else\n+    {\n+      printf (\"%s\\n\", result);\n+      free (result);\n+    }\n+}\n+\n+#include \"getopt.h\"\n+\n+static char *program_name;\n+static char *program_version = VERSION;\n+\n+static void\n+usage (stream, status)\n+     FILE *stream;\n+     int status;\n+{    \n+  fprintf (stream, \"\\\n+Usage: %s [-_] [-n] [-s {gnu,lucid,arm}] [--strip-underscores]\\n\\\n+       [--no-strip-underscores] [--format={gnu,lucid,arm}]\\n\\\n+       [--help] [--version] [arg...]\\n\",\n+\t   program_name);\n+  exit (status);\n+}\n+\n+#define MBUF_SIZE 512\n+char mbuffer[MBUF_SIZE];\n+\n+/* Defined in the automatically-generated underscore.c. */\n+extern int prepends_underscore;\n+\n+int strip_underscore = 0;\n+\n+static struct option long_options[] = {\n+  {\"strip-underscores\", no_argument, 0, '_'},\n+  {\"format\", required_argument, 0, 's'},\n+  {\"help\", no_argument, 0, 'h'},\n+  {\"no-strip-underscores\", no_argument, 0, 'n'},\n+  {\"version\", no_argument, 0, 'v'},\n+  {0, no_argument, 0, 0}\n+};\n+\n+int\n+main (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  char *result;\n+  int c;\n+\n+  program_name = argv[0];\n+\n+  strip_underscore = prepends_underscore;\n+\n+  while ((c = getopt_long (argc, argv, \"_ns:\", long_options, (int *) 0)) != EOF)\n+    {\n+      switch (c)\n+\t{\n+\t  case '?':\n+\t    usage (stderr, 1);\n+\t    break;\n+\t  case 'h':\n+\t    usage (stdout, 0);\n+\t  case 'n':\n+\t    strip_underscore = 0;\n+\t    break;\n+\t  case 'v':\n+\t    printf (\"GNU %s version %s\\n\", program_name, program_version);\n+\t    exit (0);\n+\t  case '_':\n+\t    strip_underscore = 1;\n+\t    break;\n+\t  case 's':\n+\t    if (strcmp (optarg, \"gnu\") == 0)\n+\t      {\n+\t\tcurrent_demangling_style = gnu_demangling;\n+\t      }\n+\t    else if (strcmp (optarg, \"lucid\") == 0)\n+\t      {\n+\t\tcurrent_demangling_style = lucid_demangling;\n+\t      }\n+\t    else if (strcmp (optarg, \"arm\") == 0)\n+\t      {\n+\t\tcurrent_demangling_style = arm_demangling;\n+\t      }\n+\t    else\n+\t      {\n+\t\tfprintf (stderr, \"%s: unknown demangling style `%s'\\n\",\n+\t\t\t program_name, optarg);\n+\t\texit (1);\n+\t      }\n+\t    break;\n+\t}\n+    }\n+\n+  if (optind < argc)\n+    {\n+      for ( ; optind < argc; optind++)\n+\t{\n+\t  demangle_it (argv[optind]);\n+\t}\n+    }\n+  else\n+    {\n+      for (;;)\n+\t{\n+\t  int i = 0;\n+\t  c = getchar ();\n+\t  /* Try to read a label. */\n+\t  while (c != EOF && (isalnum(c) || c == '_' || c == '$' || c == '.'))\n+\t    {\n+\t      if (i >= MBUF_SIZE-1)\n+\t\tbreak;\n+\t      mbuffer[i++] = c;\n+\t      c = getchar ();\n+\t    }\n+\t  if (i > 0)\n+\t    {\n+\t      int skip_first = 0;\n+\n+\t      if (mbuffer[0] == '.')\n+\t\t++skip_first;\n+\t      if (strip_underscore && mbuffer[skip_first] == '_')\n+\t\t++skip_first;\n+\n+\t      if (skip_first > i)\n+\t\tskip_first = i;\n+\n+\t      mbuffer[i] = 0;\n+\t      \n+\t      result = cplus_demangle (mbuffer + skip_first,\n+\t\t\t\t       DMGL_PARAMS | DMGL_ANSI);\n+\t      if (result)\n+\t\t{\n+\t\t  if (mbuffer[0] == '.')\n+\t\t    putc ('.', stdout);\n+\t\t  fputs (result, stdout);\n+\t\t  free (result);\n+\t\t}\n+\t      else\n+\t\tfputs (mbuffer, stdout);\n+\n+\t      fflush (stdout);\n+\t    }\n+\t  if (c == EOF)\n+\t    break;\n+\t  putchar (c);\n+\t}\n+    }\n+\n+  exit (0);\n+}\n+\n+static void\n+fatal (str)\n+     char *str;\n+{\n+  fprintf (stderr, \"%s: %s\\n\", program_name, str);\n+  exit (1);\n+}\n+\n+char * malloc ();\n+char * realloc ();\n+\n+char *\n+xmalloc (size)\n+     unsigned size;\n+{\n+  register char *value = (char *) malloc (size);\n+  if (value == 0)\n+    fatal (\"virtual memory exhausted\");\n+  return value;\n+}\n+\n+char *\n+xrealloc (ptr, size)\n+     char *ptr;\n+     unsigned size;\n+{\n+  register char *value = (char *) realloc (ptr, size);\n+  if (value == 0)\n+    fatal (\"virtual memory exhausted\");\n+  return value;\n+}\n+#endif\t/* main */"}, {"sha": "811406a2d787e03b7ca51ee1af6085f839e59638", "filename": "gcc/demangle.h", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a31844688a498c9f57ea71be5180da3e697b919e/gcc%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a31844688a498c9f57ea71be5180da3e697b919e/gcc%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdemangle.h?ref=a31844688a498c9f57ea71be5180da3e697b919e", "patch": "@@ -0,0 +1,107 @@\n+/* Defs for interface to demanglers.\n+   Copyright 1992, 1995 Free Software Foundation, Inc.\n+   \n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#if !defined (DEMANGLE_H)\n+#define DEMANGLE_H\n+\n+#ifdef IN_GCC\n+\n+/* Add prototype support.  */\n+#ifndef PROTO\n+#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)\n+#define PROTO(ARGS) ARGS\n+#else\n+#define PROTO(ARGS) ()\n+#endif\n+#endif\n+\n+#define PARAMS(ARGS) PROTO(ARGS)\n+\n+#ifdef __STDC__\n+#define PTR void *\n+#else\n+#ifndef const\n+#define const\n+#endif\n+#define PTR char *\n+#endif\n+\n+#else /* ! IN_GCC */\n+#include <ansidecl.h>\n+#endif /* IN_GCC */\n+\n+/* Options passed to cplus_demangle (in 2nd parameter). */\n+\n+#define DMGL_NO_OPTS\t0\t\t/* For readability... */\n+#define DMGL_PARAMS\t(1 << 0)\t/* Include function args */\n+#define DMGL_ANSI\t(1 << 1)\t/* Include const, volatile, etc */\n+\n+#define DMGL_AUTO\t(1 << 8)\n+#define DMGL_GNU\t(1 << 9)\n+#define DMGL_LUCID\t(1 << 10)\n+#define DMGL_ARM\t(1 << 11)\n+/* If none of these are set, use 'current_demangling_style' as the default. */\n+#define DMGL_STYLE_MASK (DMGL_AUTO|DMGL_GNU|DMGL_LUCID|DMGL_ARM)\n+\n+/* Enumeration of possible demangling styles.\n+\n+   Lucid and ARM styles are still kept logically distinct, even though\n+   they now both behave identically.  The resulting style is actual the\n+   union of both.  I.E. either style recognizes both \"__pt__\" and \"__rf__\"\n+   for operator \"->\", even though the first is lucid style and the second\n+   is ARM style. (FIXME?) */\n+\n+extern enum demangling_styles\n+{\n+  unknown_demangling = 0,\n+  auto_demangling = DMGL_AUTO,\n+  gnu_demangling = DMGL_GNU,\n+  lucid_demangling = DMGL_LUCID,\n+  arm_demangling = DMGL_ARM\n+} current_demangling_style;\n+\n+/* Define string names for the various demangling styles. */\n+\n+#define AUTO_DEMANGLING_STYLE_STRING\t\"auto\"\n+#define GNU_DEMANGLING_STYLE_STRING\t\"gnu\"\n+#define LUCID_DEMANGLING_STYLE_STRING\t\"lucid\"\n+#define ARM_DEMANGLING_STYLE_STRING\t\"arm\"\n+\n+/* Some macros to test what demangling style is active. */\n+\n+#define CURRENT_DEMANGLING_STYLE current_demangling_style\n+#define AUTO_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_AUTO)\n+#define GNU_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_GNU)\n+#define LUCID_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_LUCID)\n+#define ARM_DEMANGLING (CURRENT_DEMANGLING_STYLE & DMGL_ARM)\n+\n+extern char *\n+cplus_demangle PARAMS ((const char *mangled, int options));\n+\n+extern int\n+cplus_demangle_opname PARAMS ((char *opname, char *result, int options));\n+\n+extern char *\n+cplus_mangle_opname PARAMS ((char *opname, int options));\n+\n+/* Note: This sets global state.  FIXME if you care about multi-threading. */\n+\n+extern void\n+set_cplus_marker_for_demangling PARAMS ((int ch));\n+\n+#endif\t/* DEMANGLE_H */"}]}