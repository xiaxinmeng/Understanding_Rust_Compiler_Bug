{"sha": "63866e04b770cefcfa0c64b427dc924cce475201", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM4NjZlMDRiNzcwY2VmY2ZhMGM2NGI0MjdkYzkyNGNjZTQ3NTIwMQ==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2017-07-10T09:49:18Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2017-07-10T09:49:18Z"}, "message": "Better ISR prologues by supporting GASes __gcc_isr pseudo insn.\n\ngcc/\n\tBetter ISR prologues by supporting GASes __gcc_isr pseudo insn.\n\tPR target/20296\n\tPR target/81268\n\t* configure.ac [target=avr]: Add GAS check for -mgcc-isr.\n\t(HAVE_AS_AVR_MGCCISR_OPTION):  If so, AC_DEFINE it.\n\t* config.in: Regenerate.\n\t* configure: Regenerate.\n\t* doc/extend.texi (AVR Function Attributes) <no_gccisr>: Document it.\n\t* doc/invoke.texi (AVR Options) <-mgas-isr-prologues>: Document it.\n\t* config/avr/avr.opt (-mgas-isr-prologues): New option and...\n\t(TARGET_GASISR_PROLOGUES): ...target mask.\n\t* common/config/avr/avr-common.c\n\t(avr_option_optimization_table) [OPT_LEVELS_1_PLUS_NOT_DEBUG]:\n\tSet -mgas-isr-prologues.\n\t* config/avr/avr-passes.def (avr_pass_pre_proep): Add\n\tINSERT_PASS_BEFORE for it.\n\t* config/avr/avr-protos.h (make_avr_pass_pre_proep): New proto.\n\t* config/avr/avr.c (avr_option_override)\n\t[!HAVE_AS_AVR_MGCCISR_OPTION]: Unset TARGET_GASISR_PROLOGUES.\n\t(avr_no_gccisr_function_p, avr_hregs_split_reg): New static functions.\n\t(avr_attribute_table) <no_gccisr>: Add new function attribute.\n\t(avr_set_current_function) <is_no_gccisr>: Init machine field.\n\t(avr_pass_data_pre_proep, avr_pass_pre_proep): New pass data\n\tand rtl_opt_pass.\n\t(make_avr_pass_pre_proep): New function.\n\t(emit_push_sfr) <treg>: Add argument to function and use it\n\tinstead of TMP_REG.\n\t(avr_expand_prologue) [machine->gasisr.maybe]: Emit gasisr insn\n\tand set machine->gasisr.yes.\n\t(avr_expand_epilogue) [machine->gasisr.yes]: Similar.\n\t(avr_asm_function_end_prologue) [machine->gasisr.yes]: Add\n\t__gcc_isr.n_pushed to .L__stack_usage.\n\t(TARGET_ASM_FINAL_POSTSCAN_INSN): Define to...\n\t(avr_asm_final_postscan_insn): ...this new static function.\n\t* config/avr/avr.h (machine_function)\n\t<is_no_gccisr, use_L__stack_usage>: New fields.\n\t<gasisr, gasisr.yes, gasisr.maybe, gasisr.regno>: New fields.\n\t* config/avr/avr.md (UNSPECV_GASISR): Add unspecv enum.\n\t(GASISR_Prologue, GASISR_Epilogue, GASISR_Done): New define_constants.\n\t(gasisr, *gasisr): New expander and insn.\n\t* config/avr/gen-avr-mmcu-specs.c (print_mcu)\n\t[HAVE_AS_AVR_MGCCISR_OPTION]: Print asm_gccisr spec.\n\t* config/avr/specs.h (ASM_SPEC) <asm_gccisr>: Add sub spec.\n\nFrom-SVN: r250093", "tree": {"sha": "fba252f8ceeea7879e3cf77eb3f76b8cb5e262d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fba252f8ceeea7879e3cf77eb3f76b8cb5e262d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63866e04b770cefcfa0c64b427dc924cce475201", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63866e04b770cefcfa0c64b427dc924cce475201", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63866e04b770cefcfa0c64b427dc924cce475201", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63866e04b770cefcfa0c64b427dc924cce475201/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ff62510e0d3d35889cc4744340923d58297eab9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ff62510e0d3d35889cc4744340923d58297eab9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ff62510e0d3d35889cc4744340923d58297eab9"}], "stats": {"total": 549, "additions": 501, "deletions": 48}, "files": [{"sha": "73cb4fef085ccb0417688ee9dcf7dd51a4504859", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=63866e04b770cefcfa0c64b427dc924cce475201", "patch": "@@ -1,3 +1,50 @@\n+2017-07-10  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tBetter ISR prologues by supporting GASes __gcc_isr pseudo insn.\n+\n+\tPR target/20296\n+\tPR target/81268\n+\t* configure.ac [target=avr]: Add GAS check for -mgcc-isr.\n+\t(HAVE_AS_AVR_MGCCISR_OPTION):  If so, AC_DEFINE it.\n+\t* config.in: Regenerate.\n+\t* configure: Regenerate.\n+\t* doc/extend.texi (AVR Function Attributes) <no_gccisr>: Document it.\n+\t* doc/invoke.texi (AVR Options) <-mgas-isr-prologues>: Document it.\n+\t* config/avr/avr.opt (-mgas-isr-prologues): New option and...\n+\t(TARGET_GASISR_PROLOGUES): ...target mask.\n+\t* common/config/avr/avr-common.c\n+\t(avr_option_optimization_table) [OPT_LEVELS_1_PLUS_NOT_DEBUG]:\n+\tSet -mgas-isr-prologues.\n+\t* config/avr/avr-passes.def (avr_pass_pre_proep): Add\n+\tINSERT_PASS_BEFORE for it.\n+\t* config/avr/avr-protos.h (make_avr_pass_pre_proep): New proto.\n+\t* config/avr/avr.c (avr_option_override)\n+\t[!HAVE_AS_AVR_MGCCISR_OPTION]: Unset TARGET_GASISR_PROLOGUES.\n+\t(avr_no_gccisr_function_p, avr_hregs_split_reg): New static functions.\n+\t(avr_attribute_table) <no_gccisr>: Add new function attribute.\n+\t(avr_set_current_function) <is_no_gccisr>: Init machine field.\n+\t(avr_pass_data_pre_proep, avr_pass_pre_proep): New pass data\n+\tand rtl_opt_pass.\n+\t(make_avr_pass_pre_proep): New function.\n+\t(emit_push_sfr) <treg>: Add argument to function and use it\n+\tinstead of TMP_REG.\n+\t(avr_expand_prologue) [machine->gasisr.maybe]: Emit gasisr insn\n+\tand set machine->gasisr.yes.\n+\t(avr_expand_epilogue) [machine->gasisr.yes]: Similar.\n+\t(avr_asm_function_end_prologue) [machine->gasisr.yes]: Add\n+\t__gcc_isr.n_pushed to .L__stack_usage.\n+\t(TARGET_ASM_FINAL_POSTSCAN_INSN): Define to...\n+\t(avr_asm_final_postscan_insn): ...this new static function.\n+\t* config/avr/avr.h (machine_function)\n+\t<is_no_gccisr, use_L__stack_usage>: New fields.\n+\t<gasisr, gasisr.yes, gasisr.maybe, gasisr.regno>: New fields.\n+\t* config/avr/avr.md (UNSPECV_GASISR): Add unspecv enum.\n+\t(GASISR_Prologue, GASISR_Epilogue, GASISR_Done): New define_constants.\n+\t(gasisr, *gasisr): New expander and insn.\n+\t* config/avr/gen-avr-mmcu-specs.c (print_mcu)\n+\t[HAVE_AS_AVR_MGCCISR_OPTION]: Print asm_gccisr spec.\n+\t* config/avr/specs.h (ASM_SPEC) <asm_gccisr>: Add sub spec.\n+\n 2017-07-10  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/parsecpu.awk (gen_comm_data): Do not escape single quotes"}, {"sha": "4bee9d670d9565f58da527c8604191e480df667a", "filename": "gcc/common/config/avr/avr-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fcommon%2Fconfig%2Favr%2Favr-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fcommon%2Fconfig%2Favr%2Favr-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Favr%2Favr-common.c?ref=63866e04b770cefcfa0c64b427dc924cce475201", "patch": "@@ -31,6 +31,7 @@ static const struct default_options avr_option_optimization_table[] =\n     // The only effect of -fcaller-saves might be that it triggers\n     // a frame without need when it tries to be smart around calls.\n     { OPT_LEVELS_ALL, OPT_fcaller_saves, NULL, 0 },\n+    { OPT_LEVELS_1_PLUS_NOT_DEBUG, OPT_mgas_isr_prologues, NULL, 1 },\n     { OPT_LEVELS_NONE, 0, NULL, 0 }\n   };\n "}, {"sha": "89d7108e8dbd0ca0c1b8de09eb80e659aef3acca", "filename": "gcc/config.in", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=63866e04b770cefcfa0c64b427dc924cce475201", "patch": "@@ -284,6 +284,12 @@\n #endif\n \n \n+/* Define if your avr assembler supports -mgcc-isr option. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_AS_AVR_MGCCISR_OPTION\n+#endif\n+\n+\n /* Define if your avr assembler supports --mlink-relax option. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_AS_AVR_MLINK_RELAX_OPTION\n@@ -660,11 +666,13 @@\n #undef HAVE_AS_SPARC5_VIS4\n #endif\n \n+\n /* Define if your assembler supports SPARC6 instructions. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_AS_SPARC6\n #endif\n \n+\n /* Define if your assembler and linker support GOTDATA_OP relocs. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_AS_SPARC_GOTDATA_OP"}, {"sha": "340823e15c462963d68e32cfcb42325eb261c30f", "filename": "gcc/config/avr/avr-passes.def", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fconfig%2Favr%2Favr-passes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fconfig%2Favr%2Favr-passes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-passes.def?ref=63866e04b770cefcfa0c64b427dc924cce475201", "patch": "@@ -17,9 +17,12 @@\n    along with GCC; see the file COPYING3.  If not see\n    <http://www.gnu.org/licenses/>.  */\n \n-/* FIXME: We have to add the last pass first, otherwise\n-          gen-pass-instances.awk won't work as expected. */\n-          \n+/* An analysis pass that runs prior to prologue / epilogue generation.\n+   Computes cfun->machine->gasisr.maybe which is used in prologue and\n+   epilogue generation provided -mgas-isr-prologues is on.  */\n+\n+INSERT_PASS_BEFORE (pass_thread_prologue_and_epilogue, 1, avr_pass_pre_proep);\n+\n /* This avr-specific pass (re)computes insn notes, in particular REG_DEAD\n    notes which are used by `avr.c::reg_unused_after' and branch offset\n    computations.  These notes must be correct, i.e. there must be no"}, {"sha": "5d5524b2e6534d4fc5d8294c41f16bc002c22b20", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=63866e04b770cefcfa0c64b427dc924cce475201", "patch": "@@ -158,6 +158,7 @@ extern bool avr_have_dimode;\n namespace gcc { class context; }\n class rtl_opt_pass;\n \n+extern rtl_opt_pass *make_avr_pass_pre_proep (gcc::context *);\n extern rtl_opt_pass *make_avr_pass_recompute_notes (gcc::context *);\n extern rtl_opt_pass *make_avr_pass_casesi (gcc::context *);\n "}, {"sha": "d32cac64cd0fb1e667576675063bbfe692a279e1", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 276, "deletions": 42, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=63866e04b770cefcfa0c64b427dc924cce475201", "patch": "@@ -774,6 +774,10 @@ avr_option_override (void)\n   if (flag_pie == 2)\n     warning (OPT_fPIE, \"-fPIE is not supported\");\n \n+#if !defined (HAVE_AS_AVR_MGCCISR_OPTION)\n+  TARGET_GASISR_PROLOGUES = 0;\n+#endif\n+\n   if (!avr_set_core_architecture())\n     return;\n \n@@ -1007,6 +1011,15 @@ avr_OS_main_function_p (tree func)\n }\n \n \n+/* Return nonzero if FUNC is a no_gccisr function as specified\n+   by the \"no_gccisr\" attribute.  */\n+\n+static int\n+avr_no_gccisr_function_p (tree func)\n+{\n+  return avr_lookup_function_attribute1 (func, \"no_gccisr\");\n+}\n+\n /* Implement `TARGET_SET_CURRENT_FUNCTION'.  */\n /* Sanity cheching for above function attributes.  */\n \n@@ -1030,6 +1043,7 @@ avr_set_current_function (tree decl)\n   cfun->machine->is_interrupt = avr_interrupt_function_p (decl);\n   cfun->machine->is_OS_task = avr_OS_task_function_p (decl);\n   cfun->machine->is_OS_main = avr_OS_main_function_p (decl);\n+  cfun->machine->is_no_gccisr = avr_no_gccisr_function_p (decl);\n \n   isr = cfun->machine->is_interrupt ? \"interrupt\" : \"signal\";\n \n@@ -1220,6 +1234,9 @@ avr_initial_elimination_offset (int from, int to)\n       int offset = frame_pointer_needed ? 2 : 0;\n       int avr_pc_size = AVR_HAVE_EIJMP_EICALL ? 3 : 2;\n \n+      // If FROM is ARG_POINTER_REGNUM, we are not in an ISR as ISRs\n+      // might not have arguments.  Hence the following is not affected\n+      // by gasisr prologues.\n       offset += avr_regs_to_save (NULL);\n       return (get_frame_size () + avr_outgoing_args_size()\n               + avr_pc_size + 1 + offset);\n@@ -1314,6 +1331,8 @@ avr_return_addr_rtx (int count, rtx tem)\n   else\n     r = gen_rtx_SYMBOL_REF (Pmode, \".L__stack_usage+1\");\n \n+  cfun->machine->use_L__stack_usage = 1;\n+\n   r = gen_rtx_PLUS (Pmode, tem, r);\n   r = gen_frame_mem (Pmode, memory_address (Pmode, r));\n   r = gen_rtx_ROTATE (HImode, r, GEN_INT (8));\n@@ -1394,6 +1413,97 @@ sequent_regs_live (void)\n   return (cur_seq == live_seq) ? live_seq : 0;\n }\n \n+namespace {\n+static const pass_data avr_pass_data_pre_proep =\n+{\n+  RTL_PASS,      // type\n+  \"\",            // name (will be patched)\n+  OPTGROUP_NONE, // optinfo_flags\n+  TV_DF_SCAN,    // tv_id\n+  0,             // properties_required\n+  0,             // properties_provided\n+  0,             // properties_destroyed\n+  0,             // todo_flags_start\n+  0              // todo_flags_finish\n+};\n+\n+\n+class avr_pass_pre_proep : public rtl_opt_pass\n+{\n+public:\n+  avr_pass_pre_proep (gcc::context *ctxt, const char *name)\n+    : rtl_opt_pass (avr_pass_data_pre_proep, ctxt)\n+  {\n+    this->name = name;\n+  }\n+\n+  void compute_maybe_gasisr (function*);\n+\n+  virtual unsigned int execute (function *fun)\n+  {\n+    if (TARGET_GASISR_PROLOGUES\n+        // Whether this function is an ISR worth scanning at all.\n+        && !fun->machine->is_no_gccisr\n+        && (fun->machine->is_interrupt\n+            || fun->machine->is_signal)\n+        && !cfun->machine->is_naked\n+        // Paranoia: Non-local gotos and labels that might escape.\n+        && !cfun->calls_setjmp\n+        && !cfun->has_nonlocal_label\n+        && !cfun->has_forced_label_in_static)\n+      {\n+        compute_maybe_gasisr (fun);\n+      }\n+\n+    return 0;\n+  }\n+\n+}; // avr_pass_pre_proep\n+\n+} // anon namespace\n+\n+rtl_opt_pass*\n+make_avr_pass_pre_proep (gcc::context *ctxt)\n+{\n+  return new avr_pass_pre_proep (ctxt, \"avr-pre-proep\");\n+}\n+\n+\n+/* Set fun->machine->gasisr.maybe provided we don't find anything that\n+   prohibits GAS generating parts of ISR prologues / epilogues for us.  */\n+\n+void\n+avr_pass_pre_proep::compute_maybe_gasisr (function *fun)\n+{\n+  // Don't use BB iterators so that we see JUMP_TABLE_DATA.\n+\n+  for (rtx_insn *insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      // Transparent calls always use [R]CALL and are filtered out by GAS.\n+      // ISRs don't use -mcall-prologues, hence what remains to be filtered\n+      // out are open coded (tail) calls.\n+\n+      if (CALL_P (insn))\n+        return;\n+\n+      // __tablejump2__ clobbers something and is targeted by JMP so\n+      // that GAS won't see its usage.\n+\n+      if (AVR_HAVE_JMP_CALL\n+          && JUMP_TABLE_DATA_P (insn))\n+        return;\n+\n+      // Non-local gotos not seen in *FUN.\n+\n+      if (JUMP_P (insn)\n+          && find_reg_note (insn, REG_NON_LOCAL_GOTO, NULL_RTX))\n+        return;\n+    }\n+\n+  fun->machine->gasisr.maybe = 1;\n+}\n+\n+\n /* Obtain the length sequence of insns.  */\n \n int\n@@ -1418,6 +1528,46 @@ avr_incoming_return_addr_rtx (void)\n   return gen_frame_mem (HImode, plus_constant (Pmode, stack_pointer_rtx, 1));\n }\n \n+\n+/* Unset a bit in *SET.  If successful, return the respective bit number.\n+   Otherwise, return -1 and *SET is unaltered.  */\n+\n+static int\n+avr_hregs_split_reg (HARD_REG_SET *set)\n+{\n+  for (int regno = 0; regno < 32; regno++)\n+    if (TEST_HARD_REG_BIT (*set, regno))\n+      {\n+        // Don't remove a register from *SET which might indicate that\n+        // some RAMP* register might need ISR prologue / epilogue treatment.\n+\n+        if (AVR_HAVE_RAMPX\n+            && (REG_X == regno || REG_X + 1 == regno)\n+            && TEST_HARD_REG_BIT (*set, REG_X)\n+            && TEST_HARD_REG_BIT (*set, REG_X + 1))\n+          continue;\n+\n+        if (AVR_HAVE_RAMPY\n+            && !frame_pointer_needed\n+            && (REG_Y == regno || REG_Y + 1 == regno)\n+            && TEST_HARD_REG_BIT (*set, REG_Y)\n+            && TEST_HARD_REG_BIT (*set, REG_Y + 1))\n+          continue;\n+\n+        if (AVR_HAVE_RAMPZ\n+            && (REG_Z == regno || REG_Z + 1 == regno)\n+            && TEST_HARD_REG_BIT (*set, REG_Z)\n+            && TEST_HARD_REG_BIT (*set, REG_Z + 1))\n+          continue;\n+            \n+        CLEAR_HARD_REG_BIT (*set, regno);\n+        return regno;\n+      }\n+\n+  return -1;\n+}\n+\n+\n /*  Helper for expand_prologue.  Emit a push of a byte register.  */\n \n static void\n@@ -1438,24 +1588,24 @@ emit_push_byte (unsigned regno, bool frame_related_p)\n }\n \n \n-/*  Helper for expand_prologue.  Emit a push of a SFR via tmp_reg.\n+/*  Helper for expand_prologue.  Emit a push of a SFR via register TREG.\n     SFR is a MEM representing the memory location of the SFR.\n     If CLR_P then clear the SFR after the push using zero_reg.  */\n \n static void\n-emit_push_sfr (rtx sfr, bool frame_related_p, bool clr_p)\n+emit_push_sfr (rtx sfr, bool frame_related_p, bool clr_p, int treg)\n {\n   rtx_insn *insn;\n \n   gcc_assert (MEM_P (sfr));\n \n-  /* IN __tmp_reg__, IO(SFR) */\n-  insn = emit_move_insn (tmp_reg_rtx, sfr);\n+  /* IN treg, IO(SFR) */\n+  insn = emit_move_insn (all_regs_rtx[treg], sfr);\n   if (frame_related_p)\n     RTX_FRAME_RELATED_P (insn) = 1;\n \n-  /* PUSH __tmp_reg__ */\n-  emit_push_byte (AVR_TMP_REGNO, frame_related_p);\n+  /* PUSH treg */\n+  emit_push_byte (treg, frame_related_p);\n \n   if (clr_p)\n     {\n@@ -1759,52 +1909,81 @@ avr_expand_prologue (void)\n \n   if (cfun->machine->is_interrupt || cfun->machine->is_signal)\n     {\n+      int treg = AVR_TMP_REGNO;\n       /* Enable interrupts.  */\n       if (cfun->machine->is_interrupt)\n         emit_insn (gen_enable_interrupt ());\n \n-      /* Push zero reg.  */\n-      emit_push_byte (AVR_ZERO_REGNO, true);\n+      if (cfun->machine->gasisr.maybe)\n+        {\n+          /* Let GAS PR21472 emit prologue preamble for us which handles SREG,\n+             ZERO_REG and TMP_REG and one additional, optional register for\n+             us in an optimal way.  This even scans through inline asm.  */\n+\n+          cfun->machine->gasisr.yes = 1;\n+\n+          // The optional reg or TMP_REG if we don't need one.  If we need one,\n+          // remove that reg from SET so that it's not puhed / popped twice.\n+          // We also use it below instead of TMP_REG in some places.\n+\n+          treg = avr_hregs_split_reg (&set);\n+          if (treg < 0)\n+            treg = AVR_TMP_REGNO;\n+          cfun->machine->gasisr.regno = treg;\n+\n+          // The worst case of pushes.  The exact number can be inferred\n+          // at assembly time by magic expression __gcc_isr.n_pushed.\n+          cfun->machine->stack_usage += 3 + (treg != AVR_TMP_REGNO);\n+\n+          // Emit a Prologue chunk.  Epilogue chunk(s) might follow.\n+          // The final Done chunk is emit by final postscan.\n+          emit_insn (gen_gasisr (GEN_INT (GASISR_Prologue), GEN_INT (treg)));\n+        }\n+      else // !TARGET_GASISR_PROLOGUES: Classic, dumb prologue preamble.\n+        {\n+          /* Push zero reg.  */\n+          emit_push_byte (AVR_ZERO_REGNO, true);\n \n-      /* Push tmp reg.  */\n-      emit_push_byte (AVR_TMP_REGNO, true);\n+          /* Push tmp reg.  */\n+          emit_push_byte (AVR_TMP_REGNO, true);\n \n-      /* Push SREG.  */\n-      /* ??? There's no dwarf2 column reserved for SREG.  */\n-      emit_push_sfr (sreg_rtx, false, false /* clr */);\n+          /* Push SREG.  */\n+          /* ??? There's no dwarf2 column reserved for SREG.  */\n+          emit_push_sfr (sreg_rtx, false, false /* clr */, AVR_TMP_REGNO);\n \n-      /* Clear zero reg.  */\n-      emit_move_insn (zero_reg_rtx, const0_rtx);\n+          /* Clear zero reg.  */\n+          emit_move_insn (zero_reg_rtx, const0_rtx);\n \n-      /* Prevent any attempt to delete the setting of ZERO_REG!  */\n-      emit_use (zero_reg_rtx);\n+          /* Prevent any attempt to delete the setting of ZERO_REG!  */\n+          emit_use (zero_reg_rtx);\n+        }\n \n       /* Push and clear RAMPD/X/Y/Z if present and low-part register is used.\n          ??? There are no dwarf2 columns reserved for RAMPD/X/Y/Z.  */\n \n       if (AVR_HAVE_RAMPD)\n-        emit_push_sfr (rampd_rtx, false /* frame-related */, true /* clr */);\n+        emit_push_sfr (rampd_rtx, false /* frame */, true /* clr */, treg);\n \n       if (AVR_HAVE_RAMPX\n           && TEST_HARD_REG_BIT (set, REG_X)\n           && TEST_HARD_REG_BIT (set, REG_X + 1))\n         {\n-          emit_push_sfr (rampx_rtx, false /* frame-related */, true /* clr */);\n+          emit_push_sfr (rampx_rtx, false /* frame */, true /* clr */, treg);\n         }\n \n       if (AVR_HAVE_RAMPY\n           && (frame_pointer_needed\n               || (TEST_HARD_REG_BIT (set, REG_Y)\n                   && TEST_HARD_REG_BIT (set, REG_Y + 1))))\n         {\n-          emit_push_sfr (rampy_rtx, false /* frame-related */, true /* clr */);\n+          emit_push_sfr (rampy_rtx, false /* frame */, true /* clr */, treg);\n         }\n \n       if (AVR_HAVE_RAMPZ\n           && TEST_HARD_REG_BIT (set, REG_Z)\n           && TEST_HARD_REG_BIT (set, REG_Z + 1))\n         {\n-          emit_push_sfr (rampz_rtx, false /* frame-related */, AVR_HAVE_RAMPD);\n+          emit_push_sfr (rampz_rtx, false /* frame */, AVR_HAVE_RAMPD, treg);\n         }\n     }  /* is_interrupt is_signal */\n \n@@ -1846,11 +2025,23 @@ avr_asm_function_end_prologue (FILE *file)\n \n   fprintf (file, \"/* frame size = \" HOST_WIDE_INT_PRINT_DEC \" */\\n\",\n            get_frame_size());\n-  fprintf (file, \"/* stack size = %d */\\n\",\n-           cfun->machine->stack_usage);\n-  /* Create symbol stack offset here so all functions have it. Add 1 to stack\n-     usage for offset so that SP + .L__stack_offset = return address.  */\n-  fprintf (file, \".L__stack_usage = %d\\n\", cfun->machine->stack_usage);\n+\n+  if (!cfun->machine->gasisr.yes)\n+    {\n+      fprintf (file, \"/* stack size = %d */\\n\", cfun->machine->stack_usage);\n+      // Create symbol stack offset so all functions have it. Add 1 to stack\n+      // usage for offset so that SP + .L__stack_offset = return address.\n+      fprintf (file, \".L__stack_usage = %d\\n\", cfun->machine->stack_usage);\n+    }\n+  else\n+    {\n+      int used_by_gasisr = 3 + (cfun->machine->gasisr.regno != AVR_TMP_REGNO);\n+      int to = cfun->machine->stack_usage;\n+      int from = to - used_by_gasisr;\n+      // Number of pushed regs is only known at assembly-time.\n+      fprintf (file, \"/* stack size = %d...%d */\\n\", from , to);\n+      fprintf (file, \".L__stack_usage = %d + __gcc_isr.n_pushed\\n\", from);\n+    }\n }\n \n \n@@ -2026,6 +2217,15 @@ avr_expand_epilogue (bool sibcall_p)\n \n   /* Restore used registers.  */\n \n+  int treg = AVR_TMP_REGNO;\n+\n+  if (isr_p\n+      && cfun->machine->gasisr.yes)\n+    {\n+      treg = cfun->machine->gasisr.regno;\n+      CLEAR_HARD_REG_BIT (set, treg);\n+    }\n+\n   for (int reg = 31; reg >= 0; --reg)\n     if (TEST_HARD_REG_BIT (set, reg))\n       emit_pop_byte (reg);\n@@ -2039,43 +2239,52 @@ avr_expand_epilogue (bool sibcall_p)\n           && TEST_HARD_REG_BIT (set, REG_Z)\n           && TEST_HARD_REG_BIT (set, REG_Z + 1))\n         {\n-          emit_pop_byte (TMP_REGNO);\n-          emit_move_insn (rampz_rtx, tmp_reg_rtx);\n+          emit_pop_byte (treg);\n+          emit_move_insn (rampz_rtx, all_regs_rtx[treg]);\n         }\n \n       if (AVR_HAVE_RAMPY\n           && (frame_pointer_needed\n               || (TEST_HARD_REG_BIT (set, REG_Y)\n                   && TEST_HARD_REG_BIT (set, REG_Y + 1))))\n         {\n-          emit_pop_byte (TMP_REGNO);\n-          emit_move_insn (rampy_rtx, tmp_reg_rtx);\n+          emit_pop_byte (treg);\n+          emit_move_insn (rampy_rtx, all_regs_rtx[treg]);\n         }\n \n       if (AVR_HAVE_RAMPX\n           && TEST_HARD_REG_BIT (set, REG_X)\n           && TEST_HARD_REG_BIT (set, REG_X + 1))\n         {\n-          emit_pop_byte (TMP_REGNO);\n-          emit_move_insn (rampx_rtx, tmp_reg_rtx);\n+          emit_pop_byte (treg);\n+          emit_move_insn (rampx_rtx, all_regs_rtx[treg]);\n         }\n \n       if (AVR_HAVE_RAMPD)\n         {\n-          emit_pop_byte (TMP_REGNO);\n-          emit_move_insn (rampd_rtx, tmp_reg_rtx);\n+          emit_pop_byte (treg);\n+          emit_move_insn (rampd_rtx, all_regs_rtx[treg]);\n         }\n \n-      /* Restore SREG using tmp_reg as scratch.  */\n+      if (cfun->machine->gasisr.yes)\n+        {\n+          // Emit an Epilogue chunk.\n+          emit_insn (gen_gasisr (GEN_INT (GASISR_Epilogue),\n+                                 GEN_INT (cfun->machine->gasisr.regno)));\n+        }\n+      else // !TARGET_GASISR_PROLOGUES\n+        {\n+          /* Restore SREG using tmp_reg as scratch.  */\n \n-      emit_pop_byte (AVR_TMP_REGNO);\n-      emit_move_insn (sreg_rtx, tmp_reg_rtx);\n+          emit_pop_byte (AVR_TMP_REGNO);\n+          emit_move_insn (sreg_rtx, tmp_reg_rtx);\n \n-      /* Restore tmp REG.  */\n-      emit_pop_byte (AVR_TMP_REGNO);\n+          /* Restore tmp REG.  */\n+          emit_pop_byte (AVR_TMP_REGNO);\n \n-      /* Restore zero REG.  */\n-      emit_pop_byte (AVR_ZERO_REGNO);\n+          /* Restore zero REG.  */\n+          emit_pop_byte (AVR_ZERO_REGNO);\n+        }\n     }\n \n   if (!sibcall_p)\n@@ -2088,6 +2297,7 @@ avr_expand_epilogue (bool sibcall_p)\n static void\n avr_asm_function_begin_epilogue (FILE *file)\n {\n+  app_disable();\n   fprintf (file, \"/* epilogue start */\\n\");\n }\n \n@@ -3094,6 +3304,25 @@ avr_final_prescan_insn (rtx_insn *insn, rtx *operand ATTRIBUTE_UNUSED,\n              (int) INSN_ADDRESSES (INSN_UID (insn)));\n }\n \n+\n+/* Implement `TARGET_ASM_FINAL_POSTSCAN_INSN'.  */\n+/* When GAS generates (parts of) ISR prologue / epilogue for us, we must\n+   hint GAS about the end of the code to scan.  There migh be code located\n+   after the last epilogue.  */\n+\n+static void\n+avr_asm_final_postscan_insn (FILE *stream, rtx_insn *insn, rtx*, int)\n+{\n+  if (cfun->machine->gasisr.yes\n+      && !next_real_insn (insn))\n+    {\n+      app_disable();\n+      fprintf (stream, \"\\t__gcc_isr %d,r%d\\n\", GASISR_Done,\n+               cfun->machine->gasisr.regno);\n+    }\n+}\n+\n+\n /* Return 0 if undefined, 1 if always true or always false.  */\n \n int\n@@ -8300,7 +8529,7 @@ avr_out_addto_sp (rtx *op, int *plen)\n         }\n \n       while (addend++ < 0)\n-        avr_asm_len (\"push __zero_reg__\", op, plen, 1);\n+        avr_asm_len (\"push __tmp_reg__\", op, plen, 1);\n     }\n   else if (addend > 0)\n     {\n@@ -9631,6 +9860,8 @@ avr_attribute_table[] =\n     false },\n   { \"interrupt\", 0, 0, true,  false, false,  avr_handle_fndecl_attribute,\n     false },\n+  { \"no_gccisr\", 0, 0, true,  false, false,  avr_handle_fndecl_attribute,\n+    false },\n   { \"naked\",     0, 0, false, true,  true,   avr_handle_fntype_attribute,\n     false },\n   { \"OS_task\",   0, 0, false, true,  true,   avr_handle_fntype_attribute,\n@@ -14370,6 +14601,9 @@ avr_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED, tree *arg,\n #undef  TARGET_ASM_SELECT_SECTION\n #define TARGET_ASM_SELECT_SECTION avr_asm_select_section\n \n+#undef  TARGET_ASM_FINAL_POSTSCAN_INSN\n+#define TARGET_ASM_FINAL_POSTSCAN_INSN avr_asm_final_postscan_insn\n+\n #undef  TARGET_REGISTER_MOVE_COST\n #define TARGET_REGISTER_MOVE_COST avr_register_move_cost\n #undef  TARGET_MEMORY_MOVE_COST"}, {"sha": "579c8faa0b53123e41cafef4cf9d0f7078cbc771", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=63866e04b770cefcfa0c64b427dc924cce475201", "patch": "@@ -585,6 +585,26 @@ struct GTY(()) machine_function\n   /* 'true' if the above is_foo predicates are sanity-checked to avoid\n      multiple diagnose for the same function.  */\n   int attributes_checked_p;\n+\n+  /* 'true' - if current function shall not use '__gcc_isr' pseudo\n+     instructions as specified by the \"no_gccisr\" attribute.  */\n+  int is_no_gccisr;\n+\n+  /* Used for `__gcc_isr' pseudo instruction handling of\n+     non-naked ISR prologue / epilogue(s).  */\n+  struct\n+  {\n+    /* 'true' if this function actually uses \"*gasisr\" insns. */\n+    int yes;\n+    /* 'true' if this function is allowed to use \"*gasisr\" insns. */\n+    int maybe;\n+    /* The register numer as printed by the Done chunk.  */\n+    int regno;\n+  } gasisr;\n+\n+  /* 'true' if this function references .L__stack_usage like with\n+     __builtin_return_address.  */\n+  int use_L__stack_usage;\n };\n \n /* AVR does not round pushes, but the existence of this macro is"}, {"sha": "d17c0b1364074cb4a1f31e1116df182fe9284da6", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=63866e04b770cefcfa0c64b427dc924cce475201", "patch": "@@ -85,6 +85,7 @@\n   [UNSPECV_PROLOGUE_SAVES\n    UNSPECV_EPILOGUE_RESTORES\n    UNSPECV_WRITE_SP\n+   UNSPECV_GASISR\n    UNSPECV_GOTO_RECEIVER\n    UNSPECV_ENABLE_IRQS\n    UNSPECV_MEMORY_BARRIER\n@@ -94,6 +95,12 @@\n    UNSPECV_DELAY_CYCLES\n    ])\n \n+;; Chunk numbers for __gcc_isr are hard-coded in GAS.\n+(define_constants\n+  [(GASISR_Prologue 1)\n+   (GASISR_Epilogue 2)\n+   (GASISR_Done     0)\n+   ])\n \n (include \"predicates.md\")\n (include \"constraints.md\")\n@@ -5800,6 +5807,38 @@\n    (set_attr \"cc\" \"clobber\")\n    (set_attr \"isa\" \"rjmp,jmp\")])\n \n+\n+;; $0 = Chunk: 1 = Prologue,  2 = Epilogue\n+;; $1 = Register as printed by chunk 0 (Done) in final postscan.\n+(define_expand \"gasisr\"\n+  [(parallel [(unspec_volatile [(match_operand:QI 0 \"const_int_operand\")\n+                                (match_operand:QI 1 \"const_int_operand\")]\n+                               UNSPECV_GASISR)\n+              (set (reg:HI REG_SP)\n+                   (unspec_volatile:HI [(reg:HI REG_SP)] UNSPECV_GASISR))\n+              (set (match_dup 2)\n+                   (unspec_volatile:BLK [(match_dup 2)]\n+                                        UNSPECV_MEMORY_BARRIER))])]\n+  \"TARGET_GASISR_PROLOGUES\"\n+  {\n+    operands[2] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));\n+    MEM_VOLATILE_P (operands[2]) = 1;\n+  })\n+\n+(define_insn \"*gasisr\"\n+  [(unspec_volatile [(match_operand:QI 0 \"const_int_operand\" \"P,K\")\n+                     (match_operand:QI 1 \"const_int_operand\" \"n,n\")]\n+                    UNSPECV_GASISR)\n+   (set (reg:HI REG_SP)\n+        (unspec_volatile:HI [(reg:HI REG_SP)] UNSPECV_GASISR))\n+   (set (match_operand:BLK 2)\n+        (unspec_volatile:BLK [(match_dup 2)] UNSPECV_MEMORY_BARRIER))]\n+  \"TARGET_GASISR_PROLOGUES\"\n+  \"__gcc_isr %0\"\n+  [(set_attr \"length\" \"6,5\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+\n ; return\n (define_insn \"return\"\n   [(return)]"}, {"sha": "81850e037f61dafada9682fe92891721f4c9cf2d", "filename": "gcc/config/avr/avr.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fconfig%2Favr%2Favr.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fconfig%2Favr%2Favr.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.opt?ref=63866e04b770cefcfa0c64b427dc924cce475201", "patch": "@@ -26,6 +26,10 @@ mmcu=\n Target RejectNegative Joined Var(avr_mmcu) MissingArgError(missing device or architecture after %qs)\n -mmcu=MCU\tSelect the target MCU.\n \n+mgas-isr-prologues\n+Target Report Mask(GASISR_PROLOGUES)\n+Allow usage of __gcc_isr pseudo instructions in ISR prologues and epilogues.\n+\n mn-flash=\n Target RejectNegative Joined Var(avr_n_flash) UInteger Init(-1)\n Set the number of 64 KiB flash segments."}, {"sha": "b923aa4ee3cd69894587234705f050c86e2c09fe", "filename": "gcc/config/avr/gen-avr-mmcu-specs.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fconfig%2Favr%2Fgen-avr-mmcu-specs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fconfig%2Favr%2Fgen-avr-mmcu-specs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fgen-avr-mmcu-specs.c?ref=63866e04b770cefcfa0c64b427dc924cce475201", "patch": "@@ -224,6 +224,11 @@ print_mcu (const avr_mcu_t *mcu)\n            : \"\\t%{mrmw}\");\n #endif // have avr-as -mrmw\n \n+#ifdef HAVE_AS_AVR_MGCCISR_OPTION\n+  fprintf (f, \"*asm_gccisr:\\n%s\\n\\n\",\n+           \"\\t%{!mno-gas-isr-prologues: -mgcc-isr}\");\n+#endif // have avr-as -mgcc-isr\n+\n   fprintf (f, \"*asm_errata_skip:\\n%s\\n\\n\", errata_skip\n            ? \"\\t%{mno-skip-bug}\"\n            : \"\\t%{!mskip-bug: -mno-skip-bug}\");"}, {"sha": "4f046a11e1f885656181114b0f15a9986b0fd749", "filename": "gcc/config/avr/specs.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fconfig%2Favr%2Fspecs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fconfig%2Favr%2Fspecs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fspecs.h?ref=63866e04b770cefcfa0c64b427dc924cce475201", "patch": "@@ -52,6 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n   \"%(asm_arch) \"                                \\\n   \"%(asm_relax) \"                               \\\n   \"%(asm_rmw) \"                                 \\\n+  \"%(asm_gccisr) \"                              \\\n   \"%(asm_errata_skip) \"\n \n #define LINK_ARCH_SPEC                          \\"}, {"sha": "98aa62c00bea68c9b14d0fa4ed0f55ebfb238abc", "filename": "gcc/configure", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=63866e04b770cefcfa0c64b427dc924cce475201", "patch": "@@ -24817,6 +24817,42 @@ if test $gcc_cv_as_avr_mrmw = yes; then\n \n $as_echo \"#define HAVE_AS_AVR_MRMW_OPTION 1\" >>confdefs.h\n \n+fi\n+\n+\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for __gcc_isr pseudo instruction\" >&5\n+$as_echo_n \"checking assembler for __gcc_isr pseudo instruction... \" >&6; }\n+if test \"${gcc_cv_as_avr_mgccisr+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  gcc_cv_as_avr_mgccisr=no\n+  if test x$gcc_cv_as != x; then\n+    $as_echo '.text\n+      \t\t    __gcc_isr 1\n+      \t\t    __gcc_isr 2\n+      \t\t    __gcc_isr 0,r24\n+      \t\t   ' > conftest.s\n+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags -mgcc-isr -o conftest.o conftest.s >&5'\n+  { { eval echo \"\\\"\\$as_me\\\":${as_lineno-$LINENO}: \\\"$ac_try\\\"\"; } >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; }; }\n+    then\n+\tgcc_cv_as_avr_mgccisr=yes\n+    else\n+      echo \"configure: failed program was\" >&5\n+      cat conftest.s >&5\n+    fi\n+    rm -f conftest.o conftest.s\n+  fi\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_avr_mgccisr\" >&5\n+$as_echo \"$gcc_cv_as_avr_mgccisr\" >&6; }\n+if test $gcc_cv_as_avr_mgccisr = yes; then\n+\n+$as_echo \"#define HAVE_AS_AVR_MGCCISR_OPTION 1\" >>confdefs.h\n+\n fi\n \n \n@@ -25282,6 +25318,7 @@ $as_echo \"#define HAVE_AS_SPARC5_VIS4 1\" >>confdefs.h\n \n fi\n \n+\n     { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for SPARC6 instructions\" >&5\n $as_echo_n \"checking assembler for SPARC6 instructions... \" >&6; }\n if test \"${gcc_cv_as_sparc_sparc6+set}\" = set; then :\n@@ -25318,6 +25355,7 @@ $as_echo \"#define HAVE_AS_SPARC6 1\" >>confdefs.h\n \n fi\n \n+\n     { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for LEON instructions\" >&5\n $as_echo_n \"checking assembler for LEON instructions... \" >&6; }\n if test \"${gcc_cv_as_sparc_leon+set}\" = set; then :"}, {"sha": "aa980a1c4266669b9f6de15abd136465e3f488de", "filename": "gcc/configure.ac", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=63866e04b770cefcfa0c64b427dc924cce475201", "patch": "@@ -3817,6 +3817,16 @@ AS_HELP_STRING([--disable-fix-cortex-a53-843419],\n       [AC_DEFINE(HAVE_AS_AVR_MRMW_OPTION, 1,\n \t\t[Define if your avr assembler supports -mrmw option.])])\n \n+    gcc_GAS_CHECK_FEATURE([__gcc_isr pseudo instruction],\n+      gcc_cv_as_avr_mgccisr,,\n+      [-mgcc-isr], [.text\n+      \t\t    __gcc_isr 1\n+      \t\t    __gcc_isr 2\n+      \t\t    __gcc_isr 0,r24\n+      \t\t   ],,\n+      [AC_DEFINE(HAVE_AS_AVR_MGCCISR_OPTION, 1,\n+\t\t[Define if your avr assembler supports -mgcc-isr option.])])\n+\n     # Check how default linker description file implements .rodata for\n     # avrxmega3 (PR21472).  avr-gcc assumes .rodata is *not* loaded to\n     # RAM so avr-gcc skips __do_copy_data for .rodata objects."}, {"sha": "6120524011014168899acfda841c568e04d4417a", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=63866e04b770cefcfa0c64b427dc924cce475201", "patch": "@@ -3815,6 +3815,35 @@ prologue/epilogue sequences generated by the compiler. Only basic\n basic @code{asm} and C code may appear to work, they cannot be\n depended upon to work reliably and are not supported.\n \n+@item no_gccisr\n+@cindex @code{no_gccisr} function attribute, AVR\n+Do not use @code{__gcc_isr} pseudo instructions in a function with\n+the @code{interrupt} or @code{signal} attribute aka. interrupt\n+service routine (ISR).\n+For details on @code{__gcc_isr}, see the GNU Binutils\n+@w{@uref{https://sourceware.org/binutils/docs/as/AVR_002dDependent.html,AVR assembler manual}}.\n+Use this attribute if the preamble of the ISR prologue should always read\n+@example\n+push  __zero_reg__\n+push  __tmp_reg__\n+in    __tmp_reg__, __SREG__\n+push  __tmp_reg__\n+clr   __zero_reg__\n+@end example\n+and accordingly for the postamble of the epilogue --- no matter whether\n+the mentioned registers are actually used in the ISR or not.\n+Situations where you might want to use this attribute include:\n+@itemize @bullet\n+@item\n+Code that (effectively) clobbers bits of @code{SREG} other than the\n+@code{I}-flag by writing to the memory location of @code{SREG}.\n+@item\n+Code that uses inline assembler to jump to a different function which\n+expects (parts of) the prologue code as outlined above to be present.\n+@end itemize\n+To disable @code{__gcc_isr} generation for the whole compilation unit,\n+there is option @option{-mno-gas-isr-prologues}, @pxref{AVR Options}.\n+\n @item OS_main\n @itemx OS_task\n @cindex @code{OS_main} function attribute, AVR"}, {"sha": "4982f7c5d2d95720276560187df14320c7d62325", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=63866e04b770cefcfa0c64b427dc924cce475201", "patch": "@@ -661,7 +661,8 @@ Objective-C and Objective-C++ Dialects}.\n @emph{AVR Options}\n @gccoptlist{-mmcu=@var{mcu}  -mabsdata  -maccumulate-args @gol\n -mbranch-cost=@var{cost} @gol\n--mcall-prologues  -mint8  -mn_flash=@var{size}  -mno-interrupts @gol\n+-mcall-prologues  -mgas-isr-prologues  -mint8 @gol\n+-mn_flash=@var{size}  -mno-interrupts @gol\n -mrelax  -mrmw  -mstrict-X  -mtiny-stack  -mfract-convert-truncate @gol\n -mshort-calls  -nodevicelib @gol\n -Waddr-space-convert  -Wmisspelled-isr}\n@@ -15977,6 +15978,18 @@ integers. The default branch cost is 0.\n Functions prologues/epilogues are expanded as calls to appropriate\n subroutines.  Code size is smaller.\n \n+@item -mgas-isr-prologues\n+@opindex mgas-isr-prologues\n+Interrupt service routines (ISRs) may use the @code{__gcc_isr} pseudo\n+instruction supported by GNU Binutils, see the\n+@w{@uref{https://sourceware.org/binutils/docs/as/AVR_002dDependent.html,AVR assembler manual}}\n+for details.\n+If this option is on, the feature can still be disabled for individual\n+ISRs by means of the @ref{AVR Function Attributes,,@code{no_gccisr}}\n+function attribute.  This feature is activated per default\n+if optimization is on (but not with @option{-Og}, @pxref{Optimize Options}),\n+and if GNU Binutils support @w{@uref{https://sourceware.org/PR21683,PR21683}}.\n+\n @item -mint8\n @opindex mint8\n Assume @code{int} to be 8-bit integer.  This affects the sizes of all types: a"}, {"sha": "176dbc2a15fd389bd7e5d36f31fa862b99b9880a", "filename": "gcc/testsuite/gcc.target/avr/isr-test.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Fisr-test.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63866e04b770cefcfa0c64b427dc924cce475201/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Fisr-test.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Fisr-test.h?ref=63866e04b770cefcfa0c64b427dc924cce475201", "patch": "@@ -175,7 +175,7 @@ static void compare_reginfo (unsigned long gpr_ignore)\n   ST(24,M)    ST(25,M)    ST(26,M)    ST(27,M)  \\\n   ST(28,M)    ST(29,M)    ST(30,M)    ST(31,M)\n \n-__attribute__((used,naked,noinline,noclone))\n+__attribute__((unused,naked,noinline,noclone))\n static void host_store1 (void)\n {\n   __asm __volatile__\n@@ -217,7 +217,7 @@ static void host_store1 (void)\n    : \"memory\", \"r31\");\n }\n \n-__attribute__((used,naked,noinline,noclone))\n+__attribute__((unused,naked,noinline,noclone))\n static void host_store2 (void)\n {\n   __asm __volatile__"}]}