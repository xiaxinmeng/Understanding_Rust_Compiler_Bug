{"sha": "e92857a103ce0e0aa100d8509deffba228f4fe17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkyODU3YTEwM2NlMGUwYWExMDBkODUwOWRlZmZiYTIyOGY0ZmUxNw==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2006-04-10T16:01:23Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2006-04-10T16:01:23Z"}, "message": "x86_64-signal.h (HANDLE_DIVIDE_OVERFLOW): New.\n\n2006-04-10  Andrew Haley  <aph@redhat.com>\n\n        * include/x86_64-signal.h (HANDLE_DIVIDE_OVERFLOW): New.\n        (SIGNAL_HANDLER): Mark arg as unused.\n        * configure.host (x86_64-* DIVIDESPEC): Use\n        fno-use-divide-subroutine.\n\nFrom-SVN: r112827", "tree": {"sha": "ceb6cf249c4fac7a7b32abb737226b2b16b10c91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ceb6cf249c4fac7a7b32abb737226b2b16b10c91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e92857a103ce0e0aa100d8509deffba228f4fe17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e92857a103ce0e0aa100d8509deffba228f4fe17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e92857a103ce0e0aa100d8509deffba228f4fe17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e92857a103ce0e0aa100d8509deffba228f4fe17/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1f3d30ed897c623686239ceb96f21b727974807e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f3d30ed897c623686239ceb96f21b727974807e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f3d30ed897c623686239ceb96f21b727974807e"}], "stats": {"total": 123, "additions": 113, "deletions": 10}, "files": [{"sha": "2117abfe7779530d384f7158e1e4cd572b721011", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92857a103ce0e0aa100d8509deffba228f4fe17/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92857a103ce0e0aa100d8509deffba228f4fe17/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=e92857a103ce0e0aa100d8509deffba228f4fe17", "patch": "@@ -1,3 +1,10 @@\n+2006-04-10  Andrew Haley  <aph@redhat.com>\n+\n+\t* include/x86_64-signal.h (HANDLE_DIVIDE_OVERFLOW): New.\n+\t(SIGNAL_HANDLER): Mark arg as unused.\n+\t* configure.host (x86_64-* DIVIDESPEC): Use\n+\tfno-use-divide-subroutine.\n+\n 2006-04-07  Andrew Haley  <aph@redhat.com>\n \n \t* java/net/InetAddress.java: Throw an UnknownHostException if"}, {"sha": "e21307258f43cc65cd7e8d9e9c8bf847e70a79d4", "filename": "libjava/configure.host", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92857a103ce0e0aa100d8509deffba228f4fe17/libjava%2Fconfigure.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92857a103ce0e0aa100d8509deffba228f4fe17/libjava%2Fconfigure.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.host?ref=e92857a103ce0e0aa100d8509deffba228f4fe17", "patch": "@@ -115,7 +115,7 @@ case \"${host}\" in\n \tlibgcj_flags=\"${libgcj_flags} -fomit-frame-pointer\"\n \tlibgcj_cxxflags=\n \tlibgcj_cflags=\n-\tDIVIDESPEC=-f%{m32:no-}use-divide-subroutine\n+\tDIVIDESPEC=-fno-use-divide-subroutine\n \tenable_hash_synchronization_default=yes\n \tslow_pthread_self=yes\n \tlibgcj_interpreter=yes"}, {"sha": "479be3ff898b1f05605ae3f1cb708dad464a4891", "filename": "libjava/include/x86_64-signal.h", "status": "modified", "additions": 105, "deletions": 9, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e92857a103ce0e0aa100d8509deffba228f4fe17/libjava%2Finclude%2Fx86_64-signal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e92857a103ce0e0aa100d8509deffba228f4fe17/libjava%2Finclude%2Fx86_64-signal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fx86_64-signal.h?ref=e92857a103ce0e0aa100d8509deffba228f4fe17", "patch": "@@ -19,9 +19,88 @@ details.  */\n #include <sys/syscall.h>\n \n #define HANDLE_SEGV 1\n-\n-#define SIGNAL_HANDLER(_name)\t\\\n-static void _Jv_##_name (int, siginfo_t *, void *_p)\n+#define HANDLE_FPE 1\n+\n+#define SIGNAL_HANDLER(_name)\t\t\t\t\t\\\n+static void _Jv_##_name (int, siginfo_t *,\t\t\t\\\n+\t\t\t void *_p __attribute__ ((__unused__)))\n+\n+#define HANDLE_DIVIDE_OVERFLOW\t\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  struct ucontext *_uc = (struct ucontext *)_p;\t\t\t\t\\\n+  volatile struct sigcontext *_sc = (struct sigcontext *) &_uc->uc_mcontext; \\\n+\t\t\t\t\t\t\t\t\t\\\n+  register unsigned char *_rip = (unsigned char *)_sc->rip;\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* According to the JVM spec, \"if the dividend is the negative\t\\\n+   * integer of largest possible magnitude for the type and the\t\t\\\n+   * divisor is -1, then overflow occurs and the result is equal to\t\\\n+   * the dividend.  Despite the overflow, no exception occurs\".\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+   * We handle this by inspecting the instruction which generated the\t\\\n+   * signal and advancing ip to point to the following instruction.\t\\\n+   * As the instructions are variable length it is necessary to do a\t\\\n+   * little calculation to figure out where the following instruction\t\\\n+   * actually is.\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+   */\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  bool _is_64_bit = false;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if ((_rip[0] & 0xf0) == 0x40)  /* REX byte present.  */\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      unsigned char _rex = _rip[0] & 0x0f;\t\t\t\t\\\n+      _is_64_bit = (_rex & 0x08) != 0;\t\t\t\t\t\\\n+      _rip++;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* Detect a signed division of Integer.MIN_VALUE or Long.MIN_VALUE.  */ \\\n+  if (_rip[0] == 0xf7)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      bool _min_value_dividend = false;\t\t\t\t\t\\\n+      unsigned char _modrm = _rip[1];\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (((_modrm >> 3) & 7) == 7)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (_is_64_bit)\t\t\t\t\t\t\\\n+\t    _min_value_dividend = (_sc->rax == 0x8000000000000000L);\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    _min_value_dividend = ((_sc->rax & 0xffffffff) == 0x80000000); \\\n+\t}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (_min_value_dividend)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  unsigned char _rm = _modrm & 7;\t\t\t\t\\\n+\t  _sc->rdx = 0; /* the remainder is zero */\t\t\t\\\n+\t  switch (_modrm >> 6)\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t    case 0:  /* register indirect */\t\t\t\t\\\n+\t      if (_rm == 5)   /* 32-bit displacement */\t\t\t\\\n+\t\t_rip += 4;\t\t\t\t\t\t\\\n+\t      if (_rm == 4)  /* A SIB byte follows the ModR/M byte */\t\\\n+\t\t_rip += 1;\t\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+\t    case 1:  /* register indirect + 8-bit displacement */\t\\\n+\t      _rip += 1;\t\t\t\t\t\t\\\n+\t      if (_rm == 4)  /* A SIB byte follows the ModR/M byte */\t\\\n+\t\t_rip += 1;\t\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+\t    case 2:  /* register indirect + 32-bit displacement */\t\\\n+\t      _rip += 4;\t\t\t\t\t\t\\\n+\t      if (_rm == 4)  /* A SIB byte follows the ModR/M byte */\t\\\n+\t\t_rip += 1;\t\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+\t    case 3:\t\t\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  _rip += 2;\t\t\t\t\t\t\t\\\n+\t  _sc->rip = (unsigned long)_rip;\t\t\t\t\\\n+\t  return;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+while (0)\n \n extern \"C\" \n {\n@@ -65,12 +144,29 @@ do\t\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\\\n while (0)  \n \n-/* We use syscall(SYS_rt_sigaction) in INIT_SEGV instead of\n- * sigaction() because on some systems the pthreads wrappers for\n- * signal handlers are not compiled with unwind information, so it's\n- * not possible to unwind through them.  This is a problem that will\n- * go away if all systems ever have pthreads libraries that are\n- * compiled with unwind info.  */\n+#define INIT_FPE\t\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    struct kernel_sigaction act;\t\t\t\t\\\n+    act.k_sa_sigaction = _Jv_catch_fpe;\t\t\t\t\\\n+    sigemptyset (&act.k_sa_mask);\t\t\t\t\\\n+    act.k_sa_flags = SA_SIGINFO|0x4000000;\t\t\t\\\n+    act.k_sa_restorer = restore_rt;\t\t\t\t\\\n+    syscall (SYS_rt_sigaction, SIGFPE, &act, NULL, _NSIG / 8);\t\\\n+  }\t\t\t\t\t\t\t\t\\\n+while (0)  \n+\n+/* You might wonder why we use syscall(SYS_sigaction) in INIT_FPE\n+ * instead of the standard sigaction().  This is necessary because of\n+ * the shenanigans above where we increment the PC saved in the\n+ * context and then return.  This trick will only work when we are\n+ * called _directly_ by the kernel, because linuxthreads wraps signal\n+ * handlers and its wrappers do not copy the sigcontext struct back\n+ * when returning from a signal handler.  If we return from our divide\n+ * handler to a linuxthreads wrapper, we will lose the PC adjustment\n+ * we made and return to the faulting instruction again.  Using\n+ * syscall(SYS_sigaction) causes our handler to be called directly\n+ * by the kernel, bypassing any wrappers.  */\n \n #endif /* JAVA_SIGNAL_H */\n "}]}