{"sha": "03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNkNTA0NGIzMWY3YmY5NGZjZGE0MTM2YjRlZDg3YTVmZWU3NzM1ZA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-08-25T14:23:59Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-08-25T14:23:59Z"}, "message": "libstdc++: Add more C++20 additions to <chrono>\n\nThis patch adds the C++20 calendar types and their methods as defined in\n[time.cal] (modulo the parsing/printing support).  This patch also\nimplements [time.hms] and [time.12], and a few more bits of\n[time.clock].  The remaining C++20 additions to <chrono> from P0355 and\nP1466 depend on [time.zone] and <format>, so they will come later, as\nwill more optimized versions of some of the algorithms added here.\n\nThe non-member operator overloads for the calendar types are defined as\nnamespace-scope functions in the standard, but here we instead define\nthese operator overloads as hidden friends.  This simplifies the\nimplementation somewhat and lets us reap the benefits of hidden friends\nfor these overloads.\n\nThe bulk of this work is based on a patch from Ed Smith-Rowland, which can\nbe found at the Git branch users/redi/heads/calendar.\n\nCo-authored-by: Ed Smith-Rowland <3dw4rd@verizon.net>\nCo-authored-by: Jonathan Wakely <jwakely@redhat.com>\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/chrono (time_point::operator++)\n\t(time_point::operator--): Define.\n\t(utc_clock, tai_clock, gps_clock): Forward declare.\n\t(utc_time, utc_seconds, tai_time, tai_seconds, gps_time)\n\t(gps_seconds): Define.\n\t(is_clock<utc_clock>, is_clock<tai_clock>, is_clock<gps_clock>)\n\t(is_clock_v<utc_clock>, is_clock_v<tai_clock>)\n\t(is_clock_v<gps_clock>): Define these specializations.\n\t(leap_second_info): Define.\n\t(day, month, year, weekday, weekday_indexed)\n\t(weekday_last, month_day, month_day_last, month_weekday)\n\t(month_weekday_last, year_month, year_month_day)\n\t(year_month_day_last, year_month_weekday, year_month_weekday_last):\n\tDeclare and later define.\n\t(last_spec, last, __detail::__days_per_month)\n\t(__detail::__days_per_month, __detail::__last_day): Define.\n\t(January, February, March, April, May, June, July, August)\n\t(September, October, November, December, Sunday, Monday, Tuesday)\n\t(Wednesday, Thursday, Friday, Saturday): Define.\n\t(weekday::operator[]): Define out-of-line.\n\t(year_month_day::_S_from_days, year_month_day::M_days_since_epoch):\n\tLikewise.\n\t(year_month_day::year_month_day, year_month_day::ok): Likewise.\n\t(__detail::__pow10, hh_mm_ss): Define.\n\t(literals::chrono_literals::operator\"\"d)\n\t(literals::chrono_literals::operator\"\"y): Define.\n\t(is_am, is_pm, make12, make24): Define.\n\t* testsuite/20_util/time_point/4.cc: New test.\n\t* testsuite/std/time/day/1.cc: New test.\n\t* testsuite/std/time/hh_mm_ss/1.cc: New test.\n\t* testsuite/std/time/is_am/1.cc: New test.\n\t* testsuite/std/time/is_pm/1.cc: New test.\n\t* testsuite/std/time/make12/1.cc: New test.\n\t* testsuite/std/time/make24/1.cc: New test.\n\t* testsuite/std/time/month/1.cc: New test.\n\t* testsuite/std/time/month_day/1.cc: New test.\n\t* testsuite/std/time/month_day_last/1.cc: New test.\n\t* testsuite/std/time/month_weekday/1.cc: New test.\n\t* testsuite/std/time/month_weekday_last/1.cc: New test.\n\t* testsuite/std/time/weekday/1.cc: New test.\n\t* testsuite/std/time/weekday_indexed/1.cc: New test.\n\t* testsuite/std/time/weekday_last/1.cc: New test.\n\t* testsuite/std/time/year/1.cc: New test.\n\t* testsuite/std/time/year_month/1.cc: New test.\n\t* testsuite/std/time/year_month_day/1.cc: New test.\n\t* testsuite/std/time/year_month_day_last/1.cc: New test.\n\t* testsuite/std/time/year_month_weekday/1.cc: New test.\n\t* testsuite/std/time/year_month_weekday_last/1.cc: New test.", "tree": {"sha": "74dc8e721bfbc18318fe5beca51f9375fedf228e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74dc8e721bfbc18318fe5beca51f9375fedf228e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/comments", "author": null, "committer": null, "parents": [{"sha": "ef4af9eddea5a658eb7d6dc29fcb58aa54c9dd9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef4af9eddea5a658eb7d6dc29fcb58aa54c9dd9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef4af9eddea5a658eb7d6dc29fcb58aa54c9dd9f"}], "stats": {"total": 3425, "additions": 3321, "deletions": 104}, "files": [{"sha": "bf0d7e7af76638ee8fdfd84c21398d443174d262", "filename": "libstdc++-v3/include/std/chrono", "status": "modified", "additions": 2011, "deletions": 104, "changes": 2115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono?ref=03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "patch": "@@ -788,6 +788,30 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \ttime_since_epoch() const\n \t{ return __d; }\n \n+#if __cplusplus > 201703L\n+\tconstexpr time_point&\n+\toperator++()\n+\t{\n+\t  ++__d;\n+\t  return *this;\n+\t}\n+\n+\tconstexpr time_point\n+\toperator++(int)\n+\t{ return time_point{__d++}; }\n+\n+\tconstexpr time_point&\n+\toperator--()\n+\t{\n+\t  --__d;\n+\t  return *this;\n+\t}\n+\n+\tconstexpr time_point\n+\toperator--(int)\n+\t{ return time_point{__d--}; }\n+#endif\n+\n \t// arithmetic\n \t_GLIBCXX17_CONSTEXPR time_point&\n \toperator+=(const duration& __dur)\n@@ -1075,130 +1099,2013 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using local_time = time_point<local_t, _Duration>;\n     using local_seconds = local_time<seconds>;\n     using local_days = local_time<days>;\n-#endif // C++20\n \n-    // @}\n-  } // namespace chrono\n+    class utc_clock;\n+    class tai_clock;\n+    class gps_clock;\n \n-#if __cplusplus > 201103L\n+    template<typename _Duration>\n+      using utc_time = time_point<utc_clock, _Duration>;\n+    using utc_seconds = utc_time<seconds>;\n \n-#define __cpp_lib_chrono_udls 201304\n+    template<typename _Duration>\n+      using tai_time = time_point<tai_clock, _Duration>;\n+    using tai_seconds = tai_time<seconds>;\n \n-  inline namespace literals\n-  {\n-  /** ISO C++ 2014  namespace for suffixes for duration literals.\n-   *\n-   * These suffixes can be used to create `chrono::duration` values with\n-   * tick periods of hours, minutes, seconds, milliseconds, microseconds\n-   * or nanoseconds. For example, `std::chrono::seconds(5)` can be written\n-   * as `5s` after making the suffix visible in the current scope.\n-   * The suffixes can be made visible by a using-directive or\n-   * using-declaration such as:\n-   *  - `using namespace std::chrono_literals;`\n-   *  - `using namespace std::literals;`\n-   *  - `using namespace std::chrono;`\n-   *  - `using namespace std;`\n-   *  - `using std::chrono_literals::operator\"\"s;`\n-   *\n-   * The result of these suffixes on an integer literal is one of the\n-   * standard typedefs such as `std::chrono::hours`.\n-   * The result on a floating-point literal is a duration type with the\n-   * specified tick period and an unspecified floating-point representation,\n-   * for example `1.5e2ms` might be equivalent to\n-   * `chrono::duration<long double, chrono::milli>(1.5e2)`.\n-   *\n-   * @ingroup chrono\n-   */\n-  inline namespace chrono_literals\n-  {\n-#pragma GCC diagnostic push\n-#pragma GCC diagnostic ignored \"-Wliteral-suffix\"\n-    /// @cond undocumented\n-    template<typename _Dur, char... _Digits>\n-      constexpr _Dur __check_overflow()\n+    template<typename _Duration>\n+      using gps_time = time_point<gps_clock, _Duration>;\n+    using gps_seconds = gps_time<seconds>;\n+\n+    template<> struct is_clock<utc_clock> : true_type { };\n+    template<> struct is_clock<tai_clock> : true_type { };\n+    template<> struct is_clock<gps_clock> : true_type { };\n+\n+    template<> inline constexpr bool is_clock_v<utc_clock> = true;\n+    template<> inline constexpr bool is_clock_v<tai_clock> = true;\n+    template<> inline constexpr bool is_clock_v<gps_clock> = true;\n+\n+    struct leap_second_info\n+    {\n+      bool is_leap_second;\n+      seconds elapsed;\n+    };\n+\n+    // CALENDRICAL TYPES\n+\n+    // CLASS DECLARATIONS\n+    class day;\n+    class month;\n+    class year;\n+    class weekday;\n+    class weekday_indexed;\n+    class weekday_last;\n+    class month_day;\n+    class month_day_last;\n+    class month_weekday;\n+    class month_weekday_last;\n+    class year_month;\n+    class year_month_day;\n+    class year_month_day_last;\n+    class year_month_weekday;\n+    class year_month_weekday_last;\n+\n+    struct last_spec\n+    {\n+      explicit last_spec() = default;\n+\n+      friend constexpr month_day_last\n+      operator/(int __m, last_spec) noexcept;\n+\n+      friend constexpr month_day_last\n+      operator/(last_spec, int __m) noexcept;\n+    };\n+\n+    inline constexpr last_spec last{};\n+\n+    namespace __detail\n+    {\n+      // Compute the remainder of the Euclidean division of __n divided by __d.\n+      // Euclidean division truncates toward negative infinity and always\n+      // produces a remainder in the range of [0,__d-1] (whereas standard\n+      // division truncates toward zero and yields a nonpositive remainder\n+      // for negative __n).\n+      constexpr unsigned\n+      __modulo(long long __n, unsigned __d)\n       {\n-\tusing _Val = __parse_int::_Parse_int<_Digits...>;\n-\tconstexpr typename _Dur::rep __repval = _Val::value;\n-\tstatic_assert(__repval >= 0 && __repval == _Val::value,\n-\t\t      \"literal value cannot be represented by duration type\");\n-\treturn _Dur(__repval);\n+\tif (__n >= 0)\n+\t  return __n % __d;\n+\telse\n+\t  return (__d + (__n % __d)) % __d;\n       }\n-    /// @endcond\n \n-    /// Literal suffix for durations representing non-integer hours\n-    constexpr chrono::duration<long double, ratio<3600,1>>\n-    operator\"\"h(long double __hours)\n-    { return chrono::duration<long double, ratio<3600,1>>{__hours}; }\n+      inline constexpr unsigned __days_per_month[12]\n+\t= { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n \n-    /// Literal suffix for durations of type `std::chrono::hours`\n-    template <char... _Digits>\n-      constexpr chrono::hours\n-      operator\"\"h()\n-      { return __check_overflow<chrono::hours, _Digits...>(); }\n+      inline constexpr unsigned __last_day[12]\n+\t= { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n+    }\n \n-    /// Literal suffix for durations representing non-integer minutes\n-    constexpr chrono::duration<long double, ratio<60,1>>\n-    operator\"\"min(long double __mins)\n-    { return chrono::duration<long double, ratio<60,1>>{__mins}; }\n+    // DAY\n \n-    /// Literal suffix for durations of type `std::chrono::minutes`\n-    template <char... _Digits>\n-      constexpr chrono::minutes\n-      operator\"\"min()\n-      { return __check_overflow<chrono::minutes, _Digits...>(); }\n+    class day\n+    {\n+    private:\n+      unsigned char _M_d;\n \n-    /// Literal suffix for durations representing non-integer seconds\n-    constexpr chrono::duration<long double>\n-    operator\"\"s(long double __secs)\n-    { return chrono::duration<long double>{__secs}; }\n+    public:\n+      day() = default;\n \n-    /// Literal suffix for durations of type `std::chrono::seconds`\n-    template <char... _Digits>\n-      constexpr chrono::seconds\n-      operator\"\"s()\n-      { return __check_overflow<chrono::seconds, _Digits...>(); }\n+      explicit constexpr\n+      day(unsigned __d) noexcept\n+      : _M_d(__d)\n+      { }\n \n-    /// Literal suffix for durations representing non-integer milliseconds\n-    constexpr chrono::duration<long double, milli>\n-    operator\"\"ms(long double __msecs)\n-    { return chrono::duration<long double, milli>{__msecs}; }\n+      constexpr day&\n+      operator++() noexcept\n+      {\n+\t++_M_d;\n+\treturn *this;\n+      }\n \n-    /// Literal suffix for durations of type `std::chrono::milliseconds`\n-    template <char... _Digits>\n-      constexpr chrono::milliseconds\n-      operator\"\"ms()\n-      { return __check_overflow<chrono::milliseconds, _Digits...>(); }\n+      constexpr day\n+      operator++(int) noexcept\n+      {\n+\tauto __ret = *this;\n+\t++(*this);\n+\treturn __ret;\n+      }\n \n-    /// Literal suffix for durations representing non-integer microseconds\n-    constexpr chrono::duration<long double, micro>\n-    operator\"\"us(long double __usecs)\n-    { return chrono::duration<long double, micro>{__usecs}; }\n+      constexpr day&\n+      operator--() noexcept\n+      {\n+\t--_M_d;\n+\treturn *this;\n+      }\n \n-    /// Literal suffix for durations of type `std::chrono::microseconds`\n-    template <char... _Digits>\n-      constexpr chrono::microseconds\n-      operator\"\"us()\n-      { return __check_overflow<chrono::microseconds, _Digits...>(); }\n+      constexpr day\n+      operator--(int) noexcept\n+      {\n+\tauto __ret = *this;\n+\t--(*this);\n+\treturn __ret;\n+      }\n \n-    /// Literal suffix for durations representing non-integer nanoseconds\n-    constexpr chrono::duration<long double, nano>\n-    operator\"\"ns(long double __nsecs)\n-    { return chrono::duration<long double, nano>{__nsecs}; }\n+      constexpr day&\n+      operator+=(const days& __d) noexcept\n+      {\n+\t*this = *this + __d;\n+\treturn *this;\n+      }\n \n-    /// Literal suffix for durations of type `std::chrono::nanoseconds`\n-    template <char... _Digits>\n-      constexpr chrono::nanoseconds\n-      operator\"\"ns()\n-      { return __check_overflow<chrono::nanoseconds, _Digits...>(); }\n+      constexpr day&\n+      operator-=(const days& __d) noexcept\n+      {\n+\t*this = *this - __d;\n+\treturn *this;\n+      }\n \n-#pragma GCC diagnostic pop\n-  } // inline namespace chrono_literals\n-  } // inline namespace literals\n+      constexpr explicit\n+      operator unsigned() const noexcept\n+      { return _M_d; }\n \n-  namespace chrono\n-  {\n-    using namespace literals::chrono_literals;\n-  } // namespace chrono\n+      constexpr bool\n+      ok() const noexcept\n+      { return 1 <= _M_d && _M_d <= 31; }\n+\n+      friend constexpr bool\n+      operator==(const day& __x, const day& __y) noexcept\n+      { return unsigned{__x} == unsigned{__y}; }\n+\n+      friend constexpr strong_ordering\n+      operator<=>(const day& __x, const day& __y) noexcept\n+      { return unsigned{__x} <=> unsigned{__y}; }\n+\n+      friend constexpr day\n+      operator+(const day& __x, const days& __y) noexcept\n+      { return day(unsigned{__x} + __y.count()); }\n+\n+      friend constexpr day\n+      operator+(const days& __x, const day& __y) noexcept\n+      { return __y + __x; }\n+\n+      friend constexpr day\n+      operator-(const day& __x, const days& __y) noexcept\n+      { return __x + -__y; }\n+\n+      friend constexpr days\n+      operator-(const day& __x, const day& __y) noexcept\n+      { return days{int(unsigned{__x}) - int(unsigned{__y})}; }\n+\n+      friend constexpr month_day\n+      operator/(const month& __m, const day& __d) noexcept;\n+\n+      friend constexpr month_day\n+      operator/(int __m, const day& __d) noexcept;\n+\n+      friend constexpr month_day\n+      operator/(const day& __d, const month& __m) noexcept;\n+\n+      friend constexpr month_day\n+      operator/(const day& __d, int __m) noexcept;\n+\n+      friend constexpr year_month_day\n+      operator/(const year_month& __ym, const day& __d) noexcept;\n+\n+      // TODO: Implement operator<<, to_stream, from_stream.\n+    };\n+\n+    // MONTH\n+\n+    class month\n+    {\n+    private:\n+      unsigned char _M_m;\n+\n+    public:\n+      month() = default;\n+\n+      explicit constexpr\n+      month(unsigned __m) noexcept\n+      : _M_m(__m)\n+      { }\n+\n+      constexpr month&\n+      operator++() noexcept\n+      {\n+\t*this += months{1};\n+\treturn *this;\n+      }\n+\n+      constexpr month\n+      operator++(int) noexcept\n+      {\n+\tauto __ret = *this;\n+\t++(*this);\n+\treturn __ret;\n+      }\n+\n+      constexpr month&\n+      operator--() noexcept\n+      {\n+\t*this -= months{1};\n+\treturn *this;\n+      }\n+\n+      constexpr month\n+      operator--(int) noexcept\n+      {\n+\tauto __ret = *this;\n+\t--(*this);\n+\treturn __ret;\n+      }\n+\n+      constexpr month&\n+      operator+=(const months& __m) noexcept\n+      {\n+\t*this = *this + __m;\n+\treturn *this;\n+      }\n+\n+      constexpr month&\n+      operator-=(const months& __m) noexcept\n+      {\n+\t*this = *this - __m;\n+\treturn *this;\n+      }\n+\n+      explicit constexpr\n+      operator unsigned() const noexcept\n+      { return _M_m; }\n+\n+      constexpr bool\n+      ok() const noexcept\n+      { return 1 <= _M_m && _M_m <= 12; }\n+\n+      friend constexpr bool\n+      operator==(const month& __x, const month& __y) noexcept\n+      { return unsigned{__x} == unsigned{__y}; }\n+\n+      friend constexpr strong_ordering\n+      operator<=>(const month& __x, const month& __y) noexcept\n+      { return unsigned{__x} <=> unsigned{__y}; }\n+\n+      friend constexpr month\n+      operator+(const month& __x, const months& __y) noexcept\n+      {\n+\tauto __n = static_cast<long long>(unsigned{__x}) + (__y.count() - 1);\n+\treturn month{__detail::__modulo(__n, 12) + 1};\n+      }\n+\n+      friend constexpr month\n+      operator+(const months& __x,  const month& __y) noexcept\n+      { return __y + __x; }\n+\n+      friend constexpr month\n+      operator-(const month& __x, const months& __y) noexcept\n+      { return __x + -__y; }\n+\n+      friend constexpr months\n+      operator-(const month& __x,  const month& __y) noexcept\n+      {\n+\tconst auto __dm = int(unsigned(__x)) - int(unsigned(__y));\n+\treturn months{__dm < 0 ? 12 + __dm : __dm};\n+      }\n+\n+      friend constexpr year_month\n+      operator/(const year& __y, const month& __m) noexcept;\n+\n+      friend constexpr month_day\n+      operator/(const month& __m, int __d) noexcept;\n+\n+      friend constexpr month_day_last\n+      operator/(const month& __m, last_spec) noexcept;\n+\n+      friend constexpr month_day_last\n+      operator/(last_spec, const month& __m) noexcept;\n+\n+      friend constexpr month_weekday\n+      operator/(const month& __m, const weekday_indexed& __wdi) noexcept;\n+\n+      friend constexpr month_weekday\n+      operator/(const weekday_indexed& __wdi, const month& __m) noexcept;\n+\n+      friend constexpr month_weekday_last\n+      operator/(const month& __m, const weekday_last& __wdl) noexcept;\n+\n+      friend constexpr month_weekday_last\n+      operator/(const weekday_last& __wdl, const month& __m) noexcept;\n+\n+      // TODO: Implement operator<<, to_stream, from_stream.\n+    };\n+\n+    inline constexpr month January{1};\n+    inline constexpr month February{2};\n+    inline constexpr month March{3};\n+    inline constexpr month April{4};\n+    inline constexpr month May{5};\n+    inline constexpr month June{6};\n+    inline constexpr month July{7};\n+    inline constexpr month August{8};\n+    inline constexpr month September{9};\n+    inline constexpr month October{10};\n+    inline constexpr month November{11};\n+    inline constexpr month December{12};\n+\n+    // YEAR\n+\n+    class year\n+    {\n+    private:\n+      short _M_y;\n+\n+    public:\n+      year() = default;\n+\n+      explicit constexpr\n+      year(int __y) noexcept\n+      : _M_y{static_cast<short>(__y)}\n+      { }\n+\n+      static constexpr year\n+      min() noexcept\n+      { return year{-32767}; }\n+\n+      static constexpr year\n+      max() noexcept\n+      { return year{32767}; }\n+\n+      constexpr year&\n+      operator++() noexcept\n+      {\n+\t++_M_y;\n+\treturn *this;\n+      }\n+\n+      constexpr year\n+      operator++(int) noexcept\n+      {\n+\tauto __ret = *this;\n+\t++(*this);\n+\treturn __ret;\n+      }\n+\n+      constexpr year&\n+      operator--() noexcept\n+      {\n+\t--_M_y;\n+\treturn *this;\n+      }\n+\n+      constexpr year\n+      operator--(int) noexcept\n+      {\n+\tauto __ret = *this;\n+\t--(*this);\n+\treturn __ret;\n+      }\n+\n+      constexpr year&\n+      operator+=(const years& __y) noexcept\n+      {\n+\t*this = *this + __y;\n+\treturn *this;\n+      }\n+\n+      constexpr year&\n+      operator-=(const years& __y) noexcept\n+      {\n+\t*this = *this - __y;\n+\treturn *this;\n+      }\n+\n+      constexpr year\n+      operator+() const noexcept\n+      { return *this; }\n+\n+      constexpr year\n+      operator-() const noexcept\n+      { return year{-_M_y}; }\n+\n+      constexpr bool\n+      is_leap() const noexcept\n+      { return _M_y % 4 == 0 && (_M_y % 100 != 0 || _M_y % 400 == 0); }\n+\n+      explicit constexpr\n+      operator int() const noexcept\n+      { return _M_y; }\n+\n+      constexpr bool\n+      ok() const noexcept\n+      { return min()._M_y <= _M_y && _M_y <= max()._M_y; }\n+\n+      friend constexpr bool\n+      operator==(const year& __x, const year& __y) noexcept\n+      { return int{__x} == int{__y}; }\n+\n+      friend constexpr strong_ordering\n+      operator<=>(const year& __x, const year& __y) noexcept\n+      { return int{__x} <=> int{__y}; }\n+\n+      friend constexpr year\n+      operator+(const year& __x, const years& __y) noexcept\n+      { return year{int{__x} + __y.count()}; }\n+\n+      friend constexpr year\n+      operator+(const years& __x, const year& __y) noexcept\n+      { return __y + __x; }\n+\n+      friend constexpr year\n+      operator-(const year& __x, const years& __y) noexcept\n+      { return __x + -__y; }\n+\n+      friend constexpr years\n+      operator-(const year& __x, const year& __y) noexcept\n+      { return years{int{__x} - int{__y}}; }\n+\n+      friend constexpr year_month\n+      operator/(const year& __y, int __m) noexcept;\n+\n+      friend constexpr year_month_day\n+      operator/(const year& __y, const month_day& __md) noexcept;\n+\n+      friend constexpr year_month_day\n+      operator/(const month_day& __md, const year& __y) noexcept;\n+\n+      friend constexpr year_month_day_last\n+      operator/(const year& __y, const month_day_last& __mdl) noexcept;\n+\n+      friend constexpr year_month_day_last\n+      operator/(const month_day_last& __mdl, const year& __y) noexcept;\n+\n+      friend constexpr year_month_weekday\n+      operator/(const year& __y, const month_weekday& __mwd) noexcept;\n+\n+      friend constexpr year_month_weekday\n+      operator/(const month_weekday& __mwd, const year& __y) noexcept;\n+\n+      friend constexpr year_month_weekday_last\n+      operator/(const year& __y, const month_weekday_last& __mwdl) noexcept;\n+\n+      friend constexpr year_month_weekday_last\n+      operator/(const month_weekday_last& __mwdl, const year& __y) noexcept;\n+\n+      // TODO: Implement operator<<, to_stream, from_stream.\n+    };\n+\n+    // WEEKDAY\n+\n+    class weekday\n+    {\n+    private:\n+      unsigned char _M_wd;\n+\n+      static constexpr weekday\n+      _S_from_days(const days& __d)\n+      {\n+\tauto __n = __d.count();\n+\treturn weekday(__n >= -4 ? (__n + 4) % 7 : (__n + 5) % 7 + 6);\n+      }\n+\n+    public:\n+      weekday() = default;\n+\n+      explicit constexpr\n+      weekday(unsigned __wd) noexcept\n+      : _M_wd(__wd == 7 ? 0 : __wd) // __wd % 7 ?\n+      { }\n+\n+      constexpr\n+      weekday(const sys_days& __dp) noexcept\n+      : weekday{_S_from_days(__dp.time_since_epoch())}\n+      { }\n+\n+      explicit constexpr\n+      weekday(const local_days& __dp) noexcept\n+      : weekday{sys_days{__dp.time_since_epoch()}}\n+      { }\n+\n+      constexpr weekday&\n+      operator++() noexcept\n+      {\n+\t*this += days{1};\n+\treturn *this;\n+      }\n+\n+      constexpr weekday\n+      operator++(int) noexcept\n+      {\n+\tauto __ret = *this;\n+\t++(*this);\n+\treturn __ret;\n+      }\n+\n+      constexpr weekday&\n+      operator--() noexcept\n+      {\n+\t*this -= days{1};\n+\treturn *this;\n+      }\n+\n+      constexpr weekday\n+      operator--(int) noexcept\n+      {\n+\tauto __ret = *this;\n+\t--(*this);\n+\treturn __ret;\n+      }\n+\n+      constexpr weekday&\n+      operator+=(const days& __d) noexcept\n+      {\n+\t*this = *this + __d;\n+\treturn *this;\n+      }\n+\n+      constexpr weekday&\n+      operator-=(const days& __d) noexcept\n+      {\n+\t*this = *this - __d;\n+\treturn *this;\n+      }\n+\n+      constexpr unsigned\n+      c_encoding() const noexcept\n+      { return _M_wd; }\n+\n+      constexpr unsigned\n+      iso_encoding() const noexcept\n+      { return _M_wd == 0u ? 7u : _M_wd; }\n+\n+      constexpr bool\n+      ok() const noexcept\n+      { return _M_wd <= 6; }\n+\n+      constexpr weekday_indexed\n+      operator[](unsigned __index) const noexcept;\n+\n+      constexpr weekday_last\n+      operator[](last_spec) const noexcept;\n+\n+      friend constexpr bool\n+      operator==(const weekday& __x, const weekday& __y) noexcept\n+      { return __x._M_wd == __y._M_wd; }\n+\n+      friend constexpr weekday\n+      operator+(const weekday& __x, const days& __y) noexcept\n+      {\n+\tauto __n = static_cast<long long>(__x._M_wd) + __y.count();\n+\treturn weekday{__detail::__modulo(__n, 7)};\n+      }\n+\n+      friend constexpr weekday\n+      operator+(const days& __x, const weekday& __y) noexcept\n+      { return __y + __x; }\n+\n+      friend constexpr weekday\n+      operator-(const weekday& __x, const days& __y) noexcept\n+      { return __x + -__y; }\n+\n+      friend constexpr days\n+      operator-(const weekday& __x, const weekday& __y) noexcept\n+      {\n+\tauto __n = static_cast<long long>(__x._M_wd) - __y._M_wd;\n+\treturn days{__detail::__modulo(__n, 7)};\n+      }\n+\n+      // TODO: operator<<, from_stream.\n+    };\n+\n+    inline constexpr weekday Sunday{0};\n+    inline constexpr weekday Monday{1};\n+    inline constexpr weekday Tuesday{2};\n+    inline constexpr weekday Wednesday{3};\n+    inline constexpr weekday Thursday{4};\n+    inline constexpr weekday Friday{5};\n+    inline constexpr weekday Saturday{6};\n+\n+    // WEEKDAY_INDEXED\n+\n+    class weekday_indexed\n+    {\n+    private:\n+      chrono::weekday _M_wd;\n+      unsigned char _M_index;\n+\n+    public:\n+      weekday_indexed() = default;\n+\n+      constexpr\n+      weekday_indexed(const chrono::weekday& __wd, unsigned __index) noexcept\n+      : _M_wd(__wd), _M_index(__index)\n+      { }\n+\n+      constexpr chrono::weekday\n+      weekday() const noexcept\n+      { return _M_wd; }\n+\n+      constexpr unsigned\n+      index() const noexcept\n+      { return _M_index; };\n+\n+      constexpr bool\n+      ok() const noexcept\n+      { return _M_wd.ok() && 1 <= _M_index && _M_index <= 5; }\n+\n+      friend constexpr bool\n+      operator==(const weekday_indexed& __x, const weekday_indexed& __y) noexcept\n+      { return __x.weekday() == __y.weekday() && __x.index() == __y.index(); }\n+\n+      friend constexpr month_weekday\n+      operator/(const month& __m, const weekday_indexed& __wdi) noexcept;\n+\n+      friend constexpr month_weekday\n+      operator/(int __m, const weekday_indexed& __wdi) noexcept;\n+\n+      friend constexpr month_weekday\n+      operator/(const weekday_indexed& __wdi, const month& __m) noexcept;\n+\n+      friend constexpr month_weekday\n+      operator/(const weekday_indexed& __wdi, int __m) noexcept;\n+\n+      friend constexpr year_month_weekday\n+      operator/(const year_month& __ym, const weekday_indexed& __wdi) noexcept;\n+\n+      // TODO: Implement operator<<.\n+    };\n+\n+    constexpr weekday_indexed\n+    weekday::operator[](unsigned __index) const noexcept\n+    { return {*this, __index}; }\n+\n+    // WEEKDAY_LAST\n+\n+    class weekday_last\n+    {\n+    private:\n+      chrono::weekday _M_wd;\n+\n+    public:\n+      explicit constexpr\n+      weekday_last(const chrono::weekday& __wd) noexcept\n+      : _M_wd{__wd}\n+      { }\n+\n+      constexpr chrono::weekday\n+      weekday() const noexcept\n+      { return _M_wd; }\n+\n+      constexpr bool\n+      ok() const noexcept\n+      { return _M_wd.ok(); }\n+\n+      friend constexpr bool\n+      operator==(const weekday_last& __x, const weekday_last& __y) noexcept\n+      { return __x.weekday() == __y.weekday(); }\n+\n+      friend constexpr month_weekday_last\n+      operator/(int __m, const weekday_last& __wdl) noexcept;\n+\n+      friend constexpr month_weekday_last\n+      operator/(const weekday_last& __wdl, int __m) noexcept;\n+\n+      friend constexpr year_month_weekday_last\n+      operator/(const year_month& __ym, const weekday_last& __wdl) noexcept;\n+\n+      // TODO: Implement operator<<.\n+    };\n+\n+    constexpr weekday_last\n+    weekday::operator[](last_spec) const noexcept\n+    { return weekday_last{*this}; }\n+\n+    // MONTH_DAY\n+\n+    class month_day\n+    {\n+    private:\n+      chrono::month _M_m;\n+      chrono::day _M_d;\n+\n+    public:\n+      month_day() = default;\n+\n+      constexpr\n+      month_day(const chrono::month& __m, const chrono::day& __d) noexcept\n+      : _M_m{__m}, _M_d{__d}\n+      { }\n+\n+      constexpr chrono::month\n+      month() const noexcept\n+      { return _M_m; }\n+\n+      constexpr chrono::day\n+      day() const noexcept\n+      { return _M_d; }\n+\n+      constexpr bool\n+      ok() const noexcept\n+      {\n+\treturn _M_m.ok()\n+\t  && 1u <= unsigned(_M_d)\n+\t  && unsigned(_M_d) <= __detail::__days_per_month[unsigned(_M_m) - 1];\n+      }\n+\n+      friend constexpr bool\n+      operator==(const month_day& __x, const month_day& __y) noexcept\n+      { return __x.month() == __y.month() && __x.day() == __y.day(); }\n+\n+      friend constexpr strong_ordering\n+      operator<=>(const month_day& __x, const month_day& __y) noexcept\n+\t= default;\n+\n+      friend constexpr month_day\n+      operator/(const chrono::month& __m, const chrono::day& __d) noexcept\n+      { return {__m, __d}; }\n+\n+      friend constexpr month_day\n+      operator/(const chrono::month& __m, int __d) noexcept\n+      { return {__m, chrono::day(unsigned(__d))}; }\n+\n+      friend constexpr month_day\n+      operator/(int __m, const chrono::day& __d) noexcept\n+      { return {chrono::month(unsigned(__m)), __d}; }\n+\n+      friend constexpr month_day\n+      operator/(const chrono::day& __d, const chrono::month& __m) noexcept\n+      { return {__m, __d}; }\n+\n+      friend constexpr month_day\n+      operator/(const chrono::day& __d, int __m) noexcept\n+      { return {chrono::month(unsigned(__m)), __d}; }\n+\n+      friend constexpr year_month_day\n+      operator/(int __y, const month_day& __md) noexcept;\n+\n+      friend constexpr year_month_day\n+      operator/(const month_day& __md, int __y) noexcept;\n+\n+      // TODO: Implement operator<<, from_stream.\n+    };\n+\n+    // MONTH_DAY_LAST\n+\n+    class month_day_last\n+    {\n+    private:\n+      chrono::month _M_m;\n+\n+    public:\n+      explicit constexpr\n+      month_day_last(const chrono::month& __m) noexcept\n+      : _M_m{__m}\n+      { }\n+\n+      constexpr chrono::month\n+      month() const noexcept\n+      { return _M_m; }\n+\n+      constexpr bool\n+      ok() const noexcept\n+      { return _M_m.ok(); }\n+\n+      friend constexpr bool\n+      operator==(const month_day_last& __x, const month_day_last& __y) noexcept\n+      { return __x.month() == __y.month(); }\n+\n+      friend constexpr strong_ordering\n+      operator<=>(const month_day_last& __x, const month_day_last& __y) noexcept\n+\t= default;\n+\n+      friend constexpr month_day_last\n+      operator/(const chrono::month& __m, last_spec) noexcept\n+      { return month_day_last{__m}; }\n+\n+      friend constexpr month_day_last\n+      operator/(int __m, last_spec) noexcept\n+      { return chrono::month(unsigned(__m)) / last; }\n+\n+      friend constexpr month_day_last\n+      operator/(last_spec, const chrono::month& __m) noexcept\n+      { return __m / last; }\n+\n+      friend constexpr month_day_last\n+      operator/(last_spec, int __m) noexcept\n+      { return __m / last; }\n+\n+      friend constexpr year_month_day_last\n+      operator/(int __y, const month_day_last& __mdl) noexcept;\n+\n+      friend constexpr year_month_day_last\n+      operator/(const month_day_last& __mdl, int __y) noexcept;\n+\n+      // TODO: Implement operator<<.\n+    };\n+\n+    // MONTH_WEEKDAY\n+\n+    class month_weekday\n+    {\n+    private:\n+      chrono::month _M_m;\n+      chrono::weekday_indexed _M_wdi;\n+\n+    public:\n+      constexpr\n+      month_weekday(const chrono::month& __m,\n+\t\t    const chrono::weekday_indexed& __wdi) noexcept\n+      : _M_m{__m}, _M_wdi{__wdi}\n+      { }\n+\n+      constexpr chrono::month\n+      month() const noexcept\n+      { return _M_m; }\n+\n+      constexpr chrono::weekday_indexed\n+      weekday_indexed() const noexcept\n+      { return _M_wdi; }\n+\n+      constexpr bool\n+      ok() const noexcept\n+      { return _M_m.ok() && _M_wdi.ok(); }\n+\n+      friend constexpr bool\n+      operator==(const month_weekday& __x, const month_weekday& __y) noexcept\n+      {\n+\treturn __x.month() == __y.month()\n+\t  && __x.weekday_indexed() == __y.weekday_indexed();\n+      }\n+\n+      friend constexpr month_weekday\n+      operator/(const chrono::month& __m,\n+\t\tconst chrono::weekday_indexed& __wdi) noexcept\n+      { return {__m, __wdi}; }\n+\n+      friend constexpr month_weekday\n+      operator/(int __m, const chrono::weekday_indexed& __wdi) noexcept\n+      { return chrono::month(unsigned(__m)) / __wdi; }\n+\n+      friend constexpr month_weekday\n+      operator/(const chrono::weekday_indexed& __wdi,\n+\t\tconst chrono::month& __m) noexcept\n+      { return __m / __wdi; }\n+\n+      friend constexpr month_weekday\n+      operator/(const chrono::weekday_indexed& __wdi, int __m) noexcept\n+      { return __m / __wdi; }\n+\n+      friend constexpr year_month_weekday\n+      operator/(int __y, const month_weekday& __mwd) noexcept;\n+\n+      friend constexpr year_month_weekday\n+      operator/(const month_weekday& __mwd, int __y) noexcept;\n+\n+      // TODO: Implement operator<<.\n+    };\n+\n+    // MONTH_WEEKDAY_LAST\n+\n+    class month_weekday_last\n+    {\n+    private:\n+      chrono::month _M_m;\n+      chrono::weekday_last _M_wdl;\n+\n+    public:\n+      constexpr\n+      month_weekday_last(const chrono::month& __m,\n+\t\t\t const chrono::weekday_last& __wdl) noexcept\n+      :_M_m{__m}, _M_wdl{__wdl}\n+      { }\n+\n+      constexpr chrono::month\n+      month() const noexcept\n+      { return _M_m; }\n+\n+      constexpr chrono::weekday_last\n+      weekday_last() const noexcept\n+      { return _M_wdl; }\n+\n+      constexpr bool\n+      ok() const noexcept\n+      { return _M_m.ok() && _M_wdl.ok(); }\n+\n+      friend constexpr bool\n+      operator==(const month_weekday_last& __x,\n+\t\t const month_weekday_last& __y) noexcept\n+      {\n+\treturn __x.month() == __y.month()\n+\t  && __x.weekday_last() == __y.weekday_last();\n+      }\n+\n+      friend constexpr month_weekday_last\n+      operator/(const chrono::month& __m,\n+\t\tconst chrono::weekday_last& __wdl) noexcept\n+      { return {__m, __wdl}; }\n+\n+      friend constexpr month_weekday_last\n+      operator/(int __m, const chrono::weekday_last& __wdl) noexcept\n+      { return chrono::month(unsigned(__m)) / __wdl; }\n+\n+      friend constexpr month_weekday_last\n+      operator/(const chrono::weekday_last& __wdl,\n+\t\tconst chrono::month& __m) noexcept\n+      { return __m / __wdl; }\n+\n+      friend constexpr month_weekday_last\n+      operator/(const chrono::weekday_last& __wdl, int __m) noexcept\n+      { return chrono::month(unsigned(__m)) / __wdl; }\n+\n+      friend constexpr year_month_weekday_last\n+      operator/(int __y, const month_weekday_last& __mwdl) noexcept;\n+\n+      friend constexpr year_month_weekday_last\n+      operator/(const month_weekday_last& __mwdl, int __y) noexcept;\n+\n+      // TODO: Implement operator<<.\n+    };\n+\n+    // YEAR_MONTH\n+\n+    class year_month\n+    {\n+    private:\n+      chrono::year _M_y;\n+      chrono::month _M_m;\n+\n+    public:\n+      year_month() = default;\n+\n+      constexpr\n+      year_month(const chrono::year& __y, const chrono::month& __m) noexcept\n+      : _M_y{__y}, _M_m{__m}\n+      { }\n+\n+      constexpr chrono::year\n+      year() const noexcept\n+      { return _M_y; }\n+\n+      constexpr chrono::month\n+      month() const noexcept\n+      { return _M_m; }\n+\n+      constexpr year_month&\n+      operator+=(const months& __dm) noexcept\n+      {\n+\t*this = *this + __dm;\n+\treturn *this;\n+      }\n+\n+      constexpr year_month&\n+      operator-=(const months& __dm) noexcept\n+      {\n+\t*this = *this - __dm;\n+\treturn *this;\n+      }\n+\n+      constexpr year_month&\n+      operator+=(const years& __dy)  noexcept\n+      {\n+\t*this = *this + __dy;\n+\treturn *this;\n+      }\n+\n+      constexpr year_month&\n+      operator-=(const years& __dy)  noexcept\n+      {\n+\t*this = *this - __dy;\n+\treturn *this;\n+      }\n+\n+      constexpr bool\n+      ok() const noexcept\n+      { return _M_y.ok() && _M_m.ok(); }\n+\n+      friend constexpr bool\n+      operator==(const year_month& __x, const year_month& __y) noexcept\n+      { return __x.year() == __y.year() && __x.month() == __y.month(); }\n+\n+      friend constexpr strong_ordering\n+      operator<=>(const year_month& __x, const year_month& __y) noexcept\n+\t= default;\n+\n+      friend constexpr year_month\n+      operator+(const year_month& __ym, const months& __dm) noexcept\n+      {\n+\t// TODO: Optimize?\n+\tauto __m = __ym.month() + __dm;\n+\tauto __i = unsigned{__ym.month()} - 1 + __dm.count();\n+\tauto __y = (__i < 0\n+\t\t    ? __ym.year() + years{(__i - 11) / 12}\n+\t\t    : __ym.year() + years{__i / 12});\n+\treturn __y / __m;\n+      }\n+\n+      friend constexpr year_month\n+      operator+(const months& __dm, const year_month& __ym) noexcept\n+      { return __ym + __dm; }\n+\n+      friend constexpr year_month\n+      operator-(const year_month& __ym, const months& __dm) noexcept\n+      { return __ym + -__dm; }\n+\n+      friend constexpr months\n+      operator-(const year_month& __x, const year_month& __y) noexcept\n+      {\n+\treturn (__x.year() - __y.year()\n+\t\t+ months{static_cast<int>(unsigned{__x.month()})\n+\t\t\t - static_cast<int>(unsigned{__y.month()})});\n+      }\n+\n+      friend constexpr year_month\n+      operator+(const year_month& __ym, const years& __dy) noexcept\n+      { return (__ym.year() + __dy) / __ym.month(); }\n+\n+      friend constexpr year_month\n+      operator+(const years& __dy, const year_month& __ym) noexcept\n+      { return __ym + __dy; }\n+\n+      friend constexpr year_month\n+      operator-(const year_month& __ym, const years& __dy) noexcept\n+      { return __ym + -__dy; }\n+\n+      friend constexpr year_month\n+      operator/(const chrono::year& __y, const chrono::month& __m) noexcept\n+      { return {__y, __m}; }\n+\n+      friend constexpr year_month\n+      operator/(const chrono::year& __y, int __m) noexcept\n+      { return {__y, chrono::month(unsigned(__m))}; }\n+\n+      friend constexpr year_month_day\n+      operator/(const year_month& __ym, int __d) noexcept;\n+\n+      friend constexpr year_month_day_last\n+      operator/(const year_month& __ym, last_spec) noexcept;\n+\n+      // TODO: Implement operator<<, from_stream.\n+    };\n+\n+    // YEAR_MONTH_DAY\n+\n+    class year_month_day\n+    {\n+    private:\n+      chrono::year _M_y;\n+      chrono::month _M_m;\n+      chrono::day _M_d;\n+\n+      static constexpr year_month_day _S_from_days(const days& __dp) noexcept;\n+\n+      constexpr days _M_days_since_epoch() const noexcept;\n+\n+    public:\n+      year_month_day() = default;\n+\n+      constexpr\n+      year_month_day(const chrono::year& __y, const chrono::month& __m,\n+\t\t     const chrono::day& __d) noexcept\n+      : _M_y{__y}, _M_m{__m}, _M_d{__d}\n+      { }\n+\n+      constexpr\n+      year_month_day(const year_month_day_last& __ymdl) noexcept;\n+\n+      constexpr\n+      year_month_day(const sys_days& __dp) noexcept\n+      : year_month_day(_S_from_days(__dp.time_since_epoch()))\n+      { }\n+\n+      explicit constexpr\n+      year_month_day(const local_days& __dp) noexcept\n+      : year_month_day(sys_days{__dp.time_since_epoch()})\n+      { }\n+\n+      constexpr year_month_day&\n+      operator+=(const months& __m) noexcept\n+      {\n+\t*this = *this + __m;\n+\treturn *this;\n+      }\n+\n+      constexpr year_month_day&\n+      operator-=(const months& __m) noexcept\n+      {\n+\t*this = *this - __m;\n+\treturn *this;\n+      }\n+\n+      constexpr year_month_day&\n+      operator+=(const years& __y) noexcept\n+      {\n+\t*this = *this + __y;\n+\treturn *this;\n+      }\n+\n+      constexpr year_month_day&\n+      operator-=(const years& __y) noexcept\n+      {\n+\t*this = *this - __y;\n+\treturn *this;\n+      }\n+\n+      constexpr chrono::year\n+      year() const noexcept\n+      { return _M_y; }\n+\n+      constexpr chrono::month\n+      month() const noexcept\n+      { return _M_m; }\n+\n+      constexpr chrono::day\n+      day() const noexcept\n+      { return _M_d; }\n+\n+      constexpr\n+      operator sys_days() const noexcept\n+      { return sys_days{_M_days_since_epoch()}; }\n+\n+      explicit constexpr\n+      operator local_days() const noexcept\n+      { return local_days{sys_days{*this}.time_since_epoch()}; }\n+\n+      constexpr bool ok() const noexcept;\n+\n+      friend constexpr bool\n+      operator==(const year_month_day& __x, const year_month_day& __y) noexcept\n+      {\n+\treturn __x.year() == __y.year()\n+\t  && __x.month() == __y.month()\n+\t  && __x.day() == __y.day();\n+      }\n+\n+      friend constexpr strong_ordering\n+      operator<=>(const year_month_day& __x, const year_month_day& __y) noexcept\n+\t= default;\n+\n+      friend constexpr year_month_day\n+      operator+(const year_month_day& __ymd, const months& __dm) noexcept\n+      { return (__ymd.year() / __ymd.month() + __dm) / __ymd.day(); }\n+\n+      friend constexpr year_month_day\n+      operator+(const months& __dm, const year_month_day& __ymd) noexcept\n+      { return __ymd + __dm; }\n+\n+      friend constexpr year_month_day\n+      operator+(const year_month_day& __ymd, const years& __dy) noexcept\n+      { return (__ymd.year() + __dy) / __ymd.month() / __ymd.day(); }\n+\n+      friend constexpr year_month_day\n+      operator+(const years& __dy, const year_month_day& __ymd) noexcept\n+      { return __ymd + __dy; }\n+\n+      friend constexpr year_month_day\n+      operator-(const year_month_day& __ymd, const months& __dm) noexcept\n+      { return __ymd + -__dm; }\n+\n+      friend constexpr year_month_day\n+      operator-(const year_month_day& __ymd, const years& __dy) noexcept\n+      { return __ymd + -__dy; }\n+\n+      friend constexpr year_month_day\n+      operator/(const year_month& __ym, const chrono::day& __d) noexcept\n+      { return {__ym.year(), __ym.month(), __d}; }\n+\n+      friend constexpr year_month_day\n+      operator/(const year_month& __ym, int __d) noexcept\n+      { return __ym / chrono::day{unsigned(__d)}; }\n+\n+      friend constexpr year_month_day\n+      operator/(const chrono::year& __y, const month_day& __md) noexcept\n+      { return __y / __md.month() / __md.day(); }\n+\n+      friend constexpr year_month_day\n+      operator/(int __y, const month_day& __md) noexcept\n+      { return chrono::year{__y} / __md; }\n+\n+      friend constexpr year_month_day\n+      operator/(const month_day& __md, const chrono::year& __y) noexcept\n+      { return __y / __md; }\n+\n+      friend constexpr year_month_day\n+      operator/(const month_day& __md, int __y) noexcept\n+      { return chrono::year(__y) / __md; }\n+\n+      // TODO: Implement operator<<, from_stream.\n+    };\n+\n+    // Construct from days since 1970/01/01. Magic.\n+    constexpr year_month_day\n+    year_month_day::_S_from_days(const days& __dp) noexcept\n+    {\n+      const auto __z = __dp.count() + 719468;\n+      const auto __era = (__z >= 0 ? __z : __z - 146096) / 146097;\n+      const auto __doe = static_cast<unsigned>(__z - __era * 146097);\n+      const auto __yoe\n+\t= (__doe - __doe / 1460 + __doe / 36524 - __doe / 146096) / 365;\n+      const auto __y = static_cast<days::rep>(__yoe) + __era * 400;\n+      const auto __doy = __doe - (365 * __yoe + __yoe / 4 - __yoe / 100);\n+      const auto __mp = (5 * __doy + 2) / 153;\n+      const auto __d = __doy - (153 * __mp + 2) / 5 + 1;\n+      const auto __m = __mp < 10 ? __mp + 3 : __mp - 9;\n+      return year_month_day{chrono::year(__y + (__m <= 2)),\n+\t\t\t    chrono::month(__m), chrono::day(__d)};\n+    }\n+\n+    // Days since 1970/01/01. Magic.\n+    constexpr days\n+    year_month_day::_M_days_since_epoch() const noexcept\n+    {\n+      const auto __y = static_cast<int>(_M_y) - (_M_m <= February);\n+      const auto __m = static_cast<unsigned>(_M_m);\n+      const auto __d = static_cast<unsigned>(_M_d);\n+      const auto __era = (__y >= 0 ? __y : __y - 399) / 400;\n+      // Year of \"era\" [0, 399].\n+      const auto __yoe = static_cast<unsigned>(__y - __era * 400);\n+      // Day of year [0, 365].\n+      const auto __doy = (153 * (__m > 2 ? __m - 3 : __m + 9) + 2) / 5 + __d - 1;\n+      // Day of \"era\" [0, 146096].\n+      const auto __doe = __yoe * 365 + __yoe / 4 - __yoe / 100 + __doy;\n+      const auto __days = __era * 146097 + static_cast<int>(__doe) - 719468;\n+      return days{__days};\n+    }\n+\n+    // YEAR_MONTH_DAY_LAST\n+\n+    class year_month_day_last\n+    {\n+    private:\n+      chrono::year _M_y;\n+      chrono::month_day_last _M_mdl;\n+\n+    public:\n+      constexpr\n+      year_month_day_last(const chrono::year& __y,\n+\t\t\t  const chrono::month_day_last& __mdl) noexcept\n+      : _M_y{__y}, _M_mdl{__mdl}\n+      { }\n+\n+      constexpr year_month_day_last&\n+      operator+=(const months& __m) noexcept\n+      {\n+\t*this = *this + __m;\n+\treturn *this;\n+      }\n+\n+      constexpr year_month_day_last&\n+      operator-=(const months& __m) noexcept\n+      {\n+\t*this = *this - __m;\n+\treturn *this;\n+      }\n+\n+      constexpr year_month_day_last&\n+      operator+=(const years& __y)  noexcept\n+      {\n+\t*this = *this + __y;\n+\treturn *this;\n+      }\n+\n+      constexpr year_month_day_last&\n+      operator-=(const years& __y)  noexcept\n+      {\n+\t*this = *this - __y;\n+\treturn *this;\n+      }\n+\n+      constexpr chrono::year\n+      year() const noexcept\n+      { return _M_y; }\n+\n+      constexpr chrono::month\n+      month() const noexcept\n+      { return _M_mdl.month(); }\n+\n+      constexpr chrono::month_day_last\n+      month_day_last() const noexcept\n+      { return _M_mdl; }\n+\n+      // Return A day representing the last day of this year, month pair.\n+      constexpr chrono::day\n+      day() const noexcept\n+      {\n+\tif (!_M_mdl.ok() || (month() == February && _M_y.is_leap()))\n+\t  return chrono::day{29};\n+\treturn chrono::day{__detail::__last_day[unsigned(month()) - 1]};\n+      }\n+\n+      constexpr\n+      operator sys_days() const noexcept\n+      { return sys_days{year() / month() / day()}; }\n+\n+      explicit constexpr\n+      operator local_days() const noexcept\n+      { return local_days{sys_days{*this}.time_since_epoch()}; }\n+\n+      constexpr bool\n+      ok() const noexcept\n+      { return _M_y.ok() && _M_mdl.ok(); }\n+\n+      friend constexpr bool\n+      operator==(const year_month_day_last& __x,\n+\t\t const year_month_day_last& __y) noexcept\n+      {\n+\treturn __x.year() == __y.year()\n+\t  && __x.month_day_last() == __y.month_day_last();\n+      }\n+\n+      friend constexpr strong_ordering\n+      operator<=>(const year_month_day_last& __x,\n+\t\t  const year_month_day_last& __y) noexcept\n+\t= default;\n+\n+      friend constexpr year_month_day_last\n+      operator+(const year_month_day_last& __ymdl,\n+\t\tconst months& __dm) noexcept\n+      { return (__ymdl.year() / __ymdl.month() + __dm) / last; }\n+\n+      friend constexpr year_month_day_last\n+      operator+(const months& __dm,\n+\t\tconst year_month_day_last& __ymdl) noexcept\n+      { return __ymdl + __dm; }\n+\n+      friend constexpr year_month_day_last\n+      operator-(const year_month_day_last& __ymdl,\n+\t\tconst months& __dm) noexcept\n+      { return __ymdl + -__dm; }\n+\n+      friend constexpr year_month_day_last\n+      operator+(const year_month_day_last& __ymdl,\n+\t\tconst years& __dy) noexcept\n+      { return {__ymdl.year() + __dy, __ymdl.month_day_last()}; }\n+\n+      friend constexpr year_month_day_last\n+      operator+(const years& __dy,\n+\t\tconst year_month_day_last& __ymdl) noexcept\n+      { return __ymdl + __dy; }\n+\n+      friend constexpr year_month_day_last\n+      operator-(const year_month_day_last& __ymdl,\n+\t\tconst years& __dy) noexcept\n+      { return __ymdl + -__dy; }\n+\n+      friend constexpr year_month_day_last\n+      operator/(const year_month& __ym, last_spec) noexcept\n+      { return {__ym.year(), chrono::month_day_last{__ym.month()}}; }\n+\n+      friend constexpr year_month_day_last\n+      operator/(const chrono::year& __y,\n+\t\tconst chrono::month_day_last& __mdl) noexcept\n+      { return {__y, __mdl}; }\n+\n+      friend constexpr year_month_day_last\n+      operator/(int __y, const chrono::month_day_last& __mdl) noexcept\n+      { return chrono::year(__y) / __mdl; }\n+\n+      friend constexpr year_month_day_last\n+      operator/(const chrono::month_day_last& __mdl,\n+\t\tconst chrono::year& __y) noexcept\n+      { return __y / __mdl; }\n+\n+      friend constexpr year_month_day_last\n+      operator/(const chrono::month_day_last& __mdl, int __y) noexcept\n+      { return chrono::year(__y) / __mdl; }\n+\n+      // TODO: Implement operator<<.\n+    };\n+\n+    // year_month_day ctor from year_month_day_last\n+    constexpr\n+    year_month_day::year_month_day(const year_month_day_last& __ymdl) noexcept\n+    : _M_y{__ymdl.year()}, _M_m{__ymdl.month()}, _M_d{__ymdl.day()}\n+    { }\n+\n+    constexpr bool\n+    year_month_day::ok() const noexcept\n+    {\n+      if (!_M_y.ok() || !_M_m.ok())\n+\treturn false;\n+      return chrono::day{1} <= _M_d && _M_d <= (_M_y / _M_m / last).day();\n+    }\n+\n+    // YEAR_MONTH_WEEKDAY\n+\n+    class year_month_weekday\n+    {\n+    private:\n+      chrono::year _M_y;\n+      chrono::month _M_m;\n+      chrono::weekday_indexed _M_wdi;\n+\n+      static constexpr year_month_weekday\n+      _S_from_sys_days(const sys_days& __dp)\n+      {\n+\tyear_month_day __ymd{__dp};\n+\tchrono::weekday __wd{__dp};\n+\tauto __index = __wd[(unsigned{__ymd.day()} - 1) / 7 + 1];\n+\treturn {__ymd.year(), __ymd.month(), __index};\n+      }\n+\n+    public:\n+      year_month_weekday() = default;\n+\n+      constexpr\n+      year_month_weekday(const chrono::year& __y, const chrono::month& __m,\n+\t\t\t const chrono::weekday_indexed& __wdi) noexcept\n+      : _M_y{__y}, _M_m{__m}, _M_wdi{__wdi}\n+      { }\n+\n+      constexpr\n+      year_month_weekday(const sys_days& __dp) noexcept\n+      : year_month_weekday{_S_from_sys_days(__dp)}\n+      { }\n+\n+      explicit constexpr\n+      year_month_weekday(const local_days& __dp) noexcept\n+      : year_month_weekday{sys_days{__dp.time_since_epoch()}}\n+      { }\n+\n+      constexpr year_month_weekday&\n+      operator+=(const months& __m) noexcept\n+      {\n+\t*this = *this + __m;\n+\treturn *this;\n+      }\n+\n+      constexpr year_month_weekday&\n+      operator-=(const months& __m) noexcept\n+      {\n+\t*this = *this - __m;\n+\treturn *this;\n+      }\n+\n+      constexpr year_month_weekday&\n+      operator+=(const years& __y) noexcept\n+      {\n+\t*this = *this + __y;\n+\treturn *this;\n+      }\n+\n+      constexpr year_month_weekday&\n+      operator-=(const years& __y) noexcept\n+      {\n+\t*this = *this - __y;\n+\treturn *this;\n+      }\n+\n+      constexpr chrono::year\n+      year() const noexcept\n+      { return _M_y; }\n+\n+      constexpr chrono::month\n+      month() const noexcept\n+      { return _M_m; }\n+\n+      constexpr chrono::weekday\n+      weekday() const noexcept\n+      { return _M_wdi.weekday(); }\n+\n+      constexpr unsigned\n+      index() const noexcept\n+      { return _M_wdi.index(); }\n+\n+      constexpr chrono::weekday_indexed\n+      weekday_indexed() const noexcept\n+      { return _M_wdi; }\n+\n+      constexpr\n+      operator sys_days() const noexcept\n+      {\n+\tauto __d = sys_days{year() / month() / 1};\n+\treturn __d + (weekday() - chrono::weekday(__d) + days{(index()-1)*7});\n+      }\n+\n+      explicit constexpr\n+      operator local_days() const noexcept\n+      { return local_days{sys_days{*this}.time_since_epoch()}; }\n+\n+      constexpr bool\n+      ok() const noexcept\n+      {\n+\tif (!_M_y.ok() || !_M_m.ok() || !_M_wdi.ok())\n+\t  return false;\n+\tif (_M_wdi.index() <= 4)\n+\t  return true;\n+\tdays __d = (_M_wdi.weekday()\n+\t\t    - chrono::weekday{sys_days{_M_y / _M_m / 1}}\n+\t\t    + days((_M_wdi.index()-1)*7 + 1));\n+\t__glibcxx_assert(__d >= 1);\n+\treturn __d.count() <= unsigned{(_M_y / _M_m / last).day()};\n+      }\n+\n+      friend constexpr bool\n+      operator==(const year_month_weekday& __x,\n+\t\t const year_month_weekday& __y) noexcept\n+      {\n+\treturn __x.year() == __y.year()\n+\t  && __x.month() == __y.month()\n+\t  && __x.weekday() == __y.weekday();\n+      }\n+\n+      friend constexpr year_month_weekday\n+      operator+(const year_month_weekday& __ymwd, const months& __dm) noexcept\n+      { return (__ymwd.year() / __ymwd.month() + __dm) / __ymwd.weekday_indexed(); }\n+\n+      friend constexpr year_month_weekday\n+      operator+(const months& __dm, const year_month_weekday& __ymwd) noexcept\n+      { return __ymwd + __dm; }\n+\n+      friend constexpr year_month_weekday\n+      operator+(const year_month_weekday& __ymwd, const years& __dy) noexcept\n+      { return {__ymwd.year() + __dy, __ymwd.month(), __ymwd.weekday_indexed()}; }\n+\n+      friend constexpr year_month_weekday\n+      operator+(const years& __dy, const year_month_weekday& __ymwd) noexcept\n+      { return __ymwd + __dy; }\n+\n+      friend constexpr year_month_weekday\n+      operator-(const year_month_weekday& __ymwd, const months& __dm) noexcept\n+      { return __ymwd + -__dm; }\n+\n+      friend constexpr year_month_weekday\n+      operator-(const year_month_weekday& __ymwd, const years& __dy) noexcept\n+      { return __ymwd + -__dy; }\n+\n+      friend constexpr year_month_weekday\n+      operator/(const year_month& __ym,\n+\t\tconst chrono::weekday_indexed& __wdi) noexcept\n+      { return {__ym.year(), __ym.month(), __wdi}; }\n+\n+      friend constexpr year_month_weekday\n+      operator/(const chrono::year& __y, const month_weekday& __mwd) noexcept\n+      { return {__y, __mwd.month(), __mwd.weekday_indexed()}; }\n+\n+      friend constexpr year_month_weekday\n+      operator/(int __y, const month_weekday& __mwd) noexcept\n+      { return chrono::year(__y) / __mwd; }\n+\n+      friend constexpr year_month_weekday\n+      operator/(const month_weekday& __mwd, const chrono::year& __y) noexcept\n+      { return __y / __mwd; }\n+\n+      friend constexpr year_month_weekday\n+      operator/(const month_weekday& __mwd, int __y) noexcept\n+      { return chrono::year(__y) / __mwd; }\n+\n+      // TODO: Implement operator<<.\n+    };\n+\n+    // YEAR_MONTH_WEEKDAY_LAST\n+\n+    class year_month_weekday_last\n+    {\n+    private:\n+      chrono::year _M_y;\n+      chrono::month _M_m;\n+      chrono::weekday_last _M_wdl;\n+\n+    public:\n+      constexpr\n+      year_month_weekday_last(const chrono::year& __y, const chrono::month& __m,\n+\t\t\t      const chrono::weekday_last& __wdl) noexcept\n+      : _M_y{__y}, _M_m{__m}, _M_wdl{__wdl}\n+      { }\n+\n+      constexpr year_month_weekday_last&\n+      operator+=(const months& __m) noexcept\n+      {\n+\t*this = *this + __m;\n+\treturn *this;\n+      }\n+\n+      constexpr year_month_weekday_last&\n+      operator-=(const months& __m) noexcept\n+      {\n+\t*this = *this - __m;\n+\treturn *this;\n+      }\n+\n+      constexpr year_month_weekday_last&\n+      operator+=(const years& __y)  noexcept\n+      {\n+\t*this = *this + __y;\n+\treturn *this;\n+      }\n+\n+      constexpr year_month_weekday_last&\n+      operator-=(const years& __y)  noexcept\n+      {\n+\t*this = *this - __y;\n+\treturn *this;\n+      }\n+\n+      constexpr chrono::year\n+      year() const noexcept\n+      { return _M_y; }\n+\n+      constexpr chrono::month\n+      month() const noexcept\n+      { return _M_m; }\n+\n+      constexpr chrono::weekday\n+      weekday() const noexcept\n+      { return _M_wdl.weekday(); }\n+\n+      constexpr chrono::weekday_last\n+      weekday_last() const noexcept\n+      { return _M_wdl; }\n+\n+      constexpr\n+      operator sys_days() const noexcept\n+      {\n+\tconst auto __d = sys_days{_M_y / _M_m / last};\n+\treturn sys_days{(__d - (chrono::weekday{__d}\n+\t\t\t\t- _M_wdl.weekday())).time_since_epoch()};\n+      }\n+\n+      explicit constexpr\n+      operator local_days() const noexcept\n+      { return local_days{sys_days{*this}.time_since_epoch()}; }\n+\n+      constexpr bool\n+      ok() const noexcept\n+      { return _M_y.ok() && _M_m.ok() && _M_wdl.ok(); }\n+\n+      friend constexpr bool\n+      operator==(const year_month_weekday_last& __x,\n+\t\t const year_month_weekday_last& __y) noexcept\n+      {\n+\treturn __x.year() == __y.year()\n+\t  && __x.month() == __y.month()\n+\t  && __x.weekday_last() == __y.weekday_last();\n+      }\n+\n+      friend constexpr year_month_weekday_last\n+      operator+(const year_month_weekday_last& __ymwdl,\n+\t\tconst months& __dm) noexcept\n+      { return (__ymwdl.year() / __ymwdl.month() + __dm) / __ymwdl.weekday_last(); }\n+\n+      friend constexpr year_month_weekday_last\n+      operator+(const months& __dm,\n+\t\tconst year_month_weekday_last& __ymwdl) noexcept\n+      { return __ymwdl + __dm; }\n+\n+      friend constexpr year_month_weekday_last\n+      operator+(const year_month_weekday_last& __ymwdl,\n+\t\tconst years& __dy) noexcept\n+      { return {__ymwdl.year() + __dy, __ymwdl.month(), __ymwdl.weekday_last()}; }\n+\n+      friend constexpr year_month_weekday_last\n+      operator+(const years& __dy,\n+\t\tconst year_month_weekday_last& __ymwdl) noexcept\n+      { return __ymwdl + __dy; }\n+\n+      friend constexpr year_month_weekday_last\n+      operator-(const year_month_weekday_last& __ymwdl,\n+\t\tconst months& __dm) noexcept\n+      { return __ymwdl + -__dm; }\n+\n+      friend constexpr year_month_weekday_last\n+      operator-(const year_month_weekday_last& __ymwdl,\n+\t\tconst years& __dy) noexcept\n+      { return __ymwdl + -__dy; }\n+\n+      friend constexpr year_month_weekday_last\n+      operator/(const year_month& __ym,\n+\t\tconst chrono::weekday_last& __wdl) noexcept\n+      { return {__ym.year(), __ym.month(), __wdl}; }\n+\n+      friend constexpr year_month_weekday_last\n+      operator/(const chrono::year& __y,\n+\t\tconst chrono::month_weekday_last& __mwdl) noexcept\n+      { return {__y, __mwdl.month(), __mwdl.weekday_last()}; }\n+\n+      friend constexpr year_month_weekday_last\n+      operator/(int __y, const chrono::month_weekday_last& __mwdl) noexcept\n+      { return chrono::year(__y) / __mwdl; }\n+\n+      friend constexpr year_month_weekday_last\n+      operator/(const chrono::month_weekday_last& __mwdl,\n+\t\tconst chrono::year& __y) noexcept\n+      { return __y / __mwdl; }\n+\n+      friend constexpr year_month_weekday_last\n+      operator/(const chrono::month_weekday_last& __mwdl, int __y) noexcept\n+      { return chrono::year(__y) / __mwdl; }\n+\n+      // TODO: Implement operator<<.\n+    };\n+\n+    // HH_MM_SS\n+\n+    namespace __detail\n+    {\n+      consteval long long\n+      __pow10(unsigned __n)\n+      {\n+\tlong long __r = 1;\n+\twhile (__n-- > 0)\n+\t  __r *= 10;\n+\treturn __r;\n+      }\n+    }\n+\n+    template<typename _Duration>\n+      class hh_mm_ss\n+      {\n+      private:\n+\tstatic constexpr int\n+\t_S_fractional_width()\n+\t{\n+\t  int __multiplicity_2 = 0;\n+\t  int __multiplicity_5 = 0;\n+\t  auto __den = _Duration::period::den;\n+\t  while ((__den % 2) == 0)\n+\t    {\n+\t      ++__multiplicity_2;\n+\t      __den /= 2;\n+\t    }\n+\t  while ((__den % 5) == 0)\n+\t    {\n+\t      ++__multiplicity_5;\n+\t      __den /= 5;\n+\t    }\n+\t  if (__den != 1)\n+\t    return 6;\n+\n+\t  int __width = (__multiplicity_2 > __multiplicity_5\n+\t\t\t ? __multiplicity_2 : __multiplicity_5);\n+\t  if (__width > 18)\n+\t    __width = 18;\n+\t  return __width;\n+\t}\n+\n+      public:\n+\tstatic constexpr unsigned fractional_width = {_S_fractional_width()};\n+\n+\tusing precision\n+\t  = duration<common_type_t<typename _Duration::rep,\n+\t\t\t\t   chrono::seconds::rep>,\n+\t\t     ratio<1, __detail::__pow10(fractional_width)>>;\n+\n+\tconstexpr\n+\thh_mm_ss() noexcept\n+\t: hh_mm_ss{_Duration::zero()}\n+\t{ }\n+\n+\tconstexpr explicit\n+\thh_mm_ss(_Duration __d) noexcept\n+\t: _M_is_neg (__d < _Duration::zero()),\n+\t  _M_h (duration_cast<chrono::hours>(abs(__d))),\n+\t  _M_m (duration_cast<chrono::minutes>(abs(__d) - hours())),\n+\t  _M_s (duration_cast<chrono::seconds>(abs(__d) - hours() - minutes()))\n+\t{\n+\t  if constexpr (treat_as_floating_point_v<typename precision::rep>)\n+\t    _M_ss = abs(__d) - hours() - minutes() - seconds();\n+\t  else\n+\t    _M_ss = duration_cast<precision>(abs(__d) - hours()\n+\t\t\t\t\t     - minutes() - seconds());\n+\t}\n+\n+\tconstexpr bool\n+\tis_negative() const noexcept\n+\t{ return _M_is_neg; }\n+\n+\tconstexpr chrono::hours\n+\thours() const noexcept\n+\t{ return _M_h; }\n+\n+\tconstexpr chrono::minutes\n+\tminutes() const noexcept\n+\t{ return _M_m; }\n+\n+\tconstexpr chrono::seconds\n+\tseconds() const noexcept\n+\t{ return _M_s; }\n+\n+\tconstexpr precision\n+\tsubseconds() const noexcept\n+\t{ return _M_ss; }\n+\n+\tconstexpr explicit\n+\toperator precision() const noexcept\n+\t{ return to_duration(); }\n+\n+\tconstexpr precision\n+\tto_duration() const noexcept\n+\t{\n+\t  if (_M_is_neg)\n+\t    return -(_M_h + _M_m + _M_s + _M_ss);\n+\t  else\n+\t    return _M_h + _M_m + _M_s + _M_ss;\n+\t}\n+\n+\t// TODO: Implement operator<<.\n+\n+      private:\n+\tbool _M_is_neg;\n+\tchrono::hours _M_h;\n+\tchrono::minutes _M_m;\n+\tchrono::seconds _M_s;\n+\tprecision _M_ss;\n+      };\n+#endif // C++20\n+\n+    // @}\n+  } // namespace chrono\n+\n+#if __cplusplus > 201103L\n+\n+#define __cpp_lib_chrono_udls 201304\n+\n+  inline namespace literals\n+  {\n+  /** ISO C++ 2014  namespace for suffixes for duration literals.\n+   *\n+   * These suffixes can be used to create `chrono::duration` values with\n+   * tick periods of hours, minutes, seconds, milliseconds, microseconds\n+   * or nanoseconds. For example, `std::chrono::seconds(5)` can be written\n+   * as `5s` after making the suffix visible in the current scope.\n+   * The suffixes can be made visible by a using-directive or\n+   * using-declaration such as:\n+   *  - `using namespace std::chrono_literals;`\n+   *  - `using namespace std::literals;`\n+   *  - `using namespace std::chrono;`\n+   *  - `using namespace std;`\n+   *  - `using std::chrono_literals::operator\"\"s;`\n+   *\n+   * The result of these suffixes on an integer literal is one of the\n+   * standard typedefs such as `std::chrono::hours`.\n+   * The result on a floating-point literal is a duration type with the\n+   * specified tick period and an unspecified floating-point representation,\n+   * for example `1.5e2ms` might be equivalent to\n+   * `chrono::duration<long double, chrono::milli>(1.5e2)`.\n+   *\n+   * @ingroup chrono\n+   */\n+  inline namespace chrono_literals\n+  {\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wliteral-suffix\"\n+    /// @cond undocumented\n+    template<typename _Dur, char... _Digits>\n+      constexpr _Dur __check_overflow()\n+      {\n+\tusing _Val = __parse_int::_Parse_int<_Digits...>;\n+\tconstexpr typename _Dur::rep __repval = _Val::value;\n+\tstatic_assert(__repval >= 0 && __repval == _Val::value,\n+\t\t      \"literal value cannot be represented by duration type\");\n+\treturn _Dur(__repval);\n+      }\n+    /// @endcond\n+\n+    /// Literal suffix for durations representing non-integer hours\n+    constexpr chrono::duration<long double, ratio<3600,1>>\n+    operator\"\"h(long double __hours)\n+    { return chrono::duration<long double, ratio<3600,1>>{__hours}; }\n+\n+    /// Literal suffix for durations of type `std::chrono::hours`\n+    template <char... _Digits>\n+      constexpr chrono::hours\n+      operator\"\"h()\n+      { return __check_overflow<chrono::hours, _Digits...>(); }\n+\n+    /// Literal suffix for durations representing non-integer minutes\n+    constexpr chrono::duration<long double, ratio<60,1>>\n+    operator\"\"min(long double __mins)\n+    { return chrono::duration<long double, ratio<60,1>>{__mins}; }\n+\n+    /// Literal suffix for durations of type `std::chrono::minutes`\n+    template <char... _Digits>\n+      constexpr chrono::minutes\n+      operator\"\"min()\n+      { return __check_overflow<chrono::minutes, _Digits...>(); }\n+\n+    /// Literal suffix for durations representing non-integer seconds\n+    constexpr chrono::duration<long double>\n+    operator\"\"s(long double __secs)\n+    { return chrono::duration<long double>{__secs}; }\n+\n+    /// Literal suffix for durations of type `std::chrono::seconds`\n+    template <char... _Digits>\n+      constexpr chrono::seconds\n+      operator\"\"s()\n+      { return __check_overflow<chrono::seconds, _Digits...>(); }\n+\n+    /// Literal suffix for durations representing non-integer milliseconds\n+    constexpr chrono::duration<long double, milli>\n+    operator\"\"ms(long double __msecs)\n+    { return chrono::duration<long double, milli>{__msecs}; }\n+\n+    /// Literal suffix for durations of type `std::chrono::milliseconds`\n+    template <char... _Digits>\n+      constexpr chrono::milliseconds\n+      operator\"\"ms()\n+      { return __check_overflow<chrono::milliseconds, _Digits...>(); }\n+\n+    /// Literal suffix for durations representing non-integer microseconds\n+    constexpr chrono::duration<long double, micro>\n+    operator\"\"us(long double __usecs)\n+    { return chrono::duration<long double, micro>{__usecs}; }\n+\n+    /// Literal suffix for durations of type `std::chrono::microseconds`\n+    template <char... _Digits>\n+      constexpr chrono::microseconds\n+      operator\"\"us()\n+      { return __check_overflow<chrono::microseconds, _Digits...>(); }\n+\n+    /// Literal suffix for durations representing non-integer nanoseconds\n+    constexpr chrono::duration<long double, nano>\n+    operator\"\"ns(long double __nsecs)\n+    { return chrono::duration<long double, nano>{__nsecs}; }\n+\n+    /// Literal suffix for durations of type `std::chrono::nanoseconds`\n+    template <char... _Digits>\n+      constexpr chrono::nanoseconds\n+      operator\"\"ns()\n+      { return __check_overflow<chrono::nanoseconds, _Digits...>(); }\n+\n+#if __cplusplus > 201703L\n+    constexpr chrono::day\n+    operator\"\"d(unsigned long long __d) noexcept\n+    { return chrono::day{static_cast<unsigned>(__d)}; }\n+\n+    constexpr chrono::year\n+    operator\"\"y(unsigned long long __y) noexcept\n+    { return chrono::year{static_cast<int>(__y)}; }\n+#endif // C++20\n+\n+#pragma GCC diagnostic pop\n+  } // inline namespace chrono_literals\n+  } // inline namespace literals\n+\n+  namespace chrono\n+  {\n+    using namespace literals::chrono_literals;\n+  } // namespace chrono\n+\n+#if __cplusplus > 201703L\n+  namespace chrono\n+  {\n+    // 12/24 HOURS FUNCTIONS\n+\n+    constexpr bool\n+    is_am(const hours& __h) noexcept\n+    { return 0h <= __h && __h <= 11h; }\n+\n+    constexpr bool\n+    is_pm(const hours& __h) noexcept\n+    { return 12h <= __h && __h <= 23h; }\n+\n+    constexpr hours\n+    make12(const hours& __h) noexcept\n+    {\n+      if (__h == 0h)\n+\treturn 12h;\n+      else if (__h > 12h)\n+\treturn __h - 12h;\n+      return __h;\n+    }\n+\n+    constexpr hours\n+    make24(const hours& __h, bool __is_pm) noexcept\n+    {\n+      if (!__is_pm)\n+\t{\n+\t  if (__h == 12h)\n+\t    return 0h;\n+\t  else\n+\t    return __h;\n+\t}\n+      else\n+\t{\n+\t  if (__h == 12h)\n+\t    return __h;\n+\t  else\n+\t    return __h + 12h;\n+\t}\n+    }\n+  }\n+#endif\n \n #if __cplusplus >= 201703L\n   namespace filesystem"}, {"sha": "5ae4acbaffc3c1ead633737e19cb115450dfb6f2", "filename": "libstdc++-v3/testsuite/20_util/time_point/4.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftime_point%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftime_point%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftime_point%2F4.cc?ref=03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "patch": "@@ -0,0 +1,42 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.8.4 Class template time_point [time.point]\n+\n+#include <chrono>\n+\n+constexpr bool\n+test_time_point_increment_ops()\n+{\n+  using namespace std::chrono;\n+  bool ok = true;\n+  time_point<local_t, seconds> tp(seconds(1));\n+\n+  ok &= tp.time_since_epoch() == 1s;\n+  ok &= (tp++).time_since_epoch() == 1s;\n+  ok &= tp.time_since_epoch() == 2s;\n+  ok &= (++tp).time_since_epoch() == 3s;\n+  ok &= (tp--).time_since_epoch() == 3s;\n+  ok &= tp.time_since_epoch() == 2s;\n+  ok &= (--tp).time_since_epoch() == 1s;\n+  ok &= tp.time_since_epoch() == 1s;\n+  return ok;\n+}\n+static_assert(test_time_point_increment_ops());"}, {"sha": "7e5abc4107d92e9442678f771ac03994cf954034", "filename": "libstdc++-v3/testsuite/std/time/day/1.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fday%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fday%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fday%2F1.cc?ref=03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "patch": "@@ -0,0 +1,67 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Class template day [time.cal.day]\n+\n+#include <chrono>\n+\n+constexpr void\n+constexpr_day()\n+{\n+  using namespace std::chrono;\n+\n+  day dd{};\n+  ++(++dd);\n+  dd++;\n+  --(--dd);\n+  dd--;\n+  dd += days{3};\n+  dd -= days{3};\n+\n+  static_assert(day{1} + days{2} == day{3});\n+  static_assert(days{2} + day{1} == day{3});\n+  static_assert(day{3} - day{1} == days{2});\n+  static_assert(day{3} - days{1} == day{2});\n+\n+  static_assert(++day{4} == day{5});\n+  static_assert(day{4}++ == day{4});\n+  static_assert(--day{4} == day{3});\n+  static_assert(day{4}-- == day{4});\n+  static_assert((day{4} += days{3}) == day{7});\n+  static_assert((day{4} -= days{3}) == day{1});\n+\n+  static_assert(!day{}.ok());\n+  static_assert(day{1}.ok());\n+  static_assert(day{31}.ok());\n+  static_assert(!day{32}.ok());\n+\n+  static_assert(unsigned{day{7}} == 7);\n+\n+  static_assert(!(day{0} == day{1}));\n+  static_assert( (day{0} != day{2}));\n+  static_assert( (day{0} <  day{3}));\n+  static_assert(!(day{0} >  day{4}));\n+  static_assert( (day{0} <= day{5}));\n+  static_assert(!(day{0} >= day{6}));\n+\n+  static_assert(day{0} <=> day{1} == std::strong_ordering::less);\n+  static_assert(day{3} <=> day{3} == std::strong_ordering::equal);\n+  static_assert(day{5} <=> day{2} == std::strong_ordering::greater);\n+}"}, {"sha": "acb8643d4d0439e6d2fb6fc530fc437dd83125a9", "filename": "libstdc++-v3/testsuite/std/time/hh_mm_ss/1.cc", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fhh_mm_ss%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fhh_mm_ss%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fhh_mm_ss%2F1.cc?ref=03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "patch": "@@ -0,0 +1,63 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Class template hh_mm_ss [time.hh_mm_ss]\n+\n+#include <chrono>\n+\n+constexpr void\n+constexpr_hh_mm_ss()\n+{\n+  using namespace std::chrono;\n+  using std::ratio;\n+\n+  static_assert(hh_mm_ss<hours>::fractional_width == 0);\n+  static_assert(hh_mm_ss<minutes>::fractional_width == 0);\n+  static_assert(hh_mm_ss<seconds>::fractional_width == 0);\n+  static_assert(hh_mm_ss<milliseconds>::fractional_width == 3);\n+  static_assert(hh_mm_ss<microseconds>::fractional_width == 6);\n+  static_assert(hh_mm_ss<nanoseconds>::fractional_width == 9);\n+  static_assert(hh_mm_ss<duration<int, ratio<1, 2>>>::fractional_width == 1);\n+  static_assert(hh_mm_ss<duration<int, ratio<1, 3>>>::fractional_width == 6);\n+  static_assert(hh_mm_ss<duration<int, ratio<1, 4>>>::fractional_width == 2);\n+  static_assert(hh_mm_ss<duration<int, ratio<2, 4>>>::fractional_width == 1);\n+  static_assert(hh_mm_ss<duration<int, ratio<1, 5>>>::fractional_width == 1);\n+  static_assert(hh_mm_ss<duration<int, ratio<1, 6>>>::fractional_width == 6);\n+  static_assert(hh_mm_ss<duration<int, ratio<1, 7>>>::fractional_width == 6);\n+  static_assert(hh_mm_ss<duration<int, ratio<1, 8>>>::fractional_width == 3);\n+  static_assert(hh_mm_ss<duration<int, ratio<1, 9>>>::fractional_width == 6);\n+  static_assert(hh_mm_ss<duration<int, ratio<1, 10>>>::fractional_width == 1);\n+  static_assert(hh_mm_ss<duration<int, ratio<756, 625>>>::fractional_width == 4);\n+  static_assert(hh_mm_ss<duration<int, ratio<1, (1ll << 62)>>>::fractional_width\n+\t\t== 18);\n+\n+  constexpr auto hms = hh_mm_ss{-(8h + 9min + 10s + 11ms + 12us + 13ns)};\n+  static_assert(__is_same(decltype(hms)::precision, nanoseconds));\n+  static_assert(hms.hours() == 8h);\n+  static_assert(hms.minutes() == 9min);\n+  static_assert(hms.seconds() == 10s);\n+  static_assert(hms.subseconds() == 11ms + 12us + 13ns);\n+  static_assert(hms.is_negative());\n+  static_assert(hh_mm_ss{hms.to_duration()}.to_duration() == hms.to_duration());\n+\n+  static_assert(seconds{hh_mm_ss{100min}} == 100min);\n+\n+  // TODO: treat_as_floating_point_v\n+}"}, {"sha": "c452f4b65e3787d6aa12a488043bc3ec34ecdd07", "filename": "libstdc++-v3/testsuite/std/time/is_am/1.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fis_am%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fis_am%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fis_am%2F1.cc?ref=03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "patch": "@@ -0,0 +1,35 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Function is_am [time.12]\n+\n+#include <chrono>\n+\n+constexpr void\n+constexpr_is_am()\n+{\n+  using namespace std::chrono;\n+  static_assert(is_am(0h));\n+  static_assert(is_am(5h));\n+  static_assert(is_am(11h));\n+  static_assert(!is_am(12h));\n+  static_assert(!is_am(15h));\n+  static_assert(!is_am(23h));\n+}"}, {"sha": "4ca5d930a41abe030f17dc7c4c6d626c9bd3dc43", "filename": "libstdc++-v3/testsuite/std/time/is_pm/1.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fis_pm%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fis_pm%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fis_pm%2F1.cc?ref=03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "patch": "@@ -0,0 +1,35 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Function is_pm [time.12]\n+\n+#include <chrono>\n+\n+constexpr void\n+constexpr_is_pm()\n+{\n+  using namespace std::chrono;\n+  static_assert(!is_pm(0h));\n+  static_assert(!is_pm(5h));\n+  static_assert(!is_pm(11h));\n+  static_assert(is_pm(12h));\n+  static_assert(is_pm(15h));\n+  static_assert(is_pm(23h));\n+}"}, {"sha": "c13167b437a67537bba0125782101057136409da", "filename": "libstdc++-v3/testsuite/std/time/make12/1.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmake12%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmake12%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmake12%2F1.cc?ref=03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "patch": "@@ -0,0 +1,36 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Function is_pm [time.12]\n+\n+#include <chrono>\n+\n+constexpr void\n+constexpr_make12()\n+{\n+  using namespace std::chrono;\n+  static_assert(make12(0h) == 12h);\n+  static_assert(make12(1h) == 1h);\n+  static_assert(make12(5h) == 5h);\n+  static_assert(make12(12h) == 12h);\n+  static_assert(make12(13h) == 1h);\n+  static_assert(make12(19h) == 7h);\n+  static_assert(make12(23h) == 11h);\n+}"}, {"sha": "ee4c3f921c9172fa44c8f0122f9fb597571e50c4", "filename": "libstdc++-v3/testsuite/std/time/make24/1.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmake24%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmake24%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmake24%2F1.cc?ref=03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "patch": "@@ -0,0 +1,41 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Function is_pm [time.12]\n+\n+#include <chrono>\n+\n+constexpr void\n+constexpr_make24()\n+{\n+  using namespace std::chrono;\n+\n+  static_assert(make24(0h, false) == 0h);\n+  static_assert(make24(1h, false) == 1h);\n+  static_assert(make24(5h, false) == 5h);\n+  static_assert(make24(11h, false) == 11h);\n+  static_assert(make24(12h, false) == 0h);\n+\n+  static_assert(make24(0h, true) == 12h);\n+  static_assert(make24(1h, true) == 13h);\n+  static_assert(make24(5h, true) == 17h);\n+  static_assert(make24(11h, true) == 23h);\n+  static_assert(make24(12h, true) == 12h);\n+}"}, {"sha": "b5e74b090b19fb7919b08445b47d92d671eca557", "filename": "libstdc++-v3/testsuite/std/time/month/1.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmonth%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmonth%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmonth%2F1.cc?ref=03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "patch": "@@ -0,0 +1,75 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Class template day [time.cal.month]\n+\n+#include <chrono>\n+\n+constexpr void\n+constexpr_month()\n+{\n+  using namespace std::chrono;\n+\n+  month dm{};\n+  ++(++dm);\n+  dm++;\n+  --(--dm);\n+  dm--;\n+  dm += months{3};\n+  dm -= months{3};\n+\n+  static_assert(February + months{11} == January);\n+  static_assert(January + months{1200} == January);\n+  static_assert(January + months{1201} == February);\n+  static_assert(months{-1200} + January == January);\n+  static_assert(months{-1201} + January == December);\n+  static_assert(January - months{1200} == January);\n+  static_assert(January - months{-1200} == January);\n+  static_assert(January - months{1201} == December);\n+\n+  static_assert(January - February == months{11});\n+  static_assert(February - January == months{1});\n+  static_assert(June - June == months{});\n+\n+  static_assert(++month{4} == month{5});\n+  static_assert(month{4}++ == month{4});\n+  static_assert(--month{4} == month{3});\n+  static_assert(month{4}-- == month{4});\n+  static_assert((month{4} += months{3}) == month{7});\n+  static_assert((month{4} -= months{3}) == month{1});\n+\n+  static_assert(!month{}.ok());\n+  static_assert(month{1}.ok());\n+  static_assert(month{12}.ok());\n+  static_assert(!month{13}.ok());\n+\n+  static_assert(unsigned{month{7}} == 7);\n+\n+  static_assert(!(month{0} == month{1}));\n+  static_assert( (month{0} != month{2}));\n+  static_assert( (month{0} <  month{3}));\n+  static_assert(!(month{0} >  month{4}));\n+  static_assert( (month{0} <= month{5}));\n+  static_assert(!(month{0} >= month{6}));\n+\n+  static_assert(month{0} <=> month{1} == std::strong_ordering::less);\n+  static_assert(month{3} <=> month{3} == std::strong_ordering::equal);\n+  static_assert(month{5} <=> month{2} == std::strong_ordering::greater);\n+}"}, {"sha": "2d184f94d41924812aef4f6f416ca1a92a2d86da", "filename": "libstdc++-v3/testsuite/std/time/month_day/1.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmonth_day%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmonth_day%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmonth_day%2F1.cc?ref=03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "patch": "@@ -0,0 +1,73 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Class template month_day [time.cal.month_day]\n+\n+#include <chrono>\n+\n+using namespace std::chrono;\n+\n+constexpr void\n+constexpr_month_day()\n+{\n+  month_day md0 = April/4;\n+  month_day md2 = 4d/April;\n+\n+  constexpr auto md1 = month_day{month{3}, day{13}};\n+  static_assert(md1.month() == month{3});\n+  static_assert(md1.day() == day{13});\n+\n+  static_assert(!month_day{month{1}, day{}}.ok());\n+  static_assert( month_day{month{2}, day{1}}.ok());\n+  static_assert( month_day{month{3}, day{31}}.ok());\n+  static_assert(!month_day{month{4}, day{32}}.ok());\n+  static_assert(!month_day{month{0}, day{11}}.ok());\n+  static_assert(!month_day{month{13}, day{7}}.ok());\n+  static_assert( month_day{month{2}, day{28}}.ok());\n+  static_assert( month_day{month{2}, day{29}}.ok());\n+  static_assert(!month_day{month{2}, day{30}}.ok());\n+\n+  using md = month_day;\n+  static_assert(!(md{month{1}, day{0}} == md{month{1}, day{1}}));\n+  static_assert( (md{month{2}, day{0}} != md{month{2}, day{2}}));\n+  static_assert( (md{month{3}, day{0}} <  md{month{3}, day{3}}));\n+  static_assert(!(md{month{4}, day{0}} >  md{month{4}, day{4}}));\n+  static_assert( (md{month{5}, day{0}} <= md{month{5}, day{5}}));\n+  static_assert(!(md{month{6}, day{0}} >= md{month{6}, day{6}}));\n+  static_assert( (md{month{10}, day{13}} == md{month{10}, day{13}}));\n+  static_assert( (md{month{9}, day{13}} != md{month{10}, day{13}}));\n+  static_assert( (md{month{8}, day{13}} < md{month{10}, day{13}}));\n+  static_assert( (md{month{11}, day{13}} > md{month{10}, day{13}}));\n+  static_assert( (md{month{10}, day{13}} <= md{month{10}, day{13}}));\n+  static_assert( (md{month{10}, day{13}} >= md{month{10}, day{13}}));\n+\n+  static_assert( (md{month{10}, day{13}} <=> md{month{10}, day{13}})\n+\t\t== std::strong_ordering::equal);\n+  static_assert( (md{month{3}, day{0}} <=>  md{month{3}, day{3}})\n+\t\t== std::strong_ordering::less);\n+  static_assert( (md{month{11}, day{13}} <=> md{month{10}, day{13}})\n+\t\t== std::strong_ordering::greater);\n+\n+  static_assert(August/14d == month_day{month{8}, day{14}});\n+  static_assert(August/14 == month_day{month{8}, day{14}});\n+  static_assert(8/14d == month_day{month{8}, day{14}});\n+  static_assert(14d/August == month_day{month{8}, day{14}});\n+  static_assert(14d/8 == month_day{month{8}, day{14}});\n+}"}, {"sha": "979d36ffbccb58ea64457c8663599ba6e6d4ecbe", "filename": "libstdc++-v3/testsuite/std/time/month_day_last/1.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmonth_day_last%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmonth_day_last%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmonth_day_last%2F1.cc?ref=03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "patch": "@@ -0,0 +1,65 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Class template day [time.cal.month_day_last]\n+\n+#include <chrono>\n+\n+constexpr void\n+constexpr_month_day_last()\n+{\n+  using namespace std::chrono;\n+  using mdl = month_day_last;\n+\n+  constexpr auto mdl0 = February / last;\n+  static_assert(mdl0.month() == February);\n+\n+  constexpr auto mdl1 = month_day_last{month{3}};\n+  static_assert(mdl1.month() == month{3});\n+\n+  static_assert( mdl{month{3}}.ok());\n+  static_assert(!mdl{month{0}}.ok());\n+  static_assert(!mdl{month{13}}.ok());\n+\n+  static_assert( (mdl{month{1}} == mdl{month{1}}));\n+  static_assert(!(mdl{month{2}} != mdl{month{2}}));\n+  static_assert(!(mdl{month{3}} <  mdl{month{3}}));\n+  static_assert(!(mdl{month{4}} >  mdl{month{4}}));\n+  static_assert( (mdl{month{5}} <= mdl{month{5}}));\n+  static_assert( (mdl{month{6}} >= mdl{month{6}}));\n+  static_assert( (mdl{month{10}} == mdl{month{10}}));\n+  static_assert( (mdl{month{9}} != mdl{month{10}}));\n+  static_assert( (mdl{month{8}} < mdl{month{10}}));\n+  static_assert( (mdl{month{11}} > mdl{month{10}}));\n+  static_assert( (mdl{month{10}} <= mdl{month{10}}));\n+  static_assert( (mdl{month{10}} >= mdl{month{10}}));\n+\n+  static_assert( (mdl{month{1}} <=> mdl{month{1}})\n+\t\t== std::strong_ordering::equal);\n+  static_assert( (mdl{month{11}} <=> mdl{month{10}})\n+\t\t== std::strong_ordering::greater);\n+  static_assert( (mdl{month{8}} <=> mdl{month{10}})\n+\t\t== std::strong_ordering::less);\n+\n+  static_assert(August/last == mdl{month{8}});\n+  static_assert(8/last == mdl{month{8}});\n+  static_assert(last/August == mdl{month{8}});\n+  static_assert(last/8 == mdl{month{8}});\n+}"}, {"sha": "fd3500d4092359caca0c9e7083223a6455f99e6b", "filename": "libstdc++-v3/testsuite/std/time/month_weekday/1.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmonth_weekday%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmonth_weekday%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmonth_weekday%2F1.cc?ref=03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "patch": "@@ -0,0 +1,48 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Class template day [time.cal.month_weekday]\n+\n+#include <chrono>\n+\n+constexpr void\n+constexpr_month_weekday()\n+{\n+  using namespace std::chrono;\n+  using mwd = month_weekday;\n+\n+  // mwd0 is the third Tuesday of February of an as yet unspecified year.\n+  constexpr auto mwd0 = February / Tuesday[3];\n+  static_assert(mwd0.ok());\n+  static_assert(mwd0.month() == February);\n+  static_assert(mwd0.weekday_indexed() == Tuesday[3]);\n+\n+  static_assert(!mwd{month{0}, Tuesday[3]}.ok());\n+  static_assert(!mwd{February, Tuesday[0]}.ok());\n+\n+  static_assert(mwd{January, Monday[2]} == mwd{January, Monday[2]});\n+  static_assert(mwd{January, Monday[2]} != mwd{January, Monday[3]});\n+  static_assert(mwd{February, Monday[2]} != mwd{January, Monday[2]});\n+\n+  static_assert(August/Friday[2] == mwd{month{8}, weekday_indexed{weekday{5u}, 2}});\n+  static_assert(8/Friday[2] == mwd{month{8}, weekday_indexed{weekday{5u}, 2}});\n+  static_assert(Friday[2]/August == mwd{month{8}, weekday_indexed{weekday{5u}, 2}});\n+  static_assert(Friday[2]/8 == mwd{month{8}, weekday_indexed{weekday{5u}, 2}});\n+}"}, {"sha": "4d2c1bdd07ed928f682834199ce1ecd8bfbb74da", "filename": "libstdc++-v3/testsuite/std/time/month_weekday_last/1.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmonth_weekday_last%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmonth_weekday_last%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fmonth_weekday_last%2F1.cc?ref=03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "patch": "@@ -0,0 +1,48 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Class template day [time.cal.month_weekday_last]\n+\n+#include <chrono>\n+\n+constexpr void\n+constexpr_month_weekday_last()\n+{\n+  using namespace std::chrono;\n+  using mwdl = month_weekday_last;\n+\n+  // mwd0 is the third Tuesday of February of an as yet unspecified year.\n+  constexpr auto mwdl0 = February / Tuesday[last];\n+  static_assert(mwdl0.ok());\n+  static_assert(mwdl0.month() == February);\n+  static_assert(mwdl0.weekday_last() == Tuesday[last]);\n+\n+  static_assert(!mwdl{January, weekday_last{weekday{10}}}.ok());\n+  static_assert(!mwdl{month{0}, Tuesday[last]}.ok());\n+\n+  static_assert(mwdl{January, Monday[last]} == mwdl{January, Monday[last]});\n+  static_assert(mwdl{January, Monday[last]} != mwdl{January, Tuesday[last]});\n+  static_assert(mwdl{February, Monday[last]} != mwdl{January, Monday[last]});\n+\n+  static_assert(August/Friday[last] == mwdl{month{8}, weekday_last{weekday{5u}}});\n+  static_assert(8/Friday[last] == mwdl{month{8}, weekday_last{weekday{5u}}});\n+  static_assert(Friday[last]/August == mwdl{month{8}, weekday_last{weekday{5u}}});\n+  static_assert(Friday[last]/8 == mwdl{month{8}, weekday_last{weekday{5u}}});\n+}"}, {"sha": "d7330cd8648bc199cc2ddae866cf03c7cebfc247", "filename": "libstdc++-v3/testsuite/std/time/weekday/1.cc", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fweekday%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fweekday%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fweekday%2F1.cc?ref=03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "patch": "@@ -0,0 +1,102 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Class template day [time.cal.weekday]\n+\n+#include <chrono>\n+\n+constexpr void\n+constexpr_weekday()\n+{\n+  using namespace std::chrono;\n+\n+  weekday dwd{};\n+  ++dwd;\n+  dwd++;\n+  --dwd;\n+  dwd--;\n+  dwd += days{3};\n+  dwd -= days{3};\n+\n+  static_assert(weekday{3}[2].weekday() == weekday{3});\n+  static_assert(weekday{3}[last].weekday() == weekday{3});\n+\n+  static_assert(weekday{sys_days{1900y/January/1}} == Monday);\n+  static_assert(weekday{sys_days{1970y/January/1}} == Thursday);\n+  static_assert(weekday{sys_days{2020y/August/21}} == Friday);\n+\n+  static_assert(weekday{local_days{1900y/January/1}} == Monday);\n+  static_assert(weekday{local_days{1970y/January/1}} == Thursday);\n+  static_assert(weekday{local_days{2020y/August/21}} == Friday);\n+\n+  static_assert(++weekday{3} == weekday{4});\n+  static_assert(weekday{3}++ == weekday{3});\n+  static_assert(--weekday{3} == weekday{2});\n+  static_assert(weekday{3}-- == weekday{3});\n+  static_assert((weekday{3} += days{3}) == weekday{6});\n+  static_assert((weekday{3} -= days{3}) == weekday{0});\n+\n+  static_assert(Monday + days{7000} == Monday);\n+  static_assert(Monday + days{-7000} == Monday);\n+  static_assert(days{7001} + Monday == Tuesday);\n+  static_assert(days{-7001} + Monday == Sunday);\n+  static_assert(Monday - days{7000} == Monday);\n+  static_assert(Monday - days{-7000} == Monday);\n+  static_assert(Monday - days{7001} == Sunday);\n+\n+  static_assert([] {\n+    constexpr unsigned diff_tbl[7][7]\n+      = { { 0, 6, 5, 4, 3, 2, 1},\n+\t  { 1, 0, 6, 5, 4, 3, 2},\n+\t  { 2, 1, 0, 6, 5, 4, 3},\n+\t  { 3, 2, 1, 0, 6, 5, 4},\n+\t  { 4, 3, 2, 1, 0, 6, 5},\n+\t  { 5, 4, 3, 2, 1, 0, 6},\n+\t  { 6, 5, 4, 3, 2, 1, 0} };\n+    for (unsigned x = 0; x < 7; x++)\n+      for (unsigned y = 0; y < 7; y++)\n+\t{\n+\t  if (weekday{x} - weekday{y} != days{diff_tbl[x][y]})\n+\t    return false;\n+\t  if (weekday{x} - days{diff_tbl[x][y]} != weekday{y})\n+\t    return false;\n+\t  if (weekday{x} != weekday{y} + days{diff_tbl[x][y]})\n+\t    return false;\n+\t  if (weekday{x} != days{diff_tbl[x][y]} + weekday{y})\n+\t    return false;\n+\t}\n+    return true;\n+  }());\n+\n+  static_assert(Sunday.c_encoding() == 0);\n+  static_assert(Sunday.iso_encoding() == 7);\n+  static_assert(Monday.c_encoding() == 1);\n+  static_assert(Monday.iso_encoding() == 1);\n+\n+  static_assert(!weekday{127}.ok());\n+  static_assert(weekday{0}.ok());\n+  static_assert(weekday{6}.ok());\n+  static_assert(weekday{7}.ok()); // Ctor wraps 7 to 0.\n+  static_assert(!weekday{8}.ok());\n+\n+  static_assert(weekday{7} == weekday{0});\n+  static_assert(!(weekday{0} == weekday{1}));\n+  static_assert( (weekday{0} != weekday{2}));\n+}"}, {"sha": "01b5b3d1d06c3a09bf55df973da7357fc483a6d1", "filename": "libstdc++-v3/testsuite/std/time/weekday_indexed/1.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fweekday_indexed%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fweekday_indexed%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fweekday_indexed%2F1.cc?ref=03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "patch": "@@ -0,0 +1,53 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Class template day [time.cal.weekday_indexed]\n+\n+#include <chrono>\n+\n+constexpr void\n+constexpr_weekday_indexed()\n+{\n+  using namespace std::chrono;\n+\n+  weekday_indexed dwdi{};\n+\n+  // wdi0 is the second Sunday of an as yet unspecified month.\n+  constexpr auto wdi0 = Sunday[2];\n+  static_assert(wdi0.weekday() == Sunday);\n+  static_assert(wdi0.index() == 2);\n+\n+  constexpr weekday_indexed wdi1 = {weekday{3}, 2};\n+  static_assert(wdi1.weekday() == weekday{3});\n+  static_assert(wdi1.index() == 2);\n+\n+  static_assert(!weekday_indexed{weekday{127}, 1}.ok());\n+  static_assert(weekday_indexed{weekday{0}, 1}.ok());\n+  static_assert(weekday_indexed{weekday{6}, 2}.ok());\n+  static_assert(weekday_indexed{weekday{7}, 3}.ok()); // Weekday wraps 7 to 0.\n+  static_assert(!weekday_indexed{weekday{8}, 1}.ok());\n+  static_assert(!weekday_indexed{weekday{6}, 6}.ok());\n+\n+  static_assert(weekday{7}[1] == weekday{0}[1]);\n+  static_assert(!(weekday{0}[2] == weekday{1}[2]));\n+  static_assert(!(weekday{0}[2] == weekday{0}[3]));\n+  static_assert( (weekday{0}[3] != weekday{2}[3]));\n+  static_assert( (weekday{0}[3] != weekday{0}[2]));\n+}"}, {"sha": "60269f995136e721d90f3fae66b08f33decc8c7a", "filename": "libstdc++-v3/testsuite/std/time/weekday_last/1.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fweekday_last%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fweekday_last%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fweekday_last%2F1.cc?ref=03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "patch": "@@ -0,0 +1,48 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Class template day [time.cal.weekday_last]\n+\n+#include <chrono>\n+\n+constexpr void\n+constexpr_weekday_last()\n+{\n+  using namespace std::chrono;\n+\n+  constexpr auto wdl0 = Sunday[last];\n+  static_assert(wdl0.weekday() == Sunday);\n+\n+  constexpr auto wdl1 = weekday{3}[2];\n+  static_assert(wdl1.weekday() == weekday{3});\n+  static_assert(wdl1.index() == 2);\n+  constexpr auto wdll = weekday{3}[last];\n+  static_assert(wdll.weekday() == weekday{3});\n+\n+  static_assert(!weekday_last{weekday{127}}.ok());\n+  static_assert(weekday_last{weekday{0}}.ok());\n+  static_assert(weekday_last{weekday{6}}.ok());\n+  static_assert(weekday_last{weekday{7}}.ok()); // Weekday wraps 7 to 0.\n+  static_assert(!weekday_last{weekday{8}}.ok());\n+\n+  static_assert( (weekday_last{weekday{7}} == weekday_last{weekday{0}}));\n+  static_assert(!(weekday_last{weekday{0}} == weekday_last{weekday{1}}));\n+  static_assert( (weekday_last{weekday{0}} != weekday_last{weekday{2}}));\n+}"}, {"sha": "f3dbfe0607d25dfa031e224883291fa6f41e72e5", "filename": "libstdc++-v3/testsuite/std/time/year/1.cc", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear%2F1.cc?ref=03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "patch": "@@ -0,0 +1,85 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Class template day [time.cal.year]\n+\n+#include <chrono>\n+\n+constexpr void\n+constexpr_year()\n+{\n+  using namespace std::chrono;\n+\n+  year dy{};\n+  ++(++dy);\n+  dy++;\n+  --(--dy);\n+  dy--;\n+  dy += years{3};\n+  dy -= years{3};\n+\n+  static_assert(++year{4} == year{5});\n+  static_assert(year{4}++ == year{4});\n+  static_assert(--year{4} == year{3});\n+  static_assert(year{4}-- == year{4});\n+  static_assert((year{4} += years{3}) == year{7});\n+  static_assert((year{4} -= years{3}) == year{1});\n+\n+  static_assert(year{3} + years{7} == year{10});\n+  static_assert(years{3} + year{7} == year{10});\n+  static_assert(year{3} - years{7} == year{-4});\n+  static_assert(year{10} - year{30} == years{-20});\n+\n+  const auto my = -dy;\n+  const auto py = +dy;\n+\n+  static_assert((-year{1066} == year{-1066}));\n+  static_assert((-year{-332} == year{332}));\n+  static_assert((+year{1066} == year{1066}));\n+  static_assert((+year{-332} == year{-332}));\n+\n+  year::min();\n+  year::max();\n+\n+  static_assert(year{-12345}.ok());\n+  static_assert(year{1}.ok());\n+  static_assert(year{12}.ok());\n+  static_assert(year{13}.ok());\n+\n+  static_assert(int{year{-42}} == -42);\n+\n+  static_assert(!(year{0} == year{1}));\n+  static_assert( (year{0} != year{2}));\n+  static_assert( (year{0} <  year{3}));\n+  static_assert(!(year{0} >  year{4}));\n+  static_assert( (year{0} <= year{5}));\n+  static_assert(!(year{0} >= year{6}));\n+\n+  static_assert(year{10} <=> year{11} == std::strong_ordering::less);\n+  static_assert(year{13} <=> year{13} == std::strong_ordering::equal);\n+  static_assert(year{15} <=> year{12} == std::strong_ordering::greater);\n+\n+  static_assert( year{400}.is_leap());\n+  static_assert( year{1984}.is_leap());\n+  static_assert(!year{1}.is_leap());\n+  static_assert( year{1600}.is_leap());\n+  static_assert(!year{3000}.is_leap());\n+  static_assert(!year{2019}.is_leap());\n+}"}, {"sha": "007cfeb2f7287f57c12d7f408635bb494c2c9146", "filename": "libstdc++-v3/testsuite/std/time/year_month/1.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear_month%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear_month%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear_month%2F1.cc?ref=03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "patch": "@@ -0,0 +1,86 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Class template year_month [time.cal.year_month]\n+\n+#include <chrono>\n+\n+constexpr void\n+constexpr_year_month()\n+{\n+  using namespace std::chrono;\n+  using ym = year_month;\n+\n+  ym ym0 = 2015y/April;\n+  ym0 += years{100};\n+  ym0 -= years{100};\n+  ym0 += months{50};\n+  ym0 -= months{50};\n+\n+  constexpr ym ym1 = {2015y, June};\n+  static_assert(ym1.year() == year{2015});\n+  static_assert(ym1.month() == June);\n+  static_assert(ym1.ok());\n+\n+  constexpr ym ym2 = {2016y, May};\n+  static_assert(ym2.year() == year{2016});\n+  static_assert(ym2.month() == May);\n+  static_assert(ym2.ok());\n+\n+  static_assert(ym1 == ym1);\n+  static_assert(ym1 != ym2);\n+  static_assert(ym1 < ym2);\n+  static_assert(ym1 <= ym2);\n+  static_assert(ym2 > ym1);\n+  static_assert(ym2 >= ym2);\n+\n+  static_assert(ym1 <=> ym1 == std::strong_ordering::equal);\n+  static_assert(ym1 <=> ym2 == std::strong_ordering::less);\n+  static_assert(ym2 <=> ym1 == std::strong_ordering::greater);\n+\n+  static_assert(2015y/August == ym{year{2015}, August});\n+  static_assert(2015y/8 == ym{year{2015}, August});\n+\n+  static_assert(ym1 + months{6} == 2015y/December);\n+  static_assert(ym1 + months{7} == 2016y/January);\n+  static_assert(months{24} + ym1 == 2017y/June);\n+  static_assert(months{25} + ym1 == 2017y/July);\n+\n+  static_assert(ym1 + months{-5} == 2015y/January);\n+  static_assert(ym1 + months{-6} == 2014y/December);\n+  static_assert(ym1 + months{-24} == 2013y/June);\n+  static_assert(ym1 + months{-25} == 2013y/May);\n+\n+  static_assert(ym1 - months{5} == 2015y/January);\n+  static_assert(ym1 - months{6} == 2014y/December);\n+  static_assert(ym1 - months{24} == 2013y/June);\n+  static_assert(ym1 - months{25} == 2013y/May);\n+\n+  static_assert(ym2 - ym1 == months{11});\n+  static_assert(ym1 - ym2 == -months{11});\n+\n+  static_assert(ym2 + years{1} == 2017y/May);\n+  static_assert(ym2 + years{-1} == 2015y/May);\n+  static_assert(ym2 - years{1} == 2015y/May);\n+\n+  static_assert(2017y/33 + months{0} == 2019y/9);\n+\n+  static_assert(2010y/January + months{-12} == 2009y/January);\n+}"}, {"sha": "24546c36fd57b968673f56f6774f0c428d1424ec", "filename": "libstdc++-v3/testsuite/std/time/year_month_day/1.cc", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear_month_day%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear_month_day%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear_month_day%2F1.cc?ref=03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "patch": "@@ -0,0 +1,91 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Class template day [time.cal.year_month_day]\n+\n+#include <chrono>\n+\n+constexpr void\n+constexpr_year_month_day()\n+{\n+  using namespace std::chrono;\n+  using ymd = year_month_day;\n+\n+  constexpr ymd ymd1{year{1984}, August, 3d};\n+  static_assert(ymd1.ok());\n+  static_assert(ymd1.year() == year{1984});\n+  static_assert(ymd1.month() == August);\n+  static_assert(ymd1.day() == 3d);\n+  //static_assert(sys_days(ymd1) == time_point_cast<days>(days{5356}));\n+  //static_assert(local_days(ymd1) == time_point_cast<days>(days{5356}));\n+\n+  static_assert(2015y/August/14d == ymd{year{2015}, month{8}, day{14}});\n+  static_assert(2015y/August/14 == ymd{year{2015}, month{8}, day{14}});\n+  static_assert(2015y/(August/14d) == ymd{year{2015}, month{8}, day{14}});\n+  static_assert(2015/(August/14d) == ymd{year{2015}, month{8}, day{14}});\n+  static_assert(August/14d/2015y == ymd{year{2015}, month{8}, day{14}});\n+  static_assert(August/14d/2015 == ymd{year{2015}, month{8}, day{14}});\n+\n+  static_assert(((ymd{1000y, January, 1d} += months{1}) += years{1})\n+\t\t== February/1d/1001y);\n+  static_assert(((ymd{1000y, January, 1d} -= years{1}) -= months{1})\n+\t\t== December/1d/998y);\n+\n+  static_assert(!ymd{1000y, February, 30d}.ok());\n+\n+  static_assert(June/1d/1977y == June/1d/1977y);\n+  static_assert(June/1d/1977y != June/1d/1987y);\n+  static_assert(May/15d/1950y <=> May/15d/1950y == std::strong_ordering::equal);\n+  static_assert(May/15d/1950y <=> May/14d/1950y == std::strong_ordering::greater);\n+  static_assert(April/15d/1950y <=> May/14d/1950y == std::strong_ordering::less);\n+\n+  static_assert(January/1d/1900y + months{13} == February/1d/1901y);\n+  static_assert(months{13} + January/1d/1900y == February/1d/1901y);\n+  static_assert(January/1d/1900y + years{1} == January/1d/1901y);\n+  static_assert(years{1} + January/1d/1900y == January/1d/1901y);\n+  static_assert(January/1d/1900y - months{13} == December/1d/1898y);\n+  static_assert(January/1d/1900y - years{1} == January/1d/1899y);\n+\n+  // N.B. unix seems to be a macro somewhere!\n+  constexpr ymd myunix = 1970y/1/1;\n+  static_assert(myunix.ok());\n+  static_assert(myunix.year() == year{1970});\n+  static_assert(myunix.month() == January);\n+  static_assert(myunix.day() == day{1});\n+  static_assert(sys_days(myunix).time_since_epoch() == days{0});\n+  //static_assert(local_days(myunix) == time_point_cast<days>(days{0}));\n+\n+  static_assert(sys_days{August/20d/2020y}.time_since_epoch() == days{18494});\n+\n+  static_assert(ymd{sys_days{2017y/January/0}}  == 2016y/December/31);\n+  static_assert(ymd{sys_days{2017y/January/31}} == 2017y/January/31);\n+  static_assert(ymd{sys_days{2017y/January/32}} == 2017y/February/1);\n+  static_assert(ymd{sys_days{2017y/33/59 + months{0}}} == 2019y/10/29);\n+\n+  static_assert(ymd{local_days{2017y/January/0}}  == 2016y/December/31);\n+  static_assert(ymd{local_days{2017y/January/31}} == 2017y/January/31);\n+  static_assert(ymd{local_days{2017y/January/32}} == 2017y/February/1);\n+  static_assert(ymd{local_days{2017y/33/59 + months{0}}} == 2019y/10/29);\n+\n+  static_assert((2000y/February/29d).ok());\n+  static_assert(!(2001y/February/29d).ok());\n+  static_assert(!(2100y/February/29d).ok());\n+  static_assert(!(1999y/February/29d).ok());\n+}"}, {"sha": "a0cb9e74b23a993410a560b6239b9a617c15bfdf", "filename": "libstdc++-v3/testsuite/std/time/year_month_day_last/1.cc", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear_month_day_last%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear_month_day_last%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear_month_day_last%2F1.cc?ref=03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "patch": "@@ -0,0 +1,82 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Class template day [time.cal.year_month_day_last]\n+\n+#include <chrono>\n+\n+constexpr void\n+constexpr_year_month_day_last()\n+{\n+  using namespace std::chrono;\n+  using mdl = month_day_last;\n+  using ymdl = year_month_day_last;\n+\n+  year_month_day_last ymdl1{year{1066}, mdl{October}};\n+  ymdl1 += months{9};\n+  ymdl1 -= months{9};\n+  ymdl1 += years{12};\n+  ymdl1 -= years{12};\n+\n+  constexpr ymdl ymdl2{year{1984}, mdl{August}};\n+  static_assert(ymdl2.year() == year{1984});\n+  static_assert(ymdl2.month() == August);\n+  static_assert(ymdl2.month_day_last() == mdl{August});\n+  static_assert(ymdl2.day() == day{31});\n+  static_assert(sys_days(ymdl2).time_since_epoch().count() == 5356);\n+  static_assert(local_days(ymdl2).time_since_epoch().count() == 5356);\n+\n+  static_assert( (ymdl{year{1984}, mdl{August}}.ok()));\n+  static_assert(!(ymdl{year{1984}, mdl{month{13}}}.ok()));\n+\n+  static_assert(2015y/August/last == ymdl{year{2015}, month_day_last{month{8}}});\n+  static_assert(2015y/(August/last) == ymdl{year{2015}, month_day_last{month{8}}});\n+  static_assert(2015/(August/last) == ymdl{year{2015}, month_day_last{month{8}}});\n+  static_assert(August/last/2015y == ymdl{year{2015}, month_day_last{month{8}}});\n+  static_assert(August/last/2015 == ymdl{year{2015}, month_day_last{month{8}}});\n+\n+  static_assert(January/last/2000 <=> January/last/2000\n+\t\t== std::strong_ordering::equal);\n+  static_assert(January/last/2000 <=> February/last/2000\n+\t\t== std::strong_ordering::less);\n+  static_assert(January/last/2000 <=> January/last/1999\n+\t\t== std::strong_ordering::greater);\n+\n+  static_assert(January/last/2000 + months{13} == February/last/2001);\n+  static_assert(January/last/2000 + months{-1} == December/last/1999);\n+  static_assert(January/last/2000 - months{13} == December/last/1998);\n+  static_assert(January/last/2000 - months{-13} == February/last/2001);\n+\n+  static_assert(January/last/2000 + years{5} == January/last/2005);\n+  static_assert(January/last/2000 - years{5} == January/last/1995);\n+\n+  static_assert(year_month_day{January/last/2000} == January/31/2000);\n+  static_assert(year_month_day{February/last/2000} == February/29/2000);\n+  static_assert(year_month_day{March/last/2000} == March/31/2000);\n+  static_assert(year_month_day{April/last/2000} == April/30/2000);\n+  static_assert(year_month_day{May/last/2000} == May/31/2000);\n+  static_assert(year_month_day{June/last/2000} == June/30/2000);\n+  static_assert(year_month_day{July/last/2000} == July/31/2000);\n+  static_assert(year_month_day{August/last/2000} == August/31/2000);\n+  static_assert(year_month_day{September/last/2000} == September/30/2000);\n+  static_assert(year_month_day{October/last/2000} == October/31/2000);\n+  static_assert(year_month_day{November/last/2000} == November/30/2000);\n+  static_assert(year_month_day{December/last/2000} == December/31/2000);\n+}"}, {"sha": "3781f1781b768c963380b860bc4cbb1d06a2dba6", "filename": "libstdc++-v3/testsuite/std/time/year_month_weekday/1.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear_month_weekday%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear_month_weekday%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear_month_weekday%2F1.cc?ref=03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "patch": "@@ -0,0 +1,74 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Class template day [time.cal.year_month_weekday]\n+\n+#include <chrono>\n+\n+constexpr void\n+constexpr_year_month_weekday()\n+{\n+  using namespace std::chrono;\n+  using ymwd = year_month_weekday;\n+\n+  year_month_weekday ymwd1{};\n+  ymwd1 += months{9};\n+  ymwd1 -= months{9};\n+  ymwd1 += years{12};\n+  ymwd1 -= years{12};\n+\n+  constexpr ymwd ymwd2{year{1984}, month{August},\n+\t\t       weekday_indexed{Wednesday, 3}};\n+  static_assert(ymwd2.ok());\n+  static_assert(ymwd2.year() == year{1984});\n+  static_assert(ymwd2.month() == August);\n+  static_assert(ymwd2.weekday() == Wednesday);\n+  static_assert(ymwd2.index() == 3);\n+  static_assert(ymwd2.weekday_indexed() == weekday_indexed{Wednesday, 3});\n+  static_assert(ymwd{sys_days{ymwd2}} == ymwd2);\n+  static_assert(ymwd{local_days{ymwd2}} == ymwd2);\n+\n+  static_assert(2015y/August/Friday[2] == ymwd{year{2015}, month{8}, weekday_indexed{weekday{5u}, 2}});\n+  static_assert(2015y/(August/Friday[2]) == ymwd{year{2015}, month{8}, weekday_indexed{weekday{5u}, 2}});\n+  static_assert(2015/(August/Friday[2]) == ymwd{year{2015}, month{8}, weekday_indexed{weekday{5u}, 2}});\n+  static_assert(August/Friday[2]/2015y == ymwd{year{2015}, month{8}, weekday_indexed{weekday{5u}, 2}});\n+  static_assert(August/Friday[2]/2015 == ymwd{year{2015}, month{8}, weekday_indexed{weekday{5u}, 2}});\n+\n+  static_assert(January/Tuesday[2]/1900y + months{1} == February/Tuesday[2]/1900y);\n+  static_assert(months{1} + January/Tuesday[2]/1900y == February/Tuesday[2]/1900y);\n+  static_assert(January/Tuesday[2]/1900y - months{1} == December/Tuesday[2]/1899y);\n+  static_assert(January/Tuesday[2]/1900y + years{1} == January/Tuesday[2]/1901y);\n+  static_assert(years{1} + January/Tuesday[2]/1900y == January/Tuesday[2]/1901y);\n+  static_assert(January/Tuesday[2]/1900y - years{1} == January/Tuesday[2]/1899y);\n+\n+  // N.B. unix seems to be a macro somewhere!\n+  constexpr ymwd myunix(local_days{days{0}});\n+  static_assert(myunix.ok());\n+  static_assert(myunix.year() == year{1970});\n+  static_assert(myunix.month() == January);\n+  static_assert(myunix.weekday() == Thursday);\n+  static_assert(myunix.index() == 1);\n+  static_assert(myunix.weekday_indexed() == weekday_indexed{Thursday, 1});\n+  static_assert(ymwd{sys_days{myunix}} == myunix);\n+  static_assert(ymwd{local_days{myunix}} == myunix);\n+\n+  static_assert((2020y/August/Monday[5]).ok());\n+  static_assert(!(2020y/August/Tuesday[5]).ok());\n+}"}, {"sha": "efb5385d43155fbc68411d912e12e01247fcf2a9", "filename": "libstdc++-v3/testsuite/std/time/year_month_weekday_last/1.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear_month_weekday_last%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d5044b31f7bf94fcda4136b4ed87a5fee7735d/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear_month_weekday_last%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fyear_month_weekday_last%2F1.cc?ref=03d5044b31f7bf94fcda4136b4ed87a5fee7735d", "patch": "@@ -0,0 +1,61 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Class template month_day [time.cal.month_day]\n+\n+#include <chrono>\n+\n+constexpr void\n+constexpr_year_month_weekday_last()\n+{\n+  using namespace std::chrono;\n+  using ymwdl = year_month_weekday_last;\n+\n+  constexpr ymwdl ymwdl1 = {2015y, August, weekday_last{Friday}};\n+  static_assert(ymwdl1.ok());\n+  static_assert(ymwdl1.year() == 2015y);\n+  static_assert(ymwdl1.month() == August);\n+  static_assert(ymwdl1.weekday() == Friday);\n+  static_assert(ymwdl1.weekday_last() == Friday[last]);\n+  static_assert(year_month_day{sys_days{ymwdl1}} == 2015y/August/28d);\n+  static_assert(year_month_day{local_days{ymwdl1}} == 2015y/August/28d);\n+\n+  static_assert(2015y/August/Friday[last] == ymwdl{year{2015}, month{8}, weekday_last{weekday{5u}}});\n+  static_assert(2015y/(August/Friday[last]) == ymwdl{year{2015}, month{8}, weekday_last{weekday{5u}}});\n+  static_assert(2015/(August/Friday[last]) == ymwdl{year{2015}, month{8}, weekday_last{weekday{5u}}});\n+  static_assert(August/Friday[last]/2015y == ymwdl{year{2015}, month{8}, weekday_last{weekday{5u}}});\n+  static_assert(August/Friday[last]/2015 == ymwdl{year{2015}, month{8}, weekday_last{weekday{5u}}});\n+\n+  static_assert((ymwdl{ymwdl1} += months{5} -= months{5}) == ymwdl1);\n+  static_assert((ymwdl{ymwdl1} += years{5} -= years{5}) == ymwdl1);\n+\n+  static_assert(ymwdl1 + months{10} == 2016y/June/Friday[last]);\n+  static_assert(months{10} + ymwdl1 == ymwdl1 + months{10});\n+  static_assert(ymwdl1 - months{10} == 2014y/October/Friday[last]);\n+\n+  static_assert(ymwdl1 + years{10} == 2025y/August/Friday[last]);\n+  static_assert(years{10} + ymwdl1 == ymwdl1 + years{10});\n+  static_assert(ymwdl1 - years{10} == 2005y/August/Friday[last]);\n+\n+  constexpr ymwdl ymwdl2 = Saturday[last]/August/2015y;\n+  static_assert(ymwdl2.ok());\n+  static_assert(ymwdl1 == ymwdl1);\n+  static_assert(ymwdl1 != ymwdl2);\n+}"}]}