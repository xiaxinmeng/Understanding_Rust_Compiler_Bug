{"sha": "7d9d218516ac5f1004d1b5aef427d11bea1a242c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q5ZDIxODUxNmFjNWYxMDA0ZDFiNWFlZjQyN2QxMWJlYTFhMjQyYw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2013-11-08T14:30:22Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2013-11-08T14:30:22Z"}, "message": "regex_automaton.h (__detail::_State): Split non-dependent parts into new _State_base.\n\n\t* include/bits/regex_automaton.h (__detail::_State): Split\n\tnon-dependent parts into new _State_base.\n\t(__detail::_NFA): Likewise for _NFA_base. Use std::move() to avoid\n\tcopies when inserting _MatcherT and _StateT objects.\n\t* include/bits/regex_automaton.tcc: Move member definitions to base\n\tclass. Qualify dependent names.\n\t* include/bits/regex_compiler.h (__detail::_Compiler::_M_get_nfa): Make\n\tnon-const and use std::move to avoid copying.\n\t* include/bits/regex_compiler.tcc: Likewise.\n\t* include/bits/regex_executor.h (__detail::_Executor::_M_is_word): Use\n\tarray, so past-the-end iterator is valid.\n\nFrom-SVN: r204571", "tree": {"sha": "e51501c90c11733c031c148577d0f0cfcc4a7985", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e51501c90c11733c031c148577d0f0cfcc4a7985"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d9d218516ac5f1004d1b5aef427d11bea1a242c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d9d218516ac5f1004d1b5aef427d11bea1a242c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d9d218516ac5f1004d1b5aef427d11bea1a242c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d9d218516ac5f1004d1b5aef427d11bea1a242c/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb3d1e3e87f97eca6c52f7f49d2218e24c6ec39e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb3d1e3e87f97eca6c52f7f49d2218e24c6ec39e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb3d1e3e87f97eca6c52f7f49d2218e24c6ec39e"}], "stats": {"total": 420, "additions": 228, "deletions": 192}, "files": [{"sha": "68e4f6b49101abe363bfd922400464950d0225e3", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d9d218516ac5f1004d1b5aef427d11bea1a242c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d9d218516ac5f1004d1b5aef427d11bea1a242c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7d9d218516ac5f1004d1b5aef427d11bea1a242c", "patch": "@@ -1,3 +1,17 @@\n+2013-11-08  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\t* include/bits/regex_automaton.h (__detail::_State): Split\n+\tnon-dependent parts into new _State_base.\n+\t(__detail::_NFA): Likewise for _NFA_base. Use std::move() to avoid\n+\tcopies when inserting _MatcherT and _StateT objects.\n+\t* include/bits/regex_automaton.tcc: Move member definitions to base\n+\tclass. Qualify dependent names.\n+\t* include/bits/regex_compiler.h (__detail::_Compiler::_M_get_nfa): Make\n+\tnon-const and use std::move to avoid copying.\n+\t* include/bits/regex_compiler.tcc: Likewise.\n+\t* include/bits/regex_executor.h (__detail::_Executor::_M_is_word): Use\n+\tarray, so past-the-end iterator is valid.\n+\n 2013-11-06  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \t* include/bits/regex_automaton.h (_S_opcode_word_boundry): Rename to"}, {"sha": "ded3716771ca917e94426ca0b78c69b69e3f264e", "filename": "libstdc++-v3/include/bits/regex_automaton.h", "status": "modified", "additions": 102, "deletions": 77, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d9d218516ac5f1004d1b5aef427d11bea1a242c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d9d218516ac5f1004d1b5aef427d11bea1a242c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.h?ref=7d9d218516ac5f1004d1b5aef427d11bea1a242c", "patch": "@@ -65,81 +65,114 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _S_opcode_accept,\n   };\n \n-  template<typename _CharT, typename _TraitsT>\n-    class _State\n+  struct _State_base\n+  {\n+    _Opcode      _M_opcode;           // type of outgoing transition\n+    _StateIdT    _M_next;             // outgoing transition\n+    union // Since they are mutually exclusive.\n     {\n-    public:\n-      typedef _Matcher<_CharT>           _MatcherT;\n-\n-      _Opcode      _M_opcode;           // type of outgoing transition\n-      _StateIdT    _M_next;             // outgoing transition\n-      union // Since they are mutually exclusive.\n+      size_t _M_subexpr;        // for _S_opcode_subexpr_*\n+      size_t _M_backref_index;  // for _S_opcode_backref\n+      struct\n       {\n-\tsize_t _M_subexpr;        // for _S_opcode_subexpr_*\n-\tsize_t _M_backref_index;  // for _S_opcode_backref\n-\tstruct\n-\t{\n-\t  // for _S_opcode_alternative.\n-\t  _StateIdT  _M_quant_index;\n-\t  // for _S_opcode_alternative or _S_opcode_subexpr_lookahead\n-\t  _StateIdT  _M_alt;\n-\t  // for _S_opcode_word_boundary or _S_opcode_subexpr_lookahead or\n-\t  // quantifiers(ungreedy if set true)\n-\t  bool       _M_neg;\n-\t};\n+\t// for _S_opcode_alternative.\n+\t_StateIdT  _M_quant_index;\n+\t// for _S_opcode_alternative or _S_opcode_subexpr_lookahead\n+\t_StateIdT  _M_alt;\n+\t// for _S_opcode_word_boundary or _S_opcode_subexpr_lookahead or\n+\t// quantifiers (ungreedy if set true)\n+\tbool       _M_neg;\n       };\n-      _MatcherT      _M_matches;        // for _S_opcode_match\n+    };\n \n-      explicit _State(_Opcode  __opcode)\n-      : _M_opcode(__opcode), _M_next(_S_invalid_state_id)\n-      { }\n+    explicit _State_base(_Opcode __opcode)\n+    : _M_opcode(__opcode), _M_next(_S_invalid_state_id)\n+    { }\n+\n+  protected:\n+    ~_State_base() = default;\n \n+  public:\n #ifdef _GLIBCXX_DEBUG\n-      std::ostream&\n-      _M_print(std::ostream& ostr) const;\n+    std::ostream&\n+    _M_print(std::ostream& ostr) const;\n \n-      // Prints graphviz dot commands for state.\n-      std::ostream&\n-      _M_dot(std::ostream& __ostr, _StateIdT __id) const;\n+    // Prints graphviz dot commands for state.\n+    std::ostream&\n+    _M_dot(std::ostream& __ostr, _StateIdT __id) const;\n #endif\n-    };\n+  };\n \n   template<typename _CharT, typename _TraitsT>\n-    class _NFA\n-    : public std::vector<_State<_CharT, _TraitsT>>\n+    struct _State : _State_base\n     {\n-    public:\n-      typedef _State<_CharT, _TraitsT>            _StateT;\n-      typedef const _Matcher<_CharT>&             _MatcherT;\n-      typedef size_t                              _SizeT;\n-      typedef regex_constants::syntax_option_type _FlagT;\n-\n-      _NFA(_FlagT __f)\n-      : _M_flags(__f), _M_start_state(0), _M_subexpr_count(0),\n-      _M_quant_count(0), _M_has_backref(false)\n-      { }\n+      typedef _Matcher<_CharT>           _MatcherT;\n \n-      _FlagT\n-      _M_options() const\n-      { return _M_flags; }\n+      _MatcherT      _M_matches;        // for _S_opcode_match\n \n-      _StateIdT\n-      _M_start() const\n-      { return _M_start_state; }\n+      explicit _State(_Opcode __opcode) : _State_base(__opcode) { }\n+    };\n \n-      const _StateSet&\n-      _M_final_states() const\n-      { return _M_accepting_states; }\n+  struct _NFA_base\n+  {\n+    typedef size_t                              _SizeT;\n+    typedef regex_constants::syntax_option_type _FlagT;\n+\n+    explicit\n+    _NFA_base(_FlagT __f)\n+    : _M_flags(__f), _M_start_state(0), _M_subexpr_count(0),\n+    _M_quant_count(0), _M_has_backref(false)\n+    { }\n+\n+    _NFA_base(_NFA_base&&) = default;\n+\n+  protected:\n+    ~_NFA_base() = default;\n+\n+  public:\n+    _FlagT\n+    _M_options() const\n+    { return _M_flags; }\n+\n+    _StateIdT\n+    _M_start() const\n+    { return _M_start_state; }\n+\n+    const _StateSet&\n+    _M_final_states() const\n+    { return _M_accepting_states; }\n+\n+    _SizeT\n+    _M_sub_count() const\n+    { return _M_subexpr_count; }\n+\n+    std::vector<size_t>       _M_paren_stack;\n+    _StateSet                 _M_accepting_states;\n+    _FlagT                    _M_flags;\n+    _StateIdT                 _M_start_state;\n+    _SizeT                    _M_subexpr_count;\n+    _SizeT                    _M_quant_count;\n+    bool                      _M_has_backref;\n+  };\n+\n+  template<typename _CharT, typename _TraitsT>\n+    struct _NFA\n+    : _NFA_base, std::vector<_State<_CharT, _TraitsT>>\n+    {\n+      typedef _State<_CharT, _TraitsT>\t\t_StateT;\n+      typedef _Matcher<_CharT>\t\t\t_MatcherT;\n+\n+      using _NFA_base::_NFA_base;\n \n-      _SizeT\n-      _M_sub_count() const\n-      { return _M_subexpr_count; }\n+      // for performance reasons _NFA objects should only be moved not copied\n+      _NFA(const _NFA&) = delete;\n+      _NFA(_NFA&&) = default;\n \n       _StateIdT\n       _M_insert_accept()\n       {\n \tauto __ret = _M_insert_state(_StateT(_S_opcode_accept));\n-\t_M_accepting_states.insert(__ret);\n+\tthis->_M_accepting_states.insert(__ret);\n \treturn __ret;\n       }\n \n@@ -149,38 +182,38 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_StateT __tmp(_S_opcode_alternative);\n \t// It labels every quantifier to make greedy comparison easier in BFS\n \t// approach.\n-\t__tmp._M_quant_index = _M_quant_count++;\n+\t__tmp._M_quant_index = this->_M_quant_count++;\n \t__tmp._M_next = __next;\n \t__tmp._M_alt = __alt;\n \t__tmp._M_neg = __neg;\n-\treturn _M_insert_state(__tmp);\n+\treturn _M_insert_state(std::move(__tmp));\n       }\n \n       _StateIdT\n       _M_insert_matcher(_MatcherT __m)\n       {\n \t_StateT __tmp(_S_opcode_match);\n-\t__tmp._M_matches = __m;\n-\treturn _M_insert_state(__tmp);\n+\t__tmp._M_matches = std::move(__m);\n+\treturn _M_insert_state(std::move(__tmp));\n       }\n \n       _StateIdT\n       _M_insert_subexpr_begin()\n       {\n-\tauto __id = _M_subexpr_count++;\n-\t_M_paren_stack.push_back(__id);\n+\tauto __id = this->_M_subexpr_count++;\n+\tthis->_M_paren_stack.push_back(__id);\n \t_StateT __tmp(_S_opcode_subexpr_begin);\n \t__tmp._M_subexpr = __id;\n-\treturn _M_insert_state(__tmp);\n+\treturn _M_insert_state(std::move(__tmp));\n       }\n \n       _StateIdT\n       _M_insert_subexpr_end()\n       {\n \t_StateT __tmp(_S_opcode_subexpr_end);\n-\t__tmp._M_subexpr = _M_paren_stack.back();\n-\t_M_paren_stack.pop_back();\n-\treturn _M_insert_state(__tmp);\n+\t__tmp._M_subexpr = this->_M_paren_stack.back();\n+\tthis->_M_paren_stack.pop_back();\n+\treturn _M_insert_state(std::move(__tmp));\n       }\n \n       _StateIdT\n@@ -199,7 +232,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       {\n \t_StateT __tmp(_S_opcode_word_boundary);\n \t__tmp._M_neg = __neg;\n-\treturn _M_insert_state(__tmp);\n+\treturn _M_insert_state(std::move(__tmp));\n       }\n \n       _StateIdT\n@@ -208,7 +241,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_StateT __tmp(_S_opcode_subexpr_lookahead);\n \t__tmp._M_alt = __alt;\n \t__tmp._M_neg = __neg;\n-\treturn _M_insert_state(__tmp);\n+\treturn _M_insert_state(std::move(__tmp));\n       }\n \n       _StateIdT\n@@ -218,7 +251,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _StateIdT\n       _M_insert_state(_StateT __s)\n       {\n-\tthis->push_back(__s);\n+\tthis->push_back(std::move(__s));\n \treturn this->size()-1;\n       }\n \n@@ -230,14 +263,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       std::ostream&\n       _M_dot(std::ostream& __ostr) const;\n #endif\n-\n-      std::vector<size_t>       _M_paren_stack;\n-      _StateSet                 _M_accepting_states;\n-      _FlagT                    _M_flags;\n-      _StateIdT                 _M_start_state;\n-      _SizeT                    _M_subexpr_count;\n-      _SizeT                    _M_quant_count;\n-      bool                      _M_has_backref;\n     };\n \n   /// Describes a sequence of one or more %_State, its current start\n@@ -251,7 +276,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     public:\n       _StateSeq(_RegexT& __nfa, _StateIdT __s)\n-      : _StateSeq(__nfa, __s, __s)\n+      : _M_nfa(__nfa), _M_start(__s), _M_end(__s)\n       { }\n \n       _StateSeq(_RegexT& __nfa, _StateIdT __s, _StateIdT __end)"}, {"sha": "0c25c634e77e8b7bdd9794741ecbd8c20a594e65", "filename": "libstdc++-v3/include/bits/regex_automaton.tcc", "status": "modified", "additions": 100, "deletions": 102, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d9d218516ac5f1004d1b5aef427d11bea1a242c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d9d218516ac5f1004d1b5aef427d11bea1a242c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_automaton.tcc?ref=7d9d218516ac5f1004d1b5aef427d11bea1a242c", "patch": "@@ -35,118 +35,116 @@ namespace __detail\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n #ifdef _GLIBCXX_DEBUG\n-  template<typename _CharT, typename _TraitsT>\n-    std::ostream& _State<_CharT, _TraitsT>::\n-    _M_print(std::ostream& ostr) const\n+  std::ostream&\n+  _State_base::_M_print(std::ostream& ostr) const\n+  {\n+    switch (_M_opcode)\n     {\n-      switch (_M_opcode)\n-      {\n-\tcase _S_opcode_alternative:\n-\t  ostr << \"alt next=\" << _M_next << \" alt=\" << _M_alt;\n-\t  break;\n-\tcase _S_opcode_subexpr_begin:\n-\t  ostr << \"subexpr begin next=\" << _M_next << \" index=\" << _M_subexpr;\n-\t  break;\n-\tcase _S_opcode_subexpr_end:\n-\t  ostr << \"subexpr end next=\" << _M_next << \" index=\" << _M_subexpr;\n-\t  break;\n-\tcase _S_opcode_backref:\n-\t  ostr << \"backref next=\" << _M_next << \" index=\" << _M_backref_index;\n-\t  break;\n-\tcase _S_opcode_match:\n-\t  ostr << \"match next=\" << _M_next;\n-\t  break;\n-\tcase _S_opcode_accept:\n-\t  ostr << \"accept next=\" << _M_next;\n-\t  break;\n-\tdefault:\n-\t  ostr << \"unknown next=\" << _M_next;\n-\t  break;\n-      }\n-      return ostr;\n+      case _S_opcode_alternative:\n+\tostr << \"alt next=\" << _M_next << \" alt=\" << _M_alt;\n+\tbreak;\n+      case _S_opcode_subexpr_begin:\n+\tostr << \"subexpr begin next=\" << _M_next << \" index=\" << _M_subexpr;\n+\tbreak;\n+      case _S_opcode_subexpr_end:\n+\tostr << \"subexpr end next=\" << _M_next << \" index=\" << _M_subexpr;\n+\tbreak;\n+      case _S_opcode_backref:\n+\tostr << \"backref next=\" << _M_next << \" index=\" << _M_backref_index;\n+\tbreak;\n+      case _S_opcode_match:\n+\tostr << \"match next=\" << _M_next;\n+\tbreak;\n+      case _S_opcode_accept:\n+\tostr << \"accept next=\" << _M_next;\n+\tbreak;\n+      default:\n+\tostr << \"unknown next=\" << _M_next;\n+\tbreak;\n     }\n+    return ostr;\n+  }\n \n   // Prints graphviz dot commands for state.\n-  template<typename _CharT, typename _TraitsT>\n-    std::ostream& _State<_CharT, _TraitsT>::\n-    _M_dot(std::ostream& __ostr, _StateIdT __id) const\n+  std::ostream&\n+  _State_base::_M_dot(std::ostream& __ostr, _StateIdT __id) const\n+  {\n+    switch (_M_opcode)\n     {\n-      switch (_M_opcode)\n-      {\n-\tcase _S_opcode_alternative:\n-\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nALT\\\"];\\n\"\n-\t\t << __id << \" -> \" << _M_next\n-\t\t << \" [label=\\\"epsilon\\\", tailport=\\\"s\\\"];\\n\"\n-\t\t << __id << \" -> \" << _M_alt\n-\t\t << \" [label=\\\"epsilon\\\", tailport=\\\"n\\\"];\\n\";\n-\t  break;\n-\tcase _S_opcode_backref:\n-\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nBACKREF \"\n-\t\t << _M_subexpr << \"\\\"];\\n\"\n-\t\t << __id << \" -> \" << _M_next << \" [label=\\\"<match>\\\"];\\n\";\n-\t  break;\n-\tcase _S_opcode_line_begin_assertion:\n-\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nLINE_BEGIN \\\"];\\n\"\n-\t\t << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n-\t  break;\n-\tcase _S_opcode_line_end_assertion:\n-\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nLINE_END \\\"];\\n\"\n-\t\t << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n-\t  break;\n-\tcase _S_opcode_word_boundary:\n-\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nWORD_BOUNDRY \"\n-\t\t << _M_neg << \"\\\"];\\n\"\n-\t\t << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n-\t  break;\n-\tcase _S_opcode_subexpr_lookahead:\n-\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nLOOK_AHEAD\\\"];\\n\"\n-\t\t << __id << \" -> \" << _M_next\n-\t\t << \" [label=\\\"epsilon\\\", tailport=\\\"s\\\"];\\n\"\n-\t\t << __id << \" -> \" << _M_alt\n-\t\t << \" [label=\\\"<assert>\\\", tailport=\\\"n\\\"];\\n\";\n-\t  break;\n-\tcase _S_opcode_subexpr_begin:\n-\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nSBEGIN \"\n-\t\t << _M_subexpr << \"\\\"];\\n\"\n-\t\t << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n-\t  break;\n-\tcase _S_opcode_subexpr_end:\n-\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nSEND \"\n-\t\t << _M_subexpr << \"\\\"];\\n\"\n-\t\t << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n-\t  break;\n-\tcase _S_opcode_dummy:\n-\t  break;\n-\tcase _S_opcode_match:\n-\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nMATCH\\\"];\\n\"\n-\t\t << __id << \" -> \" << _M_next << \" [label=\\\"<match>\\\"];\\n\";\n-\t  break;\n-\tcase _S_opcode_accept:\n-\t  __ostr << __id << \" [label=\\\"\" << __id << \"\\\\nACC\\\"];\\n\" ;\n-\t  break;\n-\tdefault:\n-\t  _GLIBCXX_DEBUG_ASSERT(false);\n-\t  break;\n-      }\n-      return __ostr;\n+      case _S_opcode_alternative:\n+\t__ostr << __id << \" [label=\\\"\" << __id << \"\\\\nALT\\\"];\\n\"\n+\t       << __id << \" -> \" << _M_next\n+\t       << \" [label=\\\"epsilon\\\", tailport=\\\"s\\\"];\\n\"\n+\t       << __id << \" -> \" << _M_alt\n+\t       << \" [label=\\\"epsilon\\\", tailport=\\\"n\\\"];\\n\";\n+\tbreak;\n+      case _S_opcode_backref:\n+\t__ostr << __id << \" [label=\\\"\" << __id << \"\\\\nBACKREF \"\n+\t       << _M_subexpr << \"\\\"];\\n\"\n+\t       << __id << \" -> \" << _M_next << \" [label=\\\"<match>\\\"];\\n\";\n+\tbreak;\n+      case _S_opcode_line_begin_assertion:\n+\t__ostr << __id << \" [label=\\\"\" << __id << \"\\\\nLINE_BEGIN \\\"];\\n\"\n+\t       << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n+\tbreak;\n+      case _S_opcode_line_end_assertion:\n+\t__ostr << __id << \" [label=\\\"\" << __id << \"\\\\nLINE_END \\\"];\\n\"\n+\t       << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n+\tbreak;\n+      case _S_opcode_word_boundary:\n+\t__ostr << __id << \" [label=\\\"\" << __id << \"\\\\nWORD_BOUNDRY \"\n+\t       << _M_neg << \"\\\"];\\n\"\n+\t       << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n+\tbreak;\n+      case _S_opcode_subexpr_lookahead:\n+\t__ostr << __id << \" [label=\\\"\" << __id << \"\\\\nLOOK_AHEAD\\\"];\\n\"\n+\t       << __id << \" -> \" << _M_next\n+\t       << \" [label=\\\"epsilon\\\", tailport=\\\"s\\\"];\\n\"\n+\t       << __id << \" -> \" << _M_alt\n+\t       << \" [label=\\\"<assert>\\\", tailport=\\\"n\\\"];\\n\";\n+\tbreak;\n+      case _S_opcode_subexpr_begin:\n+\t__ostr << __id << \" [label=\\\"\" << __id << \"\\\\nSBEGIN \"\n+\t       << _M_subexpr << \"\\\"];\\n\"\n+\t       << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n+\tbreak;\n+      case _S_opcode_subexpr_end:\n+\t__ostr << __id << \" [label=\\\"\" << __id << \"\\\\nSEND \"\n+\t       << _M_subexpr << \"\\\"];\\n\"\n+\t       << __id << \" -> \" << _M_next << \" [label=\\\"epsilon\\\"];\\n\";\n+\tbreak;\n+      case _S_opcode_dummy:\n+\tbreak;\n+      case _S_opcode_match:\n+\t__ostr << __id << \" [label=\\\"\" << __id << \"\\\\nMATCH\\\"];\\n\"\n+\t       << __id << \" -> \" << _M_next << \" [label=\\\"<match>\\\"];\\n\";\n+\tbreak;\n+      case _S_opcode_accept:\n+\t__ostr << __id << \" [label=\\\"\" << __id << \"\\\\nACC\\\"];\\n\" ;\n+\tbreak;\n+      default:\n+\t_GLIBCXX_DEBUG_ASSERT(false);\n+\tbreak;\n     }\n+    return __ostr;\n+  }\n \n   template<typename _CharT, typename _TraitsT>\n-    std::ostream& _NFA<_CharT, _TraitsT>::\n-    _M_dot(std::ostream& __ostr) const\n+    std::ostream&\n+    _NFA<_CharT, _TraitsT>::_M_dot(std::ostream& __ostr) const\n     {\n       __ostr << \"digraph _Nfa {\\n\"\n-       << \"  rankdir=LR;\\n\";\n+\t        \"  rankdir=LR;\\n\";\n       for (size_t __i = 0; __i < this->size(); ++__i)\n-      { this->at(__i)._M_dot(__ostr, __i); }\n+        (*this)[__i]._M_dot(__ostr, __i);\n       __ostr << \"}\\n\";\n       return __ostr;\n     }\n #endif\n \n   template<typename _CharT, typename _TraitsT>\n-    _StateIdT _NFA<_CharT, _TraitsT>::\n-    _M_insert_backref(size_t __index)\n+    _StateIdT\n+    _NFA<_CharT, _TraitsT>::_M_insert_backref(size_t __index)\n     {\n       // To figure out whether a backref is valid, a stack is used to store\n       // unfinished sub-expressions. For example, when parsing\n@@ -157,18 +155,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // time, \"\\\\2\" is valid, but \"\\\\1\" and \"\\\\3\" are not.\n       if (__index >= _M_subexpr_count)\n \t__throw_regex_error(regex_constants::error_backref);\n-      for (auto __it : _M_paren_stack)\n+      for (auto __it : this->_M_paren_stack)\n \tif (__index == __it)\n \t  __throw_regex_error(regex_constants::error_backref);\n-      _M_has_backref = true;\n+      this->_M_has_backref = true;\n       _StateT __tmp(_S_opcode_backref);\n       __tmp._M_backref_index = __index;\n-      return _M_insert_state(__tmp);\n+      return _M_insert_state(std::move(__tmp));\n     }\n \n   template<typename _CharT, typename _TraitsT>\n-    void _NFA<_CharT, _TraitsT>::\n-    _M_eliminate_dummy()\n+    void\n+    _NFA<_CharT, _TraitsT>::_M_eliminate_dummy()\n     {\n       for (auto& __it : *this)\n \t{\n@@ -185,8 +183,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Just apply DFS on the sequence and re-link their links.\n   template<typename _CharT, typename _TraitsT>\n-    _StateSeq<_CharT, _TraitsT> _StateSeq<_CharT, _TraitsT>::\n-    _M_clone()\n+    _StateSeq<_CharT, _TraitsT>\n+    _StateSeq<_CharT, _TraitsT>::_M_clone()\n     {\n       std::map<_StateIdT, _StateIdT> __m;\n       std::stack<_StateIdT> __stack;"}, {"sha": "98141a722fb57bc20d071c71d4b9d9750ea0a325", "filename": "libstdc++-v3/include/bits/regex_compiler.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d9d218516ac5f1004d1b5aef427d11bea1a242c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d9d218516ac5f1004d1b5aef427d11bea1a242c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h?ref=7d9d218516ac5f1004d1b5aef427d11bea1a242c", "patch": "@@ -55,8 +55,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\tconst _TraitsT& __traits, _FlagT __flags);\n \n       std::shared_ptr<_RegexT>\n-      _M_get_nfa() const\n-      { return make_shared<_RegexT>(_M_nfa); }\n+      _M_get_nfa()\n+      { return make_shared<_RegexT>(std::move(_M_nfa)); }\n \n     private:\n       typedef _Scanner<_FwdIter>                              _ScannerT;"}, {"sha": "58ef0f0cbe5083c52e4fd26250ebd36dc85d9064", "filename": "libstdc++-v3/include/bits/regex_compiler.tcc", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d9d218516ac5f1004d1b5aef427d11bea1a242c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d9d218516ac5f1004d1b5aef427d11bea1a242c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc?ref=7d9d218516ac5f1004d1b5aef427d11bea1a242c", "patch": "@@ -147,11 +147,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _M_assertion()\n     {\n       if (_M_match_token(_ScannerT::_S_token_line_begin))\n-\t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa.\n-\t      _M_insert_line_begin()));\n+\t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa._M_insert_line_begin()));\n       else if (_M_match_token(_ScannerT::_S_token_line_end))\n-\t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa.\n-\t      _M_insert_line_end()));\n+\t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa._M_insert_line_end()));\n       else if (_M_match_token(_ScannerT::_S_token_word_bound))\n \t// _M_value[0] == 'n' means it's negtive, say \"not word boundary\".\n \t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa.\n@@ -305,7 +303,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t       _M_traits, _M_flags);\n \t  __matcher._M_add_character_class(_M_value);\n \t  _M_stack.push(_StateSeqT(_M_nfa,\n-\t\t_M_nfa._M_insert_matcher(__matcher)));\n+\t\t_M_nfa._M_insert_matcher(std::move(__matcher))));\n \t}\n       else if (_M_match_token(_ScannerT::_S_token_subexpr_no_group_begin))\n \t{\n@@ -343,7 +341,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _BMatcherT __matcher(__neg, _M_traits, _M_flags);\n       while (!_M_match_token(_ScannerT::_S_token_bracket_end))\n \t_M_expression_term(__matcher);\n-      _M_stack.push(_StateSeqT(_M_nfa, _M_nfa._M_insert_matcher(__matcher)));\n+      _M_stack.push(_StateSeqT(_M_nfa,\n+\t\t\t       _M_nfa._M_insert_matcher(std::move(__matcher))));\n       return true;\n     }\n \n@@ -432,8 +431,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _CharT, typename _TraitsT>\n-    bool _BracketMatcher<_CharT, _TraitsT>::\n-    operator()(_CharT __ch) const\n+    bool\n+    _BracketMatcher<_CharT, _TraitsT>::operator()(_CharT __ch) const\n     {\n       bool __ret = false;\n       if (_M_traits.isctype(__ch, _M_class_set)"}, {"sha": "f08f292886e6b5c5472958840b187e0dca78daa2", "filename": "libstdc++-v3/include/bits/regex_executor.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d9d218516ac5f1004d1b5aef427d11bea1a242c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d9d218516ac5f1004d1b5aef427d11bea1a242c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h?ref=7d9d218516ac5f1004d1b5aef427d11bea1a242c", "patch": "@@ -53,7 +53,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    */\n \n   template<typename _BiIter, typename _Alloc, typename _TraitsT,\n-    bool __dfs_mode>\n+\t   bool __dfs_mode>\n     class _Executor\n     {\n     public:\n@@ -117,9 +117,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       bool\n       _M_is_word(_CharT __ch) const\n       {\n-\tstatic const _CharT __s = 'w';\n+\tstatic const _CharT __s[2] = { 'w' };\n \treturn _M_re._M_traits.isctype\n-\t  (__ch, _M_re._M_traits.lookup_classname(&__s, &__s+1));\n+\t  (__ch, _M_re._M_traits.lookup_classname(__s, __s+1));\n       }\n \n       bool"}]}