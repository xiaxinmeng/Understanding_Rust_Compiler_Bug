{"sha": "dc6d66b319dd54d881f549b97d6ac17fdaa1d249", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM2ZDY2YjMxOWRkNTRkODgxZjU0OWI5N2Q2YWMxN2ZkYWExZDI0OQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-12-27T20:23:01Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-12-27T20:23:01Z"}, "message": "(expand_expr, case VAR_DECL): Set REGNO_POINTER_ALIGN when copying address into memory.\n\n(expand_expr, case VAR_DECL): Set REGNO_POINTER_ALIGN\nwhen copying address into memory.\n(expand_expr, case COMPONENT_REF, case ADDR_EXPR): Set alignment\nof register when result or result's address.\n(expand_expr, case CONVERT_EXPR): Don't handle -fforce-mem here.\n\nFrom-SVN: r10869", "tree": {"sha": "ceed7ee9a8690b910cae6bdadb4bbcfc4f679a58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ceed7ee9a8690b910cae6bdadb4bbcfc4f679a58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc6d66b319dd54d881f549b97d6ac17fdaa1d249", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc6d66b319dd54d881f549b97d6ac17fdaa1d249", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc6d66b319dd54d881f549b97d6ac17fdaa1d249", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc6d66b319dd54d881f549b97d6ac17fdaa1d249/comments", "author": null, "committer": null, "parents": [{"sha": "6c6166bdcb941475a5767e7af35bf871045111f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c6166bdcb941475a5767e7af35bf871045111f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c6166bdcb941475a5767e7af35bf871045111f6"}], "stats": {"total": 57, "additions": 39, "deletions": 18}, "files": [{"sha": "33536eeb1dbc70b2a12e0663f5ec8509e5259cac", "filename": "gcc/expr.c", "status": "modified", "additions": 39, "deletions": 18, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc6d66b319dd54d881f549b97d6ac17fdaa1d249/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc6d66b319dd54d881f549b97d6ac17fdaa1d249/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=dc6d66b319dd54d881f549b97d6ac17fdaa1d249", "patch": "@@ -4520,6 +4520,9 @@ expand_expr (exp, target, tmode, modifier)\n \t  TREE_USED (exp) = 1;\n \t}\n \n+      /* Show we haven't gotten RTL for this yet.  */\n+      temp = 0;\n+\n       /* Handle variables inherited from containing functions.  */\n       context = decl_function_context (exp);\n \n@@ -4547,32 +4550,44 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t    fix_lexical_addr (XEXP (addr, 0), exp));\n \t  else\n \t    addr = fix_lexical_addr (addr, exp);\n-\t  return change_address (DECL_RTL (exp), mode, addr);\n+\t  temp = change_address (DECL_RTL (exp), mode, addr);\n \t}\n \n       /* This is the case of an array whose size is to be determined\n \t from its initializer, while the initializer is still being parsed.\n \t See expand_decl.  */\n \n-      if (GET_CODE (DECL_RTL (exp)) == MEM\n-\t  && GET_CODE (XEXP (DECL_RTL (exp), 0)) == REG)\n-\treturn change_address (DECL_RTL (exp), GET_MODE (DECL_RTL (exp)),\n+      else if (GET_CODE (DECL_RTL (exp)) == MEM\n+\t       && GET_CODE (XEXP (DECL_RTL (exp), 0)) == REG)\n+\ttemp = change_address (DECL_RTL (exp), GET_MODE (DECL_RTL (exp)),\n \t\t\t       XEXP (DECL_RTL (exp), 0));\n \n       /* If DECL_RTL is memory, we are in the normal case and either\n \t the address is not valid or it is not a register and -fforce-addr\n \t is specified, get the address into a register.  */\n \n-      if (GET_CODE (DECL_RTL (exp)) == MEM\n-\t  && modifier != EXPAND_CONST_ADDRESS\n-\t  && modifier != EXPAND_SUM\n-\t  && modifier != EXPAND_INITIALIZER\n-\t  && (! memory_address_p (DECL_MODE (exp), XEXP (DECL_RTL (exp), 0))\n-\t      || (flag_force_addr\n-\t\t  && GET_CODE (XEXP (DECL_RTL (exp), 0)) != REG)))\n-\treturn change_address (DECL_RTL (exp), VOIDmode,\n+      else if (GET_CODE (DECL_RTL (exp)) == MEM\n+\t       && modifier != EXPAND_CONST_ADDRESS\n+\t       && modifier != EXPAND_SUM\n+\t       && modifier != EXPAND_INITIALIZER\n+\t       && (! memory_address_p (DECL_MODE (exp),\n+\t\t\t\t       XEXP (DECL_RTL (exp), 0))\n+\t\t   || (flag_force_addr\n+\t\t       && GET_CODE (XEXP (DECL_RTL (exp), 0)) != REG)))\n+\ttemp = change_address (DECL_RTL (exp), VOIDmode,\n \t\t\t       copy_rtx (XEXP (DECL_RTL (exp), 0)));\n \n+      /* If we got something, return it.  But first, set the alignment\n+\t the address is a register.  */\n+      if (temp != 0)\n+\t{\n+\t  if (GET_CODE (temp) == MEM && GET_CODE (XEXP (temp, 0)) == REG)\n+\t    mark_reg_pointer (XEXP (temp, 0),\n+\t\t\t      DECL_ALIGN (exp) / BITS_PER_UNIT);\n+\n+\t  return temp;\n+\t}\n+\n       /* If the mode of DECL_RTL does not match that of the decl, it\n \t must be a promoted value.  We return a SUBREG of the wanted mode,\n \t but mark it so that we know that it was already extended.  */\n@@ -5206,7 +5221,12 @@ expand_expr (exp, target, tmode, modifier)\n \t    if (ext_mode == BLKmode)\n \t      abort ();\n \n-\t    op0 = extract_bit_field (validize_mem (op0), bitsize, bitpos,\n+\t    op0 = validize_mem (op0);\n+\n+\t    if (GET_CODE (op0) == MEM && GET_CODE (XEXP (op0, 0)) == REG)\n+\t      mark_reg_pointer (XEXP (op0, 0), alignment);\n+\n+\t    op0 = extract_bit_field (op0, bitsize, bitpos,\n \t\t\t\t     unsignedp, target, ext_mode, ext_mode,\n \t\t\t\t     alignment,\n \t\t\t\t     int_size_in_bytes (TREE_TYPE (tem)));\n@@ -5238,6 +5258,9 @@ expand_expr (exp, target, tmode, modifier)\n \t  op0 = change_address (op0, mode1,\n \t\t\t\tplus_constant (XEXP (op0, 0),\n \t\t\t\t\t       (bitpos / BITS_PER_UNIT)));\n+\tif (GET_CODE (XEXP (op0, 0)) == REG)\n+\t  mark_reg_pointer (XEXP (op0, 0), alignment);\n+\n \tMEM_IN_STRUCT_P (op0) = 1;\n \tMEM_VOLATILE_P (op0) |= volatilep;\n \tif (mode == mode1 || mode1 == BLKmode || mode1 == tmode)\n@@ -5496,9 +5519,6 @@ expand_expr (exp, target, tmode, modifier)\n       if (modifier == EXPAND_INITIALIZER)\n \treturn gen_rtx (unsignedp ? ZERO_EXTEND : SIGN_EXTEND, mode, op0);\n \n-      if (flag_force_mem && GET_CODE (op0) == MEM)\n-\top0 = copy_to_reg (op0);\n-\n       if (target == 0)\n \treturn\n \t  convert_to_mode (mode, op0,\n@@ -6720,8 +6740,9 @@ expand_expr (exp, target, tmode, modifier)\n       if (flag_force_addr && GET_CODE (op0) != REG)\n \top0 = force_reg (Pmode, op0);\n \n-      if (GET_CODE (op0) == REG)\n-\tmark_reg_pointer (op0);\n+      if (GET_CODE (op0) == REG\n+\t  && ! REG_USERVAR_P (op0))\n+\tmark_reg_pointer (op0, TYPE_ALIGN (TREE_TYPE (type)) / BITS_PER_UNIT);\n \n       /* If we might have had a temp slot, add an equivalent address\n \t for it.  */"}]}