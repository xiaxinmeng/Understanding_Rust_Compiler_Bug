{"sha": "55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff", "node_id": "C_kwDOANBUbNoAKDU1YTExYzdlMzQ1ZGQwNmQ2OTc1ZmU4ZjRkYzBlMTFlY2JiNTgxZmY", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2022-04-05T00:52:11Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-19T14:05:30Z"}, "message": "[Ada] Fix bug in handling of Predicate_Failure aspect\n\nThe run-time behavior of the Ada 2022 Predicate_Failure aspect was\nincorrectly implemented. This could cause incorrect exception messages\nat execution time in the case of a predicate check failure, as\ndemonstrated by ACATS test C324006. In addition, a new attribute\n(Predicate_Expression) is defined in order to improve the FE/SPARK\ninterface.\n\ngcc/ada/\n\n\t* einfo-utils.ads, einfo-utils.adb: Delete Predicate_Function_M\n\tfunction and Set_Predicate_Function_M procedure.\n\t* einfo.ads: Delete comments for Is_Predicate_Function_M and\n\tPredicate_Function_M functions. Add comment for new\n\tPredicate_Expression function. Update comment describing\n\tpredicate functions.\n\t* exp_util.ads, exp_util.adb (Make_Predicate_Call): Replace Mem\n\tformal parameter with Static_Mem and Dynamic_Mem formals.\n\t(Make_Predicate_Check): Delete Add_Failure_Expression and call\n\tto it.\n\t* exp_ch4.adb (Expand_N_In.Predicate_Check): Update\n\tMake_Predicate_Call call to match profile change.\n\t* gen_il-fields.ads: Delete Is_Predicate_Function_M field, add\n\tPredicate_Expression field.\n\t* gen_il-gen-gen_entities.adb: Delete Is_Predicate_Function_M\n\tuse, add Predicate_Expression use.\n\t* sem_ch13.adb (Build_Predicate_Functions): Rename as singular,\n\tnot plural; we no longer build a Predicate_M function. Delete\n\tPredicate_M references. Add new Boolean parameter for predicate\n\tfunctions when needed. Restructure body of generated predicate\n\tfunctions to implement required Predicate_Failure behavior and\n\tto set new Predicate_Expression attribute. Remove special\n\ttreatment of raise expressions within predicate expressions.\n\t* sem_util.ads (Predicate_Failure_Expression,\n\tPredicate_Function_Needs_Membership_Parameter): New functions.\n\t* sem_util.adb (Is_Current_Instance): Fix bugs which caused\n\twrong result.\n\t(Is_Current_Instance_Reference_In_Type_Aspect): Delete\n\tIs_Predicate_Function_M reference.\n\t(Predicate_Failure_Expression): New function.\n\t(Propagate_Predicate_Attributes): Delete Is_Predicate_Function_M\n\treferences.", "tree": {"sha": "1b1faa1b7ab2504a80b5417053e7b869a3b0508b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b1faa1b7ab2504a80b5417053e7b869a3b0508b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8be71a90b15916a966553c47857e1579ca22d507", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8be71a90b15916a966553c47857e1579ca22d507", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8be71a90b15916a966553c47857e1579ca22d507"}], "stats": {"total": 1013, "additions": 436, "deletions": 577}, "files": [{"sha": "48a1bce817de45b4c4eec6a84efc404d91c58299", "filename": "gcc/ada/einfo-utils.adb", "status": "modified", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff/gcc%2Fada%2Feinfo-utils.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff/gcc%2Fada%2Feinfo-utils.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo-utils.adb?ref=55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff", "patch": "@@ -2390,53 +2390,6 @@ package body Einfo.Utils is\n       return Empty;\n    end Predicate_Function;\n \n-   --------------------------\n-   -- Predicate_Function_M --\n-   --------------------------\n-\n-   function Predicate_Function_M (Id : E) return E is\n-      Subp_Elmt : Elmt_Id;\n-      Subp_Id   : Entity_Id;\n-      Subps     : Elist_Id;\n-      Typ       : Entity_Id;\n-\n-   begin\n-      pragma Assert (Is_Type (Id));\n-\n-      --  If type is private and has a completion, predicate may be defined on\n-      --  the full view.\n-\n-      if Is_Private_Type (Id)\n-         and then\n-           (not Has_Predicates (Id) or else No (Subprograms_For_Type (Id)))\n-         and then Present (Full_View (Id))\n-      then\n-         Typ := Full_View (Id);\n-\n-      else\n-         Typ := Id;\n-      end if;\n-\n-      Subps := Subprograms_For_Type (Typ);\n-\n-      if Present (Subps) then\n-         Subp_Elmt := First_Elmt (Subps);\n-         while Present (Subp_Elmt) loop\n-            Subp_Id := Node (Subp_Elmt);\n-\n-            if Ekind (Subp_Id) = E_Function\n-              and then Is_Predicate_Function_M (Subp_Id)\n-            then\n-               return Subp_Id;\n-            end if;\n-\n-            Next_Elmt (Subp_Elmt);\n-         end loop;\n-      end if;\n-\n-      return Empty;\n-   end Predicate_Function_M;\n-\n    -------------------------\n    -- Present_In_Rep_Item --\n    -------------------------\n@@ -2879,43 +2832,6 @@ package body Einfo.Utils is\n       end loop;\n    end Set_Predicate_Function;\n \n-   ------------------------------\n-   -- Set_Predicate_Function_M --\n-   ------------------------------\n-\n-   procedure Set_Predicate_Function_M (Id : E; V : E) is\n-      Subp_Elmt : Elmt_Id;\n-      Subp_Id   : Entity_Id;\n-      Subps     : Elist_Id;\n-\n-   begin\n-      pragma Assert (Is_Type (Id) and then Has_Predicates (Id));\n-\n-      Subps := Subprograms_For_Type (Id);\n-\n-      if No (Subps) then\n-         Subps := New_Elmt_List;\n-         Set_Subprograms_For_Type (Id, Subps);\n-      end if;\n-\n-      Subp_Elmt := First_Elmt (Subps);\n-      Prepend_Elmt (V, Subps);\n-\n-      --  Check for a duplicate predication function\n-\n-      while Present (Subp_Elmt) loop\n-         Subp_Id := Node (Subp_Elmt);\n-\n-         if Ekind (Subp_Id) = E_Function\n-           and then Is_Predicate_Function_M (Subp_Id)\n-         then\n-            raise Program_Error;\n-         end if;\n-\n-         Next_Elmt (Subp_Elmt);\n-      end loop;\n-   end Set_Predicate_Function_M;\n-\n    -----------------\n    -- Size_Clause --\n    -----------------"}, {"sha": "d830c8da259b8e447169a9baada81e9f1949ac47", "filename": "gcc/ada/einfo-utils.ads", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff/gcc%2Fada%2Feinfo-utils.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff/gcc%2Fada%2Feinfo-utils.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo-utils.ads?ref=55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff", "patch": "@@ -437,14 +437,12 @@ package Einfo.Utils is\n    function Invariant_Procedure                  (Id : E) return E;\n    function Partial_Invariant_Procedure          (Id : E) return E;\n    function Predicate_Function                   (Id : E) return E;\n-   function Predicate_Function_M                 (Id : E) return E;\n \n    procedure Set_DIC_Procedure                   (Id : E; V : E);\n    procedure Set_Partial_DIC_Procedure           (Id : E; V : E);\n    procedure Set_Invariant_Procedure             (Id : E; V : E);\n    procedure Set_Partial_Invariant_Procedure     (Id : E; V : E);\n    procedure Set_Predicate_Function              (Id : E; V : E);\n-   procedure Set_Predicate_Function_M            (Id : E; V : E);\n \n    ---------------\n    -- Iterators --"}, {"sha": "b0601a9648de9c70b774f3857e1b357b7ae18a4f", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff", "patch": "@@ -3106,11 +3106,6 @@ package Einfo is\n --       Present in functions and procedures. Set for generated predicate\n --       functions.\n \n---    Is_Predicate_Function_M\n---       Present in functions and procedures. Set for special version of\n---       predicate function generated for use in membership tests, where\n---       raise expressions are transformed to return False.\n-\n --    Is_Preelaborated\n --       Defined in all entities, set in E_Package and E_Generic_Package\n --       entities to which a pragma Preelaborate is applied, and also in\n@@ -4010,8 +4005,9 @@ package Einfo is\n --       Defined in all types. Set for types for which (Has_Predicates is True)\n --       and for which a predicate procedure has been built that tests that the\n --       specified predicates are True. Contains the entity for the function\n---       which takes a single argument of the given type, and returns True if\n---       the predicate holds and False if it does not.\n+--       which takes a single argument of the given type (and sometimes an\n+--       additional Boolean parameter), and returns True if the predicate\n+--       holds and False if it does not.\n --\n --       Note: flag Has_Predicate does not imply that Predicate_Function is set\n --       to a non-empty entity; this happens, for example, for itypes created\n@@ -4024,11 +4020,14 @@ package Einfo is\n --       Note: the reason this is marked as a synthesized attribute is that the\n --       way this is stored is as an element of the Subprograms_For_Type field.\n \n---    Predicate_Function_M (synthesized)\n---       Defined in all types. Present only if Predicate_Function is present,\n---       and only if the predicate function has Raise_Expression nodes. It\n---       is the special version created for membership tests, where if one of\n---       these raise expressions is executed, the result is to return False.\n+--    Predicate_Expression\n+--      Defined on functions. For the defining identifier of the subprogram\n+--      declaration (not of the subprogram body) of a predicate function,\n+--      yields the expression for the noninherited portion of the given\n+--      predicate (except in the case where the inherited portion is\n+--      non-empty and the non-inherited portion is empty, in which case the\n+--      expression for the inherited portion is returned). Otherwise yields\n+--      empty.\n \n --    Predicated_Parent\n --       Defined on itypes created by subtype indications, when the parent\n@@ -5115,7 +5114,6 @@ package Einfo is\n    --    Partial_DIC_Procedure               (synth)\n    --    Partial_Invariant_Procedure         (synth)\n    --    Predicate_Function                  (synth)\n-   --    Predicate_Function_M                (synth)\n    --    Root_Type                           (synth)\n    --    Size_Clause                         (synth)\n \n@@ -5591,7 +5589,6 @@ package Einfo is\n    --    Is_Machine_Code_Subprogram           (non-generic case only)\n    --    Is_Partial_Invariant_Procedure       (non-generic case only)\n    --    Is_Predicate_Function                (non-generic case only)\n-   --    Is_Predicate_Function_M              (non-generic case only)\n    --    Is_Primitive\n    --    Is_Primitive_Wrapper                 (non-generic case only)\n    --    Is_Private_Descendant\n@@ -5956,7 +5953,6 @@ package Einfo is\n    --    Is_Partial_DIC_Procedure             (synth) (non-generic case only)\n    --    Is_Partial_Invariant_Procedure       (non-generic case only)\n    --    Is_Predicate_Function                (non-generic case only)\n-   --    Is_Predicate_Function_M              (non-generic case only)\n    --    Is_Primitive\n    --    Is_Primitive_Wrapper                 (non-generic case only)\n    --    Is_Private_Descendant"}, {"sha": "9e86b4d81a51bebed35a0402e1e72521f9252600", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff", "patch": "@@ -6962,7 +6962,9 @@ package body Exp_Ch4 is\n            and then Nkind (Rop) /= N_Range\n          then\n             if not In_Range_Check then\n-               R_Op := Make_Predicate_Call (Rtyp, Lop, Mem => True);\n+               --  Indicate via Static_Mem parameter that this predicate\n+               --  evaluation is for a membership test.\n+               R_Op := Make_Predicate_Call (Rtyp, Lop, Static_Mem => True);\n             else\n                R_Op := New_Occurrence_Of (Standard_True, Loc);\n             end if;"}, {"sha": "290c3805627dbb0e65af7e65057b9d2bc9218499", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 24, "deletions": 179, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff", "patch": "@@ -9927,19 +9927,20 @@ package body Exp_Util is\n    --  Ghost mode.\n \n    function Make_Predicate_Call\n-     (Typ  : Entity_Id;\n-      Expr : Node_Id;\n-      Mem  : Boolean := False) return Node_Id\n+     (Typ         : Entity_Id;\n+      Expr        : Node_Id;\n+      Static_Mem  : Boolean := False;\n+      Dynamic_Mem : Node_Id := Empty) return Node_Id\n    is\n       Loc : constant Source_Ptr := Sloc (Expr);\n \n       Saved_GM  : constant Ghost_Mode_Type := Ghost_Mode;\n       Saved_IGR : constant Node_Id         := Ignored_Ghost_Region;\n       --  Save the Ghost-related attributes to restore on exit\n \n-      Call    : Node_Id;\n-      Func_Id : Entity_Id;\n-\n+      Call         : Node_Id;\n+      Func_Id      : Entity_Id;\n+      Param_Assocs : List_Id;\n    begin\n       Func_Id := Predicate_Function (Typ);\n       pragma Assert (Present (Func_Id));\n@@ -9949,12 +9950,6 @@ package body Exp_Util is\n \n       Set_Ghost_Mode (Typ);\n \n-      --  Call special membership version if requested and available\n-\n-      if Mem and then Present (Predicate_Function_M (Typ)) then\n-         Func_Id := Predicate_Function_M (Typ);\n-      end if;\n-\n       --  Case of calling normal predicate function\n \n       --  If the type is tagged, the expression may be class-wide, in which\n@@ -9964,18 +9959,26 @@ package body Exp_Util is\n       --  extensions are involved.\n \n       if Is_Tagged_Type (Typ) then\n-         Call :=\n-           Make_Function_Call (Loc,\n-             Name                   => New_Occurrence_Of (Func_Id, Loc),\n-             Parameter_Associations =>\n-               New_List (OK_Convert_To (Typ, Relocate_Node (Expr))));\n+         Param_Assocs := New_List (OK_Convert_To (Typ, Relocate_Node (Expr)));\n       else\n-         Call :=\n-           Make_Function_Call (Loc,\n-             Name                   => New_Occurrence_Of (Func_Id, Loc),\n-             Parameter_Associations => New_List (Relocate_Node (Expr)));\n+         Param_Assocs := New_List (Relocate_Node (Expr));\n       end if;\n \n+      if Predicate_Function_Needs_Membership_Parameter (Typ) then\n+         --  Pass in parameter indicating whether this call is for a\n+         --  membership test.\n+         Append ((if Present (Dynamic_Mem)\n+                    then Dynamic_Mem\n+                    else New_Occurrence_Of\n+                           (Boolean_Literals (Static_Mem), Loc)),\n+                 Param_Assocs);\n+      end if;\n+\n+      Call :=\n+        Make_Function_Call (Loc,\n+          Name                   => New_Occurrence_Of (Func_Id, Loc),\n+          Parameter_Associations => Param_Assocs);\n+\n       Restore_Ghost_Region (Saved_GM, Saved_IGR);\n \n       return Call;\n@@ -9991,161 +9994,6 @@ package body Exp_Util is\n    is\n       Loc : constant Source_Ptr := Sloc (Expr);\n \n-      procedure Add_Failure_Expression (Args : List_Id);\n-      --  Add the failure expression of pragma Predicate_Failure (if any) to\n-      --  list Args.\n-\n-      ----------------------------\n-      -- Add_Failure_Expression --\n-      ----------------------------\n-\n-      procedure Add_Failure_Expression (Args : List_Id) is\n-         function Failure_Expression return Node_Id;\n-         pragma Inline (Failure_Expression);\n-         --  Find aspect or pragma Predicate_Failure that applies to type Typ\n-         --  and return its expression. Return Empty if no such annotation is\n-         --  available.\n-\n-         function Is_OK_PF_Aspect (Asp : Node_Id) return Boolean;\n-         pragma Inline (Is_OK_PF_Aspect);\n-         --  Determine whether aspect Asp is a suitable Predicate_Failure\n-         --  aspect that applies to type Typ.\n-\n-         function Is_OK_PF_Pragma (Prag : Node_Id) return Boolean;\n-         pragma Inline (Is_OK_PF_Pragma);\n-         --  Determine whether pragma Prag is a suitable Predicate_Failure\n-         --  pragma that applies to type Typ.\n-\n-         procedure Replace_Subtype_Reference (N : Node_Id);\n-         --  Replace the current instance of type Typ denoted by N with\n-         --  expression Expr.\n-\n-         ------------------------\n-         -- Failure_Expression --\n-         ------------------------\n-\n-         function Failure_Expression return Node_Id is\n-            Item : Node_Id;\n-\n-         begin\n-            --  The management of the rep item chain involves \"inheritance\" of\n-            --  parent type chains. If a parent [sub]type is already subject to\n-            --  pragma Predicate_Failure, then the pragma will also appear in\n-            --  the chain of the child [sub]type, which in turn may possess a\n-            --  pragma of its own. Avoid order-dependent issues by inspecting\n-            --  the rep item chain directly. Note that routine Get_Pragma may\n-            --  return a parent pragma.\n-\n-            Item := First_Rep_Item (Typ);\n-            while Present (Item) loop\n-\n-               --  Predicate_Failure appears as an aspect\n-\n-               if Nkind (Item) = N_Aspect_Specification\n-                 and then Is_OK_PF_Aspect (Item)\n-               then\n-                  return Expression (Item);\n-\n-               --  Predicate_Failure appears as a pragma\n-\n-               elsif Nkind (Item) = N_Pragma\n-                 and then Is_OK_PF_Pragma (Item)\n-               then\n-                  return\n-                    Get_Pragma_Arg\n-                      (Next (First (Pragma_Argument_Associations (Item))));\n-               end if;\n-\n-               Next_Rep_Item (Item);\n-            end loop;\n-\n-            return Empty;\n-         end Failure_Expression;\n-\n-         ---------------------\n-         -- Is_OK_PF_Aspect --\n-         ---------------------\n-\n-         function Is_OK_PF_Aspect (Asp : Node_Id) return Boolean is\n-         begin\n-            --  To qualify, the aspect must apply to the type subjected to the\n-            --  predicate check.\n-\n-            return\n-              Chars (Identifier (Asp)) = Name_Predicate_Failure\n-                and then Present (Entity (Asp))\n-                and then Entity (Asp) = Typ;\n-         end Is_OK_PF_Aspect;\n-\n-         ---------------------\n-         -- Is_OK_PF_Pragma --\n-         ---------------------\n-\n-         function Is_OK_PF_Pragma (Prag : Node_Id) return Boolean is\n-            Args    : constant List_Id := Pragma_Argument_Associations (Prag);\n-            Typ_Arg : Node_Id;\n-\n-         begin\n-            --  Nothing to do when the pragma does not denote Predicate_Failure\n-\n-            if Pragma_Name (Prag) /= Name_Predicate_Failure then\n-               return False;\n-\n-            --  Nothing to do when the pragma lacks arguments, in which case it\n-            --  is illegal.\n-\n-            elsif Is_Empty_List (Args) then\n-               return False;\n-            end if;\n-\n-            Typ_Arg := Get_Pragma_Arg (First (Args));\n-\n-            --  To qualify, the local name argument of the pragma must denote\n-            --  the type subjected to the predicate check.\n-\n-            return\n-              Is_Entity_Name (Typ_Arg)\n-                and then Present (Entity (Typ_Arg))\n-                and then Entity (Typ_Arg) = Typ;\n-         end Is_OK_PF_Pragma;\n-\n-         --------------------------------\n-         --  Replace_Subtype_Reference --\n-         --------------------------------\n-\n-         procedure Replace_Subtype_Reference (N : Node_Id) is\n-         begin\n-            Rewrite (N, New_Copy_Tree (Expr));\n-         end Replace_Subtype_Reference;\n-\n-         procedure Replace_Subtype_References is\n-           new Replace_Type_References_Generic (Replace_Subtype_Reference);\n-\n-         --  Local variables\n-\n-         PF_Expr : constant Node_Id := Failure_Expression;\n-         Expr    : Node_Id;\n-\n-      --  Start of processing for Add_Failure_Expression\n-\n-      begin\n-         if Present (PF_Expr) then\n-\n-            --  Replace any occurrences of the current instance of the type\n-            --  with the object subjected to the predicate check.\n-\n-            Expr := New_Copy_Tree (PF_Expr);\n-            Replace_Subtype_References (Expr, Typ);\n-\n-            --  The failure expression appears as the third argument of the\n-            --  Check pragma.\n-\n-            Append_To (Args,\n-              Make_Pragma_Argument_Association (Loc,\n-                Expression => Expr));\n-         end if;\n-      end Add_Failure_Expression;\n-\n       --  Local variables\n \n       Args : List_Id;\n@@ -10188,8 +10036,6 @@ package body Exp_Util is\n       --  If the subtype is subject to pragma Predicate_Failure, add the\n       --  failure expression as an additional parameter.\n \n-      Add_Failure_Expression (Args);\n-\n       return\n         Make_Pragma (Loc,\n           Chars                        => Name_Check,\n@@ -14339,7 +14185,6 @@ package body Exp_Util is\n \n          elsif Get_TSS_Name (S) /= TSS_Null\n            and then not Is_Predicate_Function (S)\n-           and then not Is_Predicate_Function_M (S)\n          then\n             return False;\n          end if;"}, {"sha": "464f66f742017b99c5bba056c0cfdbc71ecb9723", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff", "patch": "@@ -876,13 +876,19 @@ package Exp_Util is\n    --  expression Expr. Expr is passed as an actual parameter in the call.\n \n    function Make_Predicate_Call\n-     (Typ  : Entity_Id;\n-      Expr : Node_Id;\n-      Mem  : Boolean := False) return Node_Id;\n+     (Typ         : Entity_Id;\n+      Expr        : Node_Id;\n+      Static_Mem  : Boolean := False;\n+      Dynamic_Mem : Node_Id := Empty) return Node_Id;\n    --  Typ is a type with Predicate_Function set. This routine builds a call to\n    --  this function passing Expr as the argument, and returns it unanalyzed.\n-   --  If Mem is set True, this is the special call for the membership case,\n-   --  and the function called is the Predicate_Function_M if present.\n+   --  If the callee takes a second parameter (as determined by\n+   --  Sem_Util.Predicate_Function_Needs_Membership_Parameter), then the\n+   --  actual parameter is determined by the two Mem parameters.\n+   --  If Dynamic_Mem is nonempty, then Dynamic_Mem is the actual parameter.\n+   --  Otherwise, the value of the Static_Mem parameter is passed in as\n+   --  a Boolean literal. It is an error if Dynamic_Mem is nonempty but\n+   --  the callee does not take a second parameter.\n \n    function Make_Predicate_Check\n      (Typ  : Entity_Id;"}, {"sha": "878755bf34ecc24536cc8879a0867d05a54ac8b8", "filename": "gcc/ada/gen_il-fields.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff/gcc%2Fada%2Fgen_il-fields.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff/gcc%2Fada%2Fgen_il-fields.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-fields.ads?ref=55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff", "patch": "@@ -756,7 +756,6 @@ package Gen_IL.Fields is\n       Is_Partial_Invariant_Procedure,\n       Is_Potentially_Use_Visible,\n       Is_Predicate_Function,\n-      Is_Predicate_Function_M,\n       Is_Preelaborated,\n       Is_Primitive,\n       Is_Primitive_Wrapper,\n@@ -851,6 +850,7 @@ package Gen_IL.Fields is\n       Partial_View_Has_Unknown_Discr,\n       Pending_Access_Types,\n       Postconditions_Proc,\n+      Predicate_Expression,\n       Prev_Entity,\n       Prival,\n       Prival_Link,"}, {"sha": "89d86594c525695b1e367565523ccb2176e2907f", "filename": "gcc/ada/gen_il-gen-gen_entities.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff/gcc%2Fada%2Fgen_il-gen-gen_entities.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff/gcc%2Fada%2Fgen_il-gen-gen_entities.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen-gen_entities.adb?ref=55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff", "patch": "@@ -1031,14 +1031,14 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Is_Invariant_Procedure, Flag),\n         Sm (Is_Partial_Invariant_Procedure, Flag),\n         Sm (Is_Predicate_Function, Flag),\n-        Sm (Is_Predicate_Function_M, Flag),\n         Sm (Is_Primitive_Wrapper, Flag),\n         Sm (Is_Private_Primitive, Flag),\n         Sm (LSP_Subprogram, Node_Id),\n         Sm (Mechanism, Mechanism_Type),\n         Sm (Next_Inlined_Subprogram, Node_Id),\n         Sm (Original_Protected_Subprogram, Node_Id),\n         Sm (Postconditions_Proc, Node_Id),\n+        Sm (Predicate_Expression, Node_Id),\n         Sm (Protected_Subprogram, Node_Id),\n         Sm (Protection_Object, Node_Id),\n         Sm (Related_Expression, Node_Id),\n@@ -1080,7 +1080,6 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Is_Null_Init_Proc, Flag),\n         Sm (Is_Partial_Invariant_Procedure, Flag),\n         Sm (Is_Predicate_Function, Flag),\n-        Sm (Is_Predicate_Function_M, Flag),\n         Sm (Is_Primitive_Wrapper, Flag),\n         Sm (Is_Private_Primitive, Flag),\n         Sm (Is_Valued_Procedure, Flag),"}, {"sha": "54f32a2fc49510f44e425b44d2c01cceaac5090f", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 290, "deletions": 275, "changes": 565, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff", "patch": "@@ -133,17 +133,15 @@ package body Sem_Ch13 is\n    --  may be before the freeze point of the type. The predicate expression is\n    --  preanalyzed at this point, to catch visibility errors.\n \n-   procedure Build_Predicate_Functions (Typ : Entity_Id; N : Node_Id);\n+   procedure Build_Predicate_Function (Typ : Entity_Id; N : Node_Id);\n    --  If Typ has predicates (indicated by Has_Predicates being set for Typ),\n    --  then either there are pragma Predicate entries on the rep chain for the\n    --  type (note that Predicate aspects are converted to pragma Predicate), or\n    --  there are inherited aspects from a parent type, or ancestor subtypes.\n    --  This procedure builds body for the Predicate function that tests these\n    --  predicates. N is the freeze node for the type. The spec of the function\n    --  is inserted before the freeze node, and the body of the function is\n-   --  inserted after the freeze node. If the predicate expression has a least\n-   --  one Raise_Expression, then this procedure also builds the M version of\n-   --  the predicate function for use in membership tests.\n+   --  inserted after the freeze node.\n \n    procedure Check_Pool_Size_Clash (Ent : Entity_Id; SP, SS : Node_Id);\n    --  Called if both Storage_Pool and Storage_Size attribute definition\n@@ -9462,10 +9460,7 @@ package body Sem_Ch13 is\n                   declare\n                      Ent : constant Entity_Id := Entity (Name (Exp));\n                   begin\n-                     if Is_Predicate_Function (Ent)\n-                          or else\n-                        Is_Predicate_Function_M (Ent)\n-                     then\n+                     if Is_Predicate_Function (Ent) then\n                         return Stat_Pred (Etype (First_Formal (Ent)), Static);\n                      end if;\n                   end;\n@@ -10006,11 +10001,11 @@ package body Sem_Ch13 is\n       return Prag;\n    end Build_Export_Import_Pragma;\n \n-   -------------------------------\n-   -- Build_Predicate_Functions --\n-   -------------------------------\n+   ------------------------------\n+   -- Build_Predicate_Function --\n+   ------------------------------\n \n-   --  The functions that are constructed here have the form:\n+   --  The function constructed here has the form:\n \n    --    function typPredicate (Ixxx : typ) return Boolean is\n    --    begin\n@@ -10021,6 +10016,18 @@ package body Sem_Ch13 is\n    --          and then exp1 and then exp2 and then ...;\n    --    end typPredicate;\n \n+   --  If Predicate_Function_Needs_Membership_Parameter is true, then this\n+   --  function takes an additional boolean parameter; the parameter\n+   --  indicates whether the predicate evaluation is part of a membership\n+   --  test. This parameter is used in two cases: 1) It is passed along\n+   --  if another predicate function is called and that predicate function\n+   --  expects to be passed a boolean parameter. 2) If the Predicate_Failure\n+   --  aspect is directly specified for typ, then we replace the return\n+   --  expression described above with\n+   --      (if <expression described above> then True\n+   --       elsif For_Membership_Test then False\n+   --       else (raise Assertion_Error\n+   --                     with <Predicate_Failure expression>))\n    --  Here exp1, and exp2 are expressions from Predicate pragmas. Note that\n    --  this is the point at which these expressions get analyzed, providing the\n    --  required delay, and typ1, typ2, are entities from which predicates are\n@@ -10033,26 +10040,17 @@ package body Sem_Ch13 is\n    --  Note that Sem_Eval.Real_Or_String_Static_Predicate_Matches depends on\n    --  the form of this return expression.\n \n-   --  If the expression has at least one Raise_Expression, then we also build\n-   --  the typPredicateM version of the function, in which any occurrence of a\n-   --  Raise_Expression is converted to \"return False\".\n-\n    --  WARNING: This routine manages Ghost regions. Return statements must be\n    --  replaced by gotos which jump to the end of the routine and restore the\n    --  Ghost mode.\n \n-   procedure Build_Predicate_Functions (Typ : Entity_Id; N : Node_Id) is\n+   procedure Build_Predicate_Function (Typ : Entity_Id; N : Node_Id) is\n       Loc : constant Source_Ptr := Sloc (Typ);\n \n       Expr : Node_Id;\n       --  This is the expression for the result of the function. It is\n       --  is build by connecting the component predicates with AND THEN.\n \n-      Expr_M : Node_Id := Empty; -- init to avoid warning\n-      --  This is the corresponding return expression for the Predicate_M\n-      --  function. It differs in that raise expressions are marked for\n-      --  special expansion (see Process_REs).\n-\n       Object_Name : Name_Id;\n       --  Name for argument of Predicate procedure. Note that we use the same\n       --  name for both predicate functions. That way the reference within the\n@@ -10061,18 +10059,15 @@ package body Sem_Ch13 is\n       Object_Entity : Entity_Id;\n       --  Entity for argument of Predicate procedure\n \n-      Object_Entity_M : Entity_Id;\n-      --  Entity for argument of separate Predicate procedure when exceptions\n-      --  are present in expression.\n-\n       FDecl : Node_Id;\n       --  The function declaration\n \n       SId : Entity_Id;\n       --  Its entity\n \n-      Raise_Expression_Present : Boolean := False;\n-      --  Set True if Expr has at least one Raise_Expression\n+      Ancestor_Predicate_Function_Called : Boolean := False;\n+      --  Does this predicate function include a call to the\n+      --  predication function of an ancestor subtype?\n \n       procedure Add_Condition (Cond : Node_Id);\n       --  Append Cond to Expr using \"and then\" (or just copy Cond to Expr if\n@@ -10088,19 +10083,11 @@ package body Sem_Ch13 is\n       --  Includes a call to the predicate function for type T in Expr if\n       --  Predicate_Function (T) is non-empty.\n \n-      function Process_RE (N : Node_Id) return Traverse_Result;\n-      --  Used in Process REs, tests if node N is a raise expression, and if\n-      --  so, marks it to be converted to return False.\n-\n-      procedure Process_REs is new Traverse_Proc (Process_RE);\n-      --  Marks any raise expressions in Expr_M to return False\n-\n-      function Test_RE (N : Node_Id) return Traverse_Result;\n-      --  Used in Test_REs, tests one node for being a raise expression, and if\n-      --  so sets Raise_Expression_Present True.\n-\n-      procedure Test_REs is new Traverse_Proc (Test_RE);\n-      --  Tests to see if Expr contains any raise expressions\n+      procedure Replace_Current_Instance_References\n+         (N : Node_Id; Typ, New_Entity : Entity_Id);\n+      --  Replace all references to Typ in the tree rooted at N with\n+      --  references to Param. [New_Entity will be a formal parameter of a\n+      --  predicate function.]\n \n       --------------\n       -- Add_Call --\n@@ -10116,16 +10103,34 @@ package body Sem_Ch13 is\n             --  Build the call to the predicate function of T. The type may be\n             --  derived, so use an unchecked conversion for the actual.\n \n-            Exp :=\n-              Make_Predicate_Call\n-                (Typ  => T,\n-                 Expr =>\n-                   Unchecked_Convert_To (T,\n-                     Make_Identifier (Loc, Object_Name)));\n+            declare\n+               Dynamic_Mem : Node_Id := Empty;\n+               Second_Formal : constant Entity_Id :=\n+                 Next_Entity (Object_Entity);\n+            begin\n+               --  Some predicate functions require a second parameter;\n+               --  If one predicate function calls another and the second\n+               --  requires two parameters, then the first should also\n+               --  take two parameters (so that the first function has\n+               --  something to pass to the second function).\n+               if Predicate_Function_Needs_Membership_Parameter (T) then\n+                  pragma Assert (Present (Second_Formal));\n+                  Dynamic_Mem := New_Occurrence_Of (Second_Formal, Loc);\n+               end if;\n+\n+               Exp :=\n+                 Make_Predicate_Call\n+                   (Typ  => T,\n+                    Expr =>\n+                      Unchecked_Convert_To (T,\n+                        Make_Identifier (Loc, Object_Name)),\n+                    Dynamic_Mem => Dynamic_Mem);\n+            end;\n \n             --  \"and\"-in the call to evolving expression\n \n             Add_Condition (Exp);\n+            Ancestor_Predicate_Function_Called := True;\n \n             --  Output info message on inheritance if required. Note we do not\n             --  give this information for generic actual types, since it is\n@@ -10182,32 +10187,6 @@ package body Sem_Ch13 is\n          -------------------\n \n          procedure Add_Predicate (Prag : Node_Id) is\n-            procedure Replace_Type_Reference (N : Node_Id);\n-            --  Replace a single occurrence N of the subtype name with a\n-            --  reference to the formal of the predicate function. N can be an\n-            --  identifier referencing the subtype, or a selected component,\n-            --  representing an appropriately qualified occurrence of the\n-            --  subtype name.\n-\n-            procedure Replace_Type_References is\n-              new Replace_Type_References_Generic (Replace_Type_Reference);\n-            --  Traverse an expression changing every occurrence of an\n-            --  identifier whose name matches the name of the subtype with a\n-            --  reference to the formal parameter of the predicate function.\n-\n-            ----------------------------\n-            -- Replace_Type_Reference --\n-            ----------------------------\n-\n-            procedure Replace_Type_Reference (N : Node_Id) is\n-            begin\n-               Rewrite (N, Make_Identifier (Sloc (N), Object_Name));\n-               --  Use the Sloc of the usage name, not the defining name\n-\n-               Set_Etype (N, Typ);\n-               Set_Entity (N, Object_Entity);\n-            end Replace_Type_Reference;\n-\n             --  Local variables\n \n             Asp  : constant Node_Id := Corresponding_Aspect (Prag);\n@@ -10236,20 +10215,25 @@ package body Sem_Ch13 is\n             if Entity (Arg1) = Typ\n               or else Full_View (Entity (Arg1)) = Typ\n             then\n-               Replace_Type_References (Arg2, Typ);\n+               declare\n+                  Arg2_Copy : constant Node_Id := New_Copy_Tree (Arg2);\n+               begin\n+                  Replace_Current_Instance_References\n+                   (Arg2_Copy, Typ => Typ, New_Entity => Object_Entity);\n \n-               --  If the predicate pragma comes from an aspect, replace the\n-               --  saved expression because we need the subtype references\n-               --  replaced for the calls to Preanalyze_Spec_Expression in\n-               --  Check_Aspect_At_xxx routines.\n+                  --  If the predicate pragma comes from an aspect, replace the\n+                  --  saved expression because we need the subtype references\n+                  --  replaced for the calls to Preanalyze_Spec_Expression in\n+                  --  Check_Aspect_At_xxx routines.\n \n-               if Present (Asp) then\n-                  Set_Entity (Identifier (Asp), New_Copy_Tree (Arg2));\n-               end if;\n+                  if Present (Asp) then\n+                     Set_Entity (Identifier (Asp), New_Copy_Tree (Arg2_Copy));\n+                  end if;\n \n-               --  \"and\"-in the Arg2 condition to evolving expression\n+                  --  \"and\"-in the Arg2 condition to evolving expression\n \n-               Add_Condition (Relocate_Node (Arg2));\n+                  Add_Condition (Arg2_Copy);\n+               end;\n             end if;\n          end Add_Predicate;\n \n@@ -10303,41 +10287,42 @@ package body Sem_Ch13 is\n          end loop;\n       end Add_Predicates;\n \n-      ----------------\n-      -- Process_RE --\n-      ----------------\n+      -----------------------------------------\n+      -- Replace_Current_Instance_References --\n+      -----------------------------------------\n \n-      function Process_RE (N : Node_Id) return Traverse_Result is\n-      begin\n-         if Nkind (N) = N_Raise_Expression then\n-            Set_Convert_To_Return_False (N);\n-            return Skip;\n-         else\n-            return OK;\n-         end if;\n-      end Process_RE;\n+      procedure Replace_Current_Instance_References\n+         (N : Node_Id; Typ, New_Entity : Entity_Id)\n+      is\n+         Root : Node_Id renames N;\n \n-      -------------\n-      -- Test_RE --\n-      -------------\n+         procedure Replace_One_Reference (N : Node_Id);\n+         --  Actual parameter for Replace_Type_References_Generic instance\n \n-      function Test_RE (N : Node_Id) return Traverse_Result is\n+         ---------------------------\n+         -- Replace_One_Reference --\n+         ---------------------------\n+\n+         procedure Replace_One_Reference (N : Node_Id) is\n+            pragma Assert (In_Subtree (N, Root => Root));\n+         begin\n+            Rewrite (N, New_Occurrence_Of (New_Entity, Sloc (N)));\n+            --  Use the Sloc of the usage name, not the defining name\n+         end Replace_One_Reference;\n+\n+         procedure Replace_Type_References is\n+           new Replace_Type_References_Generic (Replace_One_Reference);\n       begin\n-         if Nkind (N) = N_Raise_Expression then\n-            Raise_Expression_Present := True;\n-            return Abandon;\n-         else\n-            return OK;\n-         end if;\n-      end Test_RE;\n+         Replace_Type_References (N, Typ);\n+      end Replace_Current_Instance_References;\n \n       --  Local variables\n \n       Saved_GM  : constant Ghost_Mode_Type := Ghost_Mode;\n       Saved_IGR : constant Node_Id         := Ignored_Ghost_Region;\n       --  Save the Ghost-related attributes to restore on exit\n \n-   --  Start of processing for Build_Predicate_Functions\n+   --  Start of processing for Build_Predicate_Function\n \n    begin\n       --  Return if already built, if type does not have predicates,\n@@ -10399,8 +10384,7 @@ package body Sem_Ch13 is\n          Defining_Identifier\n            (First (Parameter_Specifications (Specification (FDecl))));\n \n-      Object_Name     := Chars (Object_Entity);\n-      Object_Entity_M := Make_Defining_Identifier (Loc, Chars => Object_Name);\n+      Object_Name   := Chars (Object_Entity);\n \n       --  Add predicates for ancestor if present. These must come before the\n       --  ones for the current type, as required by AI12-0071-1.\n@@ -10432,25 +10416,6 @@ package body Sem_Ch13 is\n \n       if Present (Expr) then\n \n-         --  Test for raise expression present\n-\n-         Test_REs (Expr);\n-\n-         --  If raise expression is present, capture a copy of Expr for use\n-         --  in building the predicateM function version later on. For this\n-         --  copy we replace references to Object_Entity by Object_Entity_M.\n-\n-         if Raise_Expression_Present then\n-            declare\n-               Map : constant Elist_Id := New_Elmt_List;\n-\n-            begin\n-               Append_Elmt (Object_Entity, Map);\n-               Append_Elmt (Object_Entity_M, Map);\n-               Expr_M := New_Copy_Tree (Expr, Map => Map);\n-            end;\n-         end if;\n-\n          --  Build the main predicate function\n \n          declare\n@@ -10468,27 +10433,179 @@ package body Sem_Ch13 is\n \n             --  Build function body\n \n-            Spec :=\n-              Make_Function_Specification (Loc,\n-                Defining_Unit_Name       => SIdB,\n-                Parameter_Specifications => New_List (\n-                  Make_Parameter_Specification (Loc,\n-                    Defining_Identifier =>\n-                      Make_Defining_Identifier (Loc, Object_Name),\n-                    Parameter_Type =>\n-                      New_Occurrence_Of (Typ, Loc))),\n-                Result_Definition        =>\n-                  New_Occurrence_Of (Standard_Boolean, Loc));\n-\n-            FBody :=\n-              Make_Subprogram_Body (Loc,\n-                Specification              => Spec,\n-                Declarations               => Empty_List,\n-                Handled_Statement_Sequence =>\n-                  Make_Handled_Sequence_Of_Statements (Loc,\n-                    Statements => New_List (\n-                      Make_Simple_Return_Statement (Loc,\n-                        Expression => Expr))));\n+            declare\n+               Param_Specs : constant List_Id := New_List (\n+                 Make_Parameter_Specification (Loc,\n+                   Defining_Identifier =>\n+                     Make_Defining_Identifier (Loc, Object_Name),\n+                   Parameter_Type =>\n+                     New_Occurrence_Of (Typ, Loc)));\n+            begin\n+               --  if Spec has 2 parameters, then body should too\n+               if Present (Next_Entity (Object_Entity)) then\n+                  Append (Make_Parameter_Specification (Loc,\n+                            Defining_Identifier =>\n+                              Make_Defining_Identifier\n+                                (Loc, Chars (Next_Entity (Object_Entity))),\n+                            Parameter_Type      =>\n+                              New_Occurrence_Of (Standard_Boolean, Loc)),\n+                          Param_Specs);\n+               end if;\n+\n+               Spec :=\n+                 Make_Function_Specification (Loc,\n+                   Defining_Unit_Name       => SIdB,\n+                   Parameter_Specifications => Param_Specs,\n+                   Result_Definition        =>\n+                     New_Occurrence_Of (Standard_Boolean, Loc));\n+            end;\n+\n+            --  The Predicate_Expression attribute is used by SPARK.\n+            --\n+            --  If Ancestor_Predicate_Function_Called is True, then\n+            --  we try to exclude that call to the ancestor's\n+            --  predicate function by calling Right_Opnd.\n+            --  The call is not excluded in the case where\n+            --  it is not \"and\"ed with anything else (so we don't have\n+            --  an N_And_Then node). This exclusion is required if the\n+            --  Predicate_Failure aspect is specified for Typ because\n+            --  in that case we are going to drop the N_And_Then node\n+            --  on the floor. Otherwise, it is a question of what is\n+            --  most convenient for SPARK.\n+\n+            Set_Predicate_Expression\n+              (SId, (if Ancestor_Predicate_Function_Called\n+                       and then Nkind (Expr) = N_And_Then\n+                     then Right_Opnd (Expr)\n+                     else Expr));\n+\n+            declare\n+               Result_Expr   : Node_Id := Expr;\n+               PF_Expr       : Node_Id := Predicate_Failure_Expression\n+                                            (Typ, Inherited_OK => False);\n+               PF_Expr_Copy  : Node_Id;\n+               Second_Formal : constant Entity_Id :=\n+                 Next_Entity (Object_Entity);\n+            begin\n+               if Present (PF_Expr) then\n+                  pragma Assert (Present (Second_Formal));\n+\n+                  --  This is an ugly hack to cope with an ugly situation.\n+                  --  PF_Expr may have children whose Parent attribute\n+                  --  does not point back to PF_Expr. If we pass such a\n+                  --  tree to New_Copy_Tree, then it does not make a deep\n+                  --  copy. But we need a deep copy. So we need to find a\n+                  --  tree for which New_Copy_Tree *will* make a deep copy.\n+\n+                  declare\n+                     function Check_Node_Parent (Parent_Node, Node : Node_Id)\n+                       return Traverse_Result;\n+                     function Check_Node_Parent (Parent_Node, Node : Node_Id)\n+                       return Traverse_Result is\n+                     begin\n+                        if Parent_Node = PF_Expr\n+                          and then not Is_List_Member (Node)\n+                        then\n+                           pragma Assert\n+                             (Nkind (PF_Expr) = Nkind (Parent (Node)));\n+\n+                           --  We need PF_Expr to be a node for which\n+                           --  New_Copy_Tree will make a deep copy.\n+                           PF_Expr := Parent (Node);\n+                           return Abandon;\n+                        end if;\n+                        return OK;\n+                     end Check_Node_Parent;\n+                     procedure Check_Parentage is\n+                       new Traverse_Proc_With_Parent (Check_Node_Parent);\n+                  begin\n+                     Check_Parentage (PF_Expr);\n+                     PF_Expr_Copy := New_Copy_Tree (PF_Expr);\n+                  end;\n+\n+                  --  Current instance uses need to have their Entity\n+                  --  fields set so that Replace_Current_Instance_References\n+                  --  can find them. So we preanalyze. Just for purposes of\n+                  --  calls to Is_Current_Instance during this preanalysis,\n+                  --  we set the Parent field.\n+                  Set_Parent (PF_Expr_Copy, Parent (PF_Expr));\n+                  Preanalyze (PF_Expr_Copy);\n+                  Set_Parent (PF_Expr_Copy, Empty);\n+\n+                  Replace_Current_Instance_References\n+                    (PF_Expr_Copy, Typ => Typ, New_Entity => Object_Entity);\n+\n+                  if Ancestor_Predicate_Function_Called then\n+                     --  If the call to an ancestor predicate function\n+                     --  returns False, we do not want to raise an\n+                     --  exception here. Our Predicate_Failure aspect does\n+                     --  not apply in that case. So we have to build a\n+                     --  more complicated result expression:\n+                     --   (if not Ancestor_Predicate_Function (...) then False\n+                     --    elsif Noninherited_Predicates (...) then True\n+                     --    elsif Is_Membership_Test then False\n+                     --    else (raise Assertion_Error with PF text))\n+\n+                     declare\n+                        Ancestor_Call : constant Node_Id :=\n+                          Left_Opnd (Result_Expr);\n+                        Local_Preds   : constant Node_Id :=\n+                          Right_Opnd (Result_Expr);\n+                     begin\n+                        Result_Expr :=\n+                          Make_If_Expression (Loc,\n+                            Expressions => New_List (\n+                              Make_Op_Not (Loc, Ancestor_Call),\n+                              New_Occurrence_Of (Standard_False, Loc),\n+                              Make_If_Expression (Loc,\n+                                Is_Elsif => True,\n+                                Expressions => New_List (\n+                                  Local_Preds,\n+                                  New_Occurrence_Of (Standard_True, Loc),\n+                                  Make_If_Expression (Loc,\n+                                    Is_Elsif => True,\n+                                    Expressions => New_List (\n+                                      New_Occurrence_Of (Second_Formal, Loc),\n+                                      New_Occurrence_Of (Standard_False, Loc),\n+                                      Make_Raise_Expression (Loc,\n+                                        New_Occurrence_Of (RTE\n+                                          (RE_Assert_Failure), Loc),\n+                                        PF_Expr_Copy)))))));\n+                     end;\n+\n+                  else\n+                     --  Build a conditional expression:\n+                     --   (if <predicate evaluates to True> then True\n+                     --    elsif Is_Membership_Test then False\n+                     --    else (raise Assertion_Error with PF text))\n+\n+                     Result_Expr :=\n+                       Make_If_Expression (Loc,\n+                         Expressions => New_List (\n+                           Result_Expr,\n+                           New_Occurrence_Of (Standard_True, Loc),\n+                           Make_If_Expression (Loc,\n+                             Is_Elsif => True,\n+                             Expressions => New_List (\n+                               New_Occurrence_Of (Second_Formal, Loc),\n+                               New_Occurrence_Of (Standard_False, Loc),\n+                               Make_Raise_Expression (Loc,\n+                                 New_Occurrence_Of (RTE\n+                                   (RE_Assert_Failure), Loc),\n+                                 PF_Expr_Copy)))));\n+                  end if;\n+               end if;\n+\n+               FBody :=\n+                 Make_Subprogram_Body (Loc,\n+                   Specification              => Spec,\n+                   Declarations               => Empty_List,\n+                   Handled_Statement_Sequence =>\n+                     Make_Handled_Sequence_Of_Statements (Loc,\n+                       Statements => New_List (\n+                         Make_Simple_Return_Statement (Loc,\n+                           Expression => Result_Expr))));\n+            end;\n \n             --  The declaration has been analyzed when created, and placed\n             --  after type declaration. Insert body itself after freeze node,\n@@ -10559,121 +10676,6 @@ package body Sem_Ch13 is\n             end if;\n          end;\n \n-         --  Test for raise expressions present and if so build M version\n-\n-         if Raise_Expression_Present then\n-            declare\n-               SId : constant Entity_Id :=\n-                 Make_Defining_Identifier (Loc,\n-                   Chars => New_External_Name (Chars (Typ), \"PredicateM\"));\n-               --  The entity for the function spec\n-\n-               SIdB : constant Entity_Id :=\n-                 Make_Defining_Identifier (Loc,\n-                   Chars => New_External_Name (Chars (Typ), \"PredicateM\"));\n-               --  The entity for the function body\n-\n-               Spec  : Node_Id;\n-               FBody : Node_Id;\n-               FDecl : Node_Id;\n-               BTemp : Entity_Id;\n-\n-               CRec_Typ : Entity_Id;\n-               --  The corresponding record type of Full_Typ\n-\n-               Full_Typ : Entity_Id;\n-               --  The full view of Typ\n-\n-               Priv_Typ : Entity_Id;\n-               --  The partial view of Typ\n-\n-               UFull_Typ : Entity_Id;\n-               --  The underlying full view of Full_Typ\n-\n-            begin\n-               --  Mark any raise expressions for special expansion\n-\n-               Process_REs (Expr_M);\n-\n-               --  Build function declaration\n-\n-               Mutate_Ekind (SId, E_Function);\n-               Set_Is_Predicate_Function_M (SId);\n-               Set_Predicate_Function_M (Typ, SId);\n-\n-               --  Obtain all views of the input type\n-\n-               Get_Views (Typ, Priv_Typ, Full_Typ, UFull_Typ, CRec_Typ);\n-\n-               --  Associate the predicate function with all views\n-\n-               Propagate_Predicate_Attributes (Priv_Typ,  From_Typ => Typ);\n-               Propagate_Predicate_Attributes (Full_Typ,  From_Typ => Typ);\n-               Propagate_Predicate_Attributes (UFull_Typ, From_Typ => Typ);\n-               Propagate_Predicate_Attributes (CRec_Typ,  From_Typ => Typ);\n-\n-               Spec :=\n-                 Make_Function_Specification (Loc,\n-                   Defining_Unit_Name       => SId,\n-                   Parameter_Specifications => New_List (\n-                     Make_Parameter_Specification (Loc,\n-                       Defining_Identifier => Object_Entity_M,\n-                       Parameter_Type      => New_Occurrence_Of (Typ, Loc))),\n-                   Result_Definition        =>\n-                     New_Occurrence_Of (Standard_Boolean, Loc));\n-\n-               FDecl :=\n-                 Make_Subprogram_Declaration (Loc,\n-                   Specification => Spec);\n-\n-               --  Build function body\n-\n-               Spec :=\n-                 Make_Function_Specification (Loc,\n-                   Defining_Unit_Name       => SIdB,\n-                   Parameter_Specifications => New_List (\n-                     Make_Parameter_Specification (Loc,\n-                       Defining_Identifier =>\n-                         Make_Defining_Identifier (Loc, Object_Name),\n-                       Parameter_Type =>\n-                         New_Occurrence_Of (Typ, Loc))),\n-                   Result_Definition        =>\n-                     New_Occurrence_Of (Standard_Boolean, Loc));\n-\n-               --  Build the body, we declare the boolean expression before\n-               --  doing the return, because we are not really confident of\n-               --  what happens if a return appears within a return.\n-\n-               BTemp :=\n-                 Make_Temporary (Loc, 'B');\n-\n-               FBody :=\n-                 Make_Subprogram_Body (Loc,\n-                   Specification              => Spec,\n-\n-                   Declarations               => New_List (\n-                     Make_Object_Declaration (Loc,\n-                       Defining_Identifier => BTemp,\n-                       Constant_Present    => True,\n-                         Object_Definition =>\n-                           New_Occurrence_Of (Standard_Boolean, Loc),\n-                         Expression        => Expr_M)),\n-\n-                   Handled_Statement_Sequence =>\n-                     Make_Handled_Sequence_Of_Statements (Loc,\n-                       Statements => New_List (\n-                         Make_Simple_Return_Statement (Loc,\n-                           Expression => New_Occurrence_Of (BTemp, Loc)))));\n-\n-               --  Insert declaration before freeze node and body after\n-\n-               Insert_Before_And_Analyze (N, FDecl);\n-               Insert_After_And_Analyze  (N, FBody);\n-\n-               --  Should quantified expressions be handled here as well ???\n-            end;\n-         end if;\n-\n          --  See if we have a static predicate. Note that the answer may be\n          --  yes even if we have an explicit Dynamic_Predicate present.\n \n@@ -10766,7 +10768,7 @@ package body Sem_Ch13 is\n       end if;\n \n       Restore_Ghost_Region (Saved_GM, Saved_IGR);\n-   end Build_Predicate_Functions;\n+   end Build_Predicate_Function;\n \n    ------------------------------------------\n    -- Build_Predicate_Function_Declaration --\n@@ -10835,15 +10837,28 @@ package body Sem_Ch13 is\n       Propagate_Predicate_Attributes (UFull_Typ, From_Typ => Typ);\n       Propagate_Predicate_Attributes (CRec_Typ,  From_Typ => Typ);\n \n-      Spec :=\n-        Make_Function_Specification (Loc,\n-          Defining_Unit_Name       => Func_Id,\n-          Parameter_Specifications => New_List (\n-            Make_Parameter_Specification (Loc,\n-              Defining_Identifier => Make_Temporary (Loc, 'I'),\n-              Parameter_Type      => New_Occurrence_Of (Typ, Loc))),\n-          Result_Definition        =>\n-            New_Occurrence_Of (Standard_Boolean, Loc));\n+      declare\n+         Param_Specs : constant List_Id := New_List (\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier => Make_Temporary (Loc, 'I'),\n+             Parameter_Type      => New_Occurrence_Of (Typ, Loc)));\n+      begin\n+         if Predicate_Function_Needs_Membership_Parameter (Typ) then\n+            --  Add Boolean-valued For_Membership_Test param\n+            Append (Make_Parameter_Specification (Loc,\n+                      Defining_Identifier => Make_Temporary (Loc, 'M'),\n+                      Parameter_Type      =>\n+                        New_Occurrence_Of (Standard_Boolean, Loc)),\n+                    Param_Specs);\n+         end if;\n+\n+         Spec :=\n+           Make_Function_Specification (Loc,\n+             Defining_Unit_Name       => Func_Id,\n+             Parameter_Specifications => Param_Specs,\n+             Result_Definition        =>\n+               New_Occurrence_Of (Standard_Boolean, Loc));\n+      end;\n \n       Func_Decl := Make_Subprogram_Declaration (Loc, Specification => Spec);\n \n@@ -13107,7 +13122,7 @@ package body Sem_Ch13 is\n             end if;\n          end;\n \n-         Build_Predicate_Functions (E, N);\n+         Build_Predicate_Function (E, N);\n       end if;\n \n       --  If type has delayed aspects, this is where we do the preanalysis at"}, {"sha": "0a809154296ff76666334f4b8526f2943c6ca18e", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 75, "deletions": 13, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff", "patch": "@@ -16892,14 +16892,23 @@ package body Sem_Util is\n \n             elsif Nkind (P) = N_Aspect_Specification\n               and then Nkind (Parent (P)) = N_Subtype_Declaration\n+              and then Underlying_Type (Defining_Identifier (Parent (P))) =\n+                       Underlying_Type (Typ)\n             then\n                return True;\n \n             elsif Nkind (P) = N_Pragma\n               and then Get_Pragma_Id (P) in Pragma_Predicate\n                                           | Pragma_Predicate_Failure\n             then\n-               return True;\n+               declare\n+                  Arg : constant Entity_Id :=\n+                    Entity (Expression (Get_Argument (P)));\n+               begin\n+                  if Underlying_Type (Arg) = Underlying_Type (Typ) then\n+                     return True;\n+                  end if;\n+               end;\n             end if;\n \n             P := Parent (P);\n@@ -16933,7 +16942,6 @@ package body Sem_Util is\n            and then Ekind (Scope (Entity (N))) in E_Function | E_Procedure\n            and then\n              (Is_Predicate_Function (Scope (Entity (N)))\n-               or else Is_Predicate_Function_M (Scope (Entity (N)))\n                or else Is_Invariant_Procedure (Scope (Entity (N)))\n                or else Is_Partial_Invariant_Procedure (Scope (Entity (N)))\n                or else Is_DIC_Procedure (Scope (Entity (N))));\n@@ -26539,6 +26547,69 @@ package body Sem_Util is\n         and then not Predicate_Checks_Suppressed (Empty);\n    end Predicate_Enabled;\n \n+   ----------------------------------\n+   -- Predicate_Failure_Expression --\n+   ----------------------------------\n+\n+   function Predicate_Failure_Expression\n+    (Typ : Entity_Id; Inherited_OK : Boolean) return Node_Id\n+   is\n+      PF_Aspect : constant Node_Id :=\n+        Find_Aspect (Typ, Aspect_Predicate_Failure);\n+   begin\n+      --  Check for Predicate_Failure aspect specification via an\n+      --  aspect_specification (as opposed to via a pragma).\n+\n+      if Present (PF_Aspect) then\n+         if Inherited_OK or else Entity (PF_Aspect) = Typ then\n+            return Expression (PF_Aspect);\n+         else\n+            return Empty;\n+         end if;\n+      end if;\n+\n+      --  Check for Predicate_Failure aspect specification via a pragma.\n+\n+      declare\n+         Rep_Item : Node_Id := First_Rep_Item (Typ);\n+      begin\n+         while Present (Rep_Item) loop\n+            if Nkind (Rep_Item) = N_Pragma\n+               and then Get_Pragma_Id (Rep_Item) = Pragma_Predicate_Failure\n+            then\n+               declare\n+                  Arg1 : constant Node_Id :=\n+                    Get_Pragma_Arg\n+                      (First (Pragma_Argument_Associations (Rep_Item)));\n+                  Arg2 : constant Node_Id :=\n+                    Get_Pragma_Arg\n+                      (Next (First (Pragma_Argument_Associations (Rep_Item))));\n+               begin\n+                  if Inherited_OK or else\n+                     (Nkind (Arg1) in N_Has_Entity\n+                      and then Entity (Arg1) = Typ)\n+                  then\n+                     return Arg2;\n+                  end if;\n+               end;\n+            end if;\n+\n+            Next_Rep_Item (Rep_Item);\n+         end loop;\n+      end;\n+\n+      --  If we are interested in an inherited Predicate_Failure aspect\n+      --  and we have an ancestor to inherit from, then recursively check\n+      --  for that case.\n+\n+      if Inherited_OK and then Present (Nearest_Ancestor (Typ)) then\n+         return Predicate_Failure_Expression (Nearest_Ancestor (Typ),\n+                                              Inherited_OK => True);\n+      end if;\n+\n+      return Empty;\n+   end Predicate_Failure_Expression;\n+\n    ----------------------------------\n    -- Predicate_Tests_On_Arguments --\n    ----------------------------------\n@@ -26574,9 +26645,7 @@ package body Sem_Util is\n       --  would cause infinite recursion.\n \n       elsif Ekind (Subp) = E_Function\n-        and then (Is_Predicate_Function   (Subp)\n-                    or else\n-                  Is_Predicate_Function_M (Subp))\n+        and then Is_Predicate_Function (Subp)\n       then\n          return False;\n \n@@ -27029,9 +27098,7 @@ package body Sem_Util is\n      (Typ      : Entity_Id;\n       From_Typ : Entity_Id)\n    is\n-      Pred_Func   : Entity_Id;\n-      Pred_Func_M : Entity_Id;\n-\n+      Pred_Func : Entity_Id;\n    begin\n       if Present (Typ) and then Present (From_Typ) then\n          pragma Assert (Is_Type (Typ) and then Is_Type (From_Typ));\n@@ -27044,7 +27111,6 @@ package body Sem_Util is\n          end if;\n \n          Pred_Func   := Predicate_Function (From_Typ);\n-         Pred_Func_M := Predicate_Function_M (From_Typ);\n \n          --  The setting of the attributes is intentionally conservative. This\n          --  prevents accidental clobbering of enabled attributes.\n@@ -27056,10 +27122,6 @@ package body Sem_Util is\n          if Present (Pred_Func) and then No (Predicate_Function (Typ)) then\n             Set_Predicate_Function (Typ, Pred_Func);\n          end if;\n-\n-         if Present (Pred_Func_M) and then No (Predicate_Function_M (Typ)) then\n-            Set_Predicate_Function_M (Typ, Pred_Func_M);\n-         end if;\n       end if;\n    end Propagate_Predicate_Attributes;\n "}, {"sha": "7038f1188ba657183f5fac1a4c5ecf3e6ec34945", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=55a11c7e345dd06d6975fe8f4dc0e11ecbb581ff", "patch": "@@ -2930,6 +2930,26 @@ package Sem_Util is\n    --  Typ, taking into account Predicates_Ignored and\n    --  Predicate_Checks_Suppressed.\n \n+   function Predicate_Failure_Expression\n+    (Typ : Entity_Id; Inherited_OK : Boolean) return Node_Id;\n+   --  If the given type or subtype is subject to a Predicate_Failure\n+   --  aspect specification, then returns the specified expression.\n+   --  Otherwise, if Inherited_OK is False then returns Empty.\n+   --  Otherwise, if Typ denotes a subtype or a derived type then\n+   --  returns the result of recursing on the ancestor subtype.\n+   --  Otherwise, returns Empty.\n+\n+   function Predicate_Function_Needs_Membership_Parameter (Typ : Entity_Id)\n+     return Boolean is\n+     (Present (Predicate_Failure_Expression (Typ, Inherited_OK => True)));\n+   --  The predicate function for some, but not all, subtypes needs to\n+   --  know whether the predicate is being evaluated as part of a membership\n+   --  test. The predicate function for such a subtype takes an additional\n+   --  boolean to convey this information. This function returns True if this\n+   --  additional parameter is needed. More specifically, this function\n+   --  returns true if the Predicate_Failure aspect is specified for the\n+   --  given subtype or for any of its \"ancestor\" subtypes.\n+\n    function Predicate_Tests_On_Arguments (Subp : Entity_Id) return Boolean;\n    --  Subp is the entity for a subprogram call. This function returns True if\n    --  predicate tests are required for the arguments in this call (this is the"}]}