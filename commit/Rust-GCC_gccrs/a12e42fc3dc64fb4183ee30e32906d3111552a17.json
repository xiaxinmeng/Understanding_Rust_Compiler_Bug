{"sha": "a12e42fc3dc64fb4183ee30e32906d3111552a17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTEyZTQyZmMzZGM2NGZiNDE4M2VlMzBlMzI5MDZkMzExMTU1MmExNw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-05-26T09:03:53Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-05-26T09:03:53Z"}, "message": "tree-vect-loop.c (vect_update_vf_for_slp): Split out from ...\n\n2015-05-26  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-loop.c (vect_update_vf_for_slp): Split out from ...\n\t(vect_analyze_loop_operations): ... here.  Remove slp parameter,\n\tdetect whether we apply SLP.  Remove call to\n\tvect_update_slp_costs_according_to_vf.\n\t(vect_analyze_loop_2): Call vect_update_vf_for_slp and\n\tvect_update_slp_costs_according_to_vf from here.  Dispatch\n\tto vect_slp_analyze_operations to analyze SLP stmts.\n\t* tree-vect-slp.c (vect_slp_analyze_node_operations): Drop\n\tunused bb_vec_info parameter, adjust assert.\n\t(vect_slp_analyze_operations): Pass in the slp instance tree\n\tinstead of bb_vec_info.\n\t(vect_slp_analyze_bb_1): Adjust call to vect_slp_analyze_operations.\n\t* tree-vectorizer.h (vect_slp_analyze_operations): Declare.\n\nFrom-SVN: r223670", "tree": {"sha": "15fa47bc711a4455035b475a8d1776cff5f4faeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15fa47bc711a4455035b475a8d1776cff5f4faeb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a12e42fc3dc64fb4183ee30e32906d3111552a17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a12e42fc3dc64fb4183ee30e32906d3111552a17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a12e42fc3dc64fb4183ee30e32906d3111552a17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a12e42fc3dc64fb4183ee30e32906d3111552a17/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "213999c2337e6a75b1c95da8e86506c5e35b80a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/213999c2337e6a75b1c95da8e86506c5e35b80a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/213999c2337e6a75b1c95da8e86506c5e35b80a6"}], "stats": {"total": 203, "additions": 131, "deletions": 72}, "files": [{"sha": "dab3e07add884be0e6057834126784ff5e4fa0ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a12e42fc3dc64fb4183ee30e32906d3111552a17/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a12e42fc3dc64fb4183ee30e32906d3111552a17/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a12e42fc3dc64fb4183ee30e32906d3111552a17", "patch": "@@ -1,3 +1,19 @@\n+2015-05-26  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-loop.c (vect_update_vf_for_slp): Split out from ...\n+\t(vect_analyze_loop_operations): ... here.  Remove slp parameter,\n+\tdetect whether we apply SLP.  Remove call to\n+\tvect_update_slp_costs_according_to_vf.\n+\t(vect_analyze_loop_2): Call vect_update_vf_for_slp and\n+\tvect_update_slp_costs_according_to_vf from here.  Dispatch\n+\tto vect_slp_analyze_operations to analyze SLP stmts.\n+\t* tree-vect-slp.c (vect_slp_analyze_node_operations): Drop\n+\tunused bb_vec_info parameter, adjust assert.\n+\t(vect_slp_analyze_operations): Pass in the slp instance tree\n+\tinstead of bb_vec_info.\n+\t(vect_slp_analyze_bb_1): Adjust call to vect_slp_analyze_operations.\n+\t* tree-vectorizer.h (vect_slp_analyze_operations): Declare.\n+\n 2015-05-25  Alexander Monakov  <amonakov@ispras.ru>\n \n \t* config/i386/i386.h (enum reg_class): Move CLOBBERED_REGS prior to"}, {"sha": "89202c425ed45308b0f02113ce49b417793c6c0e", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 96, "deletions": 61, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a12e42fc3dc64fb4183ee30e32906d3111552a17/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a12e42fc3dc64fb4183ee30e32906d3111552a17/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=a12e42fc3dc64fb4183ee30e32906d3111552a17", "patch": "@@ -1355,25 +1355,85 @@ vect_analyze_loop_form (struct loop *loop)\n   return loop_vinfo;\n }\n \n+/* Scan the loop stmts and dependent on whether there are any (non-)SLP\n+   statements update the vectorization factor.  */\n+\n+static void\n+vect_update_vf_for_slp (loop_vec_info loop_vinfo)\n+{\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n+  int nbbs = loop->num_nodes;\n+  unsigned int vectorization_factor;\n+  int i;\n+\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"=== vect_update_vf_for_slp ===\\n\");\n+\n+  vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  gcc_assert (vectorization_factor != 0);\n+\n+  /* If all the stmts in the loop can be SLPed, we perform only SLP, and\n+     vectorization factor of the loop is the unrolling factor required by\n+     the SLP instances.  If that unrolling factor is 1, we say, that we\n+     perform pure SLP on loop - cross iteration parallelism is not\n+     exploited.  */\n+  bool only_slp_in_loop = true;\n+  for (i = 0; i < nbbs; i++)\n+    {\n+      basic_block bb = bbs[i];\n+      for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n+\t   gsi_next (&si))\n+\t{\n+\t  gimple stmt = gsi_stmt (si);\n+\t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\t  if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n+\t      && STMT_VINFO_RELATED_STMT (stmt_info))\n+\t    {\n+\t      stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n+\t      stmt_info = vinfo_for_stmt (stmt);\n+\t    }\n+\t  if ((STMT_VINFO_RELEVANT_P (stmt_info)\n+\t       || VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (stmt_info)))\n+\t      && !PURE_SLP_STMT (stmt_info))\n+\t    /* STMT needs both SLP and loop-based vectorization.  */\n+\t    only_slp_in_loop = false;\n+\t}\n+    }\n+\n+  if (only_slp_in_loop)\n+    vectorization_factor = LOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo);\n+  else\n+    vectorization_factor\n+      = least_common_multiple (vectorization_factor,\n+\t\t\t       LOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo));\n+\n+  LOOP_VINFO_VECT_FACTOR (loop_vinfo) = vectorization_factor;\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"Updating vectorization factor to %d\\n\",\n+\t\t     vectorization_factor);\n+}\n \n /* Function vect_analyze_loop_operations.\n \n    Scan the loop stmts and make sure they are all vectorizable.  */\n \n static bool\n-vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n+vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n   int nbbs = loop->num_nodes;\n-  unsigned int vectorization_factor = 0;\n+  unsigned int vectorization_factor;\n   int i;\n   stmt_vec_info stmt_info;\n   bool need_to_vectorize = false;\n   int min_profitable_iters;\n   int min_scalar_loop_bound;\n   unsigned int th;\n-  bool only_slp_in_loop = true, ok;\n+  bool ok;\n   HOST_WIDE_INT max_niter;\n   HOST_WIDE_INT estimated_niter;\n   int min_profitable_estimate;\n@@ -1382,50 +1442,6 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"=== vect_analyze_loop_operations ===\\n\");\n \n-  gcc_assert (LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n-  vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  if (slp)\n-    {\n-      /* If all the stmts in the loop can be SLPed, we perform only SLP, and\n-\t vectorization factor of the loop is the unrolling factor required by\n-\t the SLP instances.  If that unrolling factor is 1, we say, that we\n-\t perform pure SLP on loop - cross iteration parallelism is not\n-\t exploited.  */\n-      for (i = 0; i < nbbs; i++)\n-\t{\n-\t  basic_block bb = bbs[i];\n-\t  for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n-\t       gsi_next (&si))\n-\t    {\n-\t      gimple stmt = gsi_stmt (si);\n-\t      stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-\t      if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n-\t\t  && STMT_VINFO_RELATED_STMT (stmt_info))\n-\t\t{\n-\t\t  stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n-\t\t  stmt_info = vinfo_for_stmt (stmt);\n-\t\t}\n-\t      if ((STMT_VINFO_RELEVANT_P (stmt_info)\n-\t\t   || VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (stmt_info)))\n-\t\t  && !PURE_SLP_STMT (stmt_info))\n-\t\t/* STMT needs both SLP and loop-based vectorization.  */\n-\t\tonly_slp_in_loop = false;\n-\t    }\n-\t}\n-\n-      if (only_slp_in_loop)\n-\tvectorization_factor = LOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo);\n-      else\n-\tvectorization_factor = least_common_multiple (vectorization_factor,\n-\t\t\t\tLOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo));\n-\n-      LOOP_VINFO_VECT_FACTOR (loop_vinfo) = vectorization_factor;\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"Updating vectorization factor to %d\\n\",\n-\t\t\t vectorization_factor);\n-    }\n-\n   for (i = 0; i < nbbs; i++)\n     {\n       basic_block bb = bbs[i];\n@@ -1540,6 +1556,11 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n \t   gsi_next (&si))\n         {\n           gimple stmt = gsi_stmt (si);\n+\t  if (STMT_SLP_TYPE (vinfo_for_stmt (stmt)))\n+\t    {\n+\t      need_to_vectorize = true;\n+\t      continue;\n+\t    }\n \t  if (!gimple_clobber_p (stmt)\n \t      && !vect_analyze_stmt (stmt, &need_to_vectorize, NULL))\n \t    return false;\n@@ -1563,6 +1584,9 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n       return false;\n     }\n \n+  vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  gcc_assert (vectorization_factor != 0);\n+\n   if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo) && dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"vectorization_factor = %d, niters = \"\n@@ -1586,10 +1610,6 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n \n   /* Analyze cost.  Decide if worth while to vectorize.  */\n \n-  /* Once VF is set, SLP costs should be updated since the number of created\n-     vector stmts depends on VF.  */\n-  vect_update_slp_costs_according_to_vf (loop_vinfo);\n-\n   vect_estimate_min_profitable_iters (loop_vinfo, &min_profitable_iters,\n \t\t\t\t      &min_profitable_estimate);\n   LOOP_VINFO_COST_MODEL_MIN_ITERS (loop_vinfo) = min_profitable_iters;\n@@ -1664,7 +1684,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n static bool\n vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n {\n-  bool ok, slp = false;\n+  bool ok;\n   int max_vf = MAX_VECTORIZATION_FACTOR;\n   int min_vf = 2;\n   unsigned int th;\n@@ -1790,19 +1810,34 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   ok = vect_analyze_slp (loop_vinfo, NULL, n_stmts);\n   if (ok)\n     {\n-      /* Decide which possible SLP instances to SLP.  */\n-      slp = vect_make_slp_decision (loop_vinfo);\n-\n-      /* Find stmts that need to be both vectorized and SLPed.  */\n-      vect_detect_hybrid_slp (loop_vinfo);\n+      /* If there are any SLP instances mark them as pure_slp.  */\n+      if (vect_make_slp_decision (loop_vinfo))\n+\t{\n+\t  /* Find stmts that need to be both vectorized and SLPed.  */\n+\t  vect_detect_hybrid_slp (loop_vinfo);\n+\n+\t  /* Update the vectorization factor based on the SLP decision.  */\n+\t  vect_update_vf_for_slp (loop_vinfo);\n+\n+\t  /* Once VF is set, SLP costs should be updated since the number of\n+\t     created vector stmts depends on VF.  */\n+\t  vect_update_slp_costs_according_to_vf (loop_vinfo);\n+\n+\t  /* Analyze operations in the SLP instances.  Note this may\n+\t     remove unsupported SLP instances which makes the above\n+\t     SLP kind detection invalid.  */\n+\t  unsigned old_size = LOOP_VINFO_SLP_INSTANCES (loop_vinfo).length ();\n+\t  vect_slp_analyze_operations (LOOP_VINFO_SLP_INSTANCES (loop_vinfo));\n+\t  if (LOOP_VINFO_SLP_INSTANCES (loop_vinfo).length () != old_size)\n+\t    return false;\n+\t}\n     }\n   else\n     return false;\n \n-  /* Scan all the operations in the loop and make sure they are\n-     vectorizable.  */\n-\n-  ok = vect_analyze_loop_operations (loop_vinfo, slp);\n+  /* Scan all the remaining operations in the loop that are not subject\n+     to SLP and make sure they are vectorizable.  */\n+  ok = vect_analyze_loop_operations (loop_vinfo);\n   if (!ok)\n     {\n       if (dump_enabled_p ())"}, {"sha": "1e680207aedb2f6bede9620ee025e62f35f373ca", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a12e42fc3dc64fb4183ee30e32906d3111552a17/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a12e42fc3dc64fb4183ee30e32906d3111552a17/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=a12e42fc3dc64fb4183ee30e32906d3111552a17", "patch": "@@ -2191,7 +2191,7 @@ destroy_bb_vec_info (bb_vec_info bb_vinfo)\n    the subtree. Return TRUE if the operations are supported.  */\n \n static bool\n-vect_slp_analyze_node_operations (bb_vec_info bb_vinfo, slp_tree node)\n+vect_slp_analyze_node_operations (slp_tree node)\n {\n   bool dummy;\n   int i;\n@@ -2202,17 +2202,17 @@ vect_slp_analyze_node_operations (bb_vec_info bb_vinfo, slp_tree node)\n     return true;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    if (!vect_slp_analyze_node_operations (bb_vinfo, child))\n+    if (!vect_slp_analyze_node_operations (child))\n       return false;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt)\n     {\n       stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n       gcc_assert (stmt_info);\n-      gcc_assert (PURE_SLP_STMT (stmt_info));\n+      gcc_assert (STMT_SLP_TYPE (stmt_info) != loop_vect);\n \n       if (!vect_analyze_stmt (stmt, &dummy, node))\n-        return false;\n+\treturn false;\n     }\n \n   return true;\n@@ -2222,19 +2222,26 @@ vect_slp_analyze_node_operations (bb_vec_info bb_vinfo, slp_tree node)\n /* Analyze statements in SLP instances of the basic block.  Return TRUE if the\n    operations are supported. */\n \n-static bool\n-vect_slp_analyze_operations (bb_vec_info bb_vinfo)\n+bool\n+vect_slp_analyze_operations (vec<slp_instance> slp_instances)\n {\n-  vec<slp_instance> slp_instances = BB_VINFO_SLP_INSTANCES (bb_vinfo);\n   slp_instance instance;\n   int i;\n \n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"=== vect_slp_analyze_operations ===\\n\");\n+\n   for (i = 0; slp_instances.iterate (i, &instance); )\n     {\n-      if (!vect_slp_analyze_node_operations (bb_vinfo,\n-                                             SLP_INSTANCE_TREE (instance)))\n+      if (!vect_slp_analyze_node_operations (SLP_INSTANCE_TREE (instance)))\n         {\n- \t  vect_free_slp_instance (instance);\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"removing SLP instance operations starting from: \");\n+\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM,\n+\t\t\t    SLP_TREE_SCALAR_STMTS\n+\t\t\t      (SLP_INSTANCE_TREE (instance))[0], 0);\n+\t  vect_free_slp_instance (instance);\n           slp_instances.ordered_remove (i);\n \t}\n       else\n@@ -2498,7 +2505,7 @@ vect_slp_analyze_bb_1 (basic_block bb)\n       return NULL;\n     }\n \n-  if (!vect_slp_analyze_operations (bb_vinfo))\n+  if (!vect_slp_analyze_operations (BB_VINFO_SLP_INSTANCES (bb_vinfo)))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,"}, {"sha": "ae795a9f7d59ff8400f27ae6c81b91f1ea560250", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a12e42fc3dc64fb4183ee30e32906d3111552a17/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a12e42fc3dc64fb4183ee30e32906d3111552a17/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=a12e42fc3dc64fb4183ee30e32906d3111552a17", "patch": "@@ -1114,6 +1114,7 @@ extern void vect_free_slp_instance (slp_instance);\n extern bool vect_transform_slp_perm_load (slp_tree, vec<tree> ,\n                                           gimple_stmt_iterator *, int,\n                                           slp_instance, bool);\n+extern bool vect_slp_analyze_operations (vec<slp_instance> slp_instances);\n extern bool vect_schedule_slp (loop_vec_info, bb_vec_info);\n extern void vect_update_slp_costs_according_to_vf (loop_vec_info);\n extern bool vect_analyze_slp (loop_vec_info, bb_vec_info, unsigned);"}]}