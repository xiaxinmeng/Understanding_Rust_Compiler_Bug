{"sha": "8baddbf1080b7696875044c44eaca5a612e22ec8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGJhZGRiZjEwODBiNzY5Njg3NTA0NGM0NGVhY2E1YTYxMmUyMmVjOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-08-18T02:55:14Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-08-18T02:55:14Z"}, "message": "re PR c++/16246 (Incorrect template argument deduction)\n\n\tPR c++/16246\n\t* pt.c (unify): Tidy ARRAY_TYPE handling.  Make sure that non-type\n\targuments have the same type as the corresponding parameter.\n\n\tPR c++/16246\n\t* g++.dg/template/array7.C: New test.\n\nFrom-SVN: r86169", "tree": {"sha": "0472c6e1b231c7c7e30a9a5b938305b716ad2da9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0472c6e1b231c7c7e30a9a5b938305b716ad2da9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8baddbf1080b7696875044c44eaca5a612e22ec8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8baddbf1080b7696875044c44eaca5a612e22ec8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8baddbf1080b7696875044c44eaca5a612e22ec8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8baddbf1080b7696875044c44eaca5a612e22ec8/comments", "author": null, "committer": null, "parents": [{"sha": "07e1528687c09db7d6e1b70a0c908f8679c9615a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07e1528687c09db7d6e1b70a0c908f8679c9615a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07e1528687c09db7d6e1b70a0c908f8679c9615a"}], "stats": {"total": 100, "additions": 50, "deletions": 50}, "files": [{"sha": "1a97ccaeb493409f00b1c7fcb7acb542d1962359", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8baddbf1080b7696875044c44eaca5a612e22ec8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8baddbf1080b7696875044c44eaca5a612e22ec8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8baddbf1080b7696875044c44eaca5a612e22ec8", "patch": "@@ -1,5 +1,9 @@\n 2004-08-17  Mark Mitchell  <mark@codesourcery.com>\n \n+\tPR c++/16246\n+\t* pt.c (unify): Tidy ARRAY_TYPE handling.  Make sure that non-type\n+\targuments have the same type as the corresponding parameter.\n+\n \tPR c++/16215\n \t* parser.c (cp_parser_name_lookup_error): If parser->object_scope\n \tis set use it for diagnostic purposes."}, {"sha": "257f1066bb52abe4b1f522e9a73761945ee7cea2", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 30, "deletions": 50, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8baddbf1080b7696875044c44eaca5a612e22ec8/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8baddbf1080b7696875044c44eaca5a612e22ec8/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8baddbf1080b7696875044c44eaca5a612e22ec8", "patch": "@@ -9641,14 +9641,7 @@ check_cv_quals_for_unify (int strict, tree arg, tree parm)\n        qualified at this point.\n      UNIFY_ALLOW_OUTER_LESS_CV_QUAL:\n        This is the outermost level of a deduction, and PARM can be less CV\n-       qualified at this point.\n-     UNIFY_ALLOW_MAX_CORRECTION:\n-       This is an INTEGER_TYPE's maximum value.  Used if the range may\n-       have been derived from a size specification, such as an array size.\n-       If the size was given by a nontype template parameter N, the maximum\n-       value will have the form N-1.  The flag says that we can (and indeed\n-       must) unify N with (ARG + 1), an exception to the normal rules on\n-       folding PARM.  */\n+       qualified at this point.  */\n \n static int\n unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n@@ -9702,7 +9695,6 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n   strict &= ~UNIFY_ALLOW_DERIVED;\n   strict &= ~UNIFY_ALLOW_OUTER_MORE_CV_QUAL;\n   strict &= ~UNIFY_ALLOW_OUTER_LESS_CV_QUAL;\n-  strict &= ~UNIFY_ALLOW_MAX_CORRECTION;\n   \n   switch (TREE_CODE (parm))\n     {\n@@ -9864,7 +9856,10 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n       else if ((strict & UNIFY_ALLOW_INTEGER)\n \t       && (TREE_CODE (tparm) == INTEGER_TYPE\n \t\t   || TREE_CODE (tparm) == BOOLEAN_TYPE))\n-\t/* OK */;\n+\t/* Convert the ARG to the type of PARM; the deduced non-type\n+\t   template argument must exactly match the types of the\n+\t   corresponding parameter.  */\n+\targ = fold (build_nop (TREE_TYPE (parm), arg));\n       else if (uses_template_parms (tparm))\n \t/* We haven't deduced the type of this parameter yet.  Try again\n \t   later.  */\n@@ -9932,10 +9927,29 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n       if ((TYPE_DOMAIN (parm) == NULL_TREE)\n \t  != (TYPE_DOMAIN (arg) == NULL_TREE))\n \treturn 1;\n-      if (TYPE_DOMAIN (parm) != NULL_TREE\n-\t  && unify (tparms, targs, TYPE_DOMAIN (parm),\n-\t\t    TYPE_DOMAIN (arg), UNIFY_ALLOW_NONE) != 0)\n-\treturn 1;\n+      if (TYPE_DOMAIN (parm) != NULL_TREE)\n+\t{\n+\t  tree parm_max;\n+\t  tree arg_max;\n+\n+\t  parm_max = TYPE_MAX_VALUE (TYPE_DOMAIN (parm));\n+\t  arg_max = TYPE_MAX_VALUE (TYPE_DOMAIN (arg));\n+\n+\t  /* Our representation of array types uses \"N - 1\" as the\n+\t     TYPE_MAX_VALUE for an array with \"N\" elements, if \"N\" is\n+\t     not an integer constant.  */\n+\t  if (TREE_CODE (parm_max) == MINUS_EXPR)\n+\t    {\n+\t      arg_max = fold (build2 (PLUS_EXPR, \n+\t\t\t\t      integer_type_node,\n+\t\t\t\t      arg_max,\n+\t\t\t\t      TREE_OPERAND (parm_max, 1)));\n+\t      parm_max = TREE_OPERAND (parm_max, 0);\n+\t    }\n+\n+\t  if (unify (tparms, targs, parm_max, arg_max, UNIFY_ALLOW_INTEGER))\n+\t    return 1;\n+\t}\n       return unify (tparms, targs, TREE_TYPE (parm), TREE_TYPE (arg),\n \t\t    strict & UNIFY_ALLOW_MORE_CV_QUAL);\n \n@@ -9947,23 +9961,10 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n     case VOID_TYPE:\n       if (TREE_CODE (arg) != TREE_CODE (parm))\n \treturn 1;\n-\n-      if (TREE_CODE (parm) == INTEGER_TYPE\n-\t  && TREE_CODE (TYPE_MAX_VALUE (parm)) != INTEGER_CST)\n-\t{\n-\t  if (TYPE_MIN_VALUE (parm) && TYPE_MIN_VALUE (arg)\n-\t      && unify (tparms, targs, TYPE_MIN_VALUE (parm),\n-\t\t\tTYPE_MIN_VALUE (arg), UNIFY_ALLOW_INTEGER))\n-\t    return 1;\n-\t  if (TYPE_MAX_VALUE (parm) && TYPE_MAX_VALUE (arg)\n-\t      && unify (tparms, targs, TYPE_MAX_VALUE (parm),\n-\t\t\tTYPE_MAX_VALUE (arg),\n-\t\t\tUNIFY_ALLOW_INTEGER | UNIFY_ALLOW_MAX_CORRECTION))\n-\t    return 1;\n-\t}\n+      \n       /* We have already checked cv-qualification at the top of the\n \t function.  */\n-      else if (!same_type_ignoring_top_level_qualifiers_p (arg, parm))\n+      if (!same_type_ignoring_top_level_qualifiers_p (arg, parm))\n \treturn 1;\n \n       /* As far as unification is concerned, this wins.\t Later checks\n@@ -10089,27 +10090,6 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n       /* Matched cases are handled by the ARG == PARM test above.  */\n       return 1;\n \n-    case MINUS_EXPR:\n-      if (tree_int_cst_equal (TREE_OPERAND (parm, 1), integer_one_node)\n-\t  && (strict_in & UNIFY_ALLOW_MAX_CORRECTION))\n-\t{\n-\t  /* We handle this case specially, since it comes up with\n-\t     arrays.  In particular, something like:\n-\n-\t     template <int N> void f(int (&x)[N]);\n-\n-\t     Here, we are trying to unify the range type, which\n-\t     looks like [0 ... (N - 1)].  */\n-\t  tree t, t1, t2;\n-\t  t1 = TREE_OPERAND (parm, 0);\n-\t  t2 = TREE_OPERAND (parm, 1);\n-\n-\t  t = fold (build2 (PLUS_EXPR, integer_type_node, arg, t2));\n-\n-\t  return unify (tparms, targs, t1, t, strict);\n-\t}\n-      /* Else fall through.  */\n-\n     default:\n       if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (parm))))\n \t{"}, {"sha": "d01f412ebdc1a6632c7aec1b6e283c66912f1b7c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8baddbf1080b7696875044c44eaca5a612e22ec8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8baddbf1080b7696875044c44eaca5a612e22ec8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8baddbf1080b7696875044c44eaca5a612e22ec8", "patch": "@@ -1,3 +1,8 @@\n+2004-08-17  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/16246\n+\t* g++.dg/template/array7.C: New test.\n+\n 2004-08-17  James E Wilson  <wilson@specifixinc.com>\n \n \t* gcc.dg/mips-movcc-1.c: New test."}, {"sha": "1fb130f9961675183601a53f820c2c0e5bd03a0d", "filename": "gcc/testsuite/g++.dg/template/array7.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8baddbf1080b7696875044c44eaca5a612e22ec8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8baddbf1080b7696875044c44eaca5a612e22ec8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray7.C?ref=8baddbf1080b7696875044c44eaca5a612e22ec8", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/16246\n+\n+template <typename T> void foo (T, T); \n+ \n+template <unsigned N, unsigned M>  \n+int bar( const char(&val)[M] ) \n+{ \n+  foo (N,M); \n+} \n+ \n+int i = bar<10>(\"1234\"); "}]}