{"sha": "8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk5M2MxMmJlZTg3YTJmZGFhNWY2YTEyODZiZDQzZTQ5ZjIwNjliMw==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-06-19T10:48:46Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-06-19T10:48:46Z"}, "message": "Font.java [...]: New versions from classpath.\n\n2003-06-19  Michael Koch  <konqueror@gmx.de>\n\n\t* java/awt/Font.java\n\tjavax/swing/UIManager.java\n\tjavax/swing/border/AbstractBorder.java\n\tjavax/swing/border/BevelBorder.java\n\tjavax/swing/border/Border.java\n\tjavax/swing/border/CompoundBorder.java\n\tjavax/swing/border/EmptyBorder.java\n\tjavax/swing/border/EtchedBorder.java\n\tjavax/swing/border/LineBorder.java\n\tjavax/swing/border/MatteBorder.java\n\tjavax/swing/border/TitledBorder.java\n\tjavax/swing/plaf/BorderUIResource.java\n\tjavax/swing/plaf/basic/BasicBorders.java\n\tjavax/swing/plaf/basic/BasicButtonUI.java\n\tjavax/swing/plaf/basic/BasicCheckBoxUI.java\n\tjavax/swing/plaf/basic/BasicGraphicsUtils.java\n\tjavax/swing/plaf/basic/BasicLabelUI.java\n\tjavax/swing/plaf/basic/BasicRadioButtonUI.java\n\tjavax/swing/plaf/basic/BasicToggleButtonUI.java:\n\tNew versions from classpath.\n\t* javax/swing/border/SoftBevelBorder.java:\n\tNew file from classpath.\n\t* javax/swing/border/doc-files/LineBorder-1.png,\n\tjavax/swing/border/doc-files/BevelBorder-1.png,\n\tjavax/swing/border/doc-files/BevelBorder-2.png,\n\tjavax/swing/border/doc-files/BevelBorder-3.png,\n\tjavax/swing/border/doc-files/EmptyBorder-1.png,\n\tjavax/swing/border/doc-files/EtchedBorder-1.png,\n\tjavax/swing/border/doc-files/EtchedBorder-2.png,\n\tjavax/swing/border/doc-files/MatteBorder-1.png,\n\tjavax/swing/border/doc-files/MatteBorder-2.png,\n\tjavax/swing/border/doc-files/MatteBorder-3.png,\n\tjavax/swing/border/doc-files/MatteBorder-4.png,\n\tjavax/swing/border/doc-files/MatteBorder-5.png,\n\tjavax/swing/border/doc-files/MatteBorder-6.png,\n\tjavax/swing/border/doc-files/SoftBevelBorder-1.png,\n\tjavax/swing/border/doc-files/SoftBevelBorder-2.png,\n\tjavax/swing/border/doc-files/SoftBevelBorder-3.png,\n\tjavax/swing/plaf/basic/doc-files/BasicBorders.MarginBorder-1.png,\n\tjavax/swing/plaf/basic/doc-files/BasicBorders.ButtonBorder-1.png,\n\tjavax/swing/plaf/basic/doc-files/BasicGraphicsUtils-1.png,\n\tjavax/swing/plaf/basic/doc-files/BasicGraphicsUtils-2.png,\n\tjavax/swing/plaf/basic/doc-files/BasicGraphicsUtils-3.png,\n\tjavax/swing/plaf/basic/doc-files/BasicGraphicsUtils-4.png,\n\tjavax/swing/plaf/basic/doc-files/BasicGraphicsUtils-5.png,\n\tjavax/swing/plaf/basic/doc-files/BasicGraphicsUtils-6.png,\n\tjavax/swing/plaf/basic/doc-files/BasicGraphicsUtils-7.png:\n\tNew binary files from classpath.\n\t* Makefile.am\n\t(awt_java_source_files): Added\n\tjavax/swing/border/SoftBevelBorder.java.\n\t* Makefile.in: Regenerated.\n\nFrom-SVN: r68190", "tree": {"sha": "d5c6c6a92288550d2a139924d3ee3fcbe912bd20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5c6c6a92288550d2a139924d3ee3fcbe912bd20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/comments", "author": null, "committer": null, "parents": [{"sha": "1681bed6c83fc8911dc6790c5f043a47db2b8939", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1681bed6c83fc8911dc6790c5f043a47db2b8939", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1681bed6c83fc8911dc6790c5f043a47db2b8939"}], "stats": {"total": 5406, "additions": 4941, "deletions": 465}, "files": [{"sha": "67e842e6f362d47697a15f8fea108a35e02d8872", "filename": "libjava/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "patch": "@@ -1,3 +1,58 @@\n+2003-06-19  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/awt/Font.java\n+\tjavax/swing/UIManager.java\n+\tjavax/swing/border/AbstractBorder.java\n+\tjavax/swing/border/BevelBorder.java\n+\tjavax/swing/border/Border.java\n+\tjavax/swing/border/CompoundBorder.java\n+\tjavax/swing/border/EmptyBorder.java\n+\tjavax/swing/border/EtchedBorder.java\n+\tjavax/swing/border/LineBorder.java\n+\tjavax/swing/border/MatteBorder.java\n+\tjavax/swing/border/TitledBorder.java\n+\tjavax/swing/plaf/BorderUIResource.java\n+\tjavax/swing/plaf/basic/BasicBorders.java\n+\tjavax/swing/plaf/basic/BasicButtonUI.java\n+\tjavax/swing/plaf/basic/BasicCheckBoxUI.java\n+\tjavax/swing/plaf/basic/BasicGraphicsUtils.java\n+\tjavax/swing/plaf/basic/BasicLabelUI.java\n+\tjavax/swing/plaf/basic/BasicRadioButtonUI.java\n+\tjavax/swing/plaf/basic/BasicToggleButtonUI.java:\n+\tNew versions from classpath.\n+\t* javax/swing/border/SoftBevelBorder.java:\n+\tNew file from classpath.\n+\t* javax/swing/border/doc-files/LineBorder-1.png,\n+\tjavax/swing/border/doc-files/BevelBorder-1.png,\n+\tjavax/swing/border/doc-files/BevelBorder-2.png,\n+\tjavax/swing/border/doc-files/BevelBorder-3.png,\n+\tjavax/swing/border/doc-files/EmptyBorder-1.png,\n+\tjavax/swing/border/doc-files/EtchedBorder-1.png,\n+\tjavax/swing/border/doc-files/EtchedBorder-2.png,\n+\tjavax/swing/border/doc-files/MatteBorder-1.png,\n+\tjavax/swing/border/doc-files/MatteBorder-2.png,\n+\tjavax/swing/border/doc-files/MatteBorder-3.png,\n+\tjavax/swing/border/doc-files/MatteBorder-4.png,\n+\tjavax/swing/border/doc-files/MatteBorder-5.png,\n+\tjavax/swing/border/doc-files/MatteBorder-6.png,\n+\tjavax/swing/border/doc-files/SoftBevelBorder-1.png,\n+\tjavax/swing/border/doc-files/SoftBevelBorder-2.png,\n+\tjavax/swing/border/doc-files/SoftBevelBorder-3.png,\n+\tjavax/swing/plaf/basic/doc-files/BasicBorders.MarginBorder-1.png,\n+\tjavax/swing/plaf/basic/doc-files/BasicBorders.ButtonBorder-1.png,\n+\tjavax/swing/plaf/basic/doc-files/BasicGraphicsUtils-1.png,\n+\tjavax/swing/plaf/basic/doc-files/BasicGraphicsUtils-2.png,\n+\tjavax/swing/plaf/basic/doc-files/BasicGraphicsUtils-3.png,\n+\tjavax/swing/plaf/basic/doc-files/BasicGraphicsUtils-4.png,\n+\tjavax/swing/plaf/basic/doc-files/BasicGraphicsUtils-5.png,\n+\tjavax/swing/plaf/basic/doc-files/BasicGraphicsUtils-6.png,\n+\tjavax/swing/plaf/basic/doc-files/BasicGraphicsUtils-7.png:\n+\tNew binary files from classpath.\n+\t* Makefile.am\n+\t(awt_java_source_files): Added\n+\tjavax/swing/border/SoftBevelBorder.java.\n+\t* Makefile.in: Regenerated.\n+\n 2003-06-19  Michael Koch  <konqueror@gmx.de>\n \n \t* gnu/java/security/x509/X509Certificate.java"}, {"sha": "b50f19cba7712de9dc576e0144973844db1a5e80", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "patch": "@@ -1151,6 +1151,7 @@ javax/swing/border/EmptyBorder.java \\\n javax/swing/border/EtchedBorder.java \\\n javax/swing/border/LineBorder.java \\\n javax/swing/border/MatteBorder.java \\\n+javax/swing/border/SoftBevelBorder.java \\\n javax/swing/border/TitledBorder.java \\\n javax/swing/GrayFilter.java \\\n javax/swing/AbstractAction.java \\"}, {"sha": "b456bb4588ffccf753740df5081dfbe6eb25fbc9", "filename": "libjava/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "patch": "@@ -920,6 +920,7 @@ javax/swing/border/EmptyBorder.java \\\n javax/swing/border/EtchedBorder.java \\\n javax/swing/border/LineBorder.java \\\n javax/swing/border/MatteBorder.java \\\n+javax/swing/border/SoftBevelBorder.java \\\n javax/swing/border/TitledBorder.java \\\n javax/swing/GrayFilter.java \\\n javax/swing/AbstractAction.java \\\n@@ -4016,6 +4017,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/javax/swing/border/EtchedBorder.P \\\n .deps/javax/swing/border/LineBorder.P \\\n .deps/javax/swing/border/MatteBorder.P \\\n+.deps/javax/swing/border/SoftBevelBorder.P \\\n .deps/javax/swing/border/TitledBorder.P \\\n .deps/javax/swing/colorchooser/AbstractColorChooserPanel.P \\\n .deps/javax/swing/colorchooser/ColorChooserComponentFactory.P \\"}, {"sha": "b762a75dc31bef6bc074faeaa44b13c0a32a1a9c", "filename": "libjava/java/awt/Font.java", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjava%2Fawt%2FFont.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjava%2Fawt%2FFont.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FFont.java?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "patch": "@@ -39,6 +39,8 @@\n package java.awt;\n \n import java.awt.peer.FontPeer;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.LineMetrics;\n import java.io.Serializable;\n import java.util.StringTokenizer;\n \n@@ -484,5 +486,28 @@ public class Font implements Serializable\n          \",size=\" + size + \")\");\n }\n \n+\n+  /**\n+   * Determines the line metrics for a run of text.\n+   *\n+   * @param str the text run to be measured.\n+   *\n+   * @param frc the font rendering parameters that are used for the\n+   *        measurement. The exact placement and size of text slightly\n+   *        depends on device-specific characteristics, for instance\n+   *        the device resolution or anti-aliasing.  For this reason,\n+   *        the returned measurement will only be accurate if the\n+   *        passed <code>FontRenderContext</code> correctly reflects\n+   *        the relevant parameters. Hence, <code>frc</code> should be\n+   *        obtained from the same <code>Graphics2D</code> that will\n+   *        be used for drawing, and any rendering hints should be set\n+   *        to the desired values before obtaining <code>frc</code>.\n+   *\n+   * @see java.awt.Graphics2D#getFontRenderContext()\n+   */\n+  public LineMetrics getLineMetrics(String str, FontRenderContext frc)\n+  {\n+    throw new UnsupportedOperationException(); // FIXME\n+  }\n } // class Font \n "}, {"sha": "556e8fffdf7c5273d775fd9cad5bf4662db9efd6", "filename": "libjava/javax/swing/UIManager.java", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2FUIManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2FUIManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FUIManager.java?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "patch": "@@ -174,11 +174,21 @@ static  Dimension getDimension(Object key)\n \tSystem.out.println(\"UIManager.getDim\");\n \treturn new Dimension(200,100);\n     }\n-    static  Font getFont(Object key)\n-    //      Returns a drawing font from the defaults table. \n-    {\n-\treturn (Font) getLookAndFeel().getDefaults().get(key);\n-    }\n+\n+\n+  /**\n+   * Retrieves a font from the defaults table of the current\n+   * LookAndFeel.\n+   *\n+   * @param key an Object that specifies the font. Typically,\n+   *        this is a String such as\n+   *        <code>&quot;TitledBorder.font&quot;</code>.\n+   */\n+  public static Font getFont(Object key)\n+  {\n+    return (Font) getLookAndFeel().getDefaults().get(key);\n+  }\n+\n     static  Icon getIcon(Object key)\n     //      Returns an Icon from the defaults table. \n     {\n@@ -207,11 +217,17 @@ static  LookAndFeel getLookAndFeel()\n \treturn look_and_feel;\n     }\n \n-    static  UIDefaults getLookAndFeelDefaults()\n-    //      Returns the default values for this look and feel. \n-    {\n-\treturn getLookAndFeel().getDefaults();\n-    }\n+\n+  /**\n+   * Returns the <code>UIDefaults</code> table of the currently active\n+   * look and feel.\n+   */\n+  public static UIDefaults getLookAndFeelDefaults()\n+  {\n+    return getLookAndFeel().getDefaults();\n+  }\n+\n+\n     static  String getString(Object key)\n     //      Returns a string from the defaults table. \n     {"}, {"sha": "9c1f06be7d1d9c2053b0467e06c485b2c6e1fdbc", "filename": "libjava/javax/swing/border/AbstractBorder.java", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2FAbstractBorder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2FAbstractBorder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2FAbstractBorder.java?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "patch": "@@ -91,15 +91,16 @@ public void paintBorder (Component c, Graphics g,\n \n \n   /**\n-   * Determines the insets of this border. The implementation provided\n-   * by AbstractButton returns Insets for a zero-width border, whose\n-   * <code>left</code>, <code>right</code>, <code>top</code> and\n-   * <code>bottom</code> fields are all zero.\n+   * Measures the width of this border.\n    *\n    * @param c the component whose border is to be measured.\n    *\n-   * @return a newly created Insets object, indicating a zero-width\n-   *         border.\n+   * @return an Insets object whose <code>left</code>, <code>right</code>,\n+   *         <code>top</code> and <code>bottom</code> fields indicate the\n+   *         width of the border at the respective edge, which is zero\n+   *         for the default implementation provided by AbstractButton.\n+   *\n+   * @see #getBorderInsets(java.awt.Component, java.awt.Insets)\n    */\n   public Insets getBorderInsets (Component c)\n   {\n@@ -113,12 +114,11 @@ public Insets getBorderInsets (Component c)\n    * <code>top</code> and <code>bottom</code> fields of the passed\n    * <code>insets</code> parameter to zero.\n    *\n-   * @param c the component in the center of this border.\n+   * @param c the component whose border is to be measured.\n    *\n-   * @param insets an Insets object for holding the insets of this\n-   *        border.\n+   * @return the same object that was passed for <code>insets</code>.\n    *\n-   * @return the <code>insets</code> object.\n+   * @see #getBorderInsets()\n    */\n   public Insets getBorderInsets (Component c, Insets insets) \n   {"}, {"sha": "87bf04a0c618c98d9e10e8850f7d95850428da7c", "filename": "libjava/javax/swing/border/BevelBorder.java", "status": "modified", "additions": 498, "deletions": 20, "changes": 518, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2FBevelBorder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2FBevelBorder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2FBevelBorder.java?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "patch": "@@ -1,5 +1,5 @@\n /* BevelBorder.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -40,51 +40,529 @@\n import java.awt.Color;\n import java.awt.Component;\n import java.awt.Graphics;\n+import java.awt.Insets;\n \n-public class BevelBorder extends AbstractBorder\n+\n+/**\n+ * A rectangular, two pixel thick border that causes the enclosed area\n+ * to appear as if it was raising out of or lowered into the screen. Some\n+ * LookAndFeels use this kind of border for rectangular buttons.\n+ *\n+ * <p>A BevelBorder has a highlight and a shadow color. In the raised\n+ * variant, the highlight color is used for the top and left edges,\n+ * and the shadow color is used for the bottom and right edge. For an\n+ * image, see the documentation of the individual constructors.\n+ *\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n+ */\n+public class BevelBorder\n+  extends AbstractBorder\n {\n-  public static final int LOWERED = 1;\n+  /**\n+   * Determined using the <code>serialver</code> tool\n+   * of Apple/Sun JDK 1.3.1 on MacOS X 10.1.5.\n+   */\n+  static final long serialVersionUID = -1034942243356299676L;\n+\n+\n+  /**\n+   * Indicates that the BevelBorder looks like if the enclosed area was\n+   * raising out of the screen.\n+   */\n   public static final int RAISED = 0;\n-    \n+\n+\n+  /**\n+   * Indicates that the BevelBorder looks like if the enclosed area was\n+   * pressed into the screen.\n+   */\n+  public static final int LOWERED = 1;\n+  \n+\n+  /**\n+   * The type of this BevelBorder, which is either {@link #RAISED}\n+   * or {@link #LOWERED}.\n+   */  \n   protected int bevelType;\n+\n+\n+  /**\n+   * The outer highlight color, or <code>null</code> to indicate that\n+   * the color shall be derived from the background of the component\n+   * whose border is being painted.\n+   */\n   protected Color highlightOuter;\n+\n+\n+  /**\n+   * The inner highlight color, or <code>null</code> to indicate that\n+   * the color shall be derived from the background of the component\n+   * whose border is being painted.\n+   */\n   protected Color highlightInner;\n+\n+\n+  /**\n+   * The outer shadow color, or <code>null</code> to indicate that the\n+   * color shall be derived from the background of the component whose\n+   * border is being painted.\n+   */\n   protected Color shadowOuter;\n+\n+\n+  /**\n+   * The inner shadow color, or <code>null</code> to indicate that the\n+   * color shall be derived from the background of the component whose\n+   * border is being painted.\n+   */\n   protected Color shadowInner;\n \n-  public BevelBorder (int bevelType)\n+\n+  /**\n+   * Constructs a BevelBorder whose colors will be derived from the\n+   * background of the enclosed component. The background color is\n+   * retrieved each time the border is painted, so a BevelBorder\n+   * constructed by this method will automatically reflect a change\n+   * to the component&#x2019;s background color.\n+   *\n+   * <p><img src=\"BevelBorder-1.png\" width=\"500\" height=\"150\"\n+   * alt=\"[An illustration showing raised and lowered BevelBorders]\" />\n+   *\n+   * @param bevelType the desired appearance of the border. The value\n+   *        must be either {@link #RAISED} or {@link #LOWERED}.\n+   *\n+   * @throws IllegalArgumentException if <code>bevelType</code> has\n+   *         an unsupported value.\n+   */\n+  public BevelBorder(int bevelType)\n   {\n-    this (bevelType, null, null, null, null);\n+    if ((bevelType != RAISED) && (bevelType != LOWERED))\n+      throw new IllegalArgumentException();\n+\n+    this.bevelType = bevelType;\n   }\n \n+\n+  /**\n+   * Constructs a BevelBorder given its appearance type and two colors\n+   * for its highlight and shadow.\n+   *\n+   * <p><img src=\"BevelBorder-2.png\" width=\"500\" height=\"150\"\n+   * alt=\"[An illustration showing BevelBorders that were constructed\n+   * with this method]\" />\n+   *\n+   * @param bevelType the desired appearance of the border. The value\n+   *        must be either {@link #RAISED} or {@link #LOWERED}.\n+   *\n+   * @param highlight the color that will be used for the inner\n+   *        side of the highlighted edges (top and left if\n+   *        if <code>bevelType</code> is {@link #RAISED}; bottom\n+   *        and right otherwise). The color for the outer side\n+   *        is a brightened version of this color.\n+   *\n+   * @param shadow the color that will be used for the outer\n+   *        side of the shadowed edges (bottom and right\n+   *        if <code>bevelType</code> is {@link #RAISED}; top\n+   *        and left otherwise). The color for the inner side\n+   *        is a brightened version of this color.\n+   *\n+   * @throws IllegalArgumentException if <code>bevelType</code> has\n+   *         an unsupported value.\n+   *\n+   * @throws NullPointerException if <code>highlight</code> or\n+   *         <code>shadow</code> is <code>null</code>.\n+   *\n+   * @see java.awt.Color.brighter()\n+   */\n   public BevelBorder(int bevelType, Color highlight, Color shadow)\n   {\n-    this (bevelType, highlight, highlight, shadow, shadow);\n+    this(bevelType,\n+         /* highlightOuter */ highlight.brighter(),\n+         /* highlightInner */ highlight,\n+         /* shadowOuter */    shadow,\n+         /* shadowInner */    shadow.brighter());\n   }\n \n-  public BevelBorder (int bevelType, Color highlightOuter,\n-                      Color highlightInner, Color shadowOuter,\n-                      Color shadowInner)\n+\n+  /**\n+   * Constructs a BevelBorder given its appearance type and all\n+   * colors.\n+   *\n+   * <p><img src=\"BevelBorder-3.png\" width=\"500\" height=\"150\"\n+   * alt=\"[An illustration showing BevelBorders that were constructed\n+   * with this method]\" />\n+   *\n+   * @param bevelType the desired appearance of the border. The value\n+   *        must be either {@link #RAISED} or {@link #LOWERED}.\n+   *\n+   * @param highlightOuter the color that will be used for the outer\n+   *        side of the highlighted edges (top and left if\n+   *        <code>bevelType</code> is {@link #RAISED}; bottom and\n+   *        right otherwise).\n+   *\n+   * @param highlightInner the color that will be used for the inner\n+   *        side of the highlighted edges.\n+   *\n+   * @param shadowOuter the color that will be used for the outer\n+   *        side of the shadowed edges (bottom and right\n+   *        if <code>bevelType</code> is {@link #RAISED}; top\n+   *        and left otherwise).\n+   *\n+   * @param shadowInner the color that will be used for the inner\n+   *        side of the shadowed edges.\n+   *\n+   * @throws IllegalArgumentException if <code>bevelType</code> has\n+   *         an unsupported value.\n+   *\n+   * @throws NullPointerException if one of the passed colors\n+   *         is <code>null</code>.\n+   */\n+  public BevelBorder(int bevelType,\n+                     Color highlightOuter, Color highlightInner,\n+                     Color shadowOuter, Color shadowInner)\n   {\n-    this.bevelType = bevelType;\n+    this(bevelType); // checks the validity of bevelType\n+\n+    if ((highlightOuter == null) || (highlightInner == null)\n+        || (shadowOuter == null) || (shadowInner == null))\n+      throw new NullPointerException();\n+\n     this.highlightOuter = highlightOuter;\n     this.highlightInner = highlightInner;\n     this.shadowOuter = shadowOuter;\n     this.shadowInner = shadowInner;\n   }\n \n-    public boolean isBorderOpaque()\n+\n+  /**\n+   * Paints the border for a given component.\n+   *\n+   * @param c the component whose border is to be painted.\n+   * @param g the graphics for painting.\n+   * @param x the horizontal position for painting the border.\n+   * @param y the vertical position for painting the border.\n+   * @param width the width of the available area for painting the border.\n+   * @param height the height of the available area for painting the border.\n+   */\n+  public void paintBorder(Component c, Graphics  g,\n+                          int x, int y, int width, int height)\n+  {\n+    switch (bevelType)\n+    {\n+    case RAISED:\n+      paintRaisedBevel(c, g, x, y, width, height);\n+      break;\n+\n+    case LOWERED:\n+      paintLoweredBevel(c, g, x, y, width, height);\n+      break;\n+    }\n+  }\n+\n+\n+  /**\n+   * Measures the width of this border.\n+   *\n+   * @param c the component whose border is to be measured.\n+   *\n+   * @return an Insets object whose <code>left</code>, <code>right</code>,\n+   *         <code>top</code> and <code>bottom</code> fields indicate the\n+   *         width of the border at the respective edge.\n+   *\n+   * @see #getBorderInsets(java.awt.Component, java.awt.Insets)\n+   */\n+  public Insets getBorderInsets(Component c)\n+  {\n+    return new Insets(2, 2, 2, 2);\n+  }\n+\n+\n+  /**\n+   * Measures the width of this border, storing the results into a\n+   * pre-existing Insets object.\n+   *\n+   * @param insets an Insets object for holding the result values.\n+   *        After invoking this method, the <code>left</code>,\n+   *        <code>right</code>, <code>top</code> and\n+   *        <code>bottom</code> fields indicate the width of the\n+   *        border at the respective edge.\n+   *\n+   * @return the same object that was passed for <code>insets</code>.\n+   *\n+   * @see #getBorderInsets()\n+   */\n+  public Insets getBorderInsets(Component c, Insets insets)\n+  {\n+    insets.left = insets.right = insets.top = insets.bottom = 2;\n+    return insets;\n+  }\n+\n+  \n+  /**\n+   * Determines the color that will be used for the outer side of\n+   * highlighted edges when painting the border.  If a highlight color\n+   * has been specified upon constructing the border, that color is\n+   * returned. Otherwise, the inner highlight color is brightened.\n+   *\n+   * @param c the component enclosed by this border.\n+   *\n+   * @see #getHighlightInnerColor(java.awt.Component)\n+   * @see java.awt.Color#brighter()\n+   */\n+  public Color getHighlightOuterColor(Component c)\n+  {\n+    if (highlightOuter != null)\n+      return highlightOuter;\n+    else\n+      return getHighlightInnerColor(c).brighter();\n+  }\n+\n+\n+  /**\n+   * Determines the color that will be used for the inner side of\n+   * highlighted edges when painting the border. If a highlight color\n+   * has been specified upon constructing the border, that color is\n+   * returned. Otherwise, the background color of the enclosed\n+   * component is brightened.\n+   *\n+   * @param c the component enclosed by this border.\n+   *\n+   * @see java.awt.Component#getBackground()\n+   * @see java.awt.Color#brighter()\n+   */\n+  public Color getHighlightInnerColor(Component c)\n+  {\n+    if (highlightInner != null)\n+      return highlightInner;\n+    else\n+      return c.getBackground().brighter();\n+  }\n+\n+\n+  /**\n+   * Determines the color that will be used for the inner side of\n+   * shadowed edges when painting the border. If a shadow color has\n+   * been specified upon constructing the border, that color is\n+   * returned. Otherwise, the background color of the enclosed\n+   * component is darkened.\n+   *\n+   * @param c the component enclosed by this border.\n+   *\n+   * @see java.awt.Component#getBackground()\n+   * @see java.awt.Color#darker()\n+   */\n+  public Color getShadowInnerColor(Component c)\n+  {\n+    if (shadowInner != null)\n+      return shadowInner;\n+    else\n+      return c.getBackground().darker();\n+  }\n+\n+\n+  /**\n+   * Determines the color that will be used for the outer side of\n+   * shadowed edges when painting the border.  If a shadow color\n+   * has been specified upon constructing the border, that color is\n+   * returned. Otherwise, the inner shadow color is darkened.\n+   *\n+   * @param c the component enclosed by this border.\n+   *\n+   * @see #getShadowInnerColor(java.awt.Component)\n+   * @see java.awt.Color#darker()\n+   */\n+  public Color getShadowOuterColor(Component c)\n+  {\n+    if (shadowOuter != null)\n+      return shadowOuter;\n+    else\n+      return getShadowInnerColor(c).darker();\n+  }\n+\n+\n+  /**\n+   * Returns the color that will be used for the outer side of\n+   * highlighted edges when painting the border, or <code>null</code>\n+   * if that color will be derived from the background of the enclosed\n+   * Component.\n+   */\n+  public Color getHighlightOuterColor()\n+  {\n+    return highlightOuter;\n+  }\n+\n+\n+  /**\n+   * Returns the color that will be used for the inner side of\n+   * highlighted edges when painting the border, or <code>null</code>\n+   * if that color will be derived from the background of the enclosed\n+   * Component.\n+   */\n+  public Color getHighlightInnerColor()\n+  {\n+    return highlightInner;\n+  }\n+\n+\n+  /**\n+   * Returns the color that will be used for the inner side of\n+   * shadowed edges when painting the border, or <code>null</code> if\n+   * that color will be derived from the background of the enclosed\n+   * Component.\n+   */\n+  public Color getShadowInnerColor()\n+  {\n+    return shadowInner;\n+  }\n+\n+\n+  /**\n+   * Returns the color that will be used for the outer side of\n+   * shadowed edges when painting the border, or <code>null</code> if\n+   * that color will be derived from the background of the enclosed\n+   * Component.\n+   */\n+  public Color getShadowOuterColor()\n+  {\n+    return shadowOuter;\n+  }\n+  \n+  \n+  /**\n+   * Returns the appearance of this border, which is either {@link\n+   * #RAISED} or {@link #LOWERED}.\n+   */\n+  public int getBevelType()\n+  {\n+    return bevelType;\n+  }\n+\n+\n+  /**\n+   * Determines whether this border fills every pixel in its area\n+   * when painting.\n+   *\n+   * <p>If the border colors are derived from the background color of\n+   * the enclosed component, the result is <code>true</code> because\n+   * the derivation method always returns opaque colors. Otherwise,\n+   * the result depends on the opacity of the individual colors.\n+   *\n+   * @return <code>true</code> if the border is fully opaque, or\n+   *         <code>false</code> if some pixels of the background\n+   *         can shine through the border.\n+   */\n+  public boolean isBorderOpaque()\n+  {\n+    /* If the colors are to be drived from the enclosed Component's\n+     * background color, the border is guaranteed to be fully opaque\n+     * because Color.brighten() and Color.darken() always return an\n+     * opaque color.\n+     */\n+    return \n+      ((highlightOuter == null) || (highlightOuter.getAlpha() == 255))\n+      && ((highlightInner == null) || (highlightInner.getAlpha() == 255))\n+      && ((shadowInner == null) || (shadowInner.getAlpha() == 255))\n+      && ((shadowOuter == null) ||(shadowOuter.getAlpha() == 255));\n+  }\n+\n+\n+  /**\n+   * Paints a raised bevel border around a component.\n+   *\n+   * @param c the component whose border is to be painted.\n+   * @param g the graphics for painting.\n+   * @param x the horizontal position for painting the border.\n+   * @param y the vertical position for painting the border.\n+   * @param width the width of the available area for painting the border.\n+   * @param height the height of the available area for painting the border.\n+   */\n+  protected void paintRaisedBevel(Component c, Graphics g,\n+                                  int x, int y, int width, int height)\n+  {\n+    paintBevel(g, x, y, width, height,\n+               getHighlightOuterColor(c), getHighlightInnerColor(c),\n+               getShadowInnerColor(c), getShadowOuterColor(c));\n+  }\n+\n+\n+  /**\n+   * Paints a lowered bevel border around a component.\n+   *\n+   * @param c the component whose border is to be painted.\n+   * @param g the graphics for painting.\n+   * @param x the horizontal position for painting the border.\n+   * @param y the vertical position for painting the border.\n+   * @param width the width of the available area for painting the border.\n+   * @param height the height of the available area for painting the border.\n+   */\n+  protected void paintLoweredBevel(Component c, Graphics g,\n+                                   int x, int y, int width, int height)\n+  {\n+    paintBevel(g, x, y, width, height,\n+               getShadowInnerColor(c), getShadowOuterColor(c),\n+               getHighlightInnerColor(c), getHighlightOuterColor(c));\n+  }\n+\n+\n+  /**\n+   * Paints a two-pixel bevel in four colors.\n+   * \n+   * <pre>\n+   * @@@@@@@@@@@@\n+   * @..........#    @ = color a\n+   * @.        X#    . = color b\n+   * @.        X#    X = color c\n+   * @.XXXXXXXXX#    # = color d\n+   * ############</pre>\n+   *\n+   * @param g the graphics for painting.\n+   * @param x the horizontal position for painting the border.\n+   * @param y the vertical position for painting the border.\n+   * @param width the width of the available area for painting the border.\n+   * @param height the height of the available area for painting the border.\n+   * @param a the color for the outer side of the top and left edges.\n+   * @param b the color for the inner side of the top and left edges.\n+   * @param c the color for the inner side of the bottom and right edges.\n+   * @param d the color for the outer side of the bottom and right edges.\n+   */\n+  private static void paintBevel(Graphics g,\n+                                 int x, int y, int width, int height,\n+                                 Color a, Color b, Color c, Color d)\n+  {\n+    Color oldColor;\n+\n+    oldColor = g.getColor();\n+    g.translate(x, y);\n+    width = width - 1;\n+    height = height - 1;\n+\n+    try\n     {\n-\treturn false;\n+      /* To understand this code, it might be helpful to look at the\n+       * images that are included with the JavaDoc. They are located\n+       * in the \"doc-files\" subdirectory.\n+       */\n+      g.setColor(a);\n+      g.drawLine(0, 0, width, 0);                       // a, horizontal\n+      g.drawLine(0, 1, 0, height);                      // a, vertical\n+\n+      g.setColor(b);\n+      g.drawLine(1, 1, width - 1, 1);                   // b, horizontal\n+      g.drawLine(1, 2, 1, height - 1);                  // b, vertical\n+\n+      g.setColor(c);\n+      g.drawLine(2, height - 1, width - 1, height - 1); // c, horizontal\n+      g.drawLine(width - 1, 2, width - 1, height - 2);  // c, vertical\n+\n+      g.setColor(d);\n+      g.drawLine(1, height, width, height);             // d, horizontal\n+      g.drawLine(width, 1, width, height - 1);          // d, vertical\n     }\n-    \n-    public void paintBorder(Component  c,\n-\t\t\t    Graphics  g, \n-\t\t\t    int  x, \n-\t\t\t    int  y, \n-\t\t\t    int  width, \n-\t\t\t    int  height)\n+    finally\n     {\n+      g.translate(-x, -y);\n+      g.setColor(oldColor);\n     }\n+  }\n }\n "}, {"sha": "1f2fb827e96f09fd7ae21a5cc88f7bf949301720", "filename": "libjava/javax/swing/border/Border.java", "status": "modified", "additions": 59, "deletions": 5, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2FBorder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2FBorder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2FBorder.java?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "patch": "@@ -1,5 +1,5 @@\n /* Border.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -42,10 +42,64 @@\n import java.awt.Graphics;\n import java.awt.Insets;\n \n+\n+/**\n+ * An interface for decorative or spacing borders around a Component.\n+ *\n+ * <p>To reduce memory consumption, several Components may share a\n+ * single Border instance. {@link javax.swing.BorderFactory} is a\n+ * factory class for producing commonly used shared borders.\n+ *\n+ * @see javax.swing.BorderFactory\n+ * @see EmptyBorder\n+ * @see CompoundBorder\n+ * @see BevelBorder\n+ * @see EtchedBorder\n+ * @see LineBorder\n+ * @see MatteBorder\n+ * @see SoftBevelBorder\n+ * @see TitledBorder\n+ * @see AbstractBorder\n+ *\n+ * @author Ronald Veldema (rveldema@cs.vu.nl)\n+ * @author Michael Koch (konqueror@gmx.de)\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n+ */\n public interface Border\n {\n-  public Insets getBorderInsets (Component c);\n-  public boolean isBorderOpaque ();\n-  public void paintBorder (Component c, Graphics g, int x, int y,\n-                           int width, int height);\n+  /**\n+   * Paints the border for a given component.\n+   *\n+   * @param c the component whose border is to be painted.\n+   * @param g the graphics for painting.\n+   * @param x the horizontal position for painting the border.\n+   * @param y the vertical position for painting the border.\n+   * @param width the width of the available area for painting the border.\n+   * @param height the height of the available area for painting the border.\n+   */\n+  public void paintBorder(Component c, Graphics g,\n+                          int x, int y, int width, int height);\n+  \n+  \n+  /**\n+   * Measures the width of this border.\n+   *\n+   * @param c the component whose border is to be measured.\n+   *\n+   * @return an Insets object whose <code>left</code>, <code>right</code>,\n+   *         <code>top</code> and <code>bottom</code> fields indicate the\n+   *         width of the border at the respective edge.\n+   */\n+  public Insets getBorderInsets(Component c);\n+  \n+  \n+  /**\n+   * Determines whether this border fills every pixel in its area\n+   * when painting.\n+   *\n+   * @return <code>true</code> if the border is fully opaque, or\n+   *         <code>false</code> if some pixels of the background\n+   *         can shine through the border.\n+   */\n+  public boolean isBorderOpaque();\n }"}, {"sha": "d75f4c0dca6b2394f7e85fbdd06a91af397ff19b", "filename": "libjava/javax/swing/border/CompoundBorder.java", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2FCompoundBorder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2FCompoundBorder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2FCompoundBorder.java?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "patch": "@@ -51,6 +51,10 @@\n public class CompoundBorder\n   extends AbstractBorder\n {\n+  /**\n+   * Determined using the <code>serialver</code> tool\n+   * of Apple/Sun JDK 1.3.1 on MacOS X 10.1.5.\n+   */\n   static final long serialVersionUID = 9054540377030555103L;\n \n \n@@ -90,14 +94,14 @@ public CompoundBorder ()\n    * outside borders.\n    *\n    * @param outsideBorder the outside border, which is painted to the\n-   *        outside of both <code>insideBorder</code> and the bordered\n-   *        compoonent. It is acceptable to pass <code>null</code>, in\n-   *        which no outside border is painted.\n+   *        outside of both <code>insideBorder</code> and the enclosed\n+   *        component. It is acceptable to pass <code>null</code>, in\n+   *        which case no outside border is painted.\n    *\n    * @param insideBorder the inside border, which is painted to\n-   *        between <code>outsideBorder</code> and the bordered\n+   *        between <code>outsideBorder</code> and the enclosed\n    *        component. It is acceptable to pass <code>null</code>, in\n-   *        which no intside border is painted.\n+   *        which case no inside border is painted.\n    */\n   public CompoundBorder (Border outsideBorder, Border insideBorder)\n   {"}, {"sha": "6360063ffa410bebf84d9a42203b6d8356d37e13", "filename": "libjava/javax/swing/border/EmptyBorder.java", "status": "modified", "additions": 161, "deletions": 26, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2FEmptyBorder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2FEmptyBorder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2FEmptyBorder.java?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "patch": "@@ -1,5 +1,5 @@\n /* EmptyBorder.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -42,47 +42,182 @@\n import java.awt.Graphics;\n import java.awt.Insets;\n \n-public class EmptyBorder extends AbstractBorder\n+\n+/**\n+ * A border for leaving a specifiable number of pixels empty around\n+ * the enclosed component.  An EmptyBorder requires some space on each\n+ * edge, but does not perform any drawing.\n+ *\n+ * <p><img src=\"EmptyBorder-1.png\" width=\"290\" height=\"200\"\n+ * alt=\"[An illustration of EmptyBorder]\" />\n+ *\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n+ */\n+public class EmptyBorder\n+  extends AbstractBorder\n {\n+  /**\n+   * Determined using the <code>serialver</code> tool\n+   * of Apple/Sun JDK 1.3.1 on MacOS X 10.1.5.\n+   */\n+  static final long serialVersionUID = -8116076291731988694L;\n+\n+\n+  /**\n+   * The number of pixels required at the left edge.\n+   */\n   protected int left;\n+\n+\n+  /**\n+   * The number of pixels required at the right edge.\n+   */\n   protected int right;\n-  protected int bottom;\n+\n+\n+  /**\n+   * The number of pixels required at the top edge.\n+   */\n   protected int top;\n \n-  public EmptyBorder (Insets borderInsets)\n-  {\n-    this (borderInsets.left, borderInsets.right,\n-          borderInsets.top, borderInsets.bottom);\n-  }\n \n-  public EmptyBorder (int left, int right, int top, int bottom)\n+  /**\n+   * The number of pixels required at the bottom edge.\n+   */\n+  protected int bottom;\n+\n+\n+  /**\n+   * Constructs an empty border given the number of pixels required\n+   * on each side.\n+   *\n+   * @param top the number of pixels that the border will need\n+   *        for its top edge.\n+   *\n+   * @param left the number of pixels that the border will need\n+   *        for its left edge.\n+   *\n+   * @param bottom the number of pixels that the border will need\n+   *        for its bottom edge.\n+   *\n+   * @param right the number of pixels that the border will need\n+   *        for its right edge.\n+   */\n+  public EmptyBorder(int top, int left, int bottom, int right)\n   {\n-    this.left = left;\n-    this.right = right;\n     this.top = top;\n+    this.left = left;\n     this.bottom = bottom;\n+    this.right = right;\n   }\n \n-  public Insets getBorderInsets (Component c, Insets s)\n+\n+  /**\n+   * Constructs an empty border given the number of pixels required\n+   * on each side, passed in an Insets object.\n+   *\n+   * @param borderInsets the Insets for the new border.\n+   */\n+  public EmptyBorder(Insets borderInsets)\n   {\n-    if (s == null)\n-      s = new Insets (0,0,0,0);\n-\n-    s.left = left;\n-    s.right = right;\n-    s.top = top;\n-    s.bottom = bottom;\n-    return s;\n+    this(borderInsets.top, borderInsets.left,\n+         borderInsets.bottom, borderInsets.right);\n   }\n-    \n-  public boolean isBorderOpaque ()\n+\n+\n+  /**\n+   * Performs nothing because an EmptyBorder does not paint any\n+   * pixels. While the inherited implementation provided by\n+   * {@link AbstractBorder#paintBorder} is a no-op as well,\n+   * it is overwritten in order to match the API of the Sun\n+   * reference implementation.\n+   *\n+   * @param c the component whose border is to be painted.\n+   * @param g the graphics for painting.\n+   * @param x the horizontal position for painting the border.\n+   * @param y the vertical position for painting the border.\n+   * @param width the width of the available area for painting the border.\n+   * @param height the height of the available area for painting the border.\n+   */\n+  public void paintBorder(Component c, Graphics g,\n+                          int x, int y, int width, int height)\n   {\n-    return false;\n   }\n \n-  public void paintBorder (Component c, Graphics g, int x, int y,\n-                           int width, int height)\n+\n+  /**\n+   * Measures the width of this border.\n+   *\n+   * @param c the component whose border is to be measured.\n+   *\n+   * @return an Insets object whose <code>left</code>, <code>right</code>,\n+   *         <code>top</code> and <code>bottom</code> fields indicate the\n+   *         width of the border at the respective edge.\n+   *\n+   * @see #getBorderInsets(java.awt.Component, java.awt.Insets)\n+   */\n+  public Insets getBorderInsets(Component c)\n   {\n+    return getBorderInsets(c, null);\n   }\n-}\n \n+\n+  /**\n+   * Measures the width of this border, storing the results into a\n+   * pre-existing Insets object.\n+   *\n+   * @param insets an Insets object for holding the result values.\n+   *        After invoking this method, the <code>left</code>,\n+   *        <code>right</code>, <code>top</code> and\n+   *        <code>bottom</code> fields indicate the width of the\n+   *        border at the respective edge.\n+   *\n+   * @return the same object that was passed for <code>insets</code>.\n+   *\n+   * @see #getBorderInsets()\n+   */\n+  public Insets getBorderInsets(Component c, Insets insets)\n+  {\n+    if (insets == null)\n+      insets = new Insets(0, 0, 0, 0);\n+\n+    insets.left = left;\n+    insets.right = right;\n+    insets.top = top;\n+    insets.bottom = bottom;\n+    return insets;\n+  }\n+\n+\n+  /**\n+   * Measures the width of this border.\n+   *\n+   * @return an Insets object whose <code>left</code>, <code>right</code>,\n+   *         <code>top</code> and <code>bottom</code> fields indicate the\n+   *         width of the border at the respective edge.\n+   *\n+   * @see #getBorderInsets(java.awt.Component, java.awt.Insets)\n+   */\n+  public Insets getBorderInsets()\n+  {\n+    return getBorderInsets(null, null);\n+  }\n+  \n+  \n+  /**\n+   * Determines whether this border fills every pixel in its area\n+   * when painting. Since an empty border does not paint any pixels\n+   * whatsoever, the result is <code>false</code>.\n+   *\n+   * @return <code>false</code>.\n+   */\n+  public boolean isBorderOpaque()\n+  {\n+    /* The inherited implementation of AbstractBorder.isBorderOpaque()\n+     * would also return false. It is not clear why this is overriden\n+     * in the Sun implementation, at least not from just reading the\n+     * JavaDoc.\n+     */\n+    return false;\n+  }\n+}"}, {"sha": "bb16ae925b17d50ec6f0d2d07ade49b1a0cc5051", "filename": "libjava/javax/swing/border/EtchedBorder.java", "status": "modified", "additions": 345, "deletions": 24, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2FEtchedBorder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2FEtchedBorder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2FEtchedBorder.java?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "patch": "@@ -1,5 +1,5 @@\n /* EtchedBorder.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -41,50 +41,371 @@\n import java.awt.Color;\n import java.awt.Component;\n import java.awt.Graphics;\n+import java.awt.Insets;\n \n-public class EtchedBorder extends AbstractBorder\n+\n+/**\n+ * A border that looks like an engraving etched into the background\n+ * surface, or (in its raised variant) coming out of the surface\n+ * plane. Using different constructors, it is possible to either\n+ * explicitly specify the border colors, or to let the colors derive\n+ * from the background color of the enclosed Component.\n+ *\n+ * <p><img src=\"EtchedBorder-1.png\" width=\"500\" height=\"200\"\n+ * alt=\"[An illustration of the two EtchedBorder variants]\" />\n+ *\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n+ */\n+public class EtchedBorder\n+  extends AbstractBorder\n {\n-  public static final int LOWERED = 1;\n+  /**\n+   * Determined using the <code>serialver</code> tool\n+   * of Apple/Sun JDK 1.3.1 on MacOS X 10.1.5.\n+   */\n+  static final long serialVersionUID = 4001244046866360638L;\n+  \n+  \n+  /**\n+   * Indicates that the border appears as coming out of the\n+   * background.\n+   */\n   public static final int RAISED = 0;\n-    \n+\n+\n+  /**\n+   * Indicates that the border appears as engraved into the\n+   * background.\n+   */\n+  public static final int LOWERED = 1;\n+\n+  \n+  /**\n+   * The type of this EtchedBorder, which is either {@link #RAISED}\n+   * or {@link #LOWERED}.\n+   */\n   protected int etchType;\n+  \n+\n+  /**\n+   * The highlight color, or <code>null</code> to indicate that the\n+   * color shall be derived from the background of the enclosed\n+   * component.\n+   */\n   protected Color highlight;\n+\n+\n+  /**\n+   * The shadow color, or <code>null</code> to indicate that the\n+   * color shall be derived from the background of the enclosed\n+   * component.\n+   */\n   protected Color shadow;\n \n-  public EtchedBorder ()\n+\n+  /**\n+   * Constructs a lowered EtchedBorder. The colors will be derived\n+   * from the background color of the enclosed Component when the\n+   * border gets painted.\n+   */\n+  public EtchedBorder()\n   {\n-    this (LOWERED, null, null);\n+    this(LOWERED);\n   }\n \n-  public EtchedBorder (Color highlight, Color shadow)\n+\n+  /**\n+   * Constructs an EtchedBorder with the specified appearance. The\n+   * colors will be derived from the background color of the enclosed\n+   * Component when the border gets painted.\n+   *\n+   * <p><img src=\"EtchedBorder-1.png\" width=\"500\" height=\"200\"\n+   * alt=\"[An illustration of the two EtchedBorder variants]\" />\n+   *\n+   * @param etchType the desired appearance of the border. The value\n+   *        must be either {@link #RAISED} or {@link #LOWERED}.\n+   *\n+   * @throws IllegalArgumentException if <code>etchType</code> has\n+   *         an unsupported value.\n+   */\n+  public EtchedBorder(int etchType)\n   {\n-    this (LOWERED, highlight, shadow);\n-  }\n+    if ((etchType != RAISED) && (etchType != LOWERED))\n+      throw new IllegalArgumentException();\n+\n+    this.etchType = etchType;\n \n-  public EtchedBorder (int etchType)\n+    /* The highlight and shadow fields already have a null value\n+     * when the constructor gets called, so there is no need to\n+     * assign a value here.\n+     */\n+  }\n+  \n+  \n+  /**\n+   * Constructs a lowered EtchedBorder, explicitly selecting the\n+   * colors that will be used for highlight and shadow.\n+   *\n+   * @param highlight the color that will be used for painting\n+   *        the highlight part of the border.\n+   *\n+   * @param shadow the color that will be used for painting\n+   *        the shadow part of the border.\n+   *\n+   * @see #EtchedBorder(int, Color, Color)\n+   */\n+  public EtchedBorder(Color highlight, Color shadow)\n   {\n-    this (etchType, null, null);\n+    this(LOWERED, highlight, shadow);\n   }\n-\n-  public EtchedBorder (int etchType, Color highlight, Color shadow)\n+  \n+  \n+  /**\n+   * Constructs an EtchedBorder with the specified appearance,\n+   * explicitly selecting the colors that will be used for\n+   * highlight and shadow.\n+   *\n+   * <p><img src=\"EtchedBorder-2.png\" width=\"500\" height=\"200\"\n+   * alt=\"[An illustration that shows which pixels get painted\n+   * in what color]\" />\n+   *\n+   * @param etchType the desired appearance of the border. The value\n+   *        must be either {@link #RAISED} or {@link #LOWERED}.\n+   *\n+   * @param highlight the color that will be used for painting\n+   *        the highlight part of the border.\n+   *\n+   * @param shadow the color that will be used for painting\n+   *        the shadow part of the border.\n+   *\n+   * @throws IllegalArgumentException if <code>etchType</code> has\n+   *         an unsupported value.\n+   */\n+  public EtchedBorder(int etchType, Color highlight, Color shadow)\n   {\n-    this.etchType = etchType;\n+    this(etchType);  // Checks the validity of the value.\n     this.highlight = highlight;\n     this.shadow = shadow;\n   }\n-    \n-    public boolean isBorderOpaque()\n+  \n+  \n+  /**\n+   * Paints the border for a given component.\n+   *\n+   * @param c the component whose border is to be painted.\n+   * @param g the graphics for painting.\n+   * @param x the horizontal position for painting the border.\n+   * @param y the vertical position for painting the border.\n+   * @param width the width of the available area for painting the border.\n+   * @param height the height of the available area for painting the border.\n+   */\n+  public void paintBorder(Component c, Graphics  g,\n+                          int x, int y, int width, int height)\n+  {\n+    switch (etchType)\n+    {\n+    case RAISED:\n+      paintEtchedBorder(g, x, y, width, height,\n+                        getHighlightColor(c), getShadowColor(c));\n+      break;\n+\n+    case LOWERED:\n+      paintEtchedBorder(g, x, y, width, height,\n+                        getShadowColor(c), getHighlightColor(c));\n+      break;\n+    }\n+  }\n+  \n+  \n+  /**\n+   * Measures the width of this border.\n+   *\n+   * @param c the component whose border is to be measured.\n+   *\n+   * @return an Insets object whose <code>left</code>, <code>right</code>,\n+   *         <code>top</code> and <code>bottom</code> fields indicate the\n+   *         width of the border at the respective edge.\n+   *\n+   * @see #getBorderInsets(java.awt.Component, java.awt.Insets)\n+   */\n+  public Insets getBorderInsets(Component c)\n+  {\n+    return new Insets(2, 2, 2, 2);\n+  }\n+\n+\n+  /**\n+   * Measures the width of this border, storing the results into a\n+   * pre-existing Insets object.\n+   *\n+   * @param insets an Insets object for holding the result values.\n+   *        After invoking this method, the <code>left</code>,\n+   *        <code>right</code>, <code>top</code> and\n+   *        <code>bottom</code> fields indicate the width of the\n+   *        border at the respective edge.\n+   *\n+   * @return the same object that was passed for <code>insets</code>.\n+   *\n+   * @see #getBorderInsets()\n+   */\n+  public Insets getBorderInsets(Component c, Insets insets)\n+  {\n+    insets.left = insets.right = insets.top = insets.bottom = 2;\n+    return insets;\n+  }\n+\n+\n+  /**\n+   * Determines whether this border fills every pixel in its area\n+   * when painting.\n+   *\n+   * <p>If the border colors are derived from the background color of\n+   * the enclosed component, the result is <code>true</code> because\n+   * the derivation method always returns opaque colors. Otherwise,\n+   * the result depends on the opacity of the individual colors.\n+   *\n+   * @return <code>true</code> if the border is fully opaque, or\n+   *         <code>false</code> if some pixels of the background\n+   *         can shine through the border.\n+   */\n+  public boolean isBorderOpaque()\n+  {\n+    /* If the colors are to be drived from the enclosed Component's\n+     * background color, the border is guaranteed to be fully opaque\n+     * because Color.brighten() and Color.darken() always return an\n+     * opaque color.\n+     */\n+    return\n+      ((highlight == null) || (highlight.getAlpha() == 255))\n+      && ((shadow == null) || (shadow.getAlpha() == 255));\n+  }\n+\n+  \n+  /**\n+   * Returns the appearance of this EtchedBorder, which is either\n+   * {@link #RAISED} or {@link #LOWERED}.\n+   */\n+  public int getEtchType()\n+  {\n+    return etchType;\n+  }\n+\n+\n+  /**\n+   * Determines the color that will be used for highlighted parts when\n+   * painting the border around a given component. If a highlight\n+   * color has been specified upon constructing the border, that color\n+   * is returned. Otherwise, the background color of the enclosed\n+   * component is brightened.\n+   *\n+   * @param c the component enclosed by this border.\n+   *\n+   * @see java.awt.Component#getBackground()\n+   * @see java.awt.Color#brighter()\n+   */\n+  public Color getHighlightColor(Component c)\n+  {\n+    if (highlight != null)\n+      return highlight;\n+    else\n+      return c.getBackground().brighter();\n+  }\n+  \n+  \n+  /**\n+   * Returns the color that will be used for highlighted parts when\n+   * painting the border, or <code>null</code> if that color will be\n+   * derived from the background of the enclosed Component.\n+   */\n+  public Color getHighlightColor()\n+  {\n+    return highlight;\n+  }\n+\n+\n+  /**\n+   * Determines the color that will be used for shadowed parts when\n+   * painting the border around a given component. If a shadow color\n+   * has been specified upon constructing the border, that color is\n+   * returned. Otherwise, the background color of the enclosed\n+   * component is darkened.\n+   *\n+   * @param c the component enclosed by this border.\n+   *\n+   * @see java.awt.Component#getBackground()\n+   * @see java.awt.Color#darker()\n+   */\n+  public Color getShadowColor(Component c)\n+  {\n+    if (shadow != null)\n+      return shadow;\n+    else\n+      return c.getBackground().darker();\n+  }\n+  \n+  \n+  /**\n+   * Returns the color that will be used for shadowed parts when\n+   * painting the border, or <code>null</code> if that color will be\n+   * derived from the background of the enclosed Component.\n+   */\n+  public Color getShadowColor()\n+  {\n+    return shadow;\n+  }\n+\n+\n+  /**\n+   * Paints a two-pixel etching in two colors.\n+   *\n+   * <pre>\n+   * @@@@@@@@@@@.\n+   * @.........@.    @ = color a\n+   * @.        @.    . = color b\n+   * @.        @.\n+   * @@@@@@@@@@@.\n+   * ............</pre>\n+   *\n+   * @param g the graphics for painting.\n+   * @param x the horizontal position for painting the border.\n+   * @param y the vertical position for painting the border.\n+   * @param width the width of the available area for painting the border.\n+   * @param height the height of the available area for painting the border.\n+   * @param a one of the two colors.\n+   * @param b the second of the two colors.\n+   */\n+  private static void paintEtchedBorder(Graphics g,\n+                                        int x, int y, int width, int height,\n+                                        Color a, Color b)\n+  {\n+    Color oldColor;\n+\n+    oldColor = g.getColor();\n+    g.translate(x, y);\n+    width = width - 1;\n+    height = height - 1;\n+\n+    try\n     {\n-\treturn false;\n+      /* To understand this code, it might be helpful to look at the\n+       * images that are included with the JavaDoc. They are located\n+       * in the \"doc-files\" subdirectory. EtchedBorder-2.png might\n+       * be especially informative.\n+       */\n+      g.setColor(a);\n+      g.drawRect(0, 0, width - 1, height - 1);\n+\n+      g.setColor(b);\n+      g.drawLine(1, 1, width - 2, 1);            // top edge\n+      g.drawLine(1, 2, 1, height - 2);           // left edge\n+      g.drawLine(0, height, width, height);      // bottom edge\n+      g.drawLine(width, 0, width, height - 1);   // right edge\n     }\n-    \n-    public void paintBorder(Component  c,\n-\t\t\t    Graphics  g, \n-\t\t\t    int  x, \n-\t\t\t    int  y, \n-\t\t\t    int  width, \n-\t\t\t    int  height)\n+    finally\n     {\n+      g.translate(-x, -y);\n+      g.setColor(oldColor);\n     }\n+  }\n }\n "}, {"sha": "17ba26ef641a6e7096838ecd131a0f9d6ebb049e", "filename": "libjava/javax/swing/border/LineBorder.java", "status": "modified", "additions": 267, "deletions": 18, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2FLineBorder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2FLineBorder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2FLineBorder.java?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "patch": "@@ -1,5 +1,5 @@\n /* LineBorder.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -41,45 +41,294 @@\n import java.awt.Color;\n import java.awt.Component;\n import java.awt.Graphics;\n+import java.awt.Insets;\n \n-public class LineBorder extends AbstractBorder\n+\n+/**\n+ * A border that consists of a line whose thickness and color can be\n+ * specified. There also is a variant with rounded corners.\n+ *\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n+ */\n+public class LineBorder\n+  extends AbstractBorder\n {\n+  /**\n+   * Determined using the <code>serialver</code> tool\n+   * of Apple/Sun JDK 1.3.1 on MacOS X 10.1.5.\n+   */\n+  static final long serialVersionUID = -787563427772288970L;\n+\n+\n+  /**\n+   * A shared instance of a black, one pixel thick, plain LineBorder.\n+   * The singleton object is lazily created by {@link\n+   * #createBlackLineBorder()} upon its first invocation.\n+   */\n+  private static LineBorder blackLineBorder;\n+\n+\n+  /**\n+   * A shared instance of a gray, one pixel thick, plain LineBorder.\n+   * The singleton object is lazily created by {@link\n+   * #createBlackGrayBorder()} upon its first invocation.\n+   */\n+  private static LineBorder grayLineBorder;\n+\n+\n+  /**\n+   * The width of the line in pixels.\n+   */\n+  protected int thickness;\n+\n+\n+  /**\n+   * The color of the line.\n+   */\n   protected Color lineColor;\n+\n+\n+  /**\n+   * Indicates whether the line is drawn with rounded corners\n+   * (<code>true</code>) or not ((<code>false</code>).\n+   */\n   protected boolean roundedCorners;\n-  protected int thickness;\n \n-  public LineBorder (Color color)\n+\n+  /**\n+   * Constructs a LineBorder given its color.  The border will be one\n+   * pixel thick and have plain corners.\n+   *\n+   * @param color the color for drawing the border.\n+   *\n+   * @see #LineBorder(java.awt.Color, int, boolean)\n+   */\n+  public LineBorder(Color color)\n   {\n-    this (color, 1);\n+    this(color, /* thickness */ 1, /* roundedCorners */ false);\n   }\n \n-  public LineBorder (Color color, int thickness)\n+\n+  /**\n+   * Constructs a LineBorder given its color and thickness.  The\n+   * border will have plain corners.\n+   *\n+   * @param color the color for drawing the border.\n+   * @param thickness the width of the line in pixels.\n+   *\n+   * @see #LineBorder(java.awt.Color, int, boolean)\n+   */\n+  public LineBorder(Color color, int thickness)\n   {\n-    this (color, thickness, false); // FIXME: check roundedCorners argument\n+    this (color, thickness, /* roundedCorners */ false);\n   }\n-\n+  \n+  \n   /**\n+   * Constructs a LineBorder given its color, thickness, and whether\n+   * it has rounded corners.\n+   * \n+   * <p><img src=\"LineBorder-1.png\" width=\"500\" height=\"200\"\n+   * alt=\"[An illustration of two LineBorders] />\n+   *\n+   * <p>Note that the enlarged view in the right-hand picture shows\n+   * that the implementation draws one more pixel than specified,\n+   * provided that <code>roundedCorders</code> is <code>true</code>\n+   * and anti-aliasing is turned on while painting. While this might\n+   * be considered a bug, the Sun reference implementation (at least\n+   * JDK 1.3.1 on Apple MacOS X 10.1.5) can be observed to fill\n+   * exactly the same pixels as shown above. The GNU Classpath\n+   * LineBorder replicates the observed behavior of the Sun\n+   * implementation.\n+   *\n+   * @param color the color for drawing the border.\n+   * @param thickness the width of the line in pixels.\n+   * @param roundedCorners <code>true</code> for rounded corners,\n+   *        <code>false</code> for plain corners.\n+   *\n    * @since 1.3\n    */\n-  public LineBorder (Color color, int thickness, boolean roundedCorners)\n+  // For the bug mentioned in the JavaDoc, please see also the comment\n+  // in the paintBorder method below.\n+  //\n+  public LineBorder(Color color, int thickness, boolean roundedCorners)\n   {\n+    if ((color == null) || (thickness < 0))\n+      throw new IllegalArgumentException();\n+\n     this.lineColor = color;\n     this.thickness = thickness;\n     this.roundedCorners = roundedCorners;\n   }\n+  \n+  \n+  /**\n+   * Returns a black, one pixel thick, plain LineBorder. The method\n+   * may always return the same (singleton) LineBorder instance.\n+   */\n+  public static Border createBlackLineBorder()\n+  {\n+    /* Swing is not designed to be thread-safe, so there is no\n+     * need to synchronize the access to the global variable.\n+     */\n+    if (blackLineBorder == null)\n+      blackLineBorder = new LineBorder(Color.black);\n     \n-    public boolean isBorderOpaque()\n+    return blackLineBorder;\n+  }\n+  \n+  \n+  /**\n+   * Returns a gray, one pixel thick, plain LineBorder. The method\n+   * may always return the same (singleton) LineBorder instance.\n+   */\n+  public static Border createGrayLineBorder()\n+  {\n+    /* Swing is not designed to be thread-safe, so there is no\n+     * need to synchronize the access to the global variable.\n+     */\n+    if (grayLineBorder == null)\n+      grayLineBorder = new LineBorder(Color.gray);\n+    \n+    return grayLineBorder;\n+  }\n+  \n+  \n+  /**\n+   * Paints the line border around a given Component.\n+   *\n+   * @param c the component whose border is to be painted.\n+   * @param g the graphics for painting.\n+   * @param x the horizontal position for painting the border.\n+   * @param y the vertical position for painting the border.\n+   * @param width the width of the available area for painting the border.\n+   * @param height the height of the available area for painting the border.\n+   */\n+  public void paintBorder(Component c, Graphics  g,\n+                          int x, int y, int width, int height)\n+  {\n+    Color oldColor = g.getColor();\n+\n+    try\n     {\n-\treturn false;\n+      g.setColor(lineColor);\n+\n+      /* If width and height were not adjusted, the border would\n+       * appear one pixel too large in both directions.\n+       */\n+      width -= 1;\n+      height -= 1;\n+\n+      /* Blurred, too large appearance\n+       * -----------------------------\n+       * While Java 2D has introduced line strokes of arbitrary width,\n+       * it seems desirable to keep this code independent of Java 2D.\n+       * Therefore, multiple nested rectangles (or rounded rectangles)\n+       * are drawn in order to simulate a line whose thickness is\n+       * greater than one pixel.\n+       *\n+       * This hack causes a blurred appearance when anti-aliasing is\n+       * on. Interestingly enough, though, the Sun JDK 1.3.1 (at least\n+       * on MacOS X 10.1.5) shows exactly the same appearance under\n+       * this condition. It thus seems likely that Sun does the same\n+       * hack for simulating thick lines.  For this reason, the\n+       * blurred appearance seems acceptable -- especially since GNU\n+       * Classpath tries to be compatible with the Sun reference\n+       * implementation.\n+       */\n+      for (int i = 0; i < thickness; i++)\n+      {\n+        if (roundedCorners)\n+          g.drawRoundRect(x, y, width, height, thickness, thickness);\n+        else\n+          g.drawRect(x, y, width, height);\n+\n+        x += 1;\n+        y += 1;\n+        width -= 2;\n+        height -= 2;\n+      }\n     }\n-    \n-    public void paintBorder(Component  c,\n-\t\t\t    Graphics  g, \n-\t\t\t    int  x, \n-\t\t\t    int  y, \n-\t\t\t    int  width, \n-\t\t\t    int  height)\n+    finally\n     {\n+      g.setColor(oldColor);\n     }\n+  }\n+  \n+  \n+  /**\n+   * Measures the width of this border.\n+   *\n+   * @param c the component whose border is to be measured.\n+   *\n+   * @return an Insets object whose <code>left</code>, <code>right</code>,\n+   *         <code>top</code> and <code>bottom</code> fields indicate the\n+   *         width of the border at the respective edge, which is the\n+   *         thickness of the line.\n+   *\n+   * @see #getBorderInsets(java.awt.Component, java.awt.Insets)\n+   */\n+  public Insets getBorderInsets(Component c)\n+  {\n+    return new Insets(thickness, thickness, thickness, thickness);\n+  }\n+  \n+  \n+  /**\n+   * Measures the width of this border, storing the results into a\n+   * pre-existing Insets object.\n+   *\n+   * @param insets an Insets object for holding the result values.\n+   *        After invoking this method, the <code>left</code>,\n+   *        <code>right</code>, <code>top</code> and\n+   *        <code>bottom</code> fields indicate the width of the\n+   *        border at the respective edge, which is the thickness\n+   *        of the line.\n+   *\n+   * @return the same object that was passed for <code>insets</code>.\n+   *\n+   * @see #getBorderInsets()\n+   */\n+  public Insets getBorderInsets(Component c, Insets insets)\n+  {\n+    insets.left = insets.right = insets.top = insets.bottom = thickness;\n+    return insets;\n+  }\n+  \n+  \n+  /**\n+   * Returns the thickness of the line in pixels.\n+   */\n+  public int getThickness()\n+  {\n+    return thickness;\n+  }\n+  \n+  \n+  /**\n+   * Returns whether this LineBorder os drawm with rounded\n+   * or with plain corners.\n+   *\n+   * @return <code>true</code> if the corners are rounded,\n+   *         <code>false</code> if the corners are plain.\n+   */\n+  public boolean getRoundedCorners()\n+  {\n+    return roundedCorners;\n+  }\n+  \n+  \n+  /**\n+   * Determines whether this border fills every pixel in its area\n+   * when painting.\n+   *\n+   * @return <code>true</code> if the corners are plain and the line\n+   *         color is fully opaque; <code>false</code> if the corners\n+   *         are rounded or the line color is partially transparent.\n+   */\n+  public boolean isBorderOpaque()\n+  {\n+    return (!roundedCorners) && (lineColor.getAlpha() == 255);\n+  }\n }\n "}, {"sha": "1cc66f70a1fbc8daf8e84ff265121448db06a2f5", "filename": "libjava/javax/swing/border/MatteBorder.java", "status": "modified", "additions": 336, "deletions": 28, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2FMatteBorder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2FMatteBorder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2FMatteBorder.java?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "patch": "@@ -1,5 +1,5 @@\n /* MatteBorder.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -44,53 +44,361 @@\n import java.awt.Insets;\n import javax.swing.Icon;\n \n-public class MatteBorder extends EmptyBorder\n+\n+/**\n+ * A border that is filled with either a solid color or with repeated\n+ * icon tiles.\n+ *\n+ * <p><img src=\"MatteBorder-1.png\" width=\"500\" height=\"150\"\n+ * alt=\"[Two MatteBorders]\" />\n+ *\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n+ */\n+public class MatteBorder\n+  extends EmptyBorder\n {\n+  /**\n+   * Determined using the <code>serialver</code> tool\n+   * of Apple/Sun JDK 1.3.1 on MacOS X 10.1.5.\n+   */\n+  static final long serialVersionUID = 4422248989617298224L;\n+  \n+  \n+  /**\n+   * The color that is used for filling the border, or\n+   * <code>null</code> if the border is filled with repetitions of a\n+   * tile icon.\n+   *\n+   * @see #tileIcon\n+   */\n   protected Color color;\n+  \n+  \n+  /**\n+   * The icon is used for filling the border with a tile, or\n+   * <code>null</code> if the border is filled with a solid\n+   * color.\n+   *\n+   * @see #color\n+   */\n   protected Icon tileIcon;\n-\n-  public MatteBorder (Icon tileIcon)\n+  \n+  \n+  /**\n+   * Constructs a MatteBorder given the width on each side\n+   * and a fill color.\n+   *\n+   * <p><img src=\"MatteBorder-2.png\" width=\"500\" height=\"150\"\n+   * alt=\"[A picture of a MatteBorder made by this constructor]\" />\n+   *\n+   * @param top the width of the border at its top edge.\n+   * @param left the width of the border at its left edge.\n+   * @param bottom the width of the border at its bottom edge.\n+   * @param right the width of the border at its right edge.\n+   * @param matteColor the color for filling the border.\n+   */\n+  public MatteBorder(int top, int left, int bottom, int right,\n+                     Color matteColor)\n   {\n-    // FIXME: implement this\n-    this (null, tileIcon);\n+    super(top, left, bottom, right);\n+\n+    if (matteColor == null)\n+      throw new IllegalArgumentException();\n+\n+    this.color = matteColor;\n   }\n \n-  public MatteBorder (Insets borderInsets, Color color)\n+\n+  /**\n+   * Constructs a MatteBorder given its insets and fill color.\n+   *\n+   * <p><img src=\"MatteBorder-3.png\" width=\"500\" height=\"150\"\n+   * alt=\"[A picture of a MatteBorder made by this constructor]\" />\n+   *\n+   * @param borderInsets an Insets object whose <code>top</code>,\n+   *        <code>left</code>, <code>bottom</code> and <code>right</code>\n+   *        fields indicate the with of the border at the respective\n+   *        edge.\n+   *\n+   * @param matteColor the color for filling the border.\n+   */\n+  public MatteBorder(Insets borderInsets, Color matteColor)\n   {\n-    this (borderInsets.top, borderInsets.left, borderInsets.bottom,\n-          borderInsets.right, color);\n+    this(borderInsets.top, borderInsets.left,\n+         borderInsets.bottom, borderInsets.right,\n+         matteColor);\n   }\n \n-  public MatteBorder (Insets borderInsets, Icon tileIcon)\n+\n+  /**\n+   * Constructs a MatteBorder given the width on each side\n+   * and an icon for tiling the border area.\n+   *\n+   * <p><img src=\"MatteBorder-4.png\" width=\"500\" height=\"150\"\n+   * alt=\"[A picture of a MatteBorder made by this constructor]\" />\n+   *\n+   * @param top the width of the border at its top edge.\n+   * @param left the width of the border at its left edge.\n+   * @param bottom the width of the border at its bottom edge.\n+   * @param right the width of the border at its right edge.\n+   * @param tileIcon an icon for tiling the border area.\n+   */\n+  public MatteBorder(int top, int left, int bottom, int right,\n+                     Icon tileIcon)\n   {\n-    this (borderInsets.top, borderInsets.left, borderInsets.bottom,\n-          borderInsets.right, tileIcon);\n+    super(top, left, bottom, right);\n+\n+    if (tileIcon == null)\n+      throw new IllegalArgumentException();\n+\n+    this.tileIcon = tileIcon;\n   }\n \n-  public MatteBorder (int top, int left, int bottom, int right, Icon tileIcon)\n+\n+  /**\n+   * Constructs a MatteBorder given its insets and an icon\n+   * for tiling the border area.\n+   *\n+   * <p><img src=\"MatteBorder-5.png\" width=\"500\" height=\"150\"\n+   * alt=\"[A picture of a MatteBorder made by this constructor]\" />\n+   *\n+   * @param borderInsets an Insets object whose <code>top</code>,\n+   *        <code>left</code>, <code>bottom</code> and <code>right</code>\n+   *        fields indicate the with of the border at the respective\n+   *        edge.\n+   *\n+   * @param tileIcon an icon for tiling the border area.\n+   */\n+  public MatteBorder(Insets borderInsets, Icon tileIcon)\n   {\n-    super (top, left, bottom, right);\n-    this.tileIcon = tileIcon;\n+    this(borderInsets.top, borderInsets.left,\n+         borderInsets.bottom, borderInsets.right,\n+         tileIcon);\n+  }\n+  \n+  \n+  /**\n+   * Constructs a MatteBorder given an icon for tiling the\n+   * border area. The icon width is used for the border insets\n+   * at the left and right edge, the icon height for the top and\n+   * bottom edge.\n+   *\n+   * <p><img src=\"MatteBorder-6.png\" width=\"500\" height=\"150\"\n+   * alt=\"[A picture of a MatteBorder made by this constructor]\" />\n+   *\n+   * @param tileIcon an icon for tiling the border area.\n+   */\n+  public MatteBorder(Icon tileIcon)\n+  {\n+    this(-1, -1, -1, -1, tileIcon);\n+  }\n+  \n+  \n+  /**\n+   * Paints the border for a given component.\n+   *\n+   * @param c the component whose border is to be painted.\n+   * @param g the graphics for painting.\n+   * @param x the horizontal position for painting the border.\n+   * @param y the vertical position for painting the border.\n+   * @param width the width of the available area for painting the border.\n+   * @param height the height of the available area for painting the border.\n+   */\n+  public void paintBorder(Component c, Graphics  g,\n+                          int x, int y, int width, int height)\n+  {\n+    Insets i = getBorderInsets();\n+    paintEdge(c, g, x, y, width, i.top, 0, 0);      // top edge\n+    paintEdge(c, g, x, y + height - i.bottom,       // bottom edge\n+              width, i.bottom,\n+              0, height - i.bottom);\n+    paintEdge(c, g, x, y + i.top,                   // left edge\n+              i.left, height - i.top,\n+              0, i.top);\n+    paintEdge(c, g, x + width - i.right, y + i.top, // right edge\n+              i.right, height - i.bottom,\n+              width - i.right, i.top);\n   }\n+  \n+  \n+  /**\n+   * Measures the width of this border.\n+   *\n+   * @param c the component whose border is to be measured.\n+   *\n+   * @return an Insets object whose <code>left</code>, <code>right</code>,\n+   *         <code>top</code> and <code>bottom</code> fields indicate the\n+   *         width of the border at the respective edge.\n+   *\n+   * @see #getBorderInsets(java.awt.Component, java.awt.Insets)\n+   */\n+  public Insets getBorderInsets(Component c)\n+  {\n+    /* There is no obvious reason for overriding this method, but we\n+     * try to have exactly the same API as the Sun reference\n+     * implementation.\n+     */\n+    return this.getBorderInsets(c, null);\n+  }\n+  \n+  \n+  /**\n+   * Measures the width of this border, storing the results into a\n+   * pre-existing Insets object.\n+   *\n+   * @param insets an Insets object for holding the result values.\n+   *        After invoking this method, the <code>left</code>,\n+   *        <code>right</code>, <code>top</code> and\n+   *        <code>bottom</code> fields indicate the width of the\n+   *        border at the respective edge.\n+   *\n+   * @return the same object that was passed for <code>insets</code>.\n+   *\n+   * @see #getBorderInsets()\n+   */\n+  public Insets getBorderInsets(Component c, Insets insets)\n+  {\n+    if (insets == null)\n+      insets = new Insets(0, 0, 0, 0);\n+\n+    if ((tileIcon != null)\n+        && (top < 0) && (left < 0)\n+        && (right < 0) && (bottom < 0))\n+    {\n+      insets.left = insets.right = tileIcon.getIconWidth();\n+      insets.top = insets.bottom = tileIcon.getIconHeight();\n+      return insets;\n+    }\n \n-  public MatteBorder (int top, int left, int bottom, int right, Color color)\n+    /* Copy top, left, bottom and right into the respective\n+     * field of insets.\n+     */\n+    return super.getBorderInsets(c, insets);\n+  }\n+  \n+  \n+  /**\n+   * Measures the width of this border.\n+   *\n+   * @return an Insets object whose <code>left</code>, <code>right</code>,\n+   *         <code>top</code> and <code>bottom</code> fields indicate the\n+   *         width of the border at the respective edge.\n+   *\n+   * @see #getBorderInsets(java.awt.Component, java.awt.Insets)\n+   */\n+  public Insets getBorderInsets()\n+  {\n+    /* The inherited implementation of EmptyBorder.isBorderOpaque()\n+     * would do the same. It is not clear why this is overriden in the\n+     * Sun implementation, at least not from just reading the JavaDoc.\n+     */\n+    return this.getBorderInsets(null, null);\n+  }\n+  \n+  \n+  /**\n+   * Returns the color that is used for filling the border, or\n+   * <code>null</code> if the border is filled with repetitions of a\n+   * tile icon.\n+   */\n+  public Color getMatteColor()\n   {\n-    super (top, left, bottom, right);\n-    this.color = color;\n+    return color;\n   }\n-    \n-    public boolean isBorderOpaque()\n+  \n+  \n+  /**\n+   * Returns the icon is used for tiling the border, or\n+   * <code>null</code> if the border is filled with a color instead of\n+   * an icon.\n+   */\n+  public Icon getTileIcon()\n+  {\n+    return tileIcon;\n+  }\n+  \n+  \n+  /**\n+   * Determines whether this border fills every pixel in its area\n+   * when painting.\n+   *\n+   * @return <code>true</code> if the border is filled with an\n+   *         opaque color; <code>false</code> if it is filled with\n+   *         a semi-transparent color or with an icon.\n+   */\n+  public boolean isBorderOpaque()\n+  {\n+    return (color != null) && (color.getAlpha() == 255);\n+  }\n+  \n+\n+  /**\n+   * Paints a rectangular area of the border. This private helper\n+   * method is called once for each of the border edges\n+   * by {@link #paintBorder}.\n+   *\n+   * @param c the component whose border is being painted.\n+   * @param g the graphics for painting.\n+   * @param x the horizontal position of the rectangular area.\n+   * @param y the vertical position of the rectangular area.\n+   * @param width the width of the rectangular area.\n+   * @param height the height of the rectangular area.\n+   * @param dx the x displacement for repeating the tile.\n+   * @param dy the y displacement for repeating the tile.\n+   */\n+  private void paintEdge(Component c, Graphics g,\n+                         int x, int y, int width, int height,\n+                         int dx, int dy)\n+  {\n+    Color oldColor;\n+    int iconWidth, iconHeight;\n+    Graphics clipped;\n+\n+    if ((width <= 0) || (height <= 0))\n+      return;\n+\n+    /* Paint a colored rectangle if desired. */\n+    if (color != null)\n     {\n-\treturn false;\n+      oldColor = g.getColor();\n+      try\n+      {\n+        g.setColor(color);\n+        g.fillRect(x, y, width, height);\n+      }\n+      finally\n+      {\n+        g.setColor(oldColor);\n+      }\n+      return;\n     }\n-    \n-    public void paintBorder(Component  c,\n-\t\t\t    Graphics  g, \n-\t\t\t    int  x, \n-\t\t\t    int  y, \n-\t\t\t    int  width, \n-\t\t\t    int  height)\n+\n+    /* Determine the width and height of the icon. Some icons return\n+     * -1 if it is an image whose dimensions have not yet been\n+     * retrieved. There is not much we can do about this, but we\n+     * should at least avoid entering the paint loop below\n+     * with negative increments.\n+     */\n+    iconWidth = tileIcon.getIconWidth();\n+    iconHeight = tileIcon.getIconHeight();\n+    if ((iconWidth <= 0) || (iconHeight <= 0))\n+      return;\n+\n+    dx = dx % iconWidth;\n+    dy = dy % iconHeight;\n+\n+    clipped = g.create();\n+    try\n+    {\n+      clipped.setClip(x, y, width, height);\n+      for (int ty = y - dy; ty < y + height; ty += iconHeight)\n+        for (int tx = x - dx; tx < x + width; tx += iconWidth)\n+          tileIcon.paintIcon(c, clipped, tx, ty);\n+    }\n+    finally\n     {\n+      clipped.dispose();\n     }\n+  }\n }\n "}, {"sha": "7b2fca71be499564eba43984f8bf9362f371763a", "filename": "libjava/javax/swing/border/SoftBevelBorder.java", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2FSoftBevelBorder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2FSoftBevelBorder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2FSoftBevelBorder.java?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "patch": "@@ -0,0 +1,327 @@\n+/* SoftBevelBorder.java -- \n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.border;\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+\n+\n+/**\n+ * A rectangular, three pixel thick border that looks like a BevelBorder\n+ * with slightly softened corners.\n+ *\n+ * <p>Like BevelBorder, SoftBevelBorder has a highlight and a shadow\n+ * color. In the raised variant, the highlight color is used for the\n+ * top and left edges, and the shadow color is used for the bottom and\n+ * right edge.  In the lowered variant, color usage is reversed.  For\n+ * an image, see the documentation of the individual constructors.\n+ *\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n+ */\n+public class SoftBevelBorder\n+  extends BevelBorder\n+{\n+  /**\n+   * Determined using the <code>serialver</code> tool\n+   * of Apple/Sun JDK 1.3.1 on MacOS X 10.1.5.\n+   */\n+  static final long serialVersionUID = -6658357140774549493L;\n+\n+\n+  /**\n+   * Constructs a SoftBevelBorder whose colors will be derived from the\n+   * background of the enclosed component. The background color is\n+   * retrieved each time the border is painted, so a SoftBevelBorder\n+   * constructed by this method will automatically reflect a change\n+   * to the component&#x2019;s background color.\n+   *\n+   * <p><img src=\"SoftBevelBorder-1.png\" width=\"500\" height=\"200\"\n+   * alt=\"[An illustration showing raised and lowered SoftBevelBorders]\" />\n+   *\n+   * @param bevelType the desired appearance of the border. The value\n+   *        must be either {@link BevelBorder#RAISED}\n+   *        or {@link BevelBorder#LOWERED}.\n+   *\n+   * @throws IllegalArgumentException if <code>bevelType</code> has\n+   *         an unsupported value.\n+   */\n+  public SoftBevelBorder(int bevelType)\n+  {\n+    super(bevelType);\n+  }\n+\n+\n+  /**\n+   * Constructs a SoftBevelBorder given its appearance type and two\n+   * colors for its highlight and shadow.\n+   *\n+   * <p><img src=\"SoftBevelBorder-2.png\" width=\"500\" height=\"150\"\n+   * alt=\"[An illustration showing SoftBevelBorders that were\n+   * constructed with this method]\" />\n+   *\n+   * @param bevelType the desired appearance of the border. The value\n+   *        must be either {@link BevelBorder#RAISED} or {@link\n+   *        BevelBorder#LOWERED}.\n+   *\n+   * @param highlight the color that will be used for the inner side\n+   *        of the highlighted edges (top and left if if\n+   *        <code>bevelType</code> is {@link BevelBorder#RAISED};\n+   *        bottom and right otherwise). The color for the outer side\n+   *        is a brightened version of this color.\n+   *\n+   * @param shadow the color that will be used for the outer side of\n+   *        the shadowed edges (bottom and right if\n+   *        <code>bevelType</code> is {@link BevelBorder#RAISED}; top\n+   *        and left otherwise). The color for the inner side is a\n+   *        brightened version of this color.\n+   *\n+   * @throws IllegalArgumentException if <code>bevelType</code> has an\n+   *        unsupported value.\n+   *\n+   * @throws NullPointerException if <code>highlight</code> or\n+   *         <code>shadow</code> is <code>null</code>.\n+   *\n+   * @see java.awt.Color.brighter()\n+   */\n+  public SoftBevelBorder(int bevelType, Color highlight, Color shadow)\n+  {\n+    this(bevelType,\n+         /* highlightOuter */ highlight.brighter(),\n+         /* highlightInner */ highlight,\n+         /* shadowOuter */    shadow,\n+         /* shadowInner */    shadow.brighter());\n+  }\n+\n+\n+  /**\n+   * Constructs a SoftBevelBorder given its appearance type and all\n+   * colors.\n+   *\n+   * <p><img src=\"SoftBevelBorder-3.png\" width=\"500\" height=\"150\"\n+   * alt=\"[An illustration showing SoftBevelBorders that were\n+   * constructed with this method]\" />\n+   *\n+   * @param bevelType the desired appearance of the border. The value\n+   *        must be either {@link BevelBorder#RAISED} or {@link\n+   *        BevelBorder#LOWERED}.\n+   *\n+   * @param highlightOuter the color that will be used for the outer\n+   *        side of the highlighted edges (top and left if\n+   *        <code>bevelType</code> is {@link BevelBorder#RAISED};\n+   *        bottom and right otherwise).\n+   *\n+   * @param highlightInner the color that will be used for the inner\n+   *        side of the highlighted edges.\n+   *\n+   * @param shadowOuter the color that will be used for the outer side\n+   *        of the shadowed edges (bottom and right if\n+   *        <code>bevelType</code> is {@link BevelBorder#RAISED}; top\n+   *        and left otherwise).\n+   *\n+   * @param shadowInner the color that will be used for the inner\n+   *        side of the shadowed edges.\n+   *\n+   * @throws IllegalArgumentException if <code>bevelType</code> has\n+   *         an unsupported value.\n+   *\n+   * @throws NullPointerException if one of the passed colors\n+   *         is <code>null</code>.\n+   */\n+  public SoftBevelBorder(int bevelType,\n+                         Color highlightOuter, Color highlightInner,\n+                         Color shadowOuter, Color shadowInner)\n+  {\n+    super(bevelType,\n+          highlightOuter, highlightInner,\n+          shadowOuter, shadowInner);\n+  }\n+\n+\n+  /**\n+   * Paints the border for a given component.\n+   *\n+   * @param c the component whose border is to be painted.\n+   * @param g the graphics for painting.\n+   * @param x the horizontal position for painting the border.\n+   * @param y the vertical position for painting the border.\n+   * @param width the width of the available area for painting the border.\n+   * @param height the height of the available area for painting the border.\n+   */\n+  public void paintBorder(Component c, Graphics  g,\n+                          int x, int y, int width, int height)\n+  {\n+    switch (bevelType)\n+    {\n+    case RAISED:\n+      paintSoftBevel(g, x, y, width, height,\n+                     getHighlightOuterColor(c), getHighlightInnerColor(c),\n+                     getShadowInnerColor(c), getShadowOuterColor(c));\n+      break;\n+\n+    case LOWERED:\n+      paintSoftBevel(g, x, y, width, height,\n+                     getShadowOuterColor(c), getShadowInnerColor(c),\n+                     getHighlightInnerColor(c), getHighlightOuterColor(c));\n+      break;\n+    }\n+  }\n+\n+\n+  /**\n+   * Measures the width of this border.\n+   *\n+   * @param c the component whose border is to be measured.\n+   *\n+   * @return an Insets object whose <code>left</code>, <code>right</code>,\n+   *         <code>top</code> and <code>bottom</code> fields indicate the\n+   *         width of the border at the respective edge.\n+   *\n+   * @see #getBorderInsets(java.awt.Component, java.awt.Insets)\n+   */\n+  public Insets getBorderInsets(Component c)\n+  {\n+    return new Insets(3, 3, 3, 3);\n+  }\n+\n+\n+  /**\n+   * Measures the width of this border, storing the results into a\n+   * pre-existing Insets object.\n+   *\n+   * @param insets an Insets object for holding the result values.\n+   *        After invoking this method, the <code>left</code>,\n+   *        <code>right</code>, <code>top</code> and\n+   *        <code>bottom</code> fields indicate the width of the\n+   *        border at the respective edge.\n+   *\n+   * @return the same object that was passed for <code>insets</code>.\n+   *\n+   * @see #getBorderInsets()\n+   */\n+  public Insets getBorderInsets(Component c, Insets insets)\n+  {\n+    insets.left = insets.right = insets.top = insets.bottom = 3;\n+    return insets;\n+  }\n+\n+  \n+  /**\n+   * Determines whether this border fills every pixel in its area\n+   * when painting.\n+   *\n+   * <p>The enlarged view (see documentation for constructors) shows\n+   * that a SoftBevelBorder does not paint all pixels. Therefore,\n+   * this method always returns <code>false</code>.\n+   *\n+   * @return <code>false</code>.\n+   */\n+  public boolean isBorderOpaque()\n+  {\n+    return false;\n+  }\n+\n+\n+  /**\n+   * Paints a soft bevel in four colors.\n+   * \n+   * <pre>\n+   * @@@@@@@@@@@.\n+   * @@.........#    @ = color a\n+   * @..        #    . = color b\n+   * @.         #    X = color c\n+   * ..        X#    # = color d\n+   * . ##########</pre>\n+   *\n+   * @param g the graphics for painting.\n+   * @param x the horizontal position for painting the border.\n+   * @param y the vertical position for painting the border.\n+   * @param width the width of the available area for painting the border.\n+   * @param height the height of the available area for painting the border.\n+   * @param a the color for the outer side of the top and left edges.\n+   * @param b the color for the inner side of the top and left edges.\n+   * @param c the color for the inner side of the bottom and right edges.\n+   * @param d the color for the outer side of the bottom and right edges.\n+   */\n+  private static void paintSoftBevel(Graphics g,\n+                                     int x, int y, int width, int height,\n+                                     Color a, Color b, Color c, Color d)\n+  {\n+    Color oldColor;\n+\n+    oldColor = g.getColor();\n+    g.translate(x, y);\n+    width = width - 1;\n+    height = height - 1;\n+\n+    try\n+    {\n+      /* To understand this code, it might be helpful to look at the\n+       * images that are included with the JavaDoc, especially\n+       * SoftBevelBorder-3.png. They are located in the \"doc-files\"\n+       * subdirectory.\n+       */\n+      g.setColor(a);\n+      g.drawLine(0, 0, width - 1, 0);                   // a, horizontal\n+      g.drawLine(0, 1, 2, 1);                           // a, horizontal\n+      g.drawLine(0, 2, 0, height - 1);                  // a, vertical\n+\n+      g.setColor(b);\n+      g.drawLine(width, 0, width, 0);                   // b, horizontal\n+      g.drawLine(2, 1, width - 1, 1);                   // b, horizontal\n+      g.drawLine(1, 2, 2, 2);                           // b, horizontal\n+      g.drawLine(1, 3, 1, height - 1);                  // b, vertical\n+      g.drawLine(0, height - 1, 0, height);             // b, vertical\n+\n+      g.setColor(c);\n+      g.drawLine(width - 1, height - 1,                 // c, one pixel\n+                 width - 1, height - 1);\n+\n+      g.setColor(d);\n+      g.drawLine(2, height, width, height);             // d, horizontal\n+      g.drawLine(width, 2, width, height - 1);          // d, vertical\n+    }\n+    finally\n+    {\n+      g.translate(-x, -y);\n+      g.setColor(oldColor);\n+    }\n+  }\n+}\n+"}, {"sha": "3b6a791630c57f4d530060fdfc46f8a6898d0ee8", "filename": "libjava/javax/swing/border/TitledBorder.java", "status": "modified", "additions": 1061, "deletions": 51, "changes": 1112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2FTitledBorder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2FTitledBorder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2FTitledBorder.java?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "patch": "@@ -1,5 +1,5 @@\n /* TitledBorder.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -42,104 +42,1114 @@\n import java.awt.Component;\n import java.awt.Dimension;\n import java.awt.Font;\n+import java.awt.FontMetrics;\n import java.awt.Graphics;\n import java.awt.Insets;\n+import java.awt.Rectangle;\n+import java.awt.Shape;\n+import javax.swing.UIManager;\n \n-public class TitledBorder extends AbstractBorder\n+\n+/**\n+ * A border that paints a title on top of another border.\n+ *\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n+ */\n+public class TitledBorder\n+  extends AbstractBorder\n {\n-  public static final int ABOVE_BOTTOM = 4;\n+  /**\n+   * A value for the <code>titlePosition</code> property that vertically\n+   * positions the title text at the default vertical position, which\n+   * is in the middle of the top line of the border.\n+   *\n+   * @see #getTitlePosition()\n+   * @see #setTitlePosition(int)\n+   */\n+  public static final int DEFAULT_POSITION = 0;\n+\n+\n+  /**\n+   * A value for the <code>titlePosition</code> property that vertically\n+   * positions the title text above the top line of the border.\n+   *\n+   * @see #getTitlePosition()\n+   * @see #setTitlePosition(int)\n+   */\n   public static final int ABOVE_TOP = 1;\n-  public static final int BELOW_BOTTOM = 6;\n+\n+\n+  /**\n+   * A value for the <code>titlePosition</code> property that vertically\n+   * positions the title text at the middle of the top line\n+   * of the border.\n+   *\n+   * @see #getTitlePosition()\n+   * @see #setTitlePosition(int)\n+   */\n+  public static final int TOP = 2;\n+\n+\n+  /**\n+   * A value for the <code>titlePosition</code> property that vertically\n+   * positions the title text below the top line of the border.\n+   *\n+   * @see #getTitlePosition()\n+   * @see #setTitlePosition(int)\n+   */\n   public static final int BELOW_TOP = 3;\n+\n+\n+  /**\n+   * A value for the <code>titlePosition</code> property that vertically\n+   * positions the title text above the bottom line of the border.\n+   *\n+   * @see #getTitlePosition()\n+   * @see #setTitlePosition(int)\n+   */\n+  public static final int ABOVE_BOTTOM = 4;\n+\n+\n+  /**\n+   * A value for the <code>titlePosition</code> property that vertically\n+   * positions the title text at the center of the bottom line\n+   * of the border.\n+   *\n+   * @see #getTitlePosition()\n+   * @see #setTitlePosition(int)\n+   */\n   public static final int BOTTOM = 5;\n-  public static final int CENTER = 2;\n+\n+\n+  /**\n+   * A value for the <code>titlePosition</code> property that vertically\n+   * positions the title text below the bottom line of the border.\n+   *\n+   * @see #getTitlePosition()\n+   * @see #setTitlePosition(int)\n+   */\n+  public static final int BELOW_BOTTOM = 6;\n+\n+\n+  /**\n+   * A value for the <code>titleJustification</code> property that\n+   * horizontally aligns the title text with either the left or the\n+   * right edge of the border, depending on the orientation of the\n+   * component nested into the border. If the component orientation\n+   * is left-to-right, the title text is aligned with the left edge;\n+   * otherwise, it is aligned with the right edge.  This is the same\n+   * behavior as with {@link #LEADING}.\n+   *\n+   * @see #getTitleJustification()\n+   * @see #setTitleJustification(int)\n+   * @see java.awt.ComponentOrientation#isLeftToRight()\n+   */\n   public static final int DEFAULT_JUSTIFICATION = 0;\n-  public static final int DEFAULT_POSITION = 0;\n-  public static final int LEADING = 4;\n+\n+\n+  /**\n+   * A value for the <code>titleJustification</code> property that\n+   * horizontally aligns the title text with the left-hand edge of\n+   * the border.\n+   *\n+   * @see #getTitleJustification()\n+   * @see #setTitleJustification(int)\n+   */\n   public static final int LEFT = 1;\n+\n+\n+  /**\n+   * A value for the <code>titleJustification</code> property that\n+   * horizontally aligns the title text with the center of the border.\n+   *\n+   * @see #getTitleJustification()\n+   * @see #setTitleJustification(int)\n+   */\n+  public static final int CENTER = 2;\n+\n+\n+  /**\n+   * A value for the <code>titleJustification</code> property that\n+   * horizontally aligns the title text with the right-hand edge of\n+   * the border.\n+   *\n+   * @see #getTitleJustification()\n+   * @see #setTitleJustification(int)\n+   */\n   public static final int RIGHT = 3;\n-  public static final int TOP = 2;\n+\n+\n+  /**\n+   * A value for the <code>titleJustification</code> property that\n+   * horizontally aligns the title text with either the left or the\n+   * right edge of the border, depending on the orientation of the\n+   * component nested into the border. If the component orientation\n+   * is left-to-right, the title text is aligned with the left edge;\n+   * otherwise, it is aligned with the right edge. This is the same\n+   * behavior as with {@link #DEFAULT_JUSTIFICATION}.\n+   *\n+   * @see #getTitleJustification()\n+   * @see #setTitleJustification(int)\n+   * @see java.awt.ComponentOrientation#isLeftToRight()\n+   */\n+  public static final int LEADING = 4;\n+\n+\n+  /**\n+   * A value for the <code>titleJustification</code> property that\n+   * horizontally aligns the title text with either the right or the\n+   * left edge of the border, depending on the orientation of the\n+   * component nested into the border. If the component orientation\n+   * is left-to-right, the title text is aligned with the right edge;\n+   * otherwise, it is aligned with the left edge.\n+   *\n+   * @see #getTitleJustification()\n+   * @see #setTitleJustification(int)\n+   * @see java.awt.ComponentOrientation#isLeftToRight()\n+   */\n   public static final int TRAILING = 5;\n \n+\n+  /**\n+   * The number of pixels between the inside of {@link #border}\n+   * and the bordered component.\n+   */\n   protected static final int EDGE_SPACING = 2;\n+\n+\n+  /**\n+   * The number of pixels between the outside of this TitledBorder\n+   * and the beginning (if left-aligned) or end (if right-aligned)\n+   * of the title text.\n+   */\n   protected static final int TEXT_INSET_H = 5;\n+\n+\n+  /**\n+   * The number of pixels between the title text and {@link #border}.\n+   * This value is only relevant if the title text does not intersect\n+   * {@link #border}. No intersection occurs if {@link #titlePosition}\n+   * is one of {@link #ABOVE_TOP}, {@link #BELOW_TOP}, {@link #ABOVE_BOTTOM},\n+   * or {@link #BELOW_BOTTOM}.\n+   */\n   protected static final int TEXT_SPACING = 2;\n \n-  protected Border border;\n+\n+  /**\n+   * Determined using the <code>serialver</code> tool of Apple/Sun JDK 1.3.1\n+   * on MacOS X 10.1.5.\n+   */\n+  static final long serialVersionUID = 8012999415147721601L;\n+  \n+\n+  /**\n+   * The title, or <code>null</code> to display no title.\n+   */\n   protected String title;\n-  protected Color titleColor;\n-  protected Font titleFont;\n-  protected int titleJustification;\n-  protected int titlePosition;\n \n-  private static Border defaultBorder = new LineBorder (Color.black);\n-  private static Font defaultFont = null;\n-  private static Color defaultColor = Color.black;\n+\n+  /**\n+   * The border underneath the title. If this value is\n+   * <code>null</code>, the border will be retrieved from the {@link\n+   * javax.swing.UIManager}&#x2019;s defaults table using the key\n+   * <code>&quot;TitledBorder.border&quot;</code>.\n+   */\n+  protected Border border;\n+\n   \n-  public TitledBorder (String title)\n+  /**\n+   * The vertical position of the title text relative to the border,\n+   * which is one of {@link #ABOVE_TOP}, {@link #TOP}, {@link\n+   * #BELOW_TOP}, {@link #ABOVE_BOTTOM}, {@link #BOTTOM}, {@link\n+   * #BELOW_BOTTOM}, or {@link #DEFAULT_POSITION}.\n+   */\n+  protected int titlePosition;\n+\n+\n+  /**\n+   * The horizontal alignment of the title text in relation to the\n+   * border, which is one of {@link #LEFT}, {@link #CENTER}, {@link\n+   * #RIGHT}, {@link #LEADING}, {@link #TRAILING}, or {@link\n+   * #DEFAULT_JUSTIFICATION}.\n+   */\n+  protected int titleJustification;\n+\n+\n+  /**\n+   * The font for displaying the title text. If this value is\n+   * <code>null</code>, the font will be retrieved from the {@link\n+   * javax.swing.UIManager}&#x2019;s defaults table using the key\n+   * <code>&quot;TitledBorder.font&quot;</code>.\n+   */\n+  protected Font titleFont;\n+\n+\n+  /**\n+   * The color for displaying the title text. If this value is\n+   * <code>null</code>, the color will be retrieved from the {@link\n+   * javax.swing.UIManager}&#x2019;s defaults table using the key\n+   * <code>&quot;TitledBorder.titleColor&quot;</code>.\n+   */\n+  protected Color titleColor;\n+\n+\n+  /**\n+   * Constructs a TitledBorder given the text of its title.\n+   *\n+   * @param title the title text, or <code>null</code> to use no title text.\n+   */\n+  public TitledBorder(String title)\n   {\n-    this (defaultBorder, title, DEFAULT_JUSTIFICATION, DEFAULT_POSITION,\n-\t  defaultFont, defaultColor);\n+    this(/* border */ null,\n+         title, DEFAULT_JUSTIFICATION, DEFAULT_POSITION,\n+         /* titleFont */ null, /* titleColor */ null);\n   }\n \n-  public TitledBorder (Border border)\n+\n+  /**\n+   * Constructs an initially untitled TitledBorder given another border.\n+   *\n+   * @param border the border underneath the title, or <code>null</code>\n+   *        to use a default from the current look and feel.\n+   */\n+  public TitledBorder(Border border)\n   {\n-    this (border, \"\", DEFAULT_JUSTIFICATION, DEFAULT_POSITION, defaultFont,\n-\t  defaultColor);\n+    this(border, /* title */ \"\", DEFAULT_JUSTIFICATION, DEFAULT_POSITION,\n+         /* titleFont */ null, /* titleColor */ null);\n   }\n   \n-  public TitledBorder (Border border, String title)\n+\n+  /**\n+   * Constructs a TitledBorder given its border and title text.\n+   *\n+   * @param border the border underneath the title, or <code>null</code>\n+   *        to use a default from the current look and feel.\n+   *\n+   * @param title the title text, or <code>null</code> to use no title\n+   *        text.\n+   */\n+  public TitledBorder(Border border, String title)\n   {\n-    this (border, title, DEFAULT_JUSTIFICATION, DEFAULT_POSITION, defaultFont,\n-\t  defaultColor);\n+    this(border, title, DEFAULT_JUSTIFICATION, DEFAULT_POSITION,\n+         /* titleFont */ null, /* titleColor */ null);\n   }\n   \n-  public TitledBorder (Border border, String title, int titleJustification,\n-                       int titlePosition)\n+\n+  /**\n+   * Constructs a TitledBorder given its border, title text, horizontal\n+   * alignment, and vertical position.\n+   *\n+   * @param border the border underneath the title, or <code>null</code>\n+   *        to use a default from the current look and feel.\n+   *\n+   * @param title the title text, or <code>null</code> to use no title\n+   *        text.\n+   *\n+   * @param titleJustification the horizontal alignment of the title\n+   *        text in relation to the border. The value must be one of\n+   *        {@link #LEFT}, {@link #CENTER}, {@link #RIGHT}, {@link #LEADING},\n+   *        {@link #TRAILING}, or {@link #DEFAULT_JUSTIFICATION}.\n+   \n+   * @param titlePosition the vertical position of the title text\n+   *        in relation to the border. The value must be one of\n+   *        {@link #ABOVE_TOP}, {@link #TOP}, {@link #BELOW_TOP},\n+   *        {@link #ABOVE_BOTTOM}, {@link #BOTTOM}, {@link #BELOW_BOTTOM},\n+   *        or {@link #DEFAULT_POSITION}.\n+   *\n+   * @throws IllegalArgumentException if <code>titleJustification</code>\n+   *         or <code>titlePosition</code> have an unsupported value.\n+   */\n+  public TitledBorder(Border border, String title, int titleJustification,\n+                      int titlePosition)\n   {\n-    this (border, title, titleJustification, titlePosition, defaultFont,\n-\t  defaultColor);\n+    this(border, title, titleJustification, titlePosition,\n+         /* titleFont */ null, /* titleColor */ null);\n   }\n   \n-  public TitledBorder (Border border, String title, int titleJustification,\n-                       int titlePosition, Font titleFont)\n+\n+  /**\n+   * Constructs a TitledBorder given its border, title text, horizontal\n+   * alignment, vertical position, and font.\n+   *\n+   * @param border the border underneath the title, or <code>null</code>\n+   *        to use a default from the current look and feel.\n+   *\n+   * @param title the title text, or <code>null</code> to use no title\n+   *        text.\n+   *\n+   * @param titleJustification the horizontal alignment of the title\n+   *        text in relation to the border. The value must be one of\n+   *        {@link #LEFT}, {@link #CENTER}, {@link #RIGHT}, {@link #LEADING},\n+   *        {@link #TRAILING}, or {@link #DEFAULT_JUSTIFICATION}.\n+   *\n+   * @param titlePosition the vertical position of the title text\n+   *        in relation to the border. The value must be one of\n+   *        {@link #ABOVE_TOP}, {@link #TOP}, {@link #BELOW_TOP},\n+   *        {@link #ABOVE_BOTTOM}, {@link #BOTTOM}, {@link #BELOW_BOTTOM},\n+   *        or {@link #DEFAULT_POSITION}.\n+   *\n+   * @param titleFont the font for the title text, or <code>null</code>\n+   *        to use a default from the current look and feel.\n+   *\n+   * @throws IllegalArgumentException if <code>titleJustification</code>\n+   *         or <code>titlePosition</code> have an unsupported value.\n+   */\n+  public TitledBorder(Border border, String title, int titleJustification,\n+                      int titlePosition, Font titleFont)\n   {\n-    this (border, title, titleJustification, titlePosition, titleFont,\n-\t  defaultColor);\n+    this(border, title, titleJustification, titlePosition, titleFont,\n+         /* titleColor */ null);\n   }\n   \n-  public TitledBorder (Border border, String title, int titleJustification,\n-                       int titlePosition, Font titleFont, Color titleColor)\n+\n+  /**\n+   * Constructs a TitledBorder given its border, title text, horizontal\n+   * alignment, vertical position, font, and color.\n+   *\n+   * @param border the border underneath the title, or <code>null</code>\n+   *        to use a default from the current look and feel.\n+   *\n+   * @param title the title text, or <code>null</code> to use no title\n+   *        text.\n+   *\n+   * @param titleJustification the horizontal alignment of the title\n+   *        text in relation to the border. The value must be one of\n+   *        {@link #LEFT}, {@link #CENTER}, {@link #RIGHT}, {@link #LEADING},\n+   *        {@link #TRAILING}, or {@link #DEFAULT_JUSTIFICATION}.\n+   *\n+   * @param titlePosition the vertical position of the title text\n+   *        in relation to the border. The value must be one of\n+   *        {@link #ABOVE_TOP}, {@link #TOP}, {@link #BELOW_TOP},\n+   *        {@link #ABOVE_BOTTOM}, {@link #BOTTOM}, {@link #BELOW_BOTTOM},\n+   *        or {@link #DEFAULT_POSITION}.\n+   *\n+   * @param titleFont the font for the title text, or <code>null</code>\n+   *        to use a default from the current look and feel.\n+   *\n+   * @param titleColor the color for the title text, or <code>null</code>\n+   *        to use a default from the current look and feel.\n+   *\n+   * @throws IllegalArgumentException if <code>titleJustification</code>\n+   *         or <code>titlePosition</code> have an unsupported value.\n+   */\n+  public TitledBorder(Border border, String title, int titleJustification,\n+                      int titlePosition, Font titleFont, Color titleColor)\n   {\n     this.border = border;\n     this.title = title;\n-    this.titleJustification = titleJustification;\n+\n+    /* Invoking the setter methods ensures that the newly constructed\n+     * TitledBorder has valid property values.\n+     */\n+    setTitleJustification(titleJustification);\n+    setTitlePosition(titlePosition);\n+\n+    this.titleFont = titleFont;\n+    this.titleColor = titleColor;\n+  }\n+  \n+  \n+  /**\n+   * Paints the border and the title text.\n+   *\n+   * @param c the component whose border is to be painted.\n+   * @param g the graphics for painting.\n+   * @param x the horizontal position for painting the border.\n+   * @param y the vertical position for painting the border.\n+   * @param width the width of the available area for painting the border.\n+   * @param height the height of the available area for painting the border.\n+   */\n+  public void paintBorder(Component c, Graphics  g, \n+                          int x, int y, int width, int height)\n+  {\n+    Measurements mes = getMeasurements(c);\n+    Font oldFont = g.getFont();\n+    Color oldColor = g.getColor();\n+\n+    /**\n+     * A local helper class for painting the border without changing\n+     * any pixels inside the rectangle of the title text.\n+     */\n+    class BorderPainter\n+    {\n+      private Component c;\n+      private Border b;\n+      private int x, y, width, height;\n+\n+      /**\n+       * Constructs a BorderPainter.\n+       *\n+       * @param c the component whose border is being painted.\n+       * @param b the border object.\n+       * @param x the x coordinate of the rectangle delimiting the border.\n+       * @param y the y coordinate of the rectangle delimiting the border.\n+       * @param width the width of the rectangle delimiting the border.\n+       * @param height the width of the rectangle delimiting the border.\n+       */\n+      public BorderPainter(Component c, Border b,\n+                           int x, int y, int width, int height)\n+      {\n+        this.c = c;\n+        this.b = b;\n+        this.x = x;\n+        this.y = y;\n+        this.width = width;\n+        this.height = height;\n+      }\n+\n+\n+      /**\n+       * Paints the entire border.\n+       */\n+      public void paint(Graphics g)\n+      {\n+        if (b != null)\n+          b.paintBorder(c, g, x, y, width - 1, height - 1);\n+      }\n+\n+\n+      /**\n+       * Paints the border, clipping the drawing operation to a\n+       * given rectangular area.\n+       */\n+      private void paint(Graphics g,\n+                         int clipX, int clipY, int clipWidth, int clipHeight)\n+      {\n+        Shape oldClip = g.getClip();\n+        try\n+        {\n+          g.clipRect(clipX, clipY, clipWidth, clipHeight);\n+          paint(g);\n+        }\n+        finally\n+        {\n+          g.setClip(oldClip);\n+        }\n+      }\n+\n+\n+      /**\n+       * Paints the border without affecting a given rectangular area.\n+       * This is used for painting the border without drawing anything\n+       * underneath the title text.\n+       *\n+       * <p>Since we do not want to introduce unnecessary dependencies\n+       * on Java 2D, we perform the clipping without constructive geometry\n+       * (provided by java.awt.geom.Area). Instead, the border&#x2019;s\n+       * bounding rectangle is split into smaller parts, which are then\n+       * clipped and painted individually.:\n+       *\n+       * <p><pre>\n+       *    +--------------------+          +--------------------+\n+       *    |                    |          |        1           |\n+       *    |   +--------+       |          +---+--------+-------+\n+       *    |   | hole   |       |  |====>  | 2 | hole   |   3   |\n+       *    |   +--------+       |          |---+--------+-------+\n+       *    |                    |          |        4           |\n+       *    +--------------------+          +--------------------+</pre>\n+       *\n+       */\n+      public void paintExcept(Graphics g,\n+                              int holeX, int holeY, int holeWidth, int holeHeight)\n+      {\n+        int stripeHeight;\n+\n+        stripeHeight = holeY - y;\n+        if (stripeHeight > 0)\n+          paint(g, x, y, width, stripeHeight);   // patch #1 in the image above\n+\n+        stripeHeight = holeHeight;\n+        if (stripeHeight > 0)\n+        {\n+          paint(g, x, holeY, holeX - x, stripeHeight);  // patches #2 and #3\n+          paint(g, holeX + holeWidth, holeY, width - (holeX + holeWidth), stripeHeight);\n+        }\n+\n+        stripeHeight = height - (holeY - y + holeHeight);\n+        if (stripeHeight > 0)\n+          paint(g, x, y + height - stripeHeight, width, stripeHeight); // #4\n+      }\n+    };\n+\n+    BorderPainter bp;\n+    int textX, textY, borderWidth, borderHeight;\n+\n+    borderWidth = width - (mes.borderSpacing.left + mes.borderSpacing.right);\n+    borderHeight = height - (mes.borderSpacing.top + mes.borderSpacing.bottom);\n+    bp = new BorderPainter(c, getBorder(),\n+                           x + mes.borderSpacing.left, y + mes.borderSpacing.top,\n+                           borderWidth, borderHeight);\n+\n+    switch (getRealTitleJustification(c))\n+    {\n+    case LEFT:\n+      textX = x + TEXT_INSET_H;\n+      break;\n+\n+    case CENTER:\n+      textX = x + (borderWidth - mes.textWidth) / 2;\n+      break;\n+\n+    case RIGHT:\n+      textX = x + borderWidth - (mes.textWidth + TEXT_INSET_H);\n+      break;\n+\n+    default:\n+      throw new IllegalStateException();\n+    }\n+\n+    switch (titlePosition)\n+    {\n+    case ABOVE_TOP:\n+      textY = y;\n+      break;\n+\n+    case TOP:\n+    case DEFAULT_POSITION:\n+    default:\n+      textY = y + mes.borderSpacing.top + mes.borderInsets.top - mes.textAscent;\n+      break;\n+\n+    case BELOW_TOP:\n+      textY = y + mes.borderSpacing.top + mes.borderInsets.top + TEXT_SPACING;\n+      break;\n+\n+    case ABOVE_BOTTOM:\n+      textY = y + height - mes.borderSpacing.bottom - mes.borderInsets.bottom\n+        - TEXT_SPACING - (mes.textAscent + mes.textDescent);\n+      break;\n+\n+    case BOTTOM:\n+    case BELOW_BOTTOM:\n+      textY = y + height - (mes.textAscent + mes.textDescent);\n+      break;\n+    }\n+\n+    if (mes.trimmedText == null)\n+      bp.paint(g);\n+    else\n+    {\n+      try\n+      {\n+        g.setFont(mes.font);\n+        g.setColor(getTitleColor());\n+        g.drawString(mes.trimmedText, textX, textY + mes.textAscent);\n+      }\n+      finally\n+      {\n+        g.setFont(oldFont);\n+        g.setColor(oldColor);\n+      }\n+      bp.paintExcept(g, textX - 2, textY,\n+                     mes.textWidth + 2, mes.textAscent + mes.textDescent);\n+    }\n+  }\n+  \n+  \n+  /**\n+   * Measures the width of this border.\n+   *\n+   * @param c the component whose border is to be measured.\n+   *\n+   * @return an Insets object whose <code>left</code>, <code>right</code>,\n+   *         <code>top</code> and <code>bottom</code> fields indicate the\n+   *         width of the border at the respective edge.\n+   *\n+   * @see #getBorderInsets(java.awt.Component, java.awt.Insets)\n+   */\n+  public Insets getBorderInsets(Component c)\n+  {\n+    return getBorderInsets(c, new Insets(0, 0, 0, 0));\n+  }\n+  \n+\n+  /**\n+   * Measures the width of this border, storing the results into a\n+   * pre-existing Insets object.\n+   *\n+   * @param insets an Insets object for holding the result values.\n+   *        After invoking this method, the <code>left</code>,\n+   *        <code>right</code>, <code>top</code> and\n+   *        <code>bottom</code> fields indicate the width of the\n+   *        border at the respective edge.\n+   *\n+   * @return the same object that was passed for <code>insets</code>.\n+   *\n+   * @see #getBorderInsets()\n+   */\n+  public Insets getBorderInsets(Component c, Insets insets)\n+  {\n+    return getMeasurements(c).getContentInsets(insets);\n+  }\n+  \n+  \n+  /**\n+   * Returns <code>false</code>, indicating that there are pixels inside\n+   * the area of this border where the background shines through.\n+   *\n+   * @return <code>false</code>.\n+   */\n+  public boolean isBorderOpaque()\n+  {\n+    /* Note that the AbstractBorder.isBorderOpaque would also return\n+     * false, so there is actually no need to override the inherited\n+     * implementation. However, GNU Classpath strives for exact\n+     * compatibility with the Sun reference implementation, which\n+     * overrides isBorderOpaque for unknown reasons.\n+     */\n+    return false;\n+  }\n+\n+\n+  /**\n+   * Returns the text of the title.\n+   *\n+   * @return the title text, or <code>null</code> if no title is\n+   *         displayed.\n+   */\n+  public String getTitle()\n+  {\n+    return title;\n+  }\n+\n+\n+  /**\n+   * Retrieves the border underneath the title. If no border has been\n+   * set, or if it has been set to<code>null</code>, the current\n+   * {@link javax.swing.LookAndFeel} will be asked for a border\n+   * using the key <code>&quot;TitledBorder.border&quot;</code>.\n+   *\n+   * @return a border, or <code>null</code> if the current LookAndFeel\n+   *         does not provide a border for the key\n+   *         <code>&quot;TitledBorder.border&quot;</code>.\n+   *\n+   * @see javax.swing.UIManager#getBorder(Object)\n+   */\n+  public Border getBorder()\n+  {\n+    if (border != null)\n+      return border;\n+\n+    return UIManager.getBorder(\"TitledBorder.border\");\n+  }\n+\n+\n+  /**\n+   * Returns the vertical position of the title text in relation\n+   * to the border.\n+   *\n+   * @return one of the values {@link #ABOVE_TOP}, {@link #TOP},\n+   *         {@link #BELOW_TOP}, {@link #ABOVE_BOTTOM}, {@link #BOTTOM},\n+   *         {@link #BELOW_BOTTOM}, or {@link #DEFAULT_POSITION}.\n+   */\n+  public int getTitlePosition()\n+  {\n+    return titlePosition;\n+  }\n+\n+\n+  /**\n+   * Returns the horizontal alignment of the title text in relation to\n+   * the border.\n+   *\n+   * @return one of the values {@link #LEFT}, {@link #CENTER}, {@link\n+   *         #RIGHT}, {@link #LEADING}, {@link #TRAILING}, or {@link\n+   *         #DEFAULT_JUSTIFICATION}.\n+   */\n+  public int getTitleJustification()\n+  {\n+    return titleJustification;\n+  }\n+\n+\n+  /**\n+   * Retrieves the font for displaying the title text. If no font has\n+   * been set, or if it has been set to<code>null</code>, the current\n+   * {@link javax.swing.LookAndFeel} will be asked for a font\n+   * using the key <code>&quot;TitledBorder.font&quot;</code>.\n+   *\n+   * @return a font, or <code>null</code> if the current LookAndFeel\n+   *         does not provide a font for the key\n+   *         <code>&quot;TitledBorder.font&quot;</code>.\n+   *\n+   * @see javax.swing.UIManager#getFont(Object)\n+   */\n+  public Font getTitleFont()\n+  {\n+    if (titleFont != null)\n+      return titleFont;\n+\n+    return UIManager.getFont(\"TitledBorder.font\");\n+  }\n+\n+\n+  /**\n+   * Retrieves the color for displaying the title text. If no color has\n+   * been set, or if it has been set to<code>null</code>, the current\n+   * {@link javax.swing.LookAndFeel} will be asked for a color\n+   * using the key <code>&quot;TitledBorder.titleColor&quot;</code>.\n+   *\n+   * @return a color, or <code>null</code> if the current LookAndFeel\n+   *         does not provide a color for the key\n+   *         <code>&quot;TitledBorder.titleColor&quot;</code>.\n+   *\n+   * @see javax.swing.UIManager#getColor(Object)\n+   */\n+  public Color getTitleColor()\n+  {\n+    if (titleColor != null)\n+      return titleColor;\n+\n+    return UIManager.getColor(\"TitledBorder.titleColor\");\n+  }\n+\n+\n+  /**\n+   * Sets the text of the title.\n+   *\n+   * @param title the new title text, or <code>null</code> for displaying\n+   *        no text at all.\n+   */\n+  public void setTitle(String title)\n+  {\n+    // Swing borders are not JavaBeans, thus no need to fire an event.\n+    this.title = title;\n+  }\n+\n+\n+  /**\n+   * Sets the border underneath the title.\n+   *\n+   * @param border a border, or <code>null</code> to use the\n+   *        border that is supplied by the current LookAndFeel.\n+   *\n+   * @see #getBorder()\n+   */\n+  public void setBorder(Border border)\n+  {\n+    // Swing borders are not JavaBeans, thus no need to fire an event.\n+    this.border = border;\n+  }\n+\n+\n+  /**\n+   * Sets the vertical position of the title text in relation\n+   * to the border.\n+   *\n+   * @param titlePosition one of the values {@link #ABOVE_TOP},\n+   *        {@link #TOP}, {@link #BELOW_TOP}, {@link #ABOVE_BOTTOM},\n+   *        {@link #BOTTOM}, {@link #BELOW_BOTTOM},\n+   *        or {@link #DEFAULT_POSITION}.\n+   *\n+   * @throws IllegalArgumentException if an unsupported value is passed\n+   *         for <code>titlePosition</code>.\n+   */\n+  public void setTitlePosition(int titlePosition)\n+  {\n+    if ((titlePosition < DEFAULT_POSITION) || (titlePosition > BELOW_BOTTOM))\n+      throw new IllegalArgumentException();\n+\n+    // Swing borders are not JavaBeans, thus no need to fire an event.\n     this.titlePosition = titlePosition;\n+  }\n+\n+\n+  /**\n+   * Sets the horizontal alignment of the title text in relation to the border.\n+   *\n+   * @param titleJustification the new alignment, which must be one of\n+   *        {@link #LEFT}, {@link #CENTER}, {@link #RIGHT}, {@link #LEADING},\n+   *        {@link #TRAILING}, or {@link #DEFAULT_JUSTIFICATION}.\n+   *\n+   * @throws IllegalArgumentException if an unsupported value is passed\n+   *         for <code>titleJustification</code>.\n+   */\n+  public void setTitleJustification(int titleJustification)\n+  {\n+    if ((titleJustification < DEFAULT_JUSTIFICATION)\n+        || (titleJustification > TRAILING))\n+      throw new IllegalArgumentException();\n+\n+    // Swing borders are not JavaBeans, thus no need to fire an event.\n+    this.titleJustification = titleJustification;\n+  }\n+\n+\n+  /**\n+   * Sets the font for displaying the title text.\n+   *\n+   * @param titleFont the font, or <code>null</code> to use the font\n+   *        provided by the current {@link javax.swing.LookAndFeel}.\n+   *\n+   * @see #getTitleFont()\n+   */\n+  public void setTitleFont(Font titleFont)\n+  {\n+    // Swing borders are not JavaBeans, thus no need to fire an event.\n     this.titleFont = titleFont;\n+  }\n+\n+\n+  /**\n+   * Sets the color for displaying the title text.\n+   *\n+   * @param titleColor the color, or <code>null</code> to use the color\n+   *        provided by the current {@link javax.swing.LookAndFeel}.\n+   *\n+   * @see #getTitleColor()\n+   */\n+  public void setTitleColor(Color titleColor)\n+  {\n+    // Swing borders are not JavaBeans, thus no need to fire an event.\n     this.titleColor = titleColor;\n   }\n-    \n-    public Insets getBorderInsets(Component  c,\n-\t\t\t\t  Insets s)\n+\n+\n+  /**\n+   * Calculates the minimum size needed for displaying the border\n+   * and its title.\n+   *\n+   * @param c the Component for which this TitledBorder consitutes\n+   *        a border.\n+   */\n+  public Dimension getMinimumSize(Component c)\n+  {\n+    return getMeasurements(c).getMinimumSize();\n+  }\n+\n+\n+  /**\n+   * Returns the font that is used for displaying the title text for\n+   * a given Component.\n+   *\n+   * @param c the Component for which this TitledBorder is the border.\n+   *\n+   * @return The font returned by {@link #getTitleFont()}, or a fallback\n+   *         if {@link #getTitleFont()} returned <code>null</code>.\n+   */\n+  protected Font getFont(Component c)\n+  {\n+    Font f;\n+\n+    f = getTitleFont();\n+    if (f != null)\n+      return f;\n+\n+    return new Font(\"Dialog\", Font.PLAIN, 12);\n+  }\n+\n+\n+  /**\n+   * Returns the horizontal alignment of the title text in relation to\n+   * the border, mapping the component-dependent alignment constants\n+   * {@link #LEADING}, {@link #TRAILING} and {@link #DEFAULT_JUSTIFICATION}\n+   * to the correct value according to the embedded component&#x2019;s\n+   * orientation.\n+   *\n+   * @param c the Component for which this TitledBorder is the border.\n+   *\n+   * @return one of the values {@link #LEFT}, {@link #CENTER}, or {@link\n+   *         #RIGHT}.\n+   */\n+  private int getRealTitleJustification(Component c)\n+  {\n+    switch (titleJustification)\n+    {\n+    case DEFAULT_JUSTIFICATION:\n+    case LEADING:\n+      if ((c == null) || c.getComponentOrientation().isLeftToRight())\n+        return LEFT;\n+      else\n+        return RIGHT;\n+\n+    case TRAILING:\n+      if ((c == null) || c.getComponentOrientation().isLeftToRight())\n+        return RIGHT;\n+      else\n+        return LEFT;\n+\n+    default:\n+      return titleJustification;\n+    }\n+  }\n+\n+\n+  /**\n+   * Performs various measurements for the current state of this TitledBorder\n+   * and the given Component.\n+   */\n+  private Measurements getMeasurements(Component c)\n+  {\n+    Measurements m = new Measurements();\n+    FontMetrics fmet;\n+\n+    m.font = getFont(c);\n+    fmet = c.getFontMetrics(m.font);\n+    m.border = getBorder();\n+    if (m.border != null)\n+      m.borderInsets = m.border.getBorderInsets(c);\n+    else\n+      m.borderInsets = new Insets(0, 0, 0, 0);\n+\n+    if (title != null)\n     {\n-\ts.left = s.right = s.top = s.bottom = 5;\n-\treturn s;\n+      m.trimmedText = title.trim();\n+      if (m.trimmedText.length() == 0)\n+        m.trimmedText = null;\n     }\n     \n+    m.textAscent = fmet.getAscent();\n+    m.textDescent = fmet.getDescent();\n+    if (m.trimmedText != null)\n+      m.textWidth = fmet.stringWidth(m.trimmedText) + 3;\n+\n+    m.edgeSpacing = new Insets(EDGE_SPACING, EDGE_SPACING, EDGE_SPACING, EDGE_SPACING);\n+    m.borderSpacing = new Insets(0, 0, 0, 0);\n+\n+    switch (titlePosition)\n+    {\n+    case ABOVE_TOP:\n+      m.borderSpacing.top += m.textAscent + m.textDescent + TEXT_SPACING;\n+      break;\n+\n+    case BELOW_TOP:\n+      m.edgeSpacing.top += m.textAscent + m.textDescent + TEXT_SPACING;\n+      break;\n+\n+    case ABOVE_BOTTOM:\n+      m.edgeSpacing.bottom += m.textAscent + m.textDescent + TEXT_SPACING;\n+      break;\n+\n+    case BOTTOM:\n+      m.edgeSpacing.bottom += Math.max(m.textAscent - m.borderInsets.bottom, 0);\n+      m.borderSpacing.bottom += m.textDescent;\n+      break;\n+\n+    case BELOW_BOTTOM:\n+      m.borderSpacing.bottom += m.textAscent + m.textDescent + TEXT_SPACING;\n+      break;\n+\n+    default:\n+      m.borderSpacing.top += m.textAscent;\n+    }\n+\n+    return m;\n+  }\n+\n+\n+  /**\n+   * A private helper class for holding the result of measuring the\n+   * distances of a TitledBorder.  While it would be possible to cache\n+   * these objects, it does not seem to be worth the effort. Note that\n+   * invalidating the cache would be tricky, especially since there is\n+   * no notification mechanism that would inform the cache when\n+   * border has changed, so it would return different insets.\n+   */\n+  private static class Measurements\n+  {\n+    /**\n+     * The font used for displaying the title text. Note that it can\n+     * well be that the TitledBorder&#x2019;s font is <code>null</code>,\n+     * which means that the font is to be retrieved from the current\n+     * LookAndFeel. In this case, this <code>font</code> field will\n+     * contain the result of the retrieval. Therefore, it is safe\n+     * to assume that his <code>font</code> field will never have\n+     * a <code>null</code> value.\n+     */\n+    Font font;\n+\n+\n+    /**\n+     * The number of pixels between the base line and the top of the\n+     * text box.\n+     */\n+    int textAscent;\n+\n+\n+    /**\n+     * The number of pixels between the base line and the bottom of\n+     * the text box.\n+     */\n+    int textDescent;\n+\n+\n+    /**\n+     * The title text after removing leading and trailing white space\n+     * characters. If the title consists only of white space, the\n+     * value of <code>trimmedText</code> will be <code>null</code>.\n+     */\n+    String trimmedText;\n+\n+\n+    /**\n+     * The width of the trimmed title text in pixels.\n+     */\n+    int textWidth;\n+\n+\n+    /**\n+     * The border that constitues the &quot;interior&quot; border\n+     * underneath the title text.\n+     */\n+    Border border;\n+\n+\n+    /**\n+     * The distance between the TitledBorder and the interior border.\n+     */\n+    Insets borderSpacing;\n+\n     \n+    /**\n+     * The width of the interior border, as returned by\n+     * <code>border.getBorderInsets()</code>.\n+     */\n+    Insets borderInsets;\n+\n     \n-    public boolean isBorderOpaque()\n+    /**\n+     * The distance between the interior border and the nested\n+     * Component for which this TitledBorder is a border.\n+     */\n+    Insets edgeSpacing;\n+\n+\n+    /**\n+     * Determines the insets of the nested component when it has a\n+     * TitledBorder as its border. Used by {@link\n+     * TitledBorder#getBorderInsets()}.\n+     *\n+     * @param i an Insets object for storing the results into, or\n+     *        <code>null</code> to cause the creation of a\n+     *        new instance.\n+     *\n+     * @return the <code>i</code> object, or a new Insets object\n+     *         if <code>null</code> was passed for <code>i</code>.\n+     */\n+    public Insets getContentInsets(Insets i)\n     {\n-\treturn false;\n+      if (i == null)\n+        i = new Insets(0, 0, 0, 0);\n+      i.left = borderSpacing.left + borderInsets.left + edgeSpacing.left;\n+      i.right = borderSpacing.right + borderInsets.right + edgeSpacing.right;\n+      i.top = borderSpacing.top + borderInsets.top + edgeSpacing.top;\n+      i.bottom = borderSpacing.bottom + borderInsets.bottom + edgeSpacing.bottom;\n+      return i;\n     }\n-    \n-    public void paintBorder(Component c,\n-\t\t\t    Graphics  g, \n-\t\t\t    int  x,\n-\t\t\t    int  y, \n-\t\t\t    int  width, \n-\t\t\t    int  height)\n+\n+\n+    /**\n+     * Calculates the minimum size needed for displaying the border\n+     * and its title. Used by {@link TitledBorder#getMiminumSize()}.\n+     */\n+    public Dimension getMinimumSize()\n     {\n+      int width;\n+      Insets insets;\n+\n+      insets = getContentInsets(null);\n+      width = Math.max(insets.left + insets.right, textWidth + 2 * TEXT_INSET_H);\n+      return new Dimension(width, insets.top + insets.bottom);\n     }\n+  }\n }\n-"}, {"sha": "8c3e4b27758b44b27a4c4f0a67c2ad8045eec169", "filename": "libjava/javax/swing/border/doc-files/BevelBorder-1.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FBevelBorder-1.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FBevelBorder-1.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FBevelBorder-1.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "ac52d47a7f3a6464b54bec0af21f2782c8f601b9", "filename": "libjava/javax/swing/border/doc-files/BevelBorder-2.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FBevelBorder-2.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FBevelBorder-2.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FBevelBorder-2.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "dd531ff6831e4a067d8d2e248867a414f3a4ed3b", "filename": "libjava/javax/swing/border/doc-files/BevelBorder-3.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FBevelBorder-3.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FBevelBorder-3.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FBevelBorder-3.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "2f21140b1a56d48406efef485d3181fd333efd62", "filename": "libjava/javax/swing/border/doc-files/EmptyBorder-1.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FEmptyBorder-1.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FEmptyBorder-1.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FEmptyBorder-1.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "6b1085c1b8e564e4e981b503bde9425bb02f3a15", "filename": "libjava/javax/swing/border/doc-files/EtchedBorder-1.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FEtchedBorder-1.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FEtchedBorder-1.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FEtchedBorder-1.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "36b07056c479d7f0eaa1c4edeacd37f14fc65d1d", "filename": "libjava/javax/swing/border/doc-files/EtchedBorder-2.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FEtchedBorder-2.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FEtchedBorder-2.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FEtchedBorder-2.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "45b8afc611896ca66e680ec50d97aa503d29e2e4", "filename": "libjava/javax/swing/border/doc-files/LineBorder-1.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FLineBorder-1.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FLineBorder-1.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FLineBorder-1.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "fc49f4b4387e2be85f6bb90ff95957283ba82b25", "filename": "libjava/javax/swing/border/doc-files/MatteBorder-1.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FMatteBorder-1.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FMatteBorder-1.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FMatteBorder-1.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "9c2c8d9556fc04e37b9a898a50e7fce34e84bc83", "filename": "libjava/javax/swing/border/doc-files/MatteBorder-2.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FMatteBorder-2.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FMatteBorder-2.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FMatteBorder-2.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "62089eab5ea475fefa333e7faf32dca94eded801", "filename": "libjava/javax/swing/border/doc-files/MatteBorder-3.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FMatteBorder-3.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FMatteBorder-3.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FMatteBorder-3.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "bffbcc84e47632a4685840dd8ec2f40148bb8834", "filename": "libjava/javax/swing/border/doc-files/MatteBorder-4.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FMatteBorder-4.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FMatteBorder-4.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FMatteBorder-4.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "807eee8df132147d806e9a6e070524b940a4ff08", "filename": "libjava/javax/swing/border/doc-files/MatteBorder-5.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FMatteBorder-5.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FMatteBorder-5.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FMatteBorder-5.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "2c4ce1e3db835b937b4ef5ff6fe9eefeeda25091", "filename": "libjava/javax/swing/border/doc-files/MatteBorder-6.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FMatteBorder-6.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FMatteBorder-6.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FMatteBorder-6.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "4404bf98cc1fc8c9befca241e79e1ee53c8fdc04", "filename": "libjava/javax/swing/border/doc-files/SoftBevelBorder-1.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FSoftBevelBorder-1.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FSoftBevelBorder-1.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FSoftBevelBorder-1.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "ebd9849e618b37ec982d68d6c65072f99915edfb", "filename": "libjava/javax/swing/border/doc-files/SoftBevelBorder-2.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FSoftBevelBorder-2.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FSoftBevelBorder-2.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FSoftBevelBorder-2.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "9f939b7a9e1d558ac6e3a949d27b0e3485191f49", "filename": "libjava/javax/swing/border/doc-files/SoftBevelBorder-3.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FSoftBevelBorder-3.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FSoftBevelBorder-3.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fborder%2Fdoc-files%2FSoftBevelBorder-3.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "22d7d5c0944e811accf47bc9e458a9005252bd03", "filename": "libjava/javax/swing/plaf/BorderUIResource.java", "status": "modified", "additions": 793, "deletions": 165, "changes": 958, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2FBorderUIResource.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2FBorderUIResource.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2FBorderUIResource.java?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "patch": "@@ -1,5 +1,5 @@\n /* BorderUIResource.java\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,6 +37,7 @@\n \n \n package javax.swing.plaf;\n+\n import javax.swing.border.*;\n import javax.swing.Icon;\n import java.io.Serializable;\n@@ -47,233 +48,860 @@\n import java.awt.Color;\n \n /**\n+ * A wrapper for {@link javax.swing.border.Border} that also\n+ * implements the {@link UIResource} marker interface.  This is useful\n+ * for implementing pluggable look-and-feels: When switching the\n+ * current LookAndFeel, only those borders are replaced that are\n+ * marked as {@link UIResource}.  For this reason, a look-and-feel\n+ * should always install borders that implement\n+ * <code>UIResource</code>, such as the borders provided by this\n+ * class.\n+ *\n  * @serial\n  * @serialField delegate Border the <code>Border</code> wrapped\n- * @author Brian Jones\n+ *\n+ * @author Brian Jones (cbj@gnu.org)\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n  */\n public class BorderUIResource \n-    extends Object \n-    implements Border, UIResource, Serializable\n+  extends Object \n+  implements Border, UIResource, Serializable\n {\n+  /**\n+   * Verified using the <code>serialver</code> tool\n+   * of Apple/Sun JDK 1.3.1 on MacOS X 10.1.5.\n+   */\n   static final long serialVersionUID = -3440553684010079691L;\n \n-    private Border delegate;\n \n+  /**\n+   * A shared instance of an {@link EtchedBorderUIResource}, or\n+   * <code>null</code> if the {@link #getEtchedBorderUIResource()}\n+   * method has not yet been called.\n+   */\n+  private static Border etchedBorderUIResource;\n+\n+\n+  /**\n+   * A shared instance of a {@link BevelBorderUIResource} whose\n+   * <code>bevelType</code> is {@link\n+   * javax.swing.border.BevelBorder#LOWERED}, or <code>null</code> if\n+   * the {@link #getLoweredBevelBorderUIResource()} has not yet been\n+   * called.\n+   */\n+  private static Border loweredBevelBorderUIResource;\n+  \n+  \n+  /**\n+   * A shared instance of a {@link BevelBorderUIResource} whose\n+   * <code>bevelType</code> is {@link\n+   * javax.swing.border.BevelBorder#RAISED}, or <code>null</code> if\n+   * the {@link #getRaisedBevelBorderUIResource()} has not yet been\n+   * called.\n+   */\n+  private static Border raisedBevelBorderUIResource;\n+  \n+  \n+  /**\n+   * A shared instance of a {@link LineBorderUIResource} for\n+   * a one-pixel thick black line, or <code>null</code> if\n+   * the {@link #getBlackLineBorderUIResource()} has not yet been\n+   * called.\n+   */\n+  private static Border blackLineBorderUIResource;\n+\n+\n+  /**\n+   * Returns a shared instance of an etched border which also\n+   * is marked as an {@link UIResource}.\n+   *\n+   * @see javax.swing.border.EtchedBorder\n+   */\n+  public static Border getEtchedBorderUIResource()\n+  {\n+    /* Swing is not designed to be thread-safe, so there is no\n+     * need to synchronize the access to the global variable.\n+     */\n+    if (etchedBorderUIResource == null)\n+      etchedBorderUIResource = new EtchedBorderUIResource();\n+    return etchedBorderUIResource;\n+  }\n+  \n+\n+  /**\n+   * Returns a shared instance of {@link BevelBorderUIResource} whose\n+   * <code>bevelType</code> is {@link\n+   * javax.swing.border.BevelBorder#LOWERED}.\n+   *\n+   * @see javax.swing.border.BevelBorder\n+   */\n+  public static Border getLoweredBevelBorderUIResource()\n+  {\n+    /* Swing is not designed to be thread-safe, so there is no\n+     * need to synchronize the access to the global variable.\n+     */\n+    if (loweredBevelBorderUIResource == null)\n+      loweredBevelBorderUIResource = new BevelBorderUIResource(\n+        BevelBorder.LOWERED);\n+    return loweredBevelBorderUIResource;\n+  }\n+\n+\n+  /**\n+   * Returns a shared instance of {@link BevelBorderUIResource} whose\n+   * <code>bevelType</code> is {@link\n+   * javax.swing.border.BevelBorder#RAISED}.\n+   *\n+   * @see javax.swing.border.BevelBorder\n+   */\n+  public static Border getRaisedBevelBorderUIResource()\n+  {\n+    /* Swing is not designed to be thread-safe, so there is no\n+     * need to synchronize the access to the global variable.\n+     */\n+    if (raisedBevelBorderUIResource == null)\n+      raisedBevelBorderUIResource = new BevelBorderUIResource(\n+        BevelBorder.RAISED);\n+    return raisedBevelBorderUIResource;\n+  }\n+  \n+  \n+  /**\n+   * Returns a shared instance of {@link LineBorderUIResource} for\n+   * a black, one-pixel width border.\n+   *\n+   * @see javax.swing.border.LineBorder\n+   */\n+  public static Border getBlackLineBorderUIResource()\n+  {\n+    /* Swing is not designed to be thread-safe, so there is no\n+     * need to synchronize the access to the global variable.\n+     */\n+    if (blackLineBorderUIResource == null)\n+      blackLineBorderUIResource = new LineBorderUIResource(Color.black);\n+    return blackLineBorderUIResource;\n+  }\n+\n+\n+  /**\n+   * The wrapped border.\n+   */\n+  private Border delegate;\n+  \n+  \n+  /**\n+   * Constructs a <code>BorderUIResource</code> for wrapping\n+   * a <code>Border</code> object.\n+   * \n+   * @param delegate the border to be wrapped.\n+   */\n+  public BorderUIResource(Border delegate)\n+  {\n+    if (delegate == null)\n+      throw new IllegalArgumentException();\n+    \n+    this.delegate = delegate;\n+  }\n+\n+  \n+  /**\n+   * Paints the border around an enclosed component by calling\n+   * the <code>paintBorder</code> method of the wrapped delegate.\n+   *\n+   * @param c the component whose border is to be painted.\n+   * @param g the graphics for painting.\n+   * @param x the horizontal position for painting the border.\n+   * @param y the vertical position for painting the border.\n+   * @param width the width of the available area for painting the border.\n+   * @param height the height of the available area for painting the border.\n+   */\n+  public void paintBorder(Component c, Graphics g,\n+                          int x, int y, int width, int height)\n+  {\n+    delegate.paintBorder(c, g, x, y, width, height);\n+  }\n+  \n+  \n+  /**\n+   * Measures the width of this border by calling the\n+   * <code>getBorderInsets</code> method of the wrapped\n+   * delegate.\n+   *\n+   * @param c the component whose border is to be measured.\n+   *\n+   * @return an Insets object whose <code>left</code>, <code>right</code>,\n+   *         <code>top</code> and <code>bottom</code> fields indicate the\n+   *         width of the border at the respective edge.\n+   */\n+  public Insets getBorderInsets(Component c)\n+  { \n+    return delegate.getBorderInsets(c);\n+  }\n+  \n+  \n+  /**\n+   * Determines whether this border fills every pixel in its area\n+   * when painting by calling the <code>isBorderOpaque</code>\n+   * method of the wrapped delegate.\n+   *\n+   * @return <code>true</code> if the border is fully opaque, or\n+   *         <code>false</code> if some pixels of the background\n+   *         can shine through the border.\n+   */\n+  public boolean isBorderOpaque()\n+  { \n+    return delegate.isBorderOpaque();\n+  }\n+\n+\n+  /**\n+   * A {@link javax.swing.border.BevelBorder} that also implements the\n+   * {@link UIResource} marker interface.  This is useful for\n+   * implementing pluggable look-and-feels: When switching the current\n+   * LookAndFeel, only those borders are replaced that are marked as\n+   * {@link UIResource}.  For this reason, a look-and-feel should\n+   * always install borders that implement <code>UIResource</code>,\n+   * such as the borders provided by this class.\n+   *\n+   * @author Brian Jones (cbj@gnu.org)\n+   * @author Sascha Brawer (brawer@dandelis.ch)\n+   */\n+  public static class BevelBorderUIResource \n+    extends BevelBorder\n+    implements UIResource, Serializable\n+  {\n     /**\n-     * Creates a <code>UIResource</code> wrapper for a <code>Border</code>\n-     * object.\n-     * \n-     * @param delegate the border to be wrapped\n+     * Constructs a BevelBorderUIResource whose colors will be derived\n+     * from the background of the enclosed component. The background\n+     * color is retrieved each time the border is painted, so a border\n+     * constructed by this method will automatically reflect a change\n+     * to the component&#x2019;s background color.\n+     *\n+     * <p><img src=\"../border/BevelBorder-1.png\" width=\"500\" height=\"150\"\n+     * alt=\"[An illustration showing raised and lowered BevelBorders]\" />\n+     *\n+     * @param bevelType the desired appearance of the border. The value\n+     *        must be either {@link javax.swing.border.BevelBorder#RAISED}\n+     *        or {@link javax.swing.border.BevelBorder#LOWERED}.\n+     *\n+     * @throws IllegalArgumentException if <code>bevelType</code> has\n+     *         an unsupported value.\n+     */\n+    public BevelBorderUIResource(int bevelType) \n+    { \n+      super(bevelType);\n+    }\n+    \n+    \n+    /**\n+     * Constructs a BevelBorderUIResource given its appearance type\n+     * and two colors for its highlight and shadow.\n+     *\n+     * <p><img src=\"../border/BevelBorder-2.png\" width=\"500\" height=\"150\"\n+     * alt=\"[An illustration showing BevelBorders that were constructed\n+     * with this method]\" />\n+     *\n+     * @param bevelType the desired appearance of the border. The value\n+     *        must be either {@link javax.swing.border.BevelBorder#RAISED}\n+     *        or {@link javax.swing.border.BevelBorder#LOWERED}.\n+     *\n+     * @param highlight the color that will be used for the inner side\n+     *        of the highlighted edges (top and left if if\n+     *        <code>bevelType</code> is {@link\n+     *        javax.swing.border.BevelBorder#RAISED}; bottom and right\n+     *        otherwise). The color for the outer side is a brightened\n+     *        version of this color.\n+     *\n+     * @param shadow the color that will be used for the outer side of\n+     *        the shadowed edges (bottom and right if\n+     *        <code>bevelType</code> is {@link\n+     *        javax.swing.border.BevelBorder#RAISED}; top and left\n+     *        otherwise). The color for the inner side is a brightened\n+     *        version of this color.\n+     *\n+     * @throws IllegalArgumentException if <code>bevelType</code> has\n+     *         an unsupported value.\n+     *\n+     * @throws NullPointerException if <code>highlight</code> or\n+     *         <code>shadow</code> is <code>null</code>.\n      */\n-    public BorderUIResource(Border delegate)\n+    public BevelBorderUIResource(int bevelType, \n+                                 Color highlight, \n+                                 Color shadow) \n     {\n-\tthis.delegate = delegate;\n+      super(bevelType, highlight, shadow);\n     }\n \n+\n     /**\n+     * Constructs a BevelBorderUIResource given its appearance type\n+     * and all its colors.\n+     *\n+     * <p><img src=\"../border/BevelBorder-3.png\" width=\"500\" height=\"150\"\n+     * alt=\"[An illustration showing BevelBorders that were constructed\n+     * with this method]\" />\n+     *\n+     * @param bevelType the desired appearance of the border. The value\n+     *        must be either {@link javax.swing.border.BevelBorder#RAISED}\n+     *        or {@link javax.swing.border.BevelBorder#LOWERED}.\n+     *\n+     * @param highlightOuter the color that will be used for the outer\n+     *        side of the highlighted edges (top and left if\n+     *        <code>bevelType</code> is {@link\n+     *        javax.swing.border.BevelBorder#RAISED}; bottom and right\n+     *        otherwise).\n+     *\n+     * @param highlightInner the color that will be used for the inner\n+     *        side of the highlighted edges.\n+     *\n+     * @param shadowOuter the color that will be used for the outer\n+     *        side of the shadowed edges (bottom and right if\n+     *        <code>bevelType</code> is {@link\n+     *        javax.swing.border.BevelBorder#RAISED}; top and left\n+     *        otherwise).\n+     *\n+     * @param shadowInner the color that will be used for the inner\n+     *        side of the shadowed edges.\n+     *\n+     * @throws IllegalArgumentException if <code>bevelType</code> has\n+     *         an unsupported value.\n+     *\n+     * @throws NullPointerException if one of the passed colors\n+     *         is <code>null</code>.\n      */\n-    public static Border getEtchedBorderUIResource() { \n-\treturn null;\n+    public BevelBorderUIResource(int bevelType,\n+                                 Color highlightOuter,\n+                                 Color highlightInner,\n+                                 Color shadowOuter,\n+                                 Color shadowInner) \n+    {\n+      super(bevelType,\n+            highlightOuter, highlightInner,\n+            shadowOuter, shadowInner);\n     }\n-\n+  }\n+  \n+  \n+  /**\n+   * A {@link javax.swing.border.CompoundBorder} that also implements the\n+   * {@link UIResource} marker interface.  This is useful for\n+   * implementing pluggable look-and-feels: When switching the current\n+   * LookAndFeel, only those borders are replaced that are marked as\n+   * {@link UIResource}.  For this reason, a look-and-feel should\n+   * always install borders that implement <code>UIResource</code>,\n+   * such as the borders provided by this class.\n+   *\n+   * @author Brian Jones (cbj@gnu.org)\n+   * @author Sascha Brawer (brawer@dandelis.ch)\n+   */\n+  public static class CompoundBorderUIResource\n+    extends CompoundBorder\n+    implements UIResource, Serializable\n+  {\n     /**\n+     * Constructs a CompoundBorderUIResource with the specified inside\n+     * and outside borders.\n+     *\n+     * @param outsideBorder the outside border, which is painted to the\n+     *        outside of both <code>insideBorder</code> and the enclosed\n+     *        component. It is acceptable to pass <code>null</code>, in\n+     *        which case no outside border is painted.\n+     *\n+     * @param insideBorder the inside border, which is painted to\n+     *        between <code>outsideBorder</code> and the enclosed\n+     *        component. It is acceptable to pass <code>null</code>, in\n+     *        which case no inside border is painted.\n      */\n-    public static Border getLoweredBevelBorderUIResource() { \n-\treturn null;\n+    public CompoundBorderUIResource(Border outsideBorder,\n+                                    Border insideBorder)\n+    {\n+      super(outsideBorder, insideBorder);\n     }\n-\n+  }\n+  \n+  \n+  /**\n+   * An {@link javax.swing.border.EmptyBorder} that also implements the\n+   * {@link UIResource} marker interface.  This is useful for\n+   * implementing pluggable look-and-feels: When switching the current\n+   * LookAndFeel, only those borders are replaced that are marked as\n+   * {@link UIResource}.  For this reason, a look-and-feel should\n+   * always install borders that implement <code>UIResource</code>,\n+   * such as the borders provided by this class.\n+   *\n+   * <p><img src=\"../border/EmptyBorder-1.png\" width=\"290\" height=\"200\"\n+   * alt=\"[An illustration of EmptyBorder]\" />\n+   *\n+   * @author Brian Jones (cbj@gnu.org)\n+   * @author Sascha Brawer (brawer@dandelis.ch)\n+   */\n+  public static class EmptyBorderUIResource \n+    extends EmptyBorder\n+    implements UIResource, Serializable\n+  {\n     /**\n+     * Constructs an empty border given the number of pixels required\n+     * on each side.\n+     *\n+     * @param top the number of pixels that the border will need\n+     *        for its top edge.\n+     *\n+     * @param left the number of pixels that the border will need\n+     *        for its left edge.\n+     *\n+     * @param bottom the number of pixels that the border will need\n+     *        for its bottom edge.\n+     *\n+     * @param right the number of pixels that the border will need\n+     *        for its right edge.\n      */\n-    public static Border getRaisedBevelBorderUIResource() { \n-\treturn null;\n+    public EmptyBorderUIResource(int top, int left, int bottom, int right)\n+    {\n+      super(top, left, bottom, right);\n     }\n-\n+    \n+    \n     /**\n+     * Constructs an empty border given the number of pixels required\n+     * on each side, passed in an Insets object.\n+     *\n+     * @param insets the Insets for the new border.\n      */\n-    public static Border getBlackLineBorderUIResource() { \n-\treturn null;\n+    public EmptyBorderUIResource(Insets insets)\n+    {\n+      super(insets);\n     }\n-\n+  }\n+  \n+  \n+  /**\n+   * An {@link javax.swing.border.EtchedBorder} that also implements the\n+   * {@link UIResource} marker interface.  This is useful for\n+   * implementing pluggable look-and-feels: When switching the current\n+   * LookAndFeel, only those borders are replaced that are marked as\n+   * {@link UIResource}.  For this reason, a look-and-feel should\n+   * always install borders that implement <code>UIResource</code>,\n+   * such as the borders provided by this class.\n+   *\n+   * <p><img src=\"../border/EtchedBorder-1.png\" width=\"500\" height=\"200\"\n+   * alt=\"[An illustration of the two EtchedBorder variants]\" />\n+   *\n+   * @author Brian Jones (cbj@gnu.org)\n+   * @author Sascha Brawer (brawer@dandelis.ch)\n+   */\n+  public static class EtchedBorderUIResource\n+    extends EtchedBorder\n+    implements UIResource, Serializable\n+  {\n     /**\n+     * Constructs an EtchedBorderUIResource that appears lowered into\n+     * the surface. The colors will be derived from the background\n+     * color of the enclosed Component when the border gets painted.\n      */\n-    public void paintBorder(Component c, Graphics g, int x, int y, \n-\t\t\t    int width, int height) { }\n-\n+    public EtchedBorderUIResource()\n+    {\n+      super();\n+    }\n+    \n+    \n     /**\n+     * Constructs an EtchedBorderUIResource with the specified\n+     * appearance. The colors will be derived from the background\n+     * color of the enclosed Component when the border gets painted.\n+     *\n+     * <p><img src=\"../border/EtchedBorder-1.png\" width=\"500\" height=\"200\"\n+     * alt=\"[An illustration of the two EtchedBorder variants]\" />\n+     *\n+     * @param etchType the desired appearance of the border. The value\n+     *        must be either {@link javax.swing.border.EtchedBorder#RAISED}\n+     *        or {@link javax.swing.border.EtchedBorder#LOWERED}.\n+     *\n+     * @throws IllegalArgumentException if <code>etchType</code> has\n+     *         an unsupported value.\n      */\n-    public Insets getBorderInsets(Component c) { \n-\treturn null;\n+    public EtchedBorderUIResource(int etchType) \n+    {\n+      super(etchType);\n     }\n-\n+    \n+    \n     /**\n+     * Constructs a lowered EtchedBorderUIResource, explicitly\n+     * selecting the colors that will be used for highlight and\n+     * shadow.\n+     *\n+     * @param highlight the color that will be used for painting\n+     *        the highlight part of the border.\n+     *\n+     * @param shadow the color that will be used for painting\n+     *        the shadow part of the border.\n+     *\n+     * @see #EtchedBorderUIResource(int, Color, Color)\n      */\n-    public boolean isBorderOpaque() { \n-\treturn false;\n+    public EtchedBorderUIResource(Color highlight, Color shadow)\n+    {\n+      super(highlight, shadow);\n     }\n-\n+    \n+    \n     /**\n-     * @serial\n+     * Constructs an EtchedBorderUIResource with the specified\n+     * appearance, explicitly selecting the colors that will be used\n+     * for highlight and shadow.\n+     *\n+     * <p><img src=\"../border/EtchedBorder-2.png\" width=\"500\"\n+     * height=\"200\" alt=\"[An illustration that shows which pixels get\n+     * painted in what color]\" />\n+     *\n+     * @param etchType the desired appearance of the border. The value\n+     *        must be either {@link javax.swing.border.EtchedBorder#RAISED}\n+     *        or {@link javax.swing.border.EtchedBorder#LOWERED}.\n+     *\n+     * @param highlight the color that will be used for painting\n+     *        the highlight part of the border.\n+     *\n+     * @param shadow the color that will be used for painting\n+     *        the shadow part of the border.\n+     *\n+     * @throws IllegalArgumentException if <code>etchType</code> has\n+     *         an unsupported value.\n      */\n-    public static class BevelBorderUIResource \n-\textends BevelBorder\n-\timplements UIResource, Serializable\n+    public EtchedBorderUIResource(int etchType,\n+                                  Color highlight, Color shadow)\n     {\n-\tpublic BevelBorderUIResource(int bevelType) \n-\t{ \n-\t    super (bevelType);\n-\t}\n-\n-\tpublic BevelBorderUIResource(int bevelType, \n-\t\t\t\t     Color highlight, \n-\t\t\t\t     Color shadow) \n-\t{\n-\t  super (bevelType, highlight, shadow);\n-\t}\n-\tpublic BevelBorderUIResource(int bevelType,\n-\t\t\t\t     Color highlightOuter,\n-\t\t\t\t     Color highlightInner,\n-\t\t\t\t     Color shadowOuter,\n-\t\t\t\t     Color shadowInner) \n-\t{\n-\t  super (bevelType, highlightOuter, highlightInner, shadowOuter,\n-\t\t shadowInner);\n-\t}\n+      super(etchType, highlight, shadow);\n     }\n-\n+  }\n+  \n+  \n+  /**\n+   * A {@link javax.swing.border.LineBorder} that also implements the\n+   * {@link UIResource} marker interface.  This is useful for\n+   * implementing pluggable look-and-feels: When switching the current\n+   * LookAndFeel, only those borders are replaced that are marked as\n+   * {@link UIResource}.  For this reason, a look-and-feel should\n+   * always install borders that implement <code>UIResource</code>,\n+   * such as the borders provided by this class.\n+   *\n+   * <p><img src=\"../border/LineBorder-1.png\" width=\"500\" height=\"200\"\n+   * alt=\"[An illustration of two LineBorders] />\n+   *\n+   * @author Brian Jones (cbj@gnu.org)\n+   * @author Sascha Brawer (brawer@dandelis.ch)\n+   */\n+  public static class LineBorderUIResource\n+    extends LineBorder\n+    implements UIResource, Serializable\n+  {\n     /**\n-     * @serial\n+     * Constructs a LineBorderUIResource given its color.  The border\n+     * will be one pixel thick and have plain corners.\n+     *\n+     * @param color the color for drawing the border.\n      */\n-    public static class CompoundBorderUIResource\n-\textends CompoundBorder\n-\timplements UIResource, Serializable\n+    public LineBorderUIResource(Color color)\n     {\n-\tpublic CompoundBorderUIResource(Border outsideBorder,\n-\t\t\t\t\tBorder insideBorder)\n-\t{\n-\t  super (outsideBorder, insideBorder);\n-\t}\n+      super(color); \n     }\n-\n+    \n+    \n     /**\n-     * @serial\n+     * Constructs a LineBorder given its color and thickness.  The\n+     * border will have plain corners.\n+     *\n+     * @param color the color for drawing the border.\n+     * @param thickness the width of the line in pixels.\n      */\n-    public static class EmptyBorderUIResource \n-\textends EmptyBorder\n-\timplements UIResource, Serializable\n+    public LineBorderUIResource(Color color, int thickness)\n     {\n-\tpublic EmptyBorderUIResource(int top, int left, int bottom, int right)\n-\t{\n-\t    this(new Insets(top,left,bottom,right));\n-\t}\n-\t\n-\tpublic EmptyBorderUIResource(Insets insets)\n-\t{\n-\t  super (insets);\n-\t}\n+      super(color, thickness);\n     }\n+    \n+    \n+    /* Note: Since JDK1.3, javax.swing.border.LineBorder also has a\n+     * constructor which accepts a value for the roundedCorners\n+     * property. However, as of JDK1.4.1, the LineBorderUIResource\n+     * subclass does not have a corresponding constructor.\n+     * \n+     * A request for enhancing the Swing API has been filed with Sun.\n+     * It currently is under review, its \"review ID\" is 188305.\n+     *\n+     *                         -- Sascha Brawer (brawer@dandelis.ch)\n+     */\n+  }\n+\n \n+  /**\n+   * A {@link javax.swing.border.MatteBorder} that also implements the\n+   * {@link UIResource} marker interface.  This is useful for\n+   * implementing pluggable look-and-feels: When switching the current\n+   * LookAndFeel, only those borders are replaced that are marked as\n+   * {@link UIResource}.  For this reason, a look-and-feel should\n+   * always install borders that implement <code>UIResource</code>,\n+   * such as the borders provided by this class.\n+   *\n+   * <p><img src=\"../border/MatteBorder-1.png\" width=\"500\" height=\"150\"\n+   * alt=\"[An illustration of two MatteBorders] />\n+   *\n+   * @author Brian Jones (cbj@gnu.org)\n+   * @author Sascha Brawer (brawer@dandelis.ch)\n+   */\n+  public static class MatteBorderUIResource\n+    extends MatteBorder\n+    implements UIResource, Serializable\n+  {\n     /**\n-     * @serial\n+     * Constructs a MatteBorderUIResource given the width on each side\n+     * and a fill color.\n+     *\n+     * <p><img src=\"../border/MatteBorder-2.png\" width=\"500\" height=\"150\"\n+     * alt=\"[A picture of a MatteBorder made by this constructor]\" />\n+     *\n+     * @param top the width of the border at its top edge.\n+     * @param left the width of the border at its left edge.\n+     * @param bottom the width of the border at its bottom edge.\n+     * @param right the width of the border at its right edge.\n+     * @param matteColor the color for filling the border.\n      */\n-    public static class EtchedBorderUIResource\n-\textends EtchedBorder\n-\timplements UIResource, Serializable\n+    public MatteBorderUIResource(int top, int left,\n+                                 int bottom, int right,\n+                                 Color color)\n     {\n-\tpublic EtchedBorderUIResource() { }\n-\tpublic EtchedBorderUIResource(int etchType) \n-\t{\n-\t  super (etchType);\n-\t}\n-\tpublic EtchedBorderUIResource(Color highlight, Color shadow)\n-\t{\n-\t  super (highlight, shadow);\n-\t}\n-\tpublic EtchedBorderUIResource(int etchType, Color highlight, \n-\t\t\t\t      Color shadow)\n-\t{\n-          super (etchType, highlight, shadow);\n-\t}\n-\n+      super(top, left, bottom, right, color);\n     }\n-\n+    \n+    \n+    /**\n+     * Constructs a MatteBorderUIResource given the width on each side\n+     * and an icon for tiling the border area.\n+     *\n+     * <p><img src=\"../border/MatteBorder-4.png\" width=\"500\"\n+     * height=\"150\" alt=\"[A picture of a MatteBorder made by this\n+     * constructor]\" />\n+     *\n+     * @param top the width of the border at its top edge.\n+     * @param left the width of the border at its left edge.\n+     * @param bottom the width of the border at its bottom edge.\n+     * @param right the width of the border at its right edge.\n+     * @param tileIcon an icon for tiling the border area.\n+     */\n+    public MatteBorderUIResource(int top, int left,\n+                                 int bottom, int right,\n+                                 Icon tileIcon)\n+    {\n+      super(top, left, bottom, right, tileIcon);\n+    }\n+    \n+    \n     /**\n-     * @serial\n+     * Constructs a MatteBorderUIResource given an icon for tiling the\n+     * border area. The icon width is used for the border insets at\n+     * the left and right edge, the icon height for the top and bottom\n+     * edge.\n+     *\n+     * <p><img src=\"../border/MatteBorder-6.png\" width=\"500\" height=\"150\"\n+     * alt=\"[A picture of a MatteBorder made by this constructor]\" />\n+     *\n+     * @param tileIcon an icon for tiling the border area.\n      */\n-    public static class LineBorderUIResource\n-\textends LineBorder\n-\timplements UIResource, Serializable\n+    public MatteBorderUIResource(Icon tileIcon)\n     {\n-\tpublic LineBorderUIResource(Color color)\n-\t{\n-\t   super (color); \n-\t}\n-\tpublic LineBorderUIResource(Color color,\n-\t\t\t\t    int thickness)\n-\t{\n-\t   super (color, thickness);\n-\t}\n+      super(tileIcon);\n+    }\n+  }\n+  \n+  \n+  /**\n+   * A {@link javax.swing.border.TitledBorder} that also implements the\n+   * {@link UIResource} marker interface.  This is useful for\n+   * implementing pluggable look-and-feels: When switching the current\n+   * LookAndFeel, only those borders are replaced that are marked as\n+   * {@link UIResource}.  For this reason, a look-and-feel should\n+   * always install borders that implement <code>UIResource</code>,\n+   * such as the borders provided by this class.\n+   *\n+   * @author Brian Jones (cbj@gnu.org)\n+   * @author Sascha Brawer (brawer@dandelis.ch)\n+   */\n+  public static class TitledBorderUIResource\n+    extends TitledBorder\n+    implements UIResource, Serializable\n+  {\n+    /**\n+     * Constructs a TitledBorderUIResource given the text of its title.\n+     *\n+     * @param title the title text, or <code>null</code> to use no\n+     *        title text.\n+     */\n+    public TitledBorderUIResource(String title)\n+    {\n+      super(title);\n+    }\n+    \n+    \n+    /**\n+     * Constructs an initially untitled TitledBorderUIResource\n+     * given another border.\n+     *\n+     * @param border the border underneath the title, or\n+     *        <code>null</code> to use a default from\n+     *        the current look and feel.\n+     */\n+    public TitledBorderUIResource(Border border)\n+    {\n+      super(border);\n+    }\n+    \n+    \n+    /**\n+     * Constructs a TitledBorder given its border and title text.\n+     *\n+     * @param border the border underneath the title, or\n+     *        <code>null</code> to use a default from\n+     *        the current look and feel.\n+     *\n+     * @param title the title text, or <code>null</code>\n+     *        to use no title text.\n+     */\n+    public TitledBorderUIResource(Border border, String title)\n+    {\n+      super(border, title);\n     }\n \n+\n     /**\n-     * @serial\n+     * Constructs a TitledBorderUIResource given its border, title\n+     * text, horizontal alignment, and vertical position.\n+     *\n+     * @param border the border underneath the title, or\n+     *        <code>null</code> to use a default\n+     *        from the current look and feel.\n+     *\n+     * @param title the title text, or <code>null</code>\n+     *        to use no title text.\n+     *\n+     * @param titleJustification the horizontal alignment of the title\n+     *        text in relation to the border. The value must be one of\n+     *        {@link javax.swing.border.TitledBorder#LEFT},\n+     *        {@link javax.swing.border.TitledBorder#CENTER},\n+     *        {@link javax.swing.border.TitledBorder#RIGHT},\n+     *        {@link javax.swing.border.TitledBorder#LEADING},\n+     *        {@link javax.swing.border.TitledBorder#TRAILING}, or\n+     *        {@link javax.swing.border.TitledBorder#DEFAULT_JUSTIFICATION}.\n+     *\n+     * @param titlePosition the vertical position of the title text\n+     *        in relation to the border. The value must be one of\n+     *        {@link javax.swing.border.TitledBorder#ABOVE_TOP},\n+     *        {@link javax.swing.border.TitledBorder#TOP},\n+     *        {@link javax.swing.border.TitledBorder#BELOW_TOP},\n+     *        {@link javax.swing.border.TitledBorder#ABOVE_BOTTOM},\n+     *        {@link javax.swing.border.TitledBorder#BOTTOM},\n+     *        {@link javax.swing.border.TitledBorder#BELOW_BOTTOM},\n+     *        or {@link javax.swing.border.TitledBorder#DEFAULT_POSITION}.\n+     *\n+     * @throws IllegalArgumentException if <code>titleJustification</code>\n+     *         or <code>titlePosition</code> have an unsupported value.\n      */\n-    public static class MatteBorderUIResource\n-\textends MatteBorder\n-\timplements UIResource, Serializable\n+    public TitledBorderUIResource(Border border, String title,\n+                                  int titleJustification,\n+                                  int titlePosition)\n     {\n-\tpublic MatteBorderUIResource(int top, int left, int bottom, \n-\t\t\t\t     int right, Color color)\n-\t{\n-          super (new Insets (top, left, bottom, right), color);\n-\t}\n-\tpublic MatteBorderUIResource(int top, int left, int bottom,\n-\t\t\t\t     int right, Icon tileIcon)\n-\t{\n-          super (new Insets (top, left, bottom, right), tileIcon);\n-\n-\t}\n-\tpublic MatteBorderUIResource(Icon tileIcon)\n-\t{\n-\t  super (tileIcon);\n-\t}\n+      super(border, title, titleJustification, titlePosition);\n     }\n \n+\n+    /**\n+     * Constructs a TitledBorder given its border, title text,\n+     * horizontal alignment, vertical position, and font.\n+     *\n+     * @param border the border underneath the title, or\n+     *        <code>null</code> to use a default\n+     *        from the current look and feel.\n+     *\n+     * @param title the title text, or <code>null</code>\n+     *        to use no title text.\n+     *\n+     * @param titleJustification the horizontal alignment of the title\n+     *        text in relation to the border. The value must be one of\n+     *        {@link javax.swing.border.TitledBorder#LEFT},\n+     *        {@link javax.swing.border.TitledBorder#CENTER},\n+     *        {@link javax.swing.border.TitledBorder#RIGHT},\n+     *        {@link javax.swing.border.TitledBorder#LEADING},\n+     *        {@link javax.swing.border.TitledBorder#TRAILING}, or\n+     *        {@link javax.swing.border.TitledBorder#DEFAULT_JUSTIFICATION}.\n+     *\n+     * @param titlePosition the vertical position of the title text\n+     *        in relation to the border. The value must be one of\n+     *        {@link javax.swing.border.TitledBorder#ABOVE_TOP},\n+     *        {@link javax.swing.border.TitledBorder#TOP},\n+     *        {@link javax.swing.border.TitledBorder#BELOW_TOP},\n+     *        {@link javax.swing.border.TitledBorder#ABOVE_BOTTOM},\n+     *        {@link javax.swing.border.TitledBorder#BOTTOM},\n+     *        {@link javax.swing.border.TitledBorder#BELOW_BOTTOM},\n+     *        or {@link javax.swing.border.TitledBorder#DEFAULT_POSITION}.\n+     *\n+     * @param titleFont the font for the title text, or <code>null</code>\n+     *        to use a default from the current look and feel.\n+     *\n+     * @throws IllegalArgumentException if <code>titleJustification</code>\n+     *         or <code>titlePosition</code> have an unsupported value.\n+     */\n+    public TitledBorderUIResource(Border border, String title,\n+                                  int titleJustification,\n+                                  int titlePosition,\n+                                  Font titleFont)\n+    {\n+      super(border, title, titleJustification, titlePosition,\n+            titleFont);\n+    }\n+    \n+    \n     /**\n-     * @serial\n+     * Constructs a TitledBorder given its border, title text,\n+     * horizontal alignment, vertical position, font, and color.\n+     *\n+     * @param border the border underneath the title, or\n+     *        <code>null</code> to use a default\n+     *        from the current look and feel.\n+     *\n+     * @param title the title text, or <code>null</code>\n+     *        to use no title text.\n+     *\n+     * @param titleJustification the horizontal alignment of the title\n+     *        text in relation to the border. The value must be one of\n+     *        {@link javax.swing.border.TitledBorder#LEFT},\n+     *        {@link javax.swing.border.TitledBorder#CENTER},\n+     *        {@link javax.swing.border.TitledBorder#RIGHT},\n+     *        {@link javax.swing.border.TitledBorder#LEADING},\n+     *        {@link javax.swing.border.TitledBorder#TRAILING}, or\n+     *        {@link javax.swing.border.TitledBorder#DEFAULT_JUSTIFICATION}.\n+     *\n+     * @param titlePosition the vertical position of the title text\n+     *        in relation to the border. The value must be one of\n+     *        {@link javax.swing.border.TitledBorder#ABOVE_TOP},\n+     *        {@link javax.swing.border.TitledBorder#TOP},\n+     *        {@link javax.swing.border.TitledBorder#BELOW_TOP},\n+     *        {@link javax.swing.border.TitledBorder#ABOVE_BOTTOM},\n+     *        {@link javax.swing.border.TitledBorder#BOTTOM},\n+     *        {@link javax.swing.border.TitledBorder#BELOW_BOTTOM},\n+     *        or {@link javax.swing.border.TitledBorder#DEFAULT_POSITION}.\n+     *\n+     * @param titleFont the font for the title text, or <code>null</code>\n+     *        to use a default from the current look and feel.\n+     *\n+     * @param titleColor the color for the title text, or <code>null</code>\n+     *        to use a default from the current look and feel.\n+     *\n+     * @throws IllegalArgumentException if <code>titleJustification</code>\n+     *         or <code>titlePosition</code> have an unsupported value.\n      */\n-    public static class TitledBorderUIResource\n-\textends TitledBorder\n-\timplements UIResource, Serializable\n+    public TitledBorderUIResource(Border border, String title,\n+                                  int titleJustification, int titlePosition,\n+                                  Font titleFont, Color titleColor)\n     {\n-\tTitledBorderUIResource(String title)\n-\t{\n-\t  super (title);\n-\t}\n-\tTitledBorderUIResource(Border border)\n-\t{\n-          super (border);\n-\t}\n-\tTitledBorderUIResource(Border border, String title)\n-\t{\n-          super (border, title);\n-\t}\n-\tTitledBorderUIResource(Border border, String title,\n-\t\t\t       int titleJustification, int titlePosition)\n-\t{\n-          super (border, title, titleJustification, titlePosition);\n-\t}\n-\tTitledBorderUIResource(Border border, String title,\n-\t\t\t       int titleJustification, int titlePosition,\n-\t\t\t       Font titleFont)\n-\t{\n-          super (border, title, titleJustification, titlePosition, titleFont);\n-\t}\n-\tTitledBorderUIResource(Border border, String title,\n-\t\t\t       int titleJustification, int titlePosition,\n-\t\t\t       Font titleFont, Color titleColor)\n-\t{\n-          super (border, title, titleJustification, titlePosition, titleFont, titleColor);\n-\t}\n+      super(border, title, titleJustification, titlePosition,\n+            titleFont, titleColor);\n     }\n+  }\n }\n "}, {"sha": "85782388534fce7e0890809044a9bd5ea1038e30", "filename": "libjava/javax/swing/plaf/basic/BasicBorders.java", "status": "modified", "additions": 370, "deletions": 4, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicBorders.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicBorders.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicBorders.java?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "patch": "@@ -1,5 +1,5 @@\n /* BasicBorders.java\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,25 +37,391 @@\n \n \n package javax.swing.plaf.basic;\n+\n import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.io.Serializable;\n+import javax.swing.AbstractButton;\n+import javax.swing.ButtonModel;\n+import javax.swing.JButton;\n+import javax.swing.JPopupMenu;\n+import javax.swing.JToolBar;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.border.AbstractBorder;\n+import javax.swing.border.Border;\n+import javax.swing.plaf.UIResource;\n+import javax.swing.plaf.BorderUIResource;\n+\n+\n /**\n- * STUBBED\n+ * Provides various borders for the Basic look and feel.\n+ *\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n  */\n public class BasicBorders\n {\n+  /**\n+   * A MarginBorder that gets shared by multiple components.\n+   * Created on demand by the private helper function {@link\n+   * #getMarginBorder()}.\n+   */\n+  private static MarginBorder sharedMarginBorder;\n+\n+\n+  /**\n+   * Returns a border that is suitable for a button.\n+   *\n+   * <p>The colors of the border are retrieved from the\n+   * <code>UIDefaults</code> of the currently active look and feel\n+   * using the keys <code>&#x201c;Button.shadow&#x201d;</code>,\n+   * <code>&#x201c;Button.darkShadow&#x201d;</code>,\n+   * <code>&#x201c;Button.light&#x201d;</code>, and\n+   * <code>&#x201c;Button.highlight&#x201d;</code>.\n+   *\n+   * <p><img src=\"BasicBorders.ButtonBorder-1.png\" width=\"300\"\n+   * height=\"170\" alt=\"[A screen shot of the returned border]\" />\n+   *\n+   * @return a {@link\n+   *         javax.swing.plaf.BorderUIResource#CompoundBorderUIResource}\n+   *         whose outer border is a {@link #ButtonBorder} and whose\n+   *         inner border is a {@link #MarginBorder}.\n+   */\n+  public static Border getButtonBorder()\n+  {\n+    UIDefaults defaults;\n+    Border outer;\n+\n+    defaults = UIManager.getLookAndFeelDefaults();\n+\n+    /* The keys for UIDefaults have been determined by writing a\n+     * test program that dumps the UIDefaults to stdout; that program\n+     * was run on a JDK 1.4.1_01 for GNU/Linux. Note that in the API,\n+     * the key \"light\" is usually called \"highlight\", and \"highlight\"\n+     * is usually called \"lightHighlight\".\n+     */\n+    outer = new ButtonBorder(defaults.getColor(\"Button.shadow\"),\n+                             defaults.getColor(\"Button.darkShadow\"),\n+                             defaults.getColor(\"Button.light\"),\n+                             defaults.getColor(\"Button.highlight\"));\n+\n+    /* While the inner border is shared between multiple buttons,\n+     * we do not share the outer border because ButtonBorders store\n+     * their border colors. We cannot guarantee that the colors\n+     * (which come from UIDefaults) are unchanged between invocations\n+     * of getButtonBorder. We could store the last colors, and share\n+     * the button border if the colors are the same as in the last\n+     * invocation, but it probably is not worth the effort.\n+     */\n+    return new BorderUIResource.CompoundBorderUIResource(\n+      outer,\n+      /* inner */ getMarginBorder());\n+  }\n+\n+\n+  /**\n+   * Returns a shared MarginBorder.\n+   */\n+  static Border getMarginBorder()  // intentionally not public\n+  {\n+    /* Swing is not designed to be thread-safe, so there is no\n+     * need to synchronize the access to the global variable.\n+     */\n+    if (sharedMarginBorder == null)\n+      sharedMarginBorder = new MarginBorder();\n+\n+    return sharedMarginBorder;\n+  }\n+  \n+  \n+  /**\n+   * A border whose appearance depends on the state of\n+   * the enclosed button.\n+   *\n+   * <p><img src=\"BasicBorders.ButtonBorder-1.png\" width=\"300\"\n+   * height=\"170\" alt=\"[A screen shot of this border]\" />\n+   *\n+   * @see javax.swing.plaf.basic.BasicGraphicsUtils#drawBezel\n+   *\n+   * @author Sascha Brawer (brawer@dandelis.ch)\n+   */\n   public static class ButtonBorder\n+    extends AbstractBorder\n+    implements Serializable, UIResource\n   {\n-  } // class ButtonBorder\n+    /**\n+     * Determined using the <code>serialver</code> tool\n+     * of Apple/Sun JDK 1.3.1 on MacOS X 10.1.5.\n+     */\n+    static final long serialVersionUID = -157053874580739687L;\n+    \n+    \n+    /**\n+     * The color for drawing the shaded parts of the border.\n+     * @see javax.swing.plaf.basic.BasicGraphicsUtils#drawBezel\n+     */\n+    protected Color shadow;\n+    \n+    \n+    /**\n+     * The color for drawing the dark shaded parts of the border.\n+     * @see javax.swing.plaf.basic.BasicGraphicsUtils#drawBezel\n+     */\n+    protected Color darkShadow;\n+    \n+    \n+    /**\n+     * The color for drawing the highlighted parts of the border.\n+     * @see javax.swing.plaf.basic.BasicGraphicsUtils#drawBezel\n+     */\n+    protected Color highlight;\n+    \n+    \n+    /**\n+     * The color for drawing the bright highlighted parts of the border.\n+     * @see javax.swing.plaf.basic.BasicGraphicsUtils#drawBezel\n+     */\n+    protected Color lightHighlight;\n+    \n+    \n+    /**\n+     * Constructs a new border for drawing a button in the Basic\n+     * look and feel.\n+     *\n+     * @param shadow the shadow color.\n+     * @param darkShadow a darker variant of the shadow color.\n+     * @param highlight the highlight color.\n+     * @param lightHighlight a brighter variant of the highlight  color.\n+     */\n+    public ButtonBorder(Color shadow, Color darkShadow,\n+                        Color highlight, Color lightHighlight)\n+    {\n+      /* These colors usually come from the UIDefaults of the current\n+       * look and feel. Use fallback values if the colors are not\n+       * supplied.  The API specification is silent about what\n+       * behavior is expected for null colors, so users should not\n+       * rely on this fallback (which is why it is not documented in\n+       * the above Javadoc).\n+       */\n+      this.shadow = (shadow != null) ? shadow : Color.gray;\n+      this.darkShadow = (darkShadow != null) ? darkShadow : Color.black;\n+      this.highlight = (highlight != null) ? highlight : Color.lightGray;\n+      this.lightHighlight = (lightHighlight != null)\n+        ? lightHighlight\n+        : Color.white;\n+    }\n+    \n+\n+    /**\n+     * Paints the ButtonBorder around a given component.\n+     *\n+     * @param c the component whose border is to be painted.\n+     * @param g the graphics for painting.\n+     * @param x the horizontal position for painting the border.\n+     * @param y the vertical position for painting the border.\n+     * @param width the width of the available area for painting the border.\n+     * @param height the height of the available area for painting the border.\n+     *\n+     * @see javax.swing.plaf.basic.BasicGraphicsUtils#drawBezel\n+     */\n+    public void paintBorder(Component c, Graphics  g,\n+                            int x, int y, int width, int height)\n+    {\n+      ButtonModel bmodel = null;\n+      \n+      if (c instanceof AbstractButton)\n+        bmodel = ((AbstractButton) c).getModel();\n+      \n+      BasicGraphicsUtils.drawBezel(\n+        g, x, y, width, height,\n+        /* pressed */ (bmodel != null)\n+                        && /* mouse button pressed */ bmodel.isPressed()\n+                        && /* mouse inside */ bmodel.isArmed(),\n+        /* default */ (c instanceof JButton)\n+                        && ((JButton) c).isDefaultButton(),\n+        shadow, darkShadow, highlight, lightHighlight);\n+    }\n+    \n+    \n+    /**\n+     * Measures the width of this border.\n+     *\n+     * <p>Although the thickness of the actually painted border\n+     * depends on the state of the enclosed component, this\n+     * measurement always returns the same amount of pixels.  Indeed,\n+     * it would be rather confusing if a button was appearing to\n+     * change its size depending on whether it is pressed or not.\n+     *\n+     * @param c the component whose border is to be measured.\n+     *\n+     * @return an Insets object whose <code>left</code>,\n+     *         <code>right</code>, <code>top</code> and\n+     *         <code>bottom</code> fields indicate the width of the\n+     *         border at the respective edge.\n+     *\n+     * @see #getBorderInsets(java.awt.Component, java.awt.Insets) \n+     */\n+    public Insets getBorderInsets(Component c)\n+    {\n+      /* There is no obvious reason for overriding this method, but we\n+       * try to have exactly the same API as the Sun reference\n+       * implementation.\n+       */\n+      return getBorderInsets(c, null);\n+    }\n+\n+    \n+    /**\n+     * Measures the width of this border, storing the results into a\n+     * pre-existing Insets object.\n+     *\n+     * <p>Although the thickness of the actually painted border\n+     * depends on the state of the enclosed component, this\n+     * measurement always returns the same amount of pixels.  Indeed,\n+     * it would be rather confusing if a button was appearing to\n+     * change its size depending on whether it is pressed or not.\n+     *\n+     * @param insets an Insets object for holding the result values.\n+     *        After invoking this method, the <code>left</code>,\n+     *        <code>right</code>, <code>top</code> and\n+     *        <code>bottom</code> fields indicate the width of the\n+     *        border at the respective edge.\n+     *\n+     * @return the same object that was passed for <code>insets</code>.\n+     *\n+     * @see #getBorderInsets()\n+     */\n+    public Insets getBorderInsets(Component c, Insets insets)\n+    {\n+      /* The exact amount has been determined using a test program\n+       * that was run on the Sun reference implementation. With\n+       * Apple/Sun JDK 1.3.1 on MacOS X 10.1.5, the result is\n+       * [3, 3, 3, 3]. With Sun JDK 1.4.1_01 on Linux/x86, the\n+       * result is [2, 3, 3, 3]. We use the values from the 1.4.1_01\n+       * release.\n+       */\n+      if (insets == null)\n+        return new Insets(2, 3, 3, 3);\n+\n+      insets.top = 2;\n+      insets.bottom = insets.left = insets.right = 3;\n+      return insets;\n+    }\n+  }\n+  \n+  \n   public static class FieldBorder\n   {\n     public FieldBorder(Color shadow, Color darkShadow,\n                        Color highlight, Color lightHighlight)\n     {\n     }\n   } // class FieldBorder\n+\n+\n+  /**\n+   * An invisible, but spacing border whose margin is determined\n+   * by calling the <code>getMargin()</code> method of the enclosed\n+   * component.  If the enclosed component has no such method,\n+   * this border will not occupy any space.\n+   *\n+   * <p><img src=\"BasicBorders.MarginBorder-1.png\" width=\"325\"\n+   * height=\"200\" alt=\"[An illustration that shows how MarginBorder\n+   * determines its borders]\" />\n+   *\n+   * @author Sascha Brawer (brawer@dandelis.ch)\n+   */\n   public static class MarginBorder\n+    extends AbstractBorder\n+    implements Serializable, UIResource\n   {\n-  } // class MarginBorder\n+    /**\n+     * Determined using the <code>serialver</code> tool\n+     * of Apple/Sun JDK 1.3.1 on MacOS X 10.1.5.\n+     */\n+    static final long serialVersionUID = -3035848353448896090L;\n+    \n+    \n+    /**\n+     * Constructs a new MarginBorder.\n+     */\n+    public MarginBorder()\n+    {\n+    }\n+    \n+    \n+    /**\n+     * Measures the width of this border.\n+     *\n+     * @param c the component whose border is to be measured.\n+     *\n+     * @return an Insets object whose <code>left</code>, <code>right</code>,\n+     *         <code>top</code> and <code>bottom</code> fields indicate the\n+     *         width of the border at the respective edge.\n+     *\n+     * @see #getBorderInsets(java.awt.Component, java.awt.Insets)\n+     */\n+    public Insets getBorderInsets(Component c)\n+    {\n+      return getBorderInsets(c, new Insets(0, 0, 0, 0));\n+    }\n+    \n+    \n+    /**\n+     * Determines the insets of this border by calling the\n+     * <code>getMargin()</code> method of the enclosed component.  The\n+     * resulting margin will be stored into the the <code>left</code>,\n+     * <code>right</code>, <code>top</code> and <code>bottom</code>\n+     * fields of the passed <code>insets</code> parameter.\n+     *\n+     * <p>Unfortunately, <code>getMargin()</code> is not a method of\n+     * {@link javax.swing.JComponent} or some other common superclass\n+     * of things with margins. While reflection could be used to\n+     * determine the existence of this method, this would be slow on\n+     * many virtual machines. Therefore, the current implementation\n+     * knows about {@link javax.swing.AbstractButton#getMargin()},\n+     * {@link javax.swing.JPopupMenu#getMargin()}, and {@link\n+     * javax.swing.JToolBar#getMargin()}. If <code>c</code> is an\n+     * instance of a known class, the respective\n+     * <code>getMargin()</code> method is called to determine the\n+     * correct margin. Otherwise, a zero-width margin is returned.\n+     *\n+     * @param c the component whose border is to be measured.\n+     *\n+     * @return the same object that was passed for <code>insets</code>,\n+     *         but with changed fields.\n+     */\n+    public Insets getBorderInsets(Component c, Insets insets)\n+    {\n+      Insets margin = null;\n+\n+      /* This is terrible object-oriented design. See the above Javadoc\n+       * for an excuse.\n+       */\n+      if (c instanceof AbstractButton)\n+        margin = ((AbstractButton) c).getMargin();\n+      else if (c instanceof JPopupMenu)\n+        margin = ((JPopupMenu) c).getMargin();\n+      else if (c instanceof JToolBar)\n+        margin = ((JToolBar) c).getMargin();\n+\n+      if (margin == null)\n+        insets.top = insets.left = insets.bottom = insets.right = 0;\n+      else\n+      {\n+        insets.top = margin.top;\n+        insets.left = margin.left;\n+        insets.bottom = margin.bottom;\n+        insets.right = margin.right;\n+      }\n+\n+      return insets;\n+    }\n+  }\n+  \n+  \n   public static class MenuBarBorder\n   {\n     public MenuBarBorder(Color shadow, Color highlight)"}, {"sha": "d901e7ddeb73c07692b17b0e0936d103ae98d9de", "filename": "libjava/javax/swing/plaf/basic/BasicButtonUI.java", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "patch": "@@ -74,14 +74,7 @@ public void installUI(final JComponent c)\n     public Dimension getPreferredSize(JComponent c) \n     {\n \tAbstractButton b = (AbstractButton)c;\n-\tDimension d = BasicGraphicsUtils.getPreferredSize(b, \n-\t\t\t\t\t\t\t  gap,\n-\t\t\t\t\t\t\t  b.getText(),\n-\t\t\t\t\t\t\t  b.getIcon(),\n-\t\t\t\t\t\t\t  b.getVerticalAlignment(),\n-\t\t\t\t\t\t\t  b.getHorizontalAlignment(),\n-\t\t\t\t\t\t\t  b.getHorizontalTextPosition(),\n-\t\t\t\t\t\t\t  b.getVerticalTextPosition());\n+\tDimension d = BasicGraphicsUtils.getPreferredButtonSize(b, gap);\n \t//\tSystem.out.println(\"^^^^^^^^^^^^^^^^^^^^^^   BASIC-PREF=\"+d + \",T=\"+b.text);\n \treturn d;\n     }\n@@ -99,7 +92,7 @@ public void paint(Graphics g, JComponent c)\n \n         g.setFont(f);\n \n-        FontMetrics fm = SwingUtilities.getFontMetrics(f);\n+        FontMetrics fm = g.getFontMetrics(f);\n \n         Insets i = c.getInsets();\n \n@@ -198,7 +191,7 @@ protected void paintText(Graphics g,\n \n         g.setFont(f);\n \n-        FontMetrics fm = SwingUtilities.getFontMetrics(f);\n+        FontMetrics fm = g.getFontMetrics(f);\n \n \tg.setColor(c.isEnabled() ? textColor : disabledTextColor);\n "}, {"sha": "54a9c69862ef3c63e2d54095bd20d088834a6196", "filename": "libjava/javax/swing/plaf/basic/BasicCheckBoxUI.java", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicCheckBoxUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicCheckBoxUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicCheckBoxUI.java?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "patch": "@@ -57,15 +57,7 @@ public void installUI(final JComponent c)  {\n     public Dimension getPreferredSize(JComponent c) \n     {\n \tAbstractButton b = (AbstractButton)c;\n-\tDimension d = BasicGraphicsUtils.getPreferredSize(b, \n-\t\t\t\t\t\t\t  gap,\n-\t\t\t\t\t\t\t  b.getText(),\n-\t\t\t\t\t\t\t  b.getIcon(),\n-\t\t\t\t\t\t\t  b.getVerticalAlignment(),\n-\t\t\t\t\t\t\t  b.getHorizontalAlignment(),\n-\t\t\t\t\t\t\t  b.getHorizontalTextPosition(),\n-\t\t\t\t\t\t\t  b.getVerticalTextPosition());\n-\t\t\t\t\t\t\t  \n+\tDimension d = BasicGraphicsUtils.getPreferredButtonSize(b, gap);\n \t//System.out.println(\"^^^^^^^^^^^^^^^^^^^^^^   BASIC-PREF=\"+d + \",T=\"+b.text);\n \treturn d;\n     }"}, {"sha": "a7b64111f5301c078801ebb4ef51f67435eb58eb", "filename": "libjava/javax/swing/plaf/basic/BasicGraphicsUtils.java", "status": "modified", "additions": 583, "deletions": 62, "changes": 645, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicGraphicsUtils.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicGraphicsUtils.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicGraphicsUtils.java?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "patch": "@@ -1,5 +1,5 @@\n /* BasicGraphicsUtils.java\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,81 +35,602 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing.plaf.basic;\n \n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Insets;\n+import java.awt.Rectangle;\n+\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.LineMetrics;\n+import java.awt.font.TextLayout;\n \n-import java.awt.*;\n-import javax.swing.*;\n+import java.awt.geom.Rectangle2D;\n \n+import javax.swing.AbstractButton;\n+import javax.swing.SwingUtilities;\n \n+\n+/**\n+ * A utility class providing commonly used drawing and measurement\n+ * routines.\n+ *\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n+ */\n public class BasicGraphicsUtils\n-{  \n-    public static Dimension getPreferredSize(JComponent b, \n-\t\t\t\t\t     int gap,\n-\t\t\t\t\t     String text,\n-\t\t\t\t\t     Icon icon,\n-\t\t\t\t\t     int va,\n-\t\t\t\t\t     int ha,\n-\t\t\t\t\t     int htp,\n-\t\t\t\t\t     int vtp)\n+{\n+  /**\n+   * Constructor. It is utterly unclear why this class should\n+   * be constructable, but this is what the API specification\n+   * says.\n+   */\n+  public BasicGraphicsUtils()\n+  {\n+  }\n+\n+\n+  /**\n+   * Draws a rectangle that appears etched into the surface, given\n+   * four colors that are used for drawing.\n+   *\n+   * <p><img src=\"BasicGraphicsUtils-1.png\" width=\"360\"\n+   * height=\"200\" alt=\"[An illustration that shows which pixels\n+   * get painted in what color]\" />\n+   *\n+   * @param g the graphics into which the rectangle is drawn.\n+   * @param x the x coordinate of the rectangle.\n+   * @param y the y coordinate of the rectangle.\n+   * @param width the width of the rectangle in pixels.\n+   * @param height the height of the rectangle in pixels.\n+   *\n+   * @param shadow the color that will be used for painting\n+   *        the outer side of the top and left edges.\n+   *\n+   * @param darkShadow the color that will be used for painting\n+   *        the inner side of the top and left edges.\n+   *\n+   * @param highlight the color that will be used for painting\n+   *        the inner side of the bottom and right edges.\n+   *\n+   * @param lightHighlight the color that will be used for painting\n+   *        the outer side of the bottom and right edges.\n+   *\n+   * @see #getEtchedInsets()\n+   * @see javax.swing.border.EtchedBorder\n+   */\n+  public static void drawEtchedRect(Graphics g,\n+                                    int x, int y, int width, int height,\n+                                    Color shadow, Color darkShadow,\n+                                    Color highlight, Color lightHighlight)\n+  {\n+    Color oldColor;\n+    int x2, y2;\n+\n+    oldColor = g.getColor();\n+    x2 = x + width - 1;\n+    y2 = y + height - 1;\n+\n+    try\n     {\n-\tJComponent c = b;\n-\t// this is a staight copy from BasicButtonUI.paint()\n-\t// \n-\tRectangle tr = new Rectangle();\n-\tRectangle ir = new Rectangle();\n-\tRectangle vr = new Rectangle();\n-\n-\tFont f = c.getFont();\n-\n-        FontMetrics fm = SwingUtilities.getFontMetrics(f);\n-\n-        Insets i = c.getInsets();\n-\n-        vr.x      = i.left;\n-        vr.y      = i.top;\n-        vr.width  = b.getWidth()  - (i.right  +  i.left);\n-        vr.height = b.getHeight() - (i.bottom +  i.top);\n-\n-\t//\tSystem.out.println(\"              VIEW-RECT-BUTTON=\"+vr+\", insets=\"+i);\n-\n-\tString tt = SwingUtilities.layoutCompoundLabel(b,\n-\t\t\t\t\t\t       fm, \n-\t\t\t\t\t\t       text,\n-\t\t\t\t\t\t       icon,\n-\t\t\t\t\t\t       va,\n-\t\t\t\t\t\t       ha,\n-\t\t\t\t\t\t       vtp,\n-\t\t\t\t\t\t       htp,\n-\t\t\t\t\t\t       vr,\n-\t\t\t\t\t\t       ir,\n-\t\t\t\t\t\t       tr,\n-\t\t\t\t\t\t       gap);\n-\t\n-        Rectangle r = ir.union(tr);\n-\t\n-        Insets insets = b.getInsets();\n-        r.width  += insets.left + insets.right;\n-        r.height += insets.top  + insets.bottom;\n-\n-\t//\tSystem.out.println(\"COMPUTED SIZE FOR PREF_SIZE=\"+r);\n-\n-\treturn r.getSize();\n+      /* To understand this code, it might be helpful to look at the\n+       * image \"BasicGraphicsUtils-1.png\" that is included with the\n+       * JavaDoc. The file is located in the \"doc-files\" subdirectory.\n+       *\n+       * (x2, y2) is the coordinate of the most right and bottom pixel\n+       * to be painted.\n+       */\n+      g.setColor(shadow);\n+      g.drawLine(x, y, x2 - 1, y);                     // top, outer\n+      g.drawLine(x, y + 1, x, y2 - 1);                 // left, outer\n+\n+      g.setColor(darkShadow);\n+      g.drawLine(x + 1, y + 1, x2 - 2, y + 1);         // top, inner\n+      g.drawLine(x + 1, y + 2, x + 1, y2 - 2);         // left, inner\n+      \n+      g.setColor(highlight);\n+      g.drawLine(x + 1, y2 - 1, x2 - 1, y2 - 1);       // bottom, inner\n+      g.drawLine(x2 - 1, y + 1, x2 - 1, y2 - 2);       // right, inner\n+\n+      g.setColor(lightHighlight);\n+      g.drawLine(x, y2, x2, y2);                       // bottom, outer\n+      g.drawLine(x2, y, x2, y2 - 1);                   // right, outer\n+    }\n+    finally\n+    {\n+      g.setColor(oldColor);\n     }\n+  }\n+  \n+  \n+  /**\n+   * Determines the width of the border that gets painted by\n+   * {@link #drawEtchedRect}.\n+   *\n+   * @return an <code>Insets</code> object whose <code>top</code>,\n+   *         <code>left</code>, <code>bottom</code> and\n+   *         <code>right</code> field contain the border width at the\n+   *         respective edge in pixels.\n+   */\n+  public static Insets getEtchedInsets()\n+  {\n+    return new Insets(2, 2, 2, 2);\n+  }\n+\n+\n+  /**\n+   * Draws a rectangle that appears etched into the surface, given\n+   * two colors that are used for drawing.\n+   *\n+   * <p><img src=\"BasicGraphicsUtils-2.png\" width=\"360\"\n+   * height=\"200\" alt=\"[An illustration that shows which pixels\n+   * get painted in what color]\" />\n+   *\n+   * @param g the graphics into which the rectangle is drawn.\n+   * @param x the x coordinate of the rectangle.\n+   * @param y the y coordinate of the rectangle.\n+   * @param width the width of the rectangle in pixels.\n+   * @param height the height of the rectangle in pixels.\n+   *\n+   * @param shadow the color that will be used for painting the outer\n+   *        side of the top and left edges, and for the inner side of\n+   *        the bottom and right ones.\n+   *\n+   * @param highlight the color that will be used for painting the\n+   *        inner side of the top and left edges, and for the outer\n+   *        side of the bottom and right ones.\n+   *\n+   * @see #getGrooveInsets()\n+   * @see javax.swing.border.EtchedBorder\n+   */\n+  public static void drawGroove(Graphics g,\n+                                int x, int y, int width, int height,\n+                                Color shadow, Color highlight)\n+  {\n+    /* To understand this, it might be helpful to look at the image\n+     * \"BasicGraphicsUtils-2.png\" that is included with the JavaDoc,\n+     * and to compare it with \"BasicGraphicsUtils-1.png\" which shows\n+     * the pixels painted by drawEtchedRect.  These image files are\n+     * located in the \"doc-files\" subdirectory.\n+     */\n+    drawEtchedRect(g, x, y, width, height,\n+                   /* outer topLeft */     shadow,\n+                   /* inner topLeft */     highlight,\n+                   /* inner bottomRight */ shadow,\n+                   /* outer bottomRight */ highlight);\n+  }\n+\n \n-    public static void drawString(Graphics g,\n-\t\t\t\t  String text,\n-\t\t\t\t  int underlinedChar,\n-\t\t\t\t  int x,\n-\t\t\t\t  int y)\n+  /**\n+   * Determines the width of the border that gets painted by\n+   * {@link #drawGroove}.\n+   *\n+   * @return an <code>Insets</code> object whose <code>top</code>,\n+   *         <code>left</code>, <code>bottom</code> and\n+   *         <code>right</code> field contain the border width at the\n+   *         respective edge in pixels.\n+   */\n+  public static Insets getGrooveInsets()\n+  {\n+    return new Insets(2, 2, 2, 2);\n+  }\n+  \n+\n+  /**\n+   * Draws a border that is suitable for buttons of the Basic look and\n+   * feel.\n+   *\n+   * <p><img src=\"BasicGraphicsUtils-3.png\" width=\"500\"\n+   * height=\"300\" alt=\"[An illustration that shows which pixels\n+   * get painted in what color]\" />\n+   *\n+   * @param g the graphics into which the rectangle is drawn.\n+   * @param x the x coordinate of the rectangle.\n+   * @param y the y coordinate of the rectangle.\n+   * @param width the width of the rectangle in pixels.\n+   * @param height the height of the rectangle in pixels.\n+   *\n+   * @param isPressed <code>true</code> to draw the button border\n+   *        with a pressed-in appearance; <code>false</code> for\n+   *        normal (unpressed) appearance.\n+   *\n+   * @param isDefault <code>true</code> to draw the border with\n+   *        the appearance it has when hitting the enter key in a\n+   *        dialog will simulate a click to this button;\n+   *        <code>false</code> for normal appearance.\n+   *\n+   * @param shadow the shadow color.\n+   * @param darkShadow a darker variant of the shadow color.\n+   * @param highlight the highlight color.\n+   * @param lightHighlight a brighter variant of the highlight  color.\n+   */\n+  public static void drawBezel(Graphics g,\n+                               int x, int y, int width, int height,\n+                               boolean isPressed, boolean isDefault,\n+                               Color shadow, Color darkShadow,\n+                               Color highlight, Color lightHighlight)\n+  {\n+    Color oldColor = g.getColor();\n+\n+    /* To understand this, it might be helpful to look at the image\n+     * \"BasicGraphicsUtils-3.png\" that is included with the JavaDoc,\n+     * and to compare it with \"BasicGraphicsUtils-1.png\" which shows\n+     * the pixels painted by drawEtchedRect.  These image files are\n+     * located in the \"doc-files\" subdirectory.\n+     */\n+    try\n     {\n-\tg.drawString(text, x, y);\n+      if ((isPressed == false) && (isDefault == false))\n+      {\n+        drawEtchedRect(g, x, y, width, height,\n+                       lightHighlight, highlight,\n+                       shadow, darkShadow);\n+      }\n+\n+      if ((isPressed == true) && (isDefault == false))\n+      {\n+        g.setColor(shadow);\n+        g.drawRect(x + 1, y + 1, width - 2, height - 2);\n+      }\n+\n+      if ((isPressed == false) && (isDefault == true))\n+      {\n+        g.setColor(darkShadow);\n+        g.drawRect(x, y, width - 1, height - 1);\n+        drawEtchedRect(g, x + 1, y + 1, width - 2, height - 2,\n+                       lightHighlight, highlight,\n+                       shadow, darkShadow);\n+      }\n+\n+      if ((isPressed == true) && (isDefault == true))\n+      {\n+        g.setColor(darkShadow);\n+        g.drawRect(x, y, width - 1, height - 1);\n+        g.setColor(shadow);\n+        g.drawRect(x + 1, y + 1, width - 3, height - 3);\n+      }\n     }\n-}\n+    finally\n+    {\n+      g.setColor(oldColor);\n+    }\n+  }\n+  \n+  \n+  /**\n+   * Draws a rectangle that appears lowered into the surface, given\n+   * four colors that are used for drawing.\n+   *\n+   * <p><img src=\"BasicGraphicsUtils-4.png\" width=\"360\"\n+   * height=\"200\" alt=\"[An illustration that shows which pixels\n+   * get painted in what color]\" />\n+   *\n+   * <p><strong>Compatibility with the Sun reference\n+   * implementation:</strong> The Sun reference implementation seems\n+   * to ignore the <code>x</code> and <code>y</code> arguments, at\n+   * least in JDK 1.3.1 and 1.4.1_01.  The method always draws the\n+   * rectangular area at location (0, 0). A bug report has been filed\n+   * with Sun; its &#x201c;bug ID&#x201d; is 4880003.  The GNU Classpath\n+   * implementation behaves correctly, thus not replicating this bug.\n+   *\n+   * @param g the graphics into which the rectangle is drawn.\n+   * @param x the x coordinate of the rectangle.\n+   * @param y the y coordinate of the rectangle.\n+   * @param width the width of the rectangle in pixels.\n+   * @param height the height of the rectangle in pixels.\n+   *\n+   * @param shadow the color that will be used for painting\n+   *        the inner side of the top and left edges.\n+   *\n+   * @param darkShadow the color that will be used for painting\n+   *        the outer side of the top and left edges.\n+   *\n+   * @param highlight the color that will be used for painting\n+   *        the inner side of the bottom and right edges.\n+   *\n+   * @param lightHighlight the color that will be used for painting\n+   *        the outer side of the bottom and right edges.\n+   */\n+  public static void drawLoweredBezel(Graphics g,\n+                                      int x, int y, int width, int height,\n+                                      Color shadow, Color darkShadow,\n+                                      Color highlight, Color lightHighlight)\n+  {\n+    /* Like drawEtchedRect, but swapping darkShadow and shadow.\n+     *\n+     * To understand this, it might be helpful to look at the image\n+     * \"BasicGraphicsUtils-4.png\" that is included with the JavaDoc,\n+     * and to compare it with \"BasicGraphicsUtils-1.png\" which shows\n+     * the pixels painted by drawEtchedRect.  These image files are\n+     * located in the \"doc-files\" subdirectory.\n+     */\n+    drawEtchedRect(g, x, y, width, height,\n+                   darkShadow, shadow,\n+                   highlight, lightHighlight);\n+  }\n+  \n+  \n+  /**\n+   * Draws a String at the given location, underlining the first\n+   * occurence of a specified character. The algorithm for determining\n+   * the underlined position is not sensitive to case. If the\n+   * character is not part of <code>text</code>, the text will be\n+   * drawn without underlining. Drawing is performed in the current\n+   * color and font of <code>g</code>.\n+   *\n+   * <p><img src=\"BasicGraphicsUtils-5.png\" width=\"500\"\n+   * height=\"100\" alt=\"[An illustration showing how to use the\n+   * method]\" />\n+   *\n+   * @param g the graphics into which the String is drawn.\n+   *\n+   * @param text the String to draw.\n+   *\n+   * @param underlinedChar the character whose first occurence in\n+   *        <code>text</code> will be underlined. It is not clear\n+   *        why the API specification declares this argument to be\n+   *        of type <code>int</code> instead of <code>char</code>.\n+   *        While this would allow to pass Unicode characters outside\n+   *        Basic Multilingual Plane 0 (U+0000 .. U+FFFE), at least\n+   *        the GNU Classpath implementation does not underline\n+   *        anything if <code>underlinedChar</code> is outside\n+   *        the range of <code>char</code>.\n+   *        \n+   * @param x the x coordinate of the text, as it would be passed to\n+   *        {@link java.awt.Graphics#drawString(java.lang.String,\n+   *        int, int)}.\n+   *\n+   * @param y the y coordinate of the text, as it would be passed to\n+   *        {@link java.awt.Graphics#drawString(java.lang.String,\n+   *        int, int)}.\n+   */\n+  public static void drawString(Graphics g, String text,\n+                                int underlinedChar, int x, int y)\n+  {\n+    int index = -1;\n+\n+    /* It is intentional that lower case is used. In some languages,\n+     * the set of lowercase characters is larger than the set of\n+     * uppercase ones. Therefore, it is good practice to use lowercase\n+     * for such comparisons (which really means that the author of this\n+     * code can vaguely remember having read some Unicode techreport\n+     * with this recommendation, but is too lazy to look for the URL).\n+     */\n+    if ((underlinedChar >= 0) || (underlinedChar <= 0xffff))\n+      index = text.toLowerCase().indexOf(\n+        Character.toLowerCase((char) underlinedChar));\n+\n+    drawStringUnderlineCharAt(g, text, index, x, y);\n+  }\n \n \n+  /**\n+   * Draws a String at the given location, underlining the character\n+   * at the specified index. Drawing is performed in the current color\n+   * and font of <code>g</code>.\n+   *\n+   * <p><img src=\"BasicGraphicsUtils-5.png\" width=\"500\"\n+   * height=\"100\" alt=\"[An illustration showing how to use the\n+   * method]\" />\n+   *\n+   * @param g the graphics into which the String is drawn.\n+   *\n+   * @param text the String to draw.\n+   *\n+   * @param underlinedIndex the index of the underlined character in\n+   *        <code>text</code>.  If <code>underlinedIndex</code> falls\n+   *        outside the range <code>[0, text.length() - 1]</code>, the\n+   *        text will be drawn without underlining anything.\n+   *        \n+   * @param x the x coordinate of the text, as it would be passed to\n+   *        {@link java.awt.Graphics#drawString(java.lang.String,\n+   *        int, int)}.\n+   *\n+   * @param y the y coordinate of the text, as it would be passed to\n+   *        {@link java.awt.Graphics#drawString(java.lang.String,\n+   *        int, int)}.\n+   *\n+   * @since 1.4\n+   */\n+  public static void drawStringUnderlineCharAt(Graphics g, String text,\n+                                               int underlinedIndex,\n+                                               int x, int y)\n+  {\n+    Graphics2D g2;\n+    Rectangle2D.Double underline;\n+    FontRenderContext frc;\n+    FontMetrics fmet;\n+    LineMetrics lineMetrics;\n+    Font font;\n+    TextLayout layout;\n+    double underlineX1, underlineX2;\n+    boolean drawUnderline;\n+    int textLength;\n \n+    textLength = text.length();\n+    if (textLength == 0)\n+      return;\n \n+    drawUnderline = (underlinedIndex >= 0) && (underlinedIndex < textLength);\n \n+    if (!(g instanceof Graphics2D))\n+    {\n+      /* Fall-back. This is likely to produce garbage for any text\n+       * containing right-to-left (Hebrew or Arabic) characters, even\n+       * if the underlined character is left-to-right.\n+       */\n+      g.drawString(text, x, y);\n+      if (drawUnderline)\n+      {\n+        fmet = g.getFontMetrics();\n+        g.fillRect(\n+          /* x */ x + fmet.stringWidth(text.substring(0, underlinedIndex)),\n+          /* y */ y + fmet.getDescent() - 1,\n+          /* width */ fmet.charWidth(text.charAt(underlinedIndex)),\n+          /* height */ 1);\n+      }\n+\n+      return;\n+    }\n \n+    g2 = (Graphics2D) g;\n+    font = g2.getFont();\n+    frc = g2.getFontRenderContext();\n+    lineMetrics = font.getLineMetrics(text, frc);\n+    layout = new TextLayout(text, font, frc);\n+\n+    /* Draw the text. */\n+    layout.draw(g2, x, y);\n+    if (!drawUnderline)\n+      return;\n+\n+    underlineX1 = x + layout.getLogicalHighlightShape(\n+     underlinedIndex, underlinedIndex).getBounds2D().getX();\n+    underlineX2 = x + layout.getLogicalHighlightShape(\n+     underlinedIndex + 1, underlinedIndex + 1).getBounds2D().getX();\n+\n+    underline = new Rectangle2D.Double();\n+    if (underlineX1 < underlineX2)\n+    {\n+      underline.x = underlineX1;\n+      underline.width = underlineX2 - underlineX1;\n+    }\n+    else\n+    {\n+      underline.x = underlineX2;\n+      underline.width = underlineX1 - underlineX2;\n+    }\n+\n+    \n+    underline.height = lineMetrics.getUnderlineThickness();\n+    underline.y = lineMetrics.getUnderlineOffset();\n+    if (underline.y == 0)\n+    {\n+      /* Some fonts do not specify an underline offset, although they\n+       * actually should do so. In that case, the result of calling\n+       * lineMetrics.getUnderlineOffset() will be zero. Since it would\n+       * look very ugly if the underline was be positioned immediately\n+       * below the baseline, we check for this and move the underline\n+       * below the descent, as shown in the following ASCII picture:\n+       *\n+       *   #####       ##### #\n+       *  #     #     #     #\n+       *  #     #     #     #\n+       *  #     #     #     #\n+       *   #####       ######        ---- baseline (0)\n+       *                    #\n+       *                    #\n+       * ------------------###----------- lineMetrics.getDescent()\n+       */\n+      underline.y = lineMetrics.getDescent();\n+    }\n+\n+    underline.y += y;\n+    g2.fill(underline);\n+  }\n+\n+\n+  /**\n+   * Draws a rectangle, simulating a dotted stroke by painting only\n+   * every second pixel along the one-pixel thick edge. The color of\n+   * those pixels is the current color of the Graphics <code>g</code>.\n+   * Any other pixels are left unchanged.\n+   *\n+   * <p><img src=\"BasicGraphicsUtils-7.png\" width=\"360\"\n+   * height=\"200\" alt=\"[An illustration that shows which pixels\n+   * get painted]\" />\n+   *\n+   * @param g the graphics into which the rectangle is drawn.\n+   * @param x the x coordinate of the rectangle.\n+   * @param y the y coordinate of the rectangle.\n+   * @param width the width of the rectangle in pixels.\n+   * @param height the height of the rectangle in pixels.\n+   */\n+  public static void drawDashedRect(Graphics g,\n+                                    int x, int y, int width, int height)\n+  {\n+    int right = x + width - 1;\n+    int bottom = y + height - 1;\n+\n+    /* Draw the top and bottom edge of the dotted rectangle. */\n+    for (int i = x; i <= right; i += 2)\n+    {\n+      g.drawLine(i, y, i, y);\n+      g.drawLine(i, bottom, i, bottom);\n+    }\n+\n+    /* Draw the left and right edge of the dotted rectangle. */\n+    for (int i = y; i <= bottom; i += 2)\n+    {\n+      g.drawLine(x, i, x, i);\n+      g.drawLine(right, i, right, i);\n+    }\n+  }\n+\n+\n+  /**\n+   * Determines the preferred width and height of an AbstractButton,\n+   * given the gap between the button&#x2019;s text and icon.\n+   *\n+   * @param b the button whose preferred size is determined.\n+   *\n+   * @param textIconGap the gap between the button&#x2019;s text and\n+   *        icon.\n+   *\n+   * @return a <code>Dimension</code> object whose <code>width</code>\n+   *         and <code>height</code> fields indicate the preferred\n+   *         extent in pixels.\n+   *\n+   * @see javax.swing.SwingUtilities#layoutCompoundLabel\n+   */\n+  public static Dimension getPreferredButtonSize(AbstractButton b,\n+                                                 int textIconGap)\n+  {\n+    Rectangle contentRect;\n+    Rectangle viewRect;\n+    Rectangle iconRect = new Rectangle();\n+    Rectangle textRect = new Rectangle();\n+    Insets insets = b.getInsets();\n+    \n+    /* For determining the ideal size, do not assume a size restriction. */\n+    viewRect = new Rectangle(0, 0,\n+                             /* width */ Integer.MAX_VALUE,\n+                             /* height */ Integer.MAX_VALUE);\n+\n+     /* java.awt.Toolkit.getFontMetrics is deprecated. However, it\n+     * seems not obvious how to get to the correct FontMetrics object\n+     * otherwise. The real problem probably is that the method\n+     * javax.swing.SwingUtilities.layoutCompundLabel should take a\n+     * LineMetrics, not a FontMetrics argument. But fixing this that\n+     * would change the public API.\n+     */\n+    SwingUtilities.layoutCompoundLabel(\n+      b, // for the component orientation\n+      b.getToolkit().getFontMetrics(b.getFont()), // see comment above\n+      b.getText(),\n+      b.getIcon(),\n+      b.getVerticalAlignment(),\n+      b.getHorizontalAlignment(),\n+      b.getVerticalTextPosition(),\n+      b.getHorizontalTextPosition(),\n+      viewRect, iconRect, textRect,\n+      textIconGap);\n+\n+\n+    /*  +------------------------+       +------------------------+\n+     *  |                        |       |                        |\n+     *  | ICON                   |       | CONTENTCONTENTCONTENT  |\n+     *  |          TEXTTEXTTEXT  |  -->  | CONTENTCONTENTCONTENT  |\n+     *  |          TEXTTEXTTEXT  |       | CONTENTCONTENTCONTENT  |\n+     *  +------------------------+       +------------------------+\n+     */\n+    contentRect = textRect.union(iconRect);\n+\n+    return new Dimension(insets.left + contentRect.width + insets.right,\n+                         insets.top + contentRect.height + insets.bottom);\n+  }\n+}"}, {"sha": "0adad4dafa56cc98e36c80e4a2c95f86204d89c6", "filename": "libjava/javax/swing/plaf/basic/BasicLabelUI.java", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLabelUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLabelUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLabelUI.java?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "patch": "@@ -65,6 +65,10 @@ public void installUI(final JComponent c)  {\n     public Dimension getPreferredSize(JComponent c) \n     {\n \tJLabel b = (JLabel)c;\n+        /*\n+          We cannot use this method because it is not part of the\n+          official Swing API.\n+\n \tDimension d = BasicGraphicsUtils.getPreferredSize(b, \n \t\t\t\t\t\t\t  gap,\n \t\t\t\t\t\t\t  b.getText(),\n@@ -74,7 +78,8 @@ public Dimension getPreferredSize(JComponent c)\n \t\t\t\t\t\t\t  b.getHorizontalTextPosition(),\n \t\t\t\t\t\t\t  b.getVerticalTextPosition());\n \tSystem.out.println(\"JLABEL->^^^^^^^^^^^^^^^^^^^^^^   BASIC-PREF=\"+d + \",T=\"+b.getText());\n-\treturn d;\n+        */\n+        return new Dimension(100, 30);\n     }\n     \n \n@@ -90,7 +95,7 @@ public void paint(Graphics g, JComponent c)\n \n         g.setFont(f);\n \n-        FontMetrics fm = SwingUtilities.getFontMetrics(f);\n+        FontMetrics fm = g.getFontMetrics(f);\n \n         Insets i = c.getInsets();\n "}, {"sha": "bcc730c48f16508084d1751922a79f43eef2f399", "filename": "libjava/javax/swing/plaf/basic/BasicRadioButtonUI.java", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRadioButtonUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRadioButtonUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRadioButtonUI.java?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "patch": "@@ -60,14 +60,7 @@ public void installUI(final JComponent c)  {\n     public Dimension getPreferredSize(JComponent c) \n     {\n \tAbstractButton b = (AbstractButton)c;\n-\tDimension d = BasicGraphicsUtils.getPreferredSize(b, \n-\t\t\t\t\t\t\t  gap,\n-\t\t\t\t\t\t\t  b.getText(),\n-\t\t\t\t\t\t\t  b.getIcon(),\n-\t\t\t\t\t\t\t  b.getVerticalAlignment(),\n-\t\t\t\t\t\t\t  b.getHorizontalAlignment(),\n-\t\t\t\t\t\t\t  b.getHorizontalTextPosition(),\n-\t\t\t\t\t\t\t  b.getVerticalTextPosition());\n+\tDimension d = BasicGraphicsUtils.getPreferredButtonSize(b, gap);\n \t\n \t// and add a little something for the circles:\n "}, {"sha": "441c60696d5ce3dbdceed282b6c0b400fdbc885c", "filename": "libjava/javax/swing/plaf/basic/BasicToggleButtonUI.java", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToggleButtonUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToggleButtonUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToggleButtonUI.java?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3", "patch": "@@ -58,14 +58,7 @@ public void installUI(final JComponent c)  {\n     public Dimension getPreferredSize(JComponent c) \n     {\n \tAbstractButton b = (AbstractButton)c;\n-\tDimension d = BasicGraphicsUtils.getPreferredSize(b, \n-\t\t\t\t\t\t\t  gap,\n-\t\t\t\t\t\t\t  b.getText(),\n-\t\t\t\t\t\t\t  b.getIcon(),\n-\t\t\t\t\t\t\t  b.getVerticalAlignment(),\n-\t\t\t\t\t\t\t  b.getHorizontalAlignment(),\n-\t\t\t\t\t\t\t  b.getHorizontalTextPosition(),\n-\t\t\t\t\t\t\t  b.getVerticalTextPosition());\n+\tDimension d = BasicGraphicsUtils.getPreferredButtonSize(b, gap);\n \t\t\t\t\t\t\t  \n \t//System.out.println(\"^^^^^^^^^^^^^^^^^^^^^^   BASIC-PREF=\"+d + \",T=\"+b.text);\n \treturn d;"}, {"sha": "54047dcc17b7668ba880aab1b1f98df6e0a05628", "filename": "libjava/javax/swing/plaf/basic/doc-files/BasicBorders.ButtonBorder-1.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.ButtonBorder-1.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.ButtonBorder-1.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.ButtonBorder-1.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "a3841baac541eb5f58d03b7566bd8e3d9c4635a6", "filename": "libjava/javax/swing/plaf/basic/doc-files/BasicBorders.MarginBorder-1.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.MarginBorder-1.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.MarginBorder-1.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.MarginBorder-1.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "99f8c6ec47bb956548fd5909ad85a37c1cda2fe4", "filename": "libjava/javax/swing/plaf/basic/doc-files/BasicGraphicsUtils-1.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicGraphicsUtils-1.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicGraphicsUtils-1.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicGraphicsUtils-1.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "59d9a6192e278764daac699ca38f6c69cd76d5e9", "filename": "libjava/javax/swing/plaf/basic/doc-files/BasicGraphicsUtils-2.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicGraphicsUtils-2.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicGraphicsUtils-2.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicGraphicsUtils-2.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "5b0971c16471bc736ce0d93afe329e93a3c0d90d", "filename": "libjava/javax/swing/plaf/basic/doc-files/BasicGraphicsUtils-3.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicGraphicsUtils-3.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicGraphicsUtils-3.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicGraphicsUtils-3.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "ceba0b6e07aef239d8106fafca149e3df2cdd845", "filename": "libjava/javax/swing/plaf/basic/doc-files/BasicGraphicsUtils-4.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicGraphicsUtils-4.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicGraphicsUtils-4.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicGraphicsUtils-4.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "fa3055f8c5e0afe8f1dfcd7f46d2a1e782d0f02b", "filename": "libjava/javax/swing/plaf/basic/doc-files/BasicGraphicsUtils-5.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicGraphicsUtils-5.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicGraphicsUtils-5.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicGraphicsUtils-5.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "c760313e080421287cd39c441e33f54e841a74dc", "filename": "libjava/javax/swing/plaf/basic/doc-files/BasicGraphicsUtils-6.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicGraphicsUtils-6.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicGraphicsUtils-6.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicGraphicsUtils-6.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}, {"sha": "6a557a0445befdc389f0c21e0f38b4619c9b726c", "filename": "libjava/javax/swing/plaf/basic/doc-files/BasicGraphicsUtils-7.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicGraphicsUtils-7.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8993c12bee87a2fdaa5f6a1286bd43e49f2069b3/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicGraphicsUtils-7.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicGraphicsUtils-7.png?ref=8993c12bee87a2fdaa5f6a1286bd43e49f2069b3"}]}