{"sha": "0c1fb64d961eb760aba2601870f19be2b5533bd3", "node_id": "C_kwDOANBUbNoAKDBjMWZiNjRkOTYxZWI3NjBhYmEyNjAxODcwZjE5YmUyYjU1MzNiZDM", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-30T09:52:24Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-30T09:52:24Z"}, "message": "gimple-match: Make code_helper conversions explicit\n\ncode_helper provides conversions to tree_code and combined_fn.\nNow that the codebase is C++11, we can mark these conversions as\nexplicit.  This avoids accidentally using code_helpers with\nfunctions that take tree_codes, which would previously entail\na hidden unchecked conversion.\n\ngcc/\n\t* gimple-match.h (code_helper): Provide == and != overloads.\n\t(code_helper::operator tree_code): Make explicit.\n\t(code_helper::operator combined_fn): Likewise.\n\t* gimple-match-head.c (convert_conditional_op): Use explicit\n\tconversions where necessary.\n\t(gimple_resimplify1, gimple_resimplify2, gimple_resimplify3): Likewise.\n\t(maybe_push_res_to_seq, gimple_simplify): Likewise.\n\t* gimple-fold.c (replace_stmt_with_simplification): Likewise.", "tree": {"sha": "1e39c421a085a3548b643bbed9c779cd43f045c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e39c421a085a3548b643bbed9c779cd43f045c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c1fb64d961eb760aba2601870f19be2b5533bd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c1fb64d961eb760aba2601870f19be2b5533bd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c1fb64d961eb760aba2601870f19be2b5533bd3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c1fb64d961eb760aba2601870f19be2b5533bd3/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33973fa754de1f95d459bfca66c0d80deec36537", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33973fa754de1f95d459bfca66c0d80deec36537", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33973fa754de1f95d459bfca66c0d80deec36537"}], "stats": {"total": 78, "additions": 45, "deletions": 33}, "files": [{"sha": "db3a462e131330dc4a418bc9a7ef33ba14290a06", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1fb64d961eb760aba2601870f19be2b5533bd3/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1fb64d961eb760aba2601870f19be2b5533bd3/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=0c1fb64d961eb760aba2601870f19be2b5533bd3", "patch": "@@ -5775,18 +5775,19 @@ replace_stmt_with_simplification (gimple_stmt_iterator *gsi,\n   if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n     {\n       gcc_assert (res_op->code.is_tree_code ());\n-      if (TREE_CODE_CLASS ((enum tree_code) res_op->code) == tcc_comparison\n+      auto code = tree_code (res_op->code);\n+      if (TREE_CODE_CLASS (code) == tcc_comparison\n \t  /* GIMPLE_CONDs condition may not throw.  */\n \t  && (!flag_exceptions\n \t      || !cfun->can_throw_non_call_exceptions\n-\t      || !operation_could_trap_p (res_op->code,\n+\t      || !operation_could_trap_p (code,\n \t\t\t\t\t  FLOAT_TYPE_P (TREE_TYPE (ops[0])),\n \t\t\t\t\t  false, NULL_TREE)))\n-\tgimple_cond_set_condition (cond_stmt, res_op->code, ops[0], ops[1]);\n-      else if (res_op->code == SSA_NAME)\n+\tgimple_cond_set_condition (cond_stmt, code, ops[0], ops[1]);\n+      else if (code == SSA_NAME)\n \tgimple_cond_set_condition (cond_stmt, NE_EXPR, ops[0],\n \t\t\t\t   build_zero_cst (TREE_TYPE (ops[0])));\n-      else if (res_op->code == INTEGER_CST)\n+      else if (code == INTEGER_CST)\n \t{\n \t  if (integer_zerop (ops[0]))\n \t    gimple_cond_make_false (cond_stmt);\n@@ -5817,11 +5818,12 @@ replace_stmt_with_simplification (gimple_stmt_iterator *gsi,\n   else if (is_gimple_assign (stmt)\n \t   && res_op->code.is_tree_code ())\n     {\n+      auto code = tree_code (res_op->code);\n       if (!inplace\n-\t  || gimple_num_ops (stmt) > get_gimple_rhs_num_ops (res_op->code))\n+\t  || gimple_num_ops (stmt) > get_gimple_rhs_num_ops (code))\n \t{\n \t  maybe_build_generic_op (res_op);\n-\t  gimple_assign_set_rhs_with_ops (gsi, res_op->code,\n+\t  gimple_assign_set_rhs_with_ops (gsi, code,\n \t\t\t\t\t  res_op->op_or_null (0),\n \t\t\t\t\t  res_op->op_or_null (1),\n \t\t\t\t\t  res_op->op_or_null (2));\n@@ -5838,7 +5840,7 @@ replace_stmt_with_simplification (gimple_stmt_iterator *gsi,\n \t}\n     }\n   else if (res_op->code.is_fn_code ()\n-\t   && gimple_call_combined_fn (stmt) == res_op->code)\n+\t   && gimple_call_combined_fn (stmt) == combined_fn (res_op->code))\n     {\n       gcc_assert (num_ops == gimple_call_num_args (stmt));\n       for (unsigned int i = 0; i < num_ops; ++i)"}, {"sha": "73d9c5cf366c62c9497c9de41fc254561a9cf7cf", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1fb64d961eb760aba2601870f19be2b5533bd3/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1fb64d961eb760aba2601870f19be2b5533bd3/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=0c1fb64d961eb760aba2601870f19be2b5533bd3", "patch": "@@ -96,7 +96,7 @@ convert_conditional_op (gimple_match_op *orig_op,\n     ifn = get_conditional_internal_fn ((tree_code) orig_op->code);\n   else\n     {\n-      combined_fn cfn = orig_op->code;\n+      auto cfn = combined_fn (orig_op->code);\n       if (!internal_fn_p (cfn))\n \treturn false;\n       ifn = get_conditional_internal_fn (as_internal_fn (cfn));\n@@ -206,10 +206,10 @@ gimple_resimplify1 (gimple_seq *seq, gimple_match_op *res_op,\n       tree tem = NULL_TREE;\n       if (res_op->code.is_tree_code ())\n \t{\n-\t  tree_code code = res_op->code;\n+\t  auto code = tree_code (res_op->code);\n \t  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code))\n \t      && TREE_CODE_LENGTH (code) == 1)\n-\t    tem = const_unop (res_op->code, res_op->type, res_op->ops[0]);\n+\t    tem = const_unop (code, res_op->type, res_op->ops[0]);\n \t}\n       else\n \ttem = fold_const_call (combined_fn (res_op->code), res_op->type,\n@@ -272,10 +272,10 @@ gimple_resimplify2 (gimple_seq *seq, gimple_match_op *res_op,\n       tree tem = NULL_TREE;\n       if (res_op->code.is_tree_code ())\n \t{\n-\t  tree_code code = res_op->code;\n+\t  auto code = tree_code (res_op->code);\n \t  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code))\n \t      && TREE_CODE_LENGTH (code) == 2)\n-\t    tem = const_binop (res_op->code, res_op->type,\n+\t    tem = const_binop (code, res_op->type,\n \t\t\t       res_op->ops[0], res_op->ops[1]);\n \t}\n       else\n@@ -294,15 +294,18 @@ gimple_resimplify2 (gimple_seq *seq, gimple_match_op *res_op,\n \n   /* Canonicalize operand order.  */\n   bool canonicalized = false;\n-  if (res_op->code.is_tree_code ()\n-      && (TREE_CODE_CLASS ((enum tree_code) res_op->code) == tcc_comparison\n-\t  || commutative_tree_code (res_op->code))\n-      && tree_swap_operands_p (res_op->ops[0], res_op->ops[1]))\n+  if (res_op->code.is_tree_code ())\n     {\n-      std::swap (res_op->ops[0], res_op->ops[1]);\n-      if (TREE_CODE_CLASS ((enum tree_code) res_op->code) == tcc_comparison)\n-\tres_op->code = swap_tree_comparison (res_op->code);\n-      canonicalized = true;\n+      auto code = tree_code (res_op->code);\n+      if ((TREE_CODE_CLASS (code) == tcc_comparison\n+\t   || commutative_tree_code (code))\n+\t  && tree_swap_operands_p (res_op->ops[0], res_op->ops[1]))\n+\t{\n+\t  std::swap (res_op->ops[0], res_op->ops[1]);\n+\t  if (TREE_CODE_CLASS (code) == tcc_comparison)\n+\t    res_op->code = swap_tree_comparison (code);\n+\t  canonicalized = true;\n+\t}\n     }\n \n   /* Limit recursion, see gimple_resimplify1.  */\n@@ -350,10 +353,10 @@ gimple_resimplify3 (gimple_seq *seq, gimple_match_op *res_op,\n       tree tem = NULL_TREE;\n       if (res_op->code.is_tree_code ())\n \t{\n-\t  tree_code code = res_op->code;\n+\t  auto code = tree_code (res_op->code);\n \t  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code))\n \t      && TREE_CODE_LENGTH (code) == 3)\n-\t    tem = fold_ternary/*_to_constant*/ (res_op->code, res_op->type,\n+\t    tem = fold_ternary/*_to_constant*/ (code, res_op->type,\n \t\t\t\t\t\tres_op->ops[0], res_op->ops[1],\n \t\t\t\t\t\tres_op->ops[2]);\n \t}\n@@ -374,7 +377,7 @@ gimple_resimplify3 (gimple_seq *seq, gimple_match_op *res_op,\n   /* Canonicalize operand order.  */\n   bool canonicalized = false;\n   if (res_op->code.is_tree_code ()\n-      && commutative_ternary_tree_code (res_op->code)\n+      && commutative_ternary_tree_code (tree_code (res_op->code))\n       && tree_swap_operands_p (res_op->ops[0], res_op->ops[1]))\n     {\n       std::swap (res_op->ops[0], res_op->ops[1]);\n@@ -599,6 +602,7 @@ maybe_push_res_to_seq (gimple_match_op *res_op, gimple_seq *seq, tree res)\n \n   if (res_op->code.is_tree_code ())\n     {\n+      auto code = tree_code (res_op->code);\n       if (!res)\n \t{\n \t  if (gimple_in_ssa_p (cfun))\n@@ -607,7 +611,7 @@ maybe_push_res_to_seq (gimple_match_op *res_op, gimple_seq *seq, tree res)\n \t    res = create_tmp_reg (res_op->type);\n \t}\n       maybe_build_generic_op (res_op);\n-      gimple *new_stmt = gimple_build_assign (res, res_op->code,\n+      gimple *new_stmt = gimple_build_assign (res, code,\n \t\t\t\t\t      res_op->op_or_null (0),\n \t\t\t\t\t      res_op->op_or_null (1),\n \t\t\t\t\t      res_op->op_or_null (2));\n@@ -617,7 +621,7 @@ maybe_push_res_to_seq (gimple_match_op *res_op, gimple_seq *seq, tree res)\n   else\n     {\n       gcc_assert (num_ops != 0);\n-      combined_fn fn = res_op->code;\n+      auto fn = combined_fn (res_op->code);\n       gcall *new_stmt = NULL;\n       if (internal_fn_p (fn))\n \t{\n@@ -1058,15 +1062,16 @@ gimple_simplify (gimple *stmt, gimple_match_op *res_op, gimple_seq *seq,\n \t   || cond_valueized)\n \t  && res_op2.code.is_tree_code ())\n \t{\n-\t  if (TREE_CODE_CLASS ((tree_code) res_op2.code) == tcc_comparison)\n+\t  auto code = tree_code (res_op2.code);\n+\t  if (TREE_CODE_CLASS (code) == tcc_comparison)\n \t    {\n \t      valueized = true;\n-\t      return build2 (res_op2.code, TREE_TYPE (op),\n+\t      return build2 (code, TREE_TYPE (op),\n \t\t\t     res_op2.ops[0], res_op2.ops[1]);\n \t    }\n-\t  else if (res_op2.code == SSA_NAME\n-\t\t   || res_op2.code == INTEGER_CST\n-\t\t   || res_op2.code == VECTOR_CST)\n+\t  else if (code == SSA_NAME\n+\t\t   || code == INTEGER_CST\n+\t\t   || code == VECTOR_CST)\n \t    {\n \t      valueized = true;\n \t      return res_op2.ops[0];"}, {"sha": "b20381c05ef6f591daf3bfcdc796a9b699c0b8d5", "filename": "gcc/gimple-match.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c1fb64d961eb760aba2601870f19be2b5533bd3/gcc%2Fgimple-match.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c1fb64d961eb760aba2601870f19be2b5533bd3/gcc%2Fgimple-match.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match.h?ref=0c1fb64d961eb760aba2601870f19be2b5533bd3", "patch": "@@ -31,15 +31,20 @@ class code_helper\n   code_helper () {}\n   code_helper (tree_code code) : rep ((int) code) {}\n   code_helper (combined_fn fn) : rep (-(int) fn) {}\n-  operator tree_code () const { return (tree_code) rep; }\n-  operator combined_fn () const { return (combined_fn) -rep; }\n+  explicit operator tree_code () const { return (tree_code) rep; }\n+  explicit operator combined_fn () const { return (combined_fn) -rep; }\n   explicit operator internal_fn () const;\n   explicit operator built_in_function () const;\n   bool is_tree_code () const { return rep > 0; }\n   bool is_fn_code () const { return rep < 0; }\n   bool is_internal_fn () const;\n   bool is_builtin_fn () const;\n   int get_rep () const { return rep; }\n+  bool operator== (const code_helper &other) { return rep == other.rep; }\n+  bool operator!= (const code_helper &other) { return rep != other.rep; }\n+  bool operator== (tree_code c) { return rep == code_helper (c).rep; }\n+  bool operator!= (tree_code c) { return rep != code_helper (c).rep; }\n+\n private:\n   int rep;\n };"}]}