{"sha": "f24acbefa1bba0669fc02ec4df0e27c97d578e82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI0YWNiZWZhMWJiYTA2NjlmYzAyZWM0ZGYwZTI3Yzk3ZDU3OGU4Mg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-08-25T14:23:47Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-08-25T14:23:47Z"}, "message": "regrename.c (scan_rtx_reg, [...]): Don't declare.\n\n\t* regrename.c (scan_rtx_reg, scan_rtx_address, build_def_use,\n\tdump_def_use_chain): Don't declare.\n\t(mark_conflict, create_new_chain): Move before users.\n\t(regrename_optimize): Move to near end of file.\n\nFrom-SVN: r178065", "tree": {"sha": "90a8397a7bf3740553778d3ceedcf0c42991738a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90a8397a7bf3740553778d3ceedcf0c42991738a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f24acbefa1bba0669fc02ec4df0e27c97d578e82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f24acbefa1bba0669fc02ec4df0e27c97d578e82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f24acbefa1bba0669fc02ec4df0e27c97d578e82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f24acbefa1bba0669fc02ec4df0e27c97d578e82/comments", "author": null, "committer": null, "parents": [{"sha": "c331eabed629d872f9e5d8e1295905ec0aabde63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c331eabed629d872f9e5d8e1295905ec0aabde63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c331eabed629d872f9e5d8e1295905ec0aabde63"}], "stats": {"total": 263, "additions": 132, "deletions": 131}, "files": [{"sha": "11c667a93fd55b2631ef899b48104977da60cf88", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f24acbefa1bba0669fc02ec4df0e27c97d578e82/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f24acbefa1bba0669fc02ec4df0e27c97d578e82/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f24acbefa1bba0669fc02ec4df0e27c97d578e82", "patch": "@@ -1,3 +1,10 @@\n+2011-08-25  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* regrename.c (scan_rtx_reg, scan_rtx_address, build_def_use,\n+\tdump_def_use_chain): Don't declare.\n+\t(mark_conflict, create_new_chain): Move before users.\n+\t(regrename_optimize): Move to near end of file.\n+\n 2011-08-25  Georg-Johann Lay  <avr@gjlay.de>\n \n \t* config/avr-protos.h (byte_immediate_operand): Remove Prototype.\n@@ -13,7 +20,7 @@\n \tavr_regno_reg_class.  Return smallest register class available.\n \t\n 2011-08-25  Georg-Johann Lay  <avr@gjlay.de>\n-\t\n+\n \t* config/avr/avr.c (STR_PREFIX_P): New Define.\n \t(avr_asm_declare_function_name): Use it.\n \t(avr_asm_named_section): Use it."}, {"sha": "e547bf25884a095329e450479ad34680ae1f0247", "filename": "gcc/regrename.c", "status": "modified", "additions": 124, "deletions": 130, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f24acbefa1bba0669fc02ec4df0e27c97d578e82/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f24acbefa1bba0669fc02ec4df0e27c97d578e82/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=f24acbefa1bba0669fc02ec4df0e27c97d578e82", "patch": "@@ -138,14 +138,8 @@ static int this_tick = 0;\n static struct obstack rename_obstack;\n \n static void do_replace (struct du_head *, int);\n-static void scan_rtx_reg (rtx, rtx *, enum reg_class,\n-\t\t\t  enum scan_actions, enum op_type);\n-static void scan_rtx_address (rtx, rtx *, enum reg_class,\n-\t\t\t      enum scan_actions, enum machine_mode);\n static void scan_rtx (rtx, rtx *, enum reg_class, enum scan_actions,\n \t\t      enum op_type);\n-static struct du_head *build_def_use (basic_block);\n-static void dump_def_use_chain (struct du_head *);\n \n typedef struct du_head *du_head_p;\n DEF_VEC_P (du_head_p);\n@@ -204,6 +198,84 @@ free_chain_data (void)\n   VEC_free (du_head_p, heap, id_to_chain);\n }\n \n+/* Walk all chains starting with CHAINS and record that they conflict with\n+   another chain whose id is ID.  */\n+\n+static void\n+mark_conflict (struct du_head *chains, unsigned id)\n+{\n+  while (chains)\n+    {\n+      bitmap_set_bit (&chains->conflicts, id);\n+      chains = chains->next_chain;\n+    }\n+}\n+\n+/* Create a new chain for THIS_NREGS registers starting at THIS_REGNO,\n+   and record its occurrence in *LOC, which is being written to in INSN.\n+   This access requires a register of class CL.  */\n+\n+static void\n+create_new_chain (unsigned this_regno, unsigned this_nregs, rtx *loc,\n+\t\t  rtx insn, enum reg_class cl)\n+{\n+  struct du_head *head = XOBNEW (&rename_obstack, struct du_head);\n+  struct du_chain *this_du;\n+  int nregs;\n+\n+  head->next_chain = open_chains;\n+  open_chains = head;\n+  head->regno = this_regno;\n+  head->nregs = this_nregs;\n+  head->need_caller_save_reg = 0;\n+  head->cannot_rename = 0;\n+\n+  VEC_safe_push (du_head_p, heap, id_to_chain, head);\n+  head->id = current_id++;\n+\n+  bitmap_initialize (&head->conflicts, &bitmap_default_obstack);\n+  bitmap_copy (&head->conflicts, &open_chains_set);\n+  mark_conflict (open_chains, head->id);\n+\n+  /* Since we're tracking this as a chain now, remove it from the\n+     list of conflicting live hard registers and track it in\n+     live_in_chains instead.  */\n+  nregs = head->nregs;\n+  while (nregs-- > 0)\n+    {\n+      SET_HARD_REG_BIT (live_in_chains, head->regno + nregs);\n+      CLEAR_HARD_REG_BIT (live_hard_regs, head->regno + nregs);\n+    }\n+\n+  COPY_HARD_REG_SET (head->hard_conflicts, live_hard_regs);\n+  bitmap_set_bit (&open_chains_set, head->id);\n+\n+  open_chains = head;\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Creating chain %s (%d)\",\n+\t       reg_names[head->regno], head->id);\n+      if (insn != NULL_RTX)\n+\tfprintf (dump_file, \" at insn %d\", INSN_UID (insn));\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  if (insn == NULL_RTX)\n+    {\n+      head->first = head->last = NULL;\n+      return;\n+    }\n+\n+  this_du = XOBNEW (&rename_obstack, struct du_chain);\n+  head->first = head->last = this_du;\n+\n+  this_du->next_use = 0;\n+  this_du->loc = loc;\n+  this_du->insn = insn;\n+  this_du->cl = cl;\n+}\n+\n /* For a def-use chain HEAD, find which registers overlap its lifetime and\n    set the corresponding bits in *PSET.  */\n \n@@ -416,52 +488,6 @@ rename_chains (du_head_p all_chains)\n     }\n }\n \n-/* Perform register renaming on the current function.  */\n-\n-static unsigned int\n-regrename_optimize (void)\n-{\n-  basic_block bb;\n-  char *first_obj;\n-\n-  df_set_flags (DF_LR_RUN_DCE);\n-  df_note_add_problem ();\n-  df_analyze ();\n-  df_set_flags (DF_DEFER_INSN_RESCAN);\n-\n-  memset (tick, 0, sizeof tick);\n-\n-  gcc_obstack_init (&rename_obstack);\n-  first_obj = XOBNEWVAR (&rename_obstack, char, 0);\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      struct du_head *all_chains = 0;\n-\n-      id_to_chain = VEC_alloc (du_head_p, heap, 0);\n-\n-      if (dump_file)\n-\tfprintf (dump_file, \"\\nBasic block %d:\\n\", bb->index);\n-\n-      all_chains = build_def_use (bb);\n-\n-      if (dump_file)\n-\tdump_def_use_chain (all_chains);\n-\n-      rename_chains (all_chains);\n-\n-      free_chain_data ();\n-      obstack_free (&rename_obstack, first_obj);\n-    }\n-\n-  obstack_free (&rename_obstack, NULL);\n-\n-  if (dump_file)\n-    fputc ('\\n', dump_file);\n-\n-  return 0;\n-}\n-\n static void\n do_replace (struct du_head *head, int reg)\n {\n@@ -492,19 +518,6 @@ do_replace (struct du_head *head, int reg)\n }\n \n \n-/* Walk all chains starting with CHAINS and record that they conflict with\n-   another chain whose id is ID.  */\n-\n-static void\n-mark_conflict (struct du_head *chains, unsigned id)\n-{\n-  while (chains)\n-    {\n-      bitmap_set_bit (&chains->conflicts, id);\n-      chains = chains->next_chain;\n-    }\n-}\n-\n /* True if we found a register with a size mismatch, which means that we\n    can't track its lifetime accurately.  If so, we abort the current block\n    without renaming.  */\n@@ -570,71 +583,6 @@ note_sets_clobbers (rtx x, const_rtx set, void *data)\n     add_to_hard_reg_set (&chain->hard_conflicts, GET_MODE (x), REGNO (x));\n }\n \n-/* Create a new chain for THIS_NREGS registers starting at THIS_REGNO,\n-   and record its occurrence in *LOC, which is being written to in INSN.\n-   This access requires a register of class CL.  */\n-\n-static void\n-create_new_chain (unsigned this_regno, unsigned this_nregs, rtx *loc,\n-\t\t  rtx insn, enum reg_class cl)\n-{\n-  struct du_head *head = XOBNEW (&rename_obstack, struct du_head);\n-  struct du_chain *this_du;\n-  int nregs;\n-\n-  head->next_chain = open_chains;\n-  open_chains = head;\n-  head->regno = this_regno;\n-  head->nregs = this_nregs;\n-  head->need_caller_save_reg = 0;\n-  head->cannot_rename = 0;\n-\n-  VEC_safe_push (du_head_p, heap, id_to_chain, head);\n-  head->id = current_id++;\n-\n-  bitmap_initialize (&head->conflicts, &bitmap_default_obstack);\n-  bitmap_copy (&head->conflicts, &open_chains_set);\n-  mark_conflict (open_chains, head->id);\n-\n-  /* Since we're tracking this as a chain now, remove it from the\n-     list of conflicting live hard registers and track it in\n-     live_in_chains instead.  */\n-  nregs = head->nregs;\n-  while (nregs-- > 0)\n-    {\n-      SET_HARD_REG_BIT (live_in_chains, head->regno + nregs);\n-      CLEAR_HARD_REG_BIT (live_hard_regs, head->regno + nregs);\n-    }\n-\n-  COPY_HARD_REG_SET (head->hard_conflicts, live_hard_regs);\n-  bitmap_set_bit (&open_chains_set, head->id);\n-\n-  open_chains = head;\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"Creating chain %s (%d)\",\n-\t       reg_names[head->regno], head->id);\n-      if (insn != NULL_RTX)\n-\tfprintf (dump_file, \" at insn %d\", INSN_UID (insn));\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  if (insn == NULL_RTX)\n-    {\n-      head->first = head->last = NULL;\n-      return;\n-    }\n-\n-  this_du = XOBNEW (&rename_obstack, struct du_chain);\n-  head->first = head->last = this_du;\n-\n-  this_du->next_use = 0;\n-  this_du->loc = loc;\n-  this_du->insn = insn;\n-  this_du->cl = cl;\n-}\n-\n static void\n scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n \t      enum op_type type)\n@@ -1400,6 +1348,52 @@ build_def_use (basic_block bb)\n   return closed_chains;\n }\n \f\n+/* Perform register renaming on the current function.  */\n+\n+static unsigned int\n+regrename_optimize (void)\n+{\n+  basic_block bb;\n+  char *first_obj;\n+\n+  df_set_flags (DF_LR_RUN_DCE);\n+  df_note_add_problem ();\n+  df_analyze ();\n+  df_set_flags (DF_DEFER_INSN_RESCAN);\n+\n+  memset (tick, 0, sizeof tick);\n+\n+  gcc_obstack_init (&rename_obstack);\n+  first_obj = XOBNEWVAR (&rename_obstack, char, 0);\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      struct du_head *all_chains = 0;\n+\n+      id_to_chain = VEC_alloc (du_head_p, heap, 0);\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"\\nBasic block %d:\\n\", bb->index);\n+\n+      all_chains = build_def_use (bb);\n+\n+      if (dump_file)\n+\tdump_def_use_chain (all_chains);\n+\n+      rename_chains (all_chains);\n+\n+      free_chain_data ();\n+      obstack_free (&rename_obstack, first_obj);\n+    }\n+\n+  obstack_free (&rename_obstack, NULL);\n+\n+  if (dump_file)\n+    fputc ('\\n', dump_file);\n+\n+  return 0;\n+}\n+\f\n static bool\n gate_handle_regrename (void)\n {"}]}