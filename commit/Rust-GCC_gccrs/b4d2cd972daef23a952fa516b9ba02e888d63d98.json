{"sha": "b4d2cd972daef23a952fa516b9ba02e888d63d98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRkMmNkOTcyZGFlZjIzYTk1MmZhNTE2YjliYTAyZTg4OGQ2M2Q5OA==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-07-11T22:53:08Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-07-11T22:53:08Z"}, "message": "h8300.md (cpu): New attribute.\n\n\t* h8300/h8300.md (cpu): New attribute.\n\t(attribute length): Add h8/300h support.\n\t(attribute cc): New value `cbit'.\n\t(all anonymous insns): Give them names.\n\t(move insns): Add h8/300h support.\n\t(tstqi, tsthi): Use btst insn if able.\n\t(arithmetic insns): Add h8/300h support.\n\t(boolean insns): Likewise.\n\t(negate insns): Likewise.\n\t(branch insns): Likewise.\n\t(call_value): Use call_insn_operand for operand 1.\n\t(shift insns): Completely rewritten.  Add h8/300h support.\n\t(zero/sign extension insns): Add h8/300h support.\n\t(extv): Deleted.\n\t(insv, extzv): Only use for h8/300.\n\t(bitfield insns): Completely rewritten.\n\t(fancyb*): New insns for speeding up bit accesses.\n\nFrom-SVN: r7730", "tree": {"sha": "b22eff71ad1077e1e050934fd3c0a196d4b71c4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b22eff71ad1077e1e050934fd3c0a196d4b71c4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4d2cd972daef23a952fa516b9ba02e888d63d98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4d2cd972daef23a952fa516b9ba02e888d63d98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4d2cd972daef23a952fa516b9ba02e888d63d98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4d2cd972daef23a952fa516b9ba02e888d63d98/comments", "author": null, "committer": null, "parents": [{"sha": "48837e291c0868b323a1304af01482124d44b3f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48837e291c0868b323a1304af01482124d44b3f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48837e291c0868b323a1304af01482124d44b3f5"}], "stats": {"total": 2314, "additions": 1605, "deletions": 709}, "files": [{"sha": "5c5c3ae69d04494b4422b661942e8b3160605e1d", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 1605, "deletions": 709, "changes": 2314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d2cd972daef23a952fa516b9ba02e888d63d98/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d2cd972daef23a952fa516b9ba02e888d63d98/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=b4d2cd972daef23a952fa516b9ba02e888d63d98", "patch": "@@ -1,5 +1,8 @@\n-;;- Machine description for the Hitachi H8/300 for the GNU C compiler\n-;;   Copyright (C) 1992, 1993 Free Software Foundation, Inc.\n+;; GCC machine description for Hitachi H8/300\n+;; Copyright (C) 1992, 1993, 1994 Free Software Foundation, Inc.\n+\n+;;   Contributed by Steve Chamberlain (sac@cygnus.com),\n+;;   Jim Wilson (wilson@cygnus.com), and Doug Evans (dje@cygnus.com).\n \n ;; This file is part of GNU CC.\n \n@@ -23,6 +26,12 @@\n \n ;; See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n \n+(define_attr \"cpu\" \"h8300,h8300h\"\n+  (const (symbol_ref \"cpu_type\")))\n+\n+;; ??? If we can remove the operand type on all the insns, do it.\n+;; ??? Otherwise, try to have the operand type on all the insns.\n+\n (define_attr \"type\" \"branch,return,call,arith,move,float,multi\"\n   (const_string \"arith\"))\n \n@@ -31,53 +40,119 @@\n (define_attr \"length\" \"\" \n   (cond [(eq_attr \"type\" \"branch\")\n \t (if_then_else (and (ge (minus (pc) (match_dup 0))\n-\t\t\t\t(const_int -128))\n+\t\t\t\t(const_int -120))\n \t\t\t    (le (minus (pc) (match_dup 0))\n-\t\t\t\t(const_int 128)))\n+\t\t\t\t(const_int 120)))\n \t\t       (const_int 2)\n-\t\t       (const_int 6))\n+\t\t       (if_then_else (and (eq_attr \"cpu\" \"h8300h\")\n+\t\t\t\t\t  (and (ge (minus (pc) (match_dup 0))\n+\t\t\t\t\t\t   (const_int -32000))\n+\t\t\t\t\t       (le (minus (pc) (match_dup 0))\n+\t\t\t\t\t\t   (const_int 32000))))\n+\t\t\t\t     (const_int 4)\n+\t\t\t\t     (const_int 6)))\n \t (eq_attr \"type\" \"move\")\t(const_int 4)\n \t (eq_attr \"type\" \"return\")\t(const_int 2)\n \t (eq_attr \"type\" \"float\")\t(const_int 12)\n \t (eq_attr \"type\" \"call\")\t(const_int 4)]\n \t(const_int 200)))\n \n-\n-(define_attr \"cc\" \"none,clobber,none_0hit,set,compare,whoops\" \n+(define_attr \"cc\" \"none,clobber,none_0hit,set,compare,whoops,cbit\" \n   (const_string \"whoops\"))\n-\f\n+\n ;; ----------------------------------------------------------------------\n-;; move instructions\n+;; MOVE INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-;; movhi\n+;; movqi\n \n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"push_operand\" \"=<\")\n-\t(match_operand:HI 1 \"register_operand\" \"ra\"))]\n+(define_insn \"movqi_push\"\n+  [(set (match_operand:QI 0 \"push_operand\" \"=<\")\n+\t(match_operand:QI 1 \"register_operand\" \"r\"))]\n   \"\"\n-  \"mov.w\t%T1,%T0\"\n+  \"*\n+{\n+  if (TARGET_H8300)\n+    return \\\"push.w\t%T1\\\";\n+  else\n+    return \\\"push.l\t%S1\\\";\n+}\"\n   [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"2\")\n+   (set (attr \"length\") (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 2) (const_int 4)))\n    (set_attr \"cc\" \"set\")])\n \n-(define_insn \"movstricthi\"\n-  [(set (strict_low_part (match_operand:HI 0 \"general_operand_dst\" \"=r,r,r,o,<\"))\n-\t(match_operand:HI 1 \"general_operand_src\" \"I,r,io,r,r\"))]\n+(define_insn \"movqi_internal\"\n+  [(set (match_operand:QI 0 \"general_operand_dst\" \"=r,r,r,o,<,r\")\n+\t(match_operand:QI 1 \"general_operand_src\" \"I,r>,io,r,r,c\"))]\n+  \"register_operand (operands[0],QImode) || register_operand (operands[1], QImode)\"\n+  \"@\n+   sub.b\t%X0,%X0\n+   mov.b\t%X1,%X0\n+   mov.b\t%X1,%X0\n+   mov.b\t%X1,%X0\n+   mov.b\t%X1,%X0\n+   xor\t\t%X0,%X0\\;bst\t#0,%X0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr_alternative \"length\"\n+     [(const_int 2) (const_int 2)\n+      (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 4) (const_int 8))\n+      (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 4) (const_int 8))\n+      (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 2) (const_int 4))\n+      (const_int 4)])\n+   (set_attr \"cc\" \"set,set,set,set,set,none\")])\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand_dst\" \"\")\n+\t(match_operand:QI 1 \"general_operand_src\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register */\n+  if (!register_operand(operand0, QImode)\n+      && !register_operand(operand1, QImode))\n+    {\n+      operands[1] = copy_to_mode_reg(QImode, operand1);\n+    }\n+}\")\n+\n+(define_insn \"movstrictqi\"\n+  [(set (strict_low_part (match_operand:QI 0 \"general_operand_dst\" \"=r,r,r,o,<\"))\n+\t\t\t (match_operand:QI 1 \"general_operand_src\" \"I,r,io,r,r\"))]\n   \"\"\n   \"@\n-   sub.w\t%T0,%T0\n-   mov.w\t%T1,%T0\n-   mov.w\t%T1,%T0\n-   mov.w\t%T1,%T0\n-   mov.w\t%T1,%T0\"\n+   sub.b\t%X0,%X0\n+   mov.b\t%X1,%X0\n+   mov.b\t%X1,%X0\n+   mov.b\t%X1,%X0\n+   mov.b\t%X1,%X0\"\n   [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"2,2,4,4,2\")\n+   (set_attr_alternative \"length\"\n+     [(const_int 2) (const_int 2)\n+      (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 4) (const_int 8))\n+      (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 4) (const_int 8))\n+      (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 2) (const_int 4))])\n+   (set_attr \"cc\" \"set\")])\n+   \n+;; movhi\n+\n+(define_insn \"movhi_push\"\n+  [(set (match_operand:HI 0 \"push_operand\" \"=<\")\n+\t(match_operand:HI 1 \"register_operand\" \"ra\"))]\n+  \"\"\n+  \"*\n+{\n+  if (TARGET_H8300)\n+    return \\\"push.w\t%T1\\\";\n+  else\n+    return \\\"push.l\t%S1\\\";\n+}\"\n+  [(set_attr \"type\" \"move\")\n+   (set (attr \"length\") (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 2) (const_int 4)))\n    (set_attr \"cc\" \"set\")])\n \n-(define_insn \"\"\n+(define_insn \"movhi_internal\"\n   [(set (match_operand:HI 0 \"general_operand_dst\" \"=ra,ra,ra,o,<\")\n-\t(match_operand:HI 1 \"general_operand_src\" \"I,ra,ion,ra,ra\"))]\n+\t(match_operand:HI 1 \"general_operand_src\" \"I,ra>,ion,ra,ra\"))]\n   \"\"\n   \"@\n    sub.w\t%T0,%T0\n@@ -86,7 +161,11 @@\n    mov.w\t%T1,%T0\n    mov.w\t%T1,%T0\"\n   [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"2,2,4,4,2\")\n+   (set_attr_alternative \"length\"\n+     [(const_int 2) (const_int 2)\n+      (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 4) (const_int 8))\n+      (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 4) (const_int 8))\n+      (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 2) (const_int 4))])\n    (set_attr \"cc\" \"set\")])\n \n (define_expand \"movhi\"\n@@ -95,79 +174,84 @@\n   \"\"\n   \"\n {\n-  /* One of the ops has to be in a register.  */\n-  if (! register_operand (operand1, HImode)\n-      && ! register_operand (operand0, HImode))\n-    operands[1] = copy_to_mode_reg (HImode, operand1);\n+  /* One of the ops has to be in a register */\n+  if (!register_operand(operand1, HImode)\n+      && !register_operand(operand0, HImode))\n+    {\n+      operands[1] = copy_to_mode_reg(HImode, operand1);\n+    }\n }\")\n \n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=&ra\")\n-\t(plus:HI (match_operand:HI 1 \"general_operand_src\" \"g\")\n-\t\t (match_operand:HI 2 \"register_operand\" \"ra\")))]\n-  \"\"\n-  \"mov.w\t%T1,%T0\\;add.w\t%T2,%T0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"length\" \"6\")\n-   (set_attr \"cc\" \"set\")])\n-\n-;; movqi\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"push_operand\" \"=<\")\n-\t(match_operand:QI 1 \"register_operand\" \"r\"))]\n-  \"\"\n-  \"mov.w\t%T1,%T0\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"set\")])\n-\n-(define_insn \"movstrictqi\"\n-  [(set (strict_low_part (match_operand:QI 0 \"general_operand_dst\" \"=r,r,r,o,<\"))\n-\t(match_operand:QI 1 \"general_operand_src\" \"I,r,io,r,r\"))]\n+(define_insn \"movstricthi\"\n+  [(set (strict_low_part (match_operand:HI 0 \"general_operand_dst\" \"=r,r,r,o,<\"))\n+\t\t\t (match_operand:HI 1 \"general_operand_src\" \"I,r,io,r,r\"))]\n   \"\"\n   \"@\n-   sub.b\t%X0,%X0\n-   mov.b\t%X1,%X0\n-   mov.b\t%X1,%X0\n-   mov.b\t%X1,%X0\n-   mov.b\t%X1,%X0\"\n+   sub.w\t%T0,%T0\n+   mov.w\t%T1,%T0\n+   mov.w\t%T1,%T0\n+   mov.w\t%T1,%T0\n+   mov.w\t%T1,%T0\"\n   [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"2,2,4,4,2\")\n+   (set_attr_alternative \"length\"\n+     [(const_int 2) (const_int 2)\n+      (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 4) (const_int 8))\n+      (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 4) (const_int 8))\n+      (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 2) (const_int 4))])\n    (set_attr \"cc\" \"set\")])\n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand_dst\" \"=r,r,r,o,<\")\n-\t(match_operand:QI 1 \"general_operand_src\" \"I,r,io,r,r\"))]\n-  \"\"\n-  \"@\n-   sub.b\t%X0,%X0\n-   mov.b\t%X1,%X0\n-   mov.b\t%X1,%X0\n-   mov.b\t%X1,%X0\n-   mov.b\t%X1,%X0\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"2,2,4,4,2\")\n-   (set_attr \"cc\" \"set\")])\n+;; movsi\n \n-(define_expand \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand_dst\" \"\")\n-\t(match_operand:QI 1 \"general_operand_src\" \"\"))]\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand_dst\" \"\")\n+\t(match_operand:SI 1 \"general_operand_src\" \"\"))]\n   \"\"\n   \"\n {\n-  /* One of the ops has to be in a register.  */\n-  if (! register_operand (operand0, QImode)\n-      && ! register_operand (operand1, QImode))\n-    operands[1] = copy_to_mode_reg (QImode, operand1);\n+  if (TARGET_H8300)\n+    {\n+      if (do_movsi (operands))\n+\tDONE;\n+    }\n+  else /* TARGET_H8300H */\n+    {\n+      /* One of the ops has to be in a register.  */\n+      if (!register_operand (operand1, SImode)\n+\t  && !register_operand (operand0, SImode))\n+\t{\n+\t  operands[1] = copy_to_mode_reg (SImode, operand1);\n+\t}\n+    }\n }\")\n \n-;; movsi\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand_dst\" \"=l,l,l,o,<\")\n-\t(match_operand:SI 1 \"general_operand_src\" \"I,l,ion,l,l\"))]\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand_dst\" \"\")\n+\t(match_operand:SF 1 \"general_operand_src\" \"\"))]\n   \"\"\n+  \"\n+{\n+  if (TARGET_H8300)\n+    {\n+      if (do_movsi (operands))\n+\tDONE;\n+    }\n+  else /* TARGET_H8300H */\n+    {\n+      /* One of the ops has to be in a register.  */\n+      if (!register_operand (operand1, SFmode)\n+\t  && !register_operand (operand0, SFmode))\n+\t{\n+\t  operands[1] = copy_to_mode_reg (SFmode, operand1);\n+\t}\n+    }\n+}\")\n+\n+(define_insn \"movsi_h8300\"\n+  [(set (match_operand:SI 0 \"general_operand_dst\" \"=r,r,r,o,<,r\")\n+\t(match_operand:SI 1 \"general_operand_src\" \"I,r,ion,r,r,>\"))]\n+  \"TARGET_H8300\n+   && (register_operand (operands[0], SImode)\n+       || register_operand (operands[1], SImode))\"\n   \"*\n {\n   int rn = -1;\n@@ -176,181 +260,203 @@\n     case 0:\n       return \\\"sub.w\t%e0,%e0\\;sub.w\t%f0,%f0\\\";\n     case 1:\n-      return \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n+      if (REGNO(operands[0]) < REGNO(operands[1]))\n+\treturn \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n+      else \n+\treturn \\\"mov.w\t%f1,%f0\\;mov.w\t%e1,%e0\\\";\n     case 2:\n       /* Make sure we don't trample the register we index with.  */\n     \n-      if (GET_CODE (operands[1]) == MEM) \n+      if (GET_CODE(operands[1]) == MEM) \n \t{\n-\t  rtx inside = XEXP (operands[1], 0);\n-\t  if (REG_P (inside))\n-\t    rn = REGNO (inside);\n+\t  rtx inside = XEXP (operands[1],0);\n+\t  if  (REG_P (inside)) \n+\t    {\n+\t      rn = REGNO(inside);\n+\t    }\n \t  else if (GET_CODE (inside) == PLUS) \n \t    {\n-\t      rtx lhs = XEXP (inside, 0);\n-\t      rtx rhs = XEXP (inside, 1);\n-\t      if (REG_P (lhs))\n-\t\trn = REGNO (lhs);\n-\t      if (REG_P (rhs))\n-\t\trn = REGNO (rhs);\n+\t      rtx lhs = XEXP (inside,0);\n+\t      rtx rhs = XEXP (inside,1);\n+\t      if (REG_P (lhs)) rn = REGNO (lhs);\n+\t      if (REG_P (rhs)) rn = REGNO (rhs);\n \t    }\n \t}\n-      if (rn == REGNO (operands[0]))\n-\t/* Move the second word first.  */\n-\treturn \\\"mov.w\t%f1,%f0\\;mov.w\t%e1,%e0\\\";\n+      if (rn == REGNO (operands[0])) \t\n+\t{\n+\t  /* Move the second word first.  */\n+\t  return \\\"mov.w\t%f1,%f0\\;mov.w\t%e1,%e0\\\";\n+\t}\n       else \n-\treturn \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n+\t{\n+\t  return \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n+\t}\n     \n     case 3:\n       return \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n     case 4:\n       return \\\"mov.w\t%f1,%T0\\;mov.w\t%e1,%T0\\\";\n+    case 5:\n+      return \\\"mov.w\t%T1,%e0\\;mov.w\t%T1,%f0\\\";\n     }\n }\"\n   [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"4,4,8,8,4\")\n-   (set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"push_operand\" \"=<\")\n-\t(match_operand:SI 1 \"register_operand\" \"l\"))]\n-  \"\"\n-  \"mov.w      %f1,%T0\\;mov.w\t%e1,%T0\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"4\")\n+   (set_attr \"length\" \"4,4,8,8,4,4\")\n    (set_attr \"cc\" \"clobber\")])\n \n-(define_expand \"movsi\"\n-  [(set (match_operand:SI 0 \"general_operand_dst\" \"\")\n-\t(match_operand:SI 1 \"general_operand_src\" \"\"))]\n-  \"\"\t\t\t\t\t\n-  \"if (domovsi (operands)) DONE;\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"general_operand_dst\" \"=l,l,l,o,<\")\n-\t(match_operand:SF 1 \"general_operand_src\" \"I,l,ion,l,l\"))]\n-  \"\"\n+(define_insn \"movsf_h8300\"\n+  [(set (match_operand:SF 0 \"general_operand_dst\" \"=r,r,r,o,<,r\")\n+\t(match_operand:SF 1 \"general_operand_src\" \"I,r,ion,r,r,>\"))]\n+  \"TARGET_H8300\n+   && (register_operand (operands[0], SFmode)\n+       || register_operand (operands[1], SFmode))\"\n   \"*\n {\n-  /* This is a copy of the movsi stuff.  */\n+  /* Copy of the movsi stuff */\n   int rn = -1;\n   switch (which_alternative)\n     {\n     case 0:\n       return \\\"sub.w\t%e0,%e0\\;sub.w\t%f0,%f0\\\";\n     case 1:\n-      return \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n+      if (REGNO(operands[0]) < REGNO(operands[1]))\n+\treturn \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n+      else \n+\treturn \\\"mov.w\t%f1,%f0\\;mov.w\t%e1,%e0\\\";\n     case 2:\n       /* Make sure we don't trample the register we index with.  */\n     \n       if (GET_CODE (operands[1]) == MEM) \n \t{\n-\t  rtx inside = XEXP (operands[1], 0);\n+\t  rtx inside = XEXP (operands[1],0);\n \t  if (REG_P (inside))\n-\t    rn = REGNO (inside);\n+\t    {\n+\t      rn = REGNO (inside);\n+\t    }\n \t  else if (GET_CODE (inside) == PLUS) \n \t    {\n-\t      rtx lhs = XEXP (inside, 0);\n-\t      rtx rhs = XEXP (inside, 1);\n-\t      if (REG_P (lhs))\n-\t\trn = REGNO (lhs);\n-\t      if (REG_P (rhs))\n-\t\trn = REGNO (rhs);\n+\t      rtx lhs = XEXP (inside,0);\n+\t      rtx rhs = XEXP (inside,1);\n+\t      if (REG_P (lhs)) rn = REGNO (lhs);\n+\t      if (REG_P (rhs)) rn = REGNO (rhs);\n \t    }\n \t}\n       if (rn == REGNO (operands[0]))\n-\t/* Move the second word first.  */\n-\treturn \\\"mov.w\t%f1,%f0\\;mov.w\t%e1,%e0\\\";\n+\t{\n+\t  /* move the second word first */\n+\t  return \\\"mov.w\t%f1,%f0\\;mov.w\t%e1,%e0\\\";\n+\t}\n       else \n-\treturn \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n+\t{\n+\t  return \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n+\t}\n     \n     case 3:\n       return \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n     case 4:\n       return \\\"mov.w\t%f1,%T0\\;mov.w\t%e1,%T0\\\";\n-   }\n+    case 5:\n+      return \\\"mov.w\t%T1,%e0\\;mov.w\t%T1,%f0\\\";\n+\n+    }\n }\"\n   [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"4,4,8,8,4\")\n+   (set_attr \"length\" \"4,4,8,8,4,4\")\n    (set_attr \"cc\" \"clobber\")])\n \n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"push_operand\" \"=<\")\n-\t(match_operand:SF 1 \"register_operand\" \"l\"))]\n-  \"\"\n-  \"mov.w      %f1,%T0\\;mov.w\t%e1,%T0\"\n+(define_insn \"movsi_h8300h\"\n+  [(set (match_operand:SI 0 \"general_operand_dst\" \"=ra,ra,ra,o,<,ra\")\n+\t(match_operand:SI 1 \"general_operand_src\" \"I,ra,ion,ra,ra,>\"))]\n+  \"TARGET_H8300H\n+   && (register_operand (operands[0], SImode)\n+       || register_operand (operands[1], SImode))\"\n+  \"@\n+   sub.l\t%S0,%S0\n+   mov.l\t%S1,%S0\n+   mov.l\t%S1,%S0\n+   mov.l\t%S1,%S0\n+   mov.l\t%S1,%S0\n+   mov.l\t%S1,%S0\"\n   [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"clobber\")])\n-\n-(define_expand \"movsf\"\n-  [(set (match_operand:SF 0 \"general_operand_dst\" \"\")\n-\t(match_operand:SF 1 \"general_operand_src\" \"\"))]\n-  \"\"\t\t\t\t\t\n-  \"if (domovsi (operands)) DONE;\")\n+   (set_attr \"length\" \"2,2,8,8,4,4\")\n+   (set_attr \"cc\" \"set\")])\n \n-;; Block move\n+(define_insn \"movsf_h8300h\"\n+  [(set (match_operand:SF 0 \"general_operand_dst\" \"=r,r,r,o,<\")\n+\t(match_operand:SF 1 \"general_operand_src\" \"I,r,ion,r,r\"))]\n+  \"TARGET_H8300H\n+   && (register_operand (operands[0], SFmode)\n+       || register_operand (operands[1], SFmode))\"\n+  \"@\n+   sub.l\t%S0,%S0\n+   mov.l\t%S1,%S0\n+   mov.l\t%S1,%S0\n+   mov.l\t%S1,%S0\n+   mov.l\t%S1,%S0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"2,2,8,8,4\")\n+   (set_attr \"cc\" \"set\")])\n \n-(define_expand \"movstrhi\"\n-  [(parallel [(set (mem:BLK (match_operand:BLK 0 \"general_operand\" \"\"))\n-\t\t   (mem:BLK (match_operand:BLK 1 \"general_operand\" \"\")))\n-\t      (use (match_operand:HI 2 \"general_operand\" \"\"))\n-\t      (use (match_operand:HI 3 \"immediate_operand\" \"\"))\n-\t      (clobber (match_dup 3))\n-\t      ])]\n-  \"\"\n-  \"\n-{\n-  rtx src_ptr = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n-  rtx dst_ptr = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n-\n-  enum machine_mode mode = INTVAL (operands[3]) >=2 ? HImode : QImode;\n-  rtx tmpreg = gen_reg_rtx (mode);\n-  rtx increment = mode == QImode  ? const1_rtx : const2_rtx;\n-  rtx length = operands[2];\n-  rtx label = gen_label_rtx ();\n-  rtx end_src_ptr = gen_reg_rtx (Pmode);\n-\n-  emit_insn (gen_rtx (SET, VOIDmode, end_src_ptr,\n-\t\t      gen_rtx (PLUS, Pmode, src_ptr, length)));\n-\n-  emit_label (label);\n-  emit_move_insn (tmpreg, gen_rtx (MEM, mode, src_ptr));\n-  emit_move_insn (gen_rtx (MEM, mode, dst_ptr), tmpreg);\n-  emit_insn (gen_rtx (SET, VOIDmode, src_ptr,\n-\t\t      gen_rtx (PLUS, Pmode, src_ptr, increment)));\n-  emit_insn (gen_rtx (SET, VOIDmode, dst_ptr,\n-\t\t      gen_rtx (PLUS, Pmode, dst_ptr, increment)));\n-\n-  emit_insn (gen_rtx (SET, VOIDmode, cc0_rtx,\n-\t\t      gen_rtx (COMPARE, HImode, src_ptr, end_src_ptr)));\n-  emit_jump_insn (gen_bne (label));\n-\n-  DONE;\t\n-}\n-\")\n-\f\n ;; ----------------------------------------------------------------------\n-;; Test instructions\n+;; TEST INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n (define_insn \"tstqi\"\n-  [(set (cc0)\n-\t(match_operand:QI 0 \"register_operand\" \"ra\"))]\n+  [(set (cc0) (match_operand:QI 0 \"register_operand\" \"ra\"))]\n   \"\"\n-  \"cmp.b\t#0,%X0\"\n+  \"*\n+{\n+  /* ??? I don't think this is right.  --Jim */\n+  if (cc_prev_status.flags & CC_DONE_CBIT)\n+    return \\\"btst\t#0,%X0\\\";\n+  else\n+    return \\\"cmp.b\t#0,%X0\\\";\n+}\"\n   [(set_attr \"type\" \"arith\")\n-   (set_attr \"length\" \"2\")\n+   (set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"set\")])\n \n (define_insn \"tsthi\"\n+  [(set (cc0) (match_operand:HI 0 \"general_operand\" \"ra\"))]\n+  \"\"\n+  \"*\n+{\n+  /* ??? I don't think this is right.  --Jim */\n+  if (cc_prev_status.flags & CC_DONE_CBIT)\n+    return \\\"btst\t#0,%0l\\\";\n+  else\n+    return \\\"mov.w\t%T0,%T0\\\";\n+}\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_insn \"tstsi\"\n+  [(set (cc0) (match_operand:SI 0 \"general_operand\" \"ra\"))]\n+  \"TARGET_H8300H\"\n+  \"*\n+{\n+  /* ??? I don't think this is right.  --Jim */\n+  if (cc_prev_status.flags & CC_DONE_CBIT)\n+    return \\\"btst\t#0,%0l\\\";\n+  else\n+    return \\\"mov.l\t%S0,%S0\\\";\n+}\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_insn \"cmpqi\"\n   [(set (cc0)\n-\t(match_operand:HI 0 \"register_operand\" \"ra\"))]\n+\t(compare:QI (match_operand:QI 0 \"register_operand\" \"ra\")\n+\t\t    (match_operand:QI 1 \"nonmemory_operand\" \"rai\")))]\n   \"\"\n-  \"mov.w\t%T0,%T0\"\n+  \"cmp.b\t%X1,%X0\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"set\")])\n+   (set_attr \"cc\" \"compare\")])\n+\n+;; ??? 300h can have an immediate operand here.\n \n (define_insn \"cmphi\"\n   [(set (cc0)\n@@ -362,111 +468,103 @@\n    (set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"compare\")])\n \n-(define_insn \"cmpqi\"\n+;; ??? 300h can have an immediate operand here.\n+\n+(define_insn \"cmpsi\"\n   [(set (cc0)\n-\t(compare:QI (match_operand:QI 0 \"register_operand\" \"ra\")\n-\t\t    (match_operand:QI 1 \"nonmemory_operand\" \"rai\")))]\n-  \"\"\n-  \"cmp.b\t%X1,%X0\"\n+\t(compare:SI (match_operand:SI 0 \"register_operand\" \"ra\")\n+\t\t    (match_operand:SI 1 \"register_operand\" \"ra\")))]\n+  \"TARGET_H8300H\"\n+  \"cmp.l\t%S1,%S0\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"compare\")])\n-\f\n+\n ;; ----------------------------------------------------------------------\n-;; Add instructions\n+;; ADD INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_insn \"\"\n+(define_insn \"addqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(plus:QI (match_operand:QI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:QI 2 \"nonmemory_operand\" \"ri\")))]\n+  \"\"\n+  \"add.b\t%X2,%X0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set\")])\n+\n+;; ??? adds operates on the 32bit register.  We can use it because we don't\n+;; use the e0-7 registers.\n+;; ??? 4 can be handled in one insn on the 300h.\n+\n+(define_insn \"addhi3_internal\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=ra,ra,ra,ra,r,ra\")\n \t(plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n \t\t (match_operand:HI 2 \"nonmemory_operand\" \"K,M,L,N,n,ra\")))]\n   \"\"\n   \"@\n-   adds\t%T2,%T0\n-   adds\t#2,%T0\\;adds\t%C2,%T0\n-   subs\t%M2,%T0\n-   subs\t#2,%T0\\;subs\t%M2,%T0\n+   adds\t%T2,%A0\n+   adds\t#2,%A0\\;adds\t%C2,%A0\n+   subs\t%M2,%A0\n+   subs\t#2,%A0\\;subs\t%M2,%A0\n    add.b\t%s2,%s0\\;addx\t%t2,%t0 \n    add.w\t%T2,%T0\"\n-  [(set_attr \"type\" \"multi,multi,multi,multi,multi,arith\")\n+  [(set_attr \"type\" \"arith,multi,arith,multi,multi,arith\")\n    (set_attr \"length\" \"2,4,2,4,4,2\")\n    (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit,none_0hit,clobber,set\")])\n \n+;; ??? Why is this here?\n (define_expand \"addhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n \t(plus:HI (match_operand:HI 1 \"register_operand\" \"\")\n \t\t (match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"\n-{\n-  if (operands[0] != operands[1])\n-    emit_move_insn (operands[0], operands[1]);\n-}\")\n+  \"\")\n \n-(define_insn \"addqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(plus:QI (match_operand:QI 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:QI 2 \"nonmemory_operand\" \"ri\")))]\n+(define_expand \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"add.b\t%X2,%X0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"set\")])\n+  \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"l,n\")))\n-   (clobber (match_operand:HI 3 \"register_operand\" \"=&l,l\"))]\n-  \"\"\n+(define_insn \"addsi_h8300\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,&r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,r\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"n,r,r\")))]\n+  \"TARGET_H8300\"\n   \"@\n-     add\t%w2,%w0\\;addx\t%x2,%x0\\;addx\t%y2,%y0\\;addx\t%z2,%z0\n-     add.w\t%f2,%f0\\;addx\t%y2,%y0\\;addx\t%z2,%z0\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"8,6\")\n+   add\t%w2,%w0\\;addx\t%x2,%x0\\;addx\t%y2,%y0\\;addx\t%z2,%z0\n+   add.w\t%f2,%f0\\;addx\t%y2,%y0\\;addx\t%z2,%z0\n+   mov\t%f1,%f0\\;mov\t%e1,%e0\\;add.w\t%f2,%f0\\;addx\t%y2,%y0\\;addx\t%z2,%z0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"8,6,20\")\n    (set_attr \"cc\" \"clobber\")])\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"n,r\")))]\n-  \"\"\n+;; ??? 4 can be handled in one insn on the 300h.\n+;; ??? Should the 'n' constraint be 'i' here?\n+;; ??? We don't handle (reg + symbol_ref) which the 300h can handle.\n+\n+(define_insn \"addsi_h8300h\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=ra,ra,ra,ra,r,ra\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"K,M,L,N,n,ra\")))]\n+  \"TARGET_H8300H\"\n   \"@\n-     add\t%w2,%w0\\;addx\t%x2,%x0\\;addx\t%y2,%y0\\;addx\t%z2,%z0\n-     add.w\t%f2,%f0\\;addx\t%y2,%y0\\;addx\t%z2,%z0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"length\" \"8,6\")\n-   (set_attr \"cc\" \"clobber\")])\n+   adds\t%S2,%S0\n+   adds\t#2,%S0\\;adds\t%C2,%S0\n+   subs\t%M2,%S0\n+   subs\t#2,%S0\\;subs\t%M2,%S0\n+   add.l\t%S2,%S0\n+   add.l\t%S2,%S0\"\n+  [(set_attr \"type\" \"multi,multi,multi,multi,arith,arith\")\n+   (set_attr \"length\" \"2,4,2,4,6,2\")\n+   (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit,none_0hit,clobber,clobber\")])\n \n-(define_expand \"addsi3\"\n-  [(set (match_dup 3) (match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (match_dup 3)\n-\t(plus:SI (match_dup 3)\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n-   (set (match_operand:SI 0 \"register_operand\" \"\") (match_dup 3))]\n-  \"\"\n-  \"\n-{\n-  operands[3] = gen_rtx (REG, SImode, 0);\n-}\")\n-\f\n-;; ----------------------------------------------------------------------;\n-;; Subtract instructions\n ;; ----------------------------------------------------------------------\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=ra,ra,ra,r\")\n-\t(minus:HI (match_operand:HI 1 \"general_operand\" \"0,0,0,0\")\n-\t\t  (match_operand:HI 2 \"nonmemory_operand\" \"K,M,ra,n\")))]\n-  \"\"\n-  \"@\n-   subs\t%T2,%T0\n-   subs\t#2,%T0\\;subs\t%E2,%T0\n-   sub.w\t%T2,%T0\n-   add.b\t%E2,%s0\\;addx\t%F2,%t0 ; -%0\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"2,4,2,4\")\n-   (set_attr \"cc\" \"none_0hit,none_0hit,set,clobber\")])\n+;; SUBTRACT INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n \n (define_insn \"subqi3\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n@@ -480,52 +578,115 @@\n    (set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set\")])\n \n+;; ??? subs operates on the 32bit register.  We can use it because we don't\n+;; use the e0-7 registers.\n+;; ??? 4 can be handled in one insn on the 300h.\n+;; ??? The fourth alternative can use sub.w on the 300h.\n+;; ??? Should the 'n' constraint be an 'i' here?\n+\n+(define_insn \"subhi3_internal\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=ra,ra,ra,r\")\n+\t(minus:HI (match_operand:HI 1 \"general_operand\" \"0,0,0,0\")\n+\t\t  (match_operand:HI 2 \"nonmemory_operand\" \"K,M,ra,n\")))]\n+  \"\"\n+  \"@\n+   subs\t%T2,%T0\n+   subs\t#2,%T0\\;subs\t%M2,%T0\n+   sub.w\t%T2,%T0\n+   add.b\t%E2,%s0\\;addx\t%F2,%t0 ; -%0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"2,4,2,4\")\n+   (set_attr \"cc\" \"none_0hit,none_0hit,set,clobber\")])\n+\n+;; ??? Why is this here?\n (define_expand \"subhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n \t(minus:HI (match_operand:HI 1 \"register_operand\" \"\")\n \t\t  (match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"\n-{\n-  if (operands[0] != operands[1])\n-    emit_move_insn (operands[0], operands[1]);\n-}\")\n+  \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t  (match_operand:SI 2 \"register_operand\" \"l\")))]\n+(define_expand \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n+  \"\")\n+\n+(define_insn \"subsi3_h8300\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t  (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_H8300\"\n   \"sub.w\t%f2,%f0\\;subx\t%y2,%y0\\;subx\t%z2,%z0\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"length\" \"6\")\n    (set_attr \"cc\" \"clobber\")])\n \n-(define_expand \"subsi3\"\n-  [(set (match_dup 3) (match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (match_dup 3)\n-\t(minus:SI (match_dup 3)\n-\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n-   (set (match_operand:SI 0 \"register_operand\" \"\") (match_dup 3))]\n-  \"\"\n-  \"operands[3] = gen_rtx (REG, SImode, 0);\")\n+;; ??? 4 can be handled in one insn on the 300h.\n+\n+(define_insn \"subsi3_h8300h\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=ra,ra,ra,r\")\n+\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0,0,0,0\")\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"K,M,ra,n\")))]\n+  \"TARGET_H8300H\"\n+  \"@\n+   subs\t%T2,%T0\n+   subs\t#2,%T0\\;subs\t%E2,%T0\n+   sub.l\t%S2,%S0\n+   sub.l\t%S2,%S0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"2,4,2,6\")\n+   (set_attr \"cc\" \"none_0hit,none_0hit,set,set\")])\n \n ;; ----------------------------------------------------------------------\n-;; Multiply instruction\n+;; MULTIPLY INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n+;; Note that the h8/300 can only handle umulqihi3.\n+\n+(define_insn \"mulqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(mult:HI (sign_extend:HI (match_operand:QI 1 \"general_operand\" \"%0\"))\n+\t\t (sign_extend:HI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n+  \"TARGET_H8300H\"\n+  \"mulxs.b\t%X2,%T0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_insn \"mulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"general_operand\" \"%0\"))\n+\t\t (sign_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))))]\n+  \"TARGET_H8300H\"\n+  \"mulxs.w\t%T2,%S0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set\")])\n+\n (define_insn \"umulqihi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(mult:HI (match_operand:QI 1 \"general_operand\" \"%0\")\n-\t\t (match_operand:QI 2 \"register_operand\" \"r\")))]\n+\t(mult:HI (zero_extend:HI (match_operand:QI 1 \"general_operand\" \"%0\"))\n+\t\t (zero_extend:HI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n   \"\"\n   \"mulxu\t%X2,%T0\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"none_0hit\")])\n \n+(define_insn \"umulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mult:SI (zero_extend:SI (match_operand:HI 1 \"general_operand\" \"%0\"))\n+\t\t (zero_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))))]\n+  \"TARGET_H8300H\"\n+  \"mulxu.w\t%T2,%S0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n ;; ----------------------------------------------------------------------\n-;; Divide instructions\n+;; DIVIDE INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n (define_insn \"udivqi3\"\n@@ -538,6 +699,8 @@\n    (set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"clobber\")])\n \n+;; ??? Will divxu always work here?\n+\n (define_insn \"divqi3\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n \t(div:QI (match_operand:HI 1 \"general_operand\" \"0\")\n@@ -547,85 +710,286 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"clobber\")])\n-\f\n+\n+(define_insn \"udivhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(udiv:HI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:HI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_H8300H\"\n+  \"divxu.w\t%T2,%S0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"divhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(div:HI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t(match_operand:HI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_H8300H\"\n+  \"divxs.w\t%T2,%S0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n ;; ----------------------------------------------------------------------\n-;; And instructions\n+;; MOD INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_insn \"andqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r\")\n-\t(and:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"rn\")))]\n+(define_insn \"umodqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(umod:QI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:QI 2 \"register_operand\" \"r\")))]\n   \"\"\n-  \"and\t%X2,%X0\"\n+  \"divxu\t%X2,%T0\\;mov %t0,%s0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"modqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(mod:QI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t(match_operand:QI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_H8300H\"\n+  \"divxs.b\t%X2,%T0\\;mov %t0,%s0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"6\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"umodhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(umod:HI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:HI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_H8300H\"\n+  \"divxu.w\t%T2,%S0\\;mov %e0,%f0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"modhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(mod:HI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t(match_operand:HI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_H8300H\"\n+  \"divxs.w\t%T2,%S0\\;mov %e0,%f0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"6\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; ----------------------------------------------------------------------\n+;; AND INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"andqi3_internal\"\n+  [(set (match_operand:QI 0 \"bit_operand\" \"=r,U\")\n+\t(and:QI (match_operand:QI 1 \"bit_operand\" \"%0,0\")\n+\t\t(match_operand:QI 2 \"nonmemory_operand\" \"rn,O\")))]\n+  \"register_operand (operands[0], QImode) || o_operand (operands[2], QImode)\"\n+  \"@\n+   and\t%X2,%X0\n+   bclr\t%W2,%X0\"\n   [(set_attr \"type\" \"arith\")\n-   (set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"set\")])\n+   (set_attr \"length\" \"2,4\")\n+   (set_attr \"cc\" \"set,none_0hit\")])\n+\n+(define_expand \"andqi3\"\n+  [(set (match_operand:QI 0 \"bit_operand\" \"=r,U\")\n+\t(and:QI (match_operand:QI 1 \"bit_operand\" \"%0,0\")\n+\t\t(match_operand:QI 2 \"nonmemory_operand\" \"rn,O\")))]\n+  \"\"\n+  \"\n+{\n+  if (fix_bit_operand (operands, 'O', AND))\n+    DONE;\n+}\")\n+\n+;; ??? Should have a bclr case here also.\n \n (define_insn \"andhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(and:HI (match_operand:HI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"ri\")))]\n+\t\t(match_operand:HI 2 \"nonmemory_operand\" \"ri\")))]\n   \"\"\n-  \"and\t%s2,%s0\\;and\t%t2,%t0\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      int i = INTVAL (operands[2]);\n+      if ((i & 0x00ff) != 0x00ff) \n+\toutput_asm_insn (\\\"and\t%s2,%s0\\\", operands);\n+      if ((i & 0xff00) != 0xff00) \n+\toutput_asm_insn (\\\"and\t%t2,%t0\\\", operands);\n+      return \\\"\\\";\n+    }\n+  return \\\"and\t%s2,%s0\\;and\t%t2,%t0;\\\";\n+}\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"clobber\")])\n-\f\n+\n+;; ??? There is an iorsi3 for TARGET_H8300.  Should we have andsi3?\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,i\")))]\n+  \"TARGET_H8300H\"\n+  \"@\n+   and\t%S2,%S0\n+   and\t%S2,%S0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"4,6\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n ;; ----------------------------------------------------------------------\n-;; Or instructions\n+;; OR INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_insn \"iorqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r,U\")\n-\t(ior:QI (match_operand:QI 1 \"general_operand\" \"%0,0\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"rn,P\")))]\n-  \"\"\n+(define_insn \"iorqi3_internal\"\n+  [(set (match_operand:QI 0 \"bit_operand\" \"=U,r\")\n+\t(ior:QI (match_operand:QI 1 \"bit_operand\" \"%0,0\")\n+\t\t(match_operand:QI 2 \"nonmemory_operand\" \"P,rn\")))]\n+  \"register_operand (operands[0], QImode) || p_operand (operands[2], QImode)\"\n   \"@\n-   or\t%X2,%X0\n-   bset\t%V2,%X0\"\n+   bset\t%V2,%X0\n+   or\t%X2,%X0\"\n   [(set_attr \"type\" \"arith\")\n-   (set_attr \"length\" \"2,4\")\n-   (set_attr \"cc\" \"set,none_0hit\")])\n+   (set_attr \"length\" \"4,2\")\n+   (set_attr \"cc\" \"none_0hit,set\")])\n+\n+(define_expand \"iorqi3\"\n+  [(set (match_operand:QI 0 \"bit_operand\" \"=r,U\")\n+\t(ior:QI (match_operand:QI 1 \"bit_operand\" \"%0,0\")\n+\t\t(match_operand:QI 2 \"nonmemory_operand\" \"rn,P\")))]\n+  \"\"\n+  \"\n+{\n+  if (fix_bit_operand (operands, 'P', IOR))\n+    DONE;\n+}\")\n+\n+;; ??? Should have a bset case here also.\n \n (define_insn \"iorhi3\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=r,r\")\n \t(ior:HI (match_operand:HI 1 \"general_operand\" \"%0,0\")\n \t\t(match_operand:HI 2 \"general_operand\" \"J,ri\")))]\n   \"\"\n-  \"@\n-   or\t%s2,%s0\n-   or\t%s2,%s0\\;or\t%t2,%t0\"\n+  \"*\n+{\n+  if (TARGET_H8300)\n+    {\n+      if (GET_CODE (operands[2]) == CONST_INT)\n+\t{\n+\t  int i = INTVAL (operands[2]);\n+\t  if ((i & 0x00ff) != 0) \n+\t    output_asm_insn (\\\"or\t%s2,%s0\\\", operands);\n+\t  if ((i & 0xff00) != 0) \n+\t    output_asm_insn (\\\"or\t%t2,%t0\\\", operands);\n+\t  return \\\"\\\";\n+\t}\n+      return \\\"or\t%s2,%s0\\;or\t%t2,%t0; %2 or2\\\";\n+    }\n+  else\n+    {\n+      return \\\"or\t%S2,%S0\\\";\n+    }\n+}\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"2,4\")\n    (set_attr \"cc\" \"clobber,clobber\")])\n-\f\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"ri\")))]\n+  \"\"\n+  \"*\n+{\n+  if (TARGET_H8300)\n+    {\n+      if (GET_CODE (operands[2]) == CONST_INT)\n+\t{\n+\t  int i = INTVAL (operands[2]);\n+\t  if ((i & 0x000000ff) != 0) \n+\t    output_asm_insn (\\\"or\t%w2,%w0\\\", operands);\n+\t  if ((i & 0x0000ff00) != 0) \n+\t    output_asm_insn (\\\"or\t%x2,%x0\\\", operands);\n+\t  if ((i & 0x00ff0000) != 0) \n+\t    output_asm_insn (\\\"or\t%y2,%y0\\\", operands);\n+\t  if ((i & 0xff000000) != 0) \n+\t    output_asm_insn (\\\"or\t%z2,%z0\\\", operands);\n+\t  return \\\"\\\";\n+\t}\n+      return \\\"or\t%w2,%w0\\;or\t%x2,%x0\\;or\t%y2,%y0\\;or\t%z2,%z0\\;\\\";\n+    }\n+  else\n+    {\n+      return \\\"or\t%S2,%S0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n ;; ----------------------------------------------------------------------\n-;; Xor instructions\n+;; XOR INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_insn \"xorqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r\")\n-\t(xor:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n-\t\t(match_operand:QI 2 \"nonmemory_operand\" \"ri\")))]\n-  \"\"\n-  \"xor\t%X2,%X0\"\n+(define_insn \"xorqi3_internal\"\n+  [(set (match_operand:QI 0 \"bit_operand\" \"=r,U\")\n+\t(xor:QI (match_operand:QI 1 \"bit_operand\" \"%0,0\")\n+\t\t(match_operand:QI 2 \"nonmemory_operand\" \"rn,P\")))]\n+  \"register_operand (operands[0], QImode) || p_operand (operands[2], QImode)\"\n+  \"@\n+   xor\t%X2,%X0\n+   bnot\t%V2,%X0\"\n   [(set_attr \"type\" \"arith\")\n-   (set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"set\")])\n+   (set_attr \"length\" \"2,4\")\n+   (set_attr \"cc\" \"set,none_0hit\")])\n+\n+(define_expand \"xorqi3\"\n+  [(set (match_operand:QI 0 \"bit_operand\" \"=r,U\")\n+\t(xor:QI (match_operand:QI 1 \"bit_operand\" \"%0,0\")\n+\t\t(match_operand:QI 2 \"nonmemory_operand\" \"rn,O\")))]\n+  \"\"\n+  \"\n+{\n+  if (fix_bit_operand (operands, 'O', XOR))\n+    DONE;\n+}\")\n \n (define_insn \"xorhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=r\")\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(xor:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n \t\t(match_operand:HI 2 \"nonmemory_operand\" \"ri\")))]\n   \"\"\n-  \"xor\t%s2,%s0\\;xor\t%t2,%t0\"\n+  \"*\n+{\n+  if (TARGET_H8300)\n+    return \\\"xor\t%s2,%s0\\;xor\t%t2,%t0\\\";\n+  else\n+    return \\\"xor\t%S2,%S0\\\";\n+}\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"clobber\")])\n-\f\n+\n+;; ??? There is an iorsi3 for TARGET_H8300.  Should we have xorsi3?\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,i\")))]\n+  \"TARGET_H8300H\"\n+  \"@\n+   xor\t%S2,%S0\n+   xor\t%S2,%S0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"4,6\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n ;; ----------------------------------------------------------------------\n-;; Negation instructions\n+;; NEGATION INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n (define_insn \"negqi2\"\n@@ -635,28 +999,72 @@\n   \"neg\t%X0\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"set\")])\n+   (set_attr \"cc\" \"clobber\")])\n \n (define_expand \"neghi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(neg:HI (match_operand:HI 1 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"\n+{\n+  if (TARGET_H8300)\n+    {\n+      emit_insn (gen_neghi2_h8300 (operands[0], operands[1]));\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"neghi2_h8300\"\n   [(set (match_dup 2)\n \t(not:HI (match_operand:HI 1 \"register_operand\" \"r\")))\n    (set (match_dup 2) (plus:HI (match_dup 2) (const_int 1)))\n    (set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(match_dup 2))]\n   \"\"\n-  \"operands[2] = gen_reg_rtx (HImode);\")\n+  \"{ operands[2] = gen_reg_rtx (HImode); }\")\n+\n+(define_insn \"neghi2_h8300h\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(neg:HI (match_operand:HI 1 \"general_operand\" \"0\")))]\n+  \"TARGET_H8300H\"\n+  \"neg\t%T0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"clobber\")])\n \n (define_expand \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"\n+{\n+  if (TARGET_H8300)\n+    {\n+      emit_insn (gen_negsi2_h8300 (operands[0], operands[1]));\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"negsi2_h8300\"\n   [(set (match_dup 2)\n \t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))\n    (set (match_dup 2) (plus:SI (match_dup 2) (const_int 1)))\n    (set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(match_dup 2))]\n   \"\"\n-  \"operands[2] = gen_reg_rtx (SImode);\")\n-\f\n+  \"{ operands[2] = gen_reg_rtx(SImode); }\")\n+\n+(define_insn \"negsi2_h8300h\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n+  \"TARGET_H8300H\"\n+  \"neg\t%S0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n ;; ----------------------------------------------------------------------\n-;; Not instructions\n+;; NOT INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n (define_insn \"one_cmplqi2\"\n@@ -672,7 +1080,13 @@\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(not:HI (match_operand:HI 1 \"general_operand\" \"0\")))]\n   \"\"\n-  \"not\t%s0\\;not\t%t0\"\n+  \"*\n+{\n+  if (TARGET_H8300)\n+    return \\\"not\t%s0\\;not\t%t0\\\";\n+  else\n+    return \\\"not\t%T0\\\";\n+}\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"clobber\")])\n@@ -681,15 +1095,24 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(not:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n   \"\"\n-  \"not\t%w0\\;not\t%x0\\;not\t%y0\\;not\t%z0\"\n+  \"*\n+{\n+  if (TARGET_H8300)\n+    return \\\"not\t%w0\\;not\t%x0\\;not\t%y0\\;not\t%z0\\\";\n+  else\n+    return \\\"not\t%S0\\\";\n+}\"\n   [(set_attr \"type\" \"arith\")\n+;; ??? length is wrong for 300h\n    (set_attr \"length\" \"8\")\n    (set_attr \"cc\" \"clobber\")])\n-\f\n+\n ;; ----------------------------------------------------------------------\n-;; Conditional branches\n+;; JUMP INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n+;; Conditional jump instructions\n+\n (define_expand \"ble\"\n   [(set (pc)\n \t(if_then_else (le (cc0)\n@@ -780,72 +1203,131 @@\n   \"\"\n   \"\")\n \n-(define_insn \"\"\n+(define_insn \"branch_true\"\n   [(set (pc)\n-\t(if_then_else \n-\t (match_operator 1 \"comparison_operator\" [(cc0) (const_int 0)])\n-\t (label_ref (match_operand 0 \"\" \"\"))\n-\t (pc)))]\n+\t(if_then_else (match_operator 1 \"comparison_operator\"\n+\t\t\t\t      [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n   \"\"\n   \"*\n {\n   if (get_attr_length (insn) == 2) \n-   return \\\"b%j1\t%l0\\\";\n+    return \\\"b%j1\t%l0\\\";\n+  else if (get_attr_length (insn) == 4) \n+    return \\\"b%j1\t%l0:16\\\";\n   else\n-   return \\\"b%k1\t%L0\\;jmp\t@%l0\\;%L0:\\\";\n+    return \\\"b%k1\t%L0\\;jmp\t@%l0\\;%L0:\\\";\n }\" \n-  [(set_attr \"type\" \"branch\")\n+ [(set_attr \"type\" \"branch\")\n    (set_attr \"cc\" \"none\")])\n \n-(define_insn \"\"\n+(define_insn \"branch_false\"\n   [(set (pc)\n-\t(if_then_else\n-\t (match_operator 1 \"comparison_operator\" [(cc0) (const_int 0)])\n-\t (pc)\n-\t (label_ref (match_operand 0 \"\" \"\"))))]\n+\t(if_then_else (match_operator 1 \"comparison_operator\"\n+\t\t\t\t      [(cc0) (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n+;; ??? We don't take advantage of 16 bit relative jumps in the 300h.\n   \"*\n {\n   if (get_attr_length (insn) == 2) \n-   return \\\"b%k1\t%l0\\\";\n+    return \\\"b%k1\t%l0\\\";\n+  else if (get_attr_length (insn) == 4) \n+    return \\\"b%k1\t%l0:16\\\";\n   else\n-   return \\\"b%j1\t%L0\\;jmp\t@%l0\\;%L0:\\\";\n+    return \\\"b%j1\t%L0\\;jmp\t@%l0\\;%L0:\\\";\n }\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"cc\" \"none\")])\n-\f\n-;; ----------------------------------------------------------------------\n-;; Unconditional branches\n-;; ----------------------------------------------------------------------\n+\n+;; Unconditional and other jump instructions.\n \n (define_insn \"jump\"\n   [(set (pc)\n \t(label_ref (match_operand 0 \"\" \"\")))]\n   \"\"\n   \"*\n {\n-  if (get_attr_length (insn) == 2) \n-   return \\\"bra\t%l0\\\";\n+  if (get_attr_length (insn) == 2)\n+    return \\\"bra\t%l0\\\";\n+  else if (get_attr_length (insn) == 4)\n+    return \\\"bra\t%l0:16\\\";\n   else\n-   return \\\"jmp\t@%l0\\\";\n+    return \\\"jmp\t@%l0\\\";\n }\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"cc\" \"none\")])\n \n-(define_insn \"tablejump\"\n+;; This is a define expand, because pointers may be either 16 or 32 bits.\n+\n+(define_expand \"tablejump\"\n+  [(parallel [(set (pc) (match_operand 0 \"register_operand\" \"r\"))\n+\t      (use (label_ref (match_operand 1 \"\" \"\")))])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"tablejump_h8300\"\n   [(set (pc) (match_operand:HI 0 \"register_operand\" \"\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"\"\n+  \"TARGET_H8300\"\n   \"jmp\t@%0\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"cc\" \"none\")\n    (set_attr \"length\" \"2\")])\n \n-;; Call subroutine with no return value.\n+(define_insn \"tablejump_h8300h\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"TARGET_H8300H\"\n+  \"jmp\t@%0\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"cc\" \"none\")\n+   (set_attr \"length\" \"2\")])\n \n-(define_insn \"call\"\n-  [(call (match_operand:QI 0 \"memory_operand\" \"o\")\n-\t (match_operand:HI 1 \"general_operand\" \"g\"))]\n+;; This is a define expand, because pointers may be either 16 or 32 bits.\n+\n+;(define_insn \"indirect_jump\"\n+;  [(set (pc) (match_operand:HI 0 \"register_operand\" \"r\"))]\n+;  \"\"\n+;  \"jmp\t@%0\"\n+;  [(set_attr \"type\" \"branch\")\n+;   (set_attr \"cc\" \"none\")\n+;   (set_attr \"length\" \"2\")])\n+\n+(define_expand \"indirect_jump\"\n+  [(set (pc) (match_operand 0 \"jump_address_operand\" \"Vr\"))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"indirect_jump_h8300\"\n+  [(set (pc) (match_operand:HI 0 \"jump_address_operand\" \"V,r\"))]\n+  \"TARGET_H8300\"\n+  \"@\n+   jmp\t@%0\n+   jmp\t@%0\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"cc\" \"none\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"indirect_jump_h8300h\"\n+  [(set (pc) (match_operand:SI 0 \"jump_address_operand\" \"V,r\"))]\n+  \"TARGET_H8300H\"\n+  \"@\n+   jmp @%0\n+   jmp @%0\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"cc\" \"none\")\n+   (set_attr \"length\" \"2\")])\n+\n+;; Call subroutine with no return value.\n+\n+;; ??? Even though we use HImode here, this works for the 300h.\n+\n+(define_insn \"call\"\n+  [(call (match_operand:QI 0 \"call_insn_operand\" \"or\")\n+\t (match_operand:HI 1 \"general_operand\" \"g\"))]\n   \"\"\n   \"jsr\t%0\"\n   [(set_attr \"type\" \"call\")\n@@ -855,9 +1337,11 @@\n ;; Call subroutine, returning value in operand 0\n ;; (which must be a hard register).\n \n+;; ??? Even though we use HImode here, this works on the 300h.\n+\n (define_insn \"call_value\"\n   [(set (match_operand 0 \"\" \"=r\")\n-\t(call (match_operand:QI 1 \"memory_operand\" \"o\")\n+\t(call (match_operand:QI 1 \"call_insn_operand\" \"or\")\n \t      (match_operand:HI 2 \"general_operand\" \"g\")))]\n   \"\"\n   \"jsr\t%1\"\n@@ -873,450 +1357,862 @@\n    (set_attr \"cc\" \"none\")\n    (set_attr \"length\" \"2\")])\n \n-(define_insn \"indirect_jump\"\n-  [(set (pc) (match_operand:HI 0 \"register_operand\" \"r\"))]\n-  \"\"\n-  \"jmp\t@%0\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"cc\" \"none\")\n-   (set_attr \"length\" \"2\")])\n-\f\n-;; -----------------------------------------------------------------\n-;; Shifts\n-;; -----------------------------------------------------------------\n-\n-;; All H8 shifts go one bit at a time, here they are defined with names\n-;; so can use them in the expands..\n-\n-;; QI BIT SHIFTS\n-\n-(define_insn \"ashlqi3_one\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(ashift:QI (match_operand:QI 1 \"register_operand\" \"0\")\n-\t\t   (const_int 1)))]\n-  \"\"\n-  \"shal %X0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"set\")])\n+;; ----------------------------------------------------------------------\n+;; EXTEND INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n \n-(define_insn \"ashrqi3_one\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n-\t\t     (const_int 1)))]\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:HI (match_operand:QI 1 \"general_operand\" \"0,g\")))]\n   \"\"\n-  \"shar %X0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"set\")])\n+  \"*\n+{\n+  if (which_alternative==0)\n+    return \\\"mov.b\t#0,%t0\\\";\n \n-(define_insn \"lshrqi3_one\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n-\t\t     (const_int 1)))]\n-  \"\"\n-  \"shlr %X0\"\n-  [(set_attr \"type\" \"arith\")\n-   (set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"set\")])\n+  if (TARGET_H8300)\n+    return \\\"mov.b\t%X1,%s0\\;mov.b\t#0,%t0\\\";\n+  else\n+    {\n+      /* ??? See how often this gets optimized.  */\n+      if (REG_P (operands[1]) && (REGNO (operands[1]) == REGNO (operands[0])))\n+\treturn \\\"extu.w\t%T0\\\";\n+      else\n+\treturn \\\"mov.b\t%X1,%s0\\;extu.w\t%T0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"multi\")\n+;; ??? This length is wrong for one case.\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n \n-(define_expand \"ashlqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(ashift:QI (match_operand:QI 1 \"register_operand\" \"0\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"rn\")))]\n-  \"\"\n-  \"\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (match_operand:HI 1 \"general_operand\" \"g\")))]\n+  \"TARGET_H8300H\"\n+  \"*\n {\n-  if (can_shift (ASHIFT, operands, gen_ashlqi3_one, 4, 0))\n-    DONE;\n+  /* ??? See how often this gets optimized.  */\n+  if (REG_P (operands[1]) && (REGNO (operands[1]) == REGNO (operands[0])))\n+    return \\\"extu.l\t%S0\\\";\n   else\n-    FAIL;\n-}\")\n+    return \\\"mov.w\t%T1,%T0\\;extu.l\t%S0\\\";\n+}\"\n+  [(set_attr \"type\" \"multi\")\n+;; ??? This length is wrong for one case.\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n \n-(define_expand \"ashrqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"rn\")))]\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:HI (match_operand:QI 1 \"general_operand\" \"g\")))]\n   \"\"\n-  \"\n+  \"*\n {\n-  if (can_shift (ASHIFTRT, operands, gen_ashrqi3_one, 4, 0))\n-    DONE;\n+  if (TARGET_H8300)\n+    {\n+      /* ??? See how often this gets optimized.  */\n+      if (REG_P (operands[1]) && (REGNO (operands[1]) == REGNO (operands[0])))\n+\treturn \\\"bld\t#7,%s0\\;subx\t%t0,%t0\\\";\n+      else\n+\treturn \\\"mov.b\t%X1,%s0\\;bld\t#7,%s0\\;subx\t%t0,%t0\\\";\n+    }\n   else\n-    FAIL;\n-}\")\n+    {\n+      /* ??? See how often this gets optimized.  */\n+      if (REG_P (operands[1]) && (REGNO (operands[1]) == REGNO (operands[0])))\n+\treturn \\\"exts.w\t%T0\\\";\n+      else\n+\treturn \\\"mov.b\t%X1,%s0\\;exts.w\t%T0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"multi\")\n+;; ??? Length is wrong in some cases.\n+   (set_attr \"length\" \"6\")\n+   (set_attr \"cc\" \"clobber\")])\n \n-(define_expand \"lshrqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"rn\")))]\n+(define_expand \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:HI 1 \"general_operand\" \"\")))]\n   \"\"\n   \"\n {\n-  if (can_shift (LSHIFTRT, operands, gen_lshrqi3_one, 4, 0))\n-    DONE;\n+  if (TARGET_H8300)\n+    emit_insn (gen_extendhisi2_h8300 (operands[0], operands[1]));\n   else\n-    FAIL;\n+    emit_insn (gen_extendhisi2_h8300h (operands[0], operands[1]));\n+  DONE;\n }\")\n \n-;;  HI BIT SHIFTS\n+(define_expand \"extendhisi2_h8300\"\n+  [(set (reg:HI 1) (match_operand:HI 1 \"general_operand\" \"\"))\n+   (set (reg:SI 0) (sign_extend:SI (reg:HI 1)))\n+   (set (match_operand:SI 0 \"general_operand\" \"\" ) (reg:SI 0))]\n+  \"TARGET_H8300\"\n+  \"\")\n \n-(define_insn \"ashlhi3_one\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(ashift:HI (match_operand:HI 1 \"register_operand\" \"0\")\n-\t\t   (const_int 1)))]\n-  \"\"\n-  \"add.w\t%T1,%T0\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"set\")])\n+(define_expand \"extendhisi2_h8300h\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:HI 1 \"general_operand\" \"\")))]\n+  \"TARGET_H8300H\"\n+  \"\")\n \n-(define_insn \"ashlhi3_eight\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(ashift:HI (match_operand:HI 1 \"register_operand\" \"0\")\n-\t\t   (const_int 8)))]\n-  \"\"\n-  \"mov.b\t%s1,%t0\\;mov.b\t#0,%s0\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"4\")\n+(define_insn \"extendhisi2_h8300_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"0\")))]\n+  \"TARGET_H8300\"\n+  \"mov.w\t%T1,%f0\\;bld\t#7,%x0\\;subx\t%y0,%y0\\;subx\t%z0,%z0\"\n+  [(set_attr \"length\" \"10\")\n    (set_attr \"cc\" \"clobber\")])\n \n-(define_expand \"ashlhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(ashift:HI\n-\t (match_operand:HI 1 \"general_operand_src\" \"\")\n-\t (match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"\n+(define_insn \"extendhisi2_h8300h_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"general_operand\" \"g\")))]\n+  \"TARGET_H8300H\"\n+  \"*\n {\n-  if (can_shift (ASHIFT, operands, gen_ashlhi3_one, 4, gen_ashlhi3_eight)) \n-    DONE;\n+  /* ??? See how often this gets optimized.  */\n+  if (REG_P (operands[1]) && (REGNO (operands[1]) == REGNO (operands[0])))\n+    return \\\"exts.l\t%S0\\\";\n   else\n-    FAIL;\n-}\")\n+    return \\\"mov.w\t%T1,%T0\\;exts.l\t%S0\\\";\n+}\"\n+  [(set_attr \"length\" \"10\")\n+   (set_attr \"cc\" \"clobber\")])\n \n-(define_insn \"lshrhi3_one\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n-\t\t     (const_int 1)))]\n+;; ----------------------------------------------------------------------\n+;; SHIFTS\n+;; ----------------------------------------------------------------------\n+;;\n+;; We make some attempt to provide real efficient shifting.  One example is\n+;; doing an 8 bit shift of a 16 bit value by moving a byte reg into the other\n+;; reg and moving 0 into the former reg.\n+;;\n+;; We also try to achieve this in a uniform way.  IE: We don't try to achieve\n+;; this in both rtl and at insn emit time.  Ideally, we'd use rtl as that would\n+;; give the optimizer more cracks at the code.  However, we wish to do things\n+;; like optimizing shifting the sign bit to bit 0 by rotating the other way.\n+;; There is rtl to handle this (rotate + and), but the h8/300 doesn't handle\n+;; 16 bit rotates.  Also, if we emit complicated rtl, combine may not be able\n+;; to detect cases it can optimize.\n+;;\n+;; For these and other fuzzy reasons, I've decided to go the less pretty but\n+;; easier \"do it at insn emit time\" route.\n+\n+;; QI BIT SHIFTS\n+\n+(define_expand \"ashlqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(ashift:QI (match_operand:QI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"shlr\t%t0\\;rotxr\t%s0\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"clobber\")])\n+  \"if (expand_a_shift (QImode, ASHIFT, operands)) DONE;else FAIL;\")\n \n-(define_insn \"lshrhi3_eight\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n-\t\t     (const_int 8)))]\n+(define_expand \"ashrqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(ashiftrt:QI (match_operand:QI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"mov.b\t%t1,%s0\\;mov.b\t#0,%t0\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"clobber\")])\n+  \"if (expand_a_shift (QImode, ASHIFTRT, operands)) DONE;else FAIL;\")\n \n-(define_expand \"lshrhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(lshiftrt:HI\n-\t (match_operand:HI 1 \"general_operand_src\" \"\")\n-\t (match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n+(define_expand \"lshrqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"\n-{\n-  if (can_shift (LSHIFTRT, operands, gen_lshrhi3_one, 4, gen_lshrhi3_eight))\n-    DONE;\n-  else\n-    FAIL;\n-}\")\n+  \"if (expand_a_shift (QImode, LSHIFTRT, operands)) DONE;else FAIL;\")\n \n-(define_insn \"ashrhi3_one\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n-\t\t     (const_int 1)))]\n+;; WARNING: The constraints on the scratch register say one is not needed\n+;; for constant shifts of 1,2,3,4.  Emit_a_shift() must know this.\n+\n+(define_insn \"shiftbyn_QI\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n+\t(match_operator:QI 3 \"nshift_operator\" \n+\t\t\t[ (match_operand:QI 1 \"register_operand\" \"0,0\")\n+\t\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"IKM,rn\")]))\n+   (clobber (match_scratch:QI 4 \"=X,&r\"))]\n   \"\"\n-  \"shar\t%t0\\;rotxr\t%s0\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"4\")\n+  \"* return emit_a_shift (insn, operands);\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"20\")\n+;; ??? We'd like to indicate that cc is set here, and it is for simple shifts.\n+;; However, for cases that loop or are done in pieces, cc does not contain\n+;; what we want.  Emit_a_shift is free to tweak cc_status as desired.\n    (set_attr \"cc\" \"clobber\")])\n \n-; signed shift right by 8 bits\n-; fetch the carry bit from the top, copy the byte right, subtract the \n-; top byte from itself - carry.\n+;; HI BIT SHIFTS\n \n-(define_insn \"ashrhi3_eight\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n-\t\t     (const_int 8)))]\n+(define_expand \"ashlhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(ashift:HI (match_operand:HI 1 \"nonmemory_operand\" \"\")\n+\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"bld\t#7,%t0\\;mov.b\t%t0,%s0\\;subx\t%t0,%t0\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"6\")\n-   (set_attr \"cc\" \"clobber\")])\n+  \"if (expand_a_shift (HImode, ASHIFT, operands)) DONE;else FAIL;\")\n+\n+(define_expand \"lshrhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"general_operand_src\" \"\")\n+\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"if (expand_a_shift (HImode, LSHIFTRT, operands)) DONE;else FAIL;\")\n \n (define_expand \"ashrhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(ashiftrt:HI\n-\t (match_operand:HI 1 \"general_operand_src\" \"\")\n-\t (match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n+\t(ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"\n-{\n-  if (can_shift (ASHIFTRT, operands, gen_ashrhi3_one, 4, gen_ashrhi3_eight)) \n-    DONE;\n-  else\n-    FAIL;\n-}\")\n+  \"if (expand_a_shift (HImode, ASHIFTRT, operands)) DONE;else FAIL;\")\n \n-;; SI BIT SHIFTS\n+;; WARNING: The constraints on the scratch register say one is not needed\n+;; for constant shifts of 1,2,3,4.  Emit_a_shift() must know this.\n \n-(define_insn \"ashlsi3_one\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t   (const_int 1)))]\n+(define_insn \"shiftbyn_HI\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(match_operator:HI 3 \"nshift_operator\" \n+\t\t\t[ (match_operand:HI 1 \"register_operand\" \"0,0\")\n+\t\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"IKM,rn\")]))\n+   (clobber (match_scratch:QI 4 \"=X,&r\"))]\n   \"\"\n-  \"add.w\t%f1,%f0\\;addx\t%y1,%y0\\;addx\t%z1,%z0\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"6\")\n+  \"* return emit_a_shift (insn, operands);\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"20\")\n+;; ??? We'd like to indicate that cc is set here, and it is for simple shifts.\n+;; However, for cases that loop or are done in pieces, cc does not contain\n+;; what we want.  Emit_a_shift is free to tweak cc_status as desired.\n    (set_attr \"cc\" \"clobber\")])\n \n+;;  SI BIT SHIFTS\n+\n (define_expand \"ashlsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ashift:SI\n \t (match_operand:SI 1 \"general_operand_src\" \"\")\n-\t (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+\t (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"\n-{\n-  if (can_shift (ASHIFT, operands, gen_ashlsi3_one, 1, 0))\n-    DONE;\n-  else\n-    FAIL;\n-}\")\n-\n-(define_insn \"lshrsi3_one\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t     (const_int 1)))]\n-  \"\"\n-  \"shlr\t%z0\\;rotxr\t%y0\\;rotxr\t%x0\\;rotxr\t%w0\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"8\")\n-   (set_attr \"cc\" \"clobber\")])\n+  \"if (expand_a_shift (SImode, ASHIFT, operands)) DONE;else FAIL;\")\n \n (define_expand \"lshrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(lshiftrt:SI\n \t (match_operand:SI 1 \"general_operand_src\" \"\")\n-\t (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (can_shift (LSHIFTRT, operands, gen_lshrsi3_one, 1, 0))\n-    DONE;\n-  else\n-    FAIL;\n-}\")\n-\n-(define_insn \"ashrsi3_one\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t     (const_int 1)))]\n+\t (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"shar\t%z0\\;rotxr\t%y0\\;rotxr\t%x0\\;rotxr\t%w0\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"16\")\n-   (set_attr \"cc\" \"clobber\")])\n+  \"if (expand_a_shift (SImode, LSHIFTRT, operands)) DONE;else FAIL;\")\n \n (define_expand \"ashrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ashiftrt:SI\n \t (match_operand:SI 1 \"general_operand_src\" \"\")\n-\t (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+\t (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n-  \"\n-{\n-  if (can_shift (ASHIFTRT, operands, gen_ashrsi3_one, 1, 0))\n-    DONE;\n-  else\n-    FAIL;\n-}\")\n+  \"if (expand_a_shift (SImode, ASHIFTRT, operands)) DONE;else FAIL;\")\n \n-;; ----------------------------------------------------------------------\n-;; BIT FIELDS\n-;; ----------------------------------------------------------------------\n+;; WARNING: The constraints on the scratch register say one is not needed\n+;; for constant shifts of 1,2.  Emit_a_shift() must know this.\n \n-(define_insn \"\"\n-  [(set (zero_extract:HI (match_operand:HI 0 \"register_operand\" \"+r\")\n-\t\t\t (const_int 1)\n-\t\t\t (match_operand:HI 2 \"general_operand\" \"g\"))\n-\t(match_operand:HI 3 \"general_operand\" \"r\"))]\n+(define_insn \"shiftbyn_SI\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(match_operator:SI 3 \"nshift_operator\" \n+\t\t\t[ (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"IK,rn\")]))\n+   (clobber (match_scratch:QI 4 \"=X,&r\"))]\n   \"\"\n-  \"bld\t#0,%3l\\;bst\t%Z2,%0%Y1\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"4\")\n+  \"* return emit_a_shift (insn, operands);\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"20\")\n+;; ??? We'd like to indicate that cc is set here, and it is for simple shifts.\n+;; However, for cases that loop or are done in pieces, cc does not contain\n+;; what we want.  Emit_a_shift is free to tweak cc_status as desired.\n    (set_attr \"cc\" \"clobber\")])\n \n-(define_expand \"insv\"\n-  [(set (zero_extract:HI (match_operand:HI 0 \"register_operand\" \"+r\")\n-\t\t\t (match_operand:HI 1 \"general_operand\" \"g\")\n-\t\t\t (match_operand:HI 2 \"general_operand\" \"g\"))\n-\t(match_operand:HI 3 \"general_operand\" \"r\"))]\n-  \"\"\n-  \"if (INTVAL (operands[1]) != 1) FAIL;\")\n+;; -----------------------------------------------------------------\n+;; BIT FIELDS\n+;; -----------------------------------------------------------------\n+;; The H8/300 has given 1/8th of its opcode space to bitfield\n+;; instuctions so let's use them as well as we can\n \n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=&r\")\n-\t(zero_extract:HI (match_operand:HI 1 \"register_operand\" \"r\")\n-\t\t\t (const_int 1)\n-\t\t\t (match_operand:HI 3 \"general_operand\" \"g\")))]\n+;; BCC and BCS patterns.\n+\n+(define_insn \"bcs_qiqi\"\n+  [(set (pc)\n+\t(if_then_else \n+\t (match_operator 1 \"eq_operator\"\n+\t\t\t [(zero_extract:QI (match_operand:QI 2 \"bit_operand\" \"Ur\")\n+\t\t\t\t\t   (const_int 1)\n+\t\t\t\t\t   (match_operand:HI 3 \"immediate_operand\" \"i\"))\n+\t\t\t  (const_int 0)])\n+\t (label_ref (match_operand 0 \"\" \"\"))\n+\t (pc)))]\n   \"\"\n-  \"sub.w\t%T0,%T0\\;bld\t%Z3,%T1%Y1\\;rotxl\t%T0l\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"6\")\n+  \"*\n+{\n+  output_asm_insn(\\\"bld\t%Z3,%Y2\\\", operands);\n+  if (get_attr_length (insn) == 2) \n+    return \\\"b%d1\t%l0\\\";\n+  else if (get_attr_length (insn) == 4) \n+    return \\\"b%d1\t%l0:16\\\";\n+  else\n+    return \\\"b%g1\t%L0\\;jmp\t@%l0\\;%L0:\\\";\n+}\" \n+  [(set_attr \"type\" \"branch\")\n    (set_attr \"cc\" \"clobber\")])\n \n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(sign_extract:HI (match_operand:HI 1 \"register_operand\" \"r\")\n-\t\t\t (const_int 1)\n-\t\t\t (match_operand:HI 3 \"general_operand\" \"g\")))]\n+(define_insn \"bcs_hihi\"\n+  [(set (pc)\n+\t(if_then_else \n+\t (match_operator 1 \"eq_operator\"\n+\t\t\t [(zero_extract:HI (match_operand:HI 2 \"bit_operand\" \"Ur\")\n+\t\t\t\t\t   (const_int 1)\n+\t\t\t\t\t   (match_operand:HI 3 \"immediate_operand\" \"i\"))\n+\t\t\t  (const_int 0)])\n+\t (label_ref (match_operand 0 \"\" \"\"))\n+\t (pc)))]\n   \"\"\n-  \"bld\t%Z3,%1%Y1\\;sub.x\t%0l,%0l\\;mov.b\t%0l,%0h\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"6\")\n+  \"*\n+{\n+  output_asm_insn(\\\"bld\t%Z3,%Y2\\\", operands);\n+  if (get_attr_length (insn) == 2) \n+    return \\\"%d1\t%l0\\\";\n+  else if (get_attr_length (insn) == 4) \n+    return \\\"%d1\t%l0:16\\\";\n+  else\n+    return \\\"%g1\t%L0\\;jmp\t@%l0\\;%L0:\\\";\n+}\" \n+  [(set_attr \"type\" \"branch\")\n    (set_attr \"cc\" \"clobber\")])\n \n-(define_expand \"extzv\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(zero_extract:HI (match_operand:HI 1 \"register_operand\" \"\")\n-\t\t\t (match_operand:HI 2 \"general_operand\" \"\")\n-\t\t\t (match_operand:HI 3 \"general_operand\" \"\")))]\n+(define_insn \"bcs_hiqi\"\n+  [(set (pc)\n+\t(if_then_else \n+\t (match_operator 1 \"eq_operator\"\n+\t\t\t [(zero_extract:HI (match_operand:QI 2 \"bit_operand\" \"Ur\")\n+\t\t\t\t\t   (const_int 1)\n+\t\t\t\t\t   (match_operand:HI 3 \"immediate_operand\" \"i\"))\n+\t\t\t  (const_int 0)])\n+\t (label_ref (match_operand 0 \"\" \"\"))\n+\t (pc)))]\n   \"\"\n-  \"if (INTVAL (operands[2]) != 1) FAIL;\")\n+  \"*\n+{\n+  output_asm_insn(\\\"bld\t%Z3,%Y2\\\", operands);\n+  if (get_attr_length (insn) == 2) \n+    return \\\"%d1\t%l0\\\";\n+  else if (get_attr_length (insn) == 4) \n+    return \\\"%d1\t%l0:16\\\";\n+  else\n+    return \\\"%g1\t%L0\\;jmp\t@%l0\\;%L0:\\\";\n+}\" \n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"cc\" \"clobber\")])\n \n-(define_expand \"extv\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(sign_extract:HI (match_operand:HI 1 \"register_operand\" \"\")\n-\t\t\t (match_operand:HI 2 \"general_operand\" \"\")\n-\t\t\t (match_operand:HI 3 \"immediate_operand\" \"\")))]\n+;; BLD and BST patterns\n+\n+(define_insn \"extract_1\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=&r\")\n+\t(zero_extract:HI (match_operand:QI 1 \"bit_operand\" \"Ur\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:HI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n-  \"if (INTVAL (operands[2]) != 1)  FAIL;\")\n-\f\n-;; ----------------------------------------------------------------------\n-;; Conversions\n-;; ----------------------------------------------------------------------\n+  \"sub.w\t%0,%0\\;bld\t%Z2,%Y1\\;bst\t#0,%X0\")\n \n-(define_insn \"zero_extendqihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:HI\n-\t (match_operand:QI 1 \"general_operand\" \"g\")))]\n+(define_insn \"extract_1_hi\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=&r\")\n+\t(zero_extract:HI (match_operand:HI 1 \"bit_operand\" \"Ur\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:HI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n-  \"mov.b\t%X1,%s0\\;mov.b\t#0,%t0\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"clobber\")])\n+  \"sub.w\t%0,%0\\;bld\t%Z2,%Y1\\;bst\t#0,%X0\")\n \n-(define_insn \"extendqihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:HI\n-\t (match_operand:QI 1 \"register_operand\" \"r\")))]\n+(define_insn \"insert_1\"\n+  [(set (zero_extract:HI (match_operand:QI 0 \"bit_operand\" \"+Ur\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:HI 1 \"immediate_operand\" \"i\"))\n+\t(zero_extract:HI (match_operand:QI 2 \"bit_operand\" \"Ur\")\n+\t\t\t (const_int 1)\n+\t\t\t (const_int 0)))]\n   \"\"\n-  \"*\n+  \"bld\t#0,%X2\\;bst\t%Z1,%Y0 ; i1\")\n+\n+;; This is how combine canonicalizes this pattern.  This is perhaps a bug\n+;; in combine.c, but there is no problem with writing it this way so we do.\n+(define_insn \"extract_insert_1\"\n+  [(set (zero_extract:QI (match_operand:QI 0 \"bit_operand\" \"+Ur\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:HI 1 \"immediate_operand\" \"i\"))\n+\t(lshiftrt:QI (match_operand:QI 2 \"bit_operand\" \"Ur\")\n+\t\t     (match_operand:HI 3 \"immediate_operand\" \"i\")))]\n+ \"\"\n+ \"bld\t%Z3,%Y2\\;bst\t%Z1,%Y0; ei1\")\n+\n+;; BAND, BOR, and BXOR patterns\n+\n+(define_insn \"bitlogical_1\"\n+  [(set (match_operand:HI 0 \"bit_operand\" \"=Ur\")\n+\t(match_operator:HI 4 \"bit_operator\"\n+\t   [(zero_extract:HI (match_operand:QI 1 \"bit_operand\" \"Ur\")\n+\t\t\t     (const_int 1)\n+\t\t\t     (match_operand:HI 2 \"immediate_operand\" \"i\"))\n+\t    (match_operand:HI 3 \"bit_operand\" \"0\")]))]\n+  \"\"\n+  \"bld\t%Z2,%Y1\\;%b4\t#0,%X0\\;bst\t#0,%X0; bl1\")\n+\n+(define_insn \"bitlogical_1_hi\"\n+  [(set (match_operand:HI 0 \"bit_operand\" \"=Ur\")\n+\t(match_operator:HI 4 \"bit_operator\"\n+\t   [(zero_extract:HI (match_operand:HI 1 \"bit_operand\" \"Ur\")\n+\t\t\t     (const_int 1)\n+\t\t\t     (match_operand:HI 2 \"immediate_operand\" \"i\"))\n+\t    (match_operand:HI 3 \"bit_operand\" \"0\")]))]\n+  \"\"\n+  \"bld\t%Z2,%Y1\\;%b4\t#0,%X0\\;bst\t#0,%X0; bl2\")\n+\n+(define_insn \"bitlogical_2\"\n+  [(set (match_operand:HI 0 \"bit_operand\" \"=Ur\")\n+\t(match_operator:HI 5 \"bit_operator\"\n+\t   [(zero_extract:HI (match_operand:QI 1 \"bit_operand\" \"Ur\")\n+\t\t\t     (const_int 1)\n+\t\t\t     (match_operand:HI 2 \"immediate_operand\" \"i\"))\n+\t    (zero_extract:HI (match_operand:QI 3 \"bit_operand\" \"Ur\")\n+\t\t\t     (const_int 1)\n+\t\t\t     (match_operand:HI 4 \"immediate_operand\" \"i\"))]))]\n+  \"\"\n+  \"bld\t%Z2,%Y1\\;%b5\t%Z4,%Y3\\;bst\t#0,%X0; bl3\")\n+\n+(define_insn \"bitlogical_2_hi\"\n+  [(set (match_operand:HI 0 \"bit_operand\" \"=Ur\")\n+\t(match_operator:HI 5 \"bit_operator\"\n+\t   [(zero_extract:HI (match_operand:HI 1 \"bit_operand\" \"Ur\")\n+\t\t\t     (const_int 1)\n+\t\t\t     (match_operand:HI 2 \"immediate_operand\" \"i\"))\n+\t    (zero_extract:HI (match_operand:HI 3 \"bit_operand\" \"Ur\")\n+\t\t\t     (const_int 1)\n+\t\t\t     (match_operand:HI 4 \"immediate_operand\" \"i\"))]))]\n+  \"\"\n+  \"bld\t%Z2,%Y1\\;%b5\t%Z4,%Y3\\;bst\t#0,%X0; bl3\")\n+\n+;; This is how combine canonicalizes this pattern.  This is perhaps a bug\n+;; in combine.c, but there is no problem with writing it this way so we do.\n+(define_insn \"bitlogical_3\"\n+  [(set (zero_extract:QI (match_operand:QI 0 \"bit_operand\" \"+Ur\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:HI 1 \"immediate_operand\" \"i\"))\n+\t(match_operator:QI 6 \"bit_operator\"\n+\t   [(lshiftrt:QI (match_operand:QI 2 \"bit_operand\" \"Ur\")\n+\t\t\t (match_operand:HI 3 \"immediate_operand\" \"i\"))\n+\t    (lshiftrt:QI (match_operand:QI 4 \"bit_operand\" \"Ur\")\n+\t\t\t (match_operand:HI 5 \"immediate_operand\" \"i\"))]))]\n+  \"\"\n+  \"bld\t%Z3,%Y2\\;%b6\t%Z5,%Y4\\;bst\t%Z1,%Y0; bl5\")\n+\t\t\t\t\t\t     \n+;; This is how combine canonicalizes this pattern.  This is perhaps a bug\n+;; in combine.c, but there is no problem with writing it this way so we do.\n+(define_insn \"bitnot_1\"\n+  [(set (zero_extract:QI (match_operand:QI 0 \"bit_operand\" \"=Ur\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:HI 1 \"immediate_operand\" \"i\"))\n+\t(lshiftrt:QI (xor:QI (match_operand:QI 2 \"bit_operand\" \"0\")\n+\t\t\t     (match_operand:HI 3 \"immediate_operand\" \"i\"))\n+\t\t     (match_operand:HI 4 \"immediate_operand\" \"1\")))]\n+  \"GET_CODE (operands[3]) == CONST_INT && GET_CODE (operands[1]) == CONST_INT\n+   && exact_log2 (INTVAL (operands[3])) == INTVAL (operands[1])\"\n+  \"bnot\t%Z1,%Y0\")\n+\n+;; ??? Implement BIAND, BIOR, BIXOR\n+\n+;; ??? Implement BILD, BIST\n+\n+;; ??? Apparently general_operand for the 1st and 2nd operands is useful,\n+;; but I don't know why.  --Jim\n+\n+(define_expand \"insv\"\n+  [(set (zero_extract:HI (match_operand:QI 0 \"bit_operand\" \"Ur\")\n+\t\t\t (match_operand:HI 1 \"general_operand\" \"g\")\n+\t\t\t (match_operand:HI 2 \"general_operand\" \"g\"))\n+\t(zero_extract:HI (match_operand:QI 3 \"bit_operand\" \"Ur\")\n+\t\t\t (const_int 1)\n+\t\t\t (const_int 0)))]\n+;; ??? This should have word mode which is SImode for the h8/300h.\n+  \"TARGET_H8300\"\n+  \"\n {\n-  if (REGNO (operands[1]) != REGNO (operands[0]))\n-   return \\\"mov.b\t%X1,%s0\\;bld\t#7,%s0\\;subx\t%t0,%t0\\\";\n-  else\n-   return \\\"bld\t#7,%s0\\;subx\t%t0,%t0\\\";\n-}\"\n-  [(set_attr \"type\" \"multi\")\n+  if (INTVAL (operands[1]) != 1)\n+    FAIL;\n+\n+  /* ??? HACK ???\n+     This INSV pattern is wrong.  It should use HImode for operand 3.\n+     Also, the zero_extract around operand 3 is superfluous and should be\n+     deleted.  Fixing this is more work than we care to do for the moment,\n+     because it means most of the above patterns would need to be rewritten,\n+     and we also need more combine.c patches to make this work.\n+\n+     So, for now, we work around this bug by simply not accepting any bitfield\n+     inserts that have a position greater than fits in QImode.  */\n+\n+  if (GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) >= 8)\n+    FAIL;\n+\n+  /* The bit_operand predicate accepts any memory durint RTL generation, but\n+     only 'U' memory afterwards, so if this is a MEM operand, we must force\n+     it to be valid for 'U' by reloading the address.  */\n+\n+  if (GET_CODE (operands[0]) == MEM && ! EXTRA_CONSTRAINT (operands[0], 'U'))\n+    {\n+      rtx mem;\n+      mem = gen_rtx (MEM, GET_MODE (operands[0]),\n+\t\t     copy_to_mode_reg (Pmode, XEXP (operands[0], 0)));\n+      RTX_UNCHANGING_P (mem) = RTX_UNCHANGING_P (operands[0]);\n+      MEM_IN_STRUCT_P (mem) = MEM_IN_STRUCT_P (operands[0]);\n+      MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (operands[0]);\n+      operands[0] = mem;\n+    }\n+\n+  /* Likewise for operands[3].  */\n+\n+  if (GET_CODE (operands[3]) == MEM && ! EXTRA_CONSTRAINT (operands[3], 'U'))\n+    {\n+      rtx mem;\n+      mem = gen_rtx (MEM, GET_MODE (operands[3]),\n+\t\t     copy_to_mode_reg (Pmode, XEXP (operands[3], 0)));\n+      RTX_UNCHANGING_P (mem) = RTX_UNCHANGING_P (operands[3]);\n+      MEM_IN_STRUCT_P (mem) = MEM_IN_STRUCT_P (operands[3]);\n+      MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (operands[3]);\n+      operands[3] = mem;\n+    }\n+}\")\n+\n+;; ??? Apparently general_operand for the 2nd and 3rd operands is useful,\n+;; but I don't know why.  --Jim\n+\n+(define_expand \"extzv\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\") \n+\t(zero_extract:HI (match_operand:QI 1 \"bit_operand\" \"\")\n+\t\t\t (match_operand:HI 2 \"general_operand\" \"g\")\n+\t\t\t (match_operand:HI 3 \"general_operand\" \"g\")))]\n+;; ??? This should have word mode which is SImode for the h8/300h.\n+  \"TARGET_H8300\"\n+  \"\n+{\n+  if (INTVAL (operands[2]) != 1)\n+    FAIL;\n+\n+  /* The bit_operand predicate accepts any memory durint RTL generation, but\n+     only 'U' memory afterwards, so if this is a MEM operand, we must force\n+     it to be valid for 'U' by reloading the address.  */\n+\n+  if (GET_CODE (operands[1]) == MEM && ! EXTRA_CONSTRAINT (operands[1], 'U'))\n+    {\n+      rtx mem;\n+      mem = gen_rtx (MEM, GET_MODE (operands[1]),\n+\t\t     copy_to_mode_reg (Pmode, XEXP (operands[1], 0)));\n+      RTX_UNCHANGING_P (mem) = RTX_UNCHANGING_P (operands[1]);\n+      MEM_IN_STRUCT_P (mem) = MEM_IN_STRUCT_P (operands[1]);\n+      MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (operands[1]);\n+      operands[1] = mem;\n+    }\n+}\")\n+\n+;; -----------------------------------------------------------------\n+;; STACK POINTER MANIPULATIONS\n+;; -----------------------------------------------------------------\n+\n+;; This pattern is needed because there is no way on the H8/300\n+;; to add a 16 bit immediate value to the stack pointer in one \n+;; instruction, which could leave an invalid instruction if interrupted\n+;; half way through.  Here we add to the stack pointer from a\n+;; register.\n+\n+(define_insn \"stack_pointer_manip\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=&ra\")\n+\t(plus:HI (match_operand:HI 1 \"general_operand_src\" \"g\")\n+\t\t (match_operand:HI 2 \"register_operand\" \"ra\")))]\n+  \"TARGET_H8300\"\n+  \"mov.w\t%T1,%T0\\;add.w\t%T2,%T0\"\n+  [(set_attr \"type\" \"arith\")\n    (set_attr \"length\" \"6\")\n-   (set_attr \"cc\" \"clobber\")])\n+   (set_attr \"cc\" \"set\")])\n \n-(define_insn \"extendhisi2_one\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"0\")))]\n-  \"\"\n-  \"mov.w\t%T1,%f0\\;bld\t#7,%x0\\;subx\t%y0,%y0\\;subx\t%z0,%z0\"\n-  [(set_attr \"length\" \"10\")\n-   (set_attr \"cc\" \"clobber\")])\n \n-(define_expand \"extendhisi2\"\n-  [(set (reg:HI 1) (match_operand:HI 1 \"general_operand\" \"\"))\n-   (set (reg:SI 0) (sign_extend:SI (reg:HI 1)))\n-   (set (match_operand:SI 0 \"general_operand\" \"\" ) (reg:SI 0))]\n+;; -------------------------------------------\n+;; BLK moves\n+;; -------------------------------------------\n+\n+(define_expand \"movstrhi\"\n+  [(parallel [(set (mem:BLK (match_operand:BLK 0 \"general_operand\" \"\"))\n+\t\t   (mem:BLK (match_operand:BLK 1 \"general_operand\" \"\")))\n+\t     (use (match_operand:HI 2 \"general_operand\" \"\"))\n+\t     (use (match_operand:HI 3 \"immediate_operand\" \"\"))\n+\t     (clobber (match_dup 3))\n+  ])]\n   \"\"\n-  \"\")\n-\f\n-;; ----------------------------------------------------------------------\n-;; peepholes\n-;; ----------------------------------------------------------------------\n+  \"\n+{\n+\trtx src_ptr = copy_to_mode_reg (Pmode, XEXP(operands[1], 0));\n+\trtx dst_ptr = copy_to_mode_reg (Pmode, XEXP(operands[0], 0));\n+\t\n+        int max = GET_CODE (operands[2]) == CONST_INT\n+\t  ? MIN (INTVAL (operands[2]), INTVAL (operands[3])) : 1;\n+\tenum machine_mode mode = max >= 2 ? HImode : QImode;\n+\trtx tmpreg = gen_reg_rtx (mode);\n+\trtx increment = mode == QImode ? const1_rtx : const2_rtx;\n+\trtx length = operands[2];\n+\trtx label = gen_label_rtx ();\n+\trtx end_src_ptr = gen_reg_rtx (Pmode);\n+\n+/*\temit_move_insn (length, gen_rtx(MINUS, HImode, length, increment));*/\n+\tFAIL;\n+\tif (Pmode == HImode)\n+\t  emit_insn (gen_addhi3 (end_src_ptr, src_ptr, length));\n+\telse\n+\t  emit_insn (gen_addsi3 (end_src_ptr, src_ptr, length));\n+\n+\temit_label (label);\n+\temit_move_insn (tmpreg, gen_rtx (MEM, mode, src_ptr));\n+\temit_move_insn (gen_rtx (MEM, mode, dst_ptr), tmpreg);\n+\temit_insn (gen_rtx (SET, VOIDmode, src_ptr,\n+\t\t\t    gen_rtx (PLUS, Pmode, src_ptr, increment)));\n+\temit_insn (gen_rtx (SET, VOIDmode, dst_ptr,\n+\t\t\t    gen_rtx (PLUS, Pmode, dst_ptr, increment)));\n+\n+\temit_insn (gen_rtx (SET, VOIDmode, cc0_rtx,\n+\t\t\t    gen_rtx (COMPARE, Pmode, src_ptr, end_src_ptr)));\n+\temit_jump_insn (gen_bne (label));\n+\n+\tDONE;\t\n+}\")\n \n-;; notice a move which could be predecremented\n+;; ----------------------------------------------\n+;; Peepholes go at the end.\n+;; ----------------------------------------------\n \n-(define_peephole \n-  [(set (match_operand:HI 1 \"register_operand\" \"\")\n-\t(plus:HI (match_dup 1) (const_int -1)))\n-   (set (mem:HI (match_dup 1))\n-\t(match_operand:HI 0 \"register_operand\" \"\"))]\n-  \"REGNO (operands[1]) != REGNO (operands[0])\"\n-  \"mov.w\t%T0,@-%T1\"\n-  [(set_attr \"length\" \"2\")\n+;; Notice when two byte moves in a row could be a word move.\n+\n+(define_peephole\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(mem:QI (plus:HI (match_operand:HI 1 \"register_operand\" \"ra\")\n+\t\t\t (match_operand:HI 2 \"immediate_operand\" \"n\"))))\n+   (set (match_operand:QI 3 \"register_operand\" \"=r\")\n+\t(mem:QI (plus:HI (match_dup 1)\n+\t\t\t (match_operand:HI 4 \"immediate_operand\" \"n\"))))]\n+  \"(INTVAL(operands[2]) == INTVAL(operands[4])+1) && REGNO(operands[0]) +1 == REGNO(operands[3])\"\n+  \"mov.w\t@(%u4,%T1),%T0\"\n+  [(set_attr \"length\" \"6\")\n    (set_attr \"cc\" \"set\")])\n \n+(define_peephole\n+  [(set (mem:QI (plus:HI (match_operand:HI 1 \"register_operand\" \"ra\")\n+\t\t\t (match_operand:HI 2 \"immediate_operand\" \"n\")))\n+\t(match_operand:QI 0 \"register_operand\" \"r\"))\n+   (set (mem:QI (plus:HI (match_dup 1)\n+\t\t\t (match_operand:HI 4 \"immediate_operand\" \"n\")))\n+\t(match_operand:QI 3 \"register_operand\" \"r\"))]\n+  \"(INTVAL(operands[2]) == INTVAL(operands[4])+1) && REGNO(operands[0]) +1 == REGNO(operands[3])\"\n+  \"mov.w\t%T0,@(%u4,%T1)\"\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"cc\" \"set\")])\n+\n+;; Notice a move which could be post incremented.\n+\n (define_peephole \n-  [(set (match_operand:HI 1 \"register_operand\" \"\")\n-\t(plus:HI (match_dup 1) (const_int -1)))\n-   (set (mem:QI (match_dup 1))\n-\t(match_operand:QI 0 \"register_operand\" \"\"))]\n-  \"REGNO (operands[1]) != REGNO (operands[0])\"\n-  \"mov.b\t%X0,@-%T1\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(mem:QI (match_operand:HI 1 \"register_operand\" \"\")))\n+   (set (match_dup 1) (plus:HI (match_dup 1) (const_int 1)))]\n+  \"REGNO(operands[1]) != REGNO(operands[0])\"\n+  \"mov.b\t@%T1+,%X0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set\")])\n \n-;; notice a move which could be post incremented\n-\n (define_peephole \n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n \t(mem:HI (match_operand:HI 1 \"register_operand\" \"\")))\n    (set (match_dup 1) (plus:HI (match_dup 1) (const_int 2)))]\n-  \"REGNO (operands[1]) != REGNO (operands[0])\"\n+  \"REGNO(operands[1]) != REGNO(operands[0])\"\n   \"mov.w\t@%T1+,%T0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set\")])\n \n+;; Notice a move which could be predecremented.\n+\n (define_peephole \n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(mem:QI (match_operand:HI 1 \"register_operand\" \"\")))\n-   (set (match_dup 1) (plus:HI (match_dup 1) (const_int 1)))]\n-  \"REGNO (operands[1]) != REGNO (operands[0])\"\n-  \"mov.b\t@%T1+,%X0\"\n+  [(set (match_operand:HI 1 \"register_operand\" \"\")\n+\t(plus:HI (match_dup 1) (const_int -1)))\n+   (set (mem:QI (match_dup 1))\n+\t\t(match_operand:QI 0 \"register_operand\" \"\"))]\n+  \"REGNO(operands[1]) != REGNO(operands[0])\"\n+  \"mov.b\t%X0,@-%T1\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set\")])\n \n-;; notice when two byte moves in a row could be a word move\n-\n-(define_peephole\n-  [(set (mem:QI (plus:HI (match_operand:HI 1 \"register_operand\" \"ra\")\n-\t\t\t (match_operand:HI 2 \"immediate_operand\" \"n\")))\n-\t(match_operand:QI 0 \"register_operand\" \"r\"))\n-   (set (mem:QI (plus:HI (match_dup 1)\n-\t\t\t (match_operand:HI 4 \"immediate_operand\" \"n\")))\n-\t(match_operand:QI 3 \"register_operand\" \"r\"))]\n-  \"(INTVAL (operands[2]) == INTVAL (operands[4]) + 1) \n-   && (REGNO (operands[0]) + 1 == REGNO (operands[3]))\"\n-  \"mov.w\t%T0,@(%u4,%T1)\"\n-  [(set_attr \"length\" \"6\")\n+(define_peephole \n+  [(set (match_operand:HI 1 \"register_operand\" \"\")\n+\t(plus:HI (match_dup 1) (const_int -1)))\n+   (set (mem:HI (match_dup 1))\n+\t\t(match_operand:HI 0 \"register_operand\" \"\"))]\n+  \"REGNO(operands[1]) != REGNO(operands[0])\"\n+  \"mov.w\t%T0,@-%T1\"\n+  [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set\")])\n \n-(define_peephole\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(mem:QI (plus:HI (match_operand:HI 1 \"register_operand\" \"ra\")\n-\t\t\t (match_operand:HI 2 \"immediate_operand\" \"n\"))))\n-   (set (match_operand:QI 3 \"register_operand\" \"=r\")\n-\t(mem:QI (plus:HI (match_dup 1)\n-\t\t\t (match_operand:HI 4 \"immediate_operand\" \"n\"))))]\n-  \"(INTVAL (operands[2]) == INTVAL (operands[4]) + 1) \n-   && (REGNO (operands[0]) + 1 == REGNO (operands[3]))\"\n-  \"mov.w\t@(%u4,%T1),%T0\"\n-  [(set_attr \"length\" \"6\")\n-   (set_attr \"cc\" \"set\")])\n+;(define_insn \"\"\n+;  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+;\t(MEM:HI (match_operand:HI 1 \"register_operand\" \"r\")))\n+;   (set (match_operand:HI 3 \"register_operand\" \"=r\")\n+;\t(zero_extract:HI (match_dup 0)\n+;\t\t\t (const_int 1)\n+;\t\t\t (match_operand:HI 2 \"general_operand\" \"g\")))\n+;   (set (MEM:HI (match_dup 1) (match_dup 3)))]\n+;  \"\"\n+;  \"bld\t#0,%3l\\;bst\t%Z2,%0%Y1\"\n+;  [(set_attr \"type\" \"multi\")\n+;   (set_attr \"length\" \"4\")\n+;   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"fancybset1\"\n+  [(set (match_operand:QI 0 \"bit_operand\" \"=Ur\")\n+\t(ior:QI (subreg:QI \n+\t\t (ashift:HI (const_int 1)\n+\t\t\t    (subreg:QI (match_operand:HI 1 \"register_operand\" \"ri\") 0)) 0)\n+\t\t(match_dup 0)))]\n+  \"\"\n+  \"bset\t%X1,%X0\")\t\n+\n+(define_insn \"fancybset\"\n+  [(set (match_operand:QI 0 \"bit_operand\" \"=Ur\")\n+\t(ior:QI (subreg:QI \n+\t\t (ashift:HI (const_int 1)\n+\t\t\t    (match_operand:HI 1 \"nonmemory_operand\" \"ri\") ) 0)\n+\t\t(match_operand:QI 2 \"general_operand\" \"Ur\")))]\n+  \"\"\n+  \"mov.b\t%X2,%X0\\;bset\t%X1,%X0\")\t\n+\n+\n+(define_insn \"fancybclr4\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=Ur,Ur\")\n+\t(and:QI \n+\t (subreg:QI \n+\t  (rotate:HI (const_int -2)\n+\t\t     (match_operand:HI 2 \"nonmemory_operand\" \"ri,ri\") ) 0)\n+\t (match_operand:QI 1 \"general_operand\" \"0,Ur\")))\n+   (clobber (match_scratch:HI 3 \"=X,&r\"))]\n+  \"\"\n+  \"@\n+   bclr\t%X2,%X0; l1\n+   mov.b\t%X1,%X3\\;mov.b\t%3,%0\\;bclr\t%X2,%X0; l3\")\n+\n+(define_insn \"fancybclr5\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=Ur,Ur\")\n+\t(and:QI \n+\t (subreg:QI \n+\t  (rotate:HI (const_int -2)\n+\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"ri,ri\")) 0)\n+\t (match_operand:QI 1 \"general_operand\" \"0,Ur\")))\n+   (clobber (match_scratch:HI 3 \"=X,&r\"))]\n+  \"\"\n+  \"@\n+   bclr\t%X2,%X0; l1\n+   mov.b\t%X1,%X3\\;mov.b\t%3,%0\\;bclr\t%X2,%X0;l2\")\n+\n+(define_insn \"fancybclr2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=U,r\")\n+\t(and:QI \n+\t (subreg:QI \n+\t  (rotate:HI (const_int -2)\n+\t\t     (match_operand:HI 2 \"nonmemory_operand\" \"ri,ri\") ) 0)\n+\t (match_operand:QI 1 \"general_operand\" \"0,0\")))]\n+  \"\"\n+  \"bclr\t%X2,%X0\")\n+\n+(define_insn \"fancybclr3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=U,r\")\n+\t(and:QI \n+\t (subreg:QI \n+\t  (rotate:HI (const_int -2)\n+\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"ri,ri\")) 0)\n+\t (match_operand:QI 1 \"general_operand\" \"0,0\")))]\n+  \"\"\n+  \"bclr\t%X2,%X0\")\n+\n+(define_insn \"fancybclr\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r\")\n+\t(and:QI (not:QI (match_operand:QI 1 \"general_operand\" \"0\"))\n+\t\t(match_operand:QI 2 \"general_operand\" \"r\")))]\n+  \"\"\n+  \"not\t%X0\\;and\t%X2,%X0\")\n+\n+(define_insn \"fancybsetp3\"\n+  [(set (match_operand:QI 0 \"bit_operand\" \"=Ur\")\n+\t(ior:QI (subreg:QI (ashift:HI (const_int 1)\n+\t\t\t\t      (match_operand:QI 1 \"register_operand\" \"r\")) 0)\n+\t\t(match_operand:QI 2 \"bit_operand\" \"0\")))]\n+  \"\"\n+  \"bset\t%X1,%X0\")\n+\n+(define_insn \"fancybsetp2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,U\")\n+\t(ior:QI (subreg:QI (ashift:HI (const_int 1)\n+\t\t\t\t      (match_operand:QI 1 \"register_operand\" \"r,r\")) 0)\n+\t\t(match_operand:QI 2 \"general_operand\" \"U,r\")))]\n+  \"\"\n+  \"mov.b\t%X2,%X0\\;bset\t%X1,%X0\")\n+\t\n+(define_insn \"fancybnot\"\n+  [(set (match_operand:QI 0 \"bit_operand\" \"=Ur\")\n+\t(xor:QI (subreg:QI (ashift:HI (const_int 1)\n+\t\t\t\t      (match_operand:QI 1 \"register_operand\" \"r\")) 0)\n+\t\t(match_operand:QI 2 \"bit_operand\" \"0\")))]\n+\n+  \"\"\n+  \"bnot\t%X1,%X0\")\n+\n+(define_insn \"fancy_btst\"\n+  [(set (pc)\n+\t(if_then_else (eq (zero_extract:HI (zero_extend:HI (match_operand:QI 0 \"general_operand\" \"Ur\"))\n+\t\t\t\t\t   (const_int 1)\n+\t\t\t\t\t   (match_operand:HI 1 \"nonmemory_operand\" \"rn\"))\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+{\n+  if (get_attr_length (insn) == 2)\n+    return \\\"btst\t%X1,%X0\\;beq\t%l2\\\";\n+  else if (get_attr_length (insn) == 4)\n+    return \\\"btst\t%X1,%X0\\;beq\t%l2:16\\\";\n+  else\n+    return \\\"btst\t%X1,%X0\\;bne\t%L0\\;jmp\t@%l2\\;%L0:\\\";\n+}\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"fancy_btst1\"\n+  [(set (pc)\n+\t(if_then_else (ne (zero_extract:HI (zero_extend:HI (match_operand:QI 0 \"general_operand\" \"Ur\"))\n+\t\t\t\t\t   (const_int 1)\n+\t\t\t\t\t   (match_operand:HI 1 \"nonmemory_operand\" \"rn\"))\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+{\n+  if (get_attr_length (insn) == 2)\n+    return \\\"btst\t%X1,%X0\\;bne\t%l2\\\";\n+  else if (get_attr_length (insn) == 4)\n+    return \\\"btst\t%X1,%X0\\;bne\t%l2:16\\\";\n+  else\n+    return \\\"btst\t%X1,%X0\\;beq\t%L0\\;jmp\t@%l2\\;%L0:\\\";\n+}\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"pxor\"\n+  [(set (zero_extract:QI (match_operand:QI 0 \"bit_operand\" \"=r,U\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand 1 \"immediate_operand\" \"n,n\"))\n+\t(and:QI (not:QI (match_operand:QI 2 \"bit_operand\" \"r,U\"))\n+\t\t\t(const_int 1)))]\n+  \"\"\n+  \"bld\t#0,%X2\\;bist\t%1,%0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])"}]}