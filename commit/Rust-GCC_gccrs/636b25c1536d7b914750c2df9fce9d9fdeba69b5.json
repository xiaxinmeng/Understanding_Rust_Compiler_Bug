{"sha": "636b25c1536d7b914750c2df9fce9d9fdeba69b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM2YjI1YzE1MzZkN2I5MTQ3NTBjMmRmOWZjZTlkOWZkZWJhNjliNQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2015-11-06T16:21:29Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2015-11-06T16:21:29Z"}, "message": "Support non-type constrained-type-specifiers.\n\n\t* parser.c (check_type_concept): Remove.\n\t(cp_parser_maybe_constrained_type_specifier): Don't call it.\n\t(synthesize_implicit_template_parm): Handle non-type and template\n\ttemplate parameters.  Also compare extra args.  Return the decl.\n\t(cp_parser_template_argument): Handle constrained-type-specifiers for\n\tnon-type template parameters.\n\t(finish_constrained_template_template_parm): Split out from\n\tcp_parser_constrained_template_template_parm.\n\t(cp_parser_nonclass_name): Move some logic into\n\tcp_parser_maybe_concept_name.\n\t(cp_parser_init_declarator): Fix error recovery.\n\t(get_concept_from_constraint): Remove.\n\t(cp_parser_simple_type_specifier): Adjust for\n\tsynthesize_implicit_template_parm returning the decl.\n\t* constraint.cc (placeholder_extract_concept_and_args)\n\t(equivalent_placeholder_constraints): Also handle TYPE_DECL\n\tconstrained parms.\n\nFrom-SVN: r229860", "tree": {"sha": "89ef5af8fb6b67cce2a04c31f33cef0cc93af5af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89ef5af8fb6b67cce2a04c31f33cef0cc93af5af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/636b25c1536d7b914750c2df9fce9d9fdeba69b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/636b25c1536d7b914750c2df9fce9d9fdeba69b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/636b25c1536d7b914750c2df9fce9d9fdeba69b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/636b25c1536d7b914750c2df9fce9d9fdeba69b5/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "567700fddd2cbc1d90bb8f2acae81b3210dba2fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/567700fddd2cbc1d90bb8f2acae81b3210dba2fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/567700fddd2cbc1d90bb8f2acae81b3210dba2fb"}], "stats": {"total": 198, "additions": 123, "deletions": 75}, "files": [{"sha": "ce8a81f6a1e983db4f0ecbfb3562fb46a111e1eb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636b25c1536d7b914750c2df9fce9d9fdeba69b5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636b25c1536d7b914750c2df9fce9d9fdeba69b5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=636b25c1536d7b914750c2df9fce9d9fdeba69b5", "patch": "@@ -1,5 +1,24 @@\n 2015-11-06  Jason Merrill  <jason@redhat.com>\n \n+\tSupport non-type constrained-type-specifiers.\n+\t* parser.c (check_type_concept): Remove.\n+\t(cp_parser_maybe_constrained_type_specifier): Don't call it.\n+\t(synthesize_implicit_template_parm): Handle non-type and template\n+\ttemplate parameters.  Also compare extra args.  Return the decl.\n+\t(cp_parser_template_argument): Handle constrained-type-specifiers for\n+\tnon-type template parameters.\n+\t(finish_constrained_template_template_parm): Split out from\n+\tcp_parser_constrained_template_template_parm.\n+\t(cp_parser_nonclass_name): Move some logic into\n+\tcp_parser_maybe_concept_name.\n+\t(cp_parser_init_declarator): Fix error recovery.\n+\t(get_concept_from_constraint): Remove.\n+\t(cp_parser_simple_type_specifier): Adjust for\n+\tsynthesize_implicit_template_parm returning the decl.\n+\t* constraint.cc (placeholder_extract_concept_and_args)\n+\t(equivalent_placeholder_constraints): Also handle TYPE_DECL\n+\tconstrained parms.\n+\n \t* pt.c (push_inline_template_parms_recursive): Don't recreate the\n \tCONST_DECL.\n "}, {"sha": "c6eaf7546068900801b4fef5bbda3f748afb5212", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636b25c1536d7b914750c2df9fce9d9fdeba69b5/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636b25c1536d7b914750c2df9fce9d9fdeba69b5/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=636b25c1536d7b914750c2df9fce9d9fdeba69b5", "patch": "@@ -1379,12 +1379,21 @@ make_constrained_auto (tree con, tree args)\n   return decl;\n }\n \n-/* Given the predicate constraint T from a placeholder type, extract its\n-   TMPL and ARGS.  */\n+/* Given the predicate constraint T from a constrained-type-specifier, extract\n+   its TMPL and ARGS.  FIXME why do we need two different forms of\n+   constrained-type-specifier?  */\n \n void\n placeholder_extract_concept_and_args (tree t, tree &tmpl, tree &args)\n {\n+  if (TREE_CODE (t) == TYPE_DECL)\n+    {\n+      /* A constrained parameter.  */\n+      tmpl = DECL_TI_TEMPLATE (CONSTRAINED_PARM_CONCEPT (t));\n+      args = CONSTRAINED_PARM_EXTRA_ARGS (t);\n+      return;\n+    }\n+\n   gcc_assert (TREE_CODE (t) == PRED_CONSTR);\n   t = PRED_CONSTR_EXPR (t);\n   gcc_assert (TREE_CODE (t) == CALL_EXPR\n@@ -1418,9 +1427,10 @@ placeholder_extract_concept_and_args (tree t, tree &tmpl, tree &args)\n bool\n equivalent_placeholder_constraints (tree c1, tree c2)\n {\n-  if (TREE_CODE (c1) == TEMPLATE_TYPE_PARM)\n+  if (c1 && TREE_CODE (c1) == TEMPLATE_TYPE_PARM)\n+    /* A constrained auto.  */\n     c1 = PLACEHOLDER_TYPE_CONSTRAINTS (c1);\n-  if (TREE_CODE (c2) == TEMPLATE_TYPE_PARM)\n+  if (c2 && TREE_CODE (c2) == TEMPLATE_TYPE_PARM)\n     c2 = PLACEHOLDER_TYPE_CONSTRAINTS (c2);\n \n   if (c1 == c2)\n@@ -1434,14 +1444,21 @@ equivalent_placeholder_constraints (tree c1, tree c2)\n \n   if (t1 != t2)\n     return false;\n-  int len = TREE_VEC_LENGTH (a1);\n-  if (len != TREE_VEC_LENGTH (a2))\n-    return false;\n+\n   /* Skip the first argument to avoid infinite recursion on the\n      placeholder auto itself.  */\n-  for (int i = len-1; i > 0; --i)\n-    if (!cp_tree_equal (TREE_VEC_ELT (a1, i),\n-\t\t\tTREE_VEC_ELT (a2, i)))\n+  bool skip1 = (TREE_CODE (c1) == PRED_CONSTR);\n+  bool skip2 = (TREE_CODE (c2) == PRED_CONSTR);\n+\n+  int len1 = (a1 ? TREE_VEC_LENGTH (a1) : 0) - skip1;\n+  int len2 = (a2 ? TREE_VEC_LENGTH (a2) : 0) - skip2;\n+\n+  if (len1 != len2)\n+    return false;\n+\n+  for (int i = 0; i < len1; ++i)\n+    if (!cp_tree_equal (TREE_VEC_ELT (a1, i + skip1),\n+\t\t\tTREE_VEC_ELT (a2, i + skip2)))\n       return false;\n   return true;\n }"}, {"sha": "d1f4970f1eb1967b2e9fad7fa8a7dc15e1eb031c", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 65, "deletions": 63, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636b25c1536d7b914750c2df9fce9d9fdeba69b5/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636b25c1536d7b914750c2df9fce9d9fdeba69b5/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=636b25c1536d7b914750c2df9fce9d9fdeba69b5", "patch": "@@ -13871,18 +13871,9 @@ cp_parser_constrained_type_template_parm (cp_parser *parser,\n     return error_mark_node;\n }\n \n-/* Finish parsing/processing a template template parameter by borrowing\n-   the template parameter list from the prototype parameter.  */\n-\n static tree\n-cp_parser_constrained_template_template_parm (cp_parser *parser,\n-                                              tree proto,\n-                                              tree id,\n-                                              cp_parameter_declarator *parmdecl)\n+finish_constrained_template_template_parm (tree proto, tree id)\n {\n-  if (!cp_parser_check_constrained_type_parm (parser, parmdecl))\n-    return error_mark_node;\n-\n   /* FIXME: This should probably be copied, and we may need to adjust\n      the template parameter depths.  */\n   tree saved_parms = current_template_parms;\n@@ -13896,6 +13887,20 @@ cp_parser_constrained_template_template_parm (cp_parser *parser,\n   return parm;\n }\n \n+/* Finish parsing/processing a template template parameter by borrowing\n+   the template parameter list from the prototype parameter.  */\n+\n+static tree\n+cp_parser_constrained_template_template_parm (cp_parser *parser,\n+                                              tree proto,\n+                                              tree id,\n+                                              cp_parameter_declarator *parmdecl)\n+{\n+  if (!cp_parser_check_constrained_type_parm (parser, parmdecl))\n+    return error_mark_node;\n+  return finish_constrained_template_template_parm (proto, id);\n+}\n+\n /* Create a new non-type template parameter from the given PARM\n    declarator.  */\n \n@@ -14950,8 +14955,12 @@ cp_parser_template_argument (cp_parser* parser)\n \t\t\t\t\t  /*check_dependency=*/true,\n \t\t\t\t\t  /*ambiguous_decls=*/NULL,\n \t\t\t\t\t  argument_start_token->location);\n-      if (TREE_CODE (argument) != TEMPLATE_DECL\n-\t  && TREE_CODE (argument) != UNBOUND_CLASS_TEMPLATE)\n+      /* Handle a constrained-type-specifier for a non-type template\n+\t parameter.  */\n+      if (tree decl = cp_parser_maybe_concept_name (parser, argument))\n+\targument = decl;\n+      else if (TREE_CODE (argument) != TEMPLATE_DECL\n+\t       && TREE_CODE (argument) != UNBOUND_CLASS_TEMPLATE)\n \tcp_parser_error (parser, \"expected template-name\");\n     }\n   if (cp_parser_parse_definitely (parser))\n@@ -15630,7 +15639,10 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \t    }\n \n \t  if (cxx_dialect >= cxx14)\n-\t    type = synthesize_implicit_template_parm (parser, NULL_TREE);\n+\t    {\n+\t      type = synthesize_implicit_template_parm (parser, NULL_TREE);\n+\t      type = TREE_TYPE (type);\n+\t    }\n \t  else\n \t    type = error_mark_node;\n \n@@ -15949,19 +15961,6 @@ cp_parser_type_name (cp_parser* parser, bool typename_keyword_p)\n   return type_decl;\n }\n \n-/* Returns true if proto is a type parameter, but not a template\n-   template parameter.  */\n-static bool\n-check_type_concept (tree fn, tree proto)\n-{\n-  if (TREE_CODE (proto) != TYPE_DECL)\n-    {\n-      error (\"invalid use of non-type concept %qD\", fn);\n-      return false;\n-    }\n-  return true;\n-}\n-\n /*  Check if DECL and ARGS can form a constrained-type-specifier.\n     If ARGS is non-null, we try to form a concept check of the\n     form DECL<?, ARGS> where ? is a wildcard that matches any\n@@ -16009,13 +16008,6 @@ cp_parser_maybe_constrained_type_specifier (cp_parser *parser,\n   if (processing_template_parmlist)\n     return build_constrained_parameter (conc, proto, args);\n \n-  /* In any other context, a concept must be a type concept.\n-\n-     FIXME: A constrained-type-specifier can be a placeholder\n-     of any kind.  */\n-  if (!check_type_concept (conc, proto))\n-    return error_mark_node;\n-\n   /* In a parameter-declaration-clause, constrained-type\n      specifiers result in invented template parameters.  */\n   if (parser->auto_is_implicit_function_template_parm_p)\n@@ -16046,7 +16038,13 @@ cp_parser_maybe_constrained_type_specifier (cp_parser *parser,\n static tree\n cp_parser_maybe_concept_name (cp_parser* parser, tree decl)\n {\n-  return cp_parser_maybe_constrained_type_specifier (parser, decl, NULL_TREE);\n+  if (flag_concepts\n+      && (TREE_CODE (decl) == OVERLOAD\n+\t  || BASELINK_P (decl)\n+\t  || variable_concept_p (decl)))\n+    return cp_parser_maybe_constrained_type_specifier (parser, decl, NULL_TREE);\n+  else\n+    return NULL_TREE;\n }\n \n /* Check if DECL and ARGS form a partial-concept-id.  If so,\n@@ -16093,15 +16091,8 @@ cp_parser_nonclass_name (cp_parser* parser)\n   type_decl = strip_using_decl (type_decl);\n   \n   /* If we found an overload set, then it may refer to a concept-name. */\n-  if (flag_concepts\n-      && (TREE_CODE (type_decl) == OVERLOAD\n-\t  || BASELINK_P (type_decl)\n-\t  || variable_concept_p (type_decl)))\n-  {\n-    /* Determine whether the overload refers to a concept. */\n-    if (tree decl = cp_parser_maybe_concept_name (parser, type_decl))\n-      return decl;\n-  }\n+  if (tree decl = cp_parser_maybe_concept_name (parser, type_decl))\n+    type_decl = decl;\n \n   if (TREE_CODE (type_decl) != TYPE_DECL\n       && (objc_is_id (identifier) || objc_is_class_name (identifier)))\n@@ -18183,7 +18174,7 @@ cp_parser_init_declarator (cp_parser* parser,\n \t       \"attributes after parenthesized initializer ignored\");\n \n   /* And now complain about a non-function implicit template.  */\n-  if (bogus_implicit_tmpl)\n+  if (bogus_implicit_tmpl && decl != error_mark_node)\n     error_at (DECL_SOURCE_LOCATION (decl),\n \t      \"non-function %qD declared as implicit template\", decl);\n \n@@ -36681,17 +36672,6 @@ tree_type_is_auto_or_concept (const_tree t)\n   return TREE_TYPE (t) && is_auto_or_concept (TREE_TYPE (t));\n }\n \n-/* Returns the template declaration being called or evaluated as\n-   part of the constraint check. Note that T must be a predicate\n-   constraint (it can't be any other kind of constraint). */\n-static tree\n-get_concept_from_constraint (tree t)\n-{\n-  tree tmpl, args;\n-  placeholder_extract_concept_and_args (t, tmpl, args);\n-  return DECL_TEMPLATE_RESULT (tmpl);\n-}\n-\n /* Add an implicit template type parameter to the CURRENT_TEMPLATE_PARMS\n    (creating a new template parameter list if necessary).  Returns the newly\n    created template type parm.  */\n@@ -36711,9 +36691,14 @@ synthesize_implicit_template_parm  (cp_parser *parser, tree constr)\n       tree t = parser->implicit_template_parms;\n       while (t)\n         {\n-          tree c = get_concept_from_constraint (TREE_TYPE (t));\n-          if (c == CONSTRAINED_PARM_CONCEPT (constr))\n-            return TREE_VALUE (t);\n+          if (equivalent_placeholder_constraints (TREE_TYPE (t), constr))\n+\t    {\n+\t      tree d = TREE_VALUE (t);\n+\t      if (TREE_CODE (d) == PARM_DECL)\n+\t\t/* Return the TEMPLATE_PARM_INDEX.  */\n+\t\td = DECL_INITIAL (d);\n+\t      return d;\n+\t    }\n           t = TREE_CHAIN (t);\n         }\n     }\n@@ -36823,9 +36808,23 @@ synthesize_implicit_template_parm  (cp_parser *parser, tree constr)\n   /* Synthesize a new template parameter and track the current template\n      parameter chain with implicit_template_parms.  */\n \n+  tree proto = constr ? DECL_INITIAL (constr) : NULL_TREE;\n   tree synth_id = make_generic_type_name ();\n-  tree synth_tmpl_parm = finish_template_type_parm (class_type_node,\n-\t\t\t\t\t\t    synth_id);\n+  tree synth_tmpl_parm;\n+  bool non_type = false;\n+\n+  if (proto == NULL_TREE || TREE_CODE (proto) == TYPE_DECL)\n+    synth_tmpl_parm\n+      = finish_template_type_parm (class_type_node, synth_id);\n+  else if (TREE_CODE (proto) == TEMPLATE_DECL)\n+    synth_tmpl_parm\n+      = finish_constrained_template_template_parm (proto, synth_id);\n+  else\n+    {\n+      synth_tmpl_parm = copy_decl (proto);\n+      DECL_NAME (synth_tmpl_parm) = synth_id;\n+      non_type = true;\n+    }\n \n   // Attach the constraint to the parm before processing.\n   tree node = build_tree_list (NULL_TREE, synth_tmpl_parm);\n@@ -36834,7 +36833,7 @@ synthesize_implicit_template_parm  (cp_parser *parser, tree constr)\n     = process_template_parm (parser->implicit_template_parms,\n \t\t\t     input_location,\n \t\t\t     node,\n-\t\t\t     /*non_type=*/false,\n+\t\t\t     /*non_type=*/non_type,\n \t\t\t     /*param_pack=*/false);\n \n   // Chain the new parameter to the list of implicit parameters.\n@@ -36844,7 +36843,10 @@ synthesize_implicit_template_parm  (cp_parser *parser, tree constr)\n   else\n     parser->implicit_template_parms = new_parm;\n \n-  tree new_type = TREE_TYPE (getdecls ());\n+  tree new_decl = getdecls ();\n+  if (non_type)\n+    /* Return the TEMPLATE_PARM_INDEX, not the PARM_DECL.  */\n+    new_decl = DECL_INITIAL (new_decl);\n \n   /* If creating a fully implicit function template, start the new implicit\n      template parameter list with this synthesized type, otherwise grow the\n@@ -36878,7 +36880,7 @@ synthesize_implicit_template_parm  (cp_parser *parser, tree constr)\n \n   current_binding_level = entry_scope;\n \n-  return new_type;\n+  return new_decl;\n }\n \n /* Finish the declaration of a fully implicit function template.  Such a"}, {"sha": "1e975108257b5c3c75c234ac5c322a0fe4fb49b6", "filename": "gcc/testsuite/g++.dg/concepts/generic-fn-err.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636b25c1536d7b914750c2df9fce9d9fdeba69b5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fgeneric-fn-err.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636b25c1536d7b914750c2df9fce9d9fdeba69b5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fgeneric-fn-err.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fgeneric-fn-err.C?ref=636b25c1536d7b914750c2df9fce9d9fdeba69b5", "patch": "@@ -11,8 +11,8 @@ template<template<typename> class X>\n \n struct S { };\n \n-void f1(Int) { }      // { dg-error \"invalid\" }\n-void f2(Template) { } // { dg-error \"invalid\" }\n+void f1(Int) { }      // { dg-error \"\" }\n+void f2(Template) { } // { dg-error \"\" }\n \n struct S1 {\n   void f1(auto x) { }"}, {"sha": "7f2e67a9192b8d082a2f850048833a6505d33253", "filename": "gcc/testsuite/g++.dg/concepts/placeholder6.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636b25c1536d7b914750c2df9fce9d9fdeba69b5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636b25c1536d7b914750c2df9fce9d9fdeba69b5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fplaceholder6.C?ref=636b25c1536d7b914750c2df9fce9d9fdeba69b5", "patch": "@@ -0,0 +1,10 @@\n+// { dg-options -std=c++1z }\n+\n+template <int I> struct B { static const int i = I; };\n+template <int I> concept bool Few = I < 10;\n+\n+constexpr int g(B<Few> b) { return b.i; }\n+\n+#define SA(X) static_assert((X),#X)\n+SA(g(B<2>{}) == 2);\n+SA(g(B<10>{}) == 10); \t\t// { dg-error \"\" }"}]}