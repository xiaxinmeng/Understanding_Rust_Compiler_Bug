{"sha": "fc76a969ebc282f783412cbd73d6c3805781b147", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM3NmE5NjllYmMyODJmNzgzNDEyY2JkNzNkNmMzODA1NzgxYjE0Nw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-10-16T23:07:29Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-10-16T23:07:29Z"}, "message": "paranoia.cc (ENUM_BITFIELD): New.\n\n        * paranoia.cc (ENUM_BITFIELD): New.\n        (class): Define as klass around real.h.\n        (real_c_float): Not a template any longer; define MODE as a\n        class static constant; use real_format elements for SIZE.\n        Update uses of real_to_decimal and real_to_hexadecimal.\n        (main): Change -g argument to use a format name.\n        (mode_for_size): Remove.\n\nFrom-SVN: r58226", "tree": {"sha": "f3c1d9d148076b67d5850c8d5265e334cd0a3419", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3c1d9d148076b67d5850c8d5265e334cd0a3419"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc76a969ebc282f783412cbd73d6c3805781b147", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc76a969ebc282f783412cbd73d6c3805781b147", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc76a969ebc282f783412cbd73d6c3805781b147", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc76a969ebc282f783412cbd73d6c3805781b147/comments", "author": null, "committer": null, "parents": [{"sha": "e055ba36a15f1c8a4f30c6ca63564546c6d1087a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e055ba36a15f1c8a4f30c6ca63564546c6d1087a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e055ba36a15f1c8a4f30c6ca63564546c6d1087a"}], "stats": {"total": 167, "additions": 89, "deletions": 78}, "files": [{"sha": "c28fd46ad552f3766fa9286497560f8cd717bb5f", "filename": "contrib/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc76a969ebc282f783412cbd73d6c3805781b147/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc76a969ebc282f783412cbd73d6c3805781b147/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=fc76a969ebc282f783412cbd73d6c3805781b147", "patch": "@@ -1,3 +1,13 @@\n+2002-10-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* paranoia.cc (ENUM_BITFIELD): New.\n+\t(class): Define as klass around real.h.\n+\t(real_c_float): Not a template any longer; define MODE as a\n+\tclass static constant; use real_format elements for SIZE.\n+\tUpdate uses of real_to_decimal and real_to_hexadecimal.\n+\t(main): Change -g argument to use a format name.\n+\t(mode_for_size): Remove.\n+\n 2002-09-16  Richard Henderson  <rth@redhat.com>\n \n \t* paranoia.cc: New file."}, {"sha": "fafb92b708f199c76e2d27259aa27816f1c4ef48", "filename": "contrib/paranoia.cc", "status": "modified", "additions": 79, "deletions": 78, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc76a969ebc282f783412cbd73d6c3805781b147/contrib%2Fparanoia.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc76a969ebc282f783412cbd73d6c3805781b147/contrib%2Fparanoia.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fparanoia.cc?ref=fc76a969ebc282f783412cbd73d6c3805781b147", "patch": "@@ -169,7 +169,12 @@ lines\n     };\n #undef DEFTREECODE\n \n+#define ENUM_BITFIELD(X) enum X\n+#define class klass\n+\n #include \"real.h\"\n+\n+#undef class\n   }\n \n /* We never produce signals from the library.  Thus setjmp need do nothing.  */\n@@ -184,11 +189,13 @@ static int verbose_index = 0;\n    real.c.  I.e. the object of this excersize.  Templated so that we can\n    all fp sizes.  */\n \n-template<int SIZE, enum machine_mode MODE>\n class real_c_float\n {\n+ public:\n+  static const enum machine_mode MODE = SFmode;\n+\n  private:\n-  long image[SIZE / 32];\n+  long image[128 / 32];\n \n   void from_long(long);\n   void from_str(const char *);\n@@ -241,22 +248,20 @@ class real_c_float\n   void ldexp (int);\n };\n \n-template<int SIZE, enum machine_mode MODE>\n void\n-real_c_float<SIZE, MODE>::from_long (long l)\n+real_c_float::from_long (long l)\n {\n   REAL_VALUE_TYPE f;\n \n   real_from_integer (&f, MODE, l, l < 0 ? -1 : 0, 0);\n   real_to_target (image, &f, MODE);\n }\n \n-template<int SIZE, enum machine_mode MODE>\n void\n-real_c_float<SIZE, MODE>::from_str (const char *s)\n+real_c_float::from_str (const char *s)\n {\n   REAL_VALUE_TYPE f;\n-  char *p = s;\n+  const char *p = s;\n \n   if (*p == '-' || *p == '+')\n     p++;\n@@ -274,9 +279,8 @@ real_c_float<SIZE, MODE>::from_str (const char *s)\n   real_to_target (image, &f, MODE);\n }\n \n-template<int SIZE, enum machine_mode MODE>\n void\n-real_c_float<SIZE, MODE>::binop (int code, const real_c_float &b)\n+real_c_float::binop (int code, const real_c_float &b)\n {\n   REAL_VALUE_TYPE ai, bi, ri;\n \n@@ -288,13 +292,14 @@ real_c_float<SIZE, MODE>::binop (int code, const real_c_float &b)\n   if (verbose)\n     {\n       char ab[64], bb[64], rb[64];\n-      const int digits = int(SIZE / 4);\n+      const real_format *fmt = real_format_for_mode[MODE - QFmode];\n+      const int digits = (fmt->p * fmt->log2_b + 3) / 4;\n       char symbol_for_code;\n \n       real_from_target (&ri, image, MODE);\n-      real_to_hexadecimal (ab, &ai, digits);\n-      real_to_hexadecimal (bb, &bi, digits);\n-      real_to_hexadecimal (rb, &ri, digits);\n+      real_to_hexadecimal (ab, &ai, sizeof(ab), digits, 0);\n+      real_to_hexadecimal (bb, &bi, sizeof(bb), digits, 0);\n+      real_to_hexadecimal (rb, &ri, sizeof(rb), digits, 0);\n \n       switch (code)\n \t{\n@@ -319,9 +324,8 @@ real_c_float<SIZE, MODE>::binop (int code, const real_c_float &b)\n     }\n }\n \n-template<int SIZE, enum machine_mode MODE>\n void\n-real_c_float<SIZE, MODE>::unop (int code)\n+real_c_float::unop (int code)\n {\n   REAL_VALUE_TYPE ai, ri;\n \n@@ -332,12 +336,13 @@ real_c_float<SIZE, MODE>::unop (int code)\n   if (verbose)\n     {\n       char ab[64], rb[64];\n-      const int digits = int(SIZE / 4);\n+      const real_format *fmt = real_format_for_mode[MODE - QFmode];\n+      const int digits = (fmt->p * fmt->log2_b + 3) / 4;\n       const char *symbol_for_code;\n \n       real_from_target (&ri, image, MODE);\n-      real_to_hexadecimal (ab, &ai, digits);\n-      real_to_hexadecimal (rb, &ri, digits);\n+      real_to_hexadecimal (ab, &ai, sizeof(ab), digits, 0);\n+      real_to_hexadecimal (rb, &ri, sizeof(rb), digits, 0);\n \n       switch (code)\n \t{\n@@ -356,9 +361,8 @@ real_c_float<SIZE, MODE>::unop (int code)\n     }\n }\n \n-template<int SIZE, enum machine_mode MODE>\n bool\n-real_c_float<SIZE, MODE>::cmp (int code, const real_c_float &b) const\n+real_c_float::cmp (int code, const real_c_float &b) const\n {\n   REAL_VALUE_TYPE ai, bi;\n   bool ret;\n@@ -370,11 +374,12 @@ real_c_float<SIZE, MODE>::cmp (int code, const real_c_float &b) const\n   if (verbose)\n     {\n       char ab[64], bb[64];\n-      const int digits = int(SIZE / 4);\n+      const real_format *fmt = real_format_for_mode[MODE - QFmode];\n+      const int digits = (fmt->p * fmt->log2_b + 3) / 4;\n       const char *symbol_for_code;\n \n-      real_to_hexadecimal (ab, &ai, digits);\n-      real_to_hexadecimal (bb, &bi, digits);\n+      real_to_hexadecimal (ab, &ai, sizeof(ab), digits, 0);\n+      real_to_hexadecimal (bb, &bi, sizeof(bb), digits, 0);\n \n       switch (code)\n \t{\n@@ -407,55 +412,52 @@ real_c_float<SIZE, MODE>::cmp (int code, const real_c_float &b) const\n   return ret;\n }\n \n-template<int SIZE, enum machine_mode MODE>\n const char *\n-real_c_float<SIZE, MODE>::str() const\n+real_c_float::str() const\n {\n   REAL_VALUE_TYPE f;\n-  const int digits = int(SIZE * .30102999566398119521 + 1);\n+  const real_format *fmt = real_format_for_mode[MODE - QFmode];\n+  const int digits = int(fmt->p * fmt->log2_b * .30102999566398119521 + 1);\n \n   real_from_target (&f, image, MODE);\n   char *buf = new char[digits + 10];\n-  real_to_decimal (buf, &f, digits);\n+  real_to_decimal (buf, &f, digits+10, digits, 0);\n \n   return buf;\n }\n \n-template<int SIZE, enum machine_mode MODE>\n const char *\n-real_c_float<SIZE, MODE>::hex() const\n+real_c_float::hex() const\n {\n   REAL_VALUE_TYPE f;\n-  const int digits = int(SIZE / 4);\n+  const real_format *fmt = real_format_for_mode[MODE - QFmode];\n+  const int digits = (fmt->p * fmt->log2_b + 3) / 4;\n \n   real_from_target (&f, image, MODE);\n   char *buf = new char[digits + 10];\n-  real_to_hexadecimal (buf, &f, digits);\n+  real_to_hexadecimal (buf, &f, digits+10, digits, 0);\n \n   return buf;\n }\n \n-template<int SIZE, enum machine_mode MODE>\n long\n-real_c_float<SIZE, MODE>::integer() const\n+real_c_float::integer() const\n {\n   REAL_VALUE_TYPE f;\n   real_from_target (&f, image, MODE);\n   return real_to_integer (&f);\n }\n \n-template<int SIZE, enum machine_mode MODE>\n int\n-real_c_float<SIZE, MODE>::exp() const\n+real_c_float::exp() const\n {\n   REAL_VALUE_TYPE f;\n   real_from_target (&f, image, MODE);\n   return real_exponent (&f);\n }\n \n-template<int SIZE, enum machine_mode MODE>\n void\n-real_c_float<SIZE, MODE>::ldexp (int exp)\n+real_c_float::ldexp (int exp)\n {\n   REAL_VALUE_TYPE ai;\n \n@@ -2605,8 +2607,6 @@ Paranoia<FLOAT>::notify (const char *s)\n \n int main(int ac, char **av)\n {\n-  init_real_once ();\n-\n   while (1)\n     switch (getopt (ac, av, \"pvg:fdl\"))\n       {\n@@ -2620,30 +2620,49 @@ int main(int ac, char **av)\n \tbreak;\n       case 'g':\n \t{\n-\t  int size = strtol (optarg, 0, 0);\n-\n-\t  switch (size)\n-\t    {\n-\t    case 32:\n-\t      Paranoia< real_c_float<32, SFmode> >().main();\n-\t      break;\n-\n-\t    case 64:\n-\t      Paranoia< real_c_float<64, DFmode> >().main();\n-\t      break;\n-\n-\t    case 96:\n-\t      Paranoia< real_c_float<96, XFmode> >().main();\n+\t  static const struct {\n+\t    const char *name;\n+\t    const struct real_format *fmt;\n+\t  } fmts[] = {\n+#define F(x) { #x, &x##_format }\n+\t    F(ieee_single),\n+\t    F(ieee_double),\n+\t    F(ieee_extended_motorola),\n+\t    F(ieee_extended_intel_96),\n+\t    F(ieee_extended_intel_128),\n+\t    F(ibm_extended),\n+\t    F(ieee_quad),\n+\t    F(vax_f),\n+\t    F(vax_d),\n+\t    F(vax_g),\n+\t    F(i370_single),\n+\t    F(i370_double),\n+\t    F(c4x_single),\n+\t    F(c4x_extended),\n+#undef F\n+\t  };\n+\n+\t  int i, n = sizeof (fmts)/sizeof(*fmts);\n+\n+\t  for (i = 0; i < n; ++i)\n+\t    if (strcmp (fmts[i].name, optarg) == 0)\n \t      break;\n \n-\t    case 128:\n-\t      Paranoia< real_c_float<128, TFmode> >().main();\n-\t      break;\n-\n-\t    default:\n-\t      puts (\"Invalid gcc implementation size.\");\n+\t  if (i == n)\n+\t    {\n+\t      printf (\"Unknown implementation \\\"%s\\\"; \"\n+\t\t      \"available implementations:\\n\", optarg);\n+\t      for (i = 0; i < n; ++i)\n+\t\tprintf (\"\\t%s\\n\", fmts[i].name);\n \t      return 1;\n \t    }\n+\n+\t  // We cheat and use the same mode all the time, but vary\n+\t  // the format used for that mode.\n+\t  real_format_for_mode[int(real_c_float::MODE) - int(QFmode)]\n+\t    = fmts[i].fmt;\n+\n+\t  Paranoia<real_c_float>().main();\n \t  break;\n \t}\n \n@@ -2661,7 +2680,7 @@ int main(int ac, char **av)\n \n       case '?':\n \tputs (\"-p\\tpause between pages\");\n-\tputs (\"-g<N>\\treal.c implementation size N\");\n+\tputs (\"-g<FMT>\\treal.c implementation FMT\");\n \tputs (\"-f\\tnative float\");\n \tputs (\"-d\\tnative double\");\n \tputs (\"-l\\tnative long double\");\n@@ -2678,21 +2697,3 @@ fancy_abort ()\n }\n \n int target_flags = 0;\n-\n-extern \"C\"\n-enum machine_mode\n-mode_for_size (unsigned int size, enum mode_class, int)\n-{\n-  switch (size)\n-    {\n-    case 32:\n-      return SFmode;\n-    case 64:\n-      return DFmode;\n-    case 96:\n-      return XFmode;\n-    case 128:\n-      return TFmode;\n-    }\n-  abort ();\n-}"}]}