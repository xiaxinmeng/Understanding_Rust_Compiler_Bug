{"sha": "19ec6a367c17e084d0a9165a1d2284eebb0fe311", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTllYzZhMzY3YzE3ZTA4NGQwYTkxNjVhMWQyMjg0ZWViYjBmZTMxMQ==", "commit": {"author": {"name": "Alan Modra", "email": "alan@linuxcare.com.au", "date": "2001-04-04T03:13:54Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2001-04-04T03:13:54Z"}, "message": "DWARF2 frame notes for hppa.\n\n\t* dwarf2out.c (dwarf2out_frame_debug_expr): Support adjusting\n\tstack pointer via a LO_SUM.  Ditto for setting a temp register\n\tused to save to the stack.  Set cfa_temp when setting fp, and\n\tallow matches to cfa_temp in addition to cfa_store when saving\n\tregs.  Handle POST_INC and LO_SUM register stores.  Document the\n\tchanges and errors in rule 12 doco.\n\n\t* pa.c (set_reg_plus_d, store_reg, load_reg): Return last insn.\n\t(actual_fsize, local_fsize, save_fregs): Move for store_reg to see.\n\t(load_reg): Move closer to epilogue code.\n\t(DO_FRAME_NOTES): Define to control the following..\n\t(FRP): Define to set RTX_FRAME_RELATED_P on insns.\n\t(hppa_expand_prologue): Use FRP and REG_FRAME_RELATED_EXPR\n\tnotes as necessary.\n\t(hppa_expand_epilogue): Likewise.\n\nFrom-SVN: r41074", "tree": {"sha": "79a81d864652e4c488e5a28d8b18fdb57c97caf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79a81d864652e4c488e5a28d8b18fdb57c97caf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19ec6a367c17e084d0a9165a1d2284eebb0fe311", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19ec6a367c17e084d0a9165a1d2284eebb0fe311", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19ec6a367c17e084d0a9165a1d2284eebb0fe311", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19ec6a367c17e084d0a9165a1d2284eebb0fe311/comments", "author": null, "committer": null, "parents": [{"sha": "78e766a0e18e2815d8125627467e75922402f839", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78e766a0e18e2815d8125627467e75922402f839", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78e766a0e18e2815d8125627467e75922402f839"}], "stats": {"total": 450, "additions": 284, "deletions": 166}, "files": [{"sha": "425e6ce2c781b854690fc35a67717b26b3c57d27", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19ec6a367c17e084d0a9165a1d2284eebb0fe311/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19ec6a367c17e084d0a9165a1d2284eebb0fe311/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=19ec6a367c17e084d0a9165a1d2284eebb0fe311", "patch": "@@ -1,3 +1,21 @@\n+2001-04-04  Alan Modra  <alan@linuxcare.com.au>\n+\n+\t* dwarf2out.c (dwarf2out_frame_debug_expr): Support adjusting\n+\tstack pointer via a LO_SUM.  Ditto for setting a temp register\n+\tused to save to the stack.  Set cfa_temp when setting fp, and\n+\tallow matches to cfa_temp in addition to cfa_store when saving\n+\tregs.  Handle POST_INC and LO_SUM register stores.  Document the\n+\tchanges and errors in rule 12 doco.\n+\n+\t* pa.c (set_reg_plus_d, store_reg, load_reg): Return last insn.\n+\t(actual_fsize, local_fsize, save_fregs): Move for store_reg to see.\n+\t(load_reg): Move closer to epilogue code.\n+\t(DO_FRAME_NOTES): Define to control the following..\n+\t(FRP): Define to set RTX_FRAME_RELATED_P on insns.\n+\t(hppa_expand_prologue): Use FRP and REG_FRAME_RELATED_EXPR\n+\tnotes as necessary.\n+\t(hppa_expand_epilogue): Likewise.\n+\n 2001-04-03  Richard Henderson  <rth@redhat.com>\n \n \t* configure.in (gcc_cv_as_leb128): Reject gas before 2.11."}, {"sha": "2f16c6f085fa3cd5aa6e1820e27bc9c96a0eb096", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 194, "deletions": 121, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19ec6a367c17e084d0a9165a1d2284eebb0fe311/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19ec6a367c17e084d0a9165a1d2284eebb0fe311/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=19ec6a367c17e084d0a9165a1d2284eebb0fe311", "patch": "@@ -42,21 +42,29 @@ Boston, MA 02111-1307, USA.  */\n #include \"recog.h\"\n #include \"tm_p.h\"\n \n+#ifndef DO_FRAME_NOTES\n+#ifdef INCOMING_RETURN_ADDR_RTX\n+#define DO_FRAME_NOTES 1\n+#else\n+#define DO_FRAME_NOTES 0\n+#endif\n+#endif\n+\n static void pa_init_machine_status PARAMS ((struct function *));\n static void pa_mark_machine_status PARAMS ((struct function *));\n static void pa_free_machine_status PARAMS ((struct function *));\n-static void pa_combine_instructions\t\t\tPARAMS ((rtx));\n-static int pa_can_combine_p\tPARAMS ((rtx, rtx, rtx, int, rtx, rtx, rtx));\n-static int forward_branch_p\t\t\t\tPARAMS ((rtx));\n-static int shadd_constant_p\t\t\t\tPARAMS ((int));\n-static void pa_add_gc_roots                             PARAMS ((void));\n-static void mark_deferred_plabels                       PARAMS ((void *));\n-static void compute_zdepwi_operands\t\t\tPARAMS ((unsigned HOST_WIDE_INT, unsigned *));\n-static int compute_movstrsi_length\t\t\tPARAMS ((rtx));\n-static void remove_useless_addtr_insns\t\t\tPARAMS ((rtx, int));\n-static void store_reg\t\t\t\t\tPARAMS ((int, int, int));\n-static void load_reg\t\t\t\t\tPARAMS ((int, int, int));\n-static void set_reg_plus_d\t\t\t\tPARAMS ((int, int, int));\n+static void pa_combine_instructions PARAMS ((rtx));\n+static int pa_can_combine_p PARAMS ((rtx, rtx, rtx, int, rtx, rtx, rtx));\n+static int forward_branch_p PARAMS ((rtx));\n+static int shadd_constant_p PARAMS ((int));\n+static void pa_add_gc_roots PARAMS ((void));\n+static void mark_deferred_plabels PARAMS ((void *));\n+static void compute_zdepwi_operands PARAMS ((unsigned HOST_WIDE_INT, unsigned *));\n+static int compute_movstrsi_length PARAMS ((rtx));\n+static void remove_useless_addtr_insns PARAMS ((rtx, int));\n+static rtx store_reg PARAMS ((int, int, int));\n+static rtx load_reg PARAMS ((int, int, int));\n+static rtx set_reg_plus_d PARAMS ((int, int, int));\n \n /* Save the operands last given to a compare for use when we\n    generate a scc or bcc insn.  */\n@@ -2003,7 +2011,6 @@ output_move_double (operands)\n \t\t\t       xoperands);\n \t      return \"ldw 0(%R0),%0\\n\\tldw 4(%R0),%R0\";\n \t    }\n-\t   \n \t}\n     }\n \n@@ -2743,60 +2750,41 @@ remove_useless_addtr_insns (insns, check_notes)\n \n */\n \n+/* Global variables set by FUNCTION_PROLOGUE.  */\n+/* Size of frame.  Need to know this to emit return insns from\n+   leaf procedures.  */\n+static int actual_fsize;\n+static int local_fsize, save_fregs;\n+\n /* Emit RTL to store REG at the memory location specified by BASE+DISP.\n    Handle case where DISP > 8k by using the add_high_const patterns.\n \n    Note in DISP > 8k case, we will leave the high part of the address\n    in %r1.  There is code in expand_hppa_{prologue,epilogue} that knows this.*/\n \n-static void\n+static rtx\n store_reg (reg, disp, base)\n      int reg, disp, base;\n {\n+  rtx i, dest, src, basereg;\n+\n+  src = gen_rtx_REG (word_mode, reg);\n+  basereg = gen_rtx_REG (Pmode, base);\n   if (VAL_14_BITS_P (disp))\n-    emit_move_insn (gen_rtx_MEM (word_mode,\n-\t\t\t\t plus_constant (gen_rtx_REG (Pmode, base),\n-\t\t\t\t\t\tdisp)),\n-\t\t    gen_rtx_REG (word_mode, reg));\n-  else\n     {\n-      emit_move_insn (gen_rtx_REG (Pmode, 1),\n-\t\t      gen_rtx_PLUS (Pmode, gen_rtx_REG (Pmode, base),\n-\t\t\t\t    gen_rtx_HIGH (Pmode, GEN_INT (disp))));\n-      emit_move_insn (gen_rtx_MEM (word_mode,\n-\t\t\t\t   gen_rtx_LO_SUM (Pmode,\n-\t\t\t\t\t\t   gen_rtx_REG (Pmode, 1),\n-\t\t\t\t\t\t   GEN_INT (disp))),\n-\t\t      gen_rtx_REG (word_mode, reg));\n+      dest = gen_rtx_MEM (word_mode, plus_constant (basereg, disp));\n+      i = emit_move_insn (dest, src);\n     }\n-}\n-\n-/* Emit RTL to load REG from the memory location specified by BASE+DISP.\n-   Handle case where DISP > 8k by using the add_high_const patterns.\n-\n-   Note in DISP > 8k case, we will leave the high part of the address\n-   in %r1.  There is code in expand_hppa_{prologue,epilogue} that knows this.*/\n-\n-static void\n-load_reg (reg, disp, base)\n-     int reg, disp, base;\n-{\n-  if (VAL_14_BITS_P (disp))\n-    emit_move_insn (gen_rtx_REG (word_mode, reg),\n-\t\t    gen_rtx_MEM (word_mode,\n-\t\t\t\t plus_constant (gen_rtx_REG (Pmode, base),\n-\t\t\t\t\t\tdisp)));\n   else\n     {\n-      emit_move_insn (gen_rtx_REG (Pmode, 1),\n-\t\t      gen_rtx_PLUS (Pmode, gen_rtx_REG (Pmode, base),\n-\t\t\t\t    gen_rtx_HIGH (Pmode, GEN_INT (disp))));\n-      emit_move_insn (gen_rtx_REG (word_mode, reg),\n-\t\t      gen_rtx_MEM (word_mode,\n-\t\t\t\t   gen_rtx_LO_SUM (Pmode,\n-\t\t\t\t\t\t   gen_rtx_REG (Pmode, 1),\n-\t\t\t\t\t\t   GEN_INT (disp))));\n+      rtx delta = GEN_INT (disp);\n+      rtx high = gen_rtx_PLUS (Pmode, basereg, gen_rtx_HIGH (Pmode, delta));\n+      rtx tmpreg = gen_rtx_REG (Pmode, 1);\n+      emit_move_insn (tmpreg, high);\n+      dest = gen_rtx_MEM (word_mode, gen_rtx_LO_SUM (Pmode, tmpreg, delta));\n+      i = emit_move_insn (dest, src);\n     }\n+  return i;\n }\n \n /* Emit RTL to set REG to the value specified by BASE+DISP.\n@@ -2805,31 +2793,30 @@ load_reg (reg, disp, base)\n    Note in DISP > 8k case, we will leave the high part of the address\n    in %r1.  There is code in expand_hppa_{prologue,epilogue} that knows this.*/\n \n-static void\n+static rtx\n set_reg_plus_d (reg, base, disp)\n      int reg, base, disp;\n {\n+  rtx i;\n+\n   if (VAL_14_BITS_P (disp))\n-    emit_move_insn (gen_rtx_REG (Pmode, reg),\n-\t\t    plus_constant (gen_rtx_REG (Pmode, base), disp));\n+    {\n+      i = emit_move_insn (gen_rtx_REG (Pmode, reg),\n+\t\t\t  plus_constant (gen_rtx_REG (Pmode, base), disp));\n+    }\n   else\n     {\n+      rtx delta = GEN_INT (disp);\n       emit_move_insn (gen_rtx_REG (Pmode, 1),\n \t\t      gen_rtx_PLUS (Pmode, gen_rtx_REG (Pmode, base),\n-\t\t\t\t    gen_rtx_HIGH (Pmode, GEN_INT (disp))));\n-      emit_move_insn (gen_rtx_REG (Pmode, reg),\n-\t\t      gen_rtx_LO_SUM (Pmode,\n-\t\t\t\t      gen_rtx_REG (Pmode, 1),\n-\t\t\t\t       GEN_INT (disp)));\n+\t\t\t\t    gen_rtx_HIGH (Pmode, delta)));\n+      i = emit_move_insn (gen_rtx_REG (Pmode, reg),\n+\t\t\t  gen_rtx_LO_SUM (Pmode, gen_rtx_REG (Pmode, 1),\n+\t\t\t\t\t  delta));\n     }\n+  return i;\n }\n \n-/* Global variables set by FUNCTION_PROLOGUE.  */\n-/* Size of frame.  Need to know this to emit return insns from\n-   leaf procedures.  */\n-static int actual_fsize;\n-static int local_fsize, save_fregs;\n-\n int\n compute_frame_size (size, fregs_live)\n      int size;\n@@ -2937,8 +2924,20 @@ output_function_prologue (file, size)\n   remove_useless_addtr_insns (get_insns (), 0);\n }\n \n+#if DO_FRAME_NOTES\n+#define FRP(INSN) \\\n+  do\t\t\t\t\t\\\n+    {\t\t\t\t\t\\\n+      rtx insn = INSN;\t\t\t\\\n+      RTX_FRAME_RELATED_P (insn) = 1;\t\\\n+    }\t\t\t\t\t\\\n+  while (0)\n+#else\n+#define FRP (INSN) INSN\n+#endif\n+\n void\n-hppa_expand_prologue()\n+hppa_expand_prologue ()\n {\n   extern char call_used_regs[];\n   int size = get_frame_size ();\n@@ -2965,10 +2964,10 @@ hppa_expand_prologue()\n   size_rtx = GEN_INT (actual_fsize);\n \n   /* Save RP first.  The calling conventions manual states RP will\n-     always be stored into the caller's frame at sp-20 or sp - 16\n+     always be stored into the caller's frame at sp - 20 or sp - 16\n      depending on which ABI is in use.  */\n   if (regs_ever_live[2])\n-    store_reg (2, TARGET_64BIT ? -16 : -20, STACK_POINTER_REGNUM);\n+    FRP (store_reg (2, TARGET_64BIT ? -16 : -20, STACK_POINTER_REGNUM));\n \n   /* Allocate the local frame and set up the frame pointer if needed.  */\n   if (actual_fsize != 0)\n@@ -2982,9 +2981,31 @@ hppa_expand_prologue()\n \t     handles small (<8k) frames.  The second handles large (>=8k)\n \t     frames.  */\n \t  emit_move_insn (tmpreg, frame_pointer_rtx);\n-\t  emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n+\t  FRP (emit_move_insn (frame_pointer_rtx, stack_pointer_rtx));\n \t  if (VAL_14_BITS_P (actual_fsize))\n-\t    emit_insn (gen_post_store (stack_pointer_rtx, tmpreg, size_rtx));\n+\t    {\n+\t      rtx insn = emit_insn (gen_post_store (stack_pointer_rtx, tmpreg,\n+\t\t\t\t\t\t    size_rtx));\n+\t      if (DO_FRAME_NOTES)\n+\t\t{\n+\t\t  rtvec vec;\n+\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t  vec = gen_rtvec (2,\n+\t\t\t\t   gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t\tgen_rtx_MEM (word_mode,\n+\t\t\t\t\t\t\t     stack_pointer_rtx),\n+\t\t\t\t\t\tframe_pointer_rtx),\n+\t\t\t\t   gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\t\tgen_rtx_PLUS (word_mode,\n+\t\t\t\t\t\t\t      stack_pointer_rtx,\n+\t\t\t\t\t\t\t      size_rtx)));\n+\t\t  REG_NOTES (insn)\n+\t\t    = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\t\t\t\t gen_rtx_SEQUENCE (VOIDmode, vec),\n+\t\t\t\t\t REG_NOTES (insn));\n+\t\t}\n+\t    }\n \t  else\n \t    {\n \t      /* It is incorrect to store the saved frame pointer at *sp,\n@@ -2996,10 +3017,31 @@ hppa_expand_prologue()\n \t      int adjust1 = 8192 - 64;\n \t      int adjust2 = actual_fsize - adjust1;\n \t      rtx delta = GEN_INT (adjust1);\n-\t      emit_insn (gen_post_store (stack_pointer_rtx, tmpreg, delta));\n-\t      set_reg_plus_d (STACK_POINTER_REGNUM,\n-\t\t\t      STACK_POINTER_REGNUM,\n-\t\t\t      adjust2);\n+\t      rtx insn = emit_insn (gen_post_store (stack_pointer_rtx, tmpreg,\n+\t\t\t\t\t\t    delta));\n+\t      if (DO_FRAME_NOTES)\n+\t\t{\n+\t\t  rtvec vec;\n+\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t  vec = gen_rtvec (2,\n+\t\t\t\t   gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t\tgen_rtx_MEM (word_mode,\n+\t\t\t\t\t\t\t     stack_pointer_rtx),\n+\t\t\t\t\t\tframe_pointer_rtx),\n+\t\t\t\t   gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\t\tgen_rtx_PLUS (word_mode,\n+\t\t\t\t\t\t\t      stack_pointer_rtx,\n+\t\t\t\t\t\t\t      delta)));\n+\t\t  REG_NOTES (insn)\n+\t\t    = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\t\t\t\t gen_rtx_SEQUENCE (VOIDmode, vec),\n+\t\t\t\t\t REG_NOTES (insn));\n+\t\t}\n+\n+\t      FRP (set_reg_plus_d (STACK_POINTER_REGNUM,\n+\t\t\t\t   STACK_POINTER_REGNUM,\n+\t\t\t\t   adjust2));\n \t    }\n \t  /* Prevent register spills from being scheduled before the\n \t     stack pointer is raised.  Necessary as we will be storing\n@@ -3019,9 +3061,9 @@ hppa_expand_prologue()\n \t  /* Can not optimize.  Adjust the stack frame by actual_fsize\n \t     bytes.  */\n \t  else\n-\t    set_reg_plus_d (STACK_POINTER_REGNUM,\n-\t\t\t    STACK_POINTER_REGNUM,\n-\t\t\t    actual_fsize);\n+\t    FRP (set_reg_plus_d (STACK_POINTER_REGNUM,\n+\t\t\t\t STACK_POINTER_REGNUM,\n+\t\t\t\t actual_fsize));\n \t}\n     }\n \n@@ -3034,7 +3076,7 @@ hppa_expand_prologue()\n       for (i = 18, offset = local_fsize; i >= 4; i--)\n \tif (regs_ever_live[i] && ! call_used_regs[i])\n \t  {\n-\t    store_reg (i, offset, FRAME_POINTER_REGNUM);\n+\t    FRP (store_reg (i, offset, FRAME_POINTER_REGNUM));\n \t    offset += UNITS_PER_WORD;\n \t    gr_saved++;\n \t  }\n@@ -3051,23 +3093,24 @@ hppa_expand_prologue()\n \t       optimize the first GR save.  */\n \t    if (merge_sp_adjust_with_store)\n \t      {\n+\t\trtx delta = GEN_INT (-offset);\n \t\tmerge_sp_adjust_with_store = 0;\n-\t        emit_insn (gen_post_store (stack_pointer_rtx,\n-\t\t\t\t\t   gen_rtx_REG (word_mode, i),\n-\t\t\t\t\t   GEN_INT (-offset)));\n+\t        FRP (emit_insn (gen_post_store (stack_pointer_rtx,\n+\t\t\t\t\t\tgen_rtx_REG (word_mode, i),\n+\t\t\t\t\t\tdelta)));\n \t      }\n \t    else\n-\t      store_reg (i, offset, STACK_POINTER_REGNUM);\n+\t      FRP (store_reg (i, offset, STACK_POINTER_REGNUM));\n \t    offset += UNITS_PER_WORD;\n \t    gr_saved++;\n \t  }\n \n       /* If we wanted to merge the SP adjustment with a GR save, but we never\n \t did any GR saves, then just emit the adjustment here.  */\n       if (merge_sp_adjust_with_store)\n-\tset_reg_plus_d (STACK_POINTER_REGNUM,\n-\t\t\tSTACK_POINTER_REGNUM,\n-\t\t\tactual_fsize);\n+\tFRP (set_reg_plus_d (STACK_POINTER_REGNUM,\n+\t\t\t     STACK_POINTER_REGNUM,\n+\t\t\t     actual_fsize));\n     }\n \n   /* The hppa calling conventions say that %r19, the pic offset\n@@ -3088,25 +3131,59 @@ hppa_expand_prologue()\n       /* First get the frame or stack pointer to the start of the FP register\n \t save area.  */\n       if (frame_pointer_needed)\n-\tset_reg_plus_d (1, FRAME_POINTER_REGNUM, offset);\n+\tFRP (set_reg_plus_d (1, FRAME_POINTER_REGNUM, offset));\n       else\n-\tset_reg_plus_d (1, STACK_POINTER_REGNUM, offset);\n+\tFRP (set_reg_plus_d (1, STACK_POINTER_REGNUM, offset));\n \n       /* Now actually save the FP registers.  */\n       for (i = FP_SAVED_REG_LAST; i >= FP_SAVED_REG_FIRST; i -= FP_REG_STEP)\n \t{\n \t  if (regs_ever_live[i]\n \t      || (! TARGET_64BIT && regs_ever_live[i + 1]))\n \t    {\n-\t      emit_move_insn (gen_rtx_MEM (DFmode,\n-\t\t\t\t           gen_rtx_POST_INC (DFmode, tmpreg)),\n-\t\t\t      gen_rtx_REG (DFmode, i));\n+\t      rtx addr, reg;\n+\t      addr = gen_rtx_MEM (DFmode, gen_rtx_POST_INC (DFmode, tmpreg));\n+\t      reg = gen_rtx_REG (DFmode, i);\n+\t      FRP (emit_move_insn (addr, reg));\n \t      fr_saved++;\n \t    }\n \t}\n     }\n }\n \n+/* ?!? Do we want frame notes in the epilogue yet?  */\n+#undef DO_FRAME_NOTES\n+#define DO_FRAME_NOTES 0\n+#undef FRP\n+#define FRP(INSN) INSN\n+\n+/* Emit RTL to load REG from the memory location specified by BASE+DISP.\n+   Handle case where DISP > 8k by using the add_high_const patterns.  */\n+\n+static rtx\n+load_reg (reg, disp, base)\n+     int reg, disp, base;\n+{\n+  rtx i, src, dest, basereg;\n+\n+  dest = gen_rtx_REG (word_mode, reg);\n+  basereg = gen_rtx_REG (Pmode, base);\n+  if (VAL_14_BITS_P (disp))\n+    {\n+      src = gen_rtx_MEM (word_mode, plus_constant (basereg, disp));\n+      i = emit_move_insn (dest, src);\n+    }\n+  else\n+    {\n+      rtx delta = GEN_INT (disp);\n+      rtx high = gen_rtx_PLUS (Pmode, basereg, gen_rtx_HIGH (Pmode, delta));\n+      rtx tmpreg = gen_rtx_REG (Pmode, 1);\n+      emit_move_insn (tmpreg, high);\n+      src = gen_rtx_MEM (word_mode, gen_rtx_LO_SUM (Pmode, tmpreg, delta));\n+      i = emit_move_insn (dest, src);\n+    }\n+  return i;\n+}\n \n void\n output_function_epilogue (file, size)\n@@ -3159,15 +3236,15 @@ hppa_expand_epilogue ()\n       ret_off = TARGET_64BIT ? -16 : -20;\n       if (frame_pointer_needed)\n \t{\n-\t  load_reg (2, ret_off, FRAME_POINTER_REGNUM);\n+\t  FRP (load_reg (2, ret_off, FRAME_POINTER_REGNUM));\n \t  ret_off = 0;\n \t}\n       else\n \t{\n \t  /* No frame pointer, and stack is smaller than 8k.  */\n \t  if (VAL_14_BITS_P (ret_off - actual_fsize))\n \t    {\n-\t      load_reg (2, ret_off - actual_fsize, STACK_POINTER_REGNUM);\n+\t      FRP (load_reg (2, ret_off - actual_fsize, STACK_POINTER_REGNUM));\n \t      ret_off = 0;\n \t    }\n \t}\n@@ -3179,7 +3256,7 @@ hppa_expand_epilogue ()\n       for (i = 18, offset = local_fsize; i >= 4; i--)\n \tif (regs_ever_live[i] && ! call_used_regs[i])\n \t  {\n-\t    load_reg (i, offset, FRAME_POINTER_REGNUM);\n+\t    FRP (load_reg (i, offset, FRAME_POINTER_REGNUM));\n \t    offset += UNITS_PER_WORD;\n \t  }\n     }\n@@ -3197,7 +3274,7 @@ hppa_expand_epilogue ()\n \t\t  && VAL_14_BITS_P (-actual_fsize))\n \t        merge_sp_adjust_with_load = i;\n \t      else\n-\t        load_reg (i, offset, STACK_POINTER_REGNUM);\n+\t\tFRP (load_reg (i, offset, STACK_POINTER_REGNUM));\n \t      offset += UNITS_PER_WORD;\n \t    }\n \t}\n@@ -3211,21 +3288,19 @@ hppa_expand_epilogue ()\n     {\n       /* Adjust the register to index off of.  */\n       if (frame_pointer_needed)\n-\tset_reg_plus_d (1, FRAME_POINTER_REGNUM, offset);\n+\tFRP (set_reg_plus_d (1, FRAME_POINTER_REGNUM, offset));\n       else\n-\tset_reg_plus_d (1, STACK_POINTER_REGNUM, offset);\n+\tFRP (set_reg_plus_d (1, STACK_POINTER_REGNUM, offset));\n \n       /* Actually do the restores now.  */\n       for (i = FP_SAVED_REG_LAST; i >= FP_SAVED_REG_FIRST; i -= FP_REG_STEP)\n-\t{\n-\t  if (regs_ever_live[i]\n-\t      || (! TARGET_64BIT && regs_ever_live[i + 1]))\n-\t    {\n-\t      emit_move_insn (gen_rtx_REG (DFmode, i),\n-\t\t\t      gen_rtx_MEM (DFmode,\n-\t\t\t\t           gen_rtx_POST_INC (DFmode, tmpreg)));\n-\t    }\n-\t}\n+\tif (regs_ever_live[i]\n+\t    || (! TARGET_64BIT && regs_ever_live[i + 1]))\n+\t  {\n+\t    rtx src = gen_rtx_MEM (DFmode, gen_rtx_POST_INC (DFmode, tmpreg));\n+\t    rtx dest = gen_rtx_REG (DFmode, i);\n+\t    FRP (emit_move_insn (dest, src));\n+\t  }\n     }\n \n   /* Emit a blockage insn here to keep these insns from being moved to\n@@ -3239,35 +3314,33 @@ hppa_expand_epilogue ()\n      pointer is initially set to fp + 64 to avoid a race condition.  */\n   if (frame_pointer_needed)\n     {\n-      set_reg_plus_d (STACK_POINTER_REGNUM, FRAME_POINTER_REGNUM, 64);\n-      emit_insn (gen_pre_load (frame_pointer_rtx, \n-\t\t\t       stack_pointer_rtx,\n-\t\t\t       GEN_INT (-64)));\n+      rtx delta = GEN_INT (-64);\n+      FRP (set_reg_plus_d (STACK_POINTER_REGNUM, FRAME_POINTER_REGNUM, 64));\n+      FRP (emit_insn (gen_pre_load (frame_pointer_rtx, \n+\t\t\t\t    stack_pointer_rtx,\n+\t\t\t\t    delta)));\n     }\n   /* If we were deferring a callee register restore, do it now.  */\n   else if (merge_sp_adjust_with_load)\n     {\n       rtx delta = GEN_INT (-actual_fsize);\n-      emit_insn (gen_pre_load (gen_rtx_REG (word_mode,\n-\t\t\t\t\t    merge_sp_adjust_with_load),\n-\t\t\t       stack_pointer_rtx,\n-\t\t\t       delta));\n+      rtx dest = gen_rtx_REG (word_mode, merge_sp_adjust_with_load);\n+      FRP (emit_insn (gen_pre_load (dest, stack_pointer_rtx, delta)));\n     }\n   else if (actual_fsize != 0)\n-    {\n-      set_reg_plus_d (STACK_POINTER_REGNUM,\n-\t\t      STACK_POINTER_REGNUM,\n-\t\t      - actual_fsize);\n-    }\n+    FRP (set_reg_plus_d (STACK_POINTER_REGNUM,\n+\t\t\t STACK_POINTER_REGNUM,\n+\t\t\t - actual_fsize));\n \n   /* If we haven't restored %r2 yet (no frame pointer, and a stack\n      frame greater than 8k), do so now.  */\n   if (ret_off != 0)\n-    load_reg (2, ret_off, STACK_POINTER_REGNUM);\n+    FRP (load_reg (2, ret_off, STACK_POINTER_REGNUM));\n }\n \n /* Set up a callee saved register for the pic offset table register.  */\n-void hppa_init_pic_save ()\n+void\n+hppa_init_pic_save ()\n {\n   rtx insn, picreg;\n "}, {"sha": "f93e42d7a9dbca767b479da6285d7c342bbea2ca", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 72, "deletions": 45, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19ec6a367c17e084d0a9165a1d2284eebb0fe311/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19ec6a367c17e084d0a9165a1d2284eebb0fe311/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=19ec6a367c17e084d0a9165a1d2284eebb0fe311", "patch": "@@ -1133,11 +1133,13 @@ static dw_cfa_location cfa_temp;\n \t       cfa_store.reg to the actual CFA\n   cfa_temp     register holding an integral value.  cfa_temp.offset\n \t       stores the value, which will be used to adjust the\n-\t       stack pointer.\n+\t       stack pointer.  cfa_temp is also used like cfa_store,\n+\t       to track stores to the stack via fp or a temp reg.\n  \n   Rules  1- 4: Setting a register's value to cfa.reg or an expression\n   \t       with cfa.reg as the first operand changes the cfa.reg and its\n-\t       cfa.offset.\n+\t       cfa.offset.  Rule 1 and 4 also set cfa_temp.reg and\n+\t       cfa_temp.offset.\n \n   Rules  6- 9: Set a non-cfa.reg register value to a constant or an\n \t       expression yielding a constant.  This sets cfa_temp.reg\n@@ -1146,9 +1148,9 @@ static dw_cfa_location cfa_temp;\n   Rule 5:      Create a new register cfa_store used to save items to the\n \t       stack.\n \n-  Rules 10-13: Save a register to the stack.  Define offset as the\n+  Rules 10-14: Save a register to the stack.  Define offset as the\n \t       difference of the original location and cfa_store's\n-\t       location.\n+\t       location (or cfa_temp's location if cfa_temp is used).\n \n   The Rules\n \n@@ -1157,26 +1159,30 @@ static dw_cfa_location cfa_temp;\n \n   Rule 1:\n   (set <reg1> <reg2>:cfa.reg)\n-  effects: cfa.reg = <REG1>\n+  effects: cfa.reg = <reg1>\n            cfa.offset unchanged\n+\t   cfa_temp.reg = <reg1>\n+\t   cfa_temp.offset = cfa.offset\n \n   Rule 2:\n-  (set sp ({minus,plus} {sp,fp}:cfa.reg {<const_int>,<reg>:cfa_temp.reg}))\n+  (set sp ({minus,plus,losum} {sp,fp}:cfa.reg {<const_int>,<reg>:cfa_temp.reg}))\n   effects: cfa.reg = sp if fp used\n  \t   cfa.offset += {+/- <const_int>, cfa_temp.offset} if cfa.reg==sp\n \t   cfa_store.offset += {+/- <const_int>, cfa_temp.offset}\n \t     if cfa_store.reg==sp\n \n   Rule 3:\n-  (set fp ({minus,plus} <reg>:cfa.reg <const_int>))\n+  (set fp ({minus,plus,losum} <reg>:cfa.reg <const_int>))\n   effects: cfa.reg = fp\n   \t   cfa_offset += +/- <const_int>\n \n   Rule 4:\n-  (set <reg1> (plus <reg2>:cfa.reg <const_int>))\n+  (set <reg1> ({plus,losum} <reg2>:cfa.reg <const_int>))\n   constraints: <reg1> != fp\n   \t       <reg1> != sp\n   effects: cfa.reg = <reg1>\n+\t   cfa_temp.reg = <reg1>\n+\t   cfa_temp.offset = cfa.offset\n \n   Rule 5:\n   (set <reg1> (plus <reg2>:cfa_temp.reg sp:cfa.reg))\n@@ -1208,30 +1214,31 @@ static dw_cfa_location cfa_temp;\n   (set (mem (pre_modify sp:cfa_store (???? <reg1> <const_int>))) <reg2>)\n   effects: cfa_store.offset -= <const_int>\n \t   cfa.offset = cfa_store.offset if cfa.reg == sp\n-\t   offset = -cfa_store.offset\n \t   cfa.reg = sp\n-\t   cfa.base_offset = offset\n+\t   cfa.base_offset = -cfa_store.offset\n \n   Rule 11:\n   (set (mem ({pre_inc,pre_dec} sp:cfa_store.reg)) <reg>)\n   effects: cfa_store.offset += -/+ mode_size(mem)\n \t   cfa.offset = cfa_store.offset if cfa.reg == sp\n-\t   offset = -cfa_store.offset\n \t   cfa.reg = sp\n-\t   cfa.base_offset = offset\n+\t   cfa.base_offset = -cfa_store.offset\n \n   Rule 12:\n-  (set (mem ({minus,plus} <reg1>:cfa_store <const_int>)) <reg2>)\n-  effects: cfa_store.offset += -/+ <const_int>\n-\t   offset = -cfa_store.offset\n-\t   cfa.reg = <reg1\n-\t   cfa.base_offset = offset\n+  (set (mem ({minus,plus,losum} <reg1>:{cfa_store,cfa_temp} <const_int>)) <reg2>)\n+  effects: cfa.reg = <reg1>\n+\t   cfa.base_offset = -/+ <const_int> - {cfa_store,cfa_temp}.offset\n \n   Rule 13:\n-  (set (mem <reg1>:cfa_store) <reg2>)\n-  effects: offset = -cfa_store.offset\n-\t   cfa.reg = <reg1>\n-\t   cfa.base_offset = offset */\n+  (set (mem <reg1>:{cfa_store,cfa_temp}) <reg2>)\n+  effects: cfa.reg = <reg1>\n+\t   cfa.base_offset = -{cfa_store,cfa_temp}.offset\n+\n+  Rule 14:\n+  (set (mem (postinc <reg1>:cfa_temp <const_int>)) <reg2>)\n+  effects: cfa.reg = <reg1>\n+\t   cfa.base_offset = -cfa_temp.offset\n+\t   cfa_temp.offset -= mode_size(mem)  */\n \n static void\n dwarf2out_frame_debug_expr (expr, label)\n@@ -1291,10 +1298,13 @@ dwarf2out_frame_debug_expr (expr, label)\n \t     FP.  So we just rely on the backends to only set\n \t     RTX_FRAME_RELATED_P on appropriate insns.  */\n \t  cfa.reg = REGNO (dest);\n+\t  cfa_temp.reg = cfa.reg;\n+\t  cfa_temp.offset = cfa.offset;\n \t  break;\n \n \tcase PLUS:\n \tcase MINUS:\n+\tcase LO_SUM:\n \t  if (dest == stack_pointer_rtx)\n \t    {\n \t      /* Rule 2 */\n@@ -1320,10 +1330,13 @@ dwarf2out_frame_debug_expr (expr, label)\n \t\t    abort ();\n \t\t  cfa.reg = STACK_POINTER_REGNUM;\n \t\t}\n+\t      else if (GET_CODE (src) == LO_SUM)\n+\t\t/* Assume we've set the source reg of the LO_SUM from sp.  */\n+\t\t;\n \t      else if (XEXP (src, 0) != stack_pointer_rtx)\n \t\tabort ();\n \n-\t      if (GET_CODE (src) == PLUS)\n+\t      if (GET_CODE (src) != MINUS)\n \t\toffset = -offset;\n \t      if (cfa.reg == STACK_POINTER_REGNUM)\n \t\tcfa.offset += offset;\n@@ -1343,7 +1356,7 @@ dwarf2out_frame_debug_expr (expr, label)\n \t\t  && GET_CODE (XEXP (src, 1)) == CONST_INT)\n \t\t{\n \t\t  offset = INTVAL (XEXP (src, 1));\n-\t\t  if (GET_CODE (src) == PLUS)\n+\t\t  if (GET_CODE (src) != MINUS)\n \t\t    offset = -offset;\n \t\t  cfa.offset += offset;\n \t\t  cfa.reg = HARD_FRAME_POINTER_REGNUM;\n@@ -1353,7 +1366,7 @@ dwarf2out_frame_debug_expr (expr, label)\n \t    }\n \t  else\n \t    {\n-\t      if (GET_CODE (src) != PLUS)\n+\t      if (GET_CODE (src) == MINUS)\n \t\tabort ();\n \n \t      /* Rule 4 */\n@@ -1363,27 +1376,34 @@ dwarf2out_frame_debug_expr (expr, label)\n \t\t{\n \t\t  /* Setting a temporary CFA register that will be copied\n \t\t     into the FP later on.  */\n-\t\t  offset = INTVAL (XEXP (src, 1));\n-\t\t  if (GET_CODE (src) == PLUS)\n-\t\t    offset = -offset;\n+\t\t  offset = - INTVAL (XEXP (src, 1));\n \t\t  cfa.offset += offset;\n \t\t  cfa.reg = REGNO (dest);\n+\t\t  /* Or used to save regs to the stack.  */\n+\t\t  cfa_temp.reg = cfa.reg;\n+\t\t  cfa_temp.offset = cfa.offset;\n \t\t}\n \t      /* Rule 5 */\n-\t      else\n+\t      else if (GET_CODE (XEXP (src, 0)) == REG\n+\t\t       && REGNO (XEXP (src, 0)) == cfa_temp.reg\n+\t\t       && XEXP (src, 1) == stack_pointer_rtx)\n \t\t{\n \t\t  /* Setting a scratch register that we will use instead\n \t\t     of SP for saving registers to the stack.  */\n-\t\t  if (XEXP (src, 1) != stack_pointer_rtx)\n-\t\t    abort ();\n-\t\t  if (GET_CODE (XEXP (src, 0)) != REG\n- \t\t      || (unsigned) REGNO (XEXP (src, 0)) != cfa_temp.reg)\n-\t\t    abort ();\n \t\t  if (cfa.reg != STACK_POINTER_REGNUM)\n \t\t    abort ();\n \t\t  cfa_store.reg = REGNO (dest);\n \t\t  cfa_store.offset = cfa.offset - cfa_temp.offset;\n \t\t}\n+\t      /* Rule 9 */\n+\t      else if (GET_CODE (src) == LO_SUM\n+\t\t       && GET_CODE (XEXP (src, 1)) == CONST_INT)\n+\t\t{\n+\t\t  cfa_temp.reg = REGNO (dest);\n+\t\t  cfa_temp.offset = INTVAL (XEXP (src, 1));\n+\t\t}\n+\t      else\n+\t\tabort ();\n \t    }\n \t  break;\n \n@@ -1410,14 +1430,6 @@ dwarf2out_frame_debug_expr (expr, label)\n \tcase HIGH:\n \t  break;\n \n-\t  /* Rule 9 */\n-\tcase LO_SUM:\n-\t  if (GET_CODE (XEXP (src, 1)) != CONST_INT)\n-\t    abort ();\n-\t  cfa_temp.reg = REGNO (dest);\n-\t  cfa_temp.offset = INTVAL (XEXP (src, 1));\n-\t  break;\n-\n \tdefault:\n \t  abort ();\n \t}\n@@ -1470,23 +1482,38 @@ dwarf2out_frame_debug_expr (expr, label)\n \t  /* With an offset.  */\n \tcase PLUS:\n \tcase MINUS:\n+\tcase LO_SUM:\n \t  if (GET_CODE (XEXP (XEXP (dest, 0), 1)) != CONST_INT)\n \t    abort ();\n \t  offset = INTVAL (XEXP (XEXP (dest, 0), 1));\n \t  if (GET_CODE (XEXP (dest, 0)) == MINUS)\n \t    offset = -offset;\n \n-\t  if (cfa_store.reg != (unsigned) REGNO (XEXP (XEXP (dest, 0), 0)))\n+\t  if (cfa_store.reg == (unsigned) REGNO (XEXP (XEXP (dest, 0), 0)))\n+\t    offset -= cfa_store.offset;\n+\t  else if (cfa_temp.reg == (unsigned) REGNO (XEXP (XEXP (dest, 0), 0)))\n+\t    offset -= cfa_temp.offset;\n+\t  else\n \t    abort ();\n-\t  offset -= cfa_store.offset;\n \t  break;\n \n \t  /* Rule 13 */\n \t  /* Without an offset.  */\n \tcase REG:\n-\t  if (cfa_store.reg != (unsigned) REGNO (XEXP (dest, 0)))\n+\t  if (cfa_store.reg == (unsigned) REGNO (XEXP (dest, 0)))\n+\t    offset = -cfa_store.offset;\n+\t  else if (cfa_temp.reg == (unsigned) REGNO (XEXP (dest, 0)))\n+\t    offset = -cfa_temp.offset;\n+\t  else\n \t    abort ();\n-\t  offset = -cfa_store.offset;\n+\t  break;\n+\n+\t  /* Rule 14 */\n+\tcase POST_INC:\n+\t  if (cfa_temp.reg != (unsigned) REGNO (XEXP (XEXP (dest, 0), 0)))\n+\t    abort ();\n+\t  offset = -cfa_temp.offset;\n+\t  cfa_temp.offset -= GET_MODE_SIZE (GET_MODE (dest));\n \t  break;\n \n \tdefault:"}]}