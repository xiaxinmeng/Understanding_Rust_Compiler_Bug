{"sha": "68aed21b05c657635e6a37efe8a992cc8b39883e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhhZWQyMWIwNWM2NTc2MzVlNmEzN2VmZThhOTkyY2M4YjM5ODgzZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-08-26T18:48:21Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-08-26T18:48:21Z"}, "message": "alpha.c (alpha_handle_trap_shadows): Remove do-nothing exit.\n\n        * alpha.c (alpha_handle_trap_shadows): Remove do-nothing exit.\n        Tag trapb and next insn with TImode.\n        (alphaev5_insn_pipe, alphaev5_next_group, alphaev5_align_insns): New.\n        (alpha_reorg): Add conditional for alpha_handle_trap_shadows.\n        Invoke alphaev5_align_insns as appropriate.\n        * alpha.md (attr type): Add multi.\n        (define_asm_attributes): New.\n        (prologue_stack_probe_loop, builtin_setjmp_receiver): Set type multi.\n        (arg_home): Likewise.\n        (fnop, unop, realign): New.\n\nFrom-SVN: r22010", "tree": {"sha": "a1b1bdc9b3978737aba1793850f82ca03dfffd60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1b1bdc9b3978737aba1793850f82ca03dfffd60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68aed21b05c657635e6a37efe8a992cc8b39883e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68aed21b05c657635e6a37efe8a992cc8b39883e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68aed21b05c657635e6a37efe8a992cc8b39883e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68aed21b05c657635e6a37efe8a992cc8b39883e/comments", "author": null, "committer": null, "parents": [{"sha": "4bdc8810f6b2233b34b51c1491d9b70fad203e8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bdc8810f6b2233b34b51c1491d9b70fad203e8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bdc8810f6b2233b34b51c1491d9b70fad203e8d"}], "stats": {"total": 412, "additions": 394, "deletions": 18}, "files": [{"sha": "aef593f10f196aeff99371894aa17acee3695ae7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68aed21b05c657635e6a37efe8a992cc8b39883e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68aed21b05c657635e6a37efe8a992cc8b39883e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68aed21b05c657635e6a37efe8a992cc8b39883e", "patch": "@@ -1,3 +1,22 @@\n+Wed Aug 26 18:38:15 1998  Richard Henderson  <rth@cygnus.com>\n+\n+        * haifa-sched.c (last_clock_var): New.\n+        (schedule_block): Initialize it.\n+        (schedule_insn): Use it to fill insn modes with issue information.\n+\n+\t* alpha.c (alpha_handle_trap_shadows): Remove do-nothing exit.\n+\tTag trapb and next insn with TImode.\n+\t(alphaev5_insn_pipe, alphaev5_next_group, alphaev5_align_insns): New.\n+\t(alpha_reorg): Add conditional for alpha_handle_trap_shadows.\n+\tInvoke alphaev5_align_insns as appropriate.\n+\t* alpha.h (LABEL_ALIGN_AFTER_BARRIER): Was ALIGN_LABEL_AFTER_BARRIER.\n+\t(MD_SCHED_VARIABLE_ISSUE): New.\n+\t* alpha.md (attr type): Add multi.\n+\t(define_asm_attributes): New.\n+\t(prologue_stack_probe_loop, builtin_setjmp_receiver): Set type multi.\n+\t(arg_home): Likewise.\n+\t(fnop, unop, realign): New.\n+\n Wed Aug 26 15:55:41 1998  Jim Wilson  <wilson@cygnus.com>\n \n \t* iris5.h (PREFERRED_DEBUGGING_TYPE): Undef."}, {"sha": "17cab88d8d5345c535ffcb2aab463718a66bcdb9", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 336, "deletions": 7, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68aed21b05c657635e6a37efe8a992cc8b39883e/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68aed21b05c657635e6a37efe8a992cc8b39883e/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=68aed21b05c657635e6a37efe8a992cc8b39883e", "patch": "@@ -1416,7 +1416,7 @@ alpha_emit_conditional_move (cmp, mode)\n       abort ();\n     }\n \n-  /* ??? We mark the the branch mode to be CCmode to prevent the compare\n+  /* ??? We mark the branch mode to be CCmode to prevent the compare\n      and cmov from being combined, since the compare insn follows IEEE\n      rules that the cmov does not.  */\n   if (alpha_compare_fp_p && !flag_fast_math)\n@@ -4090,10 +4090,7 @@ alpha_handle_trap_shadows (insns)\n {\n   struct shadow_summary shadow;\n   int trap_pending, exception_nesting;\n-  rtx i;\n-\n-  if (alpha_tp == ALPHA_TP_PROG && !flag_exceptions)\n-    return;\n+  rtx i, n;\n \n   trap_pending = 0;\n   exception_nesting = 0;\n@@ -4196,7 +4193,9 @@ alpha_handle_trap_shadows (insns)\n \t      else\n \t\t{\n \t\tclose_shadow:\n-\t\t  emit_insn_before (gen_trapb (), i);\n+\t\t  n = emit_insn_before (gen_trapb (), i);\n+\t\t  PUT_MODE (n, TImode);\n+\t\t  PUT_MODE (i, TImode);\n \t\t  trap_pending = 0;\n \t\t  shadow.used.i = 0;\n \t\t  shadow.used.fp = 0;\n@@ -4218,14 +4217,344 @@ alpha_handle_trap_shadows (insns)\n \t}\n     }\n }\n+\f\n+#ifdef HAIFA\n+/* Alpha can only issue instruction groups simultaneously if they are\n+   suitibly aligned.  This is very processor-specific.  */\n+\n+enum alphaev5_pipe {\n+  EV5_STOP = 0,\n+  EV5_NONE = 1,\n+  EV5_E01 = 2,\n+  EV5_E0 = 4,\n+  EV5_E1 = 8,\n+  EV5_FAM = 16,\n+  EV5_FA = 32,\n+  EV5_FM = 64\n+};\n+\n+static enum alphaev5_pipe\n+alphaev5_insn_pipe (insn)\n+     rtx insn;\n+{\n+  if (recog_memoized (insn) < 0)\n+    return EV5_STOP;\n+  if (get_attr_length (insn) != 4)\n+    return EV5_STOP;\n+\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_ILD:\n+    case TYPE_FLD:\n+    case TYPE_LDSYM:\n+    case TYPE_IADD:\n+    case TYPE_ILOG:\n+    case TYPE_ICMOV:\n+    case TYPE_ICMP:\n+      return EV5_E01;\n+\n+    case TYPE_IST:\n+    case TYPE_FST:\n+    case TYPE_SHIFT:\n+    case TYPE_IMUL:\n+    case TYPE_MISC:\n+    case TYPE_MVI:\n+      return EV5_E0;\n+\n+    case TYPE_IBR:\n+    case TYPE_JSR:\n+      return EV5_E1;\n+\n+    case TYPE_FCPYS:\n+      return EV5_FAM;\n+\n+    case TYPE_FBR:\n+    case TYPE_FCMOV:\n+    case TYPE_FADD:\n+    case TYPE_FDIV:\n+      return EV5_FA;\n+\n+    case TYPE_FMUL:\n+      return EV5_FM;\n+    }\n+  abort();\n+}\n+\n+/* IN_USE is a mask of the slots currently filled within the\n+   insn group.  The mask bits come from alphaev5_pipe above.\n+   If EV5_E01 is set, then the insn in EV5_E0 can be swapp\n+   by the hardware into EV5_E1. \n+\n+   LEN is, of course, the length of the group in bytes.  */\n+\n+static rtx\n+alphaev5_next_group (insn, pin_use, plen)\n+     rtx insn;\n+     int *pin_use, *plen;\n+{\n+  int len, in_use;\n+\n+  len = in_use = 0;\n+\n+  if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+    goto next;\n+\n+  do\n+    {\n+      enum alphaev5_pipe pipe;\n+      rtx prev;\n+\n+      pipe = alphaev5_insn_pipe (insn);\n+      switch (pipe)\n+\t{\n+\tcase EV5_STOP:\n+\t  /* Force complex instructions to start new groups.  */\n+\t  if (in_use)\n+\t    goto done;\n+\n+\t  /* If this is a completely unrecognized insn, its an asm.\n+\t     We don't know how long it is, so record length as -1 to\n+\t     signal a needed realignment.  */\n+\t  if (recog_memoized (insn) < 0)\n+\t    len = -1;\n+\t  else\n+\t    len = get_attr_length (insn);\n+\t  goto next;\n+\n+\t/* ??? Most of the places below, we would like to abort, as \n+\t   it would indicate an error either in Haifa, or in the \n+\t   scheduling description.  Unfortunately, Haifa never \n+\t   schedules the last instruction of the BB, so we don't\n+\t   have an accurate TI bit to go off.  */\n+\tcase EV5_E01:\n+\t  if (in_use & EV5_E0)\n+\t    {\n+\t      if (in_use & EV5_E1)\n+\t\tgoto done;\n+\t      in_use |= EV5_E1;\n+\t    }\n+\t  else\n+\t    in_use |= EV5_E0 | EV5_E01;\n+\t  break;\n+\n+\tcase EV5_E0:\n+\t  if (in_use & EV5_E0)\n+\t    {\n+\t      if (!(in_use & EV5_E01) || in_use & EV5_E1)\n+\t\tgoto done;\n+\t      in_use |= EV5_E1;\n+\t    }\n+\t  in_use |= EV5_E0;\n+\t  break;\n+\n+\tcase EV5_E1:\n+\t  if (in_use & EV5_E1)\n+\t    goto done;\n+\t  in_use |= EV5_E1;\n+\t  break;\n+\n+\tcase EV5_FAM:\n+\t  if (in_use & EV5_FA)\n+\t    {\n+\t      if (in_use & EV5_FM)\n+\t\tgoto done;\n+\t      in_use |= EV5_FM;\n+\t    }\n+\t  else\n+\t    in_use |= EV5_FA | EV5_FAM;\n+\t  break;\n+\n+\tcase EV5_FA:\n+\t  if (in_use & EV5_FA)\n+\t    goto done;\n+\t  in_use |= EV5_FA;\n+\t  break;\n+\n+\tcase EV5_FM:\n+\t  if (in_use & EV5_FM)\n+\t    goto done;\n+\t  in_use |= EV5_FM;\n+\t  break;\n+\n+\tcase EV5_NONE:\n+\t  break;\n+\n+\tdefault:\n+\t  abort();\n+\t}\n+      len += 4;\n+      \n+      /* Haifa doesn't do well scheduling branches.  */\n+      /* ??? If this is predicted not-taken, slotting continues, except\n+\t that no more IBR, FBR, or JSR insns may be slotted.  */\n+      if (GET_CODE (insn) == JUMP_INSN)\n+\tgoto next;\n+\n+      insn = next_nonnote_insn (insn);\n+\n+      if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+\tgoto done;\n \n+      /* Let Haifa tell us where it thinks insn group boundaries are.  */\n+      if (GET_MODE (insn) == TImode)\n+\tgoto done;\n+\n+    }\n+  while (insn);\n+\n+ done:\n+  *plen = len;\n+  *pin_use = in_use;\n+  return insn;\n+\n+ next:\n+  insn = next_nonnote_insn (insn);\n+  goto done;\n+}\n+\n+static void\n+alphaev5_align_insns (insns)\n+     rtx insns;\n+{\n+  /* ALIGN is the known alignment for the insn group.  */\n+  int align;\n+  /* OFS is the offset of the current insn in the insn group.  */\n+  int ofs;\n+  int prev_in_use, in_use, len;\n+  rtx i, next;\n+\n+  /* Let shorten branches care for assigning alignments to code labels.  */\n+  shorten_branches (insns);\n+\n+  ofs = prev_in_use = 0;\n+  if (alpha_does_function_need_gp())\n+    {\n+      ofs = 8;\n+      prev_in_use = EV5_E01 | EV5_E0;\n+    }\n+  align = (FUNCTION_BOUNDARY/BITS_PER_UNIT < 16\n+\t   ? FUNCTION_BOUNDARY/BITS_PER_UNIT : 16);\n+\n+  i = insns;\n+  if (GET_CODE (i) == NOTE)\n+    i = next_nonnote_insn (i);\n+\n+  while (i)\n+    {\n+      next = alphaev5_next_group (i, &in_use, &len);\n+\n+      /* When we see a label, resync alignment etc.  */\n+      if (GET_CODE (i) == CODE_LABEL)\n+\t{\n+\t  int new_align = 1 << label_to_alignment (i);\n+\t  if (new_align >= align)\n+\t    {\n+\t      align = new_align < 16 ? new_align : 16;\n+\t      ofs = 0;\n+\t    }\n+\t  else if (ofs & (new_align-1))\n+\t    ofs = (ofs | (new_align-1)) + 1;\n+\t  if (len != 0)\n+\t    abort();\n+\t}\n+\n+      /* Handle complex instructions special.  */\n+      else if (in_use == 0)\n+\t{\n+\t  /* Asms will have length < 0.  This is a signal that we have\n+\t     lost alignment knowledge.  Assume, however, that the asm\n+\t     will not mis-align instructions.  */\n+\t  if (len < 0)\n+\t    {\n+\t      ofs = 0;\n+\t      align = 4;\n+\t      len = 0;\n+\t    }\n+\t}\n+\n+      /* If the known alignment is smaller than the recognized insn group,\n+\t realign the output.  */\n+      else if (align < len)\n+\t{\n+\t  int new_log_align = len > 8 ? 4 : 3;\n+\t  rtx where;\n+\n+\t  where = prev_nonnote_insn (i);\n+\t  if (!where || GET_CODE (where) != CODE_LABEL)\n+\t    where = i;\n+\n+\t  emit_insn_before (gen_realign (GEN_INT (new_log_align)), where);\n+\t  align = 1 << new_log_align;\n+\t  ofs = 0;\n+\t}\n+\n+      /* If the group won't fit in the same INT16 as the previous,\n+\t we need to add padding to keep the group together.  Rather\n+\t than simply leaving the insn filling to the assembler, we\n+\t can make use of the knowledge of what sorts of instructions\n+\t were issued in the previous group to make sure that all of\n+\t the added nops are really free.  */\n+      else if (ofs + len > align)\n+\t{\n+\t  int nop_count = (align - ofs) / 4;\n+\t  rtx where;\n+\n+\t  where = prev_nonnote_insn (i);\n+\t  if (!where || GET_CODE (where) != CODE_LABEL)\n+\t    where = i;\n+\n+\t  do \n+\t    {\n+\t      if (!(prev_in_use & EV5_E1))\n+\t\t{\n+\t\t  prev_in_use |= EV5_E1;\n+\t\t  emit_insn_before (gen_nop(), where);\n+\t\t}\n+\t      else if (TARGET_FP && !(prev_in_use & EV5_FA))\n+\t\t{\n+\t\t  prev_in_use |= EV5_FA;\n+\t\t  emit_insn_before (gen_fnop(), where);\n+\t\t}\n+\t      else if (TARGET_FP && !(prev_in_use & EV5_FM))\n+\t\t{\n+\t\t  prev_in_use |= EV5_FM;\n+\t\t  emit_insn_before (gen_fnop(), where);\n+\t\t}\n+\t      else\n+\t\temit_insn_before (gen_unop(), where);\n+\t    }\n+\t  while (--nop_count);\n+\t  ofs = 0;\n+\t}\n+\n+      ofs = (ofs + len) & (align - 1);\n+      prev_in_use = in_use;\n+      i = next;\n+    }\n+}\n+#endif /* HAIFA */\n+\f\n /* Machine dependant reorg pass.  */\n \n void\n alpha_reorg (insns)\n      rtx insns;\n {\n-  alpha_handle_trap_shadows (insns);\n+  if (alpha_tp != ALPHA_TP_PROG || flag_exceptions)\n+    alpha_handle_trap_shadows (insns);\n+\n+#ifdef HAIFA\n+  /* Due to the number of extra trapb insns, don't bother fixing up\n+     alignment when trap precision is instruction.  Moreover, we can\n+     only do our job when sched2 is run and Haifa is our scheduler.  */\n+  if (optimize && !optimize_size\n+      && alpha_tp != ALPHA_TP_INSN\n+      && flag_schedule_insns_after_reload)\n+    {\n+      if (alpha_cpu == PROCESSOR_EV5)\n+\talphaev5_align_insns (insns);\n+    }\n+#endif\n }\n \n \f"}, {"sha": "89184bf25b3f3b68d73f226d3604f1e7b0aa70e9", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68aed21b05c657635e6a37efe8a992cc8b39883e/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68aed21b05c657635e6a37efe8a992cc8b39883e/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=68aed21b05c657635e6a37efe8a992cc8b39883e", "patch": "@@ -38,6 +38,7 @@\n ;;\t3\tbuiltin_longjmp\n ;;\t4\ttrapb\n ;;\t5\tprologue_stack_probe_loop\n+;;\t6\trealign\n \f\n ;; Processor type -- this attribute must exactly match the processor_type\n ;; enumeration in alpha.h.\n@@ -51,9 +52,13 @@\n ;; separately.\n \n (define_attr \"type\"\n-  \"ild,fld,ldsym,ist,fst,ibr,fbr,jsr,iadd,ilog,shift,icmov,fcmov,icmp,imul,fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof\"\n+  \"ild,fld,ldsym,ist,fst,ibr,fbr,jsr,iadd,ilog,shift,icmov,fcmov,icmp,imul,fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   (const_string \"iadd\"))\n \n+;; Describe a user's asm statement.\n+(define_asm_attributes\n+  [(set_attr \"type\" \"multi\")])\n+\n ;; Define the operand size an insn operates on.  Used primarily by mul\n ;; and div operations that have size dependant timings.\n \n@@ -3833,12 +3838,6 @@\n   \"jmp $31,(%0),0\"\n   [(set_attr \"type\" \"ibr\")])\n \n-(define_insn \"nop\"\n-  [(const_int 0)]\n-  \"\"\n-  \"nop\"\n-  [(set_attr \"type\" \"ilog\")])\n-\n (define_expand \"tablejump\"\n   [(use (match_operand:SI 0 \"register_operand\" \"\"))\n    (use (match_operand:SI 1 \"\" \"\"))]\n@@ -5124,7 +5123,8 @@\n \n   return \\\"\\\";\n }\"\n-  [(set_attr \"length\" \"16\")])\n+  [(set_attr \"length\" \"16\")\n+   (set_attr \"type\" \"multi\")])\n \n (define_expand \"prologue\"\n   [(clobber (const_int 0))]\n@@ -5171,13 +5171,15 @@\n   [(unspec_volatile [(match_operand 0 \"\" \"\")] 2)]\n   \"! TARGET_OPEN_VMS && ! TARGET_WINDOWS_NT && TARGET_AS_CAN_SUBTRACT_LABELS\"\n   \"\\\\n$LSJ%=:\\;ldgp $29,$LSJ%=-%l0($27)\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"multi\")])\n \n (define_insn \"\"\n   [(unspec_volatile [(match_operand 0 \"\" \"\")] 2)]\n   \"! TARGET_OPEN_VMS && ! TARGET_WINDOWS_NT\"\n   \"br $27,$LSJ%=\\\\n$LSJ%=:\\;ldgp $29,0($27)\"\n-  [(set_attr \"length\" \"12\")])\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"type\" \"multi\")])\n \n (define_expand \"nonlocal_goto_receiver\"\n   [(unspec_volatile [(const_int 0)] 1)\n@@ -5209,7 +5211,8 @@\n    (clobber (reg:DI 0))]\n   \"TARGET_OPEN_VMS\"\n   \"lda $0,OTS$HOME_ARGS\\;ldq $0,8($0)\\;jsr $0,OTS$HOME_ARGS\"\n-  [(set_attr \"length\" \"16\")])\n+  [(set_attr \"length\" \"16\")\n+   (set_attr \"type\" \"multi\")])\n \n ;; Close the trap shadow of preceeding instructions.  This is generated\n ;; by alpha_reorg.\n@@ -5219,6 +5222,31 @@\n   \"\"\n   \"trapb\"\n   [(set_attr \"type\" \"misc\")])\n+\n+;; No-op instructions used by machine-dependant reorg to preserve\n+;; alignment for instruction issue.\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\"\n+  [(set_attr \"type\" \"ilog\")])\n+\n+(define_insn \"fnop\"\n+  [(const_int 1)]\n+  \"TARGET_FP\"\n+  \"fnop\"\n+  [(set_attr \"type\" \"fcpys\")])\n+\n+(define_insn \"unop\"\n+  [(const_int 2)]\n+  \"\"\n+  \"unop\")\n+\n+(define_insn \"realign\"\n+  [(unspec_volatile [(match_operand 0 \"immediate_operand\" \"i\")] 6)]\n+  \"\"\n+  \".align %0 #realign\")\n \f\n ;; Peepholes go at the end.\n "}]}