{"sha": "8aaeba8ffac5a59bf1efac5a8cbfe7bd666ec6f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFhZWJhOGZmYWM1YTU5YmYxZWZhYzVhOGNiZmU3YmQ2NjZlYzZmNw==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2009-07-15T10:25:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-15T10:25:24Z"}, "message": "par.adb: Minor reformatting Add ??? comment for possible bad comment\n\n2009-07-15  Robert Dewar  <dewar@adacore.com>\n\n\t* par.adb: Minor reformatting\n\tAdd ??? comment for possible bad comment\n\n\t* par-ch10.adb: Minor reformatting\n\nFrom-SVN: r149677", "tree": {"sha": "9b58e97ad8cdf1400124fc7e605ea44310b71d40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b58e97ad8cdf1400124fc7e605ea44310b71d40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8aaeba8ffac5a59bf1efac5a8cbfe7bd666ec6f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aaeba8ffac5a59bf1efac5a8cbfe7bd666ec6f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8aaeba8ffac5a59bf1efac5a8cbfe7bd666ec6f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aaeba8ffac5a59bf1efac5a8cbfe7bd666ec6f7/comments", "author": null, "committer": null, "parents": [{"sha": "36366047c1b09c1eecc5d5f13c45a4be93db5a20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36366047c1b09c1eecc5d5f13c45a4be93db5a20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36366047c1b09c1eecc5d5f13c45a4be93db5a20"}], "stats": {"total": 149, "additions": 78, "deletions": 71}, "files": [{"sha": "b52756a797c80aafbfbdab407f299223f74c9306", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aaeba8ffac5a59bf1efac5a8cbfe7bd666ec6f7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aaeba8ffac5a59bf1efac5a8cbfe7bd666ec6f7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8aaeba8ffac5a59bf1efac5a8cbfe7bd666ec6f7", "patch": "@@ -1,3 +1,10 @@\n+2009-07-15  Robert Dewar  <dewar@adacore.com>\n+\n+\t* par.adb: Minor reformatting\n+\tAdd ??? comment for possible bad comment\n+\n+\t* par-ch10.adb: Minor reformatting\n+\n 2009-07-15  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_warn.adb (Warn_On_Constant_Condition): if the constant condition\n@@ -29,8 +36,6 @@\n \n 2009-07-15  Robert Dewar  <dewar@adacore.com>\n \n-\t* debug.adb: Add -gnatd.O to output SCO table\n-\n \t* lib-writ.adb (Write_Unit_Information): Use SCO_Output to output SCO\n \tinformation.\n "}, {"sha": "23cb1cd444c90d4addb75d63dc3154546ea889c2", "filename": "gcc/ada/par-ch10.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aaeba8ffac5a59bf1efac5a8cbfe7bd666ec6f7/gcc%2Fada%2Fpar-ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aaeba8ffac5a59bf1efac5a8cbfe7bd666ec6f7/gcc%2Fada%2Fpar-ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch10.adb?ref=8aaeba8ffac5a59bf1efac5a8cbfe7bd666ec6f7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -243,6 +243,7 @@ package body Ch10 is\n       if Token = Tok_Private then\n          Private_Sloc := Token_Ptr;\n          Set_Keyword_Casing (Current_Source_File, Determine_Token_Casing);\n+\n          if Style_Check then\n             Style.Check_Indentation;\n          end if;\n@@ -321,6 +322,7 @@ package body Ch10 is\n       --  it hasn't already been done on seeing a WITH or PRIVATE.\n \n       Set_Keyword_Casing (Current_Source_File, Determine_Token_Casing);\n+\n       if Style_Check then\n          Style.Check_Indentation;\n       end if;\n@@ -1059,7 +1061,6 @@ package body Ch10 is\n \n       Set_Proper_Body  (Subunit_Node, Body_Node);\n       return Subunit_Node;\n-\n    end P_Subunit;\n \n    ------------------"}, {"sha": "6041c63b08bea794e79c4f7dc4c3c66847057bc8", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 68, "deletions": 67, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aaeba8ffac5a59bf1efac5a8cbfe7bd666ec6f7/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aaeba8ffac5a59bf1efac5a8cbfe7bd666ec6f7/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=8aaeba8ffac5a59bf1efac5a8cbfe7bd666ec6f7", "patch": "@@ -197,27 +197,27 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n    -- Handling of Reserved Words Used as Identifiers --\n    ----------------------------------------------------\n \n-   --  Note: throughout the parser, the terms reserved word and keyword\n-   --  are used interchangeably to refer to the same set of reserved\n-   --  keywords (including until, protected, etc).\n+   --  Note: throughout the parser, the terms reserved word and keyword are\n+   --  used interchangeably to refer to the same set of reserved keywords\n+   --  (including until, protected, etc).\n \n-   --  If a reserved word is used in place of an identifier, the parser\n-   --  where possible tries to recover gracefully. In particular, if the\n-   --  keyword is clearly spelled using identifier casing, e.g. Until in\n-   --  a source program using mixed case identifiers and lower case keywords,\n-   --  then the keyword is treated as an identifier if it appears in a place\n-   --  where an identifier is required.\n+   --  If a reserved word is used in place of an identifier, the parser where\n+   --  possible tries to recover gracefully. In particular, if the keyword is\n+   --  clearly spelled using identifier casing, e.g. Until in a source program\n+   --  using mixed case identifiers and lower case keywords, then the keyword\n+   --  is treated as an identifier if it appears in a place where an identifier\n+   --  is required.\n \n    --  The situation is more complex if the keyword is spelled with normal\n-   --  keyword casing. In this case, the parser is more reluctant to\n-   --  consider it to be intended as an identifier, unless it has some\n-   --  further confirmation.\n+   --  keyword casing. In this case, the parser is more reluctant to consider\n+   --  it to be intended as an identifier, unless it has some further\n+   --  confirmation.\n \n    --  In the case of an identifier appearing in the identifier list of a\n-   --  declaration, the appearance of a comma or colon right after the\n-   --  keyword on the same line is taken as confirmation. For an enumeration\n-   --  literal, a comma or right paren right after the identifier is also\n-   --  treated as adequate confirmation.\n+   --  declaration, the appearance of a comma or colon right after the keyword\n+   --  on the same line is taken as confirmation. For an enumeration literal,\n+   --  a comma or right paren right after the identifier is also treated as\n+   --  adequate confirmation.\n \n    --  The following type is used in calls to Is_Reserved_Identifier and\n    --  also to P_Defining_Identifier and P_Identifier. The default for all\n@@ -288,8 +288,8 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n    --  uncomfortably on the above example).\n \n    --  We have two approaches to helping to control this situation. First we\n-   --  make every attempt to avoid swallowing the last END; if we can be\n-   --  sure that some error will result from doing so. In particular, we won't\n+   --  make every attempt to avoid swallowing the last END; if we can be sure\n+   --  that some error will result from doing so. In particular, we won't\n    --  accept the END; unless it is exactly correct (in particular it must not\n    --  have incorrect name tokens), and we won't accept it if it is immediately\n    --  followed by end of file, WITH or SEPARATE (all tokens that unmistakeably\n@@ -409,13 +409,13 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n    -- Scope Table --\n    -----------------\n \n-   --  The scope table, also referred to as the scope stack, is used to\n-   --  record the current scope context. It is organized as a stack, with\n-   --  inner nested entries corresponding to higher entries on the stack.\n-   --  An entry is made when the parser encounters the opening of a nested\n-   --  construct (such as a record, task, package etc.), and then package\n-   --  Par.Endh uses this stack to deal with END lines (including properly\n-   --  dealing with END nesting errors).\n+   --  The scope table, also referred to as the scope stack, is used to record\n+   --  the current scope context. It is organized as a stack, with inner nested\n+   --  entries corresponding to higher entries on the stack. An entry is made\n+   --  when the parser encounters the opening of a nested construct (such as a\n+   --  record, task, package etc.), and then package Par.Endh uses this stack\n+   --  to deal with END lines (including properly dealing with END nesting\n+   --  errors).\n \n    type SS_End_Type is\n    --  Type of end entry required for this scope. The last two entries are\n@@ -446,8 +446,8 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n \n       Lreq : Boolean;\n       --  A flag indicating whether the label, if present, is required to\n-      --  appear on the end line. It is referenced only in the case of\n-      --  Etyp = E_Name or E_Suspicious_Is where the name may or may not be\n+      --  appear on the end line. It is referenced only in the case of Etyp is\n+      --  equal to E_Name or E_Suspicious_Is where the name may or may not be\n       --  required (yes for labeled block, no in other cases). Note that for\n       --  all cases except begin, the question of whether a label is required\n       --  can be determined from the other fields (for loop, it is required if\n@@ -456,10 +456,10 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n \n       Ecol : Column_Number;\n       --  Contains the absolute column number (with tabs expanded) of the\n-      --  the expected column of the end assuming normal Ada indentation\n-      --  usage. If the RM_Column_Check mode is set, this value is used for\n-      --  generating error messages about indentation. Otherwise it is used\n-      --  only to control heuristic error recovery actions.\n+      --  expected column of the end assuming normal Ada indentation usage. If\n+      --  the RM_Column_Check mode is set, this value is used for generating\n+      --  error messages about indentation. Otherwise it is used only to\n+      --  control heuristic error recovery actions.\n \n       Labl : Node_Id;\n       --  This field is used only for the LOOP and BEGIN cases, and is the\n@@ -479,21 +479,21 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  the proper location for implicit label declarations.\n \n       Node : Node_Id;\n-      --  Empty except in the case of entries for IF and CASE statements,\n-      --  in which case it contains the N_If_Statement or N_Case_Statement\n-      --  node. This is used for setting the End_Span field.\n+      --  Empty except in the case of entries for IF and CASE statements, in\n+      --  which case it contains the N_If_Statement or N_Case_Statement node.\n+      --  This is used for setting the End_Span field.\n \n       Sloc : Source_Ptr;\n-      --  Source location of the opening token of the construct. This is\n-      --  used to refer back to this line in error messages (such as missing\n-      --  or incorrect end lines). The Sloc field is not used, and is not set,\n-      --  if a label is present (the Labl field provides the text name of the\n+      --  Source location of the opening token of the construct. This is used\n+      --  to refer back to this line in error messages (such as missing or\n+      --  incorrect end lines). The Sloc field is not used, and is not set, if\n+      --  a label is present (the Labl field provides the text name of the\n       --  label in this case, which is fine for error messages).\n \n       S_Is : Source_Ptr;\n-      --  S_Is is relevant only if Etyp is set to E_Suspicious_Is or\n-      --  E_Bad_Is. It records the location of the IS that is considered\n-      --  to be suspicious.\n+      --  S_Is is relevant only if Etyp is set to E_Suspicious_Is or E_Bad_Is.\n+      --  It records the location of the IS that is considered to be\n+      --  suspicious.\n \n       Junk : Boolean;\n       --  A boolean flag that is set true if the opening entry is the dubious\n@@ -595,10 +595,9 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  removed the ACCESS token\n \n       procedure P_Component_Items (Decls : List_Id);\n-      --  Scan out one or more component items and append them to the\n-      --  given list. Only scans out more than one declaration in the\n-      --  case where the source has a single declaration with multiple\n-      --  defining identifiers.\n+      --  Scan out one or more component items and append them to the given\n+      --  list. Only scans out more than one declaration in the case where the\n+      --  source has a single declaration with multiple defining identifiers.\n \n       function P_Defining_Identifier (C : Id_Check := None) return Node_Id;\n       --  Scan out a defining identifier. The parameter C controls the\n@@ -619,6 +618,7 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n         (Allow_Anonymous_In_95 : Boolean := False) return Boolean;\n       --  Ada 2005 (AI-231): Parse the null-excluding part. A True result\n       --  indicates that the null-excluding part was present.\n+      --\n       --  Allow_Anonymous_In_95 is True if we are in a context that allows\n       --  anonymous access types in Ada 95, in which case \"not null\" is legal\n       --  if it precedes \"access\".\n@@ -730,8 +730,8 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       function P_Subprogram_Specification             return Node_Id;\n \n       procedure P_Mode (Node : Node_Id);\n-      --  Sets In_Present and/or Out_Present flags in Node scanning past\n-      --  IN, OUT or IN OUT tokens in the source.\n+      --  Sets In_Present and/or Out_Present flags in Node scanning past IN,\n+      --  OUT or IN OUT tokens in the source.\n \n       function P_Subprogram (Pf_Flags : Pf_Rec)       return Node_Id;\n       --  Scans out any construct starting with either of the keywords\n@@ -782,19 +782,20 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n \n    package Ch10 is\n       function P_Compilation_Unit                     return Node_Id;\n-      --  Note: this function scans a single compilation unit, and\n-      --  checks that an end of file follows this unit, diagnosing\n-      --  any unexpected input as an error, and then skipping it, so\n-      --  that Token is set to Tok_EOF on return. An exception is in\n-      --  syntax-only mode, where multiple compilation units are\n-      --  permitted. In this case, P_Compilation_Unit does not check\n-      --  for end of file and there may be more compilation units to\n-      --  scan. The caller can uniquely detect this situation by the\n+      --  Note: this function scans a single compilation unit, and checks that\n+      --  an end of file follows this unit, diagnosing any unexpected input as\n+      --  an error, and then skipping it, so that Token is set to Tok_EOF on\n+      --  return. An exception is in syntax-only mode, where multiple\n+      --  compilation units are permitted. In this case, P_Compilation_Unit\n+      --  does not check for end of file and there may be more compilation\n+      --  units to scan. The caller can uniquely detect this situation by the\n       --  fact that Token is not set to Tok_EOF on return.\n       --\n-      --  The Ignore parameter is normally set False. It is set True\n-      --  in multiple unit per file mode if we are skipping past a unit\n-      --  that we are not interested in.\n+      --  What about multiple unit/file capability that now exists???\n+      --\n+      --  The Ignore parameter is normally set False. It is set True in the\n+      --  multiple unit per file mode if we are skipping past a unit that we\n+      --  are not interested in.\n    end Ch10;\n \n    --------------\n@@ -807,8 +808,8 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n \n       function Parse_Exception_Handlers               return List_Id;\n       --  Parses the partial construct EXCEPTION followed by a list of\n-      --  exception handlers which appears in a number of productions,\n-      --  and returns the list of exception handlers.\n+      --  exception handlers which appears in a number of productions, and\n+      --  returns the list of exception handlers.\n    end Ch11;\n \n    --------------\n@@ -920,15 +921,15 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  left pointing to the semicolon rather than past it.\n \n       procedure Resync_Past_Semicolon_Or_To_Loop_Or_Then;\n-      --  Used if an error occurs while scanning a sequence of statements.\n-      --  The scan pointer is positioned past the next semicolon, or to the\n-      --  next occurrence of either then or loop, and the scan resumes.\n+      --  Used if an error occurs while scanning a sequence of statements. The\n+      --  scan pointer is positioned past the next semicolon, or to the next\n+      --  occurrence of either then or loop, and the scan resumes.\n \n       procedure Resync_To_When;\n-      --  Used when an error occurs scanning an entry index specification.\n-      --  The scan pointer is positioned to the next WHEN (or to IS or\n-      --  semicolon if either of these appear before WHEN, indicating\n-      --  another error has occurred).\n+      --  Used when an error occurs scanning an entry index specification. The\n+      --  scan pointer is positioned to the next WHEN (or to IS or semicolon if\n+      --  either of these appear before WHEN, indicating another error has\n+      --  occurred).\n \n       procedure Resync_Semicolon_List;\n       --  Used if an error occurs while scanning a parenthesized list of items"}]}