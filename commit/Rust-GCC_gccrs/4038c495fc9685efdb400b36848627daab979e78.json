{"sha": "4038c495fc9685efdb400b36848627daab979e78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAzOGM0OTVmYzk2ODVlZmRiNDAwYjM2ODQ4NjI3ZGFhYjk3OWU3OA==", "commit": {"author": {"name": "Giovanni Bajo", "email": "giovannibajo@libero.it", "date": "2005-07-20T01:19:59Z"}, "committer": {"name": "Giovanni Bajo", "email": "giovannibajo@gcc.gnu.org", "date": "2005-07-20T01:19:59Z"}, "message": "Make CONSTRUCTOR use VEC to store initializers.\n\n\t* c-common.c (complete_array_type): Update to cope with VEC in\n\tCONSTRUCTOR_ELTS.\n\t* c-pretty-print.c (pp_c_initializer_list): Use pp_c_constructor_elts.\n\t(pp_c_constructor_elts): New function.\n\t* c-pretty-print.h (pp_c_constructor_elts): Declare.\n\t* c-typeck.c (build_function_call, build_c_cast, digest_init,\n\tstruct constructor_stack, struct initializer_stack,\n\tconstructor_elements, push_init_level, pop_init_level,\n\tadd_pending_init, find_init_member, output_init_element): Update to\n\tcope with VEC in CONSTRUCTOR_ELTS.\n\t* coverage.c (build_fn_info_value, build_ctr_info_value,\n\tbuild_gcov_info): Likewise.\n\t* expr.c (categorize_ctor_elements_1, store_constructor,\n\texpand_expr_real_1): Likewise.\n\t* fold-const.c (fold_ternary): Likewise.\n\t* gimplify.c (gimplify_init_ctor_preeval, zero_sized_field_decl,\n\tgimplify_init_constructor, gimplify_expr): Likewise.\n\t* tree-dump.c (dequeue_and_dump): Likewise.\n\t* tree-inline.c (copy_tree_r): Add code to duplicate a CONSTRUCTOR\n\tnode.\n\t* tree-pretty-print.c (dump_generic_node): Update to cope with VEC in\n\tCONSTRUCTOR_ELTS.\n\t* tree-sra.c (generate_element_init_1): Likewise.\n\t* tree-ssa-ccp.c (fold_const_aggregate_ref): Likewise.\n\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n\t* tree-vect-generic.c (expand_vector_piecewise): Likewise.\n\t* tree-vect-transform.c (vect_get_vec_def_for_operand):\n\t(get_initial_def_for_reduction): Likewise.\n\t* tree-vn.c (set_value_handle, get_value_handle): CONSTURCTOR uses\n\tvalue handle in annotations.\n\t* tree.c (tree_node_kind, tree_code_size, make_node_stat,\n\ttree_node_structure): Add support for constr_kind.\n\t(build_vector_from_ctor, build_constructor_single,\n\tbuild_constructor_from_list): New functions.\n\t(build_constructor): Update to take a VEC instead of a TREE_LIST.\n\t(simple_cst_equal, iterative_hash_expr, initializer_zerop, walk_tree):\n\tUpdate to cope with VEC in CONSTRUCTOR_ELTS.\n\t* tree.def (CONSTRUCTOR): Make it a tcc_exceptional node.\n\t* tree.h (FOR_EACH_CONSTRUCTOR_VALUE, FOR_EACH_CONSTRUCTOR_ELT,\n\tCONSTRUCTOR_APPEND_ELT): New macros.\n\t(struct constructor_elt, struct\ttree_constructor): New data types.\n\t(union tree_node): Add tree_constructor field.\n\t* treestruct.def: Define TS_CONSTRUCTOR.\n\t* varasm.c (const_hash_1, compare_constant, copy_constant,\n\tcompute_reloc_for_constant, output_addressed_constants,\n\tinitializer_constant_valid_p, output_constant,\n\tarray_size_for_constructor, output_constructor): Update to cope with\n\tVEC in CONSTRUCTOR_ELTS.\n\t* vec.h (VEC_empty, VEC_copy): New macros.\n\nada/\n\tMake CONSTRUCTOR use VEC to store initializers.\n\t* decl.c (gnat_to_gnu_entity): Update to cope with VEC in\n\tCONSTRUCTOR_ELTS.\n\t* trans.c (extract_values): Likewise.\n\t* utils.c (convert, remove_conversions): Likewise.\n\t* utils2.c (contains_save_expr_p, build_binary_op, build_unary_op,\n\tgnat_build_constructor): Likewise.\n\ncp/\n\tMake CONSTRUCTOR use VEC to store initializers.\n\t* call.c (convert_default_arg): Update call to digest_init.\n\t* class.c (dump_class_hierarchy, dump_array): Update to cope with\n\tVEC in CONSTRUCTOR_ELTS.\n\t* cp-tree.h (EMPTY_CONSTRUCTOR_P): Likewise.\n\t(finish_compound_literal, digest_init): Update declaration.\n\t* decl.c (struct reshape_iter): New data type.\n\t(reshape_init_array): Rename to...\n\t(reshape_init_array_1): Update to cope with VEC in CONSTRUCTOR_ELTS.\n\t(reshape_init): Rewrite from scratch. Split parts into...\n\t(reshape_init_array, reshape_init_vector, reshape_init_class,\n\treshape_init_r): New functions.\n\t(check_initializer): Update call to reshape_init. Remove obsolete\n\tcode.\n\t(initialize_artificial_var, cp_complete_array_type): Update to cope\n\twith VEC in CONSTRUCTOR_ELTS.\n\t* decl2.c (grokfield): Update calls to digest_init.\n\t(mark_vtable_entries): Update to cope with VEC in CONSTRUCTOR_ELTS.\n\t* error.c (dump_expr_init_vec): New function.\n\t(dump_expr): Use dump_expr_init_vec.\n\t* init.c (build_zero_init, build_vec_init): Update to cope with VEC\n\tin CONSTRUCTOR_ELTS.\n\t(expand_default_init): Update call to digest_init.\n\t* parser.c  (cp_parser_postfix_expression): Use a VEC for the\n\tinitializers.\n\t(cp_parser_initializer_list): Build a VEC of initializers.\n\t* pt.c (tsubst_copy, tsubst_copy_and_build): Update to cope with VEC\n\tin CONSTRUCTOR_ELTS.\n\t* rtti.c (tinfo_base_init, generic_initializer, ptr_initializer,\n\tptm_initializer, class_initializer, get_pseudo_ti_init): Use\n\tbuild_constructor_from_list instead of build_constructor.\n\t* semantics.c (finish_compound_literal): Update call to digest_init.\n\t* tree.c (stabilize_init): Update to cope with VEC in\n\tCONSTRUCTOR_ELTS.\n\t* typeck.c (build_ptrmemfunc1): Likewise.\n\t* typeck2.c: (cxx_incomplete_type_error, split_nonconstant_init_1):\n\tLikewise.\n\t(store_init_value): Use build_constructor_from_list and update call\n\tto digest_init.\n\t(digest_init): Rewrite.\n\t(process_init_constructor): Rewrite from scratch. Split into...\n\t(process_init_constructor_array, picflag_from_initializer,\n\tprocess_init_constructor_record, process_init_constructor_union):\n\tNew functions.\n\t(PICFLAG_ERRONEOUS, PICFLAG_NOT_ALL_CONSTANT, PICFLAG_NOT_ALL_SIMPLE):\n\tNew macros.\n\t(build_functional_cast): Use build_constructor_from_list instead of\n\tbuild_constructor.\n\nfortran/\n\tMake CONSTRUCTOR use VEC to store initializers.\n\t* trans-array.c (gfc_build_null_descriptor,\n\tgfc_trans_array_constructor_value, gfc_conv_array_initializer):\n\tUpdate to cope with VEC in CONSTRUCTOR_ELTS.\n\t* trans-common.c (create_common): Likewise.\n\t* trans-expr.c (gfc_conv_structure): Likewise.\n\t* trans-stmt.c (gfc_trans_character_select): Use\n\tbuild_constructor_from_list instead of build_constructor.\n\njava/\n\tMake CONSTRUCTOR use VEC to store initializers.\n\t* check-init.c (check_init): Update to cope with VEC in\n\tCONSTRUCTOR_ELTS.\n\t* class.c (make_field_value, make_method_value, get_dispatch_table,\n\tmake_class_data, emit_symbol_table, emit_catch_table,\n\temit_assertion_table): Use build_constructor_from_list instead of\n\tbuild_constructor.\n\t* constants.c (build_constants_constructor): Likewise.\n\t* java-gimplify.c (java_gimplify_new_array_init): Update to cope with\n\tVEC in CONSTRUCTOR_ELTS.\n\t* java-tree.h (START_RECORD_CONSTRUCTOR, PUSH_SUPER_VALUE,\n\tPUSH_FIELD_VALUE, FINISH_RECORD_CONSTRUCTOR): Create a VEC instead\n\tof a TREE_LIST.\n\t* jcf-write.c (generate_bytecode_insns): Update to cope with VEC in\n\tCONSTRUCTOR_ELTS.\n\t* parse.y (build_new_array_init): Use build_constructor_from_list\n\tinstead of build_constructor.\n\t(patch_new_array_init): Update to cope with VEC in\n\tCONSTRUCTOR_ELTS.\n\t(array_constructor_check_entry): Likewise.\n\nobjc/\n\tMake CONSTRUCTOR use VEC to store initializers.\n\t* objc-act.c (objc_build_constructor): Use build_constructor_from_list\n\tinstead of build_constructor.\n\ntestsuite/\n\tMake CONSTRUCTOR use VEC to store initializers.\n\t* g++.dg/ext/complit3.C: Check for specific error messages.\n\t* g++.dg/init/brace2.C: Update error message.\n\t* g++.dg/warn/Wbraces2.C: Likewise.\n\nFrom-SVN: r102182", "tree": {"sha": "cee4baf52782472c6ce30e28249d2a5df154551f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cee4baf52782472c6ce30e28249d2a5df154551f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4038c495fc9685efdb400b36848627daab979e78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4038c495fc9685efdb400b36848627daab979e78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4038c495fc9685efdb400b36848627daab979e78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4038c495fc9685efdb400b36848627daab979e78/comments", "author": {"login": "rasky", "id": 1014109, "node_id": "MDQ6VXNlcjEwMTQxMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1014109?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rasky", "html_url": "https://github.com/rasky", "followers_url": "https://api.github.com/users/rasky/followers", "following_url": "https://api.github.com/users/rasky/following{/other_user}", "gists_url": "https://api.github.com/users/rasky/gists{/gist_id}", "starred_url": "https://api.github.com/users/rasky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rasky/subscriptions", "organizations_url": "https://api.github.com/users/rasky/orgs", "repos_url": "https://api.github.com/users/rasky/repos", "events_url": "https://api.github.com/users/rasky/events{/privacy}", "received_events_url": "https://api.github.com/users/rasky/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rasky", "id": 1014109, "node_id": "MDQ6VXNlcjEwMTQxMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1014109?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rasky", "html_url": "https://github.com/rasky", "followers_url": "https://api.github.com/users/rasky/followers", "following_url": "https://api.github.com/users/rasky/following{/other_user}", "gists_url": "https://api.github.com/users/rasky/gists{/gist_id}", "starred_url": "https://api.github.com/users/rasky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rasky/subscriptions", "organizations_url": "https://api.github.com/users/rasky/orgs", "repos_url": "https://api.github.com/users/rasky/repos", "events_url": "https://api.github.com/users/rasky/events{/privacy}", "received_events_url": "https://api.github.com/users/rasky/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f37d7c6065a4f64b7af059bc8cbd05c3e7f2e9cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f37d7c6065a4f64b7af059bc8cbd05c3e7f2e9cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f37d7c6065a4f64b7af059bc8cbd05c3e7f2e9cf"}], "stats": {"total": 2862, "additions": 1664, "deletions": 1198}, "files": [{"sha": "88073eb9e1a685860760e3e9a404babb21d3df6e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -1,3 +1,56 @@\n+2005-07-20  Giovanni Bajo  <giovannibajo@libero.it>\n+\n+\tMake CONSTRUCTOR use VEC to store initializers.\n+\t* c-common.c (complete_array_type): Update to cope with VEC in\n+\tCONSTRUCTOR_ELTS.\n+\t* c-pretty-print.c (pp_c_initializer_list): Use pp_c_constructor_elts.\n+\t(pp_c_constructor_elts): New function.\n+\t* c-pretty-print.h (pp_c_constructor_elts): Declare.\n+\t* c-typeck.c (build_function_call, build_c_cast, digest_init,\n+\tstruct constructor_stack, struct initializer_stack,\n+\tconstructor_elements, push_init_level, pop_init_level,\n+\tadd_pending_init, find_init_member, output_init_element): Update to\n+\tcope with VEC in CONSTRUCTOR_ELTS.\n+\t* coverage.c (build_fn_info_value, build_ctr_info_value,\n+\tbuild_gcov_info): Likewise.\n+\t* expr.c (categorize_ctor_elements_1, store_constructor,\n+\texpand_expr_real_1): Likewise.\n+\t* fold-const.c (fold_ternary): Likewise.\n+\t* gimplify.c (gimplify_init_ctor_preeval, zero_sized_field_decl,\n+\tgimplify_init_constructor, gimplify_expr): Likewise.\n+\t* tree-dump.c (dequeue_and_dump): Likewise.\n+\t* tree-inline.c (copy_tree_r): Add code to duplicate a CONSTRUCTOR\n+\tnode.\n+\t* tree-pretty-print.c (dump_generic_node): Update to cope with VEC in\n+\tCONSTRUCTOR_ELTS.\n+\t* tree-sra.c (generate_element_init_1): Likewise.\n+\t* tree-ssa-ccp.c (fold_const_aggregate_ref): Likewise.\n+\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n+\t* tree-vect-generic.c (expand_vector_piecewise): Likewise.\n+\t* tree-vect-transform.c (vect_get_vec_def_for_operand):\n+\t(get_initial_def_for_reduction): Likewise.\n+\t* tree-vn.c (set_value_handle, get_value_handle): CONSTURCTOR uses\n+\tvalue handle in annotations.\n+\t* tree.c (tree_node_kind, tree_code_size, make_node_stat,\n+\ttree_node_structure): Add support for constr_kind.\n+\t(build_vector_from_ctor, build_constructor_single,\n+\tbuild_constructor_from_list): New functions.\n+\t(build_constructor): Update to take a VEC instead of a TREE_LIST.\n+\t(simple_cst_equal, iterative_hash_expr, initializer_zerop, walk_tree):\n+\tUpdate to cope with VEC in CONSTRUCTOR_ELTS.\n+\t* tree.def (CONSTRUCTOR): Make it a tcc_exceptional node.\n+\t* tree.h (FOR_EACH_CONSTRUCTOR_VALUE, FOR_EACH_CONSTRUCTOR_ELT,\n+\tCONSTRUCTOR_APPEND_ELT): New macros.\n+\t(struct constructor_elt, struct\ttree_constructor): New data types.\n+\t(union tree_node): Add tree_constructor field.\n+\t* treestruct.def: Define TS_CONSTRUCTOR.\n+\t* varasm.c (const_hash_1, compare_constant, copy_constant,\n+\tcompute_reloc_for_constant, output_addressed_constants,\n+\tinitializer_constant_valid_p, output_constant,\n+\tarray_size_for_constructor, output_constructor): Update to cope with\n+\tVEC in CONSTRUCTOR_ELTS.\n+\t* vec.h (VEC_empty, VEC_copy): New macros.\n+\n 2005-07-19  Devang Patel  <dpatel@apple.com>\n \n \t* dbxout.c (dbxout_type): Check Objective-C++ lang."}, {"sha": "47e24b140c0b9141665d1bc90df580096224905f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -1,3 +1,13 @@\n+2005-07-20  Giovanni Bajo  <giovannibajo@libero.it>\n+\n+\tMake CONSTRUCTOR use VEC to store initializers.\n+\t* decl.c (gnat_to_gnu_entity): Update to cope with VEC in\n+\tCONSTRUCTOR_ELTS.\n+\t* trans.c (extract_values): Likewise.\n+\t* utils.c (convert, remove_conversions): Likewise.\n+\t* utils2.c (contains_save_expr_p, build_binary_op, build_unary_op,\n+\tgnat_build_constructor): Likewise.\n+\n 2005-07-09  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* decl.c (components_to_record): Use DECL_FCONTEXT instead of"}, {"sha": "145ece8ae8efc81a73e743510862a7b0b0a2f9c1", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -940,16 +940,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    gnu_alloc_type\n \t\t      = TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_alloc_type)));\n \n-                   if (TREE_CODE (gnu_expr) == CONSTRUCTOR\n-                       &&\n-                       TREE_CHAIN (CONSTRUCTOR_ELTS (gnu_expr)) == NULL_TREE)\n-                     gnu_expr = 0;\n-                   else\n-                     gnu_expr\n-                       = build_component_ref\n-                         (gnu_expr, NULL_TREE,\n-                          TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (gnu_expr))),\n-\t\t\t  false);\n+\t\t    if (TREE_CODE (gnu_expr) == CONSTRUCTOR\n+\t\t\t&& VEC_length (constructor_elt,\n+\t\t\t\t       CONSTRUCTOR_ELTS (gnu_expr)) == 1)\n+\t\t      gnu_expr = 0;\n+\t\t    else\n+\t\t      gnu_expr\n+\t\t\t= build_component_ref\n+\t\t\t  (gnu_expr, NULL_TREE,\n+\t\t\t  TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (gnu_expr))),\n+\t\t\t      false);\n \t\t  }\n \n \t\tif (TREE_CODE (TYPE_SIZE_UNIT (gnu_alloc_type)) == INTEGER_CST"}, {"sha": "961425224e850080c98990a4ec5cb3b55371f762", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -5625,7 +5625,8 @@ extract_values (tree values, tree record_type)\n       else if (DECL_INTERNAL_P (field))\n \t{\n \t  value = extract_values (values, TREE_TYPE (field));\n-\t  if (TREE_CODE (value) == CONSTRUCTOR && !CONSTRUCTOR_ELTS (value))\n+\t  if (TREE_CODE (value) == CONSTRUCTOR\n+\t      && VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (value)))\n \t    value = 0;\n \t}\n       else"}, {"sha": "baec9ff82cbfbb0b9f42f4538d73917461cff1e4", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -2703,9 +2703,10 @@ convert (tree type, tree expr)\n       /* If we have just converted to this padded type, just get\n \t the inner expression.  */\n       if (TREE_CODE (expr) == CONSTRUCTOR\n-\t  && CONSTRUCTOR_ELTS (expr)\n-\t  && TREE_PURPOSE (CONSTRUCTOR_ELTS (expr)) == TYPE_FIELDS (etype))\n-\treturn TREE_VALUE (CONSTRUCTOR_ELTS (expr));\n+\t  && !VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (expr))\n+\t  && VEC_index (constructor_elt, CONSTRUCTOR_ELTS (expr), 0)->index\n+\t     == TYPE_FIELDS (etype))\n+\treturn VEC_index (constructor_elt, CONSTRUCTOR_ELTS (expr), 0)->value;\n       else\n \treturn convert (type,\n \t\t\tbuild_component_ref (expr, NULL_TREE,\n@@ -3025,7 +3026,9 @@ remove_conversions (tree exp, bool true_address)\n       if (true_address\n \t  && TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE\n \t  && TYPE_JUSTIFIED_MODULAR_P (TREE_TYPE (exp)))\n-\treturn remove_conversions (TREE_VALUE (CONSTRUCTOR_ELTS (exp)), true);\n+\treturn remove_conversions (VEC_index (constructor_elt,\n+\t\t\t\t\t      CONSTRUCTOR_ELTS (exp), 0)->value,\n+\t\t\t\t   true);\n       break;\n \n     case COMPONENT_REF:"}, {"sha": "5847910d2e6745e07c7b5d0197cea47b9e2faaad", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -263,13 +263,15 @@ contains_save_expr_p (tree exp)\n       return contains_save_expr_p (TREE_OPERAND (exp, 0));\n \n     case CONSTRUCTOR:\n-      return (CONSTRUCTOR_ELTS (exp)\n-\t      && contains_save_expr_p (CONSTRUCTOR_ELTS (exp)));\n+      {\n+\ttree value;\n+\tunsigned HOST_WIDE_INT ix;\n \n-    case TREE_LIST:\n-      return (contains_save_expr_p (TREE_VALUE (exp))\n-\t      || (TREE_CHAIN (exp)\n-\t\t  && contains_save_expr_p (TREE_CHAIN (exp))));\n+\tFOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (exp), ix, value)\n+\t  if (contains_save_expr_p (value))\n+\t    return true;\n+\treturn false;\n+      }\n \n     default:\n       return false;\n@@ -884,8 +886,9 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t just compare the data pointer.  */\n       else if (TYPE_FAT_POINTER_P (left_base_type)\n \t       && TREE_CODE (right_operand) == CONSTRUCTOR\n-\t       && integer_zerop (TREE_VALUE\n-\t\t\t\t (CONSTRUCTOR_ELTS (right_operand))))\n+\t       && integer_zerop (VEC_index (constructor_elt,\n+\t\t\t\t\t    CONSTRUCTOR_ELTS (right_operand),\n+\t\t\t\t\t    0)->value))\n \t{\n \t  right_operand = build_component_ref (left_operand, NULL_TREE,\n \t\t\t\t\t       TYPE_FIELDS (left_base_type),\n@@ -1138,9 +1141,11 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t     a pointer to our type.  */\n \t  if (TREE_CODE (type) == RECORD_TYPE && TYPE_IS_PADDING_P (type))\n \t    {\n+\t      result = VEC_index (constructor_elt,\n+\t\t\t\t  CONSTRUCTOR_ELTS (operand),\n+\t\t\t\t  0)->value;\n \t      result\n-\t\t= build_unary_op (ADDR_EXPR, NULL_TREE,\n-\t\t\t\t  TREE_VALUE (CONSTRUCTOR_ELTS (operand)));\n+\t\t= build_unary_op (ADDR_EXPR, NULL_TREE, result);\n \t      result = convert (build_pointer_type (TREE_TYPE (operand)),\n \t\t\t\tresult);\n \t      break;\n@@ -1501,7 +1506,7 @@ gnat_build_constructor (tree type, tree list)\n \t}\n     }\n \n-  result = build_constructor (type, list);\n+  result = build_constructor_from_list (type, list);\n   TREE_CONSTANT (result) = TREE_INVARIANT (result)\n     = TREE_STATIC (result) = allconstant;\n   TREE_SIDE_EFFECTS (result) = side_effects;"}, {"sha": "3c341d87b0c24ad8fe5e5d71d23461cd77cf7b6d", "filename": "gcc/c-common.c", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -5938,9 +5938,9 @@ complete_array_type (tree *ptype, tree initial_value, bool do_default)\n \t}\n       else if (TREE_CODE (initial_value) == CONSTRUCTOR)\n \t{\n-\t  tree elts = CONSTRUCTOR_ELTS (initial_value);\n+\t  VEC(constructor_elt,gc) *v = CONSTRUCTOR_ELTS (initial_value);\n \n-\t  if (elts == NULL)\n+\t  if (VEC_empty (constructor_elt, v))\n \t    {\n \t      if (pedantic)\n \t\tfailure = 3;\n@@ -5949,15 +5949,21 @@ complete_array_type (tree *ptype, tree initial_value, bool do_default)\n \t  else\n \t    {\n \t      tree curindex;\n+\t      unsigned HOST_WIDE_INT cnt;\n+\t      constructor_elt *ce;\n \n-\t      if (TREE_PURPOSE (elts))\n-\t\tmaxindex = fold_convert (sizetype, TREE_PURPOSE (elts));\n+\t      if (VEC_index (constructor_elt, v, 0)->index)\n+\t\tmaxindex = fold_convert (sizetype,\n+\t\t\t\t\t VEC_index (constructor_elt,\n+\t\t\t\t\t\t    v, 0)->index);\n \t      curindex = maxindex;\n \n-\t      for (elts = TREE_CHAIN (elts); elts; elts = TREE_CHAIN (elts))\n+\t      for (cnt = 1;\n+\t\t   VEC_iterate (constructor_elt, v, cnt, ce);\n+\t\t   cnt++)\n \t\t{\n-\t\t  if (TREE_PURPOSE (elts))\n-\t\t    curindex = fold_convert (sizetype, TREE_PURPOSE (elts));\n+\t\t  if (ce->index)\n+\t\t    curindex = fold_convert (sizetype, ce->index);\n \t\t  else\n \t\t    curindex = size_binop (PLUS_EXPR, curindex, size_one_node);\n "}, {"sha": "bbc19be9fd49788675821ee93d7dce2c17c47d8c", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -1137,14 +1137,14 @@ pp_c_initializer_list (c_pretty_printer *pp, tree e)\n       if (TREE_CODE (e) == VECTOR_CST)\n         pp_c_expression_list (pp, TREE_VECTOR_CST_ELTS (e));\n       else if (TREE_CODE (e) == CONSTRUCTOR)\n-        pp_c_expression_list (pp, CONSTRUCTOR_ELTS (e));\n+        pp_c_constructor_elts (pp, CONSTRUCTOR_ELTS (e));\n       else\n         break;\n       return;\n \n     case COMPLEX_TYPE:\n       if (TREE_CODE (e) == CONSTRUCTOR)\n-\tpp_c_expression_list (pp, CONSTRUCTOR_ELTS (e));\n+\tpp_c_constructor_elts (pp, CONSTRUCTOR_ELTS (e));\n       else if (TREE_CODE (e) == COMPLEX_CST || TREE_CODE (e) == COMPLEX_EXPR)\n \t{\n \t  const bool cst = TREE_CODE (e) == COMPLEX_CST;\n@@ -1369,6 +1369,22 @@ pp_c_expression_list (c_pretty_printer *pp, tree e)\n     }\n }\n \n+/* Print out V, which contains the elements of a constructor.  */\n+\n+void\n+pp_c_constructor_elts (c_pretty_printer *pp, VEC(constructor_elt,gc) *v)\n+{\n+  unsigned HOST_WIDE_INT ix;\n+  tree value;\n+\n+  FOR_EACH_CONSTRUCTOR_VALUE (v, ix, value)\n+    {\n+      pp_expression (pp, value);\n+      if (ix != VEC_length (constructor_elt, v) - 1)\n+\tpp_separate_with (pp, ',');\n+    }\n+}\n+\n /* Print out an expression-list in parens, as in a function call.  */\n \n void"}, {"sha": "0f9d46a86e7596a4ebe74167035c5dfba8c90ad8", "filename": "gcc/c-pretty-print.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fc-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fc-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.h?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -192,6 +192,7 @@ void pp_c_statement (c_pretty_printer *, tree);\n void pp_c_expression (c_pretty_printer *, tree);\n void pp_c_logical_or_expression (c_pretty_printer *, tree);\n void pp_c_expression_list (c_pretty_printer *, tree);\n+void pp_c_constructor_elts (c_pretty_printer *, VEC(constructor_elt,gc) *);\n void pp_c_call_argument_list (c_pretty_printer *, tree);\n void pp_c_unary_expression (c_pretty_printer *, tree);\n void pp_c_cast_expression (c_pretty_printer *, tree);"}, {"sha": "d9c994983ae133ba955a06af2fac171f40e19edd", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 39, "deletions": 31, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -2061,8 +2061,7 @@ build_function_call (tree function, tree params)\n \n \t  if (AGGREGATE_TYPE_P (return_type))\n \t    rhs = build_compound_literal (return_type,\n-\t\t\t\t\t  build_constructor (return_type,\n-\t\t\t\t\t\t\t     NULL_TREE));\n+\t\t\t\t\t  build_constructor (return_type, 0));\n \t  else\n \t    rhs = fold_build1 (NOP_EXPR, return_type, integer_zero_node);\n \n@@ -3210,8 +3209,7 @@ build_c_cast (tree type, tree expr)\n \t  if (pedantic)\n \t    pedwarn (\"ISO C forbids casts to union type\");\n \t  t = digest_init (type,\n-\t\t\t   build_constructor (type,\n-\t\t\t\t\t      build_tree_list (field, value)),\n+\t\t\t   build_constructor_single (type, field, value),\n \t\t\t   true, 0);\n \t  TREE_CONSTANT (t) = TREE_CONSTANT (value);\n \t  TREE_INVARIANT (t) = TREE_INVARIANT (value);\n@@ -4397,18 +4395,22 @@ digest_init (tree type, tree init, bool strict_string, int require_constant)\n \n       if (TREE_CODE (inside_init) == CONSTRUCTOR)\n \t{\n-\t  tree link;\n+\t  unsigned HOST_WIDE_INT ix;\n+\t  tree value;\n+\t  bool constant_p = true;\n \n \t  /* Iterate through elements and check if all constructor\n \t     elements are *_CSTs.  */\n-\t  for (link = CONSTRUCTOR_ELTS (inside_init);\n-\t       link;\n-\t       link = TREE_CHAIN (link))\n-\t    if (! CONSTANT_CLASS_P (TREE_VALUE (link)))\n-\t      break;\n+\t  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (inside_init), ix, value)\n+\t    if (!CONSTANT_CLASS_P (value))\n+\t      {\n+\t\tconstant_p = false;\n+\t\tbreak;\n+\t      }\n \n-\t  if (link == NULL)\n-\t    return build_vector (type, CONSTRUCTOR_ELTS (inside_init));\n+\t  if (constant_p)\n+\t    return build_vector_from_ctor (type,\n+\t\t\t\t\t   CONSTRUCTOR_ELTS (inside_init));\n \t}\n     }\n \n@@ -4574,7 +4576,7 @@ static tree constructor_bit_index;\n /* If we are saving up the elements rather than allocating them,\n    this is the list of elements so far (in reverse order,\n    most recent first).  */\n-static tree constructor_elements;\n+static VEC(constructor_elt,gc) *constructor_elements;\n \n /* 1 if constructor should be incrementally stored into a constructor chain,\n    0 if all the elements should be kept in AVL tree.  */\n@@ -4645,7 +4647,7 @@ struct constructor_stack\n   tree unfilled_index;\n   tree unfilled_fields;\n   tree bit_index;\n-  tree elements;\n+  VEC(constructor_elt,gc) *elements;\n   struct init_node *pending_elts;\n   int offset;\n   int depth;\n@@ -4689,7 +4691,7 @@ struct initializer_stack\n   tree decl;\n   struct constructor_stack *constructor_stack;\n   struct constructor_range_stack *constructor_range_stack;\n-  tree elements;\n+  VEC(constructor_elt,gc) *elements;\n   struct spelling *spelling;\n   struct spelling *spelling_base;\n   int spelling_size;\n@@ -5024,7 +5026,7 @@ push_init_level (int implicit)\n       constructor_constant = TREE_CONSTANT (value);\n       constructor_simple = TREE_STATIC (value);\n       constructor_elements = CONSTRUCTOR_ELTS (value);\n-      if (constructor_elements\n+      if (!VEC_empty (constructor_elt, constructor_elements)\n \t  && (TREE_CODE (constructor_type) == RECORD_TYPE\n \t      || TREE_CODE (constructor_type) == ARRAY_TYPE))\n \tset_nonincremental_init ();\n@@ -5199,19 +5201,19 @@ pop_init_level (int implicit)\n     {\n       /* A nonincremental scalar initializer--just return\n \t the element, after verifying there is just one.  */\n-      if (constructor_elements == 0)\n+      if (VEC_empty (constructor_elt,constructor_elements))\n \t{\n \t  if (!constructor_erroneous)\n \t    error_init (\"empty scalar initializer\");\n \t  ret.value = error_mark_node;\n \t}\n-      else if (TREE_CHAIN (constructor_elements) != 0)\n+      else if (VEC_length (constructor_elt,constructor_elements) != 1)\n \t{\n \t  error_init (\"extra elements in scalar initializer\");\n-\t  ret.value = TREE_VALUE (constructor_elements);\n+\t  ret.value = VEC_index (constructor_elt,constructor_elements,0)->value;\n \t}\n       else\n-\tret.value = TREE_VALUE (constructor_elements);\n+\tret.value = VEC_index (constructor_elt,constructor_elements,0)->value;\n     }\n   else\n     {\n@@ -5220,7 +5222,7 @@ pop_init_level (int implicit)\n       else\n \t{\n \t  ret.value = build_constructor (constructor_type,\n-\t\t\t\t\t nreverse (constructor_elements));\n+\t\t\t\t\t constructor_elements);\n \t  if (constructor_constant)\n \t    TREE_CONSTANT (ret.value) = TREE_INVARIANT (ret.value) = 1;\n \t  if (constructor_constant && constructor_simple)\n@@ -5669,14 +5671,15 @@ add_pending_init (tree purpose, tree value)\n static void\n set_nonincremental_init (void)\n {\n-  tree chain;\n+  unsigned HOST_WIDE_INT ix;\n+  tree index, value;\n \n   if (TREE_CODE (constructor_type) != RECORD_TYPE\n       && TREE_CODE (constructor_type) != ARRAY_TYPE)\n     return;\n \n-  for (chain = constructor_elements; chain; chain = TREE_CHAIN (chain))\n-    add_pending_init (TREE_PURPOSE (chain), TREE_VALUE (chain));\n+  FOR_EACH_CONSTRUCTOR_ELT (constructor_elements, ix, index, value)\n+    add_pending_init (index, value);\n   constructor_elements = 0;\n   if (TREE_CODE (constructor_type) == RECORD_TYPE)\n     {\n@@ -5828,9 +5831,10 @@ find_init_member (tree field)\n     }\n   else if (TREE_CODE (constructor_type) == UNION_TYPE)\n     {\n-      if (constructor_elements\n-\t  && TREE_PURPOSE (constructor_elements) == field)\n-\treturn TREE_VALUE (constructor_elements);\n+      if (!VEC_empty (constructor_elt, constructor_elements)\n+\t  && (VEC_last (constructor_elt, constructor_elements)->index\n+\t      == field))\n+\treturn VEC_last (constructor_elt, constructor_elements)->value;\n     }\n   return 0;\n }\n@@ -5852,6 +5856,8 @@ static void\n output_init_element (tree value, bool strict_string, tree type, tree field,\n \t\t     int pending)\n {\n+  constructor_elt *celt;\n+\n   if (type == error_mark_node || value == error_mark_node)\n     {\n       constructor_erroneous = 1;\n@@ -5956,9 +5962,10 @@ output_init_element (tree value, bool strict_string, tree type, tree field,\n       return;\n     }\n   else if (TREE_CODE (constructor_type) == UNION_TYPE\n-\t   && constructor_elements)\n+\t   && !VEC_empty (constructor_elt, constructor_elements))\n     {\n-      if (TREE_SIDE_EFFECTS (TREE_VALUE (constructor_elements)))\n+      if (TREE_SIDE_EFFECTS (VEC_last (constructor_elt,\n+\t\t\t\t       constructor_elements)->value))\n \twarning_init (\"initialized field with side-effects overwritten\");\n \n       /* We can have just one union field set.  */\n@@ -5970,8 +5977,9 @@ output_init_element (tree value, bool strict_string, tree type, tree field,\n \n   if (field && TREE_CODE (field) == INTEGER_CST)\n     field = copy_node (field);\n-  constructor_elements\n-    = tree_cons (field, value, constructor_elements);\n+  celt = VEC_safe_push (constructor_elt, gc, constructor_elements, NULL);\n+  celt->index = field;\n+  celt->value = value;\n \n   /* Advance the variable that indicates sequential elements output.  */\n   if (TREE_CODE (constructor_type) == ARRAY_TYPE)"}, {"sha": "5c1d0922aa5fbb81ce6e424964a5462532bc6871", "filename": "gcc/coverage.c", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -672,10 +672,13 @@ build_fn_info_value (const struct function_list *function, tree type)\n \tarray_value = tree_cons (NULL_TREE, counters, array_value);\n       }\n \n-  array_value = build_constructor (TREE_TYPE (fields), nreverse (array_value));\n+  /* FIXME: use build_constructor directly.  */\n+  array_value = build_constructor_from_list (TREE_TYPE (fields),\n+\t\t\t\t\t     nreverse (array_value));\n   value = tree_cons (fields, array_value, value);\n \n-  value = build_constructor (type, nreverse (value));\n+  /* FIXME: use build_constructor directly.  */\n+  value = build_constructor_from_list (type, nreverse (value));\n \n   return value;\n }\n@@ -768,7 +771,8 @@ build_ctr_info_value (unsigned int counter, tree type)\n \t\t     build1 (ADDR_EXPR, TREE_TYPE (fields), fn),\n \t\t     value);\n \n-  value = build_constructor (type, nreverse (value));\n+  /* FIXME: use build_constructor directly.  */\n+  value = build_constructor_from_list (type, nreverse (value));\n \n   return value;\n }\n@@ -856,7 +860,9 @@ build_gcov_info (void)\n       array_type = build_index_type (build_int_cst (NULL_TREE, n_fns - 1));\n       array_type = build_array_type (fn_info_type, array_type);\n \n-      fn_info_value = build_constructor (array_type, nreverse (fn_info_value));\n+      /* FIXME: use build_constructor directly.  */\n+      fn_info_value = build_constructor_from_list (array_type,\n+\t\t\t\t\t\t   nreverse (fn_info_value));\n       fn_info_value = build1 (ADDR_EXPR, fn_info_ptr_type, fn_info_value);\n     }\n   else\n@@ -894,8 +900,9 @@ build_gcov_info (void)\n       ctr_info_value = tree_cons (NULL_TREE,\n \t\t\t\t  build_ctr_info_value (ix, ctr_info_type),\n \t\t\t\t  ctr_info_value);\n-  ctr_info_value = build_constructor (ctr_info_ary_type,\n-\t\t\t\t      nreverse (ctr_info_value));\n+  /* FIXME: use build_constructor directly.  */\n+  ctr_info_value = build_constructor_from_list (ctr_info_ary_type,\n+\t\t\t\t                nreverse (ctr_info_value));\n \n   field = build_decl (FIELD_DECL, NULL_TREE, ctr_info_ary_type);\n   TREE_CHAIN (field) = fields;\n@@ -904,7 +911,8 @@ build_gcov_info (void)\n \n   finish_builtin_struct (type, \"__gcov_info\", fields, NULL_TREE);\n \n-  value = build_constructor (type, nreverse (value));\n+  /* FIXME: use build_constructor directly.  */\n+  value = build_constructor_from_list (type, nreverse (value));\n \n   return value;\n }"}, {"sha": "0704146cfff95ddd6c8734ef50899f180039917f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -1,3 +1,54 @@\n+2005-07-20  Giovanni Bajo  <giovannibajo@libero.it>\n+\n+\tMake CONSTRUCTOR use VEC to store initializers.\n+\t* call.c (convert_default_arg): Update call to digest_init.\n+\t* class.c (dump_class_hierarchy, dump_array): Update to cope with\n+\tVEC in CONSTRUCTOR_ELTS.\n+\t* cp-tree.h (EMPTY_CONSTRUCTOR_P): Likewise.\n+\t(finish_compound_literal, digest_init): Update declaration.\n+\t* decl.c (struct reshape_iter): New data type.\n+\t(reshape_init_array): Rename to...\n+\t(reshape_init_array_1): Update to cope with VEC in CONSTRUCTOR_ELTS.\n+\t(reshape_init): Rewrite from scratch. Split parts into...\n+\t(reshape_init_array, reshape_init_vector, reshape_init_class,\n+\treshape_init_r): New functions.\n+\t(check_initializer): Update call to reshape_init. Remove obsolete\n+\tcode.\n+\t(initialize_artificial_var, cp_complete_array_type): Update to cope\n+\twith VEC in CONSTRUCTOR_ELTS.\n+\t* decl2.c (grokfield): Update calls to digest_init.\n+\t(mark_vtable_entries): Update to cope with VEC in CONSTRUCTOR_ELTS.\n+\t* error.c (dump_expr_init_vec): New function.\n+\t(dump_expr): Use dump_expr_init_vec.\n+\t* init.c (build_zero_init, build_vec_init): Update to cope with VEC\n+\tin CONSTRUCTOR_ELTS.\n+\t(expand_default_init): Update call to digest_init.\n+\t* parser.c  (cp_parser_postfix_expression): Use a VEC for the\n+\tinitializers.\n+\t(cp_parser_initializer_list): Build a VEC of initializers.\n+\t* pt.c (tsubst_copy, tsubst_copy_and_build): Update to cope with VEC\n+\tin CONSTRUCTOR_ELTS.\n+\t* rtti.c (tinfo_base_init, generic_initializer, ptr_initializer,\n+\tptm_initializer, class_initializer, get_pseudo_ti_init): Use\n+\tbuild_constructor_from_list instead of build_constructor.\n+\t* semantics.c (finish_compound_literal): Update call to digest_init.\n+\t* tree.c (stabilize_init): Update to cope with VEC in\n+\tCONSTRUCTOR_ELTS.\n+\t* typeck.c (build_ptrmemfunc1): Likewise.\n+\t* typeck2.c: (cxx_incomplete_type_error, split_nonconstant_init_1):\n+\tLikewise.\n+\t(store_init_value): Use build_constructor_from_list and update call\n+\tto digest_init.\n+\t(digest_init): Rewrite.\n+\t(process_init_constructor): Rewrite from scratch. Split into...\n+\t(process_init_constructor_array, picflag_from_initializer,\n+\tprocess_init_constructor_record, process_init_constructor_union):\n+\tNew functions.\n+\t(PICFLAG_ERRONEOUS, PICFLAG_NOT_ALL_CONSTANT, PICFLAG_NOT_ALL_SIMPLE):\n+\tNew macros.\n+\t(build_functional_cast): Use build_constructor_from_list instead of\n+\tbuild_constructor.\n+\n 2005-07-18  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/22263"}, {"sha": "6e88708840162f508e0a6aa41a9af80981efd8bc", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -4544,7 +4544,7 @@ convert_default_arg (tree type, tree arg, tree fn, int parmnum)\n \n   if (TREE_CODE (arg) == CONSTRUCTOR)\n     {\n-      arg = digest_init (type, arg, 0);\n+      arg = digest_init (type, arg);\n       arg = convert_for_initialization (0, type, arg, LOOKUP_NORMAL,\n \t\t\t\t\t\"default argument\", fn, parmnum);\n     }"}, {"sha": "9b85a4df2e9d0134a5a31f850d91633f300fe43b", "filename": "gcc/cp/class.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -6437,8 +6437,8 @@ dump_class_hierarchy (tree t)\n static void\n dump_array (FILE * stream, tree decl)\n {\n-  tree inits;\n-  int ix;\n+  tree value;\n+  unsigned HOST_WIDE_INT ix;\n   HOST_WIDE_INT elt;\n   tree size = TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (decl)));\n \n@@ -6450,10 +6450,10 @@ dump_array (FILE * stream, tree decl)\n \t\t\t   TFF_PLAIN_IDENTIFIER));\n   fprintf (stream, \"\\n\");\n \n-  for (ix = 0, inits = CONSTRUCTOR_ELTS (DECL_INITIAL (decl));\n-       inits; ix++, inits = TREE_CHAIN (inits))\n+  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (DECL_INITIAL (decl)),\n+\t\t\t      ix, value)\n     fprintf (stream, \"%-4ld  %s\\n\", (long)(ix * elt),\n-\t     expr_as_string (TREE_VALUE (inits), TFF_PLAIN_IDENTIFIER));\n+\t     expr_as_string (value, TFF_PLAIN_IDENTIFIER));\n }\n \n static void"}, {"sha": "0ac7bbab43346c874b3c8a801d0410b3be32df2a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -2417,9 +2417,10 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n #define BRACE_ENCLOSED_INITIALIZER_P(NODE) \\\n   (TREE_CODE (NODE) == CONSTRUCTOR && !TREE_TYPE (NODE))\n \n-#define EMPTY_CONSTRUCTOR_P(NODE) (TREE_CODE (NODE) == CONSTRUCTOR\t   \\\n-\t\t\t\t   && CONSTRUCTOR_ELTS (NODE) == NULL_TREE \\\n-\t\t\t\t   && ! TREE_HAS_CONSTRUCTOR (NODE))\n+#define EMPTY_CONSTRUCTOR_P(NODE) (TREE_CODE (NODE) == CONSTRUCTOR \\\n+\t\t\t\t   && VEC_empty (constructor_elt, \\\n+\t\t\t\t\t\t CONSTRUCTOR_ELTS (NODE)) \\\n+\t\t\t\t   && !TREE_HAS_CONSTRUCTOR (NODE))\n \n /* Nonzero means that an object of this type can not be initialized using\n    an initializer list.  */\n@@ -4168,7 +4169,7 @@ extern tree finish_increment_expr\t\t(tree, enum tree_code);\n extern tree finish_this_expr\t\t\t(void);\n extern tree finish_pseudo_destructor_expr       (tree, tree, tree);\n extern tree finish_unary_op_expr\t\t(enum tree_code, tree);\n-extern tree finish_compound_literal\t\t(tree, tree);\n+extern tree finish_compound_literal\t\t(tree, VEC(constructor_elt,gc) *);\n extern tree finish_fname\t\t\t(tree);\n extern void finish_translation_unit\t\t(void);\n extern tree finish_template_type_parm\t\t(tree, tree);\n@@ -4348,7 +4349,7 @@ extern void complete_type_check_abstract\t(tree);\n extern int abstract_virtuals_error\t\t(tree, tree);\n \n extern tree store_init_value\t\t\t(tree, tree);\n-extern tree digest_init\t\t\t\t(tree, tree, tree *);\n+extern tree digest_init\t\t\t\t(tree, tree);\n extern tree build_scoped_ref\t\t\t(tree, tree, tree *);\n extern tree build_x_arrow\t\t\t(tree);\n extern tree build_m_component_ref\t\t(tree, tree);"}, {"sha": "ddcab2e0fed21ffcd19c496a9a8451a82b4da722", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 287, "deletions": 212, "changes": 499, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -114,7 +114,7 @@ static void store_parm_decls (tree);\n static void initialize_local_var (tree, tree);\n static void expand_static_init (tree, tree);\n static tree next_initializable_field (tree);\n-static tree reshape_init (tree, tree *);\n+static tree reshape_init (tree, tree);\n \n /* Erroneous argument lists can use this *IFF* they do not modify it.  */\n tree error_mark_list;\n@@ -4103,6 +4103,18 @@ check_for_uninitialized_const_var (tree decl)\n     error (\"uninitialized const %qD\", decl);\n }\n \n+\f\n+/* Structure holding the current initializer being processed by reshape_init.\n+   CUR is a pointer to the current element being processed, END is a pointer\n+   after the last element present in the initializer.  */\n+typedef struct reshape_iterator_t\n+{\n+  constructor_elt *cur;\n+  constructor_elt *end;\n+} reshape_iter;\n+\n+static tree reshape_init_r (tree, reshape_iter *, bool);\n+\n /* FIELD is a FIELD_DECL or NULL.  In the former case, the value\n    returned is the next FIELD_DECL (possibly FIELD itself) that can be\n    initialized.  If there are no more such fields, the return value\n@@ -4120,22 +4132,23 @@ next_initializable_field (tree field)\n   return field;\n }\n \n-/* Subroutine of reshape_init. Reshape the constructor for an array. INITP\n-   is the pointer to the old constructor list (to the CONSTRUCTOR_ELTS of\n-   the CONSTRUCTOR we are processing), while NEW_INIT is the CONSTRUCTOR we\n-   are building.\n-   ELT_TYPE is the element type of the array. MAX_INDEX is an INTEGER_CST\n-   representing the size of the array minus one (the maximum index), or\n-   NULL_TREE if the array was declared without specifying the size.  */\n+/* Subroutine of reshape_init_array and reshape_init_vector, which does\n+   the actual work. ELT_TYPE is the element type of the array. MAX_INDEX is an\n+   INTEGER_CST representing the size of the array minus one (the maximum index),\n+   or NULL_TREE if the array was declared without specifying the size. D is\n+   the iterator within the constructor.  */\n \n-static bool\n-reshape_init_array (tree elt_type, tree max_index,\n-\t\t    tree *initp, tree new_init)\n+static tree\n+reshape_init_array_1 (tree elt_type, tree max_index, reshape_iter *d)\n {\n+  tree new_init;\n   bool sized_array_p = (max_index != NULL_TREE);\n   unsigned HOST_WIDE_INT max_index_cst = 0;\n   unsigned HOST_WIDE_INT index;\n \n+  /* The initializer for an array is always a CONSTRUCTOR.  */\n+  new_init = build_constructor (NULL_TREE, NULL);\n+\n   if (sized_array_p)\n     {\n       if (host_integerp (max_index, 1))\n@@ -4148,104 +4161,181 @@ reshape_init_array (tree elt_type, tree max_index,\n \n   /* Loop until there are no more initializers.  */\n   for (index = 0;\n-       *initp && (!sized_array_p || index <= max_index_cst);\n+       d->cur != d->end && (!sized_array_p || index <= max_index_cst);\n        ++index)\n     {\n-      tree element_init;\n-      tree designated_index;\n+      tree elt_init;\n \n-      element_init = reshape_init (elt_type, initp);\n-      if (element_init == error_mark_node)\n-\treturn false;\n-      TREE_CHAIN (element_init) = CONSTRUCTOR_ELTS (new_init);\n-      CONSTRUCTOR_ELTS (new_init) = element_init;\n-      designated_index = TREE_PURPOSE (element_init);\n-      if (designated_index)\n+      if (d->cur->index)\n \t{\n \t  /* Handle array designated initializers (GNU extension).  */\n-\t  if (TREE_CODE (designated_index) == IDENTIFIER_NODE)\n+\t  if (TREE_CODE (d->cur->index) == IDENTIFIER_NODE)\n \t    {\n \t      error (\"name %qD used in a GNU-style designated \"\n-\t\t     \"initializer for an array\", designated_index);\n-\t      TREE_PURPOSE (element_init) = NULL_TREE;\n+\t\t     \"initializer for an array\", d->cur->index);\n \t    }\n \t  else\n \t    gcc_unreachable ();\n \t}\n+\n+      elt_init = reshape_init_r (elt_type, d, /*first_initializer_p=*/false);\n+      CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (new_init), NULL_TREE, elt_init);\n     }\n \n-  return true;\n+  return new_init;\n }\n \n-/* Undo the brace-elision allowed by [dcl.init.aggr] in a\n-   brace-enclosed aggregate initializer.\n+/* Subroutine of reshape_init_r, processes the initializers for arrays.\n+   Parameters are the same of reshape_init_r.  */\n \n-   *INITP is one of a list of initializers describing a brace-enclosed\n-   initializer for an entity of the indicated aggregate TYPE.  It may\n-   not presently match the shape of the TYPE; for example:\n+static tree\n+reshape_init_array (tree type, reshape_iter *d)\n+{\n+  tree max_index = NULL_TREE;\n \n-     struct S { int a; int b; };\n-     struct S a[] = { 1, 2, 3, 4 };\n+  gcc_assert (TREE_CODE (type) == ARRAY_TYPE);\n \n-   Here *INITP will point to TREE_LIST of four elements, rather than a\n-   list of two elements, each itself a list of two elements.  This\n-   routine transforms INIT from the former form into the latter.  The\n-   revised initializer is returned.  */\n+  if (TYPE_DOMAIN (type))\n+    max_index = array_type_nelts (type);\n+\n+  return reshape_init_array_1 (TREE_TYPE (type), max_index, d);\n+}\n+\n+/* Subroutine of reshape_init_r, processes the initializers for vectors.\n+   Parameters are the same of reshape_init_r.  */\n+\n+static tree\n+reshape_init_vector (tree type, reshape_iter *d)\n+{\n+  tree max_index = NULL_TREE;\n+  tree rtype;\n+\n+  gcc_assert (TREE_CODE (type) == VECTOR_TYPE);\n+\n+  if (TREE_CODE (d->cur->value) == CONSTRUCTOR\n+      && TREE_HAS_CONSTRUCTOR (d->cur->value))\n+    {\n+      tree value = d->cur->value;\n+      if (!same_type_p (TREE_TYPE (value), type))\n+\t{\n+\t  error (\"invalid type %qT as initializer for a vector of type %qT\",\n+\t\tTREE_TYPE (d->cur->value), type);\n+  \t  value = error_mark_node;\n+\t}\n+      ++d->cur;\n+      return value;\n+    }\n+\n+  /* For a vector, the representation type is a struct\n+      containing a single member which is an array of the\n+      appropriate size.  */\n+  rtype = TYPE_DEBUG_REPRESENTATION_TYPE (type);\n+  if (rtype && TYPE_DOMAIN (TREE_TYPE (TYPE_FIELDS (rtype))))\n+    max_index = array_type_nelts (TREE_TYPE (TYPE_FIELDS (rtype)));\n+\n+  return reshape_init_array_1 (TREE_TYPE (type), max_index, d);\n+}\n+\n+/* Subroutine of reshape_init_r, processes the initializers for classes\n+   or union. Parameters are the same of reshape_init_r.  */\n \n static tree\n-reshape_init (tree type, tree *initp)\n+reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p)\n {\n-  tree inits;\n-  tree old_init;\n-  tree old_init_value;\n+  tree field;\n   tree new_init;\n-  bool brace_enclosed_p;\n-  bool string_init_p;\n \n-  old_init = *initp;\n-  old_init_value = (TREE_CODE (*initp) == TREE_LIST\n-\t\t    ? TREE_VALUE (*initp) : old_init);\n+  gcc_assert (CLASS_TYPE_P (type));\n \n-  gcc_assert (old_init_value);\n+  /* The initializer for a class is always a CONSTRUCTOR.  */\n+  new_init = build_constructor (NULL_TREE, NULL);\n+  field = next_initializable_field (TYPE_FIELDS (type));\n \n-  /* If the initializer is brace-enclosed, pull initializers from the\n-     enclosed elements.  Advance past the brace-enclosed initializer\n-     now.  */\n-  if (TREE_CODE (old_init_value) == CONSTRUCTOR\n-      && BRACE_ENCLOSED_INITIALIZER_P (old_init_value))\n+  if (!field)\n     {\n-      *initp = TREE_CHAIN (old_init);\n-      TREE_CHAIN (old_init) = NULL_TREE;\n-      inits = CONSTRUCTOR_ELTS (old_init_value);\n-      initp = &inits;\n-      brace_enclosed_p = true;\n+      /* [dcl.init.aggr]\n+\n+\tAn initializer for an aggregate member that is an\n+\tempty class shall have the form of an empty\n+\tinitializer-list {}.  */\n+      if (!first_initializer_p)\n+\t{\n+\t  error (\"initializer for %qT must be brace-enclosed\", type);\n+\t  return error_mark_node;\n+\t}\n+      return new_init;\n     }\n-  else\n+\n+  /* Loop through the initializable fields, gathering initializers.  */\n+  while (d->cur != d->end)\n     {\n-      inits = NULL_TREE;\n-      brace_enclosed_p = false;\n+      tree field_init;\n+\n+      /* Handle designated initializers, as an extension.  */\n+      if (d->cur->index)\n+\t{\n+\t  if (pedantic)\n+\t    pedwarn (\"ISO C++ does not allow designated initializers\");\n+  \t\n+\t  field = lookup_field_1 (type, d->cur->index, /*want_type=*/false);\n+\n+\t  if (!field || TREE_CODE (field) != FIELD_DECL)\n+\t    error (\"%qT has no non-static data member named %qD\", type,\n+\t\t  d->cur->index);\n+\t}\n+\n+      /* If we processed all the member of the class, we are done.  */\n+      if (!field)\n+\tbreak;\n+\n+      field_init = reshape_init_r (TREE_TYPE (field), d,\n+\t\t\t\t   /*first_initializer_p=*/false);\n+      CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (new_init), field, field_init);\n+\n+      /* [dcl.init.aggr]\n+\n+\tWhen a union  is  initialized with a brace-enclosed\n+\tinitializer, the braces shall only contain an\n+\tinitializer for the first member of the union.  */\n+      if (TREE_CODE (type) == UNION_TYPE)\n+\tbreak;\n+\n+      field = next_initializable_field (TREE_CHAIN (field));\n     }\n \n+  return new_init;\n+}\n+\n+/* Subroutine of reshape_init, which processes a single initializer (part of\n+   a CONSTRUCTOR). TYPE is the type of the variable being initialized, D is the\n+   iterator within the CONSTRUCTOR which points to the initializer to process.\n+   FIRST_INITIALIZER_P is true if this is the first initializer of the\n+   CONSTRUCTOR node.  */\n+\n+static tree\n+reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p)\n+{\n+  tree init = d->cur->value;\n+\n   /* A non-aggregate type is always initialized with a single\n      initializer.  */\n   if (!CP_AGGREGATE_TYPE_P (type))\n-      {\n-\t*initp = TREE_CHAIN (old_init);\n-\tTREE_CHAIN (old_init) = NULL_TREE;\n-\t/* It is invalid to initialize a non-aggregate type with a\n-\t   brace-enclosed initializer.  */\n-\tif (brace_enclosed_p)\n-\t  {\n-\t    error (\"brace-enclosed initializer used to initialize %qT\",\n-\t\t   type);\n-\t    if (TREE_CODE (old_init) == TREE_LIST)\n-\t      TREE_VALUE (old_init) = error_mark_node;\n-\t    else\n-\t      old_init = error_mark_node;\n-\t  }\n-\n-\treturn old_init;\n-      }\n+    {\n+      /* It is invalid to initialize a non-aggregate type with a\n+\t brace-enclosed initializer.\n+\t We need to check for BRACE_ENCLOSED_INITIALIZER_P here because\n+\t of g++.old-deja/g++.mike/p7626.C: a pointer-to-member constant is\n+\t a CONSTRUCTOR (with a record type).  */\n+      if (TREE_CODE (init) == CONSTRUCTOR\n+\t  && BRACE_ENCLOSED_INITIALIZER_P (init))  /* p7626.C */\n+\t{\n+\t  error (\"braces around scalar initializer for type %qT\", type);\n+\t  init = error_mark_node;\n+\t}\n+\t\n+      d->cur++;\n+      return init;\n+    }\n \n   /* [dcl.init.aggr]\n \n@@ -4256,139 +4346,124 @@ reshape_init (tree type, tree *initp)\n      non-empty subaggregate, brace elision is assumed and the\n      initializer is considered for the initialization of the first\n      member of the subaggregate.  */\n-  if (!brace_enclosed_p\n-      && can_convert_arg (type, TREE_TYPE (old_init_value), old_init_value))\n+  if (TREE_CODE (init) != CONSTRUCTOR\n+      && can_convert_arg (type, TREE_TYPE (init), init))\n     {\n-      *initp = TREE_CHAIN (old_init);\n-      TREE_CHAIN (old_init) = NULL_TREE;\n-      return old_init;\n+      d->cur++;\n+      return init;\n     }\n \n-  string_init_p = false;\n-  if (TREE_CODE (old_init_value) == STRING_CST\n-      && TREE_CODE (type) == ARRAY_TYPE\n+  /* [dcl.init.string]\n+\n+      A char array (whether plain char, signed char, or unsigned char)\n+      can be initialized by a string-literal (optionally enclosed in\n+      braces); a wchar_t array can be initialized by a wide\n+      string-literal (optionally enclosed in braces).  */\n+  if (TREE_CODE (type) == ARRAY_TYPE\n       && char_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (type))))\n     {\n-      /* [dcl.init.string]\n+      tree str_init = init;\n \n-\t A char array (whether plain char, signed char, or unsigned char)\n-\t can be initialized by a string-literal (optionally enclosed in\n-\t braces); a wchar_t array can be initialized by a wide\n-\t string-literal (optionally enclosed in braces).  */\n-      new_init = old_init;\n-      /* Move past the initializer.  */\n-      *initp = TREE_CHAIN (old_init);\n-      TREE_CHAIN (old_init) = NULL_TREE;\n-      string_init_p = true;\n+      /* Strip one level of braces if and only if they enclose a single\n+         element (as allowed by [dcl.init.string]).  */\n+      if (!first_initializer_p\n+\t  && TREE_CODE (str_init) == CONSTRUCTOR\n+\t  && VEC_length (constructor_elt, CONSTRUCTOR_ELTS (str_init)) == 1)\n+\t{\n+\t  str_init = VEC_index (constructor_elt,\n+\t\t\t\tCONSTRUCTOR_ELTS (str_init), 0)->value;\n+\t}\n+  \n+      /* If it's a string literal, then it's the initializer for the array\n+         as a whole. Otherwise, continue with normal initialization for\n+\t array types (one value per array element).  */\n+      if (TREE_CODE (str_init) == STRING_CST)\n+\t{\n+\t  d->cur++;\n+\t  return str_init;\n+\t}\n     }\n-  else\n-    {\n-      /* Build a CONSTRUCTOR to hold the contents of the aggregate.  */\n-      new_init = build_constructor (NULL_TREE, NULL_TREE);\n \n-      if (CLASS_TYPE_P (type))\n+  /* The following cases are about aggregates. If we are not within a full\n+     initializer already, and there is not a CONSTRUCTOR, it means that there\n+     is a missing set of braces (that is, we are processing the case for\n+     which reshape_init exists).  */\n+  if (!first_initializer_p)\n+    {\n+      if (TREE_CODE (init) == CONSTRUCTOR)\n \t{\n-\t  tree field;\n-\n-\t  field = next_initializable_field (TYPE_FIELDS (type));\n-\n-\t  if (!field)\n+\t  /* For a nested compound literal, there is no need to reshape since\n+\t     brace elision is not allowed. Even if we decided to allow it,\n+\t     we should add a call to reshape_init in finish_compound_literal,\n+\t     before calling digest_init, so changing this code would still\n+\t     not be necessary.  */\n+\t  if (!TREE_HAS_CONSTRUCTOR (init))\n \t    {\n-\t      /* [dcl.init.aggr]\n-\n-\t\t An initializer for an aggregate member that is an\n-\t\t empty class shall have the form of an empty\n-\t\t initializer-list {}.  */\n-\t      if (!brace_enclosed_p)\n-\t\t{\n-\t\t  error (\"initializer for %qT must be brace-enclosed\", type);\n-\t\t  return error_mark_node;\n-\t\t}\n+\t      ++d->cur;\n+\t      gcc_assert (BRACE_ENCLOSED_INITIALIZER_P (init));\n+\t      return reshape_init (type, init);\n \t    }\n \t  else\n-\t    {\n-\t      /* Loop through the initializable fields, gathering\n-\t\t initializers.  */\n-\t      while (*initp)\n-\t\t{\n-\t\t  tree field_init;\n+\t    gcc_assert (!BRACE_ENCLOSED_INITIALIZER_P (init));\n+\t}\n \n-\t\t  /* Handle designated initializers, as an extension.  */\n-\t\t  if (TREE_PURPOSE (*initp))\n-\t\t    {\n-\t\t      if (pedantic)\n-\t\t\tpedwarn (\"ISO C++ does not allow designated initializers\");\n-\t\t      field = lookup_field_1 (type, TREE_PURPOSE (*initp),\n-\t\t\t\t\t      /*want_type=*/false);\n-\t\t      if (!field || TREE_CODE (field) != FIELD_DECL)\n-\t\t\terror (\"%qT has no non-static data member named %qD\",\n-\t\t\t       type, TREE_PURPOSE (*initp));\n-\t\t    }\n-\t\t  if (!field)\n-\t\t    break;\n+      warning (OPT_Wmissing_braces, \"missing braces around initializer for %qT\",\n+\t       type);\n+    }\n \n-\t\t  field_init = reshape_init (TREE_TYPE (field), initp);\n-\t\t  if (field_init == error_mark_node)\n-\t\t    return error_mark_node;\n-\t\t  TREE_CHAIN (field_init) = CONSTRUCTOR_ELTS (new_init);\n-\t\t  CONSTRUCTOR_ELTS (new_init) = field_init;\n-\t\t  /* [dcl.init.aggr]\n-\n-\t\t     When a union  is  initialized with a brace-enclosed\n-\t\t     initializer, the braces shall only contain an\n-\t\t     initializer for the first member of the union.  */\n-\t\t  if (TREE_CODE (type) == UNION_TYPE)\n-\t\t    break;\n-\t\t  field = next_initializable_field (TREE_CHAIN (field));\n-\t\t}\n-\t    }\n-\t}\n-      else if (TREE_CODE (type) == ARRAY_TYPE\n-\t       || TREE_CODE (type) == VECTOR_TYPE)\n-\t{\n-\t    /* If the bound of the array is known, take no more initializers\n-\t      than are allowed.  */\n-\t    tree max_index = NULL_TREE;\n-\t    if (TREE_CODE (type) == ARRAY_TYPE)\n-\t      {\n-\t\tif (TYPE_DOMAIN (type))\n-\t\t  max_index = array_type_nelts (type);\n-\t      }\n-\t    else\n-\t      {\n-\t\t/* For a vector, the representation type is a struct\n-\t\t  containing a single member which is an array of the\n-\t\t  appropriate size.  */\n-\t\ttree rtype = TYPE_DEBUG_REPRESENTATION_TYPE (type);\n-\t\tif (rtype && TYPE_DOMAIN (TREE_TYPE (TYPE_FIELDS (rtype))))\n-\t\t  max_index = array_type_nelts (TREE_TYPE (TYPE_FIELDS\n-\t\t\t\t\t\t\t   (rtype)));\n-\t      }\n+  /* Dispatch to specialized routines.  */\n+  if (CLASS_TYPE_P (type))\n+    return reshape_init_class (type, d, first_initializer_p);\n+  else if (TREE_CODE (type) == ARRAY_TYPE)\n+    return reshape_init_array (type, d);\n+  else if (TREE_CODE (type) == VECTOR_TYPE)\n+    return reshape_init_vector (type, d);\n+  else\n+    gcc_unreachable();\n+}\n \n-\t  if (!reshape_init_array (TREE_TYPE (type), max_index,\n-\t\t\t\t   initp, new_init))\n-\t    return error_mark_node;\n-\t}\n-      else\n-\tgcc_unreachable ();\n+/* Undo the brace-elision allowed by [dcl.init.aggr] in a\n+   brace-enclosed aggregate initializer.\n \n-      /* The initializers were placed in reverse order in the\n-\t CONSTRUCTOR.  */\n-      CONSTRUCTOR_ELTS (new_init) = nreverse (CONSTRUCTOR_ELTS (new_init));\n+   INIT is the CONSTRUCTOR containing the list of initializers describing\n+   a brace-enclosed initializer for an entity of the indicated aggregate TYPE.\n+   It may not presently match the shape of the TYPE; for example:\n \n-      if (TREE_CODE (old_init) == TREE_LIST)\n-\tnew_init = build_tree_list (TREE_PURPOSE (old_init), new_init);\n-    }\n+     struct S { int a; int b; };\n+     struct S a[] = { 1, 2, 3, 4 };\n \n-  /* If there are more initializers than necessary, issue a\n-     diagnostic.  */\n-  if (*initp)\n-    {\n-      if (brace_enclosed_p)\n-\terror (\"too many initializers for %qT\", type);\n-      else if (warn_missing_braces && !string_init_p)\n-\twarning (0, \"missing braces around initializer\");\n-    }\n+   Here INIT will hold a VEC of four elements, rather than a\n+   VEC of two elements, each itself a VEC of two elements.  This\n+   routine transforms INIT from the former form into the latter.  The\n+   revised CONSTRUCTOR node is returned.  */\n+\n+static tree\n+reshape_init (tree type, tree init)\n+{\n+  VEC(constructor_elt, gc) *v;\n+  reshape_iter d;\n+  tree new_init;\n+\n+  gcc_assert (TREE_CODE (init) == CONSTRUCTOR);\n+  gcc_assert (BRACE_ENCLOSED_INITIALIZER_P (init));\n+\n+  v = CONSTRUCTOR_ELTS (init);\n+\n+  /* An empty constructor does not need reshaping, and it is always a valid\n+     initializer.  */\n+  if (VEC_empty (constructor_elt, v))\n+    return init;\n+\n+  /* Recurse on this CONSTRUCTOR.  */\n+  d.cur = VEC_index (constructor_elt, v, 0);\n+  d.end = d.cur + VEC_length (constructor_elt, v);\n+\n+  new_init = reshape_init_r (type, &d, true);\n+\n+  /* Make sure all the element of the constructor were used. Otherwise,\n+     issue an error about exceeding initializers.  */\n+  if (d.cur != d.end)\n+    error (\"too many initializers for %qT\", type);\n \n   return new_init;\n }\n@@ -4455,20 +4530,13 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n     init = grok_reference_init (decl, type, init, cleanup);\n   else if (init)\n     {\n+      /* Do not reshape constructors of vectors (they don't need to be\n+         reshaped.  */\n       if (TREE_CODE (init) == CONSTRUCTOR\n-\t  && BRACE_ENCLOSED_INITIALIZER_P (init))\n+\t  && !TREE_HAS_CONSTRUCTOR (init)\n+\t  && !TREE_TYPE (init))  /* ptrmemfunc */\n \t{\n-\t  /* [dcl.init] paragraph 13,\n-\t     If T is a scalar type, then a declaration of the form\n-\t     T x = { a };\n-\t     is equivalent to\n-\t     T x = a;\n-\n-\t     reshape_init will complain about the extra braces,\n-\t     and doesn't do anything useful in the case where TYPE is\n-\t     scalar, so just don't call it.  */\n-\t  if (CP_AGGREGATE_TYPE_P (type))\n-\t    init = reshape_init (type, &init);\n+\t  init = reshape_init (type, init);\n \n \t  if ((*targetm.vector_opaque_p) (type))\n \t    {\n@@ -4486,9 +4554,9 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n \t{\n \t  if (TREE_CODE (type) == ARRAY_TYPE)\n \t    goto initialize_aggr;\n-\t  else if (TREE_CODE (init) == CONSTRUCTOR\n-\t\t   && BRACE_ENCLOSED_INITIALIZER_P (init))\n+\t  else if (TREE_CODE (init) == CONSTRUCTOR)\n \t    {\n+\t      gcc_assert (BRACE_ENCLOSED_INITIALIZER_P (init));\n \t      if (TYPE_NON_AGGREGATE_CLASS (type))\n \t\t{\n \t\t  error (\"%qD must be initialized by constructor, \"\n@@ -4713,7 +4781,7 @@ initialize_local_var (tree decl, tree init)\n void\n initialize_artificial_var (tree decl, tree init)\n {\n-  DECL_INITIAL (decl) = build_constructor (NULL_TREE, init);\n+  DECL_INITIAL (decl) = build_constructor_from_list (NULL_TREE, init);\n   DECL_INITIALIZED_P (decl) = 1;\n   determine_visibility (decl);\n   layout_var_decl (decl);\n@@ -5401,14 +5469,21 @@ cp_complete_array_type (tree *ptype, tree initial_value, bool do_default)\n   if (initial_value)\n     {\n       /* An array of character type can be initialized from a\n-\t brace-enclosed string constant.  */\n+\t brace-enclosed string constant.\n+\n+\t FIXME: this code is duplicated from reshape_init. Probably\n+\t we should just call reshape_init here?  */\n       if (char_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (*ptype)))\n \t  && TREE_CODE (initial_value) == CONSTRUCTOR\n-\t  && CONSTRUCTOR_ELTS (initial_value)\n-\t  && (TREE_CODE (TREE_VALUE (CONSTRUCTOR_ELTS (initial_value)))\n-\t      == STRING_CST)\n-\t  && TREE_CHAIN (CONSTRUCTOR_ELTS (initial_value)) == NULL_TREE)\n-\tinitial_value = TREE_VALUE (CONSTRUCTOR_ELTS (initial_value));\n+\t  && !VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (initial_value)))\n+\t{\n+\t  VEC(constructor_elt,gc) *v = CONSTRUCTOR_ELTS (initial_value);\n+\t  tree value = VEC_index (constructor_elt, v, 0)->value;\n+\n+\t  if (TREE_CODE (value) == STRING_CST\n+\t      && VEC_length (constructor_elt, v) == 1)\n+\t    initial_value = value;\n+\t}\n     }\n \n   failure = complete_array_type (ptype, initial_value, do_default);"}, {"sha": "e7db5525961ce08b4a95eeb62afca64ac469d85f", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 18, "deletions": 30, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -903,37 +903,24 @@ grokfield (const cp_declarator *declarator,\n       else if (pedantic && TREE_CODE (value) != VAR_DECL)\n \t/* Already complained in grokdeclarator.  */\n \tinit = NULL_TREE;\n-      else\n+      else if (!processing_template_decl)\n \t{\n-\t  /* We allow initializers to become parameters to base\n-\t     initializers.  */\n-\t  if (TREE_CODE (init) == TREE_LIST)\n-\t    {\n-\t      if (TREE_CHAIN (init) == NULL_TREE)\n-\t\tinit = TREE_VALUE (init);\n-\t      else\n-\t\tinit = digest_init (TREE_TYPE (value), init, (tree *)0);\n-\t    }\n+\t  if (TREE_CODE (init) == CONSTRUCTOR)\n+\t    init = digest_init (TREE_TYPE (value), init);\n+\t  else\n+\t    init = integral_constant_value (init);\n \n-\t  if (!processing_template_decl)\n+\t  if (init != error_mark_node && !TREE_CONSTANT (init))\n \t    {\n-\t      if (TREE_CODE (init) == CONSTRUCTOR)\n-\t\tinit = digest_init (TREE_TYPE (value), init, (tree *)0);\n-\t      else\n-\t\tinit = integral_constant_value (init);\n-\n-\t      if (init != error_mark_node && ! TREE_CONSTANT (init))\n+\t      /* We can allow references to things that are effectively\n+\t\t static, since references are initialized with the\n+\t\t address.  */\n+\t      if (TREE_CODE (TREE_TYPE (value)) != REFERENCE_TYPE\n+\t\t  || (TREE_STATIC (init) == 0\n+\t\t      && (!DECL_P (init) || DECL_EXTERNAL (init) == 0)))\n \t\t{\n-\t\t  /* We can allow references to things that are effectively\n-\t\t     static, since references are initialized with the\n-\t\t     address.  */\n-\t\t  if (TREE_CODE (TREE_TYPE (value)) != REFERENCE_TYPE\n-\t\t      || (TREE_STATIC (init) == 0\n-\t\t\t  && (!DECL_P (init) || DECL_EXTERNAL (init) == 0)))\n-\t\t    {\n-\t\t      error (\"field initializer is not constant\");\n-\t\t      init = error_mark_node;\n-\t\t    }\n+\t\t  error (\"field initializer is not constant\");\n+\t\t  init = error_mark_node;\n \t\t}\n \t    }\n \t}\n@@ -1262,11 +1249,12 @@ coerce_delete_type (tree type)\n static void\n mark_vtable_entries (tree decl)\n {\n-  tree entries = CONSTRUCTOR_ELTS (DECL_INITIAL (decl));\n+  tree fnaddr;\n+  unsigned HOST_WIDE_INT idx;\n \n-  for (; entries; entries = TREE_CHAIN (entries))\n+  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (DECL_INITIAL (decl)),\n+\t\t\t      idx, fnaddr)\n     {\n-      tree fnaddr = TREE_VALUE (entries);\n       tree fn;\n \n       STRIP_NOPS (fnaddr);"}, {"sha": "9905e253aa1d90e4bb93df00952852172b8234eb", "filename": "gcc/cp/error.c", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -1266,6 +1266,23 @@ dump_expr_list (tree l, int flags)\n     }\n }\n \n+/* Print out a vector of initializers (subr of dump_expr).  */\n+\n+static void\n+dump_expr_init_vec (VEC(constructor_elt,gc) *v, int flags)\n+{\n+  unsigned HOST_WIDE_INT idx;\n+  tree value;\n+\n+  FOR_EACH_CONSTRUCTOR_VALUE (v, idx, value)\n+    {\n+      dump_expr (value, flags | TFF_EXPR_IN_PARENS);\n+      if (idx != VEC_length (constructor_elt, v) - 1)\n+\tpp_separate_with_comma (cxx_pp);\n+    }\n+}\n+\n+\n /* Print out an expression E under control of FLAGS.  */\n \n static void\n@@ -1659,7 +1676,7 @@ dump_expr (tree t, int flags)\n \t\t}\n \t    }\n \t}\n-      if (TREE_TYPE (t) && !CONSTRUCTOR_ELTS (t))\n+      if (TREE_TYPE (t) && EMPTY_CONSTRUCTOR_P (t))\n \t{\n \t  dump_type (TREE_TYPE (t), 0);\n \t  pp_cxx_left_paren (cxx_pp);\n@@ -1668,7 +1685,7 @@ dump_expr (tree t, int flags)\n       else\n \t{\n \t  pp_cxx_left_brace (cxx_pp);\n-\t  dump_expr_list (CONSTRUCTOR_ELTS (t), flags);\n+\t  dump_expr_init_vec (CONSTRUCTOR_ELTS (t), flags);\n \t  pp_cxx_right_brace (cxx_pp);\n \t}\n "}, {"sha": "9383e928fa51c81b608f5ca1a5ac40a9a7adf75f", "filename": "gcc/cp/init.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -184,12 +184,9 @@ build_zero_init (tree type, tree nelts, bool static_storage_p)\n   else if (CLASS_TYPE_P (type))\n     {\n       tree field;\n-      tree inits;\n+      VEC(constructor_elt,gc) *v = NULL;\n \n-      /* Build a constructor to contain the initializations.  */\n-      init = build_constructor (type, NULL_TREE);\n       /* Iterate over the fields, building initializations.  */\n-      inits = NULL_TREE;\n       for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n \t{\n \t  if (TREE_CODE (field) != FIELD_DECL)\n@@ -200,27 +197,27 @@ build_zero_init (tree type, tree nelts, bool static_storage_p)\n \t     over TYPE_FIELDs will result in correct initialization of\n \t     all of the subobjects.  */\n \t  if (static_storage_p && !zero_init_p (TREE_TYPE (field)))\n-\t    inits = tree_cons (field,\n-\t\t\t       build_zero_init (TREE_TYPE (field),\n-\t\t\t\t\t\t/*nelts=*/NULL_TREE,\n-\t\t\t\t\t\tstatic_storage_p),\n-\t\t\t       inits);\n+\t    {\n+\t      tree value = build_zero_init (TREE_TYPE (field),\n+\t\t\t\t\t    /*nelts=*/NULL_TREE,\n+\t\t\t\t\t    static_storage_p);\n+\t      CONSTRUCTOR_APPEND_ELT(v, field, value);\n+\t    }\n \n \t  /* For unions, only the first field is initialized.  */\n \t  if (TREE_CODE (type) == UNION_TYPE)\n \t    break;\n \t}\n-      CONSTRUCTOR_ELTS (init) = nreverse (inits);\n+\n+\t/* Build a constructor to contain the initializations.  */\n+\tinit = build_constructor (type, v);\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       tree max_index;\n-      tree inits;\n+      VEC(constructor_elt,gc) *v = NULL;\n \n-      /* Build a constructor to contain the initializations.  */\n-      init = build_constructor (type, NULL_TREE);\n       /* Iterate over the array elements, building initializations.  */\n-      inits = NULL_TREE;\n       if (nelts)\n \tmax_index = fold_build2 (MINUS_EXPR, TREE_TYPE (nelts),\n \t\t\t\t nelts, integer_one_node);\n@@ -232,21 +229,25 @@ build_zero_init (tree type, tree nelts, bool static_storage_p)\n \t have an upper bound of -1.  */\n       if (!tree_int_cst_equal (max_index, integer_minus_one_node))\n \t{\n-\t  tree elt_init = build_zero_init (TREE_TYPE (type),\n-\t\t\t\t\t   /*nelts=*/NULL_TREE,\n-\t\t\t\t\t   static_storage_p);\n-\t  tree range;\n+\t  constructor_elt *ce;\n+\n+\t  v = VEC_alloc (constructor_elt, gc, 1);\n+\t  ce = VEC_quick_push (constructor_elt, v, NULL);\n \n \t  /* If this is a one element array, we just use a regular init.  */\n \t  if (tree_int_cst_equal (size_zero_node, max_index))\n-\t    range = size_zero_node;\n+\t    ce->index = size_zero_node;\n \t  else\n-\t   range = build2 (RANGE_EXPR, sizetype, size_zero_node, max_index);\n+\t    ce->index = build2 (RANGE_EXPR, sizetype, size_zero_node,\n+\t\t\t\tmax_index);\n \n-\t  inits = tree_cons (range, elt_init, inits);\n+\t  ce->value = build_zero_init (TREE_TYPE (type),\n+\t\t\t\t       /*nelts=*/NULL_TREE,\n+\t\t\t\t       static_storage_p);\n \t}\n \n-      CONSTRUCTOR_ELTS (init) = nreverse (inits);\n+      /* Build a constructor to contain the initializations.  */\n+      init = build_constructor (type, v);\n     }\n   else\n     gcc_assert (TREE_CODE (type) == REFERENCE_TYPE);\n@@ -1191,7 +1192,7 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags)\n \t{\n \t  /* A brace-enclosed initializer for an aggregate.  */\n \t  gcc_assert (CP_AGGREGATE_TYPE_P (type));\n-\t  init = digest_init (type, init, (tree *)NULL);\n+\t  init = digest_init (type, init);\n \t}\n       else\n \tinit = ocp_convert (type, init, CONV_IMPLICIT|CONV_FORCE_TEMP, flags);\n@@ -2417,7 +2418,7 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n       && ((TREE_CODE (init) == CONSTRUCTOR\n \t   /* Don't do this if the CONSTRUCTOR might contain something\n \t      that might throw and require us to clean up.  */\n-\t   && (CONSTRUCTOR_ELTS (init) == NULL_TREE\n+\t   && (VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (init))\n \t       || ! TYPE_HAS_NONTRIVIAL_DESTRUCTOR (inner_elt_type)))\n \t  || from_array))\n     {\n@@ -2485,13 +2486,12 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n     {\n       /* Do non-default initialization of non-POD arrays resulting from\n \t brace-enclosed initializers.  */\n-\n-      tree elts;\n+      unsigned HOST_WIDE_INT idx;\n+      tree elt;\n       from_array = 0;\n \n-      for (elts = CONSTRUCTOR_ELTS (init); elts; elts = TREE_CHAIN (elts))\n+      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (init), idx, elt)\n \t{\n-\t  tree elt = TREE_VALUE (elts);\n \t  tree baseref = build1 (INDIRECT_REF, type, base);\n \n \t  num_initialized_elts++;"}, {"sha": "082727e5901a09c0c9e48553cf86d895f5638004", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -1546,7 +1546,7 @@ static tree cp_parser_initializer\n   (cp_parser *, bool *, bool *);\n static tree cp_parser_initializer_clause\n   (cp_parser *, bool *);\n-static tree cp_parser_initializer_list\n+static VEC(constructor_elt,gc) *cp_parser_initializer_list\n   (cp_parser *, bool *);\n \n static bool cp_parser_ctor_initializer_opt_and_function_body\n@@ -4027,7 +4027,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p)\n \tif (cp_parser_allow_gnu_extensions_p (parser)\n \t    && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n \t  {\n-\t    tree initializer_list = NULL_TREE;\n+\t    VEC(constructor_elt,gc) *initializer_list = NULL;\n \t    bool saved_in_type_id_in_expr_p;\n \n \t    cp_parser_parse_tentatively (parser);\n@@ -12298,7 +12298,7 @@ cp_parser_initializer (cp_parser* parser, bool* is_parenthesized_init,\n    returned is simply a representation for the expression.\n \n    Otherwise, a CONSTRUCTOR is returned.  The CONSTRUCTOR_ELTS will be\n-   the elements of the initializer-list (or NULL_TREE, if the last\n+   the elements of the initializer-list (or NULL, if the last\n    production is used).  The TREE_TYPE for the CONSTRUCTOR will be\n    NULL_TREE.  There is no way to detect whether or not the optional\n    trailing `,' was provided.  NON_CONSTANT_P is as for\n@@ -12358,15 +12358,15 @@ cp_parser_initializer_clause (cp_parser* parser, bool* non_constant_p)\n      identifier : initializer-clause\n      initializer-list, identifier : initializer-clause\n \n-   Returns a TREE_LIST.  The TREE_VALUE of each node is an expression\n-   for the initializer.  If the TREE_PURPOSE is non-NULL, it is the\n+   Returns a VEC of constructor_elt.  The VALUE of each elt is an expression\n+   for the initializer.  If the INDEX of the elt is non-NULL, it is the\n    IDENTIFIER_NODE naming the field to initialize.  NON_CONSTANT_P is\n    as for cp_parser_initializer.  */\n \n-static tree\n+static VEC(constructor_elt,gc) *\n cp_parser_initializer_list (cp_parser* parser, bool* non_constant_p)\n {\n-  tree initializers = NULL_TREE;\n+  VEC(constructor_elt,gc) *v = NULL;\n \n   /* Assume all of the expressions are constant.  */\n   *non_constant_p = false;\n@@ -12400,8 +12400,9 @@ cp_parser_initializer_list (cp_parser* parser, bool* non_constant_p)\n       /* If any clause is non-constant, so is the entire initializer.  */\n       if (clause_non_constant_p)\n \t*non_constant_p = true;\n-      /* Add it to the list.  */\n-      initializers = tree_cons (identifier, initializer, initializers);\n+\n+      /* Add it to the vector.  */\n+      CONSTRUCTOR_APPEND_ELT(v, identifier, initializer);\n \n       /* If the next token is not a comma, we have reached the end of\n \t the list.  */\n@@ -12420,9 +12421,7 @@ cp_parser_initializer_list (cp_parser* parser, bool* non_constant_p)\n       cp_lexer_consume_token (parser->lexer);\n     }\n \n-  /* The initializers were built up in reverse order, so we need to\n-     reverse them now.  */\n-  return nreverse (initializers);\n+  return v;\n }\n \n /* Classes [gram.class] */"}, {"sha": "2ab89b2eae30d6bb0869ffa43489311b8d8f05cd", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -8006,13 +8006,8 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \treturn t;\n \n     case CONSTRUCTOR:\n-      {\n-\tr = build_constructor\n-\t  (tsubst (TREE_TYPE (t), args, complain, in_decl),\n-\t   tsubst_copy (CONSTRUCTOR_ELTS (t), args, complain, in_decl));\n-\tTREE_HAS_CONSTRUCTOR (r) = TREE_HAS_CONSTRUCTOR (t);\n-\treturn r;\n-      }\n+      /* This is handled by tsubst_copy_and_build.  */\n+      gcc_unreachable ();\n \n     case VA_ARG_EXPR:\n       return build_x_va_arg (tsubst_copy (TREE_OPERAND (t, 0), args, complain,\n@@ -8814,38 +8809,35 @@ tsubst_copy_and_build (tree t,\n \n     case CONSTRUCTOR:\n       {\n+\tVEC(constructor_elt,gc) *n;\n+\tconstructor_elt *ce;\n+\tunsigned HOST_WIDE_INT idx;\n \ttree r;\n-\ttree elts;\n \ttree type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n-\tbool purpose_p;\n+\tbool process_index_p;\n \n \t/* digest_init will do the wrong thing if we let it.  */\n \tif (type && TYPE_PTRMEMFUNC_P (type))\n \t  return t;\n \n-\tr = NULL_TREE;\n-\t/* We do not want to process the purpose of aggregate\n+\t/* We do not want to process the index of aggregate\n \t   initializers as they are identifier nodes which will be\n \t   looked up by digest_init.  */\n-\tpurpose_p = !(type && IS_AGGR_TYPE (type));\n-\tfor (elts = CONSTRUCTOR_ELTS (t);\n-\t     elts;\n-\t     elts = TREE_CHAIN (elts))\n-\t  {\n-\t    tree purpose = TREE_PURPOSE (elts);\n-\t    tree value = TREE_VALUE (elts);\n+\tprocess_index_p = !(type && IS_AGGR_TYPE (type));\n \n-\t    if (purpose && purpose_p)\n-\t      purpose = RECUR (purpose);\n-\t    value = RECUR (value);\n-\t    r = tree_cons (purpose, value, r);\n+\tn = VEC_copy (constructor_elt, gc, CONSTRUCTOR_ELTS (t));\n+\tfor (idx = 0; VEC_iterate (constructor_elt, n, idx, ce); idx++)\n+\t  {\n+\t    if (ce->index && process_index_p)\n+\t      ce->index = RECUR (ce->index);\n+\t    ce->value = RECUR (ce->value);\n \t  }\n \n-\tr = build_constructor (NULL_TREE, nreverse (r));\n+\tr = build_constructor (NULL_TREE, n);\n \tTREE_HAS_CONSTRUCTOR (r) = TREE_HAS_CONSTRUCTOR (t);\n \n \tif (type)\n-\t  return digest_init (type, r, 0);\n+\t  return digest_init (type, r);\n \treturn r;\n       }\n "}, {"sha": "e0069388dd71e0bcbde2f03a038eaa7812756100", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -861,7 +861,7 @@ tinfo_base_init (tinfo_s *ti, tree target)\n \n   init = tree_cons (NULL_TREE, decay_conversion (name_decl), init);\n \n-  init = build_constructor (NULL_TREE, nreverse (init));\n+  init = build_constructor_from_list (NULL_TREE, nreverse (init));\n   TREE_CONSTANT (init) = 1;\n   TREE_INVARIANT (init) = 1;\n   TREE_STATIC (init) = 1;\n@@ -879,7 +879,7 @@ generic_initializer (tinfo_s *ti, tree target)\n {\n   tree init = tinfo_base_init (ti, target);\n   \n-  init = build_constructor (NULL_TREE, init);\n+  init = build_constructor_from_list (NULL_TREE, init);\n   TREE_CONSTANT (init) = 1;\n   TREE_INVARIANT (init) = 1;\n   TREE_STATIC (init) = 1;\n@@ -905,7 +905,7 @@ ptr_initializer (tinfo_s *ti, tree target)\n \t\t    get_tinfo_ptr (TYPE_MAIN_VARIANT (to)),\n \t\t    init);\n \n-  init = build_constructor (NULL_TREE, nreverse (init));\n+  init = build_constructor_from_list (NULL_TREE, nreverse (init));\n   TREE_CONSTANT (init) = 1;\n   TREE_INVARIANT (init) = 1;\n   TREE_STATIC (init) = 1;\n@@ -937,8 +937,8 @@ ptm_initializer (tinfo_s *ti, tree target)\n   init = tree_cons (NULL_TREE,\n \t\t    get_tinfo_ptr (klass),\n \t\t    init);\n-\n-  init = build_constructor (NULL_TREE, nreverse (init));\n+  \n+  init = build_constructor_from_list (NULL_TREE, nreverse (init));\n   TREE_CONSTANT (init) = 1;\n   TREE_INVARIANT (init) = 1;\n   TREE_STATIC (init) = 1;\n@@ -955,7 +955,7 @@ class_initializer (tinfo_s *ti, tree target, tree trail)\n   tree init = tinfo_base_init (ti, target);\n \n   TREE_CHAIN (init) = trail;\n-  init = build_constructor (NULL_TREE, init);\n+  init = build_constructor_from_list (NULL_TREE, init);\n   TREE_CONSTANT (init) = 1;\n   TREE_INVARIANT (init) = 1;\n   TREE_STATIC (init) = 1;\n@@ -1066,10 +1066,10 @@ get_pseudo_ti_init (tree type, unsigned tk_index)\n \t\t\t\t\t build_int_cst (NULL_TREE, flags));\n \t    base_init = tree_cons (NULL_TREE, offset, base_init);\n \t    base_init = tree_cons (NULL_TREE, tinfo, base_init);\n-\t    base_init = build_constructor (NULL_TREE, base_init);\n+\t    base_init = build_constructor_from_list (NULL_TREE, base_init);\n \t    base_inits = tree_cons (NULL_TREE, base_init, base_inits);\n \t  }\n-\tbase_inits = build_constructor (NULL_TREE, base_inits);\n+\tbase_inits = build_constructor_from_list (NULL_TREE, base_inits);\n \tbase_inits = tree_cons (NULL_TREE, base_inits, NULL_TREE);\n \t/* Prepend the number of bases.  */\n \tbase_inits = tree_cons (NULL_TREE,"}, {"sha": "e935bb985b165d874868d46ae1eeee30900bae2c", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -2011,20 +2011,19 @@ finish_unary_op_expr (enum tree_code code, tree expr)\n    the INITIALIZER_LIST is being cast.  */\n \n tree\n-finish_compound_literal (tree type, tree initializer_list)\n+finish_compound_literal (tree type, VEC(constructor_elt,gc) *initializer_list)\n {\n   tree compound_literal;\n \n   /* Build a CONSTRUCTOR for the INITIALIZER_LIST.  */\n   compound_literal = build_constructor (NULL_TREE, initializer_list);\n   /* Mark it as a compound-literal.  */\n-  TREE_HAS_CONSTRUCTOR (compound_literal) = 1;\n   if (processing_template_decl)\n     TREE_TYPE (compound_literal) = type;\n   else\n     {\n       /* Check the initialization.  */\n-      compound_literal = digest_init (type, compound_literal, NULL);\n+      compound_literal = digest_init (type, compound_literal);\n       /* If the TYPE was an array type with an unknown bound, then we can\n \t figure out the dimension now.  For example, something like:\n \n@@ -2036,6 +2035,7 @@ finish_compound_literal (tree type, tree initializer_list)\n \t\t\t\tcompound_literal, 1);\n     }\n \n+  TREE_HAS_CONSTRUCTOR (compound_literal) = 1;\n   return compound_literal;\n }\n "}, {"sha": "ddc0b514c99a40f6f4b9bdc799cabe859e4d1364", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -2241,7 +2241,7 @@ stabilize_init (tree init, tree *initp)\n       if (TREE_CODE (t) == COMPOUND_EXPR)\n \tt = expr_last (t);\n       if (TREE_CODE (t) == CONSTRUCTOR\n-\t  && CONSTRUCTOR_ELTS (t) == NULL_TREE)\n+\t  && EMPTY_CONSTRUCTOR_P (t))\n \t{\n \t  /* Default-initialization.  */\n \t  *initp = NULL_TREE;"}, {"sha": "9a14f4854a01fecabae4e751f23c15a87bd79474", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -5640,6 +5640,7 @@ build_ptrmemfunc1 (tree type, tree delta, tree pfn)\n   tree u = NULL_TREE;\n   tree delta_field;\n   tree pfn_field;\n+  VEC(constructor_elt, gc) *v;\n \n   /* Pull the FIELD_DECLs out of the type.  */\n   pfn_field = TYPE_FIELDS (type);\n@@ -5649,9 +5650,10 @@ build_ptrmemfunc1 (tree type, tree delta, tree pfn)\n   delta = convert_and_check (delta_type_node, delta);\n \n   /* Finish creating the initializer.  */\n-  u = tree_cons (pfn_field, pfn,\n-\t\t build_tree_list (delta_field, delta));\n-  u = build_constructor (type, u);\n+  v = VEC_alloc(constructor_elt, gc, 2);\n+  CONSTRUCTOR_APPEND_ELT(v, pfn_field, pfn);\n+  CONSTRUCTOR_APPEND_ELT(v, delta_field, delta);\n+  u = build_constructor (type, v);\n   TREE_CONSTANT (u) = TREE_CONSTANT (pfn) & TREE_CONSTANT (delta);\n   TREE_INVARIANT (u) = TREE_INVARIANT (pfn) & TREE_INVARIANT (delta);\n   TREE_STATIC (u) = (TREE_CONSTANT (u)"}, {"sha": "2564a0547684271a98215c4dc7c7fd07c633013d", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 350, "deletions": 417, "changes": 767, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -39,7 +39,9 @@ Boston, MA 02110-1301, USA.  */\n #include \"output.h\"\n #include \"diagnostic.h\"\n \n-static tree process_init_constructor (tree, tree, tree *);\n+static tree\n+process_init_constructor (tree type, tree init);\n+\n \n /* Print an error message stemming from an attempt to use\n    BASETYPE as a base class for TYPE.  */\n@@ -435,11 +437,12 @@ cxx_incomplete_type_error (tree value, tree type)\n static void\n split_nonconstant_init_1 (tree dest, tree init)\n {\n-  tree *pelt, elt, type = TREE_TYPE (dest);\n-  tree sub, code, inner_type = NULL;\n+  unsigned HOST_WIDE_INT idx;\n+  tree field_index, value;\n+  tree type = TREE_TYPE (dest);\n+  tree inner_type = NULL;\n   bool array_type_p = false;\n \n-  pelt = &CONSTRUCTOR_ELTS (init);\n   switch (TREE_CODE (type))\n     {\n     case ARRAY_TYPE:\n@@ -450,16 +453,21 @@ split_nonconstant_init_1 (tree dest, tree init)\n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n-      while ((elt = *pelt))\n+      FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (init), idx,\n+\t\t\t\tfield_index, value)\n \t{\n-\t  tree field_index = TREE_PURPOSE (elt);\n-\t  tree value = TREE_VALUE (elt);\n+\t  /* The current implementation of this algorithm assumes that\n+\t     the field was set for all the elements. This is usually done\n+\t     by process_init_constructor.  */\n+\t  gcc_assert (field_index);\n \n \t  if (!array_type_p)\n \t    inner_type = TREE_TYPE (field_index);\n \n \t  if (TREE_CODE (value) == CONSTRUCTOR)\n \t    {\n+\t      tree sub;\n+\n \t      if (array_type_p)\n \t\tsub = build4 (ARRAY_REF, inner_type, dest, field_index,\n \t\t\t      NULL_TREE, NULL_TREE);\n@@ -471,7 +479,19 @@ split_nonconstant_init_1 (tree dest, tree init)\n \t    }\n \t  else if (!initializer_constant_valid_p (value, inner_type))\n \t    {\n-\t      *pelt = TREE_CHAIN (elt);\n+\t      tree code;\n+\t      tree sub;\n+\n+\t      /* FIXME: Ordered removal is O(1) so the whole function is\n+\t\t worst-case quadratic. This could be fixed using an aside\n+\t\t bitmap to record which elements must be removed and remove\n+\t\t them all at the same time. Or by merging\n+\t\t split_non_constant_init into process_init_constructor_array,\n+\t\t that is separating constants from non-constants while building\n+\t\t the vector.  */\n+\t      VEC_ordered_remove (constructor_elt, CONSTRUCTOR_ELTS (init),\n+\t\t\t\t  idx);\n+\t      --idx;\n \n \t      if (array_type_p)\n \t\tsub = build4 (ARRAY_REF, inner_type, dest, field_index,\n@@ -485,14 +505,13 @@ split_nonconstant_init_1 (tree dest, tree init)\n \t      add_stmt (code);\n \t      continue;\n \t    }\n-\n-\t  pelt = &TREE_CHAIN (elt);\n \t}\n       break;\n \n     case VECTOR_TYPE:\n       if (!initializer_constant_valid_p (init, type))\n \t{\n+\t  tree code;\n \t  tree cons = copy_node (init);\n \t  CONSTRUCTOR_ELTS (init) = NULL;\n \t  code = build2 (MODIFY_EXPR, type, dest, cons);\n@@ -568,7 +587,7 @@ store_init_value (tree decl, tree init)\n \t{\n \t  error (\"constructor syntax used, but no constructor declared \"\n \t\t \"for type %qT\", type);\n-\t  init = build_constructor (NULL_TREE, nreverse (init));\n+\t  init = build_constructor_from_list (NULL_TREE, nreverse (init));\n \t}\n     }\n   else if (TREE_CODE (init) == TREE_LIST\n@@ -591,7 +610,7 @@ store_init_value (tree decl, tree init)\n   /* End of special C++ code.  */\n \n   /* Digest the specified initializer into an expression.  */\n-  value = digest_init (type, init, (tree *) 0);\n+  value = digest_init (type, init);\n   /* If the initializer is not a constant, fill in DECL_INITIAL with\n      the bits that are constant, and then return an expression that\n      will perform the dynamic initialization.  */\n@@ -607,520 +626,434 @@ store_init_value (tree decl, tree init)\n }\n \n \f\n-/* Digest the parser output INIT as an initializer for type TYPE.\n-   Return a C expression of type TYPE to represent the initial value.\n+/* Process the initializer INIT for a variable of type TYPE, emitting\n+   diagnostics for invalid initializers and converting the initializer as\n+   appropriate.\n \n-   If TAIL is nonzero, it points to a variable holding a list of elements\n-   of which INIT is the first.  We update the list stored there by\n-   removing from the head all the elements that we use.\n-   Normally this is only one; we use more than one element only if\n-   TYPE is an aggregate and INIT is not a constructor.  */\n+   For aggregate types, it assumes that reshape_init has already run, thus the\n+   initializer will have the right shape (brace elision has been undone).  */\n \n tree\n-digest_init (tree type, tree init, tree* tail)\n+digest_init (tree type, tree init)\n {\n   enum tree_code code = TREE_CODE (type);\n-  tree element = NULL_TREE;\n-  tree old_tail_contents = NULL_TREE;\n-\n-  /* By default, assume we use one element from a list.\n-     We correct this later in the sole case where it is not true.  */\n \n-  if (tail)\n-    {\n-      old_tail_contents = *tail;\n-      *tail = TREE_CHAIN (*tail);\n-    }\n-\n-  if (init == error_mark_node || (TREE_CODE (init) == TREE_LIST\n-\t\t\t\t  && TREE_VALUE (init) == error_mark_node))\n+  if (init == error_mark_node)\n     return error_mark_node;\n \n-  if (TREE_CODE (init) == ERROR_MARK)\n-    /* __PRETTY_FUNCTION__'s initializer is a bogus expression inside\n-       a template function. This gets substituted during instantiation.  */\n-    return init;\n+  gcc_assert (init);\n \n   /* We must strip the outermost array type when completing the type,\n      because the its bounds might be incomplete at the moment.  */\n   if (!complete_type_or_else (TREE_CODE (type) == ARRAY_TYPE\n \t\t\t      ? TREE_TYPE (type) : type, NULL_TREE))\n     return error_mark_node;\n \n-  /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n+  /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue\n+     (g++.old-deja/g++.law/casts2.C).  */\n   if (TREE_CODE (init) == NON_LVALUE_EXPR)\n     init = TREE_OPERAND (init, 0);\n \n-  if (BRACE_ENCLOSED_INITIALIZER_P (init)\n-      && CONSTRUCTOR_ELTS (init) != 0\n-      && TREE_CHAIN (CONSTRUCTOR_ELTS (init)) == 0)\n-    {\n-      element = TREE_VALUE (CONSTRUCTOR_ELTS (init));\n-      /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n-      if (element && TREE_CODE (element) == NON_LVALUE_EXPR)\n-\telement = TREE_OPERAND (element, 0);\n-      if (element == error_mark_node)\n-\treturn element;\n-    }\n-\n-  /* Initialization of an array of chars from a string constant\n-     optionally enclosed in braces.  */\n-\n+  /* Initialization of an array of chars from a string constant. The initializer\n+     can be optionally enclosed in braces, but reshape_init has already removed\n+     them if they were present.  */\n   if (code == ARRAY_TYPE)\n     {\n-      tree typ1;\n-\n-      if (TREE_CODE (init) == TREE_LIST)\n-\t{\n-\t  error (\"initializing array with parameter list\");\n-\t  return error_mark_node;\n-\t}\n-\n-      typ1 = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n+      tree typ1 = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n       if (char_type_p (typ1)\n-\t  && ((init && TREE_CODE (init) == STRING_CST)\n-\t      || (element && TREE_CODE (element) == STRING_CST)))\n+\t  /*&& init */\n+\t  && TREE_CODE (init) == STRING_CST)\n \t{\n-\t  tree string = element ? element : init;\n+\t  tree char_type = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (init)));\n \n-\t  if ((TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (string)))\n-\t       != char_type_node)\n+\t  if (char_type != char_type_node\n \t      && TYPE_PRECISION (typ1) == BITS_PER_UNIT)\n \t    {\n \t      error (\"char-array initialized from wide string\");\n \t      return error_mark_node;\n \t    }\n-\t  if ((TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (string)))\n-\t       == char_type_node)\n+\t  if (char_type == char_type_node\n \t      && TYPE_PRECISION (typ1) != BITS_PER_UNIT)\n \t    {\n \t      error (\"int-array initialized from non-wide string\");\n \t      return error_mark_node;\n \t    }\n \n-\t  TREE_TYPE (string) = type;\n-\t  if (TYPE_DOMAIN (type) != 0\n-\t      && TREE_CONSTANT (TYPE_SIZE (type)))\n+\t  TREE_TYPE (init) = type;\n+\t  if (TYPE_DOMAIN (type) != 0 && TREE_CONSTANT (TYPE_SIZE (type)))\n \t    {\n \t      int size = TREE_INT_CST_LOW (TYPE_SIZE (type));\n \t      size = (size + BITS_PER_UNIT - 1) / BITS_PER_UNIT;\n \t      /* In C it is ok to subtract 1 from the length of the string\n \t\t because it's ok to ignore the terminating null char that is\n \t\t counted in the length of the constant, but in C++ this would\n \t\t be invalid.  */\n-\t      if (size < TREE_STRING_LENGTH (string))\n+\t      if (size < TREE_STRING_LENGTH (init))\n \t\tpedwarn (\"initializer-string for array of chars is too long\");\n \t    }\n-\t  return string;\n+\t  return init;\n \t}\n     }\n \n   /* Handle scalar types, including conversions,\n      and signature pointers and references.  */\n-\n-  if (code == INTEGER_TYPE || code == REAL_TYPE || code == POINTER_TYPE\n-      || code == ENUMERAL_TYPE || code == REFERENCE_TYPE\n-      || code == BOOLEAN_TYPE || code == COMPLEX_TYPE\n-      || TYPE_PTR_TO_MEMBER_P (type))\n+  if (SCALAR_TYPE_P (type)\n+      || code == REFERENCE_TYPE)\n+    return convert_for_initialization (0, type, init, LOOKUP_NORMAL,\n+\t\t\t\t       \"initialization\", NULL_TREE, 0);\n+\n+  /* Come here only for aggregates: records, arrays, unions, complex numbers\n+     and vectors.  */\n+  gcc_assert (TREE_CODE (type) == ARRAY_TYPE\n+\t      || TREE_CODE (type) == VECTOR_TYPE\n+\t      || TREE_CODE (type) == RECORD_TYPE\n+\t      || TREE_CODE (type) == UNION_TYPE\n+\t      || TREE_CODE (type) == COMPLEX_TYPE);\n+\n+  if (BRACE_ENCLOSED_INITIALIZER_P (init))\n+      return process_init_constructor (type, init);\n+  else\n     {\n-      if (BRACE_ENCLOSED_INITIALIZER_P (init))\n+      if (TREE_HAS_CONSTRUCTOR (init)\n+\t  && TREE_CODE (type) == ARRAY_TYPE)\n \t{\n-\t  if (element == 0)\n-\t    {\n-\t      error (\"initializer for scalar variable requires one element\");\n-\t      return error_mark_node;\n-\t    }\n-\t  init = element;\n-\t}\n-      while (BRACE_ENCLOSED_INITIALIZER_P (init))\n-\t{\n-\t  pedwarn (\"braces around scalar initializer for %qT\", type);\n-\t  init = CONSTRUCTOR_ELTS (init);\n-\t  if (TREE_CHAIN (init))\n-\t    pedwarn (\"ignoring extra initializers for %qT\", type);\n-\t  init = TREE_VALUE (init);\n-\t}\n+\t  error (\"cannot initialize aggregate of type %qT with \"\n+\t\t \"a compound literal\", type);\n \n-      return convert_for_initialization (0, type, init, LOOKUP_NORMAL,\n+\t  return error_mark_node;\n+\t}\n+      return convert_for_initialization (NULL_TREE, type, init,\n+\t\t\t\t\t LOOKUP_NORMAL | LOOKUP_ONLYCONVERTING,\n \t\t\t\t\t \"initialization\", NULL_TREE, 0);\n     }\n+}\n+\n+\f\n+/* Set of flags used within process_init_constructor to describe the\n+   initializers.  */\n+#define PICFLAG_ERRONEOUS 1\n+#define PICFLAG_NOT_ALL_CONSTANT 2\n+#define PICFLAG_NOT_ALL_SIMPLE 4\n+\n+/* Given an initializer INIT, return the flag (PICFLAG_*) which better\n+   describe it.  */\n+\n+static int\n+picflag_from_initializer (tree init)\n+{\n+  if (init == error_mark_node)\n+    return PICFLAG_ERRONEOUS;\n+  else if (!TREE_CONSTANT (init))\n+    return PICFLAG_NOT_ALL_CONSTANT;\n+  else if (!initializer_constant_valid_p (init, TREE_TYPE (init)))\n+    return PICFLAG_NOT_ALL_SIMPLE;\n+  return 0;\n+}\n \n-  /* Come here only for records and arrays (and unions with constructors).  */\n+/* Subroutine of process_init_constructor, which will process an initializer\n+   INIT for a array or vector of type TYPE. Returns the flags (PICFLAG_*) which\n+   describe the initializers.  */\n \n-  if (COMPLETE_TYPE_P (type) && ! TREE_CONSTANT (TYPE_SIZE (type)))\n+static int\n+process_init_constructor_array (tree type, tree init)\n+{\n+  unsigned HOST_WIDE_INT i, len = 0;\n+  int flags = 0;\n+  bool unbounded = false;\n+  constructor_elt *ce;\n+  VEC(constructor_elt,gc) *v = CONSTRUCTOR_ELTS (init);\n+\n+  gcc_assert (TREE_CODE (type) == ARRAY_TYPE\n+\t      || TREE_CODE (type) == VECTOR_TYPE);\n+\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n-      error (\"variable-sized object of type %qT may not be initialized\",\n-\t\ttype);\n-      return error_mark_node;\n+      tree domain = TYPE_DOMAIN (type);\n+      if (domain)\n+\tlen = (TREE_INT_CST_LOW (TYPE_MAX_VALUE (domain))\n+\t      - TREE_INT_CST_LOW (TYPE_MIN_VALUE (domain))\n+\t      + 1);\n+      else\n+\tunbounded = true;  /* Take as many as there are.  */\n     }\n+  else\n+    /* Vectors are like simple fixed-size arrays.  */\n+    len = TYPE_VECTOR_SUBPARTS (type);\n \n-  if (code == ARRAY_TYPE || code == VECTOR_TYPE || IS_AGGR_TYPE_CODE (code))\n+  /* There cannot be more initializers than needed (or reshape_init would\n+     detect this before we do.  */\n+  if (!unbounded)\n+    gcc_assert (VEC_length (constructor_elt, v) <= len);\n+\n+  for (i = 0; VEC_iterate (constructor_elt, v, i, ce); ++i)\n     {\n-      if (BRACE_ENCLOSED_INITIALIZER_P (init))\n-\t{\n-\t  if (TYPE_NON_AGGREGATE_CLASS (type))\n-\t    {\n-\t      error (\"subobject of type %qT must be initialized by \"\n-\t\t     \"constructor, not by %qE\",\n-\t\t     type, init);\n-\t      return error_mark_node;\n-\t    }\n-\t  return process_init_constructor (type, init, (tree *)0);\n-\t}\n-      else if (can_convert_arg (type, TREE_TYPE (init), init)\n-\t       || TYPE_NON_AGGREGATE_CLASS (type))\n-\t/* These are never initialized from multiple constructor elements.  */;\n-      else if (tail != 0)\n+      if (ce->index)\n \t{\n-\t  *tail = old_tail_contents;\n-\t  return process_init_constructor (type, 0, tail);\n+\t  gcc_assert (TREE_CODE (ce->index) == INTEGER_CST);\n+\t  if (compare_tree_int (ce->index, i) != 0)\n+\t    sorry (\"non-trivial designated initializers not supported\");\n \t}\n+      else\n+\tce->index = size_int (i);\n+      gcc_assert (ce->value);\n+      ce->value = digest_init (TREE_TYPE (type), ce->value);\n \n-      if (code != ARRAY_TYPE)\n-\t{\n-\t  int flags = LOOKUP_NORMAL;\n-\t  /* Initialization from { } is copy-initialization.  */\n-\t  if (tail)\n-\t    flags |= LOOKUP_ONLYCONVERTING;\n+      if (ce->value != error_mark_node)\n+\tgcc_assert (same_type_ignoring_top_level_qualifiers_p\n+\t\t      (TREE_TYPE (type), TREE_TYPE (ce->value)));\n \n-\t  return convert_for_initialization (NULL_TREE, type, init, flags,\n-\t\t\t\t\t     \"initialization\", NULL_TREE, 0);\n-\t}\n+      flags |= picflag_from_initializer (ce->value);\n     }\n \n-  error (\"invalid initializer\");\n-  return error_mark_node;\n-}\n-\f\n-/* Process a constructor for a variable of type TYPE.\n-   The constructor elements may be specified either with INIT or with ELTS,\n-   only one of which should be non-null.\n+  /* No more initializers. If the array is unbounded, we are done. Otherwise,\n+     we must add initializers ourselves.  */\n+  if (!unbounded)\n+    for (; i < len; ++i)\n+      {\n+\ttree next;\n+\n+\tif (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (type)))\n+\t  {\n+\t    /* If this type needs constructors run for default-initialization,\n+\t      we can't rely on the backend to do it for us, so build up\n+\t      TARGET_EXPRs.  If the type in question is a class, just build\n+\t      one up; if it's an array, recurse.  */\n+\t    if (IS_AGGR_TYPE (TREE_TYPE (type)))\n+\t\tnext = build_functional_cast (TREE_TYPE (type), NULL_TREE);\n+\t    else\n+\t\tnext = build_constructor (NULL_TREE, NULL);\n+\t    next = digest_init (TREE_TYPE (type), next);\n+\t  }\n+\telse if (!zero_init_p (TREE_TYPE (type)))\n+\t  next = build_zero_init (TREE_TYPE (type),\n+\t\t\t\t  /*nelts=*/NULL_TREE,\n+\t\t\t\t  /*static_storage_p=*/false);\n+\telse\n+\t  /* The default zero-initialization is fine for us; don't\n+\t     add anything to the CONSTRUCTOR.  */\n+\t  break;\n \n-   If INIT is specified, it is a CONSTRUCTOR node which is specifically\n-   and solely for initializing this datum.\n+\tflags |= picflag_from_initializer (next);    \n+\tCONSTRUCTOR_APPEND_ELT (v, size_int (i), next);\n+      }\n \n-   If ELTS is specified, it is the address of a variable containing\n-   a list of expressions.  We take as many elements as we need\n-   from the head of the list and update the list.\n+  CONSTRUCTOR_ELTS (init) = v;\n+  return flags;\n+}\n \n-   In the resulting constructor, TREE_CONSTANT is set if all elts are\n-   constant, and TREE_STATIC is set if, in addition, all elts are simple enough\n-   constants that the assembler and linker can compute them.  */\n+/* Subroutine of process_init_constructor, which will process an initializer\n+   INIT for a class of type TYPE. Returns the flags (PICFLAG_*) which describe\n+   the initializers.  */\n \n-static tree\n-process_init_constructor (tree type, tree init, tree* elts)\n+static int\n+process_init_constructor_record (tree type, tree init)\n {\n-  tree tail;\n-  /* List of the elements of the result constructor,\n-     in reverse order.  */\n-  tree members = NULL;\n-  tree next1;\n-  tree result;\n-  int allconstant = 1;\n-  int allsimple = 1;\n-  int erroneous = 0;\n-\n-  /* Make TAIL be the list of elements to use for the initialization,\n-     no matter how the data was given to us.  */\n-\n-  if (elts)\n-    {\n-      if (warn_missing_braces)\n-\twarning (0, \"aggregate has a partly bracketed initializer\");\n-      tail = *elts;\n-    }\n-  else\n-    tail = CONSTRUCTOR_ELTS (init);\n-\n-  /* Gobble as many elements as needed, and make a constructor or initial value\n-     for each element of this aggregate.  Chain them together in result.\n-     If there are too few, use 0 for each scalar ultimate component.  */\n-\n-  if (TREE_CODE (type) == ARRAY_TYPE || TREE_CODE (type) == VECTOR_TYPE)\n+  VEC(constructor_elt,gc) *v = NULL;\n+  int flags = 0;\n+  tree field;\n+  unsigned HOST_WIDE_INT idx = 0;\n+\n+  gcc_assert (TREE_CODE (type) == RECORD_TYPE);\n+  gcc_assert (!CLASSTYPE_VBASECLASSES (type));\n+  gcc_assert (!TYPE_BINFO (type)\n+\t      || !BINFO_N_BASE_BINFOS (TYPE_BINFO (type)));\n+  gcc_assert (!TYPE_POLYMORPHIC_P (type));\n+\n+  /* Generally, we will always have an index for each initializer (which is\n+     a FIELD_DECL, put by reshape_init), but compound literals don't go trough\n+     reshape_init. So we need to handle both cases.  */\n+  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n     {\n-      long len;\n-      int i;\n+      tree next;\n \n-      if (TREE_CODE (type) == ARRAY_TYPE)\n+      if (!DECL_NAME (field) && DECL_C_BIT_FIELD (field))\n \t{\n-\t  tree domain = TYPE_DOMAIN (type);\n-\t  if (domain)\n-\t    len = (TREE_INT_CST_LOW (TYPE_MAX_VALUE (domain))\n-\t\t   - TREE_INT_CST_LOW (TYPE_MIN_VALUE (domain))\n-\t\t   + 1);\n-\t  else\n-\t    len = -1;  /* Take as many as there are.  */\n-\t}\n-      else\n-\t{\n-\t  /* Vectors are like simple fixed-size arrays.  */\n-\t  len = TYPE_VECTOR_SUBPARTS (type);\n+\t  flags |= picflag_from_initializer (integer_zero_node);\n+\t  CONSTRUCTOR_APPEND_ELT (v, field, integer_zero_node);\n+\t  continue;\n \t}\n \n-      for (i = 0; len < 0 || i < len; i++)\n+      if (TREE_CODE (field) != FIELD_DECL || DECL_ARTIFICIAL (field))\n+\tcontinue;\n+\n+      if (idx < VEC_length (constructor_elt, CONSTRUCTOR_ELTS (init)))\n \t{\n-\t  if (tail)\n+\t  constructor_elt *ce = VEC_index (constructor_elt,\n+\t\t\t\t\t   CONSTRUCTOR_ELTS (init), idx);\n+\t  if (ce->index)\n \t    {\n-\t      if (TREE_PURPOSE (tail)\n-\t\t  && (TREE_CODE (TREE_PURPOSE (tail)) != INTEGER_CST\n-\t\t      || compare_tree_int (TREE_PURPOSE (tail), i) != 0))\n-\t\tsorry (\"non-trivial labeled initializers\");\n-\n-\t      if (TREE_VALUE (tail) != 0)\n-\t\t{\n-\t\t  tree tail1 = tail;\n-\t\t  next1 = digest_init (TREE_TYPE (type),\n-\t\t\t\t       TREE_VALUE (tail), &tail1);\n-\t\t  if (next1 == error_mark_node)\n-\t\t    return next1;\n-\t\t  gcc_assert (same_type_ignoring_top_level_qualifiers_p\n-\t\t\t      (TREE_TYPE (type), TREE_TYPE (next1)));\n-\t\t  gcc_assert (!tail1 || TREE_CODE (tail1) == TREE_LIST);\n-\t\t  if (tail == tail1 && len < 0)\n-\t\t    {\n-\t\t      error (\"non-empty initializer for array of empty elements\");\n-\t\t      /* Just ignore what we were supposed to use.  */\n-\t\t      tail1 = NULL_TREE;\n-\t\t    }\n-\t\t  tail = tail1;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  next1 = error_mark_node;\n-\t\t  tail = TREE_CHAIN (tail);\n-\t\t}\n+\t      /* We can have either a FIELD_DECL or an IDENTIFIER_NODE. The\n+\t\t latter case can happen in templates where lookup has to be\n+\t\t deferred.  */\n+\t      gcc_assert (TREE_CODE (ce->index) == FIELD_DECL\n+\t\t\t  || TREE_CODE (ce->index) == IDENTIFIER_NODE);\n+\t      if (ce->index != field\n+\t          && ce->index != DECL_NAME (field))\n+\t\tsorry (\"non-trivial designated initializers not supported\");\n \t    }\n-\t  else if (len < 0)\n-\t    /* We're done.  */\n-\t    break;\n-\t  else if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (type)))\n-\t    {\n-\t      /* If this type needs constructors run for\n-\t\t default-initialization, we can't rely on the backend to do it\n-\t\t for us, so build up TARGET_EXPRs.  If the type in question is\n-\t\t a class, just build one up; if it's an array, recurse.  */\n \n-\t      if (IS_AGGR_TYPE (TREE_TYPE (type)))\n-\t\tnext1 = build_functional_cast (TREE_TYPE (type), NULL_TREE);\n-\t      else\n-\t\tnext1 = build_constructor (NULL_TREE, NULL_TREE);\n-\t      next1 = digest_init (TREE_TYPE (type), next1, 0);\n-\t    }\n-\t  else if (! zero_init_p (TREE_TYPE (type)))\n-\t    next1 = build_zero_init (TREE_TYPE (type),\n-\t\t\t\t     /*nelts=*/NULL_TREE,\n-\t\t\t\t     /*static_storage_p=*/false);\n+\t  gcc_assert (ce->value);\n+\t  next = digest_init (TREE_TYPE (field), ce->value);\n+\t  ++idx;\n+\t}\n+      else if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (field)))\n+\t{\n+\t  /* If this type needs constructors run for\n+\t     default-initialization, we can't rely on the backend to do it\n+\t     for us, so build up TARGET_EXPRs.  If the type in question is\n+\t     a class, just build one up; if it's an array, recurse.  */\n+\t  if (IS_AGGR_TYPE (TREE_TYPE (field)))\n+\t    next = build_functional_cast (TREE_TYPE (field), NULL_TREE);\n+\t  else\n+\t    next = build_constructor (NULL_TREE, NULL);\n+\n+\t  next = digest_init (TREE_TYPE (field), next);\n+\n+\t  /* Warn when some struct elements are implicitly initialized.  */\n+\t  warning (OPT_Wmissing_field_initializers,\n+\t\t   \"missing initializer for member %qD\", field);\n+\t}\n+      else\n+\t{\n+\t  if (TREE_READONLY (field))\n+\t    error (\"uninitialized const member %qD\", field);\n+\t  else if (CLASSTYPE_READONLY_FIELDS_NEED_INIT (TREE_TYPE (field)))\n+\t    error (\"member %qD with uninitialized const fields\", field);\n+\t  else if (TREE_CODE (TREE_TYPE (field)) == REFERENCE_TYPE)\n+\t    error (\"member %qD is uninitialized reference\", field);\n+\n+\t  /* Warn when some struct elements are implicitly initialized\n+\t     to zero.  */\n+\t  warning (OPT_Wmissing_field_initializers,\n+\t\t   \"missing initializer for member %qD\", field);\n+\n+\t  if (!zero_init_p (TREE_TYPE (field)))\n+\t    next = build_zero_init (TREE_TYPE (field), /*nelts=*/NULL_TREE,\n+\t\t\t\t    /*static_storage_p=*/false);\n \t  else\n \t    /* The default zero-initialization is fine for us; don't\n-\t       add anything to the CONSTRUCTOR.  */\n-\t    break;\n-\n-\t  if (next1 == error_mark_node)\n-\t    erroneous = 1;\n-\t  else if (!TREE_CONSTANT (next1))\n-\t    allconstant = 0;\n-\t  else if (! initializer_constant_valid_p (next1, TREE_TYPE (next1)))\n-\t    allsimple = 0;\n-\t  members = tree_cons (size_int (i), next1, members);\n+\t    add anything to the CONSTRUCTOR.  */\n+\t    continue;\n \t}\n+\n+      flags |= picflag_from_initializer (next);\n+      CONSTRUCTOR_APPEND_ELT (v, field, next);\n     }\n-  else if (TREE_CODE (type) == RECORD_TYPE)\n-    {\n-      tree field;\n \n-      if (tail)\n-\t{\n-\t  gcc_assert (!CLASSTYPE_VBASECLASSES (type));\n-\t  gcc_assert (!TYPE_BINFO (type)\n-\t\t      || !BINFO_N_BASE_BINFOS (TYPE_BINFO (type)));\n-\t  gcc_assert (!TYPE_POLYMORPHIC_P (type));\n-\t}\n+  CONSTRUCTOR_ELTS (init) = v;\n+  return flags;\n+}\n \n-      for (field = TYPE_FIELDS (type); field;\n-\t   field = TREE_CHAIN (field))\n-\t{\n-\t  if (! DECL_NAME (field) && DECL_C_BIT_FIELD (field))\n-\t    {\n-\t      members = tree_cons (field, integer_zero_node, members);\n-\t      continue;\n-\t    }\n+/* Subroutine of process_init_constructor, which will process a single\n+   initializer INIT for an union of type TYPE. Returns the flags (PICFLAG_*)\n+   which describe the initializer.  */\n \n-\t  if (TREE_CODE (field) != FIELD_DECL || DECL_ARTIFICIAL (field))\n-\t    continue;\n+static int\n+process_init_constructor_union (tree type, tree init)\n+{\n+  constructor_elt *ce;\n \n-\t  if (tail)\n-\t    {\n-\t      if (TREE_PURPOSE (tail)\n-\t\t  && TREE_PURPOSE (tail) != field\n-\t\t  && TREE_PURPOSE (tail) != DECL_NAME (field))\n-\t\tsorry (\"non-trivial labeled initializers\");\n-\n-\t      if (TREE_VALUE (tail) != 0)\n-\t\t{\n-\t\t  tree tail1 = tail;\n-\n-\t\t  next1 = digest_init (TREE_TYPE (field),\n-\t\t\t\t       TREE_VALUE (tail), &tail1);\n-\t\t  gcc_assert (!tail1 || TREE_CODE (tail1) == TREE_LIST);\n-\t\t  tail = tail1;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  next1 = error_mark_node;\n-\t\t  tail = TREE_CHAIN (tail);\n-\t\t}\n-\t    }\n-\t  else if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (field)))\n-\t    {\n-\t      /* If this type needs constructors run for\n-\t\t default-initialization, we can't rely on the backend to do it\n-\t\t for us, so build up TARGET_EXPRs.  If the type in question is\n-\t\t a class, just build one up; if it's an array, recurse.  */\n-\n-\t      if (IS_AGGR_TYPE (TREE_TYPE (field)))\n-\t\tnext1 = build_functional_cast (TREE_TYPE (field),\n-\t\t\t\t\t       NULL_TREE);\n-\t      else\n-\t\t{\n-\t\t  next1 = build_constructor (NULL_TREE, NULL_TREE);\n-\t\t  if (init)\n-\t\t    TREE_HAS_CONSTRUCTOR (next1)\n-\t\t       = TREE_HAS_CONSTRUCTOR (init);\n-\t\t}\n-\t      next1 = digest_init (TREE_TYPE (field), next1, 0);\n-\n-\t      /* Warn when some struct elements are implicitly initialized.  */\n-\t      if (warn_missing_field_initializers\n-\t\t  && (!init || BRACE_ENCLOSED_INITIALIZER_P (init)))\n-\t\twarning (0, \"missing initializer for member %qD\", field);\n-\t    }\n-\t  else\n+  /* If the initializer was empty, use default zero initialization.  */\n+  if (VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (init)))\n+    return 0;\n+\n+  gcc_assert (VEC_length (constructor_elt, CONSTRUCTOR_ELTS (init)) == 1);\n+  ce = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (init), 0);\n+\n+  /* If this element specifies a field, initialize via that field.  */\n+  if (ce->index)\n+    {\n+      if (TREE_CODE (ce->index) == FIELD_DECL)\n+\t;\n+      else if (TREE_CODE (ce->index) == IDENTIFIER_NODE)\n+\t{\n+\t  /* This can happen within a cast, see g++.dg/opt/cse2.C.  */\n+\t  tree name = ce->index;\n+\t  tree field;\n+\t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t    if (DECL_NAME (field) == name)\n+\t      break;\n+\t  if (!field)\n \t    {\n-\t      if (TREE_READONLY (field))\n-\t\terror (\"uninitialized const member %qD\", field);\n-\t      else if (CLASSTYPE_READONLY_FIELDS_NEED_INIT (TREE_TYPE (field)))\n-\t\terror (\"member %qD with uninitialized const fields\", field);\n-\t      else if (TREE_CODE (TREE_TYPE (field)) == REFERENCE_TYPE)\n-\t\terror (\"member %qD is uninitialized reference\", field);\n-\n-\t      /* Warn when some struct elements are implicitly initialized\n-\t\t to zero.  */\n-\t      if (warn_missing_field_initializers\n-\t\t  && (!init || BRACE_ENCLOSED_INITIALIZER_P (init)))\n-\t\twarning (0, \"missing initializer for member %qD\", field);\n-\n-\t      if (! zero_init_p (TREE_TYPE (field)))\n-\t\tnext1 = build_zero_init (TREE_TYPE (field),\n-\t\t\t\t\t /*nelts=*/NULL_TREE,\n-\t\t\t\t\t /*static_storage_p=*/false);\n-\t      else\n-\t\t/* The default zero-initialization is fine for us; don't\n-\t\t   add anything to the CONSTRUCTOR.  */\n-\t\tcontinue;\n+\t      error (\"no field %qD found in union being initialized\", field);\n+\t      ce->value = error_mark_node;\n \t    }\n-\n-\t  if (next1 == error_mark_node)\n-\t    erroneous = 1;\n-\t  else if (!TREE_CONSTANT (next1))\n-\t    allconstant = 0;\n-\t  else if (! initializer_constant_valid_p (next1, TREE_TYPE (next1)))\n-\t    allsimple = 0;\n-\t  members = tree_cons (field, next1, members);\n+\t  ce->index = field;\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (TREE_CODE (ce->index) == INTEGER_CST\n+\t\t      || TREE_CODE (ce->index) == RANGE_EXPR);\n+\t  error (\"index value instead of field name in union initializer\");\n+\t  ce->value = error_mark_node;\n \t}\n     }\n-  else if (TREE_CODE (type) == UNION_TYPE\n-\t   /* If the initializer was empty, use default zero initialization.  */\n-\t   && tail)\n+  else\n     {\n-      tree field = TYPE_FIELDS (type);\n-\n       /* Find the first named field.  ANSI decided in September 1990\n \t that only named fields count here.  */\n+      tree field = TYPE_FIELDS (type);\n       while (field && (!DECL_NAME (field) || TREE_CODE (field) != FIELD_DECL))\n \tfield = TREE_CHAIN (field);\n-\n-      /* If this element specifies a field, initialize via that field.  */\n-      if (TREE_PURPOSE (tail) != NULL_TREE)\n-\t{\n-\t  int win = 0;\n-\n-\t  if (TREE_CODE (TREE_PURPOSE (tail)) == FIELD_DECL)\n-\t    /* Handle the case of a call by build_c_cast.  */\n-\t    field = TREE_PURPOSE (tail), win = 1;\n-\t  else if (TREE_CODE (TREE_PURPOSE (tail)) != IDENTIFIER_NODE)\n-\t    error (\"index value instead of field name in union initializer\");\n-\t  else\n-\t    {\n-\t      tree temp;\n-\t      for (temp = TYPE_FIELDS (type);\n-\t\t   temp;\n-\t\t   temp = TREE_CHAIN (temp))\n-\t\tif (DECL_NAME (temp) == TREE_PURPOSE (tail))\n-\t\t  break;\n-\t      if (temp)\n-\t\tfield = temp, win = 1;\n-\t      else\n-\t\terror (\"no field %qD in union being initialized\",\n-\t\t       TREE_PURPOSE (tail));\n-\t    }\n-\t  if (!win)\n-\t    TREE_VALUE (tail) = error_mark_node;\n-\t}\n-      else if (field == 0)\n+      if (!field)\n \t{\n \t  error (\"union %qT with no named members cannot be initialized\",\n \t\t type);\n-\t  TREE_VALUE (tail) = error_mark_node;\n+\t  ce->value = error_mark_node;\n \t}\n+      ce->index = field;\n+    }\n \n-      if (TREE_VALUE (tail) != 0)\n-\t{\n-\t  tree tail1 = tail;\n+  if (ce->value && ce->value != error_mark_node)\n+    ce->value = digest_init (TREE_TYPE (ce->index), ce->value);\n \n-\t  next1 = digest_init (TREE_TYPE (field),\n-\t\t\t       TREE_VALUE (tail), &tail1);\n-\t  gcc_assert (!tail1 || TREE_CODE (tail1) == TREE_LIST);\n-\t  tail = tail1;\n-\t}\n-      else\n-\t{\n-\t  next1 = error_mark_node;\n-\t  tail = TREE_CHAIN (tail);\n-\t}\n+  return picflag_from_initializer (ce->value);\n+}\n \n-      if (next1 == error_mark_node)\n-\terroneous = 1;\n-      else if (!TREE_CONSTANT (next1))\n-\tallconstant = 0;\n-      else if (initializer_constant_valid_p (next1, TREE_TYPE (next1)) == 0)\n-\tallsimple = 0;\n-      members = tree_cons (field, next1, members);\n-    }\n+/* Process INIT, a constructor for a variable of aggregate type TYPE. The\n+   constructor is a brace-enclosed initializer, and will be modified in-place.\n+\n+   Each element is converted to the right type through digest_init, and\n+   missing initializers are added following the language rules (zero-padding,\n+   etc.).\n \n-  /* If arguments were specified as a list, just remove the ones we used.  */\n-  if (elts)\n-    *elts = tail;\n-  /* If arguments were specified as a constructor,\n-     complain unless we used all the elements of the constructor.  */\n-  else if (tail)\n-    pedwarn (\"excess elements in aggregate initializer\");\n+   After the execution, the initializer will have TREE_CONSTANT if all elts are\n+   constant, and TREE_STATIC set if, in addition, all elts are simple enough\n+   constants that the assembler and linker can compute them.\n+   \n+   The function returns the initializer itself, or error_mark_node in case\n+   of error.  */\n+\n+static tree\n+process_init_constructor (tree type, tree init)\n+{\n+  int flags;\n+\n+  gcc_assert (BRACE_ENCLOSED_INITIALIZER_P (init));\n+\n+  if (TREE_CODE (type) == ARRAY_TYPE || TREE_CODE (type) == VECTOR_TYPE)\n+    flags = process_init_constructor_array (type, init);\n+  else if (TREE_CODE (type) == RECORD_TYPE)\n+    flags = process_init_constructor_record (type, init);\n+  else if (TREE_CODE (type) == UNION_TYPE)\n+    flags = process_init_constructor_union (type, init);\n+  else\n+    gcc_unreachable ();\n \n-  if (erroneous)\n+  if (flags & PICFLAG_ERRONEOUS)\n     return error_mark_node;\n \n-  result = build_constructor (type, nreverse (members));\n+  TREE_TYPE (init) = type;\n   if (TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type) == NULL_TREE)\n-    cp_complete_array_type (&TREE_TYPE (result), result, /*do_default=*/0);\n-  if (init)\n-    TREE_HAS_CONSTRUCTOR (result) = TREE_HAS_CONSTRUCTOR (init);\n-  if (allconstant)\n+    cp_complete_array_type (&TREE_TYPE (init), init, /*do_default=*/0);\n+  if (!(flags & PICFLAG_NOT_ALL_CONSTANT))\n     {\n-      TREE_CONSTANT (result) = 1;\n-      TREE_INVARIANT (result) = 1;\n-      if (allsimple)\n-\tTREE_STATIC (result) = 1;\n+      TREE_CONSTANT (init) = 1;\n+      TREE_INVARIANT (init) = 1;\n+      if (!(flags & PICFLAG_NOT_ALL_SIMPLE))\n+\tTREE_STATIC (init) = 1;\n     }\n-  return result;\n+  return init;\n }\n \f\n /* Given a structure or union value DATUM, construct and return\n@@ -1396,7 +1329,7 @@ build_functional_cast (tree exp, tree parms)\n   if (parms == NULL_TREE && !TYPE_NEEDS_CONSTRUCTING (type)\n       && TYPE_HAS_DEFAULT_CONSTRUCTOR (type))\n     {\n-      exp = build_constructor (type, NULL_TREE);\n+      exp = build_constructor (type, NULL);\n       return get_target_expr (exp);\n     }\n "}, {"sha": "60d45f3ad2598101acd4536452dd653800c5fed0", "filename": "gcc/expr.c", "status": "modified", "additions": 78, "deletions": 80, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -4398,17 +4398,16 @@ categorize_ctor_elements_1 (tree ctor, HOST_WIDE_INT *p_nz_elts,\n \t\t\t    HOST_WIDE_INT *p_elt_count,\n \t\t\t    bool *p_must_clear)\n {\n+  unsigned HOST_WIDE_INT idx;\n   HOST_WIDE_INT nz_elts, nc_elts, elt_count;\n-  tree list;\n+  tree value, purpose;\n \n   nz_elts = 0;\n   nc_elts = 0;\n   elt_count = 0;\n \n-  for (list = CONSTRUCTOR_ELTS (ctor); list; list = TREE_CHAIN (list))\n+  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (ctor), idx, purpose, value)\n     {\n-      tree value = TREE_VALUE (list);\n-      tree purpose = TREE_PURPOSE (list);\n       HOST_WIDE_INT mult;\n \n       mult = 1;\n@@ -4482,14 +4481,16 @@ categorize_ctor_elements_1 (tree ctor, HOST_WIDE_INT *p_nz_elts,\n       tree init_sub_type;\n       bool clear_this = true;\n \n-      list = CONSTRUCTOR_ELTS (ctor);\n-      if (list)\n+      if (!VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (ctor)))\n \t{\n \t  /* We don't expect more than one element of the union to be\n \t     initialized.  Not sure what we should do otherwise... */\n-          gcc_assert (TREE_CHAIN (list) == NULL);\n+          gcc_assert (VEC_length (constructor_elt, CONSTRUCTOR_ELTS (ctor))\n+\t\t      == 1);\n \n-          init_sub_type = TREE_TYPE (TREE_VALUE (list));\n+          init_sub_type = TREE_TYPE (VEC_index (constructor_elt,\n+\t\t\t\t\t\tCONSTRUCTOR_ELTS (ctor),\n+\t\t\t\t\t\t0)->value);\n \n \t  /* ??? We could look at each element of the union, and find the\n \t     largest element.  Which would avoid comparing the size of the\n@@ -4699,7 +4700,8 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n       {\n-\ttree elt;\n+\tunsigned HOST_WIDE_INT idx;\n+\ttree field, value;\n \n \t/* If size is zero or the target is already cleared, do nothing.  */\n \tif (size == 0 || cleared)\n@@ -4731,7 +4733,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t   register whose mode size isn't equal to SIZE since\n \t   clear_storage can't handle this case.  */\n \telse if (size > 0\n-\t\t && ((list_length (CONSTRUCTOR_ELTS (exp))\n+\t\t && (((int)VEC_length (constructor_elt, CONSTRUCTOR_ELTS (exp))\n \t\t      != fields_length (type))\n \t\t     || mostly_zeros_p (exp))\n \t\t && (!REG_P (target)\n@@ -4747,11 +4749,8 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \n \t/* Store each element of the constructor into the\n \t   corresponding field of TARGET.  */\n-\n-\tfor (elt = CONSTRUCTOR_ELTS (exp); elt; elt = TREE_CHAIN (elt))\n+\tFOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (exp), idx, field, value)\n \t  {\n-\t    tree field = TREE_PURPOSE (elt);\n-\t    tree value = TREE_VALUE (elt);\n \t    enum machine_mode mode;\n \t    HOST_WIDE_INT bitsize;\n \t    HOST_WIDE_INT bitpos = 0;\n@@ -4857,8 +4856,8 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n       }\n     case ARRAY_TYPE:\n       {\n-\ttree elt;\n-\tint i;\n+\ttree value, index;\n+\tunsigned HOST_WIDE_INT i;\n \tint need_to_clear;\n \ttree domain;\n \ttree elttype = TREE_TYPE (type);\n@@ -4888,18 +4887,20 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t  need_to_clear = 1;\n \telse\n \t  {\n+\t    unsigned HOST_WIDE_INT idx;\n+\t    tree index, value;\n \t    HOST_WIDE_INT count = 0, zero_count = 0;\n \t    need_to_clear = ! const_bounds_p;\n \t    \n \t    /* This loop is a more accurate version of the loop in\n \t       mostly_zeros_p (it handles RANGE_EXPR in an index).  It\n \t       is also needed to check for missing elements.  */\n-\t    for (elt = CONSTRUCTOR_ELTS (exp);\n-\t\t elt != NULL_TREE && ! need_to_clear;\n-\t\t elt = TREE_CHAIN (elt))\n+\t    FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (exp), idx, index, value)\n \t      {\n-\t\ttree index = TREE_PURPOSE (elt);\n \t\tHOST_WIDE_INT this_node_count;\n+\n+\t\tif (need_to_clear)\n+\t\t  break;\n \t\t\n \t\tif (index != NULL_TREE && TREE_CODE (index) == RANGE_EXPR)\n \t\t  {\n@@ -4920,7 +4921,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t  this_node_count = 1;\n \t\t\n \t\tcount += this_node_count;\n-\t\tif (mostly_zeros_p (TREE_VALUE (elt)))\n+\t\tif (mostly_zeros_p (value))\n \t\t  zero_count += this_node_count;\n \t      }\n \t    \n@@ -4949,16 +4950,12 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t/* Store each element of the constructor into the\n \t   corresponding element of TARGET, determined by counting the\n \t   elements.  */\n-\tfor (elt = CONSTRUCTOR_ELTS (exp), i = 0;\n-\t     elt;\n-\t     elt = TREE_CHAIN (elt), i++)\n+\tFOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (exp), i, index, value)\n \t  {\n \t    enum machine_mode mode;\n \t    HOST_WIDE_INT bitsize;\n \t    HOST_WIDE_INT bitpos;\n \t    int unsignedp;\n-\t    tree value = TREE_VALUE (elt);\n-\t    tree index = TREE_PURPOSE (elt);\n \t    rtx xtarget = target;\n \t    \n \t    if (cleared && initializer_zerop (value))\n@@ -5118,7 +5115,8 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \n     case VECTOR_TYPE:\n       {\n-\ttree elt;\n+\tunsigned HOST_WIDE_INT idx;\n+\tconstructor_elt *ce;\n \tint i;\n \tint need_to_clear;\n \tint icode = 0;\n@@ -5158,18 +5156,17 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \telse\n \t  {\n \t    unsigned HOST_WIDE_INT count = 0, zero_count = 0;\n+\t    tree value;\n \t    \n-\t    for (elt = CONSTRUCTOR_ELTS (exp);\n-\t\t elt != NULL_TREE;\n-\t\t elt = TREE_CHAIN (elt))\n+\t    FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (exp), idx, value)\n \t      {\n \t\tint n_elts_here = tree_low_cst\n \t\t  (int_const_binop (TRUNC_DIV_EXPR,\n-\t\t\t\t    TYPE_SIZE (TREE_TYPE (TREE_VALUE (elt))),\n+\t\t\t\t    TYPE_SIZE (TREE_TYPE (value)),\n \t\t\t\t    TYPE_SIZE (elttype), 0), 1);\n \t\t\n \t\tcount += n_elts_here;\n-\t\tif (mostly_zeros_p (TREE_VALUE (elt)))\n+\t\tif (mostly_zeros_p (value))\n \t\t  zero_count += n_elts_here;\n \t      }\n \n@@ -5193,20 +5190,19 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \n         /* Store each element of the constructor into the corresponding\n \t   element of TARGET, determined by counting the elements.  */\n-\tfor (elt = CONSTRUCTOR_ELTS (exp), i = 0;\n-\t     elt;\n-\t     elt = TREE_CHAIN (elt), i += bitsize / elt_size)\n+\tfor (idx = 0, i = 0;\n+\t     VEC_iterate (constructor_elt, CONSTRUCTOR_ELTS (exp), idx, ce);\n+\t     idx++, i += bitsize / elt_size)\n \t  {\n-\t    tree value = TREE_VALUE (elt);\n-\t    tree index = TREE_PURPOSE (elt);\n \t    HOST_WIDE_INT eltpos;\n+\t    tree value = ce->value;\n \t    \n \t    bitsize = tree_low_cst (TYPE_SIZE (TREE_TYPE (value)), 1);\n \t    if (cleared && initializer_zerop (value))\n \t      continue;\n \t    \n-\t    if (index != 0)\n-\t      eltpos = tree_low_cst (index, 1);\n+\t    if (ce->index)\n+\t      eltpos = tree_low_cst (ce->index, 1);\n \t    else\n \t      eltpos = i;\n \t    \n@@ -6733,8 +6729,9 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  || GET_MODE_CLASS (TYPE_MODE (TREE_TYPE (exp))) == MODE_VECTOR_FLOAT)\n \treturn const_vector_from_tree (exp);\n       else\n-\treturn expand_expr (build1 (CONSTRUCTOR, TREE_TYPE (exp),\n-\t\t\t\t    TREE_VECTOR_CST_ELTS (exp)),\n+\treturn expand_expr (build_constructor_from_list\n+\t\t\t    (TREE_TYPE (exp),\n+\t\t\t     TREE_VECTOR_CST_ELTS (exp)),\n \t\t\t    ignore ? const0_rtx : target, tmode, modifier);\n \n     case CONST_DECL:\n@@ -6832,10 +6829,11 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t subexpressions.  */\n       if (ignore)\n \t{\n-\t  tree elt;\n+\t  unsigned HOST_WIDE_INT idx;\n+\t  tree value;\n \n-\t  for (elt = CONSTRUCTOR_ELTS (exp); elt; elt = TREE_CHAIN (elt))\n-\t    expand_expr (TREE_VALUE (elt), const0_rtx, VOIDmode, 0);\n+\t  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (exp), idx, value)\n+\t    expand_expr (value, const0_rtx, VOIDmode, 0);\n \n \t  return const0_rtx;\n \t}\n@@ -6997,16 +6995,17 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    && ! TREE_SIDE_EFFECTS (array)\n \t    && TREE_CODE (index) == INTEGER_CST)\n \t  {\n-\t    tree elem;\n-\n-\t    for (elem = CONSTRUCTOR_ELTS (array);\n-\t\t (elem && !tree_int_cst_equal (TREE_PURPOSE (elem), index));\n-\t\t elem = TREE_CHAIN (elem))\n-\t      ;\n+\t    unsigned HOST_WIDE_INT ix;\n+\t    tree field, value;\n \n-\t    if (elem && !TREE_SIDE_EFFECTS (TREE_VALUE (elem)))\n-\t      return expand_expr (fold (TREE_VALUE (elem)), target, tmode,\n-\t\t\t\t  modifier);\n+\t    FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (array), ix,\n+\t\t\t\t      field, value)\n+\t      if (tree_int_cst_equal (field, index))\n+\t\t{\n+\t\t  if (!TREE_SIDE_EFFECTS (value))\n+\t\t    return expand_expr (fold (value), target, tmode, modifier);\n+\t\t  break;\n+\t\t}\n \t  }\n \n \telse if (optimize >= 1\n@@ -7024,17 +7023,18 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n \t\tif (TREE_CODE (init) == CONSTRUCTOR)\n \t\t  {\n-\t\t    tree elem;\n-\n-\t\t    for (elem = CONSTRUCTOR_ELTS (init);\n-\t\t\t (elem\n-\t\t\t  && !tree_int_cst_equal (TREE_PURPOSE (elem), index));\n-\t\t\t elem = TREE_CHAIN (elem))\n-\t\t      ;\n-\n-\t\t    if (elem && !TREE_SIDE_EFFECTS (TREE_VALUE (elem)))\n-\t\t      return expand_expr (fold (TREE_VALUE (elem)), target,\n-\t\t\t\t\t  tmode, modifier);\n+\t\t    unsigned HOST_WIDE_INT ix;\n+\t\t    tree field, value;\n+\n+\t\t    FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (init), ix,\n+\t\t\t\t\t      field, value)\n+\t\t      if (tree_int_cst_equal (field, index))\n+\t\t\t{\n+\t\t\t  if (!TREE_SIDE_EFFECTS (value))\n+\t\t\t    return expand_expr (fold (value), target, tmode,\n+\t\t\t\t\t\tmodifier);\n+\t\t\t  break;\n+\t\t\t}\n \t\t  }\n \t\telse if (TREE_CODE (init) == STRING_CST\n \t\t\t && 0 > compare_tree_int (index,\n@@ -7058,36 +7058,34 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t appropriate field if it is present.  */\n       if (TREE_CODE (TREE_OPERAND (exp, 0)) == CONSTRUCTOR)\n \t{\n-\t  tree elt;\n+\t  unsigned HOST_WIDE_INT idx;\n+\t  tree field, value;\n \n-\t  for (elt = CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0)); elt;\n-\t       elt = TREE_CHAIN (elt))\n-\t    if (TREE_PURPOSE (elt) == TREE_OPERAND (exp, 1)\n+\t  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0)),\n+\t\t\t\t    idx, field, value)\n+\t    if (field == TREE_OPERAND (exp, 1)\n \t\t/* We can normally use the value of the field in the\n \t\t   CONSTRUCTOR.  However, if this is a bitfield in\n \t\t   an integral mode that we can fit in a HOST_WIDE_INT,\n \t\t   we must mask only the number of bits in the bitfield,\n \t\t   since this is done implicitly by the constructor.  If\n \t\t   the bitfield does not meet either of those conditions,\n \t\t   we can't do this optimization.  */\n-\t\t&& (! DECL_BIT_FIELD (TREE_PURPOSE (elt))\n-\t\t    || ((GET_MODE_CLASS (DECL_MODE (TREE_PURPOSE (elt)))\n-\t\t\t == MODE_INT)\n-\t\t\t&& (GET_MODE_BITSIZE (DECL_MODE (TREE_PURPOSE (elt)))\n+\t\t&& (! DECL_BIT_FIELD (field)\n+\t\t    || ((GET_MODE_CLASS (DECL_MODE (field)) == MODE_INT)\n+\t\t\t&& (GET_MODE_BITSIZE (DECL_MODE (field))\n \t\t\t    <= HOST_BITS_PER_WIDE_INT))))\n \t      {\n-\t\tif (DECL_BIT_FIELD (TREE_PURPOSE (elt))\n+\t\tif (DECL_BIT_FIELD (field)\n \t\t    && modifier == EXPAND_STACK_PARM)\n \t\t  target = 0;\n-\t\top0 = expand_expr (TREE_VALUE (elt), target, tmode, modifier);\n-\t\tif (DECL_BIT_FIELD (TREE_PURPOSE (elt)))\n+\t\top0 = expand_expr (value, target, tmode, modifier);\n+\t\tif (DECL_BIT_FIELD (field))\n \t\t  {\n-\t\t    HOST_WIDE_INT bitsize\n-\t\t      = TREE_INT_CST_LOW (DECL_SIZE (TREE_PURPOSE (elt)));\n-\t\t    enum machine_mode imode\n-\t\t      = TYPE_MODE (TREE_TYPE (TREE_PURPOSE (elt)));\n+\t\t    HOST_WIDE_INT bitsize = TREE_INT_CST_LOW (DECL_SIZE (field));\n+\t\t    enum machine_mode imode = TYPE_MODE (TREE_TYPE (field));\n \n-\t\t    if (TYPE_UNSIGNED (TREE_TYPE (TREE_PURPOSE (elt))))\n+\t\t    if (TYPE_UNSIGNED (TREE_TYPE (field)))\n \t\t      {\n \t\t\top1 = GEN_INT (((HOST_WIDE_INT) 1 << bitsize) - 1);\n \t\t\top0 = expand_and (imode, op0, op1, target);"}, {"sha": "273a912d4e4ccb621d619e95c06d4639b3b84f1a", "filename": "gcc/fold-const.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -9861,9 +9861,11 @@ fold_ternary (enum tree_code code, tree type, tree op0, tree op1, tree op2)\n       if (TREE_CODE (arg0) == CONSTRUCTOR\n \t  && ! type_contains_placeholder_p (TREE_TYPE (arg0)))\n \t{\n-\t  tree m = purpose_member (arg1, CONSTRUCTOR_ELTS (arg0));\n-\t  if (m)\n-\t    return TREE_VALUE (m);\n+\t  unsigned HOST_WIDE_INT idx;\n+\t  tree field, value;\n+\t  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (arg0), idx, field, value)\n+\t    if (field == arg1)\n+\t      return value;\n \t}\n       return NULL_TREE;\n "}, {"sha": "80a1538e14935a420aabf96e768de98718fed529", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -1,3 +1,14 @@\n+2005-07-20  Giovanni Bajo  <giovannibajo@libero.it>\n+\n+\tMake CONSTRUCTOR use VEC to store initializers.\n+\t* trans-array.c (gfc_build_null_descriptor,\n+\tgfc_trans_array_constructor_value, gfc_conv_array_initializer):\n+\tUpdate to cope with VEC in CONSTRUCTOR_ELTS.\n+\t* trans-common.c (create_common): Likewise.\n+\t* trans-expr.c (gfc_conv_structure): Likewise.\n+\t* trans-stmt.c (gfc_trans_character_select): Use\n+\tbuild_constructor_from_list instead of build_constructor.\n+\n 2005-07-19 Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/16940"}, {"sha": "e634154cc72723058ed301a6e4ac7e694fec0586", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -299,8 +299,7 @@ gfc_build_null_descriptor (tree type)\n   field = TYPE_FIELDS (type);\n \n   /* Set a NULL data pointer.  */\n-  tmp = tree_cons (field, null_pointer_node, NULL_TREE);\n-  tmp = build1 (CONSTRUCTOR, type, tmp);\n+  tmp = build_constructor_single (type, field, null_pointer_node);\n   TREE_CONSTANT (tmp) = 1;\n   TREE_INVARIANT (tmp) = 1;\n   /* All other fields are ignored.  */\n@@ -834,7 +833,7 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t\t\t\t\t  gfc_index_zero_node, bound);\n \t      tmptype = build_array_type (type, tmptype);\n \n-\t      init = build1 (CONSTRUCTOR, tmptype, nreverse (list));\n+\t      init = build_constructor_from_list (tmptype, nreverse (list));\n \t      TREE_CONSTANT (init) = 1;\n \t      TREE_INVARIANT (init) = 1;\n \t      TREE_STATIC (init) = 1;\n@@ -2833,15 +2832,14 @@ tree\n gfc_conv_array_initializer (tree type, gfc_expr * expr)\n {\n   gfc_constructor *c;\n-  tree list;\n   tree tmp;\n   mpz_t maxval;\n   gfc_se se;\n   HOST_WIDE_INT hi;\n   unsigned HOST_WIDE_INT lo;\n   tree index, range;\n+  VEC(constructor_elt,gc) *v = NULL;\n \n-  list = NULL_TREE;\n   switch (expr->expr_type)\n     {\n     case EXPR_CONSTANT:\n@@ -2865,15 +2863,15 @@ gfc_conv_array_initializer (tree type, gfc_expr * expr)\n       /* This will probably eat buckets of memory for large arrays.  */\n       while (hi != 0 || lo != 0)\n         {\n-          list = tree_cons (NULL_TREE, se.expr, list);\n+\t  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, se.expr);\n           if (lo == 0)\n             hi--;\n           lo--;\n         }\n       break;\n \n     case EXPR_ARRAY:\n-      /* Create a list of all the elements.  */\n+      /* Create a vector of all the elements.  */\n       for (c = expr->value.constructor; c; c = c->next)\n         {\n           if (c->iterator)\n@@ -2917,34 +2915,32 @@ gfc_conv_array_initializer (tree type, gfc_expr * expr)\n \t    case EXPR_CONSTANT:\n \t      gfc_conv_constant (&se, c->expr);\n               if (range == NULL_TREE)\n-                list = tree_cons (index, se.expr, list);\n+\t\tCONSTRUCTOR_APPEND_ELT (v, index, se.expr);\n               else\n                 {\n                   if (index != NULL_TREE)\n-                    list = tree_cons (index, se.expr, list);\n-                  list = tree_cons (range, se.expr, list);\n+\t\t    CONSTRUCTOR_APPEND_ELT (v, index, se.expr);\n+\t\t  CONSTRUCTOR_APPEND_ELT (v, range, se.expr);\n                 }\n \t      break;\n \n \t    case EXPR_STRUCTURE:\n               gfc_conv_structure (&se, c->expr, 1);\n-              list = tree_cons (index, se.expr, list);\n+\t      CONSTRUCTOR_APPEND_ELT (v, index, se.expr);\n \t      break;\n \n \t    default:\n \t      gcc_unreachable ();\n \t    }\n         }\n-      /* We created the list in reverse order.  */\n-      list = nreverse (list);\n       break;\n \n     default:\n       gcc_unreachable ();\n     }\n \n   /* Create a constructor from the list of elements.  */\n-  tmp = build1 (CONSTRUCTOR, type, list);\n+  tmp = build_constructor (type, v);\n   TREE_CONSTANT (tmp) = 1;\n   TREE_INVARIANT (tmp) = 1;\n   return tmp;"}, {"sha": "4defe0f6af3a2cdf834847243bdfbf8e13e9939a", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -422,10 +422,10 @@ create_common (gfc_common_head *com, segment_info * head, bool saw_equiv)\n \n   if (is_init)\n     {\n-      tree list, ctor, tmp;\n+      tree ctor, tmp;\n       HOST_WIDE_INT offset = 0;\n+      VEC(constructor_elt,gc) *v = NULL;\n \n-      list = NULL_TREE;\n       for (s = head; s; s = s->next)\n         {\n           if (s->sym->value)\n@@ -442,20 +442,25 @@ create_common (gfc_common_head *com, segment_info * head, bool saw_equiv)\n \t      tmp = gfc_conv_initializer (s->sym->value, &s->sym->ts,\n \t\t  TREE_TYPE (s->field), s->sym->attr.dimension,\n \t\t  s->sym->attr.pointer || s->sym->attr.allocatable);\n-\t      list = tree_cons (s->field, tmp, list);\n+\n+\t      CONSTRUCTOR_APPEND_ELT (v, s->field, tmp);\n               offset = s->offset + s->length;\n             }\n         }\n-      gcc_assert (list);\n-      ctor = build1 (CONSTRUCTOR, union_type, nreverse(list));\n+      gcc_assert (!VEC_empty (constructor_elt, v));\n+      ctor = build_constructor (union_type, v);\n       TREE_CONSTANT (ctor) = 1;\n       TREE_INVARIANT (ctor) = 1;\n       TREE_STATIC (ctor) = 1;\n       DECL_INITIAL (decl) = ctor;\n \n #ifdef ENABLE_CHECKING\n-      for (tmp = CONSTRUCTOR_ELTS (ctor); tmp; tmp = TREE_CHAIN (tmp))\n-\tgcc_assert (TREE_CODE (TREE_PURPOSE (tmp)) == FIELD_DECL);\n+      {\n+\ttree field, value;\n+\tunsigned HOST_WIDE_INT idx;\n+\tFOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (ctor), idx, field, value)\n+\t  gcc_assert (TREE_CODE (field) == FIELD_DECL);\n+      }\n #endif\n     }\n "}, {"sha": "0cd8741758c82c9290c449173723a5a6d6d16598", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -1812,11 +1812,10 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n {\n   gfc_constructor *c;\n   gfc_component *cm;\n-  tree head;\n-  tree tail;\n   tree val;\n   tree type;\n   tree tmp;\n+  VEC(constructor_elt,gc) *v = NULL;\n \n   gcc_assert (se->ss == NULL);\n   gcc_assert (expr->expr_type == EXPR_STRUCTURE);\n@@ -1831,9 +1830,6 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n       return;\n     }\n \n-  head = build1 (CONSTRUCTOR, type, NULL_TREE);\n-  tail = NULL_TREE;\n-\n   cm = expr->ts.derived->components;\n   for (c = expr->value.constructor; c; c = c->next, cm = cm->next)\n     {\n@@ -1844,19 +1840,10 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n       val = gfc_conv_initializer (c->expr, &cm->ts,\n \t  TREE_TYPE (cm->backend_decl), cm->dimension, cm->pointer);\n \n-      /* Build a TREE_CHAIN to hold it.  */\n-      val = tree_cons (cm->backend_decl, val, NULL_TREE);\n-\n-      /* Add it to the list.  */\n-      if (tail == NULL_TREE)\n-        TREE_OPERAND(head, 0) = tail = val;\n-      else\n-        {\n-          TREE_CHAIN (tail) = val;\n-          tail = val;\n-        }\n+      /* Append it to the constructor list.  */\n+      CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, val);\n     }\n-  se->expr = head;\n+  se->expr = build_constructor (type, v);\n }\n \n "}, {"sha": "99467b4945fe02e4170cb7db23b203a245e29a97", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -1220,14 +1220,14 @@ gfc_trans_character_select (gfc_code *code)\n       tmp = gfc_build_addr_expr (pvoid_type_node, labels[i]);\n       node = tree_cons (ss_target, tmp, node);\n \n-      tmp = build1 (CONSTRUCTOR, select_struct, nreverse (node));\n+      tmp = build_constructor_from_list (select_struct, nreverse (node));\n       init = tree_cons (NULL_TREE, tmp, init);\n     }\n \n   type = build_array_type (select_struct, build_index_type\n \t\t\t   (build_int_cst (NULL_TREE, n - 1)));\n \n-  init = build1 (CONSTRUCTOR, type, nreverse(init));\n+  init = build_constructor_from_list (type, nreverse(init));\n   TREE_CONSTANT (init) = 1;\n   TREE_INVARIANT (init) = 1;\n   TREE_STATIC (init) = 1;"}, {"sha": "bb08c2b140f78442b0f3d70c256368560e81be70", "filename": "gcc/gimplify.c", "status": "modified", "additions": 66, "deletions": 57, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -2385,9 +2385,12 @@ gimplify_init_ctor_preeval (tree *expr_p, tree *pre_p, tree *post_p,\n   /* Recurse for nested constructors.  */\n   if (TREE_CODE (*expr_p) == CONSTRUCTOR)\n     {\n-      tree list;\n-      for (list = CONSTRUCTOR_ELTS (*expr_p); list ; list = TREE_CHAIN (list))\n-\tgimplify_init_ctor_preeval (&TREE_VALUE (list), pre_p, post_p, data);\n+      unsigned HOST_WIDE_INT ix;\n+      constructor_elt *ce;\n+      VEC(constructor_elt,gc) *v = CONSTRUCTOR_ELTS (*expr_p);\n+\n+      for (ix = 0; VEC_iterate (constructor_elt, v, ix, ce); ix++)\n+\tgimplify_init_ctor_preeval (&ce->value, pre_p, post_p, data);\n       return;\n     }\n \n@@ -2446,7 +2449,8 @@ gimplify_init_ctor_preeval (tree *expr_p, tree *pre_p, tree *post_p,\n    Note that we never have to deal with SAVE_EXPRs here, because this has\n    already been taken care of for us, in gimplify_init_ctor_preeval().  */\n \n-static void gimplify_init_ctor_eval (tree, tree, tree *, bool);\n+static void gimplify_init_ctor_eval (tree, VEC(constructor_elt,gc) *,\n+\t\t\t\t     tree *, bool);\n \n static void\n gimplify_init_ctor_eval_range (tree object, tree lower, tree upper,\n@@ -2530,24 +2534,24 @@ zero_sized_field_decl (tree fdecl)\n \n /* A subroutine of gimplify_init_constructor.  Generate individual\n    MODIFY_EXPRs for a CONSTRUCTOR.  OBJECT is the LHS against which the\n-   assignments should happen.  LIST is the CONSTRUCTOR_ELTS of the\n+   assignments should happen.  ELTS is the CONSTRUCTOR_ELTS of the\n    CONSTRUCTOR.  CLEARED is true if the entire LHS object has been\n    zeroed first.  */\n \n static void\n-gimplify_init_ctor_eval (tree object, tree list, tree *pre_p, bool cleared)\n+gimplify_init_ctor_eval (tree object, VEC(constructor_elt,gc) *elts,\n+\t\t\t tree *pre_p, bool cleared)\n {\n   tree array_elt_type = NULL;\n+  unsigned HOST_WIDE_INT ix;\n+  tree purpose, value;\n \n   if (TREE_CODE (TREE_TYPE (object)) == ARRAY_TYPE)\n     array_elt_type = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (object)));\n \n-  for (; list; list = TREE_CHAIN (list))\n+  FOR_EACH_CONSTRUCTOR_ELT (elts, ix, purpose, value)\n     {\n-      tree purpose, value, cref, init;\n-\n-      purpose = TREE_PURPOSE (list);\n-      value = TREE_VALUE (list);\n+      tree cref, init;\n \n       /* NULL values are created above for gimplification errors.  */\n       if (value == NULL)\n@@ -2617,7 +2621,7 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n   tree ctor = TREE_OPERAND (*expr_p, 1);\n   tree type = TREE_TYPE (ctor);\n   enum gimplify_status ret;\n-  tree elt_list;\n+  VEC(constructor_elt,gc) *elts;\n \n   if (TREE_CODE (ctor) != CONSTRUCTOR)\n     return GS_UNHANDLED;\n@@ -2628,7 +2632,7 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n     return ret;\n   object = TREE_OPERAND (*expr_p, 0);\n \n-  elt_list = CONSTRUCTOR_ELTS (ctor);\n+  elts = CONSTRUCTOR_ELTS (ctor);\n \n   ret = GS_ALL_DONE;\n   switch (TREE_CODE (type))\n@@ -2646,7 +2650,7 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t/* Aggregate types must lower constructors to initialization of\n \t   individual elements.  The exception is that a CONSTRUCTOR node\n \t   with no elements indicates zero-initialization of the whole.  */\n-\tif (elt_list == NULL)\n+\tif (VEC_empty (constructor_elt, elts))\n \t  break;\n \n \tcategorize_ctor_elements (ctor, &num_nonzero_elements,\n@@ -2758,7 +2762,7 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t    /* Zap the CONSTRUCTOR element list, which simplifies this case.\n \t       Note that we still have to gimplify, in order to handle the\n \t       case of variable sized types.  Avoid shared tree structures.  */\n-\t    CONSTRUCTOR_ELTS (ctor) = NULL_TREE;\n+\t    CONSTRUCTOR_ELTS (ctor) = NULL;\n \t    object = unshare_expr (object);\n \t    gimplify_stmt (expr_p);\n \t    append_to_statement_list (*expr_p, pre_p);\n@@ -2776,7 +2780,7 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \n \t    gimplify_init_ctor_preeval (&TREE_OPERAND (*expr_p, 1),\n \t\t\t\t\tpre_p, post_p, &preeval_data);\n-\t    gimplify_init_ctor_eval (object, elt_list, pre_p, cleared);\n+\t    gimplify_init_ctor_eval (object, elts, pre_p, cleared);\n \t  }\n \n \t*expr_p = NULL_TREE;\n@@ -2788,17 +2792,9 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \ttree r, i;\n \n \t/* Extract the real and imaginary parts out of the ctor.  */\n-\tr = i = NULL_TREE;\n-\tif (elt_list)\n-\t  {\n-\t    r = TREE_VALUE (elt_list);\n-\t    elt_list = TREE_CHAIN (elt_list);\n-\t    if (elt_list)\n-\t      {\n-\t\ti = TREE_VALUE (elt_list);\n-\t\tgcc_assert (!TREE_CHAIN (elt_list));\n-\t      }\n-\t  }\n+\tgcc_assert (VEC_length (constructor_elt, elts) == 2);\n+\tr = VEC_index (constructor_elt, elts, 0)->value;\n+\ti = VEC_index (constructor_elt, elts, 1)->value;\n \tif (r == NULL || i == NULL)\n \t  {\n \t    tree zero = convert (TREE_TYPE (type), integer_zero_node);\n@@ -2827,35 +2823,44 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n       break;\n \n     case VECTOR_TYPE:\n-      /* Go ahead and simplify constant constructors to VECTOR_CST.  */\n-      if (TREE_CONSTANT (ctor))\n-\t{\n-\t  tree tem;\n+      {\n+\tunsigned HOST_WIDE_INT ix;\n+\tconstructor_elt *ce;\n \n-\t  /* Even when ctor is constant, it might contain non-*_CST\n-\t     elements (e.g. { 1.0/0.0 - 1.0/0.0, 0.0 }) and those don't\n-\t     belong into VECTOR_CST nodes.  */\n-\t  for (tem = elt_list; tem; tem = TREE_CHAIN (tem))\n-\t    if (! CONSTANT_CLASS_P (TREE_VALUE (tem)))\n-\t      break;\n+\t/* Go ahead and simplify constant constructors to VECTOR_CST.  */\n+\tif (TREE_CONSTANT (ctor))\n+\t  {\n+\t    bool constant_p = true;\n+\t    tree value;\n+\n+\t    /* Even when ctor is constant, it might contain non-*_CST\n+\t      elements (e.g. { 1.0/0.0 - 1.0/0.0, 0.0 }) and those don't\n+\t      belong into VECTOR_CST nodes.  */\n+\t    FOR_EACH_CONSTRUCTOR_VALUE (elts, ix, value)\n+\t      if (!CONSTANT_CLASS_P (value))\n+\t\t{\n+\t\t  constant_p = false;\n+\t\t  break;\n+\t\t}\n \n-\t  if (! tem)\n-\t    {\n-\t      TREE_OPERAND (*expr_p, 1) = build_vector (type, elt_list);\n-\t      break;\n-\t    }\n-\t}\n+\t    if (constant_p)\n+\t      {\n+\t\tTREE_OPERAND (*expr_p, 1) = build_vector_from_ctor (type, elts);\n+\t\tbreak;\n+\t      }\n+\t  }\n \n-      /* Vector types use CONSTRUCTOR all the way through gimple\n-\t compilation as a general initializer.  */\n-      for (; elt_list; elt_list = TREE_CHAIN (elt_list))\n-\t{\n-\t  enum gimplify_status tret;\n-\t  tret = gimplify_expr (&TREE_VALUE (elt_list), pre_p, post_p,\n-\t\t\t\tis_gimple_val, fb_rvalue);\n-\t  if (tret == GS_ERROR)\n-\t    ret = GS_ERROR;\n-\t}\n+\t/* Vector types use CONSTRUCTOR all the way through gimple\n+\t  compilation as a general initializer.  */\n+\tfor (ix = 0; VEC_iterate (constructor_elt, elts, ix, ce); ix++)\n+\t  {\n+\t    enum gimplify_status tret;\n+\t    tret = gimplify_expr (&ce->value, pre_p, post_p,\n+\t\t\t\t  is_gimple_val, fb_rvalue);\n+\t    if (tret == GS_ERROR)\n+\t      ret = GS_ERROR;\n+\t  }\n+      }\n       break;\n \n     default:\n@@ -4159,10 +4164,14 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t     gimplify any element that has side-effects.  */\n \t  if (fallback == fb_none)\n \t    {\n-\t      for (tmp = CONSTRUCTOR_ELTS (*expr_p); tmp;\n-\t\t   tmp = TREE_CHAIN (tmp))\n-\t\tif (TREE_SIDE_EFFECTS (TREE_VALUE (tmp)))\n-\t\t  gimplify_expr (&TREE_VALUE (tmp), pre_p, post_p,\n+\t      unsigned HOST_WIDE_INT ix;\n+\t      constructor_elt *ce;\n+\t      for (ix = 0;\n+\t\t   VEC_iterate (constructor_elt, CONSTRUCTOR_ELTS (*expr_p),\n+\t\t\t\tix, ce);\n+\t\t   ix++)\n+\t\tif (TREE_SIDE_EFFECTS (ce->value))\n+\t\t  gimplify_expr (&ce->value, pre_p, post_p,\n \t\t\t\t gimple_test_f, fallback);\n \n \t      *expr_p = NULL_TREE;"}, {"sha": "1b6eccf3a04df7f319966729b6291a24fd70afbb", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -1,3 +1,26 @@\n+2005-07-20  Giovanni Bajo  <giovannibajo@libero.it>\n+\n+\tMake CONSTRUCTOR use VEC to store initializers.\n+\t* check-init.c (check_init): Update to cope with VEC in\n+\tCONSTRUCTOR_ELTS.\n+\t* class.c (make_field_value, make_method_value, get_dispatch_table,\n+\tmake_class_data, emit_symbol_table, emit_catch_table,\n+\temit_assertion_table): Use build_constructor_from_list instead of\n+\tbuild_constructor.\n+\t* constants.c (build_constants_constructor): Likewise.\n+\t* java-gimplify.c (java_gimplify_new_array_init): Update to cope with\n+\tVEC in CONSTRUCTOR_ELTS.\n+\t* java-tree.h (START_RECORD_CONSTRUCTOR, PUSH_SUPER_VALUE,\n+\tPUSH_FIELD_VALUE, FINISH_RECORD_CONSTRUCTOR): Create a VEC instead\n+\tof a TREE_LIST.\n+\t* jcf-write.c (generate_bytecode_insns): Update to cope with VEC in\n+\tCONSTRUCTOR_ELTS.\n+\t* parse.y (build_new_array_init): Use build_constructor_from_list\n+\tinstead of build_constructor.\n+\t(patch_new_array_init): Update to cope with VEC in\n+\tCONSTRUCTOR_ELTS.\n+\t(array_constructor_check_entry): Likewise.\n+\n 2005-07-12  Tom Tromey  <tromey@redhat.com>\n \n \t* jvspec.c (lang_specific_driver): Put filelist_filename first on"}, {"sha": "377ac78630b7bf08f1497a511187a5267db79797", "filename": "gcc/java/check-init.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -918,9 +918,11 @@ check_init (tree exp, words before)\n \n     case NEW_ARRAY_INIT:\n       {\n-\ttree x = CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0));\n-\tfor ( ;  x != NULL_TREE;  x = TREE_CHAIN (x))\n-\t  check_init (TREE_VALUE (x), before);\n+\ttree value;\n+\tunsigned HOST_WIDE_INT idx;\n+\tFOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0)),\n+\t\t\t\t    idx, value)\n+\t  check_init (value, before);\n       }\n       break;\n "}, {"sha": "c2bd62f7a7326ecce339bb571d6beb665ff33ebb", "filename": "gcc/java/class.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -1278,7 +1278,7 @@ make_field_value (tree fdecl)\n \n   PUSH_FIELD_VALUE\n     (finit, \"info\",\n-     build_constructor (field_info_union_node,\n+     build_constructor_from_list (field_info_union_node,\n \t    build_tree_list\n \t    ((FIELD_STATIC (fdecl)\n \t      ? TREE_CHAIN (TYPE_FIELDS (field_info_union_node))\n@@ -1359,7 +1359,7 @@ make_method_value (tree mdecl)\n \t    table = tree_cons (NULL_TREE, utf8, table);\n \t  }\n \ttype = build_prim_array_type (ptr_type_node, length);\n-\ttable = build_constructor (type, table);\n+\ttable = build_constructor_from_list (type, table);\n \t/* Compute something unique enough.  */\n \tsprintf (buf, \"_methods%d\", method_name_count++);\n \tarray = build_decl (VAR_DECL, get_identifier (buf), type);\n@@ -1480,8 +1480,9 @@ get_dispatch_table (tree type, tree this_class_addr)\n   if (TARGET_VTABLE_USES_DESCRIPTORS)\n     arraysize *= TARGET_VTABLE_USES_DESCRIPTORS;\n   arraysize += 2;\n-  return build_constructor (build_prim_array_type (nativecode_ptr_type_node,\n-\t\t\t\t\t\t   arraysize), list);\n+  return build_constructor_from_list\n+\t  (build_prim_array_type (nativecode_ptr_type_node,\n+\t\t\t\t  arraysize), list);\n }\n \n \n@@ -1608,8 +1609,8 @@ make_class_data (tree type)\n       field_array_type = build_prim_array_type (field_type_node, field_count);\n       fields_decl = build_decl (VAR_DECL, mangled_classname (\"_FL_\", type),\n \t\t\t\tfield_array_type);\n-      DECL_INITIAL (fields_decl) = build_constructor (field_array_type,\n-\t\t\t\t\t\t      static_fields);\n+      DECL_INITIAL (fields_decl) = build_constructor_from_list\n+\t\t\t\t    (field_array_type, static_fields);\n       TREE_STATIC (fields_decl) = 1;\n       DECL_ARTIFICIAL (fields_decl) = 1;\n       DECL_IGNORED_P (fields_decl) = 1;\n@@ -1639,8 +1640,8 @@ make_class_data (tree type)\n   method_array_type = build_prim_array_type (method_type_node, method_count);\n   methods_decl = build_decl (VAR_DECL, mangled_classname (\"_MT_\", type),\n \t\t\t     method_array_type);\n-  DECL_INITIAL (methods_decl) = build_constructor (method_array_type,\n-\t\t\t\t\t\t   nreverse (methods));\n+  DECL_INITIAL (methods_decl) = build_constructor_from_list\n+\t\t\t\t (method_array_type, nreverse (methods));\n   TREE_STATIC (methods_decl) = 1;\n   DECL_ARTIFICIAL (methods_decl) = 1;\n   DECL_IGNORED_P (methods_decl) = 1;\n@@ -1715,7 +1716,8 @@ make_class_data (tree type)\n \t    }\n \t  init = tree_cons (NULL_TREE, index, init); \n \t}\n-      DECL_INITIAL (idecl) = build_constructor (interface_array_type, init);\n+      DECL_INITIAL (idecl) = build_constructor_from_list (interface_array_type,\n+\t\t\t\t\t\t\t  init);\n       TREE_STATIC (idecl) = 1;\n       DECL_ARTIFICIAL (idecl) = 1;\n       DECL_IGNORED_P (idecl) = 1;\n@@ -2528,7 +2530,7 @@ emit_symbol_table (tree name, tree the_table, tree decl_list,\n \n   /* Put the list in the right order and make it a constructor. */\n   list = nreverse (list);\n-  table = build_constructor (symbols_array_type, list);  \n+  table = build_constructor_from_list (symbols_array_type, list);  \n \n   /* Make it the initial value for otable_syms and emit the decl. */\n   DECL_INITIAL (the_syms_decl) = table;\n@@ -2589,7 +2591,7 @@ emit_catch_table (tree this_class)\n   table = \n     build_decl (VAR_DECL, DECL_NAME (TYPE_CTABLE_DECL (this_class)), array_type);\n   DECL_INITIAL (table) = \n-    build_constructor (array_type, TYPE_CATCH_CLASSES (this_class));\n+    build_constructor_from_list (array_type, TYPE_CATCH_CLASSES (this_class));\n   TREE_STATIC (table) = 1;\n   TREE_READONLY (table) = 1;  \n   DECL_IGNORED_P (table) = 1;\n@@ -2669,7 +2671,7 @@ emit_assertion_table (tree class)\n   \n   /* Put the list in the right order and make it a constructor. */\n   list = nreverse (list);\n-  ctor = build_constructor (assertion_table_type, list);\n+  ctor = build_constructor_from_list (assertion_table_type, list);\n \n   table_decl = build_decl (VAR_DECL, mangled_classname (\"_type_assert_\", class),\n \t\t\t   assertion_table_type);"}, {"sha": "bba67a708ebb9596861cc1a8deb92fb35094ce80", "filename": "gcc/java/constants.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -515,8 +515,8 @@ build_constants_constructor (void)\n   \n       data_decl = build_constant_data_ref ();\n       TREE_TYPE (data_decl) = build_array_type (ptr_type_node, index_type);\n-      DECL_INITIAL (data_decl) = build_constructor (TREE_TYPE (data_decl),\n-\t\t\t\t\t\t    data_list);\n+      DECL_INITIAL (data_decl) = build_constructor_from_list\n+\t\t\t\t  (TREE_TYPE (data_decl), data_list);\n       DECL_SIZE (data_decl) = TYPE_SIZE (TREE_TYPE (data_decl));\n       DECL_SIZE_UNIT (data_decl) = TYPE_SIZE_UNIT (TREE_TYPE (data_decl));\n       rest_of_decl_compilation (data_decl, 1, 0);\n@@ -527,7 +527,8 @@ build_constants_constructor (void)\n \t\t\t\t\t\t\t   current_class),\n \t\t\t      tags_type);\n       TREE_STATIC (tags_decl) = 1;\n-      DECL_INITIAL (tags_decl) = build_constructor (tags_type, tags_list);\n+      DECL_INITIAL (tags_decl) = build_constructor_from_list\n+\t\t\t\t (tags_type, tags_list);\n       rest_of_decl_compilation (tags_decl, 1, 0);\n       tags_value = build_address_of (tags_decl);\n     }"}, {"sha": "cbc174d8f02bcb97f7e3e57bf6f295d925f51781", "filename": "gcc/java/java-gimplify.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fjava%2Fjava-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fjava%2Fjava-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-gimplify.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -296,7 +296,8 @@ java_gimplify_new_array_init (tree exp)\n   HOST_WIDE_INT ilength = java_array_type_length (array_type);\n   tree length = build_int_cst (NULL_TREE, ilength);\n   tree init = TREE_OPERAND (exp, 0);\n-  tree values = CONSTRUCTOR_ELTS (init);\n+  tree value;\n+  unsigned HOST_WIDE_INT cnt;\n \n   tree array_ptr_type = build_pointer_type (array_type);\n   tree tmp = create_tmp_var (array_ptr_type, \"array\");\n@@ -306,7 +307,7 @@ java_gimplify_new_array_init (tree exp)\n   int index = 0;\n \n   /* FIXME: try to allocate array statically?  */\n-  while (values != NULL_TREE)\n+  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (init), cnt, value)\n     {\n       /* FIXME: Should use build_java_arrayaccess here, but avoid\n \t bounds checking.  */\n@@ -317,9 +318,8 @@ java_gimplify_new_array_init (tree exp)\n \t\t\t\tbuild4 (ARRAY_REF, element_type, lhs,\n \t\t\t\t\tbuild_int_cst (NULL_TREE, index++),\n \t\t\t\t\tNULL_TREE, NULL_TREE),\n-\t\t\t\tTREE_VALUE (values));\n+\t\t\t\tvalue);\n       body = build2 (COMPOUND_EXPR, element_type, body, assignment);\n-      values = TREE_CHAIN (values);\n     }\n \n   return build2 (COMPOUND_EXPR, array_ptr_type, body, tmp);"}, {"sha": "ab6157b7c61a1ef95018aaa06037a1bb5f2e9fb4", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -1762,41 +1762,49 @@ extern tree *type_map;\n #define FINISH_RECORD(RTYPE) layout_type (RTYPE)\n \n /* Start building a RECORD_TYPE constructor with a given TYPE in CONS. */\n-#define START_RECORD_CONSTRUCTOR(CONS, CTYPE)\t\\\n-{ CONS = build_constructor ((CTYPE), NULL_TREE);\t\\\n-  TREE_CHAIN (CONS) = TYPE_FIELDS (CTYPE); }\n+#define START_RECORD_CONSTRUCTOR(CONS, CTYPE) \\\n+  do \\\n+    { \\\n+      CONS = build_constructor ((CTYPE), VEC_alloc (constructor_elt, gc, 0)); \\\n+      CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (CONS), TYPE_FIELDS (CTYPE), \\\n+\t\t\t      NULL); \\\n+    } \\\n+  while (0)\n \n /* Append a field initializer to CONS for the dummy field for the inherited\n    fields.  The dummy field has the given VALUE, and the same type as the\n    super-class.   Must be specified before calls to PUSH_FIELD_VALUE. */\n-#define PUSH_SUPER_VALUE(CONS, VALUE)\t\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  tree _field = TREE_CHAIN (CONS);\t\t\t\\\n-  if (DECL_NAME (_field) != NULL_TREE)\t\t\t\\\n-    abort ();\t\t\t\t\t\t\\\n-  CONSTRUCTOR_ELTS (CONS)\t\t\t\t\\\n-    = tree_cons (_field, (VALUE), CONSTRUCTOR_ELTS (CONS)); \\\n-  TREE_CHAIN (CONS) = TREE_CHAIN (_field);\t\t\\\n-}\n+#define PUSH_SUPER_VALUE(CONS, VALUE) \\\n+  do \\\n+    { \\\n+      constructor_elt *_elt___ = VEC_last (constructor_elt, \\\n+\t\t\t\t\t   CONSTRUCTOR_ELTS (CONS)); \\\n+      tree _next___ = TREE_CHAIN (_elt___->index); \\\n+      gcc_assert (!DECL_NAME (_elt___->index)); \\\n+      _elt___->value = VALUE; \\\n+      CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (CONS), _next___, NULL); \\\n+    } \\\n+  while (0)\n \n /* Append a field initializer to CONS for a field with the given VALUE.\n    NAME is a char* string used for error checking;\n    the initializer must be specified in order. */\n #define PUSH_FIELD_VALUE(CONS, NAME, VALUE) \t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  tree _field = TREE_CHAIN (CONS);\t\t\t\t\t\\\n-  if (strcmp (IDENTIFIER_POINTER (DECL_NAME (_field)), NAME) != 0) \t\\\n-    abort ();\t\t\t\t\t\t\t\t\\\n-  CONSTRUCTOR_ELTS (CONS)\t\t\t\t\t\t\\\n-    = tree_cons (_field, (VALUE), CONSTRUCTOR_ELTS (CONS));\t\t\\\n-  TREE_CHAIN (CONS) = TREE_CHAIN (_field); \t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n-while (0)\n+  do \\\n+    { \\\n+      constructor_elt *_elt___ = VEC_last (constructor_elt, \\\n+\t\t\t\t\t   CONSTRUCTOR_ELTS (CONS)); \\\n+      tree _next___ = TREE_CHAIN (_elt___->index); \\\n+      gcc_assert (strcmp (IDENTIFIER_POINTER (DECL_NAME (_elt___->index)), \\\n+\t\t\t  NAME) == 0); \\\n+      _elt___->value = VALUE; \\\n+      CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (CONS), _next___, NULL); \\\n+    } \\\n+  while (0)\n \n /* Finish creating a record CONSTRUCTOR CONS. */\n #define FINISH_RECORD_CONSTRUCTOR(CONS) \\\n-  CONSTRUCTOR_ELTS(CONS) = nreverse (CONSTRUCTOR_ELTS (CONS))\n+  VEC_pop (constructor_elt, CONSTRUCTOR_ELTS (CONS))\n \n /* Macros on constructors invocations.  */\n #define CALL_CONSTRUCTOR_P(NODE)\t\t\\"}, {"sha": "45764995143ab15451690b988e450f1cd111cd8a", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -2461,14 +2461,16 @@ generate_bytecode_insns (tree exp, int target, struct jcf_partial *state)\n       break;\n     case NEW_ARRAY_INIT:\n       {\n-\ttree values = CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0));\n+\tVEC(constructor_elt,gc) *v = CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0));\n \ttree array_type = TREE_TYPE (TREE_TYPE (exp));\n \ttree element_type = TYPE_ARRAY_ELEMENT (array_type);\n+\tunsigned HOST_WIDE_INT idx;\n+\ttree value;\n \tHOST_WIDE_INT length = java_array_type_length (array_type);\n \tif (target == IGNORE_TARGET)\n \t  {\n-\t    for ( ;  values != NULL_TREE;  values = TREE_CHAIN (values))\n-\t      generate_bytecode_insns (TREE_VALUE (values), target, state);\n+\t    FOR_EACH_CONSTRUCTOR_VALUE (v, idx, value)\n+\t      generate_bytecode_insns (value, target, state);\n \t    break;\n \t  }\n \tpush_int_const (length, state);\n@@ -2489,16 +2491,17 @@ generate_bytecode_insns (tree exp, int target, struct jcf_partial *state)\n \t  }\n \toffset = 0;\n \tjopcode = OPCODE_iastore + adjust_typed_op (element_type, 7);\n-\tfor ( ;  values != NULL_TREE;  values = TREE_CHAIN (values), offset++)\n+\tFOR_EACH_CONSTRUCTOR_VALUE (v, idx, value)\n \t  {\n \t    int save_SP = state->code_SP;\n \t    emit_dup (1, 0, state);\n \t    push_int_const (offset, state);\n \t    NOTE_PUSH (1);\n-\t    generate_bytecode_insns (TREE_VALUE (values), STACK_TARGET, state);\n+\t    generate_bytecode_insns (value, STACK_TARGET, state);\n \t    RESERVE (1);\n \t    OP1 (jopcode);\n \t    state->code_SP = save_SP;\n+\t    offset++;\n \t  }\n       }\n       break;"}, {"sha": "10a37e0e449a2888a2bd38b58e05ce76cd16d53d", "filename": "gcc/java/parse.y", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -274,7 +274,7 @@ static void missing_return_error (tree);\n static tree build_new_array_init (int, tree);\n static tree patch_new_array_init (tree, tree);\n static tree maybe_build_array_element_wfl (tree);\n-static int array_constructor_check_entry (tree, tree);\n+static int array_constructor_check_entry (tree, constructor_elt *);\n static const char *purify_type_name (const char *);\n static tree fold_constant_for_init (tree, tree);\n static jdeplist *reverse_jdep_list (struct parser_ctxt *);\n@@ -14793,7 +14793,8 @@ maybe_build_array_element_wfl (tree node)\n static tree\n build_new_array_init (int location, tree values)\n {\n-  tree constructor = build_constructor (NULL_TREE, values);\n+  tree constructor = build_constructor_from_list (NULL_TREE,\n+\t\t\t\t\t\t  nreverse (values));\n   tree to_return = build1 (NEW_ARRAY_INIT, NULL_TREE, constructor);\n   EXPR_WFL_LINECOL (to_return) = location;\n   return to_return;\n@@ -14807,8 +14808,9 @@ static tree\n patch_new_array_init (tree type, tree node)\n {\n   int error_seen = 0;\n-  tree current, element_type;\n-  HOST_WIDE_INT length;\n+  tree element_type;\n+  unsigned HOST_WIDE_INT length;\n+  constructor_elt *current;\n   int all_constant = 1;\n   tree init = TREE_OPERAND (node, 0);\n \n@@ -14822,25 +14824,25 @@ patch_new_array_init (tree type, tree node)\n   type = TREE_TYPE (type);\n   element_type = TYPE_ARRAY_ELEMENT (type);\n \n-  CONSTRUCTOR_ELTS (init) = nreverse (CONSTRUCTOR_ELTS (init));\n-\n-  for (length = 0, current = CONSTRUCTOR_ELTS (init);\n-       current;  length++, current = TREE_CHAIN (current))\n+  for (length = 0;\n+       VEC_iterate (constructor_elt, CONSTRUCTOR_ELTS (init),\n+\t\t    length, current);\n+       length++)\n     {\n-      tree elt = TREE_VALUE (current);\n+      tree elt = current->value;\n       if (elt == NULL_TREE || TREE_CODE (elt) != NEW_ARRAY_INIT)\n \t{\n \t  error_seen |= array_constructor_check_entry (element_type, current);\n-\t  elt = TREE_VALUE (current);\n+\t  elt = current->value;\n \t  /* When compiling to native code, STRING_CST is converted to\n \t     INDIRECT_REF, but still with a TREE_CONSTANT flag. */\n \t  if (! TREE_CONSTANT (elt) || TREE_CODE (elt) == INDIRECT_REF)\n \t    all_constant = 0;\n \t}\n       else\n \t{\n-\t  TREE_VALUE (current) = patch_new_array_init (element_type, elt);\n-\t  TREE_PURPOSE (current) = NULL_TREE;\n+\t  current->value = patch_new_array_init (element_type, elt);\n+\t  current->index = NULL_TREE;\n \t  all_constant = 0;\n \t}\n       if (elt && TREE_CODE (elt) == TREE_LIST\n@@ -14869,16 +14871,16 @@ patch_new_array_init (tree type, tree node)\n    otherwise.  */\n \n static int\n-array_constructor_check_entry (tree type, tree entry)\n+array_constructor_check_entry (tree type, constructor_elt *entry)\n {\n   char *array_type_string = NULL;\t/* For error reports */\n   tree value, type_value, new_value, wfl_value, patched;\n   int error_seen = 0;\n \n   new_value = NULL_TREE;\n-  wfl_value = TREE_VALUE (entry);\n+  wfl_value = entry->value;\n \n-  value = java_complete_tree (TREE_VALUE (entry));\n+  value = java_complete_tree (entry->value);\n   /* patch_string return error_mark_node if arg is error_mark_node */\n   if ((patched = patch_string (value)))\n     value = patched;\n@@ -14889,7 +14891,7 @@ array_constructor_check_entry (tree type, tree entry)\n \n   /* At anytime, try_builtin_assignconv can report a warning on\n      constant overflow during narrowing. */\n-  SET_WFL_OPERATOR (wfl_operator, TREE_PURPOSE (entry), wfl_value);\n+  SET_WFL_OPERATOR (wfl_operator, entry->index, wfl_value);\n   new_value = try_builtin_assignconv (wfl_operator, type, value);\n   if (!new_value && (new_value = try_reference_assignconv (type, value)))\n     type_value = promote_type (type);\n@@ -14908,12 +14910,12 @@ array_constructor_check_entry (tree type, tree entry)\n     }\n \n   if (new_value)\n-    TREE_VALUE (entry) = new_value;\n+    entry->value = new_value;\n \n   if (array_type_string)\n     free (array_type_string);\n \n-  TREE_PURPOSE (entry) = NULL_TREE;\n+  entry->index = NULL_TREE;\n   return error_seen;\n }\n "}, {"sha": "31a1e8f91594cffd09c10b2e801756aaa3cf0865", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -1,3 +1,9 @@\n+2005-07-20  Giovanni Bajo  <giovannibajo@libero.it>\n+\n+\tMake CONSTRUCTOR use VEC to store initializers.\n+\t* objc-act.c (objc_build_constructor): Use build_constructor_from_list\n+\tinstead of build_constructor.\n+\n 2005-07-08  Daniel Berlin  <dberlin@dberlin.org>\n \t\n \t* objc-act.c (objc_push_parm): DECL_ARG_TYPE_AS_WRITTEN is"}, {"sha": "d004fb5eb0481e107848460308f6bbf846eca1eb", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -2001,7 +2001,7 @@ objc_add_static_instance (tree constructor, tree class_decl)\n static tree\n objc_build_constructor (tree type, tree elts)\n {\n-  tree constructor = build_constructor (type, elts);\n+  tree constructor = build_constructor_from_list (type, elts);\n \n   TREE_CONSTANT (constructor) = 1;\n   TREE_STATIC (constructor) = 1;"}, {"sha": "5d69c6faca40801d466b3572f6f98bf3d1fd4b0c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -1,3 +1,10 @@\n+2005-07-20  Giovanni Bajo  <giovannibajo@libero.it>\n+\n+\tMake CONSTRUCTOR use VEC to store initializers.\n+\t* g++.dg/ext/complit3.C: Check for specific error messages.\n+\t* g++.dg/init/brace2.C: Update error message.\n+\t* g++.dg/warn/Wbraces2.C: Likewise.\n+\n 2005-07-19 Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/16940"}, {"sha": "1783a08bdc7988dbce0d8dce5d8a0ce7c803cf49", "filename": "gcc/testsuite/g++.dg/ext/complit3.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcomplit3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcomplit3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcomplit3.C?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -2,7 +2,7 @@\n \n int Compound_Literals_0()\n {\n-  static int y[] = (int []) {1, 2, 3}; // { dg-error \"\" }\n-  static int z[] = (int [3]) {1}; // { dg-error \"\" }\n+  static int y[] = (int []) {1, 2, 3}; // { dg-error \"compound literal\" }\n+  static int z[] = (int [3]) {1}; // { dg-error \"compound literal\" }\n   return y[0]+z[0]; \n }"}, {"sha": "5138430e5cb1b41b051543dae4ed314e830eff1a", "filename": "gcc/testsuite/g++.dg/init/brace2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fbrace2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fbrace2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fbrace2.C?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -3,6 +3,6 @@\n int x = { 2 };\n const char * y = { \"hello\" };\n int a = 2;\n-int b = { 2,3 }; // { dg-error \"requires one element\" }\n+int b = { 2,3 }; // { dg-error \"too many initializers\" }\n int c = { { 2 } } ; // { dg-error \"braces around scalar initializer\" }\n "}, {"sha": "6d54ede9b4cc4b6c1114e02ea5d26e16264c1e96", "filename": "gcc/testsuite/g++.dg/warn/Wbraces2.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWbraces2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWbraces2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWbraces2.C?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -2,14 +2,14 @@\n // { dg-options \"-Wmissing-braces\" }\n int a[2][2] = { 0, 1, 2, 3 };\t\t\t // { dg-warning \"missing braces\" }\n int b[2][2] = { { 0, 1 }, { 2, 3 } };\n-int c[2][2] = { { { 0 }, 1 }, { 2, 3 } };\t // { dg-error \"brace-enclosed\" }\n+int c[2][2] = { { { 0 }, 1 }, { 2, 3 } };\t // { dg-error \"braces around scalar\" }\n struct S { char s[6]; int i; };\n S d = { \"hello\", 1 };\n S e = { { \"hello\" }, 1 };\n-S f = { { { \"hello\" } }, 1 };\t\t\t // { dg-error \"brace-enclosed\" }\n+S f = { { { \"hello\" } }, 1 };\t\t\t // { dg-error \"braces around scalar\" }\n S g = { 'h', 'e', 'l', 'l', 'o', '\\0', 1 };\t // { dg-warning \"missing braces\" }\n struct T { wchar_t s[6]; int i; };\n T i = { L\"hello\", 1 };\n T j = { { L\"hello\" }, 1 };\n-T k = { { { L\"hello\" } }, 1 };\t\t\t // { dg-error \"brace-enclosed\" }\n+T k = { { { L\"hello\" } }, 1 };\t\t\t // { dg-error \"braces around scalar\" }\n T l = { L'h', L'e', L'l', L'l', L'o', L'\\0', 1 };// { dg-warning \"missing braces\" }"}, {"sha": "2beecc744568a34ad8561d4c7345b9901aa9b08b", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -583,7 +583,17 @@ dequeue_and_dump (dump_info_p di)\n       break;\n \n     case CONSTRUCTOR:\n-      dump_child (\"elts\", CONSTRUCTOR_ELTS (t));\n+      {\n+\tunsigned HOST_WIDE_INT cnt;\n+\ttree index, value;\n+\tdump_int (di, \"lngt\", VEC_length (constructor_elt,\n+\t\t\t\t\t  CONSTRUCTOR_ELTS (t)));\n+\tFOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (t), cnt, index, value)\n+\t  {\n+\t    dump_child (\"idx\", index);\n+\t    dump_child (\"val\", value);\n+\t  }\n+      }\n       break;\n \n     case BIND_EXPR:"}, {"sha": "ff7ea43a10564f44b995370afe40a644333af9f6", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -2395,7 +2395,22 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n       if (TREE_CODE (*tp) == BIND_EXPR)\n \tBIND_EXPR_BLOCK (*tp) = NULL_TREE;\n     }\n+  else if (code == CONSTRUCTOR)\n+    {\n+      /* CONSTRUCTOR nodes need special handling because\n+         we need to duplicate the vector of elements.  */\n+      tree new;\n+\n+      new = copy_node (*tp);\n+\n+      /* Propagate mudflap marked-ness.  */\n+      if (flag_mudflap && mf_marked_p (*tp))\n+        mf_mark (new);\n \n+      CONSTRUCTOR_ELTS (new) = VEC_copy (constructor_elt, gc,\n+\t\t\t\t\t CONSTRUCTOR_ELTS (*tp));\n+      *tp = new;\n+    }\n   else if (TREE_CODE_CLASS (code) == tcc_type)\n     *walk_subtrees = 0;\n   else if (TREE_CODE_CLASS (code) == tcc_declaration)"}, {"sha": "d7bfe8c129c982a14250dc54fa760899ed184f87", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -778,36 +778,29 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \n     case CONSTRUCTOR:\n       {\n-\ttree lnode;\n+\tunsigned HOST_WIDE_INT ix;\n+\ttree field, val;\n \tbool is_struct_init = FALSE;\n \tpp_character (buffer, '{');\n-\tlnode = CONSTRUCTOR_ELTS (node);\n \tif (TREE_CODE (TREE_TYPE (node)) == RECORD_TYPE\n \t    || TREE_CODE (TREE_TYPE (node)) == UNION_TYPE)\n \t  is_struct_init = TRUE;\n-\twhile (lnode && lnode != error_mark_node)\n+\tFOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (node), ix, field, val)\n \t  {\n-\t    tree val;\n-\t    if (TREE_PURPOSE (lnode) && is_struct_init)\n+\t    if (field && is_struct_init)\n \t      {\n \t\tpp_character (buffer, '.');\n-\t\tdump_generic_node (buffer, TREE_PURPOSE (lnode), spc, flags, false);\n+\t\tdump_generic_node (buffer, field, spc, flags, false);\n \t\tpp_string (buffer, \"=\");\n \t      }\n-\t    val = TREE_VALUE (lnode);\n \t    if (val && TREE_CODE (val) == ADDR_EXPR)\n \t      if (TREE_CODE (TREE_OPERAND (val, 0)) == FUNCTION_DECL)\n \t\tval = TREE_OPERAND (val, 0);\n \t    if (val && TREE_CODE (val) == FUNCTION_DECL)\n-\t      {\n \t\tdump_decl_name (buffer, val, flags);\n-\t      }\n \t    else\n-\t      {\n-\t\tdump_generic_node (buffer, TREE_VALUE (lnode), spc, flags, false);\n-\t      }\n-\t    lnode = TREE_CHAIN (lnode);\n-\t    if (lnode && TREE_CODE (lnode) == TREE_LIST)\n+\t\tdump_generic_node (buffer, val, spc, flags, false);\n+\t    if (ix != VEC_length (constructor_elt, CONSTRUCTOR_ELTS (node)) - 1)\n \t      {\n \t\tpp_character (buffer, ',');\n \t\tpp_space (buffer);"}, {"sha": "0d839d8cbb7a007b0157ec67b8188f3399b4efba", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -1642,6 +1642,8 @@ generate_element_init_1 (struct sra_elt *elt, tree init, tree *list_p)\n   enum tree_code init_code;\n   struct sra_elt *sub;\n   tree t;\n+  unsigned HOST_WIDE_INT idx;\n+  tree value, purpose;\n \n   /* We can be passed DECL_INITIAL of a static variable.  It might have a\n      conversion, which we strip off here.  */\n@@ -1675,11 +1677,8 @@ generate_element_init_1 (struct sra_elt *elt, tree init, tree *list_p)\n       break;\n \n     case CONSTRUCTOR:\n-      for (t = CONSTRUCTOR_ELTS (init); t ; t = TREE_CHAIN (t))\n+      FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (init), idx, purpose, value)\n \t{\n-\t  tree purpose = TREE_PURPOSE (t);\n-\t  tree value = TREE_VALUE (t);\n-\n \t  if (TREE_CODE (purpose) == RANGE_EXPR)\n \t    {\n \t      tree lower = TREE_OPERAND (purpose, 0);"}, {"sha": "95a2fa1386465b552c6d90f43218963951c640a3", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -936,7 +936,9 @@ static tree\n fold_const_aggregate_ref (tree t)\n {\n   prop_value_t *value;\n-  tree base, ctor, idx, field, elt;\n+  tree base, ctor, idx, field;\n+  unsigned HOST_WIDE_INT cnt;\n+  tree cfield, cval;\n \n   switch (TREE_CODE (t))\n     {\n@@ -993,13 +995,9 @@ fold_const_aggregate_ref (tree t)\n \t}\n \n       /* Whoo-hoo!  I'll fold ya baby.  Yeah!  */\n-      for (elt = CONSTRUCTOR_ELTS (ctor);\n-\t   (elt && !tree_int_cst_equal (TREE_PURPOSE (elt), idx));\n-\t   elt = TREE_CHAIN (elt))\n-\t;\n-\n-      if (elt)\n-\treturn TREE_VALUE (elt);\n+      FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (ctor), cnt, cfield, cval)\n+\tif (tree_int_cst_equal (cfield, idx))\n+\t  return cval;\n       break;\n \n     case COMPONENT_REF:\n@@ -1035,11 +1033,11 @@ fold_const_aggregate_ref (tree t)\n \n       field = TREE_OPERAND (t, 1);\n \n-      for (elt = CONSTRUCTOR_ELTS (ctor); elt; elt = TREE_CHAIN (elt))\n-\tif (TREE_PURPOSE (elt) == field\n+      FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (ctor), cnt, cfield, cval)\n+\tif (cfield == field\n \t    /* FIXME: Handle bit-fields.  */\n-\t    && ! DECL_BIT_FIELD (TREE_PURPOSE (elt)))\n-\t  return TREE_VALUE (elt);\n+\t    && ! DECL_BIT_FIELD (cfield))\n+\t  return cval;\n       break;\n \n     default:"}, {"sha": "2044394337fad4634c43261d2ed30a9d06d6a054", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -1390,10 +1390,13 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n       {\n \t/* General aggregate CONSTRUCTORs have been decomposed, but they\n \t   are still in use as the COMPLEX_EXPR equivalent for vectors.  */\n+\tconstructor_elt *ce;\n+\tunsigned HOST_WIDE_INT idx;\n \n-\ttree t;\n-\tfor (t = TREE_OPERAND (expr, 0); t ; t = TREE_CHAIN (t))\n-\t  get_expr_operands (stmt, &TREE_VALUE (t), opf_none);\n+\tfor (idx = 0;\n+\t     VEC_iterate (constructor_elt, CONSTRUCTOR_ELTS (expr), idx, ce);\n+\t     idx++)\n+\t  get_expr_operands (stmt, &ce->value, opf_none);\n \n \treturn;\n       }"}, {"sha": "f9c9fda31047271902754e05f3f5fd4585984106", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -207,23 +207,25 @@ expand_vector_piecewise (block_stmt_iterator *bsi, elem_op_func f,\n \t\t\t tree type, tree inner_type,\n \t\t\t tree a, tree b, enum tree_code code)\n {\n-  tree head, *chain = &head;\n+  VEC(constructor_elt,gc) *v;\n   tree part_width = TYPE_SIZE (inner_type);\n   tree index = bitsize_int (0);\n   int nunits = TYPE_VECTOR_SUBPARTS (type);\n   int delta = tree_low_cst (part_width, 1)\n \t      / tree_low_cst (TYPE_SIZE (TREE_TYPE (type)), 1);\n   int i;\n \n+  v = VEC_alloc(constructor_elt, gc, (nunits + delta - 1) / delta);\n   for (i = 0; i < nunits;\n        i += delta, index = int_const_binop (PLUS_EXPR, index, part_width, 0))\n     {\n       tree result = f (bsi, inner_type, a, b, index, part_width, code);\n-      *chain = tree_cons (NULL_TREE, result, NULL_TREE);\n-      chain = &TREE_CHAIN (*chain);\n+      constructor_elt *ce = VEC_quick_push (constructor_elt, v, NULL);\n+      ce->index = NULL_TREE;\n+      ce->value = result;\n     }\n \n-  return build1 (CONSTRUCTOR, type, head);\n+  return build_constructor (type, v);\n }\n \n /* Expand a vector operation to scalars with the freedom to use"}, {"sha": "c2a8f0d9dc4e173d6b270d41c228a7460f44a1af", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -596,7 +596,8 @@ vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n             t = tree_cons (NULL_TREE, def, t);\n           }\n \n-        vec_inv = build_constructor (vectype, t);\n+\t/* FIXME: use build_constructor directly.  */\n+        vec_inv = build_constructor_from_list (vectype, t);\n         return vect_init_vector (stmt, vec_inv);\n       }\n \n@@ -771,7 +772,7 @@ get_initial_def_for_reduction (tree stmt, tree init_val, tree *scalar_def)\n   if (TREE_CODE (init_val) == INTEGER_CST || TREE_CODE (init_val) == REAL_CST)\n     vec = build_vector (vectype, t);\n   else\n-    vec = build_constructor (vectype, t);\n+    vec = build_constructor_from_list (vectype, t);\n     \n   if (!need_epilog_adjust)\n     {"}, {"sha": "4863cb76f3648cd4a2385fea27625522313a2085", "filename": "gcc/tree-vn.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree-vn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree-vn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vn.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -182,7 +182,8 @@ set_value_handle (tree e, tree v)\n {\n   if (TREE_CODE (e) == SSA_NAME)\n     SSA_NAME_VALUE (e) = v;\n-  else if (EXPR_P (e) || DECL_P (e) || TREE_CODE (e) == TREE_LIST)\n+  else if (EXPR_P (e) || DECL_P (e) || TREE_CODE (e) == TREE_LIST\n+\t   || TREE_CODE (e) == CONSTRUCTOR)\n     get_tree_ann (e)->common.value_handle = v;\n   else\n     /* Do nothing.  Constants are their own value handles.  */\n@@ -287,7 +288,8 @@ get_value_handle (tree expr)\n \n   if (TREE_CODE (expr) == SSA_NAME)\n     return SSA_NAME_VALUE (expr);\n-  else if (EXPR_P (expr) || DECL_P (expr) || TREE_CODE (expr) == TREE_LIST)\n+  else if (EXPR_P (expr) || DECL_P (expr) || TREE_CODE (expr) == TREE_LIST\n+\t   || TREE_CODE (expr) == CONSTRUCTOR)\n     {\n       tree_ann_t ann = tree_ann (expr);\n       return ((ann) ? ann->common.value_handle : NULL_TREE);"}, {"sha": "770ed31385672d94bb504f39a4cc6bedf3c94ee9", "filename": "gcc/tree.c", "status": "modified", "additions": 104, "deletions": 19, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -93,6 +93,7 @@ static const char * const tree_node_kind_names[] = {\n   \"binfos\",\n   \"phi_nodes\",\n   \"ssa names\",\n+  \"constructors\",\n   \"random kinds\",\n   \"lang_decl kinds\",\n   \"lang_type kinds\"\n@@ -328,6 +329,7 @@ tree_code_size (enum tree_code code)\n \tcase STATEMENT_LIST:\treturn sizeof (struct tree_statement_list);\n \tcase BLOCK:\t\treturn sizeof (struct tree_block);\n \tcase VALUE_HANDLE:\treturn sizeof (struct tree_value_handle);\n+\tcase CONSTRUCTOR:\treturn sizeof (struct tree_constructor);\n \n \tdefault:\n \t  return lang_hooks.tree_size (code);\n@@ -418,7 +420,7 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n \t  kind = id_kind;\n \t  break;\n \n-\tcase TREE_VEC:;\n+\tcase TREE_VEC:\n \t  kind = vec_kind;\n \t  break;\n \n@@ -438,6 +440,10 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n \t  kind = b_kind;\n \t  break;\n \n+\tcase CONSTRUCTOR:\n+\t  kind = constr_kind;\n+\t  break;\n+\n \tdefault:\n \t  kind = x_kind;\n \t  break;\n@@ -904,27 +910,72 @@ build_vector (tree type, tree vals)\n   return v;\n }\n \n+/* Return a new VECTOR_CST node whose type is TYPE and whose values\n+   are extracted from V, a vector of CONSTRUCTOR_ELT.  */\n+\n+tree\n+build_vector_from_ctor (tree type, VEC(constructor_elt,gc) *v)\n+{\n+  tree list = NULL_TREE;\n+  unsigned HOST_WIDE_INT idx;\n+  tree value;\n+\n+  FOR_EACH_CONSTRUCTOR_VALUE (v, idx, value)\n+    list = tree_cons (NULL_TREE, value, list);\n+  return build_vector (type, nreverse (list));\n+}\n+\n /* Return a new CONSTRUCTOR node whose type is TYPE and whose values\n-   are in a list pointed to by VALS.  */\n+   are in the VEC pointed by VALS.  */\n tree\n-build_constructor (tree type, tree vals)\n+build_constructor (tree type, VEC(constructor_elt,gc) *vals)\n {\n   tree c = make_node (CONSTRUCTOR);\n   TREE_TYPE (c) = type;\n   CONSTRUCTOR_ELTS (c) = vals;\n+  return c;\n+}\n+\n+/* Build a CONSTRUCTOR node made of a single initializer, with the specified\n+   INDEX and VALUE.  */\n+tree\n+build_constructor_single (tree type, tree index, tree value)\n+{\n+  VEC(constructor_elt,gc) *v;\n+  constructor_elt *elt;\n+\n+  v = VEC_alloc (constructor_elt, gc, 1);\n+  elt = VEC_quick_push (constructor_elt, v, NULL);\n+  elt->index = index;\n+  elt->value = value;\n+\n+  return build_constructor (type, v);\n+}\n+\n+\n+/* Return a new CONSTRUCTOR node whose type is TYPE and whose values\n+   are in a list pointed to by VALS.  */\n+tree\n+build_constructor_from_list (tree type, tree vals)\n+{\n+  tree t;\n+  VEC(constructor_elt,gc) *v = NULL;\n \n-  /* ??? May not be necessary.  Mirrors what build does.  */\n   if (vals)\n     {\n-      TREE_SIDE_EFFECTS (c) = TREE_SIDE_EFFECTS (vals);\n-      TREE_READONLY (c) = TREE_READONLY (vals);\n-      TREE_CONSTANT (c) = TREE_CONSTANT (vals);\n-      TREE_INVARIANT (c) = TREE_INVARIANT (vals);\n+      v = VEC_alloc (constructor_elt, gc, list_length (vals));\n+      for (t = vals; t; t = TREE_CHAIN (t))\n+\t{\n+\t  constructor_elt *elt = VEC_quick_push (constructor_elt, v, NULL);\n+\t  elt->index = TREE_PURPOSE (t);\n+\t  elt->value = TREE_VALUE (t);\n+\t}\n     }\n \n-  return c;\n+  return build_constructor (type, v);\n }\n \n+\n /* Return a new REAL_CST node whose type is TYPE and value is D.  */\n \n tree\n@@ -1951,6 +2002,7 @@ tree_node_structure (tree t)\n     case PLACEHOLDER_EXPR:\treturn TS_COMMON;\n     case STATEMENT_LIST:\treturn TS_STATEMENT_LIST;\n     case BLOCK:\t\t\treturn TS_BLOCK;\n+    case CONSTRUCTOR:\t\treturn TS_CONSTRUCTOR;\n     case TREE_BINFO:\t\treturn TS_BINFO;\n     case VALUE_HANDLE:\t\treturn TS_VALUE_HANDLE;\n \n@@ -4321,8 +4373,21 @@ simple_cst_equal (tree t1, tree t2)\n \t\t\t TREE_STRING_LENGTH (t1)));\n \n     case CONSTRUCTOR:\n-      return simple_cst_list_equal (CONSTRUCTOR_ELTS (t1),\n-\t                            CONSTRUCTOR_ELTS (t2));\n+      {\n+\tunsigned HOST_WIDE_INT idx;\n+\tVEC(constructor_elt, gc) *v1 = CONSTRUCTOR_ELTS (t1);\n+\tVEC(constructor_elt, gc) *v2 = CONSTRUCTOR_ELTS (t2);\n+\n+\tif (VEC_length (constructor_elt, v1) != VEC_length (constructor_elt, v2))\n+\t  return false;\n+\n+        for (idx = 0; idx < VEC_length (constructor_elt, v1); ++idx)\n+\t  /* ??? Should we handle also fields here? */\n+\t  if (!simple_cst_equal (VEC_index (constructor_elt, v1, idx)->value,\n+\t\t\t\t VEC_index (constructor_elt, v2, idx)->value))\n+\t    return false;\n+\treturn true;\n+      }\n \n     case SAVE_EXPR:\n       return simple_cst_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n@@ -4530,6 +4595,17 @@ iterative_hash_expr (tree t, hashval_t val)\n       for (; t; t = TREE_CHAIN (t))\n \tval = iterative_hash_expr (TREE_VALUE (t), val);\n       return val;\n+    case CONSTRUCTOR:\n+      {\n+\tunsigned HOST_WIDE_INT idx;\n+\ttree field, value;\n+\tFOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (t), idx, field, value)\n+\t  {\n+\t    val = iterative_hash_expr (field, val);\n+\t    val = iterative_hash_expr (value, val);\n+\t  }\n+\treturn val;\n+      }\n     case FUNCTION_DECL:\n       /* When referring to a built-in FUNCTION_DECL, use the\n \t __builtin__ form.  Otherwise nodes that compare equal\n@@ -6402,14 +6478,14 @@ initializer_zerop (tree init)\n       return true;\n \n     case CONSTRUCTOR:\n-      elt = CONSTRUCTOR_ELTS (init);\n-      if (elt == NULL_TREE)\n-\treturn true;\n+      {\n+\tunsigned HOST_WIDE_INT idx;\n \n-      for (; elt ; elt = TREE_CHAIN (elt))\n-\tif (! initializer_zerop (TREE_VALUE (elt)))\n-\t  return false;\n-      return true;\n+\tFOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (init), idx, elt)\n+\t  if (!initializer_zerop (elt))\n+\t    return false;\n+\treturn true;\n+      }\n \n     default:\n       return false;\n@@ -7057,7 +7133,16 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, struct pointer_set_t *pset)\n \t  WALK_SUBTREE_TAIL (TREE_IMAGPART (*tp));\n \n \tcase CONSTRUCTOR:\n-\t  WALK_SUBTREE_TAIL (CONSTRUCTOR_ELTS (*tp));\n+\t  {\n+\t    unsigned HOST_WIDE_INT idx;\n+\t    constructor_elt *ce;\n+\n+\t    for (idx = 0;\n+\t\t VEC_iterate(constructor_elt, CONSTRUCTOR_ELTS (*tp), idx, ce);\n+\t\t idx++)\n+\t      WALK_SUBTREE (ce->value);\n+\t  }\n+\t  break;\n \n \tcase SAVE_EXPR:\n \t  WALK_SUBTREE_TAIL (TREE_OPERAND (*tp, 0));"}, {"sha": "00b130fbc245229ca55463f7afa8f724b11ab6a0", "filename": "gcc/tree.def", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -435,19 +435,19 @@ DEFTREECODE (FILTER_EXPR, \"filter_expr\", tcc_expression, 0)\n \n /* Constructor: return an aggregate value made from specified components.\n    In C, this is used only for structure and array initializers.\n-   The operand is a list of component values made out of a chain of\n-   TREE_LIST nodes.\n+   The operand is a sequence of component values made out of a VEC of\n+   struct constructor_elt.\n \n    For ARRAY_TYPE:\n-   The TREE_PURPOSE of each node is the corresponding index.\n-   If the TREE_PURPOSE is a RANGE_EXPR, it is a short-hand for many nodes,\n-   one for each index in the range.  (If the corresponding TREE_VALUE\n+   The field INDEX of each constructor_elt is the corresponding index.\n+   If the index is a RANGE_EXPR, it is a short-hand for many nodes,\n+   one for each index in the range.  (If the corresponding field VALUE\n    has side-effects, they are evaluated once for each element.  Wrap the\n    value in a SAVE_EXPR if you want to evaluate side effects only once.)\n \n    For RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE:\n-   The TREE_PURPOSE of each node is a FIELD_DECL.  */\n-DEFTREECODE (CONSTRUCTOR, \"constructor\", tcc_expression, 1)\n+   The field INDEX of each node is a FIELD_DECL.  */\n+DEFTREECODE (CONSTRUCTOR, \"constructor\", tcc_exceptional, 0)\n \n /* The expression types are mostly straightforward, with the fourth argument\n    of DEFTREECODE saying how many operands there are."}, {"sha": "b9cd508edd0af730fffd0b900b68663490d37856", "filename": "gcc/tree.h", "status": "modified", "additions": 57, "deletions": 6, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -1190,16 +1190,64 @@ struct tree_vec GTY(())\n   tree GTY ((length (\"TREE_VEC_LENGTH ((tree)&%h)\"))) a[1];\n };\n \n+/* In a CONSTRUCTOR node.  */\n+#define CONSTRUCTOR_ELTS(NODE) (CONSTRUCTOR_CHECK (NODE)->constructor.elts)\n+\n+/* Iterate through the vector V of CONSTRUCTOR_ELT elements, yielding the\n+   value of each element (stored within VAL). IX must be a scratch variable\n+   of unsigned integer type.  */\n+#define FOR_EACH_CONSTRUCTOR_VALUE(V, IX, VAL) \\\n+  for (IX = 0; (IX >= VEC_length (constructor_elt, V)) \\\n+\t       ? false \\\n+\t       : ((VAL = VEC_index (constructor_elt, V, IX)->value), \\\n+\t       true); \\\n+       (IX)++)\n+\n+/* Iterate through the vector V of CONSTRUCTOR_ELT elements, yielding both\n+   the value of each element (stored within VAL) and its index (stored\n+   within INDEX). IX must be a scratch variable of unsigned integer type.  */\n+#define FOR_EACH_CONSTRUCTOR_ELT(V, IX, INDEX, VAL) \\\n+  for (IX = 0; (IX >= VEC_length (constructor_elt, V)) \\\n+\t       ? false \\\n+\t       : ((VAL = VEC_index (constructor_elt, V, IX)->value), \\\n+\t\t  (INDEX = VEC_index (constructor_elt, V, IX)->index), \\\n+\t       true); \\\n+       (IX)++)\n+\n+/* Append a new constructor element to V, with the specified INDEX and VAL.  */\n+#define CONSTRUCTOR_APPEND_ELT(V, INDEX, VALUE) \\\n+  do { \\\n+    constructor_elt *_ce___ = VEC_safe_push (constructor_elt, gc, V, NULL); \\\n+    _ce___->index = INDEX; \\\n+    _ce___->value = VALUE; \\\n+  } while (0)\n+\n+/* A single element of a CONSTRUCTOR. VALUE holds the actual value of the\n+   element. INDEX can optionally design the position of VALUE: in arrays,\n+   it is the index where VALUE has to be placed; in structures, it is the\n+   FIELD_DECL of the member.  */\n+typedef struct constructor_elt_d GTY(())\n+{\n+  tree index;\n+  tree value;\n+} constructor_elt;\n+\n+DEF_VEC_O(constructor_elt);\n+DEF_VEC_ALLOC_O(constructor_elt,gc);\n+\n+struct tree_constructor GTY(())\n+{\n+  struct tree_common common;\n+  VEC(constructor_elt,gc) *elts;\n+};\n+\n /* Define fields and accessors for some nodes that represent expressions.  */\n \n /* Nonzero if NODE is an empty statement (NOP_EXPR <0>).  */\n #define IS_EMPTY_STMT(NODE)\t(TREE_CODE (NODE) == NOP_EXPR \\\n \t\t\t\t && VOID_TYPE_P (TREE_TYPE (NODE)) \\\n \t\t\t\t && integer_zerop (TREE_OPERAND (NODE, 0)))\n \n-/* In a CONSTRUCTOR node.  */\n-#define CONSTRUCTOR_ELTS(NODE) TREE_OPERAND_CHECK_CODE (NODE, CONSTRUCTOR, 0)\n-\n /* In ordinary expression nodes.  */\n #define TREE_OPERAND(NODE, I) TREE_OPERAND_CHECK (NODE, I)\n #define TREE_COMPLEXITY(NODE) (EXPR_CHECK (NODE)->exp.complexity)\n@@ -2725,8 +2773,6 @@ struct tree_value_handle GTY(())\n   unsigned int id;\n };\n \f\n-\n-\n /* Define the overall contents of a tree node.\n    It may be any of the structures declared above\n    for various types of node.  */\n@@ -2764,6 +2810,7 @@ union tree_node GTY ((ptr_alias (union lang_tree_node),\n   struct tree_binfo GTY ((tag (\"TS_BINFO\"))) binfo;\n   struct tree_statement_list GTY ((tag (\"TS_STATEMENT_LIST\"))) stmt_list;\n   struct tree_value_handle GTY ((tag (\"TS_VALUE_HANDLE\"))) value_handle;\n+  struct tree_constructor GTY ((tag (\"TS_CONSTRUCTOR\"))) constructor;\n };\n \f\n /* Standard named or nameless data types of the C compiler.  */\n@@ -3104,7 +3151,10 @@ extern tree build_int_cst_type (tree, HOST_WIDE_INT);\n extern tree build_int_cstu (tree, unsigned HOST_WIDE_INT);\n extern tree build_int_cst_wide (tree, unsigned HOST_WIDE_INT, HOST_WIDE_INT);\n extern tree build_vector (tree, tree);\n-extern tree build_constructor (tree, tree);\n+extern tree build_vector_from_ctor (tree, VEC(constructor_elt,gc) *);\n+extern tree build_constructor (tree, VEC(constructor_elt,gc) *);\n+extern tree build_constructor_single (tree, tree, tree);\n+extern tree build_constructor_from_list (tree, tree);\n extern tree build_real_from_int_cst (tree, tree);\n extern tree build_complex (tree, tree, tree);\n extern tree build_string (int, const char *);\n@@ -4081,6 +4131,7 @@ typedef enum\n   binfo_kind,\n   phi_kind,\n   ssa_name_kind,\n+  constr_kind,\n   x_kind,\n   lang_decl,\n   lang_type,"}, {"sha": "bdcc4461c6af9aeb0371daea39b28236524115f2", "filename": "gcc/treestruct.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftreestruct.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Ftreestruct.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreestruct.def?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -58,3 +58,4 @@ DEFTREESTRUCT(TS_BLOCK, \"block\")\n DEFTREESTRUCT(TS_BINFO, \"binfo\")\n DEFTREESTRUCT(TS_STATEMENT_LIST, \"statement list\")\n DEFTREESTRUCT(TS_VALUE_HANDLE, \"value handle\")\n+DEFTREESTRUCT(TS_CONSTRUCTOR, \"constructor\")"}, {"sha": "e4d30974ddc9eb3230d4332f4cb112dada22dd4f", "filename": "gcc/varasm.c", "status": "modified", "additions": 67, "deletions": 45, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -2400,13 +2400,14 @@ const_hash_1 (const tree exp)\n \n     case CONSTRUCTOR:\n       {\n-\ttree link;\n+\tunsigned HOST_WIDE_INT idx;\n+\ttree value;\n \t\n \thi = 5 + int_size_in_bytes (TREE_TYPE (exp));\n \t\n-\tfor (link = CONSTRUCTOR_ELTS (exp); link; link = TREE_CHAIN (link))\n-\t  if (TREE_VALUE (link))\n-\t    hi = hi * 603 + const_hash_1 (TREE_VALUE (link));\n+\tFOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (exp), idx, value)\n+\t  if (value)\n+\t    hi = hi * 603 + const_hash_1 (value);\n \t\n \treturn hi;\n       }\n@@ -2517,7 +2518,8 @@ compare_constant (const tree t1, const tree t2)\n \n     case CONSTRUCTOR:\n       {\n-\ttree l1, l2;\n+\tVEC(constructor_elt, gc) *v1, *v2;\n+\tunsigned HOST_WIDE_INT idx;\n \t\n \ttypecode = TREE_CODE (TREE_TYPE (t1));\n \tif (typecode != TREE_CODE (TREE_TYPE (t2)))\n@@ -2540,28 +2542,34 @@ compare_constant (const tree t1, const tree t2)\n \t      return 0;\n \t  }\n \n-\tfor (l1 = CONSTRUCTOR_ELTS (t1), l2 = CONSTRUCTOR_ELTS (t2);\n-\t     l1 && l2;\n-\t     l1 = TREE_CHAIN (l1), l2 = TREE_CHAIN (l2))\n+\tv1 = CONSTRUCTOR_ELTS (t1);\n+\tv2 = CONSTRUCTOR_ELTS (t2);\n+\tif (VEC_length (constructor_elt, v1)\n+\t    != VEC_length (constructor_elt, v2))\n+\t    return 0;\n+\n+\tfor (idx = 0; idx < VEC_length (constructor_elt, v1); ++idx)\n \t  {\n+\t    constructor_elt *c1 = VEC_index (constructor_elt, v1, idx);\n+\t    constructor_elt *c2 = VEC_index (constructor_elt, v2, idx);\n+\n \t    /* Check that each value is the same...  */\n-\t    if (! compare_constant (TREE_VALUE (l1), TREE_VALUE (l2)))\n+\t    if (!compare_constant (c1->value, c2->value))\n \t      return 0;\n \t    /* ... and that they apply to the same fields!  */\n \t    if (typecode == ARRAY_TYPE)\n \t      {\n-\t\tif (! compare_constant (TREE_PURPOSE (l1),\n-\t\t\t\t\tTREE_PURPOSE (l2)))\n+\t\tif (!compare_constant (c1->index, c2->index))\n \t\t  return 0;\n \t      }\n \t    else\n \t      {\n-\t\tif (TREE_PURPOSE (l1) != TREE_PURPOSE (l2))\n+\t\tif (c1->index != c2->index)\n \t\t  return 0;\n \t      }\n \t  }\n \t\n-\treturn l1 == NULL_TREE && l2 == NULL_TREE;\n+\treturn 1;\n       }\n \n     case ADDR_EXPR:\n@@ -2645,13 +2653,19 @@ copy_constant (tree exp)\n     case CONSTRUCTOR:\n       {\n \ttree copy = copy_node (exp);\n-\ttree list = copy_list (CONSTRUCTOR_ELTS (exp));\n-\ttree tail;\n-\n-\tCONSTRUCTOR_ELTS (copy) = list;\n-\tfor (tail = list; tail; tail = TREE_CHAIN (tail))\n-\t  TREE_VALUE (tail) = copy_constant (TREE_VALUE (tail));\n-\n+\tVEC(constructor_elt, gc) *v;\n+\tunsigned HOST_WIDE_INT idx;\n+\ttree purpose, value;\n+\t\n+\tv = VEC_alloc(constructor_elt, gc, VEC_length(constructor_elt,\n+\t\t\t\t\t\t      CONSTRUCTOR_ELTS (exp)));\n+\tFOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (exp), idx, purpose, value)\n+\t  {\n+\t    constructor_elt *ce = VEC_quick_push (constructor_elt, v, NULL);\n+\t    ce->index = purpose;\n+\t    ce->value = copy_constant (value);\n+\t  }\n+\tCONSTRUCTOR_ELTS (copy) = v;\n \treturn copy;\n       }\n \n@@ -3476,10 +3490,12 @@ compute_reloc_for_constant (tree exp)\n       break;\n \n     case CONSTRUCTOR:\n-      for (tem = CONSTRUCTOR_ELTS (exp); tem; tem = TREE_CHAIN (tem))\n-\tif (TREE_VALUE (tem) != 0)\n-\t  reloc |= compute_reloc_for_constant (TREE_VALUE (tem));\n-\n+      {\n+\tunsigned HOST_WIDE_INT idx;\n+\tFOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (exp), idx, tem)\n+\t  if (tem != 0)\n+\t    reloc |= compute_reloc_for_constant (tem);\n+      }\n       break;\n \n     default:\n@@ -3533,10 +3549,12 @@ output_addressed_constants (tree exp)\n       break;\n \n     case CONSTRUCTOR:\n-      for (tem = CONSTRUCTOR_ELTS (exp); tem; tem = TREE_CHAIN (tem))\n-\tif (TREE_VALUE (tem) != 0)\n-\t  output_addressed_constants (TREE_VALUE (tem));\n-\n+      {\n+\tunsigned HOST_WIDE_INT idx;\n+\tFOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (exp), idx, tem)\n+\t  if (tem != 0)\n+\t    output_addressed_constants (tem);\n+      }\n       break;\n \n     default:\n@@ -3567,16 +3585,16 @@ initializer_constant_valid_p (tree value, tree endtype)\n       if ((TREE_CODE (TREE_TYPE (value)) == UNION_TYPE\n \t   || TREE_CODE (TREE_TYPE (value)) == RECORD_TYPE)\n \t  && TREE_CONSTANT (value)\n-\t  && CONSTRUCTOR_ELTS (value))\n+\t  && !VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (value)))\n \t{\n+\t  unsigned HOST_WIDE_INT idx;\n \t  tree elt;\n \t  bool absolute = true;\n \n-\t  for (elt = CONSTRUCTOR_ELTS (value); elt; elt = TREE_CHAIN (elt))\n+\t  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (value), idx, elt)\n \t    {\n \t      tree reloc;\n-\t      value = TREE_VALUE (elt);\n-\t      reloc = initializer_constant_valid_p (value, TREE_TYPE (value));\n+\t      reloc = initializer_constant_valid_p (elt, TREE_TYPE (elt));\n \t      if (!reloc)\n \t\treturn NULL_TREE;\n \t      if (reloc != null_pointer_node)\n@@ -3832,7 +3850,8 @@ output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align)\n \n   /* Allow a constructor with no elements for any data type.\n      This means to fill the space with zeros.  */\n-  if (TREE_CODE (exp) == CONSTRUCTOR && CONSTRUCTOR_ELTS (exp) == 0)\n+  if (TREE_CODE (exp) == CONSTRUCTOR\n+      && VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (exp)))\n     {\n       assemble_zeros (size);\n       return;\n@@ -3942,6 +3961,8 @@ static unsigned HOST_WIDE_INT\n array_size_for_constructor (tree val)\n {\n   tree max_index, i;\n+  unsigned HOST_WIDE_INT cnt;\n+  tree index, value;\n \n   /* This code used to attempt to handle string constants that are not\n      arrays of single-bytes, but nothing else does, so there's no point in\n@@ -3950,10 +3971,8 @@ array_size_for_constructor (tree val)\n     return TREE_STRING_LENGTH (val);\n \n   max_index = NULL_TREE;\n-  for (i = CONSTRUCTOR_ELTS (val); i; i = TREE_CHAIN (i))\n+  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (val), cnt, index, value)\n     {\n-      tree index = TREE_PURPOSE (i);\n-\n       if (TREE_CODE (index) == RANGE_EXPR)\n \tindex = TREE_OPERAND (index, 1);\n       if (max_index == NULL_TREE || tree_int_cst_lt (max_index, index))\n@@ -3983,14 +4002,16 @@ output_constructor (tree exp, unsigned HOST_WIDE_INT size,\n \t\t    unsigned int align)\n {\n   tree type = TREE_TYPE (exp);\n-  tree link, field = 0;\n+  tree field = 0;\n   tree min_index = 0;\n   /* Number of bytes output or skipped so far.\n      In other words, current position within the constructor.  */\n   HOST_WIDE_INT total_bytes = 0;\n   /* Nonzero means BYTE contains part of a byte, to be output.  */\n   int byte_buffer_in_use = 0;\n   int byte = 0;\n+  unsigned HOST_WIDE_INT cnt;\n+  constructor_elt *ce;\n \n   gcc_assert (HOST_BITS_PER_WIDE_INT >= BITS_PER_UNIT);\n \n@@ -4010,23 +4031,22 @@ output_constructor (tree exp, unsigned HOST_WIDE_INT size,\n      There is always a maximum of one element in the chain LINK for unions\n      (even if the initializer in a source program incorrectly contains\n      more one).  */\n-  for (link = CONSTRUCTOR_ELTS (exp);\n-       link;\n-       link = TREE_CHAIN (link),\n-       field = field ? TREE_CHAIN (field) : 0)\n+  for (cnt = 0;\n+       VEC_iterate (constructor_elt, CONSTRUCTOR_ELTS (exp), cnt, ce);\n+       cnt++, field = field ? TREE_CHAIN (field) : 0)\n     {\n-      tree val = TREE_VALUE (link);\n+      tree val = ce->value;\n       tree index = 0;\n \n       /* The element in a union constructor specifies the proper field\n \t or index.  */\n       if ((TREE_CODE (type) == RECORD_TYPE || TREE_CODE (type) == UNION_TYPE\n \t   || TREE_CODE (type) == QUAL_UNION_TYPE)\n-\t  && TREE_PURPOSE (link) != 0)\n-\tfield = TREE_PURPOSE (link);\n+\t  && ce->index != 0)\n+\tfield = ce->index;\n \n       else if (TREE_CODE (type) == ARRAY_TYPE)\n-\tindex = TREE_PURPOSE (link);\n+\tindex = ce->index;\n \n #ifdef ASM_COMMENT_START\n       if (field && flag_verbose_asm)\n@@ -4089,6 +4109,7 @@ output_constructor (tree exp, unsigned HOST_WIDE_INT size,\n \t     if each element has the proper size.  */\n \t  if ((field != 0 || index != 0) && pos != total_bytes)\n \t    {\n+\t      gcc_assert (pos >= total_bytes);\n \t      assemble_zeros (pos - total_bytes);\n \t      total_bytes = pos;\n \t    }\n@@ -4164,6 +4185,7 @@ output_constructor (tree exp, unsigned HOST_WIDE_INT size,\n \t      /* If still not at proper byte, advance to there.  */\n \t      if (next_offset / BITS_PER_UNIT != total_bytes)\n \t\t{\n+\t\t  gcc_assert (next_offset / BITS_PER_UNIT >= total_bytes);\n \t\t  assemble_zeros (next_offset / BITS_PER_UNIT - total_bytes);\n \t\t  total_bytes = next_offset / BITS_PER_UNIT;\n \t\t}"}, {"sha": "842ac7bbaaa2f3954a1540e20acfd5d8a90abd30", "filename": "gcc/vec.h", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4038c495fc9685efdb400b36848627daab979e78/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=4038c495fc9685efdb400b36848627daab979e78", "patch": "@@ -147,6 +147,15 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #define VEC_length(T,V)\t(VEC_OP(T,base,length)(VEC_BASE(V)))\n \n+\n+/* Check if vector is empty\n+   int VEC_T_empty(const VEC(T) *v);\n+\n+   Return non-zero if V is an empty vector (or V is NULL), zero otherwise. */\n+\n+#define VEC_empty(T,V)\t(VEC_length (T,V) == 0)\n+\n+\n /* Get the final element of the vector.\n    T VEC_T_last(VEC(T) *v); // Integer\n    T VEC_T_last(VEC(T) *v); // Pointer\n@@ -205,6 +214,14 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #define VEC_embedded_size(T,N)\t (VEC_OP(T,base,embedded_size)(N))\n #define VEC_embedded_init(T,O,N) (VEC_OP(T,base,embedded_init)(VEC_BASE(O),N))\n \n+/* Copy a vector.\n+   VEC(T,A) *VEC_T_A_copy(VEC(T) *);\n+\n+   Copy the live elements of a vector into a new vector.  The new and\n+   old vectors need not be allocated by the same mechanim.  */\n+\n+#define VEC_copy(T,A,V) (VEC_OP(T,A,copy)(VEC_BASE(V) MEM_STAT_INFO))\n+\n /* Determine if a vector has additional capacity.\n    \n    int VEC_T_space (VEC(T) *v,int reserve)\n@@ -667,6 +684,23 @@ static inline void VEC_OP (T,A,free)\t\t\t\t\t  \\\n   *vec_ = NULL;\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n+static inline VEC(T,A) *VEC_OP (T,A,copy) (VEC(T,base) *vec_ MEM_STAT_DECL) \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  size_t len_ = vec_ ? vec_->num : 0;\t\t\t\t\t  \\\n+  VEC (T,A) *new_vec_ = NULL;\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  if (len_)\t\t\t\t\t\t\t\t  \\\n+    {\t\t\t\t\t\t\t\t\t  \\\n+      /* We must request exact size allocation, hence the negation. */\t  \\\n+      new_vec_ = (VEC (T,A) *)(vec_##A##_p_reserve\t\t\t  \\\n+\t\t\t       (NULL, -len_ PASS_MEM_STAT));\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+      new_vec_->base.num = len_;\t\t\t\t\t  \\\n+      memcpy (new_vec_->base.vec, vec_->vec, sizeof (T) * len_);\t  \\\n+    }\t\t\t\t\t\t\t\t\t  \\\n+  return new_vec_;\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n static inline int VEC_OP (T,A,reserve)\t       \t\t\t\t  \\\n      (VEC(T,A) **vec_, int alloc_ VEC_CHECK_DECL MEM_STAT_DECL)\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n@@ -895,6 +929,25 @@ static inline VEC(T,A) *VEC_OP (T,A,alloc)      \t\t\t  \\\n                                            PASS_MEM_STAT);\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n+static inline VEC(T,A) *VEC_OP (T,A,copy) (VEC(T,base) *vec_ MEM_STAT_DECL) \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  size_t len_ = vec_ ? vec_->num : 0;\t\t\t\t\t  \\\n+  VEC (T,A) *new_vec_ = NULL;\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+  if (len_)\t\t\t\t\t\t\t\t  \\\n+    {\t\t\t\t\t\t\t\t\t  \\\n+      /* We must request exact size allocation, hence the negation. */\t  \\\n+      new_vec_ = (VEC (T,A) *)(vec_##A##_o_reserve\t\t\t  \\\n+\t\t\t       (NULL, -len_,\t\t\t\t  \\\n+\t\t\t\toffsetof (VEC(T,A),base.vec), sizeof (T)  \\\n+\t\t\t\tPASS_MEM_STAT));\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+      new_vec_->base.num = len_;\t\t\t\t\t  \\\n+      memcpy (new_vec_->base.vec, vec_->vec, sizeof (T) * len_);\t  \\\n+    }\t\t\t\t\t\t\t\t\t  \\\n+  return new_vec_;\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP (T,A,free)\t\t\t\t\t  \\\n      (VEC(T,A) **vec_)\t\t\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\"}]}