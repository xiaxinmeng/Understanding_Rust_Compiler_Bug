{"sha": "dd58eb5a7279bf7328afa905b55623b15a8577b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ1OGViNWE3Mjc5YmY3MzI4YWZhOTA1YjU1NjIzYjE1YTg1NzdiMA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2005-04-14T18:44:09Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2005-04-14T18:44:09Z"}, "message": "tree-eh.c (lower_try_finally_copy): Generate new code in response to goto_queue entries as if...\n\n* tree-eh.c (lower_try_finally_copy): Generate new code in\nresponse to goto_queue entries as if the queue was sorted by\nindex, not pointers.\n(lower_try_finally_switch): Likewise.\n\nFrom-SVN: r98149", "tree": {"sha": "cc72442cfa0549c9f53a4dec4cd687aa95223624", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc72442cfa0549c9f53a4dec4cd687aa95223624"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd58eb5a7279bf7328afa905b55623b15a8577b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd58eb5a7279bf7328afa905b55623b15a8577b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd58eb5a7279bf7328afa905b55623b15a8577b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd58eb5a7279bf7328afa905b55623b15a8577b0/comments", "author": null, "committer": null, "parents": [{"sha": "b67af20b5b1cf35ed61242540ac7608485852578", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b67af20b5b1cf35ed61242540ac7608485852578", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b67af20b5b1cf35ed61242540ac7608485852578"}], "stats": {"total": 116, "additions": 82, "deletions": 34}, "files": [{"sha": "53aa00c82b36ea84eed4bddf10f205d04096b8c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd58eb5a7279bf7328afa905b55623b15a8577b0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd58eb5a7279bf7328afa905b55623b15a8577b0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dd58eb5a7279bf7328afa905b55623b15a8577b0", "patch": "@@ -1,3 +1,10 @@\n+2005-04-14  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* tree-eh.c (lower_try_finally_copy): Generate new code in\n+\tresponse to goto_queue entries as if the queue was sorted by\n+\tindex, not pointers.\n+\t(lower_try_finally_switch): Likewise.\n+\n 2005-04-14  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/i386.c (ix86_expand_sse_cmp): Split out from ..."}, {"sha": "90f90611d019b5056358677091bb6f445a64d3fe", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 75, "deletions": 34, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd58eb5a7279bf7328afa905b55623b15a8577b0/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd58eb5a7279bf7328afa905b55623b15a8577b0/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=dd58eb5a7279bf7328afa905b55623b15a8577b0", "patch": "@@ -1038,47 +1038,72 @@ lower_try_finally_copy (struct leh_state *state, struct leh_tf_state *tf)\n     {\n       struct goto_queue_node *q, *qe;\n       tree return_val = NULL;\n-      int return_index;\n-      tree *labels;\n+      int return_index, index;\n+      struct\n+      {\n+\tstruct goto_queue_node *q;\n+\ttree label;\n+      } *labels;\n \n       if (tf->dest_array)\n \treturn_index = VARRAY_ACTIVE_SIZE (tf->dest_array);\n       else\n \treturn_index = 0;\n-      labels = xcalloc (sizeof (tree), return_index + 1);\n+      labels = xcalloc (sizeof (*labels), return_index + 1);\n \n       q = tf->goto_queue;\n       qe = q + tf->goto_queue_active;\n       for (; q < qe; q++)\n \t{\n-\t  int index = q->index < 0 ? return_index : q->index;\n-\t  tree lab = labels[index];\n-\t  bool build_p = false;\n+\t  index = q->index < 0 ? return_index : q->index;\n \n-\t  if (!lab)\n-\t    {\n-\t      labels[index] = lab = create_artificial_label ();\n-\t      build_p = true;\n-\t    }\n+\t  if (!labels[index].q)\n+\t    labels[index].q = q;\n+\t}\n+\n+      for (index = 0; index < return_index + 1; index++)\n+\t{\n+\t  tree lab;\n+\n+\t  q = labels[index].q;\n+\t  if (! q)\n+\t    continue;\n+\n+\t  lab = labels[index].label = create_artificial_label ();\n \n \t  if (index == return_index)\n \t    do_return_redirection (q, lab, NULL, &return_val);\n \t  else\n \t    do_goto_redirection (q, lab, NULL);\n \n-\t  if (build_p)\n-\t    {\n-\t      x = build1 (LABEL_EXPR, void_type_node, lab);\n-\t      append_to_statement_list (x, &new_stmt);\n+\t  x = build1 (LABEL_EXPR, void_type_node, lab);\n+\t  append_to_statement_list (x, &new_stmt);\n \n-\t      x = lower_try_finally_dup_block (finally, state);\n-\t      lower_eh_constructs_1 (state, &x);\n-\t      append_to_statement_list (x, &new_stmt);\n+\t  x = lower_try_finally_dup_block (finally, state);\n+\t  lower_eh_constructs_1 (state, &x);\n+\t  append_to_statement_list (x, &new_stmt);\n \n-\t      append_to_statement_list (q->cont_stmt, &new_stmt);\n-\t      maybe_record_in_goto_queue (state, q->cont_stmt);\n-\t    }\n+\t  append_to_statement_list (q->cont_stmt, &new_stmt);\n+\t  maybe_record_in_goto_queue (state, q->cont_stmt);\n+\t}\n+\n+      for (q = tf->goto_queue; q < qe; q++)\n+\t{\n+\t  tree lab;\n+\n+\t  index = q->index < 0 ? return_index : q->index;\n+\n+\t  if (labels[index].q == q)\n+\t    continue;\n+\n+\t  lab = labels[index].label;\n+\n+\t  if (index == return_index)\n+\t    do_return_redirection (q, lab, NULL, &return_val);\n+\t  else\n+\t    do_goto_redirection (q, lab, NULL);\n \t}\n+\t\n       replace_goto_queue (tf);\n       free (labels);\n     }\n@@ -1194,7 +1219,6 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n   q = tf->goto_queue;\n   qe = q + tf->goto_queue_active;\n   j = last_case_index + tf->may_return;\n-  last_case_index += nlabels;\n   for (; q < qe; ++q)\n     {\n       tree mod;\n@@ -1217,20 +1241,37 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n \n       case_index = j + q->index;\n       if (!TREE_VEC_ELT (case_label_vec, case_index))\n-\t{\n-\t  last_case = build (CASE_LABEL_EXPR, void_type_node,\n-\t\t\t     build_int_cst (NULL_TREE, switch_id), NULL,\n-\t\t\t     create_artificial_label ());\n-\t  TREE_VEC_ELT (case_label_vec, case_index) = last_case;\n-\n-\t  x = build (LABEL_EXPR, void_type_node, CASE_LABEL (last_case));\n-\t  append_to_statement_list (x, &switch_body);\n-\t  append_to_statement_list (q->cont_stmt, &switch_body);\n-\t  maybe_record_in_goto_queue (state, q->cont_stmt);\n-\t}\n+\tTREE_VEC_ELT (case_label_vec, case_index)\n+\t  = build (CASE_LABEL_EXPR, void_type_node,\n+\t\t   build_int_cst (NULL_TREE, switch_id), NULL,\n+\t\t   /* We store the cont_stmt in the\n+\t\t      CASE_LABEL, so that we can recover it\n+\t\t      in the loop below.  We don't create\n+\t\t      the new label while walking the\n+\t\t      goto_queue because pointers don't\n+\t\t      offer a stable order.  */\n+\t\t   q->cont_stmt);\n+    }\n+  for (j = last_case_index; j < last_case_index + nlabels; j++)\n+    {\n+      tree label;\n+      tree cont_stmt;\n+\n+      last_case = TREE_VEC_ELT (case_label_vec, j);\n+\n+      gcc_assert (last_case);\n+\n+      cont_stmt = CASE_LABEL (last_case);\n+\n+      label = create_artificial_label ();\n+      CASE_LABEL (last_case) = label;\n+\n+      x = build (LABEL_EXPR, void_type_node, label);\n+      append_to_statement_list (x, &switch_body);\n+      append_to_statement_list (cont_stmt, &switch_body);\n+      maybe_record_in_goto_queue (state, cont_stmt);\n     }\n   replace_goto_queue (tf);\n-  last_case_index += nlabels;\n \n   /* Make sure that the last case is the default label, as one is required.\n      Then sort the labels, which is also required in GIMPLE.  */"}]}