{"sha": "618b7f293745ac92cc4fef113239e84f79c4d4ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjE4YjdmMjkzNzQ1YWM5MmNjNGZlZjExMzIzOWU4NGY3OWM0ZDRmZg==", "commit": {"author": {"name": "Trevor Saunders", "email": "tsaunders@mozilla.com", "date": "2014-11-11T02:31:00Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2014-11-11T02:31:00Z"}, "message": "c++ify sreal\n\ngcc/ChangeLog:\n\n2014-11-10  Trevor Saunders  <tsaunders@mozilla.com>\n\n\t* ipa-inline.c (edge_badness): Adjust.\n\t(inline_small_functions): Likewise.\n\t* predict.c (propagate_freq): Likewise.\n\t(estimate_bb_frequencies): Likewise.\n\t* sreal.c (sreal::dump): Rename from dump_sreal.\n\t(debug): Adjust.\n\t(copy): Remove function.\n\t(sreal::shift_right): Rename from sreal_sift_right.\n\t(sreal::normalize): Rename from normalize.\n\t(sreal_init): Remove function.\n\t(sreal::to_int): Rename from sreal_to_int.\n\t(sreal_compare): Remove function.\n\t(sreal::operator+): Rename from sreal_add.\n\t(sreal::operator-): Rename from sreal_sub.\n\t(sreal::operator*): Rename from sreal_mul.\n\t(sreal::operator/): Rename from sreal_div.\n\t* sreal.h (class sreal): Adjust.\n\t(inline sreal &operator+=): New operator.\n\t(inline sreal &operator-=): Likewise.\n\t(inline sreal &operator/=): Likewise.\n\t(inline sreal &operator*=): Likewise.\n\t(inline bool operator!=): Likewise.\n\t(inline bool operator>): Likewise.\n\t(inline bool operator<=): Likewise.\n\t(inline bool operator>=): Likewise.\n\nFrom-SVN: r217332", "tree": {"sha": "45432b15918ada70945d621144d6decabaa36832", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45432b15918ada70945d621144d6decabaa36832"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/618b7f293745ac92cc4fef113239e84f79c4d4ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/618b7f293745ac92cc4fef113239e84f79c4d4ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/618b7f293745ac92cc4fef113239e84f79c4d4ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/618b7f293745ac92cc4fef113239e84f79c4d4ff/comments", "author": null, "committer": null, "parents": [{"sha": "43722f9fa69d4cc9a369b468552d5612674a576f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43722f9fa69d4cc9a369b468552d5612674a576f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43722f9fa69d4cc9a369b468552d5612674a576f"}], "stats": {"total": 728, "additions": 247, "deletions": 481}, "files": [{"sha": "2b7f3a13894f6455e843213554192691b5ab71a1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618b7f293745ac92cc4fef113239e84f79c4d4ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618b7f293745ac92cc4fef113239e84f79c4d4ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=618b7f293745ac92cc4fef113239e84f79c4d4ff", "patch": "@@ -1,3 +1,31 @@\n+2014-11-10  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* ipa-inline.c (edge_badness): Adjust.\n+\t(inline_small_functions): Likewise.\n+\t* predict.c (propagate_freq): Likewise.\n+\t(estimate_bb_frequencies): Likewise.\n+\t* sreal.c (sreal::dump): Rename from dump_sreal.\n+\t(debug): Adjust.\n+\t(copy): Remove function.\n+\t(sreal::shift_right): Rename from sreal_sift_right.\n+\t(sreal::normalize): Rename from normalize.\n+\t(sreal_init): Remove function.\n+\t(sreal::to_int): Rename from sreal_to_int.\n+\t(sreal_compare): Remove function.\n+\t(sreal::operator+): Rename from sreal_add.\n+\t(sreal::operator-): Rename from sreal_sub.\n+\t(sreal::operator*): Rename from sreal_mul.\n+\t(sreal::operator/): Rename from sreal_div.\n+\t* sreal.h (class sreal): Adjust.\n+\t(inline sreal &operator+=): New operator.\n+\t(inline sreal &operator-=): Likewise.\n+\t(inline sreal &operator/=): Likewise.\n+\t(inline sreal &operator*=): Likewise.\n+\t(inline bool operator!=): Likewise.\n+\t(inline bool operator>): Likewise.\n+\t(inline bool operator<=): Likewise.\n+\t(inline bool operator>=): Likewise.\n+\n 2014-11-11  Bin Cheng  <bin.cheng@arm.com>\n \n \t* sched-deps.c (sched_analyze_1): Check pending list if it is not"}, {"sha": "5c9781584e14227cf8e03420f92be9cb7a5dcd00", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618b7f293745ac92cc4fef113239e84f79c4d4ff/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618b7f293745ac92cc4fef113239e84f79c4d4ff/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=618b7f293745ac92cc4fef113239e84f79c4d4ff", "patch": "@@ -962,29 +962,28 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \n   else if (max_count)\n     {\n-      sreal tmp, relbenefit_real, growth_real;\n       int relbenefit = relative_time_benefit (callee_info, edge, edge_time);\n       /* Capping edge->count to max_count. edge->count can be larger than\n \t max_count if an inline adds new edges which increase max_count\n \t after max_count is computed.  */\n       gcov_type edge_count = edge->count > max_count ? max_count : edge->count;\n \n-      sreal_init (&relbenefit_real, relbenefit, 0);\n-      sreal_init (&growth_real, growth, 0);\n+      sreal relbenefit_real (relbenefit, 0);\n+      sreal growth_real (growth, 0);\n \n       /* relative_edge_count.  */\n-      sreal_init (&tmp, edge_count, 0);\n-      sreal_div (&tmp, &tmp, &max_count_real);\n+      sreal tmp (edge_count, 0);\n+      tmp /= max_count_real;\n \n       /* relative_time_benefit.  */\n-      sreal_mul (&tmp, &tmp, &relbenefit_real);\n-      sreal_div (&tmp, &tmp, &max_relbenefit_real);\n+      tmp *= relbenefit_real;\n+      tmp /= max_relbenefit_real;\n \n       /* growth_f_caller.  */\n-      sreal_mul (&tmp, &tmp, &half_int_min_real);\n-      sreal_div (&tmp, &tmp, &growth_real);\n+      tmp *= half_int_min_real;\n+      tmp /=  growth_real;\n \n-      badness = -1 * sreal_to_int (&tmp);\n+      badness = -1 * tmp.to_int ();\n  \n       if (dump)\n \t{\n@@ -1627,9 +1626,9 @@ inline_small_functions (void)\n \t  if (max_count < edge->count)\n \t    max_count = edge->count;\n       }\n-  sreal_init (&max_count_real, max_count, 0);\n-  sreal_init (&max_relbenefit_real, RELATIVE_TIME_BENEFIT_RANGE, 0);\n-  sreal_init (&half_int_min_real, INT_MAX / 2, 0);\n+  max_count_real = sreal (max_count, 0);\n+  max_relbenefit_real = sreal (RELATIVE_TIME_BENEFIT_RANGE, 0);\n+  half_int_min_real = sreal (INT_MAX / 2, 0);\n   ipa_free_postorder_info ();\n   initialize_growth_caches ();\n "}, {"sha": "0215e9170dbac6a885a08f5ffc31072405b96ed7", "filename": "gcc/predict.c", "status": "modified", "additions": 32, "deletions": 50, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618b7f293745ac92cc4fef113239e84f79c4d4ff/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618b7f293745ac92cc4fef113239e84f79c4d4ff/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=618b7f293745ac92cc4fef113239e84f79c4d4ff", "patch": "@@ -2528,15 +2528,13 @@ propagate_freq (basic_block head, bitmap tovisit)\n \tbb->count = bb->frequency = 0;\n     }\n \n-  memcpy (&BLOCK_INFO (head)->frequency, &real_one, sizeof (real_one));\n+  BLOCK_INFO (head)->frequency = real_one;\n   last = head;\n   for (bb = head; bb; bb = nextbb)\n     {\n       edge_iterator ei;\n-      sreal cyclic_probability, frequency;\n-\n-      memcpy (&cyclic_probability, &real_zero, sizeof (real_zero));\n-      memcpy (&frequency, &real_zero, sizeof (real_zero));\n+      sreal cyclic_probability = real_zero;\n+      sreal frequency = real_zero;\n \n       nextbb = BLOCK_INFO (bb)->next;\n       BLOCK_INFO (bb)->next = NULL;\n@@ -2553,42 +2551,34 @@ propagate_freq (basic_block head, bitmap tovisit)\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    if (EDGE_INFO (e)->back_edge)\n \t      {\n-\t\tsreal_add (&cyclic_probability, &cyclic_probability,\n-\t\t\t   &EDGE_INFO (e)->back_edge_prob);\n+\t\tcyclic_probability += EDGE_INFO (e)->back_edge_prob;\n \t      }\n \t    else if (!(e->flags & EDGE_DFS_BACK))\n \t      {\n-\t\tsreal tmp;\n-\n \t\t/*  frequency += (e->probability\n \t\t\t\t  * BLOCK_INFO (e->src)->frequency /\n \t\t\t\t  REG_BR_PROB_BASE);  */\n \n-\t\tsreal_init (&tmp, e->probability, 0);\n-\t\tsreal_mul (&tmp, &tmp, &BLOCK_INFO (e->src)->frequency);\n-\t\tsreal_mul (&tmp, &tmp, &real_inv_br_prob_base);\n-\t\tsreal_add (&frequency, &frequency, &tmp);\n+\t\tsreal tmp (e->probability, 0);\n+\t\ttmp *= BLOCK_INFO (e->src)->frequency;\n+\t\ttmp *= real_inv_br_prob_base;\n+\t\tfrequency += tmp;\n \t      }\n \n-\t  if (sreal_compare (&cyclic_probability, &real_zero) == 0)\n+\t  if (cyclic_probability == real_zero)\n \t    {\n-\t      memcpy (&BLOCK_INFO (bb)->frequency, &frequency,\n-\t\t      sizeof (frequency));\n+\t      BLOCK_INFO (bb)->frequency = frequency;\n \t    }\n \t  else\n \t    {\n-\t      if (sreal_compare (&cyclic_probability, &real_almost_one) > 0)\n-\t\t{\n-\t\t  memcpy (&cyclic_probability, &real_almost_one,\n-\t\t\t  sizeof (real_almost_one));\n-\t\t}\n+\t      if (cyclic_probability > real_almost_one)\n+\t\tcyclic_probability = real_almost_one;\n \n \t      /* BLOCK_INFO (bb)->frequency = frequency\n \t\t\t\t\t      / (1 - cyclic_probability) */\n \n-\t      sreal_sub (&cyclic_probability, &real_one, &cyclic_probability);\n-\t      sreal_div (&BLOCK_INFO (bb)->frequency,\n-\t\t\t &frequency, &cyclic_probability);\n+\t      cyclic_probability = real_one - cyclic_probability;\n+\t      BLOCK_INFO (bb)->frequency = frequency / cyclic_probability;\n \t    }\n \t}\n \n@@ -2597,16 +2587,13 @@ propagate_freq (basic_block head, bitmap tovisit)\n       e = find_edge (bb, head);\n       if (e)\n \t{\n-\t  sreal tmp;\n-\n \t  /* EDGE_INFO (e)->back_edge_prob\n \t     = ((e->probability * BLOCK_INFO (bb)->frequency)\n \t     / REG_BR_PROB_BASE); */\n \n-\t  sreal_init (&tmp, e->probability, 0);\n-\t  sreal_mul (&tmp, &tmp, &BLOCK_INFO (bb)->frequency);\n-\t  sreal_mul (&EDGE_INFO (e)->back_edge_prob,\n-\t\t     &tmp, &real_inv_br_prob_base);\n+\t  sreal tmp (e->probability, 0);\n+\t  tmp *= BLOCK_INFO (bb)->frequency;\n+\t  EDGE_INFO (e)->back_edge_prob = tmp * real_inv_br_prob_base;\n \t}\n \n       /* Propagate to successor blocks.  */\n@@ -2886,13 +2873,13 @@ estimate_bb_frequencies (bool force)\n       if (!real_values_initialized)\n         {\n \t  real_values_initialized = 1;\n-\t  sreal_init (&real_zero, 0, 0);\n-\t  sreal_init (&real_one, 1, 0);\n-\t  sreal_init (&real_br_prob_base, REG_BR_PROB_BASE, 0);\n-\t  sreal_init (&real_bb_freq_max, BB_FREQ_MAX, 0);\n-\t  sreal_init (&real_one_half, 1, -1);\n-\t  sreal_div (&real_inv_br_prob_base, &real_one, &real_br_prob_base);\n-\t  sreal_sub (&real_almost_one, &real_one, &real_inv_br_prob_base);\n+\t  real_zero = sreal (0, 0);\n+\t  real_one = sreal (1, 0);\n+\t  real_br_prob_base = sreal (REG_BR_PROB_BASE, 0);\n+\t  real_bb_freq_max = sreal (BB_FREQ_MAX, 0);\n+\t  real_one_half = sreal (1, -1);\n+\t  real_inv_br_prob_base = real_one / real_br_prob_base;\n+\t  real_almost_one = real_one - real_inv_br_prob_base;\n \t}\n \n       mark_dfs_back_edges ();\n@@ -2910,30 +2897,25 @@ estimate_bb_frequencies (bool force)\n \n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n-\t      sreal_init (&EDGE_INFO (e)->back_edge_prob, e->probability, 0);\n-\t      sreal_mul (&EDGE_INFO (e)->back_edge_prob,\n-\t\t\t &EDGE_INFO (e)->back_edge_prob,\n-\t\t\t &real_inv_br_prob_base);\n+\t      EDGE_INFO (e)->back_edge_prob = sreal (e->probability, 0);\n+\t      EDGE_INFO (e)->back_edge_prob *= real_inv_br_prob_base;\n \t    }\n \t}\n \n       /* First compute frequencies locally for each loop from innermost\n          to outermost to examine frequencies for back edges.  */\n       estimate_loops ();\n \n-      memcpy (&freq_max, &real_zero, sizeof (real_zero));\n+      freq_max = real_zero;\n       FOR_EACH_BB_FN (bb, cfun)\n-\tif (sreal_compare (&freq_max, &BLOCK_INFO (bb)->frequency) < 0)\n-\t  memcpy (&freq_max, &BLOCK_INFO (bb)->frequency, sizeof (freq_max));\n+\tif (freq_max < BLOCK_INFO (bb)->frequency)\n+\t  freq_max = BLOCK_INFO (bb)->frequency;\n \n-      sreal_div (&freq_max, &real_bb_freq_max, &freq_max);\n+      freq_max = real_bb_freq_max / freq_max;\n       FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n \t{\n-\t  sreal tmp;\n-\n-\t  sreal_mul (&tmp, &BLOCK_INFO (bb)->frequency, &freq_max);\n-\t  sreal_add (&tmp, &tmp, &real_one_half);\n-\t  bb->frequency = sreal_to_int (&tmp);\n+\t  sreal tmp = BLOCK_INFO (bb)->frequency * freq_max + real_one_half;\n+\t  bb->frequency = tmp.to_int ();\n \t}\n \n       free_aux_for_blocks ();"}, {"sha": "efde0680ddba408bf11365ebf7131de82fde42db", "filename": "gcc/sreal.c", "status": "modified", "additions": 99, "deletions": 388, "changes": 487, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618b7f293745ac92cc4fef113239e84f79c4d4ff/gcc%2Fsreal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618b7f293745ac92cc4fef113239e84f79c4d4ff/gcc%2Fsreal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsreal.c?ref=618b7f293745ac92cc4fef113239e84f79c4d4ff", "patch": "@@ -28,12 +28,10 @@ along with GCC; see the file COPYING3.  If not see\n \t  (for < 64-bit machines sig = sig_lo + sig_hi * 2 ^ SREAL_PART_BITS)\n \texp = exponent\n \n-   One HOST_WIDE_INT is used for the significant on 64-bit (and more than\n-   64-bit) machines,\n-   otherwise two HOST_WIDE_INTs are used for the significant.\n+   One uint64_t is used for the significant.\n    Only a half of significant bits is used (in normalized sreals) so that we do\n    not have problems with overflow, for example when c->sig = a->sig * b->sig.\n-   So the precision for 64-bit and 32-bit machines is 32-bit.\n+   So the precision is 32-bit.\n \n    Invariant: The numbers are normalized before and after each call of sreal_*.\n \n@@ -54,28 +52,18 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"sreal.h\"\n \n-static inline void copy (sreal *, sreal *);\n-static inline void shift_right (sreal *, int);\n-static void normalize (sreal *);\n-\n /* Print the content of struct sreal.  */\n \n void\n-dump_sreal (FILE *file, sreal *x)\n+sreal::dump (FILE *file) const\n {\n-#if SREAL_PART_BITS < 32\n-  fprintf (file, \"((\" HOST_WIDE_INT_PRINT_UNSIGNED \" * 2^16 + \"\n-\t   HOST_WIDE_INT_PRINT_UNSIGNED \") * 2^%d)\",\n-\t   x->sig_hi, x->sig_lo, x->exp);\n-#else\n-  fprintf (file, \"(\" HOST_WIDE_INT_PRINT_UNSIGNED \" * 2^%d)\", x->sig, x->exp);\n-#endif\n+  fprintf (file, \"(%\" PRIu64 \" * 2^%d)\", m_sig, m_exp);\n }\n \n DEBUG_FUNCTION void\n debug (sreal &ref)\n {\n-  dump_sreal (stderr, &ref);\n+  ref.dump (stderr);\n }\n \n DEBUG_FUNCTION void\n@@ -87,472 +75,195 @@ debug (sreal *ptr)\n     fprintf (stderr, \"<nil>\\n\");\n }\n \n+/* Shift this right by S bits.  Needed: 0 < S <= SREAL_BITS.\n+   When the most significant bit shifted out is 1, add 1 to this (rounding).\n+   */\n \n-/* Copy the sreal number.  */\n-\n-static inline void\n-copy (sreal *r, sreal *a)\n-{\n-#if SREAL_PART_BITS < 32\n-  r->sig_lo = a->sig_lo;\n-  r->sig_hi = a->sig_hi;\n-#else\n-  r->sig = a->sig;\n-#endif\n-  r->exp = a->exp;\n-}\n-\n-/* Shift X right by S bits.  Needed: 0 < S <= SREAL_BITS.\n-   When the most significant bit shifted out is 1, add 1 to X (rounding).  */\n-\n-static inline void\n-shift_right (sreal *x, int s)\n+void\n+sreal::shift_right (int s)\n {\n   gcc_assert (s > 0);\n   gcc_assert (s <= SREAL_BITS);\n   /* Exponent should never be so large because shift_right is used only by\n      sreal_add and sreal_sub ant thus the number cannot be shifted out from\n      exponent range.  */\n-  gcc_assert (x->exp + s <= SREAL_MAX_EXP);\n+  gcc_assert (m_exp + s <= SREAL_MAX_EXP);\n \n-  x->exp += s;\n+  m_exp += s;\n \n-#if SREAL_PART_BITS < 32\n-  if (s > SREAL_PART_BITS)\n-    {\n-      s -= SREAL_PART_BITS;\n-      x->sig_hi += (uhwi) 1 << (s - 1);\n-      x->sig_lo = x->sig_hi >> s;\n-      x->sig_hi = 0;\n-    }\n-  else\n-    {\n-      x->sig_lo += (uhwi) 1 << (s - 1);\n-      if (x->sig_lo & ((uhwi) 1 << SREAL_PART_BITS))\n-\t{\n-\t  x->sig_hi++;\n-\t  x->sig_lo -= (uhwi) 1 << SREAL_PART_BITS;\n-\t}\n-      x->sig_lo >>= s;\n-      x->sig_lo |= (x->sig_hi & (((uhwi) 1 << s) - 1)) << (SREAL_PART_BITS - s);\n-      x->sig_hi >>= s;\n-    }\n-#else\n-  x->sig += (uhwi) 1 << (s - 1);\n-  x->sig >>= s;\n-#endif\n+  m_sig += (uint64_t) 1 << (s - 1);\n+  m_sig >>= s;\n }\n \n-/* Normalize *X.  */\n+/* Normalize *this.  */\n \n-static void\n-normalize (sreal *x)\n+void\n+sreal::normalize ()\n {\n-#if SREAL_PART_BITS < 32\n-  int shift;\n-  HOST_WIDE_INT mask;\n-\n-  if (x->sig_lo == 0 && x->sig_hi == 0)\n+  if (m_sig == 0)\n     {\n-      x->exp = -SREAL_MAX_EXP;\n-    }\n-  else if (x->sig_hi < SREAL_MIN_SIG)\n-    {\n-      if (x->sig_hi == 0)\n-\t{\n-\t  /* Move lower part of significant to higher part.  */\n-\t  x->sig_hi = x->sig_lo;\n-\t  x->sig_lo = 0;\n-\t  x->exp -= SREAL_PART_BITS;\n-\t}\n-      shift = 0;\n-      while (x->sig_hi < SREAL_MIN_SIG)\n-\t{\n-\t  x->sig_hi <<= 1;\n-\t  x->exp--;\n-\t  shift++;\n-\t}\n-      /* Check underflow.  */\n-      if (x->exp < -SREAL_MAX_EXP)\n-\t{\n-\t  x->exp = -SREAL_MAX_EXP;\n-\t  x->sig_hi = 0;\n-\t  x->sig_lo = 0;\n-\t}\n-      else if (shift)\n-\t{\n-\t  mask = (1 << SREAL_PART_BITS) - (1 << (SREAL_PART_BITS - shift));\n-\t  x->sig_hi |= (x->sig_lo & mask) >> (SREAL_PART_BITS - shift);\n-\t  x->sig_lo = (x->sig_lo << shift) & (((uhwi) 1 << SREAL_PART_BITS) - 1);\n-\t}\n+      m_exp = -SREAL_MAX_EXP;\n     }\n-  else if (x->sig_hi > SREAL_MAX_SIG)\n+  else if (m_sig < SREAL_MIN_SIG)\n     {\n-      unsigned HOST_WIDE_INT tmp = x->sig_hi;\n-\n-      /* Find out how many bits will be shifted.  */\n-      shift = 0;\n       do\n \t{\n-\t  tmp >>= 1;\n-\t  shift++;\n-\t}\n-      while (tmp > SREAL_MAX_SIG);\n-\n-      /* Round the number.  */\n-      x->sig_lo += (uhwi) 1 << (shift - 1);\n-\n-      x->sig_lo >>= shift;\n-      x->sig_lo += ((x->sig_hi & (((uhwi) 1 << shift) - 1))\n-\t\t    << (SREAL_PART_BITS - shift));\n-      x->sig_hi >>= shift;\n-      x->exp += shift;\n-      if (x->sig_lo & ((uhwi) 1 << SREAL_PART_BITS))\n-\t{\n-\t  x->sig_lo -= (uhwi) 1 << SREAL_PART_BITS;\n-\t  x->sig_hi++;\n-\t  if (x->sig_hi > SREAL_MAX_SIG)\n-\t    {\n-\t      /* x->sig_hi was SREAL_MAX_SIG before increment\n-\t\t so now last bit is zero.  */\n-\t      x->sig_hi >>= 1;\n-\t      x->sig_lo >>= 1;\n-\t      x->exp++;\n-\t    }\n+\t  m_sig <<= 1;\n+\t  m_exp--;\n \t}\n-\n-      /* Check overflow.  */\n-      if (x->exp > SREAL_MAX_EXP)\n-\t{\n-\t  x->exp = SREAL_MAX_EXP;\n-\t  x->sig_hi = SREAL_MAX_SIG;\n-\t  x->sig_lo = SREAL_MAX_SIG;\n-\t}\n-    }\n-#else\n-  if (x->sig == 0)\n-    {\n-      x->exp = -SREAL_MAX_EXP;\n-    }\n-  else if (x->sig < SREAL_MIN_SIG)\n-    {\n-      do\n-\t{\n-\t  x->sig <<= 1;\n-\t  x->exp--;\n-\t}\n-      while (x->sig < SREAL_MIN_SIG);\n+      while (m_sig < SREAL_MIN_SIG);\n \n       /* Check underflow.  */\n-      if (x->exp < -SREAL_MAX_EXP)\n+      if (m_exp < -SREAL_MAX_EXP)\n \t{\n-\t  x->exp = -SREAL_MAX_EXP;\n-\t  x->sig = 0;\n+\t  m_exp = -SREAL_MAX_EXP;\n+\t  m_sig = 0;\n \t}\n     }\n-  else if (x->sig > SREAL_MAX_SIG)\n+  else if (m_sig > SREAL_MAX_SIG)\n     {\n       int last_bit;\n       do\n \t{\n-\t  last_bit = x->sig & 1;\n-\t  x->sig >>= 1;\n-\t  x->exp++;\n+\t  last_bit = m_sig & 1;\n+\t  m_sig >>= 1;\n+\t  m_exp++;\n \t}\n-      while (x->sig > SREAL_MAX_SIG);\n+      while (m_sig > SREAL_MAX_SIG);\n \n       /* Round the number.  */\n-      x->sig += last_bit;\n-      if (x->sig > SREAL_MAX_SIG)\n+      m_sig += last_bit;\n+      if (m_sig > SREAL_MAX_SIG)\n \t{\n-\t  x->sig >>= 1;\n-\t  x->exp++;\n+\t  m_sig >>= 1;\n+\t  m_exp++;\n \t}\n \n       /* Check overflow.  */\n-      if (x->exp > SREAL_MAX_EXP)\n+      if (m_exp > SREAL_MAX_EXP)\n \t{\n-\t  x->exp = SREAL_MAX_EXP;\n-\t  x->sig = SREAL_MAX_SIG;\n+\t  m_exp = SREAL_MAX_EXP;\n+\t  m_sig = SREAL_MAX_SIG;\n \t}\n     }\n-#endif\n-}\n-\n-/* Set *R to SIG * 2 ^ EXP.  Return R.  */\n-\n-sreal *\n-sreal_init (sreal *r, unsigned HOST_WIDE_INT sig, signed int exp)\n-{\n-#if SREAL_PART_BITS < 32\n-  r->sig_lo = 0;\n-  r->sig_hi = sig;\n-  r->exp = exp - 16;\n-#else\n-  r->sig = sig;\n-  r->exp = exp;\n-#endif\n-  normalize (r);\n-  return r;\n }\n \n-/* Return integer value of *R.  */\n+/* Return integer value of *this.  */\n \n-HOST_WIDE_INT\n-sreal_to_int (sreal *r)\n+int64_t\n+sreal::to_int () const\n {\n-#if SREAL_PART_BITS < 32\n-  if (r->exp <= -SREAL_BITS)\n+  if (m_exp <= -SREAL_BITS)\n     return 0;\n-  if (r->exp >= 0)\n-    return MAX_HOST_WIDE_INT;\n-  return ((r->sig_hi << SREAL_PART_BITS) + r->sig_lo) >> -r->exp;\n-#else\n-  if (r->exp <= -SREAL_BITS)\n-    return 0;\n-  if (r->exp >= SREAL_PART_BITS)\n-    return MAX_HOST_WIDE_INT;\n-  if (r->exp > 0)\n-    return r->sig << r->exp;\n-  if (r->exp < 0)\n-    return r->sig >> -r->exp;\n-  return r->sig;\n-#endif\n-}\n-\n-/* Compare *A and *B. Return -1 if *A < *B, 1 if *A > *B and 0 if *A == *B.  */\n-\n-int\n-sreal_compare (sreal *a, sreal *b)\n-{\n-  if (a->exp > b->exp)\n-    return 1;\n-  if (a->exp < b->exp)\n-    return -1;\n-#if SREAL_PART_BITS < 32\n-  if (a->sig_hi > b->sig_hi)\n-    return 1;\n-  if (a->sig_hi < b->sig_hi)\n-    return -1;\n-  if (a->sig_lo > b->sig_lo)\n-    return 1;\n-  if (a->sig_lo < b->sig_lo)\n-    return -1;\n-#else\n-  if (a->sig > b->sig)\n-    return 1;\n-  if (a->sig < b->sig)\n-    return -1;\n-#endif\n-  return 0;\n+  if (m_exp >= SREAL_PART_BITS)\n+    return INT64_MAX;\n+  if (m_exp > 0)\n+    return m_sig << m_exp;\n+  if (m_exp < 0)\n+    return m_sig >> -m_exp;\n+  return m_sig;\n }\n \n-/* *R = *A + *B.  Return R.  */\n+/* Return *this + other.  */\n \n-sreal *\n-sreal_add (sreal *r, sreal *a, sreal *b)\n+sreal\n+sreal::operator+ (const sreal &other) const\n {\n   int dexp;\n-  sreal tmp;\n-  sreal *bb;\n+  sreal tmp, r;\n+const sreal *a_p = this, *b_p = &other, *bb;\n \n-  if (sreal_compare (a, b) < 0)\n+  if (*a_p < *b_p)\n     {\n-      sreal *swap;\n-      swap = a;\n-      a = b;\n-      b = swap;\n+      const sreal *swap;\n+      swap = a_p;\n+      a_p = b_p;\n+      b_p = swap;\n     }\n \n-  dexp = a->exp - b->exp;\n-  r->exp = a->exp;\n+  dexp = a_p->m_exp - b_p->m_exp;\n+  r.m_exp = a_p->m_exp;\n   if (dexp > SREAL_BITS)\n     {\n-#if SREAL_PART_BITS < 32\n-      r->sig_hi = a->sig_hi;\n-      r->sig_lo = a->sig_lo;\n-#else\n-      r->sig = a->sig;\n-#endif\n+      r.m_sig = a_p->m_sig;\n       return r;\n     }\n \n   if (dexp == 0)\n-    bb = b;\n+    bb = b_p;\n   else\n     {\n-      copy (&tmp, b);\n-      shift_right (&tmp, dexp);\n+      tmp = *b_p;\n+      tmp.shift_right (dexp);\n       bb = &tmp;\n     }\n \n-#if SREAL_PART_BITS < 32\n-  r->sig_hi = a->sig_hi + bb->sig_hi;\n-  r->sig_lo = a->sig_lo + bb->sig_lo;\n-  if (r->sig_lo & ((uhwi) 1 << SREAL_PART_BITS))\n-    {\n-      r->sig_hi++;\n-      r->sig_lo -= (uhwi) 1 << SREAL_PART_BITS;\n-    }\n-#else\n-  r->sig = a->sig + bb->sig;\n-#endif\n-  normalize (r);\n+  r.m_sig = a_p->m_sig + bb->m_sig;\n+  r.normalize ();\n   return r;\n }\n \n-/* *R = *A - *B.  Return R.  */\n+/* Return *this - other.  */\n \n-sreal *\n-sreal_sub (sreal *r, sreal *a, sreal *b)\n+sreal\n+sreal::operator- (const sreal &other) const\n {\n   int dexp;\n-  sreal tmp;\n-  sreal *bb;\n+  sreal tmp, r;\n+  const sreal *bb;\n \n-  gcc_assert (sreal_compare (a, b) >= 0);\n+  gcc_assert (*this >= other);\n \n-  dexp = a->exp - b->exp;\n-  r->exp = a->exp;\n+  dexp = m_exp - other.m_exp;\n+  r.m_exp = m_exp;\n   if (dexp > SREAL_BITS)\n     {\n-#if SREAL_PART_BITS < 32\n-      r->sig_hi = a->sig_hi;\n-      r->sig_lo = a->sig_lo;\n-#else\n-      r->sig = a->sig;\n-#endif\n+      r.m_sig = m_sig;\n       return r;\n     }\n   if (dexp == 0)\n-    bb = b;\n+    bb = &other;\n   else\n     {\n-      copy (&tmp, b);\n-      shift_right (&tmp, dexp);\n+      tmp = other;\n+      tmp.shift_right (dexp);\n       bb = &tmp;\n     }\n \n-#if SREAL_PART_BITS < 32\n-  if (a->sig_lo < bb->sig_lo)\n-    {\n-      r->sig_hi = a->sig_hi - bb->sig_hi - 1;\n-      r->sig_lo = a->sig_lo + ((uhwi) 1 << SREAL_PART_BITS) - bb->sig_lo;\n-    }\n-  else\n-    {\n-      r->sig_hi = a->sig_hi - bb->sig_hi;\n-      r->sig_lo = a->sig_lo - bb->sig_lo;\n-    }\n-#else\n-  r->sig = a->sig - bb->sig;\n-#endif\n-  normalize (r);\n+  r.m_sig = m_sig - bb->m_sig;\n+  r.normalize ();\n   return r;\n }\n \n-/* *R = *A * *B.  Return R.  */\n+/* Return *this * other.  */\n \n-sreal *\n-sreal_mul (sreal *r, sreal *a, sreal *b)\n+sreal\n+sreal::operator* (const sreal &other) const\n {\n-#if SREAL_PART_BITS < 32\n-  if (a->sig_hi < SREAL_MIN_SIG || b->sig_hi < SREAL_MIN_SIG)\n+sreal r;\n+  if (m_sig < SREAL_MIN_SIG || other.m_sig < SREAL_MIN_SIG)\n     {\n-      r->sig_lo = 0;\n-      r->sig_hi = 0;\n-      r->exp = -SREAL_MAX_EXP;\n+      r.m_sig = 0;\n+      r.m_exp = -SREAL_MAX_EXP;\n     }\n   else\n     {\n-      unsigned HOST_WIDE_INT tmp1, tmp2, tmp3;\n-      if (sreal_compare (a, b) < 0)\n-\t{\n-\t  sreal *swap;\n-\t  swap = a;\n-\t  a = b;\n-\t  b = swap;\n-\t}\n-\n-      r->exp = a->exp + b->exp + SREAL_PART_BITS;\n-\n-      tmp1 = a->sig_lo * b->sig_lo;\n-      tmp2 = a->sig_lo * b->sig_hi;\n-      tmp3 = a->sig_hi * b->sig_lo + (tmp1 >> SREAL_PART_BITS);\n-\n-      r->sig_hi = a->sig_hi * b->sig_hi;\n-      r->sig_hi += (tmp2 >> SREAL_PART_BITS) + (tmp3 >> SREAL_PART_BITS);\n-      tmp2 &= ((uhwi) 1 << SREAL_PART_BITS) - 1;\n-      tmp3 &= ((uhwi) 1 << SREAL_PART_BITS) - 1;\n-      tmp1 = tmp2 + tmp3;\n-\n-      r->sig_lo = tmp1 & (((uhwi) 1 << SREAL_PART_BITS) - 1);\n-      r->sig_hi += tmp1 >> SREAL_PART_BITS;\n-\n-      normalize (r);\n-    }\n-#else\n-  if (a->sig < SREAL_MIN_SIG || b->sig < SREAL_MIN_SIG)\n-    {\n-      r->sig = 0;\n-      r->exp = -SREAL_MAX_EXP;\n+      r.m_sig = m_sig * other.m_sig;\n+      r.m_exp = m_exp + other.m_exp;\n+      r.normalize ();\n     }\n-  else\n-    {\n-      r->sig = a->sig * b->sig;\n-      r->exp = a->exp + b->exp;\n-      normalize (r);\n-    }\n-#endif\n   return r;\n }\n \n-/* *R = *A / *B.  Return R.  */\n+/* Return *this / other.  */\n \n-sreal *\n-sreal_div (sreal *r, sreal *a, sreal *b)\n+sreal\n+sreal::operator/ (const sreal &other) const\n {\n-#if SREAL_PART_BITS < 32\n-  unsigned HOST_WIDE_INT tmp, tmp1, tmp2;\n-\n-  gcc_assert (b->sig_hi >= SREAL_MIN_SIG);\n-  if (a->sig_hi < SREAL_MIN_SIG)\n-    {\n-      r->sig_hi = 0;\n-      r->sig_lo = 0;\n-      r->exp = -SREAL_MAX_EXP;\n-    }\n-  else\n-    {\n-      /* Since division by the whole number is pretty ugly to write\n-\t we are dividing by first 3/4 of bits of number.  */\n-\n-      tmp1 = (a->sig_hi << SREAL_PART_BITS) + a->sig_lo;\n-      tmp2 = ((b->sig_hi << (SREAL_PART_BITS / 2))\n-\t      + (b->sig_lo >> (SREAL_PART_BITS / 2)));\n-      if (b->sig_lo & ((uhwi) 1 << ((SREAL_PART_BITS / 2) - 1)))\n-\ttmp2++;\n-\n-      r->sig_lo = 0;\n-      tmp = tmp1 / tmp2;\n-      tmp1 = (tmp1 % tmp2) << (SREAL_PART_BITS / 2);\n-      r->sig_hi = tmp << SREAL_PART_BITS;\n-\n-      tmp = tmp1 / tmp2;\n-      tmp1 = (tmp1 % tmp2) << (SREAL_PART_BITS / 2);\n-      r->sig_hi += tmp << (SREAL_PART_BITS / 2);\n-\n-      tmp = tmp1 / tmp2;\n-      r->sig_hi += tmp;\n-\n-      r->exp = a->exp - b->exp - SREAL_BITS - SREAL_PART_BITS / 2;\n-      normalize (r);\n-    }\n-#else\n-  gcc_assert (b->sig != 0);\n-  r->sig = (a->sig << SREAL_PART_BITS) / b->sig;\n-  r->exp = a->exp - b->exp - SREAL_PART_BITS;\n-  normalize (r);\n-#endif\n+  gcc_assert (other.m_sig != 0);\n+sreal r;\n+  r.m_sig = (m_sig << SREAL_PART_BITS) / other.m_sig;\n+  r.m_exp = m_exp - other.m_exp - SREAL_PART_BITS;\n+  r.normalize ();\n   return r;\n }"}, {"sha": "461e28b3d2698bd47d890dc2348db0c76eb2f5de", "filename": "gcc/sreal.h", "status": "modified", "additions": 76, "deletions": 30, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618b7f293745ac92cc4fef113239e84f79c4d4ff/gcc%2Fsreal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618b7f293745ac92cc4fef113239e84f79c4d4ff/gcc%2Fsreal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsreal.h?ref=618b7f293745ac92cc4fef113239e84f79c4d4ff", "patch": "@@ -21,46 +21,92 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_SREAL_H\n \n /* SREAL_PART_BITS has to be an even number.  */\n-#if (HOST_BITS_PER_WIDE_INT / 2) % 2 == 1\n-#define SREAL_PART_BITS (HOST_BITS_PER_WIDE_INT / 2 - 1)\n-#else\n-#define SREAL_PART_BITS (HOST_BITS_PER_WIDE_INT / 2)\n-#endif\n-\n-#define uhwi unsigned HOST_WIDE_INT\n-#define MAX_HOST_WIDE_INT (((uhwi) 1 << (HOST_BITS_PER_WIDE_INT - 1)) - 1)\n+#define SREAL_PART_BITS 32\n \n-#define SREAL_MIN_SIG ((uhwi) 1 << (SREAL_PART_BITS - 1))\n-#define SREAL_MAX_SIG (((uhwi) 1 << SREAL_PART_BITS) - 1)\n+#define SREAL_MIN_SIG ((uint64_t) 1 << (SREAL_PART_BITS - 1))\n+#define SREAL_MAX_SIG (((uint64_t) 1 << SREAL_PART_BITS) - 1)\n #define SREAL_MAX_EXP (INT_MAX / 4)\n \n-#if SREAL_PART_BITS < 32\n-#define SREAL_BITS (SREAL_PART_BITS * 2)\n-#else\n #define SREAL_BITS SREAL_PART_BITS\n-#endif\n \n /* Structure for holding a simple real number.  */\n-struct sreal\n+class sreal\n {\n-#if SREAL_PART_BITS < 32\n-  unsigned HOST_WIDE_INT sig_lo;\t/* Significant (lower part).  */\n-  unsigned HOST_WIDE_INT sig_hi;\t/* Significant (higher part).  */\n-#else\n-  unsigned HOST_WIDE_INT sig;\t\t/* Significant.  */\n-#endif\n-  signed int exp;\t\t\t/* Exponent.  */\n+public:\n+  /* Construct an uninitialized sreal.  */\n+  sreal () : m_sig (-1), m_exp (-1) {}\n+\n+  /* Construct a sreal.  */\n+  sreal (uint64_t sig, int exp) : m_sig (sig), m_exp (exp) { normalize (); }\n+\n+  void dump (FILE *) const;\n+  int64_t to_int () const;\n+\n+  sreal operator+ (const sreal &other) const;\n+  sreal operator- (const sreal &other) const;\n+  sreal operator* (const sreal &other) const;\n+  sreal operator/ (const sreal &other) const;\n+\n+  bool operator< (const sreal &other) const\n+  {\n+    return m_exp < other.m_exp\n+      || (m_exp == other.m_exp && m_sig < other.m_sig);\n+  }\n+\n+  bool operator== (const sreal &other) const\n+  {\n+    return m_exp == other.m_exp && m_sig == other.m_sig;\n+  }\n+\n+private:\n+  void normalize ();\n+  void shift_right (int amount);\n+\n+  uint64_t m_sig;\t\t/* Significant.  */\n+  signed int m_exp;\t\t\t/* Exponent.  */\n };\n \n-extern void dump_sreal (FILE *, sreal *);\n extern void debug (sreal &ref);\n extern void debug (sreal *ptr);\n-extern sreal *sreal_init (sreal *, unsigned HOST_WIDE_INT, signed int);\n-extern HOST_WIDE_INT sreal_to_int (sreal *);\n-extern int sreal_compare (sreal *, sreal *);\n-extern sreal *sreal_add (sreal *, sreal *, sreal *);\n-extern sreal *sreal_sub (sreal *, sreal *, sreal *);\n-extern sreal *sreal_mul (sreal *, sreal *, sreal *);\n-extern sreal *sreal_div (sreal *, sreal *, sreal *);\n+\n+inline sreal &operator+= (sreal &a, const sreal &b)\n+{\n+  return a = a + b;\n+}\n+\n+inline sreal &operator-= (sreal &a, const sreal &b)\n+{\n+return a = a - b;\n+}\n+\n+inline sreal &operator/= (sreal &a, const sreal &b)\n+{\n+return a = a / b;\n+}\n+\n+inline sreal &operator*= (sreal &a, const sreal &b)\n+{\n+  return a = a  * b;\n+}\n+\n+inline bool operator!= (const sreal &a, const sreal &b)\n+{\n+  return !(a == b);\n+}\n+\n+inline bool operator> (const sreal &a, const sreal &b)\n+{\n+  return !(a == b || a < b);\n+}\n+\n+inline bool operator<= (const sreal &a, const sreal &b)\n+{\n+  return a < b || a == b;\n+}\n+\n+inline bool operator>= (const sreal &a, const sreal &b)\n+{\n+  return a == b || a > b;\n+}\n \n #endif"}]}