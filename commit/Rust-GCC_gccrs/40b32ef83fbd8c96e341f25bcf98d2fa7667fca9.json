{"sha": "40b32ef83fbd8c96e341f25bcf98d2fa7667fca9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBiMzJlZjgzZmJkOGM5NmUzNDFmMjViY2Y5OGQyZmE3NjY3ZmNhOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-09-04T19:17:52Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-09-04T19:17:52Z"}, "message": "revert: fold-const.c (operand_equal_p): Remove code to allow null ARG0/1.\n\nRevert:\n\t* fold-const.c (operand_equal_p): Remove code to allow null ARG0/1.\n\tDefine locals macros OP_SAME and OP_SAME_WITH_NULL and use throughout.\n\nFrom-SVN: r87089", "tree": {"sha": "ae20382b871332ac173220b3225055aa31e029a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae20382b871332ac173220b3225055aa31e029a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40b32ef83fbd8c96e341f25bcf98d2fa7667fca9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40b32ef83fbd8c96e341f25bcf98d2fa7667fca9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40b32ef83fbd8c96e341f25bcf98d2fa7667fca9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40b32ef83fbd8c96e341f25bcf98d2fa7667fca9/comments", "author": null, "committer": null, "parents": [{"sha": "875803a09267394ac672110d8d91a6084240b566", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/875803a09267394ac672110d8d91a6084240b566", "html_url": "https://github.com/Rust-GCC/gccrs/commit/875803a09267394ac672110d8d91a6084240b566"}], "stats": {"total": 93, "additions": 54, "deletions": 39}, "files": [{"sha": "be21a7f7e66156e57de34e9978a93780b4d6470d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b32ef83fbd8c96e341f25bcf98d2fa7667fca9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b32ef83fbd8c96e341f25bcf98d2fa7667fca9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40b32ef83fbd8c96e341f25bcf98d2fa7667fca9", "patch": "@@ -7,9 +7,6 @@\n \n \t* tree.c (save_expr): No longer TREE_READONLY.\n \n-\t* fold-const.c (operand_equal_p): Remove code to allow null ARG0/1.\n-\tDefine locals macros OP_SAME and OP_SAME_WITH_NULL and use throughout.\n-\n 2004-09-04  Jan Hubicka  <jh@suse.cz>\n \n \t* passes.c (rest_of_clean_state):  Fix merge conflict made during"}, {"sha": "d8c511a615ebf66ab4eb980dfab512b33cb69797", "filename": "gcc/fold-const.c", "status": "modified", "additions": 54, "deletions": 36, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b32ef83fbd8c96e341f25bcf98d2fa7667fca9/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b32ef83fbd8c96e341f25bcf98d2fa7667fca9/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=40b32ef83fbd8c96e341f25bcf98d2fa7667fca9", "patch": "@@ -2285,8 +2285,17 @@ truth_value_p (enum tree_code code)\n int\n operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n {\n+  /* If one is specified and the other isn't, they aren't equal and if\n+     neither is specified, they are.\n+\n+     ??? This is temporary and is meant only to handle the cases of the\n+     optional operands for COMPONENT_REF and ARRAY_REF.  */\n+  if ((arg0 && !arg1) || (!arg0 && arg1))\n+    return 0;\n+  else if (!arg0 && !arg1)\n+    return 1;\n   /* If either is ERROR_MARK, they aren't equal.  */\n-  if (TREE_CODE (arg0) == ERROR_MARK || TREE_CODE (arg1) == ERROR_MARK)\n+  else if (TREE_CODE (arg0) == ERROR_MARK || TREE_CODE (arg1) == ERROR_MARK)\n     return 0;\n \n   /* If both types don't have the same signedness, then we can't consider\n@@ -2378,17 +2387,6 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n   if (flags & OEP_ONLY_CONST)\n     return 0;\n \n-/* Define macros to test an operan from arg0 and arg1 for equality and a\n-   variant that allows null and views null as being different from any\n-   non-null value.  In the latter case, if either is null, the both\n-   must be; otherwise, do the normal comparison.  */\n-#define OP_SAME(N) operand_equal_p (TREE_OPERAND (arg0, N),\t\\\n-\t\t\t\t    TREE_OPERAND (arg1, N), flags)\n-\n-#define OP_SAME_WITH_NULL(N)\t\t\t\t\\\n-  ((!TREE_OPERAND (arg0, N) || !TREE_OPERAND (arg1, N))\t\\\n-   ? TREE_OPERAND (arg0, N) == TREE_OPERAND (arg1, N) : OP_SAME (N))\n-\n   switch (TREE_CODE_CLASS (TREE_CODE (arg0)))\n     {\n     case '1':\n@@ -2409,11 +2407,15 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n \t  break;\n \t}\n \n-      return OP_SAME (0);\n+      return operand_equal_p (TREE_OPERAND (arg0, 0),\n+\t\t\t      TREE_OPERAND (arg1, 0), flags);\n \n     case '<':\n     case '2':\n-      if (OP_SAME (0) && OP_SAME (1))\n+      if (operand_equal_p (TREE_OPERAND (arg0, 0),\n+\t\t\t   TREE_OPERAND (arg1, 0), flags)\n+\t  && operand_equal_p (TREE_OPERAND (arg0, 1),\n+\t\t\t      TREE_OPERAND (arg1, 1), flags))\n \treturn 1;\n \n       /* For commutative ops, allow the other order.  */\n@@ -2435,23 +2437,37 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n \tcase INDIRECT_REF:\n \tcase REALPART_EXPR:\n \tcase IMAGPART_EXPR:\n-\t  return OP_SAME (0);\n+\t  return operand_equal_p (TREE_OPERAND (arg0, 0),\n+\t\t\t\t  TREE_OPERAND (arg1, 0), flags);\n \n \tcase ARRAY_REF:\n \tcase ARRAY_RANGE_REF:\n-\t  /* Operands 2 and 3 may be null.  */\n-\t  return (OP_SAME (0)\n-\t\t  && OP_SAME (1)\n-\t\t  && OP_SAME_WITH_NULL (2)\n-\t\t  && OP_SAME_WITH_NULL (3));\n+\t  return (operand_equal_p (TREE_OPERAND (arg0, 0),\n+\t\t\t\t   TREE_OPERAND (arg1, 0), flags)\n+\t\t  && operand_equal_p (TREE_OPERAND (arg0, 1),\n+\t\t\t\t      TREE_OPERAND (arg1, 1), flags)\n+\t\t  && operand_equal_p (TREE_OPERAND (arg0, 2),\n+\t\t\t\t      TREE_OPERAND (arg1, 2), flags)\n+\t\t  && operand_equal_p (TREE_OPERAND (arg0, 3),\n+\t\t\t\t      TREE_OPERAND (arg1, 3), flags));\n+\n \n \tcase COMPONENT_REF:\n-\t  /* Handle operand 2 the same as for ARRAY_REF.  */\n-\t  return OP_SAME (0) && OP_SAME (1) && OP_SAME_WITH_NULL (2);\n+\t  return (operand_equal_p (TREE_OPERAND (arg0, 0),\n+\t\t\t\t   TREE_OPERAND (arg1, 0), flags)\n+\t\t  && operand_equal_p (TREE_OPERAND (arg0, 1),\n+\t\t\t\t      TREE_OPERAND (arg1, 1), flags)\n+\t\t  && operand_equal_p (TREE_OPERAND (arg0, 2),\n+\t\t\t\t      TREE_OPERAND (arg1, 2), flags));\n \n-\tcase BIT_FIELD_REF:\n-\t  return OP_SAME (0) && OP_SAME (1) && OP_SAME (2);\n \n+\tcase BIT_FIELD_REF:\n+\t  return (operand_equal_p (TREE_OPERAND (arg0, 0),\n+\t\t\t\t   TREE_OPERAND (arg1, 0), flags)\n+\t\t  && operand_equal_p (TREE_OPERAND (arg0, 1),\n+\t\t\t\t      TREE_OPERAND (arg1, 1), flags)\n+\t\t  && operand_equal_p (TREE_OPERAND (arg0, 2),\n+\t\t\t\t      TREE_OPERAND (arg1, 2), flags));\n \tdefault:\n \t  return 0;\n \t}\n@@ -2461,28 +2477,33 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n \t{\n \tcase ADDR_EXPR:\n \tcase TRUTH_NOT_EXPR:\n-\t  return OP_SAME (0);\n+\t  return operand_equal_p (TREE_OPERAND (arg0, 0),\n+\t\t\t\t  TREE_OPERAND (arg1, 0), flags);\n \n \tcase TRUTH_ANDIF_EXPR:\n \tcase TRUTH_ORIF_EXPR:\n-\t  return OP_SAME (0) && OP_SAME (1);\n+\t  return operand_equal_p (TREE_OPERAND (arg0, 0),\n+\t\t\t\t  TREE_OPERAND (arg1, 0), flags)\n+\t\t && operand_equal_p (TREE_OPERAND (arg0, 1),\n+\t\t\t\t     TREE_OPERAND (arg1, 1), flags);\n \n \tcase TRUTH_AND_EXPR:\n \tcase TRUTH_OR_EXPR:\n \tcase TRUTH_XOR_EXPR:\n-\t  if (OP_SAME (0) && OP_SAME (1))\n-\t    return 1;\n-\n-\t  /* Otherwise take into account this is a commutative operation.  */\n \t  return (operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t   TREE_OPERAND (arg1, 1), flags)\n+\t\t\t\t   TREE_OPERAND (arg1, 0), flags)\n \t\t  && operand_equal_p (TREE_OPERAND (arg0, 1),\n-\t\t\t\t      TREE_OPERAND (arg1, 0), flags));\n+\t\t\t\t      TREE_OPERAND (arg1, 1), flags))\n+\t\t || (operand_equal_p (TREE_OPERAND (arg0, 0),\n+\t\t\t\t      TREE_OPERAND (arg1, 1), flags)\n+\t\t     && operand_equal_p (TREE_OPERAND (arg0, 1),\n+\t\t\t\t\t TREE_OPERAND (arg1, 0), flags));\n \n \tcase CALL_EXPR:\n \t  /* If the CALL_EXPRs call different functions, then they\n \t     clearly can not be equal.  */\n-\t  if (!OP_SAME (0))\n+\t  if (! operand_equal_p (TREE_OPERAND (arg0, 0),\n+\t\t\t\t TREE_OPERAND (arg1, 0), flags))\n \t    return 0;\n \n \t  {\n@@ -2528,9 +2549,6 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n     default:\n       return 0;\n     }\n-\n-#undef OP_SAME\n-#undef OP_SAME_WITH_NULL\n }\n \f\n /* Similar to operand_equal_p, but see if ARG0 might have been made by"}]}