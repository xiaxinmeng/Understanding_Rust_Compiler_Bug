{"sha": "425fc685dd59c07316a0c9112595331aa77ba112", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI1ZmM2ODVkZDU5YzA3MzE2YTBjOTExMjU5NTMzMWFhNzdiYTExMg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2018-07-31T17:35:32Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2018-07-31T17:35:32Z"}, "message": "Add __builtin_speculation_safe_value\n\nThis patch defines a new intrinsic function\n__builtin_speculation_safe_value.  A generic default implementation is\ndefined which will attempt to use the backend pattern\n\"speculation_safe_barrier\".  If this pattern is not defined, or if it\nis not available, then the compiler will emit a warning, but\ncompilation will continue.\n\nNote that the test spec-barrier-1.c will currently fail on all\ntargets.  This is deliberate, the failure will go away when\nappropriate action is taken for each target backend.\n\ngcc:\n\t* builtin-types.def (BT_FN_PTR_PTR_VAR): New function type.\n\t(BT_FN_I1_I1_VAR, BT_FN_I2_I2_VAR, BT_FN_I4_I4_VAR): Likewise.\n\t(BT_FN_I8_I8_VAR, BT_FN_I16_I16_VAR): Likewise.\n\t* builtin-attrs.def (ATTR_NOVOPS_NOTHROW_LEAF_LIST): New attribute\n\tlist.\n\t* builtins.def (BUILT_IN_SPECULATION_SAFE_VALUE_N): New builtin.\n\t(BUILT_IN_SPECULATION_SAFE_VALUE_PTR): New internal builtin.\n\t(BUILT_IN_SPECULATION_SAFE_VALUE_1): Likewise.\n\t(BUILT_IN_SPECULATION_SAFE_VALUE_2): Likewise.\n\t(BUILT_IN_SPECULATION_SAFE_VALUE_4): Likewise.\n\t(BUILT_IN_SPECULATION_SAFE_VALUE_8): Likewise.\n\t(BUILT_IN_SPECULATION_SAFE_VALUE_16): Likewise.\n\t* builtins.c (expand_speculation_safe_value): New function.\n\t(expand_builtin): Call it.\n\t* doc/cpp.texi: Document predefine __HAVE_SPECULATION_SAFE_VALUE.\n\t* doc/extend.texi: Document __builtin_speculation_safe_value.\n\t* doc/md.texi: Document \"speculation_barrier\" pattern.\n\t* doc/tm.texi.in: Pull in TARGET_SPECULATION_SAFE_VALUE and\n\tTARGET_HAVE_SPECULATION_SAFE_VALUE.\n\t* doc/tm.texi: Regenerated.\n\t* target.def (have_speculation_safe_value, speculation_safe_value): New\n\thooks.\n\t* targhooks.c (default_have_speculation_safe_value): New function.\n\t(default_speculation_safe_value): New function.\n\t* targhooks.h (default_have_speculation_safe_value): Add prototype.\n\t(default_speculation_safe_value): Add prototype.\n\nc-family:\n\t* c-common.c (speculation_safe_resolve_call): New function.\n\t(speculation_safe_resolve_params): New function.\n\t(speculation_safe_resolve_return): New function.\n\t(resolve_overloaded_builtin): Handle __builtin_speculation_safe_value.\n\t* c-cppbuiltin.c (c_cpp_builtins): Add pre-define for\n\t__HAVE_SPECULATION_SAFE_VALUE.\n\ntestsuite:\n\t* c-c++-common/spec-barrier-1.c: New test.\n\t* c-c++-common/spec-barrier-2.c: New test.\n\t* gcc.dg/spec-barrier-3.c: New test.\n\nFrom-SVN: r263168", "tree": {"sha": "2d22b78c91baba7c56447d6b82253d85e3503bfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d22b78c91baba7c56447d6b82253d85e3503bfd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/425fc685dd59c07316a0c9112595331aa77ba112", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/425fc685dd59c07316a0c9112595331aa77ba112", "html_url": "https://github.com/Rust-GCC/gccrs/commit/425fc685dd59c07316a0c9112595331aa77ba112", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/425fc685dd59c07316a0c9112595331aa77ba112/comments", "author": null, "committer": null, "parents": [{"sha": "1d8693a0ce9e805acadc11072579e94b913eb1d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d8693a0ce9e805acadc11072579e94b913eb1d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d8693a0ce9e805acadc11072579e94b913eb1d8"}], "stats": {"total": 588, "additions": 587, "deletions": 1}, "files": [{"sha": "de37f1f879cb4ba67758b541c2eff29dc68c260c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=425fc685dd59c07316a0c9112595331aa77ba112", "patch": "@@ -1,3 +1,32 @@\n+2018-07-31  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* builtin-types.def (BT_FN_PTR_PTR_VAR): New function type.\n+\t(BT_FN_I1_I1_VAR, BT_FN_I2_I2_VAR, BT_FN_I4_I4_VAR): Likewise.\n+\t(BT_FN_I8_I8_VAR, BT_FN_I16_I16_VAR): Likewise.\n+\t* builtin-attrs.def (ATTR_NOVOPS_NOTHROW_LEAF_LIST): New attribute\n+\tlist.\n+\t* builtins.def (BUILT_IN_SPECULATION_SAFE_VALUE_N): New builtin.\n+\t(BUILT_IN_SPECULATION_SAFE_VALUE_PTR): New internal builtin.\n+\t(BUILT_IN_SPECULATION_SAFE_VALUE_1): Likewise.\n+\t(BUILT_IN_SPECULATION_SAFE_VALUE_2): Likewise.\n+\t(BUILT_IN_SPECULATION_SAFE_VALUE_4): Likewise.\n+\t(BUILT_IN_SPECULATION_SAFE_VALUE_8): Likewise.\n+\t(BUILT_IN_SPECULATION_SAFE_VALUE_16): Likewise.\n+\t* builtins.c (expand_speculation_safe_value): New function.\n+\t(expand_builtin): Call it.\n+\t* doc/cpp.texi: Document predefine __HAVE_SPECULATION_SAFE_VALUE.\n+\t* doc/extend.texi: Document __builtin_speculation_safe_value.\n+\t* doc/md.texi: Document \"speculation_barrier\" pattern.\n+\t* doc/tm.texi.in: Pull in TARGET_SPECULATION_SAFE_VALUE and\n+\tTARGET_HAVE_SPECULATION_SAFE_VALUE.\n+\t* doc/tm.texi: Regenerated.\n+\t* target.def (have_speculation_safe_value, speculation_safe_value): New\n+\thooks.\n+\t* targhooks.c (default_have_speculation_safe_value): New function.\n+\t(default_speculation_safe_value): New function.\n+\t* targhooks.h (default_have_speculation_safe_value): Add prototype.\n+\t(default_speculation_safe_value): Add prototype.\n+\n 2018-07-31  David Malcolm  <dmalcolm@redhat.com>\n \n \t* dump-context.h (dump_context::dump_loc): New decl."}, {"sha": "e245e4d9c9cb39205bca68c07eba74ff9aabfe18", "filename": "gcc/builtin-attrs.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fbuiltin-attrs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fbuiltin-attrs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-attrs.def?ref=425fc685dd59c07316a0c9112595331aa77ba112", "patch": "@@ -129,6 +129,8 @@ DEF_ATTR_TREE_LIST (ATTR_NOTHROW_LIST, ATTR_NOTHROW, ATTR_NULL, ATTR_NULL)\n \n DEF_ATTR_TREE_LIST (ATTR_NOTHROW_LEAF_LIST, ATTR_LEAF, ATTR_NULL, ATTR_NOTHROW_LIST)\n \n+DEF_ATTR_TREE_LIST (ATTR_NOVOPS_NOTHROW_LEAF_LIST, ATTR_NOVOPS, \\\n+\t\t        ATTR_NULL, ATTR_NOTHROW_LEAF_LIST)\n DEF_ATTR_TREE_LIST (ATTR_CONST_NOTHROW_LIST, ATTR_CONST,\t\\\n \t\t\tATTR_NULL, ATTR_NOTHROW_LIST)\n DEF_ATTR_TREE_LIST (ATTR_CONST_NOTHROW_LEAF_LIST, ATTR_CONST,\t\\"}, {"sha": "70fae35ce729d31ecbbd5c0f2f03caefebffb6d4", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=425fc685dd59c07316a0c9112595331aa77ba112", "patch": "@@ -763,6 +763,12 @@ DEF_FUNCTION_TYPE_VAR_1 (BT_FN_VOID_LONG_VAR,\n \t\t\t BT_VOID, BT_LONG)\n DEF_FUNCTION_TYPE_VAR_1 (BT_FN_VOID_ULL_VAR,\n \t\t\t BT_VOID, BT_ULONGLONG)\n+DEF_FUNCTION_TYPE_VAR_1 (BT_FN_PTR_PTR_VAR, BT_PTR, BT_PTR)\n+DEF_FUNCTION_TYPE_VAR_1 (BT_FN_I1_I1_VAR, BT_I1, BT_I1)\n+DEF_FUNCTION_TYPE_VAR_1 (BT_FN_I2_I2_VAR, BT_I2, BT_I2)\n+DEF_FUNCTION_TYPE_VAR_1 (BT_FN_I4_I4_VAR, BT_I4, BT_I4)\n+DEF_FUNCTION_TYPE_VAR_1 (BT_FN_I8_I8_VAR, BT_I8, BT_I8)\n+DEF_FUNCTION_TYPE_VAR_1 (BT_FN_I16_I16_VAR, BT_I16, BT_I16)\n \n DEF_FUNCTION_TYPE_VAR_2 (BT_FN_INT_FILEPTR_CONST_STRING_VAR,\n \t\t\t BT_INT, BT_FILEPTR, BT_CONST_STRING)"}, {"sha": "39611de702123be2fa958767a4a17883ab7e6de0", "filename": "gcc/builtins.c", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=425fc685dd59c07316a0c9112595331aa77ba112", "patch": "@@ -6918,6 +6918,55 @@ inline_expand_builtin_string_cmp (tree exp, rtx target)\n \t\t\t    const_str_n, mode);\n }\n \n+/* Expand a call to __builtin_speculation_safe_value_<N>.  MODE\n+   represents the size of the first argument to that call, or VOIDmode\n+   if the argument is a pointer.  IGNORE will be true if the result\n+   isn't used.  */\n+static rtx\n+expand_speculation_safe_value (machine_mode mode, tree exp, rtx target,\n+\t\t\t       bool ignore)\n+{\n+  rtx val, failsafe;\n+  unsigned nargs = call_expr_nargs (exp);\n+\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+\n+  if (mode == VOIDmode)\n+    {\n+      mode = TYPE_MODE (TREE_TYPE (arg0));\n+      gcc_assert (GET_MODE_CLASS (mode) == MODE_INT);\n+    }\n+\n+  val = expand_expr (arg0, NULL_RTX, mode, EXPAND_NORMAL);\n+\n+  /* An optional second argument can be used as a failsafe value on\n+     some machines.  If it isn't present, then the failsafe value is\n+     assumed to be 0.  */\n+  if (nargs > 1)\n+    {\n+      tree arg1 = CALL_EXPR_ARG (exp, 1);\n+      failsafe = expand_expr (arg1, NULL_RTX, mode, EXPAND_NORMAL);\n+    }\n+  else\n+    failsafe = const0_rtx;\n+\n+  /* If the result isn't used, the behavior is undefined.  It would be\n+     nice to emit a warning here, but path splitting means this might\n+     happen with legitimate code.  So simply drop the builtin\n+     expansion in that case; we've handled any side-effects above.  */\n+  if (ignore)\n+    return const0_rtx;\n+\n+  /* If we don't have a suitable target, create one to hold the result.  */\n+  if (target == NULL || GET_MODE (target) != mode)\n+    target = gen_reg_rtx (mode);\n+\n+  if (GET_MODE (val) != mode && GET_MODE (val) != VOIDmode)\n+    val = convert_modes (mode, VOIDmode, val, false);\n+\n+  return targetm.speculation_safe_value (mode, target, val, failsafe);\n+}\n+\n /* Expand an expression EXP that calls a built-in function,\n    with result going to TARGET if that's convenient\n    (and in mode MODE if that's convenient).\n@@ -8029,6 +8078,17 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n     case BUILT_IN_GOACC_PARLEVEL_SIZE:\n       return expand_builtin_goacc_parlevel_id_size (exp, target, ignore);\n \n+    case BUILT_IN_SPECULATION_SAFE_VALUE_PTR:\n+      return expand_speculation_safe_value (VOIDmode, exp, target, ignore);\n+\n+    case BUILT_IN_SPECULATION_SAFE_VALUE_1:\n+    case BUILT_IN_SPECULATION_SAFE_VALUE_2:\n+    case BUILT_IN_SPECULATION_SAFE_VALUE_4:\n+    case BUILT_IN_SPECULATION_SAFE_VALUE_8:\n+    case BUILT_IN_SPECULATION_SAFE_VALUE_16:\n+      mode = get_builtin_sync_mode (fcode - BUILT_IN_SPECULATION_SAFE_VALUE_1);\n+      return expand_speculation_safe_value (mode, exp, target, ignore);\n+\n     default:\t/* just do library call, if unknown builtin */\n       break;\n     }"}, {"sha": "ad90d4458a1a01b541c736d07ecc2d4c4676dee9", "filename": "gcc/builtins.def", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=425fc685dd59c07316a0c9112595331aa77ba112", "patch": "@@ -1003,6 +1003,28 @@ DEF_BUILTIN (BUILT_IN_EMUTLS_REGISTER_COMMON,\n \t     true, true, true, ATTR_NOTHROW_LEAF_LIST, false,\n \t     !targetm.have_tls)\n \n+/* Suppressing speculation.  Users are expected to use the first (N)\n+   variant, which will be translated internally into one of the other\n+   types.  */\n+\n+DEF_GCC_BUILTIN (BUILT_IN_SPECULATION_SAFE_VALUE_N, \"speculation_safe_value\",\n+\t\t BT_FN_VOID_VAR, ATTR_NOVOPS_NOTHROW_LEAF_LIST)\n+\n+DEF_GCC_BUILTIN (BUILT_IN_SPECULATION_SAFE_VALUE_PTR,\n+\t\t \"speculation_safe_value_ptr\", BT_FN_PTR_PTR_VAR,\n+\t\t ATTR_NOVOPS_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN (BUILT_IN_SPECULATION_SAFE_VALUE_1, \"speculation_safe_value_1\",\n+\t\t BT_FN_I1_I1_VAR, ATTR_NOVOPS_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN (BUILT_IN_SPECULATION_SAFE_VALUE_2, \"speculation_safe_value_2\",\n+\t\t BT_FN_I2_I2_VAR, ATTR_NOVOPS_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN (BUILT_IN_SPECULATION_SAFE_VALUE_4, \"speculation_safe_value_4\",\n+\t\t BT_FN_I4_I4_VAR, ATTR_NOVOPS_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN (BUILT_IN_SPECULATION_SAFE_VALUE_8, \"speculation_safe_value_8\",\n+\t\t BT_FN_I8_I8_VAR, ATTR_NOVOPS_NOTHROW_LEAF_LIST)\n+DEF_GCC_BUILTIN (BUILT_IN_SPECULATION_SAFE_VALUE_16,\n+\t\t \"speculation_safe_value_16\", BT_FN_I16_I16_VAR,\n+\t\t ATTR_NOVOPS_NOTHROW_LEAF_LIST)\n+\n /* Exception support.  */\n DEF_BUILTIN_STUB (BUILT_IN_UNWIND_RESUME, \"__builtin_unwind_resume\")\n DEF_BUILTIN_STUB (BUILT_IN_CXA_END_CLEANUP, \"__builtin_cxa_end_cleanup\")"}, {"sha": "bf1232e42a38bcfb0d5157450971cc1336e38780", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=425fc685dd59c07316a0c9112595331aa77ba112", "patch": "@@ -1,3 +1,12 @@\n+2018-07-31  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* c-common.c (speculation_safe_resolve_call): New function.\n+\t(speculation_safe_resolve_params): New function.\n+\t(speculation_safe_resolve_return): New function.\n+\t(resolve_overloaded_builtin): Handle __builtin_speculation_safe_value.\n+\t* c-cppbuiltin.c (c_cpp_builtins): Add pre-define for\n+\t__HAVE_SPECULATION_SAFE_VALUE.\n+\n 2018-07-20  David Malcolm  <dmalcolm@redhat.com>\n \n \t* c-common.c (c_cpp_error): Remove redundant \"line_table\""}, {"sha": "d919605744e0c2e118896d3bc2ce41701a69db50", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=425fc685dd59c07316a0c9112595331aa77ba112", "patch": "@@ -6457,6 +6457,122 @@ builtin_type_for_size (int size, bool unsignedp)\n   return type ? type : error_mark_node;\n }\n \n+/* Work out the size of the first argument of a call to\n+   __builtin_speculation_safe_value.  Only pointers and integral types\n+   are permitted.  Return -1 if the argument type is not supported or\n+   the size is too large; 0 if the argument type is a pointer or the\n+   size if it is integral.  */\n+static enum built_in_function\n+speculation_safe_value_resolve_call (tree function, vec<tree, va_gc> *params)\n+{\n+  /* Type of the argument.  */\n+  tree type;\n+  int size;\n+\n+  if (vec_safe_is_empty (params))\n+    {\n+      error (\"too few arguments to function %qE\", function);\n+      return BUILT_IN_NONE;\n+    }\n+\n+  type = TREE_TYPE ((*params)[0]);\n+  if (TREE_CODE (type) == ARRAY_TYPE && c_dialect_cxx ())\n+    {\n+      /* Force array-to-pointer decay for C++.   */\n+      (*params)[0] = default_conversion ((*params)[0]);\n+      type = TREE_TYPE ((*params)[0]);\n+    }\n+\n+  if (POINTER_TYPE_P (type))\n+    return BUILT_IN_SPECULATION_SAFE_VALUE_PTR;\n+\n+  if (!INTEGRAL_TYPE_P (type))\n+    goto incompatible;\n+\n+  if (!COMPLETE_TYPE_P (type))\n+    goto incompatible;\n+\n+  size = tree_to_uhwi (TYPE_SIZE_UNIT (type));\n+  if (size == 1 || size == 2 || size == 4 || size == 8 || size == 16)\n+    return ((enum built_in_function)\n+\t    ((int) BUILT_IN_SPECULATION_SAFE_VALUE_1 + exact_log2 (size)));\n+\n+ incompatible:\n+  /* Issue the diagnostic only if the argument is valid, otherwise\n+     it would be redundant at best and could be misleading.  */\n+  if (type != error_mark_node)\n+    error (\"operand type %qT is incompatible with argument %d of %qE\",\n+\t   type, 1, function);\n+\n+  return BUILT_IN_NONE;\n+}\n+\n+/* Validate and coerce PARAMS, the arguments to ORIG_FUNCTION to fit\n+   the prototype for FUNCTION.  The first argument is mandatory, a second\n+   argument, if present, must be type compatible with the first.  */\n+static bool\n+speculation_safe_value_resolve_params (location_t loc, tree orig_function,\n+\t\t\t\t       vec<tree, va_gc> *params)\n+{\n+  tree val;\n+\n+  if (params->length () == 0)\n+    {\n+      error_at (loc, \"too few arguments to function %qE\", orig_function);\n+      return false;\n+    }\n+\n+  else if (params->length () > 2)\n+    {\n+      error_at (loc, \"too many arguments to function %qE\", orig_function);\n+      return false;\n+    }\n+\n+  val = (*params)[0];\n+  if (TREE_CODE (TREE_TYPE (val)) == ARRAY_TYPE)\n+    val = default_conversion (val);\n+  if (!(TREE_CODE (TREE_TYPE (val)) == POINTER_TYPE\n+\t|| TREE_CODE (TREE_TYPE (val)) == INTEGER_TYPE))\n+    {\n+      error_at (loc,\n+\t\t\"expecting argument of type pointer or of type integer \"\n+\t\t\"for argument 1\");\n+      return false;\n+    }\n+  (*params)[0] = val;\n+\n+  if (params->length () == 2)\n+    {\n+      tree val2 = (*params)[1];\n+      if (TREE_CODE (TREE_TYPE (val2)) == ARRAY_TYPE)\n+\tval2 = default_conversion (val2);\n+      if (!(TREE_TYPE (val) == TREE_TYPE (val2)\n+\t    || useless_type_conversion_p (TREE_TYPE (val), TREE_TYPE (val2))))\n+\t{\n+\t  error_at (loc, \"both arguments must be compatible\");\n+\t  return false;\n+\t}\n+      (*params)[1] = val2;\n+    }\n+\n+  return true;\n+}\n+\n+/* Cast the result of the builtin back to the type of the first argument,\n+   preserving any qualifiers that it might have.  */\n+static tree\n+speculation_safe_value_resolve_return (tree first_param, tree result)\n+{\n+  tree ptype = TREE_TYPE (first_param);\n+  tree rtype = TREE_TYPE (result);\n+  ptype = TYPE_MAIN_VARIANT (ptype);\n+\n+  if (tree_int_cst_equal (TYPE_SIZE (ptype), TYPE_SIZE (rtype)))\n+    return convert (ptype, result);\n+\n+  return result;\n+}\n+\n /* A helper function for resolve_overloaded_builtin in resolving the\n    overloaded __sync_ builtins.  Returns a positive power of 2 if the\n    first operand of PARAMS is a pointer to a supported data type.\n@@ -7111,6 +7227,54 @@ resolve_overloaded_builtin (location_t loc, tree function,\n   /* Handle BUILT_IN_NORMAL here.  */\n   switch (orig_code)\n     {\n+    case BUILT_IN_SPECULATION_SAFE_VALUE_N:\n+      {\n+\ttree new_function, first_param, result;\n+\tenum built_in_function fncode\n+\t  = speculation_safe_value_resolve_call (function, params);;\n+\n+\tfirst_param = (*params)[0];\n+\tif (fncode == BUILT_IN_NONE\n+\t    || !speculation_safe_value_resolve_params (loc, function, params))\n+\t  return error_mark_node;\n+\n+\tif (targetm.have_speculation_safe_value (true))\n+\t  {\n+\t    new_function = builtin_decl_explicit (fncode);\n+\t    result = build_function_call_vec (loc, vNULL, new_function, params,\n+\t\t\t\t\t      NULL);\n+\n+\t    if (result == error_mark_node)\n+\t      return result;\n+\n+\t    return speculation_safe_value_resolve_return (first_param, result);\n+\t  }\n+\telse\n+\t  {\n+\t    /* This target doesn't have, or doesn't need, active mitigation\n+\t       against incorrect speculative execution.  Simply return the\n+\t       first parameter to the builtin.  */\n+\t    if (!targetm.have_speculation_safe_value (false))\n+\t      /* The user has invoked __builtin_speculation_safe_value\n+\t\t even though __HAVE_SPECULATION_SAFE_VALUE is not\n+\t\t defined: emit a warning.  */\n+\t      warning_at (input_location, 0,\n+\t\t\t  \"this target does not define a speculation barrier; \"\n+\t\t\t  \"your program will still execute correctly, \"\n+\t\t\t  \"but incorrect speculation may not be be \"\n+\t\t\t  \"restricted\");\n+\n+\t    /* If the optional second argument is present, handle any side\n+\t       effects now.  */\n+\t    if (params->length () == 2\n+\t\t&& TREE_SIDE_EFFECTS ((*params)[1]))\n+\t      return build2 (COMPOUND_EXPR, TREE_TYPE (first_param),\n+\t\t\t     (*params)[1], first_param);\n+\n+\t    return first_param;\n+\t  }\n+      }\n+\n     case BUILT_IN_ATOMIC_EXCHANGE:\n     case BUILT_IN_ATOMIC_COMPARE_EXCHANGE:\n     case BUILT_IN_ATOMIC_LOAD:"}, {"sha": "4fcf3a6e9bab4d2055793caec7fd35aa7d4594c2", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=425fc685dd59c07316a0c9112595331aa77ba112", "patch": "@@ -1361,7 +1361,12 @@ c_cpp_builtins (cpp_reader *pfile)\n     cpp_define (pfile, \"__WCHAR_UNSIGNED__\");\n \n   cpp_atomic_builtins (pfile);\n-    \n+\n+  /* Show support for __builtin_speculation_safe_value () if the target\n+     has been updated to fully support it.  */\n+  if (targetm.have_speculation_safe_value (false))\n+    cpp_define (pfile, \"__HAVE_SPECULATION_SAFE_VALUE\");\n+\n #ifdef DWARF2_UNWIND_INFO\n   if (dwarf2out_do_cfi_asm ())\n     cpp_define (pfile, \"__GCC_HAVE_DWARF2_CFI_ASM\");"}, {"sha": "efad2c8eab5ad1f61823dd7d9c450542f11c1c13", "filename": "gcc/doc/cpp.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fdoc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fdoc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcpp.texi?ref=425fc685dd59c07316a0c9112595331aa77ba112", "patch": "@@ -2381,6 +2381,10 @@ If GCC cannot determine the current date, it will emit a warning message\n These macros are defined when the target processor supports atomic compare\n and swap operations on operands 1, 2, 4, 8 or 16 bytes in length, respectively.\n \n+@item __HAVE_SPECULATION_SAFE_VALUE\n+This macro is defined with the value 1 to show that this version of GCC\n+supports @code{__builtin_speculation_safe_value}.\n+\n @item __GCC_HAVE_DWARF2_CFI_ASM\n This macro is defined when the compiler is emitting DWARF CFI directives\n to the assembler.  When this is defined, it is possible to emit those same"}, {"sha": "bf465d7b93cda579ccc2119cc3b3a62e9eaa353f", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=425fc685dd59c07316a0c9112595331aa77ba112", "patch": "@@ -10960,6 +10960,7 @@ is called and the @var{flag} argument passed to it.\n @findex __builtin_powi\n @findex __builtin_powif\n @findex __builtin_powil\n+@findex __builtin_speculation_safe_value\n @findex _Exit\n @findex _exit\n @findex abort\n@@ -11604,6 +11605,96 @@ check its compatibility with @var{size}.\n \n @end deftypefn\n \n+@deftypefn {Built-in Function} @var{type} __builtin_speculation_safe_value (@var{type} val, @var{type} failval)\n+\n+This built-in function can be used to help mitigate against unsafe\n+speculative execution.  @var{type} may be any integral type or any\n+pointer type.\n+\n+@enumerate\n+@item\n+If the CPU is not speculatively executing the code, then @var{val}\n+is returned.\n+@item\n+If the CPU is executing speculatively then either:\n+@itemize\n+@item\n+The function may cause execution to pause until it is known that the\n+code is no-longer being executed speculatively (in which case\n+@var{val} can be returned, as above); or\n+@item\n+The function may use target-dependent speculation tracking state to cause\n+@var{failval} to be returned when it is known that speculative\n+execution has incorrectly predicted a conditional branch operation.\n+@end itemize\n+@end enumerate\n+\n+The second argument, @var{failval}, is optional and defaults to zero\n+if omitted.\n+\n+GCC defines the preprocessor macro\n+@code{__HAVE_BUILTIN_SPECULATION_SAFE_VALUE} for targets that have been\n+updated to support this builtin.\n+\n+The built-in function can be used where a variable appears to be used in a\n+safe way, but the CPU, due to speculative execution may temporarily ignore\n+the bounds checks.  Consider, for example, the following function:\n+\n+@smallexample\n+int array[500];\n+int f (unsigned untrusted_index)\n+@{\n+  if (untrusted_index < 500)\n+    return array[untrusted_index];\n+  return 0;\n+@}\n+@end smallexample\n+\n+If the function is called repeatedly with @code{untrusted_index} less\n+than the limit of 500, then a branch predictor will learn that the\n+block of code that returns a value stored in @code{array} will be\n+executed.  If the function is subsequently called with an\n+out-of-range value it will still try to execute that block of code\n+first until the CPU determines that the prediction was incorrect\n+(the CPU will unwind any incorrect operations at that point).\n+However, depending on how the result of the function is used, it might be\n+possible to leave traces in the cache that can reveal what was stored\n+at the out-of-bounds location.  The built-in function can be used to\n+provide some protection against leaking data in this way by changing\n+the code to:\n+\n+@smallexample\n+int array[500];\n+int f (unsigned untrusted_index)\n+@{\n+  if (untrusted_index < 500)\n+    return array[__builtin_speculation_safe_value (untrusted_index)];\n+  return 0;\n+@}\n+@end smallexample\n+\n+The built-in function will either cause execution to stall until the\n+conditional branch has been fully resolved, or it may permit\n+speculative execution to continue, but using 0 instead of\n+@code{untrusted_value} if that exceeds the limit.\n+\n+If accessing any memory location is potentially unsafe when speculative\n+execution is incorrect, then the code can be rewritten as\n+\n+@smallexample\n+int array[500];\n+int f (unsigned untrusted_index)\n+@{\n+  if (untrusted_index < 500)\n+    return *__builtin_speculation_safe_value (&array[untrusted_index], NULL);\n+  return 0;\n+@}\n+@end smallexample\n+\n+which will cause a @code{NULL} pointer to be used for the unsafe case.\n+\n+@end deftypefn\n+\n @deftypefn {Built-in Function} int __builtin_types_compatible_p (@var{type1}, @var{type2})\n \n You can use the built-in function @code{__builtin_types_compatible_p} to"}, {"sha": "00c1239b7860625309c621d21c314245db3c2cc1", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=425fc685dd59c07316a0c9112595331aa77ba112", "patch": "@@ -7032,6 +7032,21 @@ should be defined to an instruction that orders both loads and stores\n before the instruction with respect to loads and stores after the instruction.\n This pattern has no operands.\n \n+@cindex @code{speculation_barrier} instruction pattern\n+@item @samp{speculation_barrier}\n+If the target can support speculative execution, then this pattern should\n+be defined to an instruction that will block subsequent execution until\n+any prior speculation conditions has been resolved.  The pattern must also\n+ensure that the compiler cannot move memory operations past the barrier,\n+so it needs to be an UNSPEC_VOLATILE pattern.  The pattern has no\n+operands.\n+\n+If this pattern is not defined then the default expansion of\n+@code{__builtin_speculation_safe_value} will emit a warning.  You can\n+suppress this warning by defining this pattern with a final condition\n+of @code{0} (zero), which tells the compiler that a speculation\n+barrier is not needed for this target.\n+\n @cindex @code{sync_compare_and_swap@var{mode}} instruction pattern\n @item @samp{sync_compare_and_swap@var{mode}}\n This pattern, if defined, emits code for an atomic compare-and-swap"}, {"sha": "351f0b38b0e9beaac4d2619685790e6d7a4c47ce", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=425fc685dd59c07316a0c9112595331aa77ba112", "patch": "@@ -11924,6 +11924,37 @@ maintainer is familiar with.\n \n @end defmac\n \n+@deftypefn {Target Hook} bool TARGET_HAVE_SPECULATION_SAFE_VALUE (bool @var{active})\n+This hook is used to determine the level of target support for\n+ @code{__builtin_speculation_safe_value}.  If called with an argument\n+ of false, it returns true if the target has been modified to support\n+ this builtin.  If called with an argument of true, it returns true\n+ if the target requires active mitigation execution might be speculative.\n+ \n+ The default implementation returns false if the target does not define\n+ a pattern named @code{speculation_barrier}.  Else it returns true\n+ for the first case and whether the pattern is enabled for the current\n+ compilation for the second case.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} rtx TARGET_SPECULATION_SAFE_VALUE (machine_mode @var{mode}, rtx @var{result}, rtx @var{val}, rtx @var{failval})\n+This target hook can be used to generate a target-specific code\n+ sequence that implements the @code{__builtin_speculation_safe_value}\n+ built-in function.  The function must always return @var{val} in\n+ @var{result} in mode @var{mode} when the cpu is not executing\n+ speculatively, but must never return that when speculating until it\n+ is known that the speculation will not be unwound.  The hook supports\n+ two primary mechanisms for implementing the requirements.  The first\n+ is to emit a speculation barrier which forces the processor to wait\n+ until all prior speculative operations have been resolved; the second\n+ is to use a target-specific mechanism that can track the speculation\n+ state and to return @var{failval} if it can determine that\n+ speculation must be unwound at a later time.\n+ \n+ The default implementation simply copies @var{val} to @var{result} and\n+ emits a @code{speculation_barrier} instruction if that is defined.\n+@end deftypefn\n+\n @deftypefn {Target Hook} void TARGET_RUN_TARGET_SELFTESTS (void)\n If selftests are enabled, run any selftests for this target.\n @end deftypefn"}, {"sha": "39a214e9b2c3cd5d5891af8c9cbcb940d0c5ace7", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=425fc685dd59c07316a0c9112595331aa77ba112", "patch": "@@ -8101,4 +8101,8 @@ maintainer is familiar with.\n \n @end defmac\n \n+@hook TARGET_HAVE_SPECULATION_SAFE_VALUE\n+\n+@hook TARGET_SPECULATION_SAFE_VALUE\n+\n @hook TARGET_RUN_TARGET_SELFTESTS"}, {"sha": "dc8d7deba2ecb79d279332a85105ba40ba447731", "filename": "gcc/target.def", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=425fc685dd59c07316a0c9112595331aa77ba112", "patch": "@@ -4155,6 +4155,41 @@ DEFHOOK\n  bool, (void),\n  hook_bool_void_true)\n \n+DEFHOOK\n+(have_speculation_safe_value,\n+\"This hook is used to determine the level of target support for\\n\\\n+ @code{__builtin_speculation_safe_value}.  If called with an argument\\n\\\n+ of false, it returns true if the target has been modified to support\\n\\\n+ this builtin.  If called with an argument of true, it returns true\\n\\\n+ if the target requires active mitigation execution might be speculative.\\n\\\n+ \\n\\\n+ The default implementation returns false if the target does not define\\n\\\n+ a pattern named @code{speculation_barrier}.  Else it returns true\\n\\\n+ for the first case and whether the pattern is enabled for the current\\n\\\n+ compilation for the second case.\",\n+bool, (bool active), default_have_speculation_safe_value)\n+\n+DEFHOOK\n+(speculation_safe_value,\n+\"This target hook can be used to generate a target-specific code\\n\\\n+ sequence that implements the @code{__builtin_speculation_safe_value}\\n\\\n+ built-in function.  The function must always return @var{val} in\\n\\\n+ @var{result} in mode @var{mode} when the cpu is not executing\\n\\\n+ speculatively, but must never return that when speculating until it\\n\\\n+ is known that the speculation will not be unwound.  The hook supports\\n\\\n+ two primary mechanisms for implementing the requirements.  The first\\n\\\n+ is to emit a speculation barrier which forces the processor to wait\\n\\\n+ until all prior speculative operations have been resolved; the second\\n\\\n+ is to use a target-specific mechanism that can track the speculation\\n\\\n+ state and to return @var{failval} if it can determine that\\n\\\n+ speculation must be unwound at a later time.\\n\\\n+ \\n\\\n+ The default implementation simply copies @var{val} to @var{result} and\\n\\\n+ emits a @code{speculation_barrier} instruction if that is defined.\",\n+rtx, (machine_mode mode, rtx result, rtx val, rtx failval),\n+ default_speculation_safe_value)\n+ \n+\n DEFHOOK\n (can_use_doloop_p,\n  \"Return true if it is possible to use low-overhead loops (@code{doloop_end}\\n\\"}, {"sha": "06de1e3fa86ceea59462d571193a7e6f4da51a65", "filename": "gcc/targhooks.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=425fc685dd59c07316a0c9112595331aa77ba112", "patch": "@@ -2314,4 +2314,36 @@ default_preferred_else_value (unsigned, tree type, unsigned, tree *)\n   return build_zero_cst (type);\n }\n \n+/* Default implementation of TARGET_HAVE_SPECULATION_SAFE_VALUE.  */\n+bool\n+default_have_speculation_safe_value (bool active)\n+{\n+#ifdef HAVE_speculation_barrier\n+  return active ? HAVE_speculation_barrier : true;\n+#else\n+  return false;\n+#endif\n+}\n+\n+/* Default implementation of the speculation-safe-load builtin.  This\n+   implementation simply copies val to result and generates a\n+   speculation_barrier insn, if such a pattern is defined.  */\n+rtx\n+default_speculation_safe_value (machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\trtx result, rtx val,\n+\t\t\t\trtx failval ATTRIBUTE_UNUSED)\n+{\n+  emit_move_insn (result, val);\n+\n+#ifdef HAVE_speculation_barrier\n+  /* Assume the target knows what it is doing: if it defines a\n+     speculation barrier, but it is not enabled, then assume that one\n+     isn't needed.  */\n+  if (HAVE_speculation_barrier)\n+    emit_insn (gen_speculation_barrier ());\n+#endif\n+\n+  return result;\n+}\n+\n #include \"gt-targhooks.h\""}, {"sha": "ba53778d468b2a626bf1cda9c2b4e9e4421594df", "filename": "gcc/targhooks.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=425fc685dd59c07316a0c9112595331aa77ba112", "patch": "@@ -281,4 +281,7 @@ extern bool default_stack_clash_protection_final_dynamic_probe (rtx);\n extern void default_select_early_remat_modes (sbitmap);\n extern tree default_preferred_else_value (unsigned, tree, unsigned, tree *);\n \n+extern bool default_have_speculation_safe_value (bool);\n+extern rtx default_speculation_safe_value (machine_mode, rtx, rtx, rtx);\n+\n #endif /* GCC_TARGHOOKS_H */"}, {"sha": "f0d258e83080319809ee385b06b4e974de166b99", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=425fc685dd59c07316a0c9112595331aa77ba112", "patch": "@@ -1,3 +1,9 @@\n+2018-07-31  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* c-c++-common/spec-barrier-1.c: New test.\n+\t* c-c++-common/spec-barrier-2.c: New test.\n+\t* gcc.dg/spec-barrier-3.c: New test.\n+\n 2018-07-31  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/86741"}, {"sha": "e4b44f2af57f15a2a0e096ca0b4c5928ae41ebed", "filename": "gcc/testsuite/c-c++-common/spec-barrier-1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fspec-barrier-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fspec-barrier-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fspec-barrier-1.c?ref=425fc685dd59c07316a0c9112595331aa77ba112", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O\" } */\n+\n+/* Test that __builtin_speculation_safe_value returns the correct value.  */\n+/* This test will cause an unfiltered warning to be emitted on targets\n+   that have not implemented support for speculative execution\n+   barriers.  They should fix that rather than disabling this\n+   test.  */\n+char a = 1;\n+short b = 2;\n+int c = 3;\n+long d = 4;\n+long long e = 5;\n+int *f = (int*) &c;\n+#ifdef __SIZEOF_INT128__\n+__int128 g = 9;\n+#endif\n+\n+int main ()\n+{\n+  if (__builtin_speculation_safe_value (a) != 1)\n+    __builtin_abort ();\n+  if (__builtin_speculation_safe_value (b) != 2)\n+    __builtin_abort ();\n+  if (__builtin_speculation_safe_value (c) != 3)\n+    __builtin_abort ();\n+  if (__builtin_speculation_safe_value (d) != 4)\n+    __builtin_abort ();\n+  if (__builtin_speculation_safe_value (e) != 5)\n+    __builtin_abort ();\n+  if (__builtin_speculation_safe_value (f) != &c)\n+    __builtin_abort ();\n+#ifdef __SIZEOF_INT128__\n+  if (__builtin_speculation_safe_value (g) != 9)\n+    __builtin_abort ();\n+#endif\n+  return 0;\n+}"}, {"sha": "b09567e62a9eea1ce36fff3c749a90be595e89d8", "filename": "gcc/testsuite/c-c++-common/spec-barrier-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fspec-barrier-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fspec-barrier-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fspec-barrier-2.c?ref=425fc685dd59c07316a0c9112595331aa77ba112", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do run } */\n+\n+/* Even on targets that don't need the optional failval parameter,\n+   side-effects on the operand should still be calculated.  */\n+\n+int x = 3;\n+volatile int y = 9;\n+\n+int main ()\n+{\n+  int z = __builtin_speculation_safe_value (x, y++);\n+  if (z != 3 || y != 10)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-prune-output \"this target does not define a speculation barrier;\" } */"}, {"sha": "3ed4d39061a4fac0990a0790628d602f6ed3217a", "filename": "gcc/testsuite/gcc.dg/spec-barrier-3.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Ftestsuite%2Fgcc.dg%2Fspec-barrier-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425fc685dd59c07316a0c9112595331aa77ba112/gcc%2Ftestsuite%2Fgcc.dg%2Fspec-barrier-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fspec-barrier-3.c?ref=425fc685dd59c07316a0c9112595331aa77ba112", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wpedantic\" } */\n+\n+/* __builtin_speculation_safe_value returns a value with the same type\n+   as its first argument.  There should be a warning if that isn't\n+   type-compatible with the use.  */\n+int *\n+f (int x)\n+{\n+  return __builtin_speculation_safe_value (x);  /* { dg-warning \"returning 'int' from a function with return type 'int \\\\*' makes pointer from integer without a cast\" } */\n+}\n+\n+/* { dg-prune-output \"this target does not define a speculation barrier;\" } */"}]}