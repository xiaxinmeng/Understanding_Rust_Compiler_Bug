{"sha": "be3614c740f91caf593e77b7138e65013fc0487b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmUzNjE0Yzc0MGY5MWNhZjU5M2U3N2I3MTM4ZTY1MDEzZmMwNDg3Yg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2019-12-13T09:04:23Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-12-13T09:04:23Z"}, "message": "[Ada] Crash on implicit dereference not made explicit\n\n2019-12-13  Ed Schonberg  <schonberg@adacore.com>\n\ngcc/ada/\n\n\t* sem_res.adb (Resolve): IF an entity reference is overloaded\n\tbecause its type has an Implicit_Dereference aspect, we must\n\texamine the discriminants of the type to determine whether an\n\texplicit dereference must be inserted for use in code\n\tgeneration. Previously this was done for other expressions but\n\tnot for entity references by themselves.  This was sufficient to\n\thandle uses of the aspect in container handling and iteration,\n\tbut not more generally.\n\nFrom-SVN: r279352", "tree": {"sha": "04f944289cd83f4a6cf88d46217dcfcb4de75667", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04f944289cd83f4a6cf88d46217dcfcb4de75667"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be3614c740f91caf593e77b7138e65013fc0487b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be3614c740f91caf593e77b7138e65013fc0487b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be3614c740f91caf593e77b7138e65013fc0487b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be3614c740f91caf593e77b7138e65013fc0487b/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20dc266e5a178fd87bb8ae6ebbf63e391f74e9b0"}], "stats": {"total": 47, "additions": 42, "deletions": 5}, "files": [{"sha": "9cb8f7951f1f584f630a0aee2e1b4dbd43c84dd1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3614c740f91caf593e77b7138e65013fc0487b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3614c740f91caf593e77b7138e65013fc0487b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=be3614c740f91caf593e77b7138e65013fc0487b", "patch": "@@ -1,3 +1,14 @@\n+2019-12-13  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_res.adb (Resolve): IF an entity reference is overloaded\n+\tbecause its type has an Implicit_Dereference aspect, we must\n+\texamine the discriminants of the type to determine whether an\n+\texplicit dereference must be inserted for use in code\n+\tgeneration. Previously this was done for other expressions but\n+\tnot for entity references by themselves.  This was sufficient to\n+\thandle uses of the aspect in container handling and iteration,\n+\tbut not more generally.\n+\n 2019-12-13  Javier Miranda  <miranda@adacore.com>\n \n \t* exp_disp.ads (Expand_Interface_Thunk): Adding one formal (the"}, {"sha": "3568a8901864ea387524bd59aac0692dac185d30", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be3614c740f91caf593e77b7138e65013fc0487b/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be3614c740f91caf593e77b7138e65013fc0487b/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=be3614c740f91caf593e77b7138e65013fc0487b", "patch": "@@ -2640,17 +2640,43 @@ package body Sem_Res is\n                   Set_Etype (N, Expr_Type);\n \n                --  AI05-0139-2: Expression is overloaded because type has\n-               --  implicit dereference. If type matches context, no implicit\n-               --  dereference is involved. If the expression is an entity,\n-               --  generate a reference to it, as this is not done for an\n-               --  overloaded construct during analysis.\n+               --  implicit dereference. The context may be the one that\n+               --  requires implicit dereferemce.\n \n                elsif Has_Implicit_Dereference (Expr_Type) then\n                   Set_Etype (N, Expr_Type);\n                   Set_Is_Overloaded (N, False);\n \n-                  if Is_Entity_Name (N) then\n+               --  If the expression is an entity, generate a reference\n+               --  to it, as this is not done for an overloaded construct\n+               --  during analysis.\n+\n+                  if Is_Entity_Name (N)\n+                    and then Comes_From_Source (N)\n+                  then\n                      Generate_Reference (Entity (N), N);\n+\n+                     --  Examine access discriminants of entity type,\n+                     --  to check whether one of them yields the\n+                     --  expected type.\n+\n+                     declare\n+                        Disc : Entity_Id :=\n+                          First_Discriminant (Etype (Entity (N)));\n+\n+                     begin\n+                        while Present (Disc) loop\n+                           exit when Is_Access_Type (Etype (Disc))\n+                             and then Has_Implicit_Dereference (Disc)\n+                             and then Designated_Type (Etype (Disc)) = Typ;\n+\n+                           Next_Discriminant (Disc);\n+                        end loop;\n+\n+                        if Present (Disc) then\n+                           Build_Explicit_Dereference (N, Disc);\n+                        end if;\n+                     end;\n                   end if;\n \n                   exit Interp_Loop;"}]}