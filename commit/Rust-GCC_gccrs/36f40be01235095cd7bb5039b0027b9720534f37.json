{"sha": "36f40be01235095cd7bb5039b0027b9720534f37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZmNDBiZTAxMjM1MDk1Y2Q3YmI1MDM5YjAwMjdiOTcyMDUzNGYzNw==", "commit": {"author": {"name": "Aditya Kumar", "email": "aditya.k7@samsung.com", "date": "2015-11-23T19:28:13Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-11-23T19:28:13Z"}, "message": "fix PR68279: bail out when scev gets instantiated to not_known\n\nCo-Authored-By: Sebastian Pop <s.pop@samsung.com>\n\nFrom-SVN: r230771", "tree": {"sha": "417ad9898a43ec0ccd452be020c358b9984dcc26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/417ad9898a43ec0ccd452be020c358b9984dcc26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36f40be01235095cd7bb5039b0027b9720534f37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36f40be01235095cd7bb5039b0027b9720534f37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36f40be01235095cd7bb5039b0027b9720534f37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36f40be01235095cd7bb5039b0027b9720534f37/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f29e7f5ea0d1f35c2f0524e31c0da9885a8c917", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f29e7f5ea0d1f35c2f0524e31c0da9885a8c917", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f29e7f5ea0d1f35c2f0524e31c0da9885a8c917"}], "stats": {"total": 222, "additions": 147, "deletions": 75}, "files": [{"sha": "76f2474aba361b4d0f869a39ae5174400ce11846", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36f40be01235095cd7bb5039b0027b9720534f37/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36f40be01235095cd7bb5039b0027b9720534f37/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=36f40be01235095cd7bb5039b0027b9720534f37", "patch": "@@ -1,3 +1,26 @@\n+2015-11-23  Aditya Kumar  <aditya.k7@samsung.com>\n+\t    Sebastian Pop  <s.pop@samsung.com>\n+\n+\tPR tree-optimization/68279\n+\t* graphite-poly.c (new_scop): Remove poly_scop_p.\n+\t* graphite-poly.h (struct scop): Same.\n+\t(build_poly_scop): Declare.\n+\t* graphite-sese-to-poly.c: Do not include graphite-sese-to-poly.h.\n+\t(cleanup_loop_iter_dom): New.\n+\t(build_loop_iteration_domains): Early return when scev analysis fails.\n+\t(create_pw_aff_from_tree): Same.\n+\t(add_condition_to_pbb): Same.\n+\t(add_conditions_to_domain): Same.\n+\t(add_conditions_to_constraints): Same.\n+\t(build_scop_iteration_domain): Same.\n+\t(build_poly_scop): Same.  Do not initialize poly_scop_p.\n+\t* graphite-sese-to-poly.h: Remove.\n+\t* graphite.c: Do not include graphite-sese-to-poly.h.\n+\t(graphite_transform_loops): Stop before code generation when\n+\tbuild_poly_scop fails.\n+\t* sese.c (scalar_evolution_in_region): Add fixme note about scev\n+\tanalysis.\n+\n 2015-11-23  Aditya Kumar  <aditya.k7@samsung.com>\n \t    Sebastian Pop  <s.pop@samsung.com>\n "}, {"sha": "187a3fa2bd490a4795fdcac7c8160fbb549d93e9", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36f40be01235095cd7bb5039b0027b9720534f37/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36f40be01235095cd7bb5039b0027b9720534f37/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=36f40be01235095cd7bb5039b0027b9720534f37", "patch": "@@ -308,7 +308,6 @@ new_scop (edge entry, edge exit)\n   scop_set_region (scop, region);\n   scop->original_schedule = NULL;\n   scop->pbbs.create (3);\n-  scop->poly_scop_p = false;\n   scop->drs.create (3);\n \n   return scop;"}, {"sha": "dec7fd6df8b86fcacf0f73f41d1d4574c729fdbf", "filename": "gcc/graphite-poly.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36f40be01235095cd7bb5039b0027b9720534f37/gcc%2Fgraphite-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36f40be01235095cd7bb5039b0027b9720534f37/gcc%2Fgraphite-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.h?ref=36f40be01235095cd7bb5039b0027b9720534f37", "patch": "@@ -420,10 +420,6 @@ struct scop\n \n   /* Original schedule of the SCoP.  */\n   isl_union_map *original_schedule;\n-\n-  /* True when the scop has been converted to its polyhedral\n-     representation.  */\n-  bool poly_scop_p;\n };\n \n extern scop_p new_scop (edge, edge);\n@@ -468,4 +464,6 @@ carries_deps (__isl_keep isl_union_map *schedule,\n \t      __isl_keep isl_union_map *deps,\n \t      int depth);\n \n+bool build_poly_scop (scop_p);\n+\n #endif"}, {"sha": "65ff4e6111bae4cf8a672357923d02d7350090e0", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 74, "deletions": 29, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36f40be01235095cd7bb5039b0027b9720534f37/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36f40be01235095cd7bb5039b0027b9720534f37/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=36f40be01235095cd7bb5039b0027b9720534f37", "patch": "@@ -66,7 +66,6 @@ extern \"C\" {\n #endif\n \n #include \"graphite-poly.h\"\n-#include \"graphite-sese-to-poly.h\"\n \n /* Assigns to RES the value of the INTEGER_CST T.  */\n \n@@ -590,10 +589,20 @@ set_scop_parameter_dim (scop_p scop)\n   scop->param_context = isl_set_universe (space);\n }\n \n+static inline bool\n+cleanup_loop_iter_dom (isl_set *inner, isl_set *outer, isl_space *space, mpz_t g)\n+{\n+  isl_set_free (inner);\n+  isl_set_free (outer);\n+  isl_space_free (space);\n+  mpz_clear (g);\n+  return false;\n+}\n+\n /* Builds the constraint polyhedra for LOOP in SCOP.  OUTER_PH gives\n    the constraints for the surrounding loops.  */\n \n-static void\n+static bool\n build_loop_iteration_domains (scop_p scop, struct loop *loop,\n                               int nb,\n \t\t\t      isl_set *outer, isl_set **doms)\n@@ -638,11 +647,17 @@ build_loop_iteration_domains (scop_p scop, struct loop *loop,\n \n       nb_iters = scalar_evolution_in_region (region, loop, nb_iters);\n \n+      /* Bail out as we do not know the scev.  */\n+      if (chrec_contains_undetermined (nb_iters))\n+\treturn cleanup_loop_iter_dom (inner, outer, space, g);\n+\n       aff = extract_affine (scop, nb_iters, isl_set_get_space (inner));\n       isl_set *valid = isl_pw_aff_nonneg_set (isl_pw_aff_copy (aff));\n       valid = isl_set_project_out (valid, isl_dim_set, 0,\n \t\t\t\t   isl_set_dim (valid, isl_dim_set));\n-      scop->param_context = isl_set_intersect (scop->param_context, valid);\n+\n+      if (valid)\n+\tscop->param_context = isl_set_intersect (scop->param_context, valid);\n \n       isl_local_space *ls = isl_local_space_from_space (isl_space_copy (space));\n       isl_aff *al = isl_aff_set_coefficient_si (isl_aff_zero_on_domain (ls),\n@@ -686,21 +701,24 @@ build_loop_iteration_domains (scop_p scop, struct loop *loop,\n   else\n     gcc_unreachable ();\n \n-  if (loop->inner)\n-    build_loop_iteration_domains (scop, loop->inner, nb + 1,\n-\t\t\t\t  isl_set_copy (inner), doms);\n+  if (loop->inner\n+      && !build_loop_iteration_domains (scop, loop->inner, nb + 1,\n+\t\t\t\t\tisl_set_copy (inner), doms))\n+    return cleanup_loop_iter_dom (inner, outer, space, g);\n \n   if (nb != 0\n       && loop->next\n-      && loop_in_sese_p (loop->next, region))\n-    build_loop_iteration_domains (scop, loop->next, nb,\n-\t\t\t\t  isl_set_copy (outer), doms);\n+      && loop_in_sese_p (loop->next, region)\n+      && !build_loop_iteration_domains (scop, loop->next, nb,\n+\t\t\t\t\tisl_set_copy (outer), doms))\n+    return cleanup_loop_iter_dom (inner, outer, space, g);\n \n   doms[loop->num] = inner;\n \n   isl_set_free (outer);\n   isl_space_free (space);\n   mpz_clear (g);\n+  return true;\n }\n \n /* Returns a linear expression for tree T evaluated in PBB.  */\n@@ -711,6 +729,11 @@ create_pw_aff_from_tree (poly_bb_p pbb, tree t)\n   scop_p scop = PBB_SCOP (pbb);\n \n   t = scalar_evolution_in_region (scop->scop_info->region, pbb_loop (pbb), t);\n+\n+  /* Bail out as we do not know the scev.  */\n+  if (chrec_contains_undetermined (t))\n+    return NULL;\n+\n   gcc_assert (!automatically_generated_chrec_p (t));\n \n   return extract_affine (scop, t, isl_set_get_space (pbb->domain));\n@@ -720,13 +743,21 @@ create_pw_aff_from_tree (poly_bb_p pbb, tree t)\n    operator.  This allows us to invert the condition or to handle\n    inequalities.  */\n \n-static void\n+static bool\n add_condition_to_pbb (poly_bb_p pbb, gcond *stmt, enum tree_code code)\n {\n   isl_pw_aff *lhs = create_pw_aff_from_tree (pbb, gimple_cond_lhs (stmt));\n+  if (!lhs)\n+    return false;\n+\n   isl_pw_aff *rhs = create_pw_aff_from_tree (pbb, gimple_cond_rhs (stmt));\n-  isl_set *cond;\n+  if (!rhs)\n+    {\n+      isl_pw_aff_free (lhs);\n+      return false;\n+    }\n \n+  isl_set *cond;\n   switch (code)\n     {\n       case LT_EXPR:\n@@ -756,25 +787,26 @@ add_condition_to_pbb (poly_bb_p pbb, gcond *stmt, enum tree_code code)\n       default:\n \tisl_pw_aff_free (lhs);\n \tisl_pw_aff_free (rhs);\n-\treturn;\n+\treturn true;\n     }\n \n   cond = isl_set_coalesce (cond);\n   cond = isl_set_set_tuple_id (cond, isl_set_get_tuple_id (pbb->domain));\n   pbb->domain = isl_set_intersect (pbb->domain, cond);\n+  return true;\n }\n \n /* Add conditions to the domain of PBB.  */\n \n-static void\n+static bool\n add_conditions_to_domain (poly_bb_p pbb)\n {\n   unsigned int i;\n   gimple *stmt;\n   gimple_poly_bb_p gbb = PBB_BLACK_BOX (pbb);\n \n   if (GBB_CONDITIONS (gbb).is_empty ())\n-    return;\n+    return true;\n \n   FOR_EACH_VEC_ELT (GBB_CONDITIONS (gbb), i, stmt)\n     switch (gimple_code (stmt))\n@@ -792,7 +824,8 @@ add_conditions_to_domain (poly_bb_p pbb)\n \t    if (!GBB_CONDITION_CASES (gbb)[i])\n \t      code = invert_tree_comparison (code, false);\n \n-\t    add_condition_to_pbb (pbb, cond_stmt, code);\n+\t    if (!add_condition_to_pbb (pbb, cond_stmt, code))\n+\t      return false;\n \t    break;\n \t  }\n \n@@ -803,19 +836,24 @@ add_conditions_to_domain (poly_bb_p pbb)\n \tgcc_unreachable ();\n \tbreak;\n       }\n+\n+  return true;\n }\n \n /* Traverses all the GBBs of the SCOP and add their constraints to the\n    iteration domains.  */\n \n-static void\n+static bool\n add_conditions_to_constraints (scop_p scop)\n {\n   int i;\n   poly_bb_p pbb;\n \n   FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n-    add_conditions_to_domain (pbb);\n+    if (!add_conditions_to_domain (pbb))\n+      return false;\n+\n+  return true;\n }\n \n /* Add constraints on the possible values of parameter P from the type\n@@ -895,19 +933,23 @@ build_scop_context (scop_p scop)\n    SCOP, and that vary for the execution of the current basic block.\n    Returns false if there is no loop in SCOP.  */\n \n-static void\n+static bool\n build_scop_iteration_domain (scop_p scop)\n {\n   sese_info_p region = scop->scop_info;\n   int nb_loops = number_of_loops (cfun);\n   isl_set **doms = XCNEWVEC (isl_set *, nb_loops);\n-\n+  bool res = true;\n   int i;\n   struct loop *loop;\n   FOR_EACH_VEC_ELT (region->loop_nest, i, loop)\n-    if (!loop_in_sese_p (loop_outer (loop), region->region))\n-      build_loop_iteration_domains (scop, loop, 0,\n-\t\t\t\t    isl_set_copy (scop->param_context), doms);\n+    if (!loop_in_sese_p (loop_outer (loop), region->region)\n+\t&& !build_loop_iteration_domains (scop, loop, 0,\n+\t\t\t\t\t  isl_set_copy (scop->param_context), doms))\n+      {\n+\tres = false;\n+\tgoto cleanup;\n+      }\n \n   poly_bb_p pbb;\n   FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n@@ -923,11 +965,13 @@ build_scop_iteration_domain (scop_p scop)\n \t\t\t\t\t  isl_id_for_pbb (scop, pbb));\n     }\n \n+ cleanup:\n   for (int i = 0; i < nb_loops; i++)\n     if (doms[i])\n       isl_set_free (doms[i]);\n \n   free (doms);\n+  return res;\n }\n \n /* Add a constrain to the ACCESSES polyhedron for the alias set of\n@@ -1187,20 +1231,21 @@ build_scop_drs (scop_p scop)\n \n /* Builds the polyhedral representation for a SESE region.  */\n \n-void\n+bool\n build_poly_scop (scop_p scop)\n {\n   set_scop_parameter_dim (scop);\n-  build_scop_iteration_domain (scop);\n+  if (!build_scop_iteration_domain (scop))\n+    return false;\n+\n   build_scop_context (scop);\n-  add_conditions_to_constraints (scop);\n+\n+  if (!add_conditions_to_constraints (scop))\n+    return false;\n \n   build_scop_drs (scop);\n   build_scop_minimal_scattering (scop);\n   build_scop_original_schedule (scop);\n-\n-  /* This SCoP has been translated to the polyhedral\n-     representation.  */\n-  scop->poly_scop_p = true;\n+  return true;\n }\n #endif  /* HAVE_isl */"}, {"sha": "48f0d56acff418119600c68ec39ed833a12e5b80", "filename": "gcc/graphite-sese-to-poly.h", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f29e7f5ea0d1f35c2f0524e31c0da9885a8c917/gcc%2Fgraphite-sese-to-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f29e7f5ea0d1f35c2f0524e31c0da9885a8c917/gcc%2Fgraphite-sese-to-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.h?ref=8f29e7f5ea0d1f35c2f0524e31c0da9885a8c917", "patch": "@@ -1,26 +0,0 @@\n-/* Conversion of SESE regions to Polyhedra.\n-   Copyright (C) 2009-2015 Free Software Foundation, Inc.\n-   Contributed by Sebastian Pop <sebastian.pop@amd.com>.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_GRAPHITE_SESE_TO_POLY_H\n-#define GCC_GRAPHITE_SESE_TO_POLY_H\n-\n-void build_poly_scop (scop_p);\n-\n-#endif"}, {"sha": "ef7e64daf2f000639e41bee9d8a0cf4d691f046b", "filename": "gcc/graphite.c", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36f40be01235095cd7bb5039b0027b9720534f37/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36f40be01235095cd7bb5039b0027b9720534f37/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=36f40be01235095cd7bb5039b0027b9720534f37", "patch": "@@ -62,7 +62,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"graphite-poly.h\"\n #include \"graphite-scop-detection.h\"\n #include \"graphite-isl-ast-to-gimple.h\"\n-#include \"graphite-sese-to-poly.h\"\n \n /* Print global statistics to FILE.  */\n \n@@ -326,20 +325,18 @@ graphite_transform_loops (void)\n     if (dbg_cnt (graphite_scop))\n       {\n \tscop->isl_context = ctx;\n-\tbuild_poly_scop (scop);\n-\n-\tif (dump_file && dump_flags)\n-\t  print_scop (dump_file, scop);\n-\tif (scop->poly_scop_p\n-\t    && apply_poly_transforms (scop))\n-\t  {\n-\t    need_cfg_cleanup_p = true;\n-\t    /* When code generation is not successful, do not continue\n-\t       generating code for the next scops: the IR has to be cleaned up\n-\t       and could be in an inconsistent state.  */\n-\t    if (!graphite_regenerate_ast_isl (scop))\n-\t      break;\n-\t  }\n+\tif (!build_poly_scop (scop))\n+\t  continue;\n+\n+\tif (!apply_poly_transforms (scop))\n+\t  continue;\n+\n+\tneed_cfg_cleanup_p = true;\n+\t/* When code generation is not successful, do not continue\n+\t   generating code for the next scops: the IR has to be cleaned up\n+\t   and could be in an inconsistent state.  */\n+\tif (!graphite_regenerate_ast_isl (scop))\n+\t  break;\n       }\n \n   free_scops (scops);"}, {"sha": "74dc4ac7b869370b6f66256e815b262b1ce5208f", "filename": "gcc/sese.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36f40be01235095cd7bb5039b0027b9720534f37/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36f40be01235095cd7bb5039b0027b9720534f37/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=36f40be01235095cd7bb5039b0027b9720534f37", "patch": "@@ -609,6 +609,8 @@ scalar_evolution_in_region (sese_l &region, loop_p loop, tree t)\n \n   if (TREE_CODE (t) != SSA_NAME\n       || loop_in_sese_p (loop, region))\n+    /* FIXME: we would need instantiate SCEV to work on a region, and be more\n+       flexible wrt. memory loads that may be invariant in the region.  */\n     return instantiate_scev (before, loop,\n \t\t\t     analyze_scalar_evolution (loop, t));\n "}, {"sha": "19fa7024246941be23a3e52e731051ad1fe08ad2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36f40be01235095cd7bb5039b0027b9720534f37/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36f40be01235095cd7bb5039b0027b9720534f37/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=36f40be01235095cd7bb5039b0027b9720534f37", "patch": "@@ -1,3 +1,9 @@\n+2015-11-23  Aditya Kumar  <aditya.k7@samsung.com>\n+\t    Sebastian Pop  <s.pop@samsung.com>\n+\n+\tPR tree-optimization/68279\n+\t* testsuite/gfortran.dg/graphite/pr68279.f90: New.\n+\n 2015-11-23  Marek Polacek  <polacek@redhat.com>\n \n \tPR tree-optimization/68455"}, {"sha": "e68d6e71118d77a0a4fcd7b796d544ce2ce13ea4", "filename": "gcc/testsuite/gfortran.dg/graphite/pr68279.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36f40be01235095cd7bb5039b0027b9720534f37/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr68279.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36f40be01235095cd7bb5039b0027b9720534f37/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr68279.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr68279.f90?ref=36f40be01235095cd7bb5039b0027b9720534f37", "patch": "@@ -0,0 +1,28 @@\n+! { dg-options \"-std=legacy -floop-nest-optimize -O2\" }\n+\n+MODULE dbcsr_mm_accdrv\n+  INTEGER, SAVE :: accdrv_binning_nbins = 4096\n+  INTEGER, SAVE :: accdrv_binning_binsize = 16\n+  INTEGER, PARAMETER, PUBLIC :: dbcsr_ps_width = 7\n+  CONTAINS\n+  SUBROUTINE stack_binning(params_in, params_out, stack_size)\n+    INTEGER, INTENT(IN)                      :: stack_size\n+    INTEGER, DIMENSION(dbcsr_ps_width, &\n+      stack_size), INTENT(OUT)               :: params_out\n+    INTEGER, DIMENSION(dbcsr_ps_width, &\n+      stack_size), INTENT(IN)                :: params_in\n+    INTEGER, DIMENSION(accdrv_binning_nbins) :: bin_top\n+    INTEGER, DIMENSION(dbcsr_ps_width)       :: val\n+    INTEGER, DIMENSION(dbcsr_ps_width, &\n+      accdrv_binning_binsize, &\n+      accdrv_binning_nbins)                  :: bin_arr\n+     DO i=1,stack_size\n+        val(:) = params_in(:,i)\n+        IF(bin_top(bin_id) > accdrv_binning_binsize) THEN\n+           params_out(:, top:top+bin_top(bin_id)-2) = bin_arr(:, 1:bin_top(bin_id)-1, bin_id)\n+        ENDIF\n+        bin_arr(:, bin_top(bin_id), bin_id) =  val(:)\n+        bin_top(bin_id) = bin_top(bin_id) + 1\n+     END DO\n+  END SUBROUTINE  stack_binning\n+END MODULE"}]}