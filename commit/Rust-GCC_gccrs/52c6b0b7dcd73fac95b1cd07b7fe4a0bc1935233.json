{"sha": "52c6b0b7dcd73fac95b1cd07b7fe4a0bc1935233", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJjNmIwYjdkY2Q3M2ZhYzk1YjFjZDA3YjdmZTRhMGJjMTkzNTIzMw==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2005-12-16T09:09:37Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2005-12-16T09:09:37Z"}, "message": "re PR rtl-optimization/24823 (ICE in insert_save, at caller-save.c:719)\n\n2005-12-16  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\tPR 24823\n\t* flow.c (mark_used_dest_regs): New function.\n\t(mark_used_regs): Call mark_used_dest_regs.\n\n2005-12-16  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\tPR 24823\n\t* gfortran.dg/pr24823.f: New test.\n\nFrom-SVN: r108632", "tree": {"sha": "86f6ca423a409da74f1b7d32f54c9fcdf15a340e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86f6ca423a409da74f1b7d32f54c9fcdf15a340e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52c6b0b7dcd73fac95b1cd07b7fe4a0bc1935233", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52c6b0b7dcd73fac95b1cd07b7fe4a0bc1935233", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52c6b0b7dcd73fac95b1cd07b7fe4a0bc1935233", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52c6b0b7dcd73fac95b1cd07b7fe4a0bc1935233/comments", "author": null, "committer": null, "parents": [{"sha": "7d48c9e2cc0d77630d365efe8fa1803a224a9a0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d48c9e2cc0d77630d365efe8fa1803a224a9a0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d48c9e2cc0d77630d365efe8fa1803a224a9a0a"}], "stats": {"total": 253, "additions": 186, "deletions": 67}, "files": [{"sha": "c7dfd88bad7d87f6211af22324b2e837bb98c45f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52c6b0b7dcd73fac95b1cd07b7fe4a0bc1935233/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52c6b0b7dcd73fac95b1cd07b7fe4a0bc1935233/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52c6b0b7dcd73fac95b1cd07b7fe4a0bc1935233", "patch": "@@ -1,3 +1,9 @@\n+2005-12-16  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\tPR 24823\n+\t* flow.c (mark_used_dest_regs): New function.\n+\t(mark_used_regs): Call mark_used_dest_regs.\n+\n 2005-12-16  Jeff Law  <law@redhat.com>\n \n \t* tree-ssa-dse.c (dse_optimize_stmt): Correctly handle PHI nodes which"}, {"sha": "9ef0a906ff3522d4523504b75f8460a2a6a9fe2b", "filename": "gcc/flow.c", "status": "modified", "additions": 97, "deletions": 67, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52c6b0b7dcd73fac95b1cd07b7fe4a0bc1935233/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52c6b0b7dcd73fac95b1cd07b7fe4a0bc1935233/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=52c6b0b7dcd73fac95b1cd07b7fe4a0bc1935233", "patch": "@@ -3879,6 +3879,92 @@ mark_used_reg (struct propagate_block_info *pbi, rtx reg,\n     }\n }\n \n+/* Scan expression X for registers which have to be marked used in PBI.  \n+   X is considered to be the SET_DEST rtx of SET.  TRUE is returned if\n+   X could be handled by this function.  */\n+\n+static bool\n+mark_used_dest_regs (struct propagate_block_info *pbi, rtx x, rtx cond, rtx insn)\n+{\n+  int regno;\n+  bool mark_dest = false;\n+  rtx dest = x;\n+  \n+  /* On some platforms calls return values spread over several \n+     locations.  These locations are wrapped in a EXPR_LIST rtx\n+     together with a CONST_INT offset.  */\n+  if (GET_CODE (x) == EXPR_LIST\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    x = XEXP (x, 0);\n+  \n+  if (x == NULL_RTX)\n+    return false;\n+\n+  /* If storing into MEM, don't show it as being used.  But do\n+     show the address as being used.  */\n+  if (MEM_P (x))\n+    {\n+#ifdef AUTO_INC_DEC\n+      if (pbi->flags & PROP_AUTOINC)\n+\tfind_auto_inc (pbi, x, insn);\n+#endif\n+      mark_used_regs (pbi, XEXP (x, 0), cond, insn);\n+      return true;\n+    }\n+\t    \n+  /* Storing in STRICT_LOW_PART is like storing in a reg\n+     in that this SET might be dead, so ignore it in TESTREG.\n+     but in some other ways it is like using the reg.\n+     \n+     Storing in a SUBREG or a bit field is like storing the entire\n+     register in that if the register's value is not used\n+\t       then this SET is not needed.  */\n+  while (GET_CODE (x) == STRICT_LOW_PART\n+\t || GET_CODE (x) == ZERO_EXTRACT\n+\t || GET_CODE (x) == SUBREG)\n+    {\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n+      if ((pbi->flags & PROP_REG_INFO) && GET_CODE (x) == SUBREG)\n+\trecord_subregs_of_mode (x);\n+#endif\n+      \n+      /* Modifying a single register in an alternate mode\n+\t does not use any of the old value.  But these other\n+\t ways of storing in a register do use the old value.  */\n+      if (GET_CODE (x) == SUBREG\n+\t  && !((REG_BYTES (SUBREG_REG (x))\n+\t\t+ UNITS_PER_WORD - 1) / UNITS_PER_WORD\n+\t       > (REG_BYTES (x)\n+\t\t  + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\t;\n+      else\n+\tmark_dest = true;\n+      \n+      x = XEXP (x, 0);\n+    }\n+  \n+  /* If this is a store into a register or group of registers,\n+     recursively scan the value being stored.  */\n+  if (REG_P (x)\n+      && (regno = REGNO (x),\n+\t  !(regno == FRAME_POINTER_REGNUM\n+\t    && (!reload_completed || frame_pointer_needed)))\n+#if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n+      && !(regno == HARD_FRAME_POINTER_REGNUM\n+\t   && (!reload_completed || frame_pointer_needed))\n+#endif\n+#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n+      && !(regno == ARG_POINTER_REGNUM && fixed_regs[regno])\n+#endif\n+      )\n+    {\n+      if (mark_dest)\n+\tmark_used_regs (pbi, dest, cond, insn);\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* Scan expression X and store a 1-bit in NEW_LIVE for each reg it uses.\n    This is done assuming the registers needed from X are those that\n    have 1-bits in PBI->REG_LIVE.\n@@ -3890,7 +3976,6 @@ static void\n mark_used_regs (struct propagate_block_info *pbi, rtx x, rtx cond, rtx insn)\n {\n   RTX_CODE code;\n-  int regno;\n   int flags = pbi->flags;\n \n  retry:\n@@ -3991,73 +4076,18 @@ mark_used_regs (struct propagate_block_info *pbi, rtx x, rtx cond, rtx insn)\n \n     case SET:\n       {\n-\trtx testreg = SET_DEST (x);\n-\tint mark_dest = 0;\n-\n-\t/* If storing into MEM, don't show it as being used.  But do\n-\t   show the address as being used.  */\n-\tif (MEM_P (testreg))\n-\t  {\n-#ifdef AUTO_INC_DEC\n-\t    if (flags & PROP_AUTOINC)\n-\t      find_auto_inc (pbi, testreg, insn);\n-#endif\n-\t    mark_used_regs (pbi, XEXP (testreg, 0), cond, insn);\n-\t    mark_used_regs (pbi, SET_SRC (x), cond, insn);\n-\t    return;\n-\t  }\n-\n-\t/* Storing in STRICT_LOW_PART is like storing in a reg\n-\t   in that this SET might be dead, so ignore it in TESTREG.\n-\t   but in some other ways it is like using the reg.\n-\n-\t   Storing in a SUBREG or a bit field is like storing the entire\n-\t   register in that if the register's value is not used\n-\t   then this SET is not needed.  */\n-\twhile (GET_CODE (testreg) == STRICT_LOW_PART\n-\t       || GET_CODE (testreg) == ZERO_EXTRACT\n-\t       || GET_CODE (testreg) == SUBREG)\n-\t  {\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-\t    if ((flags & PROP_REG_INFO) && GET_CODE (testreg) == SUBREG)\n-\t      record_subregs_of_mode (testreg);\n-#endif\n-\n-\t    /* Modifying a single register in an alternate mode\n-\t       does not use any of the old value.  But these other\n-\t       ways of storing in a register do use the old value.  */\n-\t    if (GET_CODE (testreg) == SUBREG\n-\t\t&& !((REG_BYTES (SUBREG_REG (testreg))\n-\t\t      + UNITS_PER_WORD - 1) / UNITS_PER_WORD\n-\t\t     > (REG_BYTES (testreg)\n-\t\t\t+ UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\t      ;\n-\t    else\n-\t      mark_dest = 1;\n-\n-\t    testreg = XEXP (testreg, 0);\n-\t  }\n-\n-\t/* If this is a store into a register or group of registers,\n-\t   recursively scan the value being stored.  */\n-\n-\tif ((GET_CODE (testreg) == PARALLEL\n-\t     && GET_MODE (testreg) == BLKmode)\n-\t    || (REG_P (testreg)\n-\t\t&& (regno = REGNO (testreg),\n-\t\t    ! (regno == FRAME_POINTER_REGNUM\n-\t\t       && (! reload_completed || frame_pointer_needed)))\n-#if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-\t\t&& ! (regno == HARD_FRAME_POINTER_REGNUM\n-\t\t      && (! reload_completed || frame_pointer_needed))\n-#endif\n-#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n-\t\t&& ! (regno == ARG_POINTER_REGNUM && fixed_regs[regno])\n-#endif\n-\t\t))\n+\trtx dest = SET_DEST (x);\n+\tint i;\n+\tbool ret = false;\n+\n+\tif (GET_CODE (dest) == PARALLEL)\n+\t  for (i = 0; i < XVECLEN (dest, 0); i++)\n+\t    ret |= mark_used_dest_regs (pbi, XVECEXP (dest, 0, i), cond, insn);\n+\telse\n+\t  ret = mark_used_dest_regs (pbi, dest, cond, insn);\n+\t\n+\tif (ret)\n \t  {\n-\t    if (mark_dest)\n-\t      mark_used_regs (pbi, SET_DEST (x), cond, insn);\n \t    mark_used_regs (pbi, SET_SRC (x), cond, insn);\n \t    return;\n \t  }"}, {"sha": "8c498964ce5df40d7d4ed2f70887721e474283cb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52c6b0b7dcd73fac95b1cd07b7fe4a0bc1935233/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52c6b0b7dcd73fac95b1cd07b7fe4a0bc1935233/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=52c6b0b7dcd73fac95b1cd07b7fe4a0bc1935233", "patch": "@@ -1,3 +1,8 @@\n+2005-12-16  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\tPR 24823\n+\t* gfortran.dg/pr24823.f: New test.\n+\n 2005-12-16  Jeff Law  <law@redhat.com>\n \n \t* gcc.dg/tree-ssa/ssa-dse-8.c: New test."}, {"sha": "1b6f448d9d9f535510a7cd9e143c616b9db0e5e6", "filename": "gcc/testsuite/gfortran.dg/pr24823.f", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52c6b0b7dcd73fac95b1cd07b7fe4a0bc1935233/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr24823.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52c6b0b7dcd73fac95b1cd07b7fe4a0bc1935233/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr24823.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr24823.f?ref=52c6b0b7dcd73fac95b1cd07b7fe4a0bc1935233", "patch": "@@ -0,0 +1,78 @@\n+!     { dg-do compile }\n+!     { dg-options \"-O2\" }\n+!     PR24823 Flow didn't handle a PARALLEL as destination of a SET properly.\n+      SUBROUTINE ZLATMR( M, N, DIST, ISEED, SYM, D, MODE, COND, DMAX,\n+     $     RSIGN, GRADE, DL, MODEL, CONDL, DR, MODER,\n+     $     PACK, A, LDA, IWORK, INFO )\n+      COMPLEX*16         A( LDA, * ), D( * ), DL( * ), DR( * )\n+      LOGICAL            BADPVT, DZERO, FULBND\n+      COMPLEX*16         ZLATM2, ZLATM3\n+      IF( IGRADE.EQ.4 .AND. MODEL.EQ.0 ) THEN\n+      END IF\n+      IF( IPVTNG.GT.0 ) THEN\n+      END IF\n+      IF( M.LT.0 ) THEN\n+      ELSE IF( IPACK.EQ.-1 .OR. ( ( IPACK.EQ.1 .OR. IPACK.EQ.2 .OR.\n+     $        IPACK.EQ.5 .OR. IPACK.EQ.6 ) .AND. ISYM.EQ.1 ) .OR.\n+     $        ( IPACK.EQ.3 .AND. ISYM.EQ.1 .AND. ( KL.NE.0 .OR. M.NE.\n+     $        6 ) .AND. LDA.LT.KUU+1 ) .OR.\n+     $        ( IPACK.EQ.7 .AND. LDA.LT.KLL+KUU+1 ) ) THEN\n+         INFO = -26\n+      END IF\n+      IF( INFO.NE.0 ) THEN\n+         RETURN\n+      END IF\n+      IF( KUU.EQ.N-1 .AND. KLL.EQ.M-1 )\n+     $     FULBND = .TRUE.\n+      IF( MODE.NE.0 .AND. MODE.NE.-6 .AND. MODE.NE.6 ) THEN\n+         TEMP = ABS( D( 1 ) )\n+         IF( TEMP.EQ.ZERO .AND. DMAX.NE.CZERO ) THEN\n+            INFO = 2\n+         END IF\n+      END IF\n+      IF( ISYM.EQ.0 ) THEN\n+      END IF\n+      IF( IGRADE.EQ.1 .OR. IGRADE.EQ.3 .OR. IGRADE.EQ.4 .OR. IGRADE.EQ.\n+     $     5 .OR. IGRADE.EQ.6 ) THEN\n+         IF( INFO.NE.0 ) THEN\n+         END IF\n+      END IF\n+      IF( FULBND ) THEN\n+         IF( IPACK.EQ.0 ) THEN\n+            IF( ISYM.EQ.0 ) THEN\n+               CTEMP = ZLATM3( M, N, I, J, ISUB, JSUB, KL, KU,\n+     $              IWORK, SPARSE )\n+               DO 120 I = 1, M\n+                  CTEMP = ZLATM3( M, N, I, J, ISUB, JSUB, KL, KU,\n+     $                 IWORK, SPARSE )\n+ 120           CONTINUE\n+            END IF\n+            IF( I.LT.1 ) THEN\n+               IF( ISYM.EQ.0 ) THEN\n+                  A( J-I+1, I ) = DCONJG( ZLATM2( M, N, I, J, KL,\n+     $                 DR, IPVTNG, IWORK, SPARSE ) )\n+               ELSE\n+                  A( J-I+1, I ) = ZLATM2( M, N, I, J, KL, KU,\n+     $                 IPVTNG, IWORK, SPARSE )\n+               END IF\n+            END IF\n+            IF( ISYM.NE.1 ) THEN\n+               IF( I.GE.1 .AND. I.NE.J ) THEN\n+                  IF( ISYM.EQ.0 ) THEN\n+                  END IF\n+               END IF\n+               A( I-J+KUU+1, J ) = ZLATM2( M, N, I, J, KL, KU,\n+     $              DR, IPVTNG, IWORK, SPARSE )\n+            END IF\n+         END IF\n+      END IF\n+      IF( IPACK.EQ.0 ) THEN\n+         ONORM = ZLANGB( 'M', N, KLL, KUU, A, LDA, TEMPA )\n+      END IF\n+      IF( ANORM.GE.ZERO ) THEN\n+         IF( ANORM.GT.ZERO .AND. ONORM.EQ.ZERO ) THEN\n+            IF( IPACK.LE.2 ) THEN\n+            END IF\n+         END IF\n+      END IF\n+      END"}]}