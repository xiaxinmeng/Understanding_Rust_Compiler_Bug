{"sha": "ed27799786f55ec8aed9f6dcb19852f924cc038e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQyNzc5OTc4NmY1NWVjOGFlZDlmNmRjYjE5ODUyZjkyNGNjMDM4ZQ==", "commit": {"author": {"name": "Johannes Singler", "email": "singler@kit.edu", "date": "2010-04-22T10:14:07Z"}, "committer": {"name": "Johannes Singler", "email": "singler@gcc.gnu.org", "date": "2010-04-22T10:14:07Z"}, "message": "partition.h (__parallel_partition): Improve scalability by...\n\n2010-04-22  Johannes Singler  <singler@kit.edu>\n\n        * include/parallel/partition.h (__parallel_partition):\n        Improve scalability by:\n        -introducing new variables __leftold, __rightold, __dist, thus\n        -getting rid of omp lock by using atomic operations\n        -getting rid of two omp barriers\n\nFrom-SVN: r158636", "tree": {"sha": "afe3d44ee2a64189890e9b1db1de661bb1937379", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afe3d44ee2a64189890e9b1db1de661bb1937379"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed27799786f55ec8aed9f6dcb19852f924cc038e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed27799786f55ec8aed9f6dcb19852f924cc038e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed27799786f55ec8aed9f6dcb19852f924cc038e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed27799786f55ec8aed9f6dcb19852f924cc038e/comments", "author": null, "committer": null, "parents": [{"sha": "6a0447ba7f4baa35624a7ff8a42b6c03f272ae40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a0447ba7f4baa35624a7ff8a42b6c03f272ae40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a0447ba7f4baa35624a7ff8a42b6c03f272ae40"}], "stats": {"total": 154, "additions": 79, "deletions": 75}, "files": [{"sha": "96d166fa22565862e8e948acfb6c153a48df2cdc", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed27799786f55ec8aed9f6dcb19852f924cc038e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed27799786f55ec8aed9f6dcb19852f924cc038e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ed27799786f55ec8aed9f6dcb19852f924cc038e", "patch": "@@ -1,3 +1,11 @@\n+2010-04-22  Johannes Singler  <singler@kit.edu>\n+\n+        * include/parallel/partition.h (__parallel_partition):\n+        Improve scalability by:\n+        -introducing new variables __leftold, __rightold, __dist, thus\n+        -getting rid of omp lock by using atomic operations\n+        -getting rid of two omp barriers\n+\n 2010-04-22  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \t* doc/xml/faq.xml: Link to manual."}, {"sha": "0d5a139968c9472592aab8b7bbe7af597a70a68c", "filename": "libstdc++-v3/include/parallel/partition.h", "status": "modified", "additions": 71, "deletions": 75, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed27799786f55ec8aed9f6dcb19852f924cc038e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed27799786f55ec8aed9f6dcb19852f924cc038e/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h?ref=ed27799786f55ec8aed9f6dcb19852f924cc038e", "patch": "@@ -66,27 +66,26 @@ namespace __gnu_parallel\n \n       const _Settings& __s = _Settings::get();\n \n-      // Shared.\n-      _GLIBCXX_VOLATILE _DifferenceType __left = 0, __right = __n - 1;\n-      _GLIBCXX_VOLATILE _DifferenceType __leftover_left, __leftover_right;\n-      _GLIBCXX_VOLATILE _DifferenceType __leftnew, __rightnew;\n+      // shared\n+      _GLIBCXX_VOLATILE _DifferenceType __left = 0, __right = __n - 1,\n+                                        __dist = __n,\n+                                        __leftover_left, __leftover_right,\n+                                        __leftnew, __rightnew;\n \n-      bool* __reserved_left = NULL, * __reserved_right = NULL;\n+      // just 0 or 1, but int to allow atomic operations\n+      int* __reserved_left = NULL, * __reserved_right = NULL;\n \n       _DifferenceType __chunk_size = __s.partition_chunk_size;\n \n-      omp_lock_t __result_lock;\n-      omp_init_lock(&__result_lock);\n-\n       //at least two chunks per thread\n-      if (__right - __left + 1 >= 2 * __num_threads * __chunk_size)\n+      if (__dist >= 2 * __num_threads * __chunk_size)\n #       pragma omp parallel num_threads(__num_threads)\n \t{\n #         pragma omp single\n \t  {\n \t    __num_threads = omp_get_num_threads();\n-\t    __reserved_left = new bool[__num_threads];\n-\t    __reserved_right = new bool[__num_threads];\n+\t    __reserved_left = new int[__num_threads];\n+\t    __reserved_right = new int[__num_threads];\n \n \t    if (__s.partition_chunk_share > 0.0)\n \t      __chunk_size = std::max<_DifferenceType>\n@@ -96,17 +95,16 @@ namespace __gnu_parallel\n \t      __chunk_size = __s.partition_chunk_size;\n \t  }\n \n-\t  while (__right - __left + 1 >= 2 * __num_threads * __chunk_size)\n+\t  while (__dist >= 2 * __num_threads * __chunk_size)\n \t    {\n #             pragma omp single\n \t      {\n-\t\t_DifferenceType __num_chunks = ((__right - __left + 1) \n-\t\t\t\t\t\t/ __chunk_size);\n+\t\t_DifferenceType __num_chunks = __dist / __chunk_size;\n \n \t\tfor (_ThreadIndex __r = 0; __r < __num_threads; ++__r)\n \t\t  {\n-\t\t    __reserved_left[__r] = false;\n-\t\t    __reserved_right[__r] = false;\n+\t\t    __reserved_left [__r] = 0; // false\n+\t\t    __reserved_right[__r] = 0; // false\n \t\t  }\n \t\t__leftover_left = 0;\n \t\t__leftover_right = 0;\n@@ -115,47 +113,56 @@ namespace __gnu_parallel\n \t      // Private.\n \t      _DifferenceType __thread_left, __thread_left_border,\n \t\t              __thread_right, __thread_right_border;\n-\t      __thread_left = __left + 1;\n \n+\t      __thread_left = __left + 1;\n \t      // Just to satisfy the condition below.\n \t      __thread_left_border = __thread_left - 1;\n+\n \t      __thread_right = __n - 1;\n+             // Just to satisfy the condition below.\n \t      __thread_right_border = __thread_right + 1;\n \n \t      bool __iam_finished = false;\n \t      while (!__iam_finished)\n \t\t{\n \t\t  if (__thread_left > __thread_left_border)\n \t\t    {\n-\t\t      omp_set_lock(&__result_lock);\n-\t\t      if (__left + (__chunk_size - 1) > __right)\n-\t\t\t__iam_finished = true;\n-\t\t      else\n-\t\t\t{\n-\t\t\t  __thread_left = __left;\n-\t\t\t  __thread_left_border = __left + (__chunk_size - 1);\n-\t\t\t  __left += __chunk_size;\n-\t\t\t}\n-\t\t      omp_unset_lock(&__result_lock);\n+                      _DifferenceType __former_dist =\n+                              __fetch_and_add(&__dist, -__chunk_size);\n+                      if (__former_dist < __chunk_size)\n+                        {\n+                          __fetch_and_add(&__dist, __chunk_size);\n+                          __iam_finished = true;\n+                          break;\n+                        }\n+                      else\n+                        {\n+                          __thread_left =\n+                                  __fetch_and_add(&__left, __chunk_size);\n+                          __thread_left_border =\n+                                  __thread_left + (__chunk_size - 1);\n+                        }\n \t\t    }\n \n \t\t  if (__thread_right < __thread_right_border)\n \t\t    {\n-\t\t      omp_set_lock(&__result_lock);\n-\t\t      if (__left > __right - (__chunk_size - 1))\n-\t\t\t__iam_finished = true;\n-\t\t      else\n-\t\t\t{\n-\t\t\t  __thread_right = __right;\n-\t\t\t  __thread_right_border = __right - (__chunk_size - 1);\n-\t\t\t  __right -= __chunk_size;\n-\t\t\t}\n-\t\t      omp_unset_lock(&__result_lock);\n+                      _DifferenceType __former_dist =\n+                              __fetch_and_add(&__dist, -__chunk_size);\n+                      if (__former_dist < __chunk_size)\n+                        {\n+                          __fetch_and_add(&__dist, __chunk_size);\n+                          __iam_finished = true;\n+                          break;\n+                        }\n+                      else\n+                        {\n+                          __thread_right =\n+                                  __fetch_and_add(&__right, -__chunk_size);\n+                          __thread_right_border =\n+                                  __thread_right - (__chunk_size - 1);\n+                        }\n \t\t    }\n \n-\t\t  if (__iam_finished)\n-\t\t    break;\n-\n \t\t  // Swap as usual.\n \t\t  while (__thread_left < __thread_right)\n \t\t    {\n@@ -188,21 +195,19 @@ namespace __gnu_parallel\n \n #             pragma omp barrier\n \n-#             pragma omp single\n-\t      {\n-\t\t__leftnew = __left - __leftover_left * __chunk_size;\n-\t\t__rightnew = __right + __leftover_right * __chunk_size;\n-\t      }\n-\n-#             pragma omp barrier\n+              _DifferenceType\n+                    __leftold = __left,\n+                    __leftnew = __left - __leftover_left * __chunk_size,\n+                    __rightold = __right,\n+                    __rightnew = __right + __leftover_right * __chunk_size;\n \n \t      // <=> __thread_left_border + (__chunk_size - 1) >= __leftnew\n \t      if (__thread_left <= __thread_left_border\n \t\t  && __thread_left_border >= __leftnew)\n \t\t{\n \t\t  // Chunk already in place, reserve spot.\n \t\t__reserved_left[(__left - (__thread_left_border + 1))\n-\t\t\t\t/ __chunk_size] = true;\n+\t\t\t\t/ __chunk_size] = 1;\n \t\t}\n \n \t      // <=> __thread_right_border - (__chunk_size - 1) <= __rightnew\n@@ -211,7 +216,7 @@ namespace __gnu_parallel\n \t\t{\n \t\t  // Chunk already in place, reserve spot.\n \t\t  __reserved_right[((__thread_right_border - 1) - __right)\n-\t\t\t\t   / __chunk_size] = true;\n+\t\t\t\t   / __chunk_size] = 1;\n \t\t}\n \n #             pragma omp barrier\n@@ -221,15 +226,13 @@ namespace __gnu_parallel\n \t\t{\n \t\t  // Find spot and swap.\n \t\t  _DifferenceType __swapstart = -1;\n-\t\t  omp_set_lock(&__result_lock);\n-\t\t  for (_DifferenceType __r = 0; __r < __leftover_left; ++__r)\n-\t\t    if (!__reserved_left[__r])\n-\t\t      {\n-\t\t\t__reserved_left[__r] = true;\n-\t\t\t__swapstart = __left - (__r + 1) * __chunk_size;\n-\t\t\tbreak;\n-\t\t      }\n-\t\t  omp_unset_lock(&__result_lock);\n+                  for (int __r = 0; __r < __leftover_left; ++__r)\n+                    if (__reserved_left[__r] == 0\n+                        && __compare_and_swap(&(__reserved_left[__r]), 0, 1))\n+                      {\n+                        __swapstart = __leftold - (__r + 1) * __chunk_size;\n+                        break;\n+                      }\n \n #if _GLIBCXX_ASSERTIONS\n \t\t  _GLIBCXX_PARALLEL_ASSERT(__swapstart != -1);\n@@ -246,15 +249,13 @@ namespace __gnu_parallel\n \t\t{\n \t\t  // Find spot and swap\n \t\t  _DifferenceType __swapstart = -1;\n-\t\t  omp_set_lock(&__result_lock);\n-\t\t  for (_DifferenceType __r = 0; __r < __leftover_right; ++__r)\n-\t\t    if (!__reserved_right[__r])\n-\t\t      {\n-\t\t\t__reserved_right[__r] = true;\n-\t\t\t__swapstart = __right + __r * __chunk_size + 1;\n-\t\t\tbreak;\n-\t\t      }\n-\t\t  omp_unset_lock(&__result_lock);\n+                  for (int __r = 0; __r < __leftover_right; ++__r)\n+                    if (__reserved_right[__r] == 0\n+                        && __compare_and_swap(&(__reserved_right[__r]), 0, 1))\n+                      {\n+                        __swapstart = __rightold + __r * __chunk_size + 1;\n+                        break;\n+                      }\n \n #if _GLIBCXX_ASSERTIONS\n \t\t  _GLIBCXX_PARALLEL_ASSERT(__swapstart != -1);\n@@ -270,18 +271,15 @@ namespace __gnu_parallel\n #             pragma omp single\n \t      {\n \t\tfor (_DifferenceType __r = 0; __r < __leftover_left; ++__r)\n-\t\t  _GLIBCXX_PARALLEL_ASSERT(__reserved_left[__r]);\n+\t\t  _GLIBCXX_PARALLEL_ASSERT(__reserved_left[__r] == 1);\n \t\tfor (_DifferenceType __r = 0; __r < __leftover_right; ++__r)\n-\t\t  _GLIBCXX_PARALLEL_ASSERT(__reserved_right[__r]);\n+\t\t  _GLIBCXX_PARALLEL_ASSERT(__reserved_right[__r] == 1);\n \t      }\n-\n-#             pragma omp barrier\n #endif\n \n-#             pragma omp barrier\n-\n \t      __left = __leftnew;\n \t      __right = __rightnew;\n+              __dist = __right - __left + 1;\n \t    }\n \n #           pragma omp flush(__left, __right)\n@@ -313,8 +311,6 @@ namespace __gnu_parallel\n \tdelete[] __reserved_left;\n \tdelete[] __reserved_right;\n \n-\tomp_destroy_lock(&__result_lock);\n-\n \t// Element \"between\" __final_left and __final_right might not have\n \t// been regarded yet\n \tif (__final_left < __n && !__pred(__begin[__final_left]))"}]}