{"sha": "18c6ada9b2ee27a40db256f4c32779fc25872050", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThjNmFkYTliMmVlMjdhNDBkYjI1NmY0YzMyNzc5ZmMyNTg3MjA1MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-04-01T23:28:15Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-04-01T23:28:15Z"}, "message": "cgraph.c: Add overall comment.\n\n\t* cgraph.c: Add overall comment.\n\t(cgraph_inline_hash): New global variable.\n\t(cgraph_create_node): Break out from ...\n\t(cgraph_node): ... here.\n\t(cgraph_edge): New function.\n\t(cgraph_create_edge): New CALL_EXPR argument; some sanity checking.\n\t(cgraph_remove_edge): Accept edge, intead of source and destination.\n\t(cgraph_redirect_edge_callee): New.\n\t(cgraph_remove_node): Update all new datastructures.\n\t(cgraph_record_call, cgraph_remove_call): Kill.\n\t(dump_cgraph_node): Break out from ... ; dump new datastructures.\n\t(dump_cgraph): ... here.\n\t(cgraph_function_possibly_inlined_p): Use new hashtable.\n\t(cgraph_clone_edge, cgraph_clone_node): New.\n\t* cgraph.h: Include hashtab.h\n\t(struct cgraph_global_info): Kill cloned_times, inline_once, will_be_output\n\tfields, add inlined_to pointer.\n\t(cgraph_node): Add pointer to next_clone.\n\t(cgraph_remove_edge, cgraph_create_edge): Update prototype.\n\t(cgraph_remove_call, cgraph_record_call): Kill.\n\t(cgraph_inline_hash): Declare.\n\t(dump_cgraph_node, cgraph_edge, cg4raph_clone_edge, cgraph_clone_node,\n\tcgraph_redirect_edge_callee): Declare.\n\t(cgraph_create_edges, cgraph_inline_p): Update prorotype.\n\t(cgraph_preserve_function_body_p, verify_cgraph, verify_cgraph_node,\n\tcgraph_mark_inline_edge, cgraph_clone_inlined_nodes): Declare.\n\t* cgraphunit.c: Add overall comment.\n\t(cgraph_optimize_function): Kill.\n\t(cgraph_assemble_pending_functions): Do not assemble inline clones.\n\t(cgraph_finalize_function): Update call of cgraph_remove_node\n\t(record_call_1): Record call sites.\n\t(cgraph_create_edges): Accept node instead of decl argument.\n\t(error_found): New static variable.\n\t(verify_cgraph_node_1, verify_cgraph_node, verify_cgraph): New functions.\n\t(cgraph_analyze_function): Update for new datastructures.\n\t(cgraph_finalize_compilation_unit): Plug memory leak.\n\t(cgraph_optimize_function): Kill.\n\t(cgraph_expand_function): Do not use cgraph_optimize_function.\n\t(INLINED_TIMES, SET_INLINED_TIMES, cgraph_inlined_into,\n\tcgraph_inlined_callees): Kill.\n\t(cgraph_remove_unreachable_nodes): Verify cgraph; update handling of\n\tclones.\n\t(estimate_growth): Simplify.\n\t(cgraph_clone_inlined_nodes): New function.\n\t(cgraph_mark_inline_edge): Re-implement.\n\t(cgraph_mark_inline): Likewise.\n\t(cgraph_check_inline_limits): Simplify.\n\t(cgraph_recursive_inlining_p): New.\n\t(update_callee_keys): Break out from ...\n\t(cgraph_decide_inlining_of_small_functions): ... here; simplify.\n\t(cgraph_decide_inlining, cgraph_decide_inlining_incrementally):\n\tLikewise.\n\t(cgraph_expand_all_functions):  Remove inline clones from the ordered\n\tlist.\n\t(cgraph_preserve_function_body_p): New predicate.\n\t(cgraph_optimize): Verify cgraph.\n\t* function.h (struct function): Add fields saved_tree/saved_args.\n\t* timevar.def (TV_CGRAPH_VERIFY): Use verifier.\n\t* toplev.c (rest_of_compilation): Do not free cfun.\n\t* tree-inline.c: Include function.h\n\t(struct inline_data): Add saving_p field; replace decl/current_decl by\n\tnode/current_node.\n\t(insert_decl_map): New function.\n\t(copy_body_r): Handle saving; update cgraph datastructure.\n\t(copy_body): Handle recursive inlining.\n\t(initialize_inlined_parameters): Likewise.\n\t(expand_call_inline): Propagate node attributes; update cgraph.\n\t(optimize_inline_calls): Verify that datastructure still match.\n\t(save_body): New function.\n\t* tree-inline.h (save_body): New.\n\t* tree-optimize.c (tree_rest_of_compilation): preserve function body; do inlining.\n\t* langhooks-def.c (LANG_HOOKS_UPDATE_DECL_AFTER_SAVING): New.\n\t* langhooks.c (lang_hooks): Add update_decl_after_saving.\n\n\t* cp-lang. (LANG_HOOKS_UPDATE_DECL_AFTER_SAVING): Define.\n\t* cp-tree.h (cp_update_decl_after_saving): Declare.\n\t* tree.c (cp_update_decl_after_saving): Define.\n\n\t* Make-lang.in (com.o): Add dependnecy on function.h\n\t* com.c: Include function.h\n\t(finish_function): Clear DECL_STRUCT_FUNCTION.\n\n\t* utils.c: Include function.h\n\t(end_subprog_body): Clear DECL_STRUCT_FUNCTION.\n\nFrom-SVN: r80334", "tree": {"sha": "77aa1595ee2a84a8ea2004429140d1fb8bcc2796", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77aa1595ee2a84a8ea2004429140d1fb8bcc2796"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18c6ada9b2ee27a40db256f4c32779fc25872050", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18c6ada9b2ee27a40db256f4c32779fc25872050", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18c6ada9b2ee27a40db256f4c32779fc25872050", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18c6ada9b2ee27a40db256f4c32779fc25872050/comments", "author": null, "committer": null, "parents": [{"sha": "e86327772eaa1f4b2c352a411afa195b30ff0c8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e86327772eaa1f4b2c352a411afa195b30ff0c8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e86327772eaa1f4b2c352a411afa195b30ff0c8f"}], "stats": {"total": 2002, "additions": 1281, "deletions": 721}, "files": [{"sha": "a7493145a38b4e1103f49bd6524290d52bd1911d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18c6ada9b2ee27a40db256f4c32779fc25872050", "patch": "@@ -1,3 +1,79 @@\n+2004-04-02  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c: Add overall comment.\n+\t(cgraph_inline_hash): New global variable.\n+\t(cgraph_create_node): Break out from ...\n+\t(cgraph_node): ... here.\n+\t(cgraph_edge): New function.\n+\t(cgraph_create_edge): New CALL_EXPR argument; some sanity checking.\n+\t(cgraph_remove_edge): Accept edge, intead of source and destination.\n+\t(cgraph_redirect_edge_callee): New.\n+\t(cgraph_remove_node): Update all new datastructures.\n+\t(cgraph_record_call, cgraph_remove_call): Kill.\n+\t(dump_cgraph_node): Break out from ... ; dump new datastructures.\n+\t(dump_cgraph): ... here.\n+\t(cgraph_function_possibly_inlined_p): Use new hashtable.\n+\t(cgraph_clone_edge, cgraph_clone_node): New.\n+\t* cgraph.h: Include hashtab.h\n+\t(struct cgraph_global_info): Kill cloned_times, inline_once, will_be_output\n+\tfields, add inlined_to pointer.\n+\t(cgraph_node): Add pointer to next_clone.\n+\t(cgraph_remove_edge, cgraph_create_edge): Update prototype.\n+\t(cgraph_remove_call, cgraph_record_call): Kill.\n+\t(cgraph_inline_hash): Declare.\n+\t(dump_cgraph_node, cgraph_edge, cg4raph_clone_edge, cgraph_clone_node,\n+\tcgraph_redirect_edge_callee): Declare.\n+\t(cgraph_create_edges, cgraph_inline_p): Update prorotype.\n+\t(cgraph_preserve_function_body_p, verify_cgraph, verify_cgraph_node,\n+\tcgraph_mark_inline_edge, cgraph_clone_inlined_nodes): Declare.\n+\t* cgraphunit.c: Add overall comment.\n+\t(cgraph_optimize_function): Kill.\n+\t(cgraph_assemble_pending_functions): Do not assemble inline clones.\n+\t(cgraph_finalize_function): Update call of cgraph_remove_node\n+\t(record_call_1): Record call sites.\n+\t(cgraph_create_edges): Accept node instead of decl argument.\n+\t(error_found): New static variable.\n+\t(verify_cgraph_node_1, verify_cgraph_node, verify_cgraph): New functions.\n+\t(cgraph_analyze_function): Update for new datastructures.\n+\t(cgraph_finalize_compilation_unit): Plug memory leak.\n+\t(cgraph_optimize_function): Kill.\n+\t(cgraph_expand_function): Do not use cgraph_optimize_function.\n+\t(INLINED_TIMES, SET_INLINED_TIMES, cgraph_inlined_into,\n+\tcgraph_inlined_callees): Kill.\n+\t(cgraph_remove_unreachable_nodes): Verify cgraph; update handling of\n+\tclones.\n+\t(estimate_growth): Simplify.\n+\t(cgraph_clone_inlined_nodes): New function.\n+\t(cgraph_mark_inline_edge): Re-implement.\n+\t(cgraph_mark_inline): Likewise.\n+\t(cgraph_check_inline_limits): Simplify.\n+\t(cgraph_recursive_inlining_p): New.\n+\t(update_callee_keys): Break out from ...\n+\t(cgraph_decide_inlining_of_small_functions): ... here; simplify.\n+\t(cgraph_decide_inlining, cgraph_decide_inlining_incrementally):\n+\tLikewise.\n+\t(cgraph_expand_all_functions):  Remove inline clones from the ordered\n+\tlist.\n+\t(cgraph_preserve_function_body_p): New predicate.\n+\t(cgraph_optimize): Verify cgraph.\n+\t* function.h (struct function): Add fields saved_tree/saved_args.\n+\t* timevar.def (TV_CGRAPH_VERIFY): Use verifier.\n+\t* toplev.c (rest_of_compilation): Do not free cfun.\n+\t* tree-inline.c: Include function.h\n+\t(struct inline_data): Add saving_p field; replace decl/current_decl by\n+\tnode/current_node.\n+\t(insert_decl_map): New function.\n+\t(copy_body_r): Handle saving; update cgraph datastructure.\n+\t(copy_body): Handle recursive inlining.\n+\t(initialize_inlined_parameters): Likewise.\n+\t(expand_call_inline): Propagate node attributes; update cgraph.\n+\t(optimize_inline_calls): Verify that datastructure still match.\n+\t(save_body): New function.\n+\t* tree-inline.h (save_body): New.\n+\t* tree-optimize.c (tree_rest_of_compilation): preserve function body; do inlining.\n+\t* langhooks-def.c (LANG_HOOKS_UPDATE_DECL_AFTER_SAVING): New.\n+\t* langhooks.c (lang_hooks): Add update_decl_after_saving.\n+\n 2004-04-01  Serge Belyshev  <1319@bot.ru>\n \n         PR target/14702"}, {"sha": "74f2c357bbe1927033960d788b7c145527ac6ed7", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=18c6ada9b2ee27a40db256f4c32779fc25872050", "patch": "@@ -1510,7 +1510,7 @@ tree-dump.o: tree-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n tree-inline.o : tree-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(RTL_H) $(EXPR_H) flags.h $(PARAMS_H) input.h insn-config.h \\\n    $(INTEGRATE_H) $(VARRAY_H) $(HASHTAB_H) $(SPLAY_TREE_H) toplev.h \\\n-   langhooks.h $(C_COMMON_H) tree-inline.h cgraph.h intl.h\n+   langhooks.h $(C_COMMON_H) tree-inline.h cgraph.h intl.h function.h\n tree-optimize.o : tree-optimize.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) toplev.h langhooks.h cgraph.h $(TIMEVAR_H) function.h $(GGC_H)\n "}, {"sha": "455ed09b1964646eb506bda6ee86fa7fb924c639", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=18c6ada9b2ee27a40db256f4c32779fc25872050", "patch": "@@ -1,3 +1,8 @@\n+2004-04-02  Jan Hubicka  <jh@suse.cz>\n+\n+\t* utils.c: Include function.h\n+\t(end_subprog_body): Clear DECL_STRUCT_FUNCTION.\n+\n 2004-04-01  Arnaud Charlet  <charlet@act-europe.fr>\n \n \tPR ada/14150"}, {"sha": "0fe1892b272abe11f90acfdb25e921b08adf141c", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=18c6ada9b2ee27a40db256f4c32779fc25872050", "patch": "@@ -37,6 +37,7 @@\n #include \"debug.h\"\n #include \"convert.h\"\n #include \"target.h\"\n+#include \"function.h\"\n \n #include \"ada.h\"\n #include \"types.h\"\n@@ -1920,7 +1921,15 @@ end_subprog_body (void)\n   /* If we're only annotating types, don't actually compile this\n      function.  */\n   if (!type_annotate_only)\n-    rest_of_compilation (current_function_decl);\n+    {\n+      rest_of_compilation (current_function_decl);\n+      if (! DECL_DEFER_OUTPUT (current_function_decl))\n+\t{\n+\t  free_after_compilation (cfun);\n+\t  DECL_STRUCT_FUNCTION (current_function_decl) = 0;\n+\t}\n+      cfun = 0;\n+    }\n \n   if (function_nesting_depth > 1)\n     ggc_pop_context ();"}, {"sha": "04049df6bf57a82a52e4c29c277b6bfc70152f50", "filename": "gcc/cgraph.c", "status": "modified", "additions": 281, "deletions": 95, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=18c6ada9b2ee27a40db256f4c32779fc25872050", "patch": "@@ -19,6 +19,66 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n+/*  This file contains basic routines manipulating call graph and variable pool\n+  \n+The callgraph:\n+\n+    The call-graph is data structure designed for intra-procedural optimization\n+    but it is also used in non-unit-at-a-time compilation to allow easier code\n+    sharing.\n+\n+    The call-graph consist of nodes and edges represented via linked lists.\n+    Each function (external or not) corresponds to the unique node (in\n+    contrast to tree DECL nodes where we can have multiple nodes for each\n+    function).\n+\n+    The mapping from declarations to call-graph nodes is done using hash table\n+    based on DECL_ASSEMBLER_NAME, so it is essential for assembler name to\n+    not change once the declaration is inserted into the call-graph.\n+    The call-graph nodes are created lazily using cgraph_node function when\n+    called for unknown declaration.\n+    \n+    When built, there is one edge for each direct call.  It is possible that\n+    the reference will be later optimized out.  The call-graph is built\n+    conservatively in order to make conservative data flow analysis possible.\n+\n+    The callgraph at the moment does not represent indirect calls or calls\n+    from other compilation unit.  Flag NEEDED is set for each node that may\n+    be accessed in such a invisible way and it shall be considered an\n+    entry point to the callgraph.\n+\n+    Intraprocedural information:\n+\n+      Callgraph is place to store data needed for intraprocedural optimization.\n+      All datastructures are divided into three components: local_info that\n+      is produced while analyzing the function, global_info that is result\n+      of global walkking of the callgraph on the end of compilation and\n+      rtl_info used by RTL backend to propagate data from already compiled\n+      functions to their callers.\n+\n+    Inlining plans:\n+\n+      The function inlining information is decided in advance and maintained\n+      in the callgraph as so called inline plan.\n+      For each inlined call, the calle's node is clonned to represent the\n+      new function copy produced by inlininer.\n+      Each inlined call gets unque corresponding clone node of the callee\n+      and the datastructure is updated while inlining is performed, so\n+      the clones are elliminated and their callee edges redirected to the\n+      caller. \n+\n+      Each edge has \"inline_failed\" field.  When the field is set to NULL,\n+      the call will be inlined.  When it is non-NULL it contains an reason\n+      why inlining wasn't performaned.\n+\n+\n+The varpool data structure:\n+\n+    Varpool is used to maintain variables in similar manner as call-graph\n+    is used for functions.  Most of the API is symmetric replacing cgraph\n+    function prefix by cgraph_varpool  */\n+\n+\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -36,10 +96,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"output.h\"\n #include \"intl.h\"\n \n-\n /* Hash table used to convert declarations into nodes.  */\n static GTY((param_is (struct cgraph_node))) htab_t cgraph_hash;\n \n+/* We destructivly update callgraph during inlining and thus we need to\n+   keep information on whether inlining happent separately.  */\n+htab_t cgraph_inline_hash;\n+\n /* The linked list of cgraph nodes.  */\n struct cgraph_node *cgraph_nodes;\n \n@@ -67,8 +130,6 @@ int cgraph_varpool_n_nodes;\n /* The linked list of cgraph varpool nodes.  */\n static GTY(())  struct cgraph_varpool_node *cgraph_varpool_nodes;\n \n-static struct cgraph_edge *create_edge (struct cgraph_node *,\n-\t\t\t\t\tstruct cgraph_node *);\n static hashval_t hash_node (const void *);\n static int eq_node (const void *, const void *);\n \n@@ -91,6 +152,23 @@ eq_node (const void *p1, const void *p2)\n \t  (tree) p2);\n }\n \n+/* Allocate new callgraph node and insert it into basic datastructures.  */\n+static struct cgraph_node *\n+cgraph_create_node (void)\n+{\n+  struct cgraph_node *node;\n+\n+  node = ggc_alloc_cleared (sizeof (*node));\n+  node->next = cgraph_nodes;\n+  node->uid = cgraph_max_uid++;\n+  if (cgraph_nodes)\n+    cgraph_nodes->previous = node;\n+  node->previous = NULL;\n+  cgraph_nodes = node;\n+  cgraph_n_nodes++;\n+  return node;\n+}\n+\n /* Return cgraph node assigned to DECL.  Create new one when needed.  */\n struct cgraph_node *\n cgraph_node (tree decl)\n@@ -110,15 +188,9 @@ cgraph_node (tree decl)\n \t\t\t        (DECL_ASSEMBLER_NAME (decl)), INSERT);\n   if (*slot)\n     return *slot;\n-  node = ggc_alloc_cleared (sizeof (*node));\n+\n+  node = cgraph_create_node ();\n   node->decl = decl;\n-  node->next = cgraph_nodes;\n-  node->uid = cgraph_max_uid++;\n-  if (cgraph_nodes)\n-    cgraph_nodes->previous = node;\n-  node->previous = NULL;\n-  cgraph_nodes = node;\n-  cgraph_n_nodes++;\n   *slot = node;\n   if (DECL_CONTEXT (decl) && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL)\n     {\n@@ -129,6 +201,23 @@ cgraph_node (tree decl)\n   return node;\n }\n \n+/* Return callgraph edge representing CALL_EXPR.  */\n+struct cgraph_edge *\n+cgraph_edge (struct cgraph_node *node, tree call_expr)\n+{\n+  struct cgraph_edge *e;\n+\n+  /* This loop may turn out to be performance problem.  In such case adding\n+     hashtables into call nodes with very many edges is probably best\n+     sollution.  It is not good idea to add pointer into CALL_EXPR itself\n+     because we want to make possible having multiple cgraph nodes representing\n+     different clones of the same body before the body is actually cloned.  */\n+  for (e = node->callees; e; e= e->next_callee)\n+    if (e->call_expr == call_expr)\n+      break;\n+  return e;\n+}\n+\n /* Try to find existing function for identifier ID.  */\n struct cgraph_node *\n cgraph_node_for_identifier (tree id)\n@@ -151,11 +240,21 @@ cgraph_node_for_identifier (tree id)\n \n /* Create edge from CALLER to CALLEE in the cgraph.  */\n \n-static struct cgraph_edge *\n-create_edge (struct cgraph_node *caller, struct cgraph_node *callee)\n+struct cgraph_edge *\n+cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n+\t\t    tree call_expr)\n {\n   struct cgraph_edge *edge = ggc_alloc (sizeof (struct cgraph_edge));\n-  struct cgraph_edge *edge2;\n+#ifdef ENABLE_CHECKING\n+  struct cgraph_edge *e;\n+\n+  for (e = caller->callees; e; e = e->next_callee)\n+    if (e->call_expr == call_expr)\n+      abort ();\n+#endif\n+\n+  if (TREE_CODE (call_expr) != CALL_EXPR)\n+    abort ();\n \n   if (!DECL_SAVED_TREE (callee->decl))\n     edge->inline_failed = N_(\"function body not available\");\n@@ -167,57 +266,70 @@ create_edge (struct cgraph_node *caller, struct cgraph_node *callee)\n   else\n     edge->inline_failed = N_(\"function not inlinable\");\n \n-  /* At the moment we don't associate calls with specific CALL_EXPRs\n-     as we probably ought to, so we must preserve inline_call flags to\n-     be the same in all copies of the same edge.  */\n-  if (cgraph_global_info_ready)\n-    for (edge2 = caller->callees; edge2; edge2 = edge2->next_callee)\n-      if (edge2->callee == callee)\n-\t{\n-\t  edge->inline_failed = edge2->inline_failed;\n-\t  break;\n-\t}\n+  edge->aux = NULL;\n \n   edge->caller = caller;\n   edge->callee = callee;\n+  edge->call_expr = call_expr;\n   edge->next_caller = callee->callers;\n   edge->next_callee = caller->callees;\n   caller->callees = edge;\n   callee->callers = edge;\n   return edge;\n }\n \n-/* Remove the edge from CALLER to CALLEE in the cgraph.  */\n+/* Remove the edge E the cgraph.  */\n \n void\n-cgraph_remove_edge (struct cgraph_node *caller, struct cgraph_node *callee)\n+cgraph_remove_edge (struct cgraph_edge *e)\n {\n   struct cgraph_edge **edge, **edge2;\n \n-  for (edge = &callee->callers; *edge && (*edge)->caller != caller;\n+  for (edge = &e->callee->callers; *edge && *edge != e;\n        edge = &((*edge)->next_caller))\n     continue;\n   if (!*edge)\n     abort ();\n   *edge = (*edge)->next_caller;\n-  for (edge2 = &caller->callees; *edge2 && (*edge2)->callee != callee;\n+  for (edge2 = &e->caller->callees; *edge2 && *edge2 != e;\n        edge2 = &(*edge2)->next_callee)\n     continue;\n   if (!*edge2)\n     abort ();\n   *edge2 = (*edge2)->next_callee;\n }\n \n+/* Redirect callee of E to N.  The function does not update underlying\n+   call expression.  */\n+\n+void\n+cgraph_redirect_edge_callee (struct cgraph_edge *e, struct cgraph_node *n)\n+{\n+  struct cgraph_edge **edge;\n+\n+  for (edge = &e->callee->callers; *edge && *edge != e;\n+       edge = &((*edge)->next_caller))\n+    continue;\n+  if (!*edge)\n+    abort ();\n+  *edge = (*edge)->next_caller;\n+  e->callee = n;\n+  e->next_caller = n->callers;\n+  n->callers = e;\n+}\n+\n /* Remove the node from cgraph.  */\n \n void\n cgraph_remove_node (struct cgraph_node *node)\n {\n   void **slot;\n+  bool check_dead = 1;\n+\n   while (node->callers)\n-    cgraph_remove_edge (node->callers->caller, node);\n+    cgraph_remove_edge (node->callers);\n   while (node->callees)\n-    cgraph_remove_edge (node, node->callees->callee);\n+    cgraph_remove_edge (node->callees);\n   while (node->nested)\n     cgraph_remove_node (node->nested);\n   if (node->origin)\n@@ -234,15 +346,52 @@ cgraph_remove_node (struct cgraph_node *node)\n     cgraph_nodes = node->next;\n   if (node->next)\n     node->next->previous = node->previous;\n-  DECL_SAVED_TREE (node->decl) = NULL;\n-  DECL_STRUCT_FUNCTION (node->decl) = NULL;\n-  DECL_ARGUMENTS (node->decl) = NULL;\n-  DECL_INITIAL (node->decl) = error_mark_node;\n   slot = \n     htab_find_slot_with_hash (cgraph_hash, DECL_ASSEMBLER_NAME (node->decl),\n \t\t\t      IDENTIFIER_HASH_VALUE (DECL_ASSEMBLER_NAME\n \t\t\t\t\t\t     (node->decl)), NO_INSERT);\n-  htab_clear_slot (cgraph_hash, slot);\n+  if (*slot == node)\n+    {\n+      if (node->next_clone)\n+\t*slot = node->next_clone;\n+      else\n+\t{\n+          htab_clear_slot (cgraph_hash, slot);\n+\t  if (!dump_enabled_p (TDI_all))\n+\t    {\n+              DECL_SAVED_TREE (node->decl) = NULL;\n+\t      DECL_STRUCT_FUNCTION (node->decl) = NULL;\n+\t    }\n+\t  check_dead = false;\n+\t}\n+    }\n+  else\n+    {\n+      struct cgraph_node *n;\n+\n+      for (n = *slot; n->next_clone != node; n = n->next_clone)\n+\tcontinue;\n+      n->next_clone = node->next_clone;\n+    }\n+\n+  /* Work out whether we still need a function body (either there is inline\n+     clone or there is out of line function whose body is not written).  */\n+  if (check_dead && flag_unit_at_a_time)\n+    {\n+      struct cgraph_node *n;\n+\n+      for (n = *slot; n; n = n->next_clone)\n+\tif (n->global.inlined_to\n+\t    || (!n->global.inlined_to\n+\t\t&& !TREE_ASM_WRITTEN (n->decl) && !DECL_EXTERNAL (n->decl)))\n+\t  break;\n+      if (!n && !dump_enabled_p (TDI_all))\n+\t{\n+\t  DECL_SAVED_TREE (node->decl) = NULL;\n+\t  DECL_STRUCT_FUNCTION (node->decl) = NULL;\n+\t}\n+    }\n+  cgraph_n_nodes--;\n   /* Do not free the structure itself so the walk over chain can continue.  */\n }\n \n@@ -281,20 +430,6 @@ cgraph_mark_needed_node (struct cgraph_node *node)\n   cgraph_mark_reachable_node (node);\n }\n \n-/* Record call from CALLER to CALLEE.  */\n-\n-struct cgraph_edge *\n-cgraph_record_call (tree caller, tree callee)\n-{\n-  return create_edge (cgraph_node (caller), cgraph_node (callee));\n-}\n-\n-void\n-cgraph_remove_call (tree caller, tree callee)\n-{\n-  cgraph_remove_edge (cgraph_node (caller), cgraph_node (callee));\n-}\n-\n /* Return true when CALLER_DECL calls CALLEE_DECL.  */\n \n bool\n@@ -356,6 +491,60 @@ cgraph_node_name (struct cgraph_node *node)\n   return lang_hooks.decl_printable_name (node->decl, 2);\n }\n \n+/* Dump given cgraph node.  */\n+void\n+dump_cgraph_node (FILE *f, struct cgraph_node *node)\n+{\n+  struct cgraph_edge *edge;\n+  fprintf (f, \"%s/%i:\", cgraph_node_name (node), node->uid);\n+  if (node->global.inlined_to)\n+    fprintf (f, \" (inline copy in %s/%i)\",\n+\t     cgraph_node_name (node->global.inlined_to),\n+\t     node->global.inlined_to->uid);\n+  if (node->local.self_insns)\n+    fprintf (f, \" %i insns\", node->local.self_insns);\n+  if (node->global.insns && node->global.insns != node->local.self_insns)\n+    fprintf (f, \" (%i after inlining)\", node->global.insns);\n+  if (node->origin)\n+    fprintf (f, \" nested in: %s\", cgraph_node_name (node->origin));\n+  if (node->needed)\n+    fprintf (f, \" needed\");\n+  else if (node->reachable)\n+    fprintf (f, \" reachable\");\n+  if (DECL_SAVED_TREE (node->decl))\n+    fprintf (f, \" tree\");\n+  if (node->output)\n+    fprintf (f, \" output\");\n+\n+  if (node->local.local)\n+    fprintf (f, \" local\");\n+  if (node->local.disregard_inline_limits)\n+    fprintf (f, \" always_inline\");\n+  else if (node->local.inlinable)\n+    fprintf (f, \" inlinable\");\n+  if (TREE_ASM_WRITTEN (node->decl))\n+    fprintf (f, \" asm_written\");\n+\n+  fprintf (f, \"\\n  called by: \");\n+  for (edge = node->callers; edge; edge = edge->next_caller)\n+    {\n+      fprintf (f, \"%s/%i \", cgraph_node_name (edge->caller),\n+\t       edge->caller->uid);\n+      if (!edge->inline_failed)\n+\tfprintf(f, \"(inlined) \");\n+    }\n+\n+  fprintf (f, \"\\n  calls: \");\n+  for (edge = node->callees; edge; edge = edge->next_callee)\n+    {\n+      fprintf (f, \"%s/%i \", cgraph_node_name (edge->callee),\n+\t       edge->callee->uid);\n+      if (!edge->inline_failed)\n+\tfprintf(f, \"(inlined) \");\n+    }\n+  fprintf (f, \"\\n\");\n+}\n+\n /* Dump the callgraph.  */\n \n void\n@@ -365,48 +554,7 @@ dump_cgraph (FILE *f)\n \n   fprintf (f, \"callgraph:\\n\\n\");\n   for (node = cgraph_nodes; node; node = node->next)\n-    {\n-      struct cgraph_edge *edge;\n-      fprintf (f, \"%s:\", cgraph_node_name (node));\n-      if (node->local.self_insns)\n-        fprintf (f, \" %i insns\", node->local.self_insns);\n-      if (node->global.insns && node->global.insns != node->local.self_insns)\n-\tfprintf (f, \" (%i after inlining)\", node->global.insns);\n-      if (node->origin)\n-\tfprintf (f, \" nested in: %s\", cgraph_node_name (node->origin));\n-      if (node->needed)\n-\tfprintf (f, \" needed\");\n-      else if (node->reachable)\n-\tfprintf (f, \" reachable\");\n-      if (DECL_SAVED_TREE (node->decl))\n-\tfprintf (f, \" tree\");\n-\n-      if (node->local.local)\n-\tfprintf (f, \" local\");\n-      if (node->local.disregard_inline_limits)\n-\tfprintf (f, \" always_inline\");\n-      else if (node->local.inlinable)\n-\tfprintf (f, \" inlinable\");\n-      if (node->global.cloned_times > 1)\n-\tfprintf (f, \" cloned %ix\", node->global.cloned_times);\n-\n-      fprintf (f, \"\\n  called by: \");\n-      for (edge = node->callers; edge; edge = edge->next_caller)\n-\t{\n-\t  fprintf (f, \"%s \", cgraph_node_name (edge->caller));\n-\t  if (!edge->inline_failed)\n-\t    fprintf(f, \"(inlined) \");\n-\t}\n-\n-      fprintf (f, \"\\n  calls: \");\n-      for (edge = node->callees; edge; edge = edge->next_callee)\n-\t{\n-\t  fprintf (f, \"%s \", cgraph_node_name (edge->callee));\n-\t  if (!edge->inline_failed)\n-\t    fprintf(f, \"(inlined) \");\n-\t}\n-      fprintf (f, \"\\n\");\n-    }\n+    dump_cgraph_node (f, node);\n }\n \n /* Returns a hash code for P.  */\n@@ -626,10 +774,48 @@ bool\n cgraph_function_possibly_inlined_p (tree decl)\n {\n   if (!cgraph_global_info_ready)\n-    return (DECL_INLINE (decl)\n-\t    && (!flag_really_no_inline\n-\t\t|| lang_hooks.tree_inlining.disregard_inline_limits (decl)));\n-  return cgraph_node (decl)->global.inlined;\n+    return (DECL_INLINE (decl) && !flag_really_no_inline);\n+  if (!cgraph_inline_hash)\n+    return false;\n+  return (htab_find_slot (cgraph_inline_hash, DECL_ASSEMBLER_NAME (decl),\n+\t\t\t  NO_INSERT) != NULL);\n+}\n+\n+/* Create clone of E in the node N represented by CALL_EXPR the callgraph.  */\n+struct cgraph_edge *\n+cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n, tree call_expr)\n+{\n+  struct cgraph_edge *new = cgraph_create_edge (n, e->callee, call_expr);\n+\n+  new->inline_failed = e->inline_failed;\n+  return new;\n }\n \n+/* Create node representing clone of N.  */\n+struct cgraph_node *\n+cgraph_clone_node (struct cgraph_node *n)\n+{\n+  struct cgraph_node *new = cgraph_create_node ();\n+  struct cgraph_edge *e;\n+\n+  new->decl = n->decl;\n+  new->origin = n->origin;\n+  if (new->origin)\n+    {\n+      new->next_nested = new->origin->nested;\n+      new->origin->nested = new;\n+    }\n+  new->analyzed = n->analyzed;\n+  new->local = n->local;\n+  new->global = n->global;\n+  new->rtl = n->rtl;\n+\n+  for (e = n->callees;e; e=e->next_callee)\n+    cgraph_clone_edge (e, new, e->call_expr);\n+\n+  new->next_clone = n->next_clone;\n+  n->next_clone = new;\n+\n+  return new;\n+}\n #include \"gt-cgraph.h\""}, {"sha": "617861be1ce5dce2ab058bfb5c0e04d12d4d3e9b", "filename": "gcc/cgraph.h", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=18c6ada9b2ee27a40db256f4c32779fc25872050", "patch": "@@ -21,6 +21,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #ifndef GCC_CGRAPH_H\n #define GCC_CGRAPH_H\n+#include \"hashtab.h\"\n \n /* Information about the function collected locally.\n    Available after function is analyzed.  */\n@@ -50,21 +51,13 @@ struct cgraph_local_info GTY(())\n \n struct cgraph_global_info GTY(())\n {\n+  /* For inline clones this points to the function they will be inlined into.  */\n+  struct cgraph_node *inlined_to;\n+\n   /* Estimated size of the function after inlining.  */\n   int insns;\n \n-  /* Number of times given function will be cloned during output.  */\n-  int cloned_times;\n-\n-  /* Set when the function will be inlined exactly once.  */\n-  bool inline_once;\n-\n-  /* Set to true for all reachable functions before inlining is decided.\n-     Once we inline all calls to the function and the function is local,\n-     it is set to false.  */\n-  bool will_be_output;\n-\n-  /* Set iff at least one of the caller edges has inline_call flag set.  */\n+  /* Set iff the function has been inlined at least once.  */\n   bool inlined;\n };\n \n@@ -97,6 +90,8 @@ struct cgraph_node GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\")))\n   struct cgraph_node *next_nested;\n   /* Pointer to the next function in cgraph_nodes_queue.  */\n   struct cgraph_node *next_needed;\n+  /* Pointer to the next clone.  */\n+  struct cgraph_node *next_clone;\n   PTR GTY ((skip)) aux;\n \n   struct cgraph_local_info local;\n@@ -117,12 +112,14 @@ struct cgraph_node GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\")))\n   bool output;\n };\n \n-struct cgraph_edge GTY(())\n+struct cgraph_edge GTY((chain_next (\"%h.next_caller\")))\n {\n   struct cgraph_node *caller;\n   struct cgraph_node *callee;\n   struct cgraph_edge *next_caller;\n   struct cgraph_edge *next_callee;\n+  tree call_expr;\n+  PTR GTY ((skip (\"\"))) aux;\n   /* When NULL, inline this call.  When non-NULL, points to the explanation\n      why function was not inlined.  */\n   const char *inline_failed;\n@@ -155,38 +152,50 @@ extern FILE *cgraph_dump_file;\n \n extern GTY(()) int cgraph_varpool_n_nodes;\n extern GTY(()) struct cgraph_varpool_node *cgraph_varpool_nodes_queue;\n+extern GTY((param_is (union tree_node))) htab_t cgraph_inline_hash;\n \n \n /* In cgraph.c  */\n void dump_cgraph (FILE *);\n-void cgraph_remove_edge (struct cgraph_node *, struct cgraph_node *);\n-void cgraph_remove_call (tree, tree);\n+void dump_cgraph_node (FILE *, struct cgraph_node *);\n+void cgraph_remove_edge (struct cgraph_edge *);\n void cgraph_remove_node (struct cgraph_node *);\n-struct cgraph_edge *cgraph_record_call (tree, tree);\n+struct cgraph_edge *cgraph_create_edge (struct cgraph_node *,\n+\t\t\t\t\tstruct cgraph_node *,\n+\t\t\t\t        tree);\n struct cgraph_node *cgraph_node (tree decl);\n+struct cgraph_edge *cgraph_edge (struct cgraph_node *, tree call_expr);\n struct cgraph_node *cgraph_node_for_identifier (tree id);\n bool cgraph_calls_p (tree, tree);\n struct cgraph_local_info *cgraph_local_info (tree);\n struct cgraph_global_info *cgraph_global_info (tree);\n struct cgraph_rtl_info *cgraph_rtl_info (tree);\n const char * cgraph_node_name (struct cgraph_node *);\n+struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *, struct cgraph_node *, tree);\n+struct cgraph_node * cgraph_clone_node (struct cgraph_node *);\n \n struct cgraph_varpool_node *cgraph_varpool_node (tree decl);\n struct cgraph_varpool_node *cgraph_varpool_node_for_identifier (tree id);\n void cgraph_varpool_mark_needed_node (struct cgraph_varpool_node *);\n void cgraph_varpool_finalize_decl (tree);\n bool cgraph_varpool_assemble_pending_decls (void);\n+void cgraph_redirect_edge_callee (struct cgraph_edge *, struct cgraph_node *);\n \n bool cgraph_function_possibly_inlined_p (tree);\n \n /* In cgraphunit.c  */\n bool cgraph_assemble_pending_functions (void);\n void cgraph_finalize_function (tree, bool);\n void cgraph_finalize_compilation_unit (void);\n-void cgraph_create_edges (tree, tree);\n+void cgraph_create_edges (struct cgraph_node *, tree);\n void cgraph_optimize (void);\n void cgraph_mark_needed_node (struct cgraph_node *);\n void cgraph_mark_reachable_node (struct cgraph_node *);\n-bool cgraph_inline_p (tree, tree, const char **reason);\n+bool cgraph_inline_p (struct cgraph_edge *, const char **reason);\n+bool cgraph_preserve_function_body_p (tree);\n+void verify_cgraph (void);\n+void verify_cgraph_node (struct cgraph_node *);\n+void cgraph_mark_inline_edge (struct cgraph_edge *e);\n+void cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate);\n \n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "7495a7595e5d55515826383120acab0ac387eee2", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 624, "deletions": 560, "changes": 1184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=18c6ada9b2ee27a40db256f4c32779fc25872050", "patch": "@@ -19,6 +19,150 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n+/* This module implements main driver of compilation process as well as\n+   few basic intraprocedural optimizers.\n+\n+   The main scope of this file is to act as an interface in between\n+   tree based frontends and the backend (and middle end)\n+\n+   The front-end is supposed to use following functionality:\n+\n+    - cgraph_finalize_function\n+\n+      This function is called once front-end has parsed whole body of function\n+      and it is certain that the function body nor the declaration will change.\n+\n+      (There is one exception needed for implementing GCC extern inline function.)\n+\n+    - cgraph_varpool_finalize_variable\n+\n+      This function has same behaviour as the above but is used for static\n+      variables.\n+\n+    - cgraph_finalize_compilation_unit\n+\n+      This function is called once compilation unit is finalized and it will\n+      no longer change.\n+\n+      In the unit-at-a-time the call-graph construction and local function\n+      analysis takes place here.  Bodies of unreachable functions are released\n+      to conserve memory usage.\n+\n+      ???  The compilation unit in this point of view should be compilation\n+      unit as defined by the language - for instance C frontend allows multiple\n+      compilation units to be parsed at once and it should call function each\n+      time parsing is done so we save memory.\n+\n+    - cgraph_optimize\n+\n+      In this unit-at-a-time compilation the intra procedural analysis takes\n+      place here.  In particular the static functions whose address is never\n+      taken are marked as local.  Backend can then use this information to\n+      modify calling conventions, do better inlining or similar optimizations.\n+\n+    - cgraph_assemble_pending_functions\n+    - cgraph_varpool_assemble_pending_variables\n+\n+      In non-unit-at-a-time mode these functions can be used to force compilation\n+      of functions or variables that are known to be needed at given stage\n+      of compilation\n+\n+    - cgraph_mark_needed_node\n+    - cgraph_varpool_mark_needed_node\n+\n+      When function or variable is referenced by some hidden way (for instance\n+      via assembly code and marked by attribute \"used\"), the call-graph data structure\n+      must be updated accordingly by this function.\n+\n+    - analyze_expr callback\n+\n+      This function is responsible for lowering tree nodes not understood by\n+      generic code into understandable ones or alternatively marking\n+      callgraph and varpool nodes referenced by the as needed.\n+\n+      ??? On the tree-ssa genericizing should take place here and we will avoid\n+      need for these hooks (replacing them by genericizing hook)\n+\n+    - expand_function callback\n+\n+      This function is used to expand function and pass it into RTL back-end.\n+      Front-end should not make any assumptions about when this function can be\n+      called.  In particular cgraph_assemble_pending_functions,\n+      cgraph_varpool_assemble_pending_variables, cgraph_finalize_function,\n+      cgraph_varpool_finalize_function, cgraph_optimize can cause arbitrarily\n+      previously finalized functions to be expanded.\n+\n+    We implement two compilation modes.\n+\n+      - unit-at-a-time:  In this mode analyzing of all functions is deferred\n+\tto cgraph_finalize_compilation_unit and expansion into cgraph_optimize.\n+\n+\tIn cgraph_finalize_compilation_unit the reachable functions are\n+\tanalyzed.  During analysis the call-graph edges from reachable\n+\tfunctions are constructed and their destinations are marked as\n+\treachable.  References to functions and variables are discovered too\n+\tand variables found to be needed output to the assembly file.  Via\n+\tmark_referenced call in assemble_variable functions referenced by\n+\tstatic variables are noticed too.\n+\n+\tThe intra-procedural information is produced and it's existence\n+\tindicated by global_info_ready.  Once this flag is set it is impossible\n+\tto change function from !reachable to reachable and thus\n+\tassemble_variable no longer call mark_referenced.\n+\n+\tFinally the call-graph is topologically sorted and all reachable functions\n+\tthat has not been completely inlined or are not external are output.\n+\n+\t??? It is possible that reference to function or variable is optimized\n+\tout.  We can not deal with this nicely because topological order is not\n+\tsuitable for it.  For tree-ssa we may consider another pass doing\n+\toptimization and re-discovering reachable functions.\n+\n+\t??? Reorganize code so variables are output very last and only if they\n+\treally has been referenced by produced code, so we catch more cases\n+\twhere reference has been optimized out.\n+\n+      - non-unit-at-a-time\n+\n+\tAll functions are variables are output as early as possible to conserve\n+\tmemory consumption.  This may or may not result in less memory used but\n+\tit is still needed for some legacy code that rely on particular ordering\n+\tof things output from the compiler.\n+\n+\tVarpool data structures are not used and variables are output directly.\n+\n+\tFunctions are output early using call of\n+\tcgraph_assemble_pending_function from cgraph_finalize_function.  The\n+\tdecision on whether function is needed is made more conservative so\n+\tuninlininable static functions are needed too.  During the call-graph\n+\tconstruction the edge destinations are not marked as reachable and it\n+\tis completely relied upn assemble_variable to mark them.\n+\t\n+     Inlining decision heuristics\n+        ??? Move this to separate file after tree-ssa merge.\n+\n+\tWe separate inlining decisions from the inliner itself and store it\n+\tinside callgraph as so called inline plan.  Reffer to cgraph.c\n+\tdocumentation about particular representation of inline plans in the\n+\tcallgraph\n+\n+\tThe implementation of particular heuristics is separated from\n+\tthe rest of code to make it easier to replace it with more complicated\n+\timplementation in the future.  The rest of inlining code acts as a\n+\tlibrary aimed to modify the callgraph and verify that the parameters\n+\ton code size growth fits.\n+\n+\tTo mark given call inline, use cgraph_mark_inline function, the\n+\tverification is performed by cgraph_default_inline_p and\n+\tcgraph_check_inline_limits.\n+\n+\tThe heuristics implements simple knapsack style algorithm ordering\n+\tall functions by their \"profitability\" (estimated by code size growth)\n+\tand inlining them in priority order.\n+\n+\tcgraph_decide_inlining implements heuristics taking whole callgraph\n+\tinto account, while cgraph_decide_inlining_incrementally considers\n+\tonly one function at a time and is used in non-unit-at-a-time mode.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -47,7 +191,6 @@ static void cgraph_mark_functions_to_output (void);\n static void cgraph_expand_function (struct cgraph_node *);\n static tree record_call_1 (tree *, int *, void *);\n static void cgraph_mark_local_functions (void);\n-static void cgraph_optimize_function (struct cgraph_node *);\n static bool cgraph_default_inline_p (struct cgraph_node *n);\n static void cgraph_analyze_function (struct cgraph_node *node);\n static void cgraph_decide_inlining_incrementally (struct cgraph_node *);\n@@ -138,7 +281,8 @@ cgraph_assemble_pending_functions (void)\n       struct cgraph_node *n = cgraph_nodes_queue;\n \n       cgraph_nodes_queue = cgraph_nodes_queue->next_needed;\n-      if (!n->origin && !DECL_EXTERNAL (n->decl))\n+      n->next_needed = NULL;\n+      if (!n->origin && !n->global.inlined_to && !DECL_EXTERNAL (n->decl))\n \t{\n \t  cgraph_expand_function (n);\n \t  output = true;\n@@ -186,7 +330,7 @@ cgraph_finalize_function (tree decl, bool nested)\n       node->analyzed = false;\n       node->local.redefined_extern_inline = true;\n       while (node->callees)\n-\tcgraph_remove_edge (node, node->callees->callee);\n+\tcgraph_remove_edge (node->callees);\n \n       /* We may need to re-queue the node for assembling in case\n          we already proceeded it and ignored as not needed.  */\n@@ -229,7 +373,7 @@ cgraph_finalize_function (tree decl, bool nested)\n   if (!TREE_ASM_WRITTEN (decl))\n     (*debug_hooks->deferred_inline_function) (decl);\n \n-  /* We will never really output the function body, clear the SAVED_INSNS array\n+  /* We will never really output the function body, clear the STRUCT_FUNCTION array\n      early then.  */\n   if (DECL_EXTERNAL (decl))\n     DECL_STRUCT_FUNCTION (decl) = NULL;\n@@ -267,7 +411,7 @@ record_call_1 (tree *tp, int *walk_subtrees, void *data)\n \ttree decl = get_callee_fndecl (*tp);\n \tif (decl && TREE_CODE (decl) == FUNCTION_DECL)\n \t  {\n-\t    cgraph_record_call (data, decl);\n+\t    cgraph_create_edge (data, cgraph_node (decl), *tp);\n \n \t    /* When we see a function call, we don't want to look at the\n \t       function reference in the ADDR_EXPR that is hanging from\n@@ -300,20 +444,162 @@ record_call_1 (tree *tp, int *walk_subtrees, void *data)\n   return NULL;\n }\n \n-/* Create cgraph edges for function calls inside BODY from DECL.  */\n+/* Create cgraph edges for function calls inside BODY from NODE.  */\n \n void\n-cgraph_create_edges (tree decl, tree body)\n+cgraph_create_edges (struct cgraph_node *node, tree body)\n {\n   /* The nodes we're interested in are never shared, so walk\n      the tree ignoring duplicates.  */\n   visited_nodes = htab_create (37, htab_hash_pointer,\n \t\t\t\t    htab_eq_pointer, NULL);\n-  walk_tree (&body, record_call_1, decl, visited_nodes);\n+  walk_tree (&body, record_call_1, node, visited_nodes);\n   htab_delete (visited_nodes);\n   visited_nodes = NULL;\n }\n \n+static bool error_found;\n+\n+/* Callbrack of verify_cgraph_node.  Check that all call_exprs have cgraph nodes.  */\n+static tree\n+verify_cgraph_node_1 (tree *tp, int *walk_subtrees, void *data)\n+{\n+  tree t = *tp;\n+  tree decl;\n+\n+  if (TREE_CODE (t) == CALL_EXPR && (decl = get_callee_fndecl (t)))\n+    {\n+      struct cgraph_edge *e = cgraph_edge (data, t);\n+      if (e)\n+\t{\n+\t  if (e->aux)\n+\t    {\n+\t      error (\"Shared call_expr:\");\n+\t      debug_tree (t);\n+\t      error_found = true;\n+\t    }\n+\t  if (e->callee->decl != cgraph_node (decl)->decl)\n+\t    {\n+\t      error (\"Edge points to wrong declaration:\");\n+\t      debug_tree (e->callee->decl);\n+\t      fprintf (stderr,\" Instead of:\");\n+\t      debug_tree (decl);\n+\t    }\n+\t  e->aux = (void *)1;\n+\t}\n+      else\n+\t{\n+\t  error (\"Missing callgraph edge for call expr:\");\n+\t  debug_tree (t);\n+\t  error_found = true;\n+\t}\n+    }\n+  /* Save some cycles by not walking types and declaration as we\n+     won't find anything useful there anyway.  */\n+  if (DECL_P (*tp) || TYPE_P (*tp))\n+    {\n+      *walk_subtrees = 0;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Verify cgraph nodes of given cgraph node.  */\n+void\n+verify_cgraph_node (struct cgraph_node *node)\n+{\n+  struct cgraph_edge *e;\n+  struct cgraph_node *main_clone;\n+\n+  timevar_push (TV_CGRAPH_VERIFY);\n+  error_found = false;\n+  for (e = node->callees; e; e = e->next_callee)\n+    if (e->aux)\n+      {\n+\terror (\"Aux field set for edge %s->%s\",\n+\t       cgraph_node_name (e->caller), cgraph_node_name (e->callee));\n+\terror_found = true;\n+      }\n+  for (e = node->callers; e; e = e->next_caller)\n+    {\n+      if (!e->inline_failed)\n+\t{\n+\t  if (node->global.inlined_to\n+\t      != (e->caller->global.inlined_to\n+\t\t  ? e->caller->global.inlined_to : e->caller))\n+\t    {\n+\t      error (\"Inlined_to pointer is wrong\");\n+\t      error_found = true;\n+\t    }\n+\t  if (node->callers->next_caller)\n+\t    {\n+\t      error (\"Multiple inline callers\");\n+\t      error_found = true;\n+\t    }\n+\t}\n+      else\n+\tif (node->global.inlined_to)\n+\t  {\n+\t    error (\"Inlined_to pointer set for noninline callers\");\n+\t    error_found = true;\n+\t  }\n+    }\n+  if (!node->callers && node->global.inlined_to)\n+    {\n+      error (\"Inlined_to pointer is set but no predecesors found\");\n+      error_found = true;\n+    }\n+  if (node->global.inlined_to == node)\n+    {\n+      error (\"Inlined_to pointer reffers to itself\");\n+      error_found = true;\n+    }\n+\n+  for (main_clone = cgraph_node (node->decl); main_clone;\n+       main_clone = main_clone->next_clone)\n+    if (main_clone == node)\n+      break;\n+  if (!node)\n+    {\n+      error (\"Node not found in DECL_ASSEMBLER_NAME hash\");\n+      error_found = true;\n+    }\n+  \n+  if (node->analyzed\n+      && DECL_SAVED_TREE (node->decl) && !TREE_ASM_WRITTEN (node->decl)\n+      && (!DECL_EXTERNAL (node->decl) || node->global.inlined_to))\n+    {\n+      walk_tree_without_duplicates (&DECL_SAVED_TREE (node->decl),\n+\t\t\t\t    verify_cgraph_node_1, node);\n+      for (e = node->callees; e; e = e->next_callee)\n+\t{\n+\t  if (!e->aux)\n+\t    {\n+\t      error (\"Edge %s->%s has no corresponding call_expr\",\n+\t\t     cgraph_node_name (e->caller),\n+\t\t     cgraph_node_name (e->callee));\n+\t      error_found = true;\n+\t    }\n+\t  e->aux = 0;\n+\t}\n+    }\n+  if (error_found)\n+    {\n+      dump_cgraph_node (stderr, node);\n+      internal_error (\"verify_cgraph_node failed.\");\n+    }\n+  timevar_pop (TV_CGRAPH_VERIFY);\n+}\n+\n+/* Verify whole cgraph structure.  */\n+void\n+verify_cgraph (void)\n+{\n+  struct cgraph_node *node;\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    verify_cgraph_node (node);\n+}\n+\n /* Analyze the function scheduled to be output.  */\n static void\n cgraph_analyze_function (struct cgraph_node *node)\n@@ -324,7 +610,7 @@ cgraph_analyze_function (struct cgraph_node *node)\n   current_function_decl = decl;\n \n   /* First kill forward declaration so reverse inlining works properly.  */\n-  cgraph_create_edges (decl, DECL_SAVED_TREE (decl));\n+  cgraph_create_edges (node, DECL_SAVED_TREE (decl));\n \n   node->local.inlinable = tree_inlinable_function_p (decl);\n   if (!node->local.self_insns)\n@@ -334,25 +620,19 @@ cgraph_analyze_function (struct cgraph_node *node)\n     node->local.disregard_inline_limits\n       = lang_hooks.tree_inlining.disregard_inline_limits (decl);\n   for (e = node->callers; e; e = e->next_caller)\n-    if (e->inline_failed)\n-      {\n-\tif (node->local.redefined_extern_inline)\n-\t  e->inline_failed = N_(\"redefined extern inline functions are not \"\n-\t\t\t\t\"considered for inlining\");\n-\telse if (!node->local.inlinable)\n-\t  e->inline_failed = N_(\"function not inlinable\");\n-\telse\n-\t  e->inline_failed = N_(\"function not considered for inlining\");\n-      }\n+    {\n+      if (node->local.redefined_extern_inline)\n+\te->inline_failed = N_(\"redefined extern inline functions are not \"\n+\t\t\t   \"considered for inlining\");\n+      else if (!node->local.inlinable)\n+\te->inline_failed = N_(\"function not inlinable\");\n+      else\n+\te->inline_failed = N_(\"function not considered for inlining\");\n+    }\n   if (flag_really_no_inline && !node->local.disregard_inline_limits)\n     node->local.inlinable = 0;\n   /* Inlining characteristics are maintained by the cgraph_mark_inline.  */\n   node->global.insns = node->local.self_insns;\n-  if (!DECL_EXTERNAL (decl))\n-    {\n-      node->global.cloned_times = 1;\n-      node->global.will_be_output = true;\n-    }\n \n   node->analyzed = true;\n   current_function_decl = NULL;\n@@ -396,6 +676,7 @@ cgraph_finalize_compilation_unit (void)\n \n       node = cgraph_nodes_queue;\n       cgraph_nodes_queue = cgraph_nodes_queue->next_needed;\n+      node->next_needed = NULL;\n \n       /* ??? It is possible to create extern inline function and later using\n \t weak alas attribute to kill its body. See\n@@ -436,9 +717,9 @@ cgraph_finalize_compilation_unit (void)\n \n       if (!node->reachable && DECL_SAVED_TREE (decl))\n \t{\n-\t  cgraph_remove_node (node);\n \t  if (cgraph_dump_file)\n \t    fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n+\t  cgraph_remove_node (node);\n \t}\n       else\n \tnode->next_needed = NULL;\n@@ -475,45 +756,20 @@ cgraph_mark_functions_to_output (void)\n \t always inlined, as well as those that are reachable from\n \t outside the current compilation unit.  */\n       if (DECL_SAVED_TREE (decl)\n+\t  && !node->global.inlined_to\n \t  && (node->needed\n \t      || (e && node->reachable))\n \t  && !TREE_ASM_WRITTEN (decl) && !node->origin\n \t  && !DECL_EXTERNAL (decl))\n \tnode->output = 1;\n-      else\n-        DECL_STRUCT_FUNCTION (decl) = NULL;\n-    }\n-}\n-\n-/* Optimize the function before expansion.  */\n-\n-static void\n-cgraph_optimize_function (struct cgraph_node *node)\n-{\n-  tree decl = node->decl;\n-\n-  timevar_push (TV_INTEGRATION);\n-  /* optimize_inline_calls avoids inlining of current_function_decl.  */\n-  current_function_decl = decl;\n-  if (flag_inline_trees)\n-    {\n-      struct cgraph_edge *e;\n-\n-      for (e = node->callees; e; e = e->next_callee)\n-\tif (!e->inline_failed || warn_inline\n-\t    || (DECL_DECLARED_INLINE_P (e->callee->decl)\n-\t\t&& lookup_attribute (\"always_inline\",\n-\t\t\t\t     DECL_ATTRIBUTES (e->callee->decl))))\n-\t  break;\n-      if (e)\n-        optimize_inline_calls (decl);\n-    }\n-  if (node->nested)\n-    {\n-      for (node = node->nested; node; node = node->next_nested)\n-\tcgraph_optimize_function (node);\n+      /* We should've reclaimed all functions that are not needed.  */\n+      else if (!node->global.inlined_to && DECL_SAVED_TREE (decl)\n+\t       && !node->origin && !DECL_EXTERNAL (decl))\n+\t{\n+\t  dump_cgraph_node (stderr, node);\n+\t  abort ();\n+\t}\n     }\n-  timevar_pop (TV_INTEGRATION);\n }\n \n /* Expand function specified by NODE.  */\n@@ -523,17 +779,24 @@ cgraph_expand_function (struct cgraph_node *node)\n {\n   tree decl = node->decl;\n \n+  /* We ought to not compile any inline clones.  */\n+  if (node->global.inlined_to)\n+    abort ();\n+\n   if (flag_unit_at_a_time)\n     announce_function (decl);\n \n-  cgraph_optimize_function (node);\n-\n   /* Generate RTL for the body of DECL.  Nested functions are expanded\n      via lang_expand_decl_stmt.  */\n   lang_hooks.callgraph.expand_function (decl);\n   if (DECL_DEFER_OUTPUT (decl))\n     abort ();\n \n+  /* Make sure that BE didn't gave up on compiling.  */\n+  if (!TREE_ASM_WRITTEN (node->decl)\n+      && !(sorrycount || errorcount))\n+    abort ();\n+\n   current_function_decl = NULL;\n }\n \n@@ -599,207 +862,6 @@ cgraph_postorder (struct cgraph_node **order)\n   return order_pos;\n }\n \n-#define INLINED_TIMES(node) ((size_t)(node)->aux)\n-#define SET_INLINED_TIMES(node,times) ((node)->aux = (void *)(times))\n-\n-/* Return list of nodes we decided to inline NODE into, set their output\n-   flag and compute INLINED_TIMES.\n-\n-   We do simple backtracing to get INLINED_TIMES right.  This should not be\n-   expensive as we limit the amount of inlining.  Alternatively we may first\n-   discover set of nodes, topologically sort these and propagate\n-   INLINED_TIMES  */\n-\n-static int\n-cgraph_inlined_into (struct cgraph_node *node, struct cgraph_node **array)\n-{\n-  int nfound = 0;\n-  struct cgraph_edge **stack;\n-  struct cgraph_edge *e, *e1;\n-  int sp;\n-  int i;\n-\n-  /* Fast path: since we traverse in mostly topological order, we will likely\n-     find no edges.  */\n-  for (e = node->callers; e; e = e->next_caller)\n-    if (!e->inline_failed)\n-      break;\n-\n-  if (!e)\n-    return 0;\n-\n-  /* Allocate stack for back-tracking up callgraph.  */\n-  stack = xmalloc ((cgraph_n_nodes + 1) * sizeof (struct cgraph_edge));\n-  sp = 0;\n-\n-  /* Push the first edge on to the stack.  */\n-  stack[sp++] = e;\n-\n-  while (sp)\n-    {\n-      struct cgraph_node *caller;\n-\n-      /* Look at the edge on the top of the stack.  */\n-      e = stack[sp - 1];\n-      caller = e->caller;\n-\n-      /* Check if the caller destination has been visited yet.  */\n-      if (!caller->output)\n-\t{\n-\t  array[nfound++] = e->caller;\n-\t  /* Mark that we have visited the destination.  */\n-\t  caller->output = true;\n-\t  SET_INLINED_TIMES (caller, 0);\n-\t}\n-      SET_INLINED_TIMES (caller, INLINED_TIMES (caller) + 1);\n-\n-      for (e1 = caller->callers; e1; e1 = e1->next_caller)\n-\tif (!e1->inline_failed)\n-\t  break;\n-\n-      if (e1)\n-\tstack[sp++] = e1;\n-      else\n-\t{\n-\t  while (true)\n-\t    {\n-\t      for (e1 = e->next_caller; e1; e1 = e1->next_caller)\n-\t\tif (!e1->inline_failed)\n-\t\t  break;\n-\n-\t      if (e1)\n-\t\t{\n-\t\t  stack[sp - 1] = e1;\n-\t\t  break;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  sp--;\n-\t\t  if (!sp)\n-\t\t    break;\n-\t\t  e = stack[sp - 1];\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  free (stack);\n-\n-\n-  if (cgraph_dump_file)\n-    {\n-      fprintf (cgraph_dump_file, \" Found inline predecesors of %s:\",\n-\t       cgraph_node_name (node));\n-      for (i = 0; i < nfound; i++)\n-\t{\n-\t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (array[i]));\n-\t  if (INLINED_TIMES (array[i]) != 1)\n-\t    fprintf (cgraph_dump_file, \" (%i times)\",\n-\t\t     (int)INLINED_TIMES (array[i]));\n-\t}\n-      fprintf (cgraph_dump_file, \"\\n\");\n-    }\n-\n-  return nfound;\n-}\n-\n-/* Return list of nodes we decided to inline into NODE, set their output\n-   flag and compute INLINED_TIMES.\n-\n-   This function is identical to cgraph_inlined_into with callers and callees\n-   nodes swapped.  */\n-\n-static int\n-cgraph_inlined_callees (struct cgraph_node *node, struct cgraph_node **array)\n-{\n-  int nfound = 0;\n-  struct cgraph_edge **stack;\n-  struct cgraph_edge *e, *e1;\n-  int sp;\n-  int i;\n-\n-  /* Fast path: since we traverse in mostly topological order, we will likely\n-     find no edges.  */\n-  for (e = node->callees; e; e = e->next_callee)\n-    if (!e->inline_failed)\n-      break;\n-\n-  if (!e)\n-    return 0;\n-\n-  /* Allocate stack for back-tracking up callgraph.  */\n-  stack = xmalloc ((cgraph_n_nodes + 1) * sizeof (struct cgraph_edge));\n-  sp = 0;\n-\n-  /* Push the first edge on to the stack.  */\n-  stack[sp++] = e;\n-\n-  while (sp)\n-    {\n-      struct cgraph_node *callee;\n-\n-      /* Look at the edge on the top of the stack.  */\n-      e = stack[sp - 1];\n-      callee = e->callee;\n-\n-      /* Check if the callee destination has been visited yet.  */\n-      if (!callee->output)\n-\t{\n-\t  array[nfound++] = e->callee;\n-\t  /* Mark that we have visited the destination.  */\n-\t  callee->output = true;\n-\t  SET_INLINED_TIMES (callee, 0);\n-\t}\n-      SET_INLINED_TIMES (callee, INLINED_TIMES (callee) + 1);\n-\n-      for (e1 = callee->callees; e1; e1 = e1->next_callee)\n-\tif (!e1->inline_failed)\n-\t  break;\n-      if (e1)\n-\tstack[sp++] = e1;\n-      else\n-\t{\n-\t  while (true)\n-\t    {\n-\t      for (e1 = e->next_callee; e1; e1 = e1->next_callee)\n-\t\tif (!e1->inline_failed)\n-\t\t  break;\n-\n-\t      if (e1)\n-\t\t{\n-\t\t  stack[sp - 1] = e1;\n-\t\t  break;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  sp--;\n-\t\t  if (!sp)\n-\t\t    break;\n-\t\t  e = stack[sp - 1];\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  free (stack);\n-\n-  if (cgraph_dump_file)\n-    {\n-      fprintf (cgraph_dump_file, \" Found inline successors of %s:\",\n-\t       cgraph_node_name (node));\n-      for (i = 0; i < nfound; i++)\n-\t{\n-\t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (array[i]));\n-\t  if (INLINED_TIMES (array[i]) != 1)\n-\t    fprintf (cgraph_dump_file, \" (%i times)\",\n-\t\t     (int)INLINED_TIMES (array[i]));\n-\t}\n-      fprintf (cgraph_dump_file, \"\\n\");\n-    }\n-\n-  return nfound;\n-}\n-\n /* Perform reachability analysis and reclaim all unreachable nodes.\n    This function also remove unneeded bodies of extern inline functions\n    and thus needs to be done only after inlining decisions has been made.  */\n@@ -811,6 +873,9 @@ cgraph_remove_unreachable_nodes (void)\n   bool changed = false;\n   int insns = 0;\n \n+#ifdef ENABLE_CHECKING\n+  verify_cgraph ();\n+#endif\n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file, \"\\nReclaiming functions:\");\n #ifdef ENABLE_CHECKING\n@@ -850,10 +915,11 @@ cgraph_remove_unreachable_nodes (void)\n   /* Remove unreachable nodes.  Extern inline functions need special care;\n      Unreachable extern inline functions shall be removed.\n      Reachable extern inline functions we never inlined shall get their bodies\n-     eliminated.\n+     eliminated\n      Reachable extern inline functions we sometimes inlined will be turned into\n      unanalyzed nodes so they look like for true extern functions to the rest\n-     of code.  */\n+     of code.  Body of such functions is relased via remove_node once the\n+     inline clones are eliminated.  */\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       if (!node->aux)\n@@ -878,9 +944,21 @@ cgraph_remove_unreachable_nodes (void)\n \t\t  break;\n \t      if (e || node->needed)\n \t\t{\n-\t\t  DECL_SAVED_TREE (node->decl) = NULL_TREE;\n+\t\t  struct cgraph_node *clone;\n+\n+\t\t  for (clone = node->next_clone; clone;\n+\t\t       clone = clone->next_clone)\n+\t\t    if (clone->aux)\n+\t\t      break;\n+\t\t  if (!clone)\n+\t\t    {\n+\t\t      DECL_SAVED_TREE (node->decl) = NULL;\n+\t\t      DECL_STRUCT_FUNCTION (node->decl) = NULL;\n+\t\t      DECL_ARGUMENTS (node->decl) = NULL;\n+\t\t      DECL_INITIAL (node->decl) = error_mark_node;\n+\t\t    }\n \t\t  while (node->callees)\n-\t\t    cgraph_remove_edge (node, node->callees->callee);\n+\t\t    cgraph_remove_edge (node->callees);\n \t\t  node->analyzed = false;\n \t\t}\n \t      else\n@@ -898,7 +976,6 @@ cgraph_remove_unreachable_nodes (void)\n   return changed;\n }\n \n-\n /* Estimate size of the function after inlining WHAT into TO.  */\n \n static int\n@@ -914,113 +991,153 @@ static int\n cgraph_estimate_growth (struct cgraph_node *node)\n {\n   int growth = 0;\n-  int calls_saved = 0;\n-  int clones_added = 0;\n   struct cgraph_edge *e;\n \n   for (e = node->callers; e; e = e->next_caller)\n     if (e->inline_failed)\n-      {\n-\tgrowth += ((cgraph_estimate_size_after_inlining (1, e->caller, node)\n-\t\t    -\n-\t\t    e->caller->global.insns) *e->caller->global.cloned_times);\n-\tcalls_saved += e->caller->global.cloned_times;\n-\tclones_added += e->caller->global.cloned_times;\n-      }\n+      growth += (cgraph_estimate_size_after_inlining (1, e->caller, node)\n+\t\t - e->caller->global.insns);\n \n   /* ??? Wrong for self recursive functions or cases where we decide to not\n      inline for different reasons, but it is not big deal as in that case\n      we will keep the body around, but we will also avoid some inlining.  */\n   if (!node->needed && !node->origin && !DECL_EXTERNAL (node->decl))\n-    growth -= node->global.insns, clones_added--;\n-\n-  if (!calls_saved)\n-    calls_saved = 1;\n+    growth -= node->global.insns;\n \n   return growth;\n }\n \n-/* Update insn sizes after inlining WHAT into TO that is already inlined into\n-   all nodes in INLINED array.  */\n+/* E is expected to be an edge being inlined.  Clone destination node of\n+   the edge and redirect it to the new clone.\n+   DUPLICATE is used for bookeeping on whether we are actually creating new\n+   clones or re-using node originally representing out-of-line function call.\n+   */\n+void\n+cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate)\n+{\n+  struct cgraph_node *n;\n+\n+  /* We may elliminate the need for out-of-line copy to be output.  In that\n+     case just go ahead and re-use it.  */\n+  if (!e->callee->callers->next_caller\n+      && (!e->callee->needed || DECL_EXTERNAL (e->callee->decl))\n+      && !e->callee->origin\n+      && duplicate\n+      && flag_unit_at_a_time)\n+    {\n+      if (e->callee->global.inlined_to)\n+\tabort ();\n+      if (!DECL_EXTERNAL (e->callee->decl))\n+        overall_insns -= e->callee->global.insns, nfunctions_inlined++;\n+      duplicate = 0;\n+    }\n+   else if (duplicate)\n+    {\n+      n = cgraph_clone_node (e->callee);\n+      cgraph_redirect_edge_callee (e, n);\n+    }\n \n-static void\n-cgraph_mark_inline (struct cgraph_node *to, struct cgraph_node *what,\n-\t\t    struct cgraph_node **inlined, int ninlined,\n-\t\t    struct cgraph_node **inlined_callees,\n-\t\t    int ninlined_callees)\n+  if (e->caller->global.inlined_to)\n+    e->callee->global.inlined_to = e->caller->global.inlined_to;\n+  else\n+    e->callee->global.inlined_to = e->caller;\n+\n+  /* Recursivly clone all bodies.  */\n+  for (e = e->callee->callees; e; e = e->next_callee)\n+    if (!e->inline_failed)\n+      cgraph_clone_inlined_nodes (e, duplicate);\n+}\n+\n+/* Mark edge E as inlined and update callgraph accordingly.  */\n+\n+void\n+cgraph_mark_inline_edge (struct cgraph_edge *e)\n {\n-  int i;\n-  int times = 0;\n-  int clones = 0;\n-  struct cgraph_edge *e;\n-  bool called = false;\n-  int new_insns;\n+  int old_insns = 0, new_insns = 0;\n+  struct cgraph_node *to = NULL, *what;\n+\n+  if (!e->inline_failed)\n+    abort ();\n+  e->inline_failed = NULL;\n \n-  what->global.inlined = 1;\n-  for (e = what->callers; e; e = e->next_caller)\n+  if (!e->callee->global.inlined && flag_unit_at_a_time)\n     {\n-      if (e->caller == to)\n-\t{\n-\t  if (!e->inline_failed)\n-\t    continue;\n-\t  e->inline_failed = NULL;\n-\t  times++;\n-\t  clones += e->caller->global.cloned_times;\n-\t}\n-      else if (e->inline_failed)\n-\tcalled = true;\n+      void **slot;\n+      if (!cgraph_inline_hash)\n+        cgraph_inline_hash = htab_create_ggc (42, htab_hash_pointer,\n+\t\t\t\t\t      htab_eq_pointer, NULL);\n+      slot = htab_find_slot (cgraph_inline_hash,\n+\t\t\t     DECL_ASSEMBLER_NAME (e->callee->decl), INSERT);\n+      *slot = DECL_ASSEMBLER_NAME (e->callee->decl);\n     }\n-  if (!times)\n-    abort ();\n-  ncalls_inlined += times;\n+  e->callee->global.inlined = true;\n+\n+  cgraph_clone_inlined_nodes (e, true);\n \n-  new_insns = cgraph_estimate_size_after_inlining (times, to, what);\n-  if (to->global.will_be_output)\n-    overall_insns += new_insns - to->global.insns;\n-  to->global.insns = new_insns;\n+  what = e->callee;\n \n-  if (!called && !what->needed && !what->origin\n-      && flag_unit_at_a_time\n-      && !DECL_EXTERNAL (what->decl))\n+  /* Now update size of caller and all functions caller is inlined into. */\n+  for (;e && !e->inline_failed; e = e->caller->callers)\n     {\n-      if (!what->global.will_be_output)\n+      old_insns = e->caller->global.insns;\n+      new_insns = cgraph_estimate_size_after_inlining (1, e->caller,\n+\t\t\t\t\t\t       what);\n+      if (new_insns < 0)\n \tabort ();\n-      clones--;\n-      nfunctions_inlined++;\n-      what->global.will_be_output = 0;\n-      overall_insns -= what->global.insns;\n+      to = e->caller;\n+      to->global.insns = new_insns;\n     }\n-  what->global.cloned_times += clones;\n-  for (i = 0; i < ninlined; i++)\n-    {\n-      new_insns =\n-\tcgraph_estimate_size_after_inlining (INLINED_TIMES (inlined[i]) *\n-\t\t\t\t\t     times, inlined[i], what);\n-      if (inlined[i]->global.will_be_output)\n-\toverall_insns += new_insns - inlined[i]->global.insns;\n-      inlined[i]->global.insns = new_insns;\n-    }\n-  for (i = 0; i < ninlined_callees; i++)\n+  if (what->global.inlined_to != to)\n+    abort ();\n+  overall_insns += new_insns - old_insns;\n+  ncalls_inlined++;\n+}\n+\n+/* Mark all calls of EDGE->CALLEE inlined into EDGE->CALLER.\n+   Return following unredirected edge in the list of callers\n+   of EDGE->CALLEE  */\n+\n+static struct cgraph_edge *\n+cgraph_mark_inline (struct cgraph_edge *edge)\n+{\n+  struct cgraph_node *to = edge->caller;\n+  struct cgraph_node *what = edge->callee;\n+  struct cgraph_edge *e, *next;\n+  int times = 0;\n+\n+  /* Look for all calls, mark them inline and clone recursivly\n+     all inlined functions.  */\n+  for (e = what->callers; e; e = next)\n     {\n-      inlined_callees[i]->global.cloned_times +=\n-\tINLINED_TIMES (inlined_callees[i]) * clones;\n+      next = e->next_caller;\n+      if (e->caller == to && e->inline_failed)\n+\t{\n+          cgraph_mark_inline_edge (e);\n+\t  if (e == edge)\n+\t    edge = next;\n+\t  times ++;\n+\t}\n     }\n+  if (!times)\n+    abort ();\n+  return edge;\n }\n \n-/* Return false when inlining WHAT into TO is not good idea as it would cause\n-   too large growth of function bodies.  */\n+/* Return false when inlining WHAT into TO is not good idea\n+   as it would cause too large growth of function bodies.  */\n \n static bool\n cgraph_check_inline_limits (struct cgraph_node *to, struct cgraph_node *what,\n-\t\t\t    struct cgraph_node **inlined, int ninlined,\n \t\t\t    const char **reason)\n {\n-  int i;\n   int times = 0;\n   struct cgraph_edge *e;\n   int newsize;\n   int limit;\n \n+  if (to->global.inlined_to)\n+    to = to->global.inlined_to;\n+\n   for (e = to->callees; e; e = e->next_callee)\n     if (e->callee == what)\n       times++;\n@@ -1038,23 +1155,10 @@ cgraph_check_inline_limits (struct cgraph_node *to, struct cgraph_node *what,\n   if (newsize > PARAM_VALUE (PARAM_LARGE_FUNCTION_INSNS)\n       && newsize > limit)\n     {\n-      *reason = N_(\"--param large-function-growth limit reached\");\n+      if (reason)\n+        *reason = N_(\"--param large-function-growth limit reached\");\n       return false;\n     }\n-  for (i = 0; i < ninlined; i++)\n-    {\n-      newsize =\n-\tcgraph_estimate_size_after_inlining (INLINED_TIMES (inlined[i]) *\n-\t\t\t\t\t     times, inlined[i], what);\n-      if (newsize > PARAM_VALUE (PARAM_LARGE_FUNCTION_INSNS)\n-\t  && newsize >\n-\t  inlined[i]->local.self_insns *\n-\t  (100 + PARAM_VALUE (PARAM_LARGE_FUNCTION_GROWTH)) / 100)\n-\t{\n-\t  *reason = N_(\"--param large-function-growth limit reached while inlining the caller\");\n-\t  return false;\n-\t}\n-    }\n   return true;\n }\n \n@@ -1071,6 +1175,54 @@ cgraph_default_inline_p (struct cgraph_node *n)\n     return n->global.insns < MAX_INLINE_INSNS_AUTO;\n }\n \n+/* Return true when inlining WHAT would create recursive inlining.\n+   We call recursive inlining all cases where same function appears more than\n+   once in the single recusion nest path in the inline graph.  */\n+\n+static bool\n+cgraph_recursive_inlining_p (struct cgraph_node *to,\n+\t\t\t     struct cgraph_node *what,\n+\t\t\t     const char **reason)\n+{\n+  struct cgraph_node *node;\n+\n+  /* Walk TO and all functions TO is inlined in.  */\n+  while (1)\n+    {\n+      /* We create recursive inlining either by inlining WHAT into something\n+\t already inlined in possibly different clone of WHAT.  */\n+      if (what->decl == to->decl)\n+\tgoto recursive;\n+      /* Or by inlining WHAT into something that is already inlined in WHAT.  */\n+      for (node = cgraph_node (to->decl); node; node = node->next_clone)\n+\tif (node->global.inlined_to == what)\n+\t  goto recursive;\n+      if (!to->callers || to->callers->inline_failed)\n+\treturn false;\n+      to = to->callers->caller;\n+    }\n+recursive:\n+  if (reason)\n+    *reason = (what->local.disregard_inline_limits\n+\t       ? N_(\"recursive inlining\") : \"\");\n+  return true;\n+}\n+\n+/* Recompute heap nodes for each of callees.  */\n+static void\n+update_callee_keys (fibheap_t heap, struct fibnode **heap_node,\n+\t\t    struct cgraph_node *node)\n+{\n+  struct cgraph_edge *e;\n+\n+  for (e = node->callees; e; e = e->next_callee)\n+    if (e->inline_failed && heap_node[e->callee->uid])\n+      fibheap_replace_key (heap, heap_node[e->callee->uid],\n+\t\t\t   cgraph_estimate_growth (e->callee));\n+    else if (!e->inline_failed)\n+      update_callee_keys (heap, heap_node, e->callee);\n+}\n+\n /* Set inline_failed for all callers of given function to REASON.  */\n \n static void\n@@ -1093,15 +1245,12 @@ cgraph_set_inline_failed (struct cgraph_node *node, const char *reason)\n    to be passed to cgraph_inlined_into and cgraph_inlined_callees.  */\n \n static void\n-cgraph_decide_inlining_of_small_functions (struct cgraph_node **inlined,\n-\t\t\t\t\t   struct cgraph_node **inlined_callees)\n+cgraph_decide_inlining_of_small_functions (void)\n {\n-  int i;\n   struct cgraph_node *node;\n   fibheap_t heap = fibheap_new ();\n   struct fibnode **heap_node =\n     xcalloc (cgraph_max_uid, sizeof (struct fibnode *));\n-  int ninlined, ninlined_callees;\n   int max_insns = ((HOST_WIDEST_INT) initial_insns\n \t\t   * (100 + PARAM_VALUE (PARAM_INLINE_UNIT_GROWTH)) / 100);\n \n@@ -1127,7 +1276,7 @@ cgraph_decide_inlining_of_small_functions (struct cgraph_node **inlined,\n     fprintf (cgraph_dump_file, \"\\nDeciding on smaller functions:\\n\");\n   while (overall_insns <= max_insns && (node = fibheap_extract_min (heap)))\n     {\n-      struct cgraph_edge *e;\n+      struct cgraph_edge *e, *next;\n       int old_insns = overall_insns;\n \n       heap_node[node->uid] = NULL;\n@@ -1143,77 +1292,48 @@ cgraph_decide_inlining_of_small_functions (struct cgraph_node **inlined,\n \t    N_(\"--param max-inline-insns-single limit reached after inlining into the callee\"));\n \t  continue;\n \t}\n-      ninlined_callees = cgraph_inlined_callees (node, inlined_callees);\n-      for (e = node->callers; e; e = e->next_caller)\n-\tif (e->inline_failed)\n-\t  {\n-\t    /* Marking recursive function inlinine has sane semantic and\n-\t       thus we should not warn on it.  */\n- \t    if (e->caller == node)\n- \t      {\n- \t        e->inline_failed = \"\";\n- \t\tcontinue;\n- \t      }\n-\t    ninlined = cgraph_inlined_into (e->caller, inlined);\n-\t    if (e->callee->output)\n-\t      e->inline_failed = \"\";\n-\t    if (e->callee->output\n-\t\t|| !cgraph_check_inline_limits (e->caller, node, inlined,\n-\t\t\t\t\t\tninlined, &e->inline_failed))\n-\t      {\n-\t\tfor (i = 0; i < ninlined; i++)\n-\t\t  inlined[i]->output = 0, inlined[i]->aux = 0;\n-\t\tif (cgraph_dump_file)\n-\t\t  fprintf (cgraph_dump_file, \" Not inlining into %s.\\n\",\n-\t\t\t   cgraph_node_name (e->caller));\n-\t\tcontinue;\n-\t      }\n-\t    cgraph_mark_inline (e->caller, node, inlined, ninlined,\n-\t\t\t\tinlined_callees, ninlined_callees);\n-\t    if (heap_node[e->caller->uid])\n-\t      fibheap_replace_key (heap, heap_node[e->caller->uid],\n-\t\t\t\t   cgraph_estimate_growth (e->caller));\n-\n-\t    /* Size of the functions we updated into has changed, so update\n-\t       the keys.  */\n-\t    for (i = 0; i < ninlined; i++)\n-\t      {\n-\t\tinlined[i]->output = 0, inlined[i]->aux = 0;\n-\t\tif (heap_node[inlined[i]->uid])\n-\t\t  fibheap_replace_key (heap, heap_node[inlined[i]->uid],\n-\t\t\t\t       cgraph_estimate_growth (inlined[i]));\n-\t      }\n-\t    if (cgraph_dump_file)\n-\t      fprintf (cgraph_dump_file, \n-\t\t       \" Inlined into %s which now has %i insns.\\n\",\n-\t\t       cgraph_node_name (e->caller),\n-\t\t       e->caller->global.insns);\n-\t  }\n+      for (e = node->callers; e; e = next)\n+\t{\n+\t  next = e->next_caller;\n+\t  if (e->inline_failed)\n+\t    {\n+\t      struct cgraph_node *where;\n+\n+\t      if (cgraph_recursive_inlining_p (e->caller, e->callee,\n+\t\t\t\t      \t       &e->inline_failed)\n+\t\t  || !cgraph_check_inline_limits (e->caller, e->callee,\n+\t\t\t  \t\t\t  &e->inline_failed))\n+\t\t{\n+\t\t  if (cgraph_dump_file)\n+\t\t    fprintf (cgraph_dump_file, \" Not inlining into %s:%s.\\n\",\n+\t\t\t     cgraph_node_name (e->caller), e->inline_failed);\n+\t\t  continue;\n+\t\t}\n+\t      next = cgraph_mark_inline (e);\n+\t      where = e->caller;\n+\t      if (where->global.inlined_to)\n+\t\twhere = where->global.inlined_to;\n+\n+\t      if (heap_node[where->uid])\n+\t\tfibheap_replace_key (heap, heap_node[where->uid],\n+\t\t\t\t     cgraph_estimate_growth (where));\n+\n+\t      if (cgraph_dump_file)\n+\t\tfprintf (cgraph_dump_file, \n+\t\t\t \" Inlined into %s which now has %i insns.\\n\",\n+\t\t\t cgraph_node_name (e->caller),\n+\t\t\t e->caller->global.insns);\n+\t    }\n+\t}\n \n       /* Similarly all functions called by the function we just inlined\n          are now called more times; update keys.  */\n+      update_callee_keys (heap, heap_node, node);\n \n-      for (e = node->callees; e; e = e->next_callee)\n-\tif (e->inline_failed && heap_node[e->callee->uid])\n-\t  fibheap_replace_key (heap, heap_node[e->callee->uid],\n-\t\t\t       cgraph_estimate_growth (e->callee));\n-\n-      for (i = 0; i < ninlined_callees; i++)\n-\t{\n-\t  struct cgraph_edge *e;\n-\n-\t  for (e = inlined_callees[i]->callees; e; e = e->next_callee)\n-\t    if (e->inline_failed && heap_node[e->callee->uid])\n-\t      fibheap_replace_key (heap, heap_node[e->callee->uid],\n-\t\t\t\t   cgraph_estimate_growth (e->callee));\n-\n-\t  inlined_callees[i]->output = 0;\n-\t  inlined_callees[i]->aux = 0;\n-\t}\n       if (cgraph_dump_file)\n \tfprintf (cgraph_dump_file, \n-\t\t \" Inlined %i times for a net change of %+i insns.\\n\",\n-\t\t node->global.cloned_times, overall_insns - old_insns);\n+\t\t \" Inlined for a net change of %+i insns.\\n\",\n+\t\t overall_insns - old_insns);\n     }\n   while ((node = fibheap_extract_min (heap)) != NULL)\n     if (!node->local.disregard_inline_limits)\n@@ -1232,14 +1352,8 @@ cgraph_decide_inlining (void)\n   int nnodes;\n   struct cgraph_node **order =\n     xcalloc (cgraph_n_nodes, sizeof (struct cgraph_node *));\n-  struct cgraph_node **inlined =\n-    xcalloc (cgraph_n_nodes, sizeof (struct cgraph_node *));\n-  struct cgraph_node **inlined_callees =\n-    xcalloc (cgraph_n_nodes, sizeof (struct cgraph_node *));\n-  int ninlined;\n-  int ninlined_callees;\n   int old_insns = 0;\n-  int i, y;\n+  int i;\n \n   for (node = cgraph_nodes; node; node = node->next)\n     initial_insns += node->local.self_insns;\n@@ -1257,11 +1371,6 @@ cgraph_decide_inlining (void)\n \n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file, \"\\nInlining always_inline functions:\\n\");\n-#ifdef ENABLE_CHECKING\n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (node->aux || node->output)\n-      abort ();\n-#endif\n \n   /* In the first pass mark all always_inline edges.  Do this with a priority\n      so none of our later choices will make this impossible.  */\n@@ -1280,51 +1389,30 @@ cgraph_decide_inlining (void)\n \tfprintf (cgraph_dump_file,\n \t\t \"\\nConsidering %s %i insns (always inline)\\n\",\n \t\t cgraph_node_name (e->callee), e->callee->global.insns);\n-      ninlined = cgraph_inlined_into (order[i], inlined);\n       for (; e; e = e->next_callee)\n \t{\n \t  old_insns = overall_insns;\n-\t  if (!e->inline_failed || !e->callee->local.inlinable\n-\t      || !e->callee->local.disregard_inline_limits)\n-  \t    continue;\n-  \t  if (e->callee->output || e->callee == node)\n-\t    {\n-\t      e->inline_failed = N_(\"recursive inlining\");\n-\t      continue;\n-\t    }\n-\t  ninlined_callees =\n-\t    cgraph_inlined_callees (e->callee, inlined_callees);\n-\t  cgraph_mark_inline (node, e->callee, inlined, ninlined,\n-\t\t\t      inlined_callees, ninlined_callees);\n-\t  for (y = 0; y < ninlined_callees; y++)\n-\t    inlined_callees[y]->output = 0, inlined_callees[y]->aux = 0;\n+\t  if (!e->inline_failed || !e->callee->local.disregard_inline_limits)\n+\t    continue;\n+\t  if (cgraph_recursive_inlining_p (order[i], e->callee,\n+\t\t\t\t  \t   &e->inline_failed))\n+\t    continue;\n+\t  cgraph_mark_inline (e);\n \t  if (cgraph_dump_file)\n \t    fprintf (cgraph_dump_file, \n \t\t     \" Inlined into %s which now has %i insns.\\n\",\n \t\t     cgraph_node_name (node->callees->caller),\n \t             node->callees->caller->global.insns);\n \t}\n-      if (cgraph_dump_file && node->global.cloned_times > 0)\n-\tfprintf (cgraph_dump_file, \n-\t\t \" Inlined %i times for a net change of %+i insns.\\n\",\n-\t\t node->global.cloned_times, overall_insns - old_insns);\n-      for (y = 0; y < ninlined; y++)\n-\tinlined[y]->output = 0, inlined[y]->aux = 0;\n+\tif (cgraph_dump_file)\n+\t  fprintf (cgraph_dump_file, \n+\t\t   \" Inlined for a net change of %+i insns.\\n\",\n+\t\t   overall_insns - old_insns);\n     }\n-#ifdef ENABLE_CHECKING\n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (node->aux || node->output)\n-      abort ();\n-#endif\n \n   if (!flag_really_no_inline)\n     {\n-      cgraph_decide_inlining_of_small_functions (inlined, inlined_callees);\n-#ifdef ENABLE_CHECKING\n-      for (node = cgraph_nodes; node; node = node->next)\n-\tif (node->aux || node->output)\n-\t  abort ();\n-#endif\n+      cgraph_decide_inlining_of_small_functions ();\n \n       if (cgraph_dump_file)\n \tfprintf (cgraph_dump_file, \"\\nDeciding on functions called once:\\n\");\n@@ -1350,30 +1438,20 @@ cgraph_decide_inlining (void)\n \t\t  ok = false;\n \t      if (ok)\n \t\t{\n-\t\t  const char *dummy_reason;\n \t\t  if (cgraph_dump_file)\n \t\t    fprintf (cgraph_dump_file,\n \t\t\t     \"\\nConsidering %s %i insns.\\n\"\n \t\t\t     \" Called once from %s %i insns.\\n\",\n \t\t\t     cgraph_node_name (node), node->global.insns,\n \t\t\t     cgraph_node_name (node->callers->caller),\n \t\t\t     node->callers->caller->global.insns);\n-\t\t  ninlined = cgraph_inlined_into (node->callers->caller,\n-\t\t      \t\t\t\t  inlined);\n+\n \t\t  old_insns = overall_insns;\n \n-\t\t  /* Inlining functions once would never cause inlining warnings.  */\n-\t\t  if (cgraph_check_inline_limits\n-\t\t      (node->callers->caller, node, inlined, ninlined,\n-\t\t       &dummy_reason))\n+\t\t  if (cgraph_check_inline_limits (node->callers->caller, node,\n+\t\t\t\t\t  \t  NULL))\n \t\t    {\n-\t\t      ninlined_callees =\n-\t\t\tcgraph_inlined_callees (node, inlined_callees);\n-\t\t      cgraph_mark_inline (node->callers->caller, node, inlined,\n-\t\t\t\t\t  ninlined, inlined_callees,\n-\t\t\t\t\t  ninlined_callees);\n-\t\t      for (y = 0; y < ninlined_callees; y++)\n-\t\t\tinlined_callees[y]->output = 0, inlined_callees[y]->aux = 0;\n+\t\t      cgraph_mark_inline (node->callers);\n \t\t      if (cgraph_dump_file)\n \t\t\tfprintf (cgraph_dump_file,\n \t\t\t\t \" Inlined into %s which now has %i insns\"\n@@ -1388,12 +1466,14 @@ cgraph_decide_inlining (void)\n \t\t\tfprintf (cgraph_dump_file,\n \t\t\t\t \" Inline limit reached, not inlined.\\n\");\n \t\t    }\n-\t\t  for (y = 0; y < ninlined; y++)\n-\t\t    inlined[y]->output = 0, inlined[y]->aux = 0;\n \t\t}\n \t    }\n \t}\n     }\n+\n+  /* We will never output extern functions we didn't inline. \n+     ??? Perhaps we can prevent accounting of growth of external\n+     inline functions.  */\n   cgraph_remove_unreachable_nodes ();\n \n   if (cgraph_dump_file)\n@@ -1403,8 +1483,6 @@ cgraph_decide_inlining (void)\n \t     ncalls_inlined, nfunctions_inlined, initial_insns,\n \t     overall_insns);\n   free (order);\n-  free (inlined);\n-  free (inlined_callees);\n }\n \n /* Decide on the inlining.  We do so in the topological order to avoid\n@@ -1414,95 +1492,45 @@ static void\n cgraph_decide_inlining_incrementally (struct cgraph_node *node)\n {\n   struct cgraph_edge *e;\n-  struct cgraph_node **inlined =\n-    xmalloc (sizeof (struct cgraph_node *) * cgraph_n_nodes);\n-  struct cgraph_node **inlined_callees =\n-    xmalloc (sizeof (struct cgraph_node *) * cgraph_n_nodes);\n-  int ninlined;\n-  int ninlined_callees;\n-  int y;\n-\n-  ninlined = cgraph_inlined_into (node, inlined);\n \n   /* First of all look for always inline functions.  */\n   for (e = node->callees; e; e = e->next_callee)\n-    if (e->callee->local.disregard_inline_limits && e->inline_failed\n+    if (e->callee->local.disregard_inline_limits\n+\t&& e->inline_failed\n+        && !cgraph_recursive_inlining_p (node, e->callee, &e->inline_failed)\n \t/* ??? It is possible that renaming variable removed the function body\n \t   in duplicate_decls. See gcc.c-torture/compile/20011119-2.c  */\n \t&& DECL_SAVED_TREE (e->callee->decl))\n-      {\n-\tif (e->callee->output || e->callee == node)\n-\t  {\n- \t    e->inline_failed = N_(\"recursive inlining\");\n-\t    continue;\n-\t  }\n-\tninlined_callees = cgraph_inlined_callees (e->callee, inlined_callees);\n-\tcgraph_mark_inline (node, e->callee, inlined, ninlined,\n-\t\t\t    inlined_callees, ninlined_callees);\n-\tfor (y = 0; y < ninlined_callees; y++)\n-\t  inlined_callees[y]->output = 0, inlined_callees[y]->aux = 0;\n-      }\n+      cgraph_mark_inline (e);\n \n+  /* Now do the automatic inlining.  */\n   if (!flag_really_no_inline)\n-    {\n-      /* Now do the automatic inlining.  */\n-      for (e = node->callees; e; e = e->next_callee)\n-\tif (e->callee->local.inlinable && e->inline_failed\n-\t    && cgraph_default_inline_p (e->callee)\n-\t    && cgraph_check_inline_limits (node, e->callee, inlined,\n-\t\t\t\t\t   ninlined, &e->inline_failed)\n-\t    && DECL_SAVED_TREE (e->callee->decl))\n-\t  {\n-\t    /* Marking recursive function inlinine has sane semantic and thus\n-\t       we should not warn on it.  */\n-\t    if (e->callee->output || e->callee == node)\n-\t      {\n-\t\te->inline_failed = \"\";\n-\t\tcontinue;\n-\t      }\n-\t    ninlined_callees = cgraph_inlined_callees (e->callee,\n-\t\t\t\t\t\t       inlined_callees);\n-\t    cgraph_mark_inline (node, e->callee, inlined, ninlined,\n-\t\t\t\tinlined_callees, ninlined_callees);\n-\t    for (y = 0; y < ninlined_callees; y++)\n-\t      inlined_callees[y]->output = 0, inlined_callees[y]->aux = 0;\n-\t  }\n-    }\n-\n-  /* Clear the flags set by cgraph_inlined_into.  */\n-  for (y = 0; y < ninlined; y++)\n-    inlined[y]->output = 0, inlined[y]->aux = 0;\n-\n-  free (inlined);\n-  free (inlined_callees);\n+    for (e = node->callees; e; e = e->next_callee)\n+      if (e->callee->local.inlinable\n+\t  && e->inline_failed\n+\t  && !e->callee->local.disregard_inline_limits\n+\t  && !cgraph_recursive_inlining_p (node, e->callee, &e->inline_failed)\n+\t  && cgraph_check_inline_limits (node, e->callee, &e->inline_failed)\n+\t  && DECL_SAVED_TREE (e->callee->decl))\n+\t{\n+\t  if (cgraph_default_inline_p (e->callee))\n+\t    cgraph_mark_inline (e);\n+\t  else\n+\t    e->inline_failed\n+\t      = N_(\"--param max-inline-insns-single limit reached\");\n+\t}\n }\n \n \n-/* Return true when CALLER_DECL should be inlined into CALLEE_DECL.\n-   When returned false and reason is non-NULL, set it to the reason\n-   why the call was not inlined.  */\n+/* Return true when CALLER_DECL should be inlined into CALLEE_DECL.  */\n \n bool\n-cgraph_inline_p (tree caller_decl, tree callee_decl, const char **reason)\n+cgraph_inline_p (struct cgraph_edge *e, const char **reason)\n {\n-  struct cgraph_node *caller = cgraph_node (caller_decl);\n-  struct cgraph_node *callee = cgraph_node (callee_decl);\n-  struct cgraph_edge *e;\n-\n-  for (e = caller->callees; e; e = e->next_callee)\n-    if (e->callee == callee)\n-      {\n-\tif (e->inline_failed && reason)\n-\t  *reason = e->inline_failed;\n-        return !e->inline_failed;\n-      }\n-  /* We do not record builtins in the callgraph.  Perhaps it would make more\n-     sense to do so and then prune out those not overwritten by explicit\n-     function body.  */\n-  if (reason)\n-    *reason = \"originally indirect function calls never inlined\";\n-  return false;\n+  *reason = e->inline_failed;\n+  return !e->inline_failed;\n }\n+\n /* Expand all functions that must be output.\n \n    Attempt to topologically sort the nodes so function is output when\n@@ -1519,14 +1547,22 @@ cgraph_expand_all_functions (void)\n   struct cgraph_node *node;\n   struct cgraph_node **order =\n     xcalloc (cgraph_n_nodes, sizeof (struct cgraph_node *));\n-  int order_pos = 0;\n+  int order_pos = 0, new_order_pos = 0;\n   int i;\n \n   cgraph_mark_functions_to_output ();\n \n   order_pos = cgraph_postorder (order);\n+  if (order_pos != cgraph_n_nodes)\n+    abort ();\n \n-  for (i = order_pos - 1; i >= 0; i--)\n+  /* Garbage collector may remove inline clones we elliminate during\n+     optimization.  So we must be sure to not reference them.  */\n+  for (i = 0; i < order_pos; i++)\n+    if (order[i]->output)\n+      order[new_order_pos++] = order[i];\n+\n+  for (i = new_order_pos - 1; i >= 0; i--)\n     {\n       node = order[i];\n       if (node->output)\n@@ -1569,11 +1605,32 @@ cgraph_mark_local_functions (void)\n     fprintf (cgraph_dump_file, \"\\n\\n\");\n }\n \n+/* Return true when function body of DECL still needs to be kept around\n+   for later re-use.  */\n+bool\n+cgraph_preserve_function_body_p (tree decl)\n+{\n+  struct cgraph_node *node;\n+  /* Keep the body; we're going to dump it.  */\n+  if (dump_enabled_p (TDI_all))\n+    return true;\n+  if (!cgraph_global_info_ready)\n+    return (DECL_INLINE (decl) && !flag_really_no_inline);\n+  /* Look if there is any clone around.  */\n+  for (node = cgraph_node (decl); node; node = node->next_clone)\n+    if (node->global.inlined_to)\n+      return true;\n+  return false;\n+}\n+\n /* Perform simple optimizations based on callgraph.  */\n \n void\n cgraph_optimize (void)\n {\n+#ifdef ENABLE_CHECKING\n+  verify_cgraph ();\n+#endif\n   if (!flag_unit_at_a_time)\n     return;\n   timevar_push (TV_CGRAPHOPT);\n@@ -1587,7 +1644,8 @@ cgraph_optimize (void)\n       dump_cgraph (cgraph_dump_file);\n     }\n \n-  cgraph_decide_inlining ();\n+  if (flag_inline_trees)\n+    cgraph_decide_inlining ();\n   cgraph_global_info_ready = true;\n   if (cgraph_dump_file)\n     {\n@@ -1599,10 +1657,16 @@ cgraph_optimize (void)\n   /* Output everything.  */\n   if (!quiet_flag)\n     fprintf (stderr, \"Assembling functions:\\n\");\n+#ifdef ENABLE_CHECKING\n+  verify_cgraph ();\n+#endif\n   cgraph_expand_all_functions ();\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"\\nFinal \");\n       dump_cgraph (cgraph_dump_file);\n     }\n+#ifdef ENABLE_CHECKING\n+  verify_cgraph ();\n+#endif\n }"}, {"sha": "75a948b4dc10463353fe800399ec5b8e68dc707e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=18c6ada9b2ee27a40db256f4c32779fc25872050", "patch": "@@ -1,3 +1,9 @@\n+2004-04-02  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cp-lang. (LANG_HOOKS_UPDATE_DECL_AFTER_SAVING): Define.\n+\t* cp-tree.h (cp_update_decl_after_saving): Declare.\n+\t* tree.c (cp_update_decl_after_saving): Define.\n+\n 2004-04-01  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/14803"}, {"sha": "bbe91707dd7575debbc569b36249d752c518bf98", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=18c6ada9b2ee27a40db256f4c32779fc25872050", "patch": "@@ -112,6 +112,8 @@ static void cxx_initialize_diagnostics (diagnostic_context *);\n #define LANG_HOOKS_WRITE_GLOBALS lhd_do_nothing\n #undef LANG_HOOKS_DECL_UNINIT\n #define LANG_HOOKS_DECL_UNINIT c_decl_uninit\n+#undef LANG_HOOKS_UPDATE_DECL_AFTER_SAVING\n+#define LANG_HOOKS_UPDATE_DECL_AFTER_SAVING cp_update_decl_after_saving\n \n \n #undef LANG_HOOKS_FUNCTION_INIT"}, {"sha": "262c314051f640076cf5bc33297cdf0754b17d72", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=18c6ada9b2ee27a40db256f4c32779fc25872050", "patch": "@@ -4161,6 +4161,7 @@ extern int cp_is_overload_p (tree);\n extern int cp_auto_var_in_fn_p (tree,tree);\n extern tree cp_copy_res_decl_for_inlining (tree, tree, tree, void*,\n \t\t\t\t\t\t   int*, tree);\n+extern void cp_update_decl_after_saving (tree, void *);\n \n /* in typeck.c */\n extern int string_conv_p\t\t\t(tree, tree, int);"}, {"sha": "afa5c4b445c17b1178c62e5f961d4b758c8a4e08", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=18c6ada9b2ee27a40db256f4c32779fc25872050", "patch": "@@ -2206,6 +2206,20 @@ cp_copy_res_decl_for_inlining (tree result,\n   return var;\n }\n \n+/* FN body has been duplicated.  Update language specific fields.  */\n+\n+void\n+cp_update_decl_after_saving (tree fn, \n+                             void* decl_map_)\n+{\n+  splay_tree decl_map = (splay_tree)decl_map_;\n+  tree nrv = DECL_SAVED_FUNCTION_DATA (fn)->x_return_value;\n+  if (nrv)\n+    {\n+      DECL_SAVED_FUNCTION_DATA (fn)->x_return_value\n+\t= (tree) splay_tree_lookup (decl_map, (splay_tree_key) nrv)->value;\n+    }\n+}\n /* Initialize tree.c.  */\n \n void"}, {"sha": "122e4906c4652f6652a94df06623a3c87eeeea29", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=18c6ada9b2ee27a40db256f4c32779fc25872050", "patch": "@@ -1,3 +1,9 @@\n+2004-04-02  Jan Hubicka  <jh@suse.cz>\n+\n+\t* Make-lang.in (com.o): Add dependnecy on function.h\n+\t* com.c: Include function.h\n+\t(finish_function): Clear DECL_STRUCT_FUNCTION.\n+\n 2004-04-01  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* com.c (ffe_truthvalue_conversion, case COMPONENT_REF):"}, {"sha": "80c870c317318f2ace96245f92883a8e2fd7f425", "filename": "gcc/f/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Ff%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Ff%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FMake-lang.in?ref=18c6ada9b2ee27a40db256f4c32779fc25872050", "patch": "@@ -374,7 +374,7 @@ f/com.o: f/com.c f/proj.h $(CONFIG_H) $(SYSTEM_H) flags.h $(RTL_H) $(TREE_H) \\\n  f/intrin.def f/lab.h f/symbol.h f/symbol.def f/equiv.h f/storag.h f/global.h \\\n  f/name.h f/expr.h f/implic.h f/src.h f/st.h $(GGC_H) toplev.h diagnostic.h \\\n  $(LANGHOOKS_DEF) langhooks.h intl.h real.h debug.h gt-f-com.h gtype-f.h \\\n- coretypes.h $(TM_H)\n+ coretypes.h $(TM_H) function.h\n f/data.o: f/data.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/data.h f/bld.h f/bld-op.def \\\n  f/bit.h f/malloc.h f/com.h f/com-rt.def $(TREE_H) f/info.h f/info-b.def \\\n  f/info-k.def f/info-w.def f/target.h f/bad.h f/bad.def f/where.h glimits.h \\"}, {"sha": "951e01891ba584d753f4804e930ad48a683da802", "filename": "gcc/f/com.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=18c6ada9b2ee27a40db256f4c32779fc25872050", "patch": "@@ -136,6 +136,7 @@ typedef struct { unsigned :16, :16, :16; } vms_ino_t;\n #include \"target.h\"\n #include \"top.h\"\n #include \"type.h\"\n+#include \"function.h\"\n \n /* Externals defined here.  */\n \n@@ -13591,6 +13592,12 @@ finish_function (int nested)\n \n       /* Run the optimizers and output the assembler code for this function.  */\n       rest_of_compilation (fndecl);\n+      if (! DECL_DEFER_OUTPUT (fndecl))\n+\t{\n+\t  free_after_compilation (cfun);\n+\t  DECL_STRUCT_FUNCTION (fndecl) = 0;\n+\t}\n+      cfun = 0;\n \n       /* Undo the GC context switch.  */\n       if (nested)"}, {"sha": "2c3a847cb5816ac6369f2e00e4abc8404cf5676c", "filename": "gcc/function.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=18c6ada9b2ee27a40db256f4c32779fc25872050", "patch": "@@ -181,6 +181,13 @@ struct function GTY(())\n   struct emit_status *emit;\n   struct varasm_status *varasm;\n \n+  /* For tree-optimize.c.  */\n+\n+  /* Saved tree and arguments during tree optimization.  Used later for\n+     inlining */\n+  tree saved_tree;\n+  tree saved_args;\n+\n   /* For function.c.  */\n \n   /* Points to the FUNCTION_DECL of this function.  */"}, {"sha": "5af66da7223daaba22f062880622c5f7df27df70", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=18c6ada9b2ee27a40db256f4c32779fc25872050", "patch": "@@ -124,6 +124,7 @@ extern tree lhd_callgraph_analyze_expr (tree *, int *, tree);\n #define LANG_HOOKS_EXPR_SIZE\t\tlhd_expr_size\n #define LANG_HOOKS_DECL_UNINIT\t\tlhd_decl_uninit\n #define LANG_HOOKS_TREE_SIZE\t\tlhd_tree_size\n+#define LANG_HOOKS_UPDATE_DECL_AFTER_SAVING NULL\n \n #define LANG_HOOKS_FUNCTION_INIT\tlhd_do_nothing_f\n #define LANG_HOOKS_FUNCTION_FINAL\tlhd_do_nothing_f\n@@ -304,6 +305,7 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_PRINT_ERROR_FUNCTION, \\\n   LANG_HOOKS_EXPR_SIZE, \\\n   LANG_HOOKS_DECL_UNINIT, \\\n+  LANG_HOOKS_UPDATE_DECL_AFTER_SAVING, \\\n   LANG_HOOKS_ATTRIBUTE_TABLE, \\\n   LANG_HOOKS_COMMON_ATTRIBUTE_TABLE, \\\n   LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE, \\"}, {"sha": "8ad1c477575a43da069214746117788713f93a3a", "filename": "gcc/langhooks.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=18c6ada9b2ee27a40db256f4c32779fc25872050", "patch": "@@ -396,6 +396,9 @@ struct lang_hooks\n      uninitialized based on DECL_INITIAL.  */\n   bool (*decl_uninit) (tree);\n \n+  /* Update lang specific fields after duplicating function body.  */\n+  void (*update_decl_after_saving) (tree, void *);\n+\n   /* Pointers to machine-independent attribute tables, for front ends\n      using attribs.c.  If one is NULL, it is ignored.  Respectively, a\n      table of attributes specific to the language, a table of"}, {"sha": "d0ab392e36c389ab22b992f0a1ce619677e05887", "filename": "gcc/passes.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=18c6ada9b2ee27a40db256f4c32779fc25872050", "patch": "@@ -2109,12 +2109,6 @@ rest_of_compilation (tree decl)\n \n   /* We're done with this function.  Free up memory if we can.  */\n   free_after_parsing (cfun);\n-  if (! DECL_DEFER_OUTPUT (decl))\n-    {\n-      free_after_compilation (cfun);\n-      DECL_STRUCT_FUNCTION (decl) = 0;\n-    }\n-  cfun = 0;\n \n   ggc_collect ();\n "}, {"sha": "c7ccd53a484c6e6e8f64268d56a65ff715423baf", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=18c6ada9b2ee27a40db256f4c32779fc25872050", "patch": "@@ -61,6 +61,7 @@ DEFTIMEVAR (TV_PARSE                 , \"parser\")\n DEFTIMEVAR (TV_NAME_LOOKUP           , \"name lookup\")\n DEFTIMEVAR (TV_OVERLOAD              , \"overload resolution\")\n DEFTIMEVAR (TV_TEMPLATE_INSTANTIATION, \"template instantiation\")\n+DEFTIMEVAR (TV_CGRAPH_VERIFY         , \"callgraph verifier\")\n DEFTIMEVAR (TV_EXPAND\t\t     , \"expand\")\n DEFTIMEVAR (TV_VARCONST              , \"varconst\")\n DEFTIMEVAR (TV_INTEGRATION           , \"integration\")"}, {"sha": "d9aeefe14dbca1c628e633e39b33cadb815de183", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 145, "deletions": 36, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=18c6ada9b2ee27a40db256f4c32779fc25872050", "patch": "@@ -40,6 +40,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"cgraph.h\"\n #include \"intl.h\"\n #include \"diagnostic.h\"\n+#include \"function.h\"\n \n /* This should be eventually be generalized to other languages, but\n    this would require a shared function-as-trees infrastructure.  */\n@@ -100,12 +101,15 @@ typedef struct inline_data\n      distinguish between those two situations.  This flag is true if\n      we are cloning, rather than inlining.  */\n   bool cloning_p;\n+  /* Similarly for saving function body.  */\n+  bool saving_p;\n   /* Hash table used to prevent walk_tree from visiting the same node\n      umpteen million times.  */\n   htab_t tree_pruner;\n-  /* Decl of function we are inlining into.  */\n-  tree decl;\n-  tree current_decl;\n+  /* Callgraph node of function we are inlining into.  */\n+  struct cgraph_node *node;\n+  /* Callgraph node of currently inlined function.  */\n+  struct cgraph_node *current_node;\n } inline_data;\n \n /* Prototypes.  */\n@@ -537,9 +541,9 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n   /* If this is a RETURN_STMT, change it into an EXPR_STMT and a\n      GOTO_STMT with the RET_LABEL as its target.  */\n #ifndef INLINER_FOR_JAVA\n-  if (TREE_CODE (*tp) == RETURN_STMT && id->ret_label)\n+  if (TREE_CODE (*tp) == RETURN_STMT && id->ret_label && !id->saving_p)\n #else /* INLINER_FOR_JAVA */\n-  if (TREE_CODE (*tp) == RETURN_EXPR && id->ret_label)\n+  if (TREE_CODE (*tp) == RETURN_EXPR && id->ret_label && !id->saving_p)\n #endif /* INLINER_FOR_JAVA */\n     {\n       tree return_stmt = *tp;\n@@ -646,6 +650,8 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n      knows not to copy VAR_DECLs, etc., so this is safe.  */\n   else\n     {\n+      tree old_node = *tp;\n+\n       if (TREE_CODE (*tp) == MODIFY_EXPR\n \t  && TREE_OPERAND (*tp, 0) == TREE_OPERAND (*tp, 1)\n \t  && (lang_hooks.tree_inlining.auto_var_in_fn_p\n@@ -693,6 +699,32 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \n       copy_tree_r (tp, walk_subtrees, NULL);\n \n+      if (TREE_CODE (*tp) == CALL_EXPR && id->node && get_callee_fndecl (*tp))\n+\t{\n+\t  if (id->saving_p)\n+\t    {\n+\t      struct cgraph_node *node;\n+              struct cgraph_edge *edge;\n+\n+\t      for (node = id->node->next_clone; node; node = node->next_clone)\n+\t\t{\n+\t\t  edge = cgraph_edge (node, old_node);\n+\t\t  if (edge)\n+\t\t    edge->call_expr = *tp;\n+\t\t  else\n+\t\t    abort ();\n+\t\t}\n+\t    }\n+\t  else if (!id->cloning_p)\n+\t    {\n+              struct cgraph_edge *edge;\n+\n+\t      edge = cgraph_edge (id->current_node, old_node);\n+\t      if (edge)\n+\t        cgraph_clone_edge (edge, id->node, *tp);\n+\t    }\n+\t}\n+\n       TREE_TYPE (*tp) = remap_type (TREE_TYPE (*tp), id);\n \n       /* The copied TARGET_EXPR has never been expanded, even if the\n@@ -715,8 +747,13 @@ static tree\n copy_body (inline_data *id)\n {\n   tree body;\n+  tree fndecl = VARRAY_TOP_TREE (id->fns);\n \n-  body = DECL_SAVED_TREE (VARRAY_TOP_TREE (id->fns));\n+  if (fndecl == current_function_decl\n+      && cfun->saved_tree)\n+    body = cfun->saved_tree;\n+  else\n+    body = DECL_SAVED_TREE (fndecl);\n   walk_tree (&body, copy_body_r, id, NULL);\n \n   return body;\n@@ -742,8 +779,9 @@ initialize_inlined_parameters (inline_data *id, tree args, tree fn, tree block)\n   int argnum = 0;\n \n   /* Figure out what the parameters are.  */\n-  parms = \n-DECL_ARGUMENTS (fn);\n+  parms = DECL_ARGUMENTS (fn);\n+  if (fn == current_function_decl && cfun->saved_args)\n+    parms = cfun->saved_args;\n \n   /* Start with no initializations whatsoever.  */\n   init_stmts = NULL_TREE;\n@@ -1254,6 +1292,7 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n   splay_tree st;\n   tree args;\n   tree return_slot_addr;\n+  struct cgraph_edge *edge;\n   const char *reason;\n \n   /* See what we've got.  */\n@@ -1333,9 +1372,30 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n       && DECL_SAVED_TREE (DECL_ABSTRACT_ORIGIN (fn)))\n     fn = DECL_ABSTRACT_ORIGIN (fn);\n \n+  /* Objective C and fortran still calls tree_rest_of_compilation directly.\n+     Kill this check once this is fixed.  */\n+  if (!id->current_node->analyzed)\n+    return NULL_TREE;\n+\n+  edge = cgraph_edge (id->current_node, t);\n+\n+  /* Constant propagation on argument done during previous inlining\n+     may create new direct call.  Produce an edge for it.  */\n+  if (!edge)\n+    {\n+      struct cgraph_node *dest = cgraph_node (fn);\n+\n+      /* FN must have address taken so it can be passed as argument.  */\n+      if (!dest->needed)\n+\tabort ();\n+      cgraph_create_edge (id->node, dest, t)->inline_failed\n+\t= N_(\"originally indirect function call not considered for inlining\");\n+      return NULL_TREE;\n+    }\n+\n   /* Don't try to inline functions that are not well-suited to\n      inlining.  */\n-  if (!cgraph_inline_p (id->current_decl, fn, &reason))\n+  if (!cgraph_inline_p (edge, &reason))\n     {\n       if (lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)))\n \t{\n@@ -1352,6 +1412,11 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n       return NULL_TREE;\n     }\n \n+#ifdef ENABLE_CHECKING\n+  if (edge->callee->decl != id->node->decl)\n+    verify_cgraph_node (edge->callee);\n+#endif\n+\n   if (! lang_hooks.tree_inlining.start_inlining (fn))\n     return NULL_TREE;\n \n@@ -1487,23 +1552,29 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n \n   /* After we've initialized the parameters, we insert the body of the\n      function itself.  */\n+  {\n+    struct cgraph_node *old_node = id->current_node;\n+\n+    id->current_node = edge->callee;\n #ifndef INLINER_FOR_JAVA\n-  inlined_body = &COMPOUND_BODY (stmt);\n-  while (*inlined_body)\n-    inlined_body = &TREE_CHAIN (*inlined_body);\n-  *inlined_body = copy_body (id);\n+    inlined_body = &COMPOUND_BODY (stmt);\n+    while (*inlined_body)\n+      inlined_body = &TREE_CHAIN (*inlined_body);\n+    *inlined_body = copy_body (id);\n #else /* INLINER_FOR_JAVA */\n-  {\n-    tree new_body;\n-    java_inlining_map_static_initializers (fn, id->decl_map);\n-    new_body = copy_body (id);\n-    TREE_TYPE (new_body) = TREE_TYPE (TREE_TYPE (fn));\n-    BLOCK_EXPR_BODY (expr)\n-      = add_stmt_to_compound (BLOCK_EXPR_BODY (expr),\n-\t\t\t      TREE_TYPE (new_body), new_body);\n-    inlined_body = &BLOCK_EXPR_BODY (expr);\n-  }\n+    {\n+      tree new_body;\n+      java_inlining_map_static_initializers (fn, id->decl_map);\n+      new_body = copy_body (id);\n+      TREE_TYPE (new_body) = TREE_TYPE (TREE_TYPE (fn));\n+      BLOCK_EXPR_BODY (expr)\n+\t= add_stmt_to_compound (BLOCK_EXPR_BODY (expr),\n+\t\t\t\tTREE_TYPE (new_body), new_body);\n+      inlined_body = &BLOCK_EXPR_BODY (expr);\n+    }\n #endif /* INLINER_FOR_JAVA */\n+    id->current_node = old_node;\n+  }\n \n   /* After the body of the function comes the RET_LABEL.  This must come\n      before we evaluate the returned value below, because that evaluation\n@@ -1574,19 +1645,10 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n   TREE_USED (*tp) = 1;\n \n   /* Update callgraph if needed.  */\n-  if (id->decl)\n-    {\n-      cgraph_remove_call (id->decl, fn);\n-      cgraph_create_edges (id->decl, *inlined_body);\n-    }\n+  cgraph_remove_node (edge->callee);\n \n   /* Recurse into the body of the just inlined function.  */\n-  {\n-    tree old_decl = id->current_decl;\n-    id->current_decl = fn;\n-    expand_calls_inline (inlined_body, id);\n-    id->current_decl = old_decl;\n-  }\n+  expand_calls_inline (inlined_body, id);\n   VARRAY_POP (id->fns);\n \n   /* Don't walk into subtrees.  We've already handled them above.  */\n@@ -1629,8 +1691,7 @@ optimize_inline_calls (tree fn)\n   /* Clear out ID.  */\n   memset (&id, 0, sizeof (id));\n \n-  id.decl = fn;\n-  id.current_decl = fn;\n+  id.current_node = id.node = cgraph_node (fn);\n   /* Don't allow recursion into FN.  */\n   VARRAY_TREE_INIT (id.fns, 32, \"fns\");\n   VARRAY_PUSH_TREE (id.fns, fn);\n@@ -1669,6 +1730,18 @@ optimize_inline_calls (tree fn)\n \t\tVARRAY_ACTIVE_SIZE (id.inlined_fns) * sizeof (tree));\n       DECL_INLINED_FNS (fn) = ifn;\n     }\n+#ifdef ENABLE_CHECKING\n+    {\n+      struct cgraph_edge *e;\n+\n+      verify_cgraph_node (id.node);\n+\n+      /* Double check that we inlined everything we are supposed to inline.  */\n+      for (e = id.node->callees; e; e = e->next_callee)\n+\tif (!e->inline_failed)\n+\t  abort ();\n+    }\n+#endif\n }\n \n /* FN is a function that has a complete body, and CLONE is a function\n@@ -1698,6 +1771,42 @@ clone_body (tree clone, tree fn, void *arg_map)\n   TREE_CHAIN (DECL_SAVED_TREE (clone)) = copy_body (&id);\n }\n \n+/* Save duplicate of body in FN.  MAP is used to pass around splay tree\n+   used to update arguments in restore_body.  */\n+tree\n+save_body (tree fn, tree *arg_copy)\n+{\n+  inline_data id;\n+  tree body, *parg;\n+\n+  memset (&id, 0, sizeof (id));\n+  VARRAY_TREE_INIT (id.fns, 1, \"fns\");\n+  VARRAY_PUSH_TREE (id.fns, fn);\n+  id.node = cgraph_node (fn);\n+  id.saving_p = true;\n+  id.decl_map = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);\n+  *arg_copy = DECL_ARGUMENTS (fn);\n+  for (parg = arg_copy; *parg; parg = &TREE_CHAIN (*parg))\n+    {\n+      tree new = copy_node (*parg);\n+      (*lang_hooks.dup_lang_specific_decl) (new);\n+      DECL_ABSTRACT_ORIGIN (new) = DECL_ORIGIN (*parg);\n+      insert_decl_map (&id, *parg, new);\n+      TREE_CHAIN (new) = TREE_CHAIN (*parg);\n+      *parg = new;\n+    }\n+  insert_decl_map (&id, DECL_RESULT (fn), DECL_RESULT (fn));\n+\n+  /* Actually copy the body.  */\n+  body = copy_body (&id);\n+  if (lang_hooks.update_decl_after_saving)\n+    lang_hooks.update_decl_after_saving (fn, id.decl_map);\n+\n+  /* Clean up.  */\n+  splay_tree_delete (id.decl_map);\n+  return body;\n+}\n+\n /* Apply FUNC to all the sub-trees of TP in a pre-order traversal.\n    FUNC is called with the DATA and the address of each sub-tree.  If\n    FUNC returns a non-NULL value, the traversal is aborted, and the"}, {"sha": "03a2b0a5ddb6596fd832ec9141799d924a5a4491", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=18c6ada9b2ee27a40db256f4c32779fc25872050", "patch": "@@ -30,6 +30,7 @@ tree walk_tree (tree*, walk_tree_fn, void*, void*);\n tree walk_tree_without_duplicates (tree*, walk_tree_fn, void*);\n tree copy_tree_r (tree*, int*, void*);\n void clone_body (tree, tree, void*);\n+tree save_body (tree, tree *);\n void remap_save_expr (tree*, void*, tree, int*);\n \n /* 0 if we should not perform inlining."}, {"sha": "f946593dc337b5c71ec6d8ede26f8075b4417728", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 61, "deletions": 3, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18c6ada9b2ee27a40db256f4c32779fc25872050/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=18c6ada9b2ee27a40db256f4c32779fc25872050", "patch": "@@ -96,6 +96,7 @@ void\n tree_rest_of_compilation (tree fndecl, bool nested_p)\n {\n   location_t saved_loc;\n+  struct cgraph_node *node, *saved_node = NULL;\n \n   timevar_push (TV_EXPAND);\n \n@@ -118,6 +119,39 @@ tree_rest_of_compilation (tree fndecl, bool nested_p)\n   immediate_size_expand = 0;\n   cfun->x_dont_save_pending_sizes_p = 1;\n \n+  node = cgraph_node (fndecl);\n+\n+  /* We might need the body of this function so that we can expand\n+     it inline somewhere else.  This means not lowering some constructs\n+     such as exception handling.  */\n+  if (cgraph_preserve_function_body_p (fndecl))\n+    {\n+      if (!flag_unit_at_a_time)\n+\t{\n+\t  struct cgraph_edge *e;\n+\n+\t  saved_node = cgraph_clone_node (node);\n+\t  for (e = saved_node->callees; e; e = e->next_callee)\n+\t    if (!e->inline_failed)\n+\t      cgraph_clone_inlined_nodes (e, true);\n+\t}\n+      cfun->saved_tree = save_body (fndecl, &cfun->saved_args);\n+    }\n+\n+  if (flag_inline_trees)\n+    {\n+      struct cgraph_edge *e;\n+      for (e = node->callees; e; e = e->next_callee)\n+\tif (!e->inline_failed || warn_inline)\n+\t  break;\n+      if (e)\n+\t{\n+\t  timevar_push (TV_INTEGRATION);\n+\t  optimize_inline_calls (fndecl);\n+\t  timevar_pop (TV_INTEGRATION);\n+\t}\n+    }\n+\n   /* If the function has a variably modified type, there may be\n      SAVE_EXPRs in the parameter types.  Their context must be set to\n      refer to this function; they cannot be expanded in the containing\n@@ -167,6 +201,7 @@ tree_rest_of_compilation (tree fndecl, bool nested_p)\n   /* Run the optimizers and output the assembler code for this function.  */\n   rest_of_compilation (fndecl);\n \n+\n   /* Undo the GC context switch.  */\n   if (nested_p)\n     ggc_pop_context ();\n@@ -205,11 +240,31 @@ tree_rest_of_compilation (tree fndecl, bool nested_p)\n   walk_tree_without_duplicates (&DECL_SAVED_TREE (fndecl),\n \t\t\t\tclear_decl_rtl,\n \t\t\t\tfndecl);\n-  if (!cgraph_function_possibly_inlined_p (fndecl))\n+  /* Restore original body if still needed.  */\n+  if (cfun->saved_tree)\n+    {\n+      DECL_SAVED_TREE (fndecl) = cfun->saved_tree;\n+      DECL_ARGUMENTS (fndecl) = cfun->saved_args;\n+\n+      /* When not in unit-at-a-time mode, we must preserve out of line copy\n+\t representing node before inlining.  Restore original outgoing edges\n+\t using clone we created earlier.  */\n+      if (!flag_unit_at_a_time)\n+\t{\n+\t  struct cgraph_edge *e;\n+\t  while (node->callees)\n+\t    cgraph_remove_edge (node->callees);\n+\t  node->callees = saved_node->callees;\n+\t  saved_node->callees = NULL;\n+\t  for (e = saved_node->callees; e; e = e->next_callee)\n+\t    e->caller = node;\n+\t  cgraph_remove_node (saved_node);\n+\t}\n+    }\n+  else\n     {\n       DECL_SAVED_TREE (fndecl) = NULL;\n-      if (DECL_STRUCT_FUNCTION (fndecl) == 0\n-\t  && !cgraph_node (fndecl)->origin)\n+      if (cgraph_node (fndecl)->origin)\n \t{\n \t  /* Stop pointing to the local nodes about to be freed.\n \t     But DECL_INITIAL must remain nonzero so we know this\n@@ -220,6 +275,9 @@ tree_rest_of_compilation (tree fndecl, bool nested_p)\n \t    DECL_INITIAL (fndecl) = error_mark_node;\n \t}\n     }\n+  free_after_compilation (cfun);\n+  cfun = 0;\n+  DECL_STRUCT_FUNCTION (fndecl) = 0;\n \n   input_location = saved_loc;\n "}]}