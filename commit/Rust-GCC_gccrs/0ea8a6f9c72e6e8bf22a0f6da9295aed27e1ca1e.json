{"sha": "0ea8a6f9c72e6e8bf22a0f6da9295aed27e1ca1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVhOGE2ZjljNzJlNmU4YmYyMmEwZjZkYTkyOTVhZWQyN2UxY2ExZQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2013-04-10T21:03:44Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2013-04-10T21:03:44Z"}, "message": "sparc.c: Include tree-pass.h.\n\n\n\t* config/sparc/sparc.c: Include tree-pass.h.\n\t(TARGET_MACHINE_DEPENDENT_REORG): Do not redefine.\n\t(sparc_reorg): Rename to sparc_do_work_around_errata.  Move to\n\thead of file.  Change return type.  Split off gate function.\n\t(sparc_gate_work_around_errata): New function.\n\t(pass_work_around_errata): New pass definition.\n\t(insert_pass_work_around_errata) New pass insert definition to\n\tinsert pass_work_around_errata just after delayed-branch scheduling.\n\t(sparc_option_override): Insert the pass.\n\t* config/sparc/t-sparc (sparc.o): Add TREE_PASS_H dependence.\n\nFrom-SVN: r197681", "tree": {"sha": "5efa286d17ee6e5beac5e34598b734df491b8fb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5efa286d17ee6e5beac5e34598b734df491b8fb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ea8a6f9c72e6e8bf22a0f6da9295aed27e1ca1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ea8a6f9c72e6e8bf22a0f6da9295aed27e1ca1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ea8a6f9c72e6e8bf22a0f6da9295aed27e1ca1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ea8a6f9c72e6e8bf22a0f6da9295aed27e1ca1e/comments", "author": null, "committer": null, "parents": [{"sha": "89deeb3b7e8a6990159acb095f950fad936614f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89deeb3b7e8a6990159acb095f950fad936614f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89deeb3b7e8a6990159acb095f950fad936614f4"}], "stats": {"total": 258, "additions": 152, "deletions": 106}, "files": [{"sha": "927a9c0f318403752ef018375c6b39499c626e08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ea8a6f9c72e6e8bf22a0f6da9295aed27e1ca1e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ea8a6f9c72e6e8bf22a0f6da9295aed27e1ca1e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ea8a6f9c72e6e8bf22a0f6da9295aed27e1ca1e", "patch": "@@ -1,3 +1,16 @@\n+2013-04-10  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* config/sparc/sparc.c: Include tree-pass.h.\n+\t(TARGET_MACHINE_DEPENDENT_REORG): Do not redefine.\n+\t(sparc_reorg): Rename to sparc_do_work_around_errata.  Move to\n+\thead of file.  Change return type.  Split off gate function.\n+\t(sparc_gate_work_around_errata): New function.\n+\t(pass_work_around_errata): New pass definition.\n+\t(insert_pass_work_around_errata) New pass insert definition to\n+\tinsert pass_work_around_errata just after delayed-branch scheduling.\n+\t(sparc_option_override): Insert the pass.\n+\t* config/sparc/t-sparc (sparc.o): Add TREE_PASS_H dependence.\n+\n 2013-04-10  David S. Miller  <davem@davemloft.net>\n \n \t* config/sparc/sparc.h (ASM_CPU_SPEC): Pass -Av8 if -mcpu=supersparc"}, {"sha": "56b95fe9cffc602b8a651fdcaec7c00396e62ee4", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 138, "deletions": 105, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ea8a6f9c72e6e8bf22a0f6da9295aed27e1ca1e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ea8a6f9c72e6e8bf22a0f6da9295aed27e1ca1e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=0ea8a6f9c72e6e8bf22a0f6da9295aed27e1ca1e", "patch": "@@ -52,6 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"df.h\"\n #include \"opts.h\"\n+#include \"tree-pass.h\"\n \n /* Processor costs */\n \n@@ -538,7 +539,6 @@ static void sparc_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t   HOST_WIDE_INT, tree);\n static bool sparc_can_output_mi_thunk (const_tree, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT, const_tree);\n-static void sparc_reorg (void);\n static struct machine_function * sparc_init_machine_status (void);\n static bool sparc_cannot_force_const_mem (enum machine_mode, rtx);\n static rtx sparc_tls_get_addr (void);\n@@ -681,9 +681,6 @@ char sparc_hard_reg_printed[8];\n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n #define TARGET_ASM_CAN_OUTPUT_MI_THUNK sparc_can_output_mi_thunk\n \n-#undef TARGET_MACHINE_DEPENDENT_REORG\n-#define TARGET_MACHINE_DEPENDENT_REORG sparc_reorg\n-\n #undef TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS sparc_rtx_costs\n #undef TARGET_ADDRESS_COST\n@@ -808,6 +805,136 @@ char sparc_hard_reg_printed[8];\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \n+/* We use a machine specific pass to enable workarounds for errata.\n+   We need to have the (essentially) final form of the insn stream in order\n+   to properly detect the various hazards.  Therefore, this machine specific\n+   pass runs as late as possible.  The pass is inserted in the pass pipeline\n+   at the end of sparc_options_override.  */\n+\n+static bool\n+sparc_gate_work_around_errata (void)\n+{\n+  /* The only erratum we handle for now is that of the AT697F processor.  */\n+  return sparc_fix_at697f != 0;\n+}\n+\n+static unsigned int\n+sparc_do_work_around_errata (void)\n+{\n+  rtx insn, next;\n+\n+  /* Now look for specific patterns in the insn stream.  */\n+  for (insn = get_insns (); insn; insn = next)\n+    {\n+      bool insert_nop = false;\n+      rtx set;\n+\n+      /* Look for a single-word load into an odd-numbered FP register.  */\n+      if (NONJUMP_INSN_P (insn)\n+\t  && (set = single_set (insn)) != NULL_RTX\n+\t  && GET_MODE_SIZE (GET_MODE (SET_SRC (set))) == 4\n+\t  && MEM_P (SET_SRC (set))\n+\t  && REG_P (SET_DEST (set))\n+\t  && REGNO (SET_DEST (set)) > 31\n+\t  && REGNO (SET_DEST (set)) % 2 != 0)\n+\t{\n+\t  /* The wrong dependency is on the enclosing double register.  */\n+\t  unsigned int x = REGNO (SET_DEST (set)) - 1;\n+\t  unsigned int src1, src2, dest;\n+\t  int code;\n+\n+\t  /* If the insn has a delay slot, then it cannot be problematic.  */\n+\t  next = next_active_insn (insn);\n+\t  if (NONJUMP_INSN_P (next) && GET_CODE (PATTERN (next)) == SEQUENCE)\n+\t    code = -1;\n+\t  else\n+\t    {\n+\t      extract_insn (next);\n+\t      code = INSN_CODE (next);\n+\t    }\n+\n+\t  switch (code)\n+\t    {\n+\t    case CODE_FOR_adddf3:\n+\t    case CODE_FOR_subdf3:\n+\t    case CODE_FOR_muldf3:\n+\t    case CODE_FOR_divdf3:\n+\t      dest = REGNO (recog_data.operand[0]);\n+\t      src1 = REGNO (recog_data.operand[1]);\n+\t      src2 = REGNO (recog_data.operand[2]);\n+\t      if (src1 != src2)\n+\t\t{\n+\t\t  /* Case [1-4]:\n+\t\t\t\t ld [address], %fx+1\n+\t\t\t\t FPOPd %f{x,y}, %f{y,x}, %f{x,y}  */\n+\t\t  if ((src1 == x || src2 == x)\n+\t\t      && (dest == src1 || dest == src2))\n+\t\t    insert_nop = true;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Case 5:\n+\t\t\t     ld [address], %fx+1\n+\t\t\t     FPOPd %fx, %fx, %fx  */\n+\t\t  if (src1 == x\n+\t\t      && dest == src1\n+\t\t      && (code == CODE_FOR_adddf3 || code == CODE_FOR_muldf3))\n+\t\t    insert_nop = true;\n+\t\t}\n+\t      break;\n+\n+\t    case CODE_FOR_sqrtdf2:\n+\t      dest = REGNO (recog_data.operand[0]);\n+\t      src1 = REGNO (recog_data.operand[1]);\n+\t      /* Case 6:\n+\t\t\t ld [address], %fx+1\n+\t\t\t fsqrtd %fx, %fx  */\n+\t      if (src1 == x && dest == src1)\n+\t\tinsert_nop = true;\n+\t      break;\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+      else\n+\tnext = NEXT_INSN (insn);\n+\n+      if (insert_nop)\n+\temit_insn_after (gen_nop (), insn);\n+    }\n+  return 0;\n+}\n+\n+struct rtl_opt_pass pass_work_around_errata =\n+{\n+ {\n+  RTL_PASS,\n+  \"errata\",\t\t\t\t/* name */\n+  OPTGROUP_NONE,\t\t\t/* optinfo_flags */\n+  sparc_gate_work_around_errata,\t/* gate */\n+  sparc_do_work_around_errata,\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_MACH_DEP,\t\t\t\t/* tv_id */\n+  0,\t\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_verify_rtl_sharing,\t\t/* todo_flags_finish */\n+ }\n+};\n+\n+struct register_pass_info insert_pass_work_around_errata =\n+{\n+  &pass_work_around_errata.pass,\t/* pass */\n+  \"dbr\",\t\t\t\t/* reference_pass_name */\n+  1,\t\t\t\t\t/* ref_pass_instance_number */\n+  PASS_POS_INSERT_AFTER\t\t\t/* po_op */\n+};\n+\n+/* Helpers for TARGET_DEBUG_OPTIONS.  */\n static void\n dump_target_flag_bits (const int flags)\n {\n@@ -1245,6 +1372,13 @@ sparc_option_override (void)\n      pessimizes for double floating-point registers.  */\n   if (!global_options_set.x_flag_ira_share_save_slots)\n     flag_ira_share_save_slots = 0;\n+\n+  /* We register a machine specific pass to work around errata, if any.\n+     The pass mut be scheduled as late as possible so that we have the\n+     (essentially) final form of the insn stream to work on.\n+     Registering the pass must be done at start up.  It's convenient to\n+     do it here.  */\n+  register_pass (&insert_pass_work_around_errata);\n }\n \f\n /* Miscellaneous utilities.  */\n@@ -10906,107 +11040,6 @@ sparc_can_output_mi_thunk (const_tree thunk_fndecl ATTRIBUTE_UNUSED,\n   return (vcall_offset >= -32768 || ! fixed_regs[5]);\n }\n \n-/* We use the machine specific reorg pass to enable workarounds for errata.  */\n-\n-static void\n-sparc_reorg (void)\n-{\n-  rtx insn, next;\n-\n-  /* The only erratum we handle for now is that of the AT697F processor.  */\n-  if (!sparc_fix_at697f)\n-    return;\n-\n-  /* We need to have the (essentially) final form of the insn stream in order\n-     to properly detect the various hazards.  Run delay slot scheduling.  */\n-  if (optimize > 0 && flag_delayed_branch)\n-    {\n-      cleanup_barriers ();\n-      dbr_schedule (get_insns ());\n-    }\n-\n-  /* Now look for specific patterns in the insn stream.  */\n-  for (insn = get_insns (); insn; insn = next)\n-    {\n-      bool insert_nop = false;\n-      rtx set;\n-\n-      /* Look for a single-word load into an odd-numbered FP register.  */\n-      if (NONJUMP_INSN_P (insn)\n-\t  && (set = single_set (insn)) != NULL_RTX\n-\t  && GET_MODE_SIZE (GET_MODE (SET_SRC (set))) == 4\n-\t  && MEM_P (SET_SRC (set))\n-\t  && REG_P (SET_DEST (set))\n-\t  && REGNO (SET_DEST (set)) > 31\n-\t  && REGNO (SET_DEST (set)) % 2 != 0)\n-\t{\n-\t  /* The wrong dependency is on the enclosing double register.  */\n-\t  unsigned int x = REGNO (SET_DEST (set)) - 1;\n-\t  unsigned int src1, src2, dest;\n-\t  int code;\n-\n-\t  /* If the insn has a delay slot, then it cannot be problematic.  */\n-\t  next = next_active_insn (insn);\n-\t  if (NONJUMP_INSN_P (next) && GET_CODE (PATTERN (next)) == SEQUENCE)\n-\t    code = -1;\n-\t  else\n-\t    {\n-\t      extract_insn (next);\n-\t      code = INSN_CODE (next);\n-\t    }\n-\n-\t  switch (code)\n-\t    {\n-\t    case CODE_FOR_adddf3:\n-\t    case CODE_FOR_subdf3:\n-\t    case CODE_FOR_muldf3:\n-\t    case CODE_FOR_divdf3:\n-\t      dest = REGNO (recog_data.operand[0]);\n-\t      src1 = REGNO (recog_data.operand[1]);\n-\t      src2 = REGNO (recog_data.operand[2]);\n-\t      if (src1 != src2)\n-\t\t{\n-\t\t  /* Case [1-4]:\n-\t\t\t\t ld [address], %fx+1\n-\t\t\t\t FPOPd %f{x,y}, %f{y,x}, %f{x,y}  */\n-\t\t  if ((src1 == x || src2 == x)\n-\t\t      && (dest == src1 || dest == src2))\n-\t\t    insert_nop = true;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* Case 5:\n-\t\t\t     ld [address], %fx+1\n-\t\t\t     FPOPd %fx, %fx, %fx  */\n-\t\t  if (src1 == x\n-\t\t      && dest == src1\n-\t\t      && (code == CODE_FOR_adddf3 || code == CODE_FOR_muldf3))\n-\t\t    insert_nop = true;\n-\t\t}\n-\t      break;\n-\n-\t    case CODE_FOR_sqrtdf2:\n-\t      dest = REGNO (recog_data.operand[0]);\n-\t      src1 = REGNO (recog_data.operand[1]);\n-\t      /* Case 6:\n-\t\t\t ld [address], %fx+1\n-\t\t\t fsqrtd %fx, %fx  */\n-\t      if (src1 == x && dest == src1)\n-\t\tinsert_nop = true;\n-\t      break;\n-\n-\t    default:\n-\t      break;\n-\t    }\n-\t}\n-      else\n-\tnext = NEXT_INSN (insn);\n-\n-      if (insert_nop)\n-\temit_insn_after (gen_nop (), insn);\n-    }\n-}\n-\n /* How to allocate a 'struct machine_function'.  */\n \n static struct machine_function *"}, {"sha": "664f4a424184d7a3cc34ef0ca6807d1019c6f782", "filename": "gcc/config/sparc/t-sparc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ea8a6f9c72e6e8bf22a0f6da9295aed27e1ca1e/gcc%2Fconfig%2Fsparc%2Ft-sparc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ea8a6f9c72e6e8bf22a0f6da9295aed27e1ca1e/gcc%2Fconfig%2Fsparc%2Ft-sparc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Ft-sparc?ref=0ea8a6f9c72e6e8bf22a0f6da9295aed27e1ca1e", "patch": "@@ -23,7 +23,7 @@ sparc.o: $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   insn-codes.h conditions.h output.h $(INSN_ATTR_H) $(FLAGS_H) \\\n   $(FUNCTION_H) $(EXCEPT_H) $(EXPR_H) $(OPTABS_H) $(RECOG_H) \\\n   $(DIAGNOSTIC_CORE_H) $(GGC_H) $(TM_P_H) debug.h $(TARGET_H) \\\n-  $(TARGET_DEF_H) $(COMMON_TARGET_H) $(GIMPLE_H) \\\n+  $(TARGET_DEF_H) $(COMMON_TARGET_H) $(GIMPLE_H) $(TREE_PASS_H) \\\n   langhooks.h reload.h $(PARAMS_H) $(DF_H) $(OPTS_H) \\\n   gt-sparc.h\n "}]}