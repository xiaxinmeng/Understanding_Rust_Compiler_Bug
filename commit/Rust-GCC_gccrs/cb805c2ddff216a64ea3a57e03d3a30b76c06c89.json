{"sha": "cb805c2ddff216a64ea3a57e03d3a30b76c06c89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I4MDVjMmRkZmYyMTZhNjRlYTNhNTdlMDNkM2EzMGI3NmMwNmM4OQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1999-07-01T01:18:36Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1999-07-01T01:18:36Z"}, "message": "Add support for arm-pe and thumb-pe\n\nFrom-SVN: r27871", "tree": {"sha": "4d8a64c7c1a483849032bb7d9b656f996c94ec39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d8a64c7c1a483849032bb7d9b656f996c94ec39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb805c2ddff216a64ea3a57e03d3a30b76c06c89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb805c2ddff216a64ea3a57e03d3a30b76c06c89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb805c2ddff216a64ea3a57e03d3a30b76c06c89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb805c2ddff216a64ea3a57e03d3a30b76c06c89/comments", "author": null, "committer": null, "parents": [{"sha": "5e13e04f6ab20f5e347c74f4bb3812b42a9db8f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e13e04f6ab20f5e347c74f4bb3812b42a9db8f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e13e04f6ab20f5e347c74f4bb3812b42a9db8f8"}], "stats": {"total": 1396, "additions": 1396, "deletions": 0}, "files": [{"sha": "c9718864f7d0a2df610fa55126e30f9f74e6dd82", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb805c2ddff216a64ea3a57e03d3a30b76c06c89/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb805c2ddff216a64ea3a57e03d3a30b76c06c89/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb805c2ddff216a64ea3a57e03d3a30b76c06c89", "patch": "@@ -1,3 +1,28 @@\n+Wed Jun 30 16:51:41 1999  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* configure.in: Add arm-pe and thumb-pe targets.\n+\t* configure: Regenerate.\n+\n+\t* thumb.c (arm_naked_function_p): New function: Determines if\n+\ta function is naked (has no gcc generated prologue/epilogue).\n+\t(is_called_in_ARM_mode): Return true if the func has the\n+\tinterfacearm attribute.\n+\t(output_return): Do not generate a return for naked functions.\n+\t(thumb_function_prologue): Do not generate a prologue for\n+\tnaked functions.\n+\t(thumb_expand_prologue): Do not generate a prologue for naked\n+\tfunctions. \n+\t(thumb_expand_epilogue): Do not generate an epilogue for naked\n+\tfunctions.\n+\t(arm_valid_machine_decl_attribute): New function, copied from\n+\tarm.c:  Permit naked and interfacearm attributes.\n+\t\n+\t* config/arm/pe.c: New file: Support code for arm-pe target.\n+\t* config/arm/pe.h: New file: Header file for arm-pe target.\n+\t* config/arm/tpe.h: New file: Header file for thumb-pe target.\n+\t* config/arm/t-thumb-pe: New file: Makefile fragment for\n+\tthumb-pe target.\n+\t\n 1999-07-01  Mark Kettenis  <kettenis@gnu.org>\n \n \t* config/i386/gnu.h (CPP_SPEC): Define __PIC__ and __pic__ if"}, {"sha": "60d6c4b104535317d782ec665fdfd3fe0f298443", "filename": "gcc/config/arm/pe.c", "status": "added", "additions": 501, "deletions": 0, "changes": 501, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb805c2ddff216a64ea3a57e03d3a30b76c06c89/gcc%2Fconfig%2Farm%2Fpe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb805c2ddff216a64ea3a57e03d3a30b76c06c89/gcc%2Fconfig%2Farm%2Fpe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpe.c?ref=cb805c2ddff216a64ea3a57e03d3a30b76c06c89", "patch": "@@ -0,0 +1,501 @@\n+/* Routines for GCC for ARM/pe.\n+   Copyright (C) 1995, 1996 Free Software Foundation, Inc.\n+   Contributed by Doug Evans (dje@cygnus.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"output.h\"\n+#include \"flags.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+\n+extern int current_function_anonymous_args;\n+\n+/* ARM/PE specific attribute support.\n+\n+   ARM/PE has three new attributes:\n+   naked - for interrupt functions\n+   dllexport - for exporting a function/variable that will live in a dll\n+   dllimport - for importing a function/variable from a dll\n+\n+   Microsoft allows multiple declspecs in one __declspec, separating\n+   them with spaces.  We do NOT support this.  Instead, use __declspec\n+   multiple times.\n+*/\n+\n+/* Return nonzero if ATTR is a valid attribute for DECL.\n+   ATTRIBUTES are any existing attributes and ARGS are the arguments\n+   supplied with ATTR.  */\n+\n+int\n+arm_pe_valid_machine_decl_attribute (decl, attributes, attr, args)\n+     tree decl;\n+     tree attributes;\n+     tree attr;\n+     tree args;\n+{\n+  if (args != NULL_TREE)\n+    return 0;\n+\n+  if (is_attribute_p (\"dllexport\", attr))\n+    return 1;\n+  if (is_attribute_p (\"dllimport\", attr))\n+    return 1;\n+\n+  return arm_valid_machine_decl_attribute (decl, attr, args);\n+}\n+\n+/* Merge attributes in decls OLD and NEW.\n+\n+   This handles the following situation:\n+\n+   __declspec (dllimport) int foo;\n+   int foo;\n+\n+   The second instance of `foo' nullifies the dllimport.  */\n+\n+tree\n+arm_pe_merge_machine_decl_attributes (old, new)\n+     tree old, new;\n+{\n+  tree a;\n+  int delete_dllimport_p;\n+\n+  old = DECL_MACHINE_ATTRIBUTES (old);\n+  new = DECL_MACHINE_ATTRIBUTES (new);\n+\n+  /* What we need to do here is remove from `old' dllimport if it doesn't\n+     appear in `new'.  dllimport behaves like extern: if a declaration is\n+     marked dllimport and a definition appears later, then the object\n+     is not dllimport'd.  */\n+\n+  if (lookup_attribute (\"dllimport\", old) != NULL_TREE\n+      && lookup_attribute (\"dllimport\", new) == NULL_TREE)\n+    delete_dllimport_p = 1;\n+  else\n+    delete_dllimport_p = 0;\n+\n+  a = merge_attributes (old, new);\n+\n+  if (delete_dllimport_p)\n+    {\n+      tree prev,t;\n+\n+      /* Scan the list for dllimport and delete it.  */\n+      for (prev = NULL_TREE, t = a; t; prev = t, t = TREE_CHAIN (t))\n+\t{\n+\t  if (is_attribute_p (\"dllimport\", TREE_PURPOSE (t)))\n+\t    {\n+\t      if (prev == NULL_TREE)\n+\t\ta = TREE_CHAIN (a);\n+\t      else\n+\t\tTREE_CHAIN (prev) = TREE_CHAIN (t);\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  return a;\n+}\n+\f\n+/* Check a type that has a virtual table, and see if any virtual methods are\n+   marked for import or export, and if so, arrange for the vtable to\n+   be imported or exported.  */\n+\n+static int\n+arm_check_vtable_importexport (type)\n+     tree type;\n+{\n+  tree methods = TYPE_METHODS (type);\n+  tree fndecl;\n+\n+  if (TREE_CODE (methods) == FUNCTION_DECL)\n+    fndecl = methods;\n+  else if (TREE_VEC_ELT (methods, 0) != NULL_TREE)\n+    fndecl = TREE_VEC_ELT (methods, 0);\n+  else\n+    fndecl = TREE_VEC_ELT (methods, 1);\n+\n+  while (fndecl)\n+    {\n+      if (DECL_VIRTUAL_P (fndecl) || DECL_VINDEX (fndecl) != NULL_TREE)\n+\t{\n+\t  tree exp = lookup_attribute (\"dllimport\",\n+\t\t\t\t       DECL_MACHINE_ATTRIBUTES (fndecl));\n+\t  if (exp == 0)\n+\t    exp = lookup_attribute (\"dllexport\",\n+\t\t\t\t    DECL_MACHINE_ATTRIBUTES (fndecl));\n+\t  if (exp)\n+\t    return 1;\n+\t}\n+\n+      fndecl = TREE_CHAIN (fndecl);\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return non-zero if DECL is a dllexport'd object.  */\n+\n+tree current_class_type; /* FIXME */\n+\n+int\n+arm_dllexport_p (decl)\n+     tree decl;\n+{\n+  tree exp;\n+\n+  if (TREE_CODE (decl) != VAR_DECL\n+      && TREE_CODE (decl) != FUNCTION_DECL)\n+    return 0;\n+  exp = lookup_attribute (\"dllexport\", DECL_MACHINE_ATTRIBUTES (decl));\n+  if (exp)\n+    return 1;\n+\n+#if 0 /* This was a hack to get vtable's exported or imported since only one\n+\t copy of them is ever output.  Disabled pending better solution.  */\n+  /* For C++, the vtables might have to be marked.  */\n+  if (TREE_CODE (decl) == VAR_DECL && DECL_VIRTUAL_P (decl))\n+    {\n+      if (TREE_PUBLIC (decl)\n+\t  && DECL_EXTERNAL (decl) == 0\n+\t  && (DECL_CONTEXT (decl)\n+\t      ? arm_check_vtable_importexport (DECL_CONTEXT (decl))\n+\t      : current_class_type\n+\t      ? arm_check_vtable_importexport (current_class_type)\n+\t      : 0)\n+\t  )\n+\treturn 1;\n+    }\n+#endif\n+\n+  return 0;\n+}\n+\n+/* Return non-zero if DECL is a dllimport'd object.  */\n+\n+int\n+arm_dllimport_p (decl)\n+     tree decl;\n+{\n+  tree imp;\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && TARGET_NOP_FUN_DLLIMPORT)\n+    return 0;\n+\n+  if (TREE_CODE (decl) != VAR_DECL\n+      && TREE_CODE (decl) != FUNCTION_DECL)\n+    return 0;\n+  imp = lookup_attribute (\"dllimport\", DECL_MACHINE_ATTRIBUTES (decl));\n+  if (imp)\n+    return 1;\n+\n+#if 0 /* This was a hack to get vtable's exported or imported since only one\n+\t copy of them is ever output.  Disabled pending better solution.  */\n+  /* For C++, the vtables might have to be marked.  */\n+  if (TREE_CODE (decl) == VAR_DECL && DECL_VIRTUAL_P (decl))\n+    {\n+      if (TREE_PUBLIC (decl)\n+\t  && DECL_EXTERNAL (decl)\n+\t  && (DECL_CONTEXT (decl)\n+\t      ? arm_check_vtable_importexport (DECL_CONTEXT (decl))\n+\t      : current_class_type\n+\t      ? arm_check_vtable_importexport (current_class_type)\n+\t      : 0)\n+\t  )\n+\treturn 1;\n+    }\n+#endif\n+\n+  return 0;\n+}\n+\n+/* Return non-zero if SYMBOL is marked as being dllexport'd.  */\n+\n+int\n+arm_dllexport_name_p (symbol)\n+     char * symbol;\n+{\n+  return symbol[0] == '@' && symbol[1] == 'e' && symbol[2] == '.';\n+}\n+\n+/* Return non-zero if SYMBOL is marked as being dllimport'd.  */\n+\n+int\n+arm_dllimport_name_p (symbol)\n+     char * symbol;\n+{\n+  return symbol[0] == '@' && symbol[1] == 'i' && symbol[2] == '.';\n+}\n+\n+/* Mark a DECL as being dllexport'd.\n+   Note that we override the previous setting (eg: dllimport).  */\n+\n+void\n+arm_mark_dllexport (decl)\n+     tree decl;\n+{\n+  char * oldname;\n+  char * newname;\n+  rtx rtlname;\n+  tree idp;\n+\n+  rtlname = XEXP (DECL_RTL (decl), 0);\n+  if (GET_CODE (rtlname) == SYMBOL_REF)\n+    oldname = XSTR (rtlname, 0);\n+  else if (GET_CODE (rtlname) == MEM\n+\t   && GET_CODE (XEXP (rtlname, 0)) == SYMBOL_REF)\n+    oldname = XSTR (XEXP (rtlname, 0), 0);\n+  else\n+    abort ();\n+  if (arm_dllimport_name_p (oldname))\n+    oldname += 9;\n+  else if (arm_dllexport_name_p (oldname))\n+    return; /* already done */\n+\n+  newname = alloca (strlen (oldname) + 4);\n+  sprintf (newname, \"@e.%s\", oldname);\n+\n+  /* We pass newname through get_identifier to ensure it has a unique\n+     address.  RTL processing can sometimes peek inside the symbol ref\n+     and compare the string's addresses to see if two symbols are\n+     identical.  */\n+  /* ??? At least I think that's why we do this.  */\n+  idp = get_identifier (newname);\n+\n+  XEXP (DECL_RTL (decl), 0) =\n+    gen_rtx (SYMBOL_REF, Pmode, IDENTIFIER_POINTER (idp));\n+}\n+\n+/* Mark a DECL as being dllimport'd.  */\n+\n+void\n+arm_mark_dllimport (decl)\n+     tree decl;\n+{\n+  char * oldname;\n+  char * newname;\n+  tree idp;\n+  rtx rtlname, newrtl;\n+\n+  rtlname = XEXP (DECL_RTL (decl), 0);\n+  \n+  if (GET_CODE (rtlname) == SYMBOL_REF)\n+    oldname = XSTR (rtlname, 0);\n+  else if (GET_CODE (rtlname) == MEM\n+\t   && GET_CODE (XEXP (rtlname, 0)) == SYMBOL_REF)\n+    oldname = XSTR (XEXP (rtlname, 0), 0);\n+  else\n+    abort ();\n+  \n+  if (arm_dllexport_name_p (oldname))\n+    abort (); /* this shouldn't happen */\n+  else if (arm_dllimport_name_p (oldname))\n+    return; /* already done */\n+\n+  /* ??? One can well ask why we're making these checks here,\n+     and that would be a good question.  */\n+\n+  /* Imported variables can't be initialized.  */\n+  if (TREE_CODE (decl) == VAR_DECL\n+      && !DECL_VIRTUAL_P (decl)\n+      && DECL_INITIAL (decl))\n+    {\n+      error_with_decl (decl, \"initialized variable `%s' is marked dllimport\");\n+      return;\n+    }\n+  /* Nor can they be static.  */\n+  if (TREE_CODE (decl) == VAR_DECL\n+      /* ??? Is this test for vtables needed?  */\n+      && !DECL_VIRTUAL_P (decl)\n+      && 0 /*???*/)\n+    {\n+      error_with_decl (decl, \"static variable `%s' is marked dllimport\");\n+      return;\n+    }\n+\n+  /* `extern' needn't be specified with dllimport.\n+     Specify `extern' now and hope for the best.  Sigh.  */\n+  if (TREE_CODE (decl) == VAR_DECL\n+      /* ??? Is this test for vtables needed?  */\n+      && !DECL_VIRTUAL_P (decl))\n+    {\n+      DECL_EXTERNAL (decl) = 1;\n+      TREE_PUBLIC (decl) = 1;\n+    }\n+\n+  newname = alloca (strlen (oldname) + 11);\n+  sprintf (newname, \"@i.__imp_%s\", oldname);\n+\n+  /* We pass newname through get_identifier to ensure it has a unique\n+     address.  RTL processing can sometimes peek inside the symbol ref\n+     and compare the string's addresses to see if two symbols are\n+     identical.  */\n+  /* ??? At least I think that's why we do this.  */\n+  idp = get_identifier (newname);\n+\n+  newrtl = gen_rtx (MEM, Pmode,\n+\t\t    gen_rtx (SYMBOL_REF, Pmode,\n+\t\t\t     IDENTIFIER_POINTER (idp)));\n+  XEXP (DECL_RTL (decl), 0) = newrtl;\n+}\n+\n+/* Cover function to implement ENCODE_SECTION_INFO.  */\n+\n+void\n+arm_pe_encode_section_info (decl)\n+     tree decl;\n+{\n+  /* This bit is copied from arm.h.  */\n+  if (optimize > 0 && TREE_CONSTANT (decl)\n+      && (!flag_writable_strings || TREE_CODE (decl) != STRING_CST))\n+    {\n+      rtx rtl = (TREE_CODE_CLASS (TREE_CODE (decl)) != 'd'\n+                 ? TREE_CST_RTL (decl) : DECL_RTL (decl));\n+      SYMBOL_REF_FLAG (XEXP (rtl, 0)) = 1;\n+    }\n+\n+  /* Mark the decl so we can tell from the rtl whether the object is\n+     dllexport'd or dllimport'd.  */\n+  if (arm_dllexport_p (decl))\n+    arm_mark_dllexport (decl);\n+  else if (arm_dllimport_p (decl))\n+    arm_mark_dllimport (decl);\n+  /* It might be that DECL has already been marked as dllimport, but a\n+     subsequent definition nullified that.  The attribute is gone but\n+     DECL_RTL still has @i.__imp_foo.  We need to remove that.  */\n+  else if ((TREE_CODE (decl) == FUNCTION_DECL\n+\t    || TREE_CODE (decl) == VAR_DECL)\n+\t   && DECL_RTL (decl) != NULL_RTX\n+\t   && GET_CODE (DECL_RTL (decl)) == MEM\n+\t   && GET_CODE (XEXP (DECL_RTL (decl), 0)) == MEM\n+\t   && GET_CODE (XEXP (XEXP (DECL_RTL (decl), 0), 0)) == SYMBOL_REF\n+\t   && arm_dllimport_name_p (XSTR (XEXP (XEXP (DECL_RTL (decl), 0), 0), 0)))\n+    {\n+      char *oldname = XSTR (XEXP (XEXP (DECL_RTL (decl), 0), 0), 0);\n+      tree idp = get_identifier (oldname + 9);\n+      rtx newrtl = gen_rtx (SYMBOL_REF, Pmode, IDENTIFIER_POINTER (idp));\n+\n+      XEXP (DECL_RTL (decl), 0) = newrtl;\n+\n+      /* We previously set TREE_PUBLIC and DECL_EXTERNAL.\n+\t ??? We leave these alone for now.  */\n+    }\n+}\n+\n+/* Cover function for UNIQUE_SECTION.  */\n+\n+void\n+arm_pe_unique_section (decl, reloc)\n+     tree decl;\n+     int reloc;\n+{\n+  int len;\n+  char * name;\n+  char * string;\n+  char * prefix;\n+\n+  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+  /* Strip off any encoding in fnname.  */\n+  STRIP_NAME_ENCODING (name, name);\n+\n+  /* The object is put in, for example, section .text$foo.\n+     The linker will then ultimately place them in .text\n+     (everything from the $ on is stripped).  */\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    prefix = \".text$\";\n+  else if (DECL_READONLY_SECTION (decl, reloc))\n+    prefix = \".rdata$\";\n+  else\n+    prefix = \".data$\";\n+  len = strlen (name) + strlen (prefix);\n+  string = alloca (len + 1);\n+  sprintf (string, \"%s%s\", prefix, name);\n+\n+  DECL_SECTION_NAME (decl) = build_string (len, string);\n+}\n+\f\n+/* This is to better conform to the ARM PCS.\n+   Richard Earnshaw hasn't put this into FSF sources yet so it's here.  */\n+\n+int\n+arm_pe_return_in_memory (type)\n+     tree type;\n+{\n+  if (TREE_CODE (type) == RECORD_TYPE)\n+    {\n+      tree field;\n+      int num_fields = 0;\n+\n+      /* For a record containing just a single element, we can be a little\n+\t less restrictive.  */\n+      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t{\n+\t  if (TREE_CODE (field) == FIELD_DECL && ! TREE_STATIC (field))\n+\t    {\n+\t      if ((AGGREGATE_TYPE_P (TREE_TYPE (field))\n+\t\t   && RETURN_IN_MEMORY (TREE_TYPE (field)))\n+\t\t  || FLOAT_TYPE_P (TREE_TYPE (field)))\n+\t\treturn 1;\n+\t      num_fields++;\n+\t    }\n+\t}\n+\n+      if (num_fields == 1)\n+\treturn 0;\n+\t    \n+      /* For a struct, we can return in a register if every element was a\n+\t bit-field and it all fits in one word.  */\n+      for (field = TYPE_FIELDS (type); field;  field = TREE_CHAIN (field))\n+\t{\n+\t  if (TREE_CODE (field) == FIELD_DECL\n+\t      && ! TREE_STATIC (field)\n+\t      && (! DECL_BIT_FIELD_TYPE (field)\n+\t\t  || (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field))\n+\t\t      + TREE_INT_CST_LOW (DECL_SIZE (field))) > 32))\n+\t    return 1;\n+\t}\n+      return 0;\n+    }\n+  else if (TREE_CODE (type) == UNION_TYPE\n+\t   || TREE_CODE (type) == QUAL_UNION_TYPE)\n+    {\n+      tree field;\n+\n+      /* Unions can be returned in registers if every element is\n+\t integral, or can be returned in an integer register.  */\n+      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t{\n+\t  if (TREE_CODE (field) == FIELD_DECL\n+\t      && ! TREE_STATIC (field)\n+\t      && ((AGGREGATE_TYPE_P (TREE_TYPE (field))\n+\t\t   && RETURN_IN_MEMORY (TREE_TYPE (field)))\n+\t\t  || FLOAT_TYPE_P (TREE_TYPE (field))))\n+\t    return 1;\n+\t}\n+      return 0;\n+    }\n+  /* XXX Not sure what should be done for other aggregates, so put them in\n+     memory. */\n+  return 1;\n+}"}, {"sha": "18281cd1d3851a084e75148e56b937380b8a904a", "filename": "gcc/config/arm/pe.h", "status": "added", "additions": 296, "deletions": 0, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb805c2ddff216a64ea3a57e03d3a30b76c06c89/gcc%2Fconfig%2Farm%2Fpe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb805c2ddff216a64ea3a57e03d3a30b76c06c89/gcc%2Fconfig%2Farm%2Fpe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpe.h?ref=cb805c2ddff216a64ea3a57e03d3a30b76c06c89", "patch": "@@ -0,0 +1,296 @@\n+/* Definitions of target machine for GNU compiler, for ARM with PE obj format.\n+   Copyright (C) 1995, 1996, 1999 Free Software Foundation, Inc.\n+   Contributed by Doug Evans (dje@cygnus.com).\n+   \n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"arm/coff.h\"\n+\n+#undef  USER_LABEL_PREFIX\n+#define USER_LABEL_PREFIX \"_\"\n+\n+\f\n+/* Run-time Target Specification.  */\n+#undef  TARGET_VERSION\n+#define TARGET_VERSION fputs (\" (ARM/pe)\", stderr)\n+\n+/* Support the __declspec keyword by turning them into attributes.\n+   We currently only support: naked, dllimport, and dllexport.\n+   Note that the current way we do this may result in a collision with\n+   predefined attributes later on.  This can be solved by using one attribute,\n+   say __declspec__, and passing args to it.  The problem with that approach\n+   is that args are not accumulated: each new appearance would clobber any\n+   existing args.  */\n+#undef  CPP_PREDEFINES\n+#define CPP_PREDEFINES \"\\\n+-Darm -D__pe__ -Acpu(arm) -Amachine(arm) \\\n+-D__declspec(x)=__attribute__((x)) \\\n+\"\n+\n+/* Experimental addition for pr 7885.\n+   Ignore dllimport for functions.  */\n+#define TARGET_NOP_FUN_DLLIMPORT (target_flags & 0x20000)\n+\n+#undef  SUBTARGET_SWITCHES\n+#define SUBTARGET_SWITCHES \\\n+{ \"nop-fun-dllimport\",\t\t 0x20000, \"Ignore dllimport attribute for functions\" }, \\\n+{ \"no-nop-fun-dllimport\",\t-0x20000, \"\" },\n+\n+#undef  TARGET_DEFAULT\n+#define TARGET_DEFAULT (ARM_FLAG_SOFT_FLOAT + 0x20000)\n+\f\n+#undef  WCHAR_TYPE\n+#define WCHAR_TYPE \"short unsigned int\"\n+#undef  WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE 16\n+\n+/* Same as arm.h except r10 is call-saved, not fixed.  */\n+#undef  FIXED_REGISTERS\n+#define FIXED_REGISTERS \\\n+{\t\t\t\\\n+  0,0,0,0,0,0,0,0,\t\\\n+  0,0,0,1,0,1,0,1,\t\\\n+  0,0,0,0,0,0,0,0,\t\\\n+  1,1,1\t\t\t\\\n+}\n+\n+/* Same as arm.h except r10 is call-saved, not fixed.  */\n+#undef  CALL_USED_REGISTERS\n+#define CALL_USED_REGISTERS \\\n+{\t\t\t\\\n+  1,1,1,1,0,0,0,0,\t\\\n+  0,0,0,1,1,1,1,1,\t\\\n+  1,1,1,1,0,0,0,0,\t\\\n+  1,1,1\t\t\t\\\n+}\n+\n+/* This is to better conform to the ARM PCS.\n+   Richard Earnshaw hasn't put this into FSF sources yet so it's here.  */\n+#undef  RETURN_IN_MEMORY\n+#define RETURN_IN_MEMORY(TYPE) \t\t\t\t\t\t\\\n+  ((TYPE_MODE ((TYPE)) == BLKmode && ! TYPE_NO_FORCE_BLK (TYPE))\t\\\n+   || (AGGREGATE_TYPE_P ((TYPE)) && arm_pe_return_in_memory ((TYPE))))\n+\f\n+/* A C expression whose value is nonzero if IDENTIFIER with arguments ARGS\n+   is a valid machine specific attribute for DECL.\n+   The attributes in ATTRIBUTES have previously been assigned to DECL.  */\n+extern int arm_pe_valid_machine_decl_attribute ();\n+#undef  VALID_MACHINE_DECL_ATTRIBUTE\n+#define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \\\n+arm_pe_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n+\n+#if 0 /* Needed when we tried type attributes.  */\n+/* A C expression whose value is zero if the attributes on\n+   TYPE1 and TYPE2 are incompatible, one if they are compatible,\n+   and two if they are nearly compatible (which causes a warning to be\n+   generated).  */\n+extern int arm_pe_comp_type_attributes ();\n+#define COMP_TYPE_ATTRIBUTES(TYPE1, TYPE2) \\\n+arm_pe_comp_type_attributes ((TYPE1), (TYPE2))\n+#endif\n+\n+extern union tree_node *arm_pe_merge_machine_decl_attributes ();\n+#define MERGE_MACHINE_DECL_ATTRIBUTES(OLD, NEW) \\\n+arm_pe_merge_machine_decl_attributes ((OLD), (NEW))\n+\n+/* In addition to the stuff done in arm.h, we must mark dll symbols specially.\n+   Definitions of dllexport'd objects install some info in the .drectve\n+   section.  References to dllimport'd objects are fetched indirectly via\n+   __imp_.  If both are declared, dllexport overrides.\n+   This is also needed to implement one-only vtables: they go into their own\n+   section and we need to set DECL_SECTION_NAME so we do that here.\n+   Note that we can be called twice on the same decl.  */\n+extern void arm_pe_encode_section_info ();\n+#undef  ENCODE_SECTION_INFO\n+#define ENCODE_SECTION_INFO(DECL) \\\n+arm_pe_encode_section_info (DECL)\n+\n+/* Used to implement dllexport overriding dllimport semantics.  It's also used\n+   to handle vtables - the first pass won't do anything because\n+   DECL_CONTEXT (DECL) will be 0 so arm_dll{ex,im}port_p will return 0.\n+   It's also used to handle dllimport override semantics.  */\n+#if 0\n+#define REDO_SECTION_INFO_P(DECL) \\\n+((DECL_MACHINE_ATTRIBUTES (DECL) != NULL_TREE) \\\n+ || (TREE_CODE (DECL) == VAR_DECL && DECL_VIRTUAL_P (DECL)))\n+#else\n+#define REDO_SECTION_INFO_P(DECL) 1\n+#endif\n+\n+/* Utility used only in this file.  */\n+#define ARM_STRIP_NAME_ENCODING(SYM_NAME) \\\n+((SYM_NAME) + ((SYM_NAME)[0] == '@' ? 3 : 0))\n+\n+/* Strip any text from SYM_NAME added by ENCODE_SECTION_INFO and store\n+   the result in VAR.  */\n+#undef  STRIP_NAME_ENCODING\n+#define STRIP_NAME_ENCODING(VAR, SYM_NAME) \\\n+(VAR) = ARM_STRIP_NAME_ENCODING (SYM_NAME)\n+\n+/* Define this macro if in some cases global symbols from one translation\n+   unit may not be bound to undefined symbols in another translation unit\n+   without user intervention.  For instance, under Microsoft Windows\n+   symbols must be explicitly imported from shared libraries (DLLs).  */\n+#define MULTIPLE_SYMBOL_SPACES\n+\n+#define UNIQUE_SECTION_P(DECL) DECL_ONE_ONLY (DECL)\n+extern void arm_pe_unique_section ();\n+#define UNIQUE_SECTION(DECL,RELOC) arm_pe_unique_section (DECL, RELOC)\n+\n+#define SUPPORTS_ONE_ONLY 1\n+\n+/* A C statement to output something to the assembler file to switch to section\n+   NAME for object DECL which is either a FUNCTION_DECL, a VAR_DECL or\n+   NULL_TREE.  Some target formats do not support arbitrary sections.  Do not\n+   define this macro in such cases.  */\n+#undef  ASM_OUTPUT_SECTION_NAME\n+#define ASM_OUTPUT_SECTION_NAME(STREAM, DECL, NAME, RELOC) \t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  if ((DECL) && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\\\n+    fprintf (STREAM, \"\\t.section %s,\\\"x\\\"\\n\", (NAME));\t\t\\\n+  else if ((DECL) && DECL_READONLY_SECTION (DECL, RELOC))\t\\\n+    fprintf (STREAM, \"\\t.section %s,\\\"\\\"\\n\", (NAME));\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\t.section %s,\\\"w\\\"\\n\", (NAME));\t\t\\\n+  /* Functions may have been compiled at various levels of\t\\\n+     optimization so we can't use `same_size' here.  Instead,\t\\\n+     have the linker pick one.  */\t\t\t\t\\\n+  if ((DECL) && DECL_ONE_ONLY (DECL))\t\t\t\t\\\n+    fprintf (STREAM, \"\\t.linkonce %s\\n\",\t\t\t\\\n+\t     TREE_CODE (DECL) == FUNCTION_DECL\t\t\t\\\n+\t     ? \"discard\" : \"same_size\");\t\t\t\\\n+} while (0)\n+\f\n+/* This outputs a lot of .req's to define alias for various registers.\n+   Let's try to avoid this.  */\n+#undef  ASM_FILE_START\n+#define ASM_FILE_START(STREAM) \\\n+do {\t\t\t\t\t\t\t\t\\\n+  extern char * version_string;\t\t\t\t\t\\\n+  fprintf (STREAM, \"%s Generated by gcc %s for ARM/pe\\n\",\t\\\n+\t   ASM_COMMENT_START, version_string);\t\t\t\\\n+  output_file_directive ((STREAM), main_input_filename);\t\\\n+} while (0)\n+\n+/* Output a reference to a label.  */\n+#undef  ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(STREAM, NAME)  \\\n+fprintf (STREAM, \"%s%s\", USER_LABEL_PREFIX, ARM_STRIP_NAME_ENCODING (NAME))\n+\n+/* Output a function definition label.  */\n+#undef  ASM_DECLARE_FUNCTION_NAME\n+#define ASM_DECLARE_FUNCTION_NAME(STREAM, NAME, DECL)   \\\n+do {\t\t\t\t\t\t\t\\\n+  if (arm_dllexport_name_p (NAME))\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      drectve_section ();\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.ascii \\\" -export:%s\\\"\\n\",\t\\\n+\t       ARM_STRIP_NAME_ENCODING (NAME));\t\t\\\n+      function_section (DECL);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  if (TARGET_POKE_FUNCTION_NAME)\t\t\t\\\n+    arm_poke_function_name ((STREAM), (NAME));\t\t\\\n+  ASM_OUTPUT_LABEL ((STREAM), (NAME));\t\t\t\\\n+} while (0)\n+\n+/* Output a common block.  */\n+#undef  ASM_OUTPUT_COMMON\n+#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED) \\\n+do {\t\t\t\t\t\t\t\\\n+  if (arm_dllexport_name_p (NAME))\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      drectve_section ();\t\t\t\t\\\n+      fprintf ((STREAM), \"\\t.ascii \\\" -export:%s\\\"\\n\",\t\\\n+\t       ARM_STRIP_NAME_ENCODING (NAME));\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  if (! arm_dllimport_name_p (NAME))\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fprintf ((STREAM), \"\\t.comm\\t\"); \t\t\t\\\n+      assemble_name ((STREAM), (NAME));\t\t\t\\\n+      fprintf ((STREAM), \", %d\\t%s %d\\n\",\t\t\\\n+\t       (ROUNDED), ASM_COMMENT_START, (SIZE));\t\\\n+    }\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* Output the label for an initialized variable.  */\n+#undef  ASM_DECLARE_OBJECT_NAME\n+#define ASM_DECLARE_OBJECT_NAME(STREAM, NAME, DECL) \\\n+do {\t\t\t\t\t\t\t\\\n+  if (arm_dllexport_name_p (NAME))\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      enum in_section save_section = in_section;\t\\\n+      drectve_section ();\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.ascii \\\" -export:%s\\\"\\n\",\t\\\n+\t       ARM_STRIP_NAME_ENCODING (NAME));\t\t\\\n+      switch_to_section (save_section, (DECL));\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_LABEL ((STREAM), (NAME));\t\t\t\\\n+} while (0)\n+\f\n+/* Support the ctors/dtors and other sections.  */\n+\n+#define DRECTVE_SECTION_ASM_OP\t\"\\t.section .drectve\"\n+\n+/* A list of other sections which the compiler might be \"in\" at any\n+   given time.  */\n+\n+#undef  SUBTARGET_EXTRA_SECTIONS\n+#define SUBTARGET_EXTRA_SECTIONS in_drectve,\n+\n+/* A list of extra section function definitions.  */\n+\n+#undef  SUBTARGET_EXTRA_SECTION_FUNCTIONS\n+#define SUBTARGET_EXTRA_SECTION_FUNCTIONS \\\n+  DRECTVE_SECTION_FUNCTION\t\\\n+  SWITCH_TO_SECTION_FUNCTION\n+\n+#define DRECTVE_SECTION_FUNCTION \\\n+void\t\t\t\t\t\t\t\t\t\\\n+drectve_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_drectve)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DRECTVE_SECTION_ASM_OP);\t\t\\\n+      in_section = in_drectve;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Switch to SECTION (an `enum in_section').\n+\n+   ??? This facility should be provided by GCC proper.\n+   The problem is that we want to temporarily switch sections in\n+   ASM_DECLARE_OBJECT_NAME and then switch back to the original section\n+   afterwards.  */\n+#define SWITCH_TO_SECTION_FUNCTION \\\n+void \\\n+switch_to_section (section, decl) \\\n+     enum in_section section; \\\n+     tree decl; \\\n+{ \\\n+  switch (section) \\\n+    { \\\n+      case in_text: text_section (); break; \\\n+      case in_data: data_section (); break; \\\n+      case in_named: named_section (decl, NULL, 0); break; \\\n+      case in_rdata: rdata_section (); break; \\\n+      case in_ctors: ctors_section (); break; \\\n+      case in_dtors: dtors_section (); break; \\\n+      case in_drectve: drectve_section (); break; \\\n+      default: abort (); break; \\\n+    } \\\n+}"}, {"sha": "c75930c8c6b3cfa617c4793e01881c8168c12512", "filename": "gcc/config/arm/t-pe-thumb", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb805c2ddff216a64ea3a57e03d3a30b76c06c89/gcc%2Fconfig%2Farm%2Ft-pe-thumb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb805c2ddff216a64ea3a57e03d3a30b76c06c89/gcc%2Fconfig%2Farm%2Ft-pe-thumb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-pe-thumb?ref=cb805c2ddff216a64ea3a57e03d3a30b76c06c89", "patch": "@@ -0,0 +1,36 @@\n+# Makefile fragment\n+# Copyright (c) 1998 Free Software Foundation\n+\n+CROSS_LIBGCC1 = libgcc1-asm.a\n+LIB1ASMSRC = arm/lib1thumb.asm\n+LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _call_via_rX _interwork_call_via_rX\n+\n+# These are really part of libgcc1, but this will cause them to be\n+# built correctly, so...\n+\n+LIB2FUNCS_EXTRA = fp-bit.c dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\techo '#ifndef __ARMEB__' >> fp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c\n+\techo '#endif' >> fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#ifndef __ARMEB__' > dp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> dp-bit.c\n+\techo '#define FLOAT_WORD_ORDER_MISMATCH' >> dp-bit.c\n+\techo '#endif' >> dp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n+\n+# Rule to build Psion specific GCC functions.\n+pe.o: $(srcdir)/config/arm/pe.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/arm/pe.c\n+\n+# Avoid building a duplicate set of libraries for the default endian-ness.\n+MULTILIB_OPTIONS = mthumb-interwork\n+MULTILIB_DIRNAMES = interwork\n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib"}, {"sha": "9048a34d473ee2caa98464159b090aaa84341e70", "filename": "gcc/config/arm/thumb.c", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb805c2ddff216a64ea3a57e03d3a30b76c06c89/gcc%2Fconfig%2Farm%2Fthumb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb805c2ddff216a64ea3a57e03d3a30b76c06c89/gcc%2Fconfig%2Farm%2Fthumb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb.c?ref=cb805c2ddff216a64ea3a57e03d3a30b76c06c89", "patch": "@@ -398,6 +398,7 @@ thumb_reorg (first)\n      rtx first;\n {\n   rtx insn;\n+  \n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     {\n       if (broken_move (insn))\n@@ -540,6 +541,24 @@ thumb_reload_out_si (operands)\n   abort ();\n }\n \n+\f\n+#ifdef THUMB_PE\n+/* Return non-zero if FUNC is a naked function.  */\n+\n+static int\n+arm_naked_function_p (func)\n+     tree func;\n+{\n+  tree a;\n+\n+  if (TREE_CODE (func) != FUNCTION_DECL)\n+    abort ();\n+\n+  a = lookup_attribute (\"naked\", DECL_MACHINE_ATTRIBUTES (func));\n+  return a != NULL_TREE;\n+}\n+#endif\n+\n /* Return non-zero if FUNC must be entered in ARM mode.  */\n int\n is_called_in_ARM_mode (func)\n@@ -552,7 +571,11 @@ is_called_in_ARM_mode (func)\n   if (TARGET_CALLEE_INTERWORKING && TREE_PUBLIC (func))\n     return TRUE;\n \n+#ifdef THUMB_PE \n+  return lookup_attribute (\"interfacearm\", DECL_MACHINE_ATTRIBUTES (func)) != NULL_TREE;\n+#else\n   return FALSE;\n+#endif\n }\n \n \f\n@@ -968,6 +991,12 @@ output_return ()\n   int regno;\n   int live_regs_mask = 0;\n \n+#ifdef THUMB_PE\n+  /* If a function is naked, don't use the \"return\" insn.  */\n+  if (arm_naked_function_p (current_function_decl))\n+    return \"\";\n+#endif\n+\n   return_used_this_function = 1;\n \n   for (regno = 0; regno < 8; regno++)\n@@ -1026,9 +1055,15 @@ thumb_function_prologue (f, frame_size)\n   int store_arg_regs = 0;\n   int regno;\n \n+#ifdef THUMB_PE\n+  if (arm_naked_function_p (current_function_decl))\n+    return;\n+#endif\n+\n   if (is_called_in_ARM_mode (current_function_decl))\n     {\n       char * name;\n+      \n       if (GET_CODE (DECL_RTL (current_function_decl)) != MEM)\n \tabort();\n       if (GET_CODE (XEXP (DECL_RTL (current_function_decl), 0)) != SYMBOL_REF)\n@@ -1051,6 +1086,12 @@ thumb_function_prologue (f, frame_size)\n #define STUB_NAME \".real_start_of\"\n       \n       asm_fprintf (f, \"\\t.code\\t16\\n\");\n+      \n+#ifdef THUMB_PE\n+      if (arm_dllexport_name_p (name))\n+        name = ARM_STRIP_NAME_ENCODING (name);\n+#endif        \n+\n       asm_fprintf (f, \"\\t.globl %s%U%s\\n\", STUB_NAME, name);\n       asm_fprintf (f, \"\\t.thumb_func\\n\");\n       asm_fprintf (f, \"%s%U%s:\\n\", STUB_NAME, name);\n@@ -1234,6 +1275,12 @@ thumb_expand_prologue ()\n   int regno;\n   int live_regs_mask;\n \n+#ifdef THUMB_PE\n+  /* Naked functions don't have prologues.  */\n+  if (arm_naked_function_p (current_function_decl))\n+    return;\n+#endif\n+  \n   if (amount)\n     {\n       live_regs_mask = 0;\n@@ -1297,6 +1344,12 @@ thumb_expand_epilogue ()\n \t\t\t  + current_function_outgoing_args_size);\n   int regno;\n \n+#ifdef THUMB_PE\n+  /* Naked functions don't have epilogues.  */\n+  if (arm_naked_function_p (current_function_decl))\n+    return;\n+#endif\n+\n   if (amount)\n     {\n       if (amount < 512)\n@@ -1991,3 +2044,37 @@ thumb_override_options ()\n       flag_pic = 0;\n     }\n }\n+\f\n+#ifdef THUMB_PE\n+/* Return nonzero if ATTR is a valid attribute for DECL.\n+   ATTRIBUTES are any existing attributes and ARGS are the arguments\n+   supplied with ATTR.\n+\n+   Supported attributes:\n+\n+   naked: don't output any prologue or epilogue code, the user is assumed\n+   to do the right thing.\n+\n+   interfacearm: Always assume that this function will be entered in ARM\n+   mode, not Thumb mode, and that the caller wishes to be returned to in\n+   ARM mode.  */\n+int\n+arm_valid_machine_decl_attribute (decl, attr, args)\n+     tree decl;\n+     tree attr;\n+     tree args;\n+{\n+  if (args != NULL_TREE)\n+    return 0;\n+  \n+  if (is_attribute_p (\"naked\", attr))\n+    if (TREE_CODE (decl) == FUNCTION_DECL)\n+      return 1;\n+  \n+  if (is_attribute_p (\"interfacearm\", attr))\n+    return TREE_CODE (decl) == FUNCTION_DECL;\n+  \n+  return 0;\n+}\n+#endif /* THUMB_PE */\n+"}, {"sha": "50e33a078bf55b08edb92d8254c31cf645ab0de4", "filename": "gcc/config/arm/tpe.h", "status": "added", "additions": 425, "deletions": 0, "changes": 425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb805c2ddff216a64ea3a57e03d3a30b76c06c89/gcc%2Fconfig%2Farm%2Ftpe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb805c2ddff216a64ea3a57e03d3a30b76c06c89/gcc%2Fconfig%2Farm%2Ftpe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ftpe.h?ref=cb805c2ddff216a64ea3a57e03d3a30b76c06c89", "patch": "@@ -0,0 +1,425 @@\n+/* Definitions of target machine for GNU compiler,\n+   for Thumb with PE object format.\n+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+   Derived from arm/coff.h and arm/pe.h originally by Doug Evans (evans@cygnus.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"arm/thumb.h\"\n+\f\n+#define THUMB_PE 1\n+\n+/* Run-time Target Specification.  */\n+#undef  TARGET_VERSION\n+#define TARGET_VERSION fputs (\" (Thumb/pe)\", stderr)\n+\f\n+/* Support the __declspec keyword by turning them into attributes.\n+   We currently only support: naked, dllimport, and dllexport.\n+   Note that the current way we do this may result in a collision with\n+   predefined attributes later on.  This can be solved by using one attribute,\n+   say __declspec__, and passing args to it.  The problem with that approach\n+   is that args are not accumulated: each new appearance would clobber any\n+   existing args.  */\n+#undef  CPP_PREDEFINES\n+#define CPP_PREDEFINES \"\\\n+-Dthumb -D__thumb -D__pe__ -Acpu(arm) -Amachine(arm) \\\n+-D__declspec(x)=__attribute__((x)) \\\n+\"\n+\n+/* Experimental addition for pr 7885.\n+   Ignore dllimport for functions.  */\n+#define ARM_FLAG_NOP_FUN_IMPORT\t\t0x20000\n+#define TARGET_NOP_FUN_DLLIMPORT (target_flags & ARM_FLAG_NOP_FUN_IMPORT)\n+\n+#undef  SUBTARGET_SWITCHES\n+#define SUBTARGET_SWITCHES \\\n+{ \"nop-fun-dllimport\",\t\t  ARM_FLAG_NOP_FUN_IMPORT, \"Ignore dllimport attribute for functions\" }, \\\n+{ \"no-nop-fun-dllimport\",\t -ARM_FLAG_NOP_FUN_IMPORT, \"\" }, \n+\n+#undef  TARGET_DEFAULT\n+#define TARGET_DEFAULT ARM_FLAG_NOP_FUN_IMPORT\n+\f\n+#undef  WCHAR_TYPE\n+#define WCHAR_TYPE \"short unsigned int\"\n+#undef  WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE 16\n+\f\n+/* Setting this to 32 produces more efficient code, but the value set in previous\n+   versions of this toolchain was 8, which produces more compact structures. The\n+   command line option -mstructure_size_boundary=<n> can be used to change this\n+   value.  */\n+#undef  STRUCTURE_SIZE_BOUNDARY\n+#define STRUCTURE_SIZE_BOUNDARY arm_structure_size_boundary\n+\n+extern int arm_structure_size_boundary;\n+\f\n+/* This is COFF, but prefer stabs.  */\n+#define SDB_DEBUGGING_INFO\n+\n+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n+\n+#include \"dbxcoff.h\"\n+\f\n+/* Note - it is important that these definitions match those in semi.h for the ARM port.  */\n+#undef  LOCAL_LABEL_PREFIX\n+#define LOCAL_LABEL_PREFIX \".\"\n+\n+#undef  USER_LABEL_PREFIX\n+#define USER_LABEL_PREFIX \"_\"\n+\n+/* A C statement to output assembler commands which will identify the\n+   object file as having been compiled with GNU CC (or another GNU\n+   compiler).  */\n+#define ASM_IDENTIFY_GCC(STREAM)\t\t\t\t\\\n+     fprintf (STREAM, \"%sgcc2_compiled.:\\n%s\", LOCAL_LABEL_PREFIX, ASM_APP_OFF )\n+\n+#undef  ASM_FILE_START\n+#define ASM_FILE_START(STREAM) \\\n+do {\t\t\t\t\t\t\t\t\\\n+  extern char * version_string;\t\t\t\t\t\\\n+  fprintf ((STREAM), \"%s Generated by gcc %s for Thumb/coff\\n\", \\\n+\t   ASM_COMMENT_START, version_string);\t                \\\n+  fprintf ((STREAM), ASM_APP_OFF);                              \\\n+} while (0)\n+\n+/* A C statement to output something to the assembler file to switch to section\n+   NAME for object DECL which is either a FUNCTION_DECL, a VAR_DECL or\n+   NULL_TREE.  Some target formats do not support arbitrary sections.  Do not\n+   define this macro in such cases.  */\n+#define ASM_OUTPUT_SECTION_NAME(STREAM, DECL, NAME, RELOC) \\\n+do {\t\t\t\t\t\t\t\t\\\n+  if ((DECL) && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\\\n+    fprintf (STREAM, \"\\t.section %s,\\\"x\\\"\\n\", (NAME));\t\t\\\n+  else if ((DECL) && DECL_READONLY_SECTION (DECL, RELOC))\t\\\n+    fprintf (STREAM, \"\\t.section %s,\\\"\\\"\\n\", (NAME));\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\t.section %s,\\\"w\\\"\\n\", (NAME));\t\t\\\n+} while (0)\n+\f\n+/* Support the ctors/dtors and other sections.  */\n+\n+#undef INIT_SECTION_ASM_OP\n+\n+/* Define this macro if jump tables (for `tablejump' insns) should be\n+   output in the text section, along with the assembler instructions.\n+   Otherwise, the readonly data section is used.  */\n+#define JUMP_TABLES_IN_TEXT_SECTION 1\n+\n+#undef  READONLY_DATA_SECTION\n+#define READONLY_DATA_SECTION\trdata_section\n+#undef  RDATA_SECTION_ASM_OP\n+#define RDATA_SECTION_ASM_OP\t\"\\t.section .rdata\"\n+\n+#undef  CTORS_SECTION_ASM_OP\n+#define CTORS_SECTION_ASM_OP\t\"\\t.section .ctors,\\\"x\\\"\"\n+#undef  DTORS_SECTION_ASM_OP\n+#define DTORS_SECTION_ASM_OP\t\"\\t.section .dtors,\\\"x\\\"\"\n+\n+/* A list of other sections which the compiler might be \"in\" at any\n+   given time.  */\n+\n+#undef  EXTRA_SECTIONS\n+#define EXTRA_SECTIONS SUBTARGET_EXTRA_SECTIONS in_rdata, in_ctors, in_dtors\n+\n+#define SUBTARGET_EXTRA_SECTIONS\n+\n+/* A list of extra section function definitions.  */\n+\n+#undef  EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS \\\n+  RDATA_SECTION_FUNCTION\t\\\n+  CTORS_SECTION_FUNCTION\t\\\n+  DTORS_SECTION_FUNCTION\t\\\n+  SUBTARGET_EXTRA_SECTION_FUNCTIONS\n+\n+#define SUBTARGET_EXTRA_SECTION_FUNCTIONS\n+\n+#define RDATA_SECTION_FUNCTION \\\n+void\t\t\t\t\t\t\t\t\t\\\n+rdata_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_rdata)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", RDATA_SECTION_ASM_OP);\t\t\\\n+      in_section = in_rdata;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define CTORS_SECTION_FUNCTION \\\n+void\t\t\t\t\t\t\t\t\t\\\n+ctors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_ctors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_ctors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define DTORS_SECTION_FUNCTION \\\n+void\t\t\t\t\t\t\t\t\t\\\n+dtors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_dtors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_dtors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\f\n+/* Support the ctors/dtors sections for g++.  */\n+\n+#define INT_ASM_OP \".word\"\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global constructors.  */\n+#undef  ASM_OUTPUT_CONSTRUCTOR\n+#define ASM_OUTPUT_CONSTRUCTOR(STREAM,NAME) \\\n+do {\t\t\t\t\t\t\\\n+  ctors_section ();\t\t\t\t\\\n+  fprintf (STREAM, \"\\t%s\\t \", INT_ASM_OP);\t\\\n+  assemble_name (STREAM, NAME);\t\t\t\\\n+  fprintf (STREAM, \"\\n\");\t\t\t\\\n+} while (0)\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global destructors.  */\n+#undef  ASM_OUTPUT_DESTRUCTOR\n+#define ASM_OUTPUT_DESTRUCTOR(STREAM,NAME) \\\n+do {\t\t\t\t\t\t\\\n+  dtors_section ();                   \t\t\\\n+  fprintf (STREAM, \"\\t%s\\t \", INT_ASM_OP);\t\\\n+  assemble_name (STREAM, NAME);              \t\\\n+  fprintf (STREAM, \"\\n\");\t\t\t\\\n+} while (0)\n+\n+/* __CTOR_LIST__ and __DTOR_LIST__ must be defined by the linker script.  */\n+#define CTOR_LISTS_DEFINED_EXTERNALLY\n+\n+#undef DO_GLOBAL_CTORS_BODY\n+#undef DO_GLOBAL_DTORS_BODY\n+\n+/* The ARM development system has atexit and doesn't have _exit,\n+   so define this for now.  */\n+#define HAVE_ATEXIT\n+\n+/* The ARM development system defines __main.  */\n+#define NAME__MAIN \"__gccmain\"\n+#define SYMBOL__MAIN __gccmain\n+\f\n+/* This is to better conform to the ARM PCS.\n+   Richard Earnshaw hasn't put this into FSF sources yet so it's here.  */\n+#undef  RETURN_IN_MEMORY\n+#define RETURN_IN_MEMORY(TYPE) \t\t\t\t\t\t\\\n+  ((TYPE_MODE ((TYPE)) == BLKmode && ! TYPE_NO_FORCE_BLK (TYPE))\t\\\n+   || (AGGREGATE_TYPE_P ((TYPE)) && arm_pe_return_in_memory ((TYPE))))\n+\f\n+/* A C expression whose value is nonzero if IDENTIFIER with arguments ARGS\n+   is a valid machine specific attribute for DECL.\n+   The attributes in ATTRIBUTES have previously been assigned to DECL.  */\n+extern int arm_pe_valid_machine_decl_attribute ();\n+#undef  VALID_MACHINE_DECL_ATTRIBUTE\n+#define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \\\n+  arm_pe_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n+\n+extern union tree_node * arm_pe_merge_machine_decl_attributes ();\n+#define MERGE_MACHINE_DECL_ATTRIBUTES(OLD, NEW) \\\n+  arm_pe_merge_machine_decl_attributes ((OLD), (NEW))\n+\n+/* In addition to the stuff done in arm.h, we must mark dll symbols specially.\n+   Definitions of dllexport'd objects install some info in the .drectve\n+   section.  References to dllimport'd objects are fetched indirectly via\n+   __imp_.  If both are declared, dllexport overrides.\n+   This is also needed to implement one-only vtables: they go into their own\n+   section and we need to set DECL_SECTION_NAME so we do that here.\n+   Note that we can be called twice on the same decl.  */\n+extern void arm_pe_encode_section_info ();\n+#undef  ENCODE_SECTION_INFO\n+#define ENCODE_SECTION_INFO(DECL) \\\n+  arm_pe_encode_section_info (DECL)\n+\n+#define REDO_SECTION_INFO_P(DECL) 1\n+     \n+     /* Utility used only in this file.  */\n+#define ARM_STRIP_NAME_ENCODING(SYM_NAME) \\\n+((SYM_NAME) + ((SYM_NAME)[0] == '@' ? 3 : 0))\n+\n+/* Strip any text from SYM_NAME added by ENCODE_SECTION_INFO and store\n+   the result in VAR.  */\n+#undef  STRIP_NAME_ENCODING\n+#define STRIP_NAME_ENCODING(VAR, SYM_NAME) \\\n+(VAR) = ARM_STRIP_NAME_ENCODING (SYM_NAME)\n+\n+/* Define this macro if in some cases global symbols from one translation\n+   unit may not be bound to undefined symbols in another translation unit\n+   without user intervention.  For instance, under Microsoft Windows\n+   symbols must be explicitly imported from shared libraries (DLLs).  */\n+#define MULTIPLE_SYMBOL_SPACES\n+\n+#define UNIQUE_SECTION_P(DECL) DECL_ONE_ONLY (DECL)\n+extern void arm_pe_unique_section ();\n+#define UNIQUE_SECTION(DECL,RELOC) arm_pe_unique_section (DECL, RELOC)\n+\n+#define SUPPORTS_ONE_ONLY 1\n+\n+/* A C statement to output something to the assembler file to switch to section\n+   NAME for object DECL which is either a FUNCTION_DECL, a VAR_DECL or\n+   NULL_TREE.  Some target formats do not support arbitrary sections.  Do not\n+   define this macro in such cases.  */\n+#undef  ASM_OUTPUT_SECTION_NAME\n+#define ASM_OUTPUT_SECTION_NAME(STREAM, DECL, NAME, RELOC) \t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  if ((DECL) && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\\\n+    fprintf (STREAM, \"\\t.section %s,\\\"x\\\"\\n\", (NAME));\t\t\\\n+  else if ((DECL) && DECL_READONLY_SECTION (DECL, RELOC))\t\\\n+    fprintf (STREAM, \"\\t.section %s,\\\"\\\"\\n\", (NAME));\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\t.section %s,\\\"w\\\"\\n\", (NAME));\t\t\\\n+  /* Functions may have been compiled at various levels of\t\\\n+     optimization so we can't use `same_size' here.  Instead,\t\\\n+     have the linker pick one.  */\t\t\t\t\\\n+  if ((DECL) && DECL_ONE_ONLY (DECL))\t\t\t\t\\\n+    fprintf (STREAM, \"\\t.linkonce %s\\n\",\t\t\t\\\n+\t     TREE_CODE (DECL) == FUNCTION_DECL\t\t\t\\\n+\t     ? \"discard\" : \"same_size\");\t\t\t\\\n+} while (0)\n+\f\n+/* This outputs a lot of .req's to define alias for various registers.\n+   Let's try to avoid this.  */\n+#undef  ASM_FILE_START\n+#define ASM_FILE_START(STREAM) \\\n+do {\t\t\t\t\t\t\t\t\\\n+  extern char * version_string;\t\t\t\t\t\\\n+  fprintf (STREAM, \"%s Generated by gcc %s for ARM/pe\\n\",\t\\\n+\t   ASM_COMMENT_START, version_string);\t\t\t\\\n+  output_file_directive ((STREAM), main_input_filename);\t\\\n+} while (0)\n+\n+/* Output a reference to a label.  */\n+#undef  ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(STREAM, NAME)  \\\n+fprintf (STREAM, \"%s%s\", USER_LABEL_PREFIX, ARM_STRIP_NAME_ENCODING (NAME))\n+\n+/* Output a function definition label.  */\n+#undef  ASM_DECLARE_FUNCTION_NAME\n+#define ASM_DECLARE_FUNCTION_NAME(STREAM, NAME, DECL) \\\n+do {\t\t\t\t\t\t\t\\\n+  if (arm_dllexport_name_p (NAME))\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      drectve_section ();\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.ascii \\\" -export:%s\\\"\\n\",\t\\\n+\t       ARM_STRIP_NAME_ENCODING (NAME));\t\t\\\n+      function_section (DECL);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  if (! is_called_in_ARM_mode (decl))\t\t\t\\\n+    fprintf (STREAM, \"\\t.thumb_func\\n\") ;\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\t.code\\t32\\n\") ;\t\t\t\\\n+  ASM_OUTPUT_LABEL ((STREAM), (NAME));\t\t\t\\\n+} while (0)\n+\n+/* Output a common block.  */\n+#undef  ASM_OUTPUT_COMMON\n+#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED) \\\n+do {\t\t\t\t\t\t\t\\\n+  if (arm_dllexport_name_p (NAME))\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      drectve_section ();\t\t\t\t\\\n+      fprintf ((STREAM), \"\\t.ascii \\\" -export:%s\\\"\\n\",\t\\\n+\t       ARM_STRIP_NAME_ENCODING (NAME));\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  if (! arm_dllimport_name_p (NAME))\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fprintf ((STREAM), \"\\t.comm\\t\"); \t\t\t\\\n+      assemble_name ((STREAM), (NAME));\t\t\t\\\n+      fprintf ((STREAM), \", %d\\t%s %d\\n\",\t\t\\\n+\t       (ROUNDED), ASM_COMMENT_START, (SIZE));\t\\\n+    }\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* Output the label for an initialized variable.  */\n+#undef  ASM_DECLARE_OBJECT_NAME\n+#define ASM_DECLARE_OBJECT_NAME(STREAM, NAME, DECL) \\\n+do {\t\t\t\t\t\t\t\\\n+  if (arm_dllexport_name_p (NAME))\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      enum in_section save_section = in_section;\t\\\n+      drectve_section ();\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.ascii \\\" -export:%s\\\"\\n\",\t\\\n+\t       ARM_STRIP_NAME_ENCODING (NAME));\t\t\\\n+      switch_to_section (save_section, (DECL));\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_LABEL ((STREAM), (NAME));\t\t\t\\\n+} while (0)\n+\f\n+/* Support the ctors/dtors and other sections.  */\n+\n+#define DRECTVE_SECTION_ASM_OP\t\"\\t.section .drectve\"\n+\n+/* A list of other sections which the compiler might be \"in\" at any\n+   given time.  */\n+\n+#undef  SUBTARGET_EXTRA_SECTIONS\n+#define SUBTARGET_EXTRA_SECTIONS in_drectve,\n+\n+/* A list of extra section function definitions.  */\n+\n+#undef  SUBTARGET_EXTRA_SECTION_FUNCTIONS\n+#define SUBTARGET_EXTRA_SECTION_FUNCTIONS \\\n+  DRECTVE_SECTION_FUNCTION\t\\\n+  SWITCH_TO_SECTION_FUNCTION\n+\n+#define DRECTVE_SECTION_FUNCTION \\\n+void\t\t\t\t\t\t\t\t\t\\\n+drectve_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_drectve)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DRECTVE_SECTION_ASM_OP);\t\t\\\n+      in_section = in_drectve;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Switch to SECTION (an `enum in_section').\n+\n+   ??? This facility should be provided by GCC proper.\n+   The problem is that we want to temporarily switch sections in\n+   ASM_DECLARE_OBJECT_NAME and then switch back to the original section\n+   afterwards.  */\n+#define SWITCH_TO_SECTION_FUNCTION \\\n+void \\\n+switch_to_section (section, decl) \\\n+     enum in_section section; \\\n+     tree decl; \\\n+{ \\\n+  switch (section) \\\n+    { \\\n+      case in_text: text_section (); break; \\\n+      case in_data: data_section (); break; \\\n+      case in_named: named_section (decl, NULL, 0); break; \\\n+      case in_rdata: rdata_section (); break; \\\n+      case in_ctors: ctors_section (); break; \\\n+      case in_dtors: dtors_section (); break; \\\n+      case in_drectve: drectve_section (); break; \\\n+      default: abort (); break; \\\n+    } \\\n+}\n+\n+\n+\f\n+extern int thumb_pe_valid_machine_decl_attribute ();"}, {"sha": "6d406f482c4438e64aa55461d7410d9581cd31b8", "filename": "gcc/configure", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb805c2ddff216a64ea3a57e03d3a30b76c06c89/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb805c2ddff216a64ea3a57e03d3a30b76c06c89/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=cb805c2ddff216a64ea3a57e03d3a30b76c06c89", "patch": "@@ -3215,6 +3215,11 @@ for machine in $build $host $target; do\n \t\ttm_file=arm/unknown-elf-oabi.h\n \t\ttmake_file=arm/t-arm-elf\n \t\t;;\n+\tarm-*-pe*)\n+\t\ttm_file=arm/pe.h\n+\t\ttmake_file=arm/t-pe\n+\t\textra_objs=pe.o\n+\t\t;;\n \tc1-convex-*)\t\t\t# Convex C1\n \t\ttarget_cpu_default=1\n \t\tuse_collect2=yes\n@@ -5578,6 +5583,14 @@ for machine in $build $host $target; do\n \t\ttmake_file=arm/t-thumb\n \t\tthread_file='vxworks'\n \t\t;;\n+\tthumb-*-pe)\n+\t\ttm_file=arm/tpe.h\n+\t\tout_file=arm/thumb.c\n+\t\txm_file=arm/xm-thumb.h\n+\t\tmd_file=arm/thumb.md\n+\t\ttmake_file=arm/t-pe-thumb\n+\t\textra_objs=pe.o\n+\t\t;;\n # This hasn't been upgraded to GCC 2.\n #\ttron-*-*)\n #\t\tcpu_type=gmicro"}, {"sha": "5c2a6310c98a4328efcde128557f23bdb5fb93da", "filename": "gcc/configure.in", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb805c2ddff216a64ea3a57e03d3a30b76c06c89/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb805c2ddff216a64ea3a57e03d3a30b76c06c89/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=cb805c2ddff216a64ea3a57e03d3a30b76c06c89", "patch": "@@ -788,6 +788,11 @@ changequote([,])dnl\n \t\ttm_file=arm/unknown-elf-oabi.h\n \t\ttmake_file=arm/t-arm-elf\n \t\t;;\n+\tarm-*-pe*)\n+\t\ttm_file=arm/pe.h\n+\t\ttmake_file=arm/t-pe\n+\t\textra_objs=pe.o\n+\t\t;;\n \tc1-convex-*)\t\t\t# Convex C1\n \t\ttarget_cpu_default=1\n \t\tuse_collect2=yes\n@@ -3275,6 +3280,14 @@ changequote([,])dnl\n \t\ttmake_file=arm/t-thumb\n \t\tthread_file='vxworks'\n \t\t;;\n+\tthumb-*-pe)\n+\t\ttm_file=arm/tpe.h\n+\t\tout_file=arm/thumb.c\n+\t\txm_file=arm/xm-thumb.h\n+\t\tmd_file=arm/thumb.md\n+\t\ttmake_file=arm/t-pe-thumb\n+\t\textra_objs=pe.o\n+\t\t;;\n # This hasn't been upgraded to GCC 2.\n #\ttron-*-*)\n #\t\tcpu_type=gmicro"}]}