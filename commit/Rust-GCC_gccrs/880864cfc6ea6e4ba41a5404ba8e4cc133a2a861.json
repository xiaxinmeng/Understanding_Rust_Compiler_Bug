{"sha": "880864cfc6ea6e4ba41a5404ba8e4cc133a2a861", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODgwODY0Y2ZjNmVhNmU0YmE0MWE1NDA0YmE4ZTRjYzEzM2EyYTg2MQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2006-04-14T03:20:21Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2006-04-14T03:20:21Z"}, "message": "re PR middle-end/27095 (O2 produces duplicate code)\n\n\tPR middle-end/27095\n\t* builtins.c: (expand_builtin_memset): Stabilize args before expansion\n\tand emit libcall here in case the builtin fails.\n\t(expand_builtin_strcmp): Always emit the libcall here on failure.\n\nFrom-SVN: r112948", "tree": {"sha": "ff3c8520dcb1c1fbbcb227b8282b29c5d3772fad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff3c8520dcb1c1fbbcb227b8282b29c5d3772fad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/880864cfc6ea6e4ba41a5404ba8e4cc133a2a861", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/880864cfc6ea6e4ba41a5404ba8e4cc133a2a861", "html_url": "https://github.com/Rust-GCC/gccrs/commit/880864cfc6ea6e4ba41a5404ba8e4cc133a2a861", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/880864cfc6ea6e4ba41a5404ba8e4cc133a2a861/comments", "author": null, "committer": null, "parents": [{"sha": "1935e8a86d3141a0d28263330fd428be06c5ecfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1935e8a86d3141a0d28263330fd428be06c5ecfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1935e8a86d3141a0d28263330fd428be06c5ecfa"}], "stats": {"total": 52, "additions": 40, "deletions": 12}, "files": [{"sha": "c0ccec9023e8d378fc1aa590ed40827ca07297f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/880864cfc6ea6e4ba41a5404ba8e4cc133a2a861/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/880864cfc6ea6e4ba41a5404ba8e4cc133a2a861/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=880864cfc6ea6e4ba41a5404ba8e4cc133a2a861", "patch": "@@ -1,3 +1,10 @@\n+2006-04-14  Alan Modra  <amodra@bigpond.net.au>\n+\n+\tPR middle-end/27095\n+\t* builtins.c: (expand_builtin_memset): Stabilize args before expansion\n+\tand emit libcall here in case the builtin fails.\n+\t(expand_builtin_strcmp): Always emit the libcall here on failure.\n+\n 2006-04-14  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* basic-block.h (REG_BASIC_BLOCK): Use VEC instead of VARRAY."}, {"sha": "c4d7ec221dc615995ccc96587126322111e52429", "filename": "gcc/builtins.c", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/880864cfc6ea6e4ba41a5404ba8e4cc133a2a861/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/880864cfc6ea6e4ba41a5404ba8e4cc133a2a861/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=880864cfc6ea6e4ba41a5404ba8e4cc133a2a861", "patch": "@@ -3390,12 +3390,14 @@ expand_builtin_memset (tree arglist, rtx target, enum machine_mode mode,\n       tree dest = TREE_VALUE (arglist);\n       tree val = TREE_VALUE (TREE_CHAIN (arglist));\n       tree len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      tree fndecl, fn;\n+      enum built_in_function fcode;\n       char c;\n-\n-      unsigned int dest_align\n-\t= get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n+      unsigned int dest_align;\n       rtx dest_mem, dest_addr, len_rtx;\n \n+      dest_align = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n+\n       /* If DEST is not a pointer type, don't do this\n \t operation in-line.  */\n       if (dest_align == 0)\n@@ -3409,15 +3411,21 @@ expand_builtin_memset (tree arglist, rtx target, enum machine_mode mode,\n \t  return expand_expr (dest, target, mode, EXPAND_NORMAL);\n \t}\n \n+      /* Stabilize the arguments in case we fail.  */\n+      dest = builtin_save_expr (dest);\n+      val = builtin_save_expr (val);\n+      len = builtin_save_expr (len);\n+\n       len_rtx = expand_normal (len);\n       dest_mem = get_memory_rtx (dest, len);\n \n       if (TREE_CODE (val) != INTEGER_CST)\n \t{\n+\t  tree cval;\n \t  rtx val_rtx;\n \n-\t  val = fold_build1 (CONVERT_EXPR, unsigned_char_type_node, val);\n-\t  val_rtx = expand_normal (val);\n+\t  cval = fold_build1 (CONVERT_EXPR, unsigned_char_type_node, val);\n+\t  val_rtx = expand_normal (cval);\n \n \t  /* Assume that we can memset by pieces if we can store the\n \t   * the coefficients by pieces (in the required modes).\n@@ -3433,17 +3441,17 @@ expand_builtin_memset (tree arglist, rtx target, enum machine_mode mode,\n \t      store_by_pieces (dest_mem, tree_low_cst (len, 1),\n \t\t\t       builtin_memset_gen_str, val_rtx, dest_align, 0);\n \t    }\n-\t  else if (!set_storage_via_setmem(dest_mem, len_rtx, val_rtx, \n-\t\t\t\t\t   dest_align))\n-\t    return 0;\n+\t  else if (!set_storage_via_setmem (dest_mem, len_rtx, val_rtx, \n+\t\t\t\t\t    dest_align))\n+\t    goto do_libcall;\n \n \t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n \t  dest_mem = convert_memory_address (ptr_mode, dest_mem);\n \t  return dest_mem;\n \t}\n \n       if (target_char_cast (val, &c))\n-\treturn 0;\n+\tgoto do_libcall;\n \n       if (c)\n \t{\n@@ -3455,7 +3463,7 @@ expand_builtin_memset (tree arglist, rtx target, enum machine_mode mode,\n \t\t\t     builtin_memset_read_str, &c, dest_align, 0);\n \t  else if (!set_storage_via_setmem (dest_mem, len_rtx, GEN_INT (c),\n \t\t\t\t\t    dest_align))\n-\t    return 0;\n+\t    goto do_libcall;\n \n \t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n \t  dest_mem = convert_memory_address (ptr_mode, dest_mem);\n@@ -3474,6 +3482,19 @@ expand_builtin_memset (tree arglist, rtx target, enum machine_mode mode,\n \t}\n \n       return dest_addr;\n+\n+    do_libcall:\n+      fndecl = get_callee_fndecl (orig_exp);\n+      fcode = DECL_FUNCTION_CODE (fndecl);\n+      gcc_assert (fcode == BUILT_IN_MEMSET || fcode == BUILT_IN_BZERO);\n+      arglist = build_tree_list (NULL_TREE, len);\n+      if (fcode == BUILT_IN_MEMSET)\n+\targlist = tree_cons (NULL_TREE, val, arglist);\n+      arglist = tree_cons (NULL_TREE, dest, arglist);\n+      fn = build_function_call_expr (fndecl, arglist);\n+      if (TREE_CODE (fn) == CALL_EXPR)\n+\tCALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (orig_exp);\n+      return expand_call (fn, target, target == const0_rtx);\n     }\n }\n \n@@ -3719,9 +3740,8 @@ expand_builtin_strcmp (tree exp, rtx target, enum machine_mode mode)\n \n \t  /* If both arguments have side effects, we cannot optimize.  */\n \t  if (!len || TREE_SIDE_EFFECTS (len))\n-\t    return 0;\n+\t    goto do_libcall;\n \n-\t  /* Stabilize the arguments in case gen_cmpstrnsi fails.  */\n \t  arg3_rtx = expand_normal (len);\n \n \t  /* Make a place to write the result of the instruction.  */\n@@ -3752,6 +3772,7 @@ expand_builtin_strcmp (tree exp, rtx target, enum machine_mode mode)\n \n       /* Expand the library call ourselves using a stabilized argument\n \t list to avoid re-evaluating the function's arguments twice.  */\n+    do_libcall:\n       arglist = build_tree_list (NULL_TREE, arg2);\n       arglist = tree_cons (NULL_TREE, arg1, arglist);\n       fndecl = get_callee_fndecl (exp);"}]}