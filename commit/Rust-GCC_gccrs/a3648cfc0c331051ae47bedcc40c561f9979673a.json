{"sha": "a3648cfc0c331051ae47bedcc40c561f9979673a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM2NDhjZmMwYzMzMTA1MWFlNDdiZWRjYzQwYzU2MWY5OTc5NjczYQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-06-30T22:18:42Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-06-30T22:18:42Z"}, "message": "[multiple changes]\n\n2005-06-29  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* tree-complex.c (complex_variable_components): Now a hashtable.\n\t(cvc_lookup): Ditto.\n\t(cvc_insert): Ditto.\n\t(create_components): Use referenced var iterator.\n\tInitialize hashtable.\tUse cvc_insert/lookup.\n\t(extract_components): Use cvc_insert/lookup.\n\t(update_complex_components): Ditto.\n\t(update_complex_components_on_edge): Ditto.\n\t* tree-dfa.c (referenced_vars): Now a hashtable.\n\t(dump_referenced_vars): Use iterator.\n\t(referenced_var_lookup): New function.\n\t(referenced_var_insert): Ditto.\n\t(add_referenced_var): Use referenced_var_insert.\n\t(mark_new_vars_to_rename): Use DECL_UID.\n\t* tree-flow-inline.h (first_htab_element): New function.\n\t(end_htab_p): Ditto.\n\t(next_htab_element): Ditto.\n\t(first_referenced_var): Ditto.\n\t(end_referenced_vars_p): Ditto.\n\t(next_referenced_var): Ditto.\n\t(is_call_clobbered): Use DECL_UID.\n\t(mark_call_clobbered): Ditto.\n\t(clear_call_clobbered): Ditto.\n\t(mark_non_addressable): Ditto.\n\t* tree-flow.h (htab_iterator): New struct.\n\t(FOR_EACH_HTAB_ELEMENT): New macro.\n\t(struct int_tree_map): New struct.\n\t(int_tree_map_hash): Prototype.\n\t(int_tree_map_eq): Ditto.\n\t(referenced_var_iterator): Ditto.\n\t(FOR_EACH_REFERENCED_VAR): New macro.\n\t(referenced_vars): Now a hashtable.\n\t* tree-into-ssa.c (symbol_marked_for_renaming): Use DECL_UID.\n\t(add_new_name_mapping): Ditto.\n\t(mark_def_sites): Ditto.\n\t(insert_phi_nodes): Use referenced_var iterator.\n\t(mark_def_site_blocks): Ditto.\n\t(mark_sym_for_renaming): Use DECL_UID.\n\t* tree-sra.c (is_sra_candidate_decl): Use DECL_UID.\n\t(lookup_element): Ditto.\n\t(find_candidates_for_sra): Use referenced_vars iterator.\n\tUse DECL_UID.\n\t* tree-ssa-alias.c (NUM_REFERENCES): New macro.\n\t(NUM_REFERENCES_CLEAR): Ditto.\n\t(NUM_REFERENCES_INC): Ditto.\n\t(NUM_REFERENCES_SET): Ditto.\n\t(alias_obstack): New bitmap obstack.\n\t(struct alias_map_d): Use bitmap, not sbitmap.\n\t(struct alias_info): Remove num_references.\n\t(init_alias_info): Use referenced_var iterator.\n\tInitialize bitmap obstack.\n\t(delete_alias_info): Use referenced_var iterator.\n\tFree bitmap obstack.\n\t(compute_points_to_and_addr_escape): Use DECL_UID.\n\tUse new NUM_REFERENCES macros.\n\t(compute_flow_sensitive_aliasing): may_aliases is now a bitmap.\n\tUse new NUM_REFERENCES macros.\n\t(group_aliases_into): Update prototype to use bitmap.\n\t(setup_pointers_and_addressables): Use referenced_vars iterator.\n\tUse DECL_UID. Use new NUM_REFERENCES macros.\n\t(add_pointed_to_var): Use DECL_UID.\n\t(dump_alias_info): Use referenced_var iterator.\n\t(add_type_alias): Ditto.\n\t(used_portions): Now a hashtable.\n\t(used_part_map_eq): New function.\n\t(used_part_map_hash): Ditto.\n\t(free_used_part_map): Ditto.\n\t(up_lookup): Ditto.\n\t(up_insert): Ditto.\n\t(get_or_create_used_part_for): Use up_lookup.\n\t(create_overlap_variables_for): Ditto.\n\t(find_used_portions): Use up_insert.\n\tUse DECL_UID.\n\t(create_structure_vars): Init used_portions hashtable, use\n\treferenced_vars iterator.\n\t* tree-ssa-live.c (create_ssa_var_map): sbitmaps became bitmaps.\n\tUse DECL_UID.\n\t* tree-ssa-loop-im.c (gather_mem_refs_stmt): Use DECL_UID.\n\t* tree-ssa-operands.c (get_asm_expr_operands): Ditto.\n\t(note_addressable): Ditto.\n\t* tree-ssa-structalias.c (set_uids_in_ptset): Ditto.\n\t* tree-ssa.c (verify_flow_insensitive_alias_info): Use\n\treferenced_var iterator.\n\tUse DECL_UID.\n\t(delete_tree_ssa): Ditto.\n\t(int_tree_map_eq): New function.\n\t(int_tree_map_hash): Ditto.\n\t* tree-stdarg.c (find_va_list_reference): Use DECL_UID.\n\t(va_list_ptr_read): Ditto.\n\t(va_list_counter_struct_op): Ditto.\n\t(va_list_ptr_write): Ditto.\n\t(check_va_list_escapes): Ditto.\n\t(check_all_va_list_escapes): Ditto.\n\t(execute_optimize_stdarg): Ditto.\n\t* tree-tailcall.c (suitable_for_tail_opt_p): Used referenced_var\n\titerator.\n2005-06-30  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* hashtab.h (HTAB_DELETED_ENTRY): New macro.\n\t(HTAB_EMPTY_ENTRY): New macro.\n\n2005-06-30  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* hashtab.c (EMPTY_ENTRY): Moved and renamed.\n\t(DELETED_ENTRY): Ditto.\n\nFrom-SVN: r101480", "tree": {"sha": "93a9e5ca3a3ce97f70134506548b6bda75edd769", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93a9e5ca3a3ce97f70134506548b6bda75edd769"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3648cfc0c331051ae47bedcc40c561f9979673a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3648cfc0c331051ae47bedcc40c561f9979673a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3648cfc0c331051ae47bedcc40c561f9979673a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3648cfc0c331051ae47bedcc40c561f9979673a/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "114a6b1d3b76098db6ab09765a3d5b21926fd639", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/114a6b1d3b76098db6ab09765a3d5b21926fd639", "html_url": "https://github.com/Rust-GCC/gccrs/commit/114a6b1d3b76098db6ab09765a3d5b21926fd639"}], "stats": {"total": 944, "additions": 651, "deletions": 293}, "files": [{"sha": "2d64f3ae3d206c09b6eb6146bdea24010eb50e85", "filename": "gcc/ChangeLog", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a3648cfc0c331051ae47bedcc40c561f9979673a", "patch": "@@ -1,3 +1,102 @@\n+2005-06-29  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* tree-complex.c (complex_variable_components): Now a hashtable.\n+\t(cvc_lookup): Ditto.\n+\t(cvc_insert): Ditto.\n+\t(create_components): Use referenced var iterator.\n+\tInitialize hashtable.\tUse cvc_insert/lookup.\n+\t(extract_components): Use cvc_insert/lookup.\n+\t(update_complex_components): Ditto.\n+\t(update_complex_components_on_edge): Ditto.\n+\t* tree-dfa.c (referenced_vars): Now a hashtable.\n+\t(dump_referenced_vars): Use iterator.\n+\t(referenced_var_lookup): New function.\n+\t(referenced_var_insert): Ditto.\n+\t(add_referenced_var): Use referenced_var_insert.\n+\t(mark_new_vars_to_rename): Use DECL_UID.\n+\t* tree-flow-inline.h (first_htab_element): New function.\n+\t(end_htab_p): Ditto.\n+\t(next_htab_element): Ditto.\n+\t(first_referenced_var): Ditto.\n+\t(end_referenced_vars_p): Ditto.\n+\t(next_referenced_var): Ditto.\n+\t(is_call_clobbered): Use DECL_UID.\n+\t(mark_call_clobbered): Ditto.\n+\t(clear_call_clobbered): Ditto.\n+\t(mark_non_addressable): Ditto.\n+\t* tree-flow.h (htab_iterator): New struct.\n+\t(FOR_EACH_HTAB_ELEMENT): New macro.\n+\t(struct int_tree_map): New struct.\n+\t(int_tree_map_hash): Prototype.\n+\t(int_tree_map_eq): Ditto.\n+\t(referenced_var_iterator): Ditto.\n+\t(FOR_EACH_REFERENCED_VAR): New macro.\n+\t(referenced_vars): Now a hashtable.\n+\t* tree-into-ssa.c (symbol_marked_for_renaming): Use DECL_UID.\n+\t(add_new_name_mapping): Ditto.\n+\t(mark_def_sites): Ditto.\n+\t(insert_phi_nodes): Use referenced_var iterator.\n+\t(mark_def_site_blocks): Ditto.\n+\t(mark_sym_for_renaming): Use DECL_UID.\n+\t* tree-sra.c (is_sra_candidate_decl): Use DECL_UID.\n+\t(lookup_element): Ditto.\n+\t(find_candidates_for_sra): Use referenced_vars iterator.\n+\tUse DECL_UID.\n+\t* tree-ssa-alias.c (NUM_REFERENCES): New macro.\n+\t(NUM_REFERENCES_CLEAR): Ditto.\n+\t(NUM_REFERENCES_INC): Ditto.\n+\t(NUM_REFERENCES_SET): Ditto.\n+\t(alias_obstack): New bitmap obstack.\n+\t(struct alias_map_d): Use bitmap, not sbitmap.\n+\t(struct alias_info): Remove num_references.\n+\t(init_alias_info): Use referenced_var iterator.\n+\tInitialize bitmap obstack.\n+\t(delete_alias_info): Use referenced_var iterator.\n+\tFree bitmap obstack.\n+\t(compute_points_to_and_addr_escape): Use DECL_UID.\n+\tUse new NUM_REFERENCES macros.\n+\t(compute_flow_sensitive_aliasing): may_aliases is now a bitmap.\n+\tUse new NUM_REFERENCES macros.\n+\t(group_aliases_into): Update prototype to use bitmap.\n+\t(setup_pointers_and_addressables): Use referenced_vars iterator.\n+\tUse DECL_UID. Use new NUM_REFERENCES macros.\n+\t(add_pointed_to_var): Use DECL_UID.\n+\t(dump_alias_info): Use referenced_var iterator.\n+\t(add_type_alias): Ditto.\n+\t(used_portions): Now a hashtable.\n+\t(used_part_map_eq): New function.\n+\t(used_part_map_hash): Ditto.\n+\t(free_used_part_map): Ditto.\n+\t(up_lookup): Ditto.\n+\t(up_insert): Ditto.\n+\t(get_or_create_used_part_for): Use up_lookup.\n+\t(create_overlap_variables_for): Ditto.\n+\t(find_used_portions): Use up_insert.\n+\tUse DECL_UID.\n+\t(create_structure_vars): Init used_portions hashtable, use\n+\treferenced_vars iterator.\n+\t* tree-ssa-live.c (create_ssa_var_map): sbitmaps became bitmaps.\n+\tUse DECL_UID.\n+\t* tree-ssa-loop-im.c (gather_mem_refs_stmt): Use DECL_UID.\n+\t* tree-ssa-operands.c (get_asm_expr_operands): Ditto.\n+\t(note_addressable): Ditto.\n+\t* tree-ssa-structalias.c (set_uids_in_ptset): Ditto.\n+\t* tree-ssa.c (verify_flow_insensitive_alias_info): Use\n+\treferenced_var iterator.\n+\tUse DECL_UID.\n+\t(delete_tree_ssa): Ditto.\n+\t(int_tree_map_eq): New function.\n+\t(int_tree_map_hash): Ditto.\n+\t* tree-stdarg.c (find_va_list_reference): Use DECL_UID.\n+\t(va_list_ptr_read): Ditto.\n+\t(va_list_counter_struct_op): Ditto.\n+\t(va_list_ptr_write): Ditto.\n+\t(check_va_list_escapes): Ditto.\n+\t(check_all_va_list_escapes): Ditto.\n+\t(execute_optimize_stdarg): Ditto.\n+\t* tree-tailcall.c (suitable_for_tail_opt_p): Used referenced_var\n+\titerator. \n+\n 2005-06-30  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* config/rs6000/darwin.h (FRAME_POINTER_REGNUM): Rename to ..."}, {"sha": "e32dd237be8508670a49b3e6bd7b5aa89a604911", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 49, "deletions": 18, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=a3648cfc0c331051ae47bedcc40c561f9979673a", "patch": "@@ -52,8 +52,37 @@ DEF_VEC_ALLOC_I(complex_lattice_t, heap);\n \n static VEC(complex_lattice_t, heap) *complex_lattice_values;\n \n-/* For each complex variable, a pair of variables for the components.  */\n-static VEC(tree, heap) *complex_variable_components;\n+/* For each complex variable, a pair of variables for the components exists in\n+   the hashtable.  */\n+static htab_t complex_variable_components;\n+\n+/* Lookup UID in the complex_variable_components hashtable and return the\n+   associated tree.  */\n+static tree \n+cvc_lookup (unsigned int uid)\n+{\n+  struct int_tree_map *h, in;\n+  in.uid = uid;\n+  h = htab_find_with_hash (complex_variable_components, &in, uid);\n+  gcc_assert (h);\n+  return h->to;\n+}\n+ \n+/* Insert the pair UID, TO into the complex_variable_components hashtable.  */\n+\n+static void \n+cvc_insert (unsigned int uid, tree to)\n+{ \n+  struct int_tree_map *h;\n+  void **loc;\n+\n+  h = xmalloc (sizeof (struct int_tree_map));\n+  h->uid = uid;\n+  h->to = to;\n+  loc = htab_find_slot_with_hash (complex_variable_components, h,\n+\t\t\t\t  uid, INSERT);\n+  *(struct int_tree_map **)  loc = h;\n+}\n \n \n /* Return true if T is not a zero constant.  In the case of real values,\n@@ -355,18 +384,19 @@ complex_visit_phi (tree phi)\n static void\n create_components (void)\n {\n-  size_t k, n;\n+  size_t n;\n+  tree var;\n+  referenced_var_iterator rvi;\n \n   n = num_referenced_vars;\n   if (n == 0)\n     return;\n \n-  complex_variable_components = VEC_alloc (tree, heap, 2*n);\n-  VEC_safe_grow (tree, heap, complex_variable_components, 2*n);\n+  complex_variable_components = htab_create (10,  int_tree_map_hash,\n+\t\t\t\t\t     int_tree_map_eq, free);\n \n-  for (k = 0; k < n; ++k)\n+  FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n-      tree var = referenced_var (k);\n       tree r = NULL, i = NULL;\n \n       if (var != NULL\n@@ -409,8 +439,8 @@ create_components (void)\n \t    }\n \t}\n \n-      VEC_replace (tree, complex_variable_components, 2*k, r);\n-      VEC_replace (tree, complex_variable_components, 2*k + 1, i);\n+      cvc_insert (2 * DECL_UID (var), r);\n+      cvc_insert (2 * DECL_UID (var) + 1, i);\n     }\n }\n \n@@ -464,8 +494,7 @@ extract_component (block_stmt_iterator *bsi, tree t, bool imagpart_p,\n \t      }\n \t  }\n \n-\treturn VEC_index (tree, complex_variable_components,\n-\t\t\t  var_ann (SSA_NAME_VAR (t))->uid * 2 + imagpart_p);\n+\treturn cvc_lookup (DECL_UID (SSA_NAME_VAR (t)) * 2 + imagpart_p);\n       }\n \n     default:\n@@ -478,16 +507,16 @@ extract_component (block_stmt_iterator *bsi, tree t, bool imagpart_p,\n static void\n update_complex_components (block_stmt_iterator *bsi, tree stmt, tree r, tree i)\n {\n-  unsigned int uid = var_ann (SSA_NAME_VAR (TREE_OPERAND (stmt, 0)))->uid;\n+  unsigned int uid = DECL_UID (SSA_NAME_VAR (TREE_OPERAND (stmt, 0)));\n   tree v, x;\n \n-  v = VEC_index (tree, complex_variable_components, 2*uid);\n+  v = cvc_lookup (2*uid);\n   x = build2 (MODIFY_EXPR, TREE_TYPE (v), v, r);\n   SET_EXPR_LOCUS (x, EXPR_LOCUS (stmt));\n   TREE_BLOCK (x) = TREE_BLOCK (stmt);\n   bsi_insert_after (bsi, x, BSI_NEW_STMT);\n \n-  v = VEC_index (tree, complex_variable_components, 2*uid + 1);\n+  v = cvc_lookup (2*uid + 1);\n   x = build2 (MODIFY_EXPR, TREE_TYPE (v), v, i);\n   SET_EXPR_LOCUS (x, EXPR_LOCUS (stmt));\n   TREE_BLOCK (x) = TREE_BLOCK (stmt);\n@@ -497,10 +526,10 @@ update_complex_components (block_stmt_iterator *bsi, tree stmt, tree r, tree i)\n static void\n update_complex_components_on_edge (edge e, tree stmt, tree lhs, tree r, tree i)\n {\n-  unsigned int uid = var_ann (SSA_NAME_VAR (lhs))->uid;\n+  unsigned int uid = DECL_UID (SSA_NAME_VAR (lhs));\n   tree v, x;\n \n-  v = VEC_index (tree, complex_variable_components, 2*uid);\n+  v = cvc_lookup (2*uid);\n   x = build2 (MODIFY_EXPR, TREE_TYPE (v), v, r);\n   if (stmt)\n     {\n@@ -509,7 +538,7 @@ update_complex_components_on_edge (edge e, tree stmt, tree lhs, tree r, tree i)\n     }\n   bsi_insert_on_edge (e, x);\n \n-  v = VEC_index (tree, complex_variable_components, 2*uid + 1);\n+  v = cvc_lookup (2*uid + 1);\n   x = build2 (MODIFY_EXPR, TREE_TYPE (v), v, i);\n   if (stmt)\n     {\n@@ -1406,7 +1435,9 @@ tree_lower_complex (void)\n \n   bsi_commit_edge_inserts ();\n \n-  VEC_free (tree, heap, complex_variable_components);\n+  if (complex_variable_components)\n+    htab_delete (complex_variable_components);\n+\n   VEC_free (complex_lattice_t, heap, complex_lattice_values);\n }\n "}, {"sha": "5cfbe1c9aee4f7276a3fe6f9840c9ad839e95358", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=a3648cfc0c331051ae47bedcc40c561f9979673a", "patch": "@@ -83,7 +83,7 @@ static void add_referenced_var (tree, struct walk_state *);\n /* Global declarations.  */\n \n /* Array of all variables referenced in the function.  */\n-VEC(tree,gc) *referenced_vars;\n+htab_t referenced_vars;\n \n \n /*---------------------------------------------------------------------------\n@@ -230,14 +230,14 @@ make_rename_temp (tree type, const char *prefix)\n void\n dump_referenced_vars (FILE *file)\n {\n-  size_t i;\n-\n+  tree var;\n+  referenced_var_iterator rvi;\n+  \n   fprintf (file, \"\\nReferenced variables in %s: %u\\n\\n\",\n \t   get_name (current_function_decl), (unsigned) num_referenced_vars);\n-\n-  for (i = 0; i < num_referenced_vars; i++)\n+  \n+  FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n-      tree var = referenced_var (i);\n       fprintf (file, \"Variable: \");\n       dump_variable (file, var);\n       fprintf (file, \"\\n\");\n@@ -278,7 +278,7 @@ dump_variable (FILE *file, tree var)\n \n   ann = var_ann (var);\n \n-  fprintf (file, \", UID %u\", (unsigned) ann->uid);\n+  fprintf (file, \", UID %u\", (unsigned) DECL_UID (var));\n \n   fprintf (file, \", \");\n   print_generic_expr (file, TREE_TYPE (var), dump_flags);\n@@ -528,6 +528,36 @@ find_vars_r (tree *tp, int *walk_subtrees, void *data)\n }\n \n \n+/* Lookup UID in the referenced_vars hashtable and return the associated\n+   variable.  */\n+\n+tree \n+referenced_var_lookup (unsigned int uid)\n+{\n+  struct int_tree_map *h, in;\n+  in.uid = uid;\n+  h = htab_find_with_hash (referenced_vars, &in, uid);\n+  gcc_assert (h || uid == 0);\n+  if (h)\n+    return h->to;\n+  return NULL_TREE;\n+}\n+\n+/* Insert the pair UID, TO into the referenced_vars hashtable.  */\n+\n+static void\n+referenced_var_insert (unsigned int uid, tree to)\n+{ \n+  struct int_tree_map *h;\n+  void **loc;\n+\n+  h = ggc_alloc (sizeof (struct int_tree_map));\n+  h->uid = uid;\n+  h->to = to;\n+  loc = htab_find_slot_with_hash (referenced_vars, h, uid, INSERT);\n+  *(struct int_tree_map **)  loc = h;\n+}\n+\n /* Add VAR to the list of dereferenced variables.\n \n    WALK_STATE contains a hash table used to avoid adding the same\n@@ -555,8 +585,8 @@ add_referenced_var (tree var, struct walk_state *walk_state)\n \t intrinsic to the variable.  */\n       if (slot)\n \t*slot = (void *) var;\n-      v_ann->uid = num_referenced_vars;\n-      VEC_safe_push (tree, gc, referenced_vars, var);\n+      \n+      referenced_var_insert (DECL_UID (var), var);\n \n       /* Global variables are always call-clobbered.  */\n       if (is_global_var (var))\n@@ -646,7 +676,7 @@ mark_new_vars_to_rename (tree stmt)\n     {\n       if (!DECL_P (val))\n \tval = SSA_NAME_VAR (val);\n-      bitmap_set_bit (vars_in_vops_to_rename, var_ann (val)->uid);\n+      bitmap_set_bit (vars_in_vops_to_rename, DECL_UID (val));\n     }\n \n   /* Now force an operand re-scan on the statement and mark any newly"}, {"sha": "13f94ac582de2ea90faa8bb7fb23b818cf2998ef", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 85, "deletions": 4, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=a3648cfc0c331051ae47bedcc40c561f9979673a", "patch": "@@ -25,6 +25,87 @@ Boston, MA 02110-1301, USA.  */\n /* Inline functions for manipulating various data structures defined in\n    tree-flow.h.  See tree-flow.h for documentation.  */\n \n+/* Initialize the hashtable iterator HTI to point to hashtable TABLE */\n+\n+static inline void *\n+first_htab_element (htab_iterator *hti, htab_t table)\n+{\n+  hti->htab = table;\n+  hti->slot = table->entries;\n+  hti->limit = hti->slot + htab_size (table);\n+  do\n+    {\n+      PTR x = *(hti->slot);\n+      if (x != HTAB_EMPTY_ENTRY && x != HTAB_DELETED_ENTRY)\n+\tbreak;\n+    } while (++(hti->slot) < hti->limit);\n+  \n+  if (hti->slot < hti->limit)\n+    return *(hti->slot);\n+  return NULL;\n+}\n+\n+/* Return current non-empty/deleted slot of the hashtable pointed to by HTI,\n+   or NULL if we have  reached the end.  */\n+\n+static inline bool\n+end_htab_p (htab_iterator *hti)\n+{\n+  if (hti->slot >= hti->limit)\n+    return true;\n+  return false;\n+}\n+\n+/* Advance the hashtable iterator pointed by HTI to the next element of the\n+   hashtable.  */\n+\n+static inline void *\n+next_htab_element (htab_iterator *hti)\n+{\n+  while (++(hti->slot) < hti->limit)\n+    {\n+      PTR x = *(hti->slot);\n+      if (x != HTAB_EMPTY_ENTRY && x != HTAB_DELETED_ENTRY)\n+\treturn x;\n+    };\n+  return NULL;\n+}\n+\n+/* Initialize ITER to point to the first referenced variable in the\n+   referenced_vars hashtable, and return that variable.  */\n+\n+static inline tree\n+first_referenced_var (referenced_var_iterator *iter)\n+{\n+  struct int_tree_map *itm;\n+  itm = first_htab_element (&iter->hti, referenced_vars);\n+  if (!itm) \n+    return NULL;\n+  return itm->to;\n+}\n+\n+/* Return true if we have hit the end of the referenced variables ITER is\n+   iterating through.  */\n+\n+static inline bool\n+end_referenced_vars_p (referenced_var_iterator *iter)\n+{\n+  return end_htab_p (&iter->hti);\n+}\n+\n+/* Make ITER point to the next referenced_var in the referenced_var hashtable,\n+   and return that variable.  */\n+\n+static inline tree\n+next_referenced_var (referenced_var_iterator *iter)\n+{\n+  struct int_tree_map *itm;\n+  itm = next_htab_element (&iter->hti);\n+  if (!itm) \n+    return NULL;\n+  return itm->to;\n+} \n+ \n /* Return the variable annotation for T, which must be a _DECL node.\n    Return NULL if the variable annotation doesn't already exist.  */\n static inline var_ann_t\n@@ -752,7 +833,7 @@ static inline bool\n is_call_clobbered (tree var)\n {\n   return is_global_var (var)\n-\t || bitmap_bit_p (call_clobbered_vars, var_ann (var)->uid);\n+    || bitmap_bit_p (call_clobbered_vars, DECL_UID (var));\n }\n \n /* Mark variable VAR as being clobbered by function calls.  */\n@@ -766,7 +847,7 @@ mark_call_clobbered (tree var)\n      location in global memory.  */\n   if (ann->mem_tag_kind != NOT_A_TAG && ann->mem_tag_kind != STRUCT_FIELD)\n     DECL_EXTERNAL (var) = 1;\n-  bitmap_set_bit (call_clobbered_vars, ann->uid);\n+  bitmap_set_bit (call_clobbered_vars, DECL_UID (var));\n   ssa_call_clobbered_cache_valid = false;\n   ssa_ro_call_cache_valid = false;\n }\n@@ -778,7 +859,7 @@ clear_call_clobbered (tree var)\n   var_ann_t ann = var_ann (var);\n   if (ann->mem_tag_kind != NOT_A_TAG && ann->mem_tag_kind != STRUCT_FIELD)\n     DECL_EXTERNAL (var) = 0;\n-  bitmap_clear_bit (call_clobbered_vars, ann->uid);\n+  bitmap_clear_bit (call_clobbered_vars, DECL_UID (var));\n   ssa_call_clobbered_cache_valid = false;\n   ssa_ro_call_cache_valid = false;\n }\n@@ -787,7 +868,7 @@ clear_call_clobbered (tree var)\n static inline void\n mark_non_addressable (tree var)\n {\n-  bitmap_clear_bit (call_clobbered_vars, var_ann (var)->uid);\n+  bitmap_clear_bit (call_clobbered_vars, DECL_UID (var));\n   TREE_ADDRESSABLE (var) = 0;\n   ssa_call_clobbered_cache_valid = false;\n   ssa_ro_call_cache_valid = false;"}, {"sha": "4a11a4eb49dbfa87dff18972b15dba1fd0499216", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 39, "deletions": 6, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=a3648cfc0c331051ae47bedcc40c561f9979673a", "patch": "@@ -41,6 +41,20 @@ typedef struct basic_block_def *basic_block;\n /* True if the code is in ssa form.  */\n extern bool in_ssa_p;\n \n+typedef struct\n+{\n+  htab_t htab;\n+  PTR *slot;\n+  PTR *limit;\n+} htab_iterator;\n+\n+/* Iterate through the elements of hashtable HTAB, using htab_iterator ITER,\n+   storing each element in RESULT, which is of type TYPE.  */\n+#define FOR_EACH_HTAB_ELEMENT(HTAB, RESULT, TYPE, ITER) \\\n+  for (RESULT = (TYPE) first_htab_element (&(ITER), (HTAB)); \\\n+\t!end_htab_p (&(ITER)); \\\n+\tRESULT = (TYPE) next_htab_element (&(ITER)))\n+\n /*---------------------------------------------------------------------------\n \t\t      Attributes for SSA_NAMEs.\n   \n@@ -208,9 +222,6 @@ struct var_ann_d GTY(())\n   /* Variables that may alias this variable.  */\n   varray_type may_aliases;\n \n-  /* Unique ID of this variable.  */\n-  size_t uid;\n-\n   /* Used when going out of SSA form to indicate which partition this\n      variable represents storage for.  */\n   unsigned partition;\n@@ -356,11 +367,33 @@ static inline void set_phi_nodes (basic_block, tree);\n /*---------------------------------------------------------------------------\n \t\t\t      Global declarations\n ---------------------------------------------------------------------------*/\n+struct int_tree_map GTY(())\n+{\n+  \n+  unsigned int uid;\n+  tree to;\n+};\n+\n+extern unsigned int int_tree_map_hash (const void *);\n+extern int int_tree_map_eq (const void *, const void *);\n+\n+typedef struct \n+{\n+  htab_iterator hti;\n+} referenced_var_iterator;\n+\n+\n+#define FOR_EACH_REFERENCED_VAR(VAR, ITER) \\\n+  for ((VAR) = first_referenced_var (&(ITER)); \\\n+       !end_referenced_vars_p (&(ITER)); \\\n+       (VAR) = next_referenced_var (&(ITER))) \n+\n /* Array of all variables referenced in the function.  */\n-extern GTY(()) VEC(tree,gc) *referenced_vars;\n+extern GTY((param_is (struct int_tree_map))) htab_t referenced_vars;\n \n-#define num_referenced_vars VEC_length (tree, referenced_vars)\n-#define referenced_var(i) VEC_index (tree, referenced_vars, i)\n+extern tree referenced_var_lookup (unsigned int);\n+#define num_referenced_vars htab_elements (referenced_vars)\n+#define referenced_var(i) referenced_var_lookup (i)\n \n /* Array of all SSA_NAMEs used in the function.  */\n extern GTY(()) VEC(tree,gc) *ssa_names;"}, {"sha": "02e587669d9a781590a1358455079faafa4ea0fc", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=a3648cfc0c331051ae47bedcc40c561f9979673a", "patch": "@@ -454,7 +454,7 @@ static inline bool\n symbol_marked_for_renaming (tree sym)\n {\n   gcc_assert (DECL_P (sym));\n-  return bitmap_bit_p (syms_to_rename, var_ann (sym)->uid);\n+  return bitmap_bit_p (syms_to_rename, DECL_UID (sym));\n }\n \n \n@@ -582,7 +582,7 @@ add_new_name_mapping (tree new, tree old)\n \t Otherwise, the insertion of PHI nodes for each of the old\n \t names in these mappings will be very slow.  */\n       sym = SSA_NAME_VAR (new);\n-      uid = var_ann (sym)->uid;\n+      uid = DECL_UID (sym);\n       update_ssa_stats.num_virtual_mappings++;\n       if (!bitmap_bit_p (update_ssa_stats.virtual_symbols, uid))\n \t{\n@@ -651,7 +651,7 @@ mark_def_sites (struct dom_walk_data *walk_data,\n     {\n       tree sym = USE_FROM_PTR (use_p);\n       gcc_assert (DECL_P (sym));\n-      if (!bitmap_bit_p (kills, var_ann (sym)->uid))\n+      if (!bitmap_bit_p (kills, DECL_UID (sym)))\n \tset_livein_block (sym, bb);\n       REWRITE_THIS_STMT (stmt) = 1;\n     }\n@@ -676,7 +676,7 @@ mark_def_sites (struct dom_walk_data *walk_data,\n     {\n       gcc_assert (DECL_P (def));\n       set_def_block (def, bb, false);\n-      bitmap_set_bit (kills, var_ann (def)->uid);\n+      bitmap_set_bit (kills, DECL_UID (def));\n       REGISTER_DEFS_IN_THIS_STMT (stmt) = 1;\n     }\n \n@@ -861,15 +861,15 @@ insert_phi_nodes_for (tree var, bitmap phi_insertion_points, bool update_p)\n static void\n insert_phi_nodes (bitmap *dfs)\n {\n-  unsigned i;\n+  referenced_var_iterator rvi;\n+  tree var;\n \n   timevar_push (TV_TREE_INSERT_PHI_NODES);\n-\n-  for (i = 0; i < num_referenced_vars; i++)\n+  \n+  FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n       struct def_blocks_d *def_map;\n       bitmap idf;\n-      tree var = referenced_var (i);\n \n       def_map = find_def_blocks_for (var);\n       if (def_map == NULL)\n@@ -1662,16 +1662,16 @@ mark_def_sites_initialize_block (struct dom_walk_data *walk_data,\n static void\n mark_def_site_blocks (sbitmap interesting_blocks)\n {\n-  size_t i;\n   struct dom_walk_data walk_data;\n   struct mark_def_sites_global_data mark_def_sites_global_data;\n+  referenced_var_iterator rvi;\n+  tree var;\n \n   /* Allocate memory for the DEF_BLOCKS hash table.  */\n-  def_blocks = htab_create (VEC_length (tree, referenced_vars),\n+  def_blocks = htab_create (num_referenced_vars,\n \t\t\t    def_blocks_hash, def_blocks_eq, def_blocks_free);\n-\n-  for (i = 0; i < num_referenced_vars; i++)\n-    set_current_def (referenced_var (i), NULL_TREE);\n+  FOR_EACH_REFERENCED_VAR(var, rvi)\n+    set_current_def (var, NULL_TREE);\n \n   /* Setup callbacks for the generic dominator tree walker to find and\n      mark definition sites.  */\n@@ -2287,7 +2287,7 @@ mark_sym_for_renaming (tree sym)\n   if (need_to_initialize_update_ssa_p)\n     init_update_ssa ();\n \n-  bitmap_set_bit (syms_to_rename, var_ann (sym)->uid);\n+  bitmap_set_bit (syms_to_rename, DECL_UID (sym));\n \n   if (!is_gimple_reg (sym))\n     need_to_update_vops_p = true;\n@@ -2769,7 +2769,7 @@ update_ssa (unsigned update_flags)\n \n       EXECUTE_IF_SET_IN_BITMAP (syms_to_rename, 0, i, bi)\n \tinsert_updated_phi_nodes_for (referenced_var (i), dfs, blocks,\n-\t                              update_flags);\n+\t    \t\t              update_flags);\n \n       FOR_EACH_BB (bb)\n \tBITMAP_FREE (dfs[bb->index]);"}, {"sha": "83659ab0e4e09043e2bbe7a9dc0fbb0d51699c9f", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=a3648cfc0c331051ae47bedcc40c561f9979673a", "patch": "@@ -151,7 +151,7 @@ static tree generate_element_ref (struct sra_elt *);\n static bool\n is_sra_candidate_decl (tree decl)\n {\n-  return DECL_P (decl) && bitmap_bit_p (sra_candidates, var_ann (decl)->uid);\n+  return DECL_P (decl) && bitmap_bit_p (sra_candidates, DECL_UID (decl));\n }\n \n /* Return true if TYPE is a scalar type.  */\n@@ -493,7 +493,7 @@ lookup_element (struct sra_elt *parent, tree child, tree type,\n       if (TREE_CODE (child) == PARM_DECL)\n \t{\n \t  elt->n_copies = 1;\n-\t  bitmap_set_bit (needs_copy_in, var_ann (child)->uid);\n+\t  bitmap_set_bit (needs_copy_in, DECL_UID (child));\n \t}\n     }\n \n@@ -940,15 +940,15 @@ sra_walk_function (const struct sra_walk_fns *fns)\n static bool\n find_candidates_for_sra (void)\n {\n-  size_t i;\n   bool any_set = false;\n+  tree var;\n+  referenced_var_iterator rvi;\n \n-  for (i = 0; i < num_referenced_vars; i++)\n+  FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n-      tree var = referenced_var (i);\n       if (decl_can_be_decomposed_p (var))\n         {\n-          bitmap_set_bit (sra_candidates, var_ann (var)->uid);\n+          bitmap_set_bit (sra_candidates, DECL_UID (var));\n           any_set = true;\n         }\n     }"}, {"sha": "91a01d2d48a0af0c64b5c02fd40b1aeacf8ee311", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 201, "deletions": 137, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=a3648cfc0c331051ae47bedcc40c561f9979673a", "patch": "@@ -43,6 +43,19 @@ Boston, MA 02110-1301, USA.  */\n #include \"convert.h\"\n #include \"params.h\"\n #include \"vec.h\"\n+#include \"bitmap.h\"\n+\n+/* Keep track of how many times each pointer has been dereferenced in\n+   the program using the aux variable.  This is used by the alias\n+   grouping heuristic in compute_flow_insensitive_aliasing.  */\n+#define NUM_REFERENCES(ANN) ((size_t)((ANN)->common.aux))\n+#define NUM_REFERENCES_CLEAR(ANN) ((ANN)->common.aux) = 0\n+#define NUM_REFERENCES_INC(ANN) (ANN)->common.aux = (void*) (((size_t)((ANN)->common.aux)) + 1)\n+#define NUM_REFERENCES_SET(ANN, VAL) (ANN)->common.aux = (void*) ((void *)(VAL))\n+\n+/* Obstack used to hold grouping bitmaps and other temporary bitmaps used by\n+   aliasing  */\n+static bitmap_obstack alias_obstack;\n \n /* 'true' after aliases have been computed (see compute_may_aliases).  */\n bool aliases_computed_p;\n@@ -66,7 +79,7 @@ struct alias_map_d\n   /* Set of variables aliased with VAR.  This is the exact same\n      information contained in VAR_ANN (VAR)->MAY_ALIASES, but in\n      bitmap form to speed up alias grouping.  */\n-  sbitmap may_aliases;\n+  bitmap may_aliases;\n };\n \n \n@@ -100,11 +113,6 @@ struct alias_info\n   /* Number of const/pure function calls found in the program.  */\n   size_t num_pure_const_calls_found;\n \n-  /* Array of counters to keep track of how many times each pointer has\n-     been dereferenced in the program.  This is used by the alias grouping\n-     heuristic in compute_flow_insensitive_aliasing.  */\n-  varray_type num_references;\n-\n   /* Total number of virtual operands that will be needed to represent\n      all the aliases of all the pointers found in the program.  */\n   long total_alias_vops;\n@@ -490,16 +498,18 @@ static struct alias_info *\n init_alias_info (void)\n {\n   struct alias_info *ai;\n+  referenced_var_iterator rvi;\n+  tree var;\n \n+  bitmap_obstack_initialize (&alias_obstack);\n   ai = xcalloc (1, sizeof (struct alias_info));\n   ai->ssa_names_visited = sbitmap_alloc (num_ssa_names);\n   sbitmap_zero (ai->ssa_names_visited);\n   VARRAY_TREE_INIT (ai->processed_ptrs, 50, \"processed_ptrs\");\n-  ai->addresses_needed = BITMAP_ALLOC (NULL);\n-  VARRAY_UINT_INIT (ai->num_references, num_referenced_vars, \"num_references\");\n-  ai->written_vars = BITMAP_ALLOC (NULL);\n-  ai->dereferenced_ptrs_store = BITMAP_ALLOC (NULL);\n-  ai->dereferenced_ptrs_load = BITMAP_ALLOC (NULL);\n+  ai->addresses_needed = BITMAP_ALLOC (&alias_obstack);\n+  ai->written_vars = BITMAP_ALLOC (&alias_obstack);\n+  ai->dereferenced_ptrs_store = BITMAP_ALLOC (&alias_obstack);\n+  ai->dereferenced_ptrs_load = BITMAP_ALLOC (&alias_obstack);\n \n   /* If aliases have been computed before, clear existing information.  */\n   if (aliases_computed_p)\n@@ -512,13 +522,13 @@ init_alias_info (void)\n       bitmap_clear (addressable_vars);\n \n       /* Clear flow-insensitive alias information from each symbol.  */\n-      for (i = 0; i < num_referenced_vars; i++)\n+      FOR_EACH_REFERENCED_VAR (var, rvi)\n \t{\n-\t  tree var = referenced_var (i);\n \t  var_ann_t ann = var_ann (var);\n-\n+\t  \n \t  ann->is_alias_tag = 0;\n \t  ann->may_aliases = NULL;\n+\t  NUM_REFERENCES_CLEAR (ann);\n \n \t  /* Since we are about to re-discover call-clobbered\n \t     variables, clear the call-clobbered flag.  Variables that\n@@ -577,29 +587,32 @@ static void\n delete_alias_info (struct alias_info *ai)\n {\n   size_t i;\n+  referenced_var_iterator rvi;\n+  tree var;\n \n   sbitmap_free (ai->ssa_names_visited);\n   ai->processed_ptrs = NULL;\n   BITMAP_FREE (ai->addresses_needed);\n \n   for (i = 0; i < ai->num_addressable_vars; i++)\n+    free (ai->addressable_vars[i]);\n+  \n+  FOR_EACH_REFERENCED_VAR(var, rvi)\n     {\n-      sbitmap_free (ai->addressable_vars[i]->may_aliases);\n-      free (ai->addressable_vars[i]);\n+      var_ann_t ann = var_ann (var);\n+      NUM_REFERENCES_CLEAR (ann);\n     }\n+\n   free (ai->addressable_vars);\n \n   for (i = 0; i < ai->num_pointers; i++)\n-    {\n-      sbitmap_free (ai->pointers[i]->may_aliases);\n-      free (ai->pointers[i]);\n-    }\n+    free (ai->pointers[i]);\n   free (ai->pointers);\n \n-  ai->num_references = NULL;\n   BITMAP_FREE (ai->written_vars);\n   BITMAP_FREE (ai->dereferenced_ptrs_store);\n   BITMAP_FREE (ai->dereferenced_ptrs_load);\n+  bitmap_obstack_release (&alias_obstack);\n \n   free (ai);\n }\n@@ -621,7 +634,6 @@ collect_points_to_info_for (struct alias_info *ai, tree ptr)\n     }\n }\n \n-\n /* Traverse use-def links for all the pointers in the program to collect\n    address escape and points-to information.\n    \n@@ -657,17 +669,18 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t     chains).  */\n \t  addr_taken = addresses_taken (stmt);\n \t  if (addr_taken)\n-\t    EXECUTE_IF_SET_IN_BITMAP (addr_taken, 0, i, bi)\n+\t    EXECUTE_IF_SET_IN_BITMAP (addr_taken, 0, i, bi) \n \t      {\n \t\ttree var = referenced_var (i);\n-\t\tbitmap_set_bit (ai->addresses_needed, var_ann (var)->uid);\n+\t\tbitmap_set_bit (ai->addresses_needed, DECL_UID (var));\n \t\tif (stmt_escapes_p)\n \t\t  mark_call_clobbered (var);\n \t      }\n \n \t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n \t    {\n-\t      var_ann_t v_ann = var_ann (SSA_NAME_VAR (op));\n+\t      tree var = SSA_NAME_VAR (op);\n+\t      var_ann_t v_ann = var_ann (var);\n \t      struct ptr_info_def *pi;\n \t      bool is_store;\n \t      unsigned num_uses, num_derefs;\n@@ -679,8 +692,8 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t\t because we are processing regular variables, not\n \t\t memory tags (the array's initial size is set to\n \t\t NUM_REFERENCED_VARS).  */\n-\t      if (may_be_aliased (SSA_NAME_VAR (op)))\n-\t\t(VARRAY_UINT (ai->num_references, v_ann->uid))++;\n+\t      if (may_be_aliased (var))\n+\t\tNUM_REFERENCES_INC (v_ann);\n \n \t      if (!POINTER_TYPE_P (TREE_TYPE (op)))\n \t\tcontinue;\n@@ -700,18 +713,18 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t\t  pi->is_dereferenced = 1;\n \n \t\t  /* Keep track of how many time we've dereferenced each\n-\t\t     pointer.  Again, we don't need to grow\n-\t\t     AI->NUM_REFERENCES because we're processing\n-\t\t     existing program variables.  */\n-\t\t  (VARRAY_UINT (ai->num_references, v_ann->uid))++;\n+\t\t     pointer.  */\n+\t\t  NUM_REFERENCES_INC (v_ann);\n \n \t\t  /* If this is a store operation, mark OP as being\n \t\t     dereferenced to store, otherwise mark it as being\n \t\t     dereferenced to load.  */\n \t\t  if (is_store)\n-\t\t    bitmap_set_bit (ai->dereferenced_ptrs_store, v_ann->uid);\n+\t\t    bitmap_set_bit (ai->dereferenced_ptrs_store, \n+\t\t\t\t    DECL_UID (var));\n \t\t  else\n-\t\t    bitmap_set_bit (ai->dereferenced_ptrs_load, v_ann->uid);\n+\t\t    bitmap_set_bit (ai->dereferenced_ptrs_load, \n+\t\t\t\t    DECL_UID (var));\n \t\t}\n \n \t      if (stmt_escapes_p && num_derefs < num_uses)\n@@ -727,7 +740,8 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t\t     operation inside the called function.  */\n \t\t  if (get_call_expr_in (stmt))\n \t\t    {\n-\t\t      bitmap_set_bit (ai->dereferenced_ptrs_store, v_ann->uid);\n+\t\t      bitmap_set_bit (ai->dereferenced_ptrs_store, \n+\t\t\t\t      DECL_UID (var));\n \t\t      pi->is_dereferenced = 1;\n \t\t    }\n \t\t}\n@@ -740,9 +754,9 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t    {\n \t      tree var = SSA_NAME_VAR (op);\n \t      var_ann_t ann = var_ann (var);\n-\t      bitmap_set_bit (ai->written_vars, ann->uid);\n+\t      bitmap_set_bit (ai->written_vars, DECL_UID (var));\n \t      if (may_be_aliased (var))\n-\t\t(VARRAY_UINT (ai->num_references, ann->uid))++;\n+\t\tNUM_REFERENCES_INC (ann);\n \n \t      if (POINTER_TYPE_P (TREE_TYPE (op)))\n \t\tcollect_points_to_info_for (ai, op);\n@@ -752,8 +766,7 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_VIRTUAL_DEFS)\n \t    {\n \t      tree var = DECL_P (op) ? op : SSA_NAME_VAR (op);\n-\t      var_ann_t ann = var_ann (var);\n-\t      bitmap_set_bit (ai->written_vars, ann->uid);\n+\t      bitmap_set_bit (ai->written_vars, DECL_UID (var));\n \t    }\n \t    \n \t  /* After promoting variables and computing aliasing we will\n@@ -861,7 +874,6 @@ create_name_tags (struct alias_info *ai)\n }\n \n \n-\n /* For every pointer P_i in AI->PROCESSED_PTRS, create may-alias sets for\n    the name memory tag (NMT) associated with P_i.  If P_i escapes, then its\n    name tag and the variables it points-to are call-clobbered.  Finally, if\n@@ -961,8 +973,7 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n       var_ann_t tag_ann = var_ann (tag);\n \n       p_map->total_alias_vops = 0;\n-      p_map->may_aliases = sbitmap_alloc (num_referenced_vars);\n-      sbitmap_zero (p_map->may_aliases);\n+      p_map->may_aliases = BITMAP_ALLOC (&alias_obstack);\n \n       for (j = 0; j < ai->num_addressable_vars; j++)\n \t{\n@@ -985,9 +996,9 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n \t     So we first check the call_clobbered status of the\n \t     tag and variable before querying the bitmap.  */\n \t  tag_stored_p = is_call_clobbered (tag)\n-\t\t\t || bitmap_bit_p (ai->written_vars, tag_ann->uid);\n+\t    || bitmap_bit_p (ai->written_vars, DECL_UID (tag));\n \t  var_stored_p = is_call_clobbered (var)\n-\t\t\t || bitmap_bit_p (ai->written_vars, v_ann->uid);\n+\t    || bitmap_bit_p (ai->written_vars, DECL_UID (var));\n \t  if (!tag_stored_p && !var_stored_p)\n \t    continue;\n \n@@ -996,8 +1007,8 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n \t      subvar_t svars;\n \t      size_t num_tag_refs, num_var_refs;\n \n-\t      num_tag_refs = VARRAY_UINT (ai->num_references, tag_ann->uid);\n-\t      num_var_refs = VARRAY_UINT (ai->num_references, v_ann->uid);\n+\t      num_tag_refs = NUM_REFERENCES (tag_ann);\n+\t      num_var_refs = NUM_REFERENCES (v_ann);\n \n \t      /* Add VAR to TAG's may-aliases set.  */\n \n@@ -1013,15 +1024,15 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n \t\t      add_may_alias (tag, sv->var);\n \t\t      /* Update the bitmap used to represent TAG's alias set\n \t\t\t in case we need to group aliases.  */\n-\t\t      SET_BIT (p_map->may_aliases, var_ann (sv->var)->uid);\n+\t\t      bitmap_set_bit (p_map->may_aliases, DECL_UID (sv->var));\n \t\t    }\n \t\t}\n \t      else\n \t\t{\n \t\t  add_may_alias (tag, var);\n \t\t  /* Update the bitmap used to represent TAG's alias set\n \t\t     in case we need to group aliases.  */\n-\t\t  SET_BIT (p_map->may_aliases, var_ann (var)->uid);\n+\t\t  bitmap_set_bit (p_map->may_aliases, DECL_UID (var));\n \t\t}\n \n \t      /* Update the total number of virtual operands due to\n@@ -1063,44 +1074,44 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n       size_t j;\n       struct alias_map_d *p_map1 = ai->pointers[i];\n       tree tag1 = var_ann (p_map1->var)->type_mem_tag;\n-      sbitmap may_aliases1 = p_map1->may_aliases;\n+      bitmap may_aliases1 = p_map1->may_aliases;\n \n       for (j = i + 1; j < ai->num_pointers; j++)\n \t{\n \t  struct alias_map_d *p_map2 = ai->pointers[j];\n \t  tree tag2 = var_ann (p_map2->var)->type_mem_tag;\n-\t  sbitmap may_aliases2 = p_map2->may_aliases;\n+\t  bitmap may_aliases2 = p_map2->may_aliases;\n \n \t  /* If the pointers may not point to each other, do nothing.  */\n \t  if (!may_alias_p (p_map1->var, p_map1->set, tag2, p_map2->set))\n \t    continue;\n \n \t  /* The two pointers may alias each other.  If they already have\n \t     symbols in common, do nothing.  */\n-\t  if (sbitmap_any_common_bits (may_aliases1, may_aliases2))\n+\t  if (bitmap_intersect_p (may_aliases1, may_aliases2))\n \t    continue;\n \n-\t  if (sbitmap_first_set_bit (may_aliases2) >= 0)\n+\t  if (!bitmap_empty_p (may_aliases2))\n \t    {\n \t      unsigned int k;\n-\t      sbitmap_iterator sbi;\n+\t      bitmap_iterator bi;\n \n \t      /* Add all the aliases for TAG2 into TAG1's alias set.\n \t\t FIXME, update grouping heuristic counters.  */\n-\t      EXECUTE_IF_SET_IN_SBITMAP (may_aliases2, 0, k, sbi)\n+\t      EXECUTE_IF_SET_IN_BITMAP (may_aliases2, 0, k, bi)\n \t\tadd_may_alias (tag1, referenced_var (k));\n-\t      sbitmap_a_or_b (may_aliases1, may_aliases1, may_aliases2);\n+\t      bitmap_ior_into (may_aliases1, may_aliases2);\n \t    }\n \t  else\n \t    {\n \t      /* Since TAG2 does not have any aliases of its own, add\n \t\t TAG2 itself to the alias set of TAG1.  */\n \t      add_may_alias (tag1, tag2);\n-\t      SET_BIT (may_aliases1, var_ann (tag2)->uid);\n+\t      bitmap_set_bit (may_aliases1, DECL_UID (tag2));\n \t    }\n \t}\n     }\n-\n+  \n   if (dump_file)\n     fprintf (dump_file, \"%s: Total number of aliased vops: %ld\\n\",\n \t     get_name (current_function_decl),\n@@ -1141,14 +1152,14 @@ total_alias_vops_cmp (const void *p, const void *q)\n \tmay-aliases(V2) = { TAG }  */\n \n static void\n-group_aliases_into (tree tag, sbitmap tag_aliases, struct alias_info *ai)\n+group_aliases_into (tree tag, bitmap tag_aliases, struct alias_info *ai)\n {\n   unsigned int i;\n   var_ann_t tag_ann = var_ann (tag);\n-  size_t num_tag_refs = VARRAY_UINT (ai->num_references, tag_ann->uid);\n-  sbitmap_iterator sbi;\n+  size_t num_tag_refs = NUM_REFERENCES (tag_ann);\n+  bitmap_iterator bi;\n \n-  EXECUTE_IF_SET_IN_SBITMAP (tag_aliases, 0, i, sbi)\n+  EXECUTE_IF_SET_IN_BITMAP (tag_aliases, 0, i, bi)\n     {\n       tree var = referenced_var (i);\n       var_ann_t ann = var_ann (var);\n@@ -1256,7 +1267,7 @@ group_aliases (struct alias_info *ai)\n     {\n       size_t j;\n       tree tag1 = var_ann (ai->pointers[i]->var)->type_mem_tag;\n-      sbitmap tag1_aliases = ai->pointers[i]->may_aliases;\n+      bitmap tag1_aliases = ai->pointers[i]->may_aliases;\n \n       /* Skip tags that have been grouped already.  */\n       if (ai->pointers[i]->grouped_p)\n@@ -1267,16 +1278,16 @@ group_aliases (struct alias_info *ai)\n \t aliases into TAG1.  */\n       for (j = i + 1; j < ai->num_pointers; j++)\n \t{\n-\t  sbitmap tag2_aliases = ai->pointers[j]->may_aliases;\n+\t  bitmap tag2_aliases = ai->pointers[j]->may_aliases;\n \n-          if (sbitmap_any_common_bits (tag1_aliases, tag2_aliases))\n+          if (bitmap_intersect_p (tag1_aliases, tag2_aliases))\n \t    {\n \t      tree tag2 = var_ann (ai->pointers[j]->var)->type_mem_tag;\n \n-\t      sbitmap_a_or_b (tag1_aliases, tag1_aliases, tag2_aliases);\n+\t      bitmap_ior_into (tag1_aliases, tag2_aliases);\n \n \t      /* TAG2 does not need its aliases anymore.  */\n-\t      sbitmap_zero (tag2_aliases);\n+\t      bitmap_clear (tag2_aliases);\n \t      var_ann (tag2)->may_aliases = NULL;\n \n \t      /* TAG1 is the unique alias of TAG2.  */\n@@ -1372,14 +1383,15 @@ create_alias_map_for (tree var, struct alias_info *ai)\n static void\n setup_pointers_and_addressables (struct alias_info *ai)\n {\n-  size_t i, n_vars, num_addressable_vars, num_pointers;\n+  size_t n_vars, num_addressable_vars, num_pointers;\n+  referenced_var_iterator rvi;\n+  tree var;\n \n   /* Size up the arrays ADDRESSABLE_VARS and POINTERS.  */\n   num_addressable_vars = num_pointers = 0;\n-  for (i = 0; i < num_referenced_vars; i++)\n+  \n+  FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n-      tree var = referenced_var (i);\n-\n       if (may_be_aliased (var))\n \tnum_addressable_vars++;\n \n@@ -1388,7 +1400,7 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \t  /* Since we don't keep track of volatile variables, assume that\n \t     these pointers are used in indirect store operations.  */\n \t  if (TREE_THIS_VOLATILE (var))\n-\t    bitmap_set_bit (ai->dereferenced_ptrs_store, var_ann (var)->uid);\n+\t    bitmap_set_bit (ai->dereferenced_ptrs_store, DECL_UID (var));\n \n \t  num_pointers++;\n \t}\n@@ -1410,9 +1422,8 @@ setup_pointers_and_addressables (struct alias_info *ai)\n      unnecessarily.  */\n   n_vars = num_referenced_vars;\n \n-  for (i = 0; i < n_vars; i++)\n+  FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n-      tree var = referenced_var (i);\n       var_ann_t v_ann = var_ann (var);\n       subvar_t svars;\n \n@@ -1436,7 +1447,7 @@ setup_pointers_and_addressables (struct alias_info *ai)\n          cleanup passes.  */\n       if (TREE_ADDRESSABLE (var) && v_ann->mem_tag_kind != STRUCT_FIELD)\n \t{\n-\t  if (!bitmap_bit_p (ai->addresses_needed, v_ann->uid)\n+\t  if (!bitmap_bit_p (ai->addresses_needed, DECL_UID (var))\n \t      && TREE_CODE (var) != RESULT_DECL\n \t      && !is_global_var (var))\n \t    {\n@@ -1453,8 +1464,8 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \n \t\t  for (sv = svars; sv; sv = sv->next)\n \t\t    {\t      \n-\t\t      var_ann_t svann = var_ann (sv->var);\n-\t\t      if (bitmap_bit_p (ai->addresses_needed, svann->uid))\n+\t\t      if (bitmap_bit_p (ai->addresses_needed, \n+\t\t\t\t\tDECL_UID (sv->var)))\n \t\t\tokay_to_mark = false;\n \t\t      mark_sym_for_renaming (sv->var);\n \t\t    }\n@@ -1472,13 +1483,13 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \t\t used when scanning operands for ASM_EXPRs that\n \t\t clobber memory.  In those cases, we need to clobber\n \t\t all call-clobbered variables and all addressables.  */\n-\t      bitmap_set_bit (addressable_vars, v_ann->uid);\n+\t      bitmap_set_bit (addressable_vars, DECL_UID (var));\n \t      if (var_can_have_subvars (var)\n \t\t  && (svars = get_subvars_for_var (var)))\n \t\t{\n \t\t  subvar_t sv;\n \t\t  for (sv = svars; sv; sv = sv->next)\n-\t\t    bitmap_set_bit (addressable_vars, var_ann (sv->var)->uid);\n+\t\t    bitmap_set_bit (addressable_vars, DECL_UID (sv->var));\n \t\t}\n \n \t    }\n@@ -1496,8 +1507,8 @@ setup_pointers_and_addressables (struct alias_info *ai)\n          array and create a type memory tag for them.  */\n       if (POINTER_TYPE_P (TREE_TYPE (var)))\n \t{\n-\t  if ((bitmap_bit_p (ai->dereferenced_ptrs_store, v_ann->uid)\n-\t\t|| bitmap_bit_p (ai->dereferenced_ptrs_load, v_ann->uid)))\n+\t  if ((bitmap_bit_p (ai->dereferenced_ptrs_store, DECL_UID (var))\n+\t       || bitmap_bit_p (ai->dereferenced_ptrs_load, DECL_UID (var))))\n \t    {\n \t      tree tag;\n \t      var_ann_t t_ann;\n@@ -1525,8 +1536,8 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \n \t      /* If pointer VAR has been used in a store operation,\n \t\t then its memory tag must be marked as written-to.  */\n-\t      if (bitmap_bit_p (ai->dereferenced_ptrs_store, v_ann->uid))\n-\t\tbitmap_set_bit (ai->written_vars, t_ann->uid);\n+\t      if (bitmap_bit_p (ai->dereferenced_ptrs_store, DECL_UID (var)))\n+\t\tbitmap_set_bit (ai->written_vars, DECL_UID (tag));\n \n \t      /* If pointer VAR is a global variable or a PARM_DECL,\n \t\t then its memory tag should be considered a global\n@@ -1537,13 +1548,11 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \t      /* All the dereferences of pointer VAR count as\n \t\t references of TAG.  Since TAG can be associated with\n \t\t several pointers, add the dereferences of VAR to the\n-\t\t TAG.  We may need to grow AI->NUM_REFERENCES because\n-\t\t we have been adding name and type tags.  */\n-\t      if (t_ann->uid >= VARRAY_SIZE (ai->num_references))\n-\t\tVARRAY_GROW (ai->num_references, t_ann->uid + 10);\n+\t\t TAG.  */\n \n-\t      VARRAY_UINT (ai->num_references, t_ann->uid)\n-\t\t+= VARRAY_UINT (ai->num_references, v_ann->uid);\n+\t      NUM_REFERENCES_SET (t_ann, \n+\t\t\t\t  NUM_REFERENCES (t_ann) + \n+\t\t\t\t  NUM_REFERENCES (v_ann));\n \t    }\n \t  else\n \t    {\n@@ -1643,7 +1652,7 @@ maybe_create_global_var (struct alias_info *ai)\n \n   /* Mark all call-clobbered symbols for renaming.  Since the initial\n      rewrite into SSA ignored all call sites, we may need to rename\n-     .GLOBAL_VAR and the call-clobbered variables.  */\n+     .GLOBAL_VAR and the call-clobbered variables.   */\n   EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i, bi)\n     {\n       tree var = referenced_var (i);\n@@ -2019,7 +2028,7 @@ add_pointed_to_var (struct alias_info *ai, tree ptr, tree value)\n       subvar_t sv;\n       svars = get_subvars_for_var (ref);\n \n-      uid = var_ann (pt_var)->uid;\n+      uid = DECL_UID (pt_var);\n       \n       if (pi->pt_vars == NULL)\n \tpi->pt_vars = BITMAP_GGC_ALLOC ();\n@@ -2032,15 +2041,15 @@ add_pointed_to_var (struct alias_info *ai, tree ptr, tree value)\n \t{\n \t  if (overlap_subvar (offset, size, sv, NULL))\n \t    {\n-\t      bitmap_set_bit (pi->pt_vars, var_ann (sv->var)->uid);\n-\t      bitmap_set_bit (ai->addresses_needed, var_ann (sv->var)->uid);\n+\t      bitmap_set_bit (pi->pt_vars, DECL_UID (sv->var));\n+\t      bitmap_set_bit (ai->addresses_needed, DECL_UID (sv->var));\n \t    }\n \t}\n     }\n   else if (pt_var && SSA_VAR_P (pt_var))\n     {\n     \n-      uid = var_ann (pt_var)->uid;\n+      uid = DECL_UID (pt_var);\n       \n       if (pi->pt_vars == NULL)\n \tpi->pt_vars = BITMAP_GGC_ALLOC ();\n@@ -2053,7 +2062,7 @@ add_pointed_to_var (struct alias_info *ai, tree ptr, tree value)\n \t  subvar_t sv;\n \t  for (sv = svars; sv; sv = sv->next)\n \t    {\n-\t      uid = var_ann (sv->var)->uid;\n+\t      uid = DECL_UID (sv->var);\n \t      bitmap_set_bit (ai->addresses_needed, uid);\t      \n \t      bitmap_set_bit (pi->pt_vars, uid);\n \t    }\n@@ -2419,30 +2428,32 @@ dump_alias_info (FILE *file)\n   size_t i;\n   const char *funcname\n     = lang_hooks.decl_printable_name (current_function_decl, 2);\n+  referenced_var_iterator rvi;\n+  tree var;\n \n   fprintf (file, \"\\nFlow-insensitive alias information for %s\\n\\n\", funcname);\n \n   fprintf (file, \"Aliased symbols\\n\\n\");\n-  for (i = 0; i < num_referenced_vars; i++)\n+  \n+  FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n-      tree var = referenced_var (i);\n       if (may_be_aliased (var))\n \tdump_variable (file, var);\n     }\n \n   fprintf (file, \"\\nDereferenced pointers\\n\\n\");\n-  for (i = 0; i < num_referenced_vars; i++)\n+\n+  FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n-      tree var = referenced_var (i);\n       var_ann_t ann = var_ann (var);\n       if (ann->type_mem_tag)\n \tdump_variable (file, var);\n     }\n \n   fprintf (file, \"\\nType memory tags\\n\\n\");\n-  for (i = 0; i < num_referenced_vars; i++)\n+  \n+  FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n-      tree var = referenced_var (i);\n       var_ann_t ann = var_ann (var);\n       if (ann->mem_tag_kind == TYPE_TAG)\n \tdump_variable (file, var);\n@@ -2467,9 +2478,9 @@ dump_alias_info (FILE *file)\n     }\n \n   fprintf (file, \"\\nName memory tags\\n\\n\");\n-  for (i = 0; i < num_referenced_vars; i++)\n+  \n+  FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n-      tree var = referenced_var (i);\n       var_ann_t ann = var_ann (var);\n       if (ann->mem_tag_kind == NAME_TAG)\n \tdump_variable (file, var);\n@@ -2578,19 +2589,19 @@ dump_points_to_info (FILE *file)\n {\n   basic_block bb;\n   block_stmt_iterator si;\n-  size_t i;\n   ssa_op_iter iter;\n   const char *fname =\n     lang_hooks.decl_printable_name (current_function_decl, 2);\n+  referenced_var_iterator rvi;\n+  tree var;\n \n   fprintf (file, \"\\n\\nPointed-to sets for pointers in %s\\n\\n\", fname);\n \n   /* First dump points-to information for the default definitions of\n      pointer variables.  This is necessary because default definitions are\n      not part of the code.  */\n-  for (i = 0; i < num_referenced_vars; i++)\n+  FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n-      tree var = referenced_var (i);\n       if (POINTER_TYPE_P (TREE_TYPE (var)))\n \t{\n \t  var_ann_t ann = var_ann (var);\n@@ -2709,13 +2720,14 @@ add_type_alias (tree ptr, tree var)\n   tree tag;\n   var_ann_t ann = var_ann (ptr);\n   subvar_t svars;\n+  \n \n   if (ann->type_mem_tag == NULL_TREE)\n     {\n-      size_t i;\n       tree q = NULL_TREE;\n       tree tag_type = TREE_TYPE (TREE_TYPE (ptr));\n       HOST_WIDE_INT tag_set = get_alias_set (tag_type);\n+      referenced_var_iterator rvi;\n \n       /* PTR doesn't have a type tag, create a new one and add VAR to\n \t the new tag's alias set.\n@@ -2724,10 +2736,8 @@ add_type_alias (tree ptr, tree var)\n \t whether there is another pointer Q with the same alias set as\n \t PTR.  This could be sped up by having type tags associated\n \t with types.  */\n-      for (i = 0; i < num_referenced_vars; i++)\n+      FOR_EACH_REFERENCED_VAR (q, rvi)\n \t{\n-\t  q = referenced_var (i);\n-\n \t  if (POINTER_TYPE_P (TREE_TYPE (q))\n \t      && tag_set == get_alias_set (TREE_TYPE (TREE_TYPE (q))))\n \t    {\n@@ -2853,6 +2863,8 @@ new_type_alias (tree ptr, tree var)\n     }    \n }\n \n+\n+\n /* This represents the used range of a variable.  */\n \n typedef struct used_part\n@@ -2870,7 +2882,68 @@ typedef struct used_part\n \n /* An array of used_part structures, indexed by variable uid.  */\n \n-static used_part_t *used_portions;\n+static htab_t used_portions;\n+\n+struct used_part_map\n+{\n+  unsigned int uid;\n+  used_part_t to;\n+};\n+\n+/* Return true if the uid in the two used part maps are equal.  */\n+\n+static int\n+used_part_map_eq (const void *va, const void *vb)\n+{\n+  const struct used_part_map  *a = va, *b = vb;\n+  return (a->uid == b->uid);\n+}\n+\n+/* Hash a from uid in a used_part_map.  */\n+\n+static unsigned int\n+used_part_map_hash (const void *item)\n+{\n+  return ((const struct used_part_map *)item)->uid;\n+}\n+\n+/* Free a used part map element.  */\n+\n+static void \n+free_used_part_map (void *item)\n+{\n+  free (((struct used_part_map *)item)->to);\n+}\n+\n+/* Lookup a used_part structure for a UID.  */\n+\n+static used_part_t\n+up_lookup (unsigned int uid)\n+{\n+  struct used_part_map *h, in;\n+  in.uid = uid;\n+  h = htab_find_with_hash (used_portions, &in, uid);\n+  if (!h)\n+    return NULL;\n+  return h->to;\n+}\n+\n+/* Insert the pair UID, TO into the used part hashtable.  */\n+ \n+static void \n+up_insert (unsigned int uid, used_part_t to)\n+{ \n+  struct used_part_map *h;\n+  void **loc;\n+\n+  h = xmalloc (sizeof (struct used_part_map));\n+  h->uid = uid;\n+  h->to = to;\n+  loc = htab_find_slot_with_hash (used_portions, h,\n+\t\t\t\t  uid, INSERT);\n+  *(struct used_part_map **)  loc = h;\n+}\n+\n \n /* Given a variable uid, UID, get or create the entry in the used portions\n    table for the variable.  */\n@@ -2879,16 +2952,15 @@ static used_part_t\n get_or_create_used_part_for (size_t uid)\n {\n   used_part_t up;\n-  if (used_portions[uid] == NULL)\n+  if ((up = up_lookup (uid)) == NULL)\n     {\n       up = xcalloc (1, sizeof (struct used_part));\n       up->minused = INT_MAX;\n       up->maxused = 0;\n       up->explicit_uses = false;\n       up->implicit_uses = false;\n     }\n-  else\n-    up = used_portions[uid];\n+\n   return up;\n }\n \n@@ -2901,12 +2973,12 @@ create_overlap_variables_for (tree var)\n {\n   VEC(fieldoff_s,heap) *fieldstack = NULL;\n   used_part_t up;\n-  size_t uid = var_ann (var)->uid;\n+  size_t uid = DECL_UID (var);\n \n-  if (used_portions[uid] == NULL)\n+  if (!up_lookup (uid))\n     return;\n \n-  up = used_portions[uid];\n+  up = up_lookup (uid);\n   push_fields_onto_fieldstack (TREE_TYPE (var), &fieldstack, 0, NULL);\n   if (VEC_length (fieldoff_s, fieldstack) != 0)\n     {\n@@ -3079,7 +3151,7 @@ find_used_portions (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \t\t\t\t   &unsignedp, &volatilep, false);\n \tif (DECL_P (ref) && offset == NULL && bitsize != -1)\n \t  {\t    \n-\t    size_t uid = var_ann (ref)->uid;\n+\t    size_t uid = DECL_UID (ref);\n \t    used_part_t up;\n \n \t    up = get_or_create_used_part_for (uid);\t    \n@@ -3090,7 +3162,7 @@ find_used_portions (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \t      up->maxused = bitpos + bitsize;\t    \n \n \t    up->explicit_uses = true;\n-\t    used_portions[uid] = up;\n+\t    up_insert (uid, up);\n \n \t    *walk_subtrees = 0;\n \t    return NULL_TREE;\n@@ -3102,7 +3174,7 @@ find_used_portions (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \t\t&& TREE_CODE (DECL_SIZE (ref)) == INTEGER_CST)\n \t      {\n \t\tused_part_t up;\n-\t\tsize_t uid = var_ann (ref)->uid;\n+\t\tsize_t uid = DECL_UID (ref);\n \n \t\tup = get_or_create_used_part_for (uid);\n \n@@ -3111,7 +3183,7 @@ find_used_portions (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \n \t\tup->implicit_uses = true;\n \n-\t\tused_portions[uid] = up;\n+\t\tup_insert (uid, up);\n \n \t\t*walk_subtrees = 0;\n \t\treturn NULL_TREE;\n@@ -3134,15 +3206,15 @@ find_used_portions (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \t    && TREE_CODE (DECL_SIZE (var)) == INTEGER_CST)\n \t  {\n \t    used_part_t up;\n-\t    size_t uid = var_ann (var)->uid;\t    \n+\t    size_t uid = DECL_UID (var);\n \t    \n \t    up = get_or_create_used_part_for (uid);\n  \n \t    up->minused = 0;\n \t    up->maxused = TREE_INT_CST_LOW (DECL_SIZE (var));\n \t    up->implicit_uses = true;\n \n-\t    used_portions[uid] = up;\n+\t    up_insert (uid, up);\n \t    *walk_subtrees = 0;\n \t    return NULL_TREE;\n \t  }\n@@ -3157,15 +3229,15 @@ find_used_portions (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \t    && TREE_CODE (DECL_SIZE (var)) == INTEGER_CST)\n \t  {\n \t    used_part_t up;\n-\t    size_t uid = var_ann (var)->uid;\t    \n+\t    size_t uid = DECL_UID (var);\n \t    \n \t    up = get_or_create_used_part_for (uid);\n  \n \t    up->minused = 0;\n \t    up->maxused = TREE_INT_CST_LOW (DECL_SIZE (var));\n \t    up->implicit_uses = true;\n \n-\t    used_portions[uid] = up;\n+\t    up_insert (uid, up);\n \t    *walk_subtrees = 0;\n \t    return NULL_TREE;\n \t  }\n@@ -3179,22 +3251,17 @@ find_used_portions (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n   return NULL_TREE;\n }\n \n-/* We are about to create some new referenced variables, and we need the\n-   before size.  */\n-\n-static size_t old_referenced_vars;\n-\n-\n /* Create structure field variables for structures used in this function.  */\n \n static void\n create_structure_vars (void)\n {\n   basic_block bb;\n-  size_t i;\n+  referenced_var_iterator rvi;\n+  tree var;\n \n-  old_referenced_vars = num_referenced_vars;\n-  used_portions = xcalloc (num_referenced_vars, sizeof (used_part_t));\n+  used_portions = htab_create (10, used_part_map_hash, used_part_map_eq, \n+                               free_used_part_map);\n   \n   FOR_EACH_BB (bb)\n     {\n@@ -3206,9 +3273,8 @@ create_structure_vars (void)\n \t\t\t\t\tNULL);\n \t}\n     }\n-  for (i = 0; i < old_referenced_vars; i++)\n+  FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n-      tree var = referenced_var (i);\n       /* The C++ FE creates vars without DECL_SIZE set, for some reason.  */\n       if (var \t  \n \t  && DECL_SIZE (var)\n@@ -3217,10 +3283,8 @@ create_structure_vars (void)\n \t  && TREE_CODE (DECL_SIZE (var)) == INTEGER_CST)\n \tcreate_overlap_variables_for (var);\n     }\n-  for (i = 0; i < old_referenced_vars; i++)\n-    free (used_portions[i]);\n+  htab_delete (used_portions);\n \n-  free (used_portions);\n }\n \n static bool"}, {"sha": "1647292b5e6d727896f3a7e148bad4c3113d7dbc", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=a3648cfc0c331051ae47bedcc40c561f9979673a", "patch": "@@ -341,18 +341,15 @@ create_ssa_var_map (int flags)\n   var_map map;\n   ssa_op_iter iter;\n #ifdef ENABLE_CHECKING\n-  sbitmap used_in_real_ops;\n-  sbitmap used_in_virtual_ops;\n+  bitmap used_in_real_ops;\n+  bitmap used_in_virtual_ops;\n #endif\n \n   map = init_var_map (num_ssa_names + 1);\n \n #ifdef ENABLE_CHECKING\n-  used_in_real_ops = sbitmap_alloc (num_referenced_vars);\n-  sbitmap_zero (used_in_real_ops);\n-\n-  used_in_virtual_ops = sbitmap_alloc (num_referenced_vars);\n-  sbitmap_zero (used_in_virtual_ops);\n+  used_in_real_ops = BITMAP_ALLOC (NULL);\n+  used_in_virtual_ops = BITMAP_ALLOC (NULL);\n #endif\n \n   if (flags & SSA_VAR_MAP_REF_COUNT)\n@@ -389,7 +386,7 @@ create_ssa_var_map (int flags)\n \t      register_ssa_partition (map, use, true);\n \n #ifdef ENABLE_CHECKING\n-\t      SET_BIT (used_in_real_ops, var_ann (SSA_NAME_VAR (use))->uid);\n+\t      bitmap_set_bit (used_in_real_ops, DECL_UID (SSA_NAME_VAR (use)));\n #endif\n \t    }\n \n@@ -398,7 +395,7 @@ create_ssa_var_map (int flags)\n \t      register_ssa_partition (map, dest, false);\n \n #ifdef ENABLE_CHECKING\n-\t      SET_BIT (used_in_real_ops, var_ann (SSA_NAME_VAR (dest))->uid);\n+\t      bitmap_set_bit (used_in_real_ops, DECL_UID (SSA_NAME_VAR (dest)));\n #endif\n \t    }\n \n@@ -407,7 +404,8 @@ create_ssa_var_map (int flags)\n \t  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, \n \t\t\t\t     SSA_OP_VIRTUAL_USES | SSA_OP_VMUSTDEF)\n \t    {\n-\t      SET_BIT (used_in_virtual_ops, var_ann (SSA_NAME_VAR (use))->uid);\n+\t      bitmap_set_bit (used_in_virtual_ops, \n+\t\t\t      DECL_UID (SSA_NAME_VAR (use)));\n \t    }\n \n #endif /* ENABLE_CHECKING */\n@@ -419,21 +417,21 @@ create_ssa_var_map (int flags)\n #if defined ENABLE_CHECKING\n   {\n     unsigned i;\n-    sbitmap both = sbitmap_alloc (num_referenced_vars);\n-    sbitmap_a_and_b (both, used_in_real_ops, used_in_virtual_ops);\n-    if (sbitmap_first_set_bit (both) >= 0)\n+    bitmap both = BITMAP_ALLOC (NULL);\n+    bitmap_and (both, used_in_real_ops, used_in_virtual_ops);\n+    if (!bitmap_empty_p (both))\n       {\n-\tsbitmap_iterator sbi;\n+\tbitmap_iterator bi;\n \n-\tEXECUTE_IF_SET_IN_SBITMAP (both, 0, i, sbi)\n+\tEXECUTE_IF_SET_IN_BITMAP (both, 0, i, bi)\n \t  fprintf (stderr, \"Variable %s used in real and virtual operands\\n\",\n \t\t   get_name (referenced_var (i)));\n \tinternal_error (\"SSA corruption\");\n       }\n \n-    sbitmap_free (used_in_real_ops);\n-    sbitmap_free (used_in_virtual_ops);\n-    sbitmap_free (both);\n+    BITMAP_FREE (used_in_real_ops);\n+    BITMAP_FREE (used_in_virtual_ops);\n+    BITMAP_FREE (both);\n   }\n #endif\n "}, {"sha": "e3476c69b2ac45876bb4bfe81ce4134823913dac", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=a3648cfc0c331051ae47bedcc40c561f9979673a", "patch": "@@ -1165,20 +1165,14 @@ gather_mem_refs_stmt (struct loop *loop, htab_t mem_refs,\n \n   FOR_EACH_SSA_TREE_OPERAND (vname, stmt, oi,\n \t\t\t     SSA_OP_VIRTUAL_USES | SSA_OP_VIRTUAL_KILLS)\n-    {\n-      bitmap_set_bit (ref->vops,\n-\t\t      var_ann (SSA_NAME_VAR (vname))->uid);\n-    }\n+    bitmap_set_bit (ref->vops, DECL_UID (SSA_NAME_VAR (vname)));\n   record_mem_ref_loc (&ref->locs, stmt, mem);\n   return;\n \n fail:\n   FOR_EACH_SSA_TREE_OPERAND (vname, stmt, oi,\n \t\t\t     SSA_OP_VIRTUAL_USES | SSA_OP_VIRTUAL_KILLS)\n-    {\n-      bitmap_set_bit (clobbered_vops,\n-\t\t      var_ann (SSA_NAME_VAR (vname))->uid);\n-    }\n+    bitmap_set_bit (clobbered_vops, DECL_UID (SSA_NAME_VAR (vname)));\n }\n \n /* Gathers memory references in LOOP.  Notes vops accessed through unrecognized"}, {"sha": "f0900248d199a20d58545a4becbb7eef246e3044", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=a3648cfc0c331051ae47bedcc40c561f9979673a", "patch": "@@ -1555,10 +1555,10 @@ get_asm_expr_operands (tree stmt)\n \t  add_stmt_operand (&global_var, s_ann, opf_is_def);\n \telse\n \t  EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i, bi)\n-\t      {\n-\t\ttree var = referenced_var (i);\n-\t\tadd_stmt_operand (&var, s_ann, opf_is_def | opf_non_specific);\n-\t      }\n+\t    {\n+\t      tree var = referenced_var (i);\n+\t      add_stmt_operand (&var, s_ann, opf_is_def | opf_non_specific);\n+\t    }\n \n \t/* Now clobber all addressables.  */\n \tEXECUTE_IF_SET_IN_BITMAP (addressable_vars, 0, i, bi)\n@@ -1937,10 +1937,10 @@ note_addressable (tree var, stmt_ann_t s_ann)\n \t{\n \t  subvar_t sv;\n \t  for (sv = svars; sv; sv = sv->next)\n-\t    bitmap_set_bit (s_ann->addresses_taken, var_ann (sv->var)->uid);\n+\t    bitmap_set_bit (s_ann->addresses_taken, DECL_UID (sv->var));\n \t}\n       else\n-\tbitmap_set_bit (s_ann->addresses_taken, var_ann (var)->uid);\n+\tbitmap_set_bit (s_ann->addresses_taken, DECL_UID (var));\n     }\n }\n "}, {"sha": "61137aaa63d6952c83cf46cc89169ae9a9602b5a", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=a3648cfc0c331051ae47bedcc40c561f9979673a", "patch": "@@ -2913,13 +2913,13 @@ set_uids_in_ptset (bitmap into, bitmap from)\n \t  subvar_t svars = get_subvars_for_var (vi->decl);\n \t  subvar_t sv;\n \t  for (sv = svars; sv; sv = sv->next)\n-\t    bitmap_set_bit (into, var_ann (sv->var)->uid);    \n+\t    bitmap_set_bit (into, DECL_UID (sv->var));\n \t}\n       /* We may end up with labels in the points-to set because people\n \t take their address, and they are _DECL's.  */\n       else if (TREE_CODE (vi->decl) == VAR_DECL \n \t  || TREE_CODE (vi->decl) == PARM_DECL)\n-\tbitmap_set_bit (into, var_ann (vi->decl)->uid);\n+\tbitmap_set_bit (into, DECL_UID (vi->decl));\n \n \t  \n     }"}, {"sha": "9836bb184fd04c92c49f3fb295d137c33f009364", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=a3648cfc0c331051ae47bedcc40c561f9979673a", "patch": "@@ -373,25 +373,24 @@ verify_phi_args (tree phi, basic_block bb, basic_block *definition_block)\n static void\n verify_flow_insensitive_alias_info (void)\n {\n-  size_t i;\n   tree var;\n   bitmap visited = BITMAP_ALLOC (NULL);\n+  referenced_var_iterator rvi;\n \n-  for (i = 0; i < num_referenced_vars; i++)\n+  FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n       size_t j;\n       var_ann_t ann;\n       varray_type may_aliases;\n \n-      var = referenced_var (i);\n       ann = var_ann (var);\n       may_aliases = ann->may_aliases;\n \n       for (j = 0; may_aliases && j < VARRAY_ACTIVE_SIZE (may_aliases); j++)\n \t{\n \t  tree alias = VARRAY_TREE (may_aliases, j);\n \n-\t  bitmap_set_bit (visited, var_ann (alias)->uid);\n+\t  bitmap_set_bit (visited, DECL_UID (alias));\n \n \t  if (!may_be_aliased (alias))\n \t    {\n@@ -402,16 +401,14 @@ verify_flow_insensitive_alias_info (void)\n \t}\n     }\n \n-  for (i = 0; i < num_referenced_vars; i++)\n+  FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n       var_ann_t ann;\n-\n-      var = referenced_var (i);\n       ann = var_ann (var);\n \n       if (ann->mem_tag_kind == NOT_A_TAG\n \t  && ann->is_alias_tag\n-\t  && !bitmap_bit_p (visited, ann->uid))\n+\t  && !bitmap_bit_p (visited, DECL_UID (var)))\n \t{\n \t  error (\"Addressable variable that is an alias tag but is not in any alias set.\");\n \t  goto err;\n@@ -554,13 +551,13 @@ verify_name_tags (void)\n \t  for (i = 0; aliases && i < VARRAY_ACTIVE_SIZE (aliases); i++)\n \t    {\n \t      tree alias = VARRAY_TREE (aliases, i);\n-\t      bitmap_set_bit (type_aliases, var_ann (alias)->uid);\n+\t      bitmap_set_bit (type_aliases, DECL_UID (alias));\n \t    }\n \n \t  /* When grouping, we may have added PTR's type tag into the\n \t     alias set of PTR's name tag.  To prevent a false\n \t     positive, pretend that TMT is in its own alias set.  */\n-\t  bitmap_set_bit (type_aliases, var_ann (tmt)->uid);\n+\t  bitmap_set_bit (type_aliases, DECL_UID (tmt));\n \n \t  if (bitmap_equal_p (type_aliases, pi->pt_vars))\n \t    continue;\n@@ -780,13 +777,31 @@ verify_ssa (bool check_modified_stmt)\n   internal_error (\"verify_ssa failed.\");\n }\n \n+/* Return true if the uid in both int tree maps are equal.  */\n+\n+int\n+int_tree_map_eq (const void *va, const void *vb)\n+{\n+  const struct int_tree_map  *a = va, *b = vb;\n+  return (a->uid == b->uid);\n+}\n+\n+/* Hash a UID in a int_tree_map.  */\n+\n+unsigned int\n+int_tree_map_hash (const void *item)\n+{\n+  return ((const struct int_tree_map *)item)->uid;\n+}\n+\n \n /* Initialize global DFA and SSA structures.  */\n \n void\n init_tree_ssa (void)\n {\n-  referenced_vars = VEC_alloc (tree, gc, 20);\n+  referenced_vars = htab_create_ggc (20, int_tree_map_hash, \n+\t\t\t\t     int_tree_map_eq, NULL);\n   call_clobbered_vars = BITMAP_ALLOC (NULL);\n   addressable_vars = BITMAP_ALLOC (NULL);\n   init_ssanames ();\n@@ -804,6 +819,8 @@ delete_tree_ssa (void)\n   size_t i;\n   basic_block bb;\n   block_stmt_iterator bsi;\n+  referenced_var_iterator rvi;\n+  tree var;\n \n   /* Release any ssa_names still in use.  */\n   for (i = 0; i < num_ssa_names; i++)\n@@ -833,13 +850,13 @@ delete_tree_ssa (void)\n     }\n \n   /* Remove annotations from every referenced variable.  */\n-  for (i = 0; i < num_referenced_vars; i++)\n+  FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n-      tree var = referenced_var (i);\n       ggc_free (var->common.ann);\n       var->common.ann = NULL;\n     }\n-  VEC_free (tree, gc, referenced_vars);\n+  htab_delete (referenced_vars);\n+  referenced_vars = NULL;\n \n   fini_ssanames ();\n   fini_phinodes ();"}, {"sha": "a7446585b63ed5049b96a3c9398420d06ac42051", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=a3648cfc0c331051ae47bedcc40c561f9979673a", "patch": "@@ -259,7 +259,7 @@ find_va_list_reference (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n     var = SSA_NAME_VAR (var);\n \n   if (TREE_CODE (var) == VAR_DECL\n-      && bitmap_bit_p (va_list_vars, var_ann (var)->uid))\n+      && bitmap_bit_p (va_list_vars, DECL_UID (var)))\n     return var;\n \n   return NULL_TREE;\n@@ -337,12 +337,12 @@ va_list_counter_struct_op (struct stdarg_info *si, tree ap, tree var,\n     return false;\n \n   if (TREE_CODE (var) != SSA_NAME\n-      || bitmap_bit_p (si->va_list_vars, var_ann (SSA_NAME_VAR (var))->uid))\n+      || bitmap_bit_p (si->va_list_vars, DECL_UID (SSA_NAME_VAR (var))))\n     return false;\n \n   base = get_base_address (ap);\n   if (TREE_CODE (base) != VAR_DECL\n-      || !bitmap_bit_p (si->va_list_vars, var_ann (base)->uid))\n+      || !bitmap_bit_p (si->va_list_vars, DECL_UID (base)))\n     return false;\n \n   if (TREE_OPERAND (ap, 1) == va_list_gpr_counter_field)\n@@ -361,12 +361,12 @@ static bool\n va_list_ptr_read (struct stdarg_info *si, tree ap, tree tem)\n {\n   if (TREE_CODE (ap) != VAR_DECL\n-      || !bitmap_bit_p (si->va_list_vars, var_ann (ap)->uid))\n+      || !bitmap_bit_p (si->va_list_vars, DECL_UID (ap)))\n     return false;\n \n   if (TREE_CODE (tem) != SSA_NAME\n       || bitmap_bit_p (si->va_list_vars,\n-\t\t       var_ann (SSA_NAME_VAR (tem))->uid)\n+\t\t       DECL_UID (SSA_NAME_VAR (tem)))\n       || is_global_var (SSA_NAME_VAR (tem)))\n     return false;\n \n@@ -396,7 +396,7 @@ va_list_ptr_read (struct stdarg_info *si, tree ap, tree tem)\n   /* Note the temporary, as we need to track whether it doesn't escape\n      the current function.  */\n   bitmap_set_bit (si->va_list_escape_vars,\n-\t\t  var_ann (SSA_NAME_VAR (tem))->uid);\n+\t\t  DECL_UID (SSA_NAME_VAR (tem)));\n   return true;\n }\n \n@@ -413,11 +413,11 @@ va_list_ptr_write (struct stdarg_info *si, tree ap, tree tem2)\n   unsigned HOST_WIDE_INT increment;\n \n   if (TREE_CODE (ap) != VAR_DECL\n-      || !bitmap_bit_p (si->va_list_vars, var_ann (ap)->uid))\n+      || !bitmap_bit_p (si->va_list_vars, DECL_UID (ap)))\n     return false;\n \n   if (TREE_CODE (tem2) != SSA_NAME\n-      || bitmap_bit_p (si->va_list_vars, var_ann (SSA_NAME_VAR (tem2))->uid))\n+      || bitmap_bit_p (si->va_list_vars, DECL_UID (SSA_NAME_VAR (tem2))))\n     return false;\n \n   if (si->compute_sizes <= 0)\n@@ -455,7 +455,7 @@ check_va_list_escapes (struct stdarg_info *si, tree lhs, tree rhs)\n \n   if (TREE_CODE (rhs) != SSA_NAME\n       || ! bitmap_bit_p (si->va_list_escape_vars,\n-\t\t\t var_ann (SSA_NAME_VAR (rhs))->uid))\n+\t\t\t DECL_UID (SSA_NAME_VAR (rhs))))\n     return;\n \n   if (TREE_CODE (lhs) != SSA_NAME || is_global_var (SSA_NAME_VAR (lhs)))\n@@ -495,7 +495,7 @@ check_va_list_escapes (struct stdarg_info *si, tree lhs, tree rhs)\n     }\n \n   bitmap_set_bit (si->va_list_escape_vars,\n-\t\t  var_ann (SSA_NAME_VAR (lhs))->uid);\n+\t\t  DECL_UID (SSA_NAME_VAR (lhs)));\n }\n \n \n@@ -519,7 +519,7 @@ check_all_va_list_escapes (struct stdarg_info *si)\n \t  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_ALL_USES)\n \t    {\n \t      if (! bitmap_bit_p (si->va_list_escape_vars,\n-\t\t\t\t  var_ann (SSA_NAME_VAR (use))->uid))\n+\t\t\t\t  DECL_UID (SSA_NAME_VAR (use))))\n \t\tcontinue;\n \n \t      if (TREE_CODE (stmt) == MODIFY_EXPR)\n@@ -565,12 +565,12 @@ check_all_va_list_escapes (struct stdarg_info *si)\n \t\t    {\n \t\t      if (TREE_CODE (lhs) == SSA_NAME\n \t\t\t  && bitmap_bit_p (si->va_list_escape_vars,\n-\t\t\t\t\t   var_ann (SSA_NAME_VAR (lhs))->uid))\n+\t\t\t\t\t   DECL_UID (SSA_NAME_VAR (lhs))))\n \t\t\tcontinue;\n \n \t\t      if (TREE_CODE (lhs) == VAR_DECL\n \t\t\t  && bitmap_bit_p (si->va_list_vars,\n-\t\t\t\t\t   var_ann (lhs)->uid))\n+\t\t\t\t\t   DECL_UID (lhs)))\n \t\t\tcontinue;\n \t\t    }\n \t\t}\n@@ -690,7 +690,7 @@ execute_optimize_stdarg (void)\n \t      break;\n \t    }\n \n-\t  bitmap_set_bit (si.va_list_vars, var_ann (ap)->uid);\n+\t  bitmap_set_bit (si.va_list_vars, DECL_UID (ap));\n \n \t  /* VA_START_BB and VA_START_AP will be only used if there is just\n \t     one va_start in the function.  */"}, {"sha": "1e266407ca15fe2142a82e29097579bf82a255cb", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3648cfc0c331051ae47bedcc40c561f9979673a/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=a3648cfc0c331051ae47bedcc40c561f9979673a", "patch": "@@ -132,16 +132,17 @@ static void find_tail_calls (basic_block, struct tailcall **);\n static bool\n suitable_for_tail_opt_p (void)\n {\n-  int i;\n+  referenced_var_iterator rvi;\n+  tree var;\n \n   if (current_function_stdarg)\n     return false;\n \n   /* No local variable nor structure field should be call-clobbered.  We\n      ignore any kind of memory tag, as these are not real variables.  */\n-  for (i = 0; i < (int) num_referenced_vars; i++)\n+\n+  FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n-      tree var = VEC_index (tree, referenced_vars, i);\n \n       if (!(TREE_STATIC (var) || DECL_EXTERNAL (var))\n \t  && (var_ann (var)->mem_tag_kind == NOT_A_TAG"}, {"sha": "d2730a6fa382db697f8fc081ac214bc96983324a", "filename": "include/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3648cfc0c331051ae47bedcc40c561f9979673a/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3648cfc0c331051ae47bedcc40c561f9979673a/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=a3648cfc0c331051ae47bedcc40c561f9979673a", "patch": "@@ -1,3 +1,8 @@\n+2005-06-30  Daniel Berlin  <dberlin@dberlin.org>\n+\t\n+\t* hashtab.h (HTAB_DELETED_ENTRY): New macro.\n+\t(HTAB_EMPTY_ENTRY): New macro.\n+\n 2005-06-20  Geoffrey Keating  <geoffk@apple.com>\n \n \t* libiberty.h (strverscmp): Prototype. "}, {"sha": "77eee14e94f3cbf5c876b5c16dbb28f6264123cd", "filename": "include/hashtab.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3648cfc0c331051ae47bedcc40c561f9979673a/include%2Fhashtab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3648cfc0c331051ae47bedcc40c561f9979673a/include%2Fhashtab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fhashtab.h?ref=a3648cfc0c331051ae47bedcc40c561f9979673a", "patch": "@@ -81,6 +81,15 @@ typedef void (*htab_free) (void *);\n typedef void *(*htab_alloc_with_arg) (void *, size_t, size_t);\n typedef void (*htab_free_with_arg) (void *, void *);\n \n+/* This macro defines reserved value for empty table entry.  */\n+\n+#define HTAB_EMPTY_ENTRY    ((PTR) 0)\n+\n+/* This macro defines reserved value for table entry which contained\n+   a deleted element. */\n+\n+#define HTAB_DELETED_ENTRY  ((PTR) 1)\n+\n /* Hash tables are of the following type.  The structure\n    (implementation) of this type is not needed for using the hash\n    tables.  All work with hash table should be executed only through"}, {"sha": "2522b8270e61b5bfd8873de01d073b0b67ad6ebc", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3648cfc0c331051ae47bedcc40c561f9979673a/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3648cfc0c331051ae47bedcc40c561f9979673a/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=a3648cfc0c331051ae47bedcc40c561f9979673a", "patch": "@@ -1,3 +1,8 @@\n+2005-06-30  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* hashtab.c (EMPTY_ENTRY): Moved and renamed.\n+\t(DELETED_ENTRY): Ditto.\t\n+\n 2005-06-20  Geoffrey Keating  <geoffk@apple.com>\n \n \t* strverscmp.c: New."}, {"sha": "a5671a0a768041bc12a4e62473ea12aa3afc7fc4", "filename": "libiberty/hashtab.c", "status": "modified", "additions": 23, "deletions": 32, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3648cfc0c331051ae47bedcc40c561f9979673a/libiberty%2Fhashtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3648cfc0c331051ae47bedcc40c561f9979673a/libiberty%2Fhashtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fhashtab.c?ref=a3648cfc0c331051ae47bedcc40c561f9979673a", "patch": "@@ -64,15 +64,6 @@ Boston, MA 02110-1301, USA.  */\n #define CHAR_BIT 8\n #endif\n \n-/* This macro defines reserved value for empty table entry. */\n-\n-#define EMPTY_ENTRY    ((PTR) 0)\n-\n-/* This macro defines reserved value for table entry which contained\n-   a deleted element. */\n-\n-#define DELETED_ENTRY  ((PTR) 1)\n-\n static unsigned int higher_prime_index (unsigned long);\n static hashval_t htab_mod_1 (hashval_t, hashval_t, hashval_t, int);\n static hashval_t htab_mod (hashval_t, htab_t);\n@@ -290,7 +281,7 @@ htab_mod_m2 (hashval_t hash, htab_t htab)\n \n /* This function creates table with length slightly longer than given\n    source length.  Created hash table is initiated as empty (all the\n-   hash table entries are EMPTY_ENTRY).  The function returns the\n+   hash table entries are HTAB_EMPTY_ENTRY).  The function returns the\n    created hash table, or NULL if memory allocation fails.  */\n \n htab_t\n@@ -401,7 +392,7 @@ htab_delete (htab_t htab)\n \n   if (htab->del_f)\n     for (i = size - 1; i >= 0; i--)\n-      if (entries[i] != EMPTY_ENTRY && entries[i] != DELETED_ENTRY)\n+      if (entries[i] != HTAB_EMPTY_ENTRY && entries[i] != HTAB_DELETED_ENTRY)\n \t(*htab->del_f) (entries[i]);\n \n   if (htab->free_f != NULL)\n@@ -427,7 +418,7 @@ htab_empty (htab_t htab)\n \n   if (htab->del_f)\n     for (i = size - 1; i >= 0; i--)\n-      if (entries[i] != EMPTY_ENTRY && entries[i] != DELETED_ENTRY)\n+      if (entries[i] != HTAB_EMPTY_ENTRY && entries[i] != HTAB_DELETED_ENTRY)\n \t(*htab->del_f) (entries[i]);\n \n   memset (entries, 0, size * sizeof (PTR));\n@@ -448,9 +439,9 @@ find_empty_slot_for_expand (htab_t htab, hashval_t hash)\n   PTR *slot = htab->entries + index;\n   hashval_t hash2;\n \n-  if (*slot == EMPTY_ENTRY)\n+  if (*slot == HTAB_EMPTY_ENTRY)\n     return slot;\n-  else if (*slot == DELETED_ENTRY)\n+  else if (*slot == HTAB_DELETED_ENTRY)\n     abort ();\n \n   hash2 = htab_mod_m2 (hash, htab);\n@@ -461,9 +452,9 @@ find_empty_slot_for_expand (htab_t htab, hashval_t hash)\n \tindex -= size;\n \n       slot = htab->entries + index;\n-      if (*slot == EMPTY_ENTRY)\n+      if (*slot == HTAB_EMPTY_ENTRY)\n \treturn slot;\n-      else if (*slot == DELETED_ENTRY)\n+      else if (*slot == HTAB_DELETED_ENTRY)\n \tabort ();\n     }\n }\n@@ -523,7 +514,7 @@ htab_expand (htab_t htab)\n     {\n       PTR x = *p;\n \n-      if (x != EMPTY_ENTRY && x != DELETED_ENTRY)\n+      if (x != HTAB_EMPTY_ENTRY && x != HTAB_DELETED_ENTRY)\n \t{\n \t  PTR *q = find_empty_slot_for_expand (htab, (*htab->hash_f) (x));\n \n@@ -556,8 +547,8 @@ htab_find_with_hash (htab_t htab, const PTR element, hashval_t hash)\n   index = htab_mod (hash, htab);\n \n   entry = htab->entries[index];\n-  if (entry == EMPTY_ENTRY\n-      || (entry != DELETED_ENTRY && (*htab->eq_f) (entry, element)))\n+  if (entry == HTAB_EMPTY_ENTRY\n+      || (entry != HTAB_DELETED_ENTRY && (*htab->eq_f) (entry, element)))\n     return entry;\n \n   hash2 = htab_mod_m2 (hash, htab);\n@@ -569,8 +560,8 @@ htab_find_with_hash (htab_t htab, const PTR element, hashval_t hash)\n \tindex -= size;\n \n       entry = htab->entries[index];\n-      if (entry == EMPTY_ENTRY\n-\t  || (entry != DELETED_ENTRY && (*htab->eq_f) (entry, element)))\n+      if (entry == HTAB_EMPTY_ENTRY\n+\t  || (entry != HTAB_DELETED_ENTRY && (*htab->eq_f) (entry, element)))\n \treturn entry;\n     }\n }\n@@ -615,9 +606,9 @@ htab_find_slot_with_hash (htab_t htab, const PTR element,\n   first_deleted_slot = NULL;\n \n   entry = htab->entries[index];\n-  if (entry == EMPTY_ENTRY)\n+  if (entry == HTAB_EMPTY_ENTRY)\n     goto empty_entry;\n-  else if (entry == DELETED_ENTRY)\n+  else if (entry == HTAB_DELETED_ENTRY)\n     first_deleted_slot = &htab->entries[index];\n   else if ((*htab->eq_f) (entry, element))\n     return &htab->entries[index];\n@@ -631,9 +622,9 @@ htab_find_slot_with_hash (htab_t htab, const PTR element,\n \tindex -= size;\n       \n       entry = htab->entries[index];\n-      if (entry == EMPTY_ENTRY)\n+      if (entry == HTAB_EMPTY_ENTRY)\n \tgoto empty_entry;\n-      else if (entry == DELETED_ENTRY)\n+      else if (entry == HTAB_DELETED_ENTRY)\n \t{\n \t  if (!first_deleted_slot)\n \t    first_deleted_slot = &htab->entries[index];\n@@ -649,7 +640,7 @@ htab_find_slot_with_hash (htab_t htab, const PTR element,\n   if (first_deleted_slot)\n     {\n       htab->n_deleted--;\n-      *first_deleted_slot = EMPTY_ENTRY;\n+      *first_deleted_slot = HTAB_EMPTY_ENTRY;\n       return first_deleted_slot;\n     }\n \n@@ -688,13 +679,13 @@ htab_remove_elt_with_hash (htab_t htab, PTR element, hashval_t hash)\n   PTR *slot;\n \n   slot = htab_find_slot_with_hash (htab, element, hash, NO_INSERT);\n-  if (*slot == EMPTY_ENTRY)\n+  if (*slot == HTAB_EMPTY_ENTRY)\n     return;\n \n   if (htab->del_f)\n     (*htab->del_f) (*slot);\n \n-  *slot = DELETED_ENTRY;\n+  *slot = HTAB_DELETED_ENTRY;\n   htab->n_deleted++;\n }\n \n@@ -706,13 +697,13 @@ void\n htab_clear_slot (htab_t htab, PTR *slot)\n {\n   if (slot < htab->entries || slot >= htab->entries + htab_size (htab)\n-      || *slot == EMPTY_ENTRY || *slot == DELETED_ENTRY)\n+      || *slot == HTAB_EMPTY_ENTRY || *slot == HTAB_DELETED_ENTRY)\n     abort ();\n \n   if (htab->del_f)\n     (*htab->del_f) (*slot);\n \n-  *slot = DELETED_ENTRY;\n+  *slot = HTAB_DELETED_ENTRY;\n   htab->n_deleted++;\n }\n \n@@ -726,15 +717,15 @@ htab_traverse_noresize (htab_t htab, htab_trav callback, PTR info)\n {\n   PTR *slot;\n   PTR *limit;\n-\n+  \n   slot = htab->entries;\n   limit = slot + htab_size (htab);\n \n   do\n     {\n       PTR x = *slot;\n \n-      if (x != EMPTY_ENTRY && x != DELETED_ENTRY)\n+      if (x != HTAB_EMPTY_ENTRY && x != HTAB_DELETED_ENTRY)\n \tif (!(*callback) (slot, info))\n \t  break;\n     }"}]}