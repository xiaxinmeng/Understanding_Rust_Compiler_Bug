{"sha": "c9626ed6db93f2b09b893758bf44d797cb0200ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk2MjZlZDZkYjkzZjJiMDliODkzNzU4YmY0NGQ3OTdjYjAyMDBhYw==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2008-08-22T13:26:19Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-08-22T13:26:19Z"}, "message": "sem_ch5.adb (One_Bound): Fix latent bug involving secondary stack\n\n2008-08-22  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch5.adb (One_Bound): Fix latent bug involving secondary stack\n\nFrom-SVN: r139464", "tree": {"sha": "589d9b91bfea0688292aa9ff0c32813cecdf69ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/589d9b91bfea0688292aa9ff0c32813cecdf69ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9626ed6db93f2b09b893758bf44d797cb0200ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9626ed6db93f2b09b893758bf44d797cb0200ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9626ed6db93f2b09b893758bf44d797cb0200ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9626ed6db93f2b09b893758bf44d797cb0200ac/comments", "author": null, "committer": null, "parents": [{"sha": "4c7ad32065f700844c9cae89560c80195be6a50e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c7ad32065f700844c9cae89560c80195be6a50e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c7ad32065f700844c9cae89560c80195be6a50e"}], "stats": {"total": 49, "additions": 42, "deletions": 7}, "files": [{"sha": "a26d4b703cd29d337326c16e0e1a13485e9a9caa", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 42, "deletions": 7, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9626ed6db93f2b09b893758bf44d797cb0200ac/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9626ed6db93f2b09b893758bf44d797cb0200ac/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=c9626ed6db93f2b09b893758bf44d797cb0200ac", "patch": "@@ -1465,10 +1465,7 @@ package body Sem_Ch5 is\n          function One_Bound\n            (Original_Bound : Node_Id;\n             Analyzed_Bound : Node_Id) return Node_Id;\n-         --  Create one declaration followed by one assignment statement\n-         --  to capture the value of bound. We create a separate assignment\n-         --  in order to force the creation of a block in case the bound\n-         --  contains a call that uses the secondary stack.\n+         --  Capture value of bound and return captured value\n \n          ---------------\n          -- One_Bound --\n@@ -1499,15 +1496,53 @@ package body Sem_Ch5 is\n             then\n                Analyze_And_Resolve (Original_Bound, Typ);\n                return Original_Bound;\n-\n-            else\n-               Analyze_And_Resolve (Original_Bound, Typ);\n             end if;\n \n+            --  Here we need to capture the value\n+\n+            Analyze_And_Resolve (Original_Bound, Typ);\n+\n             Id :=\n               Make_Defining_Identifier (Loc,\n                 Chars => New_Internal_Name ('S'));\n \n+            --  Normally, the best approach is simply to generate a constant\n+            --  declaration that captures the bound. However, there is a nasty\n+            --  case where this is wrong. If the bound is complex, and has a\n+            --  possible use of the secondary stack, we need to generate a\n+            --  separate assignment statement to ensure the creation of a block\n+            --  which will release the secondary stack.\n+\n+            --  We prefer the constant declaration, since it leaves us with a\n+            --  proper trace of the value, useful in optimizations that get rid\n+            --  of junk range checks.\n+\n+            --  Probably we want something like the Side_Effect_Free routine\n+            --  in Exp_Util, but for now, we just optimize the cases of 'Last\n+            --  and 'First applied to an entity, since these are the important\n+            --  cases for range check optimizations.\n+\n+            if Nkind (Original_Bound) = N_Attribute_Reference\n+              and then (Attribute_Name (Original_Bound) = Name_First\n+                          or else\n+                        Attribute_Name (Original_Bound) = Name_Last)\n+              and then Is_Entity_Name (Prefix (Original_Bound))\n+            then\n+               Decl :=\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Id,\n+                   Constant_Present    => True,\n+                   Object_Definition   => New_Occurrence_Of (Typ, Loc),\n+                   Expression          => Relocate_Node (Original_Bound));\n+\n+               Insert_Before (Parent (N), Decl);\n+               Analyze (Decl);\n+               Rewrite (Original_Bound, New_Occurrence_Of (Id, Loc));\n+               return Expression (Decl);\n+            end if;\n+\n+            --  Here we make a declaration with a separate assignment statement\n+\n             Decl :=\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => Id,"}]}