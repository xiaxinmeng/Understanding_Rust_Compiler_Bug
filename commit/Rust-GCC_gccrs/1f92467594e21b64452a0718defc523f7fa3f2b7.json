{"sha": "1f92467594e21b64452a0718defc523f7fa3f2b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY5MjQ2NzU5NGUyMWI2NDQ1MmEwNzE4ZGVmYzUyM2Y3ZmEzZjJiNw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2009-12-03T12:58:30Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2009-12-03T12:58:30Z"}, "message": "re PR middle-end/42202 (Revision 154688 caused many gfortran failures)\n\n\tPR middle-end/42202\n\t* regrename.c (live_in_chains): New variable.\n\t(verify_reg_tracked): New static function.\n\t(scan_rtx_reg): Update live_in_chains.\n\t(scan_rtx): Only promote sets in COND_EXEC to OP_INOUT if\n\twe're already tracking the reg.\n\t(build_def_use): Likewise.  Initialize live_in_chains.\n\nFrom-SVN: r154944", "tree": {"sha": "d1e4eef4dd149c60c96d350a0634ee170fc294ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1e4eef4dd149c60c96d350a0634ee170fc294ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f92467594e21b64452a0718defc523f7fa3f2b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f92467594e21b64452a0718defc523f7fa3f2b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f92467594e21b64452a0718defc523f7fa3f2b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f92467594e21b64452a0718defc523f7fa3f2b7/comments", "author": null, "committer": null, "parents": [{"sha": "75741fedc51736373fbcd3a028af872791ac79e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75741fedc51736373fbcd3a028af872791ac79e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75741fedc51736373fbcd3a028af872791ac79e2"}], "stats": {"total": 89, "additions": 82, "deletions": 7}, "files": [{"sha": "58ff396fb3ae761b6be6690b96a49a6d23a78efb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f92467594e21b64452a0718defc523f7fa3f2b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f92467594e21b64452a0718defc523f7fa3f2b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f92467594e21b64452a0718defc523f7fa3f2b7", "patch": "@@ -1,3 +1,13 @@\n+2009-12-03  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\tPR middle-end/42202\n+\t* regrename.c (live_in_chains): New variable.\n+\t(verify_reg_tracked): New static function.\n+\t(scan_rtx_reg): Update live_in_chains.\n+\t(scan_rtx): Only promote sets in COND_EXEC to OP_INOUT if\n+\twe're already tracking the reg.\n+\t(build_def_use): Likewise.  Initialize live_in_chains.\n+\n 2009-12-03  Ken Werner  <ken.werner@de.ibm.com>\n \n         * config/spu/spu-elf.h (STARTFILE_SPEC): Add support for gprof"}, {"sha": "0026324d1edd70ced2ca44734f9e0b4360949504", "filename": "gcc/regrename.c", "status": "modified", "additions": 72, "deletions": 7, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f92467594e21b64452a0718defc523f7fa3f2b7/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f92467594e21b64452a0718defc523f7fa3f2b7/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=1f92467594e21b64452a0718defc523f7fa3f2b7", "patch": "@@ -440,6 +440,54 @@ static struct du_head *closed_chains;\n static bitmap_head open_chains_set;\n static HARD_REG_SET live_hard_regs;\n \n+/* Record the registers being tracked in open_chains.  The intersection\n+   between this and live_hard_regs is empty.  */\n+static HARD_REG_SET live_in_chains;\n+\n+/* Return true if OP is a reg that is being tracked already in some form.\n+   May set fail_current_block if it sees an unhandled case of overlap.  */\n+\n+static bool\n+verify_reg_tracked (rtx op)\n+{\n+  unsigned regno, nregs;\n+  bool all_live, all_dead;\n+  if (!REG_P (op))\n+    return false;\n+\n+  regno = REGNO (op);\n+  nregs = hard_regno_nregs[regno][GET_MODE (op)];\n+  all_live = all_dead = true;\n+  while (nregs-- > 0)\n+    if (TEST_HARD_REG_BIT (live_hard_regs, regno + nregs))\n+      all_dead = false;\n+    else\n+      all_live = false;\n+  if (!all_dead && !all_live)\n+    {\n+      fail_current_block = true;\n+      return false;\n+    }\n+\n+  if (all_live)\n+    return true;\n+\n+  nregs = hard_regno_nregs[regno][GET_MODE (op)];\n+  all_live = all_dead = true;\n+  while (nregs-- > 0)\n+    if (TEST_HARD_REG_BIT (live_in_chains, regno + nregs))\n+      all_dead = false;\n+    else\n+      all_live = false;\n+  if (!all_dead && !all_live)\n+    {\n+      fail_current_block = true;\n+      return false;\n+    }\n+\n+  return all_live;\n+}\n+\n /* Called through note_stores.  DATA points to a rtx_code, either SET or\n    CLOBBER, which tells us which kind of rtx to look at.  If we have a\n    match, record the set register in live_hard_regs and in the hard_conflicts\n@@ -497,10 +545,14 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n \t  mark_conflict (open_chains, head->id);\n \n \t  /* Since we're tracking this as a chain now, remove it from the\n-\t     list of conflicting live hard registers.  */\n+\t     list of conflicting live hard registers and track it in\n+\t     live_in_chains instead.  */\n \t  nregs = head->nregs;\n \t  while (nregs-- > 0)\n-\t    CLEAR_HARD_REG_BIT (live_hard_regs, head->regno + nregs);\n+\t    {\n+\t      SET_HARD_REG_BIT (live_in_chains, head->regno + nregs);\n+\t      CLEAR_HARD_REG_BIT (live_hard_regs, head->regno + nregs);\n+\t    }\n \n \t  COPY_HARD_REG_SET (head->hard_conflicts, live_hard_regs);\n \t  bitmap_set_bit (&open_chains_set, head->id);\n@@ -585,10 +637,17 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n       if ((action == terminate_dead || action == terminate_write)\n \t  && superset)\n \t{\n+\t  unsigned nregs;\n+\n \t  head->terminated = 1;\n \t  head->next_chain = closed_chains;\n \t  closed_chains = head;\n \t  bitmap_clear_bit (&open_chains_set, head->id);\n+\n+\t  nregs = head->nregs;\n+\t  while (nregs-- > 0)\n+\t    CLEAR_HARD_REG_BIT (live_in_chains, head->regno + nregs);\n+\n \t  *p = next;\n \t  if (dump_file)\n \t    fprintf (dump_file,\n@@ -805,7 +864,8 @@ scan_rtx (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n     case SET:\n       scan_rtx (insn, &SET_SRC (x), cl, action, OP_IN);\n       scan_rtx (insn, &SET_DEST (x), cl, action,\n-\t\tGET_CODE (PATTERN (insn)) == COND_EXEC ? OP_INOUT : OP_OUT);\n+\t\t(GET_CODE (PATTERN (insn)) == COND_EXEC\n+\t\t && verify_reg_tracked (SET_DEST (x))) ? OP_INOUT : OP_OUT);\n       return;\n \n     case STRICT_LOW_PART:\n@@ -831,7 +891,8 @@ scan_rtx (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n \n     case CLOBBER:\n       scan_rtx (insn, &SET_DEST (x), cl, action,\n-\t\tGET_CODE (PATTERN (insn)) == COND_EXEC ? OP_INOUT : OP_OUT);\n+\t\t(GET_CODE (PATTERN (insn)) == COND_EXEC\n+\t\t && verify_reg_tracked (SET_DEST (x))) ? OP_INOUT : OP_OUT);\n       return;\n \n     case EXPR_LIST:\n@@ -964,6 +1025,7 @@ build_def_use (basic_block bb)\n \n   current_id = 0;\n   bitmap_initialize (&open_chains_set, &bitmap_default_obstack);\n+  CLEAR_HARD_REG_SET (live_in_chains);\n   REG_SET_TO_HARD_REG_SET (live_hard_regs, df_get_live_in (bb));\n   for (def_rec = df_get_artificial_defs (bb->index); *def_rec; def_rec++)\n     {\n@@ -1017,8 +1079,10 @@ build_def_use (basic_block bb)\n \t  n_ops = recog_data.n_operands;\n \n \t  /* Simplify the code below by rewriting things to reflect\n-\t     matching constraints.  Also promote OP_OUT to OP_INOUT\n-\t     in predicated instructions.  */\n+\t     matching constraints.  Also promote OP_OUT to OP_INOUT in\n+\t     predicated instructions, but only for register operands\n+\t     that are already tracked, so that we can create a chain\n+\t     when the first SET makes a register live.  */\n \n \t  predicated = GET_CODE (PATTERN (insn)) == COND_EXEC;\n \t  for (i = 0; i < n_ops; ++i)\n@@ -1027,7 +1091,8 @@ build_def_use (basic_block bb)\n \t      if (matches >= 0)\n \t\trecog_op_alt[i][alt].cl = recog_op_alt[matches][alt].cl;\n \t      if (matches >= 0 || recog_op_alt[i][alt].matched >= 0\n-\t          || (predicated && recog_data.operand_type[i] == OP_OUT))\n+\t          || (predicated && recog_data.operand_type[i] == OP_OUT\n+\t\t      && verify_reg_tracked (recog_data.operand[i])))\n \t\t{\n \t\t  recog_data.operand_type[i] = OP_INOUT;\n \t\t  if (matches >= 0"}]}