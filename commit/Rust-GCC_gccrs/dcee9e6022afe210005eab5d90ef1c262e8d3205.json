{"sha": "dcee9e6022afe210005eab5d90ef1c262e8d3205", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGNlZTllNjAyMmFmZTIxMDAwNWVhYjVkOTBlZjFjMjYyZThkMzIwNQ==", "commit": {"author": {"name": "David Jee", "email": "djee@redhat.com", "date": "2004-02-10T18:54:25Z"}, "committer": {"name": "David Jee", "email": "djee@gcc.gnu.org", "date": "2004-02-10T18:54:25Z"}, "message": "2004-02-10  David Jee  <djee@redhat.com>\n\n\t* java/awt/GridBagLayout.java\n\t(GridBagLayout): New private field, internalcomptable.\n\t(lookupInternalConstraints): New method.\n\t(ArrangeGrid): Use components' MINSIZE. Use internalcomptable.\n\t(GetLayoutInfo): Reimplement.\n\t(calcCellSizes): Ignore rows/columns with size 0.\n\nFrom-SVN: r77612", "tree": {"sha": "7c3c8cc8ecf39415da17cb01056e368941e541d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c3c8cc8ecf39415da17cb01056e368941e541d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dcee9e6022afe210005eab5d90ef1c262e8d3205", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcee9e6022afe210005eab5d90ef1c262e8d3205", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcee9e6022afe210005eab5d90ef1c262e8d3205", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcee9e6022afe210005eab5d90ef1c262e8d3205/comments", "author": null, "committer": null, "parents": [{"sha": "fbe6ec8150896cfa14b8500c932d9b890c18c297", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbe6ec8150896cfa14b8500c932d9b890c18c297", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbe6ec8150896cfa14b8500c932d9b890c18c297"}], "stats": {"total": 489, "additions": 376, "deletions": 113}, "files": [{"sha": "9140b3d9fd78ba3f9f232ecb36bf625608d8e512", "filename": "libjava/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcee9e6022afe210005eab5d90ef1c262e8d3205/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcee9e6022afe210005eab5d90ef1c262e8d3205/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=dcee9e6022afe210005eab5d90ef1c262e8d3205", "patch": "@@ -1,3 +1,12 @@\n+2004-02-10  David Jee  <djee@redhat.com>\n+\n+\t* java/awt/GridBagLayout.java\n+\t(GridBagLayout): New private field, internalcomptable.\n+\t(lookupInternalConstraints): New method.\n+\t(ArrangeGrid): Use components' MINSIZE. Use internalcomptable.\n+\t(GetLayoutInfo): Reimplement.\n+\t(calcCellSizes): Ignore rows/columns with size 0.\n+\n 2004-02-10  Michael Koch  <konqueror@gmx.de>\n \n \t* gnu/java/awt/EmbeddedWindow.java"}, {"sha": "5b009de6fb54afaeba05bcb3f0ef48e90d435a04", "filename": "libjava/java/awt/GridBagLayout.java", "status": "modified", "additions": 367, "deletions": 113, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcee9e6022afe210005eab5d90ef1c262e8d3205/libjava%2Fjava%2Fawt%2FGridBagLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcee9e6022afe210005eab5d90ef1c262e8d3205/libjava%2Fjava%2Fawt%2FGridBagLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FGridBagLayout.java?ref=dcee9e6022afe210005eab5d90ef1c262e8d3205", "patch": "@@ -40,6 +40,7 @@\n \n import java.io.Serializable;\n import java.util.Hashtable;\n+import java.util.HashMap;\n \n /**\n  * @author Michael Koch <konqueror@gmx.de>\n@@ -54,7 +55,14 @@\n     protected static final int PREFERREDSIZE = 2;\n     protected static final int MAXGRIDSIZE = 512;\n \n+    // comptable remembers the original contraints given to us.\n+    // internalcomptable is used to keep track of modified constraint values\n+    // that we calculate, particularly when we are given RELATIVE and\n+    // REMAINDER constraints.\n+    // Constraints kept in comptable are never modified, and constraints\n+    // kept in internalcomptable can be modified internally only.\n     protected Hashtable comptable;\n+    private Hashtable internalcomptable;\n     protected GridBagLayoutInfo layoutInfo;\n     protected GridBagConstraints defaultConstraints;\n \n@@ -66,6 +74,7 @@\n     public GridBagLayout ()\n     {\n \tthis.comptable = new Hashtable();\n+\tthis.internalcomptable = new Hashtable();\n \tthis.defaultConstraints= new GridBagConstraints();\n     }\n \n@@ -213,6 +222,20 @@ protected GridBagConstraints lookupConstraints (Component component)\n \treturn result;\n     }\n \n+    private GridBagConstraints lookupInternalConstraints (Component component)\n+    {\n+\tGridBagConstraints result =\n+            (GridBagConstraints) internalcomptable.get (component);\n+\n+\tif (result == null)\n+\t{\n+\t    result = (GridBagConstraints) lookupConstraints(component).clone();\n+\t    internalcomptable.put (component, result);\n+\t}\n+    \n+\treturn result;\n+    }\n+\n     /**\n      * @since 1.1\n      */\n@@ -316,7 +339,7 @@ protected void ArrangeGrid (Container parent)\n       if (components.length == 0)\n         return;\n \n-      GridBagLayoutInfo info = getLayoutInfo (parent, PREFERREDSIZE);\n+      GridBagLayoutInfo info = getLayoutInfo (parent, MINSIZE);\n       if (info.cols == 0 && info.rows == 0)\n         return;\n       layoutInfo = info;\n@@ -332,7 +355,8 @@ protected void ArrangeGrid (Container parent)\n           if (!component.isVisible())\n             continue;\n \t\t\n-          GridBagConstraints constraints = lookupConstraints (component);\n+          GridBagConstraints constraints =\n+              lookupInternalConstraints(component);\n \n           int cellx = sumIntArray(layoutInfo.colWidths, constraints.gridx);\n           int celly = sumIntArray(layoutInfo.rowHeights, constraints.gridy);\n@@ -435,12 +459,16 @@ protected GridBagLayoutInfo GetLayoutInfo (Container parent, int sizeflag)\n       parentDim.width -= parentInsets.left + parentInsets.right;\n       parentDim.height -= parentInsets.top + parentInsets.bottom;\n    \n-      int x = 0;\n-      int y = 0;\n+      int current_y = 0;\n       int max_x = 0;\n       int max_y = 0;\n \n-      // first we figure out how many rows/columns\n+      // Guaranteed to contain the last component added to the given row\n+      // or column, whose gridwidth/height is not REMAINDER.\n+      HashMap lastInRow = new HashMap();\n+      HashMap lastInCol = new HashMap();\n+\n+      // STEP 1: first we figure out how many rows/columns\n       Component[] components = parent.getComponents();\n       for (int i = 0; i < components.length; i++)\n \t{\n@@ -450,124 +478,338 @@ protected GridBagLayoutInfo GetLayoutInfo (Container parent, int sizeflag)\n           if (!component.isVisible())\n             continue;\n \t\t\n-          GridBagConstraints constraints = lookupConstraints (component);\n-\t\t\n+          // When looking up the constraint for the first time, check the\n+          // original unmodified constraint.  After the first time, always\n+          // refer to the internal modified constraint.\n+          GridBagConstraints originalConstraints = lookupConstraints (component);\n+          GridBagConstraints constraints = (GridBagConstraints) originalConstraints.clone();\n+          internalcomptable.put(component, constraints);\n+\n+          // Cases:\n+          //\n+          // 1. gridy == RELATIVE, gridx == RELATIVE\n+          //\n+          //       use y as the row number; check for the next\n+          //       available slot at row y\n+          //\n+          // 2. only gridx == RELATIVE\n+          //\n+          //       check for the next available slot at row gridy\n+          //\n+          // 3. only gridy == RELATIVE\n+          //\n+          //       check for the next available slot at column gridx\n+          //\n+          // 4. neither gridx or gridy == RELATIVE\n+          //\n+          //       nothing to check; just add it\n+\n+\n+          // cases 1 and 2\n           if(constraints.gridx == GridBagConstraints.RELATIVE)\n-            constraints.gridx = x;\n+            {\n+              if (constraints.gridy == GridBagConstraints.RELATIVE)\n+              constraints.gridy = current_y;\n+\n+              int x;\n+\n+              // Check the component that occupies the right-most spot in this\n+              // row. We want to add this component after it.\n+              // If this row is empty, add to the 0 position.\n+              if (!lastInRow.containsKey(new Integer(constraints.gridy))) \n+                x = 0;\n+              else\n+                {\n+                  Component lastComponent = (Component) lastInRow.get(new Integer(constraints.gridy));\n+                  GridBagConstraints lastConstraints = lookupInternalConstraints(lastComponent);\n+                  x = lastConstraints.gridx + Math.max(1, lastConstraints.gridwidth);\n+                }\n+\n+              // Determine if this component will fit in the slot vertically.\n+              // If not, bump it over to where it does fit.\n+              for (int y = constraints.gridy + 1; y < constraints.gridy + Math.max(1, constraints.gridheight); y++)\n+                {\n+                  if (lastInRow.containsKey(new Integer(y)))\n+                    {\n+                      Component lastComponent = (Component) lastInRow.get(new Integer(y));\n+                      GridBagConstraints lastConstraints = lookupInternalConstraints(lastComponent);\n+                      x = Math.max (x,\n+                                    lastConstraints.gridx + Math.max(1, lastConstraints.gridwidth));\n+                    }\n+                }\n+\n+              constraints.gridx = x;\n+            }\n+          // case 3\n+          else if(constraints.gridy == GridBagConstraints.RELATIVE)\n+            {\n+              int y;\n+              // Check the component that occupies the bottom-most spot in\n+              // this column. We want to add this component below it.\n+              // If this column is empty, add to the 0 position.\n+              if (!lastInCol.containsKey(new Integer(constraints.gridx))) \n+                y = 0;\n+              else\n+                {\n+                  Component lastComponent = (Component)lastInCol.get(new Integer(constraints.gridx));\n+                  GridBagConstraints lastConstraints = lookupInternalConstraints(lastComponent);\n+                  y = lastConstraints.gridy + Math.max(1, lastConstraints.gridheight);\n+                }\n+\n+              // Determine if this component will fit in the slot horizontally.\n+              // If not, bump it down to where it does fit.\n+              for (int x = constraints.gridx + 1; x < constraints.gridx + Math.max(1, constraints.gridwidth); x++)\n+                {\n+                  if (lastInCol.containsKey(new Integer(x)))\n+                    {\n+                      Component lastComponent = (Component) lastInCol.get(new Integer(x));\n+                      GridBagConstraints lastConstraints = lookupInternalConstraints(lastComponent);\n+                      y = Math.max (y,\n+                                    lastConstraints.gridy + Math.max(1, lastConstraints.gridheight));\n+                    }\n+                }\n+\n+              constraints.gridy = y;\n+            }\n+          // case 4: do nothing\n \n-          if(constraints.gridy == GridBagConstraints.RELATIVE)\n-            constraints.gridy = y;\n-\t\t\n           max_x = Math.max(max_x, \n                            constraints.gridx + Math.max(1, constraints.gridwidth));\n           max_y = Math.max(max_y,\n                            constraints.gridy + Math.max(1, constraints.gridheight));\n \n+          // Update our reference points for RELATIVE gridx and gridy.\n           if(constraints.gridwidth == GridBagConstraints.REMAINDER)\n \t    {\n-              x = 0;\n-              y++;\n+              current_y = constraints.gridy + Math.max(1, constraints.gridheight);\n \t    }\n-          else\n+          else if (constraints.gridwidth != GridBagConstraints.REMAINDER)\n \t    {\n-              x = constraints.gridx + Math.max(1, constraints.gridwidth);\n-              y = constraints.gridy;\n+              for (int y = constraints.gridy; y < constraints.gridy + Math.max(1, constraints.gridheight); y++)\n+                {\n+                  if(lastInRow.containsKey(new Integer(y)))\n+                    {\n+                      Component lastComponent = (Component) lastInRow.get(new Integer(y));\n+                      GridBagConstraints lastConstraints = lookupInternalConstraints(lastComponent);\n+                      if (constraints.gridx > lastConstraints.gridx)\n+                        {\n+                          lastInRow.put(new Integer(y), component);\n+                        }\n+                    }\n+                  else\n+                    {\n+                      lastInRow.put(new Integer(y), component);\n+                    }\n+                }\n+\n+              for (int x = constraints.gridx; x < constraints.gridx + Math.max(1, constraints.gridwidth); x++)\n+                {\n+                  if(lastInCol.containsKey(new Integer(x)))\n+                    {\n+                      Component lastComponent = (Component) lastInCol.get(new Integer(x));\n+                      GridBagConstraints lastConstraints = lookupInternalConstraints(lastComponent);\n+                      if (constraints.gridy > lastConstraints.gridy)\n+                        {\n+                          lastInCol.put(new Integer(x), component);\n+                        }\n+                    }\n+                  else\n+                    {\n+                      lastInCol.put(new Integer(x), component);\n+                    }\n+                }\n \t    }\n-\t}\n+\t} // end of STEP 1\n \t\n+      boolean[] colIsOccupied = new boolean[max_x];\n+      boolean[] rowIsOccupied = new boolean[max_y];\n+\n+      // STEP 2: Determine which cells the components occupy.\n+      for (int i = 0; i < components.length; i++)\n+        {\n+          Component component = components [i];\n+\t\t\t\n+          // If component is not visible we dont have to care about it.\n+          if (!component.isVisible())\n+            continue;\n+\t\t\t\n+          GridBagConstraints constraints = lookupInternalConstraints (component);\n+\n+          // Fix up any REMAINDER and RELATIVE cells.\n+          if(constraints.gridwidth == GridBagConstraints.REMAINDER)\n+            {\n+              for (int y = constraints.gridy; y < constraints.gridy + Math.max(1, constraints.gridheight); y++)\n+                {\n+                  if (lastInRow.containsKey(new Integer(y)))\n+                    {\n+                      Component lastComponent = (Component) lastInRow.get(new Integer(y));\n+                      GridBagConstraints lastConstraints = lookupInternalConstraints(lastComponent);\n+\n+                      if (lastConstraints.gridwidth == GridBagConstraints.RELATIVE)\n+                        {\n+                          constraints.gridx = max_x - 1;\n+                          break;\n+                        }\n+                      else\n+                        {\n+                          constraints.gridx = Math.max (constraints.gridx,\n+                                                        lastConstraints.gridx + Math.max (1, lastConstraints.gridwidth));\n+                        }\n+                    }\n+                }\n+              constraints.gridwidth = max_x - constraints.gridx;\n+            }\n+          else if (constraints.gridwidth == GridBagConstraints.RELATIVE)\n+            {\n+              constraints.gridwidth = max_x - constraints.gridx - 1;\n+            }\n+\n+          if(constraints.gridheight == GridBagConstraints.REMAINDER)\n+            {\n+              for (int x = constraints.gridx; x < constraints.gridx + Math.max(1, constraints.gridwidth); x++)\n+                {\n+                  if (lastInCol.containsKey(new Integer(x)))\n+                    {\n+                      Component lastComponent = (Component) lastInRow.get(new Integer(x));\n+                      GridBagConstraints lastConstraints = lookupInternalConstraints(lastComponent);\n+\n+                      if (lastConstraints.gridheight == GridBagConstraints.RELATIVE)\n+                        {\n+                          constraints.gridy = max_y - 1;\n+                          break;\n+                        }\n+                      else\n+                        {\n+                          constraints.gridy = Math.max (constraints.gridy,\n+                                                        lastConstraints.gridy + Math.max (1, lastConstraints.gridheight));\n+                        }\n+                    }\n+                }\n+              constraints.gridheight = max_y - constraints.gridy;\n+            }\n+          else if (constraints.gridheight == GridBagConstraints.RELATIVE)\n+            {\n+              constraints.gridheight = max_y - constraints.gridy - 1;\n+            }\n+\n+          // For now, a row or a column is \"occupied\" iff a component\n+          // both begins and ends in that row or column.\n+          if (constraints.gridwidth == 1)\n+            colIsOccupied[constraints.gridx] = true;\n+          if (constraints.gridheight == 1)\n+            rowIsOccupied[constraints.gridy] = true;\n+        } // end of STEP 2\n+\n       GridBagLayoutInfo info = new GridBagLayoutInfo(max_x, max_y);\n \n-      for (x = 0; x <= max_x; x++)\n-\t{\n+      // Check if column widths and row heights are overridden.\n+\n+      for (int x = 0; x < max_x; x++)\n+        {\n           if(columnWidths != null && columnWidths.length > x)\n-\t    {\n-              info.colWidths[x] = columnWidths[x];\n-\t    }\n+            info.colWidths[x] = columnWidths[x];\n           if(columnWeights != null && columnWeights.length > x)\n-\t    {\n-              info.colWeights[x] = columnWeights[x];\n-\t    }\n-          for (int i = 0; i < components.length; i++)\n-\t    {\n-              Component component = components [i];\n-\t\t\t\n-              // If component is not visible we dont have to care about it.\n-              if (!component.isVisible())\n-                continue;\n-\t\t\t\n-              GridBagConstraints constraints = lookupConstraints (component);\n-\n-              // first we fix up any REMAINDER cells\n-              if(constraints.gridwidth == GridBagConstraints.REMAINDER)\n-\t\t{\n-                  constraints.gridwidth = max_x - constraints.gridx;\n-\t\t}\n-              if(constraints.gridheight == GridBagConstraints.REMAINDER)\n-\t\t{\n-                  constraints.gridheight = max_y - constraints.gridy;\n-\t\t}\n-\n-              if(constraints.gridx + constraints.gridwidth - 1 == x)\n-\t\t{\n-                  int width = (sizeflag == PREFERREDSIZE) ?\n-                    component.getPreferredSize().width :\n-                    component.getMinimumSize().width;\n-                  if(constraints.insets != null)\n-\t\t    {\n-                      width += constraints.insets.left + constraints.insets.right;\n-\t\t    }\n-                  width += constraints.ipadx;\n-                  for(int w = 1; w < constraints.gridwidth; w++)\n-\t\t    {\n-                      width -= info.colWidths[x - w];\n-\t\t    }\n-                  info.colWidths[x] = Math.max(info.colWidths[x], width);\n-                  info.colWeights[x] =\n-                    Math.max(info.colWeights[x], constraints.weightx);\n-\t\t}\n-\t    }\n-\t}\n+            info.colWeights[x] = columnWeights[x];\n+        }\n \n-      for (y = 0; y <= max_y; y++)\n-\t{\n+      for (int y = 0; y < max_y; y++)\n+        {\n           if(rowHeights != null && rowHeights.length > y)\n-\t    {\n-              info.rowHeights[y] = rowHeights[y];\n-\t    }\n+            info.rowHeights[y] = rowHeights[y];\n           if(rowWeights != null && rowWeights.length > y)\n-\t    {\n-              info.rowWeights[y] = rowWeights[y];\n-\t    }\n-          for (int i = 0; i < components.length; i++)\n-\t    {\n-              Component component = components [i];\n-\t\t\t\n-              // If component is not visible we dont have to care about it.\n-              if (!component.isVisible())\n-                continue;\n+            info.rowWeights[y] = rowWeights[y];\n+        }\n+\n+      // STEP 3: Distribute the weights and min sizes among rows/columns.\n+      for (int i = 0; i < components.length; i++)\n+        {\n+          Component component = components [i];\n \t\t\t\n-              GridBagConstraints constraints = lookupConstraints (component);\n-\n-              if(constraints.gridy + constraints.gridheight - 1 == y)\n-\t\t{\n-                  int height = (sizeflag == PREFERREDSIZE) ?\n-                    component.getPreferredSize().height :\n-                    component.getMinimumSize().height;\n-                  if(constraints.insets != null)\n-\t\t    {\n-                      height += constraints.insets.top + constraints.insets.bottom;\n-\t\t    } \n-                  height += constraints.ipady;\n-                  for(int h = 1; h < constraints.gridheight; h++)\n-\t\t    {\n-                      height -= info.rowHeights[y - h];\n-\t\t    }\n-                  info.rowHeights[y] = Math.max(info.rowHeights[y], height);\n-                  info.rowWeights[y] =\n-                    Math.max(info.rowWeights[y], constraints.weighty);\n-\t\t}\n-\t    }\n-\t}\n+          // If component is not visible we dont have to care about it.\n+          if (!component.isVisible())\n+            continue;\n+\n+          GridBagConstraints constraints = lookupInternalConstraints (component);\n+          GridBagConstraints originalConstraints = lookupConstraints (component);\n+\n+          // Distribute the width.\n+\n+          int width = (sizeflag == PREFERREDSIZE) ?\n+                      component.getPreferredSize().width :\n+                      component.getMinimumSize().width;\n+\n+          if(constraints.insets != null)\n+            width += constraints.insets.left + constraints.insets.right;\n+\n+          width += constraints.ipadx;\n+\n+          int occupiedCols = constraints.gridwidth;\n+          int lastOccupiedCol = -1;\n+\n+          for(int w = constraints.gridx; w < constraints.gridx + constraints.gridwidth; w++)\n+            {\n+              if(colIsOccupied[w])\n+                lastOccupiedCol = w;\n+              else\n+                occupiedCols--;\n+            }\n+\n+          // A component needs to occupy at least one column.\n+          if(occupiedCols == 0)\n+            {\n+              colIsOccupied[constraints.gridx + constraints.gridwidth - 1] = true;\n+              lastOccupiedCol = constraints.gridx + constraints.gridwidth - 1;\n+            }\n+\n+          for(int w = constraints.gridx; w < constraints.gridx + constraints.gridwidth - 1; w++)\n+            {\n+              if(colIsOccupied[w])\n+                width -= info.colWidths[w];\n+            }\n+\n+          info.colWidths[lastOccupiedCol] = Math.max(info.colWidths[lastOccupiedCol], width);\n+          info.colWeights[lastOccupiedCol] = Math.max(info.colWeights[lastOccupiedCol], constraints.weightx);\n+\n+\n+          // Distribute the height.\n+\n+          int height = (sizeflag == PREFERREDSIZE) ?\n+                       component.getPreferredSize().height :\n+                       component.getMinimumSize().height;\n+\n+          if(constraints.insets != null)\n+            height += constraints.insets.top + constraints.insets.bottom;\n+\n+          height += constraints.ipady;\n+\n+          int occupiedRows = constraints.gridheight;\n+          int lastOccupiedRow = -1;\n+\n+          for(int h = constraints.gridy; h < constraints.gridy + constraints.gridheight; h++)\n+            {\n+              if(rowIsOccupied[h])\n+                lastOccupiedRow = h;\n+              else\n+                occupiedRows--;\n+            }\n+\n+          // A component needs to occupy at least one row.\n+          if(occupiedRows == 0)\n+            {\n+              rowIsOccupied[constraints.gridy + constraints.gridheight - 1] = true;\n+              lastOccupiedRow = constraints.gridy + constraints.gridheight - 1;\n+            }\n+\n+          for(int h = constraints.gridy; h < constraints.gridy + constraints.gridheight; h++)\n+            {\n+              if(rowIsOccupied[h])\n+                height -= info.rowHeights[h];\n+            }\n+\n+          info.rowHeights[lastOccupiedRow] = Math.max(info.rowHeights[lastOccupiedRow], height);\n+          info.rowWeights[lastOccupiedRow] = Math.max(info.rowWeights[lastOccupiedRow], constraints.weighty);\n+\n+        } // end of STEP 3\n \n       calcCellSizes (info.colWidths, info.colWeights, parentDim.width);\n       calcCellSizes (info.rowHeights, info.rowWeights, parentDim.height);\n@@ -607,20 +849,32 @@ protected Dimension getMinSize (Container parent, GridBagLayoutInfo info)\n \n     private void calcCellSizes (int[] sizes, double[] weights, int range)\n     {\n-\tint diff = range - sumIntArray (sizes);\n+      int totalSize = sumIntArray (sizes);\n+      double totalWeight = sumDoubleArray (weights);\n \n-\tif (diff == 0)\n-\t    return;\n-    \n-\tdouble weight = sumDoubleArray (weights);\n+      // Rows or columns with size 0 should not be weighted in the calculation.\n+      for (int i = 0; i < weights.length; i++)\n+        {\n+          if (sizes[i] == 0)\n+            totalWeight -= weights[i];\n+        }\n \n-\tfor (int i = 0; i < sizes.length; i++)\n-\t{\n-\t    sizes [i] += (int) (((double) diff) * weights [i] / weight );\n+      int diff = range - totalSize;\n \n-\t    if (sizes [i] < 0)\n-\t\tsizes [i] = 0;\n-\t}\n+      if (diff == 0)\n+        return;\n+\n+      for (int i = 0; i < sizes.length; i++)\n+        {\n+          // A row or column with zero size cannot all of a sudden gain size.\n+          if (sizes[i] != 0.0)\n+            {\n+              int newsize = (int) (sizes[i] + (((double) diff) * weights [i] / totalWeight ));\n+\n+              if (newsize > 0)\n+                sizes[i] = newsize;\n+            }\n+        }\n     }\n \n     private void dumpLayoutInfo (GridBagLayoutInfo info)"}]}