{"sha": "037cc0b4a6646cc86549247a3590215ebd5c4c43", "node_id": "C_kwDOANBUbNoAKDAzN2NjMGI0YTY2NDZjYzg2NTQ5MjQ3YTM1OTAyMTVlYmQ1YzRjNDM", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-01-10T14:47:09Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-01-10T14:47:09Z"}, "message": "ira: Handle \"soft\" conflicts between cap and non-cap allocnos\n\nThis patch looks for allocno conflicts of the following form:\n\n- One allocno (X) is a cap allocno for some non-cap allocno X2.\n- X2 belongs to some loop L2.\n- The other allocno (Y) is a non-cap allocno.\n- Y is an ancestor of some allocno Y2 in L2.\n- Y2 is not referenced in L2 (that is, ALLOCNO_NREFS (Y2) == 0).\n- Y can use a different allocation from Y2.\n\nIn this case, Y's register is live across L2 but is not used within it,\nwhereas X's register is used only within L2.  The conflict is therefore\nonly \"soft\", in that it can easily be avoided by spilling Y2 inside L2\nwithout affecting any insn references.\n\nIn principle we could do this for ALLOCNO_NREFS (Y2) != 0 too, with the\ncallers then taking Y2's ALLOCNO_MEMORY_COST into account.  There would\nthen be no \"cliff edge\" between a Y2 that has no references and a Y2 that\nhas (say) a single cold reference.\n\nHowever, doing that isn't necessary for the PR and seems to give\nvariable results in practice.  (fotonik3d_r improves slightly but\nnamd_r regresses slightly.)  It therefore seemed better to start\nwith the higher-value zero-reference case and see how things go.\n\nOn top of the previous patches in the series, this fixes the exchange2\nregression seen in GCC 11.\n\ngcc/\n\tPR rtl-optimization/98782\n\t* ira-int.h (ira_soft_conflict): Declare.\n\t* ira-color.c (max_soft_conflict_loop_depth): New constant.\n\t(ira_soft_conflict): New function.\n\t(spill_soft_conflicts): Likewise.\n\t(assign_hard_reg): Use them to handle the case described by\n\tthe comment above ira_soft_conflict.\n\t(improve_allocation): Likewise.\n\t* ira.c (check_allocation): Allow allocnos with \"soft\" conflicts\n\tto share the same register.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/reg-alloc-4.c: New test.", "tree": {"sha": "8d4365fe7f2fe5a2ff2b1a6e841eec526a8500ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d4365fe7f2fe5a2ff2b1a6e841eec526a8500ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/037cc0b4a6646cc86549247a3590215ebd5c4c43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/037cc0b4a6646cc86549247a3590215ebd5c4c43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/037cc0b4a6646cc86549247a3590215ebd5c4c43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/037cc0b4a6646cc86549247a3590215ebd5c4c43/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01f3e6a40e7202310abbeb41c345d325bd69554f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01f3e6a40e7202310abbeb41c345d325bd69554f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01f3e6a40e7202310abbeb41c345d325bd69554f"}], "stats": {"total": 356, "additions": 326, "deletions": 30}, "files": [{"sha": "36f3f4d70f363d753d26dfca58f121a4e011f62a", "filename": "gcc/ira-color.c", "status": "modified", "additions": 254, "deletions": 30, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/037cc0b4a6646cc86549247a3590215ebd5c4c43/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/037cc0b4a6646cc86549247a3590215ebd5c4c43/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=037cc0b4a6646cc86549247a3590215ebd5c4c43", "patch": "@@ -36,6 +36,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"reload.h\"\n #include \"cfgloop.h\"\n \n+/* To prevent soft conflict detection becoming quadratic in the\n+   loop depth.  Only for very pathological cases, so it hardly\n+   seems worth a --param.  */\n+const int max_soft_conflict_loop_depth = 64;\n+\n typedef struct allocno_hard_regs *allocno_hard_regs_t;\n \n /* The structure contains information about hard registers can be\n@@ -1707,6 +1712,167 @@ calculate_saved_nregs (int hard_regno, machine_mode mode)\n   return nregs;\n }\n \n+/* Allocnos A1 and A2 are known to conflict.  Check whether, in some loop L\n+   that is either the current loop or a nested subloop, the conflict is of\n+   the following form:\n+\n+   - One allocno (X) is a cap allocno for some non-cap allocno X2.\n+\n+   - X2 belongs to some loop L2.\n+\n+   - The other allocno (Y) is a non-cap allocno.\n+\n+   - Y is an ancestor of some allocno Y2 in L2.  (Note that such a Y2\n+     must exist, given that X and Y conflict.)\n+\n+   - Y2 is not referenced in L2 (that is, ALLOCNO_NREFS (Y2) == 0).\n+\n+   - Y can use a different allocation from Y2.\n+\n+   In this case, Y's register is live across L2 but is not used within it,\n+   whereas X's register is used only within L2.  The conflict is therefore\n+   only \"soft\", in that it can easily be avoided by spilling Y2 inside L2\n+   without affecting any insn references.\n+\n+   If the conflict does have this form, return the Y2 that would need to be\n+   spilled in order to allow X and Y (and thus A1 and A2) to use the same\n+   register.  Return null otherwise.  Returning null is conservatively correct;\n+   any nonnnull return value is an optimization.  */\n+ira_allocno_t\n+ira_soft_conflict (ira_allocno_t a1, ira_allocno_t a2)\n+{\n+  /* Search for the loop L and its associated allocnos X and Y.  */\n+  int search_depth = 0;\n+  while (ALLOCNO_CAP_MEMBER (a1) && ALLOCNO_CAP_MEMBER (a2))\n+    {\n+      a1 = ALLOCNO_CAP_MEMBER (a1);\n+      a2 = ALLOCNO_CAP_MEMBER (a2);\n+      if (search_depth++ > max_soft_conflict_loop_depth)\n+\treturn nullptr;\n+    }\n+  /* This must be true if A1 and A2 conflict.  */\n+  ira_assert (ALLOCNO_LOOP_TREE_NODE (a1) == ALLOCNO_LOOP_TREE_NODE (a2));\n+\n+  /* Make A1 the cap allocno (X in the comment above) and A2 the\n+     non-cap allocno (Y in the comment above).  */\n+  if (ALLOCNO_CAP_MEMBER (a2))\n+    std::swap (a1, a2);\n+  if (!ALLOCNO_CAP_MEMBER (a1))\n+    return nullptr;\n+\n+  /* Search for the real allocno that A1 caps (X2 in the comment above).  */\n+  do\n+    {\n+      a1 = ALLOCNO_CAP_MEMBER (a1);\n+      if (search_depth++ > max_soft_conflict_loop_depth)\n+\treturn nullptr;\n+    }\n+  while (ALLOCNO_CAP_MEMBER (a1));\n+\n+  /* Find the associated allocno for A2 (Y2 in the comment above).  */\n+  auto node = ALLOCNO_LOOP_TREE_NODE (a1);\n+  auto local_a2 = node->regno_allocno_map[ALLOCNO_REGNO (a2)];\n+\n+  /* Find the parent of LOCAL_A2/Y2.  LOCAL_A2 must be a descendant of A2\n+     for the conflict query to make sense, so this parent lookup must succeed.\n+\n+     If the parent allocno has no references, it is usually cheaper to\n+     spill at that loop level instead.  Keep searching until we find\n+     a parent allocno that does have references (but don't look past\n+     the starting allocno).  */\n+  ira_allocno_t local_parent_a2;\n+  for (;;)\n+    {\n+      local_parent_a2 = ira_parent_allocno (local_a2);\n+      if (local_parent_a2 == a2 || ALLOCNO_NREFS (local_parent_a2) != 0)\n+\tbreak;\n+      local_a2 = local_parent_a2;\n+    }\n+  if (CHECKING_P)\n+    {\n+      /* Sanity check to make sure that the conflict we've been given\n+\t makes sense.  */\n+      auto test_a2 = local_parent_a2;\n+      while (test_a2 != a2)\n+\t{\n+\t  test_a2 = ira_parent_allocno (test_a2);\n+\t  ira_assert (test_a2);\n+\t}\n+    }\n+  if (local_a2\n+      && ALLOCNO_NREFS (local_a2) == 0\n+      && ira_subloop_allocnos_can_differ_p (local_parent_a2))\n+    return local_a2;\n+  return nullptr;\n+}\n+\n+/* The caller has decided to allocate HREGNO to A and has proved that\n+   this is safe.  However, the allocation might require the kind of\n+   spilling described in the comment above ira_soft_conflict.\n+   The caller has recorded that:\n+\n+   - The allocnos in ALLOCNOS_TO_SPILL are the ones that would need\n+     to be spilled to satisfy soft conflicts for at least one allocation\n+     (not necessarily HREGNO).\n+\n+   - The soft conflicts apply only to A allocations that overlap\n+     SOFT_CONFLICT_REGS.\n+\n+   If allocating HREGNO is subject to any soft conflicts, record the\n+   subloop allocnos that need to be spilled.  */\n+static void\n+spill_soft_conflicts (ira_allocno_t a, bitmap allocnos_to_spill,\n+\t\t      HARD_REG_SET soft_conflict_regs, int hregno)\n+{\n+  auto nregs = hard_regno_nregs (hregno, ALLOCNO_MODE (a));\n+  bitmap_iterator bi;\n+  unsigned int i;\n+  EXECUTE_IF_SET_IN_BITMAP (allocnos_to_spill, 0, i, bi)\n+    {\n+      /* SPILL_A needs to be spilled for at least one allocation\n+\t (not necessarily this one).  */\n+      auto spill_a = ira_allocnos[i];\n+\n+      /* Find the corresponding allocno for this loop.  */\n+      auto conflict_a = spill_a;\n+      do\n+\t{\n+\t  conflict_a = ira_parent_or_cap_allocno (conflict_a);\n+\t  ira_assert (conflict_a);\n+\t}\n+      while (ALLOCNO_LOOP_TREE_NODE (conflict_a)->level\n+\t     > ALLOCNO_LOOP_TREE_NODE (a)->level);\n+\n+      ira_assert (ALLOCNO_LOOP_TREE_NODE (conflict_a)\n+\t\t  == ALLOCNO_LOOP_TREE_NODE (a));\n+\n+      if (conflict_a == a)\n+\t{\n+\t  /* SPILL_A is a descendant of A.  We don't know (and don't need\n+\t     to know) which cap allocnos have a soft conflict with A.\n+\t     All we need to do is test whether the soft conflict applies\n+\t     to the chosen allocation.  */\n+\t  if (ira_hard_reg_set_intersection_p (hregno, ALLOCNO_MODE (a),\n+\t\t\t\t\t       soft_conflict_regs))\n+\t    ALLOCNO_MIGHT_CONFLICT_WITH_PARENT_P (spill_a) = true;\n+\t}\n+      else\n+\t{\n+\t  /* SPILL_A is a descendant of CONFLICT_A, which has a soft conflict\n+\t     with A.  Test whether the soft conflict applies to the current\n+\t     allocation.  */\n+\t  ira_assert (ira_soft_conflict (a, conflict_a) == spill_a);\n+\t  auto conflict_hregno = ALLOCNO_HARD_REGNO (conflict_a);\n+\t  ira_assert (conflict_hregno >= 0);\n+\t  auto conflict_nregs = hard_regno_nregs (conflict_hregno,\n+\t\t\t\t\t\t  ALLOCNO_MODE (conflict_a));\n+\t  if (hregno + nregs > conflict_hregno\n+\t      && conflict_hregno + conflict_nregs > hregno)\n+\t    ALLOCNO_MIGHT_CONFLICT_WITH_PARENT_P (spill_a) = true;\n+\t}\n+    }\n+}\n+\n /* Choose a hard register for allocno A.  If RETRY_P is TRUE, it means\n    that the function called from function\n    `ira_reassign_conflict_allocnos' and `allocno_reload_assign'.  In\n@@ -1746,6 +1912,8 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)\n #ifdef STACK_REGS\n   bool no_stack_reg_p;\n #endif\n+  auto_bitmap allocnos_to_spill;\n+  HARD_REG_SET soft_conflict_regs = {};\n \n   ira_assert (! ALLOCNO_ASSIGNED_P (a));\n   get_conflict_and_start_profitable_regs (a, retry_p,\n@@ -1833,23 +2001,56 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)\n \n \t\t  mode = ALLOCNO_MODE (conflict_a);\n \t\t  conflict_nregs = hard_regno_nregs (hard_regno, mode);\n-\t\t  if (conflict_nregs == n_objects && conflict_nregs > 1)\n+\t\t  auto spill_a = (retry_p\n+\t\t\t\t  ? nullptr\n+\t\t\t\t  : ira_soft_conflict (a, conflict_a));\n+\t\t  if (spill_a)\n \t\t    {\n-\t\t      int num = OBJECT_SUBWORD (conflict_obj);\n-\n-\t\t      if (REG_WORDS_BIG_ENDIAN)\n-\t\t\tSET_HARD_REG_BIT (conflicting_regs[word],\n-\t\t\t\t\t  hard_regno + n_objects - num - 1);\n-\t\t      else\n-\t\t\tSET_HARD_REG_BIT (conflicting_regs[word],\n-\t\t\t\t\t  hard_regno + num);\n+\t\t      if (bitmap_set_bit (allocnos_to_spill,\n+\t\t\t\t\t  ALLOCNO_NUM (spill_a)))\n+\t\t\t{\n+\t\t\t  ira_loop_border_costs border_costs (spill_a);\n+\t\t\t  auto cost = border_costs.spill_inside_loop_cost ();\n+\t\t\t  auto note_conflict = [&](int r)\n+\t\t\t    {\n+\t\t\t      SET_HARD_REG_BIT (soft_conflict_regs, r);\n+\t\t\t      auto hri = ira_class_hard_reg_index[aclass][r];\n+\t\t\t      if (hri >= 0)\n+\t\t\t\t{\n+\t\t\t\t  costs[hri] += cost;\n+\t\t\t\t  full_costs[hri] += cost;\n+\t\t\t\t}\n+\t\t\t    };\n+\t\t\t  for (int r = hard_regno;\n+\t\t\t       r >= 0 && (int) end_hard_regno (mode, r) > hard_regno;\n+\t\t\t       r--)\n+\t\t\t    note_conflict (r);\n+\t\t\t  for (int r = hard_regno + 1;\n+\t\t\t       r < hard_regno + conflict_nregs;\n+\t\t\t       r++)\n+\t\t\t    note_conflict (r);\n+\t\t\t}\n \t\t    }\n \t\t  else\n-\t\t    conflicting_regs[word]\n-\t\t      |= ira_reg_mode_hard_regset[hard_regno][mode];\n-\t\t  if (hard_reg_set_subset_p (profitable_hard_regs,\n-\t\t\t\t\t     conflicting_regs[word]))\n-\t\t    goto fail;\n+\t\t    {\n+\t\t      if (conflict_nregs == n_objects && conflict_nregs > 1)\n+\t\t\t{\n+\t\t\t  int num = OBJECT_SUBWORD (conflict_obj);\n+\n+\t\t\t  if (REG_WORDS_BIG_ENDIAN)\n+\t\t\t    SET_HARD_REG_BIT (conflicting_regs[word],\n+\t\t\t\t\t      hard_regno + n_objects - num - 1);\n+\t\t\t  else\n+\t\t\t    SET_HARD_REG_BIT (conflicting_regs[word],\n+\t\t\t\t\t      hard_regno + num);\n+\t\t\t}\n+\t\t      else\n+\t\t\tconflicting_regs[word]\n+\t\t\t  |= ira_reg_mode_hard_regset[hard_regno][mode];\n+\t\t      if (hard_reg_set_subset_p (profitable_hard_regs,\n+\t\t\t\t\t\t conflicting_regs[word]))\n+\t\t\tgoto fail;\n+\t\t    }\n \t\t}\n \t    }\n \t  else if (! retry_p\n@@ -1962,6 +2163,8 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)\n     {\n       for (i = hard_regno_nregs (best_hard_regno, mode) - 1; i >= 0; i--)\n \tallocated_hardreg_p[best_hard_regno + i] = true;\n+      spill_soft_conflicts (a, allocnos_to_spill, soft_conflict_regs,\n+\t\t\t    best_hard_regno);\n     }\n   if (! retry_p)\n     restore_costs_from_copies (a);\n@@ -2983,6 +3186,8 @@ improve_allocation (void)\n \t   assigning hard register to allocno A even without spilling\n \t   conflicting allocnos.  */\n \tcontinue;\n+      auto_bitmap allocnos_to_spill;\n+      HARD_REG_SET soft_conflict_regs = {};\n       mode = ALLOCNO_MODE (a);\n       nwords = ALLOCNO_NUM_OBJECTS (a);\n       /* Process each allocno conflicting with A and update the cost\n@@ -3008,31 +3213,49 @@ improve_allocation (void)\n \t      ALLOCNO_COLOR_DATA (conflict_a)->temp = check;\n \t      if ((conflict_hregno = ALLOCNO_HARD_REGNO (conflict_a)) < 0)\n \t\tcontinue;\n-\t      spill_cost = ALLOCNO_UPDATED_MEMORY_COST (conflict_a);\n-\t      k = (ira_class_hard_reg_index\n-\t\t   [ALLOCNO_CLASS (conflict_a)][conflict_hregno]);\n-\t      ira_assert (k >= 0);\n-\t      if ((allocno_costs = ALLOCNO_HARD_REG_COSTS (conflict_a))\n-\t\t  != NULL)\n-\t\tspill_cost -= allocno_costs[k];\n+\t      auto spill_a = ira_soft_conflict (a, conflict_a);\n+\t      if (spill_a)\n+\t\t{\n+\t\t  if (!bitmap_set_bit (allocnos_to_spill,\n+\t\t\t\t       ALLOCNO_NUM (spill_a)))\n+\t\t    continue;\n+\t\t  ira_loop_border_costs border_costs (spill_a);\n+\t\t  spill_cost = border_costs.spill_inside_loop_cost ();\n+\t\t}\n \t      else\n-\t\tspill_cost -= ALLOCNO_UPDATED_CLASS_COST (conflict_a);\n-\t      spill_cost\n-\t\t+= allocno_copy_cost_saving (conflict_a, conflict_hregno);\n+\t\t{\n+\t\t  spill_cost = ALLOCNO_UPDATED_MEMORY_COST (conflict_a);\n+\t\t  k = (ira_class_hard_reg_index\n+\t\t       [ALLOCNO_CLASS (conflict_a)][conflict_hregno]);\n+\t\t  ira_assert (k >= 0);\n+\t\t  if ((allocno_costs = ALLOCNO_HARD_REG_COSTS (conflict_a))\n+\t\t      != NULL)\n+\t\t    spill_cost -= allocno_costs[k];\n+\t\t  else\n+\t\t    spill_cost -= ALLOCNO_UPDATED_CLASS_COST (conflict_a);\n+\t\t  spill_cost\n+\t\t    += allocno_copy_cost_saving (conflict_a, conflict_hregno);\n+\t\t}\n \t      conflict_nregs = hard_regno_nregs (conflict_hregno,\n \t\t\t\t\t\t ALLOCNO_MODE (conflict_a));\n+\t      auto note_conflict = [&](int r)\n+\t\t{\n+\t\t  if (check_hard_reg_p (a, r,\n+\t\t\t\t\tconflicting_regs, profitable_hard_regs))\n+\t\t    {\n+\t\t      if (spill_a)\n+\t\t\tSET_HARD_REG_BIT (soft_conflict_regs, r);\n+\t\t      costs[r] += spill_cost;\n+\t\t    }\n+\t\t};\n \t      for (r = conflict_hregno;\n \t\t   r >= 0 && (int) end_hard_regno (mode, r) > conflict_hregno;\n \t\t   r--)\n-\t\tif (check_hard_reg_p (a, r,\n-\t\t\t\t      conflicting_regs, profitable_hard_regs))\n-\t\t  costs[r] += spill_cost;\n+\t\tnote_conflict (r);\n \t      for (r = conflict_hregno + 1;\n \t\t   r < conflict_hregno + conflict_nregs;\n \t\t   r++)\n-\t\tif (check_hard_reg_p (a, r,\n-\t\t\t\t      conflicting_regs, profitable_hard_regs))\n-\t\t  costs[r] += spill_cost;\n+\t\tnote_conflict (r);\n \t    }\n \t}\n       min_cost = INT_MAX;\n@@ -3055,6 +3278,7 @@ improve_allocation (void)\n \t   by spilling some conflicting allocnos does not improve the\n \t   allocation cost.  */\n \tcontinue;\n+      spill_soft_conflicts (a, allocnos_to_spill, soft_conflict_regs, best);\n       nregs = hard_regno_nregs (best, mode);\n       /* Now spill conflicting allocnos which contain a hard register\n \t of A when we assign the best chosen hard register to it.  */"}, {"sha": "e1e68025211448232483dd84548e2be4f22e4f3c", "filename": "gcc/ira-int.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/037cc0b4a6646cc86549247a3590215ebd5c4c43/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/037cc0b4a6646cc86549247a3590215ebd5c4c43/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=037cc0b4a6646cc86549247a3590215ebd5c4c43", "patch": "@@ -1067,6 +1067,7 @@ extern void ira_debug_conflicts (bool);\n extern void ira_build_conflicts (void);\n \n /* ira-color.c */\n+extern ira_allocno_t ira_soft_conflict (ira_allocno_t, ira_allocno_t);\n extern void ira_debug_hard_regs_forest (void);\n extern int ira_loop_edge_freq (ira_loop_tree_node_t, int, bool);\n extern void ira_reassign_conflict_allocnos (int);"}, {"sha": "3bece668692ba03ea0b6b00e253941991a329825", "filename": "gcc/ira.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/037cc0b4a6646cc86549247a3590215ebd5c4c43/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/037cc0b4a6646cc86549247a3590215ebd5c4c43/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=037cc0b4a6646cc86549247a3590215ebd5c4c43", "patch": "@@ -2649,6 +2649,8 @@ check_allocation (void)\n \t      int conflict_hard_regno = ALLOCNO_HARD_REGNO (conflict_a);\n \t      if (conflict_hard_regno < 0)\n \t\tcontinue;\n+\t      if (ira_soft_conflict (a, conflict_a))\n+\t\tcontinue;\n \n \t      conflict_nregs = hard_regno_nregs (conflict_hard_regno,\n \t\t\t\t\t\t ALLOCNO_MODE (conflict_a));"}, {"sha": "ceb6f50de2dc38c4e57f0d9d15526cd721591e74", "filename": "gcc/testsuite/gcc.target/aarch64/reg-alloc-4.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/037cc0b4a6646cc86549247a3590215ebd5c4c43/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Freg-alloc-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/037cc0b4a6646cc86549247a3590215ebd5c4c43/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Freg-alloc-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Freg-alloc-4.c?ref=037cc0b4a6646cc86549247a3590215ebd5c4c43", "patch": "@@ -0,0 +1,69 @@\n+/* { dg-options \"-O2 -fno-schedule-insns -fno-schedule-insns2\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" { target lp64 } } } */\n+\n+#define PROB 0.1\n+\n+struct L\n+{\n+  int data;\n+  volatile struct L *next;\n+  volatile struct L *inner;\n+};\n+\n+/* The thing we're testing here is that the !head->inner path of the outer loop\n+   body has no stack accesses.  It's possible that we'll need to update this\n+   pattern for unrelated code changes. but the test should be XFAILed rather\n+   than changed if any new stack accesses occur on the !head->inner path.  */\n+/*\n+** foo:\n+**\t...\n+**\tldr\t(w[0-9]+), \\[(x[0-9]+)\\]\n+**\tadd\t(w[0-9]+), (?:\\3, \\1|\\1, \\3)\n+**\tldr\t(x[0-9]+), \\[\\2, #?16\\]\n+**\tstr\t\\3, \\[\\2\\]\n+**\tldr\t\\2, \\[\\2, #?8\\]\n+**\tcbn?z\t\\4, .*\n+**\t...\n+**\tret\n+*/\n+void\n+foo (volatile struct L *head, int inc)\n+{\n+  while (head)\n+    {\n+      /* Clobber all call-preserved GPRs, so that the loop has to use\n+\t call-clobbered GPRs if it is to avoid spilling.  */\n+      asm volatile (\"\" :::\n+\t\t    \"x19\", \"x20\", \"x21\", \"x22\", \"x23\",\n+\t\t    \"x24\", \"x25\", \"x26\", \"x27\", \"x28\");\n+      inc = head->data + inc;\n+      volatile struct L *inner = head->inner;\n+      head->data = inc;\n+      head = head->next;\n+      if (__builtin_expect_with_probability (inner != 0, 0, PROB))\n+\tfor (int i = 0; i < 1000; ++i)\n+\t  asm volatile (\"\" ::\t\t\t/* example allocation: */\n+\t\t\t\"r\" (i),\t\t/* x0 */\n+\t\t\t\"r\" (inner),\t\t/* x1 */\n+\t\t\t\"r\" (inner->next),\t/* x2 */\n+\t\t\t\"r\" (inner->next),\t/* x3 */\n+\t\t\t\"r\" (inner->next),\t/* x4 */\n+\t\t\t\"r\" (inner->next),\t/* x5 */\n+\t\t\t\"r\" (inner->next),\t/* x6 */\n+\t\t\t\"r\" (inner->next),\t/* x7 */\n+\t\t\t\"r\" (inner->next),\t/* x8 */\n+\t\t\t\"r\" (inner->next),\t/* x9 */\n+\t\t\t\"r\" (inner->next),\t/* x10 */\n+\t\t\t\"r\" (inner->next),\t/* x11 */\n+\t\t\t\"r\" (inner->next),\t/* x12 */\n+\t\t\t\"r\" (inner->next),\t/* x13 */\n+\t\t\t\"r\" (inner->next),\t/* x14 */\n+\t\t\t\"r\" (inner->next),\t/* x15 */\n+\t\t\t\"r\" (inner->next),\t/* x16 */\n+\t\t\t\"r\" (inner->next),\t/* x17 */\n+\t\t\t\"r\" (inner->next),\t/* x18 */\n+\t\t\t\"r\" (inner->next) :\t/* x30 */\n+\t\t\t\"x19\", \"x20\", \"x21\", \"x22\", \"x23\",\n+\t\t\t\"x24\", \"x25\", \"x26\", \"x27\", \"x28\");\n+    }\n+}"}]}