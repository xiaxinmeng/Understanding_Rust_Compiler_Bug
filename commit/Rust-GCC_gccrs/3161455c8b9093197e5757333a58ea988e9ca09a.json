{"sha": "3161455c8b9093197e5757333a58ea988e9ca09a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE2MTQ1NWM4YjkwOTMxOTdlNTc1NzMzM2E1OGVhOTg4ZTljYTA5YQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-10-07T09:04:48Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-10-07T09:04:48Z"}, "message": "tree-vectorizer.h (stmt_vec_info_vec): Use vec<stmt_vec_info>.\n\n2015-10-07  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (stmt_vec_info_vec): Use vec<stmt_vec_info>.\n\t(vinfo_for_stmt): Adjust.\n\t(set_vinfo_for_stmt): Likewise.\n\t* tree-vectorizer.c (stmt_vec_info_vec): Likewise.\n\t* tree-vect-stmts.c (free_stmt_vec_info_vec): Likewise.\n\t* tree-vect-loop.c (new_loop_vec_info): Remove special-casing\n\tof inner loop.\n\t(vect_analyze_loop_1): Remove.\n\t(vect_analyze_loop_form_1): Avoid building a loop_vec_info for\n\tinner loop when vectorizing an outer loop by splitting out from ...\n\t(vect_analyze_loop_form): ... here.\n\nFrom-SVN: r228563", "tree": {"sha": "8948d85d4c83db950a5f45fe32b674157f9485c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8948d85d4c83db950a5f45fe32b674157f9485c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3161455c8b9093197e5757333a58ea988e9ca09a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3161455c8b9093197e5757333a58ea988e9ca09a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3161455c8b9093197e5757333a58ea988e9ca09a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3161455c8b9093197e5757333a58ea988e9ca09a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "baba8d7dc75a07b8acb5928b1f8173fe2ad04e49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baba8d7dc75a07b8acb5928b1f8173fe2ad04e49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/baba8d7dc75a07b8acb5928b1f8173fe2ad04e49"}], "stats": {"total": 257, "additions": 98, "deletions": 159}, "files": [{"sha": "bcbbde486f3c84c1c1d4a0323863ddef35232210", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3161455c8b9093197e5757333a58ea988e9ca09a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3161455c8b9093197e5757333a58ea988e9ca09a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3161455c8b9093197e5757333a58ea988e9ca09a", "patch": "@@ -1,3 +1,17 @@\n+2015-10-07  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (stmt_vec_info_vec): Use vec<stmt_vec_info>.\n+\t(vinfo_for_stmt): Adjust.\n+\t(set_vinfo_for_stmt): Likewise.\n+\t* tree-vectorizer.c (stmt_vec_info_vec): Likewise.\n+\t* tree-vect-stmts.c (free_stmt_vec_info_vec): Likewise.\n+\t* tree-vect-loop.c (new_loop_vec_info): Remove special-casing\n+\tof inner loop.\n+\t(vect_analyze_loop_1): Remove.\n+\t(vect_analyze_loop_form_1): Avoid building a loop_vec_info for\n+\tinner loop when vectorizing an outer loop by splitting out from ...\n+\t(vect_analyze_loop_form): ... here.\n+\n 2015-10-07  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \tPR c/65345"}, {"sha": "26b7f8c058271597edd346e2da953b0d03a3b4ac", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 77, "deletions": 149, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3161455c8b9093197e5757333a58ea988e9ca09a/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3161455c8b9093197e5757333a58ea988e9ca09a/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=3161455c8b9093197e5757333a58ea988e9ca09a", "patch": "@@ -907,53 +907,19 @@ new_loop_vec_info (struct loop *loop)\n     {\n       basic_block bb = bbs[i];\n \n-      /* BBs in a nested inner-loop will have been already processed (because\n-         we will have called vect_analyze_loop_form for any nested inner-loop).\n-         Therefore, for stmts in an inner-loop we just want to update the\n-         STMT_VINFO_LOOP_VINFO field of their stmt_info to point to the new\n-         loop_info of the outer-loop we are currently considering to vectorize\n-         (instead of the loop_info of the inner-loop).\n-         For stmts in other BBs we need to create a stmt_info from scratch.  */\n-      if (bb->loop_father != loop)\n-        {\n-          /* Inner-loop bb.  */\n-          gcc_assert (loop->inner && bb->loop_father == loop->inner);\n-          for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n-            {\n-\t      gimple *phi = gsi_stmt (si);\n-              stmt_vec_info stmt_info = vinfo_for_stmt (phi);\n-              loop_vec_info inner_loop_vinfo =\n-                STMT_VINFO_LOOP_VINFO (stmt_info);\n-              gcc_assert (loop->inner == LOOP_VINFO_LOOP (inner_loop_vinfo));\n-              stmt_info->vinfo = res;\n-            }\n-          for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n-           {\n-\t     gimple *stmt = gsi_stmt (si);\n-              stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-              loop_vec_info inner_loop_vinfo =\n-                 STMT_VINFO_LOOP_VINFO (stmt_info);\n-              gcc_assert (loop->inner == LOOP_VINFO_LOOP (inner_loop_vinfo));\n-              stmt_info->vinfo = res;\n-           }\n-        }\n-      else\n-        {\n-          /* bb in current nest.  */\n-          for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n-            {\n-\t      gimple *phi = gsi_stmt (si);\n-              gimple_set_uid (phi, 0);\n-              set_vinfo_for_stmt (phi, new_stmt_vec_info (phi, res));\n-            }\n+      for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n+\t{\n+\t  gimple *phi = gsi_stmt (si);\n+\t  gimple_set_uid (phi, 0);\n+\t  set_vinfo_for_stmt (phi, new_stmt_vec_info (phi, res));\n+\t}\n \n-          for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n-            {\n-\t      gimple *stmt = gsi_stmt (si);\n-              gimple_set_uid (stmt, 0);\n-              set_vinfo_for_stmt (stmt, new_stmt_vec_info (stmt, res));\n-            }\n-        }\n+      for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+\t{\n+\t  gimple *stmt = gsi_stmt (si);\n+\t  gimple_set_uid (stmt, 0);\n+\t  set_vinfo_for_stmt (stmt, new_stmt_vec_info (stmt, res));\n+\t}\n     }\n \n   /* CHECKME: We want to visit all BBs before their successors (except for\n@@ -1150,54 +1116,19 @@ vect_get_single_scalar_iteration_cost (loop_vec_info loop_vinfo)\n }\n \n \n-/* Function vect_analyze_loop_1.\n-\n-   Apply a set of analyses on LOOP, and create a loop_vec_info struct\n-   for it. The different analyses will record information in the\n-   loop_vec_info struct.  This is a subset of the analyses applied in\n-   vect_analyze_loop, to be applied on an inner-loop nested in the loop\n-   that is now considered for (outer-loop) vectorization.  */\n-\n-static loop_vec_info\n-vect_analyze_loop_1 (struct loop *loop)\n-{\n-  loop_vec_info loop_vinfo;\n-\n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"===== analyze_loop_nest_1 =====\\n\");\n-\n-  /* Check the CFG characteristics of the loop (nesting, entry/exit, etc.  */\n-\n-  loop_vinfo = vect_analyze_loop_form (loop);\n-  if (!loop_vinfo)\n-    {\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"bad inner-loop form.\\n\");\n-      return NULL;\n-    }\n-\n-  return loop_vinfo;\n-}\n-\n-\n-/* Function vect_analyze_loop_form.\n+/* Function vect_analyze_loop_form_1.\n \n    Verify that certain CFG restrictions hold, including:\n    - the loop has a pre-header\n    - the loop has a single entry and exit\n    - the loop exit condition is simple enough, and the number of iterations\n      can be analyzed (a countable loop).  */\n \n-loop_vec_info\n-vect_analyze_loop_form (struct loop *loop)\n+bool\n+vect_analyze_loop_form_1 (struct loop *loop, gcond **loop_cond,\n+\t\t\t  tree *number_of_iterationsm1,\n+\t\t\t  tree *number_of_iterations, gcond **inner_loop_cond)\n {\n-  loop_vec_info loop_vinfo;\n-  gcond *loop_cond;\n-  tree number_of_iterations = NULL, number_of_iterationsm1 = NULL;\n-  loop_vec_info inner_loop_vinfo = NULL;\n-\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"=== vect_analyze_loop_form ===\\n\");\n@@ -1225,15 +1156,15 @@ vect_analyze_loop_form (struct loop *loop)\n           if (dump_enabled_p ())\n             dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"not vectorized: control flow in loop.\\n\");\n-          return NULL;\n+          return false;\n         }\n \n       if (empty_block_p (loop->header))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"not vectorized: empty loop.\\n\");\n-\t  return NULL;\n+\t  return false;\n \t}\n     }\n   else\n@@ -1263,53 +1194,46 @@ vect_analyze_loop_form (struct loop *loop)\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"not vectorized: multiple nested loops.\\n\");\n-\t  return NULL;\n-\t}\n-\n-      /* Analyze the inner-loop.  */\n-      inner_loop_vinfo = vect_analyze_loop_1 (loop->inner);\n-      if (!inner_loop_vinfo)\n-\t{\n-\t  if (dump_enabled_p ())\n-            dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: Bad inner loop.\\n\");\n-\t  return NULL;\n-\t}\n-\n-      if (!expr_invariant_in_loop_p (loop,\n-\t\t\t\t\tLOOP_VINFO_NITERS (inner_loop_vinfo)))\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: inner-loop count not\"\n-                             \" invariant.\\n\");\n-\t  destroy_loop_vec_info (inner_loop_vinfo, true);\n-\t  return NULL;\n+\t  return false;\n \t}\n \n       if (loop->num_nodes != 5)\n         {\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"not vectorized: control flow in loop.\\n\");\n-\t  destroy_loop_vec_info (inner_loop_vinfo, true);\n-\t  return NULL;\n+\t  return false;\n         }\n \n-      gcc_assert (EDGE_COUNT (innerloop->header->preds) == 2);\n-      entryedge = EDGE_PRED (innerloop->header, 0);\n-      if (EDGE_PRED (innerloop->header, 0)->src == innerloop->latch)\n-\tentryedge = EDGE_PRED (innerloop->header, 1);\n-\n+      entryedge = loop_preheader_edge (innerloop);\n       if (entryedge->src != loop->header\n \t  || !single_exit (innerloop)\n-\t  || single_exit (innerloop)->dest !=  EDGE_PRED (loop->latch, 0)->src)\n+\t  || single_exit (innerloop)->dest != EDGE_PRED (loop->latch, 0)->src)\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"not vectorized: unsupported outerloop form.\\n\");\n-\t  destroy_loop_vec_info (inner_loop_vinfo, true);\n-\t  return NULL;\n+\t  return false;\n+\t}\n+\n+      /* Analyze the inner-loop.  */\n+      tree inner_niterm1, inner_niter;\n+      if (! vect_analyze_loop_form_1 (loop->inner, inner_loop_cond,\n+\t\t\t\t      &inner_niterm1, &inner_niter, NULL))\n+\t{\n+\t  if (dump_enabled_p ())\n+            dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: Bad inner loop.\\n\");\n+\t  return false;\n+\t}\n+\n+      if (!expr_invariant_in_loop_p (loop, inner_niter))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: inner-loop count not\"\n+                             \" invariant.\\n\");\n+\t  return false;\n \t}\n \n       if (dump_enabled_p ())\n@@ -1329,9 +1253,7 @@ vect_analyze_loop_form (struct loop *loop)\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"not vectorized: too many incoming edges.\\n\");\n         }\n-      if (inner_loop_vinfo)\n-\tdestroy_loop_vec_info (inner_loop_vinfo, true);\n-      return NULL;\n+      return false;\n     }\n \n   /* We assume that the loop exit condition is at the end of the loop. i.e,\n@@ -1344,9 +1266,7 @@ vect_analyze_loop_form (struct loop *loop)\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: latch block not empty.\\n\");\n-      if (inner_loop_vinfo)\n-\tdestroy_loop_vec_info (inner_loop_vinfo, true);\n-      return NULL;\n+      return false;\n     }\n \n   /* Make sure there exists a single-predecessor exit bb:  */\n@@ -1364,47 +1284,54 @@ vect_analyze_loop_form (struct loop *loop)\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"not vectorized: abnormal loop exit edge.\\n\");\n-\t  if (inner_loop_vinfo)\n-\t    destroy_loop_vec_info (inner_loop_vinfo, true);\n-\t  return NULL;\n+\t  return false;\n \t}\n     }\n \n-  loop_cond = vect_get_loop_niters (loop, &number_of_iterations,\n-\t\t\t\t    &number_of_iterationsm1);\n-  if (!loop_cond)\n+  *loop_cond = vect_get_loop_niters (loop, number_of_iterations,\n+\t\t\t\t     number_of_iterationsm1);\n+  if (!*loop_cond)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: complicated exit condition.\\n\");\n-      if (inner_loop_vinfo)\n-\tdestroy_loop_vec_info (inner_loop_vinfo, true);\n-      return NULL;\n+      return false;\n     }\n \n-  if (!number_of_iterations\n-      || chrec_contains_undetermined (number_of_iterations))\n+  if (!*number_of_iterations\n+      || chrec_contains_undetermined (*number_of_iterations))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: number of iterations cannot be \"\n \t\t\t \"computed.\\n\");\n-      if (inner_loop_vinfo)\n-\tdestroy_loop_vec_info (inner_loop_vinfo, true);\n-      return NULL;\n+      return false;\n     }\n \n-  if (integer_zerop (number_of_iterations))\n+  if (integer_zerop (*number_of_iterations))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: number of iterations = 0.\\n\");\n-      if (inner_loop_vinfo)\n-        destroy_loop_vec_info (inner_loop_vinfo, true);\n-      return NULL;\n+      return false;\n     }\n \n-  loop_vinfo = new_loop_vec_info (loop);\n+  return true;\n+}\n+\n+/* Analyze LOOP form and return a loop_vec_info if it is of suitable form.  */\n+\n+loop_vec_info\n+vect_analyze_loop_form (struct loop *loop)\n+{\n+  tree number_of_iterations, number_of_iterationsm1;\n+  gcond *loop_cond, *inner_loop_cond = NULL;\n+\n+  if (! vect_analyze_loop_form_1 (loop, &loop_cond, &number_of_iterationsm1,\n+\t\t\t\t  &number_of_iterations, &inner_loop_cond))\n+    return NULL;\n+\n+  loop_vec_info loop_vinfo = new_loop_vec_info (loop);\n   LOOP_VINFO_NITERSM1 (loop_vinfo) = number_of_iterationsm1;\n   LOOP_VINFO_NITERS (loop_vinfo) = number_of_iterations;\n   LOOP_VINFO_NITERS_UNCHANGED (loop_vinfo) = number_of_iterations;\n@@ -1421,16 +1348,17 @@ vect_analyze_loop_form (struct loop *loop)\n     }\n \n   STMT_VINFO_TYPE (vinfo_for_stmt (loop_cond)) = loop_exit_ctrl_vec_info_type;\n-\n-  /* CHECKME: May want to keep it around it in the future.  */\n-  if (inner_loop_vinfo)\n-    destroy_loop_vec_info (inner_loop_vinfo, false);\n+  if (inner_loop_cond)\n+    STMT_VINFO_TYPE (vinfo_for_stmt (inner_loop_cond))\n+      = loop_exit_ctrl_vec_info_type;\n \n   gcc_assert (!loop->aux);\n   loop->aux = loop_vinfo;\n   return loop_vinfo;\n }\n \n+\n+\n /* Scan the loop stmts and dependent on whether there are any (non-)SLP\n    statements update the vectorization factor.  */\n "}, {"sha": "8961dda6c06bc836965c54f555e62aa3839fc821", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3161455c8b9093197e5757333a58ea988e9ca09a/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3161455c8b9093197e5757333a58ea988e9ca09a/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=3161455c8b9093197e5757333a58ea988e9ca09a", "patch": "@@ -8033,10 +8033,10 @@ void\n free_stmt_vec_info_vec (void)\n {\n   unsigned int i;\n-  vec_void_p info;\n+  stmt_vec_info info;\n   FOR_EACH_VEC_ELT (stmt_vec_info_vec, i, info)\n     if (info != NULL)\n-      free_stmt_vec_info (STMT_VINFO_STMT ((stmt_vec_info) info));\n+      free_stmt_vec_info (STMT_VINFO_STMT (info));\n   gcc_assert (stmt_vec_info_vec.exists ());\n   stmt_vec_info_vec.release ();\n }"}, {"sha": "1e4b2a6479edd2237a5822a844a5fc31da73c421", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3161455c8b9093197e5757333a58ea988e9ca09a/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3161455c8b9093197e5757333a58ea988e9ca09a/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=3161455c8b9093197e5757333a58ea988e9ca09a", "patch": "@@ -87,7 +87,7 @@ along with GCC; see the file COPYING3.  If not see\n source_location vect_location;\n \n /* Vector mapping GIMPLE stmt to stmt_vec_info. */\n-vec<vec_void_p> stmt_vec_info_vec;\n+vec<stmt_vec_info> stmt_vec_info_vec;\n \f\n /* For mapping simduid to vectorization factor.  */\n "}, {"sha": "39f92728e95e7b85dff97c7ce0d4d4d8119b0e30", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3161455c8b9093197e5757333a58ea988e9ca09a/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3161455c8b9093197e5757333a58ea988e9ca09a/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=3161455c8b9093197e5757333a58ea988e9ca09a", "patch": "@@ -741,10 +741,7 @@ struct dataref_aux {\n /* The maximum vectorization factor supported by any target (V64QI).  */\n #define MAX_VECTORIZATION_FACTOR 64\n \n-/* Avoid GTY(()) on stmt_vec_info.  */\n-typedef void *vec_void_p;\n-\n-extern vec<vec_void_p> stmt_vec_info_vec;\n+extern vec<stmt_vec_info> stmt_vec_info_vec;\n \n void init_stmt_vec_info_vec (void);\n void free_stmt_vec_info_vec (void);\n@@ -758,7 +755,7 @@ vinfo_for_stmt (gimple *stmt)\n   if (uid == 0)\n     return NULL;\n \n-  return (stmt_vec_info) stmt_vec_info_vec[uid - 1];\n+  return stmt_vec_info_vec[uid - 1];\n }\n \n /* Set vectorizer information INFO for STMT.  */\n@@ -772,10 +769,10 @@ set_vinfo_for_stmt (gimple *stmt, stmt_vec_info info)\n       gcc_checking_assert (info);\n       uid = stmt_vec_info_vec.length () + 1;\n       gimple_set_uid (stmt, uid);\n-      stmt_vec_info_vec.safe_push ((vec_void_p) info);\n+      stmt_vec_info_vec.safe_push (info);\n     }\n   else\n-    stmt_vec_info_vec[uid - 1] = (vec_void_p) info;\n+    stmt_vec_info_vec[uid - 1] = info;\n }\n \n /* Return the earlier statement between STMT1 and STMT2.  */"}]}