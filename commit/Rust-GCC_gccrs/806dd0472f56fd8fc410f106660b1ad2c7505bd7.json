{"sha": "806dd0472f56fd8fc410f106660b1ad2c7505bd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA2ZGQwNDcyZjU2ZmQ4ZmM0MTBmMTA2NjYwYjFhZDJjNzUwNWJkNw==", "commit": {"author": {"name": "Corentin Gay", "email": "gay@adacore.com", "date": "2019-11-14T15:58:31Z"}, "committer": {"name": "Olivier Hainque", "email": "hainque@gcc.gnu.org", "date": "2019-11-14T15:58:31Z"}, "message": "Improve the thread support for VxWorks\n\n2019-11-12  Corentin Gay  <gay@adacore.com>\n\t    Jerome Lambourg  <lambourg@adacore.com>\n\t    Olivier Hainque  <hainque@adacore.com>\n\n\tlibgcc/\n\n\t* config/t-gthr-vxworks: New file, add all the gthr-vxworks\n\tsources to LIB2ADDEH.\n\t* config/t-vxworks: Remove adjustments to LIB2ADDEH.\n\t* config/t-vxworks7: Likewise.\n\n\t* config.host: Append a block at the end of the file to add the\n\tt-gthr files to the tmake_file list for VxWorks after everything\n\telse.\n\n\t* config/vxlib.c: Rename as gthr-vxworks.c.\n\t* config/vxlib-tls.c: Rename as gthr-vxworks-tls.c.\n\n\t* config/gthr-vxworks.h: Simplify a few comments.  Expose a TAS\n\tAPI and a basic error checking API, both internal.  Simplify the\n\t__gthread_once_t type definition and initializers.  Add sections\n\tfor condition variables support and for the C++0x thread support,\n\tconditioned against Vx653 for the latter.\n\n\t* config/gthr-vxworks.c (__gthread_once): Simplify comments and\n\timplementation, leveraging the TAS internal API.\n\t* config/gthr-vxworks-tls.c: Introduce an internal TLS data access\n\tAPI, leveraging the general availability of TLS services in VxWorks7\n\tpost SR6xxx.\n\t(__gthread_setspecific, __gthread_setspecific): Use it.\n\t(tls_delete_hook): Likewise, and simplify the enter/leave dtor logic.\n\t* config/gthr-vxworks-cond.c: New file.  GTHREAD_COND variable\n\tsupport based on VxWorks primitives.\n\t* config/gthr-vxworks-thread.c: New file.  GTHREAD_CXX0X support\n\tbased on VxWorks primitives.\n\nCo-Authored-By: Jerome Lambourg <lambourg@adacore.com>\nCo-Authored-By: Olivier Hainque <hainque@adacore.com>\n\nFrom-SVN: r278249", "tree": {"sha": "28b76cb20eb4fa23781aba02a1910fc7a2aca914", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28b76cb20eb4fa23781aba02a1910fc7a2aca914"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/806dd0472f56fd8fc410f106660b1ad2c7505bd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/806dd0472f56fd8fc410f106660b1ad2c7505bd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/806dd0472f56fd8fc410f106660b1ad2c7505bd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/806dd0472f56fd8fc410f106660b1ad2c7505bd7/comments", "author": {"login": "ashleygay", "id": 28534730, "node_id": "MDQ6VXNlcjI4NTM0NzMw", "avatar_url": "https://avatars.githubusercontent.com/u/28534730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ashleygay", "html_url": "https://github.com/ashleygay", "followers_url": "https://api.github.com/users/ashleygay/followers", "following_url": "https://api.github.com/users/ashleygay/following{/other_user}", "gists_url": "https://api.github.com/users/ashleygay/gists{/gist_id}", "starred_url": "https://api.github.com/users/ashleygay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ashleygay/subscriptions", "organizations_url": "https://api.github.com/users/ashleygay/orgs", "repos_url": "https://api.github.com/users/ashleygay/repos", "events_url": "https://api.github.com/users/ashleygay/events{/privacy}", "received_events_url": "https://api.github.com/users/ashleygay/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "78e49fb1bc69592389a09ce5544b40fef634e893", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78e49fb1bc69592389a09ce5544b40fef634e893", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78e49fb1bc69592389a09ce5544b40fef634e893"}], "stats": {"total": 1054, "additions": 835, "deletions": 219}, "files": [{"sha": "21efeb53dbe7bba36215f7a9261c18160e46c820", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806dd0472f56fd8fc410f106660b1ad2c7505bd7/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806dd0472f56fd8fc410f106660b1ad2c7505bd7/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=806dd0472f56fd8fc410f106660b1ad2c7505bd7", "patch": "@@ -1,3 +1,37 @@\n+2019-11-12  Corentin Gay  <gay@adacore.com>\n+\t    Jerome Lambourg  <lambourg@adacore.com>\n+\t    Olivier Hainque  <hainque@adacore.com>\n+\n+\t* config/t-gthr-vxworks: New file, add all the gthr-vxworks\n+\tsources to LIB2ADDEH.\n+\t* config/t-vxworks: Remove adjustments to LIB2ADDEH.\n+\t* config/t-vxworks7: Likewise.\n+\n+\t* config.host: Append a block at the end of the file to add the\n+\tt-gthr files to the tmake_file list for VxWorks after everything\n+\telse.\n+\n+\t* config/vxlib.c: Rename as gthr-vxworks.c.\n+\t* config/vxlib-tls.c: Rename as gthr-vxworks-tls.c.\n+\n+\t* config/gthr-vxworks.h: Simplify a few comments.  Expose a TAS\n+\tAPI and a basic error checking API, both internal.  Simplify the\n+\t__gthread_once_t type definition and initializers.  Add sections\n+\tfor condition variables support and for the C++0x thread support,\n+\tconditioned against Vx653 for the latter.\n+\n+\t* config/gthr-vxworks.c (__gthread_once): Simplify comments and\n+\timplementation, leveraging the TAS internal API.\n+\t* config/gthr-vxworks-tls.c: Introduce an internal TLS data access\n+\tAPI, leveraging the general availability of TLS services in VxWorks7\n+\tpost SR6xxx.\n+\t(__gthread_setspecific, __gthread_setspecific): Use it.\n+\t(tls_delete_hook): Likewise, and simplify the enter/leave dtor logic.\n+\t* config/gthr-vxworks-cond.c: New file.  GTHREAD_COND variable\n+\tsupport based on VxWorks primitives.\n+\t* config/gthr-vxworks-thread.c: New file.  GTHREAD_CXX0X support\n+\tbased on VxWorks primitives.\n+\n 2019-11-06  Jerome Lambourg  <lambourg@adacore.com>\n \t    Olivier Hainque  <hainque@adacore.com>\n "}, {"sha": "8a090bdb54a8f7be253d53e7af8e1419b2582206", "filename": "libgcc/config.host", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806dd0472f56fd8fc410f106660b1ad2c7505bd7/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806dd0472f56fd8fc410f106660b1ad2c7505bd7/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=806dd0472f56fd8fc410f106660b1ad2c7505bd7", "patch": "@@ -1513,3 +1513,15 @@ aarch64*-*-*)\n \ttm_file=\"${tm_file} aarch64/value-unwind.h\"\n \t;;\n esac\n+\n+# The vxworks threads implementation relies on a few extra sources,\n+# which we arrange to add after everything else:\n+\n+case ${target_thread_file} in\n+vxworks)\n+\tcase ${host} in\n+\t*-*-vxworks*)\n+\t\ttmake_file=\"${tmake_file} t-gthr-vxworks\"\n+\t\t;;\n+\tesac\n+esac"}, {"sha": "0747a3daff2577e372c2609cface3fc60151d746", "filename": "libgcc/config/gthr-vxworks-cond.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806dd0472f56fd8fc410f106660b1ad2c7505bd7/libgcc%2Fconfig%2Fgthr-vxworks-cond.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806dd0472f56fd8fc410f106660b1ad2c7505bd7/libgcc%2Fconfig%2Fgthr-vxworks-cond.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fgthr-vxworks-cond.c?ref=806dd0472f56fd8fc410f106660b1ad2c7505bd7", "patch": "@@ -0,0 +1,83 @@\n+/* Copyright (C) 2002-2019 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Threads compatibility routines for libgcc2 for VxWorks.\n+\n+   This file implements the GTHREAD_HAS_COND part of the interface\n+   exposed by gthr-vxworks.h.  */\n+\n+#include \"gthr.h\"\n+#include <taskLib.h>\n+\n+/* --------------------------- Condition Variables ------------------------ */\n+\n+void\n+__gthread_cond_init (__gthread_cond_t *cond)\n+{\n+  if (!cond)\n+    return;\n+  *cond = semBCreate (SEM_Q_FIFO, SEM_EMPTY);\n+}\n+\n+int\n+__gthread_cond_destroy (__gthread_cond_t *cond)\n+{\n+  if (!cond)\n+    return ERROR;\n+  return __CHECK_RESULT (semDelete (*cond));\n+}\n+\n+int\n+__gthread_cond_broadcast (__gthread_cond_t *cond)\n+{\n+  if (!cond)\n+    return ERROR;\n+\n+  return __CHECK_RESULT (semFlush (*cond));\n+}\n+\n+int\n+__gthread_cond_wait (__gthread_cond_t *cond,\n+\t\t     __gthread_mutex_t *mutex)\n+{\n+  if (!cond)\n+    return ERROR;\n+\n+  if (!mutex)\n+    return ERROR;\n+\n+  __RETURN_ERRNO_IF_NOT_OK (semGive (*mutex));\n+\n+  __RETURN_ERRNO_IF_NOT_OK (semTake (*cond, WAIT_FOREVER));\n+\n+  __RETURN_ERRNO_IF_NOT_OK (semTake (*mutex, WAIT_FOREVER));\n+\n+  return OK;\n+}\n+\n+int\n+__gthread_cond_wait_recursive (__gthread_cond_t *cond,\n+\t\t\t       __gthread_recursive_mutex_t *mutex)\n+{\n+  return __gthread_cond_wait (cond, mutex);\n+}"}, {"sha": "3c880ba1f3ff39bf0902fc564675f096c318efb0", "filename": "libgcc/config/gthr-vxworks-thread.c", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806dd0472f56fd8fc410f106660b1ad2c7505bd7/libgcc%2Fconfig%2Fgthr-vxworks-thread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806dd0472f56fd8fc410f106660b1ad2c7505bd7/libgcc%2Fconfig%2Fgthr-vxworks-thread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fgthr-vxworks-thread.c?ref=806dd0472f56fd8fc410f106660b1ad2c7505bd7", "patch": "@@ -0,0 +1,349 @@\n+/* Copyright (C) 2002-2019 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Threads compatibility routines for libgcc2 for VxWorks.\n+\n+   This file implements the GTHREAD_CXX0X part of the interface\n+   exposed by gthr-vxworks.h, using APIs exposed by regular (!AE/653)\n+   VxWorks kernels.  */\n+\n+#include \"gthr.h\"\n+#include <taskLib.h>\n+\n+#define __TIMESPEC_TO_NSEC(timespec) \\\n+  ((long long)timespec.tv_sec * 1000000000 + (long long)timespec.tv_nsec)\n+\n+#define __TIMESPEC_TO_TICKS(timespec) \\\n+  ((long long)(sysClkRateGet() * __TIMESPEC_TO_NSEC(timespec) + 999999999) \\\n+    / 1000000000)\n+\n+#ifdef __RTP__\n+  void tls_delete_hook ();\n+  #define __CALL_DELETE_HOOK(tcb) tls_delete_hook()\n+#else\n+  /* In kernel mode, we need to pass the TCB to task_delete_hook. The TCB is\n+     the pointer to the WIND_TCB structure and is the ID of the task.  */\n+  void tls_delete_hook (void *TCB);\n+  #define __CALL_DELETE_HOOK(tcb) tls_delete_hook((WIND_TCB *) ((tcb)->task_id))\n+#endif\n+\n+/* -------------------- Timed Condition Variables --------------------- */\n+\n+int\n+__gthread_cond_signal (__gthread_cond_t *cond)\n+{\n+  if (!cond)\n+    return ERROR;\n+\n+  return __CHECK_RESULT (semGive (*cond));\n+}\n+\n+int\n+__gthread_cond_timedwait (__gthread_cond_t *cond,\n+\t\t\t  __gthread_mutex_t *mutex,\n+\t\t\t  const __gthread_time_t *abs_timeout)\n+{\n+  if (!cond)\n+    return ERROR;\n+\n+  if (!mutex)\n+    return ERROR;\n+\n+  if (!abs_timeout)\n+    return ERROR;\n+\n+  struct timespec current;\n+  if (clock_gettime (CLOCK_REALTIME, &current) == ERROR)\n+    /* CLOCK_REALTIME is not supported.  */\n+    return ERROR;\n+\n+  const long long abs_timeout_ticks = __TIMESPEC_TO_TICKS ((*abs_timeout));\n+  const long long current_ticks = __TIMESPEC_TO_TICKS (current);\n+\n+  long long waiting_ticks;\n+\n+  if (current_ticks < abs_timeout_ticks)\n+    waiting_ticks = abs_timeout_ticks - current_ticks;\n+  else\n+    /* The point until we would need to wait is in the past,\n+       no need to wait at all.  */\n+    waiting_ticks = 0;\n+\n+  /* We check that waiting_ticks can be safely casted as an int.  */\n+  if (waiting_ticks > INT_MAX)\n+    waiting_ticks = INT_MAX;\n+\n+  __RETURN_ERRNO_IF_NOT_OK (semGive (*mutex));\n+\n+  __RETURN_ERRNO_IF_NOT_OK (semTake (*cond, waiting_ticks));\n+\n+  __RETURN_ERRNO_IF_NOT_OK (semTake (*mutex, WAIT_FOREVER));\n+\n+  return OK;\n+}\n+\n+/* --------------------------- Timed Mutexes ------------------------------ */\n+\n+int\n+__gthread_mutex_timedlock (__gthread_mutex_t *m,\n+\t\t\t   const __gthread_time_t *abs_time)\n+{\n+  if (!m)\n+    return ERROR;\n+\n+  if (!abs_time)\n+    return ERROR;\n+\n+  struct timespec current;\n+  if (clock_gettime (CLOCK_REALTIME, &current) == ERROR)\n+    /* CLOCK_REALTIME is not supported.  */\n+    return ERROR;\n+\n+  const long long abs_timeout_ticks = __TIMESPEC_TO_TICKS ((*abs_time));\n+  const long long current_ticks = __TIMESPEC_TO_TICKS (current);\n+  long long waiting_ticks;\n+\n+  if (current_ticks < abs_timeout_ticks)\n+    waiting_ticks = abs_timeout_ticks - current_ticks;\n+  else\n+    /* The point until we would need to wait is in the past,\n+       no need to wait at all.  */\n+    waiting_ticks = 0;\n+\n+  /* Make sure that waiting_ticks can be safely casted as an int.  */\n+  if (waiting_ticks > INT_MAX)\n+    waiting_ticks = INT_MAX;\n+\n+  return __CHECK_RESULT (semTake (*m, waiting_ticks));\n+}\n+\n+int\n+__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *mutex,\n+\t\t\t\t     const __gthread_time_t *abs_timeout)\n+{\n+  return __gthread_mutex_timedlock ((__gthread_mutex_t *)mutex, abs_timeout);\n+}\n+\n+/* ------------------------------ Threads --------------------------------- */\n+\n+/* Task control block initialization and destruction functions.  */\n+\n+int\n+__init_gthread_tcb (__gthread_t __tcb)\n+{\n+  if (!__tcb)\n+    return ERROR;\n+\n+  __gthread_mutex_init (&(__tcb->return_value_available));\n+  if (__tcb->return_value_available == SEM_ID_NULL)\n+    return ERROR;\n+\n+  __gthread_mutex_init (&(__tcb->delete_ok));\n+  if (__tcb->delete_ok == SEM_ID_NULL)\n+    goto return_sem_delete;\n+\n+  /* We lock the two mutexes used for signaling.  */\n+  if (__gthread_mutex_lock (&(__tcb->delete_ok)) != OK)\n+    goto delete_sem_delete;\n+\n+  if (__gthread_mutex_lock (&(__tcb->return_value_available)) != OK)\n+    goto delete_sem_delete;\n+\n+  __tcb->task_id = TASK_ID_NULL;\n+  return OK;\n+\n+delete_sem_delete:\n+  semDelete (__tcb->delete_ok);\n+return_sem_delete:\n+  semDelete (__tcb->return_value_available);\n+  return ERROR;\n+}\n+\n+/* Here, we pass a pointer to a tcb to allow calls from\n+   cleanup attributes.  */\n+void\n+__delete_gthread_tcb (__gthread_t* __tcb)\n+{\n+  semDelete ((*__tcb)->return_value_available);\n+  semDelete ((*__tcb)->delete_ok);\n+  free (*__tcb);\n+}\n+\n+/* This __gthread_t stores the address of the TCB malloc'ed in\n+   __gthread_create.  It is then accessible via __gthread_self().  */\n+__thread __gthread_t __local_tcb = NULL;\n+\n+__gthread_t\n+__gthread_self (void)\n+{\n+  if (!__local_tcb)\n+    {\n+      /* We are in the initial thread, we need to initialize the TCB.  */\n+      __local_tcb = malloc (sizeof (*__local_tcb));\n+      if (!__local_tcb)\n+\treturn NULL;\n+\n+      if (__init_gthread_tcb (__local_tcb) != OK)\n+\t{\n+\t  __delete_gthread_tcb (&__local_tcb);\n+\t  return NULL;\n+\t}\n+      /* We do not set the mutexes in the structure as a thread is not supposed\n+         to join or detach himself.  */\n+      __local_tcb->task_id = taskIdSelf ();\n+    }\n+  return __local_tcb;\n+}\n+\n+int\n+__task_wrapper (__gthread_t tcb, FUNCPTR __func, _Vx_usr_arg_t __args)\n+{\n+  if (!tcb)\n+    return ERROR;\n+\n+  __local_tcb = tcb;\n+\n+  /* We use this variable to avoid memory leaks in the case where\n+     the underlying function throws an exception.  */\n+  __attribute__ ((cleanup (__delete_gthread_tcb))) __gthread_t __tmp = tcb;\n+\n+  void *return_value = (void *) __func (__args);\n+  tcb->return_value = return_value;\n+\n+  /* Call the destructors.  */\n+  __CALL_DELETE_HOOK (tcb);\n+\n+  /* Future calls of join() will be able to retrieve the return value.  */\n+  __gthread_mutex_unlock (&tcb->return_value_available);\n+\n+  /* We wait for the thread to be joined or detached.  */\n+  __gthread_mutex_lock (&(tcb->delete_ok));\n+  __gthread_mutex_unlock (&(tcb->delete_ok));\n+\n+  /* Memory deallocation is done by the cleanup attribute of the tmp variable.  */\n+\n+  return OK;\n+}\n+\n+/* Proper gthreads API.  */\n+\n+int\n+__gthread_create (__gthread_t * __threadid, void *(*__func) (void *),\n+\t\t  void *__args)\n+{\n+  if (!__threadid)\n+    return ERROR;\n+\n+  int priority;\n+  __RETURN_ERRNO_IF_NOT_OK (taskPriorityGet (taskIdSelf (), &priority));\n+\n+  int options;\n+  __RETURN_ERRNO_IF_NOT_OK (taskOptionsGet (taskIdSelf (), &options));\n+\n+#if defined (__SPE__)\n+  options |= VX_SPE_TASK;\n+#else\n+  options |= VX_FP_TASK;\n+#endif\n+  options &= VX_USR_TASK_OPTIONS;\n+\n+  int stacksize = 20 * 1024;\n+\n+  __gthread_t tcb = malloc (sizeof (*tcb));\n+  if (!tcb)\n+    return ERROR;\n+\n+  if (__init_gthread_tcb (tcb) != OK)\n+    {\n+      free (tcb);\n+      return ERROR;\n+    }\n+\n+  TASK_ID task_id = taskCreate (NULL,\n+\t\t\t\tpriority, options, stacksize,\n+\t\t\t\t(FUNCPTR) & __task_wrapper,\n+\t\t\t\t(_Vx_usr_arg_t) tcb,\n+\t\t\t\t(_Vx_usr_arg_t) __func,\n+\t\t\t\t(_Vx_usr_arg_t) __args,\n+\t\t\t\t0, 0, 0, 0, 0, 0, 0);\n+\n+  /* If taskCreate succeeds, task_id will be a valid TASK_ID and not zero.  */\n+  __RETURN_ERRNO_IF_NOT_OK (!task_id);\n+\n+  tcb->task_id = task_id;\n+  *__threadid = tcb;\n+\n+  return __CHECK_RESULT (taskActivate (task_id));\n+}\n+\n+int\n+__gthread_equal (__gthread_t __t1, __gthread_t __t2)\n+{\n+  return (__t1 == __t2) ? OK : ERROR;\n+}\n+\n+int\n+__gthread_yield (void)\n+{\n+  return taskDelay (0);\n+}\n+\n+int\n+__gthread_join (__gthread_t __threadid, void **__value_ptr)\n+{\n+  if (!__threadid)\n+    return ERROR;\n+\n+  /* A thread cannot join itself.  */\n+  if (__threadid->task_id == taskIdSelf ())\n+    return ERROR;\n+\n+  /* Waiting for the task to set the return value.  */\n+  __gthread_mutex_lock (&__threadid->return_value_available);\n+  __gthread_mutex_unlock (&__threadid->return_value_available);\n+\n+  if (__value_ptr)\n+    *__value_ptr = __threadid->return_value;\n+\n+  /* The task will be safely be deleted.  */\n+  __gthread_mutex_unlock (&(__threadid->delete_ok));\n+\n+  __RETURN_ERRNO_IF_NOT_OK (taskWait (__threadid->task_id, WAIT_FOREVER));\n+\n+  return OK;\n+}\n+\n+int\n+__gthread_detach (__gthread_t __threadid)\n+{\n+  if (!__threadid)\n+    return ERROR;\n+\n+  if (taskIdVerify (__threadid->task_id) != OK)\n+    return ERROR;\n+\n+  /* The task will be safely be deleted.  */\n+  __gthread_mutex_unlock (&(__threadid->delete_ok));\n+\n+  return OK;\n+}"}, {"sha": "cd5f7ac831c7c9425d93925c0cadd6f7c82b0ba2", "filename": "libgcc/config/gthr-vxworks-tls.c", "status": "renamed", "additions": 51, "deletions": 59, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806dd0472f56fd8fc410f106660b1ad2c7505bd7/libgcc%2Fconfig%2Fgthr-vxworks-tls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806dd0472f56fd8fc410f106660b1ad2c7505bd7/libgcc%2Fconfig%2Fgthr-vxworks-tls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fgthr-vxworks-tls.c?ref=806dd0472f56fd8fc410f106660b1ad2c7505bd7", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2002-2019 Free Software Foundation, Inc.\n+/* Copyright (C) 2002-2018 Free Software Foundation, Inc.\n    Contributed by Zack Weinberg <zack@codesourcery.com>\n \n This file is part of GCC.\n@@ -23,21 +23,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n /* Threads compatibility routines for libgcc2 for VxWorks.\n-   These are out-of-line routines called from gthr-vxworks.h. \n+   These are out-of-line routines called from gthr-vxworks.h.\n \n    This file provides the TLS related support routines, calling specific\n-   VxWorks kernel entry points for this purpose.  The base VxWorks 5.x kernels\n-   don't feature these entry points, and we provide gthr_supp_vxw_5x.c as an\n-   option to fill this gap.  Asking users to rebuild a kernel is not to be\n-   taken lightly, still, so we have isolated these routines from the rest of\n-   vxlib to ensure that the kernel dependencies are only dragged when really\n-   necessary.  */\n+   VxWorks kernel entry points for this purpose.  */\n \n #include \"tconfig.h\"\n #include \"tsystem.h\"\n #include \"gthr.h\"\n \n #if defined(__GTHREADS)\n+\n #include <vxWorks.h>\n #ifndef __RTP__\n #include <vxLib.h>\n@@ -46,31 +42,31 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #ifndef __RTP__\n #include <taskHookLib.h>\n #else\n-# include <errno.h>\n+#include <errno.h>\n #endif\n \n /* Thread-local storage.\n \n-   We reserve a field in the TCB to point to a dynamically allocated\n-   array which is used to store TLS values.  A TLS key is simply an\n-   offset in this array.  The exact location of the TCB field is not\n-   known to this code nor to vxlib.c -- all access to it indirects\n-   through the routines __gthread_get_tls_data and\n-   __gthread_set_tls_data, which are provided by the VxWorks kernel.\n+   A gthread TLS key is simply an offset in an array, the address of which\n+   we store in a single pointer field associated with the current task.\n+\n+   On VxWorks 7, we have direct support for __thread variables and use\n+   such a variable as the pointer \"field\".  On other versions, we resort\n+   to __gthread_get_tls_data and __gthread_set_tls_data functions provided\n+   by the kernel.\n \n    There is also a global array which records which keys are valid and\n    which have destructors.\n \n-   A task delete hook is installed to execute key destructors.  The\n-   routines __gthread_enter_tls_dtor_context and\n-   __gthread_leave_tls_dtor_context, which are also provided by the\n-   kernel, ensure that it is safe to call free() on memory allocated\n-   by the task being deleted.  (This is a no-op on VxWorks 5, but\n-   a major undertaking on AE.)\n+   A task delete hook is installed to execute key destructors.  The routines\n+   __gthread_enter_tls_dtor_context and __gthread_leave_tls_dtor_context,\n+   which are also provided by the kernel, ensure that it is safe to call\n+   free() on memory allocated by the task being deleted.  This is a no-op on\n+   VxWorks 5, but a major undertaking on AE.\n \n    The task delete hook is only installed when at least one thread\n    has TLS data.  This is a necessary precaution, to allow this module\n-   to be unloaded - a module with a hook cannot be removed.\n+   to be unloaded - a module with a hook can not be removed.\n \n    Since this interface is used to allocate only a small number of\n    keys, the table size is small and static, which simplifies the\n@@ -95,21 +91,34 @@ static int self_owner;\n    it is only removed when unloading this module.  */\n static volatile int delete_hook_installed;\n \n-/* kernel provided routines */\n+/* TLS data access internal API.  A straight __thread variable on VxWorks 7,\n+   a pointer returned by kernel provided routines otherwise.  */\n+\n+#ifdef __VXWORKS7__\n+\n+static __thread struct tls_data *__gthread_tls_data;\n+\n+#define VX_GET_TLS_DATA() __gthread_tls_data\n+#define VX_SET_TLS_DATA(x) __gthread_tls_data = (x)\n+\n+#define VX_ENTER_TLS_DTOR()\n+#define VX_LEAVE_TLS_DTOR()\n+\n+#else\n+\n extern void *__gthread_get_tls_data (void);\n extern void __gthread_set_tls_data (void *data);\n \n extern void __gthread_enter_tls_dtor_context (void);\n extern void __gthread_leave_tls_dtor_context (void);\n \n-#ifndef __RTP__\n+#define VX_GET_TLS_DATA() __gthread_get_tls_data()\n+#define VX_SET_TLS_DATA(x) __gthread_set_tls_data(x)\n \n-extern void *__gthread_get_tsd_data (WIND_TCB *tcb);\n-extern void __gthread_set_tsd_data (WIND_TCB *tcb, void *data);\n-extern void __gthread_enter_tsd_dtor_context (WIND_TCB *tcb);\n-extern void __gthread_leave_tsd_dtor_context (WIND_TCB *tcb);\n+#define VX_ENTER_TLS_DTOR() __gthread_enter_tls_dtor_context ()\n+#define VX_LEAVE_TLS_DTOR() __gthread_leave_tls_dtor_context ()\n \n-#endif /* __RTP__ */\n+#endif /* __VXWORKS7__ */\n \n /* This is a global structure which records all of the active keys.\n \n@@ -138,7 +147,7 @@ struct tls_keys\n    key is valid.  */\n static struct tls_keys tls_keys =\n {\n-  { 0, 0, 0, 0 },\n+  { NULL, NULL, NULL, NULL },\n   { 1, 1, 1, 1 }\n };\n \n@@ -157,28 +166,17 @@ static __gthread_once_t tls_init_guard = __GTHREAD_ONCE_INIT;\n    count protects us from calling a stale destructor.  It does\n    need to read tls_keys.dtor[key] atomically.  */\n \n-static void\n+void\n tls_delete_hook (void *tcb ATTRIBUTE_UNUSED)\n {\n   struct tls_data *data;\n   __gthread_key_t key;\n \n-#ifdef __RTP__\n-  data = __gthread_get_tls_data ();\n-#else\n-  /* In kernel mode, we can be called in the context of the thread\n-     doing the killing, so must use the TCB to determine the data of\n-     the thread being killed.  */\n-  data = __gthread_get_tsd_data (tcb);\n-#endif\n-  \n+  data = VX_GET_TLS_DATA();\n+\n   if (data && data->owner == &self_owner)\n     {\n-#ifdef __RTP__\n-      __gthread_enter_tls_dtor_context ();\n-#else\n-      __gthread_enter_tsd_dtor_context (tcb);\n-#endif\n+      VX_ENTER_TLS_DTOR();\n       for (key = 0; key < MAX_KEYS; key++)\n \t{\n \t  if (data->generation[key] == tls_keys.generation[key])\n@@ -190,19 +188,11 @@ tls_delete_hook (void *tcb ATTRIBUTE_UNUSED)\n \t    }\n \t}\n       free (data);\n-#ifdef __RTP__\n-      __gthread_leave_tls_dtor_context ();\n-#else\n-      __gthread_leave_tsd_dtor_context (tcb);\n-#endif\n \n-#ifdef __RTP__\n-      __gthread_set_tls_data (0);\n-#else\n-      __gthread_set_tsd_data (tcb, 0);\n-#endif\n+      VX_LEAVE_TLS_DTOR();\n+      VX_SET_TLS_DATA(NULL);\n     }\n-} \n+}\n \n /* Initialize global data used by the TLS system.  */\n static void\n@@ -303,7 +293,7 @@ __gthread_getspecific (__gthread_key_t key)\n   if (key >= MAX_KEYS)\n     return 0;\n \n-  data = __gthread_get_tls_data ();\n+  data = GET_VX_TLS_DATA();\n \n   if (!data)\n     return 0;\n@@ -332,7 +322,8 @@ __gthread_setspecific (__gthread_key_t key, void *value)\n   if (key >= MAX_KEYS)\n     return EINVAL;\n \n-  data = __gthread_get_tls_data ();\n+  data = VX_GET_TLS_DATA();\n+\n   if (!data)\n     {\n       if (!delete_hook_installed)\n@@ -354,7 +345,8 @@ __gthread_setspecific (__gthread_key_t key, void *value)\n \n       memset (data, 0, sizeof (struct tls_data));\n       data->owner = &self_owner;\n-      __gthread_set_tls_data (data);\n+\n+      VX_SET_TLS_DATA(data);\n     }\n \n   generation = tls_keys.generation[key];", "previous_filename": "libgcc/config/vxlib-tls.c"}, {"sha": "ddc35933d1a46e2368dda58c74a92f4a44ce941f", "filename": "libgcc/config/gthr-vxworks.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806dd0472f56fd8fc410f106660b1ad2c7505bd7/libgcc%2Fconfig%2Fgthr-vxworks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806dd0472f56fd8fc410f106660b1ad2c7505bd7/libgcc%2Fconfig%2Fgthr-vxworks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fgthr-vxworks.c?ref=806dd0472f56fd8fc410f106660b1ad2c7505bd7", "patch": "@@ -0,0 +1,87 @@\n+/* Copyright (C) 2002-2019 Free Software Foundation, Inc.\n+   Contributed by Zack Weinberg <zack@codesourcery.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Threads compatibility routines for libgcc2 for VxWorks.\n+\n+   This file implements the init-once service exposed by gthr-vxworks.h.  */\n+\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"gthr.h\"\n+\n+#if defined(__GTHREADS)\n+\n+#include <vxWorks.h>\n+\n+#ifndef __RTP__\n+# include <vxLib.h>\n+# include <taskHookLib.h>\n+#else /* __RTP__ */\n+# include <errno.h>\n+#endif /* __RTP__ */\n+\n+/* ----------------------------- Init-once ------------------------------- */\n+\n+static void\n+__release (__gthread_once_t ** __guard)\n+{\n+  (*__guard)->busy = 0;\n+}\n+\n+int\n+__gthread_once (__gthread_once_t * __guard, void (*__func) (void))\n+{\n+  if (__guard->done)\n+    return 0;\n+\n+  /* Busy-wait until we have exclusive access to the state.  Check if\n+     another thread managed to perform the init call in the interim.  */\n+  \n+  while (!__TAS(&__guard->busy))\n+    {\n+      if (__guard->done)\n+\treturn 0;\n+      taskDelay (1);\n+    }\n+\n+  if (!__guard->done)\n+    {\n+#ifndef __USING_SJLJ_EXCEPTIONS__\n+      /* Setup a cleanup to release the guard when __func() throws an\n+\t exception.  We cannot use this with SJLJ exceptions as\n+\t Unwind_Register calls __gthread_once, leading to an infinite\n+\t recursion.  */\n+      __attribute__ ((cleanup (__release)))\n+\t__gthread_once_t *__temp = __guard;\n+#endif\n+\n+      __func ();\n+      __guard->done = 1;\n+    }\n+\n+  __release(&__guard);\n+  return 0;\n+}\n+\n+#endif /* __GTHREADS */"}, {"sha": "7e3779a010a69cd177ecf66494b7c314c80fa33d", "filename": "libgcc/config/gthr-vxworks.h", "status": "modified", "additions": 214, "deletions": 58, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806dd0472f56fd8fc410f106660b1ad2c7505bd7/libgcc%2Fconfig%2Fgthr-vxworks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806dd0472f56fd8fc410f106660b1ad2c7505bd7/libgcc%2Fconfig%2Fgthr-vxworks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fgthr-vxworks.h?ref=806dd0472f56fd8fc410f106660b1ad2c7505bd7", "patch": "@@ -1,6 +1,6 @@\n /* Threads compatibility routines for libgcc2 and libobjc for VxWorks.  */\n /* Compile this one with gcc.  */\n-/* Copyright (C) 1997-2019 Free Software Foundation, Inc.\n+/* Copyright (C) 1997-2018 Free Software Foundation, Inc.\n    Contributed by Mike Stump <mrs@wrs.com>.\n \n This file is part of GCC.\n@@ -33,139 +33,295 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"gthr-posix.h\"\n \n #else\n-#ifdef __cplusplus\n-#define UNUSED(x)\n-#else\n-#define UNUSED(x) x __attribute__((__unused__))\n+\n+#include <vxWorks.h>\n+#include <version.h>\n+\n+/* Conditional compilation directives are easier to read when they fit on a\n+   single line, which is helped by macros with shorter names.  */\n+#define _VXW_MAJOR _WRS_VXWORKS_MAJOR\n+#define _VXW_MINOR _WRS_VXWORKS_MINOR\n+#define _VXW_PRE_69 (_VXW_MAJOR  < 6 || (_VXW_MAJOR == 6 && _VXW_MINOR < 9))\n+\n+/* Some VxWorks headers profusely use typedefs of a pointer to a function with\n+   undefined number of arguments.  */\n+#pragma GCC diagnostic push\n+  #pragma GCC diagnostic ignored \"-Wstrict-prototypes\"\n+  #include <semLib.h>\n+#pragma GCC diagnostic pop\n+\n+#include <errnoLib.h>\n+\n+\n+/* --------------------- Test & Set/Swap internal API --------------------- */\n+\n+/* We use a bare atomic primitive with busy loops to handle mutual exclusion.\n+   Inefficient, but reliable.  The actual primitive used depends on the mode\n+   (RTP vs Kernel) and the version of VxWorks.  We define a macro and a type\n+   here, for reuse without conditionals cluttering in the code afterwards.  */\n+\n+/* RTP, pre 6.9.  */\n+\n+#if defined(__RTP__) && _VXW_PRE_69\n+\n+#define __TAS(x) vxCas ((x), 0, 1)\n+typedef volatile unsigned char __vx_tas_t;\n+\n+#endif\n+\n+/* RTP, 6.9 and beyond.  */\n+\n+#if defined(__RTP__) && !_VXW_PRE_69\n+\n+#define __TAS(x) vxAtomicCas ((x), 0, 1)\n+typedef atomic_t __vx_tas_t;\n+\n+#include <vxAtomicLib.h>\n+\n+#endif\n+\n+/* Kernel */\n+\n+#if !defined(__RTP__)\n+\n+#define __TAS(x) vxTas (x)\n+typedef volatile unsigned char __vx_tas_t;\n+\n #endif\n \n #ifdef __cplusplus\n extern \"C\" {\n #endif\n \n+/* ------------------------ Base __GTHREADS support ----------------------- */\n+\n #define __GTHREADS 1\n #define __gthread_active_p() 1\n \n /* Mutexes are easy, except that they need to be initialized at runtime.  */\n \n-#include <semLib.h>\n-\n-typedef SEM_ID __gthread_mutex_t;\n /* All VxWorks mutexes are recursive.  */\n+typedef SEM_ID __gthread_mutex_t;\n typedef SEM_ID __gthread_recursive_mutex_t;\n-#define __GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function\n-#define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function\n+#define __GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init\n+#define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init\n+\n+#define __CHECK_RESULT(result) (((result) == OK) ? OK : errnoGet())\n+\n+/* If a call to the VxWorks API fails, we must propagate the errno value.  */\n+#define __RETURN_ERRNO_IF_NOT_OK(exp) if ((exp) != OK) return errnoGet()\n+\n+/* Non re-entrant mutex implementation. Libstdc++ expects the default\n+   gthread mutex to be non reentrant.  */\n \n static inline void\n-__gthread_mutex_init_function (__gthread_mutex_t *mutex)\n+__gthread_mutex_init (__gthread_mutex_t * __mutex)\n {\n-  *mutex = semMCreate (SEM_Q_PRIORITY | SEM_INVERSION_SAFE | SEM_DELETE_SAFE);\n+  if (!__mutex)\n+    return;\n+  *__mutex = semBCreate (SEM_Q_PRIORITY, SEM_FULL);\n }\n \n static inline int\n-__gthread_mutex_destroy (__gthread_mutex_t *mutex)\n+__gthread_mutex_destroy (__gthread_mutex_t * __mutex)\n {\n-  semDelete(*mutex);\n-  return 0;\n+  if (!__mutex)\n+    return ERROR;\n+  return __CHECK_RESULT (semDelete (*__mutex));\n }\n \n static inline int\n-__gthread_mutex_lock (__gthread_mutex_t *mutex)\n+__gthread_mutex_lock (__gthread_mutex_t * __mutex)\n {\n-  return semTake (*mutex, WAIT_FOREVER);\n+  if (!__mutex)\n+    return ERROR;\n+  return __CHECK_RESULT (semTake(*__mutex, WAIT_FOREVER));\n }\n \n static inline int\n-__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n+__gthread_mutex_trylock (__gthread_mutex_t * __mutex)\n {\n-  return semTake (*mutex, NO_WAIT);\n+  if (!__mutex)\n+    return ERROR;\n+  return __CHECK_RESULT (semTake (*__mutex, NO_WAIT));\n }\n \n static inline int\n-__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n+__gthread_mutex_unlock (__gthread_mutex_t * __mutex)\n {\n-  return semGive (*mutex);\n+  if (!__mutex)\n+    return ERROR;\n+  return __CHECK_RESULT (semGive (*__mutex));\n }\n \n+/* Recursive mutex implementation. The only change is that we use semMCreate()\n+   instead of semBCreate().  */\n+\n static inline void\n-__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_init (__gthread_recursive_mutex_t * __mutex)\n {\n-  __gthread_mutex_init_function (mutex);\n+  if (!__mutex)\n+    return;\n+  *__mutex =\n+    semMCreate (SEM_Q_PRIORITY | SEM_INVERSION_SAFE | SEM_DELETE_SAFE);\n }\n \n static inline int\n-__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t * __mutex)\n {\n-  return __gthread_mutex_lock (mutex);\n+  return __gthread_mutex_destroy (__mutex);\n }\n \n static inline int\n-__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t * __mutex)\n {\n-  return __gthread_mutex_trylock (mutex);\n+  return __gthread_mutex_lock (__mutex);\n }\n \n static inline int\n-__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t * __mutex)\n {\n-  return __gthread_mutex_unlock (mutex);\n+  return __gthread_mutex_trylock (__mutex);\n }\n \n static inline int\n-__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)\n+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t * __mutex)\n {\n-  return __gthread_mutex_destroy (__mutex);\n+  return __gthread_mutex_unlock (__mutex);\n }\n \n-/* pthread_once is complicated enough that it's implemented\n-   out-of-line.  See config/vxlib.c.  */\n-\n typedef struct\n {\n-#if !defined(__RTP__)\n+  /* PPC's test-and-set kernel mode implementation requires a pointer aligned\n+     object, of which it only sets the first byte.  We use padding in addition\n+     to an alignment request here to maxmise the factors leading to the\n+     desired actual alignment choice by the compiler.  */\n #if defined(__PPC__)\n-  __attribute ((aligned (__alignof (unsigned))))\n-#endif\n-  volatile unsigned char busy;\n+  __attribute ((aligned (__alignof__ (void *))))\n #endif\n+\n+  __vx_tas_t busy;\n   volatile unsigned char done;\n+\n #if !defined(__RTP__) && defined(__PPC__)\n-  /* PPC's test-and-set implementation requires a 4 byte aligned\n-     object, of which it only sets the first byte.  We use padding\n-     here, in order to maintain some amount of backwards\n-     compatibility.  Without this padding, gthread_once objects worked\n-     by accident because they happen to be static objects and the ppc\n-     port automatically increased their alignment to 4 bytes.  */\n   unsigned char pad1;\n   unsigned char pad2;\n #endif\n-}\n-__gthread_once_t;\n-\n-#if defined (__RTP__)\n-# define __GTHREAD_ONCE_INIT { 0 }\n-#elif defined (__PPC__)\n-# define __GTHREAD_ONCE_INIT { 0, 0, 0, 0 }\n-#else\n-# define __GTHREAD_ONCE_INIT { 0, 0 }\n+#if !defined(__RTP__) && defined(__PPC64__)\n+  unsigned char pad3;\n+  unsigned char pad4;\n+  unsigned char pad5;\n+  unsigned char pad6;\n #endif\n+} __gthread_once_t;\n+\n+#define __GTHREAD_ONCE_INIT { 0 }\n \n extern int __gthread_once (__gthread_once_t *__once, void (*__func)(void));\n \n-/* Thread-specific data requires a great deal of effort, since VxWorks\n-   is not really set up for it.  See config/vxlib.c for the gory\n-   details.  All the TSD routines are sufficiently complex that they\n+/* All the TSD routines are sufficiently complex that they\n    need to be implemented out of line.  */\n \n typedef unsigned int __gthread_key_t;\n \n-extern int __gthread_key_create (__gthread_key_t *__keyp, void (*__dtor)(void *));\n+extern int __gthread_key_create (__gthread_key_t *__keyp,\n+\t\t\t\t void (*__dtor)(void *));\n extern int __gthread_key_delete (__gthread_key_t __key);\n \n extern void *__gthread_getspecific (__gthread_key_t __key);\n extern int __gthread_setspecific (__gthread_key_t __key, void *__ptr);\n \n-#undef UNUSED\n+/* ------------------ Base condition variables support ------------------- */\n+\n+#define __GTHREAD_HAS_COND 1\n+\n+typedef SEM_ID __gthread_cond_t;\n+\n+#define __GTHREAD_COND_INIT_FUNCTION __gthread_cond_init\n+\n+/* Condition variable declarations.  */\n+\n+extern void __gthread_cond_init (__gthread_cond_t *cond);\n+\n+extern int __gthread_cond_destroy (__gthread_cond_t *cond);\n+\n+extern int __gthread_cond_broadcast (__gthread_cond_t *cond);\n+\n+extern int __gthread_cond_wait (__gthread_cond_t *cond,\n+\t\t\t\t__gthread_mutex_t *mutex);\n+\n+extern int __gthread_cond_wait_recursive (__gthread_cond_t *cond,\n+\t\t\t\t\t  __gthread_recursive_mutex_t *mutex);\n+\n+/* -----------------------  C++0x thread support ------------------------- */\n+\n+/* We do not support C++0x threads on that VxWorks 653, which we can\n+   recognize by VTHREADS being defined.  */\n+\n+#ifndef VTHREADS\n+\n+#define __GTHREADS_CXX0X 1\n+\n+#include <limits.h>\n+#include <time.h>\n+#include <tickLib.h>\n+#include <sysLib.h>\n+#include <version.h>\n+\n+typedef struct\n+{\n+  TASK_ID task_id;\n+  void *return_value;\n+\n+  /* This mutex is used to block in join() while the return value is\n+     unavailable.  */\n+  __gthread_mutex_t return_value_available;\n+\n+  /* Before freeing the structure in the task wrapper, we need to wait until\n+     join() or detach() are called on that thread.   */\n+  __gthread_mutex_t delete_ok;\n+} __gthread_tcb;\n+\n+typedef __gthread_tcb *__gthread_t;\n+\n+/* Typedefs specific to different vxworks versions.  */\n+#if _VXW_PRE_69\n+  typedef int _Vx_usr_arg_t;\n+  #define TASK_ID_NULL ((TASK_ID)NULL)\n+  #define SEM_ID_NULL ((SEM_ID)NULL)\n+#endif\n+\n+typedef struct timespec __gthread_time_t;\n+\n+/* Timed mutex lock declarations.  */\n+\n+extern int __gthread_mutex_timedlock (__gthread_mutex_t *m,\n+\t\t\t\t      const __gthread_time_t *abs_time);\n+\n+extern int __gthread_recursive_mutex_timedlock\n+  (__gthread_recursive_mutex_t *mutex,\n+   const __gthread_time_t *abs_timeout);\n+\n+/* Timed condition variable declarations.  */\n+\n+extern int __gthread_cond_signal (__gthread_cond_t *cond);\n+extern int __gthread_cond_timedwait (__gthread_cond_t *cond,\n+\t\t\t\t     __gthread_mutex_t *mutex,\n+\t\t\t\t     const __gthread_time_t *abs_timeout);\n+\n+/* gthreads declarations.  */\n+\n+extern int __gthread_equal (__gthread_t t1, __gthread_t t2);\n+extern int __gthread_yield (void);\n+extern int __gthread_create (__gthread_t *__threadid,\n+\t\t\t     void *(*__func) (void*),\n+\t\t\t     void *__args);\n+extern int __gthread_join (__gthread_t thread, void **value_ptr);\n+extern int __gthread_detach (__gthread_t thread);\n+\n+extern __gthread_t __gthread_self (void);\n+\n+#endif\n \n #ifdef __cplusplus\n }"}, {"sha": "455d0b320d7099736ec536c722f93b2adcea7144", "filename": "libgcc/config/t-gthr-vxworks", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806dd0472f56fd8fc410f106660b1ad2c7505bd7/libgcc%2Fconfig%2Ft-gthr-vxworks", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806dd0472f56fd8fc410f106660b1ad2c7505bd7/libgcc%2Fconfig%2Ft-gthr-vxworks", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ft-gthr-vxworks?ref=806dd0472f56fd8fc410f106660b1ad2c7505bd7", "patch": "@@ -0,0 +1,5 @@\n+# Extra libgcc2 modules used by gthr-vxworks.h functions\n+LIB2ADDEH += $(srcdir)/config/gthr-vxworks.c\\\n+\t     $(srcdir)/config/gthr-vxworks-cond.c\\\n+\t     $(srcdir)/config/gthr-vxworks-thread.c\\\n+\t     $(srcdir)/config/gthr-vxworks-tls.c\n\\ No newline at end of file"}, {"sha": "757cead6724a2f495f6174976e233b736da4783b", "filename": "libgcc/config/t-vxworks", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806dd0472f56fd8fc410f106660b1ad2c7505bd7/libgcc%2Fconfig%2Ft-vxworks", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806dd0472f56fd8fc410f106660b1ad2c7505bd7/libgcc%2Fconfig%2Ft-vxworks", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ft-vxworks?ref=806dd0472f56fd8fc410f106660b1ad2c7505bd7", "patch": "@@ -6,9 +6,6 @@ LIBGCC2_DEBUG_CFLAGS =\n LIB2FUNCS_EXCLUDE += _clear_cache\n LIB2ADD += $(srcdir)/config/vxcache.c\n \n-# Extra libgcc2 modules used by gthr-vxworks.h functions\n-LIB2ADDEH += $(srcdir)/config/vxlib.c $(srcdir)/config/vxlib-tls.c\n-\n # This ensures that the correct target headers are used; some VxWorks\n # system headers have names that collide with GCC's internal (host)\n # headers, e.g. regs.h. Make sure the local libgcc headers still"}, {"sha": "f2cc904ac08beb880db4d06bda1aefde763f89c2", "filename": "libgcc/config/t-vxworks7", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806dd0472f56fd8fc410f106660b1ad2c7505bd7/libgcc%2Fconfig%2Ft-vxworks7", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806dd0472f56fd8fc410f106660b1ad2c7505bd7/libgcc%2Fconfig%2Ft-vxworks7", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ft-vxworks7?ref=806dd0472f56fd8fc410f106660b1ad2c7505bd7", "patch": "@@ -6,9 +6,6 @@ LIBGCC2_DEBUG_CFLAGS =\n LIB2FUNCS_EXCLUDE += _clear_cache\n LIB2ADD += $(srcdir)/config/vxcache.c\n \n-# Extra libgcc2 modules used by gthr-vxworks.h functions\n-LIB2ADDEH += $(srcdir)/config/vxlib.c $(srcdir)/config/vxlib-tls.c\n-\n # This ensures that the correct target headers are used; some VxWorks\n # system headers have names that collide with GCC's internal (host)\n # headers, e.g. regs.h. Make sure the local libgcc headers still\n@@ -21,4 +18,3 @@ LIBGCC2_INCLUDES = -nostdinc -I. \\\n       */mrtp*) echo -I$(VSB_DIR)/usr/h/public -I$(VSB_DIR)/usr/h ;; \\\n       *) echo -I$(VSB_DIR)/krnl/h/system -I$(VSB_DIR)/krnl/h/public ;; \\\n    esac`\n-"}, {"sha": "78b677647a3e42ca01258f8ab079a65cb5c68831", "filename": "libgcc/config/vxlib.c", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78e49fb1bc69592389a09ce5544b40fef634e893/libgcc%2Fconfig%2Fvxlib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78e49fb1bc69592389a09ce5544b40fef634e893/libgcc%2Fconfig%2Fvxlib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fvxlib.c?ref=78e49fb1bc69592389a09ce5544b40fef634e893", "patch": "@@ -1,95 +0,0 @@\n-/* Copyright (C) 2002-2019 Free Software Foundation, Inc.\n-   Contributed by Zack Weinberg <zack@codesourcery.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* Threads compatibility routines for libgcc2 for VxWorks.\n-   These are out-of-line routines called from gthr-vxworks.h.  */\n-\n-#include \"tconfig.h\"\n-#include \"tsystem.h\"\n-#include \"gthr.h\"\n-\n-#if defined(__GTHREADS)\n-#include <vxWorks.h>\n-#ifndef __RTP__\n-#include <vxLib.h>\n-#endif\n-#include <taskLib.h>\n-#ifndef __RTP__\n-#include <taskHookLib.h>\n-#else\n-# include <errno.h>\n-#endif\n-\n-/* Init-once operation.\n-\n-   This would be a clone of the implementation from gthr-solaris.h,\n-   except that we have a bootstrap problem - the whole point of this\n-   exercise is to prevent double initialization, but if two threads\n-   are racing with each other, once->mutex is liable to be initialized\n-   by both.  Then each thread will lock its own mutex, and proceed to\n-   call the initialization routine.\n-\n-   So instead we use a bare atomic primitive (vxTas()) to handle\n-   mutual exclusion.  Threads losing the race then busy-wait, calling\n-   taskDelay() to yield the processor, until the initialization is\n-   completed.  Inefficient, but reliable.  */\n-\n-int\n-__gthread_once (__gthread_once_t *guard, void (*func)(void))\n-{\n-  if (guard->done)\n-    return 0;\n-\n-#ifdef __RTP__\n-  __gthread_lock_library ();\n-#else\n-  while (!vxTas ((void *)&guard->busy))\n-    {\n-#ifdef __PPC__\n-      /* This can happen on powerpc, which is using all 32 bits\n-\t of the gthread_once_t structure.  */\n-      if (guard->done)\n-\treturn 0;\n-#endif\n-      taskDelay (1);\n-    }\n-#endif\n-\n-  /* Only one thread at a time gets here.  Check ->done again, then\n-     go ahead and call func() if no one has done it yet.  */\n-  if (!guard->done)\n-    {\n-      func ();\n-      guard->done = 1;\n-    }\n-\n-#ifdef __RTP__\n-  __gthread_unlock_library ();\n-#else\n-  guard->busy = 0;\n-#endif\n-  return 0;\n-}\n-\n-#endif /* __GTHREADS */"}]}