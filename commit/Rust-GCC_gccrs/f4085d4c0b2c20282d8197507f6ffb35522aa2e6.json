{"sha": "f4085d4c0b2c20282d8197507f6ffb35522aa2e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQwODVkNGMwYjJjMjAyODJkODE5NzUwN2Y2ZmZiMzU1MjJhYTJlNg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-05-20T22:08:46Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-05-20T22:08:46Z"}, "message": "re PR middle-end/3074 (Statement with no effect not flagged with -Wall)\n\n\n\tPR middle-end/3074\n\t* fold-const.c (strip_compound_expr): Delete function.\n\t(count_cond): Delete function.\n\t(fold_binary_op_with_conditional_arg): Only perform transformations\n\t\"a + (b?c:d) -> b ? a+c : a+d\" and \"(b?c:d) + a -> b ? c+a : d+a\"\n\twhen a is constant.  This greatly simplifies this routine.\n\n\t* tree.c (saved_expr_p): Delete function.\n\t* tree.h (saved_expr_p): Delete function prototype.\n\n\t* gcc.dg/pr3074-1.c: New test case.\n\t* gcc.dg/sequence-pt-1.c: Remove an XFAIL.\n\nFrom-SVN: r82071", "tree": {"sha": "9c22a0479f3c3304c61163c2b0ebb309c08513d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c22a0479f3c3304c61163c2b0ebb309c08513d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4085d4c0b2c20282d8197507f6ffb35522aa2e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4085d4c0b2c20282d8197507f6ffb35522aa2e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4085d4c0b2c20282d8197507f6ffb35522aa2e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4085d4c0b2c20282d8197507f6ffb35522aa2e6/comments", "author": null, "committer": null, "parents": [{"sha": "3adf6cadbbfe23b96f8e53780ae5f1bc28f01077", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3adf6cadbbfe23b96f8e53780ae5f1bc28f01077", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3adf6cadbbfe23b96f8e53780ae5f1bc28f01077"}], "stats": {"total": 229, "additions": 43, "deletions": 186}, "files": [{"sha": "bc2efca0ab5a0694a7a3b7e2a274214a7b8d15a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4085d4c0b2c20282d8197507f6ffb35522aa2e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4085d4c0b2c20282d8197507f6ffb35522aa2e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f4085d4c0b2c20282d8197507f6ffb35522aa2e6", "patch": "@@ -1,3 +1,15 @@\n+2004-05-20  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR middle-end/3074\n+\t* fold-const.c (strip_compound_expr): Delete function.\n+\t(count_cond): Delete function.\n+\t(fold_binary_op_with_conditional_arg): Only perform transformations\n+\t\"a + (b?c:d) -> b ? a+c : a+d\" and \"(b?c:d) + a -> b ? c+a : d+a\"\n+\twhen a is constant.  This greatly simplifies this routine.\n+\n+\t* tree.c (saved_expr_p): Delete function.\n+\t* tree.h (saved_expr_p): Delete function prototype.\n+\n 2004-05-20  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* common.opt (ftree-loop-optimize): Remove."}, {"sha": "03f0cdcaaf4df0f1da76963917fce5234762c3f2", "filename": "gcc/fold-const.c", "status": "modified", "additions": 14, "deletions": 171, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4085d4c0b2c20282d8197507f6ffb35522aa2e6/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4085d4c0b2c20282d8197507f6ffb35522aa2e6/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=f4085d4c0b2c20282d8197507f6ffb35522aa2e6", "patch": "@@ -98,10 +98,8 @@ static tree fold_truthop (enum tree_code, tree, tree, tree);\n static tree optimize_minmax_comparison (tree);\n static tree extract_muldiv (tree, tree, enum tree_code, tree);\n static tree extract_muldiv_1 (tree, tree, enum tree_code, tree);\n-static tree strip_compound_expr (tree, tree);\n static int multiple_of_p (tree, tree, tree);\n static tree constant_boolean_node (int, tree);\n-static int count_cond (tree, int);\n static tree fold_binary_op_with_conditional_arg (enum tree_code, tree, tree,\n \t\t\t\t\t\t tree, int);\n static bool fold_real_zero_addition_p (tree, tree, int);\n@@ -4738,40 +4736,6 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n   return 0;\n }\n \f\n-/* If T contains a COMPOUND_EXPR which was inserted merely to evaluate\n-   S, a SAVE_EXPR, return the expression actually being evaluated.   Note\n-   that we may sometimes modify the tree.  */\n-\n-static tree\n-strip_compound_expr (tree t, tree s)\n-{\n-  enum tree_code code = TREE_CODE (t);\n-\n-  /* See if this is the COMPOUND_EXPR we want to eliminate.  */\n-  if (code == COMPOUND_EXPR && TREE_CODE (TREE_OPERAND (t, 0)) == CONVERT_EXPR\n-      && TREE_OPERAND (TREE_OPERAND (t, 0), 0) == s)\n-    return TREE_OPERAND (t, 1);\n-\n-  /* See if this is a COND_EXPR or a simple arithmetic operator.   We\n-     don't bother handling any other types.  */\n-  else if (code == COND_EXPR)\n-    {\n-      TREE_OPERAND (t, 0) = strip_compound_expr (TREE_OPERAND (t, 0), s);\n-      TREE_OPERAND (t, 1) = strip_compound_expr (TREE_OPERAND (t, 1), s);\n-      TREE_OPERAND (t, 2) = strip_compound_expr (TREE_OPERAND (t, 2), s);\n-    }\n-  else if (TREE_CODE_CLASS (code) == '1')\n-    TREE_OPERAND (t, 0) = strip_compound_expr (TREE_OPERAND (t, 0), s);\n-  else if (TREE_CODE_CLASS (code) == '<'\n-\t   || TREE_CODE_CLASS (code) == '2')\n-    {\n-      TREE_OPERAND (t, 0) = strip_compound_expr (TREE_OPERAND (t, 0), s);\n-      TREE_OPERAND (t, 1) = strip_compound_expr (TREE_OPERAND (t, 1), s);\n-    }\n-\n-  return t;\n-}\n-\f\n /* Return a node which has the indicated constant VALUE (either 0 or\n    1), and is of the indicated TYPE.  */\n \n@@ -4792,25 +4756,6 @@ constant_boolean_node (int value, tree type)\n     }\n }\n \n-/* Utility function for the following routine, to see how complex a nesting of\n-   COND_EXPRs can be.  EXPR is the expression and LIMIT is a count beyond which\n-   we don't care (to avoid spending too much time on complex expressions.).  */\n-\n-static int\n-count_cond (tree expr, int lim)\n-{\n-  int ctrue, cfalse;\n-\n-  if (TREE_CODE (expr) != COND_EXPR)\n-    return 0;\n-  else if (lim <= 0)\n-    return 0;\n-\n-  ctrue = count_cond (TREE_OPERAND (expr, 1), lim - 1);\n-  cfalse = count_cond (TREE_OPERAND (expr, 2), lim - 1 - ctrue);\n-  return MIN (lim, 1 + ctrue + cfalse);\n-}\n-\n /* Transform `a + (b ? x : y)' into `b ? (a + x) : (a + y)'.\n    Transform, `a + (x < y)' into `(x < y) ? (a + 1) : (a + 0)'.  Here\n    CODE corresponds to the `+', COND to the `(b ? x : y)' or `(x < y)'\n@@ -4827,82 +4772,25 @@ fold_binary_op_with_conditional_arg (enum tree_code code, tree type,\n   tree test, true_value, false_value;\n   tree lhs = NULL_TREE;\n   tree rhs = NULL_TREE;\n-  /* In the end, we'll produce a COND_EXPR.  Both arms of the\n-     conditional expression will be binary operations.  The left-hand\n-     side of the expression to be executed if the condition is true\n-     will be pointed to by TRUE_LHS.  Similarly, the right-hand side\n-     of the expression to be executed if the condition is true will be\n-     pointed to by TRUE_RHS.  FALSE_LHS and FALSE_RHS are analogous --\n-     but apply to the expression to be executed if the conditional is\n-     false.  */\n-  tree *true_lhs;\n-  tree *true_rhs;\n-  tree *false_lhs;\n-  tree *false_rhs;\n-  /* These are the codes to use for the left-hand side and right-hand\n-     side of the COND_EXPR.  Normally, they are the same as CODE.  */\n-  enum tree_code lhs_code = code;\n-  enum tree_code rhs_code = code;\n-  /* And these are the types of the expressions.  */\n-  tree lhs_type = type;\n-  tree rhs_type = type;\n-  int save = 0;\n-\n-  if (TREE_CODE (cond) != COND_EXPR\n-      && TREE_CODE_CLASS (code) == '<')\n-    return NULL_TREE;\n-\n-  if (TREE_CODE (arg) == COND_EXPR\n-      && count_cond (cond, 25) + count_cond (arg, 25) > 25)\n-    return NULL_TREE;\n \n-  if (TREE_SIDE_EFFECTS (arg)\n-      && (lang_hooks.decls.global_bindings_p () != 0\n-\t  || CONTAINS_PLACEHOLDER_P (arg)))\n+  /* This transformation is only worthwhile if we don't have to wrap\n+     arg in a SAVE_EXPR, and the operation can be simplified on atleast\n+     one of the branches once its pushed inside the COND_EXPR.  */\n+  if (!TREE_CONSTANT (arg))\n     return NULL_TREE;\n \n-  if (cond_first_p)\n-    {\n-      true_rhs = false_rhs = &arg;\n-      true_lhs = &true_value;\n-      false_lhs = &false_value;\n-    }\n-  else\n-    {\n-      true_lhs = false_lhs = &arg;\n-      true_rhs = &true_value;\n-      false_rhs = &false_value;\n-    }\n-\n   if (TREE_CODE (cond) == COND_EXPR)\n     {\n       test = TREE_OPERAND (cond, 0);\n       true_value = TREE_OPERAND (cond, 1);\n       false_value = TREE_OPERAND (cond, 2);\n       /* If this operand throws an expression, then it does not make\n \t sense to try to perform a logical or arithmetic operation\n-\t involving it.  Instead of building `a + throw 3' for example,\n-\t we simply build `a, throw 3'.  */\n+\t involving it.  */\n       if (VOID_TYPE_P (TREE_TYPE (true_value)))\n-\t{\n-\t  if (! cond_first_p)\n-\t    {\n-\t      lhs_code = COMPOUND_EXPR;\n-\t      lhs_type = void_type_node;\n-\t    }\n-\t  else\n-\t    lhs = true_value;\n-\t}\n+\tlhs = true_value;\n       if (VOID_TYPE_P (TREE_TYPE (false_value)))\n-\t{\n-\t  if (! cond_first_p)\n-\t    {\n-\t      rhs_code = COMPOUND_EXPR;\n-\t      rhs_type = void_type_node;\n-\t    }\n-\t  else\n-\t    rhs = false_value;\n-\t}\n+\trhs = false_value;\n     }\n   else\n     {\n@@ -4912,60 +4800,15 @@ fold_binary_op_with_conditional_arg (enum tree_code code, tree type,\n       false_value = fold_convert (testtype, integer_zero_node);\n     }\n \n-  /* If ARG is complex we want to make sure we only evaluate it once.  Though\n-     this is only required if it is volatile, it might be more efficient even\n-     if it is not.  However, if we succeed in folding one part to a constant,\n-     we do not need to make this SAVE_EXPR.  Since we do this optimization\n-     primarily to see if we do end up with constant and this SAVE_EXPR\n-     interferes with later optimizations, suppressing it when we can is\n-     important.\n-\n-     If we are not in a function, we can't make a SAVE_EXPR, so don't try to\n-     do so.  Don't try to see if the result is a constant if an arm is a\n-     COND_EXPR since we get exponential behavior in that case.  */\n-\n-  if (saved_expr_p (arg))\n-    save = 1;\n-  else if (lhs == 0 && rhs == 0\n-\t   && !TREE_CONSTANT (arg)\n-\t   && lang_hooks.decls.global_bindings_p () == 0\n-\t   && ((TREE_CODE (arg) != VAR_DECL && TREE_CODE (arg) != PARM_DECL)\n-\t       || TREE_SIDE_EFFECTS (arg)))\n-    {\n-      if (TREE_CODE (true_value) != COND_EXPR)\n-\tlhs = fold (build (lhs_code, lhs_type, *true_lhs, *true_rhs));\n-\n-      if (TREE_CODE (false_value) != COND_EXPR)\n-\trhs = fold (build (rhs_code, rhs_type, *false_lhs, *false_rhs));\n-\n-      if ((lhs == 0 || ! TREE_CONSTANT (lhs))\n-\t  && (rhs == 0 || !TREE_CONSTANT (rhs)))\n-\t{\n-\t  arg = save_expr (arg);\n-\t  lhs = rhs = 0;\n-\t  save = saved_expr_p (arg);\n-\t}\n-    }\n-\n   if (lhs == 0)\n-    lhs = fold (build (lhs_code, lhs_type, *true_lhs, *true_rhs));\n+    lhs = fold (cond_first_p ? build2 (code, type, true_value, arg)\n+\t\t\t     : build2 (code, type, arg, true_value));\n   if (rhs == 0)\n-    rhs = fold (build (rhs_code, rhs_type, *false_lhs, *false_rhs));\n-\n-  test = fold (build (COND_EXPR, type, test, lhs, rhs));\n-\n-  /* If ARG involves a SAVE_EXPR, we need to ensure it is evaluated\n-     ahead of the COND_EXPR we made.  Otherwise we would have it only\n-     evaluated in one branch, with the other branch using the result\n-     but missing the evaluation code.  Beware that the save_expr call\n-     above might not return a SAVE_EXPR, so testing the TREE_CODE\n-     of ARG is not enough to decide here.  */\n-  if (save)\n-    return build (COMPOUND_EXPR, type,\n-\t\t  fold_convert (void_type_node, arg),\n-\t\t  strip_compound_expr (test, arg));\n-  else\n-    return fold_convert (type, test);\n+    rhs = fold (cond_first_p ? build2 (code, type, false_value, arg)\n+\t\t\t     : build2 (code, type, arg, false_value));\n+\n+  test = fold (build3 (COND_EXPR, type, test, lhs, rhs));\n+  return fold_convert (type, test);\n }\n \n \f"}, {"sha": "9a9b2daaa8157a121abfe375472e2ffdbcdf38c1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4085d4c0b2c20282d8197507f6ffb35522aa2e6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4085d4c0b2c20282d8197507f6ffb35522aa2e6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f4085d4c0b2c20282d8197507f6ffb35522aa2e6", "patch": "@@ -1,3 +1,9 @@\n+2004-05-20  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR middle-end/3074\n+\t* gcc.dg/pr3074-1.c: New test case.\n+\t* gcc.dg/sequence-pt-1.c: Remove an XFAIL.\n+\n 2004-05-20  Falk Hueffner  <falk@debian.org>\n \n \tPR other/15526"}, {"sha": "c2258d57bb1fbaab896b5dcc9bb4609c759cead5", "filename": "gcc/testsuite/gcc.dg/pr3074-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4085d4c0b2c20282d8197507f6ffb35522aa2e6/gcc%2Ftestsuite%2Fgcc.dg%2Fpr3074-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4085d4c0b2c20282d8197507f6ffb35522aa2e6/gcc%2Ftestsuite%2Fgcc.dg%2Fpr3074-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr3074-1.c?ref=f4085d4c0b2c20282d8197507f6ffb35522aa2e6", "patch": "@@ -0,0 +1,10 @@\n+/* PR middle-end/3074  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wall\" } */\n+\n+void foo()\n+{\n+  int a;\n+  5 * (a == 1) | (a == 2);  /* { dg-warning \"no effect\" \"no effect\" } */\n+}\n+"}, {"sha": "3b9214233cd4763def57e6425d81a0893465c882", "filename": "gcc/testsuite/gcc.dg/sequence-pt-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4085d4c0b2c20282d8197507f6ffb35522aa2e6/gcc%2Ftestsuite%2Fgcc.dg%2Fsequence-pt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4085d4c0b2c20282d8197507f6ffb35522aa2e6/gcc%2Ftestsuite%2Fgcc.dg%2Fsequence-pt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsequence-pt-1.c?ref=f4085d4c0b2c20282d8197507f6ffb35522aa2e6", "patch": "@@ -56,7 +56,7 @@ foo (int a, int b, int n, int p, int *ptr, struct s *sptr,\n   ap[a+=1] += a++; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   a = a++, b = a; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   b = a, a = a++; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n-  a = (b++ ? n : a) + b; /* { dg-warning \"undefined\" \"sequence point warning\" { xfail *-*-* } } */\n+  a = (b++ ? n : a) + b; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   b ? a = a++ : a; /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   b && (a = a++); /* { dg-warning \"undefined\" \"sequence point warning\" } */\n   (a = a++) && b; /* { dg-warning \"undefined\" \"sequence point warning\" } */"}, {"sha": "2d1513c98ec1adc14b21bfc7ca84a2c017e872b9", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4085d4c0b2c20282d8197507f6ffb35522aa2e6/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4085d4c0b2c20282d8197507f6ffb35522aa2e6/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=f4085d4c0b2c20282d8197507f6ffb35522aa2e6", "patch": "@@ -1432,15 +1432,6 @@ skip_simple_arithmetic (tree expr)\n   return inner;\n }\n \n-/* Return TRUE if EXPR is a SAVE_EXPR or wraps simple arithmetic around a\n-   SAVE_EXPR.  Return FALSE otherwise.  */\n-\n-bool\n-saved_expr_p (tree expr)\n-{\n-  return TREE_CODE (skip_simple_arithmetic (expr)) == SAVE_EXPR;\n-}\n-\n /* Arrange for an expression to be expanded multiple independent\n    times.  This is useful for cleanup actions, as the backend can\n    expand them multiple times in different places.  */"}, {"sha": "ef33d0106570e24343c07593a0d5d069185b0888", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4085d4c0b2c20282d8197507f6ffb35522aa2e6/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4085d4c0b2c20282d8197507f6ffb35522aa2e6/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=f4085d4c0b2c20282d8197507f6ffb35522aa2e6", "patch": "@@ -3177,11 +3177,6 @@ extern tree save_expr (tree);\n \n extern tree skip_simple_arithmetic (tree);\n \n-/* Return TRUE if EXPR is a SAVE_EXPR or wraps simple arithmetic around a\n-   SAVE_EXPR.  Return FALSE otherwise.  */\n-\n-extern bool saved_expr_p (tree);\n-\n /* Returns the index of the first non-tree operand for CODE, or the number\n    of operands if all are trees.  */\n "}]}