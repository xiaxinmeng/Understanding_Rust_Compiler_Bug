{"sha": "108e13eb74bd925fba2a6e2e692bd1de1342fd3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA4ZTEzZWI3NGJkOTI1ZmJhMmE2ZTJlNjkyYmQxZGUxMzQyZmQzYw==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2006-10-31T17:55:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T17:55:39Z"}, "message": "exp_dbug.ads, [...] (Get_External_Name): Add missing initialization of Homonym_Len.\n\n2006-10-31  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_dbug.ads, exp_dbug.adb (Get_External_Name): Add missing\n\tinitialization of Homonym_Len.\n\t(Fully_Qualify_Name): Remove kludge to eliminate anonymous block\n\tnames from fully qualified name. Fixes problem of duplicate\n\texternal names differing only in the presence of such a block name.\n\nFrom-SVN: r118263", "tree": {"sha": "3b67093b9dac5a89e93d9b4f89c5e837966fe06f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b67093b9dac5a89e93d9b4f89c5e837966fe06f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/108e13eb74bd925fba2a6e2e692bd1de1342fd3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/108e13eb74bd925fba2a6e2e692bd1de1342fd3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/108e13eb74bd925fba2a6e2e692bd1de1342fd3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/108e13eb74bd925fba2a6e2e692bd1de1342fd3c/comments", "author": null, "committer": null, "parents": [{"sha": "ae5dd59d043919bf07714293c31d93281cebfb30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae5dd59d043919bf07714293c31d93281cebfb30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae5dd59d043919bf07714293c31d93281cebfb30"}], "stats": {"total": 548, "additions": 261, "deletions": 287}, "files": [{"sha": "babdef20daffe6467866107b595d1b5e9a21b775", "filename": "gcc/ada/exp_dbug.adb", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108e13eb74bd925fba2a6e2e692bd1de1342fd3c/gcc%2Fada%2Fexp_dbug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108e13eb74bd925fba2a6e2e692bd1de1342fd3c/gcc%2Fada%2Fexp_dbug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.adb?ref=108e13eb74bd925fba2a6e2e692bd1de1342fd3c", "patch": "@@ -36,7 +36,6 @@ with Output;   use Output;\n with Sem_Eval; use Sem_Eval;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n-with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n with Table;\n@@ -546,7 +545,6 @@ package body Exp_Dbug is\n       --  Vax floating-point case\n \n       elsif Vax_Float (E) then\n-\n          if Digits_Value (Base_Type (E)) = 6 then\n             Get_External_Name_With_Suffix (E, \"XFF\");\n \n@@ -679,13 +677,13 @@ package body Exp_Dbug is\n          else\n             Get_Name_String_And_Append (Chars (Entity));\n          end if;\n-\n       end Get_Qualified_Name_And_Append;\n \n    --  Start of processing for Get_External_Name\n \n    begin\n-      Name_Len := 0;\n+      Name_Len    := 0;\n+      Homonym_Len := 0;\n \n       --  If this is a child unit, we want the child\n \n@@ -887,9 +885,10 @@ package body Exp_Dbug is\n    ------------------------------------\n \n    procedure Get_Secondary_DT_External_Name\n-     (Typ             : Entity_Id;\n-      Ancestor_Typ    : Entity_Id;\n-      Suffix_Index    : Int) is\n+     (Typ          : Entity_Id;\n+      Ancestor_Typ : Entity_Id;\n+      Suffix_Index : Int)\n+   is\n    begin\n       Get_External_Name (Typ, Has_Suffix => False);\n \n@@ -1116,26 +1115,13 @@ package body Exp_Dbug is\n                Get_Name_String (Chars (E));\n             end if;\n \n-            --  A special check here, we never add internal block or loop\n-            --  names, since they intefere with debugging. We identify these\n-            --  by the fact that they start with an upper case B or L.\n-            --  But do add these if what we are qualifying is a __clean\n-            --  procedure since those need to be made unique.\n+            --  Here we do one step of the qualification\n \n-            if (Name_Buffer (1) = 'B' or else Name_Buffer (1) = 'L')\n-                and then (not Debug_Flag_VV)\n-                and then Full_Qualify_Len > 2\n-                and then Chars (Ent) /= Name_uClean\n-            then\n-               Full_Qualify_Len := Full_Qualify_Len - 2;\n-\n-            else\n-               Full_Qualify_Name\n-                 (Full_Qualify_Len + 1 .. Full_Qualify_Len + Name_Len) :=\n-                   Name_Buffer (1 .. Name_Len);\n-               Full_Qualify_Len := Full_Qualify_Len + Name_Len;\n-               Append_Homonym_Number (E);\n-            end if;\n+            Full_Qualify_Name\n+              (Full_Qualify_Len + 1 .. Full_Qualify_Len + Name_Len) :=\n+                 Name_Buffer (1 .. Name_Len);\n+            Full_Qualify_Len := Full_Qualify_Len + Name_Len;\n+            Append_Homonym_Number (E);\n          end if;\n \n          if Is_BNPE (E) then"}, {"sha": "49979e30b8db25d7822ad4869fc4f36c9568e64f", "filename": "gcc/ada/exp_dbug.ads", "status": "modified", "additions": 249, "deletions": 261, "changes": 510, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/108e13eb74bd925fba2a6e2e692bd1de1342fd3c/gcc%2Fada%2Fexp_dbug.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/108e13eb74bd925fba2a6e2e692bd1de1342fd3c/gcc%2Fada%2Fexp_dbug.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.ads?ref=108e13eb74bd925fba2a6e2e692bd1de1342fd3c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1996-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1996-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -50,35 +50,35 @@ package Exp_Dbug is\n    --  as described in Namet). Upper case letters are used only for entities\n    --  generated by the compiler.\n \n-   --  There are two cases, global entities, and local entities. In more\n-   --  formal terms, local entities are those which have a dynamic enclosing\n-   --  scope, and global entities are at the library level, except that we\n-   --  always consider procedures to be global entities, even if they are\n-   --  nested (that's because at the debugger level a procedure name refers\n-   --  to the code, and the code is indeed a global entity, including the\n-   --  case of nested procedures.) In addition, we also consider all types\n-   --  to be global entities, even if they are defined within a procedure.\n+   --  There are two cases, global entities, and local entities. In more formal\n+   --  terms, local entities are those which have a dynamic enclosing scope,\n+   --  and global entities are at the library level, except that we always\n+   --  consider procedures to be global entities, even if they are nested\n+   --  (that's because at the debugger level a procedure name refers to the\n+   --  code, and the code is indeed a global entity, including the case of\n+   --  nested procedures.) In addition, we also consider all types to be global\n+   --  entities, even if they are defined within a procedure.\n \n-   --  The reason for treating all type names as global entities is that\n-   --  a number of our type encodings work by having related type names,\n-   --  and we need the full qualification to keep this unique.\n+   --  The reason for treating all type names as global entities is that a\n+   --  number of our type encodings work by having related type names, and we\n+   --  need the full qualification to keep this unique.\n \n    --  For global entities, the encoded name includes all components of the\n    --  fully expanded name (but omitting Standard at the start). For example,\n    --  if a library level child package P.Q has an embedded package R, and\n    --  there is an entity in this embdded package whose name is S, the encoded\n    --  name will include the components p.q.r.s.\n \n-   --  For local entities, the encoded name only includes the components\n-   --  up to the enclosing dynamic scope (other than a block). At run time,\n-   --  such a dynamic scope is a subprogram, and the debugging formats know\n-   --  about local variables of procedures, so it is not necessary to have\n-   --  full qualification for such entities. In particular this means that\n-   --  direct local variables of a procedure are not qualified.\n+   --  For local entities, the encoded name only includes the components up to\n+   --  the enclosing dynamic scope (other than a block). At run time, such a\n+   --  dynamic scope is a subprogram, and the debugging formats know about\n+   --  local variables of procedures, so it is not necessary to have full\n+   --  qualification for such entities. In particular this means that direct\n+   --  local variables of a procedure are not qualified.\n \n    --  As an example of the local name convention, consider a procedure V.W\n-   --  with a local variable X, and a nested block Y containing an entity\n-   --  Z. The fully qualified names of the entities X and Z are:\n+   --  with a local variable X, and a nested block Y containing an entity Z.\n+   --  The fully qualified names of the entities X and Z are:\n \n    --    V.W.X\n    --    V.W.Y.Z\n@@ -95,21 +95,21 @@ package Exp_Dbug is\n       -- Handling of Overloading --\n       -----------------------------\n \n-      --  The above scheme is incomplete with respect to overloaded\n-      --  subprograms, since overloading can legitimately result in a\n-      --  case of two entities with exactly the same fully qualified names.\n-      --  To distinguish between entries in a set of overloaded subprograms,\n-      --  the encoded names are serialized by adding the suffix:\n+      --  The above scheme is incomplete for overloaded subprograms, since\n+      --  overloading can legitimately result in case of two entities with\n+      --  exactly the same fully qualified names. To distinguish between\n+      --  entries in a set of overloaded subprograms, the encoded names are\n+      --  serialized by adding the suffix:\n \n       --    __nn  (two underscores)\n \n       --  where nn is a serial number (2 for the second overloaded function,\n       --  3 for the third, etc.). A suffix of __1 is always omitted (i.e. no\n       --  suffix implies the first instance).\n \n-      --  These names are prefixed by the normal full qualification. So\n-      --  for example, the third instance of the subprogram qrs in package\n-      --  yz would have the name:\n+      --  These names are prefixed by the normal full qualification. So for\n+      --  example, the third instance of the subprogram qrs in package yz\n+      --  would have the name:\n \n       --    yz__qrs__3\n \n@@ -126,11 +126,11 @@ package Exp_Dbug is\n \n       --    __nn_nn_nn ...\n \n-      --  where the nn values are the homonym numbers as needed for any of\n-      --  the qualifying entities, separated by a single underscore. If all\n-      --  the nn values are 1, the suffix is omitted, Otherwise the suffix\n-      --  is present (including any values of 1). The following example\n-      --  shows how this suffixing works.\n+      --  where the nn values are the homonym numbers as needed for any of the\n+      --  qualifying entities, separated by a single underscore. If all the nn\n+      --  values are 1, the suffix is omitted, Otherwise the suffix is present\n+      --  (including any values of 1). The following example shows how this\n+      --  suffixing works.\n \n       --    package body Yz is\n       --      procedure Qrs is               -- Name is yz__qrs\n@@ -152,10 +152,10 @@ package Exp_Dbug is\n       -- Operator Names --\n       --------------------\n \n-      --   The above rules applied to operator names would result in names\n-      --   with quotation marks, which are not typically allowed by assemblers\n-      --   and linkers, and even if allowed would be odd and hard to deal with.\n-      --   To avoid this problem, operator names are encoded as follows:\n+      --   The above rules applied to operator names would result in names with\n+      --   quotation marks, which are not typically allowed by assemblers and\n+      --   linkers, and even if allowed would be odd and hard to deal with. To\n+      --   avoid this problem, operator names are encoded as follows:\n \n       --    Oabs       abs\n       --    Oand       and\n@@ -179,8 +179,8 @@ package Exp_Dbug is\n \n       --  These names are prefixed by the normal full qualification, and\n       --  suffixed by the overloading identification. So for example, the\n-      --  second operator \"=\" defined in package Extra.Messages would\n-      --  have the name:\n+      --  second operator \"=\" defined in package Extra.Messages would have\n+      --  the name:\n \n       --    extra__messages__Oeq__2\n \n@@ -189,9 +189,9 @@ package Exp_Dbug is\n       ----------------------------------\n \n       --  It might be thought that the above scheme is complete, but in Ada 95,\n-      --  full qualification is insufficient to uniquely identify an entity\n-      --  in the program, even if it is not an overloaded subprogram. There\n-      --  are two possible confusions:\n+      --  full qualification is insufficient to uniquely identify an entity in\n+      --  the program, even if it is not an overloaded subprogram. There are\n+      --  two possible confusions:\n \n       --     a.b\n \n@@ -203,8 +203,8 @@ package Exp_Dbug is\n       --       interpretation 1: entity c in child package a.b\n       --       interpretation 2: entity c in nested package b in body of a\n \n-      --  It is perfectly legal in both cases for both interpretations to\n-      --  be valid within a single program. This is a bit of a surprise since\n+      --  It is perfectly legal in both cases for both interpretations to be\n+      --  valid within a single program. This is a bit of a surprise since\n       --  certainly in Ada 83, full qualification was sufficient, but not in\n       --  Ada 95. The result is that the above scheme can result in duplicate\n       --  names. This would not be so bad if the effect were just restricted\n@@ -213,7 +213,7 @@ package Exp_Dbug is\n       --  a real problem of name clashes.\n \n       --  To deal with this situation, we provide two additional encoding\n-      --  rules for names\n+      --  rules for names:\n \n       --    First: all library subprogram names are preceded by the string\n       --    _ada_ (which causes no duplications, since normal Ada names can\n@@ -835,30 +835,30 @@ package Exp_Dbug is\n       -- Base Record Types --\n       -----------------------\n \n-      --  Under certain circumstances, debuggers need two descriptions\n-      --  of a record type, one that gives the actual details of the\n-      --  base type's structure (as described elsewhere in these\n-      --  comments) and one that may be used to obtain information\n-      --  about the particular subtype and the size of the objects\n-      --  being typed. In such cases the compiler will substitute a\n-      --  type whose name is typically compiler-generated and\n+      --  Under certain circumstances, debuggers need two descriptions of a\n+      --  record type, one that gives the actual details of the base type's\n+      --  structure (as described elsewhere in these comments) and one that may\n+      --  be used to obtain information about the particular subtype and the\n+      --  size of the objects being typed. In such cases the compiler will\n+      --  substitute type whose name is typically compiler-generated and\n       --  irrelevant except as a key for obtaining the actual type.\n-      --  Specifically, if this name is x, then we produce a record\n-      --  type named x___XVS consisting of one field. The name of\n-      --  this field is that of the actual type being encoded, which\n-      --  we'll call y (the type of this single field is arbitrary).\n-      --  Both x and y may have corresponding ___XVE types.\n-\n-      --  The size of the objects typed as x should be obtained from\n-      --  the structure of x (and x___XVE, if applicable) as for\n-      --  ordinary types unless there is a variable named x___XVZ, which,\n-      --  if present, will hold the the size (in bits) of x.\n-\n-      --  The type x will either be a subtype of y (see also Subtypes\n-      --  of Variant Records, below) or will contain no fields at\n-      --  all. The layout, types, and positions of these fields will\n-      --  be accurate, if present. (Currently, however, the GDB\n-      --  debugger makes no use of x except to determine its size).\n+\n+      --  Specifically, if this name is x, then we produce a record type named\n+      --  x___XVS consisting of one field. The name of this field is that of\n+      --  the actual type being encoded, which we'll call y (the type of this\n+      --  single field is arbitrary). Both x and y may have corresponding\n+      --  ___XVE types.\n+\n+      --  The size of the objects typed as x should be obtained from the\n+      --  structure of x (and x___XVE, if applicable) as for ordinary types\n+      --  unless there is a variable named x___XVZ, which, if present, will\n+      --  hold the the size (in bits) of x.\n+\n+      --  The type x will either be a subtype of y (see also Subtypes of\n+      --  Variant Records, below) or will contain no fields at all. The layout,\n+      --  types, and positions of these fields will be accurate, if present.\n+      --  (Currently, however, the GDB debugger makes no use of x except to\n+      --  determine its size).\n \n       --  Among other uses, XVS types are sometimes used to encode\n       --  unconstrained types. For example, given\n@@ -889,12 +889,11 @@ package Exp_Dbug is\n       --\n       --     at1___C_PAD___XVZ: constant Integer := 32 + M * 8 + padding term;\n       --\n-      --  Not all unconstrained types are so encoded; the XVS\n-      --  convention may be unnecessary for unconstrained types of\n-      --  fixed size. However, this encoding is always necessary when\n-      --  a subcomponent type (array element's type or record field's\n-      --  type) is an unconstrained record type some of whose\n-      --  components depend on discriminant values.\n+      --  Not all unconstrained types are so encoded; the XVS convention may be\n+      --  unnecessary for unconstrained types of fixed size. However, this\n+      --  encoding is always necessary when a subcomponent type (array\n+      --  element's type or record field's type) is an unconstrained record\n+      --  type some of whose components depend on discriminant values.\n \n       -----------------\n       -- Array Types --\n@@ -906,39 +905,38 @@ package Exp_Dbug is\n       --  are the names of the types for the bounds. The types of these\n       --  fields is an integer type which is meaningless.\n \n-      --  To conserve space, we do not produce this type unless one of\n-      --  the index types is either an enumeration type, has a variable\n-      --  upper bound, has a lower bound different from the constant 1,\n-      --  is a biased type, or is wider than \"sizetype\".\n+      --  To conserve space, we do not produce this type unless one of the\n+      --  index types is either an enumeration type, has a variable upper\n+      --  bound, has a lower bound different from the constant 1, is a biased\n+      --  type, or is wider than \"sizetype\".\n \n       --  Given the full encoding of these types (see above description for\n       --  the encoding of discrete types), this means that all necessary\n-      --  information for addressing arrays is available. In some\n-      --  debugging formats, some or all of the bounds information may\n-      --  be available redundantly, particularly in the fixed-point case,\n-      --  but this information can in any case be ignored by the debugger.\n+      --  information for addressing arrays is available. In some debugging\n+      --  formats, some or all of the bounds information may be available\n+      --  redundantly, particularly in the fixed-point case, but this\n+      --  information can in any case be ignored by the debugger.\n \n       ----------------------------\n       -- Note on Implicit Types --\n       ----------------------------\n \n-      --  The compiler creates implicit type names in many situations where\n-      --  a type is present semantically, but no specific name is present.\n-      --  For example:\n+      --  The compiler creates implicit type names in many situations where a\n+      --  type is present semantically, but no specific name is present. For\n+      --  example:\n \n       --     S : Integer range M .. N;\n \n-      --  Here the subtype of S is not integer, but rather an anonymous\n-      --  subtype of Integer. Where possible, the compiler generates names\n-      --  for such anonymous types that are related to the type from which\n-      --  the subtype is obtained as follows:\n+      --  Here the subtype of S is not integer, but rather an anonymous subtype\n+      --  of Integer. Where possible, the compiler generates names for such\n+      --  anonymous types that are related to the type from which the subtype\n+      --  is obtained as follows:\n \n       --     T name suffix\n \n       --  where name is the name from which the subtype is obtained, using\n       --  lower case letters and underscores, and suffix starts with an upper\n-      --  case letter. For example, the name for the above declaration of S\n-      --  might be:\n+      --  case letter. For example the name for the above declaration might be:\n \n       --     TintegerS4b\n \n@@ -985,11 +983,11 @@ package Exp_Dbug is\n    --    x___XRE   for an exception renaming\n    --    x___XRP   for a package renaming\n \n-   --  The name is fully qualified in the usual manner, i.e. qualified in\n-   --  the same manner as the entity x would be. In the case of a package\n-   --  renaming where x is a child unit, the qualification includes the\n-   --  name of the parent unit, to disambiguate child units with the same\n-   --  simple name and (of necessity) different parents.\n+   --  The name is fully qualified in the usual manner, i.e. qualified in the\n+   --  same manner as the entity x would be. In the case of a package renaming\n+   --  where x is a child unit, the qualification includes the name of the\n+   --  parent unit, to disambiguate child units with the same simple name and\n+   --  (of necessity) different parents.\n \n    --  Note: subprogram renamings are not encoded at the present time\n \n@@ -1001,17 +999,17 @@ package Exp_Dbug is\n \n    --       (y___XE)\n \n-   --          i.e. the enumeration type has a single field, whose name\n-   --          matches the name y, with the XE suffix. The entity for this\n-   --          enumeration literal is fully qualified in the usual manner.\n-   --          All subprogram, exception, and package renamings fall into\n-   --          this category, as well as simple object renamings.\n+   --          i.e. the enumeration type has a single field, whose name matches\n+   --          the name y, with the XE suffix. The entity for this enumeration\n+   --          literal is fully qualified in the usual manner. All subprogram,\n+   --          exception, and package renamings fall into this category, as\n+   --          well as simple object renamings.\n \n    --    For the object renaming case where y is a selected component or an\n    --    indexed component, the literal name is suffixed by additional fields\n-   --    that give details of the components. The name starts as above with\n-   --    a y___XE entity indicating the outer level variable. Then a series\n-   --    of selections and indexing operations can be specified as follows:\n+   --    that give details of the components. The name starts as above with a\n+   --    y___XE entity indicating the outer level variable. Then a series of\n+   --    selections and indexing operations can be specified as follows:\n \n    --      Indexed component\n \n@@ -1033,14 +1031,14 @@ package Exp_Dbug is\n \n    --      Slice\n \n-   --        For the slice case, we have two entries. The first is for\n-   --        the lower bound of the slice, and has the form\n+   --        For the slice case, we have two entries. The first is for the\n+   --        lower bound of the slice, and has the form\n \n    --          XLnnn\n    --          XLe\n \n-   --            Specifies the lower bound, using exactly the same encoding\n-   --            as for an XS subscript as described above.\n+   --            Specifies the lower bound, using exactly the same encoding as\n+   --            for an XS subscript as described above.\n \n    --        Then the upper bound appears in the usual XSnnn/XSe form\n \n@@ -1158,61 +1156,57 @@ package Exp_Dbug is\n    --       BV(0) BV(1)  BV(2)  BV(3) BV(4)  BV(5)  unused bits\n \n    --  Note that if a modular type is used to represent the array, the\n-   --  allocation in memory is not the same as a normal modular type.\n-   --  The difference occurs when the allocated object is larger than\n-   --  the size of the array. For a normal modular type, we extend the\n-   --  value on the left with zeroes.\n-\n-   --  For example, in the normal modular case, if we have a 6-bit\n-   --  modular type, declared as mod 2**6, and we allocate an 8-bit\n-   --  object for this type, then we extend the value with two bits\n-   --  on the most significant end, and in either the little-endian\n-   --  or big-endian case, the value 63 is represented as 00111111\n-   --  in binary in memory.\n+   --  allocation in memory is not the same as a normal modular type. The\n+   --  difference occurs when the allocated object is larger than the size of\n+   --  the array. For a normal modular type, we extend the value on the left\n+   --  with zeroes.\n+\n+   --  For example, in the normal modular case, if we have a 6-bit modular\n+   --  type, declared as mod 2**6, and we allocate an 8-bit object for this\n+   --  type, then we extend the value with two bits on the most significant\n+   --  end, and in either the little-endian or big-endian case, the value 63 is\n+   --  represented as 00111111 in binary in memory.\n \n    --  For a modular type used to represent a packed array, the rule is\n-   --  different. In this case, if we have to extend the value, then we\n-   --  do it with undefined bits (which are not initialized and whose value\n-   --  is irrelevant to any generated code). Furthermore these bits are on\n-   --  the right (least significant bits) in the big-endian case, and on the\n-   --  left (most significant bits) in the little-endian case.\n+   --  different. In this case, if we have to extend the value, then we do it\n+   --  with undefined bits (which are not initialized and whose value is\n+   --  irrelevant to any generated code). Furthermore these bits are on the\n+   --  right (least significant bits) in the big-endian case, and on the left\n+   --  (most significant bits) in the little-endian case.\n \n-   --  For example, if we have a packed boolean array of 6 bits, all set\n-   --  to True, stored in an 8-bit object, then the value in memory in\n-   --  binary is ??111111 in the little-endian case, and 111111?? in the\n-   --  big-endian case.\n+   --  For example, if we have a packed boolean array of 6 bits, all set to\n+   --  True, stored in an 8-bit object, then the value in memory in binary is\n+   --  ??111111 in the little-endian case, and 111111?? in the big-endian case.\n \n    --  This is done so that the representation of packed arrays does not\n    --  depend on whether we use a modular representation or array of bytes\n-   --  as previously described. This ensures that we can pass such values\n-   --  by reference in the case where a subprogram has to be able to handle\n-   --  values stored in either form.\n+   --  as previously described. This ensures that we can pass such values by\n+   --  reference in the case where a subprogram has to be able to handle values\n+   --  stored in either form.\n \n-   --  Note that when we extract the value of such a modular packed array,\n-   --  we expect to retrieve only the relevant bits, so in this same example,\n-   --  when we extract the value, we get 111111 in both cases, and the code\n-   --  generated by the front end assumes this, although it does not assume\n-   --  that any high order bits are defined.\n+   --  Note that when we extract the value of such a modular packed array, we\n+   --  expect to retrieve only the relevant bits, so in this same example, when\n+   --  we extract the value we get 111111 in both cases, and the code generated\n+   --  by the front end assumes this although it does not assume that any high\n+   --  order bits are defined.\n \n-   --  There are opportunities for optimization based on the knowledge that\n-   --  the unused bits are irrelevant for these type of packed arrays. For\n-   --  example if we have two such 6-bit-in-8-bit values and we do an\n-   --  assignment:\n+   --  There are opportunities for optimization based on the knowledge that the\n+   --  unused bits are irrelevant for these type of packed arrays. For example\n+   --  if we have two such 6-bit-in-8-bit values and we do an assignment:\n \n    --     a := b;\n \n    --  Then logically, we extract the 6 bits and store only 6 bits in the\n-   --  result, but the back end is free to simply assign the entire 8-bits\n-   --  in this case, since we don't actually care about the undefined bits.\n+   --  result, but the back end is free to simply assign the entire 8-bits in\n+   --  this case, since we don't actually care about the undefined bits.\n    --  However, in the equality case, it is important to ensure that the\n    --  undefined bits do not participate in an equality test.\n \n    --  If a modular packed array value is assigned to a register, then\n-   --  logically it could always be held right justified, to avoid any\n-   --  need to shift, e.g. when doing comparisons. But probably this is\n-   --  a bad choice, as it would mean that an assignment such as a := b\n-   --  above would require shifts when one value is in a register and the\n-   --  other value is in memory.\n+   --  logically it could always be held right justified, to avoid any need to\n+   --  shift, e.g. when doing comparisons. But probably this is a bad choice,\n+   --  as it would mean that an assignment such as a := above would require\n+   --  shifts when one value is in a register and the other value is in memory.\n \n    ------------------------------------------------------\n    -- Subprograms for Handling Packed Array Type Names --\n@@ -1222,27 +1216,26 @@ package Exp_Dbug is\n      (Typ   : Entity_Id;\n       Csize : Uint)\n       return  Name_Id;\n-   --  This function is used in Exp_Pakd to create the name that is encoded\n-   --  as described above. The entity Typ provides the name ttt, and the\n-   --  value Csize is the component size that provides the nnn value.\n+   --  This function is used in Exp_Pakd to create the name that is encoded as\n+   --  described above. The entity Typ provides the name ttt, and the value\n+   --  Csize is the component size that provides the nnn value.\n \n    --------------------------------------\n    -- Pointers to Unconstrained Arrays --\n    --------------------------------------\n \n-   --  There are two kinds of pointers to arrays. The debugger can tell\n-   --  which format is in use by the form of the type of the pointer.\n+   --  There are two kinds of pointers to arrays. The debugger can tell which\n+   --  format is in use by the form of the type of the pointer.\n \n    --    Fat Pointers\n \n    --      Fat pointers are represented as a struct with two fields. This\n    --      struct has two distinguished field names:\n \n-   --        P_ARRAY is a pointer to the array type. The name of this\n-   --        type is the unconstrained type followed by \"___XUA\". This\n-   --        array will have bounds which are the discriminants, and\n-   --        hence are unparsable, but will give the number of\n-   --        subscripts and the component type.\n+   --        P_ARRAY is a pointer to the array type. The name of this type is\n+   --        the unconstrained type followed by \"___XUA\". This array will have\n+   --        bounds which are the discriminants, and hence are unparsable, but\n+   --        will give the number of subscripts and the component type.\n \n    --        P_BOUNDS is a pointer to a struct, the name of  whose type is the\n    --        unconstrained array name followed by \"___XUB\" and which has\n@@ -1251,74 +1244,71 @@ package Exp_Dbug is\n    --           LBn (n a decimal integer) lower bound of n'th dimension\n    --           UBn (n a decimal integer) upper bound of n'th dimension\n \n-   --        The bounds may be any integral type. In the case of an\n-   --        enumeration type, Enum_Rep values are used.\n+   --        The bounds may be any integral type. In the case of an enumeration\n+   --        type, Enum_Rep values are used.\n \n-   --      The debugging information will sometimes reference an anonymous\n-   --      fat pointer type. Such types are given the name xxx___XUP, where\n-   --      xxx is the name of the designated type. If the debugger is asked\n-   --      to output such a type name, the appropriate form is \"access xxx\".\n+   --      The debugging information will sometimes reference an anonymous fat\n+   --      pointer type. Such types are given the name xxx___XUP, where xxx is\n+   --      the name of the designated type. If the debugger is asked to output\n+   --      such a type name, the appropriate form is \"access xxx\".\n \n    --    Thin Pointers\n \n-   --      The value of a thin pointer is a pointer to the second field\n-   --      of a structure with two fields. The name of this structure's\n-   --      type is \"arr___XUT\", where \"arr\" is the name of the\n-   --      unconstrained array type. Even though it actually points into\n-   --      middle of this structure, the thin pointer's type in debugging\n-   --      information is pointer-to-arr___XUT.\n-\n-   --      The first field of arr___XUT is named BOUNDS, and has a type\n-   --      named arr___XUB, with the structure described for such types\n-   --      in fat pointers, as described above.\n-\n-   --      The second field of arr___XUT is named ARRAY, and contains\n-   --      the actual array. Because this array has a dynamic size,\n-   --      determined by the BOUNDS field that precedes it, all of the\n-   --      information about arr___XUT is encoded in a parallel type named\n-   --      arr___XUT___XVE, with fields BOUNDS and ARRAY___XVL. As for\n-   --      previously described ___XVE types, ARRAY___XVL has\n-   --      a pointer-to-array type. However, the array type in this case\n-   --      is named arr___XUA and only its element type is meaningful,\n-   --      just as described for fat pointers.\n+   --      The value of a thin pointer is a pointer to the second field of a\n+   --      structure with two fields. The name of this structure's type is\n+   --      \"arr___XUT\", where \"arr\" is the name of the unconstrained array\n+   --      type. Even though it actually points into middle of this structure,\n+   --      the thin pointer's type in debugging information is\n+   --      pointer-to-arr___XUT.\n+\n+   --      The first field of arr___XUT is named BOUNDS, and has a type named\n+   --      arr___XUB, with the structure described for such types in fat\n+   --      pointers, as described above.\n+\n+   --      The second field of arr___XUT is named ARRAY, and contains the\n+   --      actual array. Because this array has a dynamic size, determined by\n+   --      the BOUNDS field that precedes it, all of the information about\n+   --      arr___XUT is encoded in a parallel type named arr___XUT___XVE, with\n+   --      fields BOUNDS and ARRAY___XVL. As for previously described ___XVE\n+   --      types, ARRAY___XVL has a pointer-to-array type. However, the array\n+   --      type in this case is named arr___XUA and only its element type is\n+   --      meaningful, just as described for fat pointers.\n \n    --------------------------------------\n    -- Tagged Types and Type Extensions --\n    --------------------------------------\n \n-   --  A type C derived from a tagged type P has a field named \"_parent\"\n-   --  of type P that contains its inherited fields. The type of this\n-   --  field is usually P (encoded as usual if it has a dynamic size),\n-   --  but may be a more distant ancestor, if P is a null extension of\n-   --  that type.\n+   --  A type C derived from a tagged type P has a field named \"_parent\" of\n+   --  type P that contains its inherited fields. The type of this field is\n+   --  usually P (encoded as usual if it has a dynamic size), but may be a more\n+   --  distant ancestor, if P is a null extension of that type.\n \n-   --  The type tag of a tagged type is a field named _tag, of type void*.\n-   --  If the type is derived from another tagged type, its _tag field is\n-   --  found in its _parent field.\n+   --  The type tag of a tagged type is a field named _tag, of type void*. If\n+   --  the type is derived from another tagged type, its _tag field is found in\n+   --  its _parent field.\n \n    -----------------------------\n    -- Variant Record Encoding --\n    -----------------------------\n \n-   --  The variant part of a variant record is encoded as a single field\n-   --  in the enclosing record, whose name is:\n+   --  The variant part of a variant record is encoded as a single field in the\n+   --  enclosing record, whose name is:\n \n    --     discrim___XVN\n \n-   --  where discrim is the unqualified name of the variant. This field name\n-   --  is built by gigi (not by code in this unit). In the case of an\n-   --  Unchecked_Union record, this discriminant will not appear in the\n-   --  record, and the debugger must proceed accordingly (basically it\n-   --  can treat this case as it would a C union).\n-\n-   --  The type corresponding to this field has a name that is obtained\n-   --  by concatenating the type name with the above string and is similar\n-   --  to a C union, in which each member of the union corresponds to one\n-   --  variant. However, unlike a C union, the size of the type may be\n-   --  variable even if each of the components are fixed size, since it\n-   --  includes a computation of which variant is present. In that case,\n-   --  it will be encoded as above and a type with the suffix \"___XVN___XVU\"\n-   --  will be present.\n+   --  where discrim is the unqualified name of the variant. This field name is\n+   --  built by gigi (not by code in this unit). For Unchecked_Union record,\n+   --  this discriminant will not appear in the record, and the debugger must\n+   --  proceed accordingly (basically it can treat this case as it would a C\n+   --  union).\n+\n+   --  The type corresponding to this field has a name that is obtained by\n+   --  concatenating the type name with the above string and is similar to a C\n+   --  union, in which each member of the union corresponds to one variant.\n+   --  However, unlike a C union, the size of the type may be variable even if\n+   --  each of the components are fixed size, since it includes a computation\n+   --  of which variant is present. In that case, it will be encoded as above\n+   --  and a type with the suffix \"___XVN___XVU\" will be present.\n \n    --  The name of the union member is encoded to indicate the choices, and\n    --  is a string given by the following grammar:\n@@ -1335,15 +1325,15 @@ package Exp_Dbug is\n \n    --    R1T4S7S10m\n \n-   --  In the case of enumeration values, the values used are the\n-   --  actual representation values in the case where an enumeration type\n-   --  has an enumeration representation spec (i.e. they are values that\n-   --  correspond to the use of the Enum_Rep attribute).\n+   --  In the case of enumeration values, the values used are the actual\n+   --  representation values in the case where an enumeration type has an\n+   --  enumeration representation spec (i.e. they are values that correspond\n+   --  to the use of the Enum_Rep attribute).\n \n-   --  The type of the inner record is given by the name of the union\n-   --  type (as above) concatenated with the above string. Since that\n-   --  type may itself be variable-sized, it may also be encoded as above\n-   --  with a new type with a further suffix of \"___XVU\".\n+   --  The type of the inner record is given by the name of the union type (as\n+   --  above) concatenated with the above string. Since that type may itself be\n+   --  variable-sized, it may also be encoded as above with a new type with a\n+   --  further suffix of \"___XVU\".\n \n    --  As an example, consider:\n \n@@ -1362,23 +1352,22 @@ package Exp_Dbug is\n \n    --    V1 : Var;\n \n-   --  In this case, the type var is represented as a struct with three\n-   --  fields, the first two are \"disc\" and \"m\", representing the values\n-   --  of these record  components.\n+   --  In this case, the type var is represented as a struct with three fields,\n+   --  the first two are \"disc\" and \"m\", representing the values of these\n+   --  record components.\n \n-   --  The third field is a union of two types, with field names S1 and O.\n-   --  S1 is a struct with fields \"r\" and \"s\", and O is a struct with\n-   --  fields \"t\".\n+   --  The third field is a union of two types, with field names S1 and O. S1\n+   --  is a struct with fields \"r\" and \"s\", and O is a struct with fields \"t\".\n \n    ------------------------------------------------\n    -- Subprograms for Handling Variant Encodings --\n    ------------------------------------------------\n \n    procedure Get_Variant_Encoding (V : Node_Id);\n-   --  This procedure is called by Gigi with V being the variant node.\n-   --  The corresponding encoding string is returned in Name_Buffer with\n-   --  the length of the string in Name_Len, and an ASCII.NUL character\n-   --  stored following the name.\n+   --  This procedure is called by Gigi with V being the variant node. The\n+   --  corresponding encoding string is returned in Name_Buffer with the length\n+   --  of the string in Name_Len, and an ASCII.NUL character stored following\n+   --  the name.\n \n    ---------------------------------\n    -- Subtypes of Variant Records --\n@@ -1405,38 +1394,37 @@ package Exp_Dbug is\n    --    V2 : Var (True);\n    --    V3 : Var (False);\n \n-   --  Here V2 for example is represented with a subtype whose name is\n-   --  something like TvarS3b, which is a struct with three fields. The\n-   --  first two fields are \"disc\" and \"m\" as for the base type, and\n-   --  the third field is S1, which contains the fields \"r\" and \"s\".\n+   --  Here V2, for example, is represented with a subtype whose name is\n+   --  something like TvarS3b, which is a struct with three fields. The first\n+   --  two fields are \"disc\" and \"m\" as for the base type, and the third field\n+   --  is S1, which contains the fields \"r\" and \"s\".\n \n    --  The debugger should simply ignore structs with names of the form\n-   --  corresponding to variants, and consider the fields inside as\n-   --  belonging to the containing record.\n+   --  corresponding to variants, and consider the fields inside as belonging\n+   --  to the containing record.\n \n    -------------------------------------------\n    -- Character literals in Character Types --\n    -------------------------------------------\n \n-   --  Character types are enumeration types at least one of whose\n-   --  enumeration literals is a character literal. Enumeration literals\n-   --  are usually simply represented using their identifier names. In\n-   --  the case where an enumeration literal is a character literal, the\n-   --  name aencoded as described in the following paragraph.\n+   --  Character types are enumeration types at least one of whose enumeration\n+   --  literals is a character literal. Enumeration literals are usually simply\n+   --  represented using their identifier names. If the enumeration literal is\n+   --  a character literal, the name aencoded as described in the following\n+   --  paragraph.\n \n-   --  A name QUhh, where each 'h' is a lower-case hexadecimal digit,\n-   --  stands for a character whose Unicode encoding is hh, and\n-   --  QWhhhh likewise stands for a wide character whose encoding\n-   --  is hhhh. The representation values are encoded as for ordinary\n-   --  enumeration literals (and have no necessary relationship to the\n-   --  values encoded in the names).\n+   --  A name QUhh, where each 'h' is a lower-case hexadecimal digit, stands\n+   --  for a character whose Unicode encoding is hh, and QWhhhh likewise stands\n+   --  for a wide character whose encoding is hhhh. The representation values\n+   --  are encoded as for ordinary enumeration literals (and have no necessary\n+   --  relationship to the values encoded in the names).\n \n    --  For example, given the type declaration\n \n    --    type x is (A, 'C', B);\n \n-   --  the second enumeration literal would be named QU43 and the\n-   --  value assigned to it would be 1.\n+   --  the second enumeration literal would be named QU43 and the value\n+   --  assigned to it would be 1.\n \n    -----------------------------------------------\n    -- Secondary Dispatch tables of tagged types --\n@@ -1448,9 +1436,9 @@ package Exp_Dbug is\n       Suffix_Index : Int);\n    --  Set Name_Buffer and Name_Len to the external name of one secondary\n    --  dispatch table of Typ. If the interface has been inherited from some\n-   --  ancestor then Ancestor_Typ is such node (in this case the secondary\n-   --  DT is needed to handle overriden primitives); if there is no such\n-   --  ancestor then  Ancestor_Typ is equal to Typ.\n+   --  ancestor then Ancestor_Typ is such node (in this case the secondary DT\n+   --  is needed to handle overriden primitives); if there is no such ancestor\n+   --  then Ancestor_Typ is equal to Typ.\n    --\n    --  Internal rule followed for the generation of the external name:\n    --\n@@ -1464,11 +1452,11 @@ package Exp_Dbug is\n    --             External_Name (Typ) + '_' + External_Name (Ancestor_Typ)\n    --               + Suffix_Number + 'P'\n    --\n-   --  Note: We have to use the external names (instead of simply their\n-   --  names) to protect the frontend against programs that give the same\n-   --  name to all the interfaces and use the expanded name to reference\n-   --  them. The Suffix_Number is used to differentiate all the secondary\n-   --  dispatch tables of a given type.\n+   --  Note: We have to use the external names (instead of simply their names)\n+   --  to protect the frontend against programs that give the same name to all\n+   --  the interfaces and use the expanded name to reference them. The\n+   --  Suffix_Number is used to differentiate all the secondary dispatch\n+   --  tables of a given type.\n    --\n    --  Examples:\n    --\n@@ -1503,14 +1491,14 @@ package Exp_Dbug is\n    ----------------------------\n \n    --  If the program is compiled with optimization on (e.g. -O1 switch\n-   --  specified), then there may be variations in the output from the\n-   --  above specification. In particular, objects may disappear from\n-   --  the output. This includes not only constants and variables that\n-   --  the program declares at the source level, but also the x___L and\n-   --  x___U constants created to describe the lower and upper bounds of\n-   --  subtypes with dynamic bounds. This means for example, that array\n-   --  bounds may disappear if optimization is turned on. The debugger\n-   --  is expected to recognize that these constants are missing and\n-   --  deal as best as it can with the limited information available.\n+   --  specified), then there may be variations in the output from the above\n+   --  specification. In particular, objects may disappear from the output.\n+   --  This includes not only constants and variables that the program declares\n+   --  at the source level, but also the x___L and x___U constants created to\n+   --  describe the lower and upper bounds of subtypes with dynamic bounds.\n+   --  This means for example, that array bounds may disappear if optimization\n+   --  is turned on. The debugger is expected to recognize that these constants\n+   --  are missing and deal as best as it can with the limited information\n+   --  available.\n \n end Exp_Dbug;"}]}