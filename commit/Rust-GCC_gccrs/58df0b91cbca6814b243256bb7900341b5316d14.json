{"sha": "58df0b91cbca6814b243256bb7900341b5316d14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThkZjBiOTFjYmNhNjgxNGIyNDMyNTZiYjc5MDAzNDFiNTMxNmQxNA==", "commit": {"author": {"name": "Simon Dardis", "email": "simon.dardis@imgtec.com", "date": "2015-08-20T09:45:33Z"}, "committer": {"name": "Simon Dardis", "email": "dardiss@gcc.gnu.org", "date": "2015-08-20T09:45:33Z"}, "message": "mips.c (mips_expand_block_move): Enable inline memcpy expansion when !ISA_HAS_LWL_LWR.\n\ngcc/\n\n  \t* config/mips/mips.c (mips_expand_block_move): Enable inline memcpy\n\texpansion when !ISA_HAS_LWL_LWR.\n\t(mips_block_move_straight): Update the size of elements copied to\n\taccount for alignment when !ISA_HAS_LWL_LWR.\n\t* config/mips/mips.h (MIPS_MIN_MOVE_MEM_ALIGN): New macro.\n\ngcc/testsuite/\n\n\t* inline-memcpy-1.c: Test for inline expansion of memcpy.\n\t* inline-memcpy-2.c: Ditto.\n\t* inline-memcpy-3.c: Ditto.\n\t* inline-memcpy-4.c: Ditto.\n\t* inline-memcpy-5.c: Ditto.\n\nFrom-SVN: r227026", "tree": {"sha": "901959ccb3e8165aa8dda975ea4a4cf70526a026", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/901959ccb3e8165aa8dda975ea4a4cf70526a026"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58df0b91cbca6814b243256bb7900341b5316d14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58df0b91cbca6814b243256bb7900341b5316d14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58df0b91cbca6814b243256bb7900341b5316d14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58df0b91cbca6814b243256bb7900341b5316d14/comments", "author": null, "committer": null, "parents": [{"sha": "95f25df08f656e693a62c77bed7766e701f883f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95f25df08f656e693a62c77bed7766e701f883f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95f25df08f656e693a62c77bed7766e701f883f7"}], "stats": {"total": 131, "additions": 124, "deletions": 7}, "files": [{"sha": "62459e78af6fca4a5e910d3aa192817787f58bdc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58df0b91cbca6814b243256bb7900341b5316d14/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58df0b91cbca6814b243256bb7900341b5316d14/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=58df0b91cbca6814b243256bb7900341b5316d14", "patch": "@@ -1,3 +1,11 @@\n+2015-08-20  Simon Dardis  <simon.dardis@imgtec.com>\n+\n+\t* config/mips/mips.c (mips_expand_block_move): Enable inline memcpy\n+\texpansion when !ISA_HAS_LWL_LWR.\n+\t(mips_block_move_straight): Update the size of elements copied to\n+\taccount for alignment when !ISA_HAS_LWL_LWR.\n+\t* config/mips/mips.h (MIPS_MIN_MOVE_MEM_ALIGN): New macro.\n+\n 2015-08-19  Jiong Wang  <jiong.wang@arm.com>\n \n \t* expr.c (expand_expr_real_2): Check gimple statement during"}, {"sha": "0b4a5faacdb93ed5b6ad436ef79f44185b816eb6", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58df0b91cbca6814b243256bb7900341b5316d14/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58df0b91cbca6814b243256bb7900341b5316d14/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=58df0b91cbca6814b243256bb7900341b5316d14", "patch": "@@ -7630,12 +7630,22 @@ mips_block_move_straight (rtx dest, rtx src, HOST_WIDE_INT length)\n      half-word alignment, it is usually better to move in half words.\n      For instance, lh/lh/sh/sh is usually better than lwl/lwr/swl/swr\n      and lw/lw/sw/sw is usually better than ldl/ldr/sdl/sdr.\n-     Otherwise move word-sized chunks.  */\n-  if (MEM_ALIGN (src) == BITS_PER_WORD / 2\n-      && MEM_ALIGN (dest) == BITS_PER_WORD / 2)\n-    bits = BITS_PER_WORD / 2;\n+     Otherwise move word-sized chunks.\n+\n+     For ISA_HAS_LWL_LWR we rely on the lwl/lwr & swl/swr load. Otherwise\n+     picking the minimum of alignment or BITS_PER_WORD gets us the\n+     desired size for bits.  */\n+\n+  if (!ISA_HAS_LWL_LWR)\n+    bits = MIN (BITS_PER_WORD, MIN (MEM_ALIGN (src), MEM_ALIGN (dest)));\n   else\n-    bits = BITS_PER_WORD;\n+    {\n+      if (MEM_ALIGN (src) == BITS_PER_WORD / 2\n+\t  && MEM_ALIGN (dest) == BITS_PER_WORD / 2)\n+\tbits = BITS_PER_WORD / 2;\n+      else\n+\tbits = BITS_PER_WORD;\n+    }\n \n   mode = mode_for_size (bits, MODE_INT, 0);\n   delta = bits / BITS_PER_UNIT;\n@@ -7754,8 +7764,9 @@ mips_block_move_loop (rtx dest, rtx src, HOST_WIDE_INT length,\n bool\n mips_expand_block_move (rtx dest, rtx src, rtx length)\n {\n-  /* Disable entirely for R6 initially.  */\n-  if (!ISA_HAS_LWL_LWR)\n+  if (!ISA_HAS_LWL_LWR\n+      && (MEM_ALIGN (src) < MIPS_MIN_MOVE_MEM_ALIGN\n+\t  || MEM_ALIGN (dest) < MIPS_MIN_MOVE_MEM_ALIGN))\n     return false;\n \n   if (CONST_INT_P (length))"}, {"sha": "2d44735e6ca35fc9a97ffff82612f1c5ae92441d", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58df0b91cbca6814b243256bb7900341b5316d14/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58df0b91cbca6814b243256bb7900341b5316d14/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=58df0b91cbca6814b243256bb7900341b5316d14", "patch": "@@ -2981,6 +2981,9 @@ while (0)\n #undef PTRDIFF_TYPE\n #define PTRDIFF_TYPE (POINTER_SIZE == 64 ? \"long int\" : \"int\")\n \n+/* The minimum alignment of any expanded block move.  */\n+#define MIPS_MIN_MOVE_MEM_ALIGN 16\n+\n /* The maximum number of bytes that can be copied by one iteration of\n    a movmemsi loop; see mips_block_move_loop.  */\n #define MIPS_MAX_MOVE_BYTES_PER_LOOP_ITER \\"}, {"sha": "be3314444230dffe93d9fc7700761afc9c025b38", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58df0b91cbca6814b243256bb7900341b5316d14/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58df0b91cbca6814b243256bb7900341b5316d14/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=58df0b91cbca6814b243256bb7900341b5316d14", "patch": "@@ -1,3 +1,11 @@\n+2015-08-20  Simon Dardis  <simon.dardis@imgtec.com>\n+\n+\t* gcc.target/mips/inline-memcpy-1.c: Test for inline expansion of memcpy.\n+\t* gcc.target/mips/inline-memcpy-2.c: Ditto.\n+\t* gcc.target/mips/inline-memcpy-3.c: Ditto.\n+\t* gcc.target/mips/inline-memcpy-4.c: Ditto.\n+\t* gcc.target/mips/inline-memcpy-5.c: Ditto.\n+\n 2015-08-19  Jiong Wang  <jiong.wang@arm.com>\n \n \t* gcc.dg/wide_shift_64_1.c: New testcase."}, {"sha": "5a254b1eaa913c1a52ee6434403e499c514926a4", "filename": "gcc/testsuite/gcc.target/mips/inline-memcpy-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58df0b91cbca6814b243256bb7900341b5316d14/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finline-memcpy-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58df0b91cbca6814b243256bb7900341b5316d14/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finline-memcpy-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finline-memcpy-1.c?ref=58df0b91cbca6814b243256bb7900341b5316d14", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-options \"-fno-common isa_rev>=6\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" \"-Os\" } { \"\" } } */\n+/* { dg-final { scan-assembler-not \"\\tmemcpy\" } } */\n+\n+/* Test that memcpy is inline for target hardware\n+   without swl, swr.  */\n+\n+#include <string.h>\n+\n+char c[40] __attribute__ ((aligned(8)));\n+\n+void\n+f1 ()\n+{\n+  memcpy (c, \"1234567890QWERTYUIOPASDFGHJKLZXCVBNM\", 32);\n+}"}, {"sha": "e144e61a800fe02627e9c2b542dde3c4e40a17e4", "filename": "gcc/testsuite/gcc.target/mips/inline-memcpy-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58df0b91cbca6814b243256bb7900341b5316d14/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finline-memcpy-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58df0b91cbca6814b243256bb7900341b5316d14/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finline-memcpy-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finline-memcpy-2.c?ref=58df0b91cbca6814b243256bb7900341b5316d14", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-options \"-fno-common isa_rev>=6\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" \"-Os\"} { \"\" } } */\n+/* { dg-final { scan-assembler-not \"\\tmemcpy\" } } */\n+/* { dg-final { scan-assembler-times \"\\tsh\\t\" 16 } } */\n+\n+/* Test that inline memcpy is expanded for target hardware without\n+   swl, swr when alignment is halfword and sufficent shs are produced.  */\n+\n+#include <string.h>\n+\n+char c[40] __attribute__ ((aligned(2)));\n+\n+void\n+f1 ()\n+{\n+  memcpy (c, \"1234567890QWERTYUIOPASDFGHJKLZXCVBNM\", 32);\n+}"}, {"sha": "96a0387fce52c65873ed6847e013891df0e613a7", "filename": "gcc/testsuite/gcc.target/mips/inline-memcpy-3.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58df0b91cbca6814b243256bb7900341b5316d14/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finline-memcpy-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58df0b91cbca6814b243256bb7900341b5316d14/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finline-memcpy-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finline-memcpy-3.c?ref=58df0b91cbca6814b243256bb7900341b5316d14", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-options \"-fno-common isa_rev<=5\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" \"-Os\"} { \"\" } } */\n+/* { dg-final { scan-assembler-not \"\\tmemcpy\" } } */\n+/* { dg-final { scan-assembler-times \"swl\" 8 } } */\n+/* { dg-final { scan-assembler-times \"swr\" 8 } } */\n+\n+/* Test that inline memcpy for hardware with swl, swr handles subword\n+   alignment and produces enough swl/swrs for mips32.  */\n+\n+#include <string.h>\n+\n+char c[40] __attribute__ ((aligned(2)));\n+\n+void\n+f1 ()\n+{\n+  memcpy (c, \"1234567890QWERTYUIOPASDFGHJKLZXCVBNM\", 32);\n+}"}, {"sha": "0e7a22e8a33cb19bacee10d2adf2130dd5e48145", "filename": "gcc/testsuite/gcc.target/mips/inline-memcpy-4.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58df0b91cbca6814b243256bb7900341b5316d14/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finline-memcpy-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58df0b91cbca6814b243256bb7900341b5316d14/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finline-memcpy-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finline-memcpy-4.c?ref=58df0b91cbca6814b243256bb7900341b5316d14", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-options \"-fno-common isa_rev<=5 -mabi=64\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" \"-Os\"} { \"\" } } */\n+/* { dg-final { scan-assembler-not \"\\tmemcpy\" } } */\n+/* { dg-final { scan-assembler-times \"sdl\" 4 } } */\n+/* { dg-final { scan-assembler-times \"sdr\" 4 } } */\n+\n+/* Test that inline memcpy for hardware with sdl, sdr handles subword\n+   alignment and produces enough sdl/sdrs on n64.  */\n+\n+#include <string.h>\n+\n+char c[40] __attribute__ ((aligned(2)));\n+\n+void\n+f1 ()\n+{\n+  memcpy (c, \"1234567890QWERTYUIOPASDFGHJKLZXCVBNM\", 32);\n+}"}, {"sha": "1b9fa16b2a74be743e4c1f4b916ec37da144d869", "filename": "gcc/testsuite/gcc.target/mips/inline-memcpy-5.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58df0b91cbca6814b243256bb7900341b5316d14/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finline-memcpy-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58df0b91cbca6814b243256bb7900341b5316d14/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finline-memcpy-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finline-memcpy-5.c?ref=58df0b91cbca6814b243256bb7900341b5316d14", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-options \"-fno-common isa_rev<=5 -mabi=n32\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" \"-Os\"} { \"\" } } */\n+/* { dg-final { scan-assembler-not \"\\tmemcpy\" } } */\n+/* { dg-final { scan-assembler-times \"sdl\" 4 } } */\n+/* { dg-final { scan-assembler-times \"sdr\" 4 } } */\n+\n+/* Test that inline memcpy for hardware with sdl, sdr handles subword\n+   alignment and produces enough sdr/sdls on n32.  */\n+\n+#include <string.h>\n+\n+char c[40] __attribute__ ((aligned(2)));\n+\n+void\n+f1 ()\n+{\n+  memcpy (c, \"1234567890QWERTYUIOPASDFGHJKLZXCVBNM\", 32);\n+}"}]}