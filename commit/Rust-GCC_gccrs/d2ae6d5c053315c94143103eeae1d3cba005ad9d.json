{"sha": "d2ae6d5c053315c94143103eeae1d3cba005ad9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJhZTZkNWMwNTMzMTVjOTQxNDMxMDNlZWFlMWQzY2JhMDA1YWQ5ZA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-08-03T09:38:44Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-08-03T11:27:41Z"}, "message": "tree-optimization: Fix typos in comments\n\nThe only two changes which aren't obvious are s/dirified/specified/ and\ns/edirially/especially/ which appear to be caused by a s/spec/dir/ edit\nthat went too far.\n\ngcc/ChangeLog:\n\n\t* gimple-ssa-sprintf.c: Fix typos in comments.", "tree": {"sha": "b99c2a6228c4f175f35f015b179d4ff92ad60225", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b99c2a6228c4f175f35f015b179d4ff92ad60225"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2ae6d5c053315c94143103eeae1d3cba005ad9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2ae6d5c053315c94143103eeae1d3cba005ad9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2ae6d5c053315c94143103eeae1d3cba005ad9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2ae6d5c053315c94143103eeae1d3cba005ad9d/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "341573406b392f4d57e052ce22f80e85a7c479e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/341573406b392f4d57e052ce22f80e85a7c479e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/341573406b392f4d57e052ce22f80e85a7c479e9"}], "stats": {"total": 32, "additions": 16, "deletions": 16}, "files": [{"sha": "3d77459d811eb60d1b1e436b773e0326866af37b", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2ae6d5c053315c94143103eeae1d3cba005ad9d/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2ae6d5c053315c94143103eeae1d3cba005ad9d/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=d2ae6d5c053315c94143103eeae1d3cba005ad9d", "patch": "@@ -29,7 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n    For all functions (bounded or not) the pass uses the size of the\n    destination object.  That means that it will diagnose calls to\n    snprintf not on the basis of the size specified by the function's\n-   second argument but rathger on the basis of the size the first\n+   second argument but rather on the basis of the size the first\n    argument points to (if possible).  For bound-checking built-ins\n    like __builtin___snprintf_chk the pass uses the size typically\n    determined by __builtin_object_size and passed to the built-in\n@@ -39,7 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n    including character, integer, floating point, pointer, and strings,\n    with the standard C flags, widths, and precisions.  For integers\n    and strings it computes the length of output itself.  For floating\n-   point it uses MPFR to fornmat known constants with up and down\n+   point it uses MPFR to format known constants with up and down\n    rounding and uses the resulting range of output lengths.  For\n    strings it uses the length of string literals and the sizes of\n    character arrays that a character pointer may point to as a bound\n@@ -123,7 +123,7 @@ struct result_range\n      that result in a range of bytes [MIN, MAX], LIKELY is somewhere\n      in that range.  */\n   unsigned HOST_WIDE_INT likely;\n-  /* In rare cases (e.g., for nultibyte characters) UNLIKELY gives\n+  /* In rare cases (e.g., for multibyte characters) UNLIKELY gives\n      the worst cases maximum result of a directive.  In most cases\n      UNLIKELY == MAX.  UNLIKELY is used to control the return value\n      optimization but not in diagnostics.  */\n@@ -599,7 +599,7 @@ struct directive\n      returns the formatting result.  */\n   fmtresult (*fmtfunc) (const directive &, tree, const vr_values *);\n \n-  /* Return True when a the format flag CHR has been used.  */\n+  /* Return True when the format flag CHR has been used.  */\n   bool get_flag (char chr) const\n   {\n     unsigned char c = chr & 0xff;\n@@ -1595,7 +1595,7 @@ format_floating_max (tree type, char spec, HOST_WIDE_INT prec)\n   if (MODE_COMPOSITE_P (mode))\n     mode = DFmode;\n \n-  /* Get the real type format desription for the target.  */\n+  /* Get the real type format description for the target.  */\n   const real_format *rfmt = REAL_MODE_FORMAT (mode);\n   REAL_VALUE_TYPE rv;\n \n@@ -1891,7 +1891,7 @@ format_floating (const directive &dir, tree arg, const vr_values *)\n   /* The minimum and maximum number of bytes produced by the directive.  */\n   fmtresult res;\n \n-  /* Get the real type format desription for the target.  */\n+  /* Get the real type format description for the target.  */\n   const REAL_VALUE_TYPE *rvp = TREE_REAL_CST_PTR (arg);\n   const real_format *rfmt = REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (arg)));\n \n@@ -1948,8 +1948,8 @@ format_floating (const directive &dir, tree arg, const vr_values *)\n       {\n \t/* Convert the GCC real value representation with the precision\n \t   of the real type to the mpfr_t format rounding down in the\n-\t   first iteration that computes the minimm and up in the second\n-\t   that computes the maximum.  This order is arbibtrary because\n+\t   first iteration that computes the minimum and up in the second\n+\t   that computes the maximum.  This order is arbitrary because\n \t   rounding in either direction can result in longer output.  */\n \tmpfr_t mpfrval;\n \tmpfr_init2 (mpfrval, rfmt->p);\n@@ -1982,7 +1982,7 @@ format_floating (const directive &dir, tree arg, const vr_values *)\n \n   /* For the same floating point constant, unless width or precision\n      is unknown, use the longer output as the likely maximum since\n-     with round to nearest either is equally likely.  Otheriwse, when\n+     with round to nearest either is equally likely.  Otherwise, when\n      precision is unknown, use the greater of the minimum and 3 as\n      the likely output (for \"0.0\" since zero precision is unlikely).  */\n   if (res.knownrange)\n@@ -2075,7 +2075,7 @@ get_string_length (tree str, unsigned eltsize, const vr_values *vr)\n   /* Set the max/likely counters to unbounded when a minimum is known\n      but the maximum length isn't bounded.  This implies that STR is\n      a conditional expression involving a string of known length and\n-     and an expression of unknown/unbounded length.  */\n+     an expression of unknown/unbounded length.  */\n   if (min\n       && (unsigned HOST_WIDE_INT)min < HOST_WIDE_INT_M1U\n       && unbounded)\n@@ -2183,7 +2183,7 @@ format_character (const directive &dir, tree arg, const vr_values *vr_values)\n     }\n   else\n     {\n-      /* A plain '%c' directive.  Its ouput is exactly 1.  */\n+      /* A plain '%c' directive.  Its output is exactly 1.  */\n       res.range.min = res.range.max = 1;\n       res.range.likely = res.range.unlikely = 1;\n       res.knownrange = true;\n@@ -2536,7 +2536,7 @@ format_string (const directive &dir, tree arg, const vr_values *vr_values)\n \t one of a number of strings of known length or an unknown string)\n \t the minimum number of characters is lesser of PRECISION[0] and\n \t the length of the shortest known string or zero, and the maximum\n-\t is the lessser of the length of the longest known string or\n+\t is the lesser of the length of the longest known string or\n \t PTRDIFF_MAX and PRECISION[1].  The likely length is either\n \t the minimum at level 1 and the greater of the minimum and 1\n \t at level 2.  This result is adjust upward for width (if it's\n@@ -2992,8 +2992,8 @@ maybe_warn (substring_loc &dirloc, location_t argloc,\n }\n \n /* Given the formatting result described by RES and NAVAIL, the number\n-   of available in the destination, return the range of bytes remaining\n-   in the destination.  */\n+   of available bytes in the destination, return the range of bytes\n+   remaining in the destination.  */\n \n static inline result_range\n bytes_remaining (unsigned HOST_WIDE_INT navail, const format_result &res)\n@@ -3586,7 +3586,7 @@ parse_directive (call_info &info,\n       else\n \t{\n \t  /* The decimal precision or the asterisk are optional.\n-\t     When neither is dirified it's taken to be zero.  */\n+\t     When neither is specified it's taken to be zero.  */\n \t  precision = 0;\n \t}\n     }\n@@ -3671,7 +3671,7 @@ parse_directive (call_info &info,\n \n     case 'p':\n       /* The %p output is implementation-defined.  It's possible\n-\t to determine this format but due to extensions (edirially\n+\t to determine this format but due to extensions (especially\n \t those of the Linux kernel -- see bug 78512) the first %p\n \t in the format string disables any further processing.  */\n       return false;"}]}