{"sha": "74dd418cb82d8fc95d91f1c776cd54ce33773fa3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRkZDQxOGNiODJkOGZjOTVkOTFmMWM3NzZjZDU0Y2UzMzc3M2ZhMw==", "commit": {"author": {"name": "Rafael Avila de Espindola", "email": "espindola@google.com", "date": "2008-03-04T17:43:52Z"}, "committer": {"name": "Rafael Espindola", "email": "espindola@gcc.gnu.org", "date": "2008-03-04T17:43:52Z"}, "message": "fold-const.c (tree_unary_nonzero_warnv_p): New.\n\n2008-03-04  Rafael Espindola  <espindola@google.com>\n\n\t   * fold-const.c (tree_unary_nonzero_warnv_p): New.\n\t   (tree_binary_nonzero_warnv_p): New.\n\t   (tree_single_nonzero_warnv_p): New.\n\t   (tree_expr_nonzero_warnv_p): Redefine using the new functions.\n\nFrom-SVN: r132866", "tree": {"sha": "7e32c5a6d28fa21aa75ecfb7fe02cdbfd7a6dc86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e32c5a6d28fa21aa75ecfb7fe02cdbfd7a6dc86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74dd418cb82d8fc95d91f1c776cd54ce33773fa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74dd418cb82d8fc95d91f1c776cd54ce33773fa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74dd418cb82d8fc95d91f1c776cd54ce33773fa3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74dd418cb82d8fc95d91f1c776cd54ce33773fa3/comments", "author": null, "committer": null, "parents": [{"sha": "5ce0e197751a14209bb632fb8b5ed6375376de38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ce0e197751a14209bb632fb8b5ed6375376de38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ce0e197751a14209bb632fb8b5ed6375376de38"}], "stats": {"total": 268, "additions": 194, "deletions": 74}, "files": [{"sha": "f9d861a06a6ea2844e89b6ac134225f5b04bbed0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74dd418cb82d8fc95d91f1c776cd54ce33773fa3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74dd418cb82d8fc95d91f1c776cd54ce33773fa3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=74dd418cb82d8fc95d91f1c776cd54ce33773fa3", "patch": "@@ -1,3 +1,10 @@\n+2008-03-04  Rafael Espindola  <espindola@google.com>\n+\n+\t* fold-const.c (tree_unary_nonzero_warnv_p): New.\n+\t(tree_binary_nonzero_warnv_p): New.\n+\t(tree_single_nonzero_warnv_p): New.\n+\t(tree_expr_nonzero_warnv_p): Redefine using the new functions.\n+\n 2008-03-04  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR middle-end/35456"}, {"sha": "503da6a7d498390849720742157aacc5524713d0", "filename": "gcc/fold-const.c", "status": "modified", "additions": 187, "deletions": 74, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74dd418cb82d8fc95d91f1c776cd54ce33773fa3/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74dd418cb82d8fc95d91f1c776cd54ce33773fa3/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=74dd418cb82d8fc95d91f1c776cd54ce33773fa3", "patch": "@@ -14409,67 +14409,93 @@ tree_expr_nonnegative_p (tree t)\n   return ret;\n }\n \n-/* Return true when T is an address and is known to be nonzero.\n+\n+/* Return true when (CODE OP0) is an address and is known to be nonzero.\n    For floating point we further ensure that T is not denormal.\n    Similar logic is present in nonzero_address in rtlanal.h.\n \n    If the return value is based on the assumption that signed overflow\n    is undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't\n    change *STRICT_OVERFLOW_P.  */\n \n-bool\n-tree_expr_nonzero_warnv_p (tree t, bool *strict_overflow_p)\n+static bool\n+tree_unary_nonzero_warnv_p (enum tree_code code, tree type, tree op0,\n+\t\t\t\t bool *strict_overflow_p)\n {\n-  tree type = TREE_TYPE (t);\n-  bool sub_strict_overflow_p;\n+  switch (code)\n+    {\n+    case ABS_EXPR:\n+      return tree_expr_nonzero_warnv_p (op0,\n+\t\t\t\t\tstrict_overflow_p);\n \n-  /* Doing something useful for floating point would need more work.  */\n-  if (!INTEGRAL_TYPE_P (type) && !POINTER_TYPE_P (type))\n-    return false;\n+    case NOP_EXPR:\n+      {\n+\ttree inner_type = TREE_TYPE (op0);\n+\ttree outer_type = type;\n \n-  switch (TREE_CODE (t))\n-    {\n-    case SSA_NAME:\n-      /* Query VRP to see if it has recorded any information about\n-\t the range of this object.  */\n-      return ssa_name_nonzero_p (t);\n+\treturn (TYPE_PRECISION (outer_type) >= TYPE_PRECISION (inner_type)\n+\t\t&& tree_expr_nonzero_warnv_p (op0,\n+\t\t\t\t\t      strict_overflow_p));\n+      }\n+      break;\n \n-    case ABS_EXPR:\n-      return tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 0),\n+    case NON_LVALUE_EXPR:\n+      return tree_expr_nonzero_warnv_p (op0,\n \t\t\t\t\tstrict_overflow_p);\n \n-    case INTEGER_CST:\n-      return !integer_zerop (t);\n+    default:\n+      break;\n+  }\n+\n+  return false;\n+}\n+\n+/* Return true when (CODE OP0 OP1) is an address and is known to be nonzero.\n+   For floating point we further ensure that T is not denormal.\n+   Similar logic is present in nonzero_address in rtlanal.h.\n+\n+   If the return value is based on the assumption that signed overflow\n+   is undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't\n+   change *STRICT_OVERFLOW_P.  */\n \n+static bool\n+tree_binary_nonzero_warnv_p (enum tree_code code,\n+\t\t\t     tree type,\n+\t\t\t     tree op0,\n+\t\t\t     tree op1, bool *strict_overflow_p)\n+{\n+  bool sub_strict_overflow_p;\n+  switch (code)\n+    {\n     case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n       if (TYPE_OVERFLOW_UNDEFINED (type))\n \t{\n \t  /* With the presence of negative values it is hard\n \t     to say something.  */\n \t  sub_strict_overflow_p = false;\n-\t  if (!tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 0),\n+\t  if (!tree_expr_nonnegative_warnv_p (op0,\n \t\t\t\t\t      &sub_strict_overflow_p)\n-\t      || !tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 1),\n+\t      || !tree_expr_nonnegative_warnv_p (op1,\n \t\t\t\t\t\t &sub_strict_overflow_p))\n \t    return false;\n \t  /* One of operands must be positive and the other non-negative.  */\n \t  /* We don't set *STRICT_OVERFLOW_P here: even if this value\n \t     overflows, on a twos-complement machine the sum of two\n \t     nonnegative numbers can never be zero.  */\n-\t  return (tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 0),\n+\t  return (tree_expr_nonzero_warnv_p (op0,\n \t\t\t\t\t     strict_overflow_p)\n-\t          || tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 1),\n+\t\t  || tree_expr_nonzero_warnv_p (op1,\n \t\t\t\t\t\tstrict_overflow_p));\n \t}\n       break;\n \n     case MULT_EXPR:\n       if (TYPE_OVERFLOW_UNDEFINED (type))\n \t{\n-\t  if (tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 0),\n+\t  if (tree_expr_nonzero_warnv_p (op0,\n \t\t\t\t\t strict_overflow_p)\n-\t      && tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 1),\n+\t      && tree_expr_nonzero_warnv_p (op1,\n \t\t\t\t\t    strict_overflow_p))\n \t    {\n \t      *strict_overflow_p = true;\n@@ -14478,18 +14504,83 @@ tree_expr_nonzero_warnv_p (tree t, bool *strict_overflow_p)\n \t}\n       break;\n \n-    case NOP_EXPR:\n-      {\n-\ttree inner_type = TREE_TYPE (TREE_OPERAND (t, 0));\n-\ttree outer_type = TREE_TYPE (t);\n+    case MIN_EXPR:\n+      sub_strict_overflow_p = false;\n+      if (tree_expr_nonzero_warnv_p (op0,\n+\t\t\t\t     &sub_strict_overflow_p)\n+\t  && tree_expr_nonzero_warnv_p (op1,\n+\t\t\t\t\t&sub_strict_overflow_p))\n+\t{\n+\t  if (sub_strict_overflow_p)\n+\t    *strict_overflow_p = true;\n+\t}\n+      break;\n \n-\treturn (TYPE_PRECISION (outer_type) >= TYPE_PRECISION (inner_type)\n-\t\t&& tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 0),\n-\t\t\t\t\t      strict_overflow_p));\n-      }\n+    case MAX_EXPR:\n+      sub_strict_overflow_p = false;\n+      if (tree_expr_nonzero_warnv_p (op0,\n+\t\t\t\t     &sub_strict_overflow_p))\n+\t{\n+\t  if (sub_strict_overflow_p)\n+\t    *strict_overflow_p = true;\n+\n+\t  /* When both operands are nonzero, then MAX must be too.  */\n+\t  if (tree_expr_nonzero_warnv_p (op1,\n+\t\t\t\t\t strict_overflow_p))\n+\t    return true;\n+\n+\t  /* MAX where operand 0 is positive is positive.  */\n+\t  return tree_expr_nonnegative_warnv_p (op0,\n+\t\t\t\t\t       strict_overflow_p);\n+\t}\n+      /* MAX where operand 1 is positive is positive.  */\n+      else if (tree_expr_nonzero_warnv_p (op1,\n+\t\t\t\t\t  &sub_strict_overflow_p)\n+\t       && tree_expr_nonnegative_warnv_p (op1,\n+\t\t\t\t\t\t &sub_strict_overflow_p))\n+\t{\n+\t  if (sub_strict_overflow_p)\n+\t    *strict_overflow_p = true;\n+\t  return true;\n+\t}\n+      break;\n+\n+    case BIT_IOR_EXPR:\n+      return (tree_expr_nonzero_warnv_p (op1,\n+\t\t\t\t\t strict_overflow_p)\n+\t      || tree_expr_nonzero_warnv_p (op0,\n+\t\t\t\t\t    strict_overflow_p));\n+\n+    default:\n       break;\n+  }\n \n-   case ADDR_EXPR:\n+  return false;\n+}\n+\n+/* Return true when T is an address and is known to be nonzero.\n+   For floating point we further ensure that T is not denormal.\n+   Similar logic is present in nonzero_address in rtlanal.h.\n+\n+   If the return value is based on the assumption that signed overflow\n+   is undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't\n+   change *STRICT_OVERFLOW_P.  */\n+\n+static bool\n+tree_single_nonzero_warnv_p (tree t, bool *strict_overflow_p)\n+{\n+  bool sub_strict_overflow_p;\n+  switch (TREE_CODE (t))\n+    {\n+    case SSA_NAME:\n+      /* Query VRP to see if it has recorded any information about\n+\t the range of this object.  */\n+      return ssa_name_nonzero_p (t);\n+\n+    case INTEGER_CST:\n+      return !integer_zerop (t);\n+\n+    case ADDR_EXPR:\n       {\n \ttree base = get_base_address (TREE_OPERAND (t, 0));\n \n@@ -14520,46 +14611,75 @@ tree_expr_nonzero_warnv_p (tree t, bool *strict_overflow_p)\n \t}\n       break;\n \n-    case MIN_EXPR:\n-      sub_strict_overflow_p = false;\n-      if (tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 0),\n-\t\t\t\t     &sub_strict_overflow_p)\n-\t  && tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 1),\n-\t\t\t\t\t&sub_strict_overflow_p))\n-\t{\n-\t  if (sub_strict_overflow_p)\n-\t    *strict_overflow_p = true;\n-\t}\n+    default:\n       break;\n+    }\n+  return false;\n+}\n \n-    case MAX_EXPR:\n-      sub_strict_overflow_p = false;\n-      if (tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 0),\n-\t\t\t\t     &sub_strict_overflow_p))\n-\t{\n-\t  if (sub_strict_overflow_p)\n-\t    *strict_overflow_p = true;\n+/* Return true when T is an address and is known to be nonzero.\n+   For floating point we further ensure that T is not denormal.\n+   Similar logic is present in nonzero_address in rtlanal.h.\n \n-\t  /* When both operands are nonzero, then MAX must be too.  */\n-\t  if (tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 1),\n-\t\t\t\t\t strict_overflow_p))\n-\t    return true;\n+   If the return value is based on the assumption that signed overflow\n+   is undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't\n+   change *STRICT_OVERFLOW_P.  */\n \n-\t  /* MAX where operand 0 is positive is positive.  */\n-\t  return tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 0),\n+bool\n+tree_expr_nonzero_warnv_p (tree t, bool *strict_overflow_p)\n+{\n+  tree type = TREE_TYPE (t);\n+  enum tree_code code;\n+\n+  /* Doing something useful for floating point would need more work.  */\n+  if (!INTEGRAL_TYPE_P (type) && !POINTER_TYPE_P (type))\n+    return false;\n+\n+  code = TREE_CODE (t);\n+  switch (TREE_CODE_CLASS (code))\n+    {\n+    case tcc_unary:\n+      return tree_unary_nonzero_warnv_p (code, type, TREE_OPERAND (t, 0),\n+\t\t\t\t\t      strict_overflow_p);\n+    case tcc_binary:\n+    case tcc_comparison:\n+      return tree_binary_nonzero_warnv_p (code, type,\n+\t\t\t\t\t       TREE_OPERAND (t, 0),\n+\t\t\t\t\t       TREE_OPERAND (t, 1),\n \t\t\t\t\t       strict_overflow_p);\n-\t}\n-      /* MAX where operand 1 is positive is positive.  */\n-      else if (tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 1),\n-\t\t\t\t\t  &sub_strict_overflow_p)\n-\t       && tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 1),\n-\t\t\t\t\t\t &sub_strict_overflow_p))\n-\t{\n-\t  if (sub_strict_overflow_p)\n-\t    *strict_overflow_p = true;\n-\t  return true;\n-\t}\n+    case tcc_constant:\n+    case tcc_declaration:\n+    case tcc_reference:\n+      return tree_single_nonzero_warnv_p (t, strict_overflow_p);\n+\n+    default:\n       break;\n+    }\n+\n+  switch (code)\n+    {\n+    case TRUTH_NOT_EXPR:\n+      return tree_unary_nonzero_warnv_p (code, type, TREE_OPERAND (t, 0),\n+\t\t\t\t\t      strict_overflow_p);\n+\n+    case TRUTH_AND_EXPR:\n+    case TRUTH_OR_EXPR:\n+    case TRUTH_XOR_EXPR:\n+      return tree_binary_nonzero_warnv_p (code, type,\n+\t\t\t\t\t       TREE_OPERAND (t, 0),\n+\t\t\t\t\t       TREE_OPERAND (t, 1),\n+\t\t\t\t\t       strict_overflow_p);\n+\n+    case COND_EXPR:\n+    case CONSTRUCTOR:\n+    case OBJ_TYPE_REF:\n+    case ASSERT_EXPR:\n+    case ADDR_EXPR:\n+    case WITH_SIZE_EXPR:\n+    case EXC_PTR_EXPR:\n+    case SSA_NAME:\n+    case FILTER_EXPR:\n+      return tree_single_nonzero_warnv_p (t, strict_overflow_p);\n \n     case COMPOUND_EXPR:\n     case MODIFY_EXPR:\n@@ -14569,16 +14689,9 @@ tree_expr_nonzero_warnv_p (tree t, bool *strict_overflow_p)\n \t\t\t\t\tstrict_overflow_p);\n \n     case SAVE_EXPR:\n-    case NON_LVALUE_EXPR:\n       return tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 0),\n \t\t\t\t\tstrict_overflow_p);\n \n-    case BIT_IOR_EXPR:\n-      return (tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 1),\n-\t\t\t\t\tstrict_overflow_p)\n-\t      || tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 0),\n-\t\t\t\t\t    strict_overflow_p));\n-\n     case CALL_EXPR:\n       return alloca_call_p (t);\n "}]}