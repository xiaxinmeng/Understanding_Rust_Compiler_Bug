{"sha": "bd323ce58c27abf18de4c66cf7dfdba2a8d9e85b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQzMjNjZTU4YzI3YWJmMThkZTRjNjZjZjdkZmRiYTJhOGQ5ZTg1Yg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-06-12T11:36:34Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-06-12T11:36:34Z"}, "message": "expr.c (store_field): Do a block copy from BLKmode to BLKmode-like.\n\n\t* expr.c (store_field): Do a block copy from BLKmode to BLKmode-like.\n\t(get_inner_reference): Use BLKmode for byte-aligned BLKmode bitfields.\n\nFrom-SVN: r136699", "tree": {"sha": "8b62385d4dccde65201b9a345733145b0344648d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b62385d4dccde65201b9a345733145b0344648d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd323ce58c27abf18de4c66cf7dfdba2a8d9e85b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd323ce58c27abf18de4c66cf7dfdba2a8d9e85b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd323ce58c27abf18de4c66cf7dfdba2a8d9e85b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd323ce58c27abf18de4c66cf7dfdba2a8d9e85b/comments", "author": null, "committer": null, "parents": [{"sha": "b5a6bf2e7efa45182f8a730d0c8e845a313754c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5a6bf2e7efa45182f8a730d0c8e845a313754c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5a6bf2e7efa45182f8a730d0c8e845a313754c4"}], "stats": {"total": 59, "additions": 41, "deletions": 18}, "files": [{"sha": "58260bbaff5ffe138fde251b501711a2e24cc7aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd323ce58c27abf18de4c66cf7dfdba2a8d9e85b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd323ce58c27abf18de4c66cf7dfdba2a8d9e85b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd323ce58c27abf18de4c66cf7dfdba2a8d9e85b", "patch": "@@ -1,3 +1,8 @@\n+2008-06-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* expr.c (store_field): Do a block copy from BLKmode to BLKmode-like.\n+\t(get_inner_reference): Use BLKmode for byte-aligned BLKmode bitfields.\n+\n 2008-06-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/36506"}, {"sha": "2357170dd1619f780e1be658faddf562d5815b7b", "filename": "gcc/expr.c", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd323ce58c27abf18de4c66cf7dfdba2a8d9e85b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd323ce58c27abf18de4c66cf7dfdba2a8d9e85b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=bd323ce58c27abf18de4c66cf7dfdba2a8d9e85b", "patch": "@@ -5795,13 +5795,19 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t  && mode != TYPE_MODE (TREE_TYPE (exp)))\n \ttemp = convert_modes (mode, TYPE_MODE (TREE_TYPE (exp)), temp, 1);\n \n-      /* If the modes of TARGET and TEMP are both BLKmode, both\n+      /* If the modes of TEMP and TARGET are both BLKmode, both\n \t must be in memory and BITPOS must be aligned on a byte\n-\t boundary.  If so, we simply do a block copy.  */\n-      if (GET_MODE (target) == BLKmode && GET_MODE (temp) == BLKmode)\n+\t boundary.  If so, we simply do a block copy.  Likewise\n+\t for a BLKmode-like TARGET.  */\n+      if (GET_MODE (temp) == BLKmode\n+\t  && (GET_MODE (target) == BLKmode\n+\t      || (MEM_P (target)\n+\t\t  && GET_MODE_CLASS (GET_MODE (target)) == MODE_INT\n+\t\t  && (bitpos % BITS_PER_UNIT) == 0\n+\t\t  && (bitsize % BITS_PER_UNIT) == 0)))\n \t{\n \t  gcc_assert (MEM_P (target) && MEM_P (temp)\n-\t\t      && !(bitpos % BITS_PER_UNIT));\n+\t\t      && (bitpos % BITS_PER_UNIT) == 0);\n \n \t  target = adjust_address (target, VOIDmode, bitpos / BITS_PER_UNIT);\n \t  emit_block_move (target, temp,\n@@ -5847,12 +5853,11 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n    If any of the extraction expressions is volatile,\n    we store 1 in *PVOLATILEP.  Otherwise we don't change that.\n \n-   If the field is a bit-field, *PMODE is set to VOIDmode.  Otherwise, it\n-   is a mode that can be used to access the field.  In that case, *PBITSIZE\n-   is redundant.\n+   If the field is a non-BLKmode bit-field, *PMODE is set to VOIDmode.\n+   Otherwise, it is a mode that can be used to access the field.\n \n    If the field describes a variable-sized object, *PMODE is set to\n-   VOIDmode and *PBITSIZE is set to -1.  An access cannot be made in\n+   BLKmode and *PBITSIZE is set to -1.  An access cannot be made in\n    this case, but the address of the object can be found.\n \n    If KEEP_ALIGNING is true and the target is STRICT_ALIGNMENT, we don't\n@@ -5877,18 +5882,22 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n {\n   tree size_tree = 0;\n   enum machine_mode mode = VOIDmode;\n+  bool blkmode_bitfield = false;\n   tree offset = size_zero_node;\n   tree bit_offset = bitsize_zero_node;\n \n   /* First get the mode, signedness, and size.  We do this from just the\n      outermost expression.  */\n   if (TREE_CODE (exp) == COMPONENT_REF)\n     {\n-      size_tree = DECL_SIZE (TREE_OPERAND (exp, 1));\n-      if (! DECL_BIT_FIELD (TREE_OPERAND (exp, 1)))\n-\tmode = DECL_MODE (TREE_OPERAND (exp, 1));\n+      tree field = TREE_OPERAND (exp, 1);\n+      size_tree = DECL_SIZE (field);\n+      if (!DECL_BIT_FIELD (field))\n+\tmode = DECL_MODE (field);\n+      else if (DECL_MODE (field) == BLKmode)\n+\tblkmode_bitfield = true;\n \n-      *punsignedp = DECL_UNSIGNED (TREE_OPERAND (exp, 1));\n+      *punsignedp = DECL_UNSIGNED (field);\n     }\n   else if (TREE_CODE (exp) == BIT_FIELD_REF)\n     {\n@@ -5922,8 +5931,6 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n \t*pbitsize = tree_low_cst (size_tree, 1);\n     }\n \n-  *pmode = mode;\n-\n   /* Compute cumulative bit-offset for nested component-refs and array-refs,\n      and find the ultimate containing object.  */\n   while (1)\n@@ -6018,14 +6025,25 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n       if (double_int_fits_in_shwi_p (tem))\n \t{\n \t  *pbitpos = double_int_to_shwi (tem);\n-\t  *poffset = NULL_TREE;\n-\t  return exp;\n+\t  *poffset = offset = NULL_TREE;\n \t}\n     }\n \n   /* Otherwise, split it up.  */\n-  *pbitpos = tree_low_cst (bit_offset, 0);\n-  *poffset = offset;\n+  if (offset)\n+    {\n+      *pbitpos = tree_low_cst (bit_offset, 0);\n+      *poffset = offset;\n+    }\n+\n+  /* We can use BLKmode for a byte-aligned BLKmode bitfield.  */\n+  if (mode == VOIDmode\n+      && blkmode_bitfield\n+      && (*pbitpos % BITS_PER_UNIT) == 0\n+      && (*pbitsize % BITS_PER_UNIT) == 0)\n+    *pmode = BLKmode;\n+  else\n+    *pmode = mode;\n \n   return exp;\n }"}]}