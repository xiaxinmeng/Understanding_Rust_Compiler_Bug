{"sha": "18cd8a03f87fb12895109b72832cbdcc27b39c69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThjZDhhMDNmODdmYjEyODk1MTA5YjcyODMyY2JkY2MyN2IzOWM2OQ==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2006-03-01T22:35:42Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2006-03-01T22:35:42Z"}, "message": "tree.def (SYMBOL_MEMORY_TAG): Rename from TYPE_MEMORY_TAG.\n\n\n\t* tree.def (SYMBOL_MEMORY_TAG): Rename from TYPE_MEMORY_TAG.\n\tUpdate all users.\n\t* tree-pass.h (PROP_smt_usage): Rename from PROP_tmt_usage.\n\tUpdate all users.\n\t(TODO_update_smt_usage): Rename from TODO_update_tmt_usage.\n\tUpdate all users.\n\t* tree.h (SMT_USED_ALONE): Rename from TMT_USED_ALONE.\n\tUpdate all users.\n\t* tree-flow.h (struct var_ann_d): Rename field 'type_mem_tag'\n\tto 'symbol_mem_tag'.\n\tUpdate all users.\n\t* doc/tree-ssa.texi: Update documentation to reflect TMT->SMT\n\trename.\n\nFrom-SVN: r111617", "tree": {"sha": "01a72a7a29f8e1046cda441db6c683b0feeb510d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01a72a7a29f8e1046cda441db6c683b0feeb510d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18cd8a03f87fb12895109b72832cbdcc27b39c69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18cd8a03f87fb12895109b72832cbdcc27b39c69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18cd8a03f87fb12895109b72832cbdcc27b39c69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18cd8a03f87fb12895109b72832cbdcc27b39c69/comments", "author": null, "committer": null, "parents": [{"sha": "61321991ff5f055015750ddf36444705b9921464", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61321991ff5f055015750ddf36444705b9921464", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61321991ff5f055015750ddf36444705b9921464"}], "stats": {"total": 483, "additions": 256, "deletions": 227}, "files": [{"sha": "e2ba6d7f1eb8241d887dc389ed9af7e68f10aca6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -1,3 +1,19 @@\n+2006-03-01  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree.def (SYMBOL_MEMORY_TAG): Rename from TYPE_MEMORY_TAG.\n+\tUpdate all users.\n+\t* tree-pass.h (PROP_smt_usage): Rename from PROP_tmt_usage.\n+\tUpdate all users.\n+\t(TODO_update_smt_usage): Rename from TODO_update_tmt_usage.\n+\tUpdate all users.\n+\t* tree.h (SMT_USED_ALONE): Rename from TMT_USED_ALONE.\n+\tUpdate all users.\n+\t* tree-flow.h (struct var_ann_d): Rename field 'type_mem_tag'\n+\tto 'symbol_mem_tag'.\n+\tUpdate all users.\n+\t* doc/tree-ssa.texi: Update documentation to reflect TMT->SMT\n+\trename.\n+\n 2006-03-01  Roger Sayle  <roger@eyesopen.com>\n \n \t* builtins.c (fold_builtin_copysign): Delete unreachable code.\n@@ -25,7 +41,7 @@\n \t* config/darwin.h (TARGET_ASM_OUTPUT_ANCHOR): Define.\n \n 2006-03-01  Daniel Berlin  <dberlin@dberlin.org>\n- \n+\n \tFix PR tree-optimization/26443\n \t* tree-vrp.c (pass_vrp): Add TODO_update_tmt_usage\n \tto todo and PROP_tmt_usage to properties_destroyed."}, {"sha": "e2a657a3a13838735a496b06315227ed0ed798be", "filename": "gcc/doc/tree-ssa.texi", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Fdoc%2Ftree-ssa.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Fdoc%2Ftree-ssa.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftree-ssa.texi?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -1506,7 +1506,7 @@ int bar (void)\n @}\n @end smallexample\n \n-If you copy the type tag for a variable for some reason, you probably\n+If you copy the symbol tag for a variable for some reason, you probably\n also want to copy the subvariables for that variable.\n \n @item\tPoints-to and escape analysis.\n@@ -1540,12 +1540,12 @@ the variables pointed-to by P_i (and its memory tag) also escape.\n \n We have two classes of memory tags.  Memory tags associated with\n the pointed-to data type of the pointers in the program.  These\n-tags are called ``type memory tag'' (TMT)@.  The other class are\n+tags are called ``symbol memory tag'' (SMT)@.  The other class are\n those associated with SSA_NAMEs, called ``name memory tag'' (NMT)@.\n The basic idea is that when adding operands for an INDIRECT_REF\n *P_i, we will first check whether P_i has a name tag, if it does\n we use it, because that will have more precise aliasing\n-information.  Otherwise, we use the standard type tag.\n+information.  Otherwise, we use the standard symbol tag.\n \n In this phase, we go through all the pointers we found in\n points-to analysis and create alias sets for the name memory tags\n@@ -1555,11 +1555,11 @@ call-clobbered the variables it points to and its tag.\n \n @item\tCompute flow-insensitive aliases\n \n-This pass will compare the alias set of every type memory tag and\n-every addressable variable found in the program.  Given a type\n-memory tag TMT and an addressable variable V@.  If the alias sets\n-of TMT and V conflict (as computed by may_alias_p), then V is\n-marked as an alias tag and added to the alias set of TMT@.\n+This pass will compare the alias set of every symbol memory tag and\n+every addressable variable found in the program.  Given a symbol\n+memory tag SMT and an addressable variable V@.  If the alias sets\n+of SMT and V conflict (as computed by may_alias_p), then V is\n+marked as an alias tag and added to the alias set of SMT@.\n @end enumerate\n \n For instance, consider the following function:\n@@ -1581,7 +1581,7 @@ foo (int i)\n @}\n @end smallexample\n \n-After aliasing analysis has finished, the type memory tag for\n+After aliasing analysis has finished, the symbol memory tag for\n pointer @code{p} will have two aliases, namely variables @code{a} and\n @code{b}.\n Every time pointer @code{p} is dereferenced, we want to mark the"}, {"sha": "0babab79bb8a188775dc655b5e54f2a6cf02bff3", "filename": "gcc/passes.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -718,8 +718,8 @@ execute_todo (unsigned int flags)\n   if (!flags)\n     return;\n   \n-  /* Always recalculate TMT usage before doing anything else.  */\n-  if (flags & TODO_update_tmt_usage)\n+  /* Always recalculate SMT usage before doing anything else.  */\n+  if (flags & TODO_update_smt_usage)\n     recalculate_used_alone ();\n \n   /* Always cleanup the CFG before trying to update SSA .  */\n@@ -825,7 +825,7 @@ execute_one_pass (struct tree_opt_pass *pass)\n   gcc_assert ((curr_properties & pass->properties_required)\n \t      == pass->properties_required);\n \n-  if (pass->properties_destroyed & PROP_tmt_usage)\n+  if (pass->properties_destroyed & PROP_smt_usage)\n     updating_used_alone = true;\n \n   /* If a dump file name is present, open it if enabled.  */\n@@ -894,7 +894,7 @@ execute_one_pass (struct tree_opt_pass *pass)\n       dump_file = NULL;\n     }\n \n-  if (pass->properties_destroyed & PROP_tmt_usage)\n+  if (pass->properties_destroyed & PROP_smt_usage)\n     updating_used_alone = false;\n \n   return true;"}, {"sha": "c7cb5d45352353b8c6e7709d413690b34da02dde", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -129,9 +129,10 @@ static struct data_reference * init_data_ref (tree, tree, tree, tree, bool,\n \t\t\t\t\t      struct ptr_info_def *,\n \t\t\t\t\t      enum  data_ref_type);\n \n+\n /* Determine if PTR and DECL may alias, the result is put in ALIASED.\n-   Return FALSE if there is no type memory tag for PTR.\n-*/\n+   Return FALSE if there is no symbol memory tag for PTR.  */\n+\n static bool\n ptr_decl_may_alias_p (tree ptr, tree decl, \n \t\t      struct data_reference *ptr_dr, \n@@ -141,7 +142,7 @@ ptr_decl_may_alias_p (tree ptr, tree decl,\n    \n   gcc_assert (TREE_CODE (ptr) == SSA_NAME && DECL_P (decl));\n \n-  tag = get_var_ann (SSA_NAME_VAR (ptr))->type_mem_tag;\n+  tag = get_var_ann (SSA_NAME_VAR (ptr))->symbol_mem_tag;\n   if (!tag)\n     tag = DR_MEMTAG (ptr_dr);\n   if (!tag)\n@@ -153,8 +154,8 @@ ptr_decl_may_alias_p (tree ptr, tree decl,\n \n \n /* Determine if two pointers may alias, the result is put in ALIASED.\n-   Return FALSE if there is no type memory tag for one of the pointers.\n-*/\n+   Return FALSE if there is no symbol memory tag for one of the pointers.  */\n+\n static bool\n ptr_ptr_may_alias_p (tree ptr_a, tree ptr_b, \n \t\t     struct data_reference *dra, \n@@ -163,12 +164,12 @@ ptr_ptr_may_alias_p (tree ptr_a, tree ptr_b,\n {  \n   tree tag_a, tag_b;\n \n-  tag_a = get_var_ann (SSA_NAME_VAR (ptr_a))->type_mem_tag;\n+  tag_a = get_var_ann (SSA_NAME_VAR (ptr_a))->symbol_mem_tag;\n   if (!tag_a)\n     tag_a = DR_MEMTAG (dra);\n   if (!tag_a)\n     return false;\n-  tag_b = get_var_ann (SSA_NAME_VAR (ptr_b))->type_mem_tag;\n+  tag_b = get_var_ann (SSA_NAME_VAR (ptr_b))->symbol_mem_tag;\n   if (!tag_b)\n     tag_b = DR_MEMTAG (drb);\n   if (!tag_b)\n@@ -179,8 +180,8 @@ ptr_ptr_may_alias_p (tree ptr_a, tree ptr_b,\n \n \n /* Determine if BASE_A and BASE_B may alias, the result is put in ALIASED.\n-   Return FALSE if there is no type memory tag for one of the symbols.\n-*/\n+   Return FALSE if there is no symbol memory tag for one of the symbols.  */\n+\n static bool\n may_alias_p (tree base_a, tree base_b,\n \t     struct data_reference *dra,\n@@ -1712,10 +1713,10 @@ object_analysis (tree memref, tree stmt, bool is_read,\n       switch (TREE_CODE (base_address))\n \t{\n \tcase SSA_NAME:\n-\t  *memtag = get_var_ann (SSA_NAME_VAR (base_address))->type_mem_tag;\n+\t  *memtag = get_var_ann (SSA_NAME_VAR (base_address))->symbol_mem_tag;\n \t  if (!(*memtag) && TREE_CODE (TREE_OPERAND (memref, 0)) == SSA_NAME)\n \t    *memtag = get_var_ann (\n-\t\t      SSA_NAME_VAR (TREE_OPERAND (memref, 0)))->type_mem_tag;\n+\t\t      SSA_NAME_VAR (TREE_OPERAND (memref, 0)))->symbol_mem_tag;\n \t  break;\n \tcase ADDR_EXPR:\n \t  *memtag = TREE_OPERAND (base_address, 0);"}, {"sha": "9c2ddcfaf1f1d49a4d879f19779177a3f385097f", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -344,10 +344,10 @@ dump_variable (FILE *file, tree var)\n   fprintf (file, \", \");\n   print_generic_expr (file, TREE_TYPE (var), dump_flags);\n \n-  if (ann && ann->type_mem_tag)\n+  if (ann && ann->symbol_mem_tag)\n     {\n-      fprintf (file, \", type memory tag: \");\n-      print_generic_expr (file, ann->type_mem_tag, dump_flags);\n+      fprintf (file, \", symbol memory tag: \");\n+      print_generic_expr (file, ann->symbol_mem_tag, dump_flags);\n     }\n \n   if (ann && ann->is_aliased)"}, {"sha": "42c019f40623cf0790e18fd179d6acd07c2486bc", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -478,7 +478,7 @@ dequeue_and_dump (dump_info_p di)\n       dump_child (\"cnst\", DECL_INITIAL (t));\n       break;\n       \n-    case TYPE_MEMORY_TAG:\n+    case SYMBOL_MEMORY_TAG:\n     case NAME_MEMORY_TAG:\n     case STRUCT_FIELD_TAG:\n       break;"}, {"sha": "1aad2727f39d9bbdf158c4e2d19e5dd433fac8ae", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -185,10 +185,10 @@ struct var_ann_d GTY(())\n   unsigned in_v_may_def_list : 1;\n \n   /* An artificial variable representing the memory location pointed-to by\n-     all the pointers that TBAA (type-based alias analysis) considers\n-     to be aliased.  If the variable is not a pointer or if it is never\n-     dereferenced, this must be NULL.  */\n-  tree type_mem_tag;\n+     all the pointer symbols that flow-insensitive alias analysis\n+     (mostly type-based) considers to be aliased.  If the variable is\n+     not a pointer or if it is never dereferenced, this must be NULL.  */\n+  tree symbol_mem_tag;\n \n   /* Variables that may alias this variable.  */\n   VEC(tree, gc) *may_aliases;"}, {"sha": "558cedd22fc3237bd57f2131f3c36bedc660c3c8", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -175,7 +175,7 @@ create_temp (tree t)\n   /* add_referenced_tmp_var will create the annotation and set up some\n      of the flags in the annotation.  However, some flags we need to\n      inherit from our original variable.  */\n-  var_ann (tmp)->type_mem_tag = var_ann (t)->type_mem_tag;\n+  var_ann (tmp)->symbol_mem_tag = var_ann (t)->symbol_mem_tag;\n   if (is_call_clobbered (t))\n     mark_call_clobbered (tmp, var_ann (t)->escape_mask);\n "}, {"sha": "0a1a354386639710fc98d1391468fa7352efb6f7", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -150,7 +150,7 @@ struct dump_file_info\n #define PROP_rtl\t\t(1 << 8)\n #define PROP_alias\t\t(1 << 9)\n #define PROP_gimple_lomp\t(1 << 10)\t/* lowered OpenMP directives */\n-#define PROP_tmt_usage          (1 << 11)       /* which TMT's are\n+#define PROP_smt_usage          (1 << 11)       /* which SMT's are\n \t\t\t\t\t\t   used alone.  */\n \n #define PROP_trees \\\n@@ -212,9 +212,9 @@ struct dump_file_info\n    for the passes that are handed to register_dump_files.  */\n #define TODO_set_props\t\t\t(1 << 12)\n \n-/* Set by passes that may make TMT's that were previously never used\n+/* Set by passes that may make SMT's that were previously never used\n    in statements, used.  */\n-#define TODO_update_tmt_usage           (1 << 13)\n+#define TODO_update_smt_usage           (1 << 13)\n \n #define TODO_update_ssa_any\t\t\\\n     (TODO_update_ssa\t\t\t\\"}, {"sha": "23bea83916276172d179acb4bcbaea6354163d28", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -847,7 +847,7 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t}\n       break;\n \n-    case TYPE_MEMORY_TAG:\n+    case SYMBOL_MEMORY_TAG:\n     case NAME_MEMORY_TAG:\n     case STRUCT_FIELD_TAG:\n     case VAR_DECL:"}, {"sha": "a1828e8cda63edd0aa07d5b170e58ef986217eaf", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -2223,9 +2223,9 @@ struct tree_opt_pass pass_sra =\n   TV_TREE_SRA,\t\t\t\t/* tv_id */\n   PROP_cfg | PROP_ssa | PROP_alias,\t/* properties_required */\n   0,\t\t\t\t\t/* properties_provided */\n-  PROP_tmt_usage,\t\t        /* properties_destroyed */\n+  PROP_smt_usage,\t\t        /* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_update_tmt_usage | TODO_dump_func /* todo_flags_finish */\n+  TODO_update_smt_usage | TODO_dump_func /* todo_flags_finish */\n   | TODO_update_ssa\n   | TODO_ggc_collect | TODO_verify_ssa,\n   0\t\t\t\t\t/* letter */"}, {"sha": "e8579bf8b5a18c881cf7b90eafb6659342005226", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 109, "deletions": 109, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -349,8 +349,8 @@ set_initial_properties (struct alias_info *ai)\n \t  if (pi->name_mem_tag)\n \t    mark_call_clobbered (pi->name_mem_tag, pi->escape_mask);\n \n-\t  if (v_ann->type_mem_tag)\n-\t    mark_call_clobbered (v_ann->type_mem_tag, pi->escape_mask);\n+\t  if (v_ann->symbol_mem_tag)\n+\t    mark_call_clobbered (v_ann->symbol_mem_tag, pi->escape_mask);\n \n \t  if (pi->pt_vars)\n \t    {\n@@ -361,14 +361,15 @@ set_initial_properties (struct alias_info *ai)\n \t\t  mark_call_clobbered (referenced_var (j), pi->escape_mask);\n \t    }\n \t}\n-      /* If the name tag is call clobbered, so is the type tag\n+\n+      /* If the name tag is call clobbered, so is the symbol tag\n \t associated with the base VAR_DECL.  */\n       if (pi->name_mem_tag\n-\t  && v_ann->type_mem_tag\n+\t  && v_ann->symbol_mem_tag\n \t  && is_call_clobbered (pi->name_mem_tag))\n-\tmark_call_clobbered (v_ann->type_mem_tag, pi->escape_mask);\n+\tmark_call_clobbered (v_ann->symbol_mem_tag, pi->escape_mask);\n \n-      /* Name tags and type tags that we don't know where they point\n+      /* Name tags and symbol tags that we don't know where they point\n \t to, might point to global memory, and thus, are clobbered.\n \n          FIXME:  This is not quite right.  They should only be\n@@ -384,18 +385,19 @@ set_initial_properties (struct alias_info *ai)\n \t}\n       \n       if ((pi->pt_global_mem || pi->pt_anything) \n-\t  && pi->is_dereferenced && v_ann->type_mem_tag)\n+\t  && pi->is_dereferenced\n+\t  && v_ann->symbol_mem_tag)\n \t{\n-\t  mark_call_clobbered (v_ann->type_mem_tag, ESCAPE_IS_GLOBAL);\n-\t  MTAG_GLOBAL (v_ann->type_mem_tag) = true;\n+\t  mark_call_clobbered (v_ann->symbol_mem_tag, ESCAPE_IS_GLOBAL);\n+\t  MTAG_GLOBAL (v_ann->symbol_mem_tag) = true;\n \t}\n     }\n }\n \n+\n /* This variable is set to true if we are updating the used alone\n-   information for TMT's, or are in a pass that is going to break it\n+   information for SMTs, or are in a pass that is going to break it\n    temporarily.  */\n-\n bool updating_used_alone;\n \n /* Compute which variables need to be marked call clobbered because\n@@ -424,7 +426,8 @@ compute_call_clobbered (struct alias_info *ai)\n }\n \n \n-/* Recalculate the used_alone information for TMT's . */\n+/* Recalculate the used_alone information for SMTs . */\n+\n void \n recalculate_used_alone (void)\n {\n@@ -436,19 +439,17 @@ recalculate_used_alone (void)\n   referenced_var_iterator rvi;\n   tree var;\n   \n-  /* First, reset all the TMT used alone bits to zero.  */\n+  /* First, reset all the SMT used alone bits to zero.  */\n   updating_used_alone = true;\n   FOR_EACH_REFERENCED_VAR (var, rvi)\n-    if (TREE_CODE (var) == TYPE_MEMORY_TAG)\n-      TMT_USED_ALONE (var) = 0;\n+    if (TREE_CODE (var) == SYMBOL_MEMORY_TAG)\n+      SMT_USED_ALONE (var) = 0;\n \n   /* Walk all the statements.\n      Calls get put into a list of statements to update, since we will\n      need to update operands on them if we make any changes.\n-     If we see a bare use of a TMT anywhere in a real virtual use or virtual\n-     def, mark the TMT as used alone, and for renaming.  */\n-     \n-     \n+     If we see a bare use of a SMT anywhere in a real virtual use or virtual\n+     def, mark the SMT as used alone, and for renaming.  */\n   FOR_EACH_BB (bb)\n     {\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n@@ -470,11 +471,11 @@ recalculate_used_alone (void)\n \t\t  if(TREE_CODE (var) == SSA_NAME)\n \t\t    svar = SSA_NAME_VAR (var);\n \t\t  \n-\t\t  if (TREE_CODE (svar) == TYPE_MEMORY_TAG)\n+\t\t  if (TREE_CODE (svar) == SYMBOL_MEMORY_TAG)\n \t\t    {\n-\t\t      if (!TMT_USED_ALONE (svar))\n+\t\t      if (!SMT_USED_ALONE (svar))\n \t\t\t{\n-\t\t\t  TMT_USED_ALONE (svar) = true;\n+\t\t\t  SMT_USED_ALONE (svar) = true;\n \t\t\t  mark_sym_for_renaming (svar);\n \t\t\t}\n \t\t    }\n@@ -527,11 +528,11 @@ recalculate_used_alone (void)\n \n    We have two classes of memory tags.  Memory tags associated with the\n    pointed-to data type of the pointers in the program.  These tags are\n-   called \"type memory tag\" (TMT).  The other class are those associated\n+   called \"symbol memory tag\" (SMT).  The other class are those associated\n    with SSA_NAMEs, called \"name memory tag\" (NMT). The basic idea is that\n    when adding operands for an INDIRECT_REF *P_i, we will first check\n    whether P_i has a name tag, if it does we use it, because that will have\n-   more precise aliasing information.  Otherwise, we use the standard type\n+   more precise aliasing information.  Otherwise, we use the standard symbol\n    tag.\n \n    In this phase, we go through all the pointers we found in points-to\n@@ -542,11 +543,11 @@ recalculate_used_alone (void)\n \n    3- Compute flow-insensitive aliases\n \n-   This pass will compare the alias set of every type memory tag and every\n-   addressable variable found in the program.  Given a type memory tag TMT\n-   and an addressable variable V.  If the alias sets of TMT and V conflict\n-   (as computed by may_alias_p), then V is marked as an alias tag and added\n-   to the alias set of TMT.\n+   This pass will compare the alias set of every symbol memory tag and\n+   every addressable variable found in the program.  Given a symbol\n+   memory tag SMT and an addressable variable V.  If the alias sets of\n+   SMT and V conflict (as computed by may_alias_p), then V is marked\n+   as an alias tag and added to the alias set of SMT.\n \n    For instance, consider the following function:\n \n@@ -564,7 +565,7 @@ recalculate_used_alone (void)\n \t      return *p;\n \t    }\n \n-   After aliasing analysis has finished, the type memory tag for pointer\n+   After aliasing analysis has finished, the symbol memory tag for pointer\n    'p' will have two aliases, namely variables 'a' and 'b'.  Every time\n    pointer 'p' is dereferenced, we want to mark the operation as a\n    potential reference to 'a' and 'b'.\n@@ -627,7 +628,7 @@ compute_may_aliases (void)\n   /* Compute flow-sensitive, points-to based aliasing for all the name\n      memory tags.  Note that this pass needs to be done before flow\n      insensitive analysis because it uses the points-to information\n-     gathered before to mark call-clobbered type tags.  */\n+     gathered before to mark call-clobbered symbol tags.  */\n   compute_flow_sensitive_aliasing (ai);\n \n   /* Compute type-based flow-insensitive aliasing for all the type\n@@ -860,7 +861,7 @@ init_alias_info (void)\n \t     just because they are tags, though we will clear it if they\n \t     aren't for global variables.  */\n \t  if (TREE_CODE (var) == NAME_MEMORY_TAG\n-\t      || TREE_CODE (var) == TYPE_MEMORY_TAG\n+\t      || TREE_CODE (var) == SYMBOL_MEMORY_TAG\n \t      || !is_global_var (var))\n \t    clear_call_clobbered (var);\n \t}\n@@ -973,8 +974,7 @@ create_name_tags (void)\n \t}\n \n       /* Set pt_anything on the pointers without pt_vars filled in so\n-\t that they are assigned a type tag.  */\n-      \n+\t that they are assigned a symbol tag.  */\n       if (pi->pt_vars && !bitmap_empty_p (pi->pt_vars))\t\n \tVEC_safe_push (tree, heap, with_ptvars, ptr);\n       else\n@@ -1078,7 +1078,7 @@ compute_flow_sensitive_aliasing (struct alias_info *ai)\n \tEXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, j, bi)\n \t  {\n \t    add_may_alias (pi->name_mem_tag, referenced_var (j));\n-\t    add_may_alias (v_ann->type_mem_tag, referenced_var (j));\n+\t    add_may_alias (v_ann->symbol_mem_tag, referenced_var (j));\n \t  }\n     }\n }\n@@ -1088,8 +1088,8 @@ compute_flow_sensitive_aliasing (struct alias_info *ai)\n    addressable variables found in setup_pointers_and_addressables.\n    \n    For every pointer P in AI->POINTERS and addressable variable V in\n-   AI->ADDRESSABLE_VARS, add V to the may-alias sets of P's type\n-   memory tag (TMT) if their alias sets conflict.  V is then marked as\n+   AI->ADDRESSABLE_VARS, add V to the may-alias sets of P's symbol\n+   memory tag (SMT) if their alias sets conflict.  V is then marked as\n    an alias tag so that the operand scanner knows that statements\n    containing V have aliased operands.  */\n \n@@ -1105,12 +1105,12 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n   ai->total_alias_vops = 0;\n \n   /* For every pointer P, determine which addressable variables may alias\n-     with P's type memory tag.  */\n+     with P's symbol memory tag.  */\n   for (i = 0; i < ai->num_pointers; i++)\n     {\n       size_t j;\n       struct alias_map_d *p_map = ai->pointers[i];\n-      tree tag = var_ann (p_map->var)->type_mem_tag;\n+      tree tag = var_ann (p_map->var)->symbol_mem_tag;\n       var_ann_t tag_ann = var_ann (tag);\n \n       p_map->total_alias_vops = 0;\n@@ -1181,15 +1181,15 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n      tags with conflicting alias set numbers but no aliased symbols in\n      common.\n \n-     For example, suppose that we have two memory tags TMT.1 and TMT.2\n+     For example, suppose that we have two memory tags SMT.1 and SMT.2\n      such that\n      \n-     \t\tmay-aliases (TMT.1) = { a }\n-\t\tmay-aliases (TMT.2) = { b }\n+     \t\tmay-aliases (SMT.1) = { a }\n+\t\tmay-aliases (SMT.2) = { b }\n \n-     and the alias set number of TMT.1 conflicts with that of TMT.2.\n+     and the alias set number of SMT.1 conflicts with that of SMT.2.\n      Since they don't have symbols in common, loads and stores from\n-     TMT.1 and TMT.2 will seem independent of each other, which will\n+     SMT.1 and SMT.2 will seem independent of each other, which will\n      lead to the optimizers making invalid transformations (see\n      testsuite/gcc.c-torture/execute/pr15262-[12].c).\n \n@@ -1200,13 +1200,13 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n     {\n       size_t j;\n       struct alias_map_d *p_map1 = ai->pointers[i];\n-      tree tag1 = var_ann (p_map1->var)->type_mem_tag;\n+      tree tag1 = var_ann (p_map1->var)->symbol_mem_tag;\n       bitmap may_aliases1 = p_map1->may_aliases;\n \n       for (j = i + 1; j < ai->num_pointers; j++)\n \t{\n \t  struct alias_map_d *p_map2 = ai->pointers[j];\n-\t  tree tag2 = var_ann (p_map2->var)->type_mem_tag;\n+\t  tree tag2 = var_ann (p_map2->var)->symbol_mem_tag;\n \t  bitmap may_aliases2 = p_map2->may_aliases;\n \n \t  /* If the pointers may not point to each other, do nothing.  */\n@@ -1389,14 +1389,14 @@ group_aliases (struct alias_info *ai)\n   for (i = 0; i < ai->num_pointers; i++)\n     {\n       size_t j;\n-      tree tag1 = var_ann (ai->pointers[i]->var)->type_mem_tag;\n+      tree tag1 = var_ann (ai->pointers[i]->var)->symbol_mem_tag;\n       bitmap tag1_aliases = ai->pointers[i]->may_aliases;\n \n       /* Skip tags that have been grouped already.  */\n       if (ai->pointers[i]->grouped_p)\n \tcontinue;\n \n-      /* See if TAG1 had any aliases in common with other type tags.\n+      /* See if TAG1 had any aliases in common with other symbol tags.\n \t If we find a TAG2 with common aliases with TAG1, add TAG2's\n \t aliases into TAG1.  */\n       for (j = i + 1; j < ai->num_pointers; j++)\n@@ -1405,7 +1405,7 @@ group_aliases (struct alias_info *ai)\n \n           if (bitmap_intersect_p (tag1_aliases, tag2_aliases))\n \t    {\n-\t      tree tag2 = var_ann (ai->pointers[j]->var)->type_mem_tag;\n+\t      tree tag2 = var_ann (ai->pointers[j]->var)->symbol_mem_tag;\n \n \t      bitmap_ior_into (tag1_aliases, tag2_aliases);\n \n@@ -1431,20 +1431,20 @@ group_aliases (struct alias_info *ai)\n \n   /* Finally, all the variables that have been grouped cannot be in\n      the may-alias set of name memory tags.  Suppose that we have\n-     grouped the aliases in this code so that may-aliases(a) = TMT.20\n+     grouped the aliases in this code so that may-aliases(a) = SMT.20\n \n      \tp_5 = &a;\n \t...\n \t# a_9 = V_MAY_DEF <a_8>\n \tp_5->field = 0\n-\t... Several modifications to TMT.20 ... \n+\t... Several modifications to SMT.20 ... \n \t# VUSE <a_9>\n \tx_30 = p_5->field\n \n      Since p_5 points to 'a', the optimizers will try to propagate 0\n      into p_5->field, but that is wrong because there have been\n-     modifications to 'TMT.20' in between.  To prevent this we have to\n-     replace 'a' with 'TMT.20' in the name tag of p_5.  */\n+     modifications to 'SMT.20' in between.  To prevent this we have to\n+     replace 'a' with 'SMT.20' in the name tag of p_5.  */\n   for (i = 0; i < VARRAY_ACTIVE_SIZE (ai->processed_ptrs); i++)\n     {\n       size_t j;\n@@ -1534,16 +1534,16 @@ setup_pointers_and_addressables (struct alias_info *ai)\n   /* Create ADDRESSABLE_VARS and POINTERS.  Note that these arrays are\n      always going to be slightly bigger than we actually need them\n      because some TREE_ADDRESSABLE variables will be marked\n-     non-addressable below and only pointers with unique type tags are\n+     non-addressable below and only pointers with unique symbol tags are\n      going to be added to POINTERS.  */\n   ai->addressable_vars = XCNEWVEC (struct alias_map_d *, num_addressable_vars);\n   ai->pointers = XCNEWVEC (struct alias_map_d *, num_pointers);\n   ai->num_addressable_vars = 0;\n   ai->num_pointers = 0;\n \n-  /* Since we will be creating type memory tags within this loop, cache the\n-     value of NUM_REFERENCED_VARS to avoid processing the additional tags\n-     unnecessarily.  */\n+  /* Since we will be creating symbol memory tags within this loop,\n+     cache the value of NUM_REFERENCED_VARS to avoid processing the\n+     additional tags unnecessarily.  */\n   n_vars = num_referenced_vars;\n \n   FOR_EACH_REFERENCED_VAR_SAFE (var, varvec, srvi)\n@@ -1553,7 +1553,7 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \n       /* Name memory tags already have flow-sensitive aliasing\n \t information, so they need not be processed by\n-\t compute_flow_insensitive_aliasing.  Similarly, type memory\n+\t compute_flow_insensitive_aliasing.  Similarly, symbol memory\n \t tags are already accounted for when we process their\n \t associated pointer. \n       \n@@ -1615,7 +1615,7 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \t}\n \n       /* Add pointer variables that have been dereferenced to the POINTERS\n-         array and create a type memory tag for them.  */\n+         array and create a symbol memory tag for them.  */\n       if (POINTER_TYPE_P (TREE_TYPE (var)))\n \t{\n \t  if ((bitmap_bit_p (ai->dereferenced_ptrs_store, DECL_UID (var))\n@@ -1630,20 +1630,20 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \t      tag = get_tmt_for (var, ai);\n \t      t_ann = var_ann (tag);\n \n-\t      /* The type tag will need to be renamed into SSA\n+\t      /* The symbol tag will need to be renamed into SSA\n \t\t afterwards. Note that we cannot do this inside\n \t\t get_tmt_for because aliasing may run multiple times\n-\t\t and we only create type tags the first time.  */\n+\t\t and we only create symbol tags the first time.  */\n \t      mark_sym_for_renaming (tag);\n \n \t      /* Similarly, if pointer VAR used to have another type\n \t\t tag, we will need to process it in the renamer to\n \t\t remove the stale virtual operands.  */\n-\t      if (v_ann->type_mem_tag)\n-\t\tmark_sym_for_renaming (v_ann->type_mem_tag);\n+\t      if (v_ann->symbol_mem_tag)\n+\t\tmark_sym_for_renaming (v_ann->symbol_mem_tag);\n \n \t      /* Associate the tag with pointer VAR.  */\n-\t      v_ann->type_mem_tag = tag;\n+\t      v_ann->symbol_mem_tag = tag;\n \n \t      /* If pointer VAR has been used in a store operation,\n \t\t then its memory tag must be marked as written-to.  */\n@@ -1661,14 +1661,14 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \t  else\n \t    {\n \t      /* The pointer has not been dereferenced.  If it had a\n-\t\t type memory tag, remove it and mark the old tag for\n+\t\t symbol memory tag, remove it and mark the old tag for\n \t\t renaming to remove it out of the IL.  */\n \t      var_ann_t ann = var_ann (var);\n-\t      tree tag = ann->type_mem_tag;\n+\t      tree tag = ann->symbol_mem_tag;\n \t      if (tag)\n \t\t{\n \t\t  mark_sym_for_renaming (tag);\n-\t\t  ann->type_mem_tag = NULL_TREE;\n+\t\t  ann->symbol_mem_tag = NULL_TREE;\n \t\t}\n \t    }\n \t}\n@@ -1796,7 +1796,7 @@ may_alias_p (tree ptr, HOST_WIDE_INT mem_alias_set,\n   alias_stats.simple_queries++;\n \n   /* By convention, a variable cannot alias itself.  */\n-  mem = var_ann (ptr)->type_mem_tag;\n+  mem = var_ann (ptr)->symbol_mem_tag;\n   if (mem == var)\n     {\n       alias_stats.alias_noalias++;\n@@ -1824,7 +1824,7 @@ may_alias_p (tree ptr, HOST_WIDE_INT mem_alias_set,\n       return false;\n     }\n \n-  gcc_assert (TREE_CODE (mem) == TYPE_MEMORY_TAG);\n+  gcc_assert (TREE_CODE (mem) == SYMBOL_MEMORY_TAG);\n \n   alias_stats.tbaa_queries++;\n \n@@ -2075,8 +2075,8 @@ static tree\n create_memory_tag (tree type, bool is_type_tag)\n {\n   var_ann_t ann;\n-  tree tag = create_tag_raw (is_type_tag ? TYPE_MEMORY_TAG : NAME_MEMORY_TAG,\n-\t\t\t     type, (is_type_tag) ? \"TMT\" : \"NMT\");\n+  tree tag = create_tag_raw (is_type_tag ? SYMBOL_MEMORY_TAG : NAME_MEMORY_TAG,\n+\t\t\t     type, (is_type_tag) ? \"SMT\" : \"NMT\");\n \n   /* By default, memory tags are local variables.  Alias analysis will\n      determine whether they should be considered globals.  */\n@@ -2086,7 +2086,7 @@ create_memory_tag (tree type, bool is_type_tag)\n   TREE_ADDRESSABLE (tag) = 1;\n \n   ann = get_var_ann (tag);\n-  ann->type_mem_tag = NULL_TREE;\n+  ann->symbol_mem_tag = NULL_TREE;\n \n   /* Add the tag to the symbol table.  */\n   add_referenced_tmp_var (tag);\n@@ -2112,13 +2112,13 @@ get_nmt_for (tree ptr)\n }\n \n \n-/* Return the type memory tag associated to pointer PTR.  A memory tag is an\n-   artificial variable that represents the memory location pointed-to by\n-   PTR.  It is used to model the effects of pointer de-references on\n-   addressable variables.\n+/* Return the symbol memory tag associated to pointer PTR.  A memory\n+   tag is an artificial variable that represents the memory location\n+   pointed-to by PTR.  It is used to model the effects of pointer\n+   de-references on addressable variables.\n    \n-   AI points to the data gathered during alias analysis.  This function\n-   populates the array AI->POINTERS.  */\n+   AI points to the data gathered during alias analysis.  This\n+   function populates the array AI->POINTERS.  */\n \n static tree\n get_tmt_for (tree ptr, struct alias_info *ai)\n@@ -2139,7 +2139,7 @@ get_tmt_for (tree ptr, struct alias_info *ai)\n   for (i = 0, tag = NULL_TREE; i < ai->num_pointers; i++)\n     {\n       struct alias_map_d *curr = ai->pointers[i];\n-      tree curr_tag = var_ann (curr->var)->type_mem_tag;\n+      tree curr_tag = var_ann (curr->var)->symbol_mem_tag;\n       if (tag_set == curr->set)\n \t{\n \t  tag = curr_tag;\n@@ -2153,13 +2153,13 @@ get_tmt_for (tree ptr, struct alias_info *ai)\n     {\n       struct alias_map_d *alias_map;\n \n-      /* If PTR did not have a type tag already, create a new TMT.*\n+      /* If PTR did not have a symbol tag already, create a new SMT.*\n \t artificial variable representing the memory location\n \t pointed-to by PTR.  */\n-      if (var_ann (ptr)->type_mem_tag == NULL_TREE)\n+      if (var_ann (ptr)->symbol_mem_tag == NULL_TREE)\n \ttag = create_memory_tag (tag_type, true);\n       else\n-\ttag = var_ann (ptr)->type_mem_tag;\n+\ttag = var_ann (ptr)->symbol_mem_tag;\n \n       /* Add PTR to the POINTERS array.  Note that we are not interested in\n \t PTR's alias set.  Instead, we cache the alias set for the memory that\n@@ -2173,7 +2173,7 @@ get_tmt_for (tree ptr, struct alias_info *ai)\n   /* If the pointed-to type is volatile, so is the tag.  */\n   TREE_THIS_VOLATILE (tag) |= TREE_THIS_VOLATILE (tag_type);\n \n-  /* Make sure that the type tag has the same alias set as the\n+  /* Make sure that the symbol tag has the same alias set as the\n      pointed-to type.  */\n   gcc_assert (tag_set == get_alias_set (tag));\n \n@@ -2260,15 +2260,15 @@ dump_alias_info (FILE *file)\n   FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n       var_ann_t ann = var_ann (var);\n-      if (ann->type_mem_tag)\n+      if (ann->symbol_mem_tag)\n \tdump_variable (file, var);\n     }\n \n-  fprintf (file, \"\\nType memory tags\\n\\n\");\n+  fprintf (file, \"\\nSymbol memory tags\\n\\n\");\n   \n   FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n-      if (TREE_CODE (var) == TYPE_MEMORY_TAG)\n+      if (TREE_CODE (var) == SYMBOL_MEMORY_TAG)\n \tdump_variable (file, var);\n     }\n \n@@ -2560,8 +2560,8 @@ is_aliased_with (tree tag, tree sym)\n }\n \n \n-/* Add VAR to the list of may-aliases of PTR's type tag.  If PTR\n-   doesn't already have a type tag, create one.  */\n+/* Add VAR to the list of may-aliases of PTR's symbol tag.  If PTR\n+   doesn't already have a symbol tag, create one.  */\n \n void\n add_type_alias (tree ptr, tree var)\n@@ -2573,47 +2573,47 @@ add_type_alias (tree ptr, tree var)\n   VEC (tree, heap) *varvec = NULL;  \n   unsigned i;\n \n-  if (ann->type_mem_tag == NULL_TREE)\n+  if (ann->symbol_mem_tag == NULL_TREE)\n     {\n       tree q = NULL_TREE;\n       tree tag_type = TREE_TYPE (TREE_TYPE (ptr));\n       HOST_WIDE_INT tag_set = get_alias_set (tag_type);\n       safe_referenced_var_iterator rvi;\n \n-      /* PTR doesn't have a type tag, create a new one and add VAR to\n+      /* PTR doesn't have a symbol tag, create a new one and add VAR to\n \t the new tag's alias set.\n \n \t FIXME, This is slower than necessary.  We need to determine\n \t whether there is another pointer Q with the same alias set as\n-\t PTR.  This could be sped up by having type tags associated\n+\t PTR.  This could be sped up by having symbol tags associated\n \t with types.  */\n       FOR_EACH_REFERENCED_VAR_SAFE (q, varvec, rvi)\n \t{\n \t  if (POINTER_TYPE_P (TREE_TYPE (q))\n \t      && tag_set == get_alias_set (TREE_TYPE (TREE_TYPE (q))))\n \t    {\n \t      /* Found another pointer Q with the same alias set as\n-\t\t the PTR's pointed-to type.  If Q has a type tag, use\n+\t\t the PTR's pointed-to type.  If Q has a symbol tag, use\n \t\t it.  Otherwise, create a new memory tag for PTR.  */\n \t      var_ann_t ann1 = var_ann (q);\n-\t      if (ann1->type_mem_tag)\n-\t\tann->type_mem_tag = ann1->type_mem_tag;\n+\t      if (ann1->symbol_mem_tag)\n+\t\tann->symbol_mem_tag = ann1->symbol_mem_tag;\n \t      else\n-\t\tann->type_mem_tag = create_memory_tag (tag_type, true);\n+\t\tann->symbol_mem_tag = create_memory_tag (tag_type, true);\n \t      goto found_tag;\n \t    }\n \t}\n \n-      /* Couldn't find any other pointer with a type tag we could use.\n+      /* Couldn't find any other pointer with a symbol tag we could use.\n \t Create a new memory tag for PTR.  */\n-      ann->type_mem_tag = create_memory_tag (tag_type, true);\n+      ann->symbol_mem_tag = create_memory_tag (tag_type, true);\n     }\n \n found_tag:\n-  /* If VAR is not already PTR's type tag, add it to the may-alias set\n-     for PTR's type tag.  */\n+  /* If VAR is not already PTR's symbol tag, add it to the may-alias set\n+     for PTR's symbol tag.  */\n   gcc_assert (!MTAG_P (var));\n-  tag = ann->type_mem_tag;\n+  tag = ann->symbol_mem_tag;\n \n   /* If VAR has subvars, add the subvars to the tag instead of the\n      actual var.  */\n@@ -2647,10 +2647,10 @@ add_type_alias (tree ptr, tree var)\n }\n \n \n-/* Create a new type tag for PTR.  Construct the may-alias list of this type\n+/* Create a new symbol tag for PTR.  Construct the may-alias list of this type\n    tag so that it has the aliasing of VAR. \n \n-   Note, the set of aliases represented by the new type tag are not marked\n+   Note, the set of aliases represented by the new symbol tag are not marked\n    for renaming.  */\n \n void\n@@ -2662,18 +2662,18 @@ new_type_alias (tree ptr, tree var)\n   tree tag;\n   subvar_t svars;\n \n-  gcc_assert (p_ann->type_mem_tag == NULL_TREE);\n+  gcc_assert (p_ann->symbol_mem_tag == NULL_TREE);\n   gcc_assert (!MTAG_P (var));\n \n-  /* Add VAR to the may-alias set of PTR's new type tag.  If VAR has\n+  /* Add VAR to the may-alias set of PTR's new symbol tag.  If VAR has\n      subvars, add the subvars to the tag instead of the actual var.  */\n   if (var_can_have_subvars (var)\n       && (svars = get_subvars_for_var (var)))\n     {\n       subvar_t sv;\n \n       tag = create_memory_tag (tag_type, true);\n-      p_ann->type_mem_tag = tag;\n+      p_ann->symbol_mem_tag = tag;\n \n       for (sv = svars; sv; sv = sv->next)\n         add_may_alias (tag, sv->var);\n@@ -2691,15 +2691,15 @@ new_type_alias (tree ptr, tree var)\n \t{\n \t  tree ali = VEC_index (tree, aliases, 0);\n \n-\t  if (TREE_CODE (ali) == TYPE_MEMORY_TAG)\n+\t  if (TREE_CODE (ali) == SYMBOL_MEMORY_TAG)\n \t    {\n-\t      p_ann->type_mem_tag = ali;\n+\t      p_ann->symbol_mem_tag = ali;\n \t      return;\n \t    }\n \t}\n \n       tag = create_memory_tag (tag_type, true);\n-      p_ann->type_mem_tag = tag;\n+      p_ann->symbol_mem_tag = tag;\n \n       if (aliases == NULL)\n \tadd_may_alias (tag, var);\n@@ -2846,7 +2846,7 @@ create_sft (tree var, tree field, unsigned HOST_WIDE_INT offset,\n \n   /* Add the new variable to REFERENCED_VARS.  */\n   ann = get_var_ann (subvar);\n-  ann->type_mem_tag = NULL;  \t\n+  ann->symbol_mem_tag = NULL;  \t\n   add_referenced_tmp_var (subvar);\n   SFT_PARENT_VAR (subvar) = var;\n   SFT_OFFSET (subvar) = offset;"}, {"sha": "6b724a1f25c9dd6e64270c7a09a0d0f914f5221f", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -1403,11 +1403,11 @@ struct tree_opt_pass pass_ccp =\n   TV_TREE_CCP,\t\t\t\t/* tv_id */\n   PROP_cfg | PROP_ssa | PROP_alias,\t/* properties_required */\n   0,\t\t\t\t\t/* properties_provided */\n-  PROP_tmt_usage,\t\t\t/* properties_destroyed */\n+  PROP_smt_usage,\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n   TODO_cleanup_cfg | TODO_dump_func | TODO_update_ssa\n     | TODO_ggc_collect | TODO_verify_ssa\n-    | TODO_verify_stmts | TODO_update_tmt_usage, /* todo_flags_finish */\n+    | TODO_verify_stmts | TODO_update_smt_usage, /* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n \n@@ -1440,12 +1440,12 @@ struct tree_opt_pass pass_store_ccp =\n   TV_TREE_STORE_CCP,\t\t\t/* tv_id */\n   PROP_cfg | PROP_ssa | PROP_alias,\t/* properties_required */\n   0,\t\t\t\t\t/* properties_provided */\n-  PROP_tmt_usage,\t\t\t/* properties_destroyed */\n+  PROP_smt_usage,\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n   TODO_dump_func | TODO_update_ssa\n     | TODO_ggc_collect | TODO_verify_ssa\n     | TODO_cleanup_cfg\n-    | TODO_verify_stmts | TODO_update_tmt_usage, /* todo_flags_finish */\n+    | TODO_verify_stmts | TODO_update_smt_usage, /* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n "}, {"sha": "c716d118029966677d8b706da3f9583225348dd0", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -108,8 +108,8 @@ may_propagate_copy (tree dest, tree orig)\n       && POINTER_TYPE_P (type_d)\n       && POINTER_TYPE_P (type_o))\n     {\n-      tree mt_dest = var_ann (SSA_NAME_VAR (dest))->type_mem_tag;\n-      tree mt_orig = var_ann (SSA_NAME_VAR (orig))->type_mem_tag;\n+      tree mt_dest = var_ann (SSA_NAME_VAR (dest))->symbol_mem_tag;\n+      tree mt_orig = var_ann (SSA_NAME_VAR (orig))->symbol_mem_tag;\n       if (mt_dest && mt_orig && mt_dest != mt_orig)\n \treturn false;\n       else if (!lang_hooks.types_compatible_p (type_d, type_o))\n@@ -187,16 +187,16 @@ merge_alias_info (tree orig, tree new)\n \t      == get_alias_set (TREE_TYPE (TREE_TYPE (orig_sym))));\n #endif\n \n-  /* Synchronize the type tags.  If both pointers had a tag and they\n-     are different, then something has gone wrong.  Type tags can\n+  /* Synchronize the symbol tags.  If both pointers had a tag and they\n+     are different, then something has gone wrong.  Symbol tags can\n      always be merged because they are flow insensitive, all the SSA\n-     names of the same base DECL share the same type tag.  */\n-  if (new_ann->type_mem_tag == NULL_TREE)\n-    new_ann->type_mem_tag = orig_ann->type_mem_tag;\n-  else if (orig_ann->type_mem_tag == NULL_TREE)\n-    orig_ann->type_mem_tag = new_ann->type_mem_tag;\n+     names of the same base DECL share the same symbol tag.  */\n+  if (new_ann->symbol_mem_tag == NULL_TREE)\n+    new_ann->symbol_mem_tag = orig_ann->symbol_mem_tag;\n+  else if (orig_ann->symbol_mem_tag == NULL_TREE)\n+    orig_ann->symbol_mem_tag = new_ann->symbol_mem_tag;\n   else\n-    gcc_assert (new_ann->type_mem_tag == orig_ann->type_mem_tag);\n+    gcc_assert (new_ann->symbol_mem_tag == orig_ann->symbol_mem_tag);\n \n   /* Check that flow-sensitive information is compatible.  Notice that\n      we may not merge flow-sensitive information here.  This function"}, {"sha": "7861a76fb9c0cdf2db493fc0b125a770cd814f61", "filename": "gcc/tree-ssa-copyrename.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-ssa-copyrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-ssa-copyrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copyrename.c?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -208,8 +208,9 @@ copy_rename_partition_coalesce (var_map map, tree var1, tree var2, FILE *debug)\n     }\n \n   /* Don't coalesce if there are two different memory tags.  */\n-  if (ann1->type_mem_tag && ann2->type_mem_tag\n-      && ann1->type_mem_tag != ann2->type_mem_tag)\n+  if (ann1->symbol_mem_tag\n+      && ann2->symbol_mem_tag\n+      && ann1->symbol_mem_tag != ann2->symbol_mem_tag)\n     {\n       if (debug)\n \tfprintf (debug, \" : 2 memory tags. No coalesce.\\n\");\n@@ -270,10 +271,10 @@ copy_rename_partition_coalesce (var_map map, tree var1, tree var2, FILE *debug)\n \n   /* Update the various flag widgitry of the current base representative.  */\n   ann3 = var_ann (SSA_NAME_VAR (partition_to_var (map, p3)));\n-  if (ann1->type_mem_tag)\n-    ann3->type_mem_tag = ann1->type_mem_tag;\n+  if (ann1->symbol_mem_tag)\n+    ann3->symbol_mem_tag = ann1->symbol_mem_tag;\n   else\n-    ann3->type_mem_tag = ann2->type_mem_tag;\n+    ann3->symbol_mem_tag = ann2->symbol_mem_tag;\n \n   if (debug)\n     {"}, {"sha": "e003b650c2f02dc88286ad0bcf1e6af85b21efbf", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -377,13 +377,13 @@ struct tree_opt_pass pass_dominator =\n   TV_TREE_SSA_DOMINATOR_OPTS,\t\t/* tv_id */\n   PROP_cfg | PROP_ssa | PROP_alias,\t/* properties_required */\n   0,\t\t\t\t\t/* properties_provided */\n-  PROP_tmt_usage,\t\t\t/* properties_destroyed */\n+  PROP_smt_usage,\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n   TODO_dump_func\n     | TODO_update_ssa\n     | TODO_cleanup_cfg\n     | TODO_verify_ssa\t\n-    | TODO_update_tmt_usage,\t\t/* todo_flags_finish */\n+    | TODO_update_smt_usage,\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n "}, {"sha": "1fd90088d6392e3a2131b5fdc2369fb2bdc3d824", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -1011,9 +1011,9 @@ struct tree_opt_pass pass_forwprop = {\n   PROP_cfg | PROP_ssa\n     | PROP_alias,\t\t/* properties_required */\n   0,\t\t\t\t/* properties_provided */\n-  PROP_tmt_usage,\t\t/* properties_destroyed */\n+  PROP_smt_usage,\t\t/* properties_destroyed */\n   0,\t\t\t\t/* todo_flags_start */\n-  TODO_update_tmt_usage |TODO_dump_func /* todo_flags_finish */\n+  TODO_update_smt_usage |TODO_dump_func /* todo_flags_finish */\n   | TODO_ggc_collect\n   | TODO_update_ssa | TODO_verify_ssa,\n   0\t\t\t\t\t/* letter */"}, {"sha": "9e310416c34929f0af39e1f1c41e7f6c1d6717e4", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -5342,8 +5342,8 @@ get_ref_tag (tree ref, tree orig)\n \n   if (TREE_CODE (var) == INDIRECT_REF)\n     {\n-      /* In case the base is a dereference of a pointer, first check its name\n-\t mem tag, and if it does not have one, use type mem tag.  */\n+      /* If the base is a dereference of a pointer, first check its name memory\n+\t tag.  If it does not have one, use its symbol memory tag.  */\n       var = TREE_OPERAND (var, 0);\n       if (TREE_CODE (var) != SSA_NAME)\n \treturn NULL_TREE;\n@@ -5356,7 +5356,7 @@ get_ref_tag (tree ref, tree orig)\n \t}\n  \n       var = SSA_NAME_VAR (var);\n-      tag = var_ann (var)->type_mem_tag;\n+      tag = var_ann (var)->symbol_mem_tag;\n       gcc_assert (tag != NULL_TREE);\n       return tag;\n     }\n@@ -5365,7 +5365,7 @@ get_ref_tag (tree ref, tree orig)\n       if (!DECL_P (var))\n \treturn NULL_TREE;\n \n-      tag = var_ann (var)->type_mem_tag;\n+      tag = var_ann (var)->symbol_mem_tag;\n       if (tag)\n \treturn tag;\n "}, {"sha": "727e59589dfa2c5e9767289ad1472991c55fa351", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -954,23 +954,24 @@ add_virtual_operand (tree var, stmt_ann_t s_ann, int flags,\n \t     This fixes the bug in gcc.c-torture/execute/20020503-1.c.\n \t     \n \t     It is also necessary to add bare defs on clobbers for\n-\t     TMT's, so that bare TMT uses caused by pruning all the\n+\t     SMT's, so that bare SMT uses caused by pruning all the\n \t     aliases will link up properly with calls.   In order to\n \t     keep the number of these bare defs we add down to the\n-\t     minimum necessary, we keep track of which TMT's were used\n-\t     alone in statement defs or vuses.  */\n+\t     minimum necessary, we keep track of which SMT's were used\n+\t     alone in statement vdefs or vuses.  */\n \t  if (v_ann->is_aliased\n \t      || none_added\n-\t      || (TREE_CODE (var) == TYPE_MEMORY_TAG && for_clobber\n-\t\t  && TMT_USED_ALONE (var)))\n+\t      || (TREE_CODE (var) == SYMBOL_MEMORY_TAG\n+\t\t  && for_clobber\n+\t\t  && SMT_USED_ALONE (var)))\n \t    {\n-\t      /* Every bare tmt def we add should have TMT_USED_ALONE\n+\t      /* Every bare SMT def we add should have SMT_USED_ALONE\n \t\t set on it, or else we will get the wrong answer on\n \t\t clobbers.  */\n-\n-\t      if (none_added && !updating_used_alone && aliases_computed_p\n-\t\t  && TREE_CODE (var) == TYPE_MEMORY_TAG)\n-\t\tgcc_assert (TMT_USED_ALONE (var));\n+\t      if (none_added\n+\t\t  && !updating_used_alone && aliases_computed_p\n+\t\t  && TREE_CODE (var) == SYMBOL_MEMORY_TAG)\n+\t\tgcc_assert (SMT_USED_ALONE (var));\n \n \t      append_v_may_def (var);\n \t    }\n@@ -1084,7 +1085,7 @@ get_indirect_ref_operands (tree stmt, tree expr, int flags,\n       else\n \t{\n \t  /* If PTR is not an SSA_NAME or it doesn't have a name\n-\t     tag, use its type memory tag.  */\n+\t     tag, use its symbol memory tag.  */\n \t  var_ann_t v_ann;\n \n \t  /* If we are emitting debugging dumps, display a warning if\n@@ -1106,8 +1107,8 @@ get_indirect_ref_operands (tree stmt, tree expr, int flags,\n \t    ptr = SSA_NAME_VAR (ptr);\n \t  v_ann = var_ann (ptr);\n \n-\t  if (v_ann->type_mem_tag)\n-\t    add_virtual_operand (v_ann->type_mem_tag, s_ann, flags,\n+\t  if (v_ann->symbol_mem_tag)\n+\t    add_virtual_operand (v_ann->symbol_mem_tag, s_ann, flags,\n \t\t\t\t full_ref, offset, size, false);\n \t}\n     }\n@@ -1504,7 +1505,7 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n \n     case SSA_NAME:\n     case STRUCT_FIELD_TAG:\n-    case TYPE_MEMORY_TAG:\n+    case SYMBOL_MEMORY_TAG:\n     case NAME_MEMORY_TAG:\n      add_stmt_operand (expr_p, s_ann, flags);\n      return;"}, {"sha": "7e4e14291aca997a1af12be26f01ff3790e86b2d", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -168,7 +168,7 @@ is_hidden_global_store (tree stmt)\n \t variable.\n \n \t Therefore, we check the base address of the LHS.  If the\n-\t address is a pointer, we check if its name tag or type tag is\n+\t address is a pointer, we check if its name tag or symbol tag is\n \t a global variable.  Otherwise, we check if the base variable\n \t is a global.  */\n       lhs = TREE_OPERAND (stmt, 0);\n@@ -194,12 +194,12 @@ is_hidden_global_store (tree stmt)\n \t  tree ptr = TREE_OPERAND (lhs, 0);\n \t  struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n \t  tree nmt = (pi) ? pi->name_mem_tag : NULL_TREE;\n-\t  tree tmt = var_ann (SSA_NAME_VAR (ptr))->type_mem_tag;\n+\t  tree smt = var_ann (SSA_NAME_VAR (ptr))->symbol_mem_tag;\n \n-\t  /* If either the name tag or the type tag for PTR is a\n+\t  /* If either the name tag or the symbol tag for PTR is a\n \t     global variable, then the store is necessary.  */\n \t  if ((nmt && is_global_var (nmt))\n-\t      || (tmt && is_global_var (tmt)))\n+\t      || (smt && is_global_var (smt)))\n \t    {\n \t      return true;\n \t    }"}, {"sha": "6e40e129d7ff28f226313776f5a479e0852af648", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -459,9 +459,9 @@ verify_flow_sensitive_alias_info (void)\n \tcontinue;\n \n       ann = var_ann (var);\n-      if (pi->is_dereferenced && !pi->name_mem_tag && !ann->type_mem_tag)\n+      if (pi->is_dereferenced && !pi->name_mem_tag && !ann->symbol_mem_tag)\n \t{\n-\t  error (\"dereferenced pointers should have a name or a type tag\");\n+\t  error (\"dereferenced pointers should have a name or a symbol tag\");\n \t  goto err;\n \t}\n \n@@ -498,8 +498,8 @@ DEF_VEC_ALLOC_P (bitmap,heap);\n    points-to set is different from every other points-to set for other name\n    tags.\n \n-   Additionally, given a pointer P_i with name tag NMT and type tag\n-   TMT, this function verified the alias set of TMT is a superset of\n+   Additionally, given a pointer P_i with name tag NMT and symbol tag\n+   SMT, this function verified the alias set of SMT is a superset of\n    the alias set of NMT.  */\n \n static void\n@@ -516,7 +516,7 @@ verify_name_tags (void)\n   for (i = 0; i < num_ssa_names; i++)\n     {\n       struct ptr_info_def *pi;\n-      tree tmt, ptr = ssa_name (i);\n+      tree smt, ptr = ssa_name (i);\n \n       if (ptr == NULL_TREE)\n \tcontinue;\n@@ -538,31 +538,31 @@ verify_name_tags (void)\n       VEC_safe_push (tree, heap, name_tag_reps, ptr);\n       VEC_safe_push (bitmap, heap, pt_vars_for_reps, pi->pt_vars);\n \n-      /* Verify that alias set of PTR's type tag is a superset of the\n+      /* Verify that alias set of PTR's symbol tag is a superset of the\n \t alias set of PTR's name tag.  */\n-      tmt = var_ann (SSA_NAME_VAR (ptr))->type_mem_tag;\n-      if (tmt)\n+      smt = var_ann (SSA_NAME_VAR (ptr))->symbol_mem_tag;\n+      if (smt)\n \t{\n \t  size_t i;\n-\t  VEC(tree,gc) *aliases = var_ann (tmt)->may_aliases;\n+\t  VEC(tree,gc) *aliases = var_ann (smt)->may_aliases;\n \t  tree alias;\n \n \t  bitmap_clear (type_aliases);\n \t  for (i = 0; VEC_iterate (tree, aliases, i, alias); i++)\n \t    bitmap_set_bit (type_aliases, DECL_UID (alias));\n \n-\t  /* When grouping, we may have added PTR's type tag into the\n+\t  /* When grouping, we may have added PTR's symbol tag into the\n \t     alias set of PTR's name tag.  To prevent a false\n-\t     positive, pretend that TMT is in its own alias set.  */\n-\t  bitmap_set_bit (type_aliases, DECL_UID (tmt));\n+\t     positive, pretend that SMT is in its own alias set.  */\n+\t  bitmap_set_bit (type_aliases, DECL_UID (smt));\n \n \t  if (bitmap_equal_p (type_aliases, pi->pt_vars))\n \t    continue;\n \n \t  if (!bitmap_intersect_compl_p (type_aliases, pi->pt_vars))\n \t    {\n-\t      error (\"alias set of a pointer's type tag should be a superset of the corresponding name tag\");\n-\t      debug_variable (tmt);\n+\t      error (\"alias set of a pointer's symbol tag should be a superset of the corresponding name tag\");\n+\t      debug_variable (smt);\n \t      debug_variable (pi->name_mem_tag);\n \t      goto err;\n \t    }"}, {"sha": "5f2bce367eea7aa1d0e0d00630a81b19e8e6e2c9", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -300,12 +300,12 @@ vect_create_data_ref_ptr (tree stmt,\n   tag = DR_MEMTAG (dr);\n   gcc_assert (tag);\n \n-  /* If tag is a variable (and NOT_A_TAG) than a new type alias\n+  /* If tag is a variable (and NOT_A_TAG) than a new symbol memory\n      tag must be created with tag added to its may alias list.  */\n   if (!MTAG_P (tag))\n     new_type_alias (vect_ptr, tag);\n   else\n-    var_ann (vect_ptr)->type_mem_tag = tag;\n+    var_ann (vect_ptr)->symbol_mem_tag = tag;\n \n   var_ann (vect_ptr)->subvars = DR_SUBVARS (dr);\n "}, {"sha": "099e85aae067e9120445eb027012c3ebf764e5aa", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -4571,13 +4571,13 @@ struct tree_opt_pass pass_vrp =\n   TV_TREE_VRP,\t\t\t\t/* tv_id */\n   PROP_ssa | PROP_alias,\t\t/* properties_required */\n   0,\t\t\t\t\t/* properties_provided */\n-  PROP_tmt_usage,\t\t\t\t\t/* properties_destroyed */\n+  PROP_smt_usage,\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n   TODO_cleanup_cfg\n     | TODO_ggc_collect\n     | TODO_verify_ssa\n     | TODO_dump_func\n     | TODO_update_ssa\n-    | TODO_update_tmt_usage,\t\t\t/* todo_flags_finish */\n+    | TODO_update_smt_usage,\t\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };"}, {"sha": "cf6155cd322cfeb782c4ea63113f9320652ebdc0", "filename": "gcc/tree.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -270,11 +270,11 @@ init_ttree (void)\n   tree_contains_struct[FIELD_DECL][TS_DECL_MINIMAL] = 1;\n   tree_contains_struct[STRUCT_FIELD_TAG][TS_DECL_MINIMAL] = 1;\n   tree_contains_struct[NAME_MEMORY_TAG][TS_DECL_MINIMAL] = 1;\n-  tree_contains_struct[TYPE_MEMORY_TAG][TS_DECL_MINIMAL] = 1;\n+  tree_contains_struct[SYMBOL_MEMORY_TAG][TS_DECL_MINIMAL] = 1;\n \n   tree_contains_struct[STRUCT_FIELD_TAG][TS_MEMORY_TAG] = 1;\n   tree_contains_struct[NAME_MEMORY_TAG][TS_MEMORY_TAG] = 1;\n-  tree_contains_struct[TYPE_MEMORY_TAG][TS_MEMORY_TAG] = 1;\n+  tree_contains_struct[SYMBOL_MEMORY_TAG][TS_MEMORY_TAG] = 1;\n \n   tree_contains_struct[STRUCT_FIELD_TAG][TS_STRUCT_FIELD_TAG] = 1;\n \n@@ -336,7 +336,7 @@ tree_code_size (enum tree_code code)\n \t  case FUNCTION_DECL:\n \t    return sizeof (struct tree_function_decl);\n \t  case NAME_MEMORY_TAG:\n-\t  case TYPE_MEMORY_TAG:\n+\t  case SYMBOL_MEMORY_TAG:\n \t    return sizeof (struct tree_memory_tag);\n \t  case STRUCT_FIELD_TAG:\n \t    return sizeof (struct tree_struct_field_tag);\n@@ -2042,7 +2042,7 @@ tree_node_structure (tree t)\n \t    return TS_TYPE_DECL;\n \t  case FUNCTION_DECL:\n \t    return TS_FUNCTION_DECL;\n-\t  case TYPE_MEMORY_TAG:\n+\t  case SYMBOL_MEMORY_TAG:\n \t  case NAME_MEMORY_TAG:\n \t  case STRUCT_FIELD_TAG:\n \t    return TS_MEMORY_TAG;"}, {"sha": "2b84abdf0853f16efcd61b4ba390affe479c43f9", "filename": "gcc/tree.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -358,7 +358,7 @@ DEFTREECODE (RESULT_DECL, \"result_decl\", tcc_declaration, 0)\n    virtual SSA.  */\n DEFTREECODE (STRUCT_FIELD_TAG, \"struct_field_tag\", tcc_declaration, 0)\n DEFTREECODE (NAME_MEMORY_TAG, \"name_memory_tag\", tcc_declaration, 0)\n-DEFTREECODE (TYPE_MEMORY_TAG, \"type_memory_tag\", tcc_declaration, 0)\n+DEFTREECODE (SYMBOL_MEMORY_TAG, \"symbol_memory_tag\", tcc_declaration, 0)\n \n /* A namespace declaration.  Namespaces appear in DECL_CONTEXT of other\n    _DECLs, providing a hierarchy of names.  */"}, {"sha": "6b26a85a5c625f1e6a030240b63f4cd36045eb9a", "filename": "gcc/tree.h", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18cd8a03f87fb12895109b72832cbdcc27b39c69/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=18cd8a03f87fb12895109b72832cbdcc27b39c69", "patch": "@@ -105,7 +105,7 @@ extern const enum tree_code_class tree_code_type[];\n #define MTAG_P(CODE) \\\n   (TREE_CODE (CODE) == STRUCT_FIELD_TAG\t\t\\\n    || TREE_CODE (CODE) == NAME_MEMORY_TAG\t\\\n-   || TREE_CODE (CODE) == TYPE_MEMORY_TAG)\n+   || TREE_CODE (CODE) == SYMBOL_MEMORY_TAG)\n         \n \n /* Nonzero if DECL represents a VAR_DECL or FUNCTION_DECL.  */\n@@ -2298,12 +2298,21 @@ struct tree_decl_minimal GTY(())\n \n /* When computing aliasing information, we represent the memory pointed-to\n    by pointers with artificial variables called \"memory tags\" (MT).  There\n-   are two kinds of tags: type and name.  Type tags (TMT) are used in\n-   type-based alias analysis, they represent all the pointed-to locations\n-   and variables of the same alias set class.  Name tags (NMT) are used in\n-   flow-sensitive points-to alias analysis, they represent the variables\n-   and memory locations pointed-to by a specific SSA_NAME pointer.  */\n-\n+   are two kinds of tags, namely symbol and name:\n+   \n+   Symbol tags (SMT) are used in flow-insensitive alias analysis, they\n+   represent all the pointed-to locations and variables pointed-to by\n+   the same pointer symbol.  Usually, this set is computed using\n+   type-based analysis (i.e., alias set classes), but this may not\n+   always be the case.\n+\n+   Name tags (NMT) are used in flow-sensitive points-to alias\n+   analysis, they represent the variables and memory locations\n+   pointed-to by a specific SSA_NAME pointer.\n+\n+   In general, given a pointer P with a symbol tag SMT, the alias set\n+   of SMT should be the union of all the alias sets of the NMTs of\n+   every SSA_NAME for P.  */\n struct tree_memory_tag GTY(())\n {\n   struct tree_decl_minimal common;\n@@ -2313,9 +2322,10 @@ struct tree_memory_tag GTY(())\n \n #define MTAG_GLOBAL(NODE) (TREE_MEMORY_TAG_CHECK (NODE)->mtag.is_global)\n \n-/* This flag is true if a TMT is used as the vdef or vuse operand directly,\n-   because the access had all of the TMT's aliases pruned from it.  */\n-#define TMT_USED_ALONE(NODE) (TYPE_MEMORY_TAG_CHECK (NODE)->mtag.is_used_alone)\n+/* This flag is true if a SMT is used as the V_MAY_DEF or VUSE operand\n+   directly, because the access had all of the SMT's aliases pruned\n+   from it.  */\n+#define SMT_USED_ALONE(NODE) (SYMBOL_MEMORY_TAG_CHECK (NODE)->mtag.is_used_alone)\n \n struct tree_struct_field_tag GTY(())\n {"}]}