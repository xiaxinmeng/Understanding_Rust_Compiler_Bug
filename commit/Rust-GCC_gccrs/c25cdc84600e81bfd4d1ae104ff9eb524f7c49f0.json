{"sha": "c25cdc84600e81bfd4d1ae104ff9eb524f7c49f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI1Y2RjODQ2MDBlODFiZmQ0ZDFhZTEwNGZmOWViNTI0ZjdjNDlmMA==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-15T00:12:54Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-19T14:39:18Z"}, "message": "Initial Typechecking for projections\n\nQualifiedPathInExpressions resolve to trait items which require careful\nmanagement of substitutions which still need to be implemented. This is the\nbuilding block to get that work done.", "tree": {"sha": "d0b5d1437673ce5bd051aa21f75b0f5d20a9c934", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0b5d1437673ce5bd051aa21f75b0f5d20a9c934"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c25cdc84600e81bfd4d1ae104ff9eb524f7c49f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c25cdc84600e81bfd4d1ae104ff9eb524f7c49f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c25cdc84600e81bfd4d1ae104ff9eb524f7c49f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c25cdc84600e81bfd4d1ae104ff9eb524f7c49f0/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe9dd83b41346fa667c693e5dd10dc9fe80e93b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe9dd83b41346fa667c693e5dd10dc9fe80e93b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe9dd83b41346fa667c693e5dd10dc9fe80e93b3"}], "stats": {"total": 312, "additions": 202, "deletions": 110}, "files": [{"sha": "2c0613456b950038d36fc18ac5c598102375a349", "filename": "gcc/rust/typecheck/rust-hir-type-bounds.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c25cdc84600e81bfd4d1ae104ff9eb524f7c49f0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c25cdc84600e81bfd4d1ae104ff9eb524f7c49f0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h?ref=c25cdc84600e81bfd4d1ae104ff9eb524f7c49f0", "patch": "@@ -38,6 +38,18 @@ class TypeBoundsProbe : public TypeCheckBase\n     return probe.trait_references;\n   }\n \n+  static bool is_bound_satisfied_for_type (TyTy::BaseType *receiver,\n+\t\t\t\t\t   TraitReference *ref)\n+  {\n+    std::vector<TraitReference *> bounds = Probe (receiver);\n+    for (TraitReference *b : bounds)\n+      {\n+\tif (b == ref)\n+\t  return true;\n+      }\n+    return false;\n+  }\n+\n private:\n   void scan ();\n "}, {"sha": "d82b5c7f9d7482119b349b46ea8584c7fea5b1ad", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 190, "deletions": 110, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c25cdc84600e81bfd4d1ae104ff9eb524f7c49f0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c25cdc84600e81bfd4d1ae104ff9eb524f7c49f0/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=c25cdc84600e81bfd4d1ae104ff9eb524f7c49f0", "patch": "@@ -28,6 +28,8 @@\n #include \"rust-hir-path-probe.h\"\n #include \"rust-substitution-mapper.h\"\n #include \"rust-hir-const-fold.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+#include \"rust-hir-type-bounds.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -923,6 +925,74 @@ class TypeCheckExpr : public TypeCheckBase\n     infered = resolved->get_field_type ();\n   }\n \n+  void visit (HIR::QualifiedPathInExpression &expr) override\n+  {\n+    HIR::QualifiedPathType qual_path_type = expr.get_path_type ();\n+    TyTy::BaseType *root\n+      = TypeCheckType::Resolve (qual_path_type.get_type ().get ());\n+    if (root->get_kind () == TyTy::TypeKind::ERROR)\n+      return;\n+\n+    if (!qual_path_type.has_as_clause ())\n+      {\n+\t// then this is just a normal path-in-expression\n+\tNodeId root_resolved_node_id = UNKNOWN_NODEID;\n+\tbool ok = resolver->lookup_resolved_type (\n+\t  qual_path_type.get_type ()->get_mappings ().get_nodeid (),\n+\t  &root_resolved_node_id);\n+\trust_assert (ok);\n+\n+\tresolve_segments (root_resolved_node_id, expr.get_segments (), 0, root,\n+\t\t\t  expr.get_mappings (), expr.get_locus ());\n+      }\n+\n+    // Resolve the trait now\n+    TraitReference *trait_ref\n+      = TraitResolver::Resolve (*qual_path_type.get_trait ().get ());\n+    if (trait_ref->is_error ())\n+      return;\n+\n+    // does this type actually implement this type-bound?\n+    if (!TypeBoundsProbe::is_bound_satisfied_for_type (root, trait_ref))\n+      return;\n+\n+    // then we need to look at the next segment to create perform the correct\n+    // projection type\n+    if (expr.get_segments ().empty ())\n+      return;\n+\n+    DefId resolved_item_id = UNKNOWN_DEFID;\n+    HIR::PathExprSegment &item_seg = expr.get_segments ().at (0);\n+\n+    const TraitItemReference *trait_item_ref = nullptr;\n+    bool ok\n+      = trait_ref->lookup_trait_item (item_seg.get_segment ().as_string (),\n+\t\t\t\t      &trait_item_ref);\n+    if (!ok)\n+      {\n+\trust_error_at (item_seg.get_locus (), \"unknown associated item\");\n+\treturn;\n+      }\n+\n+    // TODO self and generic arguments\n+\n+    infered = trait_item_ref->get_tyty ();\n+    rust_debug_loc (expr.get_locus (), \"resolved to:\");\n+    infered->debug ();\n+\n+    TyTy::ProjectionType *projection\n+      = new TyTy::ProjectionType (qual_path_type.get_mappings ().get_hirid (),\n+\t\t\t\t  TyTy::TyVar (root->get_ref ()), trait_ref,\n+\t\t\t\t  resolved_item_id);\n+    context->insert_type (qual_path_type.get_mappings (), projection);\n+\n+    // continue on as a path-in-expression\n+    NodeId root_resolved_node_id\n+      = trait_item_ref->get_mappings ().get_nodeid ();\n+    resolve_segments (root_resolved_node_id, expr.get_segments (), 1, infered,\n+\t\t      expr.get_mappings (), expr.get_locus ());\n+  }\n+\n   void visit (HIR::PathInExpression &expr) override\n   {\n     NodeId resolved_node_id = UNKNOWN_NODEID;\n@@ -931,15 +1001,15 @@ class TypeCheckExpr : public TypeCheckBase\n     TyTy::BaseType *tyseg\n       = resolve_root_path (expr, &offset, &resolved_node_id);\n \n+    if (tyseg == nullptr)\n+      {\n+\trust_debug_loc (expr.get_locus (), \"failed to resolve root_seg\");\n+      }\n     rust_assert (tyseg != nullptr);\n \n     if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n       return;\n \n-    // this is the case where the name resolver has already fully resolved the\n-    // name, which means all the work is already done.\n-    bool name_resolved_fully = offset >= expr.get_num_segments ();\n-\n     if (expr.get_num_segments () == 1)\n       {\n \tLocation locus = expr.get_segments ().back ().get_locus ();\n@@ -957,112 +1027,8 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn;\n       }\n \n-    TyTy::BaseType *prev_segment = tyseg;\n-    for (size_t i = offset; i < expr.get_num_segments (); i++)\n-      {\n-\tHIR::PathExprSegment &seg = expr.get_segments ().at (i);\n-\n-\tbool reciever_is_generic\n-\t  = prev_segment->get_kind () == TyTy::TypeKind::PARAM;\n-\tbool probe_bounds = true;\n-\tbool probe_impls = !reciever_is_generic;\n-\tbool ignore_mandatory_trait_items = !reciever_is_generic;\n-\n-\t// probe the path\n-\tauto candidates\n-\t  = PathProbeType::Probe (tyseg, seg.get_segment (), probe_impls,\n-\t\t\t\t  probe_bounds, ignore_mandatory_trait_items);\n-\tif (candidates.size () == 0)\n-\t  {\n-\t    rust_error_at (\n-\t      seg.get_locus (),\n-\t      \"failed to resolve path segment using an impl Probe\");\n-\t    return;\n-\t  }\n-\telse if (candidates.size () > 1)\n-\t  {\n-\t    ReportMultipleCandidateError::Report (candidates,\n-\t\t\t\t\t\t  seg.get_segment (),\n-\t\t\t\t\t\t  seg.get_locus ());\n-\t    return;\n-\t  }\n-\n-\tauto &candidate = candidates.at (0);\n-\tprev_segment = tyseg;\n-\ttyseg = candidate.ty;\n-\n-\tif (candidate.is_impl_candidate ())\n-\t  {\n-\t    resolved_node_id\n-\t      = candidate.item.impl.impl_item->get_impl_mappings ()\n-\t\t  .get_nodeid ();\n-\t  }\n-\telse\n-\t  {\n-\t    resolved_node_id\n-\t      = candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n-\t  }\n-\n-\tif (seg.has_generic_args ())\n-\t  {\n-\t    if (!tyseg->can_substitute ())\n-\t      {\n-\t\trust_error_at (expr.get_locus (),\n-\t\t\t       \"substitutions not supported for %s\",\n-\t\t\t       tyseg->as_string ().c_str ());\n-\t\treturn;\n-\t      }\n-\n-\t    tyseg = SubstMapper::Resolve (tyseg, expr.get_locus (),\n-\t\t\t\t\t  &seg.get_generic_args ());\n-\t    if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n-\t      return;\n-\t  }\n-      }\n-\n-    context->insert_receiver (expr.get_mappings ().get_hirid (), prev_segment);\n-    if (tyseg->needs_generic_substitutions ())\n-      {\n-\tLocation locus = expr.get_segments ().back ().get_locus ();\n-\tif (!prev_segment->needs_generic_substitutions ())\n-\t  {\n-\t    auto used_args_in_prev_segment\n-\t      = GetUsedSubstArgs::From (prev_segment);\n-\t    if (!used_args_in_prev_segment.is_error ())\n-\t      tyseg = SubstMapperInternal::Resolve (tyseg,\n-\t\t\t\t\t\t    used_args_in_prev_segment);\n-\t  }\n-\telse\n-\t  {\n-\t    tyseg = SubstMapper::InferSubst (tyseg, locus);\n-\t  }\n-\n-\tif (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n-\t  return;\n-      }\n-\n-    rust_assert (resolved_node_id != UNKNOWN_NODEID);\n-\n-    // lookup if the name resolver was able to canonically resolve this or not\n-    NodeId path_resolved_id = UNKNOWN_NODEID;\n-    if (resolver->lookup_resolved_name (expr.get_mappings ().get_nodeid (),\n-\t\t\t\t\t&path_resolved_id))\n-      {\n-\trust_assert (path_resolved_id == resolved_node_id);\n-      }\n-    // check the type scope\n-    else if (resolver->lookup_resolved_type (expr.get_mappings ().get_nodeid (),\n-\t\t\t\t\t     &path_resolved_id))\n-      {\n-\trust_assert (path_resolved_id == resolved_node_id);\n-      }\n-    else if (!name_resolved_fully)\n-      {\n-\tresolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n-\t\t\t\t\tresolved_node_id);\n-      }\n-\n-    infered = tyseg;\n+    resolve_segments (resolved_node_id, expr.get_segments (), offset, tyseg,\n+\t\t      expr.get_mappings (), expr.get_locus ());\n   }\n \n   void visit (HIR::LoopExpr &expr) override\n@@ -1353,6 +1319,120 @@ class TypeCheckExpr : public TypeCheckBase\n     return root_tyty;\n   }\n \n+  void resolve_segments (NodeId root_resolved_node_id,\n+\t\t\t std::vector<HIR::PathExprSegment> &segments,\n+\t\t\t size_t offset, TyTy::BaseType *tyseg,\n+\t\t\t const Analysis::NodeMapping &expr_mappings,\n+\t\t\t Location expr_locus)\n+  {\n+    NodeId resolved_node_id = root_resolved_node_id;\n+    TyTy::BaseType *prev_segment = tyseg;\n+    for (size_t i = offset; i < segments.size (); i++)\n+      {\n+\tHIR::PathExprSegment &seg = segments.at (i);\n+\n+\tbool reciever_is_generic\n+\t  = prev_segment->get_kind () == TyTy::TypeKind::PARAM;\n+\tbool probe_bounds = true;\n+\tbool probe_impls = !reciever_is_generic;\n+\tbool ignore_mandatory_trait_items = !reciever_is_generic;\n+\n+\t// probe the path\n+\tauto candidates\n+\t  = PathProbeType::Probe (prev_segment, seg.get_segment (), probe_impls,\n+\t\t\t\t  probe_bounds, ignore_mandatory_trait_items);\n+\tif (candidates.size () == 0)\n+\t  {\n+\t    rust_error_at (\n+\t      seg.get_locus (),\n+\t      \"failed to resolve path segment using an impl Probe\");\n+\t    return;\n+\t  }\n+\telse if (candidates.size () > 1)\n+\t  {\n+\t    ReportMultipleCandidateError::Report (candidates,\n+\t\t\t\t\t\t  seg.get_segment (),\n+\t\t\t\t\t\t  seg.get_locus ());\n+\t    return;\n+\t  }\n+\n+\tauto &candidate = candidates.at (0);\n+\tprev_segment = tyseg;\n+\ttyseg = candidate.ty;\n+\n+\tif (candidate.is_impl_candidate ())\n+\t  {\n+\t    resolved_node_id\n+\t      = candidate.item.impl.impl_item->get_impl_mappings ()\n+\t\t  .get_nodeid ();\n+\t  }\n+\telse\n+\t  {\n+\t    resolved_node_id\n+\t      = candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n+\t  }\n+\n+\tif (seg.has_generic_args ())\n+\t  {\n+\t    if (!tyseg->can_substitute ())\n+\t      {\n+\t\trust_error_at (expr_locus, \"substitutions not supported for %s\",\n+\t\t\t       tyseg->as_string ().c_str ());\n+\t\treturn;\n+\t      }\n+\n+\t    tyseg = SubstMapper::Resolve (tyseg, expr_locus,\n+\t\t\t\t\t  &seg.get_generic_args ());\n+\t    if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+\t      return;\n+\t  }\n+      }\n+\n+    context->insert_receiver (expr_mappings.get_hirid (), prev_segment);\n+    if (tyseg->needs_generic_substitutions ())\n+      {\n+\tLocation locus = segments.back ().get_locus ();\n+\tif (!prev_segment->needs_generic_substitutions ())\n+\t  {\n+\t    auto used_args_in_prev_segment\n+\t      = GetUsedSubstArgs::From (prev_segment);\n+\t    if (!used_args_in_prev_segment.is_error ())\n+\t      tyseg = SubstMapperInternal::Resolve (tyseg,\n+\t\t\t\t\t\t    used_args_in_prev_segment);\n+\t  }\n+\telse\n+\t  {\n+\t    tyseg = SubstMapper::InferSubst (tyseg, locus);\n+\t  }\n+\n+\tif (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+\t  return;\n+      }\n+\n+    rust_assert (resolved_node_id != UNKNOWN_NODEID);\n+\n+    // lookup if the name resolver was able to canonically resolve this or not\n+    NodeId path_resolved_id = UNKNOWN_NODEID;\n+    if (resolver->lookup_resolved_name (expr_mappings.get_nodeid (),\n+\t\t\t\t\t&path_resolved_id))\n+      {\n+\trust_assert (path_resolved_id == resolved_node_id);\n+      }\n+    // check the type scope\n+    else if (resolver->lookup_resolved_type (expr_mappings.get_nodeid (),\n+\t\t\t\t\t     &path_resolved_id))\n+      {\n+\trust_assert (path_resolved_id == resolved_node_id);\n+      }\n+    else\n+      {\n+\tresolver->insert_resolved_name (expr_mappings.get_nodeid (),\n+\t\t\t\t\tresolved_node_id);\n+      }\n+\n+    infered = tyseg;\n+  }\n+\n   bool\n   validate_arithmetic_type (TyTy::BaseType *type,\n \t\t\t    HIR::ArithmeticOrLogicalExpr::ExprType expr_type)"}]}