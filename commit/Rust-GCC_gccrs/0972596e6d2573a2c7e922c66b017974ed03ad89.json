{"sha": "0972596e6d2573a2c7e922c66b017974ed03ad89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk3MjU5NmU2ZDI1NzNhMmM3ZTkyMmM2NmIwMTc5NzRlZDAzYWQ4OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T17:59:00Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T17:59:00Z"}, "message": "Add support for reductions in fully-masked loops\n\nThis patch removes the restriction that fully-masked loops cannot\nhave reductions.  The key thing here is to make sure that the\nreduction accumulator doesn't include any values associated with\ninactive lanes; the patch adds a bunch of conditional binary\noperations for doing that.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* doc/md.texi (cond_add@var{mode}, cond_sub@var{mode})\n\t(cond_and@var{mode}, cond_ior@var{mode}, cond_xor@var{mode})\n\t(cond_smin@var{mode}, cond_smax@var{mode}, cond_umin@var{mode})\n\t(cond_umax@var{mode}): Document.\n\t* optabs.def (cond_add_optab, cond_sub_optab, cond_and_optab)\n\t(cond_ior_optab, cond_xor_optab, cond_smin_optab, cond_smax_optab)\n\t(cond_umin_optab, cond_umax_optab): New optabs.\n\t* internal-fn.def (COND_ADD, COND_SUB, COND_MIN, COND_MAX, COND_AND)\n\t(COND_IOR, COND_XOR): New internal functions.\n\t* internal-fn.h (get_conditional_internal_fn): Declare.\n\t* internal-fn.c (cond_binary_direct): New macro.\n\t(expand_cond_binary_optab_fn): Likewise.\n\t(direct_cond_binary_optab_supported_p): Likewise.\n\t(get_conditional_internal_fn): New function.\n\t* tree-vect-loop.c (vectorizable_reduction): Handle fully-masked loops.\n\tCope with reduction statements that are vectorized as calls rather\n\tthan assignments.\n\t* config/aarch64/aarch64-sve.md (cond_<optab><mode>): New insns.\n\t* config/aarch64/iterators.md (UNSPEC_COND_ADD, UNSPEC_COND_SUB)\n\t(UNSPEC_COND_SMAX, UNSPEC_COND_UMAX, UNSPEC_COND_SMIN)\n\t(UNSPEC_COND_UMIN, UNSPEC_COND_AND, UNSPEC_COND_ORR)\n\t(UNSPEC_COND_EOR): New unspecs.\n\t(optab): Add mappings for them.\n\t(SVE_COND_INT_OP, SVE_COND_FP_OP): New int iterators.\n\t(sve_int_op, sve_fp_op): New int attributes.\n\ngcc/testsuite/\n\t* gcc.dg/vect/pr60482.c: Remove XFAIL for variable-length vectors.\n\t* gcc.target/aarch64/sve/reduc_1.c: Expect the loop operations\n\tto be predicated.\n\t* gcc.target/aarch64/sve/slp_5.c: Check for a fully-masked loop.\n\t* gcc.target/aarch64/sve/slp_7.c: Likewise.\n\t* gcc.target/aarch64/sve/reduc_5.c: New test.\n\t* gcc.target/aarch64/sve/slp_13.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_13_run.c: Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256626", "tree": {"sha": "6480f2b68dc621ec33ca6970ec346cd38bc3a6a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6480f2b68dc621ec33ca6970ec346cd38bc3a6a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0972596e6d2573a2c7e922c66b017974ed03ad89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0972596e6d2573a2c7e922c66b017974ed03ad89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0972596e6d2573a2c7e922c66b017974ed03ad89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0972596e6d2573a2c7e922c66b017974ed03ad89/comments", "author": null, "committer": null, "parents": [{"sha": "7cfb4d93595da03abb4e6414758dc98eb7532b34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cfb4d93595da03abb4e6414758dc98eb7532b34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cfb4d93595da03abb4e6414758dc98eb7532b34"}], "stats": {"total": 491, "additions": 442, "deletions": 49}, "files": [{"sha": "c08d2b35e5e7a7a90c92d91feccf5382d5a5deeb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0972596e6d2573a2c7e922c66b017974ed03ad89", "patch": "@@ -1,3 +1,33 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* doc/md.texi (cond_add@var{mode}, cond_sub@var{mode})\n+\t(cond_and@var{mode}, cond_ior@var{mode}, cond_xor@var{mode})\n+\t(cond_smin@var{mode}, cond_smax@var{mode}, cond_umin@var{mode})\n+\t(cond_umax@var{mode}): Document.\n+\t* optabs.def (cond_add_optab, cond_sub_optab, cond_and_optab)\n+\t(cond_ior_optab, cond_xor_optab, cond_smin_optab, cond_smax_optab)\n+\t(cond_umin_optab, cond_umax_optab): New optabs.\n+\t* internal-fn.def (COND_ADD, COND_SUB, COND_MIN, COND_MAX, COND_AND)\n+\t(COND_IOR, COND_XOR): New internal functions.\n+\t* internal-fn.h (get_conditional_internal_fn): Declare.\n+\t* internal-fn.c (cond_binary_direct): New macro.\n+\t(expand_cond_binary_optab_fn): Likewise.\n+\t(direct_cond_binary_optab_supported_p): Likewise.\n+\t(get_conditional_internal_fn): New function.\n+\t* tree-vect-loop.c (vectorizable_reduction): Handle fully-masked loops.\n+\tCope with reduction statements that are vectorized as calls rather\n+\tthan assignments.\n+\t* config/aarch64/aarch64-sve.md (cond_<optab><mode>): New insns.\n+\t* config/aarch64/iterators.md (UNSPEC_COND_ADD, UNSPEC_COND_SUB)\n+\t(UNSPEC_COND_SMAX, UNSPEC_COND_UMAX, UNSPEC_COND_SMIN)\n+\t(UNSPEC_COND_UMIN, UNSPEC_COND_AND, UNSPEC_COND_ORR)\n+\t(UNSPEC_COND_EOR): New unspecs.\n+\t(optab): Add mappings for them.\n+\t(SVE_COND_INT_OP, SVE_COND_FP_OP): New int iterators.\n+\t(sve_int_op, sve_fp_op): New int attributes.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "0329fedb15096f0ae1cc1bd59679d019300ba43e", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=0972596e6d2573a2c7e922c66b017974ed03ad89", "patch": "@@ -1417,6 +1417,18 @@\n   \"<maxmin_uns_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n )\n \n+;; Predicated integer operations.\n+(define_insn \"cond_<optab><mode>\"\n+  [(set (match_operand:SVE_I 0 \"register_operand\" \"=w\")\n+\t(unspec:SVE_I\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n+\t   (match_operand:SVE_I 2 \"register_operand\" \"0\")\n+\t   (match_operand:SVE_I 3 \"register_operand\" \"w\")]\n+\t  SVE_COND_INT_OP))]\n+  \"TARGET_SVE\"\n+  \"<sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+)\n+\n ;; Unpredicated integer add reduction.\n (define_expand \"reduc_plus_scal_<mode>\"\n   [(set (match_operand:<VEL> 0 \"register_operand\")\n@@ -2094,6 +2106,18 @@\n   }\n )\n \n+;; Predicated floating-point operations.\n+(define_insn \"cond_<optab><mode>\"\n+  [(set (match_operand:SVE_F 0 \"register_operand\" \"=w\")\n+\t(unspec:SVE_F\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n+\t   (match_operand:SVE_F 2 \"register_operand\" \"0\")\n+\t   (match_operand:SVE_F 3 \"register_operand\" \"w\")]\n+\t  SVE_COND_FP_OP))]\n+  \"TARGET_SVE\"\n+  \"<sve_fp_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+)\n+\n ;; Shift an SVE vector left and insert a scalar into element 0.\n (define_insn \"vec_shl_insert_<mode>\"\n   [(set (match_operand:SVE_ALL 0 \"register_operand\" \"=w, w\")"}, {"sha": "c380b3bfecf9da67bb16fd72bf59afc8a0af9b33", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=0972596e6d2573a2c7e922c66b017974ed03ad89", "patch": "@@ -432,6 +432,15 @@\n     UNSPEC_ANDF\t\t; Used in aarch64-sve.md.\n     UNSPEC_IORF\t\t; Used in aarch64-sve.md.\n     UNSPEC_XORF\t\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_ADD\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_SUB\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_SMAX\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_UMAX\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_SMIN\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_UMIN\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_AND\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_ORR\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_EOR\t; Used in aarch64-sve.md.\n     UNSPEC_COND_LT\t; Used in aarch64-sve.md.\n     UNSPEC_COND_LE\t; Used in aarch64-sve.md.\n     UNSPEC_COND_EQ\t; Used in aarch64-sve.md.\n@@ -1452,6 +1461,15 @@\n \n (define_int_iterator UNPACK_UNSIGNED [UNSPEC_UNPACKULO UNSPEC_UNPACKUHI])\n \n+(define_int_iterator SVE_COND_INT_OP [UNSPEC_COND_ADD UNSPEC_COND_SUB\n+\t\t\t\t      UNSPEC_COND_SMAX UNSPEC_COND_UMAX\n+\t\t\t\t      UNSPEC_COND_SMIN UNSPEC_COND_UMIN\n+\t\t\t\t      UNSPEC_COND_AND\n+\t\t\t\t      UNSPEC_COND_ORR\n+\t\t\t\t      UNSPEC_COND_EOR])\n+\n+(define_int_iterator SVE_COND_FP_OP [UNSPEC_COND_ADD UNSPEC_COND_SUB])\n+\n (define_int_iterator SVE_COND_INT_CMP [UNSPEC_COND_LT UNSPEC_COND_LE\n \t\t\t\t       UNSPEC_COND_EQ UNSPEC_COND_NE\n \t\t\t\t       UNSPEC_COND_GE UNSPEC_COND_GT\n@@ -1484,7 +1502,16 @@\n \t\t\t(UNSPEC_XORF \"xor\")\n \t\t\t(UNSPEC_ANDV \"and\")\n \t\t\t(UNSPEC_IORV \"ior\")\n-\t\t\t(UNSPEC_XORV \"xor\")])\n+\t\t\t(UNSPEC_XORV \"xor\")\n+\t\t\t(UNSPEC_COND_ADD \"add\")\n+\t\t\t(UNSPEC_COND_SUB \"sub\")\n+\t\t\t(UNSPEC_COND_SMAX \"smax\")\n+\t\t\t(UNSPEC_COND_UMAX \"umax\")\n+\t\t\t(UNSPEC_COND_SMIN \"smin\")\n+\t\t\t(UNSPEC_COND_UMIN \"umin\")\n+\t\t\t(UNSPEC_COND_AND \"and\")\n+\t\t\t(UNSPEC_COND_ORR \"ior\")\n+\t\t\t(UNSPEC_COND_EOR \"xor\")])\n \n (define_int_attr  maxmin_uns [(UNSPEC_UMAXV \"umax\")\n \t\t\t      (UNSPEC_UMINV \"umin\")\n@@ -1696,3 +1723,16 @@\n \t\t\t  (UNSPEC_COND_LS \"vsd\")\n \t\t\t  (UNSPEC_COND_HS \"vsd\")\n \t\t\t  (UNSPEC_COND_HI \"vsd\")])\n+\n+(define_int_attr sve_int_op [(UNSPEC_COND_ADD \"add\")\n+\t\t\t     (UNSPEC_COND_SUB \"sub\")\n+\t\t\t     (UNSPEC_COND_SMAX \"smax\")\n+\t\t\t     (UNSPEC_COND_UMAX \"umax\")\n+\t\t\t     (UNSPEC_COND_SMIN \"smin\")\n+\t\t\t     (UNSPEC_COND_UMIN \"umin\")\n+\t\t\t     (UNSPEC_COND_AND \"and\")\n+\t\t\t     (UNSPEC_COND_ORR \"orr\")\n+\t\t\t     (UNSPEC_COND_EOR \"eor\")])\n+\n+(define_int_attr sve_fp_op [(UNSPEC_COND_ADD \"fadd\")\n+\t\t\t    (UNSPEC_COND_SUB \"fsub\")])"}, {"sha": "285cffd22f64c98746d07bed657677212f84989e", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=0972596e6d2573a2c7e922c66b017974ed03ad89", "patch": "@@ -6248,6 +6248,42 @@ move operand 2 or (operands 2 + operand 3) into operand 0 according to the\n comparison in operand 1.  If the comparison is false, operand 2 is moved into\n operand 0, otherwise (operand 2 + operand 3) is moved.\n \n+@cindex @code{cond_add@var{mode}} instruction pattern\n+@cindex @code{cond_sub@var{mode}} instruction pattern\n+@cindex @code{cond_and@var{mode}} instruction pattern\n+@cindex @code{cond_ior@var{mode}} instruction pattern\n+@cindex @code{cond_xor@var{mode}} instruction pattern\n+@cindex @code{cond_smin@var{mode}} instruction pattern\n+@cindex @code{cond_smax@var{mode}} instruction pattern\n+@cindex @code{cond_umin@var{mode}} instruction pattern\n+@cindex @code{cond_umax@var{mode}} instruction pattern\n+@item @samp{cond_add@var{mode}}\n+@itemx @samp{cond_sub@var{mode}}\n+@itemx @samp{cond_and@var{mode}}\n+@itemx @samp{cond_ior@var{mode}}\n+@itemx @samp{cond_xor@var{mode}}\n+@itemx @samp{cond_smin@var{mode}}\n+@itemx @samp{cond_smax@var{mode}}\n+@itemx @samp{cond_umin@var{mode}}\n+@itemx @samp{cond_umax@var{mode}}\n+Perform an elementwise operation on vector operands 2 and 3,\n+under the control of the vector mask in operand 1, and store the result\n+in operand 0.  This is equivalent to:\n+\n+@smallexample\n+for (i = 0; i < GET_MODE_NUNITS (@var{n}); i++)\n+  op0[i] = op1[i] ? op2[i] @var{op} op3[i] : op2[i];\n+@end smallexample\n+\n+where, for example, @var{op} is @code{+} for @samp{cond_add@var{mode}}.\n+\n+When defined for floating-point modes, the contents of @samp{op3[i]}\n+are not interpreted if @var{op1[i]} is false, just like they would not\n+be in a normal C @samp{?:} condition.\n+\n+Operands 0, 2 and 3 all have mode @var{m}, while operand 1 has the mode\n+returned by @code{TARGET_VECTORIZE_GET_MASK_MODE}.\n+\n @cindex @code{neg@var{mode}cc} instruction pattern\n @item @samp{neg@var{mode}cc}\n Similar to @samp{mov@var{mode}cc} but for conditional negation.  Conditionally"}, {"sha": "bc4027bd60359696f06d9c263c4a9bb658be3327", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=0972596e6d2573a2c7e922c66b017974ed03ad89", "patch": "@@ -88,6 +88,7 @@ init_internal_fns ()\n #define mask_store_lanes_direct { 0, 0, false }\n #define unary_direct { 0, 0, true }\n #define binary_direct { 0, 0, true }\n+#define cond_binary_direct { 1, 1, true }\n #define while_direct { 0, 2, false }\n \n const direct_internal_fn_info direct_internal_fn_array[IFN_LAST + 1] = {\n@@ -2855,6 +2856,9 @@ expand_while_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n #define expand_binary_optab_fn(FN, STMT, OPTAB) \\\n   expand_direct_optab_fn (FN, STMT, OPTAB, 2)\n \n+#define expand_cond_binary_optab_fn(FN, STMT, OPTAB) \\\n+  expand_direct_optab_fn (FN, STMT, OPTAB, 3)\n+\n /* RETURN_TYPE and ARGS are a return type and argument list that are\n    in principle compatible with FN (which satisfies direct_internal_fn_p).\n    Return the types that should be used to determine whether the\n@@ -2928,6 +2932,7 @@ multi_vector_optab_supported_p (convert_optab optab, tree_pair types,\n \n #define direct_unary_optab_supported_p direct_optab_supported_p\n #define direct_binary_optab_supported_p direct_optab_supported_p\n+#define direct_cond_binary_optab_supported_p direct_optab_supported_p\n #define direct_mask_load_optab_supported_p direct_optab_supported_p\n #define direct_load_lanes_optab_supported_p multi_vector_optab_supported_p\n #define direct_mask_load_lanes_optab_supported_p multi_vector_optab_supported_p\n@@ -3049,6 +3054,37 @@ static void (*const internal_fn_expanders[]) (internal_fn, gcall *) = {\n   0\n };\n \n+/* Return a function that performs the conditional form of CODE, i.e.:\n+\n+     LHS = RHS1 ? RHS2 CODE RHS3 : RHS2\n+\n+   (operating elementwise if the operands are vectors).  Return IFN_LAST\n+   if no such function exists.  */\n+\n+internal_fn\n+get_conditional_internal_fn (tree_code code)\n+{\n+  switch (code)\n+    {\n+    case PLUS_EXPR:\n+      return IFN_COND_ADD;\n+    case MINUS_EXPR:\n+      return IFN_COND_SUB;\n+    case MIN_EXPR:\n+      return IFN_COND_MIN;\n+    case MAX_EXPR:\n+      return IFN_COND_MAX;\n+    case BIT_AND_EXPR:\n+      return IFN_COND_AND;\n+    case BIT_IOR_EXPR:\n+      return IFN_COND_IOR;\n+    case BIT_XOR_EXPR:\n+      return IFN_COND_XOR;\n+    default:\n+      return IFN_LAST;\n+    }\n+}\n+\n /* Expand STMT as though it were a call to internal function FN.  */\n \n void"}, {"sha": "f0984402355a4a48ce567a7561e5bd41e0d93e71", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=0972596e6d2573a2c7e922c66b017974ed03ad89", "patch": "@@ -53,6 +53,11 @@ along with GCC; see the file COPYING3.  If not see\n    - store_lanes: currently just vec_store_lanes\n    - mask_store_lanes: currently just vec_mask_store_lanes\n \n+   - unary: a normal unary optab, such as vec_reverse_<mode>\n+   - binary: a normal binary optab, such as vec_interleave_lo_<mode>\n+\n+   - cond_binary: a conditional binary optab, such as add<mode>cc\n+\n    DEF_INTERNAL_SIGNED_OPTAB_FN defines an internal function that\n    maps to one of two optabs, depending on the signedness of an input.\n    SIGNED_OPTAB and UNSIGNED_OPTAB are the optabs for signed and\n@@ -121,6 +126,19 @@ DEF_INTERNAL_OPTAB_FN (WHILE_ULT, ECF_CONST | ECF_NOTHROW, while_ult, while)\n DEF_INTERNAL_OPTAB_FN (VEC_SHL_INSERT, ECF_CONST | ECF_NOTHROW,\n \t\t       vec_shl_insert, binary)\n \n+DEF_INTERNAL_OPTAB_FN (COND_ADD, ECF_CONST, cond_add, cond_binary)\n+DEF_INTERNAL_OPTAB_FN (COND_SUB, ECF_CONST, cond_sub, cond_binary)\n+DEF_INTERNAL_SIGNED_OPTAB_FN (COND_MIN, ECF_CONST, first,\n+\t\t\t      cond_smin, cond_umin, cond_binary)\n+DEF_INTERNAL_SIGNED_OPTAB_FN (COND_MAX, ECF_CONST, first,\n+\t\t\t      cond_smax, cond_umax, cond_binary)\n+DEF_INTERNAL_OPTAB_FN (COND_AND, ECF_CONST | ECF_NOTHROW,\n+\t\t       cond_and, cond_binary)\n+DEF_INTERNAL_OPTAB_FN (COND_IOR, ECF_CONST | ECF_NOTHROW,\n+\t\t       cond_ior, cond_binary)\n+DEF_INTERNAL_OPTAB_FN (COND_XOR, ECF_CONST | ECF_NOTHROW,\n+\t\t       cond_xor, cond_binary)\n+\n DEF_INTERNAL_OPTAB_FN (RSQRT, ECF_CONST, rsqrt, unary)\n \n DEF_INTERNAL_OPTAB_FN (REDUC_PLUS, ECF_CONST | ECF_NOTHROW,"}, {"sha": "0464e3f9e7a6229647e0eaeeaa9e521a4a8e48b8", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=0972596e6d2573a2c7e922c66b017974ed03ad89", "patch": "@@ -190,6 +190,8 @@ direct_internal_fn_supported_p (internal_fn fn, tree type0, tree type1,\n \n extern bool set_edom_supported_p (void);\n \n+extern internal_fn get_conditional_internal_fn (tree_code);\n+\n extern void expand_internal_call (gcall *);\n extern void expand_internal_call (internal_fn, gcall *);\n extern void expand_PHI (internal_fn, gcall *);"}, {"sha": "9a79f4d250baff3d2cb72f88398990da23613274", "filename": "gcc/optabs.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=0972596e6d2573a2c7e922c66b017974ed03ad89", "patch": "@@ -220,6 +220,15 @@ OPTAB_D (addcc_optab, \"add$acc\")\n OPTAB_D (negcc_optab, \"neg$acc\")\n OPTAB_D (notcc_optab, \"not$acc\")\n OPTAB_D (movcc_optab, \"mov$acc\")\n+OPTAB_D (cond_add_optab, \"cond_add$a\")\n+OPTAB_D (cond_sub_optab, \"cond_sub$a\")\n+OPTAB_D (cond_and_optab, \"cond_and$a\")\n+OPTAB_D (cond_ior_optab, \"cond_ior$a\")\n+OPTAB_D (cond_xor_optab, \"cond_xor$a\")\n+OPTAB_D (cond_smin_optab, \"cond_smin$a\")\n+OPTAB_D (cond_smax_optab, \"cond_smax$a\")\n+OPTAB_D (cond_umin_optab, \"cond_umin$a\")\n+OPTAB_D (cond_umax_optab, \"cond_umax$a\")\n OPTAB_D (cmov_optab, \"cmov$a6\")\n OPTAB_D (cstore_optab, \"cstore$a4\")\n OPTAB_D (ctrap_optab, \"ctrap$a4\")"}, {"sha": "7363c0d04a4acf9213262ff0202cd0eed6772c13", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0972596e6d2573a2c7e922c66b017974ed03ad89", "patch": "@@ -1,3 +1,16 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc.dg/vect/pr60482.c: Remove XFAIL for variable-length vectors.\n+\t* gcc.target/aarch64/sve/reduc_1.c: Expect the loop operations\n+\tto be predicated.\n+\t* gcc.target/aarch64/sve/slp_5.c: Check for a fully-masked loop.\n+\t* gcc.target/aarch64/sve/slp_7.c: Likewise.\n+\t* gcc.target/aarch64/sve/reduc_5.c: New test.\n+\t* gcc.target/aarch64/sve/slp_13.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_13_run.c: Likewise.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "4c5c20c810932ec042523121173b80f59f22cc9a", "filename": "gcc/testsuite/gcc.dg/vect/pr60482.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr60482.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr60482.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr60482.c?ref=0972596e6d2573a2c7e922c66b017974ed03ad89", "patch": "@@ -16,6 +16,4 @@ foo (double *x, int n)\n   return p;\n }\n \n-/* Until fully-masked loops are supported, we always need an epilog\n-   loop for variable-length vectors.  */\n-/* { dg-final { scan-tree-dump-not \"epilog loop required\" \"vect\" { xfail vect_variable_length } } } */\n+/* { dg-final { scan-tree-dump-not \"epilog loop required\" \"vect\" } } */"}, {"sha": "a258344b0a965e7fdc77d18e9991066e4c9521f8", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_1.c", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_1.c?ref=0972596e6d2573a2c7e922c66b017974ed03ad89", "patch": "@@ -105,10 +105,10 @@ reduc_##NAME##_##TYPE (TYPE *a, int n)\t\t\\\n \n TEST_BITWISE (DEF_REDUC_BITWISE)\n \n-/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.b, z[0-9]+\\.b, z[0-9]+\\.b\\n} 1 } } */\n-/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.h, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n-/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.s, z[0-9]+\\.s, z[0-9]+\\.s\\n} 2 } } */\n-/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.b, p[0-7]/m, z[0-9]+\\.b, z[0-9]+\\.b\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.s, p[0-7]/m, z[0-9]+\\.s, z[0-9]+\\.s\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.d, p[0-7]/m, z[0-9]+\\.d, z[0-9]+\\.d\\n} 2 } } */\n \n /* { dg-final { scan-assembler-times {\\tsmin\\tz[0-9]+\\.b, p[0-7]/m, z[0-9]+\\.b, z[0-9]+\\.b\\n} 1 } } */\n /* { dg-final { scan-assembler-times {\\tsmin\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n@@ -130,9 +130,9 @@ TEST_BITWISE (DEF_REDUC_BITWISE)\n /* { dg-final { scan-assembler-times {\\tumax\\tz[0-9]+\\.s, p[0-7]/m, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n /* { dg-final { scan-assembler-times {\\tumax\\tz[0-9]+\\.d, p[0-7]/m, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n \n-/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.h, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n-/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.s, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n-/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.s, p[0-7]/m, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.d, p[0-7]/m, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n \n /* { dg-final { scan-assembler-times {\\tfmaxnm\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n /* { dg-final { scan-assembler-times {\\tfmaxnm\\tz[0-9]+\\.s, p[0-7]/m, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n@@ -142,11 +142,20 @@ TEST_BITWISE (DEF_REDUC_BITWISE)\n /* { dg-final { scan-assembler-times {\\tfminnm\\tz[0-9]+\\.s, p[0-7]/m, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n /* { dg-final { scan-assembler-times {\\tfminnm\\tz[0-9]+\\.d, p[0-7]/m, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n \n-/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 8 } } */\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.b, p[0-7]/m, z[0-9]+\\.b, z[0-9]+\\.b\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.s, p[0-7]/m, z[0-9]+\\.s, z[0-9]+\\.s\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.d, p[0-7]/m, z[0-9]+\\.d, z[0-9]+\\.d\\n} 2 } } */\n \n-/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 8 } } */\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.b, p[0-7]/m, z[0-9]+\\.b, z[0-9]+\\.b\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.s, p[0-7]/m, z[0-9]+\\.s, z[0-9]+\\.s\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.d, p[0-7]/m, z[0-9]+\\.d, z[0-9]+\\.d\\n} 2 } } */\n \n-/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 8 } } */\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.b, p[0-7]/m, z[0-9]+\\.b, z[0-9]+\\.b\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.s, p[0-7]/m, z[0-9]+\\.s, z[0-9]+\\.s\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.d, p[0-7]/m, z[0-9]+\\.d, z[0-9]+\\.d\\n} 2 } } */\n \n /* { dg-final { scan-assembler-times {\\tuaddv\\td[0-9]+, p[0-7], z[0-9]+\\.b\\n} 1 } } */\n /* { dg-final { scan-assembler-times {\\tuaddv\\td[0-9]+, p[0-7], z[0-9]+\\.h\\n} 1 } } */\n@@ -180,17 +189,17 @@ TEST_BITWISE (DEF_REDUC_BITWISE)\n /* { dg-final { scan-assembler-times {\\tfminnmv\\ts[0-9]+, p[0-7], z[0-9]+\\.s\\n} 1 } } */\n /* { dg-final { scan-assembler-times {\\tfminnmv\\td[0-9]+, p[0-7], z[0-9]+\\.d\\n} 1 } } */\n \n-/* { dg-final { scan-assembler-times {\\tandv\\tb[0-9]+, p[0-7], z[0-9]+\\.b} 2 } } */\n-/* { dg-final { scan-assembler-times {\\tandv\\th[0-9]+, p[0-7], z[0-9]+\\.h} 2 } } */\n-/* { dg-final { scan-assembler-times {\\tandv\\ts[0-9]+, p[0-7], z[0-9]+\\.s} 2 } } */\n-/* { dg-final { scan-assembler-times {\\tandv\\td[0-9]+, p[0-7], z[0-9]+\\.d} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tandv\\tb[0-9]+, p[0-7], z[0-9]+\\.b\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tandv\\th[0-9]+, p[0-7], z[0-9]+\\.h\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tandv\\ts[0-9]+, p[0-7], z[0-9]+\\.s\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tandv\\td[0-9]+, p[0-7], z[0-9]+\\.d\\n} 2 } } */\n \n-/* { dg-final { scan-assembler-times {\\torv\\tb[0-9]+, p[0-7], z[0-9]+\\.b} 2 } } */\n-/* { dg-final { scan-assembler-times {\\torv\\th[0-9]+, p[0-7], z[0-9]+\\.h} 2 } } */\n-/* { dg-final { scan-assembler-times {\\torv\\ts[0-9]+, p[0-7], z[0-9]+\\.s} 2 } } */\n-/* { dg-final { scan-assembler-times {\\torv\\td[0-9]+, p[0-7], z[0-9]+\\.d} 2 } } */\n+/* { dg-final { scan-assembler-times {\\torv\\tb[0-9]+, p[0-7], z[0-9]+\\.b\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\torv\\th[0-9]+, p[0-7], z[0-9]+\\.h\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\torv\\ts[0-9]+, p[0-7], z[0-9]+\\.s\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\torv\\td[0-9]+, p[0-7], z[0-9]+\\.d\\n} 2 } } */\n \n-/* { dg-final { scan-assembler-times {\\teorv\\tb[0-9]+, p[0-7], z[0-9]+\\.b} 2 } } */\n-/* { dg-final { scan-assembler-times {\\teorv\\th[0-9]+, p[0-7], z[0-9]+\\.h} 2 } } */\n-/* { dg-final { scan-assembler-times {\\teorv\\ts[0-9]+, p[0-7], z[0-9]+\\.s} 2 } } */\n-/* { dg-final { scan-assembler-times {\\teorv\\td[0-9]+, p[0-7], z[0-9]+\\.d} 2 } } */\n+/* { dg-final { scan-assembler-times {\\teorv\\tb[0-9]+, p[0-7], z[0-9]+\\.b\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\teorv\\th[0-9]+, p[0-7], z[0-9]+\\.h\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\teorv\\ts[0-9]+, p[0-7], z[0-9]+\\.s\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\teorv\\td[0-9]+, p[0-7], z[0-9]+\\.d\\n} 2 } } */"}, {"sha": "ff535942331be1e5399c3ef902e08f442ba8786b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_5.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_5.c?ref=0972596e6d2573a2c7e922c66b017974ed03ad89", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#include <stdint.h>\n+\n+#define REDUC(TYPE)\t\t\t\t\t\t\\\n+  TYPE reduc_##TYPE (TYPE *x, int count)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    TYPE sum = 0;\t\t\t\t\t\t\\\n+    for (int i = 0; i < count; ++i)\t\t\t\t\\\n+      sum -= x[i];\t\t\t\t\t\t\\\n+    return sum;\t\t\t\t\t\t\t\\\n+  }\n+\n+REDUC (int8_t)\n+REDUC (uint8_t)\n+REDUC (int16_t)\n+REDUC (uint16_t)\n+REDUC (int32_t)\n+REDUC (uint32_t)\n+REDUC (int64_t)\n+REDUC (uint64_t)\n+REDUC (float)\n+REDUC (double)\n+\n+/* XFAILed until we support sub-int reductions for signed types.  */\n+/* { dg-final { scan-assembler-times {\\tsub\\tz[0-9]+\\.b, p[0-7]/m} 2 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tsub\\tz[0-9]+\\.h, p[0-7]/m} 2 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tsub\\tz[0-9]+\\.b, p[0-7]/m} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsub\\tz[0-9]+\\.h, p[0-7]/m} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsub\\tz[0-9]+\\.s, p[0-7]/m} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tsub\\tz[0-9]+\\.d, p[0-7]/m} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfsub\\tz[0-9]+\\.s, p[0-7]/m} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfsub\\tz[0-9]+\\.d, p[0-7]/m} 1 } } */\n+\n+/* XFAILed until we support sub-int reductions for signed types.  */\n+/* { dg-final { scan-assembler-times {\\tsub\\t} 8 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tfsub\\t} 2 } } */"}, {"sha": "5b875bfcc32c3d9e44329542f171529a053e5dfe", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_13.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_13.c?ref=0972596e6d2573a2c7e922c66b017974ed03ad89", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=scalable\" } */\n+\n+#include <stdint.h>\n+\n+#define VEC_PERM(TYPE)\t\t\t\t\t\t\\\n+TYPE __attribute__ ((noinline, noclone))\t\t\t\\\n+vec_slp_##TYPE (TYPE *restrict a, int n)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  TYPE res = 0;\t\t\t\t\t\t\t\\\n+  for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      res += a[i * 2] * 3;\t\t\t\t\t\\\n+      res += a[i * 2 + 1] * 5;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  return res;\t\t\t\t\t\t\t\\\n+}\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int8_t)\t\t\t\t\t\\\n+  T (uint8_t)\t\t\t\t\t\\\n+  T (int16_t)\t\t\t\t\t\\\n+  T (uint16_t)\t\t\t\t\t\\\n+  T (int32_t)\t\t\t\t\t\\\n+  T (uint32_t)\t\t\t\t\t\\\n+  T (int64_t)\t\t\t\t\t\\\n+  T (uint64_t)\n+\n+TEST_ALL (VEC_PERM)\n+\n+/* ??? We don't treat the int8_t and int16_t loops as reductions.  */\n+/* ??? We don't treat the uint loops as SLP.  */\n+/* The loop should be fully-masked.  */\n+/* { dg-final { scan-assembler-times {\\tld1b\\t} 2 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\t} 2 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\t} 2 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\t} 2 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\t} 1 } } */\n+/* { dg-final { scan-assembler-not {\\tldr} { xfail *-*-* } } } */\n+\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b} 4 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h} 4 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s} 4 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d} 4 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tuaddv\\td[0-9]+, p[0-7], z[0-9]+\\.b\\n} 2 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tuaddv\\td[0-9]+, p[0-7], z[0-9]+\\.h\\n} 2 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tuaddv\\td[0-9]+, p[0-7], z[0-9]+\\.s\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tuaddv\\td[0-9]+, p[0-7], z[0-9]+\\.d\\n} 2 } } */\n+\n+/* { dg-final { scan-assembler-not {\\tuqdec} } } */"}, {"sha": "9799e3b59fb67656355f828c1116f5049d295caa", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_13_run.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_13_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_13_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_13_run.c?ref=0972596e6d2573a2c7e922c66b017974ed03ad89", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"slp_13.c\"\n+\n+#define N1 (103 * 2)\n+#define N2 (111 * 2)\n+\n+#define HARNESS(TYPE)\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    TYPE a[N2];\t\t\t\t\t\t\t\\\n+    TYPE expected = 0;\t\t\t\t\t\t\\\n+    for (unsigned int i = 0; i < N2; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\ta[i] = i * 2 + i % 5;\t\t\t\t\t\\\n+\tif (i < N1)\t\t\t\t\t\t\\\n+\t  expected += a[i] * (i & 1 ? 5 : 3);\t\t\t\\\n+\tasm volatile (\"\");\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    if (vec_slp_##TYPE (a, N1 / 2) != expected)\t\t\t\\\n+      __builtin_abort ();\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  TEST_ALL (HARNESS)\n+}"}, {"sha": "7ff12c58570282e59328c37ddfe000f90bad91ff", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_5.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_5.c?ref=0972596e6d2573a2c7e922c66b017974ed03ad89", "patch": "@@ -56,3 +56,12 @@ TEST_ALL (VEC_PERM)\n /* { dg-final { scan-assembler-times {\\tfaddv\\th[0-9]+, p[0-7], z[0-9]+\\.h} 2 } } */\n /* { dg-final { scan-assembler-times {\\tfaddv\\ts[0-9]+, p[0-7], z[0-9]+\\.s} 2 } } */\n /* { dg-final { scan-assembler-times {\\tfaddv\\td[0-9]+, p[0-7], z[0-9]+\\.d} 2 } } */\n+\n+/* Should be 4 and 6 respectively, if we used reductions for int8_t and\n+   int16_t.  */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h} 4 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s} 6 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d} 6 } } */\n+\n+/* { dg-final { scan-assembler-not {\\tuqdec} } } */"}, {"sha": "9e6aa8ccbf81c204edc5f9faa37292f0180f0c4d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_7.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_7.c?ref=0972596e6d2573a2c7e922c66b017974ed03ad89", "patch": "@@ -64,3 +64,12 @@ TEST_ALL (VEC_PERM)\n /* { dg-final { scan-assembler-times {\\tfaddv\\th[0-9]+, p[0-7], z[0-9]+\\.h} 4 } } */\n /* { dg-final { scan-assembler-times {\\tfaddv\\ts[0-9]+, p[0-7], z[0-9]+\\.s} 4 } } */\n /* { dg-final { scan-assembler-times {\\tfaddv\\td[0-9]+, p[0-7], z[0-9]+\\.d} 4 } } */\n+\n+/* Should be 4 and 6 respectively, if we used reductions for int8_t and\n+   int16_t.  */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h} 4 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s} 6 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d} 6 } } */\n+\n+/* { dg-final { scan-assembler-not {\\tuqdec} } } */"}, {"sha": "15d36b2e8396f5f1b2103117a1034adbebd093eb", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 65, "deletions": 23, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0972596e6d2573a2c7e922c66b017974ed03ad89/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=0972596e6d2573a2c7e922c66b017974ed03ad89", "patch": "@@ -6893,19 +6893,42 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       return false;\n     }\n \n+  if (slp_node)\n+    vec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n+  else\n+    vec_num = 1;\n+\n+  internal_fn cond_fn = get_conditional_internal_fn (code);\n+  vec_loop_masks *masks = &LOOP_VINFO_MASKS (loop_vinfo);\n+\n   if (!vec_stmt) /* transformation not required.  */\n     {\n-      if (LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo))\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"can't use a fully-masked loop due to \"\n-\t\t\t     \"reduction operation.\\n\");\n-\t  LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo) = false;\n-\t}\n-\n       if (first_p)\n \tvect_model_reduction_cost (stmt_info, reduc_fn, ncopies);\n+      if (loop_vinfo && LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo))\n+\t{\n+\t  if (cond_fn == IFN_LAST\n+\t      || !direct_internal_fn_supported_p (cond_fn, vectype_in,\n+\t\t\t\t\t\t  OPTIMIZE_FOR_SPEED))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"can't use a fully-masked loop because no\"\n+\t\t\t\t \" conditional operation is available.\\n\");\n+\t      LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo) = false;\n+\t    }\n+\t  else if (reduc_index == -1)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"can't use a fully-masked loop for chained\"\n+\t\t\t\t \" reductions.\\n\");\n+\t      LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo) = false;\n+\t    }\n+\t  else\n+\t    vect_record_loop_mask (loop_vinfo, masks, ncopies * vec_num,\n+\t\t\t\t   vectype_in);\n+\t}\n       STMT_VINFO_TYPE (stmt_info) = reduc_vec_info_type;\n       return true;\n     }\n@@ -6919,16 +6942,15 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (code == COND_EXPR)\n     gcc_assert (ncopies == 1);\n \n+  bool masked_loop_p = LOOP_VINFO_FULLY_MASKED_P (loop_vinfo);\n+\n   /* Create the destination vector  */\n   vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n \n   prev_stmt_info = NULL;\n   prev_phi_info = NULL;\n-  if (slp_node)\n-    vec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n-  else\n+  if (!slp_node)\n     {\n-      vec_num = 1;\n       vec_oprnds0.create (1);\n       vec_oprnds1.create (1);\n       if (op_type == ternary_op)\n@@ -7002,19 +7024,19 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      gcc_assert (reduc_index != -1 || ! single_defuse_cycle);\n \n \t      if (single_defuse_cycle && reduc_index == 0)\n-\t\tvec_oprnds0[0] = gimple_assign_lhs (new_stmt);\n+\t\tvec_oprnds0[0] = gimple_get_lhs (new_stmt);\n \t      else\n \t\tvec_oprnds0[0]\n \t\t  = vect_get_vec_def_for_stmt_copy (dts[0], vec_oprnds0[0]);\n \t      if (single_defuse_cycle && reduc_index == 1)\n-\t\tvec_oprnds1[0] = gimple_assign_lhs (new_stmt);\n+\t\tvec_oprnds1[0] = gimple_get_lhs (new_stmt);\n \t      else\n \t\tvec_oprnds1[0]\n \t\t  = vect_get_vec_def_for_stmt_copy (dts[1], vec_oprnds1[0]);\n \t      if (op_type == ternary_op)\n \t\t{\n \t\t  if (single_defuse_cycle && reduc_index == 2)\n-\t\t    vec_oprnds2[0] = gimple_assign_lhs (new_stmt);\n+\t\t    vec_oprnds2[0] = gimple_get_lhs (new_stmt);\n \t\t  else\n \t\t    vec_oprnds2[0] \n \t\t      = vect_get_vec_def_for_stmt_copy (dts[2], vec_oprnds2[0]);\n@@ -7025,13 +7047,33 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       FOR_EACH_VEC_ELT (vec_oprnds0, i, def0)\n         {\n \t  tree vop[3] = { def0, vec_oprnds1[i], NULL_TREE };\n-\t  if (op_type == ternary_op)\n-\t    vop[2] = vec_oprnds2[i];\n+\t  if (masked_loop_p)\n+\t    {\n+\t      /* Make sure that the reduction accumulator is vop[0].  */\n+\t      if (reduc_index == 1)\n+\t\t{\n+\t\t  gcc_assert (commutative_tree_code (code));\n+\t\t  std::swap (vop[0], vop[1]);\n+\t\t}\n+\t      tree mask = vect_get_loop_mask (gsi, masks, vec_num * ncopies,\n+\t\t\t\t\t      vectype_in, i * ncopies + j);\n+\t      gcall *call = gimple_build_call_internal (cond_fn, 3, mask,\n+\t\t\t\t\t\t\tvop[0], vop[1]);\n+\t      new_temp = make_ssa_name (vec_dest, call);\n+\t      gimple_call_set_lhs (call, new_temp);\n+\t      gimple_call_set_nothrow (call, true);\n+\t      new_stmt = call;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (op_type == ternary_op)\n+\t\tvop[2] = vec_oprnds2[i];\n \n-          new_temp = make_ssa_name (vec_dest, new_stmt);\n-          new_stmt = gimple_build_assign (new_temp, code,\n-\t\t\t\t\t  vop[0], vop[1], vop[2]);\n-          vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t      new_temp = make_ssa_name (vec_dest, new_stmt);\n+\t      new_stmt = gimple_build_assign (new_temp, code,\n+\t\t\t\t\t      vop[0], vop[1], vop[2]);\n+\t    }\n+\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \n           if (slp_node)\n             {\n@@ -7056,7 +7098,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   /* Finalize the reduction-phi (set its arguments) and create the\n      epilog reduction code.  */\n   if ((!single_defuse_cycle || code == COND_EXPR) && !slp_node)\n-    vect_defs[0] = gimple_assign_lhs (*vec_stmt);\n+    vect_defs[0] = gimple_get_lhs (*vec_stmt);\n \n   vect_create_epilog_for_reduction (vect_defs, stmt, reduc_def_stmt,\n \t\t\t\t    epilog_copies, reduc_fn, phis,"}]}