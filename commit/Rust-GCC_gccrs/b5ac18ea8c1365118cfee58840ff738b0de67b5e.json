{"sha": "b5ac18ea8c1365118cfee58840ff738b0de67b5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVhYzE4ZWE4YzEzNjUxMThjZmVlNTg4NDBmZjczOGIwZGU2N2I1ZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-29T17:24:21Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-29T17:24:21Z"}, "message": "cp-tree.h (TMPL_ARGS_HAVE_MULTIPLE_LEVELS): Move here from pt.c.\n\n\t* cp-tree.h (TMPL_ARGS_HAVE_MULTIPLE_LEVELS): Move here from pt.c.\n\t(TMPL_ARGS_DEPTH, TMPL_ARGS_LEVEL, SET_TMPL_ARGS_LEVEL): Likewise.\n\t(TMPL_ARG, SET_TMPL_ARG, NUM_TMPL_ARGS, TMPL_PARMS_DEPTH): Likewise.\n\t* error.c (dump_template_bindings): Remove unused parameter.\n\tHandle multiple levels of template parameters.\n\t(dump_template_decl): Use `parms', not `args', for template\n\tparameters.  Fix thinko.\n\t(dump_function_decl): Use DECL_TEMPLATE_INSTANTIATION.  Don't pass\n\tflags to dump_template_bindings.\n\t* pt.c (TMPL_ARGS_HAVE_MULTIPLE_LEVELS): Move to cp-tree.h.\n\t(TMPL_ARGS_DEPTH, TMPL_ARGS_LEVEL, SET_TMPL_ARGS_LEVEL): Likewise.\n\t(TMPL_ARG, SET_TMPL_ARG, NUM_TMPL_ARGS, TMPL_PARMS_DEPTH): Likewise.\n\t(tsubst_copy): Clarify variable name.\n\t(most_general_template): Robustify.\n\nFrom-SVN: r29708", "tree": {"sha": "775f4aa955fdfd22ef0cbf7763b5945fd4ab87e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/775f4aa955fdfd22ef0cbf7763b5945fd4ab87e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5ac18ea8c1365118cfee58840ff738b0de67b5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5ac18ea8c1365118cfee58840ff738b0de67b5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5ac18ea8c1365118cfee58840ff738b0de67b5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5ac18ea8c1365118cfee58840ff738b0de67b5e/comments", "author": null, "committer": null, "parents": [{"sha": "0acbb8d94d6268bff84fb87e6e7e25768b58911f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0acbb8d94d6268bff84fb87e6e7e25768b58911f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0acbb8d94d6268bff84fb87e6e7e25768b58911f"}], "stats": {"total": 230, "additions": 135, "deletions": 95}, "files": [{"sha": "56d78d4898a51f59a0203f88b378ba775ccea1d0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ac18ea8c1365118cfee58840ff738b0de67b5e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ac18ea8c1365118cfee58840ff738b0de67b5e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b5ac18ea8c1365118cfee58840ff738b0de67b5e", "patch": "@@ -1,3 +1,20 @@\n+1999-09-29  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (TMPL_ARGS_HAVE_MULTIPLE_LEVELS): Move here from pt.c.\n+\t(TMPL_ARGS_DEPTH, TMPL_ARGS_LEVEL, SET_TMPL_ARGS_LEVEL): Likewise.\n+\t(TMPL_ARG, SET_TMPL_ARG, NUM_TMPL_ARGS, TMPL_PARMS_DEPTH): Likewise.\n+\t* error.c (dump_template_bindings): Remove unused parameter.\n+\tHandle multiple levels of template parameters.\n+\t(dump_template_decl): Use `parms', not `args', for template\n+\tparameters.  Fix thinko.\n+\t(dump_function_decl): Use DECL_TEMPLATE_INSTANTIATION.  Don't pass\n+\tflags to dump_template_bindings.\n+\t* pt.c (TMPL_ARGS_HAVE_MULTIPLE_LEVELS): Move to cp-tree.h.\n+\t(TMPL_ARGS_DEPTH, TMPL_ARGS_LEVEL, SET_TMPL_ARGS_LEVEL): Likewise.\n+\t(TMPL_ARG, SET_TMPL_ARG, NUM_TMPL_ARGS, TMPL_PARMS_DEPTH): Likewise.\n+\t(tsubst_copy): Clarify variable name.\n+\t(most_general_template): Robustify.\n+\t\n 1999-09-29  Nathan Sidwell  <nathan@acm.org>\n \n \t* error.c (dump_template_parms): Don't use TS_PEDANTIC_NAME"}, {"sha": "3adb3035f75c3fac3f9259b7f4e05e0f69ed5941", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ac18ea8c1365118cfee58840ff738b0de67b5e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ac18ea8c1365118cfee58840ff738b0de67b5e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b5ac18ea8c1365118cfee58840ff738b0de67b5e", "patch": "@@ -1852,6 +1852,66 @@ struct lang_decl\n #define TI_SPEC_INFO(NODE) (TREE_CHAIN (NODE))\n #define TI_PENDING_TEMPLATE_FLAG(NODE) TREE_LANG_FLAG_1 (NODE)\n \n+/* We use TREE_VECs to hold template arguments.  If there is only one\n+   level of template arguments, then the TREE_VEC contains the\n+   arguments directly.  If there is more than one level of template\n+   arguments, then each entry in the TREE_VEC is itself a TREE_VEC,\n+   containing the template arguments for a single level.  The first\n+   entry in the outer TREE_VEC is the outermost level of template\n+   parameters; the last is the innermost.  \n+\n+   It is incorrect to ever form a template argument vector containing\n+   only one level of arguments, but which is a TREE_VEC containing as\n+   its only entry the TREE_VEC for that level.  */\n+\n+/* Non-zero if the template arguments is actually a vector of vectors,\n+   rather than just a vector.  */\n+#define TMPL_ARGS_HAVE_MULTIPLE_LEVELS(NODE) \\\n+  (NODE != NULL_TREE\t\t\t\t\t\t\\\n+   && TREE_CODE (NODE) == TREE_VEC\t\t\t\t\\\n+   && TREE_VEC_LENGTH (NODE) > 0\t\t\t\t\\\n+   && TREE_VEC_ELT (NODE, 0) != NULL_TREE\t\t\t\\\n+   && TREE_CODE (TREE_VEC_ELT (NODE, 0)) == TREE_VEC)\n+\n+/* The depth of a template argument vector.  When called directly by\n+   the parser, we use a TREE_LIST rather than a TREE_VEC to represent\n+   template arguments.  In fact, we may even see NULL_TREE if there\n+   are no template arguments.  In both of those cases, there is only\n+   one level of template arguments.  */\n+#define TMPL_ARGS_DEPTH(NODE)\t\t\t\t\t\\\n+  (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (NODE) ? TREE_VEC_LENGTH (NODE) : 1)\n+\n+/* The LEVELth level of the template ARGS.  Note that template\n+   parameter levels are indexed from 1, not from 0.  */\n+#define TMPL_ARGS_LEVEL(ARGS, LEVEL)\t\t\\\n+  (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (ARGS) \t\\\n+   ? TREE_VEC_ELT ((ARGS), (LEVEL) - 1) : ARGS)\n+\n+/* Set the LEVELth level of the template ARGS to VAL.  This macro does\n+   not work with single-level argument vectors.  */\n+#define SET_TMPL_ARGS_LEVEL(ARGS, LEVEL, VAL)\t\\\n+  (TREE_VEC_ELT ((ARGS), (LEVEL) - 1) = (VAL))\n+\n+/* Accesses the IDXth parameter in the LEVELth level of the ARGS.  */\n+#define TMPL_ARG(ARGS, LEVEL, IDX)\t\t\t\t\\\n+  (TREE_VEC_ELT (TMPL_ARGS_LEVEL (ARGS, LEVEL), IDX))\n+\n+/* Set the IDXth element in the LEVELth level of ARGS to VAL.  This\n+   macro does not work with single-level argument vectors.  */\n+#define SET_TMPL_ARG(ARGS, LEVEL, IDX, VAL)\t\t\t\\\n+  (TREE_VEC_ELT (TREE_VEC_ELT ((ARGS), (LEVEL) - 1), (IDX)) = (VAL))\n+\n+/* Given a single level of template arguments in NODE, return the\n+   number of arguments.  */\n+#define NUM_TMPL_ARGS(NODE) \t\t\t\t\\\n+  ((NODE) == NULL_TREE ? 0 \t\t\t\t\\\n+   : (TREE_CODE (NODE) == TREE_VEC \t\t\t\\\n+      ? TREE_VEC_LENGTH (NODE) : list_length (NODE)))\n+\n+/* The number of levels of template parameters given by NODE.  */\n+#define TMPL_PARMS_DEPTH(NODE) \\\n+  (TREE_INT_CST_HIGH (TREE_PURPOSE (NODE)))\n+\n /* The TEMPLATE_DECL instantiated or specialized by NODE.  This\n    TEMPLATE_DECL will be the immediate parent, not the most general\n    template.  For example, in:"}, {"sha": "ac9427ba9bf7baaa6daf6c8a95d7876c02a3d03b", "filename": "gcc/cp/error.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ac18ea8c1365118cfee58840ff738b0de67b5e/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ac18ea8c1365118cfee58840ff738b0de67b5e/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=b5ac18ea8c1365118cfee58840ff738b0de67b5e", "patch": "@@ -92,7 +92,7 @@ static tree ident_fndecl PROTO((tree));\n static void dump_template_argument PROTO((tree, enum tree_string_flags));\n static void dump_template_argument_list PROTO((tree, enum tree_string_flags));\n static void dump_template_parameter PROTO((tree, enum tree_string_flags));\n-static void dump_template_bindings PROTO((tree, tree, enum tree_string_flags));\n+static void dump_template_bindings PROTO((tree, tree));\n static void dump_scope PROTO((tree, enum tree_string_flags));\n static void dump_template_parms PROTO((tree, int, enum tree_string_flags));\n \n@@ -293,41 +293,39 @@ dump_template_parameter (parm, flags)\n    TREE_VEC.  */\n \n static void\n-dump_template_bindings (parms, args, flags)\n+dump_template_bindings (parms, args)\n      tree parms, args;\n-     enum tree_string_flags flags;\n {\n-  int arg_idx = 0;\n   int need_comma = 0;\n \n   while (parms)\n     {\n       tree p = TREE_VALUE (parms);\n+      int lvl = TMPL_PARMS_DEPTH (parms);\n+      int arg_idx = 0;\n       int i;\n \n       for (i = 0; i < TREE_VEC_LENGTH (p); ++i)\n-        {\n-          tree arg = TREE_VEC_ELT (args, arg_idx);\n-\n-          if (need_comma)\n-            OB_PUTS (\", \");\n-          dump_template_parameter (TREE_VEC_ELT (p, i), TS_PLAIN);\n-          OB_PUTS (\" = \");\n-          if (arg)\n-            dump_template_argument (arg, TS_PLAIN);\n-          else\n-            OB_PUTS (\"{missing}\");\n+\t{\n+\t  tree arg = TMPL_ARG (args, lvl, arg_idx);\n+\n+\t  if (need_comma)\n+\t    OB_PUTS (\", \");\n+\t  dump_template_parameter (TREE_VEC_ELT (p, i), TS_PLAIN);\n+\t  OB_PUTS (\" = \");\n+\t  if (arg)\n+\t    dump_template_argument (arg, TS_PLAIN);\n+\t  else\n+\t    OB_PUTS (\"{missing}\");\n           \n-          ++arg_idx;\n-          need_comma = 1;\n-        }\n+\t  ++arg_idx;\n+\t  need_comma = 1;\n+\t}\n \n       parms = TREE_CHAIN (parms);\n     }\n }\n \n-\n-\n /* Dump into the obstack a human-readable equivalent of TYPE.  FLAGS\n    controls the format.  */\n \n@@ -1042,31 +1040,32 @@ dump_template_decl (t, flags)\n      tree t;\n      enum tree_string_flags flags;\n {\n-  tree orig_args = DECL_TEMPLATE_PARMS (t);\n-  tree args;\n+  tree orig_parms = DECL_TEMPLATE_PARMS (t);\n+  tree parms;\n   int i; \n   \n   if (flags & TS_TEMPLATE_PREFIX)\n     {\n-      for (args = orig_args = nreverse (orig_args); \n-           args;\n-           args = TREE_CHAIN (args))\n+      for (parms = orig_parms = nreverse (orig_parms); \n+           parms;\n+           parms = TREE_CHAIN (parms))\n         {\n-          int len = TREE_VEC_LENGTH (TREE_VALUE (args));\n+\t  tree inner_parms = INNERMOST_TEMPLATE_PARMS (parms);\n+          int len = TREE_VEC_LENGTH (inner_parms);\n           \n           OB_PUTS (\"template <\");\n           for (i = 0; i < len; i++)\n             {\n               if (i)\n                 OB_PUTS (\", \");\n-              dump_template_parameter (TREE_VEC_ELT (args, i), flags);\n+              dump_template_parameter (TREE_VEC_ELT (inner_parms, i), flags);\n             }\n           OB_END_TEMPLATE_ID ();\n           OB_PUTC (' ');\n         }\n-      nreverse(orig_args);\n+      nreverse(orig_parms);\n       /* If we've shown the template<args> prefix, we'd better show the\n-       * decl's type too.  */\n+\t decl's type too.  */\n       flags |= TS_DECL_TYPE;\n     }\n   if (TREE_CODE (DECL_TEMPLATE_RESULT (t)) == TYPE_DECL)\n@@ -1113,11 +1112,12 @@ dump_function_decl (t, flags)\n     t = DECL_TEMPLATE_RESULT (t);\n \n   /* Pretty print template instantiations only.  */\n-  if (DECL_USE_TEMPLATE (t) == 1 || DECL_USE_TEMPLATE (t) == 3)\n+  if (DECL_TEMPLATE_INSTANTIATION (t))\n     {\n       template_args = DECL_TI_ARGS (t);\n       t = most_general_template (t);\n-      template_parms = DECL_TEMPLATE_PARMS (t);\n+      if (TREE_CODE (t) == TEMPLATE_DECL)\n+\ttemplate_parms = DECL_TEMPLATE_PARMS (t);\n     }\n \n   fntype = TREE_TYPE (t);\n@@ -1184,7 +1184,7 @@ dump_function_decl (t, flags)\n   if (template_parms != NULL_TREE && template_args != NULL_TREE)\n     {\n       OB_PUTS (\" [with \");\n-      dump_template_bindings (template_parms, template_args, flags);\n+      dump_template_bindings (template_parms, template_args);\n       OB_PUTC (']');\n     }\n }"}, {"sha": "baf6c3536720888de4b0698f99fcc273d5955e11", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 63, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ac18ea8c1365118cfee58840ff738b0de67b5e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ac18ea8c1365118cfee58840ff738b0de67b5e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b5ac18ea8c1365118cfee58840ff738b0de67b5e", "patch": "@@ -158,66 +158,6 @@ static int template_args_equal PROTO((tree, tree));\n static void print_template_context PROTO((int));\n static void tsubst_default_arguments PROTO((tree));\n \n-/* We use TREE_VECs to hold template arguments.  If there is only one\n-   level of template arguments, then the TREE_VEC contains the\n-   arguments directly.  If there is more than one level of template\n-   arguments, then each entry in the TREE_VEC is itself a TREE_VEC,\n-   containing the template arguments for a single level.  The first\n-   entry in the outer TREE_VEC is the outermost level of template\n-   parameters; the last is the innermost.  \n-\n-   It is incorrect to ever form a template argument vector containing\n-   only one level of arguments, but which is a TREE_VEC containing as\n-   its only entry the TREE_VEC for that level.  */\n-\n-/* Non-zero if the template arguments is actually a vector of vectors,\n-   rather than just a vector.  */\n-#define TMPL_ARGS_HAVE_MULTIPLE_LEVELS(NODE) \\\n-  (NODE != NULL_TREE\t\t\t\t\t\t\\\n-   && TREE_CODE (NODE) == TREE_VEC\t\t\t\t\\\n-   && TREE_VEC_LENGTH (NODE) > 0\t\t\t\t\\\n-   && TREE_VEC_ELT (NODE, 0) != NULL_TREE\t\t\t\\\n-   && TREE_CODE (TREE_VEC_ELT (NODE, 0)) == TREE_VEC)\n-\n-/* The depth of a template argument vector.  When called directly by\n-   the parser, we use a TREE_LIST rather than a TREE_VEC to represent\n-   template arguments.  In fact, we may even see NULL_TREE if there\n-   are no template arguments.  In both of those cases, there is only\n-   one level of template arguments.  */\n-#define TMPL_ARGS_DEPTH(NODE)\t\t\t\t\t\\\n-  (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (NODE) ? TREE_VEC_LENGTH (NODE) : 1)\n-\n-/* The LEVELth level of the template ARGS.  Note that template\n-   parameter levels are indexed from 1, not from 0.  */\n-#define TMPL_ARGS_LEVEL(ARGS, LEVEL)\t\t\\\n-  (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (ARGS) \t\\\n-   ? TREE_VEC_ELT ((ARGS), (LEVEL) - 1) : ARGS)\n-\n-/* Set the LEVELth level of the template ARGS to VAL.  This macro does\n-   not work with single-level argument vectors.  */\n-#define SET_TMPL_ARGS_LEVEL(ARGS, LEVEL, VAL)\t\\\n-  (TREE_VEC_ELT ((ARGS), (LEVEL) - 1) = (VAL))\n-\n-/* Accesses the IDXth parameter in the LEVELth level of the ARGS.  */\n-#define TMPL_ARG(ARGS, LEVEL, IDX)\t\t\t\t\\\n-  (TREE_VEC_ELT (TMPL_ARGS_LEVEL (ARGS, LEVEL), IDX))\n-\n-/* Set the IDXth element in the LEVELth level of ARGS to VAL.  This\n-   macro does not work with single-level argument vectors.  */\n-#define SET_TMPL_ARG(ARGS, LEVEL, IDX, VAL)\t\t\t\\\n-  (TREE_VEC_ELT (TREE_VEC_ELT ((ARGS), (LEVEL) - 1), (IDX)) = (VAL))\n-\n-/* Given a single level of template arguments in NODE, return the\n-   number of arguments.  */\n-#define NUM_TMPL_ARGS(NODE) \t\t\t\t\\\n-  ((NODE) == NULL_TREE ? 0 \t\t\t\t\\\n-   : (TREE_CODE (NODE) == TREE_VEC \t\t\t\\\n-      ? TREE_VEC_LENGTH (NODE) : list_length (NODE)))\n-\n-/* The number of levels of template parameters given by NODE.  */\n-#define TMPL_PARMS_DEPTH(NODE) \\\n-  (TREE_INT_CST_HIGH (TREE_PURPOSE (NODE)))\n-\n /* Called once to initialize pt.c.  */\n \n void\n@@ -7081,10 +7021,10 @@ tsubst_copy (t, args, complain, in_decl)\n \t to expand the STMT_EXPR here.  */\n       if (!processing_template_decl)\n \t{\n-\t  tree rtl_expr = begin_stmt_expr ();\n+\t  tree stmt_expr = begin_stmt_expr ();\n \t  tsubst_expr (STMT_EXPR_STMT (t), args,\n \t\t       complain, in_decl);\n-\t  return finish_stmt_expr (rtl_expr);\n+\t  return finish_stmt_expr (stmt_expr);\n \t}\n       \n       return t;\n@@ -9092,7 +9032,11 @@ tree\n most_general_template (decl)\n      tree decl;\n {\n-  while (DECL_TEMPLATE_INFO (decl))\n+  while (DECL_TEMPLATE_INFO (decl)\n+\t /* The DECL_TI_TEMPLATE can be a LOOKUP_EXPR or\n+\t    IDENTIFIER_NODE in some cases.  (See cp-tree.h for\n+\t    details.)  */\n+\t && TREE_CODE (DECL_TI_TEMPLATE (decl)) == TEMPLATE_DECL)\n     decl = DECL_TI_TEMPLATE (decl);\n \n   return decl;"}, {"sha": "675a31a398d0bd2b4b4155a8245a7529f51f95ea", "filename": "gcc/testsuite/g++.old-deja/g++.pt/error1.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ac18ea8c1365118cfee58840ff738b0de67b5e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ferror1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ac18ea8c1365118cfee58840ff738b0de67b5e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ferror1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ferror1.C?ref=b5ac18ea8c1365118cfee58840ff738b0de67b5e", "patch": "@@ -0,0 +1,19 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+template <class T>\n+struct S\n+{\n+  template <class U>\n+  void f ();\n+  \n+};\n+\n+template <class T>\n+template <class U>\n+void S<T>::f ()\n+{\n+  U& u; // ERROR - uninitialized reference\n+}\n+\n+template void S<int>::f<double>(); // ERROR - instantiated from here"}]}