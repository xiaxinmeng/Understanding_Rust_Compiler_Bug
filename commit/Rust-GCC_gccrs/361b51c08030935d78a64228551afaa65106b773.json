{"sha": "361b51c08030935d78a64228551afaa65106b773", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzYxYjUxYzA4MDMwOTM1ZDc4YTY0MjI4NTUxYWZhYTY1MTA2Yjc3Mw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2011-06-16T21:52:00Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2011-06-16T21:52:00Z"}, "message": "tree-ssa-threadupdate.c (struct redirection_data): New field intermediate_edge.\n\n\n\t* tree-ssa-threadupdate.c (struct redirection_data): New field\n\tintermediate_edge.\n\t(THREAD_TARGET2): Define.\n\t(redirection_data_eq): Also check that the intermediate edge is\n\tequal.\n\t(lookup_redirection_data): Drop useless argument.  Extract the\n\toutgoing_edge and intermediate edge from E.  Callers updated.\n\t(copy_phi_args, update_destination_phis): New functions.\n\t(fix_duplicate_block_edges): Likewise.\n\t(create_edge_and_update_destination_phis): Duplicate all the edges\n\thung off e->aux.  Use copy_phi_args.\n\t(create_duplicates): Use fix_duplicate_block_edges.\n\t(fixup_template_block): Likewise.\n\t(redirect_edges): If necessary, redirect the joiner block's incoming\n\tedge to the duplicate of the joiner block.\n\t(thread_block): Don't muck up loops when threading through a joiner\n\tblock.\n\t(thread_through_loop_header): Handle threading through a joiner\n\tblock.\n\t(mark_threaded_blocks, register_jump_thread): Likewise.\n\t* tree-flow.h (register_jump_thread): Add new argument.  Callers\n\tupdated.\n\t* tree-ssa-threadedge.c (phi_args_equal_on_edges): New function.\n\t(thread_across_edge): Handle threading through a joiner block.\n\t\n\n\t\n\t* gcc.dg/builtin-object-size-1.c: Update to handle changes from\n\timproved jump threading.\n\t* gcc.dg/builtin-object-size-2.c: Likewise.\n\t* gcc.dg/tree-ssa/20030728-1.c: Likewise.\n\nFrom-SVN: r175114", "tree": {"sha": "3d01a6665a2ef3a33f6ed1eb847b76b1948a165d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d01a6665a2ef3a33f6ed1eb847b76b1948a165d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/361b51c08030935d78a64228551afaa65106b773", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/361b51c08030935d78a64228551afaa65106b773", "html_url": "https://github.com/Rust-GCC/gccrs/commit/361b51c08030935d78a64228551afaa65106b773", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/361b51c08030935d78a64228551afaa65106b773/comments", "author": null, "committer": null, "parents": [{"sha": "67a7c837e95e85c607e55d2b72bfd4da43f0dd16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67a7c837e95e85c607e55d2b72bfd4da43f0dd16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67a7c837e95e85c607e55d2b72bfd4da43f0dd16"}], "stats": {"total": 294, "additions": 256, "deletions": 38}, "files": [{"sha": "c1620d2eff41ef7c1d0edd82c8853d6466b79d14", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/361b51c08030935d78a64228551afaa65106b773/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/361b51c08030935d78a64228551afaa65106b773/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=361b51c08030935d78a64228551afaa65106b773", "patch": "@@ -1,3 +1,30 @@\n+2011-06-16  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-threadupdate.c (struct redirection_data): New field\n+\tintermediate_edge.\n+\t(THREAD_TARGET2): Define.\n+\t(redirection_data_eq): Also check that the intermediate edge is\n+\tequal.\n+\t(lookup_redirection_data): Drop useless argument.  Extract the\n+\toutgoing_edge and intermediate edge from E.  Callers updated.\n+\t(copy_phi_args, update_destination_phis): New functions.\n+\t(fix_duplicate_block_edges): Likewise.\n+\t(create_edge_and_update_destination_phis): Duplicate all the edges\n+\thung off e->aux.  Use copy_phi_args.\n+\t(create_duplicates): Use fix_duplicate_block_edges.\n+\t(fixup_template_block): Likewise.\n+\t(redirect_edges): If necessary, redirect the joiner block's incoming\n+\tedge to the duplicate of the joiner block.\n+\t(thread_block): Don't muck up loops when threading through a joiner\n+\tblock.\n+\t(thread_through_loop_header): Handle threading through a joiner\n+\tblock.\n+\t(mark_threaded_blocks, register_jump_thread): Likewise.\n+\t* tree-flow.h (register_jump_thread): Add new argument.  Callers\n+\tupdated.\n+\t* tree-ssa-threadedge.c (phi_args_equal_on_edges): New function.\n+\t(thread_across_edge): Handle threading through a joiner block.\n+\t\n 2011-06-16  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/49343\n@@ -320,7 +347,7 @@\n \t* ddg.c (add_intra_loop_mem_dep): New function.\n \t(build_intra_loop_deps): Call it.\n \n-2011-05-06  Jeff Law  <law@redhat.com>\n+2011-06-13  Jeff Law  <law@redhat.com>\n \n \t* df-problems.c (df_lr_local_compute): Manually CSE\n \tPIC_OFFSET_TABLE_REGNUM."}, {"sha": "bea872172d5906d455cd55a0431cd906025facdc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/361b51c08030935d78a64228551afaa65106b773/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/361b51c08030935d78a64228551afaa65106b773/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=361b51c08030935d78a64228551afaa65106b773", "patch": "@@ -1,3 +1,10 @@\n+2011-06-16  Jeff Law <law@redhat.com>\n+\n+\t* gcc.dg/builtin-object-size-1.c: Update to handle chances from\n+\timproved jump threading.\n+\t* gcc.dg/builtin-object-size-2.c: Likewise.\n+\t* gcc.dg/tree-ssa/20030728-1.c: Likewise.\n+\n 2011-06-16  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/49074"}, {"sha": "13ebeb15b2540e67f86c35ce2b99d960ece6b4a3", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-1.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/361b51c08030935d78a64228551afaa65106b773/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/361b51c08030935d78a64228551afaa65106b773/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-1.c?ref=361b51c08030935d78a64228551afaa65106b773", "patch": "@@ -64,7 +64,11 @@ test1 (void *q, int x)\n     r = malloc (30);\n   else\n     r = calloc (2, 16);\n-  if (__builtin_object_size (r, 0) != 2 * 16)\n+  /* We may duplicate this test onto the two exit paths.  On one path\n+     the size will be 32, the other it will be 30.  If we don't duplicate\n+     this test, then the size will be 32.  */\n+  if (__builtin_object_size (r, 0) != 2 * 16\n+      && __builtin_object_size (r, 0) != 30)\n     abort ();\n   if (x < 20)\n     r = malloc (30);"}, {"sha": "21aff5a958dfcfb2bee335d63bcef3023c8f8f3d", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-2.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/361b51c08030935d78a64228551afaa65106b773/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/361b51c08030935d78a64228551afaa65106b773/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-2.c?ref=361b51c08030935d78a64228551afaa65106b773", "patch": "@@ -60,7 +60,11 @@ test1 (void *q, int x)\n     r = malloc (30);\n   else\n     r = calloc (2, 16);\n-  if (__builtin_object_size (r, 1) != 2 * 16)\n+  /* We may duplicate this test onto the two exit paths.  On one path\n+     the size will be 32, the other it will be 30.  If we don't duplicate\n+     this test, then the size will be 32.  */\n+  if (__builtin_object_size (r, 1) != 2 * 16\n+      && __builtin_object_size (r, 1) != 30)\n     abort ();\n   if (x < 20)\n     r = malloc (30);"}, {"sha": "93a7979c56fa8c6015777791771dea667bacfa36", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030728-1.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/361b51c08030935d78a64228551afaa65106b773/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030728-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/361b51c08030935d78a64228551afaa65106b773/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030728-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030728-1.c?ref=361b51c08030935d78a64228551afaa65106b773", "patch": "@@ -41,7 +41,9 @@ objects_must_conflict_p (t1, t2)\n   return foo (t2 ? get_alias_set (t2) : 0);\n }\n \n-/* There should be two assignments of variables to the value zero.  */\n-/* { dg-final { scan-rtl-dump-times \"PART.. = 0\" 2 \"expand\"} } */\n+/* There should be one assignment of variables to the value zero.  There\n+   used to be two assignments, but improvements in threading allowed the\n+   second to be propagated into all its uses and eliminated.   */\n+/* { dg-final { scan-rtl-dump-times \"PART.. = 0\" 1 \"expand\"} } */\n  \n /* { dg-final { cleanup-rtl-dump \"expand\" } } */"}, {"sha": "a864e169eb7d4743780170e51ec7720adb3a55c4", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/361b51c08030935d78a64228551afaa65106b773/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/361b51c08030935d78a64228551afaa65106b773/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=361b51c08030935d78a64228551afaa65106b773", "patch": "@@ -808,7 +808,7 @@ bool may_be_nonaddressable_p (tree expr);\n \n /* In tree-ssa-threadupdate.c.  */\n extern bool thread_through_all_blocks (bool);\n-extern void register_jump_thread (edge, edge);\n+extern void register_jump_thread (edge, edge, edge);\n \n /* In gimplify.c  */\n tree force_gimple_operand_1 (tree, gimple_seq *, gimple_predicate, tree);"}, {"sha": "a485b211e59286972639cbc659be125cdf260715", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 85, "deletions": 2, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/361b51c08030935d78a64228551afaa65106b773/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/361b51c08030935d78a64228551afaa65106b773/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=361b51c08030935d78a64228551afaa65106b773", "patch": "@@ -1,5 +1,5 @@\n /* SSA Jump Threading\n-   Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Jeff Law  <law@redhat.com>\n \n@@ -652,6 +652,27 @@ thread_around_empty_block (edge taken_edge,\n   return NULL;\n }\n       \n+/* E1 and E2 are edges into the same basic block.  Return TRUE if the\n+   PHI arguments associated with those edges are equal or there are no\n+   PHI arguments, otherwise return FALSE.  */\n+\n+static bool\n+phi_args_equal_on_edges (edge e1, edge e2)\n+{\n+  gimple_stmt_iterator gsi;\n+  int indx1 = e1->dest_idx;\n+  int indx2 = e2->dest_idx;\n+\n+  for (gsi = gsi_start_phis (e1->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple phi = gsi_stmt (gsi);\n+\n+      if (!operand_equal_p (gimple_phi_arg_def (phi, indx1),\n+\t\t\t    gimple_phi_arg_def (phi, indx2), 0))\n+\treturn false;\n+    }\n+  return true;\n+}\n \n /* We are exiting E->src, see if E->dest ends with a conditional\n    jump which has a known value when reached via E.\n@@ -770,11 +791,73 @@ thread_across_edge (gimple dummy_cond,\n \t    }\n \n \t  remove_temporary_equivalences (stack);\n-\t  register_jump_thread (e, taken_edge);\n+\t  register_jump_thread (e, taken_edge, NULL);\n \t  return;\n \t}\n     }\n \n+ /* We were unable to determine what out edge from E->dest is taken.  However,\n+    we might still be able to thread through successors of E->dest.  This\n+    often occurs when E->dest is a joiner block which then fans back out\n+    based on redundant tests.\n+\n+    If so, we'll copy E->dest and redirect the appropriate predecessor to\n+    the copy.  Within the copy of E->dest, we'll thread one or more edges\n+    to points deeper in the CFG.\n+\n+    This is a stopgap until we have a more structured approach to path\n+    isolation.  */\n+  {\n+    edge e2, e3, taken_edge;\n+    edge_iterator ei;\n+    bool found = false;\n+    bitmap visited = BITMAP_ALLOC (NULL);\n+\n+    /* Look at each successor of E->dest to see if we can thread through it.  */\n+    FOR_EACH_EDGE (taken_edge, ei, e->dest->succs)\n+      {\n+\t/* Avoid threading to any block we have already visited.  */\n+\tbitmap_clear (visited);\n+\tbitmap_set_bit (visited, taken_edge->dest->index);\n+\tbitmap_set_bit (visited, e->dest->index);\n+\n+\t/* Record whether or not we were able to thread through a successor\n+\t   of E->dest.  */\n+\tfound = false;\n+\te3 = taken_edge;\n+\tdo\n+\t  {\n+\t    e2 = thread_around_empty_block (e3,\n+\t\t\t\t            dummy_cond,\n+\t\t\t\t            handle_dominating_asserts,\n+\t\t\t\t            simplify,\n+\t\t\t\t            visited);\n+\t    if (e2)\n+\t      {\n+\t        e3 = e2;\n+\t\tfound = true;\n+\t      }\n+\t  }\n+        while (e2);\n+\n+\t/* If we were able to thread through a successor of E->dest, then\n+\t   record the jump threading opportunity.  */\n+\tif (found)\n+\t  {\n+\t    edge tmp;\n+\t    /* If there is already an edge from the block to be duplicated\n+\t       (E2->src) to the final target (E3->dest), then make sure that\n+\t       the PHI args associated with the edges E2 and E3 are the\n+\t       same.  */\n+\t    tmp = find_edge (taken_edge->src, e3->dest);\n+\t    if (!tmp || phi_args_equal_on_edges (tmp, e3))\n+\t      register_jump_thread (e, taken_edge, e3);\n+\t  }\n+\n+      }\n+    BITMAP_FREE (visited);\n+  }\n+\n  fail:\n   remove_temporary_equivalences (stack);\n }"}, {"sha": "e0335dc8c106481924c7613206b8a3759f46f2c5", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 121, "deletions": 30, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/361b51c08030935d78a64228551afaa65106b773/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/361b51c08030935d78a64228551afaa65106b773/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=361b51c08030935d78a64228551afaa65106b773", "patch": "@@ -1,6 +1,6 @@\n /* Thread edges through blocks and update the control flow and SSA graphs.\n-   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2010 Free Software Foundation,\n-   Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2010, 201\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -121,6 +121,8 @@ struct redirection_data\n      its single successor.  */\n   edge outgoing_edge;\n \n+  edge intermediate_edge;\n+\n   /* A list of incoming edges which we want to thread to\n      OUTGOING_EDGE->dest.  */\n   struct el *incoming_edges;\n@@ -153,6 +155,7 @@ static VEC(edge,heap) *threaded_edges;\n    threading is attached to the AUX field for the incoming edge.  Use these\n    macros to access the underlying structure attached to the AUX field.  */\n #define THREAD_TARGET(E) ((edge *)(E)->aux)[0]\n+#define THREAD_TARGET2(E) ((edge *)(E)->aux)[1]\n \n /* Jump threading statistics.  */\n \n@@ -231,8 +234,10 @@ redirection_data_eq (const void *p1, const void *p2)\n {\n   edge e1 = ((const struct redirection_data *)p1)->outgoing_edge;\n   edge e2 = ((const struct redirection_data *)p2)->outgoing_edge;\n+  edge e3 = ((const struct redirection_data *)p1)->intermediate_edge;\n+  edge e4 = ((const struct redirection_data *)p2)->intermediate_edge;\n \n-  return e1 == e2;\n+  return e1 == e2 && e3 == e4;\n }\n \n /* Given an outgoing edge E lookup and return its entry in our hash table.\n@@ -242,15 +247,17 @@ redirection_data_eq (const void *p1, const void *p2)\n    edges associated with E in the hash table.  */\n \n static struct redirection_data *\n-lookup_redirection_data (edge e, edge incoming_edge, enum insert_option insert)\n+lookup_redirection_data (edge e, enum insert_option insert)\n {\n   void **slot;\n   struct redirection_data *elt;\n \n  /* Build a hash table element so we can see if E is already\n      in the table.  */\n   elt = XNEW (struct redirection_data);\n-  elt->outgoing_edge = e;\n+  elt->intermediate_edge = THREAD_TARGET2 (e) ? THREAD_TARGET (e) : NULL;\n+  elt->outgoing_edge = THREAD_TARGET2 (e) ? THREAD_TARGET2 (e) \n+\t\t\t\t\t  : THREAD_TARGET (e);\n   elt->dup_block = NULL;\n   elt->incoming_edges = NULL;\n \n@@ -270,7 +277,7 @@ lookup_redirection_data (edge e, edge incoming_edge, enum insert_option insert)\n     {\n       *slot = (void *)elt;\n       elt->incoming_edges = XNEW (struct el);\n-      elt->incoming_edges->e = incoming_edge;\n+      elt->incoming_edges->e = e;\n       elt->incoming_edges->next = NULL;\n       return elt;\n     }\n@@ -290,14 +297,49 @@ lookup_redirection_data (edge e, edge incoming_edge, enum insert_option insert)\n \t{\n           struct el *el = XNEW (struct el);\n \t  el->next = elt->incoming_edges;\n-\t  el->e = incoming_edge;\n+\t  el->e = e;\n \t  elt->incoming_edges = el;\n \t}\n \n       return elt;\n     }\n }\n \n+/* For each PHI in BB, copy the argument associated with SRC_E to TGT_E.  */\n+\n+static void\n+copy_phi_args (basic_block bb, edge src_e, edge tgt_e)\n+{\n+  gimple_stmt_iterator gsi;\n+  int src_indx = src_e->dest_idx;\n+\n+  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple phi = gsi_stmt (gsi);\n+      source_location locus = gimple_phi_arg_location (phi, src_indx);\n+      add_phi_arg (phi, gimple_phi_arg_def (phi, src_indx), tgt_e, locus);\n+    }\n+}\n+\n+/* We have recently made a copy of ORIG_BB, including its outgoing\n+   edges.  The copy is NEW_BB.  Every PHI node in every direct successor of\n+   ORIG_BB has a new argument associated with edge from NEW_BB to the\n+   successor.  Initialize the PHI argument so that it is equal to the PHI\n+   argument associated with the edge from ORIG_BB to the successor.  */\n+\n+static void\n+update_destination_phis (basic_block orig_bb, basic_block new_bb)\n+{\n+  edge_iterator ei;\n+  edge e;\n+\n+  FOR_EACH_EDGE (e, ei, orig_bb->succs)\n+    {\n+      edge e2 = find_edge (new_bb, e->dest);\n+      copy_phi_args (e->dest, e, e2);\n+    }\n+}\n+\n /* Given a duplicate block and its single destination (both stored\n    in RD).  Create an edge between the duplicate and its single\n    destination.\n@@ -310,16 +352,16 @@ create_edge_and_update_destination_phis (struct redirection_data *rd,\n \t\t\t\t\t basic_block bb)\n {\n   edge e = make_edge (bb, rd->outgoing_edge->dest, EDGE_FALLTHRU);\n-  gimple_stmt_iterator gsi;\n \n   rescan_loop_exit (e, true, false);\n   e->probability = REG_BR_PROB_BASE;\n   e->count = bb->count;\n \n   if (rd->outgoing_edge->aux)\n     {\n-      e->aux = (edge *) XNEWVEC (edge, 1);\n+      e->aux = (edge *) XNEWVEC (edge, 2);\n       THREAD_TARGET(e) = THREAD_TARGET (rd->outgoing_edge);\n+      THREAD_TARGET2(e) = THREAD_TARGET2 (rd->outgoing_edge);\n     }\n   else\n     {\n@@ -330,17 +372,43 @@ create_edge_and_update_destination_phis (struct redirection_data *rd,\n      from the duplicate block, then we will need to add a new argument\n      to them.  The argument should have the same value as the argument\n      associated with the outgoing edge stored in RD.  */\n-  for (gsi = gsi_start_phis (e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n+  copy_phi_args (e->dest, rd->outgoing_edge, e);\n+}\n+\n+/* Wire up the outgoing edges from the duplicate block and\n+   update any PHIs as needed.  */\n+static void\n+fix_duplicate_block_edges (struct redirection_data *rd,\n+\t\t\t   struct local_info *local_info)\n+{\n+  /* If we were threading through an joiner block, then we want\n+     to keep its control statement and redirect an outgoing edge.\n+     Else we want to remove the control statement & edges, then create\n+     a new outgoing edge.  In both cases we may need to update PHIs.  */\n+  if (THREAD_TARGET2 (rd->incoming_edges->e) == rd->outgoing_edge)\n     {\n-      gimple phi = gsi_stmt (gsi);\n-      source_location locus;\n-      int indx = rd->outgoing_edge->dest_idx;\n+      edge victim;\n+      edge e2;\n+      edge e = rd->incoming_edges->e;\n+\n+      /* This updates the PHIs at the destination of the duplicate\n+\t block.  */\n+      update_destination_phis (local_info->bb, rd->dup_block);\n \n-      locus = gimple_phi_arg_location (phi, indx);\n-      add_phi_arg (phi, gimple_phi_arg_def (phi, indx), e, locus);\n+      /* Find the edge from the duplicate block to the block we're\n+\t threading through.  That's the edge we want to redirect.  */\n+      victim = find_edge (rd->dup_block, THREAD_TARGET (e)->dest);\n+      e2 = redirect_edge_and_branch (victim, THREAD_TARGET2 (e)->dest);\n+\n+      /* This updates the PHI at the target of the threaded edge.  */\n+      copy_phi_args (e2->dest, THREAD_TARGET2 (e), e2);\n+    }\n+  else\n+    {\n+      remove_ctrl_stmt_and_useless_edges (rd->dup_block, NULL);\n+      create_edge_and_update_destination_phis (rd, rd->dup_block);\n     }\n }\n-\n /* Hash table traversal callback routine to create duplicate blocks.  */\n \n static int\n@@ -365,9 +433,8 @@ create_duplicates (void **slot, void *data)\n       create_block_for_threading (local_info->template_block, rd);\n \n       /* Go ahead and wire up outgoing edges and update PHIs for the duplicate\n-         block.  */\n-      remove_ctrl_stmt_and_useless_edges (rd->dup_block, NULL);\n-      create_edge_and_update_destination_phis (rd, rd->dup_block);\n+\t block.   */\n+      fix_duplicate_block_edges (rd, local_info);\n     }\n \n   /* Keep walking the hash table.  */\n@@ -384,12 +451,16 @@ fixup_template_block (void **slot, void *data)\n   struct redirection_data *rd = (struct redirection_data *) *slot;\n   struct local_info *local_info = (struct local_info *)data;\n \n-  /* If this is the template block, then create its outgoing edges\n-     and halt the hash table traversal.  */\n+  /* If this is the template block halt the traversal after updating\n+     it appropriately.\n+\n+     If we were threading through an joiner block, then we want\n+     to keep its control statement and redirect an outgoing edge.\n+     Else we want to remove the control statement & edges, then create\n+     a new outgoing edge.  In both cases we may need to update PHIs.  */\n   if (rd->dup_block && rd->dup_block == local_info->template_block)\n     {\n-      remove_ctrl_stmt_and_useless_edges (rd->dup_block, NULL);\n-      create_edge_and_update_destination_phis (rd, rd->dup_block);\n+      fix_duplicate_block_edges (rd, local_info);\n       return 0;\n     }\n \n@@ -419,8 +490,18 @@ redirect_edges (void **slot, void *data)\n       free (el);\n \n       thread_stats.num_threaded_edges++;\n+      /* If we are threading through a joiner block, then we have to\n+\t find the edge we want to redirect and update some PHI nodes.  */\n+      if (THREAD_TARGET2 (e))\n+\t{\n+\t  edge e2;\n \n-      if (rd->dup_block)\n+\t  /* We want to redirect the incoming edge to the joiner block (E)\n+\t     to instead reach the duplicate of the joiner block.  */\n+\t  e2 = redirect_edge_and_branch (e, rd->dup_block);\n+\t  flush_pending_stmts (e2);\n+\t}\n+      else if (rd->dup_block)\n \t{\n \t  edge e2;\n \n@@ -546,14 +627,18 @@ thread_block (basic_block bb, bool noloop_only)\n       if (e->aux == NULL)\n \tcontinue;\n \n-      e2 = THREAD_TARGET (e);\n+      if (THREAD_TARGET2 (e))\n+\te2 = THREAD_TARGET2 (e);\n+      else\n+\te2 = THREAD_TARGET (e);\n \n       if (!e2\n \t  /* If NOLOOP_ONLY is true, we only allow threading through the\n \t     header of a loop to exit edges.  */\n \t  || (noloop_only\n \t      && bb == bb->loop_father->header\n-\t      && (!loop_exit_edge_p (bb->loop_father, e2))))\n+\t      && (!loop_exit_edge_p (bb->loop_father, e2)\n+\t\t  || THREAD_TARGET2 (e))))\n \tcontinue;\n \n       if (e->dest == e2->src)\n@@ -562,7 +647,7 @@ thread_block (basic_block bb, bool noloop_only)\n \n       /* Insert the outgoing edge into the hash table if it is not\n \t already in the hash table.  */\n-      lookup_redirection_data (e2, e, INSERT);\n+      lookup_redirection_data (e, INSERT);\n     }\n \n   /* We do not update dominance info.  */\n@@ -817,6 +902,8 @@ thread_through_loop_header (struct loop *loop, bool may_peel_loop_headers)\n \n   if (latch->aux)\n     {\n+      if (THREAD_TARGET2 (latch))\n+\tgoto fail;\n       tgt_edge = THREAD_TARGET (latch);\n       tgt_bb = tgt_edge->dest;\n     }\n@@ -840,6 +927,8 @@ thread_through_loop_header (struct loop *loop, bool may_peel_loop_headers)\n \t      goto fail;\n \t    }\n \n+\t  if (THREAD_TARGET2 (e))\n+\t    goto fail;\n \t  tgt_edge = THREAD_TARGET (e);\n \t  atgt_bb = tgt_edge->dest;\n \t  if (!tgt_bb)\n@@ -967,13 +1056,14 @@ mark_threaded_blocks (bitmap threaded_blocks)\n   edge e;\n   edge_iterator ei;\n \n-  for (i = 0; i < VEC_length (edge, threaded_edges); i += 2)\n+  for (i = 0; i < VEC_length (edge, threaded_edges); i += 3)\n     {\n       edge e = VEC_index (edge, threaded_edges, i);\n-      edge *x = (edge *) XNEWVEC (edge, 1);\n+      edge *x = (edge *) XNEWVEC (edge, 2);\n \n       e->aux = x;\n       THREAD_TARGET (e) = VEC_index (edge, threaded_edges, i + 1);\n+      THREAD_TARGET2 (e) = VEC_index (edge, threaded_edges, i + 2);\n       bitmap_set_bit (tmp, e->dest->index);\n     }\n \n@@ -1085,7 +1175,7 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n    after fixing the SSA graph.  */\n \n void\n-register_jump_thread (edge e, edge e2)\n+register_jump_thread (edge e, edge e2, edge e3)\n {\n   /* This can occur if we're jumping to a constant address or\n      or something similar.  Just get out now.  */\n@@ -1102,4 +1192,5 @@ register_jump_thread (edge e, edge e2)\n \n   VEC_safe_push (edge, heap, threaded_edges, e);\n   VEC_safe_push (edge, heap, threaded_edges, e2);\n+  VEC_safe_push (edge, heap, threaded_edges, e3);\n }"}]}