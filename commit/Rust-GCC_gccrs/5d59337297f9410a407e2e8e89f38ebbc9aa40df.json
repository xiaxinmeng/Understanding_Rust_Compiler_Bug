{"sha": "5d59337297f9410a407e2e8e89f38ebbc9aa40df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ1OTMzNzI5N2Y5NDEwYTQwN2UyZThlODlmMzhlYmJjOWFhNDBkZg==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2008-08-19T08:31:41Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2008-08-19T08:31:41Z"}, "message": "tree-vectorizer.c (supportable_widening_operation): Support multi-step conversion...\n\n\t* tree-vectorizer.c (supportable_widening_operation): Support\n\tmulti-step conversion, return the number of steps in such conversion\n\tand the required intermediate types.\n\t(supportable_narrowing_operation): Likewise.\n\t* tree-vectorizer.h (vect_pow2): New function.\n\t(supportable_widening_operation): Change argument types.\n\t(supportable_narrowing_operation): Likewise.\n\t(vectorizable_type_promotion): Add an argument.\n\t(vectorizable_type_demotion): Likewise.\n\t* tree-vect-analyze.c (vect_analyze_operations): Call \n\tvectorizable_type_promotion and vectorizable_type_demotion with\n\tadditional argument.\n\t(vect_get_and_check_slp_defs): Detect patterns.\n\t(vect_build_slp_tree): Add an argument, don't fail in case of multiple\n\ttypes. \n\t(vect_analyze_slp_instance): Don't fail in case of multiple types. Call\n\tvect_build_slp_tree with correct arguments. Calculate unrolling factor\n\taccording to the smallest type in the loop.\n\t(vect_detect_hybrid_slp_stmts): Include statements from patterns.\n\t* tree-vect-patterns.c (vect_recog_widen_mult_pattern): Call \n\tsupportable_widening_operation with correct arguments. \n\t* tree-vect-transform.c (vect_get_slp_defs): Allocate output vector \n\toperands lists according to the number of vector statements in left\n\tor right node, if exists.\n\t(vect_gen_widened_results_half): Remove unused argument.\n\t(vectorizable_conversion): Call supportable_widening_operation, \n\tsupportable_narrowing_operation, and vect_gen_widened_results_half\n\twith correct arguments. \n\t(vectorizable_assignment): Change documentation, support multiple\n\ttypes in SLP. \n\t(vectorizable_operation): Likewise.\n\t(vect_get_loop_based_defs): New function.\n\t(vect_create_vectorized_demotion_stmts): Likewise.\n\t(vectorizable_type_demotion): Support loop-aware SLP and general\n\tmulti-step conversion. Call vect_get_loop_based_defs and\n\tvect_create_vectorized_demotion_stmts for transformation.\n\t(vect_create_vectorized_promotion_stmts): New function.\n\t(vectorizable_type_promotion): Support loop-aware SLP and general\n\tmulti-step conversion. Call vect_create_vectorized_promotion_stmts\n\tfor transformation.\t\n\t(vectorizable_store): Change documentation, support multiple\n\ttypes in SLP. \n\t(vectorizable_load): Likewise.\n\t(vect_transform_stmt): Pass SLP_NODE to \n\tvectorizable_type_promotion and vectorizable_type_demotion.\n\t(vect_schedule_slp_instance): Move here the calculation of number\n\tof vectorized statements for each node from...\n\t(vect_schedule_slp): ... here.\n\t(vect_transform_loop): Call vect_schedule_slp without the last\n\targument.\n\nFrom-SVN: r139225", "tree": {"sha": "f4481b3ce0ab856f0a57386df3e28b42d737975d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4481b3ce0ab856f0a57386df3e28b42d737975d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d59337297f9410a407e2e8e89f38ebbc9aa40df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d59337297f9410a407e2e8e89f38ebbc9aa40df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d59337297f9410a407e2e8e89f38ebbc9aa40df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d59337297f9410a407e2e8e89f38ebbc9aa40df/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "45ea82c11f4e9984a8f902f1e70913d5472911d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45ea82c11f4e9984a8f902f1e70913d5472911d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45ea82c11f4e9984a8f902f1e70913d5472911d3"}], "stats": {"total": 2008, "additions": 1659, "deletions": 349}, "files": [{"sha": "0055802806f01f751a97db0e309ffa552fca1212", "filename": "gcc/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -1,3 +1,56 @@\n+2008-08-19  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* tree-vectorizer.c (supportable_widening_operation): Support\n+\tmulti-step conversion, return the number of steps in such conversion\n+\tand the required intermediate types.\n+\t(supportable_narrowing_operation): Likewise.\n+\t* tree-vectorizer.h (vect_pow2): New function.\n+\t(supportable_widening_operation): Change argument types.\n+\t(supportable_narrowing_operation): Likewise.\n+\t(vectorizable_type_promotion): Add an argument.\n+\t(vectorizable_type_demotion): Likewise.\n+\t* tree-vect-analyze.c (vect_analyze_operations): Call \n+\tvectorizable_type_promotion and vectorizable_type_demotion with\n+\tadditional argument.\n+\t(vect_get_and_check_slp_defs): Detect patterns.\n+\t(vect_build_slp_tree): Add an argument, don't fail in case of multiple\n+\ttypes. \n+\t(vect_analyze_slp_instance): Don't fail in case of multiple types. Call\n+\tvect_build_slp_tree with correct arguments. Calculate unrolling factor\n+\taccording to the smallest type in the loop.\n+\t(vect_detect_hybrid_slp_stmts): Include statements from patterns.\n+\t* tree-vect-patterns.c (vect_recog_widen_mult_pattern): Call \n+\tsupportable_widening_operation with correct arguments. \n+\t* tree-vect-transform.c (vect_get_slp_defs): Allocate output vector \n+\toperands lists according to the number of vector statements in left\n+\tor right node, if exists.\n+\t(vect_gen_widened_results_half): Remove unused argument.\n+\t(vectorizable_conversion): Call supportable_widening_operation, \n+\tsupportable_narrowing_operation, and vect_gen_widened_results_half\n+\twith correct arguments. \n+\t(vectorizable_assignment): Change documentation, support multiple\n+\ttypes in SLP. \n+\t(vectorizable_operation): Likewise.\n+\t(vect_get_loop_based_defs): New function.\n+\t(vect_create_vectorized_demotion_stmts): Likewise.\n+\t(vectorizable_type_demotion): Support loop-aware SLP and general\n+\tmulti-step conversion. Call vect_get_loop_based_defs and\n+\tvect_create_vectorized_demotion_stmts for transformation.\n+\t(vect_create_vectorized_promotion_stmts): New function.\n+\t(vectorizable_type_promotion): Support loop-aware SLP and general\n+\tmulti-step conversion. Call vect_create_vectorized_promotion_stmts\n+\tfor transformation.\t\n+\t(vectorizable_store): Change documentation, support multiple\n+\ttypes in SLP. \n+\t(vectorizable_load): Likewise.\n+\t(vect_transform_stmt): Pass SLP_NODE to \n+\tvectorizable_type_promotion and vectorizable_type_demotion.\n+\t(vect_schedule_slp_instance): Move here the calculation of number\n+\tof vectorized statements for each node from...\n+\t(vect_schedule_slp): ... here.\n+\t(vect_transform_loop): Call vect_schedule_slp without the last\n+\targument.\n+\n 2008-08-19  Dorit Nuzman  <dorit@il.ibm.com>\n \n \tPR bootstrap/37152"}, {"sha": "ef27c4b069e60606738bbcc51e8d72726ae178a0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -1,3 +1,18 @@\n+2008-08-19  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* gcc.dg/vect/slp-multitypes-1.c: New testcase.\n+\t* gcc.dg/vect/slp-multitypes-2.c, gcc.dg/vect/slp-multitypes-3.c,\n+\tgcc.dg/vect/slp-multitypes-4.c, gcc.dg/vect/slp-multitypes-5.c,\n+\tgcc.dg/vect/slp-multitypes-6.c, gcc.dg/vect/slp-multitypes-7.c,\n+\tgcc.dg/vect/slp-multitypes-8.c, gcc.dg/vect/slp-multitypes-9.c,\n+\tgcc.dg/vect/slp-multitypes-10.c, gcc.dg/vect/slp-multitypes-11.c,\n+\tgcc.dg/vect/slp-multitypes-12.c, gcc.dg/vect/slp-widen-mult-u8.c,\n+\tgcc.dg/vect/slp-widen-mult-s16.c, gcc.dg/vect/vect-multitypes-16.c,\n+\tgcc.dg/vect/vect-multitypes-17.c: Likewise.\n+\t* gcc.dg/vect/slp-9.c: Now vectorizable using SLP.\n+\t* gcc.dg/vect/slp-14.c, gcc.dg/vect/slp-5.c: Likewise.\n+\t* lib/target-supports.exp (check_effective_target_vect_long_long): New.\n+\n 2008-08-18  Adam Nemet  <anemet@caviumnetworks.com>\n \n \t* gcc.target/mips/ext-1.c: Add -mgp64 to dg-mips-options."}, {"sha": "2051e285f64a341ba6645ecf55ccf80c96d8e725", "filename": "gcc/testsuite/gcc.dg/vect/slp-14.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-14.c?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -15,7 +15,7 @@ main1 (int n)\n   unsigned short in2[N*16] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n   unsigned short out2[N*16];\n \n-  /* Multiple types are not SLPable yet.  */\n+  /* Multiple types are now SLPable.  */\n   for (i = 0; i < n; i++)\n     {\n       a0 = in[i*8] + 5;\n@@ -110,9 +110,7 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target { vect_strided && vect_int_mult  } } } }  */\n-/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\"  {target { ! { vect_strided  && vect_int_mult } } } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { xfail *-*-* }  } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_int_mult } } }  */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target vect_int_mult } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n   "}, {"sha": "033de778d275e1aa8e2f6ca66e3eca8141b7be66", "filename": "gcc/testsuite/gcc.dg/vect/slp-5.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-5.c?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -15,7 +15,7 @@ main1 ()\n   unsigned short ia[N];\n   unsigned int ib[N*2];\n \n-  /* Not SLPable for now: multiple types with SLP of the smaller type.  */\n+  /* Multiple types with SLP of the smaller type.  */\n   for (i = 0; i < N; i++)\n     {\n       out[i*8] = in[i*8];\n@@ -121,8 +121,7 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { target { vect_strided_wide } } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { target  { ! { vect_strided_wide } } } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\"  } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n   "}, {"sha": "461f32e82414d6c93c923eb7ce688e190558e972", "filename": "gcc/testsuite/gcc.dg/vect/slp-9.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-9.c?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -41,7 +41,7 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" {  target { vect_strided && vect_widen_mult_hi_to_si } } } }*/\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_widen_mult_hi_to_si } } }*/\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target vect_widen_mult_hi_to_si } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "a3b93b5f015dfbcd876ed3ea3c2d565b40d5acf2", "filename": "gcc/testsuite/gcc.dg/vect/slp-multitypes-1.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-1.c?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128 \n+\n+__attribute__ ((noinline)) int\n+main1 ()\n+{\n+  int i;\n+  unsigned short sout[N*8];\n+  unsigned int iout[N*8];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      sout[i*4] = 8;\n+      sout[i*4 + 1] = 18;\n+      sout[i*4 + 2] = 28;\n+      sout[i*4 + 3] = 38;\n+\n+      iout[i*4] = 8;\n+      iout[i*4 + 1] = 18;\n+      iout[i*4 + 2] = 28;\n+      iout[i*4 + 3] = 38;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (sout[i*4] != 8 \n+         || sout[i*4 + 1] != 18\n+         || sout[i*4 + 2] != 28\n+         || sout[i*4 + 3] != 38\n+         || iout[i*4] != 8\n+         || iout[i*4 + 1] != 18\n+         || iout[i*4 + 2] != 28\n+         || iout[i*4 + 3] != 38)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "28274017d6fbefb1a9c35e7b3430de0aed5ccca2", "filename": "gcc/testsuite/gcc.dg/vect/slp-multitypes-10.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-10.c?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+\n+unsigned int in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+\n+struct s \n+{\n+  unsigned char a;\n+  unsigned char b;\n+};\n+\n+__attribute__ ((noinline)) int\n+main1 ()\n+{\n+  int i;\n+  struct s out[N*4];\n+\n+  for (i = 0; i < N*4; i++)\n+    {\n+      out[i].a = (unsigned char) in[i*2] + 1;\n+      out[i].b = (unsigned char) in[i*2 + 1] + 2;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N*4; i++)\n+    {\n+      if (out[i].a !=  (unsigned char) in[i*2] + 1\n+         || out[i].b != (unsigned char) in[i*2 + 1] + 2)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_pack_trunc } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\"  { target vect_pack_trunc } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "2a04ce0c6d2fb0b14bad5746cf90debfee173bb9", "filename": "gcc/testsuite/gcc.dg/vect/slp-multitypes-11.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-11.c?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 18 \n+\n+struct s \n+{\n+  int a;\n+  int b;\n+  int c;\n+};\n+\n+char in[N*3] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53};\n+\n+__attribute__ ((noinline)) int\n+main1 ()\n+{\n+  int i;\n+  struct s out[N];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i].a = (int) in[i*3] + 1;\n+      out[i].b = (int) in[i*3 + 1] + 2;\n+      out[i].c = (int) in[i*3 + 2] + 3;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i].a !=  (int) in[i*3] + 1\n+         || out[i].b != (int) in[i*3 + 1] + 2\n+         || out[i].c != (int) in[i*3 + 2] + 3)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_unpack } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\"  { target vect_unpack } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "5d2140fda9642cc0bdd29bc0a604a3342e4af4c1", "filename": "gcc/testsuite/gcc.dg/vect/slp-multitypes-12.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-12.c?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128 \n+\n+__attribute__ ((noinline)) int\n+main1 ()\n+{\n+  int i;\n+  unsigned short sout[N*8];\n+  unsigned int iout[N*8];\n+  unsigned char cout[N*8];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      sout[i*4] = 8;\n+      sout[i*4 + 1] = 18;\n+      sout[i*4 + 2] = 28;\n+      sout[i*4 + 3] = 38;\n+\n+      iout[i*4] = 8;\n+      iout[i*4 + 1] = 18;\n+      iout[i*4 + 2] = 28;\n+      iout[i*4 + 3] = 38;\n+\n+      cout[i*4] = 1;\n+      cout[i*4 + 1] = 2;\n+      cout[i*4 + 2] = 3;\n+      cout[i*4 + 3] = 4;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (sout[i*4] != 8 \n+         || sout[i*4 + 1] != 18\n+         || sout[i*4 + 2] != 28\n+         || sout[i*4 + 3] != 38\n+         || iout[i*4] != 8\n+         || iout[i*4 + 1] != 18\n+         || iout[i*4 + 2] != 28\n+         || iout[i*4 + 3] != 38\n+         || cout[i*4] != 1\n+         || cout[i*4 + 1] != 2\n+         || cout[i*4 + 2] != 3\n+         || cout[i*4 + 3] != 4)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "02faec741df4ff70e36756365de20124fca55dc6", "filename": "gcc/testsuite/gcc.dg/vect/slp-multitypes-2.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-2.c?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -0,0 +1,83 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128 \n+\n+__attribute__ ((noinline)) int\n+main1 (unsigned short a0, unsigned short a1, unsigned short a2, \n+       unsigned short a3, unsigned short a4, unsigned short a5,\n+       unsigned short a6, unsigned short a7, unsigned short a8,\n+       unsigned short a9, unsigned short a10, unsigned short a11,\n+       unsigned short a12, unsigned short a13, unsigned short a14,\n+       unsigned short a15, unsigned char b0, unsigned char b1)\n+{\n+  int i;\n+  unsigned short out[N*16];\n+  unsigned char out2[N*16];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*16] = a8;\n+      out[i*16 + 1] = a7;\n+      out[i*16 + 2] = a1;\n+      out[i*16 + 3] = a2;\n+      out[i*16 + 4] = a8;\n+      out[i*16 + 5] = a5;\n+      out[i*16 + 6] = a5;\n+      out[i*16 + 7] = a4;\n+      out[i*16 + 8] = a12;\n+      out[i*16 + 9] = a13;\n+      out[i*16 + 10] = a14;\n+      out[i*16 + 11] = a15;\n+      out[i*16 + 12] = a6;\n+      out[i*16 + 13] = a9;\n+      out[i*16 + 14] = a0;\n+      out[i*16 + 15] = a7;\n+\n+      out2[i*2] = b1;\n+      out2[i*2+1] = b0;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*16] != a8\n+          || out[i*16 + 1] != a7\n+          || out[i*16 + 2] != a1\n+          || out[i*16 + 3] != a2\n+          || out[i*16 + 4] != a8\n+          || out[i*16 + 5] != a5\n+          || out[i*16 + 6] != a5\n+          || out[i*16 + 7] != a4\n+          || out[i*16 + 8] != a12\n+          || out[i*16 + 9] != a13\n+          || out[i*16 + 10] != a14\n+          || out[i*16 + 11] != a15\n+          || out[i*16 + 12] != a6\n+          || out[i*16 + 13] != a9\n+          || out[i*16 + 14] != a0\n+          || out[i*16 + 15] != a7\n+          || out2[i*2] != b1\n+          || out2[i*2 + 1] != b0)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0,20,21);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "0764441c140edc2bfe253559a7223a0b6ba63af3", "filename": "gcc/testsuite/gcc.dg/vect/slp-multitypes-3.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-3.c?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -0,0 +1,94 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+unsigned int in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+unsigned char in2[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+\n+__attribute__ ((noinline)) int\n+main1 ()\n+{\n+  int i;\n+  unsigned int out[N*8];\n+  unsigned char out2[N*8];\n+\n+  for (i = 0; i < N/2; i++)\n+    {\n+      out[i*8] = in[i*8] + 5;\n+      out[i*8 + 1] = in[i*8 + 1] + 6;\n+      out[i*8 + 2] = in[i*8 + 2] + 7;\n+      out[i*8 + 3] = in[i*8 + 3] + 8;\n+      out[i*8 + 4] = in[i*8 + 4] + 9;\n+      out[i*8 + 5] = in[i*8 + 5] + 10;\n+      out[i*8 + 6] = in[i*8 + 6] + 11;\n+      out[i*8 + 7] = in[i*8 + 7] + 12;\n+\n+      out2[i*16] = in2[i*16] + 2;\n+      out2[i*16 + 1] = in2[i*16 + 1] + 3;\n+      out2[i*16 + 2] = in2[i*16 + 2] + 4;\n+      out2[i*16 + 3] = in2[i*16 + 3] + 3;\n+      out2[i*16 + 4] = in2[i*16 + 4] + 2;\n+      out2[i*16 + 5] = in2[i*16 + 5] + 3;\n+      out2[i*16 + 6] = in2[i*16 + 6] + 2;\n+      out2[i*16 + 7] = in2[i*16 + 7] + 4;\n+      out2[i*16 + 8] = in2[i*16 + 8] + 2;\n+      out2[i*16 + 9] = in2[i*16 + 9] + 5;\n+      out2[i*16 + 10] = in2[i*16 + 10] + 2;\n+      out2[i*16 + 11] = in2[i*16 + 11] + 3;\n+      out2[i*16 + 12] = in2[i*16 + 12] + 4;\n+      out2[i*16 + 13] = in2[i*16 + 13] + 4;\n+      out2[i*16 + 14] = in2[i*16 + 14] + 3;\n+      out2[i*16 + 15] = in2[i*16 + 15] + 2;\n+\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      if (out[i*8] !=  in[i*8] + 5\n+         || out[i*8 + 1] != in[i*8 + 1] + 6\n+         || out[i*8 + 2] != in[i*8 + 2] + 7\n+         || out[i*8 + 3] != in[i*8 + 3] + 8\n+         || out[i*8 + 4] != in[i*8 + 4] + 9\n+         || out[i*8 + 5] != in[i*8 + 5] + 10\n+         || out[i*8 + 6] != in[i*8 + 6] + 11\n+         || out[i*8 + 7] != in[i*8 + 7] + 12\n+         || out2[i*16] !=  in2[i*16] + 2\n+         || out2[i*16 + 1] != in2[i*16 + 1] + 3\n+         || out2[i*16 + 2] != in2[i*16 + 2] + 4\n+         || out2[i*16 + 3] != in2[i*16 + 3] + 3\n+         || out2[i*16 + 4] != in2[i*16 + 4] + 2\n+         || out2[i*16 + 5] != in2[i*16 + 5] + 3\n+         || out2[i*16 + 6] != in2[i*16 + 6] + 2\n+         || out2[i*16 + 7] != in2[i*16 + 7] + 4\n+         || out2[i*16 + 8] != in2[i*16 + 8] + 2\n+         || out2[i*16 + 9] != in2[i*16 + 9] + 5\n+         || out2[i*16 + 10] != in2[i*16 + 10] + 2\n+         || out2[i*16 + 11] != in2[i*16 + 11] + 3\n+         || out2[i*16 + 12] != in2[i*16 + 12] + 4\n+         || out2[i*16 + 13] != in2[i*16 + 13] + 4\n+         || out2[i*16 + 14] != in2[i*16 + 14] + 3\n+         || out2[i*16 + 15] != in2[i*16 + 15] + 2)\n+ \n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "770ccfcea50baad0804a29db09cbf854c48a2e3d", "filename": "gcc/testsuite/gcc.dg/vect/slp-multitypes-4.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-4.c?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+\n+short in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+\n+__attribute__ ((noinline)) int\n+main1 ()\n+{\n+  int i;\n+  int out[N*8];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*8] = (int) in[i*8] + 1;\n+      out[i*8 + 1] = (int) in[i*8 + 1] + 2;\n+      out[i*8 + 2] = (int) in[i*8 + 2] + 3;\n+      out[i*8 + 3] = (int) in[i*8 + 3] + 4;\n+      out[i*8 + 4] = (int) in[i*8 + 4] + 5;\n+      out[i*8 + 5] = (int) in[i*8 + 5] + 6;\n+      out[i*8 + 6] = (int) in[i*8 + 6] + 7;\n+      out[i*8 + 7] = (int) in[i*8 + 7] + 8;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*8] !=  (int) in[i*8] + 1\n+         || out[i*8 + 1] != (int) in[i*8 + 1] + 2\n+         || out[i*8 + 2] != (int) in[i*8 + 2] + 3\n+         || out[i*8 + 3] != (int) in[i*8 + 3] + 4\n+         || out[i*8 + 4] != (int) in[i*8 + 4] + 5\n+         || out[i*8 + 5] != (int) in[i*8 + 5] + 6\n+         || out[i*8 + 6] != (int) in[i*8 + 6] + 7\n+         || out[i*8 + 7] != (int) in[i*8 + 7] + 8)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_unpack } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\"  { target vect_unpack } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "869d87dbcf296547515362a2412ed47a52ceb88c", "filename": "gcc/testsuite/gcc.dg/vect/slp-multitypes-5.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-5.c?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+\n+short in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+\n+__attribute__ ((noinline)) int\n+main1 ()\n+{\n+  int i;\n+  int out[N*8];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*8] = (short) in[i*8] + 1;\n+      out[i*8 + 1] = (short) in[i*8 + 1] + 2;\n+      out[i*8 + 2] = (short) in[i*8 + 2] + 3;\n+      out[i*8 + 3] = (short) in[i*8 + 3] + 4;\n+      out[i*8 + 4] = (short) in[i*8 + 4] + 5;\n+      out[i*8 + 5] = (short) in[i*8 + 5] + 6;\n+      out[i*8 + 6] = (short) in[i*8 + 6] + 7;\n+      out[i*8 + 7] = (short) in[i*8 + 7] + 8;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*8] !=  (short) in[i*8] + 1\n+         || out[i*8 + 1] != (short) in[i*8 + 1] + 2\n+         || out[i*8 + 2] != (short) in[i*8 + 2] + 3\n+         || out[i*8 + 3] != (short) in[i*8 + 3] + 4\n+         || out[i*8 + 4] != (short) in[i*8 + 4] + 5\n+         || out[i*8 + 5] != (short) in[i*8 + 5] + 6\n+         || out[i*8 + 6] != (short) in[i*8 + 6] + 7\n+         || out[i*8 + 7] != (short) in[i*8 + 7] + 8)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_pack_trunc } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target vect_pack_trunc } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "34f4f0b845ac113237ac9c78af9f601dc62af32f", "filename": "gcc/testsuite/gcc.dg/vect/slp-multitypes-6.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-6.c?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+\n+unsigned int in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+\n+__attribute__ ((noinline)) int\n+main1 ()\n+{\n+  int i;\n+  unsigned char out[N*8];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*8] = (unsigned char) in[i*8] + 1;\n+      out[i*8 + 1] = (unsigned char) in[i*8 + 1] + 2;\n+      out[i*8 + 2] = (unsigned char) in[i*8 + 2] + 3;\n+      out[i*8 + 3] = (unsigned char) in[i*8 + 3] + 4;\n+      out[i*8 + 4] = (unsigned char) in[i*8 + 4] + 5;\n+      out[i*8 + 5] = (unsigned char) in[i*8 + 5] + 6;\n+      out[i*8 + 6] = (unsigned char) in[i*8 + 6] + 7;\n+      out[i*8 + 7] = (unsigned char) in[i*8 + 7] + 8;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*8] !=  (unsigned char) in[i*8] + 1\n+         || out[i*8 + 1] != (unsigned char) in[i*8 + 1] + 2\n+         || out[i*8 + 2] != (unsigned char) in[i*8 + 2] + 3\n+         || out[i*8 + 3] != (unsigned char) in[i*8 + 3] + 4\n+         || out[i*8 + 4] != (unsigned char) in[i*8 + 4] + 5\n+         || out[i*8 + 5] != (unsigned char) in[i*8 + 5] + 6\n+         || out[i*8 + 6] != (unsigned char) in[i*8 + 6] + 7\n+         || out[i*8 + 7] != (unsigned char) in[i*8 + 7] + 8)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_pack_trunc } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\"  { target vect_pack_trunc } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "8021c4946506fa47fbe7f6ce6e1a5e61a1f4e652", "filename": "gcc/testsuite/gcc.dg/vect/slp-multitypes-7.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-7.c?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+\n+char in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+\n+__attribute__ ((noinline)) int\n+main1 ()\n+{\n+  int i;\n+  int out[N*8];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*8] = (int) in[i*8] + 1;\n+      out[i*8 + 1] = (int) in[i*8 + 1] + 2;\n+      out[i*8 + 2] = (int) in[i*8 + 2] + 3;\n+      out[i*8 + 3] = (int) in[i*8 + 3] + 4;\n+      out[i*8 + 4] = (int) in[i*8 + 4] + 5;\n+      out[i*8 + 5] = (int) in[i*8 + 5] + 6;\n+      out[i*8 + 6] = (int) in[i*8 + 6] + 7;\n+      out[i*8 + 7] = (int) in[i*8 + 7] + 8;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*8] !=  (int) in[i*8] + 1\n+         || out[i*8 + 1] != (int) in[i*8 + 1] + 2\n+         || out[i*8 + 2] != (int) in[i*8 + 2] + 3\n+         || out[i*8 + 3] != (int) in[i*8 + 3] + 4\n+         || out[i*8 + 4] != (int) in[i*8 + 4] + 5\n+         || out[i*8 + 5] != (int) in[i*8 + 5] + 6\n+         || out[i*8 + 6] != (int) in[i*8 + 6] + 7\n+         || out[i*8 + 7] != (int) in[i*8 + 7] + 8)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_unpack } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\"  { target vect_unpack } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "3d3340ae83be56d14df4b5553adf6be6047ff71f", "filename": "gcc/testsuite/gcc.dg/vect/slp-multitypes-8.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-8.c?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+\n+char in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+\n+__attribute__ ((noinline)) int\n+main1 ()\n+{\n+  int i;\n+  int out[N*8];\n+\n+  for (i = 0; i < N*4; i++)\n+    {\n+      out[i*2] = (int) in[i*2] + 1;\n+      out[i*2 + 1] = (int) in[i*2 + 1] + 2;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N*4; i++)\n+    {\n+      if (out[i*2] !=  (int) in[i*2] + 1\n+         || out[i*2 + 1] != (int) in[i*2 + 1] + 2)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_unpack } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\"  { target vect_unpack } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "7d317e2e65fb609b920a1030890077c67ce7ebc5", "filename": "gcc/testsuite/gcc.dg/vect/slp-multitypes-9.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-multitypes-9.c?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+\n+unsigned int in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+\n+__attribute__ ((noinline)) int\n+main1 ()\n+{\n+  int i;\n+  unsigned char out[N*8];\n+\n+  for (i = 0; i < N*4; i++)\n+    {\n+      out[i*2] = (unsigned char) in[i*2] + 1;\n+      out[i*2 + 1] = (unsigned char) in[i*2 + 1] + 2;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N*4; i++)\n+    {\n+      if (out[i*2] !=  (unsigned char) in[i*2] + 1\n+         || out[i*2 + 1] != (unsigned char) in[i*2 + 1] + 2)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_pack_trunc } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\"  { target vect_pack_trunc } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "ebc4b5069b5dce96cac8e45f88c69fe4c9352568", "filename": "gcc/testsuite/gcc.dg/vect/slp-widen-mult-s16.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-widen-mult-s16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-widen-mult-s16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-widen-mult-s16.c?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+short X[N] __attribute__ ((__aligned__(16)));\n+short Y[N] __attribute__ ((__aligned__(16)));\n+int result[N];\n+\n+/* short->int widening-mult */\n+__attribute__ ((noinline)) int\n+foo1(int len) {\n+  int i;\n+\n+  for (i=0; i<len/2; i++) {\n+    result[2*i] = X[2*i] * Y[2*i];\n+    result[2*i+1] = X[2*i+1] * Y[2*i+1];\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = i;\n+    Y[i] = 64-i;\n+  }\n+\n+  foo1 (N);\n+\n+  for (i=0; i<N; i++) {\n+    if (result[i] != X[i] * Y[i])\n+      abort ();\n+  }\n+  \n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_widen_mult_hi_to_si || vect_inpack } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target { vect_widen_mult_hi_to_si || vect_inpack } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "d510421889a13b963e7ab5663f5e4eff64aa29fb", "filename": "gcc/testsuite/gcc.dg/vect/slp-widen-mult-u8.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-widen-mult-u8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-widen-mult-u8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-widen-mult-u8.c?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+unsigned char X[N] __attribute__ ((__aligned__(16)));\n+unsigned char Y[N] __attribute__ ((__aligned__(16)));\n+unsigned short result[N];\n+\n+/* char->short widening-mult */\n+__attribute__ ((noinline)) int\n+foo1(int len) {\n+  int i;\n+\n+  for (i=0; i<len/2; i++) {\n+    result[2*i] = X[2*i] * Y[2*i];\n+    result[2*i+1] = X[2*i+1] * Y[2*i+1];\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = i;\n+    Y[i] = 64-i;\n+  }\n+\n+  foo1 (N);\n+\n+  for (i=0; i<N; i++) {\n+    if (result[i] != X[i] * Y[i])\n+      abort ();\n+  }\n+  \n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target { vect_widen_mult_qi_to_hi || vect_unpack } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target { vect_widen_mult_hi_to_si || vect_inpack } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "171de501e8438a52156e170cbfa75bb06270319e", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-16.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-16.c?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-require-effective-target vect_long_long } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+char x[N] __attribute__ ((__aligned__(16)));\n+\n+__attribute__ ((noinline)) int\n+foo (int len, long long *z) {\n+  int i;\n+\n+  for (i=0; i<len; i++) {\n+    z[i] = x[i];\n+  }\n+}\n+\n+\n+int main (void)\n+{\n+  char i;\n+  long long z[N+4];\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    x[i] = i;\n+  }\n+\n+  foo (N,z+2);\n+\n+  for (i=0; i<N; i++) {\n+    if (z[i+2] != x[i])\n+      abort ();\n+  }\n+  \n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target vect_unpack } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { ! vect_unpack } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "61670e6995ec5f98598248dc82335b685f019a61", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-17.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-17.c?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-require-effective-target vect_long_long } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+unsigned char uX[N] __attribute__ ((__aligned__(16)));\n+unsigned char uresultX[N];\n+unsigned long long uY[N] __attribute__ ((__aligned__(16)));\n+unsigned char uresultY[N];\n+\n+/* Unsigned type demotion (si->qi) */\n+\n+__attribute__ ((noinline)) int\n+foo1(int len) {\n+  int i;\n+\n+  for (i=0; i<len; i++) {\n+    uresultX[i] = uX[i];\n+    uresultY[i] = (unsigned char)uY[i];\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    uX[i] = 16-i;\n+    uY[i] = 16-i;\n+    if (i%5 == 0)\n+      uX[i] = 16-i;\n+  }\n+\n+  foo1 (N);\n+\n+  for (i=0; i<N; i++) {\n+    if (uresultX[i] != uX[i])\n+      abort ();\n+    if (uresultY[i] != (unsigned char)uY[i])\n+      abort ();\n+  }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_pack_trunc } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "78c143c3f0fa304642c46809369aec20b12d31e8", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -1526,6 +1526,29 @@ proc check_effective_target_vect_double { } {\n     return $et_vect_double_saved\n }\n \n+# Return 1 if the target supports hardware vectors of long long, 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+proc check_effective_target_vect_long_long { } {\n+    global et_vect_long_long_saved\n+\n+    if [info exists et_vect_long_long_saved] {\n+        verbose \"check_effective_target_vect_long_long: using cached result\" 2\n+    } else {\n+        set et_vect_long_long_saved 0\n+        if { [istarget i?86-*-*]\n+              || [istarget x86_64-*-*]\n+              || [istarget spu-*-*] } {\n+           set et_vect_long_long_saved 1\n+        }\n+    }\n+\n+    verbose \"check_effective_target_vect_long_long: returning $et_vect_long_long_saved\" 2\n+    return $et_vect_long_long_saved\n+}\n+\n+\n # Return 1 if the target plus current options does not support a vector\n # max instruction on \"int\", 0 otherwise.\n #"}, {"sha": "fcb9cbd5a24235fdf37037881a42dc4b02fdd3c0", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 90, "deletions": 35, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -462,8 +462,8 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t  ok = true;\n \t  if (STMT_VINFO_RELEVANT_P (stmt_info)\n \t      || STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def)\n-\t    ok = (vectorizable_type_promotion (stmt, NULL, NULL)\n-\t\t|| vectorizable_type_demotion (stmt, NULL, NULL)\n+\t    ok = (vectorizable_type_promotion (stmt, NULL, NULL, NULL)\n+\t\t|| vectorizable_type_demotion (stmt, NULL, NULL, NULL)\n \t\t|| vectorizable_conversion (stmt, NULL, NULL, NULL)\n \t\t|| vectorizable_operation (stmt, NULL, NULL, NULL)\n \t\t|| vectorizable_assignment (stmt, NULL, NULL, NULL)\n@@ -2497,7 +2497,8 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, slp_tree slp_node,\n \t\t\t     tree *first_stmt_def0_type, \n \t\t\t     tree *first_stmt_def1_type,\n \t\t\t     tree *first_stmt_const_oprnd,\n-\t\t\t     int ncopies_for_cost)\n+\t\t\t     int ncopies_for_cost,\n+                             bool *pattern0, bool *pattern1)\n {\n   tree oprnd;\n   unsigned int i, number_of_oprnds;\n@@ -2527,6 +2528,58 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, slp_tree slp_node,\n \t  return false;\n \t}\n \n+      /* Check if DEF_STMT is a part of a pattern and get the def stmt from\n+         the pattern. Check that all the stmts of the node are in the\n+         pattern.  */\n+      if (def_stmt && vinfo_for_stmt (def_stmt)\n+          && STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (def_stmt)))\n+        {\n+          if (!*first_stmt_dt0)\n+            *pattern0 = true;\n+          else\n+            {\n+              if (i == 1 && !*first_stmt_dt1)\n+                *pattern1 = true;\n+              else if ((i == 0 && !*pattern0) || (i == 1 && !*pattern1))\n+                {\n+                  if (vect_print_dump_info (REPORT_DETAILS))\n+                    {\n+                      fprintf (vect_dump, \"Build SLP failed: some of the stmts\"\n+                                     \" are in a pattern, and others are not \");\n+                      print_generic_expr (vect_dump, oprnd, TDF_SLIM);\n+                    }\n+\n+                  return false;\n+                }\n+            }\n+\n+          def_stmt = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (def_stmt));\n+          dt[i] = STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def_stmt));\n+\n+          if (*dt == vect_unknown_def_type)\n+            {\n+              if (vect_print_dump_info (REPORT_DETAILS))\n+                fprintf (vect_dump, \"Unsupported pattern.\");\n+              return false;\n+            }\n+\n+          switch (gimple_code (def_stmt))\n+            {\n+              case GIMPLE_PHI:\n+                def = gimple_phi_result (def_stmt);\n+                break;\n+\n+              case GIMPLE_ASSIGN:\n+                def = gimple_assign_lhs (def_stmt);\n+                break;\n+\n+              default:\n+                if (vect_print_dump_info (REPORT_DETAILS))\n+                  fprintf (vect_dump, \"unsupported defining stmt: \");\n+                return false;\n+            }\n+        }\n+\n       if (!*first_stmt_dt0)\n \t{\n \t  /* op0 of the first stmt of the group - store its info.  */\n@@ -2624,15 +2677,13 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, slp_tree slp_node,\n /* Recursively build an SLP tree starting from NODE.\n    Fail (and return FALSE) if def-stmts are not isomorphic, require data \n    permutation or are of unsupported types of operation. Otherwise, return \n-   TRUE.\n-   SLP_IMPOSSIBLE is TRUE if it is impossible to SLP in the loop, for example\n-   in the case of multiple types for now.  */\n+   TRUE.  */\n \n static bool\n vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node, \n-\t\t     unsigned int group_size, bool *slp_impossible,\n+\t\t     unsigned int group_size, \n \t\t     int *inside_cost, int *outside_cost,\n-\t\t     int ncopies_for_cost)\n+\t\t     int ncopies_for_cost, unsigned int *max_nunits)\n {\n   VEC (gimple, heap) *def_stmts0 = VEC_alloc (gimple, heap, group_size);\n   VEC (gimple, heap) *def_stmts1 =  VEC_alloc (gimple, heap, group_size);\n@@ -2653,6 +2704,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n   enum machine_mode vec_mode;\n   tree first_stmt_const_oprnd = NULL_TREE;\n   struct data_reference *first_dr;\n+  bool pattern0 = false, pattern1 = false;\n \n   /* For every stmt in NODE find its def stmt/s.  */\n   for (i = 0; VEC_iterate (gimple, stmts, i, stmt); i++)\n@@ -2691,16 +2743,13 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n       gcc_assert (LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n       vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n       ncopies = vectorization_factor / TYPE_VECTOR_SUBPARTS (vectype);\n-      if (ncopies > 1)\n-\t{\n-\t  /* FORNOW.  */\n-\t  if (vect_print_dump_info (REPORT_SLP)) \n-\t    fprintf (vect_dump, \"SLP failed - multiple types \");\n-\t  \n-\t  *slp_impossible = true;\n-\t  return false;\n-\t}\n+      if (ncopies > 1 && vect_print_dump_info (REPORT_SLP))\n+        fprintf (vect_dump, \"SLP with multiple types \");\n \n+      /* In case of multiple types we need to detect the smallest type.  */\n+      if (*max_nunits < TYPE_VECTOR_SUBPARTS (vectype))\n+        *max_nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+\t  \n       if (is_gimple_call (stmt))\n \trhs_code = CALL_EXPR;\n       else\n@@ -2799,14 +2848,20 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n \t\t\t\t\t\t&first_stmt_def0_type, \n \t\t\t\t\t\t&first_stmt_def1_type,\n \t\t\t\t\t\t&first_stmt_const_oprnd,\n-\t\t\t\t\t\tncopies_for_cost))\n+\t\t\t\t\t\tncopies_for_cost,\n+                                                &pattern0, &pattern1))\n \t\treturn false;\n \t    }\n \t    else\n \t      {\n \t\t/* Load.  */\n \t\tif (i == 0)\n \t\t  {\n+                    /* In case of multiple types we need to detect the smallest\n+                       type.  */\n+                    if (*max_nunits < TYPE_VECTOR_SUBPARTS (vectype))\n+                       *max_nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+\n \t\t    /* First stmt of the SLP group should be the first load of \n \t\t       the interleaving loop if data permutation is not allowed.\n \t\t       Check that there is no gap between the loads.  */\n@@ -2905,7 +2960,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n \t\t\t\t\t    &first_stmt_def0_type, \n \t\t\t\t\t    &first_stmt_def1_type,\n \t\t\t\t\t    &first_stmt_const_oprnd,\n-\t\t\t\t\t    ncopies_for_cost))\n+\t\t\t\t\t    ncopies_for_cost,\n+                                            &pattern0, &pattern1))\n \t    return false;\n \t}\n     }\n@@ -2929,8 +2985,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n       SLP_TREE_OUTSIDE_OF_LOOP_COST (left_node) = 0;\n       SLP_TREE_INSIDE_OF_LOOP_COST (left_node) = 0;\n       if (!vect_build_slp_tree (loop_vinfo, &left_node, group_size, \n-\t\t\t\tslp_impossible, inside_cost, outside_cost,\n-\t\t\t\tncopies_for_cost))\n+\t\t\t\tinside_cost, outside_cost,\n+\t\t\t\tncopies_for_cost, max_nunits))\n \treturn false;\n       \n       SLP_TREE_LEFT (*node) = left_node;\n@@ -2946,8 +3002,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n       SLP_TREE_OUTSIDE_OF_LOOP_COST (right_node) = 0;\n       SLP_TREE_INSIDE_OF_LOOP_COST (right_node) = 0;\n       if (!vect_build_slp_tree (loop_vinfo, &right_node, group_size,\n-\t\t\t\tslp_impossible, inside_cost, outside_cost,\n-\t\t\t\tncopies_for_cost))\n+\t\t\t\tinside_cost, outside_cost,\n+\t\t\t\tncopies_for_cost, max_nunits))\n \treturn false;\n       \n       SLP_TREE_RIGHT (*node) = right_node;\n@@ -3003,7 +3059,7 @@ vect_mark_slp_stmts (slp_tree node, enum slp_vect_type mark, int j)\n \n \n /* Analyze an SLP instance starting from a group of strided stores. Call\n-   vect_build_slp_tree to build a tree of packed stmts if possible. \n+   vect_build_slp_tree to build a tree of packed stmts if possible.  \n    Return FALSE if it's impossible to SLP any stmt in the loop.  */\n \n static bool\n@@ -3018,8 +3074,8 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, gimple stmt)\n   unsigned int vectorization_factor = 0, ncopies;\n   bool slp_impossible = false; \n   int inside_cost = 0, outside_cost = 0, ncopies_for_cost;\n+  unsigned int max_nunits = 0;\n \n-  /* FORNOW: multiple types are not supported.  */\n   scalar_type = TREE_TYPE (DR_REF (STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt))));\n   vectype = get_vectype_for_scalar_type (scalar_type);\n   if (!vectype)\n@@ -3035,13 +3091,6 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, gimple stmt)\n   nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   ncopies = vectorization_factor / nunits;\n-  if (ncopies > 1)\n-    {\n-      if (vect_print_dump_info (REPORT_SLP)) \n-\t  fprintf (vect_dump, \"SLP failed - multiple types \");\n-\n-      return false;\n-    }\n \n   /* Create a node (a root of the SLP tree) for the packed strided stores.  */ \n   SLP_TREE_SCALAR_STMTS (node) = VEC_alloc (gimple, heap, group_size);\n@@ -3069,13 +3118,18 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, gimple stmt)\n   ncopies_for_cost = unrolling_factor * group_size / nunits;\n \n   /* Build the tree for the SLP instance.  */\n-  if (vect_build_slp_tree (loop_vinfo, &node, group_size, &slp_impossible,\n-\t\t\t   &inside_cost, &outside_cost, ncopies_for_cost))\n+  if (vect_build_slp_tree (loop_vinfo, &node, group_size, &inside_cost,  \n+\t\t\t   &outside_cost, ncopies_for_cost, &max_nunits))\n     {\n       /* Create a new SLP instance.  */  \n       new_instance = XNEW (struct _slp_instance);\n       SLP_INSTANCE_TREE (new_instance) = node;\n       SLP_INSTANCE_GROUP_SIZE (new_instance) = group_size;\n+      /* Calculate the unrolling factor based on the smallest type.  */\n+      if (max_nunits > nunits)\n+        unrolling_factor = least_common_multiple (max_nunits, group_size)\n+                           / group_size;\n+\n       SLP_INSTANCE_UNROLLING_FACTOR (new_instance) = unrolling_factor;\n       SLP_INSTANCE_OUTSIDE_OF_LOOP_COST (new_instance) = outside_cost;\n       SLP_INSTANCE_INSIDE_OF_LOOP_COST (new_instance) = inside_cost;\n@@ -3181,7 +3235,8 @@ vect_detect_hybrid_slp_stmts (slp_tree node)\n \t&& TREE_CODE (gimple_op (stmt, 0)) == SSA_NAME)\n       FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, gimple_op (stmt, 0))\n \tif (vinfo_for_stmt (use_stmt)\n-\t    && !STMT_SLP_TYPE (vinfo_for_stmt (use_stmt)))\n+\t    && !STMT_SLP_TYPE (vinfo_for_stmt (use_stmt))\n+            && STMT_VINFO_RELEVANT (vinfo_for_stmt (use_stmt)))\n \t  vect_mark_slp_stmts (node, hybrid, i);\n \n   vect_detect_hybrid_slp_stmts (SLP_TREE_LEFT (node));"}, {"sha": "8486775ab775a0ba475c4e4cd6732b33f466248e", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -374,7 +374,8 @@ vect_recog_widen_mult_pattern (gimple last_stmt,\n   tree dummy;\n   tree var;\n   enum tree_code dummy_code;\n-  bool dummy_bool;\n+  int dummy_int;\n+  VEC (tree, heap) *dummy_vec;\n \n   if (!is_gimple_assign (last_stmt))\n     return NULL;\n@@ -415,7 +416,7 @@ vect_recog_widen_mult_pattern (gimple last_stmt,\n   if (!vectype\n       || !supportable_widening_operation (WIDEN_MULT_EXPR, last_stmt, vectype,\n \t\t\t\t\t  &dummy, &dummy, &dummy_code,\n-\t\t\t\t\t  &dummy_code, &dummy_bool, &dummy))\n+\t\t\t\t\t  &dummy_code, &dummy_int, &dummy_vec))\n     return NULL;\n \n   *type_in = vectype;"}, {"sha": "97366336b7bc6790a86b02f4f0e88011cf50c5f1", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 429, "deletions": 234, "changes": 663, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -1492,7 +1492,7 @@ vect_get_constant_vectors (slp_tree slp_node, VEC(tree,heap) **vec_oprnds,\n \n /* Get vectorized definitions from SLP_NODE that contains corresponding\n    vectorized def-stmts.  */\n- \n+\n static void\n vect_get_slp_vect_defs (slp_tree slp_node, VEC (tree,heap) **vec_oprnds)\n {\n@@ -1502,7 +1502,7 @@ vect_get_slp_vect_defs (slp_tree slp_node, VEC (tree,heap) **vec_oprnds)\n \n   gcc_assert (SLP_TREE_VEC_STMTS (slp_node));\n \n-  for (i = 0; \n+  for (i = 0;\n        VEC_iterate (gimple, SLP_TREE_VEC_STMTS (slp_node), i, vec_def_stmt);\n        i++)\n     {\n@@ -1520,43 +1520,56 @@ vect_get_slp_vect_defs (slp_tree slp_node, VEC (tree,heap) **vec_oprnds)\n    must be stored in the LEFT/RIGHT node of SLP_NODE, and we call\n    vect_get_slp_vect_defs() to retrieve them.  \n    If VEC_OPRNDS1 is NULL, don't get vector defs for the second operand (from\n-   the right node. This is used when the second operand must remain scalar.  */\n+   the right node. This is used when the second operand must remain scalar.  */ \n  \n static void\n vect_get_slp_defs (slp_tree slp_node, VEC (tree,heap) **vec_oprnds0,\n                    VEC (tree,heap) **vec_oprnds1)\n {\n   gimple first_stmt;\n   enum tree_code code;\n+  int number_of_vects;\n+\n+  /* The number of vector defs is determined by the number of vector statements\n+     in the node from which we get those statements.  */\n+  if (SLP_TREE_LEFT (slp_node)) \n+    number_of_vects = SLP_TREE_NUMBER_OF_VEC_STMTS (SLP_TREE_LEFT (slp_node));\n+  else\n+    number_of_vects = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n \n   /* Allocate memory for vectorized defs.  */\n-  *vec_oprnds0 = VEC_alloc (tree, heap, \n-\t\t\t    SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node));\n+  *vec_oprnds0 = VEC_alloc (tree, heap, number_of_vects);\n \n-  /* SLP_NODE corresponds either to a group of stores or to a group of \n+  /* SLP_NODE corresponds either to a group of stores or to a group of\n      unary/binary operations. We don't call this function for loads.  */\n-  if (SLP_TREE_LEFT (slp_node)) \n-    /* The defs are already vectorized.  */ \n+  if (SLP_TREE_LEFT (slp_node))\n+    /* The defs are already vectorized.  */\n     vect_get_slp_vect_defs (SLP_TREE_LEFT (slp_node), vec_oprnds0);\n   else\n     /* Build vectors from scalar defs.  */\n     vect_get_constant_vectors (slp_node, vec_oprnds0, 0);\n \n   first_stmt = VEC_index (gimple, SLP_TREE_SCALAR_STMTS (slp_node), 0);\n   if (STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt)))\n-    /* Since we don't call this function with loads, this is a group of \n+    /* Since we don't call this function with loads, this is a group of\n        stores.  */\n     return;\n \n   code = gimple_assign_rhs_code (first_stmt);\n   if (get_gimple_rhs_class (code) != GIMPLE_BINARY_RHS || !vec_oprnds1)\n     return;\n \n-  *vec_oprnds1 = VEC_alloc (tree, heap, \n-\t\t\t    SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node));\n+  /* The number of vector defs is determined by the number of vector statements\n+     in the node from which we get those statements.  */\n+  if (SLP_TREE_RIGHT (slp_node))\n+    number_of_vects = SLP_TREE_NUMBER_OF_VEC_STMTS (SLP_TREE_RIGHT (slp_node));\n+  else\n+    number_of_vects = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n+\n+  *vec_oprnds1 = VEC_alloc (tree, heap, number_of_vects);\n \n   if (SLP_TREE_RIGHT (slp_node))\n-    /* The defs are already vectorized.  */ \n+    /* The defs are already vectorized.  */\n     vect_get_slp_vect_defs (SLP_TREE_RIGHT (slp_node), vec_oprnds1);\n   else\n     /* Build vectors from scalar defs.  */\n@@ -3425,15 +3438,14 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n /* Function vect_gen_widened_results_half\n \n    Create a vector stmt whose code, type, number of arguments, and result\n-   variable are CODE, VECTYPE, OP_TYPE, and VEC_DEST, and its arguments are \n+   variable are CODE, OP_TYPE, and VEC_DEST, and its arguments are \n    VEC_OPRND0 and VEC_OPRND1. The new vector stmt is to be inserted at BSI.\n    In the case that CODE is a CALL_EXPR, this means that a call to DECL\n    needs to be created (DECL is a function-decl of a target-builtin).\n    STMT is the original scalar stmt that we are vectorizing.  */\n \n static gimple\n vect_gen_widened_results_half (enum tree_code code,\n-\t\t\t       tree vectype ATTRIBUTE_UNUSED,\n \t\t\t       tree decl,\n                                tree vec_oprnd0, tree vec_oprnd1, int op_type,\n \t\t\t       tree vec_dest, gimple_stmt_iterator *gsi,\n@@ -3517,8 +3529,8 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n   VEC(tree,heap) *vec_oprnds0 = NULL;\n   tree vop0;\n   tree integral_type;\n-  tree dummy;\n-  bool dummy_bool;\n+  VEC(tree,heap) *dummy = NULL;\n+  int dummy_int;\n \n   /* Is STMT a vectorizable conversion?   */\n \n@@ -3602,10 +3614,10 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \t  && !supportable_widening_operation (code, stmt, vectype_in,\n \t\t\t\t\t      &decl1, &decl2,\n \t\t\t\t\t      &code1, &code2,\n-                                              &dummy_bool, &dummy))\n+                                              &dummy_int, &dummy))\n       || (modifier == NARROW\n \t  && !supportable_narrowing_operation (code, stmt, vectype_in,\n-\t\t\t\t\t       &code1, &dummy_bool, &dummy)))\n+\t\t\t\t\t       &code1, &dummy_int, &dummy)))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"conversion not supported by target.\");\n@@ -3646,7 +3658,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \t  ssa_op_iter iter;\n \n \t  if (j == 0)\n-\t    vect_get_vec_defs (op0, NULL, stmt, &vec_oprnds0, NULL, slp_node);\n+\t    vect_get_vec_defs (op0, NULL, stmt, &vec_oprnds0, NULL, slp_node); \n \t  else\n \t    vect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds0, NULL);\n \n@@ -3694,7 +3706,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \n \t  /* Generate first half of the widened result:  */\n \t  new_stmt\n-\t    = vect_gen_widened_results_half (code1, vectype_out, decl1, \n+\t    = vect_gen_widened_results_half (code1, decl1, \n \t\t\t\t\t     vec_oprnd0, vec_oprnd1,\n \t\t\t\t\t     unary_op, vec_dest, gsi, stmt);\n \t  if (j == 0)\n@@ -3705,7 +3717,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \n \t  /* Generate second half of the widened result:  */\n \t  new_stmt\n-\t    = vect_gen_widened_results_half (code2, vectype_out, decl2,\n+\t    = vect_gen_widened_results_half (code2, decl2,\n \t\t\t\t\t     vec_oprnd0, vec_oprnd1,\n \t\t\t\t\t     unary_op, vec_dest, gsi, stmt);\n \t  STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n@@ -3780,15 +3792,18 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n   gimple def_stmt;\n   enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n   int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+  int ncopies;\n   int i;\n   VEC(tree,heap) *vec_oprnds = NULL;\n   tree vop;\n \n-  /* FORNOW: SLP with multiple types is not supported. The SLP analysis \n-     verifies this, so we can safely override NCOPIES with 1 here.  */\n+  /* Multiple types in SLP are handled by creating the appropriate number of\n+     vectorized stmts for each SLP node. Hence, NCOPIES is always 1 in\n+     case of SLP.  */\n   if (slp_node)\n     ncopies = 1;\n+  else\n+    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n \n   gcc_assert (ncopies >= 1);\n   if (ncopies > 1)\n@@ -3978,18 +3993,22 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   int nunits_in = TYPE_VECTOR_SUBPARTS (vectype);\n   int nunits_out;\n   tree vectype_out;\n-  int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n+  int ncopies;\n   int j, i;\n   VEC(tree,heap) *vec_oprnds0 = NULL, *vec_oprnds1 = NULL;\n   tree vop0, vop1;\n   unsigned int k;\n   bool shift_p = false;\n   bool scalar_shift_arg = false;\n \n-  /* FORNOW: SLP with multiple types is not supported. The SLP analysis verifies\n-     this, so we can safely override NCOPIES with 1 here.  */\n+  /* Multiple types in SLP are handled by creating the appropriate number of\n+     vectorized stmts for each SLP node. Hence, NCOPIES is always 1 in\n+     case of SLP.  */\n   if (slp_node)\n     ncopies = 1;\n+  else\n+    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n+\n   gcc_assert (ncopies >= 1);\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n@@ -4276,6 +4295,9 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \t    VEC_quick_push (gimple, SLP_TREE_VEC_STMTS (slp_node), new_stmt);\n         }\n \n+      if (slp_node)\n+        continue;\n+\n       if (j == 0)\n \tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n       else\n@@ -4291,6 +4313,109 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n }\n \n \n+/* Get vectorized definitions for loop-based vectorization. For the first\n+   operand we call vect_get_vec_def_for_operand() (with OPRND containing \n+   scalar operand), and for the rest we get a copy with \n+   vect_get_vec_def_for_stmt_copy() using the previous vector definition\n+   (stored in OPRND). See vect_get_vec_def_for_stmt_copy() for details.\n+   The vectors are collected into VEC_OPRNDS.  */\n+\n+static void\n+vect_get_loop_based_defs (tree *oprnd, gimple stmt, enum vect_def_type dt, \n+                          VEC (tree, heap) **vec_oprnds, int multi_step_cvt)\n+{\n+  tree vec_oprnd;\n+\n+  /* Get first vector operand.  */\n+  /* All the vector operands except the very first one (that is scalar oprnd)\n+     are stmt copies.  */\n+  if (TREE_CODE (TREE_TYPE (*oprnd)) != VECTOR_TYPE)  \n+    vec_oprnd = vect_get_vec_def_for_operand (*oprnd, stmt, NULL);\n+  else\n+    vec_oprnd = vect_get_vec_def_for_stmt_copy (dt, *oprnd);\n+\n+  VEC_quick_push (tree, *vec_oprnds, vec_oprnd);\n+\n+  /* Get second vector operand.  */\n+  vec_oprnd = vect_get_vec_def_for_stmt_copy (dt, vec_oprnd);\n+  VEC_quick_push (tree, *vec_oprnds, vec_oprnd);\n+    \n+  *oprnd = vec_oprnd;\n+\n+  /* For conversion in multiple steps, continue to get operands \n+     recursively.  */\n+  if (multi_step_cvt)\n+    vect_get_loop_based_defs (oprnd, stmt, dt, vec_oprnds,  multi_step_cvt - 1); \n+}\n+\n+\n+/* Create vectorized demotion statements for vector operands from VEC_OPRNDS.\n+   For multi-step conversions store the resulting vectors and call the function \n+   recursively.  */\n+\n+static void\n+vect_create_vectorized_demotion_stmts (VEC (tree, heap) **vec_oprnds,\n+                                       int multi_step_cvt, gimple stmt,\n+                                       VEC (tree, heap) *vec_dsts,\n+                                       gimple_stmt_iterator *gsi,\n+                                       slp_tree slp_node, enum tree_code code,\n+                                       stmt_vec_info *prev_stmt_info)\n+{\n+  unsigned int i;\n+  tree vop0, vop1, new_tmp, vec_dest;\n+  gimple new_stmt;\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\n+  vec_dest = VEC_pop (tree, vec_dsts); \n+\n+  for (i = 0; i < VEC_length (tree, *vec_oprnds); i += 2)\n+    {\n+      /* Create demotion operation.  */\n+      vop0 = VEC_index (tree, *vec_oprnds, i);\n+      vop1 = VEC_index (tree, *vec_oprnds, i + 1);\n+      new_stmt = gimple_build_assign_with_ops (code, vec_dest, vop0, vop1);\n+      new_tmp = make_ssa_name (vec_dest, new_stmt);\n+      gimple_assign_set_lhs (new_stmt, new_tmp);\n+      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\n+      if (multi_step_cvt)\n+        /* Store the resulting vector for next recursive call.  */\n+        VEC_replace (tree, *vec_oprnds, i/2, new_tmp);      \n+      else\n+        {\n+          /* This is the last step of the conversion sequence. Store the \n+             vectors in SLP_NODE or in vector info of the scalar statement\n+             (or in STMT_VINFO_RELATED_STMT chain).  */\n+          if (slp_node)\n+            VEC_quick_push (gimple, SLP_TREE_VEC_STMTS (slp_node), new_stmt);\n+          else\n+            {\n+              if (!*prev_stmt_info)\n+                STMT_VINFO_VEC_STMT (stmt_info) = new_stmt;\n+              else\n+                STMT_VINFO_RELATED_STMT (*prev_stmt_info) = new_stmt;\n+\n+              *prev_stmt_info = vinfo_for_stmt (new_stmt);\n+            }\n+        }\n+    }\n+\n+  /* For multi-step demotion operations we first generate demotion operations\n+     from the source type to the intermediate types, and then combine the \n+     results (stored in VEC_OPRNDS) in demotion operation to the destination\n+     type.  */\n+  if (multi_step_cvt)\n+    {\n+      /* At each level of recursion we have have of the operands we had at the\n+         previous level.  */\n+      VEC_truncate (tree, *vec_oprnds, (i+1)/2);\n+      vect_create_vectorized_demotion_stmts (vec_oprnds, multi_step_cvt - 1, \n+                                             stmt, vec_dsts, gsi, slp_node,\n+                                             code, prev_stmt_info);\n+    }\n+}\n+\n+\n /* Function vectorizable_type_demotion\n \n    Check if STMT performs a binary or unary operation that involves\n@@ -4301,31 +4426,28 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \n bool\n vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n-\t\t\t    gimple *vec_stmt)\n+\t\t\t    gimple *vec_stmt, slp_tree slp_node)\n {\n   tree vec_dest;\n   tree scalar_dest;\n   tree op0;\n-  tree vec_oprnd0=NULL, vec_oprnd1=NULL;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   enum tree_code code, code1 = ERROR_MARK;\n-  tree new_temp;\n   tree def;\n   gimple def_stmt;\n   enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n-  gimple new_stmt;\n   stmt_vec_info prev_stmt_info;\n   int nunits_in;\n   int nunits_out;\n   tree vectype_out;\n   int ncopies;\n-  int j;\n+  int j, i;\n   tree vectype_in;\n-  tree intermediate_type = NULL_TREE, narrow_type, double_vec_dest;\n-  bool double_op = false;\n-  tree first_vector, second_vector;\n-  tree vec_oprnd2 = NULL_TREE, vec_oprnd3 = NULL_TREE, last_oprnd = NULL_TREE;\n+  int multi_step_cvt = 0;\n+  VEC (tree, heap) *vec_oprnds0 = NULL;\n+  VEC (tree, heap) *vec_dsts = NULL, *interm_types = NULL, *tmp_vec_dsts = NULL;\n+  tree last_oprnd, intermediate_type;\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n@@ -4355,11 +4477,17 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!vectype_out)\n     return false;\n   nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n-  if (nunits_in != nunits_out / 2\n-      && nunits_in != nunits_out/4)\n+  if (nunits_in >= nunits_out)\n     return false;\n \n-  ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_out;\n+  /* Multiple types in SLP are handled by creating the appropriate number of\n+     vectorized stmts for each SLP node. Hence, NCOPIES is always 1 in\n+     case of SLP.  */\n+  if (slp_node)\n+    ncopies = 1;\n+  else\n+    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_out;\n+\n   gcc_assert (ncopies >= 1);\n \n   if (! ((INTEGRAL_TYPE_P (TREE_TYPE (scalar_dest))\n@@ -4379,7 +4507,7 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n \n   /* Supportable by target?  */\n   if (!supportable_narrowing_operation (code, stmt, vectype_in, &code1,\n-                                        &double_op, &intermediate_type))\n+                                        &multi_step_cvt, &interm_types))\n     return false;\n \n   STMT_VINFO_VECTYPE (stmt_info) = vectype_in;\n@@ -4398,89 +4526,157 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n     fprintf (vect_dump, \"transform type demotion operation. ncopies = %d.\",\n \t     ncopies);\n \n-  /* Handle def.  */\n-  /* In case of double demotion, we first generate demotion operation to the\n-     intermediate type, and then from that type to the final one.  */\n-  if (double_op)\n-    narrow_type = intermediate_type;\n+  /* In case of multi-step demotion, we first generate demotion operations to \n+     the intermediate types, and then from that types to the final one. \n+     We create vector destinations for the intermediate type (TYPES) received\n+     from supportable_narrowing_operation, and store them in the correct order \n+     for future use in vect_create_vectorized_demotion_stmts().  */\n+  if (multi_step_cvt)\n+    vec_dsts = VEC_alloc (tree, heap, multi_step_cvt + 1);\n   else\n-    narrow_type = vectype_out;\n-  vec_dest = vect_create_destination_var (scalar_dest, narrow_type);\n-  double_vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n+    vec_dsts = VEC_alloc (tree, heap, 1);\n+ \n+  vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n+  VEC_quick_push (tree, vec_dsts, vec_dest);\n+\n+  if (multi_step_cvt)\n+    {\n+      for (i = VEC_length (tree, interm_types) - 1; \n+           VEC_iterate (tree, interm_types, i, intermediate_type); i--)\n+        {\n+          vec_dest = vect_create_destination_var (scalar_dest, \n+                                                  intermediate_type);\n+          VEC_quick_push (tree, vec_dsts, vec_dest);\n+        }\n+    }\n \n   /* In case the vectorization factor (VF) is bigger than the number\n      of elements that we can fit in a vectype (nunits), we have to generate\n      more than one vector stmt - i.e - we need to \"unroll\" the\n      vector stmt by a factor VF/nunits.   */\n+  last_oprnd = op0;\n   prev_stmt_info = NULL;\n   for (j = 0; j < ncopies; j++)\n     {\n       /* Handle uses.  */\n-      if (j == 0)\n-\t{\n-          vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n-          vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd0);\n-          if (double_op)\n-            {\n-              /* For double demotion we need four operands.  */\n-              vec_oprnd2 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd1);\n-              vec_oprnd3 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd2);\n-            }\n-\t}\n+      if (slp_node)\n+        vect_get_slp_defs (slp_node, &vec_oprnds0, NULL); \n       else\n-\t{\n-          vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt[0], last_oprnd);\n-          vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd0);\n-          if (double_op)\n-            {\n-              /* For double demotion we need four operands.  */\n-              vec_oprnd2 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd1);\n-              vec_oprnd3 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd2);\n-            }\n-\t}\n+        {\n+          VEC_free (tree, heap, vec_oprnds0);\n+          vec_oprnds0 = VEC_alloc (tree, heap,\n+                        (multi_step_cvt ? vect_pow2 (multi_step_cvt) * 2 : 2));\n+          vect_get_loop_based_defs (&last_oprnd, stmt, dt[0], &vec_oprnds0,  \n+                                    vect_pow2 (multi_step_cvt) - 1);\n+        }\n \n       /* Arguments are ready. Create the new vector stmts.  */\n-      new_stmt = gimple_build_assign_with_ops (code1, vec_dest, vec_oprnd0,\n-                                               vec_oprnd1);\n-      first_vector = make_ssa_name (vec_dest, new_stmt);\n-      gimple_assign_set_lhs (new_stmt, first_vector);\n-      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+      tmp_vec_dsts = VEC_copy (tree, heap, vec_dsts);\n+      vect_create_vectorized_demotion_stmts (&vec_oprnds0,  \n+                                             multi_step_cvt, stmt, tmp_vec_dsts,\n+                                             gsi, slp_node, code1, \n+                                             &prev_stmt_info);\n+    }\n+\n+  VEC_free (tree, heap, vec_oprnds0);\n+  VEC_free (tree, heap, vec_dsts);\n+  VEC_free (tree, heap, tmp_vec_dsts);\n+  VEC_free (tree, heap, interm_types);\n+\n+  *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n+  return true;\n+}\n \n-      /* In the next iteration we will get copy for this operand.  */\n-      last_oprnd = vec_oprnd1;\n \n-      if (double_op)\n+/* Create vectorized promotion statements for vector operands from VEC_OPRNDS0\n+   and VEC_OPRNDS1 (for binary operations). For multi-step conversions store \n+   the resulting vectors and call the function recursively.  */\n+\n+static void\n+vect_create_vectorized_promotion_stmts (VEC (tree, heap) **vec_oprnds0,\n+                                        VEC (tree, heap) **vec_oprnds1,\n+                                        int multi_step_cvt, gimple stmt,\n+                                        VEC (tree, heap) *vec_dsts,\n+                                        gimple_stmt_iterator *gsi,\n+                                        slp_tree slp_node, enum tree_code code1,\n+                                        enum tree_code code2, tree decl1, \n+                                        tree decl2, int op_type,\n+                                        stmt_vec_info *prev_stmt_info)\n+{\n+  int i;\n+  tree vop0, vop1, new_tmp1, new_tmp2, vec_dest;\n+  gimple new_stmt1, new_stmt2;\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  VEC (tree, heap) *vec_tmp;\n+\n+  vec_dest = VEC_pop (tree, vec_dsts);\n+  vec_tmp = VEC_alloc (tree, heap, VEC_length (tree, *vec_oprnds0) * 2);\n+\n+  for (i = 0; VEC_iterate (tree, *vec_oprnds0, i, vop0); i++)\n+    {\n+      if (op_type == binary_op)\n+        vop1 = VEC_index (tree, *vec_oprnds1, i);\n+      else\n+        vop1 = NULL_TREE;\n+\n+      /* Generate the two halves of promotion operation.  */\n+      new_stmt1 = vect_gen_widened_results_half (code1, decl1, vop0, vop1,  \n+                                                 op_type, vec_dest, gsi, stmt);\n+      new_stmt2 = vect_gen_widened_results_half (code2, decl2, vop0, vop1,\n+                                                 op_type, vec_dest, gsi, stmt);\n+      if (is_gimple_call (new_stmt1))\n         {\n-          /* For double demotion operation we first generate two demotion\n-             operations from the source type to the intermediate type, and\n-             then combine the results in one demotion to the destination\n-             type.  */\n-          new_stmt = gimple_build_assign_with_ops (code1, vec_dest, vec_oprnd2,\n-                                                   vec_oprnd3);\n-          second_vector = make_ssa_name (vec_dest, new_stmt);\n-          gimple_assign_set_lhs (new_stmt, second_vector);\n-          vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\n-          new_stmt = gimple_build_assign_with_ops (code1, double_vec_dest, \n-                                                  first_vector, second_vector);\n-          new_temp = make_ssa_name (double_vec_dest, new_stmt);\n-          gimple_assign_set_lhs (new_stmt, new_temp);\n-          vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-         \n-          /* In the next iteration we will get copy for this operand.  */\n-          last_oprnd = vec_oprnd3;\n+          new_tmp1 = gimple_call_lhs (new_stmt1);\n+          new_tmp2 = gimple_call_lhs (new_stmt2);\n         }\n-\n-      if (j == 0)\n-\tSTMT_VINFO_VEC_STMT (stmt_info) = new_stmt;\n       else\n-\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+        {\n+          new_tmp1 = gimple_assign_lhs (new_stmt1);\n+          new_tmp2 = gimple_assign_lhs (new_stmt2);\n+        }\n \n-      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+      if (multi_step_cvt)\n+        {\n+          /* Store the results for the recursive call.  */\n+          VEC_quick_push (tree, vec_tmp, new_tmp1);\n+          VEC_quick_push (tree, vec_tmp, new_tmp2);\n+        }\n+      else\n+        {\n+          /* Last step of promotion sequience - store the results.  */\n+          if (slp_node)\n+            {\n+              VEC_quick_push (gimple, SLP_TREE_VEC_STMTS (slp_node), new_stmt1);\n+              VEC_quick_push (gimple, SLP_TREE_VEC_STMTS (slp_node), new_stmt2);\n+            }\n+          else\n+            {\n+              if (!*prev_stmt_info)\n+                STMT_VINFO_VEC_STMT (stmt_info) = new_stmt1;\n+              else\n+                STMT_VINFO_RELATED_STMT (*prev_stmt_info) = new_stmt1;\n+\n+              *prev_stmt_info = vinfo_for_stmt (new_stmt1);\n+              STMT_VINFO_RELATED_STMT (*prev_stmt_info) = new_stmt2;\n+              *prev_stmt_info = vinfo_for_stmt (new_stmt2);\n+            }\n+        }\n     }\n \n-  *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n-  return true;\n+  if (multi_step_cvt)\n+    {\n+      /* For multi-step promotion operation we first generate we call the \n+         function recurcively for every stage. We start from the input type,\n+         create promotion operations to the intermediate types, and then\n+         create promotions to the output type.  */\n+      *vec_oprnds0 = VEC_copy (tree, heap, vec_tmp);\n+      VEC_free (tree, heap, vec_tmp);\n+      vect_create_vectorized_promotion_stmts (vec_oprnds0, vec_oprnds1,\n+                                              multi_step_cvt - 1, stmt,\n+                                              vec_dsts, gsi, slp_node, code1,\n+                                              code2, decl2, decl2, op_type,\n+                                              prev_stmt_info);\n+    }\n }\n \n \n@@ -4494,7 +4690,7 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n \n bool\n vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n-\t\t\t     gimple *vec_stmt)\n+\t\t\t     gimple *vec_stmt, slp_tree slp_node)\n {\n   tree vec_dest;\n   tree scalar_dest;\n@@ -4508,17 +4704,17 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n   tree def;\n   gimple def_stmt;\n   enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n-  gimple new_stmt;\n   stmt_vec_info prev_stmt_info;\n   int nunits_in;\n   int nunits_out;\n   tree vectype_out;\n   int ncopies;\n-  int j;\n+  int j, i;\n   tree vectype_in;\n-  tree intermediate_type = NULL_TREE, first_vector, second_vector;\n-  bool double_op;\n-  tree wide_type, double_vec_dest;\n+  tree intermediate_type = NULL_TREE;\n+  int multi_step_cvt = 0;\n+  VEC (tree, heap) *vec_oprnds0 = NULL, *vec_oprnds1 = NULL;\n+  VEC (tree, heap) *vec_dsts = NULL, *interm_types = NULL, *tmp_vec_dsts = NULL;\n   \n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n@@ -4549,10 +4745,17 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!vectype_out)\n     return false;\n   nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n-  if (nunits_out != nunits_in / 2 && nunits_out != nunits_in/4)\n+  if (nunits_in <= nunits_out)\n     return false;\n \n-  ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n+  /* Multiple types in SLP are handled by creating the appropriate number of\n+     vectorized stmts for each SLP node. Hence, NCOPIES is always 1 in\n+     case of SLP.  */\n+  if (slp_node)\n+    ncopies = 1;\n+  else\n+    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n+\n   gcc_assert (ncopies >= 1);\n \n   if (! ((INTEGRAL_TYPE_P (TREE_TYPE (scalar_dest))\n@@ -4585,12 +4788,12 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n   /* Supportable by target?  */\n   if (!supportable_widening_operation (code, stmt, vectype_in,\n \t\t\t\t       &decl1, &decl2, &code1, &code2,\n-                                       &double_op, &intermediate_type))\n+                                       &multi_step_cvt, &interm_types))\n     return false;\n \n   /* Binary widening operation can only be supported directly by the\n      architecture.  */\n-  gcc_assert (!(double_op && op_type == binary_op));\n+  gcc_assert (!(multi_step_cvt && op_type == binary_op));\n \n   STMT_VINFO_VECTYPE (stmt_info) = vectype_in;\n \n@@ -4610,13 +4813,38 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n                         ncopies);\n \n   /* Handle def.  */\n-  if (double_op)\n-    wide_type = intermediate_type;\n+  /* In case of multi-step promotion, we first generate promotion operations \n+     to the intermediate types, and then from that types to the final one.\n+     We store vector destination in VEC_DSTS in the correct order for \n+     recursive creation of promotion operations in \n+     vect_create_vectorized_promotion_stmts(). Vector destinations are created\n+     according to TYPES recieved from supportable_widening_operation().   */\n+  if (multi_step_cvt)\n+    vec_dsts = VEC_alloc (tree, heap, multi_step_cvt + 1);\n   else\n-    wide_type = vectype_out;\n+    vec_dsts = VEC_alloc (tree, heap, 1);\n+\n+  vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n+  VEC_quick_push (tree, vec_dsts, vec_dest);\n \n-  vec_dest = vect_create_destination_var (scalar_dest, wide_type);\n-  double_vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n+  if (multi_step_cvt)\n+    {\n+      for (i = VEC_length (tree, interm_types) - 1;\n+           VEC_iterate (tree, interm_types, i, intermediate_type); i--)\n+        {\n+          vec_dest = vect_create_destination_var (scalar_dest,\n+                                                  intermediate_type);\n+          VEC_quick_push (tree, vec_dsts, vec_dest);\n+        }\n+    }\n+  \n+  if (!slp_node)\n+    {\n+      vec_oprnds0 = VEC_alloc (tree, heap, \n+                            (multi_step_cvt ? vect_pow2 (multi_step_cvt) : 1));\n+      if (op_type == binary_op)\n+        vec_oprnds1 = VEC_alloc (tree, heap, 1);\n+    }\n \n   /* In case the vectorization factor (VF) is bigger than the number\n      of elements that we can fit in a vectype (nunits), we have to generate\n@@ -4629,90 +4857,45 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n       /* Handle uses.  */\n       if (j == 0)\n         {\n-\t  vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n-\t  if (op_type == binary_op)\n-\t    vec_oprnd1 = vect_get_vec_def_for_operand (op1, stmt, NULL);\n-        }\n-      else\n-        {\n-\t  vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd0);\n-\t  if (op_type == binary_op)\n-\t    vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt[1], vec_oprnd1);\n-        }\n-\n-      /* Arguments are ready. Create the new vector stmt.  We are creating \n-         two vector defs because the widened result does not fit in one vector.\n-         The vectorized stmt can be expressed as a call to a target builtin,\n-         or a using a tree-code. In case of double promotion (from char to int,\n-         for example), the promotion is performed in two phases: first we\n-         generate a promotion operation from the source type to the intermediate\n-         type (short in case of char->int promotion), and then for each of the\n-         created vectors we generate a promotion statement from the intermediate\n-         type to the destination type.  */\n-      /* Generate first half of the widened result:  */\n-      new_stmt = vect_gen_widened_results_half (code1, wide_type, decl1, \n-\t\t\tvec_oprnd0, vec_oprnd1, op_type, vec_dest, gsi, stmt);\n-      if (is_gimple_call (new_stmt))\n-        first_vector = gimple_call_lhs (new_stmt);\n-      else\n-        first_vector =  gimple_assign_lhs (new_stmt);\n-\n-      if (!double_op)\n-        {\n-          if (j == 0)\n-            STMT_VINFO_VEC_STMT (stmt_info) = new_stmt;\n+          if (slp_node)\n+              vect_get_slp_defs (slp_node, &vec_oprnds0, &vec_oprnds1);\n           else\n-            STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-          prev_stmt_info = vinfo_for_stmt (new_stmt);\n-        }\n-\n-      /* Generate second half of the widened result:  */\n-      new_stmt = vect_gen_widened_results_half (code2, wide_type, decl2,\n-\t\t\tvec_oprnd0, vec_oprnd1, op_type, vec_dest, gsi, stmt);\n-      if (is_gimple_call (new_stmt))\n-        second_vector = gimple_call_lhs (new_stmt);\n-      else\n-        second_vector =  gimple_assign_lhs (new_stmt);\n-\n-      if (!double_op)\n-        {\n-          STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-          prev_stmt_info = vinfo_for_stmt (new_stmt);\n+            {\n+              vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n+              VEC_quick_push (tree, vec_oprnds0, vec_oprnd0);\n+              if (op_type == binary_op)\n+                {\n+                  vec_oprnd1 = vect_get_vec_def_for_operand (op1, stmt, NULL);\n+                  VEC_quick_push (tree, vec_oprnds1, vec_oprnd1);\n+                }\n+            }\n         }\n       else\n         {\n-          /* FIRST_VECTOR and SECOND_VECTOR are the results of source type\n-             to intermediate type promotion. Now we generate promotions\n-             for both of them to the destination type (i.e., four\n-             statements).  */\n-          new_stmt = vect_gen_widened_results_half (code1, vectype_out,\n-                                   decl1, first_vector, NULL_TREE, op_type,\n-                                   double_vec_dest, gsi, stmt);\n-          if (j == 0)\n-            STMT_VINFO_VEC_STMT (stmt_info) = new_stmt;\n-          else\n-            STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-          prev_stmt_info = vinfo_for_stmt (new_stmt);\n-\n-          new_stmt = vect_gen_widened_results_half (code2, vectype_out,\n-                                   decl2, first_vector, NULL_TREE, op_type,\n-                                   double_vec_dest, gsi, stmt);\n-          STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-          prev_stmt_info = vinfo_for_stmt (new_stmt);\n-\n-          new_stmt = vect_gen_widened_results_half (code1, vectype_out,\n-                                  decl1, second_vector, NULL_TREE, op_type,\n-                                  double_vec_dest, gsi, stmt);\n-          STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-          prev_stmt_info = vinfo_for_stmt (new_stmt);\n-\n-          new_stmt = vect_gen_widened_results_half (code2, vectype_out,\n-                                  decl2, second_vector, NULL_TREE, op_type,\n-                                  double_vec_dest, gsi, stmt);\n-          STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-          prev_stmt_info = vinfo_for_stmt (new_stmt);\n+          vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd0);\n+          VEC_replace (tree, vec_oprnds0, 0, vec_oprnd0);\n+          if (op_type == binary_op)\n+            {\n+              vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt[1], vec_oprnd1);\n+              VEC_replace (tree, vec_oprnds1, 0, vec_oprnd1);\n+            }\n         }\n-    }\n+\n+      /* Arguments are ready. Create the new vector stmts.  */\n+      tmp_vec_dsts = VEC_copy (tree, heap, vec_dsts);\n+      vect_create_vectorized_promotion_stmts (&vec_oprnds0, &vec_oprnds1,\n+                                              multi_step_cvt, stmt, \n+                                              tmp_vec_dsts,\n+                                              gsi, slp_node, code1, code2,\n+                                              decl1, decl2, op_type,\n+                                              &prev_stmt_info);\n+    }\n+\n+  VEC_free (tree, heap, vec_dsts);\n+  VEC_free (tree, heap, tmp_vec_dsts);\n+  VEC_free (tree, heap, interm_types);\n+  VEC_free (tree, heap, vec_oprnds0);\n+  VEC_free (tree, heap, vec_oprnds1);\n \n   *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n   return true;\n@@ -4925,7 +5108,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   stmt_vec_info prev_stmt_info = NULL;\n   tree dataref_ptr = NULL_TREE;\n   int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+  int ncopies;\n   int j;\n   gimple next_stmt, first_stmt = NULL;\n   bool strided_store = false;\n@@ -4937,10 +5120,13 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   stmt_vec_info first_stmt_vinfo;\n   unsigned int vec_num;\n \n-   /* FORNOW: SLP with multiple types is not supported. The SLP analysis verifies\n-      this, so we can safely override NCOPIES with 1 here.  */\n+  /* Multiple types in SLP are handled by creating the appropriate number of\n+     vectorized stmts for each SLP node. Hence, NCOPIES is always 1 in\n+     case of SLP.  */\n   if (slp)\n     ncopies = 1;\n+  else\n+    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n \n   gcc_assert (ncopies >= 1);\n \n@@ -5066,7 +5252,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \tstrided_store = false;\n \n       /* VEC_NUM is the number of vect stmts to be created for this group.  */\n-      if (slp && SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node) < group_size)\n+      if (slp)\n \tvec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n       else\n \tvec_num = group_size;\n@@ -5179,9 +5365,6 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t}\n       else \n \t{\n-\t  /* FORNOW SLP doesn't work for multiple types.  */\n-\t  gcc_assert (!slp);\n-\n \t  /* For interleaved stores we created vectorized defs for all the \n \t     defs stored in OPRNDS in the previous iteration (previous copy). \n \t     DR_CHAIN is then used as an input to vect_permute_store_chain(), \n@@ -5230,6 +5413,9 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t  new_stmt = gimple_build_assign (data_ref, vec_oprnd);\n \t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t  mark_symbols_for_renaming (new_stmt);\n+\n+          if (slp)\n+            continue;\n \t  \n           if (j == 0)\n             STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt =  new_stmt;\n@@ -5795,7 +5981,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   tree dataref_ptr = NULL_TREE;\n   gimple ptr_incr;\n   int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+  int ncopies;\n   int i, j, group_size;\n   tree msq = NULL_TREE, lsq;\n   tree offset = NULL_TREE;\n@@ -5812,10 +5998,13 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   bool slp = (slp_node != NULL);\n   enum tree_code code;\n \n-  /* FORNOW: SLP with multiple types is not supported. The SLP analysis verifies\n-      this, so we can safely override NCOPIES with 1 here.  */\n+  /* Multiple types in SLP are handled by creating the appropriate number of\n+     vectorized stmts for each SLP node. Hence, NCOPIES is always 1 in\n+     case of SLP.  */\n   if (slp)\n     ncopies = 1;\n+  else\n+    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n \n   gcc_assert (ncopies >= 1);\n \n@@ -5909,7 +6098,6 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t}\n       first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n       group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n-      dr_chain = VEC_alloc (tree, heap, group_size);\n \n       /* VEC_NUM is the number of vect stmts to be created for this group.  */\n       if (slp)\n@@ -5919,6 +6107,8 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t}\n       else\n \tvec_num = group_size;\n+\n+      dr_chain = VEC_alloc (tree, heap, vec_num);\n     }\n   else\n     {\n@@ -6203,9 +6393,8 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t    VEC_quick_push (gimple, SLP_TREE_VEC_STMTS (slp_node), new_stmt);\n \t}\n \n-      /* FORNOW: SLP with multiple types is unsupported.  */\n       if (slp)\n-\treturn true;\n+\tcontinue;\n \n       if (strided_load)\n \t{\n@@ -6500,14 +6689,12 @@ vect_transform_stmt (gimple stmt, gimple_stmt_iterator *gsi,\n   switch (STMT_VINFO_TYPE (stmt_info))\n     {\n     case type_demotion_vec_info_type:\n-      gcc_assert (!slp_node);\n-      done = vectorizable_type_demotion (stmt, gsi, &vec_stmt);\n+      done = vectorizable_type_demotion (stmt, gsi, &vec_stmt, slp_node);\n       gcc_assert (done);\n       break;\n \n     case type_promotion_vec_info_type:\n-      gcc_assert (!slp_node);\n-      done = vectorizable_type_promotion (stmt, gsi, &vec_stmt);\n+      done = vectorizable_type_promotion (stmt, gsi, &vec_stmt, slp_node);\n       gcc_assert (done);\n       break;\n \n@@ -6540,7 +6727,7 @@ vect_transform_stmt (gimple stmt, gimple_stmt_iterator *gsi,\n     case store_vec_info_type:\n       done = vectorizable_store (stmt, gsi, &vec_stmt, slp_node);\n       gcc_assert (done);\n-      if (STMT_VINFO_STRIDED_ACCESS (stmt_info))\n+      if (STMT_VINFO_STRIDED_ACCESS (stmt_info) && !slp_node)\n \t{\n \t  /* In case of interleaving, the whole chain is vectorized when the\n \t     last store in the chain is reached. Store stmts before the last\n@@ -7598,21 +7785,38 @@ vect_remove_stores (gimple first_stmt)\n /* Vectorize SLP instance tree in postorder.  */\n \n static bool\n-vect_schedule_slp_instance (slp_tree node, unsigned int vec_stmts_size)\n+vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n+                            unsigned int vectorization_factor)\n {\n   gimple stmt;\n   bool strided_store, is_store;\n   gimple_stmt_iterator si;\n   stmt_vec_info stmt_info;\n+  unsigned int vec_stmts_size, nunits, group_size;\n+  tree vectype;\n \n   if (!node)\n     return false;\n \n-  vect_schedule_slp_instance (SLP_TREE_LEFT (node), vec_stmts_size);\n-  vect_schedule_slp_instance (SLP_TREE_RIGHT (node), vec_stmts_size);\n+  vect_schedule_slp_instance (SLP_TREE_LEFT (node), instance,\n+                              vectorization_factor);\n+  vect_schedule_slp_instance (SLP_TREE_RIGHT (node), instance,\n+                              vectorization_factor);\n   \n-  stmt = VEC_index(gimple, SLP_TREE_SCALAR_STMTS (node), 0);\n+  stmt = VEC_index (gimple, SLP_TREE_SCALAR_STMTS (node), 0);\n   stmt_info = vinfo_for_stmt (stmt);\n+  /* VECTYPE is the type of the destination.  */\n+  vectype = get_vectype_for_scalar_type (TREE_TYPE (gimple_assign_lhs (stmt)));\n+  nunits = (unsigned int) TYPE_VECTOR_SUBPARTS (vectype);\n+  group_size = SLP_INSTANCE_GROUP_SIZE (instance);\n+\n+  /* For each SLP instance calculate number of vector stmts to be created\n+     for the scalar stmts in each node of the SLP tree. Number of vector\n+     elements in one vector iteration is the number of scalar elements in\n+     one scalar iteration (GROUP_SIZE) multiplied by VF divided by vector\n+     size.  */\n+  vec_stmts_size = (vectorization_factor * group_size) / nunits;\n+\n   SLP_TREE_VEC_STMTS (node) = VEC_alloc (gimple, heap, vec_stmts_size);\n   SLP_TREE_NUMBER_OF_VEC_STMTS (node) = vec_stmts_size;\n \n@@ -7644,30 +7848,21 @@ vect_schedule_slp_instance (slp_tree node, unsigned int vec_stmts_size)\n \n \n static bool\n-vect_schedule_slp (loop_vec_info loop_vinfo, unsigned int nunits)\n+vect_schedule_slp (loop_vec_info loop_vinfo)\n {\n   VEC (slp_instance, heap) *slp_instances = \n     LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n   slp_instance instance;\n-  unsigned int vec_stmts_size;\n-  unsigned int group_size, i;\n-  unsigned int vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  unsigned int i;\n   bool is_store = false;\n \n   for (i = 0; VEC_iterate (slp_instance, slp_instances, i, instance); i++)\n     {\n-      group_size = SLP_INSTANCE_GROUP_SIZE (instance);\n-      /* For each SLP instance calculate number of vector stmts to be created \n-\t for the scalar stmts in each node of the SLP tree. Number of vector \n-\t elements in one vector iteration is the number of scalar elements in \n-\t one scalar iteration (GROUP_SIZE) multiplied by VF divided by vector \n-\t size.  */\t\t      \n-      vec_stmts_size = vectorization_factor * group_size / nunits;\n-\t\t\t  \n       /* Schedule the tree of INSTANCE.  */\n-      is_store = vect_schedule_slp_instance (SLP_INSTANCE_TREE (instance), \n-\t\t\t\t\t     vec_stmts_size);\n-\t\t     \n+      is_store = vect_schedule_slp_instance (SLP_INSTANCE_TREE (instance),\n+                                          instance,\n+                                          LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n+\t\t\t  \n       if (vect_print_dump_info (REPORT_VECTORIZED_LOOPS)\n \t  || vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \tfprintf (vect_dump, \"vectorizing stmts using SLP.\");\n@@ -7826,7 +8021,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t\t  if (vect_print_dump_info (REPORT_DETAILS))\n \t\t    fprintf (vect_dump, \"=== scheduling SLP instances ===\");\n \n-\t\t  is_store = vect_schedule_slp (loop_vinfo, nunits);\n+\t\t  is_store = vect_schedule_slp (loop_vinfo);\n \n \t\t  /* IS_STORE is true if STMT is a store. Stores cannot be of\n \t\t     hybrid SLP type. They are removed in"}, {"sha": "437b145db0f63ab36f0f23787fff0113f4c137d6", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 95, "deletions": 63, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -2138,30 +2138,30 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, gimple *def_stmt,\n    - DECL1 and DECL2 are decls of target builtin functions to be used\n    when vectorizing the operation, if available. In this case,\n    CODE1 and CODE2 are CALL_EXPR.  \n-   - DOUBLE_OP determines if the operation is a double cast, like\n-   char->short->int\n-   - INTERM_TYPE is the intermediate type required to perform the \n-   widening operation (short in the above example)  */\n+   - MULTI_STEP_CVT determines the number of required intermediate steps in\n+   case of multi-step conversion (like char->short->int - in that case\n+   MULTI_STEP_CVT will be 1).\n+   - INTERM_TYPES contains the intermediate type required to perform the \n+   widening operation (short in the above example).  */   \n \n bool\n supportable_widening_operation (enum tree_code code, gimple stmt, tree vectype,\n                                 tree *decl1, tree *decl2,\n                                 enum tree_code *code1, enum tree_code *code2,\n-                                bool *double_op, tree *interm_type)\n+                                int *multi_step_cvt,\n+                                VEC (tree, heap) **interm_types)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *vect_loop = LOOP_VINFO_LOOP (loop_info);\n   bool ordered_p;\n   enum machine_mode vec_mode;\n-  enum insn_code icode1, icode2;\n+  enum insn_code icode1 = 0, icode2 = 0;\n   optab optab1, optab2;\n   tree type = gimple_expr_type (stmt);\n   tree wide_vectype = get_vectype_for_scalar_type (type);\n   enum tree_code c1, c2;\n \n-  *double_op = false;\n-\n   /* The result of a vectorized widening operation usually requires two vectors\n      (because the widened results do not fit int one vector). The generated \n      vector results would normally be expected to be generated in the same \n@@ -2272,52 +2272,60 @@ supportable_widening_operation (enum tree_code code, gimple stmt, tree vectype,\n \n   vec_mode = TYPE_MODE (vectype);\n   if ((icode1 = optab_handler (optab1, vec_mode)->insn_code) == CODE_FOR_nothing\n-      || (icode2 = optab_handler (optab2, vec_mode)->insn_code)\n-                                                        == CODE_FOR_nothing)\n+       || (icode2 = optab_handler (optab2, vec_mode)->insn_code)\n+                                                       == CODE_FOR_nothing)\n     return false;\n \n-  /* Check if it's a double cast, like char->int. In such case the intermediate\n-     type is short, and we check that char->short->int operaion is supported by\n-     the target.  */\n+  /* Check if it's a multi-step conversion that can be done using intermediate \n+     types.  */\n   if (insn_data[icode1].operand[0].mode != TYPE_MODE (wide_vectype)\n-      || insn_data[icode2].operand[0].mode != TYPE_MODE (wide_vectype))\n+       || insn_data[icode2].operand[0].mode != TYPE_MODE (wide_vectype))\n     {\n-      if (code == NOP_EXPR)\n-        {\n-          enum machine_mode intermediate_mode =\n-                                             insn_data[icode1].operand[0].mode;\n-          tree intermediate_type =\n-                      lang_hooks.types.type_for_mode (intermediate_mode,\n-                                                      TYPE_UNSIGNED (vectype));\n-          optab optab3 = optab_for_tree_code (c1, intermediate_type,\n-                                              optab_default);\n-          optab optab4 = optab_for_tree_code (c2, intermediate_type,\n-                                              optab_default);\n-\n-          if (!optab3 || !optab4)\n-            return false;\n+      int i;\n+      tree prev_type = vectype, intermediate_type;\n+      enum machine_mode intermediate_mode, prev_mode = vec_mode;\n+      optab optab3, optab4;\n \n-          if ((icode1 = optab1->handlers[(int) vec_mode].insn_code)\n+      if (!CONVERT_EXPR_CODE_P (code))\n+        return false;\n+      \n+      *code1 = c1;\n+      *code2 = c2;\n+    \n+      /* We assume here that there will not be more than MAX_INTERM_CVT_STEPS\n+         intermediate  steps in promotion sequence. We try MAX_INTERM_CVT_STEPS\n+         to get to NARROW_VECTYPE, and fail if we do not.  */\n+      *interm_types = VEC_alloc (tree, heap, MAX_INTERM_CVT_STEPS);\n+      for (i = 0; i < 3; i++)\n+        {\n+          intermediate_mode = insn_data[icode1].operand[0].mode;\n+          intermediate_type = lang_hooks.types.type_for_mode (intermediate_mode,\n+                                                     TYPE_UNSIGNED (prev_type));\n+          optab3 = optab_for_tree_code (c1, intermediate_type, optab_default);\n+          optab4 = optab_for_tree_code (c2, intermediate_type, optab_default);\n+\n+          if (!optab3 || !optab4\n+              || (icode1 = optab1->handlers[(int) prev_mode].insn_code)\n                                                         == CODE_FOR_nothing\n               || insn_data[icode1].operand[0].mode != intermediate_mode\n-              || (icode2 = optab2->handlers[(int) vec_mode].insn_code)\n+              || (icode2 = optab2->handlers[(int) prev_mode].insn_code)\n                                                         == CODE_FOR_nothing\n               || insn_data[icode2].operand[0].mode != intermediate_mode\n-              || (icode1 = optab3->handlers[(int) intermediate_mode].insn_code)\n+              || (icode1 = optab3->handlers[(int) intermediate_mode].insn_code) \n                                                         == CODE_FOR_nothing\n-              || insn_data[icode1].operand[0].mode != TYPE_MODE (wide_vectype)\n               || (icode2 = optab4->handlers[(int) intermediate_mode].insn_code)\n-                                                        == CODE_FOR_nothing\n-              || insn_data[icode2].operand[0].mode != TYPE_MODE (wide_vectype))\n+                                                        == CODE_FOR_nothing)\n             return false;\n-          else\n-            {\n-              *double_op = true;\n-              *interm_type = intermediate_type;\n-              *code1 = c1;\n-              *code2 = c2;\n-              return true;\n-            }\n+\n+          VEC_quick_push (tree, *interm_types, intermediate_type);\n+          (*multi_step_cvt)++;\n+\n+          if (insn_data[icode1].operand[0].mode == TYPE_MODE (wide_vectype)\n+              && insn_data[icode2].operand[0].mode == TYPE_MODE (wide_vectype))\n+            return true;\n+\n+          prev_type = intermediate_type;\n+          prev_mode = intermediate_mode;\n         }\n \n        return false;\n@@ -2342,23 +2350,26 @@ supportable_widening_operation (enum tree_code code, gimple stmt, tree vectype,\n    Output:\n    - CODE1 is the code of a vector operation to be used when \n    vectorizing the operation, if available. \n-   - DOUBLE_OP determines if the operation is a double cast, like\n-   int->short->char\n-   - INTERMIDIATE_TYPE is the intermediate type required to perform the\n-   widening operation (short in the above example) */\n+   - MULTI_STEP_CVT determines the number of required intermediate steps in\n+   case of multi-step conversion (like int->short->char - in that case\n+   MULTI_STEP_CVT will be 1).\n+   - INTERM_TYPES contains the intermediate type required to perform the\n+   narrowing operation (short in the above example).   */ \n \n bool\n supportable_narrowing_operation (enum tree_code code,\n-\t\t\t\t const_gimple stmt, const_tree vectype,\n-\t\t\t\t enum tree_code *code1, bool *double_op,\n-                                 tree *intermediate_type)\n+\t\t\t\t const_gimple stmt, tree vectype,\n+\t\t\t\t enum tree_code *code1, int *multi_step_cvt,\n+                                 VEC (tree, heap) **interm_types)\n {\n   enum machine_mode vec_mode;\n   enum insn_code icode1;\n   optab optab1, interm_optab;\n   tree type = gimple_expr_type (stmt);\n   tree narrow_vectype = get_vectype_for_scalar_type (type);\n   enum tree_code c1;\n+  tree intermediate_type, prev_type;\n+  int i;\n \n   switch (code)\n     {\n@@ -2393,24 +2404,45 @@ supportable_narrowing_operation (enum tree_code code,\n        == CODE_FOR_nothing)\n     return false;\n \n-  /* In case of NUNITS_IN == NUNITS_OUT/4 check that the it is possible to\n-     perform the operation using an intermediate type of NUNITS_OUT/2.  */\n+  /* Check if it's a multi-step conversion that can be done using intermediate\n+     types.  */\n   if (insn_data[icode1].operand[0].mode != TYPE_MODE (narrow_vectype))\n     {\n-      enum machine_mode intermediate_mode = insn_data[icode1].operand[0].mode;\n-      *intermediate_type = lang_hooks.types.type_for_mode (intermediate_mode,\n-                                                 TYPE_UNSIGNED (vectype));\n-      interm_optab = optab_for_tree_code (VEC_PACK_TRUNC_EXPR,\n-                                          *intermediate_type, optab_default);\n-      if (!interm_optab)\n-        return false;\n+      enum machine_mode intermediate_mode, prev_mode = vec_mode;\n+\n+      *code1 = c1;\n+      prev_type = vectype;\n+      /* We assume here that there will not be more than MAX_INTERM_CVT_STEPS\n+         intermediate  steps in promotion sequence. We try MAX_INTERM_CVT_STEPS\n+         to get to NARROW_VECTYPE, and fail if we do not.  */\n+      *interm_types = VEC_alloc (tree, heap, MAX_INTERM_CVT_STEPS);\n+      for (i = 0; i < 3; i++)\n+        {\n+          intermediate_mode = insn_data[icode1].operand[0].mode;\n+          intermediate_type = lang_hooks.types.type_for_mode (intermediate_mode,\n+                                                     TYPE_UNSIGNED (prev_type));\n+          interm_optab = optab_for_tree_code (c1, intermediate_type, \n+                                              optab_default);\n+          if (!interm_optab  \n+              || (icode1 = optab1->handlers[(int) prev_mode].insn_code)\n+                                                        == CODE_FOR_nothing\n+              || insn_data[icode1].operand[0].mode != intermediate_mode\n+              || (icode1 \n+                  = interm_optab->handlers[(int) intermediate_mode].insn_code)\n+                 == CODE_FOR_nothing)\n+            return false;\n \n-      if ((icode1 = interm_optab->handlers[(int) intermediate_mode].insn_code)\n-           == CODE_FOR_nothing\n-          || insn_data[icode1].operand[0].mode != TYPE_MODE (narrow_vectype))\n-        return false;\n+          VEC_quick_push (tree, *interm_types, intermediate_type);\n+          (*multi_step_cvt)++;\n+\n+          if (insn_data[icode1].operand[0].mode == TYPE_MODE (narrow_vectype))\n+            return true;\n \n-      *double_op = true;\n+          prev_type = intermediate_type;\n+          prev_mode = intermediate_mode;\n+        }\n+\n+      return false;\n     }\n \n   *code1 = c1;"}, {"sha": "a22353ccefe3fbdffd6054f0bdf722064617a774", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59337297f9410a407e2e8e89f38ebbc9aa40df/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=5d59337297f9410a407e2e8e89f38ebbc9aa40df", "patch": "@@ -522,6 +522,10 @@ typedef struct _stmt_vec_info {\n #define TARG_VEC_STORE_COST          1\n #endif\n \n+/* The maximum number of intermediate steps required in multi-step type\n+   conversion.  */\n+#define MAX_INTERM_CVT_STEPS         3\n+\n /* Avoid GTY(()) on stmt_vec_info.  */\n typedef void *vec_void_p;\n DEF_VEC_P (vec_void_p);\n@@ -602,6 +606,16 @@ stmt_vinfo_set_outside_of_loop_cost (stmt_vec_info stmt_info, slp_tree slp_node,\n     STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info) = cost;\n }     \n \n+static inline int\n+vect_pow2 (int x)\n+{\n+  int i, res = 1;\n+\n+  for (i = 0; i < x; i++)\n+    res *= 2;\n+\n+  return res;\n+}\n \n /*-----------------------------------------------------------------*/\n /* Info on data references alignment.                              */\n@@ -671,9 +685,10 @@ extern enum dr_alignment_support vect_supportable_dr_alignment\n   (struct data_reference *);\n extern bool reduction_code_for_scalar_code (enum tree_code, enum tree_code *);\n extern bool supportable_widening_operation (enum tree_code, gimple, tree,\n-  tree *, tree *, enum tree_code *, enum tree_code *, bool *, tree *);\n+  tree *, tree *, enum tree_code *, enum tree_code *, \n+  int *, VEC (tree, heap) **);\n extern bool supportable_narrowing_operation (enum tree_code, const_gimple,\n-\t\t\t     const_tree, enum tree_code *, bool *, tree *);\n+\t     tree, enum tree_code *, int *, VEC (tree, heap) **);\n \n /* Creation and deletion of loop and stmt info structs.  */\n extern loop_vec_info new_loop_vec_info (struct loop *loop);\n@@ -705,9 +720,9 @@ extern bool vectorizable_store (gimple, gimple_stmt_iterator *, gimple *,\n extern bool vectorizable_operation (gimple, gimple_stmt_iterator *, gimple *,\n \t\t\t\t    slp_tree);\n extern bool vectorizable_type_promotion (gimple, gimple_stmt_iterator *,\n-\t\t\t\t\t gimple *);\n+\t\t\t\t\t gimple *, slp_tree);\n extern bool vectorizable_type_demotion (gimple, gimple_stmt_iterator *,\n-\t\t\t\t\tgimple *);\n+\t\t\t\t\tgimple *, slp_tree);\n extern bool vectorizable_conversion (gimple, gimple_stmt_iterator *, gimple *,\n \t\t\t\t     slp_tree);\n extern bool vectorizable_assignment (gimple, gimple_stmt_iterator *, gimple *,"}]}