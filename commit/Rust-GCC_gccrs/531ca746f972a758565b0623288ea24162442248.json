{"sha": "531ca746f972a758565b0623288ea24162442248", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTMxY2E3NDZmOTcyYTc1ODU2NWIwNjIzMjg4ZWEyNDE2MjQ0MjI0OA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2009-09-22T15:11:37Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2009-09-22T15:11:37Z"}, "message": "re PR target/41246 (should \"sorry\" when regparm=3 and nested functions are encountered)\n\n\tPR target/41246\n\t* target.h (struct gcc_target): Add asm_out.trampoline_template,\n\tcalls.static_chain, calls.trampoline_init,\n\tcalls.trampoline_adjust_address.\n\t* target-def.h (TARGET_ASM_TRAMPOLINE_TEMPLATE): New.\n\t(TARGET_STATIC_CHAIN, TARGET_TRAMPOLINE_INIT): New.\n\t(TARGET_TRAMPOLINE_ADJUST_ADDRESS): New.\n\t* builtins.c (expand_builtin_setjmp_receiver): Use\n\ttargetm.calls.static_chain; only clobber registers.\n\t(expand_builtin_init_trampoline): Use targetm.calls.trampoline_init;\n\tset up memory attributes properly for the trampoline block.\n\t(expand_builtin_adjust_trampoline): Use\n\ttargetm.calls.trampoline_adjust_address.\n\t* calls.c (prepare_call_address): Add fndecl argument.  Use\n\ttargetm.calls.static_chain.\n\t* df-scan.c (df_need_static_chain_reg): Remove.\n\t(df_get_entry_block_def_set): Use targetm.calls.static_chain;\n\tconsolodate static chain handling.\n\t* doc/tm.texi: Document new hooks.\n\t* emit-rtl.c (static_chain_rtx, static_chain_incoming_rtx): Remove.\n\t(init_emit_regs): Don't initialize them.\n\t* expr.h (prepare_call_address): Update decl.\n\t* final.c (profile_function): Use targetm.calls.static_chain.\n\t* function.c (expand_function_start): Likewise.\n\t* rtl.h (static_chain_rtx, static_chain_incoming_rtx): Remove.\n\t* stmt.c (expand_nl_goto_receiver): Use targetm.calls.static_chain;\n\tonly clobber registers.\n\t* targhooks.c (default_static_chain): New.\n\t(default_asm_trampoline_template, default_trampoline_init): New.\n\t(default_trampoline_adjust_address): New.\n\t* targhooks.h: Declare them.\n\t* varasm.c (assemble_trampoline_template): Use\n\ttargetm.asm_out.trampoline_template.  Make the memory block const\n\tand set its size.\n\nFrom-SVN: r151983", "tree": {"sha": "78521a0ca34823fbb38443911cb1b76f4bd93d6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78521a0ca34823fbb38443911cb1b76f4bd93d6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/531ca746f972a758565b0623288ea24162442248", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/531ca746f972a758565b0623288ea24162442248", "html_url": "https://github.com/Rust-GCC/gccrs/commit/531ca746f972a758565b0623288ea24162442248", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/531ca746f972a758565b0623288ea24162442248/comments", "author": null, "committer": null, "parents": [{"sha": "2df373c2eb9148f995614d5405f0e4b500de4e0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2df373c2eb9148f995614d5405f0e4b500de4e0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2df373c2eb9148f995614d5405f0e4b500de4e0d"}], "stats": {"total": 468, "additions": 278, "deletions": 190}, "files": [{"sha": "a918f3941af3716f72a4dbb267b67440ddc6b839", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531ca746f972a758565b0623288ea24162442248/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531ca746f972a758565b0623288ea24162442248/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=531ca746f972a758565b0623288ea24162442248", "patch": "@@ -1,3 +1,40 @@\n+2009-09-22  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/41246\n+\t* target.h (struct gcc_target): Add asm_out.trampoline_template,\n+\tcalls.static_chain, calls.trampoline_init,\n+\tcalls.trampoline_adjust_address.\n+\t* target-def.h (TARGET_ASM_TRAMPOLINE_TEMPLATE): New.\n+\t(TARGET_STATIC_CHAIN, TARGET_TRAMPOLINE_INIT): New.\n+\t(TARGET_TRAMPOLINE_ADJUST_ADDRESS): New.\n+\t* builtins.c (expand_builtin_setjmp_receiver): Use\n+\ttargetm.calls.static_chain; only clobber registers.\n+\t(expand_builtin_init_trampoline): Use targetm.calls.trampoline_init;\n+\tset up memory attributes properly for the trampoline block.\n+\t(expand_builtin_adjust_trampoline): Use\n+\ttargetm.calls.trampoline_adjust_address.\n+\t* calls.c (prepare_call_address): Add fndecl argument.  Use\n+\ttargetm.calls.static_chain.\n+\t* df-scan.c (df_need_static_chain_reg): Remove.\n+\t(df_get_entry_block_def_set): Use targetm.calls.static_chain;\n+\tconsolodate static chain handling.\n+\t* doc/tm.texi: Document new hooks.\n+\t* emit-rtl.c (static_chain_rtx, static_chain_incoming_rtx): Remove.\n+\t(init_emit_regs): Don't initialize them.\n+\t* expr.h (prepare_call_address): Update decl.\n+\t* final.c (profile_function): Use targetm.calls.static_chain.\n+\t* function.c (expand_function_start): Likewise.\n+\t* rtl.h (static_chain_rtx, static_chain_incoming_rtx): Remove.\n+\t* stmt.c (expand_nl_goto_receiver): Use targetm.calls.static_chain;\n+\tonly clobber registers.\n+\t* targhooks.c (default_static_chain): New.\n+\t(default_asm_trampoline_template, default_trampoline_init): New.\n+\t(default_trampoline_adjust_address): New.\n+\t* targhooks.h: Declare them.\n+\t* varasm.c (assemble_trampoline_template): Use\n+\ttargetm.asm_out.trampoline_template.  Make the memory block const\n+\tand set its size.\n+\n 2009-09-22  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/41395"}, {"sha": "7227481b4266068bfbaca6dc2f22fad2f97003d6", "filename": "gcc/builtins.c", "status": "modified", "additions": 37, "deletions": 24, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531ca746f972a758565b0623288ea24162442248/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531ca746f972a758565b0623288ea24162442248/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=531ca746f972a758565b0623288ea24162442248", "patch": "@@ -755,13 +755,17 @@ expand_builtin_setjmp_setup (rtx buf_addr, rtx receiver_label)\n void\n expand_builtin_setjmp_receiver (rtx receiver_label ATTRIBUTE_UNUSED)\n {\n+  rtx chain;\n+\n   /* Clobber the FP when we get here, so we have to make sure it's\n      marked as used by this function.  */\n   emit_use (hard_frame_pointer_rtx);\n \n   /* Mark the static chain as clobbered here so life information\n      doesn't get messed up for it.  */\n-  emit_clobber (static_chain_rtx);\n+  chain = targetm.calls.static_chain (current_function_decl, true);\n+  if (chain && REG_P (chain))\n+    emit_clobber (chain);\n \n   /* Now put in the code to restore the frame pointer, and argument\n      pointer, if needed.  */\n@@ -839,11 +843,8 @@ expand_builtin_longjmp (rtx buf_addr, rtx value)\n \n   buf_addr = force_reg (Pmode, buf_addr);\n \n-  /* We used to store value in static_chain_rtx, but that fails if pointers\n-     are smaller than integers.  We instead require that the user must pass\n-     a second argument of 1, because that is what builtin_setjmp will\n-     return.  This also makes EH slightly more efficient, since we are no\n-     longer copying around a value that we don't care about.  */\n+  /* We require that the user must pass a second argument of 1, because\n+     that is what builtin_setjmp will return.  */\n   gcc_assert (value == const1_rtx);\n \n   last = get_last_insn ();\n@@ -1590,7 +1591,7 @@ expand_builtin_apply (rtx function, rtx arguments, rtx argsize)\n     }\n \n   /* All arguments and registers used for the call are set up by now!  */\n-  function = prepare_call_address (function, NULL, &call_fusage, 0, 0);\n+  function = prepare_call_address (NULL, function, NULL, &call_fusage, 0, 0);\n \n   /* Ensure address is valid.  SYMBOL_REF is already valid, so no need,\n      and we don't want to load it into a register as an optimization,\n@@ -5815,10 +5816,7 @@ static rtx\n expand_builtin_init_trampoline (tree exp)\n {\n   tree t_tramp, t_func, t_chain;\n-  rtx r_tramp, r_func, r_chain;\n-#ifdef TRAMPOLINE_TEMPLATE\n-  rtx blktramp;\n-#endif\n+  rtx m_tramp, r_tramp, r_chain, tmp;\n \n   if (!validate_arglist (exp, POINTER_TYPE, POINTER_TYPE,\n \t\t\t POINTER_TYPE, VOID_TYPE))\n@@ -5829,20 +5827,36 @@ expand_builtin_init_trampoline (tree exp)\n   t_chain = CALL_EXPR_ARG (exp, 2);\n \n   r_tramp = expand_normal (t_tramp);\n-  r_func = expand_normal (t_func);\n+  m_tramp = gen_rtx_MEM (BLKmode, r_tramp);\n+  MEM_NOTRAP_P (m_tramp) = 1;\n+\n+  /* The TRAMP argument should be the address of a field within the\n+     local function's FRAME decl.  Let's see if we can fill in the\n+     to fill in the MEM_ATTRs for this memory.  */\n+  if (TREE_CODE (t_tramp) == ADDR_EXPR)\n+    set_mem_attributes_minus_bitpos (m_tramp, TREE_OPERAND (t_tramp, 0),\n+\t\t\t\t     true, 0);\n+\n+  tmp = round_trampoline_addr (r_tramp);\n+  if (tmp != r_tramp)\n+    {\n+      m_tramp = change_address (m_tramp, BLKmode, tmp);\n+      set_mem_align (m_tramp, TRAMPOLINE_ALIGNMENT);\n+      set_mem_size (m_tramp, GEN_INT (TRAMPOLINE_SIZE));\n+    }\n+\n+  /* The FUNC argument should be the address of the nested function.\n+     Extract the actual function decl to pass to the hook.  */\n+  gcc_assert (TREE_CODE (t_func) == ADDR_EXPR);\n+  t_func = TREE_OPERAND (t_func, 0);\n+  gcc_assert (TREE_CODE (t_func) == FUNCTION_DECL);\n+\n   r_chain = expand_normal (t_chain);\n \n   /* Generate insns to initialize the trampoline.  */\n-  r_tramp = round_trampoline_addr (r_tramp);\n-#ifdef TRAMPOLINE_TEMPLATE\n-  blktramp = gen_rtx_MEM (BLKmode, r_tramp);\n-  set_mem_align (blktramp, TRAMPOLINE_ALIGNMENT);\n-  emit_block_move (blktramp, assemble_trampoline_template (),\n-\t\t   GEN_INT (TRAMPOLINE_SIZE), BLOCK_OP_NORMAL);\n-#endif\n-  trampolines_created = 1;\n-  INITIALIZE_TRAMPOLINE (r_tramp, r_func, r_chain);\n+  targetm.calls.trampoline_init (m_tramp, t_func, r_chain);\n \n+  trampolines_created = 1;\n   return const0_rtx;\n }\n \n@@ -5856,9 +5870,8 @@ expand_builtin_adjust_trampoline (tree exp)\n \n   tramp = expand_normal (CALL_EXPR_ARG (exp, 0));\n   tramp = round_trampoline_addr (tramp);\n-#ifdef TRAMPOLINE_ADJUST_ADDRESS\n-  TRAMPOLINE_ADJUST_ADDRESS (tramp);\n-#endif\n+  if (targetm.calls.trampoline_adjust_address)\n+    tramp = targetm.calls.trampoline_adjust_address (tramp);\n \n   return tramp;\n }"}, {"sha": "f28fb513ce2ad58b0b9a1dc5fb4ddc24f224e0f2", "filename": "gcc/calls.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531ca746f972a758565b0623288ea24162442248/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531ca746f972a758565b0623288ea24162442248/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=531ca746f972a758565b0623288ea24162442248", "patch": "@@ -166,7 +166,7 @@ static void restore_fixed_argument_area (rtx, rtx, int, int);\n    CALL_INSN_FUNCTION_USAGE information.  */\n \n rtx\n-prepare_call_address (rtx funexp, rtx static_chain_value,\n+prepare_call_address (tree fndecl, rtx funexp, rtx static_chain_value,\n \t\t      rtx *call_fusage, int reg_parm_seen, int sibcallp)\n {\n   /* Make a valid memory address and copy constants through pseudo-regs,\n@@ -187,11 +187,15 @@ prepare_call_address (rtx funexp, rtx static_chain_value,\n \n   if (static_chain_value != 0)\n     {\n+      rtx chain;\n+\n+      gcc_assert (fndecl);\n+      chain = targetm.calls.static_chain (fndecl, false);\n       static_chain_value = convert_memory_address (Pmode, static_chain_value);\n-      emit_move_insn (static_chain_rtx, static_chain_value);\n \n-      if (REG_P (static_chain_rtx))\n-\tuse_reg (call_fusage, static_chain_rtx);\n+      emit_move_insn (chain, static_chain_value);\n+      if (REG_P (chain))\n+\tuse_reg (call_fusage, chain);\n     }\n \n   return funexp;\n@@ -2807,7 +2811,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t}\n \n       after_args = get_last_insn ();\n-      funexp = prepare_call_address (funexp, static_chain_value,\n+      funexp = prepare_call_address (fndecl, funexp, static_chain_value,\n \t\t\t\t     &call_fusage, reg_parm_seen, pass == 0);\n \n       load_register_parameters (args, num_actuals, &call_fusage, flags,\n@@ -3735,7 +3739,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n   else\n     argnum = 0;\n \n-  fun = prepare_call_address (fun, NULL, &call_fusage, 0, 0);\n+  fun = prepare_call_address (NULL, fun, NULL, &call_fusage, 0, 0);\n \n   /* Now load any reg parms into their regs.  */\n "}, {"sha": "33af848ee03e5375c5f6f1e097c6ed99eadf7aaa", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531ca746f972a758565b0623288ea24162442248/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531ca746f972a758565b0623288ea24162442248/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=531ca746f972a758565b0623288ea24162442248", "patch": "@@ -982,7 +982,7 @@ void add_framework_path (char *);\n #endif\n \n /* Attempt to turn on execute permission for the stack.  This may be\n-    used by INITIALIZE_TRAMPOLINE of the target needs it (that is,\n+    used by TARGET_TRAMPOLINE_INIT if the target needs it (that is,\n     if the target machine can change execute permissions on a page).\n \n     There is no way to query the execute permission of the stack, so"}, {"sha": "4f82809c8c18bc0f0955ec7041a558cc6568b2b0", "filename": "gcc/config/netbsd.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531ca746f972a758565b0623288ea24162442248/gcc%2Fconfig%2Fnetbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531ca746f972a758565b0623288ea24162442248/gcc%2Fconfig%2Fnetbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnetbsd.h?ref=531ca746f972a758565b0623288ea24162442248", "patch": "@@ -180,7 +180,7 @@ along with GCC; see the file COPYING3.  If not see\n \f\n \n /* Attempt to turn on execute permission for the stack.  This may be\n-   used by INITIALIZE_TRAMPOLINE of the target needs it (that is,\n+   used by TARGET_TRAMPOLINE_INIT if the target needs it (that is,\n    if the target machine can change execute permissions on a page).\n \n    There is no way to query the execute permission of the stack, so"}, {"sha": "45df29ecc2b075005b89b49bfeac32ff0a3debb4", "filename": "gcc/df-scan.c", "status": "modified", "additions": 6, "deletions": 38, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531ca746f972a758565b0623288ea24162442248/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531ca746f972a758565b0623288ea24162442248/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=531ca746f972a758565b0623288ea24162442248", "patch": "@@ -3601,18 +3601,6 @@ df_recompute_luids (basic_block bb)\n }\n \n \n-/* Returns true if the function entry needs to \n-   define the static chain register.  */\n-\n-static bool\n-df_need_static_chain_reg (struct function *fun)\n-{\n-  tree fun_context = decl_function_context (fun->decl);\n-  return fun_context\n-         && DECL_NO_STATIC_CHAIN (fun_context) == false;\n-}\n-\n-\n /* Collect all artificial refs at the block level for BB and add them\n    to COLLECTION_REC.  */\n \n@@ -3891,24 +3879,17 @@ df_get_entry_block_def_set (bitmap entry_block_defs)\n \tif ((call_used_regs[i] == 0) && (df_regs_ever_live_p (i)))\n \t  bitmap_set_bit (entry_block_defs, i);\n     }\n-  else\n-    {\n-      /* If STATIC_CHAIN_INCOMING_REGNUM == STATIC_CHAIN_REGNUM\n-\t only STATIC_CHAIN_REGNUM is defined.  If they are different,\n-\t we only care about the STATIC_CHAIN_INCOMING_REGNUM.  */\n-#ifdef STATIC_CHAIN_INCOMING_REGNUM\n-      bitmap_set_bit (entry_block_defs, STATIC_CHAIN_INCOMING_REGNUM);\n-#else \n-#ifdef STATIC_CHAIN_REGNUM\n-      bitmap_set_bit (entry_block_defs, STATIC_CHAIN_REGNUM);\n-#endif\n-#endif\n-    }\n \n   r = targetm.calls.struct_value_rtx (current_function_decl, true);\n   if (r && REG_P (r))\n     bitmap_set_bit (entry_block_defs, REGNO (r));\n \n+  /* If the function has an incoming STATIC_CHAIN, it has to show up\n+     in the entry def set.  */\n+  r = targetm.calls.static_chain (current_function_decl, true);\n+  if (r && REG_P (r))\n+    bitmap_set_bit (entry_block_defs, REGNO (r));\n+\n   if ((!reload_completed) || frame_pointer_needed)\n     {\n       /* Any reference to any pseudo before reload is a potential\n@@ -3946,19 +3927,6 @@ df_get_entry_block_def_set (bitmap entry_block_defs)\n #endif\n             \n   targetm.live_on_entry (entry_block_defs);\n-\n-  /* If the function has an incoming STATIC_CHAIN,\n-     it has to show up in the entry def set.  */\n-  if (df_need_static_chain_reg (cfun))\n-    {\n-#ifdef STATIC_CHAIN_INCOMING_REGNUM\n-      bitmap_set_bit (entry_block_defs, STATIC_CHAIN_INCOMING_REGNUM);\n-#else \n-#ifdef STATIC_CHAIN_REGNUM\n-      bitmap_set_bit (entry_block_defs, STATIC_CHAIN_REGNUM);\n-#endif\n-#endif\n-    }\n }\n \n "}, {"sha": "8a51a9f93c4659769f6a74cb374d7aef9127ddd4", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 44, "deletions": 39, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531ca746f972a758565b0623288ea24162442248/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531ca746f972a758565b0623288ea24162442248/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=531ca746f972a758565b0623288ea24162442248", "patch": "@@ -3684,6 +3684,16 @@ If the static chain is passed in a register, the two previous macros should\n be defined instead.\n @end defmac\n \n+@deftypefn {Target Hook} rtx TARGET_STATIC_CHAIN (const_tree @var{fndecl}, bool @var{incoming_p})\n+This hook replaces the use of @code{STATIC_CHAIN_REGNUM} et al for\n+targets that may use different static chain locations for different\n+nested functions.  This may be required if the target has function\n+attributes that affect the calling conventions of the function and\n+those calling conventions use different static chain locations.\n+\n+The default version of this hook uses @code{STATIC_CHAIN_REGNUM} et al.\n+@end deftypefn\n+\n @defmac DWARF_FRAME_REGISTERS\n This macro specifies the maximum number of hard registers that can be\n saved in a call frame.  This is used to size data structures used in\n@@ -5099,17 +5109,17 @@ proper offset from the start of the trampoline.  On a RISC machine, it\n may be necessary to take out pieces of the address and store them\n separately.\n \n-@defmac TRAMPOLINE_TEMPLATE (@var{file})\n-A C statement to output, on the stream @var{file}, assembler code for a\n-block of data that contains the constant parts of a trampoline.  This\n-code should not include a label---the label is taken care of\n-automatically.\n+@deftypefn {Target Hook} void TARGET_ASM_TRAMPOLINE_TEMPLATE (FILE *@var{f})\n+This hook is called by @code{assemble_trampoline_template} to output,\n+on the stream @var{f}, assembler code for a block of data that contains\n+the constant parts of a trampoline.  This code should not include a\n+label---the label is taken care of automatically.\n \n-If you do not define this macro, it means no template is needed\n-for the target.  Do not define this macro on systems where the block move\n+If you do not define this hook, it means no template is needed\n+for the target.  Do not define this hook on systems where the block move\n code to copy the trampoline into place would be larger than the code\n to generate it on the spot.\n-@end defmac\n+@end deftypefn\n \n @defmac TRAMPOLINE_SECTION\n Return the section into which the trampoline template is to be placed\n@@ -5123,43 +5133,38 @@ A C expression for the size in bytes of the trampoline, as an integer.\n @defmac TRAMPOLINE_ALIGNMENT\n Alignment required for trampolines, in bits.\n \n-If you don't define this macro, the value of @code{BIGGEST_ALIGNMENT}\n+If you don't define this macro, the value of @code{FUNCTION_ALIGNMENT}\n is used for aligning trampolines.\n @end defmac\n \n-@defmac INITIALIZE_TRAMPOLINE (@var{addr}, @var{fnaddr}, @var{static_chain})\n-A C statement to initialize the variable parts of a trampoline.\n-@var{addr} is an RTX for the address of the trampoline; @var{fnaddr} is\n-an RTX for the address of the nested function; @var{static_chain} is an\n+@deftypefn {Target Hook} void TARGET_TRAMPOLINE_INIT (rtx @var{m_tramp}, tree @var{fndecl}, rtx @var{static_chain})\n+This hook is called to initialize a trampoline.\n+@var{m_tramp} is an RTX for the memory block for the trampoline; @var{fndecl}\n+is the @code{FUNCTION_DECL} for the nested function; @var{static_chain} is an\n RTX for the static chain value that should be passed to the function\n when it is called.\n-@end defmac\n \n-@defmac TRAMPOLINE_ADJUST_ADDRESS (@var{addr})\n-A C statement that should perform any machine-specific adjustment in\n-the address of the trampoline.  Its argument contains the address that\n-was passed to @code{INITIALIZE_TRAMPOLINE}.  In case the address to be\n-used for a function call should be different from the address in which\n-the template was stored, the different address should be assigned to\n-@var{addr}.  If this macro is not defined, @var{addr} will be used for\n-function calls.\n+If the target defines @code{TARGET_ASM_TRAMPOLINE_TEMPLATE}, then the\n+first thing this hook should do is emit a block move into @var{m_tramp}\n+from the memory block returned by @code{assemble_trampoline_template}.\n+Note that the block move need only cover the constant parts of the \n+trampoline.  If the target isolates the variable parts of the trampoline\n+to the end, not all @code{TRAMPOLINE_SIZE} bytes need be copied.\n \n-@cindex @code{TARGET_ASM_FUNCTION_EPILOGUE} and trampolines\n-@cindex @code{TARGET_ASM_FUNCTION_PROLOGUE} and trampolines\n-If this macro is not defined, by default the trampoline is allocated as\n-a stack slot.  This default is right for most machines.  The exceptions\n-are machines where it is impossible to execute instructions in the stack\n-area.  On such machines, you may have to implement a separate stack,\n-using this macro in conjunction with @code{TARGET_ASM_FUNCTION_PROLOGUE}\n-and @code{TARGET_ASM_FUNCTION_EPILOGUE}.\n-\n-@var{fp} points to a data structure, a @code{struct function}, which\n-describes the compilation status of the immediate containing function of\n-the function which the trampoline is for.  The stack slot for the\n-trampoline is in the stack frame of this containing function.  Other\n-allocation strategies probably must do something analogous with this\n-information.\n-@end defmac\n+If the target requires any other actions, such as flushing caches or\n+enabling stack execution, these actions should be performed after \n+initializing the trampoline proper.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} rtx TARGET_TRAMPOLINE_ADJUST_ADDRESS (rtx @var{addr})\n+This hook should perform any machine-specific adjustment in\n+the address of the trampoline.  Its argument contains the address of the\n+memory block that was passed to @code{TARGET_TRAMPOLINE_INIT}.  In case\n+the address to be used for a function call should be different from the\n+address at which the template was stored, the different address should\n+be returned; otherwise @var{addr} should be returned unchanged.\n+If this hook is not defined, @var{addr} will be used for function calls.\n+@end deftypefn\n \n Implementing trampolines is difficult on many machines because they have\n separate instruction and data caches.  Writing into a stack location\n@@ -5192,7 +5197,7 @@ code located on the stack.  The macro should expand to a series of C\n file-scope constructs (e.g.@: functions) and provide a unique entry point\n named @code{__enable_execute_stack}.  The target is responsible for\n emitting calls to the entry point in the code, for example from the\n-@code{INITIALIZE_TRAMPOLINE} macro.\n+@code{TARGET_TRAMPOLINE_INIT} hook.\n @end defmac\n \n To use a standard subroutine, define the following macro.  In addition,"}, {"sha": "b3672e3e5adf166fda5d77a28cf698728b5d95ba", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531ca746f972a758565b0623288ea24162442248/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531ca746f972a758565b0623288ea24162442248/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=531ca746f972a758565b0623288ea24162442248", "patch": "@@ -136,8 +136,6 @@ FIXED_VALUE_TYPE fconst1[MAX_FCONST1];\n \n    In an inline procedure, the stack and frame pointer rtxs may not be\n    used for anything else.  */\n-rtx static_chain_rtx;\t\t/* (REG:Pmode STATIC_CHAIN_REGNUM) */\n-rtx static_chain_incoming_rtx;\t/* (REG:Pmode STATIC_CHAIN_INCOMING_REGNUM) */\n rtx pic_offset_table_rtx;\t/* (REG:Pmode PIC_OFFSET_TABLE_REGNUM) */\n \n /* This is used to implement __builtin_return_address for some machines.\n@@ -5671,28 +5669,6 @@ init_emit_regs (void)\n     = gen_raw_REG (Pmode, RETURN_ADDRESS_POINTER_REGNUM);\n #endif\n \n-#ifdef STATIC_CHAIN_REGNUM\n-  static_chain_rtx = gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);\n-\n-#ifdef STATIC_CHAIN_INCOMING_REGNUM\n-  if (STATIC_CHAIN_INCOMING_REGNUM != STATIC_CHAIN_REGNUM)\n-    static_chain_incoming_rtx\n-      = gen_rtx_REG (Pmode, STATIC_CHAIN_INCOMING_REGNUM);\n-  else\n-#endif\n-    static_chain_incoming_rtx = static_chain_rtx;\n-#endif\n-\n-#ifdef STATIC_CHAIN\n-  static_chain_rtx = STATIC_CHAIN;\n-\n-#ifdef STATIC_CHAIN_INCOMING\n-  static_chain_incoming_rtx = STATIC_CHAIN_INCOMING;\n-#else\n-  static_chain_incoming_rtx = static_chain_rtx;\n-#endif\n-#endif\n-\n   if ((unsigned) PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM)\n     pic_offset_table_rtx = gen_raw_REG (Pmode, PIC_OFFSET_TABLE_REGNUM);\n   else"}, {"sha": "4e02c24b75f231aa41b7c11c8c0e036a46f5681f", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531ca746f972a758565b0623288ea24162442248/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531ca746f972a758565b0623288ea24162442248/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=531ca746f972a758565b0623288ea24162442248", "patch": "@@ -618,7 +618,7 @@ extern HOST_WIDE_INT int_expr_size (tree);\n    in its original home.  This becomes invalid if any more code is emitted.  */\n extern rtx hard_function_value (const_tree, const_tree, const_tree, int);\n \n-extern rtx prepare_call_address (rtx, rtx, rtx *, int, int);\n+extern rtx prepare_call_address (tree, rtx, rtx, rtx *, int, int);\n \n extern bool shift_return_value (enum machine_mode, bool, rtx);\n "}, {"sha": "78a698b448460fc2457dbc1c9b4efefb1f200a0a", "filename": "gcc/final.c", "status": "modified", "additions": 18, "deletions": 40, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531ca746f972a758565b0623288ea24162442248/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531ca746f972a758565b0623288ea24162442248/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=531ca746f972a758565b0623288ea24162442248", "patch": "@@ -1594,12 +1594,14 @@ profile_function (FILE *file ATTRIBUTE_UNUSED)\n #ifndef NO_PROFILE_COUNTERS\n # define NO_PROFILE_COUNTERS\t0\n #endif\n-#if defined(ASM_OUTPUT_REG_PUSH)\n-  int sval = cfun->returns_struct;\n-  rtx svrtx = targetm.calls.struct_value_rtx (TREE_TYPE (current_function_decl), 1);\n-#if defined(STATIC_CHAIN_INCOMING_REGNUM) || defined(STATIC_CHAIN_REGNUM)\n-  int cxt = cfun->static_chain_decl != NULL;\n-#endif\n+#ifdef ASM_OUTPUT_REG_PUSH\n+  rtx sval = NULL, chain = NULL;\n+\n+  if (cfun->returns_struct)\n+    sval = targetm.calls.struct_value_rtx (TREE_TYPE (current_function_decl),\n+\t\t\t\t\t   true);\n+  if (cfun->static_chain_decl)\n+    chain = targetm.calls.static_chain (current_function_decl, true);\n #endif /* ASM_OUTPUT_REG_PUSH */\n \n   if (! NO_PROFILE_COUNTERS)\n@@ -1613,44 +1615,20 @@ profile_function (FILE *file ATTRIBUTE_UNUSED)\n \n   switch_to_section (current_function_section ());\n \n-#if defined(ASM_OUTPUT_REG_PUSH)\n-  if (sval && svrtx != NULL_RTX && REG_P (svrtx))\n-    {\n-      ASM_OUTPUT_REG_PUSH (file, REGNO (svrtx));\n-    }\n-#endif\n-\n-#if defined(STATIC_CHAIN_INCOMING_REGNUM) && defined(ASM_OUTPUT_REG_PUSH)\n-  if (cxt)\n-    ASM_OUTPUT_REG_PUSH (file, STATIC_CHAIN_INCOMING_REGNUM);\n-#else\n-#if defined(STATIC_CHAIN_REGNUM) && defined(ASM_OUTPUT_REG_PUSH)\n-  if (cxt)\n-    {\n-      ASM_OUTPUT_REG_PUSH (file, STATIC_CHAIN_REGNUM);\n-    }\n-#endif\n+#ifdef ASM_OUTPUT_REG_PUSH\n+  if (sval && REG_P (sval))\n+    ASM_OUTPUT_REG_PUSH (file, REGNO (sval));\n+  if (chain && REG_P (chain))\n+    ASM_OUTPUT_REG_PUSH (file, REGNO (chain));\n #endif\n \n   FUNCTION_PROFILER (file, current_function_funcdef_no);\n \n-#if defined(STATIC_CHAIN_INCOMING_REGNUM) && defined(ASM_OUTPUT_REG_PUSH)\n-  if (cxt)\n-    ASM_OUTPUT_REG_POP (file, STATIC_CHAIN_INCOMING_REGNUM);\n-#else\n-#if defined(STATIC_CHAIN_REGNUM) && defined(ASM_OUTPUT_REG_PUSH)\n-  if (cxt)\n-    {\n-      ASM_OUTPUT_REG_POP (file, STATIC_CHAIN_REGNUM);\n-    }\n-#endif\n-#endif\n-\n-#if defined(ASM_OUTPUT_REG_PUSH)\n-  if (sval && svrtx != NULL_RTX && REG_P (svrtx))\n-    {\n-      ASM_OUTPUT_REG_POP (file, REGNO (svrtx));\n-    }\n+#ifdef ASM_OUTPUT_REG_PUSH\n+  if (chain && REG_P (chain))\n+    ASM_OUTPUT_REG_POP (file, REGNO (chain));\n+  if (sval && REG_P (sval))\n+    ASM_OUTPUT_REG_POP (file, REGNO (sval));\n #endif\n }\n "}, {"sha": "6c9bea842e9783f45e789f0e3696194b41161af4", "filename": "gcc/function.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531ca746f972a758565b0623288ea24162442248/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531ca746f972a758565b0623288ea24162442248/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=531ca746f972a758565b0623288ea24162442248", "patch": "@@ -4453,13 +4453,21 @@ expand_function_start (tree subr)\n   if (cfun->static_chain_decl)\n     {\n       tree parm = cfun->static_chain_decl;\n-      rtx local = gen_reg_rtx (Pmode);\n+      rtx local, chain, insn;\n \n-      set_decl_incoming_rtl (parm, static_chain_incoming_rtx, false);\n+      local = gen_reg_rtx (Pmode);\n+      chain = targetm.calls.static_chain (current_function_decl, true);\n+\n+      set_decl_incoming_rtl (parm, chain, false);\n       SET_DECL_RTL (parm, local);\n       mark_reg_pointer (local, TYPE_ALIGN (TREE_TYPE (TREE_TYPE (parm))));\n \n-      emit_move_insn (local, static_chain_incoming_rtx);\n+      insn = emit_move_insn (local, chain);\n+\n+      /* Mark the register as eliminable, similar to parameters.  */\n+      if (MEM_P (chain)\n+\t  && reg_mentioned_p (arg_pointer_rtx, XEXP (chain, 0)))\n+\tset_unique_reg_note (insn, REG_EQUIV, chain);\n     }\n \n   /* If the function receives a non-local goto, then store the"}, {"sha": "d415ba483f3cc22fdb2e19adb2a3c92f2dec8e2f", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531ca746f972a758565b0623288ea24162442248/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531ca746f972a758565b0623288ea24162442248/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=531ca746f972a758565b0623288ea24162442248", "patch": "@@ -2024,8 +2024,6 @@ extern GTY(()) rtx global_rtl[GR_MAX];\n #define arg_pointer_rtx\t\t(global_rtl[GR_ARG_POINTER])\n \n extern GTY(()) rtx pic_offset_table_rtx;\n-extern GTY(()) rtx static_chain_rtx;\n-extern GTY(()) rtx static_chain_incoming_rtx;\n extern GTY(()) rtx return_address_pointer_rtx;\n \n /* Include the RTL generation functions.  */"}, {"sha": "d2583ca5458c50ef68541268bbacfa23b84589d3", "filename": "gcc/stmt.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531ca746f972a758565b0623288ea24162442248/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531ca746f972a758565b0623288ea24162442248/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=531ca746f972a758565b0623288ea24162442248", "patch": "@@ -1799,13 +1799,17 @@ expand_return (tree retval)\n static void\n expand_nl_goto_receiver (void)\n {\n+  rtx chain;\n+\n   /* Clobber the FP when we get here, so we have to make sure it's\n      marked as used by this function.  */\n   emit_use (hard_frame_pointer_rtx);\n \n   /* Mark the static chain as clobbered here so life information\n      doesn't get messed up for it.  */\n-  emit_clobber (static_chain_rtx);\n+  chain = targetm.calls.static_chain (current_function_decl, true);\n+  if (chain && REG_P (chain))\n+    emit_clobber (chain);\n \n #ifdef HAVE_nonlocal_goto\n   if (! HAVE_nonlocal_goto)"}, {"sha": "2ccdc667f629e3fbf08054e022a64ae7773f9e98", "filename": "gcc/target-def.h", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531ca746f972a758565b0623288ea24162442248/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531ca746f972a758565b0623288ea24162442248/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=531ca746f972a758565b0623288ea24162442248", "patch": "@@ -247,6 +247,12 @@\n #define TARGET_ASM_RECORD_GCC_SWITCHES_SECTION \".GCC.command.line\"\n #endif\n \n+#ifdef TRAMPOLINE_TEMPLATE\n+# define TARGET_ASM_TRAMPOLINE_TEMPLATE default_asm_trampoline_template\n+#else\n+# define TARGET_ASM_TRAMPOLINE_TEMPLATE NULL\n+#endif\n+\n #define TARGET_ASM_ALIGNED_INT_OP\t\t\t\t\\\n \t\t       {TARGET_ASM_ALIGNED_HI_OP,\t\t\\\n \t\t\tTARGET_ASM_ALIGNED_SI_OP,\t\t\\\n@@ -296,7 +302,8 @@\n \t\t\tTARGET_ASM_RECORD_GCC_SWITCHES_SECTION,\t\\\n \t\t\tTARGET_ASM_OUTPUT_ANCHOR,\t\t\\\n \t\t\tTARGET_ASM_OUTPUT_DWARF_DTPREL,\t\t\\\n-\t\t\tTARGET_ASM_FINAL_POSTSCAN_INSN}\n+\t\t\tTARGET_ASM_FINAL_POSTSCAN_INSN,\t\t\\\n+\t\t\tTARGET_ASM_TRAMPOLINE_TEMPLATE }\n \n /* Scheduler hooks.  All of these default to null pointers, which\n    haifa-sched.c looks for and handles.  */\n@@ -607,6 +614,14 @@\n #define TARGET_UPDATE_STACK_BOUNDARY NULL\n #define TARGET_GET_DRAP_RTX NULL\n #define TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS hook_bool_void_true\n+#define TARGET_STATIC_CHAIN default_static_chain\n+#define TARGET_TRAMPOLINE_INIT default_trampoline_init\n+\n+#ifdef TRAMPOLINE_ADJUST_ADDRESS\n+# define TARGET_TRAMPOLINE_ADJUST_ADDRESS default_trampoline_adjust_address\n+#else\n+# define TARGET_TRAMPOLINE_ADJUST_ADDRESS NULL\n+#endif\n \n #define TARGET_CALLS {\t\t\t\t\t\t\\\n    TARGET_PROMOTE_FUNCTION_MODE,\t\t\t\t\\\n@@ -629,7 +644,10 @@\n    TARGET_INTERNAL_ARG_POINTER,\t\t\t\t\t\\\n    TARGET_UPDATE_STACK_BOUNDARY,\t\t\t\t\\\n    TARGET_GET_DRAP_RTX,\t\t\t\t\t\t\\\n-   TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS\t\t\t\t\\\n+   TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS,\t\t\t\\\n+   TARGET_STATIC_CHAIN,\t\t\t\t\t\t\\\n+   TARGET_TRAMPOLINE_INIT,\t\t\t\t\t\\\n+   TARGET_TRAMPOLINE_ADJUST_ADDRESS\t\t\t\t\\\n    }\n \n #ifndef TARGET_UNWIND_TABLES_DEFAULT"}, {"sha": "f964b6975f82ac3fbdd79840408d0769e3dae8d0", "filename": "gcc/target.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531ca746f972a758565b0623288ea24162442248/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531ca746f972a758565b0623288ea24162442248/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=531ca746f972a758565b0623288ea24162442248", "patch": "@@ -253,6 +253,9 @@ struct gcc_target\n \n     /* Some target machines need to postscan each insn after it is output.  */\n     void (*final_postscan_insn) (FILE *, rtx, rtx *, int);\n+\n+    /* Emit the trampoline template.  This hook may be NULL.  */\n+    void (*trampoline_template) (FILE *);\n   } asm_out;\n \n   /* Functions relating to instruction scheduling.  */\n@@ -915,7 +918,17 @@ struct gcc_target\n     /* Return true if all function parameters should be spilled to the\n        stack.  */\n     bool (*allocate_stack_slots_for_args) (void);\n-    \n+\n+    /* Return an rtx for the static chain for FNDECL.  If INCOMING_P is true,\n+       then it should be for the callee; otherwise for the caller.  */\n+    rtx (*static_chain) (const_tree fndecl, bool incoming_p);\n+\n+    /* Fill in the trampoline at MEM with a call to FNDECL and a \n+       static chain value of CHAIN.  */\n+    void (*trampoline_init) (rtx mem, tree fndecl, rtx chain);\n+\n+    /* Adjust the address of the trampoline in a target-specific way.  */\n+    rtx (*trampoline_adjust_address) (rtx addr);\n   } calls;\n \n   /* Return the diagnostic message string if conversion from FROMTYPE"}, {"sha": "48401fb4544ecc67810ce6e286d0d5de0b5001d5", "filename": "gcc/targhooks.c", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531ca746f972a758565b0623288ea24162442248/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531ca746f972a758565b0623288ea24162442248/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=531ca746f972a758565b0623288ea24162442248", "patch": "@@ -628,6 +628,69 @@ default_internal_arg_pointer (void)\n     return virtual_incoming_args_rtx;\n }\n \n+rtx\n+default_static_chain (const_tree fndecl, bool incoming_p)\n+{\n+  if (DECL_NO_STATIC_CHAIN (fndecl))\n+    return NULL;\n+\n+  if (incoming_p)\n+    {\n+#ifdef STATIC_CHAIN_INCOMING\n+      return STATIC_CHAIN_INCOMING;\n+#endif\n+#ifdef STATIC_CHAIN_INCOMING_REGNUM\n+      return gen_rtx_REG (Pmode, STATIC_CHAIN_INCOMING_REGNUM);\n+#endif\n+    }\n+\n+#ifdef STATIC_CHAIN\n+  return STATIC_CHAIN;\n+#endif\n+#ifdef STATIC_CHAIN_REGNUM\n+  return gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);\n+#endif\n+\n+  gcc_unreachable ();\n+}\n+\n+#ifdef TRAMPOLINE_TEMPLATE\n+void\n+default_asm_trampoline_template (FILE *f)\n+{\n+  TRAMPOLINE_TEMPLATE (f);\n+}\n+#endif\n+\n+void\n+default_trampoline_init (rtx ARG_UNUSED (m_tramp), tree ARG_UNUSED (t_func),\n+\t\t\t rtx ARG_UNUSED (r_chain))\n+{\n+#ifdef INITIALIZE_TRAMPOLINE\n+  rtx r_tramp, r_func;\n+\n+  if (targetm.asm_out.trampoline_template)\n+    emit_block_move (m_tramp, assemble_trampoline_template (),\n+\t\t     GEN_INT (TRAMPOLINE_SIZE), BLOCK_OP_NORMAL);\n+\n+  r_func = XEXP (DECL_RTL (t_func), 0);\n+  r_tramp = XEXP (m_tramp, 0);\n+\n+  INITIALIZE_TRAMPOLINE (r_tramp, r_func, r_chain);\n+#else\n+  sorry (\"nested function trampolines not supported on this target\");\n+#endif\n+}\n+\n+rtx\n+default_trampoline_adjust_address (rtx addr)\n+{\n+#ifdef TRAMPOLINE_ADJUST_ADDRESS\n+  TRAMPOLINE_ADJUST_ADDRESS (addr);\n+#endif\n+  return addr;\n+}\n+\n enum reg_class\n default_branch_target_register_class (void)\n {"}, {"sha": "1a0dc56b67465f14c225485b06bb05c9e2559e48", "filename": "gcc/targhooks.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531ca746f972a758565b0623288ea24162442248/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531ca746f972a758565b0623288ea24162442248/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=531ca746f972a758565b0623288ea24162442248", "patch": "@@ -100,6 +100,10 @@ extern bool hook_bool_const_rtx_commutative_p (const_rtx, int);\n extern rtx default_function_value (const_tree, const_tree, bool);\n extern rtx default_libcall_value (enum machine_mode, rtx);\n extern rtx default_internal_arg_pointer (void);\n+extern rtx default_static_chain (const_tree, bool);\n+extern void default_asm_trampoline_template (FILE *);\n+extern void default_trampoline_init (rtx, tree, rtx);\n+extern rtx default_trampoline_adjust_address (rtx);\n extern enum reg_class default_branch_target_register_class (void);\n #ifdef IRA_COVER_CLASSES\n extern const enum reg_class *default_ira_cover_classes (void);"}, {"sha": "f4532b8bb6c0a6fc5da09dea94b8ee65ab5dfc99", "filename": "gcc/varasm.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531ca746f972a758565b0623288ea24162442248/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531ca746f972a758565b0623288ea24162442248/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=531ca746f972a758565b0623288ea24162442248", "patch": "@@ -2507,7 +2507,6 @@ assemble_static_space (unsigned HOST_WIDE_INT size)\n \n static GTY(()) rtx initial_trampoline;\n \n-#ifdef TRAMPOLINE_TEMPLATE\n rtx\n assemble_trampoline_template (void)\n {\n@@ -2516,6 +2515,8 @@ assemble_trampoline_template (void)\n   int align;\n   rtx symbol;\n \n+  gcc_assert (targetm.asm_out.trampoline_template != NULL);\n+\n   if (initial_trampoline)\n     return initial_trampoline;\n \n@@ -2530,25 +2531,23 @@ assemble_trampoline_template (void)\n   /* Write the assembler code to define one.  */\n   align = floor_log2 (TRAMPOLINE_ALIGNMENT / BITS_PER_UNIT);\n   if (align > 0)\n-    {\n-      ASM_OUTPUT_ALIGN (asm_out_file, align);\n-    }\n+    ASM_OUTPUT_ALIGN (asm_out_file, align);\n \n   targetm.asm_out.internal_label (asm_out_file, \"LTRAMP\", 0);\n-  TRAMPOLINE_TEMPLATE (asm_out_file);\n+  targetm.asm_out.trampoline_template (asm_out_file);\n \n   /* Record the rtl to refer to it.  */\n   ASM_GENERATE_INTERNAL_LABEL (label, \"LTRAMP\", 0);\n   name = ggc_strdup (label);\n   symbol = gen_rtx_SYMBOL_REF (Pmode, name);\n   SYMBOL_REF_FLAGS (symbol) = SYMBOL_FLAG_LOCAL;\n \n-  initial_trampoline = gen_rtx_MEM (BLKmode, symbol);\n+  initial_trampoline = gen_const_mem (BLKmode, symbol);\n   set_mem_align (initial_trampoline, TRAMPOLINE_ALIGNMENT);\n+  set_mem_size (initial_trampoline, GEN_INT (TRAMPOLINE_SIZE));\n \n   return initial_trampoline;\n }\n-#endif\n \f\n /* A and B are either alignments or offsets.  Return the minimum alignment\n    that may be assumed after adding the two together.  */"}]}