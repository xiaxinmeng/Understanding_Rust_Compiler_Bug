{"sha": "1e2c124d71ac051373a30495793883c45bcc5415", "node_id": "C_kwDOANBUbNoAKDFlMmMxMjRkNzFhYzA1MTM3M2EzMDQ5NTc5Mzg4M2M0NWJjYzU0MTU", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-09-30T15:06:54Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-09-30T15:06:54Z"}, "message": "c++: streamline built-in trait addition process\n\nAdding a new built-in trait currently involves manual boilerplate\nconsisting of defining an rid enumerator for the identifier as well as a\ncorresponding cp_trait_kind enumerator and handling them in various switch\nstatements, the exact set of which depends on whether the proposed trait\nyields (and thus is recognized as) a type or an expression.\n\nTo streamline the process, this patch adds a central cp-trait.def file\nthat tabulates the essential details about each built-in trait (whether\nit yields a type or an expression, its code, its spelling and its arity)\nand uses this file to automate away the manual boilerplate.  It also\nmigrates all the existing C++-specific built-in traits to use this\napproach.\n\nAfter this change, adding a new built-in trait just entails declaring\nit in cp-trait.def and defining its behavior in finish_trait_expr/type\n(and handling it in diagnose_trait_expr, if it's an expression-yielding\ntrait).\n\ngcc/c-family/ChangeLog:\n\n\t* c-common.cc (c_common_reswords): Use cp/cp-trait.def to handle\n\tC++ traits.\n\t* c-common.h (enum rid): Likewise.\n\ngcc/cp/ChangeLog:\n\n\t* constraint.cc (diagnose_trait_expr): Likewise.\n\t* cp-objcp-common.cc (names_builtin_p): Likewise.\n\t* cp-tree.h (enum cp_trait_kind): Likewise.\n\t* cxx-pretty-print.cc (pp_cxx_trait): Likewise.\n\t* parser.cc (cp_keyword_starts_decl_specifier_p): Likewise.\n\t(cp_parser_primary_expression): Likewise.\n\t(cp_parser_trait): Likewise.\n\t(cp_parser_simple_type_specifier): Likewise.\n\t* cp-trait.def: New file.", "tree": {"sha": "281e8aa9254d44be03e336282fc885c29eab597c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/281e8aa9254d44be03e336282fc885c29eab597c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e2c124d71ac051373a30495793883c45bcc5415", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e2c124d71ac051373a30495793883c45bcc5415", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e2c124d71ac051373a30495793883c45bcc5415", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e2c124d71ac051373a30495793883c45bcc5415/comments", "author": null, "committer": null, "parents": [{"sha": "3bb2d70d38027c43b437dee98ee1a7a15843682f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bb2d70d38027c43b437dee98ee1a7a15843682f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bb2d70d38027c43b437dee98ee1a7a15843682f"}], "stats": {"total": 638, "additions": 161, "deletions": 477}, "files": [{"sha": "3c60a89bfe2c8c042c4aff448a09761533f55a41", "filename": "gcc/c-family/c-common.cc", "status": "modified", "additions": 7, "deletions": 47, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e2c124d71ac051373a30495793883c45bcc5415/gcc%2Fc-family%2Fc-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e2c124d71ac051373a30495793883c45bcc5415/gcc%2Fc-family%2Fc-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.cc?ref=1e2c124d71ac051373a30495793883c45bcc5415", "patch": "@@ -378,7 +378,6 @@ const struct c_common_resword c_common_reswords[] =\n   { \"__attribute\",\tRID_ATTRIBUTE,\t0 },\n   { \"__attribute__\",\tRID_ATTRIBUTE,\t0 },\n   { \"__auto_type\",\tRID_AUTO_TYPE,\tD_CONLY },\n-  { \"__bases\",          RID_BASES, D_CXXONLY },\n   { \"__builtin_addressof\", RID_ADDRESSOF, D_CXXONLY },\n   { \"__builtin_bit_cast\", RID_BUILTIN_BIT_CAST, D_CXXONLY },\n   { \"__builtin_call_with_static_chain\",\n@@ -401,44 +400,12 @@ const struct c_common_resword c_common_reswords[] =\n   { \"__const__\",\tRID_CONST,\t0 },\n   { \"__constinit\",\tRID_CONSTINIT,\tD_CXXONLY },\n   { \"__decltype\",       RID_DECLTYPE,   D_CXXONLY },\n-  { \"__direct_bases\",   RID_DIRECT_BASES, D_CXXONLY },\n   { \"__extension__\",\tRID_EXTENSION,\t0 },\n   { \"__func__\",\t\tRID_C99_FUNCTION_NAME, 0 },\n-  { \"__has_nothrow_assign\", RID_HAS_NOTHROW_ASSIGN, D_CXXONLY },\n-  { \"__has_nothrow_constructor\", RID_HAS_NOTHROW_CONSTRUCTOR, D_CXXONLY },\n-  { \"__has_nothrow_copy\", RID_HAS_NOTHROW_COPY, D_CXXONLY },\n-  { \"__has_trivial_assign\", RID_HAS_TRIVIAL_ASSIGN, D_CXXONLY },\n-  { \"__has_trivial_constructor\", RID_HAS_TRIVIAL_CONSTRUCTOR, D_CXXONLY },\n-  { \"__has_trivial_copy\", RID_HAS_TRIVIAL_COPY, D_CXXONLY },\n-  { \"__has_trivial_destructor\", RID_HAS_TRIVIAL_DESTRUCTOR, D_CXXONLY },\n-  { \"__has_unique_object_representations\", RID_HAS_UNIQUE_OBJ_REPRESENTATIONS,\n-\t\t\t\t\tD_CXXONLY },\n-  { \"__has_virtual_destructor\", RID_HAS_VIRTUAL_DESTRUCTOR, D_CXXONLY },\n   { \"__imag\",\t\tRID_IMAGPART,\t0 },\n   { \"__imag__\",\t\tRID_IMAGPART,\t0 },\n   { \"__inline\",\t\tRID_INLINE,\t0 },\n   { \"__inline__\",\tRID_INLINE,\t0 },\n-  { \"__is_abstract\",\tRID_IS_ABSTRACT, D_CXXONLY },\n-  { \"__is_aggregate\",\tRID_IS_AGGREGATE, D_CXXONLY },\n-  { \"__is_base_of\",\tRID_IS_BASE_OF, D_CXXONLY },\n-  { \"__is_class\",\tRID_IS_CLASS,\tD_CXXONLY },\n-  { \"__is_empty\",\tRID_IS_EMPTY,\tD_CXXONLY },\n-  { \"__is_enum\",\tRID_IS_ENUM,\tD_CXXONLY },\n-  { \"__is_final\",\tRID_IS_FINAL,\tD_CXXONLY },\n-  { \"__is_layout_compatible\", RID_IS_LAYOUT_COMPATIBLE, D_CXXONLY },\n-  { \"__is_literal_type\", RID_IS_LITERAL_TYPE, D_CXXONLY },\n-  { \"__is_pointer_interconvertible_base_of\",\n-\t\t\tRID_IS_POINTER_INTERCONVERTIBLE_BASE_OF, D_CXXONLY },\n-  { \"__is_pod\",\t\tRID_IS_POD,\tD_CXXONLY },\n-  { \"__is_polymorphic\",\tRID_IS_POLYMORPHIC, D_CXXONLY },\n-  { \"__is_same\",     RID_IS_SAME_AS, D_CXXONLY },\n-  { \"__is_same_as\",     RID_IS_SAME_AS, D_CXXONLY },\n-  { \"__is_standard_layout\", RID_IS_STD_LAYOUT, D_CXXONLY },\n-  { \"__is_trivial\",     RID_IS_TRIVIAL, D_CXXONLY },\n-  { \"__is_trivially_assignable\", RID_IS_TRIVIALLY_ASSIGNABLE, D_CXXONLY },\n-  { \"__is_trivially_constructible\", RID_IS_TRIVIALLY_CONSTRUCTIBLE, D_CXXONLY },\n-  { \"__is_trivially_copyable\", RID_IS_TRIVIALLY_COPYABLE, D_CXXONLY },\n-  { \"__is_union\",\tRID_IS_UNION,\tD_CXXONLY },\n   { \"__label__\",\tRID_LABEL,\t0 },\n   { \"__null\",\t\tRID_NULL,\t0 },\n   { \"__real\",\t\tRID_REALPART,\t0 },\n@@ -453,7 +420,6 @@ const struct c_common_resword c_common_reswords[] =\n   { \"__transaction_cancel\", RID_TRANSACTION_CANCEL, 0 },\n   { \"__typeof\",\t\tRID_TYPEOF,\t0 },\n   { \"__typeof__\",\tRID_TYPEOF,\t0 },\n-  { \"__underlying_type\", RID_UNDERLYING_TYPE, D_CXXONLY },\n   { \"__volatile\",\tRID_VOLATILE,\t0 },\n   { \"__volatile__\",\tRID_VOLATILE,\t0 },\n   { \"__GIMPLE\",\t\tRID_GIMPLE,\tD_CONLY },\n@@ -537,19 +503,13 @@ const struct c_common_resword c_common_reswords[] =\n   { \"volatile\",\t\tRID_VOLATILE,\t0 },\n   { \"wchar_t\",\t\tRID_WCHAR,\tD_CXXONLY },\n   { \"while\",\t\tRID_WHILE,\t0 },\n-  { \"__is_assignable\", RID_IS_ASSIGNABLE, D_CXXONLY },\n-  { \"__is_constructible\", RID_IS_CONSTRUCTIBLE, D_CXXONLY },\n-  { \"__is_nothrow_assignable\", RID_IS_NOTHROW_ASSIGNABLE, D_CXXONLY },\n-  { \"__is_nothrow_constructible\", RID_IS_NOTHROW_CONSTRUCTIBLE, D_CXXONLY },\n-  { \"__is_convertible\", RID_IS_CONVERTIBLE, D_CXXONLY },\n-  { \"__is_nothrow_convertible\", RID_IS_NOTHROW_CONVERTIBLE, D_CXXONLY },\n-  { \"__reference_constructs_from_temporary\", RID_REF_CONSTRUCTS_FROM_TEMPORARY,\n-\t\t\t\t\tD_CXXONLY },\n-  { \"__reference_converts_from_temporary\", RID_REF_CONVERTS_FROM_TEMPORARY,\n-\t\t\t\t\tD_CXXONLY },\n-  { \"__remove_cv\", RID_REMOVE_CV, D_CXXONLY },\n-  { \"__remove_reference\", RID_REMOVE_REFERENCE, D_CXXONLY },\n-  { \"__remove_cvref\", RID_REMOVE_CVREF, D_CXXONLY },\n+\n+#define DEFTRAIT(TCC, CODE, NAME, ARITY) \\\n+  { NAME,\t\tRID_##CODE,\tD_CXXONLY },\n+#include \"cp/cp-trait.def\"\n+#undef DEFTRAIT\n+  /* An alias for __is_same.  */\n+  { \"__is_same_as\",\tRID_IS_SAME_AS, D_CXXONLY },\n \n   /* C++ transactional memory.  */\n   { \"synchronized\",\tRID_SYNCHRONIZED, D_CXX_OBJC | D_TRANSMEM },"}, {"sha": "5f470d94f4afefdb289b7dd92b2e418ad8a710f9", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 8, "deletions": 25, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e2c124d71ac051373a30495793883c45bcc5415/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e2c124d71ac051373a30495793883c45bcc5415/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=1e2c124d71ac051373a30495793883c45bcc5415", "patch": "@@ -163,31 +163,14 @@ enum rid\n   RID_CONSTCAST, RID_DYNCAST, RID_REINTCAST, RID_STATCAST,\n \n   /* C++ extensions */\n-  RID_ADDRESSOF,               RID_BASES,\n-  RID_BUILTIN_LAUNDER,         RID_DIRECT_BASES,\n-  RID_HAS_NOTHROW_ASSIGN,      RID_HAS_NOTHROW_CONSTRUCTOR,\n-  RID_HAS_NOTHROW_COPY,        RID_HAS_TRIVIAL_ASSIGN,\n-  RID_HAS_TRIVIAL_CONSTRUCTOR, RID_HAS_TRIVIAL_COPY,\n-  RID_HAS_TRIVIAL_DESTRUCTOR,  RID_HAS_UNIQUE_OBJ_REPRESENTATIONS,\n-  RID_HAS_VIRTUAL_DESTRUCTOR,  RID_BUILTIN_BIT_CAST,\n-  RID_IS_ABSTRACT,             RID_IS_AGGREGATE,\n-  RID_IS_BASE_OF,              RID_IS_CLASS,\n-  RID_IS_EMPTY,                RID_IS_ENUM,\n-  RID_IS_FINAL,                RID_IS_LAYOUT_COMPATIBLE,\n-  RID_IS_LITERAL_TYPE,\n-  RID_IS_POINTER_INTERCONVERTIBLE_BASE_OF,\n-  RID_IS_POD,                  RID_IS_POLYMORPHIC,\n-  RID_IS_SAME_AS,\n-  RID_IS_STD_LAYOUT,           RID_IS_TRIVIAL,\n-  RID_IS_TRIVIALLY_ASSIGNABLE, RID_IS_TRIVIALLY_CONSTRUCTIBLE,\n-  RID_IS_TRIVIALLY_COPYABLE,\n-  RID_IS_UNION,                RID_UNDERLYING_TYPE,\n-  RID_IS_ASSIGNABLE,           RID_IS_CONSTRUCTIBLE,\n-  RID_IS_NOTHROW_ASSIGNABLE,   RID_IS_NOTHROW_CONSTRUCTIBLE,\n-  RID_IS_CONVERTIBLE,\t\tRID_IS_NOTHROW_CONVERTIBLE,\n-  RID_REF_CONSTRUCTS_FROM_TEMPORARY,\n-  RID_REF_CONVERTS_FROM_TEMPORARY,\n-  RID_REMOVE_CV, RID_REMOVE_REFERENCE, RID_REMOVE_CVREF,\n+  RID_ADDRESSOF,\n+  RID_BUILTIN_LAUNDER,\n+  RID_BUILTIN_BIT_CAST,\n+\n+#define DEFTRAIT(TCC, CODE, NAME, ARITY) \\\n+  RID_##CODE,\n+#include \"cp/cp-trait.def\"\n+#undef DEFTRAIT\n \n   /* C++11 */\n   RID_CONSTEXPR, RID_DECLTYPE, RID_NOEXCEPT, RID_NULLPTR, RID_STATIC_ASSERT,"}, {"sha": "f4145571d92d4a04ad8000af94e1595108302499", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e2c124d71ac051373a30495793883c45bcc5415/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e2c124d71ac051373a30495793883c45bcc5415/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=1e2c124d71ac051373a30495793883c45bcc5415", "patch": "@@ -3711,13 +3711,11 @@ diagnose_trait_expr (tree expr, tree args)\n       inform (loc, \"  %qT is not a reference that binds to a temporary \"\n \t      \"object of type %qT (copy-initialization)\", t1, t2);\n       break;\n-    case CPTK_BASES:\n-    case CPTK_DIRECT_BASES:\n-    case CPTK_UNDERLYING_TYPE:\n-    case CPTK_REMOVE_CV:\n-    case CPTK_REMOVE_REFERENCE:\n-    case CPTK_REMOVE_CVREF:\n-      /* We shouldn't see these non-expression traits.  */\n+#define DEFTRAIT_TYPE(CODE, NAME, ARITY) \\\n+    case CPTK_##CODE:\n+#include \"cp-trait.def\"\n+#undef DEFTRAIT_TYPE\n+      /* Type-yielding traits aren't expressions.  */\n       gcc_unreachable ();\n     /* We deliberately omit the default case so that when adding a new\n        trait we'll get reminded (by way of a warning) to handle it here.  */"}, {"sha": "e4df30d9720ea1f9dcb8df0fd8b65da581a3b32b", "filename": "gcc/cp/cp-objcp-common.cc", "status": "modified", "additions": 4, "deletions": 40, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e2c124d71ac051373a30495793883c45bcc5415/gcc%2Fcp%2Fcp-objcp-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e2c124d71ac051373a30495793883c45bcc5415/gcc%2Fcp%2Fcp-objcp-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.cc?ref=1e2c124d71ac051373a30495793883c45bcc5415", "patch": "@@ -430,46 +430,10 @@ names_builtin_p (const char *name)\n     case RID_BUILTIN_ASSOC_BARRIER:\n     case RID_BUILTIN_BIT_CAST:\n     case RID_OFFSETOF:\n-    case RID_HAS_NOTHROW_ASSIGN:\n-    case RID_HAS_NOTHROW_CONSTRUCTOR:\n-    case RID_HAS_NOTHROW_COPY:\n-    case RID_HAS_TRIVIAL_ASSIGN:\n-    case RID_HAS_TRIVIAL_CONSTRUCTOR:\n-    case RID_HAS_TRIVIAL_COPY:\n-    case RID_HAS_TRIVIAL_DESTRUCTOR:\n-    case RID_HAS_UNIQUE_OBJ_REPRESENTATIONS:\n-    case RID_HAS_VIRTUAL_DESTRUCTOR:\n-    case RID_IS_ABSTRACT:\n-    case RID_IS_AGGREGATE:\n-    case RID_IS_BASE_OF:\n-    case RID_IS_CLASS:\n-    case RID_IS_EMPTY:\n-    case RID_IS_ENUM:\n-    case RID_IS_FINAL:\n-    case RID_IS_LAYOUT_COMPATIBLE:\n-    case RID_IS_LITERAL_TYPE:\n-    case RID_IS_POINTER_INTERCONVERTIBLE_BASE_OF:\n-    case RID_IS_POD:\n-    case RID_IS_POLYMORPHIC:\n-    case RID_IS_SAME_AS:\n-    case RID_IS_STD_LAYOUT:\n-    case RID_IS_TRIVIAL:\n-    case RID_IS_TRIVIALLY_ASSIGNABLE:\n-    case RID_IS_TRIVIALLY_CONSTRUCTIBLE:\n-    case RID_IS_TRIVIALLY_COPYABLE:\n-    case RID_IS_UNION:\n-    case RID_IS_ASSIGNABLE:\n-    case RID_IS_CONSTRUCTIBLE:\n-    case RID_IS_NOTHROW_ASSIGNABLE:\n-    case RID_IS_NOTHROW_CONSTRUCTIBLE:\n-    case RID_UNDERLYING_TYPE:\n-    case RID_IS_CONVERTIBLE:\n-    case RID_IS_NOTHROW_CONVERTIBLE:\n-    case RID_REF_CONSTRUCTS_FROM_TEMPORARY:\n-    case RID_REF_CONVERTS_FROM_TEMPORARY:\n-    case RID_REMOVE_CV:\n-    case RID_REMOVE_REFERENCE:\n-    case RID_REMOVE_CVREF:\n+#define DEFTRAIT(TCC, CODE, NAME, ARITY) \\\n+    case RID_##CODE:\n+#include \"cp-trait.def\"\n+#undef DEFTRAIT\n       return true;\n     default:\n       break;"}, {"sha": "922348a16591d3a6077973320534fefc85ca7189", "filename": "gcc/cp/cp-trait.def", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e2c124d71ac051373a30495793883c45bcc5415/gcc%2Fcp%2Fcp-trait.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e2c124d71ac051373a30495793883c45bcc5415/gcc%2Fcp%2Fcp-trait.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-trait.def?ref=1e2c124d71ac051373a30495793883c45bcc5415", "patch": "@@ -0,0 +1,106 @@\n+/* This file contains the definitions for C++-specific built-in traits.\n+\n+   Copyright The GNU Toolchain Authors.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Add a DEFTRAIT_EXPR (CODE, NAME, N) line to this file to define an\n+   expression-yielding built-in trait that has internal code name CODE, is\n+   spelled as NAME and takes N type arguments (where N is either 1, 2, or\n+   the special value -1 which denotes that it takes at least one argument).\n+   Such traits are represented as TRAIT_EXPR tree whose TRAIT_EXPR_KIND is\n+   CPTK_CODE.  Define the behavior of the trait in finish_trait_expr.  */\n+\n+/* Add a DEFTRAIT_TYPE (CODE, NAME, N) line to this file to define a\n+   type-yielding built-in trait as described above.  Such traits are\n+   generally represented as a TRAIT_TYPE tree whose TRAIT_TYPE_KIND is\n+   CPTK_CODE (exceptions are BASES and DIRECT_BASES below).  Define the\n+   behavior of the trait in finish_trait_type.  */\n+\n+#ifdef DEFTRAIT\n+#define DEFTRAIT_EXPR(CODE, NAME, ARITY) DEFTRAIT(tcc_expression, CODE, NAME, ARITY)\n+#define DEFTRAIT_TYPE(CODE, NAME, ARITY) DEFTRAIT(tcc_type, CODE, NAME, ARITY)\n+#define DEFTRAIT_EXPR_DEFAULTED\n+#define DEFTRAIT_TYPE_DEFAULTED\n+#endif\n+\n+#ifndef DEFTRAIT_EXPR\n+#define DEFTRAIT_EXPR(CODE, NAME, ARITY)\n+#define DEFTRAIT_EXPR_DEFAULTED\n+#endif\n+\n+#ifndef DEFTRAIT_TYPE\n+#define DEFTRAIT_TYPE(CODE, NAME, ARITY)\n+#define DEFTRAIT_TYPE_DEFAULTED\n+#endif\n+\n+DEFTRAIT_EXPR (HAS_NOTHROW_ASSIGN, \"__has_nothrow_assign\", 1)\n+DEFTRAIT_EXPR (HAS_NOTHROW_CONSTRUCTOR, \"__has_nothrow_constructor\", 1)\n+DEFTRAIT_EXPR (HAS_NOTHROW_COPY, \"__has_nothrow_copy\", 1)\n+DEFTRAIT_EXPR (HAS_TRIVIAL_ASSIGN, \"__has_trivial_assign\", 1)\n+DEFTRAIT_EXPR (HAS_TRIVIAL_CONSTRUCTOR, \"__has_trivial_constructor\", 1)\n+DEFTRAIT_EXPR (HAS_TRIVIAL_COPY, \"__has_trivial_copy\", 1)\n+DEFTRAIT_EXPR (HAS_TRIVIAL_DESTRUCTOR, \"__has_trivial_destructor\", 1)\n+DEFTRAIT_EXPR (HAS_UNIQUE_OBJ_REPRESENTATIONS, \"__has_unique_object_representations\", 1)\n+DEFTRAIT_EXPR (HAS_VIRTUAL_DESTRUCTOR, \"__has_virtual_destructor\", 1)\n+DEFTRAIT_EXPR (IS_ABSTRACT, \"__is_abstract\", 1)\n+DEFTRAIT_EXPR (IS_AGGREGATE, \"__is_aggregate\", 1)\n+DEFTRAIT_EXPR (IS_ASSIGNABLE, \"__is_assignable\", 2)\n+DEFTRAIT_EXPR (IS_BASE_OF, \"__is_base_of\", 2)\n+DEFTRAIT_EXPR (IS_CLASS, \"__is_class\", 1)\n+DEFTRAIT_EXPR (IS_CONSTRUCTIBLE, \"__is_constructible\", -1)\n+DEFTRAIT_EXPR (IS_CONVERTIBLE, \"__is_convertible\", 2)\n+DEFTRAIT_EXPR (IS_EMPTY, \"__is_empty\", 1)\n+DEFTRAIT_EXPR (IS_ENUM, \"__is_enum\", 1)\n+DEFTRAIT_EXPR (IS_FINAL, \"__is_final\", 1)\n+DEFTRAIT_EXPR (IS_LAYOUT_COMPATIBLE, \"__is_layout_compatible\", 2)\n+DEFTRAIT_EXPR (IS_LITERAL_TYPE, \"__is_literal_type\", 1)\n+DEFTRAIT_EXPR (IS_NOTHROW_ASSIGNABLE, \"__is_nothrow_assignable\", 2)\n+DEFTRAIT_EXPR (IS_NOTHROW_CONSTRUCTIBLE, \"__is_nothrow_constructible\", -1)\n+DEFTRAIT_EXPR (IS_NOTHROW_CONVERTIBLE, \"__is_nothrow_convertible\", 2)\n+DEFTRAIT_EXPR (IS_POINTER_INTERCONVERTIBLE_BASE_OF, \"__is_pointer_interconvertible_base_of\", 2)\n+DEFTRAIT_EXPR (IS_POD, \"__is_pod\", 1)\n+DEFTRAIT_EXPR (IS_POLYMORPHIC, \"__is_polymorphic\", 1)\n+DEFTRAIT_EXPR (IS_SAME_AS, \"__is_same\", 2)\n+DEFTRAIT_EXPR (IS_STD_LAYOUT, \"__is_standard_layout\", 1)\n+DEFTRAIT_EXPR (IS_TRIVIAL, \"__is_trivial\", 1)\n+DEFTRAIT_EXPR (IS_TRIVIALLY_ASSIGNABLE, \"__is_trivially_assignable\", 2)\n+DEFTRAIT_EXPR (IS_TRIVIALLY_CONSTRUCTIBLE, \"__is_trivially_constructible\", -1)\n+DEFTRAIT_EXPR (IS_TRIVIALLY_COPYABLE, \"__is_trivially_copyable\", 1)\n+DEFTRAIT_EXPR (IS_UNION, \"__is_union\", 1)\n+DEFTRAIT_EXPR (REF_CONSTRUCTS_FROM_TEMPORARY, \"__reference_constructs_from_temporary\", 2)\n+DEFTRAIT_EXPR (REF_CONVERTS_FROM_TEMPORARY, \"__reference_converts_from_temporary\", 2)\n+\n+DEFTRAIT_TYPE (REMOVE_CV, \"__remove_cv\", 1)\n+DEFTRAIT_TYPE (REMOVE_REFERENCE, \"__remove_reference\", 1)\n+DEFTRAIT_TYPE (REMOVE_CVREF, \"__remove_cvref\", 1)\n+DEFTRAIT_TYPE (UNDERLYING_TYPE,  \"__underlying_type\", 1)\n+\n+/* These traits yield a type pack, not a type, and are represented by\n+   cp_parser_trait as a special BASES tree instead of a TRAIT_TYPE tree.  */\n+DEFTRAIT_TYPE (BASES, \"__bases\", 1)\n+DEFTRAIT_TYPE (DIRECT_BASES, \"__direct_bases\", 1)\n+\n+#ifdef DEFTRAIT_EXPR_DEFAULTED\n+#undef DEFTRAIT_EXPR\n+#undef DEFTRAIT_EXPR_DEFAULTED\n+#endif\n+\n+#ifdef DEFTRAIT_TYPE_DEFAULTED\n+#undef DEFTRAIT_TYPE\n+#undef DEFTRAIT_TYPE_DEFAULTED\n+#endif"}, {"sha": "67aea9653e3cc3521e101c2981078d131bd54208", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 42, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e2c124d71ac051373a30495793883c45bcc5415/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e2c124d71ac051373a30495793883c45bcc5415/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1e2c124d71ac051373a30495793883c45bcc5415", "patch": "@@ -1374,48 +1374,10 @@ struct GTY (()) tree_argument_pack_select {\n \n enum cp_trait_kind\n {\n-  CPTK_BASES,\n-  CPTK_DIRECT_BASES,\n-  CPTK_HAS_NOTHROW_ASSIGN,\n-  CPTK_HAS_NOTHROW_CONSTRUCTOR,\n-  CPTK_HAS_NOTHROW_COPY,\n-  CPTK_HAS_TRIVIAL_ASSIGN,\n-  CPTK_HAS_TRIVIAL_CONSTRUCTOR,\n-  CPTK_HAS_TRIVIAL_COPY,\n-  CPTK_HAS_TRIVIAL_DESTRUCTOR,\n-  CPTK_HAS_UNIQUE_OBJ_REPRESENTATIONS,\n-  CPTK_HAS_VIRTUAL_DESTRUCTOR,\n-  CPTK_IS_ABSTRACT,\n-  CPTK_IS_AGGREGATE,\n-  CPTK_IS_BASE_OF,\n-  CPTK_IS_CLASS,\n-  CPTK_IS_EMPTY,\n-  CPTK_IS_ENUM,\n-  CPTK_IS_FINAL,\n-  CPTK_IS_LAYOUT_COMPATIBLE,\n-  CPTK_IS_LITERAL_TYPE,\n-  CPTK_IS_POINTER_INTERCONVERTIBLE_BASE_OF,\n-  CPTK_IS_POD,\n-  CPTK_IS_POLYMORPHIC,\n-  CPTK_IS_SAME_AS,\n-  CPTK_IS_STD_LAYOUT,\n-  CPTK_IS_TRIVIAL,\n-  CPTK_IS_TRIVIALLY_ASSIGNABLE,\n-  CPTK_IS_TRIVIALLY_CONSTRUCTIBLE,\n-  CPTK_IS_TRIVIALLY_COPYABLE,\n-  CPTK_IS_UNION,\n-  CPTK_UNDERLYING_TYPE,\n-  CPTK_IS_ASSIGNABLE,\n-  CPTK_IS_CONSTRUCTIBLE,\n-  CPTK_IS_NOTHROW_ASSIGNABLE,\n-  CPTK_IS_NOTHROW_CONSTRUCTIBLE,\n-  CPTK_IS_CONVERTIBLE,\n-  CPTK_IS_NOTHROW_CONVERTIBLE,\n-  CPTK_REF_CONSTRUCTS_FROM_TEMPORARY,\n-  CPTK_REF_CONVERTS_FROM_TEMPORARY,\n-  CPTK_REMOVE_CV,\n-  CPTK_REMOVE_REFERENCE,\n-  CPTK_REMOVE_CVREF,\n+#define DEFTRAIT(TCC, CODE, NAME, ARITY) \\\n+  CPTK_##CODE,\n+#include \"cp-trait.def\"\n+#undef DEFTRAIT\n };\n \n /* The types that we are processing.  */"}, {"sha": "8ca1b8f234a5ea26161c808afa936f5d54393aba", "filename": "gcc/cp/cxx-pretty-print.cc", "status": "modified", "additions": 5, "deletions": 121, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e2c124d71ac051373a30495793883c45bcc5415/gcc%2Fcp%2Fcxx-pretty-print.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e2c124d71ac051373a30495793883c45bcc5415/gcc%2Fcp%2Fcxx-pretty-print.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.cc?ref=1e2c124d71ac051373a30495793883c45bcc5415", "patch": "@@ -2617,128 +2617,12 @@ pp_cxx_trait (cxx_pretty_printer *pp, tree t)\n \n   switch (kind)\n     {\n-    case CPTK_HAS_NOTHROW_ASSIGN:\n-      pp_cxx_ws_string (pp, \"__has_nothrow_assign\");\n+#define DEFTRAIT(TCC, CODE, NAME, ARITY) \\\n+    case CPTK_##CODE:\t\t\t \\\n+      pp_cxx_ws_string (pp, NAME);\t \\\n       break;\n-    case CPTK_HAS_TRIVIAL_ASSIGN:\n-      pp_cxx_ws_string (pp, \"__has_trivial_assign\");\n-      break;\n-    case CPTK_HAS_NOTHROW_CONSTRUCTOR:\n-      pp_cxx_ws_string (pp, \"__has_nothrow_constructor\");\n-      break;\n-    case CPTK_HAS_TRIVIAL_CONSTRUCTOR:\n-      pp_cxx_ws_string (pp, \"__has_trivial_constructor\");\n-      break;\n-    case CPTK_HAS_NOTHROW_COPY:\n-      pp_cxx_ws_string (pp, \"__has_nothrow_copy\");\n-      break;\n-    case CPTK_HAS_TRIVIAL_COPY:\n-      pp_cxx_ws_string (pp, \"__has_trivial_copy\");\n-      break;\n-    case CPTK_HAS_TRIVIAL_DESTRUCTOR:\n-      pp_cxx_ws_string (pp, \"__has_trivial_destructor\");\n-      break;\n-    case CPTK_HAS_UNIQUE_OBJ_REPRESENTATIONS:\n-      pp_cxx_ws_string (pp, \"__has_unique_object_representations\");\n-      break;\n-    case CPTK_HAS_VIRTUAL_DESTRUCTOR:\n-      pp_cxx_ws_string (pp, \"__has_virtual_destructor\");\n-      break;\n-    case CPTK_IS_ABSTRACT:\n-      pp_cxx_ws_string (pp, \"__is_abstract\");\n-      break;\n-    case CPTK_IS_AGGREGATE:\n-      pp_cxx_ws_string (pp, \"__is_aggregate\");\n-      break;\n-    case CPTK_IS_BASE_OF:\n-      pp_cxx_ws_string (pp, \"__is_base_of\");\n-      break;\n-    case CPTK_IS_CLASS:\n-      pp_cxx_ws_string (pp, \"__is_class\");\n-      break;\n-    case CPTK_IS_EMPTY:\n-      pp_cxx_ws_string (pp, \"__is_empty\");\n-      break;\n-    case CPTK_IS_ENUM:\n-      pp_cxx_ws_string (pp, \"__is_enum\");\n-      break;\n-    case CPTK_IS_FINAL:\n-      pp_cxx_ws_string (pp, \"__is_final\");\n-      break;\n-    case CPTK_IS_LAYOUT_COMPATIBLE:\n-      pp_cxx_ws_string (pp, \"__is_layout_compatible\");\n-      break;\n-    case CPTK_IS_POINTER_INTERCONVERTIBLE_BASE_OF:\n-      pp_cxx_ws_string (pp, \"__is_pointer_interconvertible_base_of\");\n-      break;\n-    case CPTK_IS_POD:\n-      pp_cxx_ws_string (pp, \"__is_pod\");\n-      break;\n-    case CPTK_IS_POLYMORPHIC:\n-      pp_cxx_ws_string (pp, \"__is_polymorphic\");\n-      break;\n-    case CPTK_IS_SAME_AS:\n-      pp_cxx_ws_string (pp, \"__is_same\");\n-      break;\n-    case CPTK_IS_STD_LAYOUT:\n-      pp_cxx_ws_string (pp, \"__is_std_layout\");\n-      break;\n-    case CPTK_IS_TRIVIAL:\n-      pp_cxx_ws_string (pp, \"__is_trivial\");\n-      break;\n-    case CPTK_IS_TRIVIALLY_ASSIGNABLE:\n-      pp_cxx_ws_string (pp, \"__is_trivially_assignable\");\n-      break;\n-    case CPTK_IS_TRIVIALLY_CONSTRUCTIBLE:\n-      pp_cxx_ws_string (pp, \"__is_trivially_constructible\");\n-      break;\n-    case CPTK_IS_TRIVIALLY_COPYABLE:\n-      pp_cxx_ws_string (pp, \"__is_trivially_copyable\");\n-      break;\n-    case CPTK_IS_UNION:\n-      pp_cxx_ws_string (pp, \"__is_union\");\n-      break;\n-    case CPTK_IS_LITERAL_TYPE:\n-      pp_cxx_ws_string (pp, \"__is_literal_type\");\n-      break;\n-    case CPTK_IS_ASSIGNABLE:\n-      pp_cxx_ws_string (pp, \"__is_assignable\");\n-      break;\n-    case CPTK_IS_CONSTRUCTIBLE:\n-      pp_cxx_ws_string (pp, \"__is_constructible\");\n-      break;\n-    case CPTK_IS_NOTHROW_ASSIGNABLE:\n-      pp_cxx_ws_string (pp, \"__is_nothrow_assignable\");\n-      break;\n-    case CPTK_IS_NOTHROW_CONSTRUCTIBLE:\n-      pp_cxx_ws_string (pp, \"__is_nothrow_constructible\");\n-      break;\n-    case CPTK_IS_CONVERTIBLE:\n-      pp_cxx_ws_string (pp, \"__is_convertible\");\n-      break;\n-    case CPTK_IS_NOTHROW_CONVERTIBLE:\n-      pp_cxx_ws_string (pp, \"__is_nothrow_convertible\");\n-      break;\n-    case CPTK_REF_CONSTRUCTS_FROM_TEMPORARY:\n-      pp_cxx_ws_string (pp, \"__reference_constructs_from_temporary\");\n-      break;\n-    case CPTK_REF_CONVERTS_FROM_TEMPORARY:\n-      pp_cxx_ws_string (pp, \"__reference_converts_from_temporary\");\n-      break;\n-    case CPTK_UNDERLYING_TYPE:\n-      pp_cxx_ws_string (pp, \"__underlying_type\");\n-      break;\n-    case CPTK_REMOVE_CV:\n-      pp_cxx_ws_string (pp, \"__remove_cv\");\n-      break;\n-    case CPTK_REMOVE_REFERENCE:\n-      pp_cxx_ws_string (pp, \"__remove_reference\");\n-      break;\n-    case CPTK_REMOVE_CVREF:\n-      pp_cxx_ws_string (pp, \"__remove_cvref\");\n-      break;\n-    default:\n-      gcc_unreachable ();\n+#include \"cp-trait.def\"\n+#undef DEFTRAIT\n     }\n \n   pp_cxx_left_paren (pp);"}, {"sha": "8d0e0fa1b8799031f5826c1a9b4930d216c1292d", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 22, "deletions": 195, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e2c124d71ac051373a30495793883c45bcc5415/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e2c124d71ac051373a30495793883c45bcc5415/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=1e2c124d71ac051373a30495793883c45bcc5415", "patch": "@@ -1146,16 +1146,18 @@ cp_keyword_starts_decl_specifier_p (enum rid keyword)\n     case RID_TYPEOF:\n       /* C++11 extensions.  */\n     case RID_DECLTYPE:\n-    case RID_UNDERLYING_TYPE:\n-    case RID_REMOVE_CV:\n-    case RID_REMOVE_REFERENCE:\n-    case RID_REMOVE_CVREF:\n     case RID_CONSTEXPR:\n       /* C++20 extensions.  */\n     case RID_CONSTINIT:\n     case RID_CONSTEVAL:\n       return true;\n \n+#define DEFTRAIT_TYPE(CODE, NAME, ARITY) \\\n+    case RID_##CODE:\n+#include \"cp-trait.def\"\n+#undef DEFTRAIT_TYPE\n+      return true;\n+\n     default:\n       if (keyword >= RID_FIRST_INT_N\n \t  && keyword < RID_FIRST_INT_N + NUM_INT_N_ENTS\n@@ -5895,42 +5897,10 @@ cp_parser_primary_expression (cp_parser *parser,\n \tcase RID_OFFSETOF:\n \t  return cp_parser_builtin_offsetof (parser);\n \n-\tcase RID_HAS_NOTHROW_ASSIGN:\n-\tcase RID_HAS_NOTHROW_CONSTRUCTOR:\n-\tcase RID_HAS_NOTHROW_COPY:\n-\tcase RID_HAS_TRIVIAL_ASSIGN:\n-\tcase RID_HAS_TRIVIAL_CONSTRUCTOR:\n-\tcase RID_HAS_TRIVIAL_COPY:\n-\tcase RID_HAS_TRIVIAL_DESTRUCTOR:\n-\tcase RID_HAS_UNIQUE_OBJ_REPRESENTATIONS:\n-\tcase RID_HAS_VIRTUAL_DESTRUCTOR:\n-\tcase RID_IS_ABSTRACT:\n-\tcase RID_IS_AGGREGATE:\n-\tcase RID_IS_BASE_OF:\n-\tcase RID_IS_CLASS:\n-\tcase RID_IS_EMPTY:\n-\tcase RID_IS_ENUM:\n-\tcase RID_IS_FINAL:\n-\tcase RID_IS_LAYOUT_COMPATIBLE:\n-\tcase RID_IS_LITERAL_TYPE:\n-\tcase RID_IS_POINTER_INTERCONVERTIBLE_BASE_OF:\n-\tcase RID_IS_POD:\n-\tcase RID_IS_POLYMORPHIC:\n-\tcase RID_IS_SAME_AS:\n-\tcase RID_IS_STD_LAYOUT:\n-\tcase RID_IS_TRIVIAL:\n-\tcase RID_IS_TRIVIALLY_ASSIGNABLE:\n-\tcase RID_IS_TRIVIALLY_CONSTRUCTIBLE:\n-\tcase RID_IS_TRIVIALLY_COPYABLE:\n-\tcase RID_IS_UNION:\n-\tcase RID_IS_ASSIGNABLE:\n-\tcase RID_IS_CONSTRUCTIBLE:\n-\tcase RID_IS_NOTHROW_ASSIGNABLE:\n-\tcase RID_IS_NOTHROW_CONSTRUCTIBLE:\n-\tcase RID_IS_CONVERTIBLE:\n-\tcase RID_IS_NOTHROW_CONVERTIBLE:\n-\tcase RID_REF_CONSTRUCTS_FROM_TEMPORARY:\n-\tcase RID_REF_CONVERTS_FROM_TEMPORARY:\n+#define DEFTRAIT_EXPR(CODE, NAME, ARITY) \\\n+\tcase RID_##CODE:\n+#include \"cp-trait.def\"\n+#undef DEFTRAIT_EXPR\n \t  return cp_parser_trait (parser, token->keyword);\n \n \t// C++ concepts\n@@ -10898,150 +10868,15 @@ cp_parser_trait (cp_parser* parser, enum rid keyword)\n \n   switch (keyword)\n     {\n-    case RID_HAS_NOTHROW_ASSIGN:\n-      kind = CPTK_HAS_NOTHROW_ASSIGN;\n-      break;\n-    case RID_HAS_NOTHROW_CONSTRUCTOR:\n-      kind = CPTK_HAS_NOTHROW_CONSTRUCTOR;\n-      break;\n-    case RID_HAS_NOTHROW_COPY:\n-      kind = CPTK_HAS_NOTHROW_COPY;\n-      break;\n-    case RID_HAS_TRIVIAL_ASSIGN:\n-      kind = CPTK_HAS_TRIVIAL_ASSIGN;\n-      break;\n-    case RID_HAS_TRIVIAL_CONSTRUCTOR:\n-      kind = CPTK_HAS_TRIVIAL_CONSTRUCTOR;\n-      break;\n-    case RID_HAS_TRIVIAL_COPY:\n-      kind = CPTK_HAS_TRIVIAL_COPY;\n-      break;\n-    case RID_HAS_TRIVIAL_DESTRUCTOR:\n-      kind = CPTK_HAS_TRIVIAL_DESTRUCTOR;\n-      break;\n-    case RID_HAS_UNIQUE_OBJ_REPRESENTATIONS:\n-      kind = CPTK_HAS_UNIQUE_OBJ_REPRESENTATIONS;\n-      break;\n-    case RID_HAS_VIRTUAL_DESTRUCTOR:\n-      kind = CPTK_HAS_VIRTUAL_DESTRUCTOR;\n-      break;\n-    case RID_IS_ABSTRACT:\n-      kind = CPTK_IS_ABSTRACT;\n-      break;\n-    case RID_IS_AGGREGATE:\n-      kind = CPTK_IS_AGGREGATE;\n-      break;\n-    case RID_IS_BASE_OF:\n-      kind = CPTK_IS_BASE_OF;\n-      binary = true;\n-      break;\n-    case RID_IS_CLASS:\n-      kind = CPTK_IS_CLASS;\n-      break;\n-    case RID_IS_EMPTY:\n-      kind = CPTK_IS_EMPTY;\n-      break;\n-    case RID_IS_ENUM:\n-      kind = CPTK_IS_ENUM;\n-      break;\n-    case RID_IS_FINAL:\n-      kind = CPTK_IS_FINAL;\n-      break;\n-    case RID_IS_LAYOUT_COMPATIBLE:\n-      kind = CPTK_IS_LAYOUT_COMPATIBLE;\n-      binary = true;\n-      break;\n-    case RID_IS_LITERAL_TYPE:\n-      kind = CPTK_IS_LITERAL_TYPE;\n-      break;\n-    case RID_IS_POINTER_INTERCONVERTIBLE_BASE_OF:\n-      kind = CPTK_IS_POINTER_INTERCONVERTIBLE_BASE_OF;\n-      binary = true;\n-      break;\n-    case RID_IS_POD:\n-      kind = CPTK_IS_POD;\n-      break;\n-    case RID_IS_POLYMORPHIC:\n-      kind = CPTK_IS_POLYMORPHIC;\n-      break;\n-    case RID_IS_SAME_AS:\n-      kind = CPTK_IS_SAME_AS;\n-      binary = true;\n-      break;\n-    case RID_IS_STD_LAYOUT:\n-      kind = CPTK_IS_STD_LAYOUT;\n-      break;\n-    case RID_IS_TRIVIAL:\n-      kind = CPTK_IS_TRIVIAL;\n-      break;\n-    case RID_IS_TRIVIALLY_ASSIGNABLE:\n-      kind = CPTK_IS_TRIVIALLY_ASSIGNABLE;\n-      binary = true;\n-      break;\n-    case RID_IS_TRIVIALLY_CONSTRUCTIBLE:\n-      kind = CPTK_IS_TRIVIALLY_CONSTRUCTIBLE;\n-      variadic = true;\n-      break;\n-    case RID_IS_TRIVIALLY_COPYABLE:\n-      kind = CPTK_IS_TRIVIALLY_COPYABLE;\n-      break;\n-    case RID_IS_UNION:\n-      kind = CPTK_IS_UNION;\n-      break;\n-    case RID_UNDERLYING_TYPE:\n-      kind = CPTK_UNDERLYING_TYPE;\n-      type = true;\n-      break;\n-    case RID_BASES:\n-      kind = CPTK_BASES;\n-      break;\n-    case RID_DIRECT_BASES:\n-      kind = CPTK_DIRECT_BASES;\n-      break;\n-    case RID_IS_ASSIGNABLE:\n-      kind = CPTK_IS_ASSIGNABLE;\n-      binary = true;\n-      break;\n-    case RID_IS_CONSTRUCTIBLE:\n-      kind = CPTK_IS_CONSTRUCTIBLE;\n-      variadic = true;\n-      break;\n-    case RID_IS_NOTHROW_ASSIGNABLE:\n-      kind = CPTK_IS_NOTHROW_ASSIGNABLE;\n-      binary = true;\n-      break;\n-    case RID_IS_NOTHROW_CONSTRUCTIBLE:\n-      kind = CPTK_IS_NOTHROW_CONSTRUCTIBLE;\n-      variadic = true;\n-      break;\n-    case RID_IS_CONVERTIBLE:\n-      kind = CPTK_IS_CONVERTIBLE;\n-      binary = true;\n-      break;\n-    case RID_IS_NOTHROW_CONVERTIBLE:\n-      kind = CPTK_IS_NOTHROW_CONVERTIBLE;\n-      binary = true;\n-      break;\n-    case RID_REF_CONSTRUCTS_FROM_TEMPORARY:\n-      kind = CPTK_REF_CONSTRUCTS_FROM_TEMPORARY;\n-      binary = true;\n-      break;\n-    case RID_REF_CONVERTS_FROM_TEMPORARY:\n-      kind = CPTK_REF_CONVERTS_FROM_TEMPORARY;\n-      binary = true;\n-      break;\n-    case RID_REMOVE_CV:\n-      kind = CPTK_REMOVE_CV;\n-      type = true;\n-      break;\n-    case RID_REMOVE_REFERENCE:\n-      kind = CPTK_REMOVE_REFERENCE;\n-      type = true;\n-      break;\n-    case RID_REMOVE_CVREF:\n-      kind = CPTK_REMOVE_CVREF;\n-      type = true;\n+#define DEFTRAIT(TCC, CODE, NAME, ARITY) \\\n+    case RID_##CODE:\t\t\t \\\n+      kind = CPTK_##CODE;\t\t \\\n+      binary = (ARITY == 2);\t\t \\\n+      variadic = (ARITY == -1);\t\t \\\n+      type = (TCC == tcc_type);\t\t \\\n       break;\n+#include \"cp-trait.def\"\n+#undef DEFTRAIT\n     default:\n       gcc_unreachable ();\n     }\n@@ -19881,10 +19716,10 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \n       return type;\n \n-    case RID_UNDERLYING_TYPE:\n-    case RID_REMOVE_CV:\n-    case RID_REMOVE_REFERENCE:\n-    case RID_REMOVE_CVREF:\n+#define DEFTRAIT_TYPE(CODE, NAME, ARITY) \\\n+    case RID_##CODE:\n+#include \"cp-trait.def\"\n+#undef DEFTRAIT_TYPE\n       type = cp_parser_trait (parser, token->keyword);\n       if (decl_specs)\n \tcp_parser_set_decl_spec_type (decl_specs, type,\n@@ -19893,14 +19728,6 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \n       return type;\n \n-    case RID_BASES:\n-    case RID_DIRECT_BASES:\n-      type = cp_parser_trait (parser, token->keyword);\n-      if (decl_specs)\n-       cp_parser_set_decl_spec_type (decl_specs, type,\n-                                     token,\n-                                     /*type_definition_p=*/false);\n-      return type;\n     default:\n       break;\n     }"}]}