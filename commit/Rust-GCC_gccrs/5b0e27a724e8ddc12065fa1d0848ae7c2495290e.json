{"sha": "5b0e27a724e8ddc12065fa1d0848ae7c2495290e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWIwZTI3YTcyNGU4ZGRjMTIwNjVmYTFkMDg0OGFlN2MyNDk1MjkwZQ==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2016-06-23T15:58:05Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2016-06-23T15:58:05Z"}, "message": "re PR libfortran/48852 (Invalid spaces in list-directed output of complex constants)\n\n2016-06-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/48852\n\t* io/write.c: Cleaned up whitespace.\n\t(write_d, write_e, write_f, write_es, write_en): Use new helper function\n\twrite_float_0. (write_float_0): New helper function.\n\t(get_precision, select_buffer, select_string, write_float_string): New\n\thelper functions used in remaining float writing functions. Helper function\n\twrite_float_string now contains code for writing to kind=4 character\n\tinternal units.\n\t(write_real): Modified to establish working buffers at this level and to\n\tuse new helper functions.\n\t(write_real_g0): Likewise modified.\n\t(write_complex): Likewise modified. Gets both float strings before\n\toutput so that final lengths can be determined which allows right\n\tjustifying the complex number with no intervening spaces.\n\t* io/write_float.def (build_float_string): Renamed from previosly\n\toutput_float, modified to use buffers passed in from higher functions,\n\tbuilds a null terminated string of the floating point value. Character\n\tkind=4 code eliminated.\n\t(write_infnan): Likewise modified to use incoming buffers and eliminate\n\tkind=4 related code.\n\t(OUTPUT_FLOAT_FMT_G): Deleted, functionality moved into FORMAT_FLOAT.\n\t(FORMAT_FLOAT): Renamed macro from WRITE_FLOAT. Use build_float_string.\n\t(get_float_string): Renamed from write_float, uses FORMAT_FLOAT macro.\n\tBuffer allocation removed, now at higher level.\n\n\tPR libgfortran/48852\n\t* gfortran.dg/char4_iunit_1.f03: Update test.\n\t* gfortran.dg/f2003_io_5.f03: Update test.\n\t* gfortran.dg/real_const_3.f90: Update test.\n\nFrom-SVN: r237735", "tree": {"sha": "15a9936a35c8faea733bb284959bf1f4484f4c85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15a9936a35c8faea733bb284959bf1f4484f4c85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b0e27a724e8ddc12065fa1d0848ae7c2495290e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b0e27a724e8ddc12065fa1d0848ae7c2495290e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b0e27a724e8ddc12065fa1d0848ae7c2495290e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b0e27a724e8ddc12065fa1d0848ae7c2495290e/comments", "author": null, "committer": null, "parents": [{"sha": "cd64be5bcae8c6f0ccf50aac0e0a16f28e23d042", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd64be5bcae8c6f0ccf50aac0e0a16f28e23d042", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd64be5bcae8c6f0ccf50aac0e0a16f28e23d042"}], "stats": {"total": 959, "additions": 467, "deletions": 492}, "files": [{"sha": "e3c95486b48fcb084730078459cb1baf58bd1365", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b0e27a724e8ddc12065fa1d0848ae7c2495290e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b0e27a724e8ddc12065fa1d0848ae7c2495290e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5b0e27a724e8ddc12065fa1d0848ae7c2495290e", "patch": "@@ -1,3 +1,10 @@\n+2016-06-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/48852\n+\t* gfortran.dg/char4_iunit_1.f03: Update test.\n+\t* gfortran.dg/f2003_io_5.f03: Update test.\n+\t* gfortran.dg/real_const_3.f90: Update test.\n+\n 2016-06-23  Andi Kleen  <ak@linux.intel.com>\n \n \t* g++.dg/bprob/bprob.exp: Support autofdo."}, {"sha": "7d388ad99fed5ce39c8c9c083b652a2b3007484e", "filename": "gcc/testsuite/gfortran.dg/char4_iunit_1.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b0e27a724e8ddc12065fa1d0848ae7c2495290e/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar4_iunit_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b0e27a724e8ddc12065fa1d0848ae7c2495290e/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar4_iunit_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar4_iunit_1.f03?ref=5b0e27a724e8ddc12065fa1d0848ae7c2495290e", "patch": "@@ -30,5 +30,5 @@ program char4_iunit_1\n   write(string, '(10x,f3.1,3x,f9.1)') nan, inf\n   if (string .ne. 4_\"          NaN    Infinity             \") call abort\n   write(string, *) (1.2, 3.4 )\n-  if (string .ne. 4_\" (  1.20000005    ,  3.40000010    )  \") call abort\n+  if (string .ne. 4_\"             (1.20000005,3.40000010)\") call abort\n end program char4_iunit_1"}, {"sha": "34b8adbb0ade1811dbe29b0b33852cc6fd62a428", "filename": "gcc/testsuite/gfortran.dg/f2003_io_5.f03", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b0e27a724e8ddc12065fa1d0848ae7c2495290e/gcc%2Ftestsuite%2Fgfortran.dg%2Ff2003_io_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b0e27a724e8ddc12065fa1d0848ae7c2495290e/gcc%2Ftestsuite%2Fgfortran.dg%2Ff2003_io_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ff2003_io_5.f03?ref=5b0e27a724e8ddc12065fa1d0848ae7c2495290e", "patch": "@@ -18,9 +18,9 @@\n \n c = (3.123,4.456)\n write(complex,*,decimal=\"comma\") c\n-if (complex.ne.\" (  3,12299991    ;  4,45599985    )\") call abort\n+if (complex.ne.\"             (3,12299991;4,45599985)\") call abort\n c = (0.0, 0.0)\n read(complex,*,decimal=\"comma\") c\n-if (complex.ne.\" (  3,12299991    ;  4,45599985    )\") call abort\n+if (complex.ne.\"             (3,12299991;4,45599985)\") call abort\n \n end"}, {"sha": "c70591d3cfccef3dca8c3da4ba92b55445ceac42", "filename": "gcc/testsuite/gfortran.dg/real_const_3.f90", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b0e27a724e8ddc12065fa1d0848ae7c2495290e/gcc%2Ftestsuite%2Fgfortran.dg%2Freal_const_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b0e27a724e8ddc12065fa1d0848ae7c2495290e/gcc%2Ftestsuite%2Fgfortran.dg%2Freal_const_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Freal_const_3.f90?ref=5b0e27a724e8ddc12065fa1d0848ae7c2495290e", "patch": "@@ -42,15 +42,14 @@ program main\n   if (trim(adjustl(str)) .ne. 'NaN') call abort\n \n   write(str,*) z\n-  if (trim(adjustl(str)) .ne. '(             NaN,             NaN)') call abort\n+  if (trim(adjustl(str)) .ne. '(NaN,NaN)') call abort\n \n   write(str,*) z2\n-  if (trim(adjustl(str)) .ne. '(             NaN,             NaN)') call abort\n+  if (trim(adjustl(str)) .ne. '(NaN,NaN)') call abort\n \n   write(str,*) z3\n-  if (trim(adjustl(str)) .ne. '(        Infinity,       -Infinity)') call abort\n+  if (trim(adjustl(str)) .ne. '(Inf,-Inf)') call abort\n \n   write(str,*) z4\n-  if (trim(adjustl(str)) .ne. '(  0.00000000    , -0.00000000    )') call abort\n-\n+  if (trim(adjustl(str)) .ne. '(0.00000000,-0.00000000)') call abort\n end program main"}, {"sha": "04a708e17fed9eb090e2c484ffd7957c5ab59d8e", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b0e27a724e8ddc12065fa1d0848ae7c2495290e/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b0e27a724e8ddc12065fa1d0848ae7c2495290e/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=5b0e27a724e8ddc12065fa1d0848ae7c2495290e", "patch": "@@ -1,3 +1,30 @@\n+2016-06-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/48852\n+\t* io/write.c: Cleaned up whitespace.\n+\t(write_d, write_e, write_f, write_es, write_en): Use new helper function\n+\twrite_float_0. (write_float_0): New helper function.\n+\t(get_precision, select_buffer, select_string, write_float_string): New\n+\thelper functions used in remaining float writing functions. Helper function\n+\twrite_float_string now contains code for writing to kind=4 character\n+\tinternal units.\n+\t(write_real): Modified to establish working buffers at this level and to\n+\tuse new helper functions.\n+\t(write_real_g0): Likewise modified.\n+\t(write_complex): Likewise modified. Gets both float strings before\n+\toutput so that final lengths can be determined which allows right\n+\tjustifying the complex number with no intervening spaces.\n+\t* io/write_float.def (build_float_string): Renamed from previosly\n+\toutput_float, modified to use buffers passed in from higher functions,\n+\tbuilds a null terminated string of the floating point value. Character\n+\tkind=4 code eliminated.\n+\t(write_infnan): Likewise modified to use incoming buffers and eliminate\n+\tkind=4 related code.\n+\t(OUTPUT_FLOAT_FMT_G): Deleted, functionality moved into FORMAT_FLOAT.\n+\t(FORMAT_FLOAT): Renamed macro from WRITE_FLOAT. Use build_float_string.\n+\t(get_float_string): Renamed from write_float, uses FORMAT_FLOAT macro.\n+\tBuffer allocation removed, now at higher level.\n+\n 2016-05-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/71123"}, {"sha": "db27f2dc39f786165f67d21e49d0b5d8be99d7b2", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 218, "deletions": 56, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b0e27a724e8ddc12065fa1d0848ae7c2495290e/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b0e27a724e8ddc12065fa1d0848ae7c2495290e/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=5b0e27a724e8ddc12065fa1d0848ae7c2495290e", "patch": "@@ -1101,42 +1101,6 @@ write_z (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n     }\n }\n \n-\n-void\n-write_d (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n-{\n-  write_float (dtp, f, p, len, 0);\n-}\n-\n-\n-void\n-write_e (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n-{\n-  write_float (dtp, f, p, len, 0);\n-}\n-\n-\n-void\n-write_f (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n-{\n-  write_float (dtp, f, p, len, 0);\n-}\n-\n-\n-void\n-write_en (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n-{\n-  write_float (dtp, f, p, len, 0);\n-}\n-\n-\n-void\n-write_es (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n-{\n-  write_float (dtp, f, p, len, 0);\n-}\n-\n-\n /* Take care of the X/TR descriptor.  */\n \n void\n@@ -1380,6 +1344,119 @@ write_character (st_parameter_dt *dtp, const char *source, int kind, int length,\n     }\n }\n \n+/* Floating point helper functions.  */\n+\n+#define BUF_STACK_SZ 256\n+\n+static int\n+get_precision (st_parameter_dt *dtp, const fnode *f, const char *source, int kind)\n+{\n+  if (f->format != FMT_EN)\n+    return determine_precision (dtp, f, kind);\n+  else\n+    return determine_en_precision (dtp, f, source, kind);\n+}\n+\n+static char *\n+select_buffer (int precision, char *buf, size_t *size)\n+{\n+  char *result;\n+  *size = BUF_STACK_SZ / 2 + precision;\n+  if (*size > BUF_STACK_SZ)\n+     result = xmalloc (*size);\n+  else\n+     result = buf;\n+  return result;\n+}\n+\n+static char *\n+select_string (const fnode *f, char *buf, size_t *size)\n+{\n+  char *result;\n+  *size = f->u.real.w + 1;\n+  if (*size > BUF_STACK_SZ)\n+     result = xmalloc (*size);\n+  else\n+     result = buf;\n+  return result;\n+}\n+\n+static void\n+write_float_string (st_parameter_dt *dtp, char *fstr, size_t len)\n+{\n+  char *p = write_block (dtp, len);\n+  if (p == NULL)\n+    return;\n+\n+  if (unlikely (is_char4_unit (dtp)))\n+    {\n+      gfc_char4_t *p4 = (gfc_char4_t *) p;\n+      memcpy4 (p4, fstr, len);\n+      return;\n+    }\n+  memcpy (p, fstr, len);\n+}\n+\n+static void\n+write_float_0 (st_parameter_dt *dtp, const fnode *f, const char *source, int kind)\n+{\n+  char buf_stack[BUF_STACK_SZ];\n+  char str_buf[BUF_STACK_SZ];\n+  char *buffer, *result;\n+  size_t buf_size, res_len;\n+\n+  /* Precision for snprintf call.  */\n+  int precision = get_precision (dtp, f, source, kind);\n+  \n+  /* String buffer to hold final result.  */\n+  result = select_string (f, str_buf, &res_len);\n+  \n+  buffer = select_buffer (precision, buf_stack, &buf_size);\n+  \n+  get_float_string (dtp, f, source , kind, 0, buffer,\n+                           precision, buf_size, result, &res_len);\n+  write_float_string (dtp, result, res_len);\n+\n+  if (buf_size > BUF_STACK_SZ)\n+    free (buffer);\n+  if (res_len > BUF_STACK_SZ)\n+    free (result);\n+}\n+\n+void\n+write_d (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n+{\n+  write_float_0 (dtp, f, p, len);\n+}\n+\n+\n+void\n+write_e (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n+{\n+  write_float_0 (dtp, f, p, len);\n+}\n+\n+\n+void\n+write_f (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n+{\n+  write_float_0 (dtp, f, p, len);\n+}\n+\n+\n+void\n+write_en (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n+{\n+  write_float_0 (dtp, f, p, len);\n+}\n+\n+\n+void\n+write_es (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n+{\n+  write_float_0 (dtp, f, p, len);\n+}\n+\n \n /* Set an fnode to default format.  */\n \n@@ -1422,38 +1499,64 @@ set_fnode_default (st_parameter_dt *dtp, fnode *f, int length)\n     }\n }\n \n-/* Output a real number with default format.  To guarantee that a\n-   binary -> decimal -> binary roundtrip conversion recovers the\n-   original value, IEEE 754-2008 requires 9, 17, 21 and 36 significant\n-   digits for REAL kinds 4, 8, 10, and 16, respectively. Thus, we use\n-   1PG16.9E2 for REAL(4), 1PG25.17E3 for REAL(8), 1PG30.21E4 for\n-   REAL(10) and 1PG45.36E4 for REAL(16). The exception is that the\n+/* Output a real number with default format.\n+   To guarantee that a binary -> decimal -> binary roundtrip conversion\n+   recovers the original value, IEEE 754-2008 requires 9, 17, 21 and 36\n+   significant digits for REAL kinds 4, 8, 10, and 16, respectively.\n+   Thus, we use 1PG16.9E2 for REAL(4), 1PG25.17E3 for REAL(8), 1PG30.21E4\n+   for REAL(10) and 1PG45.36E4 for REAL(16). The exception is that the\n    Fortran standard requires outputting an extra digit when the scale\n    factor is 1 and when the magnitude of the value is such that E\n    editing is used. However, gfortran compensates for this, and thus\n    for list formatted the same number of significant digits is\n    generated both when using F and E editing.  */\n \n void\n-write_real (st_parameter_dt *dtp, const char *source, int length)\n+write_real (st_parameter_dt *dtp, const char *source, int kind)\n {\n   fnode f ;\n-  int org_scale = dtp->u.p.scale_factor;\n+  char buf_stack[BUF_STACK_SZ];\n+  char str_buf[BUF_STACK_SZ];\n+  char *buffer, *result;\n+  size_t buf_size, res_len;\n+  int orig_scale = dtp->u.p.scale_factor;\n   dtp->u.p.scale_factor = 1;\n-  set_fnode_default (dtp, &f, length);\n-  write_float (dtp, &f, source , length, 1);\n-  dtp->u.p.scale_factor = org_scale;\n+  set_fnode_default (dtp, &f, kind);\n+\n+  /* Precision for snprintf call.  */\n+  int precision = get_precision (dtp, &f, source, kind);\n+  \n+  /* String buffer to hold final result.  */\n+  result = select_string (&f, str_buf, &res_len);\n+\n+  /* scratch buffer to hold final result.  */\n+  buffer = select_buffer (precision, buf_stack, &buf_size);\n+  \n+  get_float_string (dtp, &f, source , kind, 1, buffer,\n+                           precision, buf_size, result, &res_len);\n+  write_float_string (dtp, result, res_len);\n+\n+  dtp->u.p.scale_factor = orig_scale;\n+  if (buf_size > BUF_STACK_SZ)\n+    free (buffer);\n+  if (res_len > BUF_STACK_SZ)\n+    free (result);\n }\n \n /* Similar to list formatted REAL output, for kPG0 where k > 0 we\n    compensate for the extra digit.  */\n \n void\n-write_real_g0 (st_parameter_dt *dtp, const char *source, int length, int d)\n+write_real_g0 (st_parameter_dt *dtp, const char *source, int kind, int d)\n {\n   fnode f;\n+  char buf_stack[BUF_STACK_SZ];\n+  char str_buf[BUF_STACK_SZ];\n+  char *buffer, *result;\n+  size_t buf_size, res_len;\n   int comp_d; \n-  set_fnode_default (dtp, &f, length);\n+  set_fnode_default (dtp, &f, kind);\n+\n   if (d > 0)\n     f.u.real.d = d;\n \n@@ -1464,8 +1567,24 @@ write_real_g0 (st_parameter_dt *dtp, const char *source, int length, int d)\n   else\n     comp_d = 0;\n   dtp->u.p.g0_no_blanks = 1;\n-  write_float (dtp, &f, source , length, comp_d);\n+\n+  /* Precision for snprintf call.  */\n+  int precision = get_precision (dtp, &f, source, kind);\n+  \n+  /* String buffer to hold final result.  */\n+  result = select_string (&f, str_buf, &res_len);\n+\n+  buffer = select_buffer (precision, buf_stack, &buf_size);\n+\n+  get_float_string (dtp, &f, source , kind, comp_d, buffer,\n+                           precision, buf_size, result, &res_len);\n+  write_float_string (dtp, result, res_len);\n+\n   dtp->u.p.g0_no_blanks = 0;\n+  if (buf_size > BUF_STACK_SZ)\n+    free (buffer);\n+  if (res_len > BUF_STACK_SZ)\n+    free (result);\n }\n \n \n@@ -1475,15 +1594,58 @@ write_complex (st_parameter_dt *dtp, const char *source, int kind, size_t size)\n   char semi_comma =\n \tdtp->u.p.current_unit->decimal_status == DECIMAL_POINT ? ',' : ';';\n \n-  if (write_char (dtp, '('))\n-    return;\n-  write_real (dtp, source, kind);\n+  /* Set for no blanks so we get a string result with no leading\n+     blanks.  We will pad left later.  */\n+  dtp->u.p.g0_no_blanks = 1;\n \n-  if (write_char (dtp, semi_comma))\n-    return;\n-  write_real (dtp, source + size / 2, kind);\n+  fnode f ;\n+  char buf_stack[BUF_STACK_SZ];\n+  char str1_buf[BUF_STACK_SZ];\n+  char str2_buf[BUF_STACK_SZ];\n+  char *buffer, *result1, *result2;\n+  size_t buf_size, res_len1, res_len2;\n+  int width, lblanks, orig_scale = dtp->u.p.scale_factor;\n \n+  dtp->u.p.scale_factor = 1;\n+  set_fnode_default (dtp, &f, kind);\n+  \n+  /* Set width for two values, parenthesis, and comma.  */\n+  width = 2 * f.u.real.w + 3;\n+\n+  /* Set for no blanks so we get a string result with no leading\n+     blanks.  We will pad left later.  */\n+  dtp->u.p.g0_no_blanks = 1;\n+  \n+  /* Precision for snprintf call.  */\n+  int precision = get_precision (dtp, &f, source, kind);\n+  \n+  /* String buffers to hold final result.  */\n+  result1 = select_string (&f, str1_buf, &res_len1);\n+  result2 = select_string (&f, str2_buf, &res_len2);\n+\n+  buffer = select_buffer (precision, buf_stack, &buf_size);\n+  \n+  get_float_string (dtp, &f, source , kind, 0, buffer,\n+                           precision, buf_size, result1, &res_len1);\n+  get_float_string (dtp, &f, source + size / 2 , kind, 0, buffer,\n+                           precision, buf_size, result2, &res_len2);\n+  lblanks = width - res_len1 - res_len2 - 3;\n+  \n+  write_x (dtp, lblanks, lblanks);\n+  write_char (dtp, '(');\n+  write_float_string (dtp, result1, res_len1);\n+  write_char (dtp, semi_comma);\n+  write_float_string (dtp, result2, res_len2);\n   write_char (dtp, ')');\n+  \n+  dtp->u.p.scale_factor = orig_scale;\n+  dtp->u.p.g0_no_blanks = 0;\n+  if (buf_size > BUF_STACK_SZ)\n+    free (buffer);\n+  if (res_len1 > BUF_STACK_SZ)\n+    free (result1);\n+  if (res_len2 > BUF_STACK_SZ)\n+    free (result2);\n }\n \n "}, {"sha": "04223c043a345f67e49d6b31fc5d39c41d689a6e", "filename": "libgfortran/io/write_float.def", "status": "modified", "additions": 208, "deletions": 428, "changes": 636, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b0e27a724e8ddc12065fa1d0848ae7c2495290e/libgfortran%2Fio%2Fwrite_float.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b0e27a724e8ddc12065fa1d0848ae7c2495290e/libgfortran%2Fio%2Fwrite_float.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite_float.def?ref=5b0e27a724e8ddc12065fa1d0848ae7c2495290e", "patch": "@@ -108,13 +108,14 @@ determine_precision (st_parameter_dt * dtp, const fnode * f, int len)\n }\n \n \n-/* Output a real number according to its format which is FMT_G free.  */\n+/* Build a real number according to its format which is FMT_G free.  */\n \n-static bool\n-output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n-\t      int nprinted, int precision, int sign_bit, bool zero_flag)\n+static void\n+build_float_string (st_parameter_dt *dtp, const fnode *f, char *buffer,\n+\t\t    size_t size, int nprinted, int precision, int sign_bit,\n+\t\t    bool zero_flag, int npad, char *result, size_t *len)\n {\n-  char *out;\n+  char *put;\n   char *digits;\n   int e, w, d, p, i;\n   char expchar, rchar;\n@@ -180,7 +181,6 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n \t{\n \t  if (p > 0)\n \t    {\n-\t      \n \t      memmove (digits + nbefore, digits + nbefore + 1, p);\n \t      digits[nbefore + p] = '.';\n \t      nbefore += p;\n@@ -252,13 +252,13 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n \t{\n \t  generate_error (&dtp->common, LIBERROR_FORMAT, \"Precision not \"\n \t\t\t  \"greater than zero in format specifier 'E' or 'D'\");\n-\t  return false;\n+\t  return;\n \t}\n       if (p <= -d || p >= d + 2)\n \t{\n \t  generate_error (&dtp->common, LIBERROR_FORMAT, \"Scale factor \"\n \t\t\t  \"out of range in format specifier 'E' or 'D'\");\n-\t  return false;\n+\t  return;\n \t}\n \n       if (!zero_flag)\n@@ -547,223 +547,127 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n       nblanks = 0;\n     }\n \n-  /* Create the ouput buffer.  */\n-  out = write_block (dtp, w);\n-  if (out == NULL)\n-    return false;\n+  /* Create the final float string.  */\n+  *len = w + npad;\n+  put = result;\n \n   /* Check the value fits in the specified field width.  */\n   if (nblanks < 0 || edigits == -1 || w == 1 || (w == 2 && sign != S_NONE))\n     {\n-      if (unlikely (is_char4_unit (dtp)))\n-\t{\n-\t  gfc_char4_t *out4 = (gfc_char4_t *) out;\n-\t  memset4 (out4, '*', w);\n-\t  return false;\n-\t}\n-      star_fill (out, w);\n-      return false;\n+      star_fill (put, *len);\n+      return;\n     }\n \n-  /* For internal character(kind=4) units, we duplicate the code used for\n-     regular output slightly modified.  This needs to be maintained\n-     consistent with the regular code that follows this block.  */\n-  if (unlikely (is_char4_unit (dtp)))\n-    {\n-      gfc_char4_t *out4 = (gfc_char4_t *) out;\n-      /* Pad to full field width.  */\n-\n-      if ( ( nblanks > 0 ) && !dtp->u.p.no_leading_blank)\n-\t{\n-\t  memset4 (out4, ' ', nblanks);\n-\t  out4 += nblanks;\n-\t}\n-\n-      /* Output the initial sign (if any).  */\n-      if (sign == S_PLUS)\n-\t*(out4++) = '+';\n-      else if (sign == S_MINUS)\n-\t*(out4++) = '-';\n-\n-      /* Output an optional leading zero.  */\n-      if (leadzero)\n-\t*(out4++) = '0';\n-\n-      /* Output the part before the decimal point, padding with zeros.  */\n-      if (nbefore > 0)\n-\t{\n-\t  if (nbefore > ndigits)\n-\t    {\n-\t      i = ndigits;\n-\t      memcpy4 (out4, digits, i);\n-\t      ndigits = 0;\n-\t      while (i < nbefore)\n-\t\tout4[i++] = '0';\n-\t    }\n-\t  else\n-\t    {\n-\t      i = nbefore;\n-\t      memcpy4 (out4, digits, i);\n-\t      ndigits -= i;\n-\t    }\n-\n-\t  digits += i;\n-\t  out4 += nbefore;\n-\t}\n-\n-      /* Output the decimal point.  */\n-      *(out4++) = dtp->u.p.current_unit->decimal_status\n-\t\t    == DECIMAL_POINT ? '.' : ',';\n-      if (ft == FMT_F \n-\t  && (dtp->u.p.current_unit->round_status == ROUND_UNSPECIFIED \n-\t      || dtp->u.p.current_unit->round_status == ROUND_PROCDEFINED))\n-\tdigits++;\n-\n-      /* Output leading zeros after the decimal point.  */\n-      if (nzero > 0)\n-\t{\n-\t  for (i = 0; i < nzero; i++)\n-\t    *(out4++) = '0';\n-\t}\n-\n-      /* Output digits after the decimal point, padding with zeros.  */\n-      if (nafter > 0)\n-\t{\n-\t  if (nafter > ndigits)\n-\t    i = ndigits;\n-\t  else\n-\t    i = nafter;\n-\n-\t  memcpy4 (out4, digits, i);\n-\t  while (i < nafter)\n-\t    out4[i++] = '0';\n-\n-\t  digits += i;\n-\t  ndigits -= i;\n-\t  out4 += nafter;\n-\t}\n-\n-      /* Output the exponent.  */\n-      if (expchar && !(dtp->u.p.g0_no_blanks && e == 0))\n-\t{\n-\t  if (expchar != ' ')\n-\t    {\n-\t      *(out4++) = expchar;\n-\t      edigits--;\n-\t    }\n-\t  snprintf (buffer, size, \"%+0*d\", edigits, e);\n-\t  memcpy4 (out4, buffer, edigits);\n-\t}\n-\n-      if (dtp->u.p.no_leading_blank)\n-\t{\n-\t  out4 += edigits;\n-\t  memset4 (out4, ' ' , nblanks);\n-\t  dtp->u.p.no_leading_blank = 0;\n-\t}\n-      return true;\n-    } /* End of character(kind=4) internal unit code.  */\n-\n   /* Pad to full field width.  */\n-\n   if ( ( nblanks > 0 ) && !dtp->u.p.no_leading_blank)\n     {\n-      memset (out, ' ', nblanks);\n-      out += nblanks;\n+      memset (put, ' ', nblanks);\n+      put += nblanks;\n     }\n \n-  /* Output the initial sign (if any).  */\n+  /* Set the initial sign (if any).  */\n   if (sign == S_PLUS)\n-    *(out++) = '+';\n+    *(put++) = '+';\n   else if (sign == S_MINUS)\n-    *(out++) = '-';\n+    *(put++) = '-';\n \n-  /* Output an optional leading zero.  */\n+  /* Set an optional leading zero.  */\n   if (leadzero)\n-    *(out++) = '0';\n+    *(put++) = '0';\n \n-  /* Output the part before the decimal point, padding with zeros.  */\n+  /* Set the part before the decimal point, padding with zeros.  */\n   if (nbefore > 0)\n     {\n       if (nbefore > ndigits)\n \t{\n \t  i = ndigits;\n-\t  memcpy (out, digits, i);\n+\t  memcpy (put, digits, i);\n \t  ndigits = 0;\n \t  while (i < nbefore)\n-\t    out[i++] = '0';\n+\t    put[i++] = '0';\n \t}\n       else\n \t{\n \t  i = nbefore;\n-\t  memcpy (out, digits, i);\n+\t  memcpy (put, digits, i);\n \t  ndigits -= i;\n \t}\n \n       digits += i;\n-      out += nbefore;\n+      put += nbefore;\n     }\n \n-  /* Output the decimal point.  */\n-  *(out++) = dtp->u.p.current_unit->decimal_status == DECIMAL_POINT ? '.' : ',';\n+  /* Set the decimal point.  */\n+  *(put++) = dtp->u.p.current_unit->decimal_status == DECIMAL_POINT ? '.' : ',';\n   if (ft == FMT_F\n \t  && (dtp->u.p.current_unit->round_status == ROUND_UNSPECIFIED \n \t      || dtp->u.p.current_unit->round_status == ROUND_PROCDEFINED))\n     digits++;\n \n-  /* Output leading zeros after the decimal point.  */\n+  /* Set leading zeros after the decimal point.  */\n   if (nzero > 0)\n     {\n       for (i = 0; i < nzero; i++)\n-\t*(out++) = '0';\n+\t*(put++) = '0';\n     }\n \n-  /* Output digits after the decimal point, padding with zeros.  */\n+  /* Set digits after the decimal point, padding with zeros.  */\n   if (nafter > 0)\n     {\n       if (nafter > ndigits)\n \ti = ndigits;\n       else\n \ti = nafter;\n \n-      memcpy (out, digits, i);\n+      memcpy (put, digits, i);\n       while (i < nafter)\n-\tout[i++] = '0';\n+\tput[i++] = '0';\n \n       digits += i;\n       ndigits -= i;\n-      out += nafter;\n+      put += nafter;\n     }\n \n-  /* Output the exponent.  */\n+  /* Set the exponent.  */\n   if (expchar && !(dtp->u.p.g0_no_blanks && e == 0))\n     {\n       if (expchar != ' ')\n \t{\n-\t  *(out++) = expchar;\n+\t  *(put++) = expchar;\n \t  edigits--;\n \t}\n       snprintf (buffer, size, \"%+0*d\", edigits, e);\n-      memcpy (out, buffer, edigits);\n+      memcpy (put, buffer, edigits);\n+      put += edigits;\n     }\n \n   if (dtp->u.p.no_leading_blank)\n     {\n-      out += edigits;\n-      memset( out , ' ' , nblanks );\n+      memset (put , ' ' , nblanks);\n       dtp->u.p.no_leading_blank = 0;\n+      put += nblanks;\n+    }\n+\n+  if (npad > 0 && !dtp->u.p.g0_no_blanks)\n+    {\n+      memset (put , ' ' , npad);\n+      put += npad;\n     }\n \n-  return true;\n+  /* NULL terminate the string.  */\n+  *put = '\\0';\n+  \n+  return;\n }\n \n \n /* Write \"Infinite\" or \"Nan\" as appropriate for the given format.  */\n \n static void\n-write_infnan (st_parameter_dt *dtp, const fnode *f, int isnan_flag, int sign_bit)\n+build_infnan_string (st_parameter_dt *dtp, const fnode *f, int isnan_flag,\n+\t\t    int sign_bit, char *p, size_t *len)\n {\n-  char * p, fin;\n+  char fin;\n   int nb = 0;\n   sign_t sign;\n   int mark;\n@@ -774,6 +678,7 @@ write_infnan (st_parameter_dt *dtp, const fnode *f, int isnan_flag, int sign_bit\n       mark = (sign == S_PLUS || sign == S_MINUS) ? 8 : 7;\n \n       nb =  f->u.real.w;\n+      *len = nb;\n \n       /* If the field width is zero, the processor must select a width \n \t not zero.  4 is chosen to allow output of '-Inf' or '+Inf' */\n@@ -784,29 +689,17 @@ write_infnan (st_parameter_dt *dtp, const fnode *f, int isnan_flag, int sign_bit\n \t    nb = 3;\n \t  else\n \t    nb = (sign == S_PLUS || sign == S_MINUS) ? 4 : 3;\n+\t  *len = nb;\n \t}\n-      p = write_block (dtp, nb);\n-      if (p == NULL)\n-\treturn;\n+\n+      p[*len] = '\\0';\n       if (nb < 3)\n \t{\n-\t  if (unlikely (is_char4_unit (dtp)))\n-\t    {\n-\t      gfc_char4_t *p4 = (gfc_char4_t *) p;\n-\t      memset4 (p4, '*', nb);\n-\t    }\n-\t  else\n-\t    memset (p, '*', nb);\n+\t  memset (p, '*', nb);\n \t  return;\n \t}\n \n-      if (unlikely (is_char4_unit (dtp)))\n-\t{\n-\t  gfc_char4_t *p4 = (gfc_char4_t *) p;\n-\t  memset4 (p4, ' ', nb);\n-\t}\n-      else\n-\tmemset(p, ' ', nb);\n+      memset(p, ' ', nb);\n \n       if (!isnan_flag)\n \t{\n@@ -816,13 +709,7 @@ write_infnan (st_parameter_dt *dtp, const fnode *f, int isnan_flag, int sign_bit\n \t\t insufficient room to output '-Inf', so output asterisks */\n \t      if (nb == 3)\n \t\t{\n-\t\t  if (unlikely (is_char4_unit (dtp)))\n-\t\t    {\n-\t\t      gfc_char4_t *p4 = (gfc_char4_t *) p;\n-\t\t      memset4 (p4, '*', nb);\n-\t\t    }\n-\t\t  else\n-\t\t    memset (p, '*', nb);\n+\t\t  memset (p, '*', nb);\n \t\t  return;\n \t\t}\n \t      /* The negative sign is mandatory */\n@@ -833,30 +720,6 @@ write_infnan (st_parameter_dt *dtp, const fnode *f, int isnan_flag, int sign_bit\n \t       consistency */\n \t    fin = '+';\n \t    \n-\t  if (unlikely (is_char4_unit (dtp)))\n-\t    {\n-\t      gfc_char4_t *p4 = (gfc_char4_t *) p;\n-\n-\t      if (nb > mark)\n-\t\t/* We have room, so output 'Infinity' */\n-\t\tmemcpy4 (p4 + nb - 8, \"Infinity\", 8);\n-\t      else\n-\t\t/* For the case of width equals mark, there is not enough room\n-\t\t   for the sign and 'Infinity' so we go with 'Inf' */\n-\t\tmemcpy4 (p4 + nb - 3, \"Inf\", 3);\n-\n-\t      if (sign == S_PLUS || sign == S_MINUS)\n-\t\t{\n-\t\t  if (nb < 9 && nb > 3)\n-\t\t    /* Put the sign in front of Inf */\n-\t\t    p4[nb - 4] = (gfc_char4_t) fin;\n-\t\t  else if (nb > 8)\n-\t\t    /* Put the sign in front of Infinity */\n-\t\t    p4[nb - 9] = (gfc_char4_t) fin;\n-\t\t}\n-\t      return;\n-\t    }\n-\n \t  if (nb > mark)\n \t    /* We have room, so output 'Infinity' */\n \t    memcpy(p + nb - 8, \"Infinity\", 8);\n@@ -874,16 +737,7 @@ write_infnan (st_parameter_dt *dtp, const fnode *f, int isnan_flag, int sign_bit\n \t    }\n \t}\n       else\n-        {\n-\t  if (unlikely (is_char4_unit (dtp)))\n-\t    {\n-\t      gfc_char4_t *p4 = (gfc_char4_t *) p;\n-\t      memcpy4 (p4 + nb - 3, \"NaN\", 3);\n-\t    }\n-\t  else\n-\t    memcpy(p + nb - 3, \"NaN\", 3);\n-\t}\n-      return;\n+\tmemcpy(p + nb - 3, \"NaN\", 3);\n     }\n }\n \n@@ -916,7 +770,7 @@ CALCULATE_EXP(16)\n #undef CALCULATE_EXP\n \n \n-/* Define a macro to build code for write_float.  */\n+/* Define macros to build code for format_float.  */\n \n   /* Note: Before output_float is called, snprintf is used to print to buffer the\n      number in the format +D.DDDDe+ddd. \n@@ -941,196 +795,35 @@ CALCULATE_EXP(16)\n \n #define DTOA(suff,prec,val) TOKENPASTE(DTOA2,suff)(prec,val)\n \n-#define DTOA2(prec,val)\t\t\t\t\t\\\n+#define DTOA2(prec,val) \\\n snprintf (buffer, size, \"%+-#.*e\", (prec), (val))\n \n-#define DTOA2L(prec,val)\t\t\t\t\\\n+#define DTOA2L(prec,val) \\\n snprintf (buffer, size, \"%+-#.*Le\", (prec), (val))\n \n \n #if defined(GFC_REAL_16_IS_FLOAT128)\n-#define DTOA2Q(prec,val)\t\t\t\t\t\t\t\\\n+#define DTOA2Q(prec,val) \\\n quadmath_snprintf (buffer, size, \"%+-#.*Qe\", (prec), (val))\n #endif\n \n #define FDTOA(suff,prec,val) TOKENPASTE(FDTOA2,suff)(prec,val)\n \n /* For F format, we print to the buffer with f format.  */\n-#define FDTOA2(prec,val)\t\t\t\t\t\t\t\\\n+#define FDTOA2(prec,val) \\\n snprintf (buffer, size, \"%+-#.*f\", (prec), (val))\n \n-#define FDTOA2L(prec,val)\t\t\t\t\t\t\\\n+#define FDTOA2L(prec,val) \\\n snprintf (buffer, size, \"%+-#.*Lf\", (prec), (val))\n \n \n #if defined(GFC_REAL_16_IS_FLOAT128)\n-#define FDTOA2Q(prec,val)\t\t\t       \\\n+#define FDTOA2Q(prec,val) \\\n quadmath_snprintf (buffer, size, \"%+-#.*Qf\", \\\n \t\t\t     (prec), (val))\n #endif\n \n \n-\n-/* Generate corresponding I/O format for FMT_G and output.\n-   The rules to translate FMT_G to FMT_E or FMT_F from DEC fortran\n-   LRM (table 11-2, Chapter 11, \"I/O Formatting\", P11-25) is:\n-\n-   Data Magnitude                              Equivalent Conversion\n-   0< m < 0.1-0.5*10**(-d-1)                   Ew.d[Ee]\n-   m = 0                                       F(w-n).(d-1), n' '\n-   0.1-0.5*10**(-d-1)<= m < 1-0.5*10**(-d)     F(w-n).d, n' '\n-   1-0.5*10**(-d)<= m < 10-0.5*10**(-d+1)      F(w-n).(d-1), n' '\n-   10-0.5*10**(-d+1)<= m < 100-0.5*10**(-d+2)  F(w-n).(d-2), n' '\n-   ................                           ..........\n-   10**(d-1)-0.5*10**(-1)<= m <10**d-0.5       F(w-n).0,n(' ')\n-   m >= 10**d-0.5                              Ew.d[Ee]\n-\n-   notes: for Gw.d ,  n' ' means 4 blanks\n-\t  for Gw.dEe, n' ' means e+2 blanks\n-\t  for rounding modes adjustment, r, See Fortran F2008 10.7.5.2.2\n-\t  the asm volatile is required for 32-bit x86 platforms.  */\n-\n-#define OUTPUT_FLOAT_FMT_G(x,y)\t\t\t\\\n-static void \\\n-output_float_FMT_G_ ## x (st_parameter_dt *dtp, const fnode *f, \\\n-\t\t      GFC_REAL_ ## x m, char *buffer, size_t size, \\\n-\t\t\t  int sign_bit, bool zero_flag, int comp_d) \\\n-{ \\\n-  int e = f->u.real.e;\\\n-  int d = f->u.real.d;\\\n-  int w = f->u.real.w;\\\n-  fnode newf;\\\n-  GFC_REAL_ ## x exp_d, r = 0.5, r_sc;\\\n-  int low, high, mid;\\\n-  int ubound, lbound;\\\n-  char *p, pad = ' ';\\\n-  int save_scale_factor, nb = 0;\\\n-  bool result;\\\n-  int nprinted, precision;\\\n-  volatile GFC_REAL_ ## x temp;\\\n-\\\n-  save_scale_factor = dtp->u.p.scale_factor;\\\n-\\\n-  switch (dtp->u.p.current_unit->round_status)\\\n-    {\\\n-      case ROUND_ZERO:\\\n-\tr = sign_bit ? 1.0 : 0.0;\\\n-\tbreak;\\\n-      case ROUND_UP:\\\n-\tr = 1.0;\\\n-\tbreak;\\\n-      case ROUND_DOWN:\\\n-\tr = 0.0;\\\n-\tbreak;\\\n-      default:\\\n-\tbreak;\\\n-    }\\\n-\\\n-  exp_d = calculate_exp_ ## x (d);\\\n-  r_sc = (1 - r / exp_d);\\\n-  temp = 0.1 * r_sc;\\\n-  if ((m > 0.0 && ((m < temp) || (r >= (exp_d - m))))\\\n-      || ((m == 0.0) && !(compile_options.allow_std\\\n-\t\t\t  & (GFC_STD_F2003 | GFC_STD_F2008)))\\\n-      ||  d == 0)\\\n-    { \\\n-      newf.format = FMT_E;\\\n-      newf.u.real.w = w;\\\n-      newf.u.real.d = d - comp_d;\\\n-      newf.u.real.e = e;\\\n-      nb = 0;\\\n-      precision = determine_precision (dtp, &newf, x);\\\n-      nprinted = DTOA(y,precision,m);\t\t\t     \\\n-      goto finish;\\\n-    }\\\n-\\\n-  mid = 0;\\\n-  low = 0;\\\n-  high = d + 1;\\\n-  lbound = 0;\\\n-  ubound = d + 1;\\\n-\\\n-  while (low <= high)\\\n-    { \\\n-      mid = (low + high) / 2;\\\n-\\\n-      temp = (calculate_exp_ ## x (mid - 1) * r_sc);\\\n-\\\n-      if (m < temp)\\\n-        { \\\n-          ubound = mid;\\\n-          if (ubound == lbound + 1)\\\n-            break;\\\n-          high = mid - 1;\\\n-        }\\\n-      else if (m > temp)\\\n-        { \\\n-          lbound = mid;\\\n-          if (ubound == lbound + 1)\\\n-            { \\\n-              mid ++;\\\n-              break;\\\n-            }\\\n-          low = mid + 1;\\\n-        }\\\n-      else\\\n-\t{\\\n-\t  mid++;\\\n-\t  break;\\\n-\t}\\\n-    }\\\n-\\\n-  nb = e <= 0 ? 4 : e + 2;\\\n-  nb = nb >= w ? w - 1 : nb;\\\n-  newf.format = FMT_F;\\\n-  newf.u.real.w = w - nb;\\\n-  newf.u.real.d = m == 0.0 ? d - 1 : -(mid - d - 1) ;\\\n-  dtp->u.p.scale_factor = 0;\\\n-  precision = determine_precision (dtp, &newf, x);\t\\\n-  nprinted = FDTOA(y,precision,m);\t\t\t\t\t\\\n-\\\n- finish:\\\n-    result = output_float (dtp, &newf, buffer, size, nprinted, precision,\\\n-\t\t\t   sign_bit, zero_flag);\\\n-  dtp->u.p.scale_factor = save_scale_factor;\\\n-\\\n-\\\n-  if (nb > 0 && !dtp->u.p.g0_no_blanks)\\\n-    {\\\n-      p = write_block (dtp, nb);\\\n-      if (p == NULL)\\\n-\treturn;\\\n-      if (!result)\\\n-        pad = '*';\\\n-      if (unlikely (is_char4_unit (dtp)))\\\n-\t{\\\n-\t  gfc_char4_t *p4 = (gfc_char4_t *) p;\\\n-\t  memset4 (p4, pad, nb);\\\n-\t}\\\n-      else \\\n-\tmemset (p, pad, nb);\\\n-    }\\\n-}\\\n-\n-OUTPUT_FLOAT_FMT_G(4,)\n-\n-OUTPUT_FLOAT_FMT_G(8,)\n-\n-#ifdef HAVE_GFC_REAL_10\n-OUTPUT_FLOAT_FMT_G(10,L)\n-#endif\n-\n-#ifdef HAVE_GFC_REAL_16\n-# ifdef GFC_REAL_16_IS_FLOAT128\n-OUTPUT_FLOAT_FMT_G(16,Q)\n-#else\n-OUTPUT_FLOAT_FMT_G(16,L)\n-#endif\n-#endif\n-\n-#undef OUTPUT_FLOAT_FMT_G\n-\n-\n /* EN format is tricky since the number of significant digits depends\n    on the magnitude.  Solve it by first printing a temporary value and\n    figure out the number of significant digits from the printed\n@@ -1144,7 +837,6 @@ OUTPUT_FLOAT_FMT_G(16,L)\n    are correctly rounded respectively to 1.0...0*10.0*(3*(n+1)),\n    100.0...0*10.0*(3*n), and 10.0...0*10.0*(3*n), where 0...0\n    represents d zeroes, by the lines 279 to 297. */\n-\n #define EN_PREC(x,y)\\\n {\\\n     volatile GFC_REAL_ ## x tmp, one = 1.0;\\\n@@ -1156,7 +848,7 @@ OUTPUT_FLOAT_FMT_G(16,L)\n \tif (buffer[1] == '1')\\\n \t  {\\\n \t    tmp = (calculate_exp_ ## x (-e)) * tmp;\\\n-\t    tmp = one - (tmp < 0 ? -tmp : tmp);\t\\\n+\t    tmp = one - (tmp < 0 ? -tmp : tmp);\\\n \t    if (tmp > 0)\\\n \t      e = e - 1;\\\n \t  }\\\n@@ -1216,87 +908,175 @@ determine_en_precision (st_parameter_dt *dtp, const fnode *f,\n }\n   \n \n-#define WRITE_FLOAT(x,y)\\\n+/* Generate corresponding I/O format. and output.\n+   The rules to translate FMT_G to FMT_E or FMT_F from DEC fortran\n+   LRM (table 11-2, Chapter 11, \"I/O Formatting\", P11-25) is:\n+\n+   Data Magnitude                              Equivalent Conversion\n+   0< m < 0.1-0.5*10**(-d-1)                   Ew.d[Ee]\n+   m = 0                                       F(w-n).(d-1), n' '\n+   0.1-0.5*10**(-d-1)<= m < 1-0.5*10**(-d)     F(w-n).d, n' '\n+   1-0.5*10**(-d)<= m < 10-0.5*10**(-d+1)      F(w-n).(d-1), n' '\n+   10-0.5*10**(-d+1)<= m < 100-0.5*10**(-d+2)  F(w-n).(d-2), n' '\n+   ................                           ..........\n+   10**(d-1)-0.5*10**(-1)<= m <10**d-0.5       F(w-n).0,n(' ')\n+   m >= 10**d-0.5                              Ew.d[Ee]\n+\n+   notes: for Gw.d ,  n' ' means 4 blanks\n+\t  for Gw.dEe, n' ' means e+2 blanks\n+\t  for rounding modes adjustment, r, See Fortran F2008 10.7.5.2.2\n+\t  the asm volatile is required for 32-bit x86 platforms.  */\n+#define FORMAT_FLOAT(x,y)\\\n {\\\n-\tGFC_REAL_ ## x tmp;\\\n-\ttmp = * (GFC_REAL_ ## x *)source;\\\n-\tsign_bit = signbit (tmp);\\\n-\tif (!isfinite (tmp))\\\n-\t  { \\\n-\t    write_infnan (dtp, f, isnan (tmp), sign_bit);\\\n-\t    return;\\\n-\t  }\\\n-\ttmp = sign_bit ? -tmp : tmp;\\\n-\tzero_flag = (tmp == 0.0);\\\n-\tif (f->format == FMT_G)\\\n-\t  output_float_FMT_G_ ## x (dtp, f, tmp, buffer, size, sign_bit, \\\n-\t\t\t\t    zero_flag, comp_d);\\\n-\telse\\\n-\t  {\\\n-\t    if (f->format == FMT_F)\\\n-\t      nprinted = FDTOA(y,precision,tmp);\t\t\\\n-\t    else\\\n-\t      nprinted = DTOA(y,precision,tmp);\t\t\t\t\t\\\n-\t    output_float (dtp, f, buffer, size, nprinted, precision,\\\n-\t\t\t  sign_bit, zero_flag);\\\n-\t  }\\\n+  int npad = 0;\\\n+  GFC_REAL_ ## x m;\\\n+  m = * (GFC_REAL_ ## x *)source;\\\n+  sign_bit = signbit (m);\\\n+  if (!isfinite (m))\\\n+    { \\\n+      build_infnan_string (dtp, f, isnan (m), sign_bit, result, res_len);\\\n+      return;\\\n+    }\\\n+  m = sign_bit ? -m : m;\\\n+  zero_flag = (m == 0.0);\\\n+  if (f->format == FMT_G)\\\n+    {\\\n+      int e = f->u.real.e;\\\n+      int d = f->u.real.d;\\\n+      int w = f->u.real.w;\\\n+      fnode newf;\\\n+      GFC_REAL_ ## x exp_d, r = 0.5, r_sc;\\\n+      int low, high, mid;\\\n+      int ubound, lbound;\\\n+      int save_scale_factor;\\\n+      volatile GFC_REAL_ ## x temp;\\\n+      save_scale_factor = dtp->u.p.scale_factor;\\\n+      switch (dtp->u.p.current_unit->round_status)\\\n+\t{\\\n+\t  case ROUND_ZERO:\\\n+\t    r = sign_bit ? 1.0 : 0.0;\\\n+\t    break;\\\n+\t  case ROUND_UP:\\\n+\t    r = 1.0;\\\n+\t    break;\\\n+\t  case ROUND_DOWN:\\\n+\t    r = 0.0;\\\n+\t    break;\\\n+\t  default:\\\n+\t    break;\\\n+\t}\\\n+      exp_d = calculate_exp_ ## x (d);\\\n+      r_sc = (1 - r / exp_d);\\\n+      temp = 0.1 * r_sc;\\\n+      if ((m > 0.0 && ((m < temp) || (r >= (exp_d - m))))\\\n+\t  || ((m == 0.0) && !(compile_options.allow_std\\\n+\t\t\t      & (GFC_STD_F2003 | GFC_STD_F2008)))\\\n+\t  ||  d == 0)\\\n+\t{ \\\n+\t  newf.format = FMT_E;\\\n+\t  newf.u.real.w = w;\\\n+\t  newf.u.real.d = d - comp_d;\\\n+\t  newf.u.real.e = e;\\\n+\t  npad = 0;\\\n+\t  precision = determine_precision (dtp, &newf, x);\\\n+\t  nprinted = DTOA(y,precision,m);\\\n+\t}\\\n+      else \\\n+\t{\\\n+\t  mid = 0;\\\n+\t  low = 0;\\\n+\t  high = d + 1;\\\n+\t  lbound = 0;\\\n+\t  ubound = d + 1;\\\n+\t  while (low <= high)\\\n+\t    {\\\n+\t      mid = (low + high) / 2;\\\n+\t      temp = (calculate_exp_ ## x (mid - 1) * r_sc);\\\n+\t      if (m < temp)\\\n+\t\t{ \\\n+\t\t  ubound = mid;\\\n+\t\t  if (ubound == lbound + 1)\\\n+\t\t    break;\\\n+\t\t  high = mid - 1;\\\n+\t\t}\\\n+\t      else if (m > temp)\\\n+\t\t{ \\\n+\t\t  lbound = mid;\\\n+\t\t  if (ubound == lbound + 1)\\\n+\t\t    { \\\n+\t\t      mid ++;\\\n+\t\t      break;\\\n+\t\t    }\\\n+\t\t  low = mid + 1;\\\n+\t\t}\\\n+\t      else\\\n+\t\t{\\\n+\t\t  mid++;\\\n+\t\t  break;\\\n+\t\t}\\\n+\t    }\\\n+\t  npad = e <= 0 ? 4 : e + 2;\\\n+\t  npad = npad >= w ? w - 1 : npad;\\\n+\t  npad = dtp->u.p.g0_no_blanks ? 0 : npad;\\\n+\t  newf.format = FMT_F;\\\n+\t  newf.u.real.w = w - npad;\\\n+\t  newf.u.real.d = m == 0.0 ? d - 1 : -(mid - d - 1) ;\\\n+\t  dtp->u.p.scale_factor = 0;\\\n+\t  precision = determine_precision (dtp, &newf, x);\\\n+\t  nprinted = FDTOA(y,precision,m);\\\n+\t}\\\n+      build_float_string (dtp, &newf, buffer, size, nprinted, precision,\\\n+\t\t\t\t   sign_bit, zero_flag, npad, result, res_len);\\\n+      dtp->u.p.scale_factor = save_scale_factor;\\\n+    }\\\n+  else\\\n+    {\\\n+      if (f->format == FMT_F)\\\n+\tnprinted = FDTOA(y,precision,m);\\\n+      else\\\n+\tnprinted = DTOA(y,precision,m);\\\n+      build_float_string (dtp, f, buffer, size, nprinted, precision,\\\n+\t\t\t\t   sign_bit, zero_flag, npad, result, res_len);\\\n+    }\\\n }\\\n \n /* Output a real number according to its format.  */\n \n+\n static void\n-write_float (st_parameter_dt *dtp, const fnode *f, const char *source, \\\n-            int len, int comp_d)\n+get_float_string (st_parameter_dt *dtp, const fnode *f, const char *source,\n+\t\t  int kind, int comp_d, char *buffer, int precision,\n+\t\t  size_t size, char *result, size_t *res_len)\n {\n   int sign_bit, nprinted;\n-  int precision;  /* Precision for snprintf call.  */\n   bool zero_flag;\n \n-  if (f->format != FMT_EN)\n-    precision = determine_precision (dtp, f, len);\n-  else\n-    precision = determine_en_precision (dtp, f, source, len);\n-\n-  /* 4932 is the maximum exponent of long double and quad precision, 3\n-     extra characters for the sign, the decimal point, and the\n-     trailing null, and finally some extra digits depending on the\n-     requested precision.  */\n-  const size_t size = 4932 + 3 + precision;\n-#define BUF_STACK_SZ 5000\n-  char buf_stack[BUF_STACK_SZ];\n-  char *buffer;\n-  if (size > BUF_STACK_SZ)\n-     buffer = xmalloc (size);\n-  else\n-     buffer = buf_stack;\n-\n-  switch (len)\n+  switch (kind)\n     {\n     case 4:\n-      WRITE_FLOAT(4,)\n+      FORMAT_FLOAT(4,)\n       break;\n \n     case 8:\n-      WRITE_FLOAT(8,)\n+      FORMAT_FLOAT(8,)\n       break;\n \n #ifdef HAVE_GFC_REAL_10\n     case 10:\n-      WRITE_FLOAT(10,L)\n+      FORMAT_FLOAT(10,L)\n       break;\n #endif\n #ifdef HAVE_GFC_REAL_16\n     case 16:\n # ifdef GFC_REAL_16_IS_FLOAT128\n-      WRITE_FLOAT(16,Q)\n+      FORMAT_FLOAT(16,Q)\n # else\n-      WRITE_FLOAT(16,L)\n+      FORMAT_FLOAT(16,L)\n # endif\n       break;\n #endif\n     default:\n       internal_error (NULL, \"bad real kind\");\n     }\n-  if (size > BUF_STACK_SZ)\n-     free (buffer);\n+  return;\n }"}]}