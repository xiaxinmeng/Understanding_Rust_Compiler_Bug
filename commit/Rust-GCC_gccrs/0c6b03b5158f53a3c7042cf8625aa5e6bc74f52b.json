{"sha": "0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM2YjAzYjUxNThmNTNhM2M3MDQyY2Y4NjI1YWE1ZTZiYzc0ZjUyYg==", "commit": {"author": {"name": "Alexander Monakov", "email": "amonakov@ispras.ru", "date": "2017-03-28T17:24:57Z"}, "committer": {"name": "Alexander Monakov", "email": "amonakov@gcc.gnu.org", "date": "2017-03-28T17:24:57Z"}, "message": "OpenMP/PTX privatization in SIMD regions\n\n\t* config/nvptx/nvptx-protos.h (nvptx_output_simt_enter): Declare.\n\t(nvptx_output_simt_exit): Declare.\n\t* config/nvptx/nvptx.c (nvptx_init_unisimt_predicate): Use\n\tcfun->machine->unisimt_location.  Handle NULL unisimt_predicate.\n\t(init_softstack_frame): Move initialization of crtl->is_leaf to...\n\t(nvptx_declare_function_name): ...here.  Emit declaration of local\n\tmemory space buffer for omp_simt_enter insn.\n\t(nvptx_output_unisimt_switch): New.\n\t(nvptx_output_softstack_switch): New.\n\t(nvptx_output_simt_enter): New.\n\t(nvptx_output_simt_exit): New.\n\t* config/nvptx/nvptx.h (struct machine_function): New fields\n\thas_simtreg, unisimt_location, simt_stack_size, simt_stack_align.\n\t* config/nvptx/nvptx.md (UNSPECV_SIMT_ENTER): New unspec.\n\t(UNSPECV_SIMT_EXIT): Ditto.\n\t(omp_simt_enter_insn): New insn.\n\t(omp_simt_enter): New expansion.\n\t(omp_simt_exit): New insn.\n\t* config/nvptx/nvptx.opt (msoft-stack-reserve-local): New option.\n\n\t* internal-fn.c (expand_GOMP_SIMT_ENTER): New.\n\t(expand_GOMP_SIMT_ENTER_ALLOC): New.\n\t(expand_GOMP_SIMT_EXIT): New.\n\t* internal-fn.def (GOMP_SIMT_ENTER): New internal function.\n\t(GOMP_SIMT_ENTER_ALLOC): Ditto.\n\t(GOMP_SIMT_EXIT): Ditto.\n\t* target-insns.def (omp_simt_enter): New insn.\n\t(omp_simt_exit): Ditto.\n\t* omp-low.c (struct omplow_simd_context): New fields simt_eargs,\n\tsimt_dlist.\n\t(lower_rec_simd_input_clauses): Implement SIMT privatization.\n\t(lower_rec_input_clauses): Likewise.\n\t(lower_lastprivate_clauses): Handle SIMT privatization.\n\n\t* omp-offload.c: Include langhooks.h, tree-nested.h, stor-layout.h.\n\t(ompdevlow_adjust_simt_enter): New.\n\t(find_simtpriv_var_op): New.\n\t(execute_omp_device_lower): Handle IFN_GOMP_SIMT_ENTER,\n\tIFN_GOMP_SIMT_ENTER_ALLOC, IFN_GOMP_SIMT_EXIT.\n\n\t* tree-inline.h (struct copy_body_data): New field dst_simt_vars.\n\t* tree-inline.c (expand_call_inline): Handle SIMT privatization.\n\t(copy_decl_for_dup_finish): Ditto.\n\n\t* tree-ssa.c (execute_update_addresses_taken): Handle GOMP_SIMT_ENTER.\n\nFrom-SVN: r246550", "tree": {"sha": "6e27cae40470f82adccad608f14526f11d8fbc1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e27cae40470f82adccad608f14526f11d8fbc1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/comments", "author": {"login": "amonakov", "id": 1997391, "node_id": "MDQ6VXNlcjE5OTczOTE=", "avatar_url": "https://avatars.githubusercontent.com/u/1997391?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amonakov", "html_url": "https://github.com/amonakov", "followers_url": "https://api.github.com/users/amonakov/followers", "following_url": "https://api.github.com/users/amonakov/following{/other_user}", "gists_url": "https://api.github.com/users/amonakov/gists{/gist_id}", "starred_url": "https://api.github.com/users/amonakov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amonakov/subscriptions", "organizations_url": "https://api.github.com/users/amonakov/orgs", "repos_url": "https://api.github.com/users/amonakov/repos", "events_url": "https://api.github.com/users/amonakov/events{/privacy}", "received_events_url": "https://api.github.com/users/amonakov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cf474530613eaaa4d28534a5a53ef61fcc71180d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf474530613eaaa4d28534a5a53ef61fcc71180d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf474530613eaaa4d28534a5a53ef61fcc71180d"}], "stats": {"total": 636, "additions": 573, "deletions": 63}, "files": [{"sha": "7a575a8a46a3839fb932b006f92423bd4ad22852", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b", "patch": "@@ -1,3 +1,51 @@\n+2017-03-28  Alexander Monakov  <amonakov@ispras.ru>\n+\n+\t* config/nvptx/nvptx-protos.h (nvptx_output_simt_enter): Declare.\n+\t(nvptx_output_simt_exit): Declare.\n+\t* config/nvptx/nvptx.c (nvptx_init_unisimt_predicate): Use\n+\tcfun->machine->unisimt_location.  Handle NULL unisimt_predicate.\n+\t(init_softstack_frame): Move initialization of crtl->is_leaf to...\n+\t(nvptx_declare_function_name): ...here.  Emit declaration of local\n+\tmemory space buffer for omp_simt_enter insn.\n+\t(nvptx_output_unisimt_switch): New.\n+\t(nvptx_output_softstack_switch): New.\n+\t(nvptx_output_simt_enter): New.\n+\t(nvptx_output_simt_exit): New.\n+\t* config/nvptx/nvptx.h (struct machine_function): New fields\n+\thas_simtreg, unisimt_location, simt_stack_size, simt_stack_align.\n+\t* config/nvptx/nvptx.md (UNSPECV_SIMT_ENTER): New unspec.\n+\t(UNSPECV_SIMT_EXIT): Ditto.\n+\t(omp_simt_enter_insn): New insn.\n+\t(omp_simt_enter): New expansion.\n+\t(omp_simt_exit): New insn.\n+\t* config/nvptx/nvptx.opt (msoft-stack-reserve-local): New option.\n+\n+\t* internal-fn.c (expand_GOMP_SIMT_ENTER): New.\n+\t(expand_GOMP_SIMT_ENTER_ALLOC): New.\n+\t(expand_GOMP_SIMT_EXIT): New.\n+\t* internal-fn.def (GOMP_SIMT_ENTER): New internal function.\n+\t(GOMP_SIMT_ENTER_ALLOC): Ditto.\n+\t(GOMP_SIMT_EXIT): Ditto.\n+\t* target-insns.def (omp_simt_enter): New insn.\n+\t(omp_simt_exit): Ditto.\n+\t* omp-low.c (struct omplow_simd_context): New fields simt_eargs,\n+\tsimt_dlist.\n+\t(lower_rec_simd_input_clauses): Implement SIMT privatization.\n+\t(lower_rec_input_clauses): Likewise.\n+\t(lower_lastprivate_clauses): Handle SIMT privatization.\n+\n+\t* omp-offload.c: Include langhooks.h, tree-nested.h, stor-layout.h.\n+\t(ompdevlow_adjust_simt_enter): New.\n+\t(find_simtpriv_var_op): New.\n+\t(execute_omp_device_lower): Handle IFN_GOMP_SIMT_ENTER,\n+\tIFN_GOMP_SIMT_ENTER_ALLOC, IFN_GOMP_SIMT_EXIT.\n+\n+\t* tree-inline.h (struct copy_body_data): New field dst_simt_vars.\n+\t* tree-inline.c (expand_call_inline): Handle SIMT privatization.\n+\t(copy_decl_for_dup_finish): Ditto.\n+\n+\t* tree-ssa.c (execute_update_addresses_taken): Handle GOMP_SIMT_ENTER.\n+\n 2017-03-28  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/53383"}, {"sha": "16b316f12b8e4d747d3d0a4f9d263b148cbb41df", "filename": "gcc/config/nvptx/nvptx-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Fconfig%2Fnvptx%2Fnvptx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Fconfig%2Fnvptx%2Fnvptx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx-protos.h?ref=0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b", "patch": "@@ -53,5 +53,7 @@ extern const char *nvptx_output_mov_insn (rtx, rtx);\n extern const char *nvptx_output_call_insn (rtx_insn *, rtx, rtx);\n extern const char *nvptx_output_return (void);\n extern const char *nvptx_output_set_softstack (unsigned);\n+extern const char *nvptx_output_simt_enter (rtx, rtx, rtx);\n+extern const char *nvptx_output_simt_exit (rtx);\n #endif\n #endif"}, {"sha": "83f46104ca3de88e118e5102bafda6122c5a77c0", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 145, "deletions": 18, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b", "patch": "@@ -1048,11 +1048,6 @@ init_softstack_frame (FILE *file, unsigned alignment, HOST_WIDE_INT size)\n   fprintf (file, \"\\t\\tsub.u%d %s, %s, \" HOST_WIDE_INT_PRINT_DEC \";\\n\",\n \t   bits, reg_stack, reg_frame, size);\n \n-  /* Usually 'crtl->is_leaf' is computed during register allocator\n-     initialization (which is not done on NVPTX) or for pressure-sensitive\n-     optimizations.  Initialize it here, except if already set.  */\n-  if (!crtl->is_leaf)\n-    crtl->is_leaf = leaf_function_p ();\n   if (!crtl->is_leaf)\n     fprintf (file, \"\\t\\tst.shared.u%d [%s], %s;\\n\",\n \t     bits, reg_sspslot, reg_stack);\n@@ -1080,24 +1075,29 @@ nvptx_init_axis_predicate (FILE *file, int regno, const char *name)\n static void\n nvptx_init_unisimt_predicate (FILE *file)\n {\n+  cfun->machine->unisimt_location = gen_reg_rtx (Pmode);\n+  int loc = REGNO (cfun->machine->unisimt_location);\n   int bits = POINTER_SIZE;\n-  int master = REGNO (cfun->machine->unisimt_master);\n-  int pred = REGNO (cfun->machine->unisimt_predicate);\n+  fprintf (file, \"\\t.reg.u%d %%r%d;\\n\", bits, loc);\n   fprintf (file, \"\\t{\\n\");\n   fprintf (file, \"\\t\\t.reg.u32 %%ustmp0;\\n\");\n   fprintf (file, \"\\t\\t.reg.u%d %%ustmp1;\\n\", bits);\n-  fprintf (file, \"\\t\\t.reg.u%d %%ustmp2;\\n\", bits);\n   fprintf (file, \"\\t\\tmov.u32 %%ustmp0, %%tid.y;\\n\");\n   fprintf (file, \"\\t\\tmul%s.u32 %%ustmp1, %%ustmp0, 4;\\n\",\n \t   bits == 64 ? \".wide\" : \".lo\");\n-  fprintf (file, \"\\t\\tmov.u%d %%ustmp2, __nvptx_uni;\\n\", bits);\n-  fprintf (file, \"\\t\\tadd.u%d %%ustmp2, %%ustmp2, %%ustmp1;\\n\", bits);\n-  fprintf (file, \"\\t\\tld.shared.u32 %%r%d, [%%ustmp2];\\n\", master);\n-  fprintf (file, \"\\t\\tmov.u32 %%ustmp0, %%tid.x;\\n\");\n-  /* Compute 'master lane index' as 'tid.x & __nvptx_uni[tid.y]'.  */\n-  fprintf (file, \"\\t\\tand.b32 %%r%d, %%r%d, %%ustmp0;\\n\", master, master);\n-  /* Compute predicate as 'tid.x == master'.  */\n-  fprintf (file, \"\\t\\tsetp.eq.u32 %%r%d, %%r%d, %%ustmp0;\\n\", pred, master);\n+  fprintf (file, \"\\t\\tmov.u%d %%r%d, __nvptx_uni;\\n\", bits, loc);\n+  fprintf (file, \"\\t\\tadd.u%d %%r%d, %%r%d, %%ustmp1;\\n\", bits, loc, loc);\n+  if (cfun->machine->unisimt_predicate)\n+    {\n+      int master = REGNO (cfun->machine->unisimt_master);\n+      int pred = REGNO (cfun->machine->unisimt_predicate);\n+      fprintf (file, \"\\t\\tld.shared.u32 %%r%d, [%%r%d];\\n\", master, loc);\n+      fprintf (file, \"\\t\\tmov.u32 %%ustmp0, %%laneid;\\n\");\n+      /* Compute 'master lane index' as 'laneid & __nvptx_uni[tid.y]'.  */\n+      fprintf (file, \"\\t\\tand.b32 %%r%d, %%r%d, %%ustmp0;\\n\", master, master);\n+      /* Compute predicate as 'tid.x == master'.  */\n+      fprintf (file, \"\\t\\tsetp.eq.u32 %%r%d, %%r%d, %%ustmp0;\\n\", pred, master);\n+    }\n   fprintf (file, \"\\t}\\n\");\n   need_unisimt_decl = true;\n }\n@@ -1224,6 +1224,12 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n \n   fprintf (file, \"%s\", s.str().c_str());\n \n+  /* Usually 'crtl->is_leaf' is computed during register allocator\n+     initialization (which is not done on NVPTX) or for pressure-sensitive\n+     optimizations.  Initialize it here, except if already set.  */\n+  if (!crtl->is_leaf)\n+    crtl->is_leaf = leaf_function_p ();\n+\n   HOST_WIDE_INT sz = get_frame_size ();\n   bool need_frameptr = sz || cfun->machine->has_chain;\n   int alignment = crtl->stack_alignment_needed / BITS_PER_UNIT;\n@@ -1240,9 +1246,28 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n \tinit_frame (file, FRAME_POINTER_REGNUM, alignment,\n \t\t    ROUND_UP (sz, GET_MODE_SIZE (DImode)));\n     }\n-  else if (need_frameptr || cfun->machine->has_varadic || cfun->calls_alloca)\n+  else if (need_frameptr || cfun->machine->has_varadic || cfun->calls_alloca\n+\t   || (cfun->machine->has_simtreg && !crtl->is_leaf))\n     init_softstack_frame (file, alignment, sz);\n \n+  if (cfun->machine->has_simtreg)\n+    {\n+      unsigned HOST_WIDE_INT &simtsz = cfun->machine->simt_stack_size;\n+      unsigned HOST_WIDE_INT &align = cfun->machine->simt_stack_align;\n+      align = MAX (align, GET_MODE_SIZE (DImode));\n+      if (!crtl->is_leaf || cfun->calls_alloca)\n+\tsimtsz = HOST_WIDE_INT_M1U;\n+      if (simtsz == HOST_WIDE_INT_M1U)\n+\tsimtsz = nvptx_softstack_size;\n+      if (cfun->machine->has_softstack)\n+\tsimtsz += POINTER_SIZE / 8;\n+      simtsz = ROUND_UP (simtsz, GET_MODE_SIZE (DImode));\n+      if (align > GET_MODE_SIZE (DImode))\n+\tsimtsz += align - GET_MODE_SIZE (DImode);\n+      if (simtsz)\n+\tfprintf (file, \"\\t.local.align 8 .b8 %%simtstack_ar[\"\n+\t\tHOST_WIDE_INT_PRINT_DEC \"];\\n\", simtsz);\n+    }\n   /* Declare the pseudos we have as ptx registers.  */\n   int maxregs = max_reg_num ();\n   for (int i = LAST_VIRTUAL_REGISTER + 1; i < maxregs; i++)\n@@ -1267,10 +1292,112 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n   if (cfun->machine->axis_predicate[1])\n     nvptx_init_axis_predicate (file,\n \t\t\t       REGNO (cfun->machine->axis_predicate[1]), \"x\");\n-  if (cfun->machine->unisimt_predicate)\n+  if (cfun->machine->unisimt_predicate\n+      || (cfun->machine->has_simtreg && !crtl->is_leaf))\n     nvptx_init_unisimt_predicate (file);\n }\n \n+/* Output code for switching uniform-simt state.  ENTERING indicates whether\n+   we are entering or leaving non-uniform execution region.  */\n+\n+static void\n+nvptx_output_unisimt_switch (FILE *file, bool entering)\n+{\n+  if (crtl->is_leaf && !cfun->machine->unisimt_predicate)\n+    return;\n+  fprintf (file, \"\\t{\\n\");\n+  fprintf (file, \"\\t\\t.reg.u32 %%ustmp2;\\n\");\n+  fprintf (file, \"\\t\\tmov.u32 %%ustmp2, %d;\\n\", entering ? -1 : 0);\n+  if (!crtl->is_leaf)\n+    {\n+      int loc = REGNO (cfun->machine->unisimt_location);\n+      fprintf (file, \"\\t\\tst.shared.u32 [%%r%d], %%ustmp2;\\n\", loc);\n+    }\n+  if (cfun->machine->unisimt_predicate)\n+    {\n+      int master = REGNO (cfun->machine->unisimt_master);\n+      int pred = REGNO (cfun->machine->unisimt_predicate);\n+      fprintf (file, \"\\t\\tmov.u32 %%ustmp2, %%laneid;\\n\");\n+      fprintf (file, \"\\t\\tmov.u32 %%r%d, %s;\\n\",\n+\t       master, entering ? \"%ustmp2\" : \"0\");\n+      fprintf (file, \"\\t\\tsetp.eq.u32 %%r%d, %%r%d, %%ustmp2;\\n\", pred, master);\n+    }\n+  fprintf (file, \"\\t}\\n\");\n+}\n+\n+/* Output code for allocating per-lane storage and switching soft-stack pointer.\n+   ENTERING indicates whether we are entering or leaving non-uniform execution.\n+   PTR is the register pointing to allocated storage, it is assigned to on\n+   entering and used to restore state on leaving.  SIZE and ALIGN are used only\n+   on entering.  */\n+\n+static void\n+nvptx_output_softstack_switch (FILE *file, bool entering,\n+\t\t\t       rtx ptr, rtx size, rtx align)\n+{\n+  gcc_assert (REG_P (ptr) && !HARD_REGISTER_P (ptr));\n+  if (crtl->is_leaf && !cfun->machine->simt_stack_size)\n+    return;\n+  int bits = POINTER_SIZE, regno = REGNO (ptr);\n+  fprintf (file, \"\\t{\\n\");\n+  if (entering)\n+    {\n+      fprintf (file, \"\\t\\tcvta.local.u%d %%r%d, %%simtstack_ar + \"\n+\t       HOST_WIDE_INT_PRINT_DEC \";\\n\", bits, regno,\n+\t       cfun->machine->simt_stack_size);\n+      fprintf (file, \"\\t\\tsub.u%d %%r%d, %%r%d, \", bits, regno, regno);\n+      if (CONST_INT_P (size))\n+\tfprintf (file, HOST_WIDE_INT_PRINT_DEC,\n+\t\t ROUND_UP (UINTVAL (size), GET_MODE_SIZE (DImode)));\n+      else\n+\toutput_reg (file, REGNO (size), VOIDmode);\n+      fputs (\";\\n\", file);\n+      if (!CONST_INT_P (size) || UINTVAL (align) > GET_MODE_SIZE (DImode))\n+\tfprintf (file, \"\\t\\tand.u%d %%r%d, %%r%d, -%d;\\n\",\n+\t\t bits, regno, regno, UINTVAL (align));\n+    }\n+  if (cfun->machine->has_softstack)\n+    {\n+      const char *reg_stack = reg_names[STACK_POINTER_REGNUM];\n+      if (entering)\n+\t{\n+\t  fprintf (file, \"\\t\\tst.u%d [%%r%d + -%d], %s;\\n\",\n+\t\t   bits, regno, bits / 8, reg_stack);\n+\t  fprintf (file, \"\\t\\tsub.u%d %s, %%r%d, %d;\\n\",\n+\t\t   bits, reg_stack, regno, bits / 8);\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \"\\t\\tld.u%d %s, [%%r%d + -%d];\\n\",\n+\t\t   bits, reg_stack, regno, bits / 8);\n+\t}\n+      nvptx_output_set_softstack (REGNO (stack_pointer_rtx));\n+    }\n+  fprintf (file, \"\\t}\\n\");\n+}\n+\n+/* Output code to enter non-uniform execution region.  DEST is a register\n+   to hold a per-lane allocation given by SIZE and ALIGN.  */\n+\n+const char *\n+nvptx_output_simt_enter (rtx dest, rtx size, rtx align)\n+{\n+  nvptx_output_unisimt_switch (asm_out_file, true);\n+  nvptx_output_softstack_switch (asm_out_file, true, dest, size, align);\n+  return \"\";\n+}\n+\n+/* Output code to leave non-uniform execution region.  SRC is the register\n+   holding per-lane storage previously allocated by omp_simt_enter insn.  */\n+\n+const char *\n+nvptx_output_simt_exit (rtx src)\n+{\n+  nvptx_output_unisimt_switch (asm_out_file, false);\n+  nvptx_output_softstack_switch (asm_out_file, false, src, NULL_RTX, NULL_RTX);\n+  return \"\";\n+}\n+\n /* Output instruction that sets soft stack pointer in shared memory to the\n    value in register given by SRC_REGNO.  */\n "}, {"sha": "0a000a73df5f0981ae277c10239ff9b5266bb4d6", "filename": "gcc/config/nvptx/nvptx.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.h?ref=0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b", "patch": "@@ -213,12 +213,18 @@ struct GTY(()) machine_function\n   bool has_varadic;  /* Current function has a varadic call.  */\n   bool has_chain; /* Current function has outgoing static chain.  */\n   bool has_softstack; /* Current function has a soft stack frame.  */\n+  bool has_simtreg; /* Current function has an OpenMP SIMD region.  */\n   int num_args;\t/* Number of args of current call.  */\n   int return_mode; /* Return mode of current fn.\n \t\t      (machine_mode not defined yet.) */\n   rtx axis_predicate[2]; /* Neutering predicates.  */\n   rtx unisimt_master; /* 'Master lane index' for -muniform-simt.  */\n   rtx unisimt_predicate; /* Predicate for -muniform-simt.  */\n+  rtx unisimt_location; /* Mask location for -muniform-simt.  */\n+  /* The following two fields hold the maximum size resp. alignment required\n+     for per-lane storage in OpenMP SIMD regions.  */\n+  unsigned HOST_WIDE_INT simt_stack_size;\n+  unsigned HOST_WIDE_INT simt_stack_align;\n };\n #endif\n \f"}, {"sha": "f2ed63bf06b377d9a70f4cda34778fdb91deec5a", "filename": "gcc/config/nvptx/nvptx.md", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Fconfig%2Fnvptx%2Fnvptx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Fconfig%2Fnvptx%2Fnvptx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.md?ref=0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b", "patch": "@@ -63,6 +63,9 @@\n    UNSPECV_JOIN\n \n    UNSPECV_NOUNROLL\n+\n+   UNSPECV_SIMT_ENTER\n+   UNSPECV_SIMT_EXIT\n ])\n \n (define_attr \"subregs_ok\" \"false,true\"\n@@ -1184,6 +1187,42 @@\n \n ;; Patterns for OpenMP SIMD-via-SIMT lowering\n \n+(define_insn \"omp_simt_enter_insn\"\n+  [(set (match_operand 0 \"nvptx_register_operand\" \"=R\")\n+\t(unspec_volatile [(match_operand 1 \"nvptx_nonmemory_operand\" \"Ri\")\n+\t\t\t    (match_operand 2 \"nvptx_nonmemory_operand\" \"Ri\")]\n+\t\t\t   UNSPECV_SIMT_ENTER))]\n+  \"\"\n+{\n+  return nvptx_output_simt_enter (operands[0], operands[1], operands[2]);\n+})\n+\n+(define_expand \"omp_simt_enter\"\n+  [(match_operand 0 \"nvptx_register_operand\" \"=R\")\n+   (match_operand 1 \"nvptx_nonmemory_operand\" \"Ri\")\n+   (match_operand 2 \"const_int_operand\" \"n\")]\n+  \"\"\n+{\n+  if (!CONST_INT_P (operands[1]))\n+    cfun->machine->simt_stack_size = HOST_WIDE_INT_M1U;\n+  else\n+    cfun->machine->simt_stack_size = MAX (UINTVAL (operands[1]),\n+\t\t\t\t\t  cfun->machine->simt_stack_size);\n+  cfun->machine->simt_stack_align = MAX (UINTVAL (operands[2]),\n+\t\t\t\t\t cfun->machine->simt_stack_align);\n+  cfun->machine->has_simtreg = true;\n+  emit_insn (gen_omp_simt_enter_insn (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_insn \"omp_simt_exit\"\n+  [(unspec_volatile [(match_operand 0 \"nvptx_register_operand\" \"R\")]\n+\t\t    UNSPECV_SIMT_EXIT)]\n+  \"\"\n+{\n+  return nvptx_output_simt_exit (operands[0]);\n+})\n+\n ;; Implement IFN_GOMP_SIMT_LANE: set operand 0 to lane index\n (define_insn \"omp_simt_lane\"\n   [(set (match_operand:SI 0 \"nvptx_register_operand\" \"\")"}, {"sha": "901def703f80f03608479245e912a008fa27390f", "filename": "gcc/config/nvptx/nvptx.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Fconfig%2Fnvptx%2Fnvptx.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Fconfig%2Fnvptx%2Fnvptx.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.opt?ref=0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b", "patch": "@@ -37,6 +37,10 @@ msoft-stack\n Target Report Mask(SOFT_STACK)\n Use custom stacks instead of local memory for automatic storage.\n \n+msoft-stack-reserve-local\n+Target Report Joined RejectNegative UInteger Var(nvptx_softstack_size) Init(128)\n+Specify size of .local memory used for stack when the exact amount is not known.\n+\n muniform-simt\n Target Report Mask(UNIFORM_SIMT)\n Generate code that can keep local state uniform across all lanes."}, {"sha": "75fe027f7b27c44baf527313e9d1878484632a89", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b", "patch": "@@ -166,6 +166,48 @@ expand_GOMP_USE_SIMT (internal_fn, gcall *)\n   gcc_unreachable ();\n }\n \n+/* This should get expanded in omp_device_lower pass.  */\n+\n+static void\n+expand_GOMP_SIMT_ENTER (internal_fn, gcall *)\n+{\n+  gcc_unreachable ();\n+}\n+\n+/* Allocate per-lane storage and begin non-uniform execution region.  */\n+\n+static void\n+expand_GOMP_SIMT_ENTER_ALLOC (internal_fn, gcall *stmt)\n+{\n+  rtx target;\n+  tree lhs = gimple_call_lhs (stmt);\n+  if (lhs)\n+    target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  else\n+    target = gen_reg_rtx (Pmode);\n+  rtx size = expand_normal (gimple_call_arg (stmt, 0));\n+  rtx align = expand_normal (gimple_call_arg (stmt, 1));\n+  struct expand_operand ops[3];\n+  create_output_operand (&ops[0], target, Pmode);\n+  create_input_operand (&ops[1], size, Pmode);\n+  create_input_operand (&ops[2], align, Pmode);\n+  gcc_assert (targetm.have_omp_simt_enter ());\n+  expand_insn (targetm.code_for_omp_simt_enter, 3, ops);\n+}\n+\n+/* Deallocate per-lane storage and leave non-uniform execution region.  */\n+\n+static void\n+expand_GOMP_SIMT_EXIT (internal_fn, gcall *stmt)\n+{\n+  gcc_checking_assert (!gimple_call_lhs (stmt));\n+  rtx arg = expand_normal (gimple_call_arg (stmt, 0));\n+  struct expand_operand ops[1];\n+  create_input_operand (&ops[0], arg, Pmode);\n+  gcc_assert (targetm.have_omp_simt_exit ());\n+  expand_insn (targetm.code_for_omp_simt_exit, 1, ops);\n+}\n+\n /* Lane index on SIMT targets: thread index in the warp on NVPTX.  On targets\n    without SIMT execution this should be expanded in omp_device_lower pass.  */\n "}, {"sha": "e162d81121cba31f75387bd6e4e3bcbde7d04b02", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b", "patch": "@@ -142,6 +142,9 @@ DEF_INTERNAL_INT_FN (PARITY, ECF_CONST, parity, unary)\n DEF_INTERNAL_INT_FN (POPCOUNT, ECF_CONST, popcount, unary)\n \n DEF_INTERNAL_FN (GOMP_USE_SIMT, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (GOMP_SIMT_ENTER, ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (GOMP_SIMT_ENTER_ALLOC, ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (GOMP_SIMT_EXIT, ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMT_LANE, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMT_VF, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMT_LAST_LANE, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)"}, {"sha": "253dc8563744d14cccb2079cfb1ec15f9d60c906", "filename": "gcc/omp-low.c", "status": "modified", "additions": 96, "deletions": 37, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b", "patch": "@@ -3457,6 +3457,8 @@ omp_clause_aligned_alignment (tree clause)\n struct omplow_simd_context {\n   tree idx;\n   tree lane;\n+  vec<tree, va_heap> simt_eargs;\n+  gimple_seq simt_dlist;\n   int max_vf;\n   bool is_simt;\n };\n@@ -3492,18 +3494,39 @@ lower_rec_simd_input_clauses (tree new_var, omp_context *ctx,\n   if (sctx->max_vf == 1)\n     return false;\n \n-  tree atype = build_array_type_nelts (TREE_TYPE (new_var), sctx->max_vf);\n-  tree avar = create_tmp_var_raw (atype);\n-  if (TREE_ADDRESSABLE (new_var))\n-    TREE_ADDRESSABLE (avar) = 1;\n-  DECL_ATTRIBUTES (avar)\n-    = tree_cons (get_identifier (\"omp simd array\"), NULL,\n-\t\t DECL_ATTRIBUTES (avar));\n-  gimple_add_tmp_var (avar);\n-  ivar = build4 (ARRAY_REF, TREE_TYPE (new_var), avar, sctx->idx,\n-\t\t NULL_TREE, NULL_TREE);\n-  lvar = build4 (ARRAY_REF, TREE_TYPE (new_var), avar, sctx->lane,\n-\t\t NULL_TREE, NULL_TREE);\n+  if (sctx->is_simt)\n+    {\n+      if (is_gimple_reg (new_var))\n+\t{\n+\t  ivar = lvar = new_var;\n+\t  return true;\n+\t}\n+      tree type = TREE_TYPE (new_var), ptype = build_pointer_type (type);\n+      ivar = lvar = create_tmp_var (type);\n+      TREE_ADDRESSABLE (ivar) = 1;\n+      DECL_ATTRIBUTES (ivar) = tree_cons (get_identifier (\"omp simt private\"),\n+\t\t\t\t\t  NULL, DECL_ATTRIBUTES (ivar));\n+      sctx->simt_eargs.safe_push (build1 (ADDR_EXPR, ptype, ivar));\n+      tree clobber = build_constructor (type, NULL);\n+      TREE_THIS_VOLATILE (clobber) = 1;\n+      gimple *g = gimple_build_assign (ivar, clobber);\n+      gimple_seq_add_stmt (&sctx->simt_dlist, g);\n+    }\n+  else\n+    {\n+      tree atype = build_array_type_nelts (TREE_TYPE (new_var), sctx->max_vf);\n+      tree avar = create_tmp_var_raw (atype);\n+      if (TREE_ADDRESSABLE (new_var))\n+\tTREE_ADDRESSABLE (avar) = 1;\n+      DECL_ATTRIBUTES (avar)\n+\t= tree_cons (get_identifier (\"omp simd array\"), NULL,\n+\t\t     DECL_ATTRIBUTES (avar));\n+      gimple_add_tmp_var (avar);\n+      ivar = build4 (ARRAY_REF, TREE_TYPE (new_var), avar, sctx->idx,\n+\t\t     NULL_TREE, NULL_TREE);\n+      lvar = build4 (ARRAY_REF, TREE_TYPE (new_var), avar, sctx->lane,\n+\t\t     NULL_TREE, NULL_TREE);\n+    }\n   if (DECL_P (new_var))\n     {\n       SET_DECL_VALUE_EXPR (new_var, lvar);\n@@ -3547,8 +3570,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n   bool is_simd = (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n \t\t  && gimple_omp_for_kind (ctx->stmt) & GF_OMP_FOR_SIMD);\n   omplow_simd_context sctx = omplow_simd_context ();\n-  tree simt_lane = NULL_TREE;\n-  tree ivar = NULL_TREE, lvar = NULL_TREE;\n+  tree simt_lane = NULL_TREE, simtrec = NULL_TREE;\n+  tree ivar = NULL_TREE, lvar = NULL_TREE, uid = NULL_TREE;\n   gimple_seq llist[3] = { };\n \n   copyin_seq = NULL;\n@@ -3581,6 +3604,10 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t  continue;\n \t}\n \n+  /* Add a placeholder for simduid.  */\n+  if (sctx.is_simt && sctx.max_vf != 1)\n+    sctx.simt_eargs.safe_push (NULL_TREE);\n+\n   /* Do all the fixed sized types in the first pass, and the variable sized\n      types in the second pass.  This makes sure that the scalar arguments to\n      the variable sized types are processed before we use them in the\n@@ -4468,21 +4495,43 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t}\n     }\n \n-  if (sctx.lane)\n+  if (sctx.max_vf == 1)\n+    sctx.is_simt = false;\n+\n+  if (sctx.lane || sctx.is_simt)\n     {\n-      tree uid = create_tmp_var (ptr_type_node, \"simduid\");\n+      uid = create_tmp_var (ptr_type_node, \"simduid\");\n       /* Don't want uninit warnings on simduid, it is always uninitialized,\n \t but we use it not for the value, but for the DECL_UID only.  */\n       TREE_NO_WARNING (uid) = 1;\n+      c = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE__SIMDUID_);\n+      OMP_CLAUSE__SIMDUID__DECL (c) = uid;\n+      OMP_CLAUSE_CHAIN (c) = gimple_omp_for_clauses (ctx->stmt);\n+      gimple_omp_for_set_clauses (ctx->stmt, c);\n+    }\n+  /* Emit calls denoting privatized variables and initializing a pointer to\n+     structure that holds private variables as fields after ompdevlow pass.  */\n+  if (sctx.is_simt)\n+    {\n+      sctx.simt_eargs[0] = uid;\n+      gimple *g\n+\t= gimple_build_call_internal_vec (IFN_GOMP_SIMT_ENTER, sctx.simt_eargs);\n+      gimple_call_set_lhs (g, uid);\n+      gimple_seq_add_stmt (ilist, g);\n+      sctx.simt_eargs.release ();\n+\n+      simtrec = create_tmp_var (ptr_type_node, \".omp_simt\");\n+      g = gimple_build_call_internal (IFN_GOMP_SIMT_ENTER_ALLOC, 1, uid);\n+      gimple_call_set_lhs (g, simtrec);\n+      gimple_seq_add_stmt (ilist, g);\n+    }\n+  if (sctx.lane)\n+    {\n       gimple *g\n \t= gimple_build_call_internal (IFN_GOMP_SIMD_LANE, 1, uid);\n       gimple_call_set_lhs (g, sctx.lane);\n       gimple_stmt_iterator gsi = gsi_start_1 (gimple_omp_body_ptr (ctx->stmt));\n       gsi_insert_before_without_update (&gsi, g, GSI_SAME_STMT);\n-      c = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE__SIMDUID_);\n-      OMP_CLAUSE__SIMDUID__DECL (c) = uid;\n-      OMP_CLAUSE_CHAIN (c) = gimple_omp_for_clauses (ctx->stmt);\n-      gimple_omp_for_set_clauses (ctx->stmt, c);\n       g = gimple_build_assign (sctx.lane, INTEGER_CST,\n \t\t\t       build_int_cst (unsigned_type_node, 0));\n       gimple_seq_add_stmt (ilist, g);\n@@ -4545,6 +4594,13 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t    gimple_seq_add_stmt (seq, gimple_build_label (end));\n \t  }\n     }\n+  if (sctx.is_simt)\n+    {\n+      gimple_seq_add_seq (dlist, sctx.simt_dlist);\n+      gimple *g\n+\t= gimple_build_call_internal (IFN_GOMP_SIMT_EXIT, 1, simtrec);\n+      gimple_seq_add_stmt (dlist, g);\n+    }\n \n   /* The copyin sequence is not to be executed by the main thread, since\n      that would result in self-copies.  Perhaps not visible to scalars,\n@@ -4715,7 +4771,8 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n \t  if (simduid && DECL_HAS_VALUE_EXPR_P (new_var))\n \t    {\n \t      tree val = DECL_VALUE_EXPR (new_var);\n-\t      if (TREE_CODE (val) == ARRAY_REF\n+\t      if (!maybe_simt\n+\t\t  && TREE_CODE (val) == ARRAY_REF\n \t\t  && VAR_P (TREE_OPERAND (val, 0))\n \t\t  && lookup_attribute (\"omp simd array\",\n \t\t\t\t       DECL_ATTRIBUTES (TREE_OPERAND (val,\n@@ -4734,24 +4791,26 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n \t\t  new_var = build4 (ARRAY_REF, TREE_TYPE (val),\n \t\t\t\t    TREE_OPERAND (val, 0), lastlane,\n \t\t\t\t    NULL_TREE, NULL_TREE);\n-\t\t  if (maybe_simt)\n+\t\t}\n+\t      else if (maybe_simt\n+\t\t       && VAR_P (val)\n+\t\t       && lookup_attribute (\"omp simt private\",\n+\t\t\t\t\t    DECL_ATTRIBUTES (val)))\n+\t\t{\n+\t\t  if (simtlast == NULL)\n \t\t    {\n-\t\t      gcall *g;\n-\t\t      if (simtlast == NULL)\n-\t\t\t{\n-\t\t\t  simtlast = create_tmp_var (unsigned_type_node);\n-\t\t\t  g = gimple_build_call_internal\n-\t\t\t    (IFN_GOMP_SIMT_LAST_LANE, 1, simtcond);\n-\t\t\t  gimple_call_set_lhs (g, simtlast);\n-\t\t\t  gimple_seq_add_stmt (stmt_list, g);\n-\t\t\t}\n-\t\t      x = build_call_expr_internal_loc\n-\t\t\t(UNKNOWN_LOCATION, IFN_GOMP_SIMT_XCHG_IDX,\n-\t\t\t TREE_TYPE (new_var), 2, new_var, simtlast);\n-\t\t      new_var = unshare_expr (new_var);\n-\t\t      gimplify_assign (new_var, x, stmt_list);\n-\t\t      new_var = unshare_expr (new_var);\n+\t\t      simtlast = create_tmp_var (unsigned_type_node);\n+\t\t      gcall *g = gimple_build_call_internal\n+\t\t\t(IFN_GOMP_SIMT_LAST_LANE, 1, simtcond);\n+\t\t      gimple_call_set_lhs (g, simtlast);\n+\t\t      gimple_seq_add_stmt (stmt_list, g);\n \t\t    }\n+\t\t  x = build_call_expr_internal_loc\n+\t\t    (UNKNOWN_LOCATION, IFN_GOMP_SIMT_XCHG_IDX,\n+\t\t     TREE_TYPE (val), 2, val, simtlast);\n+\t\t  new_var = unshare_expr (new_var);\n+\t\t  gimplify_assign (new_var, x, stmt_list);\n+\t\t  new_var = unshare_expr (new_var);\n \t\t}\n \t    }\n "}, {"sha": "beeeb71a2ebef6d5a76ebe81215d6b0813e96009", "filename": "gcc/omp-offload.c", "status": "modified", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Fomp-offload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Fomp-offload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-offload.c?ref=0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b", "patch": "@@ -33,12 +33,15 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"fold-const.h\"\n #include \"internal-fn.h\"\n+#include \"langhooks.h\"\n #include \"gimplify.h\"\n #include \"gimple-iterator.h\"\n #include \"gimplify-me.h\"\n #include \"gimple-walk.h\"\n #include \"tree-cfg.h\"\n #include \"tree-into-ssa.h\"\n+#include \"tree-nested.h\"\n+#include \"stor-layout.h\"\n #include \"common/common-target.h\"\n #include \"omp-general.h\"\n #include \"omp-offload.h\"\n@@ -1669,6 +1672,92 @@ make_pass_oacc_device_lower (gcc::context *ctxt)\n   return new pass_oacc_device_lower (ctxt);\n }\n \n+\f\n+/* Rewrite GOMP_SIMT_ENTER_ALLOC call given by GSI and remove the preceding\n+   GOMP_SIMT_ENTER call identifying the privatized variables, which are\n+   turned to structure fields and receive a DECL_VALUE_EXPR accordingly.\n+   Set *REGIMPLIFY to true, except if no privatized variables were seen.  */\n+\n+static void\n+ompdevlow_adjust_simt_enter (gimple_stmt_iterator *gsi, bool *regimplify)\n+{\n+  gimple *alloc_stmt = gsi_stmt (*gsi);\n+  tree simtrec = gimple_call_lhs (alloc_stmt);\n+  tree simduid = gimple_call_arg (alloc_stmt, 0);\n+  gimple *enter_stmt = SSA_NAME_DEF_STMT (simduid);\n+  gcc_assert (gimple_call_internal_p (enter_stmt, IFN_GOMP_SIMT_ENTER));\n+  tree rectype = lang_hooks.types.make_type (RECORD_TYPE);\n+  TYPE_ARTIFICIAL (rectype) = TYPE_NAMELESS (rectype) = 1;\n+  TREE_ADDRESSABLE (rectype) = 1;\n+  TREE_TYPE (simtrec) = build_pointer_type (rectype);\n+  for (unsigned i = 1; i < gimple_call_num_args (enter_stmt); i++)\n+    {\n+      tree *argp = gimple_call_arg_ptr (enter_stmt, i);\n+      if (*argp == null_pointer_node)\n+\tcontinue;\n+      gcc_assert (TREE_CODE (*argp) == ADDR_EXPR\n+\t\t  && VAR_P (TREE_OPERAND (*argp, 0)));\n+      tree var = TREE_OPERAND (*argp, 0);\n+\n+      tree field = build_decl (DECL_SOURCE_LOCATION (var), FIELD_DECL,\n+\t\t\t       DECL_NAME (var), TREE_TYPE (var));\n+      SET_DECL_ALIGN (field, DECL_ALIGN (var));\n+      DECL_USER_ALIGN (field) = DECL_USER_ALIGN (var);\n+      TREE_THIS_VOLATILE (field) = TREE_THIS_VOLATILE (var);\n+\n+      insert_field_into_struct (rectype, field);\n+\n+      tree t = build_simple_mem_ref (simtrec);\n+      t = build3 (COMPONENT_REF, TREE_TYPE (var), t, field, NULL);\n+      TREE_THIS_VOLATILE (t) = TREE_THIS_VOLATILE (var);\n+      SET_DECL_VALUE_EXPR (var, t);\n+      DECL_HAS_VALUE_EXPR_P (var) = 1;\n+      *regimplify = true;\n+    }\n+  layout_type (rectype);\n+  tree size = TYPE_SIZE_UNIT (rectype);\n+  tree align = build_int_cst (TREE_TYPE (size), TYPE_ALIGN_UNIT (rectype));\n+\n+  alloc_stmt\n+    = gimple_build_call_internal (IFN_GOMP_SIMT_ENTER_ALLOC, 2, size, align);\n+  gimple_call_set_lhs (alloc_stmt, simtrec);\n+  gsi_replace (gsi, alloc_stmt, false);\n+  gimple_stmt_iterator enter_gsi = gsi_for_stmt (enter_stmt);\n+  enter_stmt = gimple_build_assign (simduid, gimple_call_arg (enter_stmt, 0));\n+  gsi_replace (&enter_gsi, enter_stmt, false);\n+\n+  use_operand_p use;\n+  gimple *exit_stmt;\n+  if (single_imm_use (simtrec, &use, &exit_stmt))\n+    {\n+      gcc_assert (gimple_call_internal_p (exit_stmt, IFN_GOMP_SIMT_EXIT));\n+      gimple_stmt_iterator exit_gsi = gsi_for_stmt (exit_stmt);\n+      tree clobber = build_constructor (rectype, NULL);\n+      TREE_THIS_VOLATILE (clobber) = 1;\n+      exit_stmt = gimple_build_assign (build_simple_mem_ref (simtrec), clobber);\n+      gsi_insert_before (&exit_gsi, exit_stmt, GSI_SAME_STMT);\n+    }\n+  else\n+    gcc_checking_assert (has_zero_uses (simtrec));\n+}\n+\n+/* Callback for walk_gimple_stmt used to scan for SIMT-privatized variables.  */\n+\n+static tree\n+find_simtpriv_var_op (tree *tp, int *walk_subtrees, void *)\n+{\n+  tree t = *tp;\n+\n+  if (VAR_P (t)\n+      && DECL_HAS_VALUE_EXPR_P (t)\n+      && lookup_attribute (\"omp simt private\", DECL_ATTRIBUTES (t)))\n+    {\n+      *walk_subtrees = 0;\n+      return t;\n+    }\n+  return NULL_TREE;\n+}\n+\n /* Cleanup uses of SIMT placeholder internal functions: on non-SIMT targets,\n    VF is 1 and LANE is 0; on SIMT targets, VF is folded to a constant, and\n    LANE is kept to be expanded to RTL later on.  Also cleanup all other SIMT\n@@ -1679,6 +1768,7 @@ static unsigned int\n execute_omp_device_lower ()\n {\n   int vf = targetm.simt.vf ? targetm.simt.vf () : 1;\n+  bool regimplify = false;\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n   FOR_EACH_BB_FN (bb, cfun)\n@@ -1694,6 +1784,20 @@ execute_omp_device_lower ()\n \t  case IFN_GOMP_USE_SIMT:\n \t    rhs = vf == 1 ? integer_zero_node : integer_one_node;\n \t    break;\n+\t  case IFN_GOMP_SIMT_ENTER:\n+\t    rhs = vf == 1 ? gimple_call_arg (stmt, 0) : NULL_TREE;\n+\t    goto simtreg_enter_exit;\n+\t  case IFN_GOMP_SIMT_ENTER_ALLOC:\n+\t    if (vf != 1)\n+\t      ompdevlow_adjust_simt_enter (&gsi, &regimplify);\n+\t    rhs = vf == 1 ? null_pointer_node : NULL_TREE;\n+\t    goto simtreg_enter_exit;\n+\t  case IFN_GOMP_SIMT_EXIT:\n+\t  simtreg_enter_exit:\n+\t    if (vf != 1)\n+\t      continue;\n+\t    unlink_stmt_vdef (stmt);\n+\t    break;\n \t  case IFN_GOMP_SIMT_LANE:\n \t  case IFN_GOMP_SIMT_LAST_LANE:\n \t    rhs = vf == 1 ? build_zero_cst (type) : NULL_TREE;\n@@ -1726,6 +1830,16 @@ execute_omp_device_lower ()\n \tstmt = lhs ? gimple_build_assign (lhs, rhs) : gimple_build_nop ();\n \tgsi_replace (&gsi, stmt, false);\n       }\n+  if (regimplify)\n+    FOR_EACH_BB_REVERSE_FN (bb, cfun)\n+      for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi); gsi_prev (&gsi))\n+\tif (walk_gimple_stmt (&gsi, NULL, find_simtpriv_var_op, NULL))\n+\t  {\n+\t    if (gimple_clobber_p (gsi_stmt (gsi)))\n+\t      gsi_remove (&gsi, true);\n+\t    else\n+\t      gimple_regimplify_operands (gsi_stmt (gsi), &gsi);\n+\t  }\n   if (vf != 1)\n     cfun->has_force_vectorize_loops = false;\n   return 0;"}, {"sha": "fb92f72ac29544002983c6a89ba71d598cae7f5b", "filename": "gcc/target-insns.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Ftarget-insns.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Ftarget-insns.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-insns.def?ref=0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b", "patch": "@@ -68,6 +68,8 @@ DEF_TARGET_INSN (oacc_dim_pos, (rtx x0, rtx x1))\n DEF_TARGET_INSN (oacc_dim_size, (rtx x0, rtx x1))\n DEF_TARGET_INSN (oacc_fork, (rtx x0, rtx x1, rtx x2))\n DEF_TARGET_INSN (oacc_join, (rtx x0, rtx x1, rtx x2))\n+DEF_TARGET_INSN (omp_simt_enter, (rtx x0, rtx x1, rtx x2))\n+DEF_TARGET_INSN (omp_simt_exit, (rtx x0))\n DEF_TARGET_INSN (omp_simt_lane, (rtx x0))\n DEF_TARGET_INSN (omp_simt_last_lane, (rtx x0, rtx x1))\n DEF_TARGET_INSN (omp_simt_ordered, (rtx x0, rtx x1))"}, {"sha": "bfaaede0c326cf00e7dea8e22e3f2b55d6d73c59", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 54, "deletions": 7, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b", "patch": "@@ -4395,6 +4395,11 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)\n   gcall *call_stmt;\n   unsigned int i;\n   unsigned int prop_mask, src_properties;\n+  struct function *dst_cfun;\n+  tree simduid;\n+  use_operand_p use;\n+  gimple *simtenter_stmt = NULL;\n+  vec<tree> *simtvars_save;\n \n   /* The gimplifier uses input_location in too many places, such as\n      internal_get_tmp_var ().  */\n@@ -4598,15 +4603,26 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)\n   id->src_cfun = DECL_STRUCT_FUNCTION (fn);\n   id->call_stmt = call_stmt;\n \n+  /* When inlining into an OpenMP SIMD-on-SIMT loop, arrange for new automatic\n+     variables to be added to IFN_GOMP_SIMT_ENTER argument list.  */\n+  dst_cfun = DECL_STRUCT_FUNCTION (id->dst_fn);\n+  simtvars_save = id->dst_simt_vars;\n+  if (!(dst_cfun->curr_properties & PROP_gimple_lomp_dev)\n+      && (simduid = bb->loop_father->simduid) != NULL_TREE\n+      && (simduid = ssa_default_def (dst_cfun, simduid)) != NULL_TREE\n+      && single_imm_use (simduid, &use, &simtenter_stmt)\n+      && is_gimple_call (simtenter_stmt)\n+      && gimple_call_internal_p (simtenter_stmt, IFN_GOMP_SIMT_ENTER))\n+    vec_alloc (id->dst_simt_vars, 0);\n+  else\n+    id->dst_simt_vars = NULL;\n+\n   /* If the src function contains an IFN_VA_ARG, then so will the dst\n      function after inlining.  Likewise for IFN_GOMP_USE_SIMT.  */\n   prop_mask = PROP_gimple_lva | PROP_gimple_lomp_dev;\n   src_properties = id->src_cfun->curr_properties & prop_mask;\n   if (src_properties != prop_mask)\n-    {\n-      struct function *dst_cfun = DECL_STRUCT_FUNCTION (id->dst_fn);\n-      dst_cfun->curr_properties &= src_properties | ~prop_mask;\n-    }\n+    dst_cfun->curr_properties &= src_properties | ~prop_mask;\n \n   gcc_assert (!id->src_cfun->after_inlining);\n \n@@ -4740,6 +4756,27 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)\n   if (cfun->gimple_df)\n     pt_solution_reset (&cfun->gimple_df->escaped);\n \n+  /* Add new automatic variables to IFN_GOMP_SIMT_ENTER arguments.  */\n+  if (id->dst_simt_vars && id->dst_simt_vars->length () > 0)\n+    {\n+      size_t nargs = gimple_call_num_args (simtenter_stmt);\n+      vec<tree> *vars = id->dst_simt_vars;\n+      auto_vec<tree> newargs (nargs + vars->length ());\n+      for (size_t i = 0; i < nargs; i++)\n+\tnewargs.quick_push (gimple_call_arg (simtenter_stmt, i));\n+      for (tree *pvar = vars->begin (); pvar != vars->end (); pvar++)\n+\t{\n+\t  tree ptrtype = build_pointer_type (TREE_TYPE (*pvar));\n+\t  newargs.quick_push (build1 (ADDR_EXPR, ptrtype, *pvar));\n+\t}\n+      gcall *g = gimple_build_call_internal_vec (IFN_GOMP_SIMT_ENTER, newargs);\n+      gimple_call_set_lhs (g, gimple_call_lhs (simtenter_stmt));\n+      gimple_stmt_iterator gsi = gsi_for_stmt (simtenter_stmt);\n+      gsi_replace (&gsi, g, false);\n+    }\n+  vec_free (id->dst_simt_vars);\n+  id->dst_simt_vars = simtvars_save;\n+\n   /* Clean up.  */\n   if (id->debug_map)\n     {\n@@ -5463,9 +5500,19 @@ copy_decl_for_dup_finish (copy_body_data *id, tree decl, tree copy)\n        function.  */\n     ;\n   else\n-    /* Ordinary automatic local variables are now in the scope of the\n-       new function.  */\n-    DECL_CONTEXT (copy) = id->dst_fn;\n+    {\n+      /* Ordinary automatic local variables are now in the scope of the\n+\t new function.  */\n+      DECL_CONTEXT (copy) = id->dst_fn;\n+      if (VAR_P (copy) && id->dst_simt_vars && !is_gimple_reg (copy))\n+\t{\n+\t  if (!lookup_attribute (\"omp simt private\", DECL_ATTRIBUTES (copy)))\n+\t    DECL_ATTRIBUTES (copy)\n+\t      = tree_cons (get_identifier (\"omp simt private\"), NULL,\n+\t\t\t   DECL_ATTRIBUTES (copy));\n+\t  id->dst_simt_vars->safe_push (copy);\n+\t}\n+    }\n \n   return copy;\n }"}, {"sha": "ffb8333a7dd890841264c7eb69a0921d8f42bdf2", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b", "patch": "@@ -145,6 +145,10 @@ struct copy_body_data\n      equivalents in the function into which it is being inlined.  */\n   hash_map<dependence_hash, unsigned short> *dependence_map;\n \n+  /* A list of addressable local variables remapped into the caller\n+     when inlining a call within an OpenMP SIMD-on-SIMT loop.  */\n+  vec<tree> *dst_simt_vars;\n+\n   /* Cilk keywords currently need to replace some variables that\n      ordinary nested functions do not.  */\n   bool remap_var_for_cilk;"}, {"sha": "42e708ed673a81375492c06f5d4e2ba20d3cda97", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=0c6b03b5158f53a3c7042cf8625aa5e6bc74f52b", "patch": "@@ -1654,7 +1654,8 @@ execute_update_addresses_taken (void)\n \t\t  gimple_ior_addresses_taken (addresses_taken, stmt);\n \t\t  gimple_call_set_arg (stmt, 1, arg);\n \t\t}\n-\t      else if (is_asan_mark_p (stmt))\n+\t      else if (is_asan_mark_p (stmt)\n+\t\t       || gimple_call_internal_p (stmt, IFN_GOMP_SIMT_ENTER))\n \t\t;\n \t      else\n \t\tgimple_ior_addresses_taken (addresses_taken, stmt);\n@@ -1940,6 +1941,18 @@ execute_update_addresses_taken (void)\n \t\t\tcontinue;\n \t\t      }\n \t\t  }\n+\t\telse if (gimple_call_internal_p (stmt, IFN_GOMP_SIMT_ENTER))\n+\t\t  for (i = 1; i < gimple_call_num_args (stmt); i++)\n+\t\t    {\n+\t\t      tree *argp = gimple_call_arg_ptr (stmt, i);\n+\t\t      if (*argp == null_pointer_node)\n+\t\t\tcontinue;\n+\t\t      gcc_assert (TREE_CODE (*argp) == ADDR_EXPR\n+\t\t\t\t  && VAR_P (TREE_OPERAND (*argp, 0)));\n+\t\t      tree var = TREE_OPERAND (*argp, 0);\n+\t\t      if (bitmap_bit_p (suitable_for_renaming, DECL_UID (var)))\n+\t\t\t*argp = null_pointer_node;\n+\t\t    }\n \t\tfor (i = 0; i < gimple_call_num_args (stmt); ++i)\n \t\t  {\n \t\t    tree *argp = gimple_call_arg_ptr (stmt, i);"}]}