{"sha": "01d939e8fb624ea88487fd41ce93c238a5eb870a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFkOTM5ZThmYjYyNGVhODg0ODdmZDQxY2U5M2MyMzhhNWViODcwYQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-12-20T13:18:17Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-12-20T13:18:17Z"}, "message": "current_function -> cfun\n\nFrom-SVN: r31033", "tree": {"sha": "ef38c36222ccc381ac63f61190043f19cbf2124f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef38c36222ccc381ac63f61190043f19cbf2124f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01d939e8fb624ea88487fd41ce93c238a5eb870a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01d939e8fb624ea88487fd41ce93c238a5eb870a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01d939e8fb624ea88487fd41ce93c238a5eb870a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01d939e8fb624ea88487fd41ce93c238a5eb870a/comments", "author": null, "committer": null, "parents": [{"sha": "239a0f5ba54e5a19c4445835429ce113a68bebde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/239a0f5ba54e5a19c4445835429ce113a68bebde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/239a0f5ba54e5a19c4445835429ce113a68bebde"}], "stats": {"total": 434, "additions": 215, "deletions": 219}, "files": [{"sha": "19ce9063e876011e232bbdad19b7b9d35086e46e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01d939e8fb624ea88487fd41ce93c238a5eb870a", "patch": "@@ -1,5 +1,9 @@\n 1999-12-20  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n+\t* function.c (cfun): Renamed from current_function.  All users\n+\tchanged.\n+\t* function.h (cfun): Rename declaration as well.\n+\n \t* reload.h (struct insn_chain): Change live_throughout and dead_or_set\n \tto be of type regset_head, not regset.  All users changed by adding\n \taddress operator."}, {"sha": "282ffe9d5bd9c52dc77cf708af4ae4b391044d69", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=01d939e8fb624ea88487fd41ce93c238a5eb870a", "patch": "@@ -2739,13 +2739,13 @@ alpha_return_addr (count, frame)\n   if (count != 0)\n     return const0_rtx;\n \n-  reg = current_function->machine->ra_rtx;\n+  reg = cfun->machine->ra_rtx;\n   if (reg == NULL)\n     {\n       /* No rtx yet.  Invent one, and initialize it from $26 in\n \t the prologue.  */\n       reg = gen_reg_rtx (Pmode);\n-      current_function->machine->ra_rtx = reg;\n+      cfun->machine->ra_rtx = reg;\n       init = gen_rtx_SET (VOIDmode, reg, gen_rtx_REG (Pmode, REG_RA));\n \n       /* Emit the insn to the prologue with the other argument copies.  */\n@@ -2766,7 +2766,7 @@ alpha_ra_ever_killed ()\n   if (current_function_is_thunk)\n     return 0;\n #endif\n-  if (!current_function->machine->ra_rtx)\n+  if (!cfun->machine->ra_rtx)\n     return regs_ever_live[REG_RA];\n \n   push_topmost_sequence ();\n@@ -4090,7 +4090,7 @@ alpha_expand_epilogue ()\n   fp_is_frame_pointer = ((TARGET_OPEN_VMS && vms_is_stack_procedure)\n \t\t\t || (!TARGET_OPEN_VMS && frame_pointer_needed));\n \n-  eh_ofs = current_function->machine->eh_epilogue_sp_ofs;\n+  eh_ofs = cfun->machine->eh_epilogue_sp_ofs;\n   if (sa_size)\n     {\n       /* If we have a frame pointer, restore SP from it.  */"}, {"sha": "31c3555eb5fa75082fbd45719375f1d9c9f26a6a", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=01d939e8fb624ea88487fd41ce93c238a5eb870a", "patch": "@@ -5153,7 +5153,7 @@\n   \"! TARGET_OPEN_VMS\"\n   \"\n {\n-  current_function->machine->eh_epilogue_sp_ofs = operands[1];\n+  cfun->machine->eh_epilogue_sp_ofs = operands[1];\n   if (GET_CODE (operands[2]) != REG || REGNO (operands[2]) != 26)\n     {\n       rtx ra = gen_rtx_REG (Pmode, 26);"}, {"sha": "18124b4f12dc7ff7f0d94ed38e2f5785b4491385", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=01d939e8fb624ea88487fd41ce93c238a5eb870a", "patch": "@@ -245,7 +245,7 @@ struct machine_function\n   rtx stack_locals[(int) MAX_MACHINE_MODE][MAX_386_STACK_LOCALS];\n };\n \n-#define ix86_stack_locals (current_function->machine->stack_locals)\n+#define ix86_stack_locals (cfun->machine->stack_locals)\n \n /* which cpu are we scheduling for */\n enum processor_type ix86_cpu;"}, {"sha": "5af17e2c232e1640a943c3c7d7eda594af8f19d7", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=01d939e8fb624ea88487fd41ce93c238a5eb870a", "patch": "@@ -2763,8 +2763,7 @@ mem_min_alignment (mem, desired)\n \t  /* Check if the compiler has recorded some information\n \t     about the alignment of the base REG.  If reload has\n \t     completed, we already matched with proper alignments.  */\n-\t  if (((current_function != 0\n-\t\t&& REGNO_POINTER_ALIGN (regno) >= desired)\n+\t  if (((cfun != 0 && REGNO_POINTER_ALIGN (regno) >= desired)\n \t       || reload_completed)\n \t      && ((INTVAL (offset) & (desired - 1)) == 0))\n \t    return 1;"}, {"sha": "8fd7bf39f0fedb64b1ba41a8f65d6f6d07942b4e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=01d939e8fb624ea88487fd41ce93c238a5eb870a", "patch": "@@ -707,7 +707,7 @@ struct language_function\n \n /* The current C++-specific per-function global variables.  */\n \n-#define cp_function_chain (current_function->language)\n+#define cp_function_chain (cfun->language)\n \n /* In a destructor, the point at which all derived class destroying\n    has been done, just before any base class destroying will be done.  */\n@@ -737,14 +737,14 @@ struct language_function\n    expression for `*this'.  */\n \n #define current_class_ptr \\\n-  (current_function ? cp_function_chain->x_current_class_ptr : NULL_TREE)\n+  (cfun ? cp_function_chain->x_current_class_ptr : NULL_TREE)\n #define current_class_ref \\\n-  (current_function ? cp_function_chain->x_current_class_ref : NULL_TREE)\n+  (cfun ? cp_function_chain->x_current_class_ref : NULL_TREE)\n \n /* Information about the current statement tree.  */\n \n #define current_stmt_tree\t\t\t\\\n-  (current_function \t\t\t\t\\\n+  (cfun\t\t\t\t\t\t\\\n    ? &cp_function_chain->x_stmt_tree\t\t\\\n    : &scope_chain->x_stmt_tree)\n "}, {"sha": "8ef1d4f68cda6898b5f0beaa210d7e424e74fb9c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=01d939e8fb624ea88487fd41ce93c238a5eb870a", "patch": "@@ -491,7 +491,7 @@ struct binding_level\n /* The binding level currently in effect.  */\n \n #define current_binding_level\t\t\t\\\n-  (current_function\t\t\t\t\\\n+  (cfun\t\t\t\t\t\t\\\n    ? cp_function_chain->bindings   \t\t\\\n    : scope_chain->bindings)\n \n@@ -776,7 +776,7 @@ pushlevel (tag_transparent)\n {\n   struct binding_level *newlevel;\n \n-  if (current_function && !doing_semantic_analysis_p ())\n+  if (cfun && !doing_semantic_analysis_p ())\n     return;\n \n   /* Reuse or create a struct for this binding level.  */\n@@ -1135,7 +1135,7 @@ poplevel (keep, reverse, functionbody)\n   int block_previously_created;\n   int leaving_for_scope;\n \n-  if (current_function && !doing_semantic_analysis_p ())\n+  if (cfun && !doing_semantic_analysis_p ())\n     return NULL_TREE;\n \n   my_friendly_assert (current_binding_level->parm_flag != 2,\n@@ -1379,7 +1379,7 @@ poplevel (keep, reverse, functionbody)\n \n   /* Any uses of undefined labels now operate under constraints\n      of next binding contour.  */\n-  if (current_function)\n+  if (cfun)\n     {\n       struct binding_level *level_chain;\n       level_chain = current_binding_level->level_chain;\n@@ -2335,7 +2335,7 @@ maybe_push_to_top_level (pseudo)\n   b = scope_chain ? current_binding_level : 0;\n \n   /* If we're in the middle of some function, save our state.  */\n-  if (current_function)\n+  if (cfun)\n     {\n       need_pop = 1;\n       push_function_context_to (NULL_TREE);\n@@ -3605,7 +3605,7 @@ pushdecl (x)\n \n   /* We shouldn't be calling pushdecl when we're generating RTL for a\n      function that we already did semantic analysis on previously.  */\n-  my_friendly_assert (!current_function || doing_semantic_analysis_p (),\n+  my_friendly_assert (!cfun || doing_semantic_analysis_p (),\n \t\t      19990913);\n \n   name = DECL_ASSEMBLER_NAME (x);\n@@ -7616,7 +7616,7 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n   /* Handling __FUNCTION__ and its ilk in a template-function requires\n      some special processing because we are called from\n      language-independent code.  */\n-  if (current_function && processing_template_decl \n+  if (cfun && processing_template_decl \n       && current_function_name_declared == 2)\n     {\n       /* Since we're in a template function, we need to\n@@ -13068,8 +13068,7 @@ start_function (declspecs, declarator, attrs, flags)\n   /* Initialize RTL machinery.  We cannot do this until\n      CURRENT_FUNCTION_DECL and DECL_RESULT are set up.  We do this\n      even when processing a template; this is how we get\n-     CURRENT_FUNCTION set up, and our per-function variables\n-     initialized.  */\n+     CFUN set up, and our per-function variables initialized.  */\n   bl = current_binding_level;\n   init_function_start (decl1, input_filename, lineno);\n   current_binding_level = bl;\n@@ -13080,7 +13079,7 @@ start_function (declspecs, declarator, attrs, flags)\n      We haven't necessarily assigned RTL to all variables yet, so it's\n      not safe to try to expand expressions involving them.  */\n   immediate_size_expand = 0;\n-  current_function->x_dont_save_pending_sizes_p = 1;\n+  cfun->x_dont_save_pending_sizes_p = 1;\n \n   /* If we're building a statement-tree, start the tree now.  */\n   if (processing_template_decl || !expanding_p)\n@@ -13114,7 +13113,7 @@ start_function (declspecs, declarator, attrs, flags)\n \n   /* Reset these in case the call to pushdecl changed them.  */\n   current_function_decl = decl1;\n-  current_function->decl = decl1;\n+  cfun->decl = decl1;\n \n   /* Initialize the per-function data.  */\n   if (!DECL_PENDING_INLINE_P (decl1) && DECL_SAVED_FUNCTION_DATA (decl1))\n@@ -13127,7 +13126,7 @@ start_function (declspecs, declarator, attrs, flags)\n \n       /* This function is being processed in whole-function mode; we\n \t already did semantic analysis.  */\n-      current_function->x_whole_function_mode_p = 1;\n+      cfun->x_whole_function_mode_p = 1;\n \n       /* If we decided that we didn't want to inline this function,\n \t make sure the back-end knows that.  */\n@@ -13957,11 +13956,11 @@ finish_function (lineno, flags)\n   else\n     {\n       /* Clear out memory we no longer need.  */\n-      free_after_parsing (current_function);\n+      free_after_parsing (cfun);\n       /* Since we never call rest_of_compilation, we never clear\n-\t CURRENT_FUNCTION.  Do so explicitly.  */\n-      free_after_compilation (current_function);\n-      current_function = NULL;\n+\t CFUN.  Do so explicitly.  */\n+      free_after_compilation (cfun);\n+      cfun = NULL;\n     }\n \n   /* If this is a in-class inline definition, we may have to pop the"}, {"sha": "3e4cf2b36b28691a2acf665bc4be4fb7f796a5c7", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=01d939e8fb624ea88487fd41ce93c238a5eb870a", "patch": "@@ -2150,7 +2150,7 @@ emit_thunk (thunk_fndecl)\n       ASM_OUTPUT_MI_THUNK (asm_out_file, thunk_fndecl, delta, function);\n       assemble_end_function (thunk_fndecl, fnname);\n       current_function_decl = 0;\n-      current_function = 0;\n+      cfun = 0;\n     }\n #else /* ASM_OUTPUT_MI_THUNK */\n   {"}, {"sha": "1790ef4c3ec42945c7227e0ec61ab41df429060f", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=01d939e8fb624ea88487fd41ce93c238a5eb870a", "patch": "@@ -976,7 +976,7 @@ begin_compound_stmt (has_no_scope)\n \n   /* If this is the outermost block of the function, declare the\n      variables __FUNCTION__, __PRETTY_FUNCTION__, and so forth.  */\n-  if (current_function\n+  if (cfun\n       && !current_function_name_declared \n       && !has_no_scope)\n     {\n@@ -1351,7 +1351,7 @@ do_pushlevel ()\n     {\n       pushlevel (0);\n       if (!building_stmt_tree ()\n-\t  && !current_function->x_whole_function_mode_p)\n+\t  && !cfun->x_whole_function_mode_p)\n \tmy_friendly_abort (19991129);\n \n       if (building_stmt_tree () && !processing_template_decl)\n@@ -1408,7 +1408,7 @@ begin_stmt_expr ()\n   /* If we're outside a function, we won't have a statement-tree to\n      work with.  But, if we see a statement-expression we need to\n      create one.  */\n-  if (!current_function && !last_tree)\n+  if (! cfun && !last_tree)\n     begin_stmt_tree (&scope_chain->x_saved_tree);\n \n   keep_next_level (1);\n@@ -1452,7 +1452,7 @@ finish_stmt_expr (rtl_expr)\n \n   /* If we created a statement-tree for this statement-expression,\n      remove it now.  */ \n-  if (!current_function \n+  if (! cfun\n       && TREE_CHAIN (scope_chain->x_saved_tree) == NULL_TREE)\n     finish_stmt_tree (&scope_chain->x_saved_tree);\n \n@@ -2259,7 +2259,7 @@ finish_stmt_tree (t)\n   *t = stmt;\n   SET_LAST_STMT (NULL_TREE);\n \n-  if (current_function)\n+  if (cfun)\n     {\n       /* The line-number recorded in the outermost statement in a function\n \t is the line number of the end of the function.  */"}, {"sha": "8fb5179dc78cfe79cbe48ffe145b6bfcb4ed145e", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=01d939e8fb624ea88487fd41ce93c238a5eb870a", "patch": "@@ -5003,7 +5003,7 @@ mark_addressable (exp)\n \t\t      x);\n \tTREE_ADDRESSABLE (x) = 1;\n \tTREE_USED (x) = 1;\n-\tif (current_function && expanding_p)\n+\tif (cfun && expanding_p)\n \t  put_var_into_stack (x);\n \treturn 1;\n "}, {"sha": "4d407c42ffaf8f4f0cdddffd5a703d627e556965", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=01d939e8fb624ea88487fd41ce93c238a5eb870a", "patch": "@@ -156,12 +156,12 @@ static rtx sequence_result[SEQUENCE_RESULT_SIZE];\n /* During RTL generation, we also keep a list of free INSN rtl codes.  */\n static rtx free_insn;\n \n-#define first_insn (current_function->emit->x_first_insn)\n-#define last_insn (current_function->emit->x_last_insn)\n-#define cur_insn_uid (current_function->emit->x_cur_insn_uid)\n-#define last_linenum (current_function->emit->x_last_linenum)\n-#define last_filename (current_function->emit->x_last_filename)\n-#define first_label_num (current_function->emit->x_first_label_num)\n+#define first_insn (cfun->emit->x_first_insn)\n+#define last_insn (cfun->emit->x_last_insn)\n+#define cur_insn_uid (cfun->emit->x_cur_insn_uid)\n+#define last_linenum (cfun->emit->x_last_linenum)\n+#define last_filename (cfun->emit->x_last_filename)\n+#define first_label_num (cfun->emit->x_first_label_num)\n \n /* This is where the pointer to the obstack being used for RTL is stored.  */\n extern struct obstack *rtl_obstack;\n@@ -453,7 +453,7 @@ rtx\n gen_reg_rtx (mode)\n      enum machine_mode mode;\n {\n-  struct function *f = current_function;\n+  struct function *f = cfun;\n   register rtx val;\n \n   /* Don't let anything called after initial flow analysis create new\n@@ -3643,7 +3643,7 @@ copy_insn (insn)\n void\n init_emit ()\n {\n-  struct function *f = current_function;\n+  struct function *f = cfun;\n \n   f->emit = (struct emit_status *) xmalloc (sizeof (struct emit_status));\n   first_insn = NULL;"}, {"sha": "f90fdc93d8b368e2ed735fd990565b61fd5e3dba", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=01d939e8fb624ea88487fd41ce93c238a5eb870a", "patch": "@@ -2598,8 +2598,7 @@ init_eh ()\n void\n init_eh_for_function ()\n {\n-  current_function->eh\n-    = (struct eh_status *) xcalloc (1, sizeof (struct eh_status));\n+  cfun->eh = (struct eh_status *) xcalloc (1, sizeof (struct eh_status));\n   ehqueue = (struct eh_queue *) xcalloc (1, sizeof (struct eh_queue));\n   eh_return_context = NULL_RTX;\n   eh_return_stack_adjust = NULL_RTX;"}, {"sha": "6120af4b30c777dead65776205b31c5b8d31b4d7", "filename": "gcc/except.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=01d939e8fb624ea88487fd41ce93c238a5eb870a", "patch": "@@ -138,15 +138,15 @@ struct eh_status\n   rtx x_eh_return_stub_label;\n };\n \n-#define ehstack (current_function->eh->x_ehstack)\n-#define catchstack (current_function->eh->x_catchstack)\n-#define ehqueue (current_function->eh->x_ehqueue)\n-#define catch_clauses (current_function->eh->x_catch_clauses)\n-#define false_label_stack (current_function->eh->x_false_label_stack)\n-#define caught_return_label_stack (current_function->eh->x_caught_return_label_stack)\n-#define protect_list (current_function->eh->x_protect_list)\n-#define current_function_ehc (current_function->eh->ehc)\n-#define eh_return_stub_label (current_function->eh->x_eh_return_stub_label)\n+#define ehstack (cfun->eh->x_ehstack)\n+#define catchstack (cfun->eh->x_catchstack)\n+#define ehqueue (cfun->eh->x_ehqueue)\n+#define catch_clauses (cfun->eh->x_catch_clauses)\n+#define false_label_stack (cfun->eh->x_false_label_stack)\n+#define caught_return_label_stack (cfun->eh->x_caught_return_label_stack)\n+#define protect_list (cfun->eh->x_protect_list)\n+#define current_function_ehc (cfun->eh->ehc)\n+#define eh_return_stub_label (cfun->eh->x_eh_return_stub_label)\n \n #ifdef TREE_CODE\n /* Start an exception handling region.  All instructions emitted after"}, {"sha": "71210c01050d476d37acc8e897ab1fa8d29ecf83", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=01d939e8fb624ea88487fd41ce93c238a5eb870a", "patch": "@@ -285,8 +285,7 @@ init_expr_once ()\n void\n init_expr ()\n {\n-  current_function->expr\n-    = (struct expr_status *) xmalloc (sizeof (struct expr_status));\n+  cfun->expr = (struct expr_status *) xmalloc (sizeof (struct expr_status));\n \n   pending_chain = 0;\n   pending_stack_adjust = 0;\n@@ -2671,8 +2670,7 @@ emit_move_insn_1 (x, y)\n \n \t\t      rtx cmem = change_address (mem, mode, NULL_RTX);\n \n-\t\t      current_function->cannot_inline\n-\t\t\t= \"function uses short complex types\";\n+\t\t      cfun->cannot_inline = \"function uses short complex types\";\n \n \t\t      if (packed_dest_p)\n \t\t\t{\n@@ -5873,7 +5871,7 @@ expand_expr (exp, target, tmode, modifier)\n \t memory protection).\n \n \t Aggregates are not checked here; they're handled elsewhere.  */\n-      if (current_function && current_function_check_memory_usage\n+      if (cfun && current_function_check_memory_usage\n \t  && code == VAR_DECL\n \t  && GET_CODE (DECL_RTL (exp)) == MEM\n \t  && ! AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n@@ -6391,7 +6389,7 @@ expand_expr (exp, target, tmode, modifier)\n \top0 = expand_expr (exp1, NULL_RTX, VOIDmode, EXPAND_SUM);\n \top0 = memory_address (mode, op0);\n \n-\tif (current_function && current_function_check_memory_usage\n+\tif (cfun && current_function_check_memory_usage\n \t    && ! AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n \t  {\n \t    enum memory_use_mode memory_usage;"}, {"sha": "9a73e1286a0bff3f3996007ab421bee0e66073ff", "filename": "gcc/function.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=01d939e8fb624ea88487fd41ce93c238a5eb870a", "patch": "@@ -140,7 +140,7 @@ void (*free_lang_status) PROTO((struct function *));\n tree inline_function_decl;\n \n /* The currently compiled function.  */\n-struct function *current_function = 0;\n+struct function *cfun = 0;\n \n /* Global list of all compiled functions.  */\n struct function *all_functions = 0;\n@@ -322,14 +322,14 @@ push_function_context_to (context)\n   if (context)\n     {\n       context_data = (context == current_function_decl\n-\t\t      ? current_function\n+\t\t      ? cfun\n \t\t      : find_function_data (context));\n       context_data->contains_functions = 1;\n     }\n \n-  if (current_function == 0)\n+  if (cfun == 0)\n     init_dummy_function_start ();\n-  p = current_function;\n+  p = cfun;\n \n   p->next = outer_function_chain;\n   outer_function_chain = p;\n@@ -341,7 +341,7 @@ push_function_context_to (context)\n   if (save_machine_status)\n     (*save_machine_status) (p);\n \n-  current_function = 0;\n+  cfun = 0;\n }\n \n void\n@@ -361,7 +361,7 @@ pop_function_context_from (context)\n   struct var_refs_queue *queue;\n   struct var_refs_queue *next;\n \n-  current_function = p;\n+  cfun = p;\n   outer_function_chain = p->next;\n \n   current_function_decl = p->decl;\n@@ -487,7 +487,7 @@ get_func_frame_size (f)\n HOST_WIDE_INT\n get_frame_size ()\n {\n-  return get_func_frame_size (current_function);\n+  return get_func_frame_size (cfun);\n }\n \n /* Allocate a stack slot of SIZE bytes and return a MEM rtx for it\n@@ -515,7 +515,7 @@ assign_stack_local_1 (mode, size, align, function)\n \n   /* Allocate in the memory associated with the function in whose frame\n      we are assigning.  */\n-  if (function != current_function)\n+  if (function != cfun)\n     push_obstacks (function->function_obstack,\n \t\t   function->function_maybepermanent_obstack);\n \n@@ -572,7 +572,7 @@ assign_stack_local_1 (mode, size, align, function)\n \n   /* If we have already instantiated virtual registers, return the actual\n      address relative to the frame pointer.  */\n-  if (function == current_function && virtuals_instantiated)\n+  if (function == cfun && virtuals_instantiated)\n     addr = plus_constant (frame_pointer_rtx,\n \t\t\t  (frame_offset + bigend_correction\n \t\t\t   + STARTING_FRAME_OFFSET));\n@@ -589,7 +589,7 @@ assign_stack_local_1 (mode, size, align, function)\n   function->x_stack_slot_list\n     = gen_rtx_EXPR_LIST (VOIDmode, x, function->x_stack_slot_list);\n \n-  if (function != current_function)\n+  if (function != cfun)\n     pop_obstacks ();\n \n   return x;\n@@ -603,7 +603,7 @@ assign_stack_local (mode, size, align)\n      HOST_WIDE_INT size;\n      int align;\n {\n-  return assign_stack_local_1 (mode, size, align, current_function);\n+  return assign_stack_local_1 (mode, size, align, cfun);\n }\n \f\n /* Allocate a temporary stack slot and record it for possible later\n@@ -1410,7 +1410,7 @@ put_reg_into_stack (function, reg, type, promoted_mode, decl_mode, volatile_p,\n      int used_p;\n      struct hash_table *ht;\n {\n-  struct function *func = function ? function : current_function;\n+  struct function *func = function ? function : cfun;\n   rtx new = 0;\n   int regno = original_regno;\n \n@@ -5442,7 +5442,7 @@ trampoline_address (function)\n #define TRAMPOLINE_REAL_SIZE (TRAMPOLINE_SIZE)\n #endif\n   tramp = assign_stack_local_1 (BLKmode, TRAMPOLINE_REAL_SIZE, 0,\n-\t\t\t\tfp ? fp : current_function);\n+\t\t\t\tfp ? fp : cfun);\n #endif\n \n   /* Record the trampoline for reuse and note it for later initialization\n@@ -5558,7 +5558,7 @@ identify_blocks (block, insns)\n   /* In whole-function mode, we might not have seen the whole function\n      yet, so we might not use up all the blocks.  */\n   if (n_blocks != current_block_number \n-      && !current_function->x_whole_function_mode_p)\n+      && !cfun->x_whole_function_mode_p)\n     abort ();\n \n   free (block_vector);\n@@ -5665,7 +5665,7 @@ all_blocks (block, vector)\n static void\n prepare_function_start ()\n {\n-  current_function = (struct function *) xcalloc (1, sizeof (struct function));\n+  cfun = (struct function *) xcalloc (1, sizeof (struct function));\n \n   init_stmt_for_function ();\n   init_eh_for_function ();\n@@ -5706,14 +5706,14 @@ prepare_function_start ()\n   /* We haven't done register allocation yet.  */\n   reg_renumber = 0;\n \n-  init_varasm_status (current_function);\n+  init_varasm_status (cfun);\n \n   /* Clear out data used for inlining.  */\n-  current_function->inlinable = 0;\n-  current_function->original_decl_initial = 0;\n-  current_function->original_arg_vector = 0;  \n+  cfun->inlinable = 0;\n+  cfun->original_decl_initial = 0;\n+  cfun->original_arg_vector = 0;  \n \n-  current_function->stack_alignment_needed = 0;\n+  cfun->stack_alignment_needed = 0;\n \n   /* Set if a call to setjmp is seen.  */\n   current_function_calls_setjmp = 0;\n@@ -5777,9 +5777,9 @@ prepare_function_start ()\n   current_function_outgoing_args_size = 0;\n \n   if (init_lang_status)\n-    (*init_lang_status) (current_function);\n+    (*init_lang_status) (cfun);\n   if (init_machine_status)\n-    (*init_machine_status) (current_function);\n+    (*init_machine_status) (cfun);\n }\n \n /* Initialize the rtl expansion mechanism so that we can do simple things\n@@ -5804,11 +5804,11 @@ init_function_start (subr, filename, line)\n   prepare_function_start ();\n \n   /* Remember this function for later.  */\n-  current_function->next_global = all_functions;\n-  all_functions = current_function;\n+  cfun->next_global = all_functions;\n+  all_functions = cfun;\n   \n   current_function_name = (*decl_printable_name) (subr, 2);\n-  current_function->decl = subr;\n+  cfun->decl = subr;\n \n   /* Nonzero if this is a nested function that uses a static chain.  */\n \n@@ -6158,10 +6158,10 @@ expand_dummy_function_end ()\n   /* Outside function body, can't compute type's actual size\n      until next function's body starts.  */\n \n-  free_after_parsing (current_function);\n-  free_after_compilation (current_function);\n-  free (current_function);\n-  current_function = 0;\n+  free_after_parsing (cfun);\n+  free_after_compilation (cfun);\n+  free (cfun);\n+  cfun = 0;\n }\n \n /* Emit CODE for each register of the return value.  Useful values for"}, {"sha": "e252f7550fee30fa20a6a44c1ffc51e9ac53d627", "filename": "gcc/function.h", "status": "modified", "additions": 71, "deletions": 70, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=01d939e8fb624ea88487fd41ce93c238a5eb870a", "patch": "@@ -115,15 +115,13 @@ struct emit_status\n };\n \n /* For backward compatibility... eventually these should all go away.  */\n-#define reg_rtx_no (current_function->emit->x_reg_rtx_no)\n-#define seq_rtl_expr (current_function->emit->sequence_rtl_expr)\n-#define regno_reg_rtx (current_function->emit->x_regno_reg_rtx)\n-#define seq_stack (current_function->emit->sequence_stack)\n+#define reg_rtx_no (cfun->emit->x_reg_rtx_no)\n+#define seq_rtl_expr (cfun->emit->sequence_rtl_expr)\n+#define regno_reg_rtx (cfun->emit->x_regno_reg_rtx)\n+#define seq_stack (cfun->emit->sequence_stack)\n \n-#define REGNO_POINTER_ALIGN(REGNO) \\\n-  (current_function->emit->regno_pointer_align[REGNO])\n-#define REGNO_POINTER_FLAG(REGNO) \\\n-  (current_function->emit->regno_pointer_flag[REGNO])\n+#define REGNO_POINTER_ALIGN(REGNO) (cfun->emit->regno_pointer_align[REGNO])\n+#define REGNO_POINTER_FLAG(REGNO) (cfun->emit->regno_pointer_flag[REGNO])\n \n struct expr_status\n {\n@@ -163,12 +161,12 @@ struct expr_status\n   rtx x_pending_chain;\n };\n \n-#define pending_stack_adjust (current_function->expr->x_pending_stack_adjust)\n-#define inhibit_defer_pop (current_function->expr->x_inhibit_defer_pop)\n-#define saveregs_value (current_function->expr->x_saveregs_value)\n-#define apply_args_value (current_function->expr->x_apply_args_value)\n-#define forced_labels (current_function->expr->x_forced_labels)\n-#define pending_chain (current_function->expr->x_pending_chain)\n+#define pending_stack_adjust (cfun->expr->x_pending_stack_adjust)\n+#define inhibit_defer_pop (cfun->expr->x_inhibit_defer_pop)\n+#define saveregs_value (cfun->expr->x_saveregs_value)\n+#define apply_args_value (cfun->expr->x_apply_args_value)\n+#define forced_labels (cfun->expr->x_forced_labels)\n+#define pending_chain (cfun->expr->x_pending_chain)\n \n /* This structure can save all the important global and static variables\n    describing the status of the current function.  */\n@@ -469,65 +467,68 @@ struct function\n   rtx epilogue_delay_list;\n };\n \n-extern struct function *current_function;\n+/* The function currently being compiled.  */\n+extern struct function *cfun;\n+\n+/* A list of all functions we have compiled so far.  */\n extern struct function *all_functions;\n \n /* For backward compatibility... eventually these should all go away.  */\n-#define current_function_name (current_function->name)\n-#define current_function_pops_args (current_function->pops_args)\n-#define current_function_returns_struct (current_function->returns_struct)\n-#define current_function_returns_pcc_struct (current_function->returns_pcc_struct)\n-#define current_function_returns_pointer (current_function->returns_pointer)\n-#define current_function_needs_context (current_function->needs_context)\n-#define current_function_calls_setjmp (current_function->calls_setjmp)\n-#define current_function_calls_alloca (current_function->calls_alloca)\n-#define current_function_calls_longjmp (current_function->calls_longjmp)\n-#define current_function_has_computed_jump (current_function->has_computed_jump)\n-#define current_function_contains_functions (current_function->contains_functions)\n-#define current_function_is_thunk (current_function->is_thunk)\n-#define current_function_args_info (current_function->args_info)\n-#define current_function_args_size (current_function->args_size)\n-#define current_function_pretend_args_size (current_function->pretend_args_size)\n-#define current_function_outgoing_args_size (current_function->outgoing_args_size)\n-#define current_function_arg_offset_rtx (current_function->arg_offset_rtx)\n-#define current_function_varargs (current_function->varargs)\n-#define current_function_stdarg (current_function->stdarg)\n-#define current_function_internal_arg_pointer (current_function->internal_arg_pointer)\n-#define current_function_return_rtx (current_function->return_rtx)\n-#define current_function_instrument_entry_exit (current_function->instrument_entry_exit)\n-#define current_function_check_memory_usage (current_function->check_memory_usage)\n-#define current_function_limit_stack (current_function->limit_stack)\n-#define current_function_uses_pic_offset_table (current_function->uses_pic_offset_table)\n-#define current_function_uses_const_pool (current_function->uses_const_pool)\n-#define current_function_cannot_inline (current_function->cannot_inline)\n-#define current_function_epilogue_delay_list (current_function->epilogue_delay_list)\n-#define current_function_has_nonlocal_label (current_function->has_nonlocal_label)\n-#define current_function_has_nonlocal_goto (current_function->has_nonlocal_goto)\n-\n-#define max_parm_reg (current_function->x_max_parm_reg)\n-#define parm_reg_stack_loc (current_function->x_parm_reg_stack_loc)\n-#define cleanup_label (current_function->x_cleanup_label)\n-#define return_label (current_function->x_return_label)\n-#define save_expr_regs (current_function->x_save_expr_regs)\n-#define stack_slot_list (current_function->x_stack_slot_list)\n-#define parm_birth_insn (current_function->x_parm_birth_insn)\n-#define frame_offset (current_function->x_frame_offset)\n-#define tail_recursion_label (current_function->x_tail_recursion_label)\n-#define tail_recursion_reentry (current_function->x_tail_recursion_reentry)\n-#define arg_pointer_save_area (current_function->x_arg_pointer_save_area)\n-#define rtl_expr_chain (current_function->x_rtl_expr_chain)\n-#define last_parm_insn (current_function->x_last_parm_insn)\n-#define context_display (current_function->x_context_display)\n-#define trampoline_list (current_function->x_trampoline_list)\n-#define function_call_count (current_function->x_function_call_count)\n-#define temp_slots (current_function->x_temp_slots)\n-#define temp_slot_level (current_function->x_temp_slot_level)\n-#define target_temp_slot_level (current_function->x_target_temp_slot_level)\n-#define var_temp_slot_level (current_function->x_var_temp_slot_level)\n-#define nonlocal_labels (current_function->x_nonlocal_labels)\n-#define nonlocal_goto_handler_slots (current_function->x_nonlocal_goto_handler_slots)\n-#define nonlocal_goto_handler_labels (current_function->x_nonlocal_goto_handler_labels)\n-#define nonlocal_goto_stack_level (current_function->x_nonlocal_goto_stack_level)\n+#define current_function_name (cfun->name)\n+#define current_function_pops_args (cfun->pops_args)\n+#define current_function_returns_struct (cfun->returns_struct)\n+#define current_function_returns_pcc_struct (cfun->returns_pcc_struct)\n+#define current_function_returns_pointer (cfun->returns_pointer)\n+#define current_function_needs_context (cfun->needs_context)\n+#define current_function_calls_setjmp (cfun->calls_setjmp)\n+#define current_function_calls_alloca (cfun->calls_alloca)\n+#define current_function_calls_longjmp (cfun->calls_longjmp)\n+#define current_function_has_computed_jump (cfun->has_computed_jump)\n+#define current_function_contains_functions (cfun->contains_functions)\n+#define current_function_is_thunk (cfun->is_thunk)\n+#define current_function_args_info (cfun->args_info)\n+#define current_function_args_size (cfun->args_size)\n+#define current_function_pretend_args_size (cfun->pretend_args_size)\n+#define current_function_outgoing_args_size (cfun->outgoing_args_size)\n+#define current_function_arg_offset_rtx (cfun->arg_offset_rtx)\n+#define current_function_varargs (cfun->varargs)\n+#define current_function_stdarg (cfun->stdarg)\n+#define current_function_internal_arg_pointer (cfun->internal_arg_pointer)\n+#define current_function_return_rtx (cfun->return_rtx)\n+#define current_function_instrument_entry_exit (cfun->instrument_entry_exit)\n+#define current_function_check_memory_usage (cfun->check_memory_usage)\n+#define current_function_limit_stack (cfun->limit_stack)\n+#define current_function_uses_pic_offset_table (cfun->uses_pic_offset_table)\n+#define current_function_uses_const_pool (cfun->uses_const_pool)\n+#define current_function_cannot_inline (cfun->cannot_inline)\n+#define current_function_epilogue_delay_list (cfun->epilogue_delay_list)\n+#define current_function_has_nonlocal_label (cfun->has_nonlocal_label)\n+#define current_function_has_nonlocal_goto (cfun->has_nonlocal_goto)\n+\n+#define max_parm_reg (cfun->x_max_parm_reg)\n+#define parm_reg_stack_loc (cfun->x_parm_reg_stack_loc)\n+#define cleanup_label (cfun->x_cleanup_label)\n+#define return_label (cfun->x_return_label)\n+#define save_expr_regs (cfun->x_save_expr_regs)\n+#define stack_slot_list (cfun->x_stack_slot_list)\n+#define parm_birth_insn (cfun->x_parm_birth_insn)\n+#define frame_offset (cfun->x_frame_offset)\n+#define tail_recursion_label (cfun->x_tail_recursion_label)\n+#define tail_recursion_reentry (cfun->x_tail_recursion_reentry)\n+#define arg_pointer_save_area (cfun->x_arg_pointer_save_area)\n+#define rtl_expr_chain (cfun->x_rtl_expr_chain)\n+#define last_parm_insn (cfun->x_last_parm_insn)\n+#define context_display (cfun->x_context_display)\n+#define trampoline_list (cfun->x_trampoline_list)\n+#define function_call_count (cfun->x_function_call_count)\n+#define temp_slots (cfun->x_temp_slots)\n+#define temp_slot_level (cfun->x_temp_slot_level)\n+#define target_temp_slot_level (cfun->x_target_temp_slot_level)\n+#define var_temp_slot_level (cfun->x_var_temp_slot_level)\n+#define nonlocal_labels (cfun->x_nonlocal_labels)\n+#define nonlocal_goto_handler_slots (cfun->x_nonlocal_goto_handler_slots)\n+#define nonlocal_goto_handler_labels (cfun->x_nonlocal_goto_handler_labels)\n+#define nonlocal_goto_stack_level (cfun->x_nonlocal_goto_stack_level)\n \n /* The FUNCTION_DECL for an inline function currently being expanded.  */\n extern tree inline_function_decl;"}, {"sha": "4b4988b335d88d52c63c86784162b8ae51f9825a", "filename": "gcc/integrate.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=01d939e8fb624ea88487fd41ce93c238a5eb870a", "patch": "@@ -430,11 +430,11 @@ save_for_inline_nocopy (fndecl)\n \n   preserve_data ();\n \n-  current_function->inl_max_label_num = max_label_num ();\n-  current_function->inl_last_parm_insn = current_function->x_last_parm_insn;\n-  current_function->original_arg_vector = argvec;\n-  current_function->original_decl_initial = DECL_INITIAL (fndecl);\n-  DECL_SAVED_INSNS (fndecl) = current_function;\n+  cfun->inl_max_label_num = max_label_num ();\n+  cfun->inl_last_parm_insn = cfun->x_last_parm_insn;\n+  cfun->original_arg_vector = argvec;\n+  cfun->original_decl_initial = DECL_INITIAL (fndecl);\n+  DECL_SAVED_INSNS (fndecl) = cfun;\n \n   /* Clean up.  */\n   free (parmdecl_map);\n@@ -1395,7 +1395,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n   if (inl_f->calls_alloca)\n     emit_stack_restore (SAVE_BLOCK, stack_save, NULL_RTX);\n \n-  if (!current_function->x_whole_function_mode_p)\n+  if (! cfun->x_whole_function_mode_p)\n     /* In statement-at-a-time mode, we just tell the front-end to add\n        this block to the list of blocks at this binding level.  We\n        can't do it the way it's done for function-at-a-time mode the\n@@ -1810,7 +1810,7 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n \t remapped label.  Otherwise, symbols are returned unchanged.  */\n       if (CONSTANT_POOL_ADDRESS_P (orig))\n \t{\n-\t  struct function *f = inlining ? inlining : current_function;\n+\t  struct function *f = inlining ? inlining : cfun;\n \t  rtx constant = get_pool_constant_for_function (f, orig);\n \t  enum machine_mode const_mode = get_pool_mode_for_function (f, orig);\n \t  if (inlining)\n@@ -2572,10 +2572,10 @@ void\n output_inline_function (fndecl)\n      tree fndecl;\n {\n-  struct function *curf = current_function;\n+  struct function *old_cfun = cfun;\n   struct function *f = DECL_SAVED_INSNS (fndecl);\n \n-  current_function = f;\n+  cfun = f;\n   current_function_decl = fndecl;\n   clear_emit_caches ();\n \n@@ -2606,6 +2606,6 @@ output_inline_function (fndecl)\n   /* Compile this function all the way down to assembly code.  */\n   rest_of_compilation (fndecl);\n \n-  current_function = curf;\n-  current_function_decl = curf ? curf->decl : 0;\n+  cfun = old_cfun;\n+  current_function_decl = old_cfun ? old_cfun->decl : 0;\n }"}, {"sha": "1562ae5918603deaeeb186b7ff840aa57e908e53", "filename": "gcc/stmt.c", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=01d939e8fb624ea88487fd41ce93c238a5eb870a", "patch": "@@ -378,20 +378,20 @@ struct stmt_status\n   struct goto_fixup *x_goto_fixup_chain;\n };\n \n-#define block_stack (current_function->stmt->x_block_stack)\n-#define stack_block_stack (current_function->stmt->x_stack_block_stack)\n-#define cond_stack (current_function->stmt->x_cond_stack)\n-#define loop_stack (current_function->stmt->x_loop_stack)\n-#define case_stack (current_function->stmt->x_case_stack)\n-#define nesting_stack (current_function->stmt->x_nesting_stack)\n-#define nesting_depth (current_function->stmt->x_nesting_depth)\n-#define current_block_start_count (current_function->stmt->x_block_start_count)\n-#define last_expr_type (current_function->stmt->x_last_expr_type)\n-#define last_expr_value (current_function->stmt->x_last_expr_value)\n-#define expr_stmts_for_value (current_function->stmt->x_expr_stmts_for_value)\n-#define emit_filename (current_function->stmt->x_emit_filename)\n-#define emit_lineno (current_function->stmt->x_emit_lineno)\n-#define goto_fixup_chain (current_function->stmt->x_goto_fixup_chain)\n+#define block_stack (cfun->stmt->x_block_stack)\n+#define stack_block_stack (cfun->stmt->x_stack_block_stack)\n+#define cond_stack (cfun->stmt->x_cond_stack)\n+#define loop_stack (cfun->stmt->x_loop_stack)\n+#define case_stack (cfun->stmt->x_case_stack)\n+#define nesting_stack (cfun->stmt->x_nesting_stack)\n+#define nesting_depth (cfun->stmt->x_nesting_depth)\n+#define current_block_start_count (cfun->stmt->x_block_start_count)\n+#define last_expr_type (cfun->stmt->x_last_expr_type)\n+#define last_expr_value (cfun->stmt->x_last_expr_value)\n+#define expr_stmts_for_value (cfun->stmt->x_expr_stmts_for_value)\n+#define emit_filename (cfun->stmt->x_emit_filename)\n+#define emit_lineno (cfun->stmt->x_emit_lineno)\n+#define goto_fixup_chain (cfun->stmt->x_goto_fixup_chain)\n \n /* Non-zero if we are using EH to handle cleanus.  */\n static int using_eh_for_cleanups_p = 0;\n@@ -605,8 +605,7 @@ init_stmt ()\n void\n init_stmt_for_function ()\n {\n-  current_function->stmt\n-    = (struct stmt_status *) xmalloc (sizeof (struct stmt_status));\n+  cfun->stmt = (struct stmt_status *) xmalloc (sizeof (struct stmt_status));\n \n   /* We are not currently within any block, conditional, loop or case.  */\n   block_stack = 0;\n@@ -1030,7 +1029,7 @@ expand_fixup (tree_label, rtl_label, last_insn)\n \tblock = make_node (BLOCK);\n \tTREE_USED (block) = 1;\n \n-\tif (!current_function->x_whole_function_mode_p)\n+\tif (!cfun->x_whole_function_mode_p)\n \t  insert_block (block);\n \telse\n \t  {\n@@ -1042,11 +1041,11 @@ expand_fixup (tree_label, rtl_label, last_insn)\n \n         start_sequence ();\n         start = emit_note (NULL_PTR, NOTE_INSN_BLOCK_BEG);\n-\tif (current_function->x_whole_function_mode_p)\n+\tif (cfun->x_whole_function_mode_p)\n \t  NOTE_BLOCK (start) = block;\n \tfixup->before_jump = emit_note (NULL_PTR, NOTE_INSN_DELETED);\n \tend = emit_note (NULL_PTR, NOTE_INSN_BLOCK_END);\n-\tif (current_function->x_whole_function_mode_p)\n+\tif (cfun->x_whole_function_mode_p)\n \t  NOTE_BLOCK (end) = block;\n         fixup->context = block;\n         end_sequence ();\n@@ -2630,8 +2629,7 @@ preserve_subexpressions_p ()\n   if (flag_expensive_optimizations)\n     return 1;\n \n-  if (optimize == 0 || current_function == 0 \n-      || current_function->stmt == 0 || loop_stack == 0)\n+  if (optimize == 0 || cfun == 0 || cfun->stmt == 0 || loop_stack == 0)\n     return 0;\n \n   insn = get_last_insn_anywhere ();\n@@ -3359,8 +3357,7 @@ mark_block_as_not_eh_region ()\n int\n is_eh_region ()\n {\n-  return (current_function && block_stack\n-\t  && block_stack->data.block.exception_region);\n+  return cfun && block_stack && block_stack->data.block.exception_region;\n }\n \n /* Emit a handler label for a nonlocal goto handler.\n@@ -3970,7 +3967,7 @@ expand_decl_cleanup (decl, cleanup)\n   struct nesting *thisblock;\n \n   /* Error if we are not in any block.  */\n-  if (current_function == 0 || block_stack == 0)\n+  if (cfun == 0 || block_stack == 0)\n     return 0;\n \n   thisblock = block_stack;\n@@ -4104,7 +4101,7 @@ expand_dcc_cleanup (decl)\n   tree cleanup;\n \n   /* Error if we are not in any block.  */\n-  if (current_function == 0 || block_stack == 0)\n+  if (cfun == 0 || block_stack == 0)\n     return 0;\n   thisblock = block_stack;\n \n@@ -4146,7 +4143,7 @@ expand_dhc_cleanup (decl)\n   tree cleanup;\n \n   /* Error if we are not in any block.  */\n-  if (current_function == 0 || block_stack == 0)\n+  if (cfun == 0 || block_stack == 0)\n     return 0;\n   thisblock = block_stack;\n \n@@ -4175,7 +4172,7 @@ void\n expand_anon_union_decl (decl, cleanup, decl_elts)\n      tree decl, cleanup, decl_elts;\n {\n-  struct nesting *thisblock = current_function == 0 ? 0 : block_stack;\n+  struct nesting *thisblock = cfun == 0 ? 0 : block_stack;\n   rtx x;\n   tree t;\n \n@@ -4381,8 +4378,7 @@ any_pending_cleanups (this_contour)\n {\n   struct nesting *block;\n \n-  if (current_function == NULL || current_function->stmt == NULL\n-      || block_stack == 0)\n+  if (cfun == NULL || cfun->stmt == NULL || block_stack == 0)\n     return 0;\n \n   if (this_contour && block_stack->data.block.cleanups != NULL)"}, {"sha": "cbc867280089754cdfba1c9acb14edbe9e273a2b", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=01d939e8fb624ea88487fd41ce93c238a5eb870a", "patch": "@@ -123,8 +123,8 @@ variable_size (size)\n        Also, we would like to pass const0_rtx here, but don't have it.  */\n     expand_expr (size, expand_expr (integer_zero_node, NULL_PTR, VOIDmode, 0),\n \t\t VOIDmode, 0);\n-  else if (current_function != 0\n-\t   && current_function->x_dont_save_pending_sizes_p)\n+  else if (cfun != 0\n+\t   && cfun->x_dont_save_pending_sizes_p)\n     /* The front-end doesn't want us to keep a list of the expressions\n        that determine sizes for variable size objects.  */\n     ;"}, {"sha": "a8dd7b2a517591b842ab0cb8088a6267aab988de", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=01d939e8fb624ea88487fd41ce93c238a5eb870a", "patch": "@@ -2752,7 +2752,7 @@ rest_of_compilation (decl)\n \n   /* In function-at-a-time mode, we do not attempt to keep the BLOCK\n      tree in sensible shape.  So, we just recalculate it here.  */\n-  if (current_function->x_whole_function_mode_p)\n+  if (cfun->x_whole_function_mode_p)\n     {\n       find_loop_tree_blocks ();\n       unroll_block_trees ();\n@@ -3676,10 +3676,10 @@ rest_of_compilation (decl)\n   init_recog_no_volatile ();\n \n   /* We're done with this function.  Free up memory if we can.  */\n-  free_after_parsing (current_function);\n+  free_after_parsing (cfun);\n   if (! DECL_DEFER_OUTPUT (decl))\n-    free_after_compilation (current_function);\n-  current_function = 0;\n+    free_after_compilation (cfun);\n+  cfun = 0;\n \n   if (ggc_p)\n     ggc_collect ();"}, {"sha": "5b359a9962e133a8a6ab3853c6807b5708a647dd", "filename": "gcc/unroll.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=01d939e8fb624ea88487fd41ce93c238a5eb870a", "patch": "@@ -1180,8 +1180,8 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n     }\n \n   /* Use our current register alignment and pointer flags.  */\n-  map->regno_pointer_flag = current_function->emit->regno_pointer_flag;\n-  map->regno_pointer_align = current_function->emit->regno_pointer_align;\n+  map->regno_pointer_flag = cfun->emit->regno_pointer_flag;\n+  map->regno_pointer_align = cfun->emit->regno_pointer_align;\n \n   /* If the loop is being partially unrolled, and the iteration variables\n      are being split, and are being renamed for the split, then must fix up"}, {"sha": "efe2c0605eed5553864b4e91d5de229d557baa71", "filename": "gcc/varasm.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d939e8fb624ea88487fd41ce93c238a5eb870a/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=01d939e8fb624ea88487fd41ce93c238a5eb870a", "patch": "@@ -120,12 +120,12 @@ struct varasm_status\n   rtx x_const_double_chain;\n };\n \n-#define const_rtx_hash_table (current_function->varasm->x_const_rtx_hash_table)\n-#define const_rtx_sym_hash_table (current_function->varasm->x_const_rtx_sym_hash_table)\n-#define first_pool (current_function->varasm->x_first_pool)\n-#define last_pool (current_function->varasm->x_last_pool)\n-#define pool_offset (current_function->varasm->x_pool_offset)\n-#define const_double_chain (current_function->varasm->x_const_double_chain)\n+#define const_rtx_hash_table (cfun->varasm->x_const_rtx_hash_table)\n+#define const_rtx_sym_hash_table (cfun->varasm->x_const_rtx_sym_hash_table)\n+#define first_pool (cfun->varasm->x_first_pool)\n+#define last_pool (cfun->varasm->x_last_pool)\n+#define pool_offset (cfun->varasm->x_pool_offset)\n+#define const_double_chain (cfun->varasm->x_const_double_chain)\n \n /* Number for making the label on the next\n    constant that is stored in memory.  */\n@@ -2108,7 +2108,7 @@ immed_double_const (i0, i1, mode)\n \n   /* Search the chain for an existing CONST_DOUBLE with the right value.\n      If one is found, return it.  */\n-  if (current_function != 0)\n+  if (cfun != 0)\n     for (r = const_double_chain; r; r = CONST_DOUBLE_CHAIN (r))\n       if (CONST_DOUBLE_LOW (r) == i0 && CONST_DOUBLE_HIGH (r) == i1\n \t  && GET_MODE (r) == mode)\n@@ -2180,7 +2180,7 @@ immed_real_const_1 (d, mode)\n \n   /* Search the chain for an existing CONST_DOUBLE with the right value.\n      If one is found, return it.  */\n-  if (current_function != 0)\n+  if (cfun != 0)\n     for (r = const_double_chain; r; r = CONST_DOUBLE_CHAIN (r))\n       if (! bcmp ((char *) &CONST_DOUBLE_LOW (r), (char *) &u, sizeof u)\n \t  && GET_MODE (r) == mode)\n@@ -3686,7 +3686,7 @@ rtx\n get_pool_constant (addr)\n      rtx addr;\n {\n-  return (find_pool_constant (current_function, addr))->constant;\n+  return (find_pool_constant (cfun, addr))->constant;\n }\n \n /* Likewise, but for the constant pool of a specific function.  */\n@@ -3705,7 +3705,7 @@ enum machine_mode\n get_pool_mode (addr)\n      rtx addr;\n {\n-  return (find_pool_constant (current_function, addr))->mode;\n+  return (find_pool_constant (cfun, addr))->mode;\n }\n \n enum machine_mode\n@@ -3722,7 +3722,7 @@ int\n get_pool_offset (addr)\n      rtx addr;\n {\n-  return (find_pool_constant (current_function, addr))->offset;\n+  return (find_pool_constant (cfun, addr))->offset;\n }\n \n /* Return the size of the constant pool.  */\n@@ -3895,7 +3895,7 @@ mark_constants (x)\n   if (GET_CODE (x) == SYMBOL_REF)\n     {\n       if (CONSTANT_POOL_ADDRESS_P (x))\n-\tfind_pool_constant (current_function, x)->mark = 1;\n+\tfind_pool_constant (cfun, x)->mark = 1;\n       return;\n     }\n   /* Never search inside a CONST_DOUBLE, because CONST_DOUBLE_MEM may be"}]}