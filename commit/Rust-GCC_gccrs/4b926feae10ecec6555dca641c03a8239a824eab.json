{"sha": "4b926feae10ecec6555dca641c03a8239a824eab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI5MjZmZWFlMTBlY2VjNjU1NWRjYTY0MWMwM2E4MjM5YTgyNGVhYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-11-01T12:30:39Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-11-01T12:30:39Z"}, "message": "Widening optab cleanup\n\nwidening_optab_handler had the comment:\n\n      /* ??? Why does find_widening_optab_handler_and_mode attempt to\n         widen things that can't be widened?  E.g. add_optab... */\n      if (op > LAST_CONV_OPTAB)\n        return CODE_FOR_nothing;\n\nI think it comes from expand_binop using\nfind_widening_optab_handler_and_mode for two things: to test whether\na \"normal\" optab like add_optab is supported for a standard binary\noperation and to test whether a \"convert\" optab is supported for a\nwidening operation like umul_widen_optab.  In the former case from_mode\nand to_mode must be the same, in the latter from_mode must be narrower\nthan to_mode.\n\nFor the former case, find_widening_optab_handler_and_mode is only really\ntesting the modes that are passed in.  permit_non_widening must be true\nhere.\n\nFor the latter case, find_widening_optab_handler_and_mode should only\nreally consider new from_modes that are wider than the original\nfrom_mode and narrower than the original to_mode.  Logically\npermit_non_widening should be false, since widening optabs aren't\nsupposed to take operands that are the same width as the destination.\nWe get away with permit_non_widening being true because no target\nwould/should define a widening .md pattern with matching modes.\n\nBut really, it seems better for expand_binop to handle these two\ncases itself rather than pushing them down.  With that change,\nfind_widening_optab_handler_and_mode is only ever called with\npermit_non_widening set to false and is only ever called with\na \"proper\" convert optab.  We then no longer need widening_optab_handler,\nwe can just use convert_optab_handler directly.\n\nThe patch also passes the instruction code down to expand_binop_directly.\nThis should be more efficient and removes an extra call to\nfind_widening_optab_handler_and_mode.\n\n2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* optabs-query.h (convert_optab_p): New function, split out from...\n\t(convert_optab_handler): ...here.\n\t(widening_optab_handler): Delete.\n\t(find_widening_optab_handler): Remove permit_non_widening parameter.\n\t(find_widening_optab_handler_and_mode): Likewise.  Provide an\n\toverride that operates on mode class wrappers.\n\t* optabs-query.c (widening_optab_handler): Delete.\n\t(find_widening_optab_handler_and_mode): Remove permit_non_widening\n\tparameter.  Assert that the two modes are the same class and that\n\tthe \"from\" mode is narrower than the \"to\" mode.  Use\n\tconvert_optab_handler instead of widening_optab_handler.\n\t* expmed.c (expmed_mult_highpart_optab): Use convert_optab_handler\n\tinstead of widening_optab_handler.\n\t* expr.c (expand_expr_real_2): Update calls to\n\tfind_widening_optab_handler.\n\t* optabs.c (expand_widen_pattern_expr): Likewise.\n\t(expand_binop_directly): Take the insn_code as a parameter.\n\t(expand_binop): Only call find_widening_optab_handler for\n\tconversion optabs; use optab_handler otherwise.  Update calls\n\tto find_widening_optab_handler and expand_binop_directly.\n\tUse convert_optab_handler instead of widening_optab_handler.\n\t* tree-ssa-math-opts.c (convert_mult_to_widen): Update calls to\n\tfind_widening_optab_handler and use scalar_mode rather than\n\tmachine_mode.\n\t(convert_plusminus_to_widen): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r254302", "tree": {"sha": "14a00e419d6b7f3b8f89dc41f37a4d056346f85c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14a00e419d6b7f3b8f89dc41f37a4d056346f85c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b926feae10ecec6555dca641c03a8239a824eab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b926feae10ecec6555dca641c03a8239a824eab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b926feae10ecec6555dca641c03a8239a824eab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b926feae10ecec6555dca641c03a8239a824eab/comments", "author": null, "committer": null, "parents": [{"sha": "ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef1d3b57d2d00795c6eb01fe6b8ef6f413163c67"}], "stats": {"total": 175, "additions": 106, "deletions": 69}, "files": [{"sha": "3843db847a8f41ca7cf557ae5d83ff685a7af65a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b926feae10ecec6555dca641c03a8239a824eab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b926feae10ecec6555dca641c03a8239a824eab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b926feae10ecec6555dca641c03a8239a824eab", "patch": "@@ -1,3 +1,33 @@\n+2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* optabs-query.h (convert_optab_p): New function, split out from...\n+\t(convert_optab_handler): ...here.\n+\t(widening_optab_handler): Delete.\n+\t(find_widening_optab_handler): Remove permit_non_widening parameter.\n+\t(find_widening_optab_handler_and_mode): Likewise.  Provide an\n+\toverride that operates on mode class wrappers.\n+\t* optabs-query.c (widening_optab_handler): Delete.\n+\t(find_widening_optab_handler_and_mode): Remove permit_non_widening\n+\tparameter.  Assert that the two modes are the same class and that\n+\tthe \"from\" mode is narrower than the \"to\" mode.  Use\n+\tconvert_optab_handler instead of widening_optab_handler.\n+\t* expmed.c (expmed_mult_highpart_optab): Use convert_optab_handler\n+\tinstead of widening_optab_handler.\n+\t* expr.c (expand_expr_real_2): Update calls to\n+\tfind_widening_optab_handler.\n+\t* optabs.c (expand_widen_pattern_expr): Likewise.\n+\t(expand_binop_directly): Take the insn_code as a parameter.\n+\t(expand_binop): Only call find_widening_optab_handler for\n+\tconversion optabs; use optab_handler otherwise.  Update calls\n+\tto find_widening_optab_handler and expand_binop_directly.\n+\tUse convert_optab_handler instead of widening_optab_handler.\n+\t* tree-ssa-math-opts.c (convert_mult_to_widen): Update calls to\n+\tfind_widening_optab_handler and use scalar_mode rather than\n+\tmachine_mode.\n+\t(convert_plusminus_to_widen): Likewise.\n+\n 2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "00d2f1102bcfcf8e4f294dab92a2fe18912d48a9", "filename": "gcc/expmed.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b926feae10ecec6555dca641c03a8239a824eab/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b926feae10ecec6555dca641c03a8239a824eab/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=4b926feae10ecec6555dca641c03a8239a824eab", "patch": "@@ -3699,7 +3699,7 @@ expmed_mult_highpart_optab (scalar_int_mode mode, rtx op0, rtx op1,\n \n   /* Try widening multiplication.  */\n   moptab = unsignedp ? umul_widen_optab : smul_widen_optab;\n-  if (widening_optab_handler (moptab, wider_mode, mode) != CODE_FOR_nothing\n+  if (convert_optab_handler (moptab, wider_mode, mode) != CODE_FOR_nothing\n       && mul_widen_cost (speed, wider_mode) < max_cost)\n     {\n       tem = expand_binop (wider_mode, moptab, op0, narrow_op1, 0,\n@@ -3738,7 +3738,7 @@ expmed_mult_highpart_optab (scalar_int_mode mode, rtx op0, rtx op1,\n \n   /* Try widening multiplication of opposite signedness, and adjust.  */\n   moptab = unsignedp ? smul_widen_optab : umul_widen_optab;\n-  if (widening_optab_handler (moptab, wider_mode, mode) != CODE_FOR_nothing\n+  if (convert_optab_handler (moptab, wider_mode, mode) != CODE_FOR_nothing\n       && size - 1 < BITS_PER_WORD\n       && (mul_widen_cost (speed, wider_mode)\n \t  + 2 * shift_cost (speed, mode, size-1)"}, {"sha": "649a057e43ddb67d942e7795ecdda4883603a220", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b926feae10ecec6555dca641c03a8239a824eab/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b926feae10ecec6555dca641c03a8239a824eab/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4b926feae10ecec6555dca641c03a8239a824eab", "patch": "@@ -8610,7 +8610,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t{\n \t  machine_mode innermode = TYPE_MODE (TREE_TYPE (treeop0));\n \t  this_optab = usmul_widen_optab;\n-\t  if (find_widening_optab_handler (this_optab, mode, innermode, 0)\n+\t  if (find_widening_optab_handler (this_optab, mode, innermode)\n \t\t!= CODE_FOR_nothing)\n \t    {\n \t      if (TYPE_UNSIGNED (TREE_TYPE (treeop0)))\n@@ -8645,7 +8645,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \n \t  if (TREE_CODE (treeop0) != INTEGER_CST)\n \t    {\n-\t      if (find_widening_optab_handler (this_optab, mode, innermode, 0)\n+\t      if (find_widening_optab_handler (this_optab, mode, innermode)\n \t\t    != CODE_FOR_nothing)\n \t\t{\n \t\t  expand_operands (treeop0, treeop1, NULL_RTX, &op0, &op1,\n@@ -8667,7 +8667,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t\t\t\t\t       unsignedp, this_optab);\n \t\t  return REDUCE_BIT_FIELD (temp);\n \t\t}\n-\t      if (find_widening_optab_handler (other_optab, mode, innermode, 0)\n+\t      if (find_widening_optab_handler (other_optab, mode, innermode)\n \t\t    != CODE_FOR_nothing\n \t\t  && innermode == word_mode)\n \t\t{"}, {"sha": "440462bc242340e46d04f86d41d3961817522096", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 5, "deletions": 29, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b926feae10ecec6555dca641c03a8239a824eab/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b926feae10ecec6555dca641c03a8239a824eab/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=4b926feae10ecec6555dca641c03a8239a824eab", "patch": "@@ -401,44 +401,20 @@ can_vec_perm_p (machine_mode mode, bool variable, vec_perm_indices *sel)\n   return true;\n }\n \n-/* Like optab_handler, but for widening_operations that have a\n-   TO_MODE and a FROM_MODE.  */\n-\n-enum insn_code\n-widening_optab_handler (optab op, machine_mode to_mode,\n-\t\t\tmachine_mode from_mode)\n-{\n-  unsigned scode = (op << 16) | to_mode;\n-  if (to_mode != from_mode && from_mode != VOIDmode)\n-    {\n-      /* ??? Why does find_widening_optab_handler_and_mode attempt to\n-\t widen things that can't be widened?  E.g. add_optab... */\n-      if (op > LAST_CONV_OPTAB)\n-\treturn CODE_FOR_nothing;\n-      scode |= from_mode << 8;\n-    }\n-  return raw_optab_handler (scode);\n-}\n-\n /* Find a widening optab even if it doesn't widen as much as we want.\n    E.g. if from_mode is HImode, and to_mode is DImode, and there is no\n-   direct HI->SI insn, then return SI->DI, if that exists.\n-   If PERMIT_NON_WIDENING is non-zero then this can be used with\n-   non-widening optabs also.  */\n+   direct HI->SI insn, then return SI->DI, if that exists.  */\n \n enum insn_code\n find_widening_optab_handler_and_mode (optab op, machine_mode to_mode,\n \t\t\t\t      machine_mode from_mode,\n-\t\t\t\t      int permit_non_widening,\n \t\t\t\t      machine_mode *found_mode)\n {\n-  for (; (permit_non_widening || from_mode != to_mode)\n-\t && GET_MODE_SIZE (from_mode) <= GET_MODE_SIZE (to_mode)\n-\t && from_mode != VOIDmode;\n-       from_mode = GET_MODE_WIDER_MODE (from_mode).else_void ())\n+  gcc_checking_assert (GET_MODE_CLASS (from_mode) == GET_MODE_CLASS (to_mode));\n+  gcc_checking_assert (from_mode < to_mode);\n+  FOR_EACH_MODE (from_mode, from_mode, to_mode)\n     {\n-      enum insn_code handler = widening_optab_handler (op, to_mode,\n-\t\t\t\t\t\t       from_mode);\n+      enum insn_code handler = convert_optab_handler (op, to_mode, from_mode);\n \n       if (handler != CODE_FOR_nothing)\n \t{"}, {"sha": "2701e2594e6a1d2f333f1156e777b1c798584eab", "filename": "gcc/optabs-query.h", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b926feae10ecec6555dca641c03a8239a824eab/gcc%2Foptabs-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b926feae10ecec6555dca641c03a8239a824eab/gcc%2Foptabs-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.h?ref=4b926feae10ecec6555dca641c03a8239a824eab", "patch": "@@ -23,6 +23,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"insn-opinit.h\"\n #include \"target.h\"\n \n+/* Return true if OP is a conversion optab.  */\n+\n+inline bool\n+convert_optab_p (optab op)\n+{\n+  return op > unknown_optab && op <= LAST_CONV_OPTAB;\n+}\n+\n /* Return the insn used to implement mode MODE of OP, or CODE_FOR_nothing\n    if the target does not have such an insn.  */\n \n@@ -43,7 +51,7 @@ convert_optab_handler (convert_optab op, machine_mode to_mode,\n \t\t       machine_mode from_mode)\n {\n   unsigned scode = (op << 16) | (from_mode << 8) | to_mode;\n-  gcc_assert (op > unknown_optab && op <= LAST_CONV_OPTAB);\n+  gcc_assert (convert_optab_p (op));\n   return raw_optab_handler (scode);\n }\n \n@@ -167,12 +175,11 @@ enum insn_code can_float_p (machine_mode, machine_mode, int);\n enum insn_code can_fix_p (machine_mode, machine_mode, int, bool *);\n bool can_conditionally_move_p (machine_mode mode);\n bool can_vec_perm_p (machine_mode, bool, vec_perm_indices *);\n-enum insn_code widening_optab_handler (optab, machine_mode, machine_mode);\n /* Find a widening optab even if it doesn't widen as much as we want.  */\n-#define find_widening_optab_handler(A,B,C,D) \\\n-  find_widening_optab_handler_and_mode (A, B, C, D, NULL)\n+#define find_widening_optab_handler(A, B, C) \\\n+  find_widening_optab_handler_and_mode (A, B, C, NULL)\n enum insn_code find_widening_optab_handler_and_mode (optab, machine_mode,\n-\t\t\t\t\t\t     machine_mode, int,\n+\t\t\t\t\t\t     machine_mode,\n \t\t\t\t\t\t     machine_mode *);\n int can_mult_highpart_p (machine_mode, bool);\n bool can_vec_mask_load_store_p (machine_mode, machine_mode, bool);\n@@ -181,4 +188,20 @@ bool can_atomic_exchange_p (machine_mode, bool);\n bool can_atomic_load_p (machine_mode);\n bool lshift_cheap_p (bool);\n \n+/* Version of find_widening_optab_handler_and_mode that operates on\n+   specific mode types.  */\n+\n+template<typename T>\n+inline enum insn_code\n+find_widening_optab_handler_and_mode (optab op, const T &to_mode,\n+\t\t\t\t      const T &from_mode, T *found_mode)\n+{\n+  machine_mode tmp;\n+  enum insn_code icode = find_widening_optab_handler_and_mode\n+    (op, machine_mode (to_mode), machine_mode (from_mode), &tmp);\n+  if (icode != CODE_FOR_nothing && found_mode)\n+    *found_mode = as_a <T> (tmp);\n+  return icode;\n+}\n+\n #endif"}, {"sha": "7cf4d8e428052c4f991ed19a25b4236ffc1b6bbc", "filename": "gcc/optabs.c", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b926feae10ecec6555dca641c03a8239a824eab/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b926feae10ecec6555dca641c03a8239a824eab/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=4b926feae10ecec6555dca641c03a8239a824eab", "patch": "@@ -264,7 +264,7 @@ expand_widen_pattern_expr (sepops ops, rtx op0, rtx op1, rtx wide_op,\n       || ops->code == WIDEN_MULT_MINUS_EXPR)\n     icode = find_widening_optab_handler (widen_pattern_optab,\n \t\t\t\t\t TYPE_MODE (TREE_TYPE (ops->op2)),\n-\t\t\t\t\t tmode0, 0);\n+\t\t\t\t\t tmode0);\n   else\n     icode = optab_handler (widen_pattern_optab, tmode0);\n   gcc_assert (icode != CODE_FOR_nothing);\n@@ -979,17 +979,14 @@ avoid_expensive_constant (machine_mode mode, optab binoptab,\n }\n \n /* Helper function for expand_binop: handle the case where there\n-   is an insn that directly implements the indicated operation.\n+   is an insn ICODE that directly implements the indicated operation.\n    Returns null if this is not possible.  */\n static rtx\n-expand_binop_directly (machine_mode mode, optab binoptab,\n+expand_binop_directly (enum insn_code icode, machine_mode mode, optab binoptab,\n \t\t       rtx op0, rtx op1,\n \t\t       rtx target, int unsignedp, enum optab_methods methods,\n \t\t       rtx_insn *last)\n {\n-  machine_mode from_mode = widened_mode (mode, op0, op1);\n-  enum insn_code icode = find_widening_optab_handler (binoptab, mode,\n-\t\t\t\t\t\t      from_mode, 1);\n   machine_mode xmode0 = insn_data[(int) icode].operand[1].mode;\n   machine_mode xmode1 = insn_data[(int) icode].operand[2].mode;\n   machine_mode mode0, mode1, tmp_mode;\n@@ -1113,6 +1110,7 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n     = (methods == OPTAB_LIB || methods == OPTAB_LIB_WIDEN\n        ? OPTAB_WIDEN : methods);\n   enum mode_class mclass;\n+  enum insn_code icode;\n   machine_mode wider_mode;\n   scalar_int_mode int_mode;\n   rtx libfunc;\n@@ -1146,23 +1144,30 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n   /* If we can do it with a three-operand insn, do so.  */\n \n-  if (methods != OPTAB_MUST_WIDEN\n-      && find_widening_optab_handler (binoptab, mode,\n-\t\t\t\t      widened_mode (mode, op0, op1), 1)\n-\t    != CODE_FOR_nothing)\n+  if (methods != OPTAB_MUST_WIDEN)\n     {\n-      temp = expand_binop_directly (mode, binoptab, op0, op1, target,\n-\t\t\t\t    unsignedp, methods, last);\n-      if (temp)\n-\treturn temp;\n+      if (convert_optab_p (binoptab))\n+\t{\n+\t  machine_mode from_mode = widened_mode (mode, op0, op1);\n+\t  icode = find_widening_optab_handler (binoptab, mode, from_mode);\n+\t}\n+      else\n+\ticode = optab_handler (binoptab, mode);\n+      if (icode != CODE_FOR_nothing)\n+\t{\n+\t  temp = expand_binop_directly (icode, mode, binoptab, op0, op1,\n+\t\t\t\t\ttarget, unsignedp, methods, last);\n+\t  if (temp)\n+\t    return temp;\n+\t}\n     }\n \n   /* If we were trying to rotate, and that didn't work, try rotating\n      the other direction before falling back to shifts and bitwise-or.  */\n   if (((binoptab == rotl_optab\n-\t&& optab_handler (rotr_optab, mode) != CODE_FOR_nothing)\n+\t&& (icode = optab_handler (rotr_optab, mode)) != CODE_FOR_nothing)\n        || (binoptab == rotr_optab\n-\t   && optab_handler (rotl_optab, mode) != CODE_FOR_nothing))\n+\t   && (icode = optab_handler (rotl_optab, mode)) != CODE_FOR_nothing))\n       && is_int_mode (mode, &int_mode))\n     {\n       optab otheroptab = (binoptab == rotl_optab ? rotr_optab : rotl_optab);\n@@ -1178,7 +1183,7 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t\t\t       gen_int_mode (bits, GET_MODE (op1)), op1,\n \t\t\t       NULL_RTX, unsignedp, OPTAB_DIRECT);\n \n-      temp = expand_binop_directly (int_mode, otheroptab, op0, newop1,\n+      temp = expand_binop_directly (icode, int_mode, otheroptab, op0, newop1,\n \t\t\t\t    target, unsignedp, methods, last);\n       if (temp)\n \treturn temp;\n@@ -1225,7 +1230,8 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       else if (binoptab == rotr_optab)\n \totheroptab = vrotr_optab;\n \n-      if (otheroptab && optab_handler (otheroptab, mode) != CODE_FOR_nothing)\n+      if (otheroptab\n+\t  && (icode = optab_handler (otheroptab, mode)) != CODE_FOR_nothing)\n \t{\n \t  /* The scalar may have been extended to be too wide.  Truncate\n \t     it back to the proper size to fit in the broadcast vector.  */\n@@ -1239,7 +1245,7 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t  rtx vop1 = expand_vector_broadcast (mode, op1);\n \t  if (vop1)\n \t    {\n-\t      temp = expand_binop_directly (mode, otheroptab, op0, vop1,\n+\t      temp = expand_binop_directly (icode, mode, otheroptab, op0, vop1,\n \t\t\t\t\t    target, unsignedp, methods, last);\n \t      if (temp)\n \t\treturn temp;\n@@ -1262,7 +1268,7 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t\t&& (find_widening_optab_handler ((unsignedp\n \t\t\t\t\t\t  ? umul_widen_optab\n \t\t\t\t\t\t  : smul_widen_optab),\n-\t\t\t\t\t\t next_mode, mode, 0)\n+\t\t\t\t\t\t next_mode, mode)\n \t\t    != CODE_FOR_nothing)))\n \t  {\n \t    rtx xop0 = op0, xop1 = op1;\n@@ -1693,7 +1699,7 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       && optab_handler (add_optab, word_mode) != CODE_FOR_nothing)\n     {\n       rtx product = NULL_RTX;\n-      if (widening_optab_handler (umul_widen_optab, int_mode, word_mode)\n+      if (convert_optab_handler (umul_widen_optab, int_mode, word_mode)\n \t  != CODE_FOR_nothing)\n \t{\n \t  product = expand_doubleword_mult (int_mode, op0, op1, target,\n@@ -1703,7 +1709,7 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t}\n \n       if (product == NULL_RTX\n-\t  && (widening_optab_handler (smul_widen_optab, int_mode, word_mode)\n+\t  && (convert_optab_handler (smul_widen_optab, int_mode, word_mode)\n \t      != CODE_FOR_nothing))\n \t{\n \t  product = expand_doubleword_mult (int_mode, op0, op1, target,\n@@ -1796,10 +1802,13 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n   if (CLASS_HAS_WIDER_MODES_P (mclass))\n     {\n+      /* This code doesn't make sense for conversion optabs, since we\n+\t wouldn't then want to extend the operands to be the same size\n+\t as the result.  */\n+      gcc_assert (!convert_optab_p (binoptab));\n       FOR_EACH_WIDER_MODE (wider_mode, mode)\n \t{\n-\t  if (find_widening_optab_handler (binoptab, wider_mode, mode, 1)\n-\t\t  != CODE_FOR_nothing\n+\t  if (optab_handler (binoptab, wider_mode)\n \t      || (methods == OPTAB_LIB\n \t\t  && optab_libfunc (binoptab, wider_mode)))\n \t    {"}, {"sha": "493f4e2379653a5a35329a3459abe05b4fc7bf05", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b926feae10ecec6555dca641c03a8239a824eab/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b926feae10ecec6555dca641c03a8239a824eab/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=4b926feae10ecec6555dca641c03a8239a824eab", "patch": "@@ -3243,7 +3243,7 @@ convert_mult_to_widen (gimple *stmt, gimple_stmt_iterator *gsi)\n {\n   tree lhs, rhs1, rhs2, type, type1, type2;\n   enum insn_code handler;\n-  machine_mode to_mode, from_mode, actual_mode;\n+  scalar_int_mode to_mode, from_mode, actual_mode;\n   optab op;\n   int actual_precision;\n   location_t loc = gimple_location (stmt);\n@@ -3270,7 +3270,7 @@ convert_mult_to_widen (gimple *stmt, gimple_stmt_iterator *gsi)\n     op = usmul_widen_optab;\n \n   handler = find_widening_optab_handler_and_mode (op, to_mode, from_mode,\n-\t\t\t\t\t\t  0, &actual_mode);\n+\t\t\t\t\t\t  &actual_mode);\n \n   if (handler == CODE_FOR_nothing)\n     {\n@@ -3291,7 +3291,7 @@ convert_mult_to_widen (gimple *stmt, gimple_stmt_iterator *gsi)\n \n \t  op = smul_widen_optab;\n \t  handler = find_widening_optab_handler_and_mode (op, to_mode,\n-\t\t\t\t\t\t\t  from_mode, 0,\n+\t\t\t\t\t\t\t  from_mode,\n \t\t\t\t\t\t\t  &actual_mode);\n \n \t  if (handler == CODE_FOR_nothing)\n@@ -3351,8 +3351,7 @@ convert_plusminus_to_widen (gimple_stmt_iterator *gsi, gimple *stmt,\n   optab this_optab;\n   enum tree_code wmult_code;\n   enum insn_code handler;\n-  scalar_mode to_mode, from_mode;\n-  machine_mode actual_mode;\n+  scalar_mode to_mode, from_mode, actual_mode;\n   location_t loc = gimple_location (stmt);\n   int actual_precision;\n   bool from_unsigned1, from_unsigned2;\n@@ -3510,7 +3509,7 @@ convert_plusminus_to_widen (gimple_stmt_iterator *gsi, gimple *stmt,\n      this transformation is likely to pessimize code.  */\n   this_optab = optab_for_tree_code (wmult_code, optype, optab_default);\n   handler = find_widening_optab_handler_and_mode (this_optab, to_mode,\n-\t\t\t\t\t\t  from_mode, 0, &actual_mode);\n+\t\t\t\t\t\t  from_mode, &actual_mode);\n \n   if (handler == CODE_FOR_nothing)\n     return false;"}]}