{"sha": "8b6891963bc53520c4a1751a1e175c5c37eee441", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI2ODkxOTYzYmM1MzUyMGM0YTE3NTFhMWUxNzVjNWMzN2VlZTQ0MQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-05-06T17:28:37Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-05-06T17:28:37Z"}, "message": "unwind-dw2.c (uw_update_context_1): Only set cfa as sp if previous frame didn't save sp.\n\n        * unwind-dw2.c (uw_update_context_1): Only set cfa as sp if\n        previous frame didn't save sp.  Clear sp for next frame.\n        (uw_install_context_1): Honor saved sp from frame.\n\nFrom-SVN: r66526", "tree": {"sha": "068f6d2a17823731401099fa70401c572b4f0ad3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/068f6d2a17823731401099fa70401c572b4f0ad3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b6891963bc53520c4a1751a1e175c5c37eee441", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b6891963bc53520c4a1751a1e175c5c37eee441", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b6891963bc53520c4a1751a1e175c5c37eee441", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b6891963bc53520c4a1751a1e175c5c37eee441/comments", "author": null, "committer": null, "parents": [{"sha": "3612c9efbb5409dff4cc71c7908ecaa47a9ddf22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3612c9efbb5409dff4cc71c7908ecaa47a9ddf22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3612c9efbb5409dff4cc71c7908ecaa47a9ddf22"}], "stats": {"total": 34, "additions": 27, "deletions": 7}, "files": [{"sha": "2cdf5b76f84ad5c3e7c1ffb5b8742f123f6ec4e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6891963bc53520c4a1751a1e175c5c37eee441/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6891963bc53520c4a1751a1e175c5c37eee441/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b6891963bc53520c4a1751a1e175c5c37eee441", "patch": "@@ -1,3 +1,9 @@\n+2003-05-06  Richard Henderson  <rth@redhat.com>\n+\n+\t* unwind-dw2.c (uw_update_context_1): Only set cfa as sp if \n+\tprevious frame didn't save sp.  Clear sp for next frame.\n+\t(uw_install_context_1): Honor saved sp from frame.\n+\n 2003-05-06  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips-protos.h (mips_subword, mips_output_move): Declare."}, {"sha": "5a26d0b630ee0f1f55ca8eea8d98d9eca9d49c5b", "filename": "gcc/unwind-dw2.c", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b6891963bc53520c4a1751a1e175c5c37eee441/gcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b6891963bc53520c4a1751a1e175c5c37eee441/gcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2.c?ref=8b6891963bc53520c4a1751a1e175c5c37eee441", "patch": "@@ -1089,11 +1089,17 @@ uw_update_context_1 (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n      In very special situations (such as unwind info for signal return),\n      there may be location expressions that use the stack pointer as well.\n \n-     Given that other unwind mechanisms generally won't work if you try\n-     to represent stack pointer saves and restores directly, we don't\n-     bother conditionalizing this at all.  */\n-  tmp_sp = (_Unwind_Ptr) context->cfa;\n-  _Unwind_SetGRPtr (&orig_context, __builtin_dwarf_sp_column (), &tmp_sp);\n+     Do this conditionally for one frame.  This allows the unwind info\n+     for one frame to save a copy of the stack pointer from the previous\n+     frame, and be able to use much easier CFA mechanisms to do it.\n+     Always zap the saved stack pointer value for the next frame; carrying\n+     the value over from one frame to another doesn't make sense.  */\n+  if (!_Unwind_GetGRPtr (&orig_context, __builtin_dwarf_sp_column ()))\n+    {\n+      tmp_sp = (_Unwind_Ptr) context->cfa;\n+      _Unwind_SetGRPtr (&orig_context, __builtin_dwarf_sp_column (), &tmp_sp);\n+    }\n+  _Unwind_SetGRPtr (context, __builtin_dwarf_sp_column (), NULL);\n \n   /* Compute this frame's CFA.  */\n   switch (fs->cfa_how)\n@@ -1234,6 +1240,7 @@ uw_install_context_1 (struct _Unwind_Context *current,\n \t\t      struct _Unwind_Context *target)\n {\n   long i;\n+  void *target_cfa;\n \n #if __GTHREADS\n   {\n@@ -1256,11 +1263,18 @@ uw_install_context_1 (struct _Unwind_Context *current,\n \tmemcpy (c, t, dwarf_reg_size_table[i]);\n     }\n \n+  /* If the last frame records a saved stack pointer, use it.  */\n+  if (_Unwind_GetGRPtr (target, __builtin_dwarf_sp_column ()))\n+    target_cfa = (void *)(_Unwind_Ptr)\n+      _Unwind_GetGR (target, __builtin_dwarf_sp_column ());\n+  else\n+    target_cfa = target->cfa;\n+\n   /* We adjust SP by the difference between CURRENT and TARGET's CFA.  */\n   if (STACK_GROWS_DOWNWARD)\n-    return target->cfa - current->cfa + target->args_size;\n+    return target_cfa - current->cfa + target->args_size;\n   else\n-    return current->cfa - target->cfa - target->args_size;\n+    return current->cfa - target_cfa - target->args_size;\n }\n \n static inline _Unwind_Ptr"}]}