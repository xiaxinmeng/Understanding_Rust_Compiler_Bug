{"sha": "a059cdb8632f1a0a64d0ae2b4ada084ab69cac5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA1OWNkYjg2MzJmMWEwYTY0ZDBhZTJiNGFkYTA4NGFiNjljYWM1ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-01-22T23:07:53Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-01-22T23:07:53Z"}, "message": "re PR target/19506 (PovRay produces wrong pictures with -mfpmath=sse -ffast-math.)\n\n        PR target/19506\n        * config/i386/i386.md (movsfcc_1_sse_max): Use nonimmediate_operand\n        in both compare operands.\n        (movdfcc_1_sse_max): Likewise.\n        (movsfcc_1_sse): Likewise.  Add earlyclobber for scratch.\n        (movdfcc_1_sse): Likewise.\n        * config/i386/i386.c (ix86_split_sse_movcc): Emit copies into the\n        scratch register as needed.\n\nFrom-SVN: r94087", "tree": {"sha": "2e02b068a5287ee3ba436b3b305ae8a028c89dc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e02b068a5287ee3ba436b3b305ae8a028c89dc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a059cdb8632f1a0a64d0ae2b4ada084ab69cac5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a059cdb8632f1a0a64d0ae2b4ada084ab69cac5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a059cdb8632f1a0a64d0ae2b4ada084ab69cac5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a059cdb8632f1a0a64d0ae2b4ada084ab69cac5e/comments", "author": null, "committer": null, "parents": [{"sha": "b8f0658696a8ba74965c8a3e7d5e7148e3ba70be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8f0658696a8ba74965c8a3e7d5e7148e3ba70be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8f0658696a8ba74965c8a3e7d5e7148e3ba70be"}], "stats": {"total": 65, "additions": 58, "deletions": 7}, "files": [{"sha": "10018db64724b7b595a3a7a793c5be16774da84e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a059cdb8632f1a0a64d0ae2b4ada084ab69cac5e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a059cdb8632f1a0a64d0ae2b4ada084ab69cac5e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a059cdb8632f1a0a64d0ae2b4ada084ab69cac5e", "patch": "@@ -1,3 +1,14 @@\n+2005-01-22  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/19506\n+\t* config/i386/i386.md (movsfcc_1_sse_max): Use nonimmediate_operand\n+\tin both compare operands.\n+\t(movdfcc_1_sse_max): Likewise.\n+\t(movsfcc_1_sse): Likewise.  Add earlyclobber for scratch.\n+\t(movdfcc_1_sse): Likewise.\n+\t* config/i386/i386.c (ix86_split_sse_movcc): Emit copies into the\n+\tscratch register as needed.\n+\n 2005-01-22  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/i386.md (smaxsf3): Fix mnemonic typo."}, {"sha": "cb6c1bab62561f514b3b5fa10444509de675e2bf", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a059cdb8632f1a0a64d0ae2b4ada084ab69cac5e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a059cdb8632f1a0a64d0ae2b4ada084ab69cac5e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=a059cdb8632f1a0a64d0ae2b4ada084ab69cac5e", "patch": "@@ -9920,8 +9920,48 @@ ix86_split_sse_movcc (rtx operands[])\n   mode = GET_MODE (dest);\n   vmode = GET_MODE (scratch);\n \n-  emit_insn (gen_rtx_SET (VOIDmode, dest, cmp));\n+  /* We need to make sure that the TRUE and FALSE operands are out of the\n+     way of the destination.  Marking the destination earlyclobber doesn't\n+     work, since we want matching constraints for the actual comparison, so\n+     at some point we always wind up having to do a copy ourselves here.\n+     We very much prefer the TRUE value to be in SCRATCH.  If it turns out\n+     that FALSE overlaps DEST, then we invert the comparison so that we\n+     still only have to do one move.  */\n+  if (rtx_equal_p (op_false, dest))\n+    {\n+      enum rtx_code code;\n+\n+      if (rtx_equal_p (op_true, dest))\n+\t{\n+\t  /* ??? Really ought not happen.  It means some optimizer managed\n+\t     to prove the operands were identical, but failed to fold the\n+\t     conditional move to a straight move.  Do so here, because \n+\t     otherwise we'll generate incorrect code.  And since they're\n+\t     both already in the destination register, nothing to do.  */\n+\t  return;\n+\t}\n+\n+      x = gen_rtx_REG (mode, REGNO (scratch));\n+      emit_move_insn (x, op_false);\n+      op_false = op_true;\n+      op_true = x;\n \n+      code = GET_CODE (cmp);\n+      code = reverse_condition_maybe_unordered (code);\n+      cmp = gen_rtx_fmt_ee (code, mode, XEXP (cmp, 0), XEXP (cmp, 1));\n+    }\n+  else if (op_true == CONST0_RTX (mode))\n+    ;\n+  else if (op_false == CONST0_RTX (mode) && !rtx_equal_p (op_true, dest))\n+    ;\n+  else\n+    {\n+      x = gen_rtx_REG (mode, REGNO (scratch));\n+      emit_move_insn (x, op_true);\n+      op_true = x;\n+    }\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, dest, cmp));\n   dest = simplify_gen_subreg (vmode, dest, mode, 0);\n \n   if (op_false == CONST0_RTX (mode))"}, {"sha": "32a5281acc1c56e3e7fca411f4379c19866ffe4f", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a059cdb8632f1a0a64d0ae2b4ada084ab69cac5e/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a059cdb8632f1a0a64d0ae2b4ada084ab69cac5e/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=a059cdb8632f1a0a64d0ae2b4ada084ab69cac5e", "patch": "@@ -17443,7 +17443,7 @@\n   [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n \t(if_then_else:SF\n \t  (lt:SF (match_operand:SF 2 \"nonimmediate_operand\" \"xm\")\n-\t\t (match_operand:SF 1 \"register_operand\" \"0\"))\n+\t\t (match_operand:SF 1 \"nonimmediate_operand\" \"0\"))\n \t  (match_dup 1)\n \t  (match_dup 2)))]\n   \"TARGET_SSE_MATH\"\n@@ -17457,9 +17457,9 @@\n \t  (match_operator:SF 4 \"sse_comparison_operator\"\n \t    [(match_operand:SF 5 \"register_operand\" \"0,0,0\")\n \t     (match_operand:SF 6 \"nonimmediate_operand\" \"xm,xm,xm\")])\n-\t  (match_operand:SF 2 \"reg_or_0_operand\" \"C,x,1\")\n+\t  (match_operand:SF 2 \"reg_or_0_operand\" \"C,x,x\")\n \t  (match_operand:SF 3 \"reg_or_0_operand\" \"x,C,x\")))\n-   (clobber (match_scratch:V4SF 1 \"=X,X,x\"))]\n+   (clobber (match_scratch:V4SF 1 \"=&x,&x,&x\"))]\n   \"TARGET_SSE_MATH\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -17512,7 +17512,7 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"=x\")\n \t(if_then_else:DF\n \t  (lt:DF (match_operand:DF 2 \"nonimmediate_operand\" \"xm\")\n-\t\t (match_operand:DF 1 \"register_operand\" \"0\"))\n+\t\t (match_operand:DF 1 \"nonimmediate_operand\" \"0\"))\n \t  (match_dup 1)\n \t  (match_dup 2)))]\n   \"TARGET_SSE2 && TARGET_SSE_MATH\"\n@@ -17526,9 +17526,9 @@\n \t  (match_operator:DF 4 \"sse_comparison_operator\"\n \t    [(match_operand:DF 5 \"register_operand\" \"0,0,0\")\n \t     (match_operand:DF 6 \"nonimmediate_operand\" \"xm,xm,xm\")])\n-\t  (match_operand:DF 2 \"reg_or_0_operand\" \"C,x,1\")\n+\t  (match_operand:DF 2 \"reg_or_0_operand\" \"C,x,x\")\n \t  (match_operand:DF 3 \"reg_or_0_operand\" \"x,C,x\")))\n-   (clobber (match_scratch:V2DF 1 \"=X,X,x\"))]\n+   (clobber (match_scratch:V2DF 1 \"=&x,&x,&x\"))]\n   \"TARGET_SSE2 && TARGET_SSE_MATH\"\n   \"#\"\n   \"&& reload_completed\""}]}