{"sha": "903a9601cc5e966efee08007b7fdbde90b23d71b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTAzYTk2MDFjYzVlOTY2ZWZlZTA4MDA3YjdmZGJkZTkwYjIzZDcxYg==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2011-12-18T09:19:51Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2011-12-18T09:19:51Z"}, "message": "ia64.h (REG_OK_FOR_BASE_P, [...]): Remove macros.\n\n\t* config/ia64/ia64.h (REG_OK_FOR_BASE_P, REG_OK_FOR_INDEX_P,\n\tLEGITIMATE_ADDRESS_REG, LEGITIMATE_ADDRESS_DISP,\n\tGO_IF_LEGITIMATE_ADDRESS): Remove macros.\n\t* config/ia64/ia64.c (TARGET_LEGITIMATE_ADDRESS_P): Define.\n\t(ia64_reg_ok_for_base_p, ia64_legitimate_address_reg,\n\tia64_legitimate_address_disp, ia64_legitimate_address_p): New\n\tfunctions.\n\nFrom-SVN: r182456", "tree": {"sha": "a683d5cee2d1476323669d9cd5932069efc38866", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a683d5cee2d1476323669d9cd5932069efc38866"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/903a9601cc5e966efee08007b7fdbde90b23d71b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/903a9601cc5e966efee08007b7fdbde90b23d71b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/903a9601cc5e966efee08007b7fdbde90b23d71b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/903a9601cc5e966efee08007b7fdbde90b23d71b/comments", "author": null, "committer": null, "parents": [{"sha": "7ffbe288d7e300e55cde338148141f89ecde6ce3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ffbe288d7e300e55cde338148141f89ecde6ce3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ffbe288d7e300e55cde338148141f89ecde6ce3"}], "stats": {"total": 121, "additions": 75, "deletions": 46}, "files": [{"sha": "1377d9972435b1169a09a771205e139f1a38f4e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/903a9601cc5e966efee08007b7fdbde90b23d71b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/903a9601cc5e966efee08007b7fdbde90b23d71b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=903a9601cc5e966efee08007b7fdbde90b23d71b", "patch": "@@ -1,3 +1,13 @@\n+2011-12-18  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* config/ia64/ia64.h (REG_OK_FOR_BASE_P, REG_OK_FOR_INDEX_P,\n+\tLEGITIMATE_ADDRESS_REG, LEGITIMATE_ADDRESS_DISP,\n+\tGO_IF_LEGITIMATE_ADDRESS): Remove macros.\n+\t* config/ia64/ia64.c (TARGET_LEGITIMATE_ADDRESS_P): Define.\n+\t(ia64_reg_ok_for_base_p, ia64_legitimate_address_reg,\n+\tia64_legitimate_address_disp, ia64_legitimate_address_p): New\n+\tfunctions.\n+\n 2011-12-17  Tom de Vries  <tom@codesourcery.com>\n \n \tPR tree-optimization/51491"}, {"sha": "b9706072ad6d7e97c4cc7f60e7ad37322b6f4183", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/903a9601cc5e966efee08007b7fdbde90b23d71b/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/903a9601cc5e966efee08007b7fdbde90b23d71b/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=903a9601cc5e966efee08007b7fdbde90b23d71b", "patch": "@@ -309,6 +309,7 @@ static tree ia64_gimplify_va_arg (tree, tree, gimple_seq *, gimple_seq *);\n static bool ia64_scalar_mode_supported_p (enum machine_mode mode);\n static bool ia64_vector_mode_supported_p (enum machine_mode mode);\n static bool ia64_legitimate_constant_p (enum machine_mode, rtx);\n+static bool ia64_legitimate_address_p (enum machine_mode, rtx, bool);\n static bool ia64_cannot_force_const_mem (enum machine_mode, rtx);\n static const char *ia64_mangle_type (const_tree);\n static const char *ia64_invalid_conversion (const_tree, const_tree);\n@@ -583,6 +584,8 @@ static const struct attribute_spec ia64_attribute_table[] =\n \n #undef TARGET_LEGITIMATE_CONSTANT_P\n #define TARGET_LEGITIMATE_CONSTANT_P ia64_legitimate_constant_p\n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P ia64_legitimate_address_p\n \n #undef TARGET_CANNOT_FORCE_CONST_MEM\n #define TARGET_CANNOT_FORCE_CONST_MEM ia64_cannot_force_const_mem\n@@ -937,6 +940,68 @@ tls_symbolic_operand_type (rtx addr)\n   return tls_kind;\n }\n \n+/* Returns true if REG (assumed to be a `reg' RTX) is valid for use\n+   as a base register.  */\n+\n+static inline bool\n+ia64_reg_ok_for_base_p (const_rtx reg, bool strict)\n+{\n+  if (strict\n+      && REGNO_OK_FOR_BASE_P (REGNO (reg)))\n+    return true;\n+  else if (!strict\n+\t   && (GENERAL_REGNO_P (REGNO (reg))\n+\t       || !HARD_REGISTER_P (reg)))\n+    return true;\n+  else\n+    return false;\n+}\n+\n+static bool\n+ia64_legitimate_address_reg (const_rtx reg, bool strict)\n+{\n+  if ((REG_P (reg) && ia64_reg_ok_for_base_p (reg, strict))\n+      || (GET_CODE (reg) == SUBREG && REG_P (XEXP (reg, 0))\n+\t  && ia64_reg_ok_for_base_p (XEXP (reg, 0), strict)))\n+    return true;\n+\n+  return false;\n+}\n+\n+static bool\n+ia64_legitimate_address_disp (const_rtx reg, const_rtx disp, bool strict)\n+{\n+  if (GET_CODE (disp) == PLUS\n+      && rtx_equal_p (reg, XEXP (disp, 0))\n+      && (ia64_legitimate_address_reg (XEXP (disp, 1), strict)\n+\t  || (CONST_INT_P (XEXP (disp, 1))\n+\t      && IN_RANGE (INTVAL (XEXP (disp, 1)), -256, 255))))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Implement TARGET_LEGITIMATE_ADDRESS_P.  */\n+\n+static bool\n+ia64_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t   rtx x, bool strict)\n+{\n+  if (ia64_legitimate_address_reg (x, strict))\n+    return true;\n+  else if ((GET_CODE (x) == POST_INC || GET_CODE (x) == POST_DEC)\n+\t   && ia64_legitimate_address_reg (XEXP (x, 0), strict)\n+\t   && XEXP (x, 0) != arg_pointer_rtx) \n+    return true;\n+  else if (GET_CODE (x) == POST_MODIFY\n+\t   && ia64_legitimate_address_reg (XEXP (x, 0), strict)\n+\t   && XEXP (x, 0) != arg_pointer_rtx\n+\t   && ia64_legitimate_address_disp (XEXP (x, 0), XEXP (x, 1), strict))\n+    return true;\n+  else\n+    return false;\n+}\n+\n /* Return true if X is a constant that is valid for some immediate\n    field in an instruction.  */\n "}, {"sha": "a3ccd6fe8a95eccd73f577bbfd41590ad13aec4e", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/903a9601cc5e966efee08007b7fdbde90b23d71b/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/903a9601cc5e966efee08007b7fdbde90b23d71b/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=903a9601cc5e966efee08007b7fdbde90b23d71b", "patch": "@@ -1154,52 +1154,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define MAX_REGS_PER_ADDRESS 2\n \n-/* A C compound statement with a conditional `goto LABEL;' executed if X (an\n-   RTX) is a legitimate memory address on the target machine for a memory\n-   operand of mode MODE.  */\n-\n-#define LEGITIMATE_ADDRESS_REG(X)\t\t\t\t\t\\\n-  ((GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\t\t\\\n-   || (GET_CODE (X) == SUBREG && GET_CODE (XEXP (X, 0)) == REG\t\t\\\n-       && REG_OK_FOR_BASE_P (XEXP (X, 0))))\n-\n-#define LEGITIMATE_ADDRESS_DISP(R, X)\t\t\t\t\t\\\n-  (GET_CODE (X) == PLUS\t\t\t\t\t\t\t\\\n-   && rtx_equal_p (R, XEXP (X, 0))\t\t\t\t\t\\\n-   && (LEGITIMATE_ADDRESS_REG (XEXP (X, 1))\t\t\t\t\\\n-       || (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n-\t   && INTVAL (XEXP (X, 1)) >= -256\t\t\t\t\\\n-\t   && INTVAL (XEXP (X, 1)) < 256)))\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL) \t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (LEGITIMATE_ADDRESS_REG (X))\t\t\t\t\t\\\n-    goto LABEL;\t\t\t\t\t\t\t\t\\\n-  else if ((GET_CODE (X) == POST_INC || GET_CODE (X) == POST_DEC)\t\\\n-\t   && LEGITIMATE_ADDRESS_REG (XEXP (X, 0))\t\t\t\\\n-\t   && XEXP (X, 0) != arg_pointer_rtx)\t\t\t\t\\\n-    goto LABEL;\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == POST_MODIFY\t\t\t\t\t\\\n-\t   && LEGITIMATE_ADDRESS_REG (XEXP (X, 0))\t\t\t\\\n-\t   && XEXP (X, 0) != arg_pointer_rtx\t\t\t\t\\\n-\t   && LEGITIMATE_ADDRESS_DISP (XEXP (X, 0), XEXP (X, 1)))\t\\\n-    goto LABEL;\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-/* A C expression that is nonzero if X (assumed to be a `reg' RTX) is valid for\n-   use as a base register.  */\n-\n-#ifdef REG_OK_STRICT\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-#else\n-#define REG_OK_FOR_BASE_P(X) \\\n-  (GENERAL_REGNO_P (REGNO (X)) || (REGNO (X) >= FIRST_PSEUDO_REGISTER))\n-#endif\n-\n-/* A C expression that is nonzero if X (assumed to be a `reg' RTX) is valid for\n-   use as an index register.  This is needed for POST_MODIFY.  */\n-\n-#define REG_OK_FOR_INDEX_P(X) REG_OK_FOR_BASE_P (X)\n \f\n /* Condition Code Status */\n "}]}