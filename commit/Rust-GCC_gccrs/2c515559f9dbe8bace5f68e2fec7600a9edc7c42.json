{"sha": "2c515559f9dbe8bace5f68e2fec7600a9edc7c42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM1MTU1NTlmOWRiZThiYWNlNWY2OGUyZmVjNzYwMGE5ZWRjN2M0Mg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-04T10:41:12Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-04T10:41:12Z"}, "message": "C++-ify vec_info structures\n\nThis patch uses new, delete, constructors and desctructors to manage\nvec_info.  This includes making ~vec_info free all the data shared\nby bb_vec_info and loop_vec_info, whereas previously the code was\nduplicated in destroy_bb_vec_info and destroy_loop_vec_info.  This\nin turn meant changing the order of:\n\n  FOR_EACH_VEC_ELT (slp_instances, i, instance)\n    vect_free_slp_instance (instance);\n\nand:\n\n  gimple_set_uid (stmt, -1);\n\nin destroy_bb_vec_info/~_bb_vec_info, so that now vect_free_slp_instance\ncould see a uid of -1 as well as 0.  The patch updates vinfo_for_stmt\nso that it returns NULL for a uid of -1.\n\n2017-08-04  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree-vectorizer.h (vec_info): Add a constructor and destructor.\n\tAdd an explicit name for the enum.  Use auto_vec for slp_instances\n\tand grouped_stores.\n\t(_loop_vec_info): Add a constructor and destructor.  Use auto_vec\n\tfor all vectors.\n\t(_bb_vec_info): Add a constructor and destructor.\n\t(vinfo_for_stmt): Return NULL for uids of -1 as well.\n\t(destroy_loop_vec_info): Delete.\n\t(vect_destroy_datarefs): Likewise.\n\t* tree-vectorizer.c (vect_destroy_datarefs): Delete.\n\t(vec_info::vec_info): New function.\n\t(vec_info::~vec_info): Likewise.\n\t(vectorize_loops): Use delete instead of destroy_loop_vec_info.\n\t* tree-parloops.c (gather_scalar_reductions): Use delete instead of\n\tdestroy_loop_vec_info.\n\t* tree-vect-loop.c (new_loop_vec_info): Replace with...\n\t(_loop_vec_info::_loop_vec_info): ...this.\n\t(destroy_loop_vec_info): Replace with...\n\t(_loop_vec_info::~_loop_vec_info): ...this.  Unconditionally delete\n\tthe stmt_vec_infos.  Leave handling of vec_info information to its\n\tdestructor.  Remove explicit vector releases.\n\t(vect_analyze_loop_form): Use new instead of new_loop_vec_info.\n\t(vect_analyze_loop): Use delete instead of destroy_loop_vec_info.\n\t* tree-vect-slp.c (new_bb_vec_info): Replace with...\n\t(_bb_vec_info::_bb_vec_info): ...this.  Don't reserve space in\n\tBB_VINFO_GROUPED_STORES or BB_VINFO_SLP_INSTANCES.\n\t(destroy_bb_vec_info): Replace with...\n\t(_bb_vec_info::~_bb_vec_info): ...this.  Leave handling of vec_info\n\tinformation to its destructor.\n\t(vect_slp_analyze_bb_1): Use new and delete instead of\n\tnew_bb_vec_info and destroy_bb_vec_info.\n\t(vect_slp_bb): Replace 2 calls to destroy_bb_vec_info with a\n\tsingle delete.\n\nFrom-SVN: r250869", "tree": {"sha": "1be469fb15d4c42c3e6f4ef2d854914280c6b919", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1be469fb15d4c42c3e6f4ef2d854914280c6b919"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c515559f9dbe8bace5f68e2fec7600a9edc7c42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c515559f9dbe8bace5f68e2fec7600a9edc7c42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c515559f9dbe8bace5f68e2fec7600a9edc7c42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c515559f9dbe8bace5f68e2fec7600a9edc7c42/comments", "author": null, "committer": null, "parents": [{"sha": "9adee3052156ae36271be28e3ad47dd975c26f42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9adee3052156ae36271be28e3ad47dd975c26f42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9adee3052156ae36271be28e3ad47dd975c26f42"}], "stats": {"total": 332, "additions": 154, "deletions": 178}, "files": [{"sha": "b39dc47f411cec5ba89d1d5716233a1e12cfad3c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c515559f9dbe8bace5f68e2fec7600a9edc7c42/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c515559f9dbe8bace5f68e2fec7600a9edc7c42/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c515559f9dbe8bace5f68e2fec7600a9edc7c42", "patch": "@@ -1,3 +1,39 @@\n+2017-08-04  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree-vectorizer.h (vec_info): Add a constructor and destructor.\n+\tAdd an explicit name for the enum.  Use auto_vec for slp_instances\n+\tand grouped_stores.\n+\t(_loop_vec_info): Add a constructor and destructor.  Use auto_vec\n+\tfor all vectors.\n+\t(_bb_vec_info): Add a constructor and destructor.\n+\t(vinfo_for_stmt): Return NULL for uids of -1 as well.\n+\t(destroy_loop_vec_info): Delete.\n+\t(vect_destroy_datarefs): Likewise.\n+\t* tree-vectorizer.c (vect_destroy_datarefs): Delete.\n+\t(vec_info::vec_info): New function.\n+\t(vec_info::~vec_info): Likewise.\n+\t(vectorize_loops): Use delete instead of destroy_loop_vec_info.\n+\t* tree-parloops.c (gather_scalar_reductions): Use delete instead of\n+\tdestroy_loop_vec_info.\n+\t* tree-vect-loop.c (new_loop_vec_info): Replace with...\n+\t(_loop_vec_info::_loop_vec_info): ...this.\n+\t(destroy_loop_vec_info): Replace with...\n+\t(_loop_vec_info::~_loop_vec_info): ...this.  Unconditionally delete\n+\tthe stmt_vec_infos.  Leave handling of vec_info information to its\n+\tdestructor.  Remove explicit vector releases.\n+\t(vect_analyze_loop_form): Use new instead of new_loop_vec_info.\n+\t(vect_analyze_loop): Use delete instead of destroy_loop_vec_info.\n+\t* tree-vect-slp.c (new_bb_vec_info): Replace with...\n+\t(_bb_vec_info::_bb_vec_info): ...this.  Don't reserve space in\n+\tBB_VINFO_GROUPED_STORES or BB_VINFO_SLP_INSTANCES.\n+\t(destroy_bb_vec_info): Replace with...\n+\t(_bb_vec_info::~_bb_vec_info): ...this.  Leave handling of vec_info\n+\tinformation to its destructor.\n+\t(vect_slp_analyze_bb_1): Use new and delete instead of\n+\tnew_bb_vec_info and destroy_bb_vec_info.\n+\t(vect_slp_bb): Replace 2 calls to destroy_bb_vec_info with a\n+\tsingle delete.\n+\n 2017-08-04  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* tree-data-ref.h (subscript): Add access_fn field."}, {"sha": "59e261d2aaa35a063cf73d6bf2d94daf718e3d9e", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c515559f9dbe8bace5f68e2fec7600a9edc7c42/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c515559f9dbe8bace5f68e2fec7600a9edc7c42/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=2c515559f9dbe8bace5f68e2fec7600a9edc7c42", "patch": "@@ -2577,7 +2577,7 @@ gather_scalar_reductions (loop_p loop, reduction_info_table_type *reduction_list\n \n       build_new_reduction (reduction_list, reduc_stmt, phi);\n     }\n-  destroy_loop_vec_info (simple_loop_info, true);\n+  delete simple_loop_info;\n \n   if (!double_reduc_phis.is_empty ())\n     {\n@@ -2613,7 +2613,7 @@ gather_scalar_reductions (loop_p loop, reduction_info_table_type *reduction_list\n \n \t      build_new_reduction (reduction_list, double_reduc_stmts[i], phi);\n \t    }\n-\t  destroy_loop_vec_info (simple_loop_info, true);\n+\t  delete simple_loop_info;\n \t}\n     }\n "}, {"sha": "8b2a61e733be4134ecbdfca77b7cd86f1f35318f", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 44, "deletions": 99, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c515559f9dbe8bace5f68e2fec7600a9edc7c42/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c515559f9dbe8bace5f68e2fec7600a9edc7c42/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=2c515559f9dbe8bace5f68e2fec7600a9edc7c42", "patch": "@@ -1098,112 +1098,77 @@ bb_in_loop_p (const_basic_block bb, const void *data)\n }\n \n \n-/* Function new_loop_vec_info.\n-\n-   Create and initialize a new loop_vec_info struct for LOOP, as well as\n-   stmt_vec_info structs for all the stmts in LOOP.  */\n-\n-static loop_vec_info\n-new_loop_vec_info (struct loop *loop)\n+/* Create and initialize a new loop_vec_info struct for LOOP_IN, as well as\n+   stmt_vec_info structs for all the stmts in LOOP_IN.  */\n+\n+_loop_vec_info::_loop_vec_info (struct loop *loop_in)\n+  : vec_info (vec_info::loop, init_cost (loop_in)),\n+    loop (loop_in),\n+    bbs (XCNEWVEC (basic_block, loop->num_nodes)),\n+    num_itersm1 (NULL_TREE),\n+    num_iters (NULL_TREE),\n+    num_iters_unchanged (NULL_TREE),\n+    num_iters_assumptions (NULL_TREE),\n+    th (0),\n+    vectorization_factor (0),\n+    unaligned_dr (NULL),\n+    peeling_for_alignment (0),\n+    ptr_mask (0),\n+    slp_unrolling_factor (1),\n+    single_scalar_iteration_cost (0),\n+    vectorizable (false),\n+    peeling_for_gaps (false),\n+    peeling_for_niter (false),\n+    operands_swapped (false),\n+    no_data_dependencies (false),\n+    has_mask_store (false),\n+    scalar_loop (NULL),\n+    orig_loop_info (NULL)\n {\n-  loop_vec_info res;\n-  basic_block *bbs;\n-  gimple_stmt_iterator si;\n-  unsigned int i, nbbs;\n-\n-  res = (loop_vec_info) xcalloc (1, sizeof (struct _loop_vec_info));\n-  res->kind = vec_info::loop;\n-  LOOP_VINFO_LOOP (res) = loop;\n-\n-  bbs = get_loop_body (loop);\n-\n   /* Create/Update stmt_info for all stmts in the loop.  */\n-  for (i = 0; i < loop->num_nodes; i++)\n+  basic_block *body = get_loop_body (loop);\n+  for (unsigned int i = 0; i < loop->num_nodes; i++)\n     {\n-      basic_block bb = bbs[i];\n+      basic_block bb = body[i];\n+      gimple_stmt_iterator si;\n \n       for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n \t{\n \t  gimple *phi = gsi_stmt (si);\n \t  gimple_set_uid (phi, 0);\n-\t  set_vinfo_for_stmt (phi, new_stmt_vec_info (phi, res));\n+\t  set_vinfo_for_stmt (phi, new_stmt_vec_info (phi, this));\n \t}\n \n       for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n \t{\n \t  gimple *stmt = gsi_stmt (si);\n \t  gimple_set_uid (stmt, 0);\n-\t  set_vinfo_for_stmt (stmt, new_stmt_vec_info (stmt, res));\n+\t  set_vinfo_for_stmt (stmt, new_stmt_vec_info (stmt, this));\n \t}\n     }\n+  free (body);\n \n   /* CHECKME: We want to visit all BBs before their successors (except for\n      latch blocks, for which this assertion wouldn't hold).  In the simple\n      case of the loop forms we allow, a dfs order of the BBs would the same\n      as reversed postorder traversal, so we are safe.  */\n \n-   free (bbs);\n-   bbs = XCNEWVEC (basic_block, loop->num_nodes);\n-   nbbs = dfs_enumerate_from (loop->header, 0, bb_in_loop_p,\n-                              bbs, loop->num_nodes, loop);\n-   gcc_assert (nbbs == loop->num_nodes);\n-\n-  LOOP_VINFO_BBS (res) = bbs;\n-  LOOP_VINFO_NITERSM1 (res) = NULL;\n-  LOOP_VINFO_NITERS (res) = NULL;\n-  LOOP_VINFO_NITERS_UNCHANGED (res) = NULL;\n-  LOOP_VINFO_NITERS_ASSUMPTIONS (res) = NULL;\n-  LOOP_VINFO_COST_MODEL_THRESHOLD (res) = 0;\n-  LOOP_VINFO_VECTORIZABLE_P (res) = 0;\n-  LOOP_VINFO_PEELING_FOR_ALIGNMENT (res) = 0;\n-  LOOP_VINFO_VECT_FACTOR (res) = 0;\n-  LOOP_VINFO_LOOP_NEST (res) = vNULL;\n-  LOOP_VINFO_DATAREFS (res) = vNULL;\n-  LOOP_VINFO_DDRS (res) = vNULL;\n-  LOOP_VINFO_UNALIGNED_DR (res) = NULL;\n-  LOOP_VINFO_MAY_MISALIGN_STMTS (res) = vNULL;\n-  LOOP_VINFO_MAY_ALIAS_DDRS (res) = vNULL;\n-  LOOP_VINFO_GROUPED_STORES (res) = vNULL;\n-  LOOP_VINFO_REDUCTIONS (res) = vNULL;\n-  LOOP_VINFO_REDUCTION_CHAINS (res) = vNULL;\n-  LOOP_VINFO_SLP_INSTANCES (res) = vNULL;\n-  LOOP_VINFO_SLP_UNROLLING_FACTOR (res) = 1;\n-  LOOP_VINFO_TARGET_COST_DATA (res) = init_cost (loop);\n-  LOOP_VINFO_PEELING_FOR_GAPS (res) = false;\n-  LOOP_VINFO_PEELING_FOR_NITER (res) = false;\n-  LOOP_VINFO_OPERANDS_SWAPPED (res) = false;\n-  LOOP_VINFO_ORIG_LOOP_INFO (res) = NULL;\n-\n-  return res;\n+  unsigned int nbbs = dfs_enumerate_from (loop->header, 0, bb_in_loop_p,\n+\t\t\t\t\t  bbs, loop->num_nodes, loop);\n+  gcc_assert (nbbs == loop->num_nodes);\n }\n \n \n-/* Function destroy_loop_vec_info.\n-\n-   Free LOOP_VINFO struct, as well as all the stmt_vec_info structs of all the\n-   stmts in the loop.  */\n+/* Free all memory used by the _loop_vec_info, as well as all the\n+   stmt_vec_info structs of all the stmts in the loop.  */\n \n-void\n-destroy_loop_vec_info (loop_vec_info loop_vinfo, bool clean_stmts)\n+_loop_vec_info::~_loop_vec_info ()\n {\n-  struct loop *loop;\n-  basic_block *bbs;\n   int nbbs;\n   gimple_stmt_iterator si;\n   int j;\n-  vec<slp_instance> slp_instances;\n-  slp_instance instance;\n-  bool swapped;\n-\n-  if (!loop_vinfo)\n-    return;\n-\n-  loop = LOOP_VINFO_LOOP (loop_vinfo);\n-\n-  bbs = LOOP_VINFO_BBS (loop_vinfo);\n-  nbbs = clean_stmts ? loop->num_nodes : 0;\n-  swapped = LOOP_VINFO_OPERANDS_SWAPPED (loop_vinfo);\n \n+  nbbs = loop->num_nodes;\n   for (j = 0; j < nbbs; j++)\n     {\n       basic_block bb = bbs[j];\n@@ -1216,7 +1181,7 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo, bool clean_stmts)\n \n \t  /* We may have broken canonical form by moving a constant\n \t     into RHS1 of a commutative op.  Fix such occurrences.  */\n-\t  if (swapped && is_gimple_assign (stmt))\n+\t  if (operands_swapped && is_gimple_assign (stmt))\n \t    {\n \t      enum tree_code code = gimple_assign_rhs_code (stmt);\n \n@@ -1256,28 +1221,8 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo, bool clean_stmts)\n         }\n     }\n \n-  free (LOOP_VINFO_BBS (loop_vinfo));\n-  vect_destroy_datarefs (loop_vinfo);\n-  free_dependence_relations (LOOP_VINFO_DDRS (loop_vinfo));\n-  LOOP_VINFO_LOOP_NEST (loop_vinfo).release ();\n-  LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo).release ();\n-  LOOP_VINFO_COMP_ALIAS_DDRS (loop_vinfo).release ();\n-  LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo).release ();\n-  slp_instances = LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n-  FOR_EACH_VEC_ELT (slp_instances, j, instance)\n-    vect_free_slp_instance (instance);\n-\n-  LOOP_VINFO_SLP_INSTANCES (loop_vinfo).release ();\n-  LOOP_VINFO_GROUPED_STORES (loop_vinfo).release ();\n-  LOOP_VINFO_REDUCTIONS (loop_vinfo).release ();\n-  LOOP_VINFO_REDUCTION_CHAINS (loop_vinfo).release ();\n-\n-  destroy_cost_data (LOOP_VINFO_TARGET_COST_DATA (loop_vinfo));\n-  loop_vinfo->scalar_cost_vec.release ();\n-\n-  LOOP_VINFO_CHECK_UNEQUAL_ADDRS (loop_vinfo).release ();\n+  free (bbs);\n \n-  free (loop_vinfo);\n   loop->aux = NULL;\n }\n \n@@ -1564,7 +1509,7 @@ vect_analyze_loop_form (struct loop *loop)\n \t\t\t\t  &number_of_iterations, &inner_loop_cond))\n     return NULL;\n \n-  loop_vec_info loop_vinfo = new_loop_vec_info (loop);\n+  loop_vec_info loop_vinfo = new _loop_vec_info (loop);\n   LOOP_VINFO_NITERSM1 (loop_vinfo) = number_of_iterationsm1;\n   LOOP_VINFO_NITERS (loop_vinfo) = number_of_iterations;\n   LOOP_VINFO_NITERS_UNCHANGED (loop_vinfo) = number_of_iterations;\n@@ -2412,7 +2357,7 @@ vect_analyze_loop (struct loop *loop, loop_vec_info orig_loop_vinfo)\n \t  return loop_vinfo;\n \t}\n \n-      destroy_loop_vec_info (loop_vinfo, true);\n+      delete loop_vinfo;\n \n       vector_sizes &= ~current_vector_size;\n       if (fatal"}, {"sha": "c713745b920ab886812c857b18b2fe11970cd552", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 25, "deletions": 54, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c515559f9dbe8bace5f68e2fec7600a9edc7c42/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c515559f9dbe8bace5f68e2fec7600a9edc7c42/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=2c515559f9dbe8bace5f68e2fec7600a9edc7c42", "patch": "@@ -2378,62 +2378,37 @@ vect_detect_hybrid_slp (loop_vec_info loop_vinfo)\n }\n \n \n-/* Create and initialize a new bb_vec_info struct for BB, as well as\n-   stmt_vec_info structs for all the stmts in it.  */\n-\n-static bb_vec_info\n-new_bb_vec_info (gimple_stmt_iterator region_begin,\n-\t\t gimple_stmt_iterator region_end)\n+/* Initialize a bb_vec_info struct for the statements between\n+   REGION_BEGIN_IN (inclusive) and REGION_END_IN (exclusive).  */\n+\n+_bb_vec_info::_bb_vec_info (gimple_stmt_iterator region_begin_in,\n+\t\t\t    gimple_stmt_iterator region_end_in)\n+  : vec_info (vec_info::bb, init_cost (NULL)),\n+    bb (gsi_bb (region_begin_in)),\n+    region_begin (region_begin_in),\n+    region_end (region_end_in)\n {\n-  basic_block bb = gsi_bb (region_begin);\n-  bb_vec_info res = NULL;\n   gimple_stmt_iterator gsi;\n \n-  res = (bb_vec_info) xcalloc (1, sizeof (struct _bb_vec_info));\n-  res->kind = vec_info::bb;\n-  BB_VINFO_BB (res) = bb;\n-  res->region_begin = region_begin;\n-  res->region_end = region_end;\n-\n   for (gsi = region_begin; gsi_stmt (gsi) != gsi_stmt (region_end);\n        gsi_next (&gsi))\n     {\n       gimple *stmt = gsi_stmt (gsi);\n       gimple_set_uid (stmt, 0);\n-      set_vinfo_for_stmt (stmt, new_stmt_vec_info (stmt, res));\n+      set_vinfo_for_stmt (stmt, new_stmt_vec_info (stmt, this));\n     }\n \n-  BB_VINFO_GROUPED_STORES (res).create (10);\n-  BB_VINFO_SLP_INSTANCES (res).create (2);\n-  BB_VINFO_TARGET_COST_DATA (res) = init_cost (NULL);\n-\n-  bb->aux = res;\n-  return res;\n+  bb->aux = this;\n }\n \n \n /* Free BB_VINFO struct, as well as all the stmt_vec_info structs of all the\n    stmts in the basic block.  */\n \n-static void\n-destroy_bb_vec_info (bb_vec_info bb_vinfo)\n+_bb_vec_info::~_bb_vec_info ()\n {\n-  slp_instance instance;\n-  unsigned i;\n-\n-  if (!bb_vinfo)\n-    return;\n-\n-  vect_destroy_datarefs (bb_vinfo);\n-  free_dependence_relations (BB_VINFO_DDRS (bb_vinfo));\n-  BB_VINFO_GROUPED_STORES (bb_vinfo).release ();\n-  FOR_EACH_VEC_ELT (BB_VINFO_SLP_INSTANCES (bb_vinfo), i, instance)\n-    vect_free_slp_instance (instance);\n-  BB_VINFO_SLP_INSTANCES (bb_vinfo).release ();\n-  destroy_cost_data (BB_VINFO_TARGET_COST_DATA (bb_vinfo));\n-\n-  for (gimple_stmt_iterator si = bb_vinfo->region_begin;\n-       gsi_stmt (si) != gsi_stmt (bb_vinfo->region_end); gsi_next (&si))\n+  for (gimple_stmt_iterator si = region_begin;\n+       gsi_stmt (si) != gsi_stmt (region_end); gsi_next (&si))\n     {\n       gimple *stmt = gsi_stmt (si);\n       stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n@@ -2446,8 +2421,7 @@ destroy_bb_vec_info (bb_vec_info bb_vinfo)\n       gimple_set_uid (stmt, -1);\n     }\n \n-  BB_VINFO_BB (bb_vinfo)->aux = NULL;\n-  free (bb_vinfo);\n+  bb->aux = NULL;\n }\n \n \n@@ -2729,7 +2703,7 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n       return NULL;\n     }\n \n-  bb_vinfo = new_bb_vec_info (region_begin, region_end);\n+  bb_vinfo = new _bb_vec_info (region_begin, region_end);\n   if (!bb_vinfo)\n     return NULL;\n \n@@ -2744,7 +2718,7 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n \t\t\t \"not vectorized: unhandled data-ref in basic \"\n \t\t\t \"block.\\n\");\n \n-      destroy_bb_vec_info (bb_vinfo);\n+      delete bb_vinfo;\n       return NULL;\n     }\n \n@@ -2755,7 +2729,7 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n \t\t\t \"not vectorized: not enough data-refs in \"\n \t\t\t \"basic block.\\n\");\n \n-      destroy_bb_vec_info (bb_vinfo);\n+      delete bb_vinfo;\n       return NULL;\n     }\n \n@@ -2766,7 +2740,7 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n \t\t\t\"not vectorized: unhandled data access in \"\n \t\t\t\"basic block.\\n\");\n \n-      destroy_bb_vec_info (bb_vinfo);\n+      delete bb_vinfo;\n       return NULL;\n     }\n \n@@ -2780,7 +2754,7 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n \t\t\t \"not vectorized: no grouped stores in \"\n \t\t\t \"basic block.\\n\");\n \n-      destroy_bb_vec_info (bb_vinfo);\n+      delete bb_vinfo;\n       return NULL;\n     }\n \n@@ -2802,7 +2776,7 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n \t\t\t   \"in basic block.\\n\");\n \t}\n \n-      destroy_bb_vec_info (bb_vinfo);\n+      delete bb_vinfo;\n       return NULL;\n     }\n \n@@ -2832,7 +2806,7 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n     }\n   if (! BB_VINFO_SLP_INSTANCES (bb_vinfo).length ())\n     {\n-      destroy_bb_vec_info (bb_vinfo);\n+      delete bb_vinfo;\n       return NULL;\n     }\n \n@@ -2843,7 +2817,7 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: bad operation in basic block.\\n\");\n \n-      destroy_bb_vec_info (bb_vinfo);\n+      delete bb_vinfo;\n       return NULL;\n     }\n \n@@ -2856,7 +2830,7 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n \t\t\t \"not vectorized: vectorization is not \"\n \t\t\t \"profitable.\\n\");\n \n-      destroy_bb_vec_info (bb_vinfo);\n+      delete bb_vinfo;\n       return NULL;\n     }\n \n@@ -2936,12 +2910,9 @@ vect_slp_bb (basic_block bb)\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t     \"basic block part vectorized\\n\");\n \n-\t  destroy_bb_vec_info (bb_vinfo);\n-\n \t  vectorized = true;\n \t}\n-      else\n-\tdestroy_bb_vec_info (bb_vinfo);\n+      delete bb_vinfo;\n \n       any_vectorized |= vectorized;\n "}, {"sha": "129129f6b68dbaaba9227c3d86edfabe98ac3800", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c515559f9dbe8bace5f68e2fec7600a9edc7c42/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c515559f9dbe8bace5f68e2fec7600a9edc7c42/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=2c515559f9dbe8bace5f68e2fec7600a9edc7c42", "patch": "@@ -354,22 +354,36 @@ shrink_simd_arrays\n   delete simd_array_to_simduid_htab;\n }\n \f\n-/* A helper function to free data refs.  */\n+/* Initialize the vec_info with kind KIND_IN and target cost data\n+   TARGET_COST_DATA_IN.  */\n+\n+vec_info::vec_info (vec_info::vec_kind kind_in, void *target_cost_data_in)\n+  : kind (kind_in),\n+    datarefs (vNULL),\n+    ddrs (vNULL),\n+    target_cost_data (target_cost_data_in)\n+{\n+}\n \n-void\n-vect_destroy_datarefs (vec_info *vinfo)\n+vec_info::~vec_info ()\n {\n+  slp_instance instance;\n   struct data_reference *dr;\n   unsigned int i;\n \n-  FOR_EACH_VEC_ELT (vinfo->datarefs, i, dr)\n+  FOR_EACH_VEC_ELT (datarefs, i, dr)\n     if (dr->aux)\n       {\n         free (dr->aux);\n         dr->aux = NULL;\n       }\n \n-  free_data_refs (vinfo->datarefs);\n+  FOR_EACH_VEC_ELT (slp_instances, i, instance)\n+    vect_free_slp_instance (instance);\n+\n+  free_data_refs (datarefs);\n+  free_dependence_relations (ddrs);\n+  destroy_cost_data (target_cost_data);\n }\n \n /* A helper function to free scev and LOOP niter information, as well as\n@@ -830,7 +844,7 @@ vectorize_loops (void)\n       has_mask_store = false;\n       if (loop_vinfo)\n \thas_mask_store = LOOP_VINFO_HAS_MASK_STORE (loop_vinfo);\n-      destroy_loop_vec_info (loop_vinfo, true);\n+      delete loop_vinfo;\n       if (has_mask_store)\n \toptimize_mask_stores (loop);\n       loop->aux = NULL;"}, {"sha": "e8acf6687b79c4ab0dafc501b86618d51fff280b", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c515559f9dbe8bace5f68e2fec7600a9edc7c42/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c515559f9dbe8bace5f68e2fec7600a9edc7c42/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=2c515559f9dbe8bace5f68e2fec7600a9edc7c42", "patch": "@@ -155,20 +155,27 @@ typedef std::pair<tree, tree> vec_object_pair;\n \n /* Vectorizer state common between loop and basic-block vectorization.  */\n struct vec_info {\n-  enum { bb, loop } kind;\n+  enum vec_kind { bb, loop };\n+\n+  vec_info (vec_kind, void *);\n+  ~vec_info ();\n+\n+  /* The type of vectorization.  */\n+  vec_kind kind;\n \n   /* All SLP instances.  */\n-  vec<slp_instance> slp_instances;\n+  auto_vec<slp_instance> slp_instances;\n \n-  /* All data references.  */\n+  /* All data references.  Freed by free_data_refs, so not an auto_vec.  */\n   vec<data_reference_p> datarefs;\n \n-  /* All data dependences.  */\n+  /* All data dependences.  Freed by free_dependence_relations, so not\n+     an auto_vec.  */\n   vec<ddr_p> ddrs;\n \n   /* All interleaving chains of stores, represented by the first\n      stmt in the chain.  */\n-  vec<gimple *> grouped_stores;\n+  auto_vec<gimple *> grouped_stores;\n \n   /* Cost data used by the target cost model.  */\n   void *target_cost_data;\n@@ -198,6 +205,8 @@ is_a_helper <_bb_vec_info *>::test (vec_info *i)\n /* Info on vectorized loops.                                       */\n /*-----------------------------------------------------------------*/\n typedef struct _loop_vec_info : public vec_info {\n+  _loop_vec_info (struct loop *);\n+  ~_loop_vec_info ();\n \n   /* The loop to which this info struct refers to.  */\n   struct loop *loop;\n@@ -239,32 +248,32 @@ typedef struct _loop_vec_info : public vec_info {\n   int ptr_mask;\n \n   /* The loop nest in which the data dependences are computed.  */\n-  vec<loop_p> loop_nest;\n+  auto_vec<loop_p> loop_nest;\n \n   /* Data Dependence Relations defining address ranges that are candidates\n      for a run-time aliasing check.  */\n-  vec<ddr_p> may_alias_ddrs;\n+  auto_vec<ddr_p> may_alias_ddrs;\n \n   /* Data Dependence Relations defining address ranges together with segment\n      lengths from which the run-time aliasing check is built.  */\n-  vec<dr_with_seg_len_pair_t> comp_alias_ddrs;\n+  auto_vec<dr_with_seg_len_pair_t> comp_alias_ddrs;\n \n   /* Check that the addresses of each pair of objects is unequal.  */\n-  vec<vec_object_pair> check_unequal_addrs;\n+  auto_vec<vec_object_pair> check_unequal_addrs;\n \n   /* Statements in the loop that have data references that are candidates for a\n      runtime (loop versioning) misalignment check.  */\n-  vec<gimple *> may_misalign_stmts;\n+  auto_vec<gimple *> may_misalign_stmts;\n \n   /* Reduction cycles detected in the loop. Used in loop-aware SLP.  */\n-  vec<gimple *> reductions;\n+  auto_vec<gimple *> reductions;\n \n   /* All reduction chains in the loop, represented by the first\n      stmt in the chain.  */\n-  vec<gimple *> reduction_chains;\n+  auto_vec<gimple *> reduction_chains;\n \n   /* Cost vector for a single scalar iteration.  */\n-  vec<stmt_info_for_cost> scalar_cost_vec;\n+  auto_vec<stmt_info_for_cost> scalar_cost_vec;\n \n   /* The unrolling factor needed to SLP the loop. In case of that pure SLP is\n      applied to the loop, i.e., no unrolling is needed, this is 1.  */\n@@ -399,6 +408,9 @@ nested_in_vect_loop_p (struct loop *loop, gimple *stmt)\n \n typedef struct _bb_vec_info : public vec_info\n {\n+  _bb_vec_info (gimple_stmt_iterator, gimple_stmt_iterator);\n+  ~_bb_vec_info ();\n+\n   basic_block bb;\n   gimple_stmt_iterator region_begin;\n   gimple_stmt_iterator region_end;\n@@ -802,8 +814,8 @@ void free_stmt_vec_info_vec (void);\n static inline stmt_vec_info\n vinfo_for_stmt (gimple *stmt)\n {\n-  unsigned int uid = gimple_uid (stmt);\n-  if (uid == 0)\n+  int uid = gimple_uid (stmt);\n+  if (uid <= 0)\n     return NULL;\n \n   return stmt_vec_info_vec[uid - 1];\n@@ -1177,7 +1189,6 @@ extern tree vect_create_addr_base_for_vector_ref (gimple *, gimple_seq *,\n \n /* In tree-vect-loop.c.  */\n /* FORNOW: Used in tree-parloops.c.  */\n-extern void destroy_loop_vec_info (loop_vec_info, bool);\n extern gimple *vect_force_simple_reduction (loop_vec_info, gimple *,\n \t\t\t\t\t    bool *, bool);\n /* Drive for loop analysis stage.  */\n@@ -1226,7 +1237,6 @@ void vect_pattern_recog (vec_info *);\n \n /* In tree-vectorizer.c.  */\n unsigned vectorize_loops (void);\n-void vect_destroy_datarefs (vec_info *);\n bool vect_stmt_in_region_p (vec_info *, gimple *);\n void vect_free_loop_info_assumptions (struct loop *);\n "}]}