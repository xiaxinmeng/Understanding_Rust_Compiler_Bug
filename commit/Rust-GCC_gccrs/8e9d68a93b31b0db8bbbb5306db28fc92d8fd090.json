{"sha": "8e9d68a93b31b0db8bbbb5306db28fc92d8fd090", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU5ZDY4YTkzYjMxYjBkYjhiYmJiNTMwNmRiMjhmYzkyZDhmZDA5MA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2014-02-04T18:56:59Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2014-02-04T18:56:59Z"}, "message": "re PR bootstrap/59913 ([4.9 Regresion] bootstrap failure on arm-linux-gnueabihf)\n\n2014-02-04  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR bootstrap/59913\n\t* lra-constraints.c (need_for_split_p): Use more 3 reloads as\n\tthreshold for pseudo splitting.\n\t(update_ebb_live_info): Process call argument hard registers and\n\thard registers from insn definition too.\n\t(max_small_class_regs_num): New constant.\n\t(inherit_in_ebb): Update live hard regs through EBBs.  Update\n\treloads_num only for small register classes.  Don't split for\n\toutputs of jumps.\n\nFrom-SVN: r207485", "tree": {"sha": "ab89ce4cf892477265f6cdc2fab9df0a087eaa03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab89ce4cf892477265f6cdc2fab9df0a087eaa03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e9d68a93b31b0db8bbbb5306db28fc92d8fd090", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e9d68a93b31b0db8bbbb5306db28fc92d8fd090", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e9d68a93b31b0db8bbbb5306db28fc92d8fd090", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e9d68a93b31b0db8bbbb5306db28fc92d8fd090/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "66f206041a2088880a65063e1bfa18b9ef86f4e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66f206041a2088880a65063e1bfa18b9ef86f4e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66f206041a2088880a65063e1bfa18b9ef86f4e4"}], "stats": {"total": 55, "additions": 45, "deletions": 10}, "files": [{"sha": "6bc1933fddea20ffd30a6a4a1d9cee1e6e78bf4b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e9d68a93b31b0db8bbbb5306db28fc92d8fd090/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e9d68a93b31b0db8bbbb5306db28fc92d8fd090/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e9d68a93b31b0db8bbbb5306db28fc92d8fd090", "patch": "@@ -1,3 +1,15 @@\n+2014-02-04  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR bootstrap/59913\n+\t* lra-constraints.c (need_for_split_p): Use more 3 reloads as\n+\tthreshold for pseudo splitting.\n+\t(update_ebb_live_info): Process call argument hard registers and\n+\thard registers from insn definition too.\n+\t(max_small_class_regs_num): New constant.\n+\t(inherit_in_ebb): Update live hard regs through EBBs.  Update\n+\treloads_num only for small register classes.  Don't split for\n+\toutputs of jumps.\n+\n 2014-02-04  Markus Trippelsdorf  <markus@trippelsdorf.de>\n \n \tPR ipa/60058"}, {"sha": "5302321deb7146a5963d915375310b62943a0225", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e9d68a93b31b0db8bbbb5306db28fc92d8fd090/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e9d68a93b31b0db8bbbb5306db28fc92d8fd090/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=8e9d68a93b31b0db8bbbb5306db28fc92d8fd090", "patch": "@@ -4583,7 +4583,7 @@ need_for_split_p (HARD_REG_SET potential_reload_hard_regs, int regno)\n \t      impossibility to find hard register for reload pseudo of\n \t      small register class.  */\n \t   && (usage_insns[regno].reloads_num\n-\t       + (regno < FIRST_PSEUDO_REGISTER ? 0 : 2) < reloads_num)\n+\t       + (regno < FIRST_PSEUDO_REGISTER ? 0 : 3) < reloads_num)\n \t   && (regno < FIRST_PSEUDO_REGISTER\n \t       /* For short living pseudos, spilling + inheritance can\n \t\t  be considered a substitution for splitting.\n@@ -4840,7 +4840,7 @@ static void\n update_ebb_live_info (rtx head, rtx tail)\n {\n   unsigned int j;\n-  int regno;\n+  int i, regno;\n   bool live_p;\n   rtx prev_insn, set;\n   bool remove_p;\n@@ -4898,6 +4898,7 @@ update_ebb_live_info (rtx head, rtx tail)\n       if (! NONDEBUG_INSN_P (curr_insn))\n \tcontinue;\n       curr_id = lra_get_insn_recog_data (curr_insn);\n+      curr_static_id = curr_id->insn_static_data;\n       remove_p = false;\n       if ((set = single_set (curr_insn)) != NULL_RTX && REG_P (SET_DEST (set))\n \t  && (regno = REGNO (SET_DEST (set))) >= FIRST_PSEUDO_REGISTER\n@@ -4908,11 +4909,23 @@ update_ebb_live_info (rtx head, rtx tail)\n       for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n \tif (reg->type == OP_OUT && ! reg->subreg_p)\n \t  bitmap_clear_bit (&live_regs, reg->regno);\n+      for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n+\tif (reg->type == OP_OUT && ! reg->subreg_p)\n+\t  bitmap_clear_bit (&live_regs, reg->regno);\n       /* Mark each used value as live.  */\n       for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n \tif (reg->type != OP_OUT\n \t    && bitmap_bit_p (&check_only_regs, reg->regno))\n \t  bitmap_set_bit (&live_regs, reg->regno);\n+      for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n+\tif (reg->type != OP_OUT\n+\t    && bitmap_bit_p (&check_only_regs, reg->regno))\n+\t  bitmap_set_bit (&live_regs, reg->regno);\n+      if (curr_id->arg_hard_regs != NULL)\n+\t/* Make argument hard registers live.  */\n+\tfor (i = 0; (regno = curr_id->arg_hard_regs[i]) >= 0; i++)\n+\t  if (bitmap_bit_p (&check_only_regs, regno))\n+\t    bitmap_set_bit (&live_regs, regno);\n       /* It is quite important to remove dead move insns because it\n \t means removing dead store.  We don't need to process them for\n \t constraints.  */\n@@ -5002,6 +5015,14 @@ get_live_on_other_edges (basic_block from, basic_block to, bitmap res)\n /* Used as a temporary results of some bitmap calculations.  */\n static bitmap_head temp_bitmap;\n \n+/* We split for reloads of small class of hard regs.  The following\n+   defines how many hard regs the class should have to be qualified as\n+   small.  The code is mostly oriented to x86/x86-64 architecture\n+   where some insns need to use only specific register or pair of\n+   registers and these register can live in RTL explicitly, e.g. for\n+   parameter passing.  */\n+static const int max_small_class_regs_num = 2;\n+\n /* Do inheritance/split transformations in EBB starting with HEAD and\n    finishing on TAIL.  We process EBB insns in the reverse order.\n    Return true if we did any inheritance/split transformation in the\n@@ -5036,7 +5057,8 @@ inherit_in_ebb (rtx head, rtx tail)\n   bitmap_clear (&check_only_regs);\n   last_processed_bb = NULL;\n   CLEAR_HARD_REG_SET (potential_reload_hard_regs);\n-  CLEAR_HARD_REG_SET (live_hard_regs);\n+  COPY_HARD_REG_SET (live_hard_regs, eliminable_regset);\n+  IOR_HARD_REG_SET (live_hard_regs, lra_no_alloc_regs);\n   /* We don't process new insns generated in the loop.\t*/\n   for (curr_insn = tail; curr_insn != PREV_INSN (head); curr_insn = prev_insn)\n     {\n@@ -5062,9 +5084,6 @@ inherit_in_ebb (rtx head, rtx tail)\n \t\t\t || (find_reg_note (last_insn,\n \t\t\t\t\t   REG_NORETURN, NULL_RTX) == NULL_RTX\n \t\t\t     && ! SIBLING_CALL_P (last_insn))));\n-\t  REG_SET_TO_HARD_REG_SET (live_hard_regs, df_get_live_out (curr_bb));\n-\t  IOR_HARD_REG_SET (live_hard_regs, eliminable_regset);\n-\t  IOR_HARD_REG_SET (live_hard_regs, lra_no_alloc_regs);\n \t  CLEAR_HARD_REG_SET (potential_reload_hard_regs);\n \t  EXECUTE_IF_SET_IN_BITMAP (to_process, 0, j, bi)\n \t    {\n@@ -5098,7 +5117,8 @@ inherit_in_ebb (rtx head, rtx tail)\n \t  && (cl = lra_get_allocno_class (dst_regno)) != NO_REGS)\n \t{\n \t  /* 'reload_pseudo <- original_pseudo'.  */\n-\t  reloads_num++;\n+\t  if (ira_class_hard_regs_num[cl] <= max_small_class_regs_num)\n+\t    reloads_num++;\n \t  update_reloads_num_p = false;\n \t  succ_p = false;\n \t  if (usage_insns[src_regno].check == curr_usage_insns_check\n@@ -5122,7 +5142,8 @@ inherit_in_ebb (rtx head, rtx tail)\n \t       && (next_usage_insns\n \t\t   = usage_insns[dst_regno].insns) != NULL_RTX)\n \t{\n-\t  reloads_num++;\n+\t  if (ira_class_hard_regs_num[cl] <= max_small_class_regs_num)\n+\t    reloads_num++;\n \t  update_reloads_num_p = false;\n \t  /* 'original_pseudo <- reload_pseudo'.  */\n \t  if (! JUMP_P (curr_insn)\n@@ -5287,14 +5308,15 @@ inherit_in_ebb (rtx head, rtx tail)\n \t\t      before_p = (JUMP_P (curr_insn)\n \t\t\t\t  || (CALL_P (curr_insn) && reg->type == OP_IN));\n \t\t      if (NONDEBUG_INSN_P (curr_insn)\n+\t\t\t  && (! JUMP_P (curr_insn) || reg->type == OP_IN)\n \t\t\t  && split_if_necessary (src_regno, reg->biggest_mode,\n \t\t\t\t\t\t potential_reload_hard_regs,\n \t\t\t\t\t\t before_p, curr_insn, max_uid))\n \t\t\t{\n \t\t\t  if (reg->subreg_p)\n \t\t\t    lra_risky_transformations_p = true;\n \t\t\t  change_p = true;\n-\t\t\t  /* Invalidate.\t*/\n+\t\t\t  /* Invalidate. */\n \t\t\t  usage_insns[src_regno].check = 0;\n \t\t\t  if (before_p)\n \t\t\t    use_insn = PREV_INSN (curr_insn);\n@@ -5344,7 +5366,8 @@ inherit_in_ebb (rtx head, rtx tail)\n \t          && reg_renumber[regno] < 0\n \t          && (cl = lra_get_allocno_class (regno)) != NO_REGS))\n \t    {\n-\t      reloads_num++;\n+\t      if (ira_class_hard_regs_num[cl] <= max_small_class_regs_num)\n+\t\treloads_num++;\n \t      if (hard_reg_set_subset_p (reg_class_contents[cl], live_hard_regs))\n \t\tIOR_HARD_REG_SET (potential_reload_hard_regs,\n \t                          reg_class_contents[cl]);"}]}