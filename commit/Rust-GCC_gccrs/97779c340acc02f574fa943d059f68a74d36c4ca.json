{"sha": "97779c340acc02f574fa943d059f68a74d36c4ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc3NzljMzQwYWNjMDJmNTc0ZmE5NDNkMDU5ZjY4YTc0ZDM2YzRjYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-06T09:53:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-06T09:53:00Z"}, "message": "[multiple changes]\n\n2014-02-06  Robert Dewar  <dewar@adacore.com>\n\n\t* sprint.adb: Minor reformatting.\n\n2014-02-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch4.adb (Process_Transient_Object): Add local variable\n\tTemp_Ins. When the transient object is initialized by an\n\taggregate, the hook must capture the object after the last\n\tcomponent assignment takes place.\n\t* exp_ch7.adb (Detect_Subprogram_Call): Expose the subprogram to\n\troutine Is_Subprogram_Call.\n\t(Is_Subprogram_Call): Inspect an\n\taggregate that has been heavily expanded for subprogram calls.\n\t(Process_Transient_Objects): Add local variables Expr, Ptr_Id\n\tand Temp_Ins.  Remove the nested declare block and adjust the\n\tindentation. When the transient object is initialized by an\n\taggregate, the hook must capture the object after the last\n\tcomponent assignment takes place.\n\n2014-02-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Global_Item): Detect illegal uses of\n\texternal states with enabled properties that do not match the\n\tglobal mode.\n\t(Property_Error): New routine.\n\t* sem_res.adb (Property_Error): New routine.\n\t(Resolve_Actuals): Detect illegal uses of external variables with\n\tenabled properties in procedure calls that do not match the mode of\n\tthe corresponding formal parameter.\n\n2014-02-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_util.adb (Has_Enabled_Property): Rename\n\tformal parameter Prop_Nam to Property. Update the comment on usage\n\tand all occurrences in the body. Add local variable Prop_Nam. When\n\tinspecting a property with an expression, the property name\n\tappears as the first choice of the component association.\n\nFrom-SVN: r207534", "tree": {"sha": "0ee2912d63a73536733f817f576811cb7ab23f41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ee2912d63a73536733f817f576811cb7ab23f41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97779c340acc02f574fa943d059f68a74d36c4ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97779c340acc02f574fa943d059f68a74d36c4ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97779c340acc02f574fa943d059f68a74d36c4ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97779c340acc02f574fa943d059f68a74d36c4ca/comments", "author": null, "committer": null, "parents": [{"sha": "c801e24619405cf2ca3eb3faea28c45f10ce00d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c801e24619405cf2ca3eb3faea28c45f10ce00d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c801e24619405cf2ca3eb3faea28c45f10ce00d7"}], "stats": {"total": 358, "additions": 281, "deletions": 77}, "files": [{"sha": "0ee4e1e454958c8fe29433adb9f7f40d32c20eb2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97779c340acc02f574fa943d059f68a74d36c4ca/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97779c340acc02f574fa943d059f68a74d36c4ca/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=97779c340acc02f574fa943d059f68a74d36c4ca", "patch": "@@ -1,3 +1,42 @@\n+2014-02-06  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sprint.adb: Minor reformatting.\n+\n+2014-02-06  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch4.adb (Process_Transient_Object): Add local variable\n+\tTemp_Ins. When the transient object is initialized by an\n+\taggregate, the hook must capture the object after the last\n+\tcomponent assignment takes place.\n+\t* exp_ch7.adb (Detect_Subprogram_Call): Expose the subprogram to\n+\troutine Is_Subprogram_Call.\n+\t(Is_Subprogram_Call): Inspect an\n+\taggregate that has been heavily expanded for subprogram calls.\n+\t(Process_Transient_Objects): Add local variables Expr, Ptr_Id\n+\tand Temp_Ins.  Remove the nested declare block and adjust the\n+\tindentation. When the transient object is initialized by an\n+\taggregate, the hook must capture the object after the last\n+\tcomponent assignment takes place.\n+\n+2014-02-06  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Global_Item): Detect illegal uses of\n+\texternal states with enabled properties that do not match the\n+\tglobal mode.\n+\t(Property_Error): New routine.\n+\t* sem_res.adb (Property_Error): New routine.\n+\t(Resolve_Actuals): Detect illegal uses of external variables with\n+\tenabled properties in procedure calls that do not match the mode of\n+\tthe corresponding formal parameter.\n+\n+2014-02-06  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_util.adb (Has_Enabled_Property): Rename\n+\tformal parameter Prop_Nam to Property. Update the comment on usage\n+\tand all occurrences in the body. Add local variable Prop_Nam. When\n+\tinspecting a property with an expression, the property name\n+\tappears as the first choice of the component association.\n+\n 2014-02-04  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch5.adb, einfo.ads, freeze.adb, sem_ch8.adb: Minor reformatting."}, {"sha": "d0ee791d513683cdc671573ccd57b9aff3ba7b24", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97779c340acc02f574fa943d059f68a74d36c4ca/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97779c340acc02f574fa943d059f68a74d36c4ca/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=97779c340acc02f574fa943d059f68a74d36c4ca", "patch": "@@ -12386,6 +12386,7 @@ package body Exp_Ch4 is\n       Fin_Stmts : List_Id;\n       Ptr_Id    : Entity_Id;\n       Temp_Id   : Entity_Id;\n+      Temp_Ins  : Node_Id;\n \n    --  Start of processing for Process_Transient_Object\n \n@@ -12463,7 +12464,22 @@ package body Exp_Ch4 is\n       --      <or>\n       --    Temp := Obj_Id'Unrestricted_Access;\n \n-      Insert_After_And_Analyze (Decl,\n+      --  When the transient object is initialized by an aggregate, the hook\n+      --  must capture the object after the last component assignment takes\n+      --  place. Only then is the object fully initialized.\n+\n+      if Ekind (Obj_Id) = E_Variable\n+        and then Present (Last_Aggregate_Assignment (Obj_Id))\n+      then\n+         Temp_Ins := Last_Aggregate_Assignment (Obj_Id);\n+\n+      --  Otherwise the hook seizes the related object immediately\n+\n+      else\n+         Temp_Ins := Decl;\n+      end if;\n+\n+      Insert_After_And_Analyze (Temp_Ins,\n         Make_Assignment_Statement (Loc,\n           Name       => New_Reference_To (Temp_Id, Loc),\n           Expression => Expr));"}, {"sha": "5e90723c577123f585e90bb5acb78a97b4650bbc", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 98, "deletions": 63, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97779c340acc02f574fa943d059f68a74d36c4ca/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97779c340acc02f574fa943d059f68a74d36c4ca/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=97779c340acc02f574fa943d059f68a74d36c4ca", "patch": "@@ -2454,11 +2454,22 @@ package body Exp_Ch7 is\n              Expression => Make_Integer_Literal (Loc, Counter_Val));\n \n          --  Insert the counter after all initialization has been done. The\n-         --  place of insertion depends on the context. When dealing with a\n-         --  controlled function, the counter is inserted directly after the\n-         --  declaration because such objects lack init calls.\n+         --  place of insertion depends on the context. If an object is being\n+         --  initialized via an aggregate, then the counter must be inserted\n+         --  after the last aggregate assignment.\n \n-         Find_Last_Init (Decl, Obj_Typ, Count_Ins, Body_Ins);\n+         if Ekind (Obj_Id) = E_Variable\n+           and then Present (Last_Aggregate_Assignment (Obj_Id))\n+         then\n+            Count_Ins := Last_Aggregate_Assignment (Obj_Id);\n+            Body_Ins  := Empty;\n+\n+         --  In all other cases the counter is inserted after the last call to\n+         --  either [Deep_]Initialize or the type specific init proc.\n+\n+         else\n+            Find_Last_Init (Decl, Obj_Typ, Count_Ins, Body_Ins);\n+         end if;\n \n          Insert_After (Count_Ins, Inc_Decl);\n          Analyze (Inc_Decl);\n@@ -4419,17 +4430,25 @@ package body Exp_Ch7 is\n          function Is_Subprogram_Call (N : Node_Id) return Traverse_Result;\n          --  Determine whether an arbitrary node denotes a subprogram call\n \n+         procedure Detect_Subprogram_Call is\n+           new Traverse_Proc (Is_Subprogram_Call);\n+\n          ------------------------\n          -- Is_Subprogram_Call --\n          ------------------------\n \n          function Is_Subprogram_Call (N : Node_Id) return Traverse_Result is\n          begin\n-            --  A regular procedure or function call\n+            --  Aggregates are usually rewritten into component by component\n+            --  assignments and replaced by a reference to a temporary in the\n+            --  original tree. Peek in the aggregate to detect function calls.\n \n-            if Nkind (N) in N_Subprogram_Call then\n-               Must_Hook := True;\n-               return Abandon;\n+            if Nkind (N) = N_Identifier\n+              and then Nkind_In (Original_Node (N), N_Aggregate,\n+                                                    N_Extension_Aggregate)\n+            then\n+               Detect_Subprogram_Call (Original_Node (N));\n+               return OK;\n \n             --  Detect a call to a function that returns on the secondary stack\n \n@@ -4439,20 +4458,24 @@ package body Exp_Ch7 is\n                Must_Hook := True;\n                return Abandon;\n \n+            --  A regular procedure or function call\n+\n+            elsif Nkind (N) in N_Subprogram_Call then\n+               Must_Hook := True;\n+               return Abandon;\n+\n             --  Keep searching\n \n             else\n                return OK;\n             end if;\n          end Is_Subprogram_Call;\n \n-         procedure Detect_Subprogram_Call is\n-           new Traverse_Proc (Is_Subprogram_Call);\n-\n          --  Local variables\n \n          Built     : Boolean := False;\n          Desig_Typ : Entity_Id;\n+         Expr      : Node_Id;\n          Fin_Block : Node_Id;\n          Fin_Data  : Finalization_Exception_Data;\n          Fin_Decls : List_Id;\n@@ -4462,9 +4485,11 @@ package body Exp_Ch7 is\n          Obj_Ref   : Node_Id;\n          Obj_Typ   : Entity_Id;\n          Prev_Fin  : Node_Id := Empty;\n+         Ptr_Id    : Entity_Id;\n          Stmt      : Node_Id;\n          Stmts     : List_Id;\n          Temp_Id   : Entity_Id;\n+         Temp_Ins  : Node_Id;\n \n       --  Start of processing for Process_Transient_Objects\n \n@@ -4505,11 +4530,10 @@ package body Exp_Ch7 is\n                --  time around.\n \n                if not Built then\n+                  Built     := True;\n                   Fin_Decls := New_List;\n \n                   Build_Object_Declarations (Fin_Data, Fin_Decls, Loc);\n-\n-                  Built := True;\n                end if;\n \n                --  Transient variables associated with subprogram calls need\n@@ -4524,69 +4548,80 @@ package body Exp_Ch7 is\n                --  \"hooks\" are picked up by the finalization machinery.\n \n                if Must_Hook then\n-                  declare\n-                     Expr   : Node_Id;\n-                     Ptr_Id : Entity_Id;\n \n-                  begin\n-                     --  Step 1: Create an access type which provides a\n-                     --  reference to the transient object. Generate:\n+                  --  Step 1: Create an access type which provides a reference\n+                  --  to the transient object. Generate:\n \n-                     --    Ann : access [all] <Desig_Typ>;\n+                  --    Ann : access [all] <Desig_Typ>;\n \n-                     Ptr_Id := Make_Temporary (Loc, 'A');\n+                  Ptr_Id := Make_Temporary (Loc, 'A');\n \n-                     Insert_Action (Stmt,\n-                       Make_Full_Type_Declaration (Loc,\n-                         Defining_Identifier => Ptr_Id,\n-                         Type_Definition     =>\n-                           Make_Access_To_Object_Definition (Loc,\n-                             All_Present        =>\n-                               Ekind (Obj_Typ) = E_General_Access_Type,\n-                             Subtype_Indication =>\n-                               New_Reference_To (Desig_Typ, Loc))));\n+                  Insert_Action (Stmt,\n+                    Make_Full_Type_Declaration (Loc,\n+                      Defining_Identifier => Ptr_Id,\n+                      Type_Definition     =>\n+                        Make_Access_To_Object_Definition (Loc,\n+                          All_Present        =>\n+                            Ekind (Obj_Typ) = E_General_Access_Type,\n+                          Subtype_Indication =>\n+                            New_Reference_To (Desig_Typ, Loc))));\n \n-                     --  Step 2: Create a temporary which acts as a hook to\n-                     --  the transient object. Generate:\n+                  --  Step 2: Create a temporary which acts as a hook to the\n+                  --  transient object. Generate:\n \n-                     --    Temp : Ptr_Id := null;\n+                  --    Temp : Ptr_Id := null;\n \n-                     Temp_Id := Make_Temporary (Loc, 'T');\n+                  Temp_Id := Make_Temporary (Loc, 'T');\n \n-                     Insert_Action (Stmt,\n-                       Make_Object_Declaration (Loc,\n-                         Defining_Identifier => Temp_Id,\n-                         Object_Definition   =>\n-                           New_Reference_To (Ptr_Id, Loc)));\n+                  Insert_Action (Stmt,\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Temp_Id,\n+                      Object_Definition   =>\n+                        New_Reference_To (Ptr_Id, Loc)));\n \n-                     --  Mark the temporary as a transient hook. This signals\n-                     --  the machinery in Build_Finalizer to recognize this\n-                     --  special case.\n+                  --  Mark the temporary as a transient hook. This signals the\n+                  --  machinery in Build_Finalizer to recognize this special\n+                  --  case.\n \n-                     Set_Status_Flag_Or_Transient_Decl (Temp_Id, Stmt);\n+                  Set_Status_Flag_Or_Transient_Decl (Temp_Id, Stmt);\n \n-                     --  Step 3: Hook the transient object to the temporary\n+                  --  Step 3: Hook the transient object to the temporary\n \n-                     if Is_Access_Type (Obj_Typ) then\n-                        Expr :=\n-                          Convert_To (Ptr_Id, New_Reference_To (Obj_Id, Loc));\n-                     else\n-                        Expr :=\n-                          Make_Attribute_Reference (Loc,\n-                            Prefix         => New_Reference_To (Obj_Id, Loc),\n-                            Attribute_Name => Name_Unrestricted_Access);\n-                     end if;\n+                  if Is_Access_Type (Obj_Typ) then\n+                     Expr :=\n+                       Convert_To (Ptr_Id, New_Reference_To (Obj_Id, Loc));\n+                  else\n+                     Expr :=\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix         => New_Reference_To (Obj_Id, Loc),\n+                         Attribute_Name => Name_Unrestricted_Access);\n+                  end if;\n \n-                     --  Generate:\n-                     --    Temp := Ptr_Id (Obj_Id);\n-                     --      <or>\n-                     --    Temp := Obj_Id'Unrestricted_Access;\n-\n-                     Insert_After_And_Analyze (Stmt,\n-                       Make_Assignment_Statement (Loc,\n-                         Name       => New_Reference_To (Temp_Id, Loc),\n-                         Expression => Expr));\n-                  end;\n+                  --  Generate:\n+                  --    Temp := Ptr_Id (Obj_Id);\n+                  --      <or>\n+                  --    Temp := Obj_Id'Unrestricted_Access;\n+\n+                  --  When the transient object is initialized by an aggregate,\n+                  --  the hook must capture the object after the last component\n+                  --  assignment takes place. Only then is the object fully\n+                  --  initialized.\n+\n+                  if Ekind (Obj_Id) = E_Variable\n+                    and then Present (Last_Aggregate_Assignment (Obj_Id))\n+                  then\n+                     Temp_Ins := Last_Aggregate_Assignment (Obj_Id);\n+\n+                  --  Otherwise the hook seizes the related object immediately\n+\n+                  else\n+                     Temp_Ins := Stmt;\n+                  end if;\n+\n+                  Insert_After_And_Analyze (Temp_Ins,\n+                    Make_Assignment_Statement (Loc,\n+                      Name       => New_Reference_To (Temp_Id, Loc),\n+                      Expression => Expr));\n                end if;\n \n                Stmts := New_List;"}, {"sha": "344bd27659dd7c8238570cd1e7b9c5848689c71e", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97779c340acc02f574fa943d059f68a74d36c4ca/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97779c340acc02f574fa943d059f68a74d36c4ca/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=97779c340acc02f574fa943d059f68a74d36c4ca", "patch": "@@ -1861,8 +1861,34 @@ package body Sem_Prag is\n            (Item        : Node_Id;\n             Global_Mode : Name_Id)\n          is\n+            procedure Property_Error\n+              (State_Id : Entity_Id;\n+               Prop_Nam : Name_Id);\n+            --  Emit an error concerning state State_Id with enabled property\n+            --  Async_Readers, Effective_Reads or Effective_Writes that is not\n+            --  marked as In_Out or Output item.\n+\n+            --------------------\n+            -- Property_Error --\n+            --------------------\n+\n+            procedure Property_Error\n+              (State_Id : Entity_Id;\n+               Prop_Nam : Name_Id)\n+            is\n+            begin\n+               Error_Msg_Name_1 := Prop_Nam;\n+               Error_Msg_NE\n+                 (\"external state & with enabled property % must have mode \"\n+                  & \"In_Out or Output (SPARK RM 7.1.2(7))\", Item, State_Id);\n+            end Property_Error;\n+\n+            --  Local variables\n+\n             Item_Id : Entity_Id;\n \n+         --  Start of processing for Analyze_Global_Item\n+\n          begin\n             --  Detect one of the following cases\n \n@@ -1941,6 +1967,30 @@ package body Sem_Prag is\n                         Ref      => Item);\n                   end if;\n \n+                  --  Detect an external state with an enabled property that\n+                  --  does not match the mode of the state.\n+\n+                  if Global_Mode = Name_Input then\n+                     if Async_Readers_Enabled (Item_Id) then\n+                        Property_Error (Item_Id, Name_Async_Readers);\n+\n+                     elsif Effective_Reads_Enabled (Item_Id) then\n+                        Property_Error (Item_Id, Name_Effective_Reads);\n+\n+                     elsif Effective_Writes_Enabled (Item_Id) then\n+                        Property_Error (Item_Id, Name_Effective_Writes);\n+                     end if;\n+\n+                  elsif Global_Mode = Name_Output\n+                    and then Async_Writers_Enabled (Item_Id)\n+                  then\n+                     Error_Msg_Name_1 := Name_Async_Writers;\n+                     Error_Msg_NE\n+                       (\"external state & with enabled property % must have \"\n+                        & \"mode Input or In_Out (SPARK RM 7.1.2(7))\",\n+                        Item, Item_Id);\n+                  end if;\n+\n                --  Variable related checks\n \n                else"}, {"sha": "c7a7e08f4314c59dd2b37b9ad4d575a1971dd54c", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97779c340acc02f574fa943d059f68a74d36c4ca/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97779c340acc02f574fa943d059f68a74d36c4ca/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=97779c340acc02f574fa943d059f68a74d36c4ca", "patch": "@@ -3020,8 +3020,9 @@ package body Sem_Res is\n    procedure Resolve_Actuals (N : Node_Id; Nam : Entity_Id) is\n       Loc    : constant Source_Ptr := Sloc (N);\n       A      : Node_Id;\n-      F      : Entity_Id;\n+      A_Id   : Entity_Id;\n       A_Typ  : Entity_Id;\n+      F      : Entity_Id;\n       F_Typ  : Entity_Id;\n       Prev   : Node_Id := Empty;\n       Orig_A : Node_Id;\n@@ -3043,6 +3044,14 @@ package body Sem_Res is\n       --  an instance of the default expression. The insertion is always\n       --  a named association.\n \n+      procedure Property_Error\n+        (Var      : Node_Id;\n+         Var_Id   : Entity_Id;\n+         Prop_Nam : Name_Id);\n+      --  Emit an error concerning variable Var with entity Var_Id that has\n+      --  enabled property Prop_Nam when it acts as an actual parameter in a\n+      --  call and the corresponding formal parameter is of mode IN.\n+\n       function Same_Ancestor (T1, T2 : Entity_Id) return Boolean;\n       --  Check whether T1 and T2, or their full views, are derived from a\n       --  common type. Used to enforce the restrictions on array conversions\n@@ -3374,6 +3383,23 @@ package body Sem_Res is\n          Prev := Actval;\n       end Insert_Default;\n \n+      --------------------\n+      -- Property_Error --\n+      --------------------\n+\n+      procedure Property_Error\n+        (Var      : Node_Id;\n+         Var_Id   : Entity_Id;\n+         Prop_Nam : Name_Id)\n+      is\n+      begin\n+         Error_Msg_Name_1 := Prop_Nam;\n+         Error_Msg_NE\n+           (\"external variable & with enabled property % cannot appear as \"\n+            & \"actual in procedure call (SPARK RM 7.1.3(11))\", Var, Var_Id);\n+         Error_Msg_N (\"\\\\corresponding formal parameter has mode In\", Var);\n+      end Property_Error;\n+\n       -------------------\n       -- Same_Ancestor --\n       -------------------\n@@ -4288,6 +4314,41 @@ package body Sem_Res is\n                     (\"volatile object cannot act as actual in a call (SPARK \"\n                      & \"RM 7.1.3(12))\", A);\n                end if;\n+\n+               --  Detect an external variable with an enabled property that\n+               --  does not match the mode of the corresponding formal in a\n+               --  procedure call.\n+\n+               --  why only procedure calls ???\n+\n+               if Ekind (Nam) = E_Procedure\n+                 and then Is_Entity_Name (A)\n+                 and then Present (Entity (A))\n+                 and then Ekind (Entity (A)) = E_Variable\n+               then\n+                  A_Id := Entity (A);\n+\n+                  if Ekind (F) = E_In_Parameter then\n+                     if Async_Readers_Enabled (A_Id) then\n+                        Property_Error (A, A_Id, Name_Async_Readers);\n+                     elsif Effective_Reads_Enabled (A_Id) then\n+                        Property_Error (A, A_Id, Name_Effective_Reads);\n+                     elsif Effective_Writes_Enabled (A_Id) then\n+                        Property_Error (A, A_Id, Name_Effective_Writes);\n+                     end if;\n+\n+                  elsif Ekind (F) = E_Out_Parameter\n+                    and then Async_Writers_Enabled (A_Id)\n+                  then\n+                     Error_Msg_Name_1 := Name_Async_Writers;\n+                     Error_Msg_NE\n+                       (\"external variable & with enabled property % cannot \"\n+                        & \"appear as actual in procedure call (SPARK RM \"\n+                        & \"7.1.3(11))\", A, A_Id);\n+                     Error_Msg_N\n+                       (\"\\\\corresponding formal parameter has mode Out\", A);\n+                  end if;\n+               end if;\n             end if;\n \n             Next_Actual (A);"}, {"sha": "ba978e1aa7642e14fc23568b7889a031cb8e06df", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97779c340acc02f574fa943d059f68a74d36c4ca/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97779c340acc02f574fa943d059f68a74d36c4ca/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=97779c340acc02f574fa943d059f68a74d36c4ca", "patch": "@@ -115,10 +115,10 @@ package body Sem_Util is\n \n    function Has_Enabled_Property\n      (State_Id : Node_Id;\n-      Prop_Nam : Name_Id) return Boolean;\n+      Property : Name_Id) return Boolean;\n    --  Subsidiary to routines Async_xxx_Enabled and Effective_xxx_Enabled.\n    --  Determine whether an abstract state denoted by its entity State_Id has\n-   --  enabled property Prop_Name.\n+   --  enabled property Property.\n \n    function Has_Null_Extension (T : Entity_Id) return Boolean;\n    --  T is a derived tagged type. Check whether the type extension is null.\n@@ -7255,13 +7255,14 @@ package body Sem_Util is\n \n    function Has_Enabled_Property\n      (State_Id : Node_Id;\n-      Prop_Nam : Name_Id) return Boolean\n+      Property : Name_Id) return Boolean\n    is\n-      Decl    : constant Node_Id := Parent (State_Id);\n-      Opt     : Node_Id;\n-      Opt_Nam : Node_Id;\n-      Prop    : Node_Id;\n-      Props   : Node_Id;\n+      Decl     : constant Node_Id := Parent (State_Id);\n+      Opt      : Node_Id;\n+      Opt_Nam  : Node_Id;\n+      Prop     : Node_Id;\n+      Prop_Nam : Node_Id;\n+      Props    : Node_Id;\n \n    begin\n       --  The declaration of an external abstract state appears as an extension\n@@ -7305,7 +7306,7 @@ package body Sem_Util is\n \n                Prop := First (Expressions (Props));\n                while Present (Prop) loop\n-                  if Chars (Prop) = Prop_Nam then\n+                  if Chars (Prop) = Property then\n                      return True;\n                   end if;\n \n@@ -7316,7 +7317,9 @@ package body Sem_Util is\n \n                Prop := First (Component_Associations (Props));\n                while Present (Prop) loop\n-                  if Chars (Prop) = Prop_Nam then\n+                  Prop_Nam := First (Choices (Prop));\n+\n+                  if Chars (Prop_Nam) = Property then\n                      return Is_True (Expr_Value (Expression (Prop)));\n                   end if;\n \n@@ -7326,7 +7329,7 @@ package body Sem_Util is\n             --  Single property\n \n             else\n-               return Chars (Props) = Prop_Nam;\n+               return Chars (Props) = Property;\n             end if;\n          end if;\n "}, {"sha": "49adb111272e529fc3be7bb6255853bddcd1b798", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97779c340acc02f574fa943d059f68a74d36c4ca/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97779c340acc02f574fa943d059f68a74d36c4ca/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=97779c340acc02f574fa943d059f68a74d36c4ca", "patch": "@@ -204,7 +204,7 @@ package body Sprint is\n      (Node    : Node_Id;\n       Default : Node_Id);\n    --  Print the end label for a Handled_Sequence_Of_Statements in a body.\n-   --  If there is not end label, use the defining identifier of the enclosing\n+   --  If there is no end label, use the defining identifier of the enclosing\n    --  construct. If the end label is present, treat it as a reference to the\n    --  defining entity of the construct: this guarantees that it carries the\n    --  proper sloc information for debugging purposes."}]}