{"sha": "20da06efdce4e245fe3e13524121fb545796d5f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBkYTA2ZWZkY2U0ZTI0NWZlM2UxMzUyNDEyMWZiNTQ1Nzk2ZDVmMw==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-02-22T11:13:27Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-02-22T11:13:27Z"}, "message": "locale_facets.tcc (money_put<>::_M_insert): Restructure formatting of value component...\n\n2004-02-22  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/locale_facets.tcc (money_put<>::_M_insert):\n\tRestructure formatting of value component, first dealing with\n\tthe non-decimal digits; use reserve.\n\n2004-02-22  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/locale_facets.h (class money_get): Inherit\n\tfrom money_base too; tweak declaration of _M_extract, now\n\tparameterized on _Intl too.\n\t* include/bits/locale_facets.tcc (money_get<>::_M_extract):\n\tUpdate definition to use the cache; call reserve on __res to\n\tavoid multiple reallocations; fix parsing of sign component\n\taccording to 22.2.6.1.2, p3.\n\t(money_get<>::do_get(long double&),\n\tmoney_get<>::do_get(string_type&)): Update calls of _M_extract.\n\t* src/locale-inst.cc:  Add instantiations of\n\tmoney_get::_M_extract<false> and money_get::_M_extract<true>.\n\t* testsuite/22_locale/money_get/get/char/14.cc: New.\n\t* testsuite/22_locale/money_get/get/wchar_t/14.cc: Ditto.\n\nFrom-SVN: r78253", "tree": {"sha": "14b292290bd2f946b9786ef53eb4e649e98776f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14b292290bd2f946b9786ef53eb4e649e98776f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20da06efdce4e245fe3e13524121fb545796d5f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20da06efdce4e245fe3e13524121fb545796d5f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20da06efdce4e245fe3e13524121fb545796d5f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20da06efdce4e245fe3e13524121fb545796d5f3/comments", "author": null, "committer": null, "parents": [{"sha": "5904e65f293211ff7eb67e8eacfaf159a10570ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5904e65f293211ff7eb67e8eacfaf159a10570ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5904e65f293211ff7eb67e8eacfaf159a10570ab"}], "stats": {"total": 636, "additions": 397, "deletions": 239}, "files": [{"sha": "0e8a2f41a81fa8d80e71d8ff0979904644145ce9", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20da06efdce4e245fe3e13524121fb545796d5f3/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20da06efdce4e245fe3e13524121fb545796d5f3/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=20da06efdce4e245fe3e13524121fb545796d5f3", "patch": "@@ -1,3 +1,25 @@\n+2004-02-22  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/locale_facets.tcc (money_put<>::_M_insert):\n+\tRestructure formatting of value component, first dealing with\n+\tthe non-decimal digits; use reserve.\n+\n+2004-02-22  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/locale_facets.h (class money_get): Inherit\n+\tfrom money_base too; tweak declaration of _M_extract, now\n+\tparameterized on _Intl too.\n+\t* include/bits/locale_facets.tcc (money_get<>::_M_extract):\n+\tUpdate definition to use the cache; call reserve on __res to\n+\tavoid multiple reallocations; fix parsing of sign component\n+\taccording to 22.2.6.1.2, p3.\n+\t(money_get<>::do_get(long double&),\n+\tmoney_get<>::do_get(string_type&)): Update calls of _M_extract.\t\n+\t* src/locale-inst.cc:  Add instantiations of\n+\tmoney_get::_M_extract<false> and money_get::_M_extract<true>.\n+\t* testsuite/22_locale/money_get/get/char/14.cc: New.\n+\t* testsuite/22_locale/money_get/get/wchar_t/14.cc: Ditto.\n+\t\n 2004-02-21  Mark Mitchell  <mark@codesourcery.com>\n \n \t* libsupc++/vterminate.cc\n@@ -180,13 +202,13 @@\n 2004-02-12  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR libstdc++/13731 (final part: writev)\n-\t* config/io/basic_file_stdio.cc (__gnu_internal::xwrite):\n+\t* config/io/basic_file_stdio.cc (__gnu_internal::xwritev):\n \tNew, a wrapper around writev() handling partial writes.\n \t(__basic_file<char>::xwrite): Move to __gnu_internal and make\n \tstatic.\n \t(__basic_file<char>::xsputn): Update call.\n \t(__basic_file<char>::xsputn_2): Likewise.\t\n-\t* config/io/basic_file_stdio.h (__basic_file<char>::write):\n+\t* config/io/basic_file_stdio.h (__basic_file<char>::xwrite):\n \tDon't declare, now static.\n \n 2004-02-11  Stefan Olsson  <stefan@xapa.se>"}, {"sha": "e4735a82c8b809e5be318d55b963bf4e5eead701", "filename": "libstdc++-v3/include/bits/locale_facets.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20da06efdce4e245fe3e13524121fb545796d5f3/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20da06efdce4e245fe3e13524121fb545796d5f3/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h?ref=20da06efdce4e245fe3e13524121fb545796d5f3", "patch": "@@ -4012,7 +4012,7 @@ namespace std\n    *  the money_get facet.\n   */\n   template<typename _CharT, typename _InIter>\n-    class money_get : public locale::facet\n+  class money_get : public locale::facet, public money_base\n     {\n     public:\n       // Types:\n@@ -4125,9 +4125,10 @@ namespace std\n       do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n \t     ios_base::iostate& __err, string_type& __digits) const;\n \n-      iter_type\n-      _M_extract(iter_type __s, iter_type __end, bool __intl, ios_base& __io,\n-\t\t ios_base::iostate& __err, string_type& __digits) const;     \n+      template<bool _Intl>\n+        iter_type\n+        _M_extract(iter_type __s, iter_type __end, ios_base& __io,\n+\t\t   ios_base::iostate& __err, string_type& __digits) const;     \n     };\n \n   template<typename _CharT, typename _InIter>"}, {"sha": "6d9f2992365577573caaec756261a5c14ceedf71", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 232, "deletions": 233, "changes": 465, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20da06efdce4e245fe3e13524121fb545796d5f3/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20da06efdce4e245fe3e13524121fb545796d5f3/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=20da06efdce4e245fe3e13524121fb545796d5f3", "patch": "@@ -1159,212 +1159,209 @@ namespace std\n     };\n \n   template<typename _CharT, typename _InIter>\n-    _InIter\n-    money_get<_CharT, _InIter>::\n-    _M_extract(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,\n-\t       ios_base::iostate& __err, string_type& __units) const\n-    {\n-      // These contortions are quite unfortunate.\n-      typedef moneypunct<_CharT, true>\t\t__money_true;\n-      typedef moneypunct<_CharT, false>\t\t__money_false;\n-      typedef money_base::part\t\t\tpart;\n-      typedef typename string_type::size_type\tsize_type;\n+    template<bool _Intl>\n+      _InIter\n+      money_get<_CharT, _InIter>::\n+      _M_extract(iter_type __beg, iter_type __end, ios_base& __io,\n+\t\t ios_base::iostate& __err, string_type& __units) const\n+      {\n+\ttypedef typename string_type::size_type\t          size_type;\t\n+\ttypedef money_base::part\t\t\t  part;\n+\ttypedef moneypunct<_CharT, _Intl>\t\t  __moneypunct_type;\n+\ttypedef typename __moneypunct_type::__cache_type  __cache_type;\n+\t\n+\tconst locale& __loc = __io._M_getloc();\n+\tconst ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n \n-      const locale __loc = __io.getloc();\n-      const __money_true& __mpt = use_facet<__money_true>(__loc);\n-      const __money_false& __mpf = use_facet<__money_false>(__loc);\n-      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n+\t__use_cache<__cache_type> __uc;\n+\tconst __cache_type* __lc = __uc(__loc);\n+\tconst char_type* __lit = __lc->_M_atoms;\n \n-      const money_base::pattern __p = __intl ? __mpt.neg_format()\n-\t\t\t\t\t     : __mpf.neg_format();\n-\n-      const string_type __pos_sign = __intl ? __mpt.positive_sign()\n-\t\t\t\t\t    : __mpf.positive_sign();\n-      const string_type __neg_sign = __intl ? __mpt.negative_sign()\n-\t\t\t\t\t    : __mpf.negative_sign();\n-      const char_type __d = __intl ? __mpt.decimal_point()\n-\t\t\t\t   : __mpf.decimal_point();\n-      const char_type __sep = __intl ? __mpt.thousands_sep()\n-\t\t\t\t     : __mpf.thousands_sep();\n-\n-      const string __grouping = __intl ? __mpt.grouping() : __mpf.grouping();\n-\n-      // Set to deduced positive or negative sign, depending.\n-      string_type __sign;\n-      // String of grouping info from thousands_sep plucked from __units.\n-      string __grouping_tmp;\n-      // Marker for thousands_sep position.\n-      int __sep_pos = 0;\n-      // If input iterator is in a valid state.\n-      bool __testvalid = true;\n-      // Flag marking when a decimal point is found.\n-      bool __testdecfound = false;\n+\tconst money_base::pattern __p = __lc->_M_neg_format;\n \n-      // The tentative returned string is stored here.\n-      string_type __tmp_units;\n+\t// Deduced sign.\n+\tbool __negative = false;\n+\t// True for more than one character long sign.\n+\tbool __long_sign = false;\n+\t// String of grouping info from thousands_sep plucked from __units.\n+\tstring __grouping_tmp;\n+\t// Marker for thousands_sep position.\n+\tint __sep_pos = 0;\n+\t// If input iterator is in a valid state.\n+\tbool __testvalid = true;\n+\t// Flag marking when a decimal point is found.\n+\tbool __testdecfound = false;\n \n-      for (int __i = 0; __beg != __end && __i < 4 && __testvalid; ++__i)\n-\t{\n-\t  char_type __c;\n-\t  const part __which = static_cast<part>(__p.field[__i]);\n-\t  switch (__which)\n-\t    {\n-\t    case money_base::symbol:\n-\t      if (__io.flags() & ios_base::showbase\n-\t\t  || __i < 2 || __sign.size() > 1\n-\t\t  || ((static_cast<part>(__p.field[3]) != money_base::none)\n-\t\t      && __i == 2))\n-\t\t{\n-\t\t  // According to 22.2.6.1.2, p2, symbol is required\n-\t\t  // if (__io.flags() & ios_base::showbase),\n-\t\t  // otherwise is optional and consumed only if\n-\t\t  // other characters are needed to complete the\n-\t\t  // format.\n-\t\t  const string_type __symbol = __intl ? __mpt.curr_symbol()\n-\t\t                                      : __mpf.curr_symbol();\n-\t\t  const size_type __len = __symbol.size();\n-\t\t  size_type __j = 0;\n-\t\t  for (; __beg != __end && __j < __len\n-\t\t\t && *__beg == __symbol[__j]; ++__beg, ++__j);\n-\t\t  // When (__io.flags() & ios_base::showbase)\n-\t\t  // symbol is required.\n-\t\t  if (__j != __len && (__io.flags() & ios_base::showbase))\n-\t\t    __testvalid = false;\n-\t\t}\n-\t      break;\n-\t    case money_base::sign:\n-\t      // Sign might not exist, or be more than one character long.\n-\t      if (__pos_sign.size() && *__beg == __pos_sign[0])\n-\t\t{\n-\t\t  __sign = __pos_sign;\n-\t\t  ++__beg;\n-\t\t}\n-\t      else if (__neg_sign.size() && *__beg == __neg_sign[0])\n-\t\t{\n-\t\t  __sign = __neg_sign;\n-\t\t  ++__beg;\n-\t\t}\n-\t      else if (__pos_sign.size() && __neg_sign.size())\n-\t\t{\n-\t\t  // Sign is mandatory.\n-\t\t  __testvalid = false;\n-\t\t}\n-\t      break;\n-\t    case money_base::value:\n-\t      // Extract digits, remove and stash away the\n-\t      // grouping of found thousands separators.\n-\t      for (; __beg != __end; ++__beg)\n-\t\tif (__ctype.is(ctype_base::digit, __c = *__beg))\n+\t// The tentative returned string is stored here.\n+\tstring_type __res;\n+\t__res.reserve(20);\n+\n+\tfor (int __i = 0; __beg != __end && __i < 4 && __testvalid; ++__i)\n+\t  {\n+\t    char_type __c;\n+\t    const part __which = static_cast<part>(__p.field[__i]);\n+\t    switch (__which)\n+\t      {\n+\t      case money_base::symbol:\n+\t\tif (__io.flags() & ios_base::showbase\n+\t\t    || __i < 2 || __long_sign\n+\t\t    || ((static_cast<part>(__p.field[3]) != money_base::none)\n+\t\t\t&& __i == 2))\n \t\t  {\n-\t\t    __tmp_units += __c;\n-\t\t    ++__sep_pos;\n+\t\t    // According to 22.2.6.1.2, p2, symbol is required\n+\t\t    // if (__io.flags() & ios_base::showbase),\n+\t\t    // otherwise is optional and consumed only if\n+\t\t    // other characters are needed to complete the\n+\t\t    // format.\n+\t\t    const size_type __len = __lc->_M_curr_symbol_size;\n+\t\t    size_type __j = 0;\n+\t\t    for (; __beg != __end && __j < __len\n+\t\t\t   && *__beg == __lc->_M_curr_symbol[__j];\n+\t\t\t ++__beg, ++__j);\n+\t\t    // When (__io.flags() & ios_base::showbase)\n+\t\t    // symbol is required.\n+\t\t    if (__j != __len && (__io.flags() & ios_base::showbase))\n+\t\t      __testvalid = false;\n \t\t  }\n-\t\telse if (__c == __d && !__testdecfound)\n+\t\tbreak;\n+\t      case money_base::sign:\n+\t\t// Sign might not exist, or be more than one character long.\n+\t\tif (__lc->_M_positive_sign_size\n+\t\t    && *__beg == __lc->_M_positive_sign[0])\n \t\t  {\n-\t\t    // If no grouping chars are seen, no grouping check\n-\t\t    // is applied. Therefore __grouping_tmp is adjusted\n-\t\t    // only if decimal_point comes after some thousands_sep.\n-\t\t    if (__grouping_tmp.size())\n-\t\t      __grouping_tmp += static_cast<char>(__sep_pos);\n-\t\t    __sep_pos = 0;\n-\t\t    __testdecfound = true;\n+\t\t    if (__lc->_M_positive_sign_size > 1)\n+\t\t      __long_sign = true;\n+\t\t    ++__beg;\n \t\t  }\n-\t\telse if (__c == __sep && !__testdecfound)\n+\t\telse if (__lc->_M_negative_sign_size\n+\t\t\t && *__beg == __lc->_M_negative_sign[0])\n \t\t  {\n-\t\t    if (__grouping.size())\n-\t\t      {\n-\t\t\t// Mark position for later analysis.\n-\t\t\t__grouping_tmp += static_cast<char>(__sep_pos);\n-\t\t\t__sep_pos = 0;\n-\t\t      }\n-\t\t    else\n-\t\t      {\n-\t\t\t__testvalid = false;\n-\t\t\tbreak;\n-\t\t      }\n+\t\t    __negative = true;\n+\t\t    if (__lc->_M_negative_sign_size > 1)\n+\t\t      __long_sign = true;\t\t    \n+\t\t    ++__beg;\n \t\t  }\n-\t\telse\n-\t\t  break;\n-\t      break;\n-\t    case money_base::space:\n-\t    case money_base::none:\n-\t      // Only if not at the end of the pattern.\n-\t      if (__i != 3)\n-\t\tfor (; __beg != __end\n-\t\t       && __ctype.is(ctype_base::space, *__beg); ++__beg);\n-\t      break;\n-\t    }\n-\t}\n-\n-      // Need to get the rest of the sign characters, if they exist.\n-      if (__sign.size() > 1)\n-\t{\n-\t  const size_type __len = __sign.size();\n-\t  size_type __i = 1;\n-\t  for (; __beg != __end && __i < __len\n-\t\t && *__beg == __sign[__i]; ++__beg, ++__i);\n-\n-\t  if (__i != __len)\n-\t    __testvalid = false;\n-\t}\n-\n-      if (__testvalid && __tmp_units.size())\n-\t{\n-\t  const char_type __zero = __ctype.widen('0');\n-\n-\t  // Strip leading zeros.\n-\t  if (__tmp_units.size() > 1)\n-\t    {\n-\t      const size_type __first = __tmp_units.find_first_not_of(__zero);\n-\t      const bool __only_zeros = __first == string_type::npos;\n-\t      if (__first)\n-\t\t__tmp_units.erase(0, __only_zeros ? __tmp_units.size() - 1\n-\t\t\t\t                  : __first);\n-\t    }\n-\n-\t  // 22.2.6.1.2, p4\n-\t  if (__sign.size() && __sign == __neg_sign\n-\t      && __tmp_units[0] != __zero)\n-\t    __tmp_units.insert(__tmp_units.begin(), __ctype.widen('-'));\n-\n-\t  // Test for grouping fidelity.\n-\t  if (__grouping_tmp.size())\n-\t    {\n-\t      // Add the ending grouping if a decimal wasn't found.\n-\t      if (!__testdecfound)\n-\t\t__grouping_tmp += static_cast<char>(__sep_pos);\n-\n-\t      if (!std::__verify_grouping(__grouping.data(),\n-\t\t\t\t\t  __grouping.size(),\n-\t\t\t\t\t  __grouping_tmp))\n-\t\t__testvalid = false;\n-\t    }\n-\n-\t  // Iff not enough digits were supplied after the decimal-point.\n-\t  if (__testdecfound)\n-\t    {\n-\t      const int __frac = __intl ? __mpt.frac_digits()\n-\t\t                        : __mpf.frac_digits();\n-\t      if (__frac > 0 && __sep_pos != __frac)\n-\t\t__testvalid = false;\n-\t    }\n-\t}\n-      else\n-\t__testvalid = false;\n+\t\telse if (__lc->_M_positive_sign_size\n+\t\t\t && !__lc->_M_negative_sign_size)\n+\t\t  // \"... if no sign is detected, the result is given the sign\n+\t\t  // that corresponds to the source of the empty string\"\n+\t\t  __negative = true;\n+\t\telse if (__lc->_M_positive_sign_size\n+\t\t\t && __lc->_M_negative_sign_size)\n+\t\t  {\n+\t\t    // Sign is mandatory.\n+\t\t    __testvalid = false;\n+\t\t  }\n+\t\tbreak;\n+\t      case money_base::value:\n+\t\t// Extract digits, remove and stash away the\n+\t\t// grouping of found thousands separators.\n+\t\tfor (; __beg != __end; ++__beg)\n+\t\t  if (__ctype.is(ctype_base::digit, __c = *__beg))\n+\t\t    {\n+\t\t      __res += __c;\n+\t\t      ++__sep_pos;\n+\t\t    }\n+\t\t  else if (__c == __lc->_M_decimal_point && !__testdecfound)\n+\t\t    {\n+\t\t      // If no grouping chars are seen, no grouping check\n+\t\t      // is applied. Therefore __grouping_tmp is adjusted\n+\t\t      // only if decimal_point comes after some thousands_sep.\n+\t\t      if (__grouping_tmp.size())\n+\t\t\t__grouping_tmp += static_cast<char>(__sep_pos);\n+\t\t      __sep_pos = 0;\n+\t\t      __testdecfound = true;\n+\t\t    }\n+\t\t  else if (__c == __lc->_M_thousands_sep && !__testdecfound)\n+\t\t    {\n+\t\t      if (__lc->_M_grouping_size)\n+\t\t\t{\n+\t\t\t  // Mark position for later analysis.\n+\t\t\t  __grouping_tmp += static_cast<char>(__sep_pos);\n+\t\t\t  __sep_pos = 0;\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  __testvalid = false;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    break;\n+\t\tbreak;\n+\t      case money_base::space:\n+\t      case money_base::none:\n+\t\t// Only if not at the end of the pattern.\n+\t\tif (__i != 3)\n+\t\t  for (; __beg != __end\n+\t\t\t && __ctype.is(ctype_base::space, *__beg); ++__beg);\n+\t\tbreak;\n+\t      }\n+\t  }\n \n-      // Iff no more characters are available.\n-      if (__beg == __end)\n-\t__err |= ios_base::eofbit;\n+\t// Need to get the rest of the sign characters, if they exist.\n+\tif (__long_sign)\n+\t  {\n+\t    const char_type* __sign = __negative ? __lc->_M_negative_sign\n+\t                                         : __lc->_M_positive_sign;\n+\t    const size_type __len = __negative ? __lc->_M_negative_sign_size\n+                                               : __lc->_M_positive_sign_size;\n+\t    size_type __i = 1;\n+\t    for (; __beg != __end && __i < __len\n+\t\t   && *__beg == __sign[__i]; ++__beg, ++__i);\n+\t    \n+\t    if (__i != __len)\n+\t      __testvalid = false;\n+\t  }\n \n-      // Iff valid sequence is not recognized.\n-      if (!__testvalid)\n-\t__err |= ios_base::failbit;\n-      else\n-\t// Use the \"swap trick\" to copy __tmp_units into __units.\n-\t__tmp_units.swap(__units);\n+\tif (__testvalid && __res.size())\n+\t  {\n+\t    // Strip leading zeros.\n+\t    if (__res.size() > 1)\n+\t      {\n+\t\tsize_type __first = __res.find_first_not_of(__lit[_S_zero]);\n+\t\tconst bool __only_zeros = __first == string_type::npos;\n+\t\tif (__first)\n+\t\t  __res.erase(0, __only_zeros ? __res.size() - 1 : __first);\n+\t      }\n \n-      return __beg;\n-    }\n+\t    // 22.2.6.1.2, p4\n+\t    if (__negative && __res[0] != __lit[_S_zero])\n+\t      __res.insert(__res.begin(), __lit[_S_minus]);\n+\t    \n+\t    // Test for grouping fidelity.\n+\t    if (__grouping_tmp.size())\n+\t      {\n+\t\t// Add the ending grouping if a decimal wasn't found.\n+\t\tif (!__testdecfound)\n+\t\t  __grouping_tmp += static_cast<char>(__sep_pos);\n+\t\t\n+\t\tif (!std::__verify_grouping(__lc->_M_grouping,\n+\t\t\t\t\t    __lc->_M_grouping_size,\n+\t\t\t\t\t    __grouping_tmp))\n+\t\t  __testvalid = false;\n+\t      }\n+\t    \n+\t    // Iff not enough digits were supplied after the decimal-point.\n+\t    if (__testdecfound && __lc->_M_frac_digits > 0\n+\t\t&& __sep_pos != __lc->_M_frac_digits)\n+\t      __testvalid = false;\n+\t  }\n+\telse\n+\t  __testvalid = false;\n+\t\n+\t// Iff no more characters are available.\n+\tif (__beg == __end)\n+\t  __err |= ios_base::eofbit;\n+\t\n+\t// Iff valid sequence is not recognized.\n+\tif (!__testvalid)\n+\t  __err |= ios_base::failbit;\n+\telse\n+\t  __units.assign(__res.data(), __res.size());\n+\t\n+\treturn __beg;\n+      }\n \n   template<typename _CharT, typename _InIter>\n     _InIter\n@@ -1373,7 +1370,10 @@ namespace std\n \t   ios_base::iostate& __err, long double& __units) const\n     {\n       string_type __str;\n-      __beg = _M_extract(__beg, __end, __intl, __io, __err, __str);\n+      if (__intl)\n+\t__beg = _M_extract<true>(__beg, __end, __io, __err, __str);\n+      else\n+\t__beg = _M_extract<false>(__beg, __end, __io, __err, __str);\n \n       const int __cs_size = __str.size() + 1;\n       char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n@@ -1390,7 +1390,8 @@ namespace std\n     money_get<_CharT, _InIter>::\n     do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,\n \t   ios_base::iostate& __err, string_type& __units) const\n-    { return _M_extract(__beg, __end, __intl, __io, __err, __units); }\n+    { return __intl ? _M_extract<true>(__beg, __end, __io, __err, __units)\n+\t            : _M_extract<false>(__beg, __end, __io, __err, __units); }\n \n   template<typename _CharT, typename _OutIter>\n     template<bool _Intl>\n@@ -1440,56 +1441,54 @@ namespace std\n \t    // Assume valid input, and attempt to format.\n \t    // Break down input numbers into base components, as follows:\n \t    //   final_value = grouped units + (decimal point) + (digits)\n-\t    string_type __res;\n \t    string_type __value;\n-\t   \n+\t    size_type __len = __end - __beg;\n+\t    __value.reserve(2 * __len);\n+\n+\t    // Add thousands separators to non-decimal digits, per\n+\t    // grouping rules.\n+\t    const int __paddec = __lc->_M_frac_digits - __len;\t    \n+\t    if (__paddec < 0)\n+  \t      {\n+  \t\tif (__lc->_M_grouping_size)\n+  \t\t  {\n+\t\t    _CharT* __ws =\n+  \t\t      static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n+  \t\t\t\t\t\t\t    * 2 * __len));\n+  \t\t    _CharT* __ws_end =\n+\t\t      std::__add_grouping(__ws, __lc->_M_thousands_sep,\n+\t\t\t\t\t  __lc->_M_grouping,\n+\t\t\t\t\t  __lc->_M_grouping_size,\n+\t\t\t\t\t  __beg, __end - __lc->_M_frac_digits);\n+\t\t    __value.assign(__ws, __ws_end - __ws);\n+  \t\t  }\n+  \t\telse\n+\t\t  __value.assign(__beg, -__paddec);\n+\t      }\n+\n \t    // Deal with decimal point, decimal digits.\n \t    if (__lc->_M_frac_digits > 0)\n \t      {\n-\t\tif (__end - __beg >= __lc->_M_frac_digits)\n-\t\t  {\n-\t\t    __value = string_type(__end - __lc->_M_frac_digits, __end);\n-\t\t    __value.insert(__value.begin(), __lc->_M_decimal_point);\n-\t\t    __end -= __lc->_M_frac_digits;\n-\t\t  }\n+\t\t__value += __lc->_M_decimal_point;\n+\t\tif (__paddec <= 0)\n+\t\t  __value.append(__end - __lc->_M_frac_digits,\n+\t\t\t\t __lc->_M_frac_digits);\n \t\telse\n \t\t  {\n \t\t    // Have to pad zeros in the decimal position.\n-\t\t    __value = string_type(__beg, __end);\n-\t\t    const int __paddec = __lc->_M_frac_digits - (__end - __beg);\n-\t\t    __value.insert(__value.begin(), __paddec, __lit[_S_zero]);\n-\t\t    __value.insert(__value.begin(), __lc->_M_decimal_point);\n-\t\t    __beg = __end;\n-\t\t  }\n-\t      }\n-\t    \n-\t    // Add thousands separators to non-decimal digits, per\n-\t    // grouping rules.\n-\t    if (__beg != __end)\n-\t      {\n-\t\tif (__lc->_M_grouping_size)\n-\t\t  {\n-\t\t    const int __n = (__end - __beg) * 2;\n-\t\t    _CharT* __ws2 =\n-\t\t      static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n-\t\t\t\t\t\t\t    * __n));\n-\t\t    _CharT* __ws_end =\n-\t\t      std::__add_grouping(__ws2, __lc->_M_thousands_sep,\n-\t\t\t\t\t  __lc->_M_grouping,\n-\t\t\t\t\t  __lc->_M_grouping_size,\n-\t\t\t\t\t  __beg, __end);\n-\t\t    __value.insert(0, __ws2, __ws_end - __ws2);\n+\t\t    __value.append(__paddec, __lit[_S_zero]);\n+\t\t    __value.append(__beg, __len);\n \t\t  }\n-\t\telse\n-\t\t  __value.insert(0, string_type(__beg, __end));\n-\t      }\n-\t    \n+  \t      }\n+  \n \t    // Calculate length of resulting string.\n \t    const ios_base::fmtflags __f = __io.flags() & ios_base::adjustfield;\n-\t    size_type __len = __value.size() + __sign_size;\n+\t    __len = __value.size() + __sign_size;\n \t    __len += ((__io.flags() & ios_base::showbase)\n \t\t      ? __lc->_M_curr_symbol_size : 0);\n-\t    __res.reserve(__len);\n+\n+\t    string_type __res;\n+\t    __res.reserve(2 * __len);\n \t    \n \t    const size_type __width = static_cast<size_type>(__io.width());\t  \n \t    const bool __testipad = (__f == ios_base::internal"}, {"sha": "030b630f61207f686b07e3a95cda21322c5eee5d", "filename": "libstdc++-v3/src/locale-inst.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20da06efdce4e245fe3e13524121fb545796d5f3/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20da06efdce4e245fe3e13524121fb545796d5f3/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc?ref=20da06efdce4e245fe3e13524121fb545796d5f3", "patch": "@@ -50,6 +50,18 @@ namespace std\n   template class moneypunct_byname<C, true>;\n   template class money_get<C, istreambuf_iterator<C> >;\n   template class money_put<C, ostreambuf_iterator<C> >;\n+  template\n+    istreambuf_iterator<C>\n+    money_get<C, istreambuf_iterator<C> >::\n+    _M_extract<true>(istreambuf_iterator<C>, istreambuf_iterator<C>,\n+\t\t     ios_base&, ios_base::iostate&, string_type&) const;\n+\n+  template\n+    istreambuf_iterator<C>\n+    money_get<C, istreambuf_iterator<C> >::\n+    _M_extract<false>(istreambuf_iterator<C>, istreambuf_iterator<C>,\n+\t\t      ios_base&, ios_base::iostate&, string_type&) const;\n+\n   template\n     ostreambuf_iterator<C>\n     money_put<C, ostreambuf_iterator<C> >::"}, {"sha": "2b9b92eddffcb041d9d97df4626ca7e59d993401", "filename": "libstdc++-v3/testsuite/22_locale/money_get/get/char/14.cc", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20da06efdce4e245fe3e13524121fb545796d5f3/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_get%2Fget%2Fchar%2F14.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20da06efdce4e245fe3e13524121fb545796d5f3/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_get%2Fget%2Fchar%2F14.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_get%2Fget%2Fchar%2F14.cc?ref=20da06efdce4e245fe3e13524121fb545796d5f3", "patch": "@@ -0,0 +1,62 @@\n+// 2004-02-21  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2004 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.6.1.1 money_get members\n+\n+#include <locale>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+struct My_money : public std::moneypunct<char, false>\n+{\n+  std::string do_positive_sign() const { return \"+\"; }\n+  std::string do_negative_sign() const { return \"\"; }\n+};\n+\n+void test01()\n+{\n+  using namespace std;\n+  typedef istreambuf_iterator<char> InIt;\n+\n+  bool test __attribute__((unused)) = true;\n+\n+  locale loc(locale::classic(), new My_money);\n+\n+  string buffer(\"69\");\n+\n+  InIt iend;\n+  ios_base::iostate err;\n+  string val;\n+\n+  const money_get<char, InIt>& mg  =\n+    use_facet<money_get<char, InIt> >(loc);\n+\n+  istringstream fmt(buffer);\n+  fmt.imbue(loc);\n+  InIt ibeg(fmt);\n+  mg.get(ibeg, iend, false, fmt, err, val);\n+  VERIFY( val == \"-69\" );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "e440d63c61d6f5b1c22871c939080157c75c0b15", "filename": "libstdc++-v3/testsuite/22_locale/money_get/get/wchar_t/14.cc", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20da06efdce4e245fe3e13524121fb545796d5f3/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_get%2Fget%2Fwchar_t%2F14.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20da06efdce4e245fe3e13524121fb545796d5f3/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_get%2Fget%2Fwchar_t%2F14.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_get%2Fget%2Fwchar_t%2F14.cc?ref=20da06efdce4e245fe3e13524121fb545796d5f3", "patch": "@@ -0,0 +1,62 @@\n+// 2004-02-21  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2004 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.6.1.1 money_get members\n+\n+#include <locale>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+struct My_money : public std::moneypunct<wchar_t, false>\n+{\n+  std::wstring do_positive_sign() const { return L\"+\"; }\n+  std::wstring do_negative_sign() const { return L\"\"; }\n+};\n+\n+void test01()\n+{\n+  using namespace std;\n+  typedef istreambuf_iterator<wchar_t> InIt;\n+\n+  bool test __attribute__((unused)) = true;\n+\n+  locale loc(locale::classic(), new My_money);\n+\n+  wstring buffer(L\"69\");\n+\n+  InIt iend;\n+  ios_base::iostate err;\n+  wstring val;\n+\n+  const money_get<wchar_t, InIt>& mg  =\n+    use_facet<money_get<wchar_t, InIt> >(loc);\n+\n+  wistringstream fmt(buffer);\n+  fmt.imbue(loc);\n+  InIt ibeg(fmt);\n+  mg.get(ibeg, iend, false, fmt, err, val);\n+  VERIFY( val == L\"-69\" );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}