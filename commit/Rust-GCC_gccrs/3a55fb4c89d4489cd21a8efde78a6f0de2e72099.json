{"sha": "3a55fb4c89d4489cd21a8efde78a6f0de2e72099", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E1NWZiNGM4OWQ0NDg5Y2QyMWE4ZWZkZTc4YTZmMGRlMmU3MjA5OQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-06-04T21:21:23Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-06-04T21:21:23Z"}, "message": "Implement noexcept-specification (15.4)\n\n\tImplement noexcept-specification (15.4)\n\t* parser.c (cp_parser_exception_specification_opt): Parse it.\n\tGive -Wdeprecated warning about throw() specs.\n\t* pt.c (tsubst_exception_specification): Handle it.\n\t* error.c (dump_exception_spec): Handle it.\n\t* cxx-pretty-print.c (pp_cxx_exception_specification): Likewise.\n\t* typeck.c (comp_except_specs): Handle compatibility rules.\n\tChange exact parm to take an enum.\n\t* typeck2.c (merge_exception_specifiers): Handle noexcept.\n\t* except.c (nothrow_spec_p, type_noexcept_p): New fns.\n\t(type_throw_all_p, build_noexcept_spec): New fns.\n\t* cp-tree.h (TYPE_NOTHROW_P, TYPE_NOEXCEPT_P): Use them.\n\t(comp_except_specs): Define ce_derived, ce_normal, ce_exact enums.\n\t(cp_tree_index): Add CPTI_NOEXCEPT_TRUE_SPEC, CPTI_NOEXCEPT_FALSE_SPEC.\n\t(noexcept_true_spec, noexcept_false_spec): New macros.\n\t* name-lookup.c (pushdecl_maybe_friend): Adjust.\n\t* search.c (check_final_overrider): Adjust.\n\t* decl.c (check_redeclaration_exception_specification): Adjust.\n\t(use_eh_spec_block): Use type_throw_all_p.\n\t(cxx_init_decl_processing): Set noexcept_false_spec,noexcept_true_spec.\n\tGive operator new a noexcept-specification in C++0x mode.\n\t* tree.c (build_exception_variant, cxx_type_hash_eq): Adjust.\n\t(cp_build_type_attribute_variant): Don't test TYPE_RAISES_EXCEPTIONS.\n\nFrom-SVN: r160298", "tree": {"sha": "45574d319c9bf599a6b62ec4994fe09f77d4a51b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45574d319c9bf599a6b62ec4994fe09f77d4a51b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a55fb4c89d4489cd21a8efde78a6f0de2e72099", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a55fb4c89d4489cd21a8efde78a6f0de2e72099", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a55fb4c89d4489cd21a8efde78a6f0de2e72099", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0a766368bd6e51459bfd334086cc04af48f91f08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a766368bd6e51459bfd334086cc04af48f91f08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a766368bd6e51459bfd334086cc04af48f91f08"}], "stats": {"total": 489, "additions": 435, "deletions": 54}, "files": [{"sha": "958481083864bc19e9d8a4d709b896f952b6cbb0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3a55fb4c89d4489cd21a8efde78a6f0de2e72099", "patch": "@@ -1,5 +1,29 @@\n 2010-06-04  Jason Merrill  <jason@redhat.com>\n \n+\tImplement noexcept-specification (15.4)\n+\t* parser.c (cp_parser_exception_specification_opt): Parse it.\n+\tGive -Wdeprecated warning about throw() specs.\n+\t* pt.c (tsubst_exception_specification): Handle it.\n+\t* error.c (dump_exception_spec): Handle it.\n+\t* cxx-pretty-print.c (pp_cxx_exception_specification): Likewise.\n+\t* typeck.c (comp_except_specs): Handle compatibility rules.\n+\tChange exact parm to take an enum.\n+\t* typeck2.c (merge_exception_specifiers): Handle noexcept.\n+\t* except.c (nothrow_spec_p, type_noexcept_p): New fns.\n+\t(type_throw_all_p, build_noexcept_spec): New fns.\n+\t* cp-tree.h (TYPE_NOTHROW_P, TYPE_NOEXCEPT_P): Use them.\n+\t(comp_except_specs): Define ce_derived, ce_normal, ce_exact enums.\n+\t(cp_tree_index): Add CPTI_NOEXCEPT_TRUE_SPEC, CPTI_NOEXCEPT_FALSE_SPEC.\n+\t(noexcept_true_spec, noexcept_false_spec): New macros.\n+\t* name-lookup.c (pushdecl_maybe_friend): Adjust.\n+\t* search.c (check_final_overrider): Adjust.\n+\t* decl.c (check_redeclaration_exception_specification): Adjust.\n+\t(use_eh_spec_block): Use type_throw_all_p.\n+\t(cxx_init_decl_processing): Set noexcept_false_spec,noexcept_true_spec.\n+\tGive operator new a noexcept-specification in C++0x mode.\n+\t* tree.c (build_exception_variant, cxx_type_hash_eq): Adjust.\n+\t(cp_build_type_attribute_variant): Don't test TYPE_RAISES_EXCEPTIONS.\n+\n \tImplement noexcept operator (5.3.7)\n \t* cp-tree.def (NOEXCEPT_EXPR): New.\n \t* except.c (check_noexcept_r, finish_noexcept_expr): New."}, {"sha": "6b292b66f7316dc039ad47e1a6734604da83386d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3a55fb4c89d4489cd21a8efde78a6f0de2e72099", "patch": "@@ -758,6 +758,8 @@ enum cp_tree_index\n     CPTI_LANG_NAME_JAVA,\n \n     CPTI_EMPTY_EXCEPT_SPEC,\n+    CPTI_NOEXCEPT_TRUE_SPEC,\n+    CPTI_NOEXCEPT_FALSE_SPEC,\n     CPTI_JCLASS,\n     CPTI_TERMINATE,\n     CPTI_CALL_UNEXPECTED,\n@@ -847,6 +849,8 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n \n /* Exception specifier used for throw().  */\n #define empty_except_spec\t\tcp_global_trees[CPTI_EMPTY_EXCEPT_SPEC]\n+#define noexcept_true_spec\t\tcp_global_trees[CPTI_NOEXCEPT_TRUE_SPEC]\n+#define noexcept_false_spec\t\tcp_global_trees[CPTI_NOEXCEPT_FALSE_SPEC]\n \n /* If non-NULL, a POINTER_TYPE equivalent to (java::lang::Class*).  */\n #define jclass_node\t\t\tcp_global_trees[CPTI_JCLASS]\n@@ -1726,19 +1730,18 @@ struct GTY(()) lang_type {\n /* For FUNCTION_TYPE or METHOD_TYPE, a list of the exceptions that\n    this type can raise.  Each TREE_VALUE is a _TYPE.  The TREE_VALUE\n    will be NULL_TREE to indicate a throw specification of `()', or\n-   no exceptions allowed.  */\n+   no exceptions allowed.  For a noexcept specification, TREE_VALUE\n+   is NULL_TREE and TREE_PURPOSE is the constant-expression. */\n #define TYPE_RAISES_EXCEPTIONS(NODE) TYPE_LANG_SLOT_1 (NODE)\n \n-/* For FUNCTION_TYPE or METHOD_TYPE, return 1 iff it is declared `throw()'.  */\n-#define TYPE_NOTHROW_P(NODE) \\\n-  (TYPE_RAISES_EXCEPTIONS (NODE) \\\n-   && TREE_VALUE (TYPE_RAISES_EXCEPTIONS (NODE)) == NULL_TREE)\n+/* For FUNCTION_TYPE or METHOD_TYPE, return 1 iff it is declared `throw()'\n+   or noexcept(true).  */\n+#define TYPE_NOTHROW_P(NODE) nothrow_spec_p (TYPE_RAISES_EXCEPTIONS (NODE))\n \n /* For FUNCTION_TYPE or METHOD_TYPE, true if NODE is noexcept.  This is the\n    case for things declared noexcept(true) and, with -fnothrow-opt, for\n    throw() functions.  */\n-#define TYPE_NOEXCEPT_P(NODE) \\\n-  (flag_nothrow_opt && TYPE_NOTHROW_P(NODE))\n+#define TYPE_NOEXCEPT_P(NODE) type_noexcept_p (NODE)\n \n /* The binding level associated with the namespace.  */\n #define NAMESPACE_LEVEL(NODE) \\\n@@ -4821,6 +4824,10 @@ extern tree build_throw\t\t\t\t(tree);\n extern int nothrow_libfn_p\t\t\t(const_tree);\n extern void check_handlers\t\t\t(tree);\n extern tree finish_noexcept_expr\t\t(tree);\n+extern bool nothrow_spec_p\t\t\t(const_tree);\n+extern bool type_noexcept_p\t\t\t(const_tree);\n+extern bool type_throw_all_p\t\t\t(const_tree);\n+extern tree build_noexcept_spec\t\t\t(tree, int);\n extern void choose_personality_routine\t\t(enum languages);\n extern tree eh_type_info\t\t\t(tree);\n extern tree begin_eh_spec_block\t\t\t(void);\n@@ -5348,7 +5355,8 @@ extern tree require_complete_type\t\t(tree);\n extern tree complete_type\t\t\t(tree);\n extern tree complete_type_or_else\t\t(tree, tree);\n extern int type_unknown_p\t\t\t(const_tree);\n-extern bool comp_except_specs\t\t\t(const_tree, const_tree, bool);\n+enum { ce_derived, ce_normal, ce_exact };\n+extern bool comp_except_specs\t\t\t(const_tree, const_tree, int);\n extern bool comptypes\t\t\t\t(tree, tree, int);\n extern bool compparms\t\t\t\t(const_tree, const_tree);\n extern int comp_cv_qualification\t\t(const_tree, const_tree);"}, {"sha": "e6c68ba5ddb55b9933990ead51f817d83c389591", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=3a55fb4c89d4489cd21a8efde78a6f0de2e72099", "patch": "@@ -1418,8 +1418,17 @@ pp_cxx_exception_specification (cxx_pretty_printer *pp, tree t)\n   tree ex_spec = TYPE_RAISES_EXCEPTIONS (t);\n   bool need_comma = false;\n \n-  if (!TYPE_NOTHROW_P (t) && ex_spec == NULL)\n+  if (ex_spec == NULL)\n     return;\n+  if (TREE_PURPOSE (ex_spec))\n+    {\n+      pp_cxx_ws_string (pp, \"noexcept\");\n+      pp_cxx_whitespace (pp);\n+      pp_cxx_left_paren (pp);\n+      pp_cxx_expression (pp, TREE_PURPOSE (ex_spec));\n+      pp_cxx_right_paren (pp);\n+      return;\n+    }\n   pp_cxx_ws_string (pp, \"throw\");\n   pp_cxx_left_paren (pp);\n   for (; ex_spec && TREE_VALUE (ex_spec); ex_spec = TREE_CHAIN (ex_spec))"}, {"sha": "ef00a11b21b3e6093556c909defc686a876c684e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=3a55fb4c89d4489cd21a8efde78a6f0de2e72099", "patch": "@@ -1104,10 +1104,10 @@ check_redeclaration_exception_specification (tree new_decl,\n   if ((pedantic || ! DECL_IN_SYSTEM_HEADER (old_decl))\n       && ! DECL_IS_BUILTIN (old_decl)\n       && flag_exceptions\n-      && !comp_except_specs (new_exceptions, old_exceptions,\n-\t\t\t     /*exact=*/true))\n+      && !comp_except_specs (new_exceptions, old_exceptions, ce_normal))\n     {\n-      error (\"declaration of %qF throws different exceptions\", new_decl);\n+      error (\"declaration of %qF has a different exception specifier\",\n+\t     new_decl);\n       error (\"from previous declaration %q+F\", old_decl);\n     }\n }\n@@ -3433,6 +3433,8 @@ cxx_init_decl_processing (void)\n   truthvalue_true_node = boolean_true_node;\n \n   empty_except_spec = build_tree_list (NULL_TREE, NULL_TREE);\n+  noexcept_true_spec = build_tree_list (boolean_true_node, NULL_TREE);\n+  noexcept_false_spec = build_tree_list (boolean_false_node, NULL_TREE);\n \n #if 0\n   record_builtin_type (RID_MAX, NULL, string_type_node);\n@@ -3498,29 +3500,37 @@ cxx_init_decl_processing (void)\n   current_lang_name = lang_name_cplusplus;\n \n   {\n-    tree bad_alloc_id;\n-    tree bad_alloc_type_node;\n-    tree bad_alloc_decl;\n     tree newtype, deltype;\n     tree ptr_ftype_sizetype;\n-\n-    push_namespace (std_identifier);\n-    bad_alloc_id = get_identifier (\"bad_alloc\");\n-    bad_alloc_type_node = make_class_type (RECORD_TYPE);\n-    TYPE_CONTEXT (bad_alloc_type_node) = current_namespace;\n-    bad_alloc_decl\n-      = create_implicit_typedef (bad_alloc_id, bad_alloc_type_node);\n-    DECL_CONTEXT (bad_alloc_decl) = current_namespace;\n-    pop_namespace ();\n+    tree new_eh_spec;\n \n     ptr_ftype_sizetype\n       = build_function_type (ptr_type_node,\n \t\t\t     tree_cons (NULL_TREE,\n \t\t\t\t\tsize_type_node,\n \t\t\t\t\tvoid_list_node));\n-    newtype = build_exception_variant\n-      (ptr_ftype_sizetype, add_exception_specifier\n-       (NULL_TREE, bad_alloc_type_node, -1));\n+    if (cxx_dialect == cxx98)\n+      {\n+\ttree bad_alloc_id;\n+\ttree bad_alloc_type_node;\n+\ttree bad_alloc_decl;\n+\n+\tpush_namespace (std_identifier);\n+\tbad_alloc_id = get_identifier (\"bad_alloc\");\n+\tbad_alloc_type_node = make_class_type (RECORD_TYPE);\n+\tTYPE_CONTEXT (bad_alloc_type_node) = current_namespace;\n+\tbad_alloc_decl\n+\t  = create_implicit_typedef (bad_alloc_id, bad_alloc_type_node);\n+\tDECL_CONTEXT (bad_alloc_decl) = current_namespace;\n+\tpop_namespace ();\n+\n+\tnew_eh_spec\n+\t  = add_exception_specifier (NULL_TREE, bad_alloc_type_node, -1);\n+      }\n+    else\n+      new_eh_spec = noexcept_false_spec;\n+\n+    newtype = build_exception_variant (ptr_ftype_sizetype, new_eh_spec);\n     deltype = build_exception_variant (void_ftype_ptr, empty_except_spec);\n     push_cp_library_fn (NEW_EXPR, newtype);\n     push_cp_library_fn (VEC_NEW_EXPR, newtype);\n@@ -12198,7 +12208,7 @@ use_eh_spec_block (tree fn)\n {\n   return (flag_exceptions && flag_enforce_eh_specs\n \t  && !processing_template_decl\n-\t  && TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn))\n+\t  && !type_throw_all_p (TREE_TYPE (fn))\n \t  /* We insert the EH_SPEC_BLOCK only in the original\n \t     function; then, it is copied automatically to the\n \t     clones.  */"}, {"sha": "d535f05a54d89b185a1646268d654b15073bac87", "filename": "gcc/cp/error.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=3a55fb4c89d4489cd21a8efde78a6f0de2e72099", "patch": "@@ -1388,7 +1388,15 @@ dump_parameters (tree parmtypes, int flags)\n static void\n dump_exception_spec (tree t, int flags)\n {\n-  if (t)\n+  if (t && TREE_PURPOSE (t))\n+    {\n+      pp_cxx_ws_string (cxx_pp, \"noexcept\");\n+      pp_cxx_whitespace (cxx_pp);\n+      pp_cxx_left_paren (cxx_pp);\n+      dump_expr (TREE_PURPOSE (t), flags);\n+      pp_cxx_right_paren (cxx_pp);\n+    }\n+  else if (t)\n     {\n       pp_cxx_ws_string (cxx_pp, \"throw\");\n       pp_cxx_whitespace (cxx_pp);\n@@ -2116,6 +2124,14 @@ dump_expr (tree t, int flags)\n       pp_cxx_right_paren (cxx_pp);\n       break;\n \n+    case NOEXCEPT_EXPR:\n+      pp_cxx_ws_string (cxx_pp, \"noexcept\");\n+      pp_cxx_whitespace (cxx_pp);\n+      pp_cxx_left_paren (cxx_pp);\n+      dump_expr (TREE_OPERAND (t, 0), flags);\n+      pp_cxx_right_paren (cxx_pp);\n+      break;\n+\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n       pp_cxx_ws_string (cxx_pp, operator_name_info[TREE_CODE (t)].name);"}, {"sha": "7be760e18c0b6db79609d932f1a437fcfa6c7451", "filename": "gcc/cp/except.c", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=3a55fb4c89d4489cd21a8efde78a6f0de2e72099", "patch": "@@ -1062,3 +1062,64 @@ finish_noexcept_expr (tree expr)\n   else\n     return boolean_true_node;\n }\n+\n+/* Return true iff SPEC is throw() or noexcept(true).  */\n+\n+bool\n+nothrow_spec_p (const_tree spec)\n+{\n+  if (spec == NULL_TREE\n+      || TREE_VALUE (spec) != NULL_TREE\n+      || spec == noexcept_false_spec)\n+    return false;\n+  if (TREE_PURPOSE (spec) == NULL_TREE\n+      || spec == noexcept_true_spec)\n+    return true;\n+  gcc_assert (processing_template_decl\n+\t      || TREE_PURPOSE (spec) == error_mark_node);\n+  return false;\n+}\n+\n+/* For FUNCTION_TYPE or METHOD_TYPE, true if NODE is noexcept.  This is the\n+   case for things declared noexcept(true) and, with -fnothrow-opt, for\n+   throw() functions.  */\n+\n+bool\n+type_noexcept_p (const_tree type)\n+{\n+  tree spec = TYPE_RAISES_EXCEPTIONS (type);\n+  if (flag_nothrow_opt)\n+    return nothrow_spec_p (spec);\n+  else\n+    return spec == noexcept_true_spec;\n+}\n+\n+/* For FUNCTION_TYPE or METHOD_TYPE, true if NODE can throw any type,\n+   i.e. no exception-specification or noexcept(false).  */\n+\n+bool\n+type_throw_all_p (const_tree type)\n+{\n+  tree spec = TYPE_RAISES_EXCEPTIONS (type);\n+  return spec == NULL_TREE || spec == noexcept_false_spec;\n+}\n+\n+/* Create a representation of the noexcept-specification with\n+   constant-expression of EXPR.  COMPLAIN is as for tsubst.  */\n+\n+tree\n+build_noexcept_spec (tree expr, int complain)\n+{\n+  expr = perform_implicit_conversion_flags (boolean_type_node, expr,\n+\t\t\t\t\t    complain,\n+\t\t\t\t\t    LOOKUP_NORMAL);\n+  if (expr == boolean_true_node)\n+    return noexcept_true_spec;\n+  else if (expr == boolean_false_node)\n+    return noexcept_false_spec;\n+  else\n+    {\n+      gcc_assert (processing_template_decl || expr == error_mark_node);\n+      return build_tree_list (expr, NULL_TREE);\n+    }\n+}"}, {"sha": "3236b64e73c687da1a436fe07bb4062527ef9abc", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=3a55fb4c89d4489cd21a8efde78a6f0de2e72099", "patch": "@@ -805,7 +805,7 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \t\t\t\tTYPE_RAISES_EXCEPTIONS (TREE_TYPE (previous));\n \t\t  if (!comp_except_specs (previous_exception_spec,\n \t\t\t\t\t  x_exception_spec,\n-\t\t\t\t\t  true))\n+\t\t\t\t\t  ce_normal))\n \t\t    {\n \t\t      pedwarn (input_location, 0, \"declaration of %q#D with C language linkage\",\n \t\t\t       x);"}, {"sha": "a33330ce566595eab18ff9daa4035b41309782d3", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=3a55fb4c89d4489cd21a8efde78a6f0de2e72099", "patch": "@@ -17534,13 +17534,50 @@ cp_parser_exception_specification_opt (cp_parser* parser)\n {\n   cp_token *token;\n   tree type_id_list;\n+  const char *saved_message;\n \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n+\n+  /* Is it a noexcept-specification?  */\n+  if (cp_parser_is_keyword (token, RID_NOEXCEPT))\n+    {\n+      tree expr;\n+      cp_lexer_consume_token (parser->lexer);\n+\n+      if (cp_lexer_peek_token (parser->lexer)->type == CPP_OPEN_PAREN)\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\n+\t  /* Types may not be defined in an exception-specification.  */\n+\t  saved_message = parser->type_definition_forbidden_message;\n+\t  parser->type_definition_forbidden_message\n+\t    = G_(\"types may not be defined in an exception-specification\");\n+\n+\t  expr = cp_parser_constant_expression (parser, false, NULL);\n+\n+\t  /* Restore the saved message.  */\n+\t  parser->type_definition_forbidden_message = saved_message;\n+\n+\t  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\t}\n+      else\n+\texpr = boolean_true_node;\n+\n+      return build_noexcept_spec (expr, tf_warning_or_error);\n+    }\n+\n   /* If it's not `throw', then there's no exception-specification.  */\n   if (!cp_parser_is_keyword (token, RID_THROW))\n     return NULL_TREE;\n \n+#if 0\n+  /* Enable this once a lot of code has transitioned to noexcept?  */\n+  if (cxx_dialect == cxx0x && !in_system_header)\n+    warning (OPT_Wdeprecated, \"dynamic exception specifications are \"\n+\t     \"deprecated in C++0x; use %<noexcept%> instead.\");\n+#endif\n+\n   /* Consume the `throw'.  */\n   cp_lexer_consume_token (parser->lexer);\n \n@@ -17552,8 +17589,6 @@ cp_parser_exception_specification_opt (cp_parser* parser)\n   /* If it's not a `)', then there is a type-id-list.  */\n   if (token->type != CPP_CLOSE_PAREN)\n     {\n-      const char *saved_message;\n-\n       /* Types may not be defined in an exception-specification.  */\n       saved_message = parser->type_definition_forbidden_message;\n       parser->type_definition_forbidden_message"}, {"sha": "4c98bf276ede55b62944cfcca29aa5ee75c60350", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=3a55fb4c89d4489cd21a8efde78a6f0de2e72099", "patch": "@@ -9838,7 +9838,15 @@ tsubst_exception_specification (tree fntype,\n \n   specs = TYPE_RAISES_EXCEPTIONS (fntype);\n   new_specs = NULL_TREE;\n-  if (specs)\n+  if (specs && TREE_PURPOSE (specs))\n+    {\n+      /* A noexcept-specifier.  */\n+      new_specs = tsubst_copy_and_build\n+\t(TREE_PURPOSE (specs), args, complain, in_decl, /*function_p=*/false,\n+\t /*integral_constant_expression_p=*/true);\n+      new_specs = build_noexcept_spec (new_specs, complain);\n+    }\n+  else if (specs)\n     {\n       if (! TREE_VALUE (specs))\n \tnew_specs = specs;"}, {"sha": "e30882116bb2f00d8ef6a5870f7d48edc9225ed4", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=3a55fb4c89d4489cd21a8efde78a6f0de2e72099", "patch": "@@ -1867,7 +1867,7 @@ check_final_overrider (tree overrider, tree basefn)\n     }\n \n   /* Check throw specifier is at least as strict.  */\n-  if (!comp_except_specs (base_throw, over_throw, 0))\n+  if (!comp_except_specs (base_throw, over_throw, ce_derived))\n     {\n       error (\"looser throw specifier for %q+#F\", overrider);\n       error (\"  overriding %q+#F\", basefn);"}, {"sha": "7d0e4765cd158ede1a83b4730f4b804178ad3073", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=3a55fb4c89d4489cd21a8efde78a6f0de2e72099", "patch": "@@ -1467,12 +1467,16 @@ cxx_printable_name_translate (tree decl, int v)\n tree\n build_exception_variant (tree type, tree raises)\n {\n-  tree v = TYPE_MAIN_VARIANT (type);\n-  int type_quals = TYPE_QUALS (type);\n+  tree v;\n+  int type_quals;\n \n-  for (; v; v = TYPE_NEXT_VARIANT (v))\n+  if (comp_except_specs (raises, TYPE_RAISES_EXCEPTIONS (type), ce_exact))\n+    return type;\n+\n+  type_quals = TYPE_QUALS (type);\n+  for (v = TYPE_MAIN_VARIANT (type); v; v = TYPE_NEXT_VARIANT (v))\n     if (check_qualified_type (v, type, type_quals)\n-\t&& comp_except_specs (raises, TYPE_RAISES_EXCEPTIONS (v), 1))\n+\t&& comp_except_specs (raises, TYPE_RAISES_EXCEPTIONS (v), ce_exact))\n       return v;\n \n   /* Need to build a new variant.  */\n@@ -2645,10 +2649,8 @@ cp_build_type_attribute_variant (tree type, tree attributes)\n   tree new_type;\n \n   new_type = build_type_attribute_variant (type, attributes);\n-  if ((TREE_CODE (new_type) == FUNCTION_TYPE\n-       || TREE_CODE (new_type) == METHOD_TYPE)\n-      && (TYPE_RAISES_EXCEPTIONS (new_type)\n-\t  != TYPE_RAISES_EXCEPTIONS (type)))\n+  if (TREE_CODE (new_type) == FUNCTION_TYPE\n+      || TREE_CODE (new_type) == METHOD_TYPE)\n     new_type = build_exception_variant (new_type,\n \t\t\t\t\tTYPE_RAISES_EXCEPTIONS (type));\n \n@@ -2669,7 +2671,7 @@ cxx_type_hash_eq (const_tree typea, const_tree typeb)\n   gcc_assert (TREE_CODE (typea) == FUNCTION_TYPE);\n \n   return comp_except_specs (TYPE_RAISES_EXCEPTIONS (typea),\n-\t\t\t    TYPE_RAISES_EXCEPTIONS (typeb), 1);\n+\t\t\t    TYPE_RAISES_EXCEPTIONS (typeb), ce_exact);\n }\n \n /* Apply FUNC to all language-specific sub-trees of TP in a pre-order"}, {"sha": "26ffe1cc416e732d960e531b8ade1df2471b7bca", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=3a55fb4c89d4489cd21a8efde78a6f0de2e72099", "patch": "@@ -981,29 +981,56 @@ comp_except_types (tree a, tree b, bool exact)\n }\n \n /* Return true if TYPE1 and TYPE2 are equivalent exception specifiers.\n-   If EXACT is false, T2 can be stricter than T1 (according to 15.4/7),\n-   otherwise it must be exact. Exception lists are unordered, but\n-   we've already filtered out duplicates. Most lists will be in order,\n-   we should try to make use of that.  */\n+   If EXACT is ce_derived, T2 can be stricter than T1 (according to 15.4/5).\n+   If EXACT is ce_normal, the compatibility rules in 15.4/3 apply.\n+   If EXACT is ce_exact, the specs must be exactly the same. Exception lists\n+   are unordered, but we've already filtered out duplicates. Most lists will\n+   be in order, we should try to make use of that.  */\n \n bool\n-comp_except_specs (const_tree t1, const_tree t2, bool exact)\n+comp_except_specs (const_tree t1, const_tree t2, int exact)\n {\n   const_tree probe;\n   const_tree base;\n   int  length = 0;\n+  const_tree noexcept_spec = NULL_TREE;\n+  const_tree other_spec;\n \n   if (t1 == t2)\n     return true;\n \n+  /* First test noexcept compatibility.  */\n+  if (t1 && TREE_PURPOSE (t1))\n+    noexcept_spec = t1, other_spec = t2;\n+  else if (t2 && TREE_PURPOSE (t2))\n+    noexcept_spec = t2, other_spec = t1;\n+  if (noexcept_spec)\n+    {\n+      tree p = TREE_PURPOSE (noexcept_spec);\n+      /* Two noexcept-specs are equivalent iff their exprs are.  */\n+      if (other_spec && TREE_PURPOSE (other_spec))\n+\treturn cp_tree_equal (p, TREE_PURPOSE (other_spec));\n+      /* noexcept(true) is compatible with throw().  */\n+      else if (exact < ce_exact && p == boolean_true_node)\n+\treturn nothrow_spec_p (other_spec);\n+      /* noexcept(false) is compatible with any throwing\n+\t dynamic-exception-spec.  */\n+      else if (exact < ce_exact && p == boolean_false_node)\n+\treturn !nothrow_spec_p (other_spec);\n+      /* A dependent noexcept-spec is not compatible with any\n+\t dynamic-exception-spec.  */\n+      else\n+\treturn false;\n+    }\n+\n   if (t1 == NULL_TREE)\t\t\t   /* T1 is ...  */\n-    return t2 == NULL_TREE || !exact;\n+    return t2 == NULL_TREE || exact == ce_derived;\n   if (!TREE_VALUE (t1))\t\t\t   /* t1 is EMPTY */\n     return t2 != NULL_TREE && !TREE_VALUE (t2);\n   if (t2 == NULL_TREE)\t\t\t   /* T2 is ...  */\n     return false;\n   if (TREE_VALUE (t1) && !TREE_VALUE (t2)) /* T2 is EMPTY, T1 is not */\n-    return !exact;\n+    return exact == ce_derived;\n \n   /* Neither set is ... or EMPTY, make sure each part of T2 is in T1.\n      Count how many we find, to determine exactness. For exact matching and\n@@ -1018,7 +1045,7 @@ comp_except_specs (const_tree t1, const_tree t2, bool exact)\n \n \t  if (comp_except_types (a, b, exact))\n \t    {\n-\t      if (probe == base && exact)\n+\t      if (probe == base && exact > ce_derived)\n \t\tbase = TREE_CHAIN (probe);\n \t      length++;\n \t      break;\n@@ -1027,7 +1054,7 @@ comp_except_specs (const_tree t1, const_tree t2, bool exact)\n       if (probe == NULL_TREE)\n \treturn false;\n     }\n-  return !exact || base == NULL_TREE || length == list_length (t1);\n+  return exact == ce_derived || base == NULL_TREE || length == list_length (t1);\n }\n \n /* Compare the array types T1 and T2.  ALLOW_REDECLARATION is true if"}, {"sha": "93ea70d3808fd99d4cbcdd57d7a1c782fc30ce1f", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=3a55fb4c89d4489cd21a8efde78a6f0de2e72099", "patch": "@@ -1721,6 +1721,13 @@ merge_exception_specifiers (tree list, tree add)\n {\n   if (!list || !add)\n     return NULL_TREE;\n+  /* A noexcept(true) spec takes precedence over a throw() spec.\n+     A throw(type-list) spec takes precedence over a noexcept(false) spec.\n+     Any other noexcept-spec should only be merged with an equivalent one.\n+     So the !TREE_VALUE code is correct for the latter two cases.  */\n+  else if (list == noexcept_true_spec\n+\t   || add == noexcept_true_spec)\n+    return noexcept_true_spec;\n   else if (!TREE_VALUE (list))\n     return add;\n   else if (!TREE_VALUE (add))"}, {"sha": "7fe8c5010cd057ab71c3058a0fde1b4b4b36271d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3a55fb4c89d4489cd21a8efde78a6f0de2e72099", "patch": "@@ -1,6 +1,10 @@\n 2010-06-04  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/cpp0x/noexcept01.C: New.\n+\t* g++.dg/cpp0x/noexcept02.C: New.\n+\t* g++.dg/cpp0x/noexcept03.C: New.\n+\t* g++.dg/cpp0x/noexcept04.C: New.\n+\t* g++.dg/cpp0x/noexcept05.C: New.\n \n 2010-06-04  Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "be6fa00dd09127a24c98c9fb997becc7da5cd34d", "filename": "gcc/testsuite/g++.dg/cpp0x/noexcept02.C", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept02.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept02.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept02.C?ref=3a55fb4c89d4489cd21a8efde78a6f0de2e72099", "patch": "@@ -0,0 +1,52 @@\n+// Test for noexcept-specification\n+// { dg-options \"-std=c++0x\" }\n+\n+#define SA(X) static_assert(X, #X)\n+\n+void f();\n+void f() noexcept(false);\n+void f() noexcept(1 == 0);\n+void f();\n+\n+SA(!noexcept(f()));\n+\n+void g() throw (int);\n+void g() noexcept(false);\t// { dg-error \"previous declaration\" }\n+void g();\t\t\t// { dg-error \"different exception\" }\n+\n+void h() throw();\n+void h() noexcept;\n+void h() throw();\n+void h() noexcept;\n+\n+template <class T>\n+void g (T) noexcept(noexcept(T())); // { dg-error \"previous declaration\" }\n+template <class T>\n+void g (T) noexcept(noexcept(T(0))); // { dg-error \"different exception\" }\n+\n+template <class T>\n+void f (T) noexcept(noexcept(T()) && noexcept(T()));\n+template <class T>\n+void f (T) noexcept(noexcept(T()) && noexcept(T()));\n+template <class T>\n+void f2(T a) noexcept (noexcept (f (a)));\n+\n+struct A { A(); };\n+SA(noexcept(f(1)));\n+SA(!noexcept(f(A())));\n+SA(noexcept(f2(1)));\n+SA(!noexcept(f2(A())));\n+\n+template <class... Ts>\n+void f3(Ts... ts) noexcept (noexcept (f(ts...)));\n+\n+SA(noexcept(f3(1)));\n+SA(!noexcept(f3(A())));\n+\n+template <class T1, class T2>\n+void f (T1, T2) noexcept(noexcept(T1(), T2()));\n+\n+SA(noexcept(f3(1,1)));\n+SA(!noexcept(f3(1,A())));\n+SA(!noexcept(f3(A(),1)));\n+SA(!noexcept(f3(A(),A())));"}, {"sha": "d9922454425b41a4f8db4ef8a96b7d5412a45a51", "filename": "gcc/testsuite/g++.dg/cpp0x/noexcept03.C", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept03.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept03.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept03.C?ref=3a55fb4c89d4489cd21a8efde78a6f0de2e72099", "patch": "@@ -0,0 +1,68 @@\n+// Runtime test for noexcept-specification.\n+// { dg-options \"-std=c++0x\" }\n+// { dg-do run }\n+\n+#include <exception>\n+#include <cstdlib>\n+\n+void my_terminate ()\n+{\n+  std::exit (0);\n+}\n+\n+void my_unexpected ()\n+{\n+  throw;\n+}\n+\n+void g() { throw 1; }\n+void (*p)() = g;\n+void f () noexcept (false)\n+{\n+  p();\n+}\n+\n+template <class T>\n+void f(T) noexcept (noexcept (T()))\n+{\n+  p();\n+}\n+\n+template <class T>\n+void f2(T a) noexcept (noexcept (f (a)))\n+{\n+  f(a);\n+}\n+\n+struct A { A() { } };\n+\n+// throw(int) overrides noexcept(false) in either order.\n+void h() throw (int, std::bad_exception);\n+void h() noexcept (false)\n+{\n+  throw 1.0;\n+}\n+\n+void i() noexcept (false);\n+void i() throw (int, std::bad_exception)\n+{\n+  throw 1.0;\n+}\n+\n+int main()\n+{\n+  // noexcept(false) allows throw.\n+  try { f(); } catch (int) { }\n+  // noexcept(noexcept(A())) == noexcept(false).\n+  try { f(A()); } catch (int) { }\n+  try { f2(A()); } catch (int) { }\n+\n+  std::set_unexpected (my_unexpected);\n+  try { h(); } catch (std::bad_exception) { }\n+  try { i(); } catch (std::bad_exception) { }\n+\n+  std::set_terminate (my_terminate);\n+  // noexcept(noexcept(int())) == noexcept(true).\n+  try { f2(1); } catch (...) { }\n+  return 1;\n+}"}, {"sha": "8df818610f5fb62ee450bfa8de63445985816c51", "filename": "gcc/testsuite/g++.dg/cpp0x/noexcept04.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept04.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept04.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept04.C?ref=3a55fb4c89d4489cd21a8efde78a6f0de2e72099", "patch": "@@ -0,0 +1,31 @@\n+// Make sure that we call terminate when a noexcept spec is violated.\n+// The function pointers are there to make sure that\n+// the compiler doesn't get clever about optimizing the calls based on\n+// knowledge about the called functions.\n+\n+// { dg-options \"-std=c++0x\" }\n+// { dg-do run }\n+\n+#include <exception>\n+#include <cstdlib>\n+\n+void my_terminate ()\n+{\n+  std::exit (0);\n+}\n+\n+void g() { throw 1; }\n+void (*p1)() = g;\n+void f() noexcept { p1(); }\n+void (*p2)() = f;\n+void h() { p2(); }\n+\n+int main()\n+{\n+  std::set_terminate (my_terminate);\n+\n+  try { h(); }\n+  catch (int) { }\n+\n+  return 1;\n+}"}, {"sha": "6acea43273658ea8fdb653935048ae2e6ffa34f1", "filename": "gcc/testsuite/g++.dg/cpp0x/noexcept05.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept05.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept05.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept05.C?ref=3a55fb4c89d4489cd21a8efde78a6f0de2e72099", "patch": "@@ -0,0 +1,19 @@\n+// Make sure that we force an LSDA for a noexcept spec so\n+// that the personality routine will call terminate.  Also check that we\n+// optimize away the EH cleanup for var because the personality routine\n+// will call terminate before unwinding: there should not be an EH region\n+// (i.e. LEHB/LEHE labels) around the call to g().\n+\n+// { dg-final { scan-assembler-not \"_ZSt9terminatev\" } }\n+// { dg-final { scan-assembler-not \"EHB\" } }\n+// { dg-final { scan-assembler \"LSDA\" } }\n+\n+// { dg-options \"-std=c++0x\" }\n+\n+struct A { ~A(); };\n+void g();\n+void f() noexcept\n+{\n+  A var;\n+  g();\n+}"}, {"sha": "72dadff2257d29998b15a90910a46f2132c18b25", "filename": "gcc/testsuite/g++.dg/eh/spec8.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fspec8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a55fb4c89d4489cd21a8efde78a6f0de2e72099/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fspec8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fspec8.C?ref=3a55fb4c89d4489cd21a8efde78a6f0de2e72099", "patch": "@@ -3,9 +3,9 @@\n struct exception {};\n \n template <typename T> void foo() throw(exception); // { dg-error \"declaration\" }\n-template <typename T> void foo(); // { dg-error \"exceptions\" }\n+template <typename T> void foo(); // { dg-error \"exception\" }\n \n struct bar\n {\n-  template <typename T> friend void foo(); // { dg-error \"exceptions\" }\n+  template <typename T> friend void foo(); // { dg-error \"exception\" }\n };"}]}