{"sha": "5abd2125f012351411df08f07918667ce3e418a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFiZDIxMjVmMDEyMzUxNDExZGYwOGYwNzkxODY2N2NlM2U0MThhOQ==", "commit": {"author": {"name": "Jayant Sonar", "email": "jayants@kpitcummins.com", "date": "2007-05-07T23:13:15Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2007-05-07T23:13:15Z"}, "message": "m32c.c (SYMBOL_FLAG_FUNCVEC_FUNCTION): Define.\n\n* config/m32c/m32c.c (SYMBOL_FLAG_FUNCVEC_FUNCTION): Define.\n(TARGET_ENCODE_SECTION_INFO): Re-define.\n(m32c_encode_section_info): New\n(function_vector_handler): New\n(current_function_special_page_vector): New\n(m32c_special_page_vector_p): New.\n* config/m32c/m32c-protos.h (m32c_special_page_vector_p): \nPrototype.\n* config/m32c/jump.md: Added instruction JSRS for functions \nwith attribute \"function_vector\".\n* doc/extend.texi (function_vector): Added description \nfor M16C, M32C targets.\n\nFrom-SVN: r124523", "tree": {"sha": "b4d7248e78a4d9cbf0ccb466af301868b241de83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4d7248e78a4d9cbf0ccb466af301868b241de83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5abd2125f012351411df08f07918667ce3e418a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5abd2125f012351411df08f07918667ce3e418a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5abd2125f012351411df08f07918667ce3e418a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5abd2125f012351411df08f07918667ce3e418a9/comments", "author": null, "committer": null, "parents": [{"sha": "04055200edcb139e4be7088107191b7a1a9089fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04055200edcb139e4be7088107191b7a1a9089fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04055200edcb139e4be7088107191b7a1a9089fa"}], "stats": {"total": 196, "additions": 193, "deletions": 3}, "files": [{"sha": "9452c04552462f5f90794844ad2b28d1885609ac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5abd2125f012351411df08f07918667ce3e418a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5abd2125f012351411df08f07918667ce3e418a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5abd2125f012351411df08f07918667ce3e418a9", "patch": "@@ -1,3 +1,18 @@\n+2007-05-07  Jayant Sonar  <jayants@kpitcummins.com>\n+\n+\t* config/m32c/m32c.c (SYMBOL_FLAG_FUNCVEC_FUNCTION): Define.\n+\t(TARGET_ENCODE_SECTION_INFO): Re-define.\n+\t(m32c_encode_section_info): New\n+\t(function_vector_handler): New\n+\t(current_function_special_page_vector): New\n+\t(m32c_special_page_vector_p): New.\n+\t* config/m32c/m32c-protos.h (m32c_special_page_vector_p): \n+\tPrototype.\n+\t* config/m32c/jump.md: Added instruction JSRS for functions \n+\twith attribute \"function_vector\".\n+\t* doc/extend.texi (function_vector): Added description \n+\tfor M16C, M32C targets.\n+\n 2007-05-07  DJ Delorie  <dj@redhat.com>\n \n \tPR 31794"}, {"sha": "f0983d1532db26c2f9c5f39abb13f065ffdd449c", "filename": "gcc/config/m32c/jump.md", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5abd2125f012351411df08f07918667ce3e418a9/gcc%2Fconfig%2Fm32c%2Fjump.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5abd2125f012351411df08f07918667ce3e418a9/gcc%2Fconfig%2Fm32c%2Fjump.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fjump.md?ref=5abd2125f012351411df08f07918667ce3e418a9", "patch": "@@ -69,7 +69,18 @@\n   \"\"\n   \"*\n switch (which_alternative) {\n-  case 0: return \\\"jsr.a\\t%0\\\";\n+  case 0:\n+    {\n+      HOST_WIDE_INT func_vect_num = \n+      current_function_special_page_vector(XEXP (operands[0], 0));\n+      if (func_vect_num)\n+        {\n+          operands[3] = gen_rtx_CONST_INT (VOIDmode, func_vect_num);\n+          return \\\"jsrs\\t%3\\\";\n+        }\n+      else\n+        return \\\"jsr.a\\t%0\\\";\n+    }\n   case 1: return TARGET_A16 ? \\\"push.w %a0 | jsr.a\\tm32c_jsri16\\\" : \\\"jsri.a\\t%a0\\\";\n   case 2: return \\\"jsri.a\\t%a0\\\";\n }\"\n@@ -84,7 +95,18 @@ switch (which_alternative) {\n   \"\"\n   \"*\n switch (which_alternative) {\n-  case 0: return \\\"jsr.a\\t%1\\\";\n+  case 0:\n+    {\n+      HOST_WIDE_INT func_vect_num = \n+      current_function_special_page_vector(XEXP (operands[1], 0));\n+      if (func_vect_num)\n+        {\n+          operands[4] = gen_rtx_CONST_INT (VOIDmode, func_vect_num);\n+          return \\\"jsrs\\t%4\\\";\n+        }\n+      else\n+        return \\\"jsr.a\\t%1\\\";\n+    }\n   case 1: return TARGET_A16 ? \\\"push.w %a1 | jsr.a\\tm32c_jsri16\\\" : \\\"jsri.a\\t%a1\\\";\n   case 2: return \\\"jsri.a\\t%a1\\\";\n }\""}, {"sha": "5bbc67cbb323e828bbd15d54919ffb05e94bc44b", "filename": "gcc/config/m32c/m32c-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5abd2125f012351411df08f07918667ce3e418a9/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5abd2125f012351411df08f07918667ce3e418a9/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h?ref=5abd2125f012351411df08f07918667ce3e418a9", "patch": "@@ -112,6 +112,7 @@ void m32c_function_arg_advance (CUMULATIVE_ARGS *, MM, tree, int);\n tree m32c_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n void m32c_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, int);\n bool m32c_promote_function_return (tree);\n+int  m32c_special_page_vector_p (tree);\n \n #endif\n "}, {"sha": "dd0bce332994b004d03952af0e70b2a1c6977bce", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5abd2125f012351411df08f07918667ce3e418a9/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5abd2125f012351411df08f07918667ce3e418a9/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=5abd2125f012351411df08f07918667ce3e418a9", "patch": "@@ -61,6 +61,7 @@ typedef enum\n } Push_Pop_Type;\n \n static tree interrupt_handler (tree *, tree, tree, int, bool *);\n+static tree function_vector_handler (tree *, tree, tree, int, bool *);\n static int interrupt_p (tree node);\n static bool m32c_asm_integer (rtx, unsigned int, int);\n static int m32c_comp_type_attributes (tree, tree);\n@@ -75,6 +76,9 @@ static bool m32c_strict_argument_naming (CUMULATIVE_ARGS *);\n static rtx m32c_struct_value_rtx (tree, int);\n static rtx m32c_subreg (enum machine_mode, rtx, enum machine_mode, int);\n static int need_to_save (int);\n+int current_function_special_page_vector (rtx);\n+\n+#define SYMBOL_FLAG_FUNCVEC_FUNCTION    (SYMBOL_FLAG_MACH_DEP << 0)\n \n #define streq(a,b) (strcmp ((a), (b)) == 0)\n \n@@ -2721,10 +2725,104 @@ interrupt_handler (tree * node ATTRIBUTE_UNUSED,\n   return NULL_TREE;\n }\n \n+/* Returns TRUE if given tree has the \"function_vector\" attribute. */\n+int\n+m32c_special_page_vector_p (tree func)\n+{\n+  if (TREE_CODE (func) != FUNCTION_DECL)\n+    return 0;\n+\n+  tree list = M32C_ATTRIBUTES (func);\n+  while (list)\n+    {\n+      if (is_attribute_p (\"function_vector\", TREE_PURPOSE (list)))\n+        return 1;\n+      list = TREE_CHAIN (list);\n+    }\n+  return 0;\n+}\n+\n+static tree\n+function_vector_handler (tree * node ATTRIBUTE_UNUSED,\n+                         tree name ATTRIBUTE_UNUSED,\n+                         tree args ATTRIBUTE_UNUSED,\n+                         int flags ATTRIBUTE_UNUSED,\n+                         bool * no_add_attrs ATTRIBUTE_UNUSED)\n+{\n+  if (TARGET_R8C)\n+    {\n+      /* The attribute is not supported for R8C target.  */\n+      warning (OPT_Wattributes,\n+                \"`%s' attribute is not supported for R8C target\",\n+                IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      /* The attribute must be applied to functions only.  */\n+      warning (OPT_Wattributes,\n+                \"`%s' attribute applies only to functions\",\n+                IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else if (TREE_CODE (TREE_VALUE (args)) != INTEGER_CST)\n+    {\n+      /* The argument must be a constant integer.  */\n+      warning (OPT_Wattributes,\n+                \"`%s' attribute argument not an integer constant\",\n+                IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else if (TREE_INT_CST_LOW (TREE_VALUE (args)) < 18\n+           || TREE_INT_CST_LOW (TREE_VALUE (args)) > 255)\n+    {\n+      /* The argument value must be between 18 to 255.  */\n+      warning (OPT_Wattributes,\n+                \"`%s' attribute argument should be between 18 to 255\",\n+                IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* If the function is assigned the attribute 'function_vector', it\n+   returns the function vector number, otherwise returns zero.  */\n+int\n+current_function_special_page_vector (rtx x)\n+{\n+  int num;\n+\n+  if ((GET_CODE(x) == SYMBOL_REF)\n+      && (SYMBOL_REF_FLAGS (x) & SYMBOL_FLAG_FUNCVEC_FUNCTION))\n+    {\n+      tree t = SYMBOL_REF_DECL (x);\n+\n+      if (TREE_CODE (t) != FUNCTION_DECL)\n+        return 0;\n+\n+      tree list = M32C_ATTRIBUTES (t);\n+      while (list)\n+        {\n+          if (is_attribute_p (\"function_vector\", TREE_PURPOSE (list)))\n+            {\n+              num = TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (list)));\n+              return num;\n+            }\n+\n+          list = TREE_CHAIN (list);\n+        }\n+\n+      return 0;\n+    }\n+  else\n+    return 0;\n+}\n+\n #undef TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE m32c_attribute_table\n static const struct attribute_spec m32c_attribute_table[] = {\n   {\"interrupt\", 0, 0, false, false, false, interrupt_handler},\n+  {\"function_vector\", 1, 1, true,  false, false, function_vector_handler},\n   {0, 0, 0, 0, 0, 0, 0}\n };\n \n@@ -3751,6 +3849,23 @@ m32c_scc_pattern(rtx *operands, RTX_CODE code)\n   return buf;\n }\n \n+/* Encode symbol attributes of a SYMBOL_REF into its\n+   SYMBOL_REF_FLAGS. */\n+static void\n+m32c_encode_section_info (tree decl, rtx rtl, int first)\n+{\n+  int extra_flags = 0;\n+\n+  default_encode_section_info (decl, rtl, first);\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && m32c_special_page_vector_p (decl))\n+\n+    extra_flags = SYMBOL_FLAG_FUNCVEC_FUNCTION;\n+\n+  if (extra_flags)\n+    SYMBOL_REF_FLAGS (XEXP (rtl, 0)) |= extra_flags;\n+}\n+\n /* Returns TRUE if the current function is a leaf, and thus we can\n    determine which registers an interrupt function really needs to\n    save.  The logic below is mostly about finding the insn sequence\n@@ -4164,6 +4279,9 @@ m32c_output_compare (rtx insn, rtx *operands)\n   return template + 1;\n }\n \n+#undef TARGET_ENCODE_SECTION_INFO\n+#define TARGET_ENCODE_SECTION_INFO m32c_encode_section_info\n+\n /* The Global `targetm' Variable. */\n \n struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "1069892a50c745c1bb37c6595c7d62275f93c8c5", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5abd2125f012351411df08f07918667ce3e418a9/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5abd2125f012351411df08f07918667ce3e418a9/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=5abd2125f012351411df08f07918667ce3e418a9", "patch": "@@ -1972,7 +1972,7 @@ is used.  @xref{C Dialect Options,,Options\n Controlling C Dialect}.\n \n @item function_vector\n-@cindex calling functions through the function vector on the H8/300 processors\n+@cindex calling functions through the function vector on H8/300, M16C, and M32C processors\n Use this attribute on the H8/300, H8/300H, and H8S to indicate that the specified\n function should be called through the function vector.  Calling a\n function through the function vector will reduce code size, however;\n@@ -1982,6 +1982,40 @@ and 64 entries on the H8/300H and H8S) and shares space with the interrupt vecto\n You must use GAS and GLD from GNU binutils version 2.7 or later for\n this attribute to work correctly.\n \n+On M16C/M32C targets, the @code{function_vector} attribute declares a\n+special page subroutine call function. Use of this attribute reduces\n+the code size by 2 bytes for each call generated to the\n+subroutine. The argument to the attribute is the vector number entry\n+from the special page vector table which contains the 16 low-order\n+bits of the subroutine's entry address. Each vector table has special\n+page number (18 to 255) which are used in @code{jsrs} instruction.\n+Jump addresses of the routines are generated by adding 0x0F0000 (in\n+case of M16C targets) or 0xFF0000 (in case of M32C targets), to the 2\n+byte addresses set in the vector table. Therefore you need to ensure\n+that all the special page vector routines should get mapped within the\n+address range 0x0F0000 to 0x0FFFFF (for M16C) and 0xFF0000 to 0xFFFFFF\n+(for M32C).\n+\n+In the following example 2 bytes will be saved for each call to\n+function @code{foo}.\n+\n+@smallexample\n+void foo (void) __attribute__((function_vector(0x18)));\n+void foo (void)\n+@{\n+@}\n+\n+void bar (void)\n+@{\n+    foo();\n+@}\n+@end smallexample\n+\n+If functions are defined in one file and are called in another file,\n+then be sure to write this declaration in both files.\n+\n+This attribute is ignored for R8C target.\n+\n @item interrupt\n @cindex interrupt handler functions\n Use this attribute on the ARM, AVR, C4x, CRX, M32C, M32R/D, MS1, and Xstormy16"}]}