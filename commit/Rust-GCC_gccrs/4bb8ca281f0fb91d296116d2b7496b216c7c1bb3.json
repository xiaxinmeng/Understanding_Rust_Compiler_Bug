{"sha": "4bb8ca281f0fb91d296116d2b7496b216c7c1bb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJiOGNhMjgxZjBmYjkxZDI5NjExNmQyYjc0OTZiMjE2YzdjMWJiMw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-12-15T06:28:23Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-12-15T06:28:23Z"}, "message": "re PR c++/10779 (Error cascade for unknown type in function prototype)\n\n\t* c-common.h (c_parse_error): Declare it.\n\t* c-common.c (c_parse_error): New function.\n\t* c-parse.y (yyerror): Use it.\n\n\t* parser.c (struct cp_parser): Add in_template_argument_list_p.\n\t(cp_parser_error): Use c_parse_error.\n\t(cp_parser_name_lookup_error): New function.\n\t(cp_parser_new): Initialize it.\n\t(cp_parser_declarator): Add parenthesized_p parameter.\n\t(cp_parser_nested_name_specifier_opt): Use\n\tcp_parser_name_lookup_error.\n\t(cp_parser_parenthesized_expression_list): Improve comments.\n\t(cp_parser_condition): Adjust call to cp_parser_declarator.\n\t(cp_parser_template_parameter): Adjust call to\n\tcp_parser_parameter_declaration.\n\t(cp_parser_template_argument_list): Set\n\tin_template_argument_list_p.\n\t(cp_parser_explicit_instantiation): Adjust call to\n\tcp_parser_declarator.\n\t(cp_parser_simple_type_specifier): Remove unncessary code.\n\t(cp_parser_using_declaration): Use cp_parser_name_lookup_error.\n\t(cp_parser_init_declarator): Handle member function definitions.\n\t(cp_parser_direct_declarator): Adjust call to\n\tcp_parser_declarator.\n\t(cp_parser_type_id): Adjust call to cp_parser_declarator.\n\t(cp_parser_parameter_declaration_list): Avoid backtracking where\n\tpossible.\n\t(cp_parser_parameter_declaration): Add parenthesized_p parameter.\n\t(cp_parser_function_definition): Remove.\n\t(cp_parser_member_declaration): Do not backtrack to look for\n\tfunction definitions.\n\t(cp_parser_exception_declaration): Adjust call to\n\tcp_parser_declarator.\n\t(cp_parser_single_declaration): Handle function definitions via\n\tcp_parser_init_declarator.\n\t(cp_parser_save_member_function_body): New function.\n\n\tPR c++/10779\n\tPR c++/12160\n\t* g++.dg/parse/error3.C: New test.\n\t* g++.dg/parse/error4.C: Likewise.\n\t* g++.dg/abi/mangle4.C: Tweak error messages.\n\t* g++.dg/lookup/using5.C: Likewise.\n\t* g++.dg/other/error2.C: Likewise.\n\t* g++.dg/parse/typename5.C: Likewise.\n\t* g++.dg/parse/undefined1.C: Likewise.\n\t* g++.dg/template/arg2.C: Likewise.\n\t* g++.dg/template/ttp3.C: Likewise.\n\t* g++.dg/template/type1.C: Likewise.\n\t* g++.old-deja/g++.other/crash32.C: Likewise.\n\t* g++.old-djea/g++.pt/defarg8.C: Likewise.\n\nFrom-SVN: r74624", "tree": {"sha": "cf0b0628bdaaa8f00ed673d539b8e8c5c1193fa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf0b0628bdaaa8f00ed673d539b8e8c5c1193fa3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/comments", "author": null, "committer": null, "parents": [{"sha": "69f364953465519ced88df15edd1422c4382aecd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69f364953465519ced88df15edd1422c4382aecd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69f364953465519ced88df15edd1422c4382aecd"}], "stats": {"total": 706, "additions": 385, "deletions": 321}, "files": [{"sha": "f93381226c3c9f07e21bd1e454141218d747c0fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4bb8ca281f0fb91d296116d2b7496b216c7c1bb3", "patch": "@@ -1,3 +1,9 @@\n+2003-12-14  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* c-common.h (c_parse_error): Declare it.\n+\t* c-common.c (c_parse_error): New function.\n+\t* c-parse.y (yyerror): Use it.\n+\n 2003-12-14  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR target/13054"}, {"sha": "4ba17e0cbd93e3616f05ef665667cf5640e592b0", "filename": "gcc/c-common.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=4bb8ca281f0fb91d296116d2b7496b216c7c1bb3", "patch": "@@ -5893,4 +5893,36 @@ c_decl_uninit (tree t)\n   return false;\n }\n \n+/* Issue the error given by MSGID, indicating that it occurred before\n+   TOKEN, which had the associated VALUE.  */\n+\n+void\n+c_parse_error (const char *msgid, enum cpp_ttype token, tree value)\n+{\n+  const char *string = _(msgid);\n+\n+  if (token == CPP_EOF)\n+    error (\"%s at end of input\", string);\n+  else if (token == CPP_CHAR || token == CPP_WCHAR)\n+    {\n+      unsigned int val = TREE_INT_CST_LOW (value);\n+      const char *const ell = (token == CPP_CHAR) ? \"\" : \"L\";\n+      if (val <= UCHAR_MAX && ISGRAPH (val))\n+\terror (\"%s before %s'%c'\", string, ell, val);\n+      else\n+\terror (\"%s before %s'\\\\x%x'\", string, ell, val);\n+    }\n+  else if (token == CPP_STRING\n+\t   || token == CPP_WSTRING)\n+    error (\"%s before string constant\", string);\n+  else if (token == CPP_NUMBER)\n+    error (\"%s before numeric constant\", string);\n+  else if (token == CPP_NAME)\n+    error (\"%s before \\\"%s\\\"\", string, IDENTIFIER_POINTER (value));\n+  else if (token < N_TTYPES)\n+    error (\"%s before '%s' token\", string, cpp_type2name (token));\n+  else\n+    error (\"%s\", string);\n+}\n+\n #include \"gt-c-common.h\""}, {"sha": "326fe519be43f8b6cfb636833002047140b55a42", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=4bb8ca281f0fb91d296116d2b7496b216c7c1bb3", "patch": "@@ -1330,6 +1330,7 @@ extern void c_stddef_cpp_builtins (void);\n extern void fe_file_change (const struct line_map *);\n extern int c_estimate_num_insns (tree decl);\n extern bool c_decl_uninit (tree t);\n+extern void c_parse_error (const char *, enum cpp_ttype, tree);\n \n /* The following have been moved here from c-tree.h, since they're needed\n    in the ObjC++ world, too.  What is more, stub-objc.c could use a few"}, {"sha": "b36ab06524a092508a7fd3f99f013a7c170aad75", "filename": "gcc/c-parse.in", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=4bb8ca281f0fb91d296116d2b7496b216c7c1bb3", "patch": "@@ -3551,28 +3551,7 @@ init_reswords (void)\n static void\n yyerror (const char *msgid)\n {\n-  const char *string = _(msgid);\n-\n-  if (last_token == CPP_EOF)\n-    error (\"%s at end of input\", string);\n-  else if (last_token == CPP_CHAR || last_token == CPP_WCHAR)\n-    {\n-      unsigned int val = TREE_INT_CST_LOW (yylval.ttype);\n-      const char *const ell = (last_token == CPP_CHAR) ? \"\" : \"L\";\n-      if (val <= UCHAR_MAX && ISGRAPH (val))\n-\terror (\"%s before %s'%c'\", string, ell, val);\n-      else\n-\terror (\"%s before %s'\\\\x%x'\", string, ell, val);\n-    }\n-  else if (last_token == CPP_STRING\n-\t   || last_token == CPP_WSTRING)\n-    error (\"%s before string constant\", string);\n-  else if (last_token == CPP_NUMBER)\n-    error (\"%s before numeric constant\", string);\n-  else if (last_token == CPP_NAME)\n-    error (\"%s before \\\"%s\\\"\", string, IDENTIFIER_POINTER (yylval.ttype));\n-  else\n-    error (\"%s before '%s' token\", string, NAME(last_token));\n+  c_parse_error (msgid, last_token, yylval.ttype);\n }\n \n static int"}, {"sha": "732273e2edf5c11dbd23c1baf7970c2526979b65", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4bb8ca281f0fb91d296116d2b7496b216c7c1bb3", "patch": "@@ -1,3 +1,40 @@\n+2003-12-14  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/10779\n+\tPR c++/12160\n+\t* parser.c (struct cp_parser): Add in_template_argument_list_p.\n+\t(cp_parser_error): Use c_parse_error.\n+\t(cp_parser_name_lookup_error): New function.\n+\t(cp_parser_new): Initialize it.\n+\t(cp_parser_declarator): Add parenthesized_p parameter.\n+\t(cp_parser_nested_name_specifier_opt): Use\n+\tcp_parser_name_lookup_error.\n+\t(cp_parser_parenthesized_expression_list): Improve comments.\n+\t(cp_parser_condition): Adjust call to cp_parser_declarator.\n+\t(cp_parser_template_parameter): Adjust call to\n+\tcp_parser_parameter_declaration.\n+\t(cp_parser_template_argument_list): Set\n+\tin_template_argument_list_p.\n+\t(cp_parser_explicit_instantiation): Adjust call to\n+\tcp_parser_declarator.\n+\t(cp_parser_simple_type_specifier): Remove unncessary code.\n+\t(cp_parser_using_declaration): Use cp_parser_name_lookup_error.\n+\t(cp_parser_init_declarator): Handle member function definitions.\n+\t(cp_parser_direct_declarator): Adjust call to\n+\tcp_parser_declarator.\n+\t(cp_parser_type_id): Adjust call to cp_parser_declarator.\n+\t(cp_parser_parameter_declaration_list): Avoid backtracking where\n+\tpossible.\n+\t(cp_parser_parameter_declaration): Add parenthesized_p parameter.\n+\t(cp_parser_function_definition): Remove.\n+\t(cp_parser_member_declaration): Do not backtrack to look for\n+\tfunction definitions.\n+\t(cp_parser_exception_declaration): Adjust call to\n+\tcp_parser_declarator.\n+\t(cp_parser_single_declaration): Handle function definitions via\n+\tcp_parser_init_declarator.\n+\t(cp_parser_save_member_function_body): New function.\n+\n 2003-12-14  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/13106"}, {"sha": "4709ccbd9a765831f098b60cc00043afd51d3a36", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 265, "deletions": 286, "changes": 551, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=4bb8ca281f0fb91d296116d2b7496b216c7c1bb3", "patch": "@@ -1243,6 +1243,9 @@ typedef struct cp_parser GTY(())\n      direct-declarator.  */\n   bool in_declarator_p;\n \n+  /* TRUE if we are presently parsing a template-argument-list.  */\n+  bool in_template_argument_list_p;\n+\n   /* TRUE if we are presently parsing the body of an\n      iteration-statement.  */\n   bool in_iteration_statement_p;\n@@ -1470,7 +1473,7 @@ static void cp_parser_linkage_specification\n static tree cp_parser_init_declarator\n   (cp_parser *, tree, tree, bool, bool, int, bool *);\n static tree cp_parser_declarator\n-  (cp_parser *, cp_parser_declarator_kind, int *);\n+  (cp_parser *, cp_parser_declarator_kind, int *, bool *);\n static tree cp_parser_direct_declarator\n   (cp_parser *, cp_parser_declarator_kind, int *);\n static enum tree_code cp_parser_ptr_operator\n@@ -1490,9 +1493,7 @@ static tree cp_parser_parameter_declaration_clause\n static tree cp_parser_parameter_declaration_list\n   (cp_parser *);\n static tree cp_parser_parameter_declaration\n-  (cp_parser *, bool);\n-static tree cp_parser_function_definition\n-  (cp_parser *, bool *);\n+  (cp_parser *, bool, bool *);\n static void cp_parser_function_body\n   (cp_parser *);\n static tree cp_parser_initializer\n@@ -1644,6 +1645,8 @@ static tree cp_parser_single_declaration\n   (cp_parser *, bool, bool *);\n static tree cp_parser_functional_cast\n   (cp_parser *, tree);\n+static tree cp_parser_save_member_function_body\n+  (cp_parser *, tree, tree, tree);\n static tree cp_parser_enclosed_template_argument_list\n   (cp_parser *);\n static void cp_parser_save_default_args\n@@ -1696,6 +1699,8 @@ static bool cp_parser_committed_to_tentative_parse\n   (cp_parser *);\n static void cp_parser_error\n   (cp_parser *, const char *);\n+static void cp_parser_name_lookup_error\n+  (cp_parser *, tree, tree, const char *);\n static bool cp_parser_simulate_error\n   (cp_parser *);\n static void cp_parser_check_type_definition\n@@ -1760,7 +1765,42 @@ cp_parser_error (cp_parser* parser, const char* message)\n {\n   /* Output the MESSAGE -- unless we're parsing tentatively.  */\n   if (!cp_parser_simulate_error (parser))\n-    error (message);\n+    {\n+      cp_token *token;\n+      token = cp_lexer_peek_token (parser->lexer);\n+      c_parse_error (message, token->type, token->value);\n+    }\n+}\n+\n+/* Issue an error about name-lookup failing.  NAME is the\n+   IDENTIFIER_NODE DECL is the result of\n+   the lookup (as returned from cp_parser_lookup_name).  DESIRED is\n+   the thing that we hoped to find.  */\n+\n+static void\n+cp_parser_name_lookup_error (cp_parser* parser,\n+\t\t\t     tree name,\n+\t\t\t     tree decl,\n+\t\t\t     const char* desired)\n+{\n+  /* If name lookup completely failed, tell the user that NAME was not\n+     declared.  */\n+  if (decl == error_mark_node)\n+    {\n+      if (parser->scope && parser->scope != global_namespace)\n+\terror (\"`%D::%D' has not been declared\", \n+\t       parser->scope, name);\n+      else if (parser->scope == global_namespace)\n+\terror (\"`::%D' has not been declared\", name);\n+      else\n+\terror (\"`%D' has not been declared\", name);\n+    }\n+  else if (parser->scope && parser->scope != global_namespace)\n+    error (\"`%D::%D' %s\", parser->scope, name, desired);\n+  else if (parser->scope == global_namespace)\n+    error (\"`::%D' %s\", name, desired);\n+  else\n+    error (\"`%D' %s\", name, desired);\n }\n \n /* If we are parsing tentatively, remember that an error has occurred\n@@ -2194,6 +2234,9 @@ cp_parser_new (void)\n   /* We are not processing a declarator.  */\n   parser->in_declarator_p = false;\n \n+  /* We are not processing a template-argument-list.  */\n+  parser->in_template_argument_list_p = false;\n+\n   /* We are not in an iteration statement.  */\n   parser->in_iteration_statement_p = false;\n \n@@ -3087,24 +3130,10 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t\t  if (TREE_CODE (decl) == TEMPLATE_DECL)\n \t\t    error (\"`%D' used without template parameters\",\n \t\t\t   decl);\n-\t\t  else if (parser->scope)\n-\t\t    {\n-\t\t      if (TYPE_P (parser->scope))\n-\t\t\terror (\"`%T::%D' is not a class-name or \"\n-\t\t\t       \"namespace-name\",\n-\t\t\t       parser->scope, token->value);\n-\t\t      else if (parser->scope == global_namespace)\n-\t\t\terror (\"`::%D' is not a class-name or \"\n-\t\t\t       \"namespace-name\",\n-\t\t\t       token->value);\n-\t\t      else\n-\t\t\terror (\"`%D::%D' is not a class-name or \"\n-\t\t\t       \"namespace-name\",\n-\t\t\t       parser->scope, token->value);\n-\t\t    }\n \t\t  else\n-\t\t    error (\"`%D' is not a class-name or namespace-name\",\n-\t\t\t   token->value);\n+\t\t    cp_parser_name_lookup_error \n+\t\t      (parser, token->value, decl, \n+\t\t       \"is not a class or namespace\");\n \t\t  parser->scope = NULL_TREE;\n \t\t  error_p = true;\n \t\t  /* Treat this as a successful nested-name-specifier\n@@ -3958,7 +3987,9 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n     skip_comma:;\n       /* We try and resync to an unnested comma, as that will give the\n \t user better diagnostics.  */\n-      ending = cp_parser_skip_to_closing_parenthesis (parser, true, true,\n+      ending = cp_parser_skip_to_closing_parenthesis (parser, \n+\t\t\t\t\t\t      /*recovering=*/true, \n+\t\t\t\t\t\t      /*or_comma=*/true,\n \t\t\t\t\t\t      /*consume_paren=*/true);\n       if (ending < 0)\n \tgoto get_comma;\n@@ -5621,7 +5652,8 @@ cp_parser_condition (cp_parser* parser)\n       \n       /* Parse the declarator.  */\n       declarator = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n-\t\t\t\t\t /*ctor_dtor_or_conv_p=*/NULL);\n+\t\t\t\t\t /*ctor_dtor_or_conv_p=*/NULL,\n+\t\t\t\t\t /*parenthesized_p=*/NULL);\n       /* Parse the attributes.  */\n       attributes = cp_parser_attributes_opt (parser);\n       /* Parse the asm-specification.  */\n@@ -7449,7 +7481,8 @@ cp_parser_template_parameter (cp_parser* parser)\n      of the template parameter-list rather than a greater-than\n      operator.  */\n   return \n-    cp_parser_parameter_declaration (parser, /*template_parm_p=*/true);\n+    cp_parser_parameter_declaration (parser, /*template_parm_p=*/true,\n+\t\t\t\t     /*parenthesized_p=*/NULL);\n }\n \n /* Parse a type-parameter.\n@@ -7927,7 +7960,10 @@ cp_parser_template_argument_list (cp_parser* parser)\n   unsigned alloced = 10;\n   tree *arg_ary = fixed_args;\n   tree vec;\n+  bool saved_in_template_argument_list_p;\n \n+  saved_in_template_argument_list_p = parser->in_template_argument_list_p;\n+  parser->in_template_argument_list_p = true;\n   do\n     {\n       tree argument;\n@@ -7961,6 +7997,7 @@ cp_parser_template_argument_list (cp_parser* parser)\n   \n   if (arg_ary != fixed_args)\n     free (arg_ary);\n+  parser->in_template_argument_list_p = saved_in_template_argument_list_p;\n   return vec;\n }\n \n@@ -8207,7 +8244,8 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n       /* Parse the declarator.  */\n       declarator \n \t= cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n-\t\t\t\t/*ctor_dtor_or_conv_p=*/NULL);\n+\t\t\t\t/*ctor_dtor_or_conv_p=*/NULL,\n+\t\t\t\t/*parenthesized_p=*/NULL);\n       cp_parser_check_for_definition_in_return_type (declarator, \n \t\t\t\t\t\t     declares_class_or_enum);\n       decl = grokdeclarator (declarator, decl_specifiers, \n@@ -8548,12 +8586,7 @@ cp_parser_simple_type_specifier (cp_parser* parser, cp_parser_flags flags,\n \t}\n       /* Otherwise, look for a type-name.  */\n       else\n-\t{\n-\t  type = cp_parser_type_name (parser);\n-\t  if (type == error_mark_node)\n-\t    type = NULL_TREE;\n-\t}\n-\n+\ttype = cp_parser_type_name (parser);\n       /* If it didn't work out, we don't have a TYPE.  */\n       if ((flags & CP_PARSER_FLAGS_OPTIONAL) \n \t  && !cp_parser_parse_definitely (parser))\n@@ -8570,7 +8603,7 @@ cp_parser_simple_type_specifier (cp_parser* parser, cp_parser_flags flags,\n   /* There is no valid C++ program where a non-template type is\n      followed by a \"<\".  That usually indicates that the user thought\n      that the type was a template.  */\n-  if (type)\n+  if (type && type != error_mark_node)\n     cp_parser_check_for_invalid_template_id (parser, TREE_TYPE (type));\n \n   return type;\n@@ -8620,7 +8653,9 @@ cp_parser_type_name (cp_parser* parser)\n       /* Issue an error if we did not find a type-name.  */\n       if (TREE_CODE (type_decl) != TYPE_DECL)\n \t{\n-\t  cp_parser_error (parser, \"expected type-name\");\n+\t  if (!cp_parser_simulate_error (parser))\n+\t    cp_parser_name_lookup_error (parser, identifier, type_decl, \n+\t\t\t\t\t \"is not a type\");\n \t  type_decl = error_mark_node;\n \t}\n       /* Remember that the name was used in the definition of the\n@@ -9265,13 +9300,7 @@ cp_parser_using_declaration (cp_parser* parser)\n \t{\n \t  decl = cp_parser_lookup_name_simple (parser, identifier);\n \t  if (decl == error_mark_node)\n-\t    {\n-\t      if (parser->scope && parser->scope != global_namespace)\n-\t\terror (\"`%D::%D' has not been declared\", \n-\t\t       parser->scope, identifier);\n-\t      else\n-\t\terror (\"`::%D' has not been declared\", identifier);\n-\t    }\n+\t    cp_parser_name_lookup_error (parser, identifier, decl, NULL);\n \t  else if (scope)\n \t    do_local_using_decl (decl);\n \t  else\n@@ -9469,6 +9498,16 @@ cp_parser_asm_definition (cp_parser* parser)\n    init-declarator:\n      declarator asm-specification [opt] attributes [opt] initializer [opt]\n \n+   function-definition:\n+     decl-specifier-seq [opt] declarator ctor-initializer [opt]\n+       function-body \n+     decl-specifier-seq [opt] declarator function-try-block  \n+\n+   GNU Extension:\n+\n+   function-definition:\n+     __extension__ function-definition \n+\n    The DECL_SPECIFIERS and PREFIX_ATTRIBUTES apply to this declarator.\n    Returns a representation of the entity declared.  If MEMBER_P is TRUE,\n    then this declarator appears in a class scope.  The new DECL created\n@@ -9518,7 +9557,8 @@ cp_parser_init_declarator (cp_parser* parser,\n   /* Parse the declarator.  */\n   declarator \n     = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n-\t\t\t    &ctor_dtor_or_conv_p);\n+\t\t\t    &ctor_dtor_or_conv_p,\n+\t\t\t    /*parenthesized_p=*/NULL);\n   /* Gather up the deferred checks.  */\n   stop_deferring_access_checks ();\n \n@@ -9576,8 +9616,15 @@ cp_parser_init_declarator (cp_parser* parser,\n \t  *function_definition_p = true;\n \n \t  /* Parse the function definition.  */\n-\t  decl = (cp_parser_function_definition_from_specifiers_and_declarator\n-\t\t  (parser, decl_specifiers, prefix_attributes, declarator));\n+\t  if (member_p)\n+\t    decl = cp_parser_save_member_function_body (parser,\n+\t\t\t\t\t\t\tdecl_specifiers,\n+\t\t\t\t\t\t\tdeclarator,\n+\t\t\t\t\t\t\tprefix_attributes);\n+\t  else\n+\t    decl \n+\t      = (cp_parser_function_definition_from_specifiers_and_declarator\n+\t\t (parser, decl_specifiers, prefix_attributes, declarator));\n \n \t  return decl;\n \t}\n@@ -9780,12 +9827,16 @@ cp_parser_init_declarator (cp_parser* parser,\n    semantic analysis, rather than parsing, but that makes it difficult\n    to handle something like `f()'.  We want to notice that there are\n    no decl-specifiers, and therefore realize that this is an\n-   expression, not a declaration.)  */\n+   expression, not a declaration.)  \n+ \n+   If PARENTHESIZED_P is non-NULL, *PARENTHESIZED_P is set to true iff\n+   the declarator is a direct-declarator of the form \"(...)\".  */\n \n static tree\n cp_parser_declarator (cp_parser* parser, \n                       cp_parser_declarator_kind dcl_kind, \n-                      int* ctor_dtor_or_conv_p)\n+                      int* ctor_dtor_or_conv_p,\n+\t\t      bool* parenthesized_p)\n {\n   cp_token *token;\n   tree declarator;\n@@ -9814,14 +9865,19 @@ cp_parser_declarator (cp_parser* parser,\n   /* If that worked, then we have a ptr-operator.  */\n   if (cp_parser_parse_definitely (parser))\n     {\n+      /* If a ptr-operator was found, then this declarator was not\n+\t parenthesized.  */\n+      if (parenthesized_p)\n+\t*parenthesized_p = true;\n       /* The dependent declarator is optional if we are parsing an\n \t abstract-declarator.  */\n       if (dcl_kind != CP_PARSER_DECLARATOR_NAMED)\n \tcp_parser_parse_tentatively (parser);\n \n       /* Parse the dependent declarator.  */\n       declarator = cp_parser_declarator (parser, dcl_kind,\n-\t\t\t\t\t /*ctor_dtor_or_conv_p=*/NULL);\n+\t\t\t\t\t /*ctor_dtor_or_conv_p=*/NULL,\n+\t\t\t\t\t /*parenthesized_p=*/NULL);\n \n       /* If we are parsing an abstract-declarator, we must handle the\n \t case where the dependent declarator is absent.  */\n@@ -9842,8 +9898,13 @@ cp_parser_declarator (cp_parser* parser,\n     }\n   /* Everything else is a direct-declarator.  */\n   else\n-    declarator = cp_parser_direct_declarator (parser, dcl_kind,\n-\t\t\t\t\t      ctor_dtor_or_conv_p);\n+    {\n+      if (parenthesized_p)\n+\t*parenthesized_p = cp_lexer_next_token_is (parser->lexer,\n+\t\t\t\t\t\t   CPP_OPEN_PAREN);\n+      declarator = cp_parser_direct_declarator (parser, dcl_kind,\n+\t\t\t\t\t\tctor_dtor_or_conv_p);\n+    }\n \n   if (attributes && declarator != error_mark_node)\n     declarator = tree_cons (attributes, declarator, NULL_TREE);\n@@ -10017,7 +10078,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      cp_lexer_consume_token (parser->lexer);\n \t      /* Parse the nested declarator.  */\n \t      declarator \n-\t\t= cp_parser_declarator (parser, dcl_kind, ctor_dtor_or_conv_p);\n+\t\t= cp_parser_declarator (parser, dcl_kind, ctor_dtor_or_conv_p,\n+\t\t\t\t\t/*parenthesized_p=*/NULL);\n \t      first = false;\n \t      /* Expect a `)'.  */\n \t      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n@@ -10428,7 +10490,8 @@ cp_parser_type_id (cp_parser* parser)\n   cp_parser_parse_tentatively (parser);\n   /* Look for the declarator.  */\n   abstract_declarator \n-    = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_ABSTRACT, NULL);\n+    = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_ABSTRACT, NULL,\n+\t\t\t    /*parenthesized_p=*/NULL);\n   /* Check to see if there really was a declarator.  */\n   if (!cp_parser_parse_definitely (parser))\n     abstract_declarator = NULL_TREE;\n@@ -10604,9 +10667,12 @@ cp_parser_parameter_declaration_list (cp_parser* parser)\n   while (true)\n     {\n       tree parameter;\n+      bool parenthesized_p;\n       /* Parse the parameter.  */\n       parameter \n-\t= cp_parser_parameter_declaration (parser, /*template_parm_p=*/false);\n+\t= cp_parser_parameter_declaration (parser, \n+\t\t\t\t\t   /*template_parm_p=*/false,\n+\t\t\t\t\t   &parenthesized_p);\n \n       /* If a parse error occurred parsing the parameter declaration,\n \t then the entire parameter-declaration-list is erroneous.  */\n@@ -10636,10 +10702,37 @@ cp_parser_parameter_declaration_list (cp_parser* parser)\n \t  /* Otherwise, there must be more parameters.  Consume the\n \t     `,'.  */\n \t  cp_lexer_consume_token (parser->lexer);\n+\t  /* When parsing something like:\n+\n+\t        int i(float f, double d)\n+\t\t\n+             we can tell after seeing the declaration for \"f\" that we\n+\t     are not looking at an initialization of a variable \"i\",\n+\t     but rather at the declaration of a function \"i\".  \n+\n+\t     Due to the fact that the parsing of template arguments\n+\t     (as specified to a template-id) requires backtracking we\n+\t     cannot use this technique when inside a template argument\n+\t     list.  */\n+\t  if (!parser->in_template_argument_list_p\n+\t      && cp_parser_parsing_tentatively (parser)\n+\t      && !cp_parser_committed_to_tentative_parse (parser)\n+\t      /* However, a parameter-declaration of the form\n+\t\t \"foat(f)\" (which is a valid declaration of a\n+\t\t parameter \"f\") can also be interpreted as an\n+\t\t expression (the conversion of \"f\" to \"float\").  */\n+\t      && !parenthesized_p)\n+\t    cp_parser_commit_to_tentative_parse (parser);\n \t}\n       else\n \t{\n \t  cp_parser_error (parser, \"expected `,' or `...'\");\n+\t  if (!cp_parser_parsing_tentatively (parser)\n+\t      || cp_parser_committed_to_tentative_parse (parser))\n+\t    cp_parser_skip_to_closing_parenthesis (parser, \n+\t\t\t\t\t\t   /*recovering=*/true,\n+\t\t\t\t\t\t   /*or_comma=*/true,\n+\t\t\t\t\t\t   /*consume_paren=*/false);\n \t  break;\n \t}\n     }\n@@ -10662,14 +10755,18 @@ cp_parser_parameter_declaration_list (cp_parser* parser)\n    is not interpreted as a greater-than operator.)\n \n    Returns a TREE_LIST representing the parameter-declaration.  The\n-   TREE_VALUE is a representation of the decl-specifier-seq and\n-   declarator.  In particular, the TREE_VALUE will be a TREE_LIST\n-   whose TREE_PURPOSE represents the decl-specifier-seq and whose\n-   TREE_VALUE represents the declarator.  */\n+   TREE_PURPOSE is the default argument expression, or NULL_TREE if\n+   there is no default argument.  The TREE_VALUE is a representation\n+   of the decl-specifier-seq and declarator.  In particular, the\n+   TREE_VALUE will be a TREE_LIST whose TREE_PURPOSE represents the\n+   decl-specifier-seq and whose TREE_VALUE represents the declarator.\n+   If PARENTHESIZED_P is non-NULL, *PARENTHESIZED_P is set to true iff\n+   the declarator is of the form \"(p)\".  */\n \n static tree\n cp_parser_parameter_declaration (cp_parser *parser, \n-\t\t\t\t bool template_parm_p)\n+\t\t\t\t bool template_parm_p,\n+\t\t\t\t bool *parenthesized_p)\n {\n   int declares_class_or_enum;\n   bool greater_than_is_operator_p;\n@@ -10719,7 +10816,11 @@ cp_parser_parameter_declaration (cp_parser *parser,\n       || token->type == CPP_EQ\n       || token->type == CPP_ELLIPSIS\n       || token->type == CPP_GREATER)\n-    declarator = NULL_TREE;\n+    {\n+      declarator = NULL_TREE;\n+      if (parenthesized_p)\n+\t*parenthesized_p = false;\n+    }\n   /* Otherwise, there should be a declarator.  */\n   else\n     {\n@@ -10728,7 +10829,8 @@ cp_parser_parameter_declaration (cp_parser *parser,\n   \n       declarator = cp_parser_declarator (parser,\n \t\t\t\t\t CP_PARSER_DECLARATOR_EITHER,\n-\t\t\t\t\t /*ctor_dtor_or_conv_p=*/NULL);\n+\t\t\t\t\t /*ctor_dtor_or_conv_p=*/NULL,\n+\t\t\t\t\t parenthesized_p);\n       parser->default_arg_ok_p = saved_default_arg_ok_p;\n       /* After the declarator, allow more attributes.  */\n       attributes = chainon (attributes, cp_parser_attributes_opt (parser));\n@@ -10882,184 +10984,6 @@ cp_parser_parameter_declaration (cp_parser *parser,\n   return parameter;\n }\n \n-/* Parse a function-definition.  \n-\n-   function-definition:\n-     decl-specifier-seq [opt] declarator ctor-initializer [opt]\n-       function-body \n-     decl-specifier-seq [opt] declarator function-try-block  \n-\n-   GNU Extension:\n-\n-   function-definition:\n-     __extension__ function-definition \n-\n-   Returns the FUNCTION_DECL for the function.  If FRIEND_P is\n-   non-NULL, *FRIEND_P is set to TRUE iff the function was declared to\n-   be a `friend'.  */\n-\n-static tree\n-cp_parser_function_definition (cp_parser* parser, bool* friend_p)\n-{\n-  tree decl_specifiers;\n-  tree attributes;\n-  tree declarator;\n-  tree fn;\n-  cp_token *token;\n-  int declares_class_or_enum;\n-  bool member_p;\n-  /* The saved value of the PEDANTIC flag.  */\n-  int saved_pedantic;\n-\n-  /* Any pending qualification must be cleared by our caller.  It is\n-     more robust to force the callers to clear PARSER->SCOPE than to\n-     do it here since if the qualification is in effect here, it might\n-     also end up in effect elsewhere that it is not intended.  */\n-  my_friendly_assert (!parser->scope, 20010821);\n-\n-  /* Handle `__extension__'.  */\n-  if (cp_parser_extension_opt (parser, &saved_pedantic))\n-    {\n-      /* Parse the function-definition.  */\n-      fn = cp_parser_function_definition (parser, friend_p);\n-      /* Restore the PEDANTIC flag.  */\n-      pedantic = saved_pedantic;\n-\n-      return fn;\n-    }\n-\n-  /* Check to see if this definition appears in a class-specifier.  */\n-  member_p = (at_class_scope_p () \n-\t      && TYPE_BEING_DEFINED (current_class_type));\n-  /* Defer access checks in the decl-specifier-seq until we know what\n-     function is being defined.  There is no need to do this for the\n-     definition of member functions; we cannot be defining a member\n-     from another class.  */\n-  push_deferring_access_checks (member_p ? dk_no_check: dk_deferred);\n-\n-  /* Parse the decl-specifier-seq.  */\n-  decl_specifiers \n-    = cp_parser_decl_specifier_seq (parser,\n-\t\t\t\t    CP_PARSER_FLAGS_OPTIONAL,\n-\t\t\t\t    &attributes,\n-\t\t\t\t    &declares_class_or_enum);\n-  /* Figure out whether this declaration is a `friend'.  */\n-  if (friend_p)\n-    *friend_p = cp_parser_friend_p (decl_specifiers);\n-\n-  /* Parse the declarator.  */\n-  declarator = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n-\t\t\t\t     /*ctor_dtor_or_conv_p=*/NULL);\n-\n-  /* Gather up any access checks that occurred.  */\n-  stop_deferring_access_checks ();\n-\n-  /* If something has already gone wrong, we may as well stop now.  */\n-  if (declarator == error_mark_node)\n-    {\n-      /* Skip to the end of the function, or if this wasn't anything\n-\t like a function-definition, to a `;' in the hopes of finding\n-\t a sensible place from which to continue parsing.  */\n-      cp_parser_skip_to_end_of_block_or_statement (parser);\n-      pop_deferring_access_checks ();\n-      return error_mark_node;\n-    }\n-\n-  /* The next character should be a `{' (for a simple function\n-     definition), a `:' (for a ctor-initializer), or `try' (for a\n-     function-try block).  */\n-  token = cp_lexer_peek_token (parser->lexer);\n-  if (!cp_parser_token_starts_function_definition_p (token))\n-    {\n-      /* Issue the error-message.  */\n-      cp_parser_error (parser, \"expected function-definition\");\n-      /* Skip to the next `;'.  */\n-      cp_parser_skip_to_end_of_block_or_statement (parser);\n-\n-      pop_deferring_access_checks ();\n-      return error_mark_node;\n-    }\n-\n-  cp_parser_check_for_definition_in_return_type (declarator,\n-\t\t\t\t\t\t declares_class_or_enum);\n-\n-  /* If we are in a class scope, then we must handle\n-     function-definitions specially.  In particular, we save away the\n-     tokens that make up the function body, and parse them again\n-     later, in order to handle code like:\n-\n-       struct S {\n-         int f () { return i; }\n-\t int i;\n-       }; \n- \n-     Here, we cannot parse the body of `f' until after we have seen\n-     the declaration of `i'.  */\n-  if (member_p)\n-    {\n-      cp_token_cache *cache;\n-\n-      /* Create the function-declaration.  */\n-      fn = start_method (decl_specifiers, declarator, attributes);\n-      /* If something went badly wrong, bail out now.  */\n-      if (fn == error_mark_node)\n-\t{\n-\t  /* If there's a function-body, skip it.  */\n-\t  if (cp_parser_token_starts_function_definition_p \n-\t      (cp_lexer_peek_token (parser->lexer)))\n-\t    cp_parser_skip_to_end_of_block_or_statement (parser);\n-\t  pop_deferring_access_checks ();\n-\t  return error_mark_node;\n-\t}\n-\n-      /* Remember it, if there default args to post process.  */\n-      cp_parser_save_default_args (parser, fn);\n-      \n-      /* Create a token cache.  */\n-      cache = cp_token_cache_new ();\n-      /* Save away the tokens that make up the body of the \n-\t function.  */\n-      cp_parser_cache_group (parser, cache, CPP_CLOSE_BRACE, /*depth=*/0);\n-      /* Handle function try blocks.  */\n-      while (cp_lexer_next_token_is_keyword (parser->lexer, RID_CATCH))\n-\tcp_parser_cache_group (parser, cache, CPP_CLOSE_BRACE, /*depth=*/0);\n-\n-      /* Save away the inline definition; we will process it when the\n-\t class is complete.  */\n-      DECL_PENDING_INLINE_INFO (fn) = cache;\n-      DECL_PENDING_INLINE_P (fn) = 1;\n-\n-      /* We need to know that this was defined in the class, so that\n-\t friend templates are handled correctly.  */\n-      DECL_INITIALIZED_IN_CLASS_P (fn) = 1;\n-\n-      /* We're done with the inline definition.  */\n-      finish_method (fn);\n-\n-      /* Add FN to the queue of functions to be parsed later.  */\n-      TREE_VALUE (parser->unparsed_functions_queues)\n-\t= tree_cons (NULL_TREE, fn, \n-\t\t     TREE_VALUE (parser->unparsed_functions_queues));\n-\n-      pop_deferring_access_checks ();\n-      return fn;\n-    }\n-\n-  /* Check that the number of template-parameter-lists is OK.  */\n-  if (!cp_parser_check_declarator_template_parameters (parser, \n-\t\t\t\t\t\t       declarator))\n-    {\n-      cp_parser_skip_to_end_of_block_or_statement (parser);\n-      pop_deferring_access_checks ();\n-      return error_mark_node;\n-    }\n-\n-  fn = cp_parser_function_definition_from_specifiers_and_declarator\n-\t  (parser, decl_specifiers, attributes, declarator);\n-  pop_deferring_access_checks ();\n-  return fn;\n-}\n-\n /* Parse a function-body.\n \n    function-body:\n@@ -12035,10 +11959,6 @@ cp_parser_member_declaration (cp_parser* parser)\n       return;\n     }\n   \n-  /* We can't tell whether we're looking at a declaration or a\n-     function-definition.  */\n-  cp_parser_parse_tentatively (parser);\n-\n   /* Parse the decl-specifier-seq.  */\n   decl_specifiers \n     = cp_parser_decl_specifier_seq (parser,\n@@ -12205,15 +12125,24 @@ cp_parser_member_declaration (cp_parser* parser)\n \t      /* Parse the declarator.  */\n \t      declarator \n \t\t= cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n-\t\t\t\t\t&ctor_dtor_or_conv_p);\n+\t\t\t\t\t&ctor_dtor_or_conv_p,\n+\t\t\t\t\t/*parenthesized_p=*/NULL);\n \n \t      /* If something went wrong parsing the declarator, make sure\n \t\t that we at least consume some tokens.  */\n \t      if (declarator == error_mark_node)\n \t\t{\n \t\t  /* Skip to the end of the statement.  */\n \t\t  cp_parser_skip_to_end_of_statement (parser);\n-\t\t  break;\n+\t\t  /* If the next token is not a semicolon, that is\n+\t\t     probably because we just skipped over the body of\n+\t\t     a function.  So, we consume a semicolon if\n+\t\t     present, but do not issue an error message if it\n+\t\t     is not present.  */\n+\t\t  if (cp_lexer_next_token_is (parser->lexer,\n+\t\t\t\t\t      CPP_SEMICOLON))\n+\t\t    cp_lexer_consume_token (parser->lexer);\n+\t\t  return;\n \t\t}\n \n \t      cp_parser_check_for_definition_in_return_type \n@@ -12254,13 +12183,8 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t  if (TREE_CODE (declarator) == CALL_EXPR)\n \t\t    initializer = cp_parser_pure_specifier (parser);\n \t\t  else\n-\t\t    {\n-\t\t      /* This declaration cannot be a function\n-\t\t\t definition.  */\n-\t\t      cp_parser_commit_to_tentative_parse (parser);\n-\t\t      /* Parse the initializer.  */\n-\t\t      initializer = cp_parser_constant_initializer (parser);\n-\t\t    }\n+\t\t    /* Parse the initializer.  */\n+\t\t    initializer = cp_parser_constant_initializer (parser);\n \t\t}\n \t      /* Otherwise, there is no initializer.  */\n \t      else\n@@ -12273,7 +12197,28 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t that we are looking at a member-declarator.  */\n \t      if (cp_parser_token_starts_function_definition_p \n \t\t  (cp_lexer_peek_token (parser->lexer)))\n-\t\tdecl = error_mark_node;\n+\t\t{\n+\t\t  /* The grammar does not allow a pure-specifier to be\n+\t\t     used when a member function is defined.  (It is\n+\t\t     possible that this fact is an oversight in the\n+\t\t     standard, since a pure function may be defined\n+\t\t     outside of the class-specifier.  */\n+\t\t  if (initializer)\n+\t\t    error (\"pure-specifier on function-definition\");\n+\t\t  decl = cp_parser_save_member_function_body (parser,\n+\t\t\t\t\t\t\t      decl_specifiers,\n+\t\t\t\t\t\t\t      declarator,\n+\t\t\t\t\t\t\t      attributes);\n+\t\t  /* If the member was not a friend, declare it here.  */\n+\t\t  if (!friend_p)\n+\t\t    finish_member_declaration (decl);\n+\t\t  /* Peek at the next token.  */\n+\t\t  token = cp_lexer_peek_token (parser->lexer);\n+\t\t  /* If the next token is a semicolon, consume it.  */\n+\t\t  if (token->type == CPP_SEMICOLON)\n+\t\t    cp_lexer_consume_token (parser->lexer);\n+\t\t  return;\n+\t\t}\n \t      else\n \t\t{\n \t\t  /* Create the declaration.  */\n@@ -12324,23 +12269,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t}\n     }\n \n-  /* If everything went well, look for the `;'.  */\n-  if (cp_parser_parse_definitely (parser))\n-    {\n-      cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n-      return;\n-    }\n-\n-  /* Parse the function-definition.  */\n-  decl = cp_parser_function_definition (parser,\t&friend_p);\n-  /* If the member was not a friend, declare it here.  */\n-  if (!friend_p)\n-    finish_member_declaration (decl);\n-  /* Peek at the next token.  */\n-  token = cp_lexer_peek_token (parser->lexer);\n-  /* If the next token is a semicolon, consume it.  */\n-  if (token->type == CPP_SEMICOLON)\n-    cp_lexer_consume_token (parser->lexer);\n+  cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n }\n \n /* Parse a pure-specifier.\n@@ -12800,7 +12729,8 @@ cp_parser_exception_declaration (cp_parser* parser)\n     declarator = NULL_TREE;\n   else\n     declarator = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_EITHER,\n-\t\t\t\t       /*ctor_dtor_or_conv_p=*/NULL);\n+\t\t\t\t       /*ctor_dtor_or_conv_p=*/NULL,\n+\t\t\t\t       /*parenthesized_p=*/NULL);\n \n   /* Restore the saved message.  */\n   parser->type_definition_forbidden_message = saved_message;\n@@ -13976,10 +13906,8 @@ cp_parser_single_declaration (cp_parser* parser,\n   tree decl = NULL_TREE;\n   tree decl_specifiers;\n   tree attributes;\n+  bool function_definition_p = false;\n \n-  /* Parse the dependent declaration.  We don't know yet\n-     whether it will be a function-definition.  */\n-  cp_parser_parse_tentatively (parser);\n   /* Defer access checks until we know what is being declared.  */\n   push_deferring_access_checks (dk_deferred);\n \n@@ -13990,6 +13918,8 @@ cp_parser_single_declaration (cp_parser* parser,\n \t\t\t\t    CP_PARSER_FLAGS_OPTIONAL,\n \t\t\t\t    &attributes,\n \t\t\t\t    &declares_class_or_enum);\n+  if (friend_p)\n+    *friend_p = cp_parser_friend_p (decl_specifiers);\n   /* Gather up the access checks that occurred the\n      decl-specifier-seq.  */\n   stop_deferring_access_checks ();\n@@ -14019,10 +13949,10 @@ cp_parser_single_declaration (cp_parser* parser,\n     decl = cp_parser_init_declarator (parser, \n \t\t\t\t      decl_specifiers,\n \t\t\t\t      attributes,\n-\t\t\t\t      /*function_definition_allowed_p=*/false,\n+\t\t\t\t      /*function_definition_allowed_p=*/true,\n \t\t\t\t      member_p,\n \t\t\t\t      declares_class_or_enum,\n-\t\t\t\t      /*function_definition_p=*/NULL);\n+\t\t\t\t      &function_definition_p);\n \n   pop_deferring_access_checks ();\n \n@@ -14032,18 +13962,9 @@ cp_parser_single_declaration (cp_parser* parser,\n   parser->qualifying_scope = NULL_TREE;\n   parser->object_scope = NULL_TREE;\n   /* Look for a trailing `;' after the declaration.  */\n-  if (!cp_parser_require (parser, CPP_SEMICOLON, \"`;'\")\n-      && cp_parser_committed_to_tentative_parse (parser))\n+  if (!function_definition_p\n+      && !cp_parser_require (parser, CPP_SEMICOLON, \"`;'\"))\n     cp_parser_skip_to_end_of_block_or_statement (parser);\n-  /* If it worked, set *FRIEND_P based on the DECL_SPECIFIERS.  */\n-  if (cp_parser_parse_definitely (parser))\n-    {\n-      if (friend_p)\n-\t*friend_p = cp_parser_friend_p (decl_specifiers);\n-    }\n-  /* Otherwise, try a function-definition.  */\n-  else\n-    decl = cp_parser_function_definition (parser, friend_p);\n \n   return decl;\n }\n@@ -14071,6 +13992,65 @@ cp_parser_functional_cast (cp_parser* parser, tree type)\n   return build_functional_cast (type, expression_list);\n }\n \n+/* Save the tokens that make up the body of a member function defined\n+   in a class-specifier.  The DECL_SPECIFIERS and DECLARATOR have\n+   already been parsed.  The ATTRIBUTES are any GNU \"__attribute__\"\n+   specifiers applied to the declaration.  Returns the FUNCTION_DECL\n+   for the member function.  */\n+\n+tree\n+cp_parser_save_member_function_body (cp_parser* parser,\n+\t\t\t\t     tree decl_specifiers,\n+\t\t\t\t     tree declarator,\n+\t\t\t\t     tree attributes)\n+{\n+  cp_token_cache *cache;\n+  tree fn;\n+\n+  /* Create the function-declaration.  */\n+  fn = start_method (decl_specifiers, declarator, attributes);\n+  /* If something went badly wrong, bail out now.  */\n+  if (fn == error_mark_node)\n+    {\n+      /* If there's a function-body, skip it.  */\n+      if (cp_parser_token_starts_function_definition_p \n+\t  (cp_lexer_peek_token (parser->lexer)))\n+\tcp_parser_skip_to_end_of_block_or_statement (parser);\n+      return error_mark_node;\n+    }\n+\n+  /* Remember it, if there default args to post process.  */\n+  cp_parser_save_default_args (parser, fn);\n+\n+  /* Create a token cache.  */\n+  cache = cp_token_cache_new ();\n+  /* Save away the tokens that make up the body of the \n+     function.  */\n+  cp_parser_cache_group (parser, cache, CPP_CLOSE_BRACE, /*depth=*/0);\n+  /* Handle function try blocks.  */\n+  while (cp_lexer_next_token_is_keyword (parser->lexer, RID_CATCH))\n+    cp_parser_cache_group (parser, cache, CPP_CLOSE_BRACE, /*depth=*/0);\n+\n+  /* Save away the inline definition; we will process it when the\n+     class is complete.  */\n+  DECL_PENDING_INLINE_INFO (fn) = cache;\n+  DECL_PENDING_INLINE_P (fn) = 1;\n+\n+  /* We need to know that this was defined in the class, so that\n+     friend templates are handled correctly.  */\n+  DECL_INITIALIZED_IN_CLASS_P (fn) = 1;\n+\n+  /* We're done with the inline definition.  */\n+  finish_method (fn);\n+\n+  /* Add FN to the queue of functions to be parsed later.  */\n+  TREE_VALUE (parser->unparsed_functions_queues)\n+    = tree_cons (NULL_TREE, fn, \n+\t\t TREE_VALUE (parser->unparsed_functions_queues));\n+\n+  return fn;\n+}\n+\n /* Parse a template-argument-list, as well as the trailing \">\" (but\n    not the opening \">\").  See cp_parser_template_argument_list for the\n    return value.  */\n@@ -14115,7 +14095,6 @@ cp_parser_enclosed_template_argument_list (cp_parser* parser)\n   return arguments;\n }\n \n-\n /* MEMBER_FUNCTION is a member function, or a friend.  If default\n    arguments, or the body of the function have not yet been parsed,\n    parse them now.  */"}, {"sha": "ee586f53282e620200bf48fdf7bba0d598ccc72e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4bb8ca281f0fb91d296116d2b7496b216c7c1bb3", "patch": "@@ -1,3 +1,20 @@\n+2003-12-14  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/10779\n+\tPR c++/12160\n+\t* g++.dg/parse/error3.C: New test.\n+\t* g++.dg/parse/error4.C: Likewise.\n+\t* g++.dg/abi/mangle4.C: Tweak error messages.\n+\t* g++.dg/lookup/using5.C: Likewise.\n+\t* g++.dg/other/error2.C: Likewise.\n+\t* g++.dg/parse/typename5.C: Likewise.\n+\t* g++.dg/parse/undefined1.C: Likewise.\n+\t* g++.dg/template/arg2.C: Likewise.\n+\t* g++.dg/template/ttp3.C: Likewise.\n+\t* g++.dg/template/type1.C: Likewise.\n+\t* g++.old-deja/g++.other/crash32.C: Likewise.\n+\t* g++.old-djea/g++.pt/defarg8.C: Likewise.\n+\t\n 2003-12-14  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/13106"}, {"sha": "3ce224716db5be5763d86215f19bd0d2df11007d", "filename": "gcc/testsuite/g++.dg/abi/mangle4.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle4.C?ref=4bb8ca281f0fb91d296116d2b7496b216c7c1bb3", "patch": "@@ -18,7 +18,7 @@ int main()\n   C<static_cast<const A*>(&b)> c; // { dg-error \"\" }\n   D<&b> d;\n   E<const_cast<B*>(&b)> e; // { dg-error \"\" }\n-  f(d, c); // { dg-error \"\" }\n-  g(d, e); // { dg-error \"\" }\n+  f(d, c);\n+  g(d, e);\n }\n "}, {"sha": "b443b97742f2d73f0292be99538568117dee414a", "filename": "gcc/testsuite/g++.dg/lookup/using5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing5.C?ref=4bb8ca281f0fb91d296116d2b7496b216c7c1bb3", "patch": "@@ -13,5 +13,5 @@ template <typename> struct A\n \n template <typename T> struct B : A<T>\n {\n-    using X::foo; // { dg-error \"not a class-name|nested-name-specifier|non-member\" }\n+    using X::foo; // { dg-error \"declared|nested-name-specifier|non-member\" }\n };"}, {"sha": "ea6c5203ecbb48c884b4995ac8b1bbbcb87ab3cc", "filename": "gcc/testsuite/g++.dg/other/error2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror2.C?ref=4bb8ca281f0fb91d296116d2b7496b216c7c1bb3", "patch": "@@ -10,5 +10,5 @@ namespace N\n   class B { friend void operator>>(int, class B); };\n   class N { friend void operator>>(int,class N); };\n } \n-void N::operator>>(int, N::B)  // { dg-error \"`B' is not a member of|non-function|primary-expression\" \"\" }\n+void N::operator>>(int, N::B)  // { dg-error \"N::N::B\" }\n { } // { dg-error \"\" \"\" }"}, {"sha": "57b7896675a6293277594e2c6158ca9cd9bc416a", "filename": "gcc/testsuite/g++.dg/parse/error3.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror3.C?ref=4bb8ca281f0fb91d296116d2b7496b216c7c1bb3", "patch": "@@ -0,0 +1,6 @@\n+// PR c++/10779\n+\n+static void InstantiateConstraint(const float&, unsigned,\n+                                  void(*AddFunction)(const TYPE&,bool&, // { dg-error \"\" }\n+                                                     char*, char*,\n+                                                     unsigned*));"}, {"sha": "511209d9ab99ea74d5c4b101708227ee2d0f7f36", "filename": "gcc/testsuite/g++.dg/parse/error4.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror4.C?ref=4bb8ca281f0fb91d296116d2b7496b216c7c1bb3", "patch": "@@ -0,0 +1,7 @@\n+// PR c++/12160\n+\n+struct X { \n+  virtual void f(int, \n+\t\t itn,        // { dg-error \"declared\" }\n+\t\t int);       // { dg-error \"\" }\n+}; "}, {"sha": "6b2ed894a86d5bf735fa6da15aa12fc1b7fa5644", "filename": "gcc/testsuite/g++.dg/parse/typename5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypename5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypename5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypename5.C?ref=4bb8ca281f0fb91d296116d2b7496b216c7c1bb3", "patch": "@@ -8,5 +8,5 @@ template <typename> struct A {};\n \n template <typename> struct B\n {\n-    typedef A<typename X::Y> C; // { dg-error \"not a class-name|invalid|no type\" }\n+    typedef A<typename X::Y> C; // { dg-error \"declared|invalid|no type\" }\n };"}, {"sha": "0ae4e88777c70c277e44d88234a1d57f34e1fb37", "filename": "gcc/testsuite/g++.dg/parse/undefined1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fundefined1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fundefined1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fundefined1.C?ref=4bb8ca281f0fb91d296116d2b7496b216c7c1bb3", "patch": "@@ -7,4 +7,4 @@ struct foo\n \n     foo(X)              {} // { dg-error \"\" }\n     foo(X y, int) : x() {} // { dg-error \"\" }\n-};                         // { dg-error \"\" }\n+};"}, {"sha": "dbed54d2131cc6999afb73aba835c56eb0fe376e", "filename": "gcc/testsuite/g++.dg/template/arg2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farg2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farg2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farg2.C?ref=4bb8ca281f0fb91d296116d2b7496b216c7c1bb3", "patch": "@@ -10,5 +10,5 @@ template <typename T> class X {};\n void fn ()\n {\n   class L {};\n-  X<L> f; // { dg-error \"uses local type|trying to instantiate|expected\" \"\" }\n+  X<L> f; // { dg-error \"uses local type|trying to instantiate|no type\" \"\" }\n }"}, {"sha": "a7f231a7fb0acb01c1b84e3365be8adfca63921d", "filename": "gcc/testsuite/g++.dg/template/ttp3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fttp3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fttp3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fttp3.C?ref=4bb8ca281f0fb91d296116d2b7496b216c7c1bb3", "patch": "@@ -23,4 +23,4 @@ class List { };\n // This next line should just do a lookup of 'class List', and then\n // get a type/value mismatch. Instead we try and push 'class List'\n // into the global namespace and get a redeclaration error.\n-vector<class List > data;\t// { dg-error \"invalid|required|expected\" \"\" }\n+vector<class List > data;\t// { dg-error \"invalid|required|declaration\" \"\" }"}, {"sha": "b74d975ac49a44d3634edd2130549ab5e9a5d62e", "filename": "gcc/testsuite/g++.dg/template/type1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftype1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftype1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftype1.C?ref=4bb8ca281f0fb91d296116d2b7496b216c7c1bb3", "patch": "@@ -5,4 +5,4 @@ struct A {\n };\n \n int A::B::c;\t\t\t// { dg-error \"parameters\" }\n-int A::C::d;\t\t\t// { dg-error \"class\" }\n+int A::C::d;\t\t\t// { dg-error \"declared\" }"}, {"sha": "b9c4cf98c0652301f31da8e851dcec22f069b33e", "filename": "gcc/testsuite/g++.old-deja/g++.other/crash32.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash32.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash32.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash32.C?ref=4bb8ca281f0fb91d296116d2b7496b216c7c1bb3", "patch": "@@ -6,7 +6,7 @@ struct foo\n   enum e\n   {\n     not\t\t\t\t// { dg-error \"\" } \n-  }; // { dg-bogus \"\" \"\" { xfail *-*-* } } \n+  }; // { dg-bogus \"\" } \n   ~foo(); // { dg-bogus \"\" \"\" { xfail *-*-* } } \n   void x (foo *&a, bool b = (unsigned char)0);\n }; // { dg-bogus \"\" \"\" { xfail *-*-* } } "}, {"sha": "239672dec433e60f8dc71a215e66a88798a05144", "filename": "gcc/testsuite/g++.old-deja/g++.pt/defarg8.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdefarg8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bb8ca281f0fb91d296116d2b7496b216c7c1bb3/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdefarg8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdefarg8.C?ref=4bb8ca281f0fb91d296116d2b7496b216c7c1bb3", "patch": "@@ -7,11 +7,11 @@\n // so)\n \n template <class T> class foo1;\n-template <class T, class U> class foo2;\n+template <class T, class U> class foo2; // { dg-error \"\" }\n \n struct bar {\n   template <class T, class U>\n-  bar(int i = foo1<T>::baz, // { dg-bogus \"\" \"\" { xfail *-*-* } }  - \n+  bar(int i = foo1<T>::baz, // { dg-bogus \"\" }  - \n       int j = int(foo2<T, U>::baz), // ok\n-      int k = foo2<T, U>::baz) {} // this is the problematic one.\n+      int k = foo2<T, U>::baz) {} // { dg-error \"\" }\n };"}]}