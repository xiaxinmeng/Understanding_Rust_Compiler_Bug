{"sha": "d96db15967e78d7cecea3b1cf3169ceb924678ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk2ZGIxNTk2N2U3OGQ3Y2VjZWEzYjFjZjMxNjljZWI5MjQ2NzhhYw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-04-28T16:46:01Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-04-28T16:56:50Z"}, "message": "libstdc++: Deprecate non-standard std::pair constructors [PR 99957]\n\nThis deprecates the non-standard std::pair constructors that support\nconstruction from an rvalue and a literal zero used as a null pointer\nconstant. We can't just add the deprecated attribute to those\nconstructors, because they're currently used by correct code when they\nare a better match than the constructors required by the standard e.g.\n\n  int i = 0;\n  const int j = 0;\n  std::pair<int, int> p(i, j); // uses pair(U1&&, const int&)\n\nThis patch adjusts the parameter types and constraints of those\nconstructors so that they only get used for literal zeros, and the\npair(U1&&, U2&&) constructor gets used otherwise. Once they're only used\nfor initializations that should be ill-formed we can add the deprecated\nattribute.\n\nThe deprecated attribute is used to suggest that the user code uses\nnullptr, which avoids the problem of 0 deducing as int instead of a null\npointer constant.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/99957\n\t* include/bits/stl_pair.h (_PCC::_MoveCopyPair, _PCC::_CopyMovePair):\n\tCombine and replace with ...\n\t(_PCC::_DeprConsPair): New SFINAE helper function.\n\t(pair): Merge preprocessor blocks so that all C++03 members\n\tare defined together at the end.\n\t(pair::pair(const _T1&, _U2&&), pair::pair(_U1&&, const _T2&)):\n\tReplace _T1 and _T2 parameters with __null_ptr_constant and\n\tadjust constraints.\n\t* testsuite/20_util/pair/40925.cc: Use nullptr instead of 0.\n\t* testsuite/20_util/pair/cons/explicit_construct.cc: Likewise.\n\t* testsuite/20_util/pair/cons/99957.cc: New test.", "tree": {"sha": "4d6dd96a448af957090569668408642b8a2ad7c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d6dd96a448af957090569668408642b8a2ad7c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d96db15967e78d7cecea3b1cf3169ceb924678ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d96db15967e78d7cecea3b1cf3169ceb924678ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d96db15967e78d7cecea3b1cf3169ceb924678ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d96db15967e78d7cecea3b1cf3169ceb924678ac/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "668df9e769e7d89bcefa07f72b68dcae9a8f3970", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/668df9e769e7d89bcefa07f72b68dcae9a8f3970", "html_url": "https://github.com/Rust-GCC/gccrs/commit/668df9e769e7d89bcefa07f72b68dcae9a8f3970"}], "stats": {"total": 201, "additions": 124, "deletions": 77}, "files": [{"sha": "883d7441b3d28b1cf3f498949e290e2eef7a4d82", "filename": "libstdc++-v3/include/bits/stl_pair.h", "status": "modified", "additions": 84, "deletions": 67, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d96db15967e78d7cecea3b1cf3169ceb924678ac/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d96db15967e78d7cecea3b1cf3169ceb924678ac/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h?ref=d96db15967e78d7cecea3b1cf3169ceb924678ac", "patch": "@@ -128,34 +128,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t      is_convertible<_U2&&, _T2>>::value;\n       }\n \n-      template <bool __implicit, typename _U1, typename _U2>\n-      static constexpr bool _CopyMovePair()\n-      {\n-\tusing __do_converts = __and_<is_convertible<const _U1&, _T1>,\n-\t\t\t\t  is_convertible<_U2&&, _T2>>;\n-\tusing __converts = typename conditional<__implicit,\n-\t\t\t\t       __do_converts,\n-\t\t\t\t       __not_<__do_converts>>::type;\n-\treturn __and_<is_constructible<_T1, const _U1&>,\n-\t\t      is_constructible<_T2, _U2&&>,\n-\t\t      __converts\n-\t\t      >::value;\n-      }\n \n       template <bool __implicit, typename _U1, typename _U2>\n-      static constexpr bool _MoveCopyPair()\n+      static constexpr bool _DeprConsPair()\n       {\n \tusing __do_converts = __and_<is_convertible<_U1&&, _T1>,\n-\t\t\t\t  is_convertible<const _U2&, _T2>>;\n+\t\t\t\t     is_convertible<_U2&&, _T2>>;\n \tusing __converts = typename conditional<__implicit,\n-\t\t\t\t       __do_converts,\n-\t\t\t\t       __not_<__do_converts>>::type;\n+\t\t\t\t\t\t__do_converts,\n+\t\t\t\t\t\t__not_<__do_converts>>::type;\n \treturn __and_<is_constructible<_T1, _U1&&>,\n-\t\t      is_constructible<_T2, const _U2&&>,\n+\t\t      is_constructible<_T2, _U2&&>,\n \t\t      __converts\n-\t\t      >::value;\n+\t\t     >::value;\n       }\n-  };\n+    };\n \n   template <typename _T1, typename _T2>\n     struct _PCC<false, _T1, _T2>\n@@ -183,7 +170,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       {\n \treturn false;\n       }\n-  };\n+    };\n #endif // C++11\n \n   template<typename _U1, typename _U2> class __pair_base\n@@ -217,22 +204,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _T1 first;                 ///< The first member\n       _T2 second;                ///< The second member\n \n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 265.  std::pair::pair() effects overly restrictive\n+#if __cplusplus >= 201103L\n+      // C++11 (and later) implementation.\n+\n       /** The default constructor creates @c first and @c second using their\n        *  respective default constructors.  */\n-#if __cplusplus >= 201103L\n       template <typename _U1 = _T1,\n                 typename _U2 = _T2,\n                 typename enable_if<__and_<\n                                      __is_implicitly_default_constructible<_U1>,\n                                      __is_implicitly_default_constructible<_U2>>\n                                    ::value, bool>::type = true>\n-#endif\n-      _GLIBCXX_CONSTEXPR pair()\n+      constexpr pair()\n       : first(), second() { }\n \n-#if __cplusplus >= 201103L\n       template <typename _U1 = _T1,\n                 typename _U2 = _T2,\n                 typename enable_if<__and_<\n@@ -244,13 +229,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                                    ::value, bool>::type = false>\n       explicit constexpr pair()\n       : first(), second() { }\n-#endif\n \n-#if __cplusplus < 201103L\n-      /// Two objects may be passed to a @c pair constructor to be copied.\n-      pair(const _T1& __a, const _T2& __b)\n-      : first(__a), second(__b) { }\n-#else\n       // Shortcut for constraining the templates that don't take pairs.\n       /// @cond undocumented\n       using _PCCP = _PCC<true, _T1, _T2>;\n@@ -275,14 +254,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                          bool>::type=false>\n       explicit constexpr pair(const _T1& __a, const _T2& __b)\n       : first(__a), second(__b) { }\n-#endif\n \n-#if __cplusplus < 201103L\n-      /// There is also a templated constructor to convert from other pairs.\n-      template<typename _U1, typename _U2>\n-\tpair(const pair<_U1, _U2>& __p)\n-\t: first(__p.first), second(__p.second) { }\n-#else\n       // Shortcut for constraining the templates that take pairs.\n       /// @cond undocumented\n       template <typename _U1, typename _U2>\n@@ -308,40 +280,68 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                          bool>::type=false>\n \texplicit constexpr pair(const pair<_U1, _U2>& __p)\n \t: first(__p.first), second(__p.second) { }\n-#endif\n \n-#if __cplusplus >= 201103L\n       constexpr pair(const pair&) = default;\t///< Copy constructor\n       constexpr pair(pair&&) = default;\t\t///< Move constructor\n \n-      // DR 811.\n-      template<typename _U1, typename\n-\t       enable_if<_PCCP::template\n-\t\t\t   _MoveCopyPair<true, _U1, _T2>(),\n-                         bool>::type=true>\n-       constexpr pair(_U1&& __x, const _T2& __y)\n-       : first(std::forward<_U1>(__x)), second(__y) { }\n+#if _GLIBCXX_USE_DEPRECATED\n+    private:\n+      /// @cond undocumented\n \n-      template<typename _U1, typename\n-\t       enable_if<_PCCP::template\n-\t\t\t   _MoveCopyPair<false, _U1, _T2>(),\n-                         bool>::type=false>\n-       explicit constexpr pair(_U1&& __x, const _T2& __y)\n-       : first(std::forward<_U1>(__x)), second(__y) { }\n+      // A type which can be constructed from literal zero, but not nullptr\n+      struct __null_ptr_constant\n+      {\n+\t__null_ptr_constant(int __null_ptr_constant::*) { }\n+\ttemplate<typename _Tp,\n+\t\t typename = __enable_if_t<is_null_pointer<_Tp>::value>>\n+\t__null_ptr_constant(_Tp) = delete;\n+      };\n \n-      template<typename _U2, typename\n-\t       enable_if<_PCCP::template\n-\t\t\t   _CopyMovePair<true, _T1, _U2>(),\n-                         bool>::type=true>\n-       constexpr pair(const _T1& __x, _U2&& __y)\n-       : first(__x), second(std::forward<_U2>(__y)) { }\n+      // True if type _Up is one of _Tp& or const _Tp&\n+      template<typename _Up, typename _Tp>\n+\tusing __is_lvalue_of\n+\t  = __or_<is_same<_Up, const _Tp&>, is_same<_Up, _Tp&>>;\n \n-      template<typename _U2, typename\n-\t       enable_if<_PCCP::template\n-\t\t\t   _CopyMovePair<false, _T1, _U2>(),\n-                         bool>::type=false>\n-       explicit pair(const _T1& __x, _U2&& __y)\n-       : first(__x), second(std::forward<_U2>(__y)) { }\n+      /// @endcond\n+    public:\n+\n+      // Deprecated extensions to DR 811.\n+      template<typename _U1,\n+\t       __enable_if_t<!__is_lvalue_of<_U1, _T1>::value\n+\t\t\t     && _PCCP::template\n+\t\t\t       _DeprConsPair<true, _U1, nullptr_t>(),\n+\t\t\t     bool> = true>\n+       _GLIBCXX_DEPRECATED_SUGGEST(\"nullptr\")\n+       constexpr pair(_U1&& __x, __null_ptr_constant)\n+       : first(std::forward<_U1>(__x)), second(nullptr) { }\n+\n+      template<typename _U1,\n+\t       __enable_if_t<!__is_lvalue_of<_U1, _T1>::value\n+\t\t\t     && _PCCP::template\n+\t\t\t       _DeprConsPair<false, _U1, nullptr_t>(),\n+\t\t\t     bool> = false>\n+       _GLIBCXX_DEPRECATED_SUGGEST(\"nullptr\")\n+       explicit constexpr pair(_U1&& __x, __null_ptr_constant)\n+       : first(std::forward<_U1>(__x)), second(nullptr) { }\n+\n+      template<typename _U2,\n+\t       __enable_if_t<!__is_lvalue_of<_U2, _T2>::value\n+\t\t\t     && _PCCP::template\n+\t\t\t       _DeprConsPair<true, nullptr_t, _U2>(),\n+\t\t\t     bool> = true>\n+       _GLIBCXX_DEPRECATED_SUGGEST(\"nullptr\")\n+       constexpr pair(__null_ptr_constant, _U2&& __y)\n+       : first(nullptr), second(std::forward<_U2>(__y)) { }\n+\n+      template<typename _U2,\n+\t       __enable_if_t<!__is_lvalue_of<_U2, _T2>::value\n+\t\t\t     && _PCCP::template\n+\t\t\t       _DeprConsPair<false, nullptr_t, _U2>(),\n+\t\t\t     bool> = false>\n+       _GLIBCXX_DEPRECATED_SUGGEST(\"nullptr\")\n+       explicit pair(__null_ptr_constant, _U2&& __y)\n+       : first(nullptr), second(std::forward<_U2>(__y)) { }\n+#endif // _GLIBCXX_USE_DEPRECATED\n \n       template<typename _U1, typename _U2, typename\n \t       enable_if<_PCCP::template\n@@ -451,6 +451,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_GLIBCXX20_CONSTEXPR\n         pair(tuple<_Args1...>&, tuple<_Args2...>&,\n \t     _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);\n+#else\n+      // C++03 implementation\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 265.  std::pair::pair() effects overly restrictive\n+      /** The default constructor creates @c first and @c second using their\n+       *  respective default constructors.  */\n+      pair() : first(), second() { }\n+\n+      /// Two objects may be passed to a `pair` constructor to be copied.\n+      pair(const _T1& __a, const _T2& __b)\n+      : first(__a), second(__b) { }\n+\n+      /// Templated constructor to convert from other pairs.\n+      template<typename _U1, typename _U2>\n+\tpair(const pair<_U1, _U2>& __p)\n+\t: first(__p.first), second(__p.second) { }\n #endif // C++11\n     };\n "}, {"sha": "c95cb380b18ff4b9d8d926c595d254367b0a6bd9", "filename": "libstdc++-v3/testsuite/20_util/pair/40925.cc", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d96db15967e78d7cecea3b1cf3169ceb924678ac/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2F40925.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d96db15967e78d7cecea3b1cf3169ceb924678ac/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2F40925.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2F40925.cc?ref=d96db15967e78d7cecea3b1cf3169ceb924678ac", "patch": "@@ -20,7 +20,7 @@\n #include <utility>\n \n struct X\n-{ \n+{\n   explicit X(int, int) { }\n \n private:\n@@ -36,7 +36,7 @@ struct move_only\n   move_only(const move_only&) = delete;\n };\n \n-// libstdc++/40925\n+// libstdc++/40925 and LWG 811\n void test01()\n {\n   int *ip = 0;\n@@ -52,10 +52,12 @@ void test01()\n   std::pair<int X::*, int X::*> p7(0, mp);\n   std::pair<int X::*, int X::*> p8(mp, mp);\n \n-  std::pair<int*, move_only> p9(0, move_only());\n-  std::pair<int X::*, move_only> p10(0, move_only());\n-  std::pair<move_only, int*> p11(move_only(), 0);\n-  std::pair<move_only, int X::*> p12(move_only(), 0);\n+  // LWG 811 resolution doesn't support move-only types,\n+  // so we have to use nullptr here not a literal 0.\n+  std::pair<int*, move_only> p9(nullptr, move_only());\n+  std::pair<int X::*, move_only> p10(nullptr, move_only());\n+  std::pair<move_only, int*> p11(move_only(), nullptr);\n+  std::pair<move_only, int X::*> p12(move_only(), nullptr);\n \n   std::pair<int*, move_only> p13(ip, move_only());\n   std::pair<int X::*, move_only> p14(mp, move_only());"}, {"sha": "d75ff21da60be657f98be286466c6b8a685a0868", "filename": "libstdc++-v3/testsuite/20_util/pair/cons/99957.cc", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d96db15967e78d7cecea3b1cf3169ceb924678ac/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fcons%2F99957.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d96db15967e78d7cecea3b1cf3169ceb924678ac/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fcons%2F99957.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fcons%2F99957.cc?ref=d96db15967e78d7cecea3b1cf3169ceb924678ac", "patch": "@@ -0,0 +1,28 @@\n+// { dg-options \"-Wdeprecated\" }\n+// { dg-do compile { target c++11 } }\n+\n+#include <utility>\n+\n+using std::pair;\n+\n+struct MoveOnly\n+{\n+  MoveOnly() = default;\n+  MoveOnly(MoveOnly&&) {}\n+};\n+\n+struct ExplicitMoveOnly\n+{\n+  ExplicitMoveOnly() = default;\n+  ExplicitMoveOnly(ExplicitMoveOnly&&) {}\n+  explicit ExplicitMoveOnly(MoveOnly&&) {}\n+};\n+\n+// PR libstdc++/99957\n+// check non-standard constructors are deprecated\n+\n+pair<int*, ExplicitMoveOnly> v14{0, MoveOnly{}}; // { dg-warning \"deprecated\" }\n+pair<ExplicitMoveOnly, int*> v15{MoveOnly{}, 0}; // { dg-warning \"deprecated\" }\n+\n+pair<int*, MoveOnly> v16 = {0, MoveOnly{}}; // { dg-warning \"deprecated\" }\n+pair<MoveOnly, int*> v17 = {MoveOnly{}, 0}; // { dg-warning \"deprecated\" }"}, {"sha": "508ca32ecb7b1bc34540ef832209c201adb952ea", "filename": "libstdc++-v3/testsuite/20_util/pair/cons/explicit_construct.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d96db15967e78d7cecea3b1cf3169ceb924678ac/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fcons%2Fexplicit_construct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d96db15967e78d7cecea3b1cf3169ceb924678ac/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fcons%2Fexplicit_construct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fcons%2Fexplicit_construct.cc?ref=d96db15967e78d7cecea3b1cf3169ceb924678ac", "patch": "@@ -126,10 +126,10 @@ struct ExplicitMoveOnly\n   explicit ExplicitMoveOnly(MoveOnly&&) {}\n };\n \n-std::pair<int*, ExplicitMoveOnly> v14{0, MoveOnly{}};\n-std::pair<ExplicitMoveOnly, int*> v15{MoveOnly{}, 0};\n+std::pair<int*, ExplicitMoveOnly> v14{nullptr, MoveOnly{}};\n+std::pair<ExplicitMoveOnly, int*> v15{MoveOnly{}, nullptr};\n \n std::pair<int*, ExplicitMoveOnly> v16 =\n-  {0, MoveOnly{}}; // { dg-error \"could not convert\" }\n+  {nullptr, MoveOnly{}}; // { dg-error \"could not convert\" }\n std::pair<ExplicitMoveOnly, int*> v17 =\n-  {MoveOnly{}, 0}; // { dg-error \"could not convert\" }\n+  {MoveOnly{}, nullptr}; // { dg-error \"could not convert\" }"}]}