{"sha": "3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VkNDcyYWY2YmM5ZjgzYjdhOGFjNTUzYjI4MmY2NTlhMGJmNTNmNw==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2020-12-13T13:54:48Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2020-12-13T14:09:11Z"}, "message": "middle-end: Support complex Addition\n\nThis patch adds support for\n\n  * Complex Addition with rotation of 90 and 270.\n\n  Addition with rotation of the second argument around the Argand plane.\n    Supported rotations are 90 and 180.\n\n    c = a + (b * I) and c = a + (b * I * I * I)\n\ngcc/ChangeLog:\n\n\t* tree-vect-slp-patterns.c: New file.\n\t* Makefile.in: Add it.\n\t* doc/passes.texi: Document it.\n\t* internal-fn.def (COMPLEX_ADD_ROT90, COMPLEX_ADD_ROT270): New.\n\t* optabs.def (cadd90_optab, cadd270_optab): New.\n\t* doc/md.texi: Document them.\n\t* tree-vect-loop.c (vect_analyze_loop_2): Add dissolve code.\n\t* tree-vect-slp.c:\n\t(vect_free_slp_instance, vect_create_new_slp_node): Export.\n\t(vect_match_slp_patterns_2, vect_match_slp_patterns): New.\n\t(vect_analyze_slp): Use it.\n\t* tree-vectorizer.h (vect_free_slp_tree): Export.\n\t(enum _complex_operation): Forward declare.\n\t(class vect_pattern): New\n\ngcc/testsuite/ChangeLog:\n\n\t* lib/target-supports.exp\n\t(check_effective_target_arm_v8_3a_complex_neon_ok_nocache): Fix it.\n\t(check_effective_target_vect_complex_add_byte\n\t,check_effective_target_vect_complex_add_int\n\t,check_effective_target_vect_complex_add_short\n\t,check_effective_target_vect_complex_add_long\n\t,check_effective_target_vect_complex_add_half\n\t,check_effective_target_vect_complex_add_float\n\t,check_effective_target_vect_complex_add_double): New.\n\t* gcc.dg/vect/complex/bb-slp-complex-add-pattern-byte.c: New test.\n\t* gcc.dg/vect/complex/bb-slp-complex-add-pattern-int.c: New test.\n\t* gcc.dg/vect/complex/bb-slp-complex-add-pattern-long.c: New test.\n\t* gcc.dg/vect/complex/bb-slp-complex-add-pattern-short.c: New test.\n\t* gcc.dg/vect/complex/bb-slp-complex-add-pattern-unsigned-byte.c: New test.\n\t* gcc.dg/vect/complex/bb-slp-complex-add-pattern-unsigned-int.c: New test.\n\t* gcc.dg/vect/complex/bb-slp-complex-add-pattern-unsigned-long.c: New test.\n\t* gcc.dg/vect/complex/bb-slp-complex-add-pattern-unsigned-short.c: New test.\n\t* gcc.dg/vect/complex/complex-add-pattern-template.c: New test.\n\t* gcc.dg/vect/complex/complex-add-template.c: New test.\n\t* gcc.dg/vect/complex/complex-operations-run.c: New test.\n\t* gcc.dg/vect/complex/complex-operations.c: New test.\n\t* gcc.dg/vect/complex/complex.exp: New test.\n\t* gcc.dg/vect/complex/fast-math-bb-slp-complex-add-double.c: New test.\n\t* gcc.dg/vect/complex/fast-math-bb-slp-complex-add-float.c: New test.\n\t* gcc.dg/vect/complex/fast-math-bb-slp-complex-add-half-float.c: New test.\n\t* gcc.dg/vect/complex/fast-math-bb-slp-complex-add-pattern-double.c: New test.\n\t* gcc.dg/vect/complex/fast-math-bb-slp-complex-add-pattern-float.c: New test.\n\t* gcc.dg/vect/complex/fast-math-bb-slp-complex-add-pattern-half-float.c: New test.\n\t* gcc.dg/vect/complex/fast-math-complex-add-double.c: New test.\n\t* gcc.dg/vect/complex/fast-math-complex-add-float.c: New test.\n\t* gcc.dg/vect/complex/fast-math-complex-add-half-float.c: New test.\n\t* gcc.dg/vect/complex/fast-math-complex-add-pattern-double.c: New test.\n\t* gcc.dg/vect/complex/fast-math-complex-add-pattern-float.c: New test.\n\t* gcc.dg/vect/complex/fast-math-complex-add-pattern-half-float.c: New test.\n\t* gcc.dg/vect/complex/vect-complex-add-pattern-byte.c: New test.\n\t* gcc.dg/vect/complex/vect-complex-add-pattern-int.c: New test.\n\t* gcc.dg/vect/complex/vect-complex-add-pattern-long.c: New test.\n\t* gcc.dg/vect/complex/vect-complex-add-pattern-short.c: New test.\n\t* gcc.dg/vect/complex/vect-complex-add-pattern-unsigned-byte.c: New test.\n\t* gcc.dg/vect/complex/vect-complex-add-pattern-unsigned-int.c: New test.\n\t* gcc.dg/vect/complex/vect-complex-add-pattern-unsigned-long.c: New test.\n\t* gcc.dg/vect/complex/vect-complex-add-pattern-unsigned-short.c: New test.", "tree": {"sha": "dd5b80e24ed5ac6b8a0faed24badd4003cf4c041", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd5b80e24ed5ac6b8a0faed24badd4003cf4c041"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10bbba9145700e2c3b4709c1041c66d8ff85c7f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10bbba9145700e2c3b4709c1041c66d8ff85c7f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10bbba9145700e2c3b4709c1041c66d8ff85c7f1"}], "stats": {"total": 2099, "additions": 2078, "deletions": 21}, "files": [{"sha": "a6f995a10d753b9e515d45258974f3d813aad1db", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -1647,6 +1647,7 @@ OBJS = \\\n \ttree-vect-loop.o \\\n \ttree-vect-loop-manip.o \\\n \ttree-vect-slp.o \\\n+\ttree-vect-slp-patterns.o \\\n \ttree-vectorizer.o \\\n \ttree-vector-builder.o \\\n \ttree-vrp.o \\"}, {"sha": "ec6ec180b91fcf9f481b6754c044483787fd923c", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -6154,6 +6154,54 @@ floating-point mode.\n \n This pattern is not allowed to @code{FAIL}.\n \n+@cindex @code{cadd90@var{m}3} instruction pattern\n+@item @samp{cadd90@var{m}3}\n+Perform vector add and subtract on even/odd number pairs.  The operation being\n+matched is semantically described as\n+\n+@smallexample\n+  for (int i = 0; i < N; i += 2)\n+    @{\n+      c[i] = a[i] - b[i+1];\n+      c[i+1] = a[i+1] + b[i];\n+    @}\n+@end smallexample\n+\n+This operation is semantically equivalent to performing a vector addition of\n+complex numbers in operand 1 with operand 2 rotated by 90 degrees around\n+the argand plane and storing the result in operand 0.\n+\n+In GCC lane ordering the real part of the number must be in the even lanes with\n+the imaginary part in the odd lanes.\n+\n+The operation is only supported for vector modes @var{m}.\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n+@cindex @code{cadd270@var{m}3} instruction pattern\n+@item @samp{cadd270@var{m}3}\n+Perform vector add and subtract on even/odd number pairs.  The operation being\n+matched is semantically described as\n+\n+@smallexample\n+  for (int i = 0; i < N; i += 2)\n+    @{\n+      c[i] = a[i] + b[i+1];\n+      c[i+1] = a[i+1] - b[i];\n+    @}\n+@end smallexample\n+\n+This operation is semantically equivalent to performing a vector addition of\n+complex numbers in operand 1 with operand 2 rotated by 270 degrees around\n+the argand plane and storing the result in operand 0.\n+\n+In GCC lane ordering the real part of the number must be in the even lanes with\n+the imaginary part in the odd lanes.\n+\n+The operation is only supported for vector modes @var{m}.\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n @cindex @code{ffs@var{m}2} instruction pattern\n @item @samp{ffs@var{m}2}\n Store into operand 0 one plus the index of the least significant 1-bit"}, {"sha": "c86df5cd843084a5b7933ef99a23386891a7b0c1", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -709,7 +709,8 @@ loop.\n The pass is implemented in @file{tree-vectorizer.c} (the main driver),\n @file{tree-vect-loop.c} and @file{tree-vect-loop-manip.c} (loop specific parts\n and general loop utilities), @file{tree-vect-slp} (loop-aware SLP\n-functionality), @file{tree-vect-stmts.c} and @file{tree-vect-data-refs.c}.\n+functionality), @file{tree-vect-stmts.c}, @file{tree-vect-data-refs.c} and\n+@file{tree-vect-slp-patterns.c} containing the SLP pattern matcher.\n Analysis of data references is in @file{tree-data-ref.c}.\n \n SLP Vectorization.  This pass performs vectorization of straight-line code. The"}, {"sha": "511fe70162b5d9db3a61a5285d31c008f6835487", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -277,6 +277,9 @@ DEF_INTERNAL_FLT_FN (SCALB, ECF_CONST, scalb, binary)\n DEF_INTERNAL_FLT_FLOATN_FN (FMIN, ECF_CONST, fmin, binary)\n DEF_INTERNAL_FLT_FLOATN_FN (FMAX, ECF_CONST, fmax, binary)\n DEF_INTERNAL_OPTAB_FN (XORSIGN, ECF_CONST, xorsign, binary)\n+DEF_INTERNAL_OPTAB_FN (COMPLEX_ADD_ROT90, ECF_CONST, cadd90, binary)\n+DEF_INTERNAL_OPTAB_FN (COMPLEX_ADD_ROT270, ECF_CONST, cadd270, binary)\n+\n \n /* FP scales.  */\n DEF_INTERNAL_FLT_FN (LDEXP, ECF_CONST, ldexp, binary)"}, {"sha": "e9727def4dbf941bb9ac8b56f83f8ea0f52b262c", "filename": "gcc/optabs.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -290,6 +290,8 @@ OPTAB_D (atan_optab, \"atan$a2\")\n OPTAB_D (atanh_optab, \"atanh$a2\")\n OPTAB_D (copysign_optab, \"copysign$F$a3\")\n OPTAB_D (xorsign_optab, \"xorsign$F$a3\")\n+OPTAB_D (cadd90_optab, \"cadd90$a3\")\n+OPTAB_D (cadd270_optab, \"cadd270$a3\")\n OPTAB_D (cos_optab, \"cos$a2\")\n OPTAB_D (cosh_optab, \"cosh$a2\")\n OPTAB_D (exp10_optab, \"exp10$a2\")"}, {"sha": "aadee7f86fa42895ffc6bec481a95a2b185bf86d", "filename": "gcc/testsuite/gcc.dg/vect/complex/bb-slp-complex-add-pattern-byte.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-byte.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_byte } */\n+/* { dg-require-effective-target stdint_types } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE int8_t\n+#define N 16\n+#include <stdint.h>\n+#include \"complex-add-pattern-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"slp1\" { xfail aarch64_sve2 } } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"slp1\" { xfail aarch64_sve2 } } } */"}, {"sha": "8eba24dc187895150ee3515d5bd2a35b46528388", "filename": "gcc/testsuite/gcc.dg/vect/complex/bb-slp-complex-add-pattern-int.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-int.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_int } */\n+/* { dg-require-effective-target stdint_types } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE int32_t\n+#define N 16\n+#include <stdint.h>\n+#include \"complex-add-pattern-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"slp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"slp1\" { xfail aarch64_sve2 } } } */"}, {"sha": "9275ff12e0cc4fd643c3d60d1a5ce51cd3550833", "filename": "gcc/testsuite/gcc.dg/vect/complex/bb-slp-complex-add-pattern-long.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-long.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-long.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-long.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_long } */\n+/* { dg-require-effective-target stdint_types } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE int64_t\n+#define N 16\n+#include <stdint.h>\n+#include \"complex-add-pattern-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"slp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"slp1\" { xfail aarch64_sve2 } } } */"}, {"sha": "8cbbdb825ddb616cc9c3ac7c0b62ad53e0e54045", "filename": "gcc/testsuite/gcc.dg/vect/complex/bb-slp-complex-add-pattern-short.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-short.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-short.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-short.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_short } */\n+/* { dg-require-effective-target stdint_types } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE int16_t\n+#define N 16\n+#include <stdint.h>\n+#include \"complex-add-pattern-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"slp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"slp1\" { xfail aarch64_sve2 } } } */"}, {"sha": "b753914bea73189f90a6caf50c881d72800085e6", "filename": "gcc/testsuite/gcc.dg/vect/complex/bb-slp-complex-add-pattern-unsigned-byte.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-unsigned-byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-unsigned-byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-unsigned-byte.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_byte } */\n+/* { dg-require-effective-target stdint_types } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE uint8_t\n+#define N 16\n+#include <stdint.h>\n+#include \"complex-add-pattern-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"slp1\" { xfail aarch64_sve2 } } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"slp1\" { xfail aarch64_sve2 } } } */"}, {"sha": "270c49efbf95ffbc21ff5c3b7ae34280fa1b6059", "filename": "gcc/testsuite/gcc.dg/vect/complex/bb-slp-complex-add-pattern-unsigned-int.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-unsigned-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-unsigned-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-unsigned-int.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_int } */\n+/* { dg-require-effective-target stdint_types } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE uint32_t\n+#define N 16\n+#include <stdint.h>\n+#include \"complex-add-pattern-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"slp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"slp1\" { xfail aarch64_sve2 } } } */"}, {"sha": "88144e52014d86842b16520b0940123d5448459c", "filename": "gcc/testsuite/gcc.dg/vect/complex/bb-slp-complex-add-pattern-unsigned-long.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-unsigned-long.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-unsigned-long.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-unsigned-long.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_long } */\n+/* { dg-require-effective-target stdint_types } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE uint64_t\n+#define N 16\n+#include <stdint.h>\n+#include \"complex-add-pattern-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"slp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"slp1\" { xfail aarch64_sve2 } } } */"}, {"sha": "445af3943d318c4daa69334fa6c1095592e2dec0", "filename": "gcc/testsuite/gcc.dg/vect/complex/bb-slp-complex-add-pattern-unsigned-short.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-unsigned-short.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-unsigned-short.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fbb-slp-complex-add-pattern-unsigned-short.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_short } */\n+/* { dg-require-effective-target stdint_types } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE uint16_t\n+#define N 16\n+#include <stdint.h>\n+#include \"complex-add-pattern-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"slp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"slp1\" { xfail aarch64_sve2 } } } */"}, {"sha": "a99a9296194472c42fed84376c4a48853073c7fd", "filename": "gcc/testsuite/gcc.dg/vect/complex/complex-add-pattern-template.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fcomplex-add-pattern-template.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fcomplex-add-pattern-template.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fcomplex-add-pattern-template.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,60 @@\n+void add90 (TYPE a[restrict N], TYPE b[restrict N], TYPE c[restrict N])\n+{\n+  for (int i=0; i < N; i+=2)\n+    {\n+      c[i] = a[i] - b[i+1];\n+      c[i+1] = a[i+1] + b[i];\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"vect\" } } */\n+\n+void add270 (TYPE a[restrict N], TYPE b[restrict N], TYPE c[restrict N])\n+{\n+  for (int i=0; i < N; i+=2)\n+    {\n+      c[i] = a[i] + b[i+1];\n+      c[i+1] = a[i+1] - b[i];\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"vect\" } } */\n+\n+void addMixed (TYPE a[restrict N], TYPE b[restrict N], TYPE c[restrict N])\n+{\n+  for (int i=0; i < N; i+=4)\n+    {\n+      c[i] = a[i] - b[i+1];\n+      c[i+1] = a[i+1] + b[i];\n+      c[i+2] = a[i+2] + b[i+3];\n+      c[i+3] = a[i+3] - b[i+2];\n+    }\n+}\n+\n+void add90HandUnrolled (TYPE a[restrict N], TYPE b[restrict N],\n+\t\t\tTYPE c[restrict N])\n+{\n+  for (int i=0; i < (N /2); i+=4)\n+    {\n+      c[i] = a[i] - b[i+1];\n+      c[i+2] = a[i+2] - b[i+3];\n+      c[i+1] = a[i+1] + b[i];\n+      c[i+3] = a[i+3] + b[i+2];\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"vect\" } } */\n+\n+void add90Hybrid (TYPE a[restrict N], TYPE b[restrict N], TYPE c[restrict N],\n+\t\t  TYPE d[restrict N])\n+{\n+  for (int i=0; i < N; i+=2)\n+    {\n+      c[i] = a[i] - b[i+1];\n+      c[i+1] = a[i+1] + b[i];\n+      d[i] = a[i] - b[i];\n+      d[i+1] = a[i+1] - b[i+1];\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 2 \"vect\" } } */\n\\ No newline at end of file"}, {"sha": "32c81e64f627b0f529e6a9129bd7ceeff727a662", "filename": "gcc/testsuite/gcc.dg/vect/complex/complex-add-template.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fcomplex-add-template.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fcomplex-add-template.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fcomplex-add-template.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,79 @@\n+#include <complex.h>\n+\n+void add0 (_Complex TYPE a[restrict N], _Complex TYPE b[restrict N],\n+\t   _Complex TYPE c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+    c[i] = a[i] + b[i];\n+}\n+\n+void add90snd (_Complex TYPE a[restrict N], _Complex TYPE b[restrict N],\n+\t       _Complex TYPE c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+    c[i] = a[i] + (b[i] * I);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"vect\" } } */\n+\n+void add180snd (_Complex TYPE a[restrict N], _Complex TYPE b[restrict N],\n+\t        _Complex TYPE c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+    c[i] = a[i] + (b[i] * I * I);\n+}\n+\n+void add270snd (_Complex TYPE a[restrict N], _Complex TYPE b[restrict N],\n+\t        _Complex TYPE c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+    c[i] = a[i] + (b[i] * I * I * I);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"vect\" } } */\n+\n+void add90fst (_Complex TYPE a[restrict N], _Complex TYPE b[restrict N],\n+\t       _Complex TYPE c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+    c[i] = (a[i] * I) + b[i];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"vect\" } } */\n+\n+void add180fst (_Complex TYPE a[restrict N], _Complex TYPE b[restrict N],\n+\t        _Complex TYPE c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+    c[i] = (a[i] * I * I) + b[i];\n+}\n+\n+void add270fst (_Complex TYPE a[restrict N], _Complex TYPE b[restrict N],\n+\t        _Complex TYPE c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+    c[i] = (a[i] * I * I * I) + b[i];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"vect\" } } */\n+\n+void addconjfst (_Complex TYPE a[restrict N], _Complex TYPE b[restrict N],\n+\t\t _Complex TYPE c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+    c[i] = ~a[i] + b[i];\n+}\n+\n+void addconjsnd (_Complex TYPE a[restrict N], _Complex TYPE b[restrict N],\n+\t\t _Complex TYPE c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+    c[i] = a[i] + ~b[i];\n+}\n+\n+void addconjboth (_Complex TYPE a[restrict N], _Complex TYPE b[restrict N],\n+\t\t  _Complex TYPE c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+    c[i] = ~a[i] + ~b[i];\n+}"}, {"sha": "a0348a7041ca384104bc5ab688d941c14e5b7381", "filename": "gcc/testsuite/gcc.dg/vect/complex/complex-operations-run.c", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fcomplex-operations-run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fcomplex-operations-run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fcomplex-operations-run.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,103 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vect_complex_add_double } */\n+/* { dg-add-options arm_v8_3a_complex_neon } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#include <stdio.h>\n+#include <complex.h>\n+#include <string.h>\n+#include <float.h>\n+#include <math.h>\n+\n+#define PREF old\n+#pragma GCC push_options\n+#pragma GCC optimize (\"no-tree-vectorize\")\n+# include \"complex-operations.c\"\n+#pragma GCC pop_options\n+#undef PREF\n+\n+#define PREF new\n+# include \"complex-operations.c\"\n+#undef PREF\n+\n+#define TYPE double\n+#define TYPE2 double\n+#define EP pow(2, -45)\n+\n+#define xstr(s) str(s)\n+#define str(s) #s\n+\n+#define FCMP(A, B) \\\n+  ((fabs (creal (A) - creal (B)) <= EP) && (fabs (cimag (A) - cimag (B)) <= EP))\n+\n+#define CMP(A, B) \\\n+  (FCMP(A,B) ? \"PASS\" : \"FAIL\")\n+\n+#define COMPARE(A,B) \\\n+  memset (&c1, 0, sizeof (c1)); \\\n+  memset (&c2, 0, sizeof (c2)); \\\n+  A; B; \\\n+  if (!FCMP(c1[0],c2[0]) || !FCMP(c1[1], c2[1])) \\\n+  { \\\n+    printf (\"=> %s vs %s\\n\", xstr (A), xstr (B)); \\\n+    printf (\"%a\\n\", creal (c1[0]) - creal (c2[0])); \\\n+    printf (\"%a\\n\", cimag (c1[1]) - cimag (c2[1])); \\\n+    printf (\"%.2f+%.2fI == %.2f+%.2fI (%s)\\n\", creal (c1[0]), cimag (c1[0]), creal (c2[0]), cimag (c2[0]), CMP (c1[0], c2[0])); \\\n+    printf (\"%.2f+%.2fI == %.2f+%.2fI (%s)\\n\", creal (c1[1]), cimag (c1[1]), creal (c2[1]), cimag (c2[1]), CMP (c1[1], c2[1])); \\\n+    printf (\"\\n\"); \\\n+    __builtin_abort (); \\\n+  }\n+\n+int main ()\n+{\n+  TYPE2 complex a[] = { 1.0 + 3.0 * I, 2.0 + 3.5 * I, 1.0 + 3.0 * I, 2.0 + 3.5 * I, 1.0 + 3.0 * I, 2.0 + 3.5 * I, 1.0 + 3.0 * I, 2.0 + 3.5 * I, 1.0 + 3.0 * I, 2.0 + 3.5 * I, 1.0 + 3.0 * I, 2.0 + 3.5 * I, 1.0 + 3.0 * I, 2.0 + 3.5 * I, 1.0 + 3.0 * I, 2.0 + 3.5 * I, 1.0 + 3.0 * I, 2.0 + 3.5 * I, 1.0 + 3.0 * I, 2.0 + 3.5 * I, 1.0 + 3.0 * I, 2.0 + 3.5 * I, 1.0 + 3.0 * I, 2.0 + 3.5 * I, 1.0 + 3.0 * I, 2.0 + 3.5 * I, 1.0 + 3.0 * I, 2.0 + 3.5 * I, 1.0 + 3.0 * I, 2.0 + 3.5 * I, 1.0 + 3.0 * I, 2.0 + 3.5 * I };\n+  TYPE  complex b[] = { 1.1 + 3.1 * I, 2.1 + 3.6 * I, 1.1 + 3.1 * I, 2.1 + 3.6 * I, 1.1 + 3.1 * I, 2.1 + 3.6 * I, 1.1 + 3.1 * I, 2.1 + 3.6 * I, 1.1 + 3.1 * I, 2.1 + 3.6 * I, 1.1 + 3.1 * I, 2.1 + 3.6 * I, 1.1 + 3.1 * I, 2.1 + 3.6 * I, 1.1 + 3.1 * I, 2.1 + 3.6 * I, 1.1 + 3.1 * I, 2.1 + 3.6 * I, 1.1 + 3.1 * I, 2.1 + 3.6 * I, 1.1 + 3.1 * I, 2.1 + 3.6 * I, 1.1 + 3.1 * I, 2.1 + 3.6 * I, 1.1 + 3.1 * I, 2.1 + 3.6 * I, 1.1 + 3.1 * I, 2.1 + 3.6 * I, 1.1 + 3.1 * I, 2.1 + 3.6 * I, 1.1 + 3.1 * I, 2.1 + 3.6 * I };\n+  TYPE  complex c2[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n+  TYPE  complex c1[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n+  TYPE  diff1, diff2;\n+\n+  COMPARE(fma0_old(a, b, c1), fma0_new(a, b, c2));\n+  COMPARE(fma90_old(a, b, c1), fma90_new(a, b, c2));\n+  COMPARE(fma180_old(a, b, c1), fma180_new(a, b, c2));\n+  COMPARE(fma270_old(a, b, c1), fma270_new(a, b, c2));\n+  COMPARE(fma0_snd_old(a, b, c1), fma0_snd_new(a, b, c2));\n+  COMPARE(fma90_snd_old(a, b, c1), fma90_snd_new(a, b, c2));\n+  COMPARE(fma180_snd_old(a, b, c1), fma180_snd_new(a, b, c2));\n+  COMPARE(fma270_snd_old(a, b, c1), fma270_snd_new(a, b, c2));\n+  COMPARE(fma_conj_first_old(a, b, c1), fma_conj_first_new(a, b, c2));\n+  COMPARE(fma_conj_second_old(a, b, c1), fma_conj_second_new(a, b, c2));\n+  COMPARE(fma_conj_both_old(a, b, c1), fma_conj_both_new(a, b, c2));\n+  COMPARE(fms0_old(a, b, c1), fms0_new(a, b, c2));\n+  COMPARE(fms90_old(a, b, c1), fms90_new(a, b, c2));\n+  COMPARE(fms180_old(a, b, c1), fms180_new(a, b, c2));\n+  COMPARE(fms270_old(a, b, c1), fms270_new(a, b, c2));\n+  COMPARE(fms0_snd_old(a, b, c1), fms0_snd_new(a, b, c2));\n+  COMPARE(fms90_snd_old(a, b, c1), fms90_snd_new(a, b, c2));\n+  COMPARE(fms180_snd_old(a, b, c1), fms180_snd_new(a, b, c2));\n+  COMPARE(fms270_snd_old(a, b, c1), fms270_snd_new(a, b, c2));\n+  COMPARE(fms_conj_first_old(a, b, c1), fms_conj_first_new(a, b, c2));\n+  COMPARE(fms_conj_second_old(a, b, c1), fms_conj_second_new(a, b, c2));\n+  COMPARE(fms_conj_both_old(a, b, c1), fms_conj_both_new(a, b, c2));\n+  COMPARE(mul0_old(a, b, c1), mul0_new(a, b, c2));\n+  COMPARE(mul90_old(a, b, c1), mul90_new(a, b, c2));\n+  COMPARE(mul180_old(a, b, c1), mul180_new(a, b, c2));\n+  COMPARE(mul270_old(a, b, c1), mul270_new(a, b, c2));\n+  COMPARE(mul0_snd_old(a, b, c1), mul0_snd_new(a, b, c2));\n+  COMPARE(mul90_snd_old(a, b, c1), mul90_snd_new(a, b, c2));\n+  COMPARE(mul180_snd_old(a, b, c1), mul180_snd_new(a, b, c2));\n+  COMPARE(mul270_snd_old(a, b, c1), mul270_snd_new(a, b, c2));\n+  COMPARE(mul_conj_first_old(a, b, c1), mul_conj_first_new(a, b, c2));\n+  COMPARE(mul_conj_second_old(a, b, c1), mul_conj_second_new(a, b, c2));\n+  COMPARE(mul_conj_both_old(a, b, c1), mul_conj_both_new(a, b, c2));\n+  COMPARE(add0_old(a, b, c1), add0_new(a, b, c2));\n+  COMPARE(add90_old(a, b, c1), add90_new(a, b, c2));\n+  COMPARE(add180_old(a, b, c1), add180_new(a, b, c2));\n+  COMPARE(add270_old(a, b, c1), add270_new(a, b, c2));\n+  COMPARE(add0_snd_old(a, b, c1), add0_snd_new(a, b, c2));\n+  COMPARE(add90_snd_old(a, b, c1), add90_snd_new(a, b, c2));\n+  COMPARE(add180_snd_old(a, b, c1), add180_snd_new(a, b, c2));\n+  COMPARE(add270_snd_old(a, b, c1), add270_snd_new(a, b, c2));\n+  COMPARE(add_conj_first_old(a, b, c1), add_conj_first_new(a, b, c2));\n+  COMPARE(add_conj_second_old(a, b, c1), add_conj_second_new(a, b, c2));\n+  COMPARE(add_conj_both_old(a, b, c1), add_conj_both_new(a, b, c2));\n+}"}, {"sha": "fdce995481d23c6a536293c8ee59eaf9ca9239bf", "filename": "gcc/testsuite/gcc.dg/vect/complex/complex-operations.c", "status": "added", "additions": 358, "deletions": 0, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fcomplex-operations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fcomplex-operations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fcomplex-operations.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,358 @@\n+#include <stdio.h>\n+#include <complex.h>\n+\n+#ifndef PREF\n+#define PREF c\n+#endif\n+\n+#define FX(N,P) P ## _ ## N\n+#define MK(N,P) FX(P,N)\n+\n+#define N 32\n+#define TYPE double\n+\n+// ------ FMA\n+\n+// Complex FMA instructions rotating the result\n+\n+__attribute__((noinline,noipa))\n+void MK(fma0, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] += a[i] * b[i];\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(fma90, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] += a[i] * b[i] * I;\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(fma180, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] += a[i] * b[i] * I * I;\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(fma270, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] += a[i] * b[i] * I * I * I;\n+}\n+\n+// Complex FMA instructions rotating the second parameter.\n+\n+\n+__attribute__((noinline,noipa))\n+void MK(fma0_snd, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] += a[i] * b[i];\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(fma90_snd, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] += a[i] * (b[i] * I);\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(fma180_snd, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] += a[i] * (b[i] * I * I);\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(fma270_snd, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] += a[i] * (b[i] * I * I * I);\n+}\n+\n+// Complex FMA instructions with conjucated values.\n+\n+\n+__attribute__((noinline,noipa))\n+void MK(fma_conj_first, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] += conj (a[i]) * b[i];\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(fma_conj_second, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] += a[i] * conj (b[i]);\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(fma_conj_both, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] += conj (a[i]) * conj (b[i]);\n+}\n+\n+// ----- FMS\n+\n+// Complex FMS instructions rotating the result\n+\n+__attribute__((noinline,noipa))\n+void MK(fms0, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] -= a[i] * b[i];\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(fms90, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] -= a[i] * b[i] * I;\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(fms180, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] -= a[i] * b[i] * I * I;\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(fms270, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] -= a[i] * b[i] * I * I * I;\n+}\n+\n+// Complex FMS instructions rotating the second parameter.\n+\n+__attribute__((noinline,noipa))\n+void MK(fms0_snd, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] -= a[i] * b[i];\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(fms90_snd, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] -= a[i] * (b[i] * I);\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(fms180_snd, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] -= a[i] * (b[i] * I * I);\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(fms270_snd, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] -= a[i] * (b[i] * I * I * I);\n+}\n+\n+// Complex FMS instructions with conjucated values.\n+\n+__attribute__((noinline,noipa))\n+void MK(fms_conj_first, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] -= conj (a[i]) * b[i];\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(fms_conj_second, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] -= a[i] * conj (b[i]);\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(fms_conj_both, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] -= conj (a[i]) * conj (b[i]);\n+}\n+\n+\n+// ----- MUL\n+\n+// Complex MUL instructions rotating the result\n+\n+__attribute__((noinline,noipa))\n+void MK(mul0, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] = a[i] * b[i];\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(mul90, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] = a[i] * b[i] * I;\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(mul180, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] = a[i] * b[i] * I * I;\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(mul270, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] = a[i] * b[i] * I * I * I;\n+}\n+\n+// Complex MUL instructions rotating the second parameter.\n+\n+__attribute__((noinline,noipa))\n+void MK(mul0_snd, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] = a[i] * b[i];\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(mul90_snd, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] = a[i] * (b[i] * I);\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(mul180_snd, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] = a[i] * (b[i] * I * I);\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(mul270_snd, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] = a[i] * (b[i] * I * I * I);\n+}\n+\n+// Complex FMS instructions with conjucated values.\n+\n+__attribute__((noinline,noipa))\n+void MK(mul_conj_first, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] = conj (a[i]) * b[i];\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(mul_conj_second, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] = a[i] * conj (b[i]);\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(mul_conj_both, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] = conj (a[i]) * conj (b[i]);\n+}\n+\n+\n+// ----- ADD\n+\n+// Complex ADD instructions rotating the result\n+\n+__attribute__((noinline,noipa))\n+void MK(add0, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] = a[i] + b[i];\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(add90, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] = (a[i] + b[i]) * I;\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(add180, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] = (a[i] + b[i]) * I * I;\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(add270, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] = (a[i] + b[i]) * I * I * I;\n+}\n+\n+// Complex ADD instructions rotating the second parameter.\n+\n+__attribute__((noinline,noipa))\n+void MK(add0_snd, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] = a[i] + b[i];\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(add90_snd, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] = a[i] + (b[i] * I);\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(add180_snd, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] = a[i] + (b[i] * I * I);\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(add270_snd, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] = a[i] + (b[i] * I * I * I);\n+}\n+\n+// Complex ADD instructions with conjucated values.\n+\n+__attribute__((noinline,noipa))\n+void MK(add_conj_first, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] = conj (a[i]) + b[i];\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(add_conj_second, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] = a[i] + conj (b[i]);\n+}\n+\n+__attribute__((noinline,noipa))\n+void MK(add_conj_both, PREF) (TYPE complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+      c[i] = conj (a[i]) + conj (b[i]);\n+}\n+\n+"}, {"sha": "daeb02820ce3c83af0b5047cc25c7348790e1b8e", "filename": "gcc/testsuite/gcc.dg/vect/complex/complex.exp", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fcomplex.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fcomplex.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fcomplex.exp?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,20 @@\n+# Copyright (C) 1997-2020 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_file $srcdir/$subdir/../vect.exp"}, {"sha": "7bbb61adfab06a89ac36a66f848746033158c41c", "filename": "gcc/testsuite/gcc.dg/vect/complex/fast-math-bb-slp-complex-add-double.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-bb-slp-complex-add-double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-bb-slp-complex-add-double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-bb-slp-complex-add-double.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_double } */\n+/* { dg-add-options arm_v8_3a_complex_neon } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE double\n+#define N 16\n+#include \"complex-add-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"slp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"slp1\" } } */\n+"}, {"sha": "cf99f1de31056bbaca3fe8885643289b770ad76d", "filename": "gcc/testsuite/gcc.dg/vect/complex/fast-math-bb-slp-complex-add-float.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-bb-slp-complex-add-float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-bb-slp-complex-add-float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-bb-slp-complex-add-float.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_float } */\n+/* { dg-add-options arm_v8_3a_complex_neon } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE float\n+#define N 16\n+#include \"complex-add-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"slp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"slp1\" } } */"}, {"sha": "9f535dde7c0d131c1a35e5b6b1d27530faaea88f", "filename": "gcc/testsuite/gcc.dg/vect/complex/fast-math-bb-slp-complex-add-half-float.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-bb-slp-complex-add-half-float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-bb-slp-complex-add-half-float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-bb-slp-complex-add-half-float.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_half } */\n+/* { dg-add-options arm_v8_3a_fp16_complex_neon } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE _Float16\n+#define N 16\n+#include \"complex-add-template.c\"\n+\n+/* Vectorization is failing for these cases.  They should work but for now ignore.  */\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"slp1\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"slp1\" { xfail *-*-* } } } */"}, {"sha": "e121113320ec153a732fe8e1c0b25d06929c126b", "filename": "gcc/testsuite/gcc.dg/vect/complex/fast-math-bb-slp-complex-add-pattern-double.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-bb-slp-complex-add-pattern-double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-bb-slp-complex-add-pattern-double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-bb-slp-complex-add-pattern-double.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_double } */\n+/* { dg-add-options arm_v8_3a_complex_neon } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE double\n+#define N 16\n+#include \"complex-add-pattern-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"slp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"slp1\" } } */"}, {"sha": "8565833887f026b732b86d2c42c3a3d7a883b8d8", "filename": "gcc/testsuite/gcc.dg/vect/complex/fast-math-bb-slp-complex-add-pattern-float.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-bb-slp-complex-add-pattern-float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-bb-slp-complex-add-pattern-float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-bb-slp-complex-add-pattern-float.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_float } */\n+/* { dg-add-options arm_v8_3a_complex_neon } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE float\n+#define N 16\n+#include \"complex-add-pattern-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"slp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"slp1\" } } */"}, {"sha": "857ee9de6b48407ebb1c6974d4b05cd661cd4f16", "filename": "gcc/testsuite/gcc.dg/vect/complex/fast-math-bb-slp-complex-add-pattern-half-float.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-bb-slp-complex-add-pattern-half-float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-bb-slp-complex-add-pattern-half-float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-bb-slp-complex-add-pattern-half-float.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_half } */\n+/* { dg-add-options arm_v8_3a_fp16_complex_neon } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE _Float16\n+#define N 16\n+#include \"complex-add-pattern-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"slp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"slp1\" { xfail arm*-*-* } } } */"}, {"sha": "0d4d3ce8869cde8e3020b93456421cc268fb8263", "filename": "gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-double.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-complex-add-double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-complex-add-double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-complex-add-double.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_double } */\n+/* { dg-add-options arm_v8_3a_complex_neon } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE double\n+#define N 200\n+#include \"complex-add-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 2 \"vect\" } } */\n\\ No newline at end of file"}, {"sha": "b9866966be37ed2e2c5210a06f04474171e0d4f3", "filename": "gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-float.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-complex-add-float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-complex-add-float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-complex-add-float.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_float } */\n+/* { dg-add-options arm_v8_3a_complex_neon } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE float\n+#define N 200\n+#include \"complex-add-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 2 \"vect\" } } */\n\\ No newline at end of file"}, {"sha": "c3dca57b4f49932acf28b19ad86774f171072576", "filename": "gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-half-float.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-complex-add-half-float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-complex-add-half-float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-complex-add-half-float.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_half } */\n+/* { dg-add-options arm_v8_3a_fp16_complex_neon } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE _Float16\n+#define N 200\n+#include \"complex-add-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 2 \"vect\" } } */\n\\ No newline at end of file"}, {"sha": "df4d3f671f40663d779598dcb5b1f94260c6d7e3", "filename": "gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-double.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-complex-add-pattern-double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-complex-add-pattern-double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-complex-add-pattern-double.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_double } */\n+/* { dg-add-options arm_v8_3a_complex_neon } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE double\n+#define N 200\n+#include \"complex-add-pattern-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 4 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"vect\" } } */"}, {"sha": "6df5c6d18309723d81734429f9034e3f6b10f7fc", "filename": "gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-float.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-complex-add-pattern-float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-complex-add-pattern-float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-complex-add-pattern-float.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_float } */\n+/* { dg-add-options arm_v8_3a_complex_neon } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE float\n+#define N 200\n+#include \"complex-add-pattern-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 4 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"vect\" } } */"}, {"sha": "a72511262784b942d51fad9d0da423890bc3cd92", "filename": "gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-half-float.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-complex-add-pattern-half-float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-complex-add-pattern-half-float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Ffast-math-complex-add-pattern-half-float.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_half } */\n+/* { dg-add-options arm_v8_3a_fp16_complex_neon } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE _Float16\n+#define N 200\n+#include \"complex-add-pattern-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 4 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"vect\" } } */\n+"}, {"sha": "438d2192723a7b15261c346a290ccb0d9e0e02b6", "filename": "gcc/testsuite/gcc.dg/vect/complex/vect-complex-add-pattern-byte.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-byte.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_byte } */\n+/* { dg-require-effective-target stdint_types } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE int8_t\n+#define N 200\n+#include <stdint.h>\n+#include \"complex-add-pattern-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"vect\" } } */"}, {"sha": "04c27dcf4102e4d53f2cc4f2aebb55a10d1fe5b1", "filename": "gcc/testsuite/gcc.dg/vect/complex/vect-complex-add-pattern-int.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-int.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_int } */\n+/* { dg-require-effective-target stdint_types } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE int32_t\n+#define N 200\n+#include <stdint.h>\n+#include \"complex-add-pattern-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"vect\" } } */"}, {"sha": "27988ad34233f23b359fa4de56cb1d2182496bcc", "filename": "gcc/testsuite/gcc.dg/vect/complex/vect-complex-add-pattern-long.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-long.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-long.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-long.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_long } */\n+/* { dg-require-effective-target stdint_types } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE int64_t\n+#define N 200\n+#include <stdint.h>\n+#include \"complex-add-pattern-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"vect\" } } */"}, {"sha": "88d225d6ff8004eabc679a51b9dc01d69be2c3b0", "filename": "gcc/testsuite/gcc.dg/vect/complex/vect-complex-add-pattern-short.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-short.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-short.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-short.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_short } */\n+/* { dg-require-effective-target stdint_types } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE int16_t\n+#define N 200\n+#include <stdint.h>\n+#include \"complex-add-pattern-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"vect\" } } */"}, {"sha": "59109c008bb28bf65600e0427ca86935db10b55c", "filename": "gcc/testsuite/gcc.dg/vect/complex/vect-complex-add-pattern-unsigned-byte.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-unsigned-byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-unsigned-byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-unsigned-byte.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_byte } */\n+/* { dg-require-effective-target stdint_types } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE uint8_t\n+#define N 200\n+#include <stdint.h>\n+#include \"complex-add-pattern-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"vect\" } } */"}, {"sha": "44d96354d6071bcd2d7e61d8e5211692560f6cbe", "filename": "gcc/testsuite/gcc.dg/vect/complex/vect-complex-add-pattern-unsigned-int.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-unsigned-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-unsigned-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-unsigned-int.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_int } */\n+/* { dg-require-effective-target stdint_types } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE uint32_t\n+#define N 200\n+#include <stdint.h>\n+#include \"complex-add-pattern-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"vect\" } } */"}, {"sha": "667145751cd9efbdf8019249cffea7722e1c78e5", "filename": "gcc/testsuite/gcc.dg/vect/complex/vect-complex-add-pattern-unsigned-long.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-unsigned-long.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-unsigned-long.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-unsigned-long.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_long } */\n+/* { dg-require-effective-target stdint_types } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE uint64_t\n+#define N 200\n+#include <stdint.h>\n+#include \"complex-add-pattern-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"vect\" } } */"}, {"sha": "841adf830c8e1b2fa9184811b39fb54bfc1af92f", "filename": "gcc/testsuite/gcc.dg/vect/complex/vect-complex-add-pattern-unsigned-short.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-unsigned-short.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-unsigned-short.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fvect-complex-add-pattern-unsigned-short.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_complex_add_short } */\n+/* { dg-require-effective-target stdint_types } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#define TYPE uint16_t\n+#define N 200\n+#include <stdint.h>\n+#include \"complex-add-pattern-template.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT90\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_ADD_ROT270\" 1 \"vect\" } } */"}, {"sha": "7e3cf29c1ce6793239a8f598bfa12acd51480db6", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 158, "deletions": 5, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -3367,7 +3367,116 @@ proc check_effective_target_vect_int { } {\n \t}}]\n }\n \n-# Return 1 if the target supports signed int->float conversion \n+# Return 1 if the target supports hardware vectorization of complex additions of\n+# byte, 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+proc check_effective_target_vect_complex_add_byte { } {\n+    return [check_cached_effective_target_indexed vect_complex_add_byte {\n+      expr {\n+\t ([check_effective_target_aarch64_sve2]\n+\t  && [check_effective_target_aarch64_little_endian])\n+\t || ([check_effective_target_arm_v8_1m_mve_fp_ok]\n+\t     && [check_effective_target_arm_little_endian])\n+\t}}]\n+}\n+\n+# Return 1 if the target supports hardware vectorization of complex additions of\n+# short, 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+proc check_effective_target_vect_complex_add_short { } {\n+    return [check_cached_effective_target_indexed vect_complex_add_short {\n+      expr {\n+\t ([check_effective_target_aarch64_sve2]\n+\t  && [check_effective_target_aarch64_little_endian])\n+\t || ([check_effective_target_arm_v8_1m_mve_fp_ok]\n+\t     && [check_effective_target_arm_little_endian])\n+\t}}]\n+}\n+\n+# Return 1 if the target supports hardware vectorization of complex additions of\n+# int, 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+proc check_effective_target_vect_complex_add_int { } {\n+    return [check_cached_effective_target_indexed vect_complex_add_int {\n+      expr {\n+\t ([check_effective_target_aarch64_sve2]\n+\t  && [check_effective_target_aarch64_little_endian])\n+\t || ([check_effective_target_arm_v8_1m_mve_fp_ok]\n+\t     && [check_effective_target_arm_little_endian])\n+\t}}]\n+}\n+\n+# Return 1 if the target supports hardware vectorization of complex additions of\n+# long, 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+proc check_effective_target_vect_complex_add_long { } {\n+    return [check_cached_effective_target_indexed vect_complex_add_long {\n+      expr {\n+\t ([check_effective_target_aarch64_sve2]\n+\t  && [check_effective_target_aarch64_little_endian])\n+\t || ([check_effective_target_arm_v8_1m_mve_fp_ok]\n+\t     && [check_effective_target_arm_little_endian])\n+\t}}]\n+}\n+\n+# Return 1 if the target supports hardware vectorization of complex additions of\n+# half, 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+proc check_effective_target_vect_complex_add_half { } {\n+    return [check_cached_effective_target_indexed vect_complex_add_half {\n+      expr {\n+\t ([check_effective_target_arm_v8_3a_fp16_complex_neon_ok]\n+\t  && ([check_effective_target_aarch64_little_endian]\n+\t      || [check_effective_target_arm_little_endian]))\n+\t || ([check_effective_target_aarch64_sve2]\n+\t      && [check_effective_target_aarch64_little_endian])\n+\t || ([check_effective_target_arm_v8_1m_mve_fp_ok]\n+\t     && [check_effective_target_arm_little_endian])\n+\t}}]\n+}\n+\n+# Return 1 if the target supports hardware vectorization of complex additions of\n+# float, 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+proc check_effective_target_vect_complex_add_float { } {\n+    return [check_cached_effective_target_indexed vect_complex_add_float {\n+      expr {\n+\t ([check_effective_target_arm_v8_3a_complex_neon_ok]\n+\t  && ([check_effective_target_aarch64_little_endian]\n+\t      || [check_effective_target_arm_little_endian]))\n+\t || ([check_effective_target_aarch64_sve2]\n+\t      && [check_effective_target_aarch64_little_endian])\n+\t || ([check_effective_target_arm_v8_1m_mve_fp_ok]\n+\t     && [check_effective_target_arm_little_endian])\n+\t}}]\n+}\n+\n+# Return 1 if the target supports hardware vectorization of complex additions of\n+# double, 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+proc check_effective_target_vect_complex_add_double { } {\n+    return [check_cached_effective_target_indexed vect_complex_add_double {\n+      expr {\n+\t ([check_effective_target_aarch64_sve2]\n+\t      && [check_effective_target_aarch64_little_endian])\n+\t}}]\n+}\n+\n+# Return 1 if the target supports signed int->float conversion\n #\n \n proc check_effective_target_vect_intfloat_cvt { } {\n@@ -10386,13 +10495,13 @@ proc check_effective_target_arm_v8_3a_complex_neon_ok_nocache { } {\n     # need to be added to the -march option.\n     foreach flags {\"\" \"-mfloat-abi=softfp -mfpu=auto\" \"-mfloat-abi=hard -mfpu=auto\"} {\n         if { [check_no_compiler_messages_nocache \\\n-                  arm_v8_3a_complex_neon_ok object {\n+                  arm_v8_3a_complex_neon_ok assembly {\n             #if !defined (__ARM_FEATURE_COMPLEX)\n             #error \"__ARM_FEATURE_COMPLEX not defined\"\n             #endif\n         } \"$flags -march=armv8.3-a\"] } {\n             set et_arm_v8_3a_complex_neon_flags \"$flags -march=armv8.3-a\"\n-            return 1\n+            return 1;\n         }\n     }\n \n@@ -10412,13 +10521,57 @@ proc add_options_for_arm_v8_3a_complex_neon { flags } {\n     return \"$flags $et_arm_v8_3a_complex_neon_flags\"\n }\n \n+# Return 1 if the target supports ARMv8.3 Adv.SIMD + FP16 Complex instructions\n+# instructions, 0 otherwise.  The test is valid for ARM and for AArch64.\n+# Record the command line options needed.\n+\n+proc check_effective_target_arm_v8_3a_fp16_complex_neon_ok_nocache { } {\n+    global et_arm_v8_3a_fp16_complex_neon_flags\n+    set et_arm_v8_3a_fp16_complex_neon_flags \"\"\n+\n+    if { ![istarget arm*-*-*] && ![istarget aarch64*-*-*] } {\n+        return 0;\n+    }\n+\n+    # Iterate through sets of options to find the compiler flags that\n+    # need to be added to the -march option.\n+    foreach flags {\"\" \"-mfloat-abi=softfp -mfpu=auto\" \"-mfloat-abi=hard -mfpu=auto\"} {\n+        if { [check_no_compiler_messages_nocache \\\n+                  arm_v8_3a_fp16_complex_neon_ok assembly {\n+            #if !defined (__ARM_FEATURE_COMPLEX)\n+            #error \"__ARM_FEATURE_COMPLEX not defined\"\n+            #endif\n+        } \"$flags -march=armv8.3-a+fp16\"] } {\n+            set et_arm_v8_3a_fp16_complex_neon_flags \\\n+\t\t\t\"$flags -march=armv8.3-a+fp16\"\n+            return 1;\n+        }\n+    }\n+\n+    return 0;\n+}\n+\n+proc check_effective_target_arm_v8_3a_fp16_complex_neon_ok { } {\n+    return [check_cached_effective_target arm_v8_3a_fp16_complex_neon_ok \\\n+                check_effective_target_arm_v8_3a_fp16_complex_neon_ok_nocache]\n+}\n+\n+proc add_options_for_arm_v8_3a_fp16_complex_neon { flags } {\n+    if { ! [check_effective_target_arm_v8_3a_fp16_complex_neon_ok] } {\n+        return \"$flags\"\n+    }\n+    global et_arm_v8_3a_fp16_complex_neon_flags\n+    return \"$flags $et_arm_v8_3a_fp16_complex_neon_flags\"\n+}\n+\n+\n # Return 1 if the target supports executing AdvSIMD instructions from ARMv8.3\n # with the complex instruction extension, 0 otherwise.  The test is valid for\n # ARM and for AArch64.\n \n proc check_effective_target_arm_v8_3a_complex_neon_hw { } {\n     if { ![check_effective_target_arm_v8_3a_complex_neon_ok] } {\n-        return 0;\n+        return 1;\n     }\n     return [check_runtime arm_v8_3a_complex_neon_hw_available {\n         #include \"arm_neon.h\"\n@@ -10443,7 +10596,7 @@ proc check_effective_target_arm_v8_3a_complex_neon_hw { } {\n                : /* No clobbers.  */);\n           #endif\n \n-          return (results[0] == 8 && results[1] == 24) ? 1 : 0;\n+          return (results[0] == 8 && results[1] == 24) ? 0 : 1;\n         }\n     } [add_options_for_arm_v8_3a_complex_neon \"\"]]\n }"}, {"sha": "52757add0e3dbae41608a1786661b326f0da9be9", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -2698,9 +2698,13 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n \t  STMT_SLP_TYPE (stmt_info) = loop_vect;\n \t  if (STMT_VINFO_IN_PATTERN_P (stmt_info))\n \t    {\n+\t      stmt_vec_info pattern_stmt_info\n+\t\t= STMT_VINFO_RELATED_STMT (stmt_info);\n+\t      if (STMT_VINFO_SLP_VECT_ONLY (pattern_stmt_info))\n+\t\tSTMT_VINFO_IN_PATTERN_P (stmt_info) = false;\n+\n \t      gimple *pattern_def_seq = STMT_VINFO_PATTERN_DEF_SEQ (stmt_info);\n-\t      stmt_info = STMT_VINFO_RELATED_STMT (stmt_info);\n-\t      STMT_SLP_TYPE (stmt_info) = loop_vect;\n+\t      STMT_SLP_TYPE (pattern_stmt_info) = loop_vect;\n \t      for (gimple_stmt_iterator pi = gsi_start (pattern_def_seq);\n \t\t   !gsi_end_p (pi); gsi_next (&pi))\n \t\tSTMT_SLP_TYPE (loop_vinfo->lookup_stmt (gsi_stmt (pi)))"}, {"sha": "bb2830d1d35d1607d1566868ffbcead97e4790d7", "filename": "gcc/tree-vect-slp-patterns.c", "status": "added", "additions": 720, "deletions": 0, "changes": 720, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftree-vect-slp-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftree-vect-slp-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp-patterns.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -0,0 +1,720 @@\n+/* SLP - Pattern matcher on SLP trees\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"target.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"tree-pass.h\"\n+#include \"ssa.h\"\n+#include \"optabs-tree.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\t\t/* FIXME: for insn_data */\n+#include \"fold-const.h\"\n+#include \"stor-layout.h\"\n+#include \"gimple-iterator.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-vectorizer.h\"\n+#include \"langhooks.h\"\n+#include \"gimple-walk.h\"\n+#include \"dbgcnt.h\"\n+#include \"tree-vector-builder.h\"\n+#include \"vec-perm-indices.h\"\n+#include \"gimple-fold.h\"\n+#include \"internal-fn.h\"\n+\n+/* SLP Pattern matching mechanism.\n+\n+  This extension to the SLP vectorizer allows one to transform the generated SLP\n+  tree based on any pattern.  The difference between this and the normal vect\n+  pattern matcher is that unlike the former, this matcher allows you to match\n+  with instructions that do not belong to the same SSA dominator graph.\n+\n+  The only requirement that this pattern matcher has is that you are only\n+  only allowed to either match an entire group or none.\n+\n+  The pattern matcher currently only allows you to perform replacements to\n+  internal functions.\n+\n+  Once the patterns are matched it is one way, these cannot be undone.  It is\n+  currently not supported to match patterns recursively.\n+\n+  To add a new pattern, implement the vect_pattern class and add the type to\n+  slp_patterns.\n+\n+*/\n+\n+/*******************************************************************************\n+ * vect_pattern class\n+ ******************************************************************************/\n+\n+/* Default implementation of recognize that performs matching, validation and\n+   replacement of nodes but that can be overriden if required.  */\n+\n+static bool\n+vect_pattern_validate_optab (internal_fn ifn, slp_tree node)\n+{\n+  tree vectype = SLP_TREE_VECTYPE (node);\n+  if (ifn == IFN_LAST || !vectype)\n+    return false;\n+\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"Found %s pattern in SLP tree\\n\",\n+\t\t     internal_fn_name (ifn));\n+\n+  if (direct_internal_fn_supported_p (ifn, vectype, OPTIMIZE_FOR_SPEED))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"Target supports %s vectorization with mode %T\\n\",\n+\t\t\t internal_fn_name (ifn), vectype);\n+    }\n+  else\n+    {\n+      if (dump_enabled_p ())\n+        {\n+\t  if (!vectype)\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"Target does not support vector type for %T\\n\",\n+\t\t\t     SLP_TREE_DEF_TYPE (node));\n+\t  else\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"Target does not support %s for vector type \"\n+\t\t\t     \"%T\\n\", internal_fn_name (ifn), vectype);\n+\t}\n+      return false;\n+    }\n+  return true;\n+}\n+\n+/*******************************************************************************\n+ * General helper types\n+ ******************************************************************************/\n+\n+/* The COMPLEX_OPERATION enum denotes the possible pair of operations that can\n+   be matched when looking for expressions that we are interested matching for\n+   complex numbers addition and mla.  */\n+\n+typedef enum _complex_operation : unsigned {\n+  PLUS_PLUS,\n+  MINUS_PLUS,\n+  PLUS_MINUS,\n+  MULT_MULT,\n+  CMPLX_NONE\n+} complex_operation_t;\n+\n+/*******************************************************************************\n+ * General helper functions\n+ ******************************************************************************/\n+\n+/* Helper function of linear_loads_p that checks to see if the load permutation\n+   is sequential and in monotonically increasing order of loads with no gaps.\n+*/\n+\n+static inline complex_perm_kinds_t\n+is_linear_load_p (load_permutation_t loads)\n+{\n+  if (loads.length() == 0)\n+    return PERM_UNKNOWN;\n+\n+  unsigned load, i;\n+  complex_perm_kinds_t candidates[4]\n+    = { PERM_EVENODD\n+      , PERM_ODDEVEN\n+      , PERM_ODDODD\n+      , PERM_EVENEVEN\n+      };\n+\n+  int valid_patterns = 4;\n+  FOR_EACH_VEC_ELT_FROM (loads, i, load, 1)\n+    {\n+      if (candidates[0] != PERM_UNKNOWN && load != i)\n+\t{\n+\t  candidates[0] = PERM_UNKNOWN;\n+\t  valid_patterns--;\n+\t}\n+      if (candidates[1] != PERM_UNKNOWN\n+\t  && load != (i % 2 == 0 ? i + 1 : i - 1))\n+\t{\n+\t  candidates[1] = PERM_UNKNOWN;\n+\t  valid_patterns--;\n+\t}\n+      if (candidates[2] != PERM_UNKNOWN && load != 1)\n+\t{\n+\t  candidates[2] = PERM_UNKNOWN;\n+\t  valid_patterns--;\n+\t}\n+      if (candidates[3] != PERM_UNKNOWN && load != 0)\n+\t{\n+\t  candidates[3] = PERM_UNKNOWN;\n+\t  valid_patterns--;\n+\t}\n+\n+      if (valid_patterns == 0)\n+\treturn PERM_UNKNOWN;\n+    }\n+\n+  for (i = 0; i < sizeof(candidates); i++)\n+    if (candidates[i] != PERM_UNKNOWN)\n+      return candidates[i];\n+\n+  return PERM_UNKNOWN;\n+}\n+\n+/* Combine complex_perm_kinds A and B into a new permute kind that describes the\n+   resulting operation.  */\n+\n+static inline complex_perm_kinds_t\n+vect_merge_perms (complex_perm_kinds_t a, complex_perm_kinds_t b)\n+{\n+  if (a == b)\n+    return a;\n+\n+  if (a == PERM_TOP)\n+    return b;\n+\n+  if (b == PERM_TOP)\n+    return a;\n+\n+  return PERM_UNKNOWN;\n+}\n+\n+/* Check to see if all loads rooted in ROOT are linear.  Linearity is\n+   defined as having no gaps between values loaded.  */\n+\n+static complex_load_perm_t\n+linear_loads_p (slp_tree_to_load_perm_map_t *perm_cache, slp_tree root)\n+{\n+  if (!root)\n+    return std::make_pair (PERM_UNKNOWN, vNULL);\n+\n+  unsigned i;\n+  complex_load_perm_t *tmp;\n+\n+  if ((tmp = perm_cache->get (root)) != NULL)\n+    return *tmp;\n+\n+  complex_load_perm_t retval = std::make_pair (PERM_UNKNOWN, vNULL);\n+  perm_cache->put (root, retval);\n+\n+  /* If it's a load node, then just read the load permute.  */\n+  if (SLP_TREE_LOAD_PERMUTATION (root).exists ())\n+    {\n+      retval.first = is_linear_load_p (SLP_TREE_LOAD_PERMUTATION (root));\n+      retval.second = SLP_TREE_LOAD_PERMUTATION (root);\n+      perm_cache->put (root, retval);\n+      return retval;\n+    }\n+  else if (SLP_TREE_DEF_TYPE (root) != vect_internal_def)\n+    {\n+      retval.first = PERM_TOP;\n+      return retval;\n+    }\n+\n+  auto_vec<load_permutation_t> all_loads;\n+  complex_perm_kinds_t kind = PERM_TOP;\n+\n+  slp_tree child;\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (root), i, child)\n+    {\n+      complex_load_perm_t res = linear_loads_p (perm_cache, child);\n+      kind = vect_merge_perms (kind, res.first);\n+      if (kind == PERM_UNKNOWN)\n+\treturn retval;\n+      all_loads.safe_push (res.second);\n+    }\n+\n+  if (SLP_TREE_LANE_PERMUTATION (root).exists ())\n+    {\n+      lane_permutation_t perm = SLP_TREE_LANE_PERMUTATION (root);\n+      load_permutation_t nloads;\n+      nloads.create (SLP_TREE_LANES (root));\n+      nloads.quick_grow (SLP_TREE_LANES (root));\n+      for (i = 0; i < SLP_TREE_LANES (root); i++)\n+\tnloads[i] = all_loads[perm[i].first][perm[i].second];\n+\n+      retval.first = kind;\n+      retval.second = nloads;\n+    }\n+  else if (all_loads.length () == 1)\n+    {\n+      retval.first = kind;\n+      retval.second = all_loads[0];\n+    }\n+\n+  perm_cache->put (root, retval);\n+  return retval;\n+}\n+\n+\n+/* This function attempts to make a node rooted in NODE is linear.  If the node\n+   if already linear than the node itself is returned in RESULT.\n+\n+   If the node is not linear then a new VEC_PERM_EXPR node is created with a\n+   lane permute that when applied will make the node linear.   If such a\n+   permute cannot be created then FALSE is returned from the function.\n+\n+   Here linearity is defined as having a sequential, monotically increasing\n+   load position inside the load permute generated by the loads reachable from\n+   NODE.  */\n+\n+static slp_tree\n+vect_build_swap_evenodd_node (slp_tree node)\n+{\n+  /* Attempt to linearise the permute.  */\n+  vec<std::pair<unsigned, unsigned> > zipped;\n+  zipped.create (SLP_TREE_LANES (node));\n+\n+  for (unsigned x = 0; x < SLP_TREE_LANES (node); x+=2)\n+    {\n+      zipped.quick_push (std::make_pair (0, x+1));\n+      zipped.quick_push (std::make_pair (0, x));\n+    }\n+\n+  /* Create the new permute node and store it instead.  */\n+  slp_tree vnode = vect_create_new_slp_node (1, VEC_PERM_EXPR);\n+  SLP_TREE_LANE_PERMUTATION (vnode) = zipped;\n+  SLP_TREE_VECTYPE (vnode) = SLP_TREE_VECTYPE (node);\n+  SLP_TREE_CHILDREN (vnode).quick_push (node);\n+  SLP_TREE_REF_COUNT (vnode) = 1;\n+  SLP_TREE_LANES (vnode) = SLP_TREE_LANES (node);\n+  SLP_TREE_REPRESENTATIVE (vnode) = SLP_TREE_REPRESENTATIVE (node);\n+  SLP_TREE_REF_COUNT (node)++;\n+  return vnode;\n+}\n+\n+/* Checks to see of the expression represented by NODE is a gimple assign with\n+   code CODE.  */\n+\n+static inline bool\n+vect_match_expression_p (slp_tree node, tree_code code)\n+{\n+  if (!node\n+      || !SLP_TREE_REPRESENTATIVE (node))\n+    return false;\n+\n+  gimple* expr = STMT_VINFO_STMT (SLP_TREE_REPRESENTATIVE (node));\n+  if (!is_gimple_assign (expr)\n+      || gimple_assign_rhs_code (expr) != code)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Check if the given lane permute in PERMUTES matches an alternating sequence\n+   of {even odd even odd ...}.  This to account for unrolled loops.  Further\n+   mode there resulting permute must be linear.   */\n+\n+static inline bool\n+vect_check_evenodd_blend (lane_permutation_t &permutes,\n+\t\t\t unsigned even, unsigned odd)\n+{\n+  if (permutes.length () == 0)\n+    return false;\n+\n+  unsigned val[2] = {even, odd};\n+  unsigned seed = 0;\n+  for (unsigned i = 0; i < permutes.length (); i++)\n+    if (permutes[i].first != val[i % 2]\n+\t|| permutes[i].second != seed++)\n+      return false;\n+\n+  return true;\n+}\n+\n+/* This function will match the two gimple expressions representing NODE1 and\n+   NODE2 in parallel and returns the pair operation that represents the two\n+   expressions in the two statements.\n+\n+   If match is successful then the corresponding complex_operation is\n+   returned and the arguments to the two matched operations are returned in OPS.\n+\n+   If TWO_OPERANDS it is expected that the LANES of the parent VEC_PERM select\n+   from the two nodes alternatingly.\n+\n+   If unsuccessful then CMPLX_NONE is returned and OPS is untouched.\n+\n+   e.g. the following gimple statements\n+\n+   stmt 0 _39 = _37 + _12;\n+   stmt 1 _6 = _38 - _36;\n+\n+   will return PLUS_MINUS along with OPS containing {_37, _12, _38, _36}.\n+*/\n+\n+static complex_operation_t\n+vect_detect_pair_op (slp_tree node1, slp_tree node2, lane_permutation_t &lanes,\n+\t\t     bool two_operands = true, vec<slp_tree> *ops = NULL)\n+{\n+  complex_operation_t result = CMPLX_NONE;\n+\n+  if (vect_match_expression_p (node1, MINUS_EXPR)\n+      && vect_match_expression_p (node2, PLUS_EXPR)\n+      && (!two_operands || vect_check_evenodd_blend (lanes, 0, 1)))\n+    result = MINUS_PLUS;\n+  else if (vect_match_expression_p (node1, PLUS_EXPR)\n+\t   && vect_match_expression_p (node2, MINUS_EXPR)\n+\t   && (!two_operands || vect_check_evenodd_blend (lanes, 0, 1)))\n+    result = PLUS_MINUS;\n+  else if (vect_match_expression_p (node1, PLUS_EXPR)\n+\t   && vect_match_expression_p (node2, PLUS_EXPR))\n+    result = PLUS_PLUS;\n+  else if (vect_match_expression_p (node1, MULT_EXPR)\n+\t   && vect_match_expression_p (node2, MULT_EXPR))\n+    result = MULT_MULT;\n+\n+  if (result != CMPLX_NONE && ops != NULL)\n+    {\n+      ops->create (2);\n+      ops->quick_push (node1);\n+      ops->quick_push (node2);\n+    }\n+  return result;\n+}\n+\n+/* Overload of vect_detect_pair_op that matches against the representative\n+   statements in the children of NODE.  It is expected that NODE has exactly\n+   two children and when TWO_OPERANDS then NODE must be a VEC_PERM.  */\n+\n+static complex_operation_t\n+vect_detect_pair_op (slp_tree node, bool two_operands = true,\n+\t\t     vec<slp_tree> *ops = NULL)\n+{\n+  if (!two_operands && SLP_TREE_CODE (node) == VEC_PERM_EXPR)\n+    return CMPLX_NONE;\n+\n+  if (SLP_TREE_CHILDREN (node).length () != 2)\n+    return CMPLX_NONE;\n+\n+  vec<slp_tree> children = SLP_TREE_CHILDREN (node);\n+  lane_permutation_t &lanes = SLP_TREE_LANE_PERMUTATION (node);\n+\n+  return vect_detect_pair_op (children[0], children[1], lanes, two_operands,\n+\t\t\t      ops);\n+}\n+\n+/*******************************************************************************\n+ * complex_pattern class\n+ ******************************************************************************/\n+\n+/* SLP Complex Numbers pattern matching.\n+\n+  As an example, the following simple loop:\n+\n+    double a[restrict N]; double b[restrict N]; double c[restrict N];\n+\n+    for (int i=0; i < N; i+=2)\n+    {\n+      c[i] = a[i] - b[i+1];\n+      c[i+1] = a[i+1] + b[i];\n+    }\n+\n+  which represents a complex addition on with a rotation of 90* around the\n+  argand plane. i.e. if `a` and `b` were complex numbers then this would be the\n+  same as `a + (b * I)`.\n+\n+  Here the expressions for `c[i]` and `c[i+1]` are independent but have to be\n+  both recognized in order for the pattern to work.  As an SLP tree this is\n+  represented as\n+\n+                +--------------------------------+\n+                |       stmt 0 *_9 = _10;        |\n+                |       stmt 1 *_15 = _16;       |\n+                +--------------------------------+\n+                                |\n+                                |\n+                                v\n+                +--------------------------------+\n+                |     stmt 0 _10 = _4 - _8;      |\n+                |    stmt 1 _16 = _12 + _14;     |\n+                | lane permutation { 0[0] 1[1] } |\n+                +--------------------------------+\n+                            |        |\n+                            |        |\n+                            |        |\n+               +-----+      |        |      +-----+\n+               |     |      |        |      |     |\n+         +-----| { } |<-----+        +----->| { } --------+\n+         |     |     |   +------------------|     |       |\n+         |     +-----+   |                  +-----+       |\n+         |        |      |                                |\n+         |        |      |                                |\n+         |        +------|------------------+             |\n+         |               |                  |             |\n+         v               v                  v             v\n+     +--------------------------+     +--------------------------------+\n+     |     stmt 0 _8 = *_7;     |     |        stmt 0 _4 = *_3;        |\n+     |    stmt 1 _14 = *_13;    |     |       stmt 1 _12 = *_11;       |\n+     | load permutation { 1 0 } |     |    load permutation { 0 1 }    |\n+     +--------------------------+     +--------------------------------+\n+\n+  The pattern matcher allows you to replace both statements 0 and 1 or none at\n+  all.  Because this operation is a two operands operation the actual nodes\n+  being replaced are those in the { } nodes.  The actual scalar statements\n+  themselves are not replaced or used during the matching but instead the\n+  SLP_TREE_REPRESENTATIVE statements are inspected.  You are also allowed to\n+  replace and match on any number of nodes.\n+\n+  Because the pattern matcher matches on the representative statement for the\n+  SLP node the case of two_operators it allows you to match the children of the\n+  node.  This is done using the method `recognize ()`.\n+\n+*/\n+\n+/* The complex_pattern class contains common code for pattern matchers that work\n+   on complex numbers.  These provide functionality to allow de-construction and\n+   validation of sequences depicting/transforming REAL and IMAG pairs.  */\n+\n+class complex_pattern : public vect_pattern\n+{\n+  protected:\n+    auto_vec<slp_tree> m_workset;\n+    complex_pattern (slp_tree *node, vec<slp_tree> *m_ops, internal_fn ifn)\n+      : vect_pattern (node, m_ops, ifn)\n+    {\n+      this->m_workset.safe_push (*node);\n+    }\n+\n+  public:\n+    void build (vec_info *);\n+\n+    static internal_fn\n+    matches (complex_operation_t op, slp_tree_to_load_perm_map_t *,\n+\t     vec<slp_tree> *);\n+};\n+\n+/* Create a replacement pattern statement for each node in m_node and inserts\n+   the new statement into m_node as the new representative statement.  The old\n+   statement is marked as being in a pattern defined by the new statement.  The\n+   statement is created as call to internal function IFN with m_num_args\n+   arguments.\n+\n+   Futhermore the new pattern is also added to the vectorization information\n+   structure VINFO and the old statement STMT_INFO is marked as unused while\n+   the new statement is marked as used and the number of SLP uses of the new\n+   statement is incremented.\n+\n+   The newly created SLP nodes are marked as SLP only and will be dissolved\n+   if SLP is aborted.\n+\n+   The newly created gimple call is returned and the BB remains unchanged.\n+\n+   This default method is designed to only match against simple operands where\n+   all the input and output types are the same.\n+*/\n+\n+void\n+complex_pattern::build (vec_info *vinfo)\n+{\n+  stmt_vec_info stmt_info;\n+\n+  auto_vec<tree> args;\n+  args.create (this->m_num_args);\n+  args.quick_grow_cleared (this->m_num_args);\n+  slp_tree node;\n+  unsigned ix;\n+  stmt_vec_info call_stmt_info;\n+  gcall *call_stmt = NULL;\n+\n+  /* Now modify the nodes themselves.  */\n+  FOR_EACH_VEC_ELT (this->m_workset, ix, node)\n+    {\n+      /* Calculate the location of the statement in NODE to replace.  */\n+      stmt_info = SLP_TREE_REPRESENTATIVE (node);\n+      gimple* old_stmt = STMT_VINFO_STMT (stmt_info);\n+      tree lhs_old_stmt = gimple_get_lhs (old_stmt);\n+      tree type = TREE_TYPE (lhs_old_stmt);\n+\n+      /* Create the argument set for use by gimple_build_call_internal_vec.  */\n+      for (unsigned i = 0; i < this->m_num_args; i++)\n+\targs[i] = lhs_old_stmt;\n+\n+      /* Create the new pattern statements.  */\n+      call_stmt = gimple_build_call_internal_vec (this->m_ifn, args);\n+      tree var = make_temp_ssa_name (type, call_stmt, \"slp_patt\");\n+      gimple_call_set_lhs (call_stmt, var);\n+      gimple_set_location (call_stmt, gimple_location (old_stmt));\n+      gimple_call_set_nothrow (call_stmt, true);\n+\n+      /* Adjust the book-keeping for the new and old statements for use during\n+\t SLP.  This is required to get the right VF and statement during SLP\n+\t analysis.  These changes are created after relevancy has been set for\n+\t the nodes as such we need to manually update them.  Any changes will be\n+\t undone if SLP is cancelled.  */\n+      call_stmt_info\n+\t= vinfo->add_pattern_stmt (call_stmt, stmt_info);\n+\n+      /* Make sure to mark the representative statement pure_slp and\n+\t relevant. */\n+      STMT_VINFO_RELEVANT (call_stmt_info) = vect_used_in_scope;\n+      STMT_SLP_TYPE (call_stmt_info) = pure_slp;\n+\n+      /* add_pattern_stmt can't be done in vect_mark_pattern_stmts because\n+\t the non-SLP pattern matchers already have added the statement to VINFO\n+\t by the time it is called.  Some of them need to modify the returned\n+\t stmt_info.  vect_mark_pattern_stmts is called by recog_pattern and it\n+\t would increase the size of each pattern with boilerplate code to make\n+\t the call there.  */\n+      vect_mark_pattern_stmts (vinfo, stmt_info, call_stmt,\n+\t\t\t       SLP_TREE_VECTYPE (node));\n+      STMT_VINFO_SLP_VECT_ONLY (call_stmt_info) = true;\n+\n+      /* Since we are replacing all the statements in the group with the same\n+\t thing it doesn't really matter.  So just set it every time a new stmt\n+\t is created.  */\n+      SLP_TREE_REPRESENTATIVE (node) = call_stmt_info;\n+      SLP_TREE_LANE_PERMUTATION (node).release ();\n+      SLP_TREE_CODE (node) = CALL_EXPR;\n+    }\n+}\n+\n+/*******************************************************************************\n+ * complex_add_pattern class\n+ ******************************************************************************/\n+\n+class complex_add_pattern : public complex_pattern\n+{\n+  protected:\n+    complex_add_pattern (slp_tree *node, vec<slp_tree> *m_ops, internal_fn ifn)\n+      : complex_pattern (node, m_ops, ifn)\n+    {\n+      this->m_num_args = 2;\n+    }\n+\n+  public:\n+    void build (vec_info *);\n+    static internal_fn\n+    matches (complex_operation_t op, slp_tree_to_load_perm_map_t *,\n+\t     vec<slp_tree> *);\n+\n+    static vect_pattern*\n+    recognize (slp_tree_to_load_perm_map_t *, slp_tree *);\n+};\n+\n+/* Perform a replacement of the detected complex add pattern with the new\n+   instruction sequences.  */\n+\n+void\n+complex_add_pattern::build (vec_info *vinfo)\n+{\n+  auto_vec<slp_tree> nodes;\n+  slp_tree node = this->m_ops[0];\n+  vec<slp_tree> children = SLP_TREE_CHILDREN (node);\n+\n+  /* First re-arrange the children.  */\n+  nodes.create (children.length ());\n+  nodes.quick_push (children[0]);\n+  nodes.quick_push (vect_build_swap_evenodd_node (children[1]));\n+\n+  SLP_TREE_CHILDREN (*this->m_node).truncate (0);\n+  SLP_TREE_CHILDREN (*this->m_node).safe_splice (nodes);\n+\n+  complex_pattern::build (vinfo);\n+}\n+\n+/* Pattern matcher for trying to match complex addition pattern in SLP tree.\n+\n+   If no match is found then IFN is set to IFN_LAST.\n+   This function matches the patterns shaped as:\n+\n+   c[i] = a[i] - b[i+1];\n+   c[i+1] = a[i+1] + b[i];\n+\n+   If a match occurred then TRUE is returned, else FALSE.  The initial match is\n+   expected to be in OP1 and the initial match operands in args0.  */\n+\n+internal_fn\n+complex_add_pattern::matches (complex_operation_t op,\n+\t\t\t      slp_tree_to_load_perm_map_t *perm_cache,\n+\t\t\t      vec<slp_tree> *ops)\n+{\n+  internal_fn ifn = IFN_LAST;\n+\n+  /* Find the two components.  Rotation in the complex plane will modify\n+     the operations:\n+\n+      * Rotation  0: + +\n+      * Rotation 90: - +\n+      * Rotation 180: - -\n+      * Rotation 270: + -\n+\n+      Rotation 0 and 180 can be handled by normal SIMD code, so we don't need\n+      to care about them here.  */\n+  if (op == MINUS_PLUS)\n+    ifn = IFN_COMPLEX_ADD_ROT90;\n+  else if (op == PLUS_MINUS)\n+    ifn = IFN_COMPLEX_ADD_ROT270;\n+  else\n+    return ifn;\n+\n+  /* verify that there is a permute, otherwise this isn't a pattern we\n+     we support.  */\n+  gcc_assert (ops->length () == 2);\n+\n+  vec<slp_tree> children = SLP_TREE_CHILDREN ((*ops)[0]);\n+\n+  /* First node must be unpermuted.  */\n+  if (linear_loads_p (perm_cache, children[0]).first != PERM_EVENODD)\n+    return IFN_LAST;\n+\n+  /* Second node must be permuted.  */\n+  if (linear_loads_p (perm_cache, children[1]).first != PERM_ODDEVEN)\n+    return IFN_LAST;\n+\n+  return ifn;\n+}\n+\n+/* Attempt to recognize a complex add pattern.  */\n+\n+vect_pattern*\n+complex_add_pattern::recognize (slp_tree_to_load_perm_map_t *perm_cache,\n+\t\t\t\tslp_tree *node)\n+{\n+  auto_vec<slp_tree> ops;\n+  complex_operation_t op\n+    = vect_detect_pair_op (*node, true, &ops);\n+  internal_fn ifn = complex_add_pattern::matches (op, perm_cache, &ops);\n+  if (!vect_pattern_validate_optab (ifn, *node))\n+    return NULL;\n+\n+  return new complex_add_pattern (node, &ops, ifn);\n+}\n+\n+/*******************************************************************************\n+ * Pattern matching definitions\n+ ******************************************************************************/\n+\n+#define SLP_PATTERN(x) &x::recognize\n+vect_pattern_decl_t slp_patterns[]\n+{\n+  /* For least amount of back-tracking and more efficient matching\n+     order patterns from the largest to the smallest.  Especially if they\n+     overlap in what they can detect.  */\n+\n+  SLP_PATTERN (complex_add_pattern),\n+};\n+#undef SLP_PATTERN\n+\n+/* Set the number of SLP pattern matchers available.  */\n+size_t num__slp_patterns = sizeof(slp_patterns)/sizeof(vect_pattern_decl_t);"}, {"sha": "2a58e54fe51471df5f55ce4a524d0022744054b0", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 107, "deletions": 12, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -133,7 +133,7 @@ _slp_tree::~_slp_tree ()\n \n /* Recursively free the memory allocated for the SLP tree rooted at NODE.  */\n \n-static void\n+void\n vect_free_slp_tree (slp_tree node)\n {\n   int i;\n@@ -177,17 +177,26 @@ vect_free_slp_instance (slp_instance instance)\n /* Create an SLP node for SCALAR_STMTS.  */\n \n slp_tree\n+vect_create_new_slp_node (unsigned nops, tree_code code)\n+{\n+  slp_tree node = new _slp_tree;\n+  SLP_TREE_SCALAR_STMTS (node) = vNULL;\n+  SLP_TREE_CHILDREN (node).create (nops);\n+  SLP_TREE_DEF_TYPE (node) = vect_internal_def;\n+  SLP_TREE_CODE (node) = code;\n+  return node;\n+}\n+/* Create an SLP node for SCALAR_STMTS.  */\n+\n+static slp_tree\n vect_create_new_slp_node (slp_tree node,\n \t\t\t  vec<stmt_vec_info> scalar_stmts, unsigned nops)\n {\n   SLP_TREE_SCALAR_STMTS (node) = scalar_stmts;\n   SLP_TREE_CHILDREN (node).create (nops);\n   SLP_TREE_DEF_TYPE (node) = vect_internal_def;\n-  if (scalar_stmts.exists ())\n-    {\n-      SLP_TREE_REPRESENTATIVE (node) = scalar_stmts[0];\n-      SLP_TREE_LANES (node) = scalar_stmts.length ();\n-    }\n+  SLP_TREE_REPRESENTATIVE (node) = scalar_stmts[0];\n+  SLP_TREE_LANES (node) = scalar_stmts.length ();\n   return node;\n }\n \n@@ -239,7 +248,7 @@ typedef struct _slp_oprnd_info\n \n /* Allocate operands info for NOPS operands, and GROUP_SIZE def-stmts for each\n    operand.  */\n-static vec<slp_oprnd_info> \n+static vec<slp_oprnd_info>\n vect_create_oprnd_info (int nops, int group_size)\n {\n   int i;\n@@ -1136,7 +1145,7 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t    {\n \t      if (dump_enabled_p ())\n \t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t   \"Build SLP failed: different operation \"\n \t\t\t\t   \"in stmt %G\", stmt);\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -2219,6 +2228,84 @@ calculate_unrolling_factor (poly_uint64 nunits, unsigned int group_size)\n   return exact_div (common_multiple (nunits, group_size), group_size);\n }\n \n+/* Helper function of vect_match_slp_patterns.\n+\n+   Attempts to match patterns against the slp tree rooted in REF_NODE using\n+   VINFO.  Patterns are matched in post-order traversal.\n+\n+   If matching is successful the value in REF_NODE is updated and returned, if\n+   not then it is returned unchanged.  */\n+\n+static bool\n+vect_match_slp_patterns_2 (slp_tree *ref_node, vec_info *vinfo,\n+\t\t\t   slp_tree_to_load_perm_map_t *perm_cache,\n+\t\t\t   hash_set<slp_tree> *visited)\n+{\n+  unsigned i;\n+  slp_tree node = *ref_node;\n+  bool found_p = false;\n+  if (!node || visited->add (node))\n+    return false;\n+\n+  slp_tree child;\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n+    found_p |= vect_match_slp_patterns_2 (&SLP_TREE_CHILDREN (node)[i],\n+\t\t\t\t\t  vinfo, perm_cache, visited);\n+\n+  for (unsigned x = 0; x < num__slp_patterns; x++)\n+    {\n+      vect_pattern *pattern = slp_patterns[x] (perm_cache, ref_node);\n+      if (pattern)\n+\t{\n+\t  pattern->build (vinfo);\n+\t  delete pattern;\n+\t  found_p = true;\n+\t}\n+    }\n+\n+  return found_p;\n+}\n+\n+/* Applies pattern matching to the given SLP tree rooted in REF_NODE using\n+   vec_info VINFO.\n+\n+   The modified tree is returned.  Patterns are tried in order and multiple\n+   patterns may match.  */\n+\n+static bool\n+vect_match_slp_patterns (slp_instance instance, vec_info *vinfo,\n+\t\t\t hash_set<slp_tree> *visited,\n+\t\t\t slp_tree_to_load_perm_map_t *perm_cache,\n+\t\t\t scalar_stmts_to_slp_tree_map_t * /* bst_map */)\n+{\n+  DUMP_VECT_SCOPE (\"vect_match_slp_patterns\");\n+  slp_tree *ref_node = &SLP_INSTANCE_TREE (instance);\n+\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"Analyzing SLP tree %p for patterns\\n\",\n+\t\t     SLP_INSTANCE_TREE (instance));\n+\n+  bool found_p\n+    = vect_match_slp_patterns_2 (ref_node, vinfo, perm_cache, visited);\n+\n+  if (found_p)\n+    {\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"Pattern matched SLP tree\\n\");\n+\t  vect_print_slp_graph (MSG_NOTE, vect_location, *ref_node);\n+\t}\n+    }\n+\n+  return found_p;\n+}\n+\n+/* Analyze an SLP instance starting from a group of grouped stores.  Call\n+   vect_build_slp_tree to build a tree of packed stmts if possible.\n+   Return FALSE if it's impossible to SLP any stmt in the loop.  */\n+\n static bool\n vect_analyze_slp_instance (vec_info *vinfo,\n \t\t\t   scalar_stmts_to_slp_tree_map_t *bst_map,\n@@ -2586,6 +2673,7 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n {\n   unsigned int i;\n   stmt_vec_info first_element;\n+  slp_instance instance;\n \n   DUMP_VECT_SCOPE (\"vect_analyze_slp\");\n \n@@ -2648,6 +2736,13 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n \t\t\t\t   &limit);\n     }\n \n+  hash_set<slp_tree> visited_patterns;\n+  slp_tree_to_load_perm_map_t perm_cache;\n+  /* See if any patterns can be found in the SLP tree.  */\n+  FOR_EACH_VEC_ELT (LOOP_VINFO_SLP_INSTANCES (vinfo), i, instance)\n+    vect_match_slp_patterns (instance, vinfo, &visited_patterns, &perm_cache,\n+\t\t\t     bst_map);\n+\n   /* The map keeps a reference on SLP nodes built, release that.  */\n   for (scalar_stmts_to_slp_tree_map_t::iterator it = bst_map->begin ();\n        it != bst_map->end (); ++it)\n@@ -3973,7 +4068,7 @@ vect_bb_partition_graph (bb_vec_info bb_vinfo)\n    and return it.  Do not account defs that are marked in LIFE and\n    update LIFE according to uses of NODE.  */\n \n-static void \n+static void\n vect_bb_slp_scalar_cost (vec_info *vinfo,\n \t\t\t slp_tree node, vec<bool, va_heap> *life,\n \t\t\t stmt_vector_for_cost *cost_vec,\n@@ -3984,7 +4079,7 @@ vect_bb_slp_scalar_cost (vec_info *vinfo,\n   slp_tree child;\n \n   if (visited.add (node))\n-    return; \n+    return;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)\n     {\n@@ -4415,7 +4510,7 @@ vect_slp_analyze_bb_1 (bb_vec_info bb_vinfo, int n_stmts, bool &fatal,\n \t{\n \t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t   \"Failed to SLP the basic block.\\n\");\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t   \"not vectorized: failed to find SLP opportunities \"\n \t\t\t   \"in basic block.\\n\");\n \t}\n@@ -5297,7 +5392,7 @@ vect_transform_slp_perm_load (vec_info *vinfo,\n \t  if (!analyze_only)\n \t    {\n \t      tree mask_vec = NULL_TREE;\n-\t\t  \n+\n \t      if (! noop_p)\n \t\tmask_vec = vect_gen_perm_mask_checked (vectype, indices);\n "}, {"sha": "66e6b501d52347258ed20e6f40f88fcfae71bc4c", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ed472af6bc9f83b7a8ac553b282f659a0bf53f7/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=3ed472af6bc9f83b7a8ac553b282f659a0bf53f7", "patch": "@@ -26,6 +26,7 @@ typedef class _stmt_vec_info *stmt_vec_info;\n #include \"tree-data-ref.h\"\n #include \"tree-hash-traits.h\"\n #include \"target.h\"\n+#include \"internal-fn.h\"\n \n \n /* Used for naming of new temporaries.  */\n@@ -2008,7 +2009,8 @@ extern void duplicate_and_interleave (vec_info *, gimple_seq *, tree,\n \t\t\t\t      vec<tree>, unsigned int, vec<tree> &);\n extern int vect_get_place_in_interleaving_chain (stmt_vec_info, stmt_vec_info);\n extern bool vect_update_shared_vectype (stmt_vec_info, tree);\n-extern slp_tree vect_create_new_slp_node (vec<stmt_vec_info>, unsigned);\n+extern slp_tree vect_create_new_slp_node (unsigned, tree_code);\n+extern void vect_free_slp_tree (slp_tree);\n \n /* In tree-vect-patterns.c.  */\n extern void\n@@ -2025,4 +2027,84 @@ void vect_free_loop_info_assumptions (class loop *);\n gimple *vect_loop_vectorized_call (class loop *, gcond **cond = NULL);\n bool vect_stmt_dominates_stmt_p (gimple *, gimple *);\n \n+/* SLP Pattern matcher types, tree-vect-slp-patterns.c.  */\n+\n+/* Forward declaration of possible two operands operation that can be matched\n+   by the complex numbers pattern matchers.  */\n+enum _complex_operation : unsigned;\n+\n+/* All possible load permute values that could result from the partial data-flow\n+   analysis.  */\n+typedef enum _complex_perm_kinds {\n+   PERM_UNKNOWN,\n+   PERM_EVENODD,\n+   PERM_ODDEVEN,\n+   PERM_ODDODD,\n+   PERM_EVENEVEN,\n+   /* Can be combined with any other PERM values.  */\n+   PERM_TOP\n+} complex_perm_kinds_t;\n+\n+/* A pair with a load permute and a corresponding complex_perm_kind which gives\n+   information about the load it represents.  */\n+typedef std::pair<complex_perm_kinds_t, load_permutation_t>\n+  complex_load_perm_t;\n+\n+/* Cache from nodes to the load permutation they represent.  */\n+typedef hash_map <slp_tree, complex_load_perm_t>\n+  slp_tree_to_load_perm_map_t;\n+\n+/* Vector pattern matcher base class.  All SLP pattern matchers must inherit\n+   from this type.  */\n+\n+class vect_pattern\n+{\n+  protected:\n+    /* The number of arguments that the IFN requires.  */\n+    unsigned m_num_args;\n+\n+    /* The internal function that will be used when a pattern is created.  */\n+    internal_fn m_ifn;\n+\n+    /* The current node being inspected.  */\n+    slp_tree *m_node;\n+\n+    /* The list of operands to be the children for the node produced when the\n+       internal function is created.  */\n+    vec<slp_tree> m_ops;\n+\n+    /* Default constructor where NODE is the root of the tree to inspect.  */\n+    vect_pattern (slp_tree *node, vec<slp_tree> *m_ops, internal_fn ifn)\n+    {\n+      this->m_ifn = ifn;\n+      this->m_node = node;\n+      this->m_ops.create (0);\n+      this->m_ops.safe_splice (*m_ops);\n+    }\n+\n+  public:\n+\n+    /* Create a new instance of the pattern matcher class of the given type.  */\n+    static vect_pattern* recognize (slp_tree_to_load_perm_map_t *, slp_tree *);\n+\n+    /* Build the pattern from the data collected so far.  */\n+    virtual void build (vec_info *) = 0;\n+\n+    /* Default destructor.  */\n+    virtual ~vect_pattern ()\n+    {\n+\tthis->m_ops.release ();\n+    }\n+};\n+\n+/* Function pointer to create a new pattern matcher from a generic type.  */\n+typedef vect_pattern* (*vect_pattern_decl_t) (slp_tree_to_load_perm_map_t *,\n+\t\t\t\t\t      slp_tree *);\n+\n+/* List of supported pattern matchers.  */\n+extern vect_pattern_decl_t slp_patterns[];\n+\n+/* Number of supported pattern matchers.  */\n+extern size_t num__slp_patterns;\n+\n #endif  /* GCC_TREE_VECTORIZER_H  */"}]}