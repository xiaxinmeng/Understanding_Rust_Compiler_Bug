{"sha": "ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ3NmNlZjg0YzY3NWYyN2Q0ZTA0Mjg0YzFjZjhjMmI2NTlkODJlYQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2004-07-14T07:30:23Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-07-14T07:30:23Z"}, "message": "expr.c (enqueue_insn, [...]): Remove.\n\n2004-07-14  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* expr.c (enqueue_insn, finish_expr_for_function,\n\tprotect_from_queue, queued_subexp_p, mark_queue,\n\temit_insns_enqueued_after_mark, emit_queue,\n\texpand_increment): Remove.\n\t(store_constructor): Expand increment as an assignment.\n\t(expand_expr_real_1 <case PREINCREMENT_EXPR,\n\tcase PREDECREMENT_EXPR, case POSTINCREMENT_EXPR,\n\tcase POSTDECREMENT_EXPR>): Abort.\n\t* expr.h (QUEUED_VAR, QUEUED_INSN, QUEUED_COPY,\n\tQUEUED_BODY, QUEUED_NEXT, finish_expr_for_function,\n\tprotect_from_queue, emit_queue, queued_subexp_p): Remove.\n\t* function.h (pending_chain, x_pending_chain): Remove.\n\t* rtl.def (QUEUED): Remove.\n\n\t* emit-rtl.c (copy_insn_1, copy_most_rtx,\n\tset_used_flags, verify_rtx_sharing): Remove references to QUEUED.\n\t* genattrtab.c (attr_copy_rtx, clear_struct_flag,\n\tencode_units_mask): Likewise.\n\t* local-alloc.c (equiv_init_varies_p): Likewise.\n\t* rtl.c (copy_rtx): Likewise.\n\t* rtlanal.c (rtx_unstable_p, rtx_varies_p): Likewise.\n\t* simplify-rtx.c (simplify_gen_subreg): Likewise.\n\t* config/mn10300/mn10300.c (legitimate_pic_operand_p): Likewise.\n\n\t* builtins.c (expand_builtin, expand_builtin_apply,\n\texpand_builtin_mathfn, expand_builtin_mathfn_2,\n\texpand_builtin_mathfn_3, expand_builtin_setjmp_setup):\n\tRemove calls to emit_queue and protect_from_queue.\n\t* calls.c (expand_call, precompute_arguments,\n\tprecompute_register_parameters, rtx_for_function_call,\n\tstore_one_arg): Likewise.\n\t* dojump.c (do_compare_and_jump, do_jump): Likewise.\n\t* explow.c (memory_address): Likewise.\n\t* expmed.c (clear_by_pieces_1, clear_storage,\n\tclear_storage_via_libcall, emit_group_load,\n\temit_group_store, emit_store_flag,\n\texpand_expr_real_1, store_by_pieces,\n\tstore_constructor, store_expr, try_casesi,\n\ttry_tablejump): Likewise.\n\t* function.c (expand_pending_sizes): Likewise.\n\t* optabs.c (emit_cmp_and_jump_insns,\n\temit_conditional_add, emit_conditional_move,\n\texpand_fix, expand_float, prepare_cmp_insn): Likewise.\n\t* stmt.c (emit_case_bit_tests,\n\texpand_asm_expr, expand_computed_goto,\n\texpand_decl_init, expand_end_case_type,\n\texpand_end_stmt_expr, expand_expr_stmt_value,\n\texpand_return, expand_start_case,\n\toptimize_tail_recursion): Likewise.\n\t* config/c4x/c4x.c (c4x_expand_builtin): Likewise.\n\t* config/s390/s390.c (s390_expand_cmpmem): Likewise.\n\nFrom-SVN: r84675", "tree": {"sha": "24070b8bb3608402594a7c1884532c74eaa969a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24070b8bb3608402594a7c1884532c74eaa969a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "780028b6cff77a9f25f75a24047ab5f3b50a4834", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/780028b6cff77a9f25f75a24047ab5f3b50a4834", "html_url": "https://github.com/Rust-GCC/gccrs/commit/780028b6cff77a9f25f75a24047ab5f3b50a4834"}], "stats": {"total": 960, "additions": 100, "deletions": 860}, "files": [{"sha": "1d34c8919bd1979dae346e7ce70ade80fa86d23e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "patch": "@@ -1,3 +1,57 @@\n+2004-07-14  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* expr.c (enqueue_insn, finish_expr_for_function,\n+\tprotect_from_queue, queued_subexp_p, mark_queue,\n+\temit_insns_enqueued_after_mark, emit_queue,\n+\texpand_increment): Remove.\n+\t(store_constructor): Expand increment as an assignment.\n+\t(expand_expr_real_1 <case PREINCREMENT_EXPR,\n+\tcase PREDECREMENT_EXPR, case POSTINCREMENT_EXPR,\n+\tcase POSTDECREMENT_EXPR>): Abort.\n+\t* expr.h (QUEUED_VAR, QUEUED_INSN, QUEUED_COPY,\n+\tQUEUED_BODY, QUEUED_NEXT, finish_expr_for_function,\n+\tprotect_from_queue, emit_queue, queued_subexp_p): Remove.\n+\t* function.h (pending_chain, x_pending_chain): Remove.\n+\t* rtl.def (QUEUED): Remove.\n+\n+\t* emit-rtl.c (copy_insn_1, copy_most_rtx,\n+\tset_used_flags, verify_rtx_sharing): Remove references to QUEUED.\n+\t* genattrtab.c (attr_copy_rtx, clear_struct_flag,\n+\tencode_units_mask): Likewise.\n+\t* local-alloc.c (equiv_init_varies_p): Likewise.\n+\t* rtl.c (copy_rtx): Likewise.\n+\t* rtlanal.c (rtx_unstable_p, rtx_varies_p): Likewise.\n+\t* simplify-rtx.c (simplify_gen_subreg): Likewise.\n+\t* config/mn10300/mn10300.c (legitimate_pic_operand_p): Likewise.\n+\n+\t* builtins.c (expand_builtin, expand_builtin_apply,\n+\texpand_builtin_mathfn, expand_builtin_mathfn_2,\n+\texpand_builtin_mathfn_3, expand_builtin_setjmp_setup):\n+\tRemove calls to emit_queue and protect_from_queue.\n+\t* calls.c (expand_call, precompute_arguments,\n+\tprecompute_register_parameters, rtx_for_function_call,\n+\tstore_one_arg): Likewise.\n+\t* dojump.c (do_compare_and_jump, do_jump): Likewise.\n+\t* explow.c (memory_address): Likewise.\n+\t* expmed.c (clear_by_pieces_1, clear_storage,\n+\tclear_storage_via_libcall, emit_group_load,\n+\temit_group_store, emit_store_flag,\n+\texpand_expr_real_1, store_by_pieces,\n+\tstore_constructor, store_expr, try_casesi,\n+\ttry_tablejump): Likewise.\n+\t* function.c (expand_pending_sizes): Likewise.\n+\t* optabs.c (emit_cmp_and_jump_insns,\n+\temit_conditional_add, emit_conditional_move,\n+\texpand_fix, expand_float, prepare_cmp_insn): Likewise.\n+\t* stmt.c (emit_case_bit_tests,\n+\texpand_asm_expr, expand_computed_goto,\n+\texpand_decl_init, expand_end_case_type,\n+\texpand_end_stmt_expr, expand_expr_stmt_value,\n+\texpand_return, expand_start_case,\n+\toptimize_tail_recursion): Likewise.\n+\t* config/c4x/c4x.c (c4x_expand_builtin): Likewise.\n+\t* config/s390/s390.c (s390_expand_cmpmem): Likewise.\n+\n 2004-07-14  Ben Elliston  <bje@au.ibm.com>\n \n \t* vec.h: Comment fix."}, {"sha": "58eafd403afa110c1c5e45e0164540df71dd4b8a", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "patch": "@@ -524,8 +524,6 @@ expand_builtin_setjmp_setup (rtx buf_addr, rtx receiver_label)\n \n   buf_addr = force_reg (Pmode, force_operand (buf_addr, NULL_RTX));\n \n-  emit_queue ();\n-\n   /* We store the frame pointer and the address of receiver_label in\n      the buffer and use the rest of it for the stack save area, which\n      is machine-dependent.  */\n@@ -961,9 +959,8 @@ expand_builtin_prefetch (tree arglist)\n \t}\n       emit_insn (gen_prefetch (op0, op1, op2));\n     }\n-  else\n #endif\n-    op0 = protect_from_queue (op0, 0);\n+\n   /* Don't do anything with direct references to volatile memory, but\n      generate code to handle other side effects.  */\n   if (!MEM_P (op0) && side_effects_p (op0))\n@@ -1272,9 +1269,6 @@ expand_builtin_apply (rtx function, rtx arguments, rtx argsize)\n \t\t\t\t       incoming_args, 0, OPTAB_LIB_WIDEN);\n #endif\n \n-  /* Perform postincrements before actually calling the function.  */\n-  emit_queue ();\n-\n   /* Push a new argument block and copy the arguments.  Do not allow\n      the (potential) memcpy call below to interfere with our stack\n      manipulations.  */\n@@ -1778,7 +1772,6 @@ expand_builtin_mathfn (tree exp, rtx target, rtx subtarget)\n \n       op0 = expand_expr (arg, subtarget, VOIDmode, 0);\n \n-      emit_queue ();\n       start_sequence ();\n \n       /* Compute into TARGET.\n@@ -1933,7 +1926,6 @@ expand_builtin_mathfn_2 (tree exp, rtx target, rtx subtarget)\n   op0 = expand_expr (arg0, subtarget, VOIDmode, 0);\n   op1 = expand_expr (arg1, 0, VOIDmode, 0);\n \n-  emit_queue ();\n   start_sequence ();\n \n   /* Compute into TARGET.\n@@ -2038,7 +2030,6 @@ expand_builtin_mathfn_3 (tree exp, rtx target, rtx subtarget)\n \n       op0 = expand_expr (arg, subtarget, VOIDmode, 0);\n \n-      emit_queue ();\n       start_sequence ();\n \n       /* Compute into TARGET.\n@@ -5694,9 +5685,6 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n   enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n   enum machine_mode target_mode = TYPE_MODE (TREE_TYPE (exp));\n \n-  /* Perform postincrements before expanding builtin functions.  */\n-  emit_queue ();\n-\n   if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD)\n     return targetm.expand_builtin (exp, target, subtarget, mode, ignore);\n "}, {"sha": "d348321250b275ce10dc809efcad3773a47639ec", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "patch": "@@ -163,8 +163,6 @@ rtx\n prepare_call_address (rtx funexp, rtx static_chain_value,\n \t\t      rtx *call_fusage, int reg_parm_seen, int sibcallp)\n {\n-  funexp = protect_from_queue (funexp, 0);\n-\n   /* Make a valid memory address and copy constants through pseudo-regs,\n      but not for a constant address if -fno-function-cse.  */\n   if (GET_CODE (funexp) != SYMBOL_REF)\n@@ -663,10 +661,6 @@ precompute_register_parameters (int num_actuals, struct arg_data *args, int *reg\n \t\t\t\t\t VOIDmode, 0);\n \t    preserve_temp_slots (args[i].value);\n \t    pop_temp_slots ();\n-\n-\t    /* ANSI doesn't require a sequence point here,\n-\t       but PCC has one, so this will avoid some problems.  */\n-\t    emit_queue ();\n \t  }\n \n \t/* If the value is a non-legitimate constant, force it into a\n@@ -1256,15 +1250,8 @@ precompute_arguments (int flags, int num_actuals, struct arg_data *args)\n       if (TREE_ADDRESSABLE (TREE_TYPE (args[i].tree_value)))\n \tabort ();\n \n-      args[i].value\n-\t= expand_expr (args[i].tree_value, NULL_RTX, VOIDmode, 0);\n-\n-      /* ANSI doesn't require a sequence point here,\n-\t but PCC has one, so this will avoid some problems.  */\n-      emit_queue ();\n-\n       args[i].initial_value = args[i].value\n-\t= protect_from_queue (args[i].value, 0);\n+\t= expand_expr (args[i].tree_value, NULL_RTX, VOIDmode, 0);\n \n       mode = TYPE_MODE (TREE_TYPE (args[i].tree_value));\n       if (mode != args[i].mode)\n@@ -1439,7 +1426,6 @@ rtx_for_function_call (tree fndecl, tree addr)\n       push_temp_slots ();\n       funexp = expand_expr (addr, NULL_RTX, VOIDmode, 0);\n       pop_temp_slots ();\t/* FUNEXP can't be BLKmode.  */\n-      emit_queue ();\n     }\n   return funexp;\n }\n@@ -2365,10 +2351,6 @@ expand_call (tree exp, rtx target, int ignore)\n \n       if (pass == 0)\n \t{\n-\t  /* Emit any queued insns now; otherwise they would end up in\n-             only one of the alternates.  */\n-\t  emit_queue ();\n-\n \t  /* State variables we need to save and restore between\n \t     iterations.  */\n \t  save_pending_stack_adjust = pending_stack_adjust;\n@@ -2790,9 +2772,6 @@ expand_call (tree exp, rtx target, int ignore)\n       load_register_parameters (args, num_actuals, &call_fusage, flags,\n \t\t\t\tpass == 0, &sibcall_failure);\n \n-      /* Perform postincrements before actually calling the function.  */\n-      emit_queue ();\n-\n       /* Save a pointer to the last insn before the call, so that we can\n \t later safely search backwards to find the CALL_INSN.  */\n       before_call = get_last_insn ();\n@@ -3548,9 +3527,6 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t  || (GET_MODE (val) != mode && GET_MODE (val) != VOIDmode))\n \tabort ();\n \n-      /* There's no need to call protect_from_queue, because\n-\t either emit_move_insn or emit_push_insn will do that.  */\n-\n       /* Make sure it is a reasonable operand for a move or push insn.  */\n       if (!REG_P (val) && !MEM_P (val)\n \t  && ! (CONSTANT_P (val) && LEGITIMATE_CONSTANT_P (val)))\n@@ -4056,7 +4032,6 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n    for a value of mode OUTMODE,\n    with NARGS different arguments, passed as alternating rtx values\n    and machine_modes to convert them to.\n-   The rtx values should have been passed through protect_from_queue already.\n \n    FN_TYPE should be LCT_NORMAL for `normal' calls, LCT_CONST for `const'\n    calls, LCT_PURE for `pure' calls, LCT_CONST_MAKE_BLOCK for `const' calls\n@@ -4428,10 +4403,6 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n      be deferred during the rest of the arguments.  */\n   NO_DEFER_POP;\n \n-  /* ANSI doesn't require a sequence point here,\n-     but PCC has one, so this will avoid some problems.  */\n-  emit_queue ();\n-\n   /* Free any temporary slots made in processing this argument.  Show\n      that we might have taken the address of something and pushed that\n      as an operand.  */"}, {"sha": "f1863cb68fbd580f2a89cd6107de4413e8ddbb37", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "patch": "@@ -4815,7 +4815,6 @@ c4x_expand_builtin (tree exp, rtx target,\n     case C4X_BUILTIN_FIX:\n       arg0 = TREE_VALUE (arglist);\n       r0 = expand_expr (arg0, NULL_RTX, QFmode, 0);\n-      r0 = protect_from_queue (r0, 0);\n       if (! target || ! register_operand (target, QImode))\n \ttarget = gen_reg_rtx (QImode);\n       emit_insn (gen_fixqfqi_clobber (target, r0));\n@@ -4824,7 +4823,6 @@ c4x_expand_builtin (tree exp, rtx target,\n     case C4X_BUILTIN_FIX_ANSI:\n       arg0 = TREE_VALUE (arglist);\n       r0 = expand_expr (arg0, NULL_RTX, QFmode, 0);\n-      r0 = protect_from_queue (r0, 0);\n       if (! target || ! register_operand (target, QImode))\n \ttarget = gen_reg_rtx (QImode);\n       emit_insn (gen_fix_truncqfqi2 (target, r0));\n@@ -4837,8 +4835,6 @@ c4x_expand_builtin (tree exp, rtx target,\n       arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n       r0 = expand_expr (arg0, NULL_RTX, QImode, 0);\n       r1 = expand_expr (arg1, NULL_RTX, QImode, 0);\n-      r0 = protect_from_queue (r0, 0);\n-      r1 = protect_from_queue (r1, 0);\n       if (! target || ! register_operand (target, QImode))\n \ttarget = gen_reg_rtx (QImode);\n       emit_insn (gen_mulqi3_24_clobber (target, r0, r1));\n@@ -4849,7 +4845,6 @@ c4x_expand_builtin (tree exp, rtx target,\n \tbreak;\n       arg0 = TREE_VALUE (arglist);\n       r0 = expand_expr (arg0, NULL_RTX, QFmode, 0);\n-      r0 = protect_from_queue (r0, 0);\n       if (! target || ! register_operand (target, QFmode))\n \ttarget = gen_reg_rtx (QFmode);\n       emit_insn (gen_toieee (target, r0));\n@@ -4860,7 +4855,6 @@ c4x_expand_builtin (tree exp, rtx target,\n \tbreak;\n       arg0 = TREE_VALUE (arglist);\n       r0 = expand_expr (arg0, NULL_RTX, QFmode, 0);\n-      r0 = protect_from_queue (r0, 0);\n       if (register_operand (r0, QFmode))\n \t{\n \t  r1 = assign_stack_local (QFmode, GET_MODE_SIZE (QFmode), 0);\n@@ -4877,7 +4871,6 @@ c4x_expand_builtin (tree exp, rtx target,\n \tbreak;\n       arg0 = TREE_VALUE (arglist);\n       r0 = expand_expr (arg0, NULL_RTX, QFmode, 0);\n-      r0 = protect_from_queue (r0, 0);\n       if (! target || ! register_operand (target, QFmode))\n \ttarget = gen_reg_rtx (QFmode);\n       emit_insn (gen_rcpfqf_clobber (target, r0));"}, {"sha": "7b805310e09cad30cc26328365e8bb24e9c063f4", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "patch": "@@ -1826,9 +1826,6 @@ legitimate_pic_operand_p (rtx x)\n \t  || XINT (x, 1) == UNSPEC_PLT))\n       return 1;\n \n-  if (GET_CODE (x) == QUEUED)\n-    return legitimate_pic_operand_p (QUEUED_VAR (x));\n-\n   fmt = GET_RTX_FORMAT (GET_CODE (x));\n   for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n     {"}, {"sha": "2e576a257a6fb782df4c9b10a1e412347873056d", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "patch": "@@ -3200,10 +3200,6 @@ s390_expand_cmpmem (rtx target, rtx op0, rtx op1, rtx len)\n   rtx (*gen_result) (rtx) =\n     GET_MODE (target) == DImode ? gen_cmpint_di : gen_cmpint_si;\n \n-  op0 = protect_from_queue (op0, 0);\n-  op1 = protect_from_queue (op1, 0);\n-  len = protect_from_queue (len, 0);\n-\n   if (GET_CODE (len) == CONST_INT && INTVAL (len) >= 0 && INTVAL (len) <= 256)\n     {\n       if (INTVAL (len) > 0)"}, {"sha": "96493f3de8fa3ca01eb7d734643c9ddb6b732bad", "filename": "gcc/dojump.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "patch": "@@ -167,8 +167,6 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n   tree type;\n   enum machine_mode mode;\n \n-  emit_queue ();\n-\n   switch (code)\n     {\n     case ERROR_MARK:\n@@ -306,7 +304,6 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n       preserve_temp_slots (NULL_RTX);\n       free_temp_slots ();\n       pop_temp_slots ();\n-      emit_queue ();\n       do_pending_stack_adjust ();\n       do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label);\n       break;\n@@ -619,8 +616,6 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n         temp = copy_to_reg (temp);\n #endif\n       do_pending_stack_adjust ();\n-      /* Do any postincrements in the expression that was tested.  */\n-      emit_queue ();\n \n       if (GET_CODE (temp) == CONST_INT\n           || (GET_CODE (temp) == CONST_DOUBLE && GET_MODE (temp) == VOIDmode)\n@@ -1018,9 +1013,6 @@ do_compare_and_jump (tree exp, enum rtx_code signed_code,\n     }\n #endif\n \n-  /* Do any postincrements in the expression that was tested.  */\n-  emit_queue ();\n-\n   do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode,\n                            ((mode == BLKmode)\n                             ? expr_size (TREE_OPERAND (exp, 0)) : NULL_RTX),"}, {"sha": "cca6f63de61041ade8026071861eb5647fa47ce3", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "patch": "@@ -2227,7 +2227,6 @@ verify_rtx_sharing (rtx orig, rtx insn)\n   switch (code)\n     {\n     case REG:\n-    case QUEUED:\n     case CONST_INT:\n     case CONST_DOUBLE:\n     case CONST_VECTOR:\n@@ -2408,7 +2407,6 @@ copy_most_rtx (rtx orig, rtx may_share)\n   switch (code)\n     {\n     case REG:\n-    case QUEUED:\n     case CONST_INT:\n     case CONST_DOUBLE:\n     case CONST_VECTOR:\n@@ -2525,7 +2523,6 @@ copy_rtx_if_shared_1 (rtx *orig1)\n   switch (code)\n     {\n     case REG:\n-    case QUEUED:\n     case CONST_INT:\n     case CONST_DOUBLE:\n     case CONST_VECTOR:\n@@ -2651,7 +2648,6 @@ reset_used_flags (rtx x)\n   switch (code)\n     {\n     case REG:\n-    case QUEUED:\n     case CONST_INT:\n     case CONST_DOUBLE:\n     case CONST_VECTOR:\n@@ -2721,7 +2717,6 @@ set_used_flags (rtx x)\n   switch (code)\n     {\n     case REG:\n-    case QUEUED:\n     case CONST_INT:\n     case CONST_DOUBLE:\n     case CONST_VECTOR:\n@@ -5005,7 +5000,6 @@ copy_insn_1 (rtx orig)\n   switch (code)\n     {\n     case REG:\n-    case QUEUED:\n     case CONST_INT:\n     case CONST_DOUBLE:\n     case CONST_VECTOR:"}, {"sha": "54a863501ea07e0854b0fd500f85203de7312c2f", "filename": "gcc/explow.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "patch": "@@ -443,14 +443,6 @@ memory_address (enum machine_mode mode, rtx x)\n   if (! cse_not_expected && CONSTANT_P (x) && CONSTANT_ADDRESS_P (x))\n     x = force_reg (Pmode, x);\n \n-  /* Accept a QUEUED that refers to a REG\n-     even though that isn't a valid address.\n-     On attempting to put this in an insn we will call protect_from_queue\n-     which will turn it into a REG, which is valid.  */\n-  else if (GET_CODE (x) == QUEUED\n-      && REG_P (QUEUED_VAR (x)))\n-    ;\n-\n   /* We get better cse by rejecting indirect addressing at this stage.\n      Let the combiner create indirect addresses where appropriate.\n      For now, generate the code so that the subexpressions useful to share\n@@ -855,7 +847,6 @@ void\n adjust_stack (rtx adjust)\n {\n   rtx temp;\n-  adjust = protect_from_queue (adjust, 0);\n \n   if (adjust == const0_rtx)\n     return;\n@@ -885,7 +876,6 @@ void\n anti_adjust_stack (rtx adjust)\n {\n   rtx temp;\n-  adjust = protect_from_queue (adjust, 0);\n \n   if (adjust == const0_rtx)\n     return;"}, {"sha": "08a8863d567c83cb5db9bb7dc23d56195f97d492", "filename": "gcc/expmed.c", "status": "modified", "additions": 4, "deletions": 29, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "patch": "@@ -353,8 +353,6 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       op0 = SUBREG_REG (op0);\n     }\n \n-  value = protect_from_queue (value, 0);\n-\n   /* Use vec_set patterns for inserting parts of vectors whenever\n      available.  */\n   if (VECTOR_MODE_P (GET_MODE (op0))\n@@ -602,8 +600,6 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t}\n       offset = 0;\n     }\n-  else\n-    op0 = protect_from_queue (op0, 1);\n \n   /* If VALUE is a floating-point mode, access it as an integer of the\n      corresponding size.  This can occur on a machine with 64 bit registers\n@@ -771,9 +767,7 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n    The field starts at position BITPOS within the byte.\n     (If OP0 is a register, it may be a full word or a narrower mode,\n      but BITPOS still counts within a full word,\n-     which is significant on bigendian machines.)\n-\n-   Note that protect_from_queue has already been done on OP0 and VALUE.  */\n+     which is significant on bigendian machines.)  */\n \n static void\n store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n@@ -1369,8 +1363,6 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t}\n       offset = 0;\n     }\n-  else\n-    op0 = protect_from_queue (str_rtx, 1);\n \n   /* Now OFFSET is nonzero only for memory operands.  */\n \n@@ -1487,8 +1479,7 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t  bitsize_rtx = GEN_INT (bitsize);\n \t  bitpos_rtx = GEN_INT (xbitpos);\n \n-\t  pat = gen_extzv (protect_from_queue (xtarget, 1),\n-\t\t\t   xop0, bitsize_rtx, bitpos_rtx);\n+\t  pat = gen_extzv (xtarget, xop0, bitsize_rtx, bitpos_rtx);\n \t  if (pat)\n \t    {\n \t      emit_insn (pat);\n@@ -1616,8 +1607,7 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t  bitsize_rtx = GEN_INT (bitsize);\n \t  bitpos_rtx = GEN_INT (xbitpos);\n \n-\t  pat = gen_extv (protect_from_queue (xtarget, 1),\n-\t\t\t  xop0, bitsize_rtx, bitpos_rtx);\n+\t  pat = gen_extv (xtarget, xop0, bitsize_rtx, bitpos_rtx);\n \t  if (pat)\n \t    {\n \t      emit_insn (pat);\n@@ -2523,10 +2513,6 @@ expand_mult_const (enum machine_mode mode, rtx op0, HOST_WIDE_INT val,\n   int opno;\n   enum machine_mode nmode;\n \n-  /* op0 must be register to make mult_cost match the precomputed\n-     shiftadd_cost array.  */\n-  op0 = protect_from_queue (op0, 0);\n-\n   /* Avoid referencing memory over and over.\n      For speed, but also for correctness when mem is volatile.  */\n   if (MEM_P (op0))\n@@ -4564,10 +4550,6 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n   rtx last = get_last_insn ();\n   rtx pattern, comparison;\n \n-  /* ??? Ok to do this and then fail? */\n-  op0 = protect_from_queue (op0, 0);\n-  op1 = protect_from_queue (op1, 0);\n-\n   if (unsignedp)\n     code = unsigned_condition (code);\n \n@@ -4672,7 +4654,6 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t first.  */\n       if (GET_MODE_SIZE (target_mode) > GET_MODE_SIZE (mode))\n \t{\n-\t  op0 = protect_from_queue (op0, 0);\n \t  op0 = convert_modes (target_mode, mode, op0, 0);\n \t  mode = target_mode;\n \t}\n@@ -4704,13 +4685,8 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n       insn_operand_predicate_fn pred;\n \n       /* We think we may be able to do this with a scc insn.  Emit the\n-\t comparison and then the scc insn.\n-\n-\t compare_from_rtx may call emit_queue, which would be deleted below\n-\t if the scc insn fails.  So call it ourselves before setting LAST.\n-\t Likewise for do_pending_stack_adjust.  */\n+\t comparison and then the scc insn.  */\n \n-      emit_queue ();\n       do_pending_stack_adjust ();\n       last = get_last_insn ();\n \n@@ -4947,7 +4923,6 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \ttem = expand_unop (mode, ffs_optab, op0, subtarget, 1);\n       else if (GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n \t{\n-\t  op0 = protect_from_queue (op0, 0);\n \t  tem = convert_modes (word_mode, mode, op0, 1);\n \t  mode = word_mode;\n \t}"}, {"sha": "8a54e4b3d9e2b67bd40b3a0f13bb4946c626718a", "filename": "gcc/expr.c", "status": "modified", "additions": 21, "deletions": 545, "changes": 566, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "patch": "@@ -119,7 +119,6 @@ struct store_by_pieces\n   int reverse;\n };\n \n-static rtx enqueue_insn (rtx, rtx);\n static unsigned HOST_WIDE_INT move_by_pieces_ninsns (unsigned HOST_WIDE_INT,\n \t\t\t\t\t\t     unsigned int);\n static void move_by_pieces_1 (rtx (*) (rtx, ...), enum machine_mode,\n@@ -151,7 +150,6 @@ static unsigned HOST_WIDE_INT highest_pow2_factor (tree);\n static unsigned HOST_WIDE_INT highest_pow2_factor_for_target (tree, tree);\n \n static int is_aligning_offset (tree, tree);\n-static rtx expand_increment (tree, int, int);\n static void expand_operands (tree, tree, rtx, rtx*, rtx*,\n \t\t\t     enum expand_modifier);\n static rtx reduce_to_bit_field_precision (rtx, rtx, tree);\n@@ -312,215 +310,6 @@ init_expr (void)\n {\n   cfun->expr = ggc_alloc_cleared (sizeof (struct expr_status));\n }\n-\n-/* Small sanity check that the queue is empty at the end of a function.  */\n-\n-void\n-finish_expr_for_function (void)\n-{\n-  if (pending_chain)\n-    abort ();\n-}\n-\f\n-/* Manage the queue of increment instructions to be output\n-   for POSTINCREMENT_EXPR expressions, etc.  */\n-\n-/* Queue up to increment (or change) VAR later.  BODY says how:\n-   BODY should be the same thing you would pass to emit_insn\n-   to increment right away.  It will go to emit_insn later on.\n-\n-   The value is a QUEUED expression to be used in place of VAR\n-   where you want to guarantee the pre-incrementation value of VAR.  */\n-\n-static rtx\n-enqueue_insn (rtx var, rtx body)\n-{\n-  pending_chain = gen_rtx_QUEUED (GET_MODE (var), var, NULL_RTX, NULL_RTX,\n-\t\t\t\t  body, pending_chain);\n-  return pending_chain;\n-}\n-\n-/* Use protect_from_queue to convert a QUEUED expression\n-   into something that you can put immediately into an instruction.\n-   If the queued incrementation has not happened yet,\n-   protect_from_queue returns the variable itself.\n-   If the incrementation has happened, protect_from_queue returns a temp\n-   that contains a copy of the old value of the variable.\n-\n-   Any time an rtx which might possibly be a QUEUED is to be put\n-   into an instruction, it must be passed through protect_from_queue first.\n-   QUEUED expressions are not meaningful in instructions.\n-\n-   Do not pass a value through protect_from_queue and then hold\n-   on to it for a while before putting it in an instruction!\n-   If the queue is flushed in between, incorrect code will result.  */\n-\n-rtx\n-protect_from_queue (rtx x, int modify)\n-{\n-  RTX_CODE code = GET_CODE (x);\n-\n-#if 0  /* A QUEUED can hang around after the queue is forced out.  */\n-  /* Shortcut for most common case.  */\n-  if (pending_chain == 0)\n-    return x;\n-#endif\n-\n-  if (code != QUEUED)\n-    {\n-      /* A special hack for read access to (MEM (QUEUED ...)) to facilitate\n-\t use of autoincrement.  Make a copy of the contents of the memory\n-\t location rather than a copy of the address, but not if the value is\n-\t of mode BLKmode.  Don't modify X in place since it might be\n-\t shared.  */\n-      if (code == MEM && GET_MODE (x) != BLKmode\n-\t  && GET_CODE (XEXP (x, 0)) == QUEUED && !modify)\n-\t{\n-\t  rtx y = XEXP (x, 0);\n-\t  rtx new = replace_equiv_address_nv (x, QUEUED_VAR (y));\n-\n-\t  if (QUEUED_INSN (y))\n-\t    {\n-\t      rtx temp = gen_reg_rtx (GET_MODE (x));\n-\n-\t      emit_insn_before (gen_move_insn (temp, new),\n-\t\t\t\tQUEUED_INSN (y));\n-\t      return temp;\n-\t    }\n-\n-\t  /* Copy the address into a pseudo, so that the returned value\n-\t     remains correct across calls to emit_queue.  */\n-\t  return replace_equiv_address (new, copy_to_reg (XEXP (new, 0)));\n-\t}\n-\n-      /* Otherwise, recursively protect the subexpressions of all\n-\t the kinds of rtx's that can contain a QUEUED.  */\n-      if (code == MEM)\n-\t{\n-\t  rtx tem = protect_from_queue (XEXP (x, 0), 0);\n-\t  if (tem != XEXP (x, 0))\n-\t    {\n-\t      x = copy_rtx (x);\n-\t      XEXP (x, 0) = tem;\n-\t    }\n-\t}\n-      else if (code == PLUS || code == MULT)\n-\t{\n-\t  rtx new0 = protect_from_queue (XEXP (x, 0), 0);\n-\t  rtx new1 = protect_from_queue (XEXP (x, 1), 0);\n-\t  if (new0 != XEXP (x, 0) || new1 != XEXP (x, 1))\n-\t    {\n-\t      x = copy_rtx (x);\n-\t      XEXP (x, 0) = new0;\n-\t      XEXP (x, 1) = new1;\n-\t    }\n-\t}\n-      return x;\n-    }\n-  /* If the increment has not happened, use the variable itself.  Copy it\n-     into a new pseudo so that the value remains correct across calls to\n-     emit_queue.  */\n-  if (QUEUED_INSN (x) == 0)\n-    return copy_to_reg (QUEUED_VAR (x));\n-  /* If the increment has happened and a pre-increment copy exists,\n-     use that copy.  */\n-  if (QUEUED_COPY (x) != 0)\n-    return QUEUED_COPY (x);\n-  /* The increment has happened but we haven't set up a pre-increment copy.\n-     Set one up now, and use it.  */\n-  QUEUED_COPY (x) = gen_reg_rtx (GET_MODE (QUEUED_VAR (x)));\n-  emit_insn_before (gen_move_insn (QUEUED_COPY (x), QUEUED_VAR (x)),\n-\t\t    QUEUED_INSN (x));\n-  return QUEUED_COPY (x);\n-}\n-\n-/* Return nonzero if X contains a QUEUED expression:\n-   if it contains anything that will be altered by a queued increment.\n-   We handle only combinations of MEM, PLUS, MINUS and MULT operators\n-   since memory addresses generally contain only those.  */\n-\n-int\n-queued_subexp_p (rtx x)\n-{\n-  enum rtx_code code = GET_CODE (x);\n-  switch (code)\n-    {\n-    case QUEUED:\n-      return 1;\n-    case MEM:\n-      return queued_subexp_p (XEXP (x, 0));\n-    case MULT:\n-    case PLUS:\n-    case MINUS:\n-      return (queued_subexp_p (XEXP (x, 0))\n-\t      || queued_subexp_p (XEXP (x, 1)));\n-    default:\n-      return 0;\n-    }\n-}\n-\n-/* Retrieve a mark on the queue.  */\n-  \n-static rtx\n-mark_queue (void)\n-{\n-  return pending_chain;\n-}\n-\n-/* Perform all the pending incrementations that have been enqueued\n-   after MARK was retrieved.  If MARK is null, perform all the\n-   pending incrementations.  */\n-\n-static void\n-emit_insns_enqueued_after_mark (rtx mark)\n-{\n-  rtx p;\n-\n-  /* The marked incrementation may have been emitted in the meantime\n-     through a call to emit_queue.  In this case, the mark is not valid\n-     anymore so do nothing.  */\n-  if (mark && ! QUEUED_BODY (mark))\n-    return;\n-\n-  while ((p = pending_chain) != mark)\n-    {\n-      rtx body = QUEUED_BODY (p);\n-\n-      switch (GET_CODE (body))\n-\t{\n-\tcase INSN:\n-\tcase JUMP_INSN:\n-\tcase CALL_INSN:\n-\tcase CODE_LABEL:\n-\tcase BARRIER:\n-\tcase NOTE:\n-\t  QUEUED_INSN (p) = body;\n-\t  emit_insn (body);\n-\t  break;\n-\n-#ifdef ENABLE_CHECKING\n-\tcase SEQUENCE:\n-\t  abort ();\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  QUEUED_INSN (p) = emit_insn (body);\n-\t  break;\n-\t}\n-\n-      QUEUED_BODY (p) = 0;\n-      pending_chain = QUEUED_NEXT (p);\n-    }\n-}\n-\n-/* Perform all the pending incrementations.  */\n-\n-void\n-emit_queue (void)\n-{\n-  emit_insns_enqueued_after_mark (NULL_RTX);\n-}\n \f\n /* Copy data from FROM to TO, where the machine modes are not the same.\n    Both modes may be integer, or both may be floating.\n@@ -541,8 +330,6 @@ convert_move (rtx to, rtx from, int unsignedp)\n   enum rtx_code equiv_code = (unsignedp < 0 ? UNKNOWN\n \t\t\t      : (unsignedp ? ZERO_EXTEND : SIGN_EXTEND));\n \n-  to = protect_from_queue (to, 1);\n-  from = protect_from_queue (from, 0);\n \n   if (to_real != from_real)\n     abort ();\n@@ -899,10 +686,7 @@ convert_move (rtx to, rtx from, int unsignedp)\n    Both X and MODE may be floating, or both integer.\n    UNSIGNEDP is nonzero if X is an unsigned value.\n    This can be done by referring to a part of X in place\n-   or by copying to a new temporary with conversion.\n-\n-   This function *must not* call protect_from_queue\n-   except when putting X into an insn (in which case convert_move does it).  */\n+   or by copying to a new temporary with conversion.  */\n \n rtx\n convert_to_mode (enum machine_mode mode, rtx x, int unsignedp)\n@@ -918,10 +702,7 @@ convert_to_mode (enum machine_mode mode, rtx x, int unsignedp)\n    This can be done by referring to a part of X in place\n    or by copying to a new temporary with conversion.\n \n-   You can give VOIDmode for OLDMODE, if you are sure X has a nonvoid mode.\n-\n-   This function *must not* call protect_from_queue\n-   except when putting X into an insn (in which case convert_move does it).  */\n+   You can give VOIDmode for OLDMODE, if you are sure X has a nonvoid mode.  */\n \n rtx\n convert_modes (enum machine_mode mode, enum machine_mode oldmode, rtx x, int unsignedp)\n@@ -1040,8 +821,7 @@ can_move_by_pieces (unsigned HOST_WIDE_INT len,\n }\n \n /* Generate several move instructions to copy LEN bytes from block FROM to\n-   block TO.  (These are MEM rtx's with BLKmode).  The caller must pass FROM\n-   and TO through protect_from_queue before calling.\n+   block TO.  (These are MEM rtx's with BLKmode).\n \n    If PUSH_ROUNDING is defined and TO is NULL, emit_single_push_insn is\n    used to push FROM to the stack.\n@@ -1342,10 +1122,6 @@ emit_block_move (rtx x, rtx y, rtx size, enum block_op_methods method)\n \n   align = MIN (MEM_ALIGN (x), MEM_ALIGN (y));\n \n-  x = protect_from_queue (x, 1);\n-  y = protect_from_queue (y, 0);\n-  size = protect_from_queue (size, 0);\n-\n   if (!MEM_P (x))\n     abort ();\n   if (!MEM_P (y))\n@@ -1513,24 +1289,9 @@ emit_block_move_via_libcall (rtx dst, rtx src, rtx size)\n   enum machine_mode size_mode;\n   rtx retval;\n \n-  /* DST, SRC, or SIZE may have been passed through protect_from_queue.\n-\n-     It is unsafe to save the value generated by protect_from_queue and reuse\n-     it later.  Consider what happens if emit_queue is called before the\n-     return value from protect_from_queue is used.\n-\n-     Expansion of the CALL_EXPR below will call emit_queue before we are\n-     finished emitting RTL for argument setup.  So if we are not careful we\n-     could get the wrong value for an argument.\n-\n-     To avoid this problem we go ahead and emit code to copy the addresses of\n-     DST and SRC and SIZE into new pseudos.\n-\n-     Note this is not strictly needed for library calls since they do not call\n-     emit_queue before loading their arguments.  However, we may need to have\n-     library calls call emit_queue in the future since failing to do so could\n-     cause problems for targets which define SMALL_REGISTER_CLASSES and pass\n-     arguments in registers.  */\n+  /* Emit code to copy the addresses of DST and SRC and SIZE into new\n+     pseudos.  We can then place those new pseudos into a VAR_DECL and\n+     use them later.  */\n \n   dst_addr = copy_to_mode_reg (Pmode, XEXP (dst, 0));\n   src_addr = copy_to_mode_reg (Pmode, XEXP (src, 0));\n@@ -1926,8 +1687,6 @@ emit_group_load (rtx dst, rtx orig_src, tree type ATTRIBUTE_UNUSED, int ssize)\n \t\t\t\tbuild_int_2 (shift, 0), tmps[i], 0);\n     }\n \n-  emit_queue ();\n-\n   /* Copy the extracted pieces into the proper (probable) hard regs.  */\n   for (i = start; i < XVECLEN (dst, 0); i++)\n     emit_move_insn (XEXP (XVECEXP (dst, 0, i), 0), tmps[i]);\n@@ -1982,7 +1741,6 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n       tmps[i] = gen_reg_rtx (GET_MODE (reg));\n       emit_move_insn (tmps[i], reg);\n     }\n-  emit_queue ();\n \n   /* If we won't be storing directly into memory, protect the real destination\n      from strange tricks we might play.  */\n@@ -2076,8 +1834,6 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n \t\t\t mode, tmps[i]);\n     }\n \n-  emit_queue ();\n-\n   /* Copy from the pseudo into the (probable) hard reg.  */\n   if (orig_dst != dst)\n     emit_move_insn (orig_dst, dst);\n@@ -2322,7 +2078,6 @@ store_by_pieces (rtx to, unsigned HOST_WIDE_INT len,\n \n   if (! STORE_BY_PIECES_P (len, align))\n     abort ();\n-  to = protect_from_queue (to, 1);\n   data.constfun = constfun;\n   data.constfundata = constfundata;\n   data.len = len;\n@@ -2360,8 +2115,7 @@ store_by_pieces (rtx to, unsigned HOST_WIDE_INT len,\n }\n \n /* Generate several move instructions to clear LEN bytes of block TO.  (A MEM\n-   rtx with BLKmode).  The caller must pass TO through protect_from_queue\n-   before calling. ALIGN is maximum alignment we can assume.  */\n+   rtx with BLKmode).  ALIGN is maximum alignment we can assume.  */\n \n static void\n clear_by_pieces (rtx to, unsigned HOST_WIDE_INT len, unsigned int align)\n@@ -2391,8 +2145,7 @@ clear_by_pieces_1 (void *data ATTRIBUTE_UNUSED,\n \n /* Subroutine of clear_by_pieces and store_by_pieces.\n    Generate several move instructions to store LEN bytes of block TO.  (A MEM\n-   rtx with BLKmode).  The caller must pass TO through protect_from_queue\n-   before calling.  ALIGN is maximum alignment we can assume.  */\n+   rtx with BLKmode).  ALIGN is maximum alignment we can assume.  */\n \n static void\n store_by_pieces_1 (struct store_by_pieces *data ATTRIBUTE_UNUSED,\n@@ -2532,9 +2285,6 @@ clear_storage (rtx object, rtx size)\n     emit_move_insn (object, CONST0_RTX (GET_MODE (object)));\n   else\n     {\n-      object = protect_from_queue (object, 1);\n-      size = protect_from_queue (size, 0);\n-\n       if (size == const0_rtx)\n \t;\n       else if (GET_CODE (size) == CONST_INT\n@@ -2615,24 +2365,8 @@ clear_storage_via_libcall (rtx object, rtx size)\n   enum machine_mode size_mode;\n   rtx retval;\n \n-  /* OBJECT or SIZE may have been passed through protect_from_queue.\n-\n-     It is unsafe to save the value generated by protect_from_queue\n-     and reuse it later.  Consider what happens if emit_queue is\n-     called before the return value from protect_from_queue is used.\n-\n-     Expansion of the CALL_EXPR below will call emit_queue before\n-     we are finished emitting RTL for argument setup.  So if we are\n-     not careful we could get the wrong value for an argument.\n-\n-     To avoid this problem we go ahead and emit code to copy OBJECT\n-     and SIZE into new pseudos.\n-\n-     Note this is not strictly needed for library calls since they\n-     do not call emit_queue before loading their arguments.  However,\n-     we may need to have library calls call emit_queue in the future\n-     since failing to do so could cause problems for targets which\n-     define SMALL_REGISTER_CLASSES and pass arguments in registers.  */\n+  /* Emit code to copy OBJECT and SIZE into new pseudos.  We can then\n+     place those into new pseudos into a VAR_DECL and use them later.  */\n \n   object = copy_to_mode_reg (Pmode, XEXP (object, 0));\n \n@@ -2736,9 +2470,6 @@ emit_move_insn (rtx x, rtx y)\n   rtx y_cst = NULL_RTX;\n   rtx last_insn, set;\n \n-  x = protect_from_queue (x, 1);\n-  y = protect_from_queue (y, 0);\n-\n   if (mode == BLKmode || (GET_MODE (y) != mode && GET_MODE (y) != VOIDmode))\n     abort ();\n \n@@ -3403,7 +3134,7 @@ emit_push_insn (rtx x, enum machine_mode mode, tree type, rtx size,\n     if (where_pad != none)\n       where_pad = (where_pad == downward ? upward : downward);\n \n-  xinner = x = protect_from_queue (x, 0);\n+  xinner = x;\n \n   if (mode == BLKmode)\n     {\n@@ -3847,8 +3578,6 @@ expand_assignment (tree to, tree from, int want_value)\n \t\t  && (bitsize != 1 || TREE_CODE (op1) != INTEGER_CST))\n \t\tbreak;\n \t      value = expand_expr (op1, NULL_RTX, VOIDmode, 0);\n-\t      value = protect_from_queue (value, 0);\n-\t      to_rtx = protect_from_queue (to_rtx, 1);\n \t      binop = TREE_CODE (src) == PLUS_EXPR ? add_optab : sub_optab;\n \t      if (bitsize == 1\n \t\t  && count + bitsize != GET_MODE_BITSIZE (GET_MODE (to_rtx)))\n@@ -4030,7 +3759,6 @@ store_expr (tree exp, rtx target, int want_value)\n {\n   rtx temp;\n   rtx alt_rtl = NULL_RTX;\n-  rtx mark = mark_queue ();\n   int dont_return_target = 0;\n   int dont_store_target = 0;\n \n@@ -4050,7 +3778,6 @@ store_expr (tree exp, rtx target, int want_value)\n \t part.  */\n       expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode,\n \t\t   want_value & 2 ? EXPAND_STACK_PARM : EXPAND_NORMAL);\n-      emit_queue ();\n       return store_expr (TREE_OPERAND (exp, 1), target, want_value);\n     }\n   else if (TREE_CODE (exp) == COND_EXPR && GET_MODE (target) == BLKmode)\n@@ -4062,47 +3789,19 @@ store_expr (tree exp, rtx target, int want_value)\n \n       rtx lab1 = gen_label_rtx (), lab2 = gen_label_rtx ();\n \n-      emit_queue ();\n-      target = protect_from_queue (target, 1);\n-\n       do_pending_stack_adjust ();\n       NO_DEFER_POP;\n       jumpifnot (TREE_OPERAND (exp, 0), lab1);\n       store_expr (TREE_OPERAND (exp, 1), target, want_value & 2);\n-      emit_queue ();\n       emit_jump_insn (gen_jump (lab2));\n       emit_barrier ();\n       emit_label (lab1);\n       store_expr (TREE_OPERAND (exp, 2), target, want_value & 2);\n-      emit_queue ();\n       emit_label (lab2);\n       OK_DEFER_POP;\n \n       return want_value & 1 ? target : NULL_RTX;\n     }\n-  else if (queued_subexp_p (target))\n-    /* If target contains a postincrement, let's not risk\n-       using it as the place to generate the rhs.  */\n-    {\n-      if (GET_MODE (target) != BLKmode && GET_MODE (target) != VOIDmode)\n-\t{\n-\t  /* Expand EXP into a new pseudo.  */\n-\t  temp = gen_reg_rtx (GET_MODE (target));\n-\t  temp = expand_expr (exp, temp, GET_MODE (target),\n-\t\t\t      (want_value & 2\n-\t\t\t       ? EXPAND_STACK_PARM : EXPAND_NORMAL));\n-\t}\n-      else\n-\ttemp = expand_expr (exp, NULL_RTX, GET_MODE (target),\n-\t\t\t    (want_value & 2\n-\t\t\t     ? EXPAND_STACK_PARM : EXPAND_NORMAL));\n-\n-      /* If target is volatile, ANSI requires accessing the value\n-\t *from* the target, if it is accessed.  So make that happen.\n-\t In no case return the target itself.  */\n-      if (! MEM_VOLATILE_P (target) && (want_value & 1) != 0)\n-\tdont_return_target = 1;\n-    }\n   else if ((want_value & 1) != 0\n \t   && MEM_P (target)\n \t   && ! MEM_VOLATILE_P (target)\n@@ -4273,9 +3972,6 @@ store_expr (tree exp, rtx target, int want_value)\n \t bit-initialized.  */\n       && expr_size (exp) != const0_rtx)\n     {\n-      emit_insns_enqueued_after_mark (mark);\n-      target = protect_from_queue (target, 1);\n-      temp = protect_from_queue (temp, 0);\n       if (GET_MODE (temp) != GET_MODE (target)\n \t  && GET_MODE (temp) != VOIDmode)\n \t{\n@@ -5031,7 +4727,6 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \n \t\t  /* Build the head of the loop.  */\n \t\t  do_pending_stack_adjust ();\n-\t\t  emit_queue ();\n \t\t  emit_label (loop_start);\n \n \t\t  /* Assign value to element index.  */\n@@ -5060,9 +4755,10 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \n \t\t  /* Update the loop counter, and jump to the head of\n \t\t     the loop.  */\n-\t\t  expand_increment (build (PREINCREMENT_EXPR,\n-\t\t\t\t\t   TREE_TYPE (index),\n-\t\t\t\t\t   index, integer_one_node), 0, 0);\n+\t\t  expand_assignment (index,\n+\t\t\t             build2 (PLUS_EXPR, TREE_TYPE (index),\n+\t\t\t\t\t     index, integer_one_node), 0);\n+\n \t\t  emit_jump (loop_start);\n \n \t\t  /* Build the end of the loop.  */\n@@ -8153,7 +7849,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n     case COMPOUND_EXPR:\n       expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, 0);\n-      emit_queue ();\n       return expand_expr_real (TREE_OPERAND (exp, 1),\n \t\t\t       (ignore ? const0_rtx : target),\n \t\t\t       VOIDmode, modifier, alt_rtl);\n@@ -8492,7 +8187,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    else\n \t      expand_expr (TREE_OPERAND (exp, 1),\n \t\t\t   ignore ? const0_rtx : NULL_RTX, VOIDmode, 0);\n-\t    emit_queue ();\n \t    emit_jump_insn (gen_jump (op1));\n \t    emit_barrier ();\n \t    emit_label (op0);\n@@ -8505,7 +8199,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t   ignore ? const0_rtx : NULL_RTX, VOIDmode, 0);\n \t  }\n \n-\temit_queue ();\n \temit_label (op1);\n \tOK_DEFER_POP;\n \n@@ -8580,15 +8273,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \texpand_return (TREE_OPERAND (exp, 0));\n       return const0_rtx;\n \n-    case PREINCREMENT_EXPR:\n-    case PREDECREMENT_EXPR:\n-      return REDUCE_BIT_FIELD (expand_increment (exp, 0, ignore));\n-\n-    case POSTINCREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n-      /* Faster to treat as pre-increment if result is not used.  */\n-      return REDUCE_BIT_FIELD (expand_increment (exp, ! ignore, ignore));\n-\n     case ADDR_EXPR:\n       if (modifier == EXPAND_STACK_PARM)\n \ttarget = 0;\n@@ -8619,10 +8303,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  if (ignore)\n \t    return op0;\n \n-\t  /* Pass 1 for MODIFY, so that protect_from_queue doesn't get\n-\t     clever and returns a REG when given a MEM.  */\n-\t  op0 = protect_from_queue (op0, 1);\n-\n \t  /* We would like the object in memory.  If it is a constant, we can\n \t     have it be statically allocated into memory.  For a non-constant,\n \t     we need to allocate some memory and store the value into it.  */\n@@ -8836,6 +8516,10 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case FILTER_EXPR:\n       return get_exception_filter (cfun);\n \n+    case PREINCREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n     case FDESC_EXPR:\n       /* Function descriptors are not valid except for as\n \t initialization constants, and should not be expanded.  */\n@@ -9071,209 +8755,6 @@ string_constant (tree arg, tree *ptr_offset)\n   return 0;\n }\n \f\n-/* Expand code for a post- or pre- increment or decrement\n-   and return the RTX for the result.\n-   POST is 1 for postinc/decrements and 0 for preinc/decrements.  */\n-\n-static rtx\n-expand_increment (tree exp, int post, int ignore)\n-{\n-  rtx op0, op1;\n-  rtx temp, value;\n-  tree incremented = TREE_OPERAND (exp, 0);\n-  optab this_optab = add_optab;\n-  int icode;\n-  enum machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n-  int op0_is_copy = 0;\n-  int single_insn = 0;\n-  /* 1 means we can't store into OP0 directly,\n-     because it is a subreg narrower than a word,\n-     and we don't dare clobber the rest of the word.  */\n-  int bad_subreg = 0;\n-\n-  /* Stabilize any component ref that might need to be\n-     evaluated more than once below.  */\n-  if (!post\n-      || TREE_CODE (incremented) == BIT_FIELD_REF\n-      || (TREE_CODE (incremented) == COMPONENT_REF\n-\t  && (TREE_CODE (TREE_OPERAND (incremented, 0)) != INDIRECT_REF\n-\t      || DECL_BIT_FIELD (TREE_OPERAND (incremented, 1)))))\n-    incremented = stabilize_reference (incremented);\n-  /* Nested *INCREMENT_EXPRs can happen in C++.  We must force innermost\n-     ones into save exprs so that they don't accidentally get evaluated\n-     more than once by the code below.  */\n-  if (TREE_CODE (incremented) == PREINCREMENT_EXPR\n-      || TREE_CODE (incremented) == PREDECREMENT_EXPR)\n-    incremented = save_expr (incremented);\n-\n-  /* Compute the operands as RTX.\n-     Note whether OP0 is the actual lvalue or a copy of it:\n-     I believe it is a copy iff it is a register or subreg\n-     and insns were generated in computing it.  */\n-\n-  temp = get_last_insn ();\n-  op0 = expand_expr (incremented, NULL_RTX, VOIDmode, 0);\n-\n-  /* If OP0 is a SUBREG made for a promoted variable, we cannot increment\n-     in place but instead must do sign- or zero-extension during assignment,\n-     so we copy it into a new register and let the code below use it as\n-     a copy.\n-\n-     Note that we can safely modify this SUBREG since it is know not to be\n-     shared (it was made by the expand_expr call above).  */\n-\n-  if (GET_CODE (op0) == SUBREG && SUBREG_PROMOTED_VAR_P (op0))\n-    {\n-      if (post)\n-\tSUBREG_REG (op0) = copy_to_reg (SUBREG_REG (op0));\n-      else\n-\tbad_subreg = 1;\n-    }\n-  else if (GET_CODE (op0) == SUBREG\n-\t   && GET_MODE_BITSIZE (GET_MODE (op0)) < BITS_PER_WORD)\n-    {\n-      /* We cannot increment this SUBREG in place.  If we are\n-\t post-incrementing, get a copy of the old value.  Otherwise,\n-\t just mark that we cannot increment in place.  */\n-      if (post)\n-\top0 = copy_to_reg (op0);\n-      else\n-\tbad_subreg = 1;\n-    }\n-\n-  op0_is_copy = ((GET_CODE (op0) == SUBREG || REG_P (op0))\n-\t\t && temp != get_last_insn ());\n-  op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n-\n-  /* Decide whether incrementing or decrementing.  */\n-  if (TREE_CODE (exp) == POSTDECREMENT_EXPR\n-      || TREE_CODE (exp) == PREDECREMENT_EXPR)\n-    this_optab = sub_optab;\n-\n-  /* Convert decrement by a constant into a negative increment.  */\n-  if (this_optab == sub_optab\n-      && GET_CODE (op1) == CONST_INT)\n-    {\n-      op1 = GEN_INT (-INTVAL (op1));\n-      this_optab = add_optab;\n-    }\n-\n-  if (TYPE_TRAP_SIGNED (TREE_TYPE (exp)))\n-    this_optab = this_optab == add_optab ? addv_optab : subv_optab;\n-\n-  /* For a preincrement, see if we can do this with a single instruction.  */\n-  if (!post)\n-    {\n-      icode = (int) this_optab->handlers[(int) mode].insn_code;\n-      if (icode != (int) CODE_FOR_nothing\n-\t  /* Make sure that OP0 is valid for operands 0 and 1\n-\t     of the insn we want to queue.  */\n-\t  && (*insn_data[icode].operand[0].predicate) (op0, mode)\n-\t  && (*insn_data[icode].operand[1].predicate) (op0, mode)\n-\t  && (*insn_data[icode].operand[2].predicate) (op1, mode))\n-\tsingle_insn = 1;\n-    }\n-\n-  /* If OP0 is not the actual lvalue, but rather a copy in a register,\n-     then we cannot just increment OP0.  We must therefore contrive to\n-     increment the original value.  Then, for postincrement, we can return\n-     OP0 since it is a copy of the old value.  For preincrement, expand here\n-     unless we can do it with a single insn.\n-\n-     Likewise if storing directly into OP0 would clobber high bits\n-     we need to preserve (bad_subreg).  */\n-  if (op0_is_copy || (!post && !single_insn) || bad_subreg)\n-    {\n-      /* This is the easiest way to increment the value wherever it is.\n-\t Problems with multiple evaluation of INCREMENTED are prevented\n-\t because either (1) it is a component_ref or preincrement,\n-\t in which case it was stabilized above, or (2) it is an array_ref\n-\t with constant index in an array in a register, which is\n-\t safe to reevaluate.  */\n-      tree newexp = build (((TREE_CODE (exp) == POSTDECREMENT_EXPR\n-\t\t\t     || TREE_CODE (exp) == PREDECREMENT_EXPR)\n-\t\t\t    ? MINUS_EXPR : PLUS_EXPR),\n-\t\t\t   TREE_TYPE (exp),\n-\t\t\t   incremented,\n-\t\t\t   TREE_OPERAND (exp, 1));\n-\n-      while (TREE_CODE (incremented) == NOP_EXPR\n-\t     || TREE_CODE (incremented) == CONVERT_EXPR)\n-\t{\n-\t  newexp = convert (TREE_TYPE (incremented), newexp);\n-\t  incremented = TREE_OPERAND (incremented, 0);\n-\t}\n-\n-      temp = expand_assignment (incremented, newexp, ! post && ! ignore);\n-      return post ? op0 : temp;\n-    }\n-\n-  if (post)\n-    {\n-      /* We have a true reference to the value in OP0.\n-\t If there is an insn to add or subtract in this mode, queue it.\n-\t Queuing the increment insn avoids the register shuffling\n-\t that often results if we must increment now and first save\n-\t the old value for subsequent use.  */\n-\n-#if 0  /* Turned off to avoid making extra insn for indexed memref.  */\n-      op0 = stabilize (op0);\n-#endif\n-\n-      icode = (int) this_optab->handlers[(int) mode].insn_code;\n-      if (icode != (int) CODE_FOR_nothing\n-\t  /* Make sure that OP0 is valid for operands 0 and 1\n-\t     of the insn we want to queue.  */\n-\t  && (*insn_data[icode].operand[0].predicate) (op0, mode)\n-\t  && (*insn_data[icode].operand[1].predicate) (op0, mode))\n-\t{\n-\t  if (! (*insn_data[icode].operand[2].predicate) (op1, mode))\n-\t    op1 = force_reg (mode, op1);\n-\n-\t  return enqueue_insn (op0, GEN_FCN (icode) (op0, op0, op1));\n-\t}\n-      if (icode != (int) CODE_FOR_nothing && MEM_P (op0))\n-\t{\n-\t  rtx addr = (general_operand (XEXP (op0, 0), mode)\n-\t\t      ? force_reg (Pmode, XEXP (op0, 0))\n-\t\t      : copy_to_reg (XEXP (op0, 0)));\n-\t  rtx temp, result;\n-\n-\t  op0 = replace_equiv_address (op0, addr);\n-\t  temp = force_reg (GET_MODE (op0), op0);\n-\t  if (! (*insn_data[icode].operand[2].predicate) (op1, mode))\n-\t    op1 = force_reg (mode, op1);\n-\n-\t  /* The increment queue is LIFO, thus we have to `queue'\n-\t     the instructions in reverse order.  */\n-\t  enqueue_insn (op0, gen_move_insn (op0, temp));\n-\t  result = enqueue_insn (temp, GEN_FCN (icode) (temp, temp, op1));\n-\t  return result;\n-\t}\n-    }\n-\n-  /* Preincrement, or we can't increment with one simple insn.  */\n-  if (post)\n-    /* Save a copy of the value before inc or dec, to return it later.  */\n-    temp = value = copy_to_reg (op0);\n-  else\n-    /* Arrange to return the incremented value.  */\n-    /* Copy the rtx because expand_binop will protect from the queue,\n-       and the results of that would be invalid for us to return\n-       if our caller does emit_queue before using our result.  */\n-    temp = copy_rtx (value = op0);\n-\n-  /* Increment however we can.  */\n-  op1 = expand_binop (mode, this_optab, value, op1, op0,\n-\t\t      TYPE_UNSIGNED (TREE_TYPE (exp)), OPTAB_LIB_WIDEN);\n-\n-  /* Make sure the value is stored into OP0.  */\n-  if (op1 != op0)\n-    emit_move_insn (op0, op1);\n-\n-  return temp;\n-}\n-\f\n /* Generate code to calculate EXP using a store-flag instruction\n    and return an rtx for the result.  EXP is either a comparison\n    or a TRUTH_NOT_EXPR whose operand is a comparison.\n@@ -9481,9 +8962,7 @@ do_store_flag (tree exp, rtx target, enum machine_mode mode, int only_cheap)\n      because, if the emit_store_flag does anything it will succeed and\n      OP0 and OP1 will not be used subsequently.  */\n \n-  result = emit_store_flag (target, code,\n-\t\t\t    queued_subexp_p (op0) ? copy_rtx (op0) : op0,\n-\t\t\t    queued_subexp_p (op1) ? copy_rtx (op1) : op1,\n+  result = emit_store_flag (target, code, op0, op1,\n \t\t\t    operand_mode, unsignedp, 1);\n \n   if (result)\n@@ -9588,8 +9067,7 @@ try_casesi (tree index_type, tree index_expr, tree minval, tree range,\n \n       index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n     }\n-  emit_queue ();\n-  index = protect_from_queue (index, 0);\n+\n   do_pending_stack_adjust ();\n \n   op_mode = insn_data[(int) CODE_FOR_casesi].operand[0].mode;\n@@ -9715,8 +9193,6 @@ try_tablejump (tree index_type, tree index_expr, tree minval, tree range,\n \t\t\t    convert (index_type, index_expr),\n \t\t\t    convert (index_type, minval)));\n   index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n-  emit_queue ();\n-  index = protect_from_queue (index, 0);\n   do_pending_stack_adjust ();\n \n   do_tablejump (index, TYPE_MODE (index_type),"}, {"sha": "ebd30c3b6f9b75a3959cc198e1f3c50ff5ec69e1", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "patch": "@@ -39,25 +39,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define BRANCH_COST 1\n #endif\n \n-/* Macros to access the slots of a QUEUED rtx.\n-   Here rather than in rtl.h because only the expansion pass\n-   should ever encounter a QUEUED.  */\n-\n-/* The variable for which an increment is queued.  */\n-#define QUEUED_VAR(P) XEXP (P, 0)\n-/* If the increment has been emitted, this is the insn\n-   that does the increment.  It is zero before the increment is emitted.\n-   If more than one insn is emitted, this is the first insn.  */\n-#define QUEUED_INSN(P) XEXP (P, 1)\n-/* If a pre-increment copy has been generated, this is the copy\n-   (it is a temporary reg).  Zero if no copy made yet.  */\n-#define QUEUED_COPY(P) XEXP (P, 2)\n-/* This is the body to use for the insn to do the increment.\n-   It is used to emit the increment.  */\n-#define QUEUED_BODY(P) XEXP (P, 3)\n-/* Next QUEUED in the queue.  */\n-#define QUEUED_NEXT(P) XEXP (P, 4)\n-\n /* This is the 4th arg to `expand_expr'.\n    EXPAND_STACK_PARM means we are possibly expanding a call param onto\n    the stack.  Choosing a value of 2 isn't special;  It just allows\n@@ -304,8 +285,7 @@ extern void emit_libcall_block (rtx, rtx, rtx, rtx);\n \n /* Create but don't emit one rtl instruction to perform certain operations.\n    Modes must match; operands must meet the operation's predicates.\n-   Likewise for subtraction and for just copying.\n-   These do not call protect_from_queue; caller must do so.  */\n+   Likewise for subtraction and for just copying.  */\n extern rtx gen_add2_insn (rtx, rtx);\n extern rtx gen_add3_insn (rtx, rtx, rtx);\n extern rtx gen_sub2_insn (rtx, rtx);\n@@ -389,19 +369,6 @@ extern void init_expr_once (void);\n /* This is run at the start of compiling a function.  */\n extern void init_expr (void);\n \n-/* This is run at the end of compiling a function.  */\n-extern void finish_expr_for_function (void);\n-\n-/* Use protect_from_queue to convert a QUEUED expression\n-   into something that you can put immediately into an instruction.  */\n-extern rtx protect_from_queue (rtx, int);\n-\n-/* Perform all the pending incrementations.  */\n-extern void emit_queue (void);\n-\n-/* Tell if something has a queued subexpression.  */\n-extern int queued_subexp_p (rtx);\n-\n /* Emit some rtl insns to move data between rtx's, converting machine modes.\n    Both modes must be floating or both fixed.  */\n extern void convert_move (rtx, rtx, int);"}, {"sha": "cddade0a7511525da0e25fbcd3ebeea83337c1f2", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "patch": "@@ -4078,12 +4078,7 @@ expand_pending_sizes (tree pending_sizes)\n \n   /* Evaluate now the sizes of any types declared among the arguments.  */\n   for (tem = pending_sizes; tem; tem = TREE_CHAIN (tem))\n-    {\n-      expand_expr (TREE_VALUE (tem), const0_rtx, VOIDmode, 0);\n-      /* Flush the queue in case this parameter declaration has\n-\t side-effects.  */\n-      emit_queue ();\n-    }\n+    expand_expr (TREE_VALUE (tem), const0_rtx, VOIDmode, 0);\n }\n \n /* Start the RTL for a new function, and set variables used for\n@@ -4343,8 +4338,6 @@ expand_function_end (void)\n {\n   rtx clobber_after;\n \n-  finish_expr_for_function ();\n-\n   /* If arg_pointer_save_area was referenced only from a nested\n      function, we will not have initialized it yet.  Do that now.  */\n   if (arg_pointer_save_area && ! cfun->arg_pointer_save_area_init)"}, {"sha": "8b25793498a5e4de10cfe5c650a485319797874e", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "patch": "@@ -147,17 +147,13 @@ struct expr_status GTY(())\n \n   /* List of labels that must never be deleted.  */\n   rtx x_forced_labels;\n-\n-  /* Postincrements that still need to be expanded.  */\n-  rtx x_pending_chain;\n };\n \n #define pending_stack_adjust (cfun->expr->x_pending_stack_adjust)\n #define inhibit_defer_pop (cfun->expr->x_inhibit_defer_pop)\n #define saveregs_value (cfun->expr->x_saveregs_value)\n #define apply_args_value (cfun->expr->x_apply_args_value)\n #define forced_labels (cfun->expr->x_forced_labels)\n-#define pending_chain (cfun->expr->x_pending_chain)\n #define stack_pointer_delta (cfun->expr->x_stack_pointer_delta)\n \n /* This structure can save all the important global and static variables"}, {"sha": "c701488951e359fc3878067be75b7921cf30e145", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "patch": "@@ -838,7 +838,6 @@ attr_copy_rtx (rtx orig)\n   switch (code)\n     {\n     case REG:\n-    case QUEUED:\n     case CONST_INT:\n     case CONST_DOUBLE:\n     case CONST_VECTOR:\n@@ -2218,7 +2217,6 @@ encode_units_mask (rtx x)\n       return attr_rtx (CONST_STRING, attr_printf (MAX_DIGITS, \"%d\", j));\n \n     case REG:\n-    case QUEUED:\n     case CONST_INT:\n     case CONST_DOUBLE:\n     case CONST_VECTOR:\n@@ -4174,7 +4172,6 @@ clear_struct_flag (rtx x)\n   switch (code)\n     {\n     case REG:\n-    case QUEUED:\n     case CONST_INT:\n     case CONST_DOUBLE:\n     case CONST_VECTOR:"}, {"sha": "67133a035f9aaa59bc8d2f6864f8e255b4293d19", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "patch": "@@ -520,9 +520,6 @@ equiv_init_varies_p (rtx x)\n     case MEM:\n       return ! RTX_UNCHANGING_P (x) || equiv_init_varies_p (XEXP (x, 0));\n \n-    case QUEUED:\n-      return 1;\n-\n     case CONST:\n     case CONST_INT:\n     case CONST_DOUBLE:"}, {"sha": "2440a86dc9419edabd7b3762c6baf7ea01c509c1", "filename": "gcc/optabs.c", "status": "modified", "additions": 16, "deletions": 99, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "patch": "@@ -675,11 +675,6 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n   class = GET_MODE_CLASS (mode);\n \n-  op0 = protect_from_queue (op0, 0);\n-  op1 = protect_from_queue (op1, 0);\n-  if (target)\n-    target = protect_from_queue (target, 1);\n-\n   if (flag_force_mem)\n     {\n       /* Load duplicate non-volatile operands once.  */\n@@ -2168,20 +2163,12 @@ expand_twoval_unop (optab unoptab, rtx op0, rtx targ0, rtx targ1,\n \n   class = GET_MODE_CLASS (mode);\n \n-  op0 = protect_from_queue (op0, 0);\n-\n   if (flag_force_mem)\n-    {\n-      op0 = force_not_mem (op0);\n-    }\n+    op0 = force_not_mem (op0);\n \n-  if (targ0)\n-    targ0 = protect_from_queue (targ0, 1);\n-  else\n+  if (!targ0)\n     targ0 = gen_reg_rtx (mode);\n-  if (targ1)\n-    targ1 = protect_from_queue (targ1, 1);\n-  else\n+  if (!targ1)\n     targ1 = gen_reg_rtx (mode);\n \n   /* Record where to go back to if we fail.  */\n@@ -2272,9 +2259,6 @@ expand_twoval_binop (optab binoptab, rtx op0, rtx op1, rtx targ0, rtx targ1,\n \n   class = GET_MODE_CLASS (mode);\n \n-  op0 = protect_from_queue (op0, 0);\n-  op1 = protect_from_queue (op1, 0);\n-\n   if (flag_force_mem)\n     {\n       op0 = force_not_mem (op0);\n@@ -2291,13 +2275,9 @@ expand_twoval_binop (optab binoptab, rtx op0, rtx op1, rtx targ0, rtx targ1,\n       && rtx_cost (op1, binoptab->code) > COSTS_N_INSNS (1))\n     op1 = force_reg (mode, op1);\n \n-  if (targ0)\n-    targ0 = protect_from_queue (targ0, 1);\n-  else\n+  if (!targ0)\n     targ0 = gen_reg_rtx (mode);\n-  if (targ1)\n-    targ1 = protect_from_queue (targ1, 1);\n-  else\n+  if (!targ1)\n     targ1 = gen_reg_rtx (mode);\n \n   /* Record where to go back to if we fail.  */\n@@ -2500,15 +2480,8 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \n   class = GET_MODE_CLASS (mode);\n \n-  op0 = protect_from_queue (op0, 0);\n-\n   if (flag_force_mem)\n-    {\n-      op0 = force_not_mem (op0);\n-    }\n-\n-  if (target)\n-    target = protect_from_queue (target, 1);\n+    op0 = force_not_mem (op0);\n \n   if (unoptab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n     {\n@@ -3037,18 +3010,11 @@ expand_complex_abs (enum machine_mode mode, rtx op0, rtx target,\n   if (submode == BLKmode)\n     abort ();\n \n-  op0 = protect_from_queue (op0, 0);\n-\n   if (flag_force_mem)\n-    {\n-      op0 = force_not_mem (op0);\n-    }\n+    op0 = force_not_mem (op0);\n \n   last = get_last_insn ();\n \n-  if (target)\n-    target = protect_from_queue (target, 1);\n-\n   this_abs_optab = ! unsignedp && flag_trapv\n                    && (GET_MODE_CLASS(mode) == MODE_INT)\n                    ? absv_optab : abs_optab;\n@@ -3223,9 +3189,7 @@ emit_unop_insn (int icode, rtx target, rtx op0, enum rtx_code code)\n   enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n   rtx pat;\n \n-  temp = target = protect_from_queue (target, 1);\n-\n-  op0 = protect_from_queue (op0, 0);\n+  temp = target;\n \n   /* Sign and zero extension from memory is often done specially on\n      RISC machines, so forcing into a register here can pessimize\n@@ -3707,11 +3671,6 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n       if (size == 0)\n \tabort ();\n \n-      emit_queue ();\n-      x = protect_from_queue (x, 0);\n-      y = protect_from_queue (y, 0);\n-      size = protect_from_queue (size, 0);\n-\n       /* Try to use a memory block compare insn - either cmpstr\n \t or cmpmem will do.  */\n       for (cmp_mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n@@ -3816,8 +3775,6 @@ rtx\n prepare_operand (int icode, rtx x, int opnum, enum machine_mode mode,\n \t\t enum machine_mode wider_mode, int unsignedp)\n {\n-  x = protect_from_queue (x, 0);\n-\n   if (mode != wider_mode)\n     x = convert_modes (wider_mode, mode, x, unsignedp);\n \n@@ -3943,7 +3900,6 @@ emit_cmp_and_jump_insns (rtx x, rtx y, enum rtx_code comparison, rtx size,\n     op0 = force_reg (mode, op0);\n #endif\n \n-  emit_queue ();\n   if (unsignedp)\n     comparison = unsigned_condition (comparison);\n \n@@ -3970,8 +3926,8 @@ prepare_float_lib_cmp (rtx *px, rtx *py, enum rtx_code *pcomparison,\n {\n   enum rtx_code comparison = *pcomparison;\n   enum rtx_code swapped = swap_condition (comparison);\n-  rtx x = protect_from_queue (*px, 0);\n-  rtx y = protect_from_queue (*py, 0);\n+  rtx x = *px;\n+  rtx y = *py;\n   enum machine_mode orig_mode = GET_MODE (x);\n   enum machine_mode mode;\n   rtx value, target, insns, equiv;\n@@ -4162,18 +4118,11 @@ emit_conditional_move (rtx target, enum rtx_code code, rtx op0, rtx op1,\n       op3 = force_not_mem (op3);\n     }\n \n-  if (target)\n-    target = protect_from_queue (target, 1);\n-  else\n+  if (!target)\n     target = gen_reg_rtx (mode);\n \n   subtarget = target;\n \n-  emit_queue ();\n-\n-  op2 = protect_from_queue (op2, 0);\n-  op3 = protect_from_queue (op3, 0);\n-\n   /* If the insn doesn't accept these operands, put them in pseudos.  */\n \n   if (! (*insn_data[icode].operand[0].predicate)\n@@ -4303,23 +4252,16 @@ emit_conditional_add (rtx target, enum rtx_code code, rtx op0, rtx op1,\n       op3 = force_not_mem (op3);\n     }\n \n-  if (target)\n-    target = protect_from_queue (target, 1);\n-  else\n+  if (!target)\n     target = gen_reg_rtx (mode);\n \n-  subtarget = target;\n-\n-  emit_queue ();\n-\n-  op2 = protect_from_queue (op2, 0);\n-  op3 = protect_from_queue (op3, 0);\n-\n   /* If the insn doesn't accept these operands, put them in pseudos.  */\n \n   if (! (*insn_data[icode].operand[0].predicate)\n-      (subtarget, insn_data[icode].operand[0].mode))\n+      (target, insn_data[icode].operand[0].mode))\n     subtarget = gen_reg_rtx (insn_data[icode].operand[0].mode);\n+  else\n+    subtarget = target;\n \n   if (! (*insn_data[icode].operand[2].predicate)\n       (op2, insn_data[icode].operand[2].mode))\n@@ -4358,11 +4300,7 @@ emit_conditional_add (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \f\n /* These functions attempt to generate an insn body, rather than\n    emitting the insn, but if the gen function already emits them, we\n-   make no attempt to turn them back into naked patterns.\n-\n-   They do not protect from queued increments,\n-   because they may be used 1) in protect_from_queue itself\n-   and 2) in other passes where there is no queue.  */\n+   make no attempt to turn them back into naked patterns.  */\n \n /* Generate and return an insn body to add Y to X.  */\n \n@@ -4619,9 +4557,6 @@ expand_float (rtx to, rtx from, int unsignedp)\n \n \tif (icode != CODE_FOR_nothing)\n \t  {\n-\t    to = protect_from_queue (to, 1);\n-\t    from = protect_from_queue (from, 0);\n-\n \t    if (imode != GET_MODE (from))\n \t      from = convert_to_mode (imode, from, unsignedp);\n \n@@ -4645,11 +4580,6 @@ expand_float (rtx to, rtx from, int unsignedp)\n       rtx temp;\n       REAL_VALUE_TYPE offset;\n \n-      emit_queue ();\n-\n-      to = protect_from_queue (to, 1);\n-      from = protect_from_queue (from, 0);\n-\n       if (flag_force_mem)\n \tfrom = force_not_mem (from);\n \n@@ -4757,9 +4687,6 @@ expand_float (rtx to, rtx from, int unsignedp)\n       rtx value;\n       convert_optab tab = unsignedp ? ufloat_optab : sfloat_optab;\n \n-      to = protect_from_queue (to, 1);\n-      from = protect_from_queue (from, 0);\n-\n       if (GET_MODE_SIZE (GET_MODE (from)) < GET_MODE_SIZE (SImode))\n \tfrom = convert_to_mode (SImode, from, unsignedp);\n \n@@ -4825,9 +4752,6 @@ expand_fix (rtx to, rtx from, int unsignedp)\n \n \tif (icode != CODE_FOR_nothing)\n \t  {\n-\t    to = protect_from_queue (to, 1);\n-\t    from = protect_from_queue (from, 0);\n-\n \t    if (fmode != GET_MODE (from))\n \t      from = convert_to_mode (fmode, from, 0);\n \n@@ -4887,10 +4811,6 @@ expand_fix (rtx to, rtx from, int unsignedp)\n \t  lab1 = gen_label_rtx ();\n \t  lab2 = gen_label_rtx ();\n \n-\t  emit_queue ();\n-\t  to = protect_from_queue (to, 1);\n-\t  from = protect_from_queue (from, 0);\n-\n \t  if (flag_force_mem)\n \t    from = force_not_mem (from);\n \n@@ -4961,9 +4881,6 @@ expand_fix (rtx to, rtx from, int unsignedp)\n       if (!libfunc)\n \tabort ();\n \n-      to = protect_from_queue (to, 1);\n-      from = protect_from_queue (from, 0);\n-\n       if (flag_force_mem)\n \tfrom = force_not_mem (from);\n "}, {"sha": "05b69a486680014dcbc77efbd9fa5ab19d7cfcfb", "filename": "gcc/rtl.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "patch": "@@ -214,7 +214,6 @@ copy_rtx (rtx orig)\n   switch (code)\n     {\n     case REG:\n-    case QUEUED:\n     case CONST_INT:\n     case CONST_DOUBLE:\n     case CONST_VECTOR:"}, {"sha": "50d947d80dd6f50ae5342425a9a4fb9ea649d889", "filename": "gcc/rtl.def", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "patch": "@@ -906,24 +906,6 @@ DEF_RTL_EXPR(SYMBOL_REF, \"symbol_ref\", \"s00\", RTX_CONST_OBJ)\n    pretend to be looking at the entire value and comparing it.  */\n DEF_RTL_EXPR(CC0, \"cc0\", \"\", RTX_OBJ)\n \n-/* =====================================================================\n-   A QUEUED expression really points to a member of the queue of instructions\n-   to be output later for postincrement/postdecrement.\n-   QUEUED expressions never become part of instructions.\n-   When a QUEUED expression would be put into an instruction,\n-   instead either the incremented variable or a copy of its previous\n-   value is used.\n-   \n-   Operands are:\n-   0. the variable to be incremented (a REG rtx).\n-   1. the incrementing instruction, or 0 if it hasn't been output yet.\n-   2. A REG rtx for a copy of the old value of the variable, or 0 if none yet.\n-   3. the body to use for the incrementing instruction\n-   4. the next QUEUED expression in the queue.\n-   ====================================================================== */\n-\n-DEF_RTL_EXPR(QUEUED, \"queued\", \"eeeee\", RTX_EXTRA)\n-\n /* ----------------------------------------------------------------------\n    Expressions for operators in an rtl pattern\n    ---------------------------------------------------------------------- */"}, {"sha": "f3ce004bb2e81ced0dbac434f9bc4111d1d94074", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "patch": "@@ -83,9 +83,6 @@ rtx_unstable_p (rtx x)\n     case MEM:\n       return ! RTX_UNCHANGING_P (x) || rtx_unstable_p (XEXP (x, 0));\n \n-    case QUEUED:\n-      return 1;\n-\n     case CONST:\n     case CONST_INT:\n     case CONST_DOUBLE:\n@@ -161,9 +158,6 @@ rtx_varies_p (rtx x, int for_alias)\n     case MEM:\n       return ! RTX_UNCHANGING_P (x) || rtx_varies_p (XEXP (x, 0), for_alias);\n \n-    case QUEUED:\n-      return 1;\n-\n     case CONST:\n     case CONST_INT:\n     case CONST_DOUBLE:"}, {"sha": "2297f69781859f719b89e3c47f6edc830f851817", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "patch": "@@ -3802,9 +3802,6 @@ simplify_gen_subreg (enum machine_mode outermode, rtx op,\n       || byte >= GET_MODE_SIZE (innermode))\n     abort ();\n \n-  if (GET_CODE (op) == QUEUED)\n-    return NULL_RTX;\n-\n   new = simplify_subreg (outermode, op, innermode, byte);\n   if (new)\n     return new;"}, {"sha": "e9c6e5e22960d74959e8dbd6da3ad2184a9fa090", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad76cef84c675f27d4e04284c1cf8c2b659d82ea/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=ad76cef84c675f27d4e04284c1cf8c2b659d82ea", "patch": "@@ -430,7 +430,6 @@ expand_computed_goto (tree exp)\n \n   x = convert_memory_address (Pmode, x);\n \n-  emit_queue ();\n   do_pending_stack_adjust ();\n   emit_indirect_jump (x);\n }\n@@ -1060,7 +1059,7 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n \t  if ((! allows_mem && MEM_P (op))\n \t      || GET_CODE (op) == CONCAT)\n \t    {\n-\t      real_output_rtx[i] = protect_from_queue (op, 1);\n+\t      real_output_rtx[i] = op;\n \t      op = gen_reg_rtx (GET_MODE (op));\n \t      if (is_inout)\n \t\temit_move_insn (op, real_output_rtx[i]);\n@@ -1185,13 +1184,6 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n \n   generating_concat_p = 0;\n \n-  for (i = 0; i < ninputs - ninout; i++)\n-    ASM_OPERANDS_INPUT (body, i)\n-      = protect_from_queue (ASM_OPERANDS_INPUT (body, i), 0);\n-\n-  for (i = 0; i < noutputs; i++)\n-    output_rtx[i] = protect_from_queue (output_rtx[i], 1);\n-\n   /* For in-out operands, copy output rtx to input rtx.  */\n   for (i = 0; i < ninout; i++)\n     {\n@@ -1362,9 +1354,6 @@ expand_asm_expr (tree exp)\n \t  TREE_VALUE (tail) = o[i];\n \t}\n     }\n-\n-  /* Those MODIFY_EXPRs could do autoincrements.  */\n-  emit_queue ();\n }\n \n /* A subroutine of expand_asm_operands.  Check that all operands have\n@@ -1626,8 +1615,6 @@ expand_expr_stmt (tree exp)\n \n   /* Free any temporaries used to evaluate this expression.  */\n   free_temp_slots ();\n-\n-  emit_queue ();\n }\n \n /* Warn if EXP contains any computations whose results are not used.\n@@ -2014,7 +2001,6 @@ expand_return (tree retval)\n   if (TREE_CODE (TREE_TYPE (TREE_TYPE (current_function_decl))) == VOID_TYPE)\n     {\n       expand_expr (retval, NULL_RTX, VOIDmode, 0);\n-      emit_queue ();\n       expand_null_return ();\n       return;\n     }\n@@ -2144,7 +2130,6 @@ expand_return (tree retval)\n \tresult_reg_mode = tmpmode;\n       result_reg = gen_reg_rtx (result_reg_mode);\n \n-      emit_queue ();\n       for (i = 0; i < n_regs; i++)\n \temit_move_insn (operand_subword (result_reg, i, 0, result_reg_mode),\n \t\t\tresult_pseudos[i]);\n@@ -2167,15 +2152,13 @@ expand_return (tree retval)\n       val = assign_temp (nt, 0, 0, 1);\n       val = expand_expr (retval_rhs, val, GET_MODE (val), 0);\n       val = force_not_mem (val);\n-      emit_queue ();\n       /* Return the calculated value.  */\n       expand_value_return (shift_return_value (val));\n     }\n   else\n     {\n       /* No hard reg used; calculate value into hard return reg.  */\n       expand_expr (retval, const0_rtx, VOIDmode, 0);\n-      emit_queue ();\n       expand_value_return (result_rtl);\n     }\n }\n@@ -2682,13 +2665,11 @@ expand_decl_init (tree decl)\n \t  || code == POINTER_TYPE || code == REFERENCE_TYPE)\n \texpand_assignment (decl, convert (TREE_TYPE (decl), integer_zero_node),\n \t\t\t   0);\n-      emit_queue ();\n     }\n   else if (DECL_INITIAL (decl) && TREE_CODE (DECL_INITIAL (decl)) != TREE_LIST)\n     {\n       emit_line_note (DECL_SOURCE_LOCATION (decl));\n       expand_assignment (decl, DECL_INITIAL (decl), 0);\n-      emit_queue ();\n     }\n \n   /* Don't let the initialization count as \"using\" the variable.  */\n@@ -2801,7 +2782,6 @@ expand_start_case (int exit_flag, tree expr, tree type,\n   nesting_stack = thiscase;\n \n   do_pending_stack_adjust ();\n-  emit_queue ();\n \n   /* Make sure case_stmt.start points to something that won't\n      need any transformation before expand_end_case.  */\n@@ -3281,8 +3261,6 @@ emit_case_bit_tests (tree index_type, tree index_expr, tree minval,\n \t\t\t    convert (index_type, index_expr),\n \t\t\t    convert (index_type, minval)));\n   index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n-  emit_queue ();\n-  index = protect_from_queue (index, 0);\n   do_pending_stack_adjust ();\n \n   mode = TYPE_MODE (index_type);\n@@ -3434,7 +3412,6 @@ expand_end_case_type (tree orig_index, tree orig_type)\n       if (count == 0)\n \t{\n \t  expand_expr (index_expr, const0_rtx, VOIDmode, 0);\n-\t  emit_queue ();\n \t  emit_jump (default_label);\n \t}\n \n@@ -3503,10 +3480,8 @@ expand_end_case_type (tree orig_index, tree orig_type)\n \t\t  }\n \t    }\n \n-\t  emit_queue ();\n \t  do_pending_stack_adjust ();\n \n-\t  index = protect_from_queue (index, 0);\n \t  if (MEM_P (index))\n \t    index = copy_to_reg (index);\n \t  if (GET_CODE (index) == CONST_INT"}]}