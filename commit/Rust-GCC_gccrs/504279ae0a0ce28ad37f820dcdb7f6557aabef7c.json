{"sha": "504279ae0a0ce28ad37f820dcdb7f6557aabef7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA0Mjc5YWUwYTBjZTI4YWQzN2Y4MjBkY2RiN2Y2NTU3YWFiZWY3Yw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-09T17:58:36Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-09T17:58:36Z"}, "message": "Simplify the implementation of HARD_REG_SET\n\nWe have two styles of HARD_REG_SET: a single integer based on\nHOST_WIDEST_FAST_INT (used when FIRST_PSEUDO_REGISTER is small enough)\nor an array of integers.  One of the nice properties of this arrangement\nis that:\n\n  void foo (const HARD_REG_SET);\n\nis passed by value as an integer when the set is small enough and\nby reference otherwise.\n\n(This is in constrast to \"const HARD_REG_SET &\", which would always\nbe passed by reference, and in contrast to passing a structure wrapper\nlike \"struct s { T elts[1]; }\" by value, where the structure might be\npassed like a T or by reference, depending on the ABI.)\n\nHowever, one of the disadvantages of using an array is that simple\nassignment doesn't work.  We need to use COPY_HARD_REG_SET instead.\n\nThis patch uses a structure wrapper around the array, and preserves\nthe above \"nice property\" using a new const_hard_reg_set typedef.\nThe patch also removes the manual unrolling for small array sizes;\nI think these days we can rely on the compiler to do that for us.\n\nThis meant fixing two port-specific quirks:\n\n- epiphany passed NULL as a HARD_REG_SET whose value doesn't matter.\n  The patch passes the NO_REGS set instead.\n\n- ia64 reused TEST_HARD_REG_BIT and SET_HARD_REG_BIT for arrays that\n  are bigger than HARD_REG_SET.  The patch just open-codes them.\n\nThe patch is probably being too conservative.  Very few places actually\ntake advantage of the \"nice property\" above, and we could have a\ncleaner interface if we used a structure wrapper for all cases.\n\n2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* hard-reg-set.h (HARD_REG_SET): Define using a typedef rather\n\tthan a #define.  Use a structure rather than an array as the\n\tfallback definition.  Remove special cases for low array sizes.\n\t(const_hard_reg_set): New typedef.\n\t(hard_reg_set_subset_p): Use it instead of \"const HARD_REG_SET\".\n\t(hard_reg_set_equal_p, hard_reg_set_intersect_p): Likewise.\n\t(hard_reg_set_empty_p): Likewise.\n\t(SET_HARD_REG_BIT): Use a function rather than a macro to\n\thandle the case in which HARD_REG_SET is a structure.\n\t(CLEAR_HARD_REG_BIT, TEST_HARD_REG_BIT, CLEAR_HARD_REG_SET)\n\t(SET_HARD_REG_SET, COPY_HARD_REG_SET, COMPL_HARD_REG_SET)\n\t(AND_HARD_REG_SET, AND_COMPL_HARD_REG_SET, IOR_HARD_REG_SET)\n\t(IOR_COMPL_HARD_REG_SET): Likewise.\n\t(hard_reg_set_iterator::pset): Constify the pointer target.\n\t(hard_reg_set_iter_init): Take a const_hard_reg_set instead\n\tof a \"const HARD_REG_SET\".  Update the handling of non-integer\n\tHARD_REG_SETs.\n\t* recog.h: Test HARD_CONST instead of CLEAR_HARD_REG_SET.\n\t* reload.h: Likewise.\n\t* rtl.h (choose_hard_reg_mode): Remove unnecessary line break.\n\t* regs.h (in_hard_reg_set_p): Take a const_hard_reg_set instead\n\tof a \"const HARD_REG_SET\".\n\t(overlaps_hard_reg_set_p, range_overlaps_hard_reg_set_p): Likewise.\n\t(range_in_hard_reg_set_p): Likewise.\n\t* ira-costs.c (restrict_cost_classes): Likewise.\n\t* shrink-wrap.c (move_insn_for_shrink_wrap): Likewise.\n\t* config/epiphany/resolve-sw-modes.c (pass_resolve_sw_modes::execute):\n\tPass a NO_REGS HARD_REG_SET rather than NULL to emit_set_fp_mode.\n\t* config/ia64/ia64.c (rws_insn): In the CHECKING_P version,\n\tuse unsigned HOST_WIDEST_FAST_INT rather than HARD_REG_ELT_TYPE.\n\t(rws_insn_set, rws_insn_test): In the CHECKING_P version,\n\ttake an unsigned int and open-code the HARD_REG_SET operations.\n\nFrom-SVN: r275526", "tree": {"sha": "c15d0cea7850e25709d4fa0dd813b4a270bbb203", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c15d0cea7850e25709d4fa0dd813b4a270bbb203"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/504279ae0a0ce28ad37f820dcdb7f6557aabef7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/504279ae0a0ce28ad37f820dcdb7f6557aabef7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/504279ae0a0ce28ad37f820dcdb7f6557aabef7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/504279ae0a0ce28ad37f820dcdb7f6557aabef7c/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "812b3c62a7c8b3c006196635d0da08acc5674d98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/812b3c62a7c8b3c006196635d0da08acc5674d98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/812b3c62a7c8b3c006196635d0da08acc5674d98"}], "stats": {"total": 485, "additions": 139, "deletions": 346}, "files": [{"sha": "482a50ffc0816205f2b928a0679ea5bb95cf726a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/504279ae0a0ce28ad37f820dcdb7f6557aabef7c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/504279ae0a0ce28ad37f820dcdb7f6557aabef7c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=504279ae0a0ce28ad37f820dcdb7f6557aabef7c", "patch": "@@ -1,3 +1,38 @@\n+2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* hard-reg-set.h (HARD_REG_SET): Define using a typedef rather\n+\tthan a #define.  Use a structure rather than an array as the\n+\tfallback definition.  Remove special cases for low array sizes.\n+\t(const_hard_reg_set): New typedef.\n+\t(hard_reg_set_subset_p): Use it instead of \"const HARD_REG_SET\".\n+\t(hard_reg_set_equal_p, hard_reg_set_intersect_p): Likewise.\n+\t(hard_reg_set_empty_p): Likewise.\n+\t(SET_HARD_REG_BIT): Use a function rather than a macro to\n+\thandle the case in which HARD_REG_SET is a structure.\n+\t(CLEAR_HARD_REG_BIT, TEST_HARD_REG_BIT, CLEAR_HARD_REG_SET)\n+\t(SET_HARD_REG_SET, COPY_HARD_REG_SET, COMPL_HARD_REG_SET)\n+\t(AND_HARD_REG_SET, AND_COMPL_HARD_REG_SET, IOR_HARD_REG_SET)\n+\t(IOR_COMPL_HARD_REG_SET): Likewise.\n+\t(hard_reg_set_iterator::pset): Constify the pointer target.\n+\t(hard_reg_set_iter_init): Take a const_hard_reg_set instead\n+\tof a \"const HARD_REG_SET\".  Update the handling of non-integer\n+\tHARD_REG_SETs.\n+\t* recog.h: Test HARD_CONST instead of CLEAR_HARD_REG_SET.\n+\t* reload.h: Likewise.\n+\t* rtl.h (choose_hard_reg_mode): Remove unnecessary line break.\n+\t* regs.h (in_hard_reg_set_p): Take a const_hard_reg_set instead\n+\tof a \"const HARD_REG_SET\".\n+\t(overlaps_hard_reg_set_p, range_overlaps_hard_reg_set_p): Likewise.\n+\t(range_in_hard_reg_set_p): Likewise.\n+\t* ira-costs.c (restrict_cost_classes): Likewise.\n+\t* shrink-wrap.c (move_insn_for_shrink_wrap): Likewise.\n+\t* config/epiphany/resolve-sw-modes.c (pass_resolve_sw_modes::execute):\n+\tPass a NO_REGS HARD_REG_SET rather than NULL to emit_set_fp_mode.\n+\t* config/ia64/ia64.c (rws_insn): In the CHECKING_P version,\n+\tuse unsigned HOST_WIDEST_FAST_INT rather than HARD_REG_ELT_TYPE.\n+\t(rws_insn_set, rws_insn_test): In the CHECKING_P version,\n+\ttake an unsigned int and open-code the HARD_REG_SET operations.\n+\n 2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* Makefile.in (OBJS): Remove bt-load.o."}, {"sha": "9ecdf6301bc3aafc03db55d074887e7ecb47c3ec", "filename": "gcc/config/epiphany/resolve-sw-modes.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/504279ae0a0ce28ad37f820dcdb7f6557aabef7c/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/504279ae0a0ce28ad37f820dcdb7f6557aabef7c/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c?ref=504279ae0a0ce28ad37f820dcdb7f6557aabef7c", "patch": "@@ -167,7 +167,8 @@ pass_resolve_sw_modes::execute (function *fun)\n \t    }\n \t  start_sequence ();\n \t  emit_set_fp_mode (EPIPHANY_MSW_ENTITY_ROUND_UNKNOWN,\n-\t\t\t    jilted_mode, FP_MODE_NONE, NULL);\n+\t\t\t    jilted_mode, FP_MODE_NONE,\n+\t\t\t    reg_class_contents[NO_REGS]);\n \t  seq = get_insns ();\n \t  end_sequence ();\n \t  need_commit = true;"}, {"sha": "3768c8b5e5470a074784f0e3d4b5e52f34735cda", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/504279ae0a0ce28ad37f820dcdb7f6557aabef7c/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/504279ae0a0ce28ad37f820dcdb7f6557aabef7c/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=504279ae0a0ce28ad37f820dcdb7f6557aabef7c", "patch": "@@ -6230,20 +6230,25 @@ struct reg_write_state\n struct reg_write_state rws_sum[NUM_REGS];\n #if CHECKING_P\n /* Bitmap whether a register has been written in the current insn.  */\n-HARD_REG_ELT_TYPE rws_insn[(NUM_REGS + HOST_BITS_PER_WIDEST_FAST_INT - 1)\n-\t\t\t   / HOST_BITS_PER_WIDEST_FAST_INT];\n+unsigned HOST_WIDEST_FAST_INT rws_insn\n+  [(NUM_REGS + HOST_BITS_PER_WIDEST_FAST_INT - 1)\n+   / HOST_BITS_PER_WIDEST_FAST_INT];\n \n static inline void\n-rws_insn_set (int regno)\n+rws_insn_set (unsigned int regno)\n {\n-  gcc_assert (!TEST_HARD_REG_BIT (rws_insn, regno));\n-  SET_HARD_REG_BIT (rws_insn, regno);\n+  unsigned int elt = regno / HOST_BITS_PER_WIDEST_FAST_INT;\n+  unsigned int bit = regno % HOST_BITS_PER_WIDEST_FAST_INT;\n+  gcc_assert (!((rws_insn[elt] >> bit) & 1));\n+  rws_insn[elt] |= (unsigned HOST_WIDEST_FAST_INT) 1 << bit;\n }\n \n static inline int\n-rws_insn_test (int regno)\n+rws_insn_test (unsigned int regno)\n {\n-  return TEST_HARD_REG_BIT (rws_insn, regno);\n+  unsigned int elt = regno / HOST_BITS_PER_WIDEST_FAST_INT;\n+  unsigned int bit = regno % HOST_BITS_PER_WIDEST_FAST_INT;\n+  return (rws_insn[elt] >> bit) & 1;\n }\n #else\n /* When not checking, track just REG_AR_CFM and REG_VOLATILE.  */"}, {"sha": "32626bab379a6e7670178fd506bd88f3867fef74", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 79, "deletions": 326, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/504279ae0a0ce28ad37f820dcdb7f6557aabef7c/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/504279ae0a0ce28ad37f820dcdb7f6557aabef7c/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=504279ae0a0ce28ad37f820dcdb7f6557aabef7c", "patch": "@@ -42,14 +42,20 @@ typedef unsigned HOST_WIDEST_FAST_INT HARD_REG_ELT_TYPE;\n \n #if FIRST_PSEUDO_REGISTER <= HOST_BITS_PER_WIDEST_FAST_INT\n \n-#define HARD_REG_SET HARD_REG_ELT_TYPE\n+typedef HARD_REG_ELT_TYPE HARD_REG_SET;\n+typedef const HARD_REG_SET const_hard_reg_set;\n \n #else\n \n #define HARD_REG_SET_LONGS \\\n  ((FIRST_PSEUDO_REGISTER + HOST_BITS_PER_WIDEST_FAST_INT - 1)\t\\\n   / HOST_BITS_PER_WIDEST_FAST_INT)\n-typedef HARD_REG_ELT_TYPE HARD_REG_SET[HARD_REG_SET_LONGS];\n+\n+struct HARD_REG_SET\n+{\n+  HARD_REG_ELT_TYPE elts[HARD_REG_SET_LONGS];\n+};\n+typedef const HARD_REG_SET &const_hard_reg_set;\n \n #endif\n \n@@ -98,7 +104,7 @@ struct hard_reg_set_container\n \n #define UHOST_BITS_PER_WIDE_INT ((unsigned) HOST_BITS_PER_WIDEST_FAST_INT)\n \n-#ifdef HARD_REG_SET\n+#if FIRST_PSEUDO_REGISTER <= HOST_BITS_PER_WIDEST_FAST_INT\n \n #define SET_HARD_REG_BIT(SET, BIT)  \\\n  ((SET) |= HARD_CONST (1) << (BIT))\n@@ -119,403 +125,150 @@ struct hard_reg_set_container\n #define AND_COMPL_HARD_REG_SET(TO, FROM) ((TO) &= ~ (FROM))\n \n static inline bool\n-hard_reg_set_subset_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+hard_reg_set_subset_p (const_hard_reg_set x, const_hard_reg_set y)\n {\n   return (x & ~y) == HARD_CONST (0);\n }\n \n static inline bool\n-hard_reg_set_equal_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+hard_reg_set_equal_p (const_hard_reg_set x, const_hard_reg_set y)\n {\n   return x == y;\n }\n \n static inline bool\n-hard_reg_set_intersect_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+hard_reg_set_intersect_p (const_hard_reg_set x, const_hard_reg_set y)\n {\n   return (x & y) != HARD_CONST (0);\n }\n \n static inline bool\n-hard_reg_set_empty_p (const HARD_REG_SET x)\n+hard_reg_set_empty_p (const_hard_reg_set x)\n {\n   return x == HARD_CONST (0);\n }\n \n #else\n \n-#define SET_HARD_REG_BIT(SET, BIT)\t\t\\\n-  ((SET)[(BIT) / UHOST_BITS_PER_WIDE_INT]\t\\\n-   |= HARD_CONST (1) << ((BIT) % UHOST_BITS_PER_WIDE_INT))\n-\n-#define CLEAR_HARD_REG_BIT(SET, BIT)\t\t\\\n-  ((SET)[(BIT) / UHOST_BITS_PER_WIDE_INT]\t\\\n-   &= ~(HARD_CONST (1) << ((BIT) % UHOST_BITS_PER_WIDE_INT)))\n-\n-#define TEST_HARD_REG_BIT(SET, BIT)\t\t\\\n-  (!!((SET)[(BIT) / UHOST_BITS_PER_WIDE_INT]\t\\\n-      & (HARD_CONST (1) << ((BIT) % UHOST_BITS_PER_WIDE_INT))))\n-\n-#if FIRST_PSEUDO_REGISTER <= 2*HOST_BITS_PER_WIDEST_FAST_INT\n-#define CLEAR_HARD_REG_SET(TO)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     scan_tp_[0] = 0;\t\t\t\t\t\t\\\n-     scan_tp_[1] = 0; } while (0)\n-\n-#define SET_HARD_REG_SET(TO)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     scan_tp_[0] = -1;\t\t\t\t\t\t\\\n-     scan_tp_[1] = -1; } while (0)\n-\n-#define COPY_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     scan_tp_[0] = scan_fp_[0];\t\t\t\t\t\\\n-     scan_tp_[1] = scan_fp_[1]; } while (0)\n-\n-#define COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     scan_tp_[0] = ~ scan_fp_[0];\t\t\t\t\\\n-     scan_tp_[1] = ~ scan_fp_[1]; } while (0)\n-\n-#define AND_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     scan_tp_[0] &= scan_fp_[0];\t\t\t\t\\\n-     scan_tp_[1] &= scan_fp_[1]; } while (0)\n-\n-#define AND_COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     scan_tp_[0] &= ~ scan_fp_[0];\t\t\t\t\\\n-     scan_tp_[1] &= ~ scan_fp_[1]; } while (0)\n-\n-#define IOR_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     scan_tp_[0] |= scan_fp_[0];\t\t\t\t\\\n-     scan_tp_[1] |= scan_fp_[1]; } while (0)\n-\n-#define IOR_COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     scan_tp_[0] |= ~ scan_fp_[0];\t\t\t\t\\\n-     scan_tp_[1] |= ~ scan_fp_[1]; } while (0)\n-\n-static inline bool\n-hard_reg_set_subset_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+inline void\n+SET_HARD_REG_BIT (HARD_REG_SET &set, unsigned int bit)\n {\n-  return (x[0] & ~y[0]) == 0 && (x[1] & ~y[1]) == 0;\n+  set.elts[bit / UHOST_BITS_PER_WIDE_INT]\n+    |= HARD_CONST (1) << (bit % UHOST_BITS_PER_WIDE_INT);\n }\n \n-static inline bool\n-hard_reg_set_equal_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+inline void\n+CLEAR_HARD_REG_BIT (HARD_REG_SET &set, unsigned int bit)\n {\n-  return x[0] == y[0] && x[1] == y[1];\n+  set.elts[bit / UHOST_BITS_PER_WIDE_INT]\n+    &= ~(HARD_CONST (1) << (bit % UHOST_BITS_PER_WIDE_INT));\n }\n \n-static inline bool\n-hard_reg_set_intersect_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+inline bool\n+TEST_HARD_REG_BIT (const_hard_reg_set set, unsigned int bit)\n {\n-  return (x[0] & y[0]) != 0 || (x[1] & y[1]) != 0;\n+  return (set.elts[bit / UHOST_BITS_PER_WIDE_INT]\n+\t  & (HARD_CONST (1) << (bit % UHOST_BITS_PER_WIDE_INT)));\n }\n \n-static inline bool\n-hard_reg_set_empty_p (const HARD_REG_SET x)\n+inline void\n+CLEAR_HARD_REG_SET (HARD_REG_SET &set)\n {\n-  return x[0] == 0 && x[1] == 0;\n+  for (unsigned int i = 0; i < ARRAY_SIZE (set.elts); ++i)\n+    set.elts[i] = 0;\n }\n \n-#else\n-#if FIRST_PSEUDO_REGISTER <= 3*HOST_BITS_PER_WIDEST_FAST_INT\n-#define CLEAR_HARD_REG_SET(TO)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     scan_tp_[0] = 0;\t\t\t\t\t\t\\\n-     scan_tp_[1] = 0;\t\t\t\t\t\t\\\n-     scan_tp_[2] = 0; } while (0)\n-\n-#define SET_HARD_REG_SET(TO)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     scan_tp_[0] = -1;\t\t\t\t\t\t\\\n-     scan_tp_[1] = -1;\t\t\t\t\t\t\\\n-     scan_tp_[2] = -1; } while (0)\n-\n-#define COPY_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     scan_tp_[0] = scan_fp_[0];\t\t\t\t\t\\\n-     scan_tp_[1] = scan_fp_[1];\t\t\t\t\t\\\n-     scan_tp_[2] = scan_fp_[2]; } while (0)\n-\n-#define COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     scan_tp_[0] = ~ scan_fp_[0];\t\t\t\t\\\n-     scan_tp_[1] = ~ scan_fp_[1];\t\t\t\t\\\n-     scan_tp_[2] = ~ scan_fp_[2]; } while (0)\n-\n-#define AND_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     scan_tp_[0] &= scan_fp_[0];\t\t\t\t\\\n-     scan_tp_[1] &= scan_fp_[1];\t\t\t\t\\\n-     scan_tp_[2] &= scan_fp_[2]; } while (0)\n-\n-#define AND_COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     scan_tp_[0] &= ~ scan_fp_[0];\t\t\t\t\\\n-     scan_tp_[1] &= ~ scan_fp_[1];\t\t\t\t\\\n-     scan_tp_[2] &= ~ scan_fp_[2]; } while (0)\n-\n-#define IOR_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     scan_tp_[0] |= scan_fp_[0];\t\t\t\t\\\n-     scan_tp_[1] |= scan_fp_[1];\t\t\t\t\\\n-     scan_tp_[2] |= scan_fp_[2]; } while (0)\n-\n-#define IOR_COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     scan_tp_[0] |= ~ scan_fp_[0];\t\t\t\t\\\n-     scan_tp_[1] |= ~ scan_fp_[1];\t\t\t\t\\\n-     scan_tp_[2] |= ~ scan_fp_[2]; } while (0)\n-\n-static inline bool\n-hard_reg_set_subset_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+inline void\n+SET_HARD_REG_SET (HARD_REG_SET &set)\n {\n-  return ((x[0] & ~y[0]) == 0\n-\t  && (x[1] & ~y[1]) == 0\n-\t  && (x[2] & ~y[2]) == 0);\n+  for (unsigned int i = 0; i < ARRAY_SIZE (set.elts); ++i)\n+    set.elts[i] = -1;\n }\n \n-static inline bool\n-hard_reg_set_equal_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+inline void\n+COPY_HARD_REG_SET (HARD_REG_SET &to, const_hard_reg_set from)\n {\n-  return x[0] == y[0] && x[1] == y[1] && x[2] == y[2];\n+  to = from;\n }\n \n-static inline bool\n-hard_reg_set_intersect_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+inline void\n+COMPL_HARD_REG_SET (HARD_REG_SET &to, const_hard_reg_set from)\n {\n-  return ((x[0] & y[0]) != 0\n-\t  || (x[1] & y[1]) != 0\n-\t  || (x[2] & y[2]) != 0);\n+  for (unsigned int i = 0; i < ARRAY_SIZE (to.elts); ++i)\n+    to.elts[i] = ~from.elts[i];\n }\n \n-static inline bool\n-hard_reg_set_empty_p (const HARD_REG_SET x)\n+inline void\n+AND_HARD_REG_SET (HARD_REG_SET &to, const_hard_reg_set from)\n {\n-  return x[0] == 0 && x[1] == 0 && x[2] == 0;\n+  for (unsigned int i = 0; i < ARRAY_SIZE (to.elts); ++i)\n+    to.elts[i] &= from.elts[i];\n }\n \n-#else\n-#if FIRST_PSEUDO_REGISTER <= 4*HOST_BITS_PER_WIDEST_FAST_INT\n-#define CLEAR_HARD_REG_SET(TO)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     scan_tp_[0] = 0;\t\t\t\t\t\t\\\n-     scan_tp_[1] = 0;\t\t\t\t\t\t\\\n-     scan_tp_[2] = 0;\t\t\t\t\t\t\\\n-     scan_tp_[3] = 0; } while (0)\n-\n-#define SET_HARD_REG_SET(TO)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     scan_tp_[0] = -1;\t\t\t\t\t\t\\\n-     scan_tp_[1] = -1;\t\t\t\t\t\t\\\n-     scan_tp_[2] = -1;\t\t\t\t\t\t\\\n-     scan_tp_[3] = -1; } while (0)\n-\n-#define COPY_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     scan_tp_[0] = scan_fp_[0];\t\t\t\t\t\\\n-     scan_tp_[1] = scan_fp_[1];\t\t\t\t\t\\\n-     scan_tp_[2] = scan_fp_[2];\t\t\t\t\t\\\n-     scan_tp_[3] = scan_fp_[3]; } while (0)\n-\n-#define COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     scan_tp_[0] = ~ scan_fp_[0];\t\t\t\t\\\n-     scan_tp_[1] = ~ scan_fp_[1];\t\t\t\t\\\n-     scan_tp_[2] = ~ scan_fp_[2];\t\t\t\t\\\n-     scan_tp_[3] = ~ scan_fp_[3]; } while (0)\n-\n-#define AND_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     scan_tp_[0] &= scan_fp_[0];\t\t\t\t\\\n-     scan_tp_[1] &= scan_fp_[1];\t\t\t\t\\\n-     scan_tp_[2] &= scan_fp_[2];\t\t\t\t\\\n-     scan_tp_[3] &= scan_fp_[3]; } while (0)\n-\n-#define AND_COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     scan_tp_[0] &= ~ scan_fp_[0];\t\t\t\t\\\n-     scan_tp_[1] &= ~ scan_fp_[1];\t\t\t\t\\\n-     scan_tp_[2] &= ~ scan_fp_[2];\t\t\t\t\\\n-     scan_tp_[3] &= ~ scan_fp_[3]; } while (0)\n-\n-#define IOR_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     scan_tp_[0] |= scan_fp_[0];\t\t\t\t\\\n-     scan_tp_[1] |= scan_fp_[1];\t\t\t\t\\\n-     scan_tp_[2] |= scan_fp_[2];\t\t\t\t\\\n-     scan_tp_[3] |= scan_fp_[3]; } while (0)\n-\n-#define IOR_COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     scan_tp_[0] |= ~ scan_fp_[0];\t\t\t\t\\\n-     scan_tp_[1] |= ~ scan_fp_[1];\t\t\t\t\\\n-     scan_tp_[2] |= ~ scan_fp_[2];\t\t\t\t\\\n-     scan_tp_[3] |= ~ scan_fp_[3]; } while (0)\n-\n-static inline bool\n-hard_reg_set_subset_p (const HARD_REG_SET x, const HARD_REG_SET y)\n-{\n-  return ((x[0] & ~y[0]) == 0\n-\t  && (x[1] & ~y[1]) == 0\n-\t  && (x[2] & ~y[2]) == 0\n-\t  && (x[3] & ~y[3]) == 0);\n-}\n-\n-static inline bool\n-hard_reg_set_equal_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+inline void\n+AND_COMPL_HARD_REG_SET (HARD_REG_SET &to, const_hard_reg_set from)\n {\n-  return x[0] == y[0] && x[1] == y[1] && x[2] == y[2] && x[3] == y[3];\n+  for (unsigned int i = 0; i < ARRAY_SIZE (to.elts); ++i)\n+    to.elts[i] &= ~from.elts[i];\n }\n \n-static inline bool\n-hard_reg_set_intersect_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+inline void\n+IOR_HARD_REG_SET (HARD_REG_SET &to, const_hard_reg_set from)\n {\n-  return ((x[0] & y[0]) != 0\n-\t  || (x[1] & y[1]) != 0\n-\t  || (x[2] & y[2]) != 0\n-\t  || (x[3] & y[3]) != 0);\n+  for (unsigned int i = 0; i < ARRAY_SIZE (to.elts); ++i)\n+    to.elts[i] |= from.elts[i];\n }\n \n-static inline bool\n-hard_reg_set_empty_p (const HARD_REG_SET x)\n+inline void\n+IOR_COMPL_HARD_REG_SET (HARD_REG_SET &to, const_hard_reg_set from)\n {\n-  return x[0] == 0 && x[1] == 0 && x[2] == 0 && x[3] == 0;\n+  for (unsigned int i = 0; i < ARRAY_SIZE (to.elts); ++i)\n+    to.elts[i] |= ~from.elts[i];\n }\n \n-#else /* FIRST_PSEUDO_REGISTER > 4*HOST_BITS_PER_WIDEST_FAST_INT */\n-\n-#define CLEAR_HARD_REG_SET(TO)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     int i;\t\t\t\t\t\t\t\\\n-     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n-       *scan_tp_++ = 0; } while (0)\n-\n-#define SET_HARD_REG_SET(TO)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     int i;\t\t\t\t\t\t\t\\\n-     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n-       *scan_tp_++ = -1; } while (0)\n-\n-#define COPY_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     int i;\t\t\t\t\t\t\t\\\n-     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n-       *scan_tp_++ = *scan_fp_++; } while (0)\n-\n-#define COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     int i;\t\t\t\t\t\t\t\\\n-     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n-       *scan_tp_++ = ~ *scan_fp_++; } while (0)\n-\n-#define AND_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     int i;\t\t\t\t\t\t\t\\\n-     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n-       *scan_tp_++ &= *scan_fp_++; } while (0)\n-\n-#define AND_COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     int i;\t\t\t\t\t\t\t\\\n-     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n-       *scan_tp_++ &= ~ *scan_fp_++; } while (0)\n-\n-#define IOR_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     int i;\t\t\t\t\t\t\t\\\n-     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n-       *scan_tp_++ |= *scan_fp_++; } while (0)\n-\n-#define IOR_COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n-     const HARD_REG_ELT_TYPE *scan_fp_ = (FROM);\t\t\\\n-     int i;\t\t\t\t\t\t\t\\\n-     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n-       *scan_tp_++ |= ~ *scan_fp_++; } while (0)\n-\n static inline bool\n-hard_reg_set_subset_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+hard_reg_set_subset_p (const_hard_reg_set x, const_hard_reg_set y)\n {\n-  int i;\n-\n-  for (i = 0; i < HARD_REG_SET_LONGS; i++)\n-    if ((x[i] & ~y[i]) != 0)\n-      return false;\n-  return true;\n+  HARD_REG_ELT_TYPE bad = 0;\n+  for (unsigned int i = 0; i < ARRAY_SIZE (x.elts); ++i)\n+    bad |= (x.elts[i] & ~y.elts[i]);\n+  return bad == 0;\n }\n \n static inline bool\n-hard_reg_set_equal_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+hard_reg_set_equal_p (const_hard_reg_set x, const_hard_reg_set y)\n {\n-  int i;\n-\n-  for (i = 0; i < HARD_REG_SET_LONGS; i++)\n-    if (x[i] != y[i])\n-      return false;\n-  return true;\n+  HARD_REG_ELT_TYPE bad = 0;\n+  for (unsigned int i = 0; i < ARRAY_SIZE (x.elts); ++i)\n+    bad |= (x.elts[i] ^ y.elts[i]);\n+  return bad == 0;\n }\n \n static inline bool\n-hard_reg_set_intersect_p (const HARD_REG_SET x, const HARD_REG_SET y)\n+hard_reg_set_intersect_p (const_hard_reg_set x, const_hard_reg_set y)\n {\n-  int i;\n-\n-  for (i = 0; i < HARD_REG_SET_LONGS; i++)\n-    if ((x[i] & y[i]) != 0)\n-      return true;\n-  return false;\n+  HARD_REG_ELT_TYPE good = 0;\n+  for (unsigned int i = 0; i < ARRAY_SIZE (x.elts); ++i)\n+    good |= (x.elts[i] & y.elts[i]);\n+  return good != 0;\n }\n \n static inline bool\n-hard_reg_set_empty_p (const HARD_REG_SET x)\n+hard_reg_set_empty_p (const_hard_reg_set x)\n {\n-  int i;\n-\n-  for (i = 0; i < HARD_REG_SET_LONGS; i++)\n-    if (x[i] != 0)\n-      return false;\n-  return true;\n+  HARD_REG_ELT_TYPE bad = 0;\n+  for (unsigned int i = 0; i < ARRAY_SIZE (x.elts); ++i)\n+    bad |= x.elts[i];\n+  return bad == 0;\n }\n-\n-#endif\n-#endif\n-#endif\n #endif\n \n /* Iterator for hard register sets.  */\n \n struct hard_reg_set_iterator\n {\n   /* Pointer to the current element.  */\n-  HARD_REG_ELT_TYPE *pelt;\n+  const HARD_REG_ELT_TYPE *pelt;\n \n   /* The length of the set.  */\n   unsigned short length;\n@@ -534,11 +287,11 @@ struct hard_reg_set_iterator\n /* The implementation of the iterator functions is fully analogous to\n    the bitmap iterators.  */\n static inline void\n-hard_reg_set_iter_init (hard_reg_set_iterator *iter, HARD_REG_SET set,\n+hard_reg_set_iter_init (hard_reg_set_iterator *iter, const_hard_reg_set set,\n                         unsigned min, unsigned *regno)\n {\n #ifdef HARD_REG_SET_LONGS\n-  iter->pelt = set;\n+  iter->pelt = set.elts;\n   iter->length = HARD_REG_SET_LONGS;\n #else\n   iter->pelt = &set;"}, {"sha": "3d81c90200525cc0a3cbe7596bfa8ae1f09c0424", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/504279ae0a0ce28ad37f820dcdb7f6557aabef7c/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/504279ae0a0ce28ad37f820dcdb7f6557aabef7c/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=504279ae0a0ce28ad37f820dcdb7f6557aabef7c", "patch": "@@ -237,7 +237,7 @@ setup_cost_classes (cost_classes_t from)\n    allocated.  */\n static cost_classes_t\n restrict_cost_classes (cost_classes_t full, machine_mode mode,\n-\t\t       const HARD_REG_SET &regs)\n+\t\t       const_hard_reg_set regs)\n {\n   static struct cost_classes narrow;\n   int map[N_REG_CLASSES];"}, {"sha": "71d88e3e376de813577e532d8cf727e374dbdace", "filename": "gcc/recog.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/504279ae0a0ce28ad37f820dcdb7f6557aabef7c/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/504279ae0a0ce28ad37f820dcdb7f6557aabef7c/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=504279ae0a0ce28ad37f820dcdb7f6557aabef7c", "patch": "@@ -142,7 +142,7 @@ extern void preprocess_constraints (rtx_insn *);\n extern rtx_insn *peep2_next_insn (int);\n extern int peep2_regno_dead_p (int, int);\n extern int peep2_reg_dead_p (int, rtx);\n-#ifdef CLEAR_HARD_REG_SET\n+#ifdef HARD_CONST\n extern rtx peep2_find_free_register (int, int, const char *,\n \t\t\t\t     machine_mode, HARD_REG_SET *);\n #endif"}, {"sha": "4634abc7ece12706b9991eda0c257adeda839b56", "filename": "gcc/regs.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/504279ae0a0ce28ad37f820dcdb7f6557aabef7c/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/504279ae0a0ce28ad37f820dcdb7f6557aabef7c/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=504279ae0a0ce28ad37f820dcdb7f6557aabef7c", "patch": "@@ -298,7 +298,7 @@ remove_from_hard_reg_set (HARD_REG_SET *regs, machine_mode mode,\n /* Return true if REGS contains the whole of (reg:MODE REGNO).  */\n \n static inline bool\n-in_hard_reg_set_p (const HARD_REG_SET regs, machine_mode mode,\n+in_hard_reg_set_p (const_hard_reg_set regs, machine_mode mode,\n \t\t   unsigned int regno)\n {\n   unsigned int end_regno;\n@@ -323,7 +323,7 @@ in_hard_reg_set_p (const HARD_REG_SET regs, machine_mode mode,\n /* Return true if (reg:MODE REGNO) includes an element of REGS.  */\n \n static inline bool\n-overlaps_hard_reg_set_p (const HARD_REG_SET regs, machine_mode mode,\n+overlaps_hard_reg_set_p (const_hard_reg_set regs, machine_mode mode,\n \t\t\t unsigned int regno)\n {\n   unsigned int end_regno;\n@@ -363,7 +363,7 @@ remove_range_from_hard_reg_set (HARD_REG_SET *regs, unsigned int regno,\n /* Like overlaps_hard_reg_set_p, but use a REGNO/NREGS range instead of\n    REGNO and MODE.  */\n static inline bool\n-range_overlaps_hard_reg_set_p (const HARD_REG_SET set, unsigned regno,\n+range_overlaps_hard_reg_set_p (const_hard_reg_set set, unsigned regno,\n \t\t\t       int nregs)\n {\n   while (nregs-- > 0)\n@@ -375,7 +375,7 @@ range_overlaps_hard_reg_set_p (const HARD_REG_SET set, unsigned regno,\n /* Like in_hard_reg_set_p, but use a REGNO/NREGS range instead of\n    REGNO and MODE.  */\n static inline bool\n-range_in_hard_reg_set_p (const HARD_REG_SET set, unsigned regno, int nregs)\n+range_in_hard_reg_set_p (const_hard_reg_set set, unsigned regno, int nregs)\n {\n   while (nregs-- > 0)\n     if (!TEST_HARD_REG_BIT (set, regno + nregs))"}, {"sha": "86f0fff57f19fe8e145b3c4a03d1d66f1bffc13d", "filename": "gcc/reload.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/504279ae0a0ce28ad37f820dcdb7f6557aabef7c/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/504279ae0a0ce28ad37f820dcdb7f6557aabef7c/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=504279ae0a0ce28ad37f820dcdb7f6557aabef7c", "patch": "@@ -274,7 +274,7 @@ extern int reload_first_uid;\n \n extern int num_not_at_initial_offset;\n \n-#if defined SET_HARD_REG_BIT && defined CLEAR_REG_SET\n+#if defined HARD_CONST && defined CLEAR_REG_SET\n /* This structure describes instructions which are relevant for reload.\n    Apart from all regular insns, this also includes CODE_LABELs, since they\n    must be examined for register elimination.  */\n@@ -326,7 +326,7 @@ extern class insn_chain *reload_insn_chain;\n extern class insn_chain *new_insn_chain (void);\n #endif\n \n-#if defined SET_HARD_REG_BIT\n+#if defined HARD_CONST\n extern void compute_use_by_pseudos (HARD_REG_SET *, bitmap);\n #endif\n "}, {"sha": "b9e1fe74a01d334922c641d2feb2f19fc1551066", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/504279ae0a0ce28ad37f820dcdb7f6557aabef7c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/504279ae0a0ce28ad37f820dcdb7f6557aabef7c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=504279ae0a0ce28ad37f820dcdb7f6557aabef7c", "patch": "@@ -3377,8 +3377,7 @@ extern bool val_signbit_known_clear_p (machine_mode,\n \t\t\t\t       unsigned HOST_WIDE_INT);\n \n /* In reginfo.c  */\n-extern machine_mode choose_hard_reg_mode (unsigned int, unsigned int,\n-\t\t\t\t\t       bool);\n+extern machine_mode choose_hard_reg_mode (unsigned int, unsigned int, bool);\n extern const HARD_REG_SET &simplifiable_subregs (const subreg_shape &);\n \n /* In emit-rtl.c  */"}, {"sha": "257422cd2a61cf0db59322a1291a6235e391ac8e", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/504279ae0a0ce28ad37f820dcdb7f6557aabef7c/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/504279ae0a0ce28ad37f820dcdb7f6557aabef7c/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=504279ae0a0ce28ad37f820dcdb7f6557aabef7c", "patch": "@@ -151,8 +151,8 @@ live_edge_for_reg (basic_block bb, int regno, int end_regno)\n \n static bool\n move_insn_for_shrink_wrap (basic_block bb, rtx_insn *insn,\n-\t\t\t   const HARD_REG_SET uses,\n-\t\t\t   const HARD_REG_SET defs,\n+\t\t\t   const_hard_reg_set uses,\n+\t\t\t   const_hard_reg_set defs,\n \t\t\t   bool *split_p,\n \t\t\t   struct dead_debug_local *debug)\n {"}]}