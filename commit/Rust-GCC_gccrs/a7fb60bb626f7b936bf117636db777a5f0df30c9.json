{"sha": "a7fb60bb626f7b936bf117636db777a5f0df30c9", "node_id": "C_kwDOANBUbNoAKGE3ZmI2MGJiNjI2ZjdiOTM2YmYxMTc2MzZkYjc3N2E1ZjBkZjMwYzk", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-11-08T01:36:59Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-11-16T14:19:22Z"}, "message": "Add support compound assignment operator overloads\n\nFixes #249", "tree": {"sha": "300c1dac1d15aff0eec5cd1e0a0f549e6fd20e78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/300c1dac1d15aff0eec5cd1e0a0f549e6fd20e78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7fb60bb626f7b936bf117636db777a5f0df30c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7fb60bb626f7b936bf117636db777a5f0df30c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7fb60bb626f7b936bf117636db777a5f0df30c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7fb60bb626f7b936bf117636db777a5f0df30c9/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "432add899f4e436d0d30b89ef87fe19e71b36955", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/432add899f4e436d0d30b89ef87fe19e71b36955", "html_url": "https://github.com/Rust-GCC/gccrs/commit/432add899f4e436d0d30b89ef87fe19e71b36955"}], "stats": {"total": 412, "additions": 387, "deletions": 25}, "files": [{"sha": "4fc69d3f67bb1e1b4bcb70e7bbf7ff9b80b284aa", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7fb60bb626f7b936bf117636db777a5f0df30c9/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7fb60bb626f7b936bf117636db777a5f0df30c9/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=a7fb60bb626f7b936bf117636db777a5f0df30c9", "patch": "@@ -135,6 +135,121 @@ CompileExpr::visit (HIR::ArithmeticOrLogicalExpr &expr)\n \t\t\t\t\t    nullptr, expr.get_locus ());\n }\n \n+void\n+CompileExpr::visit (HIR::CompoundAssignmentExpr &expr)\n+{\n+  fncontext fn = ctx->peek_fn ();\n+\n+  auto op = expr.get_expr_type ();\n+  auto lhs = CompileExpr::Compile (expr.get_left_expr ().get (), ctx);\n+  auto rhs = CompileExpr::Compile (expr.get_right_expr ().get (), ctx);\n+\n+  // this might be an operator overload situation lets check\n+  TyTy::FnType *fntype;\n+  bool is_op_overload = ctx->get_tyctx ()->lookup_operator_overload (\n+    expr.get_mappings ().get_hirid (), &fntype);\n+  if (!is_op_overload)\n+    {\n+      auto operator_expr\n+\t= ctx->get_backend ()->arithmetic_or_logical_expression (\n+\t  op, lhs, rhs, expr.get_locus ());\n+      Bstatement *assignment\n+\t= ctx->get_backend ()->assignment_statement (fn.fndecl, lhs,\n+\t\t\t\t\t\t     operator_expr,\n+\t\t\t\t\t\t     expr.get_locus ());\n+      ctx->add_statement (assignment);\n+      return;\n+    }\n+\n+  // lookup the resolved name\n+  NodeId resolved_node_id = UNKNOWN_NODEID;\n+  if (!ctx->get_resolver ()->lookup_resolved_name (\n+\texpr.get_mappings ().get_nodeid (), &resolved_node_id))\n+    {\n+      rust_error_at (expr.get_locus (), \"failed to lookup resolved MethodCall\");\n+      return;\n+    }\n+\n+  // reverse lookup\n+  HirId ref;\n+  if (!ctx->get_mappings ()->lookup_node_to_hir (\n+\texpr.get_mappings ().get_crate_num (), resolved_node_id, &ref))\n+    {\n+      rust_fatal_error (expr.get_locus (), \"reverse lookup failure\");\n+      return;\n+    }\n+\n+  TyTy::BaseType *receiver = nullptr;\n+  bool ok\n+    = ctx->get_tyctx ()->lookup_receiver (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t  &receiver);\n+  rust_assert (ok);\n+\n+  bool is_dyn_dispatch\n+    = receiver->get_root ()->get_kind () == TyTy::TypeKind::DYNAMIC;\n+  bool is_generic_receiver = receiver->get_kind () == TyTy::TypeKind::PARAM;\n+  if (is_generic_receiver)\n+    {\n+      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (receiver);\n+      receiver = p->resolve ();\n+    }\n+\n+  if (is_dyn_dispatch)\n+    {\n+      const TyTy::DynamicObjectType *dyn\n+\t= static_cast<const TyTy::DynamicObjectType *> (receiver->get_root ());\n+\n+      std::vector<HIR::Expr *> arguments;\n+      arguments.push_back (expr.get_right_expr ().get ());\n+\n+      translated = compile_dyn_dispatch_call (dyn, receiver, fntype, lhs,\n+\t\t\t\t\t      arguments, expr.get_locus ());\n+      return;\n+    }\n+\n+  // lookup compiled functions since it may have already been compiled\n+  HIR::PathIdentSegment segment_name (\"add_assign\");\n+  Bexpression *fn_expr\n+    = resolve_method_address (fntype, ref, receiver, segment_name,\n+\t\t\t      expr.get_mappings (), expr.get_locus ());\n+\n+  // lookup the autoderef mappings\n+  std::vector<Resolver::Adjustment> *adjustments = nullptr;\n+  ok = ctx->get_tyctx ()->lookup_autoderef_mappings (\n+    expr.get_mappings ().get_hirid (), &adjustments);\n+  rust_assert (ok);\n+\n+  Bexpression *self = lhs;\n+  for (auto &adjustment : *adjustments)\n+    {\n+      switch (adjustment.get_type ())\n+\t{\n+\tcase Resolver::Adjustment::AdjustmentType::IMM_REF:\n+\tcase Resolver::Adjustment::AdjustmentType::MUT_REF:\n+\t  self = ctx->get_backend ()->address_expression (\n+\t    self, expr.get_left_expr ()->get_locus ());\n+\t  break;\n+\n+\tcase Resolver::Adjustment::AdjustmentType::DEREF_REF:\n+\t  Btype *expected_type\n+\t    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n+\t  self = ctx->get_backend ()->indirect_expression (\n+\t    expected_type, self, true, /* known_valid*/\n+\t    expr.get_left_expr ()->get_locus ());\n+\t  break;\n+\t}\n+    }\n+\n+  std::vector<Bexpression *> args;\n+  args.push_back (self); // adjusted self\n+  args.push_back (rhs);\n+\n+  auto fncontext = ctx->peek_fn ();\n+  translated\n+    = ctx->get_backend ()->call_expression (fncontext.fndecl, fn_expr, args,\n+\t\t\t\t\t    nullptr, expr.get_locus ());\n+}\n+\n Bexpression *\n CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n \t\t\t\t\tTyTy::BaseType *receiver,"}, {"sha": "bdcc5b68796982711874d48bfa586000324d80d5", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7fb60bb626f7b936bf117636db777a5f0df30c9/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7fb60bb626f7b936bf117636db777a5f0df30c9/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=a7fb60bb626f7b936bf117636db777a5f0df30c9", "patch": "@@ -388,22 +388,7 @@ class CompileExpr : public HIRCompileBase\n     ctx->add_statement (assignment);\n   }\n \n-  void visit (HIR::CompoundAssignmentExpr &expr) override\n-  {\n-    fncontext fn = ctx->peek_fn ();\n-    auto lvalue = CompileExpr::Compile (expr.get_left_expr ().get (), ctx);\n-    auto rvalue = CompileExpr::Compile (expr.get_right_expr ().get (), ctx);\n-\n-    auto op = expr.get_expr_type ();\n-    auto operator_expr = ctx->get_backend ()->arithmetic_or_logical_expression (\n-      op, lvalue, rvalue, expr.get_locus ());\n-\n-    Bstatement *assignment\n-      = ctx->get_backend ()->assignment_statement (fn.fndecl, lvalue,\n-\t\t\t\t\t\t   operator_expr,\n-\t\t\t\t\t\t   expr.get_locus ());\n-    ctx->add_statement (assignment);\n-  }\n+  void visit (HIR::CompoundAssignmentExpr &expr) override;\n \n   void visit (HIR::ArrayIndexExpr &expr) override\n   {"}, {"sha": "db347551e846f6ddbafd87b19d6d238bf39cb3c8", "filename": "gcc/rust/typecheck/rust-autoderef.h", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7fb60bb626f7b936bf117636db777a5f0df30c9/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7fb60bb626f7b936bf117636db777a5f0df30c9/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h?ref=a7fb60bb626f7b936bf117636db777a5f0df30c9", "patch": "@@ -68,6 +68,47 @@ class Adjustment\n   const TyTy::BaseType *expected;\n };\n \n+class Adjuster\n+{\n+public:\n+  Adjuster (const TyTy::BaseType *ty) : base (ty) {}\n+\n+  TyTy::BaseType *adjust_type (std::vector<Adjustment> adjustments)\n+  {\n+    TyTy::BaseType *ty = base->clone ();\n+    for (auto &adjustment : adjustments)\n+      {\n+\tswitch (adjustment.get_type ())\n+\t  {\n+\t  case Resolver::Adjustment::AdjustmentType::IMM_REF:\n+\t    ty = new TyTy::ReferenceType (ty->get_ref (),\n+\t\t\t\t\t  TyTy::TyVar (ty->get_ref ()),\n+\t\t\t\t\t  Mutability::Imm);\n+\t    break;\n+\n+\t  case Resolver::Adjustment::AdjustmentType::MUT_REF:\n+\t    ty = new TyTy::ReferenceType (ty->get_ref (),\n+\t\t\t\t\t  TyTy::TyVar (ty->get_ref ()),\n+\t\t\t\t\t  Mutability::Mut);\n+\t    break;\n+\n+\t  case Resolver::Adjustment::AdjustmentType::DEREF_REF:\n+\t    // FIXME this really needs to support deref lang-item operator\n+\t    // overloads\n+\t    rust_assert (ty->get_kind () == TyTy::TypeKind::REF);\n+\t    const TyTy::ReferenceType *rr\n+\t      = static_cast<const TyTy::ReferenceType *> (ty);\n+\t    ty = rr->get_base ();\n+\t    break;\n+\t  }\n+      }\n+    return ty;\n+  }\n+\n+private:\n+  const TyTy::BaseType *base;\n+};\n+\n } // namespace Resolver\n } // namespace Rust\n "}, {"sha": "977b8170d3360487ba79bcd42beabbfe97cec11c", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 202, "deletions": 9, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7fb60bb626f7b936bf117636db777a5f0df30c9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7fb60bb626f7b936bf117636db777a5f0df30c9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=a7fb60bb626f7b936bf117636db777a5f0df30c9", "patch": "@@ -477,20 +477,213 @@ class TypeCheckExpr : public TypeCheckBase\n     auto lhs = TypeCheckExpr::Resolve (expr.get_left_expr ().get (), false);\n     auto rhs = TypeCheckExpr::Resolve (expr.get_right_expr ().get (), false);\n \n-    bool valid_lhs = validate_arithmetic_type (lhs, expr.get_expr_type ());\n-    bool valid_rhs = validate_arithmetic_type (rhs, expr.get_expr_type ());\n-    bool valid = valid_lhs && valid_rhs;\n-    if (!valid)\n+    // we dont care about the result of the unify from a compound assignment\n+    // since this is a unit-type expr\n+    auto result = lhs->unify (rhs);\n+    if (result->get_kind () == TyTy::TypeKind::ERROR)\n+      return;\n+\n+    // in order to probe of the correct type paths we need the root type, which\n+    // strips any references\n+    const TyTy::BaseType *root = lhs->get_root ();\n+\n+    // look up lang item for arithmetic type\n+    std::vector<PathProbeCandidate> candidates;\n+    auto lang_item_type\n+      = Analysis::RustLangItem::CompoundAssignmentOperatorToLangItem (\n+\texpr.get_expr_type ());\n+    std::string associated_item_name\n+      = Analysis::RustLangItem::ToString (lang_item_type);\n+    DefId respective_lang_item_id = UNKNOWN_DEFID;\n+    bool lang_item_defined\n+      = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n+\n+    // probe for the lang-item\n+    if (lang_item_defined)\n+      {\n+\tbool receiver_is_type_param\n+\t  = root->get_kind () == TyTy::TypeKind::PARAM;\n+\tbool receiver_is_dyn = root->get_kind () == TyTy::TypeKind::DYNAMIC;\n+\n+\tbool receiver_is_generic = receiver_is_type_param || receiver_is_dyn;\n+\tbool probe_bounds = true;\n+\tbool probe_impls = !receiver_is_generic;\n+\tbool ignore_mandatory_trait_items = !receiver_is_generic;\n+\n+\tcandidates = PathProbeType::Probe (\n+\t  root, HIR::PathIdentSegment (associated_item_name), probe_impls,\n+\t  probe_bounds, ignore_mandatory_trait_items, respective_lang_item_id);\n+      }\n+\n+    // autoderef\n+    std::vector<Adjustment> adjustments;\n+    PathProbeCandidate *resolved_candidate\n+      = MethodResolution::Select (candidates, lhs, adjustments);\n+\n+    // is this the case we are recursive\n+    // handle the case where we are within the impl block for this lang_item\n+    // otherwise we end up with a recursive operator overload such as the i32\n+    // operator overload trait\n+    if (lang_item_defined && resolved_candidate != nullptr)\n+      {\n+\tTypeCheckContextItem &fn_context = context->peek_context ();\n+\tif (fn_context.get_type () == TypeCheckContextItem::ItemType::IMPL_ITEM)\n+\t  {\n+\t    auto &impl_item = fn_context.get_impl_item ();\n+\t    HIR::ImplBlock *parent = impl_item.first;\n+\t    HIR::Function *fn = impl_item.second;\n+\n+\t    if (parent->has_trait_ref ()\n+\t\t&& fn->get_function_name ().compare (associated_item_name) == 0)\n+\t      {\n+\t\tTraitReference *trait_reference\n+\t\t  = TraitResolver::Lookup (*parent->get_trait_ref ().get ());\n+\t\tif (!trait_reference->is_error ())\n+\t\t  {\n+\t\t    TyTy::BaseType *lookup = nullptr;\n+\t\t    bool ok\n+\t\t      = context->lookup_type (fn->get_mappings ().get_hirid (),\n+\t\t\t\t\t      &lookup);\n+\t\t    rust_assert (ok);\n+\t\t    rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+\n+\t\t    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n+\t\t    rust_assert (fntype->is_method ());\n+\n+\t\t    Adjuster adj (lhs);\n+\t\t    TyTy::BaseType *adjusted = adj.adjust_type (adjustments);\n+\n+\t\t    bool is_lang_item_impl\n+\t\t      = trait_reference->get_mappings ().get_defid ()\n+\t\t\t== respective_lang_item_id;\n+\t\t    bool self_is_lang_item_self\n+\t\t      = fntype->get_self_type ()->is_equal (*adjusted);\n+\t\t    bool recursive_operator_overload\n+\t\t      = is_lang_item_impl && self_is_lang_item_self;\n+\n+\t\t    lang_item_defined = !recursive_operator_overload;\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+\n+    bool have_implementation_for_lang_item = resolved_candidate != nullptr;\n+    if (!lang_item_defined || !have_implementation_for_lang_item)\n+      {\n+\tbool valid_lhs = validate_arithmetic_type (lhs, expr.get_expr_type ());\n+\tbool valid_rhs = validate_arithmetic_type (rhs, expr.get_expr_type ());\n+\tbool valid = valid_lhs && valid_rhs;\n+\tif (!valid)\n+\t  {\n+\t    rust_error_at (expr.get_locus (),\n+\t\t\t   \"cannot apply this operator to types %s and %s\",\n+\t\t\t   lhs->as_string ().c_str (),\n+\t\t\t   rhs->as_string ().c_str ());\n+\t    return;\n+\t  }\n+\n+\t// nothing left to do\n+\treturn;\n+      }\n+\n+    // now its just like a method-call-expr\n+    context->insert_receiver (expr.get_mappings ().get_hirid (), lhs);\n+\n+    // store the adjustments for code-generation to know what to do\n+    context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\tstd::move (adjustments));\n+\n+    TyTy::BaseType *lookup_tyty = resolved_candidate->ty;\n+    NodeId resolved_node_id\n+      = resolved_candidate->is_impl_candidate ()\n+\t  ? resolved_candidate->item.impl.impl_item->get_impl_mappings ()\n+\t      .get_nodeid ()\n+\t  : resolved_candidate->item.trait.item_ref->get_mappings ()\n+\t      .get_nodeid ();\n+\n+    rust_assert (lookup_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+    TyTy::BaseType *lookup = lookup_tyty;\n+    TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n+    rust_assert (fn->is_method ());\n+\n+    if (root->get_kind () == TyTy::TypeKind::ADT)\n+      {\n+\tconst TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (root);\n+\tif (adt->has_substitutions () && fn->needs_substitution ())\n+\t  {\n+\t    // consider the case where we have:\n+\t    //\n+\t    // struct Foo<X,Y>(X,Y);\n+\t    //\n+\t    // impl<T> Foo<T, i32> {\n+\t    //   fn test<X>(self, a:X) -> (T,X) { (self.0, a) }\n+\t    // }\n+\t    //\n+\t    // In this case we end up with an fn type of:\n+\t    //\n+\t    // fn <T,X> test(self:Foo<T,i32>, a:X) -> (T,X)\n+\t    //\n+\t    // This means the instance or self we are calling this method for\n+\t    // will be substituted such that we can get the inherited type\n+\t    // arguments but then need to use the turbo fish if available or\n+\t    // infer the remaining arguments. Luckily rust does not allow for\n+\t    // default types GenericParams on impl blocks since these must\n+\t    // always be at the end of the list\n+\n+\t    auto s = fn->get_self_type ()->get_root ();\n+\t    rust_assert (s->can_eq (adt, false, false));\n+\t    rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n+\t    const TyTy::ADTType *self_adt\n+\t      = static_cast<const TyTy::ADTType *> (s);\n+\n+\t    // we need to grab the Self substitutions as the inherit type\n+\t    // parameters for this\n+\t    if (self_adt->needs_substitution ())\n+\t      {\n+\t\trust_assert (adt->was_substituted ());\n+\n+\t\tTyTy::SubstitutionArgumentMappings used_args_in_prev_segment\n+\t\t  = GetUsedSubstArgs::From (adt);\n+\n+\t\tTyTy::SubstitutionArgumentMappings inherit_type_args\n+\t\t  = self_adt->solve_mappings_from_receiver_for_self (\n+\t\t    used_args_in_prev_segment);\n+\n+\t\t// there may or may not be inherited type arguments\n+\t\tif (!inherit_type_args.is_error ())\n+\t\t  {\n+\t\t    // need to apply the inherited type arguments to the\n+\t\t    // function\n+\t\t    lookup = fn->handle_substitions (inherit_type_args);\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+\n+    // type check the arguments\n+    TyTy::FnType *type = static_cast<TyTy::FnType *> (lookup);\n+    rust_assert (type->num_params () == 2);\n+    auto fnparam = type->param_at (1);\n+    auto resolved_argument_type = fnparam.second->unify (rhs);\n+    if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n       {\n \trust_error_at (expr.get_locus (),\n-\t\t       \"cannot apply this operator to types %s and %s\",\n-\t\t       lhs->as_string ().c_str (), rhs->as_string ().c_str ());\n+\t\t       \"Type Resolution failure on parameter\");\n \treturn;\n       }\n \n-    auto result = lhs->unify (rhs);\n-    if (result->get_kind () == TyTy::TypeKind::ERROR)\n-      return;\n+    // get the return type\n+    TyTy::BaseType *function_ret_tyty = fn->get_return_type ()->clone ();\n+\n+    // store the expected fntype\n+    context->insert_operator_overload (expr.get_mappings ().get_hirid (), type);\n+\n+    // set up the resolved name on the path\n+    resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t    resolved_node_id);\n+\n+    // return the result of the function back\n+    infered = function_ret_tyty;\n   }\n \n   void visit (HIR::IdentifierExpr &expr) override"}, {"sha": "bcbd582b34b7cdf2eedd5aca1b15b7c1f1ee963c", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7fb60bb626f7b936bf117636db777a5f0df30c9/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7fb60bb626f7b936bf117636db777a5f0df30c9/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=a7fb60bb626f7b936bf117636db777a5f0df30c9", "patch": "@@ -41,7 +41,9 @@ class RustLangItem\n     MULTIPLY,\n     DIVIDE,\n     REMAINDER,\n+\n     NEGATION,\n+\n     ADD_ASSIGN,\n     SUB_ASSIGN,\n     MUL_ASSIGN,\n@@ -158,6 +160,32 @@ class RustLangItem\n       }\n     return ItemType::UNKNOWN;\n   }\n+\n+  static ItemType\n+  CompoundAssignmentOperatorToLangItem (ArithmeticOrLogicalOperator op)\n+  {\n+    switch (op)\n+      {\n+      case ArithmeticOrLogicalOperator::ADD:\n+\treturn ItemType::ADD_ASSIGN;\n+      case ArithmeticOrLogicalOperator::SUBTRACT:\n+\treturn ItemType::SUB_ASSIGN;\n+      case ArithmeticOrLogicalOperator::MULTIPLY:\n+\treturn ItemType::MUL_ASSIGN;\n+      case ArithmeticOrLogicalOperator::DIVIDE:\n+\treturn ItemType::DIV_ASSIGN;\n+      case ArithmeticOrLogicalOperator::MODULUS:\n+\treturn ItemType::REM_ASSIGN;\n+\n+      case ArithmeticOrLogicalOperator::BITWISE_AND:\n+      case ArithmeticOrLogicalOperator::BITWISE_OR:\n+      case ArithmeticOrLogicalOperator::BITWISE_XOR:\n+      case ArithmeticOrLogicalOperator::LEFT_SHIFT:\n+      case ArithmeticOrLogicalOperator::RIGHT_SHIFT:\n+\treturn ItemType::UNKNOWN;\n+      }\n+    return ItemType::UNKNOWN;\n+  }\n };\n \n class NodeMapping"}]}