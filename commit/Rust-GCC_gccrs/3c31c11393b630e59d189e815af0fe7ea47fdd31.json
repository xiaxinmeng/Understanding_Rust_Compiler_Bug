{"sha": "3c31c11393b630e59d189e815af0fe7ea47fdd31", "node_id": "C_kwDOANBUbNoAKDNjMzFjMTEzOTNiNjMwZTU5ZDE4OWU4MTVhZjBmZTdlYTQ3ZmRkMzE", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-05-18T09:13:56Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-05-20T11:35:33Z"}, "message": "privacy: PrivacyReporter: Add type privacy checking on explicit types\n\nprivacy: Circumvent weird behavior about inference types for now\n\nThe issue we're facing is detailed in #1260. It's not necessary to fix\nnow to have a good type privacy base\n\nprivacy: PrivacyReporter: Handle projections and placeholders", "tree": {"sha": "566c819b0ea648a73e9fc19577b51e60ec03fc3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/566c819b0ea648a73e9fc19577b51e60ec03fc3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c31c11393b630e59d189e815af0fe7ea47fdd31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c31c11393b630e59d189e815af0fe7ea47fdd31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c31c11393b630e59d189e815af0fe7ea47fdd31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c31c11393b630e59d189e815af0fe7ea47fdd31/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64a41cce91795561c2b007cb25ad4e43b53d126a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64a41cce91795561c2b007cb25ad4e43b53d126a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64a41cce91795561c2b007cb25ad4e43b53d126a"}], "stats": {"total": 205, "additions": 198, "deletions": 7}, "files": [{"sha": "cab46b27b5d9be6929c05dcf9e21f7129f6ea682", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c31c11393b630e59d189e815af0fe7ea47fdd31/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c31c11393b630e59d189e815af0fe7ea47fdd31/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=3c31c11393b630e59d189e815af0fe7ea47fdd31", "patch": "@@ -486,6 +486,8 @@ class Type : public Node\n   virtual Type *clone_type_impl () const = 0;\n \n   Analysis::NodeMapping mappings;\n+\n+  // FIXME: How do we get the location here for each type?\n };\n \n // A type without parentheses? - abstract"}, {"sha": "9664d62f65c4fa2ebc8f5a38d832f431e203a13c", "filename": "gcc/rust/privacy/rust-privacy-check.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c31c11393b630e59d189e815af0fe7ea47fdd31/gcc%2Frust%2Fprivacy%2Frust-privacy-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c31c11393b630e59d189e815af0fe7ea47fdd31/gcc%2Frust%2Fprivacy%2Frust-privacy-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-privacy-check.cc?ref=3c31c11393b630e59d189e815af0fe7ea47fdd31", "patch": "@@ -41,7 +41,7 @@ Resolver::resolve (HIR::Crate &crate)\n \n   VisibilityResolver (*mappings, *resolver).go (crate);\n   PubRestrictedVisitor (*mappings).go (crate);\n-  PrivacyReporter (*mappings, *resolver).go (crate);\n+  PrivacyReporter (*mappings, *resolver, *ty_ctx).go (crate);\n \n   auto visitor = ReachabilityVisitor (ctx, *ty_ctx);\n "}, {"sha": "1685a969d453543c48eded033fc82661cf212a2e", "filename": "gcc/rust/privacy/rust-privacy-reporter.cc", "status": "modified", "additions": 115, "deletions": 5, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c31c11393b630e59d189e815af0fe7ea47fdd31/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c31c11393b630e59d189e815af0fe7ea47fdd31/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.cc?ref=3c31c11393b630e59d189e815af0fe7ea47fdd31", "patch": "@@ -6,9 +6,10 @@\n namespace Rust {\n namespace Privacy {\n \n-PrivacyReporter::PrivacyReporter (Analysis::Mappings &mappings,\n-\t\t\t\t  Resolver::Resolver &resolver)\n-  : mappings (mappings), resolver (resolver),\n+PrivacyReporter::PrivacyReporter (\n+  Analysis::Mappings &mappings, Resolver::Resolver &resolver,\n+  const Rust::Resolver::TypeCheckContext &ty_ctx)\n+  : mappings (mappings), resolver (resolver), ty_ctx (ty_ctx),\n     current_module (Optional<NodeId>::none ())\n {}\n \n@@ -52,7 +53,11 @@ PrivacyReporter::check_for_privacy_violation (const NodeId &use_id,\n   if (!resolver.lookup_resolved_name (use_id, &ref_node_id))\n     resolver.lookup_resolved_type (use_id, &ref_node_id);\n \n-  rust_assert (ref_node_id != UNKNOWN_NODEID);\n+  // FIXME: Assert here. For now, we return since this causes issues when\n+  // checking inferred types (#1260)\n+  // rust_assert (ref_node_id != UNKNOWN_NODEID);\n+  if (ref_node_id == UNKNOWN_NODEID)\n+    return;\n \n   ModuleVisibility vis;\n \n@@ -97,6 +102,102 @@ PrivacyReporter::check_for_privacy_violation (const NodeId &use_id,\n     rust_error_at (locus, \"definition is private in this context\");\n }\n \n+void\n+PrivacyReporter::check_base_type_privacy (Analysis::NodeMapping &node_mappings,\n+\t\t\t\t\t  const TyTy::BaseType *ty,\n+\t\t\t\t\t  const Location &locus)\n+{\n+  // Avoids repeating commong argument such as `use_id` or `locus` since we're\n+  // doing a lot of recursive calls here\n+  auto recursive_check\n+    = [this, &node_mappings, &locus] (const TyTy::BaseType *ty) {\n+\treturn check_base_type_privacy (node_mappings, ty, locus);\n+      };\n+\n+  switch (ty->get_kind ())\n+    {\n+      // These \"simple\" types are our stop condition\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::ADT:\n+      case TyTy::STR: {\n+\tauto ref_id = ty->get_ref ();\n+\tNodeId lookup_id;\n+\n+\tmappings.lookup_hir_to_node (node_mappings.get_crate_num (), ref_id,\n+\t\t\t\t     &lookup_id);\n+\n+\treturn check_for_privacy_violation (lookup_id, locus);\n+      }\n+    case TyTy::REF:\n+      return recursive_check (\n+\tstatic_cast<const TyTy::ReferenceType *> (ty)->get_base ());\n+    case TyTy::POINTER:\n+      return recursive_check (\n+\tstatic_cast<const TyTy::PointerType *> (ty)->get_base ());\n+    case TyTy::ARRAY:\n+      return recursive_check (\n+\tstatic_cast<const TyTy::ArrayType *> (ty)->get_element_type ());\n+    case TyTy::SLICE:\n+      return recursive_check (\n+\tstatic_cast<const TyTy::SliceType *> (ty)->get_element_type ());\n+    case TyTy::FNPTR:\n+      for (auto &param : static_cast<const TyTy::FnPtr *> (ty)->get_params ())\n+\trecursive_check (param.get_tyty ());\n+      return recursive_check (\n+\tstatic_cast<const TyTy::FnPtr *> (ty)->get_return_type ());\n+    case TyTy::TUPLE:\n+      for (auto &param :\n+\t   static_cast<const TyTy::TupleType *> (ty)->get_fields ())\n+\trecursive_check (param.get_tyty ());\n+      return;\n+    case TyTy::PLACEHOLDER:\n+      return recursive_check (\n+\t// FIXME: Can we use `resolve` here? Is that what we should do?\n+\tstatic_cast<const TyTy::PlaceholderType *> (ty)->resolve ());\n+    case TyTy::PROJECTION:\n+      return recursive_check (\n+\tstatic_cast<const TyTy::ProjectionType *> (ty)->get ());\n+    case TyTy::NEVER:\n+    case TyTy::CLOSURE:\n+    case TyTy::ERROR:\n+    case TyTy::INFER:\n+      rust_unreachable ();\n+      break;\n+\n+      // If we're dealing with a generic param, there's nothing we should be\n+      // doing here\n+    case TyTy::PARAM:\n+      // We are dealing with a function definition that has been assigned\n+      // somewhere else. Nothing to resolve privacy-wise other than the actual\n+      // function, which is resolved as an expression\n+    case TyTy::FNDEF:\n+      // FIXME: Can we really not resolve Dynamic types here? Shouldn't we have\n+      // a look at the path and perform proper privacy analysis?\n+    case TyTy::DYNAMIC:\n+      return;\n+    }\n+}\n+\n+void\n+PrivacyReporter::check_type_privacy (const HIR::Type *type,\n+\t\t\t\t     const Location &locus)\n+{\n+  rust_assert (type);\n+\n+  TyTy::BaseType *lookup = nullptr;\n+  rust_assert (\n+    ty_ctx.lookup_type (type->get_mappings ().get_hirid (), &lookup));\n+\n+  auto node_mappings = type->get_mappings ();\n+  return check_base_type_privacy (node_mappings, lookup, locus);\n+}\n+\n void\n PrivacyReporter::visit (HIR::IdentifierExpr &ident_expr)\n {}\n@@ -529,6 +630,11 @@ PrivacyReporter::visit (HIR::UseDeclaration &use_decl)\n void\n PrivacyReporter::visit (HIR::Function &function)\n {\n+  for (auto &param : function.get_function_params ())\n+    check_type_privacy (param.get_type (), param.get_locus ());\n+\n+  // FIXME: It would be better if it was specifically the type's locus (#1256)\n+\n   function.get_definition ()->accept_vis (*this);\n }\n \n@@ -626,7 +732,11 @@ PrivacyReporter::visit (HIR::EmptyStmt &stmt)\n void\n PrivacyReporter::visit (HIR::LetStmt &stmt)\n {\n-  // FIXME: We probably have to check the type as well\n+  auto type = stmt.get_type ();\n+  if (type)\n+    check_type_privacy (type, stmt.get_locus ());\n+  // FIXME: #1256\n+\n   auto init_expr = stmt.get_init_expr ();\n   if (init_expr)\n     init_expr->accept_vis (*this);"}, {"sha": "234bea718dca3b9b43d7f96eca5ae8ab162c7530", "filename": "gcc/rust/privacy/rust-privacy-reporter.h", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c31c11393b630e59d189e815af0fe7ea47fdd31/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c31c11393b630e59d189e815af0fe7ea47fdd31/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.h?ref=3c31c11393b630e59d189e815af0fe7ea47fdd31", "patch": "@@ -37,7 +37,8 @@ class PrivacyReporter : public HIR::HIRExpressionVisitor,\n {\n public:\n   PrivacyReporter (Analysis::Mappings &mappings,\n-\t\t   Rust::Resolver::Resolver &resolver);\n+\t\t   Rust::Resolver::Resolver &resolver,\n+\t\t   const Rust::Resolver::TypeCheckContext &ty_ctx);\n \n   /**\n    * Perform privacy error reporting on an entire crate\n@@ -57,6 +58,26 @@ class PrivacyReporter : public HIR::HIRExpressionVisitor,\n   void check_for_privacy_violation (const NodeId &use_id,\n \t\t\t\t    const Location &locus);\n \n+  /**\n+   * Internal function used by `check_type_privacy` when dealing with complex\n+types\n+   * such as references or arrays\n+   */\n+  void check_base_type_privacy (Analysis::NodeMapping &node_mappings,\n+\t\t\t\tconst TyTy::BaseType *ty,\n+\t\t\t\tconst Location &locus);\n+\n+  /**\n+   * Check the privacy of an explicit type.\n+   *\n+   * This function reports the errors it finds.\n+   *\n+   * @param type Reference to an explicit type used in a statement, expression\n+   * \t\tor parameter\n+   * @param locus Location of said type\n+   */\n+  void check_type_privacy (const HIR::Type *type, const Location &locus);\n+\n   virtual void visit (HIR::StructExprFieldIdentifier &field);\n   virtual void visit (HIR::StructExprFieldIdentifierValue &field);\n   virtual void visit (HIR::StructExprFieldIndexValue &field);\n@@ -142,6 +163,7 @@ class PrivacyReporter : public HIR::HIRExpressionVisitor,\n \n   Analysis::Mappings &mappings;\n   Rust::Resolver::Resolver &resolver;\n+  const Rust::Resolver::TypeCheckContext &ty_ctx;\n \n   // `None` means we're in the root module - the crate\n   Optional<NodeId> current_module;"}, {"sha": "ad552c73abec2a3dd87f38440418db9c7d51cc9b", "filename": "gcc/testsuite/rust/compile/privacy5.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c31c11393b630e59d189e815af0fe7ea47fdd31/gcc%2Ftestsuite%2Frust%2Fcompile%2Fprivacy5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c31c11393b630e59d189e815af0fe7ea47fdd31/gcc%2Ftestsuite%2Frust%2Fcompile%2Fprivacy5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fprivacy5.rs?ref=3c31c11393b630e59d189e815af0fe7ea47fdd31", "patch": "@@ -0,0 +1,18 @@\n+mod orange {\n+    mod green {\n+        struct Foo;\n+        pub(in orange) struct Bar;\n+        pub struct Baz;\n+    }\n+\n+    fn brown() {\n+        let _ = green::Foo; // { dg-error \"definition is private in this context\" }\n+        let _ = green::Bar;\n+        let _ = green::Baz;\n+\n+        let _: green::Foo; // { dg-error \"definition is private in this context\" }\n+\n+        fn any(a0: green::Foo, a1: green::Bar) {}\n+        // { dg-error \"definition is private in this context\" \"\" { target *-*-* } .-1 }\n+    }\n+}"}, {"sha": "487ed02420902028a10f66eb06323386f5d192fc", "filename": "gcc/testsuite/rust/compile/privacy6.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c31c11393b630e59d189e815af0fe7ea47fdd31/gcc%2Ftestsuite%2Frust%2Fcompile%2Fprivacy6.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c31c11393b630e59d189e815af0fe7ea47fdd31/gcc%2Ftestsuite%2Frust%2Fcompile%2Fprivacy6.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fprivacy6.rs?ref=3c31c11393b630e59d189e815af0fe7ea47fdd31", "patch": "@@ -0,0 +1,39 @@\n+// { dg-additional-options \"-w\" }\n+\n+struct Adt;\n+enum EAdt {\n+    V0,\n+    V1,\n+}\n+struct Registers {\n+    r0: i64,\n+    r1: i64,\n+    r2: i64,\n+    r3: i64,\n+}\n+trait Foo {}\n+\n+fn foo1(value: bool) {}\n+fn foo2(value: char) {}\n+fn foo3(value: i32) {}\n+fn foo4(value: u16) {}\n+fn foo5(value: f64) {}\n+fn foo6(value: usize) {}\n+fn foo7(value: isize) {}\n+fn foo8(value: Adt) {}\n+fn foo9(value: EAdt) {}\n+fn foo10(value: &str) {}\n+fn foo11(value: *const i8) {}\n+fn foo12<T>(value: T) {}\n+fn foo13(value: [i32; 5]) {}\n+fn foo14(value: [Adt]) {}\n+fn foo15(value: fn(i32) -> i32) {}\n+fn foo16(value: (i32, Adt)) {}\n+fn foo17(value: (i32, [f64; 5])) {}\n+fn foo18(value: Registers) {}\n+fn foo19(value: &dyn Foo) {}\n+fn foo20(value: &[Adt]) {}\n+// FIXME: Uncomment once #1257 is fixed\n+// fn foo21(value: fn(i32)) {}\n+// fn foo22(value: fn()) {}\n+fn foo23(value: fn() -> i32) {}"}]}