{"sha": "ef3cfba23d0f9c518cc71ff053994e77e80f1d1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYzY2ZiYTIzZDBmOWM1MThjYzcxZmYwNTM5OTRlNzdlODBmMWQxYQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-10-11T20:31:25Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-10-11T20:31:25Z"}, "message": "re PR tree-optimization/58640 (wrong code (segfaults) at -O3 on x86_64-linux-gnu)\n\n\tPR tree-optimization/58640\n\t* tree-ssa-threadupdate.c (mark_threaded_blocks): Truncate jump threading\n\tpaths that cross over two loop entry points.\n\n\t* gcc.c-torture/execute/pr58640.c: New test.\n\nFrom-SVN: r203463", "tree": {"sha": "df0943cec3572628c3fbfa0e8b03d172da3a36a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df0943cec3572628c3fbfa0e8b03d172da3a36a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef3cfba23d0f9c518cc71ff053994e77e80f1d1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef3cfba23d0f9c518cc71ff053994e77e80f1d1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef3cfba23d0f9c518cc71ff053994e77e80f1d1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef3cfba23d0f9c518cc71ff053994e77e80f1d1a/comments", "author": null, "committer": null, "parents": [{"sha": "6e8b7d9cd6c483e85dc243ac4edf561ca7d8f7ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e8b7d9cd6c483e85dc243ac4edf561ca7d8f7ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e8b7d9cd6c483e85dc243ac4edf561ca7d8f7ef"}], "stats": {"total": 104, "additions": 104, "deletions": 0}, "files": [{"sha": "9f4e2975ae0105900de2615bb877e137ef2c0eb1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3cfba23d0f9c518cc71ff053994e77e80f1d1a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3cfba23d0f9c518cc71ff053994e77e80f1d1a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef3cfba23d0f9c518cc71ff053994e77e80f1d1a", "patch": "@@ -1,3 +1,9 @@\n+2013-10-11  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/58640\n+\t* tree-ssa-threadupdate.c (mark_threaded_blocks): Truncate jump threading\n+\tpaths that cross over two loop entry points.\n+\n 2013-10-11  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* config/rs6000/vsx.md (*vsx_le_perm_load_v2di): Generalize to"}, {"sha": "bb2ede41cb5e5474949205f7b595de0307bbb721", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3cfba23d0f9c518cc71ff053994e77e80f1d1a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3cfba23d0f9c518cc71ff053994e77e80f1d1a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ef3cfba23d0f9c518cc71ff053994e77e80f1d1a", "patch": "@@ -1,3 +1,7 @@\n+2013-10-11  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.c-torture/execute/pr58640.c: New test.\n+\n 2013-10-11  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/58633"}, {"sha": "7786b8d0c9fde7fe2a7e9e019cb1d7e762215ffc", "filename": "gcc/testsuite/gcc.c-torture/execute/pr58640.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3cfba23d0f9c518cc71ff053994e77e80f1d1a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr58640.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3cfba23d0f9c518cc71ff053994e77e80f1d1a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr58640.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr58640.c?ref=ef3cfba23d0f9c518cc71ff053994e77e80f1d1a", "patch": "@@ -0,0 +1,32 @@\n+int a, b, c, d = 1, e;\n+\n+static signed char\n+foo ()\n+{\n+  int f, g = a;\n+\n+  for (f = 1; f < 3; f++)\n+    for (; b < 1; b++)\n+      {\n+        if (d)\n+          for (c = 0; c < 4; c++)\n+            for (f = 0; f < 3; f++)\n+              {\n+                for (e = 0; e < 1; e++)\n+                  a = g;\n+                if (f)\n+                  break;\n+              }\n+        else if (f)\n+          continue;\n+        return 0;\n+      }\n+  return 0;\n+}\n+\n+int\n+main ()\n+{\n+  foo ();\n+  exit (0);\n+}"}, {"sha": "3e34567d8c128bb66b8378aa196015939751b0c0", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3cfba23d0f9c518cc71ff053994e77e80f1d1a/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3cfba23d0f9c518cc71ff053994e77e80f1d1a/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=ef3cfba23d0f9c518cc71ff053994e77e80f1d1a", "patch": "@@ -1354,6 +1354,68 @@ mark_threaded_blocks (bitmap threaded_blocks)\n   else\n     bitmap_copy (threaded_blocks, tmp);\n \n+  /* Look for jump threading paths which cross multiple loop headers.\n+\n+     The code to thread through loop headers will change the CFG in ways\n+     that break assumptions made by the loop optimization code.\n+\n+     We don't want to blindly cancel the requests.  We can instead do better\n+     by trimming off the end of the jump thread path.  */\n+  EXECUTE_IF_SET_IN_BITMAP (tmp, 0, i, bi)\n+    {\n+      basic_block bb = BASIC_BLOCK (i);\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\t{\n+\t  if (e->aux)\n+\t    {\n+\t      vec<jump_thread_edge *> *path = THREAD_PATH (e);\n+\n+\t      /* Basically we're looking for a situation where we can see\n+\t  \t 3 or more loop structures on a jump threading path.  */\n+\n+\t      struct loop *first_father = (*path)[0]->e->src->loop_father;\n+\t      struct loop *second_father = NULL;\n+\t      for (unsigned int i = 0; i < path->length (); i++)\n+\t\t{\n+\t\t  /* See if this is a loop father we have not seen before.  */\n+\t\t  if ((*path)[i]->e->dest->loop_father != first_father\n+\t\t      && (*path)[i]->e->dest->loop_father != second_father)\n+\t\t    {\n+\t\t      /* We've already seen two loop fathers, so we\n+\t\t\t need to trim this jump threading path.  */\n+\t\t      if (second_father != NULL)\n+\t\t\t{\n+\t\t\t  /* Trim from entry I onwards.  */\n+\t\t\t  for (unsigned int j = i; j < path->length (); j++)\n+\t\t\t    delete (*path)[j];\n+\t\t\t  path->truncate (i);\n+\n+\t\t\t  /* Now that we've truncated the path, make sure\n+\t\t\t     what's left is still valid.   We need at least\n+\t\t\t     two edges on the path and the last edge can not\n+\t\t\t     be a joiner.  This should never happen, but let's\n+\t\t\t     be safe.  */\n+\t\t\t  if (path->length () < 2\n+\t\t\t      || (path->last ()->type\n+\t\t\t\t  == EDGE_COPY_SRC_JOINER_BLOCK))\n+\t\t\t    {\n+\t\t\t      for (unsigned int i = 0; i < path->length (); i++)\n+\t\t\t\tdelete (*path)[i];\n+\t\t\t      path->release ();\n+\t\t\t      e->aux = NULL;\n+\t\t\t    }\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  second_father = (*path)[i]->e->dest->loop_father;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n   BITMAP_FREE (tmp);\n }\n "}]}