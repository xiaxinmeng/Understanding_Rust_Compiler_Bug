{"sha": "6f572ac2297814f19a9889bf5797a67b12d2f353", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY1NzJhYzIyOTc4MTRmMTlhOTg4OWJmNTc5N2E2N2IxMmQyZjM1Mw==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.co.uk", "date": "2003-04-19T16:34:33Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2003-04-19T16:34:33Z"}, "message": "cpphash.h (struct cpp_buffer): Remove backup_to.\n\n\t* cpphash.h (struct cpp_buffer): Remove backup_to.\n\t* cpplex.c (BACKUP, get_effective_char): Die.\n\t(_cpp_skip_block_comment): Assume '*' is location on entry.\n\t(continues_identifier_p): Respect -fno-dollars-in-identifiers.\n\t(IF_NEXT_IS): Update.\n\t(_cpp_lex_direct): Don't use backup_to; look ahead directly.\n\nFrom-SVN: r65819", "tree": {"sha": "c6e984f92e62ca75600cad3e046c2697c0472890", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6e984f92e62ca75600cad3e046c2697c0472890"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f572ac2297814f19a9889bf5797a67b12d2f353", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f572ac2297814f19a9889bf5797a67b12d2f353", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f572ac2297814f19a9889bf5797a67b12d2f353", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f572ac2297814f19a9889bf5797a67b12d2f353/comments", "author": {"login": "neilb-xx", "id": 160762, "node_id": "MDQ6VXNlcjE2MDc2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/160762?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neilb-xx", "html_url": "https://github.com/neilb-xx", "followers_url": "https://api.github.com/users/neilb-xx/followers", "following_url": "https://api.github.com/users/neilb-xx/following{/other_user}", "gists_url": "https://api.github.com/users/neilb-xx/gists{/gist_id}", "starred_url": "https://api.github.com/users/neilb-xx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neilb-xx/subscriptions", "organizations_url": "https://api.github.com/users/neilb-xx/orgs", "repos_url": "https://api.github.com/users/neilb-xx/repos", "events_url": "https://api.github.com/users/neilb-xx/events{/privacy}", "received_events_url": "https://api.github.com/users/neilb-xx/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ced2ad76877637601a852871803d1dbba8e6d55a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ced2ad76877637601a852871803d1dbba8e6d55a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ced2ad76877637601a852871803d1dbba8e6d55a"}], "stats": {"total": 271, "additions": 109, "deletions": 162}, "files": [{"sha": "9c99f2e131bb221df33cb650964029df558e5974", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f572ac2297814f19a9889bf5797a67b12d2f353/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f572ac2297814f19a9889bf5797a67b12d2f353/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f572ac2297814f19a9889bf5797a67b12d2f353", "patch": "@@ -1,3 +1,12 @@\n+2003-04-19  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* cpphash.h (struct cpp_buffer): Remove backup_to.\n+\t* cpplex.c (BACKUP, get_effective_char): Die.\n+\t(_cpp_skip_block_comment): Assume '*' is location on entry.\n+\t(continues_identifier_p): Respect -fno-dollars-in-identifiers.\n+\t(IF_NEXT_IS): Update.\n+\t(_cpp_lex_direct): Don't use backup_to; look ahead directly.\n+\n 2003-04-19  Matt Kraai  <kraai@alumni.cmu.edu>\n \n \t* README.Portability: Move to a new section and obsolete K+R"}, {"sha": "f1ee4a6eb90954111084732e98a1dd95a14269e7", "filename": "gcc/cpphash.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f572ac2297814f19a9889bf5797a67b12d2f353/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f572ac2297814f19a9889bf5797a67b12d2f353/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=6f572ac2297814f19a9889bf5797a67b12d2f353", "patch": "@@ -267,8 +267,6 @@ struct cpp_buffer\n \n   struct cpp_buffer *prev;\n \n-  const unsigned char *backup_to; /* Soon to die.  */\n-\n   /* Pointer into the include table; non-NULL if this is a file\n      buffer.  Used for include_next and to record control macros.  */\n   struct include_file *inc;"}, {"sha": "c8caa393d9ea9c3830e137444758b9a9295ae433", "filename": "gcc/cpplex.c", "status": "modified", "additions": 100, "deletions": 160, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f572ac2297814f19a9889bf5797a67b12d2f353/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f572ac2297814f19a9889bf5797a67b12d2f353/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=6f572ac2297814f19a9889bf5797a67b12d2f353", "patch": "@@ -55,11 +55,8 @@ static const struct token_spelling token_spellings[N_TTYPES] = { TTYPE_TABLE };\n \n #define TOKEN_SPELL(token) (token_spellings[(token)->type].category)\n #define TOKEN_NAME(token) (token_spellings[(token)->type].name)\n-#define BACKUP() do {buffer->cur = buffer->backup_to;} while (0)\n \n static void add_line_note PARAMS ((cpp_buffer *, const uchar *, unsigned int));\n-static cppchar_t get_effective_char PARAMS ((cpp_reader *));\n-\n static int skip_line_comment PARAMS ((cpp_reader *));\n static void skip_whitespace PARAMS ((cpp_reader *, cppchar_t));\n static cpp_hashnode *lex_identifier PARAMS ((cpp_reader *));\n@@ -246,31 +243,19 @@ _cpp_process_line_notes (pfile, in_comment)\n     }\n }\n \n-/* Obtain the next character, after trigraph conversion and skipping\n-   an arbitrarily long string of escaped newlines.  The common case of\n-   no trigraphs or escaped newlines falls through quickly.  On return,\n-   buffer->backup_to points to where to return to if the character is\n-   not to be processed.  */\n-static cppchar_t\n-get_effective_char (pfile)\n-     cpp_reader *pfile;\n-{\n-  cpp_buffer *buffer = pfile->buffer;\n-\n-  buffer->backup_to = buffer->cur;\n-  return *buffer->cur++;\n-}\n-\n /* Skip a C-style block comment.  We find the end of the comment by\n    seeing if an asterisk is before every '/' we encounter.  Returns\n-   nonzero if comment terminated by EOF, zero otherwise.  */\n+   nonzero if comment terminated by EOF, zero otherwise.\n+\n+   Buffer->cur points to the initial asterisk of the comment.  */\n bool\n _cpp_skip_block_comment (pfile)\n      cpp_reader *pfile;\n {\n   cpp_buffer *buffer = pfile->buffer;\n   cppchar_t c;\n \n+  buffer->cur++;\n   if (*buffer->cur == '/')\n     buffer->cur++;\n \n@@ -381,7 +366,7 @@ static bool\n continues_identifier_p (pfile)\n      cpp_reader *pfile;\n {\n-  if (*pfile->buffer->cur != '$')\n+  if (*pfile->buffer->cur != '$' || !CPP_OPTION (pfile, dollars_in_ident))\n     return false;\n \n   if (CPP_PEDANTIC (pfile) && !pfile->state.skipping && !pfile->warned_dollar)\n@@ -492,8 +477,7 @@ lex_string (pfile, token)\n     {\n       cppchar_t c = *buffer->cur++;\n \n-      /* In #include-style directives, terminators are not escapable.\n-\t \\n can follow the '\\\\' if the file's last byte is '\\\\'.  */\n+      /* In #include-style directives, terminators are not escapable.  */\n       if (c == '\\\\' && !pfile->state.angled_headers && *buffer->cur != '\\n')\n \tbuffer->cur++;\n       else if (c == terminator || c == '\\n')\n@@ -728,16 +712,14 @@ _cpp_get_fresh_line (pfile)\n     }\n }\n \n-#define IF_NEXT_IS(CHAR, THEN_TYPE, ELSE_TYPE)\t\\\n-  do {\t\t\t\t\t\t\\\n-    if (get_effective_char (pfile) == CHAR)\t\\\n-      result->type = THEN_TYPE;\t\t\t\\\n-    else\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\\\n-        BACKUP ();\t\t\t\t\\\n-        result->type = ELSE_TYPE;\t\t\\\n-      }\t\t\t\t\t\t\\\n-  } while (0)\n+#define IF_NEXT_IS(CHAR, THEN_TYPE, ELSE_TYPE)\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      result->type = ELSE_TYPE;\t\t\t\t\\\n+      if (*buffer->cur == CHAR)\t\t\t\t\\\n+\tbuffer->cur++, result->type = THEN_TYPE;\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Lex a token into pfile->cur_token, which is also incremented, to\n    get diagnostics pointing to the correct location.\n@@ -853,8 +835,8 @@ _cpp_lex_direct (pfile)\n     case '/':\n       /* A potential block or line comment.  */\n       comment_start = buffer->cur;\n-      c = get_effective_char (pfile);\n-\n+      c = *buffer->cur;\n+      \n       if (c == '*')\n \t{\n \t  if (_cpp_skip_block_comment (pfile))\n@@ -880,12 +862,12 @@ _cpp_lex_direct (pfile)\n \t}\n       else if (c == '=')\n \t{\n+\t  buffer->cur++;\n \t  result->type = CPP_DIV_EQ;\n \t  break;\n \t}\n       else\n \t{\n-\t  BACKUP ();\n \t  result->type = CPP_DIV;\n \t  break;\n \t}\n@@ -908,179 +890,137 @@ _cpp_lex_direct (pfile)\n \t  break;\n \t}\n \n-      c = get_effective_char (pfile);\n-      if (c == '=')\n-\tresult->type = CPP_LESS_EQ;\n-      else if (c == '<')\n-\tIF_NEXT_IS ('=', CPP_LSHIFT_EQ, CPP_LSHIFT);\n-      else if (c == '?' && CPP_OPTION (pfile, cplusplus))\n-\tIF_NEXT_IS ('=', CPP_MIN_EQ, CPP_MIN);\n-      else if (c == ':' && CPP_OPTION (pfile, digraphs))\n+      result->type = CPP_LESS;\n+      if (*buffer->cur == '=')\n+\tbuffer->cur++, result->type = CPP_LESS_EQ;\n+      else if (*buffer->cur == '<')\n \t{\n-\t  result->type = CPP_OPEN_SQUARE;\n-\t  result->flags |= DIGRAPH;\n+\t  buffer->cur++;\n+\t  IF_NEXT_IS ('=', CPP_LSHIFT_EQ, CPP_LSHIFT);\n \t}\n-      else if (c == '%' && CPP_OPTION (pfile, digraphs))\n+      else if (*buffer->cur == '?' && CPP_OPTION (pfile, cplusplus))\n \t{\n-\t  result->type = CPP_OPEN_BRACE;\n-\t  result->flags |= DIGRAPH;\n+\t  buffer->cur++;\n+\t  IF_NEXT_IS ('=', CPP_MIN_EQ, CPP_MIN);\n \t}\n-      else\n+      else if (CPP_OPTION (pfile, digraphs))\n \t{\n-\t  BACKUP ();\n-\t  result->type = CPP_LESS;\n+\t  if (*buffer->cur == ':')\n+\t    {\n+\t      buffer->cur++;\n+\t      result->flags |= DIGRAPH;\n+\t      result->type = CPP_OPEN_SQUARE;\n+\t    }\n+\t  else if (*buffer->cur == '%')\n+\t    {\n+\t      buffer->cur++;\n+\t      result->flags |= DIGRAPH;\n+\t      result->type = CPP_OPEN_BRACE;\n+\t    }\n \t}\n       break;\n \n     case '>':\n-      c = get_effective_char (pfile);\n-      if (c == '=')\n-\tresult->type = CPP_GREATER_EQ;\n-      else if (c == '>')\n-\tIF_NEXT_IS ('=', CPP_RSHIFT_EQ, CPP_RSHIFT);\n-      else if (c == '?' && CPP_OPTION (pfile, cplusplus))\n-\tIF_NEXT_IS ('=', CPP_MAX_EQ, CPP_MAX);\n-      else\n+      result->type = CPP_GREATER;\n+      if (*buffer->cur == '=')\n+\tbuffer->cur++, result->type = CPP_GREATER_EQ;\n+      else if (*buffer->cur == '>')\n+\t{\n+\t  buffer->cur++;\n+\t  IF_NEXT_IS ('=', CPP_RSHIFT_EQ, CPP_RSHIFT);\n+\t}\n+      else if (*buffer->cur == '?' && CPP_OPTION (pfile, cplusplus))\n \t{\n-\t  BACKUP ();\n-\t  result->type = CPP_GREATER;\n+\t  buffer->cur++;\n+\t  IF_NEXT_IS ('=', CPP_MAX_EQ, CPP_MAX);\n \t}\n       break;\n \n     case '%':\n-      c = get_effective_char (pfile);\n-      if (c == '=')\n-\tresult->type = CPP_MOD_EQ;\n-      else if (CPP_OPTION (pfile, digraphs) && c == ':')\n+      result->type = CPP_MOD;\n+      if (*buffer->cur == '=')\n+\tbuffer->cur++, result->type = CPP_MOD_EQ;\n+      else if (CPP_OPTION (pfile, digraphs))\n \t{\n-\t  result->flags |= DIGRAPH;\n-\t  result->type = CPP_HASH;\n-\t  if (get_effective_char (pfile) == '%')\n+\t  if (*buffer->cur == ':')\n \t    {\n-\t      const unsigned char *pos = buffer->cur;\n-\n-\t      if (get_effective_char (pfile) == ':')\n-\t\tresult->type = CPP_PASTE;\n-\t      else\n-\t\tbuffer->cur = pos - 1;\n+\t      buffer->cur++;\n+\t      result->flags |= DIGRAPH;\n+\t      result->type = CPP_HASH;\n+\t      if (*buffer->cur == '%' && buffer->cur[1] == ':')\n+\t\tbuffer->cur += 2, result->type = CPP_PASTE;\n+\t    }\n+\t  else if (*buffer->cur == '>')\n+\t    {\n+\t      buffer->cur++;\n+\t      result->flags |= DIGRAPH;\n+\t      result->type = CPP_CLOSE_BRACE;\n \t    }\n-\t  else\n-\t    BACKUP ();\n-\t}\n-      else if (CPP_OPTION (pfile, digraphs) && c == '>')\n-\t{\n-\t  result->flags |= DIGRAPH;\n-\t  result->type = CPP_CLOSE_BRACE;\n-\t}\n-      else\n-\t{\n-\t  BACKUP ();\n-\t  result->type = CPP_MOD;\n \t}\n       break;\n \n     case '.':\n       result->type = CPP_DOT;\n-      c = get_effective_char (pfile);\n-      if (c == '.')\n+      if (ISDIGIT (*buffer->cur))\n \t{\n-\t  const unsigned char *pos = buffer->cur;\n-\n-\t  if (get_effective_char (pfile) == '.')\n-\t    result->type = CPP_ELLIPSIS;\n-\t  else\n-\t    buffer->cur = pos - 1;\n-\t}\n-      /* All known character sets have 0...9 contiguous.  */\n-      else if (ISDIGIT (c))\n-\t{\n-\t  buffer->cur--;\n \t  result->type = CPP_NUMBER;\n \t  lex_number (pfile, &result->val.str);\n \t}\n-      else if (c == '*' && CPP_OPTION (pfile, cplusplus))\n-\tresult->type = CPP_DOT_STAR;\n-      else\n-\tBACKUP ();\n+      else if (*buffer->cur == '.' && buffer->cur[1] == '.')\n+\tbuffer->cur += 2, result->type = CPP_ELLIPSIS;\n+      else if (*buffer->cur == '*' && CPP_OPTION (pfile, cplusplus))\n+\tbuffer->cur++, result->type = CPP_DOT_STAR;\n       break;\n \n     case '+':\n-      c = get_effective_char (pfile);\n-      if (c == '+')\n-\tresult->type = CPP_PLUS_PLUS;\n-      else if (c == '=')\n-\tresult->type = CPP_PLUS_EQ;\n-      else\n-\t{\n-\t  BACKUP ();\n-\t  result->type = CPP_PLUS;\n-\t}\n+      result->type = CPP_PLUS;\n+      if (*buffer->cur == '+')\n+\tbuffer->cur++, result->type = CPP_PLUS_PLUS;\n+      else if (*buffer->cur == '=')\n+\tbuffer->cur++, result->type = CPP_PLUS_EQ;\n       break;\n \n     case '-':\n-      c = get_effective_char (pfile);\n-      if (c == '>')\n+      result->type = CPP_MINUS;\n+      if (*buffer->cur == '>')\n \t{\n+\t  buffer->cur++;\n \t  result->type = CPP_DEREF;\n-\t  if (CPP_OPTION (pfile, cplusplus))\n-\t    {\n-\t      if (get_effective_char (pfile) == '*')\n-\t\tresult->type = CPP_DEREF_STAR;\n-\t      else\n-\t\tBACKUP ();\n-\t    }\n-\t}\n-      else if (c == '-')\n-\tresult->type = CPP_MINUS_MINUS;\n-      else if (c == '=')\n-\tresult->type = CPP_MINUS_EQ;\n-      else\n-\t{\n-\t  BACKUP ();\n-\t  result->type = CPP_MINUS;\n+\t  if (*buffer->cur == '*' && CPP_OPTION (pfile, cplusplus))\n+\t    buffer->cur++, result->type = CPP_DEREF_STAR;\n \t}\n+      else if (*buffer->cur == '-')\n+\tbuffer->cur++, result->type = CPP_MINUS_MINUS;\n+      else if (*buffer->cur == '=')\n+\tbuffer->cur++, result->type = CPP_MINUS_EQ;\n       break;\n \n     case '&':\n-      c = get_effective_char (pfile);\n-      if (c == '&')\n-\tresult->type = CPP_AND_AND;\n-      else if (c == '=')\n-\tresult->type = CPP_AND_EQ;\n-      else\n-\t{\n-\t  BACKUP ();\n-\t  result->type = CPP_AND;\n-\t}\n+      result->type = CPP_AND;\n+      if (*buffer->cur == '&')\n+\tbuffer->cur++, result->type = CPP_AND_AND;\n+      else if (*buffer->cur == '=')\n+\tbuffer->cur++, result->type = CPP_AND_EQ;\n       break;\n \n     case '|':\n-      c = get_effective_char (pfile);\n-      if (c == '|')\n-\tresult->type = CPP_OR_OR;\n-      else if (c == '=')\n-\tresult->type = CPP_OR_EQ;\n-      else\n-\t{\n-\t  BACKUP ();\n-\t  result->type = CPP_OR;\n-\t}\n+      result->type = CPP_OR;\n+      if (*buffer->cur == '|')\n+\tbuffer->cur++, result->type = CPP_OR_OR;\n+      else if (*buffer->cur == '=')\n+\tbuffer->cur++, result->type = CPP_OR_EQ;\n       break;\n \n     case ':':\n-      c = get_effective_char (pfile);\n-      if (c == ':' && CPP_OPTION (pfile, cplusplus))\n-\tresult->type = CPP_SCOPE;\n-      else if (c == '>' && CPP_OPTION (pfile, digraphs))\n+      result->type = CPP_COLON;\n+      if (*buffer->cur == ':' && CPP_OPTION (pfile, cplusplus))\n+\tbuffer->cur++, result->type = CPP_SCOPE;\n+      else if (*buffer->cur == '>' && CPP_OPTION (pfile, digraphs))\n \t{\n+\t  buffer->cur++;\n \t  result->flags |= DIGRAPH;\n \t  result->type = CPP_CLOSE_SQUARE;\n \t}\n-      else\n-\t{\n-\t  BACKUP ();\n-\t  result->type = CPP_COLON;\n-\t}\n       break;\n \n     case '*': IF_NEXT_IS ('=', CPP_MULT_EQ, CPP_MULT); break;"}]}