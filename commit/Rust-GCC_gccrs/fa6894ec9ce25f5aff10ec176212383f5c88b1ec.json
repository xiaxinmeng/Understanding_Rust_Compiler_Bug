{"sha": "fa6894ec9ce25f5aff10ec176212383f5c88b1ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE2ODk0ZWM5Y2UyNWY1YWZmMTBlYzE3NjIxMjM4M2Y1Yzg4YjFlYw==", "commit": {"author": {"name": "Marcel Vollweiler", "email": "marcel@codesourcery.com", "date": "2021-05-12T16:31:58Z"}, "committer": {"name": "Marcel Vollweiler", "email": "marcel@codesourcery.com", "date": "2021-05-12T16:57:55Z"}, "message": "OpenMP: Add support for 'close' in map clause\n\ngcc/c/ChangeLog:\n\n\t* c-parser.c (c_parser_omp_clause_map): Support map-type-modifier\n\t'close'.\n\ngcc/cp/ChangeLog:\n\n\t* parser.c (cp_parser_omp_clause_map): Support map-type-modifier\n\t'close'.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/gomp/map-6.c: New test.\n\t* c-c++-common/gomp/map-7.c: New test.", "tree": {"sha": "e33087f479e9af46be01e24c3731531fc63eb4c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e33087f479e9af46be01e24c3731531fc63eb4c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa6894ec9ce25f5aff10ec176212383f5c88b1ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa6894ec9ce25f5aff10ec176212383f5c88b1ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa6894ec9ce25f5aff10ec176212383f5c88b1ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa6894ec9ce25f5aff10ec176212383f5c88b1ec/comments", "author": null, "committer": null, "parents": [{"sha": "2a1586401a21dcd43e0f904bb6eec26c8b2f366b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a1586401a21dcd43e0f904bb6eec26c8b2f366b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a1586401a21dcd43e0f904bb6eec26c8b2f366b"}], "stats": {"total": 361, "additions": 283, "deletions": 78}, "files": [{"sha": "f79b8395366c609d29c39ffebb60dc8137c1db1b", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa6894ec9ce25f5aff10ec176212383f5c88b1ec/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa6894ec9ce25f5aff10ec176212383f5c88b1ec/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=fa6894ec9ce25f5aff10ec176212383f5c88b1ec", "patch": "@@ -15643,54 +15643,83 @@ c_parser_omp_clause_depend (c_parser *parser, tree list)\n    map-kind:\n      alloc | to | from | tofrom | release | delete\n \n-   map ( always [,] map-kind: variable-list ) */\n+   map ( always [,] map-kind: variable-list )\n+\n+   OpenMP 5.0:\n+   map ( [map-type-modifier[,] ...] map-kind: variable-list )\n+\n+   map-type-modifier:\n+     always | close */\n \n static tree\n c_parser_omp_clause_map (c_parser *parser, tree list)\n {\n   location_t clause_loc = c_parser_peek_token (parser)->location;\n   enum gomp_map_kind kind = GOMP_MAP_TOFROM;\n-  int always = 0;\n-  enum c_id_kind always_id_kind = C_ID_NONE;\n-  location_t always_loc = UNKNOWN_LOCATION;\n-  tree always_id = NULL_TREE;\n   tree nl, c;\n \n   matching_parens parens;\n   if (!parens.require_open (parser))\n     return list;\n \n-  if (c_parser_next_token_is (parser, CPP_NAME))\n+  int pos = 1;\n+  int map_kind_pos = 0;\n+  while (c_parser_peek_nth_token_raw (parser, pos)->type == CPP_NAME)\n+    {\n+      if (c_parser_peek_nth_token_raw (parser, pos + 1)->type == CPP_COLON)\n+\t{\n+\t  map_kind_pos = pos;\n+\t  break;\n+\t}\n+\n+      if (c_parser_peek_nth_token_raw (parser, pos + 1)->type == CPP_COMMA)\n+\tpos++;\n+      pos++;\n+    }\n+\n+  int always_modifier = 0;\n+  int close_modifier = 0;\n+  for (int pos = 1; pos < map_kind_pos; ++pos)\n     {\n       c_token *tok = c_parser_peek_token (parser);\n+\n+      if (tok->type == CPP_COMMA)\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  continue;\n+\t}\n+\n       const char *p = IDENTIFIER_POINTER (tok->value);\n-      always_id_kind = tok->id_kind;\n-      always_loc = tok->location;\n-      always_id = tok->value;\n       if (strcmp (\"always\", p) == 0)\n \t{\n-\t  c_token *sectok = c_parser_peek_2nd_token (parser);\n-\t  if (sectok->type == CPP_COMMA)\n+\t  if (always_modifier)\n \t    {\n-\t      c_parser_consume_token (parser);\n-\t      c_parser_consume_token (parser);\n-\t      always = 2;\n+\t      c_parser_error (parser, \"too many %<always%> modifiers\");\n+\t      parens.skip_until_found_close (parser);\n+\t      return list;\n \t    }\n-\t  else if (sectok->type == CPP_NAME)\n+\t  always_modifier++;\n+\t}\n+      else if (strcmp (\"close\", p) == 0)\n+\t{\n+\t  if (close_modifier)\n \t    {\n-\t      p = IDENTIFIER_POINTER (sectok->value);\n-\t      if (strcmp (\"alloc\", p) == 0\n-\t\t  || strcmp (\"to\", p) == 0\n-\t\t  || strcmp (\"from\", p) == 0\n-\t\t  || strcmp (\"tofrom\", p) == 0\n-\t\t  || strcmp (\"release\", p) == 0\n-\t\t  || strcmp (\"delete\", p) == 0)\n-\t\t{\n-\t\t  c_parser_consume_token (parser);\n-\t\t  always = 1;\n-\t\t}\n+\t      c_parser_error (parser, \"too many %<close%> modifiers\");\n+\t      parens.skip_until_found_close (parser);\n+\t      return list;\n \t    }\n+\t  close_modifier++;\n \t}\n+      else\n+\t{\n+\t  c_parser_error (parser, \"%<#pragma omp target%> with \"\n+\t\t\t\t  \"modifier other than %<always%> or %<close%>\"\n+\t\t\t\t  \"on %<map%> clause\");\n+\t  parens.skip_until_found_close (parser);\n+\t  return list;\n+\t}\n+\n+\tc_parser_consume_token (parser);\n     }\n \n   if (c_parser_next_token_is (parser, CPP_NAME)\n@@ -15700,11 +15729,11 @@ c_parser_omp_clause_map (c_parser *parser, tree list)\n       if (strcmp (\"alloc\", p) == 0)\n \tkind = GOMP_MAP_ALLOC;\n       else if (strcmp (\"to\", p) == 0)\n-\tkind = always ? GOMP_MAP_ALWAYS_TO : GOMP_MAP_TO;\n+\tkind = always_modifier ? GOMP_MAP_ALWAYS_TO : GOMP_MAP_TO;\n       else if (strcmp (\"from\", p) == 0)\n-\tkind = always ? GOMP_MAP_ALWAYS_FROM : GOMP_MAP_FROM;\n+\tkind = always_modifier ? GOMP_MAP_ALWAYS_FROM : GOMP_MAP_FROM;\n       else if (strcmp (\"tofrom\", p) == 0)\n-\tkind = always ? GOMP_MAP_ALWAYS_TOFROM : GOMP_MAP_TOFROM;\n+\tkind = always_modifier ? GOMP_MAP_ALWAYS_TOFROM : GOMP_MAP_TOFROM;\n       else if (strcmp (\"release\", p) == 0)\n \tkind = GOMP_MAP_RELEASE;\n       else if (strcmp (\"delete\", p) == 0)\n@@ -15719,35 +15748,6 @@ c_parser_omp_clause_map (c_parser *parser, tree list)\n       c_parser_consume_token (parser);\n       c_parser_consume_token (parser);\n     }\n-  else if (always)\n-    {\n-      if (always_id_kind != C_ID_ID)\n-\t{\n-\t  c_parser_error (parser, \"expected identifier\");\n-\t  parens.skip_until_found_close (parser);\n-\t  return list;\n-\t}\n-\n-      tree t = lookup_name (always_id);\n-      if (t == NULL_TREE)\n-\t{\n-\t  undeclared_variable (always_loc, always_id);\n-\t  t = error_mark_node;\n-\t}\n-      if (t != error_mark_node)\n-\t{\n-\t  tree u = build_omp_clause (clause_loc, OMP_CLAUSE_MAP);\n-\t  OMP_CLAUSE_DECL (u) = t;\n-\t  OMP_CLAUSE_CHAIN (u) = list;\n-\t  OMP_CLAUSE_SET_MAP_KIND (u, kind);\n-\t  list = u;\n-\t}\n-      if (always == 1)\n-\t{\n-\t  parens.skip_until_found_close (parser);\n-\t  return list;\n-\t}\n-    }\n \n   nl = c_parser_omp_variable_list (parser, clause_loc, OMP_CLAUSE_MAP, list);\n "}, {"sha": "41df5dd525f3251a419998e21615ce1c763d8516", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 70, "deletions": 20, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa6894ec9ce25f5aff10ec176212383f5c88b1ec/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa6894ec9ce25f5aff10ec176212383f5c88b1ec/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=fa6894ec9ce25f5aff10ec176212383f5c88b1ec", "patch": "@@ -37859,40 +37859,90 @@ cp_parser_omp_clause_depend (cp_parser *parser, tree list, location_t loc)\n    map-kind:\n      alloc | to | from | tofrom | release | delete\n \n-   map ( always [,] map-kind: variable-list ) */\n+   map ( always [,] map-kind: variable-list )\n+\n+   OpenMP 5.0:\n+   map ( [map-type-modifier[,] ...] map-kind: variable-list )\n+\n+   map-type-modifier:\n+     always | close */\n \n static tree\n cp_parser_omp_clause_map (cp_parser *parser, tree list)\n {\n   tree nlist, c;\n   enum gomp_map_kind kind = GOMP_MAP_TOFROM;\n-  bool always = false;\n \n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return list;\n \n-  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+  int pos = 1;\n+  int map_kind_pos = 0;\n+  while (cp_lexer_peek_nth_token (parser->lexer, pos)->type == CPP_NAME\n+\t || cp_lexer_peek_nth_token (parser->lexer, pos)->keyword == RID_DELETE)\n     {\n-      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n-      const char *p = IDENTIFIER_POINTER (id);\n+      if (cp_lexer_peek_nth_token (parser->lexer, pos + 1)->type == CPP_COLON)\n+\t{\n+\t  map_kind_pos = pos;\n+\t  break;\n+\t}\n+\n+      if (cp_lexer_peek_nth_token (parser->lexer, pos + 1)->type == CPP_COMMA)\n+\tpos++;\n+      pos++;\n+    }\n \n+  bool always_modifier = false;\n+  bool close_modifier = false;\n+  for (int pos = 1; pos < map_kind_pos; ++pos)\n+    {\n+      cp_token *tok = cp_lexer_peek_token (parser->lexer);\n+      if (tok->type == CPP_COMMA)\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  continue;\n+\t}\n+\n+      const char *p = IDENTIFIER_POINTER (tok->u.value);\n       if (strcmp (\"always\", p) == 0)\n \t{\n-\t  int nth = 2;\n-\t  if (cp_lexer_peek_nth_token (parser->lexer, 2)->type == CPP_COMMA)\n-\t    nth++;\n-\t  if ((cp_lexer_peek_nth_token (parser->lexer, nth)->type == CPP_NAME\n-\t       || (cp_lexer_peek_nth_token (parser->lexer, nth)->keyword\n-\t\t   == RID_DELETE))\n-\t      && (cp_lexer_peek_nth_token (parser->lexer, nth + 1)->type\n-\t\t  == CPP_COLON))\n+\t  if (always_modifier)\n \t    {\n-\t      always = true;\n-\t      cp_lexer_consume_token (parser->lexer);\n-\t      if (nth == 3)\n-\t\tcp_lexer_consume_token (parser->lexer);\n+\t      cp_parser_error (parser, \"too many %<always%> modifiers\");\n+\t      cp_parser_skip_to_closing_parenthesis (parser,\n+\t\t\t\t\t\t     /*recovering=*/true,\n+\t\t\t\t\t\t     /*or_comma=*/false,\n+\t\t\t\t\t\t     /*consume_paren=*/true);\n+\t      return list;\n+\t    }\n+\t  always_modifier = true;\n+\t}\n+      else if (strcmp (\"close\", p) == 0)\n+\t{\n+\t  if (close_modifier)\n+\t    {\n+\t      cp_parser_error (parser, \"too many %<close%> modifiers\");\n+\t      cp_parser_skip_to_closing_parenthesis (parser,\n+\t\t\t\t\t\t     /*recovering=*/true,\n+\t\t\t\t\t\t     /*or_comma=*/false,\n+\t\t\t\t\t\t     /*consume_paren=*/true);\n+\t      return list;\n \t    }\n+\t  close_modifier = true;\n \t}\n+      else\n+\t{\n+\t  cp_parser_error (parser, \"%<#pragma omp target%> with \"\n+\t\t\t\t   \"modifier other than %<always%> or %<close%>\"\n+\t\t\t\t   \"on %<map%> clause\");\n+\t  cp_parser_skip_to_closing_parenthesis (parser,\n+\t\t\t\t\t\t /*recovering=*/true,\n+\t\t\t\t\t\t /*or_comma=*/false,\n+\t\t\t\t\t\t /*consume_paren=*/true);\n+\t  return list;\n+\t}\n+\n+\tcp_lexer_consume_token (parser->lexer);\n     }\n \n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME)\n@@ -37904,11 +37954,11 @@ cp_parser_omp_clause_map (cp_parser *parser, tree list)\n       if (strcmp (\"alloc\", p) == 0)\n \tkind = GOMP_MAP_ALLOC;\n       else if (strcmp (\"to\", p) == 0)\n-\tkind = always ? GOMP_MAP_ALWAYS_TO : GOMP_MAP_TO;\n+\tkind = always_modifier ? GOMP_MAP_ALWAYS_TO : GOMP_MAP_TO;\n       else if (strcmp (\"from\", p) == 0)\n-\tkind = always ? GOMP_MAP_ALWAYS_FROM : GOMP_MAP_FROM;\n+\tkind = always_modifier ? GOMP_MAP_ALWAYS_FROM : GOMP_MAP_FROM;\n       else if (strcmp (\"tofrom\", p) == 0)\n-\tkind = always ? GOMP_MAP_ALWAYS_TOFROM : GOMP_MAP_TOFROM;\n+\tkind = always_modifier ? GOMP_MAP_ALWAYS_TOFROM : GOMP_MAP_TOFROM;\n       else if (strcmp (\"release\", p) == 0)\n \tkind = GOMP_MAP_RELEASE;\n       else"}, {"sha": "6ee59714847268f74f7acce4583d9d8af3216795", "filename": "gcc/testsuite/c-c++-common/gomp/map-6.c", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa6894ec9ce25f5aff10ec176212383f5c88b1ec/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa6894ec9ce25f5aff10ec176212383f5c88b1ec/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-6.c?ref=fa6894ec9ce25f5aff10ec176212383f5c88b1ec", "patch": "@@ -0,0 +1,135 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdump-tree-original\" } */\n+\n+void\n+foo (void)\n+{\n+  /* Test to ensure that the close modifier is parsed and ignored in map clauses. */\n+  int a, b, b1, b2, b3, b4, b5, b6, b7;\n+\n+  #pragma omp target map (a)\n+  ;\n+\n+  #pragma omp target map (to:a)\n+  ;\n+\n+  #pragma omp target map (a to: b) /* { dg-error \"'#pragma omp target' with modifier other than 'always' or 'close'\" } */\n+  ;\n+\n+  #pragma omp target map (close, a to: b) /* { dg-error \"'#pragma omp target' with modifier other than 'always' or 'close'\" } */\n+  ;\n+\n+  #pragma omp target map (close a) /* { dg-error \"'close' undeclared\" \"\" { target c } } */ \n+  /* { dg-error \"'close' has not been declared\" \"\" { target c++ } .-1 } */ \n+  /* { dg-error \"expected '\\\\)' before 'a'\" \"\" { target *-*-* } .-2 } */\n+  ;\n+\n+  #pragma omp target map (always a) /* { dg-error \"'always' undeclared\" \"\" { target c } } */\n+  /* { dg-error \"'always' has not been declared\" \"\" { target c++ } .-1 } */ \n+  /* { dg-error \"expected '\\\\)' before 'a'\" \"\" { target *-*-* } .-2 } */\n+  ;\n+\n+  #pragma omp target map (close to:a)\n+  ;\n+\n+  #pragma omp target map (close, to:a)\n+  ;\n+\n+  #pragma omp target map (close delete:a) /* { dg-error \"'#pragma omp target' with map-type other than 'to', 'from', 'tofrom' or 'alloc' on 'map' clause\" } */\n+  ;\n+\n+  #pragma omp target map (close always to:b1)\n+  ;\n+\n+  #pragma omp target map (close, always to:b2)\n+  ;\n+\n+  #pragma omp target map (close, always, to:b3)\n+  ;\n+\n+  #pragma omp target map (always close to:b4)\n+  ;\n+\n+  #pragma omp target map (always, close to:b5)\n+  ;\n+\n+  #pragma omp target map (always, close, to:b6)\n+  ;\n+\n+  #pragma omp target map (always, always, to:a) /* { dg-error \"too many 'always' modifiers\" } */\n+  ;\n+\n+  #pragma omp target map (always always, to:a) /* { dg-error \"too many 'always' modifiers\" } */\n+  ;\n+\n+  #pragma omp target map (always, always to:a) /* { dg-error \"too many 'always' modifiers\" } */\n+  ;\n+\n+  #pragma omp target map (always always to:a) /* { dg-error \"too many 'always' modifiers\" } */\n+  ;\n+\n+  #pragma omp target map (close, close, to:a) /* { dg-error \"too many 'close' modifiers\" } */\n+  ;\n+\n+  #pragma omp target map (close close, to:a) /* { dg-error \"too many 'close' modifiers\" } */\n+  ;\n+\n+  #pragma omp target map (close, close to:a) /* { dg-error \"too many 'close' modifiers\" } */\n+  ;\n+\n+  #pragma omp target map (close close to:a) /* { dg-error \"too many 'close' modifiers\" } */\n+  ;\n+\n+  #pragma omp target map (always to : a) map (close to : b)\n+  ;\n+\n+  int close = 0;\n+  #pragma omp target map (close) \n+  ;\n+\n+  #pragma omp target map (close a) /* { dg-error \"expected '\\\\)' before 'a'\" } */ \n+  ;\n+\n+  int always = 0;\n+  #pragma omp target map (always)\n+  ;\n+\n+  #pragma omp target map (always a) /* { dg-error \"expected '\\\\)' before 'a'\" } */\n+  ;\n+\n+  #pragma omp target map (always, close)\n+  ;\n+\n+  #pragma omp target map (always, always)  /* { dg-error \"'always' appears more than once in map clauses\" } */\n+  ;\n+\n+  #pragma omp target map (always, always, close)  /* { dg-error \"'always' appears more than once in map clauses\" } */\n+  ;\n+\n+  #pragma omp target map (always, close, to: always, close, b7)\n+  ;\n+\n+  int to = 0;\n+  #pragma omp target map (always, close, to)\n+  ;\n+\n+  #pragma omp target map (to, always, close)\n+    {\n+      to = always = close = 1;\n+    }\n+  if (to != 1 || always != 1 || close != 1)\n+    __builtin_abort ();\n+  ;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"map\\\\(\\[^\\n\\r)]*close\\[^\\n\\r)]*to:\" \"original\" } } */\n+\n+/* { dg-final { scan-tree-dump-times \"pragma omp target map\\\\(always,to:\" 7 \"original\" } } */\n+\n+/* { dg-final { scan-tree-dump \"pragma omp target map\\\\(always,to:b1\" \"original\" } } */\n+/* { dg-final { scan-tree-dump \"pragma omp target map\\\\(always,to:b2\" \"original\" } } */\n+/* { dg-final { scan-tree-dump \"pragma omp target map\\\\(always,to:b3\" \"original\" } } */\n+/* { dg-final { scan-tree-dump \"pragma omp target map\\\\(always,to:b4\" \"original\" } } */\n+/* { dg-final { scan-tree-dump \"pragma omp target map\\\\(always,to:b5\" \"original\" } } */\n+/* { dg-final { scan-tree-dump \"pragma omp target map\\\\(always,to:b6\" \"original\" } } */\n+/* { dg-final { scan-tree-dump \"pragma omp target map\\\\(always,to:b7\\\\) map\\\\(always,to:close\\\\) map\\\\(always,to:always\\\\)\" \"original\" } } */"}, {"sha": "3f1e9729e4178868f00dfc9be536458716b2c87f", "filename": "gcc/testsuite/c-c++-common/gomp/map-7.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa6894ec9ce25f5aff10ec176212383f5c88b1ec/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa6894ec9ce25f5aff10ec176212383f5c88b1ec/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-7.c?ref=fa6894ec9ce25f5aff10ec176212383f5c88b1ec", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+\n+void\n+foo (void)\n+{\n+  /* Test to ensure that the close modifier is parsed and ignored in map clauses. */\n+\n+  #define N 1024\n+  int always[N];\n+  int close;\n+\n+  #pragma omp target map(always[:N]) \n+  ;\n+\n+  #pragma omp target map(close, always[:N]) \n+  ;\n+\n+  #pragma omp target map(always[:N], close) \n+  ;\n+}"}]}