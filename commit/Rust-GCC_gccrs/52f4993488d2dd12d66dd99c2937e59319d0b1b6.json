{"sha": "52f4993488d2dd12d66dd99c2937e59319d0b1b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJmNDk5MzQ4OGQyZGQxMmQ2NmRkOTljMjkzN2U1OTMxOWQwYjFiNg==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2008-09-02T08:13:21Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2008-09-02T08:13:21Z"}, "message": "gfortran.h (struct gfc_namespace): New member `implicit_loc'.\n\n2008-09-02  Daniel Kraft  <d@domob.eu>\n\n\t* gfortran.h (struct gfc_namespace): New member `implicit_loc'.\n\t(gfc_add_abstract): New method.\n\t* decl.c (gfc_get_type_attr_spec): Match ABSTRACT attribute.\n\t(gfc_match_derived_decl): Copy abstract attribute in derived symbol.\n\t* dump-parse-tree.c (show_attr): Show ABSTRACT attribute as `ABSTRACT'\n\tonly to allow for ABSTRACT types.\n\t* parse.c (parse_interface): Use new gfc_add_abstract.\n\t* primary.c (gfc_match_structure_constructor): Check that no ABSTRACT\n\ttype is constructed.\n\t* resolve.c (resolve_typespec_used): New method.\n\t(resolve_fl_derived): Check type in respect to ABSTRACT attribute and\n\tcheck that no component is of an ABSTRACT type.\n\t(resolve_symbol): Check that no symbol is of an ABSTRACT type.\n\t(resolve_types): Check IMPLICIT declarations for ABSTRACT types.\n\t* symbol.c (gfc_merge_new_implicit): Remember loci of IMPLICIT's.\n\t(gfc_add_abstract): New method.\n\n2008-09-02  Daniel Kraft  <d@domob.eu>\n\n\t* gfortran.dg/abstract_type_1.f90: New test.\n\t* gfortran.dg/abstract_type_2.f03: New test.\n\t* gfortran.dg/abstract_type_3.f03: New test.\n\t* gfortran.dg/abstract_type_4.f03: New test.\n\nFrom-SVN: r139885", "tree": {"sha": "632874704a2f440f9696fa8dc31ad80c794354ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/632874704a2f440f9696fa8dc31ad80c794354ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52f4993488d2dd12d66dd99c2937e59319d0b1b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52f4993488d2dd12d66dd99c2937e59319d0b1b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52f4993488d2dd12d66dd99c2937e59319d0b1b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52f4993488d2dd12d66dd99c2937e59319d0b1b6/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "571191af2664d15b44e3a9795bc0cba9df44b8a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/571191af2664d15b44e3a9795bc0cba9df44b8a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/571191af2664d15b44e3a9795bc0cba9df44b8a6"}], "stats": {"total": 241, "additions": 234, "deletions": 7}, "files": [{"sha": "a878f0b7d1e69f11e4ecda7caa0ad6b33caf6b0b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=52f4993488d2dd12d66dd99c2937e59319d0b1b6", "patch": "@@ -1,3 +1,22 @@\n+2008-09-02  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfortran.h (struct gfc_namespace): New member `implicit_loc'.\n+\t(gfc_add_abstract): New method.\n+\t* decl.c (gfc_get_type_attr_spec): Match ABSTRACT attribute.\n+\t(gfc_match_derived_decl): Copy abstract attribute in derived symbol.\n+\t* dump-parse-tree.c (show_attr): Show ABSTRACT attribute as `ABSTRACT'\n+\tonly to allow for ABSTRACT types.\n+\t* parse.c (parse_interface): Use new gfc_add_abstract.\n+\t* primary.c (gfc_match_structure_constructor): Check that no ABSTRACT\n+\ttype is constructed.\n+\t* resolve.c (resolve_typespec_used): New method.\n+\t(resolve_fl_derived): Check type in respect to ABSTRACT attribute and\n+\tcheck that no component is of an ABSTRACT type.\n+\t(resolve_symbol): Check that no symbol is of an ABSTRACT type.\n+\t(resolve_types): Check IMPLICIT declarations for ABSTRACT types.\n+\t* symbol.c (gfc_merge_new_implicit): Remember loci of IMPLICIT's.\n+\t(gfc_add_abstract): New method.\n+\n 2008-09-01  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/37193"}, {"sha": "7e4cabf21ad5d85968555831f2baabdcd81807be", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=52f4993488d2dd12d66dd99c2937e59319d0b1b6", "patch": "@@ -6361,7 +6361,7 @@ gfc_get_type_attr_spec (symbol_attribute *attr, char *name)\n       if (gfc_add_access (attr, ACCESS_PUBLIC, NULL, NULL) == FAILURE)\n \treturn MATCH_ERROR;\n     }\n-  else if (gfc_match(\" , bind ( c )\") == MATCH_YES)\n+  else if (gfc_match (\" , bind ( c )\") == MATCH_YES)\n     {\n       /* If the type is defined to be bind(c) it then needs to make\n \t sure that all fields are interoperable.  This will\n@@ -6372,6 +6372,15 @@ gfc_get_type_attr_spec (symbol_attribute *attr, char *name)\n \n       /* TODO: attr conflicts need to be checked, probably in symbol.c.  */\n     }\n+  else if (gfc_match (\" , abstract\") == MATCH_YES)\n+    {\n+      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ABSTRACT type at %C\")\n+\t    == FAILURE)\n+\treturn MATCH_ERROR;\n+\n+      if (gfc_add_abstract (attr, &gfc_current_locus) == FAILURE)\n+\treturn MATCH_ERROR;\n+    }\n   else if (name && gfc_match(\" , extends ( %n )\", name) == MATCH_YES)\n     {\n       if (gfc_add_extension (attr, &gfc_current_locus) == FAILURE)\n@@ -6479,11 +6488,9 @@ gfc_match_derived_decl (void)\n   if (attr.is_bind_c != 0)\n     sym->attr.is_bind_c = attr.is_bind_c;\n \n-\n   /* Construct the f2k_derived namespace if it is not yet there.  */\n   if (!sym->f2k_derived)\n     sym->f2k_derived = gfc_get_namespace (NULL, 0);\n-\n   \n   if (extended && !sym->components)\n     {\n@@ -6507,6 +6514,9 @@ gfc_match_derived_decl (void)\n       st->n.sym = sym;\n     }\n \n+  /* Take over the ABSTRACT attribute.  */\n+  sym->attr.abstract = attr.abstract;\n+\n   gfc_new_block = sym;\n \n   return MATCH_YES;"}, {"sha": "32c97d06b73a0f011b6cc2a2e2220a5318b33e3e", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=52f4993488d2dd12d66dd99c2937e59319d0b1b6", "patch": "@@ -619,7 +619,7 @@ show_attr (symbol_attribute *attr)\n     fputs (\" IN-COMMON\", dumpfile);\n \n   if (attr->abstract)\n-    fputs (\" ABSTRACT INTERFACE\", dumpfile);\n+    fputs (\" ABSTRACT\", dumpfile);\n   if (attr->function)\n     fputs (\" FUNCTION\", dumpfile);\n   if (attr->subroutine)"}, {"sha": "444027baa443019edcdfa89f05ece482f0ef0f81", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=52f4993488d2dd12d66dd99c2937e59319d0b1b6", "patch": "@@ -1244,6 +1244,8 @@ typedef struct gfc_namespace\n   int set_flag[GFC_LETTERS];\n   /* Keeps track of the implicit types associated with the letters.  */\n   gfc_typespec default_type[GFC_LETTERS];\n+  /* Store the positions of IMPLICIT statements.  */\n+  locus implicit_loc[GFC_LETTERS];\n \n   /* If this is a namespace of a procedure, this points to the procedure.  */\n   struct gfc_symbol *proc_name;\n@@ -2260,6 +2262,7 @@ gfc_try gfc_add_function (symbol_attribute *, const char *, locus *);\n gfc_try gfc_add_subroutine (symbol_attribute *, const char *, locus *);\n gfc_try gfc_add_volatile (symbol_attribute *, const char *, locus *);\n gfc_try gfc_add_proc (symbol_attribute *attr, const char *name, locus *where);\n+gfc_try gfc_add_abstract (symbol_attribute* attr, locus* where);\n \n gfc_try gfc_add_access (symbol_attribute *, gfc_access, const char *, locus *);\n gfc_try gfc_add_is_bind_c (symbol_attribute *, const char *, locus *, int);"}, {"sha": "a96f77d84167af8adb7e5aff66b8b75b68f38af1", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=52f4993488d2dd12d66dd99c2937e59319d0b1b6", "patch": "@@ -2170,7 +2170,7 @@ parse_interface (void)\n \n   if (current_interface.type == INTERFACE_ABSTRACT)\n     {\n-      gfc_new_block->attr.abstract = 1;\n+      gfc_add_abstract (&gfc_new_block->attr, &gfc_current_locus);\n       if (gfc_is_intrinsic_typename (gfc_new_block->name))\n \tgfc_error (\"Name '%s' of ABSTRACT INTERFACE at %C \"\n \t\t   \"cannot be the same as an intrinsic type\","}, {"sha": "6689443200e5a3c18677421554c50add202321c8", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=52f4993488d2dd12d66dd99c2937e59319d0b1b6", "patch": "@@ -2125,7 +2125,8 @@ build_actual_constructor (gfc_structure_ctor_component **comp_head,\n }\n \n match\n-gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result, bool parent)\n+gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result,\n+\t\t\t\t bool parent)\n {\n   gfc_structure_ctor_component *comp_tail, *comp_head, *comp_iter;\n   gfc_constructor *ctor_head, *ctor_tail;\n@@ -2145,6 +2146,13 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result, bool parent\n \n   gfc_find_component (sym, NULL, false, true);\n \n+  /* Check that we're not about to construct an ABSTRACT type.  */\n+  if (!parent && sym->attr.abstract)\n+    {\n+      gfc_error (\"Can't construct ABSTRACT type '%s' at %C\", sym->name);\n+      return MATCH_ERROR;\n+    }\n+\n   /* Match the component list and store it in a list together with the\n      corresponding component names.  Check for empty argument list first.  */\n   if (gfc_match_char (')') != MATCH_YES)\n@@ -2243,6 +2251,7 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result, bool parent\n \t    {\n \t      gfc_current_locus = where;\n \t      gfc_free_expr (comp_tail->val);\n+\t      comp_tail->val = NULL;\n \n \t      m = gfc_match_structure_constructor (comp->ts.derived, \n \t\t\t\t\t\t   &comp_tail->val, true);"}, {"sha": "61053c3463cdb9107e8158050184a29120fbafc4", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=52f4993488d2dd12d66dd99c2937e59319d0b1b6", "patch": "@@ -82,6 +82,33 @@ gfc_is_formal_arg (void)\n   return formal_arg_flag;\n }\n \n+\n+/* Ensure a typespec used is valid; for instance, TYPE(t) is invalid if t is\n+   an ABSTRACT derived-type.  If where is not NULL, an error message with that\n+   locus is printed, optionally using name.  */\n+\n+static gfc_try\n+resolve_typespec_used (gfc_typespec* ts, locus* where, const char* name)\n+{\n+  if (ts->type == BT_DERIVED && ts->derived->attr.abstract)\n+    {\n+      if (where)\n+\t{\n+\t  if (name)\n+\t    gfc_error (\"'%s' at %L is of the ABSTRACT type '%s'\",\n+\t\t       name, where, ts->derived->name);\n+\t  else\n+\t    gfc_error (\"ABSTRACT type '%s' used at %L\",\n+\t\t       ts->derived->name, where);\n+\t}\n+\n+      return FAILURE;\n+    }\n+\n+  return SUCCESS;\n+}\n+\n+\n /* Resolve types of formal argument lists.  These have to be done early so that\n    the formal argument lists of module procedures can be copied to the\n    containing module before the individual procedures are resolved\n@@ -8420,8 +8447,21 @@ resolve_fl_derived (gfc_symbol *sym)\n   if (super_type && resolve_fl_derived (super_type) == FAILURE)\n     return FAILURE;\n \n+  /* An ABSTRACT type must be extensible.  */\n+  if (sym->attr.abstract && (sym->attr.is_bind_c || sym->attr.sequence))\n+    {\n+      gfc_error (\"Non-extensible derived-type '%s' at %L must not be ABSTRACT\",\n+\t\t sym->name, &sym->declared_at);\n+      return FAILURE;\n+    }\n+\n   for (c = sym->components; c != NULL; c = c->next)\n     {\n+      /* Check type-spec if this is not the parent-type component.  */\n+      if ((!sym->attr.extension || c != sym->components)\n+\t  && resolve_typespec_used (&c->ts, &c->loc, c->name) == FAILURE)\n+\treturn FAILURE;\n+\n       /* If this type is an extension, see if this component has the same name\n \t as an inherited type-bound procedure.  */\n       if (super_type\n@@ -9115,6 +9155,13 @@ resolve_symbol (gfc_symbol *sym)\n \t  || (a->dummy && a->intent == INTENT_OUT))\n \tapply_default_init (sym);\n     }\n+\n+  /* If this symbol has a type-spec, check it.  */\n+  if (sym->attr.flavor == FL_VARIABLE || sym->attr.flavor == FL_PARAMETER\n+      || (sym->attr.flavor == FL_PROCEDURE && sym->attr.function))\n+    if (resolve_typespec_used (&sym->ts, &sym->declared_at, sym->name)\n+\t  == FAILURE)\n+      return;\n }\n \n \n@@ -10070,6 +10117,18 @@ resolve_types (gfc_namespace *ns)\n \n   gfc_current_ns = ns;\n \n+  /* Check that all IMPLICIT types are ok.  */\n+  if (!ns->seen_implicit_none)\n+    {\n+      unsigned letter;\n+      for (letter = 0; letter != GFC_LETTERS; ++letter)\n+\tif (ns->set_flag[letter]\n+\t    && resolve_typespec_used (&ns->default_type[letter],\n+\t\t\t\t      &ns->implicit_loc[letter],\n+\t\t\t\t      NULL) == FAILURE)\n+\t  return;\n+    }\n+\n   resolve_entries (ns);\n \n   resolve_common_vars (ns->blank_common.head, false);"}, {"sha": "7c8b7bc7f38a65456f13534f2c756852ba91777a", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=52f4993488d2dd12d66dd99c2937e59319d0b1b6", "patch": "@@ -188,14 +188,15 @@ gfc_merge_new_implicit (gfc_typespec *ts)\n     {\n       if (new_flag[i])\n \t{\n-\n \t  if (gfc_current_ns->set_flag[i])\n \t    {\n \t      gfc_error (\"Letter %c already has an IMPLICIT type at %C\",\n \t\t\t i + 'A');\n \t      return FAILURE;\n \t    }\n+\n \t  gfc_current_ns->default_type[i] = *ts;\n+\t  gfc_current_ns->implicit_loc[i] = gfc_current_locus;\n \t  gfc_current_ns->set_flag[i] = 1;\n \t}\n     }\n@@ -1319,6 +1320,20 @@ gfc_add_proc (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n+gfc_try\n+gfc_add_abstract (symbol_attribute* attr, locus* where)\n+{\n+  if (attr->abstract)\n+    {\n+      duplicate_attr (\"ABSTRACT\", where);\n+      return FAILURE;\n+    }\n+\n+  attr->abstract = 1;\n+  return SUCCESS;\n+}\n+\n+\n /* Flavors are special because some flavors are not what Fortran\n    considers attributes and can be reaffirmed multiple times.  */\n "}, {"sha": "55577332b3eff7802a685c964a4c9eda63f65ff6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=52f4993488d2dd12d66dd99c2937e59319d0b1b6", "patch": "@@ -1,3 +1,10 @@\n+2008-09-02  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfortran.dg/abstract_type_1.f90: New test.\n+\t* gfortran.dg/abstract_type_2.f03: New test.\n+\t* gfortran.dg/abstract_type_3.f03: New test.\n+\t* gfortran.dg/abstract_type_4.f03: New test.\n+\n 2008-09-01  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* gcc.dg/20010516-1.c: Test for columns."}, {"sha": "b6baa3abab890338e387cc847262a88d9299e365", "filename": "gcc/testsuite/gfortran.dg/abstract_type_1.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_1.f90?ref=52f4993488d2dd12d66dd99c2937e59319d0b1b6", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do \"compile\" }\n+! { dg-options \"-std=f95\" }\n+\n+! Abstract Types.\n+! Check that ABSTRACT is rejected for F95.\n+\n+MODULE m\n+\n+  TYPE, ABSTRACT :: t ! { dg-error \"Fortran 2003\" }\n+    INTEGER :: x\n+  END TYPE t ! { dg-error \"END MODULE\" }\n+\n+END MODULE m"}, {"sha": "6dcfe1492ff5f587781fc23896691eb03a43993b", "filename": "gcc/testsuite/gfortran.dg/abstract_type_2.f03", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_2.f03?ref=52f4993488d2dd12d66dd99c2937e59319d0b1b6", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do \"compile\" }\n+\n+! Abstract Types.\n+! Check for parser errors.\n+\n+MODULE m\n+  IMPLICIT NONE\n+\n+  TYPE, ABSTRACT, EXTENDS(abst_t), ABSTRACT :: error_t ! { dg-error \"Duplicate ABSTRACT attribute\" }\n+    INTEGER :: y\n+  END TYPE error_t ! { dg-error \"END MODULE\" }\n+\n+END MODULE m"}, {"sha": "abeeec9dc6a3960dc34b8d44375c3225650d6cd4", "filename": "gcc/testsuite/gfortran.dg/abstract_type_3.f03", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_3.f03?ref=52f4993488d2dd12d66dd99c2937e59319d0b1b6", "patch": "@@ -0,0 +1,51 @@\n+! { dg-do \"compile\" }\n+\n+! Abstract Types.\n+! Check for errors when using abstract types in an inappropriate way.\n+\n+MODULE m\n+  USE ISO_C_BINDING\n+  IMPLICIT NONE\n+\n+  TYPE, ABSTRACT, BIND(C) :: bindc_t ! { dg-error \"must not be ABSTRACT\" }\n+    INTEGER(C_INT) :: x\n+  END TYPE bindc_t\n+\n+  TYPE, ABSTRACT :: sequence_t ! { dg-error \"must not be ABSTRACT\" }\n+    SEQUENCE\n+    INTEGER :: x\n+  END TYPE sequence_t\n+\n+  TYPE, ABSTRACT :: abst_t\n+    INTEGER :: x = 0\n+  END TYPE abst_t\n+\n+  TYPE, EXTENDS(abst_t) :: concrete_t\n+    INTEGER :: y = 1\n+  END TYPE concrete_t\n+\n+  TYPE :: myt\n+    TYPE(abst_t) :: comp ! { dg-error \"is of the ABSTRACT type 'abst_t'\" }\n+  END TYPE myt\n+\n+  ! This should be ok.\n+  TYPE, ABSTRACT, EXTENDS(concrete_t) :: again_abst_t\n+    INTEGER :: z = 2\n+  END TYPE again_abst_t\n+\n+CONTAINS\n+\n+  TYPE(abst_t) FUNCTION func () ! { dg-error \"of the ABSTRACT type 'abst_t'\" }\n+  END FUNCTION func\n+\n+  SUBROUTINE sub (arg) ! { dg-error \"is of the ABSTRACT type 'again_abst_t'\" }\n+    IMPLICIT NONE\n+    TYPE(again_abst_t) :: arg\n+    arg = again_abst_t () ! { dg-error \"Can't construct ABSTRACT type 'again_abst_t'\" }\n+  END SUBROUTINE sub\n+\n+  SUBROUTINE impl ()\n+    IMPLICIT TYPE(abst_t) (a-z) ! { dg-error \"ABSTRACT type 'abst_t' used\" }\n+  END SUBROUTINE impl\n+\n+END MODULE m"}, {"sha": "89fd3b0327202b911452bd384ef5dafe035ff899", "filename": "gcc/testsuite/gfortran.dg/abstract_type_4.f03", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52f4993488d2dd12d66dd99c2937e59319d0b1b6/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_4.f03?ref=52f4993488d2dd12d66dd99c2937e59319d0b1b6", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do \"compile\" }\n+\n+! Abstract Types.\n+! Check for module file IO.\n+\n+MODULE m\n+  IMPLICIT NONE\n+\n+  TYPE, ABSTRACT :: abst_t\n+    INTEGER :: x\n+  END TYPE abst_t\n+\n+  TYPE, EXTENDS(abst_t) :: concrete_t\n+    INTEGER :: y\n+  END TYPE concrete_t\n+\n+END MODULE m\n+\n+PROGRAM main\n+  USE m\n+  IMPLICIT NONE\n+\n+  TYPE(abst_t) :: abst ! { dg-error \"is of the ABSTRACT type 'abst_t'\" }\n+  TYPE(concrete_t) :: conc\n+\n+  ! See if constructing the extending type works.\n+  conc = concrete_t (1, 2)\n+END PROGRAM main"}]}