{"sha": "d3a26d5d27e7104a62b1c2e0fd64f917b9328826", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNhMjZkNWQyN2U3MTA0YTYyYjFjMmUwZmQ2NGY5MTdiOTMyODgyNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-03-09T14:57:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-03-09T14:57:35Z"}, "message": "[multiple changes]\n\n2012-03-09  Robert Dewar  <dewar@adacore.com>\n\n\t* a-direct.adb, comperr.adb, freeze.adb: Minor reformatting.\n\n2012-03-09  Arnaud Charlet  <charlet@adacore.com>\n\n\t* s-taskin.adb (Initialize_ATCB): Set Task_Image_Len to\n\t0 so that we never access this field uninitialized (e.g. in\n\tTask_Primitives.Operations.Enter_Task for the environment task).\n\n2012-03-09  Vincent Pucci  <pucci@adacore.com>\n\n\t* exp_ch5.adb (Expand_Iterator_Loop):\n\tCall to Expand_Iterator_Loop_Over_Array added.\n\t(Expand_Iterator_Loop_Over_Array): New routine. Expansion of\n\t\"of\" iterator loop over arrays. Multidimensional array case added.\n\n2012-03-09  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* uintp.ads: Fix minor pasto in comment.\n\nFrom-SVN: r185143", "tree": {"sha": "8914039e76aef96b7d2a7de89a090a0284b1001e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8914039e76aef96b7d2a7de89a090a0284b1001e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3a26d5d27e7104a62b1c2e0fd64f917b9328826", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3a26d5d27e7104a62b1c2e0fd64f917b9328826", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3a26d5d27e7104a62b1c2e0fd64f917b9328826", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3a26d5d27e7104a62b1c2e0fd64f917b9328826/comments", "author": null, "committer": null, "parents": [{"sha": "f91510fca5547ad6e73ea9153ba1bac2fefcd915", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f91510fca5547ad6e73ea9153ba1bac2fefcd915", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f91510fca5547ad6e73ea9153ba1bac2fefcd915"}], "stats": {"total": 711, "additions": 399, "deletions": 312}, "files": [{"sha": "61dc3bef1996fe22f185589866188212cbeb2897", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a26d5d27e7104a62b1c2e0fd64f917b9328826/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a26d5d27e7104a62b1c2e0fd64f917b9328826/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d3a26d5d27e7104a62b1c2e0fd64f917b9328826", "patch": "@@ -1,3 +1,24 @@\n+2012-03-09  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-direct.adb, comperr.adb, freeze.adb: Minor reformatting.\n+\n+2012-03-09  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* s-taskin.adb (Initialize_ATCB): Set Task_Image_Len to\n+\t0 so that we never access this field uninitialized (e.g. in\n+\tTask_Primitives.Operations.Enter_Task for the environment task).\n+\n+2012-03-09  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* exp_ch5.adb (Expand_Iterator_Loop):\n+\tCall to Expand_Iterator_Loop_Over_Array added.\n+\t(Expand_Iterator_Loop_Over_Array): New routine. Expansion of\n+\t\"of\" iterator loop over arrays. Multidimensional array case added.\n+\n+2012-03-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* uintp.ads: Fix minor pasto in comment.\n+\n 2012-03-09  Vasiliy Fofanov  <fofanov@adacore.com>\n \n \t* a-direct.adb: Do not strip the trailing directory separator"}, {"sha": "903440b11f2c1decf1273f81b766ddd0cae540aa", "filename": "gcc/ada/a-direct.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a26d5d27e7104a62b1c2e0fd64f917b9328826/gcc%2Fada%2Fa-direct.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a26d5d27e7104a62b1c2e0fd64f917b9328826/gcc%2Fada%2Fa-direct.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-direct.adb?ref=d3a26d5d27e7104a62b1c2e0fd64f917b9328826", "patch": "@@ -514,10 +514,10 @@ package body Ada.Directories is\n    begin\n       Local_Get_Current_Dir (Buffer'Address, Path_Len'Address);\n \n-      --  We need to resolve links because of A.16(47), since we must not\n-      --  return alternative names for files\n-      return Normalize_Pathname (Buffer (1 .. Path_Len));\n+      --  We need to resolve links because of RM A.16(47), which requires\n+      --  that we not return alternative names for files.\n \n+      return Normalize_Pathname (Buffer (1 .. Path_Len));\n    end Current_Directory;\n \n    ----------------------"}, {"sha": "ac620e6227cd0d93f228a56a24944bebf7425e59", "filename": "gcc/ada/comperr.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a26d5d27e7104a62b1c2e0fd64f917b9328826/gcc%2Fada%2Fcomperr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a26d5d27e7104a62b1c2e0fd64f917b9328826/gcc%2Fada%2Fcomperr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcomperr.adb?ref=d3a26d5d27e7104a62b1c2e0fd64f917b9328826", "patch": "@@ -502,8 +502,9 @@ package body Comperr is\n          when N_Package_Renaming_Declaration =>\n             Unit_Name := Defining_Unit_Name (Main);\n \n+         --  No SCIL file generated for generic package declarations\n+\n          when N_Generic_Package_Declaration =>\n-            --  No SCIL file generated for generic package declarations\n             return;\n \n          --  Should never happen, but can be ignored in production"}, {"sha": "6d8e0537d39bf1befac7280f5015385a87d29602", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 368, "deletions": 302, "changes": 670, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a26d5d27e7104a62b1c2e0fd64f917b9328826/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a26d5d27e7104a62b1c2e0fd64f917b9328826/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=d3a26d5d27e7104a62b1c2e0fd64f917b9328826", "patch": "@@ -107,6 +107,9 @@ package body Exp_Ch5 is\n    --  Expand loop over arrays and containers that uses the form \"for X of C\"\n    --  with an optional subtype mark, or \"for Y in C\".\n \n+   procedure Expand_Iterator_Loop_Over_Array (N : Node_Id);\n+   --  Expand loop over arrays that uses the form \"for X of C\"\n+\n    procedure Expand_Predicated_Loop (N : Node_Id);\n    --  Expand for loop over predicated subtype\n \n@@ -2946,369 +2949,432 @@ package body Exp_Ch5 is\n       --  Processing for arrays\n \n       if Is_Array_Type (Container_Typ) then\n+         Expand_Iterator_Loop_Over_Array (N);\n+         return;\n+      end if;\n \n-         --  for Element of Array loop\n-         --\n-         --  This case requires an internally generated cursor to iterate over\n-         --  the array.\n+      --  Processing for containers\n \n-         if Of_Present (I_Spec) then\n-            Iterator := Make_Temporary (Loc, 'C');\n+      --  For an \"of\" iterator the name is a container expression, which\n+      --  is transformed into a call to the default iterator.\n \n-            --  Generate:\n-            --    Element : Component_Type renames Container (Iterator);\n+      --  For an iterator of the form \"in\" the name is a function call\n+      --  that delivers an iterator type.\n \n-            Prepend_To (Stats,\n-              Make_Object_Renaming_Declaration (Loc,\n-                Defining_Identifier => Id,\n-                Subtype_Mark =>\n-                  New_Reference_To (Component_Type (Container_Typ), Loc),\n-                Name =>\n-                  Make_Indexed_Component (Loc,\n-                    Prefix => Relocate_Node (Container),\n-                    Expressions => New_List (\n-                      New_Reference_To (Iterator, Loc)))));\n+      --  In both cases, analysis of the iterator has introduced an object\n+      --  declaration to capture the domain, so that Container is an entity.\n \n-         --  for Index in Array loop\n+      --  The for loop is expanded into a while loop which uses a container\n+      --  specific cursor to desgnate each element.\n \n-         --  This case utilizes the already given iterator name\n+      --    Iter : Iterator_Type := Container.Iterate;\n+      --    Cursor : Cursor_type := First (Iter);\n+      --    while Has_Element (Iter) loop\n+      --       declare\n+      --       --  The block is added when Element_Type is controlled\n \n+      --          Obj : Pack.Element_Type := Element (Cursor);\n+      --          --  for the \"of\" loop form\n+      --       begin\n+      --          <original loop statements>\n+      --       end;\n+\n+      --       Cursor := Iter.Next (Cursor);\n+      --    end loop;\n+\n+      --  If \"reverse\" is present, then the initialization of the cursor\n+      --  uses Last and the step becomes Prev. Pack is the name of the\n+      --  scope where the container package is instantiated.\n+\n+      declare\n+         Element_Type : constant Entity_Id := Etype (Id);\n+         Iter_Type    : Entity_Id;\n+         Pack         : Entity_Id;\n+         Decl         : Node_Id;\n+         Name_Init    : Name_Id;\n+         Name_Step    : Name_Id;\n+\n+      begin\n+         --  The type of the iterator is the return type of the Iterate\n+         --  function used. For the \"of\" form this is the default iterator\n+         --  for the type, otherwise it is the type of the explicit\n+         --  function used in the iterator specification. The most common\n+         --  case will be an Iterate function in the container package.\n+\n+         --  The primitive operations of the container type may not be\n+         --  use-visible, so we introduce the name of the enclosing package\n+         --  in the declarations below. The Iterator type is declared in a\n+         --  an instance within the container package itself.\n+\n+         --  If the container type is a derived type, the cursor type is\n+         --  found in the package of the parent type.\n+\n+         if Is_Derived_Type (Container_Typ) then\n+            Pack := Scope (Root_Type (Container_Typ));\n          else\n-            Iterator := Id;\n+            Pack := Scope (Container_Typ);\n          end if;\n \n-         --  Generate:\n-         --    for Iterator in [reverse] Container'Range loop\n-         --       Element : Component_Type renames Container (Iterator);\n-         --       --  for the \"of\" form\n+         Iter_Type := Etype (Name (I_Spec));\n \n-         --       <original loop statements>\n-         --    end loop;\n+         --  The \"of\" case uses an internally generated cursor whose type\n+         --  is found in the container package. The domain of iteration\n+         --  is expanded into a call to the default Iterator function, but\n+         --  this expansion does not take place in quantified expressions\n+         --  that are analyzed with expansion disabled, and in that case the\n+         --  type of the iterator must be obtained from the aspect.\n \n-         New_Loop :=\n-           Make_Loop_Statement (Loc,\n-             Iteration_Scheme =>\n-               Make_Iteration_Scheme (Loc,\n-                 Loop_Parameter_Specification =>\n-                   Make_Loop_Parameter_Specification (Loc,\n-                     Defining_Identifier => Iterator,\n-                       Discrete_Subtype_Definition =>\n-                         Make_Attribute_Reference (Loc,\n-                           Prefix => Relocate_Node (Container),\n-                           Attribute_Name => Name_Range),\n-                      Reverse_Present => Reverse_Present (I_Spec))),\n-              Statements => Stats,\n-              End_Label  => Empty);\n+         if Of_Present (I_Spec) then\n+            declare\n+               Default_Iter : constant Entity_Id :=\n+                                Entity\n+                                  (Find_Aspect\n+                                    (Etype (Container),\n+                                     Aspect_Default_Iterator));\n \n-      --  Processing for containers\n+               Container_Arg : Node_Id;\n+               Ent           : Entity_Id;\n \n-      else\n-         --  For an \"of\" iterator the name is a container expression, which\n-         --  is transformed into a call to the default iterator.\n+            begin\n+               Cursor := Make_Temporary (Loc, 'I');\n \n-         --  For an iterator of the form \"in\" the name is a function call\n-         --  that delivers an iterator type.\n+               --  For an container element iterator, the iterator type\n+               --  is obtained from the corresponding aspect.\n \n-         --  In both cases, analysis of the iterator has introduced an object\n-         --  declaration to capture the domain, so that Container is an entity.\n+               Iter_Type := Etype (Default_Iter);\n+               Pack := Scope (Iter_Type);\n \n-         --  The for loop is expanded into a while loop which uses a container\n-         --  specific cursor to desgnate each element.\n+               --  Rewrite domain of iteration as a call to the default\n+               --  iterator for the container type. If the container is\n+               --  a derived type and the aspect is inherited, convert\n+               --  container to parent type. The Cursor type is also\n+               --  inherited from the scope of the parent.\n \n-         --    Iter : Iterator_Type := Container.Iterate;\n-         --    Cursor : Cursor_type := First (Iter);\n-         --    while Has_Element (Iter) loop\n-         --       declare\n-         --       --  The block is added when Element_Type is controlled\n+               if Base_Type (Etype (Container)) =\n+                  Base_Type (Etype (First_Formal (Default_Iter)))\n+               then\n+                  Container_Arg := New_Copy_Tree (Container);\n \n-         --          Obj : Pack.Element_Type := Element (Cursor);\n-         --          --  for the \"of\" loop form\n-         --       begin\n-         --          <original loop statements>\n-         --       end;\n+               else\n+                  Container_Arg :=\n+                    Make_Type_Conversion (Loc,\n+                      Subtype_Mark =>\n+                        New_Occurrence_Of\n+                          (Etype (First_Formal (Default_Iter)), Loc),\n+                      Expression => New_Copy_Tree (Container));\n+               end if;\n \n-         --       Cursor := Iter.Next (Cursor);\n-         --    end loop;\n+               Rewrite (Name (I_Spec),\n+                 Make_Function_Call (Loc,\n+                   Name => New_Occurrence_Of (Default_Iter, Loc),\n+                   Parameter_Associations =>\n+                     New_List (Container_Arg)));\n+               Analyze_And_Resolve (Name (I_Spec));\n+\n+               --  Find cursor type in proper iterator package, which is an\n+               --  instantiation of Iterator_Interfaces.\n+\n+               Ent := First_Entity (Pack);\n+               while Present (Ent) loop\n+                  if Chars (Ent) = Name_Cursor then\n+                     Set_Etype (Cursor, Etype (Ent));\n+                     exit;\n+                  end if;\n+                  Next_Entity (Ent);\n+               end loop;\n \n-         --  If \"reverse\" is present, then the initialization of the cursor\n-         --  uses Last and the step becomes Prev. Pack is the name of the\n-         --  scope where the container package is instantiated.\n+               --  Generate:\n+               --    Id : Element_Type renames Container (Cursor);\n+               --  This assumes that the container type has an indexing\n+               --  operation with Cursor. The check that this operation\n+               --  exists is performed in Check_Container_Indexing.\n+\n+               Decl :=\n+                 Make_Object_Renaming_Declaration (Loc,\n+                   Defining_Identifier => Id,\n+                   Subtype_Mark     =>\n+                     New_Reference_To (Element_Type, Loc),\n+                   Name             =>\n+                     Make_Indexed_Component (Loc,\n+                       Prefix      => Relocate_Node (Container_Arg),\n+                       Expressions =>\n+                         New_List (New_Occurrence_Of (Cursor, Loc))));\n+\n+               --  If the container holds controlled objects, wrap the loop\n+               --  statements and element renaming declaration with a block.\n+               --  This ensures that the result of Element (Cusor) is\n+               --  cleaned up after each iteration of the loop.\n+\n+               if Needs_Finalization (Element_Type) then\n+\n+                  --  Generate:\n+                  --    declare\n+                  --       Id : Element_Type := Element (curosr);\n+                  --    begin\n+                  --       <original loop statements>\n+                  --    end;\n+\n+                  Stats := New_List (\n+                    Make_Block_Statement (Loc,\n+                      Declarations               => New_List (Decl),\n+                      Handled_Statement_Sequence =>\n+                        Make_Handled_Sequence_Of_Statements (Loc,\n+                           Statements => Stats)));\n+\n+               --  Elements do not need finalization\n+\n+               else\n+                  Prepend_To (Stats, Decl);\n+               end if;\n+            end;\n+\n+         --  X in Iterate (S) : type of iterator is type of explicitly\n+         --  given Iterate function, and the loop variable is the cursor.\n+         --  It will be assigned in the loop and must be a variable.\n+\n+         else\n+            Cursor := Id;\n+            Set_Ekind (Cursor, E_Variable);\n+         end if;\n+\n+         Iterator := Make_Temporary (Loc, 'I');\n+\n+         --  Determine the advancement and initialization steps for the\n+         --  cursor.\n+\n+         --  Analysis of the expanded loop will verify that the container\n+         --  has a reverse iterator.\n+\n+         if Reverse_Present (I_Spec) then\n+            Name_Init := Name_Last;\n+            Name_Step := Name_Previous;\n+\n+         else\n+            Name_Init := Name_First;\n+            Name_Step := Name_Next;\n+         end if;\n+\n+         --  For both iterator forms, add a call to the step operation to\n+         --  advance the cursor. Generate:\n+\n+         --     Cursor := Iterator.Next (Cursor);\n+\n+         --   or else\n+\n+         --     Cursor := Next (Cursor);\n \n          declare\n-            Element_Type : constant Entity_Id := Etype (Id);\n-            Iter_Type    : Entity_Id;\n-            Pack         : Entity_Id;\n-            Decl         : Node_Id;\n-            Name_Init    : Name_Id;\n-            Name_Step    : Name_Id;\n+            Rhs : Node_Id;\n \n          begin\n-            --  The type of the iterator is the return type of the Iterate\n-            --  function used. For the \"of\" form this is the default iterator\n-            --  for the type, otherwise it is the type of the explicit\n-            --  function used in the iterator specification. The most common\n-            --  case will be an Iterate function in the container package.\n-\n-            --  The primitive operations of the container type may not be\n-            --  use-visible, so we introduce the name of the enclosing package\n-            --  in the declarations below. The Iterator type is declared in a\n-            --  an instance within the container package itself.\n-\n-            --  If the container type is a derived type, the cursor type is\n-            --  found in the package of the parent type.\n-\n-            if Is_Derived_Type (Container_Typ) then\n-               Pack := Scope (Root_Type (Container_Typ));\n-            else\n-               Pack := Scope (Container_Typ);\n-            end if;\n+            Rhs :=\n+              Make_Function_Call (Loc,\n+                Name                   =>\n+                  Make_Selected_Component (Loc,\n+                    Prefix        => New_Reference_To (Iterator, Loc),\n+                    Selector_Name => Make_Identifier (Loc, Name_Step)),\n+                Parameter_Associations => New_List (\n+                   New_Reference_To (Cursor, Loc)));\n \n-            Iter_Type := Etype (Name (I_Spec));\n+            Append_To (Stats,\n+              Make_Assignment_Statement (Loc,\n+                 Name       => New_Occurrence_Of (Cursor, Loc),\n+                 Expression => Rhs));\n+         end;\n \n-            --  The \"of\" case uses an internally generated cursor whose type\n-            --  is found in the container package. The domain of iteration\n-            --  is expanded into a call to the default Iterator function, but\n-            --  this expansion does not take place in quantified expressions\n-            --  that are analyzed with expansion disabled, and in that case the\n-            --  type of the iterator must be obtained from the aspect.\n+         --  Generate:\n+         --    while Iterator.Has_Element loop\n+         --       <Stats>\n+         --    end loop;\n \n-            if Of_Present (I_Spec) then\n-               declare\n-                  Default_Iter : constant Entity_Id :=\n-                                   Entity\n-                                     (Find_Aspect\n-                                       (Etype (Container),\n-                                        Aspect_Default_Iterator));\n+         --   Has_Element is the second actual in the iterator package\n \n-                  Container_Arg : Node_Id;\n-                  Ent           : Entity_Id;\n+         New_Loop :=\n+           Make_Loop_Statement (Loc,\n+             Iteration_Scheme =>\n+               Make_Iteration_Scheme (Loc,\n+                 Condition =>\n+                   Make_Function_Call (Loc,\n+                     Name                   =>\n+                       New_Occurrence_Of (\n+                        Next_Entity (First_Entity (Pack)), Loc),\n+                     Parameter_Associations =>\n+                       New_List (New_Reference_To (Cursor, Loc)))),\n+\n+             Statements => Stats,\n+             End_Label  => Empty);\n+\n+         --  Create the declarations for Iterator and cursor and insert them\n+         --  before the source loop. Given that the domain of iteration is\n+         --  already an entity, the iterator is just a renaming of that\n+         --  entity. Possible optimization ???\n+         --  Generate:\n \n-               begin\n-                  Cursor := Make_Temporary (Loc, 'I');\n+         --    I : Iterator_Type renames Container;\n+         --    C : Cursor_Type := Container.[First | Last];\n \n-                  --  For an container element iterator, the iterator type\n-                  --  is obtained from the corresponding aspect.\n+         Insert_Action (N,\n+           Make_Object_Renaming_Declaration (Loc,\n+             Defining_Identifier => Iterator,\n+             Subtype_Mark  => New_Occurrence_Of (Iter_Type, Loc),\n+             Name          => Relocate_Node (Name (I_Spec))));\n \n-                  Iter_Type := Etype (Default_Iter);\n-                  Pack := Scope (Iter_Type);\n+         --  Create declaration for cursor\n \n-                  --  Rewrite domain of iteration as a call to the default\n-                  --  iterator for the container type. If the container is\n-                  --  a derived type and the aspect is inherited, convert\n-                  --  container to parent type. The Cursor type is also\n-                  --  inherited from the scope of the parent.\n+         declare\n+            Decl : Node_Id;\n \n-                  if Base_Type (Etype (Container)) =\n-                     Base_Type (Etype (First_Formal (Default_Iter)))\n-                  then\n-                     Container_Arg := New_Copy_Tree (Container);\n+         begin\n+            Decl :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Cursor,\n+                Object_Definition   =>\n+                  New_Occurrence_Of (Etype (Cursor), Loc),\n+                Expression          =>\n+                  Make_Selected_Component (Loc,\n+                    Prefix        => New_Reference_To (Iterator, Loc),\n+                    Selector_Name =>\n+                      Make_Identifier (Loc, Name_Init)));\n \n-                  else\n-                     Container_Arg :=\n-                       Make_Type_Conversion (Loc,\n-                         Subtype_Mark =>\n-                           New_Occurrence_Of\n-                             (Etype (First_Formal (Default_Iter)), Loc),\n-                         Expression => New_Copy_Tree (Container));\n-                  end if;\n+            --  The cursor is only modified in expanded code, so it appears\n+            --  as unassigned to the warning machinery. We must suppress\n+            --  this spurious warning explicitly.\n \n-                  Rewrite (Name (I_Spec),\n-                    Make_Function_Call (Loc,\n-                      Name => New_Occurrence_Of (Default_Iter, Loc),\n-                      Parameter_Associations =>\n-                        New_List (Container_Arg)));\n-                  Analyze_And_Resolve (Name (I_Spec));\n-\n-                  --  Find cursor type in proper iterator package, which is an\n-                  --  instantiation of Iterator_Interfaces.\n-\n-                  Ent := First_Entity (Pack);\n-                  while Present (Ent) loop\n-                     if Chars (Ent) = Name_Cursor then\n-                        Set_Etype (Cursor, Etype (Ent));\n-                        exit;\n-                     end if;\n-                     Next_Entity (Ent);\n-                  end loop;\n+            Set_Warnings_Off (Cursor);\n+            Set_Assignment_OK (Decl);\n \n-                  --  Generate:\n-                  --    Id : Element_Type renames Container (Cursor);\n-                  --  This assumes that the container type has an indexing\n-                  --  operation with Cursor. The check that this operation\n-                  --  exists is performed in Check_Container_Indexing.\n-\n-                  Decl :=\n-                    Make_Object_Renaming_Declaration (Loc,\n-                      Defining_Identifier => Id,\n-                      Subtype_Mark     =>\n-                        New_Reference_To (Element_Type, Loc),\n-                      Name             =>\n-                        Make_Indexed_Component (Loc,\n-                          Prefix      => Relocate_Node (Container_Arg),\n-                          Expressions =>\n-                            New_List (New_Occurrence_Of (Cursor, Loc))));\n-\n-                  --  If the container holds controlled objects, wrap the loop\n-                  --  statements and element renaming declaration with a block.\n-                  --  This ensures that the result of Element (Cusor) is\n-                  --  cleaned up after each iteration of the loop.\n-\n-                  if Needs_Finalization (Element_Type) then\n-\n-                     --  Generate:\n-                     --    declare\n-                     --       Id : Element_Type := Element (curosr);\n-                     --    begin\n-                     --       <original loop statements>\n-                     --    end;\n-\n-                     Stats := New_List (\n-                       Make_Block_Statement (Loc,\n-                         Declarations               => New_List (Decl),\n-                         Handled_Statement_Sequence =>\n-                           Make_Handled_Sequence_Of_Statements (Loc,\n-                              Statements => Stats)));\n-\n-                  --  Elements do not need finalization\n+            Insert_Action (N, Decl);\n+         end;\n \n-                  else\n-                     Prepend_To (Stats, Decl);\n-                  end if;\n-               end;\n+         --  If the range of iteration is given by a function call that\n+         --  returns a container, the finalization actions have been saved\n+         --  in the Condition_Actions of the iterator. Insert them now at\n+         --  the head of the loop.\n \n-            --  X in Iterate (S) : type of iterator is type of explicitly\n-            --  given Iterate function, and the loop variable is the cursor.\n-            --  It will be assigned in the loop and must be a variable.\n+         if Present (Condition_Actions (Isc)) then\n+            Insert_List_Before (N, Condition_Actions (Isc));\n+         end if;\n+      end;\n \n-            else\n-               Cursor := Id;\n-               Set_Ekind (Cursor, E_Variable);\n-            end if;\n+      Rewrite (N, New_Loop);\n+      Analyze (N);\n+   end Expand_Iterator_Loop;\n \n-            Iterator := Make_Temporary (Loc, 'I');\n+   -------------------------------------\n+   -- Expand_Iterator_Loop_Over_Array --\n+   -------------------------------------\n+\n+   procedure Expand_Iterator_Loop_Over_Array (N : Node_Id) is\n+      Isc        : constant Node_Id    := Iteration_Scheme (N);\n+      I_Spec     : constant Node_Id    := Iterator_Specification (Isc);\n+      Array_Node : constant Node_Id    := Name (I_Spec);\n+      Array_Typ  : constant Entity_Id  := Base_Type (Etype (Array_Node));\n+      Array_Dim  : constant Pos        := Number_Dimensions (Array_Typ);\n+      Id         : constant Entity_Id  := Defining_Identifier (I_Spec);\n+      Loc        : constant Source_Ptr := Sloc (N);\n+      Stats      : constant List_Id    := Statements (N);\n+      Core_Loop  : Node_Id;\n+      Ind_Comp   : Node_Id;\n+      Iterator   : Entity_Id;\n+\n+   --  Start of processing for Expand_Iterator_Loop_Over_Array\n \n-            --  Determine the advancement and initialization steps for the\n-            --  cursor.\n+   begin\n+      --  for Element of Array loop\n \n-            --  Analysis of the expanded loop will verify that the container\n-            --  has a reverse iterator.\n+      --  This case requires an internally generated cursor to iterate over\n+      --  the array.\n \n-            if Reverse_Present (I_Spec) then\n-               Name_Init := Name_Last;\n-               Name_Step := Name_Previous;\n+      if Of_Present (I_Spec) then\n+         Iterator := Make_Temporary (Loc, 'C');\n \n-            else\n-               Name_Init := Name_First;\n-               Name_Step := Name_Next;\n-            end if;\n+         --  Generate:\n+         --    Element : Component_Type renames Array (Iterator);\n \n-            --  For both iterator forms, add a call to the step operation to\n-            --  advance the cursor. Generate:\n+         Ind_Comp :=\n+           Make_Indexed_Component (Loc,\n+             Prefix      => Relocate_Node (Array_Node),\n+             Expressions => New_List (New_Reference_To (Iterator, Loc)));\n \n-            --     Cursor := Iterator.Next (Cursor);\n+         Prepend_To (Stats,\n+           Make_Object_Renaming_Declaration (Loc,\n+             Defining_Identifier => Id,\n+             Subtype_Mark        =>\n+               New_Reference_To (Component_Type (Array_Typ), Loc),\n+             Name                => Ind_Comp));\n \n-            --   or else\n+      --  for Index in Array loop\n \n-            --     Cursor := Next (Cursor);\n+      --  This case utilizes the already given iterator name\n \n-            declare\n-               Rhs : Node_Id;\n+      else\n+         Iterator := Id;\n+      end if;\n \n-            begin\n-               Rhs :=\n-                 Make_Function_Call (Loc,\n-                   Name                   =>\n-                     Make_Selected_Component (Loc,\n-                       Prefix        => New_Reference_To (Iterator, Loc),\n-                       Selector_Name => Make_Identifier (Loc, Name_Step)),\n-                   Parameter_Associations => New_List (\n-                      New_Reference_To (Cursor, Loc)));\n+      --  Generate:\n \n-               Append_To (Stats,\n-                 Make_Assignment_Statement (Loc,\n-                    Name       => New_Occurrence_Of (Cursor, Loc),\n-                    Expression => Rhs));\n-            end;\n+      --    for Iterator in [reverse] Array'Range (Array_Dim) loop\n+      --       Element : Component_Type renames Array (Iterator);\n+      --       <original loop statements>\n+      --    end loop;\n \n-            --  Generate:\n-            --    while Iterator.Has_Element loop\n-            --       <Stats>\n-            --    end loop;\n+      Core_Loop :=\n+        Make_Loop_Statement (Loc,\n+          Iteration_Scheme =>\n+            Make_Iteration_Scheme (Loc,\n+              Loop_Parameter_Specification =>\n+                Make_Loop_Parameter_Specification (Loc,\n+                  Defining_Identifier         => Iterator,\n+                  Discrete_Subtype_Definition =>\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix         => Relocate_Node (Array_Node),\n+                      Attribute_Name => Name_Range,\n+                      Expressions    => New_List (\n+                        Make_Integer_Literal (Loc, Array_Dim))),\n+                  Reverse_Present             => Reverse_Present (I_Spec))),\n+           Statements      => Stats,\n+           End_Label       => Empty);\n+\n+      --  Processing for multidimensional array\n+\n+      if Array_Dim > 1 then\n+         for Dim in 1 .. Array_Dim - 1 loop\n+            Iterator := Make_Temporary (Loc, 'C');\n \n-            --   Has_Element is the second actual in the iterator package\n+            --  Generate the dimension loops starting from the innermost one\n \n-            New_Loop :=\n+            --    for Iterator in [reverse] Array'Range (Array_Dim - Dim) loop\n+            --       <core loop>\n+            --    end loop;\n+\n+            Core_Loop :=\n               Make_Loop_Statement (Loc,\n                 Iteration_Scheme =>\n                   Make_Iteration_Scheme (Loc,\n-                    Condition =>\n-                      Make_Function_Call (Loc,\n-                        Name                   =>\n-                          New_Occurrence_Of (\n-                           Next_Entity (First_Entity (Pack)), Loc),\n-                        Parameter_Associations =>\n-                          New_List (\n-                            New_Reference_To (Cursor, Loc)))),\n-\n-                Statements => Stats,\n-                End_Label  => Empty);\n-\n-            --  Create the declarations for Iterator and cursor and insert them\n-            --  before the source loop. Given that the domain of iteration is\n-            --  already an entity, the iterator is just a renaming of that\n-            --  entity. Possible optimization ???\n-            --  Generate:\n-\n-            --    I : Iterator_Type renames Container;\n-            --    C : Cursor_Type := Container.[First | Last];\n-\n-            Insert_Action (N,\n-              Make_Object_Renaming_Declaration (Loc,\n-                Defining_Identifier => Iterator,\n-                Subtype_Mark  => New_Occurrence_Of (Iter_Type, Loc),\n-                Name          => Relocate_Node (Name (I_Spec))));\n-\n-            --  Create declaration for cursor\n-\n-            declare\n-               Decl : Node_Id;\n-\n-            begin\n-               Decl :=\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Cursor,\n-                   Object_Definition   =>\n-                     New_Occurrence_Of (Etype (Cursor), Loc),\n-                   Expression          =>\n-                     Make_Selected_Component (Loc,\n-                       Prefix        => New_Reference_To (Iterator, Loc),\n-                       Selector_Name =>\n-                         Make_Identifier (Loc, Name_Init)));\n-\n-               --  The cursor is only modified in expanded code, so it appears\n-               --  as unassigned to the warning machinery. We must suppress\n-               --  this spurious warning explicitly.\n-\n-               Set_Warnings_Off (Cursor);\n-               Set_Assignment_OK (Decl);\n-\n-               Insert_Action (N, Decl);\n-            end;\n-\n-            --  If the range of iteration is given by a function call that\n-            --  returns a container, the finalization actions have been saved\n-            --  in the Condition_Actions of the iterator. Insert them now at\n-            --  the head of the loop.\n-\n-            if Present (Condition_Actions (Isc)) then\n-               Insert_List_Before (N, Condition_Actions (Isc));\n-            end if;\n-         end;\n+                    Loop_Parameter_Specification =>\n+                      Make_Loop_Parameter_Specification (Loc,\n+                        Defining_Identifier         => Iterator,\n+                        Discrete_Subtype_Definition =>\n+                          Make_Attribute_Reference (Loc,\n+                            Prefix         => Relocate_Node (Array_Node),\n+                            Attribute_Name => Name_Range,\n+                            Expressions    => New_List (\n+                              Make_Integer_Literal (Loc, Array_Dim - Dim))),\n+                    Reverse_Present              => Reverse_Present (I_Spec))),\n+                Statements       => New_List (Core_Loop),\n+                End_Label        => Empty);\n+\n+            --  Update the previously created object renaming declaration with\n+            --  the new iterator.\n+\n+            Prepend_To (Expressions (Ind_Comp),\n+              New_Reference_To (Iterator, Loc));\n+         end loop;\n       end if;\n \n-      Rewrite (N, New_Loop);\n+      Rewrite (N, Core_Loop);\n       Analyze (N);\n-   end Expand_Iterator_Loop;\n+   end Expand_Iterator_Loop_Over_Array;\n \n    -----------------------------\n    -- Expand_N_Loop_Statement --"}, {"sha": "fc7600070f7bb93186b0d52f99764cdd12fe8363", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a26d5d27e7104a62b1c2e0fd64f917b9328826/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a26d5d27e7104a62b1c2e0fd64f917b9328826/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=d3a26d5d27e7104a62b1c2e0fd64f917b9328826", "patch": "@@ -2136,8 +2136,7 @@ package body Freeze is\n                   (Rec, Attribute_Scalar_Storage_Order);\n \n          if Present (ADC)\n-              and then\n-            Reverse_Bit_Order (Rec) /= Reverse_Storage_Order (Rec)\n+           and then Reverse_Bit_Order (Rec) /= Reverse_Storage_Order (Rec)\n          then\n             if Bytes_Big_Endian = not Reverse_Storage_Order (Rec) then\n                Error_Msg_N\n@@ -2147,7 +2146,6 @@ package body Freeze is\n                Error_Msg_N\n                  (\"Scalar_Storage_Order Low_Order_First is inconsistent with\"\n                   & \" Bit_Order\", ADC);\n-\n             end if;\n          end if;\n "}, {"sha": "519626cb9c44d62f0e31e8708b4a81d1ad0f338b", "filename": "gcc/ada/s-taskin.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a26d5d27e7104a62b1c2e0fd64f917b9328826/gcc%2Fada%2Fs-taskin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a26d5d27e7104a62b1c2e0fd64f917b9328826/gcc%2Fada%2Fs-taskin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.adb?ref=d3a26d5d27e7104a62b1c2e0fd64f917b9328826", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -137,6 +137,7 @@ package body System.Tasking is\n       T.Common.Fall_Back_Handler        := null;\n       T.Common.Specific_Handler         := null;\n       T.Common.Debug_Events             := (others => False);\n+      T.Common.Task_Image_Len           := 0;\n \n       if T.Common.Parent = null then\n "}, {"sha": "41c6ff57050f28ec6535fbda8793c1721471b039", "filename": "gcc/ada/uintp.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a26d5d27e7104a62b1c2e0fd64f917b9328826/gcc%2Fada%2Fuintp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a26d5d27e7104a62b1c2e0fd64f917b9328826/gcc%2Fada%2Fuintp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.ads?ref=d3a26d5d27e7104a62b1c2e0fd64f917b9328826", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,7 +32,7 @@\n --  Support for universal integer arithmetic\n \n --  WARNING: There is a C version of this package. Any changes to this\n---  source file must be properly reflected in the C header file sinfo.h\n+--  source file must be properly reflected in the C header file uintp.h\n \n with Alloc;\n with Table;"}]}