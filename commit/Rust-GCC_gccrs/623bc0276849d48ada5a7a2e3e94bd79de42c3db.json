{"sha": "623bc0276849d48ada5a7a2e3e94bd79de42c3db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjIzYmMwMjc2ODQ5ZDQ4YWRhNWE3YTJlM2U5NGJkNzlkZTQyYzNkYg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-08-17T20:35:10Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-08-19T01:21:35Z"}, "message": "analyzer: consider initializers for globals [PR96651]\n\nPR analyzer/96651 reports a false positive in which a global\nthat can't have been touched yet is checked in \"main\".  The analyzer\nfails to reject code paths in which the initial value of the global\nmakes the path condition impossible.\n\nThis patch detects cases where the code path begins at the entrypoint\nof \"main\", and extracts values from initializers for globals that\ncan't have been touched yet, rather than using a symbolic\n\"INIT_VAL(REG)\", fixing the false positive.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/96651\n\t* region-model.cc (region_model::called_from_main_p): New.\n\t(region_model::get_store_value): Move handling for globals into...\n\t(region_model::get_initial_value_for_global): ...this new\n\tfunction, and add logic for extracting values from decl\n\tinitializers.\n\t* region-model.h (decl_region::get_svalue_for_constructor): New\n\tdecl.\n\t(decl_region::get_svalue_for_initializer): New decl.\n\t(region_model::called_from_main_p): New decl.\n\t(region_model::get_initial_value_for_global): New.\n\t* region.cc (decl_region::maybe_get_constant_value): Move logic\n\tfor getting an svalue from a CONSTRUCTOR node to...\n\t(decl_region::get_svalue_for_constructor): ...this new function.\n\t(decl_region::get_svalue_for_initializer): New.\n\t* store.cc (get_svalue_for_ctor_val): Rewrite in terms of\n\tregion_model::get_rvalue.\n\t* store.h (binding_cluster::get_map): New accessor.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/96651\n\t* gcc.dg/analyzer/pr96651-1.c: New test.\n\t* gcc.dg/analyzer/pr96651-2.c: New test.", "tree": {"sha": "9443ad633d75cbd19c7b95565d3b2a26f3419a4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9443ad633d75cbd19c7b95565d3b2a26f3419a4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/623bc0276849d48ada5a7a2e3e94bd79de42c3db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/623bc0276849d48ada5a7a2e3e94bd79de42c3db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/623bc0276849d48ada5a7a2e3e94bd79de42c3db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/623bc0276849d48ada5a7a2e3e94bd79de42c3db/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "400abebf48a90d0797718ab7c3864de331e85b70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/400abebf48a90d0797718ab7c3864de331e85b70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/400abebf48a90d0797718ab7c3864de331e85b70"}], "stats": {"total": 253, "additions": 224, "deletions": 29}, "files": [{"sha": "5b08e48e6e55581fb8c2809be53d35289924900f", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 74, "deletions": 8, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623bc0276849d48ada5a7a2e3e94bd79de42c3db/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623bc0276849d48ada5a7a2e3e94bd79de42c3db/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=623bc0276849d48ada5a7a2e3e94bd79de42c3db", "patch": "@@ -1204,6 +1204,76 @@ region_model::get_rvalue (tree expr, region_model_context *ctxt)\n   return get_rvalue (path_var (expr, get_stack_depth () - 1), ctxt);\n }\n \n+/* Return true if this model is on a path with \"main\" as the entrypoint\n+   (as opposed to one in which we're merely analyzing a subset of the\n+   path through the code).  */\n+\n+bool\n+region_model::called_from_main_p () const\n+{\n+  if (!m_current_frame)\n+    return false;\n+  /* Determine if the oldest stack frame in this model is for \"main\".  */\n+  const frame_region *frame0 = get_frame_at_index (0);\n+  gcc_assert (frame0);\n+  return id_equal (DECL_NAME (frame0->get_function ()->decl), \"main\");\n+}\n+\n+/* Subroutine of region_model::get_store_value for when REG is (or is within)\n+   a global variable that hasn't been touched since the start of this path\n+   (or was implicitly touched due to a call to an unknown function).  */\n+\n+const svalue *\n+region_model::get_initial_value_for_global (const region *reg) const\n+{\n+  /* Get the decl that REG is for (or is within).  */\n+  const decl_region *base_reg\n+    = reg->get_base_region ()->dyn_cast_decl_region ();\n+  gcc_assert (base_reg);\n+  tree decl = base_reg->get_decl ();\n+\n+  /* Special-case: to avoid having to explicitly update all previously\n+     untracked globals when calling an unknown fn, they implicitly have\n+     an unknown value if an unknown call has occurred, unless this is\n+     static to-this-TU and hasn't escaped.  Globals that have escaped\n+     are explicitly tracked, so we shouldn't hit this case for them.  */\n+  if (m_store.called_unknown_fn_p () && TREE_PUBLIC (decl))\n+    return m_mgr->get_or_create_unknown_svalue (reg->get_type ());\n+\n+  /* If we are on a path from the entrypoint from \"main\" and we have a\n+     global decl defined in this TU that hasn't been touched yet, then\n+     the initial value of REG can be taken from the initialization value\n+     of the decl.  */\n+  if (called_from_main_p () && !DECL_EXTERNAL (decl))\n+    {\n+      /* Get the initializer value for base_reg.  */\n+      const svalue *base_reg_init\n+\t= base_reg->get_svalue_for_initializer (m_mgr);\n+      gcc_assert (base_reg_init);\n+      if (reg == base_reg)\n+\treturn base_reg_init;\n+      else\n+\t{\n+\t  /* Get the value for REG within base_reg_init.  */\n+\t  binding_cluster c (base_reg);\n+\t  c.bind (m_mgr->get_store_manager (), base_reg, base_reg_init,\n+\t\t  BK_direct);\n+\t  const svalue *sval\n+\t    = c.get_any_binding (m_mgr->get_store_manager (), reg);\n+\t  if (sval)\n+\t    {\n+\t      if (reg->get_type ())\n+\t\tsval = m_mgr->get_or_create_cast (reg->get_type (),\n+\t\t\t\t\t\t  sval);\n+\t      return sval;\n+\t    }\n+\t}\n+    }\n+\n+  /* Otherwise, return INIT_VAL(REG).  */\n+  return m_mgr->get_or_create_initial_value (reg);\n+}\n+\n /* Get a value for REG, looking it up in the store, or otherwise falling\n    back to \"initial\" or \"unknown\" values.  */\n \n@@ -1256,14 +1326,10 @@ region_model::get_store_value (const region *reg) const\n      would have returned UNKNOWN, and we would already have returned\n      that above).  */\n \n-  /* Special-case: to avoid having to explicitly update all previously\n-     untracked globals when calling an unknown fn, we instead change\n-     the default here so we implicitly have an unknown value for such\n-     regions.  */\n-  if (m_store.called_unknown_fn_p ())\n-    if (reg->get_base_region ()->get_parent_region ()->get_kind ()\n-\t== RK_GLOBALS)\n-      return m_mgr->get_or_create_unknown_svalue (reg->get_type ());\n+  /* Handle globals.  */\n+  if (reg->get_base_region ()->get_parent_region ()->get_kind ()\n+      == RK_GLOBALS)\n+    return get_initial_value_for_global (reg);\n \n   return m_mgr->get_or_create_initial_value (reg);\n }"}, {"sha": "79d739e3a7b66ec801d175b666015ec0faee7a8c", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623bc0276849d48ada5a7a2e3e94bd79de42c3db/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623bc0276849d48ada5a7a2e3e94bd79de42c3db/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=623bc0276849d48ada5a7a2e3e94bd79de42c3db", "patch": "@@ -1870,6 +1870,9 @@ class decl_region : public region\n   int get_stack_depth () const;\n \n   const svalue *maybe_get_constant_value (region_model_manager *mgr) const;\n+  const svalue *get_svalue_for_constructor (tree ctor,\n+\t\t\t\t\t    region_model_manager *mgr) const;\n+  const svalue *get_svalue_for_initializer (region_model_manager *mgr) const;\n \n private:\n   tree m_decl;\n@@ -2701,6 +2704,9 @@ class region_model\n   void record_dynamic_extents (const region *reg,\n \t\t\t       const svalue *size_in_bytes);\n \n+  bool called_from_main_p () const;\n+  const svalue *get_initial_value_for_global (const region *reg) const;\n+\n   /* Storing this here to avoid passing it around everywhere.  */\n   region_model_manager *const m_mgr;\n "}, {"sha": "c3dc8cdfa844bdb014519deb25911373b360922a", "filename": "gcc/analyzer/region.cc", "status": "modified", "additions": 45, "deletions": 12, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623bc0276849d48ada5a7a2e3e94bd79de42c3db/gcc%2Fanalyzer%2Fregion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623bc0276849d48ada5a7a2e3e94bd79de42c3db/gcc%2Fanalyzer%2Fregion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.cc?ref=623bc0276849d48ada5a7a2e3e94bd79de42c3db", "patch": "@@ -886,20 +886,53 @@ decl_region::maybe_get_constant_value (region_model_manager *mgr) const\n       && DECL_IN_CONSTANT_POOL (m_decl)\n       && DECL_INITIAL (m_decl)\n       && TREE_CODE (DECL_INITIAL (m_decl)) == CONSTRUCTOR)\n-    {\n-      tree ctor = DECL_INITIAL (m_decl);\n-      gcc_assert (!TREE_CLOBBER_P (ctor));\n+    return get_svalue_for_constructor (DECL_INITIAL (m_decl), mgr);\n+  return NULL;\n+}\n \n-      /* Create a binding map, applying ctor to it, using this\n-\t decl_region as the base region when building child regions\n-\t for offset calculations.  */\n-      binding_map map;\n-      map.apply_ctor_to_region (this, ctor, mgr);\n+/* Get an svalue for CTOR, a CONSTRUCTOR for this region's decl.  */\n \n-      /* Return a compound svalue for the map we built.  */\n-      return mgr->get_or_create_compound_svalue (get_type (), map);\n-    }\n-  return NULL;\n+const svalue *\n+decl_region::get_svalue_for_constructor (tree ctor,\n+\t\t\t\t\t region_model_manager *mgr) const\n+{\n+  gcc_assert (!TREE_CLOBBER_P (ctor));\n+\n+  /* Create a binding map, applying ctor to it, using this\n+     decl_region as the base region when building child regions\n+     for offset calculations.  */\n+  binding_map map;\n+  map.apply_ctor_to_region (this, ctor, mgr);\n+\n+  /* Return a compound svalue for the map we built.  */\n+  return mgr->get_or_create_compound_svalue (get_type (), map);\n+}\n+\n+/* For use on decl_regions for global variables.\n+\n+   Get an svalue for the initial value of this region at entry to\n+   \"main\" (either based on DECL_INITIAL, or implicit initialization to\n+   zero.  */\n+\n+const svalue *\n+decl_region::get_svalue_for_initializer (region_model_manager *mgr) const\n+{\n+  tree init = DECL_INITIAL (m_decl);\n+  if (!init)\n+    {\n+      /* Implicit initialization to zero; use a compound_svalue for it.  */\n+      binding_cluster c (this);\n+      c.zero_fill_region (mgr->get_store_manager (), this);\n+      return mgr->get_or_create_compound_svalue (TREE_TYPE (m_decl),\n+\t\t\t\t\t\t c.get_map ());\n+     }\n+\n+  if (TREE_CODE (init) == CONSTRUCTOR)\n+    return get_svalue_for_constructor (init, mgr);\n+\n+  /* Reuse the get_rvalue logic from region_model.  */\n+  region_model m (mgr);\n+  return m.get_rvalue (path_var (init, 0), NULL);\n }\n \n /* class field_region : public region.  */"}, {"sha": "d854f4e504ab4e5b1ed3a3baecefe153a152e964", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623bc0276849d48ada5a7a2e3e94bd79de42c3db/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623bc0276849d48ada5a7a2e3e94bd79de42c3db/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=623bc0276849d48ada5a7a2e3e94bd79de42c3db", "patch": "@@ -396,15 +396,9 @@ get_subregion_within_ctor (const region *parent_reg, tree index,\n static const svalue *\n get_svalue_for_ctor_val (tree val, region_model_manager *mgr)\n {\n-  if (TREE_CODE (val) == ADDR_EXPR)\n-    {\n-      gcc_assert (TREE_CODE (TREE_OPERAND (val, 0)) == STRING_CST);\n-      const string_region *str_reg\n-\t= mgr->get_region_for_string (TREE_OPERAND (val, 0));\n-      return mgr->get_ptr_svalue (TREE_TYPE (val), str_reg);\n-    }\n-  gcc_assert (CONSTANT_CLASS_P (val));\n-  return mgr->get_or_create_constant_svalue (val);\n+  /* Reuse the get_rvalue logic from region_model.  */\n+  region_model m (mgr);\n+  return m.get_rvalue (path_var (val, 0), NULL);\n }\n \n /* Bind values from CONSTRUCTOR to this map, relative to"}, {"sha": "bc9dc2e0b5c78c39b47ac6d5bc81f11000bd4fcc", "filename": "gcc/analyzer/store.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623bc0276849d48ada5a7a2e3e94bd79de42c3db/gcc%2Fanalyzer%2Fstore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623bc0276849d48ada5a7a2e3e94bd79de42c3db/gcc%2Fanalyzer%2Fstore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.h?ref=623bc0276849d48ada5a7a2e3e94bd79de42c3db", "patch": "@@ -451,6 +451,8 @@ class binding_cluster\n   iterator_t begin () const { return m_map.begin (); }\n   iterator_t end () const { return m_map.end (); }\n \n+  const binding_map &get_map () const { return m_map; }\n+\n private:\n   const svalue *get_any_value (const binding_key *key) const;\n   void get_overlapping_bindings (store_manager *mgr, const region *reg,"}, {"sha": "2f3a9b44a2c33189c1c0650ddb1e13401a0bc51c", "filename": "gcc/testsuite/gcc.dg/analyzer/pr96651-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623bc0276849d48ada5a7a2e3e94bd79de42c3db/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr96651-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623bc0276849d48ada5a7a2e3e94bd79de42c3db/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr96651-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr96651-1.c?ref=623bc0276849d48ada5a7a2e3e94bd79de42c3db", "patch": "@@ -0,0 +1,22 @@\n+#include <stdlib.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+static int a;\n+\n+int main(void)\n+{\n+  char *src = NULL;\n+  char buf[128];\n+\n+  /* \"a\" can't have been touched yet, and thus\n+     is implicitly zero.  */\n+  switch (a) {\n+  case 1:\n+    strcpy(buf, src); /* { dg-bogus \"NULL\" } */\n+    break;\n+  case 0:\n+    strcpy(buf, \"hello\");\n+  }\n+  printf(\"%s\\n\", buf);\n+}"}, {"sha": "249a32b8ed9e90fc73a626f77928f23d6da70455", "filename": "gcc/testsuite/gcc.dg/analyzer/pr96651-2.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623bc0276849d48ada5a7a2e3e94bd79de42c3db/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr96651-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623bc0276849d48ada5a7a2e3e94bd79de42c3db/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr96651-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr96651-2.c?ref=623bc0276849d48ada5a7a2e3e94bd79de42c3db", "patch": "@@ -0,0 +1,72 @@\n+#include \"analyzer-decls.h\"\n+\n+extern void unknown_fn (void *, void *);\n+\n+static int a;\n+static int b = 42;\n+int c;\n+int d = 17;\n+struct { int x; int y; char rgb[3]; } s = {5, 10, {0x80, 0x40, 0x20}};\n+void *e = &d;\n+\n+extern struct _IO_FILE *stderr;\n+\n+/* If we're not on a direct path from \"main\", we know nothing about\n+   the values of globals.  */\n+\n+void test (void)\n+{\n+  __analyzer_eval (a == 0); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (b == 42); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (c == 0); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (d == 17); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (s.rgb[2] == 0x20); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (e == &d); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (stderr == 0); /* { dg-warning \"UNKNOWN\" } */\n+}\n+\n+static void __attribute__((noinline))\n+called_from_main (void)\n+{\n+  /* When accessed from main, the vars still have their initializer values.  */\n+  __analyzer_eval (a == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (b == 42); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (c == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (d == 17); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (s.rgb[2] == 0x20); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (e == &d); /* { dg-warning \"TRUE\" } */\n+  /* ...apart from those defined in a different TU (or that were inited\n+     before \"main\").  */\n+  __analyzer_eval (stderr == 0); /* { dg-warning \"UNKNOWN\" } */\n+}\n+\n+int main (void)\n+{\n+  /* When accessed from main, the vars still have their initializer values.  */\n+  __analyzer_eval (a == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (b == 42); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (c == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (d == 17); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (s.rgb[2] == 0x20); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (e == &d); /* { dg-warning \"TRUE\" } */\n+  /* ...apart from those defined in a different TU (or that were inited\n+     before \"main\").  */\n+  __analyzer_eval (stderr == 0); /* { dg-warning \"UNKNOWN\" } */\n+\n+  called_from_main ();\n+\n+  unknown_fn (&a, &c);\n+\n+  /* \"a\" escaped above and so could have been written to.  */\n+  __analyzer_eval (a == 0); /* { dg-warning \"UNKNOWN\" } */\n+  /* \"b\" doesn't escape and is static, and so must still have its\n+     initial value.  */\n+  __analyzer_eval (b == 42); /* { dg-warning \"TRUE\" } */\n+  /* The other globals are non-static and so have implicitly escaped,\n+     and so could have been written to.  */\n+  __analyzer_eval (c == 0); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (d == 17); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (s.rgb[2] == 0x20); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (e == &d); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (stderr == 0); /* { dg-warning \"UNKNOWN\" } */\n+}"}]}