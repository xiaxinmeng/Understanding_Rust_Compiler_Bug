{"sha": "5a4dbf7d315730cf6c94a67a42e8cc3a41047ff5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE0ZGJmN2QzMTU3MzBjZjZjOTRhNjdhNDJlOGNjM2E0MTA0N2ZmNQ==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2017-05-01T22:51:04Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gcc.gnu.org", "date": "2017-05-01T22:51:04Z"}, "message": "d-demangle.c (dlang_parse_symbol): Remove function.\n\nlibiberty/ChangeLog:\n\n\t* d-demangle.c (dlang_parse_symbol): Remove function.\n\t(dlang_parse_qualified): New function.\n\t(dlang_parse_mangle): New function.\n\t(dlang_type): Update to call dlang_parse_qualified.\n\t(dlang_identifier): Update to call either dlang_parse_qualified or\n\tdlang_parse_mangle.\n\t(dlang_type_modifier_p): Remove function.\n\t(dlang_call_convention_p): Don't allow type modifiers in mangle.\n\t(dlang_template_args): Update to call dlang_identifier.\n\t(dlang_demangle): Update to call dlang_parse_mangle.\n\t* testsuite/d-demangle-expected: Add tests.\n\nFrom-SVN: r247450", "tree": {"sha": "9c2a0d993a3e00604f0d3eb86032f51422a07a6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c2a0d993a3e00604f0d3eb86032f51422a07a6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a4dbf7d315730cf6c94a67a42e8cc3a41047ff5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a4dbf7d315730cf6c94a67a42e8cc3a41047ff5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a4dbf7d315730cf6c94a67a42e8cc3a41047ff5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a4dbf7d315730cf6c94a67a42e8cc3a41047ff5/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5166bee456c653c4eded6f496d66b748ed6ec82f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5166bee456c653c4eded6f496d66b748ed6ec82f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5166bee456c653c4eded6f496d66b748ed6ec82f"}], "stats": {"total": 240, "additions": 142, "deletions": 98}, "files": [{"sha": "fa2104dc866effb5d055517c2598ef3987c6f7f7", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a4dbf7d315730cf6c94a67a42e8cc3a41047ff5/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a4dbf7d315730cf6c94a67a42e8cc3a41047ff5/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=5a4dbf7d315730cf6c94a67a42e8cc3a41047ff5", "patch": "@@ -1,3 +1,17 @@\n+2017-05-02  Iain Buclaw  <ibuclaw@gdcproject.org>\n+\n+\t* d-demangle.c (dlang_parse_symbol): Remove function.\n+\t(dlang_parse_qualified): New function.\n+\t(dlang_parse_mangle): New function.\n+\t(dlang_type): Update to call dlang_parse_qualified.\n+\t(dlang_identifier): Update to call either dlang_parse_qualified or\n+\tdlang_parse_mangle.\n+\t(dlang_type_modifier_p): Remove function.\n+\t(dlang_call_convention_p): Don't allow type modifiers in mangle.\n+\t(dlang_template_args): Update to call dlang_identifier.\n+\t(dlang_demangle): Update to call dlang_parse_mangle.\n+\t* testsuite/d-demangle-expected: Add tests.\n+\n 2017-05-01  Iain Buclaw  <ibuclaw@gdcproject.org>\n \n \t* d-demangle.c (dlang_value): Add comment explaining why cases for"}, {"sha": "f62cc63878c92a54369a67eacf3282ece1e4200a", "filename": "libiberty/d-demangle.c", "status": "modified", "additions": 116, "deletions": 98, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a4dbf7d315730cf6c94a67a42e8cc3a41047ff5/libiberty%2Fd-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a4dbf7d315730cf6c94a67a42e8cc3a41047ff5/libiberty%2Fd-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fd-demangle.c?ref=5a4dbf7d315730cf6c94a67a42e8cc3a41047ff5", "patch": "@@ -186,7 +186,10 @@ static const char *dlang_type (string *, const char *);\n \n static const char *dlang_value (string *, const char *, const char *, char);\n \n-static const char *dlang_parse_symbol (string *, const char *,\n+static const char *dlang_parse_qualified (string *, const char *,\n+\t\t\t\t\t  enum dlang_symbol_kinds);\n+\n+static const char *dlang_parse_mangle (string *, const char *,\n \t\t\t\t       enum dlang_symbol_kinds);\n \n static const char *dlang_parse_tuple (string *, const char *);\n@@ -561,7 +564,7 @@ dlang_type (string *decl, const char *mangled)\n     case 'E': /* enum T */\n     case 'T': /* typedef T */\n       mangled++;\n-      return dlang_parse_symbol (decl, mangled, dlang_type_name);\n+      return dlang_parse_qualified (decl, mangled, dlang_type_name);\n     case 'D': /* delegate T */\n     {\n       string mods;\n@@ -743,12 +746,10 @@ dlang_identifier (string *decl, const char *mangled,\n \t  /* Check whether template parameter is a function with a valid\n \t     return type or an untyped identifier.  */\n \t  if (ISDIGIT (*mangled))\n-\t    mangled = dlang_parse_symbol (decl, mangled, dlang_template_ident);\n+\t    mangled = dlang_parse_qualified (decl, mangled,\n+\t\t\t\t\t     dlang_template_ident);\n \t  else if (strncmp (mangled, \"_D\", 2) == 0)\n-\t    {\n-\t      mangled += 2;\n-\t      mangled = dlang_parse_symbol (decl, mangled, dlang_function);\n-\t    }\n+\t    mangled = dlang_parse_mangle (decl, mangled, dlang_function);\n \n \t  /* Check for name length mismatch.  */\n \t  if (mangled && (mangled - pend) == psize)\n@@ -1299,49 +1300,11 @@ dlang_value (string *decl, const char *mangled, const char *name, char type)\n   return mangled;\n }\n \n-/* Extract the type modifiers from MANGLED and return the string\n-   length that it consumes in MANGLED on success or 0 on failure.  */\n-static int\n-dlang_type_modifier_p (const char *mangled)\n-{\n-  int i;\n-\n-  switch (*mangled)\n-    {\n-    case 'x': case 'y':\n-      return 1;\n-\n-    case 'O':\n-      mangled++;\n-      i = dlang_type_modifier_p (mangled);\n-      return i + 1;\n-\n-    case 'N':\n-      mangled++;\n-      if (*mangled == 'g')\n-\t{\n-\t  mangled++;\n-\t  i = dlang_type_modifier_p (mangled);\n-\t  return i + 2;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n /* Extract the function calling convention from MANGLED and\n    return 1 on success or 0 on failure.  */\n static int\n dlang_call_convention_p (const char *mangled)\n {\n-  /* Prefix for functions needing 'this' */\n-  if (*mangled == 'M')\n-    {\n-      mangled++;\n-      /* Also skip over any type modifiers.  */\n-      mangled += dlang_type_modifier_p (mangled);\n-    }\n-\n   switch (*mangled)\n     {\n     case 'F': case 'U': case 'V':\n@@ -1356,10 +1319,94 @@ dlang_call_convention_p (const char *mangled)\n /* Extract and demangle the symbol in MANGLED and append it to DECL.\n    Returns the remaining signature on success or NULL on failure.  */\n static const char *\n-dlang_parse_symbol (string *decl, const char *mangled,\n+dlang_parse_mangle (string *decl, const char *mangled,\n \t\t    enum dlang_symbol_kinds kind)\n {\n-  int saved;\n+  /* A D mangled symbol is comprised of both scope and type information.\n+\n+\tMangleName:\n+\t    _D QualifiedName Type\n+\t    _D QualifiedName M Type\n+\t    _D QualifiedName Z\n+\t    ^\n+     The caller should have guaranteed that the start pointer is at the\n+     above location.\n+   */\n+  mangled += 2;\n+\n+  mangled = dlang_parse_qualified (decl, mangled, dlang_top_level);\n+\n+  if (mangled != NULL)\n+    {\n+      /* Artificial symbols end with 'Z' and have no type.  */\n+      if (*mangled == 'Z')\n+\tmangled++;\n+      else\n+\t{\n+\t  string mods;\n+\t  int saved;\n+\n+\t  /* Skip over 'this' parameter.  */\n+\t  if (*mangled == 'M')\n+\t    mangled++;\n+\n+\t  /* Save the type modifiers for appending at the end if needed.  */\n+\t  string_init (&mods);\n+\t  mangled = dlang_type_modifiers (&mods, mangled);\n+\n+\t  if (mangled && dlang_call_convention_p (mangled))\n+\t    {\n+\t      /* Skip over calling convention and attributes.  */\n+\t      saved = string_length (decl);\n+\t      mangled = dlang_call_convention (decl, mangled);\n+\t      mangled = dlang_attributes (decl, mangled);\n+\t      string_setlength (decl, saved);\n+\n+\t      string_append (decl, \"(\");\n+\t      mangled = dlang_function_args (decl, mangled);\n+\t      string_append (decl, \")\");\n+\n+\t      /* Add any const/immutable/shared modifier. */\n+\t      string_appendn (decl, mods.b, string_length (&mods));\n+\t    }\n+\n+\t  /* Consume the decl type of symbol.  */\n+\t  saved = string_length (decl);\n+\t  mangled = dlang_type (decl, mangled);\n+\t  string_setlength (decl, saved);\n+\n+\t  string_delete (&mods);\n+\t}\n+    }\n+\n+  /* Check that the entire symbol was successfully demangled.  */\n+  if (kind == dlang_top_level)\n+    {\n+      if (mangled == NULL || *mangled != '\\0')\n+\treturn NULL;\n+    }\n+\n+  return mangled;\n+}\n+\n+/* Extract and demangle the qualified symbol in MANGLED and append it to DECL.\n+   Returns the remaining signature on success or NULL on failure.  */\n+static const char *\n+dlang_parse_qualified (string *decl, const char *mangled,\n+\t\t       enum dlang_symbol_kinds kind)\n+{\n+  /* Qualified names are identifiers separated by their encoded length.\n+     Nested functions also encode their argument types without specifying\n+     what they return.\n+\n+\tQualifiedName:\n+\t    SymbolName\n+\t    SymbolName QualifiedName\n+\t    SymbolName TypeFunctionNoReturn QualifiedName\n+\t    SymbolName M TypeModifiers TypeFunctionNoReturn QualifiedName\n+\t    ^\n+     The start pointer should be at the above location.\n+   */\n   size_t n = 0;\n   do\n     {\n@@ -1372,32 +1419,30 @@ dlang_parse_symbol (string *decl, const char *mangled,\n \n       mangled = dlang_identifier (decl, mangled, kind);\n \n-      if (mangled && dlang_call_convention_p (mangled))\n+      /* Consume the encoded arguments.  However if this is not followed by the\n+\t next encoded length, then this is not a continuation of a qualified\n+\t name, in which case we backtrack and return the current unconsumed\n+\t position of the mangled decl.  */\n+      if (mangled && (*mangled == 'M' || dlang_call_convention_p (mangled)))\n \t{\n-\t  string mods;\n-\t  const char *start = NULL;\n-\t  int checkpoint = 0;\n+\t  const char *start = mangled;\n+\t  int saved = string_length (decl);\n \n-\t  /* Skip over 'this' parameter.  */\n+\t  /* Skip over 'this' parameter and type modifiers.  */\n \t  if (*mangled == 'M')\n-\t    mangled++;\n-\n-\t  /* We have reached here because we expect an extern(Pascal) function.\n-\t     However this is so rare, that it is more likely a template value\n-\t     parameter.  Since this can't be assumed, first attempt parsing\n-\t     the symbol as a function, and then back out on failure.  */\n-\t  if (*mangled == 'V')\n \t    {\n-\t      start = mangled;\n-\t      checkpoint = string_length (decl);\n+\t      mangled++;\n+\t      mangled = dlang_type_modifiers (decl, mangled);\n+\t      string_setlength (decl, saved);\n \t    }\n \n-\t  /* Save the type modifiers for appending at the end.  */\n-\t  string_init (&mods);\n-\t  mangled = dlang_type_modifiers (&mods, mangled);\n+\t  /* The rule we expect to match in the mangled string is:\n \n-\t  /* Skip over calling convention and attributes in qualified name.  */\n-\t  saved = string_length (decl);\n+\t\tTypeFunctionNoReturn:\n+\t\t    CallConvention FuncAttrs Arguments ArgClose\n+\n+\t     The calling convention and function attributes are not included\n+\t     in the demangled string.  */\n \t  mangled = dlang_call_convention (decl, mangled);\n \t  mangled = dlang_attributes (decl, mangled);\n \t  string_setlength (decl, saved);\n@@ -1406,41 +1451,16 @@ dlang_parse_symbol (string *decl, const char *mangled,\n \t  mangled = dlang_function_args (decl, mangled);\n \t  string_append (decl, \")\");\n \n-\t  /* Add any const/immutable/shared modifier. */\n-\t  string_appendn (decl, mods.b, string_length (&mods));\n-\t  string_delete (&mods);\n-\n-\t  if (mangled == NULL && checkpoint != 0)\n+\t  if (mangled == NULL || !ISDIGIT (*mangled))\n \t    {\n+\t      /* Did not match the rule we were looking for.  */\n \t      mangled = start;\n-\t      string_setlength (decl, checkpoint);\n+\t      string_setlength (decl, saved);\n \t    }\n \t}\n     }\n   while (mangled && ISDIGIT (*mangled));\n \n-  /* Only top-level symbols or function template parameters have\n-     a type that needs checking.  */\n-  if (kind == dlang_top_level || kind == dlang_function)\n-    {\n-      /* Artificial symbols end with 'Z' and have no type.  */\n-      if (mangled && *mangled == 'Z')\n-\tmangled++;\n-      else\n-\t{\n-\t  saved = string_length (decl);\n-\t  mangled = dlang_type (decl, mangled);\n-\t  string_setlength (decl, saved);\n-\t}\n-\n-      /* Check that the entire symbol was successfully demangled.  */\n-      if (kind == dlang_top_level)\n-\t{\n-\t  if (mangled == NULL || *mangled != '\\0')\n-\t    return NULL;\n-\t}\n-    }\n-\n   return mangled;\n }\n \n@@ -1496,7 +1516,7 @@ dlang_template_args (string *decl, const char *mangled)\n \t{\n \tcase 'S': /* Symbol parameter.  */\n \t  mangled++;\n-\t  mangled = dlang_parse_symbol (decl, mangled, dlang_template_param);\n+\t  mangled = dlang_identifier (decl, mangled, dlang_template_param);\n \t  break;\n \tcase 'T': /* Type parameter.  */\n \t  mangled++;\n@@ -1594,9 +1614,7 @@ dlang_demangle (const char *mangled, int option ATTRIBUTE_UNUSED)\n     }\n   else\n     {\n-      mangled += 2;\n-\n-      if (dlang_parse_symbol (&decl, mangled, dlang_top_level) == NULL)\n+      if (dlang_parse_mangle (&decl, mangled, dlang_top_level) == NULL)\n \tstring_delete (&decl);\n     }\n "}, {"sha": "76cb208c81b78584298c4b1edb4e3cf90aab37ca", "filename": "libiberty/testsuite/d-demangle-expected", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a4dbf7d315730cf6c94a67a42e8cc3a41047ff5/libiberty%2Ftestsuite%2Fd-demangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a4dbf7d315730cf6c94a67a42e8cc3a41047ff5/libiberty%2Ftestsuite%2Fd-demangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fd-demangle-expected?ref=5a4dbf7d315730cf6c94a67a42e8cc3a41047ff5", "patch": "@@ -22,6 +22,14 @@ _D8demangle4testPFLAiYi\n demangle.test\n #\n --format=dlang\n+_D8demangle4testFZv\n+demangle.test()\n+#\n+--format=dlang\n+_D8demangle4testMFZ2fnMFZv\n+demangle.test().fn()\n+#\n+--format=dlang\n _D8demangle4testFaZv\n demangle.test(char)\n #\n@@ -1108,6 +1116,10 @@ _D8demangle29__T2fnVa97Va9Va0Vu257Vw65537Z2fnFZv\n demangle.fn!('a', '\\x09', '\\x00', '\\u0101', '\\U00010001').fn()\n #\n --format=dlang\n+_D8demangle32__T2fnTS3symVS3valS1a4_6e756c6cZ3fun13__T8positionZ13__T8confusesZ8demangleFDFxaZvZv\n+demangle.fn!(sym, val(\"null\")).fun.position!().confuses!().demangle(void(const(char)) delegate)\n+#\n+--format=dlang\n _D2gc11gctemplates56__T8mkBitmapTS3std5range13__T4iotaTiTiZ4iotaFiiZ6ResultZ8mkBitmapFNbNiNfPmmZv\n gc.gctemplates.mkBitmap!(std.range.iota!(int, int).iota(int, int).Result).mkBitmap(ulong*, ulong)\n #"}]}