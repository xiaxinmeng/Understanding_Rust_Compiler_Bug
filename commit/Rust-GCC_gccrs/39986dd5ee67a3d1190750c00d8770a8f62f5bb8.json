{"sha": "39986dd5ee67a3d1190750c00d8770a8f62f5bb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk5ODZkZDVlZTY3YTNkMTE5MDc1MGMwMGQ4NzcwYThmNjJmNWJiOA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-06-15T22:09:10Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-06-15T22:09:10Z"}, "message": "jni.cc (ClassClass): Removed; updated all users.\n\n\t* jni.cc (ClassClass): Removed; updated all users.\n\t(ObjectClass): Likewise.\n\t(ThrowableClass): Likewise.\n\t(MethodClass): Likewise.\n\t(ThreadGroupClass): Likewise.\n\t(local_ref_table): Renamed from `ref_table'.\n\t(global_ref_table): New global.\n\t(_Jv_JNI_Init): Initialize both ref tables.\n\t(mark_for_gc): Added `ref_table' parameter.\n\t(unmark_for_gc): Likewise.  Also, fail if we unreferenced too many\n\ttimes.\n\t(_Jv_JNI_NewGlobalRef): Updated for new mark function.\n\t(_Jv_JNI_DeleteGlobalRef): Likewise.\n\t(_Jv_JNI_DeleteLocalRef): Likewise.\n\t(_Jv_JNI_NewLocalRef): Likewise.\n\t(_Jv_JNI_PopLocalFrame): Likewise.\n\t(_Jv_JNI_GetStringChars): Likewise.\n\t(_Jv_JNI_ReleaseStringChars): Likewise.\n\t(_Jv_JNI_GetPrimitiveArrayElements): Likewise.\n\t(_Jv_JNI_ReleasePrimitiveArrayElements): Likewise.\n\nFrom-SVN: r43409", "tree": {"sha": "03b8104303ce7672ba05c9452e26e435fac2c617", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03b8104303ce7672ba05c9452e26e435fac2c617"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39986dd5ee67a3d1190750c00d8770a8f62f5bb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39986dd5ee67a3d1190750c00d8770a8f62f5bb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39986dd5ee67a3d1190750c00d8770a8f62f5bb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39986dd5ee67a3d1190750c00d8770a8f62f5bb8/comments", "author": null, "committer": null, "parents": [{"sha": "b927dc22376b479fd49cc5488d6adc347c05a738", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b927dc22376b479fd49cc5488d6adc347c05a738", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b927dc22376b479fd49cc5488d6adc347c05a738"}], "stats": {"total": 81, "additions": 51, "deletions": 30}, "files": [{"sha": "c50caf8486b46a97c014c5c4e6a1fb5ccfbf7d3f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39986dd5ee67a3d1190750c00d8770a8f62f5bb8/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39986dd5ee67a3d1190750c00d8770a8f62f5bb8/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=39986dd5ee67a3d1190750c00d8770a8f62f5bb8", "patch": "@@ -1,3 +1,26 @@\n+2001-06-15  Tom Tromey  <tromey@redhat.com>\n+\n+\t* jni.cc (ClassClass): Removed; updated all users.\n+\t(ObjectClass): Likewise.\n+\t(ThrowableClass): Likewise.\n+\t(MethodClass): Likewise.\n+\t(ThreadGroupClass): Likewise.\n+\t(local_ref_table): Renamed from `ref_table'.\n+\t(global_ref_table): New global.\n+\t(_Jv_JNI_Init): Initialize both ref tables.\n+\t(mark_for_gc): Added `ref_table' parameter.\n+\t(unmark_for_gc): Likewise.  Also, fail if we unreferenced too many\n+\ttimes.\n+\t(_Jv_JNI_NewGlobalRef): Updated for new mark function.\n+\t(_Jv_JNI_DeleteGlobalRef): Likewise.\n+\t(_Jv_JNI_DeleteLocalRef): Likewise.\n+\t(_Jv_JNI_NewLocalRef): Likewise.\n+\t(_Jv_JNI_PopLocalFrame): Likewise.\n+\t(_Jv_JNI_GetStringChars): Likewise.\n+\t(_Jv_JNI_ReleaseStringChars): Likewise.\n+\t(_Jv_JNI_GetPrimitiveArrayElements): Likewise.\n+\t(_Jv_JNI_ReleasePrimitiveArrayElements): Likewise.\n+\n 2001-06-14  Tom Tromey  <tromey@redhat.com>\n \n \tFix for PR libgcj/3144:"}, {"sha": "15f69bcce70fa5b255261f4fd277adf7633ba47f", "filename": "libjava/jni.cc", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39986dd5ee67a3d1190750c00d8770a8f62f5bb8/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39986dd5ee67a3d1190750c00d8770a8f62f5bb8/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=39986dd5ee67a3d1190750c00d8770a8f62f5bb8", "patch": "@@ -48,13 +48,6 @@ details.  */\n #include <java-interp.h>\n #include <java-threads.h>\n \n-// FIXME: remove these defines.\n-#define ClassClass java::lang::Class::class$\n-#define ObjectClass java::lang::Object::class$\n-#define ThrowableClass java::lang::Throwable::class$\n-#define MethodClass java::lang::reflect::Method::class$\n-#define ThreadGroupClass java::lang::ThreadGroup::class$\n-\n // This enum is used to select different template instantiations in\n // the invocation code.\n enum invocation_type\n@@ -97,8 +90,10 @@ struct _Jv_JNI_LocalFrame\n   jobject vec[0];\n };\n \n-// This holds a reference count for all local and global references.\n-static java::util::Hashtable *ref_table;\n+// This holds a reference count for all local references.\n+static java::util::Hashtable *local_ref_table;\n+// This holds a reference count for all global references.\n+static java::util::Hashtable *global_ref_table;\n \n // The only VM.\n static JavaVM *the_vm;\n@@ -153,8 +148,9 @@ jvmpiDisableEvent (jint event_type, void *)\n void\n _Jv_JNI_Init (void)\n {\n-  ref_table = new java::util::Hashtable;\n-  \n+  local_ref_table = new java::util::Hashtable;\n+  global_ref_table = new java::util::Hashtable;\n+\n #ifdef ENABLE_JVMPI\n   _Jv_JVMPI_Interface.version = 1;\n   _Jv_JVMPI_Interface.EnableEvent = &jvmpiEnableEvent;\n@@ -167,7 +163,7 @@ _Jv_JNI_Init (void)\n \n // Tell the GC that a certain pointer is live.\n static void\n-mark_for_gc (jobject obj)\n+mark_for_gc (jobject obj, java::util::Hashtable *ref_table)\n {\n   JvSynchronize sync (ref_table);\n \n@@ -180,14 +176,15 @@ mark_for_gc (jobject obj)\n \n // Unmark a pointer.\n static void\n-unmark_for_gc (jobject obj)\n+unmark_for_gc (jobject obj, java::util::Hashtable *ref_table)\n {\n   JvSynchronize sync (ref_table);\n \n   using namespace java::lang;\n   Integer *refcount = (Integer *) ref_table->get (obj);\n   JvAssert (refcount);\n   jint val = refcount->intValue () - 1;\n+  JvAssert (val >= 0);\n   if (val == 0)\n     ref_table->remove (obj);\n   else\n@@ -200,14 +197,14 @@ unmark_for_gc (jobject obj)\n static jobject\n _Jv_JNI_NewGlobalRef (JNIEnv *, jobject obj)\n {\n-  mark_for_gc (obj);\n+  mark_for_gc (obj, global_ref_table);\n   return obj;\n }\n \n static void\n _Jv_JNI_DeleteGlobalRef (JNIEnv *, jobject obj)\n {\n-  unmark_for_gc (obj);\n+  unmark_for_gc (obj, global_ref_table);\n }\n \n static void\n@@ -222,7 +219,7 @@ _Jv_JNI_DeleteLocalRef (JNIEnv *env, jobject obj)\n \t  if (frame->vec[i] == obj)\n \t    {\n \t      frame->vec[i] = NULL;\n-\t      unmark_for_gc (obj);\n+\t      unmark_for_gc (obj, local_ref_table);\n \t      return;\n \t    }\n \t}\n@@ -302,7 +299,7 @@ _Jv_JNI_NewLocalRef (JNIEnv *env, jobject obj)\n       env->locals->vec[0] = obj;\n     }\n \n-  mark_for_gc (obj);\n+  mark_for_gc (obj, local_ref_table);\n   return obj;\n }\n \n@@ -316,7 +313,7 @@ _Jv_JNI_PopLocalFrame (JNIEnv *env, jobject result, int stop)\n     {  \n       for (int i = 0; i < rf->size; ++i)\n \tif (rf->vec[i] != NULL)\n-\t  unmark_for_gc (rf->vec[i]);\n+\t  unmark_for_gc (rf->vec[i], local_ref_table);\n \n       // If the frame we just freed is the marker frame, we are done.\n       done = (rf->marker == stop);\n@@ -467,7 +464,7 @@ static jint\n _Jv_JNI_Throw (JNIEnv *env, jthrowable obj)\n {\n   // We check in case the user did some funky cast.\n-  JvAssert (obj != NULL && (&ThrowableClass)->isInstance (obj));\n+  JvAssert (obj != NULL && java::lang::Throwable::class$.isInstance (obj));\n   env->ex = obj;\n   return 0;\n }\n@@ -477,13 +474,14 @@ _Jv_JNI_ThrowNew (JNIEnv *env, jclass clazz, const char *message)\n {\n   using namespace java::lang::reflect;\n \n-  JvAssert ((&ThrowableClass)->isAssignableFrom (clazz));\n+  JvAssert (java::lang::Throwable::class$.isAssignableFrom (clazz));\n \n   int r = JNI_OK;\n   try\n     {\n       JArray<jclass> *argtypes\n-\t= (JArray<jclass> *) JvNewObjectArray (1, &ClassClass, NULL);\n+\t= (JArray<jclass> *) JvNewObjectArray (1, &java::lang::Class::class$,\n+\t\t\t\t\t       NULL);\n \n       jclass *elts = elements (argtypes);\n       elts[0] = &StringClass;\n@@ -922,7 +920,7 @@ _Jv_JNI_CallStaticMethodV (JNIEnv *env, jclass klass,\n \t\t\t   jmethodID id, va_list args)\n {\n   JvAssert (((id->accflags) & java::lang::reflect::Modifier::STATIC));\n-  JvAssert ((&ClassClass)->isInstance (klass));\n+  JvAssert (java::lang::Class::class$.isInstance (klass));\n \n   return _Jv_JNI_CallAnyMethodV<T, static_type> (env, NULL, klass, id, args);\n }\n@@ -937,7 +935,7 @@ _Jv_JNI_CallStaticMethod (JNIEnv *env, jclass klass, jmethodID id, ...)\n   T result;\n \n   JvAssert (((id->accflags) & java::lang::reflect::Modifier::STATIC));\n-  JvAssert ((&ClassClass)->isInstance (klass));\n+  JvAssert (java::lang::Class::class$.isInstance (klass));\n \n   va_start (args, id);\n   result = _Jv_JNI_CallAnyMethodV<T, static_type> (env, NULL, klass,\n@@ -955,7 +953,7 @@ _Jv_JNI_CallStaticMethodA (JNIEnv *env, jclass klass, jmethodID id,\n \t\t\t   jvalue *args)\n {\n   JvAssert (((id->accflags) & java::lang::reflect::Modifier::STATIC));\n-  JvAssert ((&ClassClass)->isInstance (klass));\n+  JvAssert (java::lang::Class::class$.isInstance (klass));\n \n   return _Jv_JNI_CallAnyMethodA<T, static_type> (env, NULL, klass, id, args);\n }\n@@ -1155,7 +1153,7 @@ static const jchar *\n _Jv_JNI_GetStringChars (JNIEnv *, jstring string, jboolean *isCopy)\n {\n   jchar *result = _Jv_GetStringChars (string);\n-  mark_for_gc (string);\n+  mark_for_gc (string, global_ref_table);\n   if (isCopy)\n     *isCopy = false;\n   return (const jchar *) result;\n@@ -1164,7 +1162,7 @@ _Jv_JNI_GetStringChars (JNIEnv *, jstring string, jboolean *isCopy)\n static void\n _Jv_JNI_ReleaseStringChars (JNIEnv *, jstring string, const jchar *)\n {\n-  unmark_for_gc (string);\n+  unmark_for_gc (string, global_ref_table);\n }\n \n static jstring\n@@ -1343,7 +1341,7 @@ _Jv_JNI_GetPrimitiveArrayElements (JNIEnv *, JArray<T> *array,\n       // We elect never to copy.\n       *isCopy = false;\n     }\n-  mark_for_gc (array);\n+  mark_for_gc (array, global_ref_table);\n   return elts;\n }\n \n@@ -1355,7 +1353,7 @@ _Jv_JNI_ReleasePrimitiveArrayElements (JNIEnv *, JArray<T> *array,\n   // Note that we ignore MODE.  We can do this because we never copy\n   // the array elements.  My reading of the JNI documentation is that\n   // this is an option for the implementor.\n-  unmark_for_gc (array);\n+  unmark_for_gc (array, global_ref_table);\n }\n \n template<typename T>\n@@ -1532,7 +1530,7 @@ static jmethodID\n _Jv_JNI_FromReflectedMethod (JNIEnv *, jobject method)\n {\n   using namespace java::lang::reflect;\n-  if ((&MethodClass)->isInstance (method))\n+  if (Method::class$.isInstance (method))\n     return _Jv_FromReflectedMethod (reinterpret_cast<Method *> (method));\n   return\n     _Jv_FromReflectedConstructor (reinterpret_cast<Constructor *> (method));\n@@ -1831,7 +1829,7 @@ _Jv_JNI_AttachCurrentThread (JavaVM *, jstring name, void **penv, void *args)\n \t  && attach->version != JNI_VERSION_1_1)\n \treturn JNI_EVERSION;\n \n-      JvAssert ((&ThreadGroupClass)->isInstance (attach->group));\n+      JvAssert (java::lang::ThreadGroup::class$.isInstance (attach->group));\n       group = reinterpret_cast<java::lang::ThreadGroup *> (attach->group);\n     }\n "}]}