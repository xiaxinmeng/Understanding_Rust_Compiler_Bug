{"sha": "bbdb5552f3ff822bd573d7261a9a4c5ccead1ef3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJkYjU1NTJmM2ZmODIyYmQ1NzNkNzI2MWE5YTRjNWNjZWFkMWVmMw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-04-28T20:33:51Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-04-28T20:33:51Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r849", "tree": {"sha": "06e27f2870698742286f6780b632da3bcbffa735", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06e27f2870698742286f6780b632da3bcbffa735"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbdb5552f3ff822bd573d7261a9a4c5ccead1ef3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbdb5552f3ff822bd573d7261a9a4c5ccead1ef3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbdb5552f3ff822bd573d7261a9a4c5ccead1ef3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbdb5552f3ff822bd573d7261a9a4c5ccead1ef3/comments", "author": null, "committer": null, "parents": [{"sha": "924706a09a3fc42b30f61f0c9189a89726bedd1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/924706a09a3fc42b30f61f0c9189a89726bedd1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/924706a09a3fc42b30f61f0c9189a89726bedd1a"}], "stats": {"total": 158, "additions": 111, "deletions": 47}, "files": [{"sha": "86f35e4195a84201f2c8b66715a4bb4070820798", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbdb5552f3ff822bd573d7261a9a4c5ccead1ef3/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbdb5552f3ff822bd573d7261a9a4c5ccead1ef3/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=bbdb5552f3ff822bd573d7261a9a4c5ccead1ef3", "patch": "@@ -1662,16 +1662,21 @@ gen_int_relational (test_code, result, cmp0, cmp1, p_invert)\n       cmp1 = temp;\n     }\n \n-  reg = (invert || eqne_p) ? gen_reg_rtx (SImode) : result;\n-  emit_move_insn (reg, gen_rtx (p_info->test_code, SImode, cmp0, cmp1));\n-\n   if (test == ITEST_NE && GET_CODE (cmp1) == CONST_INT && INTVAL (cmp1) == 0)\n+    reg = cmp0;\n+  else\n+    {\n+      reg = (invert || eqne_p) ? gen_reg_rtx (SImode) : result;\n+      emit_move_insn (reg, gen_rtx (p_info->test_code, SImode, cmp0, cmp1));\n+    }\n+\n+  if (test == ITEST_NE)\n     {\n       emit_move_insn (result, gen_rtx (GTU, SImode, reg, const0_rtx));\n       invert = FALSE;\n     }\n \n-  else if (eqne_p)\n+  else if (test == ITEST_EQ)\n     {\n       reg2 = (invert) ? gen_reg_rtx (SImode) : result;\n       emit_move_insn (reg2, gen_rtx (LTU, SImode, reg, const1_rtx));\n@@ -3568,9 +3573,6 @@ mips_asm_file_start (stream)\n   if (TARGET_ABICALLS)\n     fprintf (stream, \"\\t.abicalls\\n\");\n \n-  /* put gcc_compiled. in data, not text */\n-  data_section ();\n-\n   if (TARGET_GP_OPT)\n     {\n       asm_out_data_file = stream;"}, {"sha": "0e89ad630948ed95e2059aaed2261a6f0fe308f8", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbdb5552f3ff822bd573d7261a9a4c5ccead1ef3/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbdb5552f3ff822bd573d7261a9a4c5ccead1ef3/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=bbdb5552f3ff822bd573d7261a9a4c5ccead1ef3", "patch": "@@ -650,7 +650,7 @@ do {\t\t\t\t\t\t\t\\\n #define MASK_DEBUG\t0x40000000\t/* Eliminate version # in .s file */\n #define MASK_DEBUG_A\t0x20000000\t/* don't allow <label>($reg) addrs */\n #define MASK_DEBUG_B\t0x10000000\t/* GO_IF_LEGITIMATE_ADDRESS debug */\n-#define MASK_DEBUG_C\t0x08000000\t/* allow new seq, sne, etc. patterns */\n+#define MASK_DEBUG_C\t0x08000000\t/* don't expand seq, etc. */\n #define MASK_DEBUG_D\t0x04000000\t/* don't do define_split's */\n #define MASK_DEBUG_E\t0x02000000\t/* function_arg debug */\n #define MASK_DEBUG_F\t0x01000000\t/* don't try to suppress load nop's */"}, {"sha": "dfa514138c30cbd44866ab4a796067524c772636", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 50, "deletions": 35, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbdb5552f3ff822bd573d7261a9a4c5ccead1ef3/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbdb5552f3ff822bd573d7261a9a4c5ccead1ef3/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=bbdb5552f3ff822bd573d7261a9a4c5ccead1ef3", "patch": "@@ -103,7 +103,7 @@\n (define_delay (eq_attr \"type\" \"branch\")\n   [(and (eq_attr \"dslot\" \"no\") (eq_attr \"length\" \"1\"))\n    (nil)\n-   (eq_attr \"branch_likely\" \"yes\")])\n+   (and (eq_attr \"branch_likely\" \"yes\") (and (eq_attr \"dslot\" \"no\") (eq_attr \"length\" \"1\")))])\n \n (define_delay (eq_attr \"type\" \"call,jump\")\n   [(and (eq_attr \"dslot\" \"no\") (eq_attr \"length\" \"1\"))\n@@ -1507,22 +1507,37 @@ move\\\\t%0,%z4\\\\n\\\\\n \n \n (define_insn \"floatsidf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(float:DF (match_operand:SI 1 \"register_operand\" \"d\")))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,f,f\")\n+\t(float:DF (match_operand:SI 1 \"nonimmediate_operand\" \"d,R,m\")))]\n   \"TARGET_HARD_FLOAT\"\n-  \"mtc1\\\\t%1,%0\\;cvt.d.w\\\\t%0,%0\"\n-  [(set_attr \"type\"\t\"fcvt\")\n-   (set_attr \"mode\"\t\"DF\")\n-   (set_attr \"length\"\t\"13\")])\n+  \"*\n+{\n+  dslots_load_total++;\n+  if (GET_CODE (operands[1]) == MEM)\n+    return \\\"ld.s\\\\t%0,%1%#\\;cvt.d.w\\\\t%0,%0\\\";\n+\n+  return \\\"mtc1\\\\t%1,%0%#\\;cvt.d.w\\\\t%0,%0\\\";\n+}\"\n+  [(set_attr \"type\"\t\"fcvt,fcvt,fcvt\")\n+   (set_attr \"mode\"\t\"DF,DF,DF\")\n+   (set_attr \"length\"\t\"3,4,3\")])\n \n (define_insn \"floatsisf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(float:SF (match_operand:SI 1 \"register_operand\" \"d\")))]\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f,f\")\n+\t(float:SF (match_operand:SI 1 \"nonimmediate_operand\" \"d,R,m\")))]\n   \"TARGET_HARD_FLOAT\"\n-  \"mtc1\\\\t%1,%0\\;cvt.s.w\\\\t%0,%0\"\n-  [(set_attr \"type\"\t\"fcvt\")\n-   (set_attr \"mode\"\t\"SF\")\n-   (set_attr \"length\"\t\"13\")])\n+  \"*\n+{\n+  dslots_load_total++;\n+  if (GET_CODE (operands[1]) == MEM)\n+    return \\\"ld.s\\\\t%0,%1%#\\;cvt.s.w\\\\t%0,%0\\\";\n+\n+  return \\\"mtc1\\\\t%1,%0%#\\;cvt.s.w\\\\t%0,%0\\\";\n+}\"\n+  [(set_attr \"type\"\t\"fcvt,fcvt,fcvt\")\n+   (set_attr \"mode\"\t\"SF,SF,SF\")\n+   (set_attr \"length\"\t\"3,4,3\")])\n+\n \n (define_expand \"fixuns_truncdfsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -3049,7 +3064,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[1] = branch_cmp[0];\n   operands[2] = branch_cmp[1];\n \n-  if (TARGET_DEBUG_C_MODE)\n+  if (!TARGET_DEBUG_C_MODE)\n     {\n       gen_int_relational (EQ, operands[0], operands[1], operands[2], (int *)0);\n       DONE;\n@@ -3076,7 +3091,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n \t(eq:SI (match_operand:SI 1 \"register_operand\" \"%d,d\")\n \t       (match_operand:SI 2 \"uns_arith_operand\" \"d,K\")))]\n-  \"!TARGET_DEBUG_C_MODE\"\n+  \"TARGET_DEBUG_C_MODE\"\n   \"@\n    xor\\\\t%0,%1,%2\\;sltu\\\\t%0,%0,1\n    xori\\\\t%0,%1,%2\\;sltu\\\\t%0,%0,1\"\n@@ -3088,7 +3103,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(eq:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t       (match_operand:SI 2 \"uns_arith_operand\" \"\")))]\n-  \"!TARGET_DEBUG_C_MODE && !TARGET_DEBUG_D_MODE\n+  \"TARGET_DEBUG_C_MODE && !TARGET_DEBUG_D_MODE\n     && (GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) != 0)\"\n   [(set (match_dup 0)\n \t(xor:SI (match_dup 1)\n@@ -3114,7 +3129,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[1] = branch_cmp[0];\n   operands[2] = branch_cmp[1];\n \n-  if (TARGET_DEBUG_C_MODE)\n+  if (!TARGET_DEBUG_C_MODE)\n     {\n       gen_int_relational (NE, operands[0], operands[1], operands[2], (int *)0);\n       DONE;\n@@ -3140,7 +3155,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n \t(ne:SI (match_operand:SI 1 \"register_operand\" \"%d,d\")\n \t       (match_operand:SI 2 \"uns_arith_operand\" \"d,K\")))]\n-  \"!TARGET_DEBUG_C_MODE\"\n+  \"TARGET_DEBUG_C_MODE\"\n   \"@\n     xor\\\\t%0,%1,%2\\;sltu\\\\t%0,%.,%0\n     xori\\\\t%0,%1,%x2\\;sltu\\\\t%0,%.,%0\"\n@@ -3152,7 +3167,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ne:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t       (match_operand:SI 2 \"uns_arith_operand\" \"\")))]\n-  \"!TARGET_DEBUG_C_MODE && !TARGET_DEBUG_D_MODE\n+  \"TARGET_DEBUG_C_MODE && !TARGET_DEBUG_D_MODE\n     && (GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) != 0)\"\n   [(set (match_dup 0)\n \t(xor:SI (match_dup 1)\n@@ -3178,7 +3193,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[1] = branch_cmp[0];\n   operands[2] = branch_cmp[1];\n \n-  if (TARGET_DEBUG_C_MODE)\n+  if (!TARGET_DEBUG_C_MODE)\n     {\n       gen_int_relational (GT, operands[0], operands[1], operands[2], (int *)0);\n       DONE;\n@@ -3214,7 +3229,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[1] = branch_cmp[0];\n   operands[2] = branch_cmp[1];\n \n-  if (TARGET_DEBUG_C_MODE)\n+  if (!TARGET_DEBUG_C_MODE)\n     {\n       gen_int_relational (GE, operands[0], operands[1], operands[2], (int *)0);\n       DONE;\n@@ -3227,7 +3242,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(ge:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t       (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"!TARGET_DEBUG_C_MODE\"\n+  \"TARGET_DEBUG_C_MODE\"\n   \"slt\\\\t%0,%1,%2\\;xori\\\\t%0,%0,0x0001\"\n  [(set_attr \"type\"\t\"arith\")\n    (set_attr \"mode\"\t\"SI\")\n@@ -3237,7 +3252,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ge:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t       (match_operand:SI 2 \"arith_operand\" \"\")))]\n-  \"!TARGET_DEBUG_C_MODE && !TARGET_DEBUG_D_MODE\"\n+  \"TARGET_DEBUG_C_MODE && !TARGET_DEBUG_D_MODE\"\n   [(set (match_dup 0)\n \t(lt:SI (match_dup 1)\n \t       (match_dup 2)))\n@@ -3260,7 +3275,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[1] = branch_cmp[0];\n   operands[2] = branch_cmp[1];\n \n-  if (TARGET_DEBUG_C_MODE)\n+  if (!TARGET_DEBUG_C_MODE)\n     {\n       gen_int_relational (LT, operands[0], operands[1], operands[2], (int *)0);\n       DONE;\n@@ -3295,7 +3310,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[1] = branch_cmp[0];\n   operands[2] = branch_cmp[1];\n \n-  if (TARGET_DEBUG_C_MODE)\n+  if (!TARGET_DEBUG_C_MODE)\n     {\n       gen_int_relational (LE, operands[0], operands[1], operands[2], (int *)0);\n       DONE;\n@@ -3325,7 +3340,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(le:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t       (match_operand:SI 2 \"register_operand\" \"d\")))]\n-  \"!TARGET_DEBUG_C_MODE\"\n+  \"TARGET_DEBUG_C_MODE\"\n   \"slt\\\\t%0,%z2,%1\\;xori\\\\t%0,%0,0x0001\"\n  [(set_attr \"type\"\t\"arith\")\n    (set_attr \"mode\"\t\"SI\")\n@@ -3335,7 +3350,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(le:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t       (match_operand:SI 2 \"register_operand\" \"\")))]\n-  \"!TARGET_DEBUG_C_MODE && !TARGET_DEBUG_D_MODE\"\n+  \"TARGET_DEBUG_C_MODE && !TARGET_DEBUG_D_MODE\"\n   [(set (match_dup 0)\n \t(lt:SI (match_dup 2)\n \t       (match_dup 1)))\n@@ -3360,7 +3375,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[1] = branch_cmp[0];\n   operands[2] = branch_cmp[1];\n \n-  if (TARGET_DEBUG_C_MODE)\n+  if (!TARGET_DEBUG_C_MODE)\n     {\n       gen_int_relational (GTU, operands[0], operands[1], operands[2], (int *)0);\n       DONE;\n@@ -3396,7 +3411,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[1] = branch_cmp[0];\n   operands[2] = branch_cmp[1];\n \n-  if (TARGET_DEBUG_C_MODE)\n+  if (!TARGET_DEBUG_C_MODE)\n     {\n       gen_int_relational (GEU, operands[0], operands[1], operands[2], (int *)0);\n       DONE;\n@@ -3409,7 +3424,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(geu:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t(match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"!TARGET_DEBUG_C_MODE\"\n+  \"TARGET_DEBUG_C_MODE\"\n   \"sltu\\\\t%0,%1,%2\\;xori\\\\t%0,%0,0x0001\"\n  [(set_attr \"type\"\t\"arith\")\n    (set_attr \"mode\"\t\"SI\")\n@@ -3419,7 +3434,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(geu:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t(match_operand:SI 2 \"arith_operand\" \"\")))]\n-  \"!TARGET_DEBUG_C_MODE && !TARGET_DEBUG_D_MODE\"\n+  \"TARGET_DEBUG_C_MODE && !TARGET_DEBUG_D_MODE\"\n   [(set (match_dup 0)\n \t(ltu:SI (match_dup 1)\n \t\t(match_dup 2)))\n@@ -3442,7 +3457,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[1] = branch_cmp[0];\n   operands[2] = branch_cmp[1];\n \n-  if (TARGET_DEBUG_C_MODE)\n+  if (!TARGET_DEBUG_C_MODE)\n     {\n       gen_int_relational (LTU, operands[0], operands[1], operands[2], (int *)0);\n       DONE;\n@@ -3477,7 +3492,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[1] = branch_cmp[0];\n   operands[2] = branch_cmp[1];\n \n-  if (TARGET_DEBUG_C_MODE)\n+  if (!TARGET_DEBUG_C_MODE)\n     {\n       gen_int_relational (LEU, operands[0], operands[1], operands[2], (int *)0);\n       DONE;\n@@ -3507,7 +3522,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(leu:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t(match_operand:SI 2 \"register_operand\" \"d\")))]\n-  \"!TARGET_DEBUG_C_MODE\"\n+  \"TARGET_DEBUG_C_MODE\"\n   \"sltu\\\\t%0,%z2,%1\\;xori\\\\t%0,%0,0x0001\"\n  [(set_attr \"type\"\t\"arith\")\n    (set_attr \"mode\"\t\"SI\")\n@@ -3517,7 +3532,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(leu:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t(match_operand:SI 2 \"register_operand\" \"\")))]\n-  \"!TARGET_DEBUG_C_MODE && !TARGET_DEBUG_D_MODE\"\n+  \"TARGET_DEBUG_C_MODE && !TARGET_DEBUG_D_MODE\"\n   [(set (match_dup 0)\n \t(ltu:SI (match_dup 2)\n \t\t(match_dup 1)))"}, {"sha": "5dce4ac4fb2a957beb27e2017b6e9c7cc5afc80d", "filename": "gcc/config/mips/osfrose.h", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbdb5552f3ff822bd573d7261a9a4c5ccead1ef3/gcc%2Fconfig%2Fmips%2Fosfrose.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbdb5552f3ff822bd573d7261a9a4c5ccead1ef3/gcc%2Fconfig%2Fmips%2Fosfrose.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fosfrose.h?ref=bbdb5552f3ff822bd573d7261a9a4c5ccead1ef3", "patch": "@@ -48,7 +48,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \t\t\t%{.s:%i} %{!.s:%g.s}}}\"\n \n #define CPP_SPEC \"\\\n-%{.S:\t-D__LANGUAGE_ASSEMBLY__ %{!ansi:-DLANGUAGE_ASSEMBLY}} \\\n+%{.S:\t-D__LANGUAGE_ASSEMBLY__ %{!ansi:-DLANGUAGE_ASSEMBLY} -DLANGUAGE_C -D__LANGUAGE_C__} \\\n %{.cc:\t-D__LANGUAGE_C_PLUS_PLUS__} \\\n %{.cxx:\t-D__LANGUAGE_C_PLUS_PLUS__} \\\n %{.C:\t-D__LANGUAGE_C_PLUS_PLUS__} \\\n@@ -110,4 +110,23 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* Generate calls to memcpy, etc., not bcopy, etc.  */\n #define TARGET_MEM_FUNCTIONS\n \n+/* A C statement to output assembler commands which will identify\n+   the object file as having been compiled with GNU CC (or another\n+   GNU compiler).\n+\n+   If you don't define this macro, the string `gcc2_compiled.:' is\n+   output.  This string is calculated to define a symbol which, on\n+   BSD systems, will never be defined for any other reason.  GDB\n+   checks for the presence of this symbol when reading the symbol\n+   table of an executable.\n+\n+   On non-BSD systems, you must arrange communication with GDB in\n+   some other fashion.  If GDB is not used on your system, you can\n+   define this macro with an empty body.\n+\n+   On OSF/1, gcc2_compiled. confuses the kernel debugger, so don't\n+   put it out.  */\n+\n+#define ASM_IDENTIFY_GCC(STREAM)\n+\n #include \"mips.h\""}, {"sha": "d8f96712b5ce959eafdde7cafed7db97f67c3c95", "filename": "gcc/mips-tfile.c", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbdb5552f3ff822bd573d7261a9a4c5ccead1ef3/gcc%2Fmips-tfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbdb5552f3ff822bd573d7261a9a4c5ccead1ef3/gcc%2Fmips-tfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tfile.c?ref=bbdb5552f3ff822bd573d7261a9a4c5ccead1ef3", "patch": "@@ -2736,12 +2736,16 @@ st_to_string(symbol_type)\n }\n \n \f\n-/* Read a line from standard input, and return the start of the\n-   buffer (which is grows if the line is too big).  */\n+/* Read a line from standard input, and return the start of the buffer\n+   (which is grows if the line is too big).  We split lines at the\n+   semi-colon, and return each logical line indpendently.  */\n \n STATIC char *\n read_line __proto((void))\n {\n+  static   int line_split_p\t= 0;\n+  register int string_p\t\t= 0;\n+  register int comment_p\t= 0;\n   register int ch;\n   register char *ptr;\n \n@@ -2751,8 +2755,11 @@ read_line __proto((void))\n       cur_line_alloc = PAGE_SIZE;\n     }\n \n+  if (!line_split_p)\n+    line_number++;\n+\n+  line_split_p = 0;\n   cur_line_nbytes = 0;\n-  line_number++;\n \n   for (ptr = cur_line_start; (ch = getchar ()) != EOF; *ptr++ = ch)\n     {\n@@ -2775,6 +2782,27 @@ read_line __proto((void))\n \t  cur_line_ptr = cur_line_start;\n \t  return cur_line_ptr;\n \t}\n+\n+      else if (ch == '\\0')\n+\terror (\"Null character found in input\");\n+\n+      else if (!comment_p)\n+\t{\n+\t  if (ch == '\"')\n+\t    string_p = !string_p;\n+\n+\t  else if (ch == '#')\n+\t    comment_p++;\n+\n+\t  else if (ch == ';')\n+\t    {\n+\t      line_split_p = 1;\n+\t      *ptr++ = '\\n';\n+\t      *ptr = '\\0';\n+\t      cur_line_ptr = cur_line_start;\n+\t      return cur_line_ptr;\n+\t    }\n+\t}\n     }\n \n   if (ferror (stdin))"}]}