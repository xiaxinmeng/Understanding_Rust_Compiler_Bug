{"sha": "d90ffc8d2c830e45f8e7a17fe66355e7d7865fd8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDkwZmZjOGQyYzgzMGU0NWY4ZTdhMTdmZTY2MzU1ZTdkNzg2NWZkOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-09-11T23:54:11Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-09-11T23:54:11Z"}, "message": "i386.md (add?i_3, add?i_5): New.\n\n\n\t* i386.md (add?i_3, add?i_5): New.\n\t(add?i_4): Rename from add?i_3;  Fix compare pattern.\n\t(sub?i_3, xor?i_3, ior?i_3): New.\n\n\t* genrecog.c (write_tree): Output code to clear insn_extract cache.\n\t* genattrtab.c (write_attr_case): Gen call to extract_insn_cache\n\tinstead of extract_insn and extract_constrain_insn_cache instead of\n\textract_insn and constrain_operands.\n\t* recog.c (extract_insn_cached, extract_constrain_insn_cached):\n\tNew functions.\n\t(extract_insn): Clear which_alternative.\n\t(constrain_operands): Set which_alternative to -1 when failed.\n\t* recog.h (extract_constrain_insn_cached, extract_insn_cached):\n\tDeclare.\n\nFrom-SVN: r36342", "tree": {"sha": "a4a10ad41eb4009a3a451fc4518e9f29cc1010ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4a10ad41eb4009a3a451fc4518e9f29cc1010ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d90ffc8d2c830e45f8e7a17fe66355e7d7865fd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d90ffc8d2c830e45f8e7a17fe66355e7d7865fd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d90ffc8d2c830e45f8e7a17fe66355e7d7865fd8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d90ffc8d2c830e45f8e7a17fe66355e7d7865fd8/comments", "author": null, "committer": null, "parents": [{"sha": "14203c9cac8bfbabc168aee4df38cb752bbed421", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14203c9cac8bfbabc168aee4df38cb752bbed421", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14203c9cac8bfbabc168aee4df38cb752bbed421"}], "stats": {"total": 345, "additions": 329, "deletions": 16}, "files": [{"sha": "7643df0a864031c28024f191a70af734c3ea6d91", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90ffc8d2c830e45f8e7a17fe66355e7d7865fd8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90ffc8d2c830e45f8e7a17fe66355e7d7865fd8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d90ffc8d2c830e45f8e7a17fe66355e7d7865fd8", "patch": "@@ -1,3 +1,20 @@\n+Tue Sep 12 01:51:38 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.md (add?i_3, add?i_5): New.\n+\t(add?i_4): Rename from add?i_3;  Fix compare pattern.\n+\t(sub?i_3, xor?i_3, ior?i_3): New.\n+\n+\t* genrecog.c (write_tree): Output code to clear insn_extract cache.\n+\t* genattrtab.c (write_attr_case): Gen call to extract_insn_cache\n+\tinstead of extract_insn and extract_constrain_insn_cache instead of\n+\textract_insn and constrain_operands.\n+\t* recog.c (extract_insn_cached, extract_constrain_insn_cached):\n+\tNew functions.\n+\t(extract_insn): Clear which_alternative.\n+\t(constrain_operands): Set which_alternative to -1 when failed.\n+\t* recog.h (extract_constrain_insn_cached, extract_insn_cached):\n+\tDeclare.\n+\n 2000-09-11  Matthew Hiller  <hiller@redhat.com>\n \n \t* config/h8300/h8300.md (movstrictqi): Changed constraint modifier"}, {"sha": "6e8022f6f4497a773159052c5a3bc7666f37ac48", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 272, "deletions": 9, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90ffc8d2c830e45f8e7a17fe66355e7d7865fd8/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90ffc8d2c830e45f8e7a17fe66355e7d7865fd8/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=d90ffc8d2c830e45f8e7a17fe66355e7d7865fd8", "patch": "@@ -3997,10 +3997,55 @@\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*addsi_3\"\n+  [(set (reg 17)\n+\t(compare (neg:SI (match_operand:SI 2 \"general_operand\" \"rmni\"))\n+\t\t (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")))\n+   (clobber (match_scratch:SI 0 \"=r\"))]\n+  \"ix86_match_ccmode (insn, CCNOmode)\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\n+   /* Current assemblers are broken and do not allow @GOTOFF in\n+      ought but a memory context. */\n+   && ! pic_symbolic_operand (operands[2], VOIDmode)\"\n+  \"*\n+{\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_INCDEC:\n+      if (! rtx_equal_p (operands[0], operands[1]))\n+\tabort ();\n+      if (operands[2] == const1_rtx)\n+        return \\\"inc{l}\\\\t%0\\\";\n+      else if (operands[2] == constm1_rtx)\n+        return \\\"dec{l}\\\\t%0\\\";\n+      else\n+\tabort();\n+\n+    default:\n+      if (! rtx_equal_p (operands[0], operands[1]))\n+\tabort ();\n+      /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.\n+\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n+      if (GET_CODE (operands[2]) == CONST_INT\n+          && (INTVAL (operands[2]) == 128\n+\t      || (INTVAL (operands[2]) < 0\n+\t\t  && INTVAL (operands[2]) != -128)))\n+        {\n+          operands[2] = GEN_INT (-INTVAL (operands[2]));\n+          return \\\"sub{l}\\\\t{%2, %0|%0, %2}\\\";\n+        }\n+      return \\\"add{l}\\\\t{%2, %0|%0, %2}\\\";\n+    }\n+}\"\n+  [(set (attr \"type\")\n+     (if_then_else (match_operand:SI 2 \"incdec_operand\" \"\")\n+\t(const_string \"incdec\")\n+\t(const_string \"alu\")))\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*addsi_4\"\n   [(set (reg:CC 17)\n-\t(compare:CC (plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t\t     (match_operand:SI 2 \"general_operand\" \"rmni,rni\"))\n-\t\t    (const_int 0)))\t\t\t\n+\t(compare:CC (neg:SI (match_operand:SI 2 \"general_operand\" \"rmni,rni\"))\n+\t\t    (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0\")))\n    (set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,rm\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n   \"ix86_binary_operator_ok (PLUS, SImode, operands)\n@@ -4011,6 +4056,19 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn \"*addsi_5\"\n+  [(set (reg:CC 17)\n+\t(compare:CC (neg:SI (match_operand:SI 2 \"general_operand\" \"rmni\"))\n+\t\t    (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")))\n+   (clobber (match_scratch:SI 0 \"=r\"))]\n+  \"(GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\n+   /* Current assemblers are broken and do not allow @GOTOFF in\n+      ought but a memory context. */\n+   && ! pic_symbolic_operand (operands[2], VOIDmode)\"\n+  \"add{l}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_expand \"addhi3\"\n   [(parallel [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n \t\t   (plus:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\")\n@@ -4151,17 +4209,66 @@\n    (set_attr \"mode\" \"HI\")])\n \n (define_insn \"*addhi_3\"\n+  [(set (reg 17)\n+\t(compare (neg:HI (match_operand:HI 2 \"general_operand\" \"rmni\"))\n+\t\t (match_operand:HI 1 \"nonimmediate_operand\" \"%0\")))\n+   (clobber (match_scratch:HI 0 \"=r\"))]\n+  \"ix86_match_ccmode (insn, CCNOmode)\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n+  \"*\n+{\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_INCDEC:\n+      if (operands[2] == const1_rtx)\n+\treturn \\\"inc{w}\\\\t%0\\\";\n+      else if (operands[2] == constm1_rtx\n+\t       || (GET_CODE (operands[2]) == CONST_INT\n+\t\t   && INTVAL (operands[2]) == 65535))\n+\treturn \\\"dec{w}\\\\t%0\\\";\n+      abort();\n+\n+    default:\n+      /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.\n+\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n+      if (GET_CODE (operands[2]) == CONST_INT\n+          && (INTVAL (operands[2]) == 128\n+\t      || (INTVAL (operands[2]) < 0\n+\t\t  && INTVAL (operands[2]) != -128)))\n+\t{\n+\t  operands[2] = GEN_INT (-INTVAL (operands[2]));\n+\t  return \\\"sub{w}\\\\t{%2, %0|%0, %2}\\\";\n+\t}\n+      return \\\"add{w}\\\\t{%2, %0|%0, %2}\\\";\n+    }\n+}\"\n+  [(set (attr \"type\")\n+     (if_then_else (match_operand:HI 2 \"incdec_operand\" \"\")\n+\t(const_string \"incdec\")\n+\t(const_string \"alu\")))\n+   (set_attr \"mode\" \"HI\")])\n+\n+(define_insn \"*addhi_4\"\n   [(set (reg:CC 17)\n-\t(compare:CC (plus:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t\t     (match_operand:HI 2 \"general_operand\" \"rmni,rni\"))\n-\t\t    (const_int 0)))\t\t\t\n+\t(compare:CC (neg:HI (match_operand:HI 2 \"general_operand\" \"rmni,rni\"))\n+\t\t    (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0\")))\n    (set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,rm\")\n \t(plus:HI (match_dup 1) (match_dup 2)))]\n   \"ix86_binary_operator_ok (PLUS, HImode, operands)\"\n   \"add{w}\\\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"HI\")])\n \n+(define_insn \"*addhi_5\"\n+  [(set (reg:CC 17)\n+\t(compare:CC (neg:HI (match_operand:HI 2 \"general_operand\" \"rmni\"))\n+\t\t    (match_operand:HI 1 \"nonimmediate_operand\" \"%0\")))\n+   (clobber (match_scratch:HI 0 \"=r\"))]\n+  \"(GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n+  \"add{w}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"HI\")])\n+\n (define_expand \"addqi3\"\n   [(parallel [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n \t\t   (plus:QI (match_operand:QI 1 \"nonimmediate_operand\" \"\")\n@@ -4310,17 +4417,63 @@\n    (set_attr \"mode\" \"QI\")])\n \n (define_insn \"*addqi_3\"\n+  [(set (reg 17)\n+\t(compare (neg:QI (match_operand:QI 2 \"general_operand\" \"qmni\"))\n+\t\t (match_operand:QI 1 \"nonimmediate_operand\" \"%0\")))\n+   (clobber (match_scratch:QI 0 \"=r\"))]\n+  \"ix86_match_ccmode (insn, CCNOmode)\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n+  \"*\n+{\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_INCDEC:\n+      if (operands[2] == const1_rtx)\n+\treturn \\\"inc{b}\\\\t%0\\\";\n+      else if (operands[2] == constm1_rtx\n+\t       || (GET_CODE (operands[2]) == CONST_INT\n+\t\t   && INTVAL (operands[2]) == 255))\n+\treturn \\\"dec{b}\\\\t%0\\\";\n+      abort();\n+\n+    default:\n+      /* Make things pretty and `subb $4,%al' rather than `addb $-4, %al'.  */\n+      if (GET_CODE (operands[2]) == CONST_INT\n+          && INTVAL (operands[2]) < 0)\n+\t{\n+\t  operands[2] = GEN_INT (-INTVAL (operands[2]));\n+\t  return \\\"sub{b}\\\\t{%2, %0|%0, %2}\\\";\n+\t}\n+      return \\\"add{b}\\\\t{%2, %0|%0, %2}\\\";\n+    }\n+}\"\n+  [(set (attr \"type\")\n+     (if_then_else (match_operand:QI 2 \"incdec_operand\" \"\")\n+\t(const_string \"incdec\")\n+\t(const_string \"alu\")))\n+   (set_attr \"mode\" \"QI\")])\n+\n+(define_insn \"*addqi_4\"\n   [(set (reg:CC 17)\n-\t(compare:CC (plus:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t\t     (match_operand:QI 2 \"general_operand\" \"qmni,qni\"))\n-\t\t    (const_int 0)))\t\t\t\n+\t(compare:CC (neg:QI (match_operand:QI 2 \"general_operand\" \"qmni,qni\"))\n+\t\t    (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0\")))\n    (set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,qm\")\n \t(plus:QI (match_dup 1) (match_dup 2)))]\n   \"ix86_binary_operator_ok (PLUS, QImode, operands)\"\n   \"add{b}\\\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"QI\")])\n \n+(define_insn \"*addqi_5\"\n+  [(set (reg:CC 17)\n+\t(compare:CC (neg:QI (match_operand:QI 2 \"general_operand\" \"qmni\"))\n+\t\t    (match_operand:QI 1 \"nonimmediate_operand\" \"%0\")))\n+   (clobber (match_scratch:QI 0 \"=r\"))]\n+  \"(GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n+  \"add{b}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"QI\")])\n+\n \n (define_insn \"addqi_ext_1\"\n   [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=q\")\n@@ -4478,6 +4631,18 @@\n \t  (const_int 0)))\n    (set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r\")\n \t(minus:SI (match_dup 1) (match_dup 2)))]\n+  \"ix86_match_ccmode (insn, CCNOmode)\n+   && ix86_binary_operator_ok (MINUS, SImode, operands)\"\n+  \"sub{l}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*subsi_3\"\n+  [(set (reg 17)\n+\t(compare (match_operand:SI 1 \"nonimmediate_operand\" \"0,0\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"ri,rm\")))\n+   (set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r\")\n+\t(minus:SI (match_dup 1) (match_dup 2)))]\n   \"ix86_match_ccmode (insn, CCmode)\n    && ix86_binary_operator_ok (MINUS, SImode, operands)\"\n   \"sub{l}\\\\t{%2, %0|%0, %2}\"\n@@ -4510,6 +4675,18 @@\n \t  (const_int 0)))\n    (set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r\")\n \t(minus:HI (match_dup 1) (match_dup 2)))]\n+  \"ix86_match_ccmode (insn, CCNOmode)\n+   && ix86_binary_operator_ok (MINUS, HImode, operands)\"\n+  \"sub{w}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"HI\")])\n+\n+(define_insn \"*subhi_3\"\n+  [(set (reg 17)\n+\t(compare (match_operand:HI 1 \"nonimmediate_operand\" \"0,0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"ri,rm\")))\n+   (set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r\")\n+\t(minus:HI (match_dup 1) (match_dup 2)))]\n   \"ix86_match_ccmode (insn, CCmode)\n    && ix86_binary_operator_ok (MINUS, HImode, operands)\"\n   \"sub{w}\\\\t{%2, %0|%0, %2}\"\n@@ -4542,6 +4719,18 @@\n \t  (const_int 0)))\n    (set (match_operand:HI 0 \"nonimmediate_operand\" \"=qm,q\")\n \t(minus:HI (match_dup 1) (match_dup 2)))]\n+  \"ix86_match_ccmode (insn, CCNOmode)\n+   && ix86_binary_operator_ok (MINUS, QImode, operands)\"\n+  \"sub{b}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"QI\")])\n+\n+(define_insn \"*subqi_3\"\n+  [(set (reg 17)\n+\t(compare (match_operand:QI 1 \"nonimmediate_operand\" \"0,0\")\n+\t\t (match_operand:QI 2 \"general_operand\" \"qi,qm\")))\n+   (set (match_operand:HI 0 \"nonimmediate_operand\" \"=qm,q\")\n+\t(minus:HI (match_dup 1) (match_dup 2)))]\n   \"ix86_match_ccmode (insn, CCmode)\n    && ix86_binary_operator_ok (MINUS, QImode, operands)\"\n   \"sub{b}\\\\t{%2, %0|%0, %2}\"\n@@ -5491,6 +5680,18 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn \"*iorsi_3\"\n+  [(set (reg 17)\n+\t(compare (ior:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"rim\"))\n+\t\t (const_int 0)))\n+   (clobber (match_scratch:SI 0 \"=r\"))]\n+  \"ix86_match_ccmode (insn, CCNOmode)\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n+  \"or{l}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_expand \"iorhi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n \t(ior:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\")\n@@ -5522,6 +5723,18 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"HI\")])\n \n+(define_insn \"*iorhi_3\"\n+  [(set (reg 17)\n+\t(compare (ior:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t\t (match_operand:HI 2 \"general_operand\" \"rim\"))\n+\t\t (const_int 0)))\n+   (clobber (match_scratch:HI 0 \"=r\"))]\n+  \"ix86_match_ccmode (insn, CCNOmode)\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n+  \"or{w}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"HI\")])\n+\n (define_expand \"iorqi3\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n \t(ior:QI (match_operand:QI 1 \"nonimmediate_operand\" \"\")\n@@ -5556,6 +5769,19 @@\n   \"or{b}\\\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"QI\")])\n+\n+(define_insn \"*iorqi_3\"\n+  [(set (reg 17)\n+\t(compare (ior:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t\t (match_operand:QI 2 \"general_operand\" \"qim\"))\n+\t\t (const_int 0)))\n+   (clobber (match_scratch:QI 0 \"=r\"))]\n+  \"ix86_match_ccmode (insn, CCNOmode)\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n+  \"or{b}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"QI\")])\n+\n \f\n ;; Logical XOR instructions\n \n@@ -5593,6 +5819,18 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn \"*xorsi_3\"\n+  [(set (reg 17)\n+\t(compare (xor:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"rim\"))\n+\t\t (const_int 0)))\n+   (clobber (match_scratch:SI 0 \"=r\"))]\n+  \"ix86_match_ccmode (insn, CCNOmode)\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n+  \"xor{l}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_expand \"xorhi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n \t(xor:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\")\n@@ -5624,6 +5862,18 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"HI\")])\n \n+(define_insn \"*xorhi_3\"\n+  [(set (reg 17)\n+\t(compare (xor:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t\t (match_operand:HI 2 \"general_operand\" \"rim\"))\n+\t\t (const_int 0)))\n+   (clobber (match_scratch:HI 0 \"=r\"))]\n+  \"ix86_match_ccmode (insn, CCNOmode)\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n+  \"xor{w}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"HI\")])\n+\n (define_expand \"xorqi3\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n \t(xor:QI (match_operand:QI 1 \"nonimmediate_operand\" \"\")\n@@ -5678,6 +5928,19 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"QI\")])\n \n+(define_insn \"*xorqi_cc_2\"\n+  [(set (reg 17)\n+\t(compare\n+\t  (xor:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t  (match_operand:QI 2 \"general_operand\" \"qim\"))\n+\t  (const_int 0)))\n+   (clobber (match_scratch:QI 0 \"=r\"))]\n+  \"ix86_match_ccmode (insn, CCNOmode)\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n+  \"xor{b}\\\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"QI\")])\n+\n (define_insn \"xorqi_cc_ext_1\"\n   [(set (reg:CCNO 17)\n \t(compare:CCNO"}, {"sha": "c8cd1933d6692604632800e416057e1e3bb0e9f8", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90ffc8d2c830e45f8e7a17fe66355e7d7865fd8/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90ffc8d2c830e45f8e7a17fe66355e7d7865fd8/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=d90ffc8d2c830e45f8e7a17fe66355e7d7865fd8", "patch": "@@ -5212,18 +5212,15 @@ write_attr_case (attr, av, write_case_lines, prefix, suffix, indent,\n   must_extract = must_constrain = address_used = 0;\n   walk_attr_value (av->value);\n \n-  if (must_extract)\n+  if (must_constrain)\n     {\n       write_indent (indent + 2);\n-      printf (\"extract_insn (insn);\\n\");\n+      printf (\"extract_constrain_insn_cached (insn);\\n\");\n     }\n-\n-  if (must_constrain)\n+  else if (must_extract)\n     {\n       write_indent (indent + 2);\n-      printf (\"if (! constrain_operands (reload_completed))\\n\");\n-      write_indent (indent + 2);\n-      printf (\"  fatal_insn_not_found (insn);\\n\");\n+      printf (\"extract_insn_cached (insn);\\n\");\n     }\n \n   write_attr_set (attr, indent + 2, av->value, prefix, suffix,"}, {"sha": "b512181e10db31fc29131e4a6411a12636f48adc", "filename": "gcc/genrecog.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90ffc8d2c830e45f8e7a17fe66355e7d7865fd8/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90ffc8d2c830e45f8e7a17fe66355e7d7865fd8/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=d90ffc8d2c830e45f8e7a17fe66355e7d7865fd8", "patch": "@@ -2189,6 +2189,9 @@ peephole2%s (x0, insn, _pmatch_len)\\n\\\n \n   printf (\"  %s tem ATTRIBUTE_UNUSED;\\n\", IS_SPLIT (type) ? \"rtx\" : \"int\");\n \n+  if (!subfunction)\n+    printf (\"  recog_data.insn = NULL_RTX;\\n\");\n+\n   if (head->first)\n     write_tree (head, \"\", type, 1);\n   else"}, {"sha": "f1d5dee6c4684a252d03c065a5772a9d6ac543c3", "filename": "gcc/recog.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90ffc8d2c830e45f8e7a17fe66355e7d7865fd8/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90ffc8d2c830e45f8e7a17fe66355e7d7865fd8/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=d90ffc8d2c830e45f8e7a17fe66355e7d7865fd8", "patch": "@@ -2045,6 +2045,31 @@ adj_offsettable_operand (op, offset)\n   abort ();\n }\n \f\n+/* Like extract_insn, but save insn extracted and don't extract again, when\n+   called again for the same insn expecting that recog_data still contain the\n+   valid information.  This is used primary by gen_attr infrastructure that\n+   often does extract insn again and again.  */\n+void\n+extract_insn_cached (insn)\n+     rtx insn;\n+{\n+  if (recog_data.insn == insn && INSN_CODE (insn) >= 0)\n+    return;\n+  extract_insn (insn);\n+  recog_data.insn = insn;\n+}\n+/* Do cached extract_insn, constrain_operand and complain about failures.\n+   Used by insn_attrtab.  */\n+void\n+extract_constrain_insn_cached (insn)\n+     rtx insn;\n+{\n+  extract_insn_cached (insn);\n+  if (which_alternative == -1\n+      && !constrain_operands (reload_completed))\n+    fatal_insn_not_found (insn);\n+}\n+\f\n /* Analyze INSN and fill in recog_data.  */\n \n void\n@@ -2056,9 +2081,11 @@ extract_insn (insn)\n   int noperands;\n   rtx body = PATTERN (insn);\n \n+  recog_data.insn = NULL;\n   recog_data.n_operands = 0;\n   recog_data.n_alternatives = 0;\n   recog_data.n_dups = 0;\n+  which_alternative = -1;\n \n   switch (GET_CODE (body))\n     {\n@@ -2592,6 +2619,7 @@ constrain_operands (strict)\n       which_alternative++;\n     }\n \n+  which_alternative = -1;\n   /* If we are about to reject this, but we are not to test strictly,\n      try a very loose test.  Only return failure if it fails also.  */\n   if (strict == 0)"}, {"sha": "3328af6850a4025fe1d2242803d69a03d4f7089f", "filename": "gcc/recog.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90ffc8d2c830e45f8e7a17fe66355e7d7865fd8/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90ffc8d2c830e45f8e7a17fe66355e7d7865fd8/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=d90ffc8d2c830e45f8e7a17fe66355e7d7865fd8", "patch": "@@ -116,6 +116,8 @@ extern int recog\t\t\tPARAMS ((rtx, rtx, int *));\n extern void add_clobbers\t\tPARAMS ((rtx, int));\n extern void insn_extract\t\tPARAMS ((rtx));\n extern void extract_insn\t\tPARAMS ((rtx));\n+extern void extract_constrain_insn_cached PARAMS ((rtx));\n+extern void extract_insn_cached\t\tPARAMS ((rtx));\n extern void preprocess_constraints\tPARAMS ((void));\n extern rtx peep2_next_insn\t\tPARAMS ((int));\n extern int peep2_regno_dead_p\t\tPARAMS ((int, int));\n@@ -186,6 +188,9 @@ struct recog_data\n \n   /* The number of alternatives in the constraints for the insn.  */\n   char n_alternatives;\n+\n+  /* In case we are caching, hold insn data was generated for.  */\n+  rtx insn;\n };\n \n extern struct recog_data recog_data;"}]}