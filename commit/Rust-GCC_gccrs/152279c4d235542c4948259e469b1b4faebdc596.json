{"sha": "152279c4d235542c4948259e469b1b4faebdc596", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTUyMjc5YzRkMjM1NTQyYzQ5NDgyNTllNDY5YjFiNGZhZWJkYzU5Ng==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2006-05-29T13:47:00Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2006-05-29T13:47:00Z"}, "message": "tree-flow.h: Remove the prototype for add_type_alias.\n\n\t* tree-flow.h: Remove the prototype for add_type_alias.\n\t* tree-ssa-alias.c (add_type_alias): Remove.\n\nFrom-SVN: r114197", "tree": {"sha": "3034b741e0871fd9fe68745e08331b7ac25d6e62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3034b741e0871fd9fe68745e08331b7ac25d6e62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/152279c4d235542c4948259e469b1b4faebdc596", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/152279c4d235542c4948259e469b1b4faebdc596", "html_url": "https://github.com/Rust-GCC/gccrs/commit/152279c4d235542c4948259e469b1b4faebdc596", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/152279c4d235542c4948259e469b1b4faebdc596/comments", "author": null, "committer": null, "parents": [{"sha": "a9488625976a5060016480c231f77ba8d4dfb651", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9488625976a5060016480c231f77ba8d4dfb651", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9488625976a5060016480c231f77ba8d4dfb651"}], "stats": {"total": 91, "additions": 3, "deletions": 88}, "files": [{"sha": "b74289ade6a238c81085d9145aa42246baa37b1e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152279c4d235542c4948259e469b1b4faebdc596/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152279c4d235542c4948259e469b1b4faebdc596/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=152279c4d235542c4948259e469b1b4faebdc596", "patch": "@@ -5,6 +5,9 @@\n \n \t* config/bfin/bfin.h (PARM_BOUNDRY, STACK_BOUNDRY): Remove.\n \n+\t* tree-flow.h: Remove the prototype for add_type_alias.\n+\t* tree-ssa-alias.c (add_type_alias): Remove.\n+\n 2006-05-28  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* cfgcleanup.c, cfgexpand.c, cgraphunit.c, config/arm/arm.c,"}, {"sha": "6a953ab723e5f3b212ca4f5f307b1fcca4fdee84", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152279c4d235542c4948259e469b1b4faebdc596/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152279c4d235542c4948259e469b1b4faebdc596/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=152279c4d235542c4948259e469b1b4faebdc596", "patch": "@@ -667,7 +667,6 @@ extern void debug_points_to_info_for (tree);\n extern bool may_be_aliased (tree);\n extern bool is_aliased_with (tree, tree);\n extern struct ptr_info_def *get_ptr_info (tree);\n-extern void add_type_alias (tree, tree);\n extern void new_type_alias (tree, tree);\n extern void count_uses_and_derefs (tree, tree, unsigned *, unsigned *, bool *);\n static inline subvar_t get_subvars_for_var (tree);"}, {"sha": "2da4e61d1a96c8f4ea864c543fd4c383f1a63ea6", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152279c4d235542c4948259e469b1b4faebdc596/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152279c4d235542c4948259e469b1b4faebdc596/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=152279c4d235542c4948259e469b1b4faebdc596", "patch": "@@ -2687,93 +2687,6 @@ is_aliased_with (tree tag, tree sym)\n }\n \n \n-/* Add VAR to the list of may-aliases of PTR's symbol tag.  If PTR\n-   doesn't already have a symbol tag, create one.  */\n-\n-void\n-add_type_alias (tree ptr, tree var)\n-{\n-  VEC(tree, gc) *aliases;\n-  tree tag, al;\n-  var_ann_t ann = var_ann (ptr);\n-  subvar_t svars;\n-  VEC (tree, heap) *varvec = NULL;  \n-  unsigned i;\n-\n-  if (ann->symbol_mem_tag == NULL_TREE)\n-    {\n-      tree q = NULL_TREE;\n-      tree tag_type = TREE_TYPE (TREE_TYPE (ptr));\n-      HOST_WIDE_INT tag_set = get_alias_set (tag_type);\n-      safe_referenced_var_iterator rvi;\n-\n-      /* PTR doesn't have a symbol tag, create a new one and add VAR to\n-\t the new tag's alias set.\n-\n-\t FIXME, This is slower than necessary.  We need to determine\n-\t whether there is another pointer Q with the same alias set as\n-\t PTR.  This could be sped up by having symbol tags associated\n-\t with types.  */\n-      FOR_EACH_REFERENCED_VAR_SAFE (q, varvec, rvi)\n-\t{\n-\t  if (POINTER_TYPE_P (TREE_TYPE (q))\n-\t      && tag_set == get_alias_set (TREE_TYPE (TREE_TYPE (q))))\n-\t    {\n-\t      /* Found another pointer Q with the same alias set as\n-\t\t the PTR's pointed-to type.  If Q has a symbol tag, use\n-\t\t it.  Otherwise, create a new memory tag for PTR.  */\n-\t      var_ann_t ann1 = var_ann (q);\n-\t      if (ann1->symbol_mem_tag)\n-\t\tann->symbol_mem_tag = ann1->symbol_mem_tag;\n-\t      else\n-\t\tann->symbol_mem_tag = create_memory_tag (tag_type, true);\n-\t      goto found_tag;\n-\t    }\n-\t}\n-\n-      /* Couldn't find any other pointer with a symbol tag we could use.\n-\t Create a new memory tag for PTR.  */\n-      ann->symbol_mem_tag = create_memory_tag (tag_type, true);\n-    }\n-\n-found_tag:\n-  /* If VAR is not already PTR's symbol tag, add it to the may-alias set\n-     for PTR's symbol tag.  */\n-  gcc_assert (!MTAG_P (var));\n-  tag = ann->symbol_mem_tag;\n-\n-  /* If VAR has subvars, add the subvars to the tag instead of the\n-     actual var.  */\n-  if (var_can_have_subvars (var)\n-      && (svars = get_subvars_for_var (var)))\n-    {\n-      subvar_t sv;      \n-      for (sv = svars; sv; sv = sv->next)\n-\tadd_may_alias (tag, sv->var);\n-    }\n-  else\n-    add_may_alias (tag, var);\n-\n-  /* TAG and its set of aliases need to be marked for renaming.  */\n-  mark_sym_for_renaming (tag);\n-  if ((aliases = var_ann (tag)->may_aliases) != NULL)\n-    {\n-      for (i = 0; VEC_iterate (tree, aliases, i, al); i++)\n-\tmark_sym_for_renaming (al);\n-    }\n-\n-  /* If we had grouped aliases, VAR may have aliases of its own.  Mark\n-     them for renaming as well.  Other statements referencing the\n-     aliases of VAR will need to be updated.  */\n-  if ((aliases = var_ann (var)->may_aliases) != NULL)\n-    {\n-      for (i = 0; VEC_iterate (tree, aliases, i, al); i++)\n-\tmark_sym_for_renaming (al);\n-    }\n-  VEC_free (tree, heap, varvec);\n-}\n-\n-\n /* Create a new symbol tag for PTR.  Construct the may-alias list of this type\n    tag so that it has the aliasing of VAR. \n "}]}