{"sha": "b4117c306105c7e3279bbbabab1dd361a3b35b62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQxMTdjMzA2MTA1YzdlMzI3OWJiYmFiYWIxZGQzNjFhM2IzNWI2Mg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-05-18T01:26:21Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-05-18T01:26:21Z"}, "message": "Makefile.def, [...]: Remove all mention of libf2c.\n\ntop:\n\t* Makefile.def, Makefile.tpl, configure.in: Remove all mention\n\tof libf2c.\n\t* configure, Makefile.in: Regenerate.\ncontrib:\n\t* gcc_update: Remove gcc/f/intdoc.texi and all libf2c files\n\tfrom list of files to be touched.\n\t* convert_to_f2c, convert_to_g2c, download_f2c: Delete.\ngcc:\n\t* f: Entire directory removed\n\n\t* c-common.h (CTI_G77_INTEGER_TYPE, CTI_G77_UINTEGER_TYPE)\n\t(CTI_G77_LONGINT_TYPE, CTI_G77_ULONGINT_TYPE)\n\t(g77_integer_type_node, g77_uinteger_type_node)\n\t(g77_longint_type_node, or g77_ulongint_type_node): Delete.\n\t* c-common.c (c_common_nodes_and_builtins): Do not initialize\n\tthe above set of variables.\n\n\t* config/i386/uwin.h: No need to define WIN32_UWIN_TARGET.\n\t* doc/invoke.texi, doc/standards.texi: Remove cross-references\n\tto g77 manual.\ngcc/po:\n\t* exgettext (spec_error_string): Do not scan beyond the end of\n\tthe string for a close brace.  Do not bail out at the first\n\tincidence of %%e.\n\t* gcc.pot: Regenerate.\n\nFrom-SVN: r81967", "tree": {"sha": "50453d3a085029670f5bc4d0cbb0ea22590d6769", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50453d3a085029670f5bc4d0cbb0ea22590d6769"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4117c306105c7e3279bbbabab1dd361a3b35b62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4117c306105c7e3279bbbabab1dd361a3b35b62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4117c306105c7e3279bbbabab1dd361a3b35b62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4117c306105c7e3279bbbabab1dd361a3b35b62/comments", "author": null, "committer": null, "parents": [{"sha": "54b4ba60f20d3870a79467caa3b604971225d388", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54b4ba60f20d3870a79467caa3b604971225d388", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54b4ba60f20d3870a79467caa3b604971225d388"}], "stats": {"total": 175380, "additions": 820, "deletions": 174560}, "files": [{"sha": "3d4698cedf9525abc3cb962f22879974a3545c34", "filename": "ChangeLog", "status": "modified", "additions": 40, "deletions": 34, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4117c306105c7e3279bbbabab1dd361a3b35b62/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4117c306105c7e3279bbbabab1dd361a3b35b62/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=b4117c306105c7e3279bbbabab1dd361a3b35b62", "patch": "@@ -1,3 +1,9 @@\n+2004-05-17  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* Makefile.def, Makefile.tpl, configure.in: Remove all mention\n+\tof libf2c.\n+\t* configure, Makefile.in: Regenerate.\n+\n 2004-05-13  Tobias Schl\u00fcter  <tobi@gcc.gnu.org>\n \n \t* MAINTAINERS (Write After Approval): Add myself.\n@@ -29,15 +35,15 @@\n \n 2004-05-04  Vladimir Makarov  <vmakarov@redhat.com>\n \n-        * MAINTAINERS (Various Maintainers): Add myself.\n+\t* MAINTAINERS (Various Maintainers): Add myself.\n \n 2004-04-30  Brian Ford  <ford@vss.fsi.com>\n \n-        * MAINTAINERS (Write After Approval): Add myself.\n+\t* MAINTAINERS (Write After Approval): Add myself.\n \n 2004-04-29  Uros Bizjak  <uros@kss-loka.si>\n \n-        * MAINTAINERS (Write After Approval): Add myself.\n+\t* MAINTAINERS (Write After Approval): Add myself.\n \n 2004-04-28  Paolo Bonzini  <bonzini@gnu.org>\n \n@@ -79,11 +85,11 @@\n \n 2004-04-26  Paolo Bonzini  <bonzini@gnu.org>\n \n-        * configure.in: Invoke ACX_PROG_CMP_IGNORE_INITIAL.\n-        * configure: Regenerate.\n-        * config/acx.m4: Mutuate ACX_PROG_CMP_IGNORE_INITIAL from gcc.\n-        * gcc/Makefile.tpl (compare): Use the result of the test.\n-        * gcc/Makefile.in: Regenerate.\n+\t* configure.in: Invoke ACX_PROG_CMP_IGNORE_INITIAL.\n+\t* configure: Regenerate.\n+\t* config/acx.m4: Mutuate ACX_PROG_CMP_IGNORE_INITIAL from gcc.\n+\t* gcc/Makefile.tpl (compare): Use the result of the test.\n+\t* gcc/Makefile.in: Regenerate.\n \n 2004-04-23  Paolo Bonzini  <bonzini@gnu.org>\n \n@@ -96,7 +102,7 @@\n 2004-04-23  Laurent GUERBY <laurent@guerby.net>\n \n \t* MAINTAINERS: Update my email address.\n-\t\n+\n 2004-04-19  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* configure.in (mips*-*-irix5*): Enable ld.\n@@ -115,7 +121,7 @@\n \n 2004-04-12  Michael Chastain  <mec.gnu@mindspring.com>\n \n-        * MAINTAINERS: Add myself to write-after-approval.\n+\t* MAINTAINERS: Add myself to write-after-approval.\n \n 2004-04-09  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n@@ -139,17 +145,17 @@\n \n 2004-04-06  David Edelsohn  <edelsohn@gnu.org>\n \n-        * configure.in (powerpc-*-aix*): Remove target-libada from noconfigdirs.\n-        (rs6000-*-aix*): Same.\n-        * configure: Regenerate.\n+\t* configure.in (powerpc-*-aix*): Remove target-libada from noconfigdirs.\n+\t(rs6000-*-aix*): Same.\n+\t* configure: Regenerate.\n \n 2004-04-05  Ranjit Mathew  <rmathew@hotmail.com>\n-                                                                                \n-        * MAINTAINERS: Add myself to write-after-approval.\n+\n+\t* MAINTAINERS: Add myself to write-after-approval.\n \n 2004-04-03  Bud Davis  <bdavis9659@comcast.net>\n-                                                                                \n-        * MAINTAINERS: Add myself to write-after-approval.\n+\n+\t* MAINTAINERS: Add myself to write-after-approval.\n \n 2004-03-24  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n@@ -209,10 +215,10 @@\n \t* Makefile.in: Regenerate.\n \n 2004-03-15  Paolo Bonzini  <bonzini@gnu.org>\n-            Nathanael Nerode  <neroden@gcc.gnu.org>\n+\t    Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* configure.in (DEFAULT_YACC, DEFAULT_M4, DEFAULT_LEX):\n-        Set with AC_CHECK_PROGS.\n+\tSet with AC_CHECK_PROGS.\n \t* configure.in: Fix comment typo from last patch.\n \t* configure: Regenerate.\n \n@@ -224,14 +230,14 @@\n \t* configure: Regenerate.\n \n 2004-03-12  Eric Botcazou  <ebotcazou@gcc.gnu.org>\n-            Paolo Bonzini  <bonzini@gnu.org>\n+\t    Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR bootstrap/14522\n \t* configure.in: Cope with shells that do not support unquoted ^\n \t* configure: Regenerate.\n \n 2004-03-11  Eric Botcazou  <ebotcazou@gcc.gnu.org>\n-            Paolo Bonzini  <bonzini@gnu.org>\n+\t    Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR bootstrap/14522\n \t* configure.in: Cope with shells that do not support nesting\n@@ -280,7 +286,7 @@\n 2004-03-01  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* MAINTAINERS: Add myself to write-after-approval.\n-\t\n+\n 2004-02-28  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \tPR bootstrap/7087\n@@ -332,7 +338,7 @@\n 2004-02-12  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* MAINTAINERS: Remove myself.\n-\t\n+\n 2004-02-11  David Edelsohn  <edelsohn@gnu.org>\n \n \t* configure.in (powerpc-*-aix*): Add target-libada to noconfigdirs.\n@@ -348,15 +354,15 @@\n \t    Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \tPR ada/6637, PR ada/5911\n-        Merge with libada-branch:\n+\tMerge with libada-branch:\n \t* configure.in, Makefile.tpl, Makefile.def: Add target-libada,\n \twith appropriate dependencies. Add --enable-libada configure switch.\n \t* configure, Makefile.in: Regenerate.\n \n 2004-02-09  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* MAINTAINERS: Add myself to write-after-approval.\n-\t\n+\n 2004-02-05  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* configure.in: Don't pass --with-stabs on IRIX 5 either.\n@@ -387,15 +393,15 @@\n 2004-01-20  Caroline Tice  <ctice@apple.com>\n \n \t* MAINTAINERS: Add myself to write-after-approval.\n-\t\n+\n 2004-01-19  Paolo Carlini  <pcarlini@suse.de>\n \n \t* MAINTAINERS: Update my email address.\n \n 2004-01-18  James A. Morrison  <ja2morri@uwaterloo.ca>\n \n \t* MAINTAINERS: Add myself to write-after-approval.\n-\t\n+\n 2004-01-17  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \t* MAINTAINERS: Remove entries without email address.\n@@ -465,7 +471,7 @@\n \t* MAINTAINERS: Remove the mn10200 maintainer.\n \n 2003-12-21  Bernardo Innocenti  <bernie@develer.com>\n- \n+\n  \t* configure.in (*-*-uclinux): Exclude newlib, libgloss and rda.\n  \t* configure: Regenerated.\n \n@@ -514,8 +520,8 @@\n \n 2003-11-14  Arnaud Charlet  <charlet@act-europe.fr>\n \n-        * Makefile.tpl (EXTRA_GCC_FLAGS): Pass BOOT_ADAFLAGS.\n-        * Makefile.in: Regenerate.\n+\t* Makefile.tpl (EXTRA_GCC_FLAGS): Pass BOOT_ADAFLAGS.\n+\t* Makefile.in: Regenerate.\n \n 2003-11-03  Ulrich Weigand  <uweigand@de.ibm.com>\n \n@@ -663,7 +669,7 @@\n 2003-09-04  Robert Millan  <robertmh@gnu.org>\n \n \t* configure.in: Match GNU/KFreeBSD with new kfreebsd*-gnu triplet.\n-\t\n+\n 2003-09-02  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* configure.in: Ensure arguments to sed are properly spaced.\n@@ -702,7 +708,7 @@\n \t* configure.in: When testing with_libs and with_headers, treat\n \t'no' as unset.  Based on a patch by Dan Kegel <dank@kegel.com>.\n \t* configure: Regenerate.\n-\t\n+\n \t* configure.in (TOPLEVEL_CONFIGURE_ARGUMENTS): Quote properly for\n \tmake, shell, etc.\n \t(baseargs): Likewise.\n@@ -721,8 +727,8 @@\n \n \t* config-ml.in, symlink-tree: Add license.\n \n-2003-08-03  Richard Stallman  <rms@gnu.org> \n-            Eben Moglen  <moglen@columbia.edu>\n+2003-08-03  Richard Stallman  <rms@gnu.org>\n+\t    Eben Moglen  <moglen@columbia.edu>\n \n \t* README.SCO: New file.\n "}, {"sha": "fa51090d020615042f93fc173884fd7b26f1ecf3", "filename": "Makefile.def", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4117c306105c7e3279bbbabab1dd361a3b35b62/Makefile.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4117c306105c7e3279bbbabab1dd361a3b35b62/Makefile.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.def?ref=b4117c306105c7e3279bbbabab1dd361a3b35b62", "patch": "@@ -101,7 +101,6 @@ host_modules= { module= utils; no_check=true; };\n target_modules = { module= libstdc++-v3; raw_cxx=true; };\n target_modules = { module= libmudflap; };\n target_modules = { module= newlib; };\n-target_modules = { module= libf2c; };\n target_modules = { module= libgfortran; };\n target_modules = { module= libobjc; };\n target_modules = { module= libtermcap; no_check=true; stage=true;"}, {"sha": "f024943dca2ae1752aba2dcb034b417f86276f04", "filename": "Makefile.in", "status": "modified", "additions": 0, "deletions": 294, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4117c306105c7e3279bbbabab1dd361a3b35b62/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4117c306105c7e3279bbbabab1dd361a3b35b62/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=b4117c306105c7e3279bbbabab1dd361a3b35b62", "patch": "@@ -612,7 +612,6 @@ configure-target:  \\\n     maybe-configure-target-libstdc++-v3 \\\n     maybe-configure-target-libmudflap \\\n     maybe-configure-target-newlib \\\n-    maybe-configure-target-libf2c \\\n     maybe-configure-target-libgfortran \\\n     maybe-configure-target-libobjc \\\n     maybe-configure-target-libtermcap \\\n@@ -705,7 +704,6 @@ all-target:  \\\n     maybe-all-target-libstdc++-v3 \\\n     maybe-all-target-libmudflap \\\n     maybe-all-target-newlib \\\n-    maybe-all-target-libf2c \\\n     maybe-all-target-libgfortran \\\n     maybe-all-target-libobjc \\\n     maybe-all-target-libtermcap \\\n@@ -803,7 +801,6 @@ info-target:  \\\n     maybe-info-target-libstdc++-v3 \\\n     maybe-info-target-libmudflap \\\n     maybe-info-target-newlib \\\n-    maybe-info-target-libf2c \\\n     maybe-info-target-libgfortran \\\n     maybe-info-target-libobjc \\\n     maybe-info-target-libtermcap \\\n@@ -896,7 +893,6 @@ dvi-target:  \\\n     maybe-dvi-target-libstdc++-v3 \\\n     maybe-dvi-target-libmudflap \\\n     maybe-dvi-target-newlib \\\n-    maybe-dvi-target-libf2c \\\n     maybe-dvi-target-libgfortran \\\n     maybe-dvi-target-libobjc \\\n     maybe-dvi-target-libtermcap \\\n@@ -989,7 +985,6 @@ TAGS-target:  \\\n     maybe-TAGS-target-libstdc++-v3 \\\n     maybe-TAGS-target-libmudflap \\\n     maybe-TAGS-target-newlib \\\n-    maybe-TAGS-target-libf2c \\\n     maybe-TAGS-target-libgfortran \\\n     maybe-TAGS-target-libobjc \\\n     maybe-TAGS-target-libtermcap \\\n@@ -1082,7 +1077,6 @@ install-info-target:  \\\n     maybe-install-info-target-libstdc++-v3 \\\n     maybe-install-info-target-libmudflap \\\n     maybe-install-info-target-newlib \\\n-    maybe-install-info-target-libf2c \\\n     maybe-install-info-target-libgfortran \\\n     maybe-install-info-target-libobjc \\\n     maybe-install-info-target-libtermcap \\\n@@ -1175,7 +1169,6 @@ installcheck-target:  \\\n     maybe-installcheck-target-libstdc++-v3 \\\n     maybe-installcheck-target-libmudflap \\\n     maybe-installcheck-target-newlib \\\n-    maybe-installcheck-target-libf2c \\\n     maybe-installcheck-target-libgfortran \\\n     maybe-installcheck-target-libobjc \\\n     maybe-installcheck-target-libtermcap \\\n@@ -1268,7 +1261,6 @@ mostlyclean-target:  \\\n     maybe-mostlyclean-target-libstdc++-v3 \\\n     maybe-mostlyclean-target-libmudflap \\\n     maybe-mostlyclean-target-newlib \\\n-    maybe-mostlyclean-target-libf2c \\\n     maybe-mostlyclean-target-libgfortran \\\n     maybe-mostlyclean-target-libobjc \\\n     maybe-mostlyclean-target-libtermcap \\\n@@ -1361,7 +1353,6 @@ clean-target:  \\\n     maybe-clean-target-libstdc++-v3 \\\n     maybe-clean-target-libmudflap \\\n     maybe-clean-target-newlib \\\n-    maybe-clean-target-libf2c \\\n     maybe-clean-target-libgfortran \\\n     maybe-clean-target-libobjc \\\n     maybe-clean-target-libtermcap \\\n@@ -1454,7 +1445,6 @@ distclean-target:  \\\n     maybe-distclean-target-libstdc++-v3 \\\n     maybe-distclean-target-libmudflap \\\n     maybe-distclean-target-newlib \\\n-    maybe-distclean-target-libf2c \\\n     maybe-distclean-target-libgfortran \\\n     maybe-distclean-target-libobjc \\\n     maybe-distclean-target-libtermcap \\\n@@ -1547,7 +1537,6 @@ maintainer-clean-target:  \\\n     maybe-maintainer-clean-target-libstdc++-v3 \\\n     maybe-maintainer-clean-target-libmudflap \\\n     maybe-maintainer-clean-target-newlib \\\n-    maybe-maintainer-clean-target-libf2c \\\n     maybe-maintainer-clean-target-libgfortran \\\n     maybe-maintainer-clean-target-libobjc \\\n     maybe-maintainer-clean-target-libtermcap \\\n@@ -1694,7 +1683,6 @@ do-check: maybe-check-gcc  \\\n     maybe-check-target-libstdc++-v3 \\\n     maybe-check-target-libmudflap \\\n     maybe-check-target-newlib \\\n-    maybe-check-target-libf2c \\\n     maybe-check-target-libgfortran \\\n     maybe-check-target-libobjc \\\n     maybe-check-target-libtermcap \\\n@@ -1878,7 +1866,6 @@ install-target:  \\\n     maybe-install-target-libstdc++-v3 \\\n     maybe-install-target-libmudflap \\\n     maybe-install-target-newlib \\\n-    maybe-install-target-libf2c \\\n     maybe-install-target-libgfortran \\\n     maybe-install-target-libobjc \\\n     maybe-install-target-libtermcap \\\n@@ -20132,285 +20119,6 @@ maintainer-clean-target-newlib:\n \n \n \n-.PHONY: configure-target-libf2c maybe-configure-target-libf2c\n-maybe-configure-target-libf2c:\n-\n-# There's only one multilib.out.  Cleverer subdirs shouldn't need it copied.\n-$(TARGET_SUBDIR)/libf2c/multilib.out: multilib.out\n-\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libf2c ; \\\n-\trm -f $(TARGET_SUBDIR)/libf2c/Makefile || : ; \\\n-\tcp multilib.out $(TARGET_SUBDIR)/libf2c/multilib.out\n-\n-configure-target-libf2c: $(TARGET_SUBDIR)/libf2c/multilib.out\n-\t@test ! -f $(TARGET_SUBDIR)/libf2c/Makefile || exit 0; \\\n-\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libf2c ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\tAR=\"$(AR_FOR_TARGET)\"; export AR; \\\n-\tAS=\"$(AS_FOR_TARGET)\"; export AS; \\\n-\tCC=\"$(CC_FOR_TARGET)\"; export CC; \\\n-\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\"; export CFLAGS; \\\n-\tCONFIG_SHELL=\"$(SHELL)\"; export CONFIG_SHELL; \\\n-\tCPPFLAGS=\"$(CFLAGS_FOR_TARGET)\"; export CPPFLAGS; \\\n-\tCXX=\"$(CXX_FOR_TARGET)\"; export CXX; \\\n-\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n-\tGCJ=\"$(GCJ_FOR_TARGET)\"; export GCJ; \\\n-\tGFORTRAN=\"$(GFORTRAN_FOR_TARGET)\"; export GFORTRAN; \\\n-\tDLLTOOL=\"$(DLLTOOL_FOR_TARGET)\"; export DLLTOOL; \\\n-\tLD=\"$(LD_FOR_TARGET)\"; export LD; \\\n-\tLDFLAGS=\"$(LDFLAGS_FOR_TARGET)\"; export LDFLAGS; \\\n-\tNM=\"$(NM_FOR_TARGET)\"; export NM; \\\n-\tRANLIB=\"$(RANLIB_FOR_TARGET)\"; export RANLIB; \\\n-\tWINDRES=\"$(WINDRES_FOR_TARGET)\"; export WINDRES; \\\n-\techo Configuring in $(TARGET_SUBDIR)/libf2c; \\\n-\tcd \"$(TARGET_SUBDIR)/libf2c\" || exit 1; \\\n-\tcase $(srcdir) in \\\n-\t  /* | [A-Za-z]:[\\\\/]*) \\\n-\t    topdir=$(srcdir) ;; \\\n-\t  *) \\\n-\t    case \"$(TARGET_SUBDIR)\" in \\\n-\t      .) topdir=\"../$(srcdir)\" ;; \\\n-\t      *) topdir=\"../../$(srcdir)\" ;; \\\n-\t    esac ;; \\\n-\tesac; \\\n-\t  srcdiroption=\"--srcdir=$${topdir}/libf2c\"; \\\n-\t  libsrcdir=\"$$s/libf2c\"; \\\n-\trm -f no-such-file || : ; \\\n-\tCONFIG_SITE=no-such-file $(SHELL) $${libsrcdir}/configure \\\n-\t  $(TARGET_CONFIGARGS) $${srcdiroption} \\\n-\t  --with-target-subdir=\"$(TARGET_SUBDIR)\" \\\n-\t  || exit 1\n-\n-.PHONY: all-target-libf2c maybe-all-target-libf2c\n-maybe-all-target-libf2c:\n-all-target-libf2c: configure-target-libf2c\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\t(cd $(TARGET_SUBDIR)/libf2c && \\\n-\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  all)\n-\n-.PHONY: check-target-libf2c maybe-check-target-libf2c\n-maybe-check-target-libf2c:\n-\n-check-target-libf2c:\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\t(cd $(TARGET_SUBDIR)/libf2c && \\\n-\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  check)\n-\n-\n-.PHONY: install-target-libf2c maybe-install-target-libf2c\n-maybe-install-target-libf2c:\n-\n-install-target-libf2c: installdirs\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\t(cd $(TARGET_SUBDIR)/libf2c && \\\n-\t  $(MAKE) $(TARGET_FLAGS_TO_PASS) install)\n-\n-\n-# Other targets (info, dvi, etc.)\n-\n-.PHONY: maybe-info-target-libf2c info-target-libf2c\n-maybe-info-target-libf2c:\n-\n-info-target-libf2c: \\\n-    configure-target-libf2c \n-\t@[ -f $(TARGET_SUBDIR)/libf2c/Makefile ] || exit 0 ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\techo \"Doing info in $(TARGET_SUBDIR)/libf2c\" ; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libf2c && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n-\t          info) \\\n-\t  || exit 1\n-\n-\n-.PHONY: maybe-dvi-target-libf2c dvi-target-libf2c\n-maybe-dvi-target-libf2c:\n-\n-dvi-target-libf2c: \\\n-    configure-target-libf2c \n-\t@[ -f $(TARGET_SUBDIR)/libf2c/Makefile ] || exit 0 ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\techo \"Doing dvi in $(TARGET_SUBDIR)/libf2c\" ; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libf2c && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n-\t          dvi) \\\n-\t  || exit 1\n-\n-\n-.PHONY: maybe-TAGS-target-libf2c TAGS-target-libf2c\n-maybe-TAGS-target-libf2c:\n-\n-TAGS-target-libf2c: \\\n-    configure-target-libf2c \n-\t@[ -f $(TARGET_SUBDIR)/libf2c/Makefile ] || exit 0 ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\techo \"Doing TAGS in $(TARGET_SUBDIR)/libf2c\" ; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libf2c && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n-\t          TAGS) \\\n-\t  || exit 1\n-\n-\n-.PHONY: maybe-install-info-target-libf2c install-info-target-libf2c\n-maybe-install-info-target-libf2c:\n-\n-install-info-target-libf2c: \\\n-    configure-target-libf2c \\\n-    info-target-libf2c \n-\t@[ -f $(TARGET_SUBDIR)/libf2c/Makefile ] || exit 0 ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\techo \"Doing install-info in $(TARGET_SUBDIR)/libf2c\" ; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libf2c && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n-\t          install-info) \\\n-\t  || exit 1\n-\n-\n-.PHONY: maybe-installcheck-target-libf2c installcheck-target-libf2c\n-maybe-installcheck-target-libf2c:\n-\n-installcheck-target-libf2c: \\\n-    configure-target-libf2c \n-\t@[ -f $(TARGET_SUBDIR)/libf2c/Makefile ] || exit 0 ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\techo \"Doing installcheck in $(TARGET_SUBDIR)/libf2c\" ; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libf2c && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n-\t          installcheck) \\\n-\t  || exit 1\n-\n-\n-.PHONY: maybe-mostlyclean-target-libf2c mostlyclean-target-libf2c\n-maybe-mostlyclean-target-libf2c:\n-\n-mostlyclean-target-libf2c: \n-\t@[ -f $(TARGET_SUBDIR)/libf2c/Makefile ] || exit 0 ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\techo \"Doing mostlyclean in $(TARGET_SUBDIR)/libf2c\" ; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libf2c && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n-\t          mostlyclean) \\\n-\t  || exit 1\n-\n-\n-.PHONY: maybe-clean-target-libf2c clean-target-libf2c\n-maybe-clean-target-libf2c:\n-\n-clean-target-libf2c: \n-\t@[ -f $(TARGET_SUBDIR)/libf2c/Makefile ] || exit 0 ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\techo \"Doing clean in $(TARGET_SUBDIR)/libf2c\" ; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libf2c && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n-\t          clean) \\\n-\t  || exit 1\n-\n-\n-.PHONY: maybe-distclean-target-libf2c distclean-target-libf2c\n-maybe-distclean-target-libf2c:\n-\n-distclean-target-libf2c: \n-\t@[ -f $(TARGET_SUBDIR)/libf2c/Makefile ] || exit 0 ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\techo \"Doing distclean in $(TARGET_SUBDIR)/libf2c\" ; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libf2c && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n-\t          distclean) \\\n-\t  || exit 1\n-\n-\n-.PHONY: maybe-maintainer-clean-target-libf2c maintainer-clean-target-libf2c\n-maybe-maintainer-clean-target-libf2c:\n-\n-maintainer-clean-target-libf2c: \n-\t@[ -f $(TARGET_SUBDIR)/libf2c/Makefile ] || exit 0 ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(SET_LIB_PATH) \\\n-\techo \"Doing maintainer-clean in $(TARGET_SUBDIR)/libf2c\" ; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libf2c && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n-\t          maintainer-clean) \\\n-\t  || exit 1\n-\n-\n-\n .PHONY: configure-target-libgfortran maybe-configure-target-libgfortran\n maybe-configure-target-libgfortran:\n \n@@ -25368,8 +25076,6 @@ configure-target-boehm-gc: $(ALL_GCC_C) maybe-configure-target-qthreads\n configure-target-fastjar: maybe-configure-target-zlib\n all-target-fastjar: maybe-all-target-zlib maybe-all-target-libiberty\n configure-target-libada: $(ALL_GCC_C)\n-configure-target-libf2c: $(ALL_GCC_C)\n-all-target-libf2c: maybe-all-target-libiberty\n configure-target-libgfortran: $(ALL_GCC_C)\n configure-target-libffi: $(ALL_GCC_C) \n configure-target-libjava: $(ALL_GCC_C) maybe-configure-target-zlib maybe-configure-target-boehm-gc maybe-configure-target-qthreads maybe-configure-target-libffi"}, {"sha": "beed5825ab4135079bcbfe3add2716980f326365", "filename": "Makefile.tpl", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4117c306105c7e3279bbbabab1dd361a3b35b62/Makefile.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4117c306105c7e3279bbbabab1dd361a3b35b62/Makefile.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.tpl?ref=b4117c306105c7e3279bbbabab1dd361a3b35b62", "patch": "@@ -1686,8 +1686,6 @@ configure-target-boehm-gc: $(ALL_GCC_C) maybe-configure-target-qthreads\n configure-target-fastjar: maybe-configure-target-zlib\n all-target-fastjar: maybe-all-target-zlib maybe-all-target-libiberty\n configure-target-libada: $(ALL_GCC_C)\n-configure-target-libf2c: $(ALL_GCC_C)\n-all-target-libf2c: maybe-all-target-libiberty\n configure-target-libgfortran: $(ALL_GCC_C)\n configure-target-libffi: $(ALL_GCC_C) \n configure-target-libjava: $(ALL_GCC_C) maybe-configure-target-zlib maybe-configure-target-boehm-gc maybe-configure-target-qthreads maybe-configure-target-libffi"}, {"sha": "2bbcdca9457b4f6acca63edde6beeaca9d3d5a77", "filename": "configure", "status": "modified", "additions": 59, "deletions": 66, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4117c306105c7e3279bbbabab1dd361a3b35b62/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4117c306105c7e3279bbbabab1dd361a3b35b62/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=b4117c306105c7e3279bbbabab1dd361a3b35b62", "patch": "@@ -910,7 +910,6 @@ target_libraries=\"target-libiberty \\\n \t\ttarget-newlib \\\n \t\ttarget-libstdc++-v3 \\\n \t\ttarget-libmudflap \\\n-\t\ttarget-libf2c \\\n \t\ttarget-libgfortran \\\n \t\t${libgcj} \\\n \t\ttarget-libobjc \\\n@@ -1179,7 +1178,7 @@ case \"${target}\" in\n     ;;\n   *-*-kaos*)\n     # Remove unsupported stuff on all kaOS configurations.\n-    skipdirs=\"target-libiberty ${libgcj} target-libstdc++-v3 target-libf2c target-librx\"\n+    skipdirs=\"target-libiberty ${libgcj} target-libstdc++-v3 target-librx\"\n     skipdirs=\"$skipdirs target-libobjc target-examples target-groff target-gperf\"\n     skipdirs=\"$skipdirs zlib fastjar target-libjava target-boehm-gc target-zlib\"\n     noconfigdirs=\"$noconfigdirs target-libgloss\"\n@@ -1202,12 +1201,6 @@ case \"${target}\" in\n     ;;\n   *-*-rtems*)\n     noconfigdirs=\"$noconfigdirs target-libgloss ${libgcj}\"\n-    case ${target} in\n-\th8300*-*-* | h8500-*-*)\n-\t  noconfigdirs=\"$noconfigdirs target-libf2c\"\n-          ;;\n-        *) ;;\n-    esac\n     ;;\n   *-*-uclinux*)\n     noconfigdirs=\"$noconfigdirs target-newlib target-libgloss target-rda ${libgcj}\"\n@@ -1308,10 +1301,10 @@ case \"${target}\" in\n     noconfigdirs=\"$noconfigdirs ${libgcj}\"\n     ;;\n   h8300*-*-*)\n-    noconfigdirs=\"$noconfigdirs target-libgloss ${libgcj} target-libf2c\"\n+    noconfigdirs=\"$noconfigdirs target-libgloss ${libgcj}\"\n     ;;\n   h8500-*-*)\n-    noconfigdirs=\"$noconfigdirs target-libstdc++-v3 target-libgloss ${libgcj} target-libf2c\"\n+    noconfigdirs=\"$noconfigdirs target-libstdc++-v3 target-libgloss ${libgcj}\"\n     ;;\n   hppa*64*-*-linux* | parisc*64*-*-linux*)\n     # In this case, it's because the hppa64-linux target is for\n@@ -1901,7 +1894,7 @@ fi\n # Extract the first word of \"gcc\", so it can be a program name with args.\n set dummy gcc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1905: checking for $ac_word\" >&5\n+echo \"configure:1898: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1931,7 +1924,7 @@ if test -z \"$CC\"; then\n   # Extract the first word of \"cc\", so it can be a program name with args.\n set dummy cc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1935: checking for $ac_word\" >&5\n+echo \"configure:1928: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1982,7 +1975,7 @@ fi\n       # Extract the first word of \"cl\", so it can be a program name with args.\n set dummy cl; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1986: checking for $ac_word\" >&5\n+echo \"configure:1979: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2014,7 +2007,7 @@ fi\n fi\n \n echo $ac_n \"checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works\"\"... $ac_c\" 1>&6\n-echo \"configure:2018: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works\" >&5\n+echo \"configure:2011: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works\" >&5\n \n ac_ext=c\n # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.\n@@ -2025,12 +2018,12 @@ cross_compiling=$ac_cv_prog_cc_cross\n \n cat > conftest.$ac_ext << EOF\n \n-#line 2029 \"configure\"\n+#line 2022 \"configure\"\n #include \"confdefs.h\"\n \n main(){return(0);}\n EOF\n-if { (eval echo configure:2034: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2027: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   ac_cv_prog_cc_works=yes\n   # If we can't run a trivial program, we are probably using a cross compiler.\n   if (./conftest; exit) 2>/dev/null; then\n@@ -2056,12 +2049,12 @@ if test $ac_cv_prog_cc_works = no; then\n   { echo \"configure: error: installation or configuration problem: C compiler cannot create executables.\" 1>&2; exit 1; }\n fi\n echo $ac_n \"checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler\"\"... $ac_c\" 1>&6\n-echo \"configure:2060: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler\" >&5\n+echo \"configure:2053: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler\" >&5\n echo \"$ac_t\"\"$ac_cv_prog_cc_cross\" 1>&6\n cross_compiling=$ac_cv_prog_cc_cross\n \n echo $ac_n \"checking whether we are using GNU C\"\"... $ac_c\" 1>&6\n-echo \"configure:2065: checking whether we are using GNU C\" >&5\n+echo \"configure:2058: checking whether we are using GNU C\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gcc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2070,7 +2063,7 @@ else\n   yes;\n #endif\n EOF\n-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:2074: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:2067: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n   ac_cv_prog_gcc=yes\n else\n   ac_cv_prog_gcc=no\n@@ -2089,7 +2082,7 @@ ac_test_CFLAGS=\"${CFLAGS+set}\"\n ac_save_CFLAGS=\"$CFLAGS\"\n CFLAGS=\n echo $ac_n \"checking whether ${CC-cc} accepts -g\"\"... $ac_c\" 1>&6\n-echo \"configure:2093: checking whether ${CC-cc} accepts -g\" >&5\n+echo \"configure:2086: checking whether ${CC-cc} accepts -g\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_cc_g'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2125,7 +2118,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}gnatbind\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}gnatbind; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2129: checking for $ac_word\" >&5\n+echo \"configure:2122: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_GNATBIND'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2157,7 +2150,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"gnatbind\", so it can be a program name with args.\n set dummy gnatbind; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2161: checking for $ac_word\" >&5\n+echo \"configure:2154: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_GNATBIND'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2190,7 +2183,7 @@ fi\n fi\n \n echo $ac_n \"checking whether compiler driver understands Ada\"\"... $ac_c\" 1>&6\n-echo \"configure:2194: checking whether compiler driver understands Ada\" >&5\n+echo \"configure:2187: checking whether compiler driver understands Ada\" >&5\n if eval \"test \\\"`echo '$''{'acx_cv_cc_gcc_supports_ada'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2223,7 +2216,7 @@ else\n fi\n \n echo $ac_n \"checking how to compare bootstrapped objects\"\"... $ac_c\" 1>&6\n-echo \"configure:2227: checking how to compare bootstrapped objects\" >&5\n+echo \"configure:2220: checking how to compare bootstrapped objects\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_prog_cmp_skip'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2296,9 +2289,9 @@ saved_CFLAGS=\"$CFLAGS\"\n CFLAGS=\"$CFLAGS $gmpinc\"\n # Check GMP actually works\n echo $ac_n \"checking for correct version of gmp.h\"\"... $ac_c\" 1>&6\n-echo \"configure:2300: checking for correct version of gmp.h\" >&5\n+echo \"configure:2293: checking for correct version of gmp.h\" >&5\n cat > conftest.$ac_ext <<EOF\n-#line 2302 \"configure\"\n+#line 2295 \"configure\"\n #include \"confdefs.h\"\n #include \"gmp.h\"\n int main() {\n@@ -2309,7 +2302,7 @@ choke me\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2313: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:2306: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   echo \"$ac_t\"\"yes\" 1>&6\n else\n@@ -2322,19 +2315,19 @@ rm -f conftest*\n \n if test x\"$have_gmp\" = xyes; then\n   echo $ac_n \"checking for mpf_init in -lgmp\"\"... $ac_c\" 1>&6\n-echo \"configure:2326: checking for mpf_init in -lgmp\" >&5\n+echo \"configure:2319: checking for mpf_init in -lgmp\" >&5\n \n   saved_LIBS=\"$LIBS\"\n   LIBS=\"$LIBS $gmplibs\"\n   cat > conftest.$ac_ext <<EOF\n-#line 2331 \"configure\"\n+#line 2324 \"configure\"\n #include \"confdefs.h\"\n #include <gmp.h>\n int main() {\n mpf_t n; mpf_init(n);\n ; return 0; }\n EOF\n-if { (eval echo configure:2338: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2331: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   echo \"$ac_t\"\"yes\" 1>&6\n else\n@@ -2796,7 +2789,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2800: checking for $ac_word\" >&5\n+echo \"configure:2793: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_DEFAULT_YACC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2831,7 +2824,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2835: checking for $ac_word\" >&5\n+echo \"configure:2828: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_DEFAULT_M4'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2866,7 +2859,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2870: checking for $ac_word\" >&5\n+echo \"configure:2863: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_DEFAULT_LEX'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3444,7 +3437,7 @@ test -n \"$target_alias\" && ncn_target_tool_prefix=$target_alias-\n   # Extract the first word of \"${ncn_tool_prefix}ar\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}ar; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3448: checking for $ac_word\" >&5\n+echo \"configure:3441: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AR'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3477,7 +3470,7 @@ if test -z \"$ac_cv_prog_AR\" ; then\n     # Extract the first word of \"ar\", so it can be a program name with args.\n set dummy ar; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3481: checking for $ac_word\" >&5\n+echo \"configure:3474: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_AR'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3516,7 +3509,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}as\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}as; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3520: checking for $ac_word\" >&5\n+echo \"configure:3513: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AS'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3549,7 +3542,7 @@ if test -z \"$ac_cv_prog_AS\" ; then\n     # Extract the first word of \"as\", so it can be a program name with args.\n set dummy as; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3553: checking for $ac_word\" >&5\n+echo \"configure:3546: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_AS'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3588,7 +3581,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}dlltool\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}dlltool; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3592: checking for $ac_word\" >&5\n+echo \"configure:3585: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_DLLTOOL'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3621,7 +3614,7 @@ if test -z \"$ac_cv_prog_DLLTOOL\" ; then\n     # Extract the first word of \"dlltool\", so it can be a program name with args.\n set dummy dlltool; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3625: checking for $ac_word\" >&5\n+echo \"configure:3618: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_DLLTOOL'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3660,7 +3653,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}ld\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}ld; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3664: checking for $ac_word\" >&5\n+echo \"configure:3657: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_LD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3693,7 +3686,7 @@ if test -z \"$ac_cv_prog_LD\" ; then\n     # Extract the first word of \"ld\", so it can be a program name with args.\n set dummy ld; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3697: checking for $ac_word\" >&5\n+echo \"configure:3690: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_LD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3732,7 +3725,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}nm\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}nm; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3736: checking for $ac_word\" >&5\n+echo \"configure:3729: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_NM'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3765,7 +3758,7 @@ if test -z \"$ac_cv_prog_NM\" ; then\n     # Extract the first word of \"nm\", so it can be a program name with args.\n set dummy nm; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3769: checking for $ac_word\" >&5\n+echo \"configure:3762: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_NM'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3804,7 +3797,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}ranlib\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3808: checking for $ac_word\" >&5\n+echo \"configure:3801: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3837,7 +3830,7 @@ if test -z \"$ac_cv_prog_RANLIB\" ; then\n     # Extract the first word of \"ranlib\", so it can be a program name with args.\n set dummy ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3841: checking for $ac_word\" >&5\n+echo \"configure:3834: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3876,7 +3869,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}windres\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}windres; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3880: checking for $ac_word\" >&5\n+echo \"configure:3873: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_WINDRES'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3909,7 +3902,7 @@ if test -z \"$ac_cv_prog_WINDRES\" ; then\n     # Extract the first word of \"windres\", so it can be a program name with args.\n set dummy windres; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3913: checking for $ac_word\" >&5\n+echo \"configure:3906: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_WINDRES'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3948,7 +3941,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}objcopy\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}objcopy; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3952: checking for $ac_word\" >&5\n+echo \"configure:3945: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_OBJCOPY'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3981,7 +3974,7 @@ if test -z \"$ac_cv_prog_OBJCOPY\" ; then\n     # Extract the first word of \"objcopy\", so it can be a program name with args.\n set dummy objcopy; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3985: checking for $ac_word\" >&5\n+echo \"configure:3978: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_OBJCOPY'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4020,7 +4013,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}objdump\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}objdump; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4024: checking for $ac_word\" >&5\n+echo \"configure:4017: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_OBJDUMP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4053,7 +4046,7 @@ if test -z \"$ac_cv_prog_OBJDUMP\" ; then\n     # Extract the first word of \"objdump\", so it can be a program name with args.\n set dummy objdump; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4057: checking for $ac_word\" >&5\n+echo \"configure:4050: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_OBJDUMP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4102,7 +4095,7 @@ fi\n   # Extract the first word of \"${ncn_target_tool_prefix}ar\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}ar; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4106: checking for $ac_word\" >&5\n+echo \"configure:4099: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_AR_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4135,7 +4128,7 @@ if test -z \"$ac_cv_prog_CONFIGURED_AR_FOR_TARGET\" ; then\n     # Extract the first word of \"ar\", so it can be a program name with args.\n set dummy ar; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4139: checking for $ac_word\" >&5\n+echo \"configure:4132: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_CONFIGURED_AR_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4174,7 +4167,7 @@ fi\n   # Extract the first word of \"${ncn_target_tool_prefix}as\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}as; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4178: checking for $ac_word\" >&5\n+echo \"configure:4171: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_AS_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4207,7 +4200,7 @@ if test -z \"$ac_cv_prog_CONFIGURED_AS_FOR_TARGET\" ; then\n     # Extract the first word of \"as\", so it can be a program name with args.\n set dummy as; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4211: checking for $ac_word\" >&5\n+echo \"configure:4204: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_CONFIGURED_AS_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4246,7 +4239,7 @@ fi\n   # Extract the first word of \"${ncn_target_tool_prefix}dlltool\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}dlltool; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4250: checking for $ac_word\" >&5\n+echo \"configure:4243: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_DLLTOOL_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4279,7 +4272,7 @@ if test -z \"$ac_cv_prog_CONFIGURED_DLLTOOL_FOR_TARGET\" ; then\n     # Extract the first word of \"dlltool\", so it can be a program name with args.\n set dummy dlltool; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4283: checking for $ac_word\" >&5\n+echo \"configure:4276: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_CONFIGURED_DLLTOOL_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4318,7 +4311,7 @@ fi\n   # Extract the first word of \"${ncn_target_tool_prefix}ld\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}ld; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4322: checking for $ac_word\" >&5\n+echo \"configure:4315: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_LD_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4351,7 +4344,7 @@ if test -z \"$ac_cv_prog_CONFIGURED_LD_FOR_TARGET\" ; then\n     # Extract the first word of \"ld\", so it can be a program name with args.\n set dummy ld; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4355: checking for $ac_word\" >&5\n+echo \"configure:4348: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_CONFIGURED_LD_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4390,7 +4383,7 @@ fi\n   # Extract the first word of \"${ncn_target_tool_prefix}nm\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}nm; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4394: checking for $ac_word\" >&5\n+echo \"configure:4387: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_NM_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4423,7 +4416,7 @@ if test -z \"$ac_cv_prog_CONFIGURED_NM_FOR_TARGET\" ; then\n     # Extract the first word of \"nm\", so it can be a program name with args.\n set dummy nm; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4427: checking for $ac_word\" >&5\n+echo \"configure:4420: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_CONFIGURED_NM_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4462,7 +4455,7 @@ fi\n   # Extract the first word of \"${ncn_target_tool_prefix}ranlib\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4466: checking for $ac_word\" >&5\n+echo \"configure:4459: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_RANLIB_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4495,7 +4488,7 @@ if test -z \"$ac_cv_prog_CONFIGURED_RANLIB_FOR_TARGET\" ; then\n     # Extract the first word of \"ranlib\", so it can be a program name with args.\n set dummy ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4499: checking for $ac_word\" >&5\n+echo \"configure:4492: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_CONFIGURED_RANLIB_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4534,7 +4527,7 @@ fi\n   # Extract the first word of \"${ncn_target_tool_prefix}windres\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}windres; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4538: checking for $ac_word\" >&5\n+echo \"configure:4531: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_WINDRES_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4567,7 +4560,7 @@ if test -z \"$ac_cv_prog_CONFIGURED_WINDRES_FOR_TARGET\" ; then\n     # Extract the first word of \"windres\", so it can be a program name with args.\n set dummy windres; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4571: checking for $ac_word\" >&5\n+echo \"configure:4564: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_CONFIGURED_WINDRES_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4652,7 +4645,7 @@ RANLIB_FOR_TARGET=${RANLIB_FOR_TARGET}${extra_ranlibflags_for_target}\n NM_FOR_TARGET=${NM_FOR_TARGET}${extra_nmflags_for_target}\n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:4656: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:4649: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\""}, {"sha": "1b60f7d49db09d06a005e2320a92fec1e77ecbb5", "filename": "configure.in", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4117c306105c7e3279bbbabab1dd361a3b35b62/configure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4117c306105c7e3279bbbabab1dd361a3b35b62/configure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.in?ref=b4117c306105c7e3279bbbabab1dd361a3b35b62", "patch": "@@ -150,7 +150,6 @@ target_libraries=\"target-libiberty \\\n \t\ttarget-newlib \\\n \t\ttarget-libstdc++-v3 \\\n \t\ttarget-libmudflap \\\n-\t\ttarget-libf2c \\\n \t\ttarget-libgfortran \\\n \t\t${libgcj} \\\n \t\ttarget-libobjc \\\n@@ -390,7 +389,7 @@ case \"${target}\" in\n     ;;\n   *-*-kaos*)\n     # Remove unsupported stuff on all kaOS configurations.\n-    skipdirs=\"target-libiberty ${libgcj} target-libstdc++-v3 target-libf2c target-librx\"\n+    skipdirs=\"target-libiberty ${libgcj} target-libstdc++-v3 target-librx\"\n     skipdirs=\"$skipdirs target-libobjc target-examples target-groff target-gperf\"\n     skipdirs=\"$skipdirs zlib fastjar target-libjava target-boehm-gc target-zlib\"\n     noconfigdirs=\"$noconfigdirs target-libgloss\"\n@@ -413,12 +412,6 @@ case \"${target}\" in\n     ;;\n   *-*-rtems*)\n     noconfigdirs=\"$noconfigdirs target-libgloss ${libgcj}\"\n-    case ${target} in\n-\th8300*-*-* | h8500-*-*)\n-\t  noconfigdirs=\"$noconfigdirs target-libf2c\"\n-          ;;\n-        *) ;;\n-    esac\n     ;;\n   *-*-uclinux*)\n     noconfigdirs=\"$noconfigdirs target-newlib target-libgloss target-rda ${libgcj}\"\n@@ -519,10 +512,10 @@ case \"${target}\" in\n     noconfigdirs=\"$noconfigdirs ${libgcj}\"\n     ;;\n   h8300*-*-*)\n-    noconfigdirs=\"$noconfigdirs target-libgloss ${libgcj} target-libf2c\"\n+    noconfigdirs=\"$noconfigdirs target-libgloss ${libgcj}\"\n     ;;\n   h8500-*-*)\n-    noconfigdirs=\"$noconfigdirs target-libstdc++-v3 target-libgloss ${libgcj} target-libf2c\"\n+    noconfigdirs=\"$noconfigdirs target-libstdc++-v3 target-libgloss ${libgcj}\"\n     ;;\n   hppa*64*-*-linux* | parisc*64*-*-linux*)\n     # In this case, it's because the hppa64-linux target is for"}, {"sha": "ffeae8b7a4ae4abb7aa77f160cdf1bf2d0044f4b", "filename": "contrib/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4117c306105c7e3279bbbabab1dd361a3b35b62/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4117c306105c7e3279bbbabab1dd361a3b35b62/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=b4117c306105c7e3279bbbabab1dd361a3b35b62", "patch": "@@ -1,3 +1,9 @@\n+2004-05-17  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* gcc_update: Remove gcc/f/intdoc.texi and all libf2c files\n+\tfrom list of files to be touched.\n+\t* convert_to_f2c, convert_to_g2c, download_f2c: Delete.\n+\n 2004-05-15  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* gennews: Update for GCC 3.4.\n@@ -14,7 +20,7 @@\n \tlibbanshee and libmudflap.\n \n 2004-04-12  Kelley Cook  <kcook@gcc.gnu.org>\n-            Andreas Jaeger  <aj@suse.de>\n+\t    Andreas Jaeger  <aj@suse.de>\n \n \t* gcc_update (files_and_dependencies): Insert zlib dependencies.\n "}, {"sha": "9a499fcf14c7a673be9ee253823762fca8bf3fbc", "filename": "contrib/convert_to_f2c", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/contrib%2Fconvert_to_f2c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/contrib%2Fconvert_to_f2c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fconvert_to_f2c?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,48 +0,0 @@\n-#!/bin/sh\n-#\n-# convert_to_f2c [g2c-dir]\n-#\n-# Renames certain files in a g2c (libg2c) directory so they no longer have the\n-# `.netlib' suffix, a la netlib's f2c distribution.  If `g2c-dir' is not\n-# specified, `g2c-YYYYMMDD' is the default, where YYYYMMDD is the current\n-# date.  The directory is renamed such that the first `g' becomes an `f',\n-# usually `g2c-YYYYMMDD' -> `f2c-YYYYMMDD'.\n-#\n-# (C) 1999 Free Software Foundation\n-# Originally by James Craig Burley <craig@jcb-sc.com>, September 1999.\n-#\n-# This script is Free Software, and it can be copied, distributed and\n-# modified as defined in the GNU General Public License.  A copy of\n-# its license can be downloaded from http://www.gnu.org/copyleft/gpl.html\n-\n-set -e\n-\n-if [ x$1 = x ]\n-then\n-  dir=g2c-`date +%Y%m%d`\n-else\n-  dir=$1\n-fi\n-\n-newdir=`echo $dir | sed -e \"s:g:f:\"`\n-\n-cd $dir\n-\n-set +e\n-\n-mv -i changes.netlib changes\n-mv -i disclaimer.netlib disclaimer\n-mv -i g2c.hin f2c.h\n-mv -i permission.netlib permission\n-mv -i readme.netlib readme\n-cd libF77\n-mv -i README.netlib README\n-mv -i makefile.netlib makefile\n-cd ../libI77\n-mv -i README.netlib README\n-mv -i makefile.netlib makefile\n-cd ..\n-\n-cd ..\n-\n-mv -iv $dir $newdir"}, {"sha": "5d05f84e3932f7f210b2a61b585cc08c6b62db90", "filename": "contrib/convert_to_g2c", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/contrib%2Fconvert_to_g2c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/contrib%2Fconvert_to_g2c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fconvert_to_g2c?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,48 +0,0 @@\n-#!/bin/sh\n-#\n-# convert_to_g2c [f2c-dir]\n-#\n-# Renames certain files in a netlib f2c directory so they have the `.netlib'\n-# suffix, a la g77's version of f2c (libg2c).  If `f2c-dir' is not specified,\n-# `f2c-YYYYMMDD' is the default, where YYYYMMDD is the current date.\n-# The directory is renamed such that the first `f' becomes a `g',\n-# usually `f2c-YYYYMMDD' -> `g2c-YYYYMMDD'.\n-#\n-# (C) 1999 Free Software Foundation\n-# Originally by James Craig Burley <craig@jcb-sc.com>, September 1999.\n-#\n-# This script is Free Software, and it can be copied, distributed and\n-# modified as defined in the GNU General Public License.  A copy of\n-# its license can be downloaded from http://www.gnu.org/copyleft/gpl.html\n-\n-set -e\n-\n-if [ x$1 = x ]\n-then\n-  dir=f2c-`date +%Y%m%d`\n-else\n-  dir=$1\n-fi\n-\n-newdir=`echo $dir | sed -e \"s:f:g:\"`\n-\n-cd $dir\n-\n-set +e\n-\n-mv -i changes changes.netlib\n-mv -i disclaimer disclaimer.netlib\n-mv -i f2c.h g2c.hin\n-mv -i permission permission.netlib\n-mv -i readme readme.netlib\n-cd libF77\n-mv -i README README.netlib\n-mv -i makefile makefile.netlib\n-cd ../libI77\n-mv -i README README.netlib\n-mv -i makefile makefile.netlib\n-cd ..\n-\n-cd ..\n-\n-mv -iv $dir $newdir"}, {"sha": "159c52e7d87a630f5990ddfc056cb067c6120f54", "filename": "contrib/download_f2c", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/contrib%2Fdownload_f2c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/contrib%2Fdownload_f2c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fdownload_f2c?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,77 +0,0 @@\n-#!/bin/sh\n-#\n-# download_f2c\n-#\n-# Unpacks a directory full of f2c stuff obtained from netlib, naming\n-# the directory f2c-YYYYMMDD (YYYYMMDD being the current date),\n-# leaving it in current working directory.\n-#\n-# This shell script downloads the tarball from netlib, unpacks everything,\n-# and strips off the redundant files, leaving a bare-bones (but fully\n-# reproducible) f2c source directory.  (You must have yacc/bison to rebuild\n-# gram.c, by the way.)\n-#\n-# (C) 1999 Free Software Foundation\n-# Originally by James Craig Burley <craig@jcb-sc.com>, September 1999.\n-#\n-# This script is Free Software, and it can be copied, distributed and\n-# modified as defined in the GNU General Public License.  A copy of\n-# its license can be downloaded from http://www.gnu.org/copyleft/gpl.html\n-#\n-# FIXME: Replace WHOAMI with whatever is the canonical way to\n-# obtain the user's email address these days.\n-\n-dir=f2c-`date +%Y%m%d`\n-if [ ! -d $dir ]\n-then\n-  mkdir $dir\n-fi\n-cd $dir\n-\n-echo Preparing $dir...\n-\n-if [ ! -d tmp ]\n-then\n-  mkdir tmp\n-fi\n-\n-if [ ! -f tmp/f2c.tar ]\n-then\n-  cd tmp\n-  echo Downloading f2c.tar via ftp...\n-  ftp -n netlib.bell-labs.com <<EOF\n-  user ftp WHOAMI\n-  type binary\n-  cd netlib\n-  get f2c.tar\n-  quit\n-EOF\n-  cd ..\n-fi\n-\n-echo Unpacking f2c.tar...\n-\n-tar xf tmp/f2c.tar\n-cd f2c\n-find . -name \"*.gz\" -print | sed -e \"s:^\\(.*\\).gz:rm -f \\1.Z:g\" | sh\n-mv src libf77.gz libi77.gz f2c.1t.gz f2c.h.gz changes.gz disclaimer.gz readme.gz permission.gz ..\n-cd ..\n-rm -fr f2c\n-gunzip *.gz\n-(cd src; rm -f MD5 MD5.gz gram.c.gz .depend .depend.gz f2c.1.gz index.html index.html.gz; gunzip *.gz)\n-sh libf77 > /dev/null && rm libf77\n-rm -f libF77/xsum0.out libF77/libF77.xsum\n-sh libi77 > /dev/null && rm libi77\n-rm -f libI77/xsum0.out libI77/libI77.xsum\n-rm -f src/xsum0.out\n-touch src/xsum.out\n-cmp f2c.h src/f2c.h && rm -fv src/f2c.h\n-cmp src/readme src/README && rm -fv src/readme\n-\n-echo Deleting f2c.tar...\n-rm tmp/f2c.tar\n-rmdir tmp\n-\n-cd ..\n-\n-echo Latest f2c now in $dir."}, {"sha": "b43068a1d0dfc9432fded6689d18c9269ec30a1b", "filename": "contrib/gcc_update", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4117c306105c7e3279bbbabab1dd361a3b35b62/contrib%2Fgcc_update", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4117c306105c7e3279bbbabab1dd361a3b35b62/contrib%2Fgcc_update", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc_update?ref=b4117c306105c7e3279bbbabab1dd361a3b35b62", "patch": "@@ -66,20 +66,12 @@ gcc/cstamp-h.in: gcc/configure.ac\n gcc/config.in: gcc/cstamp-h.in\n gcc/fixinc/fixincl.x: gcc/fixinc/fixincl.tpl gcc/fixinc/inclhack.def\n # And then, language-specific files\n-gcc/f/intdoc.texi: gcc/f/intdoc.in gcc/f/intdoc.c gcc/f/intrin.h gcc/f/intrin.def\n gcc/cp/cfns.h: gcc/cp/cfns.gperf\n gcc/java/keyword.h: gcc/java/keyword.gperf\n # testsuite\n # Without this, _Pragma3.c can have a false negative.\n gcc/testsuite/gcc.dg/cpp/_Pragma3.c: gcc/testsuite/gcc.dg/cpp/mi1c.h\n # And libraries, at last\n-libf2c/configure: libf2c/configure.in\n-libf2c/libF77/configure: libf2c/libF77/configure.in\n-libf2c/libI77/configure: libf2c/libI77/configure.in\n-libf2c/libI77/stamp-h.in: libf2c/libI77/configure.in\n-libf2c/libI77/config.h.in: libf2c/libI77/configure.in libf2c/libI77/stamp-h.in\n-libf2c/libU77/configure: libf2c/libU77/configure.in\n-libf2c/libU77/stamp-h.in: libf2c/libU77/configure.in libf2c/libU77/acconfig.h\n libbanshee/configure: libbanshee/configure.in\n libmudflap/configure: libmudflap/configure.in\n libobjc/configure: libobjc/configure.ac"}, {"sha": "6b265b055b518cfafb593e867b75ef9722fd4d98", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4117c306105c7e3279bbbabab1dd361a3b35b62/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4117c306105c7e3279bbbabab1dd361a3b35b62/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4117c306105c7e3279bbbabab1dd361a3b35b62", "patch": "@@ -1,3 +1,18 @@\n+2004-05-17  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* f: Entire directory removed\n+\n+\t* c-common.h (CTI_G77_INTEGER_TYPE, CTI_G77_UINTEGER_TYPE)\n+\t(CTI_G77_LONGINT_TYPE, CTI_G77_ULONGINT_TYPE)\n+\t(g77_integer_type_node, g77_uinteger_type_node)\n+\t(g77_longint_type_node, or g77_ulongint_type_node): Delete.\n+\t* c-common.c (c_common_nodes_and_builtins): Do not initialize\n+\tthe above set of variables.\n+\n+\t* config/i386/uwin.h: No need to define WIN32_UWIN_TARGET.\n+\t* doc/invoke.texi, doc/standards.texi: Remove cross-references\n+\tto g77 manual.\n+\n 2004-05-17  Steven Bosscher  <stevenb@suse.de>\n \n \tPR tree-optimization/15438\n@@ -99,7 +114,7 @@\n \n 2004-05-15  Richard Earnshaw  <reanrsha@arm.com>\n \n-\t* arm/lib1funcs.asm (_lshrdi3, _ashrdi3, _ashldi3): Add ASM \n+\t* arm/lib1funcs.asm (_lshrdi3, _ashrdi3, _ashldi3): Add ASM\n \timplementations for ARM and Thumb.\n \t* arm/t-arm-elf (LIB1ASMFUNCS): Use them.\n \n@@ -136,7 +151,7 @@\n \t* arm/crtn.asm: (FUNC_END): Simplify.\n \t* arm/lib1funcs.asm: Remove APCS-26 return macros.\n \t* arm/aof.h, arm/coff.h arm/elf.h arm/linux-elf.h arm/netbsd-elf.h\n-\t* arm/netbsd.h arm/pe.h arm/semi.h arm/semiaof.h arm/unknown-elf.h \n+\t* arm/netbsd.h arm/pe.h arm/semi.h arm/semiaof.h arm/unknown-elf.h\n \t* arm/vxworks.h arm/wince-pe.h: Tidy TARGET_DEFAULTS and\n \tMULTILIB_DEFAULTS as required.\n \t* arm/t-arm-elf arm/t-linux arm/t-pe arm/t-semi arm/t-wince-pe"}, {"sha": "2716707b0aa579408280053a0ff7b0583ba7018b", "filename": "gcc/c-common.c", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4117c306105c7e3279bbbabab1dd361a3b35b62/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4117c306105c7e3279bbbabab1dd361a3b35b62/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=b4117c306105c7e3279bbbabab1dd361a3b35b62", "patch": "@@ -3253,59 +3253,6 @@ c_common_nodes_and_builtins (void)\n     (build_decl (TYPE_DECL, get_identifier (\"complex long double\"),\n \t\t complex_long_double_type_node));\n \n-  /* Types which are common to the fortran compiler and libf2c.  When\n-     changing these, you also need to be concerned with f/com.h.  */\n-\n-  if (TYPE_PRECISION (float_type_node)\n-      == TYPE_PRECISION (long_integer_type_node))\n-    {\n-      g77_integer_type_node = long_integer_type_node;\n-      g77_uinteger_type_node = long_unsigned_type_node;\n-    }\n-  else if (TYPE_PRECISION (float_type_node)\n-\t   == TYPE_PRECISION (integer_type_node))\n-    {\n-      g77_integer_type_node = integer_type_node;\n-      g77_uinteger_type_node = unsigned_type_node;\n-    }\n-  else\n-    g77_integer_type_node = g77_uinteger_type_node = NULL_TREE;\n-\n-  if (g77_integer_type_node != NULL_TREE)\n-    {\n-      lang_hooks.decls.pushdecl (build_decl (TYPE_DECL,\n-\t\t\t\t\t     get_identifier (\"__g77_integer\"),\n-\t\t\t\t\t     g77_integer_type_node));\n-      lang_hooks.decls.pushdecl (build_decl (TYPE_DECL,\n-\t\t\t\t\t     get_identifier (\"__g77_uinteger\"),\n-\t\t\t\t\t     g77_uinteger_type_node));\n-    }\n-\n-  if (TYPE_PRECISION (float_type_node) * 2\n-      == TYPE_PRECISION (long_integer_type_node))\n-    {\n-      g77_longint_type_node = long_integer_type_node;\n-      g77_ulongint_type_node = long_unsigned_type_node;\n-    }\n-  else if (TYPE_PRECISION (float_type_node) * 2\n-\t   == TYPE_PRECISION (long_long_integer_type_node))\n-    {\n-      g77_longint_type_node = long_long_integer_type_node;\n-      g77_ulongint_type_node = long_long_unsigned_type_node;\n-    }\n-  else\n-    g77_longint_type_node = g77_ulongint_type_node = NULL_TREE;\n-\n-  if (g77_longint_type_node != NULL_TREE)\n-    {\n-      lang_hooks.decls.pushdecl (build_decl (TYPE_DECL,\n-\t\t\t\t\t     get_identifier (\"__g77_longint\"),\n-\t\t\t\t\t     g77_longint_type_node));\n-      lang_hooks.decls.pushdecl (build_decl (TYPE_DECL,\n-\t\t\t\t\t     get_identifier (\"__g77_ulongint\"),\n-\t\t\t\t\t     g77_ulongint_type_node));\n-    }\n-\n   record_builtin_type (RID_VOID, NULL, void_type_node);\n \n   void_zero_node = build_int_2 (0, 0);"}, {"sha": "c7b6c2f40aec1dd8742040c434f4f3e694a0f530", "filename": "gcc/c-common.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4117c306105c7e3279bbbabab1dd361a3b35b62/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4117c306105c7e3279bbbabab1dd361a3b35b62/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=b4117c306105c7e3279bbbabab1dd361a3b35b62", "patch": "@@ -156,11 +156,6 @@ enum c_tree_index\n \n     CTI_DEFAULT_FUNCTION_TYPE,\n \n-    CTI_G77_INTEGER_TYPE,\n-    CTI_G77_UINTEGER_TYPE,\n-    CTI_G77_LONGINT_TYPE,\n-    CTI_G77_ULONGINT_TYPE,\n-\n     /* These are not types, but we have to look them up all the time.  */\n     CTI_FUNCTION_NAME_DECL,\n     CTI_PRETTY_FUNCTION_NAME_DECL,\n@@ -205,12 +200,6 @@ struct c_common_identifier GTY(())\n \n #define default_function_type\t\tc_global_trees[CTI_DEFAULT_FUNCTION_TYPE]\n \n-/* g77 integer types, which must be kept in sync with f/com.h */\n-#define g77_integer_type_node\t\tc_global_trees[CTI_G77_INTEGER_TYPE]\n-#define g77_uinteger_type_node\t\tc_global_trees[CTI_G77_UINTEGER_TYPE]\n-#define g77_longint_type_node\t\tc_global_trees[CTI_G77_LONGINT_TYPE]\n-#define g77_ulongint_type_node\t\tc_global_trees[CTI_G77_ULONGINT_TYPE]\n-\n #define function_name_decl_node\t\tc_global_trees[CTI_FUNCTION_NAME_DECL]\n #define pretty_function_name_decl_node\tc_global_trees[CTI_PRETTY_FUNCTION_NAME_DECL]\n #define c99_function_name_decl_node\t\tc_global_trees[CTI_C99_FUNCTION_NAME_DECL]"}, {"sha": "63e8bc22a6002f156b64a98265d85375e8a20419", "filename": "gcc/config/i386/uwin.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4117c306105c7e3279bbbabab1dd361a3b35b62/gcc%2Fconfig%2Fi386%2Fuwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4117c306105c7e3279bbbabab1dd361a3b35b62/gcc%2Fconfig%2Fi386%2Fuwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fuwin.h?ref=b4117c306105c7e3279bbbabab1dd361a3b35b62", "patch": "@@ -55,9 +55,6 @@ Boston, MA 02111-1307, USA.  */\n #define LIB_SPEC \\\n   \"%{pg:-lgmon} %{mwindows:-luser32 -lgdi32 -lcomdlg32} -lkernel32 -ladvapi32\"\n \n-/* This is needed in g77spec.c for now. Will be removed in the future.  */\n-#define WIN32_UWIN_TARGET 1\n-\n /* Include in the mingw32 libraries with libgcc */\n #undef LIBGCC_SPEC\n #define LIBGCC_SPEC \"-lgnuwin -lposix -lgcc -last -lmoldname -lmsvcrt\""}, {"sha": "968ad375e8e00af47915fd0108da3cd6d94564fc", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4117c306105c7e3279bbbabab1dd361a3b35b62/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4117c306105c7e3279bbbabab1dd361a3b35b62/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b4117c306105c7e3279bbbabab1dd361a3b35b62", "patch": "@@ -43,8 +43,8 @@ remainder.  @samp{g++} accepts mostly the same options as @samp{gcc}.\n @c man end\n @c man begin SEEALSO\n gpl(7), gfdl(7), fsf-funding(7),\n-cpp(1), gcov(1), g77(1), as(1), ld(1), gdb(1), adb(1), dbx(1), sdb(1)\n-and the Info entries for @file{gcc}, @file{cpp}, @file{g77}, @file{as},\n+cpp(1), gcov(1), as(1), ld(1), gdb(1), adb(1), dbx(1), sdb(1)\n+and the Info entries for @file{gcc}, @file{cpp}, @file{as},\n @file{ld}, @file{binutils} and @file{gdb}.\n @c man end\n @c man begin BUGS\n@@ -773,10 +773,6 @@ preprocessor (not included with GCC)@.\n @itemx @var{file}.f95\n Fortran 90/95 source code which should not be preprocessed.\n \n-@xref{Overall Options,,Options Controlling the Kind of Output, g77,\n-Using and Porting GNU Fortran}, for more details of the handling of\n-Fortran input files.\n-\n @c FIXME: Descriptions of Java file types.\n @c @var{file}.java\n @c @var{file}.class"}, {"sha": "faa08e4a9f64f6570b69a4ab9a79cdd526bcac81", "filename": "gcc/doc/standards.texi", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4117c306105c7e3279bbbabab1dd361a3b35b62/gcc%2Fdoc%2Fstandards.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4117c306105c7e3279bbbabab1dd361a3b35b62/gcc%2Fdoc%2Fstandards.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fstandards.texi?ref=b4117c306105c7e3279bbbabab1dd361a3b35b62", "patch": "@@ -185,9 +185,6 @@ HTML format.\n GNAT Reference Manual}, for information on standard\n conformance and compatibility of the Ada compiler.\n \n-@xref{Language,,The GNU Fortran Language, g77, Using and Porting GNU\n-Fortran}, for details of the Fortran language supported by @command{g77}.\n-\n @xref{Standards,,Standards, gfortran, The GNU Fortran 95 Compiler}, for details\n of standards supported by @command{gfortran}.\n "}, {"sha": "0d3532e5da694f4cfa36b2a5b26b250692cc5392", "filename": "gcc/f/ChangeLog", "status": "removed", "additions": 0, "deletions": 7304, "changes": 7304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "3d6675e5d3743f761aef12df1f425be9bce86337", "filename": "gcc/f/ChangeLog.0", "status": "removed", "additions": 0, "deletions": 4806, "changes": 4806, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2FChangeLog.0", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2FChangeLog.0", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog.0?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "783ebaa998b927c75fd12299ae071e7454bc0684", "filename": "gcc/f/ChangeLog.tree-ssa", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2FChangeLog.tree-ssa", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2FChangeLog.tree-ssa", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog.tree-ssa?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,21 +0,0 @@\n-2003-11-16  Toon Moene  <toon@moene.indiv.nluug.nl>\n-\n-\t* config-lang.in: Re-add.\n-\n-2003-10-26  Richard Henderson  <rth@redhat.com>\n-\n-\t* config-lang.in: Remove.\n-\n-2003-09-24  Jason Merrill  <jason@redhat.com>\n-\n-\t* com.c, ste.c: Revert earlier change.\n-\n-2003-01-15  Jeff Law <law@redhat.com>\n-\n-\t* com.c (duplicate_decls): Use TREE_FILENAME and TREE_LINENO\n-\tto extract file/line information from nodes.  Use TREE_LOCUS\n-\tto copy file/line information from one node to another.\n-\tMake sure to copy TREE_LOCUS from the old decl to the new decl.\n-\t(pushdecl): Similarly.\n-\t* ste.c: Likewise.\n-"}, {"sha": "80c870c317318f2ace96245f92883a8e2fd7f425", "filename": "gcc/f/Make-lang.in", "status": "removed", "additions": 0, "deletions": 545, "changes": 545, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FMake-lang.in?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,545 +0,0 @@\n-# Top level -*- makefile -*- fragment for GNU Fortran.\n-#   Copyright (C) 1995, 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004\n-#   Free Software Foundation, Inc.\n-\n-#This file is part of GNU Fortran.\n-\n-#GNU Fortran is free software; you can redistribute it and/or modify\n-#it under the terms of the GNU General Public License as published by\n-#the Free Software Foundation; either version 2, or (at your option)\n-#any later version.\n-\n-#GNU Fortran is distributed in the hope that it will be useful,\n-#but WITHOUT ANY WARRANTY; without even the implied warranty of\n-#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-#GNU General Public License for more details.\n-\n-#You should have received a copy of the GNU General Public License\n-#along with GNU Fortran; see the file COPYING.  If not, write to\n-#the Free Software Foundation, 59 Temple Place - Suite 330,\n-#Boston, MA 02111-1307, USA.\n-\n-# This file provides the language dependent support in the main Makefile.\n-# Each language makefile fragment must provide the following targets:\n-#\n-# foo.all.build, foo.all.cross, foo.start.encap, foo.rest.encap,\n-# foo.install-normal, foo.install-common, foo.install-man,\n-# foo.uninstall,\n-# foo.mostlyclean, foo.clean, foo.distclean,\n-# foo.maintainer-clean, foo.stage1, foo.stage2, foo.stage3, foo.stage4\n-#\n-# where `foo' is the name of the language.\n-#\n-# It should also provide rules for:\n-#\n-# - making any compiler driver (eg: g++)\n-# - the compiler proper (eg: cc1plus)\n-# - define the names for selecting the language in LANGUAGES.\n-#\n-# $(srcdir) must be set to the gcc/ source directory (not gcc/f/).\n-#\f\n-# Actual name to use when installing a native compiler.\n-G77_INSTALL_NAME := $(shell echo g77|sed '$(program_transform_name)')\n-\n-# Some versions of `touch' (such as the version on Solaris 2.8) \n-# do not correctly set the timestamp due to buggy versions of `utime'\n-# in the kernel.  So, we use `echo' instead. \n-STAMP = echo timestamp >\n-\n-#\f\n-# Define the names for selecting f77 in LANGUAGES.\n-# Note that it would be nice to move the dependency on g77\n-# into the F77 rule, but that needs a little bit of work\n-# to do the right thing within all.cross.\n-F77 f77: f771$(exeext)\n-\n-# Tell GNU make to ignore these if they exist.\n-.PHONY: F77 f77 f77.all.build f77.all.cross \\\n-  f77.start.encap f77.rest.encap f77.dvi \\\n-  f77.install-normal \\\n-  f77.install-common f77.install-man \\\n-  f77.uninstall f77.mostlyclean f77.clean f77.distclean \\\n-  f77.maintainer-clean \\\n-  f77.stage1 f77.stage2 f77.stage3 f77.stage4 \\\n-  f77.stageprofile f77.stagefeedback\n-\n-g77spec.o: $(srcdir)/f/g77spec.c $(SYSTEM_H) coretypes.h $(TM_H) $(GCC_H) \\\n-\t$(CONFIG_H) intl.h\n-\t(SHLIB_LINK='$(SHLIB_LINK)' \\\n-\tSHLIB_MULTILIB='$(SHLIB_MULTILIB)'; \\\n-\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(DRIVER_DEFINES) \\\n-\t\t$(INCLUDES) $(srcdir)/f/g77spec.c)\n-\n-# Create the compiler driver for g77.\n-g77$(exeext): gcc.o g77spec.o version.o prefix.o intl.o \\\n-  $(LIBDEPS) $(EXTRA_GCC_OBJS)\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ gcc.o g77spec.o \\\n-\t   version.o prefix.o intl.o $(EXTRA_GCC_OBJS) $(LIBS)\n-\n-# Create a version of the g77 driver which calls the cross-compiler.\n-g77-cross$(exeext): g77$(exeext)\n-\trm -f g77-cross$(exeext); \\\n-\tcp g77$(exeext) g77-cross$(exeext)\n-\n-# The compiler itself.\n-\n-F77_OBJS = f/bad.o f/bit.o f/bld.o f/com.o f/data.o f/equiv.o f/expr.o \\\n- f/global.o f/implic.o f/info.o f/intrin.o f/lab.o f/lex.o f/malloc.o \\\n- f/name.o f/parse.o f/src.o f/st.o f/sta.o f/stb.o f/stc.o \\\n- f/std.o f/ste.o f/storag.o f/stp.o f/str.o f/sts.o f/stt.o f/stu.o \\\n- f/stv.o f/stw.o f/symbol.o f/target.o f/top.o f/type.o f/where.o\n-\n-# Use loose warnings for this front end.\n-f-warn = $(WERROR)\n-\n-f771$(exeext): $(F77_OBJS) $(BACKEND) $(LIBDEPS)\n-\trm -f f771$(exeext)\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ $(F77_OBJS) $(BACKEND) $(LIBS)\n-\n-# Keyword tables.\n-f/stamp-str: f/str-1t.h f/str-1t.j f/str-2t.h f/str-2t.j \\\n- f/str-fo.h f/str-fo.j f/str-io.h f/str-io.j f/str-nq.h  f/str-nq.j \\\n- f/str-op.h f/str-op.j f/str-ot.h f/str-ot.j\n-\t$(STAMP) f/stamp-str\n-\n-f/str-1t.h f/str-1t.j: f/stamp-1t ; @true\n-f/stamp-1t: f/fini$(build_exeext) f/str-1t.fin\n-\t./f/fini$(build_exeext) $(srcdir)/f/str-1t.fin f/tmp-str-1t.j f/tmp-str-1t.h\n-\t$(SHELL) $(srcdir)/../move-if-change f/tmp-str-1t.j f/str-1t.j\n-\t$(SHELL) $(srcdir)/../move-if-change f/tmp-str-1t.h f/str-1t.h\n-\t$(STAMP) f/stamp-1t\n-\n-f/str-2t.h f/str-2t.j: f/stamp-2t ; @true\n-f/stamp-2t: f/fini$(build_exeext) f/str-2t.fin\n-\t./f/fini$(build_exeext) $(srcdir)/f/str-2t.fin f/tmp-str-2t.j f/tmp-str-2t.h\n-\t$(SHELL) $(srcdir)/../move-if-change f/tmp-str-2t.j f/str-2t.j\n-\t$(SHELL) $(srcdir)/../move-if-change f/tmp-str-2t.h f/str-2t.h\n-\t$(STAMP) f/stamp-2t\n-\n-f/str-fo.h f/str-fo.j: f/stamp-fo ; @true\n-f/stamp-fo: f/fini$(build_exeext) f/str-fo.fin\n-\t./f/fini$(build_exeext) $(srcdir)/f/str-fo.fin f/tmp-str-fo.j f/tmp-str-fo.h\n-\t$(SHELL) $(srcdir)/../move-if-change f/tmp-str-fo.j f/str-fo.j\n-\t$(SHELL) $(srcdir)/../move-if-change f/tmp-str-fo.h f/str-fo.h\n-\t$(STAMP) f/stamp-fo\n-\n-f/str-io.h f/str-io.j: f/stamp-io ; @true\n-f/stamp-io: f/fini$(build_exeext) f/str-io.fin\n-\t./f/fini$(build_exeext) $(srcdir)/f/str-io.fin f/tmp-str-io.j f/tmp-str-io.h\n-\t$(SHELL) $(srcdir)/../move-if-change f/tmp-str-io.j f/str-io.j\n-\t$(SHELL) $(srcdir)/../move-if-change f/tmp-str-io.h f/str-io.h\n-\t$(STAMP) f/stamp-io\n-\n-f/str-nq.h f/str-nq.j: f/stamp-nq ; @true\n-f/stamp-nq: f/fini$(build_exeext) f/str-nq.fin\n-\t./f/fini$(build_exeext) $(srcdir)/f/str-nq.fin f/tmp-str-nq.j f/tmp-str-nq.h\n-\t$(SHELL) $(srcdir)/../move-if-change f/tmp-str-nq.j f/str-nq.j\n-\t$(SHELL) $(srcdir)/../move-if-change f/tmp-str-nq.h f/str-nq.h\n-\t$(STAMP) f/stamp-nq\n-\n-f/str-op.h f/str-op.j: f/stamp-op ; @true\n-f/stamp-op: f/fini$(build_exeext) f/str-op.fin\n-\t./f/fini$(build_exeext) $(srcdir)/f/str-op.fin f/tmp-str-op.j f/tmp-str-op.h\n-\t$(SHELL) $(srcdir)/../move-if-change f/tmp-str-op.j f/str-op.j\n-\t$(SHELL) $(srcdir)/../move-if-change f/tmp-str-op.h f/str-op.h\n-\t$(STAMP) f/stamp-op\n-\n-f/str-ot.h f/str-ot.j: f/stamp-ot ; @true\n-f/stamp-ot: f/fini$(build_exeext) f/str-ot.fin\n-\t./f/fini$(build_exeext) $(srcdir)/f/str-ot.fin f/tmp-str-ot.j f/tmp-str-ot.h\n-\t$(SHELL) $(srcdir)/../move-if-change f/tmp-str-ot.j f/str-ot.j\n-\t$(SHELL) $(srcdir)/../move-if-change f/tmp-str-ot.h f/str-ot.h\n-\t$(STAMP) f/stamp-ot\n-\n-f/fini$(build_exeext): f/fini.o $(BUILD_LIBDEPS)\n-\t$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o f/fini$(build_exeext) \\\n-\t\tf/fini.o $(BUILD_LIBS)\n-\n-f/fini.o:\n-\t$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) \\\n-\t      -c $(srcdir)/f/fini.c $(OUTPUT_OPTION)\n-\n-gt-f-lex.h gt-f-where.h gt-f-com.h gt-f-ste.h gtype-f.h : s-gtype; @true\n-\n-#\f\n-# Build hooks:\n-\n-f77.all.build: g77$(exeext)\n-f77.all.cross: g77-cross$(exeext)\n-f77.start.encap: g77$(exeext)\n-f77.rest.encap:\n-\n-f77.srcinfo: doc/g77.info\n-\t-cp -p $^ $(srcdir)/doc\n-f77.srcman: doc/g77.1\n-\t-cp -p $^ $(srcdir)/doc\n-f77.srcextra: f/BUGS f/NEWS \n-\t-cp -p $^ $(srcdir)/f\n-\n-f77.tags: force\n-\tcd $(srcdir)/f; etags -o TAGS.sub *.c *.h; \\\n-\tetags --include TAGS.sub --include ../TAGS.sub\n-\n-f77.info: doc/g77.info\n-dvi:: doc/g77.dvi\n-f77.man: doc/g77.1\n-\n-check-f77 : check-g77\n-lang_checks += check-g77\n-\n-# g77 documentation.\n-TEXI_G77_FILES = f/g77.texi f/bugs.texi f/ffe.texi f/invoke.texi \\\n-\t\t f/news.texi f/root.texi $(docdir)/include/fdl.texi \\\n-\t\t $(docdir)/include/gpl.texi $(docdir)/include/funding.texi \\\n-\t\t $(docdir)/include/gcc-common.texi $(srcdir)/f/intdoc.texi\n-\n-doc/g77.info: $(TEXI_G77_FILES)\n-\tif test \"x$(BUILD_INFO)\" = xinfo; then \\\n-\t  rm -f $(@)*; \\\n-\t  $(MAKEINFO) $(MAKEINFOFLAGS) -I$(docdir)/include -I$(srcdir)/f \\\n-            -o$@ $<; \\\n-\telse true; fi\n-\n-doc/g77.dvi: $(TEXI_G77_FILES)\n-\t$(TEXI2DVI) -I $(srcdir)/f -I $(abs_docdir)/include -I $(objdir)/f -o $@ $<\n-\n-.INTERMEDIATE: g77.pod\n-g77.pod: f/invoke.texi\n-\t-$(TEXI2POD) < $< > $@\n-\n-# This dance is all about producing accurate documentation for g77's\n-# intrinsics with minimum fuss.  f/ansify appends \"\\n\\\" to C strings\n-# so ANSI C compilers can compile f/intdoc.h -- gcc can compile f/intdoc.in\n-# directly, if f/intdoc.c #include'd that, but we don't want to force\n-# people to install gcc just to build the documentation.  We use the\n-# C format for f/intdoc.in in the first place to allow a fairly \"free\",\n-# but widely known format for documentation -- basically anyone who knows\n-# how to write texinfo source and enclose it in C constants can handle\n-# it, and f/ansify allows them to not even end lines with \"\\n\\\".  So,\n-# essentially, the C preprocessor and compiler are used to enter the\n-# document snippets into a data base via name lookup, rather than duplicating\n-# that kind of code here.  And we use f/intdoc.c instead of straight\n-# texinfo in the first place so that as much information as possible\n-# contained in f/intrin.def can be inserted directly and reliably into\n-# the documentation.  That's better than replicating it, because it\n-# reduces the likelihood of discrepancies between the docs and the compiler\n-# itself, which uses f/intrin.def; in fact, many bugs in f/intrin.def have\n-# been found only upon reading the documentation that was automatically\n-# produced from it.\n-\n-# If the documentation files depended on executables in the build\n-# tree, there'd be no way to ship a source tree with the documentation\n-# already generated such that `make' wouldn't attempt to rebuild it.\n-# So, we punt and arrange for the documentation files to depend on the\n-# dependencies of the executables, not on the executables themselves.\n-# But then, we have to build the executables explicitly in their build\n-# rules.\n-\n-INTDOC_DEPS = f/intdoc.c f/intrin.h f/intrin.def\n-\n-$(srcdir)/f/intdoc.texi: $(INTDOC_DEPS) f/intdoc.in\n-\t$(MAKE) f/intdoc$(build_exeext)\n-\tf/intdoc$(build_exeext) > $(srcdir)/f/intdoc.texi\n-\n-f/intdoc$(build_exeext): $(INTDOC_DEPS) f/intdoc.h0 bconfig.h \\\n-  $(SYSTEM_H) coretypes.h $(TM_H) $(BUILD_LIBDEPS)\n-\t$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) $(INCLUDES) $< \\\n-\t  $(BUILD_LIBS) -o $@\n-\n-f/intdoc.h0: f/intdoc.in f/ansify$(build_exeext)\n-\tf/ansify$(build_exeext) $< < $< > $@\n-\n-f/ansify$(build_exeext): f/ansify.c bconfig.h $(SYSTEM_H) coretypes.h $(TM_H)\n-\t  $(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) $(INCLUDES) $< \\\n-\t  -o $@\n-\n-f/BUGS: f/bugs0.texi f/bugs.texi f/root.texi\n-\tif [ x$(BUILD_INFO) = xinfo ]; then \\\n-\t  rm -f $(@)*; \\\n-\t  $(MAKEINFO) $(MAKEINFOFLAGS) -D BUGSONLY --no-header --no-split \\\n-           --no-validate -I$(docdir)/include -I$(srcdir)/f -o $@ bugs0.texi; \\\n-\telse true; fi\n-\n-f/NEWS: f/news0.texi f/news.texi f/root.texi\n-\tif [ x$(BUILD_INFO) = xinfo ]; then \\\n-\t  rm -f $(@)*; \\\n-\t  $(MAKEINFO) $(MAKEINFOFLAGS) -D NEWSONLY --no-header --no-split \\\n-           --no-validate -I$(docdir)/include -I$(srcdir)/f -o $@ news0.texi; \\\n-\telse true; fi\n-\n-#\f\n-# Install hooks:\n-# f771 is installed elsewhere as part of $(COMPILERS).\n-\n-f77.install-normal:\n-\n-# Install the driver program as $(target)-g77\n-# and also as either g77 (if native) or $(tooldir)/bin/g77.\n-f77.install-common: installdirs\n-\t-if [ -f f771$(exeext) ] ; then \\\n-\t  rm -f $(DESTDIR)$(bindir)/$(G77_INSTALL_NAME)$(exeext); \\\n-\t  $(INSTALL_PROGRAM) g77$(exeext) $(DESTDIR)$(bindir)/$(G77_INSTALL_NAME)$(exeext); \\\n-\t  chmod a+x $(DESTDIR)$(bindir)/$(G77_INSTALL_NAME)$(exeext); \\\n-\telse true; fi\n-\t@if [ -f f77-install-ok -o -f $(srcdir)/f77-install-ok ]; then \\\n-\t  echo ''; \\\n-\t  echo 'Warning: gcc no longer installs an f77 command.'; \\\n-\t  echo '         You must do so yourself.  For more information,'; \\\n-\t  echo '         read \"Distributing Binaries\" in the g77 docs.'; \\\n-\t  echo '         (To turn off this warning, delete the file'; \\\n-\t  echo '         f77-install-ok in the source or build directory.)'; \\\n-\t  echo ''; \\\n-\telse true; fi\n-\n-install-info:: $(DESTDIR)$(infodir)/g77.info\n-\n-f77.install-man: installdirs $(DESTDIR)$(man1dir)/$(G77_INSTALL_NAME)$(man1ext)\n-\n-$(DESTDIR)$(man1dir)/$(G77_INSTALL_NAME)$(man1ext): doc/g77.1\n-\t-rm -f $@\n-\t-$(INSTALL_DATA) $< $@\n-\t-chmod a-x $@\n-\n-f77.uninstall: installdirs\n-\tif $(SHELL) -c 'install-info --version | sed 1q | fgrep -s -v -i debian' >/dev/null 2>&1; then \\\n-\t  echo \" install-info --delete --info-dir=$(DESTDIR)$(infodir) $(DESTDIR)$(infodir)/g77.info\"; \\\n-\t  install-info --delete --info-dir=$(DESTDIR)$(infodir) $(DESTDIR)$(infodir)/g77.info || : ; \\\n-\telse : ; fi\n-\trm -rf $(DESTDIR)$(bindir)/$(G77_INSTALL_NAME)$(exeext); \\\n-\trm -rf $(DESTDIR)$(man1dir)/$(G77_INSTALL_NAME)$(man1ext); \\\n-\trm -rf $(DESTDIR)$(infodir)/g77.info*\n-#\f\n-# Clean hooks:\n-# A lot of the ancillary files are deleted by the main makefile.\n-# We just have to delete files specific to us.\n-\n-f77.mostlyclean:\n-\t-rm -f f/*$(objext)\n-\t-rm -f f/*$(coverageexts)\n-\t-rm -f f/fini$(build_exeext) f/stamp-str f/str-*.h f/str-*.j\n-\t-rm -f f/BUGS f/NEWS\n-\t-rm -f g77.aux g77.cps g77.ky g77.toc g77.vr g77.fn g77.kys \\\n-\t       g77.pg g77.tp g77.vrs g77.cp g77.fns g77.log g77.pgs g77.tps \n-f77.clean:\n-\t-rm -f g77spec.o\n-f77.distclean:\n-\t-rm -f f/Makefile\n-f77.maintainer-clean:\n-\t-rm -f $(srcdir)/f/BUGS $(srcdir)/f/TAGS $(srcdir)/f/TAGS.SUB\n-\t-rm -f $(srcdir)/f/NEWS $(srcdir)/f/intdoc.texi\n-#\f\n-# Stage hooks:\n-# The main makefile has already created stage?/f.\n-\n-G77STAGESTUFF = f/*$(objext) f/fini$(build_exeext) f/stamp-* \\\n-  f/str-*.h f/str-*.j g77spec.o\n-\n-f77.stage1: stage1-start\n-\t-mv -f $(G77STAGESTUFF) stage1/f\n-\n-f77.stage2: stage2-start\n-\t-mv -f $(G77STAGESTUFF) stage2/f\n-\n-f77.stage3: stage3-start\n-\t-mv -f $(G77STAGESTUFF) stage3/f\n-\n-f77.stage4: stage4-start\n-\t-mv -f $(G77STAGESTUFF) stage4/f\n-\n-f77.stageprofile: stageprofile-start\n-\t-mv -f $(G77STAGESTUFF) stageprofile/f\n-\n-f77.stagefeedback: stageprofile-start\n-\t-mv -f $(G77STAGESTUFF) stagefeedback/f\n-#\f\n-# .o: .h dependencies.\n-\n-f/bad.o: f/bad.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/bad.h f/bad.def f/where.h \\\n- glimits.h f/top.h f/malloc.h flags.h f/com.h f/com-rt.def $(TREE_H) f/bld.h \\\n- f/bld-op.def f/bit.h f/info.h f/info-b.def f/info-k.def f/info-w.def \\\n- f/target.h f/lex.h f/type.h f/intrin.h f/intrin.def f/lab.h f/symbol.h \\\n- f/symbol.def f/equiv.h f/storag.h f/global.h f/name.h toplev.h intl.h \\\n- diagnostic.h coretypes.h $(TM_H)\n-f/bit.o: f/bit.c f/proj.h $(CONFIG_H) $(SYSTEM_H) glimits.h f/bit.h \\\n- f/malloc.h coretypes.h $(TM_H)\n-f/bld.o: f/bld.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/bld.h f/bld-op.def f/bit.h \\\n- f/malloc.h f/com.h f/com-rt.def $(TREE_H) f/info.h f/info-b.def f/info-k.def \\\n- f/info-w.def f/target.h f/bad.h f/bad.def f/where.h glimits.h f/top.h f/lex.h \\\n- f/type.h f/lab.h f/storag.h f/symbol.h f/symbol.def f/equiv.h f/global.h \\\n- f/name.h f/intrin.h f/intrin.def real.h coretypes.h $(TM_H)\n-f/com.o: f/com.c f/proj.h $(CONFIG_H) $(SYSTEM_H) flags.h $(RTL_H) $(TREE_H) \\\n- output.h convert.h f/com.h f/com-rt.def f/bld.h f/bld-op.def f/bit.h \\\n- f/malloc.h f/info.h f/info-b.def f/info-k.def f/info-w.def f/target.h f/bad.h \\\n- f/bad.def f/where.h glimits.h f/top.h f/lex.h f/type.h f/intrin.h \\\n- f/intrin.def f/lab.h f/symbol.h f/symbol.def f/equiv.h f/storag.h f/global.h \\\n- f/name.h f/expr.h f/implic.h f/src.h f/st.h $(GGC_H) toplev.h diagnostic.h \\\n- $(LANGHOOKS_DEF) langhooks.h intl.h real.h debug.h gt-f-com.h gtype-f.h \\\n- coretypes.h $(TM_H) function.h\n-f/data.o: f/data.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/data.h f/bld.h f/bld-op.def \\\n- f/bit.h f/malloc.h f/com.h f/com-rt.def $(TREE_H) f/info.h f/info-b.def \\\n- f/info-k.def f/info-w.def f/target.h f/bad.h f/bad.def f/where.h glimits.h \\\n- f/top.h f/lex.h f/type.h f/lab.h f/storag.h f/symbol.h f/symbol.def f/equiv.h \\\n- f/global.h f/name.h f/intrin.h f/intrin.def f/expr.h f/st.h coretypes.h $(TM_H)\n-f/equiv.o: f/equiv.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/equiv.h f/bld.h \\\n- f/bld-op.def f/bit.h f/malloc.h f/com.h f/com-rt.def $(TREE_H) f/info.h \\\n- f/info-b.def f/info-k.def f/info-w.def f/target.h f/bad.h f/bad.def f/where.h \\\n- glimits.h f/top.h f/lex.h f/type.h f/lab.h f/storag.h f/symbol.h f/symbol.def \\\n- f/global.h f/name.h f/intrin.h f/intrin.def f/data.h coretypes.h $(TM_H)\n-f/expr.o: f/expr.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/expr.h f/bld.h f/bld-op.def \\\n- f/bit.h f/malloc.h f/com.h f/com-rt.def $(TREE_H) f/info.h f/info-b.def \\\n- f/info-k.def f/info-w.def f/target.h f/bad.h f/bad.def f/where.h glimits.h \\\n- f/top.h f/lex.h f/type.h f/lab.h f/storag.h f/symbol.h f/symbol.def f/equiv.h \\\n- f/global.h f/name.h f/intrin.h f/intrin.def f/implic.h f/src.h f/st.h \\\n- f/stamp-str real.h coretypes.h $(TM_H)\n-f/fini.o: f/fini.c f/proj.h bconfig.h $(SYSTEM_H) f/malloc.h coretypes.h $(TM_H)\n-f/global.o: f/global.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/global.h f/info.h \\\n- f/info-b.def f/info-k.def f/info-w.def f/target.h $(TREE_H) f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/malloc.h f/lex.h f/type.h f/name.h f/symbol.h \\\n- f/symbol.def f/bld.h f/bld-op.def f/bit.h f/com.h f/com-rt.def f/lab.h \\\n- f/storag.h f/intrin.h f/intrin.def f/equiv.h coretypes.h $(TM_H)\n-f/implic.o: f/implic.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/implic.h f/info.h \\\n- f/info-b.def f/info-k.def f/info-w.def f/target.h $(TREE_H) f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/malloc.h f/lex.h f/type.h f/symbol.h \\\n- f/symbol.def f/bld.h f/bld-op.def f/bit.h f/com.h f/com-rt.def f/lab.h \\\n- f/storag.h f/intrin.h f/intrin.def f/equiv.h f/global.h f/name.h f/src.h \\\n- coretypes.h $(TM_H)\n-f/info.o: f/info.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/info.h f/info-b.def \\\n- f/info-k.def f/info-w.def f/target.h $(TREE_H) f/bad.h f/bad.def f/where.h \\\n- glimits.h f/top.h f/malloc.h f/lex.h f/type.h coretypes.h $(TM_H)\n-f/intrin.o: f/intrin.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/intrin.h \\\n- f/intrin.def f/bld.h f/bld-op.def f/bit.h f/malloc.h f/com.h f/com-rt.def \\\n- $(TREE_H) f/info.h f/info-b.def f/info-k.def f/info-w.def f/target.h f/bad.h \\\n- f/bad.def f/where.h glimits.h f/top.h f/lex.h f/type.h f/lab.h f/storag.h \\\n- f/symbol.h f/symbol.def f/equiv.h f/global.h f/name.h f/expr.h f/src.h \\\n- coretypes.h $(TM_H)\n-f/lab.o: f/lab.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/lab.h f/com.h f/com-rt.def \\\n- $(TREE_H) f/bld.h f/bld-op.def f/bit.h f/malloc.h f/info.h f/info-b.def \\\n- f/info-k.def f/info-w.def f/target.h f/bad.h f/bad.def f/where.h glimits.h \\\n- f/top.h f/lex.h f/type.h f/intrin.h f/intrin.def f/symbol.h f/symbol.def \\\n- f/equiv.h f/storag.h f/global.h f/name.h coretypes.h $(TM_H)\n-f/lex.o: f/lex.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/top.h f/malloc.h f/where.h \\\n- glimits.h f/bad.h f/bad.def f/com.h f/com-rt.def $(TREE_H) f/bld.h \\\n- f/bld-op.def f/bit.h f/info.h f/info-b.def f/info-k.def f/info-w.def \\\n- f/target.h f/lex.h f/type.h f/intrin.h f/intrin.def f/lab.h f/symbol.h \\\n- f/symbol.def f/equiv.h f/storag.h f/global.h f/name.h f/src.h flags.h \\\n- debug.h input.h toplev.h output.h $(GGC_H) gt-f-lex.h coretypes.h $(TM_H)\n-f/malloc.o: f/malloc.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/malloc.h \\\n- coretypes.h $(TM_H)\n-f/name.o: f/name.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/bad.h f/bad.def f/where.h \\\n- glimits.h f/top.h f/malloc.h f/name.h f/global.h f/info.h f/info-b.def \\\n- f/info-k.def f/info-w.def f/target.h $(TREE_H) f/lex.h f/type.h f/symbol.h \\\n- f/symbol.def f/bld.h f/bld-op.def f/bit.h f/com.h f/com-rt.def f/lab.h \\\n- f/storag.h f/intrin.h f/intrin.def f/equiv.h f/src.h coretypes.h $(TM_H)\n-f/parse.o: f/parse.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/top.h f/malloc.h \\\n- f/where.h glimits.h f/com.h f/com-rt.def $(TREE_H) f/bld.h f/bld-op.def \\\n- f/bit.h f/info.h f/info-b.def f/info-k.def f/info-w.def f/target.h f/bad.h \\\n- f/bad.def f/lex.h f/type.h f/intrin.h f/intrin.def f/lab.h f/symbol.h \\\n- f/symbol.def f/equiv.h f/storag.h f/global.h f/name.h version.h flags.h \\\n- coretypes.h $(TM_H)\n-f/src.o: f/src.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/src.h f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/malloc.h coretypes.h $(TM_H)\n-f/st.o: f/st.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/st.h f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/malloc.h f/lex.h f/symbol.h f/symbol.def \\\n- f/bld.h f/bld-op.def f/bit.h f/com.h f/com-rt.def $(TREE_H) f/info.h \\\n- f/info-b.def f/info-k.def f/info-w.def f/target.h f/type.h f/lab.h \\\n- f/storag.h f/intrin.h f/intrin.def f/equiv.h f/global.h f/name.h f/sta.h \\\n- f/stamp-str f/stb.h f/expr.h f/stp.h f/stt.h f/stc.h f/std.h \\\n- f/stv.h f/stw.h f/ste.h f/sts.h f/stu.h coretypes.h $(TM_H)\n-f/sta.o: f/sta.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/sta.h f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/malloc.h f/lex.h f/stamp-str f/symbol.h \\\n- f/symbol.def f/bld.h f/bld-op.def f/bit.h f/com.h f/com-rt.def $(TREE_H) \\\n- f/info.h f/info-b.def f/info-k.def f/info-w.def f/target.h f/type.h f/lab.h \\\n- f/storag.h f/intrin.h f/intrin.def f/equiv.h f/global.h f/name.h f/implic.h \\\n- f/stb.h f/expr.h f/stp.h f/stt.h f/stc.h f/std.h f/stv.h f/stw.h coretypes.h \\\n- $(TM_H)\n-f/stb.o: f/stb.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/stb.h f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/malloc.h f/expr.h f/bld.h f/bld-op.def f/bit.h \\\n- f/com.h f/com-rt.def $(TREE_H) f/info.h f/info-b.def f/info-k.def \\\n- f/info-w.def f/target.h f/lex.h f/type.h f/lab.h f/storag.h f/symbol.h \\\n- f/symbol.def f/equiv.h f/global.h f/name.h f/intrin.h f/intrin.def f/stp.h \\\n- f/stt.h f/stamp-str f/src.h f/sta.h f/stc.h coretypes.h $(TM_H)\n-f/stc.o: f/stc.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/stc.h f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/malloc.h f/bld.h f/bld-op.def f/bit.h f/com.h \\\n- f/com-rt.def $(TREE_H) f/info.h f/info-b.def f/info-k.def f/info-w.def \\\n- f/target.h f/lex.h f/type.h f/lab.h f/storag.h f/symbol.h f/symbol.def \\\n- f/equiv.h f/global.h f/name.h f/intrin.h f/intrin.def f/expr.h f/stp.h \\\n- f/stt.h f/stamp-str f/data.h f/implic.h f/src.h f/sta.h f/std.h f/stv.h \\\n- f/stw.h coretypes.h $(TM_H)\n-f/std.o: f/std.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/std.h f/bld.h f/bld-op.def \\\n- f/bit.h f/malloc.h f/com.h f/com-rt.def $(TREE_H) f/info.h f/info-b.def \\\n- f/info-k.def f/info-w.def f/target.h f/bad.h f/bad.def f/where.h glimits.h \\\n- f/top.h f/lex.h f/type.h f/lab.h f/storag.h f/symbol.h f/symbol.def f/equiv.h \\\n- f/global.h f/name.h f/intrin.h f/intrin.def f/stp.h f/stt.h f/stamp-str \\\n- f/stv.h f/stw.h f/sta.h f/ste.h f/sts.h coretypes.h $(TM_H)\n-f/ste.o: f/ste.c f/proj.h $(CONFIG_H) $(SYSTEM_H) $(RTL_H) toplev.h f/ste.h \\\n- f/bld.h f/bld-op.def f/bit.h f/malloc.h f/com.h f/com-rt.def $(TREE_H)\t\\\n- f/info.h f/info-b.def f/info-k.def f/info-w.def f/target.h f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/lex.h f/type.h f/lab.h f/storag.h f/symbol.h \\\n- f/symbol.def f/equiv.h f/global.h f/name.h f/intrin.h f/intrin.def f/stp.h \\\n- f/stt.h f/stamp-str f/sts.h f/stv.h f/stw.h f/expr.h f/sta.h $(GGC_H) \\\n- gt-f-ste.h coretypes.h $(TM_H)\n-f/storag.o: f/storag.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/storag.h f/bld.h  \\\n- f/bld-op.def f/bit.h f/malloc.h f/com.h f/com-rt.def $(TREE_H) \\\n- f/info.h f/info-b.def f/info-k.def f/info-w.def f/target.h f/bad.h \\\n- f/bad.def f/where.h glimits.h f/top.h f/lex.h f/type.h f/lab.h \\\n- f/symbol.h f/symbol.def f/equiv.h f/global.h f/name.h f/intrin.h \\\n- f/intrin.def f/data.h coretypes.h $(TM_H)\n-f/stp.o: f/stp.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/stp.h f/bld.h f/bld-op.def \\\n- f/bit.h f/malloc.h f/com.h f/com-rt.def $(TREE_H) f/info.h \\\n- f/info-b.def f/info-k.def f/info-w.def f/target.h f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/lex.h f/type.h f/lab.h f/storag.h \\\n- f/symbol.h f/symbol.def f/equiv.h f/global.h f/name.h f/intrin.h \\\n- f/intrin.def f/stt.h coretypes.h $(TM_H)\n-f/str.o: f/str.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/src.h f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/malloc.h f/stamp-str f/lex.h coretypes.h $(TM_H)\n-f/sts.o: f/sts.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/sts.h f/malloc.h f/com.h \\\n- f/com-rt.def $(TREE_H) f/bld.h f/bld-op.def f/bit.h f/info.h \\\n- f/info-b.def f/info-k.def f/info-w.def f/target.h f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/lex.h f/type.h f/intrin.h f/intrin.def \\\n- f/lab.h f/symbol.h f/symbol.def f/equiv.h f/storag.h f/global.h \\\n- f/name.h coretypes.h $(TM_H)\n-f/stt.o: f/stt.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/stt.h f/top.h f/malloc.h \\\n- f/where.h glimits.h f/bld.h f/bld-op.def f/bit.h f/com.h f/com-rt.def \\\n- $(TREE_H) f/info.h f/info-b.def f/info-k.def f/info-w.def f/target.h \\\n- f/bad.h f/bad.def f/lex.h f/type.h f/lab.h f/storag.h f/symbol.h \\\n- f/symbol.def f/equiv.h f/global.h f/name.h f/intrin.h f/intrin.def \\\n- f/stp.h f/expr.h f/sta.h f/stamp-str coretypes.h $(TM_H)\n-f/stu.o: f/stu.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/bld.h f/bld-op.def f/bit.h \\\n- f/malloc.h f/com.h f/com-rt.def $(TREE_H) f/info.h f/info-b.def \\\n- f/info-k.def f/info-w.def f/target.h f/bad.h f/bad.def f/where.h \\\n- glimits.h f/top.h f/lex.h f/type.h f/lab.h f/storag.h f/symbol.h \\\n- f/symbol.def f/equiv.h f/global.h f/name.h f/intrin.h f/intrin.def \\\n- f/implic.h f/stu.h f/sta.h f/stamp-str coretypes.h $(TM_H)\n-f/stv.o: f/stv.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/stv.h f/lab.h f/com.h \\\n- f/com-rt.def $(TREE_H) f/bld.h f/bld-op.def f/bit.h f/malloc.h \\\n- f/info.h f/info-b.def f/info-k.def f/info-w.def f/target.h f/bad.h \\\n- f/bad.def f/where.h glimits.h f/top.h f/lex.h f/type.h f/intrin.h \\\n- f/intrin.def f/symbol.h f/symbol.def f/equiv.h f/storag.h f/global.h \\\n- f/name.h coretypes.h $(TM_H)\n-f/stw.o: f/stw.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/stw.h f/bld.h f/bld-op.def \\\n- f/bit.h f/malloc.h f/com.h f/com-rt.def $(TREE_H) f/info.h \\\n- f/info-b.def f/info-k.def f/info-w.def f/target.h f/bad.h f/bad.def \\\n- f/where.h glimits.h f/top.h f/lex.h f/type.h f/lab.h f/storag.h \\\n- f/symbol.h f/symbol.def f/equiv.h f/global.h f/name.h f/intrin.h \\\n- f/intrin.def f/stv.h f/sta.h f/stamp-str coretypes.h $(TM_H)\n-f/symbol.o: f/symbol.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/symbol.h \\\n- f/symbol.def f/bld.h f/bld-op.def f/bit.h f/malloc.h f/com.h \\\n- f/com-rt.def $(TREE_H) f/info.h f/info-b.def f/info-k.def \\\n- f/info-w.def f/target.h f/bad.h f/bad.def f/where.h glimits.h f/top.h \\\n- f/lex.h f/type.h f/lab.h f/storag.h f/intrin.h f/intrin.def f/equiv.h \\\n- f/global.h f/name.h f/src.h f/st.h coretypes.h $(TM_H)\n-f/target.o: f/target.c f/proj.h $(CONFIG_H) $(SYSTEM_H) glimits.h f/target.h \\\n- $(TREE_H) f/bad.h f/bad.def f/where.h f/top.h f/malloc.h f/info.h real.h \\\n- f/info-b.def f/info-k.def f/info-w.def f/type.h f/lex.h diagnostic.h \\\n- coretypes.h $(TM_H) toplev.h\n-f/top.o: f/top.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/top.h f/malloc.h f/where.h \\\n- glimits.h f/bad.h f/bad.def f/bit.h f/bld.h f/bld-op.def f/com.h \\\n- f/com-rt.def $(TREE_H) f/info.h f/info-b.def f/info-k.def \\\n- f/info-w.def f/target.h f/lex.h f/type.h f/lab.h f/storag.h \\\n- f/symbol.h f/symbol.def f/equiv.h f/global.h f/name.h f/intrin.h \\\n- f/intrin.def f/data.h f/expr.h f/implic.h f/src.h f/st.h flags.h \\\n- toplev.h coretypes.h $(TM_H) opts.h options.h\n-f/type.o: f/type.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/type.h f/malloc.h \\\n- coretypes.h $(TM_H)\n-f/where.o: f/where.c f/proj.h $(CONFIG_H) $(SYSTEM_H) f/where.h glimits.h \\\n- f/top.h f/malloc.h f/lex.h $(GGC_H) gt-f-where.h coretypes.h $(TM_H)"}, {"sha": "71eebf614c4ff1cc6bc7945dc9ec2e1a6bed374f", "filename": "gcc/f/RELEASE-PREP", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2FRELEASE-PREP", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2FRELEASE-PREP", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FRELEASE-PREP?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,5 +0,0 @@\n-1999-03-13  RELEASE-PREP\n-\n-Things to do to prepare a g77 release.\n-\n--  Update root.texi: clear DEVELOPMENT flag, set version info."}, {"sha": "b03206d79e35cdfd2f42b6438635d69295656221", "filename": "gcc/f/ansify.c", "status": "removed", "additions": 0, "deletions": 190, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fansify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fansify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fansify.c?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,190 +0,0 @@\n-/* ansify.c\n-   Copyright (C) 1997, 2003 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.  */\n-\n-#include \"bconfig.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-\n-#define die_unless(c) \\\n-  do if (!(c)) \\\n-    { \\\n-      fprintf (stderr, \"%s:%lu: %s\\n\", argv[1], lineno, #c); \\\n-      die (); \\\n-    } \\\n-  while(0)\n-\n-static void ATTRIBUTE_NORETURN\n-die (void)\n-{\n-  exit (1);\n-}\n-\n-int\n-main(int argc, char **argv)\n-{\n-  int c;\n-  static unsigned long lineno = 1;\n-\n-  die_unless (argc == 2);\n-\n-  printf (\"\\\n-/* This file is automatically generated from `%s',\\n\\\n-   which you should modify instead.  */\\n\\\n-#line 1 \\\"%s\\\"\\n\\\n-\",\n-\t  argv[1], argv[1]);\n-\n-  while ((c = getchar ()) != EOF)\n-    {\n-      switch (c)\n-\t{\n-\tdefault:\n-\t  putchar (c);\n-\t  break;\n-\n-\tcase '\\n':\n-\t  ++lineno;\n-\t  putchar (c);\n-\t  break;\n-\n-\tcase '\"':\n-\t  putchar (c);\n-\t  for (;;)\n-\t    {\n-\t      c = getchar ();\n-\t      die_unless (c != EOF);\n-\t      switch (c)\n-\t\t{\n-\t\tcase '\"':\n-\t\t  putchar (c);\n-\t\t  goto next_char;\n-\n-\t\tcase '\\n':\n-\t\t  putchar ('\\\\');\n-\t\t  putchar ('n');\n-\t\t  putchar ('\\\\');\n-\t\t  putchar ('\\n');\n-\t\t  ++lineno;\n-\t\t  break;\n-\n-\t\tcase '\\\\':\n-\t\t  putchar (c);\n-\t\t  c = getchar ();\n-\t\t  die_unless (c != EOF);\n-\t\t  putchar (c);\n-\t\t  if (c == '\\n')\n-\t\t    ++lineno;\n-\t\t  break;\n-\t\t  \n-\t\tdefault:\n-\t\t  putchar (c);\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  break;\n-\n-\tcase '\\'':\n-\t  putchar (c);\n-\t  for (;;)\n-\t    {\n-\t      c = getchar ();\n-\t      die_unless (c != EOF);\n-\t      switch (c)\n-\t\t{\n-\t\tcase '\\'':\n-\t\t  putchar (c);\n-\t\t  goto next_char;\n-\t\t  \n-\t\tcase '\\n':\n-\t\t  putchar ('\\\\');\n-\t\t  putchar ('n');\n-\t\t  putchar ('\\\\');\n-\t\t  putchar ('\\n');\n-\t\t  ++lineno;\n-\t\t  break;\n-\t\t  \n-\t\tcase '\\\\':\n-\t\t  putchar (c);\n-\t\t  c = getchar ();\n-\t\t  die_unless (c != EOF);\n-\t\t  putchar (c);\n-\t\t  if (c == '\\n')\n-\t\t    ++lineno;\n-\t\t  break;\n-\t\t  \n-\t\tdefault:\n-\t\t  putchar (c);\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  break;\n-\n-\tcase '/':\n-\t  putchar (c);\n-\t  c = getchar ();\n-\t  putchar (c);\n-\t  if (c != '*')\n-\t    break;\n-\t  for (;;)\n-\t    {\n-\t      c = getchar ();\n-\t      die_unless (c != EOF);\n-\n-\t      switch (c)\n-\t\t{\n-\t\tcase '\\n':\n-\t\t  ++lineno;\n-\t\t  putchar (c);\n-\t\t  break;\n-\t\t  \n-\t\tcase '*':\n-\t\t  c = getchar ();\n-\t\t  die_unless (c != EOF);\n-\t\t  if (c == '/')\n-\t\t    {\n-\t\t      putchar ('*');\n-\t\t      putchar ('/');\n-\t\t      goto next_char;\n-\t\t    }\n-\t\t  if (c == '\\n')\n-\t\t    {\n-\t\t      ++lineno;\n-\t\t      putchar (c);\n-\t\t    }\n-\t\t  break;\n-\t\t  \n-\t\tdefault:\n-\t\t  /* Don't bother outputting content of comments.  */\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  break;\n-\t}\n-      \n-    next_char:\n-      ;\n-    }\n-\n-  die_unless (c == EOF);\n-\n-  return 0;\n-}"}, {"sha": "bed9734ecc78a24e2429d611ca2af72832d08ce8", "filename": "gcc/f/bad.c", "status": "removed", "additions": 0, "deletions": 537, "changes": 537, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fbad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fbad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbad.c?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,537 +0,0 @@\n-/* bad.c -- Implementation File (module.c template V1.0)\n-   Copyright (C) 1995, 2002, 2003 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Related Modules:\n-      None\n-\n-   Description:\n-      Handles the displaying of diagnostic messages regarding the user's source\n-      files.\n-\n-   Modifications:\n-*/\n-\n-/* If there's a %E or %4 in the messages, set this to at least 5,\n-   for example.  */\n-\n-#define FFEBAD_MAX_ 6\n-\n-/* Include files. */\n-\n-#include \"proj.h\"\n-#include \"bad.h\"\n-#include \"flags.h\"\n-#include \"com.h\"\n-#include \"toplev.h\"\n-#include \"where.h\"\n-#include \"intl.h\"\n-#include \"diagnostic.h\"\n-\n-/* Externals defined here. */\n-\n-bool ffebad_is_inhibited_ = FALSE;\n-\n-/* Simple definitions and enumerations. */\n-\n-#define FFEBAD_LONG_MSGS_ 1\t/* 0 to use short (or same) messages. */\n-\n-/* Internal typedefs. */\n-\n-\n-/* Private include files. */\n-\n-\n-/* Internal structure definitions. */\n-\n-struct _ffebad_message_\n-  {\n-    const ffebadSeverity severity;\n-    const char *const message;\n-  };\n-\n-/* Static objects accessed by functions in this module.\t */\n-\n-static const struct _ffebad_message_ ffebad_messages_[]\n-=\n-{\n-#define FFEBAD_MSG(kwd,sev,msgid) { sev, msgid },\n-#if FFEBAD_LONG_MSGS_ == 0\n-#define LONG(m)\n-#define SHORT(m) m\n-#else\n-#define LONG(m) m\n-#define SHORT(m)\n-#endif\n-#include \"bad.def\"\n-#undef FFEBAD_MSG\n-#undef LONG\n-#undef SHORT\n-};\n-\n-static struct\n-  {\n-    ffewhereLine line;\n-    ffewhereColumn col;\n-    ffebadIndex tag;\n-  }\n-\n-ffebad_here_[FFEBAD_MAX_];\n-static const char *ffebad_string_[FFEBAD_MAX_];\n-static ffebadIndex ffebad_order_[FFEBAD_MAX_];\n-static ffebad ffebad_errnum_;\n-static ffebadSeverity ffebad_severity_;\n-static const char *ffebad_message_;\n-static unsigned char ffebad_index_;\n-static ffebadIndex ffebad_places_;\n-static bool ffebad_is_temp_inhibited_;\t/* Effective setting of\n-\t\t\t\t\t   _is_inhibited_ for this\n-\t\t\t\t\t   _start/_finish invocation. */\n-\n-/* Static functions (internal). */\n-\n-static int ffebad_bufputs_ (char buf[], int bufi, const char *s);\n-\n-/* Internal macros. */\n-\n-#define ffebad_bufflush_(buf, bufi) \\\n-  (((buf)[bufi] = '\\0'), fputs ((buf), stderr), 0)\n-#define ffebad_bufputc_(buf, bufi, c) \\\n-  (((bufi) == ARRAY_SIZE (buf)) \\\n-   ? (ffebad_bufflush_ ((buf), (bufi)), ((buf)[0] = (c)), 1) \\\n-   : (((buf)[bufi] = (c)), (bufi) + 1))\n-\f\n-\n-static int\n-ffebad_bufputs_ (char buf[], int bufi, const char *s)\n-{\n-  for (; *s != '\\0'; ++s)\n-    bufi = ffebad_bufputc_ (buf, bufi, *s);\n-  return bufi;\n-}\n-\n-/* ffebad_init_0 -- Initialize\n-\n-   ffebad_init_0();  */\n-\n-void\n-ffebad_init_0 (void)\n-{\n-  assert (FFEBAD == ARRAY_SIZE (ffebad_messages_));\n-}\n-\n-ffebadSeverity\n-ffebad_severity (ffebad errnum)\n-{\n-  return ffebad_messages_[errnum].severity;\n-}\n-\n-/* ffebad_start_ -- Start displaying an error message\n-\n-   ffebad_start(FFEBAD_SOME_ERROR_CODE);\n-\n-   Call ffebad_start to establish the message, ffebad_here and ffebad_string\n-   to send run-time data to it as necessary, then ffebad_finish when through\n-   to actually get it to print (to stderr).\n-\n-   Note: ffebad_start(errnum) turns into ffebad_start_(FALSE,errnum).  No\n-   outside caller should call ffebad_start_ directly (as indicated by the\n-   trailing underscore).\n-\n-   Call ffebad_start to start a normal message, one that might be inhibited\n-   by the current state of statement guessing.\tCall ffebad_start_lex\n-   instead to start a message that is global to all statement guesses and\n-   happens only once for all guesses (i.e. the lexer).\n-\n-   sev and message are overrides for the severity and messages when errnum\n-   is FFEBAD, meaning the caller didn't want to have to put a message in\n-   bad.def to produce a diagnostic.  */\n-\n-bool\n-ffebad_start_ (bool lex_override, ffebad errnum, ffebadSeverity sev,\n-\t       const char *msgid)\n-{\n-  unsigned char i;\n-\n-  if (ffebad_is_inhibited_ && !lex_override)\n-    {\n-      ffebad_is_temp_inhibited_ = TRUE;\n-      return FALSE;\n-    }\n-\n-  if (errnum != FFEBAD)\n-    {\n-      ffebad_severity_ = ffebad_messages_[errnum].severity;\n-      ffebad_message_ = gettext (ffebad_messages_[errnum].message);\n-    }\n-  else\n-    {\n-      ffebad_severity_ = sev;\n-      ffebad_message_ = gettext (msgid);\n-    }\n-\n-  switch (ffebad_severity_)\n-    {\t\t\t\t/* Tell toplev.c about this message. */\n-    case FFEBAD_severityINFORMATIONAL:\n-    case FFEBAD_severityTRIVIAL:\n-      if (inhibit_warnings)\n-\t{\t\t\t/* User wants no warnings. */\n-\t  ffebad_is_temp_inhibited_ = TRUE;\n-\t  return FALSE;\n-\t}\n-      /* Fall through.  */\n-    case FFEBAD_severityWARNING:\n-    case FFEBAD_severityPECULIAR:\n-    case FFEBAD_severityPEDANTIC:\n-      if ((ffebad_severity_ != FFEBAD_severityPEDANTIC)\n-\t  || !flag_pedantic_errors)\n-\t{\n-\t  if (!diagnostic_report_warnings_p ())\n-\t    {\t\t\t/* User wants no warnings. */\n-\t      ffebad_is_temp_inhibited_ = TRUE;\n-\t      return FALSE;\n-\t    }\n-\t  diagnostic_kind_count (global_dc, DK_WARNING)++;\n-\t  break;\n-\t}\n-      /* Fall through (PEDANTIC && flag_pedantic_errors).  */\n-    case FFEBAD_severityFATAL:\n-    case FFEBAD_severityWEIRD:\n-    case FFEBAD_severitySEVERE:\n-    case FFEBAD_severityDISASTER:\n-      diagnostic_kind_count (global_dc, DK_ERROR)++;\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  ffebad_is_temp_inhibited_ = FALSE;\n-  ffebad_errnum_ = errnum;\n-  ffebad_index_ = 0;\n-  ffebad_places_ = 0;\n-  for (i = 0; i < FFEBAD_MAX_; ++i)\n-    {\n-      ffebad_string_[i] = NULL;\n-      ffebad_here_[i].line = ffewhere_line_unknown ();\n-      ffebad_here_[i].col = ffewhere_column_unknown ();\n-    }\n-\n-  return TRUE;\n-}\n-\n-/* ffebad_here -- Establish source location of some diagnostic concern\n-\n-   ffebad_here(ffebadIndex i,ffewhereLine line,ffewhereColumn col);\n-\n-   Call ffebad_start to establish the message, ffebad_here and ffebad_string\n-   to send run-time data to it as necessary, then ffebad_finish when through\n-   to actually get it to print (to stderr).  */\n-\n-void\n-ffebad_here (ffebadIndex index, ffewhereLine line, ffewhereColumn col)\n-{\n-  ffewhereLineNumber line_num;\n-  ffewhereLineNumber ln;\n-  ffewhereColumnNumber col_num;\n-  ffewhereColumnNumber cn;\n-  ffebadIndex i;\n-  ffebadIndex j;\n-\n-  if (ffebad_is_temp_inhibited_)\n-    return;\n-\n-  assert (index < FFEBAD_MAX_);\n-  ffebad_here_[index].line = ffewhere_line_use (line);\n-  ffebad_here_[index].col = ffewhere_column_use (col);\n-  if (ffewhere_line_is_unknown (line)\n-      || ffewhere_column_is_unknown (col))\n-    {\n-      ffebad_here_[index].tag = FFEBAD_MAX_;\n-      return;\n-    }\n-  ffebad_here_[index].tag = 0;\t/* For now, though it shouldn't matter. */\n-\n-  /* Sort the source line/col points into the order they occur in the source\n-     file.  Deal with duplicates appropriately. */\n-\n-  line_num = ffewhere_line_number (line);\n-  col_num = ffewhere_column_number (col);\n-\n-  /* Determine where in the ffebad_order_ array this new place should go. */\n-\n-  for (i = 0; i < ffebad_places_; ++i)\n-    {\n-      ln = ffewhere_line_number (ffebad_here_[ffebad_order_[i]].line);\n-      cn = ffewhere_column_number (ffebad_here_[ffebad_order_[i]].col);\n-      if (line_num < ln)\n-\tbreak;\n-      if (line_num == ln)\n-\t{\n-\t  if (col_num == cn)\n-\t    {\n-\t      ffebad_here_[index].tag = i;\n-\t      return;\t\t/* Shouldn't go in, has equivalent. */\n-\t    }\n-\t  else if (col_num < cn)\n-\t    break;\n-\t}\n-    }\n-\n-  /* Before putting new place in ffebad_order_[i], first increment all tags\n-     that are i or greater. */\n-\n-  if (i != ffebad_places_)\n-    {\n-      for (j = 0; j < FFEBAD_MAX_; ++j)\n-\t{\n-\t  if (ffebad_here_[j].tag >= i)\n-\t    ++ffebad_here_[j].tag;\n-\t}\n-    }\n-\n-  /* Then slide all ffebad_order_[] entries at and above i up one entry. */\n-\n-  for (j = ffebad_places_; j > i; --j)\n-    ffebad_order_[j] = ffebad_order_[j - 1];\n-\n-  /* Finally can put new info in ffebad_order_[i]. */\n-\n-  ffebad_order_[i] = index;\n-  ffebad_here_[index].tag = i;\n-  ++ffebad_places_;\n-}\n-\n-/* Establish string for next index (always in order) of message\n-\n-   ffebad_string(const char *string);\n-\n-   Call ffebad_start to establish the message, ffebad_here and ffebad_string\n-   to send run-time data to it as necessary, then ffebad_finish when through\n-   to actually get it to print (to stderr).  Note: don't trash the string\n-   until after calling ffebad_finish, since we just maintain a pointer to\n-   the argument passed in until then.  */\n-\n-void\n-ffebad_string (const char *string)\n-{\n-  if (ffebad_is_temp_inhibited_)\n-    return;\n-\n-  assert (ffebad_index_ != FFEBAD_MAX_);\n-  ffebad_string_[ffebad_index_++] = string;\n-}\n-\n-/* ffebad_finish -- Display error message with where & run-time info\n-\n-   ffebad_finish();\n-\n-   Call ffebad_start to establish the message, ffebad_here and ffebad_string\n-   to send run-time data to it as necessary, then ffebad_finish when through\n-   to actually get it to print (to stderr).  */\n-\n-void\n-ffebad_finish (void)\n-{\n-#define MAX_SPACES 132\n-  static const char *const spaces\n-  = \"...>\\\n-\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\\n-\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\\n-\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\\n-\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\\n-\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\\n-\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\\n-\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\\n-\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\040\\\n-\\040\\040\\040\";\t\t\t/* MAX_SPACES - 1 spaces. */\n-  ffewhereLineNumber last_line_num;\n-  ffewhereLineNumber ln;\n-  ffewhereLineNumber rn;\n-  ffewhereColumnNumber last_col_num;\n-  ffewhereColumnNumber cn;\n-  ffewhereColumnNumber cnt;\n-  ffewhereLine l;\n-  ffebadIndex bi;\n-  unsigned short i;\n-  char pointer;\n-  unsigned char c;\n-  unsigned const char *s;\n-  const char *fn;\n-  static char buf[1024];\n-  int bufi;\n-  int index;\n-\n-  if (ffebad_is_temp_inhibited_)\n-    return;\n-\n-  switch (ffebad_severity_)\n-    {\n-    case FFEBAD_severityINFORMATIONAL:\n-      s = _(\"note:\");\n-      break;\n-\n-    case FFEBAD_severityWARNING:\n-      s = _(\"warning:\");\n-      break;\n-\n-    case FFEBAD_severitySEVERE:\n-      s = _(\"fatal:\");\n-      break;\n-\n-    default:\n-      s = \"\";\n-      break;\n-    }\n-\n-  /* Display the annoying source references. */\n-\n-  last_line_num = 0;\n-  last_col_num = 0;\n-\n-  for (bi = 0; bi < ffebad_places_; ++bi)\n-    {\n-      if (ffebad_places_ == 1)\n-\tpointer = '^';\n-      else\n-\tpointer = '1' + bi;\n-\n-      l = ffebad_here_[ffebad_order_[bi]].line;\n-      ln = ffewhere_line_number (l);\n-      rn = ffewhere_line_filelinenum (l);\n-      cn = ffewhere_column_number (ffebad_here_[ffebad_order_[bi]].col);\n-      fn = ffewhere_line_filename (l);\n-      if (ln != last_line_num)\n-\t{\n-\t  if (bi != 0)\n-\t    fputc ('\\n', stderr);\n-\t  diagnostic_report_current_function (global_dc);\n-\t  fprintf (stderr,\n-\t\t   /* the trailing space on the <file>:<line>: line\n-\t\t      fools emacs19 compilation mode into finding the\n-\t\t      report */\n-\t\t   \"%s:%\" ffewhereLineNumber_f \"u: %s\\n   %s\\n   %s%c\",\n-\t\t   fn, rn,\n-\t\t   s,\n-\t\t   ffewhere_line_content (l),\n-\t\t   &spaces[cn > MAX_SPACES ? 0 : MAX_SPACES - cn + 4],\n-\t\t   pointer);\n-\t  last_line_num = ln;\n-\t  last_col_num = cn;\n-\t  s = _(\"(continued):\");\n-\t}\n-      else\n-\t{\n-\t  cnt = cn - last_col_num;\n-\t  fprintf (stderr,\n-\t\t   \"%s%c\", &spaces[cnt > MAX_SPACES\n-\t\t\t\t   ? 0 : MAX_SPACES - cnt + 4],\n-\t\t   pointer);\n-\t  last_col_num = cn;\n-\t}\n-    }\n-  if (ffebad_places_ == 0)\n-    {\n-      /* Didn't output \"warning:\" string, capitalize it for message.  */\n-      if (s[0] != '\\0')\n-\t{\n-\t  char c;\n-\n-\t  c = TOUPPER (s[0]);\n-\t  fprintf (stderr, \"%c%s \", c, &s[1]);\n-\t}\n-      else if (s[0] != '\\0')\n-\tfprintf (stderr, \"%s \", s);\n-    }\n-  else\n-    fputc ('\\n', stderr);\n-\n-  /* Release the ffewhere info. */\n-\n-  for (bi = 0; bi < FFEBAD_MAX_; ++bi)\n-    {\n-      ffewhere_line_kill (ffebad_here_[bi].line);\n-      ffewhere_column_kill (ffebad_here_[bi].col);\n-    }\n-\n-  /* Now display the message. */\n-\n-  bufi = 0;\n-  for (i = 0; (c = ffebad_message_[i]) != '\\0'; ++i)\n-    {\n-      if (c == '%')\n-\t{\n-\t  c = ffebad_message_[++i];\n-\t  if (ISUPPER (c))\n-\t    {\n-\t      index = c - 'A';\n-\n-\t      if ((index < 0) || (index >= FFEBAD_MAX_))\n-\t\t{\n-\t\t  bufi = ffebad_bufputs_ (buf, bufi, _(\"[REPORT BUG!!] %\"));\n-\t\t  bufi = ffebad_bufputc_ (buf, bufi, c);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  s = ffebad_string_[index];\n-\t\t  if (s == NULL)\n-\t\t    bufi = ffebad_bufputs_ (buf, bufi, _(\"[REPORT BUG!!]\"));\n-\t\t  else\n-\t\t    bufi = ffebad_bufputs_ (buf, bufi, s);\n-\t\t}\n-\t    }\n-\t  else if (ISDIGIT (c))\n-\t    {\n-\t      index = c - '0';\n-\n-\t      if ((index < 0) || (index >= FFEBAD_MAX_))\n-\t\t{\n-\t\t  bufi = ffebad_bufputs_ (buf, bufi, _(\"[REPORT BUG!!] %\"));\n-\t\t  bufi = ffebad_bufputc_ (buf, bufi, c);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  pointer = ffebad_here_[index].tag + '1';\n-\t\t  if (pointer == FFEBAD_MAX_ + '1')\n-\t\t    pointer = '?';\n-\t\t  else if (ffebad_places_ == 1)\n-\t\t    pointer = '^';\n-\t\t  bufi = ffebad_bufputc_ (buf, bufi, '(');\n-\t\t  bufi = ffebad_bufputc_ (buf, bufi, pointer);\n-\t\t  bufi = ffebad_bufputc_ (buf, bufi, ')');\n-\t\t}\n-\t    }\n-\t  else if (c == '\\0')\n-\t    break;\n-\t  else if (c == '%')\n-\t    bufi = ffebad_bufputc_ (buf, bufi, '%');\n-\t  else\n-\t    {\n-\t      bufi = ffebad_bufputs_ (buf, bufi, _(\"[REPORT BUG!!]\"));\n-\t      bufi = ffebad_bufputc_ (buf, bufi, '%');\n-\t      bufi = ffebad_bufputc_ (buf, bufi, c);\n-\t    }\n-\t}\n-      else\n-\tbufi = ffebad_bufputc_ (buf, bufi, c);\n-    }\n-  bufi = ffebad_bufputc_ (buf, bufi, '\\n');\n-  bufi = ffebad_bufflush_ (buf, bufi);\n-}"}, {"sha": "92d7e23303030cbc24128e18dadb72a1d3f1de1e", "filename": "gcc/f/bad.def", "status": "removed", "additions": 0, "deletions": 1103, "changes": 1103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fbad.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fbad.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbad.def?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,1103 +0,0 @@\n-/* bad.def -- Public #include File (module.h template V1.0)\n-   Copyright (C) 1995, 1996, 1997, 2002 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Owning Modules:\n-      bad.c\n-\n-   Modifications:\n-*/\n-\n-#define INFORM FFEBAD_severityINFORMATIONAL\n-#define TRIVIAL FFEBAD_severityTRIVIAL\n-#define WARN FFEBAD_severityWARNING\n-#define PECULIAR FFEBAD_severityPECULIAR\n-#define FATAL FFEBAD_severityFATAL\n-#define WEIRD FFEBAD_severityWEIRD\n-#define SEVERE FFEBAD_severitySEVERE\n-#define DISASTER FFEBAD_severityDISASTER\n-\n-FFEBAD_MSG (FFEBAD_MISSING_FIRST_BINARY_OPERAND, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing first operand for binary operator at %0\")\n-FFEBAD_MSG (FFEBAD_NULL_CHAR_CONST, WARN,\n-/* xgettext:no-c-format */\n-\"Zero-length character constant at %0\")\n-FFEBAD_MSG (FFEBAD_INVALID_TOKEN_IN_EXPRESSION, FATAL,\n-/* xgettext:no-c-format */\n-\"Invalid token at %0 in expression or subexpression at %1\")\n-FFEBAD_MSG (FFEBAD_MISSING_OPERAND_FOR_OPERATOR, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing operand for operator at %1 at end of expression at %0\")\n-FFEBAD_MSG (FFEBAD_LABEL_ALREADY_DEFINED, FATAL,\n-/* xgettext:no-c-format */\n-\"Label %A already defined at %1 when redefined at %0\")\n-FFEBAD_MSG (FFEBAD_UNRECOGNIZED_CHARACTER, FATAL,\n-/* xgettext:no-c-format */\n-\"Unrecognized character at %0 [info -f g77 M LEX]\")\n-FFEBAD_MSG (FFEBAD_LABEL_WITHOUT_STMT, WARN,\n-/* xgettext:no-c-format */\n-\"Label definition %A at %0 on empty statement (as of %1)\")\n-FFEBAD_MSG (FFEBAD_EXTRA_LABEL_DEF, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Extra label definition %A at %0 -- perhaps previous label definition %B at %1 should have CONTINUE statement?\")\n-/* xgettext:no-c-format */\n-SHORT(\"Extra label definition %A at %0 following label definition %B at %1\"))\n-FFEBAD_MSG (FFEBAD_FIRST_CHAR_INVALID, FATAL,\n-/* xgettext:no-c-format */\n-\"Invalid first character at %0 [info -f g77 M LEX]\")\n-FFEBAD_MSG (FFEBAD_LINE_TOO_LONG, FATAL,\n-/* xgettext:no-c-format */\n-\"Line too long as of %0 [info -f g77 M LEX]\")\n-FFEBAD_MSG (FFEBAD_LABEL_FIELD_NOT_NUMERIC, FATAL,\n-/* xgettext:no-c-format */\n-\"Non-numeric character at %0 in label field [info -f g77 M LEX]\")\n-FFEBAD_MSG (FFEBAD_LABEL_NUMBER_INVALID, FATAL,\n-/* xgettext:no-c-format */\n-\"Label number at %0 not in range 1-99999\")\n-FFEBAD_MSG (FFEBAD_NON_ANSI_COMMENT, WARN,\n-/* xgettext:no-c-format */\n-\"At %0, '!' and '/*' are not valid comment delimiters\")\n-FFEBAD_MSG (FFEBAD_NON_ANSI_CONTINUATION_COLUMN, WARN,\n-/* xgettext:no-c-format */\n-\"Continuation indicator at %0 must appear in column 6 [info -f g77 M LEX]\")\n-FFEBAD_MSG (FFEBAD_LABEL_ON_CONTINUATION, FATAL,\n-/* xgettext:no-c-format */\n-\"Label at %0 invalid with continuation line indicator at %1 [info -f g77 M LEX]\")\n-FFEBAD_MSG (FFEBAD_INVALID_CONTINUATION, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Continuation indicator at %0 invalid on first non-comment line of file or following END or INCLUDE [info -f g77 M LEX]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Continuation indicator at %0 invalid here [info -f g77 M LEX]\"))\n-FFEBAD_MSG (FFEBAD_NO_CLOSING_APOSTROPHE, FATAL,\n-/* xgettext:no-c-format */\n-\"Character constant at %0 has no closing apostrophe at %1\")\n-FFEBAD_MSG (FFEBAD_NOT_ENOUGH_HOLLERITH_CHARS, FATAL,\n-/* xgettext:no-c-format */\n-\"Hollerith constant at %0 specified %A more characters than are present as of %1\")\n-FFEBAD_MSG (FFEBAD_MISSING_CLOSE_PAREN, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing close parenthese at %0 needed to match open parenthese at %1\")\n-FFEBAD_MSG (FFEBAD_INTEGER_TOO_LARGE, FATAL,\n-/* xgettext:no-c-format */\n-\"Integer at %0 too large\")\n-FFEBAD_MSG (FFEBAD_BAD_MAGICAL, WARN,\n-/* xgettext:no-c-format */\n-LONG(\"Integer at %0 too large except as negative number (preceded by unary minus sign)\")\n-/* xgettext:no-c-format */\n-SHORT(\"Non-negative integer at %0 too large\"))\n-FFEBAD_MSG (FFEBAD_BAD_MAGICAL_PRECEDENCE, WARN,\n-/* xgettext:no-c-format */\n-LONG(\"Integer at %0 too large; even though preceded by unary minus sign at %1, subsequent operator at %2 has precedence over unary minus -- enclose unary minus sign and integer in parentheses to force precedence\")\n-/* xgettext:no-c-format */\n-SHORT(\"Integer at %0 too large (%2 has precedence over %1)\"))\n-FFEBAD_MSG (FFEBAD_BAD_MAGICAL_BINARY, WARN,\n-/* xgettext:no-c-format */\n-LONG(\"Integer at %0 too large; even though preceded by minus sign at %1, because minus sign is a binary, not unary, operator -- insert plus sign before minus sign to change it to a unary minus sign\")\n-/* xgettext:no-c-format */\n-SHORT(\"Integer at %0 too large (needs unary, not binary, minus at %1)\"))\n-FFEBAD_MSG (FFEBAD_BAD_MAGICAL_PRECEDENCE_BINARY, WARN,\n-/* xgettext:no-c-format */\n-LONG(\"Integer at %0 too large; even though preceded by minus sign at %1, subsequent operator at %2 has precedence over minus, and that minus sign should be a unary minus rather than a binary minus -- insert plus sign before minus sign to change it to a unary minus sign, and enclose unary minus sign and integer in parentheses to force precedence\")\n-/* xgettext:no-c-format */\n-SHORT(\"Integer at %0 too large (%2 has precedence over %1, which needs to be unary, not binary, minus)\"))\n-FFEBAD_MSG (FFEBAD_IGNORING_PERIOD, FATAL,\n-/* xgettext:no-c-format */\n-\"Period at %0 not followed by digits for floating-point number or by `NOT.', `TRUE.', or `FALSE.'\")\n-FFEBAD_MSG (FFEBAD_INSERTING_PERIOD, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing close-period between `.%A' at %0 and %1\")\n-FFEBAD_MSG (FFEBAD_INVALID_EXPONENT, FATAL,\n-/* xgettext:no-c-format */\n-\"Invalid exponent at %0 for real constant at %1; nondigit `%A' in exponent field\")\n-FFEBAD_MSG (FFEBAD_MISSING_EXPONENT_VALUE, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing value at %1 for real-number exponent at %0\")\n-FFEBAD_MSG (FFEBAD_MISSING_BINARY_OPERATOR, FATAL,\n-/* xgettext:no-c-format */\n-\"Expected binary operator between expressions at %0 and at %1\")\n-FFEBAD_MSG (FFEBAD_INVALID_DOTDOT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Period at %0 not followed by valid keyword forming a valid binary operator; `.%A.' is not a valid binary operator\")\n-/* xgettext:no-c-format */\n-SHORT(\"`.%A.' at %0 not a binary operator\"))\n-FFEBAD_MSG (FFEBAD_QUOTE_MISSES_DIGITS, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Double-quote at %0 not followed by a string of valid octal digits at %1\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid octal constant at %0\"))\n-FFEBAD_MSG (FFEBAD_INVALID_BINARY_DIGIT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid binary digit(s) found in string of digits at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid binary constant at %0\"))\n-FFEBAD_MSG (FFEBAD_INVALID_HEX_DIGIT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid hexadecimal digit(s) found in string of digits at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid hexadecimal constant at %0\"))\n-FFEBAD_MSG (FFEBAD_INVALID_OCTAL_DIGIT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid octal digit(s) found in string of digits at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid octal constant at %0\"))\n-FFEBAD_MSG (FFEBAD_INVALID_RADIX_SPECIFIER, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid radix specifier `%A' at %0 for typeless constant at %1\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid typeless constant at %1\"))\n-FFEBAD_MSG (FFEBAD_INVALID_TYPELESS_BINARY_DIGIT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid binary digit(s) found in string of digits at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid binary constant at %0\"))\n-FFEBAD_MSG (FFEBAD_INVALID_TYPELESS_OCTAL_DIGIT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid octal digit(s) found in string of digits at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid octal constant at %0\"))\n-FFEBAD_MSG (FFEBAD_INVALID_TYPELESS_HEX_DIGIT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid hexadecimal digit(s) found in string of digits at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid hexadecimal constant at %0\"))\n-FFEBAD_MSG (FFEBAD_INVALID_COMPLEX_PART, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"%A part of complex constant at %0 must be a real or integer constant -- otherwise use CMPLX() or COMPLEX() in place of ()\")\n-/* xgettext:no-c-format */\n-SHORT(\"%A part of complex constant at %0 not a real or integer constant\"))\n-FFEBAD_MSG (FFEBAD_INVALID_PERCENT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid keyword `%%%A' at %0 in this context\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid keyword `%%%A' at %0\"))\n-FFEBAD_MSG (FFEBAD_NULL_EXPRESSION, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Null expression between %0 and %1 invalid in this context\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid null expression between %0 and %1\"))\n-FFEBAD_MSG (FFEBAD_CONCAT_ARGS_TYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Concatenation operator at %0 must operate on two subexpressions of character type, but neither subexpression at %1 or %2 is of character type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operands at %1 and %2 for concatenation operator at %0\"))\n-FFEBAD_MSG (FFEBAD_CONCAT_ARG_TYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Concatenation operator at %0 must operate on two subexpressions of character type, but the subexpression at %1 is not of character type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand at %1 for concatenation operator at %0\"))\n-FFEBAD_MSG (FFEBAD_CONCAT_ARG_KIND, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Concatenation operator at %0 must operate on two scalar (not array) subexpressions, two function invocations returning character scalars, or a combination of both -- but the subexpression at %1 is %A\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand (is %A) at %1 for concatenation operator at %0\"))\n-FFEBAD_MSG (FFEBAD_MATH_ARGS_TYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Arithmetic operator at %0 must operate on two subexpressions of arithmetic type, but neither subexpression at %1 or %2 is of arithmetic type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operands at %1 and %2 for arithmetic operator at %0\"))\n-FFEBAD_MSG (FFEBAD_MATH_ARG_TYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Arithmetic operator at %0 must operate on two subexpressions of arithmetic type, but the subexpression at %1 is not of arithmetic type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand at %1 for arithmetic operator at %0\"))\n-FFEBAD_MSG (FFEBAD_MATH_ARG_KIND, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Arithmetic operator at %0 must operate on two scalar (not array) subexpressions, two function invocations returning arithmetic scalars, or a combination of both -- but the subexpression at %1 is %A\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand (is %A) at %1 for arithmetic operator at %0\"))\n-FFEBAD_MSG (FFEBAD_NO_CLOSING_QUOTE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Character constant at %0 has no closing quote at %1 [info -f g77 M LEX]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Unterminated character constant at %0 [info -f g77 M LEX]\"))\n-FFEBAD_MSG (FFEBAD_BAD_CHAR_CONTINUE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Continuation line at %0 must have initial `&' since it continues a character context [info -f g77 M LEX]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Missing initial `&' on continuation line at %0 [info -f g77 M LEX]\"))\n-FFEBAD_MSG (FFEBAD_BAD_LEXTOK_CONTINUE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Continuation line at %0 must have initial `&' since it continues a split lexical token [info -f g77 M LEX]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Missing initial `&' on continuation line at %0 [info -f g77 M LEX]\"))\n-FFEBAD_MSG (FFEBAD_BAD_FREE_CONTINUE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Continuation line at %0 invalid because it consists only of a single `&' as the only nonblank character\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid continuation line at %0\"))\n-FFEBAD_MSG (FFEBAD_STMT_BEGINS_BAD, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Statement at %0 begins with invalid token [info -f g77 M LEX]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid statement at %0 [info -f g77 M LEX]\"))\n-FFEBAD_MSG (FFEBAD_SEMICOLON, FATAL,\n-/* xgettext:no-c-format */\n-\"Semicolon at %0 is an invalid token\")\n-FFEBAD_MSG (FFEBAD_UNREC_STMT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Unrecognized statement name at %0 and invalid form for assignment or statement-function definition at %1\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid statement at %0\"))\n-FFEBAD_MSG (FFEBAD_INVALID_STMT_FORM, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid form for %A statement at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid %A statement at %0\"))\n-FFEBAD_MSG (FFEBAD_INVALID_HOLL_IN_STMT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid use of hollerith constant in statement at %0 -- enclose the constant in parentheses (for example, change BACKSPACE 2HAB to BACKSPACE (2HAB))\")\n-/* xgettext:no-c-format */\n-SHORT(\"Enclose hollerith constant in statement at %0 in parentheses\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_EXTRA_COMMA, FATAL,\n-/* xgettext:no-c-format */\n-\"Extraneous comma in FORMAT statement at %0\")\n-FFEBAD_MSG (FFEBAD_FORMAT_MISSING_COMMA, WARN,\n-/* xgettext:no-c-format */\n-\"Missing comma in FORMAT statement at %0\")\n-FFEBAD_MSG (FFEBAD_FORMAT_SPURIOUS_SIGN, FATAL,\n-/* xgettext:no-c-format */\n-\"Spurious sign in FORMAT statement at %0\")\n-FFEBAD_MSG (FFEBAD_FORMAT_SPURIOUS_NUMBER, FATAL,\n-/* xgettext:no-c-format */\n-\"Spurious number in FORMAT statement at %0\")\n-FFEBAD_MSG (FFEBAD_FORMAT_TEXT_IN_NUMBER, FATAL,\n-/* xgettext:no-c-format */\n-\"Spurious text trailing number in FORMAT statement at %0\")\n-FFEBAD_MSG (FFEBAD_FORMAT_P_NOCOMMA, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"nP control edit descriptor not followed by comma but followed by edit descriptor at %0 other than D, E, EN, F, or G\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid edit descriptor at %0 following nP control edit descriptor\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-\"Unrecognized FORMAT specifier at %0\")\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_I_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid I specifier in FORMAT statement at %0 -- correct form: [r]Iw.[m]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid I specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_B_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid B specifier in FORMAT statement at %0 -- correct form: [r]Bw.[m]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid B specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_O_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid O specifier in FORMAT statement at %0 -- correct form: [r]Ow.[m]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid O specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_Z_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid Z specifier in FORMAT statement at %0 -- correct form: [r]Zw.[m]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid Z specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_F_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid F specifier in FORMAT statement at %0 -- correct form: [r]Fw.d\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid F specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_E_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid E specifier in FORMAT statement at %0 -- correct form: [r]Ew.d[Ee]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid E specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_EN_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid EN specifier in FORMAT statement at %0 -- correct form: [r]ENw.d[Ee]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid EN specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_G_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid G specifier in FORMAT statement at %0 -- correct form: [r]Gw.d[Ee]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid G specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_L_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid L specifier in FORMAT statement at %0 -- correct form: [r]Lw\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid L specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_A_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid A specifier in FORMAT statement at %0 -- correct form: [r]A[w]\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid A specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_D_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid D specifier in FORMAT statement at %0 -- correct form: [r]Dw.d\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid D specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_Q_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid Q specifier in FORMAT statement at %0 -- correct form: Q\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid Q specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_DOLLAR_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid $ specifier in FORMAT statement at %0 -- correct form: $\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid $ specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_P_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid P specifier in FORMAT statement at %0 -- correct form: kP\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid P specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_T_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid T specifier in FORMAT statement at %0 -- correct form: Tn\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid T specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_TL_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid TL specifier in FORMAT statement at %0 -- correct form: TLn\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid TL specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_TR_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid TR specifier in FORMAT statement at %0 -- correct form: TRn\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid TR specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_X_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid X specifier in FORMAT statement at %0 -- correct form: nX\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid X specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_S_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid S specifier in FORMAT statement at %0 -- correct form: S\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid S specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_SP_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid SP specifier in FORMAT statement at %0 -- correct form: SP\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid SP specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_SS_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid SS specifier in FORMAT statement at %0 -- correct form: SS\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid SS specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_BN_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid BN specifier in FORMAT statement at %0 -- correct form: BN\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid BN specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_BZ_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid BZ specifier in FORMAT statement at %0 -- correct form: BZ\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid BZ specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_COLON_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid : specifier in FORMAT statement at %0 -- correct form: :\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid : specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_BAD_H_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid H specifier in FORMAT statement at %0 -- correct form: nHcharacters  !where n is an unsigned decimal constant, and characters               !contains exactly n characters (including spaces)\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid H specifier in FORMAT statement at %0\"))\n-FFEBAD_MSG (FFEBAD_FORMAT_MISSING_PAREN, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing close-parenthese(s) in FORMAT statement at %0\")\n-FFEBAD_MSG (FFEBAD_FORMAT_MISSING_DOT, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing number following period in FORMAT statement at %0\")\n-FFEBAD_MSG (FFEBAD_FORMAT_MISSING_EXP, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing number following `E' in FORMAT statement at %0\")\n-FFEBAD_MSG (FFEBAD_FORMAT_EXPR_TOKEN, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid token with FORMAT run-time expression at %0 -- use the traditional operators .LT., .LE., .GT., .GE., .EQ., and .NE. in place of the newer tokens <, <=, >, >=, ==, and !=, because > ends an expression within a FORMAT statement\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid token with FORMAT run-time expression at %0\"))\n-FFEBAD_MSG (FFEBAD_TRAILING_COMMA, WARN,\n-/* xgettext:no-c-format */\n-\"Spurious trailing comma preceding terminator at %0\")\n-FFEBAD_MSG (FFEBAD_INTERFACE_ASSIGNMENT, WARN,\n-/* xgettext:no-c-format */\n-\"At %0, specify OPERATOR instead of ASSIGNMENT for INTERFACE statement not specifying the assignment operator (=)\")\n-FFEBAD_MSG (FFEBAD_INTERFACE_OPERATOR, WARN,\n-/* xgettext:no-c-format */\n-\"At %0, specify ASSIGNMENT instead of OPERATOR for INTERFACE statement specifying the assignment operator (=)\")\n-FFEBAD_MSG (FFEBAD_INTERFACE_NONLETTER, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Defined operator at %0 contains a nonletter -- must contain only letters A-Z (or a-z)\")\n-/* xgettext:no-c-format */\n-SHORT(\"Nonletter in defined operator at %0\"))\n-FFEBAD_MSG (FFEBAD_INVALID_TYPEDECL_ATTR, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid type-declaration attribute at %0 -- must be one of: DIMENSION(array-spec), EXTERNAL, INTRINSIC, PARAMETER, or SAVE\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid type-declaration attribute at %0\"))\n-FFEBAD_MSG (FFEBAD_INVALID_TYPEDECL_INIT, FATAL,\n-/* xgettext:no-c-format */\n-\"Cannot specify =initialization-expr at %0 unless `::' appears before list of objects\")\n-FFEBAD_MSG (FFEBAD_LABEL_USE_DEF, FATAL,\n-/* xgettext:no-c-format */\n-\"Reference to label at %1 inconsistent with its definition at %0\")\n-FFEBAD_MSG (FFEBAD_LABEL_USE_USE, FATAL,\n-/* xgettext:no-c-format */\n-\"Reference to label at %1 inconsistent with earlier reference at %0\")\n-FFEBAD_MSG (FFEBAD_LABEL_DEF_DO, FATAL,\n-/* xgettext:no-c-format */\n-\"DO-statement reference to label at %1 follows its definition at %0\")\n-FFEBAD_MSG (FFEBAD_LABEL_BLOCK, WARN,\n-/* xgettext:no-c-format */\n-\"Reference to label at %1 is outside block containing definition at %0\")\n-FFEBAD_MSG (FFEBAD_LABEL_DO_BLOCK_DO, FATAL,\n-/* xgettext:no-c-format */\n-\"DO-statement references to label at %0 and %2 separated by unterminated block starting at %1\")\n-FFEBAD_MSG (FFEBAD_LABEL_DO_BLOCK_END, FATAL,\n-/* xgettext:no-c-format */\n-\"DO-statement reference to label at %0 and label definition at %2 separated by unterminated block starting at %1\")\n-FFEBAD_MSG (FFEBAD_INVALID_LABEL_DEF, FATAL,\n-/* xgettext:no-c-format */\n-\"Label definition at %0 invalid on this kind of statement\")\n-FFEBAD_MSG (FFEBAD_ORDER_1, FATAL,\n-/* xgettext:no-c-format */\n-\"Statement at %0 invalid in this context\")\n-FFEBAD_MSG (FFEBAD_ORDER_2, FATAL,\n-/* xgettext:no-c-format */\n-\"Statement at %0 invalid in context established by statement at %1\")\n-FFEBAD_MSG (FFEBAD_CONSTRUCT_NAMED, FATAL,\n-/* xgettext:no-c-format */\n-\"Statement at %0 must specify construct name specified at %1\")\n-FFEBAD_MSG (FFEBAD_CONSTRUCT_NOT_NAMED, FATAL,\n-/* xgettext:no-c-format */\n-\"Construct name at %0 superfluous, no construct name specified at %1\")\n-FFEBAD_MSG (FFEBAD_CONSTRUCT_WRONG_NAME, FATAL,\n-/* xgettext:no-c-format */\n-\"Construct name at %0 not the same as construct name at %1\")\n-FFEBAD_MSG (FFEBAD_CONSTRUCT_NO_DO_NAME, FATAL,\n-/* xgettext:no-c-format */\n-\"Construct name at %0 does not match construct name for any containing DO constructs\")\n-FFEBAD_MSG (FFEBAD_DO_HAD_LABEL, FATAL,\n-/* xgettext:no-c-format */\n-\"Label definition missing at %0 for DO construct specifying label at %1\")\n-FFEBAD_MSG (FFEBAD_AFTER_ELSE, FATAL,\n-/* xgettext:no-c-format */\n-\"Statement at %0 follows ELSE block for IF construct at %1\")\n-FFEBAD_MSG (FFEBAD_FORMAT_NO_LABEL_DEF, FATAL,\n-/* xgettext:no-c-format */\n-\"No label definition for FORMAT statement at %0\")\n-FFEBAD_MSG (FFEBAD_SECOND_ELSE_WHERE, FATAL,\n-/* xgettext:no-c-format */\n-\"Second occurrence of ELSE WHERE at %0 within WHERE at %1\")\n-FFEBAD_MSG (FFEBAD_END_WO, WARN,\n-/* xgettext:no-c-format */\n-\"END statement at %0 missing `%A' keyword required for internal or module procedure(s) bounded by %1\")\n-FFEBAD_MSG (FFEBAD_INVALID_MODULE_PROCEDURE, FATAL,\n-/* xgettext:no-c-format */\n-\"MODULE PROCEDURE statement at %0 disallowed because INTERFACE at %1 specifies no generic name, operator, or assignment\")\n-FFEBAD_MSG (FFEBAD_BLOCKDATA_NOT_NAMED, FATAL,\n-/* xgettext:no-c-format */\n-\"BLOCK DATA name at %0 superfluous, no name specified at %1\")\n-FFEBAD_MSG (FFEBAD_PROGRAM_NOT_NAMED, FATAL,\n-/* xgettext:no-c-format */\n-\"Program name at %0 superfluous, no PROGRAM statement specified at %1\")\n-FFEBAD_MSG (FFEBAD_UNIT_WRONG_NAME, FATAL,\n-/* xgettext:no-c-format */\n-\"Program unit name at %0 not the same as name at %1\")\n-FFEBAD_MSG (FFEBAD_TYPE_WRONG_NAME, FATAL,\n-/* xgettext:no-c-format */\n-\"Type name at %0 not the same as name at %1\")\n-FFEBAD_MSG (FFEBAD_EOF_BEFORE_BLOCK_END, FATAL,\n-/* xgettext:no-c-format */\n-\"End of source file before end of block started at %0\")\n-FFEBAD_MSG (FFEBAD_UNDEF_LABEL, FATAL,\n-/* xgettext:no-c-format */\n-\"Undefined label, first referenced at %0\")\n-FFEBAD_MSG (FFEBAD_CONFLICTING_SAVES, WARN,\n-/* xgettext:no-c-format */\n-\"SAVE statement or attribute at %1 cannot be specified along with SAVE statement or attribute at %0\")\n-FFEBAD_MSG (FFEBAD_CONFLICTING_ACCESSES, FATAL,\n-/* xgettext:no-c-format */\n-\"PUBLIC or PRIVATE statement at %1 cannot be specified along with PUBLIC or PRIVATE statement at %0\")\n-FFEBAD_MSG (FFEBAD_RETURN_IN_MAIN, WARN,\n-/* xgettext:no-c-format */\n-\"RETURN statement at %0 invalid within a main program unit\")\n-FFEBAD_MSG (FFEBAD_ALTRETURN_IN_PROGRAM, FATAL,\n-/* xgettext:no-c-format */\n-\"Alternate return specifier at %0 invalid within a main program unit\")\n-FFEBAD_MSG (FFEBAD_ALTRETURN_IN_FUNCTION, FATAL,\n-/* xgettext:no-c-format */\n-\"Alternate return specifier at %0 invalid within a function\")\n-FFEBAD_MSG (FFEBAD_DERIVTYP_ACCESS, FATAL,\n-/* xgettext:no-c-format */\n-\"Access specifier or PRIVATE statement at %0 invalid for derived-type definition within other than the specification part of a module\")\n-FFEBAD_MSG (FFEBAD_DERIVTYP_ACCESS_FIRST, FATAL,\n-/* xgettext:no-c-format */\n-\"Access specifier at %0 must immediately follow derived-type statement at %1 with no intervening statements\")\n-FFEBAD_MSG (FFEBAD_DERIVTYP_NO_COMPONENTS, FATAL,\n-/* xgettext:no-c-format */\n-\"No components specified as of %0 for derived-type definition beginning at %1\")\n-FFEBAD_MSG (FFEBAD_STRUCT_NO_COMPONENTS, FATAL,\n-/* xgettext:no-c-format */\n-\"No components specified as of %0 for structure definition beginning at %1\")\n-FFEBAD_MSG (FFEBAD_STRUCT_MISSING_NAME, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing structure name for outer structure definition at %0\")\n-FFEBAD_MSG (FFEBAD_STRUCT_IGNORING_FIELD, FATAL,\n-/* xgettext:no-c-format */\n-\"Field names at %0 for outer structure definition -- specify them in a subsequent RECORD statement instead\")\n-FFEBAD_MSG (FFEBAD_STRUCT_MISSING_FIELD, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing field name(s) for structure definition at %0 within structure definition at %1\")\n-FFEBAD_MSG (FFEBAD_MAP_NO_COMPONENTS, FATAL,\n-/* xgettext:no-c-format */\n-\"No components specified as of %0 for map beginning at %1\")\n-FFEBAD_MSG (FFEBAD_UNION_NO_TWO_MAPS, FATAL,\n-/* xgettext:no-c-format */\n-\"Zero or one maps specified as of %0 for union beginning at %1 -- at least two are required\")\n-FFEBAD_MSG (FFEBAD_MISSING_SPECIFIER, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing %A specifier in statement at %0\")\n-FFEBAD_MSG (FFEBAD_NAMELIST_ITEMS, FATAL,\n-/* xgettext:no-c-format */\n-\"Items in I/O list starting at %0 invalid for namelist-directed I/O\")\n-FFEBAD_MSG (FFEBAD_CONFLICTING_SPECS, FATAL,\n-/* xgettext:no-c-format */\n-\"Conflicting I/O control specifications at %0 and %1\")\n-FFEBAD_MSG (FFEBAD_NO_UNIT_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-\"No UNIT= specifier in I/O control list at %0\")\n-FFEBAD_MSG (FFEBAD_MISSING_ADVANCE_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-\"Specification at %0 requires ADVANCE=`NO' specification in same I/O control list\")\n-FFEBAD_MSG (FFEBAD_MISSING_FORMAT_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-\"Specification at %0 requires explicit FMT= specification in same I/O control list\")\n-FFEBAD_MSG (FFEBAD_SPEC_VALUE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Unrecognized value for character constant at %0 -- expecting %A\")\n-/* xgettext:no-c-format */\n-SHORT(\"Unrecognized value for character constant at %0\"))\n-FFEBAD_MSG (FFEBAD_CASE_SECOND_DEFAULT, FATAL,\n-/* xgettext:no-c-format */\n-\"Second occurrence of CASE DEFAULT at %0 within SELECT CASE at %1\")\n-FFEBAD_MSG (FFEBAD_CASE_DUPLICATE, FATAL,\n-/* xgettext:no-c-format */\n-\"Duplicate or overlapping case values/ranges at %0 and %1\")\n-FFEBAD_MSG (FFEBAD_CASE_TYPE_DISAGREE, FATAL,\n-/* xgettext:no-c-format */\n-\"Type and/or kind-type parameter disagreement between CASE value or value within range at %0 and SELECT CASE at %1\")\n-FFEBAD_MSG (FFEBAD_CASE_LOGICAL_RANGE, FATAL,\n-/* xgettext:no-c-format */\n-\"Range specification at %0 invalid for CASE statement within logical-type SELECT CASE statement\")\n-FFEBAD_MSG (FFEBAD_CASE_BAD_RANGE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Range specification at %0 invalid -- at least one expression must be specified, or use CASE DEFAULT\")\n-/* xgettext:no-c-format */\n-SHORT(\"Range specification at %0 invalid\"))\n-FFEBAD_MSG (FFEBAD_CASE_RANGE_USELESS, INFORM,\n-/* xgettext:no-c-format */\n-LONG(\"Range specification at %0 useless; first expression greater than second expression in range, so range can never be matched by any selection expression\")\n-/* xgettext:no-c-format */\n-SHORT(\"Useless range at %0\"))\n-FFEBAD_MSG (FFEBAD_F90, FATAL,\n-/* xgettext:no-c-format */\n-\"Fortran 90 feature at %0 unsupported\")\n-FFEBAD_MSG (FFEBAD_KINDTYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid kind at %0 for type at %1 -- unsupported or not permitted\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid kind at %0 for type at %1\"))\n-FFEBAD_MSG (FFEBAD_BAD_IMPLICIT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Cannot establish implicit type for initial letter `%A' at %0 -- already explicitly established or used to set implicit type of some name, or backwards order of letters in letter range\")\n-/* xgettext:no-c-format */\n-SHORT(\"Cannot establish implicit type for initial letter `%A' at %0\"))\n-FFEBAD_MSG (FFEBAD_SYMERR, FATAL,\n-/* xgettext:no-c-format */\n-\"Invalid declaration of or reference to symbol `%A' at %0 [initially seen at %1]\")\n-FFEBAD_MSG (FFEBAD_LABEL_WRONG_PLACE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Label definition %A (at %0) invalid -- must be in columns 1-5\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid label definition %A (at %0)\"))\n-FFEBAD_MSG (FFEBAD_NULL_ELEMENT, FATAL,\n-/* xgettext:no-c-format */\n-\"Null element at %0 for array reference at %1\")\n-FFEBAD_MSG (FFEBAD_TOO_FEW_ELEMENTS, FATAL,\n-/* xgettext:no-c-format */\n-\"Too few elements (%A missing) as of %0 for array reference at %1\")\n-FFEBAD_MSG (FFEBAD_TOO_MANY_ELEMENTS, FATAL,\n-/* xgettext:no-c-format */\n-\"Too many elements as of %0 for array reference at %1\")\n-FFEBAD_MSG (FFEBAD_MISSING_COLON_IN_SUBSTR, FATAL,\n-/* xgettext:no-c-format */\n-\"Missing colon as of %0 in substring reference for %1\")\n-FFEBAD_MSG (FFEBAD_BAD_SUBSTR, FATAL,\n-/* xgettext:no-c-format */\n-\"Invalid use at %0 of substring operator on %1\")\n-FFEBAD_MSG (FFEBAD_RANGE_SUBSTR, WARN,\n-/* xgettext:no-c-format */\n-\"Substring begin/end point at %0 out of defined range\")\n-FFEBAD_MSG (FFEBAD_RANGE_ARRAY, WARN,\n-/* xgettext:no-c-format */\n-\"Array element value at %0 out of defined range\")\n-FFEBAD_MSG (FFEBAD_EXPR_WRONG, FATAL,\n-/* xgettext:no-c-format */\n-\"Expression at %0 has incorrect data type or rank for its context\")\n-FFEBAD_MSG (FFEBAD_DIV_BY_ZERO, WARN,\n-/* xgettext:no-c-format */\n-\"Division by 0 (zero) at %0 (IEEE not yet supported)\")\n-FFEBAD_MSG (FFEBAD_DO_STEP_ZERO, FATAL,\n-/* xgettext:no-c-format */\n-\"%A step count known to be 0 (zero) at %0\")\n-FFEBAD_MSG (FFEBAD_DO_END_OVERFLOW, WARN,\n-/* xgettext:no-c-format */\n-\"%A end value plus step count known to overflow at %0\")\n-FFEBAD_MSG (FFEBAD_DO_IMP_OVERFLOW, WARN,\n-/* xgettext:no-c-format */\n-\"%A begin, end, and step-count values known to result in implementation-dependent behavior due to overflow(s) in intermediate calculations at %0\")\n-FFEBAD_MSG (FFEBAD_DO_NULL, WARN,\n-/* xgettext:no-c-format */\n-\"%A begin, end, and step-count values known to result in no iterations at %0\")\n-FFEBAD_MSG (FFEBAD_BAD_TYPES, FATAL,\n-/* xgettext:no-c-format */\n-\"Type disagreement between expressions at %0 and %1\")\n-FFEBAD_MSG (FFEBAD_FORMAT_EXPR_SPEC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Run-time expression at %0 in FORMAT statement that does not follow the first executable statement in the program unit -- move the statement\")\n-/* xgettext:no-c-format */\n-SHORT(\"FORMAT at %0 with run-time expression must follow first executable statement\"))\n-FFEBAD_MSG (FFEBAD_BAD_IMPDO, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Unexpected token at %0 in implied-DO construct at %1 -- form of implied-DO is `(item-list,do-var=start,end[,incr])'\")\n-/* xgettext:no-c-format */\n-SHORT(\"Unexpected token at %0 in implied-DO construct at %1\"))\n-FFEBAD_MSG (FFEBAD_BAD_IMPDCL, FATAL,\n-/* xgettext:no-c-format */\n-\"No specification for implied-DO iterator `%A' at %0\")\n-FFEBAD_MSG (FFEBAD_IMPDO_PAREN, WARN,\n-/* xgettext:no-c-format */\n-\"Gratuitous parentheses surround implied-DO construct at %0\")\n-FFEBAD_MSG (FFEBAD_ZERO_SIZE, FATAL,\n-/* xgettext:no-c-format */\n-\"Zero-size specification invalid at %0\")\n-FFEBAD_MSG (FFEBAD_ZERO_ARRAY, FATAL,\n-/* xgettext:no-c-format */\n-\"Zero-size array at %0\")\n-FFEBAD_MSG (FFEBAD_BAD_COMPLEX, FATAL,\n-/* xgettext:no-c-format */\n-\"Target machine does not support complex entity of kind specified at %0\")\n-FFEBAD_MSG (FFEBAD_BAD_DBLCMPLX, FATAL,\n-/* xgettext:no-c-format */\n-\"Target machine does not support DOUBLE COMPLEX, specified at %0\")\n-FFEBAD_MSG (FFEBAD_BAD_POWER, WARN,\n-/* xgettext:no-c-format */\n-\"Attempt to raise constant zero to a power at %0\")\n-FFEBAD_MSG (FFEBAD_BOOL_ARGS_TYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Boolean/logical operator at %0 must operate on two subexpressions of logical type, but neither subexpression at %1 or %2 is of logical type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operands at %1 and %2 for boolean operator at %0\"))\n-FFEBAD_MSG (FFEBAD_BOOL_ARG_TYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Boolean/logical operator at %0 must operate on two subexpressions of logical type, but the subexpression at %1 is not of logical type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand at %1 for boolean operator at %0\"))\n-FFEBAD_MSG (FFEBAD_BOOL_ARG_KIND, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Boolean/logical operator at %0 must operate on two scalar (not array) subexpressions, two function invocations returning logical scalars, or a combination of both -- but the subexpression at %1 is %A\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand (is %A) at %1 for boolean operator at %0\"))\n-FFEBAD_MSG (FFEBAD_NOT_ARG_TYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\".NOT. operator at %0 must operate on subexpression of logical type, but the subexpression at %1 is not of logical type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand at %1 for .NOT. operator at %0\"))\n-FFEBAD_MSG (FFEBAD_NOT_ARG_KIND, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\".NOT. operator at %0 must operate on scalar subexpressions -- but the subexpression at %1 is %A\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand (is %A) at %1 for .NOT. operator at %0\"))\n-FFEBAD_MSG (FFEBAD_EQOP_ARGS_TYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Equality operator at %0 must operate on two subexpressions of arithmetic or character type, but neither subexpression at %1 or %2 is of arithmetic or character type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operands at %1 and %2 for equality operator at %0\"))\n-FFEBAD_MSG (FFEBAD_EQOP_ARG_TYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Equality operator at %0 must operate on two subexpressions of arithmetic or character type, but the subexpression at %1 is not of arithmetic or character type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand at %1 for equality operator at %0\"))\n-FFEBAD_MSG (FFEBAD_EQOP_ARG_KIND, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Equality operator at %0 must operate on two scalar (not array) subexpressions, two function invocations returning arithmetic or character scalars, or a combination of both -- but the subexpression at %1 is %A\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand (is %A) at %1 for equality operator at %0\"))\n-FFEBAD_MSG (FFEBAD_RELOP_ARGS_TYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Relational operator at %0 must operate on two subexpressions of integer, real, or character type, but neither subexpression at %1 or %2 is of integer, real, or character type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operands at %1 and %2 for relational operator at %0\"))\n-FFEBAD_MSG (FFEBAD_RELOP_ARG_TYPE, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Relational operator at %0 must operate on two subexpressions of integer, real, or character type, but the subexpression at %1 is not of integer, real, or character type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand at %1 for relational operator at %0\"))\n-FFEBAD_MSG (FFEBAD_RELOP_ARG_KIND, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Relational operator at %0 must operate on two scalar (not array) subexpressions, two function invocations returning integer, real, or character scalars, or a combination of both -- but the subexpression at %1 is %A\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid operand (is %A) at %1 for relational operator at %0\"))\n-FFEBAD_MSG (FFEBAD_INTRINSIC_REF, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Reference to intrinsic `%A' at %0 invalid -- one or more arguments have incorrect type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid reference to intrinsic `%A' at %0\"))\n-FFEBAD_MSG (FFEBAD_INTRINSIC_TOOFEW, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Too few arguments passed to intrinsic `%A' at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Too few arguments for intrinsic `%A' at %0\"))\n-FFEBAD_MSG (FFEBAD_INTRINSIC_TOOMANY, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Too many arguments passed to intrinsic `%A' at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Too many arguments for intrinsic `%A' at %0\"))\n-FFEBAD_MSG (FFEBAD_INTRINSIC_DISABLED, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Reference to disabled intrinsic `%A' at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Disabled intrinsic `%A' at %0\"))\n-FFEBAD_MSG (FFEBAD_INTRINSIC_IS_SUBR, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Reference to intrinsic subroutine `%A' as if it were a function at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Function reference to intrinsic subroutine `%A' at %0\"))\n-FFEBAD_MSG (FFEBAD_INTRINSIC_IS_FUNC, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Reference to intrinsic function `%A' as if it were a subroutine at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Subroutine reference to intrinsic function `%A' at %0\"))\n-FFEBAD_MSG (FFEBAD_INTRINSIC_UNIMPL, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Reference to unimplemented intrinsic `%A' at %0 -- use EXTERNAL to reference user-written procedure with this name\")\n-/* xgettext:no-c-format */\n-SHORT(\"Unimplemented intrinsic `%A' at %0\"))\n-FFEBAD_MSG (FFEBAD_INTRINSIC_UNIMPLW, WARN,\n-/* xgettext:no-c-format */\n-LONG(\"Reference to unimplemented intrinsic `%A' at %0 (assumed EXTERNAL)\")\n-/* xgettext:no-c-format */\n-SHORT(\"Unimplemented intrinsic `%A' at %0 (assumed EXTERNAL)\"))\n-FFEBAD_MSG (FFEBAD_INTRINSIC_AMBIG, FATAL,\n-/* xgettext:no-c-format */\n-\"Reference to generic intrinsic `%A' at %0 could be to form %B or %C\")\n-FFEBAD_MSG (FFEBAD_INTRINSIC_CMPAMBIG, FATAL,\n-/* xgettext:no-c-format */\n-\"Ambiguous use of intrinsic `%A' at %0 [info -f g77 M CMPAMBIG]\")\n-FFEBAD_MSG (FFEBAD_INTRINSIC_EXPIMP, WARN,\n-/* xgettext:no-c-format */\n-\"Intrinsic `%A' referenced %Bly at %0, %Cly at %1 [info -f g77 M EXPIMP]\")\n-FFEBAD_MSG (FFEBAD_INTRINSIC_GLOBAL, WARN,\n-/* xgettext:no-c-format */\n-\"Same name `%A' used for %B at %0 and %C at %1 [info -f g77 M INTGLOB]\")\n-FFEBAD_MSG (FFEBAD_INTRINSIC_TYPE, WARN,\n-/* xgettext:no-c-format */\n-\"Explicit type declaration for intrinsic `%A' disagrees with invocation at %0\")\n-FFEBAD_MSG (FFEBAD_OPEN_INCLUDE, FATAL,\n-/* xgettext:no-c-format */\n-\"Unable to open INCLUDE file `%A' at %0\")\n-FFEBAD_MSG (FFEBAD_DOITER, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Attempt to modify variable `%A' at %0 while it serves as DO-loop iterator at %1\")\n-/* xgettext:no-c-format */\n-SHORT(\"Modification of DO-loop iterator `%A' at %0\"))\n-FFEBAD_MSG (FFEBAD_DOITER_IMPDO, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Attempt to modify variable `%A' via item #%B in list at %0 while it serves as implied-DO iterator at %1\")\n-/* xgettext:no-c-format */\n-SHORT(\"Modification of DO-loop iterator `%A' at %0\"))\n-FFEBAD_MSG (FFEBAD_TOO_MANY_DIMS, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Array has too many dimensions, as of dimension specifier at %0\")\n-/* xgettext:no-c-format */\n-SHORT(\"Too many dimensions at %0\"))\n-FFEBAD_MSG (FFEBAD_NULL_ARGUMENT, FATAL,\n-/* xgettext:no-c-format */\n-\"Null argument at %0 for statement function reference at %1\")\n-FFEBAD_MSG (FFEBAD_NULL_ARGUMENT_W, WARN,\n-/* xgettext:no-c-format */\n-\"Null argument at %0 for procedure invocation at %1\")\n-FFEBAD_MSG (FFEBAD_TOO_FEW_ARGUMENTS, FATAL,\n-/* xgettext:no-c-format */\n-\"%A too few arguments (starting with dummy argument `%B') as of %0 for statement function reference at %1\")\n-FFEBAD_MSG (FFEBAD_TOO_MANY_ARGUMENTS, FATAL,\n-/* xgettext:no-c-format */\n-\"%A too many arguments as of %0 for statement function reference at %1\")\n-FFEBAD_MSG (FFEBAD_ARRAY_AS_SFARG, FATAL,\n-/* xgettext:no-c-format */\n-\"Array supplied at %1 for dummy argument `%A' in statement function reference at %0\")\n-FFEBAD_MSG (FFEBAD_FORMAT_UNSUPPORTED, FATAL,\n-/* xgettext:no-c-format */\n-\"Unsupported FORMAT specifier at %0\")\n-FFEBAD_MSG (FFEBAD_FORMAT_VARIABLE, FATAL,\n-/* xgettext:no-c-format */\n-\"Variable-expression FORMAT specifier at %0 -- unsupported\")\n-FFEBAD_MSG (FFEBAD_OPEN_UNSUPPORTED, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Unsupported OPEN control item at %0 -- ACTION=, ASSOCIATEVARIABLE=, BLOCKSIZE=, BUFFERCOUNT=, CARRIAGECONTROL=, DEFAULTFILE=, DELIM=, DISPOSE=, EXTENDSIZE=, INITIALSIZE=, KEY=, MAXREC=, NOSPANBLOCKS, ORGANIZATION=, PAD=, POSITION=, READONLY=, RECORDTYPE=, SHARED=, and USEROPEN= are not supported\")\n-/* xgettext:no-c-format */\n-SHORT(\"Unsupported OPEN control item at %0\"))\n-FFEBAD_MSG (FFEBAD_INQUIRE_UNSUPPORTED, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Unsupported INQUIRE control item at %0 -- ACTION=, CARRIAGECONTROL=, DEFAULTFILE=, DELIM=, KEYED=, ORGANIZATION=, PAD=, POSITION=, READ=, READWRITE=, RECORDTYPE=, and WRITE= are not supported\")\n-/* xgettext:no-c-format */\n-SHORT(\"Unsupported INQUIRE control item at %0\"))\n-FFEBAD_MSG (FFEBAD_READ_UNSUPPORTED, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Unsupported READ control item at %0 -- ADVANCE=, EOR=, KEYEQ=, KEYGE=, KEYGT=, KEYID=, NULLS=, and SIZE= are not supported\")\n-/* xgettext:no-c-format */\n-SHORT(\"Unsupported READ control item at %0\"))\n-FFEBAD_MSG (FFEBAD_WRITE_UNSUPPORTED, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Unsupported WRITE control item at %0 -- ADVANCE= and EOR= are not supported\")\n-/* xgettext:no-c-format */\n-SHORT(\"Unsupported WRITE control item at %0\"))\n-FFEBAD_MSG (FFEBAD_VXT_UNSUPPORTED, FATAL,\n-/* xgettext:no-c-format */\n-\"Unsupported VXT statement at %0\")\n-FFEBAD_MSG (FFEBAD_DATA_REINIT, FATAL,\n-/* xgettext:no-c-format */\n-\"Attempt to specify second initial value for `%A' at %0\")\n-FFEBAD_MSG (FFEBAD_DATA_TOOFEW, FATAL,\n-/* xgettext:no-c-format */\n-\"Too few initial values in list of initializers for `%A' at %0\")\n-FFEBAD_MSG (FFEBAD_DATA_TOOMANY, FATAL,\n-/* xgettext:no-c-format */\n-\"Too many initial values in list of initializers starting at %0\")\n-FFEBAD_MSG (FFEBAD_DATA_RANGE, FATAL,\n-/* xgettext:no-c-format */\n-\"Array or substring specification for `%A' out of range in statement at %0\")\n-FFEBAD_MSG (FFEBAD_DATA_SUBSCRIPT, FATAL,\n-/* xgettext:no-c-format */\n-\"Array subscript #%B out of range for initialization of `%A' in statement at %0\")\n-FFEBAD_MSG (FFEBAD_DATA_ZERO, FATAL,\n-/* xgettext:no-c-format */\n-\"Implied do-loop step count of 0 (zero) for iteration variable `%A' in statement at %0\")\n-FFEBAD_MSG (FFEBAD_DATA_EMPTY, FATAL,\n-/* xgettext:no-c-format */\n-\"Implied do-loop iteration count of 0 (zero) for iteration variable `%A' in statement at %0\")\n-FFEBAD_MSG (FFEBAD_DATA_EVAL, FATAL,\n-/* xgettext:no-c-format */\n-\"Not an integer constant expression in implied do-loop in statement at %0\")\n-FFEBAD_MSG (FFEBAD_DATA_MULTIPLE, FATAL,\n-/* xgettext:no-c-format */\n-\"Attempt to specify second initial value for element of `%A' at %0\")\n-FFEBAD_MSG (FFEBAD_EQUIV_COMMON, FATAL,\n-/* xgettext:no-c-format */\n-\"Attempt to EQUIVALENCE common areas `%A' and `%B' at %0\")\n-FFEBAD_MSG (FFEBAD_EQUIV_ALIGN, FATAL,\n-/* xgettext:no-c-format */\n-\"Can't place `%A' as directed by EQUIVALENCE due to alignment restrictions\")\n-FFEBAD_MSG (FFEBAD_EQUIV_MISMATCH, FATAL,\n-/* xgettext:no-c-format */\n-\"Mismatched EQUIVALENCE requirements for placement of `%A' at both %C and %D bytes offset from `%B'\")\n-FFEBAD_MSG (FFEBAD_EQUIV_RANGE, FATAL,\n-/* xgettext:no-c-format */\n-\"Array or substring specification for `%A' out of range in EQUIVALENCE statement\")\n-FFEBAD_MSG (FFEBAD_EQUIV_SUBSTR, FATAL,\n-/* xgettext:no-c-format */\n-\"Substring of non-CHARACTER entity `%A' in EQUIVALENCE statement\")\n-FFEBAD_MSG (FFEBAD_EQUIV_ARRAY, FATAL,\n-/* xgettext:no-c-format */\n-\"Array reference to scalar variable `%A' in EQUIVALENCE statement\")\n-FFEBAD_MSG (FFEBAD_EQUIV_SUBSCRIPT, WARN,\n-/* xgettext:no-c-format */\n-\"Array subscript #%B out of range for EQUIVALENCE of `%A'\")\n-FFEBAD_MSG (FFEBAD_COMMON_PAD, WARN,\n-/* xgettext:no-c-format */\n-LONG(\"Padding of %A %D required before `%B' in common block `%C' at %0 -- consider reordering members, largest-type-size first\")\n-/* xgettext:no-c-format */\n-SHORT(\"Padding of %A %D required before `%B' in common block `%C' at %0\"))\n-FFEBAD_MSG (FFEBAD_COMMON_NEG, FATAL,\n-/* xgettext:no-c-format */\n-\"Attempt to extend COMMON area beyond its starting point via EQUIVALENCE of `%A'\")\n-FFEBAD_MSG (FFEBAD_EQUIV_FEW, FATAL,\n-/* xgettext:no-c-format */\n-\"Too few elements in reference to array `%A' in EQUIVALENCE statement\")\n-FFEBAD_MSG (FFEBAD_EQUIV_MANY, FATAL,\n-/* xgettext:no-c-format */\n-\"Too many elements in reference to array `%A' in EQUIVALENCE statement\")\n-FFEBAD_MSG (FFEBAD_MIXED_TYPES, WARN,\n-/* xgettext:no-c-format */\n-\"Mixed CHARACTER and non-CHARACTER types via COMMON/EQUIVALENCE -- for example, `%A' and `%B'\")\n-FFEBAD_MSG (FFEBAD_IMPLICIT_ADJLEN, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid length specification at %0 for IMPLICIT statement -- must be integer constant expression\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid length specification at %0\"))\n-FFEBAD_MSG (FFEBAD_ENTRY_CONFLICTS, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Type of ENTRY point at %0 to function conflicts with type(s) of previous entrypoint(s) -- must all be identical-length CHARACTER or none be CHARACTER type\")\n-/* xgettext:no-c-format */\n-SHORT(\"Type of ENTRY point at %0 to function conflicts with type(s) of previous entrypoint(s)\"))\n-FFEBAD_MSG (FFEBAD_RETURN_VALUE_UNSET, WARN,\n-/* xgettext:no-c-format */\n-\"Return value `%A' for FUNCTION at %0 not referenced in subprogram\")\n-FFEBAD_MSG (FFEBAD_COMMON_ALREADY_INIT, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Common block `%A' initialized at %0 already initialized at %1 -- only one program unit may specify initial values for a particular common block\")\n-/* xgettext:no-c-format */\n-SHORT(\"Common block `%A' initialized at %0 already initialized at %1\"))\n-FFEBAD_MSG (FFEBAD_COMMON_INIT_PAD, WARN,\n-/* xgettext:no-c-format */\n-LONG(\"Initial padding for common block `%A' is %B %C at %0 -- consider reordering members, largest-type-size first\")\n-/* xgettext:no-c-format */\n-SHORT(\"Initial padding for common block `%A' is %B %C at %0\"))\n-FFEBAD_MSG (FFEBAD_COMMON_DIFF_PAD, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Initial padding for common block `%A' is %B %D at %0 but %C %E at %1 -- consider reordering members, largest-type-size first\")\n-/* xgettext:no-c-format */\n-SHORT(\"Initial padding for common block `%A' is %B %D at %0 but %C %E at %1\"))\n-FFEBAD_MSG (FFEBAD_COMMON_DIFF_SAVE, WARN,\n-/* xgettext:no-c-format */\n-\"Common block `%A' is SAVEd, explicitly or implicitly, at %0 but not SAVEd at %1\")\n-FFEBAD_MSG (FFEBAD_COMMON_DIFF_SIZE, WARN,\n-/* xgettext:no-c-format */\n-\"Common block `%A' is %B %D in length at %0 but %C %E at %1\")\n-FFEBAD_MSG (FFEBAD_COMMON_ENLARGED, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Common block `%A' is initialized to %B %D long at %0 but enlarged to %C %E at %1 -- use consistent definitions or reorder program units in source file\")\n-/* xgettext:no-c-format */\n-SHORT(\"Common block `%A' is initialized to %B %D long at %0 but enlarged to %C %E at %1\"))\n-FFEBAD_MSG (FFEBAD_COMMON_BLANK_INIT, WARN,\n-/* xgettext:no-c-format */\n-\"Blank common initialized at %0\")\n-FFEBAD_MSG (FFEBAD_NEED_INTRINSIC, WARN,\n-/* xgettext:no-c-format */\n-\"Intrinsic `%A' is passed as actual argument at %0 but not explicitly declared INTRINSIC\")\n-FFEBAD_MSG (FFEBAD_NEED_EXTERNAL, WARN,\n-/* xgettext:no-c-format */\n-\"External procedure `%A' is passed as actual argument at %0 but not explicitly declared EXTERNAL\")\n-FFEBAD_MSG (FFEBAD_SYMBOL_UPPER_CASE, WARN,\n-/* xgettext:no-c-format */\n-\"Character `%A' (for example) is upper-case in symbol name at %0\")\n-FFEBAD_MSG (FFEBAD_SYMBOL_LOWER_CASE, WARN,\n-/* xgettext:no-c-format */\n-\"Character `%A' (for example) is lower-case in symbol name at %0\")\n-FFEBAD_MSG (FFEBAD_SYMBOL_NOLOWER_INITCAP, WARN,\n-/* xgettext:no-c-format */\n-\"Character `%A' not followed at some point by lower-case character in symbol name at %0\")\n-FFEBAD_MSG (FFEBAD_SYMBOL_LOWER_INITCAP, WARN,\n-/* xgettext:no-c-format */\n-\"Initial character `%A' is lower-case in symbol name at %0\")\n-FFEBAD_MSG (FFEBAD_DO_REAL, WARN,\n-/* xgettext:no-c-format */\n-LONG(\"DO-variable `%A' is type REAL or DOUBLE PRECISION at %0 -- unexpected behavior likely\")\n-/* xgettext:no-c-format */\n-SHORT(\"DO-variable `%A' is type REAL or DOUBLE PRECISION at %0\"))\n-FFEBAD_MSG (FFEBAD_NAMELIST_CASE, WARN,\n-/* xgettext:no-c-format */\n-\"NAMELIST not adequately supported by run-time library for source files with case preserved\")\n-FFEBAD_MSG (FFEBAD_NESTED_PERCENT, WARN,\n-/* xgettext:no-c-format */\n-\"Nested %% construct (%%VAL, %%REF, or %%DESCR) at %0\")\n-FFEBAD_MSG (FFEBAD_ACTUALARG, WARN,\n-/* xgettext:no-c-format */\n-LONG(\"Invalid actual argument at %0 -- replace hollerith constants with %%REF('string') and typeless constants with INTEGER constant equivalents, or use -fugly-args or -fugly\")\n-/* xgettext:no-c-format */\n-SHORT(\"Invalid actual argument at %0\"))\n-FFEBAD_MSG (FFEBAD_QUAD_UNSUPPORTED, FATAL,\n-/* xgettext:no-c-format */\n-LONG(\"Quadruple-precision floating-point unsupported -- treating constant at %0 as double-precision\")\n-/* xgettext:no-c-format */\n-SHORT(\"Quadruple-precision floating-point unsupported\"))\n-FFEBAD_MSG (FFEBAD_TOO_BIG_INIT, WARN,\n-/* xgettext:no-c-format */\n-LONG(\"Initialization of large (%B-unit) aggregate area `%A' at %0 slow and takes lots of memory during g77 compile\")\n-/* xgettext:no-c-format */\n-SHORT(\"This could take a while (initializing `%A' at %0)...\"))\n-FFEBAD_MSG (FFEBAD_BLOCKDATA_STMT, FATAL,\n-/* xgettext:no-c-format */\n-\"Statement at %0 invalid in BLOCK DATA program unit at %1\")\n-FFEBAD_MSG (FFEBAD_TRUNCATING_CHARACTER, FATAL,\n-/* xgettext:no-c-format */\n-\"Truncating characters on right side of character constant at %0\")\n-FFEBAD_MSG (FFEBAD_TRUNCATING_HOLLERITH, FATAL,\n-/* xgettext:no-c-format */\n-\"Truncating characters on right side of hollerith constant at %0\")\n-FFEBAD_MSG (FFEBAD_TRUNCATING_NUMERIC, FATAL,\n-/* xgettext:no-c-format */\n-\"Truncating non-zero data on left side of numeric constant at %0\")\n-FFEBAD_MSG (FFEBAD_TRUNCATING_TYPELESS, FATAL,\n-/* xgettext:no-c-format */\n-\"Truncating non-zero data on left side of typeless constant at %0\")\n-FFEBAD_MSG (FFEBAD_TYPELESS_OVERFLOW, FATAL,\n-/* xgettext:no-c-format */\n-\"Typeless constant at %0 too large\")\n-FFEBAD_MSG (FFEBAD_AMPERSAND, WARN,\n-/* xgettext:no-c-format */\n-\"First-column ampersand continuation at %0\")\n-FFEBAD_MSG (FFEBAD_FILEWIDE_ALREADY_SEEN, FATAL,\n-/* xgettext:no-c-format */\n-\"Global name `%A' defined at %0 already defined at %1 [info -f g77 M GLOBALS]\")\n-FFEBAD_MSG (FFEBAD_FILEWIDE_ALREADY_SEEN_W, WARN,\n-/* xgettext:no-c-format */\n-\"Global name `%A' defined at %0 already defined at %1 [info -f g77 M GLOBALS]\")\n-FFEBAD_MSG (FFEBAD_FILEWIDE_DISAGREEMENT, FATAL,\n-/* xgettext:no-c-format */\n-\"Global name `%A' is %B at %0 but is %C at %1 [info -f g77 M GLOBALS]\")\n-FFEBAD_MSG (FFEBAD_FILEWIDE_DISAGREEMENT_W, WARN,\n-/* xgettext:no-c-format */\n-\"Global name `%A' is %B at %0 but is %C at %1 [info -f g77 M GLOBALS]\")\n-FFEBAD_MSG (FFEBAD_FILEWIDE_TYPE_MISMATCH, FATAL,\n-/* xgettext:no-c-format */\n-\"Global name `%A' at %0 has different type at %1 [info -f g77 M GLOBALS]\")\n-FFEBAD_MSG (FFEBAD_FILEWIDE_TYPE_MISMATCH_W, WARN,\n-/* xgettext:no-c-format */\n-\"Global name `%A' at %0 has different type at %1 [info -f g77 M GLOBALS]\")\n-FFEBAD_MSG (FFEBAD_FILEWIDE_NARGS, FATAL,\n-/* xgettext:no-c-format */\n-\"Too %B arguments passed to `%A' at %0 versus definition at %1 [info -f g77 M GLOBALS]\")\n-FFEBAD_MSG (FFEBAD_FILEWIDE_NARGS_W, WARN,\n-/* xgettext:no-c-format */\n-\"Too %B arguments for `%A' at %0 versus invocation at %1 [info -f g77 M GLOBALS]\")\n-FFEBAD_MSG (FFEBAD_FILEWIDE_ARG, FATAL,\n-/* xgettext:no-c-format */\n-\"Argument #%B of `%A' is %C at %0 but is %D at %1 [info -f g77 M GLOBALS]\")\n-FFEBAD_MSG (FFEBAD_FILEWIDE_ARG_W, WARN,\n-/* xgettext:no-c-format */\n-\"Argument #%B of `%A' is %C at %0 but is %D at %1 [info -f g77 M GLOBALS]\")\n-FFEBAD_MSG (FFEBAD_ARRAY_LARGE, FATAL,\n-/* xgettext:no-c-format */\n-\"Array `%A' at %0 is too large to handle\")\n-FFEBAD_MSG (FFEBAD_SFUNC_UNUSED, WARN,\n-/* xgettext:no-c-format */\n-\"Statement function `%A' defined at %0 is not used\")\n-FFEBAD_MSG (FFEBAD_INTRINSIC_Y2KBAD, WARN,\n-/* xgettext:no-c-format */\n-\"Intrinsic `%A', invoked at %0, known to be non-Y2K-compliant [info -f g77 M Y2KBAD]\")\n-FFEBAD_MSG (FFEBAD_NOCANDO, DISASTER,\n-/* xgettext:no-c-format */\n-\"Internal compiler error -- cannot perform operation\")\n-\n-#undef INFORM\n-#undef TRIVIAL\n-#undef WARN\n-#undef PECULIAR\n-#undef FATAL\n-#undef WEIRD\n-#undef SEVERE\n-#undef DISASTER"}, {"sha": "bd7581e50d95587e74e4c3bdf475c62c41ca78ff", "filename": "gcc/f/bad.h", "status": "removed", "additions": 0, "deletions": 106, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fbad.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fbad.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbad.h?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,106 +0,0 @@\n-/* bad.h -- Public #include File (module.h template V1.0)\n-   Copyright (C) 1995, 2002 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Owning Modules:\n-      bad.c\n-\n-   Modifications:\n-*/\n-\n-/* Allow multiple inclusion to work. */\n-\n-#ifndef GCC_F_BAD_H\n-#define GCC_F_BAD_H\n-\n-/* Simple definitions and enumerations. */\n-\n-typedef enum\n-  {\n-#define FFEBAD_MSG(KWD,SEV,MSG) KWD,\n-#include \"bad.def\"\n-#undef FFEBAD_MSG\n-    FFEBAD\n-  } ffebad;\n-\n-typedef enum\n-  {\n-\n-    /* Order important; must be increasing severity. */\n-\n-    FFEBAD_severityINFORMATIONAL,\t/* User notice. */\n-    FFEBAD_severityTRIVIAL,\t/* Internal notice. */\n-    FFEBAD_severityWARNING,\t/* User warning. */\n-    FFEBAD_severityPECULIAR,\t/* Internal warning. */\n-    FFEBAD_severityPEDANTIC,\t/* Pedantic, could be warning or error. */\n-    FFEBAD_severityFATAL,\t/* User error. */\n-    FFEBAD_severityWEIRD,\t/* Internal error. */\n-    FFEBAD_severitySEVERE,\t/* User error, cannot continue. */\n-    FFEBAD_severityDISASTER,\t/* Internal error, cannot continue. */\n-    FFEBAD_severity\n-  } ffebadSeverity;\n-\n-/* Typedefs. */\n-\n-typedef unsigned char ffebadIndex;\n-\n-/* Include files needed by this one. */\n-\n-#include \"where.h\"\n-\n-/* Structure definitions. */\n-\n-\n-/* Global objects accessed by users of this module. */\n-\n-extern bool ffebad_is_inhibited_;\n-\n-/* Declare functions with prototypes. */\n-\n-void ffebad_finish (void);\n-void ffebad_here (ffebadIndex i, ffewhereLine wl, ffewhereColumn wc);\n-void ffebad_init_0 (void);\n-bool ffebad_is_fatal (ffebad errnum);\n-ffebadSeverity ffebad_severity (ffebad errnum);\n-bool ffebad_start_ (bool lex_override, ffebad errnum, ffebadSeverity sev,\n-\t\t    const char *msgid);\n-void ffebad_string (const char *string);\n-\n-/* Define macros. */\n-\n-#define ffebad_inhibit() (ffebad_is_inhibited_)\n-#define ffebad_init_1()\n-#define ffebad_init_2()\n-#define ffebad_init_3()\n-#define ffebad_init_4()\n-#define ffebad_set_inhibit(f) (ffebad_is_inhibited_ = (f))\n-#define ffebad_start(e) ffebad_start_ (FALSE, (e), FFEBAD_severity, NULL)\n-#define ffebad_start_lex(e) ffebad_start_ (TRUE, (e), FFEBAD_severity, NULL)\n-#define ffebad_start_msg(msgid,s) ffebad_start_ (FALSE, FFEBAD, (s), (msgid))\n-#define ffebad_start_msg_lex(msgid,s) ffebad_start_ (TRUE, FFEBAD, (s), (msgid))\n-#define ffebad_terminate_0()\n-#define ffebad_terminate_1()\n-#define ffebad_terminate_2()\n-#define ffebad_terminate_3()\n-#define ffebad_terminate_4()\n-\n-/* End of #include file. */\n-\n-#endif /* ! GCC_F_BAD_H */"}, {"sha": "00f064b1da22a6c545abd35781f7441cfbf4a3aa", "filename": "gcc/f/bit.c", "status": "removed", "additions": 0, "deletions": 200, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fbit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fbit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbit.c?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,200 +0,0 @@\n-/* bit.c -- Implementation File (module.c template V1.0)\n-   Copyright (C) 1995 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Related Modules:\n-      None\n-\n-   Description:\n-      Tracks arrays of booleans in useful ways.\n-\n-   Modifications:\n-*/\n-\n-/* Include files. */\n-\n-#include \"proj.h\"\n-#include \"bit.h\"\n-#include \"malloc.h\"\n-\n-/* Externals defined here. */\n-\n-\n-/* Simple definitions and enumerations. */\n-\n-\n-/* Internal typedefs. */\n-\n-\n-/* Private include files. */\n-\n-\n-/* Internal structure definitions. */\n-\n-\n-/* Static objects accessed by functions in this module. */\n-\n-\n-/* Static functions (internal). */\n-\n-\n-/* Internal macros. */\n-\f\n-\n-/* ffebit_count -- Count # of bits set a particular way\n-\n-   ffebit b;  // the ffebit object\n-   ffebitCount offset;\t// 0..size-1\n-   bool value;\t// FALSE (0), TRUE (1)\n-   ffebitCount range;  // # bits to test\n-   ffebitCount number;\t// # bits equal to value\n-   ffebit_count(b,offset,value,range,&number);\n-\n-   Sets <number> to # bits at <offset> through <offset + range - 1> set to\n-   <value>.  If <range> is 0, <number> is set to 0.  */\n-\n-void\n-ffebit_count (ffebit b, ffebitCount offset, bool value, ffebitCount range,\n-\t      ffebitCount *number)\n-{\n-  ffebitCount element;\n-  ffebitCount bitno;\n-\n-  assert (offset + range <= b->size);\n-\n-  for (*number = 0; range != 0; --range, ++offset)\n-    {\n-      element = offset / CHAR_BIT;\n-      bitno = offset % CHAR_BIT;\n-      if (value\n-\t  == ((b->bits[element] & ((unsigned char) 1 << bitno)) == 0 ? FALSE : TRUE))\n-\t++ * number;\n-    }\n-}\n-\n-/* ffebit_new -- Create a new ffebit object\n-\n-   ffebit b;\n-   ffebit_kill(b);\n-\n-   Destroys an ffebit object obtained via ffebit_new.  */\n-\n-void\n-ffebit_kill (ffebit b)\n-{\n-  malloc_kill_ks (b->pool, b,\n-\t\t  offsetof (struct _ffebit_, bits)\n-\t\t  + (b->size + CHAR_BIT - 1) / CHAR_BIT);\n-}\n-\n-/* ffebit_new -- Create a new ffebit object\n-\n-   ffebit b;\n-   mallocPool pool;\n-   ffebitCount size;\n-   b = ffebit_new(pool,size);\n-\n-   Allocates an ffebit object that holds the values of <size> bits in pool\n-   <pool>.  */\n-\n-ffebit\n-ffebit_new (mallocPool pool, ffebitCount size)\n-{\n-  ffebit b;\n-\n-  b = malloc_new_zks (pool, \"ffebit\",\n-\t\t      offsetof (struct _ffebit_, bits)\n-\t\t      + (size + CHAR_BIT - 1) / CHAR_BIT,\n-\t\t      0);\n-  b->pool = pool;\n-  b->size = size;\n-\n-  return b;\n-}\n-\n-/* ffebit_set -- Set value of # of bits\n-\n-   ffebit b;  // the ffebit object\n-   ffebitCount offset;\t// 0..size-1\n-   bool value;\t// FALSE (0), TRUE (1)\n-   ffebitCount length;\t// # bits to set starting at offset (usually 1)\n-   ffebit_set(b,offset,value,length);\n-\n-   Sets bit #s <offset> through <offset + length - 1> to <value>.  */\n-\n-void\n-ffebit_set (ffebit b, ffebitCount offset, bool value, ffebitCount length)\n-{\n-  ffebitCount i;\n-  ffebitCount element;\n-  ffebitCount bitno;\n-\n-  assert (offset + length <= b->size);\n-\n-  for (i = 0; i < length; ++i, ++offset)\n-    {\n-      element = offset / CHAR_BIT;\n-      bitno = offset % CHAR_BIT;\n-      b->bits[element] = (((unsigned char) (value ? 1 : 0)) << bitno)\n-\t| (b->bits[element] & ~((unsigned char) 1 << bitno));\n-    }\n-}\n-\n-/* ffebit_test -- Test value of # of bits\n-\n-   ffebit b;  // the ffebit object\n-   ffebitCount offset;\t// 0..size-1\n-   bool value;\t// FALSE (0), TRUE (1)\n-   ffebitCount length;\t// # bits with same value\n-   ffebit_test(b,offset,&value,&length);\n-\n-   Returns value of bits at <offset> through <offset + length - 1> in\n-   <value>.  If <offset> is already at the end of the bit array (if\n-   offset == ffebit_size(b)), <length> is set to 0 and <value> is\n-   undefined.  */\n-\n-void\n-ffebit_test (ffebit b, ffebitCount offset, bool *value, ffebitCount *length)\n-{\n-  ffebitCount i;\n-  ffebitCount element;\n-  ffebitCount bitno;\n-\n-  if (offset >= b->size)\n-    {\n-      assert (offset == b->size);\n-      *length = 0;\n-      return;\n-    }\n-\n-  element = offset / CHAR_BIT;\n-  bitno = offset % CHAR_BIT;\n-  *value = (b->bits[element] & ((unsigned char) 1 << bitno)) == 0 ? FALSE : TRUE;\n-  *length = 1;\n-\n-  for (i = b->size - offset - 1, ++offset; i != 0; --i, ++offset, ++*length)\n-    {\n-      element = offset / CHAR_BIT;\n-      bitno = offset % CHAR_BIT;\n-      if (*value\n-\t  != ((b->bits[element] & ((unsigned char) 1 << bitno)) == 0 ? FALSE : TRUE))\n-\tbreak;\n-    }\n-}"}, {"sha": "6b559efe668ea614ef35be324448cfa4968be4b1", "filename": "gcc/f/bit.h", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fbit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fbit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbit.h?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,84 +0,0 @@\n-/* bit.h -- Public #include File (module.h template V1.0)\n-   Copyright (C) 1995 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Owning Modules:\n-      bit.c\n-\n-   Modifications:\n-*/\n-\n-/* Allow multiple inclusion to work. */\n-\n-#ifndef GCC_F_BIT_H\n-#define GCC_F_BIT_H\n-\n-/* Simple definitions and enumerations. */\n-\n-\n-/* Typedefs. */\n-\n-typedef struct _ffebit_ *ffebit;\n-typedef unsigned long ffebitCount;\n-#define ffebitCount_f \"l\"\n-\n-/* Include files needed by this one. */\n-\n-#include \"malloc.h\"\n-\n-/* Structure definitions. */\n-\n-struct _ffebit_\n-  {\n-    mallocPool pool;\n-    ffebitCount size;\n-    unsigned char bits[1];\n-  };\n-\n-/* Global objects accessed by users of this module. */\n-\n-\n-/* Declare functions with prototypes. */\n-\n-void ffebit_count (ffebit b, ffebitCount offset, bool value, ffebitCount range,\n-\t\t   ffebitCount *number);\n-void ffebit_kill (ffebit b);\n-ffebit ffebit_new (mallocPool pool, ffebitCount size);\n-void ffebit_set (ffebit b, ffebitCount offset, bool value, ffebitCount length);\n-void ffebit_test (ffebit b, ffebitCount offset, bool *value, ffebitCount *length);\n-\n-/* Define macros. */\n-\n-#define ffebit_init_0()\n-#define ffebit_init_1()\n-#define ffebit_init_2()\n-#define ffebit_init_3()\n-#define ffebit_init_4()\n-#define ffebit_pool(b) ((b)->pool)\n-#define ffebit_size(b) ((b)->size)\n-#define ffebit_terminate_0()\n-#define ffebit_terminate_1()\n-#define ffebit_terminate_2()\n-#define ffebit_terminate_3()\n-#define ffebit_terminate_4()\n-\n-/* End of #include file. */\n-\n-#endif /* ! GCC_F_BIT_H */"}, {"sha": "737dcc7e2f69541969c6ef54fe688c9aa633dc4f", "filename": "gcc/f/bld-op.def", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fbld-op.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fbld-op.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbld-op.def?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,69 +0,0 @@\n-/* bld-op.def -- Public #include File (module.h template V1.0)\n-   Copyright (C) 1995 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Owning Modules:\n-      bad.c\n-\n-   Modifications:\n-*/\n-\n-FFEBLD_OP (FFEBLD_opANY, \"ANY\", 0)\n-FFEBLD_OP (FFEBLD_opSTAR, \"STAR\", 0)\t/* For adjustable arrays, alternate return dummies, etc. */\n-FFEBLD_OP (FFEBLD_opCONTER, \"CONTER\", 0)\n-FFEBLD_OP (FFEBLD_opARRTER, \"ARRTER\", 0)\t/* Array of constants (DATA...). */\n-FFEBLD_OP (FFEBLD_opACCTER, \"ACCTER\", 0)\t/* Accreting ARRTER. */\n-FFEBLD_OP (FFEBLD_opSYMTER, \"SYMTER\", 0)\n-FFEBLD_OP (FFEBLD_opITEM, \"ITEM\", 0)\n-FFEBLD_OP (FFEBLD_opUPLUS, \"UPLUS\", 1)\n-FFEBLD_OP (FFEBLD_opUMINUS, \"UMINUS\", 1)\n-FFEBLD_OP (FFEBLD_opADD, \"ADD\", 2)\n-FFEBLD_OP (FFEBLD_opSUBTRACT, \"SUBTRACT\", 2)\n-FFEBLD_OP (FFEBLD_opMULTIPLY, \"MULTIPLY\", 2)\n-FFEBLD_OP (FFEBLD_opDIVIDE, \"DIVIDE\", 2)\n-FFEBLD_OP (FFEBLD_opPOWER, \"POWER\", 2)\n-FFEBLD_OP (FFEBLD_opCONCATENATE, \"CONCATENATE\", 2)\n-FFEBLD_OP (FFEBLD_opNOT, \"NOT\", 1)\n-FFEBLD_OP (FFEBLD_opLT, \"LT\", 2)\n-FFEBLD_OP (FFEBLD_opLE, \"LE\", 2)\n-FFEBLD_OP (FFEBLD_opEQ, \"EQ\", 2)\n-FFEBLD_OP (FFEBLD_opNE, \"NE\", 2)\n-FFEBLD_OP (FFEBLD_opGT, \"GT\", 2)\n-FFEBLD_OP (FFEBLD_opGE, \"GE\", 2)\n-FFEBLD_OP (FFEBLD_opAND, \"AND\", 2)\n-FFEBLD_OP (FFEBLD_opOR, \"OR\", 2)\n-FFEBLD_OP (FFEBLD_opXOR, \"XOR\", 2)\n-FFEBLD_OP (FFEBLD_opEQV, \"EQV\", 2)\n-FFEBLD_OP (FFEBLD_opNEQV, \"NEQV\", 2)\n-FFEBLD_OP (FFEBLD_opPAREN, \"PAREN\", 1)\n-FFEBLD_OP (FFEBLD_opPERCENT_LOC, \"%LOC\", 1)\n-FFEBLD_OP (FFEBLD_opPERCENT_VAL, \"%VAL\", 1)\n-FFEBLD_OP (FFEBLD_opPERCENT_REF, \"%REF\", 1)\n-FFEBLD_OP (FFEBLD_opPERCENT_DESCR, \"%DESCR\", 1)\n-FFEBLD_OP (FFEBLD_opCONVERT, \"CONVERT\", 1)\n-FFEBLD_OP (FFEBLD_opREPEAT, \"REPEAT\", 2)\n-FFEBLD_OP (FFEBLD_opBOUNDS, \"BOUNDS\", 2)\t/* For low:high in dimension lists. */\n-FFEBLD_OP (FFEBLD_opFUNCREF, \"FUNCREF\", 2)\n-FFEBLD_OP (FFEBLD_opSUBRREF, \"SUBRREF\", 2)\n-FFEBLD_OP (FFEBLD_opARRAYREF, \"ARRAYREF\", 2)\n-FFEBLD_OP (FFEBLD_opSUBSTR, \"SUBSTR\", 2)\n-FFEBLD_OP (FFEBLD_opLABTER, \"LABTER\", 0)\n-FFEBLD_OP (FFEBLD_opLABTOK, \"LABTOK\", 0)\t/* Like LABTER but contains ffelexToken instead. */\n-FFEBLD_OP (FFEBLD_opIMPDO, \"IMPDO\", 2)"}, {"sha": "6f96f5bf9c5d1165163af3aa0de1dd73d997e136", "filename": "gcc/f/bld.c", "status": "removed", "additions": 0, "deletions": 2809, "changes": 2809, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fbld.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fbld.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbld.c?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,2809 +0,0 @@\n-/* bld.c -- Implementation File (module.c template V1.0)\n-   Copyright (C) 1995, 1996, 2003 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Related Modules:\n-      None\n-\n-   Description:\n-      The primary \"output\" of the FFE includes ffebld objects, which\n-      connect expressions, operators, and operands together, along with\n-      connecting lists of expressions together for argument or dimension\n-      lists.\n-\n-   Modifications:\n-      30-Aug-92\t JCB  1.1\n-\t Change names of some things for consistency.\n-*/\n-\n-/* Include files. */\n-\n-#include \"proj.h\"\n-#include \"bld.h\"\n-#include \"bit.h\"\n-#include \"info.h\"\n-#include \"lex.h\"\n-#include \"malloc.h\"\n-#include \"target.h\"\n-#include \"where.h\"\n-#include \"real.h\"\n-\n-/* Externals defined here.  */\n-\n-const ffebldArity ffebld_arity_op_[(int) FFEBLD_op]\n-=\n-{\n-#define FFEBLD_OP(KWD,NAME,ARITY) ARITY,\n-#include \"bld-op.def\"\n-#undef FFEBLD_OP\n-};\n-struct _ffebld_pool_stack_ ffebld_pool_stack_;\n-\n-/* Simple definitions and enumerations. */\n-\n-\n-/* Internal typedefs. */\n-\n-\n-/* Private include files. */\n-\n-\n-/* Internal structure definitions. */\n-\n-\n-/* Static objects accessed by functions in this module.\t */\n-\n-#if FFETARGET_okCHARACTER1\n-static ffebldConstant ffebld_constant_character1_;\n-#endif\n-#if FFETARGET_okCOMPLEX1\n-static ffebldConstant ffebld_constant_complex1_;\n-#endif\n-#if FFETARGET_okCOMPLEX2\n-static ffebldConstant ffebld_constant_complex2_;\n-#endif\n-#if FFETARGET_okCOMPLEX3\n-static ffebldConstant ffebld_constant_complex3_;\n-#endif\n-#if FFETARGET_okINTEGER1\n-static ffebldConstant ffebld_constant_integer1_;\n-#endif\n-#if FFETARGET_okINTEGER2\n-static ffebldConstant ffebld_constant_integer2_;\n-#endif\n-#if FFETARGET_okINTEGER3\n-static ffebldConstant ffebld_constant_integer3_;\n-#endif\n-#if FFETARGET_okINTEGER4\n-static ffebldConstant ffebld_constant_integer4_;\n-#endif\n-#if FFETARGET_okLOGICAL1\n-static ffebldConstant ffebld_constant_logical1_;\n-#endif\n-#if FFETARGET_okLOGICAL2\n-static ffebldConstant ffebld_constant_logical2_;\n-#endif\n-#if FFETARGET_okLOGICAL3\n-static ffebldConstant ffebld_constant_logical3_;\n-#endif\n-#if FFETARGET_okLOGICAL4\n-static ffebldConstant ffebld_constant_logical4_;\n-#endif\n-#if FFETARGET_okREAL1\n-static ffebldConstant ffebld_constant_real1_;\n-#endif\n-#if FFETARGET_okREAL2\n-static ffebldConstant ffebld_constant_real2_;\n-#endif\n-#if FFETARGET_okREAL3\n-static ffebldConstant ffebld_constant_real3_;\n-#endif\n-static ffebldConstant ffebld_constant_hollerith_;\n-static ffebldConstant ffebld_constant_typeless_[FFEBLD_constTYPELESS_LAST\n-\t\t\t\t\t  - FFEBLD_constTYPELESS_FIRST + 1];\n-\n-static const char *const ffebld_op_string_[]\n-=\n-{\n-#define FFEBLD_OP(KWD,NAME,ARITY) NAME,\n-#include \"bld-op.def\"\n-#undef FFEBLD_OP\n-};\n-\n-/* Static functions (internal). */\n-\n-\n-/* Internal macros. */\n-\n-#define integerdefault_ CATX(integer,FFETARGET_ktINTEGERDEFAULT)\n-#define logicaldefault_ CATX(logical,FFETARGET_ktLOGICALDEFAULT)\n-#define realdefault_ CATX(real,FFETARGET_ktREALDEFAULT)\n-#define realdouble_ CATX(real,FFETARGET_ktREALDOUBLE)\n-#define realquad_ CATX(real,FFETARGET_ktREALQUAD)\n-\f\n-/* ffebld_constant_cmp -- Compare two constants a la strcmp\n-\n-   ffebldConstant c1, c2;\n-   if (ffebld_constant_cmp(c1,c2) == 0)\n-       // they're equal, else they're not.\n-\n-   Returns -1 if c1 < c2, 0 if c1 == c2, +1 if c1 == c2.  */\n-\n-int\n-ffebld_constant_cmp (ffebldConstant c1, ffebldConstant c2)\n-{\n-  if (c1 == c2)\n-    return 0;\n-\n-  assert (ffebld_constant_type (c1) == ffebld_constant_type (c2));\n-\n-  switch (ffebld_constant_type (c1))\n-    {\n-#if FFETARGET_okINTEGER1\n-    case FFEBLD_constINTEGER1:\n-      return ffetarget_cmp_integer1 (ffebld_constant_integer1 (c1),\n-\t\t\t\t     ffebld_constant_integer1 (c2));\n-#endif\n-\n-#if FFETARGET_okINTEGER2\n-    case FFEBLD_constINTEGER2:\n-      return ffetarget_cmp_integer2 (ffebld_constant_integer2 (c1),\n-\t\t\t\t     ffebld_constant_integer2 (c2));\n-#endif\n-\n-#if FFETARGET_okINTEGER3\n-    case FFEBLD_constINTEGER3:\n-      return ffetarget_cmp_integer3 (ffebld_constant_integer3 (c1),\n-\t\t\t\t     ffebld_constant_integer3 (c2));\n-#endif\n-\n-#if FFETARGET_okINTEGER4\n-    case FFEBLD_constINTEGER4:\n-      return ffetarget_cmp_integer4 (ffebld_constant_integer4 (c1),\n-\t\t\t\t     ffebld_constant_integer4 (c2));\n-#endif\n-\n-#if FFETARGET_okLOGICAL1\n-    case FFEBLD_constLOGICAL1:\n-      return ffetarget_cmp_logical1 (ffebld_constant_logical1 (c1),\n-\t\t\t\t     ffebld_constant_logical1 (c2));\n-#endif\n-\n-#if FFETARGET_okLOGICAL2\n-    case FFEBLD_constLOGICAL2:\n-      return ffetarget_cmp_logical2 (ffebld_constant_logical2 (c1),\n-\t\t\t\t     ffebld_constant_logical2 (c2));\n-#endif\n-\n-#if FFETARGET_okLOGICAL3\n-    case FFEBLD_constLOGICAL3:\n-      return ffetarget_cmp_logical3 (ffebld_constant_logical3 (c1),\n-\t\t\t\t     ffebld_constant_logical3 (c2));\n-#endif\n-\n-#if FFETARGET_okLOGICAL4\n-    case FFEBLD_constLOGICAL4:\n-      return ffetarget_cmp_logical4 (ffebld_constant_logical4 (c1),\n-\t\t\t\t     ffebld_constant_logical4 (c2));\n-#endif\n-\n-#if FFETARGET_okREAL1\n-    case FFEBLD_constREAL1:\n-      return ffetarget_cmp_real1 (ffebld_constant_real1 (c1),\n-\t\t\t\t  ffebld_constant_real1 (c2));\n-#endif\n-\n-#if FFETARGET_okREAL2\n-    case FFEBLD_constREAL2:\n-      return ffetarget_cmp_real2 (ffebld_constant_real2 (c1),\n-\t\t\t\t  ffebld_constant_real2 (c2));\n-#endif\n-\n-#if FFETARGET_okREAL3\n-    case FFEBLD_constREAL3:\n-      return ffetarget_cmp_real3 (ffebld_constant_real3 (c1),\n-\t\t\t\t  ffebld_constant_real3 (c2));\n-#endif\n-\n-#if FFETARGET_okCHARACTER1\n-    case FFEBLD_constCHARACTER1:\n-      return ffetarget_cmp_character1 (ffebld_constant_character1 (c1),\n-\t\t\t\t       ffebld_constant_character1 (c2));\n-#endif\n-\n-    default:\n-      assert (\"bad constant type\" == NULL);\n-      return 0;\n-    }\n-}\n-\n-/* ffebld_constant_is_magical -- Determine if integer is \"magical\"\n-\n-   ffebldConstant c;\n-   if (ffebld_constant_is_magical(c))\n-       // it is 2**(n-1), where n is # bits in ffetargetIntegerDefault type\n-       // (this test is important for 2's-complement machines only).  */\n-\n-bool\n-ffebld_constant_is_magical (ffebldConstant c)\n-{\n-  switch (ffebld_constant_type (c))\n-    {\n-    case FFEBLD_constINTEGERDEFAULT:\n-      return ffetarget_integerdefault_is_magical (ffebld_constant_integer1 (c));\n-\n-    default:\n-      return FALSE;\n-    }\n-}\n-\n-/* Determine if constant is zero.  Used to ensure step count\n-   for DO loops isn't zero, also to determine if values will\n-   be binary zeros, so not entirely portable at this point.  */\n-\n-bool\n-ffebld_constant_is_zero (ffebldConstant c)\n-{\n-  switch (ffebld_constant_type (c))\n-    {\n-#if FFETARGET_okINTEGER1\n-    case FFEBLD_constINTEGER1:\n-      return ffebld_constant_integer1 (c) == 0;\n-#endif\n-\n-#if FFETARGET_okINTEGER2\n-    case FFEBLD_constINTEGER2:\n-      return ffebld_constant_integer2 (c) == 0;\n-#endif\n-\n-#if FFETARGET_okINTEGER3\n-    case FFEBLD_constINTEGER3:\n-      return ffebld_constant_integer3 (c) == 0;\n-#endif\n-\n-#if FFETARGET_okINTEGER4\n-    case FFEBLD_constINTEGER4:\n-      return ffebld_constant_integer4 (c) == 0;\n-#endif\n-\n-#if FFETARGET_okLOGICAL1\n-    case FFEBLD_constLOGICAL1:\n-      return ffebld_constant_logical1 (c) == 0;\n-#endif\n-\n-#if FFETARGET_okLOGICAL2\n-    case FFEBLD_constLOGICAL2:\n-      return ffebld_constant_logical2 (c) == 0;\n-#endif\n-\n-#if FFETARGET_okLOGICAL3\n-    case FFEBLD_constLOGICAL3:\n-      return ffebld_constant_logical3 (c) == 0;\n-#endif\n-\n-#if FFETARGET_okLOGICAL4\n-    case FFEBLD_constLOGICAL4:\n-      return ffebld_constant_logical4 (c) == 0;\n-#endif\n-\n-#if FFETARGET_okREAL1\n-    case FFEBLD_constREAL1:\n-      return ffetarget_iszero_real1 (ffebld_constant_real1 (c));\n-#endif\n-\n-#if FFETARGET_okREAL2\n-    case FFEBLD_constREAL2:\n-      return ffetarget_iszero_real2 (ffebld_constant_real2 (c));\n-#endif\n-\n-#if FFETARGET_okREAL3\n-    case FFEBLD_constREAL3:\n-      return ffetarget_iszero_real3 (ffebld_constant_real3 (c));\n-#endif\n-\n-#if FFETARGET_okCOMPLEX1\n-    case FFEBLD_constCOMPLEX1:\n-      return ffetarget_iszero_real1 (ffebld_constant_complex1 (c).real)\n-     && ffetarget_iszero_real1 (ffebld_constant_complex1 (c).imaginary);\n-#endif\n-\n-#if FFETARGET_okCOMPLEX2\n-    case FFEBLD_constCOMPLEX2:\n-      return ffetarget_iszero_real2 (ffebld_constant_complex2 (c).real)\n-     && ffetarget_iszero_real2 (ffebld_constant_complex2 (c).imaginary);\n-#endif\n-\n-#if FFETARGET_okCOMPLEX3\n-    case FFEBLD_constCOMPLEX3:\n-      return ffetarget_iszero_real3 (ffebld_constant_complex3 (c).real)\n-     && ffetarget_iszero_real3 (ffebld_constant_complex3 (c).imaginary);\n-#endif\n-\n-#if FFETARGET_okCHARACTER1\n-    case FFEBLD_constCHARACTER1:\n-      return ffetarget_iszero_character1 (ffebld_constant_character1 (c));\n-#endif\n-\n-    case FFEBLD_constHOLLERITH:\n-      return ffetarget_iszero_hollerith (ffebld_constant_hollerith (c));\n-\n-    case FFEBLD_constBINARY_MIL:\n-    case FFEBLD_constBINARY_VXT:\n-    case FFEBLD_constOCTAL_MIL:\n-    case FFEBLD_constOCTAL_VXT:\n-    case FFEBLD_constHEX_X_MIL:\n-    case FFEBLD_constHEX_X_VXT:\n-    case FFEBLD_constHEX_Z_MIL:\n-    case FFEBLD_constHEX_Z_VXT:\n-      return ffetarget_iszero_typeless (ffebld_constant_typeless (c));\n-\n-    default:\n-      return FALSE;\n-    }\n-}\n-\n-/* ffebld_constant_new_character1 -- Return character1 constant object from token\n-\n-   See prototype.  */\n-\n-#if FFETARGET_okCHARACTER1\n-ffebldConstant\n-ffebld_constant_new_character1 (ffelexToken t)\n-{\n-  ffetargetCharacter1 val;\n-\n-  ffetarget_character1 (&val, t, ffebld_constant_pool());\n-  return ffebld_constant_new_character1_val (val);\n-}\n-\n-#endif\n-/* ffebld_constant_new_character1_val -- Return an character1 constant object\n-\n-   See prototype.  */\n-\n-#if FFETARGET_okCHARACTER1\n-ffebldConstant\n-ffebld_constant_new_character1_val (ffetargetCharacter1 val)\n-{\n-  ffebldConstant c;\n-  ffebldConstant nc;\n-  int cmp;\n-\n-  ffetarget_verify_character1 (ffebld_constant_pool(), val);\n-\n-  for (c = (ffebldConstant) &ffebld_constant_character1_;\n-       c->next != NULL;\n-       c = c->next)\n-    {\n-      malloc_verify_kp (ffebld_constant_pool(),\n-\t\t\tc->next,\n-\t\t\tsizeof (*(c->next)));\n-      ffetarget_verify_character1 (ffebld_constant_pool(),\n-\t\t\t\t   ffebld_constant_character1 (c->next));\n-      cmp = ffetarget_cmp_character1 (val,\n-\t\t\t\t      ffebld_constant_character1 (c->next));\n-      if (cmp == 0)\n-\treturn c->next;\n-      if (cmp > 0)\n-\tbreak;\n-    }\n-\n-  nc = malloc_new_kp (ffebld_constant_pool(),\n-\t\t      \"FFEBLD_constCHARACTER1\",\n-\t\t      sizeof (*nc));\n-  nc->next = c->next;\n-  nc->consttype = FFEBLD_constCHARACTER1;\n-  nc->u.character1 = val;\n-  nc->hook = FFECOM_constantNULL;\n-  c->next = nc;\n-\n-  return nc;\n-}\n-\n-#endif\n-/* ffebld_constant_new_complex1 -- Return complex1 constant object from token\n-\n-   See prototype.  */\n-\n-#if FFETARGET_okCOMPLEX1\n-ffebldConstant\n-ffebld_constant_new_complex1 (ffebldConstant real,\n-\t\t\t      ffebldConstant imaginary)\n-{\n-  ffetargetComplex1 val;\n-\n-  val.real = ffebld_constant_real1 (real);\n-  val.imaginary = ffebld_constant_real1 (imaginary);\n-  return ffebld_constant_new_complex1_val (val);\n-}\n-\n-#endif\n-/* ffebld_constant_new_complex1_val -- Return a complex1 constant object\n-\n-   See prototype.  */\n-\n-#if FFETARGET_okCOMPLEX1\n-ffebldConstant\n-ffebld_constant_new_complex1_val (ffetargetComplex1 val)\n-{\n-  ffebldConstant c;\n-  ffebldConstant nc;\n-  int cmp;\n-\n-  for (c = (ffebldConstant) &ffebld_constant_complex1_;\n-       c->next != NULL;\n-       c = c->next)\n-    {\n-      cmp = ffetarget_cmp_real1 (val.real, ffebld_constant_complex1 (c->next).real);\n-      if (cmp == 0)\n-\tcmp = ffetarget_cmp_real1 (val.imaginary,\n-\t\t\t      ffebld_constant_complex1 (c->next).imaginary);\n-      if (cmp == 0)\n-\treturn c->next;\n-      if (cmp > 0)\n-\tbreak;\n-    }\n-\n-  nc = malloc_new_kp (ffebld_constant_pool(),\n-\t\t      \"FFEBLD_constCOMPLEX1\",\n-\t\t      sizeof (*nc));\n-  nc->next = c->next;\n-  nc->consttype = FFEBLD_constCOMPLEX1;\n-  nc->u.complex1 = val;\n-  nc->hook = FFECOM_constantNULL;\n-  c->next = nc;\n-\n-  return nc;\n-}\n-\n-#endif\n-/* ffebld_constant_new_complex2 -- Return complex2 constant object from token\n-\n-   See prototype.  */\n-\n-#if FFETARGET_okCOMPLEX2\n-ffebldConstant\n-ffebld_constant_new_complex2 (ffebldConstant real,\n-\t\t\t      ffebldConstant imaginary)\n-{\n-  ffetargetComplex2 val;\n-\n-  val.real = ffebld_constant_real2 (real);\n-  val.imaginary = ffebld_constant_real2 (imaginary);\n-  return ffebld_constant_new_complex2_val (val);\n-}\n-\n-#endif\n-/* ffebld_constant_new_complex2_val -- Return a complex2 constant object\n-\n-   See prototype.  */\n-\n-#if FFETARGET_okCOMPLEX2\n-ffebldConstant\n-ffebld_constant_new_complex2_val (ffetargetComplex2 val)\n-{\n-  ffebldConstant c;\n-  ffebldConstant nc;\n-  int cmp;\n-\n-  for (c = (ffebldConstant) &ffebld_constant_complex2_;\n-       c->next != NULL;\n-       c = c->next)\n-    {\n-      cmp = ffetarget_cmp_real2 (val.real, ffebld_constant_complex2 (c->next).real);\n-      if (cmp == 0)\n-\tcmp = ffetarget_cmp_real2 (val.imaginary,\n-\t\t\t      ffebld_constant_complex2 (c->next).imaginary);\n-      if (cmp == 0)\n-\treturn c->next;\n-      if (cmp > 0)\n-\tbreak;\n-    }\n-\n-  nc = malloc_new_kp (ffebld_constant_pool(),\n-\t\t      \"FFEBLD_constCOMPLEX2\",\n-\t\t      sizeof (*nc));\n-  nc->next = c->next;\n-  nc->consttype = FFEBLD_constCOMPLEX2;\n-  nc->u.complex2 = val;\n-  nc->hook = FFECOM_constantNULL;\n-  c->next = nc;\n-\n-  return nc;\n-}\n-\n-#endif\n-/* ffebld_constant_new_hollerith -- Return hollerith constant object from token\n-\n-   See prototype.  */\n-\n-ffebldConstant\n-ffebld_constant_new_hollerith (ffelexToken t)\n-{\n-  ffetargetHollerith val;\n-\n-  ffetarget_hollerith (&val, t, ffebld_constant_pool());\n-  return ffebld_constant_new_hollerith_val (val);\n-}\n-\n-/* ffebld_constant_new_hollerith_val -- Return an hollerith constant object\n-\n-   See prototype.  */\n-\n-ffebldConstant\n-ffebld_constant_new_hollerith_val (ffetargetHollerith val)\n-{\n-  ffebldConstant c;\n-  ffebldConstant nc;\n-  int cmp;\n-\n-  for (c = (ffebldConstant) &ffebld_constant_hollerith_;\n-       c->next != NULL;\n-       c = c->next)\n-    {\n-      cmp = ffetarget_cmp_hollerith (val, ffebld_constant_hollerith (c->next));\n-      if (cmp == 0)\n-\treturn c->next;\n-      if (cmp > 0)\n-\tbreak;\n-    }\n-\n-  nc = malloc_new_kp (ffebld_constant_pool(),\n-\t\t      \"FFEBLD_constHOLLERITH\",\n-\t\t      sizeof (*nc));\n-  nc->next = c->next;\n-  nc->consttype = FFEBLD_constHOLLERITH;\n-  nc->u.hollerith = val;\n-  nc->hook = FFECOM_constantNULL;\n-  c->next = nc;\n-\n-  return nc;\n-}\n-\n-/* ffebld_constant_new_integer1 -- Return integer1 constant object from token\n-\n-   See prototype.\n-\n-   Parses the token as a decimal integer constant, thus it must be an\n-   FFELEX_typeNUMBER.  */\n-\n-#if FFETARGET_okINTEGER1\n-ffebldConstant\n-ffebld_constant_new_integer1 (ffelexToken t)\n-{\n-  ffetargetInteger1 val;\n-\n-  assert (ffelex_token_type (t) == FFELEX_typeNUMBER);\n-\n-  ffetarget_integer1 (&val, t);\n-  return ffebld_constant_new_integer1_val (val);\n-}\n-\n-#endif\n-/* ffebld_constant_new_integer1_val -- Return an integer1 constant object\n-\n-   See prototype.  */\n-\n-#if FFETARGET_okINTEGER1\n-ffebldConstant\n-ffebld_constant_new_integer1_val (ffetargetInteger1 val)\n-{\n-  ffebldConstant c;\n-  ffebldConstant nc;\n-  int cmp;\n-\n-  for (c = (ffebldConstant) &ffebld_constant_integer1_;\n-       c->next != NULL;\n-       c = c->next)\n-    {\n-      cmp = ffetarget_cmp_integer1 (val, ffebld_constant_integer1 (c->next));\n-      if (cmp == 0)\n-\treturn c->next;\n-      if (cmp > 0)\n-\tbreak;\n-    }\n-\n-  nc = malloc_new_kp (ffebld_constant_pool(),\n-\t\t      \"FFEBLD_constINTEGER1\",\n-\t\t      sizeof (*nc));\n-  nc->next = c->next;\n-  nc->consttype = FFEBLD_constINTEGER1;\n-  nc->u.integer1 = val;\n-  nc->hook = FFECOM_constantNULL;\n-  c->next = nc;\n-\n-  return nc;\n-}\n-\n-#endif\n-/* ffebld_constant_new_integer2_val -- Return an integer2 constant object\n-\n-   See prototype.  */\n-\n-#if FFETARGET_okINTEGER2\n-ffebldConstant\n-ffebld_constant_new_integer2_val (ffetargetInteger2 val)\n-{\n-  ffebldConstant c;\n-  ffebldConstant nc;\n-  int cmp;\n-\n-  for (c = (ffebldConstant) &ffebld_constant_integer2_;\n-       c->next != NULL;\n-       c = c->next)\n-    {\n-      cmp = ffetarget_cmp_integer2 (val, ffebld_constant_integer2 (c->next));\n-      if (cmp == 0)\n-\treturn c->next;\n-      if (cmp > 0)\n-\tbreak;\n-    }\n-\n-  nc = malloc_new_kp (ffebld_constant_pool(),\n-\t\t      \"FFEBLD_constINTEGER2\",\n-\t\t      sizeof (*nc));\n-  nc->next = c->next;\n-  nc->consttype = FFEBLD_constINTEGER2;\n-  nc->u.integer2 = val;\n-  nc->hook = FFECOM_constantNULL;\n-  c->next = nc;\n-\n-  return nc;\n-}\n-\n-#endif\n-/* ffebld_constant_new_integer3_val -- Return an integer3 constant object\n-\n-   See prototype.  */\n-\n-#if FFETARGET_okINTEGER3\n-ffebldConstant\n-ffebld_constant_new_integer3_val (ffetargetInteger3 val)\n-{\n-  ffebldConstant c;\n-  ffebldConstant nc;\n-  int cmp;\n-\n-  for (c = (ffebldConstant) &ffebld_constant_integer3_;\n-       c->next != NULL;\n-       c = c->next)\n-    {\n-      cmp = ffetarget_cmp_integer3 (val, ffebld_constant_integer3 (c->next));\n-      if (cmp == 0)\n-\treturn c->next;\n-      if (cmp > 0)\n-\tbreak;\n-    }\n-\n-  nc = malloc_new_kp (ffebld_constant_pool(),\n-\t\t      \"FFEBLD_constINTEGER3\",\n-\t\t      sizeof (*nc));\n-  nc->next = c->next;\n-  nc->consttype = FFEBLD_constINTEGER3;\n-  nc->u.integer3 = val;\n-  nc->hook = FFECOM_constantNULL;\n-  c->next = nc;\n-\n-  return nc;\n-}\n-\n-#endif\n-/* ffebld_constant_new_integer4_val -- Return an integer4 constant object\n-\n-   See prototype.  */\n-\n-#if FFETARGET_okINTEGER4\n-ffebldConstant\n-ffebld_constant_new_integer4_val (ffetargetInteger4 val)\n-{\n-  ffebldConstant c;\n-  ffebldConstant nc;\n-  int cmp;\n-\n-  for (c = (ffebldConstant) &ffebld_constant_integer4_;\n-       c->next != NULL;\n-       c = c->next)\n-    {\n-      cmp = ffetarget_cmp_integer4 (val, ffebld_constant_integer4 (c->next));\n-      if (cmp == 0)\n-\treturn c->next;\n-      if (cmp > 0)\n-\tbreak;\n-    }\n-\n-  nc = malloc_new_kp (ffebld_constant_pool(),\n-\t\t      \"FFEBLD_constINTEGER4\",\n-\t\t      sizeof (*nc));\n-  nc->next = c->next;\n-  nc->consttype = FFEBLD_constINTEGER4;\n-  nc->u.integer4 = val;\n-  nc->hook = FFECOM_constantNULL;\n-  c->next = nc;\n-\n-  return nc;\n-}\n-\n-#endif\n-/* ffebld_constant_new_integerbinary -- Return binary constant object from token\n-\n-   See prototype.\n-\n-   Parses the token as a binary integer constant, thus it must be an\n-   FFELEX_typeNUMBER.  */\n-\n-ffebldConstant\n-ffebld_constant_new_integerbinary (ffelexToken t)\n-{\n-  ffetargetIntegerDefault val;\n-\n-  assert ((ffelex_token_type (t) == FFELEX_typeNAME)\n-\t  || (ffelex_token_type (t) == FFELEX_typeNUMBER));\n-\n-  ffetarget_integerbinary (&val, t);\n-  return ffebld_constant_new_integerdefault_val (val);\n-}\n-\n-/* ffebld_constant_new_integerhex -- Return hex constant object from token\n-\n-   See prototype.\n-\n-   Parses the token as a hex integer constant, thus it must be an\n-   FFELEX_typeNUMBER.  */\n-\n-ffebldConstant\n-ffebld_constant_new_integerhex (ffelexToken t)\n-{\n-  ffetargetIntegerDefault val;\n-\n-  assert ((ffelex_token_type (t) == FFELEX_typeNAME)\n-\t  || (ffelex_token_type (t) == FFELEX_typeNUMBER));\n-\n-  ffetarget_integerhex (&val, t);\n-  return ffebld_constant_new_integerdefault_val (val);\n-}\n-\n-/* ffebld_constant_new_integeroctal -- Return octal constant object from token\n-\n-   See prototype.\n-\n-   Parses the token as a octal integer constant, thus it must be an\n-   FFELEX_typeNUMBER.  */\n-\n-ffebldConstant\n-ffebld_constant_new_integeroctal (ffelexToken t)\n-{\n-  ffetargetIntegerDefault val;\n-\n-  assert ((ffelex_token_type (t) == FFELEX_typeNAME)\n-\t  || (ffelex_token_type (t) == FFELEX_typeNUMBER));\n-\n-  ffetarget_integeroctal (&val, t);\n-  return ffebld_constant_new_integerdefault_val (val);\n-}\n-\n-/* ffebld_constant_new_logical1 -- Return logical1 constant object from token\n-\n-   See prototype.\n-\n-   Parses the token as a decimal logical constant, thus it must be an\n-   FFELEX_typeNUMBER.  */\n-\n-#if FFETARGET_okLOGICAL1\n-ffebldConstant\n-ffebld_constant_new_logical1 (bool truth)\n-{\n-  ffetargetLogical1 val;\n-\n-  ffetarget_logical1 (&val, truth);\n-  return ffebld_constant_new_logical1_val (val);\n-}\n-\n-#endif\n-/* ffebld_constant_new_logical1_val -- Return a logical1 constant object\n-\n-   See prototype.  */\n-\n-#if FFETARGET_okLOGICAL1\n-ffebldConstant\n-ffebld_constant_new_logical1_val (ffetargetLogical1 val)\n-{\n-  ffebldConstant c;\n-  ffebldConstant nc;\n-  int cmp;\n-\n-  for (c = (ffebldConstant) &ffebld_constant_logical1_;\n-       c->next != NULL;\n-       c = c->next)\n-    {\n-      cmp = ffetarget_cmp_logical1 (val, ffebld_constant_logical1 (c->next));\n-      if (cmp == 0)\n-\treturn c->next;\n-      if (cmp > 0)\n-\tbreak;\n-    }\n-\n-  nc = malloc_new_kp (ffebld_constant_pool(),\n-\t\t      \"FFEBLD_constLOGICAL1\",\n-\t\t      sizeof (*nc));\n-  nc->next = c->next;\n-  nc->consttype = FFEBLD_constLOGICAL1;\n-  nc->u.logical1 = val;\n-  nc->hook = FFECOM_constantNULL;\n-  c->next = nc;\n-\n-  return nc;\n-}\n-\n-#endif\n-/* ffebld_constant_new_logical2_val -- Return a logical2 constant object\n-\n-   See prototype.  */\n-\n-#if FFETARGET_okLOGICAL2\n-ffebldConstant\n-ffebld_constant_new_logical2_val (ffetargetLogical2 val)\n-{\n-  ffebldConstant c;\n-  ffebldConstant nc;\n-  int cmp;\n-\n-  for (c = (ffebldConstant) &ffebld_constant_logical2_;\n-       c->next != NULL;\n-       c = c->next)\n-    {\n-      cmp = ffetarget_cmp_logical2 (val, ffebld_constant_logical2 (c->next));\n-      if (cmp == 0)\n-\treturn c->next;\n-      if (cmp > 0)\n-\tbreak;\n-    }\n-\n-  nc = malloc_new_kp (ffebld_constant_pool(),\n-\t\t      \"FFEBLD_constLOGICAL2\",\n-\t\t      sizeof (*nc));\n-  nc->next = c->next;\n-  nc->consttype = FFEBLD_constLOGICAL2;\n-  nc->u.logical2 = val;\n-  nc->hook = FFECOM_constantNULL;\n-  c->next = nc;\n-\n-  return nc;\n-}\n-\n-#endif\n-/* ffebld_constant_new_logical3_val -- Return a logical3 constant object\n-\n-   See prototype.  */\n-\n-#if FFETARGET_okLOGICAL3\n-ffebldConstant\n-ffebld_constant_new_logical3_val (ffetargetLogical3 val)\n-{\n-  ffebldConstant c;\n-  ffebldConstant nc;\n-  int cmp;\n-\n-  for (c = (ffebldConstant) &ffebld_constant_logical3_;\n-       c->next != NULL;\n-       c = c->next)\n-    {\n-      cmp = ffetarget_cmp_logical3 (val, ffebld_constant_logical3 (c->next));\n-      if (cmp == 0)\n-\treturn c->next;\n-      if (cmp > 0)\n-\tbreak;\n-    }\n-\n-  nc = malloc_new_kp (ffebld_constant_pool(),\n-\t\t      \"FFEBLD_constLOGICAL3\",\n-\t\t      sizeof (*nc));\n-  nc->next = c->next;\n-  nc->consttype = FFEBLD_constLOGICAL3;\n-  nc->u.logical3 = val;\n-  nc->hook = FFECOM_constantNULL;\n-  c->next = nc;\n-\n-  return nc;\n-}\n-\n-#endif\n-/* ffebld_constant_new_logical4_val -- Return a logical4 constant object\n-\n-   See prototype.  */\n-\n-#if FFETARGET_okLOGICAL4\n-ffebldConstant\n-ffebld_constant_new_logical4_val (ffetargetLogical4 val)\n-{\n-  ffebldConstant c;\n-  ffebldConstant nc;\n-  int cmp;\n-\n-  for (c = (ffebldConstant) &ffebld_constant_logical4_;\n-       c->next != NULL;\n-       c = c->next)\n-    {\n-      cmp = ffetarget_cmp_logical4 (val, ffebld_constant_logical4 (c->next));\n-      if (cmp == 0)\n-\treturn c->next;\n-      if (cmp > 0)\n-\tbreak;\n-    }\n-\n-  nc = malloc_new_kp (ffebld_constant_pool(),\n-\t\t      \"FFEBLD_constLOGICAL4\",\n-\t\t      sizeof (*nc));\n-  nc->next = c->next;\n-  nc->consttype = FFEBLD_constLOGICAL4;\n-  nc->u.logical4 = val;\n-  nc->hook = FFECOM_constantNULL;\n-  c->next = nc;\n-\n-  return nc;\n-}\n-\n-#endif\n-/* ffebld_constant_new_real1 -- Return real1 constant object from token\n-\n-   See prototype.  */\n-\n-#if FFETARGET_okREAL1\n-ffebldConstant\n-ffebld_constant_new_real1 (ffelexToken integer, ffelexToken decimal,\n-      ffelexToken fraction, ffelexToken exponent, ffelexToken exponent_sign,\n-\t\t\t   ffelexToken exponent_digits)\n-{\n-  ffetargetReal1 val;\n-\n-  ffetarget_real1 (&val,\n-      integer, decimal, fraction, exponent, exponent_sign, exponent_digits);\n-  return ffebld_constant_new_real1_val (val);\n-}\n-\n-#endif\n-/* ffebld_constant_new_real1_val -- Return an real1 constant object\n-\n-   See prototype.  */\n-\n-#if FFETARGET_okREAL1\n-ffebldConstant\n-ffebld_constant_new_real1_val (ffetargetReal1 val)\n-{\n-  ffebldConstant c;\n-  ffebldConstant nc;\n-  int cmp;\n-\n-  for (c = (ffebldConstant) &ffebld_constant_real1_;\n-       c->next != NULL;\n-       c = c->next)\n-    {\n-      cmp = ffetarget_cmp_real1 (val, ffebld_constant_real1 (c->next));\n-      if (cmp == 0)\n-\treturn c->next;\n-      if (cmp > 0)\n-\tbreak;\n-    }\n-\n-  nc = malloc_new_kp (ffebld_constant_pool(),\n-\t\t      \"FFEBLD_constREAL1\",\n-\t\t      sizeof (*nc));\n-  nc->next = c->next;\n-  nc->consttype = FFEBLD_constREAL1;\n-  nc->u.real1 = val;\n-  nc->hook = FFECOM_constantNULL;\n-  c->next = nc;\n-\n-  return nc;\n-}\n-\n-#endif\n-/* ffebld_constant_new_real2 -- Return real2 constant object from token\n-\n-   See prototype.  */\n-\n-#if FFETARGET_okREAL2\n-ffebldConstant\n-ffebld_constant_new_real2 (ffelexToken integer, ffelexToken decimal,\n-      ffelexToken fraction, ffelexToken exponent, ffelexToken exponent_sign,\n-\t\t\t   ffelexToken exponent_digits)\n-{\n-  ffetargetReal2 val;\n-\n-  ffetarget_real2 (&val,\n-      integer, decimal, fraction, exponent, exponent_sign, exponent_digits);\n-  return ffebld_constant_new_real2_val (val);\n-}\n-\n-#endif\n-/* ffebld_constant_new_real2_val -- Return an real2 constant object\n-\n-   See prototype.  */\n-\n-#if FFETARGET_okREAL2\n-ffebldConstant\n-ffebld_constant_new_real2_val (ffetargetReal2 val)\n-{\n-  ffebldConstant c;\n-  ffebldConstant nc;\n-  int cmp;\n-\n-  for (c = (ffebldConstant) &ffebld_constant_real2_;\n-       c->next != NULL;\n-       c = c->next)\n-    {\n-      cmp = ffetarget_cmp_real2 (val, ffebld_constant_real2 (c->next));\n-      if (cmp == 0)\n-\treturn c->next;\n-      if (cmp > 0)\n-\tbreak;\n-    }\n-\n-  nc = malloc_new_kp (ffebld_constant_pool(),\n-\t\t      \"FFEBLD_constREAL2\",\n-\t\t      sizeof (*nc));\n-  nc->next = c->next;\n-  nc->consttype = FFEBLD_constREAL2;\n-  nc->u.real2 = val;\n-  nc->hook = FFECOM_constantNULL;\n-  c->next = nc;\n-\n-  return nc;\n-}\n-\n-#endif\n-/* ffebld_constant_new_typeless_bm -- Return typeless constant object from token\n-\n-   See prototype.\n-\n-   Parses the token as a decimal integer constant, thus it must be an\n-   FFELEX_typeNUMBER.  */\n-\n-ffebldConstant\n-ffebld_constant_new_typeless_bm (ffelexToken t)\n-{\n-  ffetargetTypeless val;\n-\n-  ffetarget_binarymil (&val, t);\n-  return ffebld_constant_new_typeless_val (FFEBLD_constBINARY_MIL, val);\n-}\n-\n-/* ffebld_constant_new_typeless_bv -- Return typeless constant object from token\n-\n-   See prototype.\n-\n-   Parses the token as a decimal integer constant, thus it must be an\n-   FFELEX_typeNUMBER.  */\n-\n-ffebldConstant\n-ffebld_constant_new_typeless_bv (ffelexToken t)\n-{\n-  ffetargetTypeless val;\n-\n-  ffetarget_binaryvxt (&val, t);\n-  return ffebld_constant_new_typeless_val (FFEBLD_constBINARY_VXT, val);\n-}\n-\n-/* ffebld_constant_new_typeless_hxm -- Return typeless constant object from token\n-\n-   See prototype.\n-\n-   Parses the token as a decimal integer constant, thus it must be an\n-   FFELEX_typeNUMBER.  */\n-\n-ffebldConstant\n-ffebld_constant_new_typeless_hxm (ffelexToken t)\n-{\n-  ffetargetTypeless val;\n-\n-  ffetarget_hexxmil (&val, t);\n-  return ffebld_constant_new_typeless_val (FFEBLD_constHEX_X_MIL, val);\n-}\n-\n-/* ffebld_constant_new_typeless_hxv -- Return typeless constant object from token\n-\n-   See prototype.\n-\n-   Parses the token as a decimal integer constant, thus it must be an\n-   FFELEX_typeNUMBER.  */\n-\n-ffebldConstant\n-ffebld_constant_new_typeless_hxv (ffelexToken t)\n-{\n-  ffetargetTypeless val;\n-\n-  ffetarget_hexxvxt (&val, t);\n-  return ffebld_constant_new_typeless_val (FFEBLD_constHEX_X_VXT, val);\n-}\n-\n-/* ffebld_constant_new_typeless_hzm -- Return typeless constant object from token\n-\n-   See prototype.\n-\n-   Parses the token as a decimal integer constant, thus it must be an\n-   FFELEX_typeNUMBER.  */\n-\n-ffebldConstant\n-ffebld_constant_new_typeless_hzm (ffelexToken t)\n-{\n-  ffetargetTypeless val;\n-\n-  ffetarget_hexzmil (&val, t);\n-  return ffebld_constant_new_typeless_val (FFEBLD_constHEX_Z_MIL, val);\n-}\n-\n-/* ffebld_constant_new_typeless_hzv -- Return typeless constant object from token\n-\n-   See prototype.\n-\n-   Parses the token as a decimal integer constant, thus it must be an\n-   FFELEX_typeNUMBER.  */\n-\n-ffebldConstant\n-ffebld_constant_new_typeless_hzv (ffelexToken t)\n-{\n-  ffetargetTypeless val;\n-\n-  ffetarget_hexzvxt (&val, t);\n-  return ffebld_constant_new_typeless_val (FFEBLD_constHEX_Z_VXT, val);\n-}\n-\n-/* ffebld_constant_new_typeless_om -- Return typeless constant object from token\n-\n-   See prototype.\n-\n-   Parses the token as a decimal integer constant, thus it must be an\n-   FFELEX_typeNUMBER.  */\n-\n-ffebldConstant\n-ffebld_constant_new_typeless_om (ffelexToken t)\n-{\n-  ffetargetTypeless val;\n-\n-  ffetarget_octalmil (&val, t);\n-  return ffebld_constant_new_typeless_val (FFEBLD_constOCTAL_MIL, val);\n-}\n-\n-/* ffebld_constant_new_typeless_ov -- Return typeless constant object from token\n-\n-   See prototype.\n-\n-   Parses the token as a decimal integer constant, thus it must be an\n-   FFELEX_typeNUMBER.  */\n-\n-ffebldConstant\n-ffebld_constant_new_typeless_ov (ffelexToken t)\n-{\n-  ffetargetTypeless val;\n-\n-  ffetarget_octalvxt (&val, t);\n-  return ffebld_constant_new_typeless_val (FFEBLD_constOCTAL_VXT, val);\n-}\n-\n-/* ffebld_constant_new_typeless_val -- Return a typeless constant object\n-\n-   See prototype.  */\n-\n-ffebldConstant\n-ffebld_constant_new_typeless_val (ffebldConst type, ffetargetTypeless val)\n-{\n-  ffebldConstant c;\n-  ffebldConstant nc;\n-  int cmp;\n-\n-  for (c = (ffebldConstant) &ffebld_constant_typeless_[type\n-\t\t\t\t\t      - FFEBLD_constTYPELESS_FIRST];\n-       c->next != NULL;\n-       c = c->next)\n-    {\n-      cmp = ffetarget_cmp_typeless (val, ffebld_constant_typeless (c->next));\n-      if (cmp == 0)\n-\treturn c->next;\n-      if (cmp > 0)\n-\tbreak;\n-    }\n-\n-  nc = malloc_new_kp (ffebld_constant_pool(),\n-\t\t      \"FFEBLD_constTYPELESS\",\n-\t\t      sizeof (*nc));\n-  nc->next = c->next;\n-  nc->consttype = type;\n-  nc->u.typeless = val;\n-  nc->hook = FFECOM_constantNULL;\n-  c->next = nc;\n-\n-  return nc;\n-}\n-\n-/* ffebld_constantarray_get -- Get a value from an array of constants\n-\n-   See prototype.  */\n-\n-ffebldConstantUnion\n-ffebld_constantarray_get (ffebldConstantArray array, ffeinfoBasictype bt,\n-\t\t\t  ffeinfoKindtype kt, ffetargetOffset offset)\n-{\n-  ffebldConstantUnion u;\n-\n-  switch (bt)\n-    {\n-    case FFEINFO_basictypeINTEGER:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okINTEGER1\n-\tcase FFEINFO_kindtypeINTEGER1:\n-\t  u.integer1 = *(array.integer1 + offset);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER2\n-\tcase FFEINFO_kindtypeINTEGER2:\n-\t  u.integer2 = *(array.integer2 + offset);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER3\n-\tcase FFEINFO_kindtypeINTEGER3:\n-\t  u.integer3 = *(array.integer3 + offset);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER4\n-\tcase FFEINFO_kindtypeINTEGER4:\n-\t  u.integer4 = *(array.integer4 + offset);\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad INTEGER kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeLOGICAL:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okLOGICAL1\n-\tcase FFEINFO_kindtypeLOGICAL1:\n-\t  u.logical1 = *(array.logical1 + offset);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL2\n-\tcase FFEINFO_kindtypeLOGICAL2:\n-\t  u.logical2 = *(array.logical2 + offset);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL3\n-\tcase FFEINFO_kindtypeLOGICAL3:\n-\t  u.logical3 = *(array.logical3 + offset);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL4\n-\tcase FFEINFO_kindtypeLOGICAL4:\n-\t  u.logical4 = *(array.logical4 + offset);\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad LOGICAL kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeREAL:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okREAL1\n-\tcase FFEINFO_kindtypeREAL1:\n-\t  u.real1 = *(array.real1 + offset);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL2\n-\tcase FFEINFO_kindtypeREAL2:\n-\t  u.real2 = *(array.real2 + offset);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL3\n-\tcase FFEINFO_kindtypeREAL3:\n-\t  u.real3 = *(array.real3 + offset);\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad REAL kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeCOMPLEX:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okCOMPLEX1\n-\tcase FFEINFO_kindtypeREAL1:\n-\t  u.complex1 = *(array.complex1 + offset);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX2\n-\tcase FFEINFO_kindtypeREAL2:\n-\t  u.complex2 = *(array.complex2 + offset);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX3\n-\tcase FFEINFO_kindtypeREAL3:\n-\t  u.complex3 = *(array.complex3 + offset);\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad COMPLEX kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeCHARACTER:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okCHARACTER1\n-\tcase FFEINFO_kindtypeCHARACTER1:\n-\t  u.character1.length = 1;\n-\t  u.character1.text = array.character1 + offset;\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad CHARACTER kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    default:\n-      assert (\"bad basictype\" == NULL);\n-      break;\n-    }\n-\n-  return u;\n-}\n-\n-/* ffebld_constantarray_new -- Make an array of constants\n-\n-   See prototype.  */\n-\n-ffebldConstantArray\n-ffebld_constantarray_new (ffeinfoBasictype bt,\n-\t\t\t  ffeinfoKindtype kt, ffetargetOffset size)\n-{\n-  ffebldConstantArray ptr;\n-\n-  switch (bt)\n-    {\n-    case FFEINFO_basictypeINTEGER:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okINTEGER1\n-\tcase FFEINFO_kindtypeINTEGER1:\n-\t  ptr.integer1 = malloc_new_zkp (ffebld_constant_pool(),\n-\t\t\t\t\t \"ffebldConstantArray\",\n-\t\t\t\t\t size *= sizeof (ffetargetInteger1),\n-\t\t\t\t\t 0);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER2\n-\tcase FFEINFO_kindtypeINTEGER2:\n-\t  ptr.integer2 = malloc_new_zkp (ffebld_constant_pool(),\n-\t\t\t\t\t \"ffebldConstantArray\",\n-\t\t\t\t\t size *= sizeof (ffetargetInteger2),\n-\t\t\t\t\t 0);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER3\n-\tcase FFEINFO_kindtypeINTEGER3:\n-\t  ptr.integer3 = malloc_new_zkp (ffebld_constant_pool(),\n-\t\t\t\t\t \"ffebldConstantArray\",\n-\t\t\t\t\t size *= sizeof (ffetargetInteger3),\n-\t\t\t\t\t 0);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER4\n-\tcase FFEINFO_kindtypeINTEGER4:\n-\t  ptr.integer4 = malloc_new_zkp (ffebld_constant_pool(),\n-\t\t\t\t\t \"ffebldConstantArray\",\n-\t\t\t\t\t size *= sizeof (ffetargetInteger4),\n-\t\t\t\t\t 0);\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad INTEGER kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeLOGICAL:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okLOGICAL1\n-\tcase FFEINFO_kindtypeLOGICAL1:\n-\t  ptr.logical1 = malloc_new_zkp (ffebld_constant_pool(),\n-\t\t\t\t\t \"ffebldConstantArray\",\n-\t\t\t\t\t size *= sizeof (ffetargetLogical1),\n-\t\t\t\t\t 0);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL2\n-\tcase FFEINFO_kindtypeLOGICAL2:\n-\t  ptr.logical2 = malloc_new_zkp (ffebld_constant_pool(),\n-\t\t\t\t\t \"ffebldConstantArray\",\n-\t\t\t\t\t size *= sizeof (ffetargetLogical2),\n-\t\t\t\t\t 0);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL3\n-\tcase FFEINFO_kindtypeLOGICAL3:\n-\t  ptr.logical3 = malloc_new_zkp (ffebld_constant_pool(),\n-\t\t\t\t\t \"ffebldConstantArray\",\n-\t\t\t\t\t size *= sizeof (ffetargetLogical3),\n-\t\t\t\t\t 0);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL4\n-\tcase FFEINFO_kindtypeLOGICAL4:\n-\t  ptr.logical4 = malloc_new_zkp (ffebld_constant_pool(),\n-\t\t\t\t\t \"ffebldConstantArray\",\n-\t\t\t\t\t size *= sizeof (ffetargetLogical4),\n-\t\t\t\t\t 0);\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad LOGICAL kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeREAL:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okREAL1\n-\tcase FFEINFO_kindtypeREAL1:\n-\t  ptr.real1 = malloc_new_zkp (ffebld_constant_pool(),\n-\t\t\t\t      \"ffebldConstantArray\",\n-\t\t\t\t      size *= sizeof (ffetargetReal1),\n-\t\t\t\t      0);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL2\n-\tcase FFEINFO_kindtypeREAL2:\n-\t  ptr.real2 = malloc_new_zkp (ffebld_constant_pool(),\n-\t\t\t\t      \"ffebldConstantArray\",\n-\t\t\t\t      size *= sizeof (ffetargetReal2),\n-\t\t\t\t      0);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL3\n-\tcase FFEINFO_kindtypeREAL3:\n-\t  ptr.real3 = malloc_new_zkp (ffebld_constant_pool(),\n-\t\t\t\t      \"ffebldConstantArray\",\n-\t\t\t\t      size *= sizeof (ffetargetReal3),\n-\t\t\t\t      0);\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad REAL kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeCOMPLEX:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okCOMPLEX1\n-\tcase FFEINFO_kindtypeREAL1:\n-\t  ptr.complex1 = malloc_new_zkp (ffebld_constant_pool(),\n-\t\t\t\t\t \"ffebldConstantArray\",\n-\t\t\t\t\t size *= sizeof (ffetargetComplex1),\n-\t\t\t\t\t 0);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX2\n-\tcase FFEINFO_kindtypeREAL2:\n-\t  ptr.complex2 = malloc_new_zkp (ffebld_constant_pool(),\n-\t\t\t\t\t \"ffebldConstantArray\",\n-\t\t\t\t\t size *= sizeof (ffetargetComplex2),\n-\t\t\t\t\t 0);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX3\n-\tcase FFEINFO_kindtypeREAL3:\n-\t  ptr.complex3 = malloc_new_zkp (ffebld_constant_pool(),\n-\t\t\t\t\t \"ffebldConstantArray\",\n-\t\t\t\t\t size *= sizeof (ffetargetComplex3),\n-\t\t\t\t\t 0);\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad COMPLEX kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeCHARACTER:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okCHARACTER1\n-\tcase FFEINFO_kindtypeCHARACTER1:\n-\t  ptr.character1 = malloc_new_zkp (ffebld_constant_pool(),\n-\t\t\t\t\t   \"ffebldConstantArray\",\n-\t\t\t\t\t   size\n-\t\t\t\t\t   *= sizeof (ffetargetCharacterUnit1),\n-\t\t\t\t\t   0);\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad CHARACTER kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    default:\n-      assert (\"bad basictype\" == NULL);\n-      break;\n-    }\n-\n-  return ptr;\n-}\n-\n-/* ffebld_constantarray_preparray -- Prepare for copy between arrays\n-\n-   See prototype.\n-\n-   Like _prepare, but the source is an array instead of a single-value\n-   constant.  */\n-\n-void\n-ffebld_constantarray_preparray (void **aptr, void **cptr, size_t *size,\n-       ffebldConstantArray array, ffeinfoBasictype abt, ffeinfoKindtype akt,\n-\t\t   ffetargetOffset offset, ffebldConstantArray source_array,\n-\t\t\t\tffeinfoBasictype cbt, ffeinfoKindtype ckt)\n-{\n-  switch (abt)\n-    {\n-    case FFEINFO_basictypeINTEGER:\n-      switch (akt)\n-\t{\n-#if FFETARGET_okINTEGER1\n-\tcase FFEINFO_kindtypeINTEGER1:\n-\t  *aptr = array.integer1 + offset;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER2\n-\tcase FFEINFO_kindtypeINTEGER2:\n-\t  *aptr = array.integer2 + offset;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER3\n-\tcase FFEINFO_kindtypeINTEGER3:\n-\t  *aptr = array.integer3 + offset;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER4\n-\tcase FFEINFO_kindtypeINTEGER4:\n-\t  *aptr = array.integer4 + offset;\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad INTEGER akindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeLOGICAL:\n-      switch (akt)\n-\t{\n-#if FFETARGET_okLOGICAL1\n-\tcase FFEINFO_kindtypeLOGICAL1:\n-\t  *aptr = array.logical1 + offset;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL2\n-\tcase FFEINFO_kindtypeLOGICAL2:\n-\t  *aptr = array.logical2 + offset;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL3\n-\tcase FFEINFO_kindtypeLOGICAL3:\n-\t  *aptr = array.logical3 + offset;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL4\n-\tcase FFEINFO_kindtypeLOGICAL4:\n-\t  *aptr = array.logical4 + offset;\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad LOGICAL akindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeREAL:\n-      switch (akt)\n-\t{\n-#if FFETARGET_okREAL1\n-\tcase FFEINFO_kindtypeREAL1:\n-\t  *aptr = array.real1 + offset;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL2\n-\tcase FFEINFO_kindtypeREAL2:\n-\t  *aptr = array.real2 + offset;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL3\n-\tcase FFEINFO_kindtypeREAL3:\n-\t  *aptr = array.real3 + offset;\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad REAL akindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeCOMPLEX:\n-      switch (akt)\n-\t{\n-#if FFETARGET_okCOMPLEX1\n-\tcase FFEINFO_kindtypeREAL1:\n-\t  *aptr = array.complex1 + offset;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX2\n-\tcase FFEINFO_kindtypeREAL2:\n-\t  *aptr = array.complex2 + offset;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX3\n-\tcase FFEINFO_kindtypeREAL3:\n-\t  *aptr = array.complex3 + offset;\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad COMPLEX akindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeCHARACTER:\n-      switch (akt)\n-\t{\n-#if FFETARGET_okCHARACTER1\n-\tcase FFEINFO_kindtypeCHARACTER1:\n-\t  *aptr = array.character1 + offset;\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad CHARACTER akindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    default:\n-      assert (\"bad abasictype\" == NULL);\n-      break;\n-    }\n-\n-  switch (cbt)\n-    {\n-    case FFEINFO_basictypeINTEGER:\n-      switch (ckt)\n-\t{\n-#if FFETARGET_okINTEGER1\n-\tcase FFEINFO_kindtypeINTEGER1:\n-\t  *cptr = source_array.integer1;\n-\t  *size = sizeof (*source_array.integer1);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER2\n-\tcase FFEINFO_kindtypeINTEGER2:\n-\t  *cptr = source_array.integer2;\n-\t  *size = sizeof (*source_array.integer2);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER3\n-\tcase FFEINFO_kindtypeINTEGER3:\n-\t  *cptr = source_array.integer3;\n-\t  *size = sizeof (*source_array.integer3);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER4\n-\tcase FFEINFO_kindtypeINTEGER4:\n-\t  *cptr = source_array.integer4;\n-\t  *size = sizeof (*source_array.integer4);\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad INTEGER ckindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeLOGICAL:\n-      switch (ckt)\n-\t{\n-#if FFETARGET_okLOGICAL1\n-\tcase FFEINFO_kindtypeLOGICAL1:\n-\t  *cptr = source_array.logical1;\n-\t  *size = sizeof (*source_array.logical1);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL2\n-\tcase FFEINFO_kindtypeLOGICAL2:\n-\t  *cptr = source_array.logical2;\n-\t  *size = sizeof (*source_array.logical2);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL3\n-\tcase FFEINFO_kindtypeLOGICAL3:\n-\t  *cptr = source_array.logical3;\n-\t  *size = sizeof (*source_array.logical3);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL4\n-\tcase FFEINFO_kindtypeLOGICAL4:\n-\t  *cptr = source_array.logical4;\n-\t  *size = sizeof (*source_array.logical4);\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad LOGICAL ckindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeREAL:\n-      switch (ckt)\n-\t{\n-#if FFETARGET_okREAL1\n-\tcase FFEINFO_kindtypeREAL1:\n-\t  *cptr = source_array.real1;\n-\t  *size = sizeof (*source_array.real1);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL2\n-\tcase FFEINFO_kindtypeREAL2:\n-\t  *cptr = source_array.real2;\n-\t  *size = sizeof (*source_array.real2);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL3\n-\tcase FFEINFO_kindtypeREAL3:\n-\t  *cptr = source_array.real3;\n-\t  *size = sizeof (*source_array.real3);\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad REAL ckindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeCOMPLEX:\n-      switch (ckt)\n-\t{\n-#if FFETARGET_okCOMPLEX1\n-\tcase FFEINFO_kindtypeREAL1:\n-\t  *cptr = source_array.complex1;\n-\t  *size = sizeof (*source_array.complex1);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX2\n-\tcase FFEINFO_kindtypeREAL2:\n-\t  *cptr = source_array.complex2;\n-\t  *size = sizeof (*source_array.complex2);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX3\n-\tcase FFEINFO_kindtypeREAL3:\n-\t  *cptr = source_array.complex3;\n-\t  *size = sizeof (*source_array.complex3);\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad COMPLEX ckindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeCHARACTER:\n-      switch (ckt)\n-\t{\n-#if FFETARGET_okCHARACTER1\n-\tcase FFEINFO_kindtypeCHARACTER1:\n-\t  *cptr = source_array.character1;\n-\t  *size = sizeof (*source_array.character1);\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad CHARACTER ckindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    default:\n-      assert (\"bad cbasictype\" == NULL);\n-      break;\n-    }\n-}\n-\n-/* ffebld_constantarray_prepare -- Prepare for copy between value and array\n-\n-   See prototype.\n-\n-   Like _put, but just returns the pointers to the beginnings of the\n-   array and the constant and returns the size (the amount of info to\n-   copy).  The idea is that the caller can use memcpy to accomplish the\n-   same thing as _put (though slower), or the caller can use a different\n-   function that swaps bytes, words, etc for a different target machine.\n-   Also, the type of the array may be different from the type of the\n-   constant; the array type is used to determine the meaning (scale) of\n-   the offset field (to calculate the array pointer), the constant type is\n-   used to determine the constant pointer and the size (amount of info to\n-   copy).  */\n-\n-void\n-ffebld_constantarray_prepare (void **aptr, void **cptr, size_t *size,\n-       ffebldConstantArray array, ffeinfoBasictype abt, ffeinfoKindtype akt,\n-\t\t      ffetargetOffset offset, ffebldConstantUnion *constant,\n-\t\t\t      ffeinfoBasictype cbt, ffeinfoKindtype ckt)\n-{\n-  switch (abt)\n-    {\n-    case FFEINFO_basictypeINTEGER:\n-      switch (akt)\n-\t{\n-#if FFETARGET_okINTEGER1\n-\tcase FFEINFO_kindtypeINTEGER1:\n-\t  *aptr = array.integer1 + offset;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER2\n-\tcase FFEINFO_kindtypeINTEGER2:\n-\t  *aptr = array.integer2 + offset;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER3\n-\tcase FFEINFO_kindtypeINTEGER3:\n-\t  *aptr = array.integer3 + offset;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER4\n-\tcase FFEINFO_kindtypeINTEGER4:\n-\t  *aptr = array.integer4 + offset;\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad INTEGER akindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeLOGICAL:\n-      switch (akt)\n-\t{\n-#if FFETARGET_okLOGICAL1\n-\tcase FFEINFO_kindtypeLOGICAL1:\n-\t  *aptr = array.logical1 + offset;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL2\n-\tcase FFEINFO_kindtypeLOGICAL2:\n-\t  *aptr = array.logical2 + offset;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL3\n-\tcase FFEINFO_kindtypeLOGICAL3:\n-\t  *aptr = array.logical3 + offset;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL4\n-\tcase FFEINFO_kindtypeLOGICAL4:\n-\t  *aptr = array.logical4 + offset;\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad LOGICAL akindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeREAL:\n-      switch (akt)\n-\t{\n-#if FFETARGET_okREAL1\n-\tcase FFEINFO_kindtypeREAL1:\n-\t  *aptr = array.real1 + offset;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL2\n-\tcase FFEINFO_kindtypeREAL2:\n-\t  *aptr = array.real2 + offset;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL3\n-\tcase FFEINFO_kindtypeREAL3:\n-\t  *aptr = array.real3 + offset;\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad REAL akindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeCOMPLEX:\n-      switch (akt)\n-\t{\n-#if FFETARGET_okCOMPLEX1\n-\tcase FFEINFO_kindtypeREAL1:\n-\t  *aptr = array.complex1 + offset;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX2\n-\tcase FFEINFO_kindtypeREAL2:\n-\t  *aptr = array.complex2 + offset;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX3\n-\tcase FFEINFO_kindtypeREAL3:\n-\t  *aptr = array.complex3 + offset;\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad COMPLEX akindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeCHARACTER:\n-      switch (akt)\n-\t{\n-#if FFETARGET_okCHARACTER1\n-\tcase FFEINFO_kindtypeCHARACTER1:\n-\t  *aptr = array.character1 + offset;\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad CHARACTER akindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    default:\n-      assert (\"bad abasictype\" == NULL);\n-      break;\n-    }\n-\n-  switch (cbt)\n-    {\n-    case FFEINFO_basictypeINTEGER:\n-      switch (ckt)\n-\t{\n-#if FFETARGET_okINTEGER1\n-\tcase FFEINFO_kindtypeINTEGER1:\n-\t  *cptr = &constant->integer1;\n-\t  *size = sizeof (constant->integer1);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER2\n-\tcase FFEINFO_kindtypeINTEGER2:\n-\t  *cptr = &constant->integer2;\n-\t  *size = sizeof (constant->integer2);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER3\n-\tcase FFEINFO_kindtypeINTEGER3:\n-\t  *cptr = &constant->integer3;\n-\t  *size = sizeof (constant->integer3);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER4\n-\tcase FFEINFO_kindtypeINTEGER4:\n-\t  *cptr = &constant->integer4;\n-\t  *size = sizeof (constant->integer4);\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad INTEGER ckindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeLOGICAL:\n-      switch (ckt)\n-\t{\n-#if FFETARGET_okLOGICAL1\n-\tcase FFEINFO_kindtypeLOGICAL1:\n-\t  *cptr = &constant->logical1;\n-\t  *size = sizeof (constant->logical1);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL2\n-\tcase FFEINFO_kindtypeLOGICAL2:\n-\t  *cptr = &constant->logical2;\n-\t  *size = sizeof (constant->logical2);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL3\n-\tcase FFEINFO_kindtypeLOGICAL3:\n-\t  *cptr = &constant->logical3;\n-\t  *size = sizeof (constant->logical3);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL4\n-\tcase FFEINFO_kindtypeLOGICAL4:\n-\t  *cptr = &constant->logical4;\n-\t  *size = sizeof (constant->logical4);\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad LOGICAL ckindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeREAL:\n-      switch (ckt)\n-\t{\n-#if FFETARGET_okREAL1\n-\tcase FFEINFO_kindtypeREAL1:\n-\t  *cptr = &constant->real1;\n-\t  *size = sizeof (constant->real1);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL2\n-\tcase FFEINFO_kindtypeREAL2:\n-\t  *cptr = &constant->real2;\n-\t  *size = sizeof (constant->real2);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL3\n-\tcase FFEINFO_kindtypeREAL3:\n-\t  *cptr = &constant->real3;\n-\t  *size = sizeof (constant->real3);\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad REAL ckindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeCOMPLEX:\n-      switch (ckt)\n-\t{\n-#if FFETARGET_okCOMPLEX1\n-\tcase FFEINFO_kindtypeREAL1:\n-\t  *cptr = &constant->complex1;\n-\t  *size = sizeof (constant->complex1);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX2\n-\tcase FFEINFO_kindtypeREAL2:\n-\t  *cptr = &constant->complex2;\n-\t  *size = sizeof (constant->complex2);\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX3\n-\tcase FFEINFO_kindtypeREAL3:\n-\t  *cptr = &constant->complex3;\n-\t  *size = sizeof (constant->complex3);\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad COMPLEX ckindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeCHARACTER:\n-      switch (ckt)\n-\t{\n-#if FFETARGET_okCHARACTER1\n-\tcase FFEINFO_kindtypeCHARACTER1:\n-\t  *cptr = ffetarget_text_character1 (constant->character1);\n-\t  *size = ffetarget_length_character1 (constant->character1);\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad CHARACTER ckindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    default:\n-      assert (\"bad cbasictype\" == NULL);\n-      break;\n-    }\n-}\n-\n-/* ffebld_constantarray_put -- Put a value into an array of constants\n-\n-   See prototype.  */\n-\n-void\n-ffebld_constantarray_put (ffebldConstantArray array, ffeinfoBasictype bt,\n-   ffeinfoKindtype kt, ffetargetOffset offset, ffebldConstantUnion constant)\n-{\n-  switch (bt)\n-    {\n-    case FFEINFO_basictypeINTEGER:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okINTEGER1\n-\tcase FFEINFO_kindtypeINTEGER1:\n-\t  *(array.integer1 + offset) = constant.integer1;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER2\n-\tcase FFEINFO_kindtypeINTEGER2:\n-\t  *(array.integer2 + offset) = constant.integer2;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER3\n-\tcase FFEINFO_kindtypeINTEGER3:\n-\t  *(array.integer3 + offset) = constant.integer3;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okINTEGER4\n-\tcase FFEINFO_kindtypeINTEGER4:\n-\t  *(array.integer4 + offset) = constant.integer4;\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad INTEGER kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeLOGICAL:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okLOGICAL1\n-\tcase FFEINFO_kindtypeLOGICAL1:\n-\t  *(array.logical1 + offset) = constant.logical1;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL2\n-\tcase FFEINFO_kindtypeLOGICAL2:\n-\t  *(array.logical2 + offset) = constant.logical2;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL3\n-\tcase FFEINFO_kindtypeLOGICAL3:\n-\t  *(array.logical3 + offset) = constant.logical3;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okLOGICAL4\n-\tcase FFEINFO_kindtypeLOGICAL4:\n-\t  *(array.logical4 + offset) = constant.logical4;\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad LOGICAL kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeREAL:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okREAL1\n-\tcase FFEINFO_kindtypeREAL1:\n-\t  *(array.real1 + offset) = constant.real1;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL2\n-\tcase FFEINFO_kindtypeREAL2:\n-\t  *(array.real2 + offset) = constant.real2;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okREAL3\n-\tcase FFEINFO_kindtypeREAL3:\n-\t  *(array.real3 + offset) = constant.real3;\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad REAL kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeCOMPLEX:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okCOMPLEX1\n-\tcase FFEINFO_kindtypeREAL1:\n-\t  *(array.complex1 + offset) = constant.complex1;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX2\n-\tcase FFEINFO_kindtypeREAL2:\n-\t  *(array.complex2 + offset) = constant.complex2;\n-\t  break;\n-#endif\n-\n-#if FFETARGET_okCOMPLEX3\n-\tcase FFEINFO_kindtypeREAL3:\n-\t  *(array.complex3 + offset) = constant.complex3;\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad COMPLEX kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    case FFEINFO_basictypeCHARACTER:\n-      switch (kt)\n-\t{\n-#if FFETARGET_okCHARACTER1\n-\tcase FFEINFO_kindtypeCHARACTER1:\n-\t  memcpy (array.character1 + offset,\n-\t\t  ffetarget_text_character1 (constant.character1),\n-\t\t  ffetarget_length_character1 (constant.character1));\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  assert (\"bad CHARACTER kindtype\" == NULL);\n-\t  break;\n-\t}\n-      break;\n-\n-    default:\n-      assert (\"bad basictype\" == NULL);\n-      break;\n-    }\n-}\n-\n-/* ffebld_init_0 -- Initialize the module\n-\n-   ffebld_init_0();  */\n-\n-void\n-ffebld_init_0 (void)\n-{\n-  assert (FFEBLD_op == ARRAY_SIZE (ffebld_op_string_));\n-  assert (FFEBLD_op == ARRAY_SIZE (ffebld_arity_op_));\n-}\n-\n-/* ffebld_init_1 -- Initialize the module for a file\n-\n-   ffebld_init_1();  */\n-\n-void\n-ffebld_init_1 (void)\n-{\n-#if FFEBLD_whereconstCURRENT_ == FFEBLD_whereconstFILE_\n-  int i;\n-\n-#if FFETARGET_okCHARACTER1\n-  ffebld_constant_character1_ = NULL;\n-#endif\n-#if FFETARGET_okCOMPLEX1\n-  ffebld_constant_complex1_ = NULL;\n-#endif\n-#if FFETARGET_okCOMPLEX2\n-  ffebld_constant_complex2_ = NULL;\n-#endif\n-#if FFETARGET_okCOMPLEX3\n-  ffebld_constant_complex3_ = NULL;\n-#endif\n-#if FFETARGET_okINTEGER1\n-  ffebld_constant_integer1_ = NULL;\n-#endif\n-#if FFETARGET_okINTEGER2\n-  ffebld_constant_integer2_ = NULL;\n-#endif\n-#if FFETARGET_okINTEGER3\n-  ffebld_constant_integer3_ = NULL;\n-#endif\n-#if FFETARGET_okINTEGER4\n-  ffebld_constant_integer4_ = NULL;\n-#endif\n-#if FFETARGET_okLOGICAL1\n-  ffebld_constant_logical1_ = NULL;\n-#endif\n-#if FFETARGET_okLOGICAL2\n-  ffebld_constant_logical2_ = NULL;\n-#endif\n-#if FFETARGET_okLOGICAL3\n-  ffebld_constant_logical3_ = NULL;\n-#endif\n-#if FFETARGET_okLOGICAL4\n-  ffebld_constant_logical4_ = NULL;\n-#endif\n-#if FFETARGET_okREAL1\n-  ffebld_constant_real1_ = NULL;\n-#endif\n-#if FFETARGET_okREAL2\n-  ffebld_constant_real2_ = NULL;\n-#endif\n-#if FFETARGET_okREAL3\n-  ffebld_constant_real3_ = NULL;\n-#endif\n-  ffebld_constant_hollerith_ = NULL;\n-  for (i = FFEBLD_constTYPELESS_FIRST; i <= FFEBLD_constTYPELESS_LAST; ++i)\n-    ffebld_constant_typeless_[i - FFEBLD_constTYPELESS_FIRST] = NULL;\n-#endif\n-}\n-\n-/* ffebld_init_2 -- Initialize the module\n-\n-   ffebld_init_2();  */\n-\n-void\n-ffebld_init_2 (void)\n-{\n-#if FFEBLD_whereconstCURRENT_ == FFEBLD_whereconstPROGUNIT_\n-  int i;\n-#endif\n-\n-  ffebld_pool_stack_.next = NULL;\n-  ffebld_pool_stack_.pool = ffe_pool_program_unit ();\n-#if FFEBLD_whereconstCURRENT_ == FFEBLD_whereconstPROGUNIT_\n-#if FFETARGET_okCHARACTER1\n-  ffebld_constant_character1_ = NULL;\n-#endif\n-#if FFETARGET_okCOMPLEX1\n-  ffebld_constant_complex1_ = NULL;\n-#endif\n-#if FFETARGET_okCOMPLEX2\n-  ffebld_constant_complex2_ = NULL;\n-#endif\n-#if FFETARGET_okCOMPLEX3\n-  ffebld_constant_complex3_ = NULL;\n-#endif\n-#if FFETARGET_okINTEGER1\n-  ffebld_constant_integer1_ = NULL;\n-#endif\n-#if FFETARGET_okINTEGER2\n-  ffebld_constant_integer2_ = NULL;\n-#endif\n-#if FFETARGET_okINTEGER3\n-  ffebld_constant_integer3_ = NULL;\n-#endif\n-#if FFETARGET_okINTEGER4\n-  ffebld_constant_integer4_ = NULL;\n-#endif\n-#if FFETARGET_okLOGICAL1\n-  ffebld_constant_logical1_ = NULL;\n-#endif\n-#if FFETARGET_okLOGICAL2\n-  ffebld_constant_logical2_ = NULL;\n-#endif\n-#if FFETARGET_okLOGICAL3\n-  ffebld_constant_logical3_ = NULL;\n-#endif\n-#if FFETARGET_okLOGICAL4\n-  ffebld_constant_logical4_ = NULL;\n-#endif\n-#if FFETARGET_okREAL1\n-  ffebld_constant_real1_ = NULL;\n-#endif\n-#if FFETARGET_okREAL2\n-  ffebld_constant_real2_ = NULL;\n-#endif\n-#if FFETARGET_okREAL3\n-  ffebld_constant_real3_ = NULL;\n-#endif\n-  ffebld_constant_hollerith_ = NULL;\n-  for (i = FFEBLD_constTYPELESS_FIRST; i <= FFEBLD_constTYPELESS_LAST; ++i)\n-    ffebld_constant_typeless_[i - FFEBLD_constTYPELESS_FIRST] = NULL;\n-#endif\n-}\n-\n-/* ffebld_list_length -- Return # of opITEMs in list\n-\n-   ffebld list;\t // Must be NULL or opITEM\n-   ffebldListLength length;\n-   length = ffebld_list_length(list);\n-\n-   Returns 0 if list is NULL, 1 if it's ffebld_trail is NULL, and so on.  */\n-\n-ffebldListLength\n-ffebld_list_length (ffebld list)\n-{\n-  ffebldListLength length;\n-\n-  for (length = 0; list != NULL; ++length, list = ffebld_trail (list))\n-    ;\n-\n-  return length;\n-}\n-\n-/* ffebld_new_accter -- Create an ffebld object that is an array\n-\n-   ffebld x;\n-   ffebldConstantArray a;\n-   ffebit b;\n-   x = ffebld_new_accter(a,b);\t*/\n-\n-ffebld\n-ffebld_new_accter (ffebldConstantArray a, ffebit b)\n-{\n-  ffebld x;\n-\n-  x = ffebld_new ();\n-  x->op = FFEBLD_opACCTER;\n-  x->u.accter.array = a;\n-  x->u.accter.bits = b;\n-  x->u.accter.pad = 0;\n-  return x;\n-}\n-\n-/* ffebld_new_arrter -- Create an ffebld object that is an array\n-\n-   ffebld x;\n-   ffebldConstantArray a;\n-   ffetargetOffset size;\n-   x = ffebld_new_arrter(a,size);  */\n-\n-ffebld\n-ffebld_new_arrter (ffebldConstantArray a, ffetargetOffset size)\n-{\n-  ffebld x;\n-\n-  x = ffebld_new ();\n-  x->op = FFEBLD_opARRTER;\n-  x->u.arrter.array = a;\n-  x->u.arrter.size = size;\n-  x->u.arrter.pad = 0;\n-  return x;\n-}\n-\n-/* ffebld_new_conter_with_orig -- Create an ffebld object that is a constant\n-\n-   ffebld x;\n-   ffebldConstant c;\n-   x = ffebld_new_conter_with_orig(c,NULL);  */\n-\n-ffebld\n-ffebld_new_conter_with_orig (ffebldConstant c, ffebld o)\n-{\n-  ffebld x;\n-\n-  x = ffebld_new ();\n-  x->op = FFEBLD_opCONTER;\n-  x->u.conter.expr = c;\n-  x->u.conter.orig = o;\n-  x->u.conter.pad = 0;\n-  return x;\n-}\n-\n-/* ffebld_new_item -- Create an ffebld item object\n-\n-   ffebld x,y,z;\n-   x = ffebld_new_item(y,z);  */\n-\n-ffebld\n-ffebld_new_item (ffebld head, ffebld trail)\n-{\n-  ffebld x;\n-\n-  x = ffebld_new ();\n-  x->op = FFEBLD_opITEM;\n-  x->u.item.head = head;\n-  x->u.item.trail = trail;\n-  return x;\n-}\n-\n-/* ffebld_new_labter -- Create an ffebld object that is a label\n-\n-   ffebld x;\n-   ffelab l;\n-   x = ffebld_new_labter(c);  */\n-\n-ffebld\n-ffebld_new_labter (ffelab l)\n-{\n-  ffebld x;\n-\n-  x = ffebld_new ();\n-  x->op = FFEBLD_opLABTER;\n-  x->u.labter = l;\n-  return x;\n-}\n-\n-/* ffebld_new_labtok -- Create object that is a label's NUMBER token\n-\n-   ffebld x;\n-   ffelexToken t;\n-   x = ffebld_new_labter(c);\n-\n-   Like the other ffebld_new_ functions, the\n-   supplied argument is stored exactly as is: ffelex_token_use is NOT\n-   called, so the token is \"consumed\", if one is indeed supplied (it may\n-   be NULL).  */\n-\n-ffebld\n-ffebld_new_labtok (ffelexToken t)\n-{\n-  ffebld x;\n-\n-  x = ffebld_new ();\n-  x->op = FFEBLD_opLABTOK;\n-  x->u.labtok = t;\n-  return x;\n-}\n-\n-/* ffebld_new_none -- Create an ffebld object with no arguments\n-\n-   ffebld x;\n-   x = ffebld_new_none(FFEBLD_opWHATEVER);  */\n-\n-ffebld\n-ffebld_new_none (ffebldOp o)\n-{\n-  ffebld x;\n-\n-  x = ffebld_new ();\n-  x->op = o;\n-  return x;\n-}\n-\n-/* ffebld_new_one -- Create an ffebld object with one argument\n-\n-   ffebld x,y;\n-   x = ffebld_new_one(FFEBLD_opWHATEVER,y);  */\n-\n-ffebld\n-ffebld_new_one (ffebldOp o, ffebld left)\n-{\n-  ffebld x;\n-\n-  x = ffebld_new ();\n-  x->op = o;\n-  x->u.nonter.left = left;\n-  x->u.nonter.hook = FFECOM_nonterNULL;\n-  return x;\n-}\n-\n-/* ffebld_new_symter -- Create an ffebld object that is a symbol\n-\n-   ffebld x;\n-   ffesymbol s;\n-   ffeintrinGen gen;\t// Generic intrinsic id, if any\n-   ffeintrinSpec spec;\t// Specific intrinsic id, if any\n-   ffeintrinImp imp;\t// Implementation intrinsic id, if any\n-   x = ffebld_new_symter (s, gen, spec, imp);  */\n-\n-ffebld\n-ffebld_new_symter (ffesymbol s, ffeintrinGen gen, ffeintrinSpec spec,\n-\t\t   ffeintrinImp imp)\n-{\n-  ffebld x;\n-\n-  x = ffebld_new ();\n-  x->op = FFEBLD_opSYMTER;\n-  x->u.symter.symbol = s;\n-  x->u.symter.generic = gen;\n-  x->u.symter.specific = spec;\n-  x->u.symter.implementation = imp;\n-  x->u.symter.do_iter = FALSE;\n-  return x;\n-}\n-\n-/* ffebld_new_two -- Create an ffebld object with two arguments\n-\n-   ffebld x,y,z;\n-   x = ffebld_new_two(FFEBLD_opWHATEVER,y,z);  */\n-\n-ffebld\n-ffebld_new_two (ffebldOp o, ffebld left, ffebld right)\n-{\n-  ffebld x;\n-\n-  x = ffebld_new ();\n-  x->op = o;\n-  x->u.nonter.left = left;\n-  x->u.nonter.right = right;\n-  x->u.nonter.hook = FFECOM_nonterNULL;\n-  return x;\n-}\n-\n-/* ffebld_pool_pop -- Pop ffebld's pool stack\n-\n-   ffebld_pool_pop();  */\n-\n-void\n-ffebld_pool_pop (void)\n-{\n-  ffebldPoolstack_ ps;\n-\n-  assert (ffebld_pool_stack_.next != NULL);\n-  ps = ffebld_pool_stack_.next;\n-  ffebld_pool_stack_.next = ps->next;\n-  ffebld_pool_stack_.pool = ps->pool;\n-  malloc_kill_ks (malloc_pool_image (), ps, sizeof (*ps));\n-}\n-\n-/* ffebld_pool_push -- Push ffebld's pool stack\n-\n-   ffebld_pool_push();\t*/\n-\n-void\n-ffebld_pool_push (mallocPool pool)\n-{\n-  ffebldPoolstack_ ps;\n-\n-  ps = malloc_new_ks (malloc_pool_image (), \"Pool stack\", sizeof (*ps));\n-  ps->next = ffebld_pool_stack_.next;\n-  ps->pool = ffebld_pool_stack_.pool;\n-  ffebld_pool_stack_.next = ps;\n-  ffebld_pool_stack_.pool = pool;\n-}\n-\n-/* ffebld_op_string -- Return short string describing op\n-\n-   ffebldOp o;\n-   ffebld_op_string(o);\n-\n-   Returns a short string (uppercase) containing the name of the op.  */\n-\n-const char *\n-ffebld_op_string (ffebldOp o)\n-{\n-  if (o >= ARRAY_SIZE (ffebld_op_string_))\n-    return \"?\\?\\?\";\n-  return ffebld_op_string_[o];\n-}\n-\n-/* ffebld_size_max -- Return maximum possible size of CHARACTER-type expr\n-\n-   ffetargetCharacterSize sz;\n-   ffebld b;\n-   sz = ffebld_size_max (b);\n-\n-   Like ffebld_size_known, but if that would return NONE and the expression\n-   is opSUBSTR, opCONVERT, opPAREN, or opCONCATENATE, returns ffebld_size_max\n-   of the subexpression(s).  */\n-\n-ffetargetCharacterSize\n-ffebld_size_max (ffebld b)\n-{\n-  ffetargetCharacterSize sz;\n-\n-recurse:\t\t\t/* :::::::::::::::::::: */\n-\n-  sz = ffebld_size_known (b);\n-\n-  if (sz != FFETARGET_charactersizeNONE)\n-    return sz;\n-\n-  switch (ffebld_op (b))\n-    {\n-    case FFEBLD_opSUBSTR:\n-    case FFEBLD_opCONVERT:\n-    case FFEBLD_opPAREN:\n-      b = ffebld_left (b);\n-      goto recurse;\t\t/* :::::::::::::::::::: */\n-\n-    case FFEBLD_opCONCATENATE:\n-      sz = ffebld_size_max (ffebld_left (b))\n-\t+ ffebld_size_max (ffebld_right (b));\n-      return sz;\n-\n-    default:\n-      return sz;\n-    }\n-}"}, {"sha": "a726dec5ab0818734db25fc4661299e1ed7efc33", "filename": "gcc/f/bld.h", "status": "removed", "additions": 0, "deletions": 748, "changes": 748, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fbld.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fbld.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbld.h?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,748 +0,0 @@\n-/* bld.h -- Public #include File (module.h template V1.0)\n-   Copyright (C) 1995, 1996, 2003 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Owning Modules:\n-      bld.c\n-\n-   Modifications:\n-*/\n-\n-/* Allow multiple inclusion to work. */\n-\n-#ifndef GCC_F_BLD_H\n-#define GCC_F_BLD_H\n-\n-/* Simple definitions and enumerations. */\n-\n-typedef enum\n-  {\n-    FFEBLD_constNONE,\n-    FFEBLD_constINTEGER1,\n-    FFEBLD_constINTEGER2,\n-    FFEBLD_constINTEGER3,\n-    FFEBLD_constINTEGER4,\n-    FFEBLD_constINTEGER5,\n-    FFEBLD_constINTEGER6,\n-    FFEBLD_constINTEGER7,\n-    FFEBLD_constINTEGER8,\n-    FFEBLD_constLOGICAL1,\n-    FFEBLD_constLOGICAL2,\n-    FFEBLD_constLOGICAL3,\n-    FFEBLD_constLOGICAL4,\n-    FFEBLD_constLOGICAL5,\n-    FFEBLD_constLOGICAL6,\n-    FFEBLD_constLOGICAL7,\n-    FFEBLD_constLOGICAL8,\n-    FFEBLD_constREAL1,\n-    FFEBLD_constREAL2,\n-    FFEBLD_constREAL3,\n-    FFEBLD_constREAL4,\n-    FFEBLD_constREAL5,\n-    FFEBLD_constREAL6,\n-    FFEBLD_constREAL7,\n-    FFEBLD_constREAL8,\n-    FFEBLD_constCOMPLEX1,\n-    FFEBLD_constCOMPLEX2,\n-    FFEBLD_constCOMPLEX3,\n-    FFEBLD_constCOMPLEX4,\n-    FFEBLD_constCOMPLEX5,\n-    FFEBLD_constCOMPLEX6,\n-    FFEBLD_constCOMPLEX7,\n-    FFEBLD_constCOMPLEX8,\n-    FFEBLD_constCHARACTER1,\n-    FFEBLD_constCHARACTER2,\n-    FFEBLD_constCHARACTER3,\n-    FFEBLD_constCHARACTER4,\n-    FFEBLD_constCHARACTER5,\n-    FFEBLD_constCHARACTER6,\n-    FFEBLD_constCHARACTER7,\n-    FFEBLD_constCHARACTER8,\n-    FFEBLD_constHOLLERITH,\n-    FFEBLD_constTYPELESS_FIRST,\n-    FFEBLD_constBINARY_MIL = FFEBLD_constTYPELESS_FIRST,\n-    FFEBLD_constBINARY_VXT,\n-    FFEBLD_constOCTAL_MIL,\n-    FFEBLD_constOCTAL_VXT,\n-    FFEBLD_constHEX_X_MIL,\n-    FFEBLD_constHEX_X_VXT,\n-    FFEBLD_constHEX_Z_MIL,\n-    FFEBLD_constHEX_Z_VXT,\n-    FFEBLD_constTYPELESS_LAST = FFEBLD_constHEX_Z_VXT,\n-    FFEBLD_const\n-  } ffebldConst;\n-\n-typedef enum\n-  {\n-#define FFEBLD_OP(KWD,NAME,ARITY) KWD,\n-#include \"bld-op.def\"\n-#undef FFEBLD_OP\n-    FFEBLD_op\n-  } ffebldOp;\n-\n-/* Typedefs. */\n-\n-typedef struct _ffebld_ *ffebld;\n-typedef unsigned char ffebldArity;\n-typedef union _ffebld_constant_array_ ffebldConstantArray;\n-typedef struct _ffebld_constant_ *ffebldConstant;\n-typedef union _ffebld_constant_union_ ffebldConstantUnion;\n-typedef ffebld *ffebldListBottom;\n-typedef unsigned int ffebldListLength;\n-#define ffebldListLength_f \"\"\n-typedef struct _ffebld_pool_stack_ *ffebldPoolstack_;\n-\n-/* Include files needed by this one. */\n-\n-#include \"bit.h\"\n-#include \"com.h\"\n-#include \"info.h\"\n-#include \"intrin.h\"\n-#include \"lab.h\"\n-#include \"lex.h\"\n-#include \"malloc.h\"\n-#include \"symbol.h\"\n-#include \"target.h\"\n-\n-#define FFEBLD_whereconstPROGUNIT_ 1\n-#define FFEBLD_whereconstFILE_ 2\n-\n-#define FFEBLD_whereconstCURRENT_ FFEBLD_whereconstFILE_\n-\n-/* Structure definitions. */\n-\n-#define FFEBLD_constINTEGERDEFAULT FFEBLD_constINTEGER1\n-#define FFEBLD_constLOGICALDEFAULT FFEBLD_constLOGICAL1\n-#define FFEBLD_constREALDEFAULT FFEBLD_constREAL1\n-#define FFEBLD_constREALDOUBLE FFEBLD_constREAL2\n-#define FFEBLD_constREALQUAD FFEBLD_constREAL3\n-#define FFEBLD_constCOMPLEX FFEBLD_constCOMPLEX1\n-#define FFEBLD_constCOMPLEXDOUBLE FFEBLD_constCOMPLEX2\n-#define FFEBLD_constCOMPLEXQUAD FFEBLD_constCOMPLEX3\n-#define FFEBLD_constCHARACTERDEFAULT FFEBLD_constCHARACTER1\n-\n-union _ffebld_constant_union_\n-  {\n-    ffetargetTypeless typeless;\n-    ffetargetHollerith hollerith;\n-#if FFETARGET_okINTEGER1\n-    ffetargetInteger1 integer1;\n-#endif\n-#if FFETARGET_okINTEGER2\n-    ffetargetInteger2 integer2;\n-#endif\n-#if FFETARGET_okINTEGER3\n-    ffetargetInteger3 integer3;\n-#endif\n-#if FFETARGET_okINTEGER4\n-    ffetargetInteger4 integer4;\n-#endif\n-#if FFETARGET_okLOGICAL1\n-    ffetargetLogical1 logical1;\n-#endif\n-#if FFETARGET_okLOGICAL2\n-    ffetargetLogical2 logical2;\n-#endif\n-#if FFETARGET_okLOGICAL3\n-    ffetargetLogical3 logical3;\n-#endif\n-#if FFETARGET_okLOGICAL4\n-    ffetargetLogical4 logical4;\n-#endif\n-#if FFETARGET_okREAL1\n-    ffetargetReal1 real1;\n-#endif\n-#if FFETARGET_okREAL2\n-    ffetargetReal2 real2;\n-#endif\n-#if FFETARGET_okREAL3\n-    ffetargetReal3 real3;\n-#endif\n-#if FFETARGET_okCOMPLEX1\n-    ffetargetComplex1 complex1;\n-#endif\n-#if FFETARGET_okCOMPLEX2\n-    ffetargetComplex2 complex2;\n-#endif\n-#if FFETARGET_okCOMPLEX3\n-    ffetargetComplex3 complex3;\n-#endif\n-#if FFETARGET_okCHARACTER1\n-    ffetargetCharacter1 character1;\n-#endif\n-  };\n-\n-union _ffebld_constant_array_\n-  {\n-#if FFETARGET_okINTEGER1\n-    ffetargetInteger1 *integer1;\n-#endif\n-#if FFETARGET_okINTEGER2\n-    ffetargetInteger2 *integer2;\n-#endif\n-#if FFETARGET_okINTEGER3\n-    ffetargetInteger3 *integer3;\n-#endif\n-#if FFETARGET_okINTEGER4\n-    ffetargetInteger4 *integer4;\n-#endif\n-#if FFETARGET_okLOGICAL1\n-    ffetargetLogical1 *logical1;\n-#endif\n-#if FFETARGET_okLOGICAL2\n-    ffetargetLogical2 *logical2;\n-#endif\n-#if FFETARGET_okLOGICAL3\n-    ffetargetLogical3 *logical3;\n-#endif\n-#if FFETARGET_okLOGICAL4\n-    ffetargetLogical4 *logical4;\n-#endif\n-#if FFETARGET_okREAL1\n-    ffetargetReal1 *real1;\n-#endif\n-#if FFETARGET_okREAL2\n-    ffetargetReal2 *real2;\n-#endif\n-#if FFETARGET_okREAL3\n-    ffetargetReal3 *real3;\n-#endif\n-#if FFETARGET_okCOMPLEX1\n-    ffetargetComplex1 *complex1;\n-#endif\n-#if FFETARGET_okCOMPLEX2\n-    ffetargetComplex2 *complex2;\n-#endif\n-#if FFETARGET_okCOMPLEX3\n-    ffetargetComplex3 *complex3;\n-#endif\n-#if FFETARGET_okCHARACTER1\n-    ffetargetCharacterUnit1 *character1;\n-#endif\n-  };\n-\n-struct _ffebld_\n-  {\n-    ffebldOp op;\n-    ffeinfo info;\t\t/* Not used or valid for\n-\t\t\t\t   op=={STAR,ITEM,BOUNDS,REPEAT,LABTER,\n-\t\t\t\t   LABTOK,IMPDO}. */\n-    union\n-      {\n-\tstruct\n-\t  {\n-\t    ffebld left;\n-\t    ffebld right;\n-\t    ffecomNonter hook;\t/* Whatever the compiler/backend wants! */\n-\t  }\n-\tnonter;\n-\tstruct\n-\t  {\n-\t    ffebld head;\n-\t    ffebld trail;\n-\t  }\n-\titem;\n-\tstruct\n-\t  {\n-\t    ffebldConstant expr;\n-\t    ffebld orig;\t/* Original expression, or NULL if none. */\n-\t    ffetargetAlign pad;\t/* Initial padding (for DATA, etc.). */\n-\t  }\n-\tconter;\n-\tstruct\n-\t  {\n-\t    ffebldConstantArray array;\n-\t    ffetargetOffset size;\n-\t    ffetargetAlign pad;\t/* Initial padding (for DATA, etc.). */\n-\t  }\n-\tarrter;\n-\tstruct\n-\t  {\n-\t    ffebldConstantArray array;\n-\t    ffebit bits;\n-\t    ffetargetAlign pad;\t/* Initial padding (for DATA, etc.). */\n-\t  }\n-\taccter;\n-\tstruct\n-\t  {\n-\t    ffesymbol symbol;\n-\t    ffeintrinGen generic;\t/* Id for generic intrinsic. */\n-\t    ffeintrinSpec specific;\t/* Id for specific intrinsic. */\n-\t    ffeintrinImp implementation;\t/* Id for implementation. */\n-\t    bool do_iter;\t/* TRUE if this ref is a read-only ref by\n-\t\t\t\t   definition (ref within DO loop using this\n-\t\t\t\t   var as iterator). */\n-\t  }\n-\tsymter;\n-\tffelab labter;\n-\tffelexToken labtok;\n-      }\n-    u;\n-  };\n-\n-struct _ffebld_constant_\n-  {\n-    ffebldConstant next;\n-    ffebldConstant first_complex;\t/* First complex const with me as\n-\t\t\t\t\t   real. */\n-    ffebldConstant negated;\t/* We point to each other through here. */\n-    ffebldConst consttype;\n-    ffecomConstant hook;\t/* Whatever the compiler/backend wants! */\n-    bool numeric;\t\t/* A numeric kind of constant. */\n-    ffebldConstantUnion u;\n-  };\n-\n-struct _ffebld_pool_stack_\n-  {\n-    ffebldPoolstack_ next;\n-    mallocPool pool;\n-  };\n-\n-/* Global objects accessed by users of this module. */\n-\n-extern const ffebldArity ffebld_arity_op_[(int) FFEBLD_op];\n-extern struct _ffebld_pool_stack_ ffebld_pool_stack_;\n-\n-/* Declare functions with prototypes. */\n-\n-int ffebld_constant_cmp (ffebldConstant c1, ffebldConstant c2);\n-bool ffebld_constant_is_magical (ffebldConstant c);\n-bool ffebld_constant_is_zero (ffebldConstant c);\n-#if FFETARGET_okCHARACTER1\n-ffebldConstant ffebld_constant_new_character1 (ffelexToken t);\n-ffebldConstant ffebld_constant_new_character1_val (ffetargetCharacter1 val);\n-#endif\n-#if FFETARGET_okCOMPLEX1\n-ffebldConstant ffebld_constant_new_complex1 (ffebldConstant real,\n-\t\t\t\t\t     ffebldConstant imaginary);\n-ffebldConstant ffebld_constant_new_complex1_val (ffetargetComplex1 val);\n-#endif\n-#if FFETARGET_okCOMPLEX2\n-ffebldConstant ffebld_constant_new_complex2 (ffebldConstant real,\n-\t\t\t\t\t     ffebldConstant imaginary);\n-ffebldConstant ffebld_constant_new_complex2_val (ffetargetComplex2 val);\n-#endif\n-#if FFETARGET_okCOMPLEX3\n-ffebldConstant ffebld_constant_new_complex3 (ffebldConstant real,\n-\t\t\t\t\t     ffebldConstant imaginary);\n-ffebldConstant ffebld_constant_new_complex3_val (ffetargetComplex3 val);\n-#endif\n-ffebldConstant ffebld_constant_new_hollerith (ffelexToken t);\n-ffebldConstant ffebld_constant_new_hollerith_val (ffetargetHollerith val);\n-#if FFETARGET_okINTEGER1\n-ffebldConstant ffebld_constant_new_integer1 (ffelexToken t);\n-ffebldConstant ffebld_constant_new_integer1_val (ffetargetInteger1 val);\n-#endif\n-#if FFETARGET_okINTEGER2\n-ffebldConstant ffebld_constant_new_integer2 (ffelexToken t);\n-ffebldConstant ffebld_constant_new_integer2_val (ffetargetInteger2 val);\n-#endif\n-#if FFETARGET_okINTEGER3\n-ffebldConstant ffebld_constant_new_integer3 (ffelexToken t);\n-ffebldConstant ffebld_constant_new_integer3_val (ffetargetInteger3 val);\n-#endif\n-#if FFETARGET_okINTEGER4\n-ffebldConstant ffebld_constant_new_integer4 (ffelexToken t);\n-ffebldConstant ffebld_constant_new_integer4_val (ffetargetInteger4 val);\n-#endif\n-ffebldConstant ffebld_constant_new_integerbinary (ffelexToken t);\n-ffebldConstant ffebld_constant_new_integerhex (ffelexToken t);\n-ffebldConstant ffebld_constant_new_integeroctal (ffelexToken t);\n-#if FFETARGET_okLOGICAL1\n-ffebldConstant ffebld_constant_new_logical1 (bool truth);\n-ffebldConstant ffebld_constant_new_logical1_val (ffetargetLogical1 val);\n-#endif\n-#if FFETARGET_okLOGICAL2\n-ffebldConstant ffebld_constant_new_logical2 (bool truth);\n-ffebldConstant ffebld_constant_new_logical2_val (ffetargetLogical2 val);\n-#endif\n-#if FFETARGET_okLOGICAL3\n-ffebldConstant ffebld_constant_new_logical3 (bool truth);\n-ffebldConstant ffebld_constant_new_logical3_val (ffetargetLogical3 val);\n-#endif\n-#if FFETARGET_okLOGICAL4\n-ffebldConstant ffebld_constant_new_logical4 (bool truth);\n-ffebldConstant ffebld_constant_new_logical4_val (ffetargetLogical4 val);\n-#endif\n-#if FFETARGET_okREAL1\n-ffebldConstant ffebld_constant_new_real1 (ffelexToken integer,\n-\t    ffelexToken decimal, ffelexToken fraction, ffelexToken exponent,\n-\t\t    ffelexToken exponent_sign, ffelexToken exponent_digits);\n-ffebldConstant ffebld_constant_new_real1_val (ffetargetReal1 val);\n-#endif\n-#if FFETARGET_okREAL2\n-ffebldConstant ffebld_constant_new_real2 (ffelexToken integer,\n-\t    ffelexToken decimal, ffelexToken fraction, ffelexToken exponent,\n-\t\t    ffelexToken exponent_sign, ffelexToken exponent_digits);\n-ffebldConstant ffebld_constant_new_real2_val (ffetargetReal2 val);\n-#endif\n-#if FFETARGET_okREAL3\n-ffebldConstant ffebld_constant_new_real3 (ffelexToken integer,\n-\t    ffelexToken decimal, ffelexToken fraction, ffelexToken exponent,\n-\t\t    ffelexToken exponent_sign, ffelexToken exponent_digits);\n-ffebldConstant ffebld_constant_new_real3_val (ffetargetReal3 val);\n-#endif\n-ffebldConstant ffebld_constant_new_typeless_bm (ffelexToken t);\n-ffebldConstant ffebld_constant_new_typeless_bv (ffelexToken t);\n-ffebldConstant ffebld_constant_new_typeless_hxm (ffelexToken t);\n-ffebldConstant ffebld_constant_new_typeless_hxv (ffelexToken t);\n-ffebldConstant ffebld_constant_new_typeless_hzm (ffelexToken t);\n-ffebldConstant ffebld_constant_new_typeless_hzv (ffelexToken t);\n-ffebldConstant ffebld_constant_new_typeless_om (ffelexToken t);\n-ffebldConstant ffebld_constant_new_typeless_ov (ffelexToken t);\n-ffebldConstant ffebld_constant_new_typeless_val (ffebldConst type,\n-\t\t\t\t\t\t ffetargetTypeless val);\n-ffebldConstant ffebld_constant_negated (ffebldConstant c);\n-ffebldConstantUnion ffebld_constantarray_get (ffebldConstantArray array,\n-\t   ffeinfoBasictype bt, ffeinfoKindtype kt, ffetargetOffset offset);\n-void ffebld_constantarray_kill (ffebldConstantArray array, ffeinfoBasictype bt,\n-\t\t\t\tffeinfoKindtype kt, ffetargetOffset size);\n-ffebldConstantArray ffebld_constantarray_new (ffeinfoBasictype bt,\n-\t\t\t\t  ffeinfoKindtype kt, ffetargetOffset size);\n-void ffebld_constantarray_prepare (void **aptr, void **cptr, size_t *size,\n-       ffebldConstantArray array, ffeinfoBasictype abt, ffeinfoKindtype akt,\n-\t\t      ffetargetOffset offset, ffebldConstantUnion *constant,\n-\t\t\t\t ffeinfoBasictype cbt, ffeinfoKindtype ckt);\n-void ffebld_constantarray_preparray (void **aptr, void **cptr, size_t *size,\n-       ffebldConstantArray array, ffeinfoBasictype abt, ffeinfoKindtype akt,\n-\t\t   ffetargetOffset offset, ffebldConstantArray source_array,\n-\t\t\t\t ffeinfoBasictype cbt, ffeinfoKindtype ckt);\n-void ffebld_constantarray_put (ffebldConstantArray array, ffeinfoBasictype bt,\n-  ffeinfoKindtype kt, ffetargetOffset offset, ffebldConstantUnion constant);\n-void ffebld_init_0 (void);\n-void ffebld_init_1 (void);\n-void ffebld_init_2 (void);\n-ffebldListLength ffebld_list_length (ffebld l);\n-ffebld ffebld_new_accter (ffebldConstantArray array, ffebit b);\n-ffebld ffebld_new_arrter (ffebldConstantArray array, ffetargetOffset size);\n-ffebld ffebld_new_conter_with_orig (ffebldConstant c, ffebld orig);\n-ffebld ffebld_new_item (ffebld head, ffebld trail);\n-ffebld ffebld_new_labter (ffelab l);\n-ffebld ffebld_new_labtok (ffelexToken t);\n-ffebld ffebld_new_none (ffebldOp o);\n-ffebld ffebld_new_symter (ffesymbol s, ffeintrinGen gen, ffeintrinSpec spec,\n-\t\t\t  ffeintrinImp imp);\n-ffebld ffebld_new_one (ffebldOp o, ffebld left);\n-ffebld ffebld_new_two (ffebldOp o, ffebld left, ffebld right);\n-const char *ffebld_op_string (ffebldOp o);\n-void ffebld_pool_pop (void);\n-void ffebld_pool_push (mallocPool pool);\n-ffetargetCharacterSize ffebld_size_max (ffebld b);\n-\n-/* Define macros. */\n-\n-#define ffebld_accter(b) ((b)->u.accter.array)\n-#define ffebld_accter_bits(b) ((b)->u.accter.bits)\n-#define ffebld_accter_pad(b) ((b)->u.accter.pad)\n-#define ffebld_accter_set_bits(b,bt) ((b)->u.accter.bits = (bt))\n-#define ffebld_accter_set_pad(b,p) ((b)->u.accter.pad = (p))\n-#define ffebld_accter_size(b) ffebit_size((b)->u.accter.bits)\n-#define ffebld_append_item(b,i) (**(b) = ffebld_new_item((i),NULL),\t      \\\n-\t\t\t\t *(b) = &((**(b))->u.item.trail))\n-#define ffebld_arity(b) ffebld_arity_op(ffebld_op(b))\n-#define ffebld_arity_op(o) (ffebld_arity_op_[o])\n-#define ffebld_arrter(b) ((b)->u.arrter.array)\n-#define ffebld_arrter_pad(b) ((b)->u.arrter.pad)\n-#define ffebld_arrter_set_pad(b,p) ((b)->u.arrter.pad = (p))\n-#define ffebld_arrter_set_size(b,s) ((b)->u.arrter.size = (s))\n-#define ffebld_arrter_size(b) ((b)->u.arrter.size)\n-#define ffebld_basictype(b) (ffeinfo_basictype (ffebld_info ((b))))\n-#if FFEBLD_whereconstCURRENT_ == FFEBLD_whereconstPROGUNIT_\n-#define ffebld_constant_pool() ffe_pool_program_unit()\n-#elif FFEBLD_whereconstCURRENT_ == FFEBLD_whereconstFILE_\n-#define ffebld_constant_pool() ffe_pool_file()\n-#else\n-#error\n-#endif\n-#define ffebld_constant_character1(c) ((c)->u.character1)\n-#define ffebld_constant_character2(c) ((c)->u.character2)\n-#define ffebld_constant_character3(c) ((c)->u.character3)\n-#define ffebld_constant_character4(c) ((c)->u.character4)\n-#define ffebld_constant_character5(c) ((c)->u.character5)\n-#define ffebld_constant_character6(c) ((c)->u.character6)\n-#define ffebld_constant_character7(c) ((c)->u.character7)\n-#define ffebld_constant_character8(c) ((c)->u.character8)\n-#define ffebld_constant_characterdefault ffebld_constant_character1\n-#define ffebld_constant_complex1(c) ((c)->u.complex1)\n-#define ffebld_constant_complex2(c) ((c)->u.complex2)\n-#define ffebld_constant_complex3(c) ((c)->u.complex3)\n-#define ffebld_constant_complex4(c) ((c)->u.complex4)\n-#define ffebld_constant_complex5(c) ((c)->u.complex5)\n-#define ffebld_constant_complex6(c) ((c)->u.complex6)\n-#define ffebld_constant_complex7(c) ((c)->u.complex7)\n-#define ffebld_constant_complex8(c) ((c)->u.complex8)\n-#define ffebld_constant_complexdefault ffebld_constant_complex1\n-#define ffebld_constant_complexdouble ffebld_constant_complex2\n-#define ffebld_constant_complexquad ffebld_constant_complex3\n-#define ffebld_constant_copy(c) (c)\n-#define ffebld_constant_hollerith(c) ((c)->u.hollerith)\n-#define ffebld_constant_hook(c) ((c)->hook)\n-#define ffebld_constant_integer1(c) ((c)->u.integer1)\n-#define ffebld_constant_integer2(c) ((c)->u.integer2)\n-#define ffebld_constant_integer3(c) ((c)->u.integer3)\n-#define ffebld_constant_integer4(c) ((c)->u.integer4)\n-#define ffebld_constant_integer5(c) ((c)->u.integer5)\n-#define ffebld_constant_integer6(c) ((c)->u.integer6)\n-#define ffebld_constant_integer7(c) ((c)->u.integer7)\n-#define ffebld_constant_integer8(c) ((c)->u.integer8)\n-#define ffebld_constant_integerdefault ffebld_constant_integer1\n-#define ffebld_constant_is_numeric(c) ((c)->numeric)\n-#define ffebld_constant_logical1(c) ((c)->u.logical1)\n-#define ffebld_constant_logical2(c) ((c)->u.logical2)\n-#define ffebld_constant_logical3(c) ((c)->u.logical3)\n-#define ffebld_constant_logical4(c) ((c)->u.logical4)\n-#define ffebld_constant_logical5(c) ((c)->u.logical5)\n-#define ffebld_constant_logical6(c) ((c)->u.logical6)\n-#define ffebld_constant_logical7(c) ((c)->u.logical7)\n-#define ffebld_constant_logical8(c) ((c)->u.logical8)\n-#define ffebld_constant_logicaldefault ffebld_constant_logical1\n-#define ffebld_constant_new_characterdefault ffebld_constant_new_character1\n-#define ffebld_constant_new_characterdefault_val ffebld_constant_new_character1_val\n-#define ffebld_constant_new_complexdefault ffebld_constant_new_complex1\n-#define ffebld_constant_new_complexdefault_val ffebld_constant_new_complex1_val\n-#define ffebld_constant_new_complexdouble ffebld_constant_new_complex2\n-#define ffebld_constant_new_complexdouble_val ffebld_constant_new_complex2_val\n-#define ffebld_constant_new_complexquad ffebld_constant_new_complex3\n-#define ffebld_constant_new_complexquad_valffebld_constant_new_complex3_val\n-#define ffebld_constant_new_integerdefault ffebld_constant_new_integer1\n-#define ffebld_constant_new_integerdefault_val ffebld_constant_new_integer1_val\n-#define ffebld_constant_new_logicaldefault ffebld_constant_new_logical1\n-#define ffebld_constant_new_logicaldefault_val ffebld_constant_new_logical1_val\n-#define ffebld_constant_new_realdefault ffebld_constant_new_real1\n-#define ffebld_constant_new_realdefault_val ffebld_constant_new_real1_val\n-#define ffebld_constant_new_realdouble ffebld_constant_new_real2\n-#define ffebld_constant_new_realdouble_val ffebld_constant_new_real2_val\n-#define ffebld_constant_new_realquad ffebld_constant_new_real3\n-#define ffebld_constant_new_realquad_val ffebld_constant_new_real3_val\n-#define ffebld_constant_ptr_to_union(c) (&(c)->u)\n-#define ffebld_constant_real1(c) ((c)->u.real1)\n-#define ffebld_constant_real2(c) ((c)->u.real2)\n-#define ffebld_constant_real3(c) ((c)->u.real3)\n-#define ffebld_constant_real4(c) ((c)->u.real4)\n-#define ffebld_constant_real5(c) ((c)->u.real5)\n-#define ffebld_constant_real6(c) ((c)->u.real6)\n-#define ffebld_constant_real7(c) ((c)->u.real7)\n-#define ffebld_constant_real8(c) ((c)->u.real8)\n-#define ffebld_constant_realdefault ffebld_constant_real1\n-#define ffebld_constant_realdouble ffebld_constant_real2\n-#define ffebld_constant_realquad ffebld_constant_real3\n-#define ffebld_constant_set_hook(c,h) ((c)->hook = (h))\n-#define ffebld_constant_set_union(c,un) ((c)->u = (un))\n-#define ffebld_constant_type(c) ((c)->consttype)\n-#define ffebld_constant_typeless(c) ((c)->u.typeless)\n-#define ffebld_constant_union(c) ((c)->u)\n-#define ffebld_conter(b) ((b)->u.conter.expr)\n-#define ffebld_conter_orig(b) ((b)->u.conter.orig)\n-#define ffebld_conter_pad(b) ((b)->u.conter.pad)\n-#define ffebld_conter_set_orig(b,o) ((b)->u.conter.orig = (o))\n-#define ffebld_conter_set_pad(b,p) ((b)->u.conter.pad = (p))\n-#define ffebld_copy(b) (b)\t/* ~~~Someday really make a copy. */\n-#define ffebld_cu_ptr_typeless(u) &(u).typeless\n-#define ffebld_cu_ptr_hollerith(u) &(u).hollerith\n-#define ffebld_cu_ptr_integer1(u) &(u).integer1\n-#define ffebld_cu_ptr_integer2(u) &(u).integer2\n-#define ffebld_cu_ptr_integer3(u) &(u).integer3\n-#define ffebld_cu_ptr_integer4(u) &(u).integer4\n-#define ffebld_cu_ptr_integer5(u) &(u).integer5\n-#define ffebld_cu_ptr_integer6(u) &(u).integer6\n-#define ffebld_cu_ptr_integer7(u) &(u).integer7\n-#define ffebld_cu_ptr_integer8(u) &(u).integer8\n-#define ffebld_cu_ptr_integerdefault ffebld_cu_ptr_integer1\n-#define ffebld_cu_ptr_logical1(u) &(u).logical1\n-#define ffebld_cu_ptr_logical2(u) &(u).logical2\n-#define ffebld_cu_ptr_logical3(u) &(u).logical3\n-#define ffebld_cu_ptr_logical4(u) &(u).logical4\n-#define ffebld_cu_ptr_logical5(u) &(u).logical5\n-#define ffebld_cu_ptr_logical6(u) &(u).logical6\n-#define ffebld_cu_ptr_logical7(u) &(u).logical7\n-#define ffebld_cu_ptr_logical8(u) &(u).logical8\n-#define ffebld_cu_ptr_logicaldefault ffebld_cu_ptr_logical1\n-#define ffebld_cu_ptr_real1(u) &(u).real1\n-#define ffebld_cu_ptr_real2(u) &(u).real2\n-#define ffebld_cu_ptr_real3(u) &(u).real3\n-#define ffebld_cu_ptr_real4(u) &(u).real4\n-#define ffebld_cu_ptr_real5(u) &(u).real5\n-#define ffebld_cu_ptr_real6(u) &(u).real6\n-#define ffebld_cu_ptr_real7(u) &(u).real7\n-#define ffebld_cu_ptr_real8(u) &(u).real8\n-#define ffebld_cu_ptr_realdefault ffebld_cu_ptr_real1\n-#define ffebld_cu_ptr_realdouble ffebld_cu_ptr_real2\n-#define ffebld_cu_ptr_realquad ffebld_cu_ptr_real3\n-#define ffebld_cu_ptr_complex1(u) &(u).complex1\n-#define ffebld_cu_ptr_complex2(u) &(u).complex2\n-#define ffebld_cu_ptr_complex3(u) &(u).complex3\n-#define ffebld_cu_ptr_complex4(u) &(u).complex4\n-#define ffebld_cu_ptr_complex5(u) &(u).complex5\n-#define ffebld_cu_ptr_complex6(u) &(u).complex6\n-#define ffebld_cu_ptr_complex7(u) &(u).complex7\n-#define ffebld_cu_ptr_complex8(u) &(u).complex8\n-#define ffebld_cu_ptr_complexdefault ffebld_cu_ptr_complex1\n-#define ffebld_cu_ptr_complexdouble ffebld_cu_ptr_complex2\n-#define ffebld_cu_ptr_complexquad ffebld_cu_ptr_complex3\n-#define ffebld_cu_ptr_character1(u) &(u).character1\n-#define ffebld_cu_ptr_character2(u) &(u).character2\n-#define ffebld_cu_ptr_character3(u) &(u).character3\n-#define ffebld_cu_ptr_character4(u) &(u).character4\n-#define ffebld_cu_ptr_character5(u) &(u).character5\n-#define ffebld_cu_ptr_character6(u) &(u).character6\n-#define ffebld_cu_ptr_character7(u) &(u).character7\n-#define ffebld_cu_ptr_character8(u) &(u).character8\n-#define ffebld_cu_val_typeless(u) (u).typeless\n-#define ffebld_cu_val_hollerith(u) (u).hollerith\n-#define ffebld_cu_val_integer1(u) (u).integer1\n-#define ffebld_cu_val_integer2(u) (u).integer2\n-#define ffebld_cu_val_integer3(u) (u).integer3\n-#define ffebld_cu_val_integer4(u) (u).integer4\n-#define ffebld_cu_val_integer5(u) (u).integer5\n-#define ffebld_cu_val_integer6(u) (u).integer6\n-#define ffebld_cu_val_integer7(u) (u).integer7\n-#define ffebld_cu_val_integer8(u) (u).integer8\n-#define ffebld_cu_val_integerdefault ffebld_cu_val_integer1\n-#define ffebld_cu_val_logical1(u) (u).logical1\n-#define ffebld_cu_val_logical2(u) (u).logical2\n-#define ffebld_cu_val_logical3(u) (u).logical3\n-#define ffebld_cu_val_logical4(u) (u).logical4\n-#define ffebld_cu_val_logical5(u) (u).logical5\n-#define ffebld_cu_val_logical6(u) (u).logical6\n-#define ffebld_cu_val_logical7(u) (u).logical7\n-#define ffebld_cu_val_logical8(u) (u).logical8\n-#define ffebld_cu_val_logicaldefault ffebld_cu_val_logical\n-#define ffebld_cu_val_real1(u) (u).real1\n-#define ffebld_cu_val_real2(u) (u).real2\n-#define ffebld_cu_val_real3(u) (u).real3\n-#define ffebld_cu_val_real4(u) (u).real4\n-#define ffebld_cu_val_real5(u) (u).real5\n-#define ffebld_cu_val_real6(u) (u).real6\n-#define ffebld_cu_val_real7(u) (u).real7\n-#define ffebld_cu_val_real8(u) (u).real8\n-#define ffebld_cu_val_realdefault ffebld_cu_val_real1\n-#define ffebld_cu_val_realdouble ffebld_cu_val_real2\n-#define ffebld_cu_val_realquad ffebld_cu_val_real3\n-#define ffebld_cu_val_complex1(u) (u).complex1\n-#define ffebld_cu_val_complex2(u) (u).complex2\n-#define ffebld_cu_val_complex3(u) (u).complex3\n-#define ffebld_cu_val_complex4(u) (u).complex4\n-#define ffebld_cu_val_complex5(u) (u).complex5\n-#define ffebld_cu_val_complex6(u) (u).complex6\n-#define ffebld_cu_val_complex7(u) (u).complex7\n-#define ffebld_cu_val_complex8(u) (u).complex8\n-#define ffebld_cu_val_complexdefault ffebld_cu_val_complex1\n-#define ffebld_cu_val_complexdouble ffebld_cu_val_complex2\n-#define ffebld_cu_val_complexquad ffebld_cu_val_complex3\n-#define ffebld_cu_val_character1(u) (u).character1\n-#define ffebld_cu_val_character2(u) (u).character2\n-#define ffebld_cu_val_character3(u) (u).character3\n-#define ffebld_cu_val_character4(u) (u).character4\n-#define ffebld_cu_val_character5(u) (u).character5\n-#define ffebld_cu_val_character6(u) (u).character6\n-#define ffebld_cu_val_character7(u) (u).character7\n-#define ffebld_cu_val_character8(u) (u).character8\n-#define ffebld_end_list(b) (*(b) = NULL)\n-#define ffebld_head(b) ((b)->u.item.head)\n-#define ffebld_info(b) ((b)->info)\n-#define ffebld_init_3()\n-#define ffebld_init_4()\n-#define ffebld_init_list(l,b) (*(l) = NULL, *(b) = (l))\n-#define ffebld_item_hook(b) ((b)->u.item.hook)\n-#define ffebld_item_set_hook(b,h) ((b)->u.item.hook = (h))\n-#define ffebld_kind(b) (ffeinfo_kind (ffebld_info ((b))))\n-#define ffebld_kindtype(b) (ffeinfo_kindtype (ffebld_info ((b))))\n-#define ffebld_labter(b) ((b)->u.labter)\n-#define ffebld_labtok(b) ((b)->u.labtok)\n-#define ffebld_left(b) ((b)->u.nonter.left)\n-#define ffebld_name_string(n) ((n)->name)\n-#define ffebld_new()\t\t\t\t\t\t\t      \\\n-  ((ffebld) malloc_new_kp(ffebld_pool(), \"FFEBLD\",sizeof(struct _ffebld_)))\n-#define ffebld_new_any() ffebld_new_none(FFEBLD_opANY)\n-#define ffebld_new_conter(c) ffebld_new_conter_with_orig((c),NULL)\n-#define ffebld_new_star() ffebld_new_none(FFEBLD_opSTAR)\n-#define ffebld_new_uplus(l) ffebld_new_one(FFEBLD_opUPLUS,(l))\n-#define ffebld_new_uminus(l) ffebld_new_one(FFEBLD_opUMINUS,(l))\n-#define ffebld_new_add(l,r) ffebld_new_two(FFEBLD_opADD,(l),(r))\n-#define ffebld_new_subtract(l,r) ffebld_new_two(FFEBLD_opSUBTRACT,(l),(r))\n-#define ffebld_new_multiply(l,r) ffebld_new_two(FFEBLD_opMULTIPLY,(l),(r))\n-#define ffebld_new_divide(l,r) ffebld_new_two(FFEBLD_opDIVIDE,(l),(r))\n-#define ffebld_new_power(l,r) ffebld_new_two(FFEBLD_opPOWER,(l),(r))\n-#define ffebld_new_bounds(l,r) ffebld_new_two(FFEBLD_opBOUNDS,(l),(r))\n-#define ffebld_new_concatenate(l,r) ffebld_new_two(FFEBLD_opCONCATENATE,(l),(r))\n-#define ffebld_new_not(l) ffebld_new_one(FFEBLD_opNOT,(l))\n-#define ffebld_new_lt(l,r) ffebld_new_two(FFEBLD_opLT,(l),(r))\n-#define ffebld_new_le(l,r) ffebld_new_two(FFEBLD_opLE,(l),(r))\n-#define ffebld_new_eq(l,r) ffebld_new_two(FFEBLD_opEQ,(l),(r))\n-#define ffebld_new_ne(l,r) ffebld_new_two(FFEBLD_opNE,(l),(r))\n-#define ffebld_new_gt(l,r) ffebld_new_two(FFEBLD_opGT,(l),(r))\n-#define ffebld_new_ge(l,r) ffebld_new_two(FFEBLD_opGE,(l),(r))\n-#define ffebld_new_and(l,r) ffebld_new_two(FFEBLD_opAND,(l),(r))\n-#define ffebld_new_or(l,r) ffebld_new_two(FFEBLD_opOR,(l),(r))\n-#define ffebld_new_xor(l,r) ffebld_new_two(FFEBLD_opXOR,(l),(r))\n-#define ffebld_new_eqv(l,r) ffebld_new_two(FFEBLD_opEQV,(l),(r))\n-#define ffebld_new_neqv(l,r) ffebld_new_two(FFEBLD_opNEQV,(l),(r))\n-#define ffebld_new_paren(l) ffebld_new_one(FFEBLD_opPAREN,(l))\n-#define ffebld_new_repeat(l,r) ffebld_new_two(FFEBLD_opREPEAT,(l),(r))\n-#define ffebld_new_percent_descr(l) ffebld_new_one(FFEBLD_opPERCENT_DESCR,(l))\n-#define ffebld_new_percent_loc(l) ffebld_new_one(FFEBLD_opPERCENT_LOC,(l))\n-#define ffebld_new_percent_ref(l) ffebld_new_one(FFEBLD_opPERCENT_REF,(l))\n-#define ffebld_new_percent_val(l) ffebld_new_one(FFEBLD_opPERCENT_VAL,(l))\n-#define ffebld_new_complex(l,r) ffebld_new_two(FFEBLD_opCOMPLEX,(l),(r))\n-#define ffebld_new_convert(l) ffebld_new_one(FFEBLD_opCONVERT,(l))\n-#define ffebld_new_funcref(l,r) ffebld_new_two(FFEBLD_opFUNCREF,(l),(r))\n-#define ffebld_new_subrref(l,r) ffebld_new_two(FFEBLD_opSUBRREF,(l),(r))\n-#define ffebld_new_arrayref(l,r) ffebld_new_two(FFEBLD_opARRAYREF,(l),(r))\n-#define ffebld_new_substr(l,r) ffebld_new_two(FFEBLD_opSUBSTR,(l),(r))\n-#define ffebld_new_impdo(l,r) ffebld_new_two(FFEBLD_opIMPDO,(l),(r))\n-#define ffebld_nonter_hook(b) ((b)->u.nonter.hook)\n-#define ffebld_nonter_set_hook(b,h) ((b)->u.nonter.hook = (h))\n-#define ffebld_op(b) ((b)->op)\n-#define ffebld_pool() (ffebld_pool_stack_.pool)\n-#define ffebld_rank(b) (ffeinfo_rank (ffebld_info ((b))))\n-#define ffebld_right(b) ((b)->u.nonter.right)\n-#define ffebld_set_accter(b,a) ((b)->u.accter.array = (a))\n-#define ffebld_set_arrter(b,a) ((b)->u.arrter.array = (a))\n-#define ffebld_set_conter(b,c) ((b)->u.conter.expr = (c))\n-#define ffebld_set_info(b,i) ((b)->info = (i))\n-#define ffebld_set_labter(b,l) ((b)->u.labter = (l))\n-#define ffebld_set_op(b,o) ((b)->op = (o))\n-#define ffebld_set_head(b,h) ((b)->u.item.head = (h))\n-#define ffebld_set_left(b,l) ((b)->u.nonter.left = (l))\n-#define ffebld_set_right(b,r) ((b)->u.nonter.right = (r))\n-#define ffebld_set_trail(b,t) ((b)->u.item.trail = (t))\n-#define ffebld_size(b) (ffeinfo_size (ffebld_info ((b))))\n-#define ffebld_size_known(b) ffebld_size((b))\n-#define ffebld_symter(b) ((b)->u.symter.symbol)\n-#define ffebld_symter_generic(b) ((b)->u.symter.generic)\n-#define ffebld_symter_doiter(b) ((b)->u.symter.do_iter)\n-#define ffebld_symter_implementation(b) ((b)->u.symter.implementation)\n-#define ffebld_symter_specific(b) ((b)->u.symter.specific)\n-#define ffebld_symter_set_generic(b,g) ((b)->u.symter.generic = (g))\n-#define ffebld_symter_set_implementation(b,i) \\\n-  ((b)->u.symter.implementation = (i))\n-#define ffebld_symter_set_is_doiter(b,f) ((b)->u.symter.do_iter = (f))\n-#define ffebld_symter_set_specific(b,s) ((b)->u.symter.specific = (s))\n-#define ffebld_terminate_0()\n-#define ffebld_terminate_1()\n-#define ffebld_terminate_2()\n-#define ffebld_terminate_3()\n-#define ffebld_terminate_4()\n-#define ffebld_trail(b) ((b)->u.item.trail)\n-#define ffebld_where(b) (ffeinfo_where (ffebld_info ((b))))\n-\n-/* End of #include file. */\n-\n-#endif /* ! GCC_F_BLD_H */"}, {"sha": "176072c0d21428b7409ff84833f3847161a6e484", "filename": "gcc/f/bugs.texi", "status": "removed", "additions": 0, "deletions": 267, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fbugs.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fbugs.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbugs.texi?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,267 +0,0 @@\n-@c Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n-@c This is part of the G77 manual.\n-@c For copying conditions, see the file g77.texi.\n-\n-@c The text of this file appears in the file BUGS\n-@c in the G77 distribution, as well as in the G77 manual.\n-\n-@c Keep this the same as the dates above, since it's used\n-@c in the standalone derivations of this file (e.g. BUGS).\n-@set copyrights-bugs 1995,1996,1997,1998,1999,2000,2001,2002\n-\n-@set last-update-bugs 2002-02-01\n-\n-@ifset DOC-BUGS\n-@include root.texi\n-@c The immediately following lines apply to the BUGS file\n-@c which is derived from this file.\n-@emph{Note:} This file is automatically generated from the files\n-@file{bugs0.texi} and @file{bugs.texi}.\n-@file{BUGS} is @emph{not} a source file,\n-although it is normally included within source distributions.\n-\n-This file lists known bugs in the @value{which-g77} version\n-of the GNU Fortran compiler.\n-Copyright (C) @value{copyrights-bugs} Free Software Foundation, Inc.\n-You may copy, distribute, and modify it freely as long as you preserve\n-this copyright notice and permission notice.\n-\n-@node Top,,, (dir)\n-@chapter Known Bugs In GNU Fortran\n-@end ifset\n-\n-@ifset DOC-G77\n-@node Known Bugs\n-@section Known Bugs In GNU Fortran\n-@end ifset\n-\n-This section identifies bugs that @code{g77} @emph{users}\n-might run into in the @value{which-g77} version\n-of @code{g77}.\n-This includes bugs that are actually in the @code{gcc}\n-back end (GBE) or in @code{libf2c}, because those\n-sets of code are at least somewhat under the control\n-of (and necessarily intertwined with) @code{g77},\n-so it isn't worth separating them out.\n-\n-@ifset DOC-G77\n-For information on bugs in @emph{other} versions of @code{g77},\n-see @ref{News,,News About GNU Fortran}.\n-There, lists of bugs fixed in various versions of @code{g77}\n-can help determine what bugs existed in prior versions.\n-@end ifset\n-\n-@ifset DOC-BUGS\n-For information on bugs in @emph{other} versions of @code{g77},\n-see @file{@value{path-g77}/NEWS}.\n-There, lists of bugs fixed in various versions of @code{g77}\n-can help determine what bugs existed in prior versions.\n-@end ifset\n-\n-@ifset DEVELOPMENT\n-@emph{Warning:} The information below is still under development,\n-and might not accurately reflect the @code{g77} code base\n-of which it is a part.\n-Efforts are made to keep it somewhat up-to-date,\n-but they are particularly concentrated\n-on any version of this information\n-that is distributed as part of a @emph{released} @code{g77}.\n-\n-In particular, while this information is intended to apply to\n-the @value{which-g77} version of @code{g77},\n-only an official @emph{release} of that version\n-is expected to contain documentation that is\n-most consistent with the @code{g77} product in that version.\n-@end ifset\n-\n-An online, ``live'' version of this document\n-(derived directly from the mainline, development version\n-of @code{g77} within @code{gcc})\n-is available via\n-@uref{http://gcc.gnu.org/onlinedocs/g77/Trouble.html}.\n-Follow the ``Known Bugs'' link.\n-\n-The following information was last updated on @value{last-update-bugs}:\n-\n-@itemize @bullet\n-@item\n-@code{g77} fails to warn about\n-use of a ``live'' iterative-DO variable\n-as an implied-DO variable\n-in a @code{WRITE} or @code{PRINT} statement\n-(although it does warn about this in a @code{READ} statement).\n-\n-@item\n-Something about @code{g77}'s straightforward handling of\n-label references and definitions sometimes prevents the GBE\n-from unrolling loops.\n-Until this is solved, try inserting or removing @code{CONTINUE}\n-statements as the terminal statement, using the @code{END DO}\n-form instead, and so on.\n-\n-@item\n-Some confusion in diagnostics concerning failing @code{INCLUDE}\n-statements from within @code{INCLUDE}'d or @code{#include}'d files.\n-\n-@cindex integer constants\n-@cindex constants, integer\n-@item\n-@code{g77} assumes that @code{INTEGER(KIND=1)} constants range\n-from @samp{-2**31} to @samp{2**31-1} (the range for\n-two's-complement 32-bit values),\n-instead of determining their range from the actual range of the\n-type for the configuration (and, someday, for the constant).\n-\n-Further, it generally doesn't implement the handling\n-of constants very well in that it makes assumptions about the\n-configuration that it no longer makes regarding variables (types).\n-\n-Included with this item is the fact that @code{g77} doesn't recognize\n-that, on IEEE-754/854-compliant systems, @samp{0./0.} should produce a NaN\n-and no warning instead of the value @samp{0.} and a warning.\n-\n-@cindex compiler speed\n-@cindex speed, of compiler\n-@cindex compiler memory usage\n-@cindex memory usage, of compiler\n-@cindex large aggregate areas\n-@cindex initialization, bug\n-@cindex DATA statement\n-@cindex statements, DATA\n-@item\n-@code{g77} uses way too much memory and CPU time to process large aggregate\n-areas having any initialized elements.\n-\n-For example, @samp{REAL A(1000000)} followed by @samp{DATA A(1)/1/}\n-takes up way too much time and space, including\n-the size of the generated assembler file.\n-\n-Version 0.5.18 improves cases like this---specifically,\n-cases of @emph{sparse} initialization that leave large, contiguous\n-areas uninitialized---significantly.\n-However, even with the improvements, these cases still\n-require too much memory and CPU time.\n-\n-(Version 0.5.18 also improves cases where the initial values are\n-zero to a much greater degree, so if the above example\n-ends with @samp{DATA A(1)/0/}, the compile-time performance\n-will be about as good as it will ever get, aside from unrelated\n-improvements to the compiler.)\n-\n-Note that @code{g77} does display a warning message to\n-notify the user before the compiler appears to hang.\n-@ifset DOC-G77\n-A warning message is issued when @code{g77} sees code that provides\n-initial values (e.g. via @code{DATA}) to an aggregate area (@code{COMMON}\n-or @code{EQUIVALENCE}, or even a large enough array or @code{CHARACTER}\n-variable)\n-that is large enough to increase @code{g77}'s compile time by roughly\n-a factor of 10.\n-\n-This size currently is quite small, since @code{g77}\n-currently has a known bug requiring too much memory\n-and time to handle such cases.\n-In @file{@value{path-g77}/data.c}, the macro\n-@code{FFEDATA_sizeTOO_BIG_INIT_} is defined\n-to the minimum size for the warning to appear.\n-The size is specified in storage units,\n-which can be bytes, words, or whatever, on a case-by-case basis.\n-\n-After changing this macro definition, you must\n-(of course) rebuild and reinstall @code{g77} for\n-the change to take effect.\n-\n-Note that, as of version 0.5.18, improvements have\n-reduced the scope of the problem for @emph{sparse}\n-initialization of large arrays, especially those\n-with large, contiguous uninitialized areas.\n-However, the warning is issued at a point prior to\n-when @code{g77} knows whether the initialization is sparse,\n-and delaying the warning could mean it is produced\n-too late to be helpful.\n-\n-Therefore, the macro definition should not be adjusted to\n-reflect sparse cases.\n-Instead, adjust it to generate the warning when densely\n-initialized arrays begin to cause responses noticeably slower\n-than linear performance would suggest.\n-@end ifset\n-\n-@cindex code, displaying main source\n-@cindex displaying main source code\n-@cindex debugging main source code\n-@cindex printing main source\n-@item\n-When debugging, after starting up the debugger but before being able\n-to see the source code for the main program unit, the user must currently\n-set a breakpoint at @code{MAIN__} (or @code{MAIN___} or @code{MAIN_} if\n-@code{MAIN__} doesn't exist)\n-and run the program until it hits the breakpoint.\n-At that point, the\n-main program unit is activated and about to execute its first\n-executable statement, but that's the state in which the debugger should\n-start up, as is the case for languages like C.\n-\n-@cindex debugger\n-@item\n-Debugging @code{g77}-compiled code using debuggers other than\n-@code{gdb} is likely not to work.\n-\n-Getting @code{g77} and @code{gdb} to work together is a known\n-problem---getting @code{g77} to work properly with other\n-debuggers, for which source code often is unavailable to @code{g77}\n-developers, seems like a much larger, unknown problem,\n-and is a lower priority than making @code{g77} and @code{gdb}\n-work together properly.\n-\n-On the other hand, information about problems other debuggers\n-have with @code{g77} output might make it easier to properly\n-fix @code{g77}, and perhaps even improve @code{gdb}, so it\n-is definitely welcome.\n-Such information might even lead to all relevant products\n-working together properly sooner.\n-\n-@cindex Alpha, support\n-@cindex support, Alpha\n-@item\n-@code{g77} doesn't work perfectly on 64-bit configurations\n-such as the Digital Semiconductor (``DEC'') Alpha.\n-\n-This problem is largely resolved as of version 0.5.23.\n-\n-@cindex padding\n-@cindex structures\n-@cindex common blocks\n-@cindex equivalence areas\n-@item\n-@code{g77} currently inserts needless padding for things like\n-@samp{COMMON A,IPAD} where @samp{A} is @code{CHARACTER*1} and @samp{IPAD}\n-is @code{INTEGER(KIND=1)} on machines like x86,\n-because the back end insists that @samp{IPAD}\n-be aligned to a 4-byte boundary,\n-but the processor has no such requirement\n-(though it is usually good for performance).\n-\n-The @code{gcc} back end needs to provide a wider array\n-of specifications of alignment requirements and preferences for targets,\n-and front ends like @code{g77} should take advantage of this\n-when it becomes available.\n-\n-@cindex complex performance\n-@cindex aliasing\n-@item\n-The @code{libf2c} routines that perform some run-time\n-arithmetic on @code{COMPLEX} operands\n-were modified circa version 0.5.20 of @code{g77}\n-to work properly even in the presence of aliased operands.\n-\n-While the @code{g77} and @code{netlib} versions of @code{libf2c}\n-differ on how this is accomplished,\n-the main differences are that we believe\n-the @code{g77} version works properly\n-even in the presence of @emph{partially} aliased operands.\n-\n-However, these modifications have reduced performance\n-on targets such as x86,\n-due to the extra copies of operands involved.\n-@end itemize"}, {"sha": "9636f4da3d4d0ce9111b7d689f1d5a8d98e618d7", "filename": "gcc/f/bugs0.texi", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fbugs0.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fbugs0.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fbugs0.texi?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,9 +0,0 @@\n-\\input texinfo  @c -*-texinfo-*-\n-@c %**start of header\n-@setfilename BUGS\n-@c %**end of header\n-\n-@c This tells bugs.texi that it's generating just the BUGS file.\n-@set DOC-BUGS\n-@include bugs.texi\n-@bye"}, {"sha": "185aef52d0582dea9c3159a1582f6cbb0d08c957", "filename": "gcc/f/com-rt.def", "status": "removed", "additions": 0, "deletions": 289, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fcom-rt.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fcom-rt.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom-rt.def?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,289 +0,0 @@\n-/* com-rt.def -- Public #include File (module.h template V1.0)\n-   Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Owning Modules:\n-      com.c\n-\n-   Modifications:\n-*/\n-\n-/* DEFGFRT(CODE,NAME,TYPE,VOLATILE,COMPLEX,CONST):\n-\n-   CODE -- the #define name to use to refer to the function in g77 code\n-\n-   NAME -- the name as seen by the back end and, with whatever massaging\n-\t   is normal, the linker\n-\n-   TYPE -- a code for the tree for the type, assigned when first encountered\n-\t   (NOTE: There's a distinction made between the semantic return\n-\t   value for the function, and the actual return mechanism; e.g.\n-\t   `r_abs()' computes a single-precision `float' return value\n-\t   but returns it as a `double'.  This distinction is important\n-\t   and is flagged via the _F2C_ versus _GNU_ suffix.)\n-\n-   ARGS -- a string of codes representing the types of the arguments; the\n-           last type specifies the type for that and all following args,\n-           and the null pointer (0) means the same as \"0\":\n-\n-               0  Not applicable at and beyond this point\n-               &  Pointer to type that follows\n-               a  char\n-               c  complex\n-               d  doublereal\n-               e  doublecomplex\n-               f  real\n-               i  integer\n-               j  longint\n-\n-   VOLATILE -- TRUE if the function never returns (gen's emit_barrier in\n-\t       g77 back end)\n-\n-   COMPLEX -- TRUE if the return value is COMPLEX or DOUBLE COMPLEX and\n-\t      thus might need to be returned as ptr-to-1st-arg\n-\n-   CONST -- TRUE if the function is const\n-            (does not have side effects and only depends on its arguments).\n-\n-*/\n-\n-DEFGFRT (FFECOM_gfrtCAT, \"s_cat\", FFECOM_rttypeVOID_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtCMP, \"s_cmp\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtCOPY, \"s_copy\", FFECOM_rttypeVOID_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtPAUSE, \"s_paus\", FFECOM_rttypeVOID_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSTOP, \"s_stop\", FFECOM_rttypeVOID_, 0, TRUE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtRANGE, \"s_rnge\", FFECOM_rttypeINTEGER_, 0, TRUE, FALSE, FALSE)\n-\n-DEFGFRT (FFECOM_gfrtSRDUE, \"s_rdue\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtERDUE, \"e_rdue\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSRSUE, \"s_rsue\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtERSUE, \"e_rsue\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSRDFE, \"s_rdfe\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtERDFE, \"e_rdfe\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSRSFI, \"s_rsfi\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtERSFI, \"e_rsfi\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSRSFE, \"s_rsfe\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtERSFE, \"e_rsfe\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSRSLI, \"s_rsli\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtERSLI, \"e_rsli\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSRSLE, \"s_rsle\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtERSLE, \"e_rsle\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSRSNE, \"s_rsne\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-\n-DEFGFRT (FFECOM_gfrtSWDUE, \"s_wdue\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtEWDUE, \"e_wdue\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSWSUE, \"s_wsue\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtEWSUE, \"e_wsue\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSWDFE, \"s_wdfe\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtEWDFE, \"e_wdfe\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSWSFI, \"s_wsfi\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtEWSFI, \"e_wsfi\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSWSFE, \"s_wsfe\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtEWSFE, \"e_wsfe\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSWSLI, \"s_wsli\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtEWSLI, \"e_wsli\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSWSLE, \"s_wsle\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtEWSLE, \"e_wsle\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSWSNE, \"s_wsne\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-\n-DEFGFRT (FFECOM_gfrtDOFIO, \"do_fio\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDOLIO, \"do_lio\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDOUIO, \"do_uio\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-\n-DEFGFRT (FFECOM_gfrtFOPEN, \"f_open\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtFCLOS, \"f_clos\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtFINQU, \"f_inqu\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-\n-DEFGFRT (FFECOM_gfrtFBACK, \"f_back\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtFEND, \"f_end\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtFREW, \"f_rew\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-\n-DEFGFRT (FFECOM_gfrtABORT, \"G77_abort_0\", FFECOM_rttypeVOID_, 0, TRUE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtABS, \"r_abs\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtACCESS, \"G77_access_0\", FFECOM_rttypeINTEGER_, \"&a&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtACOS, \"r_acos\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtAIMAG, \"r_imag\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtAINT, \"r_int\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtALARM, \"G77_alarm_0\", FFECOM_rttypeINTEGER_, \"&i0\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtALOG, \"r_log\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtALOG10, \"r_lg10\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtAMOD, \"r_mod\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtANINT, \"r_nint\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtASIN, \"r_asin\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtATAN, \"r_atan\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtATAN2, \"r_atn2\", FFECOM_rttypeREAL_F2C_, \"&f&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtCABS, \"c_abs\", FFECOM_rttypeREAL_F2C_, \"&c\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtCCOS, \"c_cos\", FFECOM_rttypeCOMPLEX_F2C_, \"&c\", FALSE, TRUE, FALSE)\n-DEFGFRT (FFECOM_gfrtCEXP, \"c_exp\", FFECOM_rttypeCOMPLEX_F2C_, \"&c\", FALSE, TRUE, FALSE)\n-DEFGFRT (FFECOM_gfrtCHDIR, \"G77_chdir_0\", FFECOM_rttypeINTEGER_, \"&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtCLOG, \"c_log\", FFECOM_rttypeCOMPLEX_F2C_, \"&c\", FALSE, TRUE, FALSE)\n-DEFGFRT (FFECOM_gfrtCHMOD, \"G77_chmod_0\", FFECOM_rttypeINTEGER_, \"&a&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtCONJG, \"r_cnjg\", FFECOM_rttypeCOMPLEX_F2C_, \"&c\", FALSE, TRUE, FALSE)\n-DEFGFRT (FFECOM_gfrtCOS, \"r_cos\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtCOSH, \"r_cosh\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtCSIN, \"c_sin\", FFECOM_rttypeCOMPLEX_F2C_, \"&c\", FALSE, TRUE, FALSE)\n-DEFGFRT (FFECOM_gfrtCSQRT, \"c_sqrt\", FFECOM_rttypeCOMPLEX_F2C_, \"&c\", FALSE, TRUE, FALSE)\n-DEFGFRT (FFECOM_gfrtCTIME, \"G77_ctime_0\", FFECOM_rttypeCHARACTER_, \"&j\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDABS, \"d_abs\", FFECOM_rttypeDOUBLE_, \"&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDACOS, \"d_acos\", FFECOM_rttypeDOUBLE_, \"&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDASIN, \"d_asin\", FFECOM_rttypeDOUBLE_, \"&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDATAN, \"d_atan\", FFECOM_rttypeDOUBLE_, \"&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDATAN2, \"d_atn2\", FFECOM_rttypeDOUBLE_, \"&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDATE, \"G77_date_y2kbug_0\", FFECOM_rttypeVOID_, \"&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDATE_AND_TIME, \"G77_date_and_time_0\", FFECOM_rttypeVOID_, \"&a&a&a&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtL_BESJ0, \"j0\", FFECOM_rttypeDOUBLE_, \"d\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtL_BESJ1, \"j1\", FFECOM_rttypeDOUBLE_, \"d\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtL_BESJN, \"jn\", FFECOM_rttypeDOUBLE_, \"id\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtL_BESY0, \"y0\", FFECOM_rttypeDOUBLE_, \"d\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtL_BESY1, \"y1\", FFECOM_rttypeDOUBLE_, \"d\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtL_BESYN, \"yn\", FFECOM_rttypeDOUBLE_, \"id\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtDCOS, \"d_cos\", FFECOM_rttypeDOUBLE_, \"&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDCOSH, \"d_cosh\", FFECOM_rttypeDOUBLE_, \"&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDDIM, \"d_dim\", FFECOM_rttypeDOUBLE_, \"&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDERF, \"G77_derf_0\", FFECOM_rttypeDOUBLE_, \"&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDERFC, \"G77_derfc_0\", FFECOM_rttypeDOUBLE_, \"&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDEXP, \"d_exp\", FFECOM_rttypeDOUBLE_, \"&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDIM, \"r_dim\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDINT, \"d_int\", FFECOM_rttypeDOUBLE_, \"&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDLOG, \"d_log\", FFECOM_rttypeDOUBLE_, \"&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDLOG10, \"d_lg10\", FFECOM_rttypeDOUBLE_, \"&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDMOD, \"d_mod\", FFECOM_rttypeDOUBLE_, \"&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDNINT, \"d_nint\", FFECOM_rttypeDOUBLE_, \"&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDPROD, \"d_prod\", FFECOM_rttypeDOUBLE_, \"&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDSIGN, \"d_sign\", FFECOM_rttypeDOUBLE_, \"&d&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDSIN, \"d_sin\", FFECOM_rttypeDOUBLE_, \"&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDSINH, \"d_sinh\", FFECOM_rttypeDOUBLE_, \"&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDSQRT, \"d_sqrt\", FFECOM_rttypeDOUBLE_, \"&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDTAN, \"d_tan\", FFECOM_rttypeDOUBLE_, \"&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDTANH, \"d_tanh\", FFECOM_rttypeDOUBLE_, \"&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtDTIME, \"G77_dtime_0\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtERF, \"G77_erf_0\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtERFC, \"G77_erfc_0\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtETIME, \"G77_etime_0\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtEXIT, \"G77_exit_0\", FFECOM_rttypeVOID_, \"&i\", TRUE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtEXP, \"r_exp\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtFDATE, \"G77_fdate_0\", FFECOM_rttypeCHARACTER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtFGET, \"G77_fget_0\", FFECOM_rttypeINTEGER_, \"&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtFGETC, \"G77_fgetc_0\", FFECOM_rttypeINTEGER_, \"&i&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtFLUSH, \"G77_flush_0\", FFECOM_rttypeVOID_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtFLUSH1, \"G77_flush1_0\", FFECOM_rttypeVOID_, \"&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtFNUM, \"G77_fnum_0\", FFECOM_rttypeINTEGER_, \"&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtFPUT, \"G77_fput_0\", FFECOM_rttypeINTEGER_, \"&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtFPUTC, \"G77_fputc_0\", FFECOM_rttypeINTEGER_, \"&i&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtFSTAT, \"G77_fstat_0\", FFECOM_rttypeINTEGER_, \"&i&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtFTELL, \"G77_ftell_0\", FFECOM_rttypeINTEGER_, \"&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtFSEEK, \"G77_fseek_0\", FFECOM_rttypeINTEGER_, \"&i&i&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtGERROR, \"G77_gerror_0\", FFECOM_rttypeVOID_, \"&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtGETARG, \"G77_getarg_0\", FFECOM_rttypeVOID_, \"&i&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtGETCWD, \"G77_getcwd_0\", FFECOM_rttypeINTEGER_, \"&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtGETGID, \"G77_getgid_0\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtGETLOG, \"G77_getlog_0\", FFECOM_rttypeVOID_, \"&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtGETPID, \"G77_getpid_0\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtGETUID, \"G77_getuid_0\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtGETENV, \"G77_getenv_0\", FFECOM_rttypeVOID_, \"&a&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtGMTIME, \"G77_gmtime_0\", FFECOM_rttypeVOID_, \"&i&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtHOSTNM, \"G77_hostnm_0\", FFECOM_rttypeINTEGER_, \"&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtIABS, \"i_abs\", FFECOM_rttypeINTEGER_, \"&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtIARGC, \"G77_iargc_0\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtIDATE, \"G77_idate_0\", FFECOM_rttypeVOID_, \"&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtIDIM, \"i_dim\", FFECOM_rttypeINTEGER_, \"&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtIDNINT, \"i_dnnt\", FFECOM_rttypeINTEGER_, \"&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtIERRNO, \"G77_ierrno_0\", FFECOM_rttypeINTEGER_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtINDEX, \"i_indx\", FFECOM_rttypeINTEGER_, \"&a&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtIRAND, \"G77_irand_0\", FFECOM_rttypeINTEGER_, \"&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtISIGN, \"i_sign\", FFECOM_rttypeINTEGER_, \"&i&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtISATTY, \"G77_isatty_0\", FFECOM_rttypeINTEGER_, \"&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtITIME, \"G77_itime_0\", FFECOM_rttypeVOID_, \"&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtKILL, \"G77_kill_0\", FFECOM_rttypeINTEGER_, \"&i&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtLEN, \"i_len\", FFECOM_rttypeINTEGER_, \"&a\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtLGE, \"l_ge\", FFECOM_rttypeLOGICAL_, \"&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtLGT, \"l_gt\", FFECOM_rttypeLOGICAL_, \"&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtLINK, \"G77_link_0\", FFECOM_rttypeINTEGER_, \"&a&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtLLE, \"l_le\", FFECOM_rttypeLOGICAL_, \"&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtLLT, \"l_lt\", FFECOM_rttypeLOGICAL_, \"&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtLNBLNK, \"G77_lnblnk_0\", FFECOM_rttypeINTEGER_, \"&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtLSTAT, \"G77_lstat_0\", FFECOM_rttypeINTEGER_, \"&a&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtLTIME, \"G77_ltime_0\", FFECOM_rttypeVOID_, \"&i&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtMCLOCK, \"G77_mclock_0\", FFECOM_rttypeLONGINT_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtMOD, \"i_mod\", FFECOM_rttypeINTEGER_, \"&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtNINT, \"i_nint\", FFECOM_rttypeINTEGER_, \"&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtPERROR, \"G77_perror_0\", FFECOM_rttypeVOID_, \"&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtRAND, \"G77_rand_0\", FFECOM_rttypeREAL_F2C_, \"&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtRENAME, \"G77_rename_0\", FFECOM_rttypeINTEGER_, \"&a&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSECNDS, \"G77_secnds_0\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSECOND, \"G77_second_0\", FFECOM_rttypeREAL_F2C_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSIGN, \"r_sign\", FFECOM_rttypeREAL_F2C_, \"&f&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtL_SIGNAL, \"G77_signal_0\", FFECOM_rttypeVOIDSTAR_, \"&i0\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSIN, \"r_sin\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSINH, \"r_sinh\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSLEEP, \"G77_sleep_0\", FFECOM_rttypeVOID_, \"&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSQRT, \"r_sqrt\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSRAND, \"G77_srand_0\", FFECOM_rttypeVOID_, \"&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSTAT, \"G77_stat_0\", FFECOM_rttypeINTEGER_, \"&a&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSYMLNK, \"G77_symlnk_0\", FFECOM_rttypeINTEGER_, \"&a&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSYSTEM, \"G77_system_0\", FFECOM_rttypeINTEGER_, \"&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtSYSTEM_CLOCK, \"G77_system_clock_0\", FFECOM_rttypeVOID_, \"&i&i&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtTAN, \"r_tan\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtTANH, \"r_tanh\", FFECOM_rttypeREAL_F2C_, \"&f\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtTIME, \"G77_time_0\", FFECOM_rttypeLONGINT_, 0, FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtTTYNAM, \"G77_ttynam_0\", FFECOM_rttypeCHARACTER_, \"&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtUNLINK, \"G77_unlink_0\", FFECOM_rttypeINTEGER_, \"&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtUMASK, \"G77_umask_0\", FFECOM_rttypeINTEGER_, \"&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtVXTIDATE, \"G77_vxtidate_y2kbug_0\", FFECOM_rttypeVOID_, \"&i&i&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtVXTTIME, \"G77_vxttime_0\", FFECOM_rttypeVOID_, \"&a\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtCDABS, \"z_abs\", FFECOM_rttypeDOUBLE_, \"&e\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtCDCOS, \"z_cos\", FFECOM_rttypeDBLCMPLX_F2C_, \"&e\", FALSE, TRUE, FALSE)\n-DEFGFRT (FFECOM_gfrtCDEXP, \"z_exp\", FFECOM_rttypeDBLCMPLX_F2C_, \"&e\", FALSE, TRUE, FALSE)\n-DEFGFRT (FFECOM_gfrtCDLOG, \"z_log\", FFECOM_rttypeDBLCMPLX_F2C_, \"&e\", FALSE, TRUE, FALSE)\n-DEFGFRT (FFECOM_gfrtDCONJG, \"d_cnjg\", FFECOM_rttypeDBLCMPLX_F2C_, \"&e\", FALSE, TRUE, FALSE)\n-DEFGFRT (FFECOM_gfrtCDSIN, \"z_sin\", FFECOM_rttypeDBLCMPLX_F2C_, \"&e\", FALSE, TRUE, FALSE)\n-DEFGFRT (FFECOM_gfrtCDSQRT, \"z_sqrt\", FFECOM_rttypeDBLCMPLX_F2C_, \"&e\", FALSE, TRUE, FALSE)\n-DEFGFRT (FFECOM_gfrtDIMAG, \"d_imag\", FFECOM_rttypeDOUBLE_, \"&e\", FALSE, FALSE, FALSE)\n-\n-DEFGFRT (FFECOM_gfrtL_ACOS, \"acos\", FFECOM_rttypeDOUBLE_, \"d\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtL_ASIN, \"asin\", FFECOM_rttypeDOUBLE_, \"d\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtL_ATAN, \"__builtin_atan\", FFECOM_rttypeDOUBLE_, \"d\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtL_ATAN2, \"__builtin_atan2\", FFECOM_rttypeDOUBLE_, \"dd\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtL_COS, \"__builtin_cos\", FFECOM_rttypeDOUBLE_, \"d\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtL_COSH, \"cosh\", FFECOM_rttypeDOUBLE_, \"d\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtL_ERF, \"erf\", FFECOM_rttypeDOUBLE_, \"d\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtL_ERFC, \"erfc\", FFECOM_rttypeDOUBLE_, \"d\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtL_EXP, \"__builtin_exp\", FFECOM_rttypeDOUBLE_, \"d\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtL_FLOOR, \"__builtin_floor\", FFECOM_rttypeDOUBLE_, \"d\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtL_FMOD, \"__builtin_fmod\", FFECOM_rttypeDOUBLE_, \"dd\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtL_LOG, \"__builtin_log\", FFECOM_rttypeDOUBLE_, \"d\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtL_LOG10, \"log10\", FFECOM_rttypeDOUBLE_, \"d\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtL_POW, \"__builtin_pow\", FFECOM_rttypeDOUBLE_, \"dd\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtL_SIN, \"__builtin_sin\", FFECOM_rttypeDOUBLE_, \"d\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtL_SINH, \"sinh\", FFECOM_rttypeDOUBLE_, \"d\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtL_SQRT, \"__builtin_sqrt\", FFECOM_rttypeDOUBLE_, \"d\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtL_TAN, \"__builtin_tan\", FFECOM_rttypeDOUBLE_, \"d\", FALSE, FALSE, TRUE)\n-DEFGFRT (FFECOM_gfrtL_TANH, \"tanh\", FFECOM_rttypeDOUBLE_, \"d\", FALSE, FALSE, TRUE)\n-\n-DEFGFRT (FFECOM_gfrtPOW_CI, \"pow_ci\", FFECOM_rttypeCOMPLEX_F2C_, \"&c&i\", FALSE, TRUE, FALSE)\n-DEFGFRT (FFECOM_gfrtPOW_DD, \"pow_dd\", FFECOM_rttypeDOUBLE_, \"&d&d\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtPOW_DI, \"pow_di\", FFECOM_rttypeDOUBLE_, \"&d&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtPOW_II, \"pow_ii\", FFECOM_rttypeINTEGER_, \"&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtPOW_QQ, \"pow_qq\", FFECOM_rttypeLONGINT_, \"&j&j\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtPOW_RI, \"pow_ri\", FFECOM_rttypeREAL_F2C_, \"&f&i\", FALSE, FALSE, FALSE)\n-DEFGFRT (FFECOM_gfrtPOW_ZI, \"pow_zi\", FFECOM_rttypeDBLCMPLX_F2C_, \"&e&i\", FALSE, TRUE, FALSE)\n-DEFGFRT (FFECOM_gfrtPOW_ZZ, \"pow_zz\", FFECOM_rttypeDBLCMPLX_F2C_, \"&e&e\", FALSE, TRUE, FALSE)\n-DEFGFRT (FFECOM_gfrtDIV_CC, \"c_div\", FFECOM_rttypeCOMPLEX_F2C_, \"&c\", FALSE, TRUE, FALSE)\n-DEFGFRT (FFECOM_gfrtDIV_ZZ, \"z_div\", FFECOM_rttypeDBLCMPLX_F2C_, \"&e\", FALSE, TRUE, FALSE)"}, {"sha": "951e01891ba584d753f4804e930ad48a683da802", "filename": "gcc/f/com.c", "status": "removed", "additions": 0, "deletions": 16532, "changes": 16532, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "d23db6687a2f36c9037c81e180290655d8eb7a1b", "filename": "gcc/f/com.h", "status": "removed", "additions": 0, "deletions": 290, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fcom.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fcom.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.h?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,290 +0,0 @@\n-/* com.h -- Public #include File (module.h template V1.0)\n-   Copyright (C) 1995, 1996, 1997, 2000, 2003, 2004\n-   Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Owning Modules:\n-      com.c\n-\n-   Modifications:\n-*/\n-\n-/* Allow multiple inclusion to work. */\n-\n-#ifndef GCC_F_COM_H\n-#define GCC_F_COM_H\n-\n-/* Simple definitions and enumerations. */\n-\n-#define FFECOM_dimensionsMAX 7\t/* Max # dimensions (quick hack). */\n-\n-#define FFECOM_SIZE_UNIT \"byte\"\t/* Singular form. */\n-#define FFECOM_SIZE_UNITS \"bytes\"\t/* Plural form. */\n-\n-#define FFECOM_constantNULL NULL_TREE\n-#define FFECOM_nonterNULL NULL_TREE\n-#define FFECOM_globalNULL NULL_TREE\n-#define FFECOM_labelNULL NULL_TREE\n-#define FFECOM_storageNULL NULL_TREE\n-#define FFECOM_symbolNULL ffecom_symbol_null_\n-\n-/* Shorthand for types used in f2c.h and that g77 perhaps allows some\n-   flexibility regarding in the section below.  I.e. the actual numbers\n-   below aren't important, as long as they're unique.  */\n-\n-#define FFECOM_f2ccodeCHAR 1\n-#define FFECOM_f2ccodeSHORT 2\n-#define FFECOM_f2ccodeINT 3\n-#define FFECOM_f2ccodeLONG 4\n-#define FFECOM_f2ccodeLONGLONG 5\n-#define FFECOM_f2ccodeCHARPTR 6\t\t/* char * */\n-#define FFECOM_f2ccodeFLOAT 7\n-#define FFECOM_f2ccodeDOUBLE 8\n-#define FFECOM_f2ccodeLONGDOUBLE 9\n-#define FFECOM_f2ccodeTWOREALS 10\n-#define FFECOM_f2ccodeTWODOUBLEREALS 11\n-\n-#if FFECOM_DETERMINE_TYPES\t/* only for com.c and configure */\n-\n-/* Begin f2c.h information.  This must match the info in the f2c.h used\n-   to build the libf2c with which g77-generated code is linked, or there\n-   will probably be bugs, some of them difficult to detect or even trigger.  */\n-\n-/* The C front-end provides __g77_integer and __g77_uinteger types so that\n-   the appropriately-sized signed and unsigned integer types are available\n-   for libf2c.  If you change this, also the definitions of those types\n-   in ../c-decl.c. */\n-#define FFECOM_f2cINTEGER\t\t\t\\\n-  (LONG_TYPE_SIZE == FLOAT_TYPE_SIZE\t\t\\\n-   ? FFECOM_f2ccodeLONG\t\t\t\t\\\n-   : (INT_TYPE_SIZE == FLOAT_TYPE_SIZE\t\t\\\n-      ? FFECOM_f2ccodeINT\t\t\t\\\n-      : (abort (), -1)))\n-\n-#define FFECOM_f2cLOGICAL FFECOM_f2cINTEGER\n-\n-/* The C front-end provides __g77_longint and __g77_ulongint types so that\n-   the appropriately-sized signed and unsigned integer types are available\n-   for libf2c.  If you change this, also the definitions of those types\n-   in ../c-decl.c. */\n-#define FFECOM_f2cLONGINT\t\t\t\t\\\n- (LONG_TYPE_SIZE == (FLOAT_TYPE_SIZE * 2)\t\t\\\n-  ? FFECOM_f2ccodeLONG\t\t\t\t\t\\\n-  : (LONG_LONG_TYPE_SIZE == (FLOAT_TYPE_SIZE * 2)\t\\\n-     ? FFECOM_f2ccodeLONGLONG\t\t\t\t\\\n-     : (abort (), -1)))\n-\n-#define FFECOM_f2cADDRESS FFECOM_f2ccodeCHARPTR\n-#define FFECOM_f2cSHORTINT FFECOM_f2ccodeSHORT\n-#define FFECOM_f2cREAL FFECOM_f2ccodeFLOAT\n-#define FFECOM_f2cDOUBLEREAL FFECOM_f2ccodeDOUBLE\n-#define FFECOM_f2cCOMPLEX FFECOM_f2ccodeTWOREALS\n-#define FFECOM_f2cDOUBLECOMPLEX FFECOM_f2ccodeTWODOUBLEREALS\n-#define FFECOM_f2cSHORTLOGICAL FFECOM_f2ccodeSHORT\n-#define FFECOM_f2cLOGICAL1 FFECOM_f2ccodeCHAR\n-#define FFECOM_f2cINTEGER1 FFECOM_f2ccodeCHAR\n-\n-/* These must be f2c's INTEGER type, to match runtime/f2c.h.in.  */\n-\n-#define FFECOM_f2cFLAG FFECOM_f2cINTEGER\n-#define FFECOM_f2cFTNINT FFECOM_f2cINTEGER\n-#define FFECOM_f2cFTNLEN FFECOM_f2cINTEGER\n-\n-#endif\t/* #if FFECOM_DETERMINE_TYPES */\n-\n-/* Everything else in f2c.h, specifically the structures used in\n-   interfacing compiled code with the library, must remain exactly\n-   as delivered, or g77 internals (mostly com.c and ste.c) must\n-   be modified accordingly to compensate.  Or there will be...trouble.  */\n-\n-typedef enum\n-  {\n-#define DEFGFRT(CODE,NAME,TYPE,ARGS,VOLATILE,COMPLEX,CONST) CODE,\n-#include \"com-rt.def\"\n-#undef DEFGFRT\n-    FFECOM_gfrt\n-  } ffecomGfrt;\n-\n-/* Typedefs. */\n-\n-#ifndef TREE_CODE\n-#include \"tree.h\"\n-#endif\n-\n-typedef tree ffecomConstant;\n-typedef tree ffecomNonter;\n-typedef tree ffecomLabel;\n-typedef tree ffecomGlobal;\n-typedef tree ffecomStorage;\n-typedef struct _ffecom_symbol_ ffecomSymbol;\n-\n-struct _ffecom_symbol_\n-  {\n-    tree decl_tree;\n-    tree length_tree;\t\t/* For CHARACTER dummies. */\n-    tree vardesc_tree;\t\t/* For NAMELIST. */\n-    tree assign_tree;\t\t/* For ASSIGN'ed vars. */\n-    bool addr;\t\t\t/* Is address of item instead of item. */\n-  };\n-\n-/* Include files needed by this one. */\n-\n-#include \"bld.h\"\n-#include \"info.h\"\n-#include \"lab.h\"\n-#include \"storag.h\"\n-#include \"symbol.h\"\n-\n-extern int global_bindings_p (void);\n-extern tree getdecls (void);\n-extern void pushlevel (int);\n-extern tree poplevel (int,int, int);\n-extern void insert_block (tree);\n-extern void set_block (tree);\n-extern tree pushdecl (tree);\n-\n-/* Global objects accessed by users of this module. */\n-\n-extern GTY(()) tree string_type_node;\n-extern GTY(()) tree ffecom_integer_type_node;\n-extern GTY(()) tree ffecom_integer_zero_node;\n-extern GTY(()) tree ffecom_integer_one_node;\n-extern GTY(()) tree ffecom_tree_type[FFEINFO_basictype][FFEINFO_kindtype];\n-extern ffecomSymbol ffecom_symbol_null_;\n-extern ffeinfoKindtype ffecom_pointer_kind_;\n-extern ffeinfoKindtype ffecom_label_kind_;\n-\n-extern int ffecom_f2c_typecode_[FFEINFO_basictype][FFEINFO_kindtype];\n-extern GTY(()) tree ffecom_f2c_integer_type_node;\n-extern GTY(()) tree ffecom_f2c_address_type_node;\n-extern GTY(()) tree ffecom_f2c_real_type_node;\n-extern GTY(()) tree ffecom_f2c_doublereal_type_node;\n-extern GTY(()) tree ffecom_f2c_complex_type_node;\n-extern GTY(()) tree ffecom_f2c_doublecomplex_type_node;\n-extern GTY(()) tree ffecom_f2c_longint_type_node;\n-extern GTY(()) tree ffecom_f2c_logical_type_node;\n-extern GTY(()) tree ffecom_f2c_flag_type_node;\n-extern GTY(()) tree ffecom_f2c_ftnlen_type_node;\n-extern GTY(()) tree ffecom_f2c_ftnlen_zero_node;\n-extern GTY(()) tree ffecom_f2c_ftnlen_one_node;\n-extern GTY(()) tree ffecom_f2c_ftnlen_two_node;\n-extern GTY(()) tree ffecom_f2c_ptr_to_ftnlen_type_node;\n-extern GTY(()) tree ffecom_f2c_ftnint_type_node;\n-extern GTY(()) tree ffecom_f2c_ptr_to_ftnint_type_node;\n-\n-/* Declare functions with prototypes. */\n-\n-tree ffecom_1 (enum tree_code code, tree type, tree node);\n-tree ffecom_1_fn (tree node);\n-tree ffecom_2 (enum tree_code code, tree type, tree node1, tree node2);\n-bool ffecom_2pass_advise_entrypoint (ffesymbol entry);\n-void ffecom_2pass_do_entrypoint (ffesymbol entry);\n-tree ffecom_2s (enum tree_code code, tree type, tree node1, tree node2);\n-tree ffecom_3 (enum tree_code code, tree type, tree node1, tree node2,\n-\t       tree node3);\n-tree ffecom_3s (enum tree_code code, tree type, tree node1, tree node2,\n-\t\ttree node3);\n-tree ffecom_arg_expr (ffebld expr, tree *length);\n-tree ffecom_arg_ptr_to_const_expr (ffebld expr, tree *length);\n-tree ffecom_arg_ptr_to_expr (ffebld expr, tree *length);\n-tree ffecom_call_gfrt (ffecomGfrt ix, tree args, tree hook);\n-tree ffecom_constantunion_with_type (ffebldConstantUnion *cu, \n-\t\t            tree tree_type,ffebldConst ct);\n-tree ffecom_constantunion (ffebldConstantUnion *cu, ffeinfoBasictype bt,\n-\t\t\t   ffeinfoKindtype kt, tree tree_type);\n-tree ffecom_const_expr (ffebld expr);\n-tree ffecom_decl_field (tree context, tree prevfield, const char *name,\n-\t\t\ttree type);\n-void ffecom_close_include (FILE *f);\n-void ffecom_decode_include_option (const char *dir);\n-tree ffecom_end_compstmt (void);\n-void ffecom_end_transition (void);\n-void ffecom_exec_transition (void);\n-void ffecom_expand_let_stmt (ffebld dest, ffebld source);\n-tree ffecom_expr (ffebld expr);\n-tree ffecom_expr_assign (ffebld expr);\n-tree ffecom_expr_assign_w (ffebld expr);\n-tree ffecom_expr_rw (tree type, ffebld expr);\n-tree ffecom_expr_w (tree type, ffebld expr);\n-void ffecom_finish_compile (void);\n-void ffecom_finish_decl (tree decl, tree init, bool is_top_level);\n-void ffecom_finish_progunit (void);\n-tree ffecom_get_invented_identifier (const char *pattern, ...)\n-  ATTRIBUTE_PRINTF_1;\n-ffeinfoBasictype ffecom_gfrt_basictype (ffecomGfrt ix);\n-ffeinfoKindtype ffecom_gfrt_kindtype (ffecomGfrt ix);\n-void ffecom_init_0 (void);\n-void ffecom_init_2 (void);\n-tree ffecom_list_expr (ffebld list);\n-tree ffecom_list_ptr_to_expr (ffebld list);\n-tree ffecom_lookup_label (ffelab label);\n-tree ffecom_make_tempvar (const char *commentary, tree type,\n-\t\t\t  ffetargetCharacterSize size, int elements);\n-tree ffecom_modify (tree newtype, tree lhs, tree rhs);\n-void ffecom_save_tree_forever (tree t);\n-void ffecom_file (const char *name);\n-void ffecom_notify_init_storage (ffestorag st);\n-void ffecom_notify_init_symbol (ffesymbol s);\n-void ffecom_notify_primary_entry (ffesymbol fn);\n-FILE *ffecom_open_include (char *name, ffewhereLine l, ffewhereColumn c);\n-void ffecom_prepare_arg_ptr_to_expr (ffebld expr);\n-bool ffecom_prepare_end (void);\n-void ffecom_prepare_expr_ (ffebld expr, ffebld dest);\n-void ffecom_prepare_expr_rw (tree type, ffebld expr);\n-void ffecom_prepare_expr_w (tree type, ffebld expr);\n-void ffecom_prepare_ptr_to_expr (ffebld expr);\n-void ffecom_prepare_return_expr (ffebld expr);\n-tree ffecom_ptr_to_const_expr (ffebld expr);\n-tree ffecom_ptr_to_expr (ffebld expr);\n-tree ffecom_return_expr (ffebld expr);\n-tree ffecom_save_tree (tree t);\n-void ffecom_start_compstmt (void);\n-tree ffecom_start_decl (tree decl, bool is_init);\n-void ffecom_sym_commit (ffesymbol s);\n-ffesymbol ffecom_sym_end_transition (ffesymbol s);\n-ffesymbol ffecom_sym_exec_transition (ffesymbol s);\n-ffesymbol ffecom_sym_learned (ffesymbol s);\n-void ffecom_sym_retract (ffesymbol s);\n-tree ffecom_temp_label (void);\n-tree ffecom_truth_value (tree expr);\n-tree ffecom_truth_value_invert (tree expr);\n-tree ffecom_type_expr (ffebld expr);\n-tree ffecom_which_entrypoint_decl (void);\n-void ffe_parse_file (int);\n-\n-/* Define macros. */\n-\n-#define ffecom_f2c_typecode(bt,kt) ffecom_f2c_typecode_[(bt)][(kt)]\n-#define ffecom_label_kind() ffecom_label_kind_\n-#define ffecom_pointer_kind() ffecom_pointer_kind_\n-#define ffecom_prepare_expr(e) ffecom_prepare_expr_ ((e), NULL)\n-\n-#define ffecom_init_1()\n-#define ffecom_init_3()\n-#define ffecom_init_4()\n-#define ffecom_terminate_0()\n-#define ffecom_terminate_1()\n-#define ffecom_terminate_2()\n-#define ffecom_terminate_3()\n-#define ffecom_terminate_4()\n-\n-/* End of #include file. */\n-\n-#endif /* ! GCC_F_COM_H */"}, {"sha": "8ec70f7af8c9d0fc4902bed8224ba2e203a54511", "filename": "gcc/f/config-lang.in", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fconfig-lang.in?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,38 +0,0 @@\n-# Top level configure fragment for GNU FORTRAN.\n-#   Copyright (C) 1995, 1996, 1997, 2000, 2001, 2002 Free Software Foundation, Inc.\n-\n-#This file is part of GNU Fortran.\n-\n-#GNU Fortran is free software; you can redistribute it and/or modify\n-#it under the terms of the GNU General Public License as published by\n-#the Free Software Foundation; either version 2, or (at your option)\n-#any later version.\n-\n-#GNU Fortran is distributed in the hope that it will be useful,\n-#but WITHOUT ANY WARRANTY; without even the implied warranty of\n-#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-#GNU General Public License for more details.\n-\n-#You should have received a copy of the GNU General Public License\n-#along with GNU Fortran; see the file COPYING.  If not, write to\n-#the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-#02111-1307, USA.\n-\n-# Configure looks for the existence of this file to auto-config each language.\n-# We define several parameters used by configure:\n-#\n-# language\t- name of language as it would appear in $(LANGUAGES)\n-# compilers\t- value to add to $(COMPILERS)\n-# stagestuff\t- files to add to $(STAGESTUFF)\n-\n-language=\"f77\"\n-\n-compilers=\"f771\\$(exeext)\"\n-\n-stagestuff=\"g77\\$(exeext) g77-cross\\$(exeext) f771\\$(exeext)\"\n-\n-target_libs=target-libf2c\n-\n-gtfiles=\"\\$(srcdir)/f/com.c \\$(srcdir)/f/com.h \\$(srcdir)/f/ste.c \\$(srcdir)/f/where.h \\$(srcdir)/f/where.c \\$(srcdir)/f/lex.c\"\n-\n-build_by_default=no"}, {"sha": "2040f0ab6dc21304d6b6b92aa9e65a3335b61d2c", "filename": "gcc/f/data.c", "status": "removed", "additions": 0, "deletions": 1877, "changes": 1877, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fdata.c?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,1877 +0,0 @@\n-/* data.c -- Implementation File (module.c template V1.0)\n-   Copyright (C) 1995, 1996, 2002, 2003 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Related Modules:\n-\n-   Description:\n-      Do the tough things for DATA statement (and INTEGER FOO/.../-style\n-      initializations), like implied-DO and suchlike.\n-\n-   Modifications:\n-*/\n-\n-/* Include files. */\n-\n-#include \"proj.h\"\n-#include \"data.h\"\n-#include \"bit.h\"\n-#include \"bld.h\"\n-#include \"com.h\"\n-#include \"expr.h\"\n-#include \"global.h\"\n-#include \"malloc.h\"\n-#include \"st.h\"\n-#include \"storag.h\"\n-#include \"top.h\"\n-\n-/* Externals defined here. */\n-\n-\n-/* Simple definitions and enumerations. */\n-\n-/* I picked this value as one that, when plugged into a couple of small\n-   but nearly identical test cases I have called BIG-0.f and BIG-1.f,\n-   causes BIG-1.f to take about 10 times as long (elapsed) to compile\n-   (in f771 only) as BIG-0.f.  These test cases differ in that BIG-0.f\n-   doesn't put the one initialized variable in a common area that has\n-   a large uninitialized array in it, while BIG-1.f does.  The size of\n-   the array is this many elements, as long as they all are INTEGER\n-   type.  Note that, as of 0.5.18, sparse cases are better handled,\n-   so BIG-2.f now is used; it provides nonzero initial\n-   values for all elements of the same array BIG-0 has.  */\n-#ifndef FFEDATA_sizeTOO_BIG_INIT_\n-#define FFEDATA_sizeTOO_BIG_INIT_ 75*1024\n-#endif\n-\n-/* Internal typedefs. */\n-\n-typedef struct _ffedata_convert_cache_ *ffedataConvertCache_;\n-typedef struct _ffedata_impdo_ *ffedataImpdo_;\n-\n-/* Private include files. */\n-\n-\n-/* Internal structure definitions. */\n-\n-struct _ffedata_convert_cache_\n-  {\n-    ffebld converted;\t\t/* Results of converting expr to following\n-\t\t\t\t   type. */\n-    ffeinfoBasictype basic_type;\n-    ffeinfoKindtype kind_type;\n-    ffetargetCharacterSize size;\n-    ffeinfoRank rank;\n-  };\n-\n-struct _ffedata_impdo_\n-  {\n-    ffedataImpdo_ outer;\t/* Enclosing IMPDO construct. */\n-    ffebld outer_list;\t\t/* Item after my IMPDO on the outer list. */\n-    ffebld my_list;\t\t/* Beginning of list in my IMPDO. */\n-    ffesymbol itervar;\t\t/* Iteration variable. */\n-    ffetargetIntegerDefault increment;\n-    ffetargetIntegerDefault final;\n-  };\n-\n-/* Static objects accessed by functions in this module. */\n-\n-static ffedataImpdo_ ffedata_stack_ = NULL;\n-static ffebld ffedata_list_ = NULL;\n-static bool ffedata_reinit_;\t/* value_ should report REINIT error. */\n-static bool ffedata_reported_error_;\t/* Error has been reported. */\n-static ffesymbol ffedata_symbol_ = NULL;\t/* Symbol being initialized. */\n-static ffeinfoBasictype ffedata_basictype_;\t/* Info on symbol. */\n-static ffeinfoKindtype ffedata_kindtype_;\n-static ffestorag ffedata_storage_;\t/* If non-NULL, inits go into this parent. */\n-static ffeinfoBasictype ffedata_storage_bt_;\t/* Info on storage. */\n-static ffeinfoKindtype ffedata_storage_kt_;\n-static ffetargetOffset ffedata_storage_size_;\t/* Size of entire storage. */\n-static ffetargetAlign ffedata_storage_units_;\t/* #units per storage unit. */\n-static ffetargetOffset ffedata_arraysize_;\t/* Size of array being\n-\t\t\t\t\t\t   inited. */\n-static ffetargetOffset ffedata_expected_;\t/* Number of elements to\n-\t\t\t\t\t\t   init. */\n-static ffetargetOffset ffedata_number_;\t/* #elements inited so far. */\n-static ffetargetOffset ffedata_offset_;\t/* Offset of next element. */\n-static ffetargetOffset ffedata_symbolsize_;\t/* Size of entire sym. */\n-static ffetargetCharacterSize ffedata_size_;\t/* Size of an element. */\n-static ffetargetCharacterSize ffedata_charexpected_;\t/* #char to init. */\n-static ffetargetCharacterSize ffedata_charnumber_;\t/* #chars inited. */\n-static ffetargetCharacterSize ffedata_charoffset_;\t/* Offset of next char. */\n-static ffedataConvertCache_ ffedata_convert_cache_;\t/* Fewer conversions. */\n-static int ffedata_convert_cache_max_ = 0;\t/* #entries available. */\n-static int ffedata_convert_cache_use_ = 0;\t/* #entries in use. */\n-\n-/* Static functions (internal). */\n-\n-static bool ffedata_advance_ (void);\n-static ffebld ffedata_convert_ (ffebld source, ffelexToken source_token,\n-\t    ffelexToken dest_token, ffeinfoBasictype bt, ffeinfoKindtype kt,\n-\t\t\t\tffeinfoRank rk, ffetargetCharacterSize sz);\n-static ffetargetInteger1 ffedata_eval_integer1_ (ffebld expr);\n-static ffetargetOffset ffedata_eval_offset_ (ffebld subscripts,\n-\t\t\t\t\t     ffebld dims);\n-static ffetargetCharacterSize ffedata_eval_substr_begin_ (ffebld expr);\n-static ffetargetCharacterSize ffedata_eval_substr_end_ (ffebld expr,\n-\t\t    ffetargetCharacterSize min, ffetargetCharacterSize max);\n-static void ffedata_gather_ (ffestorag mst, ffestorag st);\n-static void ffedata_pop_ (void);\n-static void ffedata_push_ (void);\n-static bool ffedata_value_ (ffebld value, ffelexToken token);\n-\n-/* Internal macros. */\n-\f\n-\n-/* ffedata_begin -- Initialize with list of targets\n-\n-   ffebld list;\n-   ffedata_begin(list);\t // ITEM... list of SYMTERs, ARRAYs, SUBSTRs, ...\n-\n-   Remember the list.  After this call, 0...n calls to ffedata_value must\n-   follow, and then a single call to ffedata_end.  */\n-\n-void\n-ffedata_begin (ffebld list)\n-{\n-  assert (ffedata_list_ == NULL);\n-  ffedata_list_ = list;\n-  ffedata_symbol_ = NULL;\n-  ffedata_reported_error_ = FALSE;\n-  ffedata_reinit_ = FALSE;\n-  ffedata_advance_ ();\n-}\n-\n-/* ffedata_end -- End of initialization sequence\n-\n-   if (ffedata_end(FALSE))\n-       // everything's ok\n-\n-   Make sure the end of the list is valid here.\t */\n-\n-bool\n-ffedata_end (bool reported_error, ffelexToken t)\n-{\n-  reported_error |= ffedata_reported_error_;\n-\n-  /* If still targets to initialize, too few initializers, so complain. */\n-\n-  if ((ffedata_symbol_ != NULL) && !reported_error)\n-    {\n-      reported_error = TRUE;\n-      ffebad_start (FFEBAD_DATA_TOOFEW);\n-      ffebad_here (0, ffelex_token_where_line (t), ffelex_token_where_column (t));\n-      ffebad_string (ffesymbol_text (ffedata_symbol_));\n-      ffebad_finish ();\n-    }\n-\n-  /* Pop off any impdo stacks (present only if ffedata_symbol_ != NULL). */\n-\n-  while (ffedata_stack_ != NULL)\n-    ffedata_pop_ ();\n-\n-  if (ffedata_list_ != NULL)\n-    {\n-      assert (reported_error);\n-      ffedata_list_ = NULL;\n-    }\n-\n-  return TRUE;\n-}\n-\n-/* ffedata_gather -- Gather previously disparate initializations into one place\n-\n-   ffestorag st;  // A typeCBLOCK or typeLOCAL aggregate.\n-   ffedata_gather(st);\n-\n-   Prior to this call, st has no init or accretion info, but (presumably\n-   at least one of) its subordinate storage areas has init or accretion\n-   info.  After this call, none of the subordinate storage areas has inits,\n-   because they've all been moved into the newly created init/accretion\n-   info for st.\t During this call, conflicting inits produce only one\n-   error message.  */\n-\n-void\n-ffedata_gather (ffestorag st)\n-{\n-  ffesymbol s;\n-  ffebld b;\n-\n-  /* Prepare info on the storage area we're putting init info into. */\n-\n-  ffetarget_aggregate_info (&ffedata_storage_bt_, &ffedata_storage_kt_,\n-\t\t\t    &ffedata_storage_units_, ffestorag_basictype (st),\n-\t\t\t    ffestorag_kindtype (st));\n-  ffedata_storage_size_ = ffestorag_size (st) / ffedata_storage_units_;\n-  assert (ffestorag_size (st) % ffedata_storage_units_ == 0);\n-\n-  /* If a CBLOCK, gather all the init info for its explicit members. */\n-\n-  if ((ffestorag_type (st) == FFESTORAG_typeCBLOCK)\n-      && (ffestorag_symbol (st) != NULL))\n-    {\n-      s = ffestorag_symbol (st);\n-      for (b = ffesymbol_commonlist (s); b != NULL; b = ffebld_trail (b))\n-\tffedata_gather_ (st,\n-\t\t\t ffesymbol_storage (ffebld_symter (ffebld_head (b))));\n-    }\n-\n-  /* For CBLOCK or LOCAL, gather all the init info for equivalenced members. */\n-\n-  ffestorag_drive (ffestorag_list_equivs (st), ffedata_gather_, st);\n-}\n-\n-/* ffedata_value -- Provide some number of initial values\n-\n-   ffebld value;\n-   ffelexToken t;  // Points to the value.\n-   if (ffedata_value(1,value,t))\n-       // Everything's ok\n-\n-   Makes sure the value is ok, then remembers it according to the list\n-   provided to ffedata_begin.  As many instances of the value may be\n-   supplied as desired, as indicated by the first argument.  */\n-\n-bool\n-ffedata_value (ffetargetIntegerDefault rpt, ffebld value, ffelexToken token)\n-{\n-  ffetargetIntegerDefault i;\n-\n-  /* Maybe ignore zero values, to speed up compiling, even though we lose\n-     checking for multiple initializations for now.  */\n-\n-  if (!ffe_is_zeros ()\n-      && (value != NULL)\n-      && (ffebld_op (value) == FFEBLD_opCONTER)\n-      && ffebld_constant_is_zero (ffebld_conter (value)))\n-    value = NULL;\n-  else if ((value != NULL)\n-\t   && (ffebld_op (value) == FFEBLD_opANY))\n-    value = NULL;\n-  else\n-    {\n-      /* Must be a constant. */\n-      assert (value != NULL);\n-      assert (ffebld_op (value) == FFEBLD_opCONTER);\n-    }\n-\n-  /* Later we can optimize certain cases by seeing that the target array can\n-     take some number of values, and provide this number to _value_. */\n-\n-  if (rpt == 1)\n-    ffedata_convert_cache_use_ = -1;\t/* Don't bother caching. */\n-  else\n-    ffedata_convert_cache_use_ = 0;\t/* Maybe use the cache. */\n-\n-  for (i = 0; i < rpt; ++i)\n-    {\n-      if ((ffedata_symbol_ != NULL)\n-\t  && !ffesymbol_is_init (ffedata_symbol_))\n-\t{\n-\t  ffesymbol_signal_change (ffedata_symbol_);\n-\t  ffesymbol_update_init (ffedata_symbol_);\n-\t  if (1 || ffe_is_90 ())\n-\t    ffesymbol_update_save (ffedata_symbol_);\n-#if FFEGLOBAL_ENABLED\n-\t  if (ffesymbol_common (ffedata_symbol_) != NULL)\n-\t    ffeglobal_init_common (ffesymbol_common (ffedata_symbol_),\n-\t\t\t\t   token);\n-#endif\n-\t  ffesymbol_signal_unreported (ffedata_symbol_);\n-\t}\n-      if (!ffedata_value_ (value, token))\n-\treturn FALSE;\n-    }\n-\n-  return TRUE;\n-}\n-\n-/* ffedata_advance_ -- Advance initialization target to next item in list\n-\n-   if (ffedata_advance_())\n-       // everything's ok\n-\n-   Sets common info to characterize the next item in the list.\tHandles\n-   IMPDO constructs accordingly.  Does not handle advances within a single\n-   item, as in the common extension \"DATA CHARTYPE/33,34,35/\", where\n-   CHARTYPE is CHARACTER*3, for example.  */\n-\n-static bool\n-ffedata_advance_ (void)\n-{\n-  ffebld next;\n-\n-  /* Come here after handling an IMPDO. */\n-\n-tail_recurse:\t\t\t/* :::::::::::::::::::: */\n-\n-  /* Assume we're not going to find a new target for now. */\n-\n-  ffedata_symbol_ = NULL;\n-\n-  /* If at the end of the list, we're done. */\n-\n-  if (ffedata_list_ == NULL)\n-    {\n-      ffetargetIntegerDefault newval;\n-\n-      if (ffedata_stack_ == NULL)\n-\treturn TRUE;\t\t/* No IMPDO in progress, we is done! */\n-\n-      /* Iterate the IMPDO. */\n-\n-      newval = ffesymbol_value (ffedata_stack_->itervar)\n-\t+ ffedata_stack_->increment;\n-\n-      /* See if we're still in the loop. */\n-\n-      if (((ffedata_stack_->increment > 0)\n-\t   ? newval > ffedata_stack_->final\n-\t   : newval < ffedata_stack_->final)\n-\t  || (((ffesymbol_value (ffedata_stack_->itervar) < 0)\n-\t       == (ffedata_stack_->increment < 0))\n-\t      && ((ffesymbol_value (ffedata_stack_->itervar) < 0)\n-\t\t  != (newval < 0))))\t/* Overflow/underflow? */\n-\t{\t\t\t/* Done with the loop. */\n-\t  ffedata_list_ = ffedata_stack_->outer_list;\t/* Restore list. */\n-\t  ffedata_pop_ ();\t/* Pop me off the impdo stack. */\n-\t}\n-      else\n-\t{\t\t\t/* Still in the loop, reset the list and\n-\t\t\t\t   update the iter var. */\n-\t  ffedata_list_ = ffedata_stack_->my_list;\t/* Reset list. */\n-\t  ffesymbol_set_value (ffedata_stack_->itervar, newval);\n-\t}\n-      goto tail_recurse;\t/* :::::::::::::::::::: */\n-    }\n-\n-  /* Move to the next item in the list. */\n-\n-  next = ffebld_head (ffedata_list_);\n-  ffedata_list_ = ffebld_trail (ffedata_list_);\n-\n-  /* Really shouldn't happen. */\n-\n-  if (next == NULL)\n-    return TRUE;\n-\n-  /* See what kind of target this is. */\n-\n-  switch (ffebld_op (next))\n-    {\n-    case FFEBLD_opSYMTER:\t/* Simple reference to scalar or array. */\n-      ffedata_symbol_ = ffebld_symter (next);\n-      ffedata_storage_ = (ffesymbol_storage (ffedata_symbol_) == NULL) ? NULL\n-\t: ffestorag_parent (ffesymbol_storage (ffedata_symbol_));\n-      if (ffedata_storage_ != NULL)\n-\t{\n-\t  ffetarget_aggregate_info (&ffedata_storage_bt_, &ffedata_storage_kt_,\n-\t\t\t\t    &ffedata_storage_units_,\n-\t\t\t\t    ffestorag_basictype (ffedata_storage_),\n-\t\t\t\t    ffestorag_kindtype (ffedata_storage_));\n-\t  ffedata_storage_size_ = ffestorag_size (ffedata_storage_)\n-\t    / ffedata_storage_units_;\n-\t  assert (ffestorag_size (ffedata_storage_) % ffedata_storage_units_ == 0);\n-\t}\n-\n-      if ((ffesymbol_init (ffedata_symbol_) != NULL)\n-\t  || (ffesymbol_accretion (ffedata_symbol_) != NULL)\n-\t  || ((ffedata_storage_ != NULL)\n-\t      && (ffestorag_init (ffedata_storage_) != NULL)))\n-\t{\n-#if 0\n-\t  ffebad_start (FFEBAD_DATA_REINIT);\n-\t  ffest_ffebad_here_current_stmt (0);\n-\t  ffebad_string (ffesymbol_text (ffedata_symbol_));\n-\t  ffebad_finish ();\n-\t  ffedata_reported_error_ = TRUE;\n-\t  return FALSE;\n-#else\n-\t  ffedata_reinit_ = TRUE;\n-\t  return TRUE;\n-#endif\n-\t}\n-      ffedata_basictype_ = ffesymbol_basictype (ffedata_symbol_);\n-      ffedata_kindtype_ = ffesymbol_kindtype (ffedata_symbol_);\n-      if (ffesymbol_rank (ffedata_symbol_) == 0)\n-\tffedata_arraysize_ = 1;\n-      else\n-\t{\n-\t  ffebld size = ffesymbol_arraysize (ffedata_symbol_);\n-\n-\t  assert (size != NULL);\n-\t  assert (ffebld_op (size) == FFEBLD_opCONTER);\n-\t  assert (ffeinfo_basictype (ffebld_info (size))\n-\t\t  == FFEINFO_basictypeINTEGER);\n-\t  assert (ffeinfo_kindtype (ffebld_info (size))\n-\t\t  == FFEINFO_kindtypeINTEGERDEFAULT);\n-\t  ffedata_arraysize_ = ffebld_constant_integerdefault (ffebld_conter\n-\t\t\t\t\t\t\t       (size));\n-\t}\n-      ffedata_expected_ = ffedata_arraysize_;\n-      ffedata_number_ = 0;\n-      ffedata_offset_ = 0;\n-      ffedata_size_ = (ffedata_basictype_ == FFEINFO_basictypeCHARACTER)\n-\t? ffesymbol_size (ffedata_symbol_) : 1;\n-      ffedata_symbolsize_ = ffedata_size_ * ffedata_arraysize_;\n-      ffedata_charexpected_ = ffedata_size_;\n-      ffedata_charnumber_ = 0;\n-      ffedata_charoffset_ = 0;\n-      break;\n-\n-    case FFEBLD_opARRAYREF:\t/* Reference to element of array. */\n-      ffedata_symbol_ = ffebld_symter (ffebld_left (next));\n-      ffedata_storage_ = (ffesymbol_storage (ffedata_symbol_) == NULL) ? NULL\n-\t: ffestorag_parent (ffesymbol_storage (ffedata_symbol_));\n-      if (ffedata_storage_ != NULL)\n-\t{\n-\t  ffetarget_aggregate_info (&ffedata_storage_bt_, &ffedata_storage_kt_,\n-\t\t\t\t    &ffedata_storage_units_,\n-\t\t\t\t    ffestorag_basictype (ffedata_storage_),\n-\t\t\t\t    ffestorag_kindtype (ffedata_storage_));\n-\t  ffedata_storage_size_ = ffestorag_size (ffedata_storage_)\n-\t    / ffedata_storage_units_;\n-\t  assert (ffestorag_size (ffedata_storage_) % ffedata_storage_units_ == 0);\n-\t}\n-\n-      if ((ffesymbol_init (ffedata_symbol_) != NULL)\n-\t  || ((ffedata_storage_ != NULL)\n-\t      && (ffestorag_init (ffedata_storage_) != NULL)))\n-\t{\n-#if 0\n-\t  ffebad_start (FFEBAD_DATA_REINIT);\n-\t  ffest_ffebad_here_current_stmt (0);\n-\t  ffebad_string (ffesymbol_text (ffedata_symbol_));\n-\t  ffebad_finish ();\n-\t  ffedata_reported_error_ = TRUE;\n-\t  return FALSE;\n-#else\n-\t  ffedata_reinit_ = TRUE;\n-\t  return TRUE;\n-#endif\n-\t}\n-      ffedata_basictype_ = ffesymbol_basictype (ffedata_symbol_);\n-      ffedata_kindtype_ = ffesymbol_kindtype (ffedata_symbol_);\n-      if (ffesymbol_rank (ffedata_symbol_) == 0)\n-\tffedata_arraysize_ = 1;\t/* Shouldn't happen in this case... */\n-      else\n-\t{\n-\t  ffebld size = ffesymbol_arraysize (ffedata_symbol_);\n-\n-\t  assert (size != NULL);\n-\t  assert (ffebld_op (size) == FFEBLD_opCONTER);\n-\t  assert (ffeinfo_basictype (ffebld_info (size))\n-\t\t  == FFEINFO_basictypeINTEGER);\n-\t  assert (ffeinfo_kindtype (ffebld_info (size))\n-\t\t  == FFEINFO_kindtypeINTEGERDEFAULT);\n-\t  ffedata_arraysize_ = ffebld_constant_integerdefault (ffebld_conter\n-\t\t\t\t\t\t\t       (size));\n-\t}\n-      ffedata_expected_ = 1;\n-      ffedata_number_ = 0;\n-      ffedata_offset_ = ffedata_eval_offset_ (ffebld_right (next),\n-\t\t\t\t\t  ffesymbol_dims (ffedata_symbol_));\n-      ffedata_size_ = (ffedata_basictype_ == FFEINFO_basictypeCHARACTER)\n-\t? ffesymbol_size (ffedata_symbol_) : 1;\n-      ffedata_symbolsize_ = ffedata_size_ * ffedata_arraysize_;\n-      ffedata_charexpected_ = ffedata_size_;\n-      ffedata_charnumber_ = 0;\n-      ffedata_charoffset_ = 0;\n-      break;\n-\n-    case FFEBLD_opSUBSTR:\t/* Substring reference to scalar or array\n-\t\t\t\t   element. */\n-      {\n-\tbool arrayref = ffebld_op (ffebld_left (next)) == FFEBLD_opARRAYREF;\n-\tffebld colon = ffebld_right (next);\n-\n-\tassert (colon != NULL);\n-\n-\tffedata_symbol_ = ffebld_symter (ffebld_left (arrayref\n-\t\t\t\t\t      ? ffebld_left (next) : next));\n-\tffedata_storage_ = (ffesymbol_storage (ffedata_symbol_) == NULL) ? NULL\n-\t  : ffestorag_parent (ffesymbol_storage (ffedata_symbol_));\n-\tif (ffedata_storage_ != NULL)\n-\t  {\n-\t    ffetarget_aggregate_info (&ffedata_storage_bt_, &ffedata_storage_kt_,\n-\t\t\t\t      &ffedata_storage_units_,\n-\t\t\t\t      ffestorag_basictype (ffedata_storage_),\n-\t\t\t\t      ffestorag_kindtype (ffedata_storage_));\n-\t    ffedata_storage_size_ = ffestorag_size (ffedata_storage_)\n-\t      / ffedata_storage_units_;\n-\t    assert (ffestorag_size (ffedata_storage_) % ffedata_storage_units_ == 0);\n-\t  }\n-\n-\tif ((ffesymbol_init (ffedata_symbol_) != NULL)\n-\t    || ((ffedata_storage_ != NULL)\n-\t\t&& (ffestorag_init (ffedata_storage_) != NULL)))\n-\t  {\n-#if 0\n-\t    ffebad_start (FFEBAD_DATA_REINIT);\n-\t    ffest_ffebad_here_current_stmt (0);\n-\t    ffebad_string (ffesymbol_text (ffedata_symbol_));\n-\t    ffebad_finish ();\n-\t    ffedata_reported_error_ = TRUE;\n-\t    return FALSE;\n-#else\n-\t    ffedata_reinit_ = TRUE;\n-\t    return TRUE;\n-#endif\n-\t  }\n-\tffedata_basictype_ = ffesymbol_basictype (ffedata_symbol_);\n-\tffedata_kindtype_ = ffesymbol_kindtype (ffedata_symbol_);\n-\tif (ffesymbol_rank (ffedata_symbol_) == 0)\n-\t  ffedata_arraysize_ = 1;\n-\telse\n-\t  {\n-\t    ffebld size = ffesymbol_arraysize (ffedata_symbol_);\n-\n-\t    assert (size != NULL);\n-\t    assert (ffebld_op (size) == FFEBLD_opCONTER);\n-\t    assert (ffeinfo_basictype (ffebld_info (size))\n-\t\t    == FFEINFO_basictypeINTEGER);\n-\t    assert (ffeinfo_kindtype (ffebld_info (size))\n-\t\t    == FFEINFO_kindtypeINTEGERDEFAULT);\n-\t    ffedata_arraysize_ = ffebld_constant_integerdefault (ffebld_conter\n-\t\t\t\t\t\t\t\t (size));\n-\t  }\n-\tffedata_expected_ = arrayref ? 1 : ffedata_arraysize_;\n-\tffedata_number_ = 0;\n-\tffedata_offset_ = arrayref ? ffedata_eval_offset_ (ffebld_right\n-\t\t(ffebld_left (next)), ffesymbol_dims (ffedata_symbol_)) : 0;\n-\tffedata_size_ = ffesymbol_size (ffedata_symbol_);\n-\tffedata_symbolsize_ = ffedata_size_ * ffedata_arraysize_;\n-\tffedata_charnumber_ = 0;\n-\tffedata_charoffset_ = ffedata_eval_substr_begin_ (ffebld_head (colon));\n-\tffedata_charexpected_ = ffedata_eval_substr_end_ (ffebld_head\n-\t\t\t\t(ffebld_trail (colon)), ffedata_charoffset_,\n-\t\t\t\t   ffedata_size_) - ffedata_charoffset_ + 1;\n-      }\n-      break;\n-\n-    case FFEBLD_opIMPDO:\t/* Implied-DO construct. */\n-      {\n-\tffebld itervar;\n-\tffebld start;\n-\tffebld end;\n-\tffebld incr;\n-\tffebld item = ffebld_right (next);\n-\n-\titervar = ffebld_head (item);\n-\titem = ffebld_trail (item);\n-\tstart = ffebld_head (item);\n-\titem = ffebld_trail (item);\n-\tend = ffebld_head (item);\n-\titem = ffebld_trail (item);\n-\tincr = ffebld_head (item);\n-\n-\tffedata_push_ ();\n-\tffedata_stack_->outer_list = ffedata_list_;\n-\tffedata_stack_->my_list = ffedata_list_ = ffebld_left (next);\n-\n-\tassert (ffeinfo_basictype (ffebld_info (itervar))\n-\t\t== FFEINFO_basictypeINTEGER);\n-\tassert (ffeinfo_kindtype (ffebld_info (itervar))\n-\t\t== FFEINFO_kindtypeINTEGERDEFAULT);\n-\tffedata_stack_->itervar = ffebld_symter (itervar);\n-\tif (ffeinfo_basictype (ffebld_info (start)) != FFEINFO_basictypeINTEGER)\n-\t  {\n-\t    ffebad_start (FFEBAD_DATA_EVAL);\n-\t    ffest_ffebad_here_current_stmt (0);\n-\t    ffebad_finish ();\n-\t    ffedata_pop_ ();\n-\t    ffedata_reported_error_ = TRUE;\n-\t    return FALSE;\n-\t  }\n-\tassert (ffeinfo_basictype (ffebld_info (start))\n-\t\t== FFEINFO_basictypeINTEGER);\n-\tassert (ffeinfo_kindtype (ffebld_info (start))\n-\t\t== FFEINFO_kindtypeINTEGERDEFAULT);\n-\tffesymbol_set_value (ffedata_stack_->itervar, ffedata_eval_integer1_ (start));\n-\tif (ffeinfo_basictype (ffebld_info (end)) != FFEINFO_basictypeINTEGER)\n-\t  {\n-\t    ffebad_start (FFEBAD_DATA_EVAL);\n-\t    ffest_ffebad_here_current_stmt (0);\n-\t    ffebad_finish ();\n-\t    ffedata_pop_ ();\n-\t    ffedata_reported_error_ = TRUE;\n-\t    return FALSE;\n-\t  }\n-\tassert (ffeinfo_basictype (ffebld_info (end))\n-\t\t== FFEINFO_basictypeINTEGER);\n-\tassert (ffeinfo_kindtype (ffebld_info (end))\n-\t\t== FFEINFO_kindtypeINTEGERDEFAULT);\n-\tffedata_stack_->final = ffedata_eval_integer1_ (end);\n-\n-\tif (incr == NULL)\n-\t  ffedata_stack_->increment = 1;\n-\telse\n-\t  {\n-\t    if (ffeinfo_basictype (ffebld_info (incr)) != FFEINFO_basictypeINTEGER)\n-\t      {\n-\t\tffebad_start (FFEBAD_DATA_EVAL);\n-\t\tffest_ffebad_here_current_stmt (0);\n-\t\tffebad_finish ();\n-\t\tffedata_pop_ ();\n-\t\tffedata_reported_error_ = TRUE;\n-\t\treturn FALSE;\n-\t      }\n-\t    assert (ffeinfo_basictype (ffebld_info (incr))\n-\t\t    == FFEINFO_basictypeINTEGER);\n-\t    assert (ffeinfo_kindtype (ffebld_info (incr))\n-\t\t    == FFEINFO_kindtypeINTEGERDEFAULT);\n-\t    ffedata_stack_->increment = ffedata_eval_integer1_ (incr);\n-\t    if (ffedata_stack_->increment == 0)\n-\t      {\n-\t\tffebad_start (FFEBAD_DATA_ZERO);\n-\t\tffest_ffebad_here_current_stmt (0);\n-\t\tffebad_string (ffesymbol_text (ffedata_stack_->itervar));\n-\t\tffebad_finish ();\n-\t\tffedata_pop_ ();\n-\t\tffedata_reported_error_ = TRUE;\n-\t\treturn FALSE;\n-\t      }\n-\t  }\n-\n-\tif ((ffedata_stack_->increment > 0)\n-\t    ? ffesymbol_value (ffedata_stack_->itervar)\n-\t    > ffedata_stack_->final\n-\t    : ffesymbol_value (ffedata_stack_->itervar)\n-\t    < ffedata_stack_->final)\n-\t  {\n-\t    ffedata_reported_error_ = TRUE;\n-\t    ffebad_start (FFEBAD_DATA_EMPTY);\n-\t    ffest_ffebad_here_current_stmt (0);\n-\t    ffebad_string (ffesymbol_text (ffedata_stack_->itervar));\n-\t    ffebad_finish ();\n-\t    ffedata_pop_ ();\n-\t    return FALSE;\n-\t  }\n-      }\n-      goto tail_recurse;\t/* :::::::::::::::::::: */\n-\n-    case FFEBLD_opANY:\n-      ffedata_reported_error_ = TRUE;\n-      return FALSE;\n-\n-    default:\n-      assert (\"bad op\" == NULL);\n-      break;\n-    }\n-\n-  return TRUE;\n-}\n-\n-/* ffedata_convert_ -- Convert source expression to given type using cache\n-\n-   ffebld source;\n-   ffelexToken source_token;\n-   ffelexToken dest_token;  // Any appropriate token for \"destination\".\n-   ffeinfoBasictype bt;\n-   ffeinfoKindtype kt;\n-   ffetargetCharactersize sz;\n-   source = ffedata_convert_(source,source_token,dest_token,bt,kt,sz);\n-\n-   Like ffeexpr_convert, but calls it only if necessary (if the converted\n-   expression doesn't already exist in the cache) and then puts the result\n-   in the cache.  */\n-\n-static ffebld\n-ffedata_convert_ (ffebld source, ffelexToken source_token,\n-\t\t  ffelexToken dest_token, ffeinfoBasictype bt,\n-\t\t  ffeinfoKindtype kt, ffeinfoRank rk,\n-\t\t  ffetargetCharacterSize sz)\n-{\n-  ffebld converted;\n-  int i;\n-  int max;\n-  ffedataConvertCache_ cache;\n-\n-  for (i = 0; i < ffedata_convert_cache_use_; ++i)\n-    if ((bt == ffedata_convert_cache_[i].basic_type)\n-\t&& (kt == ffedata_convert_cache_[i].kind_type)\n-\t&& (sz == ffedata_convert_cache_[i].size)\n-\t&& (rk == ffedata_convert_cache_[i].rank))\n-      return ffedata_convert_cache_[i].converted;\n-\n-  converted = ffeexpr_convert (source, source_token, dest_token, bt, kt, rk,\n-\t\t\t       sz, FFEEXPR_contextDATA);\n-\n-  if (ffedata_convert_cache_use_ >= ffedata_convert_cache_max_)\n-    {\n-      if (ffedata_convert_cache_max_ == 0)\n-\tmax = 4;\n-      else\n-\tmax = ffedata_convert_cache_max_ << 1;\n-\n-      if (max > ffedata_convert_cache_max_)\n-\t{\n-\t  cache = malloc_new_ks (malloc_pool_image (),\n-\t\t\t\t \"FFEDATA cache\", max * sizeof (*cache));\n-\t  if (ffedata_convert_cache_max_ != 0)\n-\t    {\n-\t      memcpy (cache, ffedata_convert_cache_,\n-\t\t      ffedata_convert_cache_max_ * sizeof (*cache));\n-\t      malloc_kill_ks (malloc_pool_image (), ffedata_convert_cache_,\n-\t\t\t      ffedata_convert_cache_max_ * sizeof (*cache));\n-\t    }\n-\t  ffedata_convert_cache_ = cache;\n-\t  ffedata_convert_cache_max_ = max;\n-\t}\n-      else\n-\treturn converted;\t/* In case int overflows! */\n-    }\n-\n-  i = ffedata_convert_cache_use_++;\n-\n-  ffedata_convert_cache_[i].converted = converted;\n-  ffedata_convert_cache_[i].basic_type = bt;\n-  ffedata_convert_cache_[i].kind_type = kt;\n-  ffedata_convert_cache_[i].size = sz;\n-  ffedata_convert_cache_[i].rank = rk;\n-\n-  return converted;\n-}\n-\n-/* ffedata_eval_integer1_ -- Evaluate expression\n-\n-   ffetargetIntegerDefault result;\n-   ffebld expr;\t // must be kindtypeINTEGER1.\n-\n-   result = ffedata_eval_integer1_(expr);\n-\n-   Evalues the expression (which yields a kindtypeINTEGER1 result) and\n-   returns the result.\t*/\n-\n-static ffetargetIntegerDefault\n-ffedata_eval_integer1_ (ffebld expr)\n-{\n-  ffetargetInteger1 result;\n-  ffebad error;\n-\n-  assert (expr != NULL);\n-\n-  switch (ffebld_op (expr))\n-    {\n-    case FFEBLD_opCONTER:\n-      return ffebld_constant_integer1 (ffebld_conter (expr));\n-\n-    case FFEBLD_opSYMTER:\n-      return ffesymbol_value (ffebld_symter (expr));\n-\n-    case FFEBLD_opUPLUS:\n-      return ffedata_eval_integer1_ (ffebld_left (expr));\n-\n-    case FFEBLD_opUMINUS:\n-      error = ffetarget_uminus_integer1 (&result,\n-\t\t\t       ffedata_eval_integer1_ (ffebld_left (expr)));\n-      break;\n-\n-    case FFEBLD_opADD:\n-      error = ffetarget_add_integer1 (&result,\n-\t\t\t\tffedata_eval_integer1_ (ffebld_left (expr)),\n-\t\t\t      ffedata_eval_integer1_ (ffebld_right (expr)));\n-      break;\n-\n-    case FFEBLD_opSUBTRACT:\n-      error = ffetarget_subtract_integer1 (&result,\n-\t\t\t\tffedata_eval_integer1_ (ffebld_left (expr)),\n-\t\t\t      ffedata_eval_integer1_ (ffebld_right (expr)));\n-      break;\n-\n-    case FFEBLD_opMULTIPLY:\n-      error = ffetarget_multiply_integer1 (&result,\n-\t\t\t\tffedata_eval_integer1_ (ffebld_left (expr)),\n-\t\t\t      ffedata_eval_integer1_ (ffebld_right (expr)));\n-      break;\n-\n-    case FFEBLD_opDIVIDE:\n-      error = ffetarget_divide_integer1 (&result,\n-\t\t\t\tffedata_eval_integer1_ (ffebld_left (expr)),\n-\t\t\t      ffedata_eval_integer1_ (ffebld_right (expr)));\n-      break;\n-\n-    case FFEBLD_opPOWER:\n-      {\n-\tffebld r = ffebld_right (expr);\n-\n-\tif ((ffeinfo_basictype (ffebld_info (r)) != FFEINFO_basictypeINTEGER)\n-\t    || (ffeinfo_kindtype (ffebld_info (r)) != FFEINFO_kindtypeINTEGERDEFAULT))\n-\t  error = FFEBAD_DATA_EVAL;\n-\telse\n-\t  error = ffetarget_power_integerdefault_integerdefault (&result,\n-\t\t\t\tffedata_eval_integer1_ (ffebld_left (expr)),\n-\t\t\t\t\t\tffedata_eval_integer1_ (r));\n-      }\n-      break;\n-\n-#if 0\t\t\t\t/* Only for character basictype. */\n-    case FFEBLD_opCONCATENATE:\n-      error =;\n-      break;\n-#endif\n-\n-    case FFEBLD_opNOT:\n-      error = ffetarget_not_integer1 (&result,\n-\t\t\t       ffedata_eval_integer1_ (ffebld_left (expr)));\n-      break;\n-\n-#if 0\t\t\t\t/* Only for logical basictype. */\n-    case FFEBLD_opLT:\n-      error =;\n-      break;\n-\n-    case FFEBLD_opLE:\n-      error =;\n-      break;\n-\n-    case FFEBLD_opEQ:\n-      error =;\n-      break;\n-\n-    case FFEBLD_opNE:\n-      error =;\n-      break;\n-\n-    case FFEBLD_opGT:\n-      error =;\n-      break;\n-\n-    case FFEBLD_opGE:\n-      error =;\n-      break;\n-#endif\n-\n-    case FFEBLD_opAND:\n-      error = ffetarget_and_integer1 (&result,\n-\t\t\t\tffedata_eval_integer1_ (ffebld_left (expr)),\n-\t\t\t      ffedata_eval_integer1_ (ffebld_right (expr)));\n-      break;\n-\n-    case FFEBLD_opOR:\n-      error = ffetarget_or_integer1 (&result,\n-\t\t\t\tffedata_eval_integer1_ (ffebld_left (expr)),\n-\t\t\t      ffedata_eval_integer1_ (ffebld_right (expr)));\n-      break;\n-\n-    case FFEBLD_opXOR:\n-      error = ffetarget_xor_integer1 (&result,\n-\t\t\t\tffedata_eval_integer1_ (ffebld_left (expr)),\n-\t\t\t      ffedata_eval_integer1_ (ffebld_right (expr)));\n-      break;\n-\n-    case FFEBLD_opEQV:\n-      error = ffetarget_eqv_integer1 (&result,\n-\t\t\t\tffedata_eval_integer1_ (ffebld_left (expr)),\n-\t\t\t      ffedata_eval_integer1_ (ffebld_right (expr)));\n-      break;\n-\n-    case FFEBLD_opNEQV:\n-      error = ffetarget_neqv_integer1 (&result,\n-\t\t\t\tffedata_eval_integer1_ (ffebld_left (expr)),\n-\t\t\t      ffedata_eval_integer1_ (ffebld_right (expr)));\n-      break;\n-\n-    case FFEBLD_opPAREN:\n-      return ffedata_eval_integer1_ (ffebld_left (expr));\n-\n-#if 0\t\t\t\t/* ~~ no idea how to do this */\n-    case FFEBLD_opPERCENT_LOC:\n-      error =;\n-      break;\n-#endif\n-\n-#if 0\t\t\t\t/* not allowed by ANSI, but perhaps as an\n-\t\t\t\t   extension someday? */\n-    case FFEBLD_opCONVERT:\n-      switch (ffeinfo_basictype (ffebld_info (ffebld_left (expr))))\n-\t{\n-\tcase FFEINFO_basictypeINTEGER:\n-\t  switch (ffeinfo_kindtype (ffebld_info (ffebld_left (expr))))\n-\t    {\n-\t    default:\n-\t      error = FFEBAD_DATA_EVAL;\n-\t      break;\n-\t    }\n-\t  break;\n-\n-\tcase FFEINFO_basictypeREAL:\n-\t  switch (ffeinfo_kindtype (ffebld_info (ffebld_left (expr))))\n-\t    {\n-\t    default:\n-\t      error = FFEBAD_DATA_EVAL;\n-\t      break;\n-\t    }\n-\t  break;\n-\t}\n-      break;\n-#endif\n-\n-#if 0\t\t\t\t/* not valid ops */\n-    case FFEBLD_opREPEAT:\n-      error =;\n-      break;\n-\n-    case FFEBLD_opBOUNDS:\n-      error =;\n-      break;\n-#endif\n-\n-#if 0\t\t\t\t/* not allowed by ANSI, but perhaps as an\n-\t\t\t\t   extension someday? */\n-    case FFEBLD_opFUNCREF:\n-      error =;\n-      break;\n-#endif\n-\n-#if 0\t\t\t\t/* not valid ops */\n-    case FFEBLD_opSUBRREF:\n-      error =;\n-      break;\n-\n-    case FFEBLD_opARRAYREF:\n-      error =;\n-      break;\n-#endif\n-\n-#if 0\t\t\t\t/* not valid for integer1 */\n-    case FFEBLD_opSUBSTR:\n-      error =;\n-      break;\n-#endif\n-\n-    default:\n-      error = FFEBAD_DATA_EVAL;\n-      break;\n-    }\n-\n-  if (error != FFEBAD)\n-    {\n-      ffebad_start (error);\n-      ffest_ffebad_here_current_stmt (0);\n-      ffebad_finish ();\n-      result = 0;\n-    }\n-\n-  return result;\n-}\n-\n-/* ffedata_eval_offset_ -- Evaluate offset info array\n-\n-   ffetargetOffset offset;  // 0...max-1.\n-   ffebld subscripts;  // an opITEM list of subscript exprs.\n-   ffebld dims;\t // an opITEM list of opBOUNDS exprs.\n-\n-   result = ffedata_eval_offset_(expr);\n-\n-   Evalues the expression (which yields a kindtypeINTEGER1 result) and\n-   returns the result.\t*/\n-\n-static ffetargetOffset\n-ffedata_eval_offset_ (ffebld subscripts, ffebld dims)\n-{\n-  ffetargetIntegerDefault offset = 0;\n-  ffetargetIntegerDefault width = 1;\n-  ffetargetIntegerDefault value;\n-  ffetargetIntegerDefault lowbound;\n-  ffetargetIntegerDefault highbound;\n-  ffetargetOffset final;\n-  ffebld subscript;\n-  ffebld dim;\n-  ffebld low;\n-  ffebld high;\n-  int rank = 0;\n-  bool ok;\n-\n-  while (subscripts != NULL)\n-    {\n-      ffeinfoKindtype sub_kind, low_kind, hi_kind;\n-      ffebld sub1, low1, hi1;\n-\n-      ++rank;\n-      assert (dims != NULL);\n-\n-      subscript = ffebld_head (subscripts);\n-      dim = ffebld_head (dims);\n-\n-      assert (ffeinfo_basictype (ffebld_info (subscript)) == FFEINFO_basictypeINTEGER);\n-      if (ffebld_op (subscript) == FFEBLD_opCONTER)\n-\t{\n-\t  /* Force to default - it's a constant expression !  */\n-\t  sub_kind = ffeinfo_kindtype (ffebld_info (subscript));\n-\t  sub1 = ffebld_new_conter_with_orig (ffebld_constant_new_integer1_val (\n-\t\t   sub_kind == FFEINFO_kindtypeINTEGER2 ? subscript->u.conter.expr->u.integer2 :\n-\t\t   sub_kind == FFEINFO_kindtypeINTEGER3 ? subscript->u.conter.expr->u.integer3 :\n-\t\t   sub_kind == FFEINFO_kindtypeINTEGER4 ? subscript->u.conter.expr->u.integer4 :\n-\t\t\tsubscript->u.conter.expr->u.integer1), NULL);\n-\t  value = ffedata_eval_integer1_ (sub1);\n-\t}\n-      else\n-\tvalue = ffedata_eval_integer1_ (subscript);\n-\n-      assert (ffebld_op (dim) == FFEBLD_opBOUNDS);\n-      low = ffebld_left (dim);\n-      high = ffebld_right (dim);\n-\n-      if (low == NULL)\n-\tlowbound = 1;\n-      else\n-\t{\n-\t  assert (ffeinfo_basictype (ffebld_info (low)) == FFEINFO_basictypeINTEGER);\n-\t  if (ffebld_op (low) == FFEBLD_opCONTER)\n-\t    {\n-\t      /* Force to default - it's a constant expression !  */\n-\t      low_kind = ffeinfo_kindtype (ffebld_info (low));\n-\t      low1 = ffebld_new_conter_with_orig (ffebld_constant_new_integer1_val (\n-\t\t\tlow_kind == FFEINFO_kindtypeINTEGER2 ? low->u.conter.expr->u.integer2 :\n-\t\t\tlow_kind == FFEINFO_kindtypeINTEGER3 ? low->u.conter.expr->u.integer3 :\n-\t\t\tlow_kind == FFEINFO_kindtypeINTEGER4 ? low->u.conter.expr->u.integer4 :\n-\t\t\t\tlow->u.conter.expr->u.integer1), NULL);\n-\t       lowbound = ffedata_eval_integer1_ (low1);\n-\t     }\n-\t   else\n-\t     lowbound = ffedata_eval_integer1_ (low);\n-\t}\n-\n-      assert (ffeinfo_basictype (ffebld_info (high)) == FFEINFO_basictypeINTEGER);\n-      if (ffebld_op (high) == FFEBLD_opCONTER)\n-\t{\n-\t  /* Force to default - it's a constant expression !  */\n-\t  hi_kind = ffeinfo_kindtype (ffebld_info (high));\n-\t  hi1 = ffebld_new_conter_with_orig (ffebld_constant_new_integer1_val (\n-\t\t   hi_kind == FFEINFO_kindtypeINTEGER2 ? high->u.conter.expr->u.integer2 :\n-\t\t   hi_kind == FFEINFO_kindtypeINTEGER3 ? high->u.conter.expr->u.integer3 :\n-\t\t   hi_kind == FFEINFO_kindtypeINTEGER4 ? high->u.conter.expr->u.integer4 :\n-\t\t\thigh->u.conter.expr->u.integer1), NULL);\n-\t  highbound = ffedata_eval_integer1_ (hi1);\n-\t}\n-      else\n-\thighbound = ffedata_eval_integer1_ (high);\n-\n-      if ((value < lowbound) || (value > highbound))\n-\t{\n-\t  char rankstr[10];\n-\n-\t  sprintf (rankstr, \"%d\", rank);\n-\t  value = lowbound;\n-\t  ffebad_start (FFEBAD_DATA_SUBSCRIPT);\n-\t  ffebad_string (ffesymbol_text (ffedata_symbol_));\n-\t  ffebad_string (rankstr);\n-\t  ffebad_finish ();\n-\t}\n-\n-      subscripts = ffebld_trail (subscripts);\n-      dims = ffebld_trail (dims);\n-\n-      offset += width * (value - lowbound);\n-      if (subscripts != NULL)\n-\twidth *= highbound - lowbound + 1;\n-    }\n-\n-  assert (dims == NULL);\n-\n-  ok = ffetarget_offset (&final, offset);\n-  assert (ok);\n-\n-  return final;\n-}\n-\n-/* ffedata_eval_substr_begin_ -- Evaluate begin-point of substr reference\n-\n-   ffetargetCharacterSize beginpoint;\n-   ffebld endval;  // head(colon).\n-\n-   beginpoint = ffedata_eval_substr_end_(endval);\n-\n-   If beginval is NULL, returns 0.  Otherwise makes sure beginval is\n-   kindtypeINTEGERDEFAULT, makes sure its value is > 0,\n-   and returns its value minus one, or issues an error message.\t */\n-\n-static ffetargetCharacterSize\n-ffedata_eval_substr_begin_ (ffebld expr)\n-{\n-  ffetargetIntegerDefault val;\n-\n-  if (expr == NULL)\n-    return 0;\n-\n-  assert (ffeinfo_basictype (ffebld_info (expr)) == FFEINFO_basictypeINTEGER);\n-  assert (ffeinfo_kindtype (ffebld_info (expr)) == FFEINFO_kindtypeINTEGERDEFAULT);\n-\n-  val = ffedata_eval_integer1_ (expr);\n-\n-  if (val < 1)\n-    {\n-      val = 1;\n-      ffebad_start (FFEBAD_DATA_RANGE);\n-      ffest_ffebad_here_current_stmt (0);\n-      ffebad_string (ffesymbol_text (ffedata_symbol_));\n-      ffebad_finish ();\n-      ffedata_reported_error_ = TRUE;\n-    }\n-\n-  return val - 1;\n-}\n-\n-/* ffedata_eval_substr_end_ -- Evaluate end-point of substr reference\n-\n-   ffetargetCharacterSize endpoint;\n-   ffebld endval;  // head(trail(colon)).\n-   ffetargetCharacterSize min;\t// beginpoint of substr reference.\n-   ffetargetCharacterSize max;\t// size of entity.\n-\n-   endpoint = ffedata_eval_substr_end_(endval,dflt);\n-\n-   If endval is NULL, returns max.  Otherwise makes sure endval is\n-   kindtypeINTEGERDEFAULT, makes sure its value is > min and <= max,\n-   and returns its value minus one, or issues an error message.\t */\n-\n-static ffetargetCharacterSize\n-ffedata_eval_substr_end_ (ffebld expr, ffetargetCharacterSize min,\n-\t\t\t  ffetargetCharacterSize max)\n-{\n-  ffetargetIntegerDefault val;\n-\n-  if (expr == NULL)\n-    return max - 1;\n-\n-  assert (ffeinfo_basictype (ffebld_info (expr)) == FFEINFO_basictypeINTEGER);\n-  assert (ffeinfo_kindtype (ffebld_info (expr)) == FFEINFO_kindtypeINTEGER1);\n-\n-  val = ffedata_eval_integer1_ (expr);\n-\n-  if ((val < (ffetargetIntegerDefault) min)\n-      || (val > (ffetargetIntegerDefault) max))\n-    {\n-      val = 1;\n-      ffebad_start (FFEBAD_DATA_RANGE);\n-      ffest_ffebad_here_current_stmt (0);\n-      ffebad_string (ffesymbol_text (ffedata_symbol_));\n-      ffebad_finish ();\n-      ffedata_reported_error_ = TRUE;\n-    }\n-\n-  return val - 1;\n-}\n-\n-/* ffedata_gather_ -- Gather initial values for sym into master sym inits\n-\n-   ffestorag mst;  // A typeCBLOCK or typeLOCAL aggregate.\n-   ffestorag st;  // A typeCOMMON or typeEQUIV member.\n-   ffedata_gather_(mst,st);\n-\n-   If st has any initialization info, transfer that info into mst and\n-   clear st's info.  */\n-\n-static void\n-ffedata_gather_ (ffestorag mst, ffestorag st)\n-{\n-  ffesymbol s;\n-  ffesymbol s_whine;\t\t/* Symbol to complain about in diagnostics. */\n-  ffebld b;\n-  ffetargetOffset offset;\n-  ffetargetOffset units_expected;\n-  ffebitCount actual;\n-  ffebldConstantArray array;\n-  ffebld accter;\n-  ffetargetCopyfunc fn;\n-  void *ptr1;\n-  void *ptr2;\n-  size_t size;\n-  ffeinfoBasictype bt;\n-  ffeinfoKindtype kt;\n-  ffeinfoBasictype ign_bt;\n-  ffeinfoKindtype ign_kt;\n-  ffetargetAlign units;\n-  ffebit bits;\n-  ffetargetOffset source_offset;\n-  bool whine = FALSE;\n-\n-  if (st == NULL)\n-    return;\t\t\t/* Nothing to do. */\n-\n-  s = ffestorag_symbol (st);\n-\n-  assert (s != NULL);\t\t/* Must have a corresponding symbol (else how\n-\t\t\t\t   inited?). */\n-  assert (ffestorag_init (st) == NULL);\t/* No init info on storage itself. */\n-  assert (ffestorag_accretion (st) == NULL);\n-\n-  if ((((b = ffesymbol_init (s)) == NULL)\n-       && ((b = ffesymbol_accretion (s)) == NULL))\n-      || (ffebld_op (b) == FFEBLD_opANY)\n-      || ((ffebld_op (b) == FFEBLD_opCONVERT)\n-\t  && (ffebld_op (ffebld_left (b)) == FFEBLD_opANY)))\n-    return;\t\t\t/* Nothing to do. */\n-\n-  /* b now holds the init/accretion expr. */\n-\n-  ffesymbol_set_init (s, NULL);\n-  ffesymbol_set_accretion (s, NULL);\n-  ffesymbol_set_accretes (s, 0);\n-\n-  s_whine = ffestorag_symbol (mst);\n-  if (s_whine == NULL)\n-    s_whine = s;\n-\n-  /* Make sure we haven't fully accreted during an array init. */\n-\n-  if (ffestorag_init (mst) != NULL)\n-    {\n-      ffebad_start (FFEBAD_DATA_MULTIPLE);\n-      ffebad_here (0, ffewhere_line_unknown (), ffewhere_column_unknown ());\n-      ffebad_string (ffesymbol_text (s_whine));\n-      ffebad_finish ();\n-      return;\n-    }\n-\n-  bt = ffeinfo_basictype (ffebld_info (b));\n-  kt = ffeinfo_kindtype (ffebld_info (b));\n-\n-  /* Calculate offset for aggregate area. */\n-\n-  ffedata_charexpected_ = (bt == FFEINFO_basictypeCHARACTER)\n-    ? ffebld_size (b) : 1;\n-  ffetarget_aggregate_info (&ign_bt, &ign_kt, &units, bt,\n-\t\t\t    kt);/* Find out unit size of source datum. */\n-  assert (units % ffedata_storage_units_ == 0);\n-  units_expected = ffedata_charexpected_ * units / ffedata_storage_units_;\n-  offset = (ffestorag_offset (st) - ffestorag_offset (mst))\n-    / ffedata_storage_units_;\n-\n-  /* Does an accretion array exist?  If not, create it. */\n-\n-  if (ffestorag_accretion (mst) == NULL)\n-    {\n-#if FFEDATA_sizeTOO_BIG_INIT_ != 0\n-      if (ffedata_storage_size_ >= FFEDATA_sizeTOO_BIG_INIT_)\n-\t{\n-\t  char bignum[40];\n-\n-\t  sprintf (&bignum[0], \"%ld\", (long) ffedata_storage_size_);\n-\t  ffebad_start (FFEBAD_TOO_BIG_INIT);\n-\t  ffebad_here (0, ffesymbol_where_line (s_whine),\n-\t\t       ffesymbol_where_column (s_whine));\n-\t  ffebad_string (ffesymbol_text (s_whine));\n-\t  ffebad_string (bignum);\n-\t  ffebad_finish ();\n-\t}\n-#endif\n-      array = ffebld_constantarray_new (ffedata_storage_bt_,\n-\t\t\t\tffedata_storage_kt_, ffedata_storage_size_);\n-      accter = ffebld_new_accter (array, ffebit_new (ffe_pool_program_unit (),\n-\t\t\t\t\t\t     ffedata_storage_size_));\n-      ffebld_set_info (accter, ffeinfo_new\n-\t\t       (ffedata_storage_bt_,\n-\t\t\tffedata_storage_kt_,\n-\t\t\t1,\n-\t\t\tFFEINFO_kindENTITY,\n-\t\t\tFFEINFO_whereCONSTANT,\n-\t\t\t(ffedata_basictype_ == FFEINFO_basictypeCHARACTER)\n-\t\t\t? 1 : FFETARGET_charactersizeNONE));\n-      ffestorag_set_accretion (mst, accter);\n-      ffestorag_set_accretes (mst, ffedata_storage_size_);\n-    }\n-  else\n-    {\n-      accter = ffestorag_accretion (mst);\n-      assert (ffedata_storage_size_ == (ffetargetOffset) ffebld_accter_size (accter));\n-      array = ffebld_accter (accter);\n-    }\n-\n-  /* Put value in accretion array at desired offset. */\n-\n-  fn = ffetarget_aggregate_ptr_memcpy (ffedata_storage_bt_, ffedata_storage_kt_,\n-\t\t\t\t       bt, kt);\n-\n-  switch (ffebld_op (b))\n-    {\n-    case FFEBLD_opCONTER:\n-      ffebld_constantarray_prepare (&ptr1, &ptr2, &size, array, ffedata_storage_bt_,\n-\t\t\t\t    ffedata_storage_kt_, offset,\n-\t\t\t   ffebld_constant_ptr_to_union (ffebld_conter (b)),\n-\t\t\t\t    bt, kt);\n-      (*fn) (ptr1, ptr2, size);\t/* Does the appropriate memcpy-like\n-\t\t\t\t   operation. */\n-      ffebit_count (ffebld_accter_bits (accter),\n-\t\t    offset, FALSE, units_expected, &actual);\t/* How many FALSE? */\n-      if (units_expected != (ffetargetOffset) actual)\n-\t{\n-\t  ffebad_start (FFEBAD_DATA_MULTIPLE);\n-\t  ffebad_here (0, ffewhere_line_unknown (), ffewhere_column_unknown ());\n-\t  ffebad_string (ffesymbol_text (s));\n-\t  ffebad_finish ();\n-\t}\n-      ffestorag_set_accretes (mst,\n-\t\t\t      ffestorag_accretes (mst)\n-\t\t\t      - actual);\t/* Decrement # of values\n-\t\t\t\t\t\t   actually accreted. */\n-      ffebit_set (ffebld_accter_bits (accter), offset, 1, units_expected);\n-\n-      /* If done accreting for this storage area, establish as initialized. */\n-\n-      if (ffestorag_accretes (mst) == 0)\n-\t{\n-\t  ffestorag_set_init (mst, accter);\n-\t  ffestorag_set_accretion (mst, NULL);\n-\t  ffebit_kill (ffebld_accter_bits (ffestorag_init (mst)));\n-\t  ffebld_set_op (ffestorag_init (mst), FFEBLD_opARRTER);\n-\t  ffebld_set_arrter (ffestorag_init (mst),\n-\t\t\t     ffebld_accter (ffestorag_init (mst)));\n-\t  ffebld_arrter_set_size (ffestorag_init (mst),\n-\t\t\t\t  ffedata_storage_size_);\n-\t  ffebld_arrter_set_pad (ffestorag_init (mst), 0);\n-\t  ffecom_notify_init_storage (mst);\n-\t}\n-\n-      return;\n-\n-    case FFEBLD_opARRTER:\n-      ffebld_constantarray_preparray (&ptr1, &ptr2, &size, array, ffedata_storage_bt_,\n-\t\t\t     ffedata_storage_kt_, offset, ffebld_arrter (b),\n-\t\t\t\t      bt, kt);\n-      size *= ffebld_arrter_size (b);\n-      units_expected *= ffebld_arrter_size (b);\n-      (*fn) (ptr1, ptr2, size);\t/* Does the appropriate memcpy-like\n-\t\t\t\t   operation. */\n-      ffebit_count (ffebld_accter_bits (accter),\n-\t\t    offset, FALSE, units_expected, &actual);\t/* How many FALSE? */\n-      if (units_expected != (ffetargetOffset) actual)\n-\t{\n-\t  ffebad_start (FFEBAD_DATA_MULTIPLE);\n-\t  ffebad_here (0, ffewhere_line_unknown (), ffewhere_column_unknown ());\n-\t  ffebad_string (ffesymbol_text (s));\n-\t  ffebad_finish ();\n-\t}\n-      ffestorag_set_accretes (mst,\n-\t\t\t      ffestorag_accretes (mst)\n-\t\t\t      - actual);\t/* Decrement # of values\n-\t\t\t\t\t\t   actually accreted. */\n-      ffebit_set (ffebld_accter_bits (accter), offset, 1, units_expected);\n-\n-      /* If done accreting for this storage area, establish as initialized. */\n-\n-      if (ffestorag_accretes (mst) == 0)\n-\t{\n-\t  ffestorag_set_init (mst, accter);\n-\t  ffestorag_set_accretion (mst, NULL);\n-\t  ffebit_kill (ffebld_accter_bits (ffestorag_init (mst)));\n-\t  ffebld_set_op (ffestorag_init (mst), FFEBLD_opARRTER);\n-\t  ffebld_set_arrter (ffestorag_init (mst),\n-\t\t\t     ffebld_accter (ffestorag_init (mst)));\n-\t  ffebld_arrter_set_size (ffestorag_init (mst),\n-\t\t\t\t  ffedata_storage_size_);\n-\t  ffebld_arrter_set_pad (ffestorag_init (mst), 0);\n-\t  ffecom_notify_init_storage (mst);\n-\t}\n-\n-      return;\n-\n-    case FFEBLD_opACCTER:\n-      ffebld_constantarray_preparray (&ptr1, &ptr2, &size, array, ffedata_storage_bt_,\n-\t\t\t     ffedata_storage_kt_, offset, ffebld_accter (b),\n-\t\t\t\t      bt, kt);\n-      bits = ffebld_accter_bits (b);\n-      source_offset = 0;\n-\n-      for (;;)\n-\t{\n-\t  ffetargetOffset unexp;\n-\t  ffetargetOffset siz;\n-\t  ffebitCount length;\n-\t  bool value;\n-\n-\t  ffebit_test (bits, source_offset, &value, &length);\n-\t  if (length == 0)\n-\t    break;\t\t/* Exit the loop early. */\n-\t  siz = size * length;\n-\t  unexp = units_expected * length;\n-\t  if (value)\n-\t    {\n-\t      (*fn) (ptr1, ptr2, siz);\t/* Does memcpy-like operation. */\n-\t      ffebit_count (ffebld_accter_bits (accter),\t/* How many FALSE? */\n-\t\t\t    offset, FALSE, unexp, &actual);\n-\t      if (!whine && (unexp != (ffetargetOffset) actual))\n-\t\t{\n-\t\t  whine = TRUE;\t/* Don't whine more than once for one gather. */\n-\t\t  ffebad_start (FFEBAD_DATA_MULTIPLE);\n-\t\t  ffebad_here (0, ffewhere_line_unknown (), ffewhere_column_unknown ());\n-\t\t  ffebad_string (ffesymbol_text (s));\n-\t\t  ffebad_finish ();\n-\t\t}\n-\t      ffestorag_set_accretes (mst,\n-\t\t\t\t      ffestorag_accretes (mst)\n-\t\t\t\t      - actual);\t/* Decrement # of values\n-\t\t\t\t\t\t\t   actually accreted. */\n-\t      ffebit_set (ffebld_accter_bits (accter), offset, 1, unexp);\n-\t    }\n-\t  source_offset += length;\n-\t  offset += unexp;\n-\t  ptr1 = ((char *) ptr1) + siz;\n-\t  ptr2 = ((char *) ptr2) + siz;\n-\t}\n-\n-      /* If done accreting for this storage area, establish as initialized. */\n-\n-      if (ffestorag_accretes (mst) == 0)\n-\t{\n-\t  ffestorag_set_init (mst, accter);\n-\t  ffestorag_set_accretion (mst, NULL);\n-\t  ffebit_kill (ffebld_accter_bits (ffestorag_init (mst)));\n-\t  ffebld_set_op (ffestorag_init (mst), FFEBLD_opARRTER);\n-\t  ffebld_set_arrter (ffestorag_init (mst),\n-\t\t\t     ffebld_accter (ffestorag_init (mst)));\n-\t  ffebld_arrter_set_size (ffestorag_init (mst),\n-\t\t\t\t  ffedata_storage_size_);\n-\t  ffebld_arrter_set_pad (ffestorag_init (mst), 0);\n-\t  ffecom_notify_init_storage (mst);\n-\t}\n-\n-      return;\n-\n-    default:\n-      assert (\"bad init op in gather_\" == NULL);\n-      return;\n-    }\n-}\n-\n-/* ffedata_pop_ -- Pop an impdo stack entry\n-\n-   ffedata_pop_();  */\n-\n-static void\n-ffedata_pop_ (void)\n-{\n-  ffedataImpdo_ victim = ffedata_stack_;\n-\n-  assert (victim != NULL);\n-\n-  ffedata_stack_ = ffedata_stack_->outer;\n-\n-  malloc_kill_ks (ffe_pool_program_unit (), victim, sizeof (*victim));\n-}\n-\n-/* ffedata_push_ -- Push an impdo stack entry\n-\n-   ffedata_push_();  */\n-\n-static void\n-ffedata_push_ (void)\n-{\n-  ffedataImpdo_ baby;\n-\n-  baby = malloc_new_ks (ffe_pool_program_unit (), \"ffedataImpdo_\", sizeof (*baby));\n-\n-  baby->outer = ffedata_stack_;\n-  ffedata_stack_ = baby;\n-}\n-\n-/* ffedata_value_ -- Provide an initial value\n-\n-   ffebld value;\n-   ffelexToken t;  // Points to the value.\n-   if (ffedata_value(value,t))\n-       // Everything's ok\n-\n-   Makes sure the value is ok, then remembers it according to the list\n-   provided to ffedata_begin.  */\n-\n-static bool\n-ffedata_value_ (ffebld value, ffelexToken token)\n-{\n-\n-  /* If already reported an error, don't do anything. */\n-\n-  if (ffedata_reported_error_)\n-    return FALSE;\n-\n-  /* If the value is an error marker, remember we've seen one and do nothing\n-     else. */\n-\n-  if ((value != NULL)\n-      && (ffebld_op (value) == FFEBLD_opANY))\n-    {\n-      ffedata_reported_error_ = TRUE;\n-      return FALSE;\n-    }\n-\n-  /* If too many values (no more targets), complain. */\n-\n-  if (ffedata_symbol_ == NULL)\n-    {\n-      ffebad_start (FFEBAD_DATA_TOOMANY);\n-      ffebad_here (0, ffelex_token_where_line (token),\n-\t\t   ffelex_token_where_column (token));\n-      ffebad_finish ();\n-      ffedata_reported_error_ = TRUE;\n-      return FALSE;\n-    }\n-\n-  /* If ffedata_advance_ wanted to register a complaint, do it now\n-     that we have the token to point at instead of just the start\n-     of the whole statement.  */\n-\n-  if (ffedata_reinit_)\n-    {\n-      ffebad_start (FFEBAD_DATA_REINIT);\n-      ffebad_here (0, ffelex_token_where_line (token),\n-\t\t   ffelex_token_where_column (token));\n-      ffebad_string (ffesymbol_text (ffedata_symbol_));\n-      ffebad_finish ();\n-      ffedata_reported_error_ = TRUE;\n-      return FALSE;\n-    }\n-\n-#if FFEGLOBAL_ENABLED\n-  if (ffesymbol_common (ffedata_symbol_) != NULL)\n-    ffeglobal_init_common (ffesymbol_common (ffedata_symbol_), token);\n-#endif\n-\n-  /* Convert value to desired type. */\n-\n-  if (value != NULL)\n-    {\n-      if (ffedata_convert_cache_use_ == -1)\n-\tvalue = ffeexpr_convert\n-\t  (value, token, NULL, ffedata_basictype_,\n-\t   ffedata_kindtype_, 0,\n-\t   (ffedata_basictype_ == FFEINFO_basictypeCHARACTER)\n-\t   ? ffedata_charexpected_ : FFETARGET_charactersizeNONE,\n-\t   FFEEXPR_contextDATA);\n-      else\t\t\t\t/* Use the cache. */\n-\tvalue = ffedata_convert_\n-\t  (value, token, NULL, ffedata_basictype_,\n-\t   ffedata_kindtype_, 0,\n-\t   (ffedata_basictype_ == FFEINFO_basictypeCHARACTER)\n-\t   ? ffedata_charexpected_ : FFETARGET_charactersizeNONE);\n-    }\n-\n-  /* If we couldn't, bug out. */\n-\n-  if ((value != NULL) && (ffebld_op (value) == FFEBLD_opANY))\n-    {\n-      ffedata_reported_error_ = TRUE;\n-      return FALSE;\n-    }\n-\n-  /* Handle the case where initializes go to a parent's storage area. */\n-\n-  if (ffedata_storage_ != NULL)\n-    {\n-      ffetargetOffset offset;\n-      ffetargetOffset units_expected;\n-      ffebitCount actual;\n-      ffebldConstantArray array;\n-      ffebld accter;\n-      ffetargetCopyfunc fn;\n-      void *ptr1;\n-      void *ptr2;\n-      size_t size;\n-      ffeinfoBasictype ign_bt;\n-      ffeinfoKindtype ign_kt;\n-      ffetargetAlign units;\n-\n-      /* Make sure we haven't fully accreted during an array init. */\n-\n-      if (ffestorag_init (ffedata_storage_) != NULL)\n-\t{\n-\t  ffebad_start (FFEBAD_DATA_MULTIPLE);\n-\t  ffebad_here (0, ffelex_token_where_line (token),\n-\t\t       ffelex_token_where_column (token));\n-\t  ffebad_string (ffesymbol_text (ffedata_symbol_));\n-\t  ffebad_finish ();\n-\t  ffedata_reported_error_ = TRUE;\n-\t  return FALSE;\n-\t}\n-\n-      /* Calculate offset. */\n-\n-      offset = ffedata_offset_ * ffedata_size_ + ffedata_charoffset_;\n-\n-      /* Is offset within range?  If not, whine, but don't do anything else. */\n-\n-      if (offset + ffedata_charexpected_ - 1 > ffedata_symbolsize_)\n-\t{\n-\t  ffebad_start (FFEBAD_DATA_RANGE);\n-\t  ffest_ffebad_here_current_stmt (0);\n-\t  ffebad_string (ffesymbol_text (ffedata_symbol_));\n-\t  ffebad_finish ();\n-\t  ffedata_reported_error_ = TRUE;\n-\t  return FALSE;\n-\t}\n-\n-      /* Now calculate offset for aggregate area. */\n-\n-      ffetarget_aggregate_info (&ign_bt, &ign_kt, &units, ffedata_basictype_,\n-\t\t\t\tffedata_kindtype_);\t/* Find out unit size of\n-\t\t\t\t\t\t\t   source datum. */\n-      assert (units % ffedata_storage_units_ == 0);\n-      units_expected = ffedata_charexpected_ * units / ffedata_storage_units_;\n-      offset *= units / ffedata_storage_units_;\n-      offset += (ffestorag_offset (ffesymbol_storage (ffedata_symbol_))\n-\t\t - ffestorag_offset (ffedata_storage_))\n-\t/ ffedata_storage_units_;\n-\n-      assert (offset + units_expected - 1 <= ffedata_storage_size_);\n-\n-      /* Does an accretion array exist?\t If not, create it. */\n-\n-      if (value != NULL)\n-\t{\n-\t  if (ffestorag_accretion (ffedata_storage_) == NULL)\n-\t    {\n-#if FFEDATA_sizeTOO_BIG_INIT_ != 0\n-\t      if (ffedata_storage_size_ >= FFEDATA_sizeTOO_BIG_INIT_)\n-\t\t{\n-\t\t  char bignum[40];\n-\n-\t\t  sprintf (&bignum[0], \"%ld\", (long) ffedata_storage_size_);\n-\t\t  ffebad_start (FFEBAD_TOO_BIG_INIT);\n-\t\t  ffebad_here (0, ffelex_token_where_line (token),\n-\t\t\t       ffelex_token_where_column (token));\n-\t\t  ffebad_string (ffesymbol_text (ffedata_symbol_));\n-\t\t  ffebad_string (bignum);\n-\t\t  ffebad_finish ();\n-\t\t}\n-#endif\n-\t      array = ffebld_constantarray_new\n-\t\t(ffedata_storage_bt_, ffedata_storage_kt_,\n-\t\t ffedata_storage_size_);\n-\t      accter = ffebld_new_accter (array,\n-\t\t\t\t\t  ffebit_new (ffe_pool_program_unit (),\n-\t\t\t\t\t\t      ffedata_storage_size_));\n-\t      ffebld_set_info (accter, ffeinfo_new\n-\t\t\t       (ffedata_storage_bt_,\n-\t\t\t\tffedata_storage_kt_,\n-\t\t\t\t1,\n-\t\t\t\tFFEINFO_kindENTITY,\n-\t\t\t\tFFEINFO_whereCONSTANT,\n-\t\t\t\t(ffedata_basictype_\n-\t\t\t\t == FFEINFO_basictypeCHARACTER)\n-\t\t\t\t? 1 : FFETARGET_charactersizeNONE));\n-\t      ffestorag_set_accretion (ffedata_storage_, accter);\n-\t      ffestorag_set_accretes (ffedata_storage_, ffedata_storage_size_);\n-\t    }\n-\t  else\n-\t    {\n-\t      accter = ffestorag_accretion (ffedata_storage_);\n-\t      assert (ffedata_storage_size_ == (ffetargetOffset) ffebld_accter_size (accter));\n-\t      array = ffebld_accter (accter);\n-\t    }\n-\n-\t  /* Put value in accretion array at desired offset. */\n-\n-\t  fn = ffetarget_aggregate_ptr_memcpy\n-\t    (ffedata_storage_bt_, ffedata_storage_kt_,\n-\t     ffedata_basictype_, ffedata_kindtype_);\n-\t  ffebld_constantarray_prepare\n-\t    (&ptr1, &ptr2, &size, array, ffedata_storage_bt_,\n-\t     ffedata_storage_kt_, offset,\n-\t     ffebld_constant_ptr_to_union (ffebld_conter (value)),\n-\t     ffedata_basictype_, ffedata_kindtype_);\n-\t  (*fn) (ptr1, ptr2, size);\t/* Does the appropriate memcpy-like\n-\t\t\t\t\t   operation. */\n-\t  ffebit_count (ffebld_accter_bits (accter),\n-\t\t\toffset, FALSE, units_expected,\n-\t\t\t&actual);\t/* How many FALSE? */\n-\t  if (units_expected != (ffetargetOffset) actual)\n-\t    {\n-\t      ffebad_start (FFEBAD_DATA_MULTIPLE);\n-\t      ffebad_here (0, ffelex_token_where_line (token),\n-\t\t\t   ffelex_token_where_column (token));\n-\t      ffebad_string (ffesymbol_text (ffedata_symbol_));\n-\t      ffebad_finish ();\n-\t    }\n-\t  ffestorag_set_accretes (ffedata_storage_,\n-\t\t\t\t  ffestorag_accretes (ffedata_storage_)\n-\t\t\t\t  - actual);\t/* Decrement # of values\n-\t\t\t\t\t\t   actually accreted. */\n-\t  ffebit_set (ffebld_accter_bits (accter), offset,\n-\t\t      1, units_expected);\n-\n-\t  /* If done accreting for this storage area, establish as\n-\t     initialized. */\n-\n-\t  if (ffestorag_accretes (ffedata_storage_) == 0)\n-\t    {\n-\t      ffestorag_set_init (ffedata_storage_, accter);\n-\t      ffestorag_set_accretion (ffedata_storage_, NULL);\n-\t      ffebit_kill (ffebld_accter_bits\n-\t\t\t   (ffestorag_init (ffedata_storage_)));\n-\t      ffebld_set_op (ffestorag_init (ffedata_storage_),\n-\t\t\t     FFEBLD_opARRTER);\n-\t      ffebld_set_arrter\n-\t\t(ffestorag_init (ffedata_storage_),\n-\t\t ffebld_accter (ffestorag_init (ffedata_storage_)));\n-\t      ffebld_arrter_set_size (ffestorag_init (ffedata_storage_),\n-\t\t\t\t      ffedata_storage_size_);\n-\t      ffebld_arrter_set_pad (ffestorag_init (ffedata_storage_),\n-\t\t\t\t     0);\n-\t      ffecom_notify_init_storage (ffedata_storage_);\n-\t    }\n-\t}\n-\n-      /* If still accreting, adjust specs accordingly and return. */\n-\n-      if (++ffedata_number_ < ffedata_expected_)\n-\t{\n-\t  ++ffedata_offset_;\n-\t  return TRUE;\n-\t}\n-\n-      return ffedata_advance_ ();\n-    }\n-\n-  /* Figure out where the value goes -- in an accretion array or directly\n-     into the final initial-value slot for the symbol. */\n-\n-  if ((ffedata_number_ != 0)\n-      || (ffedata_arraysize_ > 1)\n-      || (ffedata_charnumber_ != 0)\n-      || (ffedata_size_ > ffedata_charexpected_))\n-    {\t\t\t\t/* Accrete this value. */\n-      ffetargetOffset offset;\n-      ffebitCount actual;\n-      ffebldConstantArray array;\n-      ffebld accter = NULL;\n-\n-      /* Calculate offset. */\n-\n-      offset = ffedata_offset_ * ffedata_size_ + ffedata_charoffset_;\n-\n-      /* Is offset within range?  If not, whine, but don't do anything else. */\n-\n-      if (offset + ffedata_charexpected_ - 1 > ffedata_symbolsize_)\n-\t{\n-\t  ffebad_start (FFEBAD_DATA_RANGE);\n-\t  ffest_ffebad_here_current_stmt (0);\n-\t  ffebad_string (ffesymbol_text (ffedata_symbol_));\n-\t  ffebad_finish ();\n-\t  ffedata_reported_error_ = TRUE;\n-\t  return FALSE;\n-\t}\n-\n-      /* Does an accretion array exist?\t If not, create it. */\n-\n-      if (value != NULL)\n-\t{\n-\t  if (ffesymbol_accretion (ffedata_symbol_) == NULL)\n-\t    {\n-#if FFEDATA_sizeTOO_BIG_INIT_ != 0\n-\t      if (ffedata_symbolsize_ >= FFEDATA_sizeTOO_BIG_INIT_ )\n-\t\t{\n-\t\t  char bignum[40];\n-\n-\t\t  sprintf (&bignum[0], \"%ld\", (long) ffedata_symbolsize_);\n-\t\t  ffebad_start (FFEBAD_TOO_BIG_INIT);\n-\t\t  ffebad_here (0, ffelex_token_where_line (token),\n-\t\t\t       ffelex_token_where_column (token));\n-\t\t  ffebad_string (ffesymbol_text (ffedata_symbol_));\n-\t\t  ffebad_string (bignum);\n-\t\t  ffebad_finish ();\n-\t\t}\n-#endif\n-\t      array = ffebld_constantarray_new\n-\t\t(ffedata_basictype_, ffedata_kindtype_,\n-\t\t ffedata_symbolsize_);\n-\t      accter = ffebld_new_accter (array,\n-\t\t\t\t\t  ffebit_new (ffe_pool_program_unit (),\n-\t\t\t\t\t\t      ffedata_symbolsize_));\n-\t      ffebld_set_info (accter, ffeinfo_new\n-\t\t\t       (ffedata_basictype_,\n-\t\t\t\tffedata_kindtype_,\n-\t\t\t\t1,\n-\t\t\t\tFFEINFO_kindENTITY,\n-\t\t\t\tFFEINFO_whereCONSTANT,\n-\t\t\t\t(ffedata_basictype_\n-\t\t\t\t == FFEINFO_basictypeCHARACTER)\n-\t\t\t\t? 1 : FFETARGET_charactersizeNONE));\n-\t      ffesymbol_set_accretion (ffedata_symbol_, accter);\n-\t      ffesymbol_set_accretes (ffedata_symbol_, ffedata_symbolsize_);\n-\t    }\n-\t  else\n-\t    {\n-\t      accter = ffesymbol_accretion (ffedata_symbol_);\n-\t      assert (ffedata_symbolsize_\n-\t\t      == (ffetargetOffset) ffebld_accter_size (accter));\n-\t      array = ffebld_accter (accter);\n-\t    }\n-\n-\t  /* Put value in accretion array at desired offset. */\n-\n-\t  ffebld_constantarray_put\n-\t    (array, ffedata_basictype_, ffedata_kindtype_,\n-\t     offset, ffebld_constant_union (ffebld_conter (value)));\n-\t  ffebit_count (ffebld_accter_bits (accter), offset, FALSE,\n-\t\t\tffedata_charexpected_,\n-\t\t\t&actual);\t/* How many FALSE? */\n-\t  if (actual != (unsigned long int) ffedata_charexpected_)\n-\t    {\n-\t      ffebad_start (FFEBAD_DATA_MULTIPLE);\n-\t      ffebad_here (0, ffelex_token_where_line (token),\n-\t\t\t   ffelex_token_where_column (token));\n-\t      ffebad_string (ffesymbol_text (ffedata_symbol_));\n-\t      ffebad_finish ();\n-\t    }\n-\t  ffesymbol_set_accretes (ffedata_symbol_,\n-\t\t\t\t  ffesymbol_accretes (ffedata_symbol_)\n-\t\t\t\t  - actual);\t/* Decrement # of values\n-\t\t\t\t\t\t   actually accreted. */\n-\t  ffebit_set (ffebld_accter_bits (accter), offset,\n-\t\t      1, ffedata_charexpected_);\n-\t  ffesymbol_signal_unreported (ffedata_symbol_);\n-\t}\n-\n-      /* If still accreting, adjust specs accordingly and return. */\n-\n-      if (++ffedata_number_ < ffedata_expected_)\n-\t{\n-\t  ++ffedata_offset_;\n-\t  return TRUE;\n-\t}\n-\n-      /* Else, if done accreting for this symbol, establish as initialized. */\n-\n-      if ((value != NULL)\n-\t  && (ffesymbol_accretes (ffedata_symbol_) == 0))\n-\t{\n-\t  ffesymbol_set_init (ffedata_symbol_, accter);\n-\t  ffesymbol_set_accretion (ffedata_symbol_, NULL);\n-\t  ffebit_kill (ffebld_accter_bits (ffesymbol_init (ffedata_symbol_)));\n-\t  ffebld_set_op (ffesymbol_init (ffedata_symbol_), FFEBLD_opARRTER);\n-\t  ffebld_set_arrter (ffesymbol_init (ffedata_symbol_),\n-\t\t\t  ffebld_accter (ffesymbol_init (ffedata_symbol_)));\n-\t  ffebld_arrter_set_size (ffesymbol_init (ffedata_symbol_),\n-\t\t\t\t  ffedata_symbolsize_);\n-\t  ffebld_arrter_set_pad (ffestorag_init (ffedata_symbol_), 0);\n-\t  ffecom_notify_init_symbol (ffedata_symbol_);\n-\t}\n-    }\n-  else if (value != NULL)\n-    {\n-      /* Simple, direct, one-shot assignment. */\n-      ffesymbol_set_init (ffedata_symbol_, value);\n-      ffecom_notify_init_symbol (ffedata_symbol_);\n-    }\n-\n-  /* Call on advance function to get next target in list. */\n-\n-  return ffedata_advance_ ();\n-}"}, {"sha": "a99369d0b0407b0076d9a5178a32018dfaa17294", "filename": "gcc/f/data.h", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fdata.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fdata.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fdata.h?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,74 +0,0 @@\n-/* data.h -- Public #include File (module.h template V1.0)\n-   Copyright (C) 1995 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Owning Modules:\n-      data.c\n-\n-   Modifications:\n-*/\n-\n-/* Allow multiple inclusion to work. */\n-\n-#ifndef GCC_F_DATA_H\n-#define GCC_F_DATA_H\n-\n-/* Simple definitions and enumerations. */\n-\n-\n-/* Typedefs. */\n-\n-\n-/* Include files needed by this one. */\n-\n-#include \"bld.h\"\n-#include \"lex.h\"\n-#include \"storag.h\"\n-\n-/* Structure definitions. */\n-\n-\n-/* Global objects accessed by users of this module. */\n-\n-\n-/* Declare functions with prototypes. */\n-\n-void ffedata_begin (ffebld list);\n-bool ffedata_end (bool report_errors, ffelexToken t);\n-void ffedata_gather (ffestorag st);\n-bool ffedata_value (ffetargetIntegerDefault rpt, ffebld value,\n-\t\t    ffelexToken value_token);\n-\n-/* Define macros. */\n-\n-#define ffedata_init_0()\n-#define ffedata_init_1()\n-#define ffedata_init_2()\n-#define ffedata_init_3()\n-#define ffedata_init_4()\n-#define ffedata_terminate_0()\n-#define ffedata_terminate_1()\n-#define ffedata_terminate_2()\n-#define ffedata_terminate_3()\n-#define ffedata_terminate_4()\n-\n-/* End of #include file. */\n-\n-#endif /* ! GCC_F_DATA_H */"}, {"sha": "bd7ac6d4d24fdb64a8a14bcd351fabf8bacbbddb", "filename": "gcc/f/equiv.c", "status": "removed", "additions": 0, "deletions": 1484, "changes": 1484, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fequiv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fequiv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fequiv.c?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,1484 +0,0 @@\n-/* equiv.c -- Implementation File (module.c template V1.0)\n-   Copyright (C) 1995, 1996, 1997, 1998, 2003\n-   Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Related Modules:\n-      None\n-\n-   Description:\n-      Handles the EQUIVALENCE relationships in a program unit.\n-\n-   Modifications:\n-*/\n-\n-#define FFEEQUIV_DEBUG 0\n-\n-/* Include files. */\n-\n-#include \"proj.h\"\n-#include \"equiv.h\"\n-#include \"bad.h\"\n-#include \"bld.h\"\n-#include \"com.h\"\n-#include \"data.h\"\n-#include \"global.h\"\n-#include \"lex.h\"\n-#include \"malloc.h\"\n-#include \"symbol.h\"\n-\n-/* Externals defined here. */\n-\n-\n-/* Simple definitions and enumerations. */\n-\n-\n-/* Internal typedefs. */\n-\n-\n-/* Private include files. */\n-\n-\n-/* Internal structure definitions. */\n-\n-struct _ffeequiv_list_\n-  {\n-    ffeequiv first;\n-    ffeequiv last;\n-  };\n-\n-/* Static objects accessed by functions in this module. */\n-\n-static struct _ffeequiv_list_ ffeequiv_list_;\n-\n-/* Static functions (internal). */\n-\n-static void ffeequiv_destroy_ (ffeequiv eq);\n-static void ffeequiv_layout_local_ (ffeequiv eq);\n-static bool ffeequiv_offset_ (ffetargetOffset *offset, ffesymbol s,\n-\t\t\t      ffebld expr, bool subtract,\n-\t\t\t      ffetargetOffset adjust, bool no_precede);\n-\n-/* Internal macros. */\n-\f\n-\n-static void\n-ffeequiv_destroy_ (ffeequiv victim)\n-{\n-  ffebld list;\n-  ffebld item;\n-  ffebld expr;\n-\n-  for (list = victim->list; list != NULL; list = ffebld_trail (list))\n-    {\n-      for (item = ffebld_head (list); item != NULL; item = ffebld_trail (item))\n-\t{\n-\t  ffesymbol sym;\n-\n-\t  expr = ffebld_head (item);\n-\t  sym = ffeequiv_symbol (expr);\n-\t  if (sym == NULL)\n-\t    continue;\n-\t  if (ffesymbol_equiv (sym) != NULL)\n-\t    ffesymbol_set_equiv (sym, NULL);\n-\t}\n-    }\n-  ffeequiv_kill (victim);\n-}\n-\n-/* ffeequiv_layout_local_ -- Lay out storage for local equivalenced vars\n-\n-   ffeequiv eq;\n-   ffeequiv_layout_local_(eq);\n-\n-   Makes a single master ffestorag object that contains all the vars\n-   in the equivalence, and makes subordinate ffestorag objects for the\n-   vars with the correct offsets.\n-\n-   The resulting var offsets are relative not necessarily to 0 -- the\n-   are relative to the offset of the master area, which might be 0 or\n-   negative, but should never be positive.  */\n-\n-static void\n-ffeequiv_layout_local_ (ffeequiv eq)\n-{\n-  ffestorag st;\t\t\t/* Equivalence storage area. */\n-  ffebld list;\t\t\t/* List of list of equivalences. */\n-  ffebld item;\t\t\t/* List of equivalences. */\n-  ffebld root_exp;\t\t/* Expression for root sym. */\n-  ffestorag root_st;\t\t/* Storage for root. */\n-  ffesymbol root_sym;\t\t/* Root itself. */\n-  ffebld rooted_exp;\t\t/* Expression for rooted sym in an eqlist. */\n-  ffestorag rooted_st;\t\t/* Storage for rooted. */\n-  ffesymbol rooted_sym;\t\t/* Rooted symbol itself. */\n-  ffetargetOffset eqlist_offset;/* Offset for eqlist from rooted sym. */\n-  ffetargetAlign alignment;\n-  ffetargetAlign modulo;\n-  ffetargetAlign pad;\n-  ffetargetOffset size;\n-  ffetargetOffset num_elements;\n-  bool new_storage;\t\t/* Established new storage info. */\n-  bool need_storage;\t\t/* Have need for more storage info. */\n-  bool init;\n-\n-  assert (eq != NULL);\n-\n-  if (ffeequiv_common (eq) != NULL)\n-    {\t\t\t\t/* Put in common due to programmer error. */\n-      ffeequiv_destroy_ (eq);\n-      return;\n-    }\n-\n-  /* Find the symbol for the first valid item in the list of lists, use that\n-     as the root symbol.  Doesn't matter if it won't end up at the beginning\n-     of the list, though.  */\n-\n-#if FFEEQUIV_DEBUG\n-  fprintf (stderr, \"Equiv1:\\n\");\n-#endif\n-\n-  root_sym = NULL;\n-  root_exp = NULL;\n-\n-  for (list = ffeequiv_list (eq);\n-       list != NULL;\n-       list = ffebld_trail (list))\n-    {\t\t\t\t/* For every equivalence list in the list of\n-\t\t\t\t   equivs */\n-      for (item = ffebld_head (list);\n-\t   item != NULL;\n-\t   item = ffebld_trail (item))\n-\t{\t\t\t/* For every equivalence item in the list */\n-\t  ffetargetOffset ign;\t/* Ignored. */\n-\n-\t  root_exp = ffebld_head (item);\n-\t  root_sym = ffeequiv_symbol (root_exp);\n-\t  if (root_sym == NULL)\n-\t    continue;\t\t/* Ignore me. */\n-\n-\t  assert (ffesymbol_storage (root_sym) == NULL);\t/* No storage yet. */\n-\n-\t  if (!ffeequiv_offset_ (&ign, root_sym, root_exp, FALSE, 0, FALSE))\n-\t    {\n-\t      /* We can't just eliminate this one symbol from the list\n-\t\t of candidates, because it might be the only one that\n-\t\t ties all these equivs together.  So just destroy the\n-\t\t whole list.  */\n-\n-\t      ffeequiv_destroy_ (eq);\n-\t      return;\n-\t    }\n-\n-\t  break;\t/* Use first valid eqv expr for root exp/sym. */\n-\t}\n-      if (root_sym != NULL)\n-\tbreak;\n-    }\n-\n-  if (root_sym == NULL)\n-    {\n-      ffeequiv_destroy_ (eq);\n-      return;\n-    }\n-\n-\n-#if FFEEQUIV_DEBUG\n-  fprintf (stderr, \"  Root: `%s'\\n\", ffesymbol_text (root_sym));\n-#endif\n-\n-  /* We've got work to do, so make the LOCAL storage object that'll hold all\n-     the equivalenced vars inside it. */\n-\n-  st = ffestorag_new (ffestorag_list_master ());\n-  ffestorag_set_parent (st, NULL);\t/* Initializations happen here. */\n-  ffestorag_set_init (st, NULL);\n-  ffestorag_set_accretion (st, NULL);\n-  ffestorag_set_offset (st, 0);\t\t/* Assume equiv will be at root offset 0 for now. */\n-  ffestorag_set_alignment (st, 1);\n-  ffestorag_set_modulo (st, 0);\n-  ffestorag_set_type (st, FFESTORAG_typeLOCAL);\n-  ffestorag_set_basictype (st, ffesymbol_basictype (root_sym));\n-  ffestorag_set_kindtype (st, ffesymbol_kindtype (root_sym));\n-  ffestorag_set_typesymbol (st, root_sym);\n-  ffestorag_set_is_save (st, ffeequiv_is_save (eq));\n-  if (ffesymbol_is_save (root_sym))\n-    ffestorag_update_save (st);\n-  ffestorag_set_is_init (st, ffeequiv_is_init (eq));\n-  if (ffesymbol_is_init (root_sym))\n-    ffestorag_update_init (st);\n-  ffestorag_set_symbol (st, root_sym);\t/* Assume this will be the root until\n-\t\t\t\t\t   we know better (used only to generate\n-\t\t\t\t\t   the internal name for the aggregate area,\n-\t\t\t\t\t   e.g. for debugging). */\n-\n-  /* Make the EQUIV storage object for the root symbol. */\n-\n-  if (ffesymbol_rank (root_sym) == 0)\n-    num_elements = 1;\n-  else\n-    num_elements = ffebld_constant_integerdefault (ffebld_conter\n-\t\t\t\t\t\t(ffesymbol_arraysize (root_sym)));\n-  ffetarget_layout (ffesymbol_text (root_sym), &alignment, &modulo, &size,\n-\t\t    ffesymbol_basictype (root_sym), ffesymbol_kindtype (root_sym),\n-\t\t    ffesymbol_size (root_sym), num_elements);\n-  ffestorag_set_size (st, size);\t/* Set initial size of aggregate area. */\n-\n-  pad = ffetarget_align (ffestorag_ptr_to_alignment (st),\n-\t\t\t ffestorag_ptr_to_modulo (st), 0, alignment,\n-\t\t\t modulo);\n-  assert (pad == 0);\n-\n-  root_st = ffestorag_new (ffestorag_list_equivs (st));\n-  ffestorag_set_parent (root_st, st);\t/* Initializations happen there. */\n-  ffestorag_set_init (root_st, NULL);\n-  ffestorag_set_accretion (root_st, NULL);\n-  ffestorag_set_symbol (root_st, root_sym);\n-  ffestorag_set_size (root_st, size);\n-  ffestorag_set_offset (root_st, 0);\t/* Will not change; always 0 relative to itself! */\n-  ffestorag_set_alignment (root_st, alignment);\n-  ffestorag_set_modulo (root_st, modulo);\n-  ffestorag_set_type (root_st, FFESTORAG_typeEQUIV);\n-  ffestorag_set_basictype (root_st, ffesymbol_basictype (root_sym));\n-  ffestorag_set_kindtype (root_st, ffesymbol_kindtype (root_sym));\n-  ffestorag_set_typesymbol (root_st, root_sym);\n-  ffestorag_set_is_save (root_st, FALSE);\t/* Assume FALSE, then... */\n-  if (ffestorag_is_save (st))\t/* ...update to TRUE if needed. */\n-    ffestorag_update_save (root_st);\n-  ffestorag_set_is_init (root_st, FALSE);\t/* Assume FALSE, then... */\n-  if (ffestorag_is_init (st))\t/* ...update to TRUE if needed. */\n-    ffestorag_update_init (root_st);\n-  ffesymbol_set_storage (root_sym, root_st);\n-  ffesymbol_signal_unreported (root_sym);\n-  init = ffesymbol_is_init (root_sym);\n-\n-  /* Now that we know the root (offset=0) symbol, revisit all the lists and\n-     do the actual storage allocation.\tKeep doing this until we've gone\n-     through them all without making any new storage objects. */\n-\n-  do\n-    {\n-      new_storage = FALSE;\n-      need_storage = FALSE;\n-      for (list = ffeequiv_list (eq);\n-\t   list != NULL;\n-\t   list = ffebld_trail (list))\n-\t{\t\t\t/* For every equivalence list in the list of\n-\t\t\t\t   equivs */\n-\t  /* Now find a \"rooted\" symbol in this list.  That is, find the\n-\t     first item we can that is valid and whose symbol already\n-\t     has a storage area, because that means we know where it\n-\t     belongs in the equivalence area and can then allocate the\n-\t     rest of the items in the list accordingly.  */\n-\n-\t  rooted_sym = NULL;\n-\t  rooted_exp = NULL;\n-\t  eqlist_offset = 0;\n-\n-\t  for (item = ffebld_head (list);\n-\t       item != NULL;\n-\t       item = ffebld_trail (item))\n-\t    {\t\t\t/* For every equivalence item in the list */\n-\t      rooted_exp = ffebld_head (item);\n-\t      rooted_sym = ffeequiv_symbol (rooted_exp);\n-\t      if ((rooted_sym == NULL)\n-\t\t  || ((rooted_st = ffesymbol_storage (rooted_sym)) == NULL))\n-\t\t{\n-\t\t  rooted_sym = NULL;\n-\t\t  continue;\t/* Ignore me. */\n-\t\t}\n-\n-\t      need_storage = TRUE;\t/* Somebody is likely to need\n-\t\t\t\t\t   storage. */\n-\n-#if FFEEQUIV_DEBUG\n-\t      fprintf (stderr, \"  Rooted: `%s' at %\" ffetargetOffset_f \"d\\n\",\n-\t\t       ffesymbol_text (rooted_sym),\n-\t\t       ffestorag_offset (rooted_st));\n-#endif\n-\n-\t      /* The offset of this symbol from the equiv's root symbol\n-\t\t is already known, and the size of this symbol is already\n-\t\t incorporated in the size of the equiv's aggregate area.\n-\t\t What we now determine is the offset of this equivalence\n-\t\t _list_ from the equiv's root symbol.\n-\n-\t\t For example, if we know that A is at offset 16 from the\n-\t\t root symbol, given EQUIVALENCE (B(24),A(2)), we're looking\n-\t\t at A(2), meaning that the offset for this equivalence list\n-\t\t is 20 (4 bytes beyond the beginning of A, assuming typical\n-\t\t array types, dimensions, and type info).  */\n-\n-\t      if (!ffeequiv_offset_ (&eqlist_offset, rooted_sym, rooted_exp, FALSE,\n-\t\t\t\t     ffestorag_offset (rooted_st), FALSE))\n-\n-\t\t{\t/* Can't use this one. */\n-\t\t  ffesymbol_set_equiv (rooted_sym, NULL);/* Equiv area slated for\n-\t\t\t\t\t\t\t    death. */\n-\t\t  rooted_sym = NULL;\n-\t\t  continue;\t\t/* Something's wrong with eqv expr, try another. */\n-\t\t}\n-\n-#if FFEEQUIV_DEBUG\n-\t      fprintf (stderr, \"  Eqlist offset: %\" ffetargetOffset_f \"d\\n\",\n-\t\t       eqlist_offset);\n-#endif\n-\n-\t      break;\n-\t    }\n-\n-\t  /* If no rooted symbol, it means this list has no roots -- yet.\n-\t     So, forget this list this time around, but we'll get back\n-\t     to it after the outer loop iterates at least one more time,\n-\t     and, ultimately, it will have a root.  */\n-\n-\t  if (rooted_sym == NULL)\n-\t    {\n-#if FFEEQUIV_DEBUG\n-\t      fprintf (stderr, \"No roots.\\n\");\n-#endif\n-\t      continue;\n-\t    }\n-\n-\t  /* We now have a rooted symbol/expr and the offset of this equivalence\n-\t     list from the root symbol.  The other expressions in this\n-\t     list all identify an initial storage unit that must have the\n-\t     same offset. */\n-\n-\t  for (item = ffebld_head (list);\n-\t       item != NULL;\n-\t       item = ffebld_trail (item))\n-\t    {\t\t\t/* For every equivalence item in the list */\n-\t      ffebld item_exp;\t\t\t/* Expression for equivalence. */\n-\t      ffestorag item_st;\t\t/* Storage for var. */\n-\t      ffesymbol item_sym;\t\t/* Var itself. */\n-\t      ffetargetOffset item_offset;\t/* Offset for var from root. */\n-\t      ffetargetOffset new_size;\n-\n-\t      item_exp = ffebld_head (item);\n-\t      item_sym = ffeequiv_symbol (item_exp);\n-\t      if ((item_sym == NULL)\n-\t\t  || (ffesymbol_equiv (item_sym) == NULL))\n-\t\tcontinue;\t/* Ignore me. */\n-\n-\t      if (item_sym == rooted_sym)\n-\t\tcontinue;\t/* Rooted sym already set up. */\n-\n-\t      if (!ffeequiv_offset_ (&item_offset, item_sym, item_exp, TRUE,\n-\t\t\t\t     eqlist_offset, FALSE))\n-\t\t{\n-\t\t  ffesymbol_set_equiv (item_sym, NULL);\t/* Don't bother with me anymore. */\n-\t\t  continue;\n-\t\t}\n-\n-#if FFEEQUIV_DEBUG\n-\t      fprintf (stderr, \"  Item `%s' at %\" ffetargetOffset_f \"d\",\n-\t\t       ffesymbol_text (item_sym), item_offset);\n-#endif\n-\n-\t      if (ffesymbol_rank (item_sym) == 0)\n-\t\tnum_elements = 1;\n-\t      else\n-\t\tnum_elements = ffebld_constant_integerdefault (ffebld_conter\n-\t\t\t\t\t\t(ffesymbol_arraysize (item_sym)));\n-\t      ffetarget_layout (ffesymbol_text (item_sym), &alignment, &modulo,\n-\t\t\t\t&size, ffesymbol_basictype (item_sym),\n-\t\t\t\tffesymbol_kindtype (item_sym), ffesymbol_size (item_sym),\n-\t\t\t\tnum_elements);\n-\t      pad = ffetarget_align (ffestorag_ptr_to_alignment (st),\n-\t\t\t\t     ffestorag_ptr_to_modulo (st),\n-\t\t\t\t     item_offset, alignment, modulo);\n-\t      if (pad != 0)\n-\t\t{\n-\t\t  ffebad_start (FFEBAD_EQUIV_ALIGN);\n-\t\t  ffebad_string (ffesymbol_text (item_sym));\n-\t\t  ffebad_finish ();\n-\t\t  ffesymbol_set_equiv (item_sym, NULL);\t/* Don't bother with me anymore. */\n-\t\t  continue;\n-\t\t}\n-\n-\t      /* If the variable's offset is less than the offset for the\n-\t\t aggregate storage area, it means it has to expand backwards\n-\t\t -- i.e. the new known starting point of the area precedes the\n-\t\t old one.  This can't happen with COMMON areas (the standard,\n-\t\t and common sense, disallow it), but it is normal for local\n-\t\t EQUIVALENCE areas.\n-\n-\t\t Also handle choosing the \"documented\" rooted symbol for this\n-\t\t area here.  It's the symbol at the bottom (lowest offset)\n-\t\t of the aggregate area, with ties going to the name that would\n-\t\t sort to the top of the list of ties.  */\n-\n-\t      if (item_offset == ffestorag_offset (st))\n-\t\t{\n-\t\t  if ((item_sym != ffestorag_symbol (st))\n-\t\t      && (strcmp (ffesymbol_text (item_sym),\n-\t\t\t\t  ffesymbol_text (ffestorag_symbol (st)))\n-\t\t\t  < 0))\n-\t\t    ffestorag_set_symbol (st, item_sym);\n-\t\t}\n-\t      else if (item_offset < ffestorag_offset (st))\n-\t\t{\n-\t\t  /* Increase size of equiv area to start for lower offset\n-\t\t     relative to root symbol.  */\n-\t\t  if (! ffetarget_offset_add (&new_size,\n-\t\t\t\t\t      ffestorag_offset (st)\n-\t\t\t\t\t      - item_offset,\n-\t\t\t\t\t      ffestorag_size (st)))\n-\t\t    ffetarget_offset_overflow (ffesymbol_text (s));\n-\t\t  else\n-\t\t    ffestorag_set_size (st, new_size);\n-\n-\t\t  ffestorag_set_symbol (st, item_sym);\n-\t\t  ffestorag_set_offset (st, item_offset);\n-\n-#if FFEEQUIV_DEBUG\n-\t\t  fprintf (stderr, \" [eq offset=%\" ffetargetOffset_f\n-\t\t\t   \"d, size=%\" ffetargetOffset_f \"d]\",\n-\t\t\t   item_offset, new_size);\n-#endif\n-\t\t}\n-\n-\t      if ((item_st = ffesymbol_storage (item_sym)) == NULL)\n-\t\t{\t\t/* Create new ffestorag object, extend equiv\n-\t\t\t\t   area. */\n-#if FFEEQUIV_DEBUG\n-\t\t  fprintf (stderr, \".\\n\");\n-#endif\n-\t\t  new_storage = TRUE;\n-\t\t  item_st = ffestorag_new (ffestorag_list_equivs (st));\n-\t\t  ffestorag_set_parent (item_st, st);\t/* Initializations\n-\t\t\t\t\t\t\t   happen there. */\n-\t\t  ffestorag_set_init (item_st, NULL);\n-\t\t  ffestorag_set_accretion (item_st, NULL);\n-\t\t  ffestorag_set_symbol (item_st, item_sym);\n-\t\t  ffestorag_set_size (item_st, size);\n-\t\t  ffestorag_set_offset (item_st, item_offset);\n-\t\t  ffestorag_set_alignment (item_st, alignment);\n-\t\t  ffestorag_set_modulo (item_st, modulo);\n-\t\t  ffestorag_set_type (item_st, FFESTORAG_typeEQUIV);\n-\t\t  ffestorag_set_basictype (item_st, ffesymbol_basictype (item_sym));\n-\t\t  ffestorag_set_kindtype (item_st, ffesymbol_kindtype (item_sym));\n-\t\t  ffestorag_set_typesymbol (item_st, item_sym);\n-\t\t  ffestorag_set_is_save (item_st, FALSE);\t/* Assume FALSE... */\n-\t\t  if (ffestorag_is_save (st))\t/* ...update TRUE */\n-\t\t    ffestorag_update_save (item_st);\t/* if needed. */\n-\t\t  ffestorag_set_is_init (item_st, FALSE);\t/* Assume FALSE... */\n-\t\t  if (ffestorag_is_init (st))\t/* ...update TRUE */\n-\t\t    ffestorag_update_init (item_st);\t/* if needed. */\n-\t\t  ffesymbol_set_storage (item_sym, item_st);\n-\t\t  ffesymbol_signal_unreported (item_sym);\n-\t\t  if (ffesymbol_is_init (item_sym))\n-\t\t    init = TRUE;\n-\n-\t\t  /* Determine new size of equiv area, complain if overflow.  */\n-\n-\t\t  if (!ffetarget_offset_add (&size, item_offset, size)\n-\t\t      || !ffetarget_offset_add (&size, -ffestorag_offset (st), size))\n-\t\t    ffetarget_offset_overflow (ffesymbol_text (s));\n-\t\t  else if (size > ffestorag_size (st))\n-\t\t    ffestorag_set_size (st, size);\n-\t\t  ffestorag_update (st, item_sym, ffesymbol_basictype (item_sym),\n-\t\t\t\t    ffesymbol_kindtype (item_sym));\n-\t\t}\n-\t      else\n-\t\t{\n-#if FFEEQUIV_DEBUG\n-\t\t  fprintf (stderr, \" (was %\" ffetargetOffset_f \"d).\\n\",\n-\t\t\t   ffestorag_offset (item_st));\n-#endif\n-\t\t  /* Make sure offset agrees with known offset. */\n-\t\t  if (item_offset != ffestorag_offset (item_st))\n-\t\t    {\n-\t\t      char io1[40];\n-\t\t      char io2[40];\n-\n-\t\t      sprintf (&io1[0], \"%\" ffetargetOffset_f \"d\", item_offset);\n-\t\t      sprintf (&io2[0], \"%\" ffetargetOffset_f \"d\", ffestorag_offset (item_st));\n-\t\t      ffebad_start (FFEBAD_EQUIV_MISMATCH);\n-\t\t      ffebad_string (ffesymbol_text (item_sym));\n-\t\t      ffebad_string (ffesymbol_text (root_sym));\n-\t\t      ffebad_string (io1);\n-\t\t      ffebad_string (io2);\n-\t\t      ffebad_finish ();\n-\t\t    }\n-\t\t}\n-\t      ffesymbol_set_equiv (item_sym, NULL);\t/* Don't bother with me anymore. */\n-\t    }\t\t\t/* (For every equivalence item in the list) */\n-\t  ffebld_set_head (list, NULL);\t/* Don't do this list again. */\n-\t}\t\t\t/* (For every equivalence list in the list of\n-\t\t\t\t   equivs) */\n-    } while (new_storage && need_storage);\n-\n-  ffesymbol_set_equiv (root_sym, NULL);\t/* This one has storage now. */\n-\n-  ffeequiv_kill (eq);\t\t/* Fully processed, no longer needed. */\n-\n-  /* If the offset for this storage area is zero (it cannot be positive),\n-     that means the alignment/modulo info is already correct.  Otherwise,\n-     the alignment info is correct, but the modulo info reflects a\n-     zero offset, so fix it.  */\n-\n-  if (ffestorag_offset (st) < 0)\n-    {\n-      /* Calculate the initial padding necessary to preserve\n-\t the alignment/modulo requirements for the storage area.\n-\t These requirements are themselves kept track of in the\n-\t record for the storage area as a whole, but really pertain\n-\t to offset 0 of that area, which is where the root symbol\n-\t was originally placed.\n-\n-\t The goal here is to have the offset and size for the area\n-\t faithfully reflect the area itself, not extra requirements\n-\t like alignment.  So to meet the alignment requirements,\n-\t the modulo for the area should be set as if the area had an\n-\t alignment requirement of alignment/0 and was aligned/padded\n-\t downward to meet the alignment requirements of the area at\n-\t offset zero, the amount of padding needed being the desired\n-\t value for the modulo of the area.  */\n-\n-      alignment = ffestorag_alignment (st);\n-      modulo = ffestorag_modulo (st);\n-\n-      /* Since we want to move the whole area *down* (lower memory\n-\t addresses) as required by the alignment/modulo paid, negate\n-\t the offset to ffetarget_align, which assumes aligning *up*\n-\t is desired.  */\n-      pad = ffetarget_align (&alignment, &modulo,\n-\t\t\t     - ffestorag_offset (st),\n-\t\t\t     alignment, 0);\n-      ffestorag_set_modulo (st, pad);\n-    }\n-\n-  if (init)\n-    ffedata_gather (st);\t/* Gather subordinate inits into one init. */\n-}\n-\n-/* ffeequiv_offset_ -- Determine offset from start of symbol\n-\n-   ffetargetOffset offset;\n-   ffesymbol s;\t // Symbol for error reporting.\n-   ffebld expr;\t // opSUBSTR, opARRAYREF, opSYMTER, opANY.\n-   bool subtract;  // FALSE means add to adjust, TRUE means subtract from it.\n-   ffetargetOffset adjust;  // Helps keep answer in pos range (unsigned).\n-   if (!ffeequiv_offset_(&offset,s,expr,subtract,adjust))\n-       // error doing the calculation, message already printed\n-\n-   Returns the offset represented by the SUBSTR, ARRAYREF, or SUBSTR/ARRAYREF\n-   combination added-to/subtracted-from the adjustment specified.  If there\n-   is an error of some kind, returns FALSE, else returns TRUE.\tNote that\n-   only the first storage unit specified is considered; A(1:1) and A(1:2000)\n-   have the same first storage unit and so return the same offset.  */\n-\n-static bool\n-ffeequiv_offset_ (ffetargetOffset *offset, ffesymbol s UNUSED,\n-\t\t  ffebld expr, bool subtract, ffetargetOffset adjust,\n-\t\t  bool no_precede)\n-{\n-  ffetargetIntegerDefault value = 0;\n-  ffetargetOffset cval;\t\t/* Converted value. */\n-  ffesymbol sym;\n-\n-  if (expr == NULL)\n-    return FALSE;\n-\n-again:\t\t\t\t/* :::::::::::::::::::: */\n-\n-  switch (ffebld_op (expr))\n-    {\n-    case FFEBLD_opANY:\n-      return FALSE;\n-\n-    case FFEBLD_opSYMTER:\n-      {\n-\tffetargetOffset size;\t/* Size of a single unit. */\n-\tffetargetAlign a;\t/* Ignored. */\n-\tffetargetAlign m;\t/* Ignored. */\n-\n-\tsym = ffebld_symter (expr);\n-\tif (ffesymbol_basictype (sym) == FFEINFO_basictypeANY)\n-\t  return FALSE;\n-\n-\tffetarget_layout (ffesymbol_text (sym), &a, &m, &size,\n-\t\t\t  ffesymbol_basictype (sym),\n-\t\t\t  ffesymbol_kindtype (sym), 1, 1);\n-\n-\tif (value < 0)\n-\t  {\t\t\t/* Really invalid, as in A(-2:5), but in case\n-\t\t\t\t   it's wanted.... */\n-\t    if (!ffetarget_offset (&cval, -value))\n-\t      return FALSE;\n-\n-\t    if (!ffetarget_offset_multiply (&cval, cval, size))\n-\t      return FALSE;\n-\n-\t    if (subtract)\n-\t      return ffetarget_offset_add (offset, cval, adjust);\n-\n-\t    if (no_precede && (cval > adjust))\n-\t      {\n-\t      neg:\t\t/* :::::::::::::::::::: */\n-\t\tffebad_start (FFEBAD_COMMON_NEG);\n-\t\tffebad_string (ffesymbol_text (sym));\n-\t\tffebad_finish ();\n-\t\treturn FALSE;\n-\t      }\n-\t    return ffetarget_offset_add (offset, -cval, adjust);\n-\t  }\n-\n-\tif (!ffetarget_offset (&cval, value))\n-\t  return FALSE;\n-\n-\tif (!ffetarget_offset_multiply (&cval, cval, size))\n-\t  return FALSE;\n-\n-\tif (!subtract)\n-\t  return ffetarget_offset_add (offset, cval, adjust);\n-\n-\tif (no_precede && (cval > adjust))\n-\t  goto neg;\t\t/* :::::::::::::::::::: */\n-\n-\treturn ffetarget_offset_add (offset, -cval, adjust);\n-      }\n-\n-    case FFEBLD_opARRAYREF:\n-      {\n-\tffebld symexp = ffebld_left (expr);\n-\tffebld subscripts = ffebld_right (expr);\n-\tffebld dims;\n-\tffetargetIntegerDefault width;\n-\tffetargetIntegerDefault arrayval;\n-\tffetargetIntegerDefault lowbound;\n-\tffetargetIntegerDefault highbound;\n-\tffebld subscript;\n-\tffebld dim;\n-\tffebld low;\n-\tffebld high;\n-\tint rank = 0;\n-\n-\tif (ffebld_op (symexp) != FFEBLD_opSYMTER)\n-\t  return FALSE;\n-\n-\tsym = ffebld_symter (symexp);\n-\tif (ffesymbol_basictype (sym) == FFEINFO_basictypeANY)\n-\t  return FALSE;\n-\n-\tif (ffesymbol_size (sym) == FFETARGET_charactersizeNONE)\n-\t  width = 1;\n-\telse\n-\t  width = ffesymbol_size (sym);\n-\tdims = ffesymbol_dims (sym);\n-\n-\twhile (subscripts != NULL)\n-\t  {\n-\t    ++rank;\n-\t    if (dims == NULL)\n-\t      {\n-\t\tffebad_start (FFEBAD_EQUIV_MANY);\n-\t\tffebad_string (ffesymbol_text (sym));\n-\t\tffebad_finish ();\n-\t\treturn FALSE;\n-\t      }\n-\n-\t    subscript = ffebld_head (subscripts);\n-\t    dim = ffebld_head (dims);\n-\n-\t    if (ffebld_op (subscript) == FFEBLD_opANY)\n-\t      return FALSE;\n-\n-\t    assert (ffebld_op (subscript) == FFEBLD_opCONTER);\n-\t    assert (ffeinfo_basictype (ffebld_info (subscript))\n-\t\t    == FFEINFO_basictypeINTEGER);\n-\t    assert (ffeinfo_kindtype (ffebld_info (subscript))\n-\t\t    == FFEINFO_kindtypeINTEGERDEFAULT);\n-\t    arrayval = ffebld_constant_integerdefault (ffebld_conter\n-\t\t\t\t\t\t       (subscript));\n-\n-\t    if (ffebld_op (dim) == FFEBLD_opANY)\n-\t      return FALSE;\n-\n-\t    assert (ffebld_op (dim) == FFEBLD_opBOUNDS);\n-\t    low = ffebld_left (dim);\n-\t    high = ffebld_right (dim);\n-\n-\t    if (low == NULL)\n-\t      lowbound = 1;\n-\t    else\n-\t      {\n-\t\tif (ffebld_op (low) == FFEBLD_opANY)\n-\t\t  return FALSE;\n-\n-\t\tassert (ffebld_op (low) == FFEBLD_opCONTER);\n-\t\tassert (ffeinfo_basictype (ffebld_info (low))\n-\t\t\t== FFEINFO_basictypeINTEGER);\n-\t\tassert (ffeinfo_kindtype (ffebld_info (low))\n-\t\t\t== FFEINFO_kindtypeINTEGERDEFAULT);\n-\t\tlowbound\n-\t\t  = ffebld_constant_integerdefault (ffebld_conter (low));\n-\t      }\n-\n-\t    if (ffebld_op (high) == FFEBLD_opANY)\n-\t      return FALSE;\n-\n-\t    assert (ffebld_op (high) == FFEBLD_opCONTER);\n-\t    assert (ffeinfo_basictype (ffebld_info (high))\n-\t\t    == FFEINFO_basictypeINTEGER);\n-\t    assert (ffeinfo_kindtype (ffebld_info (high))\n-\t\t    == FFEINFO_kindtypeINTEGER1);\n-\t    highbound\n-\t      = ffebld_constant_integerdefault (ffebld_conter (high));\n-\n-\t    if ((arrayval < lowbound) || (arrayval > highbound))\n-\t      {\n-\t\tchar rankstr[10];\n-\n-\t\tsprintf (rankstr, \"%d\", rank);\n-\t\tffebad_start (FFEBAD_EQUIV_SUBSCRIPT);\n-\t\tffebad_string (ffesymbol_text (sym));\n-\t\tffebad_string (rankstr);\n-\t\tffebad_finish ();\n-\t      }\n-\n-\t    subscripts = ffebld_trail (subscripts);\n-\t    dims = ffebld_trail (dims);\n-\n-\t    value += width * (arrayval - lowbound);\n-\t    if (subscripts != NULL)\n-\t      width *= highbound - lowbound + 1;\n-\t  }\n-\n-\tif (dims != NULL)\n-\t  {\n-\t    ffebad_start (FFEBAD_EQUIV_FEW);\n-\t    ffebad_string (ffesymbol_text (sym));\n-\t    ffebad_finish ();\n-\t    return FALSE;\n-\t  }\n-\n-\texpr = symexp;\n-      }\n-      goto again;\t\t/* :::::::::::::::::::: */\n-\n-    case FFEBLD_opSUBSTR:\n-      {\n-\tffebld begin = ffebld_head (ffebld_right (expr));\n-\n-\texpr = ffebld_left (expr);\n-\tif (ffebld_op (expr) == FFEBLD_opANY)\n-\t  return FALSE;\n-\tif (ffebld_op (expr) == FFEBLD_opARRAYREF)\n-\t  sym = ffebld_symter (ffebld_left (expr));\n-\telse if (ffebld_op (expr) == FFEBLD_opSYMTER)\n-\t  sym = ffebld_symter (expr);\n-\telse\n-\t  sym = NULL;\n-\n-\tif ((sym != NULL)\n-\t    && (ffesymbol_basictype (sym) == FFEINFO_basictypeANY))\n-\t  return FALSE;\n-\n-\tif (begin == NULL)\n-\t  value = 0;\n-\telse\n-\t  {\n-\t    if (ffebld_op (begin) == FFEBLD_opANY)\n-\t      return FALSE;\n-\t    assert (ffebld_op (begin) == FFEBLD_opCONTER);\n-\t    assert (ffeinfo_basictype (ffebld_info (begin))\n-\t\t    == FFEINFO_basictypeINTEGER);\n-\t    assert (ffeinfo_kindtype (ffebld_info (begin))\n-\t\t    == FFEINFO_kindtypeINTEGERDEFAULT);\n-\n-\t    value = ffebld_constant_integerdefault (ffebld_conter (begin));\n-\n-\t    if ((value < 1)\n-\t\t|| ((sym != NULL)\n-\t\t    && (value > ffesymbol_size (sym))))\n-\t      {\n-\t\tffebad_start (FFEBAD_EQUIV_RANGE);\n-\t\tffebad_string (ffesymbol_text (sym));\n-\t\tffebad_finish ();\n-\t      }\n-\n-\t    --value;\n-\t  }\n-\tif ((sym != NULL)\n-\t    && (ffesymbol_basictype (sym) != FFEINFO_basictypeCHARACTER))\n-\t  {\n-\t    ffebad_start (FFEBAD_EQUIV_SUBSTR);\n-\t    ffebad_string (ffesymbol_text (sym));\n-\t    ffebad_finish ();\n-\t    value = 0;\n-\t  }\n-      }\n-      goto again;\t\t/* :::::::::::::::::::: */\n-\n-    default:\n-      assert (\"bad op\" == NULL);\n-      return FALSE;\n-    }\n-\n-}\n-\n-/* ffeequiv_add -- Add list of equivalences to list of lists for eq object\n-\n-   ffeequiv eq;\n-   ffebld list;\n-   ffelexToken t;  // points to first item in equivalence list\n-   ffeequiv_add(eq,list,t);\n-\n-   Check the list to make sure only one common symbol is involved (even\n-   if multiple times) and agrees with the common symbol for the equivalence\n-   object (or it has no common symbol until now).  Prepend (or append, it\n-   doesn't matter) the list to the list of lists for the equivalence object.\n-   Otherwise report an error and return.  */\n-\n-void\n-ffeequiv_add (ffeequiv eq, ffebld list, ffelexToken t)\n-{\n-  ffebld item;\n-  ffesymbol symbol;\n-  ffesymbol common = ffeequiv_common (eq);\n-\n-  for (item = list; item != NULL; item = ffebld_trail (item))\n-    {\n-      symbol = ffeequiv_symbol (ffebld_head (item));\n-\n-      if (ffesymbol_common (symbol) != NULL)\t/* Is symbol known in COMMON yet? */\n-\t{\n-\t  if (common == NULL)\n-\t    common = ffesymbol_common (symbol);\n-\t  else if (common != ffesymbol_common (symbol))\n-\t    {\n-\t      /* Yes, and symbol disagrees with others on the COMMON area. */\n-\t      ffebad_start (FFEBAD_EQUIV_COMMON);\n-\t      ffebad_here (0, ffelex_token_where_line (t), ffelex_token_where_column (t));\n-\t      ffebad_string (ffesymbol_text (common));\n-\t      ffebad_string (ffesymbol_text (ffesymbol_common (symbol)));\n-\t      ffebad_finish ();\n-\t      return;\n-\t    }\n-\t}\n-    }\n-\n-  if ((common != NULL)\n-      && (ffeequiv_common (eq) == NULL))\t/* Is COMMON involved already? */\n-    ffeequiv_set_common (eq, common);\t/* No, but it is now. */\n-\n-  for (item = list; item != NULL; item = ffebld_trail (item))\n-    {\n-      symbol = ffeequiv_symbol (ffebld_head (item));\n-\n-      if (ffesymbol_equiv (symbol) == NULL)\n-\tffesymbol_set_equiv (symbol, eq);\n-      else\n-\tassert (ffesymbol_equiv (symbol) == eq);\n-\n-      if (ffesymbol_common (symbol) == NULL)\t/* Is symbol in a COMMON\n-\t\t\t\t\t\t   area? */\n-\t{\t\t\t/* No (at least not yet). */\n-\t  if (ffesymbol_is_save (symbol))\n-\t    ffeequiv_update_save (eq);\t/* EQUIVALENCE has >=1 SAVEd entity. */\n-\t  if (ffesymbol_is_init (symbol))\n-\t    ffeequiv_update_init (eq);\t/* EQUIVALENCE has >=1 init'd entity. */\n-\t  continue;\t\t/* Nothing more to do here. */\n-\t}\n-\n-#if FFEGLOBAL_ENABLED\n-      if (ffesymbol_is_init (symbol))\n-\tffeglobal_init_common (ffesymbol_common (symbol), t);\n-#endif\n-\n-      if (ffesymbol_is_save (ffesymbol_common (symbol)))\n-\tffeequiv_update_save (eq);\t/* EQUIVALENCE is in a SAVEd COMMON block. */\n-      if (ffesymbol_is_init (ffesymbol_common (symbol)))\n-\tffeequiv_update_init (eq);\t/* EQUIVALENCE is in a init'd COMMON block. */\n-    }\n-\n-  ffeequiv_set_list (eq, ffebld_new_item (list, ffeequiv_list (eq)));\n-}\n-\n-/* ffeequiv_exec_transition -- Do the hard work on all the equivalence objects\n-\n-   ffeequiv_exec_transition();\t*/\n-\n-void\n-ffeequiv_exec_transition (void)\n-{\n-  while (ffeequiv_list_.first != (ffeequiv) &ffeequiv_list_.first)\n-    ffeequiv_layout_local_ (ffeequiv_list_.first);\n-}\n-\n-/* ffeequiv_init_2 -- Initialize for new program unit\n-\n-   ffeequiv_init_2();\n-\n-   Initializes the list of equivalences.  */\n-\n-void\n-ffeequiv_init_2 (void)\n-{\n-  ffeequiv_list_.first = (ffeequiv) &ffeequiv_list_.first;\n-  ffeequiv_list_.last = (ffeequiv) &ffeequiv_list_.first;\n-}\n-\n-/* ffeequiv_kill -- Kill equivalence object after removing from list\n-\n-   ffeequiv eq;\n-   ffeequiv_kill(eq);\n-\n-   Removes equivalence object from master list, then kills it.\t*/\n-\n-void\n-ffeequiv_kill (ffeequiv victim)\n-{\n-  victim->next->previous = victim->previous;\n-  victim->previous->next = victim->next;\n-  if (ffe_is_do_internal_checks ())\n-    {\n-      ffebld list;\n-      ffebld item;\n-      ffebld expr;\n-\n-      /* Assert that nobody our victim points to still points to it.  */\n-\n-      assert ((victim->common == NULL)\n-\t      || (ffesymbol_equiv (victim->common) == NULL));\n-\n-      for (list = victim->list; list != NULL; list = ffebld_trail (list))\n-\t{\n-\t  for (item = ffebld_head (list); item != NULL; item = ffebld_trail (item))\n-\t    {\n-\t      ffesymbol sym;\n-\n-\t      expr = ffebld_head (item);\n-\t      sym = ffeequiv_symbol (expr);\n-\t      if (sym == NULL)\n-\t\tcontinue;\n-\t      assert (ffesymbol_equiv (sym) != victim);\n-\t    }\n-\t}\n-    }\n-  malloc_kill_ks (ffe_pool_program_unit (), victim, sizeof (*victim));\n-}\n-\n-/* ffeequiv_layout_cblock -- Lay out storage for common area\n-\n-   ffestorag st;\n-   if (ffeequiv_layout_cblock(st))\n-       // at least one equiv'd symbol has init/accretion expr.\n-\n-   Now that the explicitly COMMONed variables in the common area (whose\n-   ffestorag object is passed) have been laid out, lay out the storage\n-   for all variables equivalenced into the area by making subordinate\n-   ffestorag objects for them.\t*/\n-\n-bool\n-ffeequiv_layout_cblock (ffestorag st)\n-{\n-  ffesymbol s = ffestorag_symbol (st);\t/* CBLOCK symbol. */\n-  ffebld list;\t\t\t/* List of explicit common vars, in order, in\n-\t\t\t\t   s. */\n-  ffebld item;\t\t\t/* List of list of equivalences in a given\n-\t\t\t\t   explicit common var. */\n-  ffebld root;\t\t\t/* Expression for (1st) explicit common var\n-\t\t\t\t   in list of eqs. */\n-  ffestorag rst;\t\t/* Storage for root. */\n-  ffetargetOffset root_offset;\t/* Offset for root into common area. */\n-  ffesymbol sr;\t\t\t/* Root itself. */\n-  ffeequiv seq;\t\t\t/* Its equivalence object, if any. */\n-  ffebld var;\t\t\t/* Expression for equivalence. */\n-  ffestorag vst;\t\t/* Storage for var. */\n-  ffetargetOffset var_offset;\t/* Offset for var into common area. */\n-  ffesymbol sv;\t\t\t/* Var itself. */\n-  ffebld altroot;\t\t/* Alternate root. */\n-  ffesymbol altrootsym;\t\t/* Alternate root symbol. */\n-  ffetargetAlign alignment;\n-  ffetargetAlign modulo;\n-  ffetargetAlign pad;\n-  ffetargetOffset size;\n-  ffetargetOffset num_elements;\n-  bool new_storage;\t\t/* Established new storage info. */\n-  bool need_storage;\t\t/* Have need for more storage info. */\n-  bool ok;\n-  bool init = FALSE;\n-\n-  assert (st != NULL);\n-  assert (ffestorag_type (st) == FFESTORAG_typeCBLOCK);\n-  assert (ffesymbol_kind (ffestorag_symbol (st)) == FFEINFO_kindCOMMON);\n-\n-  for (list = ffesymbol_commonlist (ffestorag_symbol (st));\n-       list != NULL;\n-       list = ffebld_trail (list))\n-    {\t\t\t\t/* For every variable in the common area */\n-      assert (ffebld_op (ffebld_head (list)) == FFEBLD_opSYMTER);\n-      sr = ffebld_symter (ffebld_head (list));\n-      if ((seq = ffesymbol_equiv (sr)) == NULL)\n-\tcontinue;\t\t/* No equivalences to process. */\n-      rst = ffesymbol_storage (sr);\n-      if (rst == NULL)\n-\t{\n-\t  assert (ffesymbol_kind (sr) == FFEINFO_kindANY);\n-\t  continue;\n-\t}\n-      ffesymbol_set_equiv (sr, NULL);\t/* Cancel ref to equiv obj. */\n-      do\n-\t{\n-\t  new_storage = FALSE;\n-\t  need_storage = FALSE;\n-\t  for (item = ffeequiv_list (seq);\t/* Get list of equivs. */\n-\t       item != NULL;\n-\t       item = ffebld_trail (item))\n-\t    {\t\t\t/* For every eqv list in the list of equivs\n-\t\t\t\t   for the variable */\n-\t      altroot = NULL;\n-\t      altrootsym = NULL;\n-\t      for (root = ffebld_head (item);\n-\t\t   root != NULL;\n-\t\t   root = ffebld_trail (root))\n-\t\t{\t\t/* For every equivalence item in the list */\n-\t\t  sv = ffeequiv_symbol (ffebld_head (root));\n-\t\t  if (sv == sr)\n-\t\t    break;\t/* Found first mention of \"rooted\" symbol. */\n-\t\t  if (ffesymbol_storage (sv) != NULL)\n-\t\t    {\n-\t\t      altroot = root;\t/* If no mention, use this guy\n-\t\t\t\t\t   instead. */\n-\t\t      altrootsym = sv;\n-\t\t    }\n-\t\t}\n-\t      if (root != NULL)\n-\t\t{\n-\t\t  root = ffebld_head (root);\t/* Lose its opITEM. */\n-\t\t  ok = ffeequiv_offset_ (&root_offset, sr, root, FALSE,\n-\t\t\t\t\t ffestorag_offset (rst), TRUE);\n-\t\t  /* Equiv point prior to start of common area? */\n-\t\t}\n-\t      else if (altroot != NULL)\n-\t\t{\n-\t\t  /* Equiv point prior to start of common area? */\n-\t\t  root = ffebld_head (altroot);\n-\t\t  ok = ffeequiv_offset_ (&root_offset, altrootsym, root,\n-\t\t\t\t\t FALSE,\n-\t\t\t ffestorag_offset (ffesymbol_storage (altrootsym)),\n-\t\t\t\t\t TRUE);\n-\t\t  ffesymbol_set_equiv (altrootsym, NULL);\n-\t\t}\n-\t      else\n-\t\t/* No rooted symbol in list of equivalences! */\n-\t\t{\t\t/* Assume this was due to opANY and ignore\n-\t\t\t\t   this list for now. */\n-\t\t  need_storage = TRUE;\n-\t\t  continue;\n-\t\t}\n-\n-\t      /* We now know the root symbol and the operating offset of that\n-\t\t root into the common area.  The other expressions in the\n-\t\t list all identify an initial storage unit that must have the\n-\t\t same offset. */\n-\n-\t      for (var = ffebld_head (item);\n-\t\t   var != NULL;\n-\t\t   var = ffebld_trail (var))\n-\t\t{\t\t/* For every equivalence item in the list */\n-\t\t  if (ffebld_head (var) == root)\n-\t\t    continue;\t/* Except root, of course. */\n-\t\t  sv = ffeequiv_symbol (ffebld_head (var));\n-\t\t  if (sv == NULL)\n-\t\t    continue;\t/* Except erroneous stuff (opANY). */\n-\t\t  ffesymbol_set_equiv (sv, NULL);\t/* Don't need this ref\n-\t\t\t\t\t\t\t   anymore. */\n-\t\t  if (!ok\n-\t\t      || !ffeequiv_offset_ (&var_offset, sv,\n-\t\t\t\t\t    ffebld_head (var), TRUE,\n-\t\t\t\t\t    root_offset, TRUE))\n-\t\t    continue;\t/* Can't do negative offset wrt COMMON. */\n-\n-\t\t  if (ffesymbol_rank (sv) == 0)\n-\t\t    num_elements = 1;\n-\t\t  else\n-\t\t    num_elements = ffebld_constant_integerdefault\n-\t\t      (ffebld_conter (ffesymbol_arraysize (sv)));\n-\t\t  ffetarget_layout (ffesymbol_text (sv), &alignment,\n-\t\t\t\t    &modulo, &size,\n-\t\t\t\t    ffesymbol_basictype (sv),\n-\t\t\t\t    ffesymbol_kindtype (sv),\n-\t\t\t\t    ffesymbol_size (sv), num_elements);\n-\t\t  pad = ffetarget_align (ffestorag_ptr_to_alignment (st),\n-\t\t\t\t\t ffestorag_ptr_to_modulo (st),\n-\t\t\t\t\t var_offset, alignment, modulo);\n-\t\t  if (pad != 0)\n-\t\t    {\n-\t\t      ffebad_start (FFEBAD_EQUIV_ALIGN);\n-\t\t      ffebad_string (ffesymbol_text (sv));\n-\t\t      ffebad_finish ();\n-\t\t      continue;\n-\t\t    }\n-\n-\t\t  if ((vst = ffesymbol_storage (sv)) == NULL)\n-\t\t    {\t\t/* Create new ffestorag object, extend\n-\t\t\t\t   cblock. */\n-\t\t      new_storage = TRUE;\n-\t\t      vst = ffestorag_new (ffestorag_list_equivs (st));\n-\t\t      ffestorag_set_parent (vst, st);\t/* Initializations\n-\t\t\t\t\t\t\t   happen there. */\n-\t\t      ffestorag_set_init (vst, NULL);\n-\t\t      ffestorag_set_accretion (vst, NULL);\n-\t\t      ffestorag_set_symbol (vst, sv);\n-\t\t      ffestorag_set_size (vst, size);\n-\t\t      ffestorag_set_offset (vst, var_offset);\n-\t\t      ffestorag_set_alignment (vst, alignment);\n-\t\t      ffestorag_set_modulo (vst, modulo);\n-\t\t      ffestorag_set_type (vst, FFESTORAG_typeEQUIV);\n-\t\t      ffestorag_set_basictype (vst, ffesymbol_basictype (sv));\n-\t\t      ffestorag_set_kindtype (vst, ffesymbol_kindtype (sv));\n-\t\t      ffestorag_set_typesymbol (vst, sv);\n-\t\t      ffestorag_set_is_save (vst, FALSE);\t/* Assume FALSE... */\n-\t\t      if (ffestorag_is_save (st))\t/* ...update TRUE */\n-\t\t\tffestorag_update_save (vst);\t/* if needed. */\n-\t\t      ffestorag_set_is_init (vst, FALSE);\t/* Assume FALSE... */\n-\t\t      if (ffestorag_is_init (st))\t/* ...update TRUE */\n-\t\t\tffestorag_update_init (vst);\t/* if needed. */\n-\t\t      if (!ffetarget_offset_add (&size, var_offset, size))\n-\t\t\t/* Find one size of common block, complain if\n-\t\t\t   overflow. */\n-\t\t\tffetarget_offset_overflow (ffesymbol_text (s));\n-\t\t      else if (size > ffestorag_size (st))\n-\t\t\t/* Extend common. */\n-\t\t\tffestorag_set_size (st, size);\n-\t\t      ffesymbol_set_storage (sv, vst);\n-\t\t      ffesymbol_set_common (sv, s);\n-\t\t      ffesymbol_signal_unreported (sv);\n-\t\t      ffestorag_update (st, sv, ffesymbol_basictype (sv),\n-\t\t\t\t\tffesymbol_kindtype (sv));\n-\t\t      if (ffesymbol_is_init (sv))\n-\t\t\tinit = TRUE;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      /* Make sure offset agrees with known offset. */\n-\t\t      if (var_offset != ffestorag_offset (vst))\n-\t\t\t{\n-\t\t\t  char io1[40];\n-\t\t\t  char io2[40];\n-\n-\t\t\t  sprintf (&io1[0], \"%\" ffetargetOffset_f \"d\", var_offset);\n-\t\t\t  sprintf (&io2[0], \"%\" ffetargetOffset_f \"d\", ffestorag_offset (vst));\n-\t\t\t  ffebad_start (FFEBAD_EQUIV_MISMATCH);\n-\t\t\t  ffebad_string (ffesymbol_text (sv));\n-\t\t\t  ffebad_string (ffesymbol_text (s));\n-\t\t\t  ffebad_string (io1);\n-\t\t\t  ffebad_string (io2);\n-\t\t\t  ffebad_finish ();\n-\t\t\t}\n-\t\t    }\n-\t\t}\t\t/* (For every equivalence item in the list) */\n-\t    }\t\t\t/* (For every eqv list in the list of equivs\n-\t\t\t\t   for the variable) */\n-\t}\n-      while (new_storage && need_storage);\n-\n-      ffeequiv_kill (seq);\t/* Kill equiv obj. */\n-    }\t\t\t\t/* (For every variable in the common area) */\n-\n-  return init;\n-}\n-\n-/* ffeequiv_merge -- Merge two equivalence objects, return the merged result\n-\n-   ffeequiv eq1;\n-   ffeequiv eq2;\n-   ffelexToken t;  // points to current equivalence item forcing the merge.\n-   eq1 = ffeequiv_merge(eq1,eq2,t);\n-\n-   If the two equivalence objects can be merged, they are, all the\n-   ffesymbols in their lists of lists are adjusted to point to the merged\n-   equivalence object, and the merged object is returned.\n-\n-   Otherwise, the two equivalence objects have different non-NULL common\n-   symbols, so the merge cannot take place.  An error message is issued and\n-   NULL is returned.  */\n-\n-ffeequiv\n-ffeequiv_merge (ffeequiv eq1, ffeequiv eq2, ffelexToken t)\n-{\n-  ffebld list;\n-  ffebld eqs;\n-  ffesymbol symbol;\n-  ffebld last = NULL;\n-\n-  /* If both equivalence objects point to different common-based symbols,\n-     complain.\tOf course, one or both might have NULL common symbols now,\n-     and get COMMONed later, but the COMMON statement handler checks for\n-     this. */\n-\n-  if ((ffeequiv_common (eq1) != NULL) && (ffeequiv_common (eq2) != NULL)\n-      && (ffeequiv_common (eq1) != ffeequiv_common (eq2)))\n-    {\n-      ffebad_start (FFEBAD_EQUIV_COMMON);\n-      ffebad_here (0, ffelex_token_where_line (t), ffelex_token_where_column (t));\n-      ffebad_string (ffesymbol_text (ffeequiv_common (eq1)));\n-      ffebad_string (ffesymbol_text (ffeequiv_common (eq2)));\n-      ffebad_finish ();\n-      return NULL;\n-    }\n-\n-  /* Make eq1 the new, merged object (arbitrarily). */\n-\n-  if (ffeequiv_common (eq1) == NULL)\n-    ffeequiv_set_common (eq1, ffeequiv_common (eq2));\n-\n-  /* If the victim object has any init'ed entities, so does the new object. */\n-\n-  if (eq2->is_init)\n-    eq1->is_init = TRUE;\n-\n-#if FFEGLOBAL_ENABLED\n-  if (eq1->is_init && (ffeequiv_common (eq1) != NULL))\n-    ffeglobal_init_common (ffeequiv_common (eq1), t);\n-#endif\n-\n-  /* If the victim object has any SAVEd entities, then the new object has\n-     some. */\n-\n-  if (ffeequiv_is_save (eq2))\n-    ffeequiv_update_save (eq1);\n-\n-  /* If the victim object has any init'd entities, then the new object has\n-     some. */\n-\n-  if (ffeequiv_is_init (eq2))\n-    ffeequiv_update_init (eq1);\n-\n-  /* Adjust all the symbols in the list of lists of equivalences for the\n-     victim equivalence object so they point to the new merged object\n-     instead. */\n-\n-  for (list = ffeequiv_list (eq2); list != NULL; list = ffebld_trail (list))\n-    {\n-      for (eqs = ffebld_head (list); eqs != NULL; eqs = ffebld_trail (eqs))\n-\t{\n-\t  symbol = ffeequiv_symbol (ffebld_head (eqs));\n-\t  if (ffesymbol_equiv (symbol) == eq2)\n-\t    ffesymbol_set_equiv (symbol, eq1);\n-\t  else\n-\t    assert (ffesymbol_equiv (symbol) == eq1);\t/* Can see a sym > once. */\n-\t}\n-\n-      /* For convenience, remember where the last ITEM in the outer list is. */\n-\n-      if (ffebld_trail (list) == NULL)\n-\t{\n-\t  last = list;\n-\t  break;\n-\t}\n-    }\n-\n-  /* Append the list of lists in the new, merged object to the list of lists\n-     in the victim object, then use the new combined list in the new merged\n-     object. */\n-\n-  ffebld_set_trail (last, ffeequiv_list (eq1));\n-  ffeequiv_set_list (eq1, ffeequiv_list (eq2));\n-\n-  /* Unlink and kill the victim object. */\n-\n-  ffeequiv_kill (eq2);\n-\n-  return eq1;\t\t\t/* Return the new merged object. */\n-}\n-\n-/* ffeequiv_new -- Create new equivalence object, put in list\n-\n-   ffeequiv eq;\n-   eq = ffeequiv_new();\n-\n-   Creates a new equivalence object and adds it to the list of equivalence\n-   objects.  */\n-\n-ffeequiv\n-ffeequiv_new (void)\n-{\n-  ffeequiv eq;\n-\n-  eq = malloc_new_ks (ffe_pool_program_unit (), \"ffeequiv\", sizeof (*eq));\n-  eq->next = (ffeequiv) &ffeequiv_list_.first;\n-  eq->previous = ffeequiv_list_.last;\n-  ffeequiv_set_common (eq, NULL);\t/* No COMMON area yet. */\n-  ffeequiv_set_list (eq, NULL);\t/* No list of lists of equivalences yet. */\n-  ffeequiv_set_is_save (eq, FALSE);\n-  ffeequiv_set_is_init (eq, FALSE);\n-  eq->next->previous = eq;\n-  eq->previous->next = eq;\n-\n-  return eq;\n-}\n-\n-/* ffeequiv_symbol -- Return symbol for equivalence expression\n-\n-   ffesymbol symbol;\n-   ffebld expr;\n-   symbol = ffeequiv_symbol(expr);\n-\n-   Finds the terminal SYMTER in an equivalence expression and returns the\n-   ffesymbol for it.  */\n-\n-ffesymbol\n-ffeequiv_symbol (ffebld expr)\n-{\n-  assert (expr != NULL);\n-\n-again:\t\t\t\t/* :::::::::::::::::::: */\n-\n-  switch (ffebld_op (expr))\n-    {\n-    case FFEBLD_opARRAYREF:\n-    case FFEBLD_opSUBSTR:\n-      expr = ffebld_left (expr);\n-      goto again;\t\t/* :::::::::::::::::::: */\n-\n-    case FFEBLD_opSYMTER:\n-      return ffebld_symter (expr);\n-\n-    case FFEBLD_opANY:\n-      return NULL;\n-\n-    default:\n-      assert (\"bad eq expr\" == NULL);\n-      return NULL;\n-    }\n-}\n-\n-/* ffeequiv_update_init -- Update the INIT flag for the area to TRUE\n-\n-   ffeequiv eq;\n-   ffeequiv_update_init(eq);\n-\n-   If the INIT flag for the <eq> object is already set, return.\t Else,\n-   set it TRUE and call ffe*_update_init for all objects contained in\n-   this one.  */\n-\n-void\n-ffeequiv_update_init (ffeequiv eq)\n-{\n-  ffebld list;\t\t\t/* Current list in list of lists. */\n-  ffebld item;\t\t\t/* Current item in current list. */\n-  ffebld expr;\t\t\t/* Expression in head of current item. */\n-\n-  if (eq->is_init)\n-    return;\n-\n-  eq->is_init = TRUE;\n-\n-  if ((eq->common != NULL)\n-      && !ffesymbol_is_init (eq->common))\n-    ffesymbol_update_init (eq->common);\t/* Shouldn't be needed. */\n-\n-  for (list = eq->list; list != NULL; list = ffebld_trail (list))\n-    {\n-      for (item = ffebld_head (list); item != NULL; item = ffebld_trail (item))\n-\t{\n-\t  expr = ffebld_head (item);\n-\n-\tagain:\t\t\t/* :::::::::::::::::::: */\n-\n-\t  switch (ffebld_op (expr))\n-\t    {\n-\t    case FFEBLD_opANY:\n-\t      break;\n-\n-\t    case FFEBLD_opSYMTER:\n-\t      if (!ffesymbol_is_init (ffebld_symter (expr)))\n-\t\tffesymbol_update_init (ffebld_symter (expr));\n-\t      break;\n-\n-\t    case FFEBLD_opARRAYREF:\n-\t      expr = ffebld_left (expr);\n-\t      goto again;\t/* :::::::::::::::::::: */\n-\n-\t    case FFEBLD_opSUBSTR:\n-\t      expr = ffebld_left (expr);\n-\t      goto again;\t/* :::::::::::::::::::: */\n-\n-\t    default:\n-\t      assert (\"bad op for ffeequiv_update_init\" == NULL);\n-\t      break;\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* ffeequiv_update_save -- Update the SAVE flag for the area to TRUE\n-\n-   ffeequiv eq;\n-   ffeequiv_update_save(eq);\n-\n-   If the SAVE flag for the <eq> object is already set, return.\t Else,\n-   set it TRUE and call ffe*_update_save for all objects contained in\n-   this one.  */\n-\n-void\n-ffeequiv_update_save (ffeequiv eq)\n-{\n-  ffebld list;\t\t\t/* Current list in list of lists. */\n-  ffebld item;\t\t\t/* Current item in current list. */\n-  ffebld expr;\t\t\t/* Expression in head of current item. */\n-\n-  if (eq->is_save)\n-    return;\n-\n-  eq->is_save = TRUE;\n-\n-  if ((eq->common != NULL)\n-      && !ffesymbol_is_save (eq->common))\n-    ffesymbol_update_save (eq->common);\t/* Shouldn't be needed. */\n-\n-  for (list = eq->list; list != NULL; list = ffebld_trail (list))\n-    {\n-      for (item = ffebld_head (list); item != NULL; item = ffebld_trail (item))\n-\t{\n-\t  expr = ffebld_head (item);\n-\n-\tagain:\t\t\t/* :::::::::::::::::::: */\n-\n-\t  switch (ffebld_op (expr))\n-\t    {\n-\t    case FFEBLD_opANY:\n-\t      break;\n-\n-\t    case FFEBLD_opSYMTER:\n-\t      if (!ffesymbol_is_save (ffebld_symter (expr)))\n-\t\tffesymbol_update_save (ffebld_symter (expr));\n-\t      break;\n-\n-\t    case FFEBLD_opARRAYREF:\n-\t      expr = ffebld_left (expr);\n-\t      goto again;\t/* :::::::::::::::::::: */\n-\n-\t    case FFEBLD_opSUBSTR:\n-\t      expr = ffebld_left (expr);\n-\t      goto again;\t/* :::::::::::::::::::: */\n-\n-\t    default:\n-\t      assert (\"bad op for ffeequiv_update_save\" == NULL);\n-\t      break;\n-\t    }\n-\t}\n-    }\n-}"}, {"sha": "59abfc875ca248c19a31fa8c315858ad35c2148c", "filename": "gcc/f/equiv.h", "status": "removed", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fequiv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fequiv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fequiv.h?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,100 +0,0 @@\n-/* equiv.h -- Public #include File (module.h template V1.0)\n-   Copyright (C) 1995, 1996 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Owning Modules:\n-      equiv.c\n-\n-   Modifications:\n-*/\n-\n-/* Allow multiple inclusion to work. */\n-\n-#ifndef GCC_F_EQUIV_H\n-#define GCC_F_EQUIV_H\n-\n-/* Simple definitions and enumerations. */\n-\n-\n-/* Typedefs. */\n-\n-typedef struct _ffeequiv_ *ffeequiv;\n-\n-/* Include files needed by this one. */\n-\n-#include \"bld.h\"\n-#include \"lex.h\"\n-#include \"storag.h\"\n-#include \"symbol.h\"\n-\n-/* Structure definitions. */\n-\n-struct _ffeequiv_\n-  {\n-    ffeequiv next;\n-    ffeequiv previous;\n-    ffesymbol common;\t\t/* Common area for this equiv, if any. */\n-    ffebld list;\t\t/* List of lists of equiv exprs. */\n-    bool is_save;\t\t/* Any SAVEd members? */\n-    bool is_init;\t\t/* Any initialized members? */\n-  };\n-\n-/* Global objects accessed by users of this module. */\n-\n-\n-/* Declare functions with prototypes. */\n-\n-void ffeequiv_add (ffeequiv eq, ffebld list, ffelexToken t);\n-void ffeequiv_exec_transition (void);\n-void ffeequiv_init_2 (void);\n-void ffeequiv_kill (ffeequiv victim);\n-bool ffeequiv_layout_cblock (ffestorag st);\n-ffeequiv ffeequiv_merge (ffeequiv eq1, ffeequiv eq2, ffelexToken t);\n-ffeequiv ffeequiv_new (void);\n-ffesymbol ffeequiv_symbol (ffebld expr);\n-void ffeequiv_update_init (ffeequiv eq);\n-void ffeequiv_update_save (ffeequiv eq);\n-\n-/* Define macros. */\n-\n-#define ffeequiv_common(e) ((e)->common)\n-#define ffeequiv_init_0()\n-#define ffeequiv_init_1()\n-#define ffeequiv_init_3()\n-#define ffeequiv_init_4()\n-#define ffeequiv_is_init(e) ((e)->is_init)\n-#define ffeequiv_is_save(e) ((e)->is_save)\n-#define ffeequiv_list(e) ((e)->list)\n-#define ffeequiv_next(e) ((e)->next)\n-#define ffeequiv_previous(e) ((e)->previous)\n-#define ffeequiv_set_common(e,c) ((e)->common = (c))\n-#define ffeequiv_set_init(e,i) ((e)->init = (i))\n-#define ffeequiv_set_is_init(e,in) ((e)->is_init = (in))\n-#define ffeequiv_set_is_save(e,sa) ((e)->is_save = (sa))\n-#define ffeequiv_set_list(e,l) ((e)->list = (l))\n-#define ffeequiv_terminate_0()\n-#define ffeequiv_terminate_1()\n-#define ffeequiv_terminate_2()\n-#define ffeequiv_terminate_3()\n-#define ffeequiv_terminate_4()\n-\n-/* End of #include file. */\n-\n-#endif /* ! GCC_F_EQUIV_H */"}, {"sha": "ef7661dc3ec3e95e60099e5b716b406fa3b17e3d", "filename": "gcc/f/expr.c", "status": "removed", "additions": 0, "deletions": 18571, "changes": 18571, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fexpr.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "b82173bbf0e7453e2c3659853e1952df02164894", "filename": "gcc/f/expr.h", "status": "removed", "additions": 0, "deletions": 194, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fexpr.h?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,194 +0,0 @@\n-/* expr.h -- Public #include File (module.h template V1.0)\n-   Copyright (C) 1995, 1996 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Owning Modules:\n-      expr.c\n-\n-   Modifications:\n-*/\n-\n-/* Allow multiple inclusion to work. */\n-\n-#ifndef GCC_F_EXPR_H\n-#define GCC_F_EXPR_H\n-\n-/* Simple definitions and enumerations. */\n-\n-typedef enum\n-  {\n-    FFEEXPR_contextLET,\n-    FFEEXPR_contextASSIGN,\n-    FFEEXPR_contextIOLIST,\n-    FFEEXPR_contextPARAMETER,\n-    FFEEXPR_contextSUBROUTINEREF,\n-    FFEEXPR_contextDATA,\n-    FFEEXPR_contextIF,\n-    FFEEXPR_contextARITHIF,\n-    FFEEXPR_contextDO,\n-    FFEEXPR_contextDOWHILE,\n-    FFEEXPR_contextFORMAT,\n-    FFEEXPR_contextAGOTO,\n-    FFEEXPR_contextCGOTO,\n-    FFEEXPR_contextCHARACTERSIZE,\n-    FFEEXPR_contextEQUIVALENCE,\n-    FFEEXPR_contextSTOP,\n-    FFEEXPR_contextRETURN,\n-    FFEEXPR_contextSFUNCDEF,\n-    FFEEXPR_contextINCLUDE,\n-    FFEEXPR_contextWHERE,\n-    FFEEXPR_contextSELECTCASE,\n-    FFEEXPR_contextCASE,\n-    FFEEXPR_contextDIMLIST,\n-    FFEEXPR_contextDIMLISTCOMMON,\t/* Dim list in COMMON stmt. */\n-    FFEEXPR_contextFILEASSOC,\t/* ASSOCIATEVARIABLE=. */\n-    FFEEXPR_contextFILEINT,\t/* IOSTAT=. */\n-    FFEEXPR_contextFILEDFINT,\t/* NEXTREC=. */\n-    FFEEXPR_contextFILELOG,\t/* NAMED=. */\n-    FFEEXPR_contextFILENUM,\t/* Numerical expression. */\n-    FFEEXPR_contextFILECHAR,\t/* Character expression. */\n-    FFEEXPR_contextFILENUMCHAR,\t/* READ KEYxyz=. */\n-    FFEEXPR_contextFILEDFCHAR,\t/* Default kind character expression. */\n-    FFEEXPR_contextFILEKEY,\t/* OPEN KEY=. */\n-    FFEEXPR_contextFILEEXTFUNC,\t/* USEROPEN=. */\n-    FFEEXPR_contextFILEUNIT,\t/* READ/WRITE UNIT=. */\n-    FFEEXPR_contextFILEUNIT_DF,\t/* DEFINE FILE unit (no \"(\" after it). */\n-    FFEEXPR_contextFILEFORMATNML,\t/* [FMT=] or [NML=]. */\n-    FFEEXPR_contextFILEFORMAT,\t/* FMT=. */\n-    FFEEXPR_contextFILENAMELIST,/* NML=. */\n-    FFEEXPR_contextFILENUMAMBIG,/* BACKSPACE, ENDFILE, REWIND, UNLOCK...\n-\t\t\t\t   where at e.g. BACKSPACE(, if COMMA seen\n-\t\t\t\t   before ), it is ok. */\n-    FFEEXPR_contextFILEUNITAMBIG,\t/* READ(, if COMMA seen before ), ok. */\n-    FFEEXPR_contextFILEVXTCODE,\t/* ENCODE/DECODE third arg (scalar/array). */\n-    FFEEXPR_contextALLOCATE,\t/* ALLOCATE objects (weird). */\n-    FFEEXPR_contextDEALLOCATE,\t/* DEALLOCATE objects (weird). */\n-    FFEEXPR_contextHEAPSTAT,\t/* ALLOCATE/DEALLOCATE STAT= variable. */\n-    FFEEXPR_contextKINDTYPE,\t/* KIND=. */\n-    FFEEXPR_contextINITVAL,\t/* R426 =initialization-expr. */\n-    FFEEXPR_contextNULLIFY,\t/* Pointer names only (F90) or pointers. */\n-    FFEEXPR_contextIOLISTDF,\t/* IOLIST w/internal file (V112 9-14 30,31). */\n-    FFEEXPR_contextINDEX_,\t/* Element dimension or substring value. */\n-    FFEEXPR_contextEQVINDEX_,\t/* EQUIVALENCE element dimension. */\n-    FFEEXPR_contextDATAIMPDOINDEX_,\t/* INDEX in DATAIMPDO context. */\n-    FFEEXPR_contextIMPDOITEM_,\n-    FFEEXPR_contextIMPDOITEMDF_,/* to ...ITEM_ as IOLISTDF is to IOLIST. */\n-    FFEEXPR_contextIMPDOCTRL_,\n-    FFEEXPR_contextDATAIMPDOITEM_,\n-    FFEEXPR_contextDATAIMPDOCTRL_,\n-    FFEEXPR_contextLOC_,\n-    FFEEXPR_contextACTUALARG_,\t/* Actual arg to function or subroutine;\n-\t\t\t\t   turns into ACTUALARGEXPR_ if tokens not\n-\t\t\t\t   NAME (CLOSE_PAREN/COMMA) or PERCENT.... */\n-    FFEEXPR_contextACTUALARGEXPR_,\t/* Like LET but disallow CHAR*(*)\n-\t\t\t\t\t   concats. */\n-    FFEEXPR_contextINDEXORACTUALARG_,\t/* \"CHARACTER FOO; PRINT *,FOO(?\". */\n-    FFEEXPR_contextINDEXORACTUALARGEXPR_,\t/* ? not NAME\n-\t\t\t\t\t\t   (CLOSE_PAREN/COMMA). */\n-    FFEEXPR_contextSFUNCDEFINDEX_,\t/* INDEX_ within stmt-func def. */\n-    FFEEXPR_contextSFUNCDEFACTUALARG_,\n-    FFEEXPR_contextSFUNCDEFACTUALARGEXPR_,\n-    FFEEXPR_contextSFUNCDEFINDEXORACTUALARG_,\n-    FFEEXPR_contextSFUNCDEFINDEXORACTUALARGEXPR_,\n-    FFEEXPR_contextPAREN_,\t/* Rhs paren except in LET context. */\n-    FFEEXPR_contextPARENFILENUM_,\t/* Either PAREN or FILENUM context. */\n-    FFEEXPR_contextPARENFILEUNIT_,\t/* Either PAREN or FILEUNIT context. */\n-    FFEEXPR_context\n-  } ffeexprContext;\n-\n-/* Typedefs. */\n-\n-\n-/* Include files needed by this one. */\n-\n-#include \"bld.h\"\n-#include \"lex.h\"\n-#include \"malloc.h\"\n-\n-/* Structure definitions. */\n-\n-typedef ffelexHandler (*ffeexprCallback) (ffelexToken ft, ffebld expr,\n-\t\t\t\t\t  ffelexToken t);\n-\n-/* Global objects accessed by users of this module. */\n-\n-\n-/* Declare functions with prototypes. */\n-\n-ffebld ffeexpr_collapse_convert (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_paren (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_uplus (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_uminus (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_not (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_add (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_subtract (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_multiply (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_divide (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_power (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_concatenate (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_lt (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_le (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_eq (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_ne (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_gt (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_ge (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_and (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_or (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_xor (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_eqv (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_neqv (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_symter (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_funcref (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_arrayref (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_collapse_substr (ffebld expr, ffelexToken t);\n-ffebld ffeexpr_convert (ffebld source, ffelexToken source_token,\n-\t    ffelexToken dest_token, ffeinfoBasictype bt, ffeinfoKindtype kt,\n-\t\t\tffeinfoRank rk, ffetargetCharacterSize sz,\n-\t\t\tffeexprContext context);\n-ffebld ffeexpr_convert_expr (ffebld source, ffelexToken source_token,\n-\t\t\t     ffebld dest, ffelexToken dest_token,\n-\t\t\t     ffeexprContext context);\n-ffebld ffeexpr_convert_to_sym (ffebld source, ffelexToken source_token,\n-\t\t\t       ffesymbol dest, ffelexToken dest_token);\n-void ffeexpr_init_2 (void);\n-ffelexHandler ffeexpr_rhs (mallocPool pool, ffeexprContext context,\n-\t\t\t   ffeexprCallback callback);\n-ffelexHandler ffeexpr_lhs (mallocPool pool, ffeexprContext context,\n-\t\t\t   ffeexprCallback callback);\n-void ffeexpr_terminate_2 (void);\n-void ffeexpr_type_combine (ffeinfoBasictype *nbt, ffeinfoKindtype *nkt,\n-\t\t\t   ffeinfoBasictype lbt, ffeinfoKindtype lkt,\n-\t\t\t   ffeinfoBasictype rbt, ffeinfoKindtype rkt,\n-\t\t\t   ffelexToken t);\n-\n-/* Define macros. */\n-\n-#define ffeexpr_init_0()\n-#define ffeexpr_init_1()\n-#define ffeexpr_init_3()\n-#define ffeexpr_init_4()\n-#define ffeexpr_terminate_0()\n-#define ffeexpr_terminate_1()\n-#define ffeexpr_terminate_3()\n-#define ffeexpr_terminate_4()\n-\n-/* End of #include file. */\n-\n-#endif /* ! GCC_F_EXPR_H */"}, {"sha": "fd5d3bf349ae7d7d0e6ff4b512ace5bb64b2f1c9", "filename": "gcc/f/ffe.texi", "status": "removed", "additions": 0, "deletions": 2063, "changes": 2063, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fffe.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fffe.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fffe.texi?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,2063 +0,0 @@\n-@c Copyright (C) 1999, 2003 Free Software Foundation, Inc.\n-@c This is part of the G77 manual.\n-@c For copying conditions, see the file g77.texi.\n-\n-@node Front End\n-@chapter Front End\n-@cindex GNU Fortran Front End (FFE)\n-@cindex FFE\n-@cindex @code{g77}, front end\n-@cindex front end, @code{g77}\n-\n-This chapter describes some aspects of the design and implementation\n-of the @code{g77} front end.\n-\n-To find about things that are ``To Be Determined'' or ``To Be Done'',\n-search for the string TBD.\n-If you want to help by working on one or more of these items,\n-email @email{gcc@@gcc.gnu.org}.\n-If you're planning to do more than just research issues and offer comments,\n-see @uref{http://gcc.gnu.org/contribute.html} for steps you might\n-need to take first.\n-\n-@menu\n-* Overview of Sources::\n-* Overview of Translation Process::\n-* Philosophy of Code Generation::\n-* Two-pass Design::\n-* Challenges Posed::\n-* Transforming Statements::\n-* Transforming Expressions::\n-* Internal Naming Conventions::\n-@end menu\n-\n-@node Overview of Sources\n-@section Overview of Sources\n-\n-The current directory layout includes the following:\n-\n-@table @file\n-@item @var{srcdir}/gcc/\n-Non-g77 files in gcc\n-\n-@item @var{srcdir}/gcc/f/\n-GNU Fortran front end sources\n-\n-@item @var{srcdir}/libf2c/\n-@code{libg2c} configuration and @code{g2c.h} file generation\n-\n-@item @var{srcdir}/libf2c/libF77/\n-General support and math portion of @code{libg2c}\n-\n-@item @var{srcdir}/libf2c/libI77/\n-I/O portion of @code{libg2c}\n-\n-@item @var{srcdir}/libf2c/libU77/\n-Additional interfaces to Unix @code{libc} for @code{libg2c}\n-@end table\n-\n-Components of note in @code{g77} are described below.\n-\n-@file{f/} as a whole contains the source for @code{g77},\n-while @file{libf2c/} contains a portion of the separate program\n-@code{f2c}.\n-Note that the @code{libf2c} code is not part of the program @code{g77},\n-just distributed with it.\n-\n-@file{f/} contains text files that document the Fortran compiler, source\n-files for the GNU Fortran Front End (FFE), and some other stuff.\n-The @code{g77} compiler code is placed in @file{f/} because it,\n-along with its contents,\n-is designed to be a subdirectory of a @code{gcc} source directory,\n-@file{gcc/},\n-which is structured so that language-specific front ends can be ``dropped\n-in'' as subdirectories.\n-The C++ front end (@code{g++}), is an example of this---it resides in\n-the @file{cp/} subdirectory.\n-Note that the C front end (also referred to as @code{gcc})\n-is an exception to this, as its source files reside\n-in the @file{gcc/} directory itself.\n-\n-@file{libf2c/} contains the run-time libraries for the @code{f2c} program,\n-also used by @code{g77}.\n-These libraries normally referred to collectively as @code{libf2c}.\n-When built as part of @code{g77},\n-@code{libf2c} is installed under the name @code{libg2c} to avoid\n-conflict with any existing version of @code{libf2c},\n-and thus is often referred to as @code{libg2c} when the\n-@code{g77} version is specifically being referred to.\n-\n-The @code{netlib} version of @code{libf2c/}\n-contains two distinct libraries,\n-@code{libF77} and @code{libI77},\n-each in their own subdirectories.\n-In @code{g77}, this distinction is not made,\n-beyond maintaining the subdirectory structure in the source-code tree.\n-\n-@file{libf2c/} is not part of the program @code{g77},\n-just distributed with it.\n-It contains files not present\n-in the official (@code{netlib}) version of @code{libf2c},\n-and also contains some minor changes made from @code{libf2c},\n-to fix some bugs,\n-and to facilitate automatic configuration, building, and installation of\n-@code{libf2c} (as @code{libg2c}) for use by @code{g77} users.\n-See @file{libf2c/README} for more information,\n-including licensing conditions\n-governing distribution of programs containing code from @code{libg2c}.\n-\n-@code{libg2c}, @code{g77}'s version of @code{libf2c},\n-adds Dave Love's implementation of @code{libU77},\n-in the @file{libf2c/libU77/} directory.\n-This library is distributed under the\n-GNU Library General Public License (LGPL)---see the\n-file @file{libf2c/libU77/COPYING.LIB}\n-for more information,\n-as this license\n-governs distribution conditions for programs containing code\n-from this portion of the library.\n-\n-Files of note in @file{f/} and @file{libf2c/} are described below:\n-\n-@table @file\n-@item f/BUGS\n-Lists some important bugs known to be in g77.\n-Or use Info (or GNU Emacs Info mode) to read\n-the ``Actual Bugs'' node of the @code{g77} documentation:\n-\n-@smallexample\n-info -f f/g77.info -n \"Actual Bugs\"\n-@end smallexample\n-\n-@item f/ChangeLog\n-Lists recent changes to @code{g77} internals.\n-\n-@item libf2c/ChangeLog\n-Lists recent changes to @code{libg2c} internals.\n-\n-@item f/NEWS\n-Contains the per-release changes.\n-These include the user-visible\n-changes described in the node ``Changes''\n-in the @code{g77} documentation, plus internal\n-changes of import.\n-Or use:\n-\n-@smallexample\n-info -f f/g77.info -n News\n-@end smallexample\n-\n-@item f/g77.info*\n-The @code{g77} documentation, in Info format,\n-produced by building @code{g77}.\n-\n-All users of @code{g77} (not just installers) should read this,\n-using the @code{more} command if neither the @code{info} command,\n-nor GNU Emacs (with its Info mode), are available, or if users\n-aren't yet accustomed to using these tools.\n-All of these files are readable as ``plain text'' files,\n-though they're easier to navigate using Info readers\n-such as @code{info} and GNU Emacs Info mode.\n-@end table\n-\n-If you want to explore the FFE code, which lives entirely in @file{f/},\n-here are a few clues.\n-The file @file{g77spec.c} contains the @code{g77}-specific source code\n-for the @code{g77} command only---this just forms a variant of the\n-@code{gcc} command, so,\n-just as the @code{gcc} command itself does not contain the C front end,\n-the @code{g77} command does not contain the Fortran front end (FFE).\n-The FFE code ends up in an executable named @file{f771},\n-which does the actual compiling,\n-so it contains the FFE plus the @code{gcc} back end (GBE),\n-the latter to do most of the optimization, and the code generation.\n-\n-The file @file{parse.c} is the source file for @code{yyparse()},\n-which is invoked by the GBE to start the compilation process,\n-for @file{f771}.\n-\n-The file @file{top.c} contains the top-level FFE function @code{ffe_file}\n-and it (along with top.h) define all @samp{ffe_[a-z].*}, @samp{ffe[A-Z].*},\n-and @samp{FFE_[A-Za-z].*} symbols.\n-\n-The file @file{fini.c} is a @code{main()} program that is used when building\n-the FFE to generate C header and source files for recognizing keywords.\n-The files @file{malloc.c} and @file{malloc.h} comprise a memory manager\n-that defines all @samp{malloc_[a-z].*}, @samp{malloc[A-Z].*}, and\n-@samp{MALLOC_[A-Za-z].*} symbols.\n-\n-All other modules named @var{xyz}\n-are comprised of all files named @samp{@var{xyz}*.@var{ext}}\n-and define all @samp{ffe@var{xyz}_[a-z].*}, @samp{ffe@var{xyz}[A-Z].*},\n-and @samp{FFE@var{XYZ}_[A-Za-z].*} symbols.\n-If you understand all this, congratulations---it's easier for me to remember\n-how it works than to type in these regular expressions.\n-But it does make it easy to find where a symbol is defined.\n-For example, the symbol @samp{ffexyz_set_something} would be defined\n-in @file{xyz.h} and implemented there (if it's a macro) or in @file{xyz.c}.\n-\n-The ``porting'' files of note currently are:\n-\n-@table @file\n-@item proj.h\n-This defines the ``language'' used by all the other source files,\n-the language being Standard C plus some useful things\n-like @code{ARRAY_SIZE} and such.\n-\n-@item target.c\n-@itemx target.h\n-These describe the target machine\n-in terms of what data types are supported,\n-how they are denoted\n-(to what C type does an @code{INTEGER*8} map, for example),\n-how to convert between them,\n-and so on.\n-Over time, versions of @code{g77} rely less on this file\n-and more on run-time configuration based on GBE info\n-in @file{com.c}.\n-\n-@item com.c\n-@itemx com.h\n-These are the primary interface to the GBE.\n-\n-@item ste.c\n-@itemx ste.h\n-This contains code for implementing recognized executable statements\n-in the GBE.\n-\n-@item src.c\n-@itemx src.h\n-These contain information on the format(s) of source files\n-(such as whether they are never to be processed as case-insensitive\n-with regard to Fortran keywords).\n-@end table\n-\n-If you want to debug the @file{f771} executable,\n-for example if it crashes,\n-note that the global variables @code{lineno} and @code{input_filename}\n-are usually set to reflect the current line being read by the lexer\n-during the first-pass analysis of a program unit and to reflect\n-the current line being processed during the second-pass compilation\n-of a program unit.\n-\n-If an invocation of the function @code{ffestd_exec_end} is on the stack,\n-the compiler is in the second pass, otherwise it is in the first.\n-\n-(This information might help you reduce a test case and/or work around\n-a bug in @code{g77} until a fix is available.)\n-\n-@node Overview of Translation Process\n-@section Overview of Translation Process\n-\n-The order of phases translating source code to the form accepted\n-by the GBE is:\n-\n-@enumerate\n-@item\n-Stripping punched-card sources (@file{g77stripcard.c})\n-\n-@item\n-Lexing (@file{lex.c})\n-\n-@item\n-Stand-alone statement identification (@file{sta.c})\n-\n-@item\n-INCLUDE handling (@file{sti.c})\n-\n-@item\n-Order-dependent statement identification (@file{stq.c})\n-\n-@item\n-Parsing (@file{stb.c} and @file{expr.c})\n-\n-@item\n-Constructing (@file{stc.c})\n-\n-@item\n-Collecting (@file{std.c})\n-\n-@item\n-Expanding (@file{ste.c})\n-@end enumerate\n-\n-To get a rough idea of how a particularly twisted Fortran statement\n-gets treated by the passes, consider:\n-\n-@smallexample\n-      FORMAT(I2 4H)=(J/\n-     &   I3)\n-@end smallexample\n-\n-The job of @file{lex.c} is to know enough about Fortran syntax rules\n-to break the statement up into distinct lexemes without requiring\n-any feedback from subsequent phases:\n-\n-@smallexample\n-`FORMAT'\n-`('\n-`I24H'\n-`)'\n-`='\n-`('\n-`J'\n-`/'\n-`I3'\n-`)'\n-@end smallexample\n-\n-The job of @file{sta.c} is to figure out the kind of statement,\n-or, at least, statement form, that sequence of lexemes represent.\n-\n-The sooner it can do this (in terms of using the smallest number of\n-lexemes, starting with the first for each statement), the better,\n-because that leaves diagnostics for problems beyond the recognition\n-of the statement form to subsequent phases,\n-which can usually better describe the nature of the problem.\n-\n-In this case, the @samp{=} at ``level zero''\n-(not nested within parentheses)\n-tells @file{sta.c} that this is an @emph{assignment-form},\n-not @code{FORMAT}, statement.\n-\n-An assignment-form statement might be a statement-function\n-definition or an executable assignment statement.\n-\n-To make that determination,\n-@file{sta.c} looks at the first two lexemes.\n-\n-Since the second lexeme is @samp{(},\n-the first must represent an array for this to be an assignment statement,\n-else it's a statement function.\n-\n-Either way, @file{sta.c} hands off the statement to @file{stq.c}\n-(via @file{sti.c}, which expands INCLUDE files).\n-@file{stq.c} figures out what a statement that is,\n-on its own, ambiguous, must actually be based on the context\n-established by previous statements.\n-\n-So, @file{stq.c} watches the statement stream for executable statements,\n-END statements, and so on, so it knows whether @samp{A(B)=C} is\n-(intended as) a statement-function definition or an assignment statement.\n-\n-After establishing the context-aware statement info, @file{stq.c}\n-passes the original sample statement on to @file{stb.c}\n-(either its statement-function parser or its assignment-statement parser).\n-\n-@file{stb.c} forms a\n-statement-specific record containing the pertinent information.\n-That information includes a source expression and,\n-for an assignment statement, a destination expression.\n-Expressions are parsed by @file{expr.c}.\n-\n-This record is passed to @file{stc.c},\n-which copes with the implications of the statement\n-within the context established by previous statements.\n-\n-For example, if it's the first statement in the file\n-or after an @code{END} statement,\n-@file{stc.c} recognizes that, first of all,\n-a main program unit is now being lexed\n-(and tells that to @file{std.c}\n-before telling it about the current statement).\n-\n-@file{stc.c} attaches whatever information it can,\n-usually derived from the context established by the preceding statements,\n-and passes the information to @file{std.c}.\n-\n-@file{std.c} saves this information away,\n-since the GBE cannot cope with information\n-that might be incomplete at this stage.\n-\n-For example, @samp{I3} might later be determined\n-to be an argument to an alternate @code{ENTRY} point.\n-\n-When @file{std.c} is told about the end of an external (top-level)\n-program unit,\n-it passes all the information it has saved away\n-on statements in that program unit\n-to @file{ste.c}.\n-\n-@file{ste.c} ``expands'' each statement, in sequence, by\n-constructing the appropriate GBE information and calling\n-the appropriate GBE routines.\n-\n-Details on the transformational phases follow.\n-Keep in mind that Fortran numbering is used,\n-so the first character on a line is column 1,\n-decimal numbering is used, and so on.\n-\n-@menu\n-* g77stripcard::\n-* lex.c::\n-* sta.c::\n-* sti.c::\n-* stq.c::\n-* stb.c::\n-* expr.c::\n-* stc.c::\n-* std.c::\n-* ste.c::\n-\n-* Gotchas (Transforming)::\n-* TBD (Transforming)::\n-@end menu\n-\n-@node g77stripcard\n-@subsection g77stripcard\n-\n-The @code{g77stripcard} program handles removing content beyond\n-column 72 (adjustable via a command-line option),\n-optionally warning about that content being something other\n-than trailing whitespace or Fortran commentary.\n-\n-This program is needed because @code{lex.c} doesn't pay attention\n-to maximum line lengths at all, to make it easier to maintain,\n-as well as faster (for sources that don't depend on the maximum\n-column length vis-a-vis trailing non-blank non-commentary content).\n-\n-Just how this program will be run---whether automatically for\n-old source (perhaps as the default for @file{.f} files?)---is not\n-yet determined.\n-\n-In the meantime, it might as well be implemented as a typical UNIX pipe.\n-\n-It should accept a @samp{-fline-length-@var{n}} option,\n-with the default line length set to 72.\n-\n-When the text it strips off the end of a line is not blank\n-(not spaces and tabs),\n-it should insert an additional comment line\n-(beginning with @samp{!},\n-so it works for both fixed-form and free-form files)\n-containing the text,\n-following the stripped line.\n-The inserted comment should have a prefix of some kind,\n-TBD, that distinguishes the comment as representing stripped text.\n-Users could use that to @code{sed} out such lines, if they wished---it\n-seems silly to provide a command-line option to delete information\n-when it can be so easily filtered out by another program.\n-\n-(This inserted comment should be designed to ``fit in'' well\n-with whatever the Fortran community is using these days for\n-preprocessor, translator, and other such products, like OpenMP.\n-What that's all about, and how @code{g77} can elegantly fit its\n-special comment conventions into it all, is TBD as well.\n-We don't want to reinvent the wheel here, but if there turn out\n-to be too many conflicting conventions, we might have to invent\n-one that looks nothing like the others, but which offers their\n-host products a better infrastructure in which to fit and coexist\n-peacefully.)\n-\n-@code{g77stripcard} probably shouldn't do any tab expansion or other\n-fancy stuff.\n-People can use @code{expand} or other pre-filtering if they like.\n-The idea here is to keep each stage quite simple, while providing\n-excellent performance for ``normal'' code.\n-\n-(Code with junk beyond column 73 is not really ``normal'',\n-as it comes from a card-punch heritage,\n-and will be increasingly hard for tomorrow's Fortran programmers to read.)\n-\n-@node lex.c\n-@subsection lex.c\n-\n-To help make the lexer simple, fast, and easy to maintain,\n-while also having @code{g77} generally encourage Fortran programmers\n-to write simple, maintainable, portable code by maximizing the\n-performance of compiling that kind of code:\n-\n-@itemize @bullet\n-@item\n-There'll be just one lexer, for both fixed-form and free-form source.\n-\n-@item\n-It'll care about the form only when handling the first 7 columns of\n-text, stuff like spaces between strings of alphanumerics, and\n-how lines are continued.\n-\n-Some other distinctions will be handled by subsequent phases,\n-so at least one of them will have to know which form is involved.\n-\n-For example, @samp{I = 2 . 4} is acceptable in fixed form,\n-and works in free form as well given the implementation @code{g77}\n-presently uses.\n-But the standard requires a diagnostic for it in free form,\n-so the parser has to be able to recognize that\n-the lexemes aren't contiguous\n-(information the lexer @emph{does} have to provide)\n-and that free-form source is being parsed,\n-so it can provide the diagnostic.\n-\n-The @code{g77} lexer doesn't try to gather @samp{2 . 4} into a single lexeme.\n-Otherwise, it'd have to know a whole lot more about how to parse Fortran,\n-or subsequent phases (mainly parsing) would have two paths through\n-lots of critical code---one to handle the lexeme @samp{2}, @samp{.},\n-and @samp{4} in sequence, another to handle the lexeme @samp{2.4}.\n-\n-@item\n-It won't worry about line lengths\n-(beyond the first 7 columns for fixed-form source).\n-\n-That is, once it starts parsing the ``statement'' part of a line\n-(column 7 for fixed-form, column 1 for free-form),\n-it'll keep going until it finds a newline,\n-rather than ignoring everything past a particular column\n-(72 or 132).\n-\n-The implication here is that there shouldn't @emph{be}\n-anything past that last column, other than whitespace or\n-commentary, because users using typical editors\n-(or viewing output as typically printed)\n-won't necessarily know just where the last column is.\n-\n-Code that has ``garbage'' beyond the last column\n-(almost certainly only fixed-form code with a punched-card legacy,\n-such as code using columns 73-80 for ``sequence numbers'')\n-will have to be run through @code{g77stripcard} first.\n-\n-Also, keeping track of the maximum column position while also watching out\n-for the end of a line @emph{and} while reading from a file\n-just makes things slower.\n-Since a file must be read, and watching for the end of the line\n-is necessary (unless the typical input file was preprocessed to\n-include the necessary number of trailing spaces),\n-dropping the tracking of the maximum column position\n-is the only way to reduce the complexity of the pertinent code\n-while maintaining high performance.\n-\n-@item\n-ASCII encoding is assumed for the input file.\n-\n-Code written in other character sets will have to be converted first.\n-\n-@item\n-Tabs (ASCII code 9)\n-will be converted to spaces via the straightforward\n-approach.\n-\n-Specifically, a tab is converted to between one and eight spaces\n-as necessary to reach column @var{n},\n-where dividing @samp{(@var{n} - 1)} by eight\n-results in a remainder of zero.\n-\n-That saves having to pass most source files through @code{expand}.\n-\n-@item\n-Linefeeds (ASCII code 10)\n-mark the ends of lines.\n-\n-@item\n-A carriage return (ASCII code 13)\n-is accept if it immediately precedes a linefeed,\n-in which case it is ignored.\n-\n-Otherwise, it is rejected (with a diagnostic).\n-\n-@item\n-Any other characters other than the above\n-that are not part of the GNU Fortran Character Set\n-(@pxref{Character Set})\n-are rejected with a diagnostic.\n-\n-This includes backspaces, form feeds, and the like.\n-\n-(It might make sense to allow a form feed in column 1\n-as long as that's the only character on a line.\n-It certainly wouldn't seem to cost much in terms of performance.)\n-\n-@item\n-The end of the input stream (EOF)\n-ends the current line.\n-\n-@item\n-The distinction between uppercase and lowercase letters\n-will be preserved.\n-\n-It will be up to subsequent phases to decide to fold case.\n-\n-Current plans are to permit any casing for Fortran (reserved) keywords\n-while preserving casing for user-defined names.\n-(This might not be made the default for @file{.f} files, though.)\n-\n-Preserving case seems necessary to provide more direct access\n-to facilities outside of @code{g77}, such as to C or Pascal code.\n-\n-Names of intrinsics will probably be matchable in any case,\n-\n-(How @samp{external SiN; r = sin(x)} would be handled is TBD.\n-I think old @code{g77} might already handle that pretty elegantly,\n-but whether we can cope with allowing the same fragment to reference\n-a @emph{different} procedure, even with the same interface,\n-via @samp{s = SiN(r)}, needs to be determined.\n-If it can't, we need to make sure that when code introduces\n-a user-defined name, any intrinsic matching that name\n-using a case-insensitive comparison\n-is ``turned off''.)\n-\n-@item\n-Backslashes in @code{CHARACTER} and Hollerith constants\n-are not allowed.\n-\n-This avoids the confusion introduced by some Fortran compiler vendors\n-providing C-like interpretation of backslashes,\n-while others provide straight-through interpretation.\n-\n-Some kind of lexical construct (TBD) will be provided to allow\n-flagging of a @code{CHARACTER}\n-(but probably not a Hollerith)\n-constant that permits backslashes.\n-It'll necessarily be a prefix, such as:\n-\n-@smallexample\n-PRINT *, C'This line has a backspace \\b here.'\n-PRINT *, F'This line has a straight backslash \\ here.'\n-@end smallexample\n-\n-Further, command-line options might be provided to specify that\n-one prefix or the other is to be assumed as the default\n-for @code{CHARACTER} constants.\n-\n-However, it seems more helpful for @code{g77} to provide a program\n-that converts prefix all constants\n-(or just those containing backslashes)\n-with the desired designation,\n-so printouts of code can be read\n-without knowing the compile-time options used when compiling it.\n-\n-If such a program is provided\n-(let's name it @code{g77slash} for now),\n-then a command-line option to @code{g77} should not be provided.\n-(Though, given that it'll be easy to implement, it might be hard\n-to resist user requests for it ``to compile faster than if we\n-have to invoke another filter''.)\n-\n-This program would take a command-line option to specify the\n-default interpretation of slashes,\n-affecting which prefix it uses for constants.\n-\n-@code{g77slash} probably should automatically convert Hollerith\n-constants that contain slashes\n-to the appropriate @code{CHARACTER} constants.\n-Then @code{g77} wouldn't have to define a prefix syntax for Hollerith\n-constants specifying whether they want C-style or straight-through\n-backslashes.\n-\n-@item\n-To allow for form-neutral INCLUDE files without requiring them\n-to be preprocessed,\n-the fixed-form lexer should offer an extension (if possible)\n-allowing a trailing @samp{&} to be ignored, especially if after\n-column 72, as it would be using the traditional Unix Fortran source\n-model (which ignores @emph{everything} after column 72).\n-@end itemize\n-\n-The above implements nearly exactly what is specified by\n-@ref{Character Set},\n-and\n-@ref{Lines},\n-except it also provides automatic conversion of tabs\n-and ignoring of newline-related carriage returns,\n-as well as accommodating form-neutral INCLUDE files.\n-\n-It also implements the ``pure visual'' model,\n-by which is meant that a user viewing his code\n-in a typical text editor\n-(assuming it's not preprocessed via @code{g77stripcard} or similar)\n-doesn't need any special knowledge\n-of whether spaces on the screen are really tabs,\n-whether lines end immediately after the last visible non-space character\n-or after a number of spaces and tabs that follow it,\n-or whether the last line in the file is ended by a newline.\n-\n-Most editors don't make these distinctions,\n-the ANSI FORTRAN 77 standard doesn't require them to,\n-and it permits a standard-conforming compiler\n-to define a method for transforming source code to\n-``standard form'' however it wants.\n-\n-So, GNU Fortran defines it such that users have the best chance\n-of having the code be interpreted the way it looks on the screen\n-of the typical editor.\n-\n-(Fancy editors should @emph{never} be required to correctly read code\n-written in classic two-dimensional-plaintext form.\n-By correct reading I mean ability to read it, book-like, without\n-mistaking text ignored by the compiler for program code and vice versa,\n-and without having to count beyond the first several columns.\n-The vague meaning of ASCII TAB, among other things, complicates\n-this somewhat, but as long as ``everyone'', including the editor,\n-other tools, and printer, agrees about the every-eighth-column convention,\n-the GNU Fortran ``pure visual'' model meets these requirements.\n-Any language or user-visible source form\n-requiring special tagging of tabs,\n-the ends of lines after spaces/tabs,\n-and so on, fails to meet this fairly straightforward specification.\n-Fortunately, Fortran @emph{itself} does not mandate such a failure,\n-though most vendor-supplied defaults for their Fortran compilers @emph{do}\n-fail to meet this specification for readability.)\n-\n-Further, this model provides a clean interface\n-to whatever preprocessors or code-generators are used\n-to produce input to this phase of @code{g77}.\n-Mainly, they need not worry about long lines.\n-\n-@node sta.c\n-@subsection sta.c\n-\n-@node sti.c\n-@subsection sti.c\n-\n-@node stq.c\n-@subsection stq.c\n-\n-@node stb.c\n-@subsection stb.c\n-\n-@node expr.c\n-@subsection expr.c\n-\n-@node stc.c\n-@subsection stc.c\n-\n-@node std.c\n-@subsection std.c\n-\n-@node ste.c\n-@subsection ste.c\n-\n-@node Gotchas (Transforming)\n-@subsection Gotchas (Transforming)\n-\n-This section is not about transforming ``gotchas'' into something else.\n-It is about the weirder aspects of transforming Fortran,\n-however that's defined,\n-into a more modern, canonical form.\n-\n-@subsubsection Multi-character Lexemes\n-\n-Each lexeme carries with it a pointer to where it appears in the source.\n-\n-To provide the ability for diagnostics to point to column numbers,\n-in addition to line numbers and names,\n-lexemes that represent more than one (significant) character\n-in the source code need, generally,\n-to provide pointers to where each @emph{character} appears in the source.\n-\n-This provides the ability to properly identify the precise location\n-of the problem in code like\n-\n-@smallexample\n-SUBROUTINE X\n-END\n-BLOCK DATA X\n-END\n-@end smallexample\n-\n-which, in fixed-form source, would result in single lexemes\n-consisting of the strings @samp{SUBROUTINEX} and @samp{BLOCKDATAX}.\n-(The problem is that @samp{X} is defined twice,\n-so a pointer to the @samp{X} in the second definition,\n-as well as a follow-up pointer to the corresponding pointer in the first,\n-would be preferable to pointing to the beginnings of the statements.)\n-\n-This need also arises when parsing (and diagnosing) @code{FORMAT}\n-statements.\n-\n-Further, it arises when diagnosing\n-@code{FMT=} specifiers that contain constants\n-(or partial constants, or even propagated constants!)\n-in I/O statements, as in:\n-\n-@smallexample\n-PRINT '(I2, 3HAB)', J\n-@end smallexample\n-\n-(A pointer to the beginning of the prematurely-terminated Hollerith\n-constant, and/or to the close parenthese, is preferable to a pointer\n-to the open-parenthese or the apostrophe that precedes it.)\n-\n-Multi-character lexemes, which would seem to naturally include\n-at least digit strings, alphanumeric strings, @code{CHARACTER}\n-constants, and Hollerith constants, therefore need to provide\n-location information on each character.\n-(Maybe Hollerith constants don't, but it's unnecessary to except them.)\n-\n-The question then arises, what about @emph{other} multi-character lexemes,\n-such as @samp{**} and @samp{//},\n-and Fortran 90's @samp{(/}, @samp{/)}, @samp{::}, and so on?\n-\n-Turns out there's a need to identify the location of the second character\n-of these two-character lexemes.\n-For example, in @samp{I(/J) = K}, the slash needs to be diagnosed\n-as the problem, not the open parenthese.\n-Similarly, it is preferable to diagnose the second slash in\n-@samp{I = J // K} rather than the first, given the implicit typing\n-rules, which would result in the compiler disallowing the attempted\n-concatenation of two integers.\n-(Though, since that's more of a semantic issue,\n-it's not @emph{that} much preferable.)\n-\n-Even sequences that could be parsed as digit strings could use location info,\n-for example, to diagnose the @samp{9} in the octal constant @samp{O'129'}.\n-(This probably will be parsed as a character string,\n-to be consistent with the parsing of @samp{Z'129A'}.)\n-\n-To avoid the hassle of recording the location of the second character,\n-while also preserving the general rule that each significant character\n-is distinctly pointed to by the lexeme that contains it,\n-it's best to simply not have any fixed-size lexemes\n-larger than one character.\n-\n-This new design is expected to make checking for two\n-@samp{*} lexemes in a row much easier than the old design,\n-so this is not much of a sacrifice.\n-It probably makes the lexer much easier to implement\n-than it makes the parser harder.\n-\n-@subsubsection Space-padding Lexemes\n-\n-Certain lexemes need to be padded with virtual spaces when the\n-end of the line (or file) is encountered.\n-\n-This is necessary in fixed form, to handle lines that don't\n-extend to column 72, assuming that's the line length in effect.\n-\n-@subsubsection Bizarre Free-form Hollerith Constants\n-\n-Last I checked, the Fortran 90 standard actually required the compiler\n-to silently accept something like\n-\n-@smallexample\n-FORMAT ( 1 2   Htwelve chars )\n-@end smallexample\n-\n-as a valid @code{FORMAT} statement specifying a twelve-character\n-Hollerith constant.\n-\n-The implication here is that, since the new lexer is a zero-feedback one,\n-it won't know that the special case of a @code{FORMAT} statement being parsed\n-requires apparently distinct lexemes @samp{1} and @samp{2} to be treated as\n-a single lexeme.\n-\n-(This is a horrible misfeature of the Fortran 90 language.\n-It's one of many such misfeatures that almost make me want\n-to not support them, and forge ahead with designing a new\n-``GNU Fortran'' language that has the features,\n-but not the misfeatures, of Fortran 90,\n-and provide utility programs to do the conversion automatically.)\n-\n-So, the lexer must gather distinct chunks of decimal strings into\n-a single lexeme in contexts where a single decimal lexeme might\n-start a Hollerith constant.\n-\n-(Which probably means it might as well do that all the time\n-for all multi-character lexemes, even in free-form mode,\n-leaving it to subsequent phases to pull them apart as they see fit.)\n-\n-Compare the treatment of this to how\n-\n-@smallexample\n-CHARACTER * 4 5 HEY\n-@end smallexample\n-\n-and\n-\n-@smallexample\n-CHARACTER * 12 HEY\n-@end smallexample\n-\n-must be treated---the former must be diagnosed, due to the separation\n-between lexemes, the latter must be accepted as a proper declaration.\n-\n-@subsubsection Hollerith Constants\n-\n-Recognizing a Hollerith constant---specifically,\n-that an @samp{H} or @samp{h} after a digit string begins\n-such a constant---requires some knowledge of context.\n-\n-Hollerith constants (such as @samp{2HAB}) can appear after:\n-\n-@itemize @bullet\n-@item\n-@samp{(}\n-\n-@item\n-@samp{,}\n-\n-@item\n-@samp{=}\n-\n-@item\n-@samp{+}, @samp{-}, @samp{/}\n-\n-@item\n-@samp{*}, except as noted below\n-@end itemize\n-\n-Hollerith constants don't appear after:\n-\n-@itemize @bullet\n-@item\n-@samp{CHARACTER*},\n-which can be treated generally as\n-any @samp{*} that is the second lexeme of a statement\n-@end itemize\n-\n-@subsubsection Confusing Function Keyword\n-\n-While\n-\n-@smallexample\n-REAL FUNCTION FOO ()\n-@end smallexample\n-\n-must be a @code{FUNCTION} statement and\n-\n-@smallexample\n-REAL FUNCTION FOO (5)\n-@end smallexample\n-\n-must be a type-definition statement,\n-\n-@smallexample\n-REAL FUNCTION FOO (@var{names})\n-@end smallexample\n-\n-where @var{names} is a comma-separated list of names,\n-can be one or the other.\n-\n-The only way to disambiguate that statement\n-(short of mandating free-form source or a short maximum\n-length for name for external procedures)\n-is based on the context of the statement.\n-\n-In particular, the statement is known to be within an\n-already-started program unit\n-(but not at the outer level of the @code{CONTAINS} block),\n-it is a type-declaration statement.\n-\n-Otherwise, the statement is a @code{FUNCTION} statement,\n-in that it begins a function program unit\n-(external, or, within @code{CONTAINS}, nested).\n-\n-@subsubsection Weird READ\n-\n-The statement\n-\n-@smallexample\n-READ (N)\n-@end smallexample\n-\n-is equivalent to either\n-\n-@smallexample\n-READ (UNIT=(N))\n-@end smallexample\n-\n-or\n-\n-@smallexample\n-READ (FMT=(N))\n-@end smallexample\n-\n-depending on which would be valid in context.\n-\n-Specifically, if @samp{N} is type @code{INTEGER},\n-@samp{READ (FMT=(N))} would not be valid,\n-because parentheses may not be used around @samp{N},\n-whereas they may around it in @samp{READ (UNIT=(N))}.\n-\n-Further, if @samp{N} is type @code{CHARACTER},\n-the opposite is true---@samp{READ (UNIT=(N))} is not valid,\n-but @samp{READ (FMT=(N))} is.\n-\n-Strictly speaking, if anything follows\n-\n-@smallexample\n-READ (N)\n-@end smallexample\n-\n-in the statement, whether the first lexeme after the close\n-parenthese is a comma could be used to disambiguate the two cases,\n-without looking at the type of @samp{N},\n-because the comma is required for the @samp{READ (FMT=(N))}\n-interpretation and disallowed for the @samp{READ (UNIT=(N))}\n-interpretation.\n-\n-However, in practice, many Fortran compilers allow\n-the comma for the @samp{READ (UNIT=(N))}\n-interpretation anyway\n-(in that they generally allow a leading comma before\n-an I/O list in an I/O statement),\n-and much code takes advantage of this allowance.\n-\n-(This is quite a reasonable allowance, since the\n-juxtaposition of a comma-separated list immediately\n-after an I/O control-specification list, which is also comma-separated,\n-without an intervening comma,\n-looks sufficiently ``wrong'' to programmers\n-that they can't resist the itch to insert the comma.\n-@samp{READ (I, J), K, L} simply looks cleaner than\n-@samp{READ (I, J) K, L}.)\n-\n-So, type-based disambiguation is needed unless strict adherence\n-to the standard is always assumed, and we're not going to assume that.\n-\n-@node TBD (Transforming)\n-@subsection TBD (Transforming)\n-\n-Continue researching gotchas, designing the transformational process,\n-and implementing it.\n-\n-Specific issues to resolve:\n-\n-@itemize @bullet\n-@item\n-Just where should (if it was implemented) @code{USE} processing take place?\n-\n-This gets into the whole issue of how @code{g77} should handle the concept\n-of modules.\n-I think GNAT already takes on this issue, but don't know more than that.\n-Jim Giles has written extensively on @code{comp.lang.fortran}\n-about his opinions on module handling, as have others.\n-Jim's views should be taken into account.\n-\n-Actually, Richard M. Stallman (RMS) also has written up\n-some guidelines for implementing such things,\n-but I'm not sure where I read them.\n-Perhaps the old @email{gcc2@@cygnus.com} list.\n-\n-If someone could dig references to these up and get them to me,\n-that would be much appreciated!\n-Even though modules are not on the short-term list for implementation,\n-it'd be helpful to know @emph{now} how to avoid making them harder to\n-implement them @emph{later}.\n-\n-@item\n-Should the @code{g77} command become just a script that invokes\n-all the various preprocessing that might be needed,\n-thus making it seem slower than necessary for legacy code\n-that people are unwilling to convert,\n-or should we provide a separate script for that,\n-thus encouraging people to convert their code once and for all?\n-\n-At least, a separate script to behave as old @code{g77} did,\n-perhaps named @code{g77old}, might ease the transition,\n-as might a corresponding one that converts source codes\n-named @code{g77oldnew}.\n-\n-These scripts would take all the pertinent options @code{g77} used\n-to take and run the appropriate filters,\n-passing the results to @code{g77} or just making new sources out of them\n-(in a subdirectory, leaving the user to do the dirty deed of\n-moving or copying them over the old sources).\n-\n-@item\n-Do other Fortran compilers provide a prefix syntax\n-to govern the treatment of backslashes in @code{CHARACTER}\n-(or Hollerith) constants?\n-\n-Knowing what other compilers provide would help.\n-\n-@item\n-Is it okay to drop support for the @samp{-fintrin-case-initcap},\n-@samp{-fmatch-case-initcap}, @samp{-fsymbol-case-initcap},\n-and @samp{-fcase-initcap} options?\n-\n-I've asked @email{info-gnu-fortran@@gnu.org} for input on this.\n-Not having to support these makes it easier to write the new front end,\n-and might also avoid complicated its design.\n-\n-The consensus to date (1999-11-17) has been to drop this support.\n-Can't recall anybody saying they're using it, in fact.\n-@end itemize\n-\n-@node Philosophy of Code Generation\n-@section Philosophy of Code Generation\n-\n-Don't poke the bear.\n-\n-The @code{g77} front end generates code\n-via the @code{gcc} back end.\n-\n-@cindex GNU Back End (GBE)\n-@cindex GBE\n-@cindex @code{gcc}, back end\n-@cindex back end, gcc\n-@cindex code generator\n-The @code{gcc} back end (GBE) is a large, complex\n-labyrinth of intricate code\n-written in a combination of the C language\n-and specialized languages internal to @code{gcc}.\n-\n-While the @emph{code} that implements the GBE\n-is written in a combination of languages,\n-the GBE itself is,\n-to the front end for a language like Fortran,\n-best viewed as a @emph{compiler}\n-that compiles its own, unique, language.\n-\n-The GBE's ``source'', then, is written in this language,\n-which consists primarily of\n-a combination of calls to GBE functions\n-and @dfn{tree} nodes\n-(which are, themselves, created\n-by calling GBE functions).\n-\n-So, the @code{g77} generates code by, in effect,\n-translating the Fortran code it reads\n-into a form ``written'' in the ``language''\n-of the @code{gcc} back end.\n-\n-@cindex GBEL\n-@cindex GNU Back End Language (GBEL)\n-This language will heretofore be referred to as @dfn{GBEL},\n-for GNU Back End Language.\n-\n-GBEL is an evolving language,\n-not fully specified in any published form\n-as of this writing.\n-It offers many facilities,\n-but its ``core'' facilities\n-are those that corresponding most directly\n-to those needed to support @code{gcc}\n-(compiling code written in GNU C).\n-\n-The @code{g77} Fortran Front End (FFE)\n-is designed and implemented\n-to navigate the currents and eddies\n-of ongoing GBEL and @code{gcc} development\n-while also delivering on the potential\n-of an integrated FFE\n-(as compared to using a converter like @code{f2c}\n-and feeding the output into @code{gcc}).\n-\n-Goals of the FFE's code-generation strategy include:\n-\n-@itemize @bullet\n-@item\n-High likelihood of generation of correct code,\n-or, failing that, producing a fatal diagnostic or crashing.\n-\n-@item\n-Generation of highly optimized code,\n-as directed by the user\n-via GBE-specific (versus @code{g77}-specific) constructs,\n-such as command-line options.\n-\n-@item\n-Fast overall (FFE plus GBE) compilation.\n-\n-@item\n-Preservation of source-level debugging information.\n-@end itemize\n-\n-The strategies historically, and currently, used by the FFE\n-to achieve these goals include:\n-\n-@itemize @bullet\n-@item\n-Use of GBEL constructs that most faithfully encapsulate\n-the semantics of Fortran.\n-\n-@item\n-Avoidance of GBEL constructs that are so rarely used,\n-or limited to use in specialized situations not related to Fortran,\n-that their reliability and performance has not yet been established\n-as sufficient for use by the FFE.\n-\n-@item\n-Flexible design, to readily accommodate changes to specific\n-code-generation strategies, perhaps governed by command-line options.\n-@end itemize\n-\n-@cindex Bear-poking\n-@cindex Poking the bear\n-``Don't poke the bear'' somewhat summarizes the above strategies.\n-The GBE is the bear.\n-The FFE is designed and implemented to avoid poking it\n-in ways that are likely to just annoy it.\n-The FFE usually either tackles it head-on,\n-or avoids treating it in ways dissimilar to how\n-the @code{gcc} front end treats it.\n-\n-For example, the FFE uses the native array facility in the back end\n-instead of the lower-level pointer-arithmetic facility\n-used by @code{gcc} when compiling @code{f2c} output).\n-Theoretically, this presents more opportunities for optimization,\n-faster compile times,\n-and the production of more faithful debugging information.\n-These benefits were not, however, immediately realized,\n-mainly because @code{gcc} itself makes little or no use\n-of the native array facility.\n-\n-Complex arithmetic is a case study of the evolution of this strategy.\n-When originally implemented,\n-the GBEL had just evolved its own native complex-arithmetic facility,\n-so the FFE took advantage of that.\n-\n-When porting @code{g77} to 64-bit systems,\n-it was discovered that the GBE didn't really\n-implement its native complex-arithmetic facility properly.\n-\n-The short-term solution was to rewrite the FFE\n-to instead use the lower-level facilities\n-that'd be used by @code{gcc}-compiled code\n-(assuming that code, itself, didn't use the native complex type\n-provided, as an extension, by @code{gcc}),\n-since these were known to work,\n-and, in any case, if shown to not work,\n-would likely be rapidly fixed\n-(since they'd likely not work for vanilla C code in similar circumstances).\n-\n-However, the rewrite accommodated the original, native approach as well\n-by offering a command-line option to select it over the emulated approach.\n-This allowed users, and especially GBE maintainers, to try out\n-fixes to complex-arithmetic support in the GBE\n-while @code{g77} continued to default to compiling more code correctly,\n-albeit producing (typically) slower executables.\n-\n-As of April 1999, it appeared that the last few bugs\n-in the GBE's support of its native complex-arithmetic facility\n-were worked out.\n-The FFE was changed back to default to using that native facility,\n-leaving emulation as an option.\n-\n-Later during the release cycle\n-(which was called EGCS 1.2, but soon became GCC 2.95),\n-bugs in the native facility were found.\n-Reactions among various people included\n-``the last thing we should do is change the default back'',\n-``we must change the default back'',\n-and ``let's figure out whether we can narrow down the bugs to\n-few enough cases to allow the now-months-long-tested default\n-to remain the same''.\n-The latter viewpoint won that particular time.\n-The bugs exposed other concerns regarding ABI compliance\n-when the ABI specified treatment of complex data as different\n-from treatment of what Fortran and GNU C consider the equivalent\n-aggregation (structure) of real (or float) pairs.\n-\n-Other Fortran constructs---arrays, character strings,\n-complex division, @code{COMMON} and @code{EQUIVALENCE} aggregates,\n-and so on---involve issues similar to those pertaining to complex arithmetic.\n-\n-So, it is possible that the history\n-of how the FFE handled complex arithmetic\n-will be repeated, probably in modified form\n-(and hopefully over shorter timeframes),\n-for some of these other facilities.\n-\n-@node Two-pass Design\n-@section Two-pass Design\n-\n-The FFE does not tell the GBE anything about a program unit\n-until after the last statement in that unit has been parsed.\n-(A program unit is a Fortran concept that corresponds, in the C world,\n-mostly closely to functions definitions in ISO C.\n-That is, a program unit in Fortran is like a top-level function in C.\n-Nested functions, found among the extensions offered by GNU C,\n-correspond roughly to Fortran's statement functions.)\n-\n-So, while parsing the code in a program unit,\n-the FFE saves up all the information\n-on statements, expressions, names, and so on,\n-until it has seen the last statement.\n-\n-At that point, the FFE revisits the saved information\n-(in what amounts to a second @dfn{pass} over the program unit)\n-to perform the actual translation of the program unit into GBEL,\n-ultimating in the generation of assembly code for it.\n-\n-Some lookahead is performed during this second pass,\n-so the FFE could be viewed as a ``two-plus-pass'' design.\n-\n-@menu\n-* Two-pass Code::\n-* Why Two Passes::\n-@end menu\n-\n-@node Two-pass Code\n-@subsection Two-pass Code\n-\n-Most of the code that turns the first pass (parsing)\n-into a second pass for code generation\n-is in @file{@value{path-g77}/std.c}.\n-\n-It has external functions,\n-called mainly by siblings in @file{@value{path-g77}/stc.c},\n-that record the information on statements and expressions\n-in the order they are seen in the source code.\n-These functions save that information.\n-\n-It also has an external function that revisits that information,\n-calling the siblings in @file{@value{path-g77}/ste.c},\n-which handles the actual code generation\n-(by generating GBEL code,\n-that is, by calling GBE routines\n-to represent and specify expressions, statements, and so on).\n-\n-@node Why Two Passes\n-@subsection Why Two Passes\n-\n-The need for two passes was not immediately evident\n-during the design and implementation of the code in the FFE\n-that was to produce GBEL.\n-Only after a few kludges,\n-to handle things like incorrectly-guessed @code{ASSIGN} label nature,\n-had been implemented,\n-did enough evidence pile up to make it clear\n-that @file{std.c} had to be introduced to intercept,\n-save, then revisit as part of a second pass,\n-the digested contents of a program unit.\n-\n-Other such missteps have occurred during the evolution of the FFE,\n-because of the different goals of the FFE and the GBE.\n-\n-Because the GBE's original, and still primary, goal\n-was to directly support the GNU C language,\n-the GBEL, and the GBE itself,\n-requires more complexity\n-on the part of most front ends\n-than it requires of @code{gcc}'s.\n-\n-For example,\n-the GBEL offers an interface that permits the @code{gcc} front end\n-to implement most, or all, of the language features it supports,\n-without the front end having to\n-make use of non-user-defined variables.\n-(It's almost certainly the case that all of K&R C,\n-and probably ANSI C as well,\n-is handled by the @code{gcc} front end\n-without declaring such variables.)\n-\n-The FFE, on the other hand, must resort to a variety of ``tricks''\n-to achieve its goals.\n-\n-Consider the following C code:\n-\n-@smallexample\n-int\n-foo (int a, int b)\n-@{\n-  int c = 0;\n-\n-  if ((c = bar (c)) == 0)\n-    goto done;\n-\n-  quux (c << 1);\n-\n-done:\n-  return c;\n-@}\n-@end smallexample\n-\n-Note what kinds of objects are declared, or defined, before their use,\n-and before any actual code generation involving them\n-would normally take place:\n-\n-@itemize @bullet\n-@item\n-Return type of function\n-\n-@item\n-Entry point(s) of function\n-\n-@item\n-Dummy arguments\n-\n-@item\n-Variables\n-\n-@item\n-Initial values for variables\n-@end itemize\n-\n-Whereas, the following items can, and do,\n-suddenly appear ``out of the blue'' in C:\n-\n-@itemize @bullet\n-@item\n-Label references\n-\n-@item\n-Function references\n-@end itemize\n-\n-Not surprisingly, the GBE faithfully permits the latter set of items\n-to be ``discovered'' partway through GBEL ``programs'',\n-just as they are permitted to in C.\n-\n-Yet, the GBE has tended, at least in the past,\n-to be reticent to fully support similar ``late'' discovery\n-of items in the former set.\n-\n-This makes Fortran a poor fit for the ``safe'' subset of GBEL.\n-Consider:\n-\n-@smallexample\n-      FUNCTION X (A, ARRAY, ID1)\n-      CHARACTER*(*) A\n-      DOUBLE PRECISION X, Y, Z, TMP, EE, PI\n-      REAL ARRAY(ID1*ID2)\n-      COMMON ID2\n-      EXTERNAL FRED\n-\n-      ASSIGN 100 TO J\n-      CALL FOO (I)\n-      IF (I .EQ. 0) PRINT *, A(0)\n-      GOTO 200\n-\n-      ENTRY Y (Z)\n-      ASSIGN 101 TO J\n-200   PRINT *, A(1)\n-      READ *, TMP\n-      GOTO J\n-100   X = TMP * EE\n-      RETURN\n-101   Y = TMP * PI\n-      CALL FRED\n-      DATA EE, PI /2.71D0, 3.14D0/\n-      END\n-@end smallexample\n-\n-Here are some observations about the above code,\n-which, while somewhat contrived,\n-conforms to the FORTRAN 77 and Fortran 90 standards:\n-\n-@itemize @bullet\n-@item\n-The return type of function @samp{X} is not known\n-until the @samp{DOUBLE PRECISION} line has been parsed.\n-\n-@item\n-Whether @samp{A} is a function or a variable\n-is not known until the @samp{PRINT *, A(0)} statement\n-has been parsed.\n-\n-@item\n-The bounds of the array of argument @samp{ARRAY}\n-depend on a computation involving\n-the subsequent argument @samp{ID1}\n-and the blank-common member @samp{ID2}.\n-\n-@item\n-Whether @samp{Y} and @samp{Z} are local variables,\n-additional function entry points,\n-or dummy arguments to additional entry points\n-is not known\n-until the @code{ENTRY} statement is parsed.\n-\n-@item\n-Similarly, whether @samp{TMP} is a local variable is not known\n-until the @samp{READ *, TMP} statement is parsed.\n-\n-@item\n-The initial values for @samp{EE} and @samp{PI}\n-are not known until after the @code{DATA} statement is parsed.\n-\n-@item\n-Whether @samp{FRED} is a function returning type @code{REAL}\n-or a subroutine\n-(which can be thought of as returning type @code{void}\n-@emph{or}, to support alternate returns in a simple way,\n-type @code{int})\n-is not known\n-until the @samp{CALL FRED} statement is parsed.\n-\n-@item\n-Whether @samp{100} is a @code{FORMAT} label\n-or the label of an executable statement\n-is not known\n-until the @samp{X =} statement is parsed.\n-(These two types of labels get @emph{very} different treatment,\n-especially when @code{ASSIGN}'ed.)\n-\n-@item\n-That @samp{J} is a local variable is not known\n-until the first @code{ASSIGN} statement is parsed.\n-(This happens @emph{after} executable code has been seen.)\n-@end itemize\n-\n-Very few of these ``discoveries''\n-can be accommodated by the GBE as it has evolved over the years.\n-The GBEL doesn't support several of them,\n-and those it might appear to support\n-don't always work properly,\n-especially in combination with other GBEL and GBE features,\n-as implemented in the GBE.\n-\n-(Had the GBE and its GBEL originally evolved to support @code{g77},\n-the shoe would be on the other foot, so to speak---most, if not all,\n-of the above would be directly supported by the GBEL,\n-and a few C constructs would probably not, as they are in reality,\n-be supported.\n-Both this mythical, and today's real, GBE caters to its GBEL\n-by, sometimes, scrambling around, cleaning up after itself---after\n-discovering that assumptions it made earlier during code generation\n-are incorrect.\n-That's not a great design, since it indicates significant code\n-paths that might be rarely tested but used in some key production\n-environments.)\n-\n-So, the FFE handles these discrepancies---between the order in which\n-it discovers facts about the code it is compiling,\n-and the order in which the GBEL and GBE support such discoveries---by\n-performing what amounts to two\n-passes over each program unit.\n-\n-(A few ambiguities can remain at that point,\n-such as whether, given @samp{EXTERNAL BAZ}\n-and no other reference to @samp{BAZ} in the program unit,\n-it is a subroutine, a function, or a block-data---which, in C-speak,\n-governs its declared return type.\n-Fortunately, these distinctions are easily finessed\n-for the procedure, library, and object-file interfaces\n-supported by @code{g77}.)\n-\n-@node Challenges Posed\n-@section Challenges Posed\n-\n-Consider the following Fortran code, which uses various extensions\n-(including some to Fortran 90):\n-\n-@smallexample\n-SUBROUTINE X(A)\n-CHARACTER*(*) A\n-COMPLEX CFUNC\n-INTEGER*2 CLOCKS(200)\n-INTEGER IFUNC\n-\n-CALL SYSTEM_CLOCK (CLOCKS (IFUNC (CFUNC ('('//A//')'))))\n-@end smallexample\n-\n-The above poses the following challenges to any Fortran compiler\n-that uses run-time interfaces, and a run-time library, roughly similar\n-to those used by @code{g77}:\n-\n-@itemize @bullet\n-@item\n-Assuming the library routine that supports @code{SYSTEM_CLOCK}\n-expects to set an @code{INTEGER*4} variable via its @code{COUNT} argument,\n-the compiler must make available to it a temporary variable of that type.\n-\n-@item\n-Further, after the @code{SYSTEM_CLOCK} library routine returns,\n-the compiler must ensure that the temporary variable it wrote\n-is copied into the appropriate element of the @samp{CLOCKS} array.\n-(This assumes the compiler doesn't just reject the code,\n-which it should if it is compiling under some kind of a ``strict'' option.)\n-\n-@item\n-To determine the correct index into the @samp{CLOCKS} array,\n-(putting aside the fact that the index, in this particular case,\n-need not be computed until after\n-the @code{SYSTEM_CLOCK} library routine returns),\n-the compiler must ensure that the @code{IFUNC} function is called.\n-\n-That requires evaluating its argument,\n-which requires, for @code{g77}\n-(assuming @code{-ff2c} is in force),\n-reserving a temporary variable of type @code{COMPLEX}\n-for use as a repository for the return value\n-being computed by @samp{CFUNC}.\n-\n-@item\n-Before invoking @samp{CFUNC},\n-is argument must be evaluated,\n-which requires allocating, at run time,\n-a temporary large enough to hold the result of the concatenation,\n-as well as actually performing the concatenation.\n-\n-@item\n-The large temporary needed during invocation of @code{CFUNC}\n-should, ideally, be deallocated\n-(or, at least, left to the GBE to dispose of, as it sees fit)\n-as soon as @code{CFUNC} returns,\n-which means before @code{IFUNC} is called\n-(as it might need a lot of dynamically allocated memory).\n-@end itemize\n-\n-@code{g77} currently doesn't support all of the above,\n-but, so that it might someday, it has evolved to handle\n-at least some of the above requirements.\n-\n-Meeting the above requirements is made more challenging\n-by conforming to the requirements of the GBEL/GBE combination.\n-\n-@node Transforming Statements\n-@section Transforming Statements\n-\n-Most Fortran statements are given their own block,\n-and, for temporary variables they might need, their own scope.\n-(A block is what distinguishes @samp{@{ foo (); @}}\n-from just @samp{foo ();} in C.\n-A scope is included with every such block,\n-providing a distinct name space for local variables.)\n-\n-Label definitions for the statement precede this block,\n-so @samp{10 PRINT *, I} is handled more like\n-@samp{fl10: @{ @dots{} @}} than @samp{@{ fl10: @dots{} @}}\n-(where @samp{fl10} is just a notation meaning ``Fortran Label 10''\n-for the purposes of this document).\n-\n-@menu\n-* Statements Needing Temporaries::\n-* Transforming DO WHILE::\n-* Transforming Iterative DO::\n-* Transforming Block IF::\n-* Transforming SELECT CASE::\n-@end menu\n-\n-@node Statements Needing Temporaries\n-@subsection Statements Needing Temporaries\n-\n-Any temporaries needed during, but not beyond,\n-execution of a Fortran statement,\n-are made local to the scope of that statement's block.\n-\n-This allows the GBE to share storage for these temporaries\n-among the various statements without the FFE\n-having to manage that itself.\n-\n-(The GBE could, of course, decide to optimize \n-management of these temporaries.\n-For example, it could, theoretically,\n-schedule some of the computations involving these temporaries\n-to occur in parallel.\n-More practically, it might leave the storage for some temporaries\n-``live'' beyond their scopes, to reduce the number of\n-manipulations of the stack pointer at run time.)\n-\n-Temporaries needed across distinct statement boundaries usually\n-are associated with Fortran blocks (such as @code{DO}/@code{END DO}).\n-(Also, there might be temporaries not associated with blocks at all---these\n-would be in the scope of the entire program unit.)\n-\n-Each Fortran block @emph{should} get its own block/scope in the GBE.\n-This is best, because it allows temporaries to be more naturally handled.\n-However, it might pose problems when handling labels\n-(in particular, when they're the targets of @code{GOTO}s outside the Fortran\n-block), and generally just hassling with replicating\n-parts of the @code{gcc} front end\n-(because the FFE needs to support\n-an arbitrary number of nested back-end blocks\n-if each Fortran block gets one).\n-\n-So, there might still be a need for top-level temporaries, whose\n-``owning'' scope is that of the containing procedure.\n-\n-Also, there seems to be problems declaring new variables after\n-generating code (within a block) in the back end, leading to, e.g.,\n-@samp{label not defined before binding contour} or similar messages,\n-when compiling with @samp{-fstack-check} or\n-when compiling for certain targets.\n-\n-Because of that, and because sometimes these temporaries are not\n-discovered until in the middle of of generating code for an expression\n-statement (as in the case of the optimization for @samp{X**I}),\n-it seems best to always\n-pre-scan all the expressions that'll be expanded for a block\n-before generating any of the code for that block.\n-\n-This pre-scan then handles discovering and declaring, to the back end,\n-the temporaries needed for that block.\n-\n-It's also important to treat distinct items in an I/O list as distinct\n-statements deserving their own blocks.\n-That's because there's a requirement\n-that each I/O item be fully processed before the next one,\n-which matters in cases like @samp{READ (*,*), I, A(I)}---the\n-element of @samp{A} read in the second item\n-@emph{must} be determined from the value\n-of @samp{I} read in the first item.\n-\n-@node Transforming DO WHILE\n-@subsection Transforming DO WHILE\n-\n-@samp{DO WHILE(expr)} @emph{must} be implemented\n-so that temporaries needed to evaluate @samp{expr}\n-are generated just for the test, each time.\n-\n-Consider how @samp{DO WHILE (A//B .NE. 'END'); @dots{}; END DO} is transformed:\n-\n-@smallexample\n-for (;;)\n-  @{\n-    int temp0;\n-\n-    @{\n-      char temp1[large];\n-\n-      libg77_catenate (temp1, a, b);\n-      temp0 = libg77_ne (temp1, 'END');\n-    @}\n-\n-    if (! temp0)\n-      break;\n-\n-    @dots{}\n-  @}\n-@end smallexample\n-\n-In this case, it seems like a time/space tradeoff\n-between allocating and deallocating @samp{temp1} for each iteration\n-and allocating it just once for the entire loop.\n-\n-However, if @samp{temp1} is allocated just once for the entire loop,\n-it could be the wrong size for subsequent iterations of that loop\n-in cases like @samp{DO WHILE (A(I:J)//B .NE. 'END')},\n-because the body of the loop might modify @samp{I} or @samp{J}.\n-\n-So, the above implementation is used,\n-though a more optimal one can be used\n-in specific circumstances.\n-\n-@node Transforming Iterative DO\n-@subsection Transforming Iterative DO\n-\n-An iterative @code{DO} loop\n-(one that specifies an iteration variable)\n-is required by the Fortran standards\n-to be implemented as though an iteration count\n-is computed before entering the loop body,\n-and that iteration count used to determine\n-the number of times the loop body is to be performed\n-(assuming the loop isn't cut short via @code{GOTO} or @code{EXIT}).\n-\n-The FFE handles this by allocating a temporary variable\n-to contain the computed number of iterations.\n-Since this variable must be in a scope that includes the entire loop,\n-a GBEL block is created for that loop,\n-and the variable declared as belonging to the scope of that block.\n-\n-@node Transforming Block IF\n-@subsection Transforming Block IF\n-\n-Consider:\n-\n-@smallexample\n-SUBROUTINE X(A,B,C)\n-CHARACTER*(*) A, B, C\n-LOGICAL LFUNC\n-\n-IF (LFUNC (A//B)) THEN\n-  CALL SUBR1\n-ELSE IF (LFUNC (A//C)) THEN\n-  CALL SUBR2\n-ELSE\n-  CALL SUBR3\n-END\n-@end smallexample\n-\n-The arguments to the two calls to @samp{LFUNC}\n-require dynamic allocation (at run time),\n-but are not required during execution of the @code{CALL} statements.\n-\n-So, the scopes of those temporaries must be within blocks inside\n-the block corresponding to the Fortran @code{IF} block.\n-\n-This cannot be represented ``naturally''\n-in vanilla C, nor in GBEL.\n-The @code{if}, @code{elseif}, @code{else},\n-and @code{endif} constructs\n-provided by both languages must,\n-for a given @code{if} block,\n-share the same C/GBE block.\n-\n-Therefore, any temporaries needed during evaluation of @samp{expr}\n-while executing @samp{ELSE IF(expr)}\n-must either have been predeclared\n-at the top of the corresponding @code{IF} block,\n-or declared within a new block for that @code{ELSE IF}---a block that,\n-since it cannot contain the @code{else} or @code{else if} itself\n-(due to the above requirement),\n-actually implements the rest of the @code{IF} block's\n-@code{ELSE IF} and @code{ELSE} statements\n-within an inner block.\n-\n-The FFE takes the latter approach.\n-\n-@node Transforming SELECT CASE\n-@subsection Transforming SELECT CASE\n-\n-@code{SELECT CASE} poses a few interesting problems for code generation,\n-if efficiency and frugal stack management are important.\n-\n-Consider @samp{SELECT CASE (I('PREFIX'//A))},\n-where @samp{A} is @code{CHARACTER*(*)}.\n-In a case like this---basically,\n-in any case where largish temporaries are needed\n-to evaluate the expression---those temporaries should\n-not be ``live'' during execution of any of the @code{CASE} blocks.\n-\n-So, evaluation of the expression is best done within its own block,\n-which in turn is within the @code{SELECT CASE} block itself\n-(which contains the code for the CASE blocks as well,\n-though each within their own block).\n-\n-Otherwise, we'd have the rough equivalent of this pseudo-code:\n-\n-@smallexample\n-@{\n-  char temp[large];\n-\n-  libg77_catenate (temp, 'prefix', a);\n-\n-  switch (i (temp))\n-    @{\n-    case 0:\n-      @dots{}\n-    @}\n-@}\n-@end smallexample\n-\n-And that would leave temp[large] in scope during the CASE blocks\n-(although a clever back end *could* see that it isn't referenced\n-in them, and thus free that temp before executing the blocks).\n-\n-So this approach is used instead:\n-\n-@smallexample\n-@{\n-  int temp0;\n-\n-  @{\n-    char temp1[large];\n-\n-    libg77_catenate (temp1, 'prefix', a);\n-    temp0 = i (temp1);\n-  @}\n-\n-  switch (temp0)\n-    @{\n-    case 0:\n-      @dots{}\n-    @}\n-@}\n-@end smallexample\n-\n-Note how @samp{temp1} goes out of scope before starting the switch,\n-thus making it easy for a back end to free it.\n-\n-The problem @emph{that} solution has, however,\n-is with @samp{SELECT CASE('prefix'//A)}\n-(which is currently not supported).\n-\n-Unless the GBEL is extended to support arbitrarily long character strings\n-in its @code{case} facility,\n-the FFE has to implement @code{SELECT CASE} on @code{CHARACTER}\n-(probably excepting @code{CHARACTER*1})\n-using a cascade of\n-@code{if}, @code{elseif}, @code{else}, and @code{endif} constructs\n-in GBEL.\n-\n-To prevent the (potentially large) temporary,\n-needed to hold the selected expression itself (@samp{'prefix'//A}),\n-from being in scope during execution of the @code{CASE} blocks,\n-two approaches are available:\n-\n-@itemize @bullet\n-@item\n-Pre-evaluate all the @code{CASE} tests,\n-producing an integer ordinal that is used,\n-a la @samp{temp0} in the earlier example,\n-as if @samp{SELECT CASE(temp0)} had been written.\n-\n-Each corresponding @code{CASE} is replaced with @samp{CASE(@var{i})},\n-where @var{i} is the ordinal for that case,\n-determined while, or before,\n-generating the cascade of @code{if}-related constructs\n-to cope with @code{CHARACTER} selection.\n-\n-@item\n-Make @samp{temp0} above just\n-large enough to hold the longest @code{CASE} string\n-that'll actually be compared against the expression\n-(in this case, @samp{'prefix'//A}).\n-\n-Since that length must be constant\n-(because @code{CASE} expressions are all constant),\n-it won't be so large,\n-and, further, @samp{temp1} need not be dynamically allocated,\n-since normal @code{CHARACTER} assignment can be used\n-into the fixed-length @samp{temp0}.\n-@end itemize\n-\n-Both of these solutions require @code{SELECT CASE} implementation\n-to be changed so all the corresponding @code{CASE} statements\n-are seen during the actual code generation for @code{SELECT CASE}.\n-\n-@node Transforming Expressions\n-@section Transforming Expressions\n-\n-The interactions between statements, expressions, and subexpressions\n-at program run time can be viewed as:\n-\n-@smallexample\n-@var{action}(@var{expr})\n-@end smallexample\n-\n-Here, @var{action} is the series of steps\n-performed to effect the statement,\n-and @var{expr} is the expression\n-whose value is used by @var{action}.\n-\n-Expanding the above shows a typical order of events at run time:\n-\n-@smallexample\n-Evaluate @var{expr}\n-Perform @var{action}, using result of evaluation of @var{expr}\n-Clean up after evaluating @var{expr}\n-@end smallexample\n-\n-So, if evaluating @var{expr} requires allocating memory,\n-that memory can be freed before performing @var{action}\n-only if it is not needed to hold the result of evaluating @var{expr}.\n-Otherwise, it must be freed no sooner than\n-after @var{action} has been performed.\n-\n-The above are recursive definitions,\n-in the sense that they apply to subexpressions of @var{expr}.\n-\n-That is, evaluating @var{expr} involves\n-evaluating all of its subexpressions,\n-performing the @var{action} that computes the\n-result value of @var{expr},\n-then cleaning up after evaluating those subexpressions.\n-\n-The recursive nature of this evaluation is implemented\n-via recursive-descent transformation of the top-level statements,\n-their expressions, @emph{their} subexpressions, and so on.\n-\n-However, that recursive-descent transformation is,\n-due to the nature of the GBEL,\n-focused primarily on generating a @emph{single} stream of code\n-to be executed at run time.\n-\n-Yet, from the above, it's clear that multiple streams of code\n-must effectively be simultaneously generated\n-during the recursive-descent analysis of statements.\n-\n-The primary stream implements the primary @var{action} items,\n-while at least two other streams implement\n-the evaluation and clean-up items.\n-\n-Requirements imposed by expressions include:\n-\n-@itemize @bullet\n-@item\n-Whether the caller needs to have a temporary ready\n-to hold the value of the expression.\n-\n-@item\n-Other stuff???\n-@end itemize\n-\n-@node Internal Naming Conventions\n-@section Internal Naming Conventions\n-\n-Names exported by FFE modules have the following (regular-expression) forms.\n-Note that all names beginning @code{ffe@var{mod}} or @code{FFE@var{mod}},\n-where @var{mod} is lowercase or uppercase alphanumerics, respectively,\n-are exported by the module @code{ffe@var{mod}},\n-with the source code doing the exporting in @file{@var{mod}.h}.\n-(Usually, the source code for the implementation is in @file{@var{mod}.c}.)\n-\n-Identifiers that don't fit the following forms\n-are not considered exported,\n-even if they are according to the C language.\n-(For example, they might be made available to other modules\n-solely for use within expansions of exported macros,\n-not for use within any source code in those other modules.)\n-\n-@table @code\n-@item ffe@var{mod}\n-The single typedef exported by the module.\n-\n-@item FFE@var{umod}_[A-Z][A-Z0-9_]*\n-(Where @var{umod} is the uppercase for of @var{mod}.)\n-\n-A @code{#define} or @code{enum} constant of the type @code{ffe@var{mod}}.\n-\n-@item ffe@var{mod}[A-Z][A-Z][a-z0-9]*\n-A typedef exported by the module.\n-\n-The portion of the identifier after @code{ffe@var{mod}} is\n-referred to as @code{ctype}, a capitalized (mixed-case) form\n-of @code{type}.\n-\n-@item FFE@var{umod}_@var{type}[A-Z][A-Z0-9_]*[A-Z0-9]?\n-(Where @var{umod} is the uppercase for of @var{mod}.)\n-\n-A @code{#define} or @code{enum} constant of the type\n-@code{ffe@var{mod}@var{type}},\n-where @var{type} is the lowercase form of @var{ctype}\n-in an exported typedef.\n-\n-@item ffe@var{mod}_@var{value}\n-A function that does or returns something,\n-as described by @var{value} (see below).\n-\n-@item ffe@var{mod}_@var{value}_@var{input}\n-A function that does or returns something based\n-primarily on the thing described by @var{input} (see below).\n-@end table\n-\n-Below are names used for @var{value} and @var{input},\n-along with their definitions.\n-\n-@table @code\n-@item col\n-A column number within a line (first column is number 1).\n-\n-@item file\n-An encapsulation of a file's name.\n-\n-@item find\n-Looks up an instance of some type that matches specified criteria,\n-and returns that, even if it has to create a new instance or\n-crash trying to find it (as appropriate).\n-\n-@item initialize\n-Initializes, usually a module.  No type.\n-\n-@item int\n-A generic integer of type @code{int}.\n-\n-@item is\n-A generic integer that contains a true (nonzero) or false (zero) value.\n-\n-@item len\n-A generic integer that contains the length of something.\n-\n-@item line\n-A line number within a source file,\n-or a global line number.\n-\n-@item lookup\n-Looks up an instance of some type that matches specified criteria,\n-and returns that, or returns nil.\n-\n-@item name\n-A @code{text} that points to a name of something.\n-\n-@item new\n-Makes a new instance of the indicated type.\n-Might return an existing one if appropriate---if so,\n-similar to @code{find} without crashing.\n-\n-@item pt\n-Pointer to a particular character (line, column pairs)\n-in the input file (source code being compiled).\n-\n-@item run\n-Performs some herculean task.  No type.\n-\n-@item terminate\n-Terminates, usually a module.  No type.\n-\n-@item text\n-A @code{char *} that points to generic text.\n-@end table"}, {"sha": "167837b461f30b12ee788dcee97d31dfb475dd76", "filename": "gcc/f/fini.c", "status": "removed", "additions": 0, "deletions": 772, "changes": 772, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Ffini.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Ffini.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Ffini.c?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,772 +0,0 @@\n-/* fini.c\n-   Copyright (C) 1995 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.  */\n-\n-#define USE_BCONFIG\n-\n-#include \"proj.h\"\n-#include \"malloc.h\"\n-\n-#undef MAXNAMELEN\n-#define MAXNAMELEN 100\n-\n-typedef struct _name_ *name;\n-\n-struct _name_\n-  {\n-    name next;\n-    name previous;\n-    name next_alpha;\n-    name previous_alpha;\n-    int namelen;\n-    int kwlen;\n-    char kwname[MAXNAMELEN];\n-    char name_uc[MAXNAMELEN];\n-    char name_lc[MAXNAMELEN];\n-    char name_ic[MAXNAMELEN];\n-  };\n-\n-struct _name_root_\n-  {\n-    name first;\n-    name last;\n-  };\n-\n-struct _name_alpha_\n-  {\n-    name ign1;\n-    name ign2;\n-    name first;\n-    name last;\n-  };\n-\n-static FILE *in;\n-static FILE *out;\n-static char prefix[32];\n-static char postfix[32];\n-static char storage[32];\n-static const char *const xspaces[]\n-=\n-{\n-  \"\",\t\t\t\t/* 0 */\n-  \" \",\t\t\t\t/* 1 */\n-  \"  \",\t\t\t\t/* 2 */\n-  \"   \",\t\t\t/* 3 */\n-  \"    \",\t\t\t/* 4 */\n-  \"     \",\t\t\t/* 5 */\n-  \"      \",\t\t\t/* 6 */\n-  \"       \",\t\t\t/* 7 */\n-  \"\\t\",\t\t\t\t/* 8 */\n-  \"\\t \",\t\t\t/* 9 */\n-  \"\\t  \",\t\t\t/* 10 */\n-  \"\\t   \",\t\t\t/* 11 */\n-  \"\\t    \",\t\t\t/* 12 */\n-  \"\\t     \",\t\t\t/* 13 */\n-  \"\\t      \",\t\t\t/* 14 */\n-  \"\\t       \",\t\t\t/* 15 */\n-  \"\\t\\t\",\t\t\t/* 16 */\n-  \"\\t\\t \",\t\t\t/* 17 */\n-  \"\\t\\t  \",\t\t\t/* 18 */\n-  \"\\t\\t   \",\t\t\t/* 19 */\n-  \"\\t\\t    \",\t\t\t/* 20 */\n-  \"\\t\\t     \",\t\t\t/* 21 */\n-  \"\\t\\t      \",\t\t\t/* 22 */\n-  \"\\t\\t       \",\t\t/* 23 */\n-  \"\\t\\t\\t\",\t\t\t/* 24 */\n-  \"\\t\\t\\t \",\t\t\t/* 25 */\n-  \"\\t\\t\\t  \",\t\t\t/* 26 */\n-  \"\\t\\t\\t   \",\t\t\t/* 27 */\n-  \"\\t\\t\\t    \",\t\t\t/* 28 */\n-  \"\\t\\t\\t     \",\t\t/* 29 */\n-  \"\\t\\t\\t      \",\t\t/* 30 */\n-  \"\\t\\t\\t       \",\t\t/* 31 */\n-  \"\\t\\t\\t\\t\",\t\t\t/* 32 */\n-  \"\\t\\t\\t\\t \",\t\t\t/* 33 */\n-  \"\\t\\t\\t\\t  \",\t\t\t/* 34 */\n-  \"\\t\\t\\t\\t   \",\t\t/* 35 */\n-  \"\\t\\t\\t\\t    \",\t\t/* 36 */\n-  \"\\t\\t\\t\\t     \",\t\t/* 37 */\n-  \"\\t\\t\\t\\t      \",\t\t/* 38 */\n-  \"\\t\\t\\t\\t       \",\t\t/* 39 */\n-  \"\\t\\t\\t\\t\\t\",\t\t\t/* 40 */\n-  \"\\t\\t\\t\\t\\t \",\t\t/* 41 */\n-  \"\\t\\t\\t\\t\\t  \",\t\t/* 42 */\n-  \"\\t\\t\\t\\t\\t   \",\t\t/* 43 */\n-  \"\\t\\t\\t\\t\\t    \",\t\t/* 44 */\n-  \"\\t\\t\\t\\t\\t     \",\t\t/* 45 */\n-  \"\\t\\t\\t\\t\\t      \",\t\t/* 46 */\n-  \"\\t\\t\\t\\t\\t       \",\t\t/* 47 */\n-  \"\\t\\t\\t\\t\\t\\t\",\t\t/* 48 */\n-  \"\\t\\t\\t\\t\\t\\t \",\t\t/* 49 */\n-  \"\\t\\t\\t\\t\\t\\t  \",\t\t/* 50 */\n-  \"\\t\\t\\t\\t\\t\\t   \",\t\t/* 51 */\n-  \"\\t\\t\\t\\t\\t\\t    \",\t\t/* 52 */\n-  \"\\t\\t\\t\\t\\t\\t     \",\t\t/* 53 */\n-  \"\\t\\t\\t\\t\\t\\t      \",\t\t/* 54 */\n-  \"\\t\\t\\t\\t\\t\\t       \",\t/* 55 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\",\t\t/* 56 */\n-  \"\\t\\t\\t\\t\\t\\t\\t \",\t\t/* 57 */\n-  \"\\t\\t\\t\\t\\t\\t\\t  \",\t\t/* 58 */\n-  \"\\t\\t\\t\\t\\t\\t\\t   \",\t\t/* 59 */\n-  \"\\t\\t\\t\\t\\t\\t\\t    \",\t\t/* 60 */\n-  \"\\t\\t\\t\\t\\t\\t\\t     \",\t/* 61 */\n-  \"\\t\\t\\t\\t\\t\\t\\t      \",\t/* 62 */\n-  \"\\t\\t\\t\\t\\t\\t\\t       \",\t/* 63 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\",\t\t/* 64 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t \",\t\t/* 65 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t  \",\t\t/* 66 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t   \",\t/* 67 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t    \",\t/* 68 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t     \",\t/* 69 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t      \",\t/* 70 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t       \",\t/* 71 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\",\t\t/* 72 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t \",\t/* 73 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t  \",\t/* 74 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t   \",\t/* 75 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t    \",\t/* 76 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t     \",\t/* 77 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t      \",\t/* 78 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t       \",\t/* 79 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\",\t/* 80 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \",\t/* 81 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \",\t/* 82 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \",\t/* 83 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    \",\t/* 84 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     \",\t/* 85 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t      \",\t/* 86 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       \",/* 87 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\",\t/* 88 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \",\t/* 89 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \",\t/* 90 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \",\t/* 91 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    \",\t/* 92 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     \",/* 93 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t      \",\t/* 94 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       \",\t/* 95 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\",\t/* 96 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \",\t/* 97 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \",\t/* 98 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \",/* 99 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    \",\t/* 100 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     \",\t/* 101 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t      \",\t/* 102 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       \",\t/* 103 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\",\t/* 104 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \",/* 105 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \",\t/* 106 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \",\t/* 107 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    \",\t/* 108 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     \",\t/* 109 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t      \",\t/* 110 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       \",\t/* 111 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\",\t/* 112 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \",\t/* 113 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \",\t/* 114 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \",\t/* 115 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    \",\t/* 116 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     \",\t/* 117 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t      \",\t/* 118 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       \",\t/* 119 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\",\t/* 120 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \",\t/* 121 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \",\t/* 122 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \",\t/* 123 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    \",\t/* 124 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     \",\t/* 125 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t      \",\t/* 126 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       \",\t/* 127 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\",\t/* 128 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \",\t/* 129 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \",\t/* 130 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \",\t/* 131 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    \",\t/* 132 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     \",\t/* 133 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t      \",\t/* 134 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       \",\t/* 135 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\",\t/* 136 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \",\t/* 137 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \",\t/* 138 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \",\t/* 139 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    \",\t/* 140 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     \",\t/* 141 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t      \",\t/* 142 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       \",\t/* 143 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\",\t/* 144 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \",\t/* 145 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \",\t/* 146 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \",\t/* 147 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    \",\t/* 148 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     \",\t/* 149 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t      \",\t/* 150 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       \",\t/* 151 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\",\t/* 152 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \",\t/* 153 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \",\t/* 154 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \",\t/* 155 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    \",\t/* 156 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     \",\t/* 157 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t      \",\t/* 158 */\n-  \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       \",\t/* 159 */\n-};\n-\n-void testname (bool nested, int indent, name first, name last);\n-void testnames (bool nested, int indent, int len, name first, name last);\n-\n-int\n-main (int argc, char **argv)\n-{\n-  char buf[MAXNAMELEN];\n-  char last_buf[MAXNAMELEN];\n-  char kwname[MAXNAMELEN];\n-  char routine[32];\n-  char type[32];\n-  int i;\n-  int count;\n-  int len;\n-  struct _name_root_ names[200];\n-  struct _name_alpha_ names_alpha;\n-  name n;\n-  name newname;\n-  char *input_name;\n-  char *output_name;\n-  char *include_name;\n-  FILE *incl;\n-  int fixlengths;\n-  int total_length;\n-  int do_name;\t\t\t/* TRUE if token may be NAME. */\n-  int do_names;\t\t\t/* TRUE if token may be NAMES. */\n-  int cc;\n-  bool do_exit = FALSE;\n-\n-  last_buf[0] = '\\0';\n-  \n-  for (i = 0; ((size_t) i) < ARRAY_SIZE (names); ++i)\n-    {\t\t\t\t/* Initialize length/name ordered list roots. */\n-      names[i].first = (name) &names[i];\n-      names[i].last = (name) &names[i];\n-    }\n-  names_alpha.first = (name) &names_alpha;\t/* Initialize name order. */\n-  names_alpha.last = (name) &names_alpha;\n-\n-  if (argc != 4)\n-    {\n-      fprintf (stderr, \"Command form: fini input output-code output-include\\n\");\n-      return (1);\n-    }\n-\n-  input_name = argv[1];\n-  output_name = argv[2];\n-  include_name = argv[3];\n-\n-  in = fopen (input_name, \"r\");\n-  if (in == NULL)\n-    {\n-      fprintf (stderr, \"Cannot open \\\"%s\\\"\\n\", input_name);\n-      return (1);\n-    }\n-  out = fopen (output_name, \"w\");\n-  if (out == NULL)\n-    {\n-      fclose (in);\n-      fprintf (stderr, \"Cannot open \\\"%s\\\"\\n\", output_name);\n-      return (1);\n-    }\n-  incl = fopen (include_name, \"w\");\n-  if (incl == NULL)\n-    {\n-      fclose (in);\n-      fprintf (stderr, \"Cannot open \\\"%s\\\"\\n\", include_name);\n-      return (1);\n-    }\n-\n-  /* Get past the initial block-style comment (man, this parsing code is just\n-     _so_ lame, but I'm too lazy to improve it).  */\n-\n-  for (;;)\n-    {\n-      cc = getc (in);\n-      if (cc == '{')\n-\t{\n-\t  while (((cc = getc (in)) != '}') && (cc != EOF))\n-\t    ;\n-\t}\n-      else if (cc != EOF)\n-\t{\n-\t  while (((cc = getc (in)) != EOF) && (! ISALNUM (cc)))\n-\t    ;\n-\t  ungetc (cc, in);\n-\t  break;\n-\t}\n-      else\n-\t{\n-\t  assert (\"EOF too soon!\" == NULL);\n-\t  return (1);\n-\t}\n-    }\n-\n-  fscanf (in, \"%s %s %s %s %s %d %d\", prefix, postfix, storage, type, routine,\n-\t  &do_name, &do_names);\n-\n-  if (storage[0] == '\\0')\n-    storage[1] = '\\0';\n-  else\n-    /* Assume string is quoted somehow, replace ending quote with space. */\n-    {\n-      if (storage[2] == '\\0')\n-\tstorage[1] = '\\0';\n-      else\n-\tstorage[strlen (storage) - 1] = ' ';\n-    }\n-\n-  if (postfix[0] == '\\0')\n-    postfix[1] = '\\0';\n-  else\t\t\t\t/* Assume string is quoted somehow, strip off\n-\t\t\t\t   ending quote. */\n-    postfix[strlen (postfix) - 1] = '\\0';\n-\n-  for (i = 1; storage[i] != '\\0'; ++i)\n-    storage[i - 1] = storage[i];\n-  storage[i - 1] = '\\0';\n-\n-  for (i = 1; postfix[i] != '\\0'; ++i)\n-    postfix[i - 1] = postfix[i];\n-  postfix[i - 1] = '\\0';\n-\n-  fixlengths = strlen (prefix) + strlen (postfix);\n-\n-  while (TRUE)\n-    {\n-      count = fscanf (in, \"%s %s\", buf, kwname);\n-      if (count == EOF)\n-\tbreak;\n-      len = strlen (buf);\n-      if (len == 0)\n-\tcontinue;\t\t/* Skip empty lines. */\n-      if (buf[0] == ';')\n-\tcontinue;\t\t/* Skip commented-out lines. */\n-      for (i = strlen (buf) - 1; i > 0; --i)\n-\tcc = buf[i];\n-\n-      /* Make new name object to store name and its keyword. */\n-\n-      newname = xmalloc (sizeof (*newname));\n-      newname->namelen = strlen (buf);\n-      newname->kwlen = strlen (kwname);\n-      total_length = newname->kwlen + fixlengths;\n-      if (total_length >= 32)\t/* Else resulting keyword name too long. */\n-\t{\n-\t  fprintf (stderr, \"%s: %s%s%s is 31+%d chars long\\n\", input_name,\n-\t\t   prefix, kwname, postfix, total_length - 31);\n-\t  do_exit = TRUE;\n-\t}\n-      strcpy (newname->kwname, kwname);\n-      for (i = 0; i < newname->namelen; ++i)\n-\t{\n-\t  cc = buf[i];\n-\t  newname->name_uc[i] = TOUPPER (cc);\n-\t  newname->name_lc[i] = TOLOWER (cc);\n-\t  newname->name_ic[i] = cc;\n-\t}\n-      newname->name_uc[i] = newname->name_lc[i] = newname->name_ic[i] = '\\0';\n-\n-      /* Warn user if names aren't alphabetically ordered. */\n-\n-      if ((last_buf[0] != '\\0')\n-\t  && (strcmp (last_buf, newname->name_uc) >= 0))\n-\t{\n-\t  fprintf (stderr, \"%s: \\\"%s\\\" precedes \\\"%s\\\"\\n\", input_name,\n-\t\t   last_buf, newname->name_uc);\n-\t  do_exit = TRUE;\n-\t}\n-      strcpy (last_buf, newname->name_uc);\n-\n-      /* Append name to end of alpha-sorted list (assumes names entered in\n-\t alpha order wrt name, not kwname, even though kwname is output from\n-\t this list). */\n-\n-      n = names_alpha.last;\n-      newname->next_alpha = n->next_alpha;\n-      newname->previous_alpha = n;\n-      n->next_alpha->previous_alpha = newname;\n-      n->next_alpha = newname;\n-\n-      /* Insert name in appropriate length/name ordered list. */\n-\n-      n = (name) &names[len];\n-      while ((n->next != (name) &names[len])\n-\t     && (strcmp (buf, n->next->name_uc) > 0))\n-\tn = n->next;\n-      if (strcmp (buf, n->next->name_uc) == 0)\n-\t{\n-\t  fprintf (stderr, \"%s: extraneous \\\"%s\\\"\\n\", input_name, buf);\n-\t  do_exit = TRUE;\n-\t}\n-      newname->next = n->next;\n-      newname->previous = n;\n-      n->next->previous = newname;\n-      n->next = newname;\n-    }\n-\n-#if 0\n-  for (len = 0; len < ARRAY_SIZE (name); ++len)\n-    {\n-      if (names[len].first == (name) &names[len])\n-\tcontinue;\n-      printf (\"Length %d:\\n\", len);\n-      for (n = names[len].first; n != (name) &names[len]; n = n->next)\n-\tprintf (\"    %s %s %s\\n\", n->name_uc, n->name_lc, n->name_ic);\n-    }\n-#endif\n-\n-  if (do_exit)\n-    return (1);\n-\n-  /* First output the #include file. */\n-\n-  for (n = names_alpha.first; n != (name) &names_alpha; n = n->next_alpha)\n-    {\n-      fprintf (incl, \"#define %sl%s%s %d\\n\", prefix, n->kwname, postfix,\n-\t       n->namelen);\n-    }\n-\n-  fprintf (incl,\n-\t   \"\\\n-\\n\\\n-enum %s_\\n\\\n-{\\n\\\n-%sNone%s,\\n\\\n-\",\n-\t   type, prefix, postfix);\n-\n-  for (n = names_alpha.first; n != (name) &names_alpha; n = n->next_alpha)\n-    {\n-      fprintf (incl,\n-\t       \"\\\n-%s%s%s,\\n\\\n-\",\n-\t       prefix, n->kwname, postfix);\n-    }\n-\n-  fprintf (incl,\n-\t   \"\\\n-%s%s\\n\\\n-};\\n\\\n-typedef enum %s_ %s;\\n\\\n-\",\n-\t   prefix, postfix, type, type);\n-\n-  /* Now output the C program. */\n-\n-  fprintf (out,\n-\t   \"\\\n-%s%s\\n\\\n-%s (ffelexToken t)\\n\\\n-%c\\n\\\n-  char *p;\\n\\\n-  int c;\\n\\\n-\\n\\\n-  p = ffelex_token_text (t);\\n\\\n-\\n\\\n-\",\n-\t   storage, type, routine, '{');\n-\n-  if (do_name)\n-    {\n-      if (do_names)\n-\tfprintf (out,\n-\t\t \"\\\n-  if (ffelex_token_type (t) == FFELEX_typeNAME)\\n\\\n-    {\\n\\\n-      switch (ffelex_token_length (t))\\n\\\n-\\t{\\n\\\n-\"\n-\t  );\n-      else\n-\tfprintf (out,\n-\t\t \"\\\n-  assert (ffelex_token_type (t) == FFELEX_typeNAME);\\n\\\n-\\n\\\n-  switch (ffelex_token_length (t))\\n\\\n-    {\\n\\\n-\"\n-\t  );\n-\n-/* Now output the length as a case, followed by the binary search within that length.  */\n-\n-      for (len = 0; ((size_t) len) < ARRAY_SIZE (names); ++len)\n-\t{\n-\t  if (names[len].first != (name) &names[len])\n-\t    {\n-\t      if (do_names)\n-\t\tfprintf (out,\n-\t\t\t \"\\\n-\\tcase %d:\\n\\\n-\",\n-\t\t\t len);\n-\t      else\n-\t\tfprintf (out,\n-\t\t\t \"\\\n-    case %d:\\n\\\n-\",\n-\t\t\t len);\n-\t      testname (FALSE, do_names ? 10 : 6, names[len].first, names[len].last);\n-\t      if (do_names)\n-\t\tfprintf (out,\n-\t\t\t \"\\\n-\\t  break;\\n\\\n-\"\n-\t\t  );\n-\t      else\n-\t\tfprintf (out,\n-\t\t\t \"\\\n-      break;\\n\\\n-\"\n-\t\t  );\n-\t    }\n-\t}\n-\n-      if (do_names)\n-\tfprintf (out,\n-\t\t \"\\\n-\\t}\\n\\\n-      return %sNone%s;\\n\\\n-    }\\n\\\n-\\n\\\n-\",\n-\t\t prefix, postfix);\n-      else\n-\tfprintf (out,\n-\t\t \"\\\n-    }\\n\\\n-\\n\\\n-  return %sNone%s;\\n\\\n-}\\n\\\n-\",\n-\t\t prefix, postfix);\n-    }\n-\n-  if (do_names)\n-    {\n-      fputs (\"\\\n-  assert (ffelex_token_type (t) == FFELEX_typeNAMES);\\n\\\n-\\n\\\n-  switch (ffelex_token_length (t))\\n\\\n-    {\\n\\\n-    default:\\n\\\n-\",\n-\t     out);\n-\n-      /* Find greatest non-empty length list. */\n-\n-      for (len = ARRAY_SIZE (names) - 1;\n-\t   names[len].first == (name) &names[len];\n-\t   --len)\n-\t;\n-\n-/* Now output the length as a case, followed by the binary search within that length. */\n-\n-      if (len > 0)\n-\t{\n-\t  for (; len != 0; --len)\n-\t    {\n-\t      fprintf (out,\n-\t\t       \"\\\n-    case %d:\\n\\\n-\",\n-\t\t       len);\n-\t      if (names[len].first != (name) &names[len])\n-\t\ttestnames (FALSE, 6, len, names[len].first, names[len].last);\n-\t    }\n-\t  if (names[1].first == (name) &names[1])\n-\t    fprintf (out,\n-\t\t     \"\\\n-      ;\\n\\\n-\"\n-\t      );\t\t/* Need empty statement after an empty case\n-\t\t\t\t   1:  */\n-\t}\n-\n-      fprintf (out,\n-\t       \"\\\n-    }\\n\\\n-\\n\\\n-  return %sNone%s;\\n\\\n-}\\n\\\n-\",\n-\t       prefix, postfix);\n-    }\n-\n-  if (out != stdout)\n-    fclose (out);\n-  if (incl != stdout)\n-    fclose (incl);\n-  if (in != stdin)\n-    fclose (in);\n-  return (0);\n-}\n-\n-void\n-testname (bool nested, int indent, name first, name last)\n-{\n-  name n;\n-  name nhalf;\n-  int num;\n-  int numhalf;\n-\n-  assert (!nested || indent >= 2);\n-  assert (((size_t) indent) + 4 < ARRAY_SIZE (xspaces));\n-\n-  num = 0;\n-  numhalf = 0;\n-  for (n = first, nhalf = first; n != last->next; n = n->next)\n-    {\n-      if ((++num & 1) == 0)\n-\t{\n-\t  nhalf = nhalf->next;\n-\t  ++numhalf;\n-\t}\n-    }\n-\n-  if (nested)\n-    fprintf (out,\n-\t     \"\\\n-%s{\\n\\\n-\",\n-\t     xspaces[indent - 2]);\n-\n-  fprintf (out,\n-\t   \"\\\n-%sif ((c = ffesrc_strcmp_2c (ffe_case_match (), p, \\\"%s\\\", \\\"%s\\\", \\\"%s\\\")) == 0)\\n\\\n-%sreturn %s%s%s;\\n\\\n-\",\n-\t   xspaces[indent], nhalf->name_uc, nhalf->name_lc, nhalf->name_ic,\n-\t   xspaces[indent + 2], prefix, nhalf->kwname, postfix);\n-\n-  if (num != 1)\n-    {\n-      fprintf (out,\n-\t       \"\\\n-%selse if (c < 0)\\n\\\n-\",\n-\t       xspaces[indent]);\n-\n-      if (numhalf == 0)\n-\tfprintf (out,\n-\t\t \"\\\n-%s;\\n\\\n-\",\n-\t\t xspaces[indent + 2]);\n-      else\n-\ttestname (TRUE, indent + 4, first, nhalf->previous);\n-\n-      if (num - numhalf > 1)\n-\t{\n-\t  fprintf (out,\n-\t\t   \"\\\n-%selse\\n\\\n-\",\n-\t\t   xspaces[indent]);\n-\n-\t  testname (TRUE, indent + 4, nhalf->next, last);\n-\t}\n-    }\n-\n-  if (nested)\n-    fprintf (out,\n-\t     \"\\\n-%s}\\n\\\n-\",\n-\t     xspaces[indent - 2]);\n-}\n-\n-void\n-testnames (bool nested, int indent, int len, name first, name last)\n-{\n-  name n;\n-  name nhalf;\n-  int num;\n-  int numhalf;\n-\n-  assert (!nested || indent >= 2);\n-  assert (((size_t) indent) + 4 < ARRAY_SIZE (xspaces));\n-\n-  num = 0;\n-  numhalf = 0;\n-  for (n = first, nhalf = first; n != last->next; n = n->next)\n-    {\n-      if ((++num & 1) == 0)\n-\t{\n-\t  nhalf = nhalf->next;\n-\t  ++numhalf;\n-\t}\n-    }\n-\n-  if (nested)\n-    fprintf (out,\n-\t     \"\\\n-%s{\\n\\\n-\",\n-\t     xspaces[indent - 2]);\n-\n-  fprintf (out,\n-\t   \"\\\n-%sif ((c = ffesrc_strncmp_2c (ffe_case_match (), p, \\\"%s\\\", \\\"%s\\\", \\\"%s\\\", %d)) == 0)\\n\\\n-%sreturn %s%s%s;\\n\\\n-\",\n-\t   xspaces[indent], nhalf->name_uc, nhalf->name_lc, nhalf->name_ic,\n-\t   len, xspaces[indent + 2], prefix, nhalf->kwname, postfix);\n-\n-  if (num != 1)\n-    {\n-      fprintf (out,\n-\t       \"\\\n-%selse if (c < 0)\\n\\\n-\",\n-\t       xspaces[indent]);\n-\n-      if (numhalf == 0)\n-\tfprintf (out,\n-\t\t \"\\\n-%s;\\n\\\n-\",\n-\t\t xspaces[indent + 2]);\n-      else\n-\ttestnames (TRUE, indent + 4, len, first, nhalf->previous);\n-\n-      if (num - numhalf > 1)\n-\t{\n-\t  fprintf (out,\n-\t\t   \"\\\n-%selse\\n\\\n-\",\n-\t\t   xspaces[indent]);\n-\n-\t  testnames (TRUE, indent + 4, len, nhalf->next, last);\n-\t}\n-    }\n-\n-  if (nested)\n-    fprintf (out,\n-\t     \"\\\n-%s}\\n\\\n-\",\n-\t     xspaces[indent - 2]);\n-}"}, {"sha": "d97f69c6b8ca5bffd9201497639f11e648371b5f", "filename": "gcc/f/g77.texi", "status": "removed", "additions": 0, "deletions": 11848, "changes": 11848, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fg77.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fg77.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fg77.texi?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "3dca7bc44838d114b2d1543f362196425b87565f", "filename": "gcc/f/g77spec.c", "status": "removed", "additions": 0, "deletions": 541, "changes": 541, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fg77spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fg77spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fg77spec.c?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,541 +0,0 @@\n-/* Specific flags and argument handling of the Fortran front-end.\n-   Copyright (C) 1997, 1999, 2000, 2001, 2002, 2003, 2004\n-   Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* This file contains a filter for the main `gcc' driver, which is\n-   replicated for the `g77' driver by adding this filter.  The purpose\n-   of this filter is to be basically identical to gcc (in that\n-   it faithfully passes all of the original arguments to gcc) but,\n-   unless explicitly overridden by the user in certain ways, ensure\n-   that the needs of the language supported by this wrapper are met.\n-\n-   For GNU Fortran (g77), we do the following to the argument list\n-   before passing it to `gcc':\n-\n-   1.  Make sure `-lg2c -lm' is at the end of the list.\n-\n-   2.  Make sure each time `-lg2c' or `-lm' is seen, it forms\n-       part of the series `-lg2c -lm'.\n-\n-   #1 and #2 are not done if `-nostdlib' or any option that disables\n-   the linking phase is present, or if `-xfoo' is in effect.  Note that\n-   a lack of source files or -l options disables linking.\n-\n-   This program was originally made out of gcc/cp/g++spec.c, but the\n-   way it builds the new argument list was rewritten so it is much\n-   easier to maintain, improve the way it decides to add or not add\n-   extra arguments, etc.  And several improvements were made in the\n-   handling of arguments, primarily to make it more consistent with\n-   `gcc' itself.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"gcc.h\"\n-#include \"intl.h\"\n-\n-#ifndef MATH_LIBRARY\n-#define MATH_LIBRARY \"-lm\"\n-#endif\n-\n-#ifndef FORTRAN_INIT\n-#define FORTRAN_INIT \"-lfrtbegin\"\n-#endif\n-\n-#ifndef FORTRAN_LIBRARY\n-#define FORTRAN_LIBRARY \"-lg2c\"\n-#endif\n-\n-/* Options this driver needs to recognize, not just know how to\n-   skip over.  */\n-typedef enum\n-{\n-  OPTION_b,\t\t\t/* Aka --prefix. */\n-  OPTION_B,\t\t\t/* Aka --target. */\n-  OPTION_c,\t\t\t/* Aka --compile. */\n-  OPTION_driver,\t\t/* Wrapper-specific option. */\n-  OPTION_E,\t\t\t/* Aka --preprocess. */\n-  OPTION_help,\t\t\t/* --help. */\n-  OPTION_i,\t\t\t/* -imacros, -include, -include-*. */\n-  OPTION_l,\n-  OPTION_L,\t\t\t/* Aka --library-directory. */\n-  OPTION_M,\t\t\t/* Aka --dependencies. */\n-  OPTION_MM,\t\t\t/* Aka --user-dependencies. */\n-  OPTION_nostdlib,\t\t/* Aka --no-standard-libraries, or\n-\t\t\t\t   -nodefaultlibs. */\n-  OPTION_o,\t\t\t/* Aka --output. */\n-  OPTION_S,\t\t\t/* Aka --assemble. */\n-  OPTION_syntax_only,\t\t/* -fsyntax-only. */\n-  OPTION_v,\t\t\t/* Aka --verbose. */\n-  OPTION_version,\t\t/* --version. */\n-  OPTION_V,\t\t\t/* Aka --use-version. */\n-  OPTION_x,\t\t\t/* Aka --language. */\n-  OPTION_\t\t\t/* Unrecognized or unimportant. */\n-} Option;\n-\n-/* The original argument list and related info is copied here.  */\n-static int g77_xargc;\n-static const char *const *g77_xargv;\n-static void lookup_option (Option *, int *, const char **, const char *);\n-static void append_arg (const char *);\n-\n-/* The new argument list will be built here.  */\n-static int g77_newargc;\n-static const char **g77_newargv;\n-\n-#ifndef SWITCH_TAKES_ARG\n-#define SWITCH_TAKES_ARG(CHAR) DEFAULT_SWITCH_TAKES_ARG(CHAR)\n-#endif\n-\n-#ifndef WORD_SWITCH_TAKES_ARG\n-#define WORD_SWITCH_TAKES_ARG(STR) DEFAULT_WORD_SWITCH_TAKES_ARG (STR)\n-#endif\n-\n-/* Assumes text[0] == '-'.  Returns number of argv items that belong to\n-   (and follow) this one, an option id for options important to the\n-   caller, and a pointer to the first char of the arg, if embedded (else\n-   returns NULL, meaning no arg or it's the next argv).\n-\n-   Note that this also assumes gcc.c's pass converting long options\n-   to short ones, where available, has already been run.  */\n-\n-static void\n-lookup_option (Option *xopt, int *xskip, const char **xarg, const char *text)\n-{\n-  Option opt = OPTION_;\n-  int skip;\n-  const char *arg = NULL;\n-\n-  if ((skip = SWITCH_TAKES_ARG (text[1])))\n-    skip -= (text[2] != '\\0');\t/* See gcc.c. */\n-\n-  if (text[1] == 'B')\n-    opt = OPTION_B, skip = (text[2] == '\\0'), arg = text + 2;\n-  else if (text[1] == 'b')\n-    opt = OPTION_b, skip = (text[2] == '\\0'), arg = text + 2;\n-  else if ((text[1] == 'c') && (text[2] == '\\0'))\n-    opt = OPTION_c, skip = 0;\n-  else if ((text[1] == 'E') && (text[2] == '\\0'))\n-    opt = OPTION_E, skip = 0;\n-  else if (text[1] == 'i')\n-    opt = OPTION_i, skip = 0;\n-  else if (text[1] == 'l')\n-    opt = OPTION_l;\n-  else if (text[1] == 'L')\n-    opt = OPTION_L, arg = text + 2;\n-  else if (text[1] == 'o')\n-    opt = OPTION_o;\n-  else if ((text[1] == 'S') && (text[2] == '\\0'))\n-    opt = OPTION_S, skip = 0;\n-  else if (text[1] == 'V')\n-    opt = OPTION_V, skip = (text[2] == '\\0');\n-  else if ((text[1] == 'v') && (text[2] == '\\0'))\n-    opt = OPTION_v, skip = 0;\n-  else if (text[1] == 'x')\n-    opt = OPTION_x, arg = text + 2;\n-  else\n-    {\n-      if ((skip = WORD_SWITCH_TAKES_ARG (text + 1)) != 0)  /* See gcc.c. */\n-\t;\n-      else if (! strncmp (text, \"-fdriver\", 8))  /* Really --driver!! */\n-\topt = OPTION_driver;\t/* Never mind arg, this is unsupported. */\n-      else if (! strcmp (text, \"-fhelp\"))  /* Really --help!! */\n-\topt = OPTION_help;\n-      else if (! strcmp (text, \"-M\"))\n-\topt = OPTION_M;\n-      else if (! strcmp (text, \"-MM\"))\n-\topt = OPTION_MM;\n-      else if (! strcmp (text, \"-nostdlib\")\n-\t       || ! strcmp (text, \"-nodefaultlibs\"))\n-\topt = OPTION_nostdlib;\n-      else if (! strcmp (text, \"-fsyntax-only\"))\n-\topt = OPTION_syntax_only;\n-      else if (! strcmp (text, \"-dumpversion\"))\n-\topt = OPTION_version;\n-      else if (! strcmp (text, \"-fversion\"))  /* Really --version!! */\n-\topt = OPTION_version;\n-      else if (! strcmp (text, \"-Xlinker\")\n-\t       || ! strcmp (text, \"-specs\"))\n-\tskip = 1;\n-      else\n-\tskip = 0;\n-    }\n-\n-  if (xopt != NULL)\n-    *xopt = opt;\n-  if (xskip != NULL)\n-    *xskip = skip;\n-  if (xarg != NULL)\n-    {\n-      if ((arg != NULL)\n-\t  && (arg[0] == '\\0'))\n-\t*xarg = NULL;\n-      else\n-\t*xarg = arg;\n-    }\n-}\n-\n-/* Append another argument to the list being built.  As long as it is\n-   identical to the corresponding arg in the original list, just increment\n-   the new arg count.  Otherwise allocate a new list, etc.  */\n-\n-static void\n-append_arg (const char *arg)\n-{\n-  static int newargsize;\n-\n-#if 0\n-  fprintf (stderr, \"`%s'\\n\", arg);\n-#endif\n-\n-  if (g77_newargv == g77_xargv\n-      && g77_newargc < g77_xargc\n-      && (arg == g77_xargv[g77_newargc]\n-\t  || ! strcmp (arg, g77_xargv[g77_newargc])))\n-    {\n-      ++g77_newargc;\n-      return;\t\t\t/* Nothing new here. */\n-    }\n-\n-  if (g77_newargv == g77_xargv)\n-    {\t\t\t\t/* Make new arglist. */\n-      int i;\n-\n-      newargsize = (g77_xargc << 2) + 20;\t/* This should handle all. */\n-      g77_newargv = xmalloc (newargsize * sizeof (char *));\n-\n-      /* Copy what has been done so far.  */\n-      for (i = 0; i < g77_newargc; ++i)\n-\tg77_newargv[i] = g77_xargv[i];\n-    }\n-\n-  if (g77_newargc == newargsize)\n-    fatal (\"overflowed output arg list for `%s'\", arg);\n-\n-  g77_newargv[g77_newargc++] = arg;\n-}\n-\n-void\n-lang_specific_driver (int *in_argc, const char *const **in_argv,\n-\t\t      int *in_added_libraries ATTRIBUTE_UNUSED)\n-{\n-  int argc = *in_argc;\n-  const char *const *argv = *in_argv;\n-  int i;\n-  int verbose = 0;\n-  Option opt;\n-  int skip;\n-  const char *arg;\n-\n-  /* This will be NULL if we encounter a situation where we should not\n-     link in libf2c.  */\n-  const char *library = FORTRAN_LIBRARY;\n-\n-  /* 0 => -xnone in effect.\n-     1 => -xfoo in effect.  */\n-  int saw_speclang = 0;\n-\n-  /* 0 => initial/reset state\n-     1 => last arg was -l<library>\n-     2 => last two args were -l<library> -lm.  */\n-  int saw_library = 0;\n-\n-  /* 0 => initial/reset state\n-     1 => FORTRAN_INIT linked in */\n-  int use_init = 0;\n-  /* By default, we throw on the math library if we have one.  */\n-  int need_math = (MATH_LIBRARY[0] != '\\0');\n-\n-  /* The number of input and output files in the incoming arg list.  */\n-  int n_infiles = 0;\n-  int n_outfiles = 0;\n-\n-#if 0\n-  fprintf (stderr, \"Incoming:\");\n-  for (i = 0; i < argc; i++)\n-    fprintf (stderr, \" %s\", argv[i]);\n-  fprintf (stderr, \"\\n\");\n-#endif\n-\n-  g77_xargc = argc;\n-  g77_xargv = argv;\n-  g77_newargc = 0;\n-  g77_newargv = (const char **) argv;\n-\n-  /* First pass through arglist.\n-\n-     If -nostdlib or a \"turn-off-linking\" option is anywhere in the\n-     command line, don't do any library-option processing (except\n-     relating to -x).  Also, if -v is specified, but no other options\n-     that do anything special (allowing -V version, etc.), remember\n-     to add special stuff to make gcc command actually invoke all\n-     the different phases of the compilation process so all the version\n-     numbers can be seen.\n-\n-     Also, here is where all problems with missing arguments to options\n-     are caught.  If this loop is exited normally, it means all options\n-     have the appropriate number of arguments as far as the rest of this\n-     program is concerned.  */\n-\n-  for (i = 1; i < argc; ++i)\n-    {\n-      if ((argv[i][0] == '+') && (argv[i][1] == 'e'))\n-\t{\n-\t  continue;\n-\t}\n-\n-      if ((argv[i][0] != '-') || (argv[i][1] == '\\0'))\n-\t{\n-\t  ++n_infiles;\n-\t  continue;\n-\t}\n-\n-      lookup_option (&opt, &skip, NULL, argv[i]);\n-\n-      switch (opt)\n-\t{\n-\tcase OPTION_nostdlib:\n-\tcase OPTION_c:\n-\tcase OPTION_S:\n-\tcase OPTION_syntax_only:\n-\tcase OPTION_E:\n-\tcase OPTION_M:\n-\tcase OPTION_MM:\n-\t  /* These options disable linking entirely or linking of the\n-\t     standard libraries.  */\n-\t  library = 0;\n-\t  break;\n-\n-\tcase OPTION_l:\n-\t  ++n_infiles;\n-\t  break;\n-\n-\tcase OPTION_o:\n-\t  ++n_outfiles;\n-\t  break;\n-\n-\tcase OPTION_v:\n-\t  verbose = 1;\n-\t  break;\n-\n-\tcase OPTION_b:\n-\tcase OPTION_B:\n-\tcase OPTION_L:\n-\tcase OPTION_i:\n-\tcase OPTION_V:\n-\t  /* These options are useful in conjunction with -v to get\n-\t     appropriate version info.  */\n-\t  break;\n-\n-\tcase OPTION_version:\n-\t  printf (\"GNU Fortran (GCC) %s\\n\", version_string);\n-\t  printf (\"Copyright %s 2004 Free Software Foundation, Inc.\\n\",\n-\t\t  _(\"(C)\"));\n-\t  printf (\"\\n\");\n-\t  printf (_(\"\\\n-GNU Fortran comes with NO WARRANTY, to the extent permitted by law.\\n\\\n-You may redistribute copies of GNU Fortran\\n\\\n-under the terms of the GNU General Public License.\\n\\\n-For more information about these matters, see the file named COPYING\\n\\\n-or type the command `info -f g77 Copying'.\\n\\\n-\"));\n-\t  exit (0);\n-\t  break;\n-\n-\tcase OPTION_help:\n-\t  /* Let gcc.c handle this, as it has a really\n-\t     cool facility for handling --help and --verbose --help.  */\n-\t  return;\n-\n-\tcase OPTION_driver:\n-\t  fatal (\"--driver no longer supported\");\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-\n-      /* This is the one place we check for missing arguments in the\n-\t program.  */\n-\n-      if (i + skip < argc)\n-\ti += skip;\n-      else\n-\tfatal (\"argument to `%s' missing\", argv[i]);\n-    }\n-\n-  if ((n_outfiles != 0) && (n_infiles == 0))\n-    fatal (\"no input files; unwilling to write output files\");\n-\n-  /* If there are no input files, no need for the library.  */\n-  if (n_infiles == 0)\n-    library = 0;\n-\n-  /* Second pass through arglist, transforming arguments as appropriate.  */\n-\n-  append_arg (argv[0]);\t/* Start with command name, of course. */\n-\n-  for (i = 1; i < argc; ++i)\n-    {\n-      if (argv[i][0] == '\\0')\n-\t{\n-\t  append_arg (argv[i]);\t/* Interesting.  Just append as is. */\n-\t  continue;\n-\t}\n-\n-      if ((argv[i][0] == '-') && (argv[i][1] != 'l'))\n-\t{\n-\t  /* Not a filename or library. */\n-\n-\t if (saw_library == 1 && need_math)    /* -l<library>. */\n-\t    append_arg (MATH_LIBRARY);\n-\n-\t  saw_library = 0;\n-\n-\t  lookup_option (&opt, &skip, &arg, argv[i]);\n-\n-\t  if (argv[i][1] == '\\0')\n-\t    {\n-\t      append_arg (argv[i]);\t/* \"-\" == Standard input. */\n-\t      continue;\n-\t    }\n-\n-\t  if (opt == OPTION_x)\n-\t    {\n-\t      /* Track input language. */\n-\t      const char *lang;\n-\n-\t      if (arg == NULL)\n-\t\tlang = argv[i+1];\n-\t      else\n-\t\tlang = arg;\n-\n-\t      saw_speclang = (strcmp (lang, \"none\") != 0);\n-\t    }\n-\n-\t  append_arg (argv[i]);\n-\n-\t  for (; skip != 0; --skip)\n-\t    append_arg (argv[++i]);\n-\n-\t  continue;\n-\t}\n-\n-      /* A filename/library, not an option. */\n-\n-      if (saw_speclang)\n-\tsaw_library = 0;\t/* -xfoo currently active. */\n-      else\n-\t{\t\t\t/* -lfoo or filename. */\n-\t  if (strcmp (argv[i], MATH_LIBRARY) == 0)\n-\t    {\n-\t      if (saw_library == 1)\n-\t\tsaw_library = 2;\t/* -l<library> -lm. */\n-\t      else\n-\t\t{\n-\t\t  if (0 == use_init)\n-\t\t    {\n-\t\t      append_arg (FORTRAN_INIT);\n-\t\t      use_init = 1;\n-\t\t    }\n-\t\t  append_arg (FORTRAN_LIBRARY);\n-\t\t}\n-\t    }\n-\t  else if (strcmp (argv[i], FORTRAN_LIBRARY) == 0)\n-\t    saw_library = 1;\t/* -l<library>. */\n-\t  else\n-\t    {\t\t/* Other library, or filename. */\n-\t     if (saw_library == 1 && need_math)\n-\t\tappend_arg (MATH_LIBRARY);\n-\t      saw_library = 0;\n-\t    }\n-\t}\n-      append_arg (argv[i]);\n-    }\n-\n-  /* Append `-lg2c -lm' as necessary.  */\n-\n-  if (library)\n-    {\t\t\t\t/* Doing a link and no -nostdlib. */\n-      if (saw_speclang)\n-\tappend_arg (\"-xnone\");\n-\n-      switch (saw_library)\n-\t{\n-\tcase 0:\n-\t  if (0 == use_init)\n-\t    {\n-\t      append_arg (FORTRAN_INIT);\n-\t      use_init = 1;\n-\t    }\n-\t  append_arg (library);\n-\tcase 1:\n-\t if (need_math)\n-\t   append_arg (MATH_LIBRARY);\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n-\n-#ifdef ENABLE_SHARED_LIBGCC\n-  if (library)\n-    {\n-      int i;\n-\n-      for (i = 1; i < g77_newargc; i++)\n-\tif (g77_newargv[i][0] == '-')\n-\t  if (strcmp (g77_newargv[i], \"-static-libgcc\") == 0\n-\t      || strcmp (g77_newargv[i], \"-static\") == 0)\n-\t    break;\n-    \n-      if (i == g77_newargc)\n-\tappend_arg (\"-shared-libgcc\");\n-    }\n-  \n-#endif\n-\n-  if (verbose\n-      && g77_newargv != g77_xargv)\n-    {\n-      fprintf (stderr, \"Driving:\");\n-      for (i = 0; i < g77_newargc; i++)\n-\tfprintf (stderr, \" %s\", g77_newargv[i]);\n-      fprintf (stderr, \"\\n\");\n-    }\n-\n-  *in_argc = g77_newargc;\n-  *in_argv = g77_newargv;\n-}\n-\n-/* Called before linking.  Returns 0 on success and -1 on failure. */\n-int lang_specific_pre_link (void)  /* Not used for F77. */\n-{\n-  return 0;\n-}\n-\n-/* Number of extra output files that lang_specific_pre_link may generate. */\n-int lang_specific_extra_outfiles = 0;  /* Not used for F77. */\n-\n-/* Table of language-specific spec functions.  */ \n-const struct spec_function lang_specific_spec_functions[] =\n-{\n-  { 0, 0 }\n-};"}, {"sha": "8793f62c4a73ccc8ad02b4304e85a74e5dcba137", "filename": "gcc/f/global.c", "status": "removed", "additions": 0, "deletions": 1586, "changes": 1586, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fglobal.c?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,1586 +0,0 @@\n-/* global.c -- Implementation File (module.c template V1.0)\n-   Copyright (C) 1995, 1997, 2003 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Related Modules:\n-\n-   Description:\n-      Manages information kept across individual program units within a single\n-      source file.  This includes reporting errors when a name is defined\n-      multiple times (for example, two program units named FOO) and when a\n-      COMMON block is given initial data in more than one program unit.\n-\n-   Modifications:\n-*/\n-\n-/* Include files. */\n-\n-#include \"proj.h\"\n-#include \"global.h\"\n-#include \"info.h\"\n-#include \"lex.h\"\n-#include \"malloc.h\"\n-#include \"name.h\"\n-#include \"symbol.h\"\n-#include \"top.h\"\n-\n-/* Externals defined here. */\n-\n-\n-/* Simple definitions and enumerations. */\n-\n-\n-/* Internal typedefs. */\n-\n-\n-/* Private include files. */\n-\n-\n-/* Internal structure definitions. */\n-\n-\n-/* Static objects accessed by functions in this module. */\n-\n-#if FFEGLOBAL_ENABLED\n-static ffenameSpace ffeglobal_filewide_ = NULL;\n-static const char *const ffeglobal_type_string_[] =\n-{\n-  [FFEGLOBAL_typeNONE] = \"??\",\n-  [FFEGLOBAL_typeMAIN] = \"main program\",\n-  [FFEGLOBAL_typeEXT] = \"external\",\n-  [FFEGLOBAL_typeSUBR] = \"subroutine\",\n-  [FFEGLOBAL_typeFUNC] = \"function\",\n-  [FFEGLOBAL_typeBDATA] = \"block data\",\n-  [FFEGLOBAL_typeCOMMON] = \"common block\",\n-  [FFEGLOBAL_typeANY] = \"?any?\"\n-};\n-#endif\n-\n-/* Static functions (internal). */\n-\n-\n-/* Internal macros. */\n-\f\n-\n-/* Call given fn with all globals\n-\n-   ffeglobal (*fn)(ffeglobal g);\n-   ffeglobal_drive(fn);\t */\n-\n-#if FFEGLOBAL_ENABLED\n-void\n-ffeglobal_drive (ffeglobal (*fn) (ffeglobal))\n-{\n-  if (ffeglobal_filewide_ != NULL)\n-    ffename_space_drive_global (ffeglobal_filewide_, fn);\n-}\n-\n-#endif\n-/* ffeglobal_new_ -- Make new global\n-\n-   ffename n;\n-   ffeglobal g;\n-   g = ffeglobal_new_(n);  */\n-\n-#if FFEGLOBAL_ENABLED\n-static ffeglobal\n-ffeglobal_new_ (ffename n)\n-{\n-  ffeglobal g;\n-\n-  assert (n != NULL);\n-\n-  g = malloc_new_ks (malloc_pool_image (), \"FFEGLOBAL\", sizeof (*g));\n-  g->n = n;\n-  g->hook = FFECOM_globalNULL;\n-  g->tick = 0;\n-\n-  ffename_set_global (n, g);\n-\n-  return g;\n-}\n-\n-#endif\n-/* ffeglobal_init_1 -- Initialize per file\n-\n-   ffeglobal_init_1();\t*/\n-\n-void\n-ffeglobal_init_1 (void)\n-{\n-#if FFEGLOBAL_ENABLED\n-  if (ffeglobal_filewide_ != NULL)\n-    ffename_space_kill (ffeglobal_filewide_);\n-  ffeglobal_filewide_ = ffename_space_new (malloc_pool_image ());\n-#endif\n-}\n-\n-/* ffeglobal_init_common -- Initial value specified for common block\n-\n-   ffesymbol s;\t // the ffesymbol for the common block\n-   ffelexToken t;  // the token with the point of initialization\n-   ffeglobal_init_common(s,t);\n-\n-   For back ends where file-wide global symbols are not maintained, does\n-   nothing.  Otherwise, makes sure this common block hasn't already been\n-   initialized in a previous program unit, and flag that it's been\n-   initialized in this one.  */\n-\n-void\n-ffeglobal_init_common (ffesymbol s, ffelexToken t)\n-{\n-#if FFEGLOBAL_ENABLED\n-  ffeglobal g;\n-\n-  g = ffesymbol_global (s);\n-\n-  if ((g == NULL) || (g->type != FFEGLOBAL_typeCOMMON))\n-    return;\n-  if (g->type == FFEGLOBAL_typeANY)\n-    return;\n-\n-  if (g->tick == ffe_count_2)\n-    return;\n-\n-  if (g->tick != 0)\n-    {\n-      if (g->u.common.initt != NULL)\n-\t{\n-\t  ffebad_start (FFEBAD_COMMON_ALREADY_INIT);\n-\t  ffebad_string (ffesymbol_text (s));\n-\t  ffebad_here (0, ffelex_token_where_line (t), ffelex_token_where_column (t));\n-\t  ffebad_here (1, ffelex_token_where_line (g->u.common.initt),\n-\t\t       ffelex_token_where_column (g->u.common.initt));\n-\t  ffebad_finish ();\n-\t}\n-\n-      /* Complain about just one attempt to reinit per program unit, but\n-\t continue referring back to the first such successful attempt.  */\n-    }\n-  else\n-    {\n-      if (g->u.common.blank)\n-\t{\n-\t  /* Not supposed to initialize blank common, though it works.  */\n-\t  ffebad_start (FFEBAD_COMMON_BLANK_INIT);\n-\t  ffebad_here (0, ffelex_token_where_line (t), ffelex_token_where_column (t));\n-\t  ffebad_finish ();\n-\t}\n-\n-      g->u.common.initt = ffelex_token_use (t);\n-    }\n-\n-  g->tick = ffe_count_2;\n-#endif\n-}\n-\n-/* ffeglobal_new_common -- New common block\n-\n-   ffesymbol s;\t // the ffesymbol for the new common block\n-   ffelexToken t;  // the token with the name of the common block\n-   bool blank;\t// TRUE if blank common\n-   ffeglobal_new_common(s,t,blank);\n-\n-   For back ends where file-wide global symbols are not maintained, does\n-   nothing.  Otherwise, makes sure this symbol hasn't been seen before or\n-   is known as a common block.\t*/\n-\n-void\n-ffeglobal_new_common (ffesymbol s, ffelexToken t, bool blank)\n-{\n-#if FFEGLOBAL_ENABLED\n-  ffename n;\n-  ffeglobal g;\n-\n-  if (ffesymbol_global (s) == NULL)\n-    {\n-      n = ffename_find (ffeglobal_filewide_, t);\n-      g = ffename_global (n);\n-    }\n-  else\n-    {\n-      g = ffesymbol_global (s);\n-      n = NULL;\n-    }\n-\n-  if ((g != NULL) && (g->type == FFEGLOBAL_typeANY))\n-    return;\n-\n-  if ((g != NULL) && (g->type != FFEGLOBAL_typeNONE))\n-    {\n-      if (g->type == FFEGLOBAL_typeCOMMON)\n-\t{\n-\t  /* The names match, so the \"blankness\" should match too!  */\n-\t  assert (g->u.common.blank == blank);\n-\t}\n-      else\n-\t{\n-\t  /* This global name has already been established,\n-\t     but as something other than a common block.  */\n-\t  if (ffe_is_globals () || ffe_is_warn_globals ())\n-\t    {\n-\t      ffebad_start (ffe_is_globals ()\n-\t\t\t    ? FFEBAD_FILEWIDE_ALREADY_SEEN\n-\t\t\t    : FFEBAD_FILEWIDE_ALREADY_SEEN_W);\n-\t      ffebad_string (ffelex_token_text (t));\n-\t      ffebad_here (0, ffelex_token_where_line (t), ffelex_token_where_column (t));\n-\t      ffebad_here (1, ffelex_token_where_line (g->t),\n-\t\t\t   ffelex_token_where_column (g->t));\n-\t      ffebad_finish ();\n-\t    }\n-\t  g->type = FFEGLOBAL_typeANY;\n-\t}\n-    }\n-  else\n-    {\n-      if (g == NULL)\n-\t{\n-\t  g = ffeglobal_new_ (n);\n-\t  g->intrinsic = FALSE;\n-\t}\n-      else if (g->intrinsic\n-\t       && !g->explicit_intrinsic\n-\t       && ffe_is_warn_globals ())\n-\t{\n-\t  /* Common name previously used as intrinsic.  Though it works,\n-\t     warn, because the intrinsic reference might have been intended\n-\t     as a ref to an external procedure, but g77's vast list of\n-\t     intrinsics happened to snarf the name.  */\n-\t  ffebad_start (FFEBAD_INTRINSIC_GLOBAL);\n-\t  ffebad_string (ffelex_token_text (t));\n-\t  ffebad_string (\"common block\");\n-\t  ffebad_string (\"intrinsic\");\n-\t  ffebad_here (0, ffelex_token_where_line (t), ffelex_token_where_column (t));\n-\t  ffebad_here (1, ffelex_token_where_line (g->t),\n-\t\t       ffelex_token_where_column (g->t));\n-\t  ffebad_finish ();\n-\t}\n-      g->t = ffelex_token_use (t);\n-      g->type = FFEGLOBAL_typeCOMMON;\n-      g->u.common.have_pad = FALSE;\n-      g->u.common.have_save = FALSE;\n-      g->u.common.have_size = FALSE;\n-      g->u.common.blank = blank;\n-    }\n-\n-  ffesymbol_set_global (s, g);\n-#endif\n-}\n-\n-/* ffeglobal_new_progunit_ -- New program unit\n-\n-   ffesymbol s;\t // the ffesymbol for the new unit\n-   ffelexToken t;  // the token with the name of the unit\n-   ffeglobalType type;\t// the type of the new unit\n-   ffeglobal_new_progunit_(s,t,type);\n-\n-   For back ends where file-wide global symbols are not maintained, does\n-   nothing.  Otherwise, makes sure this symbol hasn't been seen before.\t */\n-\n-void\n-ffeglobal_new_progunit_ (ffesymbol s, ffelexToken t, ffeglobalType type)\n-{\n-#if FFEGLOBAL_ENABLED\n-  ffename n;\n-  ffeglobal g;\n-\n-  n = ffename_find (ffeglobal_filewide_, t);\n-  g = ffename_global (n);\n-  if ((g != NULL) && (g->type == FFEGLOBAL_typeANY))\n-    return;\n-\n-  if ((g != NULL)\n-      && ((g->type == FFEGLOBAL_typeMAIN)\n-\t  || (g->type == FFEGLOBAL_typeSUBR)\n-\t  || (g->type == FFEGLOBAL_typeFUNC)\n-\t  || (g->type == FFEGLOBAL_typeBDATA))\n-      && g->u.proc.defined)\n-    {\n-      /* This program unit has already been defined.  */\n-      if (ffe_is_globals () || ffe_is_warn_globals ())\n-\t{\n-\t  ffebad_start (ffe_is_globals ()\n-\t\t\t? FFEBAD_FILEWIDE_ALREADY_SEEN\n-\t\t\t: FFEBAD_FILEWIDE_ALREADY_SEEN_W);\n-\t  ffebad_string (ffelex_token_text (t));\n-\t  ffebad_here (0, ffelex_token_where_line (t),\n-\t\t       ffelex_token_where_column (t));\n-\t  ffebad_here (1, ffelex_token_where_line (g->t),\n-\t\t       ffelex_token_where_column (g->t));\n-\t  ffebad_finish ();\n-\t}\n-      g->type = FFEGLOBAL_typeANY;\n-    }\n-  else if ((g != NULL)\n-\t   && (g->type != FFEGLOBAL_typeNONE)\n-\t   && (g->type != FFEGLOBAL_typeEXT)\n-\t   && (g->type != type))\n-    {\n-      /* A reference to this program unit has been seen, but its\n-\t context disagrees about the new definition regarding\n-\t what kind of program unit it is.  (E.g. `call foo' followed\n-\t by `function foo'.)  But `external foo' alone doesn't mean\n-\t disagreement with either a function or subroutine, though\n-\t g77 normally interprets it as a request to force-load\n-\t a block data program unit by that name (to cope with libs).  */\n-      if (ffe_is_globals () || ffe_is_warn_globals ())\n-\t{\n-\t  ffebad_start (ffe_is_globals ()\n-\t\t\t? FFEBAD_FILEWIDE_DISAGREEMENT\n-\t\t\t: FFEBAD_FILEWIDE_DISAGREEMENT_W);\n-\t  ffebad_string (ffelex_token_text (t));\n-\t  ffebad_string (ffeglobal_type_string_[type]);\n-\t  ffebad_string (ffeglobal_type_string_[g->type]);\n-\t  ffebad_here (0, ffelex_token_where_line (t),\n-\t\t       ffelex_token_where_column (t));\n-\t  ffebad_here (1, ffelex_token_where_line (g->t),\n-\t\t       ffelex_token_where_column (g->t));\n-\t  ffebad_finish ();\n-\t}\n-      g->type = FFEGLOBAL_typeANY;\n-    }\n-  else\n-    {\n-      if (g == NULL)\n-\t{\n-\t  g = ffeglobal_new_ (n);\n-\t  g->intrinsic = FALSE;\n-\t  g->u.proc.n_args = -1;\n-\t  g->u.proc.other_t = NULL;\n-\t}\n-      else if ((ffesymbol_basictype (s) != FFEINFO_basictypeNONE)\n-\t       && (g->type == FFEGLOBAL_typeFUNC)\n-\t       && ((ffesymbol_basictype (s) != g->u.proc.bt)\n-\t\t   || (ffesymbol_kindtype (s) != g->u.proc.kt)\n-\t\t   || ((ffesymbol_size (s) != FFETARGET_charactersizeNONE)\n-\t\t       && (ffesymbol_size (s) != g->u.proc.sz))))\n-\t{\n-\t  /* The previous reference and this new function definition\n-\t     disagree about the type of the function.  I (Burley) think\n-\t     this rarely occurs, because when this code is reached,\n-\t     the type info doesn't appear to be filled in yet.  */\n-\t  if (ffe_is_globals () || ffe_is_warn_globals ())\n-\t    {\n-\t      ffebad_start (ffe_is_globals ()\n-\t\t\t    ? FFEBAD_FILEWIDE_TYPE_MISMATCH\n-\t\t\t    : FFEBAD_FILEWIDE_TYPE_MISMATCH_W);\n-\t      ffebad_string (ffelex_token_text (t));\n-\t      ffebad_here (0, ffelex_token_where_line (t),\n-\t\t\t   ffelex_token_where_column (t));\n-\t      ffebad_here (1, ffelex_token_where_line (g->t),\n-\t\t\t   ffelex_token_where_column (g->t));\n-\t      ffebad_finish ();\n-\t    }\n-\t  g->type = FFEGLOBAL_typeANY;\n-\t  return;\n-\t}\n-      if (g->intrinsic\n-\t  && !g->explicit_intrinsic\n-\t  && ffe_is_warn_globals ())\n-\t{\n-\t  /* This name, previously used as an intrinsic, now is known\n-\t     to also be a global procedure name.  Warn, since the previous\n-\t     use as an intrinsic might have been intended to refer to\n-\t     this procedure.  */\n-\t  ffebad_start (FFEBAD_INTRINSIC_GLOBAL);\n-\t  ffebad_string (ffelex_token_text (t));\n-\t  ffebad_string (\"global\");\n-\t  ffebad_string (\"intrinsic\");\n-\t  ffebad_here (0, ffelex_token_where_line (t), ffelex_token_where_column (t));\n-\t  ffebad_here (1, ffelex_token_where_line (g->t),\n-\t\t       ffelex_token_where_column (g->t));\n-\t  ffebad_finish ();\n-\t}\n-      g->t = ffelex_token_use (t);\n-      if ((g->tick == 0)\n-\t  || (g->u.proc.bt == FFEINFO_basictypeNONE)\n-\t  || (g->u.proc.kt == FFEINFO_kindtypeNONE))\n-\t{\n-\t  g->u.proc.bt = ffesymbol_basictype (s);\n-\t  g->u.proc.kt = ffesymbol_kindtype (s);\n-\t  g->u.proc.sz = ffesymbol_size (s);\n-\t}\n-      /* If there's a known disagreement about the kind of program\n-\t unit, then don't even bother tracking arglist argreement.  */\n-      if ((g->tick != 0)\n-\t  && (g->type != type))\n-\tg->u.proc.n_args = -1;\n-      g->tick = ffe_count_2;\n-      g->type = type;\n-      g->u.proc.defined = TRUE;\n-    }\n-\n-  ffesymbol_set_global (s, g);\n-#endif\n-}\n-\n-/* ffeglobal_pad_common -- Check initial padding of common area\n-\n-   ffesymbol s;\t // the common area\n-   ffetargetAlign pad;\t// the initial padding\n-   ffeglobal_pad_common(s,pad,ffesymbol_where_line(s),\n-\t ffesymbol_where_column(s));\n-\n-   In global-enabled mode, make sure the padding agrees with any existing\n-   padding established for the common area, otherwise complain.\n-   In global-disabled mode, warn about nonzero padding.\t */\n-\n-void\n-ffeglobal_pad_common (ffesymbol s, ffetargetAlign pad, ffewhereLine wl,\n-\t\t      ffewhereColumn wc)\n-{\n-#if FFEGLOBAL_ENABLED\n-  ffeglobal g;\n-\n-  g = ffesymbol_global (s);\n-  if ((g == NULL) || (g->type != FFEGLOBAL_typeCOMMON))\n-    return;\t\t\t/* Let someone else catch this! */\n-  if (g->type == FFEGLOBAL_typeANY)\n-    return;\n-\n-  if (!g->u.common.have_pad)\n-    {\n-      g->u.common.have_pad = TRUE;\n-      g->u.common.pad = pad;\n-      g->u.common.pad_where_line = ffewhere_line_use (wl);\n-      g->u.common.pad_where_col = ffewhere_column_use (wc);\n-\n-      if (pad != 0)\n-\t{\n-\t  char padding[20];\n-\n-\t  sprintf (&padding[0], \"%\" ffetargetAlign_f \"u\", pad);\n-\t  ffebad_start (FFEBAD_COMMON_INIT_PAD);\n-\t  ffebad_string (ffesymbol_text (s));\n-\t  ffebad_string (padding);\n-\t  ffebad_string ((pad == 1)\n-\t\t\t ? FFECOM_SIZE_UNIT : FFECOM_SIZE_UNITS);\n-\t  ffebad_here (0, wl, wc);\n-\t  ffebad_finish ();\n-\t}\n-    }\n-  else\n-    {\n-      if (g->u.common.pad != pad)\n-\t{\n-\t  char padding_1[20];\n-\t  char padding_2[20];\n-\n-\t  sprintf (&padding_1[0], \"%\" ffetargetAlign_f \"u\", pad);\n-\t  sprintf (&padding_2[0], \"%\" ffetargetAlign_f \"u\", g->u.common.pad);\n-\t  ffebad_start (FFEBAD_COMMON_DIFF_PAD);\n-\t  ffebad_string (ffesymbol_text (s));\n-\t  ffebad_string (padding_1);\n-\t  ffebad_here (0, wl, wc);\n-\t  ffebad_string (padding_2);\n-\t  ffebad_string ((pad == 1)\n-\t\t\t ? FFECOM_SIZE_UNIT : FFECOM_SIZE_UNITS);\n-\t  ffebad_string ((g->u.common.pad == 1)\n-\t\t\t ? FFECOM_SIZE_UNIT : FFECOM_SIZE_UNITS);\n-\t  ffebad_here (1, g->u.common.pad_where_line, g->u.common.pad_where_col);\n-\t  ffebad_finish ();\n-\t}\n-\n-      if (g->u.common.pad < pad)\n-\t{\n-\t  g->u.common.pad = pad;\n-\t  g->u.common.pad_where_line = ffewhere_line_use (wl);\n-\t  g->u.common.pad_where_col = ffewhere_column_use (wc);\n-\t}\n-    }\n-#endif\n-}\n-\n-/* Collect info for a global's argument.  */\n-\n-void\n-ffeglobal_proc_def_arg (ffesymbol s, int argno, const char *name, ffeglobalArgSummary as,\n-\t\t\tffeinfoBasictype bt, ffeinfoKindtype kt,\n-\t\t\tbool array)\n-{\n-  ffeglobal g = ffesymbol_global (s);\n-  ffeglobalArgInfo_ ai;\n-\n-  assert (g != NULL);\n-\n-  if (g->type == FFEGLOBAL_typeANY)\n-    return;\n-\n-  assert (g->u.proc.n_args >= 0);\n-\n-  if (argno >= g->u.proc.n_args)\n-    return;\t/* Already complained about this discrepancy. */\n-\n-  ai = &g->u.proc.arg_info[argno];\n-\n-  /* Maybe warn about previous references.  */\n-\n-  if ((ai->t != NULL)\n-      && ffe_is_warn_globals ())\n-    {\n-      const char *refwhy = NULL;\n-      const char *defwhy = NULL;\n-      bool warn = FALSE;\n-\n-      switch (as)\n-\t{\n-\tcase FFEGLOBAL_argsummaryREF:\n-\t  if ((ai->as != FFEGLOBAL_argsummaryREF)\n-\t      && (ai->as != FFEGLOBAL_argsummaryNONE)\n-\t      && ((ai->as != FFEGLOBAL_argsummaryDESCR)\t/* Choose better message. */\n-\t\t  || (ai->bt != FFEINFO_basictypeCHARACTER)\n-\t\t  || (ai->bt == bt)))\n-\t    {\n-\t      warn = TRUE;\n-\t      refwhy = \"passed by reference\";\n-\t    }\n-\t  break;\n-\n-\tcase FFEGLOBAL_argsummaryDESCR:\n-\t  if ((ai->as != FFEGLOBAL_argsummaryDESCR)\n-\t      && (ai->as != FFEGLOBAL_argsummaryNONE)\n-\t      && ((ai->as != FFEGLOBAL_argsummaryREF)\t/* Choose better message. */\n-\t\t  || (bt != FFEINFO_basictypeCHARACTER)\n-\t\t  || (ai->bt == bt)))\n-\t    {\n-\t      warn = TRUE;\n-\t      refwhy = \"passed by descriptor\";\n-\t    }\n-\t  break;\n-\n-\tcase FFEGLOBAL_argsummaryPROC:\n-\t  if ((ai->as != FFEGLOBAL_argsummaryPROC)\n-\t      && (ai->as != FFEGLOBAL_argsummarySUBR)\n-\t      && (ai->as != FFEGLOBAL_argsummaryFUNC)\n-\t      && (ai->as != FFEGLOBAL_argsummaryNONE))\n-\t    {\n-\t      warn = TRUE;\n-\t      refwhy = \"a procedure\";\n-\t    }\n-\t  break;\n-\n-\tcase FFEGLOBAL_argsummarySUBR:\n-\t  if ((ai->as != FFEGLOBAL_argsummaryPROC)\n-\t      && (ai->as != FFEGLOBAL_argsummarySUBR)\n-\t      && (ai->as != FFEGLOBAL_argsummaryNONE))\n-\t    {\n-\t      warn = TRUE;\n-\t      refwhy = \"a subroutine\";\n-\t    }\n-\t  break;\n-\n-\tcase FFEGLOBAL_argsummaryFUNC:\n-\t  if ((ai->as != FFEGLOBAL_argsummaryPROC)\n-\t      && (ai->as != FFEGLOBAL_argsummaryFUNC)\n-\t      && (ai->as != FFEGLOBAL_argsummaryNONE))\n-\t    {\n-\t      warn = TRUE;\n-\t      refwhy = \"a function\";\n-\t    }\n-\t  break;\n-\n-\tcase FFEGLOBAL_argsummaryALTRTN:\n-\t  if ((ai->as != FFEGLOBAL_argsummaryALTRTN)\n-\t      && (ai->as != FFEGLOBAL_argsummaryNONE))\n-\t    {\n-\t      warn = TRUE;\n-\t      refwhy = \"an alternate-return label\";\n-\t    }\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-\n-      if ((refwhy != NULL) && (defwhy == NULL))\n-\t{\n-\t  /* Fill in the def info.  */\n-\n-\t  switch (ai->as)\n-\t    {\n-\t    case FFEGLOBAL_argsummaryNONE:\n-\t      defwhy = \"omitted\";\n-\t      break;\n-\n-\t    case FFEGLOBAL_argsummaryVAL:\n-\t      defwhy = \"passed by value\";\n-\t      break;\n-\n-\t    case FFEGLOBAL_argsummaryREF:\n-\t      defwhy = \"passed by reference\";\n-\t      break;\n-\n-\t    case FFEGLOBAL_argsummaryDESCR:\n-\t      defwhy = \"passed by descriptor\";\n-\t      break;\n-\n-\t    case FFEGLOBAL_argsummaryPROC:\n-\t      defwhy = \"a procedure\";\n-\t      break;\n-\n-\t    case FFEGLOBAL_argsummarySUBR:\n-\t      defwhy = \"a subroutine\";\n-\t      break;\n-\n-\t    case FFEGLOBAL_argsummaryFUNC:\n-\t      defwhy = \"a function\";\n-\t      break;\n-\n-\t    case FFEGLOBAL_argsummaryALTRTN:\n-\t      defwhy = \"an alternate-return label\";\n-\t      break;\n-\n-#if 0\n-\t    case FFEGLOBAL_argsummaryPTR:\n-\t      defwhy = \"a pointer\";\n-\t      break;\n-#endif\n-\n-\t    default:\n-\t      defwhy = \"???\";\n-\t      break;\n-\t    }\n-\t}\n-\n-      if (!warn\n-\t  && (bt != FFEINFO_basictypeHOLLERITH)\n-\t  && (bt != FFEINFO_basictypeTYPELESS)\n-\t  && (bt != FFEINFO_basictypeNONE)\n-\t  && (ai->bt != FFEINFO_basictypeHOLLERITH)\n-\t  && (ai->bt != FFEINFO_basictypeTYPELESS)\n-\t  && (ai->bt != FFEINFO_basictypeNONE))\n-\t{\n-\t  /* Check types.  */\n-\n-\t  if ((bt != ai->bt)\n-\t      && ((bt != FFEINFO_basictypeREAL)\n-\t\t  || (ai->bt != FFEINFO_basictypeCOMPLEX))\n-\t      && ((bt != FFEINFO_basictypeCOMPLEX)\n-\t\t  || (ai->bt != FFEINFO_basictypeREAL)))\n-\t    {\n-\t      warn = TRUE;\t/* We can cope with these differences. */\n-\t      refwhy = \"one type\";\n-\t      defwhy = \"some other type\";\n-\t    }\n-\n-\t  if (!warn && (kt != ai->kt))\n-\t    {\n-\t      warn = TRUE;\n-\t      refwhy = \"one precision\";\n-\t      defwhy = \"some other precision\";\n-\t    }\n-\t}\n-\n-      if (warn)\n-\t{\n-\t  char num[60];\n-\n-\t  if (name == NULL)\n-\t    sprintf (&num[0], \"%d\", argno + 1);\n-\t  else\n-\t    {\n-\t      if (strlen (name) < 30)\n-\t\tsprintf (&num[0], \"%d (named `%s')\", argno + 1, name);\n-\t      else\n-\t\tsprintf (&num[0], \"%d (named `%.*s...')\", argno + 1, 30, name);\n-\t    }\n-\t  ffebad_start (FFEBAD_FILEWIDE_ARG_W);\n-\t  ffebad_string (ffesymbol_text (s));\n-\t  ffebad_string (num);\n-\t  ffebad_string (refwhy);\n-\t  ffebad_string (defwhy);\n-\t  ffebad_here (0, ffelex_token_where_line (g->t), ffelex_token_where_column (g->t));\n-\t  ffebad_here (1, ffelex_token_where_line (ai->t), ffelex_token_where_column (ai->t));\n-\t  ffebad_finish ();\n-\t}\n-    }\n-\n-  /* Define this argument.  */\n-\n-  if (ai->t != NULL)\n-    ffelex_token_kill (ai->t);\n-  if ((as != FFEGLOBAL_argsummaryPROC)\n-      || (ai->t == NULL))\n-    ai->as = as;\t/* Otherwise leave SUBR/FUNC info intact. */\n-  ai->t = ffelex_token_use (g->t);\n-  if (name == NULL)\n-    ai->name = NULL;\n-  else\n-    {\n-      ai->name = malloc_new_ks (malloc_pool_image (),\n-\t\t\t\t\"ffeglobalArgInfo_ name\",\n-\t\t\t\tstrlen (name) + 1);\n-      strcpy (ai->name, name);\n-    }\n-  ai->bt = bt;\n-  ai->kt = kt;\n-  ai->array = array;\n-}\n-\n-/* Collect info on #args a global accepts.  */\n-\n-void\n-ffeglobal_proc_def_nargs (ffesymbol s, int n_args)\n-{\n-  ffeglobal g = ffesymbol_global (s);\n-\n-  assert (g != NULL);\n-\n-  if (g->type == FFEGLOBAL_typeANY)\n-    return;\n-\n-  if (g->u.proc.n_args >= 0)\n-    {\n-      if (g->u.proc.n_args == n_args)\n-\treturn;\n-\n-      if (ffe_is_warn_globals ())\n-\t{\n-\t  ffebad_start (FFEBAD_FILEWIDE_NARGS_W);\n-\t  ffebad_string (ffesymbol_text (s));\n-\t  if (g->u.proc.n_args > n_args)\n-\t    ffebad_string (\"few\");\n-\t  else\n-\t    ffebad_string (\"many\");\n-\t  ffebad_here (0, ffelex_token_where_line (g->u.proc.other_t),\n-\t\t       ffelex_token_where_column (g->u.proc.other_t));\n-\t  ffebad_here (1, ffelex_token_where_line (g->t),\n-\t\t       ffelex_token_where_column (g->t));\n-\t  ffebad_finish ();\n-\t}\n-    }\n-\n-  /* This is new info we can use in cross-checking future references\n-     and a possible future definition.  */\n-\n-  g->u.proc.n_args = n_args;\n-  g->u.proc.other_t = NULL;\t/* No other reference yet. */\n-\n-  if (n_args == 0)\n-    {\n-      g->u.proc.arg_info = NULL;\n-      return;\n-    }\n-\n-  g->u.proc.arg_info = malloc_new_ks (malloc_pool_image (),\n-\t\t\t\t      \"ffeglobalArgInfo_\",\n-\t\t\t\t      n_args * sizeof (g->u.proc.arg_info[0]));\n-  while (n_args-- > 0)\n-    g->u.proc.arg_info[n_args].t = NULL;\n-}\n-\n-/* Verify that the info for a global's argument is valid.  */\n-\n-bool\n-ffeglobal_proc_ref_arg (ffesymbol s, int argno, ffeglobalArgSummary as,\n-\t\t\tffeinfoBasictype bt, ffeinfoKindtype kt,\n-\t\t\tbool array, ffelexToken t)\n-{\n-  ffeglobal g = ffesymbol_global (s);\n-  ffeglobalArgInfo_ ai;\n-\n-  assert (g != NULL);\n-\n-  if (g->type == FFEGLOBAL_typeANY)\n-    return FALSE;\n-\n-  assert (g->u.proc.n_args >= 0);\n-\n-  if (argno >= g->u.proc.n_args)\n-    return TRUE;\t/* Already complained about this discrepancy. */\n-\n-  ai = &g->u.proc.arg_info[argno];\n-\n-  /* Warn about previous references.  */\n-\n-  if (ai->t != NULL)\n-    {\n-      const char *refwhy = NULL;\n-      const char *defwhy = NULL;\n-      bool fail = FALSE;\n-      bool warn = FALSE;\n-\n-      switch (as)\n-\t{\n-\tcase FFEGLOBAL_argsummaryNONE:\n-\t  if (g->u.proc.defined)\n-\t    {\n-\t      fail = TRUE;\n-\t      refwhy = \"omitted\";\n-\t      defwhy = \"not optional\";\n-\t    }\n-\t  break;\n-\n-\tcase FFEGLOBAL_argsummaryVAL:\n-\t  if (ai->as != FFEGLOBAL_argsummaryVAL)\n-\t    {\n-\t      fail = TRUE;\n-\t      refwhy = \"passed by value\";\n-\t    }\n-\t  break;\n-\n-\tcase FFEGLOBAL_argsummaryREF:\n-\t  if ((ai->as != FFEGLOBAL_argsummaryREF)\n-\t      && (ai->as != FFEGLOBAL_argsummaryNONE)\n-\t      && ((ai->as != FFEGLOBAL_argsummaryDESCR)\t/* Choose better message. */\n-\t\t  || (ai->bt != FFEINFO_basictypeCHARACTER)\n-\t\t  || (ai->bt == bt)))\n-\t    {\n-\t      fail = TRUE;\n-\t      refwhy = \"passed by reference\";\n-\t    }\n-\t  break;\n-\n-\tcase FFEGLOBAL_argsummaryDESCR:\n-\t  if ((ai->as != FFEGLOBAL_argsummaryDESCR)\n-\t      && (ai->as != FFEGLOBAL_argsummaryNONE)\n-\t      && ((ai->as != FFEGLOBAL_argsummaryREF)\t/* Choose better message. */\n-\t\t  || (bt != FFEINFO_basictypeCHARACTER)\n-\t\t  || (ai->bt == bt)))\n-\t    {\n-\t      fail = TRUE;\n-\t      refwhy = \"passed by descriptor\";\n-\t    }\n-\t  break;\n-\n-\tcase FFEGLOBAL_argsummaryPROC:\n-\t  if ((ai->as != FFEGLOBAL_argsummaryPROC)\n-\t      && (ai->as != FFEGLOBAL_argsummarySUBR)\n-\t      && (ai->as != FFEGLOBAL_argsummaryFUNC)\n-\t      && (ai->as != FFEGLOBAL_argsummaryNONE))\n-\t    {\n-\t      fail = TRUE;\n-\t      refwhy = \"a procedure\";\n-\t    }\n-\t  break;\n-\n-\tcase FFEGLOBAL_argsummarySUBR:\n-\t  if ((ai->as != FFEGLOBAL_argsummaryPROC)\n-\t      && (ai->as != FFEGLOBAL_argsummarySUBR)\n-\t      && (ai->as != FFEGLOBAL_argsummaryNONE))\n-\t    {\n-\t      fail = TRUE;\n-\t      refwhy = \"a subroutine\";\n-\t    }\n-\t  break;\n-\n-\tcase FFEGLOBAL_argsummaryFUNC:\n-\t  if ((ai->as != FFEGLOBAL_argsummaryPROC)\n-\t      && (ai->as != FFEGLOBAL_argsummaryFUNC)\n-\t      && (ai->as != FFEGLOBAL_argsummaryNONE))\n-\t    {\n-\t      fail = TRUE;\n-\t      refwhy = \"a function\";\n-\t    }\n-\t  break;\n-\n-\tcase FFEGLOBAL_argsummaryALTRTN:\n-\t  if ((ai->as != FFEGLOBAL_argsummaryALTRTN)\n-\t      && (ai->as != FFEGLOBAL_argsummaryNONE))\n-\t    {\n-\t      fail = TRUE;\n-\t      refwhy = \"an alternate-return label\";\n-\t    }\n-\t  break;\n-\n-#if 0\n-\tcase FFEGLOBAL_argsummaryPTR:\n-\t  if ((ai->as != FFEGLOBAL_argsummaryPTR)\n-\t      && (ai->as != FFEGLOBAL_argsummaryNONE))\n-\t    {\n-\t      fail = TRUE;\n-\t      refwhy = \"a pointer\";\n-\t    }\n-\t  break;\n-#endif\n-\n-\tdefault:\n-\t  break;\n-\t}\n-\n-      if ((refwhy != NULL) && (defwhy == NULL))\n-\t{\n-\t  /* Fill in the def info.  */\n-\n-\t  switch (ai->as)\n-\t    {\n-\t    case FFEGLOBAL_argsummaryNONE:\n-\t      defwhy = \"omitted\";\n-\t      break;\n-\n-\t    case FFEGLOBAL_argsummaryVAL:\n-\t      defwhy = \"passed by value\";\n-\t      break;\n-\n-\t    case FFEGLOBAL_argsummaryREF:\n-\t      defwhy = \"passed by reference\";\n-\t      break;\n-\n-\t    case FFEGLOBAL_argsummaryDESCR:\n-\t      defwhy = \"passed by descriptor\";\n-\t      break;\n-\n-\t    case FFEGLOBAL_argsummaryPROC:\n-\t      defwhy = \"a procedure\";\n-\t      break;\n-\n-\t    case FFEGLOBAL_argsummarySUBR:\n-\t      defwhy = \"a subroutine\";\n-\t      break;\n-\n-\t    case FFEGLOBAL_argsummaryFUNC:\n-\t      defwhy = \"a function\";\n-\t      break;\n-\n-\t    case FFEGLOBAL_argsummaryALTRTN:\n-\t      defwhy = \"an alternate-return label\";\n-\t      break;\n-\n-#if 0\n-\t    case FFEGLOBAL_argsummaryPTR:\n-\t      defwhy = \"a pointer\";\n-\t      break;\n-#endif\n-\n-\t    default:\n-\t      defwhy = \"???\";\n-\t      break;\n-\t    }\n-\t}\n-\n-      if (!fail && !warn\n-\t  && (bt != FFEINFO_basictypeHOLLERITH)\n-\t  && (bt != FFEINFO_basictypeTYPELESS)\n-\t  && (bt != FFEINFO_basictypeNONE)\n-\t  && (ai->bt != FFEINFO_basictypeHOLLERITH)\n-\t  && (ai->bt != FFEINFO_basictypeNONE)\n-\t  && (ai->bt != FFEINFO_basictypeTYPELESS))\n-\t{\n-\t  /* Check types.  */\n-\n-\t  if ((bt != ai->bt)\n-\t      && ((bt != FFEINFO_basictypeREAL)\n-\t\t  || (ai->bt != FFEINFO_basictypeCOMPLEX))\n-\t      && ((bt != FFEINFO_basictypeCOMPLEX)\n-\t\t  || (ai->bt != FFEINFO_basictypeREAL)))\n-\t    {\n-\t      if (((bt == FFEINFO_basictypeINTEGER)\n-\t\t   && (ai->bt == FFEINFO_basictypeLOGICAL))\n-\t\t  || ((bt == FFEINFO_basictypeLOGICAL)\n-\t\t   && (ai->bt == FFEINFO_basictypeINTEGER)))\n-\t\twarn = TRUE;\t/* We can cope with these differences. */\n-\t      else\n-\t\tfail = TRUE;\n-\t      refwhy = \"one type\";\n-\t      defwhy = \"some other type\";\n-\t    }\n-\n-\t  if (!fail && !warn && (kt != ai->kt))\n-\t    {\n-\t      fail = TRUE;\n-\t      refwhy = \"one precision\";\n-\t      defwhy = \"some other precision\";\n-\t    }\n-\t}\n-\n-      if (fail && ! g->u.proc.defined)\n-\t{\n-\t  /* No point failing if we're worried only about invocations.  */\n-\t  fail = FALSE;\n-\t  warn = TRUE;\n-\t}\n-\n-      if (fail && ! ffe_is_globals ())\n-\t{\n-\t  warn = TRUE;\n-\t  fail = FALSE;\n-\t}\n-\n-      if (fail || (warn && ffe_is_warn_globals ()))\n-\t{\n-\t  char num[60];\n-\n-\t  if (ai->name == NULL)\n-\t    sprintf (&num[0], \"%d\", argno + 1);\n-\t  else\n-\t    {\n-\t      if (strlen (ai->name) < 30)\n-\t\tsprintf (&num[0], \"%d (named `%s')\", argno + 1, ai->name);\n-\t      else\n-\t\tsprintf (&num[0], \"%d (named `%.*s...')\", argno + 1, 30, ai->name);\n-\t    }\n-\t  ffebad_start (fail ? FFEBAD_FILEWIDE_ARG : FFEBAD_FILEWIDE_ARG_W);\n-\t  ffebad_string (ffesymbol_text (s));\n-\t  ffebad_string (num);\n-\t  ffebad_string (refwhy);\n-\t  ffebad_string (defwhy);\n-\t  ffebad_here (0, ffelex_token_where_line (t), ffelex_token_where_column (t));\n-\t  ffebad_here (1, ffelex_token_where_line (ai->t), ffelex_token_where_column (ai->t));\n-\t  ffebad_finish ();\n-\t  return (fail ? FALSE : TRUE);\n-\t}\n-\n-      if (warn)\n-\treturn TRUE;\n-    }\n-\n-  /* Define this argument.  */\n-\n-  if (ai->t != NULL)\n-    ffelex_token_kill (ai->t);\n-  if ((as != FFEGLOBAL_argsummaryPROC)\n-      || (ai->t == NULL))\n-    ai->as = as;\n-  ai->t = ffelex_token_use (g->t);\n-  ai->name = NULL;\n-  ai->bt = bt;\n-  ai->kt = kt;\n-  ai->array = array;\n-  return TRUE;\n-}\n-\n-bool\n-ffeglobal_proc_ref_nargs (ffesymbol s, int n_args, ffelexToken t)\n-{\n-  ffeglobal g = ffesymbol_global (s);\n-\n-  assert (g != NULL);\n-\n-  if (g->type == FFEGLOBAL_typeANY)\n-    return FALSE;\n-\n-  if (g->u.proc.n_args >= 0)\n-    {\n-      if (g->u.proc.n_args == n_args)\n-\treturn TRUE;\n-\n-      if (g->u.proc.defined && ffe_is_globals ())\n-\t{\n-\t  ffebad_start (FFEBAD_FILEWIDE_NARGS);\n-\t  ffebad_string (ffesymbol_text (s));\n-\t  if (g->u.proc.n_args > n_args)\n-\t    ffebad_string (\"few\");\n-\t  else\n-\t    ffebad_string (\"many\");\n-\t  ffebad_here (0, ffelex_token_where_line (t), ffelex_token_where_column (t));\n-\t  ffebad_here (1, ffelex_token_where_line (g->t),\n-\t\t       ffelex_token_where_column (g->t));\n-\t  ffebad_finish ();\n-\t  return FALSE;\n-\t}\n-\n-      if (ffe_is_warn_globals ())\n-\t{\n-\t  ffebad_start (FFEBAD_FILEWIDE_NARGS_W);\n-\t  ffebad_string (ffesymbol_text (s));\n-\t  if (g->u.proc.n_args > n_args)\n-\t    ffebad_string (\"few\");\n-\t  else\n-\t    ffebad_string (\"many\");\n-\t  ffebad_here (0, ffelex_token_where_line (t), ffelex_token_where_column (t));\n-\t  ffebad_here (1, ffelex_token_where_line (g->t),\n-\t\t       ffelex_token_where_column (g->t));\n-\t  ffebad_finish ();\n-\t}\n-\n-      return TRUE;\t\t/* Don't replace the info we already have. */\n-    }\n-\n-  /* This is new info we can use in cross-checking future references\n-     and a possible future definition.  */\n-\n-  g->u.proc.n_args = n_args;\n-  g->u.proc.other_t = ffelex_token_use (t);\n-\n-  /* Make this \"the\" place we found the global, since it has the most info.  */\n-\n-  if (g->t != NULL)\n-    ffelex_token_kill (g->t);\n-  g->t = ffelex_token_use (t);\n-\n-  if (n_args == 0)\n-    {\n-      g->u.proc.arg_info = NULL;\n-      return TRUE;\n-    }\n-\n-  g->u.proc.arg_info = malloc_new_ks (malloc_pool_image (),\n-\t\t\t\t      \"ffeglobalArgInfo_\",\n-\t\t\t\t      n_args * sizeof (g->u.proc.arg_info[0]));\n-  while (n_args-- > 0)\n-    g->u.proc.arg_info[n_args].t = NULL;\n-\n-  return TRUE;\n-}\n-\n-/* Return a global for a promoted symbol (one that has heretofore\n-   been assumed to be local, but since discovered to be global).  */\n-\n-ffeglobal\n-ffeglobal_promoted (ffesymbol s)\n-{\n-#if FFEGLOBAL_ENABLED\n-  ffename n;\n-  ffeglobal g;\n-\n-  assert (ffesymbol_global (s) == NULL);\n-\n-  n = ffename_find (ffeglobal_filewide_, ffename_token (ffesymbol_name (s)));\n-  g = ffename_global (n);\n-\n-  return g;\n-#else\n-  return NULL;\n-#endif\n-}\n-\n-/* Register a reference to an intrinsic.  Such a reference is always\n-   valid, though a warning might be in order if the same name has\n-   already been used for a global.  */\n-\n-void\n-ffeglobal_ref_intrinsic (ffesymbol s, ffelexToken t, bool explicit)\n-{\n-#if FFEGLOBAL_ENABLED\n-  ffename n;\n-  ffeglobal g;\n-\n-  if (ffesymbol_global (s) == NULL)\n-    {\n-      n = ffename_find (ffeglobal_filewide_, t);\n-      g = ffename_global (n);\n-    }\n-  else\n-    {\n-      g = ffesymbol_global (s);\n-      n = NULL;\n-    }\n-\n-  if ((g != NULL) && (g->type == FFEGLOBAL_typeANY))\n-    return;\n-\n-  if ((g != NULL) && (g->type != FFEGLOBAL_typeNONE))\n-    {\n-      if (! explicit\n-\t  && ! g->intrinsic\n-\t  && ffe_is_warn_globals ())\n-\t{\n-\t  /* This name, previously used as a global, now is used\n-\t     for an intrinsic.  Warn, since this new use as an\n-\t     intrinsic might have been intended to refer to\n-\t     the global procedure.  */\n-\t  ffebad_start (FFEBAD_INTRINSIC_GLOBAL);\n-\t  ffebad_string (ffelex_token_text (t));\n-\t  ffebad_string (\"intrinsic\");\n-\t  ffebad_string (\"global\");\n-\t  ffebad_here (0, ffelex_token_where_line (t), ffelex_token_where_column (t));\n-\t  ffebad_here (1, ffelex_token_where_line (g->t),\n-\t\t       ffelex_token_where_column (g->t));\n-\t  ffebad_finish ();\n-\t}\n-    }\n-  else\n-    {\n-      if (g == NULL)\n-\t{\n-\t  g = ffeglobal_new_ (n);\n-\t  g->tick = ffe_count_2;\n-\t  g->type = FFEGLOBAL_typeNONE;\n-\t  g->intrinsic = TRUE;\n-\t  g->explicit_intrinsic = explicit;\n-\t  g->t = ffelex_token_use (t);\n-\t}\n-      else if (g->intrinsic\n-\t       && (explicit != g->explicit_intrinsic)\n-\t       && (g->tick != ffe_count_2)\n-\t       && ffe_is_warn_globals ())\n-\t{\n-\t  /* An earlier reference to this intrinsic disagrees with\n-\t     this reference vis-a-vis explicit `intrinsic foo',\n-\t     which suggests that the one relying on implicit\n-\t     intrinsicacity might have actually intended to refer\n-\t     to a global of the same name.  */\n-\t  ffebad_start (FFEBAD_INTRINSIC_EXPIMP);\n-\t  ffebad_string (ffelex_token_text (t));\n-\t  ffebad_string (explicit ? \"explicit\" : \"implicit\");\n-\t  ffebad_string (explicit ? \"implicit\" : \"explicit\");\n-\t  ffebad_here (0, ffelex_token_where_line (t), ffelex_token_where_column (t));\n-\t  ffebad_here (1, ffelex_token_where_line (g->t),\n-\t\t       ffelex_token_where_column (g->t));\n-\t  ffebad_finish ();\n-\t}\n-    }\n-\n-  g->intrinsic = TRUE;\n-  if (explicit)\n-    g->explicit_intrinsic = TRUE;\n-\n-  ffesymbol_set_global (s, g);\n-#endif\n-}\n-\n-/* Register a reference to a global.  Returns TRUE if the reference\n-   is valid.  */\n-\n-bool\n-ffeglobal_ref_progunit_ (ffesymbol s, ffelexToken t, ffeglobalType type)\n-{\n-#if FFEGLOBAL_ENABLED\n-  ffename n = NULL;\n-  ffeglobal g;\n-\n-  /* It is never really _known_ that an EXTERNAL statement\n-     names a BLOCK DATA by just looking at the program unit,\n-     so override a different notion here.  */\n-  if (type == FFEGLOBAL_typeBDATA)\n-    type = FFEGLOBAL_typeEXT;\n-\n-  g = ffesymbol_global (s);\n-  if (g == NULL)\n-    {\n-      n = ffename_find (ffeglobal_filewide_, t);\n-      g = ffename_global (n);\n-      if (g != NULL)\n-\tffesymbol_set_global (s, g);\n-    }\n-\n-  if ((g != NULL) && (g->type == FFEGLOBAL_typeANY))\n-    return TRUE;\n-\n-  if ((g != NULL)\n-      && (g->type != FFEGLOBAL_typeNONE)\n-      && (g->type != FFEGLOBAL_typeEXT)\n-      && (g->type != type)\n-      && (type != FFEGLOBAL_typeEXT))\n-    {\n-      /* Disagreement about (fully refined) class of program unit\n-\t (main, subroutine, function, block data).  Treat EXTERNAL/\n-\t COMMON disagreements distinctly.  */\n-      if ((((type == FFEGLOBAL_typeBDATA)\n-\t    && (g->type != FFEGLOBAL_typeCOMMON))\n-\t   || ((g->type == FFEGLOBAL_typeBDATA)\n-\t       && (type != FFEGLOBAL_typeCOMMON)\n-\t       && ! g->u.proc.defined)))\n-\t{\n-#if 0\t/* This is likely to just annoy people. */\n-\t  if (ffe_is_warn_globals ())\n-\t    {\n-\t      /* Warn about EXTERNAL of a COMMON name, though it works.  */\n-\t      ffebad_start (FFEBAD_FILEWIDE_TIFF);\n-\t      ffebad_string (ffelex_token_text (t));\n-\t      ffebad_string (ffeglobal_type_string_[type]);\n-\t      ffebad_string (ffeglobal_type_string_[g->type]);\n-\t      ffebad_here (0, ffelex_token_where_line (t),\n-\t\t\t   ffelex_token_where_column (t));\n-\t      ffebad_here (1, ffelex_token_where_line (g->t),\n-\t\t\t   ffelex_token_where_column (g->t));\n-\t      ffebad_finish ();\n-\t    }\n-#endif\n-\t}\n-      else if (ffe_is_globals () || ffe_is_warn_globals ())\n-\t{\n-\t  ffebad_start (ffe_is_globals ()\n-\t\t\t? FFEBAD_FILEWIDE_DISAGREEMENT\n-\t\t\t: FFEBAD_FILEWIDE_DISAGREEMENT_W);\n-\t  ffebad_string (ffelex_token_text (t));\n-\t  ffebad_string (ffeglobal_type_string_[type]);\n-\t  ffebad_string (ffeglobal_type_string_[g->type]);\n-\t  ffebad_here (0, ffelex_token_where_line (t),\n-\t\t       ffelex_token_where_column (t));\n-\t  ffebad_here (1, ffelex_token_where_line (g->t),\n-\t\t       ffelex_token_where_column (g->t));\n-\t  ffebad_finish ();\n-\t  g->type = FFEGLOBAL_typeANY;\n-\t  return (! ffe_is_globals ());\n-\t}\n-    }\n-\n-  if ((g != NULL)\n-      && (type == FFEGLOBAL_typeFUNC))\n-    {\n-      /* If just filling in this function's type, do so.  */\n-      if ((g->tick == ffe_count_2)\n-\t  && (ffesymbol_basictype (s) != FFEINFO_basictypeNONE)\n-\t  && (ffesymbol_kindtype (s) != FFEINFO_kindtypeNONE))\n-\t{\n-\t  g->u.proc.bt = ffesymbol_basictype (s);\n-\t  g->u.proc.kt = ffesymbol_kindtype (s);\n-\t  g->u.proc.sz = ffesymbol_size (s);\n-\t}\n-      /* Make sure there is type agreement.  */\n-      if (g->type == FFEGLOBAL_typeFUNC\n-\t  && g->u.proc.bt != FFEINFO_basictypeNONE\n-\t  && ffesymbol_basictype (s) != FFEINFO_basictypeNONE\n-\t  && (ffesymbol_basictype (s) != g->u.proc.bt\n-\t      || ffesymbol_kindtype (s) != g->u.proc.kt\n-\t      /* CHARACTER*n disagreements matter only once a\n-\t\t definition is involved, since the definition might\n-\t\t be CHARACTER*(*), which accepts all references.  */\n-\t      || (g->u.proc.defined\n-\t\t  && ffesymbol_size (s) != g->u.proc.sz\n-\t\t  && ffesymbol_size (s) != FFETARGET_charactersizeNONE\n-\t\t  && g->u.proc.sz != FFETARGET_charactersizeNONE)))\n-\t{\n-\t  int error;\n-\n-\t  /* Type mismatch between function reference/definition and\n-\t     this subsequent reference (which might just be the filling-in\n-\t     of type info for the definition, but we can't reach here\n-\t     if that's the case and there was a previous definition).\n-\n-\t     It's an error given a previous definition, since that\n-\t     implies inlining can crash the compiler, unless the user\n-\t     asked for no such inlining.  */\n-\t  error = (g->tick != ffe_count_2\n-\t\t   && g->u.proc.defined\n-\t\t   && ffe_is_globals ());\n-\t  if (error || ffe_is_warn_globals ())\n-\t    {\n-\t      ffebad_start (error\n-\t\t\t    ? FFEBAD_FILEWIDE_TYPE_MISMATCH\n-\t\t\t    : FFEBAD_FILEWIDE_TYPE_MISMATCH_W);\n-\t      ffebad_string (ffelex_token_text (t));\n-\t      if (g->tick == ffe_count_2)\n-\t\t{\n-\t\t  /* Current reference fills in type info for definition.\n-\t\t     The current token doesn't necessarily point to the actual\n-\t\t     definition of the function, so use the definition pointer\n-\t\t     and the pointer to the pre-definition type info.  */\n-\t\t  ffebad_here (0, ffelex_token_where_line (g->t),\n-\t\t\t       ffelex_token_where_column (g->t));\n-\t\t  ffebad_here (1, ffelex_token_where_line (g->u.proc.other_t),\n-\t\t\t       ffelex_token_where_column (g->u.proc.other_t));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* Current reference is not a filling-in of a current\n-\t\t     definition.  The current token is fine, as is\n-\t\t     the previous-mention token.  */\n-\t\t  ffebad_here (0, ffelex_token_where_line (t),\n-\t\t\t       ffelex_token_where_column (t));\n-\t\t  ffebad_here (1, ffelex_token_where_line (g->t),\n-\t\t\t       ffelex_token_where_column (g->t));\n-\t\t}\n-\t      ffebad_finish ();\n-\t      if (error)\n-\t\tg->type = FFEGLOBAL_typeANY;\n-\t      return FALSE;\n-\t    }\n-\t}\n-    }\n-\n-  if (g == NULL)\n-    {\n-      g = ffeglobal_new_ (n);\n-      g->t = ffelex_token_use (t);\n-      g->tick = ffe_count_2;\n-      g->intrinsic = FALSE;\n-      g->type = type;\n-      g->u.proc.defined = FALSE;\n-      g->u.proc.bt = ffesymbol_basictype (s);\n-      g->u.proc.kt = ffesymbol_kindtype (s);\n-      g->u.proc.sz = ffesymbol_size (s);\n-      g->u.proc.n_args = -1;\n-      ffesymbol_set_global (s, g);\n-    }\n-  else if (g->intrinsic\n-\t   && !g->explicit_intrinsic\n-\t   && (g->tick != ffe_count_2)\n-\t   && ffe_is_warn_globals ())\n-    {\n-      /* Now known as a global, this name previously was seen as an\n-\t intrinsic.  Warn, in case the previous reference was intended\n-\t for the same global.  */\n-      ffebad_start (FFEBAD_INTRINSIC_GLOBAL);\n-      ffebad_string (ffelex_token_text (t));\n-      ffebad_string (\"global\");\n-      ffebad_string (\"intrinsic\");\n-      ffebad_here (0, ffelex_token_where_line (t), ffelex_token_where_column (t));\n-      ffebad_here (1, ffelex_token_where_line (g->t),\n-\t\t   ffelex_token_where_column (g->t));\n-      ffebad_finish ();\n-    }\n-\n-  if ((g->type != type)\n-      && (type != FFEGLOBAL_typeEXT))\n-    {\n-      /* We've learned more, so point to where we learned it.  */\n-      g->t = ffelex_token_use (t);\n-      g->type = type;\n-      g->hook = FFECOM_globalNULL;\t/* Discard previous _DECL. */\n-      g->u.proc.n_args = -1;\n-    }\n-\n-  return TRUE;\n-#endif\n-}\n-\n-/* ffeglobal_save_common -- Check SAVE status of common area\n-\n-   ffesymbol s;\t // the common area\n-   bool save;  // TRUE if SAVEd, FALSE otherwise\n-   ffeglobal_save_common(s,save,ffesymbol_where_line(s),\n-\t ffesymbol_where_column(s));\n-\n-   In global-enabled mode, make sure the save info agrees with any existing\n-   info established for the common area, otherwise complain.\n-   In global-disabled mode, do nothing.\t */\n-\n-void\n-ffeglobal_save_common (ffesymbol s, bool save, ffewhereLine wl,\n-\t\t       ffewhereColumn wc)\n-{\n-#if FFEGLOBAL_ENABLED\n-  ffeglobal g;\n-\n-  g = ffesymbol_global (s);\n-  if ((g == NULL) || (g->type != FFEGLOBAL_typeCOMMON))\n-    return;\t\t\t/* Let someone else catch this! */\n-  if (g->type == FFEGLOBAL_typeANY)\n-    return;\n-\n-  if (!g->u.common.have_save)\n-    {\n-      g->u.common.have_save = TRUE;\n-      g->u.common.save = save;\n-      g->u.common.save_where_line = ffewhere_line_use (wl);\n-      g->u.common.save_where_col = ffewhere_column_use (wc);\n-    }\n-  else\n-    {\n-      if ((g->u.common.save != save) && ffe_is_pedantic ())\n-\t{\n-\t  ffebad_start (FFEBAD_COMMON_DIFF_SAVE);\n-\t  ffebad_string (ffesymbol_text (s));\n-\t  ffebad_here (save ? 0 : 1, wl, wc);\n-\t  ffebad_here (save ? 1 : 0, g->u.common.pad_where_line, g->u.common.pad_where_col);\n-\t  ffebad_finish ();\n-\t}\n-    }\n-#endif\n-}\n-\n-/* ffeglobal_size_common -- Establish size of COMMON area\n-\n-   ffesymbol s;\t // the common area\n-   ffetargetOffset size;  // size in units\n-   if (ffeglobal_size_common(s,size))  // new size is largest seen\n-\n-   In global-enabled mode, set the size if it current size isn't known or is\n-   smaller than new size, and for non-blank common, complain if old size\n-   is different from new.  Return TRUE if the new size is the largest seen\n-   for this COMMON area (or if no size was known for it previously).\n-   In global-disabled mode, do nothing.\t */\n-\n-#if FFEGLOBAL_ENABLED\n-bool\n-ffeglobal_size_common (ffesymbol s, ffetargetOffset size)\n-{\n-  ffeglobal g;\n-\n-  g = ffesymbol_global (s);\n-  if ((g == NULL) || (g->type != FFEGLOBAL_typeCOMMON))\n-    return FALSE;\n-  if (g->type == FFEGLOBAL_typeANY)\n-    return FALSE;\n-\n-  if (!g->u.common.have_size)\n-    {\n-      g->u.common.have_size = TRUE;\n-      g->u.common.size = size;\n-      return TRUE;\n-    }\n-\n-  if ((g->tick > 0) && (g->tick < ffe_count_2)\n-      && (g->u.common.size < size))\n-    {\n-      char oldsize[40];\n-      char newsize[40];\n-\n-      /* Common block initialized in a previous program unit, which\n-\t effectively freezes its size, but now the program is trying\n-\t to enlarge it.  */\n-\n-      sprintf (&oldsize[0], \"%\" ffetargetOffset_f \"d\", g->u.common.size);\n-      sprintf (&newsize[0], \"%\" ffetargetOffset_f \"d\", size);\n-\n-      ffebad_start (FFEBAD_COMMON_ENLARGED);\n-      ffebad_string (ffesymbol_text (s));\n-      ffebad_string (oldsize);\n-      ffebad_string (newsize);\n-      ffebad_string ((g->u.common.size == 1)\n-\t\t     ? FFECOM_SIZE_UNIT : FFECOM_SIZE_UNITS);\n-      ffebad_string ((size == 1)\n-\t\t     ? FFECOM_SIZE_UNIT : FFECOM_SIZE_UNITS);\n-      ffebad_here (0, ffelex_token_where_line (g->u.common.initt),\n-\t\t   ffelex_token_where_column (g->u.common.initt));\n-      ffebad_here (1, ffesymbol_where_line (s),\n-\t\t   ffesymbol_where_column (s));\n-      ffebad_finish ();\n-    }\n-  else if ((g->u.common.size != size) && !g->u.common.blank)\n-    {\n-      char oldsize[40];\n-      char newsize[40];\n-\n-      /* Warn about this even if not -pedantic, because putting all\n-\t program units in a single source file is the only way to\n-\t detect this.  Apparently UNIX-model linkers neither handle\n-\t nor report when they make a common unit smaller than\n-\t requested, such as when the smaller-declared version is\n-\t initialized and the larger-declared version is not.  So\n-\t if people complain about strange overwriting, we can tell\n-\t them to put all their code in a single file and compile\n-\t that way.  Warnings about differing sizes must therefore\n-\t always be issued.  */\n-\n-      sprintf (&oldsize[0], \"%\" ffetargetOffset_f \"d\", g->u.common.size);\n-      sprintf (&newsize[0], \"%\" ffetargetOffset_f \"d\", size);\n-\n-      ffebad_start (FFEBAD_COMMON_DIFF_SIZE);\n-      ffebad_string (ffesymbol_text (s));\n-      ffebad_string (oldsize);\n-      ffebad_string (newsize);\n-      ffebad_string ((g->u.common.size == 1)\n-\t\t     ? FFECOM_SIZE_UNIT : FFECOM_SIZE_UNITS);\n-      ffebad_string ((size == 1)\n-\t\t     ? FFECOM_SIZE_UNIT : FFECOM_SIZE_UNITS);\n-      ffebad_here (0, ffelex_token_where_line (g->t),\n-\t\t   ffelex_token_where_column (g->t));\n-      ffebad_here (1, ffesymbol_where_line (s),\n-\t\t   ffesymbol_where_column (s));\n-      ffebad_finish ();\n-    }\n-\n-  if (size > g->u.common.size)\n-    {\n-      g->u.common.size = size;\n-      return TRUE;\n-    }\n-\n-  return FALSE;\n-}\n-\n-#endif\n-void\n-ffeglobal_terminate_1 (void)\n-{\n-}"}, {"sha": "dc499df9eb7d47abcd6ae834b8fcc99535c1100d", "filename": "gcc/f/global.h", "status": "removed", "additions": 0, "deletions": 193, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fglobal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fglobal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fglobal.h?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,193 +0,0 @@\n-/* global.h -- Public #include File (module.h template V1.0)\n-   Copyright (C) 1995, 1997, 2003 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Owning Modules:\n-      global.c\n-\n-   Modifications:\n-*/\n-\n-/* Allow multiple inclusion to work. */\n-\n-#ifndef GCC_F_GLOBAL_H\n-#define GCC_F_GLOBAL_H\n-\n-/* Simple definitions and enumerations. */\n-\n-typedef enum\n-  {\n-    FFEGLOBAL_typeNONE,\n-    FFEGLOBAL_typeMAIN,\n-    FFEGLOBAL_typeEXT,\t\t/* EXTERNAL is all we know. */\n-    FFEGLOBAL_typeSUBR,\n-    FFEGLOBAL_typeFUNC,\n-    FFEGLOBAL_typeBDATA,\n-    FFEGLOBAL_typeCOMMON,\n-    FFEGLOBAL_typeANY,\t\t/* Confusion reigns, so just ignore. */\n-    FFEGLOBAL_type\n-  } ffeglobalType;\n-\n-typedef enum\n-  {\n-    FFEGLOBAL_argsummaryNONE,\t/* No arg present. */\n-    FFEGLOBAL_argsummaryVAL,\t/* Pass-by-value. */\n-    FFEGLOBAL_argsummaryREF,\t/* Pass-by-reference. */\n-    FFEGLOBAL_argsummaryDESCR,\t/* Pass-by-descriptor. */\n-    FFEGLOBAL_argsummaryPROC,\t/* Procedure (intrinsic, external). */\n-    FFEGLOBAL_argsummarySUBR,\t/* Subroutine (intrinsic, external). */\n-    FFEGLOBAL_argsummaryFUNC,\t/* Function (intrinsic, external). */\n-    FFEGLOBAL_argsummaryALTRTN,\t/* Alternate-return (label). */\n-    FFEGLOBAL_argsummaryANY,\n-    FFEGLOBAL_argsummary\n-  } ffeglobalArgSummary;\n-\n-/* Typedefs. */\n-\n-typedef struct _ffeglobal_arginfo_ *ffeglobalArgInfo_;\n-typedef struct _ffeglobal_ *ffeglobal;\n-\n-/* Include files needed by this one. */\n-\n-#include \"info.h\"\n-#include \"lex.h\"\n-#include \"name.h\"\n-#include \"symbol.h\"\n-#include \"target.h\"\n-#include \"top.h\"\n-\n-/* Structure definitions. */\n-\n-struct _ffeglobal_arginfo_\n-{\n-  ffelexToken t;\t/* Different from master token when difference is important. */\n-  char *name;\t\t/* Name of dummy arg, or NULL if not yet known. */\n-  ffeglobalArgSummary as;\n-  ffeinfoBasictype bt;\n-  ffeinfoKindtype kt;\n-  bool array;\n-};\n-\n-struct _ffeglobal_\n-{\n-  ffelexToken t;\n-  ffename n;\n-  ffecomGlobal hook;\n-  ffeCounter tick;\t\t/* Recent transition in this progunit. */\n-  ffeglobalType type;\n-  bool intrinsic;\t\t/* Known as intrinsic? */\n-  bool explicit_intrinsic;\t/* Explicit intrinsic? */\n-  union {\n-    struct {\n-      ffelexToken initt;\t/* First initial value. */\n-      bool have_pad;\t\t/* Padding info avail for COMMON? */\n-      ffetargetAlign pad;\t/* Initial padding for COMMON. */\n-      ffewhereLine pad_where_line;\n-      ffewhereColumn pad_where_col;\n-      bool have_save;\t\t/* Save info avail for COMMON? */\n-      bool save;\t\t/* Save info for COMMON. */\n-      ffewhereLine save_where_line;\n-      ffewhereColumn save_where_col;\n-      bool have_size;\t\t/* Size info avail for COMMON? */\n-      ffetargetOffset size;\t/* Size info for COMMON. */\n-      bool blank;\t\t/* TRUE if blank COMMON. */\n-    } common;\n-    struct {\n-      bool defined;\t\t/* Seen actual code yet? */\n-      ffeinfoBasictype bt;\t/* NONE for non-function. */\n-      ffeinfoKindtype kt;\t/* NONE for non-function. */\n-      ffetargetCharacterSize sz;\n-      int n_args;\t\t/* 0 for main/blockdata. */\n-      ffelexToken other_t;\t/* Location of reference. */\n-      ffeglobalArgInfo_ arg_info;\t/* Info on each argument. */\n-    } proc;\n-  } u;\n-};\n-\n-/* Global objects accessed by users of this module. */\n-\n-\n-/* Declare functions with prototypes. */\n-\n-void ffeglobal_drive (ffeglobal (*fn) (ffeglobal));\n-void ffeglobal_init_1 (void);\n-void ffeglobal_init_common (ffesymbol s, ffelexToken t);\n-void ffeglobal_new_progunit_ (ffesymbol s, ffelexToken t, ffeglobalType type);\n-void ffeglobal_new_common (ffesymbol s, ffelexToken t, bool blank);\n-void ffeglobal_pad_common (ffesymbol s, ffetargetAlign pad, ffewhereLine wl,\n-\t\t\t   ffewhereColumn wc);\n-void ffeglobal_proc_def_arg (ffesymbol s, int argno, const char *name, ffeglobalArgSummary as,\n-\t\t\t     ffeinfoBasictype bt, ffeinfoKindtype kt,\n-\t\t\t     bool array);\n-void ffeglobal_proc_def_nargs (ffesymbol s, int n_args);\n-bool ffeglobal_proc_ref_arg (ffesymbol s, int argno, ffeglobalArgSummary as,\n-\t\t\t     ffeinfoBasictype bt, ffeinfoKindtype kt,\n-\t\t\t     bool array, ffelexToken t);\n-bool ffeglobal_proc_ref_nargs (ffesymbol s, int n_args, ffelexToken t);\n-ffeglobal ffeglobal_promoted (ffesymbol s);\n-void ffeglobal_ref_intrinsic (ffesymbol s, ffelexToken t, bool explicit);\n-bool ffeglobal_ref_progunit_ (ffesymbol s, ffelexToken t, ffeglobalType type);\n-void ffeglobal_save_common (ffesymbol s, bool save, ffewhereLine wl,\n-\t\t\t    ffewhereColumn wc);\n-bool ffeglobal_size_common (ffesymbol s, ffetargetOffset size);\n-void ffeglobal_terminate_1 (void);\n-\n-/* Define macros. */\n-\n-#define FFEGLOBAL_ENABLED 1\n-\n-#define ffeglobal_common_init(g) ((g)->tick != 0)\n-#define ffeglobal_common_have_pad(g) ((g)->u.common.have_pad)\n-#define ffeglobal_common_have_size(g) ((g)->u.common.have_size)\n-#define ffeglobal_common_pad(g) ((g)->u.common.pad)\n-#define ffeglobal_common_size(g) ((g)->u.common.size)\n-#define ffeglobal_hook(g) ((g)->hook)\n-#define ffeglobal_init_0()\n-#define ffeglobal_init_2()\n-#define ffeglobal_init_3()\n-#define ffeglobal_init_4()\n-#define ffeglobal_new_blockdata(s,t) \\\n-      ffeglobal_new_progunit_(s,t,FFEGLOBAL_typeBDATA)\n-#define ffeglobal_new_function(s,t) \\\n-      ffeglobal_new_progunit_(s,t,FFEGLOBAL_typeFUNC)\n-#define ffeglobal_new_program(s,t) \\\n-      ffeglobal_new_progunit_(s,t,FFEGLOBAL_typeMAIN)\n-#define ffeglobal_new_subroutine(s,t) \\\n-      ffeglobal_new_progunit_(s,t,FFEGLOBAL_typeSUBR)\n-#define ffeglobal_ref_blockdata(s,t) \\\n-      ffeglobal_ref_progunit_(s,t,FFEGLOBAL_typeBDATA)\n-#define ffeglobal_ref_external(s,t) \\\n-      ffeglobal_ref_progunit_(s,t,FFEGLOBAL_typeEXT)\n-#define ffeglobal_ref_function(s,t) \\\n-      ffeglobal_ref_progunit_(s,t,FFEGLOBAL_typeFUNC)\n-#define ffeglobal_ref_subroutine(s,t) \\\n-      ffeglobal_ref_progunit_(s,t,FFEGLOBAL_typeSUBR)\n-#define ffeglobal_set_hook(g,h) ((g)->hook = (h))\n-#define ffeglobal_terminate_0()\n-#define ffeglobal_terminate_2()\n-#define ffeglobal_terminate_3()\n-#define ffeglobal_terminate_4()\n-#define ffeglobal_text(g) ffename_text((g)->n)\n-#define ffeglobal_type(g) ((g)->type)\n-\n-/* End of #include file. */\n-\n-#endif /* ! GCC_F_GLOBAL_H */\n-"}, {"sha": "c7a28cbc42acc6e23bf459a1ce7bbf1a4dbe02a3", "filename": "gcc/f/implic.c", "status": "removed", "additions": 0, "deletions": 383, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fimplic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fimplic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fimplic.c?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,383 +0,0 @@\n-/* implic.c -- Implementation File (module.c template V1.0)\n-   Copyright (C) 1995, 2002, 2003 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Related Modules:\n-      None.\n-\n-   Description:\n-      The GNU Fortran Front End.\n-\n-   Modifications:\n-*/\n-\n-/* Include files. */\n-\n-#include \"proj.h\"\n-#include \"implic.h\"\n-#include \"info.h\"\n-#include \"src.h\"\n-#include \"symbol.h\"\n-#include \"target.h\"\n-\n-/* Externals defined here. */\n-\n-\n-/* Simple definitions and enumerations. */\n-\n-typedef enum\n-  {\n-    FFEIMPLIC_stateINITIAL_,\n-    FFEIMPLIC_stateASSUMED_,\n-    FFEIMPLIC_stateESTABLISHED_,\n-    FFEIMPLIC_state\n-  } ffeimplicState_;\n-\n-/* Internal typedefs. */\n-\n-typedef struct _ffeimplic_ *ffeimplic_;\n-\n-/* Private include files. */\n-\n-\n-/* Internal structure definitions. */\n-\n-struct _ffeimplic_\n-  {\n-    ffeimplicState_ state;\n-    ffeinfo info;\n-  };\n-\n-/* Static objects accessed by functions in this module. */\n-\n-/* NOTE: This is definitely ASCII-specific!!  */\n-\n-static struct _ffeimplic_ ffeimplic_table_['z' - 'A' + 1];\n-\n-/* Static functions (internal). */\n-\n-static ffeimplic_ ffeimplic_lookup_ (unsigned char c);\n-\n-/* Internal macros. */\n-\f\n-\n-/* ffeimplic_lookup_ -- Look up implicit descriptor for initial character\n-\n-   ffeimplic_ imp;\n-   if ((imp = ffeimplic_lookup_('A')) == NULL)\n-       // error\n-\n-   Returns a pointer to an implicit descriptor block based on the character\n-   passed, or NULL if it is not a valid initial character for an implicit\n-   data type.  */\n-\n-static ffeimplic_\n-ffeimplic_lookup_ (unsigned char c)\n-{\n-  /* NOTE: This is definitely ASCII-specific!!  */\n-  if (ISIDST (c))\n-    return &ffeimplic_table_[c - 'A'];\n-  return NULL;\n-}\n-\n-/* ffeimplic_establish_initial -- Establish type of implicit initial letter\n-\n-   ffesymbol s;\n-   if (!ffeimplic_establish_initial(s))\n-       // error\n-\n-   Assigns implicit type information to the symbol based on the first\n-   character of the symbol's name.  */\n-\n-bool\n-ffeimplic_establish_initial (char c, ffeinfoBasictype basic_type,\n-\t\t     ffeinfoKindtype kind_type, ffetargetCharacterSize size)\n-{\n-  ffeimplic_ imp;\n-\n-  imp = ffeimplic_lookup_ (c);\n-  if (imp == NULL)\n-    return FALSE;\t\t/* Character not A-Z or some such thing. */\n-  if (ffeinfo_basictype (imp->info) == FFEINFO_basictypeNONE)\n-    return FALSE;\t\t/* IMPLICIT NONE in effect here. */\n-\n-  switch (imp->state)\n-    {\n-    case FFEIMPLIC_stateINITIAL_:\n-      imp->info = ffeinfo_new (basic_type,\n-\t\t\t       kind_type,\n-\t\t\t       0,\n-\t\t\t       FFEINFO_kindNONE,\n-\t\t\t       FFEINFO_whereNONE,\n-\t\t\t       size);\n-      imp->state = FFEIMPLIC_stateESTABLISHED_;\n-      return TRUE;\n-\n-    case FFEIMPLIC_stateASSUMED_:\n-      if ((ffeinfo_basictype (imp->info) != basic_type)\n-\t  || (ffeinfo_kindtype (imp->info) != kind_type)\n-\t  || (ffeinfo_size (imp->info) != size))\n-\treturn FALSE;\n-      imp->state = FFEIMPLIC_stateESTABLISHED_;\n-      return TRUE;\n-\n-    case FFEIMPLIC_stateESTABLISHED_:\n-      return FALSE;\n-\n-    default:\n-      assert (\"Weird state for implicit object\" == NULL);\n-      return FALSE;\n-    }\n-}\n-\n-/* ffeimplic_establish_symbol -- Establish implicit type of a symbol\n-\n-   ffesymbol s;\n-   if (!ffeimplic_establish_symbol(s))\n-       // error\n-\n-   Assigns implicit type information to the symbol based on the first\n-   character of the symbol's name.\n-\n-   If symbol already has a type, return TRUE.\n-   Get first character of symbol's name.\n-   Get ffeimplic_ object for it (return FALSE if NULL returned).\n-   Return FALSE if object has no assigned type (IMPLICIT NONE).\n-   Copy the type information from the object to the symbol.\n-   If the object is state \"INITIAL\", set to state \"ASSUMED\" so no\n-       subsequent IMPLICIT statement may change the state.\n-   Return TRUE.\t */\n-\n-bool\n-ffeimplic_establish_symbol (ffesymbol s)\n-{\n-  char c;\n-  ffeimplic_ imp;\n-\n-  if (ffesymbol_basictype (s) != FFEINFO_basictypeNONE)\n-    return TRUE;\n-\n-  c = *(ffesymbol_text (s));\n-  imp = ffeimplic_lookup_ (c);\n-  if (imp == NULL)\n-    return FALSE;\t\t/* First character not A-Z or some such\n-\t\t\t\t   thing. */\n-  if (ffeinfo_basictype (imp->info) == FFEINFO_basictypeNONE)\n-    return FALSE;\t\t/* IMPLICIT NONE in effect here. */\n-\n-  ffesymbol_signal_change (s);\t/* Gonna change, save existing? */\n-\n-  /* Establish basictype, kindtype, size; preserve rank, kind, where. */\n-\n-  ffesymbol_set_info (s,\n-\t\t      ffeinfo_new (ffeinfo_basictype (imp->info),\n-\t\t\t\t   ffeinfo_kindtype (imp->info),\n-\t\t\t\t   ffesymbol_rank (s),\n-\t\t\t\t   ffesymbol_kind (s),\n-\t\t\t\t   ffesymbol_where (s),\n-\t\t\t\t   ffeinfo_size (imp->info)));\n-\n-  if (imp->state == FFEIMPLIC_stateINITIAL_)\n-    imp->state = FFEIMPLIC_stateASSUMED_;\n-\n-  if (ffe_is_warn_implicit ())\n-    {\n-      /* xgettext:no-c-format */\n-      ffebad_start_msg (\"Implicit declaration of `%A' at %0\",\n-\t\t\tFFEBAD_severityWARNING);\n-      ffebad_here (0, ffesymbol_where_line (s),\n-\t\t   ffesymbol_where_column (s));\n-      ffebad_string (ffesymbol_text (s));\n-      ffebad_finish ();\n-    }\n-\n-  return TRUE;\n-}\n-\n-/* ffeimplic_init_2 -- Initialize table\n-\n-   ffeimplic_init_2();\n-\n-   Assigns initial type information to all initial letters.\n-\n-   Allows for holes in the sequence of letters (i.e. EBCDIC).  */\n-\n-void\n-ffeimplic_init_2 (void)\n-{\n-  ffeimplic_ imp;\n-  char c;\n-\n-  for (c = 'A'; c <= 'z'; ++c)\n-    {\n-      imp = &ffeimplic_table_[c - 'A'];\n-      imp->state = FFEIMPLIC_stateINITIAL_;\n-      switch (c)\n-\t{\n-\tcase 'A':\n-\tcase 'B':\n-\tcase 'C':\n-\tcase 'D':\n-\tcase 'E':\n-\tcase 'F':\n-\tcase 'G':\n-\tcase 'H':\n-\tcase 'O':\n-\tcase 'P':\n-\tcase 'Q':\n-\tcase 'R':\n-\tcase 'S':\n-\tcase 'T':\n-\tcase 'U':\n-\tcase 'V':\n-\tcase 'W':\n-\tcase 'X':\n-\tcase 'Y':\n-\tcase 'Z':\n-\tcase '_':\n-\tcase 'a':\n-\tcase 'b':\n-\tcase 'c':\n-\tcase 'd':\n-\tcase 'e':\n-\tcase 'f':\n-\tcase 'g':\n-\tcase 'h':\n-\tcase 'o':\n-\tcase 'p':\n-\tcase 'q':\n-\tcase 'r':\n-\tcase 's':\n-\tcase 't':\n-\tcase 'u':\n-\tcase 'v':\n-\tcase 'w':\n-\tcase 'x':\n-\tcase 'y':\n-\tcase 'z':\n-\t  imp->info = ffeinfo_new (FFEINFO_basictypeREAL,\n-\t\t\t\t   FFEINFO_kindtypeREALDEFAULT,\n-\t\t\t\t   0,\n-\t\t\t\t   FFEINFO_kindNONE,\n-\t\t\t\t   FFEINFO_whereNONE,\n-\t\t\t\t   FFETARGET_charactersizeNONE);\n-\t  break;\n-\n-\tcase 'I':\n-\tcase 'J':\n-\tcase 'K':\n-\tcase 'L':\n-\tcase 'M':\n-\tcase 'N':\n-\tcase 'i':\n-\tcase 'j':\n-\tcase 'k':\n-\tcase 'l':\n-\tcase 'm':\n-\tcase 'n':\n-\t  imp->info = ffeinfo_new (FFEINFO_basictypeINTEGER,\n-\t\t\t\t   FFEINFO_kindtypeINTEGERDEFAULT, 0, FFEINFO_kindNONE, FFEINFO_whereNONE,\n-\t\t\t\t   FFETARGET_charactersizeNONE);\n-\t  break;\n-\n-\tdefault:\n-\t  imp->info = ffeinfo_new (FFEINFO_basictypeNONE, FFEINFO_kindtypeNONE, 0,\n-\t  FFEINFO_kindNONE, FFEINFO_whereNONE, FFETARGET_charactersizeNONE);\n-\t  break;\n-\t}\n-    }\n-}\n-\n-/* ffeimplic_none -- Implement IMPLICIT NONE statement\n-\n-   ffeimplic_none();\n-\n-   Assigns null type information to all initial letters.  */\n-\n-void\n-ffeimplic_none (void)\n-{\n-  ffeimplic_ imp;\n-\n-  for (imp = &ffeimplic_table_[0];\n-       imp != &ffeimplic_table_[ARRAY_SIZE (ffeimplic_table_)];\n-       imp++)\n-    {\n-      imp->info = ffeinfo_new (FFEINFO_basictypeNONE,\n-\t\t\t       FFEINFO_kindtypeNONE,\n-\t\t\t       0,\n-\t\t\t       FFEINFO_kindNONE,\n-\t\t\t       FFEINFO_whereNONE,\n-\t\t\t       FFETARGET_charactersizeNONE);\n-    }\n-}\n-\n-/* ffeimplic_peek_symbol_type -- Determine implicit type of a symbol\n-\n-   ffesymbol s;\n-   const char *name; // name for s in case it is NULL, or NULL if s never NULL\n-   if (ffeimplic_peek_symbol_type(s,name) == FFEINFO_basictypeCHARACTER)\n-       // is or will be a CHARACTER-typed name\n-\n-   Like establish_symbol, but doesn't change anything.\n-\n-   If symbol is non-NULL and already has a type, return it.\n-   Get first character of symbol's name or from name arg if symbol is NULL.\n-   Get ffeimplic_ object for it (return FALSE if NULL returned).\n-   Return NONE if object has no assigned type (IMPLICIT NONE).\n-   Return the data type indicated in the object.\n-\n-   24-Oct-91  JCB  2.0\n-      Take a char * instead of ffelexToken, since the latter isn't always\n-      needed anyway (as when ffecom calls it).\t*/\n-\n-ffeinfoBasictype\n-ffeimplic_peek_symbol_type (ffesymbol s, const char *name)\n-{\n-  char c;\n-  ffeimplic_ imp;\n-\n-  if (s == NULL)\n-    c = *name;\n-  else\n-    {\n-      if (ffesymbol_basictype (s) != FFEINFO_basictypeNONE)\n-\treturn ffesymbol_basictype (s);\n-\n-      c = *(ffesymbol_text (s));\n-    }\n-\n-  imp = ffeimplic_lookup_ (c);\n-  if (imp == NULL)\n-    return FFEINFO_basictypeNONE;\t/* First character not A-Z or\n-\t\t\t\t\t   something. */\n-  return ffeinfo_basictype (imp->info);\n-}\n-\n-/* ffeimplic_terminate_2 -- Terminate table\n-\n-   ffeimplic_terminate_2();\n-\n-   Kills info object for each entry in table.  */\n-\n-void\n-ffeimplic_terminate_2 (void)\n-{\n-}"}, {"sha": "44fbfac4e4fa1d0bb6aea3bbe2150be4967a97dc", "filename": "gcc/f/implic.h", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fimplic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fimplic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fimplic.h?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,74 +0,0 @@\n-/* implic.h -- Public #include File (module.h template V1.0)\n-   Copyright (C) 1995 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Owning Modules:\n-      implic.c\n-\n-   Modifications:\n-*/\n-\n-/* Allow multiple inclusion to work. */\n-\n-#ifndef GCC_F_IMPLIC_H\n-#define GCC_F_IMPLIC_H\n-\n-/* Simple definitions and enumerations. */\n-\n-\n-/* Typedefs. */\n-\n-\n-/* Include files needed by this one. */\n-\n-#include \"info.h\"\n-#include \"symbol.h\"\n-#include \"target.h\"\n-\n-/* Structure definitions. */\n-\n-\n-/* Global objects accessed by users of this module. */\n-\n-\n-/* Declare functions with prototypes. */\n-\n-bool ffeimplic_establish_initial (char c, ffeinfoBasictype basic_type,\n-\t\t    ffeinfoKindtype kind_type, ffetargetCharacterSize size);\n-bool ffeimplic_establish_symbol (ffesymbol s);\n-void ffeimplic_init_2 (void);\n-void ffeimplic_none (void);\n-ffeinfoBasictype ffeimplic_peek_symbol_type (ffesymbol s, const char *name);\n-void ffeimplic_terminate_2 (void);\n-\n-/* Define macros. */\n-\n-#define ffeimplic_init_0()\n-#define ffeimplic_init_1()\n-#define ffeimplic_init_3()\n-#define ffeimplic_init_4()\n-#define ffeimplic_terminate_0()\n-#define ffeimplic_terminate_1()\n-#define ffeimplic_terminate_3()\n-#define ffeimplic_terminate_4()\n-\n-/* End of #include file. */\n-\n-#endif /* ! GCC_F_IMPLIC_H */"}, {"sha": "088d108f05539a9d1b416d3aaff07fb0d8d4cbf8", "filename": "gcc/f/info-b.def", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Finfo-b.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Finfo-b.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Finfo-b.def?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,36 +0,0 @@\n-/* info-b.def -- Public #include File (module.h template V1.0)\n-   Copyright (C) 1995 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Owning Modules:\n-      info.c\n-\n-   Modifications:\n-*/\n-\n-FFEINFO_BASICTYPE (FFEINFO_basictypeNONE, \"None\", \"\")\n-FFEINFO_BASICTYPE (FFEINFO_basictypeINTEGER, \"INTEGER\", \"i\")\n-FFEINFO_BASICTYPE (FFEINFO_basictypeLOGICAL, \"LOGICAL\", \"l\")\n-FFEINFO_BASICTYPE (FFEINFO_basictypeREAL, \"REAL\", \"r\")\n-FFEINFO_BASICTYPE (FFEINFO_basictypeCOMPLEX, \"COMPLEX\", \"c\")\n-FFEINFO_BASICTYPE (FFEINFO_basictypeCHARACTER, \"CHARACTER\", \"a\")\n-FFEINFO_BASICTYPE (FFEINFO_basictypeHOLLERITH, \"Hollerith\", \"h\")\n-FFEINFO_BASICTYPE (FFEINFO_basictypeTYPELESS, \"Typeless\", \"t\")\n-FFEINFO_BASICTYPE (FFEINFO_basictypeANY, \"Any\", \"~\")"}, {"sha": "9e6052d61502655bc8f9a324ed2917816386da99", "filename": "gcc/f/info-k.def", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Finfo-k.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Finfo-k.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Finfo-k.def?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,41 +0,0 @@\n-/* info-k.def -- Public #include File (module.h template V1.0)\n-   Copyright (C) 1995, 2002 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Owning Modules:\n-      info.c\n-\n-   Modifications:\n-*/\n-\n-#\n-/* Kind messages are used in diagnostic location reports of the\n-   form \"<file>: In function `foo': <error message>\". */\n-\n-FFEINFO_KIND (FFEINFO_kindNONE, \"In unknown kind\", \"\")\n-FFEINFO_KIND (FFEINFO_kindENTITY, \"In entity\", \"e\")\n-FFEINFO_KIND (FFEINFO_kindFUNCTION, \"In function\", \"f\")\n-FFEINFO_KIND (FFEINFO_kindSUBROUTINE, \"In subroutine\", \"u\")\n-FFEINFO_KIND (FFEINFO_kindPROGRAM, \"In program\", \"p\")\n-FFEINFO_KIND (FFEINFO_kindBLOCKDATA, \"In block-data unit\", \"b\")\n-FFEINFO_KIND (FFEINFO_kindCOMMON, \"In common block\", \"c\")\n-FFEINFO_KIND (FFEINFO_kindCONSTRUCT, \"In construct\", \":\")\n-FFEINFO_KIND (FFEINFO_kindNAMELIST, \"In namelist\", \"n\")\n-FFEINFO_KIND (FFEINFO_kindANY, \"In anything\", \"~\")"}, {"sha": "57e3f8c6d628146513ff98047fa54e1bb0850a51", "filename": "gcc/f/info-w.def", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Finfo-w.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Finfo-w.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Finfo-w.def?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,41 +0,0 @@\n-/* info-w.def -- Public #include File (module.h template V1.0)\n-   Copyright (C) 1995 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Owning Modules:\n-      info.c\n-\n-   Modifications:\n-*/\n-\n-FFEINFO_WHERE (FFEINFO_whereNONE, \"None\", \"\")\n-FFEINFO_WHERE (FFEINFO_whereLOCAL, \"Local\", \"l\")\t/* Defined locally. */\n-FFEINFO_WHERE (FFEINFO_whereCOMMON, \"Common\", \"c\")\t/* In a common area. */\n-FFEINFO_WHERE (FFEINFO_whereDUMMY, \"Dummy\", \"d\")\t/* A dummy argument. */\n-FFEINFO_WHERE (FFEINFO_whereGLOBAL, \"Global\", \"g\")\t/* Reference to external global like FUNCTION, SUBR. */\n-FFEINFO_WHERE (FFEINFO_whereRESULT, \"Result\", \"r\")\t/* Result of this function. */\n-FFEINFO_WHERE (FFEINFO_whereFLEETING, \"Fleeting\", \"f\")\t\t/* Result of \"X*Y\", \"FUNCREF(5,1.3)\", \"ARRAY(X)\", etc. */\n-FFEINFO_WHERE (FFEINFO_whereFLEETING_CADDR, \"Fleet-Const\", \"fp\")\t/* \"A(3)\", \"CHARS(4:5)\". */\n-FFEINFO_WHERE (FFEINFO_whereFLEETING_IADDR, \"Fleet-Immed\", \"fi\")\t/* A(IX) in \"DATA (A(IX),IX=1,100)/.../\". */\n-FFEINFO_WHERE (FFEINFO_whereIMMEDIATE, \"Immediate\", \"i\")\t/* IX in \"DATA (A(IX),IX=1,100)/.../\". */\n-FFEINFO_WHERE (FFEINFO_whereINTRINSIC, \"Intrinsic\", \"b\")\n-FFEINFO_WHERE (FFEINFO_whereCONSTANT, \"Constant\", \"p\")\t\t/* For kindFUNCTION, means statement function! */\n-FFEINFO_WHERE (FFEINFO_whereCONSTANT_SUBOBJECT, \"Const-subobj\", \"q\")\t/* As in \"'FOO'(I:J)\". */\n-FFEINFO_WHERE (FFEINFO_whereANY, \"Any\", \"~\")"}, {"sha": "3c0030f27f8f172514fb5a3719d1c473f9227452", "filename": "gcc/f/info.c", "status": "removed", "additions": 0, "deletions": 303, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Finfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Finfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Finfo.c?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,303 +0,0 @@\n-/* info.c -- Implementation File (module.c template V1.0)\n-   Copyright (C) 1995, 2002, 2003 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Related Modules:\n-      None\n-\n-   Description:\n-      An abstraction for information maintained on a per-operator and per-\n-      operand basis in expression trees.\n-\n-   Modifications:\n-      30-Aug-90\t JCB  2.0\n-\t Extensive rewrite for new cleaner approach.\n-*/\n-\n-/* Include files. */\n-\n-#include \"proj.h\"\n-#include \"info.h\"\n-#include \"target.h\"\n-#include \"type.h\"\n-\n-/* Externals defined here. */\n-\n-\n-/* Simple definitions and enumerations. */\n-\n-\n-/* Internal typedefs. */\n-\n-\n-/* Private include files. */\n-\n-\n-/* Internal structure definitions. */\n-\n-\n-/* Static objects accessed by functions in this module.\t */\n-\n-static const char *const ffeinfo_basictype_string_[]\n-=\n-{\n-#define FFEINFO_BASICTYPE(KWD,LNAM,SNAM) SNAM,\n-#include \"info-b.def\"\n-#undef FFEINFO_BASICTYPE\n-};\n-static const char *const ffeinfo_kind_message_[]\n-=\n-{\n-#define FFEINFO_KIND(kwd,msgid,snam) msgid,\n-#include \"info-k.def\"\n-#undef FFEINFO_KIND\n-};\n-static const char *const ffeinfo_kind_string_[]\n-=\n-{\n-#define FFEINFO_KIND(KWD,LNAM,SNAM) SNAM,\n-#include \"info-k.def\"\n-#undef FFEINFO_KIND\n-};\n-static ffeinfoBasictype ffeinfo_combine_[FFEINFO_basictype][FFEINFO_basictype];\n-static const char *const ffeinfo_kindtype_string_[]\n-=\n-{\n-  \"\",\n-  \"1\",\n-  \"2\",\n-  \"3\",\n-  \"4\",\n-  \"5\",\n-  \"6\",\n-  \"7\",\n-  \"8\",\n-  \"*\",\n-};\n-static const char *const ffeinfo_where_string_[]\n-=\n-{\n-#define FFEINFO_WHERE(KWD,LNAM,SNAM) SNAM,\n-#include \"info-w.def\"\n-#undef FFEINFO_WHERE\n-};\n-static ffetype ffeinfo_types_[FFEINFO_basictype][FFEINFO_kindtype];\n-\n-/* Static functions (internal). */\n-\n-\n-/* Internal macros. */\n-\f\n-\n-/* ffeinfo_basictype_combine -- Combine two basictypes into highest rank type\n-\n-   ffeinfoBasictype i, j, k;\n-   k = ffeinfo_basictype_combine(i,j);\n-\n-   Returns a type based on \"standard\" operation between two given types.  */\n-\n-ffeinfoBasictype\n-ffeinfo_basictype_combine (ffeinfoBasictype l, ffeinfoBasictype r)\n-{\n-  assert (l < FFEINFO_basictype);\n-  assert (r < FFEINFO_basictype);\n-  return ffeinfo_combine_[l][r];\n-}\n-\n-/* ffeinfo_basictype_string -- Return tiny string showing the basictype\n-\n-   ffeinfoBasictype i;\n-   printf(\"%s\",ffeinfo_basictype_string(dt));\n-\n-   Returns the string based on the basic type.\t*/\n-\n-const char *\n-ffeinfo_basictype_string (ffeinfoBasictype basictype)\n-{\n-  if (basictype >= ARRAY_SIZE (ffeinfo_basictype_string_))\n-    return \"?\\?\\?\";\n-  return ffeinfo_basictype_string_[basictype];\n-}\n-\n-/* ffeinfo_init_0 -- Initialize\n-\n-   ffeinfo_init_0();  */\n-\n-void\n-ffeinfo_init_0 (void)\n-{\n-  ffeinfoBasictype i;\n-  ffeinfoBasictype j;\n-\n-  assert (FFEINFO_basictype == ARRAY_SIZE (ffeinfo_basictype_string_));\n-  assert (FFEINFO_kind == ARRAY_SIZE (ffeinfo_kind_message_));\n-  assert (FFEINFO_kind == ARRAY_SIZE (ffeinfo_kind_string_));\n-  assert (FFEINFO_kindtype == ARRAY_SIZE (ffeinfo_kindtype_string_));\n-  assert (FFEINFO_where == ARRAY_SIZE (ffeinfo_where_string_));\n-\n-  /* Make array that, given two basic types, produces resulting basic type. */\n-\n-  for (i = 0; i < FFEINFO_basictype; ++i)\n-    for (j = 0; j < FFEINFO_basictype; ++j)\n-      if ((i == FFEINFO_basictypeANY) || (j == FFEINFO_basictypeANY))\n-\tffeinfo_combine_[i][j] = FFEINFO_basictypeANY;\n-      else\n-\tffeinfo_combine_[i][j] = FFEINFO_basictypeNONE;\n-\n-#define same(bt) ffeinfo_combine_[bt][bt] = bt\n-#define use2(bt1,bt2) ffeinfo_combine_[bt1][bt2]  \\\n-      = ffeinfo_combine_[bt2][bt1] = bt2\n-\n-  same (FFEINFO_basictypeINTEGER);\n-  same (FFEINFO_basictypeLOGICAL);\n-  same (FFEINFO_basictypeREAL);\n-  same (FFEINFO_basictypeCOMPLEX);\n-  same (FFEINFO_basictypeCHARACTER);\n-  use2 (FFEINFO_basictypeINTEGER, FFEINFO_basictypeREAL);\n-  use2 (FFEINFO_basictypeINTEGER, FFEINFO_basictypeCOMPLEX);\n-  use2 (FFEINFO_basictypeREAL, FFEINFO_basictypeCOMPLEX);\n-\n-#undef same\n-#undef use2\n-}\n-\n-/* ffeinfo_kind_message -- Return helpful string showing the kind\n-\n-   ffeinfoKind kind;\n-   printf(\"%s\",ffeinfo_kind_message(kind));\n-\n-   Returns the string based on the kind.  */\n-\n-const char *\n-ffeinfo_kind_message (ffeinfoKind kind)\n-{\n-  if (kind >= ARRAY_SIZE (ffeinfo_kind_message_))\n-    return \"?\\?\\?\";\n-  return ffeinfo_kind_message_[kind];\n-}\n-\n-/* ffeinfo_kind_string -- Return tiny string showing the kind\n-\n-   ffeinfoKind kind;\n-   printf(\"%s\",ffeinfo_kind_string(kind));\n-\n-   Returns the string based on the kind.  */\n-\n-const char *\n-ffeinfo_kind_string (ffeinfoKind kind)\n-{\n-  if (kind >= ARRAY_SIZE (ffeinfo_kind_string_))\n-    return \"?\\?\\?\";\n-  return ffeinfo_kind_string_[kind];\n-}\n-\n-ffeinfoKindtype\n-ffeinfo_kindtype_max(ffeinfoBasictype bt,\n-\t\t     ffeinfoKindtype k1,\n-\t\t     ffeinfoKindtype k2)\n-{\n-  if ((bt == FFEINFO_basictypeANY)\n-      || (k1 == FFEINFO_kindtypeANY)\n-      || (k2 == FFEINFO_kindtypeANY))\n-    return FFEINFO_kindtypeANY;\n-\n-  if (ffetype_size (ffeinfo_types_[bt][k1])\n-      > ffetype_size (ffeinfo_types_[bt][k2]))\n-    return k1;\n-  return k2;\n-}\n-\n-/* ffeinfo_kindtype_string -- Return tiny string showing the kind type\n-\n-   ffeinfoKindtype kind_type;\n-   printf(\"%s\",ffeinfo_kindtype_string(kind));\n-\n-   Returns the string based on the kind type.  */\n-\n-const char *\n-ffeinfo_kindtype_string (ffeinfoKindtype kind_type)\n-{\n-  if (kind_type >= ARRAY_SIZE (ffeinfo_kindtype_string_))\n-    return \"?\\?\\?\";\n-  return ffeinfo_kindtype_string_[kind_type];\n-}\n-\n-void\n-ffeinfo_set_type (ffeinfoBasictype basictype, ffeinfoKindtype kindtype,\n-\t\t  ffetype type)\n-{\n-  assert (basictype < FFEINFO_basictype);\n-  assert (kindtype < FFEINFO_kindtype);\n-  assert (ffeinfo_types_[basictype][kindtype] == NULL);\n-\n-  ffeinfo_types_[basictype][kindtype] = type;\n-}\n-\n-ffetype\n-ffeinfo_type (ffeinfoBasictype basictype, ffeinfoKindtype kindtype)\n-{\n-  assert (basictype < FFEINFO_basictype);\n-  assert (kindtype < FFEINFO_kindtype);\n-\n-  return ffeinfo_types_[basictype][kindtype];\n-}\n-\n-/* ffeinfo_where_string -- Return tiny string showing the where\n-\n-   ffeinfoWhere where;\n-   printf(\"%s\",ffeinfo_where_string(where));\n-\n-   Returns the string based on the where.  */\n-\n-const char *\n-ffeinfo_where_string (ffeinfoWhere where)\n-{\n-  if (where >= ARRAY_SIZE (ffeinfo_where_string_))\n-    return \"?\\?\\?\";\n-  return ffeinfo_where_string_[where];\n-}\n-\n-/* ffeinfo_new -- Return object representing datatype, kind, and where info\n-\n-   ffeinfo i;\n-   i = ffeinfo_new(FFEINFO_datatypeINTEGER,FFEINFO_kindSCALAR,\n-       FFEINFO_whereLOCAL);\n-\n-   Returns the string based on the data type.  */\n-\n-#ifndef __GNUC__\n-ffeinfo\n-ffeinfo_new (ffeinfoBasictype basictype, ffeinfoKindtype kindtype,\n-\t     ffeinfoRank rank, ffeinfoKind kind, ffeinfoWhere where,\n-\t     ffetargetCharacterSize size)\n-{\n-  ffeinfo i;\n-\n-  i.basictype = basictype;\n-  i.kindtype = kindtype;\n-  i.rank = rank;\n-  i.size = size;\n-  i.kind = kind;\n-  i.where = where;\n-  i.size = size;\n-\n-  return i;\n-}\n-#endif"}, {"sha": "69defd27ab633f0e61e692dc913d3ea2e4392362", "filename": "gcc/f/info.h", "status": "removed", "additions": 0, "deletions": 186, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Finfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Finfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Finfo.h?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,186 +0,0 @@\n-/* info.h -- Public #include File (module.h template V1.0)\n-   Copyright (C) 1995 Free Software Foundation, Inc.\n-   Contributed by James Craig Burley.\n-\n-This file is part of GNU Fortran.\n-\n-GNU Fortran is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Fortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Fortran; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.\n-\n-   Owning Modules:\n-      info.c\n-\n-   Modifications:\n-      30-Aug-90\t JCB  2.0\n-\t Extensive rewrite for new cleaner approach.\n-*/\n-\n-/* Allow multiple inclusion to work. */\n-\n-#ifndef GCC_F_INFO_H\n-#define GCC_F_INFO_H\n-\n-/* Simple definitions and enumerations. */\n-\n-typedef enum\n-  {\n-#define FFEINFO_BASICTYPE(KWD,LNAM,SNAM) KWD,\n-#include \"info-b.def\"\n-#undef FFEINFO_BASICTYPE\n-    FFEINFO_basictype\n-  } ffeinfoBasictype;\n-\n-typedef enum\n-  {\t\t\t\t/* If these kindtypes aren't in size order,\n-\t\t\t\t   change _kindtype_max. */\n-    FFEINFO_kindtypeNONE,\n-    FFEINFO_kindtypeINTEGER1,\n-    FFEINFO_kindtypeINTEGER2,\n-    FFEINFO_kindtypeINTEGER3,\n-    FFEINFO_kindtypeINTEGER4,\n-    FFEINFO_kindtypeINTEGER5,\n-    FFEINFO_kindtypeINTEGER6,\n-    FFEINFO_kindtypeINTEGER7,\n-    FFEINFO_kindtypeINTEGER8,\n-    FFEINFO_kindtypeLOGICAL1 = 1,\t/* Ok to omit, but ok to overlap. */\n-    FFEINFO_kindtypeLOGICAL2,\n-    FFEINFO_kindtypeLOGICAL3,\n-    FFEINFO_kindtypeLOGICAL4,\n-    FFEINFO_kindtypeLOGICAL5,\n-    FFEINFO_kindtypeLOGICAL6,\n-    FFEINFO_kindtypeLOGICAL7,\n-    FFEINFO_kindtypeLOGICAL8,\n-    FFEINFO_kindtypeREAL1 = 1,\t/* Ok to omit, but ok to overlap. */\n-    FFEINFO_kindtypeREAL2,\n-    FFEINFO_kindtypeREAL3,\n-    FFEINFO_kindtypeREAL4,\n-    FFEINFO_kindtypeREAL5,\n-    FFEINFO_kindtypeREAL6,\n-    FFEINFO_kindtypeREAL7,\n-    FFEINFO_kindtypeREAL8,\n-    FFEINFO_kindtypeCHARACTER1 = 1,\t/* Ok to omit, but ok to overlap. */\n-    FFEINFO_kindtypeCHARACTER2,\n-    FFEINFO_kindtypeCHARACTER3,\n-    FFEINFO_kindtypeCHARACTER4,\n-    FFEINFO_kindtypeCHARACTER5,\n-    FFEINFO_kindtypeCHARACTER6,\n-    FFEINFO_kindtypeCHARACTER7,\n-    FFEINFO_kindtypeCHARACTER8,\n-    FFEINFO_kindtypeANY,\n-    FFEINFO_kindtype\n-  } ffeinfoKindtype;\n-\n-typedef enum\n-  {\n-#define FFEINFO_KIND(KWD,LNAM,SNAM) KWD,\n-#include \"info-k.def\"\n-#undef FFEINFO_KIND\n-    FFEINFO_kind\n-  } ffeinfoKind;\n-\n-typedef enum\n-  {\n-#define FFEINFO_WHERE(KWD,LNAM,SNAM) KWD,\n-#include \"info-w.def\"\n-#undef FFEINFO_WHERE\n-    FFEINFO_where\n-  } ffeinfoWhere;\n-\n-/* Typedefs. */\n-\n-typedef struct _ffeinfo_ ffeinfo;\n-typedef char ffeinfoRank;\n-\n-/* Include files needed by this one. */\n-\n-#include \"target.h\"\n-#include \"type.h\"\n-\n-/* Structure definitions. */\n-\n-struct _ffeinfo_\n-  {\n-    ffeinfoBasictype basictype;\n-    ffeinfoKindtype kindtype;\n-    ffeinfoRank rank;\n-    ffeinfoKind kind;\n-    ffeinfoWhere where;\n-    ffetargetCharacterSize size;\n-  };\n-\n-/* Global objects accessed by users of this module. */\n-\n-\n-/* Declare functions with prototypes. */\n-\n-ffeinfoBasictype ffeinfo_basictype_combine (ffeinfoBasictype l,\n-\t\t\t\t\t    ffeinfoBasictype r);\n-const char *ffeinfo_basictype_string (ffeinfoBasictype basictype);\n-void ffeinfo_init_0 (void);\n-const char *ffeinfo_kind_message (ffeinfoKind kind);\n-const char *ffeinfo_kind_string (ffeinfoKind kind);\n-ffeinfoKindtype ffeinfo_kindtype_max(ffeinfoBasictype bt,\n-\t\t\t\t     ffeinfoKindtype k1,\n-\t\t\t\t     ffeinfoKindtype k2);\n-const char *ffeinfo_kindtype_string (ffeinfoKindtype kind_type);\n-const char *ffeinfo_where_string (ffeinfoWhere where);\n-ffeinfo ffeinfo_new (ffeinfoBasictype basictype, ffeinfoKindtype kindtype,\n-\t\t     ffeinfoRank rank, ffeinfoKind kind, ffeinfoWhere where,\n-\t\t     ffetargetCharacterSize size);\n-void ffeinfo_set_type (ffeinfoBasictype basictype, ffeinfoKindtype kindtype,\n-\t\t       ffetype type);\n-ffetype ffeinfo_type (ffeinfoBasictype basictype, ffeinfoKindtype kindtype);\n-\n-/* Define macros. */\n-\n-#define ffeinfo_basictype(i) (i.basictype)\n-#define ffeinfo_init_1()\n-#define ffeinfo_init_2()\n-#define ffeinfo_init_3()\n-#define ffeinfo_init_4()\n-#define ffeinfo_kind(i) (i.kind)\n-#define ffeinfo_kindtype(i) (i.kindtype)\n-#ifdef __GNUC__\n-#define ffeinfo_new(bt,kt,r,k,w,sz) \\\n-  ((ffeinfo) {(bt), (kt), (r), (k), (w), (sz)})\n-#endif\n-#define ffeinfo_new_any()\t\t\t\t\t\t      \\\n-  ffeinfo_new (FFEINFO_basictypeANY, FFEINFO_kindtypeANY, 0,\t\t      \\\n-\t       FFEINFO_kindANY, FFEINFO_whereANY,\t\t\t      \\\n-\t       FFETARGET_charactersizeNONE)\n-#define ffeinfo_new_null()\t\t\t\t\t\t      \\\n-  ffeinfo_new (FFEINFO_basictypeNONE, FFEINFO_kindtypeNONE, 0,\t\t      \\\n-\t       FFEINFO_kindNONE, FFEINFO_whereNONE,\t\t\t      \\\n-\t       FFETARGET_charactersizeNONE)\n-#define ffeinfo_rank(i) (i.rank)\n-#define ffeinfo_size(i) (i.size)\n-#define ffeinfo_terminate_0()\n-#define ffeinfo_terminate_1()\n-#define ffeinfo_terminate_2()\n-#define ffeinfo_terminate_3()\n-#define ffeinfo_terminate_4()\n-#define ffeinfo_use(i) i\n-#define ffeinfo_where(i) (i.where)\n-\n-#define FFEINFO_kindtypeINTEGERDEFAULT FFEINFO_kindtypeINTEGER1\n-#define FFEINFO_kindtypeLOGICALDEFAULT FFEINFO_kindtypeLOGICAL1\n-#define FFEINFO_kindtypeREALDEFAULT FFEINFO_kindtypeREAL1\n-#define FFEINFO_kindtypeREALDOUBLE FFEINFO_kindtypeREAL2\n-#define FFEINFO_kindtypeREALQUAD FFEINFO_kindtypeREAL3\n-#define FFEINFO_kindtypeCHARACTERDEFAULT FFEINFO_kindtypeCHARACTER1\n-\n-/* End of #include file. */\n-\n-#endif /* ! GCC_F_INFO_H */"}, {"sha": "b24c79a481141ffc1da82bc90dd853dcb7c843a4", "filename": "gcc/f/intdoc.c", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fintdoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fintdoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fintdoc.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "6f2423f6cac6f8f3a8288b853034413c5e9a6034", "filename": "gcc/f/intdoc.in", "status": "removed", "additions": 0, "deletions": 2705, "changes": 2705, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fintdoc.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fintdoc.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fintdoc.in?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "e657510a0608136453ecbbdc0eda530f770db796", "filename": "gcc/f/intdoc.texi", "status": "removed", "additions": 0, "deletions": 10931, "changes": 10931, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fintdoc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fintdoc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fintdoc.texi?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "a379684ae4c2c229c2053b0426906f1847cd46a3", "filename": "gcc/f/intrin.c", "status": "removed", "additions": 0, "deletions": 2119, "changes": 2119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fintrin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fintrin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fintrin.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "5d712ba21c0286abc85fccbf6d6d07b1ff2f05af", "filename": "gcc/f/intrin.def", "status": "removed", "additions": 0, "deletions": 3358, "changes": 3358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fintrin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fintrin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fintrin.def?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "e741e69b4ecefa6e6861143a4aaa253a83dd330a", "filename": "gcc/f/intrin.h", "status": "removed", "additions": 0, "deletions": 135, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fintrin.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "fd1b80412a64c8503976b3fe45f36a79ed3caad6", "filename": "gcc/f/invoke.texi", "status": "removed", "additions": 0, "deletions": 2233, "changes": 2233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Finvoke.texi?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "1d278748b21d02bf3e80ee10c8d8f3be48a26ee6", "filename": "gcc/f/lab.c", "status": "removed", "additions": 0, "deletions": 157, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Flab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Flab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Flab.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "f3f89868a546b9f612236ae621832f7bdbaf6773", "filename": "gcc/f/lab.h", "status": "removed", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Flab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Flab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Flab.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "f1281d6767293412815af60faece1bcc9d02857e", "filename": "gcc/f/lang-specs.h", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Flang-specs.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "d6a53b7dcd13be1502ef66833507792c97d55e24", "filename": "gcc/f/lang.opt", "status": "removed", "additions": 0, "deletions": 402, "changes": 402, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Flang.opt?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "9a38ad5b0bb8deec09ac1ee85041526ba637c790", "filename": "gcc/f/lex.c", "status": "removed", "additions": 0, "deletions": 4575, "changes": 4575, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Flex.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "04dfbed426d3333c51800efc72e252e5bf1ea7fe", "filename": "gcc/f/lex.h", "status": "removed", "additions": 0, "deletions": 200, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Flex.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "7a84781d9ef95ae64f76300fc1ae1cc839ef56ad", "filename": "gcc/f/malloc.c", "status": "removed", "additions": 0, "deletions": 551, "changes": 551, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fmalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fmalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fmalloc.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "1c827209f2c9101b4f1861c3a1f65637d94a5e42", "filename": "gcc/f/malloc.h", "status": "removed", "additions": 0, "deletions": 183, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fmalloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fmalloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fmalloc.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "26f713ef32b9cd0a4d2474945bc3cdec2e182278", "filename": "gcc/f/name.c", "status": "removed", "additions": 0, "deletions": 241, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fname.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fname.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fname.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "4b18805d3d0a55e06e7d101f674c9f335478d288", "filename": "gcc/f/name.h", "status": "removed", "additions": 0, "deletions": 109, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fname.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fname.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fname.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "28a3fac6516fe1eae0e60e9758546878eec175ed", "filename": "gcc/f/news.texi", "status": "removed", "additions": 0, "deletions": 3182, "changes": 3182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fnews.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fnews.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fnews.texi?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "21176c39ecdb5ba9cfd8df01a357eb41b8b68d38", "filename": "gcc/f/news0.texi", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fnews0.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fnews0.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fnews0.texi?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "d822773f35be3bca8ca4aa97559ca1d8f49733aa", "filename": "gcc/f/parse.c", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fparse.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "0896bdf32c07f785d7e2578530aed3670da06f02", "filename": "gcc/f/proj.h", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fproj.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fproj.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fproj.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "1956abca3c3e767a97c5329dcdd0a6cda0599cb3", "filename": "gcc/f/root.texi", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Froot.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Froot.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Froot.texi?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "54fc7773fef96accdb4e135ddc86530903954111", "filename": "gcc/f/src.c", "status": "removed", "additions": 0, "deletions": 427, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fsrc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fsrc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fsrc.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "ce5843eaa0e240d23ec945ce6a6d07d089210d53", "filename": "gcc/f/src.h", "status": "removed", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fsrc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fsrc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fsrc.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "cdfdfb596a893d26f9cfd8fd5ce2ddc24e1b0c7c", "filename": "gcc/f/st.c", "status": "removed", "additions": 0, "deletions": 554, "changes": 554, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fst.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "65b99f9bbfee80aa43eafe45cd7c4846ce28462c", "filename": "gcc/f/st.h", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fst.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fst.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fst.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "ee75fa88f6087ac190bde71e50ff70f60cf19981", "filename": "gcc/f/sta.c", "status": "removed", "additions": 0, "deletions": 1722, "changes": 1722, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fsta.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fsta.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fsta.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "cf417771557879ce3fbd435a154873b0bef04416", "filename": "gcc/f/sta.h", "status": "removed", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fsta.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fsta.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fsta.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "673f96c23c543a72438d11d9b0382a81f1a58ce2", "filename": "gcc/f/stb.c", "status": "removed", "additions": 0, "deletions": 17812, "changes": 17812, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstb.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "88cb7c5452bb5839ef8ba10bd23dfe3a52e64b32", "filename": "gcc/f/stb.h", "status": "removed", "additions": 0, "deletions": 177, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstb.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstb.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstb.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "5f058135bbf683bda51e58b412420bf3fe07b779", "filename": "gcc/f/stc.c", "status": "removed", "additions": 0, "deletions": 10459, "changes": 10459, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstc.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "37feba69b8535466a08013cdf25323236045d3e7", "filename": "gcc/f/stc.h", "status": "removed", "additions": 0, "deletions": 234, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstc.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "09f04198f0a889bfba9920e650869820bc1acb21", "filename": "gcc/f/std.c", "status": "removed", "additions": 0, "deletions": 3623, "changes": 3623, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstd.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "29a82a8c99861697d31cfc78895881f20e2ce386", "filename": "gcc/f/std.h", "status": "removed", "additions": 0, "deletions": 194, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstd.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "82435bc8dc8e2bbf8a8b5e7e463a6ad242c93a31", "filename": "gcc/f/ste.c", "status": "removed", "additions": 0, "deletions": 4475, "changes": 4475, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fste.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fste.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fste.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "ac04a4c00da136073dff4e40f417aeb4192da189", "filename": "gcc/f/ste.h", "status": "removed", "additions": 0, "deletions": 144, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fste.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fste.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fste.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "8e9cb247a08193e19274feb21a6b929563352bb2", "filename": "gcc/f/storag.c", "status": "removed", "additions": 0, "deletions": 570, "changes": 570, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstorag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstorag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstorag.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "b58dc9a9602e9a421e25494227cad2973651fc3e", "filename": "gcc/f/storag.h", "status": "removed", "additions": 0, "deletions": 165, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstorag.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstorag.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstorag.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "7b8763d0c8f128c0d47497b846428c6e0b05b624", "filename": "gcc/f/stp.c", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstp.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "eca8d0d563daf97b08fe4ab9fb08135443f626d4", "filename": "gcc/f/stp.h", "status": "removed", "additions": 0, "deletions": 508, "changes": 508, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstp.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "b74f5834e943d700195e668a3fcf64f42a5a61e1", "filename": "gcc/f/str-1t.fin", "status": "removed", "additions": 0, "deletions": 135, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstr-1t.fin", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstr-1t.fin", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstr-1t.fin?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "d0ba9fcce7045bfbdc0e558d6f1ca5ce79730d1e", "filename": "gcc/f/str-2t.fin", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstr-2t.fin", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstr-2t.fin", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstr-2t.fin?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "ea39b6c61548d99661c747abb9bcb25f5d187417", "filename": "gcc/f/str-fo.fin", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstr-fo.fin", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstr-fo.fin", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstr-fo.fin?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "efd4008f4dcccd6f126b7cd6af7e64ee8fa61ad9", "filename": "gcc/f/str-io.fin", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstr-io.fin", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstr-io.fin", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstr-io.fin?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "3cdae089dac0833f3d80db581d3a8fd996656fbf", "filename": "gcc/f/str-nq.fin", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstr-nq.fin", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstr-nq.fin", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstr-nq.fin?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "b7a51126fa7db721ab68e59b33d226ac142bdd91", "filename": "gcc/f/str-op.fin", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstr-op.fin", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstr-op.fin", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstr-op.fin?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "c96b59c9bb040d0c2470dcfb40a009b3a4112d1b", "filename": "gcc/f/str-ot.fin", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstr-ot.fin", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstr-ot.fin", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstr-ot.fin?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "f03c893f209db5cf1099c90eea084928afb46f62", "filename": "gcc/f/str.c", "status": "removed", "additions": 0, "deletions": 217, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstr.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "b3ac04e5cb6d159b99db55a98feec98bf7090fd0", "filename": "gcc/f/str.h", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstr.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "63bf77aea77a4b0e9e4afae755b20f5efbcba90e", "filename": "gcc/f/sts.c", "status": "removed", "additions": 0, "deletions": 179, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fsts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fsts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fsts.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "3ca494d81de53afcb9f5270ac1c573bf764e93c5", "filename": "gcc/f/sts.h", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fsts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fsts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fsts.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "e616d492289a99da41bc11b7edd8caccc30c93de", "filename": "gcc/f/stt.c", "status": "removed", "additions": 0, "deletions": 892, "changes": 892, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstt.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "56543d033956e7908ebeb42339179aaa2343d70c", "filename": "gcc/f/stt.h", "status": "removed", "additions": 0, "deletions": 212, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstt.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "1d58731fcaeb47e998f61645f88c4fce80d1eb01", "filename": "gcc/f/stu.c", "status": "removed", "additions": 0, "deletions": 1162, "changes": 1162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstu.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "e01b741b389d8c74434d8912f94401a4cfa29c9b", "filename": "gcc/f/stu.h", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstu.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "cd31ac492a5a8ddc6e0d003deb17d2ee953f8f89", "filename": "gcc/f/stv.c", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstv.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "a3f959f46086181a80627bd8544f745381acbd91", "filename": "gcc/f/stv.h", "status": "removed", "additions": 0, "deletions": 165, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstv.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "57658de3204e267ed335f95e4d6fd04e2592cad6", "filename": "gcc/f/stw.c", "status": "removed", "additions": 0, "deletions": 428, "changes": 428, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstw.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "080bd73885d32c1cf28822ba0ea3698ace054a86", "filename": "gcc/f/stw.h", "status": "removed", "additions": 0, "deletions": 185, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstw.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fstw.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fstw.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "c22697ff3771bc8654192aeef5aa117ca30cc797", "filename": "gcc/f/symbol.c", "status": "removed", "additions": 0, "deletions": 1253, "changes": 1253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fsymbol.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "9cddcb6dbe074960dd8598b5893f1f77ab7f6add", "filename": "gcc/f/symbol.def", "status": "removed", "additions": 0, "deletions": 654, "changes": 654, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fsymbol.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fsymbol.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fsymbol.def?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "7ddafbd446dd650ef36486cdccc049d35b2b263c", "filename": "gcc/f/symbol.h", "status": "removed", "additions": 0, "deletions": 287, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fsymbol.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fsymbol.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fsymbol.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "16261120e240e7b8c9ce7e462625a9f963fda076", "filename": "gcc/f/target.c", "status": "removed", "additions": 0, "deletions": 2583, "changes": 2583, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Ftarget.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "8ec73addc85cd2869a0bfe2bd1d4c29558934e81", "filename": "gcc/f/target.h", "status": "removed", "additions": 0, "deletions": 1433, "changes": 1433, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Ftarget.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "ce39dd09bf4c233c11a50b635caceee7c475a3dc", "filename": "gcc/f/top.c", "status": "removed", "additions": 0, "deletions": 994, "changes": 994, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Ftop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Ftop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Ftop.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "5538ab8db13457f3d9b8619dd79601788997531f", "filename": "gcc/f/top.h", "status": "removed", "additions": 0, "deletions": 262, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Ftop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Ftop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Ftop.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "d25ab50f4c2a1b18057e17b6666ddf2f36837876", "filename": "gcc/f/type.c", "status": "removed", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Ftype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Ftype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Ftype.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "9e3bd801e19aa5a60702786eb398d95bdfa6bf23", "filename": "gcc/f/type.h", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Ftype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Ftype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Ftype.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "b409a4681f5247e9b508b7577078c6282a0b2287", "filename": "gcc/f/where.c", "status": "removed", "additions": 0, "deletions": 520, "changes": 520, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fwhere.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fwhere.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fwhere.c?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "cce7b2a75ba8cdbef85bd38992e78edbe3652959", "filename": "gcc/f/where.h", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fwhere.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ff%2Fwhere.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fwhere.h?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "f5649d7dc018a06696f6aedf5e1fcff2a9ebbe35", "filename": "gcc/po/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4117c306105c7e3279bbbabab1dd361a3b35b62/gcc%2Fpo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4117c306105c7e3279bbbabab1dd361a3b35b62/gcc%2Fpo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpo%2FChangeLog?ref=b4117c306105c7e3279bbbabab1dd361a3b35b62"}, {"sha": "691dad9f051236f64c68be453332d60bc76e88be", "filename": "gcc/po/exgettext", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4117c306105c7e3279bbbabab1dd361a3b35b62/gcc%2Fpo%2Fexgettext", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4117c306105c7e3279bbbabab1dd361a3b35b62/gcc%2Fpo%2Fexgettext", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpo%2Fexgettext?ref=b4117c306105c7e3279bbbabab1dd361a3b35b62"}, {"sha": "194d54db70630d147601d7bfbb27585c02c03047", "filename": "gcc/po/gcc.pot", "status": "modified", "additions": 679, "deletions": 2008, "changes": 2687, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4117c306105c7e3279bbbabab1dd361a3b35b62/gcc%2Fpo%2Fgcc.pot", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4117c306105c7e3279bbbabab1dd361a3b35b62/gcc%2Fpo%2Fgcc.pot", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpo%2Fgcc.pot?ref=b4117c306105c7e3279bbbabab1dd361a3b35b62"}, {"sha": "2636d32c70e413293057a245d4b03a62b8272637", "filename": "libf2c/configure", "status": "removed", "additions": 0, "deletions": 2939, "changes": 2939, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/libf2c%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/libf2c%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libf2c%2Fconfigure?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "4e198c87c8f8beda4b105760ba30cb65128d95f7", "filename": "libf2c/libF77/configure", "status": "removed", "additions": 0, "deletions": 1568, "changes": 1568, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/libf2c%2FlibF77%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/libf2c%2FlibF77%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libf2c%2FlibF77%2Fconfigure?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "3ae78d198ad741c70c89027b06bf8fc4deb6bd54", "filename": "libf2c/libI77/config.h.in", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/libf2c%2FlibI77%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/libf2c%2FlibI77%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libf2c%2FlibI77%2Fconfig.h.in?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "3d3b6dcdfb57f9756303ee92fc47f7963952b105", "filename": "libf2c/libI77/configure", "status": "removed", "additions": 0, "deletions": 2123, "changes": 2123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/libf2c%2FlibI77%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/libf2c%2FlibI77%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libf2c%2FlibI77%2Fconfigure?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "9788f70238c91894045d22366fa941580826c3c1", "filename": "libf2c/libI77/stamp-h.in", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/libf2c%2FlibI77%2Fstamp-h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/libf2c%2FlibI77%2Fstamp-h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libf2c%2FlibI77%2Fstamp-h.in?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "e6d5af240a1d594dd16c7ff091507d643621eab3", "filename": "libf2c/libU77/config.hin", "status": "removed", "additions": 0, "deletions": 128, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/libf2c%2FlibU77%2Fconfig.hin", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/libf2c%2FlibU77%2Fconfig.hin", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libf2c%2FlibU77%2Fconfig.hin?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "afe63fbeab36511eb695af243e9e43ee1c84e039", "filename": "libf2c/libU77/configure", "status": "removed", "additions": 0, "deletions": 2066, "changes": 2066, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/libf2c%2FlibU77%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/libf2c%2FlibU77%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libf2c%2FlibU77%2Fconfigure?ref=54b4ba60f20d3870a79467caa3b604971225d388"}, {"sha": "9788f70238c91894045d22366fa941580826c3c1", "filename": "libf2c/libU77/stamp-h.in", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/libf2c%2FlibU77%2Fstamp-h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/libf2c%2FlibU77%2Fstamp-h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libf2c%2FlibU77%2Fstamp-h.in?ref=54b4ba60f20d3870a79467caa3b604971225d388"}]}