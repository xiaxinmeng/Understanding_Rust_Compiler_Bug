{"sha": "f3124d8f6431bcfce76eca31a198ba89ce0d15fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMxMjRkOGY2NDMxYmNmY2U3NmVjYTMxYTE5OGJhODljZTBkMTVmZQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2014-08-04T10:55:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T10:55:30Z"}, "message": "2014-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* opt.ads Alphabetize various global flags. New flag\n\tIgnore_Pragma_SPARK_Mode along with a comment on usage.\n\t* sem_ch6.adb (Analyze_Generic_Subprogram_Body):\n\tPragma SPARK_Mode is now allowed in generic units.\n\t(Analyze_Subprogram_Body_Helper): Do not verify the compatibility\n\tbetween the SPARK_Mode of a spec and that of a body when inside\n\ta generic.\n\t* sem_ch7.adb (Analyze_Package_Body_Helper): Do not verify the\n\tcompatibility between the SPARK_Mode of a spec and that of a\n\tbody when inside a generic.\n\t* sem_ch12.adb (Analyze_Generic_Subprogram_Declaration):\n\tPragma SPARK_Mode is now allowed in generic units.\n\t(Analyze_Package_Instantiation): Save and restore the value of\n\tflag Ignore_ Pragma_SPARK_Mode in a stack-like fasion. Set\n\tthe governing SPARK_Mode before analyzing the instance.\n\t(Analyze_Subprogram_Instantiation): Save and restore the value\n\tof flag Ignore_ Pragma_SPARK_Mode in a stack-like fasion. Set\n\tthe governing SPARK_Mode before analyzing the instance.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Emulate the\n\tplacement of a source pragma when inserting the generated pragma\n\tfor aspect SPARK_Mode.\n\t* sem_prag.adb (Analyze_Pragma): Reimplement the handling of\n\tpragma SPARK_Mode to allow for generics and their respective\n\tinstantiations.\n\t* sem_util.ads, sem_util.adb (Check_SPARK_Mode_In_Generic): Removed.\n\t(Set_Ignore_Pragma_SPARK_Mode): New routine.\n\nFrom-SVN: r213570", "tree": {"sha": "121b03cc943bf71264e84e46bed57fea3f122034", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/121b03cc943bf71264e84e46bed57fea3f122034"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3124d8f6431bcfce76eca31a198ba89ce0d15fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3124d8f6431bcfce76eca31a198ba89ce0d15fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3124d8f6431bcfce76eca31a198ba89ce0d15fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3124d8f6431bcfce76eca31a198ba89ce0d15fe/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f10ff6cc46ab7e851afbaf05818f4e9db0f8a335", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f10ff6cc46ab7e851afbaf05818f4e9db0f8a335", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f10ff6cc46ab7e851afbaf05818f4e9db0f8a335"}], "stats": {"total": 603, "additions": 391, "deletions": 212}, "files": [{"sha": "8bed0123c2e37ea2ef3cfd3aa27fff6239bc734f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3124d8f6431bcfce76eca31a198ba89ce0d15fe/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3124d8f6431bcfce76eca31a198ba89ce0d15fe/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f3124d8f6431bcfce76eca31a198ba89ce0d15fe", "patch": "@@ -1,3 +1,32 @@\n+2014-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* opt.ads Alphabetize various global flags. New flag\n+\tIgnore_Pragma_SPARK_Mode along with a comment on usage.\n+\t* sem_ch6.adb (Analyze_Generic_Subprogram_Body):\n+\tPragma SPARK_Mode is now allowed in generic units.\n+\t(Analyze_Subprogram_Body_Helper): Do not verify the compatibility\n+\tbetween the SPARK_Mode of a spec and that of a body when inside\n+\ta generic.\n+\t* sem_ch7.adb (Analyze_Package_Body_Helper): Do not verify the\n+\tcompatibility between the SPARK_Mode of a spec and that of a\n+\tbody when inside a generic.\n+\t* sem_ch12.adb (Analyze_Generic_Subprogram_Declaration):\n+\tPragma SPARK_Mode is now allowed in generic units.\n+\t(Analyze_Package_Instantiation): Save and restore the value of\n+\tflag Ignore_ Pragma_SPARK_Mode in a stack-like fasion. Set\n+\tthe governing SPARK_Mode before analyzing the instance.\n+\t(Analyze_Subprogram_Instantiation): Save and restore the value\n+\tof flag Ignore_ Pragma_SPARK_Mode in a stack-like fasion. Set\n+\tthe governing SPARK_Mode before analyzing the instance.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Emulate the\n+\tplacement of a source pragma when inserting the generated pragma\n+\tfor aspect SPARK_Mode.\n+\t* sem_prag.adb (Analyze_Pragma): Reimplement the handling of\n+\tpragma SPARK_Mode to allow for generics and their respective\n+\tinstantiations.\n+\t* sem_util.ads, sem_util.adb (Check_SPARK_Mode_In_Generic): Removed.\n+\t(Set_Ignore_Pragma_SPARK_Mode): New routine.\n+\n 2014-08-04  Eric Botcazou  <ebotcazou@adacore.com>\n \n         * gcc-interface/decl.c (gnat_to_gnu_entity) <E_Component>: Deal with"}, {"sha": "2e00d4aa9953310afb7816828d0edae20ece9b99", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3124d8f6431bcfce76eca31a198ba89ce0d15fe/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3124d8f6431bcfce76eca31a198ba89ce0d15fe/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=f3124d8f6431bcfce76eca31a198ba89ce0d15fe", "patch": "@@ -648,6 +648,20 @@ package Opt is\n    --  GNAT\n    --  Disable generation of ALI file\n \n+   Follow_Links_For_Files : Boolean := False;\n+   --  PROJECT MANAGER\n+   --  Set to True (-eL) to process the project files in trusted mode. If\n+   --  Follow_Links is False, it is assumed that the project doesn't contain\n+   --  any file duplicated through symbolic links (although the latter are\n+   --  still valid if they point to a file which is outside of the project),\n+   --  and that no directory has a name which is a valid source name.\n+\n+   Follow_Links_For_Dirs : Boolean := False;\n+   --  PROJECT MANAGER\n+   --  Set to True if directories can be links in this project, and therefore\n+   --  additional system calls must be performed to ensure that we always see\n+   --  the same full name for each directory.\n+\n    Force_Checking_Of_Elaboration_Flags : Boolean := False;\n    --  GNATBIND\n    --  True if binding with forced checking of the elaboration flags\n@@ -657,6 +671,13 @@ package Opt is\n    --  GNATMAKE, GPRMAKE, GPRBUILD\n    --  Set to force recompilations even when the objects are up-to-date.\n \n+   Front_End_Inlining : Boolean := False;\n+   --  GNAT\n+   --  Set True to activate inlining by front-end expansion (even on GCC\n+   --  targets, where inlining is normally handled by the back end). Set by\n+   --  the flag -gnatN (which is now considered obsolescent, since the GCC\n+   --  back end can do a better job of inlining than the front end these days.\n+\n    Full_Path_Name_For_Brief_Errors : Boolean := False;\n    --  PROJECT MANAGER\n    --  When True, in Brief_Output mode, each error message line\n@@ -684,6 +705,10 @@ package Opt is\n    --  True when switch -gnateG is used. When True, create in a file\n    --  <source>.prep, if the source is preprocessed.\n \n+   Generate_SCIL : Boolean := False;\n+   --  GNAT\n+   --  Set True to activate SCIL code generation.\n+\n    Generate_SCO : Boolean := False;\n    --  GNAT\n    --  True when switch -fdump-scos (or -gnateS) is used. When True, Source\n@@ -728,6 +753,12 @@ package Opt is\n    --  default value appropriate to the system (in Osint.Initialize), and then\n    --  reset if a command line switch is used to change the setting.\n \n+   Ignore_Pragma_SPARK_Mode : Boolean := False;\n+   --  GNAT\n+   --  Set True to ignore the semantics and effects of pragma SPARK_Mode when\n+   --  the pragma appears inside an instance whose enclosing context is subject\n+   --  to SPARK_Mode \"off\".\n+\n    Ignore_Rep_Clauses : Boolean := False;\n    --  GNAT\n    --  Set True to ignore all representation clauses. Useful when compiling\n@@ -798,35 +829,10 @@ package Opt is\n    --  then elaboration flag checks are to be generated in the binder\n    --  generated file.\n \n-   Generate_SCIL : Boolean := False;\n-   --  GNAT\n-   --  Set True to activate SCIL code generation.\n-\n    Invalid_Value_Used : Boolean := False;\n    --  GNAT\n    --  Set True if a valid Invalid_Value attribute is encountered\n \n-   Follow_Links_For_Files : Boolean := False;\n-   --  PROJECT MANAGER\n-   --  Set to True (-eL) to process the project files in trusted mode. If\n-   --  Follow_Links is False, it is assumed that the project doesn't contain\n-   --  any file duplicated through symbolic links (although the latter are\n-   --  still valid if they point to a file which is outside of the project),\n-   --  and that no directory has a name which is a valid source name.\n-\n-   Follow_Links_For_Dirs : Boolean := False;\n-   --  PROJECT MANAGER\n-   --  Set to True if directories can be links in this project, and therefore\n-   --  additional system calls must be performed to ensure that we always see\n-   --  the same full name for each directory.\n-\n-   Front_End_Inlining : Boolean := False;\n-   --  GNAT\n-   --  Set True to activate inlining by front-end expansion (even on GCC\n-   --  targets, where inlining is normally handled by the back end). Set by\n-   --  the flag -gnatN (which is now considered obsolescent, since the GCC\n-   --  back end can do a better job of inlining than the front end these days.\n-\n    Inline_Processing_Required : Boolean := False;\n    --  GNAT\n    --  Set True if inline processing is required. Inline processing is required"}, {"sha": "73533a2107fed589a9ca1963f5b370b5b269b1e1", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3124d8f6431bcfce76eca31a198ba89ce0d15fe/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3124d8f6431bcfce76eca31a198ba89ce0d15fe/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=f3124d8f6431bcfce76eca31a198ba89ce0d15fe", "patch": "@@ -3342,8 +3342,6 @@ package body Sem_Ch12 is\n       Set_Parent_Spec (New_N, Save_Parent);\n       Rewrite (N, New_N);\n \n-      Check_SPARK_Mode_In_Generic (N);\n-\n       --  The aspect specifications are not attached to the tree, and must\n       --  be copied and attached to the generic copy explicitly.\n \n@@ -3532,6 +3530,9 @@ package body Sem_Ch12 is\n       Needs_Body       : Boolean;\n       Inline_Now       : Boolean := False;\n \n+      Save_IPSM : constant Boolean := Ignore_Pragma_SPARK_Mode;\n+      --  Save flag Ignore_Pragma_SPARK_Mode for restore on exit\n+\n       Save_Style_Check : constant Boolean := Style_Check;\n       --  Save style check mode for restore on exit\n \n@@ -3771,6 +3772,12 @@ package body Sem_Ch12 is\n          goto Leave;\n \n       else\n+         --  If the instance or its context is subject to SPARK_Mode \"off\",\n+         --  set the global flag which signals Analyze_Pragma to ignore all\n+         --  SPARK_Mode pragmas within the instance.\n+\n+         Set_Ignore_Pragma_SPARK_Mode (N);\n+\n          Gen_Decl := Unit_Declaration_Node (Gen_Unit);\n \n          --  Initialize renamings map, for error checking, and the list that\n@@ -3835,9 +3842,7 @@ package body Sem_Ch12 is\n             Set_Visible_Declarations (Act_Spec, Renaming_List);\n          end if;\n \n-         Act_Decl :=\n-           Make_Package_Declaration (Loc,\n-             Specification => Act_Spec);\n+         Act_Decl := Make_Package_Declaration (Loc, Specification => Act_Spec);\n \n          --  Propagate the aspect specifications from the package declaration\n          --  template to the instantiated version of the package declaration.\n@@ -4277,6 +4282,7 @@ package body Sem_Ch12 is\n          Set_Defining_Identifier (N, Act_Decl_Id);\n       end if;\n \n+      Ignore_Pragma_SPARK_Mode := Save_IPSM;\n       Style_Check := Save_Style_Check;\n \n       --  Check that if N is an instantiation of System.Dim_Float_IO or\n@@ -4311,6 +4317,7 @@ package body Sem_Ch12 is\n             Restore_Env;\n          end if;\n \n+         Ignore_Pragma_SPARK_Mode := Save_IPSM;\n          Style_Check := Save_Style_Check;\n    end Analyze_Package_Instantiation;\n \n@@ -4865,6 +4872,9 @@ package body Sem_Ch12 is\n \n       --  Local variables\n \n+      Save_IPSM : constant Boolean := Ignore_Pragma_SPARK_Mode;\n+      --  Save flag Ignore_Pragma_SPARK_Mode for restore on exit\n+\n       Vis_Prims_List : Elist_Id := No_Elist;\n       --  List of primitives made temporarily visible in the instantiation\n       --  to match the visibility of the formal type\n@@ -4929,6 +4939,12 @@ package body Sem_Ch12 is\n          Error_Msg_NE (\"instantiation of & within itself\", N, Gen_Unit);\n \n       else\n+         --  If the instance or its context is subject to SPARK_Mode \"off\",\n+         --  set the global flag which signals Analyze_Pragma to ignore all\n+         --  SPARK_Mode pragmas within the instance.\n+\n+         Set_Ignore_Pragma_SPARK_Mode (N);\n+\n          Set_Entity (Gen_Id, Gen_Unit);\n          Set_Is_Instantiated (Gen_Unit);\n \n@@ -5139,6 +5155,8 @@ package body Sem_Ch12 is\n          Env_Installed := False;\n          Generic_Renamings.Set_Last (0);\n          Generic_Renamings_HTable.Reset;\n+\n+         Ignore_Pragma_SPARK_Mode := Save_IPSM;\n       end if;\n \n    <<Leave>>\n@@ -5155,6 +5173,8 @@ package body Sem_Ch12 is\n          if Env_Installed then\n             Restore_Env;\n          end if;\n+\n+         Ignore_Pragma_SPARK_Mode := Save_IPSM;\n    end Analyze_Subprogram_Instantiation;\n \n    -------------------------"}, {"sha": "dc226b37ec4776115744768eee401e2c63daca2e", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3124d8f6431bcfce76eca31a198ba89ce0d15fe/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3124d8f6431bcfce76eca31a198ba89ce0d15fe/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=f3124d8f6431bcfce76eca31a198ba89ce0d15fe", "patch": "@@ -2418,11 +2418,11 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_SPARK_Mode);\n \n-                  --  When the aspect appears on a package body, insert the\n-                  --  generated pragma at the top of the body declarations to\n-                  --  emulate the behavior of a source pragma.\n+                  --  When the aspect appears on a package or a subprogram\n+                  --  body, insert the generated pragma at the top of the body\n+                  --  declarations to emulate the behavior of a source pragma.\n \n-                  if Nkind (N) = N_Package_Body then\n+                  if Nkind_In (N, N_Package_Body, N_Subprogram_Body) then\n                      Decorate (Aspect, Aitem);\n \n                      Decls := Declarations (N);\n@@ -2435,11 +2435,14 @@ package body Sem_Ch13 is\n                      Prepend_To (Decls, Aitem);\n                      goto Continue;\n \n-                  --  When the aspect is associated with package declaration,\n-                  --  insert the generated pragma at the top of the visible\n-                  --  declarations to emulate the behavior of a source pragma.\n+                  --  When the aspect is associated with a [generic] package\n+                  --  declaration, insert the generated pragma at the top of\n+                  --  the visible declarations to emulate the behavior of a\n+                  --  source pragma.\n \n-                  elsif Nkind (N) = N_Package_Declaration then\n+                  elsif Nkind_In (N, N_Generic_Package_Declaration,\n+                                     N_Package_Declaration)\n+                  then\n                      Decorate (Aspect, Aitem);\n \n                      Decls := Visible_Declarations (Specification (N));"}, {"sha": "a6014b14ec60d90407fb68d489010f87344f4e77", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3124d8f6431bcfce76eca31a198ba89ce0d15fe/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3124d8f6431bcfce76eca31a198ba89ce0d15fe/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=f3124d8f6431bcfce76eca31a198ba89ce0d15fe", "patch": "@@ -1251,8 +1251,6 @@ package body Sem_Ch6 is\n             end loop;\n          end;\n \n-         Check_SPARK_Mode_In_Generic (N);\n-\n          Set_SPARK_Pragma (Body_Id, SPARK_Mode_Pragma);\n          Set_SPARK_Pragma_Inherited (Body_Id, True);\n \n@@ -3743,11 +3741,12 @@ package body Sem_Ch6 is\n \n       Analyze_Declarations (Declarations (N));\n \n-      --  After declarations have been analyzed, the body has been set\n-      --  its final value of SPARK_Mode. Check that SPARK_Mode for body\n-      --  is consistent with SPARK_Mode for spec.\n+      --  Verify that the SPARK_Mode of the body agrees with that of its spec\n \n-      if Present (Spec_Id) and then Present (SPARK_Pragma (Body_Id)) then\n+      if not Inside_A_Generic\n+        and then Present (Spec_Id)\n+        and then Present (SPARK_Pragma (Body_Id))\n+      then\n          if Present (SPARK_Pragma (Spec_Id)) then\n             if Get_SPARK_Mode_From_Pragma (SPARK_Pragma (Spec_Id)) = Off\n                  and then\n@@ -3757,7 +3756,7 @@ package body Sem_Ch6 is\n                Error_Msg_N (\"incorrect application of SPARK_Mode#\", N);\n                Error_Msg_Sloc := Sloc (SPARK_Pragma (Spec_Id));\n                Error_Msg_NE\n-                 (\"\\value Off was set for SPARK_Mode on&#\", N, Spec_Id);\n+                 (\"\\value Off was set for SPARK_Mode on & #\", N, Spec_Id);\n             end if;\n \n          elsif Nkind (Parent (Parent (Spec_Id))) = N_Subprogram_Body_Stub then\n@@ -3767,7 +3766,8 @@ package body Sem_Ch6 is\n             Error_Msg_Sloc := Sloc (SPARK_Pragma (Body_Id));\n             Error_Msg_N (\"incorrect application of SPARK_Mode#\", N);\n             Error_Msg_Sloc := Sloc (Spec_Id);\n-            Error_Msg_NE (\"\\no value was set for SPARK_Mode on&#\", N, Spec_Id);\n+            Error_Msg_NE\n+              (\"\\no value was set for SPARK_Mode on & #\", N, Spec_Id);\n          end if;\n       end if;\n "}, {"sha": "583621f96e702bf58205efe0a6f80c454488d9c9", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3124d8f6431bcfce76eca31a198ba89ce0d15fe/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3124d8f6431bcfce76eca31a198ba89ce0d15fe/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=f3124d8f6431bcfce76eca31a198ba89ce0d15fe", "patch": "@@ -437,11 +437,9 @@ package body Sem_Ch7 is\n          Inspect_Deferred_Constant_Completion (Declarations (N));\n       end if;\n \n-      --  After declarations have been analyzed, the body has been set to have\n-      --  the final value of SPARK_Mode. Check that the SPARK_Mode for the body\n-      --  is consistent with the SPARK_Mode for the spec.\n+      --  Verify that the SPARK_Mode of the body agrees with that of its spec\n \n-      if Present (SPARK_Pragma (Body_Id)) then\n+      if not Inside_A_Generic and then Present (SPARK_Pragma (Body_Id)) then\n          if Present (SPARK_Aux_Pragma (Spec_Id)) then\n             if Get_SPARK_Mode_From_Pragma (SPARK_Aux_Pragma (Spec_Id)) = Off\n                  and then"}, {"sha": "d6de6a7d1ded0e5e7ff0d4f864e00f8875bad035", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 158, "deletions": 133, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3124d8f6431bcfce76eca31a198ba89ce0d15fe/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3124d8f6431bcfce76eca31a198ba89ce0d15fe/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=f3124d8f6431bcfce76eca31a198ba89ce0d15fe", "patch": "@@ -19116,13 +19116,6 @@ package body Sem_Prag is\n          --  pragma SPARK_Mode [(On | Off)];\n \n          when Pragma_SPARK_Mode => Do_SPARK_Mode : declare\n-            Body_Id : Entity_Id;\n-            Context : Node_Id;\n-            Mode    : Name_Id;\n-            Mode_Id : SPARK_Mode_Type;\n-            Spec_Id : Entity_Id;\n-            Stmt    : Node_Id;\n-\n             procedure Check_Pragma_Conformance\n               (Context_Pragma : Node_Id;\n                Entity_Pragma  : Node_Id;\n@@ -19163,7 +19156,7 @@ package body Sem_Prag is\n                   --  New mode less restrictive than the established mode\n \n                   if Get_SPARK_Mode_From_Pragma (Context_Pragma) = Off\n-                    and then Mode_Id = On\n+                    and then Get_SPARK_Mode_From_Pragma (N) = On\n                   then\n                      Error_Msg_N\n                        (\"cannot change SPARK_Mode from Off to On\", Arg1);\n@@ -19176,7 +19169,7 @@ package body Sem_Prag is\n                if Present (Entity) then\n                   if Present (Entity_Pragma) then\n                      if Get_SPARK_Mode_From_Pragma (Entity_Pragma) = Off\n-                       and then Mode_Id = On\n+                       and then Get_SPARK_Mode_From_Pragma (N) = On\n                      then\n                         Error_Msg_N (\"incorrect use of SPARK_Mode\", Arg1);\n                         Error_Msg_Sloc := Sloc (Entity_Pragma);\n@@ -19224,9 +19217,36 @@ package body Sem_Prag is\n                end if;\n             end Check_Library_Level_Entity;\n \n+            --  Local variables\n+\n+            Body_Id : Entity_Id;\n+            Context : Node_Id;\n+            Inst_Id : Entity_Id;\n+            Mode    : Name_Id;\n+            Mode_Id : SPARK_Mode_Type;\n+            Spec_Id : Entity_Id;\n+            Stmt    : Node_Id;\n+\n          --  Start of processing for Do_SPARK_Mode\n \n          begin\n+            --  When a SPARK_Mode pragma appears inside an instantiation whose\n+            --  enclosing context has SPARK_Mode set to \"off\", the pragma has\n+            --  no semantic effect.\n+\n+            if Ignore_Pragma_SPARK_Mode then\n+               Rewrite (N, Make_Null_Statement (Loc));\n+               Analyze (N);\n+               return;\n+\n+            --  Do not analyze the pragma when it appears inside a generic\n+            --  because the semantic information of the related context is\n+            --  scarce.\n+\n+            elsif Inside_A_Generic then\n+               return;\n+            end if;\n+\n             GNAT_Pragma;\n             Check_No_Identifiers;\n             Check_At_Most_N_Arguments (1);\n@@ -19243,15 +19263,15 @@ package body Sem_Prag is\n             Mode_Id := Get_SPARK_Mode_Type (Mode);\n             Context := Parent (N);\n \n-            --  Packages and subprograms declared in a generic unit cannot be\n-            --  subject to the pragma.\n+            --  Handle a compilation unit with configuration pragmas\n \n-            if Inside_A_Generic then\n-               Error_Pragma (\"incorrect placement of pragma% in a generic\");\n+            if Nkind (Context) = N_Compilation_Unit_Aux then\n+               Context := Parent (Context);\n+            end if;\n \n             --  The pragma appears in a configuration pragmas file\n \n-            elsif No (Context) then\n+            if No (Context) then\n                Check_Valid_Configuration_Pragma;\n \n                if Present (SPARK_Mode_Pragma) then\n@@ -19263,29 +19283,63 @@ package body Sem_Prag is\n                SPARK_Mode_Pragma := N;\n                SPARK_Mode := Mode_Id;\n \n-            --  When the pragma is placed before the declaration of a unit, it\n-            --  configures the whole unit.\n+            --  The pragma applies to a compilation unit\n \n             elsif Nkind (Context) = N_Compilation_Unit then\n-               Check_Valid_Configuration_Pragma;\n \n-               if Nkind (Unit (Context)) in N_Generic_Declaration\n-                 or else (Present (Library_Unit (Context))\n-                           and then Nkind (Unit (Library_Unit (Context))) in\n-                                                        N_Generic_Declaration)\n-               then\n-                  Error_Pragma (\"incorrect placement of pragma% in a generic\");\n-               end if;\n+               --  The pragma acts as a configuration pragma\n \n-               SPARK_Mode_Pragma := N;\n-               SPARK_Mode := Mode_Id;\n+               --    pragma SPARK_Mode ...;\n+               --    package Pack is ...;\n \n-            --  The pragma applies to a [library unit] subprogram or package\n+               if List_Containing (N) = Context_Items (Context) then\n+                  Check_Valid_Configuration_Pragma;\n+                  SPARK_Mode_Pragma := N;\n+                  SPARK_Mode := Mode_Id;\n \n-            else\n-               --  Verify the placement of the pragma with respect to package\n-               --  or subprogram declarations and detect duplicates.\n+               --  The pragma applies to a package instantiation that acts as a\n+               --  compilation unit.\n+\n+               --    package Inst is new Gen ...;\n+               --    pragma SPARK_Mode ...;\n+\n+               elsif Nkind (Unit (Context)) = N_Package_Instantiation then\n+                  Inst_Id := Defining_Entity (Instance_Spec (Unit (Context)));\n+                  Check_Library_Level_Entity (Inst_Id);\n+                  Check_Pragma_Conformance\n+                    (Context_Pragma => SPARK_Mode_Pragma,\n+                     Entity_Pragma  => Empty,\n+                     Entity         => Empty);\n+\n+                  Set_SPARK_Pragma           (Inst_Id, N);\n+                  Set_SPARK_Pragma_Inherited (Inst_Id, False);\n \n+               --  Otherwise the pragma applies to a subprogram instantiation\n+               --  that acts as a compilation unit.\n+\n+               else\n+                  Spec_Id := Defining_Entity (Unit (Context));\n+                  Inst_Id := Related_Instance (Spec_Id);\n+                  Check_Library_Level_Entity (Spec_Id);\n+                  Check_Pragma_Conformance\n+                    (Context_Pragma => SPARK_Mode_Pragma,\n+                     Entity_Pragma  => Empty,\n+                     Entity         => Empty);\n+\n+                  Set_SPARK_Pragma           (Spec_Id, N);\n+                  Set_SPARK_Pragma_Inherited (Spec_Id, False);\n+\n+                  if Present (Inst_Id) then\n+                     Set_SPARK_Pragma           (Inst_Id, N);\n+                     Set_SPARK_Pragma_Inherited (Inst_Id, False);\n+                  end if;\n+               end if;\n+\n+            --  Otherwise the placement of the pragma within the tree dictates\n+            --  its associated construct. Inspect the declarative list where\n+            --  the pragma resides to find a potential construct.\n+\n+            else\n                Stmt := Prev (N);\n                while Present (Stmt) loop\n \n@@ -19299,28 +19353,32 @@ package body Sem_Prag is\n                         raise Pragma_Exit;\n                      end if;\n \n-                  elsif Nkind (Stmt) in N_Generic_Declaration then\n-                     Error_Pragma\n-                       (\"incorrect placement of pragma% on a generic\");\n+                  --  The pragma is associated with a package or subprogram\n+                  --  instantiation that does not act as a compilation unit.\n \n-                  --  The pragma applies to a package declaration\n+                  --    package Inst is new Gen ...;\n+                  --    pragma SPARK_Mode ...;\n \n-                  elsif Nkind (Stmt) = N_Package_Declaration then\n-                     Spec_Id := Defining_Entity (Stmt);\n-                     Check_Library_Level_Entity (Spec_Id);\n+                  elsif Nkind_In (Stmt, N_Function_Instantiation,\n+                                        N_Package_Instantiation,\n+                                        N_Procedure_Instantiation)\n+                  then\n+                     Inst_Id := Defining_Entity (Instance_Spec (Stmt));\n+                     Check_Library_Level_Entity (Inst_Id);\n                      Check_Pragma_Conformance\n-                       (Context_Pragma => SPARK_Pragma (Spec_Id),\n+                       (Context_Pragma => SPARK_Mode_Pragma,\n                         Entity_Pragma  => Empty,\n                         Entity         => Empty);\n \n-                     Set_SPARK_Pragma               (Spec_Id, N);\n-                     Set_SPARK_Pragma_Inherited     (Spec_Id, False);\n-                     Set_SPARK_Aux_Pragma           (Spec_Id, N);\n-                     Set_SPARK_Aux_Pragma_Inherited (Spec_Id, True);\n+                     Set_SPARK_Pragma           (Inst_Id, N);\n+                     Set_SPARK_Pragma_Inherited (Inst_Id, False);\n                      return;\n \n                   --  The pragma applies to a subprogram declaration\n \n+                  --    procedure Proc ...;\n+                  --    pragma SPARK_Mode ..;\n+\n                   elsif Nkind (Stmt) = N_Subprogram_Declaration then\n                      Spec_Id := Defining_Entity (Stmt);\n                      Check_Library_Level_Entity (Spec_Id);\n@@ -19338,8 +19396,9 @@ package body Sem_Prag is\n                   elsif not Comes_From_Source (Stmt) then\n                      null;\n \n-                  --  The pragma does not apply to a legal construct, issue an\n-                  --  error and stop the analysis.\n+                  --  Otherwise the pragma does not apply to a legal construct\n+                  --  or it does not appear at the top of a declarative or a\n+                  --  statement list. Issue an error and stop the analysis.\n \n                   else\n                      Pragma_Misplaced;\n@@ -19349,59 +19408,18 @@ package body Sem_Prag is\n                   Stmt := Prev (Stmt);\n                end loop;\n \n-               --  Handle all cases where the pragma is actually an aspect and\n-               --  applies to a library-level package spec, body or subprogram.\n-\n-               --    function F ... with SPARK_Mode => ...;\n-               --    package P with SPARK_Mode => ...;\n-               --    package body P with SPARK_Mode => ... is\n-\n-               --  The following circuitry simply prepares the proper context\n-               --  for the general pragma processing mechanism below.\n-\n-               if Nkind (Context) = N_Compilation_Unit_Aux then\n-                  Context := Unit (Parent (Context));\n-\n-                  if Nkind_In (Context, N_Package_Declaration,\n-                                        N_Subprogram_Declaration)\n-                  then\n-                     Context := Specification (Context);\n-                  end if;\n-               end if;\n-\n-               --  The pragma is at the top level of a package spec\n-\n-               --    package P is\n-               --       pragma SPARK_Mode;\n-\n-               --      or\n-\n-               --    package P is\n-               --      ...\n-               --    private\n-               --      pragma SPARK_Mode;\n+               --  The pragma appears within package declarations\n \n                if Nkind (Context) = N_Package_Specification then\n                   Spec_Id := Defining_Entity (Context);\n+                  Check_Library_Level_Entity (Spec_Id);\n \n-                  --  Pragma applies to private part\n-\n-                  if List_Containing (N) = Private_Declarations (Context) then\n-                     Check_Library_Level_Entity (Spec_Id);\n-                     Check_Pragma_Conformance\n-                       (Context_Pragma => Empty,\n-                        Entity_Pragma  => SPARK_Pragma (Spec_Id),\n-                        Entity         => Spec_Id);\n-                     SPARK_Mode_Pragma := N;\n-                     SPARK_Mode := Mode_Id;\n-\n-                     Set_SPARK_Aux_Pragma           (Spec_Id, N);\n-                     Set_SPARK_Aux_Pragma_Inherited (Spec_Id, False);\n+                  --  The pragma is at the top of the visible declarations\n \n-                  --  Pragma applies to public part\n+                  --    package Pack is\n+                  --       pragma SPARK_Mode ...;\n \n-                  else\n-                     Check_Library_Level_Entity (Spec_Id);\n+                  if List_Containing (N) = Visible_Declarations (Context) then\n                      Check_Pragma_Conformance\n                        (Context_Pragma => SPARK_Pragma (Spec_Id),\n                         Entity_Pragma  => Empty,\n@@ -19413,28 +19431,29 @@ package body Sem_Prag is\n                      Set_SPARK_Pragma_Inherited     (Spec_Id, False);\n                      Set_SPARK_Aux_Pragma           (Spec_Id, N);\n                      Set_SPARK_Aux_Pragma_Inherited (Spec_Id, True);\n-                  end if;\n \n-               --  The pragma appears as an aspect on a subprogram.\n+                  --  The pragma is at the top of the private declarations\n \n-               --    function F ... with SPARK_Mode => ...;\n+                  --    package Pack is\n+                  --    private\n+                  --       pragma SPARK_Mode ...;\n \n-               elsif Nkind_In (Context, N_Function_Specification,\n-                                        N_Procedure_Specification)\n-               then\n-                  Spec_Id := Defining_Entity (Context);\n-                  Check_Library_Level_Entity (Spec_Id);\n-                  Check_Pragma_Conformance\n-                    (Context_Pragma => SPARK_Pragma (Spec_Id),\n-                     Entity_Pragma  => Empty,\n-                     Entity         => Empty);\n-                  Set_SPARK_Pragma           (Spec_Id, N);\n-                  Set_SPARK_Pragma_Inherited (Spec_Id, False);\n+                  else\n+                     Check_Pragma_Conformance\n+                       (Context_Pragma => Empty,\n+                        Entity_Pragma  => SPARK_Pragma (Spec_Id),\n+                        Entity         => Spec_Id);\n+                     SPARK_Mode_Pragma := N;\n+                     SPARK_Mode := Mode_Id;\n \n-               --  Pragma is immediately within a package body\n+                     Set_SPARK_Aux_Pragma           (Spec_Id, N);\n+                     Set_SPARK_Aux_Pragma_Inherited (Spec_Id, False);\n+                  end if;\n \n-               --    package body P is\n-               --       pragma SPARK_Mode;\n+               --  The pragma appears at the top of package body declarations\n+\n+               --    package body Pack is\n+               --       pragma SPARK_Mode ...;\n \n                elsif Nkind (Context) = N_Package_Body then\n                   Spec_Id := Corresponding_Spec (Context);\n@@ -19452,9 +19471,33 @@ package body Sem_Prag is\n                   Set_SPARK_Aux_Pragma           (Body_Id, N);\n                   Set_SPARK_Aux_Pragma_Inherited (Body_Id, True);\n \n-               --  Pragma is immediately within a subprogram body\n+               --  The pragma appears at the top of package body statements\n+\n+               --    package body Pack is\n+               --    begin\n+               --       pragma SPARK_Mode;\n+\n+               elsif Nkind (Context) = N_Handled_Sequence_Of_Statements\n+                 and then Nkind (Parent (Context)) = N_Package_Body\n+               then\n+                  Context := Parent (Context);\n+                  Spec_Id := Corresponding_Spec (Context);\n+                  Body_Id := Defining_Entity (Context);\n+                  Check_Library_Level_Entity (Body_Id);\n+                  Check_Pragma_Conformance\n+                    (Context_Pragma => Empty,\n+                     Entity_Pragma  => SPARK_Pragma (Body_Id),\n+                     Entity         => Body_Id);\n+                  SPARK_Mode_Pragma := N;\n+                  SPARK_Mode := Mode_Id;\n+\n+                  Set_SPARK_Aux_Pragma           (Body_Id, N);\n+                  Set_SPARK_Aux_Pragma_Inherited (Body_Id, False);\n+\n+               --  The pragma appears at the top of subprogram body\n+               --  declarations.\n \n-               --    function F ... is\n+               --    procedure Proc ... is\n                --       pragma SPARK_Mode;\n \n                elsif Nkind (Context) = N_Subprogram_Body then\n@@ -19471,11 +19514,16 @@ package body Sem_Prag is\n \n                   Check_Library_Level_Entity (Body_Id);\n \n+                  --  The body is a completion of a previous declaration\n+\n                   if Present (Spec_Id) then\n                      Check_Pragma_Conformance\n                        (Context_Pragma => SPARK_Pragma (Body_Id),\n                         Entity_Pragma  => SPARK_Pragma (Spec_Id),\n                         Entity         => Spec_Id);\n+\n+                  --  The body acts as spec\n+\n                   else\n                      Check_Pragma_Conformance\n                        (Context_Pragma => SPARK_Pragma (Body_Id),\n@@ -19489,29 +19537,6 @@ package body Sem_Prag is\n                   Set_SPARK_Pragma           (Body_Id, N);\n                   Set_SPARK_Pragma_Inherited (Body_Id, False);\n \n-               --  The pragma applies to the statements of a package body\n-\n-               --    package body P is\n-               --    begin\n-               --       pragma SPARK_Mode;\n-\n-               elsif Nkind (Context) = N_Handled_Sequence_Of_Statements\n-                 and then Nkind (Parent (Context)) = N_Package_Body\n-               then\n-                  Context := Parent (Context);\n-                  Spec_Id := Corresponding_Spec (Context);\n-                  Body_Id := Defining_Entity (Context);\n-                  Check_Library_Level_Entity (Body_Id);\n-                  Check_Pragma_Conformance\n-                    (Context_Pragma => Empty,\n-                     Entity_Pragma  => SPARK_Pragma (Body_Id),\n-                     Entity         => Body_Id);\n-                  SPARK_Mode_Pragma := N;\n-                  SPARK_Mode := Mode_Id;\n-\n-                  Set_SPARK_Aux_Pragma           (Body_Id, N);\n-                  Set_SPARK_Aux_Pragma_Inherited (Body_Id, False);\n-\n                --  The pragma does not apply to a legal construct, issue error\n \n                else"}, {"sha": "107ce11e0ce3d2d75eb6538f656aa17b73520040", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 122, "deletions": 25, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3124d8f6431bcfce76eca31a198ba89ce0d15fe/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3124d8f6431bcfce76eca31a198ba89ce0d15fe/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f3124d8f6431bcfce76eca31a198ba89ce0d15fe", "patch": "@@ -3078,31 +3078,6 @@ package body Sem_Util is\n       end if;\n    end Check_Result_And_Post_State;\n \n-   ---------------------------------\n-   -- Check_SPARK_Mode_In_Generic --\n-   ---------------------------------\n-\n-   procedure Check_SPARK_Mode_In_Generic (N : Node_Id) is\n-      Aspect : Node_Id;\n-\n-   begin\n-      --  Try to find aspect SPARK_Mode and flag it as illegal\n-\n-      if Has_Aspects (N) then\n-         Aspect := First (Aspect_Specifications (N));\n-         while Present (Aspect) loop\n-            if Get_Aspect_Id (Aspect) = Aspect_SPARK_Mode then\n-               Error_Msg_Name_1 := Name_SPARK_Mode;\n-               Error_Msg_N\n-                 (\"incorrect placement of aspect % on a generic\", Aspect);\n-               exit;\n-            end if;\n-\n-            Next (Aspect);\n-         end loop;\n-      end if;\n-   end Check_SPARK_Mode_In_Generic;\n-\n    ------------------------------\n    -- Check_Unprotected_Access --\n    ------------------------------\n@@ -16481,6 +16456,128 @@ package body Sem_Util is\n       Set_Entity (N, Val);\n    end Set_Entity_With_Checks;\n \n+   ----------------------------------\n+   -- Set_Ignore_Pragma_SPARK_Mode --\n+   ----------------------------------\n+\n+   procedure Set_Ignore_Pragma_SPARK_Mode (N : Node_Id) is\n+      procedure Set_SPARK_Mode (Expr : Node_Id);\n+      --  Set flag Ignore_Pragma_SPARK_Mode based on the argument of aspect or\n+      --  pragma SPARK_Mode denoted by Expr.\n+\n+      --------------------\n+      -- Set_SPARK_Mode --\n+      --------------------\n+\n+      procedure Set_SPARK_Mode (Expr : Node_Id) is\n+      begin\n+         --  When pragma SPARK_Mode with argument \"off\" applies to an instance,\n+         --  all SPARK_Mode pragmas within the instance are ignored.\n+\n+         if Present (Expr)\n+           and then Nkind (Expr) = N_Identifier\n+           and then Chars (Expr) = Name_Off\n+         then\n+            Ignore_Pragma_SPARK_Mode := True;\n+         end if;\n+      end Set_SPARK_Mode;\n+\n+      --  Local variables\n+\n+      Aspects : constant List_Id := Aspect_Specifications (N);\n+      Context : constant Node_Id := Parent (N);\n+      Args    : List_Id;\n+      Aspect  : Node_Id;\n+      Decl    : Node_Id;\n+\n+   --  Start of processing for Set_Ignore_Pragma_SPARK_Mode\n+\n+   begin\n+      --  When the enclosing context of the instance has SPARK_Mode \"off\", all\n+      --  SPARK_Mode pragmas within the instance are ignored. Note that there\n+      --  is no point in checking whether the instantiation itself carries\n+      --  aspect/pragma SPARK_Mode because it is either illegal (\"on\") or has\n+      --  no effect (\"off\").\n+\n+      if SPARK_Mode = Off then\n+         Ignore_Pragma_SPARK_Mode := True;\n+         return;\n+      end if;\n+\n+      --  Inspect the aspects of the instantiation and locate SPARK_Mode. Note\n+      --  that the aspect form of SPARK_Mode precedes a potentially duplicate\n+      --  pragma.\n+\n+      if Present (Aspects) then\n+         Aspect := First (Aspects);\n+         while Present (Aspect) loop\n+            if Get_Aspect_Id (Aspect) = Aspect_SPARK_Mode then\n+               Set_SPARK_Mode (Expression (Aspect));\n+               return;\n+            end if;\n+\n+            Next (Aspect);\n+         end loop;\n+      end if;\n+\n+      --  Peek ahead of the instance and locate pragma SPARK_Mode. Even though\n+      --  the pragma is analyzed after the instance, its mode must be known now\n+      --  as it governs the legality of SPARK_Mode pragmas within the instance.\n+\n+      Decl := Empty;\n+\n+      --  The instance is a compilation unit, the pragma appears on the\n+      --  Pragmas_After list.\n+\n+      if Present (Context)\n+        and then Nkind (Context) = N_Compilation_Unit\n+        and then Present (Aux_Decls_Node (Context))\n+        and then Present (Pragmas_After (Aux_Decls_Node (Context)))\n+      then\n+         Decl := First (Pragmas_After (Aux_Decls_Node (Context)));\n+\n+      --  The instance is part of a declarative list, the pragma appears after\n+      --  the instance.\n+\n+      elsif Is_List_Member (N) then\n+         Decl := Next (N);\n+      end if;\n+\n+      --  Inspect all declarations following the instance\n+\n+      while Present (Decl) loop\n+         if Nkind (Decl) = N_Pragma then\n+            if Get_Pragma_Id (Decl) = Pragma_SPARK_Mode then\n+               Args := Pragma_Argument_Associations (Decl);\n+\n+               --  The pragma argument dictates the mode\n+\n+               if Present (Args) then\n+                  Set_SPARK_Mode (Get_Pragma_Arg (First (Args)));\n+               end if;\n+\n+               --  Only the first SPARK_Mode following the instance is\n+               --  considered, any extra (illegal) pragmas are ignored.\n+\n+               exit;\n+            end if;\n+\n+         --  Skip internally generated code\n+\n+         elsif not Comes_From_Source (Decl) then\n+            null;\n+\n+         --  Otherwise a source construct exhaust the range where the pragma\n+         --  may appear.\n+\n+         else\n+            exit;\n+         end if;\n+\n+         Next (Decl);\n+      end loop;\n+   end Set_Ignore_Pragma_SPARK_Mode;\n+\n    ------------------------\n    -- Set_Name_Entity_Id --\n    ------------------------"}, {"sha": "9ac981e2f60554275c191a48ff102ee34e289f59", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3124d8f6431bcfce76eca31a198ba89ce0d15fe/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3124d8f6431bcfce76eca31a198ba89ce0d15fe/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=f3124d8f6431bcfce76eca31a198ba89ce0d15fe", "patch": "@@ -327,10 +327,6 @@ package Sem_Util is\n    --  and post-state. Prag is a [refined] postcondition or a contract-cases\n    --  pragma. Result_Seen is set when the pragma mentions attribute 'Result.\n \n-   procedure Check_SPARK_Mode_In_Generic (N : Node_Id);\n-   --  Given a generic package [body] or a generic subprogram [body], inspect\n-   --  the aspect specifications (if any) and flag SPARK_Mode as illegal.\n-\n    procedure Check_Unprotected_Access\n      (Context : Node_Id;\n       Expr    : Node_Id);\n@@ -1841,6 +1837,11 @@ package Sem_Util is\n    --    If restriction No_Implementation_Identifiers is set, then it checks\n    --    that the entity is not implementation defined.\n \n+   procedure Set_Ignore_Pragma_SPARK_Mode (N : Node_Id);\n+   --  Determine whether [the enclosing context of] package or subprogram N is\n+   --  subject to pragma SPARK_Mode with mode \"off\". If this is the case, set\n+   --  global flag Ignore_Pragma_SPARK_Mode to True.\n+\n    procedure Set_Name_Entity_Id (Id : Name_Id; Val : Entity_Id);\n    pragma Inline (Set_Name_Entity_Id);\n    --  Sets the Entity_Id value associated with the given name, which is the"}]}