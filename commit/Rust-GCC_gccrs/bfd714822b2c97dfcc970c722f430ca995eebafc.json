{"sha": "bfd714822b2c97dfcc970c722f430ca995eebafc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZkNzE0ODIyYjJjOTdkZmNjOTcwYzcyMmY0MzBjYTk5NWVlYmFmYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-03-19T07:53:38Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-03-19T07:53:38Z"}, "message": "re PR sanitizer/65400 (tsan mis-compiles inlineable C functions)\n\n\tPR sanitizer/65400\n\t* ipa-split.c (find_return_bb): Allow TSAN_FUNC_EXIT internal\n\tcall in the return bb.\n\t(find_split_points): Add RETURN_BB argument, don't call\n\tfind_return_bb.\n\t(split_function): Likewise.  Add ADD_TSAN_FUNC_EXIT argument,\n\tif true append TSAN_FUNC_EXIT internal call after the call to\n\tthe split off function.\n\t(execute_split_functions): Call find_return_bb here.\n\tDon't optimize if TSAN_FUNC_EXIT is found in unexpected places.\n\tAdjust find_split_points and split_function calls.\n\n\t* c-c++-common/tsan/pr65400-1.c: New test.\n\t* c-c++-common/tsan/pr65400-2.c: New test.\n\nFrom-SVN: r221508", "tree": {"sha": "d66c13575e21970d004baf7ab6afa1494b91bd8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d66c13575e21970d004baf7ab6afa1494b91bd8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfd714822b2c97dfcc970c722f430ca995eebafc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfd714822b2c97dfcc970c722f430ca995eebafc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfd714822b2c97dfcc970c722f430ca995eebafc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfd714822b2c97dfcc970c722f430ca995eebafc/comments", "author": null, "committer": null, "parents": [{"sha": "995332cad37e5724a88a9a3cdfb3008248d5257e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/995332cad37e5724a88a9a3cdfb3008248d5257e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/995332cad37e5724a88a9a3cdfb3008248d5257e"}], "stats": {"total": 181, "additions": 169, "deletions": 12}, "files": [{"sha": "251fc3a8ec7953b8f5c3615067bfc6b8204dff20", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfd714822b2c97dfcc970c722f430ca995eebafc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfd714822b2c97dfcc970c722f430ca995eebafc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bfd714822b2c97dfcc970c722f430ca995eebafc", "patch": "@@ -1,3 +1,17 @@\n+2015-03-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR sanitizer/65400\n+\t* ipa-split.c (find_return_bb): Allow TSAN_FUNC_EXIT internal\n+\tcall in the return bb.\n+\t(find_split_points): Add RETURN_BB argument, don't call\n+\tfind_return_bb.\n+\t(split_function): Likewise.  Add ADD_TSAN_FUNC_EXIT argument,\n+\tif true append TSAN_FUNC_EXIT internal call after the call to\n+\tthe split off function.\n+\t(execute_split_functions): Call find_return_bb here.\n+\tDon't optimize if TSAN_FUNC_EXIT is found in unexpected places.\n+\tAdjust find_split_points and split_function calls.\n+\n 2015-03-18  DJ Delorie  <dj@redhat.com>\n \t\n \t* config/rl78/rl78-virt.md (andqi3_virt): Allow far operands."}, {"sha": "5d5db0e4eee99c738df2e885719e877c34fe5ce3", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 51, "deletions": 9, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfd714822b2c97dfcc970c722f430ca995eebafc/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfd714822b2c97dfcc970c722f430ca995eebafc/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=bfd714822b2c97dfcc970c722f430ca995eebafc", "patch": "@@ -769,7 +769,8 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n    of the form:\n    <retval> = tmp_var;\n    return <retval>\n-   but return_bb can not be more complex than this.\n+   but return_bb can not be more complex than this (except for\n+   -fsanitize=thread we allow TSAN_FUNC_EXIT () internal call in there).\n    If nothing is found, return the exit block.\n \n    When there are multiple RETURN statement, chose one with return value,\n@@ -814,6 +815,13 @@ find_return_bb (void)\n \t  found_return = true;\n \t  retval = gimple_return_retval (return_stmt);\n \t}\n+      /* For -fsanitize=thread, allow also TSAN_FUNC_EXIT () in the return\n+\t bb.  */\n+      else if ((flag_sanitize & SANITIZE_THREAD)\n+\t       && is_gimple_call (stmt)\n+\t       && gimple_call_internal_p (stmt)\n+\t       && gimple_call_internal_fn (stmt) == IFN_TSAN_FUNC_EXIT)\n+\t;\n       else\n \tbreak;\n     }\n@@ -1074,12 +1082,11 @@ typedef struct\n    the component used by consider_split.  */\n \n static void\n-find_split_points (int overall_time, int overall_size)\n+find_split_points (basic_block return_bb, int overall_time, int overall_size)\n {\n   stack_entry first;\n   vec<stack_entry> stack = vNULL;\n   basic_block bb;\n-  basic_block return_bb = find_return_bb ();\n   struct split_point current;\n \n   current.header_time = overall_time;\n@@ -1236,19 +1243,20 @@ insert_bndret_call_after (tree retbnd, tree retval, gimple_stmt_iterator *gsi)\n   gimple_call_set_lhs (bndret, retbnd);\n   gsi_insert_after (gsi, bndret, GSI_CONTINUE_LINKING);\n }\n+\n /* Split function at SPLIT_POINT.  */\n \n static void\n-split_function (struct split_point *split_point)\n+split_function (basic_block return_bb, struct split_point *split_point,\n+\t\tbool add_tsan_func_exit)\n {\n   vec<tree> args_to_pass = vNULL;\n   bitmap args_to_skip;\n   tree parm;\n   int num = 0;\n   cgraph_node *node, *cur_node = cgraph_node::get (current_function_decl);\n-  basic_block return_bb = find_return_bb ();\n   basic_block call_bb;\n-  gcall *call;\n+  gcall *call, *tsan_func_exit_call = NULL;\n   edge e;\n   edge_iterator ei;\n   tree retval = NULL, real_retval = NULL, retbnd = NULL;\n@@ -1534,11 +1542,18 @@ split_function (struct split_point *split_point)\n \t  || DECL_BY_REFERENCE (DECL_RESULT (current_function_decl))))\n     gimple_call_set_return_slot_opt (call, true);\n \n+  if (add_tsan_func_exit)\n+    tsan_func_exit_call = gimple_build_call_internal (IFN_TSAN_FUNC_EXIT, 0);\n+\n   /* Update return value.  This is bit tricky.  When we do not return,\n      do nothing.  When we return we might need to update return_bb\n      or produce a new return statement.  */\n   if (!split_part_return_p)\n-    gsi_insert_after (&gsi, call, GSI_NEW_STMT);\n+    {\n+      gsi_insert_after (&gsi, call, GSI_NEW_STMT);\n+      if (tsan_func_exit_call)\n+\tgsi_insert_after (&gsi, tsan_func_exit_call, GSI_NEW_STMT);\n+    }\n   else\n     {\n       e = make_edge (call_bb, return_bb,\n@@ -1642,6 +1657,8 @@ split_function (struct split_point *split_point)\n \t    }\n \t  else\n \t    gsi_insert_after (&gsi, call, GSI_NEW_STMT);\n+\t  if (tsan_func_exit_call)\n+\t    gsi_insert_after (&gsi, tsan_func_exit_call, GSI_NEW_STMT);\n \t}\n       /* We don't use return block (there is either no return in function or\n \t multiple of them).  So create new basic block with return statement.\n@@ -1684,6 +1701,8 @@ split_function (struct split_point *split_point)\n \t  /* Build bndret call to obtain returned bounds.  */\n \t  if (retbnd)\n \t    insert_bndret_call_after (retbnd, retval, &gsi);\n+\t  if (tsan_func_exit_call)\n+\t    gsi_insert_after (&gsi, tsan_func_exit_call, GSI_NEW_STMT);\n \t  ret = gimple_build_return (retval);\n \t  gsi_insert_after (&gsi, ret, GSI_NEW_STMT);\n \t}\n@@ -1792,6 +1811,8 @@ execute_split_functions (void)\n   /* Compute local info about basic blocks and determine function size/time.  */\n   bb_info_vec.safe_grow_cleared (last_basic_block_for_fn (cfun) + 1);\n   memset (&best_split_point, 0, sizeof (best_split_point));\n+  basic_block return_bb = find_return_bb ();\n+  int tsan_exit_found = -1;\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       int time = 0;\n@@ -1818,16 +1839,37 @@ execute_split_functions (void)\n \t\t       freq, this_size, this_time);\n \t      print_gimple_stmt (dump_file, stmt, 0, 0);\n \t    }\n+\n+\t  if ((flag_sanitize & SANITIZE_THREAD)\n+\t      && is_gimple_call (stmt)\n+\t      && gimple_call_internal_p (stmt)\n+\t      && gimple_call_internal_fn (stmt) == IFN_TSAN_FUNC_EXIT)\n+\t    {\n+\t      /* We handle TSAN_FUNC_EXIT for splitting either in the\n+\t\t return_bb, or in its immediate predecessors.  */\n+\t      if ((bb != return_bb && !find_edge (bb, return_bb))\n+\t\t  || (tsan_exit_found != -1\n+\t\t      && tsan_exit_found != (bb != return_bb)))\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"Not splitting: TSAN_FUNC_EXIT\"\n+\t\t\t     \" in unexpected basic block.\\n\");\n+\t\t  BITMAP_FREE (forbidden_dominators);\n+\t\t  bb_info_vec.release ();\n+\t\t  return 0;\n+\t\t}\n+\t      tsan_exit_found = bb != return_bb;\n+\t    }\n \t}\n       overall_time += time;\n       overall_size += size;\n       bb_info_vec[bb->index].time = time;\n       bb_info_vec[bb->index].size = size;\n     }\n-  find_split_points (overall_time, overall_size);\n+  find_split_points (return_bb, overall_time, overall_size);\n   if (best_split_point.split_bbs)\n     {\n-      split_function (&best_split_point);\n+      split_function (return_bb, &best_split_point, tsan_exit_found == 1);\n       BITMAP_FREE (best_split_point.ssa_names_to_pass);\n       BITMAP_FREE (best_split_point.split_bbs);\n       todo = TODO_update_ssa | TODO_cleanup_cfg;"}, {"sha": "405eaebf1305a1a2423923c00956e245c4fac69d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfd714822b2c97dfcc970c722f430ca995eebafc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfd714822b2c97dfcc970c722f430ca995eebafc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bfd714822b2c97dfcc970c722f430ca995eebafc", "patch": "@@ -1,3 +1,9 @@\n+2015-03-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR sanitizer/65400\n+\t* c-c++-common/tsan/pr65400-1.c: New test.\n+\t* c-c++-common/tsan/pr65400-2.c: New test.\n+\n 2015-03-18  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/59816\n@@ -6,7 +12,7 @@\n 2015-03-18  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/59198\n-\t* gfortran.dg/proc_ptr_comp_45.f90 : Make tests fuzzy.\n+\t* gfortran.dg/proc_ptr_comp_45.f90: Make tests fuzzy.\n \n 2015-03-18  Martin Liska  <mliska@suse.cz>\n \n@@ -55,8 +61,8 @@\n 2015-03-17  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/59198\n-\t* gfortran.dg/proc_ptr_comp_44.f90 : New test\n-\t* gfortran.dg/proc_ptr_comp_45.f90 : New test\n+\t* gfortran.dg/proc_ptr_comp_44.f90: New test.\n+\t* gfortran.dg/proc_ptr_comp_45.f90: New test.\n \n 2015-03-16 Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n "}, {"sha": "96fbbfd36b62629933c605a95be5e264e54a6f83", "filename": "gcc/testsuite/c-c++-common/tsan/pr65400-1.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfd714822b2c97dfcc970c722f430ca995eebafc/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftsan%2Fpr65400-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfd714822b2c97dfcc970c722f430ca995eebafc/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftsan%2Fpr65400-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftsan%2Fpr65400-1.c?ref=bfd714822b2c97dfcc970c722f430ca995eebafc", "patch": "@@ -0,0 +1,85 @@\n+/* PR sanitizer/65400 */\n+/* { dg-shouldfail \"tsan\" } */\n+/* { dg-additional-options \"-fno-omit-frame-pointer -ldl\" } */\n+/* { dg-additional-sources pr65400-2.c } */\n+\n+#include <pthread.h>\n+#include \"tsan_barrier.h\"\n+\n+static pthread_barrier_t barrier;\n+int v;\n+int q;\n+int o;\n+extern void baz4 (int *);\n+\n+__attribute__((noinline, noclone)) int\n+bar (int x)\n+{\n+  q += x;\n+  return x;\n+}\n+\n+void\n+foo (int *x)\n+{\n+  if (__builtin_expect (x == 0, 1))\n+    return;\n+  bar (bar (bar (bar (*x))));\n+}\n+\n+__attribute__((noinline, noclone)) void\n+baz1 (int *x)\n+{\n+  foo (x);\n+}\n+\n+__attribute__((noinline, noclone)) void\n+baz2 (int **x)\n+{\n+  foo (*x);\n+}\n+\n+__attribute__((noinline, noclone)) void\n+baz3 (void)\n+{\n+  barrier_wait (&barrier);\n+  v++;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+baz5 (void)\n+{\n+  int i;\n+  o = 1;\n+  baz1 (&o);\n+  int *p = &o;\n+  baz2 (&p);\n+  for (i = 0; i < 128; i++)\n+    baz4 (&o);\n+  if (q != 130 * 4)\n+    __builtin_abort ();\n+  baz3 ();\n+}\n+\n+__attribute__((noinline, noclone)) void *\n+tf (void *arg)\n+{\n+  (void) arg;\n+  baz5 ();\n+  return NULL;\n+}\n+\n+int\n+main ()\n+{\n+  pthread_t th;\n+  barrier_init (&barrier, 2);\n+  if (pthread_create (&th, NULL, tf, NULL))\n+    return 0;\n+  v++;\n+  barrier_wait (&barrier);\n+  pthread_join (th, NULL);\n+  return 0;\n+}\n+\n+/* { dg-output \"WARNING: ThreadSanitizer: data race.*#2 _?tf\" } */"}, {"sha": "de9131aff744b8770bbd6a0a8c21b4036c95bcd4", "filename": "gcc/testsuite/c-c++-common/tsan/pr65400-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfd714822b2c97dfcc970c722f430ca995eebafc/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftsan%2Fpr65400-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfd714822b2c97dfcc970c722f430ca995eebafc/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftsan%2Fpr65400-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftsan%2Fpr65400-2.c?ref=bfd714822b2c97dfcc970c722f430ca995eebafc", "patch": "@@ -0,0 +1,10 @@\n+/* PR sanitizer/65400 */\n+/* { dg-do compile } */\n+\n+extern void foo (int *);\n+\n+void\n+baz4 (int *p)\n+{\n+  foo (p);\n+}"}]}