{"sha": "6b8c9327ed60bbb966e7c82df75f9aa0faa727e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI4YzkzMjdlZDYwYmJiOTY2ZTdjODJkZjc1ZjlhYTBmYWE3MjdlMg==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2001-08-31T14:49:37Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2001-08-31T14:49:37Z"}, "message": "gcse.c (add_label_notes): REG_LABEL is an INSN_LIST.\n\n\n\t* gcse.c (add_label_notes): REG_LABEL is an INSN_LIST.\n\t* loop.c (add_label_notes): Likewise.\n\t* reload.c (find_reloads): Likewise.\n\t* config/sh/sh.c (machine_dependent_reorg): Likewise.\n\nFrom-SVN: r45320", "tree": {"sha": "c5b148bc30a5e693f60c12062a6f49f2e7378e98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5b148bc30a5e693f60c12062a6f49f2e7378e98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b8c9327ed60bbb966e7c82df75f9aa0faa727e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b8c9327ed60bbb966e7c82df75f9aa0faa727e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b8c9327ed60bbb966e7c82df75f9aa0faa727e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b8c9327ed60bbb966e7c82df75f9aa0faa727e2/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6c8d43e78d57068e37ba19d7e5da8c447eca8daa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c8d43e78d57068e37ba19d7e5da8c447eca8daa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c8d43e78d57068e37ba19d7e5da8c447eca8daa"}], "stats": {"total": 163, "additions": 85, "deletions": 78}, "files": [{"sha": "6993ca691dcbec34dcbb3a4b64c6c7f46f08c95a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8c9327ed60bbb966e7c82df75f9aa0faa727e2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8c9327ed60bbb966e7c82df75f9aa0faa727e2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b8c9327ed60bbb966e7c82df75f9aa0faa727e2", "patch": "@@ -1,3 +1,10 @@\n+2001-08-31  Andreas Jaeger  <aj@suse.de>\n+\n+\t* gcse.c (add_label_notes): REG_LABEL is an INSN_LIST.\n+\t* loop.c (add_label_notes): Likewise.\n+\t* reload.c (find_reloads): Likewise.\n+\t* config/sh/sh.c (machine_dependent_reorg): Likewise.\n+\n 2001-08-31  Jason Merrill  <jason_merrill@redhat.com>\n \n \t* unwind-pe.h (read_uleb128, read_sleb128): Move actual reading"}, {"sha": "7945a9c6a4b8f7ff2891cc1322ff50ad24b167fb", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8c9327ed60bbb966e7c82df75f9aa0faa727e2/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8c9327ed60bbb966e7c82df75f9aa0faa727e2/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=6b8c9327ed60bbb966e7c82df75f9aa0faa727e2", "patch": "@@ -3238,9 +3238,9 @@ machine_dependent_reorg (first)\n              or pseudo-op.  */\n \n \t  label = gen_label_rtx ();\n-\t  REG_NOTES (link) = gen_rtx_EXPR_LIST (REG_LABEL, label,\n+\t  REG_NOTES (link) = gen_rtx_INSN_LIST (REG_LABEL, label,\n \t\t\t\t\t\tREG_NOTES (link));\n-\t  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_LABEL, label,\n+\t  REG_NOTES (insn) = gen_rtx_INSN_LIST (REG_LABEL, label,\n \t\t\t\t\t\tREG_NOTES (insn));\n \t  if (rescan)\n \t    {\n@@ -3256,7 +3256,7 @@ machine_dependent_reorg (first)\n \t\t\t  || ((reg2 = sfunc_uses_reg (scan))\n \t\t\t      && REGNO (reg2) == REGNO (reg))))\n \t\t    REG_NOTES (scan)\n-\t\t      = gen_rtx_EXPR_LIST (REG_LABEL, label, REG_NOTES (scan));\n+\t\t      = gen_rtx_INSN_LIST (REG_LABEL, label, REG_NOTES (scan));\n \t\t}\n \t      while (scan != dies);\n \t    }"}, {"sha": "a6ea791d12aba428227f2882e045cf28fc7b9eaf", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8c9327ed60bbb966e7c82df75f9aa0faa727e2/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8c9327ed60bbb966e7c82df75f9aa0faa727e2/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=6b8c9327ed60bbb966e7c82df75f9aa0faa727e2", "patch": "@@ -5113,7 +5113,7 @@ add_label_notes (x, insn)\n \t We no longer ignore such label references (see LABEL_REF handling in\n \t mark_jump_label for additional information).  */\n \n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_LABEL, XEXP (x, 0),\n+      REG_NOTES (insn) = gen_rtx_INSN_LIST (REG_LABEL, XEXP (x, 0),\n \t\t\t\t\t    REG_NOTES (insn));\n       if (LABEL_P (XEXP (x, 0)))\n         LABEL_NUSES (XEXP (x, 0))++;"}, {"sha": "5fbe6670f71a50d6cf6df76012d3aaec4e4778e7", "filename": "gcc/loop.c", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8c9327ed60bbb966e7c82df75f9aa0faa727e2/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8c9327ed60bbb966e7c82df75f9aa0faa727e2/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=6b8c9327ed60bbb966e7c82df75f9aa0faa727e2", "patch": "@@ -253,7 +253,7 @@ static rtx gen_add_mult PARAMS ((rtx, rtx, rtx, rtx));\n static void loop_regs_update PARAMS ((const struct loop *, rtx));\n static int iv_add_mult_cost PARAMS ((rtx, rtx, rtx, rtx));\n \n-static rtx loop_insn_emit_after PARAMS((const struct loop *, basic_block, \n+static rtx loop_insn_emit_after PARAMS((const struct loop *, basic_block,\n \t\t\t\t\trtx, rtx));\n static rtx loop_call_insn_emit_before PARAMS((const struct loop *,\n \t\t\t\t\t      basic_block, rtx, rtx));\n@@ -283,8 +283,8 @@ typedef struct loop_replace_args\n } loop_replace_args;\n \n /* Nonzero iff INSN is between START and END, inclusive.  */\n-#define INSN_IN_RANGE_P(INSN, START, END) \t\\\n-  (INSN_UID (INSN) < max_uid_for_loop \t\t\\\n+#define INSN_IN_RANGE_P(INSN, START, END)\t\\\n+  (INSN_UID (INSN) < max_uid_for_loop\t\t\\\n    && INSN_LUID (INSN) >= INSN_LUID (START)\t\\\n    && INSN_LUID (INSN) <= INSN_LUID (END))\n \n@@ -1347,7 +1347,7 @@ combine_movables (movables, regs)\n \t/* We want later insns to match the first one.  Don't make the first\n \t   one match any later ones.  So start this loop at m->next.  */\n \tfor (m1 = m->next; m1; m1 = m1->next)\n-\t  if (m != m1 && m1->match == 0 \n+\t  if (m != m1 && m1->match == 0\n \t      && regs->array[m1->regno].n_times_set == 1\n \t      /* A reg used outside the loop mustn't be eliminated.  */\n \t      && !m1->global\n@@ -1626,7 +1626,7 @@ add_label_notes (x, insns)\n       for (insn = insns; insn; insn = NEXT_INSN (insn))\n \tif (reg_mentioned_p (XEXP (x, 0), insn))\n \t  {\n-\t    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_LABEL, XEXP (x, 0),\n+\t    REG_NOTES (insn) = gen_rtx_INSN_LIST (REG_LABEL, XEXP (x, 0),\n \t\t\t\t\t\t  REG_NOTES (insn));\n \t    if (LABEL_P (XEXP (x, 0)))\n \t      LABEL_NUSES (XEXP (x, 0))++;\n@@ -2179,7 +2179,7 @@ loop_movables_free (movables)\n       m_next = m->next;\n       free (m);\n     }\n-}  \n+}\n \f\n #if 0\n /* Scan X and replace the address of any MEM in it with ADDR.\n@@ -2336,7 +2336,7 @@ prescan_loop (loop)\n   loop_info->num_mem_sets = 0;\n \n \n-  for (insn = start; insn && GET_CODE (insn) != CODE_LABEL; \n+  for (insn = start; insn && GET_CODE (insn) != CODE_LABEL;\n        insn = PREV_INSN (insn))\n     {\n       if (GET_CODE (insn) == CALL_INSN)\n@@ -3620,7 +3620,7 @@ loop_bivs_find (loop)\n   ivs->list = 0;\n \n   for_each_insn_in_loop (loop, check_insn_for_bivs);\n-  \n+\n   /* Scan ivs->list to remove all regs that proved not to be bivs.\n      Make a sanity check against regs->n_times_set.  */\n   for (backbl = &ivs->list, bl = *backbl; bl; bl = bl->next)\n@@ -3747,8 +3747,8 @@ loop_bivs_check (loop)\n \n       if ((GET_MODE (src) == GET_MODE (regno_reg_rtx[bl->regno])\n \t   || GET_MODE (src) == VOIDmode)\n-\t  && valid_initial_value_p (src, bl->init_insn, \n-\t\t\t\t    LOOP_INFO (loop)->pre_header_has_call, \n+\t  && valid_initial_value_p (src, bl->init_insn,\n+\t\t\t\t    LOOP_INFO (loop)->pre_header_has_call,\n \t\t\t\t    loop->start))\n \t{\n \t  bl->initial_value = src;\n@@ -3831,15 +3831,15 @@ loop_biv_eliminable_p (loop, bl, threshold, insn_count)\n      loop->start since these won't be affected by the value of the biv\n      elsewhere in the function, so long as init_insn doesn't use the\n      biv itself.  */\n-  \n+\n   if ((REGNO_LAST_LUID (bl->regno) < INSN_LUID (loop->end)\n        && bl->init_insn\n        && INSN_UID (bl->init_insn) < max_uid_for_loop\n        && REGNO_FIRST_LUID (bl->regno) >= INSN_LUID (bl->init_insn)\n        && ! reg_mentioned_p (bl->biv->dest_reg, SET_SRC (bl->init_set)))\n       || (bl->final_value = final_biv_value (loop, bl)))\n     return maybe_eliminate_biv (loop, bl, 0, threshold,\tinsn_count);\n-  \n+\n   if (loop_dump_stream)\n     {\n       fprintf (loop_dump_stream,\n@@ -3869,12 +3869,12 @@ loop_givs_reduce (loop, bl)\n       if (! v->ignore && v->same == 0)\n \t{\n \t  int auto_inc_opt = 0;\n-\t  \n+\n \t  /* If the code for derived givs immediately below has already\n \t     allocated a new_reg, we must keep it.  */\n \t  if (! v->new_reg)\n \t    v->new_reg = gen_reg_rtx (v->mode);\n-\t  \n+\n #ifdef AUTO_INC_DEC\n \t  /* If the target has auto-increment addressing modes, and\n \t     this is an address giv, then try to put the increment\n@@ -3891,7 +3891,7 @@ loop_givs_reduce (loop, bl)\n \t      /* If other giv's have been combined with this one, then\n \t\t this will work only if all uses of the other giv's occur\n \t\t before this giv's insn.  This is difficult to check.\n-\t\t \n+\n \t\t We simplify this by looking for the common case where\n \t\t there is one DEST_REG giv, and this giv's insn is the\n \t\t last use of the dest_reg of that DEST_REG giv.  If the\n@@ -3903,7 +3903,7 @@ loop_givs_reduce (loop, bl)\n \t      if (v->combined_with)\n \t\t{\n \t\t  struct induction *other_giv = 0;\n-\t\t  \n+\n \t\t  for (tv = bl->giv; tv; tv = tv->next_iv)\n \t\t    if (tv->same == v)\n \t\t      {\n@@ -3931,11 +3931,11 @@ loop_givs_reduce (loop, bl)\n \t\tauto_inc_opt = -1;\n \t      else\n \t\tauto_inc_opt = 1;\n-\t      \n+\n #ifdef HAVE_cc0\n \t      {\n \t\trtx prev;\n-\t\t\n+\n \t\t/* We can't put an insn immediately after one setting\n \t\t   cc0, or immediately before one using cc0.  */\n \t\tif ((auto_inc_opt == 1 && sets_cc0_p (PATTERN (v->insn)))\n@@ -3946,39 +3946,39 @@ loop_givs_reduce (loop, bl)\n \t\t  auto_inc_opt = 0;\n \t      }\n #endif\n-\t      \n+\n \t      if (auto_inc_opt)\n \t\tv->auto_inc_opt = 1;\n \t    }\n #endif\n-\t  \n+\n \t  /* For each place where the biv is incremented, add an insn\n \t     to increment the new, reduced reg for the giv.  */\n \t  for (tv = bl->biv; tv; tv = tv->next_iv)\n \t    {\n \t      rtx insert_before;\n-\t      \n+\n \t      if (! auto_inc_opt)\n \t\tinsert_before = tv->insn;\n \t      else if (auto_inc_opt == 1)\n \t\tinsert_before = NEXT_INSN (v->insn);\n \t      else\n \t\tinsert_before = v->insn;\n-\t      \n+\n \t      if (tv->mult_val == const1_rtx)\n \t\tloop_iv_add_mult_emit_before (loop, tv->add_val, v->mult_val,\n-\t\t\t\t\t      v->new_reg, v->new_reg, \n+\t\t\t\t\t      v->new_reg, v->new_reg,\n \t\t\t\t\t      0, insert_before);\n \t      else /* tv->mult_val == const0_rtx */\n \t\t/* A multiply is acceptable here\n \t\t   since this is presumed to be seldom executed.  */\n \t\tloop_iv_add_mult_emit_before (loop, tv->add_val, v->mult_val,\n-\t\t\t\t\t      v->add_val, v->new_reg, \n+\t\t\t\t\t      v->add_val, v->new_reg,\n \t\t\t\t\t      0, insert_before);\n \t    }\n-\t  \n+\n \t  /* Add code at loop start to initialize giv's reduced reg.  */\n-\t  \n+\n \t  loop_iv_add_mult_hoist (loop,\n \t\t\t\t  extend_value_for_giv (v, bl->initial_value),\n \t\t\t\t  v->mult_val, v->add_val, v->new_reg);\n@@ -4004,12 +4004,12 @@ loop_givs_dead_check (loop, bl)\n       if (v->ignore\n \t  || (v->same && v->same->ignore))\n \tcontinue;\n-      \n+\n       if (v->giv_type == DEST_REG\n \t  && REGNO_FIRST_UID (REGNO (v->dest_reg)) == INSN_UID (v->insn))\n \t{\n \t  struct induction *v1;\n-\t  \n+\n \t  for (v1 = bl->giv; v1; v1 = v1->next_iv)\n \t    if (REGNO_LAST_UID (REGNO (v->dest_reg)) == INSN_UID (v1->insn))\n \t      v->maybe_dead = 1;\n@@ -4030,16 +4030,16 @@ loop_givs_rescan (loop, bl, reg_map)\n     {\n       if (v->same && v->same->ignore)\n \tv->ignore = 1;\n-      \n+\n       if (v->ignore)\n \tcontinue;\n-      \n+\n       /* Update expression if this was combined, in case other giv was\n \t replaced.  */\n       if (v->same)\n \tv->new_reg = replace_rtx (v->new_reg,\n \t\t\t\t  v->same->dest_reg, v->same->new_reg);\n-      \n+\n       /* See if this register is known to be a pointer to something.  If\n \t so, see if we can find the alignment.  First see if there is a\n \t destination register that is a pointer.  If so, this shares the\n@@ -4056,29 +4056,29 @@ loop_givs_rescan (loop, bl, reg_map)\n \t       && REG_POINTER (v->src_reg))\n \t{\n \t  unsigned int align = REGNO_POINTER_ALIGN (REGNO (v->src_reg));\n-\t  \n+\n \t  if (align == 0\n \t      || GET_CODE (v->add_val) != CONST_INT\n \t      || INTVAL (v->add_val) % (align / BITS_PER_UNIT) != 0)\n \t    align = 0;\n-\t  \n+\n \t  mark_reg_pointer (v->new_reg, align);\n \t}\n       else if (GET_CODE (v->new_reg) == REG\n \t       && GET_CODE (v->add_val) == REG\n \t       && REG_POINTER (v->add_val))\n \t{\n \t  unsigned int align = REGNO_POINTER_ALIGN (REGNO (v->add_val));\n-\t  \n+\n \t  if (align == 0 || GET_CODE (v->mult_val) != CONST_INT\n \t      || INTVAL (v->mult_val) % (align / BITS_PER_UNIT) != 0)\n \t    align = 0;\n-\t  \n+\n \t  mark_reg_pointer (v->new_reg, align);\n \t}\n       else if (GET_CODE (v->new_reg) == REG && v->giv_type == DEST_ADDR)\n \tmark_reg_pointer (v->new_reg, 0);\n-      \n+\n       if (v->giv_type == DEST_ADDR)\n \t/* Store reduced reg as the address in the memref where we found\n \t   this giv.  */\n@@ -4091,23 +4091,23 @@ loop_givs_rescan (loop, bl, reg_map)\n \t{\n \t  /* Not replaceable; emit an insn to set the original giv reg from\n \t     the reduced giv, same as above.  */\n-\t  loop_insn_emit_after (loop, 0, v->insn, \n+\t  loop_insn_emit_after (loop, 0, v->insn,\n \t\t\t\tgen_move_insn (v->dest_reg, v->new_reg));\n \t}\n-      \n+\n       /* When a loop is reversed, givs which depend on the reversed\n \t biv, and which are live outside the loop, must be set to their\n \t correct final value.  This insn is only needed if the giv is\n \t not replaceable.  The correct final value is the same as the\n \t value that the giv starts the reversed loop with.  */\n       if (bl->reversed && ! v->replaceable)\n-\tloop_iv_add_mult_sink (loop, \n+\tloop_iv_add_mult_sink (loop,\n \t\t\t       extend_value_for_giv (v, bl->initial_value),\n \t\t\t       v->mult_val, v->add_val, v->dest_reg);\n       else if (v->final_value)\n-\tloop_insn_sink_or_swim (loop, \n+\tloop_insn_sink_or_swim (loop,\n \t\t\t\tgen_move_insn (v->dest_reg, v->final_value));\n-      \n+\n       if (loop_dump_stream)\n \t{\n \t  fprintf (loop_dump_stream, \"giv at %d reduced to \",\n@@ -4133,7 +4133,7 @@ loop_giv_reduce_benefit (loop, bl, v, test_reg)\n   PUT_MODE (test_reg, v->mode);\n   add_cost = iv_add_mult_cost (bl->biv->add_val, v->mult_val,\n \t\t\t       test_reg, test_reg);\n-  \n+\n   /* Reduce benefit if not replaceable, since we will insert a\n      move-insn to replace the insn that calculates this giv.  Don't do\n      this unless the giv is a user variable, since it will often be\n@@ -4147,7 +4147,7 @@ loop_giv_reduce_benefit (loop, bl, v, test_reg)\n   if (! v->replaceable && ! bl->eliminable\n       && REG_USERVAR_P (v->dest_reg))\n     benefit -= copy_cost;\n-  \n+\n   /* Decrease the benefit to count the add-insns that we will insert\n      to increment the reduced reg for the giv.  ??? This can\n      overestimate the run-time cost of the additional insns, e.g. if\n@@ -4202,15 +4202,15 @@ loop_ivs_free (loop)\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n   struct iv_class *iv = ivs->list;\n-  \n+\n   free (ivs->regs);\n \n   while (iv)\n     {\n       struct iv_class *next = iv->next;\n       struct induction *induction;\n       struct induction *next_induction;\n-      \n+\n       for (induction = iv->biv; induction; induction = next_induction)\n \t{\n \t  next_induction = induction->next_iv;\n@@ -4221,7 +4221,7 @@ loop_ivs_free (loop)\n \t  next_induction = induction->next_iv;\n \t  free (induction);\n \t}\n-      \n+\n       free (iv);\n       iv = next;\n     }\n@@ -4322,7 +4322,7 @@ strength_reduce (loop, flags)\n     {\n       struct induction *v;\n       int benefit;\n-      \n+\n       /* Test whether it will be possible to eliminate this biv\n \t provided all givs are reduced.  */\n       bl->eliminable = loop_biv_eliminable_p (loop, bl, threshold, insn_count);\n@@ -5009,12 +5009,12 @@ record_giv (loop, v, insn, src_reg, dest_reg, mult_val, add_val, ext_val,\n     {\n       /* The giv can be replaced outright by the reduced register only if all\n \t of the following conditions are true:\n- \t - the insn that sets the giv is always executed on any iteration\n+\t - the insn that sets the giv is always executed on any iteration\n \t   on which the giv is used at all\n \t   (there are two ways to deduce this:\n \t    either the insn is executed on every iteration,\n \t    or all uses follow that insn in the same basic block),\n- \t - the giv is not used outside the loop\n+\t - the giv is not used outside the loop\n \t - no assignments to the biv occur during the giv's lifetime.  */\n \n       if (REGNO_FIRST_UID (REGNO (dest_reg)) == INSN_UID (insn)\n@@ -5498,7 +5498,7 @@ basic_induction_var (loop, x, mode, dest_reg, p, inc_val, mult_val, location)\n       /* Fall through.  */\n \n       /* Can accept constant setting of biv only when inside inner most loop.\n-  \t Otherwise, a biv of an inner loop may be incorrectly recognized\n+\t Otherwise, a biv of an inner loop may be incorrectly recognized\n \t as a biv of the outer loop,\n \t causing code to be moved INTO the inner loop.  */\n     case MEM:\n@@ -5660,7 +5660,7 @@ general_induction_var (loop, x, src_reg, add_val, mult_val, ext_val,\n \f\n /* Given an expression, X, try to form it as a linear function of a biv.\n    We will canonicalize it to be of the form\n-   \t(plus (mult (BIV) (invar_1))\n+\t(plus (mult (BIV) (invar_1))\n \t      (invar_2))\n    with possible degeneracies.\n \n@@ -5726,7 +5726,7 @@ simplify_giv_expr (loop, x, ext_val, benefit)\n \t  case CONST_INT:\n \t  case USE:\n \t    /* Adding two invariants must result in an invariant, so enclose\n- \t       addition operation inside a USE and return it.  */\n+\t       addition operation inside a USE and return it.  */\n \t    if (GET_CODE (arg0) == USE)\n \t      arg0 = XEXP (arg0, 0);\n \t    if (GET_CODE (arg1) == USE)\n@@ -6280,7 +6280,7 @@ consec_sets_giv (loop, first_benefit, p, src_reg, dest_reg,\n    it cannot possibly be a valid address, 0 is returned.\n \n    To perform the computation, we note that\n-   \tG1 = x * v + a\t\tand\n+\tG1 = x * v + a\t\tand\n \tG2 = y * v + b\n    where `v' is the biv.\n \n@@ -6944,7 +6944,7 @@ loop_regs_update (loop, seq)\n \t    record_base_value (REGNO (SET_DEST (set)), SET_SRC (set), 0);\n \t}\n     }\n-  else \n+  else\n     {\n       rtx set = single_set (seq);\n       if (set && GET_CODE (SET_DEST (set)) == REG)\n@@ -8095,7 +8095,7 @@ maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where_bb, where_insn)\n \t\t\t\t v->new_reg, 1);\n \n \t\t/* Compute value to compare against.  */\n-\t\tloop_iv_add_mult_emit_before (loop, arg, \n+\t\tloop_iv_add_mult_emit_before (loop, arg,\n \t\t\t\t\t      v->mult_val, v->add_val,\n \t\t\t\t\t      tem, where_bb, where_insn);\n \t\t/* Use it in this insn.  */\n@@ -8133,7 +8133,7 @@ maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where_bb, where_insn)\n \t\t\t\t     v->new_reg, 1);\n \n \t\t    /* Compute value to compare against.  */\n-\t\t    loop_iv_add_mult_emit_before (loop, arg, \n+\t\t    loop_iv_add_mult_emit_before (loop, arg,\n \t\t\t\t\t\t  v->mult_val, v->add_val,\n \t\t\t\t\t\t  tem, where_bb, where_insn);\n \t\t    validate_change (insn, &XEXP (x, arg_operand), tem, 1);\n@@ -8169,7 +8169,7 @@ maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where_bb, where_insn)\n \t      if (v->ignore || v->maybe_dead || v->mode != mode)\n \t\tcontinue;\n \n-\t      for (tv = REG_IV_CLASS (ivs, REGNO (arg))->giv; tv; \n+\t      for (tv = REG_IV_CLASS (ivs, REGNO (arg))->giv; tv;\n \t\t   tv = tv->next_iv)\n \t\tif (! tv->ignore && ! tv->maybe_dead\n \t\t    && rtx_equal_p (tv->mult_val, v->mult_val)\n@@ -8291,8 +8291,8 @@ update_reg_last_use (x, insn)\n   /* Check for the case where INSN does not have a valid luid.  In this case,\n      there is no need to modify the regno_last_uid, as this can only happen\n      when code is inserted after the loop_end to set a pseudo's final value,\n-     and hence this insn will never be the last use of x. \n-     ???? This comment is not correct.  See for example loop_givs_reduce.  \n+     and hence this insn will never be the last use of x.\n+     ???? This comment is not correct.  See for example loop_givs_reduce.\n      This may insert an insn before another new insn.  */\n   if (GET_CODE (x) == REG && REGNO (x) < max_reg_before_loop\n       && INSN_UID (insn) < max_uid_for_loop\n@@ -8762,7 +8762,7 @@ loop_regs_scan (loop, extra_size)\n   if (regs->num >= regs->size)\n     {\n       regs->size = regs->num + extra_size;\n-      \n+\n       regs->array = (struct loop_reg *)\n \txrealloc (regs->array, regs->size * sizeof (*regs->array));\n \n@@ -8823,7 +8823,7 @@ loop_regs_scan (loop, extra_size)\n     if (GET_MODE_CLASS (GET_MODE (regno_reg_rtx[i])) == MODE_CC)\n       regs->array[i].may_not_optimize = 1;\n #endif\n-  \n+\n   /* Set regs->array[I].n_times_set for the new registers.  */\n   for (i = old_nregs; i < regs->num; i++)\n     regs->array[i].n_times_set = regs->array[i].set_in_loop;\n@@ -9723,7 +9723,7 @@ loop_iv_class_dump (bl, file, verbose)\n   /* List the givs.  */\n   for (i = 0, v = bl->giv; v; v = v->next_iv, i++)\n     {\n-      fprintf (file, \" Giv%d: insn %d, benefit %d, \", \n+      fprintf (file, \" Giv%d: insn %d, benefit %d, \",\n \t       i, INSN_UID (v->insn), v->benefit);\n       if (v->giv_type == DEST_ADDR)\n \t  print_simple_rtl (file, v->mem);\n@@ -9751,7 +9751,7 @@ loop_biv_dump (v, file, verbose)\n \n   if (verbose && v->final_value)\n     {\n-      fputc ('\\n', file);  \n+      fputc ('\\n', file);\n       fprintf (file, \" final \");\n       print_simple_rtl (file, v->final_value);\n     }\n@@ -9771,22 +9771,22 @@ loop_giv_dump (v, file, verbose)\n \n   if (v->giv_type == DEST_REG)\n     fprintf (file, \"Giv %d: insn %d\",\n-\t     REGNO (v->dest_reg),  INSN_UID (v->insn)); \n+\t     REGNO (v->dest_reg),  INSN_UID (v->insn));\n   else\n     fprintf (file, \"Dest address: insn %d\",\n \t     INSN_UID (v->insn));\n-  \n+\n   fprintf (file, \" src reg %d benefit %d\",\n \t   REGNO (v->src_reg), v->benefit);\n   fprintf (file, \" lifetime %d\",\n \t   v->lifetime);\n-  \n+\n   if (v->replaceable)\n     fprintf (file, \" replaceable\");\n-  \n+\n   if (v->no_const_addval)\n     fprintf (file, \" ncav\");\n-  \n+\n   if (v->ext_dependant)\n     {\n       switch (GET_CODE (v->ext_dependant))\n@@ -9805,22 +9805,22 @@ loop_giv_dump (v, file, verbose)\n \t}\n     }\n \n-  fputc ('\\n', file);  \n+  fputc ('\\n', file);\n   fprintf (file, \" mult \");\n   print_simple_rtl (file, v->mult_val);\n \n-  fputc ('\\n', file);  \n+  fputc ('\\n', file);\n   fprintf (file, \" add  \");\n   print_simple_rtl (file, v->add_val);\n \n   if (verbose && v->final_value)\n     {\n-      fputc ('\\n', file);  \n+      fputc ('\\n', file);\n       fprintf (file, \" final \");\n       print_simple_rtl (file, v->final_value);\n     }\n \n-  fputc ('\\n', file);  \n+  fputc ('\\n', file);\n }\n \n "}, {"sha": "9fb19bae478186fd8ef0924e3ce016a4114277ab", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8c9327ed60bbb966e7c82df75f9aa0faa727e2/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8c9327ed60bbb966e7c82df75f9aa0faa727e2/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=6b8c9327ed60bbb966e7c82df75f9aa0faa727e2", "patch": "@@ -3875,7 +3875,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  if (GET_CODE (insn) != JUMP_INSN\n \t      && GET_CODE (substitution) == LABEL_REF\n \t      && !find_reg_note (insn, REG_LABEL, XEXP (substitution, 0)))\n-\t    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_LABEL,\n+\t    REG_NOTES (insn) = gen_rtx_INSN_LIST (REG_LABEL,\n \t\t\t\t\t\t  XEXP (substitution, 0),\n \t\t\t\t\t\t  REG_NOTES (insn));\n \t}\n@@ -5782,7 +5782,7 @@ subst_reloads (insn)\n \t     register refers to.  */\n \t  if (GET_CODE (*r->where) == LABEL_REF\n \t      && GET_CODE (insn) == JUMP_INSN)\n-\t    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_LABEL,\n+\t    REG_NOTES (insn) = gen_rtx_INSN_LIST (REG_LABEL,\n \t\t\t\t\t\t  XEXP (*r->where, 0),\n \t\t\t\t\t\t  REG_NOTES (insn));\n "}]}