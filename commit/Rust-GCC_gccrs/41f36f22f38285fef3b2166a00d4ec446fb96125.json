{"sha": "41f36f22f38285fef3b2166a00d4ec446fb96125", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDFmMzZmMjJmMzgyODVmZWYzYjIxNjZhMDBkNGVjNDQ2ZmI5NjEyNQ==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2019-12-09T11:40:36Z"}, "committer": {"name": "Thomas Schwinge", "email": "tschwinge@gcc.gnu.org", "date": "2019-12-09T11:40:36Z"}, "message": "[PR92511] More testing for OpenACC \"present\" subarrays\n\nIn particular, \"subset subarrays\".\n\n\tlibgomp/\n\tPR libgomp/92511\n\t* testsuite/libgomp.oacc-c-c++-common/copyin-devptr-1.c: Remove\n\tthis file...\n\t* testsuite/libgomp.oacc-c-c++-common/copyin-devptr-2.c: ..., and\n\tthis file...\n\t* testsuite/libgomp.oacc-c-c++-common/lib-22.c: ..., and this\n\tfile...\n\t* testsuite/libgomp.oacc-c-c++-common/lib-30.c: ..., and this\n\tfile...\n\t* testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-r-p.c:\n\t... with their content moved into, and extended in this new file.\n\t* testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-d-a.c:\n\tNew file.\n\t* testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-d-p.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-r-a.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-2.c:\n\tLikewise.\n\nFrom-SVN: r279122", "tree": {"sha": "502c8735398818d41c68770da6a248b171a009fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/502c8735398818d41c68770da6a248b171a009fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41f36f22f38285fef3b2166a00d4ec446fb96125", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41f36f22f38285fef3b2166a00d4ec446fb96125", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41f36f22f38285fef3b2166a00d4ec446fb96125", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41f36f22f38285fef3b2166a00d4ec446fb96125/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6effebe10be2c53472db9eb573cdeeac312036c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6effebe10be2c53472db9eb573cdeeac312036c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6effebe10be2c53472db9eb573cdeeac312036c1"}], "stats": {"total": 796, "additions": 670, "deletions": 126}, "files": [{"sha": "739a76d48ac8d2c641824970924ec05db499b6b7", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f36f22f38285fef3b2166a00d4ec446fb96125/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f36f22f38285fef3b2166a00d4ec446fb96125/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=41f36f22f38285fef3b2166a00d4ec446fb96125", "patch": "@@ -1,5 +1,25 @@\n 2019-12-09  Thomas Schwinge  <thomas@codesourcery.com>\n \n+\tPR libgomp/92511\n+\t* testsuite/libgomp.oacc-c-c++-common/copyin-devptr-1.c: Remove\n+\tthis file...\n+\t* testsuite/libgomp.oacc-c-c++-common/copyin-devptr-2.c: ..., and\n+\tthis file...\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-22.c: ..., and this\n+\tfile...\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-30.c: ..., and this\n+\tfile...\n+\t* testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-r-p.c:\n+\t... with their content moved into, and extended in this new file.\n+\t* testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-d-a.c:\n+\tNew file.\n+\t* testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-d-p.c:\n+\tLikewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-r-a.c:\n+\tLikewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-2.c:\n+\tLikewise.\n+\n \t* testsuite/libgomp.oacc-c-c++-common/map-data-1.c: New file.\n \n \tPR libgomp/92854"}, {"sha": "7e50f3b892e5db04d64210259e9b12c21acbf8fe", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/copyin-devptr-1.c", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6effebe10be2c53472db9eb573cdeeac312036c1/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcopyin-devptr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6effebe10be2c53472db9eb573cdeeac312036c1/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcopyin-devptr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcopyin-devptr-1.c?ref=6effebe10be2c53472db9eb573cdeeac312036c1", "patch": "@@ -1,28 +0,0 @@\n-/* { dg-skip-if \"\" { *-*-* } { \"-DACC_MEM_SHARED=1\" } } */\n-\n-#include <openacc.h>\n-#include <stdlib.h>\n-#include <assert.h>\n-#include <stdint.h>\n-\n-int main (int argc, char* argv[])\n-{\n-  char *myblock = (char *) malloc (1024);\n-  int i;\n-  void *dst;\n-  for (i = 0; i < 1024; i++)\n-    myblock[i] = i;\n-  dst = acc_copyin (myblock, 1024);\n-  for (i = 0; i < 1024; i += 256)\n-    {\n-      void *partdst = acc_pcopyin (&myblock[i], 256);\n-      assert ((uintptr_t) partdst == (uintptr_t) dst + i);\n-    }\n-  for (i = 0; i < 1024; i += 256)\n-    acc_delete (&myblock[i], 256);\n-  assert (acc_is_present (myblock, 1024));\n-  acc_delete (myblock, 1024);\n-  assert (!acc_is_present (myblock, 1024));\n-  free (myblock);\n-  return 0;\n-}"}, {"sha": "00e7da1f128b7ff01f422104ae9f58d5fc47d349", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/copyin-devptr-2.c", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6effebe10be2c53472db9eb573cdeeac312036c1/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcopyin-devptr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6effebe10be2c53472db9eb573cdeeac312036c1/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcopyin-devptr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcopyin-devptr-2.c?ref=6effebe10be2c53472db9eb573cdeeac312036c1", "patch": "@@ -1,35 +0,0 @@\n-/* { dg-skip-if \"\" { *-*-* } { \"-DACC_MEM_SHARED=1\" } } */\n-\n-#include <openacc.h>\n-#include <stdlib.h>\n-#include <assert.h>\n-#include <stdint.h>\n-\n-int main (int argc, char* argv[])\n-{\n-  char *block1 = (char *) malloc (1024);\n-  char *block2 = (char *) malloc (1024);\n-  char *block3 = (char *) malloc (1024);\n-  int i;\n-  void *dst;\n-  for (i = 0; i < 1024; i++)\n-    block1[i] = block2[i] = block3[i] = i;\n-  #pragma acc data copyin(block1[0:1024]) copyin(block2[0:1024]) \\\n-\t\t   copyin(block3[0:1024])\n-  {\n-    dst = acc_deviceptr (block2);\n-    for (i = 0; i < 1024; i += 256)\n-      {\n-\tvoid *partdst = acc_pcopyin (&block2[i], 256);\n-\tassert ((uintptr_t) partdst == (uintptr_t) dst + i);\n-      }\n-  }\n-  assert (acc_is_present (block2, 1024));\n-  for (i = 0; i < 1024; i += 256)\n-    acc_delete (&block2[i], 256);\n-  assert (!acc_is_present (block2, 1024));\n-  free (block1);\n-  free (block2);\n-  free (block3);\n-  return 0;\n-}"}, {"sha": "cb32bbcb652e256635acb9dced4d74bfed50fca5", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-22.c", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6effebe10be2c53472db9eb573cdeeac312036c1/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6effebe10be2c53472db9eb573cdeeac312036c1/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-22.c?ref=6effebe10be2c53472db9eb573cdeeac312036c1", "patch": "@@ -1,33 +0,0 @@\n-/* Exercise acc_copyin and acc_copyout on nvidia targets.  */\n-\n-/* { dg-do run { target openacc_nvidia_accel_selected } } */\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <openacc.h>\n-\n-int\n-main (int argc, char **argv)\n-{\n-  const int N = 256;\n-  int i;\n-  unsigned char *h;\n-\n-  h = (unsigned char *) malloc (N);\n-\n-  for (i = 0; i < N; i++)\n-    {\n-      h[i] = i;\n-    }\n-\n-  (void) acc_copyin (h, N);\n-\n-  fprintf (stderr, \"CheCKpOInT\\n\");\n-  acc_copyout (h + 1, N - 1);\n-\n-  free (h);\n-\n-  return 0;\n-}\n-\n-/* { dg-output \"CheCKpOInT(\\n|\\r\\n|\\r).*\" } */"}, {"sha": "d0e5ffb069106a42662ed2bd1daecf5034db335f", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-30.c", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6effebe10be2c53472db9eb573cdeeac312036c1/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6effebe10be2c53472db9eb573cdeeac312036c1/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-30.c?ref=6effebe10be2c53472db9eb573cdeeac312036c1", "patch": "@@ -1,30 +0,0 @@\n-/* Exercise an invalid partial acc_delete on nvidia targets.  */\n-\n-/* { dg-do run { target openacc_nvidia_accel_selected } } */\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <openacc.h>\n-\n-int\n-main (int argc, char **argv)\n-{\n-  const int N = 256;\n-  unsigned char *h;\n-  void *d;\n-\n-  h = (unsigned char *) malloc (N);\n-\n-  d = acc_create (h, N);\n-  if (!d)\n-    abort ();\n-\n-  fprintf (stderr, \"CheCKpOInT\\n\");\n-  acc_delete (h, N - 2);\n-\n-  free (h);\n-\n-  return 0;\n-}\n-\n-/* { dg-output \"CheCKpOInT(\\n|\\r\\n|\\r).*\" } */"}, {"sha": "1d168c2e5856e68b2c1b3d248f62b2fb6d56569f", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-d-a.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f36f22f38285fef3b2166a00d4ec446fb96125/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fsubset-subarray-mappings-1-d-a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f36f22f38285fef3b2166a00d4ec446fb96125/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fsubset-subarray-mappings-1-d-a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fsubset-subarray-mappings-1-d-a.c?ref=41f36f22f38285fef3b2166a00d4ec446fb96125", "patch": "@@ -0,0 +1,7 @@\n+/* Test \"subset\" subarray mappings\n+   { dg-additional-options \"-DOPENACC_DIRECTIVES\" } using OpenACC directives,\n+   { dg-additional-options \"-DARRAYS\" } using arrays.  */\n+\n+/* { dg-skip-if \"\" { *-*-* } { \"-DACC_MEM_SHARED=1\" } } */\n+\n+#include \"subset-subarray-mappings-1-r-p.c\""}, {"sha": "68ed0ce3ecaf6864fc236bd4fcce73a562533dd9", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-d-p.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f36f22f38285fef3b2166a00d4ec446fb96125/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fsubset-subarray-mappings-1-d-p.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f36f22f38285fef3b2166a00d4ec446fb96125/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fsubset-subarray-mappings-1-d-p.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fsubset-subarray-mappings-1-d-p.c?ref=41f36f22f38285fef3b2166a00d4ec446fb96125", "patch": "@@ -0,0 +1,7 @@\n+/* Test \"subset\" subarray mappings\n+   { dg-additional-options \"-DOPENACC_DIRECTIVES\" } using OpenACC directives,\n+   { dg-additional-options \"-DPOINTERS\" } using pointers.  */\n+\n+/* { dg-skip-if \"\" { *-*-* } { \"-DACC_MEM_SHARED=1\" } } */\n+\n+#include \"subset-subarray-mappings-1-r-p.c\""}, {"sha": "5c0fd040d8758d1daf7ccb0bb602a6092174ca76", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-r-a.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f36f22f38285fef3b2166a00d4ec446fb96125/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fsubset-subarray-mappings-1-r-a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f36f22f38285fef3b2166a00d4ec446fb96125/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fsubset-subarray-mappings-1-r-a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fsubset-subarray-mappings-1-r-a.c?ref=41f36f22f38285fef3b2166a00d4ec446fb96125", "patch": "@@ -0,0 +1,7 @@\n+/* Test \"subset\" subarray mappings\n+   { dg-additional-options \"-DOPENACC_RUNTIME\" } using OpenACC Runtime Library routines,\n+   { dg-additional-options \"-DARRAYS\" } using arrays.  */\n+\n+/* { dg-skip-if \"\" { *-*-* } { \"-DACC_MEM_SHARED=1\" } } */\n+\n+#include \"subset-subarray-mappings-1-r-p.c\""}, {"sha": "9b5d83c66ddc7ee07b2e335c17a318f261557c52", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-1-r-p.c", "status": "added", "additions": 514, "deletions": 0, "changes": 514, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f36f22f38285fef3b2166a00d4ec446fb96125/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fsubset-subarray-mappings-1-r-p.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f36f22f38285fef3b2166a00d4ec446fb96125/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fsubset-subarray-mappings-1-r-p.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fsubset-subarray-mappings-1-r-p.c?ref=41f36f22f38285fef3b2166a00d4ec446fb96125", "patch": "@@ -0,0 +1,514 @@\n+/* Test \"subset\" subarray mappings\n+   { dg-additional-options \"-DOPENACC_RUNTIME\" } using OpenACC Runtime Library routines,\n+   { dg-additional-options \"-DPOINTERS\" } using pointers.  */\n+\n+/* { dg-skip-if \"\" { *-*-* } { \"-DACC_MEM_SHARED=1\" } } */\n+\n+#if OPENACC_RUNTIME\n+#elif OPENACC_DIRECTIVES\n+#else\n+# error\n+#endif\n+\n+#if POINTERS\n+#elif ARRAYS\n+#else\n+# error\n+#endif\n+\n+\n+#include <openacc.h>\n+#include <acc_prof.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdint.h>\n+#include <stdbool.h>\n+\n+\n+static bool cb_ev_alloc_expected;\n+static size_t cb_ev_alloc_bytes;\n+static const void *cb_ev_alloc_device_ptr;\n+static void\n+cb_ev_alloc (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  assert (cb_ev_alloc_expected);\n+  cb_ev_alloc_expected = false;\n+\n+  cb_ev_alloc_bytes = event_info->data_event.bytes;\n+  cb_ev_alloc_device_ptr = event_info->data_event.device_ptr;\n+}\n+\n+static bool cb_ev_free_expected;\n+static const void *cb_ev_free_device_ptr;\n+static void\n+cb_ev_free (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  assert (cb_ev_free_expected);\n+  cb_ev_free_expected = false;\n+\n+  cb_ev_free_device_ptr = event_info->data_event.device_ptr;\n+}\n+\n+\n+/* Match the alignment processing that\n+   'libgomp/target.c:gomp_map_vars_internal' is doing; simplified, not\n+   considering special alignment requirements of certain data types.  */\n+\n+static size_t\n+aligned_size (size_t tgt_size)\n+{\n+  size_t tgt_align = sizeof (void *);\n+  return tgt_size + tgt_align - 1;\n+}\n+\n+static const void *\n+aligned_address (const void *tgt_start)\n+{\n+  size_t tgt_align = sizeof (void *);\n+  return (void *) (((uintptr_t) tgt_start + tgt_align - 1) & ~(tgt_align - 1));\n+}\n+\n+\n+#define SIZE 1024\n+#define SUBSET 32\n+\n+\n+static void\n+f1 (void)\n+{\n+  cb_ev_alloc_expected = false;\n+  cb_ev_free_expected = false;\n+  acc_prof_register (acc_ev_alloc, cb_ev_alloc, acc_reg);\n+  acc_prof_register (acc_ev_free, cb_ev_free, acc_reg);\n+\n+#if POINTERS\n+  char* myblock = (char *) malloc (SIZE);\n+#else\n+  char myblock[SIZE];\n+#endif\n+  int i;\n+  void *dst;\n+  for (i = 0; i < SIZE; i++)\n+    myblock[i] = i;\n+\n+  cb_ev_alloc_expected = true;\n+#if OPENACC_RUNTIME\n+  dst = acc_copyin (myblock, SIZE);\n+#else\n+# if POINTERS\n+#  pragma acc enter data copyin (myblock[0:SIZE])\n+# else\n+#  pragma acc enter data copyin (myblock)\n+# endif\n+  dst = acc_deviceptr (myblock);\n+#endif\n+  assert (dst);\n+  assert (!cb_ev_alloc_expected);\n+  assert (cb_ev_alloc_bytes == aligned_size (SIZE));\n+  assert (aligned_address (cb_ev_alloc_device_ptr) == dst);\n+  for (i = 0; i < SIZE; i += SUBSET)\n+    {\n+      void *partdst = acc_deviceptr (&myblock[i]);\n+      assert ((uintptr_t) partdst == (uintptr_t) dst + i);\n+      assert (acc_hostptr (partdst) == &myblock[i]);\n+    }\n+  for (i = 0; i < SIZE; i += SUBSET)\n+    {\n+      void *partdst;\n+#if OPENACC_RUNTIME\n+      partdst = acc_pcopyin (&myblock[i], SUBSET);\n+#else\n+# pragma acc enter data pcopyin (myblock[i:SUBSET])\n+      partdst = acc_deviceptr (&myblock[i]);\n+#endif\n+      assert ((uintptr_t) partdst == (uintptr_t) dst + i);\n+    }\n+  /* Dereference first half.  */\n+  for (i = 0; i < 512; i += SUBSET)\n+    {\n+      assert (acc_is_present (&myblock[i], SUBSET));\n+      assert (acc_is_present (myblock, SIZE));\n+#if OPENACC_RUNTIME\n+      acc_delete (&myblock[i], SUBSET);\n+#else\n+# pragma acc exit data delete (myblock[i:SUBSET])\n+#endif\n+      assert (acc_is_present (&myblock[i], SUBSET));\n+      assert (acc_is_present (myblock, SIZE));\n+    }\n+  /* Dereference all.  */\n+#if OPENACC_RUNTIME\n+  acc_delete (myblock, SIZE);\n+#else\n+# if POINTERS\n+#  pragma acc exit data delete (myblock[0:SIZE])\n+# else\n+#  pragma acc exit data delete (myblock)\n+# endif\n+#endif\n+  /* Expect it's still present.  */\n+  assert (acc_is_present (myblock, SIZE));\n+  /* Dereference second half.  */\n+  for (i = 512; i < SIZE; i += SUBSET)\n+    {\n+      bool last = i >= SIZE - SUBSET;\n+\n+      assert (acc_is_present (&myblock[i], SUBSET));\n+      assert (acc_is_present (myblock, SIZE));\n+#if 0 //TODO PR92848\n+      if (last)\n+\tcb_ev_free_expected = true;\n+#endif\n+#if OPENACC_RUNTIME\n+      acc_delete (&myblock[i], SUBSET);\n+#else\n+# pragma acc exit data delete (myblock[i:SUBSET])\n+#endif\n+#if 0 //TODO PR92848\n+      assert (!cb_ev_free_expected);\n+      if (last)\n+\tassert (cb_ev_free_device_ptr == cb_ev_alloc_device_ptr);\n+#endif\n+      assert (acc_is_present (&myblock[i], SUBSET) != last);\n+      assert (acc_is_present (myblock, SIZE) != last);\n+    }\n+  /* Expect it's all gone now.  */\n+  for (i = 512; i < SIZE; i += SUBSET)\n+    assert (!acc_is_present (&myblock[i], SUBSET));\n+  assert (!acc_is_present (myblock, SIZE));\n+  assert (!acc_is_present (myblock, 1));\n+\n+#if POINTERS\n+  free (myblock);\n+#endif\n+\n+  acc_prof_unregister (acc_ev_alloc, cb_ev_alloc, acc_reg);\n+  acc_prof_unregister (acc_ev_free, cb_ev_free, acc_reg);\n+}\n+\n+\n+static void\n+f2 (void)\n+{\n+  cb_ev_alloc_expected = false;\n+  cb_ev_free_expected = false;\n+  acc_prof_register (acc_ev_alloc, cb_ev_alloc, acc_reg);\n+  acc_prof_register (acc_ev_free, cb_ev_free, acc_reg);\n+\n+#if POINTERS\n+  char *block1 = (char *) malloc (SIZE);\n+  char *block2 = (char *) malloc (SIZE);\n+  char *block3 = (char *) malloc (SIZE);\n+#else\n+  char block1[SIZE];\n+  char block2[SIZE];\n+  char block3[SIZE];\n+#endif\n+  int i;\n+  for (i = 0; i < SIZE; i++)\n+    block1[i] = block2[i] = block3[i] = i;\n+\n+  cb_ev_alloc_expected = true;\n+#if POINTERS\n+# pragma acc data copyin(block1[0:SIZE], block2[0:SIZE], block3[0:SIZE])\n+#else\n+# pragma acc data copyin(block1, block2, block3)\n+#endif\n+  {\n+    void *block1_d = acc_deviceptr (block1);\n+    void *block2_d = acc_deviceptr (block2);\n+    void *block3_d = acc_deviceptr (block3);\n+    assert (!cb_ev_alloc_expected);\n+    /* 'block1', 'block2', 'block3' get mapped in one device memory object, in\n+       reverse order.  */\n+    assert (cb_ev_alloc_bytes == aligned_size (3 * SIZE));\n+    assert ((void *) ((uintptr_t) aligned_address (cb_ev_alloc_device_ptr) + 2 * SIZE) == block1_d);\n+    assert ((void *) ((uintptr_t) aligned_address (cb_ev_alloc_device_ptr) + 1 * SIZE) == block2_d);\n+    assert ((void *) ((uintptr_t) aligned_address (cb_ev_alloc_device_ptr) + 0 * SIZE) == block3_d);\n+\n+    for (i = 0; i < SIZE; i += SUBSET)\n+      {\n+\tvoid *block2_part_d;\n+#if OPENACC_RUNTIME\n+\tblock2_part_d = acc_pcopyin (&block2[i], SUBSET);\n+#else\n+# pragma acc enter data pcopyin (block2[i:SUBSET])\n+\tblock2_part_d = acc_deviceptr (&block2[i]);\n+#endif\n+\tassert ((uintptr_t) block2_part_d == (uintptr_t) block2_d + i);\n+      }\n+  }\n+  /* The mappings have been removed, but the device memory object has not yet\n+     been 'free'd.  */\n+  assert (!acc_is_present (block1, SIZE));\n+  assert (acc_is_present (block2, SIZE));\n+  assert (!acc_is_present (block3, SIZE));\n+  for (i = 0; i < SIZE; i += SUBSET)\n+    {\n+      bool last = i >= SIZE - SUBSET;\n+\n+      assert (acc_is_present (block2, SIZE));\n+      if (last)\n+\tcb_ev_free_expected = true;\n+#if OPENACC_RUNTIME\n+      acc_delete (&block2[i], SUBSET);\n+#else\n+# pragma acc exit data delete (block2[i:SUBSET])\n+#endif\n+      assert (!cb_ev_free_expected);\n+      if (last)\n+\tassert (cb_ev_free_device_ptr == cb_ev_alloc_device_ptr);\n+    }\n+  assert (!acc_is_present (block1, SIZE));\n+  assert (!acc_is_present (block2, SIZE));\n+  assert (!acc_is_present (block3, SIZE));\n+\n+#if POINTERS\n+  free (block1);\n+  free (block2);\n+  free (block3);\n+#endif\n+\n+  acc_prof_unregister (acc_ev_alloc, cb_ev_alloc, acc_reg);\n+  acc_prof_unregister (acc_ev_free, cb_ev_free, acc_reg);\n+}\n+\n+\n+static void\n+f3 ()\n+{\n+  cb_ev_alloc_expected = false;\n+  cb_ev_free_expected = false;\n+  acc_prof_register (acc_ev_alloc, cb_ev_alloc, acc_reg);\n+  acc_prof_register (acc_ev_free, cb_ev_free, acc_reg);\n+\n+#if POINTERS\n+  char *h = (char *) malloc (SIZE);\n+#else\n+  char h[SIZE];\n+#endif\n+\n+  char *d1;\n+  cb_ev_alloc_expected = true;\n+#if OPENACC_RUNTIME\n+  d1 = (char *) acc_present_or_create (h, SIZE);\n+#else\n+# if POINTERS\n+#  pragma acc enter data present_or_create (h[0:SIZE])\n+# else\n+#  pragma acc enter data present_or_create (h)\n+# endif\n+  d1 = (char *) acc_deviceptr (h);\n+#endif\n+  assert (d1);\n+  assert (!cb_ev_alloc_expected);\n+  assert (cb_ev_alloc_bytes == aligned_size (SIZE));\n+  assert (aligned_address (cb_ev_alloc_device_ptr) == d1);\n+  assert (acc_is_present (h, SIZE));\n+  assert (acc_is_present (&h[2], SIZE - 2));\n+\n+  char *d2;\n+#if OPENACC_RUNTIME\n+  d2 = (char *) acc_present_or_create (&h[2], SIZE - 2);\n+#else\n+# pragma acc enter data present_or_create (h[2:SIZE - 2])\n+  d2 = (char *) acc_deviceptr (&h[2]);\n+#endif\n+  assert (d2);\n+  assert (d1 == d2 - 2);\n+  assert (acc_is_present (h, SIZE));\n+  assert (acc_is_present (&h[2], SIZE - 2));\n+\n+  d2 = (char *) acc_deviceptr (&h[2]);\n+  assert (d1 == d2 - 2);\n+\n+#if OPENACC_RUNTIME\n+  acc_delete (&h[2], SIZE - 2);\n+#else\n+# pragma acc exit data delete (h[2:SIZE - 2])\n+#endif\n+  assert (acc_is_present (h, SIZE));\n+  assert (acc_is_present (&h[2], SIZE - 2));\n+\n+#if 0 //TODO PR92848\n+  cb_ev_free_expected = true;\n+#endif\n+#if OPENACC_RUNTIME\n+  acc_delete (h, SIZE);\n+#else\n+# if POINTERS\n+#  pragma acc exit data delete (h[0:SIZE])\n+# else\n+#  pragma acc exit data delete (h)\n+# endif\n+#endif\n+#if 0 //TODO PR92848\n+  assert (!cb_ev_free_expected);\n+  assert (cb_ev_free_device_ptr == cb_ev_alloc_device_ptr);\n+#endif\n+\n+  assert (!acc_is_present (h, SIZE));\n+  assert (!acc_is_present (&h[2], SIZE - 2));\n+  assert (!acc_is_present (h, 1));\n+\n+# if POINTERS\n+  free (h);\n+#endif\n+\n+  acc_prof_unregister (acc_ev_alloc, cb_ev_alloc, acc_reg);\n+  acc_prof_unregister (acc_ev_free, cb_ev_free, acc_reg);\n+}\n+\n+\n+/* Based on what used to be 'libgomp.oacc-c-c++-common/lib-22.c'.  */\n+\n+static void\n+f_lib_22 (void)\n+{\n+  cb_ev_alloc_expected = false;\n+  cb_ev_free_expected = false;\n+  acc_prof_register (acc_ev_alloc, cb_ev_alloc, acc_reg);\n+  acc_prof_register (acc_ev_free, cb_ev_free, acc_reg);\n+\n+  const int c0 = 0;\n+  const int c1 = 1;\n+\n+#if POINTERS\n+  char *h = (char *) malloc (SIZE);\n+#else\n+  char h[SIZE];\n+#endif\n+\n+  memset (h, c0, SIZE);\n+  void *d;\n+  cb_ev_alloc_expected = true;\n+#if OPENACC_RUNTIME\n+  d = acc_copyin (h, SIZE);\n+#else\n+# if POINTERS\n+#  pragma acc enter data copyin (h[0:SIZE])\n+# else\n+#  pragma acc enter data copyin (h)\n+# endif\n+  d = acc_deviceptr (h);\n+#endif\n+  assert (d);\n+  assert (!cb_ev_alloc_expected);\n+  assert (cb_ev_alloc_bytes == aligned_size (SIZE));\n+  assert (aligned_address (cb_ev_alloc_device_ptr) == d);\n+  /* Overwrite the local memory.  */\n+  memset (h, c1, SIZE);\n+  /* Now 'copyout' not the whole but only a \"subset\" subarray, missing one\n+     SUBSET at the beginning, and half a SUBSET at the end...  */\n+#if 0 //TODO PR92848\n+  cb_ev_free_expected = true;\n+#endif\n+#if OPENACC_RUNTIME\n+  acc_copyout (h + SUBSET, SIZE - SUBSET - SUBSET / 2);\n+#else\n+# pragma acc exit data copyout (h[SUBSET:SIZE - SUBSET - SUBSET / 2])\n+#endif\n+#if 0 //TODO PR92848\n+  /* ..., yet, expect the device memory object to be 'free'd...  */\n+  assert (!cb_ev_free_expected);\n+  assert (cb_ev_free_device_ptr == cb_ev_alloc_device_ptr);\n+#endif\n+  /* ..., and the mapping to be removed...  */\n+  assert (!acc_is_present (h, SIZE));\n+  assert (!acc_is_present (&h[SUBSET], SIZE - SUBSET - SUBSET / 2));\n+  assert (!acc_is_present (h, 1));\n+  /* ..., but the 'copyout'ed device memory to correspond to just the \"subset\"\n+     subarray.  */\n+  for (size_t i = 0; i < SIZE; ++i)\n+    {\n+      if (i < SUBSET)\n+\tassert (h[i] == c1);\n+      else if (i < SIZE - SUBSET / 2)\n+\tassert (h[i] == c0);\n+      else if (i < SIZE)\n+\tassert (h[i] == c1);\n+    }\n+\n+#if POINTERS\n+  free (h);\n+#endif\n+\n+  acc_prof_unregister (acc_ev_alloc, cb_ev_alloc, acc_reg);\n+  acc_prof_unregister (acc_ev_free, cb_ev_free, acc_reg);\n+}\n+\n+\n+/* Based on what used to be 'libgomp.oacc-c-c++-common/lib-30.c'.  */\n+\n+static void\n+f_lib_30 (void)\n+{\n+  cb_ev_alloc_expected = false;\n+  cb_ev_free_expected = false;\n+  acc_prof_register (acc_ev_alloc, cb_ev_alloc, acc_reg);\n+  acc_prof_register (acc_ev_free, cb_ev_free, acc_reg);\n+\n+#if POINTERS\n+  char *h = (char *) malloc (SIZE);\n+#else\n+  char h[SIZE];\n+#endif\n+  memset (h, 0, SIZE);\n+\n+  void *d;\n+  cb_ev_alloc_expected = true;\n+#if OPENACC_RUNTIME\n+  d = acc_create (h, SIZE);\n+#else\n+# if POINTERS\n+#  pragma acc enter data create (h[0:SIZE])\n+# else\n+#  pragma acc enter data create (h)\n+# endif\n+  d = acc_deviceptr (h);\n+#endif\n+  assert (d);\n+  assert (!cb_ev_alloc_expected);\n+  assert (cb_ev_alloc_bytes == aligned_size (SIZE));\n+  assert (aligned_address (cb_ev_alloc_device_ptr) == d);\n+\n+  /* We 'delete' not the whole but only a \"subset\" subarray...  */\n+#if 0 //TODO PR92848\n+  cb_ev_free_expected = true;\n+#endif\n+#if OPENACC_RUNTIME\n+  acc_delete (h, SIZE - SUBSET);\n+#else\n+# pragma acc exit data delete (h[0:SIZE - SUBSET])\n+#endif\n+#if 0 //TODO PR92848\n+  /* ..., yet, expect the device memory object to be 'free'd...  */\n+  assert (!cb_ev_free_expected);\n+  assert (cb_ev_free_device_ptr == cb_ev_alloc_device_ptr);\n+#endif\n+  /* ..., and the mapping to be removed.  */\n+  assert (!acc_is_present (h, SIZE));\n+  assert (!acc_is_present (h, SIZE - SUBSET));\n+  assert (!acc_is_present (h, 1));\n+\n+#if POINTERS\n+  free (h);\n+#endif\n+\n+  acc_prof_unregister (acc_ev_alloc, cb_ev_alloc, acc_reg);\n+  acc_prof_unregister (acc_ev_free, cb_ev_free, acc_reg);\n+}\n+\n+\n+int\n+main ()\n+{\n+  f1 ();\n+  f2 ();\n+  f3 ();\n+  f_lib_22 ();\n+  f_lib_30 ();\n+\n+  return 0;\n+}"}, {"sha": "f4e18fa97a704ab5fa3666ce99d9d238f86d0961", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/subset-subarray-mappings-2.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f36f22f38285fef3b2166a00d4ec446fb96125/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fsubset-subarray-mappings-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f36f22f38285fef3b2166a00d4ec446fb96125/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fsubset-subarray-mappings-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fsubset-subarray-mappings-2.c?ref=41f36f22f38285fef3b2166a00d4ec446fb96125", "patch": "@@ -0,0 +1,115 @@\n+/* Test \"subset\" subarray mappings.  */\n+\n+/* { dg-skip-if \"\" { *-*-* } { \"-DACC_MEM_SHARED=1\" } } */\n+\n+#include <openacc.h>\n+#include <acc_prof.h>\n+#include <stdbool.h>\n+#include <stdint.h>\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+static bool cb_ev_alloc_expected;\n+static size_t cb_ev_alloc_bytes;\n+static const void *cb_ev_alloc_device_ptr;\n+static void\n+cb_ev_alloc (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  assert (cb_ev_alloc_expected);\n+  cb_ev_alloc_expected = false;\n+\n+  cb_ev_alloc_bytes = event_info->data_event.bytes;\n+  cb_ev_alloc_device_ptr = event_info->data_event.device_ptr;\n+}\n+\n+static bool cb_ev_free_expected;\n+static const void *cb_ev_free_device_ptr;\n+static void\n+cb_ev_free (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  assert (cb_ev_free_expected);\n+  cb_ev_free_expected = false;\n+\n+  cb_ev_free_device_ptr = event_info->data_event.device_ptr;\n+}\n+\n+\n+/* Match the alignment processing that\n+   'libgomp/target.c:gomp_map_vars_internal' is doing; simplified, not\n+   considering special alignment requirements of certain data types.  */\n+\n+static size_t\n+aligned_size (size_t tgt_size)\n+{\n+  size_t tgt_align = sizeof (void *);\n+  return tgt_size + tgt_align - 1;\n+}\n+\n+static const void *\n+aligned_address (const void *tgt_start)\n+{\n+  size_t tgt_align = sizeof (void *);\n+  return (void *) (((uintptr_t) tgt_start + tgt_align - 1) & ~(tgt_align - 1));\n+}\n+\n+\n+#define SIZE 1024\n+\n+\n+int\n+main ()\n+{\n+  cb_ev_alloc_expected = false;\n+  cb_ev_free_expected = false;\n+  acc_prof_register (acc_ev_alloc, cb_ev_alloc, acc_reg);\n+  acc_prof_register (acc_ev_free, cb_ev_free, acc_reg);\n+\n+  char *block1 = (char *) malloc (SIZE);\n+  char *block2 = (char *) malloc (SIZE);\n+  char *block3 = (char *) malloc (SIZE);\n+  cb_ev_alloc_expected = true;\n+#pragma acc data create (block1[0:SIZE], block2[0:SIZE], block3[0:SIZE])\n+  {\n+    void *s_block1_d = acc_deviceptr (&block1[1]);\n+    void *s_block2_d = acc_deviceptr (&block2[20]);\n+    void *s_block3_d = acc_deviceptr (&block3[300]);\n+    assert (!cb_ev_alloc_expected);\n+    /* 'block1', 'block2', 'block3' get mapped in one device memory object, in\n+       reverse order.  */\n+    assert (cb_ev_alloc_bytes == aligned_size (3 * SIZE));\n+    assert ((void *) ((uintptr_t) aligned_address (cb_ev_alloc_device_ptr) + 2 * SIZE + 1) == s_block1_d);\n+    assert ((void *) ((uintptr_t) aligned_address (cb_ev_alloc_device_ptr) + 1 * SIZE + 20) == s_block2_d);\n+    assert ((void *) ((uintptr_t) aligned_address (cb_ev_alloc_device_ptr) + 0 * SIZE + 300) == s_block3_d);\n+\n+    void *s_block1_p_d = acc_pcopyin (&block1[1], SIZE - 3);\n+    void *s_block2_p_d = acc_pcopyin (&block2[20], SIZE - 33);\n+    void *s_block3_p_d = acc_pcopyin (&block3[300], SIZE - 333);\n+    assert (s_block1_p_d == s_block1_d);\n+    assert (s_block2_p_d == s_block2_d);\n+    assert (s_block3_p_d == s_block3_d);\n+\n+    acc_delete (block1, SIZE);\n+    acc_delete (block2, SIZE);\n+    acc_delete (block3, SIZE);\n+    assert (acc_is_present (block1, SIZE));\n+    assert (acc_is_present (block2, SIZE));\n+    assert (acc_is_present (block3, SIZE));\n+\n+    cb_ev_free_expected = true;\n+  }\n+  assert (!cb_ev_free_expected);\n+  assert (cb_ev_free_device_ptr == cb_ev_alloc_device_ptr);\n+  assert (!acc_is_present (block1, SIZE));\n+  assert (!acc_is_present (block2, SIZE));\n+  assert (!acc_is_present (block3, SIZE));\n+\n+  free (block1);\n+  free (block2);\n+  free (block3);\n+\n+  acc_prof_unregister (acc_ev_alloc, cb_ev_alloc, acc_reg);\n+  acc_prof_unregister (acc_ev_free, cb_ev_free, acc_reg);\n+\n+  return 0;\n+}"}]}