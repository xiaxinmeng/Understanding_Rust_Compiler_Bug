{"sha": "6812b99bfefb741cadac6c5eba5a7446af820b62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjgxMmI5OWJmZWZiNzQxY2FkYWM2YzVlYmE1YTc0NDZhZjgyMGI2Mg==", "commit": {"author": {"name": "Paul Hilfinger", "email": "hilfinger@adacore.com", "date": "2007-08-14T08:48:27Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:48:27Z"}, "message": "impunit.adb: Re-organize System.Random_Numbers and GNAT.Random_Numbers and add to builds.\n\n2007-08-14  Paul Hilfinger  <hilfinger@adacore.com>\n\n\t* impunit.adb: Re-organize System.Random_Numbers and\n\tGNAT.Random_Numbers and add to builds.\n\n\t* Makefile.rtl: Add s-rannum.ad* and g-rannum.ad*, a-assert*\n\n\t* s-rannum.ads, s-rannum.adb, g-rannum.ads, g-rannum.adb: New files.\n\n\t* a-assert.ads, a-assert.adb: New files.\n\nFrom-SVN: r127454", "tree": {"sha": "190c0fcc941968be691aa7eaf9126fa0bfed8d17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/190c0fcc941968be691aa7eaf9126fa0bfed8d17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6812b99bfefb741cadac6c5eba5a7446af820b62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6812b99bfefb741cadac6c5eba5a7446af820b62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6812b99bfefb741cadac6c5eba5a7446af820b62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6812b99bfefb741cadac6c5eba5a7446af820b62/comments", "author": null, "committer": null, "parents": [{"sha": "f86eb278906f1cf6b948c0a26517f77f76ed1b4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f86eb278906f1cf6b948c0a26517f77f76ed1b4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f86eb278906f1cf6b948c0a26517f77f76ed1b4c"}], "stats": {"total": 1237, "additions": 1235, "deletions": 2}, "files": [{"sha": "900df52c5cf1b5d2f62fa3aefaf6f6ff05540f07", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6812b99bfefb741cadac6c5eba5a7446af820b62/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6812b99bfefb741cadac6c5eba5a7446af820b62/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=6812b99bfefb741cadac6c5eba5a7446af820b62", "patch": "@@ -21,7 +21,7 @@\n # This makefile fragment is included in the ada Makefile (both Unix\n # and NT and VMS versions).\n \n-# It's purpose is to allow the separate maintainence of the list of\n+# Its purpose is to allow the separate maintainence of the list of\n # GNATRTL objects, which frequently changes.\n \n # Objects needed only for tasking\n@@ -76,6 +76,7 @@ GNATRTL_TASKING_OBJS= \\\n \n # Objects needed for non-tasking.\n GNATRTL_NONTASKING_OBJS= \\\n+  a-assert$(objext) \\\n   a-calari$(objext) \\\n   a-caldel$(objext) \\\n   a-calend$(objext) \\\n@@ -158,6 +159,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-ngcefu$(objext) \\\n   a-ngcoty$(objext) \\\n   a-ngelfu$(objext) \\\n+  a-ngrear$(objext) \\\n   a-nlcefu$(objext) \\\n   a-nlcoty$(objext) \\\n   a-nlelfu$(objext) \\\n@@ -303,6 +305,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-zzunio$(objext) \\\n   ada$(objext) \\\n   calendar$(objext) \\\n+  directio$(objext) \\\n   g-allein$(objext) \\\n   g-alleve$(objext) \\\n   g-altcon$(objext) \\\n@@ -350,6 +353,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   g-moreex$(objext) \\\n   g-os_lib$(objext) \\\n   g-pehage$(objext) \\\n+  g-rannum$(objext) \\\n   g-regexp$(objext) \\\n   g-regpat$(objext) \\\n   g-sestin$(objext) \\\n@@ -523,6 +527,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-poosiz$(objext) \\\n   s-powtab$(objext) \\\n   s-purexc$(objext) \\\n+  s-rannum$(objext) \\\n   s-regexp$(objext) \\\n   s-regpat$(objext) \\\n   s-restri$(objext) \\\n@@ -584,5 +589,9 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-wwdcha$(objext) \\\n   s-wwdenu$(objext) \\\n   s-wwdwch$(objext) \\\n+  sequenio$(objext) \\\n   system$(objext) \\\n-  text_io$(objext) $(EXTRA_GNATRTL_NONTASKING_OBJS)\n+  text_io$(objext) \\\n+  unchconv$(objext) \\\n+  unchdeal$(objext) \\\n+  $(EXTRA_GNATRTL_NONTASKING_OBJS)"}, {"sha": "10a3bdf8d6ae0ae317bb7c43c40f758e14b07edf", "filename": "gcc/ada/a-assert.adb", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6812b99bfefb741cadac6c5eba5a7446af820b62/gcc%2Fada%2Fa-assert.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6812b99bfefb741cadac6c5eba5a7446af820b62/gcc%2Fada%2Fa-assert.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-assert.adb?ref=6812b99bfefb741cadac6c5eba5a7446af820b62", "patch": "@@ -0,0 +1,54 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                           A D A . A S S E R T                            --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2007, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body Ada.Assertions is\n+\n+   ------------\n+   -- Assert --\n+   ------------\n+\n+   procedure Assert (Check : Boolean) is\n+   begin\n+      if Check = False then\n+         raise Ada.Assertions.Assertion_Error;\n+      end if;\n+   end Assert;\n+\n+   procedure Assert (Check : Boolean; Message : String) is\n+   begin\n+      if Check = False then\n+         raise Ada.Assertions.Assertion_Error with Message;\n+      end if;\n+   end Assert;\n+\n+end Ada.Assertions;"}, {"sha": "614421b7e4e700d0116a501b1b17b2edf827a324", "filename": "gcc/ada/a-assert.ads", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6812b99bfefb741cadac6c5eba5a7446af820b62/gcc%2Fada%2Fa-assert.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6812b99bfefb741cadac6c5eba5a7446af820b62/gcc%2Fada%2Fa-assert.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-assert.ads?ref=6812b99bfefb741cadac6c5eba5a7446af820b62", "patch": "@@ -0,0 +1,33 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                           A D A . A S S E R T                            --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  We do a with of System.Assertions to get hold of the exception (following\n+--  the specific RM permission that lets' Assertion_Error being a renaming).\n+--  The suppression of Warnings stops the warning about bad categorization.\n+\n+pragma Warnings (Off);\n+with System.Assertions;\n+pragma Warnings (On);\n+\n+package Ada.Assertions is\n+   pragma Pure (Assertions);\n+\n+   Assertion_Error : exception renames System.Assertions.Assert_Failure;\n+\n+   procedure Assert (Check : Boolean);\n+\n+   procedure Assert (Check : Boolean; Message : String);\n+\n+end Ada.Assertions;"}, {"sha": "d038adbbea1b8cbfdaecc8e14640b7215a68f3ef", "filename": "gcc/ada/g-rannum.adb", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6812b99bfefb741cadac6c5eba5a7446af820b62/gcc%2Fada%2Fg-rannum.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6812b99bfefb741cadac6c5eba5a7446af820b62/gcc%2Fada%2Fg-rannum.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-rannum.adb?ref=6812b99bfefb741cadac6c5eba5a7446af820b62", "patch": "@@ -0,0 +1,310 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                  G N A T . R A N D O M _ N U M B E R S                   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2007, Free Software Foundation, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Numerics.Long_Elementary_Functions;\n+use Ada.Numerics.Long_Elementary_Functions;\n+with Ada.Unchecked_Conversion;\n+with System.Random_Numbers; use System.Random_Numbers;\n+\n+package body GNAT.Random_Numbers is\n+\n+   Sys_Max_Image_Width : constant := System.Random_Numbers.Max_Image_Width;\n+\n+   subtype Image_String is String (1 .. Max_Image_Width);\n+\n+   --  Utility function declarations\n+\n+   procedure Insert_Image\n+     (S     : in out Image_String;\n+      Index : Integer;\n+      V     : Integer_64);\n+   --  Insert string representation of V in S starting at position Index\n+\n+   ---------------\n+   -- To_Signed --\n+   ---------------\n+\n+   function To_Signed is\n+     new Ada.Unchecked_Conversion (Unsigned_32, Integer_32);\n+   function To_Signed is\n+     new Ada.Unchecked_Conversion (Unsigned_64, Integer_64);\n+\n+   ------------------\n+   -- Insert_Image --\n+   ------------------\n+\n+   procedure Insert_Image\n+     (S     : in out Image_String;\n+      Index : Integer;\n+      V     : Integer_64)\n+   is\n+      Image : constant String := Integer_64'Image (V);\n+   begin\n+      S (Index .. Index + Image'Length - 1) := Image;\n+   end Insert_Image;\n+\n+   ---------------------\n+   -- Random_Discrete --\n+   ---------------------\n+\n+   function Random_Discrete\n+     (Gen   : Generator;\n+      Min   : Result_Subtype := Default_Min;\n+      Max   : Result_Subtype := Result_Subtype'Last) return Result_Subtype\n+   is\n+      function F is\n+        new System.Random_Numbers.Random_Discrete\n+              (Result_Subtype, Default_Min);\n+   begin\n+      return F (Gen.Rep, Min, Max);\n+   end Random_Discrete;\n+\n+   ------------\n+   -- Random --\n+   ------------\n+\n+   function Random (Gen : Generator) return Float is\n+   begin\n+      return Random (Gen.Rep);\n+   end Random;\n+\n+   function Random (Gen : Generator) return Long_Float is\n+   begin\n+      return Random (Gen.Rep);\n+   end Random;\n+\n+   function Random (Gen : Generator) return Interfaces.Unsigned_32 is\n+   begin\n+      return Random (Gen.Rep);\n+   end Random;\n+\n+   function Random (Gen : Generator) return Interfaces.Unsigned_64 is\n+   begin\n+      return Random (Gen.Rep);\n+   end Random;\n+\n+   function Random (Gen : Generator) return Integer_64 is\n+   begin\n+      return To_Signed (Unsigned_64'(Random (Gen)));\n+   end Random;\n+\n+   function Random (Gen : Generator) return Integer_32 is\n+   begin\n+      return To_Signed (Unsigned_32'(Random (Gen)));\n+   end Random;\n+\n+   function Random (Gen : Generator) return Long_Integer is\n+      function Random_Long_Integer is new Random_Discrete (Long_Integer);\n+   begin\n+      return Random_Long_Integer (Gen);\n+   end Random;\n+\n+   function Random (Gen : Generator) return Integer is\n+      function Random_Integer is new Random_Discrete (Integer);\n+   begin\n+      return Random_Integer (Gen);\n+   end Random;\n+\n+   ------------------\n+   -- Random_Float --\n+   ------------------\n+\n+   function Random_Float (Gen   : Generator) return Result_Subtype is\n+      function F is new System.Random_Numbers.Random_Float (Result_Subtype);\n+   begin\n+      return F (Gen.Rep);\n+   end Random_Float;\n+\n+   ---------------------\n+   -- Random_Gaussian --\n+   ---------------------\n+\n+   --  Generates pairs of normally distributed values using the polar method of\n+   --  G. E. P. Box, M. E. Muller, and G. Marsaglia. See Donald E. Knuth, The\n+   --  Art of Computer Programming, Vol 2: Seminumerical Algorithms, section\n+   --  3.4.1, subsection C, algorithm P. Returns half of the pair on each call,\n+   --  using the Next_Gaussian field of Gen to hold the second member on\n+   --  even-numbered calls.\n+\n+   function Random_Gaussian (Gen : Generator) return Long_Float is\n+      G : Generator renames Gen'Unrestricted_Access.all;\n+\n+      V1, V2, Rad2, Mult : Long_Float;\n+\n+   begin\n+      if G.Have_Gaussian then\n+         G.Have_Gaussian := False;\n+         return G.Next_Gaussian;\n+\n+      else\n+         loop\n+            V1 := 2.0 * Random (G) - 1.0;\n+            V2 := 2.0 * Random (G) - 1.0;\n+            Rad2 := V1 ** 2 + V2 ** 2;\n+            exit when Rad2 < 1.0 and then Rad2 /= 0.0;\n+         end loop;\n+\n+         --  Now V1 and V2 are coordinates in the unit circle\n+\n+         Mult := Sqrt (-2.0 * Log (Rad2) / Rad2);\n+         G.Next_Gaussian := V2 * Mult;\n+         G.Have_Gaussian := True;\n+         return Long_Float'Machine (V1 * Mult);\n+      end if;\n+   end Random_Gaussian;\n+\n+   function Random_Gaussian (Gen : Generator) return Float is\n+      V : constant Long_Float := Random_Gaussian (Gen);\n+   begin\n+      return Float'Machine (Float (V));\n+   end Random_Gaussian;\n+\n+   -----------\n+   -- Reset --\n+   -----------\n+\n+   procedure Reset (Gen : out Generator) is\n+   begin\n+      Reset (Gen.Rep);\n+      Gen.Have_Gaussian := False;\n+   end Reset;\n+\n+   procedure Reset\n+     (Gen       : out Generator;\n+      Initiator : Initialization_Vector)\n+   is\n+   begin\n+      Reset (Gen.Rep, Initiator);\n+      Gen.Have_Gaussian := False;\n+   end Reset;\n+\n+   procedure Reset\n+     (Gen       : out Generator;\n+      Initiator : Interfaces.Integer_32)\n+   is\n+   begin\n+      Reset (Gen.Rep, Initiator);\n+      Gen.Have_Gaussian := False;\n+   end Reset;\n+\n+   procedure Reset\n+     (Gen       : out Generator;\n+      Initiator : Interfaces.Unsigned_32)\n+   is\n+   begin\n+      Reset (Gen.Rep, Initiator);\n+      Gen.Have_Gaussian := False;\n+   end Reset;\n+\n+   procedure Reset\n+     (Gen       : out Generator;\n+      Initiator : Integer)\n+   is\n+   begin\n+      Reset (Gen.Rep, Initiator);\n+      Gen.Have_Gaussian := False;\n+   end Reset;\n+\n+   procedure Reset\n+     (Gen        : out Generator;\n+      From_State : Generator)\n+   is\n+   begin\n+      Reset (Gen.Rep, From_State.Rep);\n+      Gen.Have_Gaussian := From_State.Have_Gaussian;\n+      Gen.Next_Gaussian := From_State.Next_Gaussian;\n+   end Reset;\n+\n+   Frac_Scale : constant Long_Float :=\n+                  Long_Float\n+                    (Long_Float'Machine_Radix) ** Long_Float'Machine_Mantissa;\n+\n+   function Val64 (Image : String) return Integer_64;\n+   --  Renames Integer64'Value\n+   --  We cannot use a 'renames Integer64'Value' since for some strange\n+   --  reason, this requires a dependency on s-auxdec.ads which not all\n+   --  run-times support ???\n+\n+   function Val64 (Image : String) return Integer_64 is\n+   begin\n+      return Integer_64'Value (Image);\n+   end Val64;\n+\n+   procedure Reset\n+     (Gen        : out Generator;\n+      From_Image : String)\n+   is\n+      F0 : constant Integer := From_Image'First;\n+      T0 : constant Integer := From_Image'First + Sys_Max_Image_Width;\n+\n+   begin\n+      Reset (Gen.Rep, From_Image (F0 .. F0 + Sys_Max_Image_Width));\n+\n+      if From_Image (T0 + 1) = '1' then\n+         Gen.Have_Gaussian := True;\n+         Gen.Next_Gaussian :=\n+           Long_Float (Val64 (From_Image (T0 + 3 .. T0 + 23))) / Frac_Scale\n+           * Long_Float (Long_Float'Machine_Radix)\n+           ** Integer (Val64 (From_Image (T0 + 25 .. From_Image'Last)));\n+      else\n+         Gen.Have_Gaussian := False;\n+      end if;\n+   end Reset;\n+\n+   -----------\n+   -- Image --\n+   -----------\n+\n+   function Image (Gen : Generator) return String is\n+      Result : Image_String;\n+\n+   begin\n+      Result := (others => ' ');\n+      Result (1 .. Sys_Max_Image_Width) := Image (Gen.Rep);\n+\n+      if Gen.Have_Gaussian then\n+         Result (Sys_Max_Image_Width + 2) := '1';\n+         Insert_Image (Result, Sys_Max_Image_Width + 4,\n+                       Integer_64 (Long_Float'Fraction (Gen.Next_Gaussian)\n+                                   * Frac_Scale));\n+         Insert_Image (Result, Sys_Max_Image_Width + 24,\n+                       Integer_64 (Long_Float'Exponent (Gen.Next_Gaussian)));\n+\n+      else\n+         Result (Sys_Max_Image_Width + 2) := '0';\n+      end if;\n+\n+      return Result;\n+   end Image;\n+\n+end GNAT.Random_Numbers;"}, {"sha": "441c3ce72582b4265b6d2c337329d9f0fa2c926a", "filename": "gcc/ada/g-rannum.ads", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6812b99bfefb741cadac6c5eba5a7446af820b62/gcc%2Fada%2Fg-rannum.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6812b99bfefb741cadac6c5eba5a7446af820b62/gcc%2Fada%2Fg-rannum.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-rannum.ads?ref=6812b99bfefb741cadac6c5eba5a7446af820b62", "patch": "@@ -0,0 +1,141 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                   G N A T . R A N D O M _ N U M B E R S                  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2007, Free Software Foundation, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Extended pseudo-random number generation\n+\n+--  This package provides a type representing pseudo-random number\n+--  generators, and subprograms to extract various distributions of numbers\n+--  from them. It also provides types for representing initialization values\n+--  and snapshots of internal generator state, which permit reproducible\n+--  pseudo-random streams.\n+\n+--  The generator currently provided by this package has an extremely long\n+--  period (at least 2**19937-1), and passes the Big Crush test suite, with\n+--  the exception of the two linear complexity tests. Therefore, it is\n+--  suitable for simulations, but should not be used as a cryptographic\n+--  pseudo-random source without additional processing.\n+\n+--  The design of this package effects some simplification from that of\n+--  the standard Ada.Numerics packages. There is no separate State type;\n+--  the Generator type itself suffices for this purpose. The parameter\n+--  modes on Reset procedures better reflect the effect of these routines.\n+\n+with System.Random_Numbers;\n+with Interfaces; use Interfaces;\n+\n+package GNAT.Random_Numbers is\n+\n+   type Generator is limited private;\n+   subtype Initialization_Vector is\n+     System.Random_Numbers.Initialization_Vector;\n+\n+   function Random (Gen : Generator) return Float;\n+   function Random (Gen : Generator) return Long_Float;\n+   --  Return pseudo-random numbers uniformly distributed on [0 .. 1)\n+\n+   function Random (Gen : Generator) return Interfaces.Integer_32;\n+   function Random (Gen : Generator) return Interfaces.Unsigned_32;\n+   function Random (Gen : Generator) return Interfaces.Integer_64;\n+   function Random (Gen : Generator) return Interfaces.Unsigned_64;\n+   function Random (Gen : Generator) return Integer;\n+   function Random (Gen : Generator) return Long_Integer;\n+   --  Return pseudo-random numbers uniformly distributed on T'First .. T'Last\n+   --  for various builtin integer types.\n+\n+   generic\n+      type Result_Subtype is (<>);\n+      Default_Min : Result_Subtype := Result_Subtype'Val (0);\n+   function Random_Discrete\n+     (Gen   : Generator;\n+      Min   : Result_Subtype := Default_Min;\n+      Max   : Result_Subtype := Result_Subtype'Last) return Result_Subtype;\n+   --  Returns pseudo-random numbers uniformly distributed on Min .. Max\n+\n+   generic\n+      type Result_Subtype is digits <>;\n+   function Random_Float (Gen   : Generator) return Result_Subtype;\n+   --  Returns pseudo-random numbers uniformly distributed on [0 .. 1)\n+\n+   function Random_Gaussian (Gen : Generator) return Long_Float;\n+   function Random_Gaussian (Gen : Generator) return Float;\n+   --  Returns pseudo-random numbers normally distributed value with mean 0\n+   --  and standard deviation 1.0.\n+\n+   procedure Reset (Gen : out Generator);\n+   --  Re-initialize the state of Gen from the time of day\n+\n+   procedure Reset\n+     (Gen       : out Generator;\n+      Initiator : Initialization_Vector);\n+   procedure Reset\n+     (Gen       : out Generator;\n+      Initiator : Interfaces.Integer_32);\n+   procedure Reset\n+     (Gen       : out Generator;\n+      Initiator : Interfaces.Unsigned_32);\n+   procedure Reset\n+     (Gen       : out Generator;\n+      Initiator : Integer);\n+   --  Re-initialize Gen based on the Initiator in various ways. Identical\n+   --  values of Initiator cause identical sequences of values.\n+\n+   procedure Reset (Gen : out Generator; From_State : Generator);\n+   --  Causes the state of Gen to be identical to that of From_State; Gen\n+   --  and From_State will produce identical sequences of values subsequently.\n+\n+   procedure Reset (Gen : out Generator; From_Image : String);\n+   function Image (Gen : Generator) return String;\n+   --  The call\n+   --     Reset (Gen2, Image (Gen1))\n+   --  has the same effect as Reset (Gen2, Gen1);\n+\n+   Max_Image_Width : constant :=\n+     System.Random_Numbers.Max_Image_Width + 2 + 20 + 5;\n+   --  Maximum possible length of result of Image (...)\n+\n+private\n+\n+   type Generator is limited record\n+      Rep : System.Random_Numbers.Generator;\n+\n+      Have_Gaussian : Boolean;\n+      --  The algorithm used for Random_Gaussian produces deviates in\n+      --  pairs. Have_Gaussian is true iff Random_Gaussian has returned one\n+      --  member of the pair and Next_Gaussian contains the other.\n+\n+      Next_Gaussian : Long_Float;\n+      --  Next random deviate to be produced by Random_Gaussian, if\n+      --  Have_Gaussian.\n+   end record;\n+\n+end GNAT.Random_Numbers;"}, {"sha": "ee539a2a50e00ba601eb8149744b04e19e938d6a", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6812b99bfefb741cadac6c5eba5a7446af820b62/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6812b99bfefb741cadac6c5eba5a7446af820b62/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=6812b99bfefb741cadac6c5eba5a7446af820b62", "patch": "@@ -247,6 +247,7 @@ package body Impunit is\n      \"g-moreex\",    -- GNAT.Most_Recent_Exception\n      \"g-os_lib\",    -- GNAT.Os_Lib\n      \"g-pehage\",    -- GNAT.Perfect_Hash_Generators\n+     \"g-rannum\",    -- GNAT.Random_Numbers\n      \"g-regexp\",    -- GNAT.Regexp\n      \"g-regist\",    -- GNAT.Registry\n      \"g-regpat\",    -- GNAT.Regpat\n@@ -333,6 +334,7 @@ package body Impunit is\n    -- Ada Hierarchy Units from Ada 2005 Reference Manual --\n    --------------------------------------------------------\n \n+     \"a-assert\",    -- Ada.Assertions\n      \"a-calari\",    -- Ada.Calendar.Arithmetic\n      \"a-calfor\",    -- Ada.Calendar.Formatting\n      \"a-catizo\",    -- Ada.Calendar.Time_Zones"}, {"sha": "797f8200ec1044ae9afb7285081b289ab29410bd", "filename": "gcc/ada/s-rannum.adb", "status": "added", "additions": 536, "deletions": 0, "changes": 536, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6812b99bfefb741cadac6c5eba5a7446af820b62/gcc%2Fada%2Fs-rannum.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6812b99bfefb741cadac6c5eba5a7446af820b62/gcc%2Fada%2Fs-rannum.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-rannum.adb?ref=6812b99bfefb741cadac6c5eba5a7446af820b62", "patch": "@@ -0,0 +1,536 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                S Y S T E M . R A N D O M _ N U M B E R S                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2007, Free Software Foundation, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+------------------------------------------------------------------------------\n+--                                                                          --\n+-- The implementation here is derived from a C-program for MT19937, with    --\n+-- initialization improved 2002/1/26. As required, the following notice is  --\n+-- copied from the original program.                                        --\n+--                                                                          --\n+-- Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,        --\n+-- All rights reserved.                                                     --\n+--                                                                          --\n+-- Redistribution and use in source and binary forms, with or without       --\n+-- modification, are permitted provided that the following conditions       --\n+-- are met:                                                                 --\n+--                                                                          --\n+--   1. Redistributions of source code must retain the above copyright      --\n+--      notice, this list of conditions and the following disclaimer.       --\n+--                                                                          --\n+--   2. Redistributions in binary form must reproduce the above copyright   --\n+--      notice, this list of conditions and the following disclaimer in the --\n+--      documentation and/or other materials provided with the distribution.--\n+--                                                                          --\n+--   3. The names of its contributors may not be used to endorse or promote --\n+--      products derived from this software without specific prior written  --\n+--      permission.                                                         --\n+--                                                                          --\n+-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS      --\n+-- \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT        --\n+-- LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    --\n+-- A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT    --\n+-- OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    --\n+-- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED --\n+-- TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR   --\n+-- PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF   --\n+-- LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING     --\n+-- NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS       --\n+-- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.             --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+------------------------------------------------------------------------------\n+--                                                                          --\n+-- This is an implementation of the Mersenne Twister, twisted generalized   --\n+-- feedback shift register of rational normal form, with state-bit          --\n+-- reflection and tempering. This version generates 32-bit integers with a  --\n+-- period of 2**19937 - 1 (a Mersenne prime, hence the name). For           --\n+-- applications requiring more than 32 bits (up to 64), we concatenate two  --\n+-- 32-bit numbers.                                                          --\n+--                                                                          --\n+-- See http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html for         --\n+-- details.                                                                 --\n+--                                                                          --\n+-- In contrast to the original code, we do not generate random numbers in   --\n+-- batches of N. Measurement seems to show this has very little if any      --\n+-- effect on performance, and it may be marginally better for real-time     --\n+-- applications with hard deadlines.                                        --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Calendar;              use Ada.Calendar;\n+with Ada.Unchecked_Conversion;\n+with Interfaces;                use Interfaces;\n+\n+use Ada;\n+\n+package body System.Random_Numbers is\n+\n+   -------------------------\n+   -- Implementation Note --\n+   -------------------------\n+\n+   --  The design of this spec is very awkward, as a result of Ada 95 not\n+   --  permitting in-out parameters for function formals (most naturally,\n+   --  Generator values would be passed this way). In pure Ada 95, the only\n+   --  solution is to use the heap and pointers, and, to avoid memory leaks,\n+   --  controlled types.\n+\n+   --  This is awfully heavy, so what we do is to use Unrestricted_Access to\n+   --  get a pointer to the state in the passed Generator. This works because\n+   --  Generator is a limited type and will thus always be passed by reference.\n+\n+   Low31_Mask : constant := 2**31-1;\n+   Bit31_Mask : constant := 2**31;\n+\n+   Matrix_A_X : constant array (State_Val range 0 .. 1) of State_Val :=\n+                  (0, 16#9908b0df#);\n+\n+   Y2K : constant Calendar.Time :=\n+           Calendar.Time_Of\n+             (Year => 2000, Month => 1, Day => 1, Seconds => 0.0);\n+   --  First Year 2000 day\n+\n+   subtype Image_String is String (1 .. Max_Image_Width);\n+\n+   --  Utility functions\n+\n+   procedure Init (Gen : out Generator; Initiator : Unsigned_32);\n+   --  Perform a default initialization of the state of Gen. The resulting\n+   --  state is identical for identical values of Initiator.\n+\n+   procedure Insert_Image\n+     (S     : in out Image_String;\n+      Index : Integer;\n+      V     : State_Val);\n+   --  Insert image of V into S, in the Index'th 11-character substring\n+\n+   function Extract_Value (S : String; Index : Integer) return State_Val;\n+   --  Treat S as a sequence of 11-character decimal numerals and return\n+   --  the result of converting numeral #Index (numbering from 0)\n+\n+   function To_Unsigned is\n+     new Unchecked_Conversion (Integer_32, Unsigned_32);\n+   function To_Unsigned is\n+     new Unchecked_Conversion (Integer_64, Unsigned_64);\n+\n+   ------------\n+   -- Random --\n+   ------------\n+\n+   function Random (Gen : Generator) return Unsigned_32 is\n+      G : Generator renames Gen'Unrestricted_Access.all;\n+      Y : State_Val;\n+      I : Integer;\n+\n+   begin\n+      I := G.I;\n+\n+      if I < N - M then\n+         Y := (G.S (I) and Bit31_Mask) or (G.S (I + 1) and Low31_Mask);\n+         Y := G.S (I + M) xor Shift_Right (Y, 1) xor Matrix_A_X (Y and 1);\n+         I := I + 1;\n+\n+      elsif I < N - 1 then\n+         Y := (G.S (I) and Bit31_Mask) or (G.S (I + 1) and Low31_Mask);\n+         Y := G.S (I + (M - N))\n+                xor Shift_Right (Y, 1)\n+                xor Matrix_A_X (Y and 1);\n+         I := I + 1;\n+\n+      elsif I = N - 1 then\n+         Y := (G.S (I) and Bit31_Mask) or (G.S (0) and Low31_Mask);\n+         Y := G.S (M - 1) xor Shift_Right (Y, 1) xor Matrix_A_X (Y and 1);\n+         I := 0;\n+\n+      else\n+         Init (G, 5489);\n+         return Random (Gen);\n+      end if;\n+\n+      G.S (G.I) := Y;\n+      G.I := I;\n+\n+      Y := Y xor Shift_Right (Y, 11);\n+      Y := Y xor (Shift_Left (Y, 7)  and 16#9d2c5680#);\n+      Y := Y xor (Shift_Left (Y, 15) and 16#efc60000#);\n+      Y := Y xor Shift_Right (Y, 18);\n+\n+      return Y;\n+   end Random;\n+\n+   function Random (Gen : Generator) return Float is\n+\n+      --  Note: The application of Float'Machine (...) is necessary to avoid\n+      --  returning extra significand bits. Without it, the function's value\n+      --  will change if it is spilled, for example, causing\n+      --  gratuitous nondeterminism.\n+\n+      Result : constant Float :=\n+                 Float'Machine\n+                   (Float (Unsigned_32'(Random (Gen))) * 2.0 ** (-32));\n+   begin\n+      if Result < 1.0 then\n+         return Result;\n+      else\n+         return Float'Adjacent (1.0, 0.0);\n+      end if;\n+   end Random;\n+\n+   function Random (Gen : Generator) return Long_Float is\n+      Result : constant Long_Float :=\n+                 Long_Float'Machine ((Long_Float (Unsigned_32'(Random (Gen)))\n+                   * 2.0 ** (-32))\n+                   + (Long_Float (Unsigned_32'(Random (Gen))) * 2.0 ** (-64)));\n+   begin\n+      if Result < 1.0 then\n+         return Result;\n+      else\n+         return Long_Float'Adjacent (1.0, 0.0);\n+      end if;\n+   end Random;\n+\n+   function Random (Gen : Generator) return Unsigned_64 is\n+   begin\n+      return Shift_Left (Unsigned_64 (Unsigned_32'(Random (Gen))), 32)\n+        or Unsigned_64 (Unsigned_32'(Random (Gen)));\n+   end Random;\n+\n+   ---------------------\n+   -- Random_Discrete --\n+   ---------------------\n+\n+   function Random_Discrete\n+     (Gen : Generator;\n+      Min : Result_Subtype := Default_Min;\n+      Max : Result_Subtype := Result_Subtype'Last) return Result_Subtype\n+   is\n+   begin\n+      if Max = Min then\n+         return Max;\n+\n+      elsif Max < Min then\n+         raise Constraint_Error;\n+\n+      elsif Result_Subtype'Base'Size > 32 then\n+         declare\n+            --  In the 64-bit case, we have to be careful, since not all 64-bit\n+            --  unsigned values are representable in GNAT's root_integer type.\n+            --  Ignore different-size warnings here; since GNAT's handling\n+            --  is correct.\n+\n+            pragma Warnings (\"Z\");\n+            function Conv_To_Unsigned is\n+               new Unchecked_Conversion (Result_Subtype'Base, Unsigned_64);\n+            function Conv_To_Result is\n+               new Unchecked_Conversion (Unsigned_64, Result_Subtype'Base);\n+            pragma Warnings (\"z\");\n+\n+            N : constant Unsigned_64 :=\n+                  Conv_To_Unsigned (Max) - Conv_To_Unsigned (Min) + 1;\n+\n+            X, Slop : Unsigned_64;\n+\n+         begin\n+            if N = 0 then\n+               return Conv_To_Result (Conv_To_Unsigned (Min) + Random (Gen));\n+\n+            else\n+               Slop := Unsigned_64'Last rem N + 1;\n+\n+               loop\n+                  X := Random (Gen);\n+                  exit when Slop = N or else X <= Unsigned_64'Last - Slop;\n+               end loop;\n+\n+               return Conv_To_Result (Conv_To_Unsigned (Min) + X rem N);\n+            end if;\n+         end;\n+\n+      elsif Result_Subtype'Pos (Max) - Result_Subtype'Pos (Min) =\n+                                                         2 ** 32 - 1\n+      then\n+         return Result_Subtype'Val\n+           (Result_Subtype'Pos (Min) + Unsigned_32'Pos (Random (Gen)));\n+      else\n+         declare\n+            N    : constant Unsigned_32 :=\n+                     Unsigned_32 (Result_Subtype'Pos (Max) -\n+                                    Result_Subtype'Pos (Min) + 1);\n+            Slop : constant Unsigned_32 := Unsigned_32'Last rem N + 1;\n+            X    : Unsigned_32;\n+\n+         begin\n+            loop\n+               X := Random (Gen);\n+               exit when Slop = N or else X <= Unsigned_32'Last - Slop;\n+            end loop;\n+\n+            return\n+              Result_Subtype'Val\n+                (Result_Subtype'Pos (Min) + Unsigned_32'Pos (X rem N));\n+         end;\n+      end if;\n+   end Random_Discrete;\n+\n+   ------------------\n+   -- Random_Float --\n+   ------------------\n+\n+   function Random_Float (Gen : Generator) return Result_Subtype is\n+   begin\n+      if Result_Subtype'Base'Digits > Float'Digits then\n+         return Result_Subtype'Machine (Result_Subtype\n+                                         (Long_Float'(Random (Gen))));\n+      else\n+         return Result_Subtype'Machine (Result_Subtype\n+                                         (Float'(Random (Gen))));\n+      end if;\n+   end Random_Float;\n+\n+   -----------\n+   -- Reset --\n+   -----------\n+\n+   procedure Reset (Gen : out Generator) is\n+      X : constant Unsigned_32 := Unsigned_32 ((Calendar.Clock - Y2K) * 64.0);\n+   begin\n+      Init (Gen, X);\n+   end Reset;\n+\n+   procedure Reset (Gen : out Generator; Initiator : Integer_32) is\n+   begin\n+      Init (Gen, To_Unsigned (Initiator));\n+   end Reset;\n+\n+   procedure Reset (Gen : out Generator; Initiator : Unsigned_32) is\n+   begin\n+      Init (Gen, Initiator);\n+   end Reset;\n+\n+   procedure Reset (Gen : out Generator; Initiator : Integer) is\n+   begin\n+      pragma Warnings (\"C\");\n+      --  This is probably an unnecessary precaution against future change, but\n+      --  since the test is a static expression, no extra code is involved.\n+\n+      if Integer'Size <= 32 then\n+         Init (Gen, To_Unsigned (Integer_32 (Initiator)));\n+\n+      else\n+         declare\n+            Initiator1 : constant Unsigned_64 :=\n+                           To_Unsigned (Integer_64 (Initiator));\n+            Init0      : constant Unsigned_32 :=\n+                           Unsigned_32 (Initiator1 mod 2 ** 32);\n+            Init1      : constant Unsigned_32 :=\n+                           Unsigned_32 (Shift_Right (Initiator1, 32));\n+         begin\n+            Reset (Gen, Initialization_Vector'(Init0, Init1));\n+         end;\n+      end if;\n+\n+      pragma Warnings (\"c\");\n+   end Reset;\n+\n+   procedure Reset (Gen : out Generator; Initiator : Initialization_Vector) is\n+      I, J : Integer;\n+\n+   begin\n+      Init (Gen, 19650218);\n+      I := 1;\n+      J := 0;\n+\n+      if Initiator'Length > 0 then\n+         for K in reverse 1 .. Integer'Max (N, Initiator'Length) loop\n+            Gen.S (I) :=\n+              (Gen.S (I)\n+                 xor ((Gen.S (I - 1) xor Shift_Right (Gen.S (I - 1), 30))\n+                                                                 * 1664525))\n+              + Initiator (J + Initiator'First) + Unsigned_32 (J);\n+\n+            I := I + 1;\n+            J := J + 1;\n+\n+            if I >= N then\n+               Gen.S (0) := Gen.S (N - 1);\n+               I := 1;\n+            end if;\n+\n+            if J >= Initiator'Length then\n+               J := 0;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      for K in reverse 1 .. N - 1 loop\n+         Gen.S (I) :=\n+           (Gen.S (I) xor ((Gen.S (I - 1)\n+                            xor Shift_Right (Gen.S (I - 1), 30)) * 1566083941))\n+           - Unsigned_32 (I);\n+         I := I + 1;\n+\n+         if I >= N then\n+            Gen.S (0) := Gen.S (N - 1);\n+            I := 1;\n+         end if;\n+      end loop;\n+\n+      Gen.S (0) := Bit31_Mask;\n+   end Reset;\n+\n+   procedure Reset (Gen : out Generator; From_State : Generator) is\n+   begin\n+      Gen.S := From_State.S;\n+      Gen.I := From_State.I;\n+   end Reset;\n+\n+   procedure Reset (Gen : out Generator; From_State : State) is\n+   begin\n+      Gen.I := 0;\n+      Gen.S := From_State;\n+   end Reset;\n+\n+   procedure Reset (Gen : out Generator; From_Image : String) is\n+   begin\n+      Gen.I := 0;\n+\n+      for J in 0 .. N - 1 loop\n+         Gen.S (J) := Extract_Value (From_Image, J);\n+      end loop;\n+   end Reset;\n+\n+   ----------\n+   -- Save --\n+   ----------\n+\n+   procedure Save (Gen : Generator; To_State : out State) is\n+      Gen2 : Generator;\n+\n+   begin\n+      if Gen.I = N then\n+         Init (Gen2, 5489);\n+         To_State := Gen2.S;\n+\n+      else\n+         To_State (0 .. N - 1 - Gen.I) := Gen.S (Gen.I .. N - 1);\n+         To_State (N - Gen.I .. N - 1) := Gen.S (0 .. Gen.I - 1);\n+      end if;\n+   end Save;\n+\n+   -----------\n+   -- Image --\n+   -----------\n+\n+   function Image (Of_State : State) return String is\n+      Result : Image_String;\n+\n+   begin\n+      Result := (others => ' ');\n+\n+      for J in Of_State'Range loop\n+         Insert_Image (Result, J, Of_State (J));\n+      end loop;\n+\n+      return Result;\n+   end Image;\n+\n+   function Image (Gen : Generator) return String is\n+      Result : Image_String;\n+\n+   begin\n+      Result := (others => ' ');\n+\n+      for J in 0 .. N - 1 loop\n+         Insert_Image (Result, J, Gen.S ((J + Gen.I) mod N));\n+      end loop;\n+\n+      return Result;\n+   end Image;\n+\n+   -----------\n+   -- Value --\n+   -----------\n+\n+   function Value (Coded_State : String) return State is\n+      Gen : Generator;\n+      S   : State;\n+   begin\n+      Reset (Gen, Coded_State);\n+      Save (Gen, S);\n+      return S;\n+   end Value;\n+\n+   ----------\n+   -- Init --\n+   ----------\n+\n+   procedure Init (Gen : out Generator; Initiator : Unsigned_32) is\n+   begin\n+      Gen.S (0) := Initiator;\n+\n+      for I in 1 .. N - 1 loop\n+         Gen.S (I) :=\n+           1812433253\n+             * (Gen.S (I - 1) xor Shift_Right (Gen.S (I - 1), 30))\n+           + Unsigned_32 (I);\n+      end loop;\n+\n+      Gen.I := 0;\n+   end Init;\n+\n+   ------------------\n+   -- Insert_Image --\n+   ------------------\n+\n+   procedure Insert_Image\n+     (S     : in out Image_String;\n+      Index : Integer;\n+      V     : State_Val)\n+   is\n+      Value : constant String := State_Val'Image (V);\n+   begin\n+      S (Index * 11 + 1 .. Index * 11 + Value'Length) := Value;\n+   end Insert_Image;\n+\n+   -------------------\n+   -- Extract_Value --\n+   -------------------\n+\n+   function Extract_Value (S : String; Index : Integer) return State_Val is\n+   begin\n+      return State_Val'Value (S (S'First + Index * 11 ..\n+                                 S'First + Index * 11 + 11));\n+   end Extract_Value;\n+\n+end System.Random_Numbers;"}, {"sha": "28e2c9e8663eb2f7aedbf4c3a00f16385882c8e0", "filename": "gcc/ada/s-rannum.ads", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6812b99bfefb741cadac6c5eba5a7446af820b62/gcc%2Fada%2Fs-rannum.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6812b99bfefb741cadac6c5eba5a7446af820b62/gcc%2Fada%2Fs-rannum.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-rannum.ads?ref=6812b99bfefb741cadac6c5eba5a7446af820b62", "patch": "@@ -0,0 +1,148 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                S Y S T E M . R A N D O M _ N U M B E R S                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2007, Free Software Foundation, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Extended pseudo-random number generation\n+\n+--  This package provides a type representing pseudo-random number generators,\n+--  and subprograms to extract various uniform distributions of numbers\n+--  from them. It also provides types for representing initialization values\n+--  and snapshots of internal generator state, which permit reproducible\n+--  pseudo-random streams.\n+\n+--  The generator currently provided by this package has an extremely long\n+--  period (at least 2**19937-1), and passes the Big Crush test suite, with the\n+--  exception of the two linear complexity tests. Therefore, it is suitable\n+--  for simulations, but should not be used as a cryptographic pseudo-random\n+--  source without additional processing.\n+\n+--  Note: this package is in the System hierarchy so that it can be directly\n+--  used by other predefined packages. User access to this package is via\n+--  the package GNAT.Random_Numbers (file g-rannum.ads), which also extends\n+--  its capabilities. The interfaces are different so as to include in\n+--  System.Random_Numbers only the definitions necessary to implement the\n+--  standard random-number packages Ada.Numerics.Float_Random and\n+--  Ada.Numerics.Discrete_Random.\n+\n+with Interfaces;\n+\n+package System.Random_Numbers is\n+\n+   type Generator is limited private;\n+   type State is private;\n+   --  A non-limited version of a Generator's internal state\n+\n+   function Random (Gen : Generator) return Float;\n+   function Random (Gen : Generator) return Long_Float;\n+   --  Return pseudo-random numbers uniformly distributed on [0 .. 1)\n+\n+   function Random (Gen : Generator) return Interfaces.Unsigned_32;\n+   function Random (Gen : Generator) return Interfaces.Unsigned_64;\n+   --  Return pseudo-random numbers uniformly distributed on T'First .. T'Last\n+   --  for builtin integer types.\n+\n+   generic\n+      type Result_Subtype is (<>);\n+      Default_Min : Result_Subtype := Result_Subtype'Val (0);\n+   function Random_Discrete\n+     (Gen : Generator;\n+      Min : Result_Subtype := Default_Min;\n+      Max : Result_Subtype := Result_Subtype'Last) return Result_Subtype;\n+   --  Returns pseudo-random numbers uniformly distributed on Min .. Max\n+\n+   generic\n+      type Result_Subtype is digits <>;\n+   function Random_Float (Gen : Generator) return Result_Subtype;\n+   --  Returns pseudo-random numbers uniformly distributed on [0 .. 1)\n+\n+   type Initialization_Vector is\n+     array (Integer range <>) of Interfaces.Unsigned_32;\n+   --  Provides the most general initialization values for a generator (used\n+   --  in Reset).  In general, there is little point in providing more than\n+   --  a certain number of values (currently 624).\n+\n+   procedure Reset (Gen : out Generator);\n+   --  Re-initialize the state of Gen from the time of day\n+\n+   procedure Reset (Gen : out Generator; Initiator : Initialization_Vector);\n+   procedure Reset (Gen : out Generator; Initiator : Interfaces.Integer_32);\n+   procedure Reset (Gen : out Generator; Initiator : Interfaces.Unsigned_32);\n+   procedure Reset (Gen : out Generator; Initiator : Integer);\n+   --  Re-initialize Gen based on the Initiator in various ways. Identical\n+   --  values of Initiator cause identical sequences of values.\n+\n+   procedure Reset (Gen : out Generator; From_State : Generator);\n+   --  Causes the state of Gen to be identical to that of From_State; Gen\n+   --  and From_State will produce identical sequences of values subsequently.\n+\n+   procedure Reset (Gen : out Generator; From_State : State);\n+   procedure Save  (Gen : Generator; To_State : out State);\n+   --  The sequence\n+   --     Save (Gen2, S); Reset (Gen1, S)\n+   --  has the same effect as Reset (Gen2, Gen1).\n+\n+   procedure Reset (Gen : out Generator; From_Image : String);\n+   function Image (Gen : Generator) return String;\n+   --  The call\n+   --     Reset (Gen2, Image (Gen1))\n+   --  has the same effect as Reset (Gen2, Gen1);\n+\n+   Max_Image_Width : constant := 11 * 624;\n+   --  Maximum possible length of result of Image (...)\n+\n+   function Image (Of_State : State) return String;\n+   --  A String representation of Of_State. Identical to the result of\n+   --  Image (Gen), if Of_State has been set with Save (Gen, Of_State).\n+\n+   function Value (Coded_State : String) return State;\n+   --  Inverse of Image on States\n+\n+private\n+\n+   N : constant := 624;\n+   --  The number of 32-bit integers in the shift register\n+\n+   M : constant := 397;\n+   --  Feedback distance from the current position\n+\n+   subtype State_Val is Interfaces.Unsigned_32;\n+   type State is array (0 .. N - 1) of State_Val;\n+\n+   type Generator is limited record\n+      S : State := (others => 0);\n+      --  The shift register, a circular buffer\n+\n+      I : Integer := N;\n+      --  Current starting position in shift register S\n+   end record;\n+\n+end System.Random_Numbers;"}]}