{"sha": "15cb981aa34233d3842213b60d6081b807a4bc98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVjYjk4MWFhMzQyMzNkMzg0MjIxM2I2MGQ2MDgxYjgwN2E0YmM5OA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2009-06-12T05:46:46Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2009-06-12T05:46:46Z"}, "message": "alpha.c (alpha_expand_prologue): Add a REF_CFA_REGISTER note when storing the frame pointer in a register.\n\n        * alpha.c (alpha_expand_prologue): Add a REF_CFA_REGISTER\n        note when storing the frame pointer in a register.\n        (FRP): Don't redefine to nothing for epilogue.\n        (alpha_expand_epilogue): Mark register and sp restores.\n        (unicosmk_gen_dsib): Don't mark weird frame pointer adjust.\n\nFrom-SVN: r148414", "tree": {"sha": "c23cd5a8cd3d35dd085c92c3f20e4d17c56d4bf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c23cd5a8cd3d35dd085c92c3f20e4d17c56d4bf6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15cb981aa34233d3842213b60d6081b807a4bc98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15cb981aa34233d3842213b60d6081b807a4bc98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15cb981aa34233d3842213b60d6081b807a4bc98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15cb981aa34233d3842213b60d6081b807a4bc98/comments", "author": null, "committer": null, "parents": [{"sha": "7c1db202df5854c842f03ae423cd56431d35a43d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c1db202df5854c842f03ae423cd56431d35a43d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c1db202df5854c842f03ae423cd56431d35a43d"}], "stats": {"total": 112, "additions": 68, "deletions": 44}, "files": [{"sha": "db12670498ec24d4404fc825597d60c35c83ec50", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15cb981aa34233d3842213b60d6081b807a4bc98/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15cb981aa34233d3842213b60d6081b807a4bc98/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15cb981aa34233d3842213b60d6081b807a4bc98", "patch": "@@ -1,5 +1,11 @@\n 2009-06-11  Richard Henderson  <rth@redhat.com>\n \n+        * alpha.c (alpha_expand_prologue): Add a REF_CFA_REGISTER\n+\tnote when storing the frame pointer in a register.\n+\t(FRP): Don't redefine to nothing for epilogue.\n+\t(alpha_expand_epilogue): Mark register and sp restores.\n+\t(unicosmk_gen_dsib): Don't mark weird frame pointer adjust.\n+\n \t* config/alpha/alpha.c (alpha_emit_setcc): Fix test for\n \twhen gen_lowpart is needed.\n "}, {"sha": "635450276f745c7f7fff73989db94013e7fb1150", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 62, "deletions": 44, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15cb981aa34233d3842213b60d6081b807a4bc98/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15cb981aa34233d3842213b60d6081b807a4bc98/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=15cb981aa34233d3842213b60d6081b807a4bc98", "patch": "@@ -7727,11 +7727,14 @@ alpha_expand_prologue (void)\n \n   if (TARGET_ABI_OPEN_VMS)\n     {\n+      /* Register frame procedures save the fp.  */\n       if (alpha_procedure_type == PT_REGISTER)\n-\t/* Register frame procedures save the fp.\n-\t   ?? Ought to have a dwarf2 save for this.  */\n-\temit_move_insn (gen_rtx_REG (DImode, vms_save_fp_regno),\n-\t\t\thard_frame_pointer_rtx);\n+\t{\n+\t  rtx insn = emit_move_insn (gen_rtx_REG (DImode, vms_save_fp_regno),\n+\t\t\t\t     hard_frame_pointer_rtx);\n+\t  add_reg_note (insn, REG_CFA_REGISTER, NULL);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n \n       if (alpha_procedure_type != PT_NULL && vms_base_regno != REG_PV)\n \temit_insn (gen_force_movdi (gen_rtx_REG (DImode, vms_base_regno),\n@@ -8006,12 +8009,6 @@ alpha_output_function_end_prologue (FILE *file)\n \n /* Write function epilogue.  */\n \n-/* ??? At some point we will want to support full unwind, and so will\n-   need to mark the epilogue as well.  At the moment, we just confuse\n-   dwarf2out.  */\n-#undef FRP\n-#define FRP(exp) exp\n-\n void\n alpha_expand_epilogue (void)\n {\n@@ -8026,8 +8023,9 @@ alpha_expand_epilogue (void)\n   HOST_WIDE_INT reg_offset;\n   int fp_is_frame_pointer, fp_offset;\n   rtx sa_reg, sa_reg_exp = NULL;\n-  rtx sp_adj1, sp_adj2, mem;\n+  rtx sp_adj1, sp_adj2, mem, reg, insn;\n   rtx eh_ofs;\n+  rtx cfa_restores = NULL_RTX;\n   int i;\n \n   sa_size = alpha_sa_size ();\n@@ -8078,7 +8076,7 @@ alpha_expand_epilogue (void)\n       if ((TARGET_ABI_OPEN_VMS\n \t   && vms_unwind_regno == HARD_FRAME_POINTER_REGNUM)\n \t  || (!TARGET_ABI_OPEN_VMS && frame_pointer_needed))\n-\tFRP (emit_move_insn (stack_pointer_rtx, hard_frame_pointer_rtx));\n+\temit_move_insn (stack_pointer_rtx, hard_frame_pointer_rtx);\n \n       /* Cope with very large offsets to the register save area.  */\n       if (reg_offset + sa_size > 0x8000)\n@@ -8094,15 +8092,17 @@ alpha_expand_epilogue (void)\n \t  sa_reg = gen_rtx_REG (DImode, 22);\n \t  sa_reg_exp = plus_constant (stack_pointer_rtx, bias);\n \n-\t  FRP (emit_move_insn (sa_reg, sa_reg_exp));\n+\t  emit_move_insn (sa_reg, sa_reg_exp);\n \t}\n \n       /* Restore registers in order, excepting a true frame pointer.  */\n \n       mem = gen_rtx_MEM (DImode, plus_constant (sa_reg, reg_offset));\n       if (! eh_ofs)\n         set_mem_alias_set (mem, alpha_sr_alias_set);\n-      FRP (emit_move_insn (gen_rtx_REG (DImode, REG_RA), mem));\n+      reg = gen_rtx_REG (DImode, REG_RA);\n+      emit_move_insn (reg, mem);\n+      cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n \n       reg_offset += 8;\n       imask &= ~(1UL << REG_RA);\n@@ -8116,7 +8116,10 @@ alpha_expand_epilogue (void)\n \t      {\n \t\tmem = gen_rtx_MEM (DImode, plus_constant(sa_reg, reg_offset));\n \t\tset_mem_alias_set (mem, alpha_sr_alias_set);\n-\t\tFRP (emit_move_insn (gen_rtx_REG (DImode, i), mem));\n+\t\treg = gen_rtx_REG (DImode, i);\n+\t\temit_move_insn (reg, mem);\n+\t\tcfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg,\n+\t\t\t\t\t       cfa_restores);\n \t      }\n \t    reg_offset += 8;\n \t  }\n@@ -8126,7 +8129,9 @@ alpha_expand_epilogue (void)\n \t  {\n \t    mem = gen_rtx_MEM (DFmode, plus_constant(sa_reg, reg_offset));\n \t    set_mem_alias_set (mem, alpha_sr_alias_set);\n-\t    FRP (emit_move_insn (gen_rtx_REG (DFmode, i+32), mem));\n+\t    reg = gen_rtx_REG (DFmode, i+32);\n+\t    emit_move_insn (reg, mem);\n+\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n \t    reg_offset += 8;\n \t  }\n     }\n@@ -8142,7 +8147,9 @@ alpha_expand_epilogue (void)\n \t    mem = gen_rtx_MEM (DImode, plus_constant(hard_frame_pointer_rtx,\n \t\t\t\t\t\t     reg_offset));\n \t    set_mem_alias_set (mem, alpha_sr_alias_set);\n-\t    FRP (emit_move_insn (gen_rtx_REG (DImode, i), mem));\n+\t    reg = gen_rtx_REG (DImode, i);\n+\t    emit_move_insn (reg, mem);\n+\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n \t    reg_offset -= 8;\n \t  }\n \n@@ -8152,15 +8159,18 @@ alpha_expand_epilogue (void)\n \t    mem = gen_rtx_MEM (DFmode, plus_constant(hard_frame_pointer_rtx,\n \t\t\t\t\t\t     reg_offset));\n \t    set_mem_alias_set (mem, alpha_sr_alias_set);\n-\t    FRP (emit_move_insn (gen_rtx_REG (DFmode, i+32), mem));\n+\t    reg = gen_rtx_REG (DFmode, i+32);\n+\t    emit_move_insn (reg, mem);\n+\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n \t    reg_offset -= 8;\n \t  }\n \n       /* Restore the return address from the DSIB.  */\n-\n-      mem = gen_rtx_MEM (DImode, plus_constant(hard_frame_pointer_rtx, -8));\n+      mem = gen_rtx_MEM (DImode, plus_constant (hard_frame_pointer_rtx, -8));\n       set_mem_alias_set (mem, alpha_sr_alias_set);\n-      FRP (emit_move_insn (gen_rtx_REG (DImode, REG_RA), mem));\n+      reg = gen_rtx_REG (DImode, REG_RA);\n+      emit_move_insn (reg, mem);\n+      cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n     }\n \n   if (frame_size || eh_ofs)\n@@ -8183,7 +8193,7 @@ alpha_expand_epilogue (void)\n       else if (TARGET_ABI_UNICOSMK)\n \t{\n \t  sp_adj1 = gen_rtx_REG (DImode, 23);\n-\t  FRP (emit_move_insn (sp_adj1, hard_frame_pointer_rtx));\n+\t  emit_move_insn (sp_adj1, hard_frame_pointer_rtx);\n \t  sp_adj2 = const0_rtx;\n \t}\n       else if (frame_size < 0x40007fffL)\n@@ -8196,21 +8206,20 @@ alpha_expand_epilogue (void)\n \t  else\n \t    {\n \t      sp_adj1 = gen_rtx_REG (DImode, 23);\n-\t      FRP (emit_move_insn (sp_adj1, sp_adj2));\n+\t      emit_move_insn (sp_adj1, sp_adj2);\n \t    }\n \t  sp_adj2 = GEN_INT (low);\n \t}\n       else\n \t{\n \t  rtx tmp = gen_rtx_REG (DImode, 23);\n-\t  FRP (sp_adj2 = alpha_emit_set_const (tmp, DImode, frame_size,\n-\t\t\t\t\t       3, false));\n+\t  sp_adj2 = alpha_emit_set_const (tmp, DImode, frame_size, 3, false);\n \t  if (!sp_adj2)\n \t    {\n \t      /* We can't drop new things to memory this late, afaik,\n \t\t so build it up by pieces.  */\n-\t      FRP (sp_adj2 = alpha_emit_set_long_const (tmp, frame_size,\n-\t\t\t\t\t\t\t-(frame_size < 0)));\n+\t      sp_adj2 = alpha_emit_set_long_const (tmp, frame_size,\n+\t\t\t\t\t\t   -(frame_size < 0));\n \t      gcc_assert (sp_adj2);\n \t    }\n \t}\n@@ -8224,46 +8233,58 @@ alpha_expand_epilogue (void)\n \t  mem = gen_rtx_MEM (DImode,\n \t\t\t     plus_constant (hard_frame_pointer_rtx, -16));\n \t  set_mem_alias_set (mem, alpha_sr_alias_set);\n-\t  FRP (emit_move_insn (hard_frame_pointer_rtx, mem));\n+\t  emit_move_insn (hard_frame_pointer_rtx, mem);\n+\t  cfa_restores = alloc_reg_note (REG_CFA_RESTORE,\n+\t\t\t\t\t hard_frame_pointer_rtx, cfa_restores);\n \t}\n       else if (fp_is_frame_pointer)\n \t{\n \t  emit_insn (gen_blockage ());\n \t  mem = gen_rtx_MEM (DImode, plus_constant (sa_reg, fp_offset));\n \t  set_mem_alias_set (mem, alpha_sr_alias_set);\n-\t  FRP (emit_move_insn (hard_frame_pointer_rtx, mem));\n+\t  emit_move_insn (hard_frame_pointer_rtx, mem);\n+\t  cfa_restores = alloc_reg_note (REG_CFA_RESTORE,\n+\t\t\t\t\t hard_frame_pointer_rtx, cfa_restores);\n \t}\n       else if (TARGET_ABI_OPEN_VMS)\n \t{\n \t  emit_insn (gen_blockage ());\n-\t  FRP (emit_move_insn (hard_frame_pointer_rtx,\n-\t\t\t       gen_rtx_REG (DImode, vms_save_fp_regno)));\n+\t  emit_move_insn (hard_frame_pointer_rtx,\n+\t\t\t  gen_rtx_REG (DImode, vms_save_fp_regno));\n+\t  cfa_restores = alloc_reg_note (REG_CFA_RESTORE,\n+\t\t\t\t\t hard_frame_pointer_rtx, cfa_restores);\n \t}\n \n       /* Restore the stack pointer.  */\n       emit_insn (gen_blockage ());\n       if (sp_adj2 == const0_rtx)\n-\tFRP (emit_move_insn (stack_pointer_rtx, sp_adj1));\n+\tinsn = emit_move_insn (stack_pointer_rtx, sp_adj1);\n       else\n-\tFRP (emit_move_insn (stack_pointer_rtx,\n-\t\t\t     gen_rtx_PLUS (DImode, sp_adj1, sp_adj2)));\n+\tinsn = emit_move_insn (stack_pointer_rtx,\n+\t\t\t       gen_rtx_PLUS (DImode, sp_adj1, sp_adj2));\n+      REG_NOTES (insn) = cfa_restores;\n+      add_reg_note (insn, REG_CFA_DEF_CFA, stack_pointer_rtx);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n     }\n   else\n     {\n+      gcc_assert (cfa_restores == NULL);\n+\n       if (TARGET_ABI_OPEN_VMS && alpha_procedure_type == PT_REGISTER)\n         {\n           emit_insn (gen_blockage ());\n-          FRP (emit_move_insn (hard_frame_pointer_rtx,\n-\t\t\t       gen_rtx_REG (DImode, vms_save_fp_regno)));\n+          insn = emit_move_insn (hard_frame_pointer_rtx,\n+\t\t\t\t gen_rtx_REG (DImode, vms_save_fp_regno));\n+\t  add_reg_note (insn, REG_CFA_RESTORE, hard_frame_pointer_rtx);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n         }\n       else if (TARGET_ABI_UNICOSMK && alpha_procedure_type != PT_STACK)\n \t{\n \t  /* Decrement the frame pointer if the function does not have a\n \t     frame.  */\n-\n \t  emit_insn (gen_blockage ());\n-\t  FRP (emit_insn (gen_adddi3 (hard_frame_pointer_rtx,\n-\t\t\t\t      hard_frame_pointer_rtx, constm1_rtx)));\n+\t  emit_insn (gen_adddi3 (hard_frame_pointer_rtx,\n+\t\t\t\t hard_frame_pointer_rtx, constm1_rtx));\n         }\n     }\n }\n@@ -10247,18 +10268,15 @@ unicosmk_gen_dsib (unsigned long *imaskP)\n       emit_insn (gen_blockage ());\n \n       /* Set the new frame pointer.  */\n-\n       FRP (emit_insn (gen_adddi3 (hard_frame_pointer_rtx,\n                                   stack_pointer_rtx, GEN_INT (64))));\n-\n     }\n   else\n     {\n       /* Increment the frame pointer register to indicate that we do not\n          have a frame.  */\n-\n-      FRP (emit_insn (gen_adddi3 (hard_frame_pointer_rtx,\n-                                  hard_frame_pointer_rtx, const1_rtx)));\n+      emit_insn (gen_adddi3 (hard_frame_pointer_rtx,\n+                             hard_frame_pointer_rtx, const1_rtx));\n     }\n }\n "}]}