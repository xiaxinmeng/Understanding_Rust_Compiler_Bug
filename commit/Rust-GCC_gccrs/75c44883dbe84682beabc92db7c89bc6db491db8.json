{"sha": "75c44883dbe84682beabc92db7c89bc6db491db8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVjNDQ4ODNkYmU4NDY4MmJlYWJjOTJkYjdjODliYzZkYjQ5MWRiOA==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-06-14T13:25:59Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-06-14T15:31:34Z"}, "message": "Name resolver should try to resolve each segment in turn\n\nName resolution tried to greedily resolve the entire CanonicalPath in one\nlookup which was ok for simple paths like A::B. This changes the name\nresolver to resolve each segment which allows the type resolution to\ndetermine the root path to be up until the segment is unresolved which\nwill then require a PathProbe or its a failure. This will be required to\nsupport modules which extend the resolution to be much more generic than\nis assumed here.\n\nAddresses: #432", "tree": {"sha": "52bea53f2c0f257c8a1a85de28e354456a53dfb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52bea53f2c0f257c8a1a85de28e354456a53dfb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75c44883dbe84682beabc92db7c89bc6db491db8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75c44883dbe84682beabc92db7c89bc6db491db8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75c44883dbe84682beabc92db7c89bc6db491db8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75c44883dbe84682beabc92db7c89bc6db491db8/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df36e6b9abb197ceb0ff5d1020482c75c6f1424a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df36e6b9abb197ceb0ff5d1020482c75c6f1424a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df36e6b9abb197ceb0ff5d1020482c75c6f1424a"}], "stats": {"total": 112, "additions": 58, "deletions": 54}, "files": [{"sha": "74ad4b8eae08657423820eac59b31ccd58cc8dde", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 58, "deletions": 54, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75c44883dbe84682beabc92db7c89bc6db491db8/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75c44883dbe84682beabc92db7c89bc6db491db8/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=75c44883dbe84682beabc92db7c89bc6db491db8", "patch": "@@ -537,61 +537,65 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n       AST::PathExprSegment &seg = expr->get_segments ().at (i);\n       auto s = ResolvePathSegmentToCanonicalPath::resolve (seg);\n       path = path.append (s);\n-    }\n \n-  if (resolver->get_name_scope ().lookup (path, &resolved_node))\n-    {\n-      resolver->insert_resolved_name (expr->get_node_id (), resolved_node);\n-      resolver->insert_new_definition (expr->get_node_id (),\n-\t\t\t\t       Definition{expr->get_node_id (),\n-\t\t\t\t\t\t  parent});\n-    }\n-  // check the type scope\n-  else if (resolver->get_type_scope ().lookup (path, &resolved_node))\n-    {\n-      resolver->insert_resolved_type (expr->get_node_id (), resolved_node);\n-      resolver->insert_new_definition (expr->get_node_id (),\n-\t\t\t\t       Definition{expr->get_node_id (),\n-\t\t\t\t\t\t  parent});\n-    }\n-  else\n-    {\n-      // attempt to fully resolve the path which is allowed to fail given the\n-      // following scenario\n-      //\n-      // https://github.com/Rust-GCC/gccrs/issues/355 Paths are\n-      // resolved fully here, there are limitations though imagine:\n-      //\n-      // struct Foo<A> (A);\n-      //\n-      // impl Foo<isize> {\n-      //    fn test() -> ...\n-      //\n-      // impl Foo<f32> {\n-      //    fn test() -> ...\n-      //\n-      // fn main() {\n-      //    let a:i32 = Foo::test();\n-      //\n-      // there are multiple paths that test can resolve to Foo::<?>::test here\n-      // so we cannot resolve this case\n-      //\n-      // canonical names:\n-      //\n-      // struct Foo<A>            -> Foo\n-      // impl Foo<isize>::fn test -> Foo::isize::test\n-      // impl Foo<f32>::fn test   -> Foo::f32::test\n-      //\n-      // Since there is the case we have the following paths for test:\n-      //\n-      // Foo::isize::test\n-      // Foo::f32::test\n-      // vs\n-      // Foo::test\n-      //\n-      // but the lookup was simply Foo::test we must rely on type resolution to\n-      // figure this type out in a similar fashion to method resolution with a\n-      // probe phase\n+      if (resolver->get_name_scope ().lookup (path, &resolved_node))\n+\t{\n+\t  resolver->insert_resolved_name (seg.get_node_id (), resolved_node);\n+\t  resolver->insert_new_definition (seg.get_node_id (),\n+\t\t\t\t\t   Definition{expr->get_node_id (),\n+\t\t\t\t\t\t      parent});\n+\t}\n+      // check the type scope\n+      else if (resolver->get_type_scope ().lookup (path, &resolved_node))\n+\t{\n+\t  resolver->insert_resolved_type (seg.get_node_id (), resolved_node);\n+\t  resolver->insert_new_definition (seg.get_node_id (),\n+\t\t\t\t\t   Definition{expr->get_node_id (),\n+\t\t\t\t\t\t      parent});\n+\t}\n+      else\n+\t{\n+\t  // attempt to fully resolve the path which is allowed to fail given\n+\t  // the following scenario\n+\t  //\n+\t  // https://github.com/Rust-GCC/gccrs/issues/355 Paths are\n+\t  // resolved fully here, there are limitations though imagine:\n+\t  //\n+\t  // struct Foo<A> (A);\n+\t  //\n+\t  // impl Foo<isize> {\n+\t  //    fn test() -> ...\n+\t  //\n+\t  // impl Foo<f32> {\n+\t  //    fn test() -> ...\n+\t  //\n+\t  // fn main() {\n+\t  //    let a:i32 = Foo::test();\n+\t  //\n+\t  // there are multiple paths that test can resolve to Foo::<?>::test\n+\t  // here so we cannot resolve this case\n+\t  //\n+\t  // canonical names:\n+\t  //\n+\t  // struct Foo<A>            -> Foo\n+\t  // impl Foo<isize>::fn test -> Foo::isize::test\n+\t  // impl Foo<f32>::fn test   -> Foo::f32::test\n+\t  //\n+\t  // Since there is the case we have the following paths for test:\n+\t  //\n+\t  // Foo::isize::test\n+\t  // Foo::f32::test\n+\t  // vs\n+\t  // Foo::test\n+\t  //\n+\t  // but the lookup was simply Foo::test we must rely on type resolution\n+\t  // to figure this type out in a similar fashion to method resolution\n+\t  // with a probe phase\n+\n+\t  // nothing more we can do we need the type resolver to try and resolve\n+\t  // this\n+\t  return;\n+\t}\n     }\n }\n "}]}