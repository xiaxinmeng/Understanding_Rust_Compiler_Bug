{"sha": "7d11cebe9a4c0ca58d956644027ab7d9b93b8157", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2QxMWNlYmU5YTRjMGNhNThkOTU2NjQ0MDI3YWI3ZDliOTNiODE1Nw==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2011-03-31T19:48:11Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2011-03-31T19:48:11Z"}, "message": "cprop.c: Clean up hash table building.\n\n\t* cprop.c: Clean up hash table building.\n\t(reg_avail_info): Remove.\n\t(oprs_available_p): Remove.\n\t(record_last_reg_set_info): Remove.\n\t(record_last_set_info): Remove.\n\t(reg_available_p): New function.\n\t(gcse_constant_p): Do not treat unfolded conditions as constants.\n\t(make_set_regs_unavailable): New function.\n\t(hash_scan_set): Simplify with new reg_available_p.\n\t(compute_hash_table_work): Traverse insns stream only once.\n\tDo not compute reg_avail_info. Traverse insns in reverse order.\n\tRecord implicit sets after recording explicit sets from the block.\n\nFrom-SVN: r171794", "tree": {"sha": "355ea15bc07e30c6c45030f0172588be21b7b72a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/355ea15bc07e30c6c45030f0172588be21b7b72a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d11cebe9a4c0ca58d956644027ab7d9b93b8157", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d11cebe9a4c0ca58d956644027ab7d9b93b8157", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d11cebe9a4c0ca58d956644027ab7d9b93b8157", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d11cebe9a4c0ca58d956644027ab7d9b93b8157/comments", "author": null, "committer": null, "parents": [{"sha": "b5ad7facf3504d711ba3390607ad3a22d8d2af7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5ad7facf3504d711ba3390607ad3a22d8d2af7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5ad7facf3504d711ba3390607ad3a22d8d2af7b"}], "stats": {"total": 236, "additions": 61, "deletions": 175}, "files": [{"sha": "a0ba31aa4b2b70f1ab5daabcc0636a32ee906de9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d11cebe9a4c0ca58d956644027ab7d9b93b8157/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d11cebe9a4c0ca58d956644027ab7d9b93b8157/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d11cebe9a4c0ca58d956644027ab7d9b93b8157", "patch": "@@ -1,3 +1,18 @@\n+2011-03-31  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* cprop.c: Clean up hash table building.\n+\t(reg_avail_info): Remove.\n+\t(oprs_available_p): Remove.\n+\t(record_last_reg_set_info): Remove.\n+\t(record_last_set_info): Remove.\n+\t(reg_available_p): New function.\n+\t(gcse_constant_p): Do not treat unfolded conditions as constants.\n+\t(make_set_regs_unavailable): New function.\n+\t(hash_scan_set): Simplify with new reg_available_p.\n+\t(compute_hash_table_work): Traverse insns stream only once.\n+\tDo not compute reg_avail_info. Traverse insns in reverse order.\n+\tRecord implicit sets after recording explicit sets from the block.\n+\n 2011-03-31  Michael Matz  <matz@suse.de>\n \n \t* builtins.c (build_va_arg_indirect_ref): Use"}, {"sha": "7d06e7be26d37491076b0a250f0fb68a4883a132", "filename": "gcc/cprop.c", "status": "modified", "additions": 46, "deletions": 175, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d11cebe9a4c0ca58d956644027ab7d9b93b8157/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d11cebe9a4c0ca58d956644027ab7d9b93b8157/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=7d11cebe9a4c0ca58d956644027ab7d9b93b8157", "patch": "@@ -118,7 +118,7 @@ static rtx *implicit_sets;\n \n /* Bitmap containing one bit for each register in the program.\n    Used when performing GCSE to track which registers have been set since\n-   the start of the basic block.  */\n+   the start or end of the basic block while traversing that block.  */\n static regset reg_set_bitmap;\n \n /* Various variables for statistics gathering.  */\n@@ -183,79 +183,13 @@ free_gcse_mem (void)\n   FREE_REG_SET (reg_set_bitmap);\n }\n \f\n-struct reg_avail_info\n-{\n-  basic_block last_bb;\n-  int last_set;\n-};\n-\n-static struct reg_avail_info *reg_avail_info;\n-static basic_block current_bb;\n-\n-/* Return nonzero if the operands of expression X are unchanged from\n-   INSN to the end of INSN's basic block.  */\n+/* Return nonzero if register X is unchanged from INSN to the end\n+   of INSN's basic block.  */\n \n static int\n-oprs_available_p (const_rtx x, const_rtx insn)\n+reg_available_p (const_rtx x, const_rtx insn ATTRIBUTE_UNUSED)\n {\n-  int i, j;\n-  enum rtx_code code;\n-  const char *fmt;\n-\n-  if (x == 0)\n-    return 1;\n-\n-  code = GET_CODE (x);\n-  switch (code)\n-    {\n-    case REG:\n-      {\n-\tstruct reg_avail_info *info = &reg_avail_info[REGNO (x)];\n-\n-\tif (info->last_bb != current_bb)\n-\t  return 1;\n-\treturn info->last_set < DF_INSN_LUID (insn);\n-      }\n-\n-    case PRE_DEC:\n-    case PRE_INC:\n-    case POST_DEC:\n-    case POST_INC:\n-    case PRE_MODIFY:\n-    case POST_MODIFY:\n-      return 0;\n-\n-    case PC:\n-    case CC0: /*FIXME*/\n-    case CONST:\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case CONST_FIXED:\n-    case CONST_VECTOR:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-    case ADDR_VEC:\n-    case ADDR_DIFF_VEC:\n-      return 1;\n-\n-    default:\n-      break;\n-    }\n-\n-  for (i = GET_RTX_LENGTH (code) - 1, fmt = GET_RTX_FORMAT (code); i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\t{\n-\t  if (! oprs_available_p (XEXP (x, i), insn))\n-\t    return 0;\n-\t}\n-      else if (fmt[i] == 'E')\n-\tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  if (! oprs_available_p (XVECEXP (x, i, j), insn))\n-\t    return 0;\n-    }\n-\n-  return 1;\n+  return ! REGNO_REG_SET_P (reg_set_bitmap, REGNO (x));\n }\n \n /* Hash a set of register REGNO.\n@@ -353,29 +287,13 @@ insert_set_in_table (rtx x, rtx insn, struct hash_table_d *table)\n     }\n }\n \n-/* Determine whether the rtx X should be treated as a constant for\n-   the purposes of GCSE's constant propagation.  */\n+/* Determine whether the rtx X should be treated as a constant for CPROP.\n+   Since X might be inserted more than once we have to take care that it\n+   is sharable.  */\n \n static bool\n gcse_constant_p (const_rtx x)\n {\n-  /* Consider a COMPARE of two integers constant.  */\n-  if (GET_CODE (x) == COMPARE\n-      && CONST_INT_P (XEXP (x, 0))\n-      && CONST_INT_P (XEXP (x, 1)))\n-    return true;\n-\n-  /* Consider a COMPARE of the same registers is a constant\n-     if they are not floating point registers.  */\n-  if (GET_CODE(x) == COMPARE\n-      && REG_P (XEXP (x, 0)) && REG_P (XEXP (x, 1))\n-      && REGNO (XEXP (x, 0)) == REGNO (XEXP (x, 1))\n-      && ! FLOAT_MODE_P (GET_MODE (XEXP (x, 0)))\n-      && ! FLOAT_MODE_P (GET_MODE (XEXP (x, 1))))\n-    return true;\n-\n-  /* Since X might be inserted more than once we have to take care that it\n-     is sharable.  */\n   return CONSTANT_P (x) && (GET_CODE (x) != CONST || shared_const_p (x));\n }\n \n@@ -387,49 +305,38 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n {\n   rtx src = SET_SRC (pat);\n   rtx dest = SET_DEST (pat);\n-  rtx note;\n \n-  if (REG_P (dest))\n+  if (REG_P (dest)\n+      && ! HARD_REGISTER_P (dest)\n+      && reg_available_p (dest, insn)\n+      && can_copy_p (GET_MODE (dest)))\n     {\n-      unsigned int regno = REGNO (dest);\n-      rtx tmp;\n-\n       /* See if a REG_EQUAL note shows this equivalent to a simpler expression.\n \n-\t This allows us to do a single GCSE pass and still eliminate\n+\t This allows us to do a single CPROP pass and still eliminate\n \t redundant constants, addresses or other expressions that are\n \t constructed with multiple instructions.\n \n \t However, keep the original SRC if INSN is a simple reg-reg move.  In\n \t In this case, there will almost always be a REG_EQUAL note on the\n \t insn that sets SRC.  By recording the REG_EQUAL value here as SRC\n-\t for INSN, we miss copy propagation opportunities and we perform the\n-\t same PRE GCSE operation repeatedly on the same REG_EQUAL value if we\n-\t do more than one PRE GCSE pass.\n+\t for INSN, we miss copy propagation opportunities.\n \n \t Note that this does not impede profitable constant propagations.  We\n \t \"look through\" reg-reg sets in lookup_avail_set.  */\n-      note = find_reg_equal_equiv_note (insn);\n+      rtx note = find_reg_equal_equiv_note (insn);\n       if (note != 0\n \t  && REG_NOTE_KIND (note) == REG_EQUAL\n \t  && !REG_P (src)\n \t  && gcse_constant_p (XEXP (note, 0)))\n \tsrc = XEXP (note, 0), pat = gen_rtx_SET (VOIDmode, dest, src);\n \n       /* Record sets for constant/copy propagation.  */\n-      if (regno >= FIRST_PSEUDO_REGISTER\n-\t  && ((REG_P (src)\n-\t       && REGNO (src) >= FIRST_PSEUDO_REGISTER\n-\t       && can_copy_p (GET_MODE (dest))\n-\t       && REGNO (src) != regno)\n-\t      || gcse_constant_p (src))\n-\t  /* A copy is not available if its src or dest is subsequently\n-\t     modified.  Here we want to search from INSN+1 on, but\n-\t     oprs_available_p searches from INSN on.  */\n-\t  && (insn == BB_END (BLOCK_FOR_INSN (insn))\n-\t      || (tmp = next_nonnote_nondebug_insn (insn)) == NULL_RTX\n-\t      || BLOCK_FOR_INSN (tmp) != BLOCK_FOR_INSN (insn)\n-\t      || oprs_available_p (pat, tmp)))\n+      if ((REG_P (src)\n+\t   && src != dest\n+\t   && ! HARD_REGISTER_P (src)\n+\t   && reg_available_p (src, insn))\n+\t  || gcse_constant_p (src))\n \tinsert_set_in_table (pat, insn, table);\n     }\n }\n@@ -504,39 +411,15 @@ dump_hash_table (FILE *file, const char *name, struct hash_table_d *table)\n   free (hash_val);\n }\n \n-/* Record register first/last/block set information for REGNO in INSN.\n-\n-   last_set records the last place in the block where the register\n-   is set and is used to compute \"availability\".\n-\n-   last_bb records the block for which last_set is valid, as a quick\n-   test to invalidate it.  */\n-\n-static void\n-record_last_reg_set_info (rtx insn, int regno)\n-{\n-  struct reg_avail_info *info = &reg_avail_info[regno];\n-  int luid = DF_INSN_LUID (insn);\n-\n-  info->last_set = luid;\n-  if (info->last_bb != current_bb)\n-    info->last_bb = current_bb;\n-}\n-\n-/* Called from compute_hash_table via note_stores to handle one\n-   SET or CLOBBER in an insn.  DATA is really the instruction in which\n-   the SET is taking place.  */\n-\n+/* Record as unavailable all registers that are DEF operands of INSN.  */\n static void\n-record_last_set_info (rtx dest, const_rtx setter ATTRIBUTE_UNUSED, void *data)\n+make_set_regs_unavailable (rtx insn)\n {\n-  rtx last_set_insn = (rtx) data;\n+  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+  df_ref *def_rec;\n \n-  if (GET_CODE (dest) == SUBREG)\n-    dest = SUBREG_REG (dest);\n-\n-  if (REG_P (dest))\n-    record_last_reg_set_info (last_set_insn, REGNO (dest));\n+  for (def_rec = DF_INSN_INFO_DEFS (insn_info); *def_rec; def_rec++)\n+    SET_REGNO_REG_SET (reg_set_bitmap, DF_REF_REGNO (*def_rec));\n }\n \n /* Top level function to create an assignments hash table.\n@@ -553,49 +436,37 @@ record_last_set_info (rtx dest, const_rtx setter ATTRIBUTE_UNUSED, void *data)\n static void\n compute_hash_table_work (struct hash_table_d *table)\n {\n-  int i;\n-\n-  /* Some working arrays used to track first and last set in each block.  */\n-  reg_avail_info = GNEWVEC (struct reg_avail_info, max_reg_num ());\n-\n-  for (i = 0; i < max_reg_num (); ++i)\n-    reg_avail_info[i].last_bb = NULL;\n+  basic_block bb;\n \n-  FOR_EACH_BB (current_bb)\n+  FOR_EACH_BB (bb)\n     {\n       rtx insn;\n-      unsigned int regno;\n \n-      /* First pass over the instructions records information used to\n-\t determine when registers and memory are first and last set.  */\n-      FOR_BB_INSNS (current_bb, insn)\n-\t{\n+      /* Reset tables used to keep track of what's not yet invalid [since\n+\t the end of the block].  */\n+      CLEAR_REG_SET (reg_set_bitmap);\n+\n+      /* Go over all insns from the last to the first.  This is convenient\n+\t for tracking available registers, i.e. not set between INSN and\n+\t the end of the basic block BB.  */\n+      FOR_BB_INSNS_REVERSE (bb, insn)\n+        {\n+\t  /* Only real insns are interesting.  */\n \t  if (!NONDEBUG_INSN_P (insn))\n \t    continue;\n \n-\t  if (CALL_P (insn))\n-\t    {\n-\t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\t\tif (TEST_HARD_REG_BIT (regs_invalidated_by_call, regno))\n-\t\t  record_last_reg_set_info (insn, regno);\n-\t    }\n+\t  /* Record interesting sets from INSN in the hash table.  */\n+\t  hash_scan_insn (insn, table);\n \n-\t  note_stores (PATTERN (insn), record_last_set_info, insn);\n+\t  /* Any registers set in INSN will make SETs above it not AVAIL.  */\n+\t  make_set_regs_unavailable (insn);\n \t}\n \n-      /* Insert implicit sets in the hash table.  */\n-      if (implicit_sets[current_bb->index] != NULL_RTX)\n-\thash_scan_set (implicit_sets[current_bb->index],\n-\t\t       BB_HEAD (current_bb), table);\n-\n-      /* The next pass builds the hash table.  */\n-      FOR_BB_INSNS (current_bb, insn)\n-\tif (NONDEBUG_INSN_P (insn))\n-\t  hash_scan_insn (insn, table);\n+      /* Insert implicit sets in the hash table, pretending they appear as\n+\t insns at the head of the basic block.  */\n+      if (implicit_sets[bb->index] != NULL_RTX)\n+\thash_scan_set (implicit_sets[bb->index], BB_HEAD (bb), table);\n     }\n-\n-  free (reg_avail_info);\n-  reg_avail_info = NULL;\n }\n \n /* Allocate space for the set/expr hash TABLE."}]}