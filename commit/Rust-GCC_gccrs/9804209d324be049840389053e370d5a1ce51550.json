{"sha": "9804209d324be049840389053e370d5a1ce51550", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTgwNDIwOWQzMjRiZTA0OTg0MDM4OTA1M2UzNzBkNWExY2U1MTU1MA==", "commit": {"author": {"name": "Douglas Gregor", "email": "dgregor@cs.indiana.edu", "date": "2005-02-21T23:12:27Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2005-02-21T23:12:27Z"}, "message": "re PR c++/19076 (Pointer to member function not matched to pointer to member template)\n\n2005-02-21  Douglas Gregor  <dgregor@cs.indiana.edu>\n\n\tPR c++/19076\n\tPR c++/6628\n\t* cp-tree.h (cp_apply_type_quals_to_decl): Declared.\n\t* decl.c (grokdeclarator): Pedwarn about qualifying a function\n\ttype.\n\tAdd qualifiers when declaring a typedef of a function type.\n\tMember function pointers pick up the qualifiers of the typedef\n\tused to declare them.\n        Don't complain about creating cv-qualified function types.\n\tComplain about qualified function typedefs that are used to\n\tdeclare non-static member functions or free functions.\n\tUse cp_apply_type_quals_to_decl.\n\t(start_preparsed_function): Use cp_apply_type_quals_to_decl.\n\t(grokclassfn): Use cp_apply_type_quals_to_decl.\n\t* error.c (dump_type_suffix): Print qualifiers for function\n\ttypes.\n\t* pt.c (tsubst_decl): Use cp_apply_type_quals_to_decl.\n\t(tsubst): When substituting a function type into a member\n\tpointer type, pass along the qualifiers.\n\t(unify): Unify member pointers to member function pointers.\n\t* tree.c (cp_build_qualified_type_real): Function types may be\n\tqualified. This includes restrict qualifiers.\n\t* typeck.c (cp_apply_type_quals_to_decl): New function to replace\n\tuse of c_apply_type_quals_to_decl. Drops qualifiers that are being\n\tadded to function types.\n\nFrom-SVN: r95356", "tree": {"sha": "04879cd2510172e1979dedf06e8a47fcc01ae72a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04879cd2510172e1979dedf06e8a47fcc01ae72a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9804209d324be049840389053e370d5a1ce51550", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9804209d324be049840389053e370d5a1ce51550", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9804209d324be049840389053e370d5a1ce51550", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9804209d324be049840389053e370d5a1ce51550/comments", "author": null, "committer": null, "parents": [{"sha": "89e4aa8109752fdf412a763afcb721acca852e96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89e4aa8109752fdf412a763afcb721acca852e96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89e4aa8109752fdf412a763afcb721acca852e96"}], "stats": {"total": 182, "additions": 155, "deletions": 27}, "files": [{"sha": "ae75f8fc23fecdad470cc2e68237c73a6a14e393", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9804209d324be049840389053e370d5a1ce51550/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9804209d324be049840389053e370d5a1ce51550/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9804209d324be049840389053e370d5a1ce51550", "patch": "@@ -1,3 +1,31 @@\n+2005-02-21  Douglas Gregor  <dgregor@cs.indiana.edu>\n+\t\n+\tPR c++/19076\n+\tPR c++/6628\n+\t* cp-tree.h (cp_apply_type_quals_to_decl): Declared.\n+\t* decl.c (grokdeclarator): Pedwarn about qualifying a function\n+\ttype. \n+\tAdd qualifiers when declaring a typedef of a function type.\n+\tMember function pointers pick up the qualifiers of the typedef\n+\tused to declare them.\n+        Don't complain about creating cv-qualified function types.\n+\tComplain about qualified function typedefs that are used to\n+\tdeclare non-static member functions or free functions.\n+\tUse cp_apply_type_quals_to_decl.\n+\t(start_preparsed_function): Use cp_apply_type_quals_to_decl.\n+\t(grokclassfn): Use cp_apply_type_quals_to_decl.\n+\t* error.c (dump_type_suffix): Print qualifiers for function\n+\ttypes. \n+\t* pt.c (tsubst_decl): Use cp_apply_type_quals_to_decl.\n+\t(tsubst): When substituting a function type into a member\n+\tpointer type, pass along the qualifiers.\n+\t(unify): Unify member pointers to member function pointers.\n+\t* tree.c (cp_build_qualified_type_real): Function types may be\n+\tqualified. This includes restrict qualifiers.\n+\t* typeck.c (cp_apply_type_quals_to_decl): New function to replace\n+\tuse of c_apply_type_quals_to_decl. Drops qualifiers that are being\n+\tadded to function types.\n+\n 2005-02-20  Zack Weinberg  <zack@codesourcery.com>\n \n \tPR 18785"}, {"sha": "d99ae7f74c1d46d5f454ee49de63b58b687ffb7c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9804209d324be049840389053e370d5a1ce51550/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9804209d324be049840389053e370d5a1ce51550/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9804209d324be049840389053e370d5a1ce51550", "patch": "@@ -4310,6 +4310,7 @@ extern tree build_ptrmemfunc\t\t\t(tree, tree, int, bool);\n extern int cp_type_quals                        (tree);\n extern bool cp_has_mutable_p                     (tree);\n extern bool at_least_as_qualified_p              (tree, tree);\n+extern void cp_apply_type_quals_to_decl         (int, tree);\n extern tree build_ptrmemfunc1                   (tree, tree, tree);\n extern void expand_ptrmemfunc_cst               (tree, tree *, tree *);\n extern tree pfn_from_ptrmemfunc                 (tree);"}, {"sha": "1613488acb73047555b9afbf67ac1d00e587b997", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 48, "deletions": 7, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9804209d324be049840389053e370d5a1ce51550/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9804209d324be049840389053e370d5a1ce51550/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9804209d324be049840389053e370d5a1ce51550", "patch": "@@ -6939,6 +6939,20 @@ grokdeclarator (const cp_declarator *declarator,\n     error (\"qualifiers are not allowed on declaration of %<operator %T%>\",\n            ctor_return_type);\n \n+  if (TREE_CODE (type) == FUNCTION_TYPE \n+      && type_quals != TYPE_UNQUALIFIED)\n+    {\n+      /* This was an error in C++98 (cv-qualifiers cannot be added to\n+         a function type), but DR 295 makes the code well-formed by\n+         dropping the extra qualifiers. */\n+      if (pedantic)\n+        {\n+          tree bad_type = build_qualified_type (type, type_quals);\n+          pedwarn (\"ignoring %qV qualifiers added to function type %qT\",\n+                   bad_type, type);\n+        }\n+      type_quals = TYPE_UNQUALIFIED;\n+    }\n   type_quals |= cp_type_quals (type);\n   type = cp_build_qualified_type_real\n     (type, type_quals, ((typedef_decl && !DECL_ARTIFICIAL (typedef_decl)\n@@ -7300,6 +7314,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t      }\n \n \t    type = build_function_type (type, arg_types);\n+            type = cp_build_qualified_type (type, quals);\n \t  }\n \t  break;\n \n@@ -7332,7 +7347,15 @@ grokdeclarator (const cp_declarator *declarator,\n \t      && (TREE_CODE (type) == FUNCTION_TYPE\n \t\t  || (quals && TREE_CODE (type) == METHOD_TYPE)))\n \t    {\n-\t      tree dummy = build_decl (TYPE_DECL, NULL_TREE, type);\n+\t      tree dummy;\n+\t      \n+              /* If the type is a FUNCTION_TYPE, pick up the\n+                 qualifiers from that function type. No other\n+                 qualifiers may be supplied. */\n+              if (TREE_CODE (type) == FUNCTION_TYPE)\n+                quals = cp_type_quals (type);\n+\n+\t      dummy = build_decl (TYPE_DECL, NULL_TREE, type);\n \t      grok_method_quals (declarator->u.pointer.class_type,\n \t\t\t\t dummy, quals);\n \t      type = TREE_TYPE (dummy);\n@@ -7629,11 +7652,12 @@ grokdeclarator (const cp_declarator *declarator,\n \t{\n \t  if (ctype == NULL_TREE)\n \t    {\n-\t      if (TREE_CODE (type) != METHOD_TYPE)\n-\t\terror (\"%Jinvalid type qualifier for non-member function type\",\n-\t\t       decl);\n-\t      else\n+              if (TREE_CODE (type) == METHOD_TYPE)\n \t\tctype = TYPE_METHOD_BASETYPE (type);\n+              /* Any qualifiers on a function type typedef have\n+                 already been dealt with. */\n+              else if (TREE_CODE (type) == FUNCTION_TYPE)\n+                quals = TYPE_UNQUALIFIED;\n \t    }\n \t  if (ctype != NULL_TREE)\n \t    grok_method_quals (ctype, decl, quals);\n@@ -7676,6 +7700,23 @@ grokdeclarator (const cp_declarator *declarator,\n \t}\n \n       parms = nreverse (decls);\n+\n+      if (decl_context != TYPENAME)\n+        {\n+          /* A cv-qualifier-seq shall only be part of the function type\n+             for a non-static member function. [8.3.5/4 dcl.fct] */ \n+          if (cp_type_quals (type) != TYPE_UNQUALIFIED\n+              && (current_class_type == NULL_TREE || staticp) )\n+            {\n+              error (\"qualified function types cannot be used to declare %s functions\",\n+                     (staticp? \"static member\" : \"free\"));\n+              type = TYPE_MAIN_VARIANT (type);\n+            }\n+          \n+          /* The qualifiers on the function type become the qualifiers on\n+             the non-static member function. */\n+          quals |= cp_type_quals (type);\n+        }\n     }\n \n   /* If this is a type name (such as, in a cast or sizeof),\n@@ -8211,7 +8252,7 @@ grokdeclarator (const cp_declarator *declarator,\n        when processing a template; we'll do this for the instantiated\n        declaration based on the type of DECL.  */\n     if (!processing_template_decl)\n-      c_apply_type_quals_to_decl (type_quals, decl);\n+      cp_apply_type_quals_to_decl (type_quals, decl);\n \n     return decl;\n   }\n@@ -9995,7 +10036,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n       DECL_IGNORED_P (resdecl) = 1;\n       DECL_RESULT (decl1) = resdecl;\n \n-      c_apply_type_quals_to_decl (cp_type_quals (restype), resdecl);\n+      cp_apply_type_quals_to_decl (cp_type_quals (restype), resdecl);\n     }\n \n   /* Initialize RTL machinery.  We cannot do this until"}, {"sha": "8243cb144654f1a7a333c6bb5336660c686786c6", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9804209d324be049840389053e370d5a1ce51550/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9804209d324be049840389053e370d5a1ce51550/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=9804209d324be049840389053e370d5a1ce51550", "patch": "@@ -299,7 +299,7 @@ grokclassfn (tree ctype, tree function, enum overload_flags flags,\n       this_quals |= TYPE_QUAL_CONST;\n       qual_type = cp_build_qualified_type (type, this_quals);\n       parm = build_artificial_parm (this_identifier, qual_type);\n-      c_apply_type_quals_to_decl (this_quals, parm);\n+      cp_apply_type_quals_to_decl (this_quals, parm);\n       TREE_CHAIN (parm) = DECL_ARGUMENTS (function);\n       DECL_ARGUMENTS (function) = parm;\n     }"}, {"sha": "86ea7aa6edaaa047282df79c76c16cd8a530466b", "filename": "gcc/cp/error.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9804209d324be049840389053e370d5a1ce51550/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9804209d324be049840389053e370d5a1ce51550/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=9804209d324be049840389053e370d5a1ce51550", "patch": "@@ -613,6 +613,8 @@ dump_type_suffix (tree t, int flags)\n \tif (TREE_CODE (t) == METHOD_TYPE)\n           pp_cxx_cv_qualifier_seq\n             (cxx_pp, TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t))));\n+        else\n+          pp_cxx_cv_qualifier_seq(cxx_pp, t);\n \tdump_exception_spec (TYPE_RAISES_EXCEPTIONS (t), flags);\n \tdump_type_suffix (TREE_TYPE (t), flags);\n \tbreak;"}, {"sha": "0d83bc1a4d278f164dc63336ab4d27fa26b12ba2", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9804209d324be049840389053e370d5a1ce51550/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9804209d324be049840389053e370d5a1ce51550/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9804209d324be049840389053e370d5a1ce51550", "patch": "@@ -6469,7 +6469,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \n \ttype = tsubst (TREE_TYPE (t), args, complain, in_decl);\n \tTREE_TYPE (r) = type;\n-\tc_apply_type_quals_to_decl (cp_type_quals (type), r);\n+\tcp_apply_type_quals_to_decl (cp_type_quals (type), r);\n \n \tif (DECL_INITIAL (r))\n \t  {\n@@ -6499,7 +6499,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \tif (type == error_mark_node)\n \t  return error_mark_node;\n \tTREE_TYPE (r) = type;\n-\tc_apply_type_quals_to_decl (cp_type_quals (type), r);\n+\tcp_apply_type_quals_to_decl (cp_type_quals (type), r);\n \n \t/* We don't have to set DECL_CONTEXT here; it is set by\n \t   finish_member_declaration.  */\n@@ -6599,7 +6599,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \telse if (DECL_SELF_REFERENCE_P (t))\n \t  SET_DECL_SELF_REFERENCE_P (r);\n \tTREE_TYPE (r) = type;\n-\tc_apply_type_quals_to_decl (cp_type_quals (type), r);\n+\tcp_apply_type_quals_to_decl (cp_type_quals (type), r);\n \tDECL_CONTEXT (r) = ctx;\n \t/* Clear out the mangled name and RTL for the instantiation.  */\n \tSET_DECL_ASSEMBLER_NAME (r, NULL_TREE);\n@@ -7218,22 +7218,18 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tgcc_assert (TREE_CODE (type) != METHOD_TYPE);\n \tif (TREE_CODE (type) == FUNCTION_TYPE)\n \t  {\n-\t    /* This is really a method type. The cv qualifiers of the\n-\t       this pointer should _not_ be determined by the cv\n-\t       qualifiers of the class type.  They should be held\n-\t       somewhere in the FUNCTION_TYPE, but we don't do that at\n-\t       the moment.  Consider\n-\t\t  typedef void (Func) () const;\n-\n-\t\t  template <typename T1> void Foo (Func T1::*);\n-\n-\t\t*/\n+            /* The type of the implicit object parameter gets its\n+               cv-qualifiers from the FUNCTION_TYPE. */\n \t    tree method_type;\n-\n-\t    method_type = build_method_type_directly (TYPE_MAIN_VARIANT (r),\n+            tree this_type = cp_build_qualified_type (TYPE_MAIN_VARIANT (r),\n+                                                      cp_type_quals (type));\n+            tree memptr;\n+            method_type = build_method_type_directly (this_type,\n \t\t\t\t\t\t      TREE_TYPE (type),\n \t\t\t\t\t\t      TYPE_ARG_TYPES (type));\n-\t    return build_ptrmemfunc_type (build_pointer_type (method_type));\n+            memptr = build_ptrmemfunc_type (build_pointer_type (method_type));\n+            return cp_build_qualified_type_real (memptr, cp_type_quals (t),\n+                                                 complain);\n \t  }\n \telse\n \t  return cp_build_qualified_type_real (build_ptrmem_type (r, type),\n@@ -10251,6 +10247,37 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t\t\t\t    DEDUCE_EXACT, 0, -1);\n \n     case OFFSET_TYPE:\n+      /* Unify a pointer to member with a pointer to member function, which\n+         deduces the type of the member as a function type. */\n+      if (TYPE_PTRMEMFUNC_P (arg))\n+        {\n+          tree method_type;\n+          tree fntype;\n+          cp_cv_quals cv_quals;\n+\n+          /* Check top-level cv qualifiers */\n+          if (!check_cv_quals_for_unify (UNIFY_ALLOW_NONE, arg, parm))\n+            return 1;\n+\n+          if (unify (tparms, targs, TYPE_OFFSET_BASETYPE (parm),\n+                     TYPE_PTRMEMFUNC_OBJECT_TYPE (arg), UNIFY_ALLOW_NONE))\n+            return 1;\n+\n+          /* Determine the type of the function we are unifying against. */\n+          method_type = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (arg));\n+          fntype = \n+            build_function_type (TREE_TYPE (method_type),\n+                                 TREE_CHAIN (TYPE_ARG_TYPES (method_type)));\n+\n+          /* Extract the cv-qualifiers of the member function from the\n+             implicit object parameter and place them on the function\n+             type to be restored later. */\n+          cv_quals = \n+            cp_type_quals(TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (method_type))));\n+          fntype = build_qualified_type (fntype, cv_quals);\n+          return unify (tparms, targs, TREE_TYPE (parm), fntype, strict);\n+        }\n+\n       if (TREE_CODE (arg) != OFFSET_TYPE)\n \treturn 1;\n       if (unify (tparms, targs, TYPE_OFFSET_BASETYPE (parm),"}, {"sha": "321ba4bdbc7090e8d2977a21390f200214ef13cf", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9804209d324be049840389053e370d5a1ce51550/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9804209d324be049840389053e370d5a1ce51550/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=9804209d324be049840389053e370d5a1ce51550", "patch": "@@ -499,22 +499,22 @@ cp_build_qualified_type_real (tree type,\n       return build_ptrmemfunc_type (t);\n     }\n \n-  /* A reference, function or method type shall not be cv qualified.\n+  /* A reference or method type shall not be cv qualified.\n      [dcl.ref], [dct.fct]  */\n   if (type_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE)\n       && (TREE_CODE (type) == REFERENCE_TYPE\n-\t  || TREE_CODE (type) == FUNCTION_TYPE\n \t  || TREE_CODE (type) == METHOD_TYPE))\n     {\n       bad_quals |= type_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n       type_quals &= ~(TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n     }\n \n   /* A restrict-qualified type must be a pointer (or reference)\n-     to object or incomplete type.  */\n+     to object or incomplete type, or a function type. */\n   if ((type_quals & TYPE_QUAL_RESTRICT)\n       && TREE_CODE (type) != TEMPLATE_TYPE_PARM\n       && TREE_CODE (type) != TYPENAME_TYPE\n+      && TREE_CODE (type) != FUNCTION_TYPE\n       && !POINTER_TYPE_P (type))\n     {\n       bad_quals |= TYPE_QUAL_RESTRICT;"}, {"sha": "4a6ded4c4a73c11c58175c3a443aa21e5b5746f6", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9804209d324be049840389053e370d5a1ce51550/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9804209d324be049840389053e370d5a1ce51550/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=9804209d324be049840389053e370d5a1ce51550", "patch": "@@ -6383,6 +6383,35 @@ cp_has_mutable_p (tree type)\n   return CLASS_TYPE_P (type) && CLASSTYPE_HAS_MUTABLE (type);\n }\n \n+/* Apply the TYPE_QUALS to the new DECL.  */\n+void\n+cp_apply_type_quals_to_decl (int type_quals, tree decl)\n+{\n+  tree type = TREE_TYPE (decl);\n+\n+  if (type == error_mark_node)\n+    return;\n+\n+  if (TREE_CODE (type) == FUNCTION_TYPE \n+      && type_quals != TYPE_UNQUALIFIED)\n+    {\n+      /* This was an error in C++98 (cv-qualifiers cannot be added to\n+         a function type), but DR 295 makes the code well-formed by\n+         dropping the extra qualifiers. */\n+      if (pedantic)\n+        {\n+          tree bad_type = build_qualified_type (type, type_quals);\n+          pedwarn (\"ignoring %qV qualifiers added to function type %qT\",\n+                   bad_type, type);\n+        }\n+\n+      TREE_TYPE (decl) = TYPE_MAIN_VARIANT (type);\n+      return;\n+    }\n+\n+  c_apply_type_quals_to_decl (type_quals, decl);\n+}\n+\n /* Subroutine of casts_away_constness.  Make T1 and T2 point at\n    exemplar types such that casting T1 to T2 is casting away constness\n    if and only if there is no implicit conversion from T1 to T2.  */"}]}