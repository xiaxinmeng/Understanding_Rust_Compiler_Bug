{"sha": "f2cf4c6121d2b350bb66ed6763e81b77a585846d", "node_id": "C_kwDOANBUbNoAKGYyY2Y0YzYxMjFkMmIzNTBiYjY2ZWQ2NzYzZTgxYjc3YTU4NTg0NmQ", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-12-13T23:33:06Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-12-13T23:58:30Z"}, "message": "ipa-sra: Forward propagation of sizes which are safe to dereference\n\nThe previous patch established a way to propagate information about\nparameters from callers to callees (even though then the actual\nsplitting is done in the opposite direction), this patch adds to that\ninformation about size of the parameters that is known to be safe to\ndereference in the callers - the information currently does not come\nfrom actual dereferences but only when we pass a reference to a known\ndeclaration, but we can use e.g. dereferences in BBs dominating the\ncall, for example too, if we decide it is worth it.\n\nReferences which look like splitting candidates but are not always\ndereferenced are - assuming the dereferences are not improbable - not\ndiscarded straight away but only marked as conditionally\ndereferenceable.  IPA phase then makes sure that they stay candidates\nonly if all incoming edges have big enough known-to-be-safe size.\n\ngcc/ChangeLog:\n\n2022-11-11  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-sra.cc (isra_param_desc): New fields safe_size,\n\tconditionally_dereferenceable and safe_size_set.\n\t(struct gensum_param_desc): New field conditionally_dereferenceable.\n\t(struct isra_param_flow): Updated comment of field unit_size.\n\t(ipa_sra_function_summaries::duplicate): Copy the new fields.\n\t(isra_call_summary::dump): Dump unit_size when representing safe_size.\n\t(dump_gensum_param_descriptor): Dump new flag.\n\t(dump_isra_param_descriptor): Dump new fields.\n\t(isra_analyze_call): Fill unit_size when it represents known safe\n\tsize.\n\t(check_gensum_access): Instead of disqualifying pointers which are not\n\talways dereference, mark them as conditionally dereferencable if loads\n\tare frequent enough.\n\t(process_scan_results): Copy the conditionally_dereferenceable flag.\n\t(isra_write_node_summary): Stream new fields, or assert they are not\n\tinitialized yet.\n\t(isra_read_node_info): Stream new fields.\n\t(update_safe_size): New function.\n\t(propagate_param_hints_accross_call): Propagate safe_sizes.\n\t(propagate_hints_to_all_callees): New function.\n\t(adjust_parameter_descriptions): Check conditionally_dereferenceable\n\tcandidates, rework dumping.\n\t(ipa_sra_analysis): Move most of hint propagation for one node to\n\tpropagate_hints_to_all_callees.  Add another loop to stabilize within\n\tSCCs and another one to verify.\n\ngcc/testsuite/ChangeLog:\n\n2022-11-11  Martin Jambor  <mjambor@suse.cz>\n\n\t* gcc.dg/ipa/ipa-sra-26.c: New test.\n\t* gcc.dg/ipa/ipa-sra-27.c: Likewise.\n\t* gcc.dg/ipa/ipa-sra-28.c: Likewise.", "tree": {"sha": "0c1bedcd8c92a3c22043e1711c410e38282bb6dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c1bedcd8c92a3c22043e1711c410e38282bb6dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2cf4c6121d2b350bb66ed6763e81b77a585846d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmOZEacACgkQv2PBvD+k\nNUBKnQ//fXjWr/Fso54zk/9jL6xJT2UNocsIP/B5pxcDEdGyC3VbSC3cAI044DCU\nAadH1w5vrW2VNIQc7eBvWvKMyYkNBDhSrlIFaqOoDyOMuv340TVZx1iE4a1wpaPI\nCo7N0IlRulaXgsQpO0ud/klPKfA0AX9g2QCRCJ8oMG/iccbxKXcnRS2pSkchdCZ4\nIFz1VDNZzns99DqWqv5MdbAf+AZy4rZpYmmT4LzuPvjDvhj12JpRQNEg+Q/drYjR\newk54AavjjKpyRJWRCjXbbEfyCRGDDuXWEXVvWK74V0DLD+GDdTm8vEpenWmEhD7\nbRIciixzYQpduRpMJjFBqBDfHpc3DCE5WCjDbaK1McON6te/G9+qqWBF1I1JSeWK\n2cFT77YQx1Udl+QmOyWNIB3Pl5XJRxPrHNbH0G/kxraHMzvfI+jLqMfOca7DhPit\nKY1kG95Yv5+vqu2PYzBrckrcc8iY028pkFlWUA090ulN/MDQlux9+NyG27Ayzljv\nIU+mKxmbkVGBI8bJPKZqvUd85Skru6geeb5eurIdMhFsk1TBwvlMbUrxytAaACEC\naCnMYoM8ekOYxylyWMp+YGBGTUP0q0U09lHtJhaGyrAPfBCnv997KypWDMWeu/Xd\n2molnYCYZrnuXMvxEw/i9lArryKrugw3LjagQbNG9wxs1gNs6qo=\n=plel\n-----END PGP SIGNATURE-----", "payload": "tree 0c1bedcd8c92a3c22043e1711c410e38282bb6dd\nparent e3a5cc3259ea173f74e34094c1eeffec7ccd9fe1\nauthor Martin Jambor <mjambor@suse.cz> 1670974386 +0100\ncommitter Martin Jambor <mjambor@suse.cz> 1670975910 +0100\n\nipa-sra: Forward propagation of sizes which are safe to dereference\n\nThe previous patch established a way to propagate information about\nparameters from callers to callees (even though then the actual\nsplitting is done in the opposite direction), this patch adds to that\ninformation about size of the parameters that is known to be safe to\ndereference in the callers - the information currently does not come\nfrom actual dereferences but only when we pass a reference to a known\ndeclaration, but we can use e.g. dereferences in BBs dominating the\ncall, for example too, if we decide it is worth it.\n\nReferences which look like splitting candidates but are not always\ndereferenced are - assuming the dereferences are not improbable - not\ndiscarded straight away but only marked as conditionally\ndereferenceable.  IPA phase then makes sure that they stay candidates\nonly if all incoming edges have big enough known-to-be-safe size.\n\ngcc/ChangeLog:\n\n2022-11-11  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-sra.cc (isra_param_desc): New fields safe_size,\n\tconditionally_dereferenceable and safe_size_set.\n\t(struct gensum_param_desc): New field conditionally_dereferenceable.\n\t(struct isra_param_flow): Updated comment of field unit_size.\n\t(ipa_sra_function_summaries::duplicate): Copy the new fields.\n\t(isra_call_summary::dump): Dump unit_size when representing safe_size.\n\t(dump_gensum_param_descriptor): Dump new flag.\n\t(dump_isra_param_descriptor): Dump new fields.\n\t(isra_analyze_call): Fill unit_size when it represents known safe\n\tsize.\n\t(check_gensum_access): Instead of disqualifying pointers which are not\n\talways dereference, mark them as conditionally dereferencable if loads\n\tare frequent enough.\n\t(process_scan_results): Copy the conditionally_dereferenceable flag.\n\t(isra_write_node_summary): Stream new fields, or assert they are not\n\tinitialized yet.\n\t(isra_read_node_info): Stream new fields.\n\t(update_safe_size): New function.\n\t(propagate_param_hints_accross_call): Propagate safe_sizes.\n\t(propagate_hints_to_all_callees): New function.\n\t(adjust_parameter_descriptions): Check conditionally_dereferenceable\n\tcandidates, rework dumping.\n\t(ipa_sra_analysis): Move most of hint propagation for one node to\n\tpropagate_hints_to_all_callees.  Add another loop to stabilize within\n\tSCCs and another one to verify.\n\ngcc/testsuite/ChangeLog:\n\n2022-11-11  Martin Jambor  <mjambor@suse.cz>\n\n\t* gcc.dg/ipa/ipa-sra-26.c: New test.\n\t* gcc.dg/ipa/ipa-sra-27.c: Likewise.\n\t* gcc.dg/ipa/ipa-sra-28.c: Likewise.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2cf4c6121d2b350bb66ed6763e81b77a585846d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2cf4c6121d2b350bb66ed6763e81b77a585846d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2cf4c6121d2b350bb66ed6763e81b77a585846d/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3a5cc3259ea173f74e34094c1eeffec7ccd9fe1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3a5cc3259ea173f74e34094c1eeffec7ccd9fe1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3a5cc3259ea173f74e34094c1eeffec7ccd9fe1"}], "stats": {"total": 384, "additions": 328, "deletions": 56}, "files": [{"sha": "93f5e34b15c15de7fd834a10fc7c7e833e17d1c9", "filename": "gcc/ipa-sra.cc", "status": "modified", "additions": 197, "deletions": 56, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2cf4c6121d2b350bb66ed6763e81b77a585846d/gcc%2Fipa-sra.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2cf4c6121d2b350bb66ed6763e81b77a585846d/gcc%2Fipa-sra.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-sra.cc?ref=f2cf4c6121d2b350bb66ed6763e81b77a585846d", "patch": "@@ -173,6 +173,10 @@ struct GTY(()) isra_param_desc\n   unsigned param_size_limit : ISRA_ARG_SIZE_LIMIT_BITS;\n   /* Sum of unit sizes of all certain replacements.  */\n   unsigned size_reached : ISRA_ARG_SIZE_LIMIT_BITS;\n+  /* Minimum offset that is known to be safe to dereference because of callers\n+     pass pointers to DECLs of at least this size or because of dereferences in\n+     callers.  */\n+  unsigned safe_size : ISRA_ARG_SIZE_LIMIT_BITS;\n \n   /* A parameter that is used only in call arguments and can be removed if all\n      concerned actual arguments are removed.  */\n@@ -185,6 +189,12 @@ struct GTY(()) isra_param_desc\n      not construct the argument just to pass it to calls.  Only meaningful for\n      by_ref parameters.  */\n   unsigned not_specially_constructed : 1;\n+  /* Only meaningful for by_ref parameters.  If set, this parameter can only be\n+     a split candidate if all callers pass pointers that are known to point to\n+     a chunk of memory large enough to contain all accesses.  */\n+  unsigned conditionally_dereferenceable : 1;\n+  /* Set when safe_size has been updated from at least one caller.  */\n+  unsigned safe_size_set : 1;\n };\n \n /* Structure used when generating summaries that describes a parameter.  */\n@@ -220,6 +230,10 @@ struct gensum_param_desc\n      without performing further checks (for example because it is a\n      REFERENCE_TYPE)?  */\n   bool safe_ref;\n+  /* Only meaningful for by_ref parameters.  If set, this parameter can only be\n+     a split candidate if all callers pass pointers that are known to point to\n+     a chunk of memory large enough to contain all accesses.  */\n+  bool conditionally_dereferenceable;\n \n   /* The number of this parameter as they are ordered in function decl.  */\n   int param_number;\n@@ -332,10 +346,12 @@ struct isra_param_flow\n \n   /* Offset within the formal parameter.  */\n   unsigned unit_offset;\n-  /* Size of the portion of the formal parameter that is being passed.  */\n+  /* When aggregate_pass_through is set, this is the size of the portion of an\n+     aggregate formal parameter that is being passed.  Otherwise, this is size\n+     of pointed to memory that is known to be valid be dereferenced.  */\n   unsigned unit_size : ISRA_ARG_SIZE_LIMIT_BITS;\n \n-  /* True when the value of this actual copy is a portion of a formal\n+  /* True when the value of this actual argument is a portion of a formal\n      parameter.  */\n   unsigned aggregate_pass_through : 1;\n   /* True when the value of this actual copy is a verbatim pass through of an\n@@ -425,10 +441,13 @@ ipa_sra_function_summaries::duplicate (cgraph_node *, cgraph_node *,\n \n       d->param_size_limit = s->param_size_limit;\n       d->size_reached = s->size_reached;\n+      d->safe_size = s->safe_size;\n       d->locally_unused = s->locally_unused;\n       d->split_candidate = s->split_candidate;\n       d->by_ref = s->by_ref;\n       d->not_specially_constructed = s->not_specially_constructed;\n+      d->conditionally_dereferenceable = s->conditionally_dereferenceable;\n+      d->safe_size_set = s->safe_size_set;\n \n       unsigned acc_count = vec_safe_length (s->accesses);\n       vec_safe_reserve_exact (d->accesses, acc_count);\n@@ -537,6 +556,8 @@ isra_call_summary::dump (FILE *f)\n \tfprintf (f, \"      Aggregate pass through from the param given above, \"\n \t\t \"unit offset: %u , unit size: %u\\n\",\n \t\t ipf->unit_offset, ipf->unit_size);\n+      else if (ipf->unit_size > 0)\n+\tfprintf (f, \"      Known dereferenceable size: %u\\n\", ipf->unit_size);\n       if (ipf->pointer_pass_through)\n \tfprintf (f, \"      Pointer pass through from the param given above, \"\n \t\t \"safe_to_import_accesses: %u\\n\", ipf->safe_to_import_accesses);\n@@ -717,8 +738,11 @@ dump_gensum_param_descriptor (FILE *f, gensum_param_desc *desc)\n       return;\n     }\n   if (desc->by_ref)\n-    fprintf (f, \"    %s by_ref with %u pass throughs\\n\",\n-\t     desc->safe_ref ? \"safe\" : \"unsafe\", desc->ptr_pt_count);\n+    fprintf (f, \"    %s%s by_ref with %u pass throughs\\n\",\n+\t     desc->safe_ref ? \"safe\" : \"unsafe\",\n+\t     desc->conditionally_dereferenceable\n+\t     ? \" conditionally_dereferenceable\" : \" ok\",\n+\t     desc->ptr_pt_count);\n \n   for (gensum_param_access *acc = desc->accesses; acc; acc = acc->next_sibling)\n     dump_gensum_access (f, acc, 2);\n@@ -756,16 +780,23 @@ dump_isra_param_descriptor (FILE *f, isra_param_desc *desc, bool hints)\n     }\n   if (!desc->split_candidate)\n     {\n-      fprintf (f, \"    not a candidate for splitting\\n\");\n+      fprintf (f, \"    not a candidate for splitting\");\n+      if (hints && desc->by_ref && desc->safe_size_set)\n+\tfprintf (f, \", safe_size: %u\", (unsigned) desc->safe_size);\n+      fprintf (f, \"\\n\");\n       return;\n     }\n   fprintf (f, \"    param_size_limit: %u, size_reached: %u%s\",\n \t   desc->param_size_limit, desc->size_reached,\n \t   desc->by_ref ? \", by_ref\" : \"\");\n+  if (desc->by_ref && desc->conditionally_dereferenceable)\n+    fprintf (f, \", conditionally_dereferenceable\");\n   if (hints)\n     {\n       if (desc->by_ref && !desc->not_specially_constructed)\n \tfprintf (f, \", args_specially_constructed\");\n+      if (desc->by_ref && desc->safe_size_set)\n+\tfprintf (f, \", safe_size: %u\", (unsigned) desc->safe_size);\n     }\n   fprintf (f, \"\\n\");\n \n@@ -2085,8 +2116,19 @@ isra_analyze_call (cgraph_edge *cs)\n \t  bool reverse;\n \t  tree base = get_ref_base_and_extent (TREE_OPERAND (arg, 0), &poffset,\n \t\t\t\t\t       &psize, &pmax_size, &reverse);\n-\t  /* TODO: Next patch will need the offset too, so we cannot use\n-\t     get_base_address. */\n+\t  HOST_WIDE_INT offset;\n+\t  unsigned HOST_WIDE_INT ds;\n+\t  if (DECL_P (base)\n+\t      && (poffset.is_constant (&offset))\n+\t      && tree_fits_uhwi_p (DECL_SIZE (base))\n+\t      && ((ds = tree_to_uhwi (DECL_SIZE (base)) - offset)\n+\t\t  < ISRA_ARG_SIZE_LIMIT * BITS_PER_UNIT))\n+\t    {\n+\t      csum->init_inputs (count);\n+\t      gcc_assert (!csum->m_arg_flow[i].aggregate_pass_through);\n+\t      csum->m_arg_flow[i].unit_size = ds / BITS_PER_UNIT;\n+\t    }\n+\n \t  if (TREE_CODE (base) == VAR_DECL\n \t      && !TREE_STATIC (base)\n \t      && !loaded_decls->contains (base))\n@@ -2309,9 +2351,14 @@ check_gensum_access (struct function *fun, tree parm, gensum_param_desc *desc,\n \t  int idx = (entry_bb_index * unsafe_by_ref_count + desc->deref_index);\n \t  if ((access->offset + access->size) > bb_dereferences[idx])\n \t    {\n-\t      disqualify_split_candidate (desc, \"Would create a possibly \"\n-\t\t\t\t\t  \"illegal dereference in a caller.\");\n-\t      return true;\n+\t      if (!dereference_probable_p (fun, access))\n+\t\t{\n+\t\t  disqualify_split_candidate (desc, \"Would create a possibly \"\n+\t\t\t\t\t      \"illegal dereference in a \"\n+\t\t\t\t\t      \"caller.\");\n+\t\t  return true;\n+\t\t}\n+\t      desc->conditionally_dereferenceable = true;\n \t    }\n \t}\n     }\n@@ -2540,6 +2587,7 @@ process_scan_results (cgraph_node *node, struct function *fun,\n       d->locally_unused = s->locally_unused;\n       d->split_candidate = s->split_candidate;\n       d->by_ref = s->by_ref;\n+      d->conditionally_dereferenceable = s->conditionally_dereferenceable;\n \n       for (gensum_param_access *acc = s->accesses;\n \t   acc;\n@@ -2694,11 +2742,14 @@ isra_write_node_summary (output_block *ob, cgraph_node *node)\n \t}\n       streamer_write_uhwi (ob, desc->param_size_limit);\n       streamer_write_uhwi (ob, desc->size_reached);\n+      gcc_assert (desc->safe_size == 0);\n       bitpack_d bp = bitpack_create (ob->main_stream);\n       bp_pack_value (&bp, desc->locally_unused, 1);\n       bp_pack_value (&bp, desc->split_candidate, 1);\n       bp_pack_value (&bp, desc->by_ref, 1);\n       gcc_assert (!desc->not_specially_constructed);\n+      bp_pack_value (&bp, desc->conditionally_dereferenceable, 1);\n+      gcc_assert (!desc->safe_size_set);\n       streamer_write_bitpack (&bp);\n     }\n   bitpack_d bp = bitpack_create (ob->main_stream);\n@@ -2815,11 +2866,14 @@ isra_read_node_info (struct lto_input_block *ib, cgraph_node *node,\n \t}\n       desc->param_size_limit = streamer_read_uhwi (ib);\n       desc->size_reached = streamer_read_uhwi (ib);\n+      desc->safe_size = 0;\n       bitpack_d bp = streamer_read_bitpack (ib);\n       desc->locally_unused = bp_unpack_value (&bp, 1);\n       desc->split_candidate = bp_unpack_value (&bp, 1);\n       desc->by_ref = bp_unpack_value (&bp, 1);\n       desc->not_specially_constructed = 0;\n+      desc->conditionally_dereferenceable = bp_unpack_value (&bp, 1);\n+      desc->safe_size_set = 0;\n     }\n   bitpack_d bp = streamer_read_bitpack (ib);\n   ifs->m_candidate = bp_unpack_value (&bp, 1);\n@@ -3266,44 +3320,65 @@ isra_mark_caller_param_used (isra_func_summary *from_ifs, int input_idx,\n     }\n }\n \n-/* Set all param hints in DESC to the pessimistic values.  */\n+/* Combine safe_size of DESC with SIZE and return true if it has changed.  */\n \n-static void\n+static bool\n+update_safe_size (isra_param_desc *desc, unsigned size)\n+{\n+  if (!desc->safe_size_set)\n+    {\n+      desc->safe_size_set = 1;\n+      desc->safe_size = size;\n+      return true;\n+    }\n+  if (desc->safe_size <= size)\n+    return false;\n+  desc->safe_size = size;\n+  return true;\n+}\n+\n+/* Set all param hints in DESC to the pessimistic values.  Return true if any\n+   hints that need to potentially trigger further propagation have changed.  */\n+\n+static bool\n flip_all_hints_pessimistic (isra_param_desc *desc)\n {\n   desc->not_specially_constructed = true;\n-\n-  return;\n+  return update_safe_size (desc, 0);\n }\n \n-/* Because we have not analyzed a caller, go over all parameter int flags of\n-   NODE and turn them pessimistic.  */\n+/* Because we have not analyzed or otherwise problematic caller, go over all\n+   parameter int flags of IFS describing a call graph node of a calllee and\n+   turn them pessimistic.  Return true if any hints that need to potentially\n+   trigger further propagation have changed.  */\n \n-static void\n-flip_all_param_hints_pessimistic (cgraph_node *node)\n+static bool\n+flip_all_param_hints_pessimistic (isra_func_summary *ifs)\n {\n-  isra_func_summary *ifs = func_sums->get (node);\n   if (!ifs || !ifs->m_candidate)\n-    return;\n+    return false;\n \n+  bool ret = false;\n   unsigned param_count = vec_safe_length (ifs->m_parameters);\n \n   for (unsigned i = 0; i < param_count; i++)\n-    flip_all_hints_pessimistic (&(*ifs->m_parameters)[i]);\n+    ret |= flip_all_hints_pessimistic (&(*ifs->m_parameters)[i]);\n \n-  return;\n+  return ret;\n }\n \n-/* Propagate hints accross edge CS which ultimately leads to CALLEE.  */\n+/* Propagate hints accross edge CS which ultimately leads to a node described\n+   by TO_IFS.  Return true if any hints of the callee which should potentially\n+   trigger further propagation have changed.  */\n \n-static void\n-propagate_param_hints (cgraph_edge *cs, cgraph_node *callee)\n+static bool\n+propagate_param_hints_accross_call (cgraph_edge *cs, isra_func_summary *to_ifs)\n {\n-  isra_call_summary *csum = call_sums->get (cs);\n-  isra_func_summary *to_ifs = func_sums->get (callee);\n   if (!to_ifs || !to_ifs->m_candidate)\n-    return;\n+    return false;\n \n+  isra_call_summary *csum = call_sums->get (cs);\n+  bool ret = false;\n   unsigned args_count = csum->m_arg_flow.length ();\n   unsigned param_count = vec_safe_length (to_ifs->m_parameters);\n \n@@ -3312,14 +3387,62 @@ propagate_param_hints (cgraph_edge *cs, cgraph_node *callee)\n       isra_param_desc *desc = &(*to_ifs->m_parameters)[i];\n       if (i >= args_count)\n \t{\n-\t  flip_all_hints_pessimistic (desc);\n+\t  ret |= flip_all_hints_pessimistic (desc);\n \t  continue;\n \t}\n \n-      if (desc->by_ref && !csum->m_arg_flow[i].constructed_for_calls)\n-\tdesc->not_specially_constructed = true;\n+      if (desc->by_ref)\n+\t{\n+\t  isra_param_flow *ipf = &csum->m_arg_flow[i];\n+\n+\t  if (!ipf->constructed_for_calls)\n+\t    desc->not_specially_constructed = true;\n+\n+\t  if (ipf->pointer_pass_through)\n+\t    {\n+\t      isra_func_summary *from_ifs = func_sums->get (cs->caller);\n+\t      int srcidx = get_single_param_flow_source (ipf);\n+\t      if (vec_safe_length (from_ifs->m_parameters) > (unsigned) srcidx)\n+\t\t{\n+\t\t  isra_param_desc *src_d = &(*from_ifs->m_parameters)[srcidx];\n+\t\t  if (src_d->safe_size_set)\n+\t\t    ret |= update_safe_size (desc, src_d->safe_size);\n+\t\t}\n+\t      else\n+\t\tret |= update_safe_size (desc, 0);\n+\t    }\n+\t  else if (!ipf->aggregate_pass_through)\n+\t    ret |= update_safe_size (desc, ipf->unit_size);\n+\t  else\n+\t    /* LTOing type-mismatched programs can end up here.  */\n+\t    ret |= update_safe_size (desc, 0);\n+\t}\n+    }\n+  return ret;\n+}\n+\n+/* Propagate hints from NODE described by FROM_IFS to all its (dorect) callees,\n+   push those that may need re-visiting onto STACK.  */\n+\n+static void\n+propagate_hints_to_all_callees (cgraph_node *node, isra_func_summary *from_ifs,\n+\t\t\t\tvec<cgraph_node *> *stack)\n+{\n+  for (cgraph_edge *cs = node->callees; cs; cs = cs->next_callee)\n+    {\n+      enum availability availability;\n+      cgraph_node *callee = cs->callee->function_symbol (&availability);\n+      isra_func_summary *to_ifs = func_sums->get (callee);\n+      if (!from_ifs)\n+\t{\n+\t  if (flip_all_param_hints_pessimistic (to_ifs)\n+\t      && ipa_edge_within_scc (cs))\n+\t    isra_push_node_to_stack (callee, to_ifs, stack);\n+\t}\n+      else if (propagate_param_hints_accross_call (cs, to_ifs)\n+\t       && ipa_edge_within_scc (cs))\n+\tisra_push_node_to_stack (callee, to_ifs, stack);\n     }\n-  return;\n }\n \n /* Propagate information that any parameter is not used only locally within a\n@@ -3991,7 +4114,8 @@ adjust_parameter_descriptions (cgraph_node *node, isra_func_summary *ifs)\n       check_surviving = true;\n       cinfo->param_adjustments->get_surviving_params (&surviving_params);\n     }\n-  bool dumped_first = false;\n+  auto_vec <unsigned> dump_dead_indices;\n+  auto_vec <unsigned> dump_bad_cond_indices;\n   for (unsigned i = 0; i < len; i++)\n     {\n       isra_param_desc *desc = &(*ifs->m_parameters)[i];\n@@ -4010,19 +4134,23 @@ adjust_parameter_descriptions (cgraph_node *node, isra_func_summary *ifs)\n \t  desc->split_candidate = false;\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      if (!dumped_first)\n-\t\t{\n-\t\t  fprintf (dump_file,\n-\t\t\t   \"The following parameters of %s are dead on \"\n-\t\t\t   \"arrival:\", node->dump_name ());\n-\t\t  dumped_first = true;\n-\t\t}\n-\t      fprintf (dump_file, \" %u\", i);\n-\t    }\n+\t    dump_dead_indices.safe_push (i);\n \t}\n       else\n \t{\n+\t  if (desc->split_candidate && desc->conditionally_dereferenceable)\n+\t    {\n+\t      gcc_assert (desc->safe_size_set);\n+\t      for (param_access *pa : *desc->accesses)\n+\t\tif ((pa->unit_offset + pa->unit_size) > desc->safe_size)\n+\t\t  {\n+\t\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t      dump_bad_cond_indices.safe_push (i);\n+\t\t    desc->split_candidate = false;\n+\t\t    break;\n+\t\t  }\n+\t    }\n+\n \t  if (desc->split_candidate)\n \t    {\n \t      if (desc->by_ref && !desc->not_specially_constructed)\n@@ -4040,8 +4168,22 @@ adjust_parameter_descriptions (cgraph_node *node, isra_func_summary *ifs)\n \t}\n     }\n \n-  if (dumped_first)\n-    fprintf (dump_file, \"\\n\");\n+  if (!dump_dead_indices.is_empty ())\n+    {\n+      fprintf (dump_file, \"The following parameters of %s are dead on arrival:\",\n+\t       node->dump_name ());\n+      for (unsigned i : dump_dead_indices)\n+\tfprintf (dump_file, \" %u\", i);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  if (!dump_bad_cond_indices.is_empty ())\n+    {\n+      fprintf (dump_file, \"The following parameters of %s are not safe to \"\n+\t       \"derefernce in all callers:\", node->dump_name ());\n+      for (unsigned i : dump_bad_cond_indices)\n+\tfprintf (dump_file, \" %u\", i);\n+      fprintf (dump_file, \"\\n\");\n+    }\n \n   return ret;\n }\n@@ -4122,17 +4264,16 @@ ipa_sra_analysis (void)\n       for (cgraph_node *v : cycle_nodes)\n \t{\n \t  isra_func_summary *ifs = func_sums->get (v);\n-\t  for (cgraph_edge *cs = v->callees; cs; cs = cs->next_callee)\n-\t    {\n-\t      enum availability availability;\n-\t      cgraph_node *callee = cs->callee->function_symbol (&availability);\n-\t      if (!ifs)\n-\t\t{\n-\t\t  flip_all_param_hints_pessimistic (callee);\n-\t\t  continue;\n-\t\t}\n-\t      propagate_param_hints (cs, callee);\n-\t    }\n+\t  propagate_hints_to_all_callees (v, ifs, &stack);\n+\t}\n+\n+      while (!stack.is_empty ())\n+\t{\n+\t  cgraph_node *node = stack.pop ();\n+\t  isra_func_summary *ifs = func_sums->get (node);\n+\t  gcc_checking_assert (ifs && ifs->m_queued);\n+\t  ifs->m_queued = false;\n+\t  propagate_hints_to_all_callees (node, ifs, &stack);\n \t}\n \n       cycle_nodes.release ();"}, {"sha": "08a40da1482845c271bd8f356115178b6b312ed0", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-26.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2cf4c6121d2b350bb66ed6763e81b77a585846d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2cf4c6121d2b350bb66ed6763e81b77a585846d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-26.c?ref=f2cf4c6121d2b350bb66ed6763e81b77a585846d", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-sra-details\"  } */\n+\n+struct S\n+{\n+  short a, b, c;\n+};\n+\n+extern int gc;\n+extern int *arr;\n+\n+static void __attribute__((noinline))\n+foo (struct S *p)\n+{\n+  for (int i = 0; i < gc; i++)\n+    arr += p->b;\n+}\n+\n+void\n+bar (short a, short b, short c)\n+{\n+  struct S s;\n+  s.a = a;\n+  s.b = b;\n+  s.c = c;\n+  foo (&s);\n+  return;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Will split parameter\" \"sra\" } } */\n+"}, {"sha": "b815e8a83b17011e2942b5d688ecae0811e37f41", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-27.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2cf4c6121d2b350bb66ed6763e81b77a585846d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2cf4c6121d2b350bb66ed6763e81b77a585846d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-27.c?ref=f2cf4c6121d2b350bb66ed6763e81b77a585846d", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-sra-details\"  } */\n+\n+struct S\n+{\n+  short a, b, c;\n+};\n+\n+extern int gc;\n+extern int *arr;\n+\n+static void __attribute__((noinline))\n+foo (struct S *p)\n+{\n+  for (int i = 0; i < gc; i++)\n+    arr += p->b;\n+}\n+\n+static void __attribute__((noinline))\n+baz (struct S *p)\n+{\n+  foo (p);\n+  gc = p->a + p->c;\n+}\n+\n+void\n+bar (short a, short b, short c)\n+{\n+  struct S s;\n+  s.a = a;\n+  s.b = b;\n+  s.c = c;\n+  foo (&s);\n+  return;\n+}\n+\n+void\n+bar2 (short a, short b, short c)\n+{\n+  struct S s;\n+  s.a = a;\n+  s.b = b;\n+  s.c = c;\n+  baz (&s);\n+  return;\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"Will split parameter\" 2 \"sra\" } } */\n+"}, {"sha": "d77d33a36083156dedd8c2a026be5a038443e1fe", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-28.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2cf4c6121d2b350bb66ed6763e81b77a585846d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2cf4c6121d2b350bb66ed6763e81b77a585846d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-28.c?ref=f2cf4c6121d2b350bb66ed6763e81b77a585846d", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-sra-details\"  } */\n+\n+struct S\n+{\n+  short a, b, c;\n+};\n+\n+volatile int gc;\n+volatile int *arr;\n+\n+static void __attribute__((noinline))\n+foo (struct S *p)\n+{\n+  for (int i = 0; i < gc; i++)\n+    arr += p->b;\n+}\n+\n+void\n+bar (short a, short b, short c)\n+{\n+  struct S s;\n+  s.a = a;\n+  s.b = b;\n+  s.c = c;\n+  foo (&s);\n+  return;\n+}\n+\n+void\n+baz (void)\n+{\n+  foo ((struct S *) 0);\n+}\n+\n+void __attribute__((noipa))\n+confuse (void)\n+{\n+  gc = 0;\n+  baz ();\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  confuse ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump-not \"Will split parameter\" \"sra\" } } */\n+"}]}