{"sha": "33521f7d42494a249c2c5446a8aedd88406389f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM1MjFmN2Q0MjQ5NGEyNDljMmM1NDQ2YThhZWRkODg0MDYzODlmMg==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@redhat.com", "date": "2004-03-17T22:26:28Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-03-17T22:26:28Z"}, "message": "builtins.c (apply_args_size): Use reg_raw_mode.\n\n2004-03-17  Eric Christopher  <echristo@redhat.com>\n\n\t* builtins.c (apply_args_size): Use reg_raw_mode.\n\t(apply_result_size): Ditto.\n\nFrom-SVN: r79609", "tree": {"sha": "9b55792e221034d43c937039bcb7b4d758ad6c8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b55792e221034d43c937039bcb7b4d758ad6c8d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33521f7d42494a249c2c5446a8aedd88406389f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33521f7d42494a249c2c5446a8aedd88406389f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33521f7d42494a249c2c5446a8aedd88406389f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33521f7d42494a249c2c5446a8aedd88406389f2/comments", "author": {"login": "echristo", "id": 327308, "node_id": "MDQ6VXNlcjMyNzMwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/327308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/echristo", "html_url": "https://github.com/echristo", "followers_url": "https://api.github.com/users/echristo/followers", "following_url": "https://api.github.com/users/echristo/following{/other_user}", "gists_url": "https://api.github.com/users/echristo/gists{/gist_id}", "starred_url": "https://api.github.com/users/echristo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/echristo/subscriptions", "organizations_url": "https://api.github.com/users/echristo/orgs", "repos_url": "https://api.github.com/users/echristo/repos", "events_url": "https://api.github.com/users/echristo/events{/privacy}", "received_events_url": "https://api.github.com/users/echristo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "86881a7b541b2ec6557b1a315f841b211d14c576", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86881a7b541b2ec6557b1a315f841b211d14c576", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86881a7b541b2ec6557b1a315f841b211d14c576"}], "stats": {"total": 112, "additions": 25, "deletions": 87}, "files": [{"sha": "0ce701fcc51b3624da64767ba82b55fc2ed3a211", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33521f7d42494a249c2c5446a8aedd88406389f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33521f7d42494a249c2c5446a8aedd88406389f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=33521f7d42494a249c2c5446a8aedd88406389f2", "patch": "@@ -1,3 +1,8 @@\n+2004-03-17  Eric Christopher  <echristo@redhat.com>\n+\n+\t* builtins.c (apply_args_size): Use reg_raw_mode.\n+\t(apply_result_size): Ditto.\n+\n 2004-03-17  Ralf Corsepius <corsepiu@faw.uni-ulm.de>\n \n \tPR target/14620"}, {"sha": "0222673f8494175915995d973c19cb8f96de227a", "filename": "gcc/builtins.c", "status": "modified", "additions": 20, "deletions": 87, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33521f7d42494a249c2c5446a8aedd88406389f2/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33521f7d42494a249c2c5446a8aedd88406389f2/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=33521f7d42494a249c2c5446a8aedd88406389f2", "patch": "@@ -261,7 +261,7 @@ c_strlen (tree src, int only_value)\n \n       len1 = c_strlen (TREE_OPERAND (src, 1), only_value);\n       len2 = c_strlen (TREE_OPERAND (src, 2), only_value);\n-      if (tree_int_cst_equal (len1, len2))      \n+      if (tree_int_cst_equal (len1, len2))\n \treturn len1;\n     }\n \n@@ -904,42 +904,8 @@ apply_args_size (void)\n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \tif (FUNCTION_ARG_REGNO_P (regno))\n \t  {\n-\t    /* Search for the proper mode for copying this register's\n-\t       value.  I'm not sure this is right, but it works so far.  */\n-\t    enum machine_mode best_mode = VOIDmode;\n-\n-\t    for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t\t mode != VOIDmode;\n-\t\t mode = GET_MODE_WIDER_MODE (mode))\n-\t      if (HARD_REGNO_MODE_OK (regno, mode)\n-\t\t  && hard_regno_nregs[regno][mode] == 1)\n-\t\tbest_mode = mode;\n-\n-\t    if (best_mode == VOIDmode)\n-\t      for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT);\n-\t\t   mode != VOIDmode;\n-\t\t   mode = GET_MODE_WIDER_MODE (mode))\n-\t\tif (HARD_REGNO_MODE_OK (regno, mode)\n-\t\t    && have_insn_for (SET, mode))\n-\t\t  best_mode = mode;\n-\n-\t    if (best_mode == VOIDmode)\n-\t      for (mode = GET_CLASS_NARROWEST_MODE (MODE_VECTOR_FLOAT);\n-\t\t   mode != VOIDmode;\n-\t\t   mode = GET_MODE_WIDER_MODE (mode))\n-\t\tif (HARD_REGNO_MODE_OK (regno, mode)\n-\t\t    && have_insn_for (SET, mode))\n-\t\t  best_mode = mode;\n-\n-\t    if (best_mode == VOIDmode)\n-\t      for (mode = GET_CLASS_NARROWEST_MODE (MODE_VECTOR_INT);\n-\t\t   mode != VOIDmode;\n-\t\t   mode = GET_MODE_WIDER_MODE (mode))\n-\t\tif (HARD_REGNO_MODE_OK (regno, mode)\n-\t\t    && have_insn_for (SET, mode))\n-\t\t  best_mode = mode;\n-\n-\t    mode = best_mode;\n+\t    mode = reg_raw_mode[regno];\n+\n \t    if (mode == VOIDmode)\n \t      abort ();\n \n@@ -977,41 +943,8 @@ apply_result_size (void)\n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \tif (FUNCTION_VALUE_REGNO_P (regno))\n \t  {\n-\t    /* Search for the proper mode for copying this register's\n-\t       value.  I'm not sure this is right, but it works so far.  */\n-\t    enum machine_mode best_mode = VOIDmode;\n-\n-\t    for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t\t mode != TImode;\n-\t\t mode = GET_MODE_WIDER_MODE (mode))\n-\t      if (HARD_REGNO_MODE_OK (regno, mode))\n-\t\tbest_mode = mode;\n-\n-\t    if (best_mode == VOIDmode)\n-\t      for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT);\n-\t\t   mode != VOIDmode;\n-\t\t   mode = GET_MODE_WIDER_MODE (mode))\n-\t\tif (HARD_REGNO_MODE_OK (regno, mode)\n-\t\t    && have_insn_for (SET, mode))\n-\t\t  best_mode = mode;\n-\n-\t    if (best_mode == VOIDmode)\n-\t      for (mode = GET_CLASS_NARROWEST_MODE (MODE_VECTOR_FLOAT);\n-\t\t   mode != VOIDmode;\n-\t\t   mode = GET_MODE_WIDER_MODE (mode))\n-\t\tif (HARD_REGNO_MODE_OK (regno, mode)\n-\t\t    && have_insn_for (SET, mode))\n-\t\t  best_mode = mode;\n-\n-\t    if (best_mode == VOIDmode)\n-\t      for (mode = GET_CLASS_NARROWEST_MODE (MODE_VECTOR_INT);\n-\t\t   mode != VOIDmode;\n-\t\t   mode = GET_MODE_WIDER_MODE (mode))\n-\t\tif (HARD_REGNO_MODE_OK (regno, mode)\n-\t\t    && have_insn_for (SET, mode))\n-\t\t  best_mode = mode;\n-\n-\t    mode = best_mode;\n+\t    mode = reg_raw_mode[regno];\n+\n \t    if (mode == VOIDmode)\n \t      abort ();\n \n@@ -1109,7 +1042,7 @@ expand_builtin_apply_args_1 (void)\n \t\t     NULL_RTX);\n #endif\n   emit_move_insn (adjust_address (registers, Pmode, 0), tem);\n-  \n+\n   size = GET_MODE_SIZE (Pmode);\n \n   /* Save the structure value address unless this is passed as an\n@@ -1895,7 +1828,7 @@ expand_builtin_mathfn_2 (tree exp, rtx target, rtx subtarget)\n    multiplications to inline before calling the system library's pow\n    function.  powi(x,n) requires at worst 2*bits(n)-2 multiplications,\n    so this default never requires calling pow, powf or powl.  */\n- \n+\n #ifndef POWI_MAX_MULTS\n #define POWI_MAX_MULTS  (2*HOST_BITS_PER_WIDE_INT-2)\n #endif\n@@ -2012,7 +1945,7 @@ powi_cost (HOST_WIDE_INT n)\n \t  result++;\n \t}\n     }\n-  \n+\n   return result + powi_lookup_cost (val, cache);\n }\n \n@@ -2061,7 +1994,7 @@ expand_powi_1 (enum machine_mode mode, unsigned HOST_WIDE_INT n, rtx *cache)\n /* Expand the RTL to evaluate powi(x,n) in mode MODE.  X is the\n    floating point operand in mode MODE, and N is the exponent.  This\n    function needs to be kept in sync with powi_cost above.  */\n-   \n+\n static rtx\n expand_powi (rtx x, enum machine_mode mode, HOST_WIDE_INT n)\n {\n@@ -2622,7 +2555,7 @@ expand_builtin_mempcpy (tree arglist, rtx target, enum machine_mode mode,\n       /* If LEN is not constant, call the normal function.  */\n       if (! host_integerp (len, 1))\n \treturn 0;\n-  \n+\n       /* If the LEN parameter is zero, return DEST.  */\n       if (tree_low_cst (len, 1) == 0)\n \t{\n@@ -3195,7 +3128,7 @@ expand_builtin_memcmp (tree exp ATTRIBUTE_UNUSED, tree arglist, rtx target,\n       insn_mode = insn_data[(int) CODE_FOR_cmpstrsi].operand[0].mode;\n     else\n #endif\n-      return 0;     \n+      return 0;\n \n     /* If we don't have POINTER_TYPE, call the function.  */\n     if (arg1_align == 0 || arg2_align == 0)\n@@ -3597,15 +3530,15 @@ expand_builtin_strcat (tree arglist, rtx target, enum machine_mode mode)\n                  pieces into (dst + strlen(dst)).  */\n \t      tree newdst, arglist,\n \t\tstrlen_fn = implicit_built_in_decls[BUILT_IN_STRLEN];\n-\t      \n+\n \t      /* This is the length argument.  */\n \t      arglist = build_tree_list (NULL_TREE,\n \t\t\t\t\t fold (size_binop (PLUS_EXPR,\n \t\t\t\t\t\t\t   c_strlen (src, 0),\n \t\t\t\t\t\t\t   ssize_int (1))));\n \t      /* Prepend src argument.  */\n \t      arglist = tree_cons (NULL_TREE, src, arglist);\n-\t      \n+\n \t      /* We're going to use dst more than once.  */\n \t      dst = save_expr (dst);\n \n@@ -3619,7 +3552,7 @@ expand_builtin_strcat (tree arglist, rtx target, enum machine_mode mode)\n \n \t      /* Prepend the new dst argument.  */\n \t      arglist = tree_cons (NULL_TREE, newdst, arglist);\n-\t      \n+\n \t      /* We don't want to get turned into a memcpy if the\n                  target is const0_rtx, i.e. when the return value\n                  isn't used.  That would produce pessimized code so\n@@ -4638,7 +4571,7 @@ build_string_literal (int len, const char *str)\n /* Expand a call to printf or printf_unlocked with argument list ARGLIST.\n    Return 0 if a normal call should be emitted rather than transforming\n    the function inline.  If convenient, the result should be placed in\n-   TARGET with mode MODE.  UNLOCKED indicates this is a printf_unlocked \n+   TARGET with mode MODE.  UNLOCKED indicates this is a printf_unlocked\n    call.  */\n static rtx\n expand_builtin_printf (tree arglist, rtx target, enum machine_mode mode,\n@@ -4741,7 +4674,7 @@ expand_builtin_printf (tree arglist, rtx target, enum machine_mode mode,\n /* Expand a call to fprintf or fprintf_unlocked with argument list ARGLIST.\n    Return 0 if a normal call should be emitted rather than transforming\n    the function inline.  If convenient, the result should be placed in\n-   TARGET with mode MODE.  UNLOCKED indicates this is a fprintf_unlocked \n+   TARGET with mode MODE.  UNLOCKED indicates this is a fprintf_unlocked\n    call.  */\n static rtx\n expand_builtin_fprintf (tree arglist, rtx target, enum machine_mode mode,\n@@ -6209,7 +6142,7 @@ fold_builtin_logarithm (tree exp, const REAL_VALUE_TYPE *value)\n       tree type = TREE_TYPE (TREE_TYPE (fndecl));\n       tree arg = TREE_VALUE (arglist);\n       const enum built_in_function fcode = builtin_mathfn_code (arg);\n-\t\n+\n       /* Optimize logN(1.0) = 0.0.  */\n       if (real_onep (arg))\n \treturn build_real (type, dconst0);\n@@ -6224,7 +6157,7 @@ fold_builtin_logarithm (tree exp, const REAL_VALUE_TYPE *value)\n \t  if (real_dconstp (arg, &value_truncate))\n \t    return build_real (type, dconst1);\n \t}\n-      \n+\n       /* Special case, optimize logN(expN(x)) = x.  */\n       if (flag_unsafe_math_optimizations\n \t  && ((value == &dconste\n@@ -6244,7 +6177,7 @@ fold_builtin_logarithm (tree exp, const REAL_VALUE_TYPE *value)\n       if (flag_unsafe_math_optimizations)\n         {\n \t  tree exponent = 0, x = 0;\n-\t  \n+\n \t  switch (fcode)\n \t  {\n \t  case BUILT_IN_EXP:\n@@ -6311,7 +6244,7 @@ fold_builtin_logarithm (tree exp, const REAL_VALUE_TYPE *value)\n \n   return 0;\n }\n-\t  \n+\n /* A subroutine of fold_builtin to fold the various exponent\n    functions.  EXP is the CALL_EXPR of a call to a builtin function.\n    VALUE is the value which will be raised to a power.  */"}]}