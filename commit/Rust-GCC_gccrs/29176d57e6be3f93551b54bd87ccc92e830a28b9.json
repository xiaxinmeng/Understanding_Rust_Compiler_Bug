{"sha": "29176d57e6be3f93551b54bd87ccc92e830a28b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjkxNzZkNTdlNmJlM2Y5MzU1MWI1NGJkODdjY2M5MmU4MzBhMjhiOQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-01-13T20:07:12Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-01-13T20:07:12Z"}, "message": "rs6000-builtin.def (BU_FLOAT128_2): Add support for pack/unpack functions for __ibm128.\n\n[gcc]\n2016-01-13  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000-builtin.def (BU_FLOAT128_2): Add support\n\tfor pack/unpack functions for __ibm128.\n\t(PACK_IF): Likewise.\n\t(UNPACK_IF): Likewise.\n\n\t* config/rs6000/rs6000.c (rs6000_builtin_mask_calculate): Add\n\tsupport for __ibm128 pack/unpack functions.\n\t(rs6000_invalid_builtin): Likewise.\n\t(rs6000_init_builtins): Likewise.\n\t(rs6000_opt_masks): Likewise.\n\n\t* config/rs6000/rs6000.h (MASK_FLOAT128): Add short name.\n\t(RS6000_BTM_FLOAT128): Add support for __ibm128 pack/unpack\n\tfunctions\n\t(RS6000_BTM_COMMON): Likewise.\n\n\t* config/rs6000/rs6000.md (f128_vsx): New mode attribute.\n\t(unpack<mode>): Use FMOVE128_FPR iterator instead of FMOVE128, to\n\tdisallow __builtin_{pack,unpack}_longdouble if long double is IEEE\n\t128-bit floating point.  Add support for the double values to be\n\tin Altivec registers for TF/IF packing and unpacking, but restrict\n\tTD packing sub-fields to be FPR registers.  Don't allow overlapped\n\tregister support for packing.  Allow pack inputs to be memory\n\tlocations.  Don't build generator functions for unpack<mode>_dm\n\tand unpack<mode>_nodm.\n\t(unpack<mode>_dm): Likewise.\n\t(unpack<mode>_nodm): Likewise.\n\t(pack<mode>): Likewise.\n\n\t* config/rs6000/rs6000-builtin.def (__builtin_pack_ibm128): Add\n\tbuilt-in functions to pack/unpack explicit __ibm128 values.\n\t(__builtin_unpack_ibm128): Likewise.\n\n\t* doc/extend.texi (PowerPC Built-in Functions): Document\n\t__builtin_pack_ibm128 and __builtin_unpack_ibm128.\n\n[libgcc]\n2016-01-13  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\t    Steven Munroe <munroesj@linux.vnet.ibm.com>\n\t    Tulio Magno Quites Machado Filho <tulioqm@br.ibm.com>\n\n\t* config/rs6000/sfp-exceptions.c: New file to provide exception\n\tsupport for IEEE 128-bit floating point.\n\n\t* config/rs6000/float128-hw.c: New file for ISA 3.0 IEEE 128-bit\n\tfloating point hardware support.\n\n\t* config/rs6000/floattikf.c: New files for IEEE 128-bit floating\n\tpoint conversions.\n\t* config/rs6000/fixunskfti.c: Likewise.\n\t* config/rs6000/fixkfti.c: Likewise.\n\t* config/rs6000/floatuntikf.c: Likewise.\n\t* config/rs6000/extendkftf2-sw.c: Likewise.\n\t* config/rs6000/trunctfkf2-sw.c: Likewise.\n\n\t* config/rs6000/float128-ifunc.c: New file to pick either IEEE\n\t128-bit floating point software emulation or use ISA 3.0 hardware\n\tsupport if it is available.\n\n\t* config/rs6000/quad-float128.h: New file to support IEEE 128-bit\n\tfloating point.\n\n\t* config/rs6000/t-float128: New Makefile fragments to enable\n\tbuilding __float128 emulation support.\n\t* config/rs6000/t-float128-hw: Likewise.\n\n\t* config/rs6000/float128-sed: New file to convert TF names to KF\n\tnames for PowerPC IEEE 128-bit floating point support.\n\n\t* config/rs6000/sfp-machine.h (_FP_W_TYPE_SIZE): Use 64-bit types\n\twhen building on 64-bit systems, or when VSX is enabled.\n\t(_FP_W_TYPE): Likewise.\n\t(_FP_WS_TYPE): Likewise.\n\t(_FP_I_TYPE): Likewise.\n\t(TItype): Define on 64-bit systems.\n\t(UTItype): Likewise.\n\t(TI_BITS): Likewise.\n\t(_FP_MUL_MEAT_D): Add support for using 64-bit types.\n\t(_FP_MUL_MEAT_Q): Likewise.\n\t(_FP_DIV_MEAT_D): Likewise.\n\t(_FP_DIV_MEAT_Q): Likewise.\n\t(_FP_NANFRAC_D): Likewise.\n\t(_FP_NANFRAC_Q): Likewise.\n\t(ISA_BIT): Add exception support if we are being compiled on a\n\tmachine with hardware floating point support to build the IEEE\n\t128-bit emulation functions.\n\t(FP_EX_INVALID): Likewise.\n\t(FP_EX_OVERFLOW): Likewise.\n\t(FP_EX_UNDERFLOW): Likewise.\n\t(FP_EX_DIVZERO): Likewise.\n\t(FP_EX_INEXACT): Likewise.\n\t(FP_EX_ALL): Likewise.\n\t(__sfp_handle_exceptions): Likewise.\n\t(FP_HANDLE_EXCEPTIONS): Likewise.\n\t(FP_RND_NEAREST): Likewise.\n\t(FP_RND_ZERO): Likewise.\n\t(FP_RND_PINF): Likewise.\n\t(FP_RND_MINF): Likewise.\n\t(FP_RND_MASK): Likewise.\n\t(_FP_DECL_EX): Likewise.\n\t(FP_INIT_ROUNDMODE): Likewise.\n\t(FP_ROUNDMODE): Likewise.\n\n\t* configure.ac (powerpc*-*-linux*): Check whether the PowerPC\n\tcompiler can do __float128.\n\t* configure: Regenerate.\n\n\t* libgcc/config.host (powerpc*-*-linux*): If compiler can compile\n\tVSX code, enable IEEE 128-bit floating point.\n\nFrom-SVN: r232346", "tree": {"sha": "3e9e41b127e139ff3b252fcbc1363a8af5c6916b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e9e41b127e139ff3b252fcbc1363a8af5c6916b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29176d57e6be3f93551b54bd87ccc92e830a28b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29176d57e6be3f93551b54bd87ccc92e830a28b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29176d57e6be3f93551b54bd87ccc92e830a28b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29176d57e6be3f93551b54bd87ccc92e830a28b9/comments", "author": null, "committer": null, "parents": [{"sha": "3342fd71e0465ab4a702480a35043b295fc6fa21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3342fd71e0465ab4a702480a35043b295fc6fa21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3342fd71e0465ab4a702480a35043b295fc6fa21"}], "stats": {"total": 1671, "additions": 1633, "deletions": 38}, "files": [{"sha": "784d5b18613c197e1bc6d2e4682e6b96bf4e4921", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -1,3 +1,41 @@\n+2016-01-13  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000-builtin.def (BU_FLOAT128_2): Add support\n+\tfor pack/unpack functions for __ibm128.\n+\t(PACK_IF): Likewise.\n+\t(UNPACK_IF): Likewise.\n+\n+\t* config/rs6000/rs6000.c (rs6000_builtin_mask_calculate): Add\n+\tsupport for __ibm128 pack/unpack functions.\n+\t(rs6000_invalid_builtin): Likewise.\n+\t(rs6000_init_builtins): Likewise.\n+\t(rs6000_opt_masks): Likewise.\n+\n+\t* config/rs6000/rs6000.h (MASK_FLOAT128): Add short name.\n+\t(RS6000_BTM_FLOAT128): Add support for __ibm128 pack/unpack\n+\tfunctions\n+\t(RS6000_BTM_COMMON): Likewise.\n+\n+\t* config/rs6000/rs6000.md (f128_vsx): New mode attribute.\n+\t(unpack<mode>): Use FMOVE128_FPR iterator instead of FMOVE128, to\n+\tdisallow __builtin_{pack,unpack}_longdouble if long double is IEEE\n+\t128-bit floating point.  Add support for the double values to be\n+\tin Altivec registers for TF/IF packing and unpacking, but restrict\n+\tTD packing sub-fields to be FPR registers.  Don't allow overlapped\n+\tregister support for packing.  Allow pack inputs to be memory\n+\tlocations.  Don't build generator functions for unpack<mode>_dm\n+\tand unpack<mode>_nodm.\n+\t(unpack<mode>_dm): Likewise.\n+\t(unpack<mode>_nodm): Likewise.\n+\t(pack<mode>): Likewise.\n+\n+\t* config/rs6000/rs6000-builtin.def (__builtin_pack_ibm128): Add\n+\tbuilt-in functions to pack/unpack explicit __ibm128 values.\n+\t(__builtin_unpack_ibm128): Likewise.\n+\n+\t* doc/extend.texi (PowerPC Built-in Functions): Document\n+\t__builtin_pack_ibm128 and __builtin_unpack_ibm128.\n+\n 2016-01-13  Bernd Schmidt  <bschmidt@redhat.com>\n \n \tPR c/66208"}, {"sha": "bbb395df37d77dd1c85869ca9dd9951d7c49739b", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -647,6 +647,15 @@\n \t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n \t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n \n+/* __float128 floating point builtins.  */\n+#define BU_FLOAT128_2(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_2 (MISC_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_\" NAME,\t\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_FLOAT128,\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n #endif\n \n /* Insure 0 is not a legitimate index.  */\n@@ -1642,6 +1651,9 @@ BU_DFP_MISC_2 (UNPACK_TD,\t\"unpack_dec128\",\tCONST,\tunpacktd)\n BU_LDBL128_2 (PACK_TF,\t\t\"pack_longdouble\",\tCONST,\tpacktf)\n BU_LDBL128_2 (UNPACK_TF,\t\"unpack_longdouble\",\tCONST,\tunpacktf)\n \n+BU_FLOAT128_2 (PACK_IF,\t\t\"pack_ibm128\",\t\tCONST,\tpackif)\n+BU_FLOAT128_2 (UNPACK_IF,\t\"unpack_ibm128\",\tCONST,\tunpackif)\n+\n BU_P7_MISC_2 (PACK_V1TI,\t\"pack_vector_int128\",\tCONST,\tpackv1ti)\n BU_P7_MISC_2 (UNPACK_V1TI,\t\"unpack_vector_int128\",\tCONST,\tunpackv1ti)\n "}, {"sha": "a7144fd38701ac886476bf09f2651a450dd8be84", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -3521,7 +3521,8 @@ rs6000_builtin_mask_calculate (void)\n \t  | ((TARGET_HTM)\t\t    ? RS6000_BTM_HTM\t   : 0)\n \t  | ((TARGET_DFP)\t\t    ? RS6000_BTM_DFP\t   : 0)\n \t  | ((TARGET_HARD_FLOAT)\t    ? RS6000_BTM_HARD_FLOAT : 0)\n-\t  | ((TARGET_LONG_DOUBLE_128)\t    ? RS6000_BTM_LDBL128 : 0));\n+\t  | ((TARGET_LONG_DOUBLE_128)\t    ? RS6000_BTM_LDBL128   : 0)\n+\t  | ((TARGET_FLOAT128)\t\t    ? RS6000_BTM_FLOAT128  : 0));\n }\n \n /* Implement TARGET_MD_ASM_ADJUST.  All asm statements are considered\n@@ -14605,6 +14606,8 @@ rs6000_invalid_builtin (enum rs6000_builtins fncode)\n \t   \" -mlong-double-128 options\", name);\n   else if ((fnmask & RS6000_BTM_HARD_FLOAT) != 0)\n     error (\"Builtin function %s requires the -mhard-float option\", name);\n+  else if ((fnmask & RS6000_BTM_FLOAT128) != 0)\n+    error (\"Builtin function %s requires the -mfloat128 options\", name);\n   else\n     error (\"Builtin function %s is not supported with the current options\",\n \t   name);\n@@ -14894,19 +14897,21 @@ rs6000_init_builtins (void)\n      IFmode is the IBM extended 128-bit format that is a pair of doubles.\n      TFmode will be either IEEE 128-bit floating point or the IBM double-double\n      format that uses a pair of doubles, depending on the switches and\n-     defaults.  */\n-  if (TARGET_FLOAT128)\n-    {\n-      ibm128_float_type_node = make_node (REAL_TYPE);\n-      TYPE_PRECISION (ibm128_float_type_node) = 128;\n-      layout_type (ibm128_float_type_node);\n-      SET_TYPE_MODE (ibm128_float_type_node, IFmode);\n+     defaults.  Always create the types even if we don't register the keywords\n+     to allow built-in functions using these types to be created.  */\n+\n+  ibm128_float_type_node = make_node (REAL_TYPE);\n+  TYPE_PRECISION (ibm128_float_type_node) = 128;\n+  layout_type (ibm128_float_type_node);\n+  SET_TYPE_MODE (ibm128_float_type_node, IFmode);\n \n-      ieee128_float_type_node = make_node (REAL_TYPE);\n-      TYPE_PRECISION (ieee128_float_type_node) = 128;\n-      layout_type (ieee128_float_type_node);\n-      SET_TYPE_MODE (ieee128_float_type_node, KFmode);\n+  ieee128_float_type_node = make_node (REAL_TYPE);\n+  TYPE_PRECISION (ieee128_float_type_node) = 128;\n+  layout_type (ieee128_float_type_node);\n+  SET_TYPE_MODE (ieee128_float_type_node, KFmode);\n \n+  if (TARGET_FLOAT128)\n+    {\n       lang_hooks.types.register_builtin_type (ieee128_float_type_node,\n \t\t\t\t\t      \"__float128\");\n \n@@ -34223,6 +34228,7 @@ static struct rs6000_opt_mask const rs6000_builtin_mask_names[] =\n   { \"hard-dfp\",\t\t RS6000_BTM_DFP,\tfalse, false },\n   { \"hard-float\",\t RS6000_BTM_HARD_FLOAT,\tfalse, false },\n   { \"long-double-128\",\t RS6000_BTM_LDBL128,\tfalse, false },\n+  { \"float128\",\t\t RS6000_BTM_FLOAT128,\tfalse, false },\n };\n \n /* Option variables that we want to support inside attribute((target)) and"}, {"sha": "c93500840169a2301e7460d234cbacf49f3cb4aa", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -605,6 +605,7 @@ extern int rs6000_vector_align[];\n #define MASK_DLMZB\t\t\tOPTION_MASK_DLMZB\n #define MASK_EABI\t\t\tOPTION_MASK_EABI\n #define MASK_FPRND\t\t\tOPTION_MASK_FPRND\n+#define MASK_FLOAT128\t\t\tOPTION_MASK_FLOAT128\n #define MASK_P8_FUSION\t\t\tOPTION_MASK_P8_FUSION\n #define MASK_HARD_FLOAT\t\t\tOPTION_MASK_HARD_FLOAT\n #define MASK_HTM\t\t\tOPTION_MASK_HTM\n@@ -2670,6 +2671,7 @@ extern int frame_pointer_needed;\n #define RS6000_BTM_DFP\t\tMASK_DFP\t/* Decimal floating point.  */\n #define RS6000_BTM_HARD_FLOAT\tMASK_SOFT_FLOAT\t/* Hardware floating point.  */\n #define RS6000_BTM_LDBL128\tMASK_MULTIPLE\t/* 128-bit long double.  */\n+#define RS6000_BTM_FLOAT128\tMASK_FLOAT128\t/* IEEE 128-bit fp.  */\n \n #define RS6000_BTM_COMMON\t(RS6000_BTM_ALTIVEC\t\t\t\\\n \t\t\t\t | RS6000_BTM_VSX\t\t\t\\\n@@ -2684,7 +2686,8 @@ extern int frame_pointer_needed;\n \t\t\t\t | RS6000_BTM_CELL\t\t\t\\\n \t\t\t\t | RS6000_BTM_DFP\t\t\t\\\n \t\t\t\t | RS6000_BTM_HARD_FLOAT\t\t\\\n-\t\t\t\t | RS6000_BTM_LDBL128)\n+\t\t\t\t | RS6000_BTM_LDBL128\t\t\t\\\n+\t\t\t\t | RS6000_BTM_FLOAT128)\n \n /* Define builtin enum index.  */\n "}, {"sha": "24cb6e7b2a29fa30cf7114262cbe8c6827ac942f", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -469,6 +469,9 @@\n ; Definitions for 64-bit access to ISA 3.0 (power9) vector\n (define_mode_attr f64_p9  [(DF \"wb\") (DD \"wn\")])\n \n+; Definitions for 128-bit IBM extended double word pack/unpack\n+(define_mode_attr f128_vsx [(TF \"ws\") (IF \"ws\") (TD \"d\")])\n+\n ; These modes do not fit in integer registers in 32-bit mode.\n ; but on e500v2, the gpr are 64 bit registers\n (define_mode_iterator DIFD [DI (DF \"!TARGET_E500_DOUBLE\") DD])\n@@ -13109,16 +13112,16 @@\n (define_expand \"unpack<mode>\"\n   [(set (match_operand:<FP128_64> 0 \"nonimmediate_operand\" \"\")\n \t(unspec:<FP128_64>\n-\t [(match_operand:FMOVE128 1 \"register_operand\" \"\")\n+\t [(match_operand:FMOVE128_FPR 1 \"register_operand\" \"\")\n \t  (match_operand:QI 2 \"const_0_to_1_operand\" \"\")]\n \t UNSPEC_UNPACK_128BIT))]\n   \"FLOAT128_2REG_P (<MODE>mode)\"\n   \"\")\n \n-(define_insn_and_split \"unpack<mode>_dm\"\n-  [(set (match_operand:<FP128_64> 0 \"nonimmediate_operand\" \"=d,m,d,r,m\")\n+(define_insn_and_split \"*unpack<mode>_dm\"\n+  [(set (match_operand:<FP128_64> 0 \"nonimmediate_operand\" \"=<f128_vsx>,m,<f128_vsx>,r,m\")\n \t(unspec:<FP128_64>\n-\t [(match_operand:FMOVE128 1 \"register_operand\" \"d,d,r,d,r\")\n+\t [(match_operand:FMOVE128_FPR 1 \"register_operand\" \"d,d,r,d,r\")\n \t  (match_operand:QI 2 \"const_0_to_1_operand\" \"i,i,i,i,i\")]\n \t UNSPEC_UNPACK_128BIT))]\n   \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE && FLOAT128_2REG_P (<MODE>mode)\"\n@@ -13139,10 +13142,10 @@\n   [(set_attr \"type\" \"fp,fpstore,mffgpr,mftgpr,store\")\n    (set_attr \"length\" \"4\")])\n \n-(define_insn_and_split \"unpack<mode>_nodm\"\n-  [(set (match_operand:<FP128_64> 0 \"nonimmediate_operand\" \"=d,m\")\n+(define_insn_and_split \"*unpack<mode>_nodm\"\n+  [(set (match_operand:<FP128_64> 0 \"nonimmediate_operand\" \"=<f128_vsx>,m\")\n \t(unspec:<FP128_64>\n-\t [(match_operand:FMOVE128 1 \"register_operand\" \"d,d\")\n+\t [(match_operand:FMOVE128_FPR 1 \"register_operand\" \"d,d\")\n \t  (match_operand:QI 2 \"const_0_to_1_operand\" \"i,i\")]\n \t UNSPEC_UNPACK_128BIT))]\n   \"(!TARGET_POWERPC64 || !TARGET_DIRECT_MOVE) && FLOAT128_2REG_P (<MODE>mode)\"\n@@ -13164,30 +13167,31 @@\n    (set_attr \"length\" \"4\")])\n \n (define_insn_and_split \"pack<mode>\"\n-  [(set (match_operand:FMOVE128 0 \"register_operand\" \"=d,&d\")\n-\t(unspec:FMOVE128\n-\t [(match_operand:<FP128_64> 1 \"register_operand\" \"0,d\")\n-\t  (match_operand:<FP128_64> 2 \"register_operand\" \"d,d\")]\n+  [(set (match_operand:FMOVE128_FPR 0 \"register_operand\" \"=&d,&d,&d,&d\")\n+\t(unspec:FMOVE128_FPR\n+\t [(match_operand:<FP128_64> 1 \"input_operand\" \"<f128_vsx>,<f128_vsx>,m,m\")\n+\t  (match_operand:<FP128_64> 2 \"input_operand\" \"<f128_vsx>,m,<f128_vsx>,m\")]\n \t UNSPEC_PACK_128BIT))]\n   \"FLOAT128_2REG_P (<MODE>mode)\"\n-  \"@\n-   fmr %L0,%2\n-   #\"\n-  \"&& reload_completed && REGNO (operands[0]) != REGNO (operands[1])\"\n+  \"#\"\n+  \"&& reload_completed\"\n   [(set (match_dup 3) (match_dup 1))\n    (set (match_dup 4) (match_dup 2))]\n {\n-  unsigned dest_hi = REGNO (operands[0]);\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+  rtx op2 = operands[2];\n+  unsigned dest_hi = REGNO (op0);\n   unsigned dest_lo = dest_hi + 1;\n \n-  gcc_assert (!IN_RANGE (REGNO (operands[1]), dest_hi, dest_lo));\n-  gcc_assert (!IN_RANGE (REGNO (operands[2]), dest_hi, dest_lo));\n+  gcc_assert (!REG_P (op1) || !IN_RANGE (REGNO (op1), dest_hi, dest_lo));\n+  gcc_assert (!REG_P (op2) || !IN_RANGE (REGNO (op2), dest_hi, dest_lo));\n \n   operands[3] = gen_rtx_REG (<FP128_64>mode, dest_hi);\n   operands[4] = gen_rtx_REG (<FP128_64>mode, dest_lo);\n }\n-  [(set_attr \"type\" \"fp,fp\")\n-   (set_attr \"length\" \"4,8\")])\n+  [(set_attr \"type\" \"fp,fpload,fpload,fpload\")\n+   (set_attr \"length\" \"8\")])\n \n (define_insn \"unpack<mode>\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")"}, {"sha": "3579b760fee2a0f63a59035db7b98245e69a726b", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -13538,6 +13538,8 @@ uint64_t __builtin_ppc_get_timebase ();\n unsigned long __builtin_ppc_mftb ();\n double __builtin_unpack_longdouble (long double, int);\n long double __builtin_pack_longdouble (double, double);\n+double __builtin_unpack_ibm128 (__ibm128, int);\n+__ibm128 __builtin_pack_ibm128 (double, double);\n @end smallexample\n \n The @code{vec_rsqrt}, @code{__builtin_rsqrt}, and"}, {"sha": "4219bc176cc7725da09d91dec85aeaf9518bb2c9", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 75, "deletions": 2, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -1,7 +1,80 @@\n+2016-01-13  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\t    Steven Munroe <munroesj@linux.vnet.ibm.com>\n+\t    Tulio Magno Quites Machado Filho <tulioqm@br.ibm.com>\n+\n+\t* config/rs6000/sfp-exceptions.c: New file to provide exception\n+\tsupport for IEEE 128-bit floating point.\n+\n+\t* config/rs6000/float128-hw.c: New file for ISA 3.0 IEEE 128-bit\n+\tfloating point hardware support.\n+\n+\t* config/rs6000/floattikf.c: New files for IEEE 128-bit floating\n+\tpoint conversions.\n+\t* config/rs6000/fixunskfti.c: Likewise.\n+\t* config/rs6000/fixkfti.c: Likewise.\n+\t* config/rs6000/floatuntikf.c: Likewise.\n+\t* config/rs6000/extendkftf2-sw.c: Likewise.\n+\t* config/rs6000/trunctfkf2-sw.c: Likewise.\n+\n+\t* config/rs6000/float128-ifunc.c: New file to pick either IEEE\n+\t128-bit floating point software emulation or use ISA 3.0 hardware\n+\tsupport if it is available.\n+\n+\t* config/rs6000/quad-float128.h: New file to support IEEE 128-bit\n+\tfloating point.\n+\n+\t* config/rs6000/t-float128: New Makefile fragments to enable\n+\tbuilding __float128 emulation support.\n+\t* config/rs6000/t-float128-hw: Likewise.\n+\n+\t* config/rs6000/float128-sed: New file to convert TF names to KF\n+\tnames for PowerPC IEEE 128-bit floating point support.\n+\n+\t* config/rs6000/sfp-machine.h (_FP_W_TYPE_SIZE): Use 64-bit types\n+\twhen building on 64-bit systems, or when VSX is enabled.\n+\t(_FP_W_TYPE): Likewise.\n+\t(_FP_WS_TYPE): Likewise.\n+\t(_FP_I_TYPE): Likewise.\n+\t(TItype): Define on 64-bit systems.\n+\t(UTItype): Likewise.\n+\t(TI_BITS): Likewise.\n+\t(_FP_MUL_MEAT_D): Add support for using 64-bit types.\n+\t(_FP_MUL_MEAT_Q): Likewise.\n+\t(_FP_DIV_MEAT_D): Likewise.\n+\t(_FP_DIV_MEAT_Q): Likewise.\n+\t(_FP_NANFRAC_D): Likewise.\n+\t(_FP_NANFRAC_Q): Likewise.\n+\t(ISA_BIT): Add exception support if we are being compiled on a\n+\tmachine with hardware floating point support to build the IEEE\n+\t128-bit emulation functions.\n+\t(FP_EX_INVALID): Likewise.\n+\t(FP_EX_OVERFLOW): Likewise.\n+\t(FP_EX_UNDERFLOW): Likewise.\n+\t(FP_EX_DIVZERO): Likewise.\n+\t(FP_EX_INEXACT): Likewise.\n+\t(FP_EX_ALL): Likewise.\n+\t(__sfp_handle_exceptions): Likewise.\n+\t(FP_HANDLE_EXCEPTIONS): Likewise.\n+\t(FP_RND_NEAREST): Likewise.\n+\t(FP_RND_ZERO): Likewise.\n+\t(FP_RND_PINF): Likewise.\n+\t(FP_RND_MINF): Likewise.\n+\t(FP_RND_MASK): Likewise.\n+\t(_FP_DECL_EX): Likewise.\n+\t(FP_INIT_ROUNDMODE): Likewise.\n+\t(FP_ROUNDMODE): Likewise.\n+\n+\t* configure.ac (powerpc*-*-linux*): Check whether the PowerPC\n+\tcompiler can do __float128.\n+\t* configure: Regenerate.\n+\n+\t* libgcc/config.host (powerpc*-*-linux*): If compiler can compile\n+\tVSX code, enable IEEE 128-bit floating point.\n+\n 2016-01-05  Olivier Hainque  <hainque@adacore.com>\n \n \t* config/rs6000/aix-unwind.h (ucontext_for): Handle AIX 7.1\n-\tspecificities. \n+\tspecificities.\n \n 2016-01-04  Jakub Jelinek  <jakub@redhat.com>\n \n@@ -10,7 +83,7 @@\n 2015-12-18  Andris Pavenis  <andris.pavenis@iki.fi>\n \n \t* config.host: Add *-*-msdosdjgpp to lists of i[34567]86-*-*\n-\tsoft-fp targets \n+\tsoft-fp targets.\n \n 2015-12-16  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n "}, {"sha": "d8efd82d2132a0ded396b09e352aa7e36812130b", "filename": "libgcc/config.host", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -1063,6 +1063,15 @@ powerpc*-*-linux*)\n \t\texit 1\n \t\t;;\n \tesac\n+\n+\tif test $libgcc_cv_powerpc_float128 = yes; then\n+\t\ttmake_file=\"${tmake_file} rs6000/t-float128\"\n+\tfi\n+\n+\tif test $libgcc_cv_powerpc_float128_hw = yes; then\n+\t\ttmake_file=\"${tmake_file} rs6000/t-float128-hw\"\n+\tfi\n+\n \textra_parts=\"$extra_parts ecrti.o ecrtn.o ncrti.o ncrtn.o\"\n \tmd_unwind_header=rs6000/linux-unwind.h\n \t;;"}, {"sha": "2418a392c56e0fd2b2438b94d13617f9031994fa", "filename": "libgcc/config/rs6000/extendkftf2-sw.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Fextendkftf2-sw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Fextendkftf2-sw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Fextendkftf2-sw.c?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -0,0 +1,49 @@\n+/* Software IEEE 128-bit floating-point emulation for PowerPC.\n+\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Michael Meissner (meissner@linux.vnet.ibm.com)\n+   Code is based on the main soft-fp library written by:\n+\tRichard Henderson (rth@cygnus.com) and\n+\tJakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Convert IEEE 128-bit floating point to IBM long double.  */\n+\n+#ifdef __FLOAT128_HARDWARE__\n+#error \"This module must not be compiled with IEEE 128-bit hardware support\"\n+#endif\n+\n+#include \"soft-fp.h\"\n+#include \"quad-float128.h\"\n+\n+__ibm128\n+__extendkftf2_sw (__float128 value)\n+{\n+  __ibm128 ret;\n+\n+  CVT_FLOAT128_TO_IBM128 (ret, value);\n+  return ret;\n+}"}, {"sha": "80e10f078c0678798356ddf10b9a57d5c945c796", "filename": "libgcc/config/rs6000/fixkfti.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Ffixkfti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Ffixkfti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ffixkfti.c?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -0,0 +1,51 @@\n+/* Software floating-point emulation, convert IEEE quad to 128bit signed\n+   integer.\n+\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Steven Munroe (munroesj@linux.vnet.ibm.com)\n+   Code is based on the main soft-fp library written by:\n+   \t   Uros Bizjak (ubizjak@gmail.com).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifdef _ARCH_PPC64\n+#include \"soft-fp.h\"\n+#include \"quad-float128.h\"\n+\n+TItype\n+__fixkfti (TFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_Q (A);\n+  UTItype r;\n+\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_Q (A, a);\n+  FP_TO_INT_Q (r, A, TI_BITS, 1);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}\n+#endif"}, {"sha": "56c36716120f0b3d0a1ab05e05f8c4ec8e2557c7", "filename": "libgcc/config/rs6000/fixunskfti.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Ffixunskfti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Ffixunskfti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ffixunskfti.c?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -0,0 +1,51 @@\n+/* Software floating-point emulation, convert IEEE quad to 128bit unsigned\n+   integer.\n+\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Steven Munroe (munroesj@linux.vnet.ibm.com)\n+   Code is based on the main soft-fp library written by:\n+   \t   Uros Bizjak (ubizjak@gmail.com).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifdef _ARCH_PPC64\n+#include \"soft-fp.h\"\n+#include \"quad-float128.h\"\n+\n+UTItype\n+__fixunskfti (TFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_Q (A);\n+  UTItype r;\n+\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_Q (A, a);\n+  FP_TO_INT_Q (r, A, TI_BITS, 0);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}\n+#endif"}, {"sha": "da2fbbcafd1c83f345ca153b6dea968d4f1adb03", "filename": "libgcc/config/rs6000/float128-hw.c", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Ffloat128-hw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Ffloat128-hw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ffloat128-hw.c?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -0,0 +1,207 @@\n+/* Automatic switching between software and hardware IEEE 128-bit\n+   floating-point emulation for PowerPC.\n+\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Michael Meissner (meissner@linux.vnet.ibm.com)\n+   Code is based on the main soft-fp library written by:\n+\tRichard Henderson (rth@cygnus.com) and\n+\tJakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <soft-fp.h>\n+#include <quad-float128.h>\n+\n+#ifndef __FLOAT128_HARDWARE__\n+#error \"This module must be compiled with IEEE 128-bit hardware support\"\n+#endif\n+\n+TFtype\n+__addkf3_hw (TFtype a, TFtype b)\n+{\n+  return a + b;\n+}\n+\n+TFtype\n+__subkf3_hw (TFtype a, TFtype b)\n+{\n+  return a - b;\n+}\n+\n+TFtype\n+__mulkf3_hw (TFtype a, TFtype b)\n+{\n+  return a * b;\n+}\n+\n+TFtype\n+__divkf3_hw (TFtype a, TFtype b)\n+{\n+  return a / b;\n+}\n+\n+TFtype\n+__negkf2_hw (TFtype a)\n+{\n+  return -a;\n+}\n+\n+TFtype\n+__floatsikf_hw (SItype_ppc a)\n+{\n+  return (TFtype) a;\n+}\n+\n+TFtype\n+__floatunsikf_hw (USItype_ppc a)\n+{\n+  return (TFtype) a;\n+}\n+\n+TFtype\n+__floatdikf_hw (DItype_ppc a)\n+{\n+  return (TFtype) a;\n+}\n+\n+TFtype\n+__floatundikf_hw (UDItype_ppc a)\n+{\n+  return (TFtype) a;\n+}\n+\n+SItype_ppc\n+__fixkfsi_hw (TFtype a)\n+{\n+  return (SItype_ppc) a;\n+}\n+\n+USItype_ppc\n+__fixunskfsi_hw (TFtype a)\n+{\n+  return (USItype_ppc) a;\n+}\n+\n+DItype_ppc\n+__fixkfdi_hw (TFtype a)\n+{\n+  return (DItype_ppc) a;\n+}\n+\n+UDItype_ppc\n+__fixunskfdi_hw (TFtype a)\n+{\n+  return (UDItype_ppc) a;\n+}\n+\n+TFtype\n+__extendsfkf2_hw (float a)\n+{\n+  return (TFtype) a;\n+}\n+\n+TFtype\n+__extenddfkf2_hw (double a)\n+{\n+  return (TFtype) a;\n+}\n+\n+float\n+__trunckfsf2_hw (TFtype a)\n+{\n+  return (float) a;\n+}\n+\n+double\n+__trunckfdf2_hw (TFtype a)\n+{\n+  return (double) a;\n+}\n+\n+/* __eqkf2 returns 0 if equal, or 1 if not equal or NaN.  */\n+CMPtype\n+__eqkf2_hw (TFtype a, TFtype b)\n+{\n+  return (a != b);\n+}\n+\n+/* __gekf2 returns -1 if a < b, 0 if a == b, +1 if a > b, or -2 if NaN.  */\n+CMPtype\n+__gekf2_hw (TFtype a, TFtype b)\n+{\n+  if (a < b)\n+    return -1;\n+\n+  else if (__builtin_isunordered (a, b))\n+    return -2;\n+\n+  else if (a == b)\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* __lekf2 returns -1 if a < b, 0 if a == b, +1 if a > b, or +2 if NaN.  */\n+CMPtype\n+__lekf2_hw (TFtype a, TFtype b)\n+{\n+  if (a < b)\n+    return -1;\n+\n+  else if (__builtin_isunordered (a, b))\n+    return 2;\n+\n+  else if (a == b)\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* __unordkf2 returns 1 if NaN or 0 otherwise.  */\n+CMPtype\n+__unordkf2_hw (TFtype a, TFtype b)\n+{\n+  return (__builtin_isunordered (a, b)) ? 1 : 0;\n+}\n+\n+/* Convert __float128 to __ibm128.  */\n+__ibm128\n+__extendkftf2_hw (TFtype value)\n+{\n+  __ibm128 ret;\n+\n+  CVT_FLOAT128_TO_IBM128 (ret, value);\n+  return ret;\n+}\n+\n+/* Convert __ibm128 to __float128.  */\n+TFtype\n+__trunctfkf2_hw (__ibm128 value)\n+{\n+  TFtype ret;\n+\n+  CVT_IBM128_TO_FLOAT128 (ret, value);\n+  return ret;\n+}"}, {"sha": "6e14608d3a7d3856754820698e93f94cbea05c9e", "filename": "libgcc/config/rs6000/float128-ifunc.c", "status": "added", "additions": 358, "deletions": 0, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Ffloat128-ifunc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Ffloat128-ifunc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ffloat128-ifunc.c?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -0,0 +1,358 @@\n+/* Automatic switching between software and hardware IEEE 128-bit\n+   floating-point emulation for PowerPC.\n+\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Michael Meissner (meissner@linux.vnet.ibm.com)\n+   Code is based on the main soft-fp library written by:\n+\tRichard Henderson (rth@cygnus.com) and\n+\tJakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <soft-fp.h>\n+#include <quad-float128.h>\n+#include <string.h>\n+#include <stdlib.h>\n+#include <ctype.h>\n+\n+#ifdef FLOAT128_HW_INSNS\n+#include <sys/auxv.h>\n+\n+/* Use the namespace clean version of getauxval.  However, not all versions of\n+   sys/auxv.h declare it, so declare it here.  This code is intended to be\n+   temporary until a suitable version of __builtin_cpu_supports is added that\n+   allows us to tell quickly if the machine supports IEEE 128-bit hardware.  */\n+extern unsigned long __getauxval (unsigned long);\n+\n+static int\n+have_ieee_hw_p (void)\n+{\n+  static int ieee_hw_p = -1;\n+\n+  if (ieee_hw_p < 0)\n+    {\n+      char *p = (char *) __getauxval (AT_PLATFORM);\n+\n+      ieee_hw_p = 0;\n+\n+      /* Don't use atoi/strtol/strncmp/etc.  These may require the normal\n+\t environment to be setup to set errno to 0, and the ifunc resolvers run\n+\t before the whole glibc environment is initialized.  */\n+      if (p && p[0] == 'p' && p[1] == 'o' && p[2] == 'w' && p[3] == 'e'\n+\t  && p[4] == 'r')\n+\t{\n+\t  long n = 0;\n+\t  char ch;\n+\n+\t  p += 5;\n+\t  while ((ch = *p++) >= '0' && (ch <= '9'))\n+\t    n = (n * 10) + (ch - '0');\n+\n+\t  if (n >= 9)\n+\t    ieee_hw_p = 1;\n+\t}\n+    }\n+\n+  return ieee_hw_p;\n+}\n+\n+#define SW_OR_HW(SW, HW) (have_ieee_hw_p () ? HW : SW)\n+#else\n+#define SW_OR_HW(SW, HW) (SW)\n+#endif\t/* ISA 3.0 hardware available.  */\n+\n+/* Resolvers.  */\n+\n+/* We do not provide ifunc resolvers for __fixkfti, __fixunskfti, __floattikf,\n+   and __floatuntikf.  There is no ISA 3.0 instruction that converts between\n+   128-bit integer types and 128-bit IEEE floating point, or vice versa.  So\n+   use the emulator functions for these conversions.  */\n+\n+static void *__addkf3_resolve (void);\n+static void *__subkf3_resolve (void);\n+static void *__mulkf3_resolve (void);\n+static void *__divkf3_resolve (void);\n+static void *__negkf2_resolve (void);\n+static void *__eqkf2_resolve (void);\n+static void *__nekf2_resolve (void);\n+static void *__gekf2_resolve (void);\n+static void *__gtkf2_resolve (void);\n+static void *__lekf2_resolve (void);\n+static void *__ltkf2_resolve (void);\n+static void *__unordkf2_resolve (void);\n+static void *__extendsfkf2_resolve (void);\n+static void *__extenddfkf2_resolve (void);\n+static void *__trunckfsf2_resolve (void);\n+static void *__trunckfdf2_resolve (void);\n+static void *__fixkfsi_resolve (void);\n+static void *__fixkfdi_resolve (void);\n+static void *__fixunskfsi_resolve (void);\n+static void *__fixunskfdi_resolve (void);\n+static void *__floatsikf_resolve (void);\n+static void *__floatdikf_resolve (void);\n+static void *__floatunsikf_resolve (void);\n+static void *__floatundikf_resolve (void);\n+static void *__extendkftf2_resolve (void);\n+static void *__trunctfkf2_resolve (void);\n+\n+static void *\n+__addkf3_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__addkf3_sw, __addkf3_hw);\n+}\n+\n+static void *\n+__subkf3_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__subkf3_sw, __subkf3_hw);\n+}\n+\n+static void *\n+__mulkf3_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__mulkf3_sw, __mulkf3_hw);\n+}\n+\n+static void *\n+__divkf3_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__divkf3_sw, __divkf3_hw);\n+}\n+\n+static void *\n+__negkf2_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__negkf2_sw, __negkf2_hw);\n+}\n+\n+static void *\n+__floatsikf_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__floatsikf_sw, __floatsikf_hw);\n+}\n+\n+static void *\n+__floatdikf_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__floatdikf_sw, __floatdikf_hw);\n+}\n+\n+static void *\n+__floatunsikf_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__floatunsikf_sw, __floatunsikf_hw);\n+}\n+\n+static void *\n+__floatundikf_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__floatundikf_sw, __floatundikf_hw);\n+}\n+\n+static void *\n+__fixkfsi_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__fixkfsi_sw, __fixkfsi_hw);\n+}\n+\n+static void *\n+__fixkfdi_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__fixkfdi_sw, __fixkfdi_hw);\n+}\n+\n+static void *\n+__fixunskfsi_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__fixunskfsi_sw, __fixunskfsi_hw);\n+}\n+\n+static void *\n+__fixunskfdi_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__fixunskfdi_sw, __fixunskfdi_hw);\n+}\n+\n+static void *\n+__extendsfkf2_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__extendsfkf2_sw, __extendsfkf2_hw);\n+}\n+\n+static void *\n+__extenddfkf2_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__extenddfkf2_sw, __extenddfkf2_hw);\n+}\n+\n+static void *\n+__trunckfsf2_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__trunckfsf2_sw, __trunckfsf2_hw);\n+}\n+\n+static void *\n+__trunckfdf2_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__trunckfdf2_sw, __trunckfdf2_hw);\n+}\n+\n+static void *\n+__extendkftf2_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__extendkftf2_sw, __extendkftf2_hw);\n+}\n+\n+static void *\n+__trunctfkf2_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__trunctfkf2_sw, __trunctfkf2_hw);\n+}\n+\n+static void *\n+__eqkf2_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__eqkf2_sw, __eqkf2_hw);\n+}\n+\n+static void *\n+__gekf2_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__gekf2_sw, __gekf2_hw);\n+}\n+\n+static void *\n+__lekf2_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__lekf2_sw, __lekf2_hw);\n+}\n+\n+static void *\n+__unordkf2_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__unordkf2_sw, __unordkf2_hw);\n+}\n+\n+/* Resolve __nekf2, __gtkf2, __ltkf2 like __eqkf2, __gekf2, and __lekf2, since\n+   the functions return the same values.  */\n+\n+static void *\n+__nekf2_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__eqkf2_sw, __eqkf2_hw);\n+}\n+\n+static void *\n+__gtkf2_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__gekf2_sw, __gekf2_hw);\n+}\n+\n+static void *\n+__ltkf2_resolve (void)\n+{\n+  return (void *) SW_OR_HW (__lekf2_sw, __lekf2_hw);\n+}\n+\n+\n+\f\n+/* Ifunc definitions.  */\n+TFtype __addkf3 (TFtype, TFtype)\n+  __attribute__ ((__ifunc__ (\"__addkf3_resolve\")));\n+\n+TFtype __subkf3 (TFtype, TFtype)\n+  __attribute__ ((__ifunc__ (\"__subkf3_resolve\")));\n+\n+TFtype __mulkf3 (TFtype, TFtype)\n+  __attribute__ ((__ifunc__ (\"__mulkf3_resolve\")));\n+\n+TFtype __divkf3 (TFtype, TFtype)\n+  __attribute__ ((__ifunc__ (\"__divkf3_resolve\")));\n+\n+TFtype __negkf2 (TFtype)\n+  __attribute__ ((__ifunc__ (\"__negkf2_resolve\")));\n+\n+CMPtype __eqkf2 (TFtype, TFtype)\n+  __attribute__ ((__ifunc__ (\"__eqkf2_resolve\")));\n+\n+CMPtype __nekf2 (TFtype, TFtype)\n+  __attribute__ ((__ifunc__ (\"__nekf2_resolve\")));\n+\n+CMPtype __gekf2 (TFtype, TFtype)\n+  __attribute__ ((__ifunc__ (\"__gekf2_resolve\")));\n+\n+CMPtype __gtkf2 (TFtype, TFtype)\n+  __attribute__ ((__ifunc__ (\"__gtkf2_resolve\")));\n+\n+CMPtype __lekf2 (TFtype, TFtype)\n+  __attribute__ ((__ifunc__ (\"__lekf2_resolve\")));\n+\n+CMPtype __ltkf2 (TFtype, TFtype)\n+  __attribute__ ((__ifunc__ (\"__ltkf2_resolve\")));\n+\n+CMPtype __unordkf2 (TFtype, TFtype)\n+  __attribute__ ((__ifunc__ (\"__unordkf2_resolve\")));\n+\n+TFtype __extendsfkf2 (float)\n+  __attribute__ ((__ifunc__ (\"__extendsfkf2_resolve\")));\n+\n+TFtype __extenddfkf2 (double)\n+  __attribute__ ((__ifunc__ (\"__extenddfkf2_resolve\")));\n+\n+float __trunckfsf2 (TFtype)\n+  __attribute__ ((__ifunc__ (\"__trunckfsf2_resolve\")));\n+\n+double __trunckfdf2 (TFtype)\n+  __attribute__ ((__ifunc__ (\"__trunckfdf2_resolve\")));\n+\n+SItype_ppc __fixkfsi (TFtype)\n+  __attribute__ ((__ifunc__ (\"__fixkfsi_resolve\")));\n+\n+DItype_ppc __fixkfdi (TFtype)\n+  __attribute__ ((__ifunc__ (\"__fixkfdi_resolve\")));\n+\n+USItype_ppc __fixunskfsi (TFtype)\n+  __attribute__ ((__ifunc__ (\"__fixunskfsi_resolve\")));\n+\n+UDItype_ppc __fixunskfdi (TFtype)\n+  __attribute__ ((__ifunc__ (\"__fixunskfdi_resolve\")));\n+\n+TFtype __floatsikf (SItype_ppc)\n+  __attribute__ ((__ifunc__ (\"__floatsikf_resolve\")));\n+\n+TFtype __floatdikf (DItype_ppc)\n+  __attribute__ ((__ifunc__ (\"__floatdikf_resolve\")));\n+\n+TFtype __floatunsikf (USItype_ppc)\n+  __attribute__ ((__ifunc__ (\"__floatunsikf_resolve\")));\n+\n+TFtype __floatundikf (UDItype_ppc)\n+  __attribute__ ((__ifunc__ (\"__floatundikf_resolve\")));\n+\n+__ibm128 __extendkftf2 (TFtype)\n+  __attribute__ ((__ifunc__ (\"__extendkftf2_resolve\")));\n+\n+TFtype __trunctfkf2 (__ibm128)\n+  __attribute__ ((__ifunc__ (\"__trunctfkf2_resolve\")));"}, {"sha": "acf36b0c17dd9e1cbd6a5899469fc7559a7d02a8", "filename": "libgcc/config/rs6000/float128-sed", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Ffloat128-sed", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Ffloat128-sed", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ffloat128-sed?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -0,0 +1,25 @@\n+s/__addtf3/__addkf3_sw/g\n+s/__divtf3/__divkf3_sw/g\n+s/__eqtf2/__eqkf2_sw/g\n+s/__extenddftf2/__extenddfkf2_sw/g\n+s/__extendsftf2/__extendsfkf2_sw/g\n+s/__fixtfdi/__fixkfdi_sw/g\n+s/__fixtfsi/__fixkfsi_sw/g\n+s/__fixunstfdi/__fixunskfdi_sw/g\n+s/__fixunstfsi/__fixunskfsi_sw/g\n+s/__floatditf/__floatdikf_sw/g\n+s/__floatsitf/__floatsikf_sw/g\n+s/__floatunditf/__floatundikf_sw/g\n+s/__floatunsitf/__floatunsikf_sw/g\n+s/__getf2/__gekf2_sw/g\n+s/__gttf2/__gtkf2_sw/g\n+s/__letf2/__lekf2_sw/g\n+s/__lttf2/__ltkf2_sw/g\n+s/__multf3/__mulkf3_sw/g\n+s/__negtf2/__negkf2_sw/g\n+s/__netf2/__nekf2_sw/g\n+s/quad[.]h/quad-float128.h/g\n+s/__subtf3/__subkf3_sw/g\n+s/__trunctfdf2/__trunckfdf2_sw/g\n+s/__trunctfsf2/__trunckfsf2_sw/g\n+s/__unordtf2/__unordkf2_sw/g"}, {"sha": "4c652308158994233e9daa618a3203ef9883fa0c", "filename": "libgcc/config/rs6000/floattikf.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Ffloattikf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Ffloattikf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ffloattikf.c?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -0,0 +1,51 @@\n+/* Software floating-point emulation, convert a 128bit signed integer to IEEE\n+   quad.\n+\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Steven Munroe (munroesj@linux.vnet.ibm.com)\n+   Code is based on the main soft-fp library written by:\n+   \t   Uros Bizjak (ubizjak@gmail.com).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifdef _ARCH_PPC64\n+#include \"soft-fp.h\"\n+#include \"quad-float128.h\"\n+\n+TFtype\n+__floattikf (TItype i)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_Q (A);\n+  TFtype a;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_FROM_INT_Q (A, i, TI_BITS, UTItype);\n+  FP_PACK_RAW_Q (a, A);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return a;\n+}\n+#endif"}, {"sha": "6dabf7b33bd8af3ee909c8541b453a8914d1b56e", "filename": "libgcc/config/rs6000/floatuntikf.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Ffloatuntikf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Ffloatuntikf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ffloatuntikf.c?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -0,0 +1,51 @@\n+/* Software floating-point emulation, convert a 128bit unsigned integer to IEEE\n+   quad.\n+\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Steven Munroe (munroesj@linux.vnet.ibm.com)\n+   Code is based on the main soft-fp library written by:\n+   \t   Uros Bizjak (ubizjak@gmail.com).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifdef _ARCH_PPC64\n+#include \"soft-fp.h\"\n+#include \"quad-float128.h\"\n+\n+TFtype\n+__floatuntikf (UTItype i)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_Q (A);\n+  TFtype a;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_FROM_INT_Q (A, i, TI_BITS, UTItype);\n+  FP_PACK_RAW_Q (a, A);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return a;\n+}\n+#endif"}, {"sha": "423cb05d9ea54e619a89169876d0a033626e9f86", "filename": "libgcc/config/rs6000/quad-float128.h", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Fquad-float128.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Fquad-float128.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Fquad-float128.h?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -0,0 +1,203 @@\n+/* Software floating-point emulation.\n+   Definitions for IEEE Quad Precision on the PowerPC.\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Michael Meissner (meissner@linux.vnet.ibm.com).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* quad.h defines the TFtype type by:\n+   typedef float TFtype __attribute__ ((mode (TF)));\n+\n+   This define forces it to use KFmode (aka, ieee 128-bit floating point).  */\n+#define TF KF\n+\n+/* Force the use of the VSX instruction set.  */\n+#if defined(_ARCH_PPC) && (!defined(__VSX__) || !defined(__FLOAT128__))\n+#pragma GCC target (\"vsx,float128\")\n+#endif\n+\n+#include <quad.h>\n+\n+/* Add prototypes of the library functions created.  In case the appropriate\n+   int/long types are not declared in scope by the time quad.h is included,\n+   provide our own version.  */\n+typedef int\t SItype_ppc  __attribute__ ((__mode__ (__SI__)));\n+typedef int\t DItype_ppc  __attribute__ ((__mode__ (__DI__)));\n+typedef unsigned USItype_ppc __attribute__ ((__mode__ (__SI__)));\n+typedef unsigned UDItype_ppc __attribute__ ((__mode__ (__DI__)));\n+\n+#ifdef _ARCH_PPC64\n+typedef int\t TItype_ppc  __attribute__ ((__mode__ (__TI__)));\n+typedef unsigned UTItype_ppc __attribute__ ((__mode__ (__TI__)));\n+#endif\n+\n+/* Software emulation functions.  */\n+extern TFtype __addkf3_sw (TFtype, TFtype);\n+extern TFtype __subkf3_sw (TFtype, TFtype);\n+extern TFtype __mulkf3_sw (TFtype, TFtype);\n+extern TFtype __divkf3_sw (TFtype, TFtype);\n+extern TFtype __negkf2_sw (TFtype);\n+extern CMPtype __eqkf2_sw (TFtype, TFtype);\n+extern CMPtype __gekf2_sw (TFtype, TFtype);\n+extern CMPtype __lekf2_sw (TFtype, TFtype);\n+extern CMPtype __unordkf2_sw (TFtype, TFtype);\n+extern TFtype __extendsfkf2_sw (float);\n+extern TFtype __extenddfkf2_sw (double);\n+extern float __trunckfsf2_sw (TFtype);\n+extern double __trunckfdf2_sw (TFtype);\n+extern SItype_ppc __fixkfsi_sw (TFtype);\n+extern DItype_ppc __fixkfdi_sw (TFtype);\n+extern USItype_ppc __fixunskfsi_sw (TFtype);\n+extern UDItype_ppc __fixunskfdi_sw (TFtype);\n+extern TFtype __floatsikf_sw (SItype_ppc);\n+extern TFtype __floatdikf_sw (DItype_ppc);\n+extern TFtype __floatunsikf_sw (USItype_ppc);\n+extern TFtype __floatundikf_sw (UDItype_ppc);\n+extern __ibm128 __extendkftf2_sw (TFtype);\n+extern TFtype __trunctfkf2_sw (__ibm128);\n+\n+#ifdef _ARCH_PPC64\n+/* We do not provide ifunc resolvers for __fixkfti, __fixunskfti, __floattikf,\n+   and __floatuntikf.  There is no ISA 3.0 instruction that converts between\n+   128-bit integer types and 128-bit IEEE floating point, or vice versa.  So\n+   use the emulator functions for these conversions.  */\n+\n+extern TItype_ppc __fixkfti (TFtype);\n+extern UTItype_ppc __fixunskfti (TFtype);\n+extern TFtype __floattikf (TItype_ppc);\n+extern TFtype __floatuntikf (UTItype_ppc);\n+#endif\n+\n+/* Functions using the ISA 3.0 hardware support.  If the code is compiled with\n+   -mcpu=power9, it will not use these functions, but if it was compiled with\n+   -mcpu=power7 or -mcpu=power8 and run on a ISA 3.0 system, it will use the\n+   hardware instruction.  */\n+extern TFtype __addkf3_hw (TFtype, TFtype);\n+extern TFtype __subkf3_hw (TFtype, TFtype);\n+extern TFtype __mulkf3_hw (TFtype, TFtype);\n+extern TFtype __divkf3_hw (TFtype, TFtype);\n+extern TFtype __negkf2_hw (TFtype);\n+extern CMPtype __eqkf2_hw (TFtype, TFtype);\n+extern CMPtype __gekf2_hw (TFtype, TFtype);\n+extern CMPtype __lekf2_hw (TFtype, TFtype);\n+extern CMPtype __unordkf2_hw (TFtype, TFtype);\n+extern TFtype __extendsfkf2_hw (float);\n+extern TFtype __extenddfkf2_hw (double);\n+extern float __trunckfsf2_hw (TFtype);\n+extern double __trunckfdf2_hw (TFtype);\n+extern SItype_ppc __fixkfsi_hw (TFtype);\n+extern DItype_ppc __fixkfdi_hw (TFtype);\n+extern USItype_ppc __fixunskfsi_hw (TFtype);\n+extern UDItype_ppc __fixunskfdi_hw (TFtype);\n+extern TFtype __floatsikf_hw (SItype_ppc);\n+extern TFtype __floatdikf_hw (DItype_ppc);\n+extern TFtype __floatunsikf_hw (USItype_ppc);\n+extern TFtype __floatundikf_hw (UDItype_ppc);\n+extern __ibm128 __extendkftf2_hw (TFtype);\n+extern TFtype __trunctfkf2_hw (__ibm128);\n+\n+/* Ifunc function declarations, to automatically switch between software\n+   emulation and hardware support.  */\n+extern TFtype __addkf3 (TFtype, TFtype);\n+extern TFtype __subkf3 (TFtype, TFtype);\n+extern TFtype __mulkf3 (TFtype, TFtype);\n+extern TFtype __divkf3 (TFtype, TFtype);\n+extern TFtype __negkf2 (TFtype);\n+extern CMPtype __eqkf2 (TFtype, TFtype);\n+extern CMPtype __nekf2 (TFtype, TFtype);\n+extern CMPtype __gekf2 (TFtype, TFtype);\n+extern CMPtype __gtkf2 (TFtype, TFtype);\n+extern CMPtype __lekf2 (TFtype, TFtype);\n+extern CMPtype __ltkf2 (TFtype, TFtype);\n+extern CMPtype __unordkf2 (TFtype, TFtype);\n+extern TFtype __extendsfkf2 (float);\n+extern TFtype __extenddfkf2 (double);\n+extern float __trunckfsf2 (TFtype);\n+extern double __trunckfdf2 (TFtype);\n+extern SItype_ppc __fixkfsi (TFtype);\n+extern DItype_ppc __fixkfdi (TFtype);\n+extern USItype_ppc __fixunskfsi (TFtype);\n+extern UDItype_ppc __fixunskfdi (TFtype);\n+extern TFtype __floatsikf (SItype_ppc);\n+extern TFtype __floatdikf (DItype_ppc);\n+extern TFtype __floatunsikf (USItype_ppc);\n+extern TFtype __floatundikf (UDItype_ppc);\n+extern __ibm128 __extendkftf2 (TFtype);\n+extern TFtype __trunctfkf2 (__ibm128);\n+\n+#ifdef __LITTLE_ENDIAN__\n+#define HIGH_WORD\t1\n+#define LOW_WORD\t0\n+#else\n+#define HIGH_WORD\t0\n+#define LOW_WORD\t1\n+#endif\n+\n+/* Implementation of conversions between __ibm128 and __float128, to allow the\n+   same code to be used on systems with IEEE 128-bit emulation and with IEEE\n+   128-bit hardware support.  */\n+\n+#define CVT_FLOAT128_TO_IBM128(RESULT, VALUE)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  double __high, __low;\t\t\t\t\t\t\t\\\n+  __float128 __value = (VALUE);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  __high = (double) __value;\t\t\t\t\t\t\\\n+  if (__builtin_isnan (__high) || __builtin_isinf (__high))\t\t\\\n+    __low = 0.0;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      double __high_temp;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      __low = (double) (__value - (__float128) __high);\t\t\t\\\n+      /* Renormalize low/high and move them into canonical IBM long\t\\\n+\t double form.  */\t\t\t\t\t\t\\\n+      __high_temp = __high + __low;\t\t\t\t\t\\\n+      __low = (__high - __high_temp) + __low;\t\t\t\t\\\n+      __high = __high_temp;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  RESULT = __builtin_pack_ibm128 (__high, __low);\t\t\t\\\n+}\n+\n+#define CVT_IBM128_TO_FLOAT128(RESULT, VALUE)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  __ibm128 __value = (VALUE);\t\t\t\t\t\t\\\n+  double __high = __builtin_unpack_ibm128 (__value, HIGH_WORD);\t\t\\\n+  double __low = __builtin_unpack_ibm128 (__value, LOW_WORD);\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* Handle the special cases of NAN and infinity.  */\t\t\t\\\n+  if (__builtin_isnan (__high) || __builtin_isinf (__high))\t\t\\\n+    RESULT = (__float128) __high;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* If low is 0.0, there no need to do the add.  In addition,\t\t\\\n+     avoiding the add produces the correct sign if high is -0.0.  */\t\\\n+  else if (__low == 0.0)\t\t\t\t\t\t\\\n+    RESULT = (__float128) __high;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    RESULT = ((__float128) __high) + ((__float128) __low);\t\t\\\n+}"}, {"sha": "efd21da53205d7f677e694b5970826a5cf6ea5c3", "filename": "libgcc/config/rs6000/sfp-exceptions.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Fsfp-exceptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Fsfp-exceptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Fsfp-exceptions.c?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -0,0 +1,72 @@\n+/* Copyright (C) 2016 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+\n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"sfp-machine.h\"\n+\n+/* Only provide exception support if we have hardware floating point and we can\n+   execute the mtfsf instruction.  This would only be true if we are using the\n+   emulation routines for IEEE 128-bit floating point on pre-ISA 3.0 machines\n+   without the IEEE 128-bit floating point support.  */\n+\n+#ifndef __NO_FPRS__ \n+\n+void\n+__sfp_handle_exceptions (int _fex)\n+{\n+  const double fp_max = __DBL_MAX__;\n+  const double fp_min = __DBL_MIN__;\n+  const double fp_zero = (double) 0.0;\n+  const double fp_one = 1.0;\n+  double tmp;\n+\n+  if (_fex & FP_EX_INVALID)\n+    {\n+      __asm__ __volatile__ (\"fdiv %0, %1, %1\"\n+\t\t\t    : \"=f\" (tmp)\n+\t\t\t    : \"f\" (fp_zero));\n+    }\n+  if (_fex & FP_EX_DIVZERO)\n+    {\n+      __asm__ __volatile__ (\"fdiv %0, %1, %2\"\n+\t\t\t    : \"=f\" (tmp)\n+\t\t\t    : \"f\" (fp_one), \"f\" (fp_zero));\n+    }\n+  if (_fex & FP_EX_OVERFLOW)\n+    {\n+      __asm__ __volatile__ (\"fadd %0, %1, %1\"\n+\t\t\t    : \"=f\" (tmp)\n+\t\t\t    : \"f\" (fp_max));\n+    }\n+  if (_fex & FP_EX_UNDERFLOW)\n+    {\n+      __asm__ __volatile__ (\"fmul %0, %1, %1\"\n+\t\t\t    : \"=f\" (tmp)\n+\t\t\t    : \"f\" (fp_min));\n+    }\n+  if (_fex & FP_EX_INEXACT)\n+    {\n+      __asm__ __volatile__ (\"fsub %0, %1, %2\"\n+\t\t\t    : \"=f\" (tmp)\n+\t\t\t    : \"f\" (fp_max), \"f\" (fp_one));\n+    }\n+}\n+\n+#endif\t/* !__NO_FPRS__   */"}, {"sha": "91f82ae1f0954d1af1be435fb1b82066dbbdadb5", "filename": "libgcc/config/rs6000/sfp-machine.h", "status": "modified", "additions": 91, "deletions": 3, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Fsfp-machine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Fsfp-machine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Fsfp-machine.h?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -1,7 +1,26 @@\n+/* Decide whether to use 64 or 32-bit types to do the emulation.  If we are\n+   doing IEEE-128 with VSX, use 64-bit emulation even if we are compiling for a\n+   32-bit target.  */\n+\n+#if defined(_ARCH_PPC64) || defined(__VSX__) || defined(__FLOAT128__)\n+#define _FP_W_TYPE_SIZE\t\t64\n+#define _FP_W_TYPE\t\tunsigned long long\n+#define _FP_WS_TYPE\t\tsigned long long\n+#define _FP_I_TYPE\t\tlong long\n+\n+#ifdef _ARCH_PPC64\n+typedef int TItype __attribute__ ((mode (TI)));\n+typedef unsigned int UTItype __attribute__ ((mode (TI)));\n+\n+#define TI_BITS (__CHAR_BIT__ * (int)sizeof(TItype))\n+#endif\n+\n+#else\t/* 32-bits  */\n #define _FP_W_TYPE_SIZE\t\t32\n-#define _FP_W_TYPE\t\tunsigned long\n-#define _FP_WS_TYPE\t\tsigned long\n-#define _FP_I_TYPE\t\tlong\n+#define _FP_W_TYPE\t\tunsigned int\n+#define _FP_WS_TYPE\t\tsigned int\n+#define _FP_I_TYPE\t\tint\n+#endif\t/* 32-bits  */\n \n /* The type of the result of a floating point comparison.  This must\n    match `__libgcc_cmp_return__' in GCC for the target.  */\n@@ -10,18 +29,39 @@ typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n \n #define _FP_MUL_MEAT_S(R,X,Y)\t\t\t\t\\\n   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)\n+\n+#if (_FP_W_TYPE_SIZE==64)\n+#define _FP_MUL_MEAT_D(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)\n+#define _FP_MUL_MEAT_Q(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)\n+#else\n #define _FP_MUL_MEAT_D(R,X,Y)\t\t\t\t\\\n   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)\n #define _FP_MUL_MEAT_Q(R,X,Y)\t\t\t\t\\\n   _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)\n+#endif\n \n #define _FP_DIV_MEAT_S(R,X,Y)\t_FP_DIV_MEAT_1_loop(S,R,X,Y)\n+\n+#if (_FP_W_TYPE_SIZE==64)\n+#define _FP_DIV_MEAT_D(R,X,Y)\t_FP_DIV_MEAT_1_udiv(D,R,X,Y)\n+#define _FP_DIV_MEAT_Q(R,X,Y)   _FP_DIV_MEAT_2_udiv(Q,R,X,Y)\n+#else\n #define _FP_DIV_MEAT_D(R,X,Y)\t_FP_DIV_MEAT_2_udiv(D,R,X,Y)\n #define _FP_DIV_MEAT_Q(R,X,Y)\t_FP_DIV_MEAT_4_udiv(Q,R,X,Y)\n+#endif\n \n #define _FP_NANFRAC_S\t\t((_FP_QNANBIT_S << 1) - 1)\n+\n+#if (_FP_W_TYPE_SIZE==64)\n+#define _FP_NANFRAC_D\t\t((_FP_QNANBIT_D << 1) - 1)\n+#define _FP_NANFRAC_Q\t\t((_FP_QNANBIT_Q << 1) - 1), -1\n+#else\n #define _FP_NANFRAC_D\t\t((_FP_QNANBIT_D << 1) - 1), -1\n #define _FP_NANFRAC_Q\t\t((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1\n+#endif\n+\n #define _FP_NANSIGN_S\t\t0\n #define _FP_NANSIGN_D\t\t0\n #define _FP_NANSIGN_Q\t\t0\n@@ -64,6 +104,54 @@ typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n # endif\n #endif\n \n+/* Only provide exception support if we have hardware floating point using\n+   floating point registers and we can execute the mtfsf instruction.  This\n+   would only be true if we are using the emulation routines for IEEE 128-bit\n+   floating point on pre-ISA 3.0 machines without the IEEE 128-bit floating\n+   point support.  */\n+\n+#ifndef ___NO_FPRS__\n+#define ISA_BIT(x) (1LL << (63 - x))\n+\n+/* Use the same bits of the FPSCR.  */\n+# define FP_EX_INVALID\t\tISA_BIT(34)\n+# define FP_EX_OVERFLOW\t\tISA_BIT(35)\n+# define FP_EX_UNDERFLOW\tISA_BIT(36)\n+# define FP_EX_DIVZERO\t\tISA_BIT(37)\n+# define FP_EX_INEXACT\t\tISA_BIT(38)\n+# define FP_EX_ALL\t\t(FP_EX_INVALID | FP_EX_OVERFLOW \t\\\n+\t\t\t\t | FP_EX_UNDERFLOW | FP_EX_DIVZERO\t\\\n+\t\t\t\t | FP_EX_INEXACT)\n+\n+void __sfp_handle_exceptions (int);\n+\n+# define FP_HANDLE_EXCEPTIONS\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    if (__builtin_expect (_fex, 0))\t\t\\\n+      __sfp_handle_exceptions (_fex);\t\t\\\n+  } while (0);\n+/* A set bit indicates an exception is masked and a clear bit indicates it is\n+   trapping.  */\n+# define FP_TRAPPING_EXCEPTIONS (~_fpscr & (FP_EX_ALL >> 22))\n+\n+# define FP_RND_NEAREST\t0x0\n+# define FP_RND_ZERO\t0x1\n+# define FP_RND_PINF\t0x2\n+# define FP_RND_MINF\t0x3\n+# define FP_RND_MASK\t0x3\n+\n+# define _FP_DECL_EX \\\n+  unsigned long long _fpscr __attribute__ ((unused)) = FP_RND_NEAREST\n+\n+#define FP_INIT_ROUNDMODE\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    __asm__ __volatile__ (\"mtfsf 255, %0\"\t\\\n+\t\t\t  :\t\t\t\\\n+\t\t\t  : \"f\" (_fpscr));\t\\\n+  } while (0)\n+\n+# define FP_ROUNDMODE\t(_fpscr & FP_RND_MASK)\n+#endif\t/* !__NO_FPRS__ */\n \n /* Define ALIASNAME as a strong alias for NAME.  */\n # define strong_alias(name, aliasname) _strong_alias(name, aliasname)"}, {"sha": "4145c57417492a80516818d464037814d280d0f4", "filename": "libgcc/config/rs6000/t-float128", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Ft-float128", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Ft-float128", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ft-float128?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -0,0 +1,95 @@\n+# Support for adding __float128 to the powerpc.\n+\n+# The standard 128-bit floating point support functions are TFmode.  Most\n+# PowerPC targets use a long double format that has a pair of doubles to give\n+# you more precision, but no extra expoenent range.  This long double format is\n+# mostly compatible with the format used by the IBM XL compilers.  Some of the\n+# names used by the IBM double-double format use TF in them, so we rename\n+# all of the functions provided for the new IEEE 128-bit support.\n+#\n+# We use the TF functions in soft-fp for 128-bit floating point support, using\n+# sed to transform the names in the files from TF names to KF names.\n+\n+# Emulator functions from the soft-fp directory\n+fp128_softfp_funcs\t= addkf3 subkf3 mulkf3 divkf3 negkf2 \\\n+\t\t\t  unordkf2 eqkf2 gekf2 lekf2 \\\n+\t\t\t  extendsfkf2 extenddfkf2 trunckfsf2 trunckfdf2 \\\n+\t\t\t  fixkfsi fixkfdi fixunskfsi fixunskfdi \\\n+\t\t\t  floatsikf floatdikf floatunsikf floatundikf\n+\n+fp128_softfp_src\t= $(addsuffix -sw.c,$(fp128_softfp_funcs))\n+fp128_softfp_static_obj\t= $(addsuffix -sw$(objext),$(fp128_softfp_funcs))\n+fp128_softfp_shared_obj\t= $(addsuffix -sw_s$(objext),$(fp128_softfp_funcs))\n+fp128_softfp_obj\t= $(fp128_softfp_static_obj) $(fp128_softfp_shared_obj)\n+\n+# New functions for software emulation\n+fp128_ppc_funcs\t\t= floattikf floatuntikf fixkfti fixunskfti \\\n+\t\t\t  extendkftf2-sw trunctfkf2-sw \\\n+\t\t\t  sfp-exceptions float128-ifunc\n+\n+fp128_ppc_src\t\t= $(addprefix $(srcdir)/config/rs6000/,$(addsuffix \\\n+\t\t\t\t.c,$(fp128_ppc_funcs)))\n+fp128_ppc_static_obj\t= $(addsuffix $(objext),$(fp128_ppc_funcs))\n+fp128_ppc_shared_obj\t= $(addsuffix _s$(objext),$(fp128_ppc_funcs))\n+fp128_ppc_obj\t\t= $(fp128_ppc_static_obj) $(fp128_ppc_shared_obj)\n+\n+# All functions\n+fp128_funcs\t\t= $(fp128_softfp_funcs) $(fp128_ppc_funcs) \\\n+\t\t\t  $(fp128_hw_funcs)\n+\n+fp128_src\t\t= $(fp128_softfp_src) $(fp128_ppc_src) \\\n+\t\t\t  $(fp128_hw_src)\n+\n+fp128_obj\t\t= $(fp128_softfp_obj) $(fp128_ppc_obj) \\\n+\t\t\t  $(fp128_hw_obj)\n+\n+fp128_sed\t\t= $(srcdir)/config/rs6000/float128-sed\n+fp128_dep\t\t= $(fp128_sed) $(srcdir)/config/rs6000/t-float128\n+\n+fp128_includes\t\t= $(srcdir)/soft-fp/double.h \\\n+\t\t\t  $(srcdir)/soft-fp/op-1.h \\\n+\t\t\t  $(srcdir)/soft-fp/op-4.h \\\n+\t\t\t  $(srcdir)/soft-fp/op-common.h \\\n+\t\t\t  $(srcdir)/soft-fp/single.h \\\n+\t\t\t  $(srcdir)/soft-fp/extended.h \\\n+\t\t\t  $(srcdir)/soft-fp/op-2.h \\\n+\t\t\t  $(srcdir)/soft-fp/op-8.h \\\n+\t\t\t  $(srcdir)/soft-fp/quad.h \\\n+\t\t\t  $(srcdir)/soft-fp/soft-fp.h\n+\n+# Build the emulator without ISA 3.0 hardware support.\n+FP128_CFLAGS_SW\t\t = -Wno-type-limits -mvsx -mfloat128 \\\n+\t\t\t   -mno-float128-hardware \\\n+\t\t\t   -I$(srcdir)/soft-fp \\\n+\t\t\t   -I$(srcdir)/config/rs6000 \\\n+\t\t\t   $(FLOAT128_HW_INSNS)\n+\n+$(fp128_softfp_obj)\t : INTERNAL_CFLAGS += $(FP128_CFLAGS_SW)\n+$(fp128_ppc_obj)\t : INTERNAL_CFLAGS += $(FP128_CFLAGS_SW)\n+$(fp128_obj)\t\t : $(fp128_includes)\n+$(fp128_obj)\t\t : $(srcdir)/config/rs6000/quad-float128.h\n+\n+$(fp128_softfp_src) : $(srcdir)/soft-fp/$(subst -sw,,$(subst kf,tf,$@)) $(fp128_dep)\n+\t@src=\"$(srcdir)/soft-fp/$(subst -sw,,$(subst kf,tf,$@))\"; \\\n+\techo \"Create $@\"; \\\n+\t(echo \"/* file created from $$src */\"; \\\n+\t echo; \\\n+\t sed -f $(fp128_sed) < $$src) > $@\n+\n+.PHONY: test clean-float128\n+\n+test:\n+\t@echo \"fp128_src:\"; \\\n+\tfor x in $(fp128_src); do echo \"    $$x\"; done; \\\n+\techo; \\\n+\techo \"fp128_obj:\"; \\\n+\tfor x in $(fp128_obj); do echo \"    $$x\"; done;\n+\n+clean-float128:\n+\trm -rf $(fp128_softfp_src)\n+\t@$(MULTICLEAN) multi-clean DO=clean-float128\n+\n+# For now, only put it in the static library\n+# LIB2ADD += $(fp128_src)\n+\n+LIB2ADD_ST += $(fp128_src)"}, {"sha": "daae802189dbfdf7d9fbcf3eaaab946febc54b39", "filename": "libgcc/config/rs6000/t-float128-hw", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Ft-float128-hw", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Ft-float128-hw", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ft-float128-hw?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -0,0 +1,24 @@\n+# Support for adding __float128 hardware support to the powerpc.\n+# Tell the float128 functions that the ISA 3.0 hardware support can\n+# be compiled it to be selected via IFUNC functions.\n+\n+FLOAT128_HW_INSNS\t= -DFLOAT128_HW_INSNS\n+\n+# New functions for hardware support\n+fp128_hw_funcs\t\t= float128-hw\n+fp128_hw_src\t\t= $(srcdir)/config/rs6000/float128-hw.c\n+fp128_hw_static_obj\t= float128-hw$(objext)\n+fp128_hw_shared_obj\t= float128-hw_s$(objext)\n+fp128_hw_obj\t\t= $(fp128_hw_static_obj) $(fp128_hw_shared_obj)\n+\n+# Build the hardware support functions with appropriate hardware support\n+FP128_CFLAGS_HW\t\t = -Wno-type-limits -mvsx -mfloat128 \\\n+\t\t\t   -mpower8-vector -mpower9-vector \\\n+\t\t\t   -mfloat128-hardware \\\n+\t\t\t   -I$(srcdir)/soft-fp \\\n+\t\t\t   -I$(srcdir)/config/rs6000 \\\n+\t\t\t   $(FLOAT128_HW_INSNS)\n+\n+$(fp128_hw_obj)\t\t : INTERNAL_CFLAGS += $(FP128_CFLAGS_HW)\n+$(fp128_hw_obj)\t\t : $(srcdir)/config/rs6000/t-float128-hw\n+"}, {"sha": "653866337f53c4b588e3eb82d638ea8ca6d96d65", "filename": "libgcc/config/rs6000/trunctfkf2-sw.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Ftrunctfkf2-sw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfig%2Frs6000%2Ftrunctfkf2-sw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ftrunctfkf2-sw.c?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -0,0 +1,49 @@\n+/* Software IEEE 128-bit floating-point emulation for PowerPC.\n+\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Michael Meissner (meissner@linux.vnet.ibm.com)\n+   Code is based on the main soft-fp library written by:\n+\tRichard Henderson (rth@cygnus.com) and\n+\tJakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Convert IBM long double to IEEE 128-bit floating point.  */\n+\n+#ifdef __FLOAT128_HARDWARE__\n+#error \"This module must not be compiled with IEEE 128-bit hardware support\"\n+#endif\n+\n+#include \"soft-fp.h\"\n+#include \"quad-float128.h\"\n+\n+__float128\n+__trunctfkf2_sw (__ibm128 value)\n+{\n+  __float128 ret;\n+\n+  CVT_IBM128_TO_FLOAT128 (ret, value);\n+  return ret;\n+}"}, {"sha": "7cf6e9b1979508ca4310dec3fb964834b3463819", "filename": "libgcc/configure", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfigure?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -4766,6 +4766,55 @@ esac\n ;;\n esac\n \n+case ${host} in\n+powerpc*-*-linux*)\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether the PowerPC compiler can do __float128\" >&5\n+$as_echo_n \"checking whether the PowerPC compiler can do __float128... \" >&6; }\n+if test \"${libgcc_cv_powerpc_float128+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#pragma GCC target (\"vsx,float128\")\n+     __float128 add (__float128 *a) { return *a + *(a+1); }\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  libgcc_cv_powerpc_float128=yes\n+else\n+  libgcc_cv_powerpc_float128=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libgcc_cv_powerpc_float128\" >&5\n+$as_echo \"$libgcc_cv_powerpc_float128\" >&6; }\n+\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether the PowerPC compiler can do hardware __float128\" >&5\n+$as_echo_n \"checking whether the PowerPC compiler can do hardware __float128... \" >&6; }\n+if test \"${libgcc_cv_powerpc_float128_hw+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#pragma GCC target (\"cpu=power9,float128,float128-hardware\")\n+     #include <sys/auxv.h>\n+     __float128 add (__float128 a, __float128 b)\n+     {\n+       __float128 ret;\n+       __asm__ (\"xsaddqp %0,%1,%2\" : \"=v\" (ret) : \"v\" (a), \"v\" (b));\n+       return ret;\n+     }\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  libgcc_cv_powerpc_float128_hw=yes\n+else\n+  libgcc_cv_powerpc_float128_hw=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libgcc_cv_powerpc_float128_hw\" >&5\n+$as_echo \"$libgcc_cv_powerpc_float128_hw\" >&6; }\n+esac\n+\n # Collect host-machine-specific information.\n . ${srcdir}/config.host\n "}, {"sha": "b96d4bca435ceec79dbb27cbc537a9971e9ec5dc", "filename": "libgcc/configure.ac", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29176d57e6be3f93551b54bd87ccc92e830a28b9/libgcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfigure.ac?ref=29176d57e6be3f93551b54bd87ccc92e830a28b9", "patch": "@@ -373,6 +373,31 @@ esac\n ;;\n esac\n \n+case ${host} in\n+powerpc*-*-linux*)\n+  AC_CACHE_CHECK([whether the PowerPC compiler can do __float128],\n+\t\t [libgcc_cv_powerpc_float128],\n+\t\t [AC_COMPILE_IFELSE(\n+    [#pragma GCC target (\"vsx,float128\")\n+     __float128 add (__float128 *a) { return *a + *(a+1); }],\n+    [libgcc_cv_powerpc_float128=yes],\n+    [libgcc_cv_powerpc_float128=no])])\n+\n+  AC_CACHE_CHECK([whether the PowerPC compiler can do hardware __float128],\n+\t\t [libgcc_cv_powerpc_float128_hw],\n+\t\t [AC_COMPILE_IFELSE(\n+    [#pragma GCC target (\"cpu=power9,float128,float128-hardware\")\n+     #include <sys/auxv.h>\n+     __float128 add (__float128 a, __float128 b)\n+     {\n+       __float128 ret;\n+       __asm__ (\"xsaddqp %0,%1,%2\" : \"=v\" (ret) : \"v\" (a), \"v\" (b));\n+       return ret;\n+     }],\n+    [libgcc_cv_powerpc_float128_hw=yes],\n+    [libgcc_cv_powerpc_float128_hw=no])])\n+esac\n+\n # Collect host-machine-specific information.\n . ${srcdir}/config.host\n "}]}