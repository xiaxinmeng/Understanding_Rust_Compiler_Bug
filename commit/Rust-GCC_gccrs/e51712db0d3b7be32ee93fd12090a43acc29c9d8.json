{"sha": "e51712db0d3b7be32ee93fd12090a43acc29c9d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTUxNzEyZGIwZDNiN2JlMzJlZTkzZmQxMjA5MGE0M2FjYzI5YzlkOA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "1998-10-14T09:02:55Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "1998-10-14T09:02:55Z"}, "message": "Warning fixes:\n\n        * Makefile.in (sched.o): Depend on recog.h.\n        * alias.c (REG_BASE_VALUE): Cast the result of REGNO() macro to\n        (unsigned) when comparing against one.\n        (find_base_value): Likewise.\n        (record_base_value): Cast variable `regno' to (unsigned) when\n        comparing against one.  Cast the result of REGNO() macro to\n        (unsigned) when comparing against one.\n        (memrefs_conflict_p): Change type of variables `r_x' and `r_y'  to\n        unsigned.\n        (init_alias_analysis): Add unsigned variable `ui'.  Use it as loop\n        variable where an unsigned index is needed.\n        * caller-save.c (init_caller_save): Cast `-1' to (enum insn_code)\n        before comparing against one.\n        * collect2.c: Add prototypes for functions `error', `fatal' and\n        `fatal_perror'.  Make these functions take variable arguments\n        instead of faking it with a fixed number of args.\n        (write_c_file_stat): Cast the argument of ctype macro to (unsigned\n        char).\n        * combine.c (can_combine_p): Mark parameter `pred' with\n        ATTRIBUTE_UNUSED.\n        (find_split_point): Cast variable `src' to (unsigned\n        HOST_WIDE_INT) when comparing against one.\n        HOST_WIDE_INT) when comparing against one.\n        (simplify_rtx): Cast 1 to (unsigned HOST_WIDE_INT) in shift.\n        (simplify_logical): Likewise.\n        (force_to_mode): Cast result of INTVAL() macro to (unsigned\n        HOST_WIDE_INT) when comparing against one.  Cast 1 to (unsigned\n        HOST_WIDE_INT) in shift.\n        (simplify_and_const_int): Cast result of INTVAL() macro to\n        `unsigned HOST_WIDE_INT' when comparing against one.\n        (merge_outer_ops): Cast variable const0 to `unsigned\n        HOST_WIDE_INT' when comparing against the result of\n        GET_MODE_MASK() macro.\n        (simplify_comparison): Likewise for variable `c0'.  Cast variable\n        `const_op' to `unsigned HOST_WIDE_INT' when comparing against\n        one.  Cast `1' to `unsigned HOST_WIDE_INT' in shift.  Cast the\n        result of `GET_MODE_MASK()/2' to `HOST_WIDE_INT' when comparing\n        against one.  Cast `1' to `unsigned HOST_WIDE_INT' in shift.  Cast\n        result of INTVAL() macro to `unsigned HOST_WIDE_INT' when\n        comparing against one.\n        (distribute_notes): Wrap variable `cc0_setter' in macro `HAVE_cc0'.\n        config/mips/mips.c (gen_int_relational): Cast result of INTVAL()\n        macro to `unsigned HOST_WIDE_INT' when comparing against one.\n        (output_block_move): Cast `sizeof' expression to (int) when\n        comparing against one.\n        (function_arg): Cast BITS_PER_WORD to `unsigned' when comparing\n        against one.\n        (save_restore_insns): Cast `base_offset' to `long' to match format\n        specifier in fprintf.\n        * config/mips/mips.h (Pmode): Cast the result of `Pmode' macro\n        to `enum machine_mode'.\n        * flow.c (life_analysis_1): Remove unused variable `insn'.\n        * gcc.c (translate_options): Move variables `j' and `k' into the\n        scope in which they are used.  Change their types to `size_t'.\n        (set_spec): Cast the argument of ctype macro to `unsigned char'.\n        (read_specs): Likewise.\n        (process_command): Cast `sizeof' to (int) when comparing against one.\n        (do_spec_1): Cast the argument of ctype macro to `unsigned char'.\n        (handle_braces): Cast both sides of `==' expression to `long' to\n        ensure sign matching.\n        (main): Cast variable `i' to `int' when comparing against one.\n        * gcov-io.h (__fetch_long): Change type of parameter `bytes' from\n        int to size_t.  Cast variable `i' to size_t when comparing against\n        one.\n        * genattrtab.c (convert_set_attr_alternative): Remove unused\n        parameter `insn_code'.  All callers changed.\n        (convert_set_attr): Likewise.\n        * genrecog.c (add_to_sequence): Cast result of XVECLEN() macro to\n        size_t when comparing against one.  Likewise for variable `len'.\n        * global.c (global_alloc): Cast variable `max_regno' to size_t\n        when comparing against one.  Likewise for variable `max_allocno'.\n        * jump.c (sets_cc0_p): Mark parameter `x' with ATTRIBUTE_UNUSED.\n        * local-alloc.c (validate_equiv_mem_from_store): Mark parameter\n        `set' with ATTRIBUTE_UNUSED.\n        (find_free_reg): Cast `sizeof' expression to (int) when comparing\n        against one.\n        * loop.c (count_loop_regs_set): Remove unused variable `dest'.\n        (strength_reduce): Mark parameter `bct_p' with ATTRIBUTE_UNUSED.\n        (get_condition): Cast variable `const_val' to `unsigned\n        HOST_WIDE_INT' when comparing against one.  Cast unsigned\n        expression to HOST_WIDE_INT when comparing against one.\n        (insert_loop_mem): Mark parameter `data' with ATTRIBUTE_UNUSED.\n        (load_mems_and_recount_loop_regs_set): Cast variable `nregs' to\n        `unsigned' when comparing against one.\n        * protoize.c (is_id_char): Change type of parameter `ch' to\n        unsigned char.\n        (munge_compile_params): Cast argument of ctype macro to (const\n        unsigned char).\n        (process_aux_info_file): Cast variable `aux_info_size' to int when\n        comparing against one.\n        (forward_to_next_token_char): Cast argument of ctype macro to\n        `const unsigned char'.\n        (edit_formals_lists): Likewise.\n        (find_rightmost_formals_list): Likewise.\n        (add_local_decl): Likewise.\n        (add_global_decls): Likewise.\n        (edit_fn_definition): Likewise.\n        (do_cleaning): Likewise.\n        (scan_for_missed_items): Likewise.\n        (edit_file): Cast variable `orig_size' to (int) when comparing\n        against one.\n        (main): Cast argument of ctype macro to `const unsigned char'.\n        * recog.c (const_int_operand): Mark parameter `mode' with\n        ATTRIBUTE_UNUSED.\n        * regclass.c (record_reg_classes): Change type of variable `c' to\n        `unsigned char'.  Cast `char' array index to `unsigned char'.\n        * reload.c (push_secondary_reload): Cast argument to\n        REG_CLASS_FROM_LETTER() macro to `unsigned char'.\n        * reload1.c (calculate_needs): Cast `char' array index to\n        `unsigned char'.\n        (set_label_offsets): Change type of variable `i' to unsigned int.\n        Cast result of XVECLEN() macro to unsigned when comparing against\n        one.\n        (mark_not_eliminable): Change type of variable `i' to unsigned.\n        (order_regs_for_reload): Likewise.  Cast `max_regno' to unsigned\n        when comparing against one.\n        (reload_as_needed): Cast macro NUM_ELIMINABLE_REGS to (int) when\n        comparing against one.\n        (choose_reload_regs): Hide unused label `fail'.\n        (reload_cse_simplify_operands): Cast `char' array index to\n        `unsigned char'.\n        (reload_combine_note_store): Mark parameter `set' with\n        ATTRIBUTE_UNUSED.  Cast UNITS_PER_WORD to unsigned when comparing\n        against one.\n        (reload_cse_move2add): Remove unused variable `src2'.\n        * sched.c: Include recog.h.\n        (sched_note_set): Remove unused parameter `b'.  All callers\n        changed.\n        (split_hard_reg_notes): Likewise for parameter `orig_insn'.\n        (blockage_range): Cast result of UNIT_BLOCKED() macro to (int)\n        when comparing against one.\n        * stupid.c (stupid_find_reg): Mark parameter `changes_size' with\n        ATTRIBUTE_UNUSED.  Cast `sizeof' expression to (int) when\n        comparing against one.\n        * unroll.c (precondition_loop_p): Remove unused parameter\n        `loop_end'.  All callers changed.\n\nFrom-SVN: r23079", "tree": {"sha": "512ed0c30b871532bb4d50fed36b99ceca838284", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/512ed0c30b871532bb4d50fed36b99ceca838284"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e51712db0d3b7be32ee93fd12090a43acc29c9d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e51712db0d3b7be32ee93fd12090a43acc29c9d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e51712db0d3b7be32ee93fd12090a43acc29c9d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e51712db0d3b7be32ee93fd12090a43acc29c9d8/comments", "author": null, "committer": null, "parents": [{"sha": "902648f892bbb961610c2018816576361a010eb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/902648f892bbb961610c2018816576361a010eb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/902648f892bbb961610c2018816576361a010eb7"}], "stats": {"total": 563, "additions": 390, "deletions": 173}, "files": [{"sha": "5ba13c741de9da1c5bb23a52e55fb562ecde61a7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -1,3 +1,164 @@\n+Wed Oct 14 11:14:02 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* Makefile.in (sched.o): Depend on recog.h.\n+\n+\t* alias.c (REG_BASE_VALUE): Cast the result of REGNO() macro to\n+\t(unsigned) when comparing against one.\n+\t(find_base_value): Likewise.\n+\t(record_base_value): Cast variable `regno' to (unsigned) when\n+\tcomparing against one.  Cast the result of REGNO() macro to\n+\t(unsigned) when comparing against one.\n+\t(memrefs_conflict_p): Change type of variables `r_x' and `r_y'  to\n+\tunsigned.\n+\t(init_alias_analysis): Add unsigned variable `ui'.  Use it as loop\n+\tvariable where an unsigned index is needed.\n+\n+\t* caller-save.c (init_caller_save): Cast `-1' to (enum insn_code)\n+\tbefore comparing against one.\n+\n+\t* collect2.c: Add prototypes for functions `error', `fatal' and\n+\t`fatal_perror'.  Make these functions take variable arguments\n+\tinstead of faking it with a fixed number of args.\n+\t(write_c_file_stat): Cast the argument of ctype macro to (unsigned\n+\tchar).\n+\n+\t* combine.c (can_combine_p): Mark parameter `pred' with\n+\tATTRIBUTE_UNUSED.\n+\t(find_split_point): Cast variable `src' to (unsigned\n+\tHOST_WIDE_INT) when comparing against one.\n+\t(simplify_rtx): Cast 1 to (unsigned HOST_WIDE_INT) in shift.\n+\t(simplify_logical): Likewise.\n+\t(force_to_mode): Cast result of INTVAL() macro to (unsigned\n+\tHOST_WIDE_INT) when comparing against one.  Cast 1 to (unsigned\n+\tHOST_WIDE_INT) in shift.\n+\t(simplify_and_const_int): Cast result of INTVAL() macro to\n+\t`unsigned HOST_WIDE_INT' when comparing against one.\n+\t(merge_outer_ops): Cast variable const0 to `unsigned\n+\tHOST_WIDE_INT' when comparing against the result of\n+\tGET_MODE_MASK() macro.\n+\t(simplify_comparison): Likewise for variable `c0'.  Cast variable\n+\t`const_op' to `unsigned HOST_WIDE_INT' when comparing against\n+\tone.  Cast `1' to `unsigned HOST_WIDE_INT' in shift.  Cast the\n+\tresult of `GET_MODE_MASK()/2' to `HOST_WIDE_INT' when comparing\n+\tagainst one.  Cast `1' to `unsigned HOST_WIDE_INT' in shift.  Cast\n+\tresult of INTVAL() macro to `unsigned HOST_WIDE_INT' when\n+\tcomparing against one.\n+\t(distribute_notes): Wrap variable `cc0_setter' in macro `HAVE_cc0'.\n+\n+\tconfig/mips/mips.c (gen_int_relational): Cast result of INTVAL()\n+\tmacro to `unsigned HOST_WIDE_INT' when comparing against one.\n+\t(output_block_move): Cast `sizeof' expression to (int) when\n+\tcomparing against one.\n+\t(function_arg): Cast BITS_PER_WORD to `unsigned' when comparing\n+\tagainst one.\n+\t(save_restore_insns): Cast `base_offset' to `long' to match format\n+\tspecifier in fprintf.\n+\n+\t* config/mips/mips.h (Pmode): Cast the result of `Pmode' macro\n+\tto `enum machine_mode'.\n+\n+\t* flow.c (life_analysis_1): Remove unused variable `insn'.\n+\n+\t* gcc.c (translate_options): Move variables `j' and `k' into the\n+\tscope in which they are used.  Change their types to `size_t'.\n+\t(set_spec): Cast the argument of ctype macro to `unsigned char'.\n+\t(read_specs): Likewise.\n+\t(process_command): Cast `sizeof' to (int) when comparing against one.\n+\t(do_spec_1): Cast the argument of ctype macro to `unsigned char'.\n+\t(handle_braces): Cast both sides of `==' expression to `long' to\n+\tensure sign matching.\n+\t(main): Cast variable `i' to `int' when comparing against one.\n+\n+\t* gcov-io.h (__fetch_long): Change type of parameter `bytes' from\n+\tint to size_t.  Cast variable `i' to size_t when comparing against\n+\tone.\n+\n+\t* genattrtab.c (convert_set_attr_alternative): Remove unused\n+\tparameter `insn_code'.  All callers changed.\n+\t(convert_set_attr): Likewise.\n+\n+\t* genrecog.c (add_to_sequence): Cast result of XVECLEN() macro to\n+\tsize_t when comparing against one.  Likewise for variable `len'.\n+\n+\t* global.c (global_alloc): Cast variable `max_regno' to size_t\n+\twhen comparing against one.  Likewise for variable `max_allocno'.\n+\n+\t* jump.c (sets_cc0_p): Mark parameter `x' with ATTRIBUTE_UNUSED.\n+\n+\t* local-alloc.c (validate_equiv_mem_from_store): Mark parameter\n+\t`set' with ATTRIBUTE_UNUSED.\n+\t(find_free_reg): Cast `sizeof' expression to (int) when comparing\n+\tagainst one.\n+\n+\t* loop.c (count_loop_regs_set): Remove unused variable `dest'.\n+\t(strength_reduce): Mark parameter `bct_p' with ATTRIBUTE_UNUSED.\n+\t(get_condition): Cast variable `const_val' to `unsigned\n+\tHOST_WIDE_INT' when comparing against one.  Cast unsigned\n+\texpression to HOST_WIDE_INT when comparing against one.\n+\t(insert_loop_mem): Mark parameter `data' with ATTRIBUTE_UNUSED.\n+\t(load_mems_and_recount_loop_regs_set): Cast variable `nregs' to\n+\t`unsigned' when comparing against one.\n+\n+\t* protoize.c (is_id_char): Change type of parameter `ch' to\n+\tunsigned char.\n+\t(munge_compile_params): Cast argument of ctype macro to (const\n+\tunsigned char).\n+\t(process_aux_info_file): Cast variable `aux_info_size' to int when\n+\tcomparing against one.\n+\t(forward_to_next_token_char): Cast argument of ctype macro to\n+\t`const unsigned char'.\n+\t(edit_formals_lists): Likewise.\n+\t(find_rightmost_formals_list): Likewise.\n+\t(add_local_decl): Likewise.\n+\t(add_global_decls): Likewise.\n+\t(edit_fn_definition): Likewise.\n+\t(do_cleaning): Likewise.\n+\t(scan_for_missed_items): Likewise.\n+\t(edit_file): Cast variable `orig_size' to (int) when comparing\n+\tagainst one.\n+\t(main): Cast argument of ctype macro to `const unsigned char'.\n+\n+\t* recog.c (const_int_operand): Mark parameter `mode' with\n+\tATTRIBUTE_UNUSED.\n+\n+\t* regclass.c (record_reg_classes): Change type of variable `c' to\n+\t`unsigned char'.  Cast `char' array index to `unsigned char'.\n+\n+\t* reload.c (push_secondary_reload): Cast argument to\n+\tREG_CLASS_FROM_LETTER() macro to `unsigned char'.\n+\n+\t* reload1.c (calculate_needs): Cast `char' array index to\n+\t`unsigned char'.\n+\t(set_label_offsets): Change type of variable `i' to unsigned int.\n+\tCast result of XVECLEN() macro to unsigned when comparing against\n+\tone.\n+\t(mark_not_eliminable): Change type of variable `i' to unsigned.\n+\t(order_regs_for_reload): Likewise.  Cast `max_regno' to unsigned\n+\twhen comparing against one.\n+\t(reload_as_needed): Cast macro NUM_ELIMINABLE_REGS to (int) when\n+\tcomparing against one.\n+\t(choose_reload_regs): Hide unused label `fail'.\n+\t(reload_cse_simplify_operands): Cast `char' array index to\n+\t`unsigned char'.\n+\t(reload_combine_note_store): Mark parameter `set' with\n+\tATTRIBUTE_UNUSED.  Cast UNITS_PER_WORD to unsigned when comparing\n+\tagainst one.\n+\t(reload_cse_move2add): Remove unused variable `src2'.\n+\n+\t* sched.c: Include recog.h.\n+\t(sched_note_set): Remove unused parameter `b'.  All callers\n+\tchanged.\n+\t(split_hard_reg_notes): Likewise for parameter `orig_insn'.\n+\t(blockage_range): Cast result of UNIT_BLOCKED() macro to (int)\n+\twhen comparing against one.\n+\n+\t* stupid.c (stupid_find_reg): Mark parameter `changes_size' with\n+\tATTRIBUTE_UNUSED.  Cast `sizeof' expression to (int) when\n+\tcomparing against one.\n+\n+\t* unroll.c (precondition_loop_p): Remove unused parameter\n+\t`loop_end'.  All callers changed.\n+\n Tue Oct 13 22:12:11 1998  Bernd Schmidt <crux@pool.informatik.rwth-aachen.de>\n \n \t* reload1.c (maybe_fix_stack_asms): New static function."}, {"sha": "e1b1413cdaf6117bd2a584dfb5540f59c30d3e4c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -1511,8 +1511,8 @@ regmove.o : regmove.c $(CONFIG_H) system.h $(RTL_H) insn-config.h \\\n    $(RECOG_H) output.h reload.h $(REGS_H) hard-reg-set.h flags.h \\\n    $(EXPR_H) insn-flags.h $(BASIC_BLOCK_H) toplev.h\n $(SCHED_PREFIX)sched.o : $(SCHED_PREFIX)sched.c $(CONFIG_H) system.h $(RTL_H) \\\n-   $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h insn-attr.h \\\n-   toplev.h\n+   $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h \\\n+   insn-attr.h toplev.h recog.h\n final.o : final.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h $(REGS_H) \\\n    $(RECOG_H) conditions.h insn-config.h insn-attr.h except.h real.h output.h \\\n    hard-reg-set.h insn-flags.h insn-codes.h gstab.h xcoffout.h defaults.h \\"}, {"sha": "27a069f949eda93e9f3eec5014da40337318c623", "filename": "gcc/alias.c", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -94,7 +94,7 @@ rtx *reg_base_value;\n rtx *new_reg_base_value;\n unsigned int reg_base_value_size;\t/* size of reg_base_value array */\n #define REG_BASE_VALUE(X) \\\n-\t(REGNO (X) < reg_base_value_size ? reg_base_value[REGNO (X)] : 0)\n+  ((unsigned) REGNO (X) < reg_base_value_size ? reg_base_value[REGNO (X)] : 0)\n \n /* Vector of known invariant relationships between registers.  Set in\n    loop unrolling.  Indexed by register number, if nonzero the value\n@@ -158,7 +158,7 @@ find_base_value (src)\n \t The test above is not sufficient because the scheduler may move\n \t a copy out of an arg reg past the NOTE_INSN_FUNCTION_BEGIN.  */\n       if (REGNO (src) >= FIRST_PSEUDO_REGISTER\n-\t  && REGNO (src) < reg_base_value_size\n+\t  && (unsigned) REGNO (src) < reg_base_value_size\n \t  && reg_base_value[REGNO (src)])\n \treturn reg_base_value[REGNO (src)];\n \n@@ -341,7 +341,7 @@ record_base_value (regno, val, invariant)\n      rtx val;\n      int invariant;\n {\n-  if (regno >= reg_base_value_size)\n+  if ((unsigned) regno >= reg_base_value_size)\n     return;\n \n   /* If INVARIANT is true then this value also describes an invariant\n@@ -352,7 +352,7 @@ record_base_value (regno, val, invariant)\n \n   if (GET_CODE (val) == REG)\n     {\n-      if (REGNO (val) < reg_base_value_size)\n+      if ((unsigned) REGNO (val) < reg_base_value_size)\n \t{\n \t  reg_base_value[regno] = reg_base_value[REGNO (val)];\n \t}\n@@ -799,7 +799,7 @@ memrefs_conflict_p (xsize, x, ysize, y, c)\n \t/* Are these registers known not to be equal?  */\n \tif (alias_invariant)\n \t  {\n-\t    int r_x = REGNO (x), r_y = REGNO (y);\n+\t    unsigned int r_x = REGNO (x), r_y = REGNO (y);\n \t    rtx i_x, i_y;\t/* invariant relationships of X and Y */\n \n \t    i_x = r_x >= reg_base_value_size ? 0 : alias_invariant[r_x];\n@@ -1071,6 +1071,7 @@ init_alias_analysis ()\n   int maxreg = max_reg_num ();\n   int changed, pass;\n   register int i;\n+  register unsigned int ui;\n   register rtx insn;\n \n   reg_known_value_size = maxreg;\n@@ -1210,13 +1211,13 @@ init_alias_analysis ()\n \t}\n \n       /* Now propagate values from new_reg_base_value to reg_base_value.  */\n-      for (i = 0; i < reg_base_value_size; i++)\n+      for (ui = 0; ui < reg_base_value_size; ui++)\n \t{\n-\t  if (new_reg_base_value[i]\n-\t      && new_reg_base_value[i] != reg_base_value[i]\n-\t      && ! rtx_equal_p (new_reg_base_value[i], reg_base_value[i]))\n+\t  if (new_reg_base_value[ui]\n+\t      && new_reg_base_value[ui] != reg_base_value[ui]\n+\t      && ! rtx_equal_p (new_reg_base_value[ui], reg_base_value[ui]))\n \t    {\n-\t      reg_base_value[i] = new_reg_base_value[i];\n+\t      reg_base_value[ui] = new_reg_base_value[ui];\n \t      changed = 1;\n \t    }\n \t}\n@@ -1243,16 +1244,16 @@ init_alias_analysis ()\n     {\n       changed = 0;\n       pass++;\n-      for (i = 0; i < reg_base_value_size; i++)\n+      for (ui = 0; ui < reg_base_value_size; ui++)\n \t{\n-\t  rtx base = reg_base_value[i];\n+\t  rtx base = reg_base_value[ui];\n \t  if (base && GET_CODE (base) == REG)\n \t    {\n-\t      int base_regno = REGNO (base);\n-\t      if (base_regno == i)\t\t/* register set from itself */\n-\t\treg_base_value[i] = 0;\n+\t      unsigned int base_regno = REGNO (base);\n+\t      if (base_regno == ui)\t\t/* register set from itself */\n+\t\treg_base_value[ui] = 0;\n \t      else\n-\t\treg_base_value[i] = reg_base_value[base_regno];\n+\t\treg_base_value[ui] = reg_base_value[base_regno];\n \t      changed = 1;\n \t    }\n \t}"}, {"sha": "b05e8493a2458efd5caea7f2eff2fb3e447b3ca1", "filename": "gcc/caller-save.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -192,7 +192,8 @@ init_caller_save ()\n \n \t  /* Now extract both insns and see if we can meet their\n              constraints.  */\n-\t  ok = (reg_save_code[i][j] != -1 && reg_restore_code[i][j] != -1);\n+\t  ok = (reg_save_code[i][j] != (enum insn_code)-1\n+\t\t&& reg_restore_code[i][j] != (enum insn_code)-1);\n \t  if (ok)\n \t    {\n \t      insn_extract (saveinsn);"}, {"sha": "bf494c04562a8164736200a5a19ce8da9b7317b8", "filename": "gcc/collect2.c", "status": "modified", "additions": 49, "deletions": 10, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -266,6 +266,11 @@ static struct path_prefix *libpaths[3] = {&cmdline_lib_dirs,\n static char *libexts[3] = {\"a\", \"so\", NULL};  /* possible library extentions */\n #endif\n \n+void error\t\tPVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n+void fatal\t\tPVPROTO((const char *, ...)) \n+  ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n+void fatal_perror\tPVPROTO((const char *, ...))\n+  ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n static char *my_strerror\tPROTO((int));\n static const char *my_strsignal\tPROTO((int));\n static void handler\t\tPROTO((int));\n@@ -409,38 +414,72 @@ collect_exit (status)\n /* Die when sys call fails.  */\n \n void\n-fatal_perror (string, arg1, arg2, arg3)\n-     char *string, *arg1, *arg2, *arg3;\n+fatal_perror VPROTO((const char * string, ...))\n {\n+#ifndef __STDC__\n+  const char *string;\n+#endif\n   int e = errno;\n+  va_list ap;\n+\n+  VA_START (ap, string);\n+\n+#ifndef __STDC__\n+  string = va_arg (ap, const char *);\n+#endif\n \n   fprintf (stderr, \"collect2: \");\n-  fprintf (stderr, string, arg1, arg2, arg3);\n+  vfprintf (stderr, string, ap);\n   fprintf (stderr, \": %s\\n\", my_strerror (e));\n+  va_end (ap);\n+\n   collect_exit (FATAL_EXIT_CODE);\n }\n \n /* Just die.  */\n \n void\n-fatal (string, arg1, arg2, arg3)\n-     char *string, *arg1, *arg2, *arg3;\n+fatal VPROTO((const char * string, ...))\n {\n+#ifndef __STDC__\n+  const char *string;\n+#endif\n+  va_list ap;\n+  \n+  VA_START (ap, string);\n+\n+#ifndef __STDC__\n+  string = va_arg (ap, const char *);\n+#endif\n+  \n   fprintf (stderr, \"collect2: \");\n-  fprintf (stderr, string, arg1, arg2, arg3);\n+  vfprintf (stderr, string, ap);\n   fprintf (stderr, \"\\n\");\n+  va_end (ap);\n+\n   collect_exit (FATAL_EXIT_CODE);\n }\n \n /* Write error message.  */\n \n void\n-error (string, arg1, arg2, arg3, arg4)\n-     char *string, *arg1, *arg2, *arg3, *arg4;\n+error VPROTO((const char * string, ...))\n {\n+#ifndef __STDC__\n+  const char * string;\n+#endif\n+  va_list ap;\n+ \n+  VA_START (ap, string);\n+  \n+#ifndef __STDC__\n+  string = va_arg (ap, const char *);\n+#endif\n+\n   fprintf (stderr, \"collect2: \");\n-  fprintf (stderr, string, arg1, arg2, arg3, arg4);\n+  vfprintf (stderr, string, ap);\n   fprintf (stderr, \"\\n\");\n+  va_end(ap);\n }\n \n /* In case obstack is linked in, and abort is defined to fancy_abort,\n@@ -1940,7 +1979,7 @@ write_c_file_stat (stream, name)\n   strncpy (prefix, p, q - p);\n   prefix[q - p] = 0;\n   for (q = prefix; *q; q++)\n-    if (!ISALNUM (*q))\n+    if (!ISALNUM ((unsigned char)*q))\n       *q = '_';\n   if (debug)\n     fprintf (stderr, \"\\nwrite_c_file - output name is %s, prefix is %s\\n\","}, {"sha": "619c897f81169e09260e54eb3c635d366949cb04", "filename": "gcc/combine.c", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -816,7 +816,8 @@ static int\n can_combine_p (insn, i3, pred, succ, pdest, psrc)\n      rtx insn;\n      rtx i3;\n-     rtx pred, succ;\n+     rtx pred ATTRIBUTE_UNUSED;\n+     rtx succ;\n      rtx *pdest, *psrc;\n {\n   int i;\n@@ -2750,7 +2751,7 @@ find_split_point (loc, insn)\n \t  if (BITS_BIG_ENDIAN)\n \t    pos = GET_MODE_BITSIZE (mode) - len - pos;\n \n-\t  if (src == mask)\n+\t  if ((unsigned HOST_WIDE_INT) src == mask)\n \t    SUBST (SET_SRC (x),\n \t\t   gen_binary (IOR, mode, dest, GEN_INT (src << pos)));\n \t  else\n@@ -4119,7 +4120,7 @@ simplify_rtx (x, op0_mode, last, in_dest)\n \t  if (new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n \t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t      && ((STORE_FLAG_VALUE & GET_MODE_MASK (mode))\n-\t\t  == (HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1))\n+\t\t  == (unsigned HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE(mode)-1))\n \t      && op1 == const0_rtx\n \t      && mode == GET_MODE (op0)\n \t      && (i = exact_log2 (nonzero_bits (op0, mode))) >= 0)\n@@ -5086,7 +5087,7 @@ simplify_logical (x, last)\n \t when STORE_FLAG_VALUE is the sign bit.  */\n       if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t  && ((STORE_FLAG_VALUE & GET_MODE_MASK (mode))\n-\t      == (HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1))\n+\t      == (unsigned HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1))\n \t  && op1 == const_true_rtx\n \t  && GET_RTX_CLASS (GET_CODE (op0)) == '<'\n \t  && reversible_comparison_p (op0))\n@@ -6319,7 +6320,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t     need it.  */\n \n \t  if (GET_CODE (x) == AND && GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t      && INTVAL (XEXP (x, 1)) == mask)\n+\t      && (unsigned HOST_WIDE_INT) INTVAL (XEXP (x, 1)) == mask)\n \t    x = XEXP (x, 0);\n \n \t  /* If it remains an AND, try making another AND with the bits\n@@ -6540,7 +6541,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n       /* If we are just looking for the sign bit, we don't need this shift at\n \t all, even if it has a variable count.  */\n       if (GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT\n-\t  && (mask == ((HOST_WIDE_INT) 1\n+\t  && (mask == ((unsigned HOST_WIDE_INT) 1\n \t\t       << (GET_MODE_BITSIZE (GET_MODE (x)) - 1))))\n \treturn force_to_mode (XEXP (x, 0), mode, mask, reg, next_select);\n \n@@ -7367,7 +7368,7 @@ simplify_and_const_int (x, mode, varop, constop)\n   else\n     {\n       if (GET_CODE (XEXP (x, 1)) != CONST_INT\n-\t  || INTVAL (XEXP (x, 1)) != constop)\n+\t  || (unsigned HOST_WIDE_INT) INTVAL (XEXP (x, 1)) != constop)\n \tSUBST (XEXP (x, 1), GEN_INT (constop));\n \n       SUBST (XEXP (x, 0), varop);\n@@ -8273,7 +8274,8 @@ merge_outer_ops (pop0, pconst0, op1, const1, mode, pcomp_p)\n     op0 = NIL;\n   else if (const0 == 0 && op0 == AND)\n     op0 = SET;\n-  else if (const0 == GET_MODE_MASK (mode) && op0 == AND)\n+  else if ((unsigned HOST_WIDE_INT) const0 == GET_MODE_MASK (mode)\n+\t   && op0 == AND)\n     op0 = NIL;\n \n   /* If this would be an entire word for the target, but is not for\n@@ -9534,7 +9536,7 @@ simplify_comparison (code, pop0, pop1)\n \t    for (tmode = GET_CLASS_NARROWEST_MODE\n \t\t (GET_MODE_CLASS (GET_MODE (op0)));\n \t\t tmode != GET_MODE (op0); tmode = GET_MODE_WIDER_MODE (tmode))\n-\t      if (c0 == GET_MODE_MASK (tmode))\n+\t      if ((unsigned HOST_WIDE_INT) c0 == GET_MODE_MASK (tmode))\n \t\t{\n \t\t  op0 = gen_lowpart_for_combine (tmode, inner_op0);\n \t\t  op1 = gen_lowpart_for_combine (tmode, inner_op1);\n@@ -9609,7 +9611,7 @@ simplify_comparison (code, pop0, pop1)\n \t      || code == LT || code == LTU)\n \t  && mode_width <= HOST_BITS_PER_WIDE_INT\n \t  && exact_log2 (const_op) >= 0\n-\t  && nonzero_bits (op0, mode) == const_op)\n+\t  && nonzero_bits (op0, mode) == (unsigned HOST_WIDE_INT) const_op)\n \t{\n \t  code = (code == EQ || code == GE || code == GEU ? NE : EQ);\n \t  op1 = const0_rtx, const_op = 0;\n@@ -9938,7 +9940,7 @@ simplify_comparison (code, pop0, pop1)\n \t      && (GET_MODE_BITSIZE (GET_MODE (XEXP (op0, 0)))\n \t\t  <= HOST_BITS_PER_WIDE_INT)\n \t      && ((unsigned HOST_WIDE_INT) const_op\n-\t\t  < (((HOST_WIDE_INT) 1\n+\t\t  < (((unsigned HOST_WIDE_INT) 1\n \t\t      << (GET_MODE_BITSIZE (GET_MODE (XEXP (op0, 0))) - 1)))))\n \t    {\n \t      op0 = XEXP (op0, 0);\n@@ -9962,7 +9964,7 @@ simplify_comparison (code, pop0, pop1)\n \t      && GET_CODE (XEXP (SUBREG_REG (op0), 1)) == CONST_INT\n \t      && INTVAL (XEXP (SUBREG_REG (op0), 1)) < 0\n \t      && (- INTVAL (XEXP (SUBREG_REG (op0), 1))\n-\t\t  < GET_MODE_MASK (mode) / 2)\n+\t\t  < (HOST_WIDE_INT)(GET_MODE_MASK (mode) / 2))\n \t      && (unsigned HOST_WIDE_INT) const_op < GET_MODE_MASK (mode) / 2\n \t      && (0 == (nonzero_bits (XEXP (SUBREG_REG (op0), 0),\n \t\t\t\t      GET_MODE (SUBREG_REG (op0)))\n@@ -10166,7 +10168,7 @@ simplify_comparison (code, pop0, pop1)\n \t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n \t      && mode_width <= HOST_BITS_PER_WIDE_INT\n \t      && ((INTVAL (XEXP (op0, 1)) & GET_MODE_MASK (mode))\n-\t\t  == (HOST_WIDE_INT) 1 << (mode_width - 1)))\n+\t\t  == (unsigned HOST_WIDE_INT) 1 << (mode_width - 1)))\n \t    {\n \t      op0 = XEXP (op0, 0);\n \t      code = (code == EQ ? GE : LT);\n@@ -10217,8 +10219,8 @@ simplify_comparison (code, pop0, pop1)\n \t      && (INTVAL (XEXP (op0, 1)) & ~ mask) == 0\n \t      && 0 == (~ GET_MODE_MASK (GET_MODE (SUBREG_REG (XEXP (op0, 0))))\n \t\t       & INTVAL (XEXP (op0, 1)))\n-\t      && INTVAL (XEXP (op0, 1)) != mask\n-\t      && (INTVAL (XEXP (op0, 1))\n+\t      && (unsigned HOST_WIDE_INT) INTVAL (XEXP (op0, 1)) != mask\n+\t      && ((unsigned HOST_WIDE_INT) INTVAL (XEXP (op0, 1))\n \t\t  != GET_MODE_MASK (GET_MODE (SUBREG_REG (XEXP (op0, 0))))))\n \t\t       \n \t    {\n@@ -11563,7 +11565,9 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t    {\n \t\t      rtx set = single_set (tem);\n \t\t      rtx inner_dest = 0;\n+#ifdef HAVE_cc0\n \t\t      rtx cc0_setter = NULL_RTX;\n+#endif\n \n \t\t      if (set != 0)\n \t\t\tfor (inner_dest = SET_DEST (set);"}, {"sha": "d795059ebae77bbf00079b3478182d75e9228868", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -2682,7 +2682,7 @@ gen_int_relational (test_code, result, cmp0, cmp1, p_invert)\n \t      && p_info->const_add != 0\n \t      && ((p_info->unsignedp\n \t\t   ? ((unsigned HOST_WIDE_INT) (value + p_info->const_add)\n-\t\t      > INTVAL (cmp1))\n+\t\t      > (unsigned HOST_WIDE_INT) INTVAL (cmp1))\n \t\t   : (value + p_info->const_add) > INTVAL (cmp1))\n \t\t  != (p_info->const_add > 0))))\n \tcmp1 = force_reg (mode, cmp1);\n@@ -2710,7 +2710,8 @@ gen_int_relational (test_code, result, cmp0, cmp1, p_invert)\n \t     we would get the wrong answer if we follow the usual path;\n \t     thus, x > 0xffffffffU would turn into x > 0U.  */\n \t  if ((p_info->unsignedp\n-\t       ? (unsigned HOST_WIDE_INT) new > INTVAL (cmp1)\n+\t       ? (unsigned HOST_WIDE_INT) new >\n+\t       (unsigned HOST_WIDE_INT) INTVAL (cmp1)\n \t       : new > INTVAL (cmp1))\n \t      != (p_info->const_add > 0))\n \t    {\n@@ -3230,7 +3231,7 @@ output_block_move (insn, operands, num_regs, move_type)\n      the number of registers available.  */\n   for (i = 4;\n        i < last_operand\n-       && safe_regs < (sizeof(xoperands) / sizeof(xoperands[0]));\n+       && safe_regs < (int)(sizeof(xoperands) / sizeof(xoperands[0]));\n        i++)\n     if (! reg_mentioned_p (operands[i], operands[0])\n \t&& ! reg_mentioned_p (operands[i], operands[1]))\n@@ -3326,7 +3327,7 @@ output_block_move (insn, operands, num_regs, move_type)\n \t}\n     }\n \n-  if (num_regs > sizeof (load_store) / sizeof (load_store[0]))\n+  if (num_regs > (int)(sizeof (load_store) / sizeof (load_store[0])))\n     num_regs = sizeof (load_store) / sizeof (load_store[0]);\n \n   else if (num_regs < 1)\n@@ -3749,7 +3750,7 @@ function_arg (cum, mode, type, named)\n \n       /* Drops through.  */\n     case BLKmode:\n-      if (type != (tree)0 && TYPE_ALIGN (type) > BITS_PER_WORD\n+      if (type != (tree)0 && TYPE_ALIGN (type) > (unsigned) BITS_PER_WORD\n \t  && ! TARGET_64BIT && mips_abi != ABI_EABI)\n \tcum->arg_words += (cum->arg_words & 1);\n       regbase = GP_ARG_FIRST;\n@@ -5764,7 +5765,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t  else\n \t    {\n \t      fprintf (file, \"\\tli\\t%s,0x%.08lx\\t# \",\n-\t\t       reg_names[MIPS_TEMP2_REGNUM], base_offset);\n+\t\t       reg_names[MIPS_TEMP2_REGNUM], (long) base_offset);\n \t      fprintf (file, HOST_WIDE_INT_PRINT_DEC, base_offset);\n \t      fprintf (file, \"\\n\\t%s\\t%s,%s,%s\\n\",\n \t\t       Pmode == DImode ? \"daddu\" : \"addu\",\n@@ -5981,7 +5982,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t  else\n \t    {\n \t      fprintf (file, \"\\tli\\t%s,0x%.08lx\\t# \",\n-\t\t       reg_names[MIPS_TEMP2_REGNUM], base_offset);\n+\t\t       reg_names[MIPS_TEMP2_REGNUM], (long) base_offset);\n \t      fprintf (file, HOST_WIDE_INT_PRINT_DEC, base_offset);\n \t      fprintf (file, \"\\n\\t%s\\t%s,%s,%s\\n\",\n \t\t       Pmode == DImode ? \"daddu\" : \"addu\","}, {"sha": "c562307310f19fabf3ab44716927062f84369859", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -3183,7 +3183,7 @@ while (0)\n    between pointers and any other objects of this machine mode.  */\n \n #ifndef Pmode\n-#define Pmode (TARGET_LONG64 ? DImode : SImode)\n+#define Pmode ((enum machine_mode)(TARGET_LONG64 ? DImode : SImode))\n #endif\n \n /* A function address in a call instruction"}, {"sha": "a7865730d98ba5beb9219f54b6ba0af117499869", "filename": "gcc/flow.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -1347,7 +1347,6 @@ life_analysis_1 (f, nregs)\n      possibly excluding those that are used after they are set.  */\n   regset *basic_block_significant;\n   register int i;\n-  rtx insn;\n \n   struct obstack flow_obstack;\n "}, {"sha": "b9740129884587535e2df810b7fdc7abc8ff6910", "filename": "gcc/gcc.c", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -930,7 +930,7 @@ translate_options (argcp, argvp)\n      int *argcp;\n      char ***argvp;\n {\n-  int i, j, k;\n+  int i;\n   int argc = *argcp;\n   char **argv = *argvp;\n   char **newv = (char **) xmalloc ((argc + 2) * 2 * sizeof (char *));\n@@ -944,6 +944,7 @@ translate_options (argcp, argvp)\n       /* Translate -- options.  */\n       if (argv[i][0] == '-' && argv[i][1] == '-')\n \t{\n+\t  size_t j;\n \t  /* Find a mapping that applies to this option.  */\n \t  for (j = 0; j < sizeof (option_map) / sizeof (option_map[0]); j++)\n \t    {\n@@ -961,6 +962,7 @@ translate_options (argcp, argvp)\n \n \t\t  if (arglen < optlen)\n \t\t    {\n+\t\t      size_t k;\n \t\t      for (k = j + 1;\n \t\t\t   k < sizeof (option_map) / sizeof (option_map[0]);\n \t\t\t   k++)\n@@ -1267,7 +1269,7 @@ set_spec (name, spec)\n     }\n \n   old_spec = *(sl->ptr_spec);\n-  *(sl->ptr_spec) = ((spec[0] == '+' && ISSPACE (spec[1]))\n+  *(sl->ptr_spec) = ((spec[0] == '+' && ISSPACE ((unsigned char)spec[1]))\n \t\t     ? concat (old_spec, spec + 1, NULL_PTR)\n \t\t     : save_string (spec, strlen (spec)));\n \n@@ -1566,12 +1568,12 @@ read_specs (filename, main_p)\n \t      while (*p1 == ' ' || *p1 == '\\t')\n \t\tp1++;\n \n-\t      if (! ISALPHA (*p1))\n+\t      if (! ISALPHA ((unsigned char)*p1))\n \t\tfatal (\"specs %%rename syntax malformed after %d characters\",\n \t\t       p1 - buffer);\n \n \t      p2 = p1;\n-\t      while (*p2 && !ISSPACE (*p2))\n+\t      while (*p2 && !ISSPACE ((unsigned char)*p2))\n \t\tp2++;\n \n \t      if (*p2 != ' ' && *p2 != '\\t')\n@@ -1583,13 +1585,13 @@ read_specs (filename, main_p)\n \t      while (*p2 == ' ' || *p2 == '\\t')\n \t\tp2++;\n \n-\t      if (! ISALPHA (*p2))\n+\t      if (! ISALPHA ((unsigned char)*p2))\n \t\tfatal (\"specs %%rename syntax malformed after %d characters\",\n \t\t       p2 - buffer);\n \n \t      /* Get new spec name */\n \t      p3 = p2;\n-\t      while (*p3 && !ISSPACE (*p3))\n+\t      while (*p3 && !ISSPACE ((unsigned char)*p3))\n \t\tp3++;\n \n \t      if (p3 != p-1)\n@@ -2606,7 +2608,7 @@ process_command (argc, argv)\n   if (gcc_exec_prefix)\n     {\n       int len = strlen (gcc_exec_prefix);\n-      if (len > sizeof (\"/lib/gcc-lib/\")-1\n+      if (len > (int) sizeof (\"/lib/gcc-lib/\")-1\n \t  && (gcc_exec_prefix[len-1] == '/'\n \t      || gcc_exec_prefix[len-1] == DIR_SEPARATOR))\n \t{\n@@ -3664,15 +3666,15 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\tif (p[0] == '%' && p[1] == 'O')\n \t\t  {\n \t\t    /* We don't support extra suffix characters after %O.  */\n-\t\t    if (*p == '.' || ISALPHA (*p))\n+\t\t    if (*p == '.' || ISALPHA ((unsigned char)*p))\n \t\t      abort ();\n \t\t    suffix = OBJECT_SUFFIX;\n \t\t    suffix_length = strlen (OBJECT_SUFFIX);\n \t\t    p += 2;\n \t\t  }\n \t\telse\n \t\t  {\n-\t\t    while (*p == '.' || ISALPHA (*p))\n+\t\t    while (*p == '.' || ISALPHA ((unsigned char)*p))\n \t\t      p++;\n \t\t    suffix_length = p - suffix;\n \t\t  }\n@@ -3960,7 +3962,8 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t      *x++ = *y++;\n \n \t\t      if (*y != '_'\n-\t\t\t  || (*(y+1) != '_' && ! ISUPPER (*(y+1))))\n+\t\t\t  || (*(y+1) != '_'\n+\t\t\t      && ! ISUPPER ((unsigned char)*(y+1))))\n \t\t        {\n \t\t\t  /* Stick __ at front of macro name.  */\n \t\t\t  *x++ = '_';\n@@ -4002,7 +4005,8 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t      y += 2;\n \n \t\t      if (*y != '_'\n-\t\t\t  || (*(y+1) != '_' && ! ISUPPER (*(y+1))))\n+\t\t\t  || (*(y+1) != '_'\n+\t\t\t      && ! ISUPPER ((unsigned char)*(y+1))))\n \t\t        {\n \t\t\t  /* Stick -D__ at front of macro name.  */\n \t\t\t  *x++ = '-';\n@@ -4304,7 +4308,7 @@ handle_braces (p)\n   if (suffix)\n     {\n       int found = (input_suffix != 0\n-\t\t   && strlen (input_suffix) == p - filter\n+\t\t   && (long) strlen (input_suffix) == (long)(p - filter)\n \t\t   && strncmp (input_suffix, filter, p - filter) == 0);\n \n       if (body[0] == '}')\n@@ -4748,7 +4752,7 @@ main (argc, argv)\n \t\t  sizeof (\"COLLECT_GCC_OPTIONS=\")-1);\n \n     first_time = TRUE;\n-    for (i = 0; i < n_switches; i++)\n+    for (i = 0; (int)i < n_switches; i++)\n       {\n \tchar **args;\n \tchar *p, *q;\n@@ -4919,7 +4923,7 @@ main (argc, argv)\n \n   /* Warn about any switches that no pass was interested in.  */\n \n-  for (i = 0; i < n_switches; i++)\n+  for (i = 0; (int)i < n_switches; i++)\n     if (! switches[i].valid)\n       error (\"unrecognized option `-%s'\", switches[i].part1);\n \n@@ -5018,7 +5022,7 @@ main (argc, argv)\n   explicit_link_files = xmalloc (n_infiles);\n   bzero (explicit_link_files, n_infiles);\n \n-  for (i = 0; i < n_infiles; i++)\n+  for (i = 0; (int)i < n_infiles; i++)\n     {\n       register struct compiler *cp = 0;\n       int this_file_error = 0;\n@@ -5149,7 +5153,7 @@ main (argc, argv)\n      complain about input files to be given to the linker.  */\n \n   if (! linker_was_run && error_count == 0)\n-    for (i = 0; i < n_infiles; i++)\n+    for (i = 0; (int)i < n_infiles; i++)\n       if (explicit_link_files[i])\n \terror (\"%s: linker input file unused since linking not done\",\n \t       outfiles[i]);"}, {"sha": "67b194b0c75cb148aeb0b3e45c131b2f10abb372", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -24,7 +24,7 @@ Boston, MA 02111-1307, USA.  */\n #include <stdio.h>\n #include <sys/types.h>\n \n-static int __fetch_long\t\tPROTO ((long *, char *, int));\n+static int __fetch_long\t\tPROTO ((long *, char *, size_t));\n static int __store_long\t\tPROTO ((long, char *, size_t));\n static int __read_long\t\tPROTO ((long *, FILE *, size_t));\n static int __write_long\t\tPROTO ((long, FILE *, size_t));\n@@ -74,17 +74,17 @@ static int\n __fetch_long (dest, source, bytes)\n      long *dest;\n      char *source;\n-     int bytes;\n+     size_t bytes;\n {\n   long value = 0;\n   int i;\n \n-  for (i = bytes - 1; i > (sizeof (*dest) - 1); i--)\n-    if (source[i] & (i == (bytes - 1) ? 127 : 255 ))\n+  for (i = bytes - 1; (size_t) i > (sizeof (*dest) - 1); i--)\n+    if (source[i] & ((size_t) i == (bytes - 1) ? 127 : 255 ))\n       return 1;\n \n   for (; i >= 0; i--)\n-    value = value * 256 + (source[i] & (i == (bytes - 1) ? 127 : 255));\n+    value = value * 256 + (source[i] & ((size_t)i == (bytes - 1) ? 127 : 255));\n \n   if ((source[bytes - 1] & 128) && (value > 0))\n     value = - value;"}, {"sha": "40bb38ba03c2bc2767d0926a0520f20052d8b013", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -368,8 +368,8 @@ static char *attr_printf\tPVPROTO((int, char *, ...));\n static char *attr_string        PROTO((char *, int));\n static rtx check_attr_test\tPROTO((rtx, int));\n static rtx check_attr_value\tPROTO((rtx, struct attr_desc *));\n-static rtx convert_set_attr_alternative PROTO((rtx, int, int, int));\n-static rtx convert_set_attr\tPROTO((rtx, int, int, int));\n+static rtx convert_set_attr_alternative PROTO((rtx, int, int));\n+static rtx convert_set_attr\tPROTO((rtx, int, int));\n static void check_defs\t\tPROTO((void));\n #if 0\n static rtx convert_const_symbol_ref PROTO((rtx, struct attr_desc *));\n@@ -1166,10 +1166,10 @@ check_attr_value (exp, attr)\n    It becomes a COND with each test being (eq_attr \"alternative \"n\") */\n \n static rtx\n-convert_set_attr_alternative (exp, num_alt, insn_code, insn_index)\n+convert_set_attr_alternative (exp, num_alt, insn_index)\n      rtx exp;\n      int num_alt;\n-     int insn_code, insn_index;\n+     int insn_index;\n {\n   rtx condexp;\n   int i;\n@@ -1207,10 +1207,10 @@ convert_set_attr_alternative (exp, num_alt, insn_code, insn_index)\n    list of values is given, convert to SET_ATTR_ALTERNATIVE first.  */\n \n static rtx\n-convert_set_attr (exp, num_alt, insn_code, insn_index)\n+convert_set_attr (exp, num_alt, insn_index)\n      rtx exp;\n      int num_alt;\n-     int insn_code, insn_index;\n+     int insn_index;\n {\n   rtx newexp;\n   char *name_ptr;\n@@ -1234,7 +1234,7 @@ convert_set_attr (exp, num_alt, insn_code, insn_index)\n   while ((p = next_comma_elt (&name_ptr)) != NULL)\n     XVECEXP (newexp, 1, n++) = attr_rtx (CONST_STRING, p);\n \n-  return convert_set_attr_alternative (newexp, num_alt, insn_code, insn_index);\n+  return convert_set_attr_alternative (newexp, num_alt, insn_index);\n }\n \f\n /* Scan all definitions, checking for validity.  Also, convert any SET_ATTR\n@@ -1267,13 +1267,12 @@ check_defs ()\n \t    case SET_ATTR_ALTERNATIVE:\n \t      value = convert_set_attr_alternative (value,\n \t\t\t\t\t\t    id->num_alternatives,\n-\t\t\t\t\t\t    id->insn_code,\n \t\t\t\t\t\t    id->insn_index);\n \t      break;\n \n \t    case SET_ATTR:\n \t      value = convert_set_attr (value, id->num_alternatives,\n-\t\t\t\t\tid->insn_code, id->insn_index);\n+\t\t\t\t\tid->insn_index);\n \t      break;\n \n \t    default:"}, {"sha": "6ea513c65474dc35acc7ec8e0398ff63a079e771", "filename": "gcc/genrecog.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -416,7 +416,7 @@ add_to_sequence (pattern, last, position)\n \n       if (code == MATCH_OPERATOR || code == MATCH_PARALLEL)\n \t{\n-\t  for (i = 0; i < XVECLEN (pattern, 2); i++)\n+\t  for (i = 0; i < (size_t) XVECLEN (pattern, 2); i++)\n \t    {\n \t      newpos[depth] = i + (code == MATCH_OPERATOR ? '0': 'a');\n \t      new = add_to_sequence (XVECEXP (pattern, 2, i),\n@@ -431,7 +431,7 @@ add_to_sequence (pattern, last, position)\n       new->dupno = XINT (pattern, 0);\n       new->code = UNKNOWN;\n       new->tests = 0;\n-      for (i = 0; i < XVECLEN (pattern, 1); i++)\n+      for (i = 0; i < (size_t) XVECLEN (pattern, 1); i++)\n \t{\n \t  newpos[depth] = i + '0';\n \t  new = add_to_sequence (XVECEXP (pattern, 1, i),\n@@ -528,7 +528,7 @@ add_to_sequence (pattern, last, position)\n \n   fmt = GET_RTX_FORMAT (code);\n   len = GET_RTX_LENGTH (code);\n-  for (i = 0; i < len; i++)\n+  for (i = 0; i < (size_t) len; i++)\n     {\n       newpos[depth] = '0' + i;\n       if (fmt[i] == 'e' || fmt[i] == 'u')"}, {"sha": "3dd8463bc4192d865dbad3c5cf68a693a71c21ce", "filename": "gcc/global.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -363,7 +363,7 @@ global_alloc (file)\n       SET_HARD_REG_BIT (regs_used_so_far, i);\n #endif\n \n-  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n+  for (i = FIRST_PSEUDO_REGISTER; i < (size_t) max_regno; i++)\n     if (reg_renumber[i] >= 0)\n       SET_HARD_REG_BIT (regs_used_so_far, reg_renumber[i]);\n \n@@ -389,7 +389,7 @@ global_alloc (file)\n \treg_may_share[r2] = r1;\n     }\n \n-  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n+  for (i = FIRST_PSEUDO_REGISTER; i < (size_t) max_regno; i++)\n     /* Note that reg_live_length[i] < 0 indicates a \"constant\" reg\n        that we are supposed to refrain from putting in a hard reg.\n        -2 means do make an allocno but don't allocate it.  */\n@@ -419,7 +419,7 @@ global_alloc (file)\n   bzero ((char *) allocno_n_refs, max_allocno * sizeof (int));\n   bzero ((char *) allocno_live_length, max_allocno * sizeof (int));\n \n-  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n+  for (i = FIRST_PSEUDO_REGISTER; i < (size_t) max_regno; i++)\n     if (reg_allocno[i] >= 0)\n       {\n \tint allocno = reg_allocno[i];\n@@ -436,7 +436,7 @@ global_alloc (file)\n      override it.  */\n   bzero ((char *) local_reg_live_length, sizeof local_reg_live_length);\n   bzero ((char *) local_reg_n_refs, sizeof local_reg_n_refs);\n-  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n+  for (i = FIRST_PSEUDO_REGISTER; i < (size_t) max_regno; i++)\n     if (reg_renumber[i] >= 0)\n       {\n \tint regno = reg_renumber[i];\n@@ -509,7 +509,7 @@ global_alloc (file)\n \t So in either case, we can ignore the conflict.  Likewise for\n \t preferences.  */\n \n-      for (i = 0; i < max_allocno; i++)\n+      for (i = 0; i < (size_t) max_allocno; i++)\n \t{\n \t  AND_COMPL_HARD_REG_SET (hard_reg_conflicts[i], eliminable_regset);\n \t  AND_COMPL_HARD_REG_SET (hard_reg_copy_preferences[i],\n@@ -524,7 +524,7 @@ global_alloc (file)\n       /* Determine the order to allocate the remaining pseudo registers.  */\n \n       allocno_order = (int *) alloca (max_allocno * sizeof (int));\n-      for (i = 0; i < max_allocno; i++)\n+      for (i = 0; i < (size_t) max_allocno; i++)\n \tallocno_order[i] = i;\n \n       /* Default the size to 1, since allocno_compare uses it to divide by.\n@@ -534,7 +534,7 @@ global_alloc (file)\n \t allocate it.  So avoid the divide-by-zero and set it to a low\n \t priority.  */\n \n-      for (i = 0; i < max_allocno; i++)\n+      for (i = 0; i < (size_t) max_allocno; i++)\n \t{\n \t  if (allocno_size[i] == 0)\n \t    allocno_size[i] = 1;\n@@ -552,7 +552,7 @@ global_alloc (file)\n       /* Try allocating them, one by one, in that order,\n \t except for parameters marked with reg_live_length[regno] == -2.  */\n \n-      for (i = 0; i < max_allocno; i++)\n+      for (i = 0; i < (size_t) max_allocno; i++)\n \tif (reg_renumber[allocno_reg[allocno_order[i]]] < 0\n \t    && REG_LIVE_LENGTH (allocno_reg[allocno_order[i]]) >= 0)\n \t  {"}, {"sha": "8ae0b0aed89d3aaf1f961833fe7b8d32b04939b4", "filename": "gcc/jump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -3328,7 +3328,7 @@ condjump_in_parallel_p (insn)\n \n int\n sets_cc0_p (x)\n-     rtx x;\n+     rtx x ATTRIBUTE_UNUSED;\n {\n #ifdef HAVE_cc0\n   if (GET_CODE (x) == SET && SET_DEST (x) == cc0_rtx)"}, {"sha": "1e6955ac6ca07e9af44547de933d63c3d636495d", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -420,7 +420,7 @@ static int equiv_mem_modified;\n static void\n validate_equiv_mem_from_store (dest, set)\n      rtx dest;\n-     rtx set;\n+     rtx set ATTRIBUTE_UNUSED;\n {\n   if ((GET_CODE (dest) == REG\n        && reg_overlap_mentioned_p (dest, equiv_mem))\n@@ -1858,7 +1858,7 @@ find_free_reg (class, mode, qty, accept_call_clobbered, just_try_suggested,\n \n      This is true of any register that can be eliminated.  */\n #ifdef ELIMINABLE_REGS\n-  for (i = 0; i < sizeof eliminables / sizeof eliminables[0]; i++)\n+  for (i = 0; i < (int)(sizeof eliminables / sizeof eliminables[0]); i++)\n     SET_HARD_REG_BIT (used, eliminables[i].from);\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n   /* If FRAME_POINTER_REGNUM is not a real register, then protect the one"}, {"sha": "792992026dd917c9223113cc0089f2a9ef40bebc", "filename": "gcc/loop.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -3387,7 +3387,6 @@ count_loop_regs_set (from, to, may_not_move, single_usage, count_ptr, nregs)\n   register rtx *last_set = (rtx *) alloca (nregs * sizeof (rtx));\n   register rtx insn;\n   register int count = 0;\n-  register rtx dest;\n \n   bzero ((char *) last_set, nregs * sizeof (rtx));\n   for (insn = from; insn != to; insn = NEXT_INSN (insn))\n@@ -3544,7 +3543,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n      int insn_count;\n      rtx loop_start;\n      rtx loop_end;\n-     int unroll_p, bct_p;\n+     int unroll_p, bct_p ATTRIBUTE_UNUSED;\n {\n   rtx p;\n   rtx set;\n@@ -7871,14 +7870,14 @@ get_condition (jump, earliest)\n       switch (code)\n \t{\n \tcase LE:\n-\t  if (const_val != max_val >> 1)\n+\t  if ((unsigned HOST_WIDE_INT) const_val != max_val >> 1)\n \t    code = LT,\top1 = GEN_INT (const_val + 1);\n \t  break;\n \n \t/* When cross-compiling, const_val might be sign-extended from\n \t   BITS_PER_WORD to HOST_BITS_PER_WIDE_INT */\n \tcase GE:\n-\t  if ((const_val & max_val)\n+\t  if ((HOST_WIDE_INT) (const_val & max_val)\n \t      != (((HOST_WIDE_INT) 1\n \t\t   << (GET_MODE_BITSIZE (GET_MODE (op0)) - 1))))\n \t    code = GT, op1 = GEN_INT (const_val - 1);\n@@ -8249,7 +8248,7 @@ indirect_jump_in_function_p (start)\n static int\n insert_loop_mem (mem, data)\n      rtx *mem;\n-     void *data;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   int i;\n   rtx m = *mem;\n@@ -8339,7 +8338,7 @@ load_mems_and_recount_loop_regs_set (scan_start, end, loop_top, start,\n       old_nregs = nregs;\n       nregs = max_reg_num ();\n \n-      if (nregs > n_times_set->num_elements)\n+      if ((unsigned) nregs > n_times_set->num_elements)\n \t{\n \t  /* Grow all the arrays.  */\n \t  VARRAY_GROW (n_times_set, nregs);"}, {"sha": "73d8caba3903ab95fa50394abd83155f7a346e38", "filename": "gcc/protoize.c", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fprotoize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fprotoize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprotoize.c?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -824,7 +824,7 @@ restore_pointers ()\n \n static int\n is_id_char (ch)\n-     char ch;\n+     unsigned char ch;\n {\n   return (ISALNUM (ch) || (ch == '_') || (ch == '$'));\n }\n@@ -2002,12 +2002,12 @@ munge_compile_params (params_list)\n   temp_params[param_count++] = compiler_file_name;\n   for (;;)\n     {\n-      while (ISSPACE (*params_list))\n+      while (ISSPACE ((const unsigned char)*params_list))\n         params_list++;\n       if (!*params_list)\n         break;\n       param = params_list;\n-      while (*params_list && !ISSPACE (*params_list))\n+      while (*params_list && !ISSPACE ((const unsigned char)*params_list))\n         params_list++;\n       if (param[0] != '-')\n         temp_params[param_count++]\n@@ -2022,9 +2022,10 @@ munge_compile_params (params_list)\n               case 'c':\n                 break;\t\t/* Don't copy these.  */\n               case 'o':\n-                while (ISSPACE (*params_list))\n+                while (ISSPACE ((const unsigned char)*params_list))\n                   params_list++;\n-                while (*params_list && !ISSPACE (*params_list))\n+                while (*params_list\n+\t\t       && !ISSPACE ((const unsigned char)*params_list))\n                   params_list++;\n                 break;\n               default:\n@@ -2287,7 +2288,8 @@ start_over: ;\n   \n     /* Read the aux_info file into memory.  */\n   \n-    if (safe_read (aux_info_file, aux_info_base, aux_info_size) != aux_info_size)\n+    if (safe_read (aux_info_file, aux_info_base, aux_info_size) !=\n+\t(int) aux_info_size)\n       {\n \tint errno_val = errno;\n         fprintf (stderr, \"%s: error reading aux info file `%s': %s\\n\",\n@@ -2955,7 +2957,8 @@ static const char *\n forward_to_next_token_char (ptr)\n      const char *ptr;\n {\n-  for (++ptr; ISSPACE (*ptr); check_source (++ptr < clean_text_limit, 0))\n+  for (++ptr; ISSPACE ((const unsigned char)*ptr);\n+       check_source (++ptr < clean_text_limit, 0))\n     continue;\n   return ptr;\n }\n@@ -3323,7 +3326,7 @@ edit_formals_lists (end_formals, f_list_count, def_dec_p)\n \n       next_end = start_formals - 1;\n       check_source (next_end > clean_read_ptr, 0);\n-      while (ISSPACE (*next_end))\n+      while (ISSPACE ((const unsigned char)*next_end))\n         check_source (--next_end > clean_read_ptr, 0);\n       check_source (*next_end == ')', next_end);\n       check_source (--next_end > clean_read_ptr, 0);\n@@ -3343,7 +3346,8 @@ edit_formals_lists (end_formals, f_list_count, def_dec_p)\n       const char *func_name_limit;\n       size_t func_name_len;\n \n-      for (func_name_limit = start_formals-1; ISSPACE (*func_name_limit); )\n+      for (func_name_limit = start_formals-1;\n+\t   ISSPACE ((const unsigned char)*func_name_limit); )\n         check_source (--func_name_limit > clean_read_ptr, 0);\n \n       for (func_name_start = func_name_limit++;\n@@ -3469,8 +3473,8 @@ find_rightmost_formals_list (clean_text_p)\n \n       while (*end_formals != ')')\n         {\n-          if (ISSPACE (*end_formals))\n-            while (ISSPACE (*end_formals))\n+          if (ISSPACE ((const unsigned char)*end_formals))\n+            while (ISSPACE ((const unsigned char)*end_formals))\n               check_source (--end_formals > clean_read_ptr, 0);\n           else\n             check_source (--end_formals > clean_read_ptr, 0);\n@@ -3488,7 +3492,7 @@ find_rightmost_formals_list (clean_text_p)\n          by an alphabetic character, while others *cannot* validly be followed\n          by such characters.  */\n \n-      if ((ch == '{') || ISALPHA (ch))\n+      if ((ch == '{') || ISALPHA ((unsigned char)ch))\n         break;\n \n       /* At this point, we have found a right paren, but we know that it is\n@@ -3584,7 +3588,7 @@ add_local_decl (def_dec_p, clean_text_p)\n        We can now just scan backwards and find the left end of the existing\n        indentation string, and then copy it to the output buffer.  */\n \n-    for (sp = ep; ISSPACE (*sp) && *sp != '\\n'; sp--)\n+    for (sp = ep; ISSPACE ((const unsigned char)*sp) && *sp != '\\n'; sp--)\n       continue;\n \n     /* Now write out the open { which began this block, and any following\n@@ -3665,7 +3669,7 @@ add_global_decls (file_p, clean_text_p)\n      header.  We will put in the added declarations just prior to that.  */\n \n   scan_p++;\n-  while (ISSPACE (*scan_p))\n+  while (ISSPACE ((const unsigned char)*scan_p))\n     scan_p++;\n   scan_p--;\n \n@@ -3834,7 +3838,7 @@ edit_fn_definition (def_dec_p, clean_text_p)\n           {\n             have_newlines |= (*scan_orig == '\\n');\n             /* Leave identical whitespace alone.  */\n-            if (!ISSPACE (*scan_orig))\n+            if (!ISSPACE ((const unsigned char)*scan_orig))\n               *((NONCONST char *)scan_orig) = ' '; /* identical - so whiteout */\n           }\n         else\n@@ -3878,7 +3882,7 @@ do_cleaning (new_clean_text_base, new_clean_text_limit)\n             scan_p += 2;\n             while (scan_p[1] != '/' || scan_p[0] != '*')\n               {\n-                if (!ISSPACE (*scan_p))\n+                if (!ISSPACE ((const unsigned char)*scan_p))\n                   *scan_p = ' ';\n                 if (++scan_p >= new_clean_text_limit)\n                   abort ();\n@@ -3893,7 +3897,7 @@ do_cleaning (new_clean_text_base, new_clean_text_limit)\n             *scan_p = ' ';\n             while (scan_p[1] != '\\n' || scan_p[0] == '\\\\')\n               {\n-                if (!ISSPACE (*scan_p))\n+                if (!ISSPACE ((const unsigned char)*scan_p))\n                   *scan_p = ' ';\n                 if (++scan_p >= new_clean_text_limit)\n                   abort ();\n@@ -3905,9 +3909,10 @@ do_cleaning (new_clean_text_base, new_clean_text_limit)\n             non_whitespace_since_newline = 1;\n             while (scan_p[1] != '\\'' || scan_p[0] == '\\\\')\n               {\n-                if (scan_p[0] == '\\\\' && !ISSPACE (scan_p[1]))\n+                if (scan_p[0] == '\\\\'\n+\t\t    && !ISSPACE ((const unsigned char)scan_p[1]))\n                   scan_p[1] = ' ';\n-                if (!ISSPACE (*scan_p))\n+                if (!ISSPACE ((const unsigned char)*scan_p))\n                   *scan_p = ' ';\n                 if (++scan_p >= new_clean_text_limit)\n                   abort ();\n@@ -3919,14 +3924,15 @@ do_cleaning (new_clean_text_base, new_clean_text_limit)\n             non_whitespace_since_newline = 1;\n             while (scan_p[1] != '\"' || scan_p[0] == '\\\\')\n               {\n-                if (scan_p[0] == '\\\\' && !ISSPACE (scan_p[1]))\n+                if (scan_p[0] == '\\\\'\n+\t\t    && !ISSPACE ((const unsigned char)scan_p[1]))\n                   scan_p[1] = ' ';\n-                if (!ISSPACE (*scan_p))\n+                if (!ISSPACE ((const unsigned char)*scan_p))\n                   *scan_p = ' ';\n                 if (++scan_p >= new_clean_text_limit)\n                   abort ();\n               }\n-\t    if (!ISSPACE (*scan_p))\n+\t    if (!ISSPACE ((const unsigned char)*scan_p))\n \t      *scan_p = ' ';\n \t    scan_p++;\n             break;\n@@ -4019,12 +4025,12 @@ scan_for_missed_items (file_p)\n \n           last_r_paren = scan_p;\n \n-          for (ahead_p = scan_p + 1; ISSPACE (*ahead_p); )\n+          for (ahead_p = scan_p + 1; ISSPACE ((const unsigned char)*ahead_p); )\n             check_source (++ahead_p < limit, limit);\n \n           scan_p = ahead_p - 1;\n \n-          if (ISALPHA (*ahead_p) || *ahead_p == '{')\n+          if (ISALPHA ((const unsigned char)*ahead_p) || *ahead_p == '{')\n             {\n               const char *last_l_paren;\n               const int lineno = identify_lineno (ahead_p);\n@@ -4038,7 +4044,8 @@ scan_for_missed_items (file_p)\n               do\n                 {\n                   last_l_paren = careful_find_l_paren (last_r_paren);\n-                  for (last_r_paren = last_l_paren-1; ISSPACE (*last_r_paren); )\n+                  for (last_r_paren = last_l_paren-1;\n+\t\t       ISSPACE ((const unsigned char)*last_r_paren); )\n                     check_source (--last_r_paren >= backup_limit, backup_limit);\n                 }\n               while (*last_r_paren == ')');\n@@ -4219,7 +4226,8 @@ edit_file (hp)\n        in one swell fwoop.  Then figure out where the end of the text is and\n        make sure that it ends with a newline followed by a null.  */\n \n-    if (safe_read (input_file, new_orig_text_base, orig_size) != orig_size)\n+    if (safe_read (input_file, new_orig_text_base, orig_size) !=\n+\t(int) orig_size)\n       {\n \tint errno_val = errno;\n         close (input_file);\n@@ -4677,7 +4685,8 @@ main (argc, argv)\n   {\n     const char *cp;\n \n-    for (cp = varargs_style_indicator; ISALNUM (*cp) || *cp == '_'; cp++)\n+    for (cp = varargs_style_indicator;\n+\t ISALNUM ((const unsigned char)*cp) || *cp == '_'; cp++)\n       continue;\n     if (*cp != 0)\n       varargs_style_indicator = savestring (varargs_style_indicator,"}, {"sha": "97eccbcf6c173219f6a0942d903cb9e01a3c3cc9", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -1011,7 +1011,7 @@ immediate_operand (op, mode)\n int\n const_int_operand (op, mode)\n      register rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return GET_CODE (op) == CONST_INT;\n }"}, {"sha": "601b2f797a6b9caaf405ae583c1c7fdd381150f6", "filename": "gcc/regclass.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -1134,7 +1134,7 @@ record_reg_classes (n_alts, n_ops, ops, modes, constraints, insn)\n \t  enum machine_mode mode = modes[i];\n \t  int allows_mem = 0;\n \t  int win = 0;\n-\t  char c;\n+\t  unsigned char c;\n \n \t  /* If this operand has no constraints at all, we can conclude \n \t     nothing about it since anything is valid.  */\n@@ -1394,7 +1394,7 @@ record_reg_classes (n_alts, n_ops, ops, modes, constraints, insn)\n \n \t\t  if (prefclass)\n \t\t    alt_cost\n-\t\t      += may_move_cost[prefclass[REGNO (op)]][(int) classes[i]];\n+\t\t      += may_move_cost[(unsigned char)prefclass[REGNO (op)]][(int) classes[i]];\n \t\t}\n \t    }\n \n@@ -1466,9 +1466,9 @@ record_reg_classes (n_alts, n_ops, ops, modes, constraints, insn)\n \t  int nr;\n \n \t  if (regno >= FIRST_PSEUDO_REGISTER && prefclass != 0\n-\t      && (reg_class_size[prefclass[regno]]\n+\t      && (reg_class_size[(unsigned char)prefclass[regno]]\n \t\t  == CLASS_MAX_NREGS (prefclass[regno], mode)))\n-\t    op_costs[i].cost[prefclass[regno]] = -1;\n+\t    op_costs[i].cost[(unsigned char)prefclass[regno]] = -1;\n \t  else if (regno < FIRST_PSEUDO_REGISTER)\n \t    for (class = 0; class < N_REG_CLASSES; class++)\n \t      if (TEST_HARD_REG_BIT (reg_class_contents[class], regno)"}, {"sha": "1e438e17b318a031bc6b92502bd42c35ebf9114d", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -445,7 +445,7 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n       char insn_letter = insn_operand_constraint[(int) icode][!in_p][in_p];\n       enum reg_class insn_class\n \t= (insn_letter == 'r' ? GENERAL_REGS\n-\t   : REG_CLASS_FROM_LETTER (insn_letter));\n+\t   : REG_CLASS_FROM_LETTER ((unsigned char) insn_letter));\n \n       if (insn_class == NO_REGS\n \t  || (in_p && insn_operand_constraint[(int) icode][!in_p][0] != '=')\n@@ -462,7 +462,7 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n \t  class = insn_class;\n \t  t_mode = insn_operand_mode[(int) icode][2];\n \t  t_class = (t_letter == 'r' ? GENERAL_REGS\n-\t\t     : REG_CLASS_FROM_LETTER (t_letter));\n+\t\t     : REG_CLASS_FROM_LETTER ((unsigned char) t_letter));\n \t  t_icode = icode;\n \t  icode = CODE_FOR_nothing;\n \t}"}, {"sha": "36fb75b4ca8282cfe824f9c241b6fa6dbf8169d4", "filename": "gcc/reload1.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -1651,10 +1651,10 @@ calculate_needs (chain, avoid_return_reg, global)\n \t}\n       else if (size == 1)\n \t{\n-\t  this_needs->regs[reload_nongroup[i]][(int) class] += 1;\n+\t  this_needs->regs[(unsigned char)reload_nongroup[i]][(int) class] += 1;\n \t  p = reg_class_superclasses[(int) class];\n \t  while (*p != LIM_REG_CLASSES)\n-\t    this_needs->regs[reload_nongroup[i]][(int) *p++] += 1;\n+\t    this_needs->regs[(unsigned char)reload_nongroup[i]][(int) *p++] += 1;\n \t}\n       else\n \tabort ();\n@@ -2666,7 +2666,7 @@ set_label_offsets (x, insn, initial_p)\n {\n   enum rtx_code code = GET_CODE (x);\n   rtx tem;\n-  int i;\n+  unsigned int i;\n   struct elim_table *p;\n \n   switch (code)\n@@ -2749,7 +2749,7 @@ set_label_offsets (x, insn, initial_p)\n \t offsets.  We want the first field for ADDR_VEC and the second\n \t field for ADDR_DIFF_VEC.  */\n \n-      for (i = 0; i < XVECLEN (x, code == ADDR_DIFF_VEC); i++)\n+      for (i = 0; i < (unsigned) XVECLEN (x, code == ADDR_DIFF_VEC); i++)\n \tset_label_offsets (XVECEXP (x, code == ADDR_DIFF_VEC, i),\n \t\t\t   insn, initial_p);\n       return;\n@@ -3669,7 +3669,7 @@ mark_not_eliminable (dest, x)\n      rtx dest;\n      rtx x;\n {\n-  register int i;\n+  register unsigned int i;\n \n   /* A SUBREG of a hard register here is just changing its mode.  We should\n      not see a SUBREG of an eliminable hard register, but check just in\n@@ -4043,7 +4043,7 @@ hard_reg_use_compare (p1p, p2p)\n static void\n order_regs_for_reload ()\n {\n-  register int i;\n+  register unsigned int i;\n   register int o = 0;\n   int large = 0;\n \n@@ -4063,7 +4063,7 @@ order_regs_for_reload ()\n       hard_reg_n_uses[i].regno = i;\n     }\n \n-  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n+  for (i = FIRST_PSEUDO_REGISTER; i < (unsigned) max_regno; i++)\n     {\n       int regno = reg_renumber[i];\n       if (regno >= 0)\n@@ -4186,7 +4186,7 @@ reload_as_needed (live_known)\n \n   /* Reset all offsets on eliminable registers to their initial values.  */\n #ifdef ELIMINABLE_REGS\n-  for (i = 0; i < NUM_ELIMINABLE_REGS; i++)\n+  for (i = 0; i < (int) NUM_ELIMINABLE_REGS; i++)\n     {\n       INITIAL_ELIMINATION_OFFSET (reg_eliminate[i].from, reg_eliminate[i].to,\n \t\t\t\t  reg_eliminate[i].initial_offset);\n@@ -4220,7 +4220,7 @@ reload_as_needed (live_known)\n       if (GET_CODE (insn) == CODE_LABEL)\n \t{\n \t  num_not_at_initial_offset = 0;\n-\t  for (i = 0; i < NUM_ELIMINABLE_REGS; i++)\n+\t  for (i = 0; i < (int) NUM_ELIMINABLE_REGS; i++)\n \t    {\n \t      reg_eliminate[i].offset = reg_eliminate[i].previous_offset\n \t\t= offsets_at[CODE_LABEL_NUMBER (insn)][i];\n@@ -6163,7 +6163,9 @@ choose_reload_regs (chain, avoid_return_reg)\n       if (j == n_reloads)\n \tbreak;\n \n+#if 0\n     fail:\n+#endif\n       /* Loop around and try without any inheritance.  */\n       /* First undo everything done by the failed attempt\n \t to allocate with inheritance.  */\n@@ -9016,7 +9018,7 @@ reload_cse_simplify_operands (insn)\n \n \t\tdefault:\n \t\t  class\n-\t\t    = reg_class_subunion[(int) class][(int) REG_CLASS_FROM_LETTER (c)];\n+\t\t    = reg_class_subunion[(int) class][(int) REG_CLASS_FROM_LETTER ((unsigned char)c)];\n \t\t  break;\n \n \t\tcase ',': case '\\0':\n@@ -9546,7 +9548,7 @@ reload_combine ()\n    The second argument, SET, is ignored.  */\n static void\n reload_combine_note_store (dst, set)\n-     rtx dst, set;\n+     rtx dst, set ATTRIBUTE_UNUSED;\n {\n   int regno = 0;\n   int i;\n@@ -9562,7 +9564,7 @@ reload_combine_note_store (dst, set)\n   regno += REGNO (dst);\n   /* note_stores might have stripped a STRICT_LOW_PART, so we have to be\n      careful with registers / register parts that are not full words.  */\n-  if (size < UNITS_PER_WORD)\n+  if (size < (unsigned) UNITS_PER_WORD)\n     reg_state[regno].use_index = -1;\n   else\n     {\n@@ -9799,7 +9801,6 @@ reload_cse_move2add (first)\n \t\t      && XEXP (SET_SRC (set), 0) == reg\n \t\t      && GET_CODE (XEXP (SET_SRC (set), 1)) == CONST_INT)\n \t\t    {\n-\t\t      rtx src2 = SET_SRC (set);\n \t\t      rtx src3 = XEXP (SET_SRC (set), 1);\n \t\t      rtx new_src = GEN_INT (INTVAL (src3)\n \t\t\t\t\t     - INTVAL (reg_offset[regno]));"}, {"sha": "78b879ff97b495c13a363bf0dbd68381c329dcbc", "filename": "gcc/sched.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -126,6 +126,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"insn-config.h\"\n #include \"insn-attr.h\"\n+#include \"recog.h\"\n \n #ifndef INSN_SCHEDULING\n void\n@@ -325,7 +326,7 @@ static void sched_analyze_1\t\tPROTO((rtx, rtx));\n static void sched_analyze_2\t\tPROTO((rtx, rtx));\n static void sched_analyze_insn\t\tPROTO((rtx, rtx, rtx));\n static int sched_analyze\t\tPROTO((rtx, rtx));\n-static void sched_note_set\t\tPROTO((int, rtx, int));\n+static void sched_note_set\t\tPROTO((rtx, int));\n static int rank_for_schedule\t\tPROTO((const GENERIC_PTR, const GENERIC_PTR));\n static void swap_sort\t\t\tPROTO((rtx *, int));\n static void queue_insn\t\t\tPROTO((rtx, int));\n@@ -342,7 +343,7 @@ static void finish_sometimes_live\tPROTO((struct sometimes *, int));\n static rtx reemit_notes\t\t\tPROTO((rtx, rtx));\n static void schedule_block\t\tPROTO((int, FILE *));\n static rtx regno_use_in\t\t\tPROTO((int, rtx));\n-static void split_hard_reg_notes\tPROTO((rtx, rtx, rtx, rtx));\n+static void split_hard_reg_notes\tPROTO((rtx, rtx, rtx));\n static void new_insn_dead_notes\t\tPROTO((rtx, rtx, rtx, rtx));\n static void update_n_sets\t\tPROTO((rtx, int));\n static void update_flow_info\t\tPROTO((rtx, rtx, rtx, rtx));\n@@ -606,7 +607,7 @@ blockage_range (unit, insn)\n   unsigned int blockage = INSN_BLOCKAGE (insn);\n   unsigned int range;\n \n-  if (UNIT_BLOCKED (blockage) != unit + 1)\n+  if ((int) UNIT_BLOCKED (blockage) != unit + 1)\n     {\n       range = function_units[unit].blockage_range_function (insn);\n       /* We only cache the blockage range for one unit and then only if\n@@ -1762,8 +1763,7 @@ sched_analyze (head, tail)\n    are scanning forwards.  Mark that register as being born.  */\n \n static void\n-sched_note_set (b, x, death)\n-     int b;\n+sched_note_set (x, death)\n      rtx x;\n      int death;\n {\n@@ -2926,20 +2926,20 @@ schedule_block (b, file)\n \t\t   a register must be marked as dead after this insn.  */\n \t\tif (GET_CODE (PATTERN (insn)) == SET\n \t\t    || GET_CODE (PATTERN (insn)) == CLOBBER)\n-\t\t  sched_note_set (b, PATTERN (insn), 0);\n+\t\t  sched_note_set (PATTERN (insn), 0);\n \t\telse if (GET_CODE (PATTERN (insn)) == PARALLEL)\n \t\t  {\n \t\t    int j;\n \t\t    for (j = XVECLEN (PATTERN (insn), 0) - 1; j >= 0; j--)\n \t\t      if (GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == SET\n \t\t\t  || GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == CLOBBER)\n-\t\t\tsched_note_set (b, XVECEXP (PATTERN (insn), 0, j), 0);\n+\t\t\tsched_note_set (XVECEXP (PATTERN (insn), 0, j), 0);\n \n \t\t    /* ??? This code is obsolete and should be deleted.  It\n \t\t       is harmless though, so we will leave it in for now.  */\n \t\t    for (j = XVECLEN (PATTERN (insn), 0) - 1; j >= 0; j--)\n \t\t      if (GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == USE)\n-\t\t\tsched_note_set (b, XVECEXP (PATTERN (insn), 0, j), 0);\n+\t\t\tsched_note_set (XVECEXP (PATTERN (insn), 0, j), 0);\n \t\t  }\n \n \t\t/* Each call clobbers (makes live) all call-clobbered regs\n@@ -3036,20 +3036,20 @@ schedule_block (b, file)\n \t     must be marked as dead after this insn.  */\n \t  if (GET_CODE (PATTERN (insn)) == SET\n \t      || GET_CODE (PATTERN (insn)) == CLOBBER)\n-\t    sched_note_set (b, PATTERN (insn), 0);\n+\t    sched_note_set (PATTERN (insn), 0);\n \t  else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n \t    {\n \t      int j;\n \t      for (j = XVECLEN (PATTERN (insn), 0) - 1; j >= 0; j--)\n \t\tif (GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == SET\n \t\t    || GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == CLOBBER)\n-\t\t  sched_note_set (b, XVECEXP (PATTERN (insn), 0, j), 0);\n+\t\t  sched_note_set (XVECEXP (PATTERN (insn), 0, j), 0);\n \n \t      /* ??? This code is obsolete and should be deleted.  It\n \t\t is harmless though, so we will leave it in for now.  */\n \t      for (j = XVECLEN (PATTERN (insn), 0) - 1; j >= 0; j--)\n \t\tif (GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == USE)\n-\t\t  sched_note_set (b, XVECEXP (PATTERN (insn), 0, j), 0);\n+\t\t  sched_note_set (XVECEXP (PATTERN (insn), 0, j), 0);\n \t    }\n \n \t  /* Each call clobbers (makes live) all call-clobbered regs that are\n@@ -3279,14 +3279,14 @@ schedule_block (b, file)\n \t      /* See if this is the last notice we must take of a register.  */\n \t      if (GET_CODE (PATTERN (insn)) == SET\n \t\t  || GET_CODE (PATTERN (insn)) == CLOBBER)\n-\t\tsched_note_set (b, PATTERN (insn), 1);\n+\t\tsched_note_set (PATTERN (insn), 1);\n \t      else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n \t\t{\n \t\t  int j;\n \t\t  for (j = XVECLEN (PATTERN (insn), 0) - 1; j >= 0; j--)\n \t\t    if (GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == SET\n \t\t\t|| GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == CLOBBER)\n-\t\t      sched_note_set (b, XVECEXP (PATTERN (insn), 0, j), 1);\n+\t\t      sched_note_set (XVECEXP (PATTERN (insn), 0, j), 1);\n \t\t}\n \t      \n \t      /* This code keeps life analysis information up to date.  */\n@@ -3593,8 +3593,8 @@ regno_use_in (regno, x)\n    several smaller hard register references in the split insns.  */\n \n static void\n-split_hard_reg_notes (note, first, last, orig_insn)\n-     rtx note, first, last, orig_insn;\n+split_hard_reg_notes (note, first, last)\n+  rtx note, first, last;\n {\n   rtx reg, temp, link;\n   int n_regs, i, new_reg;\n@@ -3823,7 +3823,7 @@ update_flow_info (notes, first, last, orig_insn)\n \t\t      && GET_CODE (temp) == REG\n \t\t      && REGNO (temp) < FIRST_PSEUDO_REGISTER\n \t\t      && HARD_REGNO_NREGS (REGNO (temp), GET_MODE (temp)) > 1)\n-\t\t    split_hard_reg_notes (note, first, last, orig_insn);\n+\t\t    split_hard_reg_notes (note, first, last);\n \t\t  else\n \t\t    {\n \t\t      XEXP (note, 1) = REG_NOTES (insn);"}, {"sha": "8af1e3cc093e4b59bcb60e7781b28dec0302bf87", "filename": "gcc/stupid.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fstupid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Fstupid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstupid.c?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -497,7 +497,7 @@ stupid_find_reg (call_preserved, class, mode,\n      enum reg_class class;\n      enum machine_mode mode;\n      int born_insn, dead_insn;\n-     int changes_size;\n+     int changes_size ATTRIBUTE_UNUSED;\n {\n   register int i, ins;\n #ifdef HARD_REG_SET\n@@ -519,7 +519,7 @@ stupid_find_reg (call_preserved, class, mode,\n \t\t     call_preserved ? call_used_reg_set : fixed_reg_set);\n \n #ifdef ELIMINABLE_REGS\n-  for (i = 0; i < sizeof eliminables / sizeof eliminables[0]; i++)\n+  for (i = 0; i < (int)(sizeof eliminables / sizeof eliminables[0]); i++)\n     SET_HARD_REG_BIT (used, eliminables[i].from);\n #if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n   SET_HARD_REG_BIT (used, HARD_FRAME_POINTER_REGNUM);"}, {"sha": "034fe52a0e9b60a2ebf963c3c9668b177e887d92", "filename": "gcc/unroll.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e51712db0d3b7be32ee93fd12090a43acc29c9d8/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=e51712db0d3b7be32ee93fd12090a43acc29c9d8", "patch": "@@ -198,7 +198,7 @@ enum rtx_code loop_comparison_code;\n /* Forward declarations.  */\n \n static void init_reg_map PROTO((struct inline_remap *, int));\n-static int precondition_loop_p PROTO((rtx *, rtx *, rtx *, rtx, rtx));\n+static int precondition_loop_p PROTO((rtx *, rtx *, rtx *, rtx));\n static rtx calculate_giv_inc PROTO((rtx, rtx, int));\n static rtx initial_reg_note_copy PROTO((rtx, struct inline_remap *));\n static void final_reg_note_copy PROTO((rtx, struct inline_remap *));\n@@ -858,7 +858,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n       rtx initial_value, final_value, increment;\n \n       if (precondition_loop_p (&initial_value, &final_value, &increment,\n-\t\t\t       loop_start, loop_end))\n+\t\t\t       loop_start))\n \t{\n \t  register rtx diff ;\n \t  enum machine_mode mode;\n@@ -1319,10 +1319,9 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n    whether divide is cheap.  */\n \n static int\n-precondition_loop_p (initial_value, final_value, increment, loop_start,\n-\t\t     loop_end)\n+precondition_loop_p (initial_value, final_value, increment, loop_start)\n      rtx *initial_value, *final_value, *increment;\n-     rtx loop_start, loop_end;\n+     rtx loop_start;\n {\n \n   if (loop_n_iterations > 0)"}]}