{"sha": "43940f6bb9f83f8b0784a485914d090118cc225d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM5NDBmNmJiOWY4M2Y4YjA3ODRhNDg1OTE0ZDA5MDExOGNjMjI1ZA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-01-10T22:59:50Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-01-10T22:59:50Z"}, "message": "pa.c (output_global_address): Handle (high (const (plus ...))).\n\n\t* pa.c (output_global_address): Handle (high (const (plus ...))).\n\t(secondary_reload_class): If TARGET_KERNEL, then loading a\n\tsymbolic address, or the high part of a symbolic address requires\n\t%r1 as a secondary reload register.\n\t(emit_move_sequence, SYMBOL_REF case): If TARGET_KERNEL, then handle\n\tsecondary reload created for a symbolic (high (const (plus ...))).\n\tNo longer show DP relocation; read_only and normal operands emit the\n\tsame RTL now.\n\tEmit the same RTL before and after reload, only change how the\n\tscratch/temporary register is chosen.\n\nFrom-SVN: r3186", "tree": {"sha": "755b648ffaf74ea489490a9fe767524db22ced29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/755b648ffaf74ea489490a9fe767524db22ced29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43940f6bb9f83f8b0784a485914d090118cc225d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43940f6bb9f83f8b0784a485914d090118cc225d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43940f6bb9f83f8b0784a485914d090118cc225d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43940f6bb9f83f8b0784a485914d090118cc225d/comments", "author": null, "committer": null, "parents": [{"sha": "9f309ba3e7ae686cd3e193722eb43e28e9d83018", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f309ba3e7ae686cd3e193722eb43e28e9d83018", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f309ba3e7ae686cd3e193722eb43e28e9d83018"}], "stats": {"total": 86, "additions": 40, "deletions": 46}, "files": [{"sha": "4280a6972ac271912b2dd56ce8187adc8ef444c8", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 40, "deletions": 46, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43940f6bb9f83f8b0784a485914d090118cc225d/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43940f6bb9f83f8b0784a485914d090118cc225d/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=43940f6bb9f83f8b0784a485914d090118cc225d", "patch": "@@ -594,8 +594,18 @@ emit_move_sequence (operands, mode, scratch_reg)\n     }\n \n   /* Simplify the source if we need to.  */\n-  if (GET_CODE (operand1) != HIGH && immediate_operand (operand1, mode))\n+  if (GET_CODE (operand1) != HIGH && immediate_operand (operand1, mode)\n+      || (GET_CODE (operand1) == HIGH\n+\t  && symbolic_operand (XEXP (operand1, 0), mode)\n+\t  && TARGET_KERNEL))\n     {\n+      int ishighonly = 0;\n+\n+      if (GET_CODE (operand1) == HIGH)\n+\t{\n+\t  ishighonly = 1;\n+\t  operand1 = XEXP (operand1, 0);\n+\t}\n       if (symbolic_operand (operand1, mode))\n \t{\n \t  if (flag_pic)\n@@ -604,15 +614,26 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t      operands[1] = legitimize_pic_address (operand1, mode, temp);\n \t    }\n \t  /* On the HPPA, references to data space are supposed to */\n-\t  /* use dp, register 27. */\n-\t  else if (read_only_operand (operand1))\n+\t  /* use dp, register 27, but showing it in the RTL inhibits various\n+\t     cse and loop optimizations.  */\n+\t  else \n \t    {\n-\t      rtx set = gen_rtx (SET, VOIDmode,\n-\t\t\t\t  operand0,\n-\t\t\t\t  gen_rtx (LO_SUM, mode, operand0, operand1));\n+\t      rtx temp, set;\n+\n+\t      if (reload_in_progress) \n+\t\ttemp = scratch_reg ? scratch_reg : operand0;\n+\t      else\n+\t\ttemp = gen_reg_rtx (mode);\n+\n+\t      if (ishighonly)\n+\t\tset = gen_rtx (SET, mode, operand0, temp);\n+\t      else\n+\t\tset = gen_rtx (SET, VOIDmode,\n+\t\t\t       operand0,\n+\t\t\t       gen_rtx (LO_SUM, mode, temp, operand1));\n \t\t\t\t \n \t      emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t\t  operand0,\n+\t\t\t\t  temp,\n \t\t\t\t  gen_rtx (HIGH, mode, operand1)));\n \t      if (TARGET_SHARED_LIBS\n \t\t  && function_label_operand (operand1, mode))\n@@ -631,45 +652,7 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t\temit_insn (set);\n \t      return 1;\n \t    }\n-\t  else\n-\t    {\n-\t      /* If reload_in_progress, we can't use addil and r1; we */\n-\t      /* have to use the more expensive ldil sequence. */\n-\t      if (reload_in_progress)\n-\t\t{\n-\t\t  emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t\t      operand0,\n-\t\t\t\t      gen_rtx (HIGH, mode, operand1)));\n-\t\t  emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t\t      operand0,\n-\t\t\t\t      gen_rtx (PLUS, mode,\n-\t\t\t\t\t       operand0,\n-\t\t\t\t\t       gen_rtx (REG, mode, 27))));\n-\t\t  emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t\t      operand0,\n-\t\t\t\t      gen_rtx (LO_SUM, mode,\n-\t\t\t\t\t       operand0, operand1)));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  rtx temp1, temp2 = gen_reg_rtx (mode);\n-\n-\t\t  /* For 2.4 we could set RTX_UNCHANGING and add a \n-\t\t     REG_EQUAL note for the first insn.  This would \n-\t\t     allow the first insn to be moved out of loops.  */\n-\t\t  temp1 = gen_rtx (HIGH, mode, operand1);\n-\t\t  emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t\t      temp2,\n-\t\t\t\t      gen_rtx (PLUS, mode,\n-\t\t\t\t\t       gen_rtx (REG, mode, 27),\n-\t\t\t\t\t       temp1)));\n-\t\t  emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t\t      operand0,\n-\t\t\t\t      gen_rtx (LO_SUM, mode,\n-\t\t\t\t\t       temp2, operand1)));\n-\t\t}\n-\t      return 1;\n-\t    }\n+\t  return 1;\n \t}\n       else if (depi_cint_operand (operand1, VOIDmode))\n \treturn 0;\n@@ -2097,6 +2080,11 @@ output_global_address (file, x)\n      FILE *file;\n      rtx x;\n {\n+\n+  /* Imagine  (high (const (plus ...))).  */\n+  if (GET_CODE (x) == HIGH)\n+    x = XEXP (x, 0);\n+\n   if (GET_CODE (x) == SYMBOL_REF && read_only_operand (x))\n     assemble_name (file, XSTR (x, 0));\n   else if (GET_CODE (x) == SYMBOL_REF)\n@@ -2428,6 +2416,12 @@ secondary_reload_class (class, mode, in)\n       || (class == SHIFT_REGS && (regno <= 0 || regno >= 32)))\n     return GENERAL_REGS;\n \n+  if (GET_CODE (in) == HIGH)\n+    in = XEXP (in, 0);\n+\n+  if (TARGET_KERNEL && class != R1_REGS && symbolic_operand (in, VOIDmode))\n+    return R1_REGS;\n+\n   return NO_REGS;\n }\n "}]}