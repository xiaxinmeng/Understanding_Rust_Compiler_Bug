{"sha": "b4206259f10455603e0c90825566de1ea777c04a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQyMDYyNTlmMTA0NTU2MDNlMGM5MDgyNTU2NmRlMWVhNzc3YzA0YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:10:53Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:10:53Z"}, "message": "[20/77] Replace MODE_INT checks with is_int_mode\n\nReplace checks of \"GET_MODE_CLASS (...) == MODE_INT\" with\n\"is_int_mode (..., &var)\", in cases where it becomes useful\nto refer to the mode as a scalar_int_mode.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* machmode.h (is_int_mode): New fuction.\n\t* combine.c (find_split_point): Use it.\n\t(combine_simplify_rtx): Likewise.\n\t(simplify_if_then_else): Likewise.\n\t(simplify_set): Likewise.\n\t(simplify_shift_const_1): Likewise.\n\t(simplify_comparison): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_rtx_costs): Likewise.\n\t* cse.c (notreg_cost): Likewise.\n\t(cse_insn): Likewise.\n\t* cselib.c (cselib_lookup_1): Likewise.\n\t* dojump.c (do_jump_1): Likewise.\n\t(do_compare_rtx_and_jump): Likewise.\n\t* dse.c (get_call_args): Likewise.\n\t* dwarf2out.c (rtl_for_decl_init): Likewise.\n\t(native_encode_initializer): Likewise.\n\t* expmed.c (emit_store_flag_1): Likewise.\n\t(emit_store_flag): Likewise.\n\t* expr.c (convert_modes): Likewise.\n\t(store_field): Likewise.\n\t(expand_expr_real_1): Likewise.\n\t* fold-const.c (fold_read_from_constant_string): Likewise.\n\t* gimple-ssa-sprintf.c (get_format_string): Likewise.\n\t* optabs-libfuncs.c (gen_int_libfunc): Likewise.\n\t* optabs.c (expand_binop): Likewise.\n\t(expand_unop): Likewise.\n\t(expand_abs_nojump): Likewise.\n\t(expand_one_cmpl_abs_nojump): Likewise.\n\t* simplify-rtx.c (mode_signbit_p): Likewise.\n\t(val_signbit_p): Likewise.\n\t(val_signbit_known_set_p): Likewise.\n\t(val_signbit_known_clear_p): Likewise.\n\t(simplify_relational_operation_1): Likewise.\n\t* tree.c (vector_type_mode): Likewise.\n\ngcc/go/\n\t* go-lang.c (go_langhook_type_for_mode): Use is_int_mode.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251472", "tree": {"sha": "7511466ff26d775b7a754d24ae68485928d10a95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7511466ff26d775b7a754d24ae68485928d10a95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4206259f10455603e0c90825566de1ea777c04a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4206259f10455603e0c90825566de1ea777c04a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4206259f10455603e0c90825566de1ea777c04a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4206259f10455603e0c90825566de1ea777c04a/comments", "author": null, "committer": null, "parents": [{"sha": "f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f67f4dfffe08b1cea5de407e35e03dd38b64fcd3"}], "stats": {"total": 697, "additions": 400, "deletions": 297}, "files": [{"sha": "654ea7e3e1eb09e5b4bdbf768ec32a2f8e7c74e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4206259f10455603e0c90825566de1ea777c04a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4206259f10455603e0c90825566de1ea777c04a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4206259f10455603e0c90825566de1ea777c04a", "patch": "@@ -1,3 +1,42 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* machmode.h (is_int_mode): New fuction.\n+\t* combine.c (find_split_point): Use it.\n+\t(combine_simplify_rtx): Likewise.\n+\t(simplify_if_then_else): Likewise.\n+\t(simplify_set): Likewise.\n+\t(simplify_shift_const_1): Likewise.\n+\t(simplify_comparison): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_rtx_costs): Likewise.\n+\t* cse.c (notreg_cost): Likewise.\n+\t(cse_insn): Likewise.\n+\t* cselib.c (cselib_lookup_1): Likewise.\n+\t* dojump.c (do_jump_1): Likewise.\n+\t(do_compare_rtx_and_jump): Likewise.\n+\t* dse.c (get_call_args): Likewise.\n+\t* dwarf2out.c (rtl_for_decl_init): Likewise.\n+\t(native_encode_initializer): Likewise.\n+\t* expmed.c (emit_store_flag_1): Likewise.\n+\t(emit_store_flag): Likewise.\n+\t* expr.c (convert_modes): Likewise.\n+\t(store_field): Likewise.\n+\t(expand_expr_real_1): Likewise.\n+\t* fold-const.c (fold_read_from_constant_string): Likewise.\n+\t* gimple-ssa-sprintf.c (get_format_string): Likewise.\n+\t* optabs-libfuncs.c (gen_int_libfunc): Likewise.\n+\t* optabs.c (expand_binop): Likewise.\n+\t(expand_unop): Likewise.\n+\t(expand_abs_nojump): Likewise.\n+\t(expand_one_cmpl_abs_nojump): Likewise.\n+\t* simplify-rtx.c (mode_signbit_p): Likewise.\n+\t(val_signbit_p): Likewise.\n+\t(val_signbit_known_set_p): Likewise.\n+\t(val_signbit_known_clear_p): Likewise.\n+\t(simplify_relational_operation_1): Likewise.\n+\t* tree.c (vector_type_mode): Likewise.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "39c26feb24aacaa3447d3e0dbe4432562068d14e", "filename": "gcc/combine.c", "status": "modified", "additions": 108, "deletions": 102, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=b4206259f10455603e0c90825566de1ea777c04a", "patch": "@@ -4791,6 +4791,7 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n   HOST_WIDE_INT pos = 0;\n   int unsignedp = 0;\n   rtx inner = NULL_RTX;\n+  scalar_int_mode inner_mode;\n \n   /* First special-case some codes.  */\n   switch (code)\n@@ -5032,12 +5033,12 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n \t  /* We can't optimize if either mode is a partial integer\n \t     mode as we don't know how many bits are significant\n \t     in those modes.  */\n-\t  if (GET_MODE_CLASS (GET_MODE (inner)) == MODE_PARTIAL_INT\n+\t  if (!is_int_mode (GET_MODE (inner), &inner_mode)\n \t      || GET_MODE_CLASS (GET_MODE (SET_SRC (x))) == MODE_PARTIAL_INT)\n \t    break;\n \n \t  pos = 0;\n-\t  len = GET_MODE_PRECISION (GET_MODE (inner));\n+\t  len = GET_MODE_PRECISION (inner_mode);\n \t  unsignedp = 0;\n \t  break;\n \n@@ -5560,6 +5561,7 @@ combine_simplify_rtx (rtx x, machine_mode op0_mode, int in_dest,\n {\n   enum rtx_code code = GET_CODE (x);\n   machine_mode mode = GET_MODE (x);\n+  scalar_int_mode int_mode;\n   rtx temp;\n   int i;\n \n@@ -6070,47 +6072,51 @@ combine_simplify_rtx (rtx x, machine_mode op0_mode, int in_dest,\n \t    ;\n \n \t  else if (STORE_FLAG_VALUE == 1\n-\t      && new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n-\t      && op1 == const0_rtx\n-\t      && mode == GET_MODE (op0)\n-\t      && nonzero_bits (op0, mode) == 1)\n-\t    return gen_lowpart (mode,\n+\t\t   && new_code == NE\n+\t\t   && is_int_mode (mode, &int_mode)\n+\t\t   && op1 == const0_rtx\n+\t\t   && int_mode == GET_MODE (op0)\n+\t\t   && nonzero_bits (op0, int_mode) == 1)\n+\t    return gen_lowpart (int_mode,\n \t\t\t\texpand_compound_operation (op0));\n \n \t  else if (STORE_FLAG_VALUE == 1\n-\t\t   && new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n+\t\t   && new_code == NE\n+\t\t   && is_int_mode (mode, &int_mode)\n \t\t   && op1 == const0_rtx\n-\t\t   && mode == GET_MODE (op0)\n-\t\t   && (num_sign_bit_copies (op0, mode)\n-\t\t       == GET_MODE_PRECISION (mode)))\n+\t\t   && int_mode == GET_MODE (op0)\n+\t\t   && (num_sign_bit_copies (op0, int_mode)\n+\t\t       == GET_MODE_PRECISION (int_mode)))\n \t    {\n \t      op0 = expand_compound_operation (op0);\n-\t      return simplify_gen_unary (NEG, mode,\n-\t\t\t\t\t gen_lowpart (mode, op0),\n-\t\t\t\t\t mode);\n+\t      return simplify_gen_unary (NEG, int_mode,\n+\t\t\t\t\t gen_lowpart (int_mode, op0),\n+\t\t\t\t\t int_mode);\n \t    }\n \n \t  else if (STORE_FLAG_VALUE == 1\n-\t\t   && new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n+\t\t   && new_code == EQ\n+\t\t   && is_int_mode (mode, &int_mode)\n \t\t   && op1 == const0_rtx\n-\t\t   && mode == GET_MODE (op0)\n-\t\t   && nonzero_bits (op0, mode) == 1)\n+\t\t   && int_mode == GET_MODE (op0)\n+\t\t   && nonzero_bits (op0, int_mode) == 1)\n \t    {\n \t      op0 = expand_compound_operation (op0);\n-\t      return simplify_gen_binary (XOR, mode,\n-\t\t\t\t\t  gen_lowpart (mode, op0),\n+\t      return simplify_gen_binary (XOR, int_mode,\n+\t\t\t\t\t  gen_lowpart (int_mode, op0),\n \t\t\t\t\t  const1_rtx);\n \t    }\n \n \t  else if (STORE_FLAG_VALUE == 1\n-\t\t   && new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n+\t\t   && new_code == EQ\n+\t\t   && is_int_mode (mode, &int_mode)\n \t\t   && op1 == const0_rtx\n-\t\t   && mode == GET_MODE (op0)\n-\t\t   && (num_sign_bit_copies (op0, mode)\n-\t\t       == GET_MODE_PRECISION (mode)))\n+\t\t   && int_mode == GET_MODE (op0)\n+\t\t   && (num_sign_bit_copies (op0, int_mode)\n+\t\t       == GET_MODE_PRECISION (int_mode)))\n \t    {\n \t      op0 = expand_compound_operation (op0);\n-\t      return plus_constant (mode, gen_lowpart (mode, op0), 1);\n+\t      return plus_constant (int_mode, gen_lowpart (int_mode, op0), 1);\n \t    }\n \n \t  /* If STORE_FLAG_VALUE is -1, we have cases similar to\n@@ -6119,65 +6125,69 @@ combine_simplify_rtx (rtx x, machine_mode op0_mode, int in_dest,\n \t    ;\n \n \t  else if (STORE_FLAG_VALUE == -1\n-\t\t   && new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n+\t\t   && new_code == NE\n+\t\t   && is_int_mode (mode, &int_mode)\n \t\t   && op1 == const0_rtx\n-\t\t   && mode == GET_MODE (op0)\n-\t\t   && (num_sign_bit_copies (op0, mode)\n-\t\t       == GET_MODE_PRECISION (mode)))\n-\t    return gen_lowpart (mode,\n-\t\t\t\texpand_compound_operation (op0));\n+\t\t   && int_mode == GET_MODE (op0)\n+\t\t   && (num_sign_bit_copies (op0, int_mode)\n+\t\t       == GET_MODE_PRECISION (int_mode)))\n+\t    return gen_lowpart (int_mode, expand_compound_operation (op0));\n \n \t  else if (STORE_FLAG_VALUE == -1\n-\t\t   && new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n+\t\t   && new_code == NE\n+\t\t   && is_int_mode (mode, &int_mode)\n \t\t   && op1 == const0_rtx\n-\t\t   && mode == GET_MODE (op0)\n-\t\t   && nonzero_bits (op0, mode) == 1)\n+\t\t   && int_mode == GET_MODE (op0)\n+\t\t   && nonzero_bits (op0, int_mode) == 1)\n \t    {\n \t      op0 = expand_compound_operation (op0);\n-\t      return simplify_gen_unary (NEG, mode,\n-\t\t\t\t\t gen_lowpart (mode, op0),\n-\t\t\t\t\t mode);\n+\t      return simplify_gen_unary (NEG, int_mode,\n+\t\t\t\t\t gen_lowpart (int_mode, op0),\n+\t\t\t\t\t int_mode);\n \t    }\n \n \t  else if (STORE_FLAG_VALUE == -1\n-\t\t   && new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n+\t\t   && new_code == EQ\n+\t\t   && is_int_mode (mode, &int_mode)\n \t\t   && op1 == const0_rtx\n-\t\t   && mode == GET_MODE (op0)\n-\t\t   && (num_sign_bit_copies (op0, mode)\n-\t\t       == GET_MODE_PRECISION (mode)))\n+\t\t   && int_mode == GET_MODE (op0)\n+\t\t   && (num_sign_bit_copies (op0, int_mode)\n+\t\t       == GET_MODE_PRECISION (int_mode)))\n \t    {\n \t      op0 = expand_compound_operation (op0);\n-\t      return simplify_gen_unary (NOT, mode,\n-\t\t\t\t\t gen_lowpart (mode, op0),\n-\t\t\t\t\t mode);\n+\t      return simplify_gen_unary (NOT, int_mode,\n+\t\t\t\t\t gen_lowpart (int_mode, op0),\n+\t\t\t\t\t int_mode);\n \t    }\n \n \t  /* If X is 0/1, (eq X 0) is X-1.  */\n \t  else if (STORE_FLAG_VALUE == -1\n-\t\t   && new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n+\t\t   && new_code == EQ\n+\t\t   && is_int_mode (mode, &int_mode)\n \t\t   && op1 == const0_rtx\n-\t\t   && mode == GET_MODE (op0)\n-\t\t   && nonzero_bits (op0, mode) == 1)\n+\t\t   && int_mode == GET_MODE (op0)\n+\t\t   && nonzero_bits (op0, int_mode) == 1)\n \t    {\n \t      op0 = expand_compound_operation (op0);\n-\t      return plus_constant (mode, gen_lowpart (mode, op0), -1);\n+\t      return plus_constant (int_mode, gen_lowpart (int_mode, op0), -1);\n \t    }\n \n \t  /* If STORE_FLAG_VALUE says to just test the sign bit and X has just\n \t     one bit that might be nonzero, we can convert (ne x 0) to\n \t     (ashift x c) where C puts the bit in the sign bit.  Remove any\n \t     AND with STORE_FLAG_VALUE when we are done, since we are only\n \t     going to test the sign bit.  */\n-\t  if (new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n-\t      && HWI_COMPUTABLE_MODE_P (mode)\n-\t      && val_signbit_p (mode, STORE_FLAG_VALUE)\n+\t  if (new_code == NE\n+\t      && is_int_mode (mode, &int_mode)\n+\t      && HWI_COMPUTABLE_MODE_P (int_mode)\n+\t      && val_signbit_p (int_mode, STORE_FLAG_VALUE)\n \t      && op1 == const0_rtx\n-\t      && mode == GET_MODE (op0)\n-\t      && (i = exact_log2 (nonzero_bits (op0, mode))) >= 0)\n+\t      && int_mode == GET_MODE (op0)\n+\t      && (i = exact_log2 (nonzero_bits (op0, int_mode))) >= 0)\n \t    {\n-\t      x = simplify_shift_const (NULL_RTX, ASHIFT, mode,\n+\t      x = simplify_shift_const (NULL_RTX, ASHIFT, int_mode,\n \t\t\t\t\texpand_compound_operation (op0),\n-\t\t\t\t\tGET_MODE_PRECISION (mode) - 1 - i);\n+\t\t\t\t\tGET_MODE_PRECISION (int_mode) - 1 - i);\n \t      if (GET_CODE (x) == AND && XEXP (x, 1) == const_true_rtx)\n \t\treturn XEXP (x, 0);\n \t      else\n@@ -6263,6 +6273,7 @@ simplify_if_then_else (rtx x)\n   int i;\n   enum rtx_code false_code;\n   rtx reversed;\n+  scalar_int_mode int_mode;\n \n   /* Simplify storing of the truth value.  */\n   if (comparison_p && true_rtx == const_true_rtx && false_rtx == const0_rtx)\n@@ -6443,15 +6454,15 @@ simplify_if_then_else (rtx x)\n \n   if ((STORE_FLAG_VALUE == 1 || STORE_FLAG_VALUE == -1)\n       && comparison_p\n-      && GET_MODE_CLASS (mode) == MODE_INT\n+      && is_int_mode (mode, &int_mode)\n       && ! side_effects_p (x))\n     {\n       rtx t = make_compound_operation (true_rtx, SET);\n       rtx f = make_compound_operation (false_rtx, SET);\n       rtx cond_op0 = XEXP (cond, 0);\n       rtx cond_op1 = XEXP (cond, 1);\n       enum rtx_code op = UNKNOWN, extend_op = UNKNOWN;\n-      machine_mode m = mode;\n+      machine_mode m = int_mode;\n       rtx z = 0, c1 = NULL_RTX;\n \n       if ((GET_CODE (t) == PLUS || GET_CODE (t) == MINUS\n@@ -6480,7 +6491,7 @@ simplify_if_then_else (rtx x)\n \t       && rtx_equal_p (SUBREG_REG (XEXP (XEXP (t, 0), 0)), f)\n \t       && (num_sign_bit_copies (f, GET_MODE (f))\n \t\t   > (unsigned int)\n-\t\t     (GET_MODE_PRECISION (mode)\n+\t\t     (GET_MODE_PRECISION (int_mode)\n \t\t      - GET_MODE_PRECISION (GET_MODE (XEXP (XEXP (t, 0), 0))))))\n \t{\n \t  c1 = XEXP (XEXP (t, 0), 1); z = f; op = GET_CODE (XEXP (t, 0));\n@@ -6496,7 +6507,7 @@ simplify_if_then_else (rtx x)\n \t       && rtx_equal_p (SUBREG_REG (XEXP (XEXP (t, 0), 1)), f)\n \t       && (num_sign_bit_copies (f, GET_MODE (f))\n \t\t   > (unsigned int)\n-\t\t     (GET_MODE_PRECISION (mode)\n+\t\t     (GET_MODE_PRECISION (int_mode)\n \t\t      - GET_MODE_PRECISION (GET_MODE (XEXP (XEXP (t, 0), 1))))))\n \t{\n \t  c1 = XEXP (XEXP (t, 0), 0); z = f; op = GET_CODE (XEXP (t, 0));\n@@ -6512,7 +6523,7 @@ simplify_if_then_else (rtx x)\n \t\t   || GET_CODE (XEXP (t, 0)) == LSHIFTRT\n \t\t   || GET_CODE (XEXP (t, 0)) == ASHIFTRT)\n \t       && GET_CODE (XEXP (XEXP (t, 0), 0)) == SUBREG\n-\t       && HWI_COMPUTABLE_MODE_P (mode)\n+\t       && HWI_COMPUTABLE_MODE_P (int_mode)\n \t       && subreg_lowpart_p (XEXP (XEXP (t, 0), 0))\n \t       && rtx_equal_p (SUBREG_REG (XEXP (XEXP (t, 0), 0)), f)\n \t       && ((nonzero_bits (f, GET_MODE (f))\n@@ -6528,7 +6539,7 @@ simplify_if_then_else (rtx x)\n \t\t   || GET_CODE (XEXP (t, 0)) == IOR\n \t\t   || GET_CODE (XEXP (t, 0)) == XOR)\n \t       && GET_CODE (XEXP (XEXP (t, 0), 1)) == SUBREG\n-\t       && HWI_COMPUTABLE_MODE_P (mode)\n+\t       && HWI_COMPUTABLE_MODE_P (int_mode)\n \t       && subreg_lowpart_p (XEXP (XEXP (t, 0), 1))\n \t       && rtx_equal_p (SUBREG_REG (XEXP (XEXP (t, 0), 1)), f)\n \t       && ((nonzero_bits (f, GET_MODE (f))\n@@ -6552,7 +6563,7 @@ simplify_if_then_else (rtx x)\n \t  temp = simplify_gen_binary (op, m, gen_lowpart (m, z), temp);\n \n \t  if (extend_op != UNKNOWN)\n-\t    temp = simplify_gen_unary (extend_op, mode, temp, m);\n+\t    temp = simplify_gen_unary (extend_op, int_mode, temp, m);\n \n \t  return temp;\n \t}\n@@ -6605,6 +6616,7 @@ simplify_set (rtx x)\n     = GET_MODE (src) != VOIDmode ? GET_MODE (src) : GET_MODE (dest);\n   rtx_insn *other_insn;\n   rtx *cc_use;\n+  scalar_int_mode int_mode;\n \n   /* (set (pc) (return)) gets written as (return).  */\n   if (GET_CODE (dest) == PC && ANY_RETURN_P (src))\n@@ -6871,15 +6883,14 @@ simplify_set (rtx x)\n \n   if (GET_CODE (dest) != PC\n       && GET_CODE (src) == IF_THEN_ELSE\n-      && GET_MODE_CLASS (GET_MODE (src)) == MODE_INT\n+      && is_int_mode (GET_MODE (src), &int_mode)\n       && (GET_CODE (XEXP (src, 0)) == EQ || GET_CODE (XEXP (src, 0)) == NE)\n       && XEXP (XEXP (src, 0), 1) == const0_rtx\n-      && GET_MODE (src) == GET_MODE (XEXP (XEXP (src, 0), 0))\n+      && int_mode == GET_MODE (XEXP (XEXP (src, 0), 0))\n       && (!HAVE_conditional_move\n-\t  || ! can_conditionally_move_p (GET_MODE (src)))\n-      && (num_sign_bit_copies (XEXP (XEXP (src, 0), 0),\n-\t\t\t       GET_MODE (XEXP (XEXP (src, 0), 0)))\n-\t  == GET_MODE_PRECISION (GET_MODE (XEXP (XEXP (src, 0), 0))))\n+\t  || ! can_conditionally_move_p (int_mode))\n+      && (num_sign_bit_copies (XEXP (XEXP (src, 0), 0), int_mode)\n+\t  == GET_MODE_PRECISION (int_mode))\n       && ! side_effects_p (src))\n     {\n       rtx true_rtx = (GET_CODE (XEXP (src, 0)) == NE\n@@ -6901,17 +6912,17 @@ simplify_set (rtx x)\n \t       && rtx_equal_p (XEXP (false_rtx, 1), true_rtx))\n \tterm1 = true_rtx, false_rtx = XEXP (false_rtx, 0), true_rtx = const0_rtx;\n \n-      term2 = simplify_gen_binary (AND, GET_MODE (src),\n+      term2 = simplify_gen_binary (AND, int_mode,\n \t\t\t\t   XEXP (XEXP (src, 0), 0), true_rtx);\n-      term3 = simplify_gen_binary (AND, GET_MODE (src),\n-\t\t\t\t   simplify_gen_unary (NOT, GET_MODE (src),\n+      term3 = simplify_gen_binary (AND, int_mode,\n+\t\t\t\t   simplify_gen_unary (NOT, int_mode,\n \t\t\t\t\t\t       XEXP (XEXP (src, 0), 0),\n-\t\t\t\t\t\t       GET_MODE (src)),\n+\t\t\t\t\t\t       int_mode),\n \t\t\t\t   false_rtx);\n \n       SUBST (SET_SRC (x),\n-\t     simplify_gen_binary (IOR, GET_MODE (src),\n-\t\t\t\t  simplify_gen_binary (IOR, GET_MODE (src),\n+\t     simplify_gen_binary (IOR, int_mode,\n+\t\t\t\t  simplify_gen_binary (IOR, int_mode,\n \t\t\t\t\t\t       term1, term2),\n \t\t\t\t  term3));\n \n@@ -10296,7 +10307,8 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n   rtx orig_varop = varop;\n   int count;\n   machine_mode mode = result_mode;\n-  machine_mode shift_mode, tmode;\n+  machine_mode shift_mode;\n+  scalar_int_mode tmode, inner_mode;\n   unsigned int mode_words\n     = (GET_MODE_SIZE (mode) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;\n   /* We form (outer_op (code varop count) (outer_const)).  */\n@@ -10464,17 +10476,16 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t     the same number of words as what we've seen so far.  Then store\n \t     the widest mode in MODE.  */\n \t  if (subreg_lowpart_p (varop)\n-\t      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (varop)))\n-\t\t  > GET_MODE_SIZE (GET_MODE (varop)))\n-\t      && (unsigned int) ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (varop)))\n+\t      && is_int_mode (GET_MODE (SUBREG_REG (varop)), &inner_mode)\n+\t      && GET_MODE_SIZE (inner_mode) > GET_MODE_SIZE (GET_MODE (varop))\n+\t      && (unsigned int) ((GET_MODE_SIZE (inner_mode)\n \t\t\t\t  + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n \t\t == mode_words\n-\t      && GET_MODE_CLASS (GET_MODE (varop)) == MODE_INT\n-\t      && GET_MODE_CLASS (GET_MODE (SUBREG_REG (varop))) == MODE_INT)\n+\t      && GET_MODE_CLASS (GET_MODE (varop)) == MODE_INT)\n \t    {\n \t      varop = SUBREG_REG (varop);\n-\t      if (GET_MODE_SIZE (GET_MODE (varop)) > GET_MODE_SIZE (mode))\n-\t\tmode = GET_MODE (varop);\n+\t      if (GET_MODE_SIZE (inner_mode) > GET_MODE_SIZE (mode))\n+\t\tmode = inner_mode;\n \t      continue;\n \t    }\n \t  break;\n@@ -11717,7 +11728,8 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n   rtx op1 = *pop1;\n   rtx tem, tem1;\n   int i;\n-  machine_mode mode, tmode;\n+  scalar_int_mode mode, inner_mode;\n+  machine_mode tmode;\n \n   /* Try a few ways of applying the same transformation to both operands.  */\n   while (1)\n@@ -12128,19 +12140,17 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t    ;\n \t  else if (subreg_lowpart_p (op0)\n \t\t   && GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT\n-\t\t   && GET_MODE_CLASS (GET_MODE (SUBREG_REG (op0))) == MODE_INT\n+\t\t   && is_int_mode (GET_MODE (SUBREG_REG (op0)), &inner_mode)\n \t\t   && (code == NE || code == EQ)\n-\t\t   && (GET_MODE_PRECISION (GET_MODE (SUBREG_REG (op0)))\n-\t\t       <= HOST_BITS_PER_WIDE_INT)\n+\t\t   && GET_MODE_PRECISION (inner_mode) <= HOST_BITS_PER_WIDE_INT\n \t\t   && !paradoxical_subreg_p (op0)\n-\t\t   && (nonzero_bits (SUBREG_REG (op0),\n-\t\t\t\t     GET_MODE (SUBREG_REG (op0)))\n+\t\t   && (nonzero_bits (SUBREG_REG (op0), inner_mode)\n \t\t       & ~GET_MODE_MASK (GET_MODE (op0))) == 0)\n \t    {\n \t      /* Remove outer subregs that don't do anything.  */\n-\t      tem = gen_lowpart (GET_MODE (SUBREG_REG (op0)), op1);\n+\t      tem = gen_lowpart (inner_mode, op1);\n \n-\t      if ((nonzero_bits (tem, GET_MODE (SUBREG_REG (op0)))\n+\t      if ((nonzero_bits (tem, inner_mode)\n \t\t   & ~GET_MODE_MASK (GET_MODE (op0))) == 0)\n \t\t{\n \t\t  op0 = SUBREG_REG (op0);\n@@ -12658,8 +12668,8 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n   op1 = make_compound_operation (op1, SET);\n \n   if (GET_CODE (op0) == SUBREG && subreg_lowpart_p (op0)\n-      && GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT\n-      && GET_MODE_CLASS (GET_MODE (SUBREG_REG (op0))) == MODE_INT\n+      && is_int_mode (GET_MODE (op0), &mode)\n+      && is_int_mode (GET_MODE (SUBREG_REG (op0)), &inner_mode)\n       && (code == NE || code == EQ))\n     {\n       if (paradoxical_subreg_p (op0))\n@@ -12669,19 +12679,16 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t  if (REG_P (SUBREG_REG (op0)))\n \t    {\n \t      op0 = SUBREG_REG (op0);\n-\t      op1 = gen_lowpart (GET_MODE (op0), op1);\n+\t      op1 = gen_lowpart (inner_mode, op1);\n \t    }\n \t}\n-      else if ((GET_MODE_PRECISION (GET_MODE (SUBREG_REG (op0)))\n-\t\t<= HOST_BITS_PER_WIDE_INT)\n-\t       && (nonzero_bits (SUBREG_REG (op0),\n-\t\t\t\t GET_MODE (SUBREG_REG (op0)))\n-\t\t   & ~GET_MODE_MASK (GET_MODE (op0))) == 0)\n+      else if (GET_MODE_PRECISION (inner_mode) <= HOST_BITS_PER_WIDE_INT\n+\t       && (nonzero_bits (SUBREG_REG (op0), inner_mode)\n+\t\t   & ~GET_MODE_MASK (mode)) == 0)\n \t{\n-\t  tem = gen_lowpart (GET_MODE (SUBREG_REG (op0)), op1);\n+\t  tem = gen_lowpart (inner_mode, op1);\n \n-\t  if ((nonzero_bits (tem, GET_MODE (SUBREG_REG (op0)))\n-\t       & ~GET_MODE_MASK (GET_MODE (op0))) == 0)\n+\t  if ((nonzero_bits (tem, inner_mode) & ~GET_MODE_MASK (mode)) == 0)\n \t    op0 = SUBREG_REG (op0), op1 = tem;\n \t}\n     }\n@@ -12692,8 +12699,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n      mode for which we can do the compare.  There are a number of cases in\n      which we can use the wider mode.  */\n \n-  mode = GET_MODE (op0);\n-  if (mode != VOIDmode && GET_MODE_CLASS (mode) == MODE_INT\n+  if (is_int_mode (GET_MODE (op0), &mode)\n       && GET_MODE_SIZE (mode) < UNITS_PER_WORD\n       && ! have_insn_for (COMPARE, mode))\n     FOR_EACH_WIDER_MODE (tmode, mode)"}, {"sha": "7ca12db76e44c307c6a9f5a78ea69528fbd5cfa5", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=b4206259f10455603e0c90825566de1ea777c04a", "patch": "@@ -6844,6 +6844,7 @@ aarch64_rtx_costs (rtx x, machine_mode mode, int outer ATTRIBUTE_UNUSED,\n   const struct cpu_cost_table *extra_cost\n     = aarch64_tune_params.insn_extra_cost;\n   int code = GET_CODE (x);\n+  scalar_int_mode int_mode;\n \n   /* By default, assume that everything has equivalent cost to the\n      cheapest instruction.  Any additional costs are applied as a delta\n@@ -7426,28 +7427,29 @@ aarch64_rtx_costs (rtx x, machine_mode mode, int outer ATTRIBUTE_UNUSED,\n           return true;\n         }\n \n-      if (GET_MODE_CLASS (mode) == MODE_INT)\n+      if (is_int_mode (mode, &int_mode))\n \t{\n \t  if (CONST_INT_P (op1))\n \t    {\n \t      /* We have a mask + shift version of a UBFIZ\n \t\t i.e. the *andim_ashift<mode>_bfiz pattern.  */\n \t      if (GET_CODE (op0) == ASHIFT\n-\t\t  && aarch64_mask_and_shift_for_ubfiz_p (mode, op1,\n-\t\t\t\t\t\t\t  XEXP (op0, 1)))\n+\t\t  && aarch64_mask_and_shift_for_ubfiz_p (int_mode, op1,\n+\t\t\t\t\t\t\t XEXP (op0, 1)))\n \t\t{\n-\t\t  *cost += rtx_cost (XEXP (op0, 0), mode,\n+\t\t  *cost += rtx_cost (XEXP (op0, 0), int_mode,\n \t\t\t\t     (enum rtx_code) code, 0, speed);\n \t\t  if (speed)\n \t\t    *cost += extra_cost->alu.bfx;\n \n \t\t  return true;\n \t\t}\n-\t      else if (aarch64_bitmask_imm (INTVAL (op1), mode))\n+\t      else if (aarch64_bitmask_imm (INTVAL (op1), int_mode))\n \t\t{\n \t\t/* We possibly get the immediate for free, this is not\n \t\t   modelled.  */\n-\t\t  *cost += rtx_cost (op0, mode, (enum rtx_code) code, 0, speed);\n+\t\t  *cost += rtx_cost (op0, int_mode,\n+\t\t\t\t     (enum rtx_code) code, 0, speed);\n \t\t  if (speed)\n \t\t    *cost += extra_cost->alu.logical;\n \n@@ -7482,8 +7484,10 @@ aarch64_rtx_costs (rtx x, machine_mode mode, int outer ATTRIBUTE_UNUSED,\n \t\t}\n \n \t      /* In both cases we want to cost both operands.  */\n-\t      *cost += rtx_cost (new_op0, mode, (enum rtx_code) code, 0, speed);\n-\t      *cost += rtx_cost (op1, mode, (enum rtx_code) code, 1, speed);\n+\t      *cost += rtx_cost (new_op0, int_mode, (enum rtx_code) code,\n+\t\t\t\t 0, speed);\n+\t      *cost += rtx_cost (op1, int_mode, (enum rtx_code) code,\n+\t\t\t\t 1, speed);\n \n \t      return true;\n \t    }"}, {"sha": "8ef90639753823a38fe6bc30cb6fbc126aba335f", "filename": "gcc/cse.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=b4206259f10455603e0c90825566de1ea777c04a", "patch": "@@ -720,13 +720,14 @@ preferable (int cost_a, int regcost_a, int cost_b, int regcost_b)\n static int\n notreg_cost (rtx x, machine_mode mode, enum rtx_code outer, int opno)\n {\n+  scalar_int_mode int_mode, inner_mode;\n   return ((GET_CODE (x) == SUBREG\n \t   && REG_P (SUBREG_REG (x))\n-\t   && GET_MODE_CLASS (mode) == MODE_INT\n-\t   && GET_MODE_CLASS (GET_MODE (SUBREG_REG (x))) == MODE_INT\n-\t   && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))\n+\t   && is_int_mode (mode, &int_mode)\n+\t   && is_int_mode (GET_MODE (SUBREG_REG (x)), &inner_mode)\n+\t   && GET_MODE_SIZE (int_mode) < GET_MODE_SIZE (inner_mode)\n \t   && subreg_lowpart_p (x)\n-\t   && TRULY_NOOP_TRUNCATION_MODES_P (mode, GET_MODE (SUBREG_REG (x))))\n+\t   && TRULY_NOOP_TRUNCATION_MODES_P (int_mode, inner_mode))\n \t  ? 0\n \t  : rtx_cost (x, mode, outer, opno, optimize_this_for_speed_p) * 2);\n }\n@@ -4603,6 +4604,7 @@ cse_insn (rtx_insn *insn)\n       /* Set nonzero if we need to call force_const_mem on with the\n \t contents of src_folded before using it.  */\n       int src_folded_force_flag = 0;\n+      scalar_int_mode int_mode;\n \n       dest = SET_DEST (sets[i].rtl);\n       src = SET_SRC (sets[i].rtl);\n@@ -4840,13 +4842,13 @@ cse_insn (rtx_insn *insn)\n \t wider mode.  */\n \n       if (src_const && src_related == 0 && CONST_INT_P (src_const)\n-\t  && GET_MODE_CLASS (mode) == MODE_INT\n-\t  && GET_MODE_PRECISION (mode) < BITS_PER_WORD)\n+\t  && is_int_mode (mode, &int_mode)\n+\t  && GET_MODE_PRECISION (int_mode) < BITS_PER_WORD)\n \t{\n-\t  machine_mode wider_mode;\n-\n-\t  FOR_EACH_WIDER_MODE (wider_mode, mode)\n+\t  opt_scalar_int_mode wider_mode_iter;\n+\t  FOR_EACH_WIDER_MODE (wider_mode_iter, int_mode)\n \t    {\n+\t      scalar_int_mode wider_mode = wider_mode_iter.require ();\n \t      if (GET_MODE_PRECISION (wider_mode) > BITS_PER_WORD)\n \t\tbreak;\n \n@@ -4860,7 +4862,7 @@ cse_insn (rtx_insn *insn)\n \t\t   const_elt; const_elt = const_elt->next_same_value)\n \t\tif (REG_P (const_elt->exp))\n \t\t  {\n-\t\t    src_related = gen_lowpart (mode, const_elt->exp);\n+\t\t    src_related = gen_lowpart (int_mode, const_elt->exp);\n \t\t    break;\n \t\t  }\n "}, {"sha": "41e0e4fbb34120a2cf7507dba9057543bfd09c24", "filename": "gcc/cselib.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=b4206259f10455603e0c90825566de1ea777c04a", "patch": "@@ -2009,6 +2009,8 @@ cselib_lookup_1 (rtx x, machine_mode mode,\n \n       e = new_cselib_val (next_uid, GET_MODE (x), x);\n       new_elt_loc_list (e, x);\n+\n+      scalar_int_mode int_mode;\n       if (REG_VALUES (i) == 0)\n \t{\n \t  /* Maintain the invariant that the first entry of\n@@ -2018,27 +2020,27 @@ cselib_lookup_1 (rtx x, machine_mode mode,\n \t  REG_VALUES (i) = new_elt_list (REG_VALUES (i), NULL);\n \t}\n       else if (cselib_preserve_constants\n-\t       && GET_MODE_CLASS (mode) == MODE_INT)\n+\t       && is_int_mode (mode, &int_mode))\n \t{\n \t  /* During var-tracking, try harder to find equivalences\n \t     for SUBREGs.  If a setter sets say a DImode register\n \t     and user uses that register only in SImode, add a lowpart\n \t     subreg location.  */\n \t  struct elt_list *lwider = NULL;\n+\t  scalar_int_mode lmode;\n \t  l = REG_VALUES (i);\n \t  if (l && l->elt == NULL)\n \t    l = l->next;\n \t  for (; l; l = l->next)\n-\t    if (GET_MODE_CLASS (GET_MODE (l->elt->val_rtx)) == MODE_INT\n-\t\t&& GET_MODE_SIZE (GET_MODE (l->elt->val_rtx))\n-\t\t   > GET_MODE_SIZE (mode)\n+\t    if (is_int_mode (GET_MODE (l->elt->val_rtx), &lmode)\n+\t\t&& GET_MODE_SIZE (lmode) > GET_MODE_SIZE (int_mode)\n \t\t&& (lwider == NULL\n-\t\t    || GET_MODE_SIZE (GET_MODE (l->elt->val_rtx))\n+\t\t    || GET_MODE_SIZE (lmode)\n \t\t       < GET_MODE_SIZE (GET_MODE (lwider->elt->val_rtx))))\n \t      {\n \t\tstruct elt_loc_list *el;\n \t\tif (i < FIRST_PSEUDO_REGISTER\n-\t\t    && hard_regno_nregs[i][GET_MODE (l->elt->val_rtx)] != 1)\n+\t\t    && hard_regno_nregs[i][lmode] != 1)\n \t\t  continue;\n \t\tfor (el = l->elt->locs; el; el = el->next)\n \t\t  if (!REG_P (el->loc))\n@@ -2048,7 +2050,7 @@ cselib_lookup_1 (rtx x, machine_mode mode,\n \t      }\n \t  if (lwider)\n \t    {\n-\t      rtx sub = lowpart_subreg (mode, lwider->elt->val_rtx,\n+\t      rtx sub = lowpart_subreg (int_mode, lwider->elt->val_rtx,\n \t\t\t\t\tGET_MODE (lwider->elt->val_rtx));\n \t      if (sub)\n \t\tnew_elt_loc_list (e, sub);"}, {"sha": "b084253505128aa4fdb29151d8231684045de5cc", "filename": "gcc/dojump.c", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=b4206259f10455603e0c90825566de1ea777c04a", "patch": "@@ -203,6 +203,7 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n {\n   machine_mode mode;\n   rtx_code_label *drop_through_label = 0;\n+  scalar_int_mode int_mode;\n \n   switch (code)\n     {\n@@ -218,8 +219,8 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n         if (integer_zerop (op1))\n \t  do_jump (op0, if_true_label, if_false_label,\n \t\t   prob.invert ());\n-        else if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_INT\n-                 && !can_compare_p (EQ, TYPE_MODE (inner_type), ccp_jump))\n+\telse if (is_int_mode (TYPE_MODE (inner_type), &int_mode)\n+\t\t && !can_compare_p (EQ, int_mode, ccp_jump))\n \t  do_jump_by_parts_equality (op0, op1, if_false_label, if_true_label,\n \t\t\t\t     prob);\n         else\n@@ -239,8 +240,8 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n \n         if (integer_zerop (op1))\n \t  do_jump (op0, if_false_label, if_true_label, prob);\n-        else if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_INT\n-           && !can_compare_p (NE, TYPE_MODE (inner_type), ccp_jump))\n+\telse if (is_int_mode (TYPE_MODE (inner_type), &int_mode)\n+\t\t && !can_compare_p (NE, int_mode, ccp_jump))\n \t  do_jump_by_parts_equality (op0, op1, if_true_label, if_false_label,\n \t\t\t\t     prob.invert ());\n         else\n@@ -251,19 +252,19 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n \n     case LT_EXPR:\n       mode = TYPE_MODE (TREE_TYPE (op0));\n-      if (GET_MODE_CLASS (mode) == MODE_INT\n-          && ! can_compare_p (LT, mode, ccp_jump))\n-\tdo_jump_by_parts_greater (op0, op1, 1, if_false_label, if_true_label,\n-\t\t\t\t  prob);\n+      if (is_int_mode (mode, &int_mode)\n+\t  && ! can_compare_p (LT, int_mode, ccp_jump))\n+\tdo_jump_by_parts_greater (op0, op1, 1, if_false_label,\n+\t\t\t\t  if_true_label, prob);\n       else\n \tdo_compare_and_jump (op0, op1, LT, LTU, if_false_label, if_true_label,\n \t\t\t     prob);\n       break;\n \n     case LE_EXPR:\n       mode = TYPE_MODE (TREE_TYPE (op0));\n-      if (GET_MODE_CLASS (mode) == MODE_INT\n-          && ! can_compare_p (LE, mode, ccp_jump))\n+      if (is_int_mode (mode, &int_mode)\n+\t  && ! can_compare_p (LE, int_mode, ccp_jump))\n \tdo_jump_by_parts_greater (op0, op1, 0, if_true_label, if_false_label,\n \t\t\t\t  prob.invert ());\n       else\n@@ -273,19 +274,19 @@ do_jump_1 (enum tree_code code, tree op0, tree op1,\n \n     case GT_EXPR:\n       mode = TYPE_MODE (TREE_TYPE (op0));\n-      if (GET_MODE_CLASS (mode) == MODE_INT\n-          && ! can_compare_p (GT, mode, ccp_jump))\n-\tdo_jump_by_parts_greater (op0, op1, 0, if_false_label, if_true_label,\n-\t\t\t\t  prob);\n+      if (is_int_mode (mode, &int_mode)\n+\t  && ! can_compare_p (GT, int_mode, ccp_jump))\n+\tdo_jump_by_parts_greater (op0, op1, 0, if_false_label,\n+\t\t\t\t  if_true_label, prob);\n       else\n \tdo_compare_and_jump (op0, op1, GT, GTU, if_false_label, if_true_label,\n \t\t\t     prob);\n       break;\n \n     case GE_EXPR:\n       mode = TYPE_MODE (TREE_TYPE (op0));\n-      if (GET_MODE_CLASS (mode) == MODE_INT\n-          && ! can_compare_p (GE, mode, ccp_jump))\n+      if (is_int_mode (mode, &int_mode)\n+\t  && ! can_compare_p (GE, int_mode, ccp_jump))\n \tdo_jump_by_parts_greater (op0, op1, 1, if_true_label, if_false_label,\n \t\t\t\t  prob.invert ());\n       else\n@@ -1024,62 +1025,63 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n   if (! if_true_label)\n     dummy_label = if_true_label = gen_label_rtx ();\n \n-  if (GET_MODE_CLASS (mode) == MODE_INT\n-      && ! can_compare_p (code, mode, ccp_jump))\n+  scalar_int_mode int_mode;\n+  if (is_int_mode (mode, &int_mode)\n+      && ! can_compare_p (code, int_mode, ccp_jump))\n     {\n       switch (code)\n \t{\n \tcase LTU:\n-\t  do_jump_by_parts_greater_rtx (mode, 1, op1, op0,\n+\t  do_jump_by_parts_greater_rtx (int_mode, 1, op1, op0,\n \t\t\t\t\tif_false_label, if_true_label, prob);\n \t  break;\n \n \tcase LEU:\n-\t  do_jump_by_parts_greater_rtx (mode, 1, op0, op1,\n+\t  do_jump_by_parts_greater_rtx (int_mode, 1, op0, op1,\n \t\t\t\t\tif_true_label, if_false_label,\n \t\t\t\t\tprob.invert ());\n \t  break;\n \n \tcase GTU:\n-\t  do_jump_by_parts_greater_rtx (mode, 1, op0, op1,\n+\t  do_jump_by_parts_greater_rtx (int_mode, 1, op0, op1,\n \t\t\t\t\tif_false_label, if_true_label, prob);\n \t  break;\n \n \tcase GEU:\n-\t  do_jump_by_parts_greater_rtx (mode, 1, op1, op0,\n+\t  do_jump_by_parts_greater_rtx (int_mode, 1, op1, op0,\n \t\t\t\t\tif_true_label, if_false_label,\n \t\t\t\t\tprob.invert ());\n \t  break;\n \n \tcase LT:\n-\t  do_jump_by_parts_greater_rtx (mode, 0, op1, op0,\n+\t  do_jump_by_parts_greater_rtx (int_mode, 0, op1, op0,\n \t\t\t\t\tif_false_label, if_true_label, prob);\n \t  break;\n \n \tcase LE:\n-\t  do_jump_by_parts_greater_rtx (mode, 0, op0, op1,\n+\t  do_jump_by_parts_greater_rtx (int_mode, 0, op0, op1,\n \t\t\t\t\tif_true_label, if_false_label,\n \t\t\t\t\tprob.invert ());\n \t  break;\n \n \tcase GT:\n-\t  do_jump_by_parts_greater_rtx (mode, 0, op0, op1,\n+\t  do_jump_by_parts_greater_rtx (int_mode, 0, op0, op1,\n \t\t\t\t\tif_false_label, if_true_label, prob);\n \t  break;\n \n \tcase GE:\n-\t  do_jump_by_parts_greater_rtx (mode, 0, op1, op0,\n+\t  do_jump_by_parts_greater_rtx (int_mode, 0, op1, op0,\n \t\t\t\t\tif_true_label, if_false_label,\n \t\t\t\t\tprob.invert ());\n \t  break;\n \n \tcase EQ:\n-\t  do_jump_by_parts_equality_rtx (mode, op0, op1, if_false_label,\n+\t  do_jump_by_parts_equality_rtx (int_mode, op0, op1, if_false_label,\n \t\t\t\t\t if_true_label, prob);\n \t  break;\n \n \tcase NE:\n-\t  do_jump_by_parts_equality_rtx (mode, op0, op1, if_true_label,\n+\t  do_jump_by_parts_equality_rtx (int_mode, op0, op1, if_true_label,\n \t\t\t\t\t if_false_label,\n \t\t\t\t\t prob.invert ());\n \t  break;"}, {"sha": "65b4b868aec7cd1ae5e9504a24dff5f73ccd7432", "filename": "gcc/dse.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=b4206259f10455603e0c90825566de1ea777c04a", "patch": "@@ -2185,27 +2185,29 @@ get_call_args (rtx call_insn, tree fn, rtx *args, int nargs)\n        arg != void_list_node && idx < nargs;\n        arg = TREE_CHAIN (arg), idx++)\n     {\n-      machine_mode mode = TYPE_MODE (TREE_VALUE (arg));\n+      scalar_int_mode mode;\n       rtx reg, link, tmp;\n+\n+      if (!is_int_mode (TYPE_MODE (TREE_VALUE (arg)), &mode))\n+\treturn false;\n+\n       reg = targetm.calls.function_arg (args_so_far, mode, NULL_TREE, true);\n-      if (!reg || !REG_P (reg) || GET_MODE (reg) != mode\n-\t  || GET_MODE_CLASS (mode) != MODE_INT)\n+      if (!reg || !REG_P (reg) || GET_MODE (reg) != mode)\n \treturn false;\n \n       for (link = CALL_INSN_FUNCTION_USAGE (call_insn);\n \t   link;\n \t   link = XEXP (link, 1))\n \tif (GET_CODE (XEXP (link, 0)) == USE)\n \t  {\n+\t    scalar_int_mode arg_mode;\n \t    args[idx] = XEXP (XEXP (link, 0), 0);\n \t    if (REG_P (args[idx])\n \t\t&& REGNO (args[idx]) == REGNO (reg)\n \t\t&& (GET_MODE (args[idx]) == mode\n-\t\t    || (GET_MODE_CLASS (GET_MODE (args[idx])) == MODE_INT\n-\t\t\t&& (GET_MODE_SIZE (GET_MODE (args[idx]))\n-\t\t\t    <= UNITS_PER_WORD)\n-\t\t\t&& (GET_MODE_SIZE (GET_MODE (args[idx]))\n-\t\t\t    > GET_MODE_SIZE (mode)))))\n+\t\t    || (is_int_mode (GET_MODE (args[idx]), &arg_mode)\n+\t\t\t&& (GET_MODE_SIZE (arg_mode) <= UNITS_PER_WORD)\n+\t\t\t&& (GET_MODE_SIZE (arg_mode) > GET_MODE_SIZE (mode)))))\n \t      break;\n \t  }\n       if (!link)"}, {"sha": "f974f180d4fde5b5410bac2fee98bb23c3b266ff", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=b4206259f10455603e0c90825566de1ea777c04a", "patch": "@@ -18840,9 +18840,10 @@ rtl_for_decl_init (tree init, tree type)\n     {\n       tree enttype = TREE_TYPE (type);\n       tree domain = TYPE_DOMAIN (type);\n-      machine_mode mode = TYPE_MODE (enttype);\n+      scalar_int_mode mode;\n \n-      if (GET_MODE_CLASS (mode) == MODE_INT && GET_MODE_SIZE (mode) == 1\n+      if (is_int_mode (TYPE_MODE (enttype), &mode)\n+\t  && GET_MODE_SIZE (mode) == 1\n \t  && domain\n \t  && integer_zerop (TYPE_MIN_VALUE (domain))\n \t  && compare_tree_int (TYPE_MAX_VALUE (domain),\n@@ -19323,9 +19324,10 @@ native_encode_initializer (tree init, unsigned char *array, int size)\n       if (TREE_CODE (type) == ARRAY_TYPE)\n \t{\n \t  tree enttype = TREE_TYPE (type);\n-\t  machine_mode mode = TYPE_MODE (enttype);\n+\t  scalar_int_mode mode;\n \n-\t  if (GET_MODE_CLASS (mode) != MODE_INT || GET_MODE_SIZE (mode) != 1)\n+\t  if (!is_int_mode (TYPE_MODE (enttype), &mode)\n+\t      || GET_MODE_SIZE (mode) != 1)\n \t    return false;\n \t  if (int_size_in_bytes (type) != size)\n \t    return false;"}, {"sha": "815c766cec0688d01a447ee9cdbf8486e9cf9380", "filename": "gcc/expmed.c", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=b4206259f10455603e0c90825566de1ea777c04a", "patch": "@@ -5446,8 +5446,9 @@ emit_store_flag_1 (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \n   /* If we are comparing a double-word integer with zero or -1, we can\n      convert the comparison into one involving a single word.  */\n-  if (GET_MODE_BITSIZE (mode) == BITS_PER_WORD * 2\n-      && GET_MODE_CLASS (mode) == MODE_INT\n+  scalar_int_mode int_mode;\n+  if (is_int_mode (mode, &int_mode)\n+      && GET_MODE_BITSIZE (int_mode) == BITS_PER_WORD * 2\n       && (!MEM_P (op0) || ! MEM_VOLATILE_P (op0)))\n     {\n       rtx tem;\n@@ -5458,8 +5459,8 @@ emit_store_flag_1 (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \n \t  /* Do a logical OR or AND of the two words and compare the\n \t     result.  */\n-\t  op00 = simplify_gen_subreg (word_mode, op0, mode, 0);\n-\t  op01 = simplify_gen_subreg (word_mode, op0, mode, UNITS_PER_WORD);\n+\t  op00 = simplify_gen_subreg (word_mode, op0, int_mode, 0);\n+\t  op01 = simplify_gen_subreg (word_mode, op0, int_mode, UNITS_PER_WORD);\n \t  tem = expand_binop (word_mode,\n \t\t\t      op1 == const0_rtx ? ior_optab : and_optab,\n \t\t\t      op00, op01, NULL_RTX, unsignedp,\n@@ -5474,9 +5475,9 @@ emit_store_flag_1 (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t  rtx op0h;\n \n \t  /* If testing the sign bit, can just test on high word.  */\n-\t  op0h = simplify_gen_subreg (word_mode, op0, mode,\n+\t  op0h = simplify_gen_subreg (word_mode, op0, int_mode,\n \t\t\t\t      subreg_highpart_offset (word_mode,\n-\t\t\t\t\t\t\t      mode));\n+\t\t\t\t\t\t\t      int_mode));\n \t  tem = emit_store_flag (NULL_RTX, code, op0h, op1, word_mode,\n \t\t\t\t unsignedp, normalizep);\n \t}\n@@ -5501,21 +5502,21 @@ emit_store_flag_1 (rtx target, enum rtx_code code, rtx op0, rtx op1,\n   /* If this is A < 0 or A >= 0, we can do this by taking the ones\n      complement of A (for GE) and shifting the sign bit to the low bit.  */\n   if (op1 == const0_rtx && (code == LT || code == GE)\n-      && GET_MODE_CLASS (mode) == MODE_INT\n+      && is_int_mode (mode, &int_mode)\n       && (normalizep || STORE_FLAG_VALUE == 1\n-\t  || val_signbit_p (mode, STORE_FLAG_VALUE)))\n+\t  || val_signbit_p (int_mode, STORE_FLAG_VALUE)))\n     {\n       subtarget = target;\n \n       if (!target)\n-\ttarget_mode = mode;\n+\ttarget_mode = int_mode;\n \n       /* If the result is to be wider than OP0, it is best to convert it\n \t first.  If it is to be narrower, it is *incorrect* to convert it\n \t first.  */\n-      else if (GET_MODE_SIZE (target_mode) > GET_MODE_SIZE (mode))\n+      else if (GET_MODE_SIZE (target_mode) > GET_MODE_SIZE (int_mode))\n \t{\n-\t  op0 = convert_modes (target_mode, mode, op0, 0);\n+\t  op0 = convert_modes (target_mode, int_mode, op0, 0);\n \t  mode = target_mode;\n \t}\n \n@@ -5925,8 +5926,9 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \n   /* The remaining tricks only apply to integer comparisons.  */\n \n-  if (GET_MODE_CLASS (mode) == MODE_INT)\n-    return emit_store_flag_int (target, subtarget, code, op0, op1, mode,\n+  scalar_int_mode int_mode;\n+  if (is_int_mode (mode, &int_mode))\n+    return emit_store_flag_int (target, subtarget, code, op0, op1, int_mode,\n \t\t\t\tunsignedp, normalizep, trueval);\n \n   return 0;"}, {"sha": "225b8c2925ecd7f939a99c76561333624984c178", "filename": "gcc/expr.c", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b4206259f10455603e0c90825566de1ea777c04a", "patch": "@@ -630,6 +630,7 @@ rtx\n convert_modes (machine_mode mode, machine_mode oldmode, rtx x, int unsignedp)\n {\n   rtx temp;\n+  scalar_int_mode int_mode;\n \n   /* If FROM is a SUBREG that indicates that we have already done at least\n      the required extension, strip it.  */\n@@ -645,32 +646,33 @@ convert_modes (machine_mode mode, machine_mode oldmode, rtx x, int unsignedp)\n   if (mode == oldmode)\n     return x;\n \n-  if (CONST_SCALAR_INT_P (x) && GET_MODE_CLASS (mode) == MODE_INT)\n+  if (CONST_SCALAR_INT_P (x)\n+      && is_int_mode (mode, &int_mode))\n     {\n       /* If the caller did not tell us the old mode, then there is not\n \t much to do with respect to canonicalization.  We have to\n \t assume that all the bits are significant.  */\n       if (GET_MODE_CLASS (oldmode) != MODE_INT)\n \toldmode = MAX_MODE_INT;\n       wide_int w = wide_int::from (rtx_mode_t (x, oldmode),\n-\t\t\t\t   GET_MODE_PRECISION (mode),\n+\t\t\t\t   GET_MODE_PRECISION (int_mode),\n \t\t\t\t   unsignedp ? UNSIGNED : SIGNED);\n-      return immed_wide_int_const (w, mode);\n+      return immed_wide_int_const (w, int_mode);\n     }\n \n   /* We can do this with a gen_lowpart if both desired and current modes\n      are integer, and this is either a constant integer, a register, or a\n      non-volatile MEM. */\n-  if (GET_MODE_CLASS (mode) == MODE_INT\n-      && GET_MODE_CLASS (oldmode) == MODE_INT\n-      && GET_MODE_PRECISION (mode) <= GET_MODE_PRECISION (oldmode)\n-      && ((MEM_P (x) && !MEM_VOLATILE_P (x) && direct_load[(int) mode])\n+  scalar_int_mode int_oldmode;\n+  if (is_int_mode (mode, &int_mode)\n+      && is_int_mode (oldmode, &int_oldmode)\n+      && GET_MODE_PRECISION (int_mode) <= GET_MODE_PRECISION (int_oldmode)\n+      && ((MEM_P (x) && !MEM_VOLATILE_P (x) && direct_load[(int) int_mode])\n           || (REG_P (x)\n               && (!HARD_REGISTER_P (x)\n-                  || HARD_REGNO_MODE_OK (REGNO (x), mode))\n-              && TRULY_NOOP_TRUNCATION_MODES_P (mode, GET_MODE (x)))))\n-\n-   return gen_lowpart (mode, x);\n+                  || HARD_REGNO_MODE_OK (REGNO (x), int_mode))\n+              && TRULY_NOOP_TRUNCATION_MODES_P (int_mode, GET_MODE (x)))))\n+   return gen_lowpart (int_mode, x);\n \n   /* Converting from integer constant into mode is always equivalent to an\n      subreg operation.  */\n@@ -6872,20 +6874,21 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t case, if it has reverse storage order, it needs to be accessed as a\n \t scalar field with reverse storage order and we must first put the\n \t value into target order.  */\n+      scalar_int_mode temp_mode;\n       if (AGGREGATE_TYPE_P (TREE_TYPE (exp))\n-\t  && GET_MODE_CLASS (GET_MODE (temp)) == MODE_INT)\n+\t  && is_int_mode (GET_MODE (temp), &temp_mode))\n \t{\n-\t  HOST_WIDE_INT size = GET_MODE_BITSIZE (GET_MODE (temp));\n+\t  HOST_WIDE_INT size = GET_MODE_BITSIZE (temp_mode);\n \n \t  reverse = TYPE_REVERSE_STORAGE_ORDER (TREE_TYPE (exp));\n \n \t  if (reverse)\n-\t    temp = flip_storage_order (GET_MODE (temp), temp);\n+\t    temp = flip_storage_order (temp_mode, temp);\n \n \t  if (bitsize < size\n \t      && reverse ? !BYTES_BIG_ENDIAN : BYTES_BIG_ENDIAN\n \t      && !(mode == BLKmode && bitsize > BITS_PER_WORD))\n-\t    temp = expand_shift (RSHIFT_EXPR, GET_MODE (temp), temp,\n+\t    temp = expand_shift (RSHIFT_EXPR, temp_mode, temp,\n \t\t\t\t size - bitsize, NULL_RTX, 1);\n \t}\n \n@@ -9959,13 +9962,15 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t    || GET_MODE_CLASS (mode) == MODE_VECTOR_ACCUM\n \t    || GET_MODE_CLASS (mode) == MODE_VECTOR_UACCUM)\n \t  return const_vector_from_tree (exp);\n-\tif (GET_MODE_CLASS (mode) == MODE_INT)\n+\tscalar_int_mode int_mode;\n+\tif (is_int_mode (mode, &int_mode))\n \t  {\n \t    if (VECTOR_BOOLEAN_TYPE_P (TREE_TYPE (exp)))\n \t      return const_scalar_mask_from_tree (exp);\n \t    else\n \t      {\n-\t\ttree type_for_mode = lang_hooks.types.type_for_mode (mode, 1);\n+\t\ttree type_for_mode\n+\t\t  = lang_hooks.types.type_for_mode (int_mode, 1);\n \t\tif (type_for_mode)\n \t\t  tmp = fold_unary_loc (loc, VIEW_CONVERT_EXPR,\n \t\t\t\t\ttype_for_mode, exp);\n@@ -10360,9 +10365,9 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t\t    && compare_tree_int (index1, TREE_STRING_LENGTH (init)) < 0)\n \t\t  {\n \t\t    tree type = TREE_TYPE (TREE_TYPE (init));\n-\t\t    machine_mode mode = TYPE_MODE (type);\n+\t\t    scalar_int_mode mode;\n \n-\t\t    if (GET_MODE_CLASS (mode) == MODE_INT\n+\t\t    if (is_int_mode (TYPE_MODE (type), &mode)\n \t\t\t&& GET_MODE_SIZE (mode) == 1)\n \t\t      return gen_int_mode (TREE_STRING_POINTER (init)\n \t\t\t\t\t   [TREE_INT_CST_LOW (index1)],\n@@ -10380,6 +10385,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t{\n \t  unsigned HOST_WIDE_INT idx;\n \t  tree field, value;\n+\t  scalar_int_mode field_mode;\n \n \t  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (treeop0),\n \t\t\t\t    idx, field, value)\n@@ -10392,8 +10398,8 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t\t   the bitfield does not meet either of those conditions,\n \t\t   we can't do this optimization.  */\n \t\t&& (! DECL_BIT_FIELD (field)\n-\t\t    || ((GET_MODE_CLASS (DECL_MODE (field)) == MODE_INT)\n-\t\t\t&& (GET_MODE_PRECISION (DECL_MODE (field))\n+\t\t    || (is_int_mode (DECL_MODE (field), &field_mode)\n+\t\t\t&& (GET_MODE_PRECISION (field_mode)\n \t\t\t    <= HOST_BITS_PER_WIDE_INT))))\n \t      {\n \t\tif (DECL_BIT_FIELD (field)\n@@ -10727,18 +10733,19 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t       and this is for big-endian data, we must put the field\n \t       into the high-order bits.  And we must also put it back\n \t       into memory order if it has been previously reversed.  */\n+\t    scalar_int_mode op0_mode;\n \t    if (TREE_CODE (type) == RECORD_TYPE\n-\t\t&& GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT)\n+\t\t&& is_int_mode (GET_MODE (op0), &op0_mode))\n \t      {\n-\t\tHOST_WIDE_INT size = GET_MODE_BITSIZE (GET_MODE (op0));\n+\t\tHOST_WIDE_INT size = GET_MODE_BITSIZE (op0_mode);\n \n \t\tif (bitsize < size\n \t\t    && reversep ? !BYTES_BIG_ENDIAN : BYTES_BIG_ENDIAN)\n-\t\t  op0 = expand_shift (LSHIFT_EXPR, GET_MODE (op0), op0,\n+\t\t  op0 = expand_shift (LSHIFT_EXPR, op0_mode, op0,\n \t\t\t\t      size - bitsize, op0, 1);\n \n \t\tif (reversep)\n-\t\t  op0 = flip_storage_order (GET_MODE (op0), op0);\n+\t\t  op0 = flip_storage_order (op0_mode, op0);\n \t      }\n \n \t    /* If the result type is BLKmode, store the data into a temporary"}, {"sha": "b9f2a39ee853e6071e39783f5bb3d7a68166b85e", "filename": "gcc/fold-const.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=b4206259f10455603e0c90825566de1ea777c04a", "patch": "@@ -13652,14 +13652,15 @@ fold_read_from_constant_string (tree exp)\n \t  string = exp1;\n \t}\n \n+      scalar_int_mode char_mode;\n       if (string\n \t  && TYPE_MODE (TREE_TYPE (exp)) == TYPE_MODE (TREE_TYPE (TREE_TYPE (string)))\n \t  && TREE_CODE (string) == STRING_CST\n \t  && TREE_CODE (index) == INTEGER_CST\n \t  && compare_tree_int (index, TREE_STRING_LENGTH (string)) < 0\n-\t  && (GET_MODE_CLASS (TYPE_MODE (TREE_TYPE (TREE_TYPE (string))))\n-\t      == MODE_INT)\n-\t  && (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (TREE_TYPE (string)))) == 1))\n+\t  && is_int_mode (TYPE_MODE (TREE_TYPE (TREE_TYPE (string))),\n+\t\t\t  &char_mode)\n+\t  && GET_MODE_SIZE (char_mode) == 1)\n \treturn build_int_cst_type (TREE_TYPE (exp),\n \t\t\t\t   (TREE_STRING_POINTER (string)\n \t\t\t\t    [TREE_INT_CST_LOW (index)]));"}, {"sha": "7899e09195fe200088d95d54d94019e5c013b48a", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=b4206259f10455603e0c90825566de1ea777c04a", "patch": "@@ -528,8 +528,9 @@ get_format_string (tree format, location_t *ploc)\n \n   tree type = TREE_TYPE (format);\n \n-  if (GET_MODE_CLASS (TYPE_MODE (TREE_TYPE (type))) != MODE_INT\n-      || GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (type))) != 1)\n+  scalar_int_mode char_mode;\n+  if (!is_int_mode (TYPE_MODE (TREE_TYPE (type)), &char_mode)\n+      || GET_MODE_SIZE (char_mode) != 1)\n     {\n       /* Wide format string.  */\n       return NULL;"}, {"sha": "ea47870590d99a0038ed01a4e7a4389d31b76259", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=b4206259f10455603e0c90825566de1ea777c04a", "patch": "@@ -1,3 +1,9 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* go-lang.c (go_langhook_type_for_mode): Use is_int_mode.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "d470d5ab20a244e80857420ab06da231c26f94d6", "filename": "gcc/go/go-lang.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fgo%2Fgo-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fgo%2Fgo-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-lang.c?ref=b4206259f10455603e0c90825566de1ea777c04a", "patch": "@@ -382,10 +382,11 @@ go_langhook_type_for_mode (machine_mode mode, int unsignedp)\n       return NULL_TREE;\n     }\n \n+  scalar_int_mode imode;\n   scalar_float_mode fmode;\n   enum mode_class mc = GET_MODE_CLASS (mode);\n-  if (mc == MODE_INT)\n-    return go_langhook_type_for_size (GET_MODE_BITSIZE (mode), unsignedp);\n+  if (is_int_mode (mode, &imode))\n+    return go_langhook_type_for_size (GET_MODE_BITSIZE (imode), unsignedp);\n   else if (is_float_mode (mode, &fmode))\n     {\n       switch (GET_MODE_BITSIZE (fmode))"}, {"sha": "497b0fbde54e610afa29198e0266f01d7587baa4", "filename": "gcc/machmode.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=b4206259f10455603e0c90825566de1ea777c04a", "patch": "@@ -695,6 +695,21 @@ struct int_n_data_t {\n extern bool int_n_enabled_p[NUM_INT_N_ENTS];\n extern const int_n_data_t int_n_data[NUM_INT_N_ENTS];\n \n+/* Return true if MODE has class MODE_INT, storing it as a scalar_int_mode\n+   in *INT_MODE if so.  */\n+\n+template<typename T>\n+inline bool\n+is_int_mode (machine_mode mode, T *int_mode)\n+{\n+  if (GET_MODE_CLASS (mode) == MODE_INT)\n+    {\n+      *int_mode = scalar_int_mode (scalar_int_mode::from_int (mode));\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* Return true if MODE has class MODE_FLOAT, storing it as a\n    scalar_float_mode in *FLOAT_MODE if so.  */\n "}, {"sha": "5ad3c6d86f5130035ebf3cf5867efbffea5ad6a8", "filename": "gcc/optabs-libfuncs.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Foptabs-libfuncs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Foptabs-libfuncs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-libfuncs.c?ref=b4206259f10455603e0c90825566de1ea777c04a", "patch": "@@ -189,19 +189,20 @@ gen_int_libfunc (optab optable, const char *opname, char suffix,\n {\n   int maxsize = 2 * BITS_PER_WORD;\n   int minsize = BITS_PER_WORD;\n+  scalar_int_mode int_mode;\n \n-  if (GET_MODE_CLASS (mode) != MODE_INT)\n+  if (!is_int_mode (mode, &int_mode))\n     return;\n   if (maxsize < LONG_LONG_TYPE_SIZE)\n     maxsize = LONG_LONG_TYPE_SIZE;\n   if (minsize > INT_TYPE_SIZE\n       && (trapv_binoptab_p (optable)\n \t  || trapv_unoptab_p (optable)))\n     minsize = INT_TYPE_SIZE;\n-  if (GET_MODE_BITSIZE (mode) < minsize\n-      || GET_MODE_BITSIZE (mode) > maxsize)\n+  if (GET_MODE_BITSIZE (int_mode) < minsize\n+      || GET_MODE_BITSIZE (int_mode) > maxsize)\n     return;\n-  gen_libfunc (optable, opname, suffix, mode);\n+  gen_libfunc (optable, opname, suffix, int_mode);\n }\n \n /* Like gen_libfunc, but verify that FP and set decimal prefix if needed.  */"}, {"sha": "65a098eb90e88a979e4f5c2e6daeadd5afd13753", "filename": "gcc/optabs.c", "status": "modified", "additions": 70, "deletions": 65, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=b4206259f10455603e0c90825566de1ea777c04a", "patch": "@@ -1113,6 +1113,7 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n        ? OPTAB_WIDEN : methods);\n   enum mode_class mclass;\n   machine_mode wider_mode;\n+  scalar_int_mode int_mode;\n   rtx libfunc;\n   rtx temp;\n   rtx_insn *entry_last = get_last_insn ();\n@@ -1161,22 +1162,22 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t&& optab_handler (rotr_optab, mode) != CODE_FOR_nothing)\n        || (binoptab == rotr_optab\n \t   && optab_handler (rotl_optab, mode) != CODE_FOR_nothing))\n-      && mclass == MODE_INT)\n+      && is_int_mode (mode, &int_mode))\n     {\n       optab otheroptab = (binoptab == rotl_optab ? rotr_optab : rotl_optab);\n       rtx newop1;\n-      unsigned int bits = GET_MODE_PRECISION (mode);\n+      unsigned int bits = GET_MODE_PRECISION (int_mode);\n \n       if (CONST_INT_P (op1))\n         newop1 = GEN_INT (bits - INTVAL (op1));\n-      else if (targetm.shift_truncation_mask (mode) == bits - 1)\n+      else if (targetm.shift_truncation_mask (int_mode) == bits - 1)\n         newop1 = negate_rtx (GET_MODE (op1), op1);\n       else\n         newop1 = expand_binop (GET_MODE (op1), sub_optab,\n \t\t\t       gen_int_mode (bits, GET_MODE (op1)), op1,\n \t\t\t       NULL_RTX, unsignedp, OPTAB_DIRECT);\n \n-      temp = expand_binop_directly (mode, otheroptab, op0, newop1,\n+      temp = expand_binop_directly (int_mode, otheroptab, op0, newop1,\n \t\t\t\t    target, unsignedp, methods, last);\n       if (temp)\n \treturn temp;\n@@ -1320,8 +1321,8 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n   /* These can be done a word at a time.  */\n   if ((binoptab == and_optab || binoptab == ior_optab || binoptab == xor_optab)\n-      && mclass == MODE_INT\n-      && GET_MODE_SIZE (mode) > UNITS_PER_WORD\n+      && is_int_mode (mode, &int_mode)\n+      && GET_MODE_SIZE (int_mode) > UNITS_PER_WORD\n       && optab_handler (binoptab, word_mode) != CODE_FOR_nothing)\n     {\n       int i;\n@@ -1333,17 +1334,17 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t  || target == op0\n \t  || target == op1\n \t  || !valid_multiword_target_p (target))\n-\ttarget = gen_reg_rtx (mode);\n+\ttarget = gen_reg_rtx (int_mode);\n \n       start_sequence ();\n \n       /* Do the actual arithmetic.  */\n-      for (i = 0; i < GET_MODE_BITSIZE (mode) / BITS_PER_WORD; i++)\n+      for (i = 0; i < GET_MODE_BITSIZE (int_mode) / BITS_PER_WORD; i++)\n \t{\n-\t  rtx target_piece = operand_subword (target, i, 1, mode);\n+\t  rtx target_piece = operand_subword (target, i, 1, int_mode);\n \t  rtx x = expand_binop (word_mode, binoptab,\n-\t\t\t\toperand_subword_force (op0, i, mode),\n-\t\t\t\toperand_subword_force (op1, i, mode),\n+\t\t\t\toperand_subword_force (op0, i, int_mode),\n+\t\t\t\toperand_subword_force (op1, i, int_mode),\n \t\t\t\ttarget_piece, unsignedp, next_methods);\n \n \t  if (x == 0)\n@@ -1356,7 +1357,7 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       insns = get_insns ();\n       end_sequence ();\n \n-      if (i == GET_MODE_BITSIZE (mode) / BITS_PER_WORD)\n+      if (i == GET_MODE_BITSIZE (int_mode) / BITS_PER_WORD)\n \t{\n \t  emit_insn (insns);\n \t  return target;\n@@ -1366,18 +1367,18 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   /* Synthesize double word shifts from single word shifts.  */\n   if ((binoptab == lshr_optab || binoptab == ashl_optab\n        || binoptab == ashr_optab)\n-      && mclass == MODE_INT\n+      && is_int_mode (mode, &int_mode)\n       && (CONST_INT_P (op1) || optimize_insn_for_speed_p ())\n-      && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n-      && GET_MODE_PRECISION (mode) == GET_MODE_BITSIZE (mode)\n+      && GET_MODE_SIZE (int_mode) == 2 * UNITS_PER_WORD\n+      && GET_MODE_PRECISION (int_mode) == GET_MODE_BITSIZE (int_mode)\n       && optab_handler (binoptab, word_mode) != CODE_FOR_nothing\n       && optab_handler (ashl_optab, word_mode) != CODE_FOR_nothing\n       && optab_handler (lshr_optab, word_mode) != CODE_FOR_nothing)\n     {\n       unsigned HOST_WIDE_INT shift_mask, double_shift_mask;\n       machine_mode op1_mode;\n \n-      double_shift_mask = targetm.shift_truncation_mask (mode);\n+      double_shift_mask = targetm.shift_truncation_mask (int_mode);\n       shift_mask = targetm.shift_truncation_mask (word_mode);\n       op1_mode = GET_MODE (op1) != VOIDmode ? GET_MODE (op1) : word_mode;\n \n@@ -1405,7 +1406,7 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t      || target == op0\n \t      || target == op1\n \t      || !valid_multiword_target_p (target))\n-\t    target = gen_reg_rtx (mode);\n+\t    target = gen_reg_rtx (int_mode);\n \n \t  start_sequence ();\n \n@@ -1417,11 +1418,11 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t  left_shift = binoptab == ashl_optab;\n \t  outof_word = left_shift ^ ! WORDS_BIG_ENDIAN;\n \n-\t  outof_target = operand_subword (target, outof_word, 1, mode);\n-\t  into_target = operand_subword (target, 1 - outof_word, 1, mode);\n+\t  outof_target = operand_subword (target, outof_word, 1, int_mode);\n+\t  into_target = operand_subword (target, 1 - outof_word, 1, int_mode);\n \n-\t  outof_input = operand_subword_force (op0, outof_word, mode);\n-\t  into_input = operand_subword_force (op0, 1 - outof_word, mode);\n+\t  outof_input = operand_subword_force (op0, outof_word, int_mode);\n+\t  into_input = operand_subword_force (op0, 1 - outof_word, int_mode);\n \n \t  if (expand_doubleword_shift (op1_mode, binoptab,\n \t\t\t\t       outof_input, into_input, op1,\n@@ -1440,9 +1441,9 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n   /* Synthesize double word rotates from single word shifts.  */\n   if ((binoptab == rotl_optab || binoptab == rotr_optab)\n-      && mclass == MODE_INT\n+      && is_int_mode (mode, &int_mode)\n       && CONST_INT_P (op1)\n-      && GET_MODE_PRECISION (mode) == 2 * BITS_PER_WORD\n+      && GET_MODE_PRECISION (int_mode) == 2 * BITS_PER_WORD\n       && optab_handler (ashl_optab, word_mode) != CODE_FOR_nothing\n       && optab_handler (lshr_optab, word_mode) != CODE_FOR_nothing)\n     {\n@@ -1463,7 +1464,7 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t  || target == op1\n \t  || !REG_P (target)\n \t  || !valid_multiword_target_p (target))\n-\ttarget = gen_reg_rtx (mode);\n+\ttarget = gen_reg_rtx (int_mode);\n \n       start_sequence ();\n \n@@ -1477,11 +1478,11 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       left_shift = (binoptab == rotl_optab);\n       outof_word = left_shift ^ ! WORDS_BIG_ENDIAN;\n \n-      outof_target = operand_subword (target, outof_word, 1, mode);\n-      into_target = operand_subword (target, 1 - outof_word, 1, mode);\n+      outof_target = operand_subword (target, outof_word, 1, int_mode);\n+      into_target = operand_subword (target, 1 - outof_word, 1, int_mode);\n \n-      outof_input = operand_subword_force (op0, outof_word, mode);\n-      into_input = operand_subword_force (op0, 1 - outof_word, mode);\n+      outof_input = operand_subword_force (op0, outof_word, int_mode);\n+      into_input = operand_subword_force (op0, 1 - outof_word, int_mode);\n \n       if (shift_count == BITS_PER_WORD)\n \t{\n@@ -1557,13 +1558,13 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n   /* These can be done a word at a time by propagating carries.  */\n   if ((binoptab == add_optab || binoptab == sub_optab)\n-      && mclass == MODE_INT\n-      && GET_MODE_SIZE (mode) >= 2 * UNITS_PER_WORD\n+      && is_int_mode (mode, &int_mode)\n+      && GET_MODE_SIZE (int_mode) >= 2 * UNITS_PER_WORD\n       && optab_handler (binoptab, word_mode) != CODE_FOR_nothing)\n     {\n       unsigned int i;\n       optab otheroptab = binoptab == add_optab ? sub_optab : add_optab;\n-      const unsigned int nwords = GET_MODE_BITSIZE (mode) / BITS_PER_WORD;\n+      const unsigned int nwords = GET_MODE_BITSIZE (int_mode) / BITS_PER_WORD;\n       rtx carry_in = NULL_RTX, carry_out = NULL_RTX;\n       rtx xop0, xop1, xtarget;\n \n@@ -1577,10 +1578,10 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n #endif\n \n       /* Prepare the operands.  */\n-      xop0 = force_reg (mode, op0);\n-      xop1 = force_reg (mode, op1);\n+      xop0 = force_reg (int_mode, op0);\n+      xop1 = force_reg (int_mode, op1);\n \n-      xtarget = gen_reg_rtx (mode);\n+      xtarget = gen_reg_rtx (int_mode);\n \n       if (target == 0 || !REG_P (target) || !valid_multiword_target_p (target))\n \ttarget = xtarget;\n@@ -1593,9 +1594,9 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       for (i = 0; i < nwords; i++)\n \t{\n \t  int index = (WORDS_BIG_ENDIAN ? nwords - i - 1 : i);\n-\t  rtx target_piece = operand_subword (xtarget, index, 1, mode);\n-\t  rtx op0_piece = operand_subword_force (xop0, index, mode);\n-\t  rtx op1_piece = operand_subword_force (xop1, index, mode);\n+\t  rtx target_piece = operand_subword (xtarget, index, 1, int_mode);\n+\t  rtx op0_piece = operand_subword_force (xop0, index, int_mode);\n+\t  rtx op1_piece = operand_subword_force (xop1, index, int_mode);\n \t  rtx x;\n \n \t  /* Main add/subtract of the input operands.  */\n@@ -1654,16 +1655,16 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t  carry_in = carry_out;\n \t}\n \n-      if (i == GET_MODE_BITSIZE (mode) / (unsigned) BITS_PER_WORD)\n+      if (i == GET_MODE_BITSIZE (int_mode) / (unsigned) BITS_PER_WORD)\n \t{\n-\t  if (optab_handler (mov_optab, mode) != CODE_FOR_nothing\n+\t  if (optab_handler (mov_optab, int_mode) != CODE_FOR_nothing\n \t      || ! rtx_equal_p (target, xtarget))\n \t    {\n \t      rtx_insn *temp = emit_move_insn (target, xtarget);\n \n \t      set_dst_reg_note (temp, REG_EQUAL,\n \t\t\t\tgen_rtx_fmt_ee (optab_to_code (binoptab),\n-\t\t\t\t\t\tmode, copy_rtx (xop0),\n+\t\t\t\t\t\tint_mode, copy_rtx (xop0),\n \t\t\t\t\t\tcopy_rtx (xop1)),\n \t\t\t\ttarget);\n \t    }\n@@ -1683,40 +1684,40 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n      try using a signed widening multiply.  */\n \n   if (binoptab == smul_optab\n-      && mclass == MODE_INT\n-      && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n+      && is_int_mode (mode, &int_mode)\n+      && GET_MODE_SIZE (int_mode) == 2 * UNITS_PER_WORD\n       && optab_handler (smul_optab, word_mode) != CODE_FOR_nothing\n       && optab_handler (add_optab, word_mode) != CODE_FOR_nothing)\n     {\n       rtx product = NULL_RTX;\n-      if (widening_optab_handler (umul_widen_optab, mode, word_mode)\n-\t    != CODE_FOR_nothing)\n+      if (widening_optab_handler (umul_widen_optab, int_mode, word_mode)\n+\t  != CODE_FOR_nothing)\n \t{\n-\t  product = expand_doubleword_mult (mode, op0, op1, target,\n+\t  product = expand_doubleword_mult (int_mode, op0, op1, target,\n \t\t\t\t\t    true, methods);\n \t  if (!product)\n \t    delete_insns_since (last);\n \t}\n \n       if (product == NULL_RTX\n-\t  && widening_optab_handler (smul_widen_optab, mode, word_mode)\n-\t\t!= CODE_FOR_nothing)\n+\t  && (widening_optab_handler (smul_widen_optab, int_mode, word_mode)\n+\t      != CODE_FOR_nothing))\n \t{\n-\t  product = expand_doubleword_mult (mode, op0, op1, target,\n+\t  product = expand_doubleword_mult (int_mode, op0, op1, target,\n \t\t\t\t\t    false, methods);\n \t  if (!product)\n \t    delete_insns_since (last);\n \t}\n \n       if (product != NULL_RTX)\n \t{\n-\t  if (optab_handler (mov_optab, mode) != CODE_FOR_nothing)\n+\t  if (optab_handler (mov_optab, int_mode) != CODE_FOR_nothing)\n \t    {\n \t      rtx_insn *move = emit_move_insn (target ? target : product,\n \t\t\t\t\t       product);\n \t      set_dst_reg_note (move,\n \t\t\t\tREG_EQUAL,\n-\t\t\t\tgen_rtx_fmt_ee (MULT, mode,\n+\t\t\t\tgen_rtx_fmt_ee (MULT, int_mode,\n \t\t\t\t\t\tcopy_rtx (op0),\n \t\t\t\t\t\tcopy_rtx (op1)),\n \t\t\t\ttarget ? target : product);\n@@ -2696,6 +2697,7 @@ expand_unop (machine_mode mode, optab unoptab, rtx op0, rtx target,\n {\n   enum mode_class mclass = GET_MODE_CLASS (mode);\n   machine_mode wider_mode;\n+  scalar_int_mode int_mode;\n   scalar_float_mode float_mode;\n   rtx temp;\n   rtx libfunc;\n@@ -2853,24 +2855,24 @@ expand_unop (machine_mode mode, optab unoptab, rtx op0, rtx target,\n \n   /* These can be done a word at a time.  */\n   if (unoptab == one_cmpl_optab\n-      && mclass == MODE_INT\n-      && GET_MODE_SIZE (mode) > UNITS_PER_WORD\n+      && is_int_mode (mode, &int_mode)\n+      && GET_MODE_SIZE (int_mode) > UNITS_PER_WORD\n       && optab_handler (unoptab, word_mode) != CODE_FOR_nothing)\n     {\n       int i;\n       rtx_insn *insns;\n \n       if (target == 0 || target == op0 || !valid_multiword_target_p (target))\n-\ttarget = gen_reg_rtx (mode);\n+\ttarget = gen_reg_rtx (int_mode);\n \n       start_sequence ();\n \n       /* Do the actual arithmetic.  */\n-      for (i = 0; i < GET_MODE_BITSIZE (mode) / BITS_PER_WORD; i++)\n+      for (i = 0; i < GET_MODE_BITSIZE (int_mode) / BITS_PER_WORD; i++)\n \t{\n-\t  rtx target_piece = operand_subword (target, i, 1, mode);\n+\t  rtx target_piece = operand_subword (target, i, 1, int_mode);\n \t  rtx x = expand_unop (word_mode, unoptab,\n-\t\t\t       operand_subword_force (op0, i, mode),\n+\t\t\t       operand_subword_force (op0, i, int_mode),\n \t\t\t       target_piece, unsignedp);\n \n \t  if (target_piece != x)\n@@ -3116,18 +3118,20 @@ expand_abs_nojump (machine_mode mode, rtx op0, rtx target,\n      value of X as (((signed) x >> (W-1)) ^ x) - ((signed) x >> (W-1)),\n      where W is the width of MODE.  */\n \n-  if (GET_MODE_CLASS (mode) == MODE_INT\n+  scalar_int_mode int_mode;\n+  if (is_int_mode (mode, &int_mode)\n       && BRANCH_COST (optimize_insn_for_speed_p (),\n \t      \t      false) >= 2)\n     {\n-      rtx extended = expand_shift (RSHIFT_EXPR, mode, op0,\n-\t\t\t\t   GET_MODE_PRECISION (mode) - 1,\n+      rtx extended = expand_shift (RSHIFT_EXPR, int_mode, op0,\n+\t\t\t\t   GET_MODE_PRECISION (int_mode) - 1,\n \t\t\t\t   NULL_RTX, 0);\n \n-      temp = expand_binop (mode, xor_optab, extended, op0, target, 0,\n+      temp = expand_binop (int_mode, xor_optab, extended, op0, target, 0,\n \t\t\t   OPTAB_LIB_WIDEN);\n       if (temp != 0)\n-\ttemp = expand_binop (mode, result_unsignedp ? sub_optab : subv_optab,\n+\ttemp = expand_binop (int_mode,\n+\t\t\t     result_unsignedp ? sub_optab : subv_optab,\n                              temp, extended, target, 0, OPTAB_LIB_WIDEN);\n \n       if (temp != 0)\n@@ -3220,15 +3224,16 @@ expand_one_cmpl_abs_nojump (machine_mode mode, rtx op0, rtx target)\n   /* If this machine has expensive jumps, we can do one's complement\n      absolute value of X as (((signed) x >> (W-1)) ^ x).  */\n \n-  if (GET_MODE_CLASS (mode) == MODE_INT\n+  scalar_int_mode int_mode;\n+  if (is_int_mode (mode, &int_mode)\n       && BRANCH_COST (optimize_insn_for_speed_p (),\n \t             false) >= 2)\n     {\n-      rtx extended = expand_shift (RSHIFT_EXPR, mode, op0,\n-\t\t\t\t   GET_MODE_PRECISION (mode) - 1,\n+      rtx extended = expand_shift (RSHIFT_EXPR, int_mode, op0,\n+\t\t\t\t   GET_MODE_PRECISION (int_mode) - 1,\n \t\t\t\t   NULL_RTX, 0);\n \n-      temp = expand_binop (mode, xor_optab, extended, op0, target, 0,\n+      temp = expand_binop (int_mode, xor_optab, extended, op0, target, 0,\n \t\t\t   OPTAB_LIB_WIDEN);\n \n       if (temp != 0)"}, {"sha": "c4fd0e9f8f7e649a8001a256f69a9c8c6c3287df", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=b4206259f10455603e0c90825566de1ea777c04a", "patch": "@@ -77,11 +77,12 @@ mode_signbit_p (machine_mode mode, const_rtx x)\n {\n   unsigned HOST_WIDE_INT val;\n   unsigned int width;\n+  scalar_int_mode int_mode;\n \n-  if (GET_MODE_CLASS (mode) != MODE_INT)\n+  if (!is_int_mode (mode, &int_mode))\n     return false;\n \n-  width = GET_MODE_PRECISION (mode);\n+  width = GET_MODE_PRECISION (int_mode);\n   if (width == 0)\n     return false;\n \n@@ -129,15 +130,16 @@ bool\n val_signbit_p (machine_mode mode, unsigned HOST_WIDE_INT val)\n {\n   unsigned int width;\n+  scalar_int_mode int_mode;\n \n-  if (GET_MODE_CLASS (mode) != MODE_INT)\n+  if (!is_int_mode (mode, &int_mode))\n     return false;\n \n-  width = GET_MODE_PRECISION (mode);\n+  width = GET_MODE_PRECISION (int_mode);\n   if (width == 0 || width > HOST_BITS_PER_WIDE_INT)\n     return false;\n \n-  val &= GET_MODE_MASK (mode);\n+  val &= GET_MODE_MASK (int_mode);\n   return val == (HOST_WIDE_INT_1U << (width - 1));\n }\n \n@@ -148,10 +150,11 @@ val_signbit_known_set_p (machine_mode mode, unsigned HOST_WIDE_INT val)\n {\n   unsigned int width;\n \n-  if (GET_MODE_CLASS (mode) != MODE_INT)\n+  scalar_int_mode int_mode;\n+  if (!is_int_mode (mode, &int_mode))\n     return false;\n \n-  width = GET_MODE_PRECISION (mode);\n+  width = GET_MODE_PRECISION (int_mode);\n   if (width == 0 || width > HOST_BITS_PER_WIDE_INT)\n     return false;\n \n@@ -166,10 +169,11 @@ val_signbit_known_clear_p (machine_mode mode, unsigned HOST_WIDE_INT val)\n {\n   unsigned int width;\n \n-  if (GET_MODE_CLASS (mode) != MODE_INT)\n+  scalar_int_mode int_mode;\n+  if (!is_int_mode (mode, &int_mode))\n     return false;\n \n-  width = GET_MODE_PRECISION (mode);\n+  width = GET_MODE_PRECISION (int_mode);\n   if (width == 0 || width > HOST_BITS_PER_WIDE_INT)\n     return false;\n \n@@ -4828,18 +4832,19 @@ simplify_relational_operation_1 (enum rtx_code code, machine_mode mode,\n \n   /* (ne:SI (zero_extract:SI FOO (const_int 1) BAR) (const_int 0))) is\n      the same as (zero_extract:SI FOO (const_int 1) BAR).  */\n+  scalar_int_mode int_mode;\n   if (code == NE\n       && op1 == const0_rtx\n-      && GET_MODE_CLASS (mode) == MODE_INT\n+      && is_int_mode (mode, &int_mode)\n       && cmp_mode != VOIDmode\n       /* ??? Work-around BImode bugs in the ia64 backend.  */\n-      && mode != BImode\n+      && int_mode != BImode\n       && cmp_mode != BImode\n       && nonzero_bits (op0, cmp_mode) == 1\n       && STORE_FLAG_VALUE == 1)\n-    return GET_MODE_SIZE (mode) > GET_MODE_SIZE (cmp_mode)\n-\t   ? simplify_gen_unary (ZERO_EXTEND, mode, op0, cmp_mode)\n-\t   : lowpart_subreg (mode, op0, cmp_mode);\n+    return GET_MODE_SIZE (int_mode) > GET_MODE_SIZE (cmp_mode)\n+\t   ? simplify_gen_unary (ZERO_EXTEND, int_mode, op0, cmp_mode)\n+\t   : lowpart_subreg (int_mode, op0, cmp_mode);\n \n   /* (eq/ne (xor x y) 0) simplifies to (eq/ne x y).  */\n   if ((code == EQ || code == NE)"}, {"sha": "c36183487a5ca41e4137cb8c61e6e742d03b9d4f", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4206259f10455603e0c90825566de1ea777c04a/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=b4206259f10455603e0c90825566de1ea777c04a", "patch": "@@ -12634,10 +12634,10 @@ vector_type_mode (const_tree t)\n       && (!targetm.vector_mode_supported_p (mode)\n \t  || !have_regs_of_mode[mode]))\n     {\n-      machine_mode innermode = TREE_TYPE (t)->type_common.mode;\n+      scalar_int_mode innermode;\n \n       /* For integers, try mapping it to a same-sized scalar mode.  */\n-      if (GET_MODE_CLASS (innermode) == MODE_INT)\n+      if (is_int_mode (TREE_TYPE (t)->type_common.mode, &innermode))\n \t{\n \t  unsigned int size = (TYPE_VECTOR_SUBPARTS (t)\n \t\t\t       * GET_MODE_BITSIZE (innermode));"}]}