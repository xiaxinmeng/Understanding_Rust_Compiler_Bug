{"sha": "a1747d2c89a29f9a380073f0f6aa264cc0edda9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE3NDdkMmM4OWEyOWY5YTM4MDA3M2YwZjZhYTI2NGNjMGVkZGE5Yw==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1993-01-14T19:28:19Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1993-01-14T19:28:19Z"}, "message": "(move_operand): Allow all CONST_INTs that can be moved to general registers with one insn.\n\n(move_operand): Allow all CONST_INTs that can be moved to\ngeneral registers with one insn.\n(pre_cint_operand): New predicate for predecrementing ldwm/stwm insns.\n(zdepi_cint_p): New function.\n(depi_cint_operand): Remove.\n(and_mask_p): New name for consec_zeros_p.  All callers changed.\n(srcsi_operand): Removed.\n(all file): Use INT_14_BITS instead of synonym SMALL_INT.\n(emit_move_sequence): Clean up CONST_INT case.\n(compute_zdepi_operands): New name for\ncompute_xdepi_operands_from_integer.  Change second parm to return\nplain integers (was RTXes).\n(print_operand): Handle 'Z' for 'zdepi' source used to movCONST_INT.\n\nFrom-SVN: r3238", "tree": {"sha": "6ca9a1a1452e79d80335245a2c241217b4c1c983", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ca9a1a1452e79d80335245a2c241217b4c1c983"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1747d2c89a29f9a380073f0f6aa264cc0edda9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1747d2c89a29f9a380073f0f6aa264cc0edda9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1747d2c89a29f9a380073f0f6aa264cc0edda9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1747d2c89a29f9a380073f0f6aa264cc0edda9c/comments", "author": null, "committer": null, "parents": [{"sha": "8d2f437448007e2a41b957590a1468e0246b58d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d2f437448007e2a41b957590a1468e0246b58d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d2f437448007e2a41b957590a1468e0246b58d5"}], "stats": {"total": 95, "additions": 43, "deletions": 52}, "files": [{"sha": "800a2e027e7d6266f13d22799ac86800d8476e20", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 43, "deletions": 52, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1747d2c89a29f9a380073f0f6aa264cc0edda9c/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1747d2c89a29f9a380073f0f6aa264cc0edda9c/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=a1747d2c89a29f9a380073f0f6aa264cc0edda9c", "patch": "@@ -134,8 +134,12 @@ move_operand (op, mode)\n   if (register_operand (op, mode))\n     return 1;\n \n-  if (op == CONST0_RTX (mode))\n-    return 1;\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      /* OK if ldo, ldil, or zdepi, can be used.  */\n+      return (INT_14_BITS (op) || (INTVAL (op) & 0x7ff) == 0\n+\t      || zdepi_cint_p (INTVAL (op)));\n+    }\n \n   if (GET_MODE (op) != mode)\n     return 0;\n@@ -279,6 +283,15 @@ arith11_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT && INT_11_BITS (op)));\n }\n \n+int\n+pre_cint_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == CONST_INT\n+\t  && INTVAL (op) >= -0x2000 && INTVAL (op) < 0x10);\n+}\n+\n int\n arith_double_operand (op, mode)\n      rtx op;\n@@ -330,27 +343,22 @@ arith5_operand (op, mode)\n \n /* True iff zdepi can be used to generate this CONST_INT.  */\n int\n-depi_cint_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+zdepi_cint_p (x)\n+     unsigned x;\n {\n-  unsigned x;\n-  unsigned lbmask, t;\n-\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n+  unsigned lsb_mask, t;\n \n   /* This might not be obvious, but it's at least fast.\n      This function is critcal; we don't have the time loops would take.  */\n-  x = INTVAL (op);\n-  lbmask = x & -x;\n-  t = ((x >> 4) + lbmask) & ~(lbmask - 1);\n+  lsb_mask = x & -x;\n+  t = ((x >> 4) + lsb_mask) & ~(lsb_mask - 1);\n+  /* Return true iff t is a power of two.  */\n   return ((t & (t - 1)) == 0);\n }\n \n /* True iff depi or extru can be used to compute (reg & mask).  */\n int\n-consec_zeros_p (mask)\n+and_mask_p (mask)\n      unsigned mask;\n {\n   mask = ~mask;\n@@ -365,7 +373,7 @@ and_operand (op, mode)\n      enum machine_mode mode;\n {\n   return (register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT && consec_zeros_p (INTVAL (op))));\n+\t  || (GET_CODE (op) == CONST_INT && and_mask_p (INTVAL (op))));\n }\n \n /* True iff depi can be used to compute (reg | MASK).  */\n@@ -394,29 +402,6 @@ arith32_operand (op, mode)\n {\n   return register_operand (op, mode) || GET_CODE (op) == CONST_INT;\n }\n-\n-/* True iff OP can be the source of a move to a general register.  */\n-int\n-srcsi_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  /* Not intended for other modes than SImode.  */\n-  if (mode != SImode)\n-    return 0;\n-\n-  /* Accept any register or memory reference.  */\n-  if (nonimmediate_operand (op, mode))\n-    return 1;\n-\n-  if (depi_cint_operand (op, mode))\n-    return 1;\n-\n-  /* OK if ldo or ldil can be used.  */\n-  return (GET_CODE (op) == CONST_INT\n-\t  && (INT_14_BITS (op) || (INTVAL (op) & 0x7ff) == 0));\n-}\n-\n \f\n /* Legitimize PIC addresses.  If the address is already\n    position-independent, we return ORIG.  Newly generated\n@@ -471,7 +456,7 @@ legitimize_pic_address (orig, mode, reg)\n       else abort ();\n       if (GET_CODE (orig) == CONST_INT)\n \t{\n-\t  if (SMALL_INT (orig))\n+\t  if (INT_14_BITS (orig))\n \t    return plus_constant_for_output (base, INTVAL (orig));\n \t  orig = force_reg (Pmode, orig);\n \t}\n@@ -567,7 +552,7 @@ emit_move_sequence (operands, mode, scratch_reg)\n   else if (register_operand (operand0, mode))\n     {\n       if (register_operand (operand1, mode)\n-\t  || (GET_CODE (operand1) == CONST_INT && SMALL_INT (operand1))\n+\t  || (GET_CODE (operand1) == CONST_INT && INT_14_BITS (operand1))\n \t  || (GET_CODE (operand1) == HIGH\n \t      && !symbolic_operand (XEXP (operand1, 0)))\n \t  /* Only `general_operands' can come here, so MEM is ok.  */\n@@ -654,11 +639,10 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t    }\n \t  return 1;\n \t}\n-      else if (depi_cint_operand (operand1, VOIDmode))\n-\treturn 0;\n-      else if (GET_CODE (operand1) == CONST_INT\n-\t       ? (! SMALL_INT (operand1)\n-\t\t  && (INTVAL (operand1) & 0x7ff) != 0) : 1)\n+      else if (GET_CODE (operand1) != CONST_INT\n+\t       || (! INT_14_BITS (operand1)\n+\t\t   && ! ((INTVAL (operand1) & 0x7ff) == 0)\n+\t\t   && !zdepi_cint_p (INTVAL (operand1))))\n \t{\n \t  rtx temp = reload_in_progress ? operand0 : gen_reg_rtx (mode);\n \t  emit_insn (gen_rtx (SET, VOIDmode, temp,\n@@ -705,13 +689,13 @@ singlemove_string (operands)\n }\n \f\n \n-/* Compute position (in OPERANDS[2]) and width (in OPERANDS[3])\n+/* Compute position (in OP[2]) and width (in OP[3])\n    useful for copying or or'ing IMM to a register using bit field\n-   instructions.  Store the immediate value to insert in OPERANDS[1].  */\n+   instructions.  Store the immediate value to insert in OP[1].  */\n void\n-compute_xdepi_operands_from_integer (imm, operands)\n+compute_zdepi_operands (imm, op)\n      unsigned imm;\n-     rtx *operands;\n+     unsigned *op;\n {\n   int lsb, len;\n \n@@ -739,9 +723,9 @@ compute_xdepi_operands_from_integer (imm, operands)\n       imm = (imm & 0xf) - 0x10;\n     }\n \n-  operands[1] = gen_rtx (CONST_INT, VOIDmode, imm);\n-  operands[2] = gen_rtx (CONST_INT, VOIDmode, 31 - lsb);\n-  operands[3] = gen_rtx (CONST_INT, VOIDmode, len);\n+  op[0] = imm;\n+  op[1] = 31 - lsb;\n+  op[2] = len;\n }\n \n /* Output assembler code to perform a doubleword move insn\n@@ -2028,6 +2012,13 @@ print_operand (file, x, code)\n       return;\n     case 0:\t\t\t/* Don't do anything special */\n       break;\n+    case 'Z':\n+      {\n+\tunsigned op[3];\n+\tcompute_zdepi_operands (INTVAL (x), op);\n+\tfprintf (file, \"%d,%d,%d\", op[0], op[1], op[2]);\n+\treturn;\n+      }\n     default:\n       abort ();\n     }"}]}