{"sha": "012a47cb77ff762418af8c1150637235b447b42a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEyYTQ3Y2I3N2ZmNzYyNDE4YWY4YzExNTA2MzcyMzViNDQ3YjQyYQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-07-11T22:32:24Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-07-11T22:32:24Z"}, "message": "Initial revision\n\nFrom-SVN: r7723", "tree": {"sha": "e139b2a8039b9477c29bce4e008fa07139930632", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e139b2a8039b9477c29bce4e008fa07139930632"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/012a47cb77ff762418af8c1150637235b447b42a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/012a47cb77ff762418af8c1150637235b447b42a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/012a47cb77ff762418af8c1150637235b447b42a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/012a47cb77ff762418af8c1150637235b447b42a/comments", "author": null, "committer": null, "parents": [{"sha": "218d0f8a84f4f3df355a5eeaffc7bca059c672d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/218d0f8a84f4f3df355a5eeaffc7bca059c672d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/218d0f8a84f4f3df355a5eeaffc7bca059c672d6"}], "stats": {"total": 1259, "additions": 1259, "deletions": 0}, "files": [{"sha": "8157a0575b06f865afa77063f5ed2e2e0bb1ec25", "filename": "gcc/config/fp-bit.c", "status": "added", "additions": 1259, "deletions": 0, "changes": 1259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/012a47cb77ff762418af8c1150637235b447b42a/gcc%2Fconfig%2Ffp-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/012a47cb77ff762418af8c1150637235b447b42a/gcc%2Fconfig%2Ffp-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffp-bit.c?ref=012a47cb77ff762418af8c1150637235b447b42a", "patch": "@@ -0,0 +1,1259 @@\n+/* This is a software floating point library which can be used instead of\n+   the floating point routines in libgcc1.c for targets without hardware\n+   floating point.\n+\n+   This implements IEEE 754 format arithmetic, but does not provide a\n+   mechanism for setting the rounding mode, or for generating or handling\n+   exceptions.\n+\n+   The original code by Steve Chamberlain, hacked by Mark Eichin and Jim\n+   Wilson, all of Cygnus Support.\n+\n+   This file is in the public domain.  */\n+\n+/* The intended way to use this file is to make two copies, add `#define FLOAT'\n+   to one copy, then compile both copies and add them to libgcc.a.  */\n+\n+/* The following macros can be defined to change the behaviour of this file:\n+   FLOAT: Implement a `float', aka SFmode, fp library.  If this is not\n+     defined, then this file implements a `double', aka DFmode, fp library.\n+   FLOAT_ONLY: Used with FLOAT, to implement a `float' only library, i.e.\n+     don't include float->double conversion which requires the double library.\n+     This is useful only for machines which can't support doubles, e.g. some\n+     8-bit processors.\n+   CMPtype: Specify the type that floating point compares should return.\n+     This defaults to SItype, aka int.\n+   US_SOFTWARE_GOFAST: This makes all entry points use the same names as the\n+     US Software goFast library.  If this is not defined, the entry points use\n+     the same names as libgcc1.c.\n+   _DEBUG_BITFLOAT: This makes debugging the code a little easier, by adding\n+     two integers to the FLO_union_type.  \n+   NO_NANS: Disable nan and infinity handling\n+   SMALL_MACHINE: Useful when operations on QIs and HIs are faster\n+     than on an SI */\n+\n+typedef SFtype __attribute__ ((mode (SF)));\n+typedef DFtype __attribute__ ((mode (DF)));\n+\n+typedef int HItype __attribute__ ((mode (HI)));\n+typedef int SItype __attribute__ ((mode (SI)));\n+typedef int DItype __attribute__ ((mode (DI)));\n+\n+/* The type of the result of a fp compare */\n+#ifndef CMPtype\n+#define CMPtype SItype\n+#endif\n+\n+typedef unsigned int UHItype __attribute__ ((mode (HI)));\n+typedef unsigned int USItype __attribute__ ((mode (SI)));\n+typedef unsigned int UDItype __attribute__ ((mode (DI)));\n+\n+#define MAX_SI_INT   ((SItype) ((unsigned) (~0)>>1))\n+#define MAX_USI_INT  ((USItype) ~0)\n+\n+\n+#ifdef FLOAT_ONLY\n+#define NO_DI_MODE\n+#endif\n+\n+#ifdef FLOAT\n+#\tdefine NGARDS    7L\n+#\tdefine GARDROUND 0x3f\n+#\tdefine GARDMASK  0x7f\n+#\tdefine GARDMSB   0x40\n+#\tdefine EXPBITS 8\n+#\tdefine EXPBIAS 127\n+#\tdefine FRACBITS 23\n+#\tdefine EXPMAX (0xff)\n+#\tdefine QUIET_NAN 0x100000L\n+#\tdefine FRAC_NBITS 32\n+#\tdefine FRACHIGH  0x80000000L\n+#\tdefine FRACHIGH2 0xc0000000L\n+\ttypedef USItype fractype;\n+\ttypedef UHItype halffractype;\n+\ttypedef SFtype FLO_type;\n+\ttypedef SItype intfrac;\n+\n+#else\n+#\tdefine PREFIXFPDP dp\n+#\tdefine PREFIXSFDF df\n+#\tdefine NGARDS 8L\n+#\tdefine GARDROUND 0x7f\n+#\tdefine GARDMASK  0xff\n+#\tdefine GARDMSB   0x80\n+#\tdefine EXPBITS 11\n+#\tdefine EXPBIAS 1023\n+#\tdefine FRACBITS 52\n+#\tdefine EXPMAX (0x7ff)\n+#\tdefine QUIET_NAN 0x8000000000000LL\n+#\tdefine FRAC_NBITS 64\n+#\tdefine FRACHIGH  0x8000000000000000LL\n+#\tdefine FRACHIGH2 0xc000000000000000LL\n+\ttypedef UDItype fractype;\n+\ttypedef USItype halffractype;\n+\ttypedef DFtype FLO_type;\n+\ttypedef DItype intfrac;\n+#endif\n+\n+#ifdef US_SOFTWARE_GOFAST\n+#\tifdef FLOAT\n+#\t\tdefine add \t\tfpadd\n+#\t\tdefine sub \t\tfpsub\n+#\t\tdefine multiply \tfpmul\n+#\t\tdefine divide \t\tfpdiv\n+#\t\tdefine compare \t\tfpcmp\n+#\t\tdefine si_to_float \tsitofp\n+#\t\tdefine float_to_si \tfptosi\n+#\t\tdefine float_to_usi \tfptoui\n+#\t\tdefine negate \t\t__negsf2\n+#\t\tdefine sf_to_df\t\tfptodp\n+#\t\tdefine dptofp \t\tdptofp\n+#else\n+#\t\tdefine add \t\tdpadd\n+#\t\tdefine sub \t\tdpsub\n+#\t\tdefine multiply \tdpmul\n+#\t\tdefine divide \t\tdpdiv\n+#\t\tdefine compare \t\tdpcmp\n+#\t\tdefine si_to_float \tlitodp\n+#\t\tdefine float_to_si \tdptoli\n+#\t\tdefine float_to_usi \tdptoul\n+#\t\tdefine negate \t\t__negdf2\n+#\t\tdefine df_to_sf \tdptofp\n+#endif\n+#else\n+#\tifdef FLOAT\n+#\t\tdefine add \t\t__addsf3\n+#\t\tdefine sub \t\t__subsf3\n+#\t\tdefine multiply \t__mulsf3\n+#\t\tdefine divide \t\t__divsf3\n+#\t\tdefine compare \t\t__cmpsf2\n+#\t\tdefine _eq_f2 \t\t__eqsf2\n+#\t\tdefine _ne_f2 \t\t__nesf2\n+#\t\tdefine _gt_f2 \t\t__gtsf2\n+#\t\tdefine _ge_f2 \t\t__gesf2\n+#\t\tdefine _lt_f2 \t\t__ltsf2\n+#\t\tdefine _le_f2 \t\t__lesf2\n+#\t\tdefine si_to_float \t__floatsisf\n+#\t\tdefine float_to_si \t__fixsfsi\n+#\t\tdefine float_to_usi \t__fixunssfsi\n+#\t\tdefine negate \t\t__negsf2\n+#\t\tdefine sf_to_df\t\t__extendsfdf2\n+#else\n+#\t\tdefine add \t\t__adddf3\n+#\t\tdefine sub \t\t__subdf3\n+#\t\tdefine multiply \t__muldf3\n+#\t\tdefine divide \t\t__divdf3\n+#\t\tdefine compare \t\t__cmpdf2\n+#\t\tdefine _eq_f2 \t\t__eqdf2\n+#\t\tdefine _ne_f2 \t\t__nedf2\n+#\t\tdefine _gt_f2 \t\t__gtdf2\n+#\t\tdefine _ge_f2 \t\t__gedf2\n+#\t\tdefine _lt_f2 \t\t__ltdf2\n+#\t\tdefine _le_f2 \t\t__ledf2\n+#\t\tdefine si_to_float \t__floatsidf\n+#\t\tdefine float_to_si \t__fixdfsi\n+#\t\tdefine float_to_usi \t__fixunsdfsi\n+#\t\tdefine negate \t\t__negdf2\n+#\t\tdefine df_to_sf\t\t__truncdfsf2\n+#\tendif\n+#endif\n+\n+\n+#define INLINE __inline__\n+\n+/* Preserve the sticky-bit when shifting fractions to the right.  */\n+#define LSHIFT(a) { a = (a & 1) | (a >> 1); }\n+\n+/* numeric parameters */\n+/* F_D_BITOFF is the number of bits offset between the MSB of the mantissa\n+   of a float and of a double. Assumes there are only two float types.\n+   (double::FRAC_BITS+double::NGARGS-(float::FRAC_BITS-float::NGARDS))\n+ */\n+#define F_D_BITOFF (52+8-(23+7))\n+\n+\n+#define NORMAL_EXPMIN (-(EXPBIAS)+1)\n+#define IMPLICIT_1 (1LL<<(FRACBITS+NGARDS))\n+#define IMPLICIT_2 (1LL<<(FRACBITS+1+NGARDS))\n+\n+/* common types */\n+\n+typedef enum\n+{\n+  CLASS_SNAN,\n+  CLASS_QNAN,\n+  CLASS_ZERO,\n+  CLASS_NUMBER,\n+  CLASS_INFINITY\n+} fp_class_type;\n+\n+typedef struct\n+{\n+#ifdef SMALL_MACHINE\n+  char class;\n+  unsigned char sign;\n+  short normal_exp;\n+#else\n+  fp_class_type class;\n+  unsigned int sign;\n+  int normal_exp;\n+#endif\n+\n+  union\n+    {\n+      fractype ll;\n+      halffractype l[2];\n+    } fraction;\n+} fp_number_type;\n+\n+typedef\n+union\n+{\n+  FLO_type value;\n+#ifdef _DEBUG_BITFLOAT\n+  int l[2];\n+#endif\n+  struct\n+    {\n+#ifndef FLOAT_BIT_ORDER_MISMATCH\n+      unsigned int sign:1;\n+      unsigned int exp:EXPBITS;\n+      fractype fraction:FRACBITS;\n+#else\n+      fractype fraction:FRACBITS;\n+      unsigned int exp:EXPBITS;\n+      unsigned int sign:1;\n+#endif\n+    }\n+  bits;\n+}\n+\n+FLO_union_type;\n+\n+\n+/* end of header */\n+\n+/* IEEE \"special\" number predicates */\n+\n+#ifdef NO_NANS\n+\n+#define nan() 0\n+#define isnan(x) 0\n+#define isinf(x) 0\n+#else\n+\n+INLINE\n+static fp_number_type *\n+nan ()\n+{\n+  static fp_number_type thenan;\n+\n+  return &thenan;\n+}\n+\n+INLINE\n+static int\n+isnan ( fp_number_type *  x)\n+{\n+  return x->class == CLASS_SNAN || x->class == CLASS_QNAN;\n+}\n+\n+INLINE\n+static int\n+isinf ( fp_number_type *  x)\n+{\n+  return x->class == CLASS_INFINITY;\n+}\n+\n+#endif\n+\n+INLINE\n+static int\n+iszero ( fp_number_type *  x)\n+{\n+  return x->class == CLASS_ZERO;\n+}\n+\n+INLINE \n+static void\n+flip_sign ( fp_number_type *  x)\n+{\n+  x->sign = !x->sign;\n+}\n+\n+static FLO_type\n+pack_d ( fp_number_type *  src)\n+{\n+  FLO_union_type dst;\n+  fractype fraction = src->fraction.ll;\t/* wasn't unsigned before? */\n+\n+  dst.bits.sign = src->sign;\n+\n+  if (isnan (src))\n+    {\n+      dst.bits.exp = EXPMAX;\n+      dst.bits.fraction = src->fraction.ll;\n+      if (src->class == CLASS_QNAN || 1)\n+\t{\n+\t  dst.bits.fraction |= QUIET_NAN;\n+\t}\n+    }\n+  else if (isinf (src))\n+    {\n+      dst.bits.exp = EXPMAX;\n+      dst.bits.fraction = 0;\n+    }\n+  else if (iszero (src))\n+    {\n+      dst.bits.exp = 0;\n+      dst.bits.fraction = 0;\n+    }\n+  else if (fraction == 0)\n+    {\n+      dst.value = 0;\n+    }\n+  else\n+    {\n+      if (src->normal_exp < NORMAL_EXPMIN)\n+\t{\n+\t  /* This number's exponent is too low to fit into the bits\n+\t     available in the number, so we'll store 0 in the exponent and\n+\t     shift the fraction to the right to make up for it.  */\n+\n+\t  int shift = NORMAL_EXPMIN - src->normal_exp;\n+\n+\t  dst.bits.exp = 0;\n+\n+\t  if (shift > FRAC_NBITS - NGARDS)\n+\t    {\n+\t      /* No point shifting, since it's more that 64 out.  */\n+\t      fraction = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Shift by the value */\n+\t      fraction >>= shift;\n+\t    }\n+\t  fraction >>= NGARDS;\n+\t  dst.bits.fraction = fraction;\n+\t}\n+      else if (src->normal_exp > EXPBIAS)\n+\t{\n+\t  dst.bits.exp = EXPMAX;\n+\t  dst.bits.fraction = 0;\n+\t}\n+      else\n+\t{\n+\t  dst.bits.exp = src->normal_exp + EXPBIAS;\n+\t  /* IF the gard bits are the all zero, but the first, then we're\n+\t     half way between two numbers, choose the one which makes the\n+\t     lsb of the answer 0.  */\n+\t  if ((fraction & GARDMASK) == GARDMSB)\n+\t    {\n+\t      if (fraction & (1 << NGARDS))\n+\t\tfraction += GARDROUND + 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Add a one to the guards to round up */\n+\t      fraction += GARDROUND;\n+\t    }\n+\t  if (fraction >= IMPLICIT_2)\n+\t    {\n+\t      fraction >>= 1;\n+\t      dst.bits.exp += 1;\n+\t    }\n+\t  fraction >>= NGARDS;\n+\t  dst.bits.fraction = fraction;\n+\t}\n+    }\n+  return dst.value;\n+}\n+\n+static void\n+unpack_d (FLO_union_type * src, fp_number_type * dst)\n+{\n+  fractype fraction = src->bits.fraction;\n+\n+  dst->sign = src->bits.sign;\n+  if (src->bits.exp == 0)\n+    {\n+      /* Hmm.  Looks like 0 */\n+      if (fraction == 0)\n+\t{\n+\t  /* tastes like zero */\n+\t  dst->class = CLASS_ZERO;\n+\t}\n+      else\n+\t{\n+\t  /* Zero exponent with non zero fraction - it's denormalized,\n+\t     so there isn't a leading implicit one - we'll shift it so\n+\t     it gets one.  */\n+\t  dst->normal_exp = src->bits.exp - EXPBIAS + 1;\n+\t  fraction <<= NGARDS;\n+\n+\t  dst->class = CLASS_NUMBER;\n+#if 1\n+\t  while (fraction < IMPLICIT_1)\n+\t    {\n+\t      fraction <<= 1;\n+\t      dst->normal_exp--;\n+\t    }\n+#endif\n+\t  dst->fraction.ll = fraction;\n+\t}\n+    }\n+  else if (src->bits.exp == EXPMAX)\n+    {\n+      /* Huge exponent*/\n+      if (fraction == 0)\n+\t{\n+\t  /* Attatched to a zero fraction - means infinity */\n+\t  dst->class = CLASS_INFINITY;\n+\t}\n+      else\n+\t{\n+\t  /* Non zero fraction, means nan */\n+\t  if (dst->sign)\n+\t    {\n+\t      dst->class = CLASS_SNAN;\n+\t    }\n+\t  else\n+\t    {\n+\t      dst->class = CLASS_QNAN;\n+\t    }\n+\t  /* Keep the fraction part as the nan number */\n+\t  dst->fraction.ll = fraction;\n+\t}\n+    }\n+  else\n+    {\n+      /* Nothing strange about this number */\n+      dst->normal_exp = src->bits.exp - EXPBIAS;\n+      dst->class = CLASS_NUMBER;\n+      dst->fraction.ll = (fraction << NGARDS) | IMPLICIT_1;\n+    }\n+}\n+\n+static fp_number_type *\n+_fpadd_parts (fp_number_type * a,\n+\t      fp_number_type * b,\n+\t      fp_number_type * tmp)\n+{\n+  intfrac tfraction;\n+\n+  /* Put commonly used fields in local variables.  */\n+  int a_normal_exp;\n+  int b_normal_exp;\n+  fractype a_fraction;\n+  fractype b_fraction;\n+\n+  if (isnan (a))\n+    {\n+      return a;\n+    }\n+  if (isnan (b))\n+    {\n+      return b;\n+    }\n+  if (isinf (a))\n+    {\n+      return a;\n+    }\n+  if (isinf (b))\n+    {\n+      return b;\n+    }\n+  if (iszero (b))\n+    {\n+      return a;\n+    }\n+  if (iszero (a))\n+    {\n+      return b;\n+    }\n+\n+  /* Got two numbers. shift the smaller and increment the exponent till\n+     they're the same */\n+  {\n+    int diff;\n+\n+    a_normal_exp = a->normal_exp;\n+    b_normal_exp = b->normal_exp;\n+    a_fraction = a->fraction.ll;\n+    b_fraction = b->fraction.ll;\n+\n+    diff = a_normal_exp - b_normal_exp;\n+\n+    if (diff < 0)\n+      diff = -diff;\n+    if (diff < FRAC_NBITS)\n+      {\n+\t/* ??? This does shifts one bit at a time.  Optimize.  */\n+\twhile (a_normal_exp > b_normal_exp)\n+\t  {\n+\t    b_normal_exp++;\n+\t    LSHIFT (b_fraction);\n+\t  }\n+\twhile (b_normal_exp > a_normal_exp)\n+\t  {\n+\t    a_normal_exp++;\n+\t    LSHIFT (a_fraction);\n+\t  }\n+      }\n+    else\n+      {\n+\t/* Somethings's up.. choose the biggest */\n+\tif (a_normal_exp > b_normal_exp)\n+\t  {\n+\t    b_normal_exp = a_normal_exp;\n+\t    b_fraction = 0;\n+\t  }\n+\telse\n+\t  {\n+\t    a_normal_exp = b_normal_exp;\n+\t    a_fraction = 0;\n+\t  }\n+      }\n+  }\n+\n+  if (a->sign != b->sign)\n+    {\n+      if (a->sign)\n+\t{\n+\t  tfraction = -a_fraction + b_fraction;\n+\t}\n+      else\n+\t{\n+\t  tfraction = a_fraction - b_fraction;\n+\t}\n+      if (tfraction > 0)\n+\t{\n+\t  tmp->sign = 0;\n+\t  tmp->normal_exp = a_normal_exp;\n+\t  tmp->fraction.ll = tfraction;\n+\t}\n+      else\n+\t{\n+\t  tmp->sign = 1;\n+\t  tmp->normal_exp = a_normal_exp;\n+\t  tmp->fraction.ll = -tfraction;\n+\t}\n+      /* and renomalize it */\n+\n+      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)\n+\t{\n+\t  tmp->fraction.ll <<= 1;\n+\t  tmp->normal_exp--;\n+\t}\n+    }\n+  else\n+    {\n+      tmp->sign = a->sign;\n+      tmp->normal_exp = a_normal_exp;\n+      tmp->fraction.ll = a_fraction + b_fraction;\n+    }\n+  tmp->class = CLASS_NUMBER;\n+  /* Now the fraction is added, we have to shift down to renormalize the\n+     number */\n+\n+  if (tmp->fraction.ll >= IMPLICIT_2)\n+    {\n+      LSHIFT (tmp->fraction.ll);\n+      tmp->normal_exp++;\n+    }\n+  return tmp;\n+\n+}\n+\n+FLO_type\n+add (FLO_type arg_a, FLO_type arg_b)\n+{\n+  fp_number_type a;\n+  fp_number_type b;\n+  fp_number_type tmp;\n+  fp_number_type *res;\n+\n+  unpack_d ((FLO_union_type *) & arg_a, &a);\n+  unpack_d ((FLO_union_type *) & arg_b, &b);\n+\n+  res = _fpadd_parts (&a, &b, &tmp);\n+\n+  return pack_d (res);\n+}\n+\n+FLO_type\n+sub (FLO_type arg_a, FLO_type arg_b)\n+{\n+  fp_number_type a;\n+  fp_number_type b;\n+  fp_number_type tmp;\n+  fp_number_type *res;\n+\n+  unpack_d ((FLO_union_type *) & arg_a, &a);\n+  unpack_d ((FLO_union_type *) & arg_b, &b);\n+\n+  b.sign ^= 1;\n+\n+  res = _fpadd_parts (&a, &b, &tmp);\n+\n+  return pack_d (res);\n+}\n+\n+static fp_number_type *\n+_fpmul_parts ( fp_number_type *  a,\n+\t       fp_number_type *  b,\n+\t       fp_number_type * tmp)\n+{\n+  fractype low = 0;\n+  fractype high = 0;\n+\n+  if (isnan (a))\n+    {\n+      a->sign = a->sign != b->sign;\n+      return a;\n+    }\n+  if (isnan (b))\n+    {\n+      b->sign = a->sign != b->sign;\n+      return b;\n+    }\n+  if (isinf (a))\n+    {\n+      if (iszero (b))\n+\treturn nan ();\n+      a->sign = a->sign != b->sign;\n+      return a;\n+    }\n+  if (isinf (b))\n+    {\n+      if (iszero (a))\n+\t{\n+\t  return nan ();\n+\t}\n+      b->sign = a->sign != b->sign;\n+      return b;\n+    }\n+  if (iszero (a))\n+    {\n+      a->sign = a->sign != b->sign;\n+      return a;\n+    }\n+  if (iszero (b))\n+    {\n+      b->sign = a->sign != b->sign;\n+      return b;\n+    }\n+\n+  /* Calculate the mantissa by multiplying both 64bit numbers to get a\n+     128 bit number */\n+  {\n+    fractype x = a->fraction.ll;\n+    fractype ylow = b->fraction.ll;\n+    fractype yhigh = 0;\n+    int bit;\n+\n+#if defined(NO_DI_MODE)\n+    {\n+      /* ??? This does multiplies one bit at a time.  Optimize.  */\n+      for (bit = 0; bit < FRAC_NBITS; bit++)\n+\t{\n+\t  int carry;\n+\n+\t  if (x & 1)\n+\t    {\n+\t      carry = (low += ylow) < ylow;\n+\t      high += yhigh + carry;\n+\t    }\n+\t  yhigh <<= 1;\n+\t  if (ylow & FRACHIGH)\n+\t    {\n+\t      yhigh |= 1;\n+\t    }\n+\t  ylow <<= 1;\n+\t  x >>= 1;\n+\t}\n+    }\n+#elif defined(FLOAT) \n+    {\n+      /* Multiplying two 32 bit numbers to get a 64 bit number  on \n+        a machine with DI, so we're safe */\n+\n+      DItype answer = (DItype)(a->fraction.ll) * (DItype)(b->fraction.ll);\n+      \n+      high = answer >> 32;\n+      low = answer;\n+    }\n+#else\n+    /* Doing a 64*64 to 128 */\n+    {\n+      UDItype nl = a->fraction.ll;\n+      UDItype nh = a->fraction.ll >> 32;\n+      UDItype ml = b->fraction.ll;\n+      UDItype mh = b->fraction.ll >>32;\n+      UDItype pp_ll = ml * nl;\n+      UDItype pp_hl = mh * nl;\n+      UDItype pp_lh = ml * nh;\n+      UDItype pp_hh = mh * nh;\n+      UDItype res2 = 0;\n+      UDItype res0 = 0;\n+      UDItype ps_hh__ = pp_hl + pp_lh;\n+      if (ps_hh__ < pp_hl)\n+\tres2 += 0x100000000LL;\n+      pp_hl = (ps_hh__ << 32) & 0xffffffff00000000LL;\n+      res0 = pp_ll + pp_hl;\n+      if (res0 < pp_ll)\n+\tres2++;\n+      res2 += ((ps_hh__ >> 32) & 0xffffffffL) + pp_hh;\n+      high = res2;\n+      low = res0;\n+    }\n+#endif\n+  }\n+\n+  tmp->normal_exp = a->normal_exp + b->normal_exp;\n+  tmp->sign = a->sign != b->sign;\n+#ifdef FLOAT\n+  tmp->normal_exp += 2;\t\t/* ??????????????? */\n+#else\n+  tmp->normal_exp += 4;\t\t/* ??????????????? */\n+#endif\n+  while (high >= IMPLICIT_2)\n+    {\n+      tmp->normal_exp++;\n+      if (high & 1)\n+\t{\n+\t  low >>= 1;\n+\t  low |= FRACHIGH;\n+\t}\n+      high >>= 1;\n+    }\n+  while (high < IMPLICIT_1)\n+    {\n+      tmp->normal_exp--;\n+\n+      high <<= 1;\n+      if (low & FRACHIGH)\n+\thigh |= 1;\n+      low <<= 1;\n+    }\n+  /* rounding is tricky. if we only round if it won't make us round later. */\n+#if 0\n+  if (low & FRACHIGH2)\n+    {\n+      if (((high & GARDMASK) != GARDMSB)\n+\t  && (((high + 1) & GARDMASK) == GARDMSB))\n+\t{\n+\t  /* don't round, it gets done again later. */\n+\t}\n+      else\n+\t{\n+\t  high++;\n+\t}\n+    }\n+#endif\n+  if ((high & GARDMASK) == GARDMSB)\n+    {\n+      if (high & (1 << NGARDS))\n+\t{\n+\t  /* half way, so round to even */\n+\t  high += GARDROUND + 1;\n+\t}\n+      else if (low)\n+\t{\n+\t  /* but we really weren't half way */\n+\t  high += GARDROUND + 1;\n+\t}\n+    }\n+  tmp->fraction.ll = high;\n+  tmp->class = CLASS_NUMBER;\n+  return tmp;\n+}\n+\n+FLO_type\n+multiply (FLO_type arg_a, FLO_type arg_b)\n+{\n+  fp_number_type a;\n+  fp_number_type b;\n+  fp_number_type tmp;\n+  fp_number_type *res;\n+\n+  unpack_d ((FLO_union_type *) & arg_a, &a);\n+  unpack_d ((FLO_union_type *) & arg_b, &b);\n+\n+  res = _fpmul_parts (&a, &b, &tmp);\n+\n+  return pack_d (res);\n+}\n+\n+static fp_number_type *\n+_fpdiv_parts (fp_number_type * a,\n+\t      fp_number_type * b,\n+\t      fp_number_type * tmp)\n+{\n+  fractype low = 0;\n+  fractype high = 0;\n+  fractype r0, r1, y0, y1, bit;\n+  fractype q;\n+  fractype numerator;\n+  fractype denominator;\n+  fractype quotient;\n+  fractype remainder;\n+\n+  if (isnan (a))\n+    {\n+      return a;\n+    }\n+  if (isnan (b))\n+    {\n+      return b;\n+    }\n+  if (isinf (a) || iszero (a))\n+    {\n+      if (a->class == b->class)\n+\treturn nan ();\n+      return a;\n+    }\n+  a->sign = a->sign ^ b->sign;\n+\n+  if (isinf (b))\n+    {\n+      a->fraction.ll = 0;\n+      a->normal_exp = 0;\n+      return a;\n+    }\n+  if (iszero (b))\n+    {\n+      a->class = CLASS_INFINITY;\n+      return b;\n+    }\n+\n+  /* Calculate the mantissa by multiplying both 64bit numbers to get a\n+     128 bit number */\n+  {\n+    int carry;\n+    intfrac d0, d1;\t\t/* weren't unsigned before ??? */\n+\n+    /* quotient =\n+       ( numerator / denominator) * 2^(numerator exponent -  denominator exponent)\n+     */\n+\n+    a->normal_exp = a->normal_exp - b->normal_exp;\n+    numerator = a->fraction.ll;\n+    denominator = b->fraction.ll;\n+\n+    if (numerator < denominator)\n+      {\n+\t/* Fraction will be less than 1.0 */\n+\tnumerator *= 2;\n+\ta->normal_exp--;\n+      }\n+    bit = IMPLICIT_1;\n+    quotient = 0;\n+    /* ??? Does divide one bit at a time.  Optimize.  */\n+    while (bit)\n+      {\n+\tif (numerator >= denominator)\n+\t  {\n+\t    quotient |= bit;\n+\t    numerator -= denominator;\n+\t  }\n+\tbit >>= 1;\n+\tnumerator *= 2;\n+      }\n+\n+    if ((quotient & GARDMASK) == GARDMSB)\n+      {\n+\tif (quotient & (1 << NGARDS))\n+\t  {\n+\t    /* half way, so round to even */\n+\t    quotient += GARDROUND + 1;\n+\t  }\n+\telse if (numerator)\n+\t  {\n+\t    /* but we really weren't half way, more bits exist */\n+\t    quotient += GARDROUND + 1;\n+\t  }\n+      }\n+\n+    a->fraction.ll = quotient;\n+    return (a);\n+  }\n+}\n+\n+FLO_type\n+divide (FLO_type arg_a, FLO_type arg_b)\n+{\n+  fp_number_type a;\n+  fp_number_type b;\n+  fp_number_type tmp;\n+  fp_number_type *res;\n+\n+  unpack_d ((FLO_union_type *) & arg_a, &a);\n+  unpack_d ((FLO_union_type *) & arg_b, &b);\n+\n+  res = _fpdiv_parts (&a, &b, &tmp);\n+\n+  return pack_d (res);\n+}\n+\n+/* according to the demo, fpcmp returns a comparison with 0... thus\n+   a<b -> -1\n+   a==b -> 0\n+   a>b -> +1\n+ */\n+\n+static int\n+_fpcmp_parts (fp_number_type * a, fp_number_type * b)\n+{\n+#if 0\n+  /* either nan -> unordered. Must be checked outside of this routine. */\n+  if (isnan (a) && isnan (b))\n+    {\n+      return 1;\t\t\t/* still unordered! */\n+    }\n+#endif\n+\n+  if (isnan (a) || isnan (b))\n+    {\n+      return 1;\t\t\t/* how to indicate unordered compare? */\n+    }\n+  if (isinf (a) && isinf (b))\n+    {\n+      /* +inf > -inf, but +inf != +inf */\n+      /* b    \\a| +inf(0)| -inf(1)\n+       ______\\+--------+--------\n+       +inf(0)| a==b(0)| a<b(-1)\n+       -------+--------+--------\n+       -inf(1)| a>b(1) | a==b(0)\n+       -------+--------+--------\n+       So since unordered must be non zero, just line up the columns...\n+       */\n+      return b->sign - a->sign;\n+    }\n+  /* but not both... */\n+  if (isinf (a))\n+    {\n+      return a->sign ? -1 : 1;\n+    }\n+  if (isinf (b))\n+    {\n+      return b->sign ? 1 : -1;\n+    }\n+  if (iszero (a) && iszero (b))\n+    {\n+      return 0;\n+    }\n+  if (iszero (a))\n+    {\n+      return b->sign ? 1 : -1;\n+    }\n+  if (iszero (b))\n+    {\n+      return a->sign ? -1 : 1;\n+    }\n+  /* now both are \"normal\". */\n+  if (a->sign != b->sign)\n+    {\n+      /* opposite signs */\n+      return a->sign ? -1 : 1;\n+    }\n+  /* same sign; exponents? */\n+  if (a->normal_exp > b->normal_exp)\n+    {\n+      return a->sign ? -1 : 1;\n+    }\n+  if (a->normal_exp < b->normal_exp)\n+    {\n+      return a->sign ? 1 : -1;\n+    }\n+  /* same exponents; check size. */\n+  if (a->fraction.ll > b->fraction.ll)\n+    {\n+      return a->sign ? -1 : 1;\n+    }\n+  if (a->fraction.ll < b->fraction.ll)\n+    {\n+      return a->sign ? 1 : -1;\n+    }\n+  /* after all that, they're equal. */\n+  return 0;\n+}\n+\n+CMPtype\n+compare (FLO_type arg_a, FLO_type arg_b)\n+{\n+  fp_number_type a;\n+  fp_number_type b;\n+\n+  unpack_d ((FLO_union_type *) & arg_a, &a);\n+  unpack_d ((FLO_union_type *) & arg_b, &b);\n+\n+  return _fpcmp_parts (&a, &b);\n+}\n+\n+#ifndef US_SOFTWARE_GOFAST\n+\n+/* These should be optimized for their specific tasks someday.  */\n+\n+CMPtype\n+_eq_f2 (FLO_type arg_a, FLO_type arg_b)\n+{\n+  fp_number_type a;\n+  fp_number_type b;\n+\n+  unpack_d ((FLO_union_type *) & arg_a, &a);\n+  unpack_d ((FLO_union_type *) & arg_b, &b);\n+\n+  if (isnan (&a) || isnan (&b))\n+    return 1;\t\t\t/* false, truth == 0 */\n+\n+  return _fpcmp_parts (&a, &b) ;\n+}\n+\n+CMPtype\n+_ne_f2 (FLO_type arg_a, FLO_type arg_b)\n+{\n+  fp_number_type a;\n+  fp_number_type b;\n+\n+  unpack_d ((FLO_union_type *) & arg_a, &a);\n+  unpack_d ((FLO_union_type *) & arg_b, &b);\n+\n+  if (isnan (&a) || isnan (&b))\n+    return 1;\t\t\t/* true, truth != 0 */\n+\n+  return  _fpcmp_parts (&a, &b) ;\n+}\n+\n+CMPtype\n+_gt_f2 (FLO_type arg_a, FLO_type arg_b)\n+{\n+  fp_number_type a;\n+  fp_number_type b;\n+\n+  unpack_d ((FLO_union_type *) & arg_a, &a);\n+  unpack_d ((FLO_union_type *) & arg_b, &b);\n+\n+  if (isnan (&a) || isnan (&b))\n+    return -1;\t\t\t/* false, truth > 0 */\n+\n+  return _fpcmp_parts (&a, &b);\n+}\n+\n+CMPtype\n+_ge_f2 (FLO_type arg_a, FLO_type arg_b)\n+{\n+  fp_number_type a;\n+  fp_number_type b;\n+\n+  unpack_d ((FLO_union_type *) & arg_a, &a);\n+  unpack_d ((FLO_union_type *) & arg_b, &b);\n+\n+  if (isnan (&a) || isnan (&b))\n+    return -1;\t\t\t/* false, truth >= 0 */\n+  return _fpcmp_parts (&a, &b) ;\n+}\n+\n+CMPtype\n+_lt_f2 (FLO_type arg_a, FLO_type arg_b)\n+{\n+  fp_number_type a;\n+  fp_number_type b;\n+\n+  unpack_d ((FLO_union_type *) & arg_a, &a);\n+  unpack_d ((FLO_union_type *) & arg_b, &b);\n+\n+  if (isnan (&a) || isnan (&b))\n+    return 1;\t\t\t/* false, truth < 0 */\n+\n+  return _fpcmp_parts (&a, &b);\n+}\n+\n+CMPtype\n+_le_f2 (FLO_type arg_a, FLO_type arg_b)\n+{\n+  fp_number_type a;\n+  fp_number_type b;\n+\n+  unpack_d ((FLO_union_type *) & arg_a, &a);\n+  unpack_d ((FLO_union_type *) & arg_b, &b);\n+\n+  if (isnan (&a) || isnan (&b))\n+    return 1;\t\t\t/* false, truth <= 0 */\n+\n+  return _fpcmp_parts (&a, &b) ;\n+}\n+\n+#endif /* ! US_SOFTWARE_GOFAST */\n+\n+FLO_type\n+si_to_float (SItype arg_a)\n+{\n+  fp_number_type in;\n+\n+  in.class = CLASS_NUMBER;\n+  in.sign = arg_a < 0;\n+  if (!arg_a)\n+    {\n+      in.class = CLASS_ZERO;\n+    }\n+  else\n+    {\n+      in.normal_exp = FRACBITS + NGARDS;\n+      if (in.sign) \n+\t{\n+\t  /* Special case for minint, since there is no +ve integer\n+\t     representation for it */\n+\t  if (arg_a == 0x80000000)\n+\t    {\n+\t      return -2147483648.0;\n+\t    }\n+\t  in.fraction.ll = (-arg_a);\n+\t}\n+      else\n+\tin.fraction.ll = arg_a;\n+\n+      while (in.fraction.ll < (1LL << (FRACBITS + NGARDS)))\n+\t{\n+\t  in.fraction.ll <<= 1;\n+\t  in.normal_exp -= 1;\n+\t}\n+    }\n+  return pack_d (&in);\n+}\n+\n+SItype\n+float_to_si (FLO_type arg_a)\n+{\n+  fp_number_type a;\n+  SItype tmp;\n+\n+  unpack_d ((FLO_union_type *) & arg_a, &a);\n+  if (iszero (&a))\n+    return 0;\n+  if (isnan (&a))\n+    return 0;\n+  /* get reasonable MAX_SI_INT... */\n+  if (isinf (&a))\n+    return a.sign ? MAX_SI_INT : (-MAX_SI_INT)-1;\n+  /* it is a number, but a small one */\n+  if (a.normal_exp < 0)\n+    return 0;\n+  if (a.normal_exp > 30)\n+    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;\n+  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);\n+  return a.sign ? (-tmp) : (tmp);\n+}\n+\n+#ifdef US_SOFTWARE_GOFAST\n+/* While libgcc2.c defines its own __fixunssfsi and __fixunsdfsi routines,\n+   we also define them for GOFAST because the ones in libgcc2.c have the\n+   wrong names and I'd rather define these here and keep GOFAST CYG-LOC's\n+   out of libgcc2.c.  We can't define these here if not GOFAST because then\n+   there'd be duplicate copies.  */\n+\n+USItype\n+float_to_usi (FLO_type arg_a)\n+{\n+  fp_number_type a;\n+\n+  unpack_d ((FLO_union_type *) & arg_a, &a);\n+  if (iszero (&a))\n+    return 0;\n+  if (isnan (&a))\n+    return 0;\n+  /* get reasonable MAX_USI_INT... */\n+  if (isinf (&a))\n+    return a.sign ? MAX_USI_INT : 0;\n+  /* it is a negative number */\n+  if (a.sign)\n+    return 0;\n+  /* it is a number, but a small one */\n+  if (a.normal_exp < 0)\n+    return 0;\n+  if (a.normal_exp > 31)\n+    return MAX_USI_INT;\n+  else if (a.normal_exp > (FRACBITS + NGARDS))\n+    return a.fraction.ll << ((FRACBITS + NGARDS) - a.normal_exp);\n+  else\n+    return a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);\n+}\n+#endif\n+\n+FLO_type\n+negate (FLO_type arg_a)\n+{\n+  fp_number_type a;\n+\n+  unpack_d ((FLO_union_type *) & arg_a, &a);\n+  flip_sign (&a);\n+  return pack_d (&a);\n+}\n+\n+#ifdef FLOAT\n+\n+SFtype\n+__make_fp(fp_class_type class,\n+\t     unsigned int sign,\n+\t     int exp, \n+\t     USItype frac)\n+{\n+  fp_number_type in;\n+\n+  in.class = class;\n+  in.sign = sign;\n+  in.normal_exp = exp;\n+  in.fraction.ll = frac;\n+  return pack_d (&in);\n+}\n+\n+#ifndef FLOAT_ONLY\n+\n+/* This enables one to build an fp library that supports float but not double.\n+   Otherwise, we would get an undefined reference to __make_dp.\n+   This is needed for some 8-bit ports that can't handle well values that\n+   are 8-bytes in size, so we just don't support double for them at all.  */\n+\n+extern DFtype __make_dp (fp_class_type, unsigned int, int, UDItype frac);\n+\n+DFtype\n+sf_to_df (SFtype arg_a)\n+{\n+  fp_number_type in;\n+\n+  unpack_d ((FLO_union_type *) & arg_a, &in);\n+  return __make_dp (in.class, in.sign, in.normal_exp,\n+\t\t    ((UDItype) in.fraction.ll) << F_D_BITOFF);\n+}\n+\n+#endif\n+#endif\n+\n+#ifndef FLOAT\n+\n+extern SFtype __make_fp (fp_class_type, unsigned int, int, USItype);\n+\n+DFtype\n+__make_dp (fp_class_type class, unsigned int sign, int exp, UDItype frac)\n+{\n+  fp_number_type in;\n+\n+  in.class = class;\n+  in.sign = sign;\n+  in.normal_exp = exp;\n+  in.fraction.ll = frac;\n+  return pack_d (&in);\n+}\n+\n+SFtype\n+df_to_sf (DFtype arg_a)\n+{\n+  fp_number_type in;\n+\n+  unpack_d ((FLO_union_type *) & arg_a, &in);\n+  return __make_fp (in.class, in.sign, in.normal_exp,\n+\t\t    in.fraction.ll >> F_D_BITOFF);\n+}\n+\n+#endif"}]}