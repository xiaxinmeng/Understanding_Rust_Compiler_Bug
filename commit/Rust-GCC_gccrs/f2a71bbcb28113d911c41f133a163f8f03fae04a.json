{"sha": "f2a71bbcb28113d911c41f133a163f8f03fae04a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJhNzFiYmNiMjgxMTNkOTExYzQxZjEzM2ExNjNmOGYwM2ZhZTA0YQ==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2005-06-29T22:13:56Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2005-06-29T22:13:56Z"}, "message": "c-tree.h (default_function_array_conversion): Take and return struct c_expr.\n\n\t* c-tree.h (default_function_array_conversion): Take and return\n\tstruct c_expr.\n\t* c-typeck.c (default_function_array_conversion): Split into\n\tarray_to_pointer_conversion and function_to_pointer_conversion.\n\tTake and return struct c_expr.\n\t(array_to_pointer_conversion): Do not handle type qualifiers or\n\tCOMPOUND_EXPRs specially.\n\t(build_function_call): Call function_to_pointer_conversion for\n\tfunction designators.\n\t(build_unary_op): Call array_to_pointer_conversion, not\n\tdefault_function_array_conversion.\n\t(digest_init, output_init_element): Likewise.\n\t* c-parser.c: All callers of default_function_array_conversion\n\tchanged.\n\nFrom-SVN: r101440", "tree": {"sha": "c48b91e3a25e2d526fe68f6ba85cfffb181ca5c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c48b91e3a25e2d526fe68f6ba85cfffb181ca5c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2a71bbcb28113d911c41f133a163f8f03fae04a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2a71bbcb28113d911c41f133a163f8f03fae04a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2a71bbcb28113d911c41f133a163f8f03fae04a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2a71bbcb28113d911c41f133a163f8f03fae04a/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a81408c939f8b804f6b16e49b738dbc0c3d15a01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a81408c939f8b804f6b16e49b738dbc0c3d15a01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a81408c939f8b804f6b16e49b738dbc0c3d15a01"}], "stats": {"total": 305, "additions": 171, "deletions": 134}, "files": [{"sha": "91e2631840e8bdee66c9db406d58fd8a12e501ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2a71bbcb28113d911c41f133a163f8f03fae04a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2a71bbcb28113d911c41f133a163f8f03fae04a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f2a71bbcb28113d911c41f133a163f8f03fae04a", "patch": "@@ -1,3 +1,20 @@\n+2005-06-29  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* c-tree.h (default_function_array_conversion): Take and return\n+\tstruct c_expr.\n+\t* c-typeck.c (default_function_array_conversion): Split into\n+\tarray_to_pointer_conversion and function_to_pointer_conversion.\n+\tTake and return struct c_expr.\n+\t(array_to_pointer_conversion): Do not handle type qualifiers or\n+\tCOMPOUND_EXPRs specially.\n+\t(build_function_call): Call function_to_pointer_conversion for\n+\tfunction designators.\n+\t(build_unary_op): Call array_to_pointer_conversion, not\n+\tdefault_function_array_conversion.\n+\t(digest_init, output_init_element): Likewise.\n+\t* c-parser.c: All callers of default_function_array_conversion\n+\tchanged.\n+\n 2005-06-29  Ziemowit Laski  <zlaski@apple.com>\n \n \t* config/darwin.c (machopic_select_section): constant ObjC string"}, {"sha": "9a6799435e105e80931fd40f48a5af4cafc1c3bc", "filename": "gcc/c-parser.c", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2a71bbcb28113d911c41f133a163f8f03fae04a/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2a71bbcb28113d911c41f133a163f8f03fae04a/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=f2a71bbcb28113d911c41f133a163f8f03fae04a", "patch": "@@ -2880,7 +2880,7 @@ c_parser_initializer (c_parser *parser)\n       ret = c_parser_expr_no_commas (parser, NULL);\n       if (TREE_CODE (ret.value) != STRING_CST\n \t  && TREE_CODE (ret.value) != COMPOUND_LITERAL_EXPR)\n-\tret.value = default_function_array_conversion (ret.value);\n+\tret = default_function_array_conversion (ret);\n       return ret;\n     }\n }\n@@ -3036,11 +3036,11 @@ c_parser_initelt (c_parser *parser)\n \t\t  rec = first;\n \t\t  while (c_parser_next_token_is (parser, CPP_COMMA))\n \t\t    {\n-\t\t      tree next;\n+\t\t      struct c_expr next;\n \t\t      c_parser_consume_token (parser);\n-\t\t      next = c_parser_expr_no_commas (parser, NULL).value;\n+\t\t      next = c_parser_expr_no_commas (parser, NULL);\n \t\t      next = default_function_array_conversion (next);\n-\t\t      rec = build_compound_expr (rec, next);\n+\t\t      rec = build_compound_expr (rec, next.value);\n \t\t    }\n \t\tparse_message_args:\n \t\t  /* Now parse the objc-message-args.  */\n@@ -3130,7 +3130,7 @@ c_parser_initval (c_parser *parser, struct c_expr *after)\n       if (init.value != NULL_TREE\n \t  && TREE_CODE (init.value) != STRING_CST\n \t  && TREE_CODE (init.value) != COMPOUND_LITERAL_EXPR)\n-\tinit.value = default_function_array_conversion (init.value);\n+\tinit = default_function_array_conversion (init);\n     }\n   process_init_element (init);\n }\n@@ -3990,7 +3990,8 @@ c_parser_asm_operands (c_parser *parser, bool convert_p)\n   tree list = NULL_TREE;\n   while (true)\n     {\n-      tree name, str, expr;\n+      tree name, str;\n+      struct c_expr expr;\n       if (c_parser_next_token_is (parser, CPP_OPEN_SQUARE))\n \t{\n \t  c_parser_consume_token (parser);\n@@ -4021,7 +4022,7 @@ c_parser_asm_operands (c_parser *parser, bool convert_p)\n \t  c_lex_string_translate = 0;\n \t  return NULL_TREE;\n \t}\n-      expr = c_parser_expression (parser).value;\n+      expr = c_parser_expression (parser);\n       if (convert_p)\n \texpr = default_function_array_conversion (expr);\n       c_lex_string_translate = 0;\n@@ -4031,7 +4032,7 @@ c_parser_asm_operands (c_parser *parser, bool convert_p)\n \t  return NULL_TREE;\n \t}\n       list = chainon (list, build_tree_list (build_tree_list (name, str),\n-\t\t\t\t\t     expr));\n+\t\t\t\t\t     expr.value));\n       if (c_parser_next_token_is (parser, CPP_COMMA))\n \tc_parser_consume_token (parser);\n       else\n@@ -4129,7 +4130,7 @@ c_parser_expr_no_commas (c_parser *parser, struct c_expr *after)\n     }\n   c_parser_consume_token (parser);\n   rhs = c_parser_expr_no_commas (parser, NULL);\n-  rhs.value = default_function_array_conversion (rhs.value);\n+  rhs = default_function_array_conversion (rhs);\n   ret.value = build_modify_expr (lhs.value, code, rhs.value);\n   if (code == NOP_EXPR)\n     ret.original_code = MODIFY_EXPR;\n@@ -4163,7 +4164,7 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n   cond = c_parser_binary_expression (parser, after);\n   if (c_parser_next_token_is_not (parser, CPP_QUERY))\n     return cond;\n-  cond.value = default_function_array_conversion (cond.value);\n+  cond = default_function_array_conversion (cond);\n   c_parser_consume_token (parser);\n   if (c_parser_next_token_is (parser, CPP_COLON))\n     {\n@@ -4192,7 +4193,7 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n       return ret;\n     }\n   exp2 = c_parser_conditional_expression (parser, NULL);\n-  exp2.value = default_function_array_conversion (exp2.value);\n+  exp2 = default_function_array_conversion (exp2);\n   skip_evaluation -= cond.value == truthvalue_true_node;\n   ret.value = build_conditional_expr (cond.value, exp1.value, exp2.value);\n   ret.original_code = ERROR_MARK;\n@@ -4316,10 +4317,10 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after)\n       default:\t\t\t\t\t\t\t\t      \\\n \tbreak;\t\t\t\t\t\t\t\t      \\\n       }\t\t\t\t\t\t\t\t\t      \\\n-    stack[sp - 1].expr.value\t\t\t\t\t\t      \\\n-      = default_function_array_conversion (stack[sp - 1].expr.value);\t      \\\n-    stack[sp].expr.value\t\t\t\t\t\t      \\\n-      = default_function_array_conversion (stack[sp].expr.value);\t      \\\n+    stack[sp - 1].expr\t\t\t\t\t\t\t      \\\n+      = default_function_array_conversion (stack[sp - 1].expr);\t\t      \\\n+    stack[sp].expr\t\t\t\t\t\t\t      \\\n+      = default_function_array_conversion (stack[sp].expr);\t\t      \\\n     stack[sp - 1].expr = parser_build_binary_op (stack[sp].op,\t\t      \\\n \t\t\t\t\t\t stack[sp - 1].expr,\t      \\\n \t\t\t\t\t\t stack[sp].expr);\t      \\\n@@ -4420,15 +4421,15 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after)\n       switch (ocode)\n \t{\n \tcase TRUTH_ANDIF_EXPR:\n-\t  stack[sp].expr.value\n-\t    = default_function_array_conversion (stack[sp].expr.value);\n+\t  stack[sp].expr\n+\t    = default_function_array_conversion (stack[sp].expr);\n \t  stack[sp].expr.value = c_objc_common_truthvalue_conversion\n \t    (default_conversion (stack[sp].expr.value));\n \t  skip_evaluation += stack[sp].expr.value == truthvalue_false_node;\n \t  break;\n \tcase TRUTH_ORIF_EXPR:\n-\t  stack[sp].expr.value\n-\t    = default_function_array_conversion (stack[sp].expr.value);\n+\t  stack[sp].expr\n+\t    = default_function_array_conversion (stack[sp].expr);\n \t  stack[sp].expr.value = c_objc_common_truthvalue_conversion\n \t    (default_conversion (stack[sp].expr.value));\n \t  skip_evaluation += stack[sp].expr.value == truthvalue_true_node;\n@@ -4472,7 +4473,7 @@ c_parser_cast_expression (c_parser *parser, struct c_expr *after)\n     {\n       struct c_type_name *type_name;\n       struct c_expr ret;\n-      tree expr;\n+      struct c_expr expr;\n       c_parser_consume_token (parser);\n       type_name = c_parser_type_name (parser);\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n@@ -4485,9 +4486,9 @@ c_parser_cast_expression (c_parser *parser, struct c_expr *after)\n       if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n \treturn c_parser_postfix_expression_after_paren_type (parser,\n \t\t\t\t\t\t\t     type_name);\n-      expr = c_parser_cast_expression (parser, NULL).value;\n+      expr = c_parser_cast_expression (parser, NULL);\n       expr = default_function_array_conversion (expr);\n-      ret.value = c_cast_expr (type_name, expr);\n+      ret.value = c_cast_expr (type_name, expr.value);\n       ret.original_code = ERROR_MARK;\n       return ret;\n     }\n@@ -4532,12 +4533,12 @@ c_parser_unary_expression (c_parser *parser)\n     case CPP_PLUS_PLUS:\n       c_parser_consume_token (parser);\n       op = c_parser_cast_expression (parser, NULL);\n-      op.value = default_function_array_conversion (op.value);\n+      op = default_function_array_conversion (op);\n       return parser_build_unary_op (PREINCREMENT_EXPR, op);\n     case CPP_MINUS_MINUS:\n       c_parser_consume_token (parser);\n       op = c_parser_cast_expression (parser, NULL);\n-      op.value = default_function_array_conversion (op.value);\n+      op = default_function_array_conversion (op);\n       return parser_build_unary_op (PREDECREMENT_EXPR, op);\n     case CPP_AND:\n       c_parser_consume_token (parser);\n@@ -4546,7 +4547,7 @@ c_parser_unary_expression (c_parser *parser)\n     case CPP_MULT:\n       c_parser_consume_token (parser);\n       op = c_parser_cast_expression (parser, NULL);\n-      op.value = default_function_array_conversion (op.value);\n+      op = default_function_array_conversion (op);\n       ret.value = build_indirect_ref (op.value, \"unary *\");\n       ret.original_code = ERROR_MARK;\n       return ret;\n@@ -4556,22 +4557,22 @@ c_parser_unary_expression (c_parser *parser)\n \twarning (OPT_Wtraditional,\n \t\t \"traditional C rejects the unary plus operator\");\n       op = c_parser_cast_expression (parser, NULL);\n-      op.value = default_function_array_conversion (op.value);\n+      op = default_function_array_conversion (op);\n       return parser_build_unary_op (CONVERT_EXPR, op);\n     case CPP_MINUS:\n       c_parser_consume_token (parser);\n       op = c_parser_cast_expression (parser, NULL);\n-      op.value = default_function_array_conversion (op.value);\n+      op = default_function_array_conversion (op);\n       return parser_build_unary_op (NEGATE_EXPR, op);\n     case CPP_COMPL:\n       c_parser_consume_token (parser);\n       op = c_parser_cast_expression (parser, NULL);\n-      op.value = default_function_array_conversion (op.value);\n+      op = default_function_array_conversion (op);\n       return parser_build_unary_op (BIT_NOT_EXPR, op);\n     case CPP_NOT:\n       c_parser_consume_token (parser);\n       op = c_parser_cast_expression (parser, NULL);\n-      op.value = default_function_array_conversion (op.value);\n+      op = default_function_array_conversion (op);\n       return parser_build_unary_op (TRUTH_NOT_EXPR, op);\n     case CPP_AND_AND:\n       /* Refer to the address of a label as a pointer.  */\n@@ -4605,12 +4606,12 @@ c_parser_unary_expression (c_parser *parser)\n \tcase RID_REALPART:\n \t  c_parser_consume_token (parser);\n \t  op = c_parser_cast_expression (parser, NULL);\n-\t  op.value = default_function_array_conversion (op.value);\n+\t  op = default_function_array_conversion (op);\n \t  return parser_build_unary_op (REALPART_EXPR, op);\n \tcase RID_IMAGPART:\n \t  c_parser_consume_token (parser);\n \t  op = c_parser_cast_expression (parser, NULL);\n-\t  op.value = default_function_array_conversion (op.value);\n+\t  op = default_function_array_conversion (op);\n \t  return parser_build_unary_op (IMAGPART_EXPR, op);\n \tdefault:\n \t  return c_parser_postfix_expression (parser);\n@@ -5250,7 +5251,7 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \tcase CPP_DOT:\n \t  /* Structure element reference.  */\n \t  c_parser_consume_token (parser);\n-\t  expr.value = default_function_array_conversion (expr.value);\n+\t  expr = default_function_array_conversion (expr);\n \t  if (c_parser_next_token_is (parser, CPP_NAME))\n \t    ident = c_parser_peek_token (parser)->value;\n \t  else\n@@ -5267,7 +5268,7 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \tcase CPP_DEREF:\n \t  /* Structure element reference.  */\n \t  c_parser_consume_token (parser);\n-\t  expr.value = default_function_array_conversion (expr.value);\n+\t  expr = default_function_array_conversion (expr);\n \t  if (c_parser_next_token_is (parser, CPP_NAME))\n \t    ident = c_parser_peek_token (parser)->value;\n \t  else\n@@ -5285,14 +5286,14 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \tcase CPP_PLUS_PLUS:\n \t  /* Postincrement.  */\n \t  c_parser_consume_token (parser);\n-\t  expr.value = default_function_array_conversion (expr.value);\n+\t  expr = default_function_array_conversion (expr);\n \t  expr.value = build_unary_op (POSTINCREMENT_EXPR, expr.value, 0);\n \t  expr.original_code = ERROR_MARK;\n \t  break;\n \tcase CPP_MINUS_MINUS:\n \t  /* Postdecrement.  */\n \t  c_parser_consume_token (parser);\n-\t  expr.value = default_function_array_conversion (expr.value);\n+\t  expr = default_function_array_conversion (expr);\n \t  expr.value = build_unary_op (POSTDECREMENT_EXPR, expr.value, 0);\n \t  expr.original_code = ERROR_MARK;\n \t  break;\n@@ -5319,7 +5320,7 @@ c_parser_expression (c_parser *parser)\n       struct c_expr next;\n       c_parser_consume_token (parser);\n       next = c_parser_expr_no_commas (parser, NULL);\n-      next.value = default_function_array_conversion (next.value);\n+      next = default_function_array_conversion (next);\n       expr.value = build_compound_expr (expr.value, next.value);\n       expr.original_code = COMPOUND_EXPR;\n     }\n@@ -5334,7 +5335,7 @@ c_parser_expression_conv (c_parser *parser)\n {\n   struct c_expr expr;\n   expr = c_parser_expression (parser);\n-  expr.value = default_function_array_conversion (expr.value);\n+  expr = default_function_array_conversion (expr);\n   return expr;\n }\n \n@@ -5353,14 +5354,14 @@ c_parser_expr_list (c_parser *parser, bool convert_p)\n   tree ret, cur;\n   expr = c_parser_expr_no_commas (parser, NULL);\n   if (convert_p)\n-    expr.value = default_function_array_conversion (expr.value);\n+    expr = default_function_array_conversion (expr);\n   ret = cur = build_tree_list (NULL_TREE, expr.value);\n   while (c_parser_next_token_is (parser, CPP_COMMA))\n     {\n       c_parser_consume_token (parser);\n       expr = c_parser_expr_no_commas (parser, NULL);\n       if (convert_p)\n-\texpr.value = default_function_array_conversion (expr.value);\n+\texpr = default_function_array_conversion (expr);\n       cur = TREE_CHAIN (cur) = build_tree_list (NULL_TREE, expr.value);\n     }\n   return ret;"}, {"sha": "e92006c6147298a11b0da117fb898b0424635d53", "filename": "gcc/c-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2a71bbcb28113d911c41f133a163f8f03fae04a/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2a71bbcb28113d911c41f133a163f8f03fae04a/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=f2a71bbcb28113d911c41f133a163f8f03fae04a", "patch": "@@ -523,7 +523,7 @@ extern bool c_mark_addressable (tree);\n extern void c_incomplete_type_error (tree, tree);\n extern tree c_type_promotes_to (tree);\n extern tree default_conversion (tree);\n-extern tree default_function_array_conversion (tree);\n+extern struct c_expr default_function_array_conversion (struct c_expr);\n extern tree composite_type (tree, tree);\n extern tree build_component_ref (tree, tree);\n extern tree build_indirect_ref (tree, const char *);"}, {"sha": "64ec126b4bdbc145cb188e0564c94f4ff30c84aa", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 113, "deletions": 94, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2a71bbcb28113d911c41f133a163f8f03fae04a/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2a71bbcb28113d911c41f133a163f8f03fae04a/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=f2a71bbcb28113d911c41f133a163f8f03fae04a", "patch": "@@ -1259,103 +1259,116 @@ decl_constant_value_for_broken_optimization (tree decl)\n   return ret;\n }\n \n-\n-/* Perform the default conversion of arrays and functions to pointers.\n-   Return the result of converting EXP.  For any other expression, just\n-   return EXP after removing NOPs.  */\n-\n-tree\n-default_function_array_conversion (tree exp)\n+/* Convert the array expression EXP to a pointer.  */\n+static tree\n+array_to_pointer_conversion (tree exp)\n {\n-  tree orig_exp;\n+  tree orig_exp = exp;\n   tree type = TREE_TYPE (exp);\n-  enum tree_code code = TREE_CODE (type);\n-  int not_lvalue = 0;\n+  tree adr;\n+  tree restype = TREE_TYPE (type);\n+  tree ptrtype;\n \n-  /* Strip NON_LVALUE_EXPRs and no-op conversions, since we aren't using as\n-     an lvalue.\n+  gcc_assert (TREE_CODE (type) == ARRAY_TYPE);\n \n-     Do not use STRIP_NOPS here!  It will remove conversions from pointer\n-     to integer and cause infinite recursion.  */\n-  orig_exp = exp;\n-  while (TREE_CODE (exp) == NON_LVALUE_EXPR\n-\t || (TREE_CODE (exp) == NOP_EXPR\n-\t     && TREE_TYPE (TREE_OPERAND (exp, 0)) == TREE_TYPE (exp)))\n-    {\n-      if (TREE_CODE (exp) == NON_LVALUE_EXPR)\n-\tnot_lvalue = 1;\n-      exp = TREE_OPERAND (exp, 0);\n-    }\n+  STRIP_TYPE_NOPS (exp);\n \n   if (TREE_NO_WARNING (orig_exp))\n     TREE_NO_WARNING (exp) = 1;\n \n-  if (code == FUNCTION_TYPE)\n+  ptrtype = build_pointer_type (restype);\n+\n+  if (TREE_CODE (exp) == INDIRECT_REF)\n+    return convert (ptrtype, TREE_OPERAND (exp, 0));\n+\n+  if (TREE_CODE (exp) == VAR_DECL)\n     {\n-      return build_unary_op (ADDR_EXPR, exp, 0);\n+      /* We are making an ADDR_EXPR of ptrtype.  This is a valid\n+\t ADDR_EXPR because it's the best way of representing what\n+\t happens in C when we take the address of an array and place\n+\t it in a pointer to the element type.  */\n+      adr = build1 (ADDR_EXPR, ptrtype, exp);\n+      if (!c_mark_addressable (exp))\n+\treturn error_mark_node;\n+      TREE_SIDE_EFFECTS (adr) = 0;   /* Default would be, same as EXP.  */\n+      return adr;\n     }\n-  if (code == ARRAY_TYPE)\n-    {\n-      tree adr;\n-      tree restype = TREE_TYPE (type);\n-      tree ptrtype;\n-      int constp = 0;\n-      int volatilep = 0;\n-      int lvalue_array_p;\n \n-      if (REFERENCE_CLASS_P (exp) || DECL_P (exp))\n-\t{\n-\t  constp = TREE_READONLY (exp);\n-\t  volatilep = TREE_THIS_VOLATILE (exp);\n-\t}\n+  /* This way is better for a COMPONENT_REF since it can\n+     simplify the offset for a component.  */\n+  adr = build_unary_op (ADDR_EXPR, exp, 1);\n+  return convert (ptrtype, adr);\n+}\n \n-      if (TYPE_QUALS (type) || constp || volatilep)\n-\trestype\n-\t  = c_build_qualified_type (restype,\n-\t\t\t\t    TYPE_QUALS (type)\n-\t\t\t\t    | (constp * TYPE_QUAL_CONST)\n-\t\t\t\t    | (volatilep * TYPE_QUAL_VOLATILE));\n+/* Convert the function expression EXP to a pointer.  */\n+static tree\n+function_to_pointer_conversion (tree exp)\n+{\n+  tree orig_exp = exp;\n \n-      if (TREE_CODE (exp) == INDIRECT_REF)\n-\treturn convert (build_pointer_type (restype),\n-\t\t\tTREE_OPERAND (exp, 0));\n+  gcc_assert (TREE_CODE (TREE_TYPE (exp)) == FUNCTION_TYPE);\n \n-      if (TREE_CODE (exp) == COMPOUND_EXPR)\n-\t{\n-\t  tree op1 = default_conversion (TREE_OPERAND (exp, 1));\n-\t  return build2 (COMPOUND_EXPR, TREE_TYPE (op1),\n-\t\t\t TREE_OPERAND (exp, 0), op1);\n-\t}\n+  STRIP_TYPE_NOPS (exp);\n \n-      lvalue_array_p = !not_lvalue && lvalue_p (exp);\n-      if (!flag_isoc99 && !lvalue_array_p)\n-\t{\n-\t  /* Before C99, non-lvalue arrays do not decay to pointers.\n-\t     Normally, using such an array would be invalid; but it can\n-\t     be used correctly inside sizeof or as a statement expression.\n-\t     Thus, do not give an error here; an error will result later.  */\n-\t  return exp;\n-\t}\n+  if (TREE_NO_WARNING (orig_exp))\n+    TREE_NO_WARNING (exp) = 1;\n \n-      ptrtype = build_pointer_type (restype);\n+  return build_unary_op (ADDR_EXPR, exp, 0);\n+}\n \n-      if (TREE_CODE (exp) == VAR_DECL)\n-\t{\n-\t  /* We are making an ADDR_EXPR of ptrtype.  This is a valid\n-\t     ADDR_EXPR because it's the best way of representing what\n-\t     happens in C when we take the address of an array and place\n-\t     it in a pointer to the element type.  */\n-\t  adr = build1 (ADDR_EXPR, ptrtype, exp);\n-\t  if (!c_mark_addressable (exp))\n-\t    return error_mark_node;\n-\t  TREE_SIDE_EFFECTS (adr) = 0;   /* Default would be, same as EXP.  */\n-\t  return adr;\n-\t}\n-      /* This way is better for a COMPONENT_REF since it can\n-\t simplify the offset for a component.  */\n-      adr = build_unary_op (ADDR_EXPR, exp, 1);\n-      return convert (ptrtype, adr);\n+/* Perform the default conversion of arrays and functions to pointers.\n+   Return the result of converting EXP.  For any other expression, just\n+   return EXP after removing NOPs.  */\n+\n+struct c_expr\n+default_function_array_conversion (struct c_expr exp)\n+{\n+  tree orig_exp = exp.value;\n+  tree type = TREE_TYPE (exp.value);\n+  enum tree_code code = TREE_CODE (type);\n+\n+  switch (code)\n+    {\n+    case ARRAY_TYPE:\n+      {\n+\tbool not_lvalue = false;\n+\tbool lvalue_array_p;\n+\n+\twhile ((TREE_CODE (exp.value) == NON_LVALUE_EXPR\n+\t\t|| TREE_CODE (exp.value) == NOP_EXPR)\n+\t       && TREE_TYPE (TREE_OPERAND (exp.value, 0)) == type)\n+\t  {\n+\t    if (TREE_CODE (exp.value) == NON_LVALUE_EXPR)\n+\t      not_lvalue = true;\n+\t    exp.value = TREE_OPERAND (exp.value, 0);\n+\t  }\n+\n+\tif (TREE_NO_WARNING (orig_exp))\n+\t  TREE_NO_WARNING (exp.value) = 1;\n+\n+\tlvalue_array_p = !not_lvalue && lvalue_p (exp.value);\n+\tif (!flag_isoc99 && !lvalue_array_p)\n+\t  {\n+\t    /* Before C99, non-lvalue arrays do not decay to pointers.\n+\t       Normally, using such an array would be invalid; but it can\n+\t       be used correctly inside sizeof or as a statement expression.\n+\t       Thus, do not give an error here; an error will result later.  */\n+\t    return exp;\n+\t  }\n+\n+\texp.value = array_to_pointer_conversion (exp.value);\n+      }\n+      break;\n+    case FUNCTION_TYPE:\n+      exp.value = function_to_pointer_conversion (exp.value);\n+      break;\n+    default:\n+      STRIP_TYPE_NOPS (exp.value);\n+      if (TREE_NO_WARNING (orig_exp))\n+\tTREE_NO_WARNING (exp.value) = 1;\n+      break;\n     }\n+\n   return exp;\n }\n \n@@ -1992,7 +2005,8 @@ build_function_call (tree function, tree params)\n       name = DECL_NAME (function);\n       fundecl = function;\n     }\n-  function = default_function_array_conversion (function);\n+  if (TREE_CODE (TREE_TYPE (function)) == FUNCTION_TYPE)\n+    function = function_to_pointer_conversion (function);\n \n   /* For Objective-C, convert any calls via a cast to OBJC_TYPE_REF\n      expressions, like those used for ObjC messenger dispatches.  */\n@@ -2730,11 +2744,13 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n       /* For &x[y], return x+y */\n       if (TREE_CODE (arg) == ARRAY_REF)\n \t{\n-\t  if (!c_mark_addressable (TREE_OPERAND (arg, 0)))\n+\t  tree op0 = TREE_OPERAND (arg, 0);\n+\t  if (!c_mark_addressable (op0))\n \t    return error_mark_node;\n \t  return build_binary_op (PLUS_EXPR,\n-\t\t\t\t  default_function_array_conversion\n-\t\t\t\t    (TREE_OPERAND (arg, 0)),\n+\t\t\t\t  (TREE_CODE (TREE_TYPE (op0)) == ARRAY_TYPE\n+\t\t\t\t   ? array_to_pointer_conversion (op0)\n+\t\t\t\t   : op0),\n \t\t\t\t  TREE_OPERAND (arg, 1), 1);\n \t}\n \n@@ -4367,16 +4383,18 @@ digest_init (tree type, tree init, bool strict_string, int require_constant)\n     {\n       if (code == POINTER_TYPE)\n \t{\n-\t  if (TREE_CODE (inside_init) == STRING_CST\n-\t      || TREE_CODE (inside_init) == COMPOUND_LITERAL_EXPR)\n-\t    inside_init = default_function_array_conversion (inside_init);\n-\n \t  if (TREE_CODE (TREE_TYPE (inside_init)) == ARRAY_TYPE)\n \t    {\n-\t      error_init (\"invalid use of non-lvalue array\");\n-\t      return error_mark_node;\n+\t      if (TREE_CODE (inside_init) == STRING_CST\n+\t\t  || TREE_CODE (inside_init) == COMPOUND_LITERAL_EXPR)\n+\t\tinside_init = array_to_pointer_conversion (inside_init);\n+\t      else\n+\t\t{\n+\t\t  error_init (\"invalid use of non-lvalue array\");\n+\t\t  return error_mark_node;\n+\t\t}\n \t    }\n-\t }\n+\t}\n \n       if (code == VECTOR_TYPE)\n \t/* Although the types are compatible, we may require a\n@@ -4436,9 +4454,10 @@ digest_init (tree type, tree init, bool strict_string, int require_constant)\n       || code == ENUMERAL_TYPE || code == BOOLEAN_TYPE || code == COMPLEX_TYPE\n       || code == VECTOR_TYPE)\n     {\n-      if (TREE_CODE (init) == STRING_CST\n-\t  || TREE_CODE (init) == COMPOUND_LITERAL_EXPR)\n-\tinit = default_function_array_conversion (init);\n+      if (TREE_CODE (TREE_TYPE (init)) == ARRAY_TYPE\n+\t  && (TREE_CODE (init) == STRING_CST\n+\t      || TREE_CODE (init) == COMPOUND_LITERAL_EXPR))\n+\tinit = array_to_pointer_conversion (init);\n       inside_init\n \t= convert_for_assignment (type, init, ic_init,\n \t\t\t\t  NULL_TREE, NULL_TREE, 0);\n@@ -5796,7 +5815,7 @@ output_init_element (tree value, bool strict_string, tree type, tree field,\n \t   && INTEGRAL_TYPE_P (TREE_TYPE (type)))\n       && !comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (value)),\n \t\t     TYPE_MAIN_VARIANT (type)))\n-    value = default_function_array_conversion (value);\n+    value = array_to_pointer_conversion (value);\n \n   if (TREE_CODE (value) == COMPOUND_LITERAL_EXPR\n       && require_constant_value && !flag_isoc99 && pending)"}]}