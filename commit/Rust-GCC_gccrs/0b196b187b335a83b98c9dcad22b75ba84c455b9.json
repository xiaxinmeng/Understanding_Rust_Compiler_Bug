{"sha": "0b196b187b335a83b98c9dcad22b75ba84c455b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGIxOTZiMTg3YjMzNWE4M2I5OGM5ZGNhZDIyYjc1YmE4NGM0NTViOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-04-18T16:13:00Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-04-18T16:13:00Z"}, "message": "alpha.c (alpha_split_atomic_op): New.\n\n        * config/alpha/alpha.c (alpha_split_atomic_op): New.\n        (alphaev5_insn_pipe): Add LD_L, ST_C, MB types.\n        (alphaev4_insn_pipe): Likewise.  Correct IST and LDSYM pipes.\n        * config/alpha/alpha-protos.h: Update.\n        * config/alpha/alpha.md (UNSPECV_MB, UNSPECV_LL, UNSPECV_SC): New.\n        (UNSPECV_ATOMIC, UNSPECV_CMPXCHG, UNSPECV_XCHG): New.\n        (attr type): Add ld_l, st_c, mb.\n        (andsi_internal, andnotsi3, iorsi_internal, one_cmplsi_internal,\n        iornotsi3, xorsi_internal, xornotsi3): New.\n        * config/alpha/ev4.md (ev4_ld): Add ld_l.\n        (ev4_ist_c, ev4_mb): New.\n        * config/alpha/ev5.md (ev5_st): Add st_c, mb.\n        (ev5_ld_l): New.\n        * config/alpha/ev6.md (ev6_ild): Add ld_l.\n        (ev6_ist): Add st_c.\n        (ev6_mb): New.\n        * config/alpha/sync.md: New file.\n\nFrom-SVN: r98328", "tree": {"sha": "d03d3c5e67f21af4ac017cf55ce23f1beda9b168", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d03d3c5e67f21af4ac017cf55ce23f1beda9b168"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b196b187b335a83b98c9dcad22b75ba84c455b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b196b187b335a83b98c9dcad22b75ba84c455b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b196b187b335a83b98c9dcad22b75ba84c455b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b196b187b335a83b98c9dcad22b75ba84c455b9/comments", "author": null, "committer": null, "parents": [{"sha": "46c94db61830d164a410f0f09d605c9cecedb2eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46c94db61830d164a410f0f09d605c9cecedb2eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46c94db61830d164a410f0f09d605c9cecedb2eb"}], "stats": {"total": 524, "additions": 513, "deletions": 11}, "files": [{"sha": "335f5ffaf6825e7060c3e8f44d4d5f065acb3763", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b196b187b335a83b98c9dcad22b75ba84c455b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b196b187b335a83b98c9dcad22b75ba84c455b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b196b187b335a83b98c9dcad22b75ba84c455b9", "patch": "@@ -1,3 +1,23 @@\n+2005-04-18  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (alpha_split_atomic_op): New.\n+\t(alphaev5_insn_pipe): Add LD_L, ST_C, MB types.\n+\t(alphaev4_insn_pipe): Likewise.  Correct IST and LDSYM pipes.\n+\t* config/alpha/alpha-protos.h: Update.\n+\t* config/alpha/alpha.md (UNSPECV_MB, UNSPECV_LL, UNSPECV_SC): New.\n+\t(UNSPECV_ATOMIC, UNSPECV_CMPXCHG, UNSPECV_XCHG): New.\n+\t(attr type): Add ld_l, st_c, mb.\n+\t(andsi_internal, andnotsi3, iorsi_internal, one_cmplsi_internal,\n+\tiornotsi3, xorsi_internal, xornotsi3): New.\n+\t* config/alpha/ev4.md (ev4_ld): Add ld_l.\n+\t(ev4_ist_c, ev4_mb): New.\n+\t* config/alpha/ev5.md (ev5_st): Add st_c, mb.\n+\t(ev5_ld_l): New.\n+\t* config/alpha/ev6.md (ev6_ild): Add ld_l.\n+\t(ev6_ist): Add st_c.\n+\t(ev6_mb): New.\n+\t* config/alpha/sync.md: New file.\n+\n 2005-04-18  Richard Henderson  <rth@redhat.com>\n \n \t* builtins.c (expand_builtin_sync_operation): Fold nand to and"}, {"sha": "dc2b027108bfd533565eb3f0ab85ac393899219c", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b196b187b335a83b98c9dcad22b75ba84c455b9/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b196b187b335a83b98c9dcad22b75ba84c455b9/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=0b196b187b335a83b98c9dcad22b75ba84c455b9", "patch": "@@ -101,6 +101,7 @@ extern rtx alpha_emit_setcc (enum rtx_code);\n extern int alpha_split_conditional_move (enum rtx_code, rtx, rtx, rtx, rtx);\n extern void alpha_emit_xfloating_arith (enum rtx_code, rtx[]);\n extern void alpha_emit_xfloating_cvt (enum rtx_code, rtx[]);\n+extern void alpha_split_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx, rtx);\n #endif\n \n extern rtx alpha_need_linkage (const char *, int);"}, {"sha": "895189b2770e820931718fc091f32d8a5a991d1d", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 66, "deletions": 2, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b196b187b335a83b98c9dcad22b75ba84c455b9/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b196b187b335a83b98c9dcad22b75ba84c455b9/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=0b196b187b335a83b98c9dcad22b75ba84c455b9", "patch": "@@ -4469,6 +4469,64 @@ alpha_expand_builtin_vector_binop (rtx (*gen) (rtx, rtx, rtx),\n \n   emit_insn ((*gen) (op0, op1, op2));\n }\n+\n+/* Expand an an atomic fetch-and-operate pattern.  CODE is the binary operation\n+   to perform.  MEM is the memory on which to operate.  VAL is the second \n+   operand of the binary operator.  BEFORE and AFTER are optional locations to\n+   return the value of MEM either before of after the operation.  SCRATCH is\n+   a scratch register.  */\n+\n+void\n+alpha_split_atomic_op (enum rtx_code code, rtx mem, rtx val,\n+\t\t       rtx before, rtx after, rtx scratch)\n+{\n+  enum machine_mode mode = GET_MODE (mem);\n+  rtx label, cond, x;\n+  rtx very_unlikely = GEN_INT (REG_BR_PROB_BASE / 100 - 1);\n+\n+  emit_insn (gen_memory_barrier ());\n+\n+  label = gen_label_rtx ();\n+  emit_label (label);\n+  label = gen_rtx_LABEL_REF (DImode, label);\n+\n+  if (before == NULL)\n+    before = scratch;\n+\n+  if (mode == SImode)\n+    emit_insn (gen_load_locked_si (before, mem));\n+  else if (mode == DImode)\n+    emit_insn (gen_load_locked_di (before, mem));\n+  else\n+    gcc_unreachable ();\n+\n+  if (code == NOT)\n+    {\n+      x = gen_rtx_NOT (mode, val);\n+      x = gen_rtx_AND (mode, x, before);\n+    }\n+  else\n+    x = gen_rtx_fmt_ee (code, mode, before, val);\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, scratch, x));\n+  if (after)\n+    emit_insn (gen_rtx_SET (VOIDmode, after, copy_rtx (x)));\n+\n+  cond = gen_rtx_REG (DImode, REGNO (scratch));\n+  if (mode == SImode)\n+    emit_insn (gen_store_conditional_si (cond, mem, scratch));\n+  else if (mode == DImode)\n+    emit_insn (gen_store_conditional_di (cond, mem, scratch));\n+  else\n+    gcc_unreachable ();\n+\n+  x = gen_rtx_EQ (DImode, cond, const0_rtx);\n+  x = gen_rtx_IF_THEN_ELSE (VOIDmode, x, label, pc_rtx);\n+  x = emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, x));\n+  REG_NOTES (x) = gen_rtx_EXPR_LIST (REG_BR_PROB, very_unlikely, NULL_RTX);\n+\n+  emit_insn (gen_memory_barrier ());\n+}\n \f\n /* Adjust the cost of a scheduling dependency.  Return the new cost of\n    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */\n@@ -8479,21 +8537,22 @@ alphaev4_insn_pipe (rtx insn)\n   switch (get_attr_type (insn))\n     {\n     case TYPE_ILD:\n+    case TYPE_LDSYM:\n     case TYPE_FLD:\n+    case TYPE_LD_L:\n       return EV4_IBX;\n \n-    case TYPE_LDSYM:\n     case TYPE_IADD:\n     case TYPE_ILOG:\n     case TYPE_ICMOV:\n     case TYPE_ICMP:\n-    case TYPE_IST:\n     case TYPE_FST:\n     case TYPE_SHIFT:\n     case TYPE_IMUL:\n     case TYPE_FBR:\n       return EV4_IB0;\n \n+    case TYPE_IST:\n     case TYPE_MISC:\n     case TYPE_IBR:\n     case TYPE_JSR:\n@@ -8503,6 +8562,8 @@ alphaev4_insn_pipe (rtx insn)\n     case TYPE_FADD:\n     case TYPE_FDIV:\n     case TYPE_FMUL:\n+    case TYPE_ST_C:\n+    case TYPE_MB:\n       return EV4_IB1;\n \n     default:\n@@ -8535,6 +8596,9 @@ alphaev5_insn_pipe (rtx insn)\n     case TYPE_IMUL:\n     case TYPE_MISC:\n     case TYPE_MVI:\n+    case TYPE_LD_L:\n+    case TYPE_ST_C:\n+    case TYPE_MB:\n       return EV5_E0;\n \n     case TYPE_IBR:"}, {"sha": "644b5b0653f1f8be5359f8411c088a31ca4fdd21", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 77, "deletions": 4, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b196b187b335a83b98c9dcad22b75ba84c455b9/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b196b187b335a83b98c9dcad22b75ba84c455b9/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=0b196b187b335a83b98c9dcad22b75ba84c455b9", "patch": "@@ -76,6 +76,12 @@\n    (UNSPECV_SET_TP\t12)\n    (UNSPECV_RPCC\t13)\n    (UNSPECV_SETJMPR_ER\t14)\t; builtin_setjmp_receiver fragment\n+   (UNSPECV_MB\t\t15)\n+   (UNSPECV_LL\t\t16)\t; load-locked\n+   (UNSPECV_SC\t\t17)\t; store-conditional\n+   (UNSPECV_ATOMIC\t18)\n+   (UNSPECV_CMPXCHG\t19)\n+   (UNSPECV_XCHG\t20)\n   ])\n \n ;; Where necessary, the suffixes _le and _be are used to distinguish between\n@@ -97,7 +103,8 @@\n \n (define_attr \"type\"\n   \"ild,fld,ldsym,ist,fst,ibr,callpal,fbr,jsr,iadd,ilog,shift,icmov,fcmov,\n-   icmp,imul,fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n+   icmp,imul,fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,mb,ld_l,st_c,\n+   multi,none\"\n   (const_string \"iadd\"))\n \n ;; Describe a user's asm statement.\n@@ -1100,7 +1107,20 @@\n   [(set_attr \"type\" \"jsr\")\n    (set_attr \"length\" \"8\")])\n \f\n-;; Next are the basic logical operations.  These only exist in DImode.\n+;; Next are the basic logical operations.  We only expose the DImode operations\n+;; to the rtl expanders, but SImode versions exist for combine as well as for\n+;; the atomic operation splitters.\n+\n+(define_insn \"*andsi_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(and:SI (match_operand:SI 1 \"reg_or_0_operand\" \"%rJ,rJ,rJ\")\n+\t\t(match_operand:SI 2 \"and_operand\" \"rI,N,MH\")))]\n+  \"\"\n+  \"@\n+   and %r1,%2,%0\n+   bic %r1,%N2,%0\n+   zapnot %r1,%m2,%0\"\n+  [(set_attr \"type\" \"ilog,ilog,shift\")])\n \n (define_insn \"anddi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r\")\n@@ -1275,6 +1295,14 @@\n   \"zapnot %1,15,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n+(define_insn \"*andnotsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (not:SI (match_operand:SI 1 \"reg_or_8bit_operand\" \"rI\"))\n+\t\t(match_operand:SI 2 \"reg_or_0_operand\" \"rJ\")))]\n+  \"\"\n+  \"bic %r2,%1,%0\"\n+  [(set_attr \"type\" \"ilog\")])\n+\n (define_insn \"andnotdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(and:DI (not:DI (match_operand:DI 1 \"reg_or_8bit_operand\" \"rI\"))\n@@ -1283,6 +1311,16 @@\n   \"bic %r2,%1,%0\"\n   [(set_attr \"type\" \"ilog\")])\n \n+(define_insn \"*iorsi_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ior:SI (match_operand:SI 1 \"reg_or_0_operand\" \"%rJ,rJ\")\n+\t\t(match_operand:SI 2 \"or_operand\" \"rI,N\")))]\n+  \"\"\n+  \"@\n+   bis %r1,%2,%0\n+   ornot %r1,%N2,%0\"\n+  [(set_attr \"type\" \"ilog\")])\n+\n (define_insn \"iordi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(ior:DI (match_operand:DI 1 \"reg_or_0_operand\" \"%rJ,rJ\")\n@@ -1293,21 +1331,46 @@\n    ornot %r1,%N2,%0\"\n   [(set_attr \"type\" \"ilog\")])\n \n+(define_insn \"*one_cmplsi_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (match_operand:SI 1 \"reg_or_8bit_operand\" \"rI\")))]\n+  \"\"\n+  \"ornot $31,%1,%0\"\n+  [(set_attr \"type\" \"ilog\")])\n+\n (define_insn \"one_cmpldi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(not:DI (match_operand:DI 1 \"reg_or_8bit_operand\" \"rI\")))]\n   \"\"\n   \"ornot $31,%1,%0\"\n   [(set_attr \"type\" \"ilog\")])\n \n-(define_insn \"*iornot\"\n+(define_insn \"*iornotsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (not:SI (match_operand:SI 1 \"reg_or_8bit_operand\" \"rI\"))\n+\t\t(match_operand:SI 2 \"reg_or_0_operand\" \"rJ\")))]\n+  \"\"\n+  \"ornot %r2,%1,%0\"\n+  [(set_attr \"type\" \"ilog\")])\n+\n+(define_insn \"*iornotdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ior:DI (not:DI (match_operand:DI 1 \"reg_or_8bit_operand\" \"rI\"))\n \t\t(match_operand:DI 2 \"reg_or_0_operand\" \"rJ\")))]\n   \"\"\n   \"ornot %r2,%1,%0\"\n   [(set_attr \"type\" \"ilog\")])\n \n+(define_insn \"*xorsi_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(xor:SI (match_operand:SI 1 \"reg_or_0_operand\" \"%rJ,rJ\")\n+\t\t(match_operand:SI 2 \"or_operand\" \"rI,N\")))]\n+  \"\"\n+  \"@\n+   xor %r1,%2,%0\n+   eqv %r1,%N2,%0\"\n+  [(set_attr \"type\" \"ilog\")])\n+\n (define_insn \"xordi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(xor:DI (match_operand:DI 1 \"reg_or_0_operand\" \"%rJ,rJ\")\n@@ -1318,7 +1381,15 @@\n    eqv %r1,%N2,%0\"\n   [(set_attr \"type\" \"ilog\")])\n \n-(define_insn \"*xornot\"\n+(define_insn \"*xornotsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (xor:SI (match_operand:SI 1 \"register_operand\" \"%rJ\")\n+\t\t\t(match_operand:SI 2 \"register_operand\" \"rI\"))))]\n+  \"\"\n+  \"eqv %r1,%2,%0\"\n+  [(set_attr \"type\" \"ilog\")])\n+\n+(define_insn \"*xornotdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(not:DI (xor:DI (match_operand:DI 1 \"register_operand\" \"%rJ\")\n \t\t\t(match_operand:DI 2 \"register_operand\" \"rI\"))))]\n@@ -7705,6 +7776,8 @@\n   \"unpkbw %r1,%0\"\n   [(set_attr \"type\" \"mvi\")])\n \f\n+(include \"sync.md\")\n+\f\n ;; The call patterns are at the end of the file because their\n ;; wildcard operand0 interferes with nice recognition.\n "}, {"sha": "52f25561c565c7293c16ae894ce544fad06aa06c", "filename": "gcc/config/alpha/ev4.md", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b196b187b335a83b98c9dcad22b75ba84c455b9/gcc%2Fconfig%2Falpha%2Fev4.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b196b187b335a83b98c9dcad22b75ba84c455b9/gcc%2Fconfig%2Falpha%2Fev4.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fev4.md?ref=0b196b187b335a83b98c9dcad22b75ba84c455b9", "patch": "@@ -39,7 +39,7 @@\n ; in user-specified memory latency, so return 1 here.\n (define_insn_reservation \"ev4_ld\" 1\n   (and (eq_attr \"tune\" \"ev4\")\n-       (eq_attr \"type\" \"ild,fld,ldsym\"))\n+       (eq_attr \"type\" \"ild,fld,ldsym,ld_l\"))\n   \"ev4_ib01+ev4_abox\")\n \n ; Stores can issue before the data (but not address) is ready.\n@@ -48,11 +48,26 @@\n        (eq_attr \"type\" \"ist\"))\n   \"ev4_ib1+ev4_abox\")\n \n+; ??? Separate from ev4_ist because store_data_bypass_p can't handle\n+; the patterns with multiple sets, like store-conditional.\n+(define_insn_reservation \"ev4_ist_c\" 1\n+  (and (eq_attr \"tune\" \"ev4\")\n+       (eq_attr \"type\" \"st_c\"))\n+  \"ev4_ib1+ev4_abox\")\n+\n (define_insn_reservation \"ev4_fst\" 1\n   (and (eq_attr \"tune\" \"ev4\")\n        (eq_attr \"type\" \"fst\"))\n   \"ev4_ib0+ev4_abox\")\n \n+; Memory barrier blocks ABOX insns until it's acknowledged by the external\n+; memory bus.  This may be *quite* slow.  Setting this to 4 cycles gets\n+; about all the benefit without making the DFA too large.\n+(define_insn_reservation \"ev4_mb\" 4\n+  (and (eq_attr \"tune\" \"ev4\")\n+       (eq_attr \"type\" \"mb\"))\n+  \"ev4_ib1+ev4_abox,ev4_abox*3\")\n+\n ; Branches have no delay cost, but do tie up the unit for two cycles.\n (define_insn_reservation \"ev4_ibr\" 2\n   (and (eq_attr \"tune\" \"ev4\")"}, {"sha": "b61cfe8e8f0bf8def616f1e17da5cc27b3bbb33d", "filename": "gcc/config/alpha/ev5.md", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b196b187b335a83b98c9dcad22b75ba84c455b9/gcc%2Fconfig%2Falpha%2Fev5.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b196b187b335a83b98c9dcad22b75ba84c455b9/gcc%2Fconfig%2Falpha%2Fev5.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fev5.md?ref=0b196b187b335a83b98c9dcad22b75ba84c455b9", "patch": "@@ -43,7 +43,7 @@\n \n (define_insn_reservation \"ev5_st\" 1\n   (and (eq_attr \"tune\" \"ev5\")\n-       (eq_attr \"type\" \"ist,fst\"))\n+       (eq_attr \"type\" \"ist,fst,st_c,mb\"))\n   \"ev5_e0+ev5_st\")\n \n ; Loads from L0 complete in two cycles.  adjust_cost still factors\n@@ -53,6 +53,11 @@\n        (eq_attr \"type\" \"ild,fld,ldsym\"))\n   \"ev5_e01+ev5_ld\")\n \n+(define_insn_reservation \"ev5_ld_l\" 1\n+  (and (eq_attr \"tune\" \"ev5\")\n+       (eq_attr \"type\" \"ld_l\"))\n+  \"ev5_e0+ev5_ld\")\n+\n ; Integer branches slot only to E1.\n (define_insn_reservation \"ev5_ibr\" 1\n   (and (eq_attr \"tune\" \"ev5\")\n@@ -129,7 +134,7 @@\n ; Model this instead with increased latency on the input instruction.\n \n (define_bypass 3\n-  \"ev5_ld,ev5_shift,ev5_mvi,ev5_cmov,ev5_iadd,ev5_ilogcmp\"\n+  \"ev5_ld,ev5_ld_l,ev5_shift,ev5_mvi,ev5_cmov,ev5_iadd,ev5_ilogcmp\"\n   \"ev5_imull,ev5_imulq,ev5_imulh\")\n \n (define_bypass  9 \"ev5_imull\" \"ev5_imull,ev5_imulq,ev5_imulh\")"}, {"sha": "6ddadca54f29aa6ef373f24b073fe62a187c499b", "filename": "gcc/config/alpha/ev6.md", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b196b187b335a83b98c9dcad22b75ba84c455b9/gcc%2Fconfig%2Falpha%2Fev6.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b196b187b335a83b98c9dcad22b75ba84c455b9/gcc%2Fconfig%2Falpha%2Fev6.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fev6.md?ref=0b196b187b335a83b98c9dcad22b75ba84c455b9", "patch": "@@ -53,14 +53,19 @@\n ; adjust_cost still factors in user-specified memory latency, so return 1 here.\n (define_insn_reservation \"ev6_ild\" 1\n   (and (eq_attr \"tune\" \"ev6\")\n-       (eq_attr \"type\" \"ild,ldsym\"))\n+       (eq_attr \"type\" \"ild,ldsym,ld_l\"))\n   \"ev6_l\")\n \n (define_insn_reservation \"ev6_ist\" 1\n   (and (eq_attr \"tune\" \"ev6\")\n-       (eq_attr \"type\" \"ist\"))\n+       (eq_attr \"type\" \"ist,st_c\"))\n   \"ev6_l\")\n \n+(define_insn_reservation \"ev6_mb\" 1\n+  (and (eq_attr \"tune\" \"ev6\")\n+       (eq_attr \"type\" \"mb\"))\n+  \"ev6_l1\")\n+\n ; FP loads take at least 4 clocks.  adjust_cost still factors\n ; in user-specified memory latency, so return 2 here.\n (define_insn_reservation \"ev6_fld\" 2"}, {"sha": "755a3f3e2e9b355aa47a222d4bc06a9dc975ac18", "filename": "gcc/config/alpha/sync.md", "status": "added", "additions": 319, "deletions": 0, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b196b187b335a83b98c9dcad22b75ba84c455b9/gcc%2Fconfig%2Falpha%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b196b187b335a83b98c9dcad22b75ba84c455b9/gcc%2Fconfig%2Falpha%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fsync.md?ref=0b196b187b335a83b98c9dcad22b75ba84c455b9", "patch": "@@ -0,0 +1,319 @@\n+;; GCC machine description for Alpha synchronization instructions.\n+;; Copyright (C) 2005\n+;; Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+(define_mode_macro I48MODE [SI DI])\n+(define_mode_attr modesuffix [(SI \"l\") (DI \"q\")])\n+\n+(define_code_macro FETCHOP [plus minus ior xor and])\n+(define_code_attr fetchop_name\n+  [(plus \"add\") (minus \"sub\") (ior \"ior\") (xor \"xor\") (and \"and\")])\n+(define_code_attr fetchop_pred\n+  [(plus \"add_operand\") (minus \"reg_or_8bit_operand\")\n+   (ior \"or_operand\") (xor \"or_operand\") (and \"and_operand\")])\n+(define_code_attr fetchop_constr\n+  [(plus \"rKL\") (minus \"rI\") (ior \"rIN\") (xor \"rIN\") (and \"riNHM\")])\n+\n+\n+(define_expand \"memory_barrier\"\n+  [(set (mem:BLK (match_dup 0))\n+\t(unspec_volatile:BLK [(mem:BLK (match_dup 0))] UNSPECV_MB))]\n+  \"\"\n+{\n+  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (DImode));\n+  MEM_VOLATILE_P (operands[0]) = 1;\n+})\n+\n+(define_insn \"*mb_internal\"\n+  [(set (match_operand:BLK 0 \"\" \"\")\n+\t(unspec_volatile:BLK [(match_operand:BLK 1 \"\" \"\")] UNSPECV_MB))]\n+  \"\"\n+  \"mb\"\n+  [(set_attr \"type\" \"mb\")])\n+\n+(define_insn \"load_locked_<mode>\"\n+  [(set (match_operand:I48MODE 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:I48MODE\n+\t  [(match_operand:I48MODE 1 \"memory_operand\" \"m\")]\n+\t  UNSPECV_LL))]\n+  \"\"\n+  \"ld<modesuffix>_l %0,%1\"\n+  [(set_attr \"type\" \"ld_l\")])\n+\n+(define_insn \"store_conditional_<mode>\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (unspec_volatile:DI [(const_int 0)] UNSPECV_SC))\n+   (set (match_operand:I48MODE 1 \"memory_operand\" \"=m\")\n+\t(match_operand:I48MODE 2 \"reg_or_0_operand\" \"0\"))]\n+  \"\"\n+  \"st<modesuffix>_c %0,%1\"\n+  [(set_attr \"type\" \"st_c\")])\n+\n+;; The Alpha Architecture Handbook says that it is UNPREDICTABLE whether\n+;; the lock is cleared by a TAKEN branch.  If we were to honor that, it\n+;; would mean that we could not expand a ll/sc sequence until after the\n+;; final basic-block reordering pass.  Fortunately, it appears that no\n+;; Alpha implementation ever built actually clears the lock on branches,\n+;; taken or not.\n+\n+(define_insn_and_split \"sync_<fetchop_name><mode>\"\n+  [(set (match_operand:I48MODE 0 \"memory_operand\" \"+m\")\n+\t(unspec_volatile:I48MODE\n+\t  [(FETCHOP:I48MODE (match_dup 0)\n+\t     (match_operand:I48MODE 1 \"<fetchop_pred>\" \"<fetchop_constr>\"))]\n+\t  UNSPECV_ATOMIC))\n+   (clobber (match_scratch:I48MODE 2 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  alpha_split_atomic_op (<CODE>, operands[0], operands[1],\n+\t\t\t NULL, NULL, operands[2]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn_and_split \"sync_nand<mode>\"\n+  [(set (match_operand:I48MODE 0 \"memory_operand\" \"+m\")\n+\t(unspec_volatile:I48MODE\n+\t  [(and:I48MODE\n+\t     (not:I48MODE\n+\t       (match_operand:I48MODE 1 \"reg_or_8bit_operand\" \"rI\"))\n+\t     (match_dup 0))]\n+\t  UNSPECV_ATOMIC))\n+   (clobber (match_scratch:I48MODE 2 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  alpha_split_atomic_op (NOT, operands[0], operands[1],\n+\t\t\t NULL, NULL, operands[2]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn_and_split \"sync_old_<fetchop_name><mode>\"\n+  [(set (match_operand:I48MODE 0 \"register_operand\" \"=&r\")\n+\t(match_operand:I48MODE 1 \"memory_operand\" \"+m\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:I48MODE\n+\t  [(FETCHOP:I48MODE (match_dup 1)\n+\t     (match_operand:I48MODE 2 \"<fetchop_pred>\" \"<fetchop_constr>\"))]\n+\t  UNSPECV_ATOMIC))\n+   (clobber (match_scratch:I48MODE 3 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  alpha_split_atomic_op (<CODE>, operands[1], operands[2],\n+\t\t\t operands[0], NULL, operands[3]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn_and_split \"sync_old_nand<mode>\"\n+  [(set (match_operand:I48MODE 0 \"register_operand\" \"=&r\")\n+\t(match_operand:I48MODE 1 \"memory_operand\" \"+m\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:I48MODE\n+\t  [(and:I48MODE\n+\t     (not:I48MODE\n+\t       (match_operand:I48MODE 2 \"reg_or_8bit_operand\" \"rI\"))\n+\t     (match_dup 1))]\n+\t  UNSPECV_ATOMIC))\n+   (clobber (match_scratch:I48MODE 3 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  alpha_split_atomic_op (NOT, operands[1], operands[2],\n+\t\t\t operands[0], NULL, operands[3]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn_and_split \"sync_new_<fetchop_name><mode>\"\n+  [(set (match_operand:I48MODE 0 \"register_operand\" \"=&r\")\n+\t(FETCHOP:I48MODE \n+\t  (match_operand:I48MODE 1 \"memory_operand\" \"+m\")\n+\t  (match_operand:I48MODE 2 \"<fetchop_pred>\" \"<fetchop_constr>\")))\n+   (set (match_dup 1)\n+\t(unspec_volatile:I48MODE\n+\t  [(FETCHOP:I48MODE (match_dup 1) (match_dup 2))]\n+\t  UNSPECV_ATOMIC))\n+   (clobber (match_scratch:I48MODE 3 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  alpha_split_atomic_op (<CODE>, operands[1], operands[2],\n+\t\t\t NULL, operands[0], operands[3]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn_and_split \"sync_new_nand<mode>\"\n+  [(set (match_operand:I48MODE 0 \"register_operand\" \"=&r\")\n+\t(and:I48MODE \n+\t  (not:I48MODE\n+\t    (match_operand:I48MODE 2 \"reg_or_8bit_operand\" \"rI\"))\n+\t  (match_operand:I48MODE 1 \"memory_operand\" \"+m\")))\n+   (set (match_dup 1)\n+\t(unspec_volatile:I48MODE\n+\t  [(and:I48MODE (not:I48MODE (match_dup 2)) (match_dup 1))]\n+\t  UNSPECV_ATOMIC))\n+   (clobber (match_scratch:I48MODE 3 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  alpha_split_atomic_op (NOT, operands[1], operands[2],\n+\t\t\t NULL, operands[0], operands[3]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_expand \"sync_compare_and_swap<mode>\"\n+  [(parallel\n+     [(set (match_operand:I48MODE 0 \"register_operand\" \"\")\n+\t   (match_operand:I48MODE 1 \"memory_operand\" \"\"))\n+      (set (match_dup 1)\n+\t   (unspec_volatile:I48MODE\n+\t     [(match_operand:I48MODE 2 \"reg_or_8bit_operand\" \"\")\n+\t      (match_operand:I48MODE 3 \"add_operand\" \"rKL\")]\n+\t     UNSPECV_CMPXCHG))\n+      (clobber (match_scratch:I48MODE 4 \"=&r\"))])]\n+  \"\"\n+{\n+  if (<MODE>mode == SImode)\n+    operands[2] = convert_modes (DImode, SImode, operands[2], 0);\n+})\n+\n+(define_insn_and_split \"*sync_compare_and_swap<mode>\"\n+  [(set (match_operand:I48MODE 0 \"register_operand\" \"=&r\")\n+\t(match_operand:I48MODE 1 \"memory_operand\" \"+m\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:I48MODE\n+\t  [(match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n+\t   (match_operand:I48MODE 3 \"add_operand\" \"rKL\")]\n+\t  UNSPECV_CMPXCHG))\n+   (clobber (match_scratch:I48MODE 4 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx retval, mem, oldval, newval, scratch;\n+  rtx cond, label1, label2, x;\n+  rtx very_unlikely = GEN_INT (REG_BR_PROB_BASE / 100 - 1);\n+\n+  retval = operands[0];\n+  mem = operands[1];\n+  oldval = operands[2];\n+  newval = operands[3];\n+  scratch = operands[4];\n+  cond = gen_lowpart (DImode, scratch);\n+\n+  emit_insn (gen_memory_barrier ());\n+\n+  label1 = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n+  label2 = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n+  emit_label (XEXP (label1, 0));\n+\n+  emit_insn (gen_load_locked_<mode> (retval, mem));\n+\n+  x = gen_lowpart (DImode, retval);\n+  x = gen_rtx_EQ (DImode, x, oldval);\n+  if (oldval != const0_rtx)\n+    {\n+      emit_insn (gen_rtx_SET (VOIDmode, cond, x));\n+      x = gen_rtx_EQ (DImode, cond, const0_rtx);\n+    }\n+  x = gen_rtx_IF_THEN_ELSE (VOIDmode, x, label2, pc_rtx);\n+  x = emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, x));\n+  REG_NOTES (x) = gen_rtx_EXPR_LIST (REG_BR_PROB, very_unlikely, NULL_RTX);\n+    \n+  emit_move_insn (scratch, newval);\n+  emit_move_insn (retval, newval);\n+  \n+  emit_insn (gen_store_conditional_<mode> (cond, mem, scratch));\n+\n+  x = gen_rtx_EQ (DImode, cond, const0_rtx);\n+  x = gen_rtx_IF_THEN_ELSE (VOIDmode, x, label1, pc_rtx);\n+  x = emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, x));\n+  REG_NOTES (x) = gen_rtx_EXPR_LIST (REG_BR_PROB, very_unlikely, NULL_RTX);\n+\n+  emit_label (XEXP (label2, 0));\n+  emit_insn (gen_memory_barrier ());\n+  DONE;\n+}\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn_and_split \"sync_lock_test_and_set<mode>\"\n+  [(set (match_operand:I48MODE 0 \"register_operand\" \"=&r\")\n+\t(match_operand:I48MODE 1 \"memory_operand\" \"+m\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:I48MODE\n+\t  [(match_operand:I48MODE 2 \"add_operand\" \"rKL\")]\n+\t  UNSPECV_XCHG))\n+   (clobber (match_scratch:I48MODE 3 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx retval, mem, val, scratch;\n+  rtx cond, label1, label2, x;\n+  rtx very_unlikely = GEN_INT (REG_BR_PROB_BASE / 100 - 1);\n+\n+  retval = operands[0];\n+  mem = operands[1];\n+  val = operands[2];\n+  scratch = operands[3];\n+  cond = gen_lowpart (DImode, scratch);\n+\n+  emit_insn (gen_memory_barrier ());\n+\n+  label1 = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n+  label2 = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n+  emit_label (XEXP (label1, 0));\n+\n+  emit_insn (gen_load_locked_<mode> (retval, mem));\n+\n+  emit_move_insn (scratch, val);\n+  \n+  emit_insn (gen_store_conditional_<mode> (cond, mem, scratch));\n+\n+  x = gen_rtx_EQ (DImode, cond, const0_rtx);\n+  x = gen_rtx_IF_THEN_ELSE (VOIDmode, x, label1, pc_rtx);\n+  x = emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, x));\n+  REG_NOTES (x) = gen_rtx_EXPR_LIST (REG_BR_PROB, very_unlikely, NULL_RTX);\n+\n+  emit_label (XEXP (label2, 0));\n+  emit_insn (gen_memory_barrier ());\n+  DONE;\n+}\n+  [(set_attr \"type\" \"multi\")])"}]}