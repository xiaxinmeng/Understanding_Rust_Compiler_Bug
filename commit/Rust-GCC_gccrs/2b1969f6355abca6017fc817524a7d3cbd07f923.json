{"sha": "2b1969f6355abca6017fc817524a7d3cbd07f923", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmIxOTY5ZjYzNTVhYmNhNjAxN2ZjODE3NTI0YTdkM2NiZDA3ZjkyMw==", "commit": {"author": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2018-08-11T21:37:55Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2018-08-11T21:37:55Z"}, "message": "pa.md (UNSPEC_MEMORY_BARRIER): New unspec enum.\n\n\tgcc\n\t* config/pa/pa.md (UNSPEC_MEMORY_BARRIER): New unspec enum.\n\tUpdate comment for atomic instructions.\n\t(atomic_storeqi, atomic_storehi, atomic_storesi, atomic_storesf,\n\tatomic_loaddf, atomic_loaddf_1, atomic_storedf, atomic_storedf_1):\n\tRemove.\n\t(atomic_loaddi): Revise fence expansion to only emit fence prior to\n\tload for __ATOMIC_SEQ_CST model.\n\t(atomic_loaddi_1): Remove float register target.\n\t(atomic_storedi): Handle CONST_INT values.\n\t(atomic_storedi_1): Remove float register source.  Add special case\n\tfor zero value.\n\t(memory_barrier): New expander and insn.\n\n\tlibgcc\n\t* config/pa/linux-atomic.c: Update comment.\n\t(FETCH_AND_OP_2, OP_AND_FETCH_2, FETCH_AND_OP_WORD, OP_AND_FETCH_WORD,\n\tCOMPARE_AND_SWAP_2, __sync_val_compare_and_swap_4,\n\tSYNC_LOCK_TEST_AND_SET_2, __sync_lock_test_and_set_4): Use\n\t__ATOMIC_RELAXED for atomic loads.\n\t(SYNC_LOCK_RELEASE_1): New define.  Use __sync_synchronize() and\n\tunordered store to release lock.\n\t(__sync_lock_release_8): Likewise.\n\t(SYNC_LOCK_RELEASE_2): Remove define.\n\nFrom-SVN: r263488", "tree": {"sha": "b4b1cc592f57238dd537334771852b2a8d3c05eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4b1cc592f57238dd537334771852b2a8d3c05eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b1969f6355abca6017fc817524a7d3cbd07f923", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b1969f6355abca6017fc817524a7d3cbd07f923", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b1969f6355abca6017fc817524a7d3cbd07f923", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b1969f6355abca6017fc817524a7d3cbd07f923/comments", "author": null, "committer": null, "parents": [{"sha": "8be591a9cd557be85e591a0362d220d84c296bd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8be591a9cd557be85e591a0362d220d84c296bd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8be591a9cd557be85e591a0362d220d84c296bd4"}], "stats": {"total": 290, "additions": 84, "deletions": 206}, "files": [{"sha": "c669cadfec53ccd40bf668d6e4fedd5092d65f52", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1969f6355abca6017fc817524a7d3cbd07f923/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1969f6355abca6017fc817524a7d3cbd07f923/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b1969f6355abca6017fc817524a7d3cbd07f923", "patch": "@@ -1,3 +1,18 @@\n+2018-08-11  John David Anglin  <danglin@gcc.gnu.org>\n+\n+\t* config/pa/pa.md (UNSPEC_MEMORY_BARRIER): New unspec enum.\n+\tUpdate comment for atomic instructions.\n+\t(atomic_storeqi, atomic_storehi, atomic_storesi, atomic_storesf,\n+\tatomic_loaddf, atomic_loaddf_1, atomic_storedf, atomic_storedf_1):\n+\tRemove.\n+\t(atomic_loaddi): Revise fence expansion to only emit fence prior to\n+\tload for __ATOMIC_SEQ_CST model.\n+\t(atomic_loaddi_1): Remove float register target.\n+\t(atomic_storedi): Handle CONST_INT values.\n+\t(atomic_storedi_1): Remove float register source.  Add special case\n+\tfor zero value.\n+\t(memory_barrier): New expander and insn.\n+\n 2018-08-11  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/86835"}, {"sha": "0094c58f5e4f097ca4f24ed424c11866e0a131fb", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 30, "deletions": 167, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1969f6355abca6017fc817524a7d3cbd07f923/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1969f6355abca6017fc817524a7d3cbd07f923/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=2b1969f6355abca6017fc817524a7d3cbd07f923", "patch": "@@ -84,6 +84,7 @@\n    UNSPEC_TLSGD_PIC\n    UNSPEC_TLSLDM_PIC\n    UNSPEC_TLSIE_PIC\n+   UNSPEC_MEMORY_BARRIER\n   ])\n \n ;; UNSPEC_VOLATILE:\n@@ -9955,84 +9956,8 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n ;; doubleword loads and stores are not guaranteed to be atomic\n ;; when referencing the I/O address space.\n \n-;; The kernel cmpxchg operation on linux is not atomic with respect to\n-;; memory stores on SMP machines, so we must do stores using a cmpxchg\n-;; operation.\n-\n ;; These patterns are at the bottom so the non atomic versions are preferred.\n \n-;; Implement atomic QImode store using exchange.\n-\n-(define_expand \"atomic_storeqi\"\n-  [(match_operand:QI 0 \"memory_operand\")                ;; memory\n-   (match_operand:QI 1 \"register_operand\")              ;; val out\n-   (match_operand:SI 2 \"const_int_operand\")]            ;; model\n-  \"\"\n-{\n-  if (TARGET_SYNC_LIBCALL)\n-    {\n-      rtx mem = operands[0];\n-      rtx val = operands[1];\n-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))\n-\tDONE;\n-    }\n-  FAIL;\n-})\n-\n-;; Implement atomic HImode stores using exchange.\n-\n-(define_expand \"atomic_storehi\"\n-  [(match_operand:HI 0 \"memory_operand\")                ;; memory\n-   (match_operand:HI 1 \"register_operand\")              ;; val out\n-   (match_operand:SI 2 \"const_int_operand\")]            ;; model\n-  \"\"\n-{\n-  if (TARGET_SYNC_LIBCALL)\n-    {\n-      rtx mem = operands[0];\n-      rtx val = operands[1];\n-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))\n-\tDONE;\n-    }\n-  FAIL;\n-})\n-\n-;; Implement atomic SImode store using exchange.\n-\n-(define_expand \"atomic_storesi\"\n-  [(match_operand:SI 0 \"memory_operand\")                ;; memory\n-   (match_operand:SI 1 \"register_operand\")              ;; val out\n-   (match_operand:SI 2 \"const_int_operand\")]            ;; model\n-  \"\"\n-{\n-  if (TARGET_SYNC_LIBCALL)\n-    {\n-      rtx mem = operands[0];\n-      rtx val = operands[1];\n-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))\n-\tDONE;\n-    }\n-  FAIL;\n-})\n-\n-;; Implement atomic SFmode store using exchange.\n-\n-(define_expand \"atomic_storesf\"\n-  [(match_operand:SF 0 \"memory_operand\")                ;; memory\n-   (match_operand:SF 1 \"register_operand\")              ;; val out\n-   (match_operand:SI 2 \"const_int_operand\")]            ;; model\n-  \"\"\n-{\n-  if (TARGET_SYNC_LIBCALL)\n-    {\n-      rtx mem = operands[0];\n-      rtx val = operands[1];\n-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))\n-\tDONE;\n-    }\n-  FAIL;\n-})\n-\n ;; Implement atomic DImode load using 64-bit floating point load.\n \n (define_expand \"atomic_loaddi\"\n@@ -10048,47 +9973,39 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \n   model = memmodel_from_int (INTVAL (operands[2]));\n   operands[1] = force_reg (SImode, XEXP (operands[1], 0));\n-  expand_mem_thread_fence (model);\n-  emit_insn (gen_atomic_loaddi_1 (operands[0], operands[1]));\n   if (is_mm_seq_cst (model))\n     expand_mem_thread_fence (model);\n+  emit_insn (gen_atomic_loaddi_1 (operands[0], operands[1]));\n+  expand_mem_thread_fence (model);\n   DONE;\n })\n \n (define_insn \"atomic_loaddi_1\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=f,r\")\n-        (mem:DI (match_operand:SI 1 \"register_operand\" \"r,r\")))\n-   (clobber (match_scratch:DI 2 \"=X,f\"))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (mem:DI (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (clobber (match_scratch:DI 2 \"=f\"))]\n   \"!TARGET_64BIT && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT\"\n-  \"@\n-   {fldds|fldd} 0(%1),%0\n-   {fldds|fldd} 0(%1),%2\\n\\t{fstds|fstd} %2,-16(%%sp)\\n\\t{ldws|ldw} -16(%%sp),%0\\n\\t{ldws|ldw} -12(%%sp),%R0\"\n-  [(set_attr \"type\" \"move,move\")\n-   (set_attr \"length\" \"4,16\")])\n+  \"{fldds|fldd} 0(%1),%2\\n\\t{fstds|fstd} %2,-16(%%sp)\\n\\t{ldws|ldw} -16(%%sp),%0\\n\\t{ldws|ldw} -12(%%sp),%R0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"16\")])\n \n ;; Implement atomic DImode store.\n \n (define_expand \"atomic_storedi\"\n   [(match_operand:DI 0 \"memory_operand\")                ;; memory\n-   (match_operand:DI 1 \"register_operand\")              ;; val out\n+   (match_operand:DI 1 \"reg_or_cint_move_operand\")      ;; val out\n    (match_operand:SI 2 \"const_int_operand\")]            ;; model\n   \"\"\n {\n   enum memmodel model;\n \n-  if (TARGET_SYNC_LIBCALL)\n-    {\n-      rtx mem = operands[0];\n-      rtx val = operands[1];\n-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))\n-\tDONE;\n-    }\n-\n   if (TARGET_64BIT || TARGET_DISABLE_FPREGS || TARGET_SOFT_FLOAT)\n     FAIL;\n \n   model = memmodel_from_int (INTVAL (operands[2]));\n   operands[0] = force_reg (SImode, XEXP (operands[0], 0));\n+  if (operands[1] != CONST0_RTX (DImode))\n+    operands[1] = force_reg (DImode, operands[1]);\n   expand_mem_thread_fence (model);\n   emit_insn (gen_atomic_storedi_1 (operands[0], operands[1]));\n   if (is_mm_seq_cst (model))\n@@ -10098,87 +10015,33 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \n (define_insn \"atomic_storedi_1\"\n   [(set (mem:DI (match_operand:SI 0 \"register_operand\" \"r,r\"))\n-        (match_operand:DI 1 \"register_operand\" \"f,r\"))\n+        (match_operand:DI 1 \"reg_or_0_operand\" \"M,r\"))\n    (clobber (match_scratch:DI 2 \"=X,f\"))]\n-  \"!TARGET_64BIT && !TARGET_DISABLE_FPREGS\n-   && !TARGET_SOFT_FLOAT && !TARGET_SYNC_LIBCALL\"\n+  \"!TARGET_64BIT && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT\"\n   \"@\n-   {fstds|fstd} %1,0(%0)\n+   {fstds|fstd} %%fr0,0(%0)\n    {stws|stw} %1,-16(%%sp)\\n\\t{stws|stw} %R1,-12(%%sp)\\n\\t{fldds|fldd} -16(%%sp),%2\\n\\t{fstds|fstd} %2,0(%0)\"\n   [(set_attr \"type\" \"move,move\")\n    (set_attr \"length\" \"4,16\")])\n \n-;; Implement atomic DFmode load using 64-bit floating point load.\n+;; PA 2.0 hardware supports out-of-order execution of loads and stores, so\n+;; we need a memory barrier to enforce program order for memory references.\n+;; Since we want PA 1.x code to be PA 2.0 compatible, we also need the\n+;; barrier when generating PA 1.x code.\n \n-(define_expand \"atomic_loaddf\"\n-  [(match_operand:DF 0 \"register_operand\")              ;; val out\n-   (match_operand:DF 1 \"memory_operand\")                ;; memory\n-   (match_operand:SI 2 \"const_int_operand\")]            ;; model\n+(define_expand \"memory_barrier\"\n+  [(set (match_dup 0)\n+        (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))]\n   \"\"\n {\n-  enum memmodel model;\n-\n-  if (TARGET_64BIT || TARGET_DISABLE_FPREGS || TARGET_SOFT_FLOAT)\n-    FAIL;\n-\n-  model = memmodel_from_int (INTVAL (operands[2]));\n-  operands[1] = force_reg (SImode, XEXP (operands[1], 0));\n-  expand_mem_thread_fence (model);\n-  emit_insn (gen_atomic_loaddf_1 (operands[0], operands[1]));\n-  if (is_mm_seq_cst (model))\n-    expand_mem_thread_fence (model);\n-  DONE;\n+  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));\n+  MEM_VOLATILE_P (operands[0]) = 1;\n })\n \n-(define_insn \"atomic_loaddf_1\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f,r\")\n-        (mem:DF (match_operand:SI 1 \"register_operand\" \"r,r\")))\n-   (clobber (match_scratch:DF 2 \"=X,f\"))]\n-  \"!TARGET_64BIT && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT\"\n-  \"@\n-   {fldds|fldd} 0(%1),%0\n-   {fldds|fldd} 0(%1),%2\\n\\t{fstds|fstd} %2,-16(%%sp)\\n\\t{ldws|ldw} -16(%%sp),%0\\n\\t{ldws|ldw} -12(%%sp),%R0\"\n-  [(set_attr \"type\" \"move,move\")\n-   (set_attr \"length\" \"4,16\")])\n-\n-;; Implement atomic DFmode store using 64-bit floating point store.\n-\n-(define_expand \"atomic_storedf\"\n-  [(match_operand:DF 0 \"memory_operand\")                ;; memory\n-   (match_operand:DF 1 \"register_operand\")              ;; val out\n-   (match_operand:SI 2 \"const_int_operand\")]            ;; model\n+(define_insn \"*memory_barrier\"\n+  [(set (match_operand:BLK 0 \"\" \"\")\n+        (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))]\n   \"\"\n-{\n-  enum memmodel model;\n-\n-  if (TARGET_SYNC_LIBCALL)\n-    {\n-      rtx mem = operands[0];\n-      rtx val = operands[1];\n-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))\n-\tDONE;\n-    }\n-\n-  if (TARGET_64BIT || TARGET_DISABLE_FPREGS || TARGET_SOFT_FLOAT)\n-    FAIL;\n-\n-  model = memmodel_from_int (INTVAL (operands[2]));\n-  operands[0] = force_reg (SImode, XEXP (operands[0], 0));\n-  expand_mem_thread_fence (model);\n-  emit_insn (gen_atomic_storedf_1 (operands[0], operands[1]));\n-  if (is_mm_seq_cst (model))\n-    expand_mem_thread_fence (model);\n-  DONE;\n-})\n-\n-(define_insn \"atomic_storedf_1\"\n-  [(set (mem:DF (match_operand:SI 0 \"register_operand\" \"r,r\"))\n-        (match_operand:DF 1 \"register_operand\" \"f,r\"))\n-   (clobber (match_scratch:DF 2 \"=X,f\"))]\n-  \"!TARGET_64BIT && !TARGET_DISABLE_FPREGS\n-   && !TARGET_SOFT_FLOAT && !TARGET_SYNC_LIBCALL\"\n-  \"@\n-   {fstds|fstd} %1,0(%0)\n-   {stws|stw} %1,-16(%%sp)\\n\\t{stws|stw} %R1,-12(%%sp)\\n\\t{fldds|fldd} -16(%%sp),%2\\n\\t{fstds|fstd} %2,0(%0)\"\n-  [(set_attr \"type\" \"move,move\")\n-   (set_attr \"length\" \"4,16\")])\n+  \"sync\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"4\")])"}, {"sha": "084131abd0442d90c7221fa38616818b035367b0", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1969f6355abca6017fc817524a7d3cbd07f923/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1969f6355abca6017fc817524a7d3cbd07f923/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=2b1969f6355abca6017fc817524a7d3cbd07f923", "patch": "@@ -1,3 +1,15 @@\n+2018-08-11  John David Anglin  <danglin@gcc.gnu.org>\n+\n+\t* config/pa/linux-atomic.c: Update comment.\n+\t(FETCH_AND_OP_2, OP_AND_FETCH_2, FETCH_AND_OP_WORD, OP_AND_FETCH_WORD,\n+\tCOMPARE_AND_SWAP_2, __sync_val_compare_and_swap_4,\n+\tSYNC_LOCK_TEST_AND_SET_2, __sync_lock_test_and_set_4): Use\n+\t__ATOMIC_RELAXED for atomic loads.\n+\t(SYNC_LOCK_RELEASE_1): New define.  Use __sync_synchronize() and\n+\tunordered store to release lock.\n+\t(__sync_lock_release_8): Likewise.\n+\t(SYNC_LOCK_RELEASE_2): Remove define.\n+\t \n 2018-08-02  Nicolas Pitre <nico@fluxnic.net>\n \n \tPR libgcc/86512"}, {"sha": "ddd0b1e9708172fd14ba10c736e4b74dcd45a5d5", "filename": "libgcc/config/pa/linux-atomic.c", "status": "modified", "additions": 27, "deletions": 39, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b1969f6355abca6017fc817524a7d3cbd07f923/libgcc%2Fconfig%2Fpa%2Flinux-atomic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b1969f6355abca6017fc817524a7d3cbd07f923/libgcc%2Fconfig%2Fpa%2Flinux-atomic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fpa%2Flinux-atomic.c?ref=2b1969f6355abca6017fc817524a7d3cbd07f923", "patch": "@@ -28,14 +28,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define EBUSY   16\n #define ENOSYS 251 \n \n-/* All PA-RISC implementations supported by linux have strongly\n-   ordered loads and stores.  Only cache flushes and purges can be\n-   delayed.  The data cache implementations are all globally\n-   coherent.  Thus, there is no need to synchonize memory accesses.\n-\n-   GCC automatically issues a asm memory barrier when it encounters\n-   a __sync_synchronize builtin.  Thus, we do not need to define this\n-   builtin.\n+/* PA-RISC 2.0 supports out-of-order execution for loads and stores.\n+   Thus, we need to synchonize memory accesses.  For more info, see:\n+   \"Advanced Performance Features of the 64-bit PA-8000\" by Doug Hunt.\n \n    We implement byte, short and int versions of each atomic operation\n    using the kernel helper defined below.  There is no support for\n@@ -119,7 +114,7 @@ __kernel_cmpxchg2 (void *mem, const void *oldval, const void *newval,\n     long failure;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     do {\t\t\t\t\t\t\t\t\\\n-      tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);\t\t\t\\\n+      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);\t\t\t\\\n       newval = PFX_OP (tmp INF_OP val);\t\t\t\t\t\\\n       failure = __kernel_cmpxchg2 (ptr, &tmp, &newval, INDEX);\t\t\\\n     } while (failure != 0);\t\t\t\t\t\t\\\n@@ -156,7 +151,7 @@ FETCH_AND_OP_2 (nand, ~, &, signed char, 1, 0)\n     long failure;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     do {\t\t\t\t\t\t\t\t\\\n-      tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);\t\t\t\\\n+      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);\t\t\t\\\n       newval = PFX_OP (tmp INF_OP val);\t\t\t\t\t\\\n       failure = __kernel_cmpxchg2 (ptr, &tmp, &newval, INDEX);\t\t\\\n     } while (failure != 0);\t\t\t\t\t\t\\\n@@ -193,7 +188,7 @@ OP_AND_FETCH_2 (nand, ~, &, signed char, 1, 0)\n     long failure;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     do {\t\t\t\t\t\t\t\t\\\n-      tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);\t\t\t\\\n+      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);\t\t\t\\\n       failure = __kernel_cmpxchg (ptr, tmp, PFX_OP (tmp INF_OP val));\t\\\n     } while (failure != 0);\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n@@ -215,7 +210,7 @@ FETCH_AND_OP_WORD (nand, ~, &)\n     long failure;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     do {\t\t\t\t\t\t\t\t\\\n-      tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);\t\t\t\\\n+      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);\t\t\t\\\n       failure = __kernel_cmpxchg (ptr, tmp, PFX_OP (tmp INF_OP val));\t\\\n     } while (failure != 0);\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n@@ -241,7 +236,7 @@ typedef unsigned char bool;\n \t\t\t\t\t\t\t\t\t\\\n     while (1)\t\t\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n-\tactual_oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);\t\\\n+\tactual_oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);\t\\\n \t\t\t\t\t\t\t\t\t\\\n \tif (__builtin_expect (oldval != actual_oldval, 0))\t\t\\\n \t  return actual_oldval;\t\t\t\t\t\t\\\n@@ -273,7 +268,7 @@ __sync_val_compare_and_swap_4 (int *ptr, int oldval, int newval)\n     \n   while (1)\n     {\n-      actual_oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);\n+      actual_oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);\n \n       if (__builtin_expect (oldval != actual_oldval, 0))\n \treturn actual_oldval;\n@@ -300,7 +295,7 @@ TYPE HIDDEN\t\t\t\t\t\t\t\t\\\n     long failure;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     do {\t\t\t\t\t\t\t\t\\\n-      oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);\t\t\t\\\n+      oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);\t\t\t\\\n       failure = __kernel_cmpxchg2 (ptr, &oldval, &val, INDEX);\t\t\\\n     } while (failure != 0);\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n@@ -318,38 +313,31 @@ __sync_lock_test_and_set_4 (int *ptr, int val)\n   int oldval;\n \n   do {\n-    oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);\n+    oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);\n     failure = __kernel_cmpxchg (ptr, oldval, val);\n   } while (failure != 0);\n \n   return oldval;\n }\n \n-#define SYNC_LOCK_RELEASE_2(TYPE, WIDTH, INDEX)\t\t\t\\\n+void HIDDEN\n+__sync_lock_release_8 (long long *ptr)\n+{\n+  /* All accesses must be complete before we release the lock.  */\n+  __sync_synchronize ();\n+  *(double *)ptr = 0;\n+}\n+\n+#define SYNC_LOCK_RELEASE_1(TYPE, WIDTH)\t\t\t\\\n   void HIDDEN\t\t\t\t\t\t\t\\\n   __sync_lock_release_##WIDTH (TYPE *ptr)\t\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n-    TYPE oldval, zero = 0;\t\t\t\t\t\\\n-    long failure;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-    do {\t\t\t\t\t\t\t\\\n-      oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);\t\t\\\n-      failure = __kernel_cmpxchg2 (ptr, &oldval, &zero, INDEX);\t\\\n-    } while (failure != 0);\t\t\t\t\t\\\n+    /* All accesses must be complete before we release\t\t\\\n+       the lock.  */\t\t\t\t\t\t\\\n+    __sync_synchronize ();\t\t\t\t\t\\\n+    *ptr = 0;\t\t\t\t\t\t\t\\\n   }\n \n-SYNC_LOCK_RELEASE_2 (long long, 8, 3)\n-SYNC_LOCK_RELEASE_2 (short, 2, 1)\n-SYNC_LOCK_RELEASE_2 (signed char, 1, 0)\n-\n-void HIDDEN\n-__sync_lock_release_4 (int *ptr)\n-{\n-  long failure;\n-  int oldval;\n-\n-  do {\n-    oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);\n-    failure = __kernel_cmpxchg (ptr, oldval, 0);\n-  } while (failure != 0);\n-}\n+SYNC_LOCK_RELEASE_1 (int, 4)\n+SYNC_LOCK_RELEASE_1 (short, 2)\n+SYNC_LOCK_RELEASE_1 (signed char, 1)"}]}