{"sha": "45a647bee982216e27536ea8f9a23389c1a15369", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVhNjQ3YmVlOTgyMjE2ZTI3NTM2ZWE4ZjlhMjMzODljMWExNTM2OQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2001-03-12T02:37:56Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2001-03-12T02:37:56Z"}, "message": "mips-tfile.c: Cast arg to PTR when specifier is HOST_PTR_PRINTF.\n\n\t* mips-tfile.c: Cast arg to PTR when specifier is HOST_PTR_PRINTF.\n\t(__proto, PTR_T, CPTR_T): Delete, use PARAMS/PTR instead.\n\t(local_index, local_rindex): Delete, use strchr/strrchr instead.\n\t(copy_object): Fix format specifier vs argument mismatch.\n\n\t* mips-tdump.c: Make local functions static.\n\t(rindex): Don't #undef.\n\t(__proto, PTR_T, CPTR_T): Delete, use PARAMS/PTR instead.\n\t(fatal, fancy_abort): Delete.\n\t(read_seek): Avoid signed/unsigned compare.\n\nFrom-SVN: r40391", "tree": {"sha": "5156260a027e6de15817a1c12ce4d7f0e5eac149", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5156260a027e6de15817a1c12ce4d7f0e5eac149"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45a647bee982216e27536ea8f9a23389c1a15369", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45a647bee982216e27536ea8f9a23389c1a15369", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45a647bee982216e27536ea8f9a23389c1a15369", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45a647bee982216e27536ea8f9a23389c1a15369/comments", "author": null, "committer": null, "parents": [{"sha": "c7ca5912e35ee202df6d4ab8036e8d1671221f5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7ca5912e35ee202df6d4ab8036e8d1671221f5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7ca5912e35ee202df6d4ab8036e8d1671221f5c"}], "stats": {"total": 390, "additions": 163, "deletions": 227}, "files": [{"sha": "1d0db81bbed4bde56c5fdac25a63733168f19c8b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a647bee982216e27536ea8f9a23389c1a15369/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a647bee982216e27536ea8f9a23389c1a15369/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=45a647bee982216e27536ea8f9a23389c1a15369", "patch": "@@ -1,3 +1,16 @@\n+2001-03-11  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* mips-tfile.c: Cast arg to PTR when specifier is HOST_PTR_PRINTF.\n+\t(__proto, PTR_T, CPTR_T): Delete, use PARAMS/PTR instead.\n+\t(local_index, local_rindex): Delete, use strchr/strrchr instead.\n+\t(copy_object): Fix format specifier vs argument mismatch.\n+\n+\t* mips-tdump.c: Make local functions static.\n+\t(rindex): Don't #undef.\n+\t(__proto, PTR_T, CPTR_T): Delete, use PARAMS/PTR instead.\n+\t(fatal, fancy_abort): Delete.\n+\t(read_seek): Avoid signed/unsigned compare.\n+\n Sun Mar 11 17:01:41 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* combine.c (try_combine): Fix error in change to try original"}, {"sha": "b199468c31d42a1a16ef0f9c2ff202d35e1b3857", "filename": "gcc/mips-tdump.c", "status": "modified", "additions": 48, "deletions": 78, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a647bee982216e27536ea8f9a23389c1a15369/gcc%2Fmips-tdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a647bee982216e27536ea8f9a23389c1a15369/gcc%2Fmips-tdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tdump.c?ref=45a647bee982216e27536ea8f9a23389c1a15369", "patch": "@@ -25,7 +25,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #ifdef index\n #undef index\n-#undef rindex\n #endif\n #ifndef CROSS_COMPILE\n #include <a.out.h>\n@@ -47,34 +46,11 @@ Boston, MA 02111-1307, USA.  */\n #define MIPS_UNMARK_STAB(code) ((code)-CODE_MASK)\n #endif\n \n-#define __proto(x) PARAMS(x)\n-typedef PTR PTR_T;\n-typedef const PTR_T CPTR_T;\n-\n #define uchar\tunsigned char\n #define ushort\tunsigned short\n #define uint\tunsigned int\n #define ulong\tunsigned long\n \n-void fatal PARAMS ((const char *)) ATTRIBUTE_NORETURN;\n-void fancy_abort PARAMS ((void)) ATTRIBUTE_NORETURN;\n-  \n-void\n-fatal (s)\n-  const char *s;\n-{\n-  fprintf (stderr, \"%s\\n\", s);\n-  exit (FATAL_EXIT_CODE);\n-}\n-\n-/* Due to size_t being defined in sys/types.h and different\n-   in stddef.h, we have to do this by hand.....  Note, these\n-   types are correct for MIPS based systems, and may not be\n-   correct for other systems.  */\n-\n-#define size_t\t\tuint\n-#define ptrdiff_t\tint\n-\n \f\n /* Redefinition of storage classes as an enumeration for better\n    debugging.  */\n@@ -250,19 +226,19 @@ ulong\t*rfile_desc;\t\t/* relative file tables */\n PDR\t*proc_desc;\t\t/* procedure tables */\n \n /* Forward reference for functions.  */\n-PTR_T read_seek\t\t__proto((PTR_T, size_t, off_t, const char *));\n-void  read_tfile\t__proto((void));\n-void  print_global_hdr\t__proto((struct filehdr *));\n-void  print_sym_hdr\t__proto((HDRR *));\n-void  print_file_desc\t__proto((FDR *, int));\n-void  print_symbol\t__proto((SYMR *, int, char *, AUXU *, int, FDR *));\n-void  print_aux\t\t__proto((AUXU, int, int));\n-void  emit_aggregate\t__proto((char *, AUXU, AUXU, const char *, FDR *));\n-const char *st_to_string\t__proto((st_t));\n-const char *sc_to_string\t__proto((sc_t));\n-const char *glevel_to_string\t__proto((glevel_t));\n-const char *lang_to_string\t__proto((lang_t));\n-const char *type_to_string\t__proto((AUXU *, int, FDR *));\n+static PTR read_seek\t\t\tPARAMS ((PTR, size_t, off_t, const char *));\n+static void read_tfile\t\t\tPARAMS ((void));\n+static void print_global_hdr\t\tPARAMS ((struct filehdr *));\n+static void print_sym_hdr\t\tPARAMS ((HDRR *));\n+static void print_file_desc\t\tPARAMS ((FDR *, int));\n+static void print_symbol\t\tPARAMS ((SYMR *, int, const char *, AUXU *, int, FDR *));\n+static void print_aux\t\t\tPARAMS ((AUXU, int, int));\n+static void emit_aggregate\t\tPARAMS ((char *, AUXU, AUXU, const char *, FDR *));\n+static const char *st_to_string\t\tPARAMS ((st_t));\n+static const char *sc_to_string\t\tPARAMS ((sc_t));\n+static const char *glevel_to_string\tPARAMS ((glevel_t));\n+static const char *lang_to_string\tPARAMS ((lang_t));\n+static const char *type_to_string\tPARAMS ((AUXU *, int, FDR *));\n \n extern char *optarg;\n extern int   optind;\n@@ -279,9 +255,9 @@ struct {short code; char string[10];} stab_names[]  = {\n \f\n /* Read some bytes at a specified location, and return a pointer.  */\n \n-PTR_T\n+static PTR\n read_seek (ptr, size, offset, context)\n-     PTR_T ptr;\t\t\t/* pointer to buffer or NULL */\n+     PTR ptr;\t\t\t/* pointer to buffer or NULL */\n      size_t size;\t\t/* # bytes to read */\n      off_t offset;\t\t/* offset to read at */\n      const char *context;\t/* context for error message */\n@@ -291,15 +267,17 @@ read_seek (ptr, size, offset, context)\n   if (size == 0)\t\t/* nothing to read */\n     return ptr;\n \n-  if ((ptr == (PTR_T) 0 && (ptr = xmalloc (size)) == (PTR_T) 0)\n-      || (tfile_offset != offset && lseek (tfile_fd, offset, 0) == -1)\n+  if (!ptr)\n+    ptr = xmalloc (size);\n+\n+  if ((tfile_offset != offset && lseek (tfile_fd, offset, 0) == -1)\n       || (read_size = read (tfile_fd, ptr, size)) < 0)\n     {\n       perror (context);\n       exit (1);\n     }\n \n-  if (read_size != size)\n+  if (read_size != (long) size)\n     {\n       fprintf (stderr, \"%s: read %ld bytes, expected %ld bytes\\n\",\n \t       context, read_size, (long) size);\n@@ -313,7 +291,7 @@ read_seek (ptr, size, offset, context)\n \f\n /* Convert language code to string format.  */\n \n-const char *\n+static const char *\n lang_to_string (lang)\n      lang_t lang;\n {\n@@ -336,7 +314,7 @@ lang_to_string (lang)\n \f\n /* Convert storage class to string.  */\n \n-const char *\n+static const char *\n sc_to_string(storage_class)\n      sc_t storage_class;\n {\n@@ -374,7 +352,7 @@ sc_to_string(storage_class)\n \f\n /* Convert symbol type to string.  */\n \n-const char *\n+static const char *\n st_to_string(symbol_type)\n      st_t symbol_type;\n {\n@@ -415,7 +393,7 @@ st_to_string(symbol_type)\n \f\n /* Convert debug level to string.  */\n \n-const char *\n+static const char *\n glevel_to_string (g_level)\n      glevel_t g_level;\n {\n@@ -433,7 +411,7 @@ glevel_to_string (g_level)\n \f\n /* Convert the type information to string format.  */\n \n-const char *\n+static const char *\n type_to_string (aux_ptr, index, fdp)\n      AUXU *aux_ptr;\n      int index;\n@@ -746,7 +724,7 @@ type_to_string (aux_ptr, index, fdp)\n \f\n /* Print out the global file header for object files.  */\n \n-void\n+static void\n print_global_hdr (ptr)\n      struct filehdr *ptr;\n {\n@@ -801,7 +779,7 @@ print_global_hdr (ptr)\n \f\n /* Print out the symbolic header.  */\n \n-void\n+static void\n print_sym_hdr (sym_ptr)\n      HDRR *sym_ptr;\n {\n@@ -875,11 +853,11 @@ print_sym_hdr (sym_ptr)\n \f\n /* Print out a symbol.  */\n \n-void\n+static void\n print_symbol (sym_ptr, number, strbase, aux_base, ifd, fdp)\n      SYMR *sym_ptr;\n      int number;\n-     char *strbase;\n+     const char *strbase;\n      AUXU *aux_base;\n      int ifd;\n      FDR *fdp;\n@@ -1054,7 +1032,7 @@ print_symbol (sym_ptr, number, strbase, aux_base, ifd, fdp)\n \f\n /* Print out a word from the aux. table in various formats.  */\n \n-void\n+static void\n print_aux (u, auxi, used)\n      AUXU u;\n      int auxi;\n@@ -1080,7 +1058,7 @@ print_aux (u, auxi, used)\n \f\n /* Write aggregate information to a string.  */\n \n-void\n+static void\n emit_aggregate (string, u, u2, which, fdp)\n      char *string;\n      AUXU u;\n@@ -1120,7 +1098,7 @@ emit_aggregate (string, u, u2, which, fdp)\n /* Print out information about a file descriptor, and the symbols,\n    procedures, and line numbers within it.  */\n \n-void\n+static void\n print_file_desc (fdp, number)\n      FDR *fdp;\n      int number;\n@@ -1348,18 +1326,18 @@ print_file_desc (fdp, number)\n \f\n /* Read in the portions of the .T file that we will print out.  */\n \n-void\n-read_tfile __proto((void))\n+static void\n+read_tfile ()\n {\n   short magic;\n   off_t sym_hdr_offset = 0;\n \n-  (void) read_seek ((PTR_T) &magic, sizeof (magic), (off_t) 0, \"Magic number\");\n+  (void) read_seek ((PTR) &magic, sizeof (magic), (off_t) 0, \"Magic number\");\n   if (!tfile)\n     {\n       /* Print out the global header, since this is not a T-file.  */\n \n-      (void) read_seek ((PTR_T) &global_hdr, sizeof (global_hdr), (off_t) 0,\n+      (void) read_seek ((PTR) &global_hdr, sizeof (global_hdr), (off_t) 0,\n \t\t\t\"Global file header\");\n \n       print_global_hdr (&global_hdr);\n@@ -1373,67 +1351,67 @@ read_tfile __proto((void))\n       sym_hdr_offset = global_hdr.f_symptr;\n     }\n \n-  (void) read_seek ((PTR_T) &sym_hdr,\n+  (void) read_seek ((PTR) &sym_hdr,\n \t\t    sizeof (sym_hdr),\n \t\t    sym_hdr_offset,\n \t\t    \"Symbolic header\");\n \n   print_sym_hdr (&sym_hdr);\n \n-  lines = (LINER *) read_seek ((PTR_T) 0,\n+  lines = (LINER *) read_seek (NULL_PTR,\n \t\t\t       sym_hdr.cbLine,\n \t\t\t       sym_hdr.cbLineOffset,\n \t\t\t       \"Line numbers\");\n \n-  dense_nums = (DNR *) read_seek ((PTR_T) 0,\n+  dense_nums = (DNR *) read_seek (NULL_PTR,\n \t\t\t\t  sym_hdr.idnMax * sizeof (DNR),\n \t\t\t\t  sym_hdr.cbDnOffset,\n \t\t\t\t  \"Dense numbers\");\n \n-  proc_desc = (PDR *) read_seek ((PTR_T) 0,\n+  proc_desc = (PDR *) read_seek (NULL_PTR,\n \t\t\t\t sym_hdr.ipdMax * sizeof (PDR),\n \t\t\t\t sym_hdr.cbPdOffset,\n \t\t\t\t \"Procedure tables\");\n \n-  l_symbols = (SYMR *) read_seek ((PTR_T) 0,\n+  l_symbols = (SYMR *) read_seek (NULL_PTR,\n \t\t\t\t  sym_hdr.isymMax * sizeof (SYMR),\n \t\t\t\t  sym_hdr.cbSymOffset,\n \t\t\t\t  \"Local symbols\");\n \n-  opt_symbols = (OPTR *) read_seek ((PTR_T) 0,\n+  opt_symbols = (OPTR *) read_seek (NULL_PTR,\n \t\t\t\t    sym_hdr.ioptMax * sizeof (OPTR),\n \t\t\t\t    sym_hdr.cbOptOffset,\n \t\t\t\t    \"Optimization symbols\");\n \n-  aux_symbols = (AUXU *) read_seek ((PTR_T) 0,\n+  aux_symbols = (AUXU *) read_seek (NULL_PTR,\n \t\t\t\t    sym_hdr.iauxMax * sizeof (AUXU),\n \t\t\t\t    sym_hdr.cbAuxOffset,\n \t\t\t\t    \"Auxiliary symbols\");\n \n   if (sym_hdr.iauxMax > 0)\n     aux_used = xcalloc (sym_hdr.iauxMax, 1);\n \n-  l_strings = (char *) read_seek ((PTR_T) 0,\n+  l_strings = (char *) read_seek (NULL_PTR,\n \t\t\t\t  sym_hdr.issMax,\n \t\t\t\t  sym_hdr.cbSsOffset,\n \t\t\t\t  \"Local string table\");\n \n-  e_strings = (char *) read_seek ((PTR_T) 0,\n+  e_strings = (char *) read_seek (NULL_PTR,\n \t\t\t\t  sym_hdr.issExtMax,\n \t\t\t\t  sym_hdr.cbSsExtOffset,\n \t\t\t\t  \"External string table\");\n \n-  file_desc = (FDR *) read_seek ((PTR_T) 0,\n+  file_desc = (FDR *) read_seek (NULL_PTR,\n \t\t\t\t sym_hdr.ifdMax * sizeof (FDR),\n \t\t\t\t sym_hdr.cbFdOffset,\n \t\t\t\t \"File tables\");\n \n-  rfile_desc = (ulong *) read_seek ((PTR_T) 0,\n+  rfile_desc = (ulong *) read_seek (NULL_PTR,\n \t\t\t\t    sym_hdr.crfd * sizeof (ulong),\n \t\t\t\t    sym_hdr.cbRfdOffset,\n \t\t\t\t    \"Relative file tables\");\n \n-  e_symbols = (EXTR *) read_seek ((PTR_T) 0,\n+  e_symbols = (EXTR *) read_seek (NULL_PTR,\n \t\t\t\t  sym_hdr.iextMax * sizeof (EXTR),\n \t\t\t\t  sym_hdr.cbExtOffset,\n \t\t\t\t  \"External symbols\");\n@@ -1568,11 +1546,3 @@ main (argc, argv)\n \n   return 0;\n }\n-\n-\f\n-void\n-fancy_abort ()\n-{\n-  fprintf (stderr, \"mips-tdump internal error\");\n-  exit (1);\n-}"}, {"sha": "d0804931817ec66b48f5ffaf4944016a41f6cec7", "filename": "gcc/mips-tfile.c", "status": "modified", "additions": 102, "deletions": 149, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a647bee982216e27536ea8f9a23389c1a15369/gcc%2Fmips-tfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a647bee982216e27536ea8f9a23389c1a15369/gcc%2Fmips-tfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tfile.c?ref=45a647bee982216e27536ea8f9a23389c1a15369", "patch": "@@ -613,10 +613,6 @@ Boston, MA 02111-1307, USA.  */\n #define __LINE__ 0\n #endif\n \n-#define __proto(x) PARAMS(x)\n-typedef PTR PTR_T;\n-typedef const PTR_T CPTR_T;\n-\n /* Due to size_t being defined in sys/types.h and different\n    in stddef.h, we have to do this by hand.....  Note, these\n    types are correct for MIPS based systems, and may not be\n@@ -636,9 +632,9 @@ typedef const PTR_T CPTR_T;\n    so they can't be static.  */\n \n extern void\tpfatal_with_name\n-\t\t\t\t__proto((const char *)) ATTRIBUTE_NORETURN;\n-extern void\tfancy_abort\t__proto((void)) ATTRIBUTE_NORETURN;\n-       void\tbotch\t\t__proto((const char *)) ATTRIBUTE_NORETURN;\n+\t\t\t\tPARAMS ((const char *)) ATTRIBUTE_NORETURN;\n+extern void\tfancy_abort\tPARAMS ((void)) ATTRIBUTE_NORETURN;\n+       void\tbotch\t\tPARAMS ((const char *)) ATTRIBUTE_NORETURN;\n \n extern void\tfatal\t\tPARAMS ((const char *format, ...)) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n extern void\terror\t\tPARAMS ((const char *format, ...)) ATTRIBUTE_PRINTF_1;\n@@ -1615,28 +1611,28 @@ static char stabs_symbol[] = STABS_SYMBOL;\n #define STATIC static\n #endif\n \n-STATIC int\tout_of_bounds\t__proto((symint_t, symint_t, const char *, int));\n+STATIC int\tout_of_bounds\tPARAMS ((symint_t, symint_t, const char *, int));\n \n-STATIC shash_t *hash_string\t__proto((const char *,\n+STATIC shash_t *hash_string\tPARAMS ((const char *,\n \t\t\t\t\t Ptrdiff_t,\n \t\t\t\t\t shash_t **,\n \t\t\t\t\t symint_t *));\n \n-STATIC symint_t\tadd_string\t__proto((varray_t *,\n+STATIC symint_t\tadd_string\tPARAMS ((varray_t *,\n \t\t\t\t\t shash_t **,\n \t\t\t\t\t const char *,\n \t\t\t\t\t const char *,\n \t\t\t\t\t shash_t **));\n \n STATIC symint_t\tadd_local_symbol\n-\t\t\t\t__proto((const char *,\n+\t\t\t\tPARAMS ((const char *,\n \t\t\t\t\t const char *,\n \t\t\t\t\t st_t,\n \t\t\t\t\t sc_t,\n \t\t\t\t\t symint_t,\n \t\t\t\t\t symint_t));\n \n-STATIC symint_t\tadd_ext_symbol\t__proto((const char *,\n+STATIC symint_t\tadd_ext_symbol\tPARAMS ((const char *,\n \t\t\t\t\t const char *,\n \t\t\t\t\t st_t,\n \t\t\t\t\t sc_t,\n@@ -1645,88 +1641,82 @@ STATIC symint_t\tadd_ext_symbol\t__proto((const char *,\n \t\t\t\t\t int));\n \n STATIC symint_t\tadd_aux_sym_symint\n-\t\t\t\t__proto((symint_t));\n+\t\t\t\tPARAMS ((symint_t));\n \n STATIC symint_t\tadd_aux_sym_rndx\n-\t\t\t\t__proto((int, symint_t));\n+\t\t\t\tPARAMS ((int, symint_t));\n \n-STATIC symint_t\tadd_aux_sym_tir\t__proto((type_info_t *,\n+STATIC symint_t\tadd_aux_sym_tir\tPARAMS ((type_info_t *,\n \t\t\t\t\t hash_state_t,\n \t\t\t\t\t thash_t **));\n \n-STATIC tag_t *\tget_tag\t\t__proto((const char *,\n+STATIC tag_t *\tget_tag\t\tPARAMS ((const char *,\n \t\t\t\t\t const char *,\n \t\t\t\t\t symint_t,\n \t\t\t\t\t bt_t));\n \n-STATIC void\tadd_unknown_tag\t__proto((tag_t *));\n+STATIC void\tadd_unknown_tag\tPARAMS ((tag_t *));\n \n-STATIC void\tadd_procedure\t__proto((const char *,\n+STATIC void\tadd_procedure\tPARAMS ((const char *,\n \t\t\t\t\t const char *));\n \n-STATIC void\tadd_file\t__proto((const char *,\n+STATIC void\tadd_file\tPARAMS ((const char *,\n \t\t\t\t\t const char *));\n \n-STATIC void\tadd_bytes\t__proto((varray_t *,\n+STATIC void\tadd_bytes\tPARAMS ((varray_t *,\n \t\t\t\t\t char *,\n \t\t\t\t\t Size_t));\n \n-STATIC void\tadd_varray_page\t__proto((varray_t *));\n-\n-STATIC void\tupdate_headers\t__proto((void));\n-\n-STATIC void\twrite_varray\t__proto((varray_t *, off_t, const char *));\n-STATIC void\twrite_object\t__proto((void));\n-STATIC const char *st_to_string\t__proto((st_t));\n-STATIC const char *sc_to_string\t__proto((sc_t));\n-STATIC char    *read_line\t__proto((void));\n-STATIC void\tparse_input\t__proto((void));\n-STATIC void\tmark_stabs\t__proto((const char *));\n-STATIC void\tparse_begin\t__proto((const char *));\n-STATIC void\tparse_bend\t__proto((const char *));\n-STATIC void\tparse_def\t__proto((const char *));\n-STATIC void\tparse_end\t__proto((const char *));\n-STATIC void\tparse_ent\t__proto((const char *));\n-STATIC void\tparse_file\t__proto((const char *));\n+STATIC void\tadd_varray_page\tPARAMS ((varray_t *));\n+\n+STATIC void\tupdate_headers\tPARAMS ((void));\n+\n+STATIC void\twrite_varray\tPARAMS ((varray_t *, off_t, const char *));\n+STATIC void\twrite_object\tPARAMS ((void));\n+STATIC const char *st_to_string\tPARAMS ((st_t));\n+STATIC const char *sc_to_string\tPARAMS ((sc_t));\n+STATIC char    *read_line\tPARAMS ((void));\n+STATIC void\tparse_input\tPARAMS ((void));\n+STATIC void\tmark_stabs\tPARAMS ((const char *));\n+STATIC void\tparse_begin\tPARAMS ((const char *));\n+STATIC void\tparse_bend\tPARAMS ((const char *));\n+STATIC void\tparse_def\tPARAMS ((const char *));\n+STATIC void\tparse_end\tPARAMS ((const char *));\n+STATIC void\tparse_ent\tPARAMS ((const char *));\n+STATIC void\tparse_file\tPARAMS ((const char *));\n STATIC void\tparse_stabs_common\n-\t\t\t\t__proto((const char *, const char *, const char *));\n-STATIC void\tparse_stabs\t__proto((const char *));\n-STATIC void\tparse_stabn\t__proto((const char *));\n-STATIC page_t  *read_seek\t__proto((Size_t, off_t, const char *));\n-STATIC void\tcopy_object\t__proto((void));\n+\t\t\t\tPARAMS ((const char *, const char *, const char *));\n+STATIC void\tparse_stabs\tPARAMS ((const char *));\n+STATIC void\tparse_stabn\tPARAMS ((const char *));\n+STATIC page_t  *read_seek\tPARAMS ((Size_t, off_t, const char *));\n+STATIC void\tcopy_object\tPARAMS ((void));\n \n-STATIC void\tcatch_signal\t__proto((int)) ATTRIBUTE_NORETURN;\n-STATIC page_t  *allocate_page\t__proto((void));\n+STATIC void\tcatch_signal\tPARAMS ((int)) ATTRIBUTE_NORETURN;\n+STATIC page_t  *allocate_page\tPARAMS ((void));\n \n STATIC page_t  *allocate_multiple_pages\n-\t\t\t\t__proto((Size_t));\n+\t\t\t\tPARAMS ((Size_t));\n \n STATIC void\tfree_multiple_pages\n-\t\t\t\t__proto((page_t *, Size_t));\n+\t\t\t\tPARAMS ((page_t *, Size_t));\n \n #ifndef MALLOC_CHECK\n STATIC page_t  *allocate_cluster\n-\t\t\t\t__proto((Size_t));\n+\t\t\t\tPARAMS ((Size_t));\n #endif\n \n-STATIC forward_t *allocate_forward\t__proto((void));\n-STATIC scope_t\t *allocate_scope\t__proto((void));\n-STATIC shash_t\t *allocate_shash\t__proto((void));\n-STATIC tag_t\t *allocate_tag\t\t__proto((void));\n-STATIC thash_t\t *allocate_thash\t__proto((void));\n-STATIC thead_t\t *allocate_thead\t__proto((void));\n-STATIC vlinks_t\t *allocate_vlinks\t__proto((void));\n-\n-STATIC void\t  free_forward\t\t__proto((forward_t *));\n-STATIC void\t  free_scope\t\t__proto((scope_t *));\n-STATIC void\t  free_tag\t\t__proto((tag_t *));\n-STATIC void\t  free_thead\t\t__proto((thead_t *));\n-\n-STATIC char\t *local_index\t\t__proto((const char *, int));\n-STATIC char\t *local_rindex\t\t__proto((const char *, int));\n+STATIC forward_t *allocate_forward\tPARAMS ((void));\n+STATIC scope_t\t *allocate_scope\tPARAMS ((void));\n+STATIC shash_t\t *allocate_shash\tPARAMS ((void));\n+STATIC tag_t\t *allocate_tag\t\tPARAMS ((void));\n+STATIC thash_t\t *allocate_thash\tPARAMS ((void));\n+STATIC thead_t\t *allocate_thead\tPARAMS ((void));\n+STATIC vlinks_t\t *allocate_vlinks\tPARAMS ((void));\n \n-extern char  *mktemp\t\t\t__proto((char *));\n-extern long   strtol\t\t\t__proto((const char *, char **, int));\n+STATIC void\t  free_forward\t\tPARAMS ((forward_t *));\n+STATIC void\t  free_scope\t\tPARAMS ((scope_t *));\n+STATIC void\t  free_tag\t\tPARAMS ((tag_t *));\n+STATIC void\t  free_thead\t\tPARAMS ((thead_t *));\n \n extern char *optarg;\n extern int   optind;\n@@ -1740,7 +1730,7 @@ extern int   opterr;\n typedef struct _pseudo_ops {\n   const char *name;\t\t\t/* pseudo-op in ascii */\n   int len;\t\t\t\t/* length of name to compare */\n-  void (*func) __proto((const char *));\t/* function to handle line */\n+  void (*func) PARAMS ((const char *));\t/* function to handle line */\n } pseudo_ops_t;\n \n static pseudo_ops_t pseudo_ops[] = {\n@@ -1819,7 +1809,7 @@ hash_string (text, hash_len, hash_tbl, ret_hash_index)\n   for (ptr = hash_tbl[hi]; ptr != (shash_t *) 0; ptr = ptr->next)\n     if ((symint_t) hash_len == ptr->len\n \t&& first_ch == ptr->string[0]\n-\t&& memcmp ((CPTR_T) text, (CPTR_T) ptr->string, hash_len) == 0)\n+\t&& memcmp (text, ptr->string, hash_len) == 0)\n       break;\n \n   return ptr;\n@@ -2520,7 +2510,7 @@ add_file (file_start, file_end_p1)\n     {\n       if (first_ch == file_ptr->name[0]\n \t  && file_ptr->name[len] == '\\0'\n-\t  && memcmp ((CPTR_T) file_start, (CPTR_T) file_ptr->name, len) == 0)\n+\t  && memcmp (file_start, file_ptr->name, len) == 0)\n \t{\n \t  cur_file_ptr = file_ptr;\n \t  break;\n@@ -2604,7 +2594,7 @@ add_bytes (vp, input_ptr, nitems)\n \n       if (move_bytes >= 32)\n \t{\n-\t  (void) memcpy ((PTR_T) ptr, (CPTR_T) input_ptr, move_bytes);\n+\t  (void) memcpy (ptr, input_ptr, move_bytes);\n \t  input_ptr += move_bytes;\n \t}\n       else\n@@ -2694,7 +2684,7 @@ st_to_string(symbol_type)\n    semi-colon, and return each logical line independently.  */\n \n STATIC char *\n-read_line __proto((void))\n+read_line ()\n {\n   static   int line_split_p\t= 0;\n   register int string_p\t\t= 0;\n@@ -2889,8 +2879,8 @@ parse_def (name_start)\n   const char *arg_start;\t\t\t/* start of current argument */\n   const char *arg_end_p1;\t\t\t/* end+1 of current argument */\n   const char *name_end_p1;\t\t\t/* end+1 of label */\n-  const char *tag_start\t  = (const char *) 0;\t/* start of tag name */\n-  const char *tag_end_p1  = (const char *) 0;\t/* end+1 of tag name */\n+  const char *tag_start\t  = 0;\t\t\t/* start of tag name */\n+  const char *tag_end_p1  = 0;\t\t\t/* end+1 of tag name */\n   sc_t storage_class\t  = sc_Nil;\n   st_t symbol_type\t  = st_Nil;\n   type_info_t t;\n@@ -2962,7 +2952,7 @@ parse_def (name_start)\n \n       /* Pick up the subdirective argument now.  */\n       arg_was_number = arg_number = 0;\n-      arg_end_p1 = (const char *) 0;\n+      arg_end_p1 = 0;\n       arg_start = dir_end_p1+1;\n       ch = *arg_start;\n       while (ch == ' ' || ch == '\\t')\n@@ -3377,7 +3367,7 @@ parse_def (name_start)\n \t that any error reporting above gives the correct name.  */\n \n     case st_End:\n-      name_start = name_end_p1 = (const char *) 0;\n+      name_start = name_end_p1 = 0;\n       value = inside_enumeration = 0;\n       break;\n \n@@ -3565,8 +3555,8 @@ parse_file (start)\n \n   (void) strtol (start, &p, 0);\n   if (start == p\n-      || (start_name = local_index (p, '\"')) == (char *) 0\n-      || (end_name_p1 = local_rindex (++start_name, '\"')) == (char *) 0)\n+      || (start_name = strchr (p, '\"')) == (char *) 0\n+      || (end_name_p1 = strrchr (++start_name, '\"')) == (char *) 0)\n     {\n       error (\"Invalid .file directive\");\n       return;\n@@ -3832,7 +3822,7 @@ STATIC void\n parse_stabs (start)\n      const char *start;\t\t\t/* start of directive */\n {\n-  const char *end = local_index (start+1, '\"');\n+  const char *end = strchr (start+1, '\"');\n \n   if (*start != '\"' || end == (const char *) 0 || end[1] != ',')\n     {\n@@ -3856,7 +3846,7 @@ parse_stabn (start)\n    if needed.  */\n \n STATIC void\n-parse_input __proto((void))\n+parse_input ()\n {\n   register char *p;\n   register Size_t i;\n@@ -3919,7 +3909,7 @@ parse_input __proto((void))\n    to write out the .T file.  */\n \n STATIC void\n-update_headers __proto((void))\n+update_headers ()\n {\n   register symint_t i;\n   register efdr_t *file_ptr;\n@@ -4119,7 +4109,7 @@ write_varray (vp, offset, str)\n   if (debug)\n     {\n       fputs (\"\\twarray\\tvp = \", stderr);\n-      fprintf (stderr, HOST_PTR_PRINTF, vp);\n+      fprintf (stderr, HOST_PTR_PRINTF, (PTR) vp);\n       fprintf (stderr, \", offset = %7lu, size = %7lu, %s\\n\",\n \t       (unsigned long) offset, vp->num_allocated * vp->object_size, str);\n     }\n@@ -4134,7 +4124,7 @@ write_varray (vp, offset, str)\n \t? vp->objects_last_page * vp->object_size\n \t: vp->objects_per_page  * vp->object_size;\n \n-      sys_write = fwrite ((PTR_T) ptr->datum, 1, num_write, object_stream);\n+      sys_write = fwrite ((PTR) ptr->datum, 1, num_write, object_stream);\n       if (sys_write <= 0)\n \tpfatal_with_name (object_name);\n \n@@ -4152,7 +4142,7 @@ write_varray (vp, offset, str)\n /* Write out the symbol table in the object file.  */\n \n STATIC void\n-write_object __proto((void))\n+write_object ()\n {\n   int sys_write;\n   efdr_t *file_ptr;\n@@ -4161,12 +4151,12 @@ write_object __proto((void))\n   if (debug)\n     {\n       fputs (\"\\n\\twrite\\tvp = \", stderr);\n-      fprintf (stderr, HOST_PTR_PRINTF, (PTR_T *) &symbolic_header);\n+      fprintf (stderr, HOST_PTR_PRINTF, (PTR) &symbolic_header);\n       fprintf (stderr, \", offset = %7u, size = %7lu, %s\\n\",\n \t       0, (unsigned long) sizeof (symbolic_header), \"symbolic header\");\n     }\n \n-  sys_write = fwrite ((PTR_T) &symbolic_header,\n+  sys_write = fwrite ((PTR) &symbolic_header,\n \t\t      1,\n \t\t      sizeof (symbolic_header),\n \t\t      object_stream);\n@@ -4194,13 +4184,13 @@ write_object __proto((void))\n       if (debug)\n \t{\n \t  fputs (\"\\twrite\\tvp = \", stderr);\n-\t  fprintf (stderr, HOST_PTR_PRINTF, (PTR_T *) &orig_linenum);\n+\t  fprintf (stderr, HOST_PTR_PRINTF, (PTR) &orig_linenum);\n \t  fprintf (stderr, \", offset = %7lu, size = %7lu, %s\\n\",\n \t\t   (long) symbolic_header.cbLineOffset,\n \t\t   (long) symbolic_header.cbLine, \"Line numbers\");\n \t}\n \n-      sys_write = fwrite ((PTR_T) orig_linenum,\n+      sys_write = fwrite ((PTR) orig_linenum,\n \t\t\t  1,\n \t\t\t  symbolic_header.cbLine,\n \t\t\t  object_stream);\n@@ -4229,13 +4219,13 @@ write_object __proto((void))\n       if (debug)\n \t{\n \t  fputs (\"\\twrite\\tvp = \", stderr);\n-\t  fprintf (stderr, HOST_PTR_PRINTF, (PTR_T *) &orig_opt_syms);\n+\t  fprintf (stderr, HOST_PTR_PRINTF, (PTR) &orig_opt_syms);\n \t  fprintf (stderr, \", offset = %7lu, size = %7lu, %s\\n\",\n \t\t   (long) symbolic_header.cbOptOffset,\n \t\t   num_write, \"Optimizer symbols\");\n \t}\n \n-      sys_write = fwrite ((PTR_T) orig_opt_syms,\n+      sys_write = fwrite ((PTR) orig_opt_syms,\n \t\t\t  1,\n \t\t\t  num_write,\n \t\t\t  object_stream);\n@@ -4321,7 +4311,7 @@ write_object __proto((void))\n \t  if (debug)\n \t    {\n \t      fputs (\"\\twrite\\tvp = \", stderr);\n-\t      fprintf (stderr, HOST_PTR_PRINTF, (PTR_T *) &file_ptr->fdr);\n+\t      fprintf (stderr, HOST_PTR_PRINTF, (PTR) &file_ptr->fdr);\n \t      fprintf (stderr, \", offset = %7lu, size = %7lu, %s\\n\",\n \t\t       file_offset, (unsigned long) sizeof (FDR),\n \t\t       \"File header\");\n@@ -4357,7 +4347,7 @@ write_object __proto((void))\n       if (debug)\n \t{\n \t  fputs (\"\\twrite\\tvp = \", stderr);\n-\t  fprintf (stderr, HOST_PTR_PRINTF, (PTR_T *) &orig_rfds);\n+\t  fprintf (stderr, HOST_PTR_PRINTF, (PTR) &orig_rfds);\n \t  fprintf (stderr, \", offset = %7lu, size = %7lu, %s\\n\",\n \t\t   (long) symbolic_header.cbRfdOffset,\n \t\t   num_write, \"Relative file descriptors\");\n@@ -4437,7 +4427,7 @@ read_seek (size, offset, str)\n \tpfatal_with_name (obj_in_name);\n     }\n \n-  sys_read = fread ((PTR_T)ptr, 1, size, obj_in_stream);\n+  sys_read = fread ((PTR) ptr, 1, size, obj_in_stream);\n   if (sys_read <= 0)\n     pfatal_with_name (obj_in_name);\n \n@@ -4461,7 +4451,7 @@ read_seek (size, offset, str)\n    symbol table.  */\n \n STATIC void\n-copy_object __proto((void))\n+copy_object ()\n {\n   char buffer[ PAGE_SIZE ];\n   register int sys_read;\n@@ -4480,7 +4470,7 @@ copy_object __proto((void))\n       || fseek (obj_in_stream, 0L, SEEK_SET) != 0)\n     pfatal_with_name (obj_in_name);\n \n-  sys_read = fread ((PTR_T) &orig_file_header,\n+  sys_read = fread ((PTR) &orig_file_header,\n \t\t    1,\n \t\t    sizeof (struct filehdr),\n \t\t    obj_in_stream);\n@@ -4499,15 +4489,15 @@ copy_object __proto((void))\n \n \n   if (orig_file_header.f_nsyms != sizeof (HDRR))\n-    fatal (\"%s symbolic header wrong size (%d bytes, should be %d)\",\n-\t   input_name, orig_file_header.f_nsyms, (int) sizeof (HDRR));\n+    fatal (\"%s symbolic header wrong size (%ld bytes, should be %ld)\",\n+\t   input_name, (long) orig_file_header.f_nsyms, (long) sizeof (HDRR));\n \n \n   /* Read in the current symbolic header.  */\n   if (fseek (obj_in_stream, (long) orig_file_header.f_symptr, SEEK_SET) != 0)\n     pfatal_with_name (input_name);\n \n-  sys_read = fread ((PTR_T) &orig_sym_hdr,\n+  sys_read = fread ((PTR) &orig_sym_hdr,\n \t\t    1,\n \t\t    sizeof (orig_sym_hdr),\n \t\t    obj_in_stream);\n@@ -4596,7 +4586,7 @@ copy_object __proto((void))\n   if (max_file_offset != stat_buf.st_size)\n     fatal (\"Symbol table is not last (symbol table ends at %ld, .o ends at %ld\",\n \t   max_file_offset,\n-\t   stat_buf.st_size);\n+\t   (long) stat_buf.st_size);\n \n \n   /* If the first original file descriptor is a dummy which the assembler\n@@ -4606,7 +4596,7 @@ copy_object __proto((void))\n       && orig_files->caux == 0)\n     {\n       char *filename = orig_local_strs + (orig_files->issBase + orig_files->rss);\n-      char *suffix = local_rindex (filename, '.');\n+      char *suffix = strrchr (filename, '.');\n \n       if (suffix != (char *) 0 && strcmp (suffix, \".s\") == 0)\n \tdelete_ifd = 1;\n@@ -4813,7 +4803,7 @@ copy_object __proto((void))\n       num_write\n \t= (remaining <= (int) sizeof (buffer))\n \t  ? remaining : (int) sizeof (buffer);\n-      sys_read = fread ((PTR_T) buffer, 1, num_write, obj_in_stream);\n+      sys_read = fread ((PTR) buffer, 1, num_write, obj_in_stream);\n       if (sys_read <= 0)\n \tpfatal_with_name (obj_in_name);\n \n@@ -4846,7 +4836,7 @@ main (argc, argv)\n      char **argv;\n {\n   int iflag = 0;\n-  char *p = local_rindex (argv[0], '/');\n+  char *p = strrchr (argv[0], '/');\n   char *num_end;\n   int option;\n   int i;\n@@ -5155,7 +5145,7 @@ allocate_cluster (npages)\n     {\n       fprintf (stderr, \"\\talloc\\tnpages = %lu, value = \",\n \t       (unsigned long) npages);\n-      fprintf (stderr, HOST_PTR_PRINTF, ptr);\n+      fprintf (stderr, HOST_PTR_PRINTF, (PTR) ptr);\n       fputs (\"\\n\", stderr);\n     }\n \n@@ -5235,7 +5225,7 @@ free_multiple_pages (page_ptr, npages)\n /* Allocate one page (which is initialized to 0).  */\n \n STATIC page_t *\n-allocate_page __proto((void))\n+allocate_page ()\n {\n #ifndef MALLOC_CHECK\n   if (pages_left == 0)\n@@ -5257,7 +5247,7 @@ allocate_page __proto((void))\n /* Allocate scoping information.  */\n \n STATIC scope_t *\n-allocate_scope __proto((void))\n+allocate_scope ()\n {\n   register scope_t *ptr;\n   static scope_t initial_scope;\n@@ -5306,7 +5296,7 @@ free_scope (ptr)\n   alloc_counts[ (int)alloc_type_scope ].free_list.f_scope = ptr;\n \n #else\n-  free ((PTR_T) ptr);\n+  free ((PTR) ptr);\n #endif\n \n }\n@@ -5315,7 +5305,7 @@ free_scope (ptr)\n /* Allocate links for pages in a virtual array.  */\n \n STATIC vlinks_t *\n-allocate_vlinks __proto((void))\n+allocate_vlinks ()\n {\n   register vlinks_t *ptr;\n   static vlinks_t initial_vlinks;\n@@ -5348,7 +5338,7 @@ allocate_vlinks __proto((void))\n /* Allocate string hash buckets.  */\n \n STATIC shash_t *\n-allocate_shash __proto((void))\n+allocate_shash ()\n {\n   register shash_t *ptr;\n   static shash_t initial_shash;\n@@ -5381,7 +5371,7 @@ allocate_shash __proto((void))\n /* Allocate type hash buckets.  */\n \n STATIC thash_t *\n-allocate_thash __proto((void))\n+allocate_thash ()\n {\n   register thash_t *ptr;\n   static thash_t initial_thash;\n@@ -5414,7 +5404,7 @@ allocate_thash __proto((void))\n /* Allocate structure, union, or enum tag information.  */\n \n STATIC tag_t *\n-allocate_tag __proto((void))\n+allocate_tag ()\n {\n   register tag_t *ptr;\n   static tag_t initial_tag;\n@@ -5463,7 +5453,7 @@ free_tag (ptr)\n   alloc_counts[ (int)alloc_type_tag ].free_list.f_tag = ptr;\n \n #else\n-  free ((PTR_T) ptr);\n+  free ((PTR) ptr);\n #endif\n \n }\n@@ -5472,7 +5462,7 @@ free_tag (ptr)\n /* Allocate forward reference to a yet unknown tag.  */\n \n STATIC forward_t *\n-allocate_forward __proto((void))\n+allocate_forward ()\n {\n   register forward_t *ptr;\n   static forward_t initial_forward;\n@@ -5521,7 +5511,7 @@ free_forward (ptr)\n   alloc_counts[ (int)alloc_type_forward ].free_list.f_forward = ptr;\n \n #else\n-  free ((PTR_T) ptr);\n+  free ((PTR) ptr);\n #endif\n \n }\n@@ -5530,7 +5520,7 @@ free_forward (ptr)\n /* Allocate head of type hash list.  */\n \n STATIC thead_t *\n-allocate_thead __proto((void))\n+allocate_thead ()\n {\n   register thead_t *ptr;\n   static thead_t initial_thead;\n@@ -5579,7 +5569,7 @@ free_thead (ptr)\n   alloc_counts[ (int)alloc_type_thead ].free_list.f_thead = ptr;\n \n #else\n-  free ((PTR_T) ptr);\n+  free ((PTR) ptr);\n #endif\n \n }\n@@ -5669,40 +5659,3 @@ botch (s)\n {\n   fatal (\"%s\", s);\n }\n-\n-\f\n-/* Define our own index/rindex, since the local and global symbol\n-   structures as defined by MIPS has an 'index' field.  */\n-\n-STATIC char *\n-local_index (str, sentinel)\n-     const char *str;\n-     int sentinel;\n-{\n-  int ch;\n-\n-  for ( ; (ch = *str) != sentinel; str++)\n-    {\n-      if (ch == '\\0')\n-\treturn (char *) 0;\n-    }\n-\n-  return (char *)str;\n-}\n-\n-STATIC char *\n-local_rindex (str, sentinel)\n-     const char *str;\n-     int sentinel;\n-{\n-  int ch;\n-  const char *ret = (const char *) 0;\n-\n-  for ( ; (ch = *str) != '\\0'; str++)\n-    {\n-      if (ch == sentinel)\n-\tret = str;\n-    }\n-\n-  return (char *)ret;\n-}"}]}