{"sha": "e535b963b4a39e041cc81e2879cfb637d60c720d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTUzNWI5NjNiNGEzOWUwNDFjYzgxZTI4NzljZmI2MzdkNjBjNzIwZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-14T00:06:02Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-14T00:06:02Z"}, "message": "poly_int: add poly-int.h\n\nThis patch adds a new \"poly_int\" class to represent polynomial integers\nof the form:\n\n  C0 + C1*X1 + C2*X2 ... + Cn*Xn\n\nIt also adds poly_int-based typedefs for offsets and sizes of various\nprecisions.  In these typedefs, the Ci coefficients are compile-time\nconstants and the Xi indeterminates are run-time invariants.  The number\nof coefficients is controlled by the target and is initially 1 for all\nports.\n\nMost routines can handle general coefficient counts, but for now a few\nare specific to one or two coefficients.  Support for other coefficient\ncounts can be added when needed.\n\nThe patch also adds a new macro, IN_TARGET_CODE, that can be\nset to indicate that a TU contains target-specific rather than\ntarget-independent code.  When this macro is set and the number of\ncoefficients is 1, the poly-int.h classes define a conversion operator\nto a constant.  This allows most existing target code to work without\nmodification.  The main exceptions are:\n\n- values passed through ..., which need an explicit conversion to a\n  constant\n\n- ?: expression in which one arm ends up being a polynomial and the\n  other remains a constant.  In these cases it would be valid to convert\n  the constant to a polynomial and the polynomial to a constant, so a\n  cast is needed to break the ambiguity.\n\nThe patch also adds a new target hook to return the estimated\nvalue of a polynomial for costing purposes.\n\nThe patch also adds operator<< on wide_ints (it was already defined\nfor offset_int and widest_int).  I think this was originally excluded\nbecause >> is ambiguous for wide_int, but << is useful for converting\nbytes to bits, etc., so is worth defining on its own.  The patch also\nadds operator% and operator/ for offset_int and widest_int, since those\ntypes are always signed.  These changes allow the poly_int interface to\nbe more predictable.\n\nI'd originally tried adding the tests as selftests, but that ended up\nbloating cc1 by at least a third.  It also took a while to build them\nat -O2.  The patch therefore uses plugin tests instead, where we can\nforce the tests to be built at -O0.  They still run in negligible time\nwhen built that way.\n\n2017-12-14  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* poly-int.h: New file.\n\t* poly-int-types.h: Likewise.\n\t* coretypes.h: Include them.\n\t(POLY_INT_CONVERSION): Define.\n\t* target.def (estimated_poly_value): New hook.\n\t* doc/tm.texi.in (TARGET_ESTIMATED_POLY_VALUE): New hook.\n\t* doc/tm.texi: Regenerate.\n\t* doc/poly-int.texi: New file.\n\t* doc/gccint.texi: Include it.\n\t* doc/rtl.texi: Describe restrictions on subreg modes.\n\t* Makefile.in (TEXI_GCCINT_FILES): Add poly-int.texi.\n\t* genmodes.c (NUM_POLY_INT_COEFFS): Provide a default definition.\n\t(emit_insn_modes_h): Emit a definition of NUM_POLY_INT_COEFFS.\n\t* targhooks.h (default_estimated_poly_value): Declare.\n\t* targhooks.c (default_estimated_poly_value): New function.\n\t* target.h (estimated_poly_value): Likewise.\n\t* wide-int.h (WI_UNARY_RESULT): Use wi::binary_traits.\n\t(wi::unary_traits): Delete.\n\t(wi::binary_traits::signed_shift_result_type): Define for\n\toffset_int << HOST_WIDE_INT, etc.\n\t(generic_wide_int::operator <<=): Define for all types and use\n\twi::lshift instead of <<.\n\t(wi::hwi_with_prec): Add a default constructor.\n\t(wi::ints_for): New class.\n\t(operator <<): Define for all wide-int types.\n\t(operator /): New function.\n\t(operator %): Likewise.\n\t* selftest.h (ASSERT_KNOWN_EQ, ASSERT_KNOWN_EQ_AT, ASSERT_MAYBE_NE)\n\t(ASSERT_MAYBE_NE_AT): New macros.\n\ngcc/testsuite/\n\t* gcc.dg/plugin/poly-int-tests.h,\n\tgcc.dg/plugin/poly-int-test-1.c,\n\tgcc.dg/plugin/poly-int-01_plugin.c,\n\tgcc.dg/plugin/poly-int-02_plugin.c,\n\tgcc.dg/plugin/poly-int-03_plugin.c,\n\tgcc.dg/plugin/poly-int-04_plugin.c,\n\tgcc.dg/plugin/poly-int-05_plugin.c,\n\tgcc.dg/plugin/poly-int-06_plugin.c,\n\tgcc.dg/plugin/poly-int-07_plugin.c: New tests.\n\t* gcc.dg/plugin/plugin.exp: Run them.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255617", "tree": {"sha": "e380648d6b3b82e1442620c6f67e83c5d250ef81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e380648d6b3b82e1442620c6f67e83c5d250ef81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e535b963b4a39e041cc81e2879cfb637d60c720d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e535b963b4a39e041cc81e2879cfb637d60c720d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e535b963b4a39e041cc81e2879cfb637d60c720d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e535b963b4a39e041cc81e2879cfb637d60c720d/comments", "author": null, "committer": null, "parents": [{"sha": "b9f92c0bb7fc0c319b0a2d54b6a74e8f49c469bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9f92c0bb7fc0c319b0a2d54b6a74e8f49c469bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9f92c0bb7fc0c319b0a2d54b6a74e8f49c469bd"}], "stats": {"total": 8883, "additions": 8871, "deletions": 12}, "files": [{"sha": "9d4869eadba8cf3955d4595b07d25ecc8200a15a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -1,3 +1,37 @@\n+2017-12-14  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* poly-int.h: New file.\n+\t* poly-int-types.h: Likewise.\n+\t* coretypes.h: Include them.\n+\t(POLY_INT_CONVERSION): Define.\n+\t* target.def (estimated_poly_value): New hook.\n+\t* doc/tm.texi.in (TARGET_ESTIMATED_POLY_VALUE): New hook.\n+\t* doc/tm.texi: Regenerate.\n+\t* doc/poly-int.texi: New file.\n+\t* doc/gccint.texi: Include it.\n+\t* doc/rtl.texi: Describe restrictions on subreg modes.\n+\t* Makefile.in (TEXI_GCCINT_FILES): Add poly-int.texi.\n+\t* genmodes.c (NUM_POLY_INT_COEFFS): Provide a default definition.\n+\t(emit_insn_modes_h): Emit a definition of NUM_POLY_INT_COEFFS.\n+\t* targhooks.h (default_estimated_poly_value): Declare.\n+\t* targhooks.c (default_estimated_poly_value): New function.\n+\t* target.h (estimated_poly_value): Likewise.\n+\t* wide-int.h (WI_UNARY_RESULT): Use wi::binary_traits.\n+\t(wi::unary_traits): Delete.\n+\t(wi::binary_traits::signed_shift_result_type): Define for\n+\toffset_int << HOST_WIDE_INT, etc.\n+\t(generic_wide_int::operator <<=): Define for all types and use\n+\twi::lshift instead of <<.\n+\t(wi::hwi_with_prec): Add a default constructor.\n+\t(wi::ints_for): New class.\n+\t(operator <<): Define for all wide-int types.\n+\t(operator /): New function.\n+\t(operator %): Likewise.\n+\t* selftest.h (ASSERT_KNOWN_EQ, ASSERT_KNOWN_EQ_AT, ASSERT_MAYBE_NE)\n+\t(ASSERT_MAYBE_NE_AT): New macros.\n+\n 2017-12-13  Eric Botcazou  <ebotcazou@adacore.com>\n             Dominik Vogt  <vogt@linux.vnet.ibm.com>\n "}, {"sha": "115cbe53d0b25998207b19fe52303c72373351b0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -3162,7 +3162,7 @@ TEXI_GCCINT_FILES = gccint.texi gcc-common.texi gcc-vers.texi\t\t\\\n \t gnu.texi gpl_v3.texi fdl.texi contrib.texi languages.texi\t\\\n \t sourcebuild.texi gty.texi libgcc.texi cfg.texi tree-ssa.texi\t\\\n \t loop.texi generic.texi gimple.texi plugins.texi optinfo.texi   \\\n-\t match-and-simplify.texi\n+\t match-and-simplify.texi poly-int.texi\n \n TEXI_GCCINSTALL_FILES = install.texi install-old.texi fdl.texi\t\t\\\n \t gcc-common.texi gcc-vers.texi"}, {"sha": "9d94e4922995d79a7093a619966b5592c555f94c", "filename": "gcc/coretypes.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -396,6 +396,21 @@ typedef unsigned char uchar;\n #include \"signop.h\"\n #include \"wide-int.h\" \n #include \"wide-int-print.h\"\n+\n+/* On targets that don't need polynomial offsets, target-specific code\n+   should be able to treat poly_int like a normal constant, with a\n+   conversion operator going from the former to the latter.  We also\n+   allow this for gencondmd.c for all targets, so that we can treat\n+   machine_modes as enums without causing build failures.  */\n+#if (defined (IN_TARGET_CODE) \\\n+     && (defined (USE_ENUM_MODES) || NUM_POLY_INT_COEFFS == 1))\n+#define POLY_INT_CONVERSION 1\n+#else\n+#define POLY_INT_CONVERSION 0\n+#endif\n+\n+#include \"poly-int.h\"\n+#include \"poly-int-types.h\"\n #include \"insn-modes-inline.h\"\n #include \"machmode.h\"\n #include \"double-int.h\""}, {"sha": "849c67c787ef825c932415280cba19a13f8fb36d", "filename": "gcc/doc/gccint.texi", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Fdoc%2Fgccint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Fdoc%2Fgccint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint.texi?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -107,6 +107,7 @@ Additional tutorial information is linked to from\n * Testsuites::      GCC testsuites.\n * Options::         Option specification files.\n * Passes::          Order of passes, what they do, and what each file is for.\n+* poly_int::        Representation of runtime sizes and offsets.\n * GENERIC::         Language-independent representation generated by Front Ends\n * GIMPLE::          Tuple representation used by Tree SSA optimizers\n * Tree SSA::        Analysis and optimization of GIMPLE\n@@ -144,6 +145,7 @@ Additional tutorial information is linked to from\n @include sourcebuild.texi\n @include options.texi\n @include passes.texi\n+@include poly-int.texi\n @include generic.texi\n @include gimple.texi\n @include tree-ssa.texi"}, {"sha": "1023e823cb3aaf7713f242cae4751f1929bbef25", "filename": "gcc/doc/poly-int.texi", "status": "added", "additions": 1048, "deletions": 0, "changes": 1048, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Fdoc%2Fpoly-int.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Fdoc%2Fpoly-int.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpoly-int.texi?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -0,0 +1,1048 @@\n+@node poly_int\n+@chapter Sizes and offsets as runtime invariants\n+@cindex polynomial integers\n+@findex poly_int\n+\n+GCC allows the size of a hardware register to be a runtime invariant\n+rather than a compile-time constant.  This in turn means that various\n+sizes and offsets must also be runtime invariants rather than\n+compile-time constants, such as:\n+\n+@itemize @bullet\n+@item\n+the size of a general @code{machine_mode} (@pxref{Machine Modes});\n+\n+@item\n+the size of a spill slot;\n+\n+@item\n+the offset of something within a stack frame;\n+\n+@item\n+the number of elements in a vector;\n+\n+@item\n+the size and offset of a @code{mem} rtx (@pxref{Regs and Memory}); and\n+\n+@item\n+the byte offset in a @code{subreg} rtx (@pxref{Regs and Memory}).\n+@end itemize\n+\n+The motivating example is the Arm SVE ISA, whose vector registers can be\n+any multiple of 128 bits between 128 and 2048 inclusive.  The compiler\n+normally produces code that works for all SVE register sizes, with the\n+actual size only being known at runtime.\n+\n+GCC's main representation of such runtime invariants is the\n+@code{poly_int} class.  This chapter describes what @code{poly_int}\n+does, lists the available operations, and gives some general\n+usage guidelines.\n+\n+@menu\n+* Overview of @code{poly_int}::\n+* Consequences of using @code{poly_int}::\n+* Comparisons involving @code{poly_int}::\n+* Arithmetic on @code{poly_int}s::\n+* Alignment of @code{poly_int}s::\n+* Computing bounds on @code{poly_int}s::\n+* Converting @code{poly_int}s::\n+* Miscellaneous @code{poly_int} routines::\n+* Guidelines for using @code{poly_int}::\n+@end menu\n+\n+@node Overview of @code{poly_int}\n+@section Overview of @code{poly_int}\n+\n+@cindex @code{poly_int}, runtime value\n+We define indeterminates @var{x1}, @dots{}, @var{xn} whose values are\n+only known at runtime and use polynomials of the form:\n+\n+@smallexample\n+@var{c0} + @var{c1} * @var{x1} + @dots{} + @var{cn} * @var{xn}\n+@end smallexample\n+\n+to represent a size or offset whose value might depend on some\n+of these indeterminates.  The coefficients @var{c0}, @dots{}, @var{cn}\n+are always known at compile time, with the @var{c0} term being the\n+``constant'' part that does not depend on any runtime value.\n+\n+GCC uses the @code{poly_int} class to represent these coefficients.\n+The class has two template parameters: the first specifies the number of\n+coefficients (@var{n} + 1) and the second specifies the type of the\n+coefficients.  For example, @samp{poly_int<2, unsigned short>} represents\n+a polynomial with two coefficients (and thus one indeterminate), with each\n+coefficient having type @code{unsigned short}.  When @var{n} is 0,\n+the class degenerates to a single compile-time constant @var{c0}.\n+\n+@cindex @code{poly_int}, template parameters\n+@findex NUM_POLY_INT_COEFFS\n+The number of coefficients needed for compilation is a fixed\n+property of each target and is specified by the configuration macro\n+@code{NUM_POLY_INT_COEFFS}.  The default value is 1, since most targets\n+do not have such runtime invariants.  Targets that need a different\n+value should @code{#define} the macro in their @file{@var{cpu}-modes.def}\n+file.  @xref{Back End}.\n+\n+@cindex @code{poly_int}, invariant range\n+@code{poly_int} makes the simplifying requirement that each indeterminate\n+must be a nonnegative integer.  An indeterminate value of 0 should usually\n+represent the minimum possible runtime value, with @var{c0} specifying\n+the value in that case.\n+\n+For example, when targetting the Arm SVE ISA, the single indeterminate\n+represents the number of 128-bit blocks in a vector @emph{beyond the minimum\n+length of 128 bits}.  Thus the number of 64-bit doublewords in a vector\n+is 2 + 2 * @var{x1}.  If an aggregate has a single SVE vector and 16\n+additional bytes, its total size is 32 + 16 * @var{x1} bytes.\n+\n+The header file @file{poly-int-types.h} provides typedefs for the\n+most common forms of @code{poly_int}, all having\n+@code{NUM_POLY_INT_COEFFS} coefficients:\n+\n+@cindex @code{poly_int}, main typedefs\n+@table @code\n+@item poly_uint16\n+a @samp{poly_int} with @code{unsigned short} coefficients.\n+\n+@item poly_int64\n+a @samp{poly_int} with @code{HOST_WIDE_INT} coefficients.\n+\n+@item poly_uint64\n+a @samp{poly_int} with @code{unsigned HOST_WIDE_INT} coefficients.\n+\n+@item poly_offset_int\n+a @samp{poly_int} with @code{offset_int} coefficients.\n+\n+@item poly_wide_int\n+a @samp{poly_int} with @code{wide_int} coefficients.\n+\n+@item poly_widest_int\n+a @samp{poly_int} with @code{widest_int} coefficients.\n+@end table\n+\n+Since the main purpose of @code{poly_int} is to represent sizes and\n+offsets, the last two typedefs are only rarely used.\n+\n+@node Consequences of using @code{poly_int}\n+@section Consequences of using @code{poly_int}\n+\n+The two main consequences of using polynomial sizes and offsets are that:\n+\n+@itemize\n+@item\n+there is no total ordering between the values at compile time, and\n+\n+@item\n+some operations might yield results that cannot be expressed as a\n+@code{poly_int}.\n+@end itemize\n+\n+For example, if @var{x} is a runtime invariant, we cannot tell at\n+compile time whether:\n+\n+@smallexample\n+3 + 4@var{x} <= 1 + 5@var{x}\n+@end smallexample\n+\n+since the condition is false when @var{x} <= 1 and true when @var{x} >= 2.\n+\n+Similarly, @code{poly_int} cannot represent the result of:\n+\n+@smallexample\n+(3 + 4@var{x}) * (1 + 5@var{x})\n+@end smallexample\n+\n+since it cannot (and in practice does not need to) store powers greater\n+than one.  It also cannot represent the result of:\n+\n+@smallexample\n+(3 + 4@var{x}) / (1 + 5@var{x})\n+@end smallexample\n+\n+The following sections describe how we deal with these restrictions.\n+\n+@cindex @code{poly_int}, use in target-independent code\n+As described earlier, a @code{poly_int<1, @var{T}>} has no indeterminates\n+and so degenerates to a compile-time constant of type @var{T}.  It would\n+be possible in that case to do all normal arithmetic on the @var{T},\n+and to compare the @var{T} using the normal C++ operators.  We deliberately\n+prevent target-independent code from doing this, since the compiler needs\n+to support other @code{poly_int<@var{n}, @var{T}>} as well, regardless of\n+the current target's @code{NUM_POLY_INT_COEFFS}.\n+\n+@cindex @code{poly_int}, use in target-specific code\n+However, it would be very artificial to force target-specific code\n+to follow these restrictions if the target has no runtime indeterminates.\n+There is therefore an implicit conversion from @code{poly_int<1, @var{T}>}\n+to @var{T} when compiling target-specific translation units.\n+\n+@node Comparisons involving @code{poly_int}\n+@section Comparisons involving @code{poly_int}\n+\n+In general we need to compare sizes and offsets in two situations:\n+those in which the values need to be ordered, and those in which\n+the values can be unordered.  More loosely, the distinction is often\n+between values that have a definite link (usually because they refer to the\n+same underlying register or memory location) and values that have\n+no definite link.  An example of the former is the relationship between\n+the inner and outer sizes of a subreg, where we must know at compile time\n+whether the subreg is paradoxical, partial, or complete.  An example of\n+the latter is alias analysis: we might want to check whether two\n+arbitrary memory references overlap.\n+\n+Referring back to the examples in the previous section, it makes sense\n+to ask whether a memory reference of size @samp{3 + 4@var{x}} overlaps\n+one of size @samp{1 + 5@var{x}}, but it does not make sense to have a\n+subreg in which the outer mode has @samp{3 + 4@var{x}} bytes and the\n+inner mode has @samp{1 + 5@var{x}} bytes (or vice versa).  Such subregs\n+are always invalid and should trigger an internal compiler error\n+if formed.\n+\n+The underlying operators are the same in both cases, but the distinction\n+affects how they are used.\n+\n+@menu\n+* Comparison functions for @code{poly_int}::\n+* Properties of the @code{poly_int} comparisons::\n+* Comparing potentially-unordered @code{poly_int}s::\n+* Comparing ordered @code{poly_int}s::\n+* Checking for a @code{poly_int} marker value::\n+* Range checks on @code{poly_int}s::\n+* Sorting @code{poly_int}s::\n+@end menu\n+\n+@node Comparison functions for @code{poly_int}\n+@subsection Comparison functions for @code{poly_int}\n+\n+@code{poly_int} provides the following routines for checking whether\n+a particular condition ``may be'' (might be) true:\n+\n+@example\n+maybe_lt maybe_le maybe_eq maybe_ge maybe_gt\n+                  maybe_ne\n+@end example\n+\n+The functions have their natural meaning:\n+\n+@table @samp\n+@item maybe_lt(@var{a}, @var{b})\n+Return true if @var{a} might be less than @var{b}.\n+\n+@item maybe_le(@var{a}, @var{b})\n+Return true if @var{a} might be less than or equal to @var{b}.\n+\n+@item maybe_eq(@var{a}, @var{b})\n+Return true if @var{a} might be equal to @var{b}.\n+\n+@item maybe_ne(@var{a}, @var{b})\n+Return true if @var{a} might not be equal to @var{b}.\n+\n+@item maybe_ge(@var{a}, @var{b})\n+Return true if @var{a} might be greater than or equal to @var{b}.\n+\n+@item maybe_gt(@var{a}, @var{b})\n+Return true if @var{a} might be greater than @var{b}.\n+@end table\n+\n+For readability, @code{poly_int} also provides ``known'' inverses of these\n+functions:\n+\n+@example\n+known_lt (@var{a}, @var{b}) == !maybe_ge (@var{a}, @var{b})\n+known_le (@var{a}, @var{b}) == !maybe_gt (@var{a}, @var{b})\n+known_eq (@var{a}, @var{b}) == !maybe_ne (@var{a}, @var{b})\n+known_ge (@var{a}, @var{b}) == !maybe_lt (@var{a}, @var{b})\n+known_gt (@var{a}, @var{b}) == !maybe_le (@var{a}, @var{b})\n+known_ne (@var{a}, @var{b}) == !maybe_eq (@var{a}, @var{b})\n+@end example\n+\n+@node Properties of the @code{poly_int} comparisons\n+@subsection Properties of the @code{poly_int} comparisons\n+\n+All ``maybe'' relations except @code{maybe_ne} are transitive, so for example:\n+\n+@smallexample\n+maybe_lt (@var{a}, @var{b}) && maybe_lt (@var{b}, @var{c}) implies maybe_lt (@var{a}, @var{c})\n+@end smallexample\n+\n+for all @var{a}, @var{b} and @var{c}.  @code{maybe_lt}, @code{maybe_gt}\n+and @code{maybe_ne} are irreflexive, so for example:\n+\n+@smallexample\n+!maybe_lt (@var{a}, @var{a})\n+@end smallexample\n+\n+is true for all @var{a}.  @code{maybe_le}, @code{maybe_eq} and @code{maybe_ge}\n+are reflexive, so for example:\n+\n+@smallexample\n+maybe_le (@var{a}, @var{a})\n+@end smallexample\n+\n+is true for all @var{a}.  @code{maybe_eq} and @code{maybe_ne} are symmetric, so:\n+\n+@smallexample\n+maybe_eq (@var{a}, @var{b}) == maybe_eq (@var{b}, @var{a})\n+maybe_ne (@var{a}, @var{b}) == maybe_ne (@var{b}, @var{a})\n+@end smallexample\n+\n+for all @var{a} and @var{b}.  In addition:\n+\n+@smallexample\n+maybe_le (@var{a}, @var{b}) == maybe_lt (@var{a}, @var{b}) || maybe_eq (@var{a}, @var{b})\n+maybe_ge (@var{a}, @var{b}) == maybe_gt (@var{a}, @var{b}) || maybe_eq (@var{a}, @var{b})\n+maybe_lt (@var{a}, @var{b}) == maybe_gt (@var{b}, @var{a})\n+maybe_le (@var{a}, @var{b}) == maybe_ge (@var{b}, @var{a})\n+@end smallexample\n+\n+However:\n+\n+@smallexample\n+maybe_le (@var{a}, @var{b}) && maybe_le (@var{b}, @var{a}) does not imply !maybe_ne (@var{a}, @var{b}) [== known_eq (@var{a}, @var{b})]\n+maybe_ge (@var{a}, @var{b}) && maybe_ge (@var{b}, @var{a}) does not imply !maybe_ne (@var{a}, @var{b}) [== known_eq (@var{a}, @var{b})]\n+@end smallexample\n+\n+One example is again @samp{@var{a} == 3 + 4@var{x}}\n+and @samp{@var{b} == 1 + 5@var{x}}, where @samp{maybe_le (@var{a}, @var{b})},\n+@samp{maybe_ge (@var{a}, @var{b})} and @samp{maybe_ne (@var{a}, @var{b})}\n+all hold.  @code{maybe_le} and @code{maybe_ge} are therefore not antisymetric\n+and do not form a partial order.\n+\n+From the above, it follows that:\n+\n+@itemize @bullet\n+@item\n+All ``known'' relations except @code{known_ne} are transitive.\n+\n+@item\n+@code{known_lt}, @code{known_ne} and @code{known_gt} are irreflexive.\n+\n+@item\n+@code{known_le}, @code{known_eq} and @code{known_ge} are reflexive.\n+@end itemize\n+\n+Also:\n+\n+@smallexample\n+known_lt (@var{a}, @var{b}) == known_gt (@var{b}, @var{a})\n+known_le (@var{a}, @var{b}) == known_ge (@var{b}, @var{a})\n+known_lt (@var{a}, @var{b}) implies !known_lt (@var{b}, @var{a})  [asymmetry]\n+known_gt (@var{a}, @var{b}) implies !known_gt (@var{b}, @var{a})\n+known_le (@var{a}, @var{b}) && known_le (@var{b}, @var{a}) == known_eq (@var{a}, @var{b}) [== !maybe_ne (@var{a}, @var{b})]\n+known_ge (@var{a}, @var{b}) && known_ge (@var{b}, @var{a}) == known_eq (@var{a}, @var{b}) [== !maybe_ne (@var{a}, @var{b})]\n+@end smallexample\n+\n+@code{known_le} and @code{known_ge} are therefore antisymmetric and are\n+partial orders.  However:\n+\n+@smallexample\n+known_le (@var{a}, @var{b}) does not imply known_lt (@var{a}, @var{b}) || known_eq (@var{a}, @var{b})\n+known_ge (@var{a}, @var{b}) does not imply known_gt (@var{a}, @var{b}) || known_eq (@var{a}, @var{b})\n+@end smallexample\n+\n+For example, @samp{known_le (4, 4 + 4@var{x})} holds because the runtime\n+indeterminate @var{x} is a nonnegative integer, but neither\n+@code{known_lt (4, 4 + 4@var{x})} nor @code{known_eq (4, 4 + 4@var{x})} hold.\n+\n+@node Comparing potentially-unordered @code{poly_int}s\n+@subsection Comparing potentially-unordered @code{poly_int}s\n+\n+In cases where there is no definite link between two @code{poly_int}s,\n+we can usually make a conservatively-correct assumption.  For example,\n+the conservative assumption for alias analysis is that two references\n+@emph{might} alias.\n+\n+One way of checking whether [@var{begin1}, @var{end1}) might overlap\n+[@var{begin2}, @var{end2}) using the @code{poly_int} comparisons is:\n+\n+@smallexample\n+maybe_gt (@var{end1}, @var{begin2}) && maybe_gt (@var{end2}, @var{begin1})\n+@end smallexample\n+\n+and another (equivalent) way is:\n+\n+@smallexample\n+!(known_le (@var{end1}, @var{begin2}) || known_le (@var{end2}, @var{begin1}))\n+@end smallexample\n+\n+However, in this particular example, it is better to use the range helper\n+functions instead.  @xref{Range checks on @code{poly_int}s}.\n+\n+@node Comparing ordered @code{poly_int}s\n+@subsection Comparing ordered @code{poly_int}s\n+\n+In cases where there is a definite link between two @code{poly_int}s,\n+such as the outer and inner sizes of subregs, we usually require the sizes\n+to be ordered by the @code{known_le} partial order.  @code{poly_int} provides\n+the following utility functions for ordered values:\n+\n+@table @samp\n+@item ordered_p (@var{a}, @var{b})\n+Return true if @var{a} and @var{b} are ordered by the @code{known_le}\n+partial order.\n+\n+@item ordered_min (@var{a}, @var{b})\n+Assert that @var{a} and @var{b} are ordered by @code{known_le} and return the\n+minimum of the two.  When using this function, please add a comment explaining\n+why the values are known to be ordered.\n+\n+@item ordered_max (@var{a}, @var{b})\n+Assert that @var{a} and @var{b} are ordered by @code{known_le} and return the\n+maximum of the two.  When using this function, please add a comment explaining\n+why the values are known to be ordered.\n+@end table\n+\n+For example, if a subreg has an outer mode of size @var{outer} and an\n+inner mode of size @var{inner}:\n+\n+@itemize @bullet\n+@item\n+the subreg is complete if known_eq (@var{inner}, @var{outer})\n+\n+@item\n+otherwise, the subreg is paradoxical if known_le (@var{inner}, @var{outer})\n+\n+@item\n+otherwise, the subreg is partial if known_le (@var{outer}, @var{inner})\n+\n+@item\n+otherwise, the subreg is ill-formed\n+@end itemize\n+\n+Thus the subreg is only valid if\n+@samp{ordered_p (@var{outer}, @var{inner})} is true.  If this condition\n+is already known to be true then:\n+\n+@itemize @bullet\n+@item\n+the subreg is complete if known_eq (@var{inner}, @var{outer})\n+\n+@item\n+the subreg is paradoxical if maybe_lt (@var{inner}, @var{outer})\n+\n+@item\n+the subreg is partial if maybe_lt (@var{outer}, @var{inner})\n+@end itemize\n+\n+with the three conditions being mutually exclusive.\n+\n+Code that checks whether a subreg is valid would therefore generally\n+check whether @code{ordered_p} holds (in addition to whatever other\n+checks are required for subreg validity).  Code that is dealing\n+with existing subregs can assert that @code{ordered_p} holds\n+and use either of the classifications above.\n+\n+@node Checking for a @code{poly_int} marker value\n+@subsection Checking for a @code{poly_int} marker value\n+\n+It is sometimes useful to have a special ``marker value'' that is not\n+meant to be taken literally.  For example, some code uses a size\n+of -1 to represent an unknown size, rather than having to carry around\n+a separate boolean to say whether the size is known.\n+\n+The best way of checking whether something is a marker value is\n+@code{known_eq}.  Conversely the best way of checking whether something\n+is @emph{not} a marker value is @code{maybe_ne}.\n+\n+Thus in the size example just mentioned, @samp{known_eq (size, -1)} would\n+check for an unknown size and @samp{maybe_ne (size, -1)} would check for a\n+known size.\n+\n+@node Range checks on @code{poly_int}s\n+@subsection Range checks on @code{poly_int}s\n+\n+As well as the core comparisons\n+(@pxref{Comparison functions for @code{poly_int}}), @code{poly_int} provides\n+utilities for various kinds of range check.  In each case the range\n+is represented by a start position and a size rather than a start\n+position and an end position; this is because the former is used\n+much more often than the latter in GCC@.  Also, the sizes can be\n+-1 (or all ones for unsigned sizes) to indicate a range with a known\n+start position but an unknown size.  All other sizes must be nonnegative.\n+A range of size 0 does not contain anything or overlap anything.\n+\n+@table @samp\n+@item known_size_p (@var{size})\n+Return true if @var{size} represents a known range size, false if it\n+is -1 or all ones (for signed and unsigned types respectively).\n+\n+@item ranges_maybe_overlap_p (@var{pos1}, @var{size1}, @var{pos2}, @var{size2})\n+Return true if the range described by @var{pos1} and @var{size1} @emph{might}\n+overlap the range described by @var{pos2} and @var{size2} (in other words,\n+return true if we cannot prove that the ranges are disjoint).\n+\n+@item ranges_known_overlap_p (@var{pos1}, @var{size1}, @var{pos2}, @var{size2})\n+Return true if the range described by @var{pos1} and @var{size1} is known to\n+overlap the range described by @var{pos2} and @var{size2}.\n+\n+@item known_subrange_p (@var{pos1}, @var{size1}, @var{pos2}, @var{size2})\n+Return true if the range described by @var{pos1} and @var{size1} is known to\n+be contained in the range described by @var{pos2} and @var{size2}.\n+\n+@item maybe_in_range_p (@var{value}, @var{pos}, @var{size})\n+Return true if @var{value} @emph{might} be in the range described by\n+@var{pos} and @var{size} (in other words, return true if we cannot\n+prove that @var{value} is outside that range).\n+\n+@item known_in_range_p (@var{value}, @var{pos}, @var{size})\n+Return true if @var{value} is known to be in the range described\n+by @var{pos} and @var{size}.\n+\n+@item endpoint_representable_p (@var{pos}, @var{size})\n+Return true if the range described by @var{pos} and @var{size} is\n+open-ended or if the endpoint (@var{pos} + @var{size}) is representable\n+in the same type as @var{pos} and @var{size}.  The function returns false\n+if adding @var{size} to @var{pos} makes conceptual sense but could overflow.\n+@end table\n+\n+There is also a @code{poly_int} version of the @code{IN_RANGE_P} macro:\n+\n+@table @samp\n+@item coeffs_in_range_p (@var{x}, @var{lower}, @var{upper})\n+Return true if every coefficient of @var{x} is in the inclusive range\n+[@var{lower}, @var{upper}].  This function can be useful when testing\n+whether an operation would cause the values of coefficients to\n+overflow.\n+\n+Note that the function does not indicate whether @var{x} itself is in the\n+given range.  @var{x} can be either a constant or a @code{poly_int}.\n+@end table\n+\n+@node Sorting @code{poly_int}s\n+@subsection Sorting @code{poly_int}s\n+\n+@code{poly_int} provides the following routine for sorting:\n+\n+@table @samp\n+@item compare_sizes_for_sort (@var{a}, @var{b})\n+Compare @var{a} and @var{b} in reverse lexicographical order (that is,\n+compare the highest-indexed coefficients first).  This can be useful when\n+sorting data structures, since it has the effect of separating constant\n+and non-constant values.  If all values are nonnegative, the constant\n+values come first.\n+\n+Note that the values do not necessarily end up in numerical order.\n+For example, @samp{1 + 1@var{x}} would come after @samp{100} in the sort order,\n+but may well be less than @samp{100} at run time.\n+@end table\n+\n+@node Arithmetic on @code{poly_int}s\n+@section Arithmetic on @code{poly_int}s\n+\n+Addition, subtraction, negation and bit inversion all work normally for\n+@code{poly_int}s.  Multiplication by a constant multiplier and left\n+shifting by a constant shift amount also work normally.  General\n+multiplication of two @code{poly_int}s is not supported and is not\n+useful in practice.\n+\n+Other operations are only conditionally supported: the operation\n+might succeed or might fail, depending on the inputs.\n+\n+This section describes both types of operation.\n+\n+@menu\n+* Using @code{poly_int} with C++ arithmetic operators::\n+* @code{wi} arithmetic on @code{poly_int}s::\n+* Division of @code{poly_int}s::\n+* Other @code{poly_int} arithmetic::\n+@end menu\n+\n+@node Using @code{poly_int} with C++ arithmetic operators\n+@subsection Using @code{poly_int} with C++ arithmetic operators\n+\n+The following C++ expressions are supported, where @var{p1} and @var{p2}\n+are @code{poly_int}s and where @var{c1} and @var{c2} are scalars:\n+\n+@smallexample\n+-@var{p1}\n+~@var{p1}\n+\n+@var{p1} + @var{p2}\n+@var{p1} + @var{c2}\n+@var{c1} + @var{p2}\n+\n+@var{p1} - @var{p2}\n+@var{p1} - @var{c2}\n+@var{c1} - @var{p2}\n+\n+@var{c1} * @var{p2}\n+@var{p1} * @var{c2}\n+\n+@var{p1} << @var{c2}\n+\n+@var{p1} += @var{p2}\n+@var{p1} += @var{c2}\n+\n+@var{p1} -= @var{p2}\n+@var{p1} -= @var{c2}\n+\n+@var{p1} *= @var{c2}\n+@var{p1} <<= @var{c2}\n+@end smallexample\n+\n+These arithmetic operations handle integer ranks in a similar way\n+to C++.  The main difference is that every coefficient narrower than\n+@code{HOST_WIDE_INT} promotes to @code{HOST_WIDE_INT}, whereas in\n+C++ everything narrower than @code{int} promotes to @code{int}.\n+For example:\n+\n+@smallexample\n+poly_uint16     + int          -> poly_int64\n+unsigned int    + poly_uint16  -> poly_int64\n+poly_int64      + int          -> poly_int64\n+poly_int32      + poly_uint64  -> poly_uint64\n+uint64          + poly_int64   -> poly_uint64\n+poly_offset_int + int32        -> poly_offset_int\n+offset_int      + poly_uint16  -> poly_offset_int\n+@end smallexample\n+\n+In the first two examples, both coefficients are narrower than\n+@code{HOST_WIDE_INT}, so the result has coefficients of type\n+@code{HOST_WIDE_INT}.  In the other examples, the coefficient\n+with the highest rank ``wins''.\n+\n+If one of the operands is @code{wide_int} or @code{poly_wide_int},\n+the rules are the same as for @code{wide_int} arithmetic.\n+\n+@node @code{wi} arithmetic on @code{poly_int}s\n+@subsection @code{wi} arithmetic on @code{poly_int}s\n+\n+As well as the C++ operators, @code{poly_int} supports the following\n+@code{wi} routines:\n+\n+@smallexample\n+wi::neg (@var{p1}, &@var{overflow})\n+\n+wi::add (@var{p1}, @var{p2})\n+wi::add (@var{p1}, @var{c2})\n+wi::add (@var{c1}, @var{p1})\n+wi::add (@var{p1}, @var{p2}, @var{sign}, &@var{overflow})\n+\n+wi::sub (@var{p1}, @var{p2})\n+wi::sub (@var{p1}, @var{c2})\n+wi::sub (@var{c1}, @var{p1})\n+wi::sub (@var{p1}, @var{p2}, @var{sign}, &@var{overflow})\n+\n+wi::mul (@var{p1}, @var{c2})\n+wi::mul (@var{c1}, @var{p1})\n+wi::mul (@var{p1}, @var{c2}, @var{sign}, &@var{overflow})\n+\n+wi::lshift (@var{p1}, @var{c2})\n+@end smallexample\n+\n+These routines just check whether overflow occurs on any individual\n+coefficient; it is not possible to know at compile time whether the\n+final runtime value would overflow.\n+\n+@node Division of @code{poly_int}s\n+@subsection Division of @code{poly_int}s\n+\n+Division of @code{poly_int}s is possible for certain inputs.  The functions\n+for division return true if the operation is possible and in most cases\n+return the results by pointer.  The routines are:\n+\n+@table @samp\n+@item multiple_p (@var{a}, @var{b})\n+@itemx multiple_p (@var{a}, @var{b}, &@var{quotient})\n+Return true if @var{a} is an exact multiple of @var{b}, storing the result\n+in @var{quotient} if so.  There are overloads for various combinations\n+of polynomial and constant @var{a}, @var{b} and @var{quotient}.\n+\n+@item constant_multiple_p (@var{a}, @var{b})\n+@itemx constant_multiple_p (@var{a}, @var{b}, &@var{quotient})\n+Like @code{multiple_p}, but also test whether the multiple is a\n+compile-time constant.\n+\n+@item can_div_trunc_p (@var{a}, @var{b}, &@var{quotient})\n+@itemx can_div_trunc_p (@var{a}, @var{b}, &@var{quotient}, &@var{remainder})\n+Return true if we can calculate @samp{trunc (@var{a} / @var{b})} at compile\n+time, storing the result in @var{quotient} and @var{remainder} if so.\n+\n+@item can_div_away_from_zero_p (@var{a}, @var{b}, &@var{quotient})\n+Return true if we can calculate @samp{@var{a} / @var{b}} at compile time,\n+rounding away from zero.  Store the result in @var{quotient} if so.\n+\n+Note that this is true if and only if @code{can_div_trunc_p} is true.\n+The only difference is in the rounding of the result.\n+@end table\n+\n+There is also an asserting form of division:\n+\n+@table @samp\n+@item exact_div (@var{a}, @var{b})\n+Assert that @var{a} is a multiple of @var{b} and return\n+@samp{@var{a} / @var{b}}.  The result is a @code{poly_int} if @var{a}\n+is a @code{poly_int}.\n+@end table\n+\n+@node Other @code{poly_int} arithmetic\n+@subsection Other @code{poly_int} arithmetic\n+\n+There are tentative routines for other operations besides division:\n+\n+@table @samp\n+@item can_ior_p (@var{a}, @var{b}, &@var{result})\n+Return true if we can calculate @samp{@var{a} | @var{b}} at compile time,\n+storing the result in @var{result} if so.\n+@end table\n+\n+Also, ANDs with a value @samp{(1 << @var{y}) - 1} or its inverse can be\n+treated as alignment operations.  @xref{Alignment of @code{poly_int}s}.\n+\n+In addition, the following miscellaneous routines are available:\n+\n+@table @samp\n+@item coeff_gcd (@var{a})\n+Return the greatest common divisor of all nonzero coefficients in\n+@var{a}, or zero if @var{a} is known to be zero.\n+\n+@item common_multiple (@var{a}, @var{b})\n+Return a value that is a multiple of both @var{a} and @var{b}, where\n+one value is a @code{poly_int} and the other is a scalar.  The result\n+will be the least common multiple for some indeterminate values but\n+not necessarily for all.\n+\n+@item force_common_multiple (@var{a}, @var{b})\n+Return a value that is a multiple of both @code{poly_int} @var{a} and\n+@code{poly_int} @var{b}, asserting that such a value exists.  The\n+result will be the least common multiple for some indeterminate values\n+but not necessarily for all.\n+\n+When using this routine, please add a comment explaining why the\n+assertion is known to hold.\n+@end table\n+\n+Please add any other operations that you find to be useful.\n+\n+@node Alignment of @code{poly_int}s\n+@section Alignment of @code{poly_int}s\n+\n+@code{poly_int} provides various routines for aligning values and for querying\n+misalignments.  In each case the alignment must be a power of 2.\n+\n+@table @samp\n+@item can_align_p (@var{value}, @var{align})\n+Return true if we can align @var{value} up or down to the nearest multiple\n+of @var{align} at compile time.  The answer is the same for both directions.\n+\n+@item can_align_down (@var{value}, @var{align}, &@var{aligned})\n+Return true if @code{can_align_p}; if so, set @var{aligned} to the greatest\n+aligned value that is less than or equal to @var{value}.\n+\n+@item can_align_up (@var{value}, @var{align}, &@var{aligned})\n+Return true if @code{can_align_p}; if so, set @var{aligned} to the lowest\n+aligned value that is greater than or equal to @var{value}.\n+\n+@item known_equal_after_align_down (@var{a}, @var{b}, @var{align})\n+Return true if we can align @var{a} and @var{b} down to the nearest\n+@var{align} boundary at compile time and if the two results are equal.\n+\n+@item known_equal_after_align_up (@var{a}, @var{b}, @var{align})\n+Return true if we can align @var{a} and @var{b} up to the nearest\n+@var{align} boundary at compile time and if the two results are equal.\n+\n+@item aligned_lower_bound (@var{value}, @var{align})\n+Return a result that is no greater than @var{value} and that is aligned\n+to @var{align}.  The result will the closest aligned value for some\n+indeterminate values but not necessarily for all.\n+\n+For example, suppose we are allocating an object of @var{size} bytes\n+in a downward-growing stack whose current limit is given by @var{limit}.\n+If the object requires @var{align} bytes of alignment, the new stack\n+limit is given by:\n+\n+@smallexample\n+aligned_lower_bound (@var{limit} - @var{size}, @var{align})\n+@end smallexample\n+\n+@item aligned_upper_bound (@var{value}, @var{align})\n+Likewise return a result that is no less than @var{value} and that is\n+aligned to @var{align}.  This is the routine that would be used for\n+upward-growing stacks in the scenario just described.\n+\n+@item known_misalignment (@var{value}, @var{align}, &@var{misalign})\n+Return true if we can calculate the misalignment of @var{value}\n+with respect to @var{align} at compile time, storing the result in\n+@var{misalign} if so.\n+\n+@item known_alignment (@var{value})\n+Return the minimum alignment that @var{value} is known to have\n+(in other words, the largest alignment that can be guaranteed\n+whatever the values of the indeterminates turn out to be).\n+Return 0 if @var{value} is known to be 0.\n+\n+@item force_align_down (@var{value}, @var{align})\n+Assert that @var{value} can be aligned down to @var{align} at compile\n+time and return the result.  When using this routine, please add a\n+comment explaining why the assertion is known to hold.\n+\n+@item force_align_up (@var{value}, @var{align})\n+Likewise, but aligning up.\n+\n+@item force_align_down_and_div (@var{value}, @var{align})\n+Divide the result of @code{force_align_down} by @var{align}.  Again,\n+please add a comment explaining why the assertion in @code{force_align_down}\n+is known to hold.\n+\n+@item force_align_up_and_div (@var{value}, @var{align})\n+Likewise for @code{force_align_up}.\n+\n+@item force_get_misalignment (@var{value}, @var{align})\n+Assert that we can calculate the misalignment of @var{value} with\n+respect to @var{align} at compile time and return the misalignment.\n+When using this function, please add a comment explaining why\n+the assertion is known to hold.\n+@end table\n+\n+@node Computing bounds on @code{poly_int}s\n+@section Computing bounds on @code{poly_int}s\n+\n+@code{poly_int} also provides routines for calculating lower and upper bounds:\n+\n+@table @samp\n+@item constant_lower_bound (@var{a})\n+Assert that @var{a} is nonnegative and return the smallest value it can have.\n+\n+@item lower_bound (@var{a}, @var{b})\n+Return a value that is always less than or equal to both @var{a} and @var{b}.\n+It will be the greatest such value for some indeterminate values\n+but necessarily for all.\n+\n+@item upper_bound (@var{a}, @var{b})\n+Return a value that is always greater than or equal to both @var{a} and\n+@var{b}.  It will be the least such value for some indeterminate values\n+but necessarily for all.\n+@end table\n+\n+@node Converting @code{poly_int}s\n+@section Converting @code{poly_int}s\n+\n+A @code{poly_int<@var{n}, @var{T}>} can be constructed from up to\n+@var{n} individual @var{T} coefficients, with the remaining coefficients\n+being implicitly zero.  In particular, this means that every\n+@code{poly_int<@var{n}, @var{T}>} can be constructed from a single\n+scalar @var{T}, or something compatible with @var{T}.\n+\n+Also, a @code{poly_int<@var{n}, @var{T}>} can be constructed from\n+a @code{poly_int<@var{n}, @var{U}>} if @var{T} can be constructed\n+from @var{U}.\n+\n+The following functions provide other forms of conversion,\n+or test whether such a conversion would succeed.\n+\n+@table @samp\n+@item @var{value}.is_constant ()\n+Return true if @code{poly_int} @var{value} is a compile-time constant.\n+\n+@item @var{value}.is_constant (&@var{c1})\n+Return true if @code{poly_int} @var{value} is a compile-time constant,\n+storing it in @var{c1} if so.  @var{c1} must be able to hold all\n+constant values of @var{value} without loss of precision.\n+\n+@item @var{value}.to_constant ()\n+Assert that @var{value} is a compile-time constant and return its value.\n+When using this function, please add a comment explaining why the\n+condition is known to hold (for example, because an earlier phase\n+of analysis rejected non-constants).\n+\n+@item @var{value}.to_shwi (&@var{p2})\n+Return true if @samp{poly_int<@var{N}, @var{T}>} @var{value} can be\n+represented without loss of precision as a\n+@samp{poly_int<@var{N}, @code{HOST_WIDE_INT}>}, storing it in that\n+form in @var{p2} if so.\n+\n+@item @var{value}.to_uhwi (&@var{p2})\n+Return true if @samp{poly_int<@var{N}, @var{T}>} @var{value} can be\n+represented without loss of precision as a\n+@samp{poly_int<@var{N}, @code{unsigned HOST_WIDE_INT}>}, storing it in that\n+form in @var{p2} if so.\n+\n+@item @var{value}.force_shwi ()\n+Forcibly convert each coefficient of @samp{poly_int<@var{N}, @var{T}>}\n+@var{value} to @code{HOST_WIDE_INT}, truncating any that are out of range.\n+Return the result as a @samp{poly_int<@var{N}, @code{HOST_WIDE_INT}>}.\n+\n+@item @var{value}.force_uhwi ()\n+Forcibly convert each coefficient of @samp{poly_int<@var{N}, @var{T}>}\n+@var{value} to @code{unsigned HOST_WIDE_INT}, truncating any that are\n+out of range.  Return the result as a\n+@samp{poly_int<@var{N}, @code{unsigned HOST_WIDE_INT}>}.\n+\n+@item wi::shwi (@var{value}, @var{precision})\n+Return a @code{poly_int} with the same value as @var{value}, but with\n+the coefficients converted from @code{HOST_WIDE_INT} to @code{wide_int}.\n+@var{precision} specifies the precision of the @code{wide_int} cofficients;\n+if this is wider than a @code{HOST_WIDE_INT}, the coefficients of\n+@var{value} will be sign-extended to fit.\n+\n+@item wi::uhwi (@var{value}, @var{precision})\n+Like @code{wi::shwi}, except that @var{value} has coefficients of\n+type @code{unsigned HOST_WIDE_INT}.  If @var{precision} is wider than\n+a @code{HOST_WIDE_INT}, the coefficients of @var{value} will be\n+zero-extended to fit.\n+\n+@item wi::sext (@var{value}, @var{precision})\n+Return a @code{poly_int} of the same type as @var{value}, sign-extending\n+every coefficient from the low @var{precision} bits.  This in effect\n+applies @code{wi::sext} to each coefficient individually.\n+\n+@item wi::zext (@var{value}, @var{precision})\n+Like @code{wi::sext}, but for zero extension.\n+\n+@item poly_wide_int::from (@var{value}, @var{precision}, @var{sign})\n+Convert @var{value} to a @code{poly_wide_int} in which each coefficient\n+has @var{precision} bits.  Extend the coefficients according to\n+@var{sign} if the coefficients have fewer bits.\n+\n+@item poly_offset_int::from (@var{value}, @var{sign})\n+Convert @var{value} to a @code{poly_offset_int}, extending its coefficients\n+according to @var{sign} if they have fewer bits than @code{offset_int}.\n+\n+@item poly_widest_int::from (@var{value}, @var{sign})\n+Convert @var{value} to a @code{poly_widest_int}, extending its coefficients\n+according to @var{sign} if they have fewer bits than @code{widest_int}.\n+@end table\n+\n+@node Miscellaneous @code{poly_int} routines\n+@section Miscellaneous @code{poly_int} routines\n+\n+@table @samp\n+@item print_dec (@var{value}, @var{file}, @var{sign})\n+@itemx print_dec (@var{value}, @var{file})\n+Print @var{value} to @var{file} as a decimal value, interpreting\n+the coefficients according to @var{sign}.  The final argument is\n+optional if @var{value} has an inherent sign; for example,\n+@code{poly_int64} values print as signed by default and\n+@code{poly_uint64} values print as unsigned by default.\n+\n+This is a simply a @code{poly_int} version of a wide-int routine.\n+@end table\n+\n+@node Guidelines for using @code{poly_int}\n+@section Guidelines for using @code{poly_int}\n+\n+One of the main design goals of @code{poly_int} was to make it easy\n+to write target-independent code that handles variable-sized registers\n+even when the current target has fixed-sized registers.  There are two\n+aspects to this:\n+\n+@itemize\n+@item\n+The set of @code{poly_int} operations should be complete enough that\n+the question in most cases becomes ``Can we do this operation on these\n+particular @code{poly_int} values?  If not, bail out'' rather than\n+``Are these @code{poly_int} values constant?  If so, do the operation,\n+otherwise bail out''.\n+\n+@item\n+If target-independent code compiles and runs correctly on a target\n+with one value of @code{NUM_POLY_INT_COEFFS}, and if the code does not\n+use asserting functions like @code{to_constant}, it is reasonable to\n+assume that the code also works on targets with other values of\n+@code{NUM_POLY_INT_COEFFS}.  There is no need to check this during\n+everyday development.\n+@end itemize\n+\n+So the general principle is: if target-independent code is dealing\n+with a @code{poly_int} value, it is better to operate on it as a\n+@code{poly_int} if at all possible, choosing conservatively-correct\n+behavior if a particular operation fails.  For example, the following\n+code handles an index @code{pos} into a sequence of vectors that each\n+have @code{nunits} elements:\n+\n+@smallexample\n+/* Calculate which vector contains the result, and which lane of\n+   that vector we need.  */\n+if (!can_div_trunc_p (pos, nunits, &vec_entry, &vec_index))\n+  @{\n+    if (dump_enabled_p ())\n+      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                       \"Cannot determine which vector holds the\"\n+                       \" final result.\\n\");\n+    return false;\n+  @}\n+@end smallexample\n+\n+However, there are some contexts in which operating on a\n+@code{poly_int} is not possible or does not make sense.  One example\n+is when handling static initializers, since no current target supports\n+the concept of a variable-length static initializer.  In these\n+situations, a reasonable fallback is:\n+\n+@smallexample\n+if (@var{poly_value}.is_constant (&@var{const_value}))\n+  @{\n+    @dots{}\n+    /* Operate on @var{const_value}.  */\n+    @dots{}\n+  @}\n+else\n+  @{\n+    @dots{}\n+    /* Conservatively correct fallback.  */\n+    @dots{}\n+  @}\n+@end smallexample\n+\n+@code{poly_int} also provides some asserting functions like\n+@code{to_constant}.  Please only use these functions if there is a\n+good theoretical reason to believe that the assertion cannot fire.\n+For example, if some work is divided into an analysis phase and an\n+implementation phase, the analysis phase might reject inputs that are\n+not @code{is_constant}, in which case the implementation phase can\n+reasonably use @code{to_constant} on the remaining inputs.  The assertions\n+should not be used to discover whether a condition ever occurs ``in the\n+field''; in other words, they should not be used to restrict code to\n+constants at first, with the intention of only implementing a\n+@code{poly_int} version if a user hits the assertion.\n+\n+If a particular asserting function like @code{to_constant} is needed\n+more than once for the same reason, it is probably worth adding a\n+helper function or macro for that situation, so that the justification\n+only needs to be given once.  For example:\n+\n+@smallexample\n+/* Return the size of an element in a vector of size SIZE, given that\n+   the vector has NELTS elements.  The return value is in the same units\n+   as SIZE (either bits or bytes).\n+\n+   to_constant () is safe in this situation because vector elements are\n+   always constant-sized scalars.  */\n+#define vector_element_size(SIZE, NELTS) \\\n+  (exact_div (SIZE, NELTS).to_constant ())\n+@end smallexample\n+\n+Target-specific code in @file{config/@var{cpu}} only needs to handle\n+non-constant @code{poly_int}s if @code{NUM_POLY_INT_COEFFS} is greater\n+than one.  For other targets, @code{poly_int} degenerates to a compile-time\n+constant and is often interchangable with a normal scalar integer.\n+There are two main exceptions:\n+\n+@itemize\n+@item\n+Sometimes an explicit cast to an integer type might be needed, such as to\n+resolve ambiguities in a @code{?:} expression, or when passing values\n+through @code{...} to things like print functions.\n+\n+@item\n+Target macros are included in target-independent code and so do not\n+have access to the implicit conversion to a scalar integer.\n+If this becomes a problem for a particular target macro, the\n+possible solutions, in order of preference, are:\n+\n+@itemize\n+@item\n+Convert the target macro to a target hook (for all targets).\n+\n+@item\n+Put the target's implementation of the target macro in its\n+@file{@var{cpu}.c} file and call it from the target macro in the\n+@file{@var{cpu}.h} file.\n+\n+@item\n+Add @code{to_constant ()} calls where necessary.  The previous option\n+is preferable because it will help with any future conversion of the\n+macro to a hook.\n+@end itemize\n+@end itemize\n+"}, {"sha": "c28bdd5149bc8e5a997619e3b03d7028f4df0b8f", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -2067,6 +2067,15 @@ TARGET_CAN_CHANGE_MODE_CLASS (@var{m2}, @var{m1}, @var{class})\n \n must be false for every class @var{class} that includes @var{reg}.\n \n+GCC must be able to determine at compile time whether a subreg is\n+paradoxical, whether it occupies a whole number of blocks, or whether\n+it is a lowpart of a block.  This means that certain combinations of\n+variable-sized mode are not permitted.  For example, if @var{m2}\n+holds @var{n} @code{SI} values, where @var{n} is greater than zero,\n+it is not possible to form a @code{DI} @code{subreg} of it; such a\n+@code{subreg} would be paradoxical when @var{n} is 1 but not when\n+@var{n} is greater than 1.\n+\n @findex SUBREG_REG\n @findex SUBREG_BYTE\n The first operand of a @code{subreg} expression is customarily accessed"}, {"sha": "45675e38d71cd351532ece56a003767721be87f2", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -6725,6 +6725,12 @@ delay slot branches filled using the basic filler is often still desirable\n as the delay slot can hide a pipeline bubble.\n @end deftypefn\n \n+@deftypefn {Target Hook} HOST_WIDE_INT TARGET_ESTIMATED_POLY_VALUE (poly_int64 @var{val})\n+Return an estimate of the runtime value of @var{val}, for use in\n+things like cost calculations or profiling frequencies.  The default\n+implementation returns the lowest possible value of @var{val}.\n+@end deftypefn\n+\n @node Scheduling\n @section Adjusting the Instruction Scheduler\n "}, {"sha": "ff0067360cdfc295f12494f6b15ecc378aa61ff8", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -4607,6 +4607,8 @@ Define this macro if a non-short-circuit operation produced by\n \n @hook TARGET_NO_SPECULATION_IN_DELAY_SLOTS_P\n \n+@hook TARGET_ESTIMATED_POLY_VALUE\n+\n @node Scheduling\n @section Adjusting the Instruction Scheduler\n "}, {"sha": "e7ee3ab1ad0f6e4c4da5e851fdfdb0a69a471a0c", "filename": "gcc/genmodes.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -781,6 +781,10 @@ create_modes (void)\n #endif\n }\n \n+#ifndef NUM_POLY_INT_COEFFS\n+#define NUM_POLY_INT_COEFFS 1\n+#endif\n+\n /* Processing.  */\n \n /* Sort a list of modes into the order needed for the WIDER field:\n@@ -1246,6 +1250,8 @@ enum machine_mode\\n{\");\n \n   printf (\"#define NUM_INT_N_ENTS %d\\n\", n_int_n_ents);\n \n+  printf (\"#define NUM_POLY_INT_COEFFS %d\\n\", NUM_POLY_INT_COEFFS);\n+\n   puts (\"\\\n \\n\\\n #endif /* insn-modes.h */\");"}, {"sha": "1c62ff88ff7bcc8e2f43923900ae817b388511ae", "filename": "gcc/poly-int-types.h", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Fpoly-int-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Fpoly-int-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpoly-int-types.h?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -0,0 +1,83 @@\n+/* Typedefs for polynomial integers used in GCC.\n+   Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef HAVE_POLY_INT_TYPES_H\n+#define HAVE_POLY_INT_TYPES_H\n+\n+typedef poly_int_pod<NUM_POLY_INT_COEFFS, unsigned short> poly_uint16_pod;\n+typedef poly_int_pod<NUM_POLY_INT_COEFFS, HOST_WIDE_INT> poly_int64_pod;\n+typedef poly_int_pod<NUM_POLY_INT_COEFFS,\n+\t\t     unsigned HOST_WIDE_INT> poly_uint64_pod;\n+typedef poly_int_pod<NUM_POLY_INT_COEFFS, offset_int> poly_offset_int_pod;\n+typedef poly_int_pod<NUM_POLY_INT_COEFFS, wide_int> poly_wide_int_pod;\n+typedef poly_int_pod<NUM_POLY_INT_COEFFS, widest_int> poly_widest_int_pod;\n+\n+typedef poly_int<NUM_POLY_INT_COEFFS, unsigned short> poly_uint16;\n+typedef poly_int<NUM_POLY_INT_COEFFS, HOST_WIDE_INT> poly_int64;\n+typedef poly_int<NUM_POLY_INT_COEFFS, unsigned HOST_WIDE_INT> poly_uint64;\n+typedef poly_int<NUM_POLY_INT_COEFFS, offset_int> poly_offset_int;\n+typedef poly_int<NUM_POLY_INT_COEFFS, wide_int> poly_wide_int;\n+typedef poly_int<NUM_POLY_INT_COEFFS, wide_int_ref> poly_wide_int_ref;\n+typedef poly_int<NUM_POLY_INT_COEFFS, widest_int> poly_widest_int;\n+\n+/* Divide bit quantity X by BITS_PER_UNIT and round down (towards -Inf).\n+   If X is a bit size, this gives the number of whole bytes spanned by X.\n+\n+   This is safe because non-constant mode sizes must be a whole number\n+   of bytes in size.  */\n+#define bits_to_bytes_round_down(X) force_align_down_and_div (X, BITS_PER_UNIT)\n+\n+/* Divide bit quantity X by BITS_PER_UNIT and round up (towards +Inf).\n+   If X is a bit size, this gives the number of whole or partial bytes\n+   spanned by X.\n+\n+   This is safe because non-constant mode sizes must be a whole number\n+   of bytes in size.  */\n+#define bits_to_bytes_round_up(X) force_align_up_and_div (X, BITS_PER_UNIT)\n+\n+/* Return the number of bits in bit quantity X that do not belong to\n+   whole bytes.  This is equivalent to:\n+\n+       X - bits_to_bytes_round_down (X) * BITS_PER_UNIT\n+\n+   This is safe because non-constant mode sizes must be a whole number\n+   of bytes in size.  */\n+#define num_trailing_bits(X) force_get_misalignment (X, BITS_PER_UNIT)\n+\n+/* Return the size of an element in a vector of size SIZE, given that\n+   the vector has NELTS elements.  The return value is in the same units\n+   as SIZE (either bits or bytes).\n+\n+   to_constant () is safe in this situation because vector elements are\n+   always constant-sized scalars.  */\n+#define vector_element_size(SIZE, NELTS) \\\n+  (exact_div (SIZE, NELTS).to_constant ())\n+\n+/* Wrapper for poly_int arguments to target macros, so that if a target\n+   doesn't need polynomial-sized modes, its header file can continue to\n+   treat the argument as a normal constant.  This should go away once\n+   macros are moved to target hooks.  It shouldn't be used in other\n+   contexts.  */\n+#if NUM_POLY_INT_COEFFS == 1\n+#define MACRO_INT(X) ((X).to_constant ())\n+#else\n+#define MACRO_INT(X) (X)\n+#endif\n+\n+#endif"}, {"sha": "8472e519ecbd79766f4e4f2ce2701f5b3d625c9a", "filename": "gcc/poly-int.h", "status": "added", "additions": 2601, "deletions": 0, "changes": 2601, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Fpoly-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Fpoly-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpoly-int.h?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -0,0 +1,2601 @@\n+/* Polynomial integer classes.\n+   Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This file provides a representation of sizes and offsets whose exact\n+   values depend on certain runtime properties.  The motivating example\n+   is the Arm SVE ISA, in which the number of vector elements is only\n+   known at runtime.  See doc/poly-int.texi for more details.\n+\n+   Tests for poly-int.h are located in testsuite/gcc.dg/plugin,\n+   since they are too expensive (in terms of binary size) to be\n+   included as selftests.  */\n+\n+#ifndef HAVE_POLY_INT_H\n+#define HAVE_POLY_INT_H\n+\n+template<unsigned int N, typename T> class poly_int_pod;\n+template<unsigned int N, typename T> class poly_int;\n+\n+/* poly_coeff_traiits<T> describes the properties of a poly_int\n+   coefficient type T:\n+\n+   - poly_coeff_traits<T1>::rank is less than poly_coeff_traits<T2>::rank\n+     if T1 can promote to T2.  For C-like types the rank is:\n+\n+       (2 * number of bytes) + (unsigned ? 1 : 0)\n+\n+     wide_ints don't have a normal rank and so use a value of INT_MAX.\n+     Any fixed-width integer should be promoted to wide_int if possible\n+     and lead to an error otherwise.\n+\n+   - poly_coeff_traits<T>::int_type is the type to which an integer\n+     literal should be cast before comparing it with T.\n+\n+   - poly_coeff_traits<T>::precision is the number of bits that T can hold.\n+\n+   - poly_coeff_traits<T>::signedness is:\n+\t0 if T is unsigned\n+\t1 if T is signed\n+       -1 if T has no inherent sign (as for wide_int).\n+\n+   - poly_coeff_traits<T>::max_value, if defined, is the maximum value of T.\n+\n+   - poly_coeff_traits<T>::result is a type that can hold results of\n+     operations on T.  This is different from T itself in cases where T\n+     is the result of an accessor like wi::to_offset.  */\n+template<typename T, wi::precision_type = wi::int_traits<T>::precision_type>\n+struct poly_coeff_traits;\n+\n+template<typename T>\n+struct poly_coeff_traits<T, wi::FLEXIBLE_PRECISION>\n+{\n+  typedef T result;\n+  typedef T int_type;\n+  static const int signedness = (T (0) >= T (-1));\n+  static const int precision = sizeof (T) * CHAR_BIT;\n+  static const T max_value = (signedness\n+\t\t\t      ? ((T (1) << (precision - 2))\n+\t\t\t\t + ((T (1) << (precision - 2)) - 1))\n+\t\t\t      : T (-1));\n+  static const int rank = sizeof (T) * 2 + !signedness;\n+};\n+\n+template<typename T>\n+struct poly_coeff_traits<T, wi::VAR_PRECISION>\n+{\n+  typedef T result;\n+  typedef int int_type;\n+  static const int signedness = -1;\n+  static const int precision = WIDE_INT_MAX_PRECISION;\n+  static const int rank = INT_MAX;\n+};\n+\n+template<typename T>\n+struct poly_coeff_traits<T, wi::CONST_PRECISION>\n+{\n+  typedef WI_UNARY_RESULT (T) result;\n+  typedef int int_type;\n+  /* These types are always signed.  */\n+  static const int signedness = 1;\n+  static const int precision = wi::int_traits<T>::precision;\n+  static const int rank = precision * 2 / CHAR_BIT;\n+};\n+\n+/* Information about a pair of coefficient types.  */\n+template<typename T1, typename T2>\n+struct poly_coeff_pair_traits\n+{\n+  /* True if T1 can represent all the values of T2.\n+\n+     Either:\n+\n+     - T1 should be a type with the same signedness as T2 and no less\n+       precision.  This allows things like int16_t -> int16_t and\n+       uint32_t -> uint64_t.\n+\n+     - T1 should be signed, T2 should be unsigned, and T1 should be\n+       wider than T2.  This allows things like uint16_t -> int32_t.\n+\n+     This rules out cases in which T1 has less precision than T2 or where\n+     the conversion would reinterpret the top bit.  E.g. int16_t -> uint32_t\n+     can be dangerous and should have an explicit cast if deliberate.  */\n+  static const bool lossless_p = (poly_coeff_traits<T1>::signedness\n+\t\t\t\t  == poly_coeff_traits<T2>::signedness\n+\t\t\t\t  ? (poly_coeff_traits<T1>::precision\n+\t\t\t\t     >= poly_coeff_traits<T2>::precision)\n+\t\t\t\t  : (poly_coeff_traits<T1>::signedness == 1\n+\t\t\t\t     && poly_coeff_traits<T2>::signedness == 0\n+\t\t\t\t     && (poly_coeff_traits<T1>::precision\n+\t\t\t\t\t > poly_coeff_traits<T2>::precision)));\n+\n+  /* 0 if T1 op T2 should promote to HOST_WIDE_INT,\n+     1 if T1 op T2 should promote to unsigned HOST_WIDE_INT,\n+     2 if T1 op T2 should use wide-int rules.  */\n+#define RANK(X) poly_coeff_traits<X>::rank\n+  static const int result_kind\n+    = ((RANK (T1) <= RANK (HOST_WIDE_INT)\n+\t&& RANK (T2) <= RANK (HOST_WIDE_INT))\n+       ? 0\n+       : (RANK (T1) <= RANK (unsigned HOST_WIDE_INT)\n+\t  && RANK (T2) <= RANK (unsigned HOST_WIDE_INT))\n+       ? 1 : 2);\n+#undef RANK\n+};\n+\n+/* SFINAE class that makes T3 available as \"type\" if T2 can represent all the\n+   values in T1.  */\n+template<typename T1, typename T2, typename T3,\n+\t bool lossless_p = poly_coeff_pair_traits<T1, T2>::lossless_p>\n+struct if_lossless;\n+template<typename T1, typename T2, typename T3>\n+struct if_lossless<T1, T2, T3, true>\n+{\n+  typedef T3 type;\n+};\n+\n+/* poly_int_traits<T> describes an integer type T that might be polynomial\n+   or non-polynomial:\n+\n+   - poly_int_traits<T>::is_poly is true if T is a poly_int-based type\n+     and false otherwise.\n+\n+   - poly_int_traits<T>::num_coeffs gives the number of coefficients in T\n+     if T is a poly_int and 1 otherwise.\n+\n+   - poly_int_traits<T>::coeff_type gives the coefficent type of T if T\n+     is a poly_int and T itself otherwise\n+\n+   - poly_int_traits<T>::int_type is a shorthand for\n+     typename poly_coeff_traits<coeff_type>::int_type.  */\n+template<typename T>\n+struct poly_int_traits\n+{\n+  static const bool is_poly = false;\n+  static const unsigned int num_coeffs = 1;\n+  typedef T coeff_type;\n+  typedef typename poly_coeff_traits<T>::int_type int_type;\n+};\n+template<unsigned int N, typename C>\n+struct poly_int_traits<poly_int_pod<N, C> >\n+{\n+  static const bool is_poly = true;\n+  static const unsigned int num_coeffs = N;\n+  typedef C coeff_type;\n+  typedef typename poly_coeff_traits<C>::int_type int_type;\n+};\n+template<unsigned int N, typename C>\n+struct poly_int_traits<poly_int<N, C> > : poly_int_traits<poly_int_pod<N, C> >\n+{\n+};\n+\n+/* SFINAE class that makes T2 available as \"type\" if T1 is a non-polynomial\n+   type.  */\n+template<typename T1, typename T2 = T1,\n+\t bool is_poly = poly_int_traits<T1>::is_poly>\n+struct if_nonpoly {};\n+template<typename T1, typename T2>\n+struct if_nonpoly<T1, T2, false>\n+{\n+  typedef T2 type;\n+};\n+\n+/* SFINAE class that makes T3 available as \"type\" if both T1 and T2 are\n+   non-polynomial types.  */\n+template<typename T1, typename T2, typename T3,\n+\t bool is_poly1 = poly_int_traits<T1>::is_poly,\n+\t bool is_poly2 = poly_int_traits<T2>::is_poly>\n+struct if_nonpoly2 {};\n+template<typename T1, typename T2, typename T3>\n+struct if_nonpoly2<T1, T2, T3, false, false>\n+{\n+  typedef T3 type;\n+};\n+\n+/* SFINAE class that makes T2 available as \"type\" if T1 is a polynomial\n+   type.  */\n+template<typename T1, typename T2 = T1,\n+\t bool is_poly = poly_int_traits<T1>::is_poly>\n+struct if_poly {};\n+template<typename T1, typename T2>\n+struct if_poly<T1, T2, true>\n+{\n+  typedef T2 type;\n+};\n+\n+/* poly_result<T1, T2> describes the result of an operation on two\n+   types T1 and T2, where at least one of the types is polynomial:\n+\n+   - poly_result<T1, T2>::type gives the result type for the operation.\n+     The intention is to provide normal C-like rules for integer ranks,\n+     except that everything smaller than HOST_WIDE_INT promotes to\n+     HOST_WIDE_INT.\n+\n+   - poly_result<T1, T2>::cast is the type to which an operand of type\n+     T1 should be cast before doing the operation, to ensure that\n+     the operation is done at the right precision.  Casting to\n+     poly_result<T1, T2>::type would also work, but casting to this\n+     type is more efficient.  */\n+template<typename T1, typename T2 = T1,\n+\t int result_kind = poly_coeff_pair_traits<T1, T2>::result_kind>\n+struct poly_result;\n+\n+/* Promote pair to HOST_WIDE_INT.  */\n+template<typename T1, typename T2>\n+struct poly_result<T1, T2, 0>\n+{\n+  typedef HOST_WIDE_INT type;\n+  /* T1 and T2 are primitive types, so cast values to T before operating\n+     on them.  */\n+  typedef type cast;\n+};\n+\n+/* Promote pair to unsigned HOST_WIDE_INT.  */\n+template<typename T1, typename T2>\n+struct poly_result<T1, T2, 1>\n+{\n+  typedef unsigned HOST_WIDE_INT type;\n+  /* T1 and T2 are primitive types, so cast values to T before operating\n+     on them.  */\n+  typedef type cast;\n+};\n+\n+/* Use normal wide-int rules.  */\n+template<typename T1, typename T2>\n+struct poly_result<T1, T2, 2>\n+{\n+  typedef WI_BINARY_RESULT (T1, T2) type;\n+  /* Don't cast values before operating on them; leave the wi:: routines\n+     to handle promotion as necessary.  */\n+  typedef const T1 &cast;\n+};\n+\n+/* The coefficient type for the result of a binary operation on two\n+   poly_ints, the first of which has coefficients of type C1 and the\n+   second of which has coefficients of type C2.  */\n+#define POLY_POLY_COEFF(C1, C2) typename poly_result<C1, C2>::type\n+\n+/* Enforce that T2 is non-polynomial and provide the cofficient type of\n+   the result of a binary operation in which the first operand is a\n+   poly_int with coefficients of type C1 and the second operand is\n+   a constant of type T2.  */\n+#define POLY_CONST_COEFF(C1, T2) \\\n+  POLY_POLY_COEFF (C1, typename if_nonpoly<T2>::type)\n+\n+/* Likewise in reverse.  */\n+#define CONST_POLY_COEFF(T1, C2) \\\n+  POLY_POLY_COEFF (typename if_nonpoly<T1>::type, C2)\n+\n+/* The result type for a binary operation on poly_int<N, C1> and\n+   poly_int<N, C2>.  */\n+#define POLY_POLY_RESULT(N, C1, C2) poly_int<N, POLY_POLY_COEFF (C1, C2)>\n+\n+/* Enforce that T2 is non-polynomial and provide the result type\n+   for a binary operation on poly_int<N, C1> and T2.  */\n+#define POLY_CONST_RESULT(N, C1, T2) poly_int<N, POLY_CONST_COEFF (C1, T2)>\n+\n+/* Enforce that T1 is non-polynomial and provide the result type\n+   for a binary operation on T1 and poly_int<N, C2>.  */\n+#define CONST_POLY_RESULT(N, T1, C2) poly_int<N, CONST_POLY_COEFF (T1, C2)>\n+\n+/* Enforce that T1 and T2 are non-polynomial and provide the result type\n+   for a binary operation on T1 and T2.  */\n+#define CONST_CONST_RESULT(N, T1, T2) \\\n+  POLY_POLY_COEFF (typename if_nonpoly<T1>::type, \\\n+\t\t   typename if_nonpoly<T2>::type)\n+\n+/* The type to which a coefficient of type C1 should be cast before\n+   using it in a binary operation with a coefficient of type C2.  */\n+#define POLY_CAST(C1, C2) typename poly_result<C1, C2>::cast\n+\n+/* Provide the coefficient type for the result of T1 op T2, where T1\n+   and T2 can be polynomial or non-polynomial.  */\n+#define POLY_BINARY_COEFF(T1, T2) \\\n+  typename poly_result<typename poly_int_traits<T1>::coeff_type, \\\n+\t\t       typename poly_int_traits<T2>::coeff_type>::type\n+\n+/* The type to which an integer constant should be cast before\n+   comparing it with T.  */\n+#define POLY_INT_TYPE(T) typename poly_int_traits<T>::int_type\n+\n+/* RES is a poly_int result that has coefficients of type C and that\n+   is being built up a coefficient at a time.  Set coefficient number I\n+   to VALUE in the most efficient way possible.\n+\n+   For primitive C it is better to assign directly, since it avoids\n+   any further calls and so is more efficient when the compiler is\n+   built at -O0.  But for wide-int based C it is better to construct\n+   the value in-place.  This means that calls out to a wide-int.cc\n+   routine can take the address of RES rather than the address of\n+   a temporary.\n+\n+   The dummy comparison against a null C * is just a way of checking\n+   that C gives the right type.  */\n+#define POLY_SET_COEFF(C, RES, I, VALUE) \\\n+  ((void) (&(RES).coeffs[0] == (C *) 0), \\\n+   wi::int_traits<C>::precision_type == wi::FLEXIBLE_PRECISION \\\n+   ? (void) ((RES).coeffs[I] = VALUE) \\\n+   : (void) ((RES).coeffs[I].~C (), new (&(RES).coeffs[I]) C (VALUE)))\n+\n+/* A base POD class for polynomial integers.  The polynomial has N\n+   coefficients of type C.  */\n+template<unsigned int N, typename C>\n+class poly_int_pod\n+{\n+public:\n+  template<typename Ca>\n+  poly_int_pod &operator = (const poly_int_pod<N, Ca> &);\n+  template<typename Ca>\n+  typename if_nonpoly<Ca, poly_int_pod>::type &operator = (const Ca &);\n+\n+  template<typename Ca>\n+  poly_int_pod &operator += (const poly_int_pod<N, Ca> &);\n+  template<typename Ca>\n+  typename if_nonpoly<Ca, poly_int_pod>::type &operator += (const Ca &);\n+\n+  template<typename Ca>\n+  poly_int_pod &operator -= (const poly_int_pod<N, Ca> &);\n+  template<typename Ca>\n+  typename if_nonpoly<Ca, poly_int_pod>::type &operator -= (const Ca &);\n+\n+  template<typename Ca>\n+  typename if_nonpoly<Ca, poly_int_pod>::type &operator *= (const Ca &);\n+\n+  poly_int_pod &operator <<= (unsigned int);\n+\n+  bool is_constant () const;\n+\n+  template<typename T>\n+  typename if_lossless<T, C, bool>::type is_constant (T *) const;\n+\n+  C to_constant () const;\n+\n+  template<typename Ca>\n+  static poly_int<N, C> from (const poly_int_pod<N, Ca> &, unsigned int,\n+\t\t\t      signop);\n+  template<typename Ca>\n+  static poly_int<N, C> from (const poly_int_pod<N, Ca> &, signop);\n+\n+  bool to_shwi (poly_int_pod<N, HOST_WIDE_INT> *) const;\n+  bool to_uhwi (poly_int_pod<N, unsigned HOST_WIDE_INT> *) const;\n+  poly_int<N, HOST_WIDE_INT> force_shwi () const;\n+  poly_int<N, unsigned HOST_WIDE_INT> force_uhwi () const;\n+\n+#if POLY_INT_CONVERSION\n+  operator C () const;\n+#endif\n+\n+  C coeffs[N];\n+};\n+\n+template<unsigned int N, typename C>\n+template<typename Ca>\n+inline poly_int_pod<N, C>&\n+poly_int_pod<N, C>::operator = (const poly_int_pod<N, Ca> &a)\n+{\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (C, *this, i, a.coeffs[i]);\n+  return *this;\n+}\n+\n+template<unsigned int N, typename C>\n+template<typename Ca>\n+inline typename if_nonpoly<Ca, poly_int_pod<N, C> >::type &\n+poly_int_pod<N, C>::operator = (const Ca &a)\n+{\n+  POLY_SET_COEFF (C, *this, 0, a);\n+  if (N >= 2)\n+    for (unsigned int i = 1; i < N; i++)\n+      POLY_SET_COEFF (C, *this, i, wi::ints_for<C>::zero (this->coeffs[0]));\n+  return *this;\n+}\n+\n+template<unsigned int N, typename C>\n+template<typename Ca>\n+inline poly_int_pod<N, C>&\n+poly_int_pod<N, C>::operator += (const poly_int_pod<N, Ca> &a)\n+{\n+  for (unsigned int i = 0; i < N; i++)\n+    this->coeffs[i] += a.coeffs[i];\n+  return *this;\n+}\n+\n+template<unsigned int N, typename C>\n+template<typename Ca>\n+inline typename if_nonpoly<Ca, poly_int_pod<N, C> >::type &\n+poly_int_pod<N, C>::operator += (const Ca &a)\n+{\n+  this->coeffs[0] += a;\n+  return *this;\n+}\n+\n+template<unsigned int N, typename C>\n+template<typename Ca>\n+inline poly_int_pod<N, C>&\n+poly_int_pod<N, C>::operator -= (const poly_int_pod<N, Ca> &a)\n+{\n+  for (unsigned int i = 0; i < N; i++)\n+    this->coeffs[i] -= a.coeffs[i];\n+  return *this;\n+}\n+\n+template<unsigned int N, typename C>\n+template<typename Ca>\n+inline typename if_nonpoly<Ca, poly_int_pod<N, C> >::type &\n+poly_int_pod<N, C>::operator -= (const Ca &a)\n+{\n+  this->coeffs[0] -= a;\n+  return *this;\n+}\n+\n+template<unsigned int N, typename C>\n+template<typename Ca>\n+inline typename if_nonpoly<Ca, poly_int_pod<N, C> >::type &\n+poly_int_pod<N, C>::operator *= (const Ca &a)\n+{\n+  for (unsigned int i = 0; i < N; i++)\n+    this->coeffs[i] *= a;\n+  return *this;\n+}\n+\n+template<unsigned int N, typename C>\n+inline poly_int_pod<N, C>&\n+poly_int_pod<N, C>::operator <<= (unsigned int a)\n+{\n+  for (unsigned int i = 0; i < N; i++)\n+    this->coeffs[i] <<= a;\n+  return *this;\n+}\n+\n+/* Return true if the polynomial value is a compile-time constant.  */\n+\n+template<unsigned int N, typename C>\n+inline bool\n+poly_int_pod<N, C>::is_constant () const\n+{\n+  if (N >= 2)\n+    for (unsigned int i = 1; i < N; i++)\n+      if (this->coeffs[i] != 0)\n+\treturn false;\n+  return true;\n+}\n+\n+/* Return true if the polynomial value is a compile-time constant,\n+   storing its value in CONST_VALUE if so.  */\n+\n+template<unsigned int N, typename C>\n+template<typename T>\n+inline typename if_lossless<T, C, bool>::type\n+poly_int_pod<N, C>::is_constant (T *const_value) const\n+{\n+  if (is_constant ())\n+    {\n+      *const_value = this->coeffs[0];\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Return the value of a polynomial that is already known to be a\n+   compile-time constant.\n+\n+   NOTE: When using this function, please add a comment above the call\n+   explaining why we know the value is constant in that context.  */\n+\n+template<unsigned int N, typename C>\n+inline C\n+poly_int_pod<N, C>::to_constant () const\n+{\n+  gcc_checking_assert (is_constant ());\n+  return this->coeffs[0];\n+}\n+\n+/* Convert X to a wide_int-based polynomial in which each coefficient\n+   has BITSIZE bits.  If X's coefficients are smaller than BITSIZE,\n+   extend them according to SGN.  */\n+\n+template<unsigned int N, typename C>\n+template<typename Ca>\n+inline poly_int<N, C>\n+poly_int_pod<N, C>::from (const poly_int_pod<N, Ca> &a,\n+\t\t\t  unsigned int bitsize, signop sgn)\n+{\n+  poly_int<N, C> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (C, r, i, C::from (a.coeffs[i], bitsize, sgn));\n+  return r;\n+}\n+\n+/* Convert X to a fixed_wide_int-based polynomial, extending according\n+   to SGN.  */\n+\n+template<unsigned int N, typename C>\n+template<typename Ca>\n+inline poly_int<N, C>\n+poly_int_pod<N, C>::from (const poly_int_pod<N, Ca> &a, signop sgn)\n+{\n+  poly_int<N, C> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (C, r, i, C::from (a.coeffs[i], sgn));\n+  return r;\n+}\n+\n+/* Return true if the coefficients of this generic_wide_int-based\n+   polynomial can be represented as signed HOST_WIDE_INTs without loss\n+   of precision.  Store the HOST_WIDE_INT representation in *R if so.  */\n+\n+template<unsigned int N, typename C>\n+inline bool\n+poly_int_pod<N, C>::to_shwi (poly_int_pod<N, HOST_WIDE_INT> *r) const\n+{\n+  for (unsigned int i = 0; i < N; i++)\n+    if (!wi::fits_shwi_p (this->coeffs[i]))\n+      return false;\n+  for (unsigned int i = 0; i < N; i++)\n+    r->coeffs[i] = this->coeffs[i].to_shwi ();\n+  return true;\n+}\n+\n+/* Return true if the coefficients of this generic_wide_int-based\n+   polynomial can be represented as unsigned HOST_WIDE_INTs without\n+   loss of precision.  Store the unsigned HOST_WIDE_INT representation\n+   in *R if so.  */\n+\n+template<unsigned int N, typename C>\n+inline bool\n+poly_int_pod<N, C>::to_uhwi (poly_int_pod<N, unsigned HOST_WIDE_INT> *r) const\n+{\n+  for (unsigned int i = 0; i < N; i++)\n+    if (!wi::fits_uhwi_p (this->coeffs[i]))\n+      return false;\n+  for (unsigned int i = 0; i < N; i++)\n+    r->coeffs[i] = this->coeffs[i].to_uhwi ();\n+  return true;\n+}\n+\n+/* Force a generic_wide_int-based constant to HOST_WIDE_INT precision,\n+   truncating if necessary.  */\n+\n+template<unsigned int N, typename C>\n+inline poly_int<N, HOST_WIDE_INT>\n+poly_int_pod<N, C>::force_shwi () const\n+{\n+  poly_int_pod<N, HOST_WIDE_INT> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    r.coeffs[i] = this->coeffs[i].to_shwi ();\n+  return r;\n+}\n+\n+/* Force a generic_wide_int-based constant to unsigned HOST_WIDE_INT precision,\n+   truncating if necessary.  */\n+\n+template<unsigned int N, typename C>\n+inline poly_int<N, unsigned HOST_WIDE_INT>\n+poly_int_pod<N, C>::force_uhwi () const\n+{\n+  poly_int_pod<N, unsigned HOST_WIDE_INT> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    r.coeffs[i] = this->coeffs[i].to_uhwi ();\n+  return r;\n+}\n+\n+#if POLY_INT_CONVERSION\n+/* Provide a conversion operator to constants.  */\n+\n+template<unsigned int N, typename C>\n+inline\n+poly_int_pod<N, C>::operator C () const\n+{\n+  gcc_checking_assert (this->is_constant ());\n+  return this->coeffs[0];\n+}\n+#endif\n+\n+/* The main class for polynomial integers.  The class provides\n+   constructors that are necessarily missing from the POD base.  */\n+template<unsigned int N, typename C>\n+class poly_int : public poly_int_pod<N, C>\n+{\n+public:\n+  poly_int () {}\n+\n+  template<typename Ca>\n+  poly_int (const poly_int<N, Ca> &);\n+  template<typename Ca>\n+  poly_int (const poly_int_pod<N, Ca> &);\n+  template<typename C0>\n+  poly_int (const C0 &);\n+  template<typename C0, typename C1>\n+  poly_int (const C0 &, const C1 &);\n+\n+  template<typename Ca>\n+  poly_int &operator = (const poly_int_pod<N, Ca> &);\n+  template<typename Ca>\n+  typename if_nonpoly<Ca, poly_int>::type &operator = (const Ca &);\n+\n+  template<typename Ca>\n+  poly_int &operator += (const poly_int_pod<N, Ca> &);\n+  template<typename Ca>\n+  typename if_nonpoly<Ca, poly_int>::type &operator += (const Ca &);\n+\n+  template<typename Ca>\n+  poly_int &operator -= (const poly_int_pod<N, Ca> &);\n+  template<typename Ca>\n+  typename if_nonpoly<Ca, poly_int>::type &operator -= (const Ca &);\n+\n+  template<typename Ca>\n+  typename if_nonpoly<Ca, poly_int>::type &operator *= (const Ca &);\n+\n+  poly_int &operator <<= (unsigned int);\n+};\n+\n+template<unsigned int N, typename C>\n+template<typename Ca>\n+inline\n+poly_int<N, C>::poly_int (const poly_int<N, Ca> &a)\n+{\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (C, *this, i, a.coeffs[i]);\n+}\n+\n+template<unsigned int N, typename C>\n+template<typename Ca>\n+inline\n+poly_int<N, C>::poly_int (const poly_int_pod<N, Ca> &a)\n+{\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (C, *this, i, a.coeffs[i]);\n+}\n+\n+template<unsigned int N, typename C>\n+template<typename C0>\n+inline\n+poly_int<N, C>::poly_int (const C0 &c0)\n+{\n+  POLY_SET_COEFF (C, *this, 0, c0);\n+  for (unsigned int i = 1; i < N; i++)\n+    POLY_SET_COEFF (C, *this, i, wi::ints_for<C>::zero (this->coeffs[0]));\n+}\n+\n+template<unsigned int N, typename C>\n+template<typename C0, typename C1>\n+inline\n+poly_int<N, C>::poly_int (const C0 &c0, const C1 &c1)\n+{\n+  STATIC_ASSERT (N >= 2);\n+  POLY_SET_COEFF (C, *this, 0, c0);\n+  POLY_SET_COEFF (C, *this, 1, c1);\n+  for (unsigned int i = 2; i < N; i++)\n+    POLY_SET_COEFF (C, *this, i, wi::ints_for<C>::zero (this->coeffs[0]));\n+}\n+\n+template<unsigned int N, typename C>\n+template<typename Ca>\n+inline poly_int<N, C>&\n+poly_int<N, C>::operator = (const poly_int_pod<N, Ca> &a)\n+{\n+  for (unsigned int i = 0; i < N; i++)\n+    this->coeffs[i] = a.coeffs[i];\n+  return *this;\n+}\n+\n+template<unsigned int N, typename C>\n+template<typename Ca>\n+inline typename if_nonpoly<Ca, poly_int<N, C> >::type &\n+poly_int<N, C>::operator = (const Ca &a)\n+{\n+  this->coeffs[0] = a;\n+  if (N >= 2)\n+    for (unsigned int i = 1; i < N; i++)\n+      this->coeffs[i] = wi::ints_for<C>::zero (this->coeffs[0]);\n+  return *this;\n+}\n+\n+template<unsigned int N, typename C>\n+template<typename Ca>\n+inline poly_int<N, C>&\n+poly_int<N, C>::operator += (const poly_int_pod<N, Ca> &a)\n+{\n+  for (unsigned int i = 0; i < N; i++)\n+    this->coeffs[i] += a.coeffs[i];\n+  return *this;\n+}\n+\n+template<unsigned int N, typename C>\n+template<typename Ca>\n+inline typename if_nonpoly<Ca, poly_int<N, C> >::type &\n+poly_int<N, C>::operator += (const Ca &a)\n+{\n+  this->coeffs[0] += a;\n+  return *this;\n+}\n+\n+template<unsigned int N, typename C>\n+template<typename Ca>\n+inline poly_int<N, C>&\n+poly_int<N, C>::operator -= (const poly_int_pod<N, Ca> &a)\n+{\n+  for (unsigned int i = 0; i < N; i++)\n+    this->coeffs[i] -= a.coeffs[i];\n+  return *this;\n+}\n+\n+template<unsigned int N, typename C>\n+template<typename Ca>\n+inline typename if_nonpoly<Ca, poly_int<N, C> >::type &\n+poly_int<N, C>::operator -= (const Ca &a)\n+{\n+  this->coeffs[0] -= a;\n+  return *this;\n+}\n+\n+template<unsigned int N, typename C>\n+template<typename Ca>\n+inline typename if_nonpoly<Ca, poly_int<N, C> >::type &\n+poly_int<N, C>::operator *= (const Ca &a)\n+{\n+  for (unsigned int i = 0; i < N; i++)\n+    this->coeffs[i] *= a;\n+  return *this;\n+}\n+\n+template<unsigned int N, typename C>\n+inline poly_int<N, C>&\n+poly_int<N, C>::operator <<= (unsigned int a)\n+{\n+  for (unsigned int i = 0; i < N; i++)\n+    this->coeffs[i] <<= a;\n+  return *this;\n+}\n+\n+/* Return true if every coefficient of A is in the inclusive range [B, C].  */\n+\n+template<typename Ca, typename Cb, typename Cc>\n+inline typename if_nonpoly<Ca, bool>::type\n+coeffs_in_range_p (const Ca &a, const Cb &b, const Cc &c)\n+{\n+  return a >= b && a <= c;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb, typename Cc>\n+inline typename if_nonpoly<Ca, bool>::type\n+coeffs_in_range_p (const poly_int_pod<N, Ca> &a, const Cb &b, const Cc &c)\n+{\n+  for (unsigned int i = 0; i < N; i++)\n+    if (a.coeffs[i] < b || a.coeffs[i] > c)\n+      return false;\n+  return true;\n+}\n+\n+namespace wi {\n+/* Poly version of wi::shwi, with the same interface.  */\n+\n+template<unsigned int N>\n+inline poly_int<N, hwi_with_prec>\n+shwi (const poly_int_pod<N, HOST_WIDE_INT> &a, unsigned int precision)\n+{\n+  poly_int<N, hwi_with_prec> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (hwi_with_prec, r, i, wi::shwi (a.coeffs[i], precision));\n+  return r;\n+}\n+\n+/* Poly version of wi::uhwi, with the same interface.  */\n+\n+template<unsigned int N>\n+inline poly_int<N, hwi_with_prec>\n+uhwi (const poly_int_pod<N, unsigned HOST_WIDE_INT> &a, unsigned int precision)\n+{\n+  poly_int<N, hwi_with_prec> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (hwi_with_prec, r, i, wi::uhwi (a.coeffs[i], precision));\n+  return r;\n+}\n+\n+/* Poly version of wi::sext, with the same interface.  */\n+\n+template<unsigned int N, typename Ca>\n+inline POLY_POLY_RESULT (N, Ca, Ca)\n+sext (const poly_int_pod<N, Ca> &a, unsigned int precision)\n+{\n+  typedef POLY_POLY_COEFF (Ca, Ca) C;\n+  poly_int<N, C> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (C, r, i, wi::sext (a.coeffs[i], precision));\n+  return r;\n+}\n+\n+/* Poly version of wi::zext, with the same interface.  */\n+\n+template<unsigned int N, typename Ca>\n+inline POLY_POLY_RESULT (N, Ca, Ca)\n+zext (const poly_int_pod<N, Ca> &a, unsigned int precision)\n+{\n+  typedef POLY_POLY_COEFF (Ca, Ca) C;\n+  poly_int<N, C> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (C, r, i, wi::zext (a.coeffs[i], precision));\n+  return r;\n+}\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline POLY_POLY_RESULT (N, Ca, Cb)\n+operator + (const poly_int_pod<N, Ca> &a, const poly_int_pod<N, Cb> &b)\n+{\n+  typedef POLY_CAST (Ca, Cb) NCa;\n+  typedef POLY_POLY_COEFF (Ca, Cb) C;\n+  poly_int<N, C> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (C, r, i, NCa (a.coeffs[i]) + b.coeffs[i]);\n+  return r;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline POLY_CONST_RESULT (N, Ca, Cb)\n+operator + (const poly_int_pod<N, Ca> &a, const Cb &b)\n+{\n+  typedef POLY_CAST (Ca, Cb) NCa;\n+  typedef POLY_CONST_COEFF (Ca, Cb) C;\n+  poly_int<N, C> r;\n+  POLY_SET_COEFF (C, r, 0, NCa (a.coeffs[0]) + b);\n+  if (N >= 2)\n+    for (unsigned int i = 1; i < N; i++)\n+      POLY_SET_COEFF (C, r, i, NCa (a.coeffs[i]));\n+  return r;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline CONST_POLY_RESULT (N, Ca, Cb)\n+operator + (const Ca &a, const poly_int_pod<N, Cb> &b)\n+{\n+  typedef POLY_CAST (Cb, Ca) NCb;\n+  typedef CONST_POLY_COEFF (Ca, Cb) C;\n+  poly_int<N, C> r;\n+  POLY_SET_COEFF (C, r, 0, a + NCb (b.coeffs[0]));\n+  if (N >= 2)\n+    for (unsigned int i = 1; i < N; i++)\n+      POLY_SET_COEFF (C, r, i, NCb (b.coeffs[i]));\n+  return r;\n+}\n+\n+namespace wi {\n+/* Poly versions of wi::add, with the same interface.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline poly_int<N, WI_BINARY_RESULT (Ca, Cb)>\n+add (const poly_int_pod<N, Ca> &a, const poly_int_pod<N, Cb> &b)\n+{\n+  typedef WI_BINARY_RESULT (Ca, Cb) C;\n+  poly_int<N, C> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (C, r, i, wi::add (a.coeffs[i], b.coeffs[i]));\n+  return r;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline poly_int<N, WI_BINARY_RESULT (Ca, Cb)>\n+add (const poly_int_pod<N, Ca> &a, const Cb &b)\n+{\n+  typedef WI_BINARY_RESULT (Ca, Cb) C;\n+  poly_int<N, C> r;\n+  POLY_SET_COEFF (C, r, 0, wi::add (a.coeffs[0], b));\n+  for (unsigned int i = 1; i < N; i++)\n+    POLY_SET_COEFF (C, r, i, wi::add (a.coeffs[i],\n+\t\t\t\t      wi::ints_for<Cb>::zero (b)));\n+  return r;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline poly_int<N, WI_BINARY_RESULT (Ca, Cb)>\n+add (const Ca &a, const poly_int_pod<N, Cb> &b)\n+{\n+  typedef WI_BINARY_RESULT (Ca, Cb) C;\n+  poly_int<N, C> r;\n+  POLY_SET_COEFF (C, r, 0, wi::add (a, b.coeffs[0]));\n+  for (unsigned int i = 1; i < N; i++)\n+    POLY_SET_COEFF (C, r, i, wi::add (wi::ints_for<Ca>::zero (a),\n+\t\t\t\t      b.coeffs[i]));\n+  return r;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline poly_int<N, WI_BINARY_RESULT (Ca, Cb)>\n+add (const poly_int_pod<N, Ca> &a, const poly_int_pod<N, Cb> &b,\n+     signop sgn, bool *overflow)\n+{\n+  typedef WI_BINARY_RESULT (Ca, Cb) C;\n+  poly_int<N, C> r;\n+  POLY_SET_COEFF (C, r, 0, wi::add (a.coeffs[0], b.coeffs[0], sgn, overflow));\n+  for (unsigned int i = 1; i < N; i++)\n+    {\n+      bool suboverflow;\n+      POLY_SET_COEFF (C, r, i, wi::add (a.coeffs[i], b.coeffs[i], sgn,\n+\t\t\t\t\t&suboverflow));\n+      *overflow |= suboverflow;\n+    }\n+  return r;\n+}\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline POLY_POLY_RESULT (N, Ca, Cb)\n+operator - (const poly_int_pod<N, Ca> &a, const poly_int_pod<N, Cb> &b)\n+{\n+  typedef POLY_CAST (Ca, Cb) NCa;\n+  typedef POLY_POLY_COEFF (Ca, Cb) C;\n+  poly_int<N, C> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (C, r, i, NCa (a.coeffs[i]) - b.coeffs[i]);\n+  return r;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline POLY_CONST_RESULT (N, Ca, Cb)\n+operator - (const poly_int_pod<N, Ca> &a, const Cb &b)\n+{\n+  typedef POLY_CAST (Ca, Cb) NCa;\n+  typedef POLY_CONST_COEFF (Ca, Cb) C;\n+  poly_int<N, C> r;\n+  POLY_SET_COEFF (C, r, 0, NCa (a.coeffs[0]) - b);\n+  if (N >= 2)\n+    for (unsigned int i = 1; i < N; i++)\n+      POLY_SET_COEFF (C, r, i, NCa (a.coeffs[i]));\n+  return r;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline CONST_POLY_RESULT (N, Ca, Cb)\n+operator - (const Ca &a, const poly_int_pod<N, Cb> &b)\n+{\n+  typedef POLY_CAST (Cb, Ca) NCb;\n+  typedef CONST_POLY_COEFF (Ca, Cb) C;\n+  poly_int<N, C> r;\n+  POLY_SET_COEFF (C, r, 0, a - NCb (b.coeffs[0]));\n+  if (N >= 2)\n+    for (unsigned int i = 1; i < N; i++)\n+      POLY_SET_COEFF (C, r, i, -NCb (b.coeffs[i]));\n+  return r;\n+}\n+\n+namespace wi {\n+/* Poly versions of wi::sub, with the same interface.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline poly_int<N, WI_BINARY_RESULT (Ca, Cb)>\n+sub (const poly_int_pod<N, Ca> &a, const poly_int_pod<N, Cb> &b)\n+{\n+  typedef WI_BINARY_RESULT (Ca, Cb) C;\n+  poly_int<N, C> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (C, r, i, wi::sub (a.coeffs[i], b.coeffs[i]));\n+  return r;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline poly_int<N, WI_BINARY_RESULT (Ca, Cb)>\n+sub (const poly_int_pod<N, Ca> &a, const Cb &b)\n+{\n+  typedef WI_BINARY_RESULT (Ca, Cb) C;\n+  poly_int<N, C> r;\n+  POLY_SET_COEFF (C, r, 0, wi::sub (a.coeffs[0], b));\n+  for (unsigned int i = 1; i < N; i++)\n+    POLY_SET_COEFF (C, r, i, wi::sub (a.coeffs[i],\n+\t\t\t\t      wi::ints_for<Cb>::zero (b)));\n+  return r;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline poly_int<N, WI_BINARY_RESULT (Ca, Cb)>\n+sub (const Ca &a, const poly_int_pod<N, Cb> &b)\n+{\n+  typedef WI_BINARY_RESULT (Ca, Cb) C;\n+  poly_int<N, C> r;\n+  POLY_SET_COEFF (C, r, 0, wi::sub (a, b.coeffs[0]));\n+  for (unsigned int i = 1; i < N; i++)\n+    POLY_SET_COEFF (C, r, i, wi::sub (wi::ints_for<Ca>::zero (a),\n+\t\t\t\t      b.coeffs[i]));\n+  return r;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline poly_int<N, WI_BINARY_RESULT (Ca, Cb)>\n+sub (const poly_int_pod<N, Ca> &a, const poly_int_pod<N, Cb> &b,\n+     signop sgn, bool *overflow)\n+{\n+  typedef WI_BINARY_RESULT (Ca, Cb) C;\n+  poly_int<N, C> r;\n+  POLY_SET_COEFF (C, r, 0, wi::sub (a.coeffs[0], b.coeffs[0], sgn, overflow));\n+  for (unsigned int i = 1; i < N; i++)\n+    {\n+      bool suboverflow;\n+      POLY_SET_COEFF (C, r, i, wi::sub (a.coeffs[i], b.coeffs[i], sgn,\n+\t\t\t\t\t&suboverflow));\n+      *overflow |= suboverflow;\n+    }\n+  return r;\n+}\n+}\n+\n+template<unsigned int N, typename Ca>\n+inline POLY_POLY_RESULT (N, Ca, Ca)\n+operator - (const poly_int_pod<N, Ca> &a)\n+{\n+  typedef POLY_CAST (Ca, Ca) NCa;\n+  typedef POLY_POLY_COEFF (Ca, Ca) C;\n+  poly_int<N, C> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (C, r, i, -NCa (a.coeffs[i]));\n+  return r;\n+}\n+\n+namespace wi {\n+/* Poly version of wi::neg, with the same interface.  */\n+\n+template<unsigned int N, typename Ca>\n+inline poly_int<N, WI_UNARY_RESULT (Ca)>\n+neg (const poly_int_pod<N, Ca> &a)\n+{\n+  typedef WI_UNARY_RESULT (Ca) C;\n+  poly_int<N, C> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (C, r, i, wi::neg (a.coeffs[i]));\n+  return r;\n+}\n+\n+template<unsigned int N, typename Ca>\n+inline poly_int<N, WI_UNARY_RESULT (Ca)>\n+neg (const poly_int_pod<N, Ca> &a, bool *overflow)\n+{\n+  typedef WI_UNARY_RESULT (Ca) C;\n+  poly_int<N, C> r;\n+  POLY_SET_COEFF (C, r, 0, wi::neg (a.coeffs[0], overflow));\n+  for (unsigned int i = 1; i < N; i++)\n+    {\n+      bool suboverflow;\n+      POLY_SET_COEFF (C, r, i, wi::neg (a.coeffs[i], &suboverflow));\n+      *overflow |= suboverflow;\n+    }\n+  return r;\n+}\n+}\n+\n+template<unsigned int N, typename Ca>\n+inline POLY_POLY_RESULT (N, Ca, Ca)\n+operator ~ (const poly_int_pod<N, Ca> &a)\n+{\n+  if (N >= 2)\n+    return -1 - a;\n+  return ~a.coeffs[0];\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline POLY_CONST_RESULT (N, Ca, Cb)\n+operator * (const poly_int_pod<N, Ca> &a, const Cb &b)\n+{\n+  typedef POLY_CAST (Ca, Cb) NCa;\n+  typedef POLY_CONST_COEFF (Ca, Cb) C;\n+  poly_int<N, C> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (C, r, i, NCa (a.coeffs[i]) * b);\n+  return r;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline CONST_POLY_RESULT (N, Ca, Cb)\n+operator * (const Ca &a, const poly_int_pod<N, Cb> &b)\n+{\n+  typedef POLY_CAST (Ca, Cb) NCa;\n+  typedef CONST_POLY_COEFF (Ca, Cb) C;\n+  poly_int<N, C> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (C, r, i, NCa (a) * b.coeffs[i]);\n+  return r;\n+}\n+\n+namespace wi {\n+/* Poly versions of wi::mul, with the same interface.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline poly_int<N, WI_BINARY_RESULT (Ca, Cb)>\n+mul (const poly_int_pod<N, Ca> &a, const Cb &b)\n+{\n+  typedef WI_BINARY_RESULT (Ca, Cb) C;\n+  poly_int<N, C> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (C, r, i, wi::mul (a.coeffs[i], b));\n+  return r;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline poly_int<N, WI_BINARY_RESULT (Ca, Cb)>\n+mul (const Ca &a, const poly_int_pod<N, Cb> &b)\n+{\n+  typedef WI_BINARY_RESULT (Ca, Cb) C;\n+  poly_int<N, C> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (C, r, i, wi::mul (a, b.coeffs[i]));\n+  return r;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline poly_int<N, WI_BINARY_RESULT (Ca, Cb)>\n+mul (const poly_int_pod<N, Ca> &a, const Cb &b,\n+     signop sgn, bool *overflow)\n+{\n+  typedef WI_BINARY_RESULT (Ca, Cb) C;\n+  poly_int<N, C> r;\n+  POLY_SET_COEFF (C, r, 0, wi::mul (a.coeffs[0], b, sgn, overflow));\n+  for (unsigned int i = 1; i < N; i++)\n+    {\n+      bool suboverflow;\n+      POLY_SET_COEFF (C, r, i, wi::mul (a.coeffs[i], b, sgn, &suboverflow));\n+      *overflow |= suboverflow;\n+    }\n+  return r;\n+}\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline POLY_POLY_RESULT (N, Ca, Ca)\n+operator << (const poly_int_pod<N, Ca> &a, const Cb &b)\n+{\n+  typedef POLY_CAST (Ca, Ca) NCa;\n+  typedef POLY_POLY_COEFF (Ca, Ca) C;\n+  poly_int<N, C> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (C, r, i, NCa (a.coeffs[i]) << b);\n+  return r;\n+}\n+\n+namespace wi {\n+/* Poly version of wi::lshift, with the same interface.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline poly_int<N, WI_BINARY_RESULT (Ca, Ca)>\n+lshift (const poly_int_pod<N, Ca> &a, const Cb &b)\n+{\n+  typedef WI_BINARY_RESULT (Ca, Ca) C;\n+  poly_int<N, C> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (C, r, i, wi::lshift (a.coeffs[i], b));\n+  return r;\n+}\n+}\n+\n+/* Return true if a0 + a1 * x might equal b0 + b1 * x for some nonnegative\n+   integer x.  */\n+\n+template<typename Ca, typename Cb>\n+inline bool\n+maybe_eq_2 (const Ca &a0, const Ca &a1, const Cb &b0, const Cb &b1)\n+{\n+  if (a1 != b1)\n+     /*      a0 + a1 * x == b0 + b1 * x\n+       ==> (a1 - b1) * x == b0 - a0\n+       ==>             x == (b0 - a0) / (a1 - b1)\n+\n+       We need to test whether that's a valid value of x.\n+       (b0 - a0) and (a1 - b1) must not have opposite signs\n+       and the result must be integral.  */\n+    return (a1 < b1\n+\t    ? b0 <= a0 && (a0 - b0) % (b1 - a1) == 0\n+\t    : b0 >= a0 && (b0 - a0) % (a1 - b1) == 0);\n+  return a0 == b0;\n+}\n+\n+/* Return true if a0 + a1 * x might equal b for some nonnegative\n+   integer x.  */\n+\n+template<typename Ca, typename Cb>\n+inline bool\n+maybe_eq_2 (const Ca &a0, const Ca &a1, const Cb &b)\n+{\n+  if (a1 != 0)\n+     /*      a0 + a1 * x == b\n+       ==>             x == (b - a0) / a1\n+\n+       We need to test whether that's a valid value of x.\n+       (b - a0) and a1 must not have opposite signs and the\n+       result must be integral.  */\n+    return (a1 < 0\n+\t    ? b <= a0 && (a0 - b) % a1 == 0\n+\t    : b >= a0 && (b - a0) % a1 == 0);\n+  return a0 == b;\n+}\n+\n+/* Return true if A might equal B for some indeterminate values.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline bool\n+maybe_eq (const poly_int_pod<N, Ca> &a, const poly_int_pod<N, Cb> &b)\n+{\n+  STATIC_ASSERT (N <= 2);\n+  if (N == 2)\n+    return maybe_eq_2 (a.coeffs[0], a.coeffs[1], b.coeffs[0], b.coeffs[1]);\n+  return a.coeffs[0] == b.coeffs[0];\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline typename if_nonpoly<Cb, bool>::type\n+maybe_eq (const poly_int_pod<N, Ca> &a, const Cb &b)\n+{\n+  STATIC_ASSERT (N <= 2);\n+  if (N == 2)\n+    return maybe_eq_2 (a.coeffs[0], a.coeffs[1], b);\n+  return a.coeffs[0] == b;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline typename if_nonpoly<Ca, bool>::type\n+maybe_eq (const Ca &a, const poly_int_pod<N, Cb> &b)\n+{\n+  STATIC_ASSERT (N <= 2);\n+  if (N == 2)\n+    return maybe_eq_2 (b.coeffs[0], b.coeffs[1], a);\n+  return a == b.coeffs[0];\n+}\n+\n+template<typename Ca, typename Cb>\n+inline typename if_nonpoly2<Ca, Cb, bool>::type\n+maybe_eq (const Ca &a, const Cb &b)\n+{\n+  return a == b;\n+}\n+\n+/* Return true if A might not equal B for some indeterminate values.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline bool\n+maybe_ne (const poly_int_pod<N, Ca> &a, const poly_int_pod<N, Cb> &b)\n+{\n+  if (N >= 2)\n+    for (unsigned int i = 1; i < N; i++)\n+      if (a.coeffs[i] != b.coeffs[i])\n+\treturn true;\n+  return a.coeffs[0] != b.coeffs[0];\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline typename if_nonpoly<Cb, bool>::type\n+maybe_ne (const poly_int_pod<N, Ca> &a, const Cb &b)\n+{\n+  if (N >= 2)\n+    for (unsigned int i = 1; i < N; i++)\n+      if (a.coeffs[i] != 0)\n+\treturn true;\n+  return a.coeffs[0] != b;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline typename if_nonpoly<Ca, bool>::type\n+maybe_ne (const Ca &a, const poly_int_pod<N, Cb> &b)\n+{\n+  if (N >= 2)\n+    for (unsigned int i = 1; i < N; i++)\n+      if (0 != b.coeffs[i])\n+\treturn true;\n+  return a != b.coeffs[0];\n+}\n+\n+template<typename Ca, typename Cb>\n+inline typename if_nonpoly2<Ca, Cb, bool>::type\n+maybe_ne (const Ca &a, const Cb &b)\n+{\n+  return a != b;\n+}\n+\n+/* Return true if A is known to be equal to B.  */\n+#define known_eq(A, B) (!maybe_ne (A, B))\n+\n+/* Return true if A is known to be unequal to B.  */\n+#define known_ne(A, B) (!maybe_eq (A, B))\n+\n+/* Return true if A might be less than or equal to B for some\n+   indeterminate values.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline bool\n+maybe_le (const poly_int_pod<N, Ca> &a, const poly_int_pod<N, Cb> &b)\n+{\n+  if (N >= 2)\n+    for (unsigned int i = 1; i < N; i++)\n+      if (a.coeffs[i] < b.coeffs[i])\n+\treturn true;\n+  return a.coeffs[0] <= b.coeffs[0];\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline typename if_nonpoly<Cb, bool>::type\n+maybe_le (const poly_int_pod<N, Ca> &a, const Cb &b)\n+{\n+  if (N >= 2)\n+    for (unsigned int i = 1; i < N; i++)\n+      if (a.coeffs[i] < 0)\n+\treturn true;\n+  return a.coeffs[0] <= b;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline typename if_nonpoly<Ca, bool>::type\n+maybe_le (const Ca &a, const poly_int_pod<N, Cb> &b)\n+{\n+  if (N >= 2)\n+    for (unsigned int i = 1; i < N; i++)\n+      if (0 < b.coeffs[i])\n+\treturn true;\n+  return a <= b.coeffs[0];\n+}\n+\n+template<typename Ca, typename Cb>\n+inline typename if_nonpoly2<Ca, Cb, bool>::type\n+maybe_le (const Ca &a, const Cb &b)\n+{\n+  return a <= b;\n+}\n+\n+/* Return true if A might be less than B for some indeterminate values.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline bool\n+maybe_lt (const poly_int_pod<N, Ca> &a, const poly_int_pod<N, Cb> &b)\n+{\n+  if (N >= 2)\n+    for (unsigned int i = 1; i < N; i++)\n+      if (a.coeffs[i] < b.coeffs[i])\n+\treturn true;\n+  return a.coeffs[0] < b.coeffs[0];\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline typename if_nonpoly<Cb, bool>::type\n+maybe_lt (const poly_int_pod<N, Ca> &a, const Cb &b)\n+{\n+  if (N >= 2)\n+    for (unsigned int i = 1; i < N; i++)\n+      if (a.coeffs[i] < 0)\n+\treturn true;\n+  return a.coeffs[0] < b;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline typename if_nonpoly<Ca, bool>::type\n+maybe_lt (const Ca &a, const poly_int_pod<N, Cb> &b)\n+{\n+  if (N >= 2)\n+    for (unsigned int i = 1; i < N; i++)\n+      if (0 < b.coeffs[i])\n+\treturn true;\n+  return a < b.coeffs[0];\n+}\n+\n+template<typename Ca, typename Cb>\n+inline typename if_nonpoly2<Ca, Cb, bool>::type\n+maybe_lt (const Ca &a, const Cb &b)\n+{\n+  return a < b;\n+}\n+\n+/* Return true if A may be greater than or equal to B.  */\n+#define maybe_ge(A, B) maybe_le (B, A)\n+\n+/* Return true if A may be greater than B.  */\n+#define maybe_gt(A, B) maybe_lt (B, A)\n+\n+/* Return true if A is known to be less than or equal to B.  */\n+#define known_le(A, B) (!maybe_gt (A, B))\n+\n+/* Return true if A is known to be less than B.  */\n+#define known_lt(A, B) (!maybe_ge (A, B))\n+\n+/* Return true if A is known to be greater than B.  */\n+#define known_gt(A, B) (!maybe_le (A, B))\n+\n+/* Return true if A is known to be greater than or equal to B.  */\n+#define known_ge(A, B) (!maybe_lt (A, B))\n+\n+/* Return true if A and B are ordered by the partial ordering known_le.  */\n+\n+template<typename T1, typename T2>\n+inline bool\n+ordered_p (const T1 &a, const T2 &b)\n+{\n+  return ((poly_int_traits<T1>::num_coeffs == 1\n+\t   && poly_int_traits<T2>::num_coeffs == 1)\n+\t  || known_le (a, b)\n+\t  || known_le (b, a));\n+}\n+\n+/* Assert that A and B are known to be ordered and return the minimum\n+   of the two.\n+\n+   NOTE: When using this function, please add a comment above the call\n+   explaining why we know the values are ordered in that context.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline POLY_POLY_RESULT (N, Ca, Cb)\n+ordered_min (const poly_int_pod<N, Ca> &a, const poly_int_pod<N, Cb> &b)\n+{\n+  if (known_le (a, b))\n+    return a;\n+  else\n+    {\n+      if (N > 1)\n+\tgcc_checking_assert (known_le (b, a));\n+      return b;\n+    }\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline CONST_POLY_RESULT (N, Ca, Cb)\n+ordered_min (const Ca &a, const poly_int_pod<N, Cb> &b)\n+{\n+  if (known_le (a, b))\n+    return a;\n+  else\n+    {\n+      if (N > 1)\n+\tgcc_checking_assert (known_le (b, a));\n+      return b;\n+    }\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline POLY_CONST_RESULT (N, Ca, Cb)\n+ordered_min (const poly_int_pod<N, Ca> &a, const Cb &b)\n+{\n+  if (known_le (a, b))\n+    return a;\n+  else\n+    {\n+      if (N > 1)\n+\tgcc_checking_assert (known_le (b, a));\n+      return b;\n+    }\n+}\n+\n+/* Assert that A and B are known to be ordered and return the maximum\n+   of the two.\n+\n+   NOTE: When using this function, please add a comment above the call\n+   explaining why we know the values are ordered in that context.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline POLY_POLY_RESULT (N, Ca, Cb)\n+ordered_max (const poly_int_pod<N, Ca> &a, const poly_int_pod<N, Cb> &b)\n+{\n+  if (known_le (a, b))\n+    return b;\n+  else\n+    {\n+      if (N > 1)\n+\tgcc_checking_assert (known_le (b, a));\n+      return a;\n+    }\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline CONST_POLY_RESULT (N, Ca, Cb)\n+ordered_max (const Ca &a, const poly_int_pod<N, Cb> &b)\n+{\n+  if (known_le (a, b))\n+    return b;\n+  else\n+    {\n+      if (N > 1)\n+\tgcc_checking_assert (known_le (b, a));\n+      return a;\n+    }\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline POLY_CONST_RESULT (N, Ca, Cb)\n+ordered_max (const poly_int_pod<N, Ca> &a, const Cb &b)\n+{\n+  if (known_le (a, b))\n+    return b;\n+  else\n+    {\n+      if (N > 1)\n+\tgcc_checking_assert (known_le (b, a));\n+      return a;\n+    }\n+}\n+\n+/* Return a constant lower bound on the value of A, which is known\n+   to be nonnegative.  */\n+\n+template<unsigned int N, typename Ca>\n+inline Ca\n+constant_lower_bound (const poly_int_pod<N, Ca> &a)\n+{\n+  gcc_checking_assert (known_ge (a, POLY_INT_TYPE (Ca) (0)));\n+  return a.coeffs[0];\n+}\n+\n+/* Return a value that is known to be no greater than A and B.  This\n+   will be the greatest lower bound for some indeterminate values but\n+   not necessarily for all.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline POLY_CONST_RESULT (N, Ca, Cb)\n+lower_bound (const poly_int_pod<N, Ca> &a, const Cb &b)\n+{\n+  typedef POLY_CAST (Ca, Cb) NCa;\n+  typedef POLY_CAST (Cb, Ca) NCb;\n+  typedef POLY_INT_TYPE (Cb) ICb;\n+  typedef POLY_CONST_COEFF (Ca, Cb) C;\n+\n+  poly_int<N, C> r;\n+  POLY_SET_COEFF (C, r, 0, MIN (NCa (a.coeffs[0]), NCb (b)));\n+  if (N >= 2)\n+    for (unsigned int i = 1; i < N; i++)\n+      POLY_SET_COEFF (C, r, i, MIN (NCa (a.coeffs[i]), ICb (0)));\n+  return r;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline CONST_POLY_RESULT (N, Ca, Cb)\n+lower_bound (const Ca &a, const poly_int_pod<N, Cb> &b)\n+{\n+  return lower_bound (b, a);\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline POLY_POLY_RESULT (N, Ca, Cb)\n+lower_bound (const poly_int_pod<N, Ca> &a, const poly_int_pod<N, Cb> &b)\n+{\n+  typedef POLY_CAST (Ca, Cb) NCa;\n+  typedef POLY_CAST (Cb, Ca) NCb;\n+  typedef POLY_POLY_COEFF (Ca, Cb) C;\n+\n+  poly_int<N, C> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (C, r, i, MIN (NCa (a.coeffs[i]), NCb (b.coeffs[i])));\n+  return r;\n+}\n+\n+template<typename Ca, typename Cb>\n+inline CONST_CONST_RESULT (N, Ca, Cb)\n+lower_bound (const Ca &a, const Cb &b)\n+{\n+  return a < b ? a : b;\n+}\n+\n+/* Return a value that is known to be no less than A and B.  This will\n+   be the least upper bound for some indeterminate values but not\n+   necessarily for all.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline POLY_CONST_RESULT (N, Ca, Cb)\n+upper_bound (const poly_int_pod<N, Ca> &a, const Cb &b)\n+{\n+  typedef POLY_CAST (Ca, Cb) NCa;\n+  typedef POLY_CAST (Cb, Ca) NCb;\n+  typedef POLY_INT_TYPE (Cb) ICb;\n+  typedef POLY_CONST_COEFF (Ca, Cb) C;\n+\n+  poly_int<N, C> r;\n+  POLY_SET_COEFF (C, r, 0, MAX (NCa (a.coeffs[0]), NCb (b)));\n+  if (N >= 2)\n+    for (unsigned int i = 1; i < N; i++)\n+      POLY_SET_COEFF (C, r, i, MAX (NCa (a.coeffs[i]), ICb (0)));\n+  return r;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline CONST_POLY_RESULT (N, Ca, Cb)\n+upper_bound (const Ca &a, const poly_int_pod<N, Cb> &b)\n+{\n+  return upper_bound (b, a);\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline POLY_POLY_RESULT (N, Ca, Cb)\n+upper_bound (const poly_int_pod<N, Ca> &a, const poly_int_pod<N, Cb> &b)\n+{\n+  typedef POLY_CAST (Ca, Cb) NCa;\n+  typedef POLY_CAST (Cb, Ca) NCb;\n+  typedef POLY_POLY_COEFF (Ca, Cb) C;\n+\n+  poly_int<N, C> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (C, r, i, MAX (NCa (a.coeffs[i]), NCb (b.coeffs[i])));\n+  return r;\n+}\n+\n+/* Return the greatest common divisor of all nonzero coefficients, or zero\n+   if all coefficients are zero.  */\n+\n+template<unsigned int N, typename Ca>\n+inline POLY_BINARY_COEFF (Ca, Ca)\n+coeff_gcd (const poly_int_pod<N, Ca> &a)\n+{\n+  /* Find the first nonzero coefficient, stopping at 0 whatever happens.  */\n+  unsigned int i;\n+  for (i = N - 1; i > 0; --i)\n+    if (a.coeffs[i] != 0)\n+      break;\n+  typedef POLY_BINARY_COEFF (Ca, Ca) C;\n+  C r = a.coeffs[i];\n+  for (unsigned int j = 0; j < i; ++j)\n+    if (a.coeffs[j] != 0)\n+      r = gcd (r, C (a.coeffs[j]));\n+  return r;\n+}\n+\n+/* Return a value that is a multiple of both A and B.  This will be the\n+   least common multiple for some indeterminate values but necessarily\n+   for all.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+POLY_CONST_RESULT (N, Ca, Cb)\n+common_multiple (const poly_int_pod<N, Ca> &a, Cb b)\n+{\n+  POLY_BINARY_COEFF (Ca, Ca) xgcd = coeff_gcd (a);\n+  return a * (least_common_multiple (xgcd, b) / xgcd);\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline CONST_POLY_RESULT (N, Ca, Cb)\n+common_multiple (const Ca &a, const poly_int_pod<N, Cb> &b)\n+{\n+  return common_multiple (b, a);\n+}\n+\n+/* Return a value that is a multiple of both A and B, asserting that\n+   such a value exists.  The result will be the least common multiple\n+   for some indeterminate values but necessarily for all.\n+\n+   NOTE: When using this function, please add a comment above the call\n+   explaining why we know the values have a common multiple (which might\n+   for example be because we know A / B is rational).  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+POLY_POLY_RESULT (N, Ca, Cb)\n+force_common_multiple (const poly_int_pod<N, Ca> &a,\n+\t\t       const poly_int_pod<N, Cb> &b)\n+{\n+  if (b.is_constant ())\n+    return common_multiple (a, b.coeffs[0]);\n+  if (a.is_constant ())\n+    return common_multiple (a.coeffs[0], b);\n+\n+  typedef POLY_CAST (Ca, Cb) NCa;\n+  typedef POLY_CAST (Cb, Ca) NCb;\n+  typedef POLY_BINARY_COEFF (Ca, Cb) C;\n+  typedef POLY_INT_TYPE (Ca) ICa;\n+\n+  for (unsigned int i = 1; i < N; ++i)\n+    if (a.coeffs[i] != ICa (0))\n+      {\n+\tC lcm = least_common_multiple (NCa (a.coeffs[i]), NCb (b.coeffs[i]));\n+\tC amul = lcm / a.coeffs[i];\n+\tC bmul = lcm / b.coeffs[i];\n+\tfor (unsigned int j = 0; j < N; ++j)\n+\t  gcc_checking_assert (a.coeffs[j] * amul == b.coeffs[j] * bmul);\n+\treturn a * amul;\n+      }\n+  gcc_unreachable ();\n+}\n+\n+/* Compare A and B for sorting purposes, returning -1 if A should come\n+   before B, 0 if A and B are identical, and 1 if A should come after B.\n+   This is a lexicographical compare of the coefficients in reverse order.\n+\n+   A consequence of this is that all constant sizes come before all\n+   non-constant ones, regardless of magnitude (since a size is never\n+   negative).  This is what most callers want.  For example, when laying\n+   data out on the stack, it's better to keep all the constant-sized\n+   data together so that it can be accessed as a constant offset from a\n+   single base.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline int\n+compare_sizes_for_sort (const poly_int_pod<N, Ca> &a,\n+\t\t\tconst poly_int_pod<N, Cb> &b)\n+{\n+  for (unsigned int i = N; i-- > 0; )\n+    if (a.coeffs[i] != b.coeffs[i])\n+      return a.coeffs[i] < b.coeffs[i] ? -1 : 1;\n+  return 0;\n+}\n+\n+/* Return true if we can calculate VALUE & (ALIGN - 1) at compile time.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline bool\n+can_align_p (const poly_int_pod<N, Ca> &value, Cb align)\n+{\n+  for (unsigned int i = 1; i < N; i++)\n+    if ((value.coeffs[i] & (align - 1)) != 0)\n+      return false;\n+  return true;\n+}\n+\n+/* Return true if we can align VALUE up to the smallest multiple of\n+   ALIGN that is >= VALUE.  Store the aligned value in *ALIGNED if so.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline bool\n+can_align_up (const poly_int_pod<N, Ca> &value, Cb align,\n+\t      poly_int_pod<N, Ca> *aligned)\n+{\n+  if (!can_align_p (value, align))\n+    return false;\n+  *aligned = value + (-value.coeffs[0] & (align - 1));\n+  return true;\n+}\n+\n+/* Return true if we can align VALUE down to the largest multiple of\n+   ALIGN that is <= VALUE.  Store the aligned value in *ALIGNED if so.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline bool\n+can_align_down (const poly_int_pod<N, Ca> &value, Cb align,\n+\t\tpoly_int_pod<N, Ca> *aligned)\n+{\n+  if (!can_align_p (value, align))\n+    return false;\n+  *aligned = value - (value.coeffs[0] & (align - 1));\n+  return true;\n+}\n+\n+/* Return true if we can align A and B up to the smallest multiples of\n+   ALIGN that are >= A and B respectively, and if doing so gives the\n+   same value.  */\n+\n+template<unsigned int N, typename Ca, typename Cb, typename Cc>\n+inline bool\n+known_equal_after_align_up (const poly_int_pod<N, Ca> &a,\n+\t\t\t    const poly_int_pod<N, Cb> &b,\n+\t\t\t    Cc align)\n+{\n+  poly_int<N, Ca> aligned_a;\n+  poly_int<N, Cb> aligned_b;\n+  return (can_align_up (a, align, &aligned_a)\n+\t  && can_align_up (b, align, &aligned_b)\n+\t  && known_eq (aligned_a, aligned_b));\n+}\n+\n+/* Return true if we can align A and B down to the largest multiples of\n+   ALIGN that are <= A and B respectively, and if doing so gives the\n+   same value.  */\n+\n+template<unsigned int N, typename Ca, typename Cb, typename Cc>\n+inline bool\n+known_equal_after_align_down (const poly_int_pod<N, Ca> &a,\n+\t\t\t      const poly_int_pod<N, Cb> &b,\n+\t\t\t      Cc align)\n+{\n+  poly_int<N, Ca> aligned_a;\n+  poly_int<N, Cb> aligned_b;\n+  return (can_align_down (a, align, &aligned_a)\n+\t  && can_align_down (b, align, &aligned_b)\n+\t  && known_eq (aligned_a, aligned_b));\n+}\n+\n+/* Assert that we can align VALUE to ALIGN at compile time and return\n+   the smallest multiple of ALIGN that is >= VALUE.\n+\n+   NOTE: When using this function, please add a comment above the call\n+   explaining why we know the non-constant coefficients must already\n+   be a multiple of ALIGN.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline poly_int<N, Ca>\n+force_align_up (const poly_int_pod<N, Ca> &value, Cb align)\n+{\n+  gcc_checking_assert (can_align_p (value, align));\n+  return value + (-value.coeffs[0] & (align - 1));\n+}\n+\n+/* Assert that we can align VALUE to ALIGN at compile time and return\n+   the largest multiple of ALIGN that is <= VALUE.\n+\n+   NOTE: When using this function, please add a comment above the call\n+   explaining why we know the non-constant coefficients must already\n+   be a multiple of ALIGN.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline poly_int<N, Ca>\n+force_align_down (const poly_int_pod<N, Ca> &value, Cb align)\n+{\n+  gcc_checking_assert (can_align_p (value, align));\n+  return value - (value.coeffs[0] & (align - 1));\n+}\n+\n+/* Return a value <= VALUE that is a multiple of ALIGN.  It will be the\n+   greatest such value for some indeterminate values but not necessarily\n+   for all.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline poly_int<N, Ca>\n+aligned_lower_bound (const poly_int_pod<N, Ca> &value, Cb align)\n+{\n+  poly_int<N, Ca> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    /* This form copes correctly with more type combinations than\n+       value.coeffs[i] & -align would.  */\n+    POLY_SET_COEFF (Ca, r, i, (value.coeffs[i]\n+\t\t\t       - (value.coeffs[i] & (align - 1))));\n+  return r;\n+}\n+\n+/* Return a value >= VALUE that is a multiple of ALIGN.  It will be the\n+   least such value for some indeterminate values but not necessarily\n+   for all.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline poly_int<N, Ca>\n+aligned_upper_bound (const poly_int_pod<N, Ca> &value, Cb align)\n+{\n+  poly_int<N, Ca> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    POLY_SET_COEFF (Ca, r, i, (value.coeffs[i]\n+\t\t\t       + (-value.coeffs[i] & (align - 1))));\n+  return r;\n+}\n+\n+/* Assert that we can align VALUE to ALIGN at compile time.  Align VALUE\n+   down to the largest multiple of ALIGN that is <= VALUE, then divide by\n+   ALIGN.\n+\n+   NOTE: When using this function, please add a comment above the call\n+   explaining why we know the non-constant coefficients must already\n+   be a multiple of ALIGN.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline poly_int<N, Ca>\n+force_align_down_and_div (const poly_int_pod<N, Ca> &value, Cb align)\n+{\n+  gcc_checking_assert (can_align_p (value, align));\n+\n+  poly_int<N, Ca> r;\n+  POLY_SET_COEFF (Ca, r, 0, ((value.coeffs[0]\n+\t\t\t      - (value.coeffs[0] & (align - 1)))\n+\t\t\t     / align));\n+  if (N >= 2)\n+    for (unsigned int i = 1; i < N; i++)\n+      POLY_SET_COEFF (Ca, r, i, value.coeffs[i] / align);\n+  return r;\n+}\n+\n+/* Assert that we can align VALUE to ALIGN at compile time.  Align VALUE\n+   up to the smallest multiple of ALIGN that is >= VALUE, then divide by\n+   ALIGN.\n+\n+   NOTE: When using this function, please add a comment above the call\n+   explaining why we know the non-constant coefficients must already\n+   be a multiple of ALIGN.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline poly_int<N, Ca>\n+force_align_up_and_div (const poly_int_pod<N, Ca> &value, Cb align)\n+{\n+  gcc_checking_assert (can_align_p (value, align));\n+\n+  poly_int<N, Ca> r;\n+  POLY_SET_COEFF (Ca, r, 0, ((value.coeffs[0]\n+\t\t\t      + (-value.coeffs[0] & (align - 1)))\n+\t\t\t     / align));\n+  if (N >= 2)\n+    for (unsigned int i = 1; i < N; i++)\n+      POLY_SET_COEFF (Ca, r, i, value.coeffs[i] / align);\n+  return r;\n+}\n+\n+/* Return true if we know at compile time the difference between VALUE\n+   and the equal or preceding multiple of ALIGN.  Store the value in\n+   *MISALIGN if so.  */\n+\n+template<unsigned int N, typename Ca, typename Cb, typename Cm>\n+inline bool\n+known_misalignment (const poly_int_pod<N, Ca> &value, Cb align, Cm *misalign)\n+{\n+  gcc_checking_assert (align != 0);\n+  if (!can_align_p (value, align))\n+    return false;\n+  *misalign = value.coeffs[0] & (align - 1);\n+  return true;\n+}\n+\n+/* Return X & (Y - 1), asserting that this value is known.  Please add\n+   an a comment above callers to this function to explain why the condition\n+   is known to hold.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline POLY_BINARY_COEFF (Ca, Ca)\n+force_get_misalignment (const poly_int_pod<N, Ca> &a, Cb align)\n+{\n+  gcc_checking_assert (can_align_p (a, align));\n+  return a.coeffs[0] & (align - 1);\n+}\n+\n+/* Return the maximum alignment that A is known to have.  Return 0\n+   if A is known to be zero.  */\n+\n+template<unsigned int N, typename Ca>\n+inline POLY_BINARY_COEFF (Ca, Ca)\n+known_alignment (const poly_int_pod<N, Ca> &a)\n+{\n+  typedef POLY_BINARY_COEFF (Ca, Ca) C;\n+  C r = a.coeffs[0];\n+  for (unsigned int i = 1; i < N; ++i)\n+    r |= a.coeffs[i];\n+  return r & -r;\n+}\n+\n+/* Return true if we can compute A | B at compile time, storing the\n+   result in RES if so.  */\n+\n+template<unsigned int N, typename Ca, typename Cb, typename Cr>\n+inline typename if_nonpoly<Cb, bool>::type\n+can_ior_p (const poly_int_pod<N, Ca> &a, Cb b, Cr *result)\n+{\n+  /* Coefficients 1 and above must be a multiple of something greater\n+     than B.  */\n+  typedef POLY_INT_TYPE (Ca) int_type;\n+  if (N >= 2)\n+    for (unsigned int i = 1; i < N; i++)\n+      if ((-(a.coeffs[i] & -a.coeffs[i]) & b) != int_type (0))\n+\treturn false;\n+  *result = a;\n+  result->coeffs[0] |= b;\n+  return true;\n+}\n+\n+/* Return true if A is a constant multiple of B, storing the\n+   multiple in *MULTIPLE if so.  */\n+\n+template<unsigned int N, typename Ca, typename Cb, typename Cm>\n+inline typename if_nonpoly<Cb, bool>::type\n+constant_multiple_p (const poly_int_pod<N, Ca> &a, Cb b, Cm *multiple)\n+{\n+  typedef POLY_CAST (Ca, Cb) NCa;\n+  typedef POLY_CAST (Cb, Ca) NCb;\n+\n+  /* Do the modulus before the constant check, to catch divide by\n+     zero errors.  */\n+  if (NCa (a.coeffs[0]) % NCb (b) != 0 || !a.is_constant ())\n+    return false;\n+  *multiple = NCa (a.coeffs[0]) / NCb (b);\n+  return true;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb, typename Cm>\n+inline typename if_nonpoly<Ca, bool>::type\n+constant_multiple_p (Ca a, const poly_int_pod<N, Cb> &b, Cm *multiple)\n+{\n+  typedef POLY_CAST (Ca, Cb) NCa;\n+  typedef POLY_CAST (Cb, Ca) NCb;\n+  typedef POLY_INT_TYPE (Ca) int_type;\n+\n+  /* Do the modulus before the constant check, to catch divide by\n+     zero errors.  */\n+  if (NCa (a) % NCb (b.coeffs[0]) != 0\n+      || (a != int_type (0) && !b.is_constant ()))\n+    return false;\n+  *multiple = NCa (a) / NCb (b.coeffs[0]);\n+  return true;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb, typename Cm>\n+inline bool\n+constant_multiple_p (const poly_int_pod<N, Ca> &a,\n+\t\t     const poly_int_pod<N, Cb> &b, Cm *multiple)\n+{\n+  typedef POLY_CAST (Ca, Cb) NCa;\n+  typedef POLY_CAST (Cb, Ca) NCb;\n+  typedef POLY_INT_TYPE (Ca) ICa;\n+  typedef POLY_INT_TYPE (Cb) ICb;\n+  typedef POLY_BINARY_COEFF (Ca, Cb) C;\n+\n+  if (NCa (a.coeffs[0]) % NCb (b.coeffs[0]) != 0)\n+    return false;\n+\n+  C r = NCa (a.coeffs[0]) / NCb (b.coeffs[0]);\n+  for (unsigned int i = 1; i < N; ++i)\n+    if (b.coeffs[i] == ICb (0)\n+\t? a.coeffs[i] != ICa (0)\n+\t: (NCa (a.coeffs[i]) % NCb (b.coeffs[i]) != 0\n+\t   || NCa (a.coeffs[i]) / NCb (b.coeffs[i]) != r))\n+      return false;\n+\n+  *multiple = r;\n+  return true;\n+}\n+\n+/* Return true if A is a multiple of B.  */\n+\n+template<typename Ca, typename Cb>\n+inline typename if_nonpoly2<Ca, Cb, bool>::type\n+multiple_p (Ca a, Cb b)\n+{\n+  return a % b != 0;\n+}\n+\n+/* Return true if A is a (polynomial) multiple of B.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline typename if_nonpoly<Cb, bool>::type\n+multiple_p (const poly_int_pod<N, Ca> &a, Cb b)\n+{\n+  for (unsigned int i = 0; i < N; ++i)\n+    if (a.coeffs[i] % b != 0)\n+      return false;\n+  return true;\n+}\n+\n+/* Return true if A is a (constant) multiple of B.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline typename if_nonpoly<Ca, bool>::type\n+multiple_p (Ca a, const poly_int_pod<N, Cb> &b)\n+{\n+  typedef POLY_INT_TYPE (Ca) int_type;\n+\n+  /* Do the modulus before the constant check, to catch divide by\n+     potential zeros.  */\n+  return a % b.coeffs[0] == 0 && (a == int_type (0) || b.is_constant ());\n+}\n+\n+/* Return true if A is a (polynomial) multiple of B.  This handles cases\n+   where either B is constant or the multiple is constant.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline bool\n+multiple_p (const poly_int_pod<N, Ca> &a, const poly_int_pod<N, Cb> &b)\n+{\n+  if (b.is_constant ())\n+    return multiple_p (a, b.coeffs[0]);\n+  POLY_BINARY_COEFF (Ca, Ca) tmp;\n+  return constant_multiple_p (a, b, &tmp);\n+}\n+\n+/* Return true if A is a (constant) multiple of B, storing the\n+   multiple in *MULTIPLE if so.  */\n+\n+template<typename Ca, typename Cb, typename Cm>\n+inline typename if_nonpoly2<Ca, Cb, bool>::type\n+multiple_p (Ca a, Cb b, Cm *multiple)\n+{\n+  if (a % b != 0)\n+    return false;\n+  *multiple = a / b;\n+  return true;\n+}\n+\n+/* Return true if A is a (polynomial) multiple of B, storing the\n+   multiple in *MULTIPLE if so.  */\n+\n+template<unsigned int N, typename Ca, typename Cb, typename Cm>\n+inline typename if_nonpoly<Cb, bool>::type\n+multiple_p (const poly_int_pod<N, Ca> &a, Cb b, poly_int_pod<N, Cm> *multiple)\n+{\n+  if (!multiple_p (a, b))\n+    return false;\n+  for (unsigned int i = 0; i < N; ++i)\n+    multiple->coeffs[i] = a.coeffs[i] / b;\n+  return true;\n+}\n+\n+/* Return true if B is a constant and A is a (constant) multiple of B,\n+   storing the multiple in *MULTIPLE if so.  */\n+\n+template<unsigned int N, typename Ca, typename Cb, typename Cm>\n+inline typename if_nonpoly<Ca, bool>::type\n+multiple_p (Ca a, const poly_int_pod<N, Cb> &b, Cm *multiple)\n+{\n+  typedef POLY_CAST (Ca, Cb) NCa;\n+\n+  /* Do the modulus before the constant check, to catch divide by\n+     potential zeros.  */\n+  if (a % b.coeffs[0] != 0 || (NCa (a) != 0 && !b.is_constant ()))\n+    return false;\n+  *multiple = a / b.coeffs[0];\n+  return true;\n+}\n+\n+/* Return true if A is a (polynomial) multiple of B, storing the\n+   multiple in *MULTIPLE if so.  This handles cases where either\n+   B is constant or the multiple is constant.  */\n+\n+template<unsigned int N, typename Ca, typename Cb, typename Cm>\n+inline bool\n+multiple_p (const poly_int_pod<N, Ca> &a, const poly_int_pod<N, Cb> &b,\n+\t    poly_int_pod<N, Cm> *multiple)\n+{\n+  if (b.is_constant ())\n+    return multiple_p (a, b.coeffs[0], multiple);\n+  return constant_multiple_p (a, b, multiple);\n+}\n+\n+/* Return A / B, given that A is known to be a multiple of B.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline POLY_CONST_RESULT (N, Ca, Cb)\n+exact_div (const poly_int_pod<N, Ca> &a, Cb b)\n+{\n+  typedef POLY_CONST_COEFF (Ca, Cb) C;\n+  poly_int<N, C> r;\n+  for (unsigned int i = 0; i < N; i++)\n+    {\n+      gcc_checking_assert (a.coeffs[i] % b == 0);\n+      POLY_SET_COEFF (C, r, i, a.coeffs[i] / b);\n+    }\n+  return r;\n+}\n+\n+/* Return A / B, given that A is known to be a multiple of B.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline POLY_POLY_RESULT (N, Ca, Cb)\n+exact_div (const poly_int_pod<N, Ca> &a, const poly_int_pod<N, Cb> &b)\n+{\n+  if (b.is_constant ())\n+    return exact_div (a, b.coeffs[0]);\n+\n+  typedef POLY_CAST (Ca, Cb) NCa;\n+  typedef POLY_CAST (Cb, Ca) NCb;\n+  typedef POLY_BINARY_COEFF (Ca, Cb) C;\n+  typedef POLY_INT_TYPE (Cb) int_type;\n+\n+  gcc_checking_assert (a.coeffs[0] % b.coeffs[0] == 0);\n+  C r = NCa (a.coeffs[0]) / NCb (b.coeffs[0]);\n+  for (unsigned int i = 1; i < N; ++i)\n+    gcc_checking_assert (b.coeffs[i] == int_type (0)\n+\t\t\t ? a.coeffs[i] == int_type (0)\n+\t\t\t : (a.coeffs[i] % b.coeffs[i] == 0\n+\t\t\t    && NCa (a.coeffs[i]) / NCb (b.coeffs[i]) == r));\n+\n+  return r;\n+}\n+\n+/* Return true if there is some constant Q and polynomial r such that:\n+\n+     (1) a = b * Q + r\n+     (2) |b * Q| <= |a|\n+     (3) |r| < |b|\n+\n+   Store the value Q in *QUOTIENT if so.  */\n+\n+template<unsigned int N, typename Ca, typename Cb, typename Cq>\n+inline typename if_nonpoly2<Cb, Cq, bool>::type\n+can_div_trunc_p (const poly_int_pod<N, Ca> &a, Cb b, Cq *quotient)\n+{\n+  typedef POLY_CAST (Ca, Cb) NCa;\n+  typedef POLY_CAST (Cb, Ca) NCb;\n+\n+  /* Do the division before the constant check, to catch divide by\n+     zero errors.  */\n+  Cq q = NCa (a.coeffs[0]) / NCb (b);\n+  if (!a.is_constant ())\n+    return false;\n+  *quotient = q;\n+  return true;\n+}\n+\n+template<unsigned int N, typename Ca, typename Cb, typename Cq>\n+inline typename if_nonpoly<Cq, bool>::type\n+can_div_trunc_p (const poly_int_pod<N, Ca> &a,\n+\t\t const poly_int_pod<N, Cb> &b,\n+\t\t Cq *quotient)\n+{\n+  /* We can calculate Q from the case in which the indeterminates\n+     are zero.  */\n+  typedef POLY_CAST (Ca, Cb) NCa;\n+  typedef POLY_CAST (Cb, Ca) NCb;\n+  typedef POLY_INT_TYPE (Ca) ICa;\n+  typedef POLY_INT_TYPE (Cb) ICb;\n+  typedef POLY_BINARY_COEFF (Ca, Cb) C;\n+  C q = NCa (a.coeffs[0]) / NCb (b.coeffs[0]);\n+\n+  /* Check the other coefficients and record whether the division is exact.\n+     The only difficult case is when it isn't.  If we require a and b to\n+     ordered wrt zero, there can be no two coefficients of the same value\n+     that have opposite signs.  This means that:\n+\n+\t |a| = |a0| + |a1 * x1| + |a2 * x2| + ...\n+\t |b| = |b0| + |b1 * x1| + |b2 * x2| + ...\n+\n+      The Q we've just calculated guarantees:\n+\n+\t |b0 * Q| <= |a0|\n+\t |a0 - b0 * Q| < |b0|\n+\n+      and so:\n+\n+\t (2) |b * Q| <= |a|\n+\n+      is satisfied if:\n+\n+\t |bi * xi * Q| <= |ai * xi|\n+\n+      for each i in [1, N].  This is trivially true when xi is zero.\n+      When it isn't we need:\n+\n+\t (2') |bi * Q| <= |ai|\n+\n+      r is calculated as:\n+\n+\t r = r0 + r1 * x1 + r2 * x2 + ...\n+\t where ri = ai - bi * Q\n+\n+      Restricting to ordered a and b also guarantees that no two ris\n+      have opposite signs, so we have:\n+\n+\t |r| = |r0| + |r1 * x1| + |r2 * x2| + ...\n+\n+      We know from the calculation of Q that |r0| < |b0|, so:\n+\n+\t (3) |r| < |b|\n+\n+      is satisfied if:\n+\n+\t (3') |ai - bi * Q| <= |bi|\n+\n+      for each i in [1, N].  */\n+  bool rem_p = NCa (a.coeffs[0]) % NCb (b.coeffs[0]) != 0;\n+  for (unsigned int i = 1; i < N; ++i)\n+    {\n+      if (b.coeffs[i] == ICb (0))\n+\t{\n+\t  /* For bi == 0 we simply need: (3') |ai| == 0.  */\n+\t  if (a.coeffs[i] != ICa (0))\n+\t    return false;\n+\t}\n+      else\n+\t{\n+\t  if (q == 0)\n+\t    {\n+\t      /* For Q == 0 we simply need: (3') |ai| <= |bi|.  */\n+\t      if (a.coeffs[i] != ICa (0))\n+\t\t{\n+\t\t  /* Use negative absolute to avoid overflow, i.e.\n+\t\t     -|ai| >= -|bi|.  */\n+\t\t  C neg_abs_a = (a.coeffs[i] < 0 ? a.coeffs[i] : -a.coeffs[i]);\n+\t\t  C neg_abs_b = (b.coeffs[i] < 0 ? b.coeffs[i] : -b.coeffs[i]);\n+\t\t  if (neg_abs_a < neg_abs_b)\n+\t\t    return false;\n+\t\t  rem_p = true;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Otherwise just check for the case in which ai / bi == Q.  */\n+\t      if (NCa (a.coeffs[i]) / NCb (b.coeffs[i]) != q)\n+\t\treturn false;\n+\t      if (NCa (a.coeffs[i]) % NCb (b.coeffs[i]) != 0)\n+\t\trem_p = true;\n+\t    }\n+\t}\n+    }\n+\n+  /* If the division isn't exact, require both values to be ordered wrt 0,\n+     so that we can guarantee conditions (2) and (3) for all indeterminate\n+     values.  */\n+  if (rem_p && (!ordered_p (a, ICa (0)) || !ordered_p (b, ICb (0))))\n+    return false;\n+\n+  *quotient = q;\n+  return true;\n+}\n+\n+/* Likewise, but also store r in *REMAINDER.  */\n+\n+template<unsigned int N, typename Ca, typename Cb, typename Cq, typename Cr>\n+inline typename if_nonpoly<Cq, bool>::type\n+can_div_trunc_p (const poly_int_pod<N, Ca> &a,\n+\t\t const poly_int_pod<N, Cb> &b,\n+\t\t Cq *quotient, Cr *remainder)\n+{\n+  if (!can_div_trunc_p (a, b, quotient))\n+    return false;\n+  *remainder = a - *quotient * b;\n+  return true;\n+}\n+\n+/* Return true if there is some polynomial q and constant R such that:\n+\n+     (1) a = B * q + R\n+     (2) |B * q| <= |a|\n+     (3) |R| < |B|\n+\n+   Store the value q in *QUOTIENT if so.  */\n+\n+template<unsigned int N, typename Ca, typename Cb, typename Cq>\n+inline typename if_nonpoly<Cb, bool>::type\n+can_div_trunc_p (const poly_int_pod<N, Ca> &a, Cb b,\n+\t\t poly_int_pod<N, Cq> *quotient)\n+{\n+  /* The remainder must be constant.  */\n+  for (unsigned int i = 1; i < N; ++i)\n+    if (a.coeffs[i] % b != 0)\n+      return false;\n+  for (unsigned int i = 0; i < N; ++i)\n+    quotient->coeffs[i] = a.coeffs[i] / b;\n+  return true;\n+}\n+\n+/* Likewise, but also store R in *REMAINDER.  */\n+\n+template<unsigned int N, typename Ca, typename Cb, typename Cq, typename Cr>\n+inline typename if_nonpoly<Cb, bool>::type\n+can_div_trunc_p (const poly_int_pod<N, Ca> &a, Cb b,\n+\t\t poly_int_pod<N, Cq> *quotient, Cr *remainder)\n+{\n+  if (!can_div_trunc_p (a, b, quotient))\n+    return false;\n+  *remainder = a.coeffs[0] % b;\n+  return true;\n+}\n+\n+/* Return true if there is some constant Q and polynomial r such that:\n+\n+     (1) a = b * Q + r\n+     (2) |a| <= |b * Q|\n+     (3) |r| < |b|\n+\n+   Store the value Q in *QUOTIENT if so.  */\n+\n+template<unsigned int N, typename Ca, typename Cb, typename Cq>\n+inline typename if_nonpoly<Cq, bool>::type\n+can_div_away_from_zero_p (const poly_int_pod<N, Ca> &a,\n+\t\t\t  const poly_int_pod<N, Cb> &b,\n+\t\t\t  Cq *quotient)\n+{\n+  if (!can_div_trunc_p (a, b, quotient))\n+    return false;\n+  if (maybe_ne (*quotient * b, a))\n+    *quotient += (*quotient < 0 ? -1 : 1);\n+  return true;\n+}\n+\n+/* Use print_dec to print VALUE to FILE, where SGN is the sign\n+   of the values.  */\n+\n+template<unsigned int N, typename C>\n+void\n+print_dec (const poly_int_pod<N, C> &value, FILE *file, signop sgn)\n+{\n+  if (value.is_constant ())\n+    print_dec (value.coeffs[0], file, sgn);\n+  else\n+    {\n+      fprintf (file, \"[\");\n+      for (unsigned int i = 0; i < N; ++i)\n+\t{\n+\t  print_dec (value.coeffs[i], file, sgn);\n+\t  fputc (i == N - 1 ? ']' : ',', file);\n+\t}\n+    }\n+}\n+\n+/* Likewise without the signop argument, for coefficients that have an\n+   inherent signedness.  */\n+\n+template<unsigned int N, typename C>\n+void\n+print_dec (const poly_int_pod<N, C> &value, FILE *file)\n+{\n+  STATIC_ASSERT (poly_coeff_traits<C>::signedness >= 0);\n+  print_dec (value, file,\n+\t     poly_coeff_traits<C>::signedness ? SIGNED : UNSIGNED);\n+}\n+\n+/* Helper for correctly comparing Pos - Start with Size in cases where\n+   known_ge (Pos, Start), Pos and Start are potentially signed, and Size is\n+   potentially unsigned.  Applying the cast function to the result of\n+   Pos - Start gives the value that should be compared with the size.\n+\n+   Try to avoid doing any unnecessary arithmetic or copying.  */\n+template<typename Pos, typename Start, typename Size,\n+\t typename Diff = POLY_BINARY_COEFF (Start, Pos),\n+\t typename Res = POLY_BINARY_COEFF (Size, Diff)>\n+struct poly_span_traits\n+{\n+  /* Assume no cast is needed.  We'll get a warning about signed vs.\n+     unsigned comparisons if the assumption is wrong.  */\n+  template<typename T>\n+  static const T &cast (const T &x) { return x; }\n+};\n+\n+/* The only case a change in type is needed is this one, in which the\n+   subtraction would give a HOST_WIDE_INT-based result if done on poly_ints\n+   and adding a zero size would give an unsigned HOST_WIDE_INT-based\n+   result.  Since we know known_ge (Pos, Start), it is safe to treat\n+   Pos - Start as an unsigned HOST_WIDE_INT.  */\n+template<typename T1, typename T2, typename T3>\n+struct poly_span_traits<T1, T2, T3, HOST_WIDE_INT, unsigned HOST_WIDE_INT>\n+{\n+  template<typename T>\n+  static typename if_nonpoly<T, unsigned HOST_WIDE_INT>::type\n+  cast (const T &x) { return x; }\n+\n+  template<unsigned int N, typename T>\n+  static poly_int<N, unsigned HOST_WIDE_INT>\n+  cast (const poly_int_pod<N, T> &x) { return x; }\n+};\n+\n+/* Return true if SIZE represents a known size, assuming that all-ones\n+   indicates an unknown size.  */\n+\n+template<typename T>\n+inline bool\n+known_size_p (const T &a)\n+{\n+  return maybe_ne (a, POLY_INT_TYPE (T) (-1));\n+}\n+\n+/* Return true if range [POS, POS + SIZE) might include VAL.\n+   SIZE can be the special value -1, in which case the range is\n+   open-ended.  */\n+\n+template<typename T1, typename T2, typename T3>\n+inline bool\n+maybe_in_range_p (const T1 &val, const T2 &pos, const T3 &size)\n+{\n+  typedef poly_span_traits<T1, T2, T3> span;\n+  if (known_lt (val, pos))\n+    return false;\n+  if (!known_size_p (size))\n+    return true;\n+  if ((poly_int_traits<T1>::num_coeffs > 1\n+       || poly_int_traits<T2>::num_coeffs > 1)\n+      && maybe_lt (val, pos))\n+    /* In this case we don't know whether VAL >= POS is true at compile\n+       time, so we can't prove that VAL >= POS + SIZE.  */\n+    return true;\n+  return maybe_lt (span::cast (val - pos), size);\n+}\n+\n+/* Return true if range [POS, POS + SIZE) is known to include VAL.\n+   SIZE can be the special value -1, in which case the range is\n+   open-ended.  */\n+\n+template<typename T1, typename T2, typename T3>\n+inline bool\n+known_in_range_p (const T1 &val, const T2 &pos, const T3 &size)\n+{\n+  typedef poly_span_traits<T1, T2, T3> span;\n+  return (known_size_p (size)\n+\t  && known_ge (val, pos)\n+\t  && known_lt (span::cast (val - pos), size));\n+}\n+\n+/* Return true if the two ranges [POS1, POS1 + SIZE1) and [POS2, POS2 + SIZE2)\n+   might overlap.  SIZE1 and/or SIZE2 can be the special value -1, in which\n+   case the range is open-ended.  */\n+\n+template<typename T1, typename T2, typename T3, typename T4>\n+inline bool\n+ranges_maybe_overlap_p (const T1 &pos1, const T2 &size1,\n+\t\t\tconst T3 &pos2, const T4 &size2)\n+{\n+  if (maybe_in_range_p (pos2, pos1, size1))\n+    return maybe_ne (size2, POLY_INT_TYPE (T4) (0));\n+  if (maybe_in_range_p (pos1, pos2, size2))\n+    return maybe_ne (size1, POLY_INT_TYPE (T2) (0));\n+  return false;\n+}\n+\n+/* Return true if the two ranges [POS1, POS1 + SIZE1) and [POS2, POS2 + SIZE2)\n+   are known to overlap.  SIZE1 and/or SIZE2 can be the special value -1,\n+   in which case the range is open-ended.  */\n+\n+template<typename T1, typename T2, typename T3, typename T4>\n+inline bool\n+ranges_known_overlap_p (const T1 &pos1, const T2 &size1,\n+\t\t\tconst T3 &pos2, const T4 &size2)\n+{\n+  typedef poly_span_traits<T1, T3, T2> span1;\n+  typedef poly_span_traits<T1, T3, T4> span2;\n+  /* known_gt (POS1 + SIZE1, POS2)                         [infinite precision]\n+     --> known_gt (SIZE1, POS2 - POS1)                     [infinite precision]\n+     --> known_gt (SIZE1, POS2 - lower_bound (POS1, POS2)) [infinite precision]\n+                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ always nonnegative\n+     --> known_gt (SIZE1, span1::cast (POS2 - lower_bound (POS1, POS2))).\n+\n+     Using the saturating subtraction enforces that SIZE1 must be\n+     nonzero, since known_gt (0, x) is false for all nonnegative x.\n+     If POS2.coeff[I] < POS1.coeff[I] for some I > 0, increasing\n+     indeterminate number I makes the unsaturated condition easier to\n+     satisfy, so using a saturated coefficient of zero tests the case in\n+     which the indeterminate is zero (the minimum value).  */\n+  return (known_size_p (size1)\n+\t  && known_size_p (size2)\n+\t  && known_lt (span1::cast (pos2 - lower_bound (pos1, pos2)), size1)\n+\t  && known_lt (span2::cast (pos1 - lower_bound (pos1, pos2)), size2));\n+}\n+\n+/* Return true if range [POS1, POS1 + SIZE1) is known to be a subrange of\n+   [POS2, POS2 + SIZE2).  SIZE1 and/or SIZE2 can be the special value -1,\n+   in which case the range is open-ended.  */\n+\n+template<typename T1, typename T2, typename T3, typename T4>\n+inline bool\n+known_subrange_p (const T1 &pos1, const T2 &size1,\n+\t\t  const T3 &pos2, const T4 &size2)\n+{\n+  typedef typename poly_int_traits<T2>::coeff_type C2;\n+  typedef POLY_BINARY_COEFF (T2, T4) size_diff_type;\n+  typedef poly_span_traits<T1, T3, size_diff_type> span;\n+  return (known_gt (size1, POLY_INT_TYPE (T2) (0))\n+\t  && (poly_coeff_traits<C2>::signedness > 0\n+\t      || known_size_p (size1))\n+\t  && known_size_p (size2)\n+\t  && known_ge (pos1, pos2)\n+\t  && known_le (size1, size2)\n+\t  && known_le (span::cast (pos1 - pos2), size2 - size1));\n+}\n+\n+/* Return true if the endpoint of the range [POS, POS + SIZE) can be\n+   stored in a T, or if SIZE is the special value -1, which makes the\n+   range open-ended.  */\n+\n+template<typename T>\n+inline typename if_nonpoly<T, bool>::type\n+endpoint_representable_p (const T &pos, const T &size)\n+{\n+  return (!known_size_p (size)\n+\t  || pos <= poly_coeff_traits<T>::max_value - size);\n+}\n+\n+template<unsigned int N, typename C>\n+inline bool\n+endpoint_representable_p (const poly_int_pod<N, C> &pos,\n+\t\t\t  const poly_int_pod<N, C> &size)\n+{\n+  if (known_size_p (size))\n+    for (unsigned int i = 0; i < N; ++i)\n+      if (pos.coeffs[i] > poly_coeff_traits<C>::max_value - size.coeffs[i])\n+\treturn false;\n+  return true;\n+}\n+\n+template<unsigned int N, typename C>\n+void\n+gt_ggc_mx (poly_int_pod<N, C> *)\n+{\n+}\n+\n+template<unsigned int N, typename C>\n+void\n+gt_pch_nx (poly_int_pod<N, C> *)\n+{\n+}\n+\n+template<unsigned int N, typename C>\n+void\n+gt_pch_nx (poly_int_pod<N, C> *, void (*) (void *, void *), void *)\n+{\n+}\n+\n+#undef POLY_SET_COEFF\n+#undef POLY_INT_TYPE\n+#undef POLY_BINARY_COEFF\n+#undef CONST_CONST_RESULT\n+#undef POLY_CONST_RESULT\n+#undef CONST_POLY_RESULT\n+#undef POLY_POLY_RESULT\n+#undef POLY_CONST_COEFF\n+#undef CONST_POLY_COEFF\n+#undef POLY_POLY_COEFF\n+\n+#endif"}, {"sha": "ab8a7c0c71c4ac6b1e78102ff1d584e271ee7219", "filename": "gcc/selftest.h", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -281,6 +281,25 @@ extern int num_passes;\n     ::selftest::fail ((LOC), desc_);\t\t\t       \\\n   SELFTEST_END_STMT\n \n+/* Evaluate EXPECTED and ACTUAL and compare them with known_eq, calling\n+   ::selftest::pass if they are always equal,\n+   ::selftest::fail if they might be non-equal.  */\n+\n+#define ASSERT_KNOWN_EQ(EXPECTED, ACTUAL) \\\n+  ASSERT_KNOWN_EQ_AT ((SELFTEST_LOCATION), (EXPECTED), (ACTUAL))\n+\n+/* Like ASSERT_KNOWN_EQ, but treat LOC as the effective location of the\n+   selftest.  */\n+\n+#define ASSERT_KNOWN_EQ_AT(LOC, EXPECTED, ACTUAL)\t\t\t\\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\t\\\n+  const char *desc = \"ASSERT_KNOWN_EQ (\" #EXPECTED \", \" #ACTUAL \")\";\t\\\n+  if (known_eq (EXPECTED, ACTUAL))\t\t\t\t\t\\\n+    ::selftest::pass ((LOC), desc);\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    ::selftest::fail ((LOC), desc);\t\t\t\t\t\\\n+  SELFTEST_END_STMT\n+\n /* Evaluate EXPECTED and ACTUAL and compare them with !=, calling\n    ::selftest::pass if they are non-equal,\n    ::selftest::fail if they are equal.  */\n@@ -294,6 +313,25 @@ extern int num_passes;\n     ::selftest::fail (SELFTEST_LOCATION, desc_);\t       \\\n   SELFTEST_END_STMT\n \n+/* Evaluate EXPECTED and ACTUAL and compare them with maybe_ne, calling\n+   ::selftest::pass if they might be non-equal,\n+   ::selftest::fail if they are known to be equal.  */\n+\n+#define ASSERT_MAYBE_NE(EXPECTED, ACTUAL) \\\n+  ASSERT_MAYBE_NE_AT ((SELFTEST_LOCATION), (EXPECTED), (ACTUAL))\n+\n+/* Like ASSERT_MAYBE_NE, but treat LOC as the effective location of the\n+   selftest.  */\n+\n+#define ASSERT_MAYBE_NE_AT(LOC, EXPECTED, ACTUAL)\t\t\t\\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\t\\\n+  const char *desc = \"ASSERT_MAYBE_NE (\" #EXPECTED \", \" #ACTUAL \")\";\t\\\n+  if (maybe_ne (EXPECTED, ACTUAL))\t\t\t\t\t\\\n+    ::selftest::pass ((LOC), desc);\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    ::selftest::fail ((LOC), desc);\t\t\t\t\t\\\n+  SELFTEST_END_STMT\n+\n /* Evaluate EXPECTED and ACTUAL and compare them with strcmp, calling\n    ::selftest::pass if they are equal,\n    ::selftest::fail if they are non-equal.  */"}, {"sha": "78577d6bf84e9eca0838b784436b56659bdcb178", "filename": "gcc/target.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -3784,6 +3784,14 @@ candidate as a replacement for the if-convertible sequence described in\\n\\\n bool, (rtx_insn *seq, struct noce_if_info *if_info),\n default_noce_conversion_profitable_p)\n \n+DEFHOOK\n+(estimated_poly_value,\n+ \"Return an estimate of the runtime value of @var{val}, for use in\\n\\\n+things like cost calculations or profiling frequencies.  The default\\n\\\n+implementation returns the lowest possible value of @var{val}.\",\n+ HOST_WIDE_INT, (poly_int64 val),\n+ default_estimated_poly_value)\n+\n /* Permit speculative instructions in delay slots during delayed-branch \n    scheduling.  */\n DEFHOOK"}, {"sha": "9696b4d61e1d0e5e85a28d1b8b1509f918a80b0a", "filename": "gcc/target.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -211,6 +211,21 @@ typedef auto_vec<unsigned short, 32> auto_vec_perm_indices;\n \n extern struct gcc_target targetm;\n \n+/* Return an estimate of the runtime value of X, for use in things\n+   like cost calculations or profiling frequencies.  Note that this\n+   function should never be used in situations where the actual\n+   runtime value is needed for correctness, since the function only\n+   provides a rough guess.  */\n+\n+static inline HOST_WIDE_INT\n+estimated_poly_value (poly_int64 x)\n+{\n+  if (NUM_POLY_INT_COEFFS == 1)\n+    return x.coeffs[0];\n+  else\n+    return targetm.estimated_poly_value (x);\n+}\n+\n #ifdef GCC_TM_H\n \n #ifndef CUMULATIVE_ARGS_MAGIC"}, {"sha": "6b3279e4b38140c2246b302481c1905cb284751e", "filename": "gcc/targhooks.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -1666,6 +1666,14 @@ default_slow_unaligned_access (machine_mode, unsigned int)\n   return STRICT_ALIGNMENT;\n }\n \n+/* The default implementation of TARGET_ESTIMATED_POLY_VALUE.  */\n+\n+HOST_WIDE_INT\n+default_estimated_poly_value (poly_int64 x)\n+{\n+  return x.coeffs[0];\n+}\n+\n /* For hooks which use the MOVE_RATIO macro, this gives the legacy default\n    behavior.  SPEED_P is true if we are compiling for speed.  */\n "}, {"sha": "4c6c65cd312892cbba611054d4b39fefb9620e06", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -210,6 +210,7 @@ extern int default_memory_move_cost (machine_mode, reg_class_t, bool);\n extern int default_register_move_cost (machine_mode, reg_class_t,\n \t\t\t\t       reg_class_t);\n extern bool default_slow_unaligned_access (machine_mode, unsigned int);\n+extern HOST_WIDE_INT default_estimated_poly_value (poly_int64);\n \n extern bool default_use_by_pieces_infrastructure_p (unsigned HOST_WIDE_INT,\n \t\t\t\t\t\t    unsigned int,"}, {"sha": "b80b2f2bf55e5494eb36b776133e5231cd22e223", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -1,3 +1,18 @@\n+2017-12-14  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc.dg/plugin/poly-int-tests.h,\n+\tgcc.dg/plugin/poly-int-test-1.c,\n+\tgcc.dg/plugin/poly-int-01_plugin.c,\n+\tgcc.dg/plugin/poly-int-02_plugin.c,\n+\tgcc.dg/plugin/poly-int-03_plugin.c,\n+\tgcc.dg/plugin/poly-int-04_plugin.c,\n+\tgcc.dg/plugin/poly-int-05_plugin.c,\n+\tgcc.dg/plugin/poly-int-06_plugin.c,\n+\tgcc.dg/plugin/poly-int-07_plugin.c: New tests.\n+\t* gcc.dg/plugin/plugin.exp: Run them.\n+\n 2017-12-13  Peter Bergner  <bergner@vnet.ibm.com>\n \n \t* gcc.target/powerpc/cpu-builtin-1.c (htm-no-suspend): Add test."}, {"sha": "057f4e223dfdc12a3c3edea0a7b3f3484fde0817", "filename": "gcc/testsuite/gcc.dg/plugin/plugin.exp", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -62,6 +62,13 @@ set plugin_test_list [list \\\n     { start_unit_plugin.c start_unit-test-1.c } \\\n     { finish_unit_plugin.c finish_unit-test-1.c } \\\n     { wide-int_plugin.c wide-int-test-1.c } \\\n+    { poly-int-01_plugin.c poly-int-test-1.c } \\\n+    { poly-int-02_plugin.c poly-int-test-1.c } \\\n+    { poly-int-03_plugin.c poly-int-test-1.c } \\\n+    { poly-int-04_plugin.c poly-int-test-1.c } \\\n+    { poly-int-05_plugin.c poly-int-test-1.c } \\\n+    { poly-int-06_plugin.c poly-int-test-1.c } \\\n+    { poly-int-07_plugin.c poly-int-test-1.c } \\\n     { diagnostic_plugin_test_show_locus.c \\\n \t  diagnostic-test-show-locus-bw.c \\\n \t  diagnostic-test-show-locus-color.c \\"}, {"sha": "099c9d94c42c092e383fa15ba594da779dff1846", "filename": "gcc/testsuite/gcc.dg/plugin/poly-int-01_plugin.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-01_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-01_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-01_plugin.c?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -0,0 +1,21 @@\n+/* Not worth spending time optimizing this.  */\n+/* { dg-options \"-O0\" } */\n+\n+#include \"config.h\"\n+#include \"gcc-plugin.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"poly-int-tests.h\"\n+\n+int plugin_is_GPL_compatible;\n+\n+int\n+plugin_init (struct plugin_name_args *plugin_info,\n+\t     struct plugin_gcc_version *version)\n+{\n+  test_helper ();\n+  test_poly_coeff_traits ();\n+  test_nonpoly ();\n+  test_endpoint_representable ();\n+  return 0;\n+}"}, {"sha": "bf103acba8be410a5d7ec573e10d708670f9e01f", "filename": "gcc/testsuite/gcc.dg/plugin/poly-int-02_plugin.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-02_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-02_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-02_plugin.c?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -0,0 +1,18 @@\n+/* Not worth spending time optimizing this.  */\n+/* { dg-options \"-O0\" } */\n+\n+#include \"config.h\"\n+#include \"gcc-plugin.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"poly-int-tests.h\"\n+\n+int plugin_is_GPL_compatible;\n+\n+int\n+plugin_init (struct plugin_name_args *plugin_info,\n+\t     struct plugin_gcc_version *version)\n+{\n+  test_num_coeffs_core<1> ();\n+  return 0;\n+}"}, {"sha": "0c08ead8b752a0b8f56fa53faf8684ba9862c752", "filename": "gcc/testsuite/gcc.dg/plugin/poly-int-03_plugin.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-03_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-03_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-03_plugin.c?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -0,0 +1,18 @@\n+/* Not worth spending time optimizing this.  */\n+/* { dg-options \"-O0\" } */\n+\n+#include \"config.h\"\n+#include \"gcc-plugin.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"poly-int-tests.h\"\n+\n+int plugin_is_GPL_compatible;\n+\n+int\n+plugin_init (struct plugin_name_args *plugin_info,\n+\t     struct plugin_gcc_version *version)\n+{\n+  test_num_coeffs_extra<1> ();\n+  return 0;\n+}"}, {"sha": "8b0a5f91fb4499a7fb7d2b1ba82fda49eccc46eb", "filename": "gcc/testsuite/gcc.dg/plugin/poly-int-04_plugin.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-04_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-04_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-04_plugin.c?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -0,0 +1,18 @@\n+/* Not worth spending time optimizing this.  */\n+/* { dg-options \"-O0\" } */\n+\n+#include \"config.h\"\n+#include \"gcc-plugin.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"poly-int-tests.h\"\n+\n+int plugin_is_GPL_compatible;\n+\n+int\n+plugin_init (struct plugin_name_args *plugin_info,\n+\t     struct plugin_gcc_version *version)\n+{\n+  test_num_coeffs_core<2> ();\n+  return 0;\n+}"}, {"sha": "62493118fe4027ca957b6eca5461b4bc9a6ee8e8", "filename": "gcc/testsuite/gcc.dg/plugin/poly-int-05_plugin.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-05_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-05_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-05_plugin.c?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -0,0 +1,18 @@\n+/* Not worth spending time optimizing this.  */\n+/* { dg-options \"-O0\" } */\n+\n+#include \"config.h\"\n+#include \"gcc-plugin.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"poly-int-tests.h\"\n+\n+int plugin_is_GPL_compatible;\n+\n+int\n+plugin_init (struct plugin_name_args *plugin_info,\n+\t     struct plugin_gcc_version *version)\n+{\n+  test_num_coeffs_extra<2> ();\n+  return 0;\n+}"}, {"sha": "ee4308c26bf8ea314a735ce5608398ea2cff09d3", "filename": "gcc/testsuite/gcc.dg/plugin/poly-int-06_plugin.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-06_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-06_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-06_plugin.c?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -0,0 +1,26 @@\n+/* Not worth spending time optimizing this.  */\n+/* { dg-options \"-O0\" } */\n+\n+#include \"config.h\"\n+#include \"gcc-plugin.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"poly-int-tests.h\"\n+\n+int plugin_is_GPL_compatible;\n+\n+int\n+plugin_init (struct plugin_name_args *plugin_info,\n+\t     struct plugin_gcc_version *version)\n+{\n+  test_signed_2<int> ();\n+  test_signed_2<HOST_WIDE_INT> ();\n+  test_signed_2<offset_int> ();\n+  test_signed_2<widest_int> ();\n+\n+  test_ordered_2<unsigned short> ();\n+  test_ordered_2<unsigned int> ();\n+  test_ordered_2<unsigned HOST_WIDE_INT> ();\n+\n+  return 0;\n+}"}, {"sha": "e3203d9f3e1a19c6001fcd8d20e0f82527dfe1fa", "filename": "gcc/testsuite/gcc.dg/plugin/poly-int-07_plugin.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-07_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-07_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-07_plugin.c?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -0,0 +1,18 @@\n+/* Not worth spending time optimizing this.  */\n+/* { dg-options \"-O\" } */\n+\n+#include \"config.h\"\n+#include \"gcc-plugin.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"poly-int-tests.h\"\n+\n+int plugin_is_GPL_compatible;\n+\n+int\n+plugin_init (struct plugin_name_args *plugin_info,\n+\t     struct plugin_gcc_version *version)\n+{\n+  test_num_coeffs_core<3> ();\n+  return 0;\n+}"}, {"sha": "fe284d594334a38d3a23aa6fc699dcabb7932fea", "filename": "gcc/testsuite/gcc.dg/plugin/poly-int-test-1.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-test-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-test-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-test-1.c?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+\n+int\n+main (int argc, char **argv)\n+{\n+  return 0;\n+}"}, {"sha": "b195f67aaf41a8661404b397360eb9fb74069ddb", "filename": "gcc/testsuite/gcc.dg/plugin/poly-int-tests.h", "status": "added", "additions": 4778, "deletions": 0, "changes": 4778, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-tests.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-tests.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-tests.h?ref=e535b963b4a39e041cc81e2879cfb637d60c720d"}, {"sha": "bbfde909aeb17654568dd7ec2d8152b52ad7eb09", "filename": "gcc/wide-int.h", "status": "modified", "additions": 49, "deletions": 11, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Fwide-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e535b963b4a39e041cc81e2879cfb637d60c720d/gcc%2Fwide-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.h?ref=e535b963b4a39e041cc81e2879cfb637d60c720d", "patch": "@@ -293,7 +293,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* The type of result produced by a unary operation on type T.  */\n #define WI_UNARY_RESULT(T) \\\n-  typename wi::unary_traits <T>::result_type\n+  typename wi::binary_traits <T, T>::result_type\n \n /* Define a variable RESULT to hold the result of a binary operation on\n    X and Y, which have types T1 and T2 respectively.  Define VAL to\n@@ -390,11 +390,6 @@ namespace wi\n \t    enum precision_type P2 = int_traits <T2>::precision_type>\n   struct binary_traits;\n \n-  /* The result of a unary operation on T is the same as the result of\n-     a binary operation on two values of type T.  */\n-  template <typename T>\n-  struct unary_traits : public binary_traits <T, T> {};\n-\n   /* Specify the result type for each supported combination of binary\n      inputs.  Note that CONST_PRECISION and VAR_PRECISION cannot be\n      mixed, in order to give stronger type checking.  When both inputs\n@@ -423,6 +418,7 @@ namespace wi\n \t\t\t       <int_traits <T2>::precision> > result_type;\n     typedef result_type operator_result;\n     typedef bool predicate_result;\n+    typedef result_type signed_shift_result_type;\n     typedef bool signed_predicate_result;\n   };\n \n@@ -727,7 +723,7 @@ class GTY(()) generic_wide_int : public storage\n   ASSIGNMENT_OPERATOR (operator +=, add)\n   ASSIGNMENT_OPERATOR (operator -=, sub)\n   ASSIGNMENT_OPERATOR (operator *=, mul)\n-  SHIFT_ASSIGNMENT_OPERATOR (operator <<=, <<)\n+  ASSIGNMENT_OPERATOR (operator <<=, lshift)\n   SHIFT_ASSIGNMENT_OPERATOR (operator >>=, >>)\n   INCDEC_OPERATOR (operator ++, 1)\n   INCDEC_OPERATOR (operator --, -1)\n@@ -1513,6 +1509,7 @@ namespace wi\n      and precision PRECISION.  */\n   struct hwi_with_prec\n   {\n+    hwi_with_prec () {}\n     hwi_with_prec (HOST_WIDE_INT, unsigned int, signop);\n     HOST_WIDE_INT val;\n     unsigned int precision;\n@@ -1580,6 +1577,30 @@ wi::two (unsigned int precision)\n   return wi::shwi (2, precision);\n }\n \n+namespace wi\n+{\n+  /* ints_for<T>::zero (X) returns a zero that, when asssigned to a T,\n+     gives that T the same precision as X.  */\n+  template<typename T, precision_type = int_traits<T>::precision_type>\n+  struct ints_for\n+  {\n+    static int zero (const T &) { return 0; }\n+  };\n+\n+  template<typename T>\n+  struct ints_for<T, VAR_PRECISION>\n+  {\n+    static hwi_with_prec zero (const T &);\n+  };\n+}\n+\n+template<typename T>\n+inline wi::hwi_with_prec\n+wi::ints_for<T, wi::VAR_PRECISION>::zero (const T &x)\n+{\n+  return wi::zero (wi::get_precision (x));\n+}\n+\n namespace wi\n {\n   template <>\n@@ -3152,6 +3173,14 @@ SIGNED_BINARY_PREDICATE (operator >=, ges_p)\n     return wi::F (x, y); \\\n   }\n \n+#define SHIFT_OPERATOR(OP, F) \\\n+  template<typename T1, typename T2> \\\n+  WI_BINARY_OPERATOR_RESULT (T1, T1) \\\n+  OP (const T1 &x, const T2 &y) \\\n+  { \\\n+    return wi::F (x, y); \\\n+  }\n+\n UNARY_OPERATOR (operator ~, bit_not)\n UNARY_OPERATOR (operator -, neg)\n BINARY_PREDICATE (operator ==, eq_p)\n@@ -3162,23 +3191,32 @@ BINARY_OPERATOR (operator ^, bit_xor)\n BINARY_OPERATOR (operator +, add)\n BINARY_OPERATOR (operator -, sub)\n BINARY_OPERATOR (operator *, mul)\n+SHIFT_OPERATOR (operator <<, lshift)\n \n #undef UNARY_OPERATOR\n #undef BINARY_PREDICATE\n #undef BINARY_OPERATOR\n+#undef SHIFT_OPERATOR\n+\n+template <typename T1, typename T2>\n+inline WI_SIGNED_SHIFT_RESULT (T1, T2)\n+operator >> (const T1 &x, const T2 &y)\n+{\n+  return wi::arshift (x, y);\n+}\n \n template <typename T1, typename T2>\n inline WI_SIGNED_SHIFT_RESULT (T1, T2)\n-operator << (const T1 &x, const T2 &y)\n+operator / (const T1 &x, const T2 &y)\n {\n-  return wi::lshift (x, y);\n+  return wi::sdiv_trunc (x, y);\n }\n \n template <typename T1, typename T2>\n inline WI_SIGNED_SHIFT_RESULT (T1, T2)\n-operator >> (const T1 &x, const T2 &y)\n+operator % (const T1 &x, const T2 &y)\n {\n-  return wi::arshift (x, y);\n+  return wi::smod_trunc (x, y);\n }\n \n template<typename T>"}]}