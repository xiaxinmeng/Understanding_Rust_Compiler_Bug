{"sha": "5dab8b11c41fe72ea606c38884f7730bd2aeafdc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRhYjhiMTFjNDFmZTcyZWE2MDZjMzg4ODRmNzczMGJkMmFlYWZkYw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2018-11-05T07:46:57Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2018-11-05T07:46:57Z"}, "message": "Fix various latent issues revealed by P0732 work.\n\nThe initialized_type hunk fixes handling of void AGGR_INIT_EXPRs that call a\nnon-constructor; an AGGR_INIT_EXPR can have void type if its initialization\nsemantics are more complicated than just expanding the call.\n\nThe cxx_eval_vec_init_1 hunk corrects AGGR_INIT_EXPRs that were\nnonsensically built to initialize an object of void type.  And the\nbuild_aggr_init_expr hunk makes sure we don't do that again.\n\nThe ocp_convert and cxx_eval_outermost_constant_expr hunks deal with making\nsure that a constant CONSTRUCTOR has the right type.\n\n\t* cvt.c (ocp_convert): Don't wrap a CONSTRUCTOR in a NOP_EXPR.\n\t* constexpr.c (initialized_type): Fix AGGR_INIT_EXPR handling.\n\t(cxx_eval_vec_init_1): Correct type of AGGR_INIT_EXPR.\n\t(cxx_eval_outermost_constant_expr): Make sure a CONSTRUCTOR has the\n\tright type.  Don't wrap a CONSTRUCTOR if one was passed in.\n\t* tree.c (build_aggr_init_expr): Check for void.\n\nFrom-SVN: r265788", "tree": {"sha": "93c5972f6c8b0ac891b9a3d2e0afdc8eda67bf8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93c5972f6c8b0ac891b9a3d2e0afdc8eda67bf8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5dab8b11c41fe72ea606c38884f7730bd2aeafdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dab8b11c41fe72ea606c38884f7730bd2aeafdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dab8b11c41fe72ea606c38884f7730bd2aeafdc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dab8b11c41fe72ea606c38884f7730bd2aeafdc/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c24c8a4b003f81734c2a94e0980008c2c24659d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c24c8a4b003f81734c2a94e0980008c2c24659d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c24c8a4b003f81734c2a94e0980008c2c24659d9"}], "stats": {"total": 41, "additions": 31, "deletions": 10}, "files": [{"sha": "4f40627a2261fc456f53411d38171ed5ec97fa81", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dab8b11c41fe72ea606c38884f7730bd2aeafdc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dab8b11c41fe72ea606c38884f7730bd2aeafdc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5dab8b11c41fe72ea606c38884f7730bd2aeafdc", "patch": "@@ -1,5 +1,12 @@\n 2018-11-04  Jason Merrill  <jason@redhat.com>\n \n+\t* cvt.c (ocp_convert): Don't wrap a CONSTRUCTOR in a NOP_EXPR.\n+\t* constexpr.c (initialized_type): Fix AGGR_INIT_EXPR handling.\n+\t(cxx_eval_vec_init_1): Correct type of AGGR_INIT_EXPR.\n+\t(cxx_eval_outermost_constant_expr): Make sure a CONSTRUCTOR has the\n+\tright type.  Don't wrap a CONSTRUCTOR if one was passed in.\n+\t* tree.c (build_aggr_init_expr): Check for void.\n+\n \tPR c++/60503 - wrong lambda attribute syntax.\n \t* parser.c (cp_parser_lambda_declarator_opt): Fix attribute\n \thandling."}, {"sha": "4fb1ba527e3207149e1703f1477d4060bf4bcc51", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dab8b11c41fe72ea606c38884f7730bd2aeafdc/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dab8b11c41fe72ea606c38884f7730bd2aeafdc/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=5dab8b11c41fe72ea606c38884f7730bd2aeafdc", "patch": "@@ -2778,16 +2778,20 @@ initialized_type (tree t)\n {\n   if (TYPE_P (t))\n     return t;\n-  tree type = cv_unqualified (TREE_TYPE (t));\n-  if (TREE_CODE (t) == CALL_EXPR || TREE_CODE (t) == AGGR_INIT_EXPR)\n+  tree type = TREE_TYPE (t);\n+  if (!VOID_TYPE_P (type))\n+    /* No need to look deeper.  */;\n+  else if (TREE_CODE (t) == CALL_EXPR)\n     {\n       /* A constructor call has void type, so we need to look deeper.  */\n       tree fn = get_function_named_in_call (t);\n       if (fn && TREE_CODE (fn) == FUNCTION_DECL\n \t  && DECL_CXX_CONSTRUCTOR_P (fn))\n \ttype = DECL_CONTEXT (fn);\n     }\n-  return type;\n+  else if (TREE_CODE (t) == AGGR_INIT_EXPR)\n+    type = TREE_TYPE (AGGR_INIT_EXPR_SLOT (t));\n+  return cv_unqualified (type);\n }\n \n /* We're about to initialize element INDEX of an array or class from VALUE.\n@@ -3000,7 +3004,7 @@ cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,\n \t\t\t\t\t&argvec, elttype, LOOKUP_NORMAL,\n \t\t\t\t\tcomplain);\n       release_tree_vector (argvec);\n-      init = build_aggr_init_expr (TREE_TYPE (init), init);\n+      init = build_aggr_init_expr (elttype, init);\n       pre_init = true;\n     }\n \n@@ -5089,26 +5093,26 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n \tr = build_nop (TREE_TYPE (r), r);\n       TREE_CONSTANT (r) = false;\n     }\n-  else if (non_constant_p || r == t)\n+  else if (non_constant_p)\n     return t;\n \n   if (should_unshare)\n     r = unshare_expr (r);\n \n   if (TREE_CODE (r) == CONSTRUCTOR && CLASS_TYPE_P (TREE_TYPE (r)))\n     {\n+      r = adjust_temp_type (type, r);\n       if (TREE_CODE (t) == TARGET_EXPR\n \t  && TARGET_EXPR_INITIAL (t) == r)\n \treturn t;\n-      else\n+      else if (TREE_CODE (t) != CONSTRUCTOR)\n \t{\n \t  r = get_target_expr (r);\n \t  TREE_CONSTANT (r) = true;\n-\t  return r;\n \t}\n     }\n-  else\n-    return r;\n+\n+  return r;\n }\n \n /* Returns true if T is a valid subexpression of a constant expression,"}, {"sha": "b04e9a70652663010433513f560339319713a480", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dab8b11c41fe72ea606c38884f7730bd2aeafdc/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dab8b11c41fe72ea606c38884f7730bd2aeafdc/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=5dab8b11c41fe72ea606c38884f7730bd2aeafdc", "patch": "@@ -725,7 +725,8 @@ ocp_convert (tree type, tree expr, int convtype, int flags,\n     /* We need a new temporary; don't take this shortcut.  */;\n   else if (same_type_ignoring_top_level_qualifiers_p (type, TREE_TYPE (e)))\n     {\n-      if (same_type_p (type, TREE_TYPE (e)))\n+      tree etype = TREE_TYPE (e);\n+      if (same_type_p (type, etype))\n \t/* The call to fold will not always remove the NOP_EXPR as\n \t   might be expected, since if one of the types is a typedef;\n \t   the comparison in fold is just equality of pointers, not a\n@@ -743,9 +744,16 @@ ocp_convert (tree type, tree expr, int convtype, int flags,\n \t{\n \t  /* Don't build a NOP_EXPR of class type.  Instead, change the\n \t     type of the temporary.  */\n+\t  gcc_assert (same_type_ignoring_top_level_qualifiers_p (type, etype));\n \t  TREE_TYPE (e) = TREE_TYPE (TARGET_EXPR_SLOT (e)) = type;\n \t  return e;\n \t}\n+      else if (TREE_CODE (e) == CONSTRUCTOR)\n+\t{\n+\t  gcc_assert (same_type_ignoring_top_level_qualifiers_p (type, etype));\n+\t  TREE_TYPE (e) = type;\n+\t  return e;\n+\t}\n       else\n \t{\n \t  /* We shouldn't be treating objects of ADDRESSABLE type as"}, {"sha": "51af9f2015e2c2a5bce144dc63fe6b9c48fac750", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dab8b11c41fe72ea606c38884f7730bd2aeafdc/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dab8b11c41fe72ea606c38884f7730bd2aeafdc/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=5dab8b11c41fe72ea606c38884f7730bd2aeafdc", "patch": "@@ -576,6 +576,8 @@ build_aggr_init_expr (tree type, tree init)\n   tree rval;\n   int is_ctor;\n \n+  gcc_assert (!VOID_TYPE_P (type));\n+\n   /* Don't build AGGR_INIT_EXPR in a template.  */\n   if (processing_template_decl)\n     return init;"}]}