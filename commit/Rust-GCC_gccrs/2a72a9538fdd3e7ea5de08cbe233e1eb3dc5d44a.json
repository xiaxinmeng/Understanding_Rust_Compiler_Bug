{"sha": "2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE3MmE5NTM4ZmRkM2U3ZWE1ZGUwOGNiZTIzM2UxZWIzZGM1ZDQ0YQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-12-08T19:31:45Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-12-08T19:31:45Z"}, "message": "PR jit/63854: Introduce xstrdup_for_dump\n\ngcc/ChangeLog:\n\tPR jit/63854\n\t* cgraph.h (xstrdup_for_dump): New function.\n\t* cgraph.c (cgraph_node::get_create): Replace use of xstrdup\n\twithin fprintf with xstrdup_for_dump.\n\t(cgraph_edge::make_speculative): Likewise.\n\t(cgraph_edge::resolve_speculation): Likewise.\n\t(cgraph_edge::redirect_call_stmt_to_callee): Likewise.\n\t(cgraph_node::dump): Likewise.\n\t* cgraphclones.c (symbol_table::materialize_all_clones): Likewise.\n\t* ipa-cp.c (perhaps_add_new_callers): Likewise.\n\t* ipa-inline.c (report_inline_failed_reason): Likewise.\n\t(want_early_inline_function_p): Likewise.\n\t(edge_badness): Likewise.\n\t(update_edge_key): Likewise.\n\t(flatten_function): Likewise.\n\t(inline_always_inline_functions): Likewise.\n\t* ipa-profile.c (ipa_profile): Likewise.\n\t* ipa-prop.c (ipa_print_node_jump_functions): Likewise.\n\t(ipa_make_edge_direct_to_target): Likewise.\n\t(remove_described_reference): Likewise.\n\t(propagate_controlled_uses): Likewise.\n\t* ipa-utils.c (ipa_merge_profiles): Likewise.\n\nFrom-SVN: r218490", "tree": {"sha": "717a1d74dbcf55ae4d71c2fc03be956c6157212c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/717a1d74dbcf55ae4d71c2fc03be956c6157212c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "53b730ff90bc866123609de78bf5247e6ae328cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53b730ff90bc866123609de78bf5247e6ae328cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53b730ff90bc866123609de78bf5247e6ae328cf"}], "stats": {"total": 183, "additions": 120, "deletions": 63}, "files": [{"sha": "5e4306d8b0a9652e1d7e282cef3b92c98fd1d16c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a", "patch": "@@ -1,3 +1,28 @@\n+2014-12-08  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR jit/63854\n+\t* cgraph.h (xstrdup_for_dump): New function.\n+\t* cgraph.c (cgraph_node::get_create): Replace use of xstrdup\n+\twithin fprintf with xstrdup_for_dump.\n+\t(cgraph_edge::make_speculative): Likewise.\n+\t(cgraph_edge::resolve_speculation): Likewise.\n+\t(cgraph_edge::redirect_call_stmt_to_callee): Likewise.\n+\t(cgraph_node::dump): Likewise.\n+\t* cgraphclones.c (symbol_table::materialize_all_clones): Likewise.\n+\t* ipa-cp.c (perhaps_add_new_callers): Likewise.\n+\t* ipa-inline.c (report_inline_failed_reason): Likewise.\n+\t(want_early_inline_function_p): Likewise.\n+\t(edge_badness): Likewise.\n+\t(update_edge_key): Likewise.\n+\t(flatten_function): Likewise.\n+\t(inline_always_inline_functions): Likewise.\n+\t* ipa-profile.c (ipa_profile): Likewise.\n+\t* ipa-prop.c (ipa_print_node_jump_functions): Likewise.\n+\t(ipa_make_edge_direct_to_target): Likewise.\n+\t(remove_described_reference): Likewise.\n+\t(propagate_controlled_uses): Likewise.\n+\t* ipa-utils.c (ipa_merge_profiles): Likewise.\n+\n 2014-12-08  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \n \tPR ipa/64049"}, {"sha": "50c7b34b3dc9efd85a1a989de4fe814d1bebcc67", "filename": "gcc/cgraph.c", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a", "patch": "@@ -537,11 +537,11 @@ cgraph_node::get_create (tree decl)\n       if (dump_file)\n \tfprintf (dump_file, \"Introduced new external node \"\n \t\t \"(%s/%i) and turned into root of the clone tree.\\n\",\n-\t\t xstrdup (node->name ()), node->order);\n+\t\t xstrdup_for_dump (node->name ()), node->order);\n     }\n   else if (dump_file)\n     fprintf (dump_file, \"Introduced new external node \"\n-\t     \"(%s/%i).\\n\", xstrdup (node->name ()),\n+\t     \"(%s/%i).\\n\", xstrdup_for_dump (node->name ()),\n \t     node->order);\n   return node;\n }\n@@ -1070,8 +1070,8 @@ cgraph_edge::make_speculative (cgraph_node *n2, gcov_type direct_count,\n     {\n       fprintf (dump_file, \"Indirect call -> speculative call\"\n \t       \" %s/%i => %s/%i\\n\",\n-\t       xstrdup (n->name ()), n->order,\n-\t       xstrdup (n2->name ()), n2->order);\n+\t       xstrdup_for_dump (n->name ()), n->order,\n+\t       xstrdup_for_dump (n2->name ()), n2->order);\n     }\n   speculative = true;\n   e2 = n->create_edge (n2, call_stmt, direct_count, direct_frequency);\n@@ -1190,16 +1190,20 @@ cgraph_edge::resolve_speculation (tree callee_decl)\n \t    {\n \t      fprintf (dump_file, \"Speculative indirect call %s/%i => %s/%i has \"\n \t\t       \"turned out to have contradicting known target \",\n-\t\t       xstrdup (edge->caller->name ()), edge->caller->order,\n-\t\t       xstrdup (e2->callee->name ()), e2->callee->order);\n+\t\t       xstrdup_for_dump (edge->caller->name ()),\n+\t\t       edge->caller->order,\n+\t\t       xstrdup_for_dump (e2->callee->name ()),\n+\t\t       e2->callee->order);\n \t      print_generic_expr (dump_file, callee_decl, 0);\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n \t  else\n \t    {\n \t      fprintf (dump_file, \"Removing speculative call %s/%i => %s/%i\\n\",\n-\t\t       xstrdup (edge->caller->name ()), edge->caller->order,\n-\t\t       xstrdup (e2->callee->name ()), e2->callee->order);\n+\t\t       xstrdup_for_dump (edge->caller->name ()),\n+\t\t       edge->caller->order,\n+\t\t       xstrdup_for_dump (e2->callee->name ()),\n+\t\t       e2->callee->order);\n \t    }\n \t}\n     }\n@@ -1319,9 +1323,9 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Not expanding speculative call of %s/%i -> %s/%i\\n\"\n \t\t     \"Type mismatch.\\n\",\n-\t\t     xstrdup (e->caller->name ()),\n+\t\t     xstrdup_for_dump (e->caller->name ()),\n \t\t     e->caller->order,\n-\t\t     xstrdup (e->callee->name ()),\n+\t\t     xstrdup_for_dump (e->callee->name ()),\n \t\t     e->callee->order);\n \t  e = e->resolve_speculation ();\n \t  /* We are producing the final function body and will throw away the\n@@ -1338,9 +1342,9 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n \t    fprintf (dump_file,\n \t\t     \"Expanding speculative call of %s/%i -> %s/%i count:\"\n \t\t     \"%\"PRId64\"\\n\",\n-\t\t     xstrdup (e->caller->name ()),\n+\t\t     xstrdup_for_dump (e->caller->name ()),\n \t\t     e->caller->order,\n-\t\t     xstrdup (e->callee->name ()),\n+\t\t     xstrdup_for_dump (e->callee->name ()),\n \t\t     e->callee->order,\n \t\t     (int64_t)e->count);\n \t  gcc_assert (e2->speculative);\n@@ -1415,8 +1419,8 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n   if (symtab->dump_file)\n     {\n       fprintf (symtab->dump_file, \"updating call of %s/%i -> %s/%i: \",\n-\t       xstrdup (e->caller->name ()), e->caller->order,\n-\t       xstrdup (e->callee->name ()), e->callee->order);\n+\t       xstrdup_for_dump (e->caller->name ()), e->caller->order,\n+\t       xstrdup_for_dump (e->callee->name ()), e->callee->order);\n       print_gimple_stmt (symtab->dump_file, e->call_stmt, 0, dump_flags);\n       if (e->callee->clone.combined_args_to_skip)\n \t{\n@@ -1965,9 +1969,9 @@ cgraph_node::dump (FILE *f)\n \n   if (global.inlined_to)\n     fprintf (f, \"  Function %s/%i is inline copy in %s/%i\\n\",\n-\t     xstrdup (name ()),\n+\t     xstrdup_for_dump (name ()),\n \t     order,\n-\t     xstrdup (global.inlined_to->name ()),\n+\t     xstrdup_for_dump (global.inlined_to->name ()),\n \t     global.inlined_to->order);\n   if (clone_of)\n     fprintf (f, \"  Clone of %s/%i\\n\","}, {"sha": "891b92500e7539a81d0829332cac8e262d01dec7", "filename": "gcc/cgraph.h", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a", "patch": "@@ -2833,4 +2833,32 @@ cgraph_local_p (cgraph_node *node)\n   return node->local.local && node->instrumented_version->local.local;\n }\n \n+/* When using fprintf (or similar), problems can arise with\n+   transient generated strings.  Many string-generation APIs\n+   only support one result being alive at once (e.g. by\n+   returning a pointer to a statically-allocated buffer).\n+\n+   If there is more than one generated string within one\n+   fprintf call: the first string gets evicted or overwritten\n+   by the second, before fprintf is fully evaluated.\n+   See e.g. PR/53136.\n+\n+   This function provides a workaround for this, by providing\n+   a simple way to create copies of these transient strings,\n+   without the need to have explicit cleanup:\n+\n+       fprintf (dumpfile, \"string 1: %s string 2:%s\\n\",\n+                xstrdup_for_dump (EXPR_1),\n+                xstrdup_for_dump (EXPR_2));\n+\n+   This is actually a simple wrapper around ggc_strdup, but\n+   the name documents the intent.  We require that no GC can occur\n+   within the fprintf call.  */\n+\n+static inline const char *\n+xstrdup_for_dump (const char *transient_str)\n+{\n+  return ggc_strdup (transient_str);\n+}\n+\n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "13bb0e95b44a0c1cc1d5a2b70df4a375c07e779c", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a", "patch": "@@ -1094,8 +1094,8 @@ symbol_table::materialize_all_clones (void)\n \t\t  if (symtab->dump_file)\n \t\t    {\n \t\t      fprintf (symtab->dump_file, \"cloning %s to %s\\n\",\n-\t\t\t       xstrdup (node->clone_of->name ()),\n-\t\t\t       xstrdup (node->name ()));\n+\t\t\t       xstrdup_for_dump (node->clone_of->name ()),\n+\t\t\t       xstrdup_for_dump (node->name ()));\n \t\t      if (node->clone.tree_map)\n \t\t        {\n \t\t\t  unsigned int i;"}, {"sha": "79a1799d90137295e015a629ca0709c2e068fbaa", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a", "patch": "@@ -3907,9 +3907,9 @@ perhaps_add_new_callers (cgraph_node *node, ipcp_value<valtype> *val)\n \t      if (dump_file)\n \t\tfprintf (dump_file, \" - adding an extra caller %s/%i\"\n \t\t\t \" of %s/%i\\n\",\n-\t\t\t xstrdup (cs->caller->name ()),\n+\t\t\t xstrdup_for_dump (cs->caller->name ()),\n \t\t\t cs->caller->order,\n-\t\t\t xstrdup (val->spec_node->name ()),\n+\t\t\t xstrdup_for_dump (val->spec_node->name ()),\n \t\t\t val->spec_node->order);\n \n \t      cs->redirect_callee_duplicating_thunks (val->spec_node);"}, {"sha": "f62760fd39ca06315604000ebcf494daeea12440", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a", "patch": "@@ -248,8 +248,8 @@ report_inline_failed_reason (struct cgraph_edge *e)\n   if (dump_file)\n     {\n       fprintf (dump_file, \"  not inlinable: %s/%i -> %s/%i, %s\\n\",\n-\t       xstrdup (e->caller->name ()), e->caller->order,\n-\t       xstrdup (e->callee->name ()), e->callee->order,\n+\t       xstrdup_for_dump (e->caller->name ()), e->caller->order,\n+\t       xstrdup_for_dump (e->callee->name ()), e->callee->order,\n \t       cgraph_inline_failed_string (e->inline_failed));\n     }\n }\n@@ -480,9 +480,9 @@ want_early_inline_function_p (struct cgraph_edge *e)\n \t  if (dump_file)\n \t    fprintf (dump_file, \"  will not early inline: %s/%i->%s/%i, \"\n \t\t     \"call is cold and code would grow by %i\\n\",\n-\t\t     xstrdup (e->caller->name ()),\n+\t\t     xstrdup_for_dump (e->caller->name ()),\n \t\t     e->caller->order,\n-\t\t     xstrdup (callee->name ()), callee->order,\n+\t\t     xstrdup_for_dump (callee->name ()), callee->order,\n \t\t     growth);\n \t  want_inline = false;\n \t}\n@@ -491,9 +491,9 @@ want_early_inline_function_p (struct cgraph_edge *e)\n \t  if (dump_file)\n \t    fprintf (dump_file, \"  will not early inline: %s/%i->%s/%i, \"\n \t\t     \"growth %i exceeds --param early-inlining-insns\\n\",\n-\t\t     xstrdup (e->caller->name ()),\n+\t\t     xstrdup_for_dump (e->caller->name ()),\n \t\t     e->caller->order,\n-\t\t     xstrdup (callee->name ()), callee->order,\n+\t\t     xstrdup_for_dump (callee->name ()), callee->order,\n \t\t     growth);\n \t  want_inline = false;\n \t}\n@@ -504,9 +504,9 @@ want_early_inline_function_p (struct cgraph_edge *e)\n \t    fprintf (dump_file, \"  will not early inline: %s/%i->%s/%i, \"\n \t\t     \"growth %i exceeds --param early-inlining-insns \"\n \t\t     \"divided by number of calls\\n\",\n-\t\t     xstrdup (e->caller->name ()),\n+\t\t     xstrdup_for_dump (e->caller->name ()),\n \t\t     e->caller->order,\n-\t\t     xstrdup (callee->name ()), callee->order,\n+\t\t     xstrdup_for_dump (callee->name ()), callee->order,\n \t\t     growth);\n \t  want_inline = false;\n \t}\n@@ -925,9 +925,9 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n   if (dump)\n     {\n       fprintf (dump_file, \"    Badness calculation for %s/%i -> %s/%i\\n\",\n-\t       xstrdup (edge->caller->name ()),\n+\t       xstrdup_for_dump (edge->caller->name ()),\n \t       edge->caller->order,\n-\t       xstrdup (callee->name ()),\n+\t       xstrdup_for_dump (callee->name ()),\n \t       edge->callee->order);\n       fprintf (dump_file, \"      size growth %i, time %i \",\n \t       growth,\n@@ -1094,9 +1094,9 @@ update_edge_key (edge_heap_t *heap, struct cgraph_edge *edge)\n \t      fprintf (dump_file,\n \t\t       \"  decreasing badness %s/%i -> %s/%i, %\"PRId64\n \t\t       \" to %\"PRId64\"\\n\",\n-\t\t       xstrdup (edge->caller->name ()),\n+\t\t       xstrdup_for_dump (edge->caller->name ()),\n \t\t       edge->caller->order,\n-\t\t       xstrdup (edge->callee->name ()),\n+\t\t       xstrdup_for_dump (edge->callee->name ()),\n \t\t       edge->callee->order,\n \t\t       n->get_key ().to_int (),\n \t\t       badness.to_int ());\n@@ -1111,9 +1111,9 @@ update_edge_key (edge_heap_t *heap, struct cgraph_edge *edge)\n \t {\n \t   fprintf (dump_file,\n \t\t    \"  enqueuing call %s/%i -> %s/%i, badness %\"PRId64\"\\n\",\n-\t\t    xstrdup (edge->caller->name ()),\n+\t\t    xstrdup_for_dump (edge->caller->name ()),\n \t\t    edge->caller->order,\n-\t\t    xstrdup (edge->callee->name ()),\n+\t\t    xstrdup_for_dump (edge->callee->name ()),\n \t\t    edge->callee->order,\n \t\t    badness.to_int ());\n \t }\n@@ -1892,8 +1892,8 @@ flatten_function (struct cgraph_node *node, bool early)\n \t  if (dump_file)\n \t    fprintf (dump_file,\n \t\t     \"Not inlining %s into %s to avoid cycle.\\n\",\n-\t\t     xstrdup (callee->name ()),\n-\t\t     xstrdup (e->caller->name ()));\n+\t\t     xstrdup_for_dump (callee->name ()),\n+\t\t     xstrdup_for_dump (e->caller->name ()));\n \t  e->inline_failed = CIF_RECURSIVE_INLINING;\n \t  continue;\n \t}\n@@ -1933,8 +1933,8 @@ flatten_function (struct cgraph_node *node, bool early)\n          recursing through the original node if the node was cloned.  */\n       if (dump_file)\n \tfprintf (dump_file, \" Inlining %s into %s.\\n\",\n-\t\t xstrdup (callee->name ()),\n-\t\t xstrdup (e->caller->name ()));\n+\t\t xstrdup_for_dump (callee->name ()),\n+\t\t xstrdup_for_dump (e->caller->name ()));\n       orig_callee = callee;\n       inline_call (e, true, NULL, NULL, false);\n       if (e->callee != orig_callee)\n@@ -2311,8 +2311,8 @@ inline_always_inline_functions (struct cgraph_node *node)\n \n       if (dump_file)\n \tfprintf (dump_file, \"  Inlining %s into %s (always_inline).\\n\",\n-\t\t xstrdup (e->callee->name ()),\n-\t\t xstrdup (e->caller->name ()));\n+\t\t xstrdup_for_dump (e->callee->name ()),\n+\t\t xstrdup_for_dump (e->caller->name ()));\n       inline_call (e, true, NULL, NULL, false);\n       inlined = true;\n     }\n@@ -2363,8 +2363,8 @@ early_inline_small_functions (struct cgraph_node *node)\n \n       if (dump_file)\n \tfprintf (dump_file, \" Inlining %s into %s.\\n\",\n-\t\t xstrdup (callee->name ()),\n-\t\t xstrdup (e->caller->name ()));\n+\t\t xstrdup_for_dump (callee->name ()),\n+\t\t xstrdup_for_dump (e->caller->name ()));\n       inline_call (e, true, NULL, NULL, true);\n       inlined = true;\n     }"}, {"sha": "f540bd6558b6b58dcb2d5b50def14de4e5e87de4", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a", "patch": "@@ -607,8 +607,8 @@ ipa_profile (void)\n \t\t    {\n \t\t      fprintf (dump_file, \"Indirect call -> direct call from\"\n \t\t\t       \" other module %s/%i => %s/%i, prob %3.2f\\n\",\n-\t\t\t       xstrdup (n->name ()), n->order,\n-\t\t\t       xstrdup (n2->name ()), n2->order,\n+\t\t\t       xstrdup_for_dump (n->name ()), n->order,\n+\t\t\t       xstrdup_for_dump (n2->name ()), n2->order,\n \t\t\t       e->indirect_info->common_target_probability\n \t\t\t       / (float)REG_BR_PROB_BASE);\n \t\t    }"}, {"sha": "50adefbcde51d708cf58f34d08d0712df6236e38", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a", "patch": "@@ -401,8 +401,8 @@ ipa_print_node_jump_functions (FILE *f, struct cgraph_node *node)\n \tcontinue;\n \n       fprintf (f, \"    callsite  %s/%i -> %s/%i : \\n\",\n-\t       xstrdup (node->name ()), node->order,\n-\t       xstrdup (cs->callee->name ()),\n+\t       xstrdup_for_dump (node->name ()), node->order,\n+\t       xstrdup_for_dump (cs->callee->name ()),\n \t       cs->callee->order);\n       ipa_print_node_jump_functions_for_edge (f, cs);\n     }\n@@ -2657,9 +2657,9 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n \t  if (dump_file)\n \t    fprintf (dump_file, \"ipa-prop: Discovered call to a known target \"\n \t\t     \"(%s/%i -> %s/%i) but can not refer to it. Giving up.\\n\",\n-\t\t     xstrdup (ie->caller->name ()),\n+\t\t     xstrdup_for_dump (ie->caller->name ()),\n \t\t     ie->caller->order,\n-\t\t     xstrdup (ie->callee->name ()),\n+\t\t     xstrdup_for_dump (ie->callee->name ()),\n \t\t     ie->callee->order);\n \t  return NULL;\n \t}\n@@ -2678,21 +2678,21 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n \t  if (dump_file)\n \t    fprintf (dump_file, \"ipa-prop: Discovered call to a speculative target \"\n \t\t     \"(%s/%i -> %s/%i) but the call is already speculated to %s/%i. Giving up.\\n\",\n-\t\t     xstrdup (ie->caller->name ()),\n+\t\t     xstrdup_for_dump (ie->caller->name ()),\n \t\t     ie->caller->order,\n-\t\t     xstrdup (callee->name ()),\n+\t\t     xstrdup_for_dump (callee->name ()),\n \t\t     callee->order,\n-\t\t     xstrdup (e2->callee->name ()),\n+\t\t     xstrdup_for_dump (e2->callee->name ()),\n \t\t     e2->callee->order);\n \t}\n       else\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"ipa-prop: Discovered call to a speculative target \"\n \t\t     \"(%s/%i -> %s/%i) this agree with previous speculation.\\n\",\n-\t\t     xstrdup (ie->caller->name ()),\n+\t\t     xstrdup_for_dump (ie->caller->name ()),\n \t\t     ie->caller->order,\n-\t\t     xstrdup (callee->name ()),\n+\t\t     xstrdup_for_dump (callee->name ()),\n \t\t     callee->order);\n \t}\n       return NULL;\n@@ -2713,9 +2713,9 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n \t       \"(%s/%i -> %s/%i), for stmt \",\n \t       ie->indirect_info->polymorphic ? \"a virtual\" : \"an indirect\",\n \t       speculative ? \"speculative\" : \"known\",\n-\t       xstrdup (ie->caller->name ()),\n+\t       xstrdup_for_dump (ie->caller->name ()),\n \t       ie->caller->order,\n-\t       xstrdup (callee->name ()),\n+\t       xstrdup_for_dump (callee->name ()),\n \t       callee->order);\n       if (ie->call_stmt)\n \tprint_gimple_stmt (dump_file, ie->call_stmt, 2, TDF_SLIM);\n@@ -2799,8 +2799,8 @@ remove_described_reference (symtab_node *symbol, struct ipa_cst_ref_desc *rdesc)\n   to_del->remove_reference ();\n   if (dump_file)\n     fprintf (dump_file, \"ipa-prop: Removed a reference from %s/%i to %s.\\n\",\n-\t     xstrdup (origin->caller->name ()),\n-\t     origin->caller->order, xstrdup (symbol->name ()));\n+\t     xstrdup_for_dump (origin->caller->name ()),\n+\t     origin->caller->order, xstrdup_for_dump (symbol->name ()));\n   return true;\n }\n \n@@ -3214,9 +3214,9 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \"ipa-prop: Removing cloning-created \"\n \t\t\t     \"reference from %s/%i to %s/%i.\\n\",\n-\t\t\t     xstrdup (new_root->name ()),\n+\t\t\t     xstrdup_for_dump (new_root->name ()),\n \t\t\t     new_root->order,\n-\t\t\t     xstrdup (n->name ()), n->order);\n+\t\t\t     xstrdup_for_dump (n->name ()), n->order);\n \t\t  ref->remove_reference ();\n \t\t}\n \t    }\n@@ -3255,9 +3255,9 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \t\t\t    fprintf (dump_file, \"ipa-prop: Removing \"\n \t\t\t\t     \"cloning-created reference \"\n \t\t\t\t     \"from %s/%i to %s/%i.\\n\",\n-\t\t\t\t     xstrdup (clone->name ()),\n+\t\t\t\t     xstrdup_for_dump (clone->name ()),\n \t\t\t\t     clone->order,\n-\t\t\t\t     xstrdup (n->name ()),\n+\t\t\t\t     xstrdup_for_dump (n->name ()),\n \t\t\t\t     n->order);\n \t\t\t  ref->remove_reference ();\n \t\t\t}"}, {"sha": "c158837ba364e629d7691069aadaa93a0a446281", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=2a72a9538fdd3e7ea5de08cbe233e1eb3dc5d44a", "patch": "@@ -427,8 +427,8 @@ ipa_merge_profiles (struct cgraph_node *dst,\n   if (symtab->dump_file)\n     {\n       fprintf (symtab->dump_file, \"Merging profiles of %s/%i to %s/%i\\n\",\n-\t       xstrdup (src->name ()), src->order,\n-\t       xstrdup (dst->name ()), dst->order);\n+\t       xstrdup_for_dump (src->name ()), src->order,\n+\t       xstrdup_for_dump (dst->name ()), dst->order);\n     }\n   dst->count += src->count;\n "}]}