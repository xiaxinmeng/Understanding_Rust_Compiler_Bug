{"sha": "0036534fa36a1e3f62ddaffb3d6c2fa565511f17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAzNjUzNGZhMzZhMWUzZjYyZGRhZmZiM2Q2YzJmYTU2NTUxMWYxNw==", "commit": {"author": {"name": "Alexander Ivchenko", "email": "alexander.ivchenko@intel.com", "date": "2017-06-08T14:07:21Z"}, "committer": {"name": "Alexander Ivchenko", "email": "aivchenk@gcc.gnu.org", "date": "2017-06-08T14:07:21Z"}, "message": "tree-chkp.c (chkp_get_hard_register_var_fake_base_address): New function.\n\ngcc/ChangeLog:\n\n2017-05-09  Alexander Ivchenko  <aivchenk@gmail.com>\n\n        * tree-chkp.c (chkp_get_hard_register_var_fake_base_address):\n        New function.\n        (chkp_get_hard_register_fake_addr_expr): Ditto.\n        (chkp_build_addr_expr): Add check for hard reg case.\n        (chkp_parse_array_and_component_ref): Ditto.\n        (chkp_find_bounds_1): Ditto.\n        (chkp_process_stmt): Don't generate bounds store for\n        hard reg case.\n\n\ngcc/testsuite/ChangeLog:\n\n2017-05-09  Alexander Ivchenko  <aivchenk@gmail.com>\n\n        * gcc.target/i386/mpx/hard-reg-2-lbv.c: New test.\n        * gcc.target/i386/mpx/hard-reg-2-nov.c: New test.\n        * gcc.target/i386/mpx/hard-reg-2-ubv.c: New test.\n\nFrom-SVN: r249015", "tree": {"sha": "ae9a619499347db624cba5c08b23183acb68eaec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae9a619499347db624cba5c08b23183acb68eaec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0036534fa36a1e3f62ddaffb3d6c2fa565511f17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0036534fa36a1e3f62ddaffb3d6c2fa565511f17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0036534fa36a1e3f62ddaffb3d6c2fa565511f17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0036534fa36a1e3f62ddaffb3d6c2fa565511f17/comments", "author": null, "committer": null, "parents": [{"sha": "b69d9ac6a9f6fae426080c77ce4a395fafb49a5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b69d9ac6a9f6fae426080c77ce4a395fafb49a5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b69d9ac6a9f6fae426080c77ce4a395fafb49a5f"}], "stats": {"total": 145, "additions": 145, "deletions": 0}, "files": [{"sha": "bf4e0952f71f72afe3eef8d69335b50760d5ccc0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0036534fa36a1e3f62ddaffb3d6c2fa565511f17/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0036534fa36a1e3f62ddaffb3d6c2fa565511f17/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0036534fa36a1e3f62ddaffb3d6c2fa565511f17", "patch": "@@ -1,3 +1,14 @@\n+2017-06-08  Alexander Ivchenko  <alexander.ivchenko@intel.com>\n+\n+\t* tree-chkp.c (chkp_get_hard_register_var_fake_base_address):\n+\tNew function.\n+\t(chkp_get_hard_register_fake_addr_expr): Ditto.\n+\t(chkp_build_addr_expr): Add check for hard reg case.\n+\t(chkp_parse_array_and_component_ref): Ditto.\n+\t(chkp_find_bounds_1): Ditto.\n+\t(chkp_process_stmt): Don't generate bounds store for\n+\thard reg case.\n+\n 2017-06-08  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* predict.c (maybe_hot_bb_p): Do not check profile status."}, {"sha": "e077cbb5f5a05468abc71922ab5cb215e2aca07c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0036534fa36a1e3f62ddaffb3d6c2fa565511f17/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0036534fa36a1e3f62ddaffb3d6c2fa565511f17/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0036534fa36a1e3f62ddaffb3d6c2fa565511f17", "patch": "@@ -1,3 +1,9 @@\n+2017-06-08  Alexander Ivchenko  <alexander.ivchenko@intel.com>\n+\n+\t* gcc.target/i386/mpx/hard-reg-2-lbv.c: New test.\n+\t* gcc.target/i386/mpx/hard-reg-2-nov.c: New test.\n+\t* gcc.target/i386/mpx/hard-reg-2-ubv.c: New test.\n+\n 2017-06-08  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* g++.dg/tree-ssa/counts-1.C: New testcase."}, {"sha": "319e1ecd981354ab4ebc4d9ea6c726cc0a9dc6d0", "filename": "gcc/testsuite/gcc.target/i386/mpx/hard-reg-2-lbv.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0036534fa36a1e3f62ddaffb3d6c2fa565511f17/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmpx%2Fhard-reg-2-lbv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0036534fa36a1e3f62ddaffb3d6c2fa565511f17/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmpx%2Fhard-reg-2-lbv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmpx%2Fhard-reg-2-lbv.c?ref=0036534fa36a1e3f62ddaffb3d6c2fa565511f17", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do run } */\n+/* { dg-shouldfail \"bounds violation\" } */\n+/* { dg-options \"-fcheck-pointer-bounds -mmpx\" } */\n+\n+\n+#define SHOULDFAIL\n+\n+#include \"mpx-check.h\"\n+\n+typedef int v16 __attribute__((vector_size(16)));\n+\n+int foo(int i) {\n+  register v16 u asm(\"xmm0\");\n+  return u[i];\n+}\n+\n+int mpx_test (int argc, const char **argv)\n+{\n+  printf (\"%d\\n\", foo (-1));\n+  return 0;\n+}"}, {"sha": "3c6d39aad246ecbeea5da7d06e420e191c0a0b8d", "filename": "gcc/testsuite/gcc.target/i386/mpx/hard-reg-2-nov.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0036534fa36a1e3f62ddaffb3d6c2fa565511f17/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmpx%2Fhard-reg-2-nov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0036534fa36a1e3f62ddaffb3d6c2fa565511f17/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmpx%2Fhard-reg-2-nov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmpx%2Fhard-reg-2-nov.c?ref=0036534fa36a1e3f62ddaffb3d6c2fa565511f17", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fcheck-pointer-bounds -mmpx\" } */\n+\n+#include \"mpx-check.h\"\n+\n+typedef int v16 __attribute__((vector_size(16)));\n+\n+int foo (int i) {\n+  register v16 u asm (\"xmm0\");\n+  return u[i];\n+}\n+\n+int mpx_test (int argc, const char **argv)\n+{\n+  printf (\"%d\\n\", foo (3));\n+  printf (\"%d\\n\", foo (0));\n+  return 0;\n+}"}, {"sha": "7fe76c498e597dd678dc466eb26bf532ea508c06", "filename": "gcc/testsuite/gcc.target/i386/mpx/hard-reg-2-ubv.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0036534fa36a1e3f62ddaffb3d6c2fa565511f17/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmpx%2Fhard-reg-2-ubv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0036534fa36a1e3f62ddaffb3d6c2fa565511f17/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmpx%2Fhard-reg-2-ubv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmpx%2Fhard-reg-2-ubv.c?ref=0036534fa36a1e3f62ddaffb3d6c2fa565511f17", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do run } */\n+/* { dg-shouldfail \"bounds violation\" } */\n+/* { dg-options \"-fcheck-pointer-bounds -mmpx\" } */\n+\n+\n+#define SHOULDFAIL\n+\n+#include \"mpx-check.h\"\n+\n+typedef int v16 __attribute__((vector_size(16)));\n+\n+int foo (int i) {\n+  register v16 u asm (\"xmm0\");\n+  return u[i];\n+}\n+\n+int mpx_test (int argc, const char **argv)\n+{\n+  printf (\"%d\\n\", foo (5));\n+  return 0;\n+}"}, {"sha": "e36ecbfbbe0cdefa28d2a64e2f66bc4963d8e780", "filename": "gcc/tree-chkp.c", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0036534fa36a1e3f62ddaffb3d6c2fa565511f17/gcc%2Ftree-chkp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0036534fa36a1e3f62ddaffb3d6c2fa565511f17/gcc%2Ftree-chkp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chkp.c?ref=0036534fa36a1e3f62ddaffb3d6c2fa565511f17", "patch": "@@ -327,6 +327,8 @@ static void chkp_parse_array_and_component_ref (tree node, tree *ptr,\n \t\t\t\t\t\tbool innermost_bounds);\n static void chkp_parse_bit_field_ref (tree node, location_t loc,\n \t\t\t\t      tree *offset, tree *size);\n+static tree\n+chkp_make_addressed_object_bounds (tree obj, gimple_stmt_iterator *iter);\n \n #define chkp_bndldx_fndecl \\\n   (targetm.builtin_chkp_function (BUILT_IN_CHKP_BNDLDX))\n@@ -679,6 +681,45 @@ chkp_erase_completed_bounds (void)\n   chkp_completed_bounds_set = new hash_set<tree>;\n }\n \n+/* This function is used to provide a base address for\n+   chkp_get_hard_register_fake_addr_expr.  */\n+static tree\n+chkp_get_hard_register_var_fake_base_address ()\n+{\n+  tree base = fold_convert (ptr_type_node, integer_zero_node);\n+  unsigned HOST_WIDE_INT offset = 1 << (TYPE_PRECISION (ptr_type_node) - 1);\n+  return fold_build_pointer_plus_hwi (base, offset);\n+}\n+\n+/* If we check bounds for a hard register variable, we cannot\n+   use its address - it is illegal, so instead of that we use\n+   this fake value.  */\n+static tree\n+chkp_get_hard_register_fake_addr_expr (tree obj)\n+{\n+  tree addr = chkp_get_hard_register_var_fake_base_address ();\n+  tree outer = obj;\n+  while (TREE_CODE (outer) == COMPONENT_REF || TREE_CODE (outer) == ARRAY_REF)\n+    {\n+      if (TREE_CODE (outer) == COMPONENT_REF)\n+\t{\n+\t  addr = fold_build_pointer_plus (addr,\n+\t\t\t\t\t  component_ref_field_offset (outer));\n+\t  outer = TREE_OPERAND (outer, 0);\n+\t}\n+      else if (TREE_CODE (outer) == ARRAY_REF)\n+\t{\n+\t  tree indx = fold_convert(size_type_node, TREE_OPERAND(outer, 1));\n+\t  tree offset = size_binop (MULT_EXPR,\n+\t\t\t\t    array_ref_element_size (outer), indx);\n+\t  addr = fold_build_pointer_plus (addr, offset);\n+\t  outer = TREE_OPERAND (outer, 0);\n+\t}\n+    }\n+\n+  return addr;\n+}\n+\n /* Mark BOUNDS associated with PTR as incomplete.  */\n static void\n chkp_register_incomplete_bounds (tree bounds, tree ptr)\n@@ -1044,6 +1085,12 @@ chkp_add_modification_to_stmt_list (tree lhs,\n static tree\n chkp_build_addr_expr (tree obj)\n {\n+  /* We first check whether it is a \"hard reg case\".  */\n+  tree base = get_base_address (obj);\n+  if (VAR_P (base) && DECL_HARD_REGISTER (base))\n+    return chkp_get_hard_register_fake_addr_expr (obj);\n+\n+  /* If not - return regular ADDR_EXPR.  */\n   return TREE_CODE (obj) == TARGET_MEM_REF\n     ? tree_mem_ref_addr (ptr_type_node, obj)\n     : build_fold_addr_expr (obj);\n@@ -3442,6 +3489,13 @@ chkp_parse_array_and_component_ref (tree node, tree *ptr,\n \t\t  || TREE_CODE (var) == SSA_NAME);\n \n       *ptr = chkp_build_addr_expr (var);\n+\n+      /* For hard register cases chkp_build_addr_expr returns INTEGER_CST\n+\t and later on chkp_find_bounds will fail to find proper bounds.\n+\t In order to avoid that, we find/create bounds right aways using\n+\t the var itself.  */\n+      if (VAR_P (var) && DECL_HARD_REGISTER (var))\n+\t*bounds = chkp_make_addressed_object_bounds (var, iter);\n     }\n \n   /* In this loop we are trying to find a field access\n@@ -3646,6 +3700,11 @@ chkp_find_bounds_1 (tree ptr, tree ptr_src, gimple_stmt_iterator *iter)\n     case ARRAY_REF:\n     case COMPONENT_REF:\n       addr = get_base_address (ptr_src);\n+      if (VAR_P (addr) && DECL_HARD_REGISTER (addr))\n+\t{\n+\t  bounds = chkp_get_zero_bounds ();\n+\t  break;\n+\t}\n       if (DECL_P (addr)\n \t  || TREE_CODE (addr) == MEM_REF\n \t  || TREE_CODE (addr) == TARGET_MEM_REF)\n@@ -3989,6 +4048,7 @@ chkp_process_stmt (gimple_stmt_iterator *iter, tree node,\n   tree addr_last = NULL_TREE; /* address of the last accessed byte */\n   tree ptr = NULL_TREE; /* a pointer used for dereference */\n   tree bounds = NULL_TREE;\n+  bool reg_store = false;\n \n   /* We do not need instrumentation for clobbers.  */\n   if (dirflag == integer_one_node\n@@ -4103,6 +4163,13 @@ chkp_process_stmt (gimple_stmt_iterator *iter, tree node,\n       addr_last = fold_build_pointer_plus_loc (loc, addr_last, access_offs);\n     }\n \n+  if (dirflag == integer_one_node)\n+    {\n+      tree base = get_base_address (node);\n+      if (VAR_P (base) && DECL_HARD_REGISTER (base))\n+\treg_store = true;\n+    }\n+\n   /* Generate bndcl/bndcu checks if memory access is not safe.  */\n   if (!safe)\n     {\n@@ -4117,6 +4184,7 @@ chkp_process_stmt (gimple_stmt_iterator *iter, tree node,\n \n   /* We need to store bounds in case pointer is stored.  */\n   if (dirflag == integer_one_node\n+      && !reg_store\n       && chkp_type_has_pointer (node_type)\n       && flag_chkp_store_bounds)\n     {"}]}