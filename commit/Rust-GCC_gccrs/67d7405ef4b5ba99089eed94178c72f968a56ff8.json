{"sha": "67d7405ef4b5ba99089eed94178c72f968a56ff8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdkNzQwNWVmNGI1YmE5OTA4OWVlZDk0MTc4YzcyZjk2OGE1NmZmOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-12-21T20:21:00Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-12-21T20:21:00Z"}, "message": "re PR target/51552 (bfin generates bad assembly)\n\nPR target/51552\n        * dwarf2cfi.c (dwarf2out_frame_debug): Move any_cfis_emitted code...\n        (scan_trace): ... here.\n\nFrom-SVN: r182604", "tree": {"sha": "cd9614dae70a35c8221c4af1f1a2dc6e12310734", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd9614dae70a35c8221c4af1f1a2dc6e12310734"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67d7405ef4b5ba99089eed94178c72f968a56ff8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67d7405ef4b5ba99089eed94178c72f968a56ff8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67d7405ef4b5ba99089eed94178c72f968a56ff8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67d7405ef4b5ba99089eed94178c72f968a56ff8/comments", "author": null, "committer": null, "parents": [{"sha": "c65b06073ce31831f65fce84a393c106c1ad5a07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c65b06073ce31831f65fce84a393c106c1ad5a07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c65b06073ce31831f65fce84a393c106c1ad5a07"}], "stats": {"total": 35, "additions": 18, "deletions": 17}, "files": [{"sha": "31210c0aa47e7f80d41a17749635c5f21c656c44", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67d7405ef4b5ba99089eed94178c72f968a56ff8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67d7405ef4b5ba99089eed94178c72f968a56ff8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=67d7405ef4b5ba99089eed94178c72f968a56ff8", "patch": "@@ -1,3 +1,9 @@\n+2011-12-21  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/51552\n+\t* dwarf2cfi.c (dwarf2out_frame_debug): Move any_cfis_emitted code...\n+\t(scan_trace): ... here.\n+\n 2011-12-21  Jason Merrill  <jason@redhat.com>\n \n \t* doc/standards.texi (C++ language): Update for C++11."}, {"sha": "b2721e88ef41ac29c4c46d3a97b80f4d233d5043", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67d7405ef4b5ba99089eed94178c72f968a56ff8/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67d7405ef4b5ba99089eed94178c72f968a56ff8/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=67d7405ef4b5ba99089eed94178c72f968a56ff8", "patch": "@@ -1930,9 +1930,6 @@ dwarf2out_frame_debug (rtx insn)\n {\n   rtx note, n;\n   bool handled_one = false;\n-  bool need_flush = false;\n-\n-  any_cfis_emitted = false;\n \n   for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n     switch (REG_NOTE_KIND (note))\n@@ -2020,22 +2017,15 @@ dwarf2out_frame_debug (rtx insn)\n \tbreak;\n \n       case REG_CFA_FLUSH_QUEUE:\n-\t/* The actual flush happens below.  */\n-\tneed_flush = true;\n+\t/* The actual flush happens elsewhere.  */\n \thandled_one = true;\n \tbreak;\n \n       default:\n \tbreak;\n       }\n \n-  if (handled_one)\n-    {\n-      /* Minimize the number of advances by emitting the entire queue\n-\t once anything is emitted.  */\n-      need_flush |= any_cfis_emitted;\n-    }\n-  else\n+  if (!handled_one)\n     {\n       insn = PATTERN (insn);\n     do_frame_expr:\n@@ -2044,12 +2034,9 @@ dwarf2out_frame_debug (rtx insn)\n       /* Check again.  A parallel can save and update the same register.\n          We could probably check just once, here, but this is safer than\n          removing the check at the start of the function.  */\n-      if (any_cfis_emitted || clobbers_queued_reg_save (insn))\n-\tneed_flush = true;\n+      if (clobbers_queued_reg_save (insn))\n+\tdwarf2out_flush_queued_reg_saves ();\n     }\n-\n-  if (need_flush)\n-    dwarf2out_flush_queued_reg_saves ();\n }\n \n /* Emit CFI info to change the state from OLD_ROW to NEW_ROW.  */\n@@ -2489,6 +2476,7 @@ scan_trace (dw_trace_info *trace)\n \n \t  /* Make sure any register saves are visible at the jump target.  */\n \t  dwarf2out_flush_queued_reg_saves ();\n+\t  any_cfis_emitted = false;\n \n           /* However, if there is some adjustment on the call itself, e.g.\n \t     a call_pop, that action should be considered to happen after\n@@ -2508,6 +2496,7 @@ scan_trace (dw_trace_info *trace)\n \t\t   || clobbers_queued_reg_save (insn)\n \t\t   || find_reg_note (insn, REG_CFA_FLUSH_QUEUE, NULL))\n \t    dwarf2out_flush_queued_reg_saves ();\n+\t  any_cfis_emitted = false;\n \n \t  add_cfi_insn = insn;\n \t  scan_insn_after (insn);\n@@ -2518,6 +2507,12 @@ scan_trace (dw_trace_info *trace)\n \t emitted two cfa adjustments.  Do it now.  */\n       def_cfa_1 (&this_cfa);\n \n+      /* Minimize the number of advances by emitting the entire queue\n+\t once anything is emitted.  */\n+      if (any_cfis_emitted\n+\t  || find_reg_note (insn, REG_CFA_FLUSH_QUEUE, NULL))\n+\tdwarf2out_flush_queued_reg_saves ();\n+\n       /* Note that a test for control_flow_insn_p does exactly the\n \t same tests as are done to actually create the edges.  So\n \t always call the routine and let it not create edges for"}]}