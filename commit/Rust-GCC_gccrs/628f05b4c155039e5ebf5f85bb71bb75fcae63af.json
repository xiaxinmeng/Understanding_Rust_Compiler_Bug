{"sha": "628f05b4c155039e5ebf5f85bb71bb75fcae63af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI4ZjA1YjRjMTU1MDM5ZTVlYmY1Zjg1YmI3MWJiNzVmY2FlNjNhZg==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "2000-06-29T00:36:10Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2000-06-29T00:36:10Z"}, "message": "* flow.c (flow_depth_first_order_compute): Fix algorithm.\n\nFrom-SVN: r34774", "tree": {"sha": "6b757a49c1d46fd46454044a43e206bd043033c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b757a49c1d46fd46454044a43e206bd043033c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/628f05b4c155039e5ebf5f85bb71bb75fcae63af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/628f05b4c155039e5ebf5f85bb71bb75fcae63af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/628f05b4c155039e5ebf5f85bb71bb75fcae63af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/628f05b4c155039e5ebf5f85bb71bb75fcae63af/comments", "author": null, "committer": null, "parents": [{"sha": "5e4adfbabc05f6e37ed5ae233b0a43f144fef4f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e4adfbabc05f6e37ed5ae233b0a43f144fef4f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e4adfbabc05f6e37ed5ae233b0a43f144fef4f6"}], "stats": {"total": 86, "additions": 48, "deletions": 38}, "files": [{"sha": "22c802602f0f5b4d6d079d755f3ab2af8a42fae7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f05b4c155039e5ebf5f85bb71bb75fcae63af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f05b4c155039e5ebf5f85bb71bb75fcae63af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=628f05b4c155039e5ebf5f85bb71bb75fcae63af", "patch": "@@ -1,3 +1,7 @@\n+2000-06-29  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* flow.c (flow_depth_first_order_compute): Fix algorithm.\n+\n 2000-06-28  Philipp Thomas  <pthomas@suse.de>\n \n \t* c-decl.c : Mark strings for translation."}, {"sha": "8135e020ec313517c8725e659fe55a67704e0f53", "filename": "gcc/flow.c", "status": "modified", "additions": 44, "deletions": 38, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628f05b4c155039e5ebf5f85bb71bb75fcae63af/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628f05b4c155039e5ebf5f85bb71bb75fcae63af/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=628f05b4c155039e5ebf5f85bb71bb75fcae63af", "patch": "@@ -7253,19 +7253,19 @@ flow_loop_nodes_find (header, latch, nodes)\n \n /* Compute the depth first search order and store in the array\n    DFS_ORDER, marking the nodes visited in VISITED.  Returns the\n-   number of nodes visited.  */\n+   number of nodes visited.  A depth first search tries to get as far\n+   away from the starting point as quickly as possible.  */\n static int\n flow_depth_first_order_compute (dfs_order)\n      int *dfs_order;\n {\n-  edge e;\n   edge *stack;\n   int sp;\n   int dfsnum = 0;\n   sbitmap visited;\n \n   /* Allocate stack for back-tracking up CFG.  */\n-  stack = (edge *) xmalloc (n_basic_blocks * sizeof (edge));\n+  stack = (edge *) xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n   sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n@@ -7274,49 +7274,55 @@ flow_depth_first_order_compute (dfs_order)\n   /* None of the nodes in the CFG have been visited yet.  */\n   sbitmap_zero (visited);\n   \n-  /* Start with the first successor edge from the entry block.  */\n-  e = ENTRY_BLOCK_PTR->succ;\n-  while (e)\n+  /* Push the first edge on to the stack.  */\n+  stack[sp++] = ENTRY_BLOCK_PTR->succ;\n+\n+  while (sp)\n     {\n-      basic_block src = e->src;\n-      basic_block dest = e->dest;\n+      edge e;\n+      basic_block src;\n+      basic_block dest;\n+\n+      /* Look at the edge on the top of the stack.  */\n+      e = stack[sp - 1];\n+      src = e->src;\n+      dest = e->dest;\n       \n-      /* Mark that we have visited this node.  */\n-      if (src != ENTRY_BLOCK_PTR)\n-\tSET_BIT (visited, src->index);\n-\n-      /* If this node has not been visited before, push the current\n-\t edge on to the stack and proceed with the first successor\n-\t edge of this node.  */\n-      if (dest != EXIT_BLOCK_PTR && ! TEST_BIT (visited, dest->index)\n-\t  && dest->succ)\n+      /* Check if the edge destination has been visited yet.  */\n+      if (dest != EXIT_BLOCK_PTR && ! TEST_BIT (visited, dest->index))\n \t{\n-\t  stack[sp++] = e;\n-\t  e = dest->succ;\n+\t  /* Mark that we have visited the destination.  */\n+\t  SET_BIT (visited, dest->index);\n+\n+ \t  if (dest->succ)\n+ \t    {\n+ \t      /* Since the DEST node has been visited for the first\n+ \t\t time, check its successors.  */\n+ \t      stack[sp++] = dest->succ;\n+ \t    }\n+ \t  else\n+ \t    {\n+ \t      /* There are no successors for the DEST node so assign\n+ \t\t its DFS number.  */\n+ \t      dfs_order[n_basic_blocks - ++dfsnum] = dest->index;\n+ \t    }\n \t}\n       else\n \t{\n-\t  if (dest != EXIT_BLOCK_PTR && ! TEST_BIT (visited, dest->index)\n-\t      && ! dest->succ)\n-\t    {\n-\t      /* DEST has no successors (for example, a non-returning\n-                 function is called) so do not push the current edge\n-                 but carry on with its next successor.  */\n-\t      dfs_order[dest->index] = n_basic_blocks - ++dfsnum;\n-\t      SET_BIT (visited, dest->index);\n-\t    }\n-\n-\t  while (! e->succ_next && src != ENTRY_BLOCK_PTR)\n-\t    {\n-\t      dfs_order[src->index] = n_basic_blocks - ++dfsnum;\n-\n-\t      /* Pop edge off stack.  */\n-\t      e = stack[--sp];\n-\t      src = e->src;\n-\t    }\n-\t  e = e->succ_next;\n+\t  if (! e->succ_next && src != ENTRY_BLOCK_PTR)\n+  \t    {\n+ \t      /* There are no more successors for the SRC node\n+ \t\t so assign its DFS number.  */\n+ \t      dfs_order[n_basic_blocks - ++dfsnum] = src->index;\n+  \t    }\n+\t  \n+\t  if (e->succ_next)\n+\t    stack[sp - 1] = e->succ_next;\n+\t  else\n+\t    sp--;\n \t}\n     }\n+\n   free (stack);\n   sbitmap_free (visited);\n "}]}