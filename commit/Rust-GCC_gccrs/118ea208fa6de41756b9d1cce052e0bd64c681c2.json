{"sha": "118ea208fa6de41756b9d1cce052e0bd64c681c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE4ZWEyMDhmYTZkZTQxNzU2YjlkMWNjZTA1MmUwYmQ2NGM2ODFjMg==", "commit": {"author": {"name": "Steve Ellcey", "email": "sje@cup.hp.com", "date": "2005-09-27T21:12:52Z"}, "committer": {"name": "Steve Ellcey", "email": "sje@gcc.gnu.org", "date": "2005-09-27T21:12:52Z"}, "message": "re PR target/23552 (FAIL: gfortran.dg/large_real_kind_1.f90)\n\n\tPR target/23552\n\t* acinclude.m4 (LIBGFOR_CHECK_FOR_BROKEN_ISFINITE): New.\n\t(LIBGFOR_CHECK_FOR_BROKEN_ISNAN): New.\n\t(LIBGFOR_CHECK_FOR_BROKEN_FPCLASSIFY): New.\n\t* configure.ac (LIBGFOR_CHECK_FOR_BROKEN_ISFINITE): Add use.\n\t(LIBGFOR_CHECK_FOR_BROKEN_ISNAN): Add use.\n\t(LIBGFOR_CHECK_FOR_BROKEN_FPCLASSIFY): Add use.\n\t* configure: Regenerate.\n\t* config.h.in: Regenerate.\n\t* libgfortan.h (isfinite): undef if broken, set if needed.\n\t(isnan): undef if broken, set if needed.\n        (fpclassify): undef if broken, set if needed.\n\t* io/write.c: Remove TODO comment about working isfinite.\n\t* intrinsics/c99_functions.c (round): Use isfinite instead\n\tof fpclassify.\n\t* intrinsics/c99_functions.c (roundf): Ditto.\n\nFrom-SVN: r104710", "tree": {"sha": "b153488273b3833bfdf44f1f0c3ac72e033b31c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b153488273b3833bfdf44f1f0c3ac72e033b31c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/118ea208fa6de41756b9d1cce052e0bd64c681c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/118ea208fa6de41756b9d1cce052e0bd64c681c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/118ea208fa6de41756b9d1cce052e0bd64c681c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/118ea208fa6de41756b9d1cce052e0bd64c681c2/comments", "author": null, "committer": null, "parents": [{"sha": "ca7a5aec06cbaa6683aedc8ebb6273e5d0e64fc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca7a5aec06cbaa6683aedc8ebb6273e5d0e64fc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca7a5aec06cbaa6683aedc8ebb6273e5d0e64fc6"}], "stats": {"total": 447, "additions": 428, "deletions": 19}, "files": [{"sha": "3f75f61715146505dfe16e80fe0920207b540831", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118ea208fa6de41756b9d1cce052e0bd64c681c2/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118ea208fa6de41756b9d1cce052e0bd64c681c2/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=118ea208fa6de41756b9d1cce052e0bd64c681c2", "patch": "@@ -1,3 +1,22 @@\n+2005-09-27  Steve Ellcey  <sje@cup.hp.com>\n+\n+\tPR target/23552\n+\t* acinclude.m4 (LIBGFOR_CHECK_FOR_BROKEN_ISFINITE): New.\n+\t(LIBGFOR_CHECK_FOR_BROKEN_ISNAN): New.\n+\t(LIBGFOR_CHECK_FOR_BROKEN_FPCLASSIFY): New.\n+\t* configure.ac (LIBGFOR_CHECK_FOR_BROKEN_ISFINITE): Add use.\n+\t(LIBGFOR_CHECK_FOR_BROKEN_ISNAN): Add use.\n+\t(LIBGFOR_CHECK_FOR_BROKEN_FPCLASSIFY): Add use.\n+\t* configure: Regenerate.\n+\t* config.h.in: Regenerate.\n+\t* libgfortan.h (isfinite): undef if broken, set if needed.\n+\t(isnan): undef if broken, set if needed.\n+        (fpclassify): undef if broken, set if needed.\n+\t* io/write.c: Remove TODO comment about working isfinite.\n+\t* intrinsics/c99_functions.c (round): Use isfinite instead\n+\tof fpclassify.\n+\t* intrinsics/c99_functions.c (roundf): Ditto.\n+\n 2005-09-24  Janne Blomqvist <jblomqvi@cc.hut.fi>\n \n \t* io.h: Changed prototypes of list_formatted_{read|write}."}, {"sha": "dbf25f3c6362b3436629272d34ba1eaf3a98f2c4", "filename": "libgfortran/acinclude.m4", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118ea208fa6de41756b9d1cce052e0bd64c681c2/libgfortran%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118ea208fa6de41756b9d1cce052e0bd64c681c2/libgfortran%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Facinclude.m4?ref=118ea208fa6de41756b9d1cce052e0bd64c681c2", "patch": "@@ -230,3 +230,122 @@ esac])])\n if test x\"$have_crlf\" = xyes; then\n   AC_DEFINE(HAVE_CRLF, 1, [Define if CRLF is line terminator.])\n fi])\n+\n+dnl Check whether isfinite is broken.\n+dnl The most common problem is that it does not work on long doubles.\n+AC_DEFUN([LIBGFOR_CHECK_FOR_BROKEN_ISFINITE], [\n+  AC_CACHE_CHECK([whether isfinite is broken],\n+                  have_broken_isfinite, [\n+  libgfor_check_for_broken_isfinite_save_LIBS=$LIBS\n+  LIBS=\"$LIBS -lm\"\n+  AC_TRY_RUN([\n+#ifdef HAVE_MATH_H\n+#include <math.h>\n+#endif\n+#include <float.h>\n+int main ()\n+{\n+#ifdef isfinite\n+#ifdef LDBL_MAX\n+  if (!isfinite(LDBL_MAX)) return 1;\n+#endif\n+#ifdef DBL_MAX\n+  if (!isfinite(DBL_MAX)) return 1;\n+#endif\n+#endif\n+return 0;\n+}], have_broken_isfinite=no, have_broken_isfinite=yes, [\n+case \"${target}\" in\n+  hppa*-*-hpux*) have_broken_isfinite=yes ;;\n+  *) have_broken_isfinite=no ;;\n+esac])]\n+  LIBS=$libgfor_check_for_broken_isfinite_save_LIBS)\n+if test x\"$have_broken_isfinite\" = xyes; then\n+  AC_DEFINE(HAVE_BROKEN_ISFINITE, 1, [Define if isfinite is broken.])\n+fi])\n+\n+dnl Check whether isnan is broken.\n+dnl The most common problem is that it does not work on long doubles.\n+AC_DEFUN([LIBGFOR_CHECK_FOR_BROKEN_ISNAN], [\n+  AC_CACHE_CHECK([whether isnan is broken],\n+                  have_broken_isnan, [\n+  libgfor_check_for_broken_isnan_save_LIBS=$LIBS\n+  LIBS=\"$LIBS -lm\"\n+  AC_TRY_RUN([\n+#ifdef HAVE_MATH_H\n+#include <math.h>\n+#endif\n+#include <float.h>\n+int main ()\n+{\n+#ifdef isnan\n+#ifdef LDBL_MAX\n+  {\n+    long double x;\n+    x = __builtin_nanl (\"\");\n+    if (!isnan(x)) return 1;\n+    if (isnan(LDBL_MAX)) return 1;\n+#ifdef NAN\n+    x = (long double) NAN;\n+    if (!isnan(x)) return 1;\n+#endif\n+  }\n+#endif\n+#ifdef DBL_MAX\n+  {\n+    double y;\n+    y = __builtin_nan (\"\");\n+    if (!isnan(y)) return 1;\n+    if (isnan(DBL_MAX)) return 1;\n+#ifdef NAN\n+    y = (double) NAN;\n+    if (!isnan(y)) return 1;\n+#endif\n+  }\n+#endif\n+#endif\n+return 0;\n+}], have_broken_isnan=no, have_broken_isnan=yes, [\n+case \"${target}\" in\n+  hppa*-*-hpux*) have_broken_isnan=yes ;;\n+  *) have_broken_isnan=no ;;\n+esac])]\n+  LIBS=$libgfor_check_for_broken_isnan_save_LIBS)\n+if test x\"$have_broken_isnan\" = xyes; then\n+  AC_DEFINE(HAVE_BROKEN_ISNAN, 1, [Define if isnan is broken.])\n+fi])\n+\n+dnl Check whether fpclassify is broken.\n+dnl The most common problem is that it does not work on long doubles.\n+AC_DEFUN([LIBGFOR_CHECK_FOR_BROKEN_FPCLASSIFY], [\n+  AC_CACHE_CHECK([whether fpclassify is broken],\n+                  have_broken_fpclassify, [\n+  libgfor_check_for_broken_fpclassify_save_LIBS=$LIBS\n+  LIBS=\"$LIBS -lm\"\n+  AC_TRY_RUN([\n+#ifdef HAVE_MATH_H\n+#include <math.h>\n+#endif\n+#include <float.h>\n+int main ()\n+{\n+#ifdef fpclassify\n+#ifdef LDBL_MAX\n+        if (fpclassify(LDBL_MAX) == FP_NAN\n+            || fpclassify(LDBL_MAX) == FP_INFINITE) return 1;\n+#endif\n+#ifdef DBL_MAX\n+        if (fpclassify(DBL_MAX) == FP_NAN\n+            || fpclassify(DBL_MAX) == FP_INFINITE) return 1;\n+#endif\n+#endif\n+return 0;\n+}], have_broken_fpclassify=no, have_broken_fpclassify=yes, [\n+case \"${target}\" in\n+  hppa*-*-hpux*) have_broken_fpclassify=yes ;;\n+  *) have_broken_fpclassify=no ;;\n+esac])]\n+  LIBS=$libgfor_check_for_broken_fpclassify_save_LIBS)\n+if test x\"$have_broken_fpclassify\" = xyes; then\n+  AC_DEFINE(HAVE_BROKEN_FPCLASSIFY, 1, [Define if fpclassify is broken.])\n+fi])"}, {"sha": "44c45c7767bc126b3f10664504c143fd41f30c46", "filename": "libgfortran/config.h.in", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118ea208fa6de41756b9d1cce052e0bd64c681c2/libgfortran%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118ea208fa6de41756b9d1cce052e0bd64c681c2/libgfortran%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig.h.in?ref=118ea208fa6de41756b9d1cce052e0bd64c681c2", "patch": "@@ -75,6 +75,15 @@\n /* Define to 1 if the target supports __attribute__((visibility(...))). */\n #undef HAVE_ATTRIBUTE_VISIBILITY\n \n+/* Define if fpclassify is broken. */\n+#undef HAVE_BROKEN_FPCLASSIFY\n+\n+/* Define if isfinite is broken. */\n+#undef HAVE_BROKEN_ISFINITE\n+\n+/* Define if isnan is broken. */\n+#undef HAVE_BROKEN_ISNAN\n+\n /* libm includes cabs */\n #undef HAVE_CABS\n "}, {"sha": "5b31d51a64772bd6b57bbf116f2979c9fbbb1319", "filename": "libgfortran/configure", "status": "modified", "additions": 246, "deletions": 1, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118ea208fa6de41756b9d1cce052e0bd64c681c2/libgfortran%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118ea208fa6de41756b9d1cce052e0bd64c681c2/libgfortran%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure?ref=118ea208fa6de41756b9d1cce052e0bd64c681c2", "patch": "@@ -19028,7 +19028,7 @@ _ACEOF\n fi\n \n \n-# Hack for AIX\n+# On AIX, clog is present in libm as __clog\n echo \"$as_me:$LINENO: checking for __clog in -lm\" >&5\n echo $ECHO_N \"checking for __clog in -lm... $ECHO_C\" >&6\n if test \"${ac_cv_lib_m___clog+set}\" = set; then\n@@ -19107,6 +19107,251 @@ _ACEOF\n fi\n \n \n+# Check for a isfinite macro that works on long doubles.\n+\n+  echo \"$as_me:$LINENO: checking whether isfinite is broken\" >&5\n+echo $ECHO_N \"checking whether isfinite is broken... $ECHO_C\" >&6\n+if test \"${have_broken_isfinite+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+\n+  libgfor_check_for_broken_isfinite_save_LIBS=$LIBS\n+  LIBS=\"$LIBS -lm\"\n+  if test \"$cross_compiling\" = yes; then\n+\n+case \"${target}\" in\n+  hppa*-*-hpux*) have_broken_isfinite=yes ;;\n+  *) have_broken_isfinite=no ;;\n+esac\n+else\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+#ifdef HAVE_MATH_H\n+#include <math.h>\n+#endif\n+#include <float.h>\n+int main ()\n+{\n+#ifdef isfinite\n+#ifdef LDBL_MAX\n+  if (!isfinite(LDBL_MAX)) return 1;\n+#endif\n+#ifdef DBL_MAX\n+  if (!isfinite(DBL_MAX)) return 1;\n+#endif\n+#endif\n+return 0;\n+}\n+_ACEOF\n+rm -f conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  have_broken_isfinite=no\n+else\n+  echo \"$as_me: program exited with status $ac_status\" >&5\n+echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+( exit $ac_status )\n+have_broken_isfinite=yes\n+fi\n+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext\n+fi\n+  LIBS=$libgfor_check_for_broken_isfinite_save_LIBS\n+fi\n+echo \"$as_me:$LINENO: result: $have_broken_isfinite\" >&5\n+echo \"${ECHO_T}$have_broken_isfinite\" >&6\n+if test x\"$have_broken_isfinite\" = xyes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_BROKEN_ISFINITE 1\n+_ACEOF\n+\n+fi\n+\n+# Check for a isnan macro that works on long doubles.\n+\n+  echo \"$as_me:$LINENO: checking whether isnan is broken\" >&5\n+echo $ECHO_N \"checking whether isnan is broken... $ECHO_C\" >&6\n+if test \"${have_broken_isnan+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+\n+  libgfor_check_for_broken_isnan_save_LIBS=$LIBS\n+  LIBS=\"$LIBS -lm\"\n+  if test \"$cross_compiling\" = yes; then\n+\n+case \"${target}\" in\n+  hppa*-*-hpux*) have_broken_isnan=yes ;;\n+  *) have_broken_isnan=no ;;\n+esac\n+else\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+#ifdef HAVE_MATH_H\n+#include <math.h>\n+#endif\n+#include <float.h>\n+int main ()\n+{\n+#ifdef isnan\n+#ifdef LDBL_MAX\n+  {\n+    long double x;\n+    x = __builtin_nanl (\"\");\n+    if (!isnan(x)) return 1;\n+    if (isnan(LDBL_MAX)) return 1;\n+#ifdef NAN\n+    x = (long double) NAN;\n+    if (!isnan(x)) return 1;\n+#endif\n+  }\n+#endif\n+#ifdef DBL_MAX\n+  {\n+    double y;\n+    y = __builtin_nan (\"\");\n+    if (!isnan(y)) return 1;\n+    if (isnan(DBL_MAX)) return 1;\n+#ifdef NAN\n+    y = (double) NAN;\n+    if (!isnan(y)) return 1;\n+#endif\n+  }\n+#endif\n+#endif\n+return 0;\n+}\n+_ACEOF\n+rm -f conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  have_broken_isnan=no\n+else\n+  echo \"$as_me: program exited with status $ac_status\" >&5\n+echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+( exit $ac_status )\n+have_broken_isnan=yes\n+fi\n+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext\n+fi\n+  LIBS=$libgfor_check_for_broken_isnan_save_LIBS\n+fi\n+echo \"$as_me:$LINENO: result: $have_broken_isnan\" >&5\n+echo \"${ECHO_T}$have_broken_isnan\" >&6\n+if test x\"$have_broken_isnan\" = xyes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_BROKEN_ISNAN 1\n+_ACEOF\n+\n+fi\n+\n+# Check for a fpclassify macro that works on long doubles.\n+\n+  echo \"$as_me:$LINENO: checking whether fpclassify is broken\" >&5\n+echo $ECHO_N \"checking whether fpclassify is broken... $ECHO_C\" >&6\n+if test \"${have_broken_fpclassify+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+\n+  libgfor_check_for_broken_fpclassify_save_LIBS=$LIBS\n+  LIBS=\"$LIBS -lm\"\n+  if test \"$cross_compiling\" = yes; then\n+\n+case \"${target}\" in\n+  hppa*-*-hpux*) have_broken_fpclassify=yes ;;\n+  *) have_broken_fpclassify=no ;;\n+esac\n+else\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+#ifdef HAVE_MATH_H\n+#include <math.h>\n+#endif\n+#include <float.h>\n+int main ()\n+{\n+#ifdef fpclassify\n+#ifdef LDBL_MAX\n+        if (fpclassify(LDBL_MAX) == FP_NAN\n+            || fpclassify(LDBL_MAX) == FP_INFINITE) return 1;\n+#endif\n+#ifdef DBL_MAX\n+        if (fpclassify(DBL_MAX) == FP_NAN\n+            || fpclassify(DBL_MAX) == FP_INFINITE) return 1;\n+#endif\n+#endif\n+return 0;\n+}\n+_ACEOF\n+rm -f conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  have_broken_fpclassify=no\n+else\n+  echo \"$as_me: program exited with status $ac_status\" >&5\n+echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+( exit $ac_status )\n+have_broken_fpclassify=yes\n+fi\n+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext\n+fi\n+  LIBS=$libgfor_check_for_broken_fpclassify_save_LIBS\n+fi\n+echo \"$as_me:$LINENO: result: $have_broken_fpclassify\" >&5\n+echo \"${ECHO_T}$have_broken_fpclassify\" >&6\n+if test x\"$have_broken_fpclassify\" = xyes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_BROKEN_FPCLASSIFY 1\n+_ACEOF\n+\n+fi\n+\n # Fallback in case isfinite is not available.\n echo \"$as_me:$LINENO: checking for finite in -lm\" >&5\n echo $ECHO_N \"checking for finite in -lm... $ECHO_C\" >&6"}, {"sha": "65f6241637442fef0fcd36de291a8f9db60b77d5", "filename": "libgfortran/configure.ac", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118ea208fa6de41756b9d1cce052e0bd64c681c2/libgfortran%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118ea208fa6de41756b9d1cce052e0bd64c681c2/libgfortran%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure.ac?ref=118ea208fa6de41756b9d1cce052e0bd64c681c2", "patch": "@@ -328,6 +328,15 @@ AC_CHECK_LIB([m],[ynl],[AC_DEFINE([HAVE_YNL],[1],[libm includes ynl])])\n # On AIX, clog is present in libm as __clog\n AC_CHECK_LIB([m],[__clog],[AC_DEFINE([HAVE_CLOG],[1],[libm includes clog])])\n \n+# Check for a isfinite macro that works on long doubles.\n+LIBGFOR_CHECK_FOR_BROKEN_ISFINITE\n+\n+# Check for a isnan macro that works on long doubles.\n+LIBGFOR_CHECK_FOR_BROKEN_ISNAN\n+\n+# Check for a fpclassify macro that works on long doubles.\n+LIBGFOR_CHECK_FOR_BROKEN_FPCLASSIFY\n+\n # Fallback in case isfinite is not available.\n AC_CHECK_LIB([m],[finite],[AC_DEFINE([HAVE_FINITE],[1],[libm includes finite])])\n "}, {"sha": "2417e69cbed5ab372a0600b534ec592a0ccd5290", "filename": "libgfortran/intrinsics/c99_functions.c", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118ea208fa6de41756b9d1cce052e0bd64c681c2/libgfortran%2Fintrinsics%2Fc99_functions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118ea208fa6de41756b9d1cce052e0bd64c681c2/libgfortran%2Fintrinsics%2Fc99_functions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fc99_functions.c?ref=118ea208fa6de41756b9d1cce052e0bd64c681c2", "patch": "@@ -344,12 +344,8 @@ double\n round(double x)\n {\n    double t;\n-#if defined(fpclassify)\n-   int i;\n-   i = fpclassify(x);\n-   if (i == FP_INFINITE || i == FP_NAN)\n+   if (!isfinite (x))\n      return (x);\n-#endif\n \n    if (x >= 0.0) \n     {\n@@ -377,13 +373,8 @@ float\n roundf(float x)\n {\n    float t;\n-#if defined(fpclassify)\n-   int i;\n-\n-   i = fpclassify(x);\n-   if (i == FP_INFINITE || i == FP_NAN)\n+   if (!isfinite (x))\n      return (x);\n-#endif\n \n    if (x >= 0.0) \n     {"}, {"sha": "c1bf78eca3e39bd6817a0972da590842d359a9be", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118ea208fa6de41756b9d1cce052e0bd64c681c2/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118ea208fa6de41756b9d1cce052e0bd64c681c2/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=118ea208fa6de41756b9d1cce052e0bd64c681c2", "patch": "@@ -821,9 +821,6 @@ write_float (fnode *f, const char *source, int len)\n \n   if (f->format != FMT_B && f->format != FMT_O && f->format != FMT_Z)\n     {\n-      /* TODO: there are some systems where isfinite is not able to work\n-               with long double variables. We should detect this case and\n-\t       provide our own version for isfinite.  */\n       res = isfinite (n); \n       if (res == 0)\n \t{"}, {"sha": "191d8d4807065801124a20bca0c7e39c9fbbb2c4", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118ea208fa6de41756b9d1cce052e0bd64c681c2/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118ea208fa6de41756b9d1cce052e0bd64c681c2/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=118ea208fa6de41756b9d1cce052e0bd64c681c2", "patch": "@@ -177,13 +177,33 @@ typedef off_t gfc_offset;\n \n    When isfinite is not available, try to use one of the\n    alternatives, or bail out.  */\n-#if (!defined(isfinite) || defined(__CYGWIN__))\n+\n+#if defined(HAVE_BROKEN_ISFINITE) || defined(__CYGWIN__)\n #undef isfinite\n-#if defined(fpclassify)\n+#endif\n+\n+#if defined(HAVE_BROKEN_ISNAN)\n+#undef isnan\n+#endif\n+\n+#if defined(HAVE_BROKEN_FPCLASSIFY)\n+#undef fpclassify\n+#endif\n+\n+#if !defined(isfinite)\n+#if !defined(fpclassify)\n+#define isfinite(x) ((x) - (x) == 0)\n+#else\n #define isfinite(x) (fpclassify(x) != FP_NAN && fpclassify(x) != FP_INFINITE)\n+#endif /* !defined(fpclassify) */\n+#endif /* !defined(isfinite)  */\n+\n+#if !defined(isnan)\n+#if !defined(fpclassify)\n+#define isnan(x) ((x) != (x))\n #else\n-#define isfinite(x) ((x) - (x) == 0)\n-#endif\n+#define isnan(x) (fpclassify(x) == FP_NAN)\n+#endif /* !defined(fpclassify) */\n #endif /* !defined(isfinite)  */\n \n /* TODO: find the C99 version of these an move into above ifdef.  */"}]}