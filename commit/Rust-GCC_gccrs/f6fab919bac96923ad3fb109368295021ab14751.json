{"sha": "f6fab919bac96923ad3fb109368295021ab14751", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZmYWI5MTliYWM5NjkyM2FkM2ZiMTA5MzY4Mjk1MDIxYWIxNDc1MQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-04-16T02:18:52Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-04-16T02:18:52Z"}, "message": "cpplex.c (output_line_command): Remove debugging prints.\n\n\t* cpplex.c (output_line_command): Remove debugging prints.\n\t(cpp_output_tokens): Don't write out a zero-length buffer or\n\ttry to see if it has a newline in it.\n\t(_cpp_expand_to_buffer): Copy the source buffer before pushing.\n\t(_cpp_read_and_prescan): Move shift-down of pushback bytes to\n\tthe end of the loop.  Use memmove.  Don't read past the end of\n\tthe buffer.  Remove trailing newlines from error messages.\n\nFrom-SVN: r33180", "tree": {"sha": "d124b776a65bba44c571b2da18a91a1cd3fb95aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d124b776a65bba44c571b2da18a91a1cd3fb95aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6fab919bac96923ad3fb109368295021ab14751", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6fab919bac96923ad3fb109368295021ab14751", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6fab919bac96923ad3fb109368295021ab14751", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6fab919bac96923ad3fb109368295021ab14751/comments", "author": null, "committer": null, "parents": [{"sha": "d481b69b5e3d1ea42d9b36c652aa3c9ab5c35404", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d481b69b5e3d1ea42d9b36c652aa3c9ab5c35404", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d481b69b5e3d1ea42d9b36c652aa3c9ab5c35404"}], "stats": {"total": 49, "additions": 33, "deletions": 16}, "files": [{"sha": "e98762dbda11817ec21e108977b99142841d24d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6fab919bac96923ad3fb109368295021ab14751/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6fab919bac96923ad3fb109368295021ab14751/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f6fab919bac96923ad3fb109368295021ab14751", "patch": "@@ -1,3 +1,13 @@\n+2000-04-15  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpplex.c (output_line_command): Remove debugging prints.\n+\t(cpp_output_tokens): Don't write out a zero-length buffer or\n+\ttry to see if it has a newline in it.\n+\t(_cpp_expand_to_buffer): Copy the source buffer before pushing.\n+\t(_cpp_read_and_prescan): Move shift-down of pushback bytes to\n+\tthe end of the loop.  Use memmove.  Don't read past the end of\n+\tthe buffer.  Remove trailing newlines from error messages.\n+\n 2004-04-16  Neil Booth  <NeilB@earthling.net>\n \n         * cpphash.h (SYNTAX_INCLUDE, SYNTAX_ASSERT, directive_handler): new."}, {"sha": "f4f7c8def67eb280e160c8cae70b5cf7fa92d545", "filename": "gcc/cpplex.c", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6fab919bac96923ad3fb109368295021ab14751/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6fab919bac96923ad3fb109368295021ab14751/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=f6fab919bac96923ad3fb109368295021ab14751", "patch": "@@ -165,8 +165,6 @@ output_line_command (pfile, print)\n     return;\n   line = CPP_BUF_LINE (ip);\n \n-  //  fprintf (print->outf, \"[%u %u\", print->lineno, line);\n-\n   /* Determine whether the current filename has changed, and if so,\n      how.  'nominal_fname' values are unique, so they can be compared\n      by comparing pointers.  */\n@@ -199,7 +197,6 @@ output_line_command (pfile, print)\n \t  putc ('\\n', print->outf);\n \t  print->lineno++;\n \t}\n-      //      putc(']', print->outf);\n       return;\n     }\n \n@@ -226,10 +223,13 @@ cpp_output_tokens (pfile, print)\n      cpp_reader *pfile;\n      cpp_printer *print;\n {\n-  if (CPP_PWRITTEN (pfile)[-1] == '\\n' && print->lineno)\n-    print->lineno++;\n-  safe_fwrite (pfile, pfile->token_buffer,\n-\t       CPP_WRITTEN (pfile) - print->written, print->outf);\n+  if (CPP_WRITTEN (pfile) - print->written)\n+    {\n+      if (CPP_PWRITTEN (pfile)[-1] == '\\n' && print->lineno)\n+\tprint->lineno++;\n+      safe_fwrite (pfile, pfile->token_buffer,\n+\t\t   CPP_WRITTEN (pfile) - print->written, print->outf);\n+    }\n   output_line_command (pfile, print);\n   CPP_SET_WRITTEN (pfile, print->written);\n }\n@@ -245,15 +245,22 @@ _cpp_expand_to_buffer (pfile, buf, length)\n {\n   cpp_buffer *ip;\n   enum cpp_ttype token;\n+  U_CHAR *buf1;\n \n   if (length < 0)\n     {\n       cpp_ice (pfile, \"length < 0 in cpp_expand_to_buffer\");\n       return;\n     }\n \n+  /* Copy the buffer, because it might be in an unsafe place - for\n+     example, a sequence on the token_buffer, where the pointers will\n+     be invalidated if we enlarge the token_buffer.  */\n+  buf1 = alloca (length);\n+  memcpy (buf1, buf, length);\n+\n   /* Set up the input on the input stack.  */\n-  ip = cpp_push_buffer (pfile, buf, length);\n+  ip = cpp_push_buffer (pfile, buf1, length);\n   if (ip == NULL)\n     return;\n   ip->has_escapes = 1;\n@@ -1631,12 +1638,6 @@ _cpp_read_and_prescan (pfile, fp, desc, len)\n     {\n       U_CHAR *near_buff_end;\n \n-      /* Copy previous char plus unprocessed (at most 2) chars\n-\t to beginning of buffer, refill it with another\n-\t read(), and continue processing */\n-      memcpy(ip - count - 1, ip - 1, 3);\n-      ip -= count;\n-\n       count = read (desc, ibase, pfile->input_buffer_len);\n       if (count < 0)\n \tgoto error;\n@@ -1785,6 +1786,11 @@ _cpp_read_and_prescan (pfile, fp, desc, len)\n \t      break;\n \t    }\n \t}\n+      /* Copy previous char plus unprocessed (at most 2) chars\n+\t to beginning of buffer, refill it with another\n+\t read(), and continue processing */\n+      memmove (ip - count - 1, ip - 1, 4 - (ip - near_buff_end));\n+      ip -= count;\n     }\n \n   if (offset == 0)\n@@ -1795,7 +1801,7 @@ _cpp_read_and_prescan (pfile, fp, desc, len)\n       unsigned long col;\n       line_base = find_position (line_base, op, &line);\n       col = op - line_base + 1;\n-      cpp_warning_with_line (pfile, line, col, \"no newline at end of file\\n\");\n+      cpp_warning_with_line (pfile, line, col, \"no newline at end of file\");\n       if (offset + 1 > len)\n \t{\n \t  len += 1;\n@@ -1811,7 +1817,8 @@ _cpp_read_and_prescan (pfile, fp, desc, len)\n   return op - buf;\n \n  too_big:\n-  cpp_error (pfile, \"file is too large (>%lu bytes)\\n\", (unsigned long)offset);\n+  cpp_notice (pfile, \"%s is too large (>%lu bytes)\", fp->ihash->name,\n+\t      (unsigned long)offset);\n   free (buf);\n   return -1;\n "}]}