{"sha": "19bb30c065848fab2edc67f56990704e42345b2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTliYjMwYzA2NTg0OGZhYjJlZGM2N2Y1Njk5MDcwNGU0MjM0NWIyYg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2016-07-25T10:31:53Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2016-07-25T10:31:53Z"}, "message": "Use std::mt19937, std::thread and std::atomic to simplify tests\n\n\t* testsuite/20_util/shared_ptr/thread/default_weaktoshared.cc: Use\n\tstd::mt19937, std::thread and std::atomic to simplify test.\n\t* testsuite/20_util/shared_ptr/thread/mutex_weaktoshared.cc: Likewise.\n\nFrom-SVN: r238703", "tree": {"sha": "181a5132656bb9ba24bd0a82b0fb029470d23591", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/181a5132656bb9ba24bd0a82b0fb029470d23591"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19bb30c065848fab2edc67f56990704e42345b2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19bb30c065848fab2edc67f56990704e42345b2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19bb30c065848fab2edc67f56990704e42345b2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19bb30c065848fab2edc67f56990704e42345b2b/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9e4348d68fd2a013f8b4c74b10ce8a3e551138d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9e4348d68fd2a013f8b4c74b10ce8a3e551138d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9e4348d68fd2a013f8b4c74b10ce8a3e551138d"}], "stats": {"total": 176, "additions": 56, "deletions": 120}, "files": [{"sha": "0179b15feb26e59c19423a74d14e7ab8c0ce8bf4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19bb30c065848fab2edc67f56990704e42345b2b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19bb30c065848fab2edc67f56990704e42345b2b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=19bb30c065848fab2edc67f56990704e42345b2b", "patch": "@@ -1,3 +1,9 @@\n+2016-07-25  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* testsuite/20_util/shared_ptr/thread/default_weaktoshared.cc: Use\n+\tstd::mt19937, std::thread and std::atomic to simplify test.\n+\t* testsuite/20_util/shared_ptr/thread/mutex_weaktoshared.cc: Likewise.\n+\n 2016-07-22  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/71964"}, {"sha": "a853307b7c5171d7b2db368100e87a5f27a169d1", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/thread/default_weaktoshared.cc", "status": "modified", "additions": 25, "deletions": 60, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19bb30c065848fab2edc67f56990704e42345b2b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fthread%2Fdefault_weaktoshared.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19bb30c065848fab2edc67f56990704e42345b2b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fthread%2Fdefault_weaktoshared.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fthread%2Fdefault_weaktoshared.cc?ref=19bb30c065848fab2edc67f56990704e42345b2b", "patch": "@@ -25,11 +25,11 @@\n #include <memory>\n #include <random>\n #include <vector>\n-#include <testsuite_hooks.h>\n #include <iostream>\n #include <cstdlib>\n-\n-#include <pthread.h>\n+#include <thread>\n+#include <atomic>\n+#include <testsuite_hooks.h>\n \n #ifdef _GLIBCXX_HAVE_UNISTD_H\n #include <unistd.h>\t// To test for _POSIX_THREAD_PRIORITY_SCHEDULING\n@@ -50,19 +50,13 @@ const unsigned long HAMMER_REPEAT = 100000;\n const unsigned long KILL_ONE_IN = 1000;\n \n struct A\n-  {\n-    static _Atomic_word counter;\n-    A()\n-      {\n-\t__gnu_cxx::__atomic_add(&counter, 1);\n-      }\n-    ~A()\n-      {\n-\t__gnu_cxx::__atomic_add(&counter, -1);\n-      }\n-  };\n+{\n+  static std::atomic<int> counter;\n+  A() { counter.fetch_add(1, std::memory_order_relaxed); }\n+ ~A() { counter.fetch_sub(1, std::memory_order_relaxed); }\n+};\n \n-_Atomic_word A::counter = 0;\n+std::atomic<int> A::counter{ 0 };\n \n typedef std::shared_ptr<A> sp_A_t;\n typedef std::weak_ptr<A> wp_A_t;\n@@ -80,16 +74,10 @@ struct shared_and_weak_pools\n     { }\n };\n \n-void* thread_hammer_and_kill(void* opaque_pools)\n+void thread_hammer_and_kill(shared_and_weak_pools& pools)\n {\n-  shared_and_weak_pools& pools = *static_cast<shared_and_weak_pools*>(opaque_pools);\n-  // Using the same parameters as in the RNG test cases.\n-  std::mersenne_twister_engine<\n-    unsigned long, 32, 624, 397, 31,\n-    0x9908b0dful, 11,\n-    0xfffffffful, 7,\n-    0x9d2c5680ul, 15,\n-    0xefc60000ul, 18, 1812433253ul> rng;\n+  std::mt19937 urbg;\n+  std::uniform_int_distribution<> dist(0, KILL_ONE_IN - 1);\n   \n   sp_vector_t::iterator cur_shared = pools.shared_pool.begin();\n   wp_vector_t::iterator cur_weak = pools.weak_pool.begin();\n@@ -107,26 +95,16 @@ void* thread_hammer_and_kill(void* opaque_pools)\n           break;\n       }\n       \n-      if (rng() % KILL_ONE_IN == 0)\n+      if (dist(urbg) == 0)\n       {\n         cur_shared->reset();\n         ++cur_shared;\n       }\n     }\n-  return 0;\n }\n \n-void* thread_hammer(void* opaque_weak)\n+void thread_hammer(wp_vector_t& weak_pool)\n {\n-  wp_vector_t& weak_pool = *static_cast<wp_vector_t*>(opaque_weak);\n-  // Using the same parameters as in the RNG test cases.\n-  std::mersenne_twister_engine<\n-    unsigned long, 32, 624, 397, 31,\n-    0x9908b0dful, 11,\n-    0xfffffffful, 7,\n-    0x9d2c5680ul, 15,\n-    0xefc60000ul, 18, 1812433253ul> rng;\n-\n   wp_vector_t::iterator cur_weak = weak_pool.begin();\n \n   for (unsigned int i = 0; i < HAMMER_REPEAT; ++i)\n@@ -142,51 +120,38 @@ void* thread_hammer(void* opaque_weak)\n           break;\n       }\n     }\n-  return 0;\n }\n \n-int\n+void\n test01()\n {\n   bool test __attribute__((unused)) = true;\n   sp_vector_t obj_pool(POOL_SIZE);\n   \n-  for(sp_vector_t::iterator cur = obj_pool.begin(); cur != obj_pool.end(); ++cur)\n-  {\n-    cur->reset(new A);\n-  }\n+  for(auto& obj : obj_pool)\n+    obj.reset(new A);\n+\n   // Obtain weak references.\n   std::vector<wp_vector_t> weak_pool(HAMMER_MAX_THREADS, wp_vector_t(obj_pool.begin(), obj_pool.end()));\n   \n   // Launch threads with pointer to weak reference.\n-  pthread_t threads[HAMMER_MAX_THREADS];\n+  std::thread threads[HAMMER_MAX_THREADS];\n #if defined(__sun) && defined(__svr4__) && _XOPEN_VERSION >= 500\n   pthread_setconcurrency (HAMMER_MAX_THREADS);\n #endif\n   \n-  pthread_attr_t tattr;\n-  pthread_attr_init(&tattr);\n-\n   shared_and_weak_pools pools(obj_pool, weak_pool[0]);\n-  pthread_create(threads, &tattr, thread_hammer_and_kill, static_cast<void*>(&pools));\n+  threads[0] = std::thread(thread_hammer_and_kill, std::ref(pools));\n   for (unsigned int worker = 1; worker < HAMMER_MAX_THREADS; worker++)\n-    {\n-      if (pthread_create(&threads[worker], &tattr,\n-\t\t\t thread_hammer, static_cast<void*>(&weak_pool[worker])))\n-\tstd::abort();\n-    }\n+    threads[worker] = std::thread(thread_hammer, std::ref(weak_pool[worker]));\n+\n   // Wait for threads to complete, then check integrity of reference.\n-  void* status;\n-  for (unsigned int worker = 0; worker < HAMMER_MAX_THREADS; worker++)\n-    {\n-      if (pthread_join(threads[worker], &status))\n-\tstd::abort();\n-    }\n+  for (auto& thread : threads)\n+    thread.join();\n+\n   obj_pool.clear();\n   \n   VERIFY( A::counter == 0 );\n-  \n-  return 0;\n }\n \n int "}, {"sha": "404fc46d50eb44fe7afd7fb1c94971550c7cf8ea", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/thread/mutex_weaktoshared.cc", "status": "modified", "additions": 25, "deletions": 60, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19bb30c065848fab2edc67f56990704e42345b2b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fthread%2Fmutex_weaktoshared.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19bb30c065848fab2edc67f56990704e42345b2b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fthread%2Fmutex_weaktoshared.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fthread%2Fmutex_weaktoshared.cc?ref=19bb30c065848fab2edc67f56990704e42345b2b", "patch": "@@ -25,11 +25,11 @@\n #include <memory>\n #include <random>\n #include <vector>\n-#include <testsuite_hooks.h>\n #include <iostream>\n #include <cstdlib>\n-\n-#include <pthread.h>\n+#include <thread>\n+#include <atomic>\n+#include <testsuite_hooks.h>\n \n #ifdef _GLIBCXX_HAVE_UNISTD_H\n #include <unistd.h>\t// To test for _POSIX_THREAD_PRIORITY_SCHEDULING\n@@ -50,19 +50,13 @@ const unsigned long HAMMER_REPEAT = 100000;\n const unsigned long KILL_ONE_IN = 1000;\n \n struct A\n-  {\n-    static _Atomic_word counter;\n-    A()\n-      {\n-\t__gnu_cxx::__atomic_add(&counter, 1);\n-      }\n-    ~A()\n-      {\n-\t__gnu_cxx::__atomic_add(&counter, -1);\n-      }\n-  };\n+{\n+  static std::atomic<int> counter;\n+  A() { counter.fetch_add(1, std::memory_order_relaxed); }\n+ ~A() { counter.fetch_sub(1, std::memory_order_relaxed); }\n+};\n \n-_Atomic_word A::counter = 0;\n+std::atomic<int> A::counter{0};\n \n using std::_S_mutex;\n \n@@ -82,16 +76,10 @@ struct shared_and_weak_pools\n     { }\n };\n \n-void* thread_hammer_and_kill(void* opaque_pools)\n+void thread_hammer_and_kill(shared_and_weak_pools& pools)\n {\n-  shared_and_weak_pools& pools = *static_cast<shared_and_weak_pools*>(opaque_pools);\n-  // Using the same parameters as in the RNG test cases.\n-  std::mersenne_twister_engine<\n-    unsigned long, 32, 624, 397, 31,\n-    0x9908b0dful, 11,\n-    0xfffffffful, 7,\n-    0x9d2c5680ul, 15,\n-    0xefc60000ul, 18, 1812433253ul> rng;\n+  std::mt19937 urbg;\n+  std::uniform_int_distribution<> dist(0, KILL_ONE_IN - 1);\n \n   sp_vector_t::iterator cur_shared = pools.shared_pool.begin();\n   wp_vector_t::iterator cur_weak = pools.weak_pool.begin();\n@@ -109,26 +97,16 @@ void* thread_hammer_and_kill(void* opaque_pools)\n           break;\n       }\n       \n-      if (rng() % KILL_ONE_IN == 0)\n+      if (dist(urbg) == 0)\n       {\n         cur_shared->reset();\n         ++cur_shared;\n       }\n     }\n-  return 0;\n }\n \n-void* thread_hammer(void* opaque_weak)\n+void thread_hammer(wp_vector_t& weak_pool)\n {\n-  wp_vector_t& weak_pool = *static_cast<wp_vector_t*>(opaque_weak);\n-  // Using the same parameters as in the RNG test cases.\n-  std::mersenne_twister_engine<\n-    unsigned long, 32, 624, 397, 31,\n-    0x9908b0dful, 11,\n-    0xfffffffful, 7,\n-    0x9d2c5680ul, 15,\n-    0xefc60000ul, 18, 1812433253ul> rng;\n-\n   wp_vector_t::iterator cur_weak = weak_pool.begin();\n \n   for (unsigned int i = 0; i < HAMMER_REPEAT; ++i)\n@@ -144,51 +122,38 @@ void* thread_hammer(void* opaque_weak)\n           break;\n       }\n     }\n-  return 0;\n }\n \n-int\n+void\n test01()\n {\n   bool test __attribute__((unused)) = true;\n   sp_vector_t obj_pool(POOL_SIZE);\n   \n-  for(sp_vector_t::iterator cur = obj_pool.begin(); cur != obj_pool.end(); ++cur)\n-  {\n-    cur->reset(new A);\n-  }\n+  for(auto& obj : obj_pool)\n+    obj.reset(new A);\n+\n   // Obtain weak references.\n   std::vector<wp_vector_t> weak_pool(HAMMER_MAX_THREADS, wp_vector_t(obj_pool.begin(), obj_pool.end()));\n   \n   // Launch threads with pointer to weak reference.\n-  pthread_t threads[HAMMER_MAX_THREADS];\n+  std::thread threads[HAMMER_MAX_THREADS];\n #if defined(__sun) && defined(__svr4__) && _XOPEN_VERSION >= 500\n   pthread_setconcurrency (HAMMER_MAX_THREADS);\n #endif\n   \n-  pthread_attr_t tattr;\n-  pthread_attr_init(&tattr);\n-\n   shared_and_weak_pools pools(obj_pool, weak_pool[0]);\n-  pthread_create(threads, &tattr, thread_hammer_and_kill, static_cast<void*>(&pools));\n+  threads[0] = std::thread(thread_hammer_and_kill, std::ref(pools));\n   for (unsigned int worker = 1; worker < HAMMER_MAX_THREADS; worker++)\n-    {\n-      if (pthread_create(&threads[worker], &tattr,\n-\t\t\t thread_hammer, static_cast<void*>(&weak_pool[worker])))\n-\tstd::abort();\n-    }\n+    threads[worker] = std::thread(thread_hammer, std::ref(weak_pool[worker]));\n+\n   // Wait for threads to complete, then check integrity of reference.\n-  void* status;\n-  for (unsigned int worker = 0; worker < HAMMER_MAX_THREADS; worker++)\n-    {\n-      if (pthread_join(threads[worker], &status))\n-\tstd::abort();\n-    }\n+  for (auto& thread : threads)\n+    thread.join();\n+\n   obj_pool.clear();\n   \n   VERIFY( A::counter == 0 );\n-  \n-  return 0;\n }\n \n int "}]}