{"sha": "70d4736c9af4dd94e932aee07f4e27e675350331", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBkNDczNmM5YWY0ZGQ5NGU5MzJhZWUwN2Y0ZTI3ZTY3NTM1MDMzMQ==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-08-09T23:27:51Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-08-09T23:27:51Z"}, "message": "re PR target/54089 ([SH] Refactor shift patterns)\n\n\tPR target/54089\n\t* config/sh/sh-protos (shift_insns_rtx): Delete.\n\t(sh_ashlsi_clobbers_t_reg_p): Add.\n\t* config/sh/sh.c (shift_insns, shift_amounts, ext_shift_insns,\n\text_shift_amounts): Merge arrays of ints to array of structs.\n\tAdapt usage of arrays throughout the file.\n\t(shift_insns_rtx): Delete unused function.\n\t(sh_ashlsi_clobbers_t_reg_p): New function.\n\t* config/sh/sh.md (ashlsi3): Emit ashlsi3_n_clobbers_t insn if the\n\tfinal shift sequence will clobber T_REG.\n\t(ashlsi3_n): Split only if the final shift sequence will not\n\tclobber T_REG.\n\t(ashlsi3_n_clobbers_t): New insn_and_split.\n\nFrom-SVN: r190273", "tree": {"sha": "a03a6d2ae30fcbeeb358b351b3eb28289129916d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a03a6d2ae30fcbeeb358b351b3eb28289129916d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70d4736c9af4dd94e932aee07f4e27e675350331", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70d4736c9af4dd94e932aee07f4e27e675350331", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70d4736c9af4dd94e932aee07f4e27e675350331", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70d4736c9af4dd94e932aee07f4e27e675350331/comments", "author": null, "committer": null, "parents": [{"sha": "9ab48d6e6ca06afe12664be30bb30043a9572604", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ab48d6e6ca06afe12664be30bb30043a9572604", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ab48d6e6ca06afe12664be30bb30043a9572604"}], "stats": {"total": 287, "additions": 198, "deletions": 89}, "files": [{"sha": "b73c69027fa98c27fb68e26a3de182e96abca291", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70d4736c9af4dd94e932aee07f4e27e675350331/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70d4736c9af4dd94e932aee07f4e27e675350331/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=70d4736c9af4dd94e932aee07f4e27e675350331", "patch": "@@ -1,3 +1,19 @@\n+2012-08-09  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/54089\n+\t* config/sh/sh-protos (shift_insns_rtx): Delete.\n+\t(sh_ashlsi_clobbers_t_reg_p): Add.\n+\t* config/sh/sh.c (shift_insns, shift_amounts, ext_shift_insns,\n+\text_shift_amounts): Merge arrays of ints to array of structs.\n+\tAdapt usage of arrays throughout the file.\n+\t(shift_insns_rtx): Delete unused function.\n+\t(sh_ashlsi_clobbers_t_reg_p): New function.\n+\t* config/sh/sh.md (ashlsi3): Emit ashlsi3_n_clobbers_t insn if the\n+\tfinal shift sequence will clobber T_REG.\n+\t(ashlsi3_n): Split only if the final shift sequence will not\n+\tclobber T_REG.\n+\t(ashlsi3_n_clobbers_t): New insn_and_split.\n+\n 2012-08-09  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* calls.c (mem_overlaps_already_clobbered_arg_p): Use SBITMAP_SIZE"}, {"sha": "db5f975fca7d03b8006f71bf0f7dad6e2adb953f", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70d4736c9af4dd94e932aee07f4e27e675350331/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70d4736c9af4dd94e932aee07f4e27e675350331/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=70d4736c9af4dd94e932aee07f4e27e675350331", "patch": "@@ -73,7 +73,7 @@ extern void sh_emit_scc_to_t (enum rtx_code, rtx, rtx);\n extern rtx sh_emit_cheap_store_flag (enum machine_mode, enum rtx_code, rtx, rtx);\n extern void sh_emit_compare_and_branch (rtx *, enum machine_mode);\n extern void sh_emit_compare_and_set (rtx *, enum machine_mode);\n-extern int shift_insns_rtx (rtx);\n+extern bool sh_ashlsi_clobbers_t_reg_p (rtx);\n extern void gen_shifty_op (int, rtx *);\n extern void gen_shifty_hi_op (int, rtx *);\n extern bool expand_ashiftrt (rtx *);"}, {"sha": "bac849bd991430b86f12cb092709cab38ec4fa89", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 143, "deletions": 86, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70d4736c9af4dd94e932aee07f4e27e675350331/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70d4736c9af4dd94e932aee07f4e27e675350331/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=70d4736c9af4dd94e932aee07f4e27e675350331", "patch": "@@ -2786,72 +2786,117 @@ sh_cannot_copy_insn_p (rtx insn)\n   return false;\n }\n \f\n-/* Actual number of instructions used to make a shift by N.  */\n+/* Number of instructions used to make an arithmetic right shift by N.  */\n static const char ashiftrt_insns[] =\n   { 0,1,2,3,4,5,8,8,8,8,8,8,8,8,8,8,2,3,4,5,8,8,8,8,8,8,8,8,8,8,8,2};\n \n-/* Left shift and logical right shift are the same.  */\n-static const char shift_insns[]    =\n-  { 0,1,1,2,2,3,3,4,1,2,2,3,3,4,3,3,1,2,2,3,3,4,3,3,2,3,3,4,4,4,3,3};\n-\n-/* Individual shift amounts needed to get the above length sequences.\n-   One bit right shifts clobber the T bit, so when possible, put one bit\n-   shifts in the middle of the sequence, so the ends are eligible for\n-   branch delay slots.  */\n-static const short shift_amounts[32][5] = {\n-  {0}, {1}, {2}, {2, 1},\n-  {2, 2}, {2, 1, 2}, {2, 2, 2}, {2, 2, 1, 2},\n-  {8}, {8, 1}, {8, 2}, {8, 1, 2},\n-  {8, 2, 2}, {8, 2, 1, 2}, {8, -2, 8}, {8, -1, 8},\n-  {16}, {16, 1}, {16, 2}, {16, 1, 2},\n-  {16, 2, 2}, {16, 2, 1, 2}, {16, -2, 8}, {16, -1, 8},\n-  {16, 8}, {16, 1, 8}, {16, 8, 2}, {16, 8, 1, 2},\n-  {16, 8, 2, 2}, {16, -1, -2, 16}, {16, -2, 16}, {16, -1, 16}};\n-\n-/* Likewise, but for shift amounts < 16, up to three highmost bits\n-   might be clobbered.  This is typically used when combined with some\n-   kind of sign or zero extension.  */\n+/* Description of a logical left or right shift, when expanded to a sequence\n+   of 1/2/8/16 shifts.\n+   Notice that one bit right shifts clobber the T bit.  One bit left shifts\n+   are done with an 'add Rn,Rm' insn and thus do not clobber the T bit.  */\n+enum\n+{\n+  ASHL_CLOBBERS_T = 1 << 0,\n+  LSHR_CLOBBERS_T = 1 << 1\n+};\n+\n+struct ashl_lshr_sequence\n+{\n+  char insn_count;\n+  char amount[6];\n+  char clobbers_t;\n+};\n+\n+static const struct ashl_lshr_sequence ashl_lshr_seq[32] =\n+{\n+  { 0, { 0 },\t\t    0 },\n+  { 1, { 1 },\t\t    LSHR_CLOBBERS_T },\n+  { 1, { 2 },\t\t    0 },\n+  { 2, { 2, 1 },\t    LSHR_CLOBBERS_T },\n+  { 2, { 2, 2 },\t    0 },\n+  { 3, { 2, 1, 2 },\t    LSHR_CLOBBERS_T },\n+  { 3, { 2, 2, 2 },\t    0 },\n+  { 4, { 2, 2, 1, 2 },\t    LSHR_CLOBBERS_T },\n+  { 1, { 8 },\t\t    0 },\n+  { 2, { 8, 1 },\t    LSHR_CLOBBERS_T },\n+  { 2, { 8, 2 },\t    0 },\n+  { 3, { 8, 1, 2 },\t    LSHR_CLOBBERS_T },\n+  { 3, { 8, 2, 2 },\t    0 },\n+  { 4, { 8, 2, 1, 2 },\t    LSHR_CLOBBERS_T },\n+  { 3, { 8, -2, 8 },\t    0 },\n+  { 3, { 8, -1, 8 },\t    ASHL_CLOBBERS_T },\n+  { 1, { 16 },\t\t    0 },\n+  { 2, { 16, 1 },\t    LSHR_CLOBBERS_T },\n+  { 2, { 16, 2 },\t    0 },\n+  { 3, { 16, 1, 2 },\t    LSHR_CLOBBERS_T },\n+  { 3, { 16, 2, 2 },\t    0 },\n+  { 4, { 16, 2, 1, 2 },\t    LSHR_CLOBBERS_T },\n+  { 3, { 16, -2, 8 },\t    0 },\n+  { 3, { 16, -1, 8 },\t    ASHL_CLOBBERS_T },\n+  { 2, { 16, 8 },\t    0 },\n+  { 3, { 16, 1, 8 },\t    LSHR_CLOBBERS_T },\n+  { 3, { 16, 8, 2 },\t    0 },\n+  { 4, { 16, 8, 1, 2 },     LSHR_CLOBBERS_T },\n+  { 4, { 16, 8, 2, 2 },\t    0 },\n+  { 4, { 16, -1, -2, 16 },  ASHL_CLOBBERS_T },\n+  { 3, { 16, -2, 16 },\t    0 },\n+  { 3, { 16, -1, 16 },\t    ASHL_CLOBBERS_T }\n+};\n \n-static const char ext_shift_insns[]    =\n-  { 0,1,1,2,2,3,2,2,1,2,2,3,3,3,2,2,1,2,2,3,3,4,3,3,2,3,3,4,4,4,3,3};\n+/* Individual shift amounts for shift amounts < 16, up to three highmost\n+   bits might be clobbered.  This is typically used when combined with some\n+   kind of sign or zero extension.  */\n+static const struct ashl_lshr_sequence ext_ashl_lshr_seq[32] =\n+{\n+  { 0, { 0 },\t\t    0 },\n+  { 1, { 1 },\t\t    LSHR_CLOBBERS_T },\n+  { 1, { 2 },\t\t    0 },\n+  { 2, { 2, 1 },\t    LSHR_CLOBBERS_T },\n+  { 2, { 2, 2 },\t    0 },\n+  { 3, { 2, 1, 2 },\t    LSHR_CLOBBERS_T },\n+  { 2, { 8, -2 },\t    0 },\n+  { 2, { 8, -1 },\t    ASHL_CLOBBERS_T },\n+  { 1, { 8 },\t\t    0 },\n+  { 2, { 8, 1 },\t    LSHR_CLOBBERS_T },\n+  { 2, { 8, 2 },\t    0 },\n+  { 3, { 8, 1, 2 },\t    LSHR_CLOBBERS_T },\n+  { 3, { 8, 2, 2 },\t    0 },\n+  { 3, { 16, -2, -1 },\t    ASHL_CLOBBERS_T },\n+  { 2, { 16, -2 },\t    0 },\n+  { 2, { 16, -1 },\t    ASHL_CLOBBERS_T },\n+  { 1, { 16 },\t\t    0 },\n+  { 2, { 16, 1 },\t    LSHR_CLOBBERS_T },\n+  { 2, { 16, 2 },\t    0 },\n+  { 3, { 16, 1, 2 },\t    LSHR_CLOBBERS_T },\n+  { 3, { 16, 2, 2 },\t    0 },\n+  { 4, { 16, 2, 1, 2 },\t    LSHR_CLOBBERS_T },\n+  { 3, { 16, -2, 8 },\t    0 },\n+  { 3, { 16, -1, 8 },\t    ASHL_CLOBBERS_T },\n+  { 2, { 16, 8 },\t    0 },\n+  { 3, { 16, 1, 8 },\t    LSHR_CLOBBERS_T },\n+  { 3, { 16, 8, 2 },\t    0 },\n+  { 4, { 16, 8, 1, 2 },\t    LSHR_CLOBBERS_T },\n+  { 4, { 16, 8, 2, 2 },\t    0 },\n+  { 4, { 16, -1, -2, 16 },  ASHL_CLOBBERS_T },\n+  { 3, { 16, -2, 16 },\t    0 },\n+  { 3, { 16, -1, 16 },\t    ASHL_CLOBBERS_T }\n+};\n \n-static const short ext_shift_amounts[32][4] = {\n-  {0}, {1}, {2}, {2, 1},\n-  {2, 2}, {2, 1, 2}, {8, -2}, {8, -1},\n-  {8}, {8, 1}, {8, 2}, {8, 1, 2},\n-  {8, 2, 2}, {16, -2, -1}, {16, -2}, {16, -1},\n-  {16}, {16, 1}, {16, 2}, {16, 1, 2},\n-  {16, 2, 2}, {16, 2, 1, 2}, {16, -2, 8}, {16, -1, 8},\n-  {16, 8}, {16, 1, 8}, {16, 8, 2}, {16, 8, 1, 2},\n-  {16, 8, 2, 2}, {16, -1, -2, 16}, {16, -2, 16}, {16, -1, 16}};\n+/* Return true if a shift left consisting of 1/2/8/16 shift instructions\n+   will clobber the T bit.  */\n+bool\n+sh_ashlsi_clobbers_t_reg_p (rtx shift_amount)\n+{\n+  gcc_assert (CONST_INT_P (shift_amount));\n+  return (ashl_lshr_seq[INTVAL (shift_amount) & 31].clobbers_t\n+\t  & ASHL_CLOBBERS_T) != 0;\n+}\n \n /* Assuming we have a value that has been sign-extended by at least one bit,\n    can we use the ext_shift_amounts with the last shift turned to an arithmetic shift\n    to shift it by N without data loss, and quicker than by other means?  */\n #define EXT_SHIFT_SIGNED(n) (((n) | 8) == 15)\n \n-/* This is used in length attributes in sh.md to help compute the length\n-   of arbitrary constant shift instructions.  */\n-\n-int\n-shift_insns_rtx (rtx insn)\n-{\n-  rtx set_src = SET_SRC (XVECEXP (PATTERN (insn), 0, 0));\n-  int shift_count = INTVAL (XEXP (set_src, 1)) & 31;\n-  enum rtx_code shift_code = GET_CODE (set_src);\n-\n-  switch (shift_code)\n-    {\n-    case ASHIFTRT:\n-      return ashiftrt_insns[shift_count];\n-    case LSHIFTRT:\n-    case ASHIFT:\n-      return shift_insns[shift_count];\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n /* Return the cost of a shift.  */\n \n static inline int\n@@ -2890,7 +2935,7 @@ shiftcosts (rtx x)\n       return cost;\n     }\n   else\n-    return shift_insns[value];\n+    return ashl_lshr_seq[value].insn_count;\n }\n \n /* Return the cost of an AND/XOR/IOR operation.  */\n@@ -3400,9 +3445,9 @@ gen_shifty_op (int code, rtx *operands)\n       return;\n     }\n \n-  max = shift_insns[value];\n+  max = ashl_lshr_seq[value].insn_count;\n   for (i = 0; i < max; i++)\n-    gen_ashift (code, shift_amounts[value][i], operands[0]);\n+    gen_ashift (code, ashl_lshr_seq[value].amount[i], operands[0]);\n }\n \n /* Same as above, but optimized for values where the topmost bits don't\n@@ -3427,15 +3472,15 @@ gen_shifty_hi_op (int code, rtx *operands)\n   gen_fun = GET_MODE (operands[0]) == HImode ? gen_ashift_hi : gen_ashift;\n   if (code == ASHIFT)\n     {\n-      max = ext_shift_insns[value];\n+      max = ext_ashl_lshr_seq[value].insn_count;\n       for (i = 0; i < max; i++)\n-\tgen_fun (code, ext_shift_amounts[value][i], operands[0]);\n+\tgen_fun (code, ext_ashl_lshr_seq[value].amount[i], operands[0]);\n     }\n   else\n     /* When shifting right, emit the shifts in reverse order, so that\n        solitary negative values come first.  */\n-    for (i = ext_shift_insns[value] - 1; i >= 0; i--)\n-      gen_fun (code, ext_shift_amounts[value][i], operands[0]);\n+    for (i = ext_ashl_lshr_seq[value].insn_count - 1; i >= 0; i--)\n+      gen_fun (code, ext_ashl_lshr_seq[value].amount[i], operands[0]);\n }\n \n /* Output RTL for an arithmetic right shift.  */\n@@ -3526,9 +3571,10 @@ expand_ashiftrt (rtx *operands)\n bool\n sh_dynamicalize_shift_p (rtx count)\n {\n+  int insn_count;\n   gcc_assert (CONST_INT_P (count));\n-  return TARGET_DYNSHIFT\n-\t && (shift_insns[INTVAL (count) & 31] > 1 + SH_DYNAMIC_SHIFT_COST);\n+  insn_count = ashl_lshr_seq[INTVAL (count) & 31].insn_count;\n+  return TARGET_DYNSHIFT && (insn_count > 1 + SH_DYNAMIC_SHIFT_COST);\n }\n \n /* Try to find a good way to implement the combiner pattern\n@@ -3575,12 +3621,14 @@ shl_and_kind (rtx left_rtx, rtx mask_rtx, int *attrp)\n   lsb2 = ((mask2 ^ (mask2 - 1)) >> 1) + 1;\n   /* mask has no zeroes but trailing zeroes <==> ! mask2 */\n   if (! mask2)\n-    best_cost = shift_insns[right] + shift_insns[right + left];\n+    best_cost = ashl_lshr_seq[right].insn_count\n+\t\t+ ashl_lshr_seq[right + left].insn_count;\n   /* mask has no trailing zeroes <==> ! right */\n   else if (! right && mask2 == ~(lsb2 - 1))\n     {\n       int late_right = exact_log2 (lsb2);\n-      best_cost = shift_insns[left + late_right] + shift_insns[late_right];\n+      best_cost = ashl_lshr_seq[left + late_right].insn_count\n+\t\t  + ashl_lshr_seq[late_right].insn_count;\n     }\n   /* Try to use zero extend.  */\n   if (mask2 == ~(lsb2 - 1))\n@@ -3592,8 +3640,8 @@ shl_and_kind (rtx left_rtx, rtx mask_rtx, int *attrp)\n \t  /* Can we zero-extend right away?  */\n \t  if (lsb2 == (unsigned HOST_WIDE_INT) 1 << width)\n \t    {\n-\t      cost\n-\t\t= 1 + ext_shift_insns[right] + ext_shift_insns[left + right];\n+\t      cost = 1 + ext_ashl_lshr_seq[right].insn_count\n+\t\t       + ext_ashl_lshr_seq[left + right].insn_count;\n \t      if (cost < best_cost)\n \t\t{\n \t\t  best = 1;\n@@ -3612,8 +3660,10 @@ shl_and_kind (rtx left_rtx, rtx mask_rtx, int *attrp)\n \t  first = width - exact_log2 (lsb2) + right;\n \t  if (first >= 0 && right + left - first >= 0)\n \t    {\n-\t      cost = ext_shift_insns[right] + ext_shift_insns[first] + 1\n-\t\t+ ext_shift_insns[right + left - first];\n+\t      cost = ext_ashl_lshr_seq[right].insn_count\n+\t\t     + ext_ashl_lshr_seq[first].insn_count + 1\n+\t\t     + ext_ashl_lshr_seq[right + left - first].insn_count;\n+\n \t      if (cost < best_cost)\n \t\t{\n \t\t  best = 1;\n@@ -3633,7 +3683,7 @@ shl_and_kind (rtx left_rtx, rtx mask_rtx, int *attrp)\n \tbreak;\n       if (! CONST_OK_FOR_K08 (mask >> i))\n \tcontinue;\n-      cost = (i != 0) + 2 + ext_shift_insns[left + i];\n+      cost = (i != 0) + 2 + ext_ashl_lshr_seq[left + i].insn_count;\n       if (cost < best_cost)\n \t{\n \t  best = 2;\n@@ -3649,7 +3699,9 @@ shl_and_kind (rtx left_rtx, rtx mask_rtx, int *attrp)\n       if (i > right)\n \tbreak;\n       cost = (i != 0) + (CONST_OK_FOR_I08 (mask >> i) ? 2 : 3)\n-\t+ (can_ext ? ext_shift_insns : shift_insns)[left + i];\n+\t     + (can_ext\n+\t\t? ext_ashl_lshr_seq\n+\t\t: ashl_lshr_seq)[left + i].insn_count;\n       if (cost < best_cost)\n \t{\n \t  best = 4 - can_ext;\n@@ -3688,11 +3740,11 @@ int\n shl_and_scr_length (rtx insn)\n {\n   rtx set_src = SET_SRC (XVECEXP (PATTERN (insn), 0, 0));\n-  int len = shift_insns[INTVAL (XEXP (set_src, 1)) & 31];\n+  int len = ashl_lshr_seq[INTVAL (XEXP (set_src, 1)) & 31].insn_count;\n   rtx op = XEXP (set_src, 0);\n-  len += shift_insns[INTVAL (XEXP (op, 1)) & 31] + 1;\n+  len += ashl_lshr_seq[INTVAL (XEXP (op, 1)) & 31].insn_count + 1;\n   op = XEXP (XEXP (op, 0), 0);\n-  return len + shift_insns[INTVAL (XEXP (op, 1)) & 31];\n+  return len + ashl_lshr_seq[INTVAL (XEXP (op, 1)) & 31].insn_count;\n }\n \n /* Generate rtl for instructions for which shl_and_kind advised a particular\n@@ -3793,9 +3845,9 @@ gen_shl_and (rtx dest, rtx left_rtx, rtx mask_rtx, rtx source)\n \t  int neg = 0;\n \t  if (kind != 4 && total_shift < 16)\n \t    {\n-\t      neg = -ext_shift_amounts[total_shift][1];\n+\t      neg = -ext_ashl_lshr_seq[total_shift].amount[1];\n \t      if (neg > 0)\n-\t\tneg -= ext_shift_amounts[total_shift][2];\n+\t\tneg -= ext_ashl_lshr_seq[total_shift].amount[2];\n \t      else\n \t\tneg = 0;\n \t    }\n@@ -3842,11 +3894,13 @@ shl_sext_kind (rtx left_rtx, rtx size_rtx, int *costp)\n   gcc_assert (insize > 0);\n   /* Default to left / right shift.  */\n   kind = 0;\n-  best_cost = shift_insns[32 - insize] + ashiftrt_insns[32 - size];\n+  best_cost = ashl_lshr_seq[32 - insize].insn_count\n+\t      + ashl_lshr_seq[32 - size].insn_count;\n   if (size <= 16)\n     {\n       /* 16 bit shift / sign extend / 16 bit shift */\n-      cost = shift_insns[16 - insize] + 1 + ashiftrt_insns[16 - size];\n+      cost = ashl_lshr_seq[16 - insize].insn_count + 1\n+\t     + ashl_lshr_seq[16 - size].insn_count;\n       /* If ashiftrt_insns[16 - size] is 8, this choice will be overridden\n \t below, by alternative 3 or something even better.  */\n       if (cost < best_cost)\n@@ -3860,7 +3914,8 @@ shl_sext_kind (rtx left_rtx, rtx size_rtx, int *costp)\n     {\n       if (ext <= size)\n \t{\n-\t  cost = ext_shift_insns[ext - insize] + 1 + shift_insns[size - ext];\n+\t  cost = ext_ashl_lshr_seq[ext - insize].insn_count + 1\n+\t\t + ashl_lshr_seq[size - ext].insn_count;\n \t  if (cost < best_cost)\n \t    {\n \t      kind = ext / (unsigned) 8;\n@@ -3870,12 +3925,14 @@ shl_sext_kind (rtx left_rtx, rtx size_rtx, int *costp)\n       /* Check if we can do a sloppy shift with a final signed shift\n \t restoring the sign.  */\n       if (EXT_SHIFT_SIGNED (size - ext))\n-\tcost = ext_shift_insns[ext - insize] + ext_shift_insns[size - ext] + 1;\n+\tcost = ext_ashl_lshr_seq[ext - insize].insn_count\n+\t       + ext_ashl_lshr_seq[size - ext].insn_count + 1;\n       /* If not, maybe it's still cheaper to do the second shift sloppy,\n \t and do a final sign extend?  */\n       else if (size <= 16)\n-\tcost = ext_shift_insns[ext - insize] + 1\n-\t  + ext_shift_insns[size > ext ? size - ext : ext - size] + 1;\n+\tcost = ext_ashl_lshr_seq[ext - insize].insn_count + 1\n+\t  + ext_ashl_lshr_seq[size > ext ? size - ext : ext - size].insn_count\n+\t  + 1;\n       else\n \tcontinue;\n       if (cost < best_cost)\n@@ -3887,7 +3944,7 @@ shl_sext_kind (rtx left_rtx, rtx size_rtx, int *costp)\n   /* Check if we can sign extend in r0 */\n   if (insize < 8)\n     {\n-      cost = 3 + shift_insns[left];\n+      cost = 3 + ashl_lshr_seq[left].insn_count;\n       if (cost < best_cost)\n \t{\n \t  kind = 6;\n@@ -3896,7 +3953,7 @@ shl_sext_kind (rtx left_rtx, rtx size_rtx, int *costp)\n       /* Try the same with a final signed shift.  */\n       if (left < 31)\n \t{\n-\t  cost = 3 + ext_shift_insns[left + 1] + 1;\n+\t  cost = 3 + ext_ashl_lshr_seq[left + 1].insn_count + 1;\n \t  if (cost < best_cost)\n \t    {\n \t      kind = 7;\n@@ -3907,7 +3964,7 @@ shl_sext_kind (rtx left_rtx, rtx size_rtx, int *costp)\n   if (TARGET_DYNSHIFT)\n     {\n       /* Try to use a dynamic shift.  */\n-      cost = shift_insns[32 - insize] + 1 + SH_DYNAMIC_SHIFT_COST;\n+      cost = ashl_lshr_seq[32 - insize].insn_count + 1 + SH_DYNAMIC_SHIFT_COST;\n       if (cost < best_cost)\n \t{\n \t  kind = 0;"}, {"sha": "ffa899d3a48670b36615aca70a842eb14cc95e75", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70d4736c9af4dd94e932aee07f4e27e675350331/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70d4736c9af4dd94e932aee07f4e27e675350331/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=70d4736c9af4dd94e932aee07f4e27e675350331", "patch": "@@ -3496,6 +3496,17 @@ label:\n   if (TARGET_DYNSHIFT\n       && CONST_INT_P (operands[2]) && sh_dynamicalize_shift_p (operands[2]))\n       operands[2] = force_reg (SImode, operands[2]);\n+\n+  /*  If the ashlsi3_* insn is going to clobber the T_REG it must be\n+      expanded here.  */\n+  if (CONST_INT_P (operands[2])\n+      && sh_ashlsi_clobbers_t_reg_p (operands[2])\n+      && ! sh_dynamicalize_shift_p (operands[2]))\n+    {\n+      emit_insn (gen_ashlsi3_n_clobbers_t (operands[0], operands[1],\n+\t\t\t\t\t   operands[2]));\n+      DONE;\n+    }\n })\n \n (define_insn \"ashlsi3_k\"\n@@ -3522,7 +3533,7 @@ label:\n       emit_insn (gen_ashlsi3_k (operands[0], operands[1], operands[2]));\n       DONE;\n     }\n-  else if (!satisfies_constraint_P27 (operands[2]))\n+  else if (! satisfies_constraint_P27 (operands[2]))\n     {\n       /* This must happen before reload, otherwise the constant will be moved\n \t into a register due to the \"r\" constraint, after which this split\n@@ -3541,7 +3552,32 @@ label:\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n \t\t   (match_operand:SI 2 \"not_p27_shift_count_operand\" \"\")))]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && ! sh_ashlsi_clobbers_t_reg_p (operands[2])\"\n+  \"#\"\n+  \"&& (reload_completed\n+       || (sh_dynamicalize_shift_p (operands[2]) && can_create_pseudo_p ()))\"\n+  [(const_int 0)]\n+{\n+  if (sh_dynamicalize_shift_p (operands[2]) && can_create_pseudo_p ())\n+    {\n+      /* If this pattern was picked and dynamic shifts are supported, switch\n+\t to dynamic shift pattern before reload.  However, we must not\n+\t create a shift sequence that clobbers the T_REG.  */\n+      operands[2] = force_reg (SImode, operands[2]);\n+      emit_insn (gen_ashlsi3_d (operands[0], operands[1], operands[2]));\n+    }\n+  else\n+    gen_shifty_op (ASHIFT, operands);\n+\n+  DONE;\n+})\n+\n+(define_insn_and_split \"ashlsi3_n_clobbers_t\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n+\t(ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"not_p27_shift_count_operand\" \"\")))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1 && sh_ashlsi_clobbers_t_reg_p (operands[2])\"\n   \"#\"\n   \"&& (reload_completed || INTVAL (operands[2]) == 31\n        || (sh_dynamicalize_shift_p (operands[2]) && can_create_pseudo_p ()))\""}]}