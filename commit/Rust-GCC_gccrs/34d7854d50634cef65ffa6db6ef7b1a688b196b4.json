{"sha": "34d7854d50634cef65ffa6db6ef7b1a688b196b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRkNzg1NGQ1MDYzNGNlZjY1ZmZhNmRiNmVmN2IxYTY4OGIxOTZiNA==", "commit": {"author": {"name": "Jackson Woodruff", "email": "jackson.woodruff@arm.com", "date": "2018-07-13T08:38:18Z"}, "committer": {"name": "Jackson Woodruff", "email": "jcw@gcc.gnu.org", "date": "2018-07-13T08:38:18Z"}, "message": "aarch64.c (aarch64_operands_adjust_ok_for_ldpstp): Use arrays instead of numbered variables.\n\n\n\t* config/aarch64/aarch64.c (aarch64_operands_adjust_ok_for_ldpstp): Use\n\tarrays instead of numbered variables.\n\nFrom-SVN: r262626", "tree": {"sha": "643ebfd15b3e7c31d6ee45d79a3f90f2333062da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/643ebfd15b3e7c31d6ee45d79a3f90f2333062da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34d7854d50634cef65ffa6db6ef7b1a688b196b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34d7854d50634cef65ffa6db6ef7b1a688b196b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34d7854d50634cef65ffa6db6ef7b1a688b196b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34d7854d50634cef65ffa6db6ef7b1a688b196b4/comments", "author": null, "committer": null, "parents": [{"sha": "f77c5a3ff85875d388ab7034ddef23ce1a096748", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f77c5a3ff85875d388ab7034ddef23ce1a096748", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f77c5a3ff85875d388ab7034ddef23ce1a096748"}], "stats": {"total": 147, "additions": 64, "deletions": 83}, "files": [{"sha": "b97ebca58c735f748584141e560e13c1f3b930b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d7854d50634cef65ffa6db6ef7b1a688b196b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d7854d50634cef65ffa6db6ef7b1a688b196b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=34d7854d50634cef65ffa6db6ef7b1a688b196b4", "patch": "@@ -1,3 +1,8 @@\n+2018-07-13  Jackson Woodruff  <jackson.woodruff@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_operands_adjust_ok_for_ldpstp): Use\n+\tarrays instead of numbered variables.\n+\n 2018-07-13  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/sparc/sparc-protos.h (sparc_compute_frame_size): Delete."}, {"sha": "1369704da3ed8094c0d4612643794e6392dce05a", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 59, "deletions": 83, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d7854d50634cef65ffa6db6ef7b1a688b196b4/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d7854d50634cef65ffa6db6ef7b1a688b196b4/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=34d7854d50634cef65ffa6db6ef7b1a688b196b4", "patch": "@@ -17040,23 +17040,20 @@ bool\n aarch64_operands_adjust_ok_for_ldpstp (rtx *operands, bool load,\n \t\t\t\t       scalar_mode mode)\n {\n-  enum reg_class rclass_1, rclass_2, rclass_3, rclass_4;\n-  HOST_WIDE_INT offvals[4], msize;\n-  rtx mem_1, mem_2, mem_3, mem_4, reg_1, reg_2, reg_3, reg_4;\n-  rtx base_1, base_2, base_3, base_4, offset_1, offset_2, offset_3, offset_4;\n+  const int num_insns = 4;\n+  enum reg_class rclass;\n+  HOST_WIDE_INT offvals[num_insns], msize;\n+  rtx mem[num_insns], reg[num_insns], base[num_insns], offset[num_insns];\n \n   if (load)\n     {\n-      reg_1 = operands[0];\n-      mem_1 = operands[1];\n-      reg_2 = operands[2];\n-      mem_2 = operands[3];\n-      reg_3 = operands[4];\n-      mem_3 = operands[5];\n-      reg_4 = operands[6];\n-      mem_4 = operands[7];\n-      gcc_assert (REG_P (reg_1) && REG_P (reg_2)\n-\t\t  && REG_P (reg_3) && REG_P (reg_4));\n+      for (int i = 0; i < num_insns; i++)\n+\t{\n+\t  reg[i] = operands[2 * i];\n+\t  mem[i] = operands[2 * i + 1];\n+\n+\t  gcc_assert (REG_P (reg[i]));\n+\t}\n \n       /* Do not attempt to merge the loads if the loads clobber each other.  */\n       for (int i = 0; i < 8; i += 2)\n@@ -17065,53 +17062,47 @@ aarch64_operands_adjust_ok_for_ldpstp (rtx *operands, bool load,\n \t    return false;\n     }\n   else\n-    {\n-      mem_1 = operands[0];\n-      reg_1 = operands[1];\n-      mem_2 = operands[2];\n-      reg_2 = operands[3];\n-      mem_3 = operands[4];\n-      reg_3 = operands[5];\n-      mem_4 = operands[6];\n-      reg_4 = operands[7];\n-    }\n-  /* Skip if memory operand is by itslef valid for ldp/stp.  */\n-  if (!MEM_P (mem_1) || aarch64_mem_pair_operand (mem_1, mode))\n-    return false;\n+    for (int i = 0; i < num_insns; i++)\n+      {\n+\tmem[i] = operands[2 * i];\n+\treg[i] = operands[2 * i + 1];\n+      }\n \n-  /* The mems cannot be volatile.  */\n-  if (MEM_VOLATILE_P (mem_1) || MEM_VOLATILE_P (mem_2)\n-      || MEM_VOLATILE_P (mem_3) ||MEM_VOLATILE_P (mem_4))\n+  /* Skip if memory operand is by itself valid for ldp/stp.  */\n+  if (!MEM_P (mem[0]) || aarch64_mem_pair_operand (mem[0], mode))\n     return false;\n \n-  /* Check if the addresses are in the form of [base+offset].  */\n-  extract_base_offset_in_addr (mem_1, &base_1, &offset_1);\n-  if (base_1 == NULL_RTX || offset_1 == NULL_RTX)\n-    return false;\n-  extract_base_offset_in_addr (mem_2, &base_2, &offset_2);\n-  if (base_2 == NULL_RTX || offset_2 == NULL_RTX)\n-    return false;\n-  extract_base_offset_in_addr (mem_3, &base_3, &offset_3);\n-  if (base_3 == NULL_RTX || offset_3 == NULL_RTX)\n-    return false;\n-  extract_base_offset_in_addr (mem_4, &base_4, &offset_4);\n-  if (base_4 == NULL_RTX || offset_4 == NULL_RTX)\n-    return false;\n+  for (int i = 0; i < num_insns; i++)\n+    {\n+      /* The mems cannot be volatile.  */\n+      if (MEM_VOLATILE_P (mem[i]))\n+\treturn false;\n+\n+      /* Check if the addresses are in the form of [base+offset].  */\n+      extract_base_offset_in_addr (mem[i], base + i, offset + i);\n+      if (base[i] == NULL_RTX || offset[i] == NULL_RTX)\n+\treturn false;\n+    }\n+\n+  /* Check if addresses are clobbered by load.  */\n+  if (load)\n+    for (int i = 0; i < num_insns; i++)\n+      if (reg_mentioned_p (reg[i], mem[i]))\n+\treturn false;\n \n   /* Check if the bases are same.  */\n-  if (!rtx_equal_p (base_1, base_2)\n-      || !rtx_equal_p (base_2, base_3)\n-      || !rtx_equal_p (base_3, base_4))\n-    return false;\n+  for (int i = 0; i < num_insns - 1; i++)\n+    if (!rtx_equal_p (base[i], base[i + 1]))\n+      return false;\n+\n+  for (int i = 0; i < num_insns; i++)\n+    offvals[i] = INTVAL (offset[i]);\n \n-  offvals[0] = INTVAL (offset_1);\n-  offvals[1] = INTVAL (offset_2);\n-  offvals[2] = INTVAL (offset_3);\n-  offvals[3] = INTVAL (offset_4);\n   msize = GET_MODE_SIZE (mode);\n \n   /* Check if the offsets can be put in the right order to do a ldp/stp.  */\n-  qsort (offvals, 4, sizeof (HOST_WIDE_INT), aarch64_host_wide_int_compare);\n+  qsort (offvals, num_insns, sizeof (HOST_WIDE_INT),\n+\t aarch64_host_wide_int_compare);\n \n   if (!(offvals[1] == offvals[0] + msize\n \t&& offvals[3] == offvals[2] + msize))\n@@ -17126,45 +17117,30 @@ aarch64_operands_adjust_ok_for_ldpstp (rtx *operands, bool load,\n   if (offvals[0] % msize != offvals[2] % msize)\n     return false;\n \n-  /* Check if the addresses are clobbered by load.  */\n-  if (load && (reg_mentioned_p (reg_1, mem_1)\n-\t       || reg_mentioned_p (reg_2, mem_2)\n-\t       || reg_mentioned_p (reg_3, mem_3)\n-\t       || reg_mentioned_p (reg_4, mem_4)))\n-    return false;\n-\n   /* If we have SImode and slow unaligned ldp,\n      check the alignment to be at least 8 byte. */\n   if (mode == SImode\n       && (aarch64_tune_params.extra_tuning_flags\n-          & AARCH64_EXTRA_TUNE_SLOW_UNALIGNED_LDPW)\n+\t  & AARCH64_EXTRA_TUNE_SLOW_UNALIGNED_LDPW)\n       && !optimize_size\n-      && MEM_ALIGN (mem_1) < 8 * BITS_PER_UNIT)\n+      && MEM_ALIGN (mem[0]) < 8 * BITS_PER_UNIT)\n     return false;\n \n-  if (REG_P (reg_1) && FP_REGNUM_P (REGNO (reg_1)))\n-    rclass_1 = FP_REGS;\n-  else\n-    rclass_1 = GENERAL_REGS;\n-\n-  if (REG_P (reg_2) && FP_REGNUM_P (REGNO (reg_2)))\n-    rclass_2 = FP_REGS;\n-  else\n-    rclass_2 = GENERAL_REGS;\n-\n-  if (REG_P (reg_3) && FP_REGNUM_P (REGNO (reg_3)))\n-    rclass_3 = FP_REGS;\n-  else\n-    rclass_3 = GENERAL_REGS;\n-\n-  if (REG_P (reg_4) && FP_REGNUM_P (REGNO (reg_4)))\n-    rclass_4 = FP_REGS;\n-  else\n-    rclass_4 = GENERAL_REGS;\n-\n   /* Check if the registers are of same class.  */\n-  if (rclass_1 != rclass_2 || rclass_2 != rclass_3 || rclass_3 != rclass_4)\n-    return false;\n+  rclass = REG_P (reg[0]) && FP_REGNUM_P (REGNO (reg[0]))\n+    ? FP_REGS : GENERAL_REGS;\n+\n+  for (int i = 1; i < num_insns; i++)\n+    if (REG_P (reg[i]) && FP_REGNUM_P (REGNO (reg[i])))\n+      {\n+\tif (rclass != FP_REGS)\n+\t  return false;\n+      }\n+    else\n+      {\n+\tif (rclass != GENERAL_REGS)\n+\t  return false;\n+      }\n \n   return true;\n }"}]}