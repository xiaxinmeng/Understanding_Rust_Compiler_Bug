{"sha": "3e293154d69acf16281d5b9b038ca741c1cf53d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2UyOTMxNTRkNjlhY2YxNjI4MWQ1YjliMDM4Y2E3NDFjMWNmNTNkNg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2008-07-23T19:45:45Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2008-07-23T19:45:45Z"}, "message": "ipa-cp.c (ipcp_print_edge_profiles): Test for node->analyzed rather than for DECL_SAVED_TREE.\n\n2008-07-23  Martin Jambor  <mjambor@suse.cz>\n\n        * ipa-cp.c (ipcp_print_edge_profiles): Test for node->analyzed\n\trather than for DECL_SAVED_TREE.\n\t* ipa-prop.c: Include diagnostic.h.\n        (ipa_check_stmt_modifications): Check LHS of GIMPLE_MODIFY_EXPRs\n\tthoroughly.\n\t(ipa_detect_param_modifications): Function rewritten from scratch.\n\t(ipa_compute_jump_functions): Changed accesses to modification flags.\n\t(ipa_free_node_params_substructures): Update flags destruction.\n\t(ipa_node_duplication_hook): Update flags duplication.\n\t(ipa_print_all_params_modified): Updated flag access.\n\t* ipa-prop.h (struct ipa_param_flags): New structure.\n        (struct ipa_node_params): New field modification_analysis_done,\n        modified_flags changed into param_flags.\n        (ipa_is_ith_param_modified): Changed to use new flags.\n\t* Makefile.in (ipa-prop.o): Add $(DIAGNOSTIC_H) to dependencies.\n\n\t* ipa-prop.c (ipa_print_all_jump_functions): Moved here from\n\tipa-cp.c and split into two functions.\n\t(ipa_print_node_jump_functions): New function.\n\t(compute_scalar_jump_functions): New function.\n\t(type_like_member_ptr_p): New function.\n\t(compute_pass_through_member_ptrs): New function.\n\t(fill_member_ptr_cst_jump_function): New function.\n\t(determine_cst_member_ptr): New function.\n\t(compute_cst_member_ptr_arguments): New function.\n\t(ipa_compute_jump_functions): Complete rewrite.\n\t* ipa-prop.h (enum jump_func_type): Make explicit that we depend\n\ton IPA_UNKNOWN being zero. Added value IPA_CONST_MEMBER_PTR.\n\t(struct ipa_member_ptr_cst): New structure.\n\t(union jump_func_value): New field member_cst.\n\t* ipa-cp.c (ipcp_lat_is_insertable): New function.\n\t(ipcp_lattice_from_jfunc): Produces bottom lattices for unhandled\n\tjump function types.\n\t(ipcp_print_all_lattices): Slight fprintf rearrangement.\n\t(ipcp_print_all_structures): Call ipa_print_all_jump_functions\n\tinstead of ipcp_print_all_jump_functions.\n\t(ipcp_insert_stage): Use ipcp_lat_is_insertable, create replace maps\n\tonly for replacable scalars.\n\n\t* doc/invoke.texi (Optimize options): Add description of\n\t-findirect-inlining.\n\t* common.opt (flag_indirect_inlining): New flag.\n\t* opts.c (decode_options): Set flag_indirect_inlining when \n\toptimize >= 3.\n\n\t* ipa-inline.c: Include ipa-prop.h.\n\t(inline_indirect_intraprocedural_analysis): New function.\n\t(inline_generate_summary): Allocate parameter and argument info\n\tstructures, call inline_indirect_intraprocedural_analysis on each\n\tnode when doing indirect inlining and deallocate indirect inlining \n\tdata structures in the end.\n\t* ipa-prop.c (ipa_create_param_decls_array): Return if already done.\n\t(free_all_ipa_structures_after_iinln): New function.\n\t(free_all_ipa_structures_after_ipa_cp): Checks whether iinln will be \n\tdone.\n\t* Makefile.in (ipa-inline.o): Added $(IPA_PROP_H) to dependencies.\n\n\t* cgraphbuild.c (compute_call_stmt_bb_frequency): New function.\n\t(build_cgraph_edges): Call compute_call_stmt_bb_frequency instead\n\tof computing the frequency separately.\n\t(rebuild_cgraph_edges): Call compute_call_stmt_bb_frequency instead\n\tof computing the frequency separately.\n\t* ipa-cp.c (ipcp_print_all_structures): Replace a call to \n\tipa_print_all_param_modified with a call to ipa_print_all_param_flags.\n\t* ipa-prop.c (ipa_get_member_ptr_load_param): New function.\n\t(ipa_get_stmt_member_ptr_load_param): New function.\n\t(ipa_is_ssa_with_stmt_def): New function.\n\t(ipa_note_param_call): New function.\n\t(ipa_analyze_call_uses): New function.\n\t(ipa_analyze_stmt_uses): New function.\n\t(ipa_analyze_params_uses): New function.\n\t(ipa_free_node_params_substructures): Also free the param_calls linked\n\tlist.\n\t(ipa_node_duplication_hook): Also duplicate the param_calls linked list.\n\t(ipa_print_node_param_flags): New function.\n\t(ipa_print_all_params_modified): Renamed to ipa_print_all_param_flags.\n\t(ipa_print_all_param_flags): Calls ipa_print_node_param_flags.\n\t* ipa-prop.h (struct ipa_param_flags): New field called.\n\t(struct ipa_param_call_note): New structure.\n\t(struct ipa_node_params): New fields param_calls and\n\tuses_analysis_done.\n\t(ipa_is_ith_param_called): New function.\n\t* ipa-inline.c (inline_indirect_intraprocedural_analysis): Call\n\tipa_analyze_params_uses and dump parameter flags.\n\n\t* ipa-inline.c (cgraph_decide_recursive_inlining): Call\n\tipa_propagate_indirect_call_infos if performing indirect inlining,\n\tpass a new parameter new_edges to it.\n\t(add_new_edges_to_heap): New fucntion.\n\t(cgraph_decide_inlining_of_small_functions): New vector\n\tnew_indirect_edges for newly found indirect edges , call\n\tipa_propagate_indirect_call_infos after inlining.\n\t(cgraph_decide_inlining): Call ipa_propagate_indirect_call_infos after\n\tinlining if performing indirect inlining.  Call\n\tfree_all_ipa_structures_after_iinln when doing so too.\n\t(inline_generate_summary): Do not call\n\tfree_all_ipa_structures_after_iinln here.\n\t* ipa-prop.c (update_jump_functions_after_inlining): New function.\n\t(print_edge_addition_message): New function.\n\t(update_call_notes_after_inlining): New function.\n\t(propagate_info_to_inlined_callees): New function.\n\t(ipa_propagate_indirect_call_infos): New function.\n\t* ipa-prop.h: Include cgraph.h\n\t(struct ipa_param_call_note): Fields reordered, new field processed.\n\t* cgraph.h (cgraph_edge): Shrink loop_nest field to 31 bits, add a new\n\tflag indirect_call.\n\t* cgraphunit.c (verify_cgraph_node): Allow indirect edges not to have\n\trediscovered call statements.\n\t* cgraph.c (cgraph_create_edge): Initialize indirect_call to zero.\n\t(dump_cgraph_node): Dump also the indirect_call flag.\n\t(cgraph_clone_edge): Copy also the indirect_call flag.\n\t* tree-inline.c (copy_bb): Do not check for fndecls from call\n\texpressions, check for edge availability when moving clones.\n\t(get_indirect_callee_fndecl): New function.\n\t(expand_call_inline): If callee declaration is not apprent from\n\tthe statement, try calling get_indirect_callee_fndecl.  Do not\n\tissue warnings or call sorry when not inlinings an indirect edge.\n\t* Makefile.in (IPA_PROP_H): Added $(CGRAPH_H) to dependencies.\n\n\t* ipa-prop.c (ipa_print_node_param_flags): Make the dump format a\n\tbit more frandly to matching.\n\t* testsuite/g++.dg/ipa/iinline-1.C: New testcase.\n\t* testsuite/gcc.dg/ipa/iinline-1.c: New testcase.\n\t* testsuite/gcc.dg/ipa/modif-1.c: New testcase.\n\nFrom-SVN: r138092", "tree": {"sha": "425c693ef81efc3a4ab38d1ddfbc42bc63047cc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/425c693ef81efc3a4ab38d1ddfbc42bc63047cc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e293154d69acf16281d5b9b038ca741c1cf53d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e293154d69acf16281d5b9b038ca741c1cf53d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e293154d69acf16281d5b9b038ca741c1cf53d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e293154d69acf16281d5b9b038ca741c1cf53d6/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e62fe68a6400c082dd735c29b83890e4935ea36d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e62fe68a6400c082dd735c29b83890e4935ea36d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e62fe68a6400c082dd735c29b83890e4935ea36d"}], "stats": {"total": 1668, "additions": 1393, "deletions": 275}, "files": [{"sha": "b79791e58e7b7145d8d666cd65e43d0d00780b79", "filename": "gcc/ChangeLog", "status": "modified", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3e293154d69acf16281d5b9b038ca741c1cf53d6", "patch": "@@ -1,3 +1,130 @@\n+2008-07-23  Martin Jambor  <mjambor@suse.cz>\n+\n+        * ipa-cp.c (ipcp_print_edge_profiles): Test for node->analyzed\n+\trather than for DECL_SAVED_TREE.\n+\t* ipa-prop.c: Include diagnostic.h.\n+        (ipa_check_stmt_modifications): Check LHS of GIMPLE_MODIFY_EXPRs\n+\tthoroughly.\n+\t(ipa_detect_param_modifications): Function rewritten from scratch.\n+\t(ipa_compute_jump_functions): Changed accesses to modification flags.\n+\t(ipa_free_node_params_substructures): Update flags destruction.\n+\t(ipa_node_duplication_hook): Update flags duplication.\n+\t(ipa_print_all_params_modified): Updated flag access.\n+\t* ipa-prop.h (struct ipa_param_flags): New structure.\n+        (struct ipa_node_params): New field modification_analysis_done,\n+        modified_flags changed into param_flags.\n+        (ipa_is_ith_param_modified): Changed to use new flags.\n+\t* Makefile.in (ipa-prop.o): Add $(DIAGNOSTIC_H) to dependencies.\n+\n+\t* ipa-prop.c (ipa_print_all_jump_functions): Moved here from\n+\tipa-cp.c and split into two functions.\n+\t(ipa_print_node_jump_functions): New function.\n+\t(compute_scalar_jump_functions): New function.\n+\t(type_like_member_ptr_p): New function.\n+\t(compute_pass_through_member_ptrs): New function.\n+\t(fill_member_ptr_cst_jump_function): New function.\n+\t(determine_cst_member_ptr): New function.\n+\t(compute_cst_member_ptr_arguments): New function.\n+\t(ipa_compute_jump_functions): Complete rewrite.\n+\t* ipa-prop.h (enum jump_func_type): Make explicit that we depend\n+\ton IPA_UNKNOWN being zero. Added value IPA_CONST_MEMBER_PTR.\n+\t(struct ipa_member_ptr_cst): New structure.\n+\t(union jump_func_value): New field member_cst.\n+\t* ipa-cp.c (ipcp_lat_is_insertable): New function.\n+\t(ipcp_lattice_from_jfunc): Produces bottom lattices for unhandled\n+\tjump function types.\n+\t(ipcp_print_all_lattices): Slight fprintf rearrangement.\n+\t(ipcp_print_all_structures): Call ipa_print_all_jump_functions\n+\tinstead of ipcp_print_all_jump_functions.\n+\t(ipcp_insert_stage): Use ipcp_lat_is_insertable, create replace maps\n+\tonly for replacable scalars.\n+\n+\t* doc/invoke.texi (Optimize options): Add description of\n+\t-findirect-inlining.\n+\t* common.opt (flag_indirect_inlining): New flag.\n+\t* opts.c (decode_options): Set flag_indirect_inlining when \n+\toptimize >= 3.\n+\n+\t* ipa-inline.c: Include ipa-prop.h.\n+\t(inline_indirect_intraprocedural_analysis): New function.\n+\t(inline_generate_summary): Allocate parameter and argument info\n+\tstructures, call inline_indirect_intraprocedural_analysis on each\n+\tnode when doing indirect inlining and deallocate indirect inlining \n+\tdata structures in the end.\n+\t* ipa-prop.c (ipa_create_param_decls_array): Return if already done.\n+\t(free_all_ipa_structures_after_iinln): New function.\n+\t(free_all_ipa_structures_after_ipa_cp): Checks whether iinln will be \n+\tdone.\n+\t* Makefile.in (ipa-inline.o): Added $(IPA_PROP_H) to dependencies.\n+\n+\t* cgraphbuild.c (compute_call_stmt_bb_frequency): New function.\n+\t(build_cgraph_edges): Call compute_call_stmt_bb_frequency instead\n+\tof computing the frequency separately.\n+\t(rebuild_cgraph_edges): Call compute_call_stmt_bb_frequency instead\n+\tof computing the frequency separately.\n+\t* ipa-cp.c (ipcp_print_all_structures): Replace a call to \n+\tipa_print_all_param_modified with a call to ipa_print_all_param_flags.\n+\t* ipa-prop.c (ipa_get_member_ptr_load_param): New function.\n+\t(ipa_get_stmt_member_ptr_load_param): New function.\n+\t(ipa_is_ssa_with_stmt_def): New function.\n+\t(ipa_note_param_call): New function.\n+\t(ipa_analyze_call_uses): New function.\n+\t(ipa_analyze_stmt_uses): New function.\n+\t(ipa_analyze_params_uses): New function.\n+\t(ipa_free_node_params_substructures): Also free the param_calls linked\n+\tlist.\n+\t(ipa_node_duplication_hook): Also duplicate the param_calls linked list.\n+\t(ipa_print_node_param_flags): New function.\n+\t(ipa_print_all_params_modified): Renamed to ipa_print_all_param_flags.\n+\t(ipa_print_all_param_flags): Calls ipa_print_node_param_flags.\n+\t* ipa-prop.h (struct ipa_param_flags): New field called.\n+\t(struct ipa_param_call_note): New structure.\n+\t(struct ipa_node_params): New fields param_calls and\n+\tuses_analysis_done.\n+\t(ipa_is_ith_param_called): New function.\n+\t* ipa-inline.c (inline_indirect_intraprocedural_analysis): Call\n+\tipa_analyze_params_uses and dump parameter flags.\n+\n+\t* ipa-inline.c (cgraph_decide_recursive_inlining): Call\n+\tipa_propagate_indirect_call_infos if performing indirect inlining,\n+\tpass a new parameter new_edges to it.\n+\t(add_new_edges_to_heap): New fucntion.\n+\t(cgraph_decide_inlining_of_small_functions): New vector\n+\tnew_indirect_edges for newly found indirect edges , call\n+\tipa_propagate_indirect_call_infos after inlining.\n+\t(cgraph_decide_inlining): Call ipa_propagate_indirect_call_infos after\n+\tinlining if performing indirect inlining.  Call\n+\tfree_all_ipa_structures_after_iinln when doing so too.\n+\t(inline_generate_summary): Do not call\n+\tfree_all_ipa_structures_after_iinln here.\n+\t* ipa-prop.c (update_jump_functions_after_inlining): New function.\n+\t(print_edge_addition_message): New function.\n+\t(update_call_notes_after_inlining): New function.\n+\t(propagate_info_to_inlined_callees): New function.\n+\t(ipa_propagate_indirect_call_infos): New function.\n+\t* ipa-prop.h: Include cgraph.h\n+\t(struct ipa_param_call_note): Fields reordered, new field processed.\n+\t* cgraph.h (cgraph_edge): Shrink loop_nest field to 31 bits, add a new\n+\tflag indirect_call.\n+\t* cgraphunit.c (verify_cgraph_node): Allow indirect edges not to have\n+\trediscovered call statements.\n+\t* cgraph.c (cgraph_create_edge): Initialize indirect_call to zero.\n+\t(dump_cgraph_node): Dump also the indirect_call flag.\n+\t(cgraph_clone_edge): Copy also the indirect_call flag.\n+\t* tree-inline.c (copy_bb): Do not check for fndecls from call\n+\texpressions, check for edge availability when moving clones.\n+\t(get_indirect_callee_fndecl): New function.\n+\t(expand_call_inline): If callee declaration is not apprent from\n+\tthe statement, try calling get_indirect_callee_fndecl.  Do not\n+\tissue warnings or call sorry when not inlinings an indirect edge.\n+\t* Makefile.in (IPA_PROP_H): Added $(CGRAPH_H) to dependencies.\n+\n+\t* ipa-prop.c (ipa_print_node_param_flags): Make the dump format a\n+\tbit more frandly to matching.\n+\t* testsuite/g++.dg/ipa/iinline-1.C: New testcase.\n+\t* testsuite/gcc.dg/ipa/iinline-1.c: New testcase.\n+\t* testsuite/gcc.dg/ipa/modif-1.c: New testcase.\n+\t\n 2008-07-23  Michael Meissner  <gnu@the-meissners.org>\n \n \tPR 36907"}, {"sha": "f73686f030037751c51a7406634291b96e290860", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3e293154d69acf16281d5b9b038ca741c1cf53d6", "patch": "@@ -860,7 +860,7 @@ TREE_INLINE_H = tree-inline.h $(VARRAY_H) pointer-set.h\n REAL_H = real.h $(MACHMODE_H)\n DBGCNT_H = dbgcnt.h dbgcnt.def\n EBIMAP_H = ebitmap.h sbitmap.h\n-IPA_PROP_H = ipa-prop.h $(TREE_H) vec.h\n+IPA_PROP_H = ipa-prop.h $(TREE_H) vec.h $(CGRAPH_H)\n GSTAB_H = gstab.h stab.def\n BITMAP_H = bitmap.h $(HASHTAB_H) statistics.h\n \n@@ -2564,8 +2564,8 @@ varpool.o : varpool.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_FLOW_H) gt-varpool.h\n ipa.o : ipa.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(CGRAPH_H) \\\n    tree-pass.h $(TIMEVAR_H)\n-ipa-prop.o : ipa-prop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n-   langhooks.h $(GGC_H) $(TARGET_H) $(CGRAPH_H) $(IPA_PROP_H) \\\n+ipa-prop.o : ipa-prop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   langhooks.h $(GGC_H) $(TARGET_H) $(CGRAPH_H) $(IPA_PROP_H) $(DIAGNOSTIC_H) \\\n    $(TREE_FLOW_H) $(TM_H) tree-pass.h $(FLAGS_H) $(TREE_H) $(TREE_INLINE_H) \\\n    $(TIMEVAR_H)\n ipa-cp.o : ipa-cp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n@@ -2581,7 +2581,7 @@ matrix-reorg.o : matrix-reorg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n ipa-inline.o : ipa-inline.c gt-ipa-inline.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(TREE_INLINE_H) $(FLAGS_H) $(CGRAPH_H) intl.h \\\n    $(DIAGNOSTIC_H) $(FIBHEAP_H) $(PARAMS_H) $(TIMEVAR_H) tree-pass.h \\\n-   $(HASHTAB_H) $(COVERAGE_H) $(GGC_H) $(TREE_FLOW_H) $(RTL_H)\n+   $(HASHTAB_H) $(COVERAGE_H) $(GGC_H) $(TREE_FLOW_H) $(RTL_H) $(IPA_PROP_H)\n ipa-utils.o : ipa-utils.c $(IPA_UTILS_H) $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(C_COMMON_H) $(TREE_GIMPLE_H) \\"}, {"sha": "14d058788084b0d61fafea94ac7f68cb0e48dbea", "filename": "gcc/cgraph.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=3e293154d69acf16281d5b9b038ca741c1cf53d6", "patch": "@@ -625,6 +625,7 @@ cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n   gcc_assert (freq >= 0);\n   gcc_assert (freq <= CGRAPH_FREQ_MAX);\n   edge->loop_nest = nest;\n+  edge->indirect_call = 0;\n   edge->uid = cgraph_edge_max_uid++;\n   if (caller->call_site_hash)\n     {\n@@ -1048,6 +1049,8 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \t\t edge->frequency / (double)CGRAPH_FREQ_BASE);\n       if (!edge->inline_failed)\n \tfprintf(f, \"(inlined) \");\n+      if (edge->indirect_call)\n+\tfprintf(f, \"(indirect) \");\n     }\n \n   fprintf (f, \"\\n  calls: \");\n@@ -1057,6 +1060,8 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \t       edge->callee->uid);\n       if (!edge->inline_failed)\n \tfprintf(f, \"(inlined) \");\n+      if (edge->indirect_call)\n+\tfprintf(f, \"(indirect) \");\n       if (edge->count)\n \tfprintf (f, \"(\"HOST_WIDEST_INT_PRINT_DEC\"x) \",\n \t\t (HOST_WIDEST_INT)edge->count);\n@@ -1166,6 +1171,7 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n \t\t\t    e->loop_nest + loop_nest);\n \n   new->inline_failed = e->inline_failed;\n+  new->indirect_call = e->indirect_call;\n   if (update_original)\n     {\n       e->count -= new->count;"}, {"sha": "f36f6f577a2f8862894428840640e9a7d3875f05", "filename": "gcc/cgraph.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=3e293154d69acf16281d5b9b038ca741c1cf53d6", "patch": "@@ -208,7 +208,9 @@ struct cgraph_edge GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_call\n      per function call.  The range is 0 to CGRAPH_FREQ_MAX.  */\n   int frequency;\n   /* Depth of loop nest, 1 means no loop nest.  */\n-  int loop_nest;\n+  unsigned int loop_nest : 31;\n+  /* Whether this edge describes a call that was originally indirect.  */\n+  unsigned int indirect_call : 1;\n   /* Unique id of the edge.  */\n   int uid;\n };\n@@ -376,6 +378,7 @@ void cgraph_remove_node_duplication_hook (struct cgraph_2node_hook_list *);\n \n /* In cgraphbuild.c  */\n unsigned int rebuild_cgraph_edges (void);\n+int compute_call_stmt_bb_frequency (basic_block bb);\n \n /* In ipa.c  */\n bool cgraph_remove_unreachable_nodes (bool, FILE *);"}, {"sha": "23cfde892eff2eb44798daef0bad6b4dded67f97", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=3e293154d69acf16281d5b9b038ca741c1cf53d6", "patch": "@@ -122,6 +122,25 @@ initialize_inline_failed (struct cgraph_node *node)\n     }\n }\n \n+/* Computes the frequency of the call statement so that it can be stored in\n+   cgraph_edge.  BB is the basic block of the call statement.  */\n+int\n+compute_call_stmt_bb_frequency (basic_block bb)\n+{\n+  int entry_freq = ENTRY_BLOCK_PTR->frequency;\n+  int freq;\n+\n+  if (!entry_freq)\n+    entry_freq = 1;\n+\n+  freq = (!bb->frequency && !entry_freq ? CGRAPH_FREQ_BASE\n+\t      : bb->frequency * CGRAPH_FREQ_BASE / entry_freq);\n+  if (freq > CGRAPH_FREQ_MAX)\n+    freq = CGRAPH_FREQ_MAX;\n+\n+  return freq;\n+}\n+\n /* Create cgraph edges for function calls.\n    Also look for functions and variables having addresses taken.  */\n \n@@ -133,10 +152,6 @@ build_cgraph_edges (void)\n   struct pointer_set_t *visited_nodes = pointer_set_create ();\n   block_stmt_iterator bsi;\n   tree step;\n-  int entry_freq = ENTRY_BLOCK_PTR->frequency;\n-\n-  if (!entry_freq)\n-    entry_freq = 1;\n \n   /* Create the callgraph edges and record the nodes referenced by the function.\n      body.  */\n@@ -151,12 +166,8 @@ build_cgraph_edges (void)\n \t  {\n \t    int i;\n \t    int n = call_expr_nargs (call);\n-\t    int freq = (!bb->frequency && !entry_freq ? CGRAPH_FREQ_BASE\n-\t\t\t: bb->frequency * CGRAPH_FREQ_BASE / entry_freq);\n-\t    if (freq > CGRAPH_FREQ_MAX)\n-\t      freq = CGRAPH_FREQ_MAX;\n \t    cgraph_create_edge (node, cgraph_node (decl), stmt,\n-\t\t\t\tbb->count, freq,\n+\t\t\t\tbb->count, compute_call_stmt_bb_frequency (bb),\n \t\t\t\tbb->loop_depth);\n \t    for (i = 0; i < n; i++)\n \t      walk_tree (&CALL_EXPR_ARG (call, i),\n@@ -227,10 +238,6 @@ rebuild_cgraph_edges (void)\n   basic_block bb;\n   struct cgraph_node *node = cgraph_node (current_function_decl);\n   block_stmt_iterator bsi;\n-  int entry_freq = ENTRY_BLOCK_PTR->frequency;\n-\n-  if (!entry_freq)\n-    entry_freq = 1;\n \n   cgraph_node_remove_callees (node);\n \n@@ -244,14 +251,9 @@ rebuild_cgraph_edges (void)\n \ttree decl;\n \n \tif (call && (decl = get_callee_fndecl (call)))\n-\t  {\n-\t    int freq = (!bb->frequency && !entry_freq ? CGRAPH_FREQ_BASE\n-\t\t\t: bb->frequency * CGRAPH_FREQ_BASE / entry_freq);\n-\t    if (freq > CGRAPH_FREQ_MAX)\n-\t      freq = CGRAPH_FREQ_MAX;\n-\t    cgraph_create_edge (node, cgraph_node (decl), stmt,\n-\t\t\t\tbb->count, freq, bb->loop_depth);\n-\t   }\n+\t  cgraph_create_edge (node, cgraph_node (decl), stmt,\n+\t\t\t      bb->count, compute_call_stmt_bb_frequency (bb),\n+\t\t\t      bb->loop_depth);\n       }\n   initialize_inline_failed (node);\n   gcc_assert (!node->global.inlined_to);"}, {"sha": "c9b072608d6fda1603f899f5fc6b2beca171bf15", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=3e293154d69acf16281d5b9b038ca741c1cf53d6", "patch": "@@ -796,7 +796,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \n       for (e = node->callees; e; e = e->next_callee)\n \t{\n-\t  if (!e->aux)\n+\t  if (!e->aux && !e->indirect_call)\n \t    {\n \t      error (\"edge %s->%s has no corresponding call_stmt\",\n \t\t     cgraph_node_name (e->caller),"}, {"sha": "5d730a8cbf4df931b740d71a26d5ce2eb9efe0e6", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=3e293154d69acf16281d5b9b038ca741c1cf53d6", "patch": "@@ -571,6 +571,10 @@ finhibit-size-directive\n Common Report Var(flag_inhibit_size_directive)\n Do not generate .size directives\n \n+findirect-inlining\n+Common Report Var(flag_indirect_inlining)\n+Perform indirect inlining\n+\n ; Nonzero means that functions declared `inline' will be treated\n ; as `static'.  Prevents generation of zillions of copies of unused\n ; static inline functions; instead, `inlines' are written out"}, {"sha": "bace891ffdc9e033bcf61db1c21f0339ce56043e", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3e293154d69acf16281d5b9b038ca741c1cf53d6", "patch": "@@ -328,8 +328,8 @@ Objective-C and Objective-C++ Dialects}.\n -fearly-inlining -fexpensive-optimizations -ffast-math @gol\n -ffinite-math-only -ffloat-store -fforward-propagate @gol\n -ffunction-sections -fgcse -fgcse-after-reload -fgcse-las -fgcse-lm @gol\n--fgcse-sm -fif-conversion -fif-conversion2 -finline-functions @gol\n--finline-functions-called-once -finline-limit=@var{n} @gol\n+-fgcse-sm -fif-conversion -fif-conversion2 -findirect-inlining @gol\n+-finline-functions -finline-functions-called-once -finline-limit=@var{n} @gol\n -finline-small-functions -fipa-cp -fipa-marix-reorg -fipa-pta @gol \n -fipa-pure-const -fipa-reference -fipa-struct-reorg @gol\n -fipa-type-escape -fivopts -fkeep-inline-functions -fkeep-static-consts @gol\n@@ -5199,6 +5199,7 @@ also turns on the following optimization flags:\n -fdelete-null-pointer-checks @gol\n -fexpensive-optimizations @gol\n -fgcse  -fgcse-lm  @gol\n+-findirect-inlining @gol\n -foptimize-sibling-calls @gol\n -fpeephole2 @gol\n -fregmove @gol\n@@ -5216,8 +5217,8 @@ invoking @option{-O2} on programs that use computed gotos.\n \n @item -O3\n @opindex O3\n-Optimize yet more.  @option{-O3} turns on all optimizations specified by\n-@option{-O2} and also turns on the @option{-finline-functions},\n+Optimize yet more.  @option{-O3} turns on all optimizations specified\n+by @option{-O2} and also turns on the @option{-finline-functions},\n @option{-funswitch-loops}, @option{-fpredictive-commoning},\n @option{-fgcse-after-reload} and @option{-ftree-vectorize} options.\n \n@@ -5319,6 +5320,15 @@ in this way.\n \n Enabled at level @option{-O2}.\n \n+@item -findirect-inlining\n+@opindex findirect-inlining\n+Inline also indirect calls that are discovered to be known at compile\n+time thanks to previous inlining.  This option has any effect only\n+when inlining itself is turned on by the @option{-finline-functions}\n+or @option{-finline-small-functions} options.\n+\n+Enabled at level @option{-O2}.\n+\n @item -finline-functions\n @opindex finline-functions\n Integrate all simple functions into their callers.  The compiler"}, {"sha": "92d12c44d917b3a66dc6ba5a7e3bd6f4a9bf3c84", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 28, "deletions": 68, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=3e293154d69acf16281d5b9b038ca741c1cf53d6", "patch": "@@ -183,6 +183,18 @@ ipcp_lat_is_const (struct ipcp_lattice *lat)\n     return false;\n }\n \n+/* Return whether LAT is a constant lattice that ipa-cp can actually insert\n+   into the code (i.e. constants excluding member pointers and pointers).  */\n+static inline bool\n+ipcp_lat_is_insertable (struct ipcp_lattice *lat)\n+{\n+  if ((lat->type == IPA_CONST_VALUE || lat->type == IPA_CONST_VALUE_REF)\n+      && !POINTER_TYPE_P (TREE_TYPE (lat->constant)))\n+    return true;\n+  else\n+    return false;\n+}\n+\n /* Return true if LAT1 and LAT2 are equal.  */\n static inline bool\n ipcp_lats_are_equal (struct ipcp_lattice *lat1, struct ipcp_lattice *lat2)\n@@ -247,9 +259,7 @@ static void\n ipcp_lattice_from_jfunc (struct ipa_node_params *info, struct ipcp_lattice *lat,\n \t\t\t struct ipa_jump_func *jfunc)\n {\n-  if (jfunc->type == IPA_UNKNOWN)\n-    lat->type = IPA_BOTTOM;\n-  else if (jfunc->type == IPA_CONST)\n+  if (jfunc->type == IPA_CONST)\n     {\n       lat->type = IPA_CONST_VALUE;\n       lat->constant = jfunc->value.constant;\n@@ -267,6 +277,8 @@ ipcp_lattice_from_jfunc (struct ipa_node_params *info, struct ipcp_lattice *lat,\n       lat->type = caller_lat->type;\n       lat->constant = caller_lat->constant;\n     }\n+  else\n+    lat->type = IPA_BOTTOM;\n }\n \n /* True when OLD and NEW values are not the same.  */\n@@ -303,17 +315,18 @@ ipcp_print_all_lattices (FILE * f)\n       for (i = 0; i < count; i++)\n \t{\n \t  struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n+\n+\t  fprintf (f, \" param [%d]: \", i);\n \t  if (lat->type == IPA_CONST_VALUE || lat->type == IPA_CONST_VALUE_REF)\n \t    {\n-\t      fprintf (f, \" param [%d]: \", i);\n \t      fprintf (f, \"type is CONST \");\n \t      print_generic_expr (f, lat->constant, 0);\n \t      fprintf (f, \"\\n\");\n \t    }\n \t  else if (lat->type == IPA_TOP)\n-\t    fprintf (f, \"param [%d]: type is TOP  \\n\", i);\n+\t    fprintf (f, \"type is TOP\\n\");\n \t  else\n-\t    fprintf (f, \"param [%d]: type is BOTTOM  \\n\", i);\n+\t    fprintf (f, \"type is BOTTOM\\n\");\n \t}\n     }\n }\n@@ -551,58 +564,6 @@ ipcp_node_not_modifiable_p (struct cgraph_node *node)\n   return false;\n }\n \n-/* Print ipa_jump_func data structures to F.  */\n-static void\n-ipcp_print_all_jump_functions (FILE * f)\n-{\n-  struct cgraph_node *node;\n-  int i, count;\n-  struct cgraph_edge *cs;\n-  struct ipa_jump_func *jump_func;\n-  enum jump_func_type type;\n-  tree info_type;\n-\n-  fprintf (f, \"\\nCALLSITE PARAM PRINT\\n\");\n-  for (node = cgraph_nodes; node; node = node->next)\n-    {\n-      if (!node->analyzed)\n-\tcontinue;\n-\n-      for (cs = node->callees; cs; cs = cs->next_callee)\n-\t{\n-\t  fprintf (f, \"callsite  %s \", cgraph_node_name (node));\n-\t  fprintf (f, \"-> %s :: \\n\", cgraph_node_name (cs->callee));\n-\n-\t  if (!ipa_edge_args_info_available_for_edge_p (cs)\n-\t      || ipa_is_called_with_var_arguments (IPA_NODE_REF (cs->callee)))\n-\t    continue;\n-\n-\t  count = ipa_get_cs_argument_count (IPA_EDGE_REF (cs));\n-\t  for (i = 0; i < count; i++)\n-\t    {\n-\t      jump_func = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n-\t      type = jump_func->type;\n-\n-\t      fprintf (f, \" param %d: \", i);\n-\t      if (type == IPA_UNKNOWN)\n-\t\tfprintf (f, \"UNKNOWN\\n\");\n-\t      else if (type == IPA_CONST || type == IPA_CONST_REF)\n-\t\t{\n-\t\t  info_type = jump_func->value.constant;\n-\t\t  fprintf (f, \"CONST : \");\n-\t\t  print_generic_expr (f, info_type, 0);\n-\t\t  fprintf (f, \"\\n\");\n-\t\t}\n-\t      else if (type == IPA_PASS_THROUGH)\n-\t\t{\n-\t\t  fprintf (f, \"PASS THROUGH : \");\n-\t\t  fprintf (f, \"%d\\n\", jump_func->value.formal_id);\n-\t\t}\n-\t    }\n-\t}\n-    }\n-}\n-\n /* Print count scale data structures.  */\n static void\n ipcp_function_scale_print (FILE * f)\n@@ -664,7 +625,7 @@ ipcp_print_edge_profiles (FILE * f)\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       fprintf (f, \"function %s: \\n\", cgraph_node_name (node));\n-      if (DECL_SAVED_TREE (node->decl))\n+      if (node->analyzed)\n \t{\n \t  bb =\n \t    ENTRY_BLOCK_PTR_FOR_FUNCTION (DECL_STRUCT_FUNCTION (node->decl));\n@@ -751,8 +712,8 @@ ipcp_print_all_structures (FILE * f)\n   ipcp_print_all_lattices (f);\n   ipcp_function_scale_print (f);\n   ipa_print_all_tree_maps (f);\n-  ipa_print_all_params_modified (f);\n-  ipcp_print_all_jump_functions (f);\n+  ipa_print_all_param_flags (f);\n+  ipa_print_all_jump_functions (f);\n }\n \n /* Print profile info for all functions.  */\n@@ -781,10 +742,8 @@ ipcp_create_replace_map (struct function *func, tree parm_tree,\n   tree const_val;\n \n   replace_map = XCNEW (struct ipa_replace_map);\n-  gcc_assert (ipcp_lat_is_const (lat));\n-  if (lat->type != IPA_CONST_VALUE_REF\n-      && is_gimple_reg (parm_tree) && gimple_default_def (func, parm_tree)\n-\t&& !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_default_def (func,\n+  if (is_gimple_reg (parm_tree) && gimple_default_def (func, parm_tree)\n+      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_default_def (func,\n \t\t\t\t\t\t\t\t parm_tree)))\n     {\n       if (dump_file)\n@@ -944,7 +903,7 @@ ipcp_insert_stage (void)\n       for (i = 0; i < count; i++)\n \t{\n \t  struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n-\t  if (ipcp_lat_is_const (lat))\n+\t  if (ipcp_lat_is_insertable (lat))\n \t    const_param++;\n \t}\n       if (const_param == 0)\n@@ -953,7 +912,8 @@ ipcp_insert_stage (void)\n       for (i = 0; i < count; i++)\n \t{\n \t  struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n-\t  if (ipcp_lat_is_const (lat))\n+\t  if (lat->type == IPA_CONST_VALUE\n+\t      && !POINTER_TYPE_P (TREE_TYPE (lat->constant)))\n \t    {\n \t      parm_tree = ipa_get_ith_param (info, i);\n \t      replace_param =\n@@ -990,7 +950,7 @@ ipcp_insert_stage (void)\n \t  for (i = 0; i < count; i++)\n \t    {\n \t      struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n-\t      if (ipcp_lat_is_const (lat))\n+\t      if (ipcp_lat_is_insertable (lat))\n \t\t{\n \t\t  parm_tree = ipa_get_ith_param (info, i);\n \t\t  if (lat->type != IPA_CONST_VALUE_REF"}, {"sha": "3683ec772ac5b1adbbadcba4245037a37cee9b89", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 79, "deletions": 3, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=3e293154d69acf16281d5b9b038ca741c1cf53d6", "patch": "@@ -139,6 +139,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ggc.h\"\n #include \"tree-flow.h\"\n #include \"rtl.h\"\n+#include \"ipa-prop.h\"\n \n /* Mode incremental inliner operate on:\n \n@@ -660,10 +661,12 @@ lookup_recursive_calls (struct cgraph_node *node, struct cgraph_node *where,\n }\n \n /* Decide on recursive inlining: in the case function has recursive calls,\n-   inline until body size reaches given argument.  */\n+   inline until body size reaches given argument.  If any new indirect edges\n+   are discovered in the process, add them to NEW_EDGES, unless it is NULL.  */\n \n static bool\n-cgraph_decide_recursive_inlining (struct cgraph_node *node)\n+cgraph_decide_recursive_inlining (struct cgraph_node *node,\n+\t\t\t\t  VEC (cgraph_edge_p, heap) *new_edges)\n {\n   int limit = PARAM_VALUE (PARAM_MAX_INLINE_INSNS_RECURSIVE_AUTO);\n   int max_depth = PARAM_VALUE (PARAM_MAX_INLINE_RECURSIVE_DEPTH_AUTO);\n@@ -760,6 +763,8 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node)\n \t}\n       cgraph_redirect_edge_callee (curr, master_clone);\n       cgraph_mark_inline_edge (curr, false);\n+      if (flag_indirect_inlining)\n+\tipa_propagate_indirect_call_infos (curr, new_edges);\n       lookup_recursive_calls (node, curr->callee, heap);\n       n++;\n     }\n@@ -817,6 +822,20 @@ compute_max_insns (int insns)\n \t  * (100 + PARAM_VALUE (PARAM_INLINE_UNIT_GROWTH)) / 100);\n }\n \n+/* Compute badness of all edges in NEW_EDGES and add them to the HEAP.  */\n+static void\n+add_new_edges_to_heap (fibheap_t heap, VEC (cgraph_edge_p, heap) *new_edges)\n+{\n+  while (VEC_length (cgraph_edge_p, new_edges) > 0)\n+    {\n+      struct cgraph_edge *edge = VEC_pop (cgraph_edge_p, new_edges);\n+\n+      gcc_assert (!edge->aux);\n+      edge->aux = fibheap_insert (heap, cgraph_edge_badness (edge), edge);\n+    }\n+}\n+\n+\n /* We use greedy algorithm for inlining of small functions:\n    All inline candidates are put into prioritized heap based on estimated\n    growth of the overall number of instructions and then update the estimates.\n@@ -833,6 +852,10 @@ cgraph_decide_inlining_of_small_functions (void)\n   fibheap_t heap = fibheap_new ();\n   bitmap updated_nodes = BITMAP_ALLOC (NULL);\n   int min_insns, max_insns;\n+  VEC (cgraph_edge_p, heap) *new_indirect_edges = NULL;\n+\n+  if (flag_indirect_inlining)\n+    new_indirect_edges = VEC_alloc (cgraph_edge_p, heap, 8);\n \n   if (dump_file)\n     fprintf (dump_file, \"\\nDeciding on smaller functions:\\n\");\n@@ -968,8 +991,10 @@ cgraph_decide_inlining_of_small_functions (void)\n \t  where = edge->caller;\n \t  if (where->global.inlined_to)\n \t    where = where->global.inlined_to;\n-\t  if (!cgraph_decide_recursive_inlining (where))\n+\t  if (!cgraph_decide_recursive_inlining (where, new_indirect_edges))\n \t    continue;\n+\t  if (flag_indirect_inlining)\n+\t    add_new_edges_to_heap (heap, new_indirect_edges);\n           update_callee_keys (heap, where, updated_nodes);\n \t}\n       else\n@@ -986,6 +1011,11 @@ cgraph_decide_inlining_of_small_functions (void)\n \t    }\n \t  callee = edge->callee;\n \t  cgraph_mark_inline_edge (edge, true);\n+\t  if (flag_indirect_inlining)\n+\t    {\n+\t      ipa_propagate_indirect_call_infos (edge, new_indirect_edges);\n+\t      add_new_edges_to_heap (heap, new_indirect_edges);\n+\t    }\n \t  update_callee_keys (heap, callee, updated_nodes);\n \t}\n       where = edge->caller;\n@@ -1028,6 +1058,9 @@ cgraph_decide_inlining_of_small_functions (void)\n \t\t\t\t           &edge->inline_failed))\n \tedge->inline_failed = N_(\"--param inline-unit-growth limit reached\");\n     }\n+\n+  if (new_indirect_edges)\n+    VEC_free (cgraph_edge_p, heap, new_indirect_edges);\n   fibheap_delete (heap);\n   BITMAP_FREE (updated_nodes);\n }\n@@ -1112,6 +1145,8 @@ cgraph_decide_inlining (void)\n \t      continue;\n \t    }\n \t  cgraph_mark_inline_edge (e, true);\n+\t  if (flag_indirect_inlining)\n+\t    ipa_propagate_indirect_call_infos (e, NULL);\n \t  if (dump_file)\n \t    fprintf (dump_file, \n \t\t     \" Inlined into %s which now has %i insns.\\n\",\n@@ -1133,6 +1168,11 @@ cgraph_decide_inlining (void)\n   if (!flag_really_no_inline)\n     cgraph_decide_inlining_of_small_functions ();\n \n+  /* After this point, any edge discovery performed by indirect inlining is no\n+     good so let's give up. */\n+  if (flag_indirect_inlining)\n+    free_all_ipa_structures_after_iinln ();\n+\n   if (!flag_really_no_inline\n       && flag_inline_functions_called_once)\n     {\n@@ -1612,6 +1652,31 @@ struct gimple_opt_pass pass_inline_parameters =\n  }\n };\n \n+/* This function performs intraprocedural analyzis in NODE that is required to\n+   inline indirect calls.  */\n+static void\n+inline_indirect_intraprocedural_analysis (struct cgraph_node *node)\n+{\n+  struct cgraph_edge *cs;\n+\n+  ipa_count_formal_params (node);\n+  ipa_create_param_decls_array (node);\n+  ipa_detect_param_modifications (node);\n+  ipa_analyze_params_uses (node);\n+\n+  if (dump_file)\n+    ipa_print_node_param_flags (dump_file, node);\n+\n+  for (cs = node->callees; cs; cs = cs->next_callee)\n+    {\n+      ipa_count_arguments (cs);\n+      ipa_compute_jump_functions (cs);\n+    }\n+\n+  if (dump_file)\n+    ipa_print_node_jump_functions (dump_file, node);\n+}\n+\n /* Note function body size.  */\n static void\n inline_generate_summary (void)\n@@ -1621,6 +1686,13 @@ inline_generate_summary (void)\n   int nnodes = cgraph_postorder (order);\n   int i;\n \n+  if (flag_indirect_inlining)\n+    {\n+      ipa_register_cgraph_hooks ();\n+      ipa_check_create_node_params ();\n+      ipa_check_create_edge_args ();\n+    }\n+\n   for (i = nnodes - 1; i >= 0; i--)\n     {\n       struct cgraph_node *node = order[i];\n@@ -1632,6 +1704,10 @@ inline_generate_summary (void)\n \t  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n \t  current_function_decl = node->decl;\n \t  compute_inline_parameters (node);\n+\n+\t  if (flag_indirect_inlining)\n+\t    inline_indirect_intraprocedural_analysis (node);\n+\n \t  pop_cfun ();\n \t}\n     }"}, {"sha": "1476d2eccca4a348a431a4792084750a819ccfd3", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 873, "deletions": 154, "changes": 1027, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=3e293154d69acf16281d5b9b038ca741c1cf53d6", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"timevar.h\"\n #include \"flags.h\"\n+#include \"diagnostic.h\"\n \n /* Vector where the parameter infos are actually stored. */\n VEC (ipa_node_params_t, heap) *ipa_node_params_vector;\n@@ -117,6 +118,9 @@ ipa_create_param_decls_array (struct cgraph_node *mt)\n   int param_num;\n   struct ipa_node_params *info = IPA_NODE_REF (mt);\n \n+  if (info->param_decls)\n+    return;\n+\n   info->param_decls = XCNEWVEC (tree, ipa_get_param_count (info));\n   fndecl = mt->decl;\n   fnargs = DECL_ARGUMENTS (fndecl);\n@@ -146,95 +150,84 @@ ipa_count_formal_params (struct cgraph_node *mt)\n   ipa_set_param_count (IPA_NODE_REF (mt), param_num);\n }\n \n-/* Check STMT to detect whether a formal is modified within MT, the appropriate\n-   entry is updated in the modified_flags array of ipa_node_params (associated\n-   with MT).  */\n+/* Check STMT to detect whether a formal parameter is directly modified within\n+   STMT, the appropriate entry is updated in the modified flags of INFO.\n+   Directly means that this function does not check for modifications through\n+   pointers or escaping addresses because all TREE_ADDRESSABLE parameters are\n+   considered modified anyway.  */\n static void\n-ipa_check_stmt_modifications (struct cgraph_node *mt, tree stmt)\n+ipa_check_stmt_modifications (struct ipa_node_params *info, tree stmt)\n {\n-  int index, j;\n-  tree parm_decl;\n-  struct ipa_node_params *info;\n+  int j;\n+  int index;\n+  tree lhs;\n \n   switch (TREE_CODE (stmt))\n     {\n     case GIMPLE_MODIFY_STMT:\n-\t  if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == PARM_DECL)\n-\t{\n-\t  info = IPA_NODE_REF (mt);\n-\t  parm_decl = GIMPLE_STMT_OPERAND (stmt, 0);\n-\t  index = ipa_get_param_decl_index (info, parm_decl);\n-\t  if (index >= 0)\n-\t    info->modified_flags[index] = true;\n-\t}\n+      lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+\n+      while (handled_component_p (lhs))\n+\tlhs = TREE_OPERAND (lhs, 0);\n+      if (TREE_CODE (lhs) == SSA_NAME)\n+\tlhs = SSA_NAME_VAR (lhs);\n+      index = ipa_get_param_decl_index (info, lhs);\n+      if (index >= 0)\n+\tinfo->param_flags[index].modified = true;\n       break;\n+\n     case ASM_EXPR:\n       /* Asm code could modify any of the parameters.  */\n-      info = IPA_NODE_REF (mt);\n-      for (j = 0; j < ipa_get_param_count (IPA_NODE_REF (mt)); j++)\n-\tinfo->modified_flags[j] = true;\n+      for (j = 0; j < ipa_get_param_count (info); j++)\n+\tinfo->param_flags[j].modified = true;\n       break;\n+\n     default:\n       break;\n     }\n }\n \n-/* The modify computation driver for MT. Compute which formal arguments \n-   of function MT are locally modified.  Formals may be modified in MT\n-   if their address is taken, or if\n-   they appear on the left hand side of an assignment.  */\n+/* Compute which formal parameters of function associated with NODE are locally\n+   modified.  Parameters may be modified in NODE if they are TREE_ADDRESSABLE,\n+   if they appear on the left hand side of an assignment or if there is an\n+   ASM_EXPR in the function.  */\n void\n-ipa_detect_param_modifications (struct cgraph_node *mt)\n+ipa_detect_param_modifications (struct cgraph_node *node)\n {\n-  tree decl;\n-  tree body;\n-  int j, count;\n+  tree decl = node->decl;\n   basic_block bb;\n   struct function *func;\n   block_stmt_iterator bsi;\n-  tree stmt, parm_tree;\n-  struct ipa_node_params *info = IPA_NODE_REF (mt);\n+  tree stmt;\n+  struct ipa_node_params *info = IPA_NODE_REF (node);\n+  int i, count;\n \n-  if (ipa_get_param_count (info) == 0 || info->modified_flags)\n+  if (ipa_get_param_count (info) == 0 || info->modification_analysis_done)\n     return;\n \n-  count = ipa_get_param_count (info);\n-  info->modified_flags = XCNEWVEC (bool, count);\n-  decl = mt->decl;\n-  /* ??? Handle pending sizes case. Set all parameters \n-     of the function to be modified.  */\n+  if (!info->param_flags)\n+    info->param_flags = XCNEWVEC (struct ipa_param_flags,\n+\t\t\t\t  ipa_get_param_count (info));\n \n-  if (DECL_UNINLINABLE (decl))\n-    {\n-      for (j = 0; j < count; j++)\n-\tinfo->modified_flags[j] = true;\n-\n-      return;\n-    }\n-  /* Formals whose address is taken are considered modified.  */\n-  for (j = 0; j < count; j++)\n-    {\n-      parm_tree = ipa_get_ith_param (info, j);\n-      if (!is_gimple_reg (parm_tree) \n-\t  && TREE_ADDRESSABLE (parm_tree))\n-\tinfo->modified_flags[j] = true;\n-    }\n-  body = DECL_SAVED_TREE (decl);\n-  if (body != NULL)\n+  func = DECL_STRUCT_FUNCTION (decl);\n+  FOR_EACH_BB_FN (bb, func)\n     {\n-      func = DECL_STRUCT_FUNCTION (decl);\n-      FOR_EACH_BB_FN (bb, func)\n-      {\n-\tfor (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\t  {\n-\t    stmt = bsi_stmt (bsi);\n-\t    ipa_check_stmt_modifications (mt, stmt);\n-\t  }\n-      }\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t{\n+\t  stmt = bsi_stmt (bsi);\n+\t  ipa_check_stmt_modifications (info, stmt);\n+\t}\n     }\n+\n+  count = ipa_get_param_count (info);\n+  for (i = 0; i < count; i++)\n+    if (TREE_ADDRESSABLE (ipa_get_ith_param (info, i)))\n+      info->param_flags[i].modified = true;\n+\n+  info->modification_analysis_done = 1;\n }\n \n-/* Count number of arguments callsite CS has and store it in \n+/* Count number of arguments callsite CS has and store it in\n    ipa_edge_args structure corresponding to this callsite.  */\n void\n ipa_count_arguments (struct cgraph_edge *cs)\n@@ -248,91 +241,780 @@ ipa_count_arguments (struct cgraph_edge *cs)\n   ipa_set_cs_argument_count (IPA_EDGE_REF (cs), arg_num);\n }\n \n-/* Compute jump function for all arguments of callsite CS \n-   and insert the information in the jump_functions array\n-   in the ipa_edge_args corresponding to this callsite.  */\n+/* The following function prints the jump functions of all arguments on all\n+   call graph edges going from NODE to file F.  */\n void\n-ipa_compute_jump_functions (struct cgraph_edge *cs)\n+ipa_print_node_jump_functions (FILE *f, struct cgraph_node *node)\n {\n-  tree call_tree;\n-  tree arg, cst_decl;\n-  int arg_num;\n-  struct cgraph_node *mt;\n-  tree parm_decl;\n-  struct function *curr_cfun;\n-  call_expr_arg_iterator iter;\n-  struct ipa_edge_args *args = IPA_EDGE_REF (cs);\n+  int i, count;\n+  struct cgraph_edge *cs;\n+  struct ipa_jump_func *jump_func;\n+  enum jump_func_type type;\n \n-  if (ipa_get_cs_argument_count (args) == 0 || args->jump_functions)\n-    return;\n-  args->jump_functions = XCNEWVEC (struct ipa_jump_func,\n-\t\t\t\t   ipa_get_cs_argument_count (args));\n-  call_tree = get_call_expr_in (cs->call_stmt);\n-  gcc_assert (TREE_CODE (call_tree) == CALL_EXPR);\n-  arg_num = 0;\n+  fprintf (f, \"JUMP FUNCTIONS OF CALLER  %s:\\n\", cgraph_node_name (node));\n+  for (cs = node->callees; cs; cs = cs->next_callee)\n+    {\n+      if (!ipa_edge_args_info_available_for_edge_p (cs))\n+\tcontinue;\n+\n+      fprintf (f, \"callsite  %s \", cgraph_node_name (node));\n+      fprintf (f, \"-> %s :: \\n\", cgraph_node_name (cs->callee));\n \n-  FOR_EACH_CALL_EXPR_ARG (arg, iter, call_tree)\n+      count = ipa_get_cs_argument_count (IPA_EDGE_REF (cs));\n+      for (i = 0; i < count; i++)\n+\t{\n+\t  jump_func = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n+\t  type = jump_func->type;\n+\n+\t  fprintf (f, \"  param %d: \", i);\n+\t  if (type == IPA_UNKNOWN)\n+\t    fprintf (f, \"UNKNOWN\\n\");\n+\t  else if (type == IPA_CONST || type == IPA_CONST_REF)\n+ \t    {\n+\t      tree val = jump_func->value.constant;\n+\t      fprintf (f, \"CONST: \");\n+\t      print_generic_expr (f, val, 0);\n+\t      fprintf (f, \"\\n\");\n+\t    }\n+\t  else if (type == IPA_CONST_MEMBER_PTR)\n+\t    {\n+\t      fprintf (f, \"CONST MEMBER PTR: \");\n+\t      print_generic_expr (f, jump_func->value.member_cst.pfn, 0);\n+\t      fprintf (f, \", \");\n+\t      print_generic_expr (f, jump_func->value.member_cst.delta, 0);\n+\t      fprintf (f, \"\\n\");\n+\t    }\n+\t  else if (type == IPA_PASS_THROUGH)\n+ \t    {\n+\t      fprintf (f, \"PASS THROUGH: \");\n+\t      fprintf (f, \"%d\\n\", jump_func->value.formal_id);\n+ \t    }\n+\t}\n+    }\n+}\n+\n+/* Print ipa_jump_func data structures of all nodes in the call graph to F.  */\n+void\n+ipa_print_all_jump_functions (FILE *f)\n+{\n+  struct cgraph_node *node;\n+\n+  fprintf (f, \"\\nCALLSITE PARAM PRINT\\n\");\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      ipa_print_node_jump_functions (f, node);\n+    }\n+}\n+\n+/* The following function determines the jump functions of scalar arguments.\n+   Scalar means SSA names and constants of a number of selected types.  INFO is\n+   the ipa_node_params structure associated with the caller, FUNCTIONS is a\n+   pointer to an array of jump function structures associated with CALL which\n+   is the call statement being examined.*/\n+static void\n+compute_scalar_jump_functions (struct ipa_node_params *info,\n+\t\t\t       struct ipa_jump_func *functions,\n+\t\t\t       tree call)\n+{\n+  call_expr_arg_iterator iter;\n+  tree arg;\n+  int num = 0;\n+\n+  FOR_EACH_CALL_EXPR_ARG (arg, iter, call)\n     {\n-      /* If the formal parameter was passed as argument, we store \n-         IPA_PASS_THROUGH and its index in the caller as the jump function\n-         of this argument.  */\n-      if ((TREE_CODE (arg) == SSA_NAME\n-\t   && TREE_CODE (SSA_NAME_VAR (arg)) == PARM_DECL)\n-\t  || TREE_CODE (arg) == PARM_DECL)\n+      if (TREE_CODE (arg) == INTEGER_CST\n+\t  || TREE_CODE (arg) == REAL_CST\n+\t  || TREE_CODE (arg) == FIXED_CST)\n \t{\n-\t  struct ipa_node_params *info;\n-\t  int index;\n-\n-\t  mt = cs->caller;\n-\t  info = IPA_NODE_REF (mt);\n-\t  parm_decl = TREE_CODE (arg) == PARM_DECL ? arg : SSA_NAME_VAR (arg);\n-          \n-\t  index = ipa_get_param_decl_index (info, parm_decl);\n-\t  if (TREE_CODE (arg) == SSA_NAME && IS_VALID_JUMP_FUNC_INDEX (index))\n+\t  functions[num].type = IPA_CONST;\n+\t  functions[num].value.constant = arg;\n+\t}\n+      else if (TREE_CODE (arg) == ADDR_EXPR)\n+\t{\n+\t  if (TREE_CODE (TREE_OPERAND (arg, 0)) == FUNCTION_DECL)\n \t    {\n-\t      curr_cfun = DECL_STRUCT_FUNCTION (mt->decl);\n-\t      if (!gimple_default_def (curr_cfun, parm_decl) \n-\t          || gimple_default_def (curr_cfun, parm_decl) != arg)\n-\t\tinfo->modified_flags[index] = true;\n+\t      functions[num].type = IPA_CONST;\n+\t      functions[num].value.constant = TREE_OPERAND (arg, 0);\n \t    }\n-\t  if (!IS_VALID_JUMP_FUNC_INDEX (index) || info->modified_flags[index])\n-\t    args->jump_functions[arg_num].type = IPA_UNKNOWN;\n-\t  else\n+\t  else if (TREE_CODE (TREE_OPERAND (arg, 0)) == CONST_DECL)\n+\t    {\n+\t      tree cst_decl = TREE_OPERAND (arg, 0);\n+\n+\t      if (TREE_CODE (DECL_INITIAL (cst_decl)) == INTEGER_CST\n+\t\t  || TREE_CODE (DECL_INITIAL (cst_decl)) == REAL_CST\n+\t\t  || TREE_CODE (DECL_INITIAL (cst_decl)) == FIXED_CST)\n+\t\t{\n+\t\t  functions[num].type = IPA_CONST_REF;\n+\t\t  functions[num].value.constant = cst_decl;\n+\t\t}\n+\t    }\n+ \t}\n+      else if ((TREE_CODE (arg) == SSA_NAME) && SSA_NAME_IS_DEFAULT_DEF (arg))\n+\t{\n+\t  int index = ipa_get_param_decl_index (info, SSA_NAME_VAR (arg));\n+\n+\t  if (index >= 0)\n \t    {\n-\t      args->jump_functions[arg_num].type = IPA_PASS_THROUGH;\n-\t      args->jump_functions[arg_num].value.formal_id = index;\n+\t      functions[num].type = IPA_PASS_THROUGH;\n+\t      functions[num].value.formal_id = index;\n \t    }\n \t}\n-      /* If a constant value was passed as argument, \n-         we store IPA_CONST and its value as the jump function\n-         of this argument.  */\n-      else if (TREE_CODE (arg) == INTEGER_CST\n-\t       || TREE_CODE (arg) == REAL_CST\n-\t       || TREE_CODE (arg) == FIXED_CST)\n+\n+      num++;\n+    }\n+}\n+\n+/* This function inspects the given TYPE and returns true iff it has the same\n+   structure (the same number of fields of the same types) as a C++ member\n+   pointer.  If METHOD_PTR and DELTA are non-NULL, the trees representing the\n+   corresponding fields are stored there.  */\n+static bool\n+type_like_member_ptr_p (tree type, tree *method_ptr, tree *delta)\n+{\n+  tree fld;\n+\n+  if (TREE_CODE (type) != RECORD_TYPE)\n+    return false;\n+\n+  fld = TYPE_FIELDS (type);\n+  if (!fld || !POINTER_TYPE_P (TREE_TYPE (fld))\n+      || TREE_CODE (TREE_TYPE (TREE_TYPE (fld))) != METHOD_TYPE)\n+    return false;\n+\n+  if (method_ptr)\n+    *method_ptr = fld;\n+\n+  fld = TREE_CHAIN (fld);\n+  if (!fld || INTEGRAL_TYPE_P (fld))\n+    return false;\n+  if (delta)\n+    *delta = fld;\n+\n+  if (TREE_CHAIN (fld))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* This function goes through arguments of the CALL and for every one that\n+   looks like a member pointer, it checks whether it can be safely declared\n+   pass-through and if so, marks that to the corresponding item of jum\n+   FUNCTIONS .  It returns true iff there were non-pass-through member pointers\n+   within the arguments.  INFO describes formal parameters of the caller.  */\n+static bool\n+compute_pass_through_member_ptrs (struct ipa_node_params *info,\n+\t\t\t\t  struct ipa_jump_func *functions,\n+\t\t\t\t  tree call)\n+{\n+  call_expr_arg_iterator iter;\n+  bool undecided_members = false;\n+  int num = 0;\n+  tree arg;\n+\n+  FOR_EACH_CALL_EXPR_ARG (arg, iter, call)\n+    {\n+      if (type_like_member_ptr_p (TREE_TYPE (arg), NULL, NULL))\n \t{\n-\t  args->jump_functions[arg_num].type = IPA_CONST;\n-\t  args->jump_functions[arg_num].value.constant = arg;\n+\t  if (TREE_CODE (arg) == PARM_DECL)\n+\t    {\n+\t      int index = ipa_get_param_decl_index (info, arg);\n+\n+\t      gcc_assert (index >=0);\n+\t      if (!ipa_is_ith_param_modified (info, index))\n+\t\t{\n+\t\t  functions[num].type = IPA_PASS_THROUGH;\n+\t\t  functions[num].value.formal_id = index;\n+\t\t}\n+\t      else\n+\t\tundecided_members = true;\n+\t    }\n+\t  else\n+\t    undecided_members = true;\n \t}\n-      /* This is for the case of Fortran. If the address of a const_decl \n-         was passed as argument then we store\n-         IPA_CONST_REF/IPA_CONST_REF and the constant\n-         value as the jump function corresponding to this argument.  */\n-      else if (TREE_CODE (arg) == ADDR_EXPR\n-\t       && TREE_CODE (TREE_OPERAND (arg, 0)) == CONST_DECL)\n+\n+      num++;\n+    }\n+\n+  return undecided_members;\n+}\n+\n+/* Simple function filling in a member pointer constant jump function (with PFN\n+   and DELTA as the constant value) into JFUNC.  */\n+static void\n+fill_member_ptr_cst_jump_function (struct ipa_jump_func *jfunc,\n+\t\t\t\t   tree pfn, tree delta)\n+{\n+  jfunc->type = IPA_CONST_MEMBER_PTR;\n+  jfunc->value.member_cst.pfn = pfn;\n+  jfunc->value.member_cst.delta = delta;\n+}\n+\n+/* Traverse statements from CALL_STMT backwards, scanning whether the argument\n+   ARG which is a member pointer is filled in with constant values.  If it is,\n+   fill the jump function JFUNC in appropriately.  METHOD_FIELD and DELTA_FIELD\n+   are fields of the record type of the member pointer.  To give an example, we\n+   look for a pattern looking like the following:  \n+\n+     D.2515.__pfn ={v} printStuff;\n+     D.2515.__delta ={v} 0;\n+     i_1 = doprinting (D.2515);  */\n+static void\n+determine_cst_member_ptr (tree call_stmt, tree arg, tree method_field,\n+\t\t\t  tree delta_field, struct ipa_jump_func *jfunc)\n+{\n+  block_stmt_iterator bsi;\n+  tree method = NULL_TREE;\n+  tree delta = NULL_TREE;\n+\n+  bsi = bsi_for_stmt (call_stmt);\n+\n+  bsi_prev (&bsi);\n+  for (; !bsi_end_p (bsi); bsi_prev (&bsi))\n+    {\n+      tree stmt = bsi_stmt (bsi);\n+      tree lhs, rhs, fld;\n+\n+      if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n+\treturn;\n+\n+      rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n+      if (TREE_CODE (rhs) == CALL_EXPR)\n+\treturn;\n+\n+      lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+\n+      if (TREE_CODE (lhs) != COMPONENT_REF\n+\t  || TREE_OPERAND (lhs, 0) != arg)\n+\tcontinue;\n+\n+      fld = TREE_OPERAND (lhs, 1);\n+      if (!method && fld == method_field)\n \t{\n-\t  cst_decl = TREE_OPERAND (arg, 0);\n-\t  if (TREE_CODE (DECL_INITIAL (cst_decl)) == INTEGER_CST\n-\t      || TREE_CODE (DECL_INITIAL (cst_decl)) == REAL_CST\n-\t      || TREE_CODE (DECL_INITIAL (cst_decl)) == FIXED_CST)\n+\t  if (TREE_CODE (rhs) == ADDR_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (rhs, 0)) == FUNCTION_DECL\n+\t      && TREE_CODE (TREE_TYPE (TREE_OPERAND (rhs, 0))) == METHOD_TYPE)\n \t    {\n-\t      args->jump_functions[arg_num].type = IPA_CONST_REF;\n-\t      args->jump_functions[arg_num].value.constant = cst_decl;\n+\t      method = TREE_OPERAND (rhs, 0);\n+\t      if (delta)\n+\t\t{\n+\t\t  fill_member_ptr_cst_jump_function (jfunc, method, delta);\n+\t\t  return;\n+\t\t}\n \t    }\n+\t  else\n+\t    return;\n+\t}\n+\n+      if (!delta && fld == delta_field)\n+\t{\n+\t  if (TREE_CODE (rhs) == INTEGER_CST)\n+\t    {\n+\t      delta = rhs;\n+\t      if (method)\n+\t\t{\n+\t\t  fill_member_ptr_cst_jump_function (jfunc, method, delta);\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t  else\n+\t    return;\n+\t}\n+    }\n+\n+  return;\n+}\n+\n+/* Go through the arguments of the call in CALL_STMT and for every member\n+   pointer within tries determine whether it is a constant.  If it is, create a\n+   corresponding constant jump function in FUNCTIONS which is an array of jump\n+   functions associated with the call.  */\n+static void\n+compute_cst_member_ptr_arguments (struct ipa_jump_func *functions,\n+\t\t\t\t  tree call_stmt)\n+{\n+  call_expr_arg_iterator iter;\n+  int num = 0;\n+  tree call = get_call_expr_in (call_stmt);\n+  tree arg, method_field, delta_field;\n+\n+  FOR_EACH_CALL_EXPR_ARG (arg, iter, call)\n+    {\n+      if (functions[num].type == IPA_UNKNOWN\n+\t  && type_like_member_ptr_p (TREE_TYPE (arg), &method_field,\n+\t\t\t\t     &delta_field))\n+\tdetermine_cst_member_ptr (call_stmt, arg, method_field,\n+\t\t\t\t  delta_field, &functions[num]);\n+\n+      num++;\n+    }\n+}\n+\n+/* Compute jump function for all arguments of callsite CS and insert the\n+   information in the jump_functions array in the ipa_edge_args corresponding\n+   to this callsite.  */\n+void\n+ipa_compute_jump_functions (struct cgraph_edge *cs)\n+{\n+  struct ipa_node_params *info = IPA_NODE_REF (cs->caller);\n+  struct ipa_edge_args *arguments = IPA_EDGE_REF (cs);\n+  tree call;\n+\n+  if (ipa_get_cs_argument_count (arguments) == 0 || arguments->jump_functions)\n+    return;\n+  arguments->jump_functions = XCNEWVEC (struct ipa_jump_func,\n+\t\t\t\t\tipa_get_cs_argument_count (arguments));\n+  call = get_call_expr_in (cs->call_stmt);\n+\n+  /* We will deal with constants and SSA scalars first:  */\n+  compute_scalar_jump_functions (info, arguments->jump_functions, call);\n+\n+  /* Let's check whether there are any potential member pointers and if so,\n+     whether we can determine their functions as pass_through.  */\n+  if (!compute_pass_through_member_ptrs (info, arguments->jump_functions, call))\n+    return;\n+\n+  /* Finally, let's check whether we actually pass a new constant membeer\n+     pointer here...  */\n+  compute_cst_member_ptr_arguments (arguments->jump_functions, cs->call_stmt);\n+}\n+\n+/* If RHS looks like a rhs of a statement loading pfn from a member pointer\n+   formal parameter, return the parameter, otherwise return NULL.  */\n+static tree\n+ipa_get_member_ptr_load_param (tree rhs)\n+{\n+  tree rec, fld;\n+  tree ptr_field;\n+\n+  if (TREE_CODE (rhs) != COMPONENT_REF)\n+    return NULL_TREE;\n+\n+  rec = TREE_OPERAND (rhs, 0);\n+  if (TREE_CODE (rec) != PARM_DECL\n+      || !type_like_member_ptr_p (TREE_TYPE (rec), &ptr_field, NULL))\n+    return NULL_TREE;\n+\n+  fld = TREE_OPERAND (rhs, 1);\n+  if (fld == ptr_field)\n+    return rec;\n+  else\n+    return NULL_TREE;\n+}\n+\n+/* If STMT looks like a statement loading a value from a member pointer formal\n+   parameter, this function retuns that parameter.  */\n+static tree\n+ipa_get_stmt_member_ptr_load_param (tree stmt)\n+{\n+  tree rhs;\n+\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n+    return NULL_TREE;\n+\n+  rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n+  return ipa_get_member_ptr_load_param (rhs);\n+}\n+\n+/* Returns true iff T is an SSA_NAME defined by a statement.  */\n+static bool\n+ipa_is_ssa_with_stmt_def (tree t)\n+{\n+  if (TREE_CODE (t) == SSA_NAME\n+      && !SSA_NAME_IS_DEFAULT_DEF (t))\n+    return true;\n+  else\n+    return false;\n+}\n+\n+/* Creates a new note describing a call to a parameter number FORMAL_ID and\n+   attaches it to the linked list of INFO.  It also sets the called flag of the\n+   parameter.  STMT is the corresponding call statement.  */\n+static void\n+ipa_note_param_call (struct ipa_node_params *info, int formal_id,\n+\t\t     tree stmt)\n+{\n+  struct ipa_param_call_note *note;\n+  basic_block bb = bb_for_stmt (stmt);\n+\n+  info->param_flags[formal_id].called = 1;\n+\n+  note = XCNEW (struct ipa_param_call_note);\n+  note->formal_id = formal_id;\n+  note->stmt = stmt;\n+  note->count = bb->count;\n+  note->frequency = compute_call_stmt_bb_frequency (bb);\n+\n+  note->next = info->param_calls;\n+  info->param_calls = note;\n+\n+  return;\n+}\n+\n+/* Analyze the CALL (which itself must be a part of statement STMT) and examine\n+   uses of formal parameters of the caller (described by INFO).  Currently it\n+   checks whether the call calls a pointer that is a formal parameter and if\n+   so, the parameter is marked with the called flag and a note describing the\n+   call is created.  This is very simple for ordinary pointers represented in\n+   SSA but not-so-nice when it comes to member pointers.  The ugly part of this\n+   function does nothing more than tries to match the pattern of such a call.\n+   An example of such a pattern is the gimple dump below, the call is on the\n+   last line:\n+\n+     <bb 2>:\n+       f$__delta_5 = f.__delta;\n+       f$__pfn_24 = f.__pfn;\n+       D.2496_3 = (int) f$__pfn_24;\n+       D.2497_4 = D.2496_3 & 1;\n+       if (D.2497_4 != 0)\n+         goto <bb 3>;\n+       else\n+         goto <bb 4>;\n+\n+     <bb 3>:\n+       D.2500_7 = (unsigned int) f$__delta_5;\n+       D.2501_8 = &S + D.2500_7;\n+       D.2502_9 = (int (*__vtbl_ptr_type) (void) * *) D.2501_8;\n+       D.2503_10 = *D.2502_9;\n+       D.2504_12 = f$__pfn_24 + -1;\n+       D.2505_13 = (unsigned int) D.2504_12;\n+       D.2506_14 = D.2503_10 + D.2505_13;\n+       D.2507_15 = *D.2506_14;\n+       iftmp.11_16 = (String:: *) D.2507_15;\n+\n+     <bb 4>:\n+       # iftmp.11_1 = PHI <iftmp.11_16(3), f$__pfn_24(2)>\n+       D.2500_19 = (unsigned int) f$__delta_5;\n+       D.2508_20 = &S + D.2500_19;\n+       D.2493_21 = iftmp.11_1 (D.2508_20, 4);\n+\n+   Such patterns are results of simple calls to a member pointer:\n+\n+     int doprinting (int (MyString::* f)(int) const)\n+     {\n+       MyString S (\"somestring\");\n+\n+       return (S.*f)(4);\n+     }\n+*/\n+\n+static void\n+ipa_analyze_call_uses (struct ipa_node_params *info, tree call, tree stmt)\n+{\n+  tree target = CALL_EXPR_FN (call);\n+  tree var, def;\n+  tree n1, n2;\n+  tree d1, d2;\n+  tree rec, rec2;\n+  tree branch, cond;\n+  int index;\n+\n+  basic_block bb, virt_bb, join;\n+\n+  if (TREE_CODE (target) != SSA_NAME)\n+    return;\n+\n+  var = SSA_NAME_VAR (target);\n+  if (SSA_NAME_IS_DEFAULT_DEF (target))\n+    {\n+      /* assuming TREE_CODE (var) == PARM_DECL */\n+      index = ipa_get_param_decl_index (info, var);\n+      if (index >= 0)\n+\tipa_note_param_call (info, index, stmt);\n+      return;\n+    }\n+\n+  /* Now we need to try to match the complex pattern of calling a member\n+     pointer. */\n+\n+  if (!POINTER_TYPE_P (TREE_TYPE (target))\n+      || TREE_CODE (TREE_TYPE (TREE_TYPE (target))) != METHOD_TYPE)\n+    return;\n+\n+  def = SSA_NAME_DEF_STMT (target);\n+  if (TREE_CODE (def) != PHI_NODE)\n+    return;\n+\n+  if (PHI_NUM_ARGS (def) != 2)\n+    return;\n+\n+  /* First, we need to check whether one of these is a load from a member\n+     pointer that is a parameter to this function. */\n+  n1 = PHI_ARG_DEF (def, 0);\n+  n2 = PHI_ARG_DEF (def, 1);\n+  if (SSA_NAME_IS_DEFAULT_DEF (n1) || SSA_NAME_IS_DEFAULT_DEF (n2))\n+    return;\n+  d1 = SSA_NAME_DEF_STMT (n1);\n+  d2 = SSA_NAME_DEF_STMT (n2);\n+\n+  if ((rec = ipa_get_stmt_member_ptr_load_param (d1)))\n+    {\n+      if (ipa_get_stmt_member_ptr_load_param (d2))\n+\treturn;\n+\n+      bb = bb_for_stmt (d1);\n+      virt_bb = bb_for_stmt (d2);\n+    }\n+  else if ((rec = ipa_get_stmt_member_ptr_load_param (d2)))\n+    {\n+      bb = bb_for_stmt (d2);\n+      virt_bb = bb_for_stmt (d1);\n+    }\n+  else\n+    return;\n+\n+  /* Second, we need to check that the basic blocks are laid out in the way\n+     corresponding to the pattern. */\n+\n+  join = bb_for_stmt (def);\n+  if (!single_pred_p (virt_bb) || !single_succ_p (virt_bb)\n+      || single_pred (virt_bb) != bb\n+      || single_succ (virt_bb) != join)\n+    return;\n+\n+  /* Third, let's see that the branching is done depending on the least\n+     significant bit of the pfn. */\n+\n+  branch = last_stmt (bb);\n+  if (TREE_CODE (branch) != COND_EXPR)\n+    return;\n+\n+  cond = TREE_OPERAND (branch, 0);\n+  if (TREE_CODE (cond) != NE_EXPR\n+      || !integer_zerop (TREE_OPERAND (cond, 1)))\n+    return;\n+  cond = TREE_OPERAND (cond, 0);\n+\n+  if (!ipa_is_ssa_with_stmt_def (cond))\n+    return;\n+\n+  cond = SSA_NAME_DEF_STMT (cond);\n+  if (TREE_CODE (cond) != GIMPLE_MODIFY_STMT)\n+    return;\n+  cond = GIMPLE_STMT_OPERAND (cond, 1);\n+  if (TREE_CODE (cond) != BIT_AND_EXPR\n+      || !integer_onep (TREE_OPERAND (cond, 1)))\n+    return;\n+  cond = TREE_OPERAND (cond, 0);\n+  if (!ipa_is_ssa_with_stmt_def (cond))\n+    return;\n+\n+  cond = SSA_NAME_DEF_STMT (cond);\n+  if (TREE_CODE (cond) != GIMPLE_MODIFY_STMT)\n+    return;\n+  cond = GIMPLE_STMT_OPERAND (cond, 1);\n+\n+  if (TREE_CODE (cond) == NOP_EXPR)\n+    {\n+      cond = TREE_OPERAND (cond, 0);\n+      if (!ipa_is_ssa_with_stmt_def (cond))\n+\treturn;\n+      cond = SSA_NAME_DEF_STMT (cond);\n+      if (TREE_CODE (cond) != GIMPLE_MODIFY_STMT)\n+\treturn;\n+      cond = GIMPLE_STMT_OPERAND (cond, 1);\n+    }\n+\n+  rec2 = ipa_get_member_ptr_load_param (cond);\n+  if (rec != rec2)\n+    return;\n+\n+  index = ipa_get_param_decl_index (info, rec);\n+  if (index >= 0 && !ipa_is_ith_param_modified (info, index))\n+    ipa_note_param_call (info, index, stmt);\n+\n+  return;\n+}\n+\n+/* Analyze the statement STMT with respect to formal parameters (described in\n+   INFO) and their uses.  Currently it only checks whether formal parameters\n+   are called.  */\n+static void\n+ipa_analyze_stmt_uses (struct ipa_node_params *info, tree stmt)\n+{\n+  tree call = get_call_expr_in (stmt);\n+\n+  if (call)\n+    ipa_analyze_call_uses (info, call, stmt);\n+}\n+\n+/* Scan the function body of NODE and inspect the uses of formal parameters.\n+   Store the findings in various structures of the associated ipa_node_params\n+   structure, such as parameter flags, notes etc.  */\n+void\n+ipa_analyze_params_uses (struct cgraph_node *node)\n+{\n+  tree decl = node->decl;\n+  basic_block bb;\n+  struct function *func;\n+  block_stmt_iterator bsi;\n+  struct ipa_node_params *info = IPA_NODE_REF (node);\n+\n+  if (ipa_get_param_count (info) == 0 || info->uses_analysis_done\n+      || !DECL_SAVED_TREE (decl))\n+    return;\n+  if (!info->param_flags)\n+    info->param_flags = XCNEWVEC (struct ipa_param_flags,\n+\t\t\t\t  ipa_get_param_count (info));\n+\n+  func = DECL_STRUCT_FUNCTION (decl);\n+  FOR_EACH_BB_FN (bb, func)\n+    {\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t{\n+\t  tree stmt = bsi_stmt (bsi);\n+\t  ipa_analyze_stmt_uses (info, stmt);\n \t}\n-      else\n-\targs->jump_functions[arg_num].type = IPA_UNKNOWN;\n-      arg_num++;\n     }\n+\n+  info->uses_analysis_done = 1;\n+}\n+\n+/* Update the jump functions assocated with call graph edge E when the call\n+   graph edge CS is being inlined, assuming that E->caller is already (possibly\n+   indirectly) inlined into CS->callee and that E has not been inlined.  */\n+static void\n+update_jump_functions_after_inlining (struct cgraph_edge *cs,\n+\t\t\t\t      struct cgraph_edge *e)\n+{\n+  struct ipa_edge_args *top = IPA_EDGE_REF (cs);\n+  struct ipa_edge_args *args = IPA_EDGE_REF (e);\n+  int count = ipa_get_cs_argument_count (args);\n+  int i;\n+\n+  for (i = 0; i < count; i++)\n+    {\n+      struct ipa_jump_func *src, *dst = ipa_get_ith_jump_func (args, i);\n+\n+      if (dst->type != IPA_PASS_THROUGH)\n+\tcontinue;\n+\n+      /* We must check range due to calls with variable number of arguments:  */\n+      if (dst->value.formal_id >= (unsigned) ipa_get_cs_argument_count (top))\n+\t{\n+\t  dst->type = IPA_BOTTOM;\n+\t  continue;\n+\t}\n+\n+      src = ipa_get_ith_jump_func (top, dst->value.formal_id);\n+      *dst = *src;\n+    }\n+}\n+\n+/* Print out a debug message to file F that we have discovered that an indirect\n+   call descibed by NT is in fact a call of a known constant function descibed\n+   by JFUNC.  NODE is the node where the call is.  */\n+static void\n+print_edge_addition_message (FILE *f, struct ipa_param_call_note *nt,\n+\t\t\t     struct ipa_jump_func *jfunc,\n+\t\t\t     struct cgraph_node *node)\n+{\n+  fprintf (f, \"ipa-prop: Discovered an indirect call to a known target (\");\n+  if (jfunc->type == IPA_CONST_MEMBER_PTR)\n+    {\n+      print_node_brief (f, \"\", jfunc->value.member_cst.pfn, 0);\n+      print_node_brief (f, \", \", jfunc->value.member_cst.delta, 0);\n+    }\n+  else\n+    print_node_brief(f, \"\", jfunc->value.constant, 0);\n+\n+  fprintf (f, \") in %s: \", cgraph_node_name (node));\n+  print_generic_stmt (f, nt->stmt, 2);\n+}\n+\n+/* Update the param called notes associated with NODE when CS is being inlined,\n+   assuming NODE is (potentially indirectly) inlined into CS->callee.\n+   Moreover, if the callee is discovered to be constant, create a new cgraph\n+   edge for it.  Newly discovered indirect edges will be added to NEW_EDGES,\n+   unless it is NULL.  */\n+static void\n+update_call_notes_after_inlining (struct cgraph_edge *cs,\n+\t\t\t\t  struct cgraph_node *node,\n+\t\t\t\t  VEC (cgraph_edge_p, heap) *new_edges)\n+{\n+  struct ipa_node_params *info = IPA_NODE_REF (node);\n+  struct ipa_edge_args *top = IPA_EDGE_REF (cs);\n+  struct ipa_param_call_note *nt;\n+\n+  for (nt = info->param_calls; nt; nt = nt->next)\n+    {\n+      struct ipa_jump_func *jfunc;\n+\n+      if (nt->processed)\n+\tcontinue;\n+\n+      /* We must check range due to calls with variable number of arguments:  */\n+      if (nt->formal_id >= (unsigned) ipa_get_cs_argument_count (top))\n+\t{\n+\t  nt->processed = true;\n+\t  continue;\n+\t}\n+\n+      jfunc = ipa_get_ith_jump_func (top, nt->formal_id);\n+      if (jfunc->type == IPA_PASS_THROUGH)\n+\tnt->formal_id = jfunc->value.formal_id;\n+      else if (jfunc->type == IPA_CONST || jfunc->type == IPA_CONST_MEMBER_PTR)\n+\t{\n+\t  struct cgraph_node *callee;\n+\t  struct cgraph_edge *new_indirect_edge;\n+\t  tree decl;\n+\n+\t  nt->processed = true;\n+\t  if (jfunc->type == IPA_CONST_MEMBER_PTR)\n+\t    decl = jfunc->value.member_cst.pfn;\n+\t  else\n+\t    decl = jfunc->value.constant;\n+\n+\t  if (TREE_CODE (decl) != FUNCTION_DECL)\n+\t    continue;\n+\t  callee = cgraph_node (decl);\n+\t  if (!callee || !callee->local.inlinable)\n+\t    continue;\n+\n+\t  if (dump_file)\n+\t    print_edge_addition_message (dump_file, nt, jfunc, node);\n+\n+\t  new_indirect_edge = cgraph_create_edge (node, callee, nt->stmt,\n+\t\t\t\t\t\t  nt->count, nt->frequency,\n+\t\t\t\t\t\t  nt->loop_nest);\n+\t  new_indirect_edge->indirect_call = 1;\n+\t  ipa_check_create_edge_args ();\n+\t  if (new_edges)\n+\t    VEC_safe_push (cgraph_edge_p, heap, new_edges, new_indirect_edge);\n+\t}\n+    }\n+}\n+\n+/* Recursively traverse subtree of NODE (including node) made of inlined\n+   cgraph_edges when CS has been inlined and invoke\n+   update_call_notes_after_inlining on all nodes and\n+   update_jump_functions_after_inlining on all non-inlined edges that lead out\n+   of this subtree.  Newly discovered indirect edges will be added to\n+   NEW_EDGES, unless it is NULL.  */\n+static void\n+propagate_info_to_inlined_callees (struct cgraph_edge *cs,\n+\t\t\t\t   struct cgraph_node *node,\n+\t\t\t\t   VEC (cgraph_edge_p, heap) *new_edges)\n+{\n+  struct cgraph_edge *e;\n+\n+  update_call_notes_after_inlining (cs, node, new_edges);\n+\n+  for (e = node->callees; e; e = e->next_callee)\n+    if (!e->inline_failed)\n+      propagate_info_to_inlined_callees (cs, e->callee, new_edges);\n+    else\n+      update_jump_functions_after_inlining (cs, e);\n+}\n+\n+/* Update jump functions and call note functions on inlining the call site CS.\n+   CS is expected to lead to a node already cloned by\n+   cgraph_clone_inline_nodes.  Newly discovered indirect edges will be added to\n+   NEW_EDGES, unless it is NULL.  */\n+void\n+ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n+\t\t\t\t   VEC (cgraph_edge_p, heap) *new_edges)\n+{\n+  propagate_info_to_inlined_callees (cs, cs->callee, new_edges);\n }\n \n /* Frees all dynamically allocated structures that the argument info points\n@@ -371,8 +1053,15 @@ ipa_free_node_params_substructures (struct ipa_node_params *info)\n     free (info->ipcp_lattices);\n   if (info->param_decls)\n     free (info->param_decls);\n-  if (info->modified_flags)\n-    free (info->modified_flags);\n+  if (info->param_flags)\n+    free (info->param_flags);\n+\n+  while (info->param_calls)\n+    {\n+      struct ipa_param_call_note *note = info->param_calls;\n+      info->param_calls = note->next;\n+      free (note);\n+    }\n \n   memset (info, 0, sizeof (*info));\n }\n@@ -451,6 +1140,7 @@ ipa_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t\t\t   void *data)\n {\n   struct ipa_node_params *old_info, *new_info;\n+  struct ipa_param_call_note *note;\n   int param_count;\n \n   ipa_check_create_node_params ();\n@@ -464,12 +1154,24 @@ ipa_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t\t     sizeof (struct ipcp_lattice) * param_count);\n   new_info->param_decls = (tree *)\n     duplicate_array (old_info->param_decls, sizeof (tree) * param_count);\n-  new_info->modified_flags = (bool *)\n-    duplicate_array (old_info->modified_flags, sizeof (bool) * param_count);\n+  new_info->param_flags = (struct ipa_param_flags *)\n+    duplicate_array (old_info->param_flags,\n+\t\t     sizeof (struct ipa_param_flags) * param_count);\n \n   new_info->ipcp_orig_node = old_info->ipcp_orig_node;\n   new_info->count_scale = old_info->count_scale;\n \n+  for (note = old_info->param_calls; note; note = note->next)\n+    {\n+      struct ipa_param_call_note *nn;\n+\n+      nn = (struct ipa_param_call_note *)\n+\txcalloc (1, sizeof (struct ipa_param_call_note));\n+      memcpy (nn, note, sizeof (struct ipa_param_call_note));\n+      nn->next = new_info->param_calls;\n+      new_info->param_calls = nn;\n+    }\n+\n   data = data; \t\t\t/* Suppressing compiler warning.  */\n }\n \n@@ -509,6 +1211,19 @@ ipa_unregister_cgraph_hooks (void)\n    longer needed after ipa-cp.  */\n void\n free_all_ipa_structures_after_ipa_cp (void)\n+{\n+  if (!flag_indirect_inlining || !flag_inline_trees)\n+    {\n+      ipa_free_all_edge_args ();\n+      ipa_free_all_node_params ();\n+      ipa_unregister_cgraph_hooks ();\n+    }\n+}\n+\n+/* Free all ipa_node_params and all ipa_edge_args structures if they are no\n+   longer needed after indirect inlining.  */\n+void\n+free_all_ipa_structures_after_iinln (void)\n {\n   ipa_free_all_edge_args ();\n   ipa_free_all_node_params ();\n@@ -545,33 +1260,37 @@ ipa_print_all_tree_maps (FILE * f)\n     }\n }\n \n-/* Print modified_flags data structures of all functions in the\n-   callgraph to F.  */\n+/* Print param_flags data structures of the NODE to F.  */\n void\n-ipa_print_all_params_modified (FILE * f)\n+ipa_print_node_param_flags (FILE * f, struct cgraph_node *node)\n {\n   int i, count;\n-  bool temp;\n-  struct cgraph_node *node;\n+  struct ipa_node_params *info;\n \n-  fprintf (f, \"\\nMODIFY PRINT\\n\");\n-  for (node = cgraph_nodes; node; node = node->next)\n+  if (!node->analyzed)\n+    return;\n+  info = IPA_NODE_REF (node);\n+  fprintf (f, \"PARAM FLAGS of function  %s: \\n\", cgraph_node_name (node));\n+  count = ipa_get_param_count (info);\n+  for (i = 0; i < count; i++)\n     {\n-      struct ipa_node_params *info;\n-\n-      if (!node->analyzed)\n-\tcontinue;\n-      info = IPA_NODE_REF (node);\n-      fprintf (f, \"function  %s :: \\n\", cgraph_node_name (node));\n-      count = ipa_get_param_count (info);\n-      for (i = 0; i < count; i++)\n-\t{\n-\t  temp = info->modified_flags[i];\n-\t  if (temp)\n-\t    fprintf (f, \" param [%d] true \\n\", i);\n-\t  else\n-\t    fprintf (f, \" param [%d] false \\n\", i);\n-\t}\n+      fprintf (f, \"   param %d flags:\", i);\n+      if (ipa_is_ith_param_modified (info, i))\n+\tfprintf (f, \" modified\");\n+      if (ipa_is_ith_param_called (info, i))\n+\tfprintf (f, \" called\");\n+      fprintf (f, \"\\n\");\n     }\n }\n \n+/* Print param_flags data structures of all functions in the\n+   callgraph to F.  */\n+void\n+ipa_print_all_param_flags (FILE * f)\n+{\n+  struct cgraph_node *node;\n+\n+  fprintf (f, \"\\nIPA PARAM FLAGS DUMP\\n\");\n+  for (node = cgraph_nodes; node; node = node->next)\n+    ipa_print_node_param_flags (f, node);\n+}"}, {"sha": "7d44da1813cb04fcae55cc2e7a28f886d03ce011", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 82, "deletions": 14, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=3e293154d69acf16281d5b9b038ca741c1cf53d6", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"tree.h\"\n #include \"vec.h\"\n+#include \"cgraph.h\"\n \n /* The following definitions and interfaces are used by\n    interprocedural analyses.  */\n@@ -32,21 +33,23 @@ along with GCC; see the file COPYING3.  If not see\n    Constant - a constant is passed as an actual argument.\n    Unknown - neither of the above.\n    Integer and real constants are represented as IPA_CONST and Fortran\n-   constants are represented as IPA_CONST_REF.  */\n+   constants are represented as IPA_CONST_REF.  Finally, IPA_CONST_MEMBER_PTR\n+   stands for C++ member pointers constants.  */\n enum jump_func_type\n {\n-  IPA_UNKNOWN,\n+  IPA_UNKNOWN = 0,     /* newly allocated and zeroed jump functions default */\n   IPA_CONST,\n   IPA_CONST_REF,\n+  IPA_CONST_MEMBER_PTR,\n   IPA_PASS_THROUGH\n };\n \n /* All formal parameters in the program have a lattice associated with it\n    computed by the interprocedural stage of IPCP.\n    There are three main values of the lattice:\n-   TOP - unknown.\n-   BOTTOM - non constant.\n-   CONSTANT_TYPE - constant value.\n+   IPA_TOP - unknown,\n+   IPA_BOTTOM - non constant,\n+   IPA_CONST_VALUE - simple scalar constant,\n    Cval of formal f will have a constant value if all callsites to this\n    function have the same constant value passed to f.\n    Integer and real constants are represented as IPA_CONST and Fortran\n@@ -59,14 +62,24 @@ enum ipa_lattice_type\n   IPA_TOP\n };\n \n-/* Represents a value of a jump function.\n-   value represents a constant.\n-   formal_id is used only in jump function context and represents \n-   pass-through parameter (the formal of caller is passed as argument).  */\n+/* Structure holding a C++ member pointer constant.  Holds a pointer to the\n+   method and delta offset.  */\n+struct ipa_member_ptr_cst\n+{\n+  tree pfn;\n+  tree delta;\n+};\n+\n+/* Represents a value of a jump function.  formal_id is used only in jump\n+   function context and represents pass-through parameter (the formal parameter\n+   of the caller is passed as argument).  constant represents the actual\n+   constant in constant jump functions and member_cst holds constant c++ member\n+   functions.  */\n union jump_func_value\n {\n   unsigned int formal_id;\n   tree constant;\n+  struct ipa_member_ptr_cst member_cst;\n };\n \n /* A jump function for a callsite represents the values passed as actual \n@@ -101,10 +114,43 @@ struct ipa_replace_map\n   bool ref_p;\n };\n \n+/* ipa_param_flags contains various flags that describe how the associated\n+   parameter is treated within a function. */\n+struct ipa_param_flags\n+{\n+  /* Whether the value parameter has been modified within the function.  */\n+  unsigned modified : 1;\n+  /* Whether the parameter has been used as a call destination. */\n+  unsigned called : 1;\n+};\n+\n+/* Each instance of the following  structure describes a statement that calls a\n+   function parameter.  Those referring  to statements within the same function\n+   are linked in a list.  */\n+struct ipa_param_call_note\n+{\n+  /* Linked list's next */\n+  struct ipa_param_call_note *next;\n+  /* Statement that contains the call to the parameter above.  */\n+  tree stmt;\n+  /* Index of the parameter that is called.  */\n+  unsigned int formal_id;\n+  /* Expected number of executions: calculated in profile.c.  */\n+  gcov_type count;\n+  /* Expected frequency of executions within the function. see cgraph_edge in\n+     cgraph.h for more on this. */\n+  int frequency;\n+  /* Depth of loop nest, 1 means no loop nest.  */\n+  int loop_nest;\n+  /* Set when we have already found the target to be a compile time constant\n+     and turned this into an edge or when the note was found unusable for some\n+     reason.  */\n+  bool processed;\n+};\n+\n /* ipa_node_params stores information related to formal parameters of functions\n    and some other information for interprocedural passes that operate on\n    parameters (such as ipa-cp).  */\n-\n struct ipa_node_params\n {\n   /* Number of formal parameters of this function.  When set to 0,\n@@ -115,8 +161,10 @@ struct ipa_node_params\n   struct ipcp_lattice *ipcp_lattices;\n   /* Mapping each parameter to its PARM_DECL tree.  */\n   tree *param_decls;\n-  /* Indicating which parameter is modified in its function.  */\n-  bool *modified_flags;\n+  /* Various flags describing individual parameters.  */\n+  struct ipa_param_flags *param_flags;\n+  /* List of structures enumerating calls to a formal parameter.  */\n+  struct ipa_param_call_note *param_calls;\n   /* Only for versioned nodes this field would not be NULL,\n      it points to the node that IPA cp cloned from.  */\n   struct cgraph_node *ipcp_orig_node;\n@@ -130,6 +178,10 @@ struct ipa_node_params\n   /* Whether this function is called with variable number of actual\n      arguments.  */\n   unsigned called_with_var_arguments : 1;\n+  /* Whether the modification analysis has already been performed. */\n+  unsigned modification_analysis_done : 1;\n+  /* Whether the param uses analysis has already been performed.  */\n+  unsigned uses_analysis_done : 1;\n };\n \n /* ipa_node_params access functions.  Please use these to access fields that\n@@ -164,7 +216,16 @@ ipa_get_ith_param (struct ipa_node_params *info, int i)\n static inline bool\n ipa_is_ith_param_modified (struct ipa_node_params *info, int i)\n {\n-  return info->modified_flags[i];\n+  return info->param_flags[i].modified;\n+}\n+\n+/* Returns the called flag corresponding o the ith paramterer.  Note there is\n+   no setter method as the goal is to set all flags when building the array in\n+   ipa_detect_called_params.  */\n+static inline bool\n+ipa_is_ith_param_called (struct ipa_node_params *info, int i)\n+{\n+  return info->param_flags[i].called;\n }\n \n /* Flag this node as having callers with variable number of arguments.  */\n@@ -255,6 +316,7 @@ void ipa_free_node_params_substructures (struct ipa_node_params *);\n void ipa_free_all_node_params (void);\n void ipa_free_all_edge_args (void);\n void free_all_ipa_structures_after_ipa_cp (void);\n+void free_all_ipa_structures_after_iinln (void);\n void ipa_register_cgraph_hooks (void);\n \n /* This function ensures the array of node param infos is big enough to\n@@ -318,9 +380,15 @@ void ipa_count_arguments (struct cgraph_edge *);\n void ipa_count_formal_params (struct cgraph_node *);\n void ipa_create_param_decls_array (struct cgraph_node *);\n void ipa_detect_param_modifications (struct cgraph_node *);\n+void ipa_analyze_params_uses (struct cgraph_node *);\n+void ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n+\t\t\t\t\tVEC (cgraph_edge_p, heap) *new_edges);\n \n /* Debugging interface.  */\n void ipa_print_all_tree_maps (FILE *);\n-void ipa_print_all_params_modified (FILE *);\n+void ipa_print_node_param_flags (FILE * f, struct cgraph_node *node);\n+void ipa_print_all_param_flags (FILE *);\n+void ipa_print_node_jump_functions (FILE *f, struct cgraph_node *node);\n+void ipa_print_all_jump_functions (FILE * f);\n \n #endif /* IPA_PROP_H */"}, {"sha": "ecd4e372e2ee877727796886f0a1b9c85d8a3342", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=3e293154d69acf16281d5b9b038ca741c1cf53d6", "patch": "@@ -934,6 +934,7 @@ decode_options (unsigned int argc, const char **argv)\n   /* -O2 optimizations.  */\n   opt2 = (optimize >= 2);\n   flag_inline_small_functions = opt2;\n+  flag_indirect_inlining = opt2;\n   flag_thread_jumps = opt2;\n   flag_crossjumping = opt2;\n   flag_optimize_sibling_calls = opt2;"}, {"sha": "be3be71f96a418138fff05fd31b9dd7ec5ede090", "filename": "gcc/testsuite/g++.dg/ipa/iinline-1.C", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fiinline-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fiinline-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fiinline-1.C?ref=3e293154d69acf16281d5b9b038ca741c1cf53d6", "patch": "@@ -0,0 +1,47 @@\n+/* Verify that simple indirect calls are inlined even without early\n+   inlining..  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -c -fdump-ipa-inline -fno-early-inlining\"  } */\n+\n+extern void non_existent (const char *, int);\n+\n+class String\n+{\n+private:\n+  const char *data;\n+\n+public:\n+  String (const char *d) : data(d)\n+  {}\n+\n+  int funcOne (int delim) const;\n+  int printStuffTwice (int delim) const;\n+};\n+\n+\n+int String::funcOne (int delim) const\n+{\n+  int i;\n+  for (i = 0; i < delim; i++)\n+    non_existent(data, i);\n+\n+  return 1;\n+}\n+\n+int docalling (int (String::* f)(int delim) const)\n+{\n+  String S (\"muhehehe\");\n+\n+  return (S.*f)(4);\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  int i;\n+  i = docalling (&String::funcOne);\n+  non_existent (\"done\", i);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"String::funcOne\\[^\\\\n\\]*inline copy in int main\"  \"inline\"  } } */\n+/* { dg-final { cleanup-tree-dump \"inline\" } } */"}, {"sha": "da548f466489f7106b9e658645b9a3d47f94c196", "filename": "gcc/testsuite/gcc.dg/ipa/iinline-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-1.c?ref=3e293154d69acf16281d5b9b038ca741c1cf53d6", "patch": "@@ -0,0 +1,26 @@\n+/* Verify that simple indirect calls are inlined even without early\n+   inlining..  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -c -fdump-ipa-inline -fno-early-inlining\"  } */\n+\n+extern void non_existent(int);\n+\n+static void hooray ()\n+{\n+  non_existent (1);\n+}\n+\n+static void hiphip (void (*f)())\n+{\n+  non_existent (2);\n+  f ();\n+}\n+\n+int main (int argc, int *argv[])\n+{\n+  hiphip (hooray);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"hooray\\[^\\\\n\\]*inline copy in main\"  \"inline\"  } } */\n+/* { dg-final { cleanup-tree-dump \"inline\" } } */"}, {"sha": "7d160cb7e74b0d07c14410760b2441a1d6d97080", "filename": "gcc/testsuite/gcc.dg/ipa/modif-1.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fmodif-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fmodif-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fmodif-1.c?ref=3e293154d69acf16281d5b9b038ca741c1cf53d6", "patch": "@@ -0,0 +1,44 @@\n+/* Verify that modification analysis detects modfications.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -c -fdump-ipa-inline -fno-early-inlining\"  } */\n+\n+struct whatever\n+{\n+  int first;\n+  unsigned second;\n+};\n+\n+void func1 (struct whatever w);\n+void func2 (struct whatever *pw);\n+void func3 (int i);\n+void func4 (int *pi);\n+\n+void the_test (struct whatever u, struct whatever v,\n+\t       struct whatever w, struct whatever x,\n+\t       int i, int j, int k, int l)\n+{\n+  struct whatever *pw = &w;\n+  int *pk = &k;\n+\n+  j = l+3;\n+  v.first = 9;\n+\n+  func1 (u);\n+  func1 (v);\n+  func2 (pw);\n+  func2 (&x);\n+  func3 (i);\n+  func3 (j);\n+  func4 (pk);\n+  func4 (&l);\n+}\n+\n+/* { dg-final { scan-ipa-dump-not \"param 0 flags:\\[^\\\\n\\]*modified\" \"inline\" } } */\n+/* { dg-final { scan-ipa-dump \"param 1 flags:\\[^\\\\n\\]*modified\" \"inline\" } } */\n+/* { dg-final { scan-ipa-dump \"param 2 flags:\\[^\\\\n\\]*modified\" \"inline\" } } */\n+/* { dg-final { scan-ipa-dump \"param 3 flags:\\[^\\\\n\\]*modified\" \"inline\" } } */\n+/* { dg-final { scan-ipa-dump-not \"param 4 flags:\\[^\\\\n\\]*modified\" \"inline\" } } */\n+/* { dg-final { scan-ipa-dump \"param 5 flags:\\[^\\\\n\\]*modified\" \"inline\" } } */\n+/* { dg-final { scan-ipa-dump \"param 6 flags:\\[^\\\\n\\]*modified\" \"inline\" } } */\n+/* { dg-final { scan-ipa-dump \"param 7 flags:\\[^\\\\n\\]*modified\" \"inline\" } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "b5eb033588e429c08d6e7c6322891a5c213ba880", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e293154d69acf16281d5b9b038ca741c1cf53d6/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=3e293154d69acf16281d5b9b038ca741c1cf53d6", "patch": "@@ -951,7 +951,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\tpointer_set_insert (id->statements_to_fold, stmt);\n \t      /* We're duplicating a CALL_EXPR.  Find any corresponding\n \t\t callgraph edges and update or duplicate them.  */\n-\t      if (call && (decl = get_callee_fndecl (call)))\n+\t      if (call)\n \t\t{\n \t\t  struct cgraph_node *node;\n \t\t  struct cgraph_edge *edge;\n@@ -962,7 +962,8 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t      edge = cgraph_edge (id->src_node, orig_stmt);\n \t\t      if (edge)\n \t\t\tcgraph_clone_edge (edge, id->dst_node, stmt,\n-\t\t\t\t\t   REG_BR_PROB_BASE, 1, edge->frequency, true);\n+\t\t\t\t\t   REG_BR_PROB_BASE, 1,\n+\t\t\t\t\t   edge->frequency, true);\n \t\t      break;\n \n \t\t    case CB_CGE_MOVE_CLONES:\n@@ -971,8 +972,8 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t\t   node = node->next_clone)\n \t\t\t{\n \t\t\t  edge = cgraph_edge (node, orig_stmt);\n-\t\t\t  gcc_assert (edge);\n-\t\t\t  cgraph_set_call_stmt (edge, stmt);\n+\t\t\t  if (edge)\n+\t\t\t    cgraph_set_call_stmt (edge, stmt);\n \t\t\t}\n \t\t      /* FALLTHRU */\n \n@@ -2580,6 +2581,20 @@ add_lexical_block (tree current_block, tree new_block)\n   BLOCK_SUPERCONTEXT (new_block) = current_block;\n }\n \n+/* Fetch callee declaration from the call graph edge going from NODE and\n+   associated with STMR call statement.  Return NULL_TREE if not found.  */\n+static tree\n+get_indirect_callee_fndecl (struct cgraph_node *node, tree stmt)\n+{\n+  struct cgraph_edge *cs;\n+\n+  cs = cgraph_edge (node, stmt);\n+  if (cs)\n+    return cs->callee->decl;\n+\n+  return NULL_TREE;\n+}\n+\n /* If *TP is a CALL_EXPR, replace it with its inline expansion.  */\n \n static bool\n@@ -2621,7 +2636,11 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n      If we cannot, then there is no hope of inlining the function.  */\n   fn = get_callee_fndecl (t);\n   if (!fn)\n-    goto egress;\n+    {\n+      fn = get_indirect_callee_fndecl (id->dst_node, stmt);\n+      if (!fn)\n+\tgoto egress;\n+    }\n \n   /* Turn forward declarations into real ones.  */\n   fn = cgraph_node (fn)->decl;\n@@ -2672,6 +2691,12 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n      inlining.  */\n   if (!cgraph_inline_p (cg_edge, &reason))\n     {\n+      /* If this call was originally indirect, we do not want to emit any\n+\t inlining related warnings or sorry messages because there are no\n+\t guarantees regarding those.  */\n+      if (cg_edge->indirect_call)\n+\tgoto egress;\n+\n       if (lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn))\n \t  /* Avoid warnings during early inline pass. */\n \t  && (!flag_unit_at_a_time || cgraph_global_info_ready))"}]}