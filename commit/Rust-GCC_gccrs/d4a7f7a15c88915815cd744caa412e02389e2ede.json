{"sha": "d4a7f7a15c88915815cd744caa412e02389e2ede", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRhN2Y3YTE1Yzg4OTE1ODE1Y2Q3NDRjYWE0MTJlMDIzODllMmVkZQ==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2012-11-16T21:28:44Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2012-11-16T21:28:44Z"}, "message": "hashtable_policy.h (_Prime_rehash_policy): Remove automatic shrink.\n\n2012-11-16  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/bits/hashtable_policy.h (_Prime_rehash_policy): Remove\n\tautomatic shrink.\n\t(_Prime_rehash_policy::_M_bkt_for_elements): Do not call\n\t_M_next_bkt anymore.\n\t(_Prime_rehash_policy::_M_next_bkt): Move usage of\n\t_S_growth_factor ...\n\t(_Prime_rehash_policy::_M_need_rehash): ... here.\n\t* include/bits/hashtable.h (_Hashtable<>): Adapt.\n\t* testsuite/performance/23_containers/insert_erase/41975.cc: Add\n\t_USE_TR1 to force build using std::tr1 container.\n\t* testsuite/performance/23_containers/insert/unordered_set.cc:\n\tLikewise.\n\t* testsuite/performance/23_containers/insert/54075.cc: New.\n\nFrom-SVN: r193576", "tree": {"sha": "af286ba5a2bef7d79795117e634ec60dc2a3c8df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af286ba5a2bef7d79795117e634ec60dc2a3c8df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4a7f7a15c88915815cd744caa412e02389e2ede", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4a7f7a15c88915815cd744caa412e02389e2ede", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4a7f7a15c88915815cd744caa412e02389e2ede", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4a7f7a15c88915815cd744caa412e02389e2ede/comments", "author": null, "committer": null, "parents": [{"sha": "9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9acb8ddf3e7cf312de229eae11e0a1df29548ec9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9acb8ddf3e7cf312de229eae11e0a1df29548ec9"}], "stats": {"total": 264, "additions": 204, "deletions": 60}, "files": [{"sha": "9be305b97e8930dc842883f106f858a4f71304f7", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4a7f7a15c88915815cd744caa412e02389e2ede/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4a7f7a15c88915815cd744caa412e02389e2ede/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d4a7f7a15c88915815cd744caa412e02389e2ede", "patch": "@@ -1,3 +1,19 @@\n+2012-11-16  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\t* include/bits/hashtable_policy.h (_Prime_rehash_policy): Remove\n+\tautomatic shrink.\n+\t(_Prime_rehash_policy::_M_bkt_for_elements): Do not call\n+\t_M_next_bkt anymore.\n+\t(_Prime_rehash_policy::_M_next_bkt): Move usage of\n+\t_S_growth_factor ...\n+\t(_Prime_rehash_policy::_M_need_rehash): ... here.\n+\t* include/bits/hashtable.h (_Hashtable<>): Adapt.\n+\t* testsuite/performance/23_containers/insert_erase/41975.cc: Add\n+\t_USE_TR1 to force build using std::tr1 container.\n+\t* testsuite/performance/23_containers/insert/unordered_set.cc:\n+\tLikewise.\n+\t* testsuite/performance/23_containers/insert/54075.cc: New.\n+\n 2012-11-16  Tom Tromey  <tromey@redhat.com>\n \n \t* testsuite/libstdc++-prettyprinters/whatis.cc: New file."}, {"sha": "0f15a46e6db018ef1c9490ae0e7f0b86c40f98cd", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 10, "deletions": 25, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4a7f7a15c88915815cd744caa412e02389e2ede/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4a7f7a15c88915815cd744caa412e02389e2ede/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=d4a7f7a15c88915815cd744caa412e02389e2ede", "patch": "@@ -806,11 +806,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_rehash_policy()\n     {\n       _M_bucket_count = _M_rehash_policy._M_next_bkt(__bucket_hint);\n-\n-      // We don't want the rehash policy to ask for the hashtable to\n-      // shrink on the first insertion so we need to reset its\n-      // previous resize level.\n-      _M_rehash_policy._M_prev_resize = 0;\n       _M_buckets = _M_allocate_buckets(_M_bucket_count);\n     }\n \n@@ -834,16 +829,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_M_element_count(0),\n \t_M_rehash_policy()\n       {\n+\tauto __nb_elems = __detail::__distance_fw(__f, __l);\n \t_M_bucket_count =\n-\t  _M_rehash_policy._M_bkt_for_elements(__detail::__distance_fw(__f,\n-\t\t\t\t\t\t\t\t       __l));\n-\tif (_M_bucket_count <= __bucket_hint)\n-\t  _M_bucket_count = _M_rehash_policy._M_next_bkt(__bucket_hint);\n-\n-\t// We don't want the rehash policy to ask for the hashtable to\n-\t// shrink on the first insertion so we need to reset its\n-\t// previous resize level.\n-\t_M_rehash_policy._M_prev_resize = 0;\n+\t  _M_rehash_policy._M_next_bkt(\n+\t    std::max(_M_rehash_policy._M_bkt_for_elements(__nb_elems),\n+\t\t     __bucket_hint));\n+\n \t_M_buckets = _M_allocate_buckets(_M_bucket_count);\n \t__try\n \t  {\n@@ -990,6 +981,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     __rehash_policy(const _RehashPolicy& __pol)\n     {\n       size_type __n_bkt = __pol._M_bkt_for_elements(_M_element_count);\n+      __n_bkt = __pol._M_next_bkt(__n_bkt);\n       if (__n_bkt != _M_bucket_count)\n \t_M_rehash(__n_bkt, _M_rehash_policy._M_state());\n       _M_rehash_policy = __pol;\n@@ -1641,19 +1633,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       const __rehash_state& __saved_state = _M_rehash_policy._M_state();\n       std::size_t __buckets\n-\t= _M_rehash_policy._M_bkt_for_elements(_M_element_count + 1);\n-      if (__buckets <= __n)\n-\t__buckets = _M_rehash_policy._M_next_bkt(__n);\n+\t= std::max(_M_rehash_policy._M_bkt_for_elements(_M_element_count + 1),\n+\t\t   __n);\n+      __buckets = _M_rehash_policy._M_next_bkt(__buckets);\n \n       if (__buckets != _M_bucket_count)\n-\t{\n-\t  _M_rehash(__buckets, __saved_state);\n-\n-\t  // We don't want the rehash policy to ask for the hashtable to shrink\n-\t  // on the next insertion so we need to reset its previous resize\n-\t  // level.\n-\t  _M_rehash_policy._M_prev_resize = 0;\n-\t}\n+\t_M_rehash(__buckets, __saved_state);\n       else\n \t// No rehash, restore previous state to keep a consistent state.\n \t_M_rehash_policy._M_reset(__saved_state);"}, {"sha": "ee289da6a483ad36b9d235507d8f533b75990c99", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 13, "deletions": 30, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4a7f7a15c88915815cd744caa412e02389e2ede/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4a7f7a15c88915815cd744caa412e02389e2ede/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=d4a7f7a15c88915815cd744caa412e02389e2ede", "patch": "@@ -358,7 +358,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   struct _Prime_rehash_policy\n   {\n     _Prime_rehash_policy(float __z = 1.0)\n-    : _M_max_load_factor(__z), _M_prev_resize(0), _M_next_resize(0) { }\n+    : _M_max_load_factor(__z), _M_next_resize(0) { }\n \n     float\n     max_load_factor() const noexcept\n@@ -380,25 +380,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,\n \t\t   std::size_t __n_ins) const;\n \n-    typedef std::pair<std::size_t, std::size_t> _State;\n+    typedef std::size_t _State;\n \n     _State\n     _M_state() const\n-    { return std::make_pair(_M_prev_resize, _M_next_resize); }\n+    { return _M_next_resize; }\n \n     void\n-    _M_reset(const _State& __state)\n-    {\n-      _M_prev_resize = __state.first;\n-      _M_next_resize = __state.second;\n-    }\n+    _M_reset(_State __state)\n+    { _M_next_resize = __state; }\n \n     enum { _S_n_primes = sizeof(unsigned long) != 8 ? 256 : 256 + 48 };\n \n     static const std::size_t _S_growth_factor = 2;\n \n     float                _M_max_load_factor;\n-    mutable std::size_t  _M_prev_resize;\n     mutable std::size_t  _M_next_resize;\n   };\n \n@@ -417,35 +413,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     static const unsigned char __fast_bkt[12]\n       = { 2, 2, 2, 3, 5, 5, 7, 7, 11, 11, 11, 11 };\n \n-    const std::size_t __grown_n = __n * _S_growth_factor;\n-    if (__grown_n <= 11)\n+    if (__n <= 11)\n       {\n-\t_M_prev_resize = 0;\n \t_M_next_resize\n-\t  = __builtin_ceil(__fast_bkt[__grown_n]\n+\t  = __builtin_ceil(__fast_bkt[__n]\n \t\t\t   * (long double)_M_max_load_factor);\n-\treturn __fast_bkt[__grown_n];\n+\treturn __fast_bkt[__n];\n       }\n \n     const unsigned long* __next_bkt\n       = std::lower_bound(__prime_list + 5, __prime_list + _S_n_primes,\n-\t\t\t __grown_n);\n-    const unsigned long* __prev_bkt\n-      = std::lower_bound(__prime_list + 1, __next_bkt, __n / _S_growth_factor);\n-\n-    _M_prev_resize\n-      = __builtin_floor(*(__prev_bkt - 1) * (long double)_M_max_load_factor);\n+\t\t\t __n);\n     _M_next_resize\n       = __builtin_ceil(*__next_bkt * (long double)_M_max_load_factor);\n     return *__next_bkt;\n   }\n \n-  // Return the smallest prime p such that alpha p >= n, where alpha\n+  // Return the smallest integer p such that alpha p >= n, where alpha\n   // is the load factor.\n   inline std::size_t\n   _Prime_rehash_policy::\n   _M_bkt_for_elements(std::size_t __n) const\n-  { return _M_next_bkt(__builtin_ceil(__n / (long double)_M_max_load_factor)); }\n+  { return __builtin_ceil(__n / (long double)_M_max_load_factor); }\n \n   // Finds the smallest prime p such that alpha p > __n_elt + __n_ins.\n   // If p > __n_bkt, return make_pair(true, p); otherwise return\n@@ -467,21 +456,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t / (long double)_M_max_load_factor;\n \tif (__min_bkts >= __n_bkt)\n \t  return std::make_pair(true,\n-\t\t\t\t_M_next_bkt(__builtin_floor(__min_bkts) + 1));\n+\t    _M_next_bkt(std::max<std::size_t>(__builtin_floor(__min_bkts) + 1,\n+\t\t\t\t\t      __n_bkt * _S_growth_factor)));\n \telse\n \t  {\n \t    _M_next_resize\n \t      = __builtin_floor(__n_bkt * (long double)_M_max_load_factor);\n \t    return std::make_pair(false, 0);\n \t  }\n       }\n-    else if (__n_elt + __n_ins < _M_prev_resize)\n-      {\n-\tlong double __min_bkts = (__n_elt + __n_ins)\n-\t\t\t\t / (long double)_M_max_load_factor;\n-\treturn std::make_pair(true,\n-\t\t\t      _M_next_bkt(__builtin_floor(__min_bkts) + 1));\n-      }\n     else\n       return std::make_pair(false, 0);\n   }"}, {"sha": "cb045ead3c43897e790f66eec88f74c71bdcbc06", "filename": "libstdc++-v3/testsuite/performance/23_containers/insert/54075.cc", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4a7f7a15c88915815cd744caa412e02389e2ede/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert%2F54075.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4a7f7a15c88915815cd744caa412e02389e2ede/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert%2F54075.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert%2F54075.cc?ref=d4a7f7a15c88915815cd744caa412e02389e2ede", "patch": "@@ -0,0 +1,132 @@\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <testsuite_performance.h>\n+#include <random>\n+#include <sstream>\n+#include <tr1/unordered_set>\n+#include<unordered_set>\n+\n+struct Foo\n+{\n+  typedef std::random_device::result_type _Type;\n+  _Type bar;\n+  _Type baz;\n+  _Type meh;\n+\n+  void\n+  init(std::random_device& randev)\n+  {\n+    bar = randev();\n+    baz = randev();\n+    meh = randev();\n+  }\n+\n+  std::size_t\n+  hash() const noexcept\n+  { return std::size_t(bar ^ baz ^ meh); }\n+\n+  inline bool\n+  operator==(const Foo& other) const\n+  { return other.bar == bar && other.baz == baz && other.meh == meh; }\n+};\n+\n+struct HashFunction\n+{\n+  template<typename T>\n+    std::size_t operator()(const T& t) const noexcept\n+    { return t.hash(); }\n+};\n+\n+template<typename _ContType>\n+  void bench(const char* container_desc)\n+  {\n+    using namespace __gnu_test;\n+\n+    time_counter time;\n+    resource_counter resource;\n+\n+    const int sz = 300000;\n+\n+    Foo foos[sz];\n+    {\n+      std::random_device randev;\n+      for (int i = 0; i != sz; ++i)\n+\tfoos[i].init(randev);\n+    }\n+\n+    _ContType s;\n+    start_counters(time, resource);\n+\n+    for (int i = 0; i != sz ; ++i)\n+      s.insert(foos[i]);\n+\n+    stop_counters(time, resource);\n+    std::ostringstream ostr;\n+    ostr << container_desc << sz << \" Foo insertions\";\n+    report_performance(__FILE__, ostr.str().c_str(), time, resource);\n+\n+    // Try to insert again to check performance of collision detection\n+    \n+    const int nb_loop = 10;\n+    start_counters(time, resource);\n+\n+    for (int j = 0; j != nb_loop; ++j)\n+      for (int i = 0; i != sz; ++i)\n+\ts.insert(foos[i]);\n+\n+    stop_counters(time, resource);\n+    ostr.str(\"\");\n+    ostr << container_desc << nb_loop << \" times insertion of \"\n+\t << sz << \" Foo\";\n+    report_performance(__FILE__, ostr.str().c_str(), time, resource);\n+  }\n+\n+template<bool cache>\n+  using __tr1_uset = std::tr1::__unordered_set<Foo, HashFunction,\n+\t\t\t\t\t       std::equal_to<Foo>,\n+\t\t\t\t\t       std::allocator<Foo>,\n+\t\t\t\t\t       cache>;\n+template<bool cache>\n+  using __tr1_umset = std::tr1::__unordered_multiset<Foo, HashFunction,\n+\t\t\t\t\t\t     std::equal_to<Foo>,\n+\t\t\t\t\t\t     std::allocator<Foo>,\n+\t\t\t\t\t\t     cache>;\n+template<bool cache>\n+  using __uset = std::__uset_hashtable<Foo, HashFunction,\n+\t\t\t\t       std::equal_to<Foo>,\n+\t\t\t\t       std::allocator<Foo>,\n+\t\t\t\t       std::__uset_traits<cache>>;\n+template<bool cache>\n+  using __umset = std::__umset_hashtable<Foo, HashFunction,\n+\t\t\t\t\t std::equal_to<Foo>,\n+\t\t\t\t\t std::allocator<Foo>,\n+\t\t\t\t\t std::__uset_traits<cache>>;\n+\n+int main()\n+{\n+  bench<__tr1_uset<false>>(\"std::tr1::unordered_set without hash code cached \");\n+  bench<__tr1_uset<true>>(\"std::tr1::unordered_set with hash code cached \");\n+  bench<__tr1_umset<false>>(\"std::tr1::unordered_multiset without hash code cached \");\n+  bench<__tr1_umset<true>>(\"std::tr1::unordered_multiset with hash code cached \");\n+  bench<__uset<false>>(\"std::unordered_set without hash code cached \");\n+  bench<__uset<true>>(\"std::unordered_set with hash code cached \");\n+  bench<__umset<false>>(\"std::unordered_multiset without hash code cached \");\n+  bench<__umset<true>>(\"std::unordered_multiset with hash code cached \");\n+}"}, {"sha": "a7fd4a0ece141984fc676e1efaa94deb8a9736d6", "filename": "libstdc++-v3/testsuite/performance/23_containers/insert/unordered_set.cc", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4a7f7a15c88915815cd744caa412e02389e2ede/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert%2Funordered_set.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4a7f7a15c88915815cd744caa412e02389e2ede/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert%2Funordered_set.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert%2Funordered_set.cc?ref=d4a7f7a15c88915815cd744caa412e02389e2ede", "patch": "@@ -17,8 +17,17 @@\n \n // { dg-options \"-std=c++11\" }\n \n-#include <unordered_set>\n #include <testsuite_performance.h>\n+#include <sstream>\n+#ifdef _USE_TR1\n+#  include <tr1/unordered_set>\n+using namespace std::tr1;\n+const char* ns = \"std::tr1::\";\n+#else\n+#  include<unordered_set>\n+using namespace std;\n+const char* ns = \"std::\";\n+#endif\n \n int main()\n {\n@@ -29,14 +38,16 @@ int main()\n \n   const int sz = 10000000;\n \n-  std::unordered_set<int> s;\n+  unordered_set<int> s;\n   start_counters(time, resource);\n \n   for (int i = 0; i != sz ; ++i)\n     s.insert(i);\n \n   stop_counters(time, resource);\n-  report_performance(__FILE__, \"unordered_set 10000000 insertions\",\n+  std::ostringstream ostr;\n+  ostr << ns << \"unordered_set \" << sz << \" insertions\";\n+  report_performance(__FILE__, ostr.str().c_str(),\n \t\t     time, resource);\n   return 0;\n }"}, {"sha": "19226f6e113064f2662cb09e5bf39d42e4588082", "filename": "libstdc++-v3/testsuite/performance/23_containers/insert_erase/41975.cc", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4a7f7a15c88915815cd744caa412e02389e2ede/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert_erase%2F41975.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4a7f7a15c88915815cd744caa412e02389e2ede/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert_erase%2F41975.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert_erase%2F41975.cc?ref=d4a7f7a15c88915815cd744caa412e02389e2ede", "patch": "@@ -18,7 +18,11 @@\n // <http://www.gnu.org/licenses/>.\n \n #include <sstream>\n-#include <unordered_set>\n+#ifdef _USE_TR1\n+#  include <tr1/unordered_set>\n+#else\n+#  include <unordered_set>\n+#endif\n #include <testsuite_performance.h>\n \n namespace\n@@ -40,11 +44,17 @@ namespace\n       const int nb = 200000;\n       start_counters(time, resource);\n \n+#ifdef _USE_TR1\n+      std::tr1::__unordered_set<int, std::hash<int>, std::equal_to<int>,\n+\t\t\t\tstd::allocator<int>,\n+\t\t\t       \tuse_cache> us;\n+#else\n       std::__uset_hashtable<int, std::hash<int>, std::equal_to<int>,\n \t\t\t    std::allocator<int>,\n \t\t\t    std::__uset_traits<use_cache>> us;\n+#endif\n       for (int i = 0; i != nb; ++i)\n-\tus.insert(i);\n+\t  us.insert(i);\n \n       stop_counters(time, resource);\n       ostr.str(\"\");\n@@ -126,10 +136,17 @@ namespace\n \n       start_counters(time, resource);\n \n+#ifdef _USE_TR1\n+      std::tr1::__unordered_set<std::string, std::hash<std::string>,\n+\t\t\t\tstd::equal_to<std::string>,\n+\t\t\t\tstd::allocator<std::string>,\n+\t\t\t\tuse_cache> us;\n+#else\n       std::__uset_hashtable<std::string, std::hash<std::string>,\n \t\t\t    std::equal_to<std::string>,\n \t\t\t    std::allocator<std::string>,\n \t\t\t    std::__uset_traits<use_cache>> us;\n+#endif\n       for (int i = 0; i != nb; ++i)\n \tus.insert(strs[i]);\n "}]}