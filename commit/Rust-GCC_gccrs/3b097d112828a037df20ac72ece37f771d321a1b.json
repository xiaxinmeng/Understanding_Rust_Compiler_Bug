{"sha": "3b097d112828a037df20ac72ece37f771d321a1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2IwOTdkMTEyODI4YTAzN2RmMjBhYzcyZWNlMzdmNzcxZDMyMWExYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-26T10:57:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-26T10:57:52Z"}, "message": "[multiple changes]\n\n2010-10-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch5.adb: Adjust format of error message.\n\n2010-10-26  Robert Dewar  <dewar@adacore.com>\n\n\t* einfo.ads, einfo.adb (OK_To_Reference): Removed, no longer used.\n\t* exp_util.adb (Side_Effect_Free): Put in safety barrier in code to\n\tdetect renamings to avoid problems with invariants.\n\t* sem_ch13.adb (Replace_Type_References_Generic): New procedure\n\t(Build_Invariant_Procedure): Use Replace_Type_Reference_Generic\n\t(Build_Predicate_Function): Use Replace_Type_Reference_Generic\n\t* sem_res.adb, sem_ch8.adb, sem_ch4.adb (OK_To_Reference): Remove\n\treferences, flag is no longer set.\n\nFrom-SVN: r165944", "tree": {"sha": "2cc9b5a637f02648c47d1218218b06c410228d5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cc9b5a637f02648c47d1218218b06c410228d5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b097d112828a037df20ac72ece37f771d321a1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b097d112828a037df20ac72ece37f771d321a1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b097d112828a037df20ac72ece37f771d321a1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b097d112828a037df20ac72ece37f771d321a1b/comments", "author": null, "committer": null, "parents": [{"sha": "3e5daac435e6f3da145310c2140745df5a04fd45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e5daac435e6f3da145310c2140745df5a04fd45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e5daac435e6f3da145310c2140745df5a04fd45"}], "stats": {"total": 386, "additions": 191, "deletions": 195}, "files": [{"sha": "c4ab24377e4ebffe3ebbd08beccdf5d4e3482118", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b097d112828a037df20ac72ece37f771d321a1b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b097d112828a037df20ac72ece37f771d321a1b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3b097d112828a037df20ac72ece37f771d321a1b", "patch": "@@ -1,3 +1,18 @@\n+2010-10-26  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch5.adb: Adjust format of error message.\n+\n+2010-10-26  Robert Dewar  <dewar@adacore.com>\n+\n+\t* einfo.ads, einfo.adb (OK_To_Reference): Removed, no longer used.\n+\t* exp_util.adb (Side_Effect_Free): Put in safety barrier in code to\n+\tdetect renamings to avoid problems with invariants.\n+\t* sem_ch13.adb (Replace_Type_References_Generic): New procedure\n+\t(Build_Invariant_Procedure): Use Replace_Type_Reference_Generic\n+\t(Build_Predicate_Function): Use Replace_Type_Reference_Generic\n+\t* sem_res.adb, sem_ch8.adb, sem_ch4.adb (OK_To_Reference): Remove\n+\treferences, flag is no longer set.\n+\n 2010-10-26  Vincent Celier  <celier@adacore.com>\n \n \t* prj.ads (Source_Data): New Boolean component Initialized, defaulted"}, {"sha": "4c2530aed8227663bdbc28c9106e7809ee3eb1be", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b097d112828a037df20ac72ece37f771d321a1b/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b097d112828a037df20ac72ece37f771d321a1b/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=3b097d112828a037df20ac72ece37f771d321a1b", "patch": "@@ -513,10 +513,10 @@ package body Einfo is\n    --    Is_Underlying_Record_View       Flag246\n    --    OK_To_Rename                    Flag247\n    --    Has_Inheritable_Invariants      Flag248\n-   --    OK_To_Reference                 Flag249\n    --    Has_Predicates                  Flag250\n \n    --    (unused)                        Flag151\n+   --    (unused)                        Flag249\n    --    (unused)                        Flag251\n    --    (unused)                        Flag252\n    --    (unused)                        Flag253\n@@ -2314,11 +2314,6 @@ package body Einfo is\n       return Uint10 (Id);\n    end Normalized_Position_Max;\n \n-   function OK_To_Reference (Id : E) return B is\n-   begin\n-      return Flag249 (Id);\n-   end OK_To_Reference;\n-\n    function OK_To_Rename (Id : E) return B is\n    begin\n       pragma Assert (Ekind (Id) = E_Variable);\n@@ -4808,11 +4803,6 @@ package body Einfo is\n       Set_Uint10 (Id, V);\n    end Set_Normalized_Position_Max;\n \n-   procedure Set_OK_To_Reference (Id : E; V : B := True) is\n-   begin\n-      Set_Flag249 (Id, V);\n-   end Set_OK_To_Reference;\n-\n    procedure Set_OK_To_Rename (Id : E; V : B := True) is\n    begin\n       pragma Assert (Ekind (Id) = E_Variable);\n@@ -7517,7 +7507,6 @@ package body Einfo is\n       W (\"No_Strict_Aliasing\",              Flag136 (Id));\n       W (\"Non_Binary_Modulus\",              Flag58  (Id));\n       W (\"Nonzero_Is_True\",                 Flag162 (Id));\n-      W (\"OK_To_Reference\",                 Flag249 (Id));\n       W (\"OK_To_Rename\",                    Flag247 (Id));\n       W (\"OK_To_Reorder_Components\",        Flag239 (Id));\n       W (\"Optimize_Alignment_Space\",        Flag241 (Id));"}, {"sha": "3a0b36a636f262b8de613a17d366ad2539f8b409", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b097d112828a037df20ac72ece37f771d321a1b/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b097d112828a037df20ac72ece37f771d321a1b/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=3b097d112828a037df20ac72ece37f771d321a1b", "patch": "@@ -3151,12 +3151,6 @@ package Einfo is\n --       Applies to subprograms and subprogram types. Yields the number of\n --       formals as a value of type Pos.\n \n---    OK_To_Reference (Flag249)\n---       Present in all entities. If set it indicates that a naked reference to\n---       the entity is permitted within an expression that is being preanalyzed\n---       (for example, a type name may be referenced within the Invariant\n---       or Predicate aspect expression for a type).\n-\n --    OK_To_Rename (Flag247)\n --       Present only in entities for variables. If this flag is set, it\n --       means that if the entity is used as the initial value of an object\n@@ -4739,7 +4733,6 @@ package Einfo is\n    --    Needs_Debug_Info                    (Flag147)\n    --    Never_Set_In_Source                 (Flag115)\n    --    No_Return                           (Flag113)\n-   --    OK_To_Reference                     (Flag249)\n    --    Overlays_Constant                   (Flag243)\n    --    Referenced                          (Flag156)\n    --    Referenced_As_LHS                   (Flag36)\n@@ -6191,7 +6184,6 @@ package Einfo is\n    function Normalized_First_Bit                (Id : E) return U;\n    function Normalized_Position                 (Id : E) return U;\n    function Normalized_Position_Max             (Id : E) return U;\n-   function OK_To_Reference                     (Id : E) return B;\n    function OK_To_Rename                        (Id : E) return B;\n    function OK_To_Reorder_Components            (Id : E) return B;\n    function Optimize_Alignment_Space            (Id : E) return B;\n@@ -6779,7 +6771,6 @@ package Einfo is\n    procedure Set_Normalized_First_Bit            (Id : E; V : U);\n    procedure Set_Normalized_Position             (Id : E; V : U);\n    procedure Set_Normalized_Position_Max         (Id : E; V : U);\n-   procedure Set_OK_To_Reference                 (Id : E; V : B := True);\n    procedure Set_OK_To_Rename                    (Id : E; V : B := True);\n    procedure Set_OK_To_Reorder_Components        (Id : E; V : B := True);\n    procedure Set_Optimize_Alignment_Space        (Id : E; V : B := True);\n@@ -7512,7 +7503,6 @@ package Einfo is\n    pragma Inline (Normalized_First_Bit);\n    pragma Inline (Normalized_Position);\n    pragma Inline (Normalized_Position_Max);\n-   pragma Inline (OK_To_Reference);\n    pragma Inline (OK_To_Rename);\n    pragma Inline (OK_To_Reorder_Components);\n    pragma Inline (Optimize_Alignment_Space);\n@@ -7909,7 +7899,6 @@ package Einfo is\n    pragma Inline (Set_Normalized_Position);\n    pragma Inline (Set_Normalized_Position_Max);\n    pragma Inline (Set_OK_To_Reorder_Components);\n-   pragma Inline (Set_OK_To_Reference);\n    pragma Inline (Set_OK_To_Rename);\n    pragma Inline (Set_Optimize_Alignment_Space);\n    pragma Inline (Set_Optimize_Alignment_Time);"}, {"sha": "5fc7d4db48b99c2382c8b381e94adc50b58334b1", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b097d112828a037df20ac72ece37f771d321a1b/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b097d112828a037df20ac72ece37f771d321a1b/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=3b097d112828a037df20ac72ece37f771d321a1b", "patch": "@@ -4716,7 +4716,14 @@ package body Exp_Util is\n          --  some cases, and an assignment can modify the component\n          --  designated by N, so we need to create a temporary for it.\n \n+         --  The guard testing for Entity being present is needed at least\n+         --  in the case of rewritten predicate expressions, and may be\n+         --  appropriate elsewhere. Obviously we can't go testing the entity\n+         --  field if it does not exist, so it's reasonable to say that this\n+         --  is not the renaming case if it does not exist.\n+\n          elsif Is_Entity_Name (Original_Node (N))\n+           and then Present (Entity (Original_Node (N)))\n            and then Is_Renaming_Of_Object (Entity (Original_Node (N)))\n            and then Ekind (Entity (Original_Node (N))) /= E_Constant\n          then"}, {"sha": "a46ba87f488ed3efe012b689207a18da484f0af2", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 167, "deletions": 155, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b097d112828a037df20ac72ece37f771d321a1b/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b097d112828a037df20ac72ece37f771d321a1b/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=3b097d112828a037df20ac72ece37f771d321a1b", "patch": "@@ -134,6 +134,17 @@ package body Sem_Ch13 is\n    --  renaming_as_body. For tagged types, the specification is one of the\n    --  primitive specs.\n \n+   generic\n+      with procedure Replace_Type_Reference (N : Node_Id);\n+   procedure Replace_Type_References_Generic (N : Node_Id; TName : Name_Id);\n+   --  This is used to scan an expression for a predicate or invariant aspect\n+   --  replacing occurrences of the name TName (the name of the subtype to\n+   --  which the aspect applies) with appropriate references to the parameter\n+   --  of the predicate function or invariant procedure. The procedure passed\n+   --  as a generic parameter does the actual replacement of node N, which is\n+   --  either a simple direct reference to TName, or a selected component that\n+   --  represents an appropriately qualified occurrence of TName.\n+\n    procedure Set_Biased\n      (E      : Entity_Id;\n       N      : Node_Id;\n@@ -3552,56 +3563,46 @@ package body Sem_Ch13 is\n          Assoc : List_Id;\n          Str   : String_Id;\n \n-         function Replace_Node (N : Node_Id) return Traverse_Result;\n-         --  Process single node for traversal to replace type references\n+         procedure Replace_Type_Reference (N : Node_Id);\n+         --  Replace a single occurrence N of the subtype name with a reference\n+         --  to the formal of the predicate function. N can be an identifier\n+         --  referencing the subtype, or a selected component, representing an\n+         --  appropriately qualified occurrence of the subtype name.\n \n-         procedure Replace_Type is new Traverse_Proc (Replace_Node);\n-         --  Traverse an expression changing every occurrence of an entity\n-         --  reference to type T with a reference to the object argument.\n+         procedure Replace_Type_References is\n+           new Replace_Type_References_Generic (Replace_Type_Reference);\n+         --  Traverse an expression replacing all occurrences of the subtype\n+         --  name with appropriate references to the object that is the formal\n+         --  parameter of the predicate function.\n \n-         ------------------\n-         -- Replace_Node --\n-         ------------------\n+         ----------------------------\n+         -- Replace_Type_Reference --\n+         ----------------------------\n \n-         function Replace_Node (N : Node_Id) return Traverse_Result is\n+         procedure Replace_Type_Reference (N : Node_Id) is\n          begin\n-            --  Case of entity name referencing the type\n-\n-            if Is_Entity_Name (N)\n-              and then Entity (N) = T\n-            then\n-               --  Invariant'Class, replace with T'Class (obj)\n-\n-               if Class_Present (Ritem) then\n-                  Rewrite (N,\n-                    Make_Type_Conversion (Loc,\n-                      Subtype_Mark =>\n-                        Make_Attribute_Reference (Loc,\n-                          Prefix         =>\n-                            New_Occurrence_Of (T, Loc),\n-                          Attribute_Name => Name_Class),\n-                      Expression =>\n-                        Make_Identifier (Loc,\n-                          Chars => Object_Name)));\n-\n-               --  Invariant, replace with obj\n-\n-               else\n-                  Rewrite (N,\n-                    Make_Identifier (Loc,\n-                      Chars => Object_Name));\n-               end if;\n-\n-               --  All done with this node\n-\n-               return Skip;\n+            --  Invariant'Class, replace with T'Class (obj)\n+\n+            if Class_Present (Ritem) then\n+               Rewrite (N,\n+                 Make_Type_Conversion (Loc,\n+                   Subtype_Mark =>\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix         =>\n+                         New_Occurrence_Of (T, Loc),\n+                       Attribute_Name => Name_Class),\n+                   Expression =>\n+                     Make_Identifier (Loc,\n+                       Chars => Object_Name)));\n \n-            --  Not an instance of the type entity, keep going\n+            --  Invariant, replace with obj\n \n             else\n-               return OK;\n+               Rewrite (N,\n+                 Make_Identifier (Loc,\n+                   Chars => Object_Name));\n             end if;\n-         end Replace_Node;\n+         end Replace_Type_Reference;\n \n       --  Start of processing for Add_Invariants\n \n@@ -3642,21 +3643,9 @@ package body Sem_Ch13 is\n \n                --  We need to replace any occurrences of the name of the type\n                --  with references to the object, converted to type'Class in\n-               --  the case of Invariant'Class aspects. We do this by first\n-               --  doing a preanalysis, to identify all the entities, then\n-               --  we traverse looking for the type entity, and doing the\n-               --  necessary substitution. The preanalysis is done with the\n-               --  special OK_To_Reference flag set on the type, so that if\n-               --  we get an occurrence of this type, it will be reognized\n-               --  as legitimate.\n-\n-               Set_OK_To_Reference (T, True);\n-               Preanalyze_Spec_Expression (Exp, Standard_Boolean);\n-               Set_OK_To_Reference (T, False);\n+               --  the case of Invariant'Class aspects.\n \n-               --  Do the traversal\n-\n-               Replace_Type (Exp);\n+               Replace_Type_References (Exp, Chars (T));\n \n                --  Build first two arguments for Check pragma\n \n@@ -3833,9 +3822,6 @@ package body Sem_Ch13 is\n       FDecl : Node_Id;\n       FBody : Node_Id;\n \n-      TName : constant Name_Id := Chars (Typ);\n-      --  Name of the type, used for replacement in predicate expression\n-\n       Expr : Node_Id;\n       --  This is the expression for the return statement in the function. It\n       --  is build by connecting the component predicates with AND THEN.\n@@ -3911,107 +3897,26 @@ package body Sem_Ch13 is\n          Arg1  : Node_Id;\n          Arg2  : Node_Id;\n \n-         function Replace_Node (N : Node_Id) return Traverse_Result;\n-         --  Process single node for traversal to replace type references\n+         procedure Replace_Type_Reference (N : Node_Id);\n+         --  Replace a single occurrence N of the subtype name with a reference\n+         --  to the formal of the predicate function. N can be an identifier\n+         --  referencing the subtype, or a selected component, representing an\n+         --  appropriately qualified occurrence of the subtype name.\n \n-         procedure Replace_Type is new Traverse_Proc (Replace_Node);\n+         procedure Replace_Type_References is\n+           new Replace_Type_References_Generic (Replace_Type_Reference);\n          --  Traverse an expression changing every occurrence of an identifier\n-         --  whose name is TName with a reference to the object argument.\n+         --  whose name mathches the name of the subtype with a reference to\n+         --  the formal parameter of the predicate function.\n \n-         ------------------\n-         -- Replace_Node --\n-         ------------------\n-\n-         function Replace_Node (N : Node_Id) return Traverse_Result is\n-            S : Entity_Id;\n-            P : Node_Id;\n+         ----------------------------\n+         -- Replace_Type_Reference --\n+         ----------------------------\n \n+         procedure Replace_Type_Reference (N : Node_Id) is\n          begin\n-            --  Case of identifier\n-\n-            if Nkind (N) = N_Identifier then\n-\n-               --  If not the type name, all done with this node\n-\n-               if Chars (N) /= TName then\n-                  return Skip;\n-\n-               --  Otherwise do the replacement\n-\n-               else\n-                  goto Do_Replace;\n-               end if;\n-\n-               --  Case of selected component (which is what a qualification\n-               --  looks like in the unanalyzed tree, which is what we have.\n-\n-            elsif Nkind (N) = N_Selected_Component then\n-\n-               --  If selector name is not our type, keeping going (we might\n-               --  still have an occurrence of the type in the prefix).\n-\n-               if Nkind (Selector_Name (N)) /= N_Identifier\n-                 or else Chars (Selector_Name (N)) /= TName\n-               then\n-                  return OK;\n-\n-               --  Selector name is our type, check qualification\n-\n-               else\n-                  --  Loop through scopes and prefixes, doing comparison\n-\n-                  S := Current_Scope;\n-                  P := Prefix (N);\n-                  loop\n-                     --  Continue if no more scopes or scope with no name\n-\n-                     if No (S) or else Nkind (S) not in N_Has_Chars then\n-                        return OK;\n-                     end if;\n-\n-                     --  Do replace if prefix is an identifier matching the\n-                     --  scope that we are currently looking at.\n-\n-                     if Nkind (P) = N_Identifier\n-                       and then Chars (P) = Chars (S)\n-                     then\n-                        goto Do_Replace;\n-                     end if;\n-\n-                     --  Go check scope above us if prefix is itself of the\n-                     --  form of a selected component, whose selector matches\n-                     --  the scope we are currently looking at.\n-\n-                     if Nkind (P) = N_Selected_Component\n-                       and then Nkind (Selector_Name (P)) = N_Identifier\n-                       and then Chars (Selector_Name (P)) = Chars (S)\n-                     then\n-                        S := Scope (S);\n-                        P := Prefix (P);\n-\n-                     --  For anything else, we don't have a match, so keep on\n-                     --  going, there are still some weird cases where we may\n-                     --  still have a replacement within the prefix.\n-\n-                     else\n-                        return OK;\n-                     end if;\n-                  end loop;\n-               end if;\n-\n-            --  Continue for any other node kind\n-\n-            else\n-               return OK;\n-            end if;\n-\n-         <<Do_Replace>>\n-\n-            --  Replace with object\n-\n             Rewrite (N, Make_Identifier (Loc, Chars => Object_Name));\n-            return Skip;\n-         end Replace_Node;\n+         end Replace_Type_Reference;\n \n       --  Start of processing for Add_Predicates\n \n@@ -4036,7 +3941,7 @@ package body Sem_Ch13 is\n                   --  First We need to replace any occurrences of the name of\n                   --  the type with references to the object.\n \n-                  Replace_Type (Arg2);\n+                  Replace_Type_References (Arg2, Chars (Typ));\n \n                   --  OK, replacement complete, now we can add the expression\n \n@@ -6751,6 +6656,113 @@ package body Sem_Ch13 is\n       return False;\n    end Rep_Item_Too_Late;\n \n+   -------------------------------------\n+   -- Replace_Type_References_Generic --\n+   -------------------------------------\n+\n+   procedure Replace_Type_References_Generic (N : Node_Id; TName : Name_Id) is\n+\n+      function Replace_Node (N : Node_Id) return Traverse_Result;\n+      --  Processes a single node in the traversal procedure below, checking\n+      --  if node N should be replaced, and if so, doing the replacement.\n+\n+      procedure Replace_Type_Refs is new Traverse_Proc (Replace_Node);\n+      --  This instantiation provides the body of Replace_Type_References\n+\n+      ------------------\n+      -- Replace_Node --\n+      ------------------\n+\n+      function Replace_Node (N : Node_Id) return Traverse_Result is\n+         S : Entity_Id;\n+         P : Node_Id;\n+\n+      begin\n+         --  Case of identifier\n+\n+         if Nkind (N) = N_Identifier then\n+\n+            --  If not the type name, all done with this node\n+\n+            if Chars (N) /= TName then\n+               return Skip;\n+\n+            --  Otherwise do the replacement and we are done with this node\n+\n+            else\n+               Replace_Type_Reference (N);\n+               return Skip;\n+            end if;\n+\n+         --  Case of selected component (which is what a qualification\n+         --  looks like in the unanalyzed tree, which is what we have.\n+\n+         elsif Nkind (N) = N_Selected_Component then\n+\n+            --  If selector name is not our type, keeping going (we might\n+            --  still have an occurrence of the type in the prefix).\n+\n+            if Nkind (Selector_Name (N)) /= N_Identifier\n+              or else Chars (Selector_Name (N)) /= TName\n+            then\n+               return OK;\n+\n+            --  Selector name is our type, check qualification\n+\n+            else\n+               --  Loop through scopes and prefixes, doing comparison\n+\n+               S := Current_Scope;\n+               P := Prefix (N);\n+               loop\n+                  --  Continue if no more scopes or scope with no name\n+\n+                  if No (S) or else Nkind (S) not in N_Has_Chars then\n+                     return OK;\n+                  end if;\n+\n+                  --  Do replace if prefix is an identifier matching the\n+                  --  scope that we are currently looking at.\n+\n+                  if Nkind (P) = N_Identifier\n+                    and then Chars (P) = Chars (S)\n+                  then\n+                     Replace_Type_Reference (N);\n+                     return Skip;\n+                  end if;\n+\n+                  --  Go check scope above us if prefix is itself of the\n+                  --  form of a selected component, whose selector matches\n+                  --  the scope we are currently looking at.\n+\n+                  if Nkind (P) = N_Selected_Component\n+                    and then Nkind (Selector_Name (P)) = N_Identifier\n+                    and then Chars (Selector_Name (P)) = Chars (S)\n+                  then\n+                     S := Scope (S);\n+                     P := Prefix (P);\n+\n+                  --  For anything else, we don't have a match, so keep on\n+                  --  going, there are still some weird cases where we may\n+                  --  still have a replacement within the prefix.\n+\n+                  else\n+                     return OK;\n+                  end if;\n+               end loop;\n+            end if;\n+\n+            --  Continue for any other node kind\n+\n+         else\n+            return OK;\n+         end if;\n+      end Replace_Node;\n+\n+   begin\n+      Replace_Type_Refs (N);\n+   end Replace_Type_References_Generic;\n+\n    -------------------------\n    -- Same_Representation --\n    -------------------------"}, {"sha": "8d743f21cc964db897033175fc6ffb002d660926", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b097d112828a037df20ac72ece37f771d321a1b/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b097d112828a037df20ac72ece37f771d321a1b/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=3b097d112828a037df20ac72ece37f771d321a1b", "patch": "@@ -5584,13 +5584,6 @@ package body Sem_Ch4 is\n          return False;\n       end if;\n \n-      --  If OK_To_Reference is set for the entity, then don't complain, it\n-      --  means we are doing a preanalysis in which such complaints are wrong.\n-\n-      if OK_To_Reference (Entity (Enode)) then\n-         return False;\n-      end if;\n-\n       --  Now test the entity we got to see if it is a bad case\n \n       case Ekind (Entity (Enode)) is"}, {"sha": "5edc3425a0ef53e1a2d967e0ef3001fce0253710", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b097d112828a037df20ac72ece37f771d321a1b/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b097d112828a037df20ac72ece37f771d321a1b/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=3b097d112828a037df20ac72ece37f771d321a1b", "patch": "@@ -2011,7 +2011,7 @@ package body Sem_Ch5 is\n             Set_Etype (Def_Id, Component_Type (Typ));\n          else\n             Error_Msg_N\n-              (\"to iterate over the elements of an array, use 'O'F\", N);\n+              (\"to iterate over the elements of an array, use OF\", N);\n             Set_Etype (Def_Id, Etype (First_Index (Typ)));\n          end if;\n "}, {"sha": "9785348dc3e40857277fa6b2bf50e02fe3378348", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b097d112828a037df20ac72ece37f771d321a1b/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b097d112828a037df20ac72ece37f771d321a1b/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=3b097d112828a037df20ac72ece37f771d321a1b", "patch": "@@ -5481,9 +5481,6 @@ package body Sem_Ch8 is\n \n          --  Reference to type name in predicate/invariant expression\n \n-         elsif OK_To_Reference (Etype (P)) then\n-            Analyze_Selected_Component (N);\n-\n          elsif Is_Appropriate_For_Entry_Prefix (P_Type)\n            and then not In_Open_Scopes (P_Name)\n            and then (not Is_Concurrent_Type (Etype (P_Name))"}, {"sha": "cf710469c83e239923b8ecc7f8c211d96d2216f3", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b097d112828a037df20ac72ece37f771d321a1b/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b097d112828a037df20ac72ece37f771d321a1b/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=3b097d112828a037df20ac72ece37f771d321a1b", "patch": "@@ -5971,12 +5971,6 @@ package body Sem_Res is\n          then\n             null;\n \n-         --  Allow reference to type specifically marked as being OK in this\n-         --  context (this is used for example for type names in invariants).\n-\n-         elsif OK_To_Reference (E) then\n-            null;\n-\n          --  Any other use is an eror\n \n          else"}]}