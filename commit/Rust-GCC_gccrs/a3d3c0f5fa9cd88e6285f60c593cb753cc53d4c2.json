{"sha": "a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNkM2MwZjVmYTljZDg4ZTYyODVmNjBjNTkzY2I3NTNjYzUzZDRjMg==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2008-10-09T07:28:22Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2008-10-09T07:28:22Z"}, "message": "re PR fortran/35723 (Can't use run-time array element in character declaration)\n\n2008-10-09  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/35723\n\t* gfortran.h (gfc_suppress_error): Removed from header.\n\t(gfc_push_suppress_errors), (gfc_pop_suppress_errors): New methods.\n\t* array.c (gfc_array_size): Use new gfc_push/pop_suppress_errors\n\tinstead of directly changing gfc_suppress_error.\n\t* intrinsic.c (gfc_intrinsic_func_interface): Ditto.\n\t(gfc_intrinsic_sub_interface): Ditto.\n\t* error.c (suppress_errors): Made static from `gfc_suppress_error'.\n\t(gfc_push_suppress_errors), (gfc_pop_suppress_errors): New methods.\n\t(gfc_notify_std), (gfc_error): Use new static name of global.\n\t* expr.c (check_arglist), (check_references): New methods.\n\t(check_restricted): Check arglists and references of EXPR_FUNCTIONs\n\tand EXPR_VARAIBALEs, respectively.  Allow PARAMETER symbols.\n\n2008-10-09  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/35723\n\t* gfortran.dg/restricted_expression_1.f90: New test.\n\t* gfortran.dg/restricted_expression_2.f90: New test.\n\t* gfortran.dg/restricted_expression_3.f90: New test.\n\nFrom-SVN: r141001", "tree": {"sha": "d9580ac4df12f19afd82891b682e7616c40bfac2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9580ac4df12f19afd82891b682e7616c40bfac2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cdb148c194bac4a574cb77ee2522e418b9681860", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdb148c194bac4a574cb77ee2522e418b9681860", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdb148c194bac4a574cb77ee2522e418b9681860"}], "stats": {"total": 261, "additions": 238, "deletions": 23}, "files": [{"sha": "a2ca844018c02ebcd9dace236f29f99076ac68e7", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2", "patch": "@@ -1,3 +1,19 @@\n+2008-10-09  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/35723\n+\t* gfortran.h (gfc_suppress_error): Removed from header.\n+\t(gfc_push_suppress_errors), (gfc_pop_suppress_errors): New methods.\n+\t* array.c (gfc_array_size): Use new gfc_push/pop_suppress_errors\n+\tinstead of directly changing gfc_suppress_error.\n+\t* intrinsic.c (gfc_intrinsic_func_interface): Ditto.\n+\t(gfc_intrinsic_sub_interface): Ditto.\n+\t* error.c (suppress_errors): Made static from `gfc_suppress_error'.\n+\t(gfc_push_suppress_errors), (gfc_pop_suppress_errors): New methods.\n+\t(gfc_notify_std), (gfc_error): Use new static name of global.\n+\t* expr.c (check_arglist), (check_references): New methods.\n+\t(check_restricted): Check arglists and references of EXPR_FUNCTIONs\n+\tand EXPR_VARAIBALEs, respectively.  Allow PARAMETER symbols.\n+\n 2008-10-07  Jakub Jelinek  <jakub@redhat.com>\n \n \t* f95-lang.c (poplevel): Don't clear BLOCK_VARS if functionbody."}, {"sha": "70cf66294da8628fd02648a22a1d6f67dbca2b1c", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2", "patch": "@@ -2073,14 +2073,13 @@ gfc_array_size (gfc_expr *array, mpz_t *result)\n {\n   expand_info expand_save;\n   gfc_ref *ref;\n-  int i, flag;\n+  int i;\n   gfc_try t;\n \n   switch (array->expr_type)\n     {\n     case EXPR_ARRAY:\n-      flag = gfc_suppress_error;\n-      gfc_suppress_error = 1;\n+      gfc_push_suppress_errors ();\n \n       expand_save = current_expand;\n \n@@ -2091,7 +2090,8 @@ gfc_array_size (gfc_expr *array, mpz_t *result)\n       iter_stack = NULL;\n \n       t = expand_constructor (array->value.constructor);\n-      gfc_suppress_error = flag;\n+\n+      gfc_pop_suppress_errors ();\n \n       if (t == FAILURE)\n \tmpz_clear (*result);"}, {"sha": "a7005e9fbb61ba1915d2aef720ecbcfe16139b59", "filename": "gcc/fortran/error.c", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2", "patch": "@@ -30,13 +30,33 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"gfortran.h\"\n \n-int gfc_suppress_error = 0;\n+static int suppress_errors = 0;\n \n static int terminal_width, buffer_flag, errors, warnings;\n \n static gfc_error_buf error_buffer, warning_buffer, *cur_error_buffer;\n \n \n+/* Go one level deeper suppressing errors.  */\n+\n+void\n+gfc_push_suppress_errors (void)\n+{\n+  gcc_assert (suppress_errors >= 0);\n+  ++suppress_errors;\n+}\n+\n+\n+/* Leave one level of error suppressing.  */\n+\n+void\n+gfc_pop_suppress_errors (void)\n+{\n+  gcc_assert (suppress_errors > 0);\n+  --suppress_errors;\n+}\n+\n+\n /* Per-file error initialization.  */\n \n void\n@@ -764,7 +784,7 @@ gfc_notify_std (int std, const char *nocmsgid, ...)\n   if ((gfc_option.allow_std & std) != 0 && !warning)\n     return SUCCESS;\n \n-  if (gfc_suppress_error)\n+  if (suppress_errors)\n     return warning ? SUCCESS : FAILURE;\n \n   cur_error_buffer = warning ? &warning_buffer : &error_buffer;\n@@ -850,7 +870,7 @@ gfc_error (const char *nocmsgid, ...)\n {\n   va_list argp;\n \n-  if (gfc_suppress_error)\n+  if (suppress_errors)\n     return;\n \n   error_buffer.flag = 1;"}, {"sha": "5a167b7067f8c094774b8536dff9b0cbe0c2630b", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 80, "deletions": 3, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2", "patch": "@@ -2503,14 +2503,72 @@ restricted_intrinsic (gfc_expr *e)\n }\n \n \n+/* Check the expressions of an actual arglist.  Used by check_restricted.  */\n+\n+static gfc_try\n+check_arglist (gfc_actual_arglist* arg, gfc_try (*checker) (gfc_expr*))\n+{\n+  for (; arg; arg = arg->next)\n+    if (checker (arg->expr) == FAILURE)\n+      return FAILURE;\n+\n+  return SUCCESS;\n+}\n+\n+\n+/* Check the subscription expressions of a reference chain with a checking\n+   function; used by check_restricted.  */\n+\n+static gfc_try\n+check_references (gfc_ref* ref, gfc_try (*checker) (gfc_expr*))\n+{\n+  int dim;\n+\n+  if (!ref)\n+    return SUCCESS;\n+\n+  switch (ref->type)\n+    {\n+    case REF_ARRAY:\n+      for (dim = 0; dim != ref->u.ar.dimen; ++dim)\n+\t{\n+\t  if (checker (ref->u.ar.start[dim]) == FAILURE)\n+\t    return FAILURE;\n+\t  if (checker (ref->u.ar.end[dim]) == FAILURE)\n+\t    return FAILURE;\n+\t  if (checker (ref->u.ar.stride[dim]) == FAILURE)\n+\t    return FAILURE;\n+\t}\n+      break;\n+\n+    case REF_COMPONENT:\n+      /* Nothing needed, just proceed to next reference.  */\n+      break;\n+\n+    case REF_SUBSTRING:\n+      if (checker (ref->u.ss.start) == FAILURE)\n+\treturn FAILURE;\n+      if (checker (ref->u.ss.end) == FAILURE)\n+\treturn FAILURE;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+\n+  return check_references (ref->next, checker);\n+}\n+\n+\n /* Verify that an expression is a restricted expression.  Like its\n    cousin check_init_expr(), an error message is generated if we\n    return FAILURE.  */\n \n static gfc_try\n check_restricted (gfc_expr *e)\n {\n-  gfc_symbol *sym;\n+  gfc_symbol* sym;\n   gfc_try t;\n \n   if (e == NULL)\n@@ -2526,8 +2584,22 @@ check_restricted (gfc_expr *e)\n       break;\n \n     case EXPR_FUNCTION:\n-      t = e->value.function.esym ? external_spec_function (e)\n-\t\t\t\t : restricted_intrinsic (e);\n+      if (e->value.function.esym)\n+\t{\n+\t  t = check_arglist (e->value.function.actual, &check_restricted);\n+\t  if (t == SUCCESS)\n+\t    t = external_spec_function (e);\n+\t}\n+      else\n+\t{\n+\t  if (e->value.function.isym && e->value.function.isym->inquiry)\n+\t    t = SUCCESS;\n+\t  else\n+\t    t = check_arglist (e->value.function.actual, &check_restricted);\n+\n+\t  if (t == SUCCESS)\n+\t    t = restricted_intrinsic (e);\n+\t}\n       break;\n \n     case EXPR_VARIABLE:\n@@ -2561,6 +2633,10 @@ check_restricted (gfc_expr *e)\n \t  break;\n \t}\n \n+      /* Check reference chain if any.  */\n+      if (check_references (e->ref, &check_restricted) == FAILURE)\n+\tbreak;\n+\n       /* gfc_is_formal_arg broadcasts that a formal argument list is being\n \t processed in resolve.c(resolve_formal_arglist).  This is done so\n \t that host associated dummy array indices are accepted (PR23446).\n@@ -2571,6 +2647,7 @@ check_restricted (gfc_expr *e)\n \t    || sym->attr.use_assoc\n \t    || sym->attr.dummy\n \t    || sym->attr.implied_index\n+\t    || sym->attr.flavor == FL_PARAMETER\n \t    || (sym->ns && sym->ns == gfc_current_ns->parent)\n \t    || (sym->ns && gfc_current_ns->parent\n \t\t  && sym->ns == gfc_current_ns->parent->parent)"}, {"sha": "42f5516b746b067db6bb323caa6375a9e9c568b8", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2", "patch": "@@ -770,7 +770,10 @@ typedef struct\n #endif\n \n \n-extern int gfc_suppress_error;\n+/* Suppress error messages or re-enable them.  */\n+\n+void gfc_push_suppress_errors (void);\n+void gfc_pop_suppress_errors (void);\n \n \n /* Character length structures hold the expression that gives the"}, {"sha": "7acdcb05e6080d514a6e9166eaa3bb51c4d87d92", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2", "patch": "@@ -3598,7 +3598,8 @@ gfc_intrinsic_func_interface (gfc_expr *expr, int error_flag)\n     return (do_simplify (expr->value.function.isym, expr) == FAILURE)\n \t   ? MATCH_ERROR : MATCH_YES;\n \n-  gfc_suppress_error = !error_flag;\n+  if (!error_flag)\n+    gfc_push_suppress_errors ();\n   flag = 0;\n \n   for (actual = expr->value.function.actual; actual; actual = actual->next)\n@@ -3611,7 +3612,8 @@ gfc_intrinsic_func_interface (gfc_expr *expr, int error_flag)\n   isym = specific = gfc_find_function (name);\n   if (isym == NULL)\n     {\n-      gfc_suppress_error = 0;\n+      if (!error_flag)\n+\tgfc_pop_suppress_errors ();\n       return MATCH_NO;\n     }\n \n@@ -3621,7 +3623,11 @@ gfc_intrinsic_func_interface (gfc_expr *expr, int error_flag)\n       && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Function '%s' \"\n \t\t\t \"as initialization expression at %L\", name,\n \t\t\t &expr->where) == FAILURE)\n-    return MATCH_ERROR;\n+    {\n+      if (!error_flag)\n+\tgfc_pop_suppress_errors ();\n+      return MATCH_ERROR;\n+    }\n \n   gfc_current_intrinsic_where = &expr->where;\n \n@@ -3633,15 +3639,16 @@ gfc_intrinsic_func_interface (gfc_expr *expr, int error_flag)\n       if (gfc_check_min_max (expr->value.function.actual) == SUCCESS)\n \tgoto got_specific;\n \n-      gfc_suppress_error = 0;\n+      if (!error_flag)\n+\tgfc_pop_suppress_errors ();\n       return MATCH_NO;\n     }\n \n   /* If the function is generic, check all of its specific\n      incarnations.  If the generic name is also a specific, we check\n      that name last, so that any error message will correspond to the\n      specific.  */\n-  gfc_suppress_error = 1;\n+  gfc_push_suppress_errors ();\n \n   if (isym->generic)\n     {\n@@ -3651,15 +3658,19 @@ gfc_intrinsic_func_interface (gfc_expr *expr, int error_flag)\n \t  if (specific == isym)\n \t    continue;\n \t  if (check_specific (specific, expr, 0) == SUCCESS)\n-\t    goto got_specific;\n+\t    {\n+\t      gfc_pop_suppress_errors ();\n+\t      goto got_specific;\n+\t    }\n \t}\n     }\n \n-  gfc_suppress_error = !error_flag;\n+  gfc_pop_suppress_errors ();\n \n   if (check_specific (isym, expr, error_flag) == FAILURE)\n     {\n-      gfc_suppress_error = 0;\n+      if (!error_flag)\n+\tgfc_pop_suppress_errors ();\n       return MATCH_NO;\n     }\n \n@@ -3669,7 +3680,9 @@ gfc_intrinsic_func_interface (gfc_expr *expr, int error_flag)\n   expr->value.function.isym = specific;\n   gfc_intrinsic_symbol (expr->symtree->n.sym);\n \n-  gfc_suppress_error = 0;\n+  if (!error_flag)\n+    gfc_pop_suppress_errors ();\n+\n   if (do_simplify (specific, expr) == FAILURE)\n     return MATCH_ERROR;\n \n@@ -3709,7 +3722,8 @@ gfc_intrinsic_sub_interface (gfc_code *c, int error_flag)\n   if (isym == NULL)\n     return MATCH_NO;\n \n-  gfc_suppress_error = !error_flag;\n+  if (!error_flag)\n+    gfc_push_suppress_errors ();\n \n   init_arglist (isym);\n \n@@ -3729,7 +3743,8 @@ gfc_intrinsic_sub_interface (gfc_code *c, int error_flag)\n \n   /* The subroutine corresponds to an intrinsic.  Allow errors to be\n      seen at this point.  */\n-  gfc_suppress_error = 0;\n+  if (!error_flag)\n+    gfc_pop_suppress_errors ();\n \n   if (isym->resolve.s1 != NULL)\n     isym->resolve.s1 (c);\n@@ -3751,7 +3766,8 @@ gfc_intrinsic_sub_interface (gfc_code *c, int error_flag)\n   return MATCH_YES;\n \n fail:\n-  gfc_suppress_error = 0;\n+  if (!error_flag)\n+    gfc_pop_suppress_errors ();\n   return MATCH_NO;\n }\n "}, {"sha": "2e61e8ca8a49842ccdf9180cf74ea0acbd02deb4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2", "patch": "@@ -1,3 +1,10 @@\n+2008-10-09  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/35723\n+\t* gfortran.dg/restricted_expression_1.f90: New test.\n+\t* gfortran.dg/restricted_expression_2.f90: New test.\n+\t* gfortran.dg/restricted_expression_3.f90: New test.\n+\n 2008-10-08  Jerry DeLisle  <jvdelisle@gcc.gnu.org\n \n \tPR libfortran/37707"}, {"sha": "45211a585f4006e660043b1561c493821c4b5e89", "filename": "gcc/testsuite/gfortran.dg/restricted_expression_1.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2/gcc%2Ftestsuite%2Fgfortran.dg%2Frestricted_expression_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2/gcc%2Ftestsuite%2Fgfortran.dg%2Frestricted_expression_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frestricted_expression_1.f90?ref=a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do compile }\n+! { dg-options \"-pedantic -ffixed-form\" }\n+\n+! PR fortran/35723\n+! An argument subscript into a parameter array was not allowed as\n+! dimension.  Check this is fixed.\n+\n+! Contributed by Dick Hendrickson <dick.hendrickson@gmail.com>\n+\n+      call       vf0016(  1,  2,  3)\n+\n+      end\n+      SUBROUTINE VF0016(nf1,nf2,nf3)\n+      CHARACTER(LEN=9,KIND=1),DIMENSION(3), PARAMETER\n+     $     ::  TEST_STRINGS =\n+     $  (/'       HI','ABC      ','  CDEFG  '/)\n+      CHARACTER :: TEST_ARRAY\n+     $(LEN_TRIM(ADJUSTL(TEST_STRINGS(nf1))),\n+     $ SUM(LEN_TRIM(ADJUSTL(TEST_STRINGS))),\n+     $ LEN_TRIM(ADJUSTL(ADJUSTR(TEST_STRINGS(3)))),\n+     $ SUM(LEN_TRIM(ADJUSTL(ADJUSTR(TEST_STRINGS(NF1:NF3:NF2)))))   )\n+\n+       print *, 2, 10, 5, 7\n+       print *, shape (test_array)\n+         end"}, {"sha": "9c281664a84133897430f7af66746d2977c22e25", "filename": "gcc/testsuite/gfortran.dg/restricted_expression_2.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2/gcc%2Ftestsuite%2Fgfortran.dg%2Frestricted_expression_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2/gcc%2Ftestsuite%2Fgfortran.dg%2Frestricted_expression_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frestricted_expression_2.f90?ref=a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do compile }\n+! { dg-options \"-pedantic -ffixed-form\" }\n+\n+! PR fortran/35723\n+! Check that a program using a local variable subscript is still rejected.\n+\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+\n+      call       vf0016(  1,  2,  3)\n+\n+      end\n+      SUBROUTINE VF0016(nf1,nf2,nf3)\n+      CHARACTER(LEN=9,KIND=1),DIMENSION(3), PARAMETER\n+     $     ::  TEST_STRINGS =\n+     $  (/'       HI','ABC      ','  CDEFG  '/)\n+      INTEGER :: i = 2\n+      CHARACTER :: TEST_ARRAY\n+     $(LEN_TRIM(ADJUSTL(TEST_STRINGS(i))), ! { dg-error \"'i' cannot appear\" }\n+     $ SUM(LEN_TRIM(ADJUSTL(TEST_STRINGS))),\n+     $ LEN_TRIM(ADJUSTL(ADJUSTR(TEST_STRINGS(3)))),\n+     $ SUM(LEN_TRIM(ADJUSTL(ADJUSTR(TEST_STRINGS(NF1:NF3:NF2)))))   )\n+\n+       print *, 2, 10, 5, 7\n+       print *, shape (test_array)\n+         end"}, {"sha": "0b84f67aa58835e9a7e8be916688ef815bfce47a", "filename": "gcc/testsuite/gfortran.dg/restricted_expression_3.f90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2/gcc%2Ftestsuite%2Fgfortran.dg%2Frestricted_expression_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2/gcc%2Ftestsuite%2Fgfortran.dg%2Frestricted_expression_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frestricted_expression_3.f90?ref=a3d3c0f5fa9cd88e6285f60c593cb753cc53d4c2", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do compile }\n+\n+! PR fortran/35723\n+! Check that a dummy-argument array with non-restricted subscript is\n+! rejected and some more reference-checks.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+  CALL test (5, (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /), \"0123456789\" )\n+\n+CONTAINS\n+\n+  SUBROUTINE test (n, arr, str)\n+    IMPLICIT NONE\n+    INTEGER :: n, arr(:)\n+    CHARACTER(len=10) :: str\n+\n+    INTEGER :: i = 5\n+    INTEGER :: ok1(arr(n)), ok2(LEN_TRIM (str(3:n)))\n+    INTEGER :: ok3(LEN_TRIM(\"hello, world!\"(2:n)))\n+    INTEGER :: wrong1(arr(i)) ! { dg-error \"'i' cannot appear\" }\n+    INTEGER :: wrong2(LEN_TRIM (str(i:n))) ! { dg-error \"'i' cannot appear\" }\n+    INTEGER :: wrong3(LEN_TRIM (\"hello, world!\"(i:n))) ! { dg-error \"'i' cannot appear\" }\n+  END SUBROUTINE test\n+\n+END PROGRAM main"}]}