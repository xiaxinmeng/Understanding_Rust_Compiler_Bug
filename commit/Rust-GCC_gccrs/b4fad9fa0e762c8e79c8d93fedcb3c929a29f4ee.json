{"sha": "b4fad9fa0e762c8e79c8d93fedcb3c929a29f4ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRmYWQ5ZmEwZTc2MmM4ZTc5YzhkOTNmZWRjYjNjOTI5YTI5ZjRlZQ==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2017-01-23T13:34:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-23T13:34:31Z"}, "message": "sem_util.adb (New_Copy_Tree): Code cleanup: removal of the internal map (ie.\n\n2017-01-23  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_util.adb (New_Copy_Tree): Code cleanup:\n\tremoval of the internal map (ie. variable Actual_Map, its\n\tassociated local variables, and all the code handling it).\n\t* sem_ch9.adb (Analyze_Task_Type_Declaration): in GNATprove mode\n\tforce loading of the System package when processing a task type.\n\t(Analyze_Protected_Type_Declaration): in GNATprove mode force\n\tloading of the System package when processing a protected type.\n\t* sem_ch10.adb (Analyze_Compilation_Unit): in GNATprove mode\n\tforce loading of the System package when processing compilation\n\tunit with a main-like subprogram.\n\t* frontend.adb (Frontend): remove forced loading of the System\n\tpackage.\n\nFrom-SVN: r244810", "tree": {"sha": "009925b6d917321a7009e702bcf3b6c9a0c6ee73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/009925b6d917321a7009e702bcf3b6c9a0c6ee73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4fad9fa0e762c8e79c8d93fedcb3c929a29f4ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4fad9fa0e762c8e79c8d93fedcb3c929a29f4ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4fad9fa0e762c8e79c8d93fedcb3c929a29f4ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4fad9fa0e762c8e79c8d93fedcb3c929a29f4ee/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d268147dea8efee7a66e409e7cba492ab4679f29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d268147dea8efee7a66e409e7cba492ab4679f29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d268147dea8efee7a66e409e7cba492ab4679f29"}], "stats": {"total": 365, "additions": 134, "deletions": 231}, "files": [{"sha": "674ca6fd1c1eb8d8a5b8e3dbfb9a3bf6e880cc30", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4fad9fa0e762c8e79c8d93fedcb3c929a29f4ee/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4fad9fa0e762c8e79c8d93fedcb3c929a29f4ee/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b4fad9fa0e762c8e79c8d93fedcb3c929a29f4ee", "patch": "@@ -1,3 +1,18 @@\n+2017-01-23  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_util.adb (New_Copy_Tree): Code cleanup:\n+\tremoval of the internal map (ie. variable Actual_Map, its\n+\tassociated local variables, and all the code handling it).\n+\t* sem_ch9.adb (Analyze_Task_Type_Declaration): in GNATprove mode\n+\tforce loading of the System package when processing a task type.\n+\t(Analyze_Protected_Type_Declaration): in GNATprove mode force\n+\tloading of the System package when processing a protected type.\n+\t* sem_ch10.adb (Analyze_Compilation_Unit): in GNATprove mode\n+\tforce loading of the System package when processing compilation\n+\tunit with a main-like subprogram.\n+\t* frontend.adb (Frontend): remove forced loading of the System\n+\tpackage.\n+\n 2017-01-23  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_prag.adb (Default_Initial_Condition): If the desired type"}, {"sha": "612f55484fbb8a929cdc8ba6d23deb70d25f3178", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4fad9fa0e762c8e79c8d93fedcb3c929a29f4ee/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4fad9fa0e762c8e79c8d93fedcb3c929a29f4ee/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=b4fad9fa0e762c8e79c8d93fedcb3c929a29f4ee", "patch": "@@ -463,23 +463,6 @@ begin\n       end if;\n    end if;\n \n-   --  In GNATprove mode, force the loading of a few RTE units. This step is\n-   --  skipped if we had a fatal error during parsing.\n-\n-   if GNATprove_Mode\n-     and then Fatal_Error (Main_Unit) /= Error_Detected\n-   then\n-      declare\n-         Unused : Entity_Id;\n-\n-      begin\n-         --  Ensure that System.Interrupt_Priority is available to GNATprove\n-         --  for the generation of VCs related to ceiling priority.\n-\n-         Unused := RTE (RE_Interrupt_Priority);\n-      end;\n-   end if;\n-\n    --  Qualify all entity names in inner packages, package bodies, etc\n \n    Exp_Dbug.Qualify_All_Entity_Names;"}, {"sha": "f4268a0d903a1e8113eed170c9f47527a8c0cd8d", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4fad9fa0e762c8e79c8d93fedcb3c929a29f4ee/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4fad9fa0e762c8e79c8d93fedcb3c929a29f4ee/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=b4fad9fa0e762c8e79c8d93fedcb3c929a29f4ee", "patch": "@@ -1133,6 +1133,48 @@ package body Sem_Ch10 is\n \n             Style_Check := Save_Style_Check;\n          end;\n+\n+         --  In GNATprove mode, force the loading of a Interrupt_Priority when\n+         --  processing compilation units with potentially \"main\" subprograms.\n+         --  This is required for the ceiling priority protocol checks, which\n+         --  are trigerred by these subprograms.\n+\n+         if GNATprove_Mode\n+           and then Nkind_In (Unit_Node, N_Subprogram_Body,\n+                                         N_Procedure_Instantiation,\n+                                         N_Function_Instantiation)\n+         then\n+            declare\n+               Spec   : Node_Id;\n+               Unused : Entity_Id;\n+\n+            begin\n+               case Nkind (Unit_Node) is\n+                  when N_Subprogram_Body =>\n+                     Spec := Specification (Unit_Node);\n+\n+                  when N_Subprogram_Instantiation =>\n+                     Spec :=\n+                       Subprogram_Specification (Entity (Name (Unit_Node)));\n+\n+                  when others =>\n+                     raise Program_Error;\n+               end case;\n+\n+               pragma Assert (Nkind (Spec) in N_Subprogram_Specification);\n+\n+               --  Only subprogram with no parameters can act as \"main\", and if\n+               --  it is a function, it needs to return an integer.\n+\n+               if No (Parameter_Specifications (Spec))\n+                 and then (Nkind (Spec) = N_Procedure_Specification\n+                             or else\n+                           Is_Integer_Type (Etype (Result_Definition (Spec))))\n+               then\n+                  Unused := RTE (RE_Interrupt_Priority);\n+               end if;\n+            end;\n+         end if;\n       end if;\n \n       --  Deal with creating elaboration counter if needed. We create an"}, {"sha": "efca9fcd8fc2aa68b3d6828b6434225b37318336", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4fad9fa0e762c8e79c8d93fedcb3c929a29f4ee/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4fad9fa0e762c8e79c8d93fedcb3c929a29f4ee/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=b4fad9fa0e762c8e79c8d93fedcb3c929a29f4ee", "patch": "@@ -2257,6 +2257,19 @@ package body Sem_Ch9 is\n             Process_Full_View (N, T, Def_Id);\n          end if;\n       end if;\n+\n+      --  In GNATprove mode, force the loading of a Interrupt_Priority, which\n+      --  is required for the ceiling priority protocol checks trigerred by\n+      --  calls originating from protected subprograms and entries.\n+\n+      if GNATprove_Mode then\n+         declare\n+            Unused : Entity_Id;\n+\n+         begin\n+            Unused := RTE (RE_Interrupt_Priority);\n+         end;\n+      end if;\n    end Analyze_Protected_Type_Declaration;\n \n    ---------------------\n@@ -3196,6 +3209,19 @@ package body Sem_Ch9 is\n             Process_Full_View (N, T, Def_Id);\n          end if;\n       end if;\n+\n+      --  In GNATprove mode, force the loading of a Interrupt_Priority, which\n+      --  is required for the ceiling priority protocol checks trigerred by\n+      --  calls originating from tasks.\n+\n+      if GNATprove_Mode then\n+         declare\n+            Unused : Entity_Id;\n+\n+         begin\n+            Unused := RTE (RE_Interrupt_Priority);\n+         end;\n+      end if;\n    end Analyze_Task_Type_Declaration;\n \n    -----------------------------------"}, {"sha": "1d78642e659fb2314bf71256cfb4624a0cf7bed7", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 51, "deletions": 214, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4fad9fa0e762c8e79c8d93fedcb3c929a29f4ee/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4fad9fa0e762c8e79c8d93fedcb3c929a29f4ee/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=b4fad9fa0e762c8e79c8d93fedcb3c929a29f4ee", "patch": "@@ -16227,31 +16227,6 @@ package body Sem_Util is\n       New_Sloc  : Source_Ptr := No_Location;\n       New_Scope : Entity_Id  := Empty) return Node_Id\n    is\n-      Actual_Map : Elist_Id := Map;\n-      --  This is the actual map for the copy. It is initialized with the given\n-      --  elements, and then enlarged as required for Itypes that are copied\n-      --  during the first phase of the copy operation. The visit procedures\n-      --  add elements to this map as Itypes are encountered. The reason we\n-      --  cannot use Map directly, is that it may well be (and normally is)\n-      --  initialized to No_Elist, and if we have mapped entities, we have to\n-      --  reset it to point to a real Elist.\n-\n-      NCT_Hash_Threshold : constant := 20;\n-      --  If there are more than this number of pairs of entries in the map,\n-      --  then Hash_Tables_Used will be set, and the hash tables will be\n-      --  initialized and used for the searches.\n-\n-      NCT_Hash_Tables_Used : Boolean := False;\n-      --  Set to True if hash tables are in use\n-\n-      NCT_Table_Entries : Nat := 0;\n-      --  Count entries in table to see if threshold is reached\n-\n-      NCT_Hash_Table_Setup : Boolean := False;\n-      --  Set to True if hash table contains data. We set this True if we setup\n-      --  the hash table with data. This is a signal that we must clear its\n-      --  contents before returning the tree copy.\n-\n       ------------------------------------\n       -- Auxiliary Data and Subprograms --\n       ------------------------------------\n@@ -16312,11 +16287,11 @@ package body Sem_Util is\n \n       function Assoc (N : Node_Or_Entity_Id) return Node_Id;\n       --  Called during second phase to map entities into their corresponding\n-      --  copies using Actual_Map. If the argument is not an entity, or is not\n-      --  in Actual_Map, then it is returned unchanged.\n+      --  copies using the hash table. If the argument is not an entity, or is\n+      --  not in the hash table, then it is returned unchanged.\n \n       procedure Build_NCT_Hash_Tables;\n-      --  Builds hash tables (number of elements >= threshold value)\n+      --  Builds hash tables.\n \n       function Copy_Elist_With_Replacement\n         (Old_Elist : Elist_Id) return Elist_Id;\n@@ -16358,33 +16333,18 @@ package body Sem_Util is\n       -----------\n \n       function Assoc (N : Node_Or_Entity_Id) return Node_Id is\n-         E   : Elmt_Id;\n          Ent : Entity_Id;\n \n       begin\n-         if not Has_Extension (N) or else No (Actual_Map) then\n+         if Nkind (N) not in N_Entity then\n             return N;\n \n-         elsif NCT_Hash_Tables_Used then\n+         else\n             Ent := NCT_Assoc.Get (Entity_Id (N));\n \n             if Present (Ent) then\n                return Ent;\n-            else\n-               return N;\n             end if;\n-\n-         --  No hash table used, do serial search\n-\n-         else\n-            E := First_Elmt (Actual_Map);\n-            while Present (E) loop\n-               if Node (E) = N then\n-                  return Node (Next_Elmt (E));\n-               else\n-                  E := Next_Elmt (Next_Elmt (E));\n-               end if;\n-            end loop;\n          end if;\n \n          return N;\n@@ -16399,7 +16359,11 @@ package body Sem_Util is\n          Ent  : Entity_Id;\n \n       begin\n-         Elmt := First_Elmt (Actual_Map);\n+         if No (Map) then\n+            return;\n+         end if;\n+\n+         Elmt := First_Elmt (Map);\n          while Present (Elmt) loop\n             Ent := Node (Elmt);\n \n@@ -16427,9 +16391,6 @@ package body Sem_Util is\n \n             Next_Elmt (Elmt);\n          end loop;\n-\n-         NCT_Hash_Tables_Used := True;\n-         NCT_Hash_Table_Setup := True;\n       end Build_NCT_Hash_Tables;\n \n       ---------------------------------\n@@ -16678,7 +16639,7 @@ package body Sem_Util is\n          if Old_Node <= Empty_Or_Error then\n             return Old_Node;\n \n-         elsif Has_Extension (Old_Node) then\n+         elsif Nkind (Old_Node) in N_Entity then\n             return Assoc (Old_Node);\n \n          else\n@@ -16688,39 +16649,14 @@ package body Sem_Util is\n             --  previously copied Itype, then adjust the associated node\n             --  of the copy of that Itype accordingly.\n \n-            if Present (Actual_Map) then\n-               declare\n-                  E   : Elmt_Id;\n-                  Ent : Entity_Id;\n-\n-               begin\n-                  --  Case of hash table used\n-\n-                  if NCT_Hash_Tables_Used then\n-                     Ent := NCT_Itype_Assoc.Get (Old_Node);\n-\n-                     if Present (Ent) then\n-                        Set_Associated_Node_For_Itype (Ent, New_Node);\n-                     end if;\n-\n-                  --  Case of no hash table used\n-\n-                  else\n-                     E := First_Elmt (Actual_Map);\n-                     while Present (E) loop\n-                        if Is_Itype (Node (E))\n-                          and then\n-                            Old_Node = Associated_Node_For_Itype (Node (E))\n-                        then\n-                           Set_Associated_Node_For_Itype\n-                             (Node (Next_Elmt (E)), New_Node);\n-                        end if;\n+            declare\n+               Ent : constant Entity_Id := NCT_Itype_Assoc.Get (Old_Node);\n \n-                        E := Next_Elmt (Next_Elmt (E));\n-                     end loop;\n-                  end if;\n-               end;\n-            end if;\n+            begin\n+               if Present (Ent) then\n+                  Set_Associated_Node_For_Itype (Ent, New_Node);\n+               end if;\n+            end;\n \n             --  Recursively copy descendants\n \n@@ -16846,7 +16782,7 @@ package body Sem_Util is\n             --  would catch it, but it is a common case (Etype pointing to\n             --  itself for an Itype that is a base type).\n \n-            elsif Has_Extension (Node_Id (F))\n+            elsif Nkind (Node_Id (F)) in N_Entity\n               and then Is_Itype (Entity_Id (F))\n               and then Node_Id (F) /= N\n             then\n@@ -16884,7 +16820,6 @@ package body Sem_Util is\n \n       procedure Visit_Itype (Old_Itype : Entity_Id) is\n          New_Itype : Entity_Id;\n-         E         : Elmt_Id;\n          Ent       : Entity_Id;\n \n       begin\n@@ -16913,50 +16848,23 @@ package body Sem_Util is\n          --  node of some previously copied Itype, then we set the right\n          --  pointer in the other direction.\n \n-         if Present (Actual_Map) then\n-\n-            --  Case of hash tables used\n-\n-            if NCT_Hash_Tables_Used then\n-               Ent := NCT_Assoc.Get (Associated_Node_For_Itype (Old_Itype));\n-\n-               if Present (Ent) then\n-                  Set_Associated_Node_For_Itype (New_Itype, Ent);\n-               end if;\n-\n-               Ent := NCT_Itype_Assoc.Get (Old_Itype);\n-\n-               if Present (Ent) then\n-                  Set_Associated_Node_For_Itype (Ent, New_Itype);\n-\n-               --  If the hash table has no association for this Itype and its\n-               --  associated node, enter one now.\n+         Ent := NCT_Assoc.Get (Associated_Node_For_Itype (Old_Itype));\n \n-               else\n-                  NCT_Itype_Assoc.Set\n-                    (Associated_Node_For_Itype (Old_Itype), New_Itype);\n-               end if;\n+         if Present (Ent) then\n+            Set_Associated_Node_For_Itype (New_Itype, Ent);\n+         end if;\n \n-            --  Case of hash tables not used\n+         Ent := NCT_Itype_Assoc.Get (Old_Itype);\n \n-            else\n-               E := First_Elmt (Actual_Map);\n-               while Present (E) loop\n-                  if Associated_Node_For_Itype (Old_Itype) = Node (E) then\n-                     Set_Associated_Node_For_Itype\n-                       (New_Itype, Node (Next_Elmt (E)));\n-                  end if;\n+         if Present (Ent) then\n+            Set_Associated_Node_For_Itype (Ent, New_Itype);\n \n-                  if Is_Type (Node (E))\n-                    and then Old_Itype = Associated_Node_For_Itype (Node (E))\n-                  then\n-                     Set_Associated_Node_For_Itype\n-                       (Node (Next_Elmt (E)), New_Itype);\n-                  end if;\n+         --  If the hash table has no association for this Itype and its\n+         --  associated node, enter one now.\n \n-                  E := Next_Elmt (Next_Elmt (E));\n-               end loop;\n-            end if;\n+         else\n+            NCT_Itype_Assoc.Set\n+              (Associated_Node_For_Itype (Old_Itype), New_Itype);\n          end if;\n \n          if Present (Freeze_Node (New_Itype)) then\n@@ -16966,23 +16874,7 @@ package body Sem_Util is\n \n          --  Add new association to map\n \n-         if No (Actual_Map) then\n-            Actual_Map := New_Elmt_List;\n-         end if;\n-\n-         Append_Elmt (Old_Itype, Actual_Map);\n-         Append_Elmt (New_Itype, Actual_Map);\n-\n-         if NCT_Hash_Tables_Used then\n-            NCT_Assoc.Set (Old_Itype, New_Itype);\n-\n-         else\n-            NCT_Table_Entries := NCT_Table_Entries + 1;\n-\n-            if NCT_Table_Entries > NCT_Hash_Threshold then\n-               Build_NCT_Hash_Tables;\n-            end if;\n-         end if;\n+         NCT_Assoc.Set (Old_Itype, New_Itype);\n \n          --  If a record subtype is simply copied, the entity list will be\n          --  shared. Thus cloned_Subtype must be set to indicate the sharing.\n@@ -17041,36 +16933,14 @@ package body Sem_Util is\n       begin\n          --  Handle case of an Itype, which must be copied\n \n-         if Has_Extension (N) and then Is_Itype (N) then\n+         if Nkind (N) in N_Entity and then Is_Itype (N) then\n \n             --  Nothing to do if already in the list. This can happen with an\n             --  Itype entity that appears more than once in the tree. Note that\n             --  we do not want to visit descendants in this case.\n \n-            --  Test for already in list when hash table is used\n-\n-            if NCT_Hash_Tables_Used then\n-               if Present (NCT_Assoc.Get (Entity_Id (N))) then\n-                  return;\n-               end if;\n-\n-            --  Test for already in list when hash table not used\n-\n-            else\n-               declare\n-                  E : Elmt_Id;\n-               begin\n-                  if Present (Actual_Map) then\n-                     E := First_Elmt (Actual_Map);\n-                     while Present (E) loop\n-                        if Node (E) = N then\n-                           return;\n-                        else\n-                           E := Next_Elmt (Next_Elmt (E));\n-                        end if;\n-                     end loop;\n-                  end if;\n-               end;\n+            if Present (NCT_Assoc.Get (Entity_Id (N))) then\n+               return;\n             end if;\n \n             Visit_Itype (N);\n@@ -17088,34 +16958,7 @@ package body Sem_Util is\n    --  Start of processing for New_Copy_Tree\n \n    begin\n-      Actual_Map := Map;\n-\n-      --  See if we should use hash table\n-\n-      if No (Actual_Map) then\n-         NCT_Hash_Tables_Used := False;\n-\n-      else\n-         declare\n-            Elmt : Elmt_Id;\n-\n-         begin\n-            NCT_Table_Entries := 0;\n-\n-            Elmt := First_Elmt (Actual_Map);\n-            while Present (Elmt) loop\n-               NCT_Table_Entries := NCT_Table_Entries + 1;\n-               Next_Elmt (Elmt);\n-               Next_Elmt (Elmt);\n-            end loop;\n-\n-            if NCT_Table_Entries > NCT_Hash_Threshold then\n-               Build_NCT_Hash_Tables;\n-            else\n-               NCT_Hash_Tables_Used := False;\n-            end if;\n-         end;\n-      end if;\n+      Build_NCT_Hash_Tables;\n \n       --  Hash table set up if required, now start phase one by visiting top\n       --  node (we will recursively visit the descendants).\n@@ -17125,35 +16968,29 @@ package body Sem_Util is\n       --  Now the second phase of the copy can start. First we process all the\n       --  mapped entities, copying their descendants.\n \n-      if Present (Actual_Map) then\n-         declare\n-            Elmt      : Elmt_Id;\n-            New_Itype : Entity_Id;\n-         begin\n-            Elmt := First_Elmt (Actual_Map);\n-            while Present (Elmt) loop\n-               Next_Elmt (Elmt);\n-               New_Itype := Node (Elmt);\n+      declare\n+         Old_E : Entity_Id := Empty;\n+         New_E : Entity_Id;\n \n-               if Is_Itype (New_Itype) then\n-                  Copy_Itype_With_Replacement (New_Itype);\n-               end if;\n+      begin\n+         NCT_Assoc.Get_First (Old_E, New_E);\n+         while Present (New_E) loop\n+            if Is_Itype (New_E) then\n+               Copy_Itype_With_Replacement (New_E);\n+            end if;\n \n-               Next_Elmt (Elmt);\n-            end loop;\n-         end;\n-      end if;\n+            NCT_Assoc.Get_Next (Old_E, New_E);\n+         end loop;\n+      end;\n \n       --  Now we can copy the actual tree\n \n       declare\n          Result : constant Node_Id := Copy_Node_With_Replacement (Source);\n \n       begin\n-         if NCT_Hash_Table_Setup then\n-            NCT_Assoc.Reset;\n-            NCT_Itype_Assoc.Reset;\n-         end if;\n+         NCT_Assoc.Reset;\n+         NCT_Itype_Assoc.Reset;\n \n          return Result;\n       end;\n@@ -19482,7 +19319,7 @@ package body Sem_Util is\n \n       function Clear_Analyzed (N : Node_Id) return Traverse_Result is\n       begin\n-         if not Has_Extension (N) then\n+         if Nkind (N) not in N_Entity then\n             Set_Analyzed (N, False);\n          end if;\n "}]}