{"sha": "478490f681da504e75723828d9f1b3b09928b5e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc4NDkwZjY4MWRhNTA0ZTc1NzIzODI4ZDlmMWIzYjA5OTI4YjVlNQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-08-17T17:52:49Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-08-17T17:52:49Z"}, "message": "PR libstdc++/86963 Implement LWG 2729 constraints on tuple assignment\n\n\tPR libstdc++/86963\n\t* include/std/tuple (__tuple_base): New class template with deleted\n\tcopy assignment operator.\n\t(tuple, tuple<_T1, _T2>): Derive from __tuple_base<tuple> so that\n\timplicit copy/move assignment operator will be deleted/suppressed.\n\t(tuple::__assignable, tuple<_T1, _T2>::__assignable): New helper\n\tfunctions for SFINAE constraints on assignment operators.\n\t(tuple::__nothrow_assignable, tuple<_T1, _T2>::__nothrow_assignable):\n\tNew helper functions for exception specifications.\n\t(tuple::operator=(const tuple&), tuple::operator=(tuple&&))\n\t(tuple<_T1, _T2>::operator=(const tuple&))\n\t(tuple<_T1, _T2>::operator=(tuple&&)): Change parameter types to\n\t__nonesuch_no_braces when the operator should be defined implicitly.\n\tUse __nothrow_assignable for exception specifications.\n\t(tuple::operator=(const tuple<_UElements...>&))\n\t(tuple::operator=(tuple<_UElements...>&&))\n\t(tuple<_T1, _T2>::operator=(const tuple<_U1, _U2>&))\n\t(tuple<_T1, _T2>::operator=(tuple<_U1, _U2>&&))\n\t(tuple<_T1, _T2>::operator=(const pair<_U1, _U2>&))\n\t(tuple<_T1, _T2>::operator=(pair<_U1, _U2>&&)): Constrain using\n\t__assignable and use __nothrow_assignable for exception\n\tspecifications.\n\t* python/libstdcxx/v6/printers.py (is_specialization_of): Accept\n\tgdb.Type as first argument, instead of a string.\n\t(StdTuplePrinter._iterator._is_nonempty_tuple): New method to check\n\ttuple for expected structure.\n\t(StdTuplePrinter._iterator.__init__): Use _is_nonempty_tuple.\n\t* testsuite/20_util/tuple/dr2729.cc: New test.\n\t* testsuite/20_util/tuple/element_access/get_neg.cc: Change dg-error\n\tto dg-prune-output.\n\nFrom-SVN: r263625", "tree": {"sha": "832430bb0a15d9fa69ca293fd004bf9c53bb98e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/832430bb0a15d9fa69ca293fd004bf9c53bb98e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/478490f681da504e75723828d9f1b3b09928b5e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/478490f681da504e75723828d9f1b3b09928b5e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/478490f681da504e75723828d9f1b3b09928b5e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/478490f681da504e75723828d9f1b3b09928b5e5/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81bf52f56416c91706c32f651b411e4f4adfb413", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81bf52f56416c91706c32f651b411e4f4adfb413", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81bf52f56416c91706c32f651b411e4f4adfb413"}], "stats": {"total": 362, "additions": 319, "deletions": 43}, "files": [{"sha": "95d4d06bf35ce04d2e8cedc6a8cc0d786d94a172", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478490f681da504e75723828d9f1b3b09928b5e5/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478490f681da504e75723828d9f1b3b09928b5e5/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=478490f681da504e75723828d9f1b3b09928b5e5", "patch": "@@ -1,3 +1,36 @@\n+2018-08-17  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/86963\n+\t* include/std/tuple (__tuple_base): New class template with deleted\n+\tcopy assignment operator.\n+\t(tuple, tuple<_T1, _T2>): Derive from __tuple_base<tuple> so that\n+\timplicit copy/move assignment operator will be deleted/suppressed.\n+\t(tuple::__assignable, tuple<_T1, _T2>::__assignable): New helper\n+\tfunctions for SFINAE constraints on assignment operators.\n+\t(tuple::__nothrow_assignable, tuple<_T1, _T2>::__nothrow_assignable):\n+\tNew helper functions for exception specifications.\n+\t(tuple::operator=(const tuple&), tuple::operator=(tuple&&))\n+\t(tuple<_T1, _T2>::operator=(const tuple&))\n+\t(tuple<_T1, _T2>::operator=(tuple&&)): Change parameter types to\n+\t__nonesuch_no_braces when the operator should be defined implicitly.\n+\tUse __nothrow_assignable for exception specifications.\n+\t(tuple::operator=(const tuple<_UElements...>&))\n+\t(tuple::operator=(tuple<_UElements...>&&))\n+\t(tuple<_T1, _T2>::operator=(const tuple<_U1, _U2>&))\n+\t(tuple<_T1, _T2>::operator=(tuple<_U1, _U2>&&))\n+\t(tuple<_T1, _T2>::operator=(const pair<_U1, _U2>&))\n+\t(tuple<_T1, _T2>::operator=(pair<_U1, _U2>&&)): Constrain using\n+\t__assignable and use __nothrow_assignable for exception\n+\tspecifications.\n+\t* python/libstdcxx/v6/printers.py (is_specialization_of): Accept\n+\tgdb.Type as first argument, instead of a string.\n+\t(StdTuplePrinter._iterator._is_nonempty_tuple): New method to check\n+\ttuple for expected structure.\n+\t(StdTuplePrinter._iterator.__init__): Use _is_nonempty_tuple.\n+\t* testsuite/20_util/tuple/dr2729.cc: New test.\n+\t* testsuite/20_util/tuple/element_access/get_neg.cc: Change dg-error\n+\tto dg-prune-output.\n+\n 2018-08-16  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/tr1/legendre_function.tcc (__sph_legendre): Avoid warning"}, {"sha": "955b853066f91333775287b155d06af157f6e48a", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 89, "deletions": 36, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478490f681da504e75723828d9f1b3b09928b5e5/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478490f681da504e75723828d9f1b3b09928b5e5/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=478490f681da504e75723828d9f1b3b09928b5e5", "patch": "@@ -551,9 +551,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n   };\n \n+  // The tag parameter ensures that in nested tuples each __tuple_base\n+  // is a different type and can use the empty base-class optimisation.\n+  template<typename _Tag>\n+    class __tuple_base\n+    {\n+      template<typename...> friend struct tuple;\n+      __tuple_base() = default;\n+      ~__tuple_base() = default;\n+      __tuple_base(const __tuple_base&) = default;\n+      __tuple_base& operator=(const __tuple_base&) = delete;\n+    };\n+\n   /// Primary class template, tuple\n   template<typename... _Elements>\n-    class tuple : public _Tuple_impl<0, _Elements...>\n+    class tuple\n+    : public _Tuple_impl<0, _Elements...>,\n+      private __tuple_base<tuple<_Elements...>>\n     {\n       typedef _Tuple_impl<0, _Elements...> _Inherited;\n \n@@ -573,6 +587,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         }\n       };\n \n+      template<typename... _UElements>\n+\tstatic constexpr\n+\t__enable_if_t<sizeof...(_UElements) == sizeof...(_Elements), bool>\n+\t__assignable()\n+\t{ return __and_<is_assignable<_Elements&, _UElements>...>::value; }\n+\n+      template<typename... _UElements>\n+\tstatic constexpr bool __nothrow_assignable()\n+\t{\n+\t  return\n+\t    __and_<is_nothrow_assignable<_Elements&, _UElements>...>::value;\n+\t}\n+\n     public:\n       template<typename _Dummy = void,\n                typename enable_if<_TC2<_Dummy>::\n@@ -832,36 +859,39 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{ }\n \n       tuple&\n-      operator=(const tuple& __in)\n+      operator=(typename conditional<__assignable<const _Elements&...>(),\n+\t\t\t\t     const tuple&,\n+\t\t\t\t     const __nonesuch_no_braces&>::type __in)\n+      noexcept(__nothrow_assignable<const _Elements&...>())\n       {\n \tstatic_cast<_Inherited&>(*this) = __in;\n \treturn *this;\n       }\n \n       tuple&\n-      operator=(tuple&& __in)\n-      noexcept(is_nothrow_move_assignable<_Inherited>::value)\n+      operator=(typename conditional<__assignable<_Elements...>(),\n+\t\t\t\t     tuple&&,\n+\t\t\t\t     __nonesuch_no_braces&&>::type __in)\n+      noexcept(__nothrow_assignable<_Elements...>())\n       {\n \tstatic_cast<_Inherited&>(*this) = std::move(__in);\n \treturn *this;\n       }\n \n       template<typename... _UElements>\n-\ttypename\n-\t       enable_if<sizeof...(_UElements)\n-\t\t\t == sizeof...(_Elements), tuple&>::type\n-        operator=(const tuple<_UElements...>& __in)\n-        {\n+\t__enable_if_t<__assignable<const _UElements&...>(), tuple&>\n+\toperator=(const tuple<_UElements...>& __in)\n+\tnoexcept(__nothrow_assignable<const _UElements&...>())\n+\t{\n \t  static_cast<_Inherited&>(*this) = __in;\n \t  return *this;\n \t}\n \n       template<typename... _UElements>\n-\ttypename\n-\t       enable_if<sizeof...(_UElements)\n-\t\t\t == sizeof...(_Elements), tuple&>::type\n-        operator=(tuple<_UElements...>&& __in)\n-        {\n+\t__enable_if_t<__assignable<_UElements...>(), tuple&>\n+\toperator=(tuple<_UElements...>&& __in)\n+\tnoexcept(__nothrow_assignable<_UElements...>())\n+\t{\n \t  static_cast<_Inherited&>(*this) = std::move(__in);\n \t  return *this;\n \t}\n@@ -904,20 +934,35 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// Partial specialization, 2-element tuple.\n   /// Includes construction and assignment from a pair.\n   template<typename _T1, typename _T2>\n-    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>\n+    class tuple<_T1, _T2>\n+    : public _Tuple_impl<0, _T1, _T2>,\n+      private __tuple_base<tuple<_T1, _T2>>\n     {\n       typedef _Tuple_impl<0, _T1, _T2> _Inherited;\n \n+      template<typename _U1, typename _U2>\n+\tstatic constexpr bool __assignable()\n+\t{\n+\t  return __and_<is_assignable<_T1&, _U1>,\n+\t\t\tis_assignable<_T2&, _U2>>::value;\n+\t}\n+\n+      template<typename _U1, typename _U2>\n+\tstatic constexpr bool __nothrow_assignable()\n+\t{\n+\t  return __and_<is_nothrow_assignable<_T1&, _U1>,\n+\t\t\tis_nothrow_assignable<_T2&, _U2>>::value;\n+\t}\n+\n     public:\n       template <typename _U1 = _T1,\n                 typename _U2 = _T2,\n                 typename enable_if<__and_<\n                                      __is_implicitly_default_constructible<_U1>,\n                                      __is_implicitly_default_constructible<_U2>>\n                                    ::value, bool>::type = true>\n-\n-      constexpr tuple()\n-      : _Inherited() { }\n+\tconstexpr tuple()\n+\t: _Inherited() { }\n \n       template <typename _U1 = _T1,\n                 typename _U2 = _T2,\n@@ -929,9 +974,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                       __and_<__is_implicitly_default_constructible<_U1>,\n                              __is_implicitly_default_constructible<_U2>>>>\n                   ::value, bool>::type = false>\n-\n-      explicit constexpr tuple()\n-      : _Inherited() { }\n+\texplicit constexpr tuple()\n+\t: _Inherited() { }\n \n       // Shortcut for the cases where constructors taking _T1, _T2\n       // need to be constrained.\n@@ -1206,49 +1250,58 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t     std::forward<_U2>(__in.second)) { }\n \n       tuple&\n-      operator=(const tuple& __in)\n+      operator=(typename conditional<__assignable<const _T1&, const _T2&>(),\n+\t\t\t\t     const tuple&,\n+\t\t\t\t     const __nonesuch_no_braces&>::type __in)\n+      noexcept(__nothrow_assignable<const _T1&, const _T2&>())\n       {\n \tstatic_cast<_Inherited&>(*this) = __in;\n \treturn *this;\n       }\n \n       tuple&\n-      operator=(tuple&& __in)\n-      noexcept(is_nothrow_move_assignable<_Inherited>::value)\n+      operator=(typename conditional<__assignable<_T1, _T2>(),\n+\t\t\t\t     tuple&&,\n+\t\t\t\t     __nonesuch_no_braces&&>::type __in)\n+      noexcept(__nothrow_assignable<_T1, _T2>())\n       {\n \tstatic_cast<_Inherited&>(*this) = std::move(__in);\n \treturn *this;\n       }\n \n       template<typename _U1, typename _U2>\n-        tuple&\n-        operator=(const tuple<_U1, _U2>& __in)\n-        {\n+\t__enable_if_t<__assignable<const _U1&, const _U2&>(), tuple&>\n+\toperator=(const tuple<_U1, _U2>& __in)\n+\tnoexcept(__nothrow_assignable<const _U1&, const _U2&>())\n+\t{\n \t  static_cast<_Inherited&>(*this) = __in;\n \t  return *this;\n \t}\n \n       template<typename _U1, typename _U2>\n-        tuple&\n-        operator=(tuple<_U1, _U2>&& __in)\n-        {\n+\t__enable_if_t<__assignable<_U1, _U2>(), tuple&>\n+\toperator=(tuple<_U1, _U2>&& __in)\n+\tnoexcept(__nothrow_assignable<_U1, _U2>())\n+\t{\n \t  static_cast<_Inherited&>(*this) = std::move(__in);\n \t  return *this;\n \t}\n \n       template<typename _U1, typename _U2>\n-        tuple&\n-        operator=(const pair<_U1, _U2>& __in)\n-        {\n+\t__enable_if_t<__assignable<const _U1&, const _U2&>(), tuple&>\n+\toperator=(const pair<_U1, _U2>& __in)\n+\tnoexcept(__nothrow_assignable<const _U1&, const _U2&>())\n+\t{\n \t  this->_M_head(*this) = __in.first;\n \t  this->_M_tail(*this)._M_head(*this) = __in.second;\n \t  return *this;\n \t}\n \n       template<typename _U1, typename _U2>\n-        tuple&\n-        operator=(pair<_U1, _U2>&& __in)\n-        {\n+\t__enable_if_t<__assignable<_U1, _U2>(), tuple&>\n+\toperator=(pair<_U1, _U2>&& __in)\n+\tnoexcept(__nothrow_assignable<_U1, _U2>())\n+\t{\n \t  this->_M_head(*this) = std::forward<_U1>(__in.first);\n \t  this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);\n \t  return *this;"}, {"sha": "afe1b325d87830847e514fcd8c99e4c98c263b3b", "filename": "libstdc++-v3/python/libstdcxx/v6/printers.py", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478490f681da504e75723828d9f1b3b09928b5e5/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478490f681da504e75723828d9f1b3b09928b5e5/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py?ref=478490f681da504e75723828d9f1b3b09928b5e5", "patch": "@@ -101,12 +101,14 @@ def find_type(orig, name):\n \n _versioned_namespace = '__8::'\n \n-def is_specialization_of(type, template_name):\n+def is_specialization_of(x, template_name):\n     \"Test if a type is a given template instantiation.\"\n     global _versioned_namespace\n+    if type(x) is gdb.Type:\n+        x = x.tag\n     if _versioned_namespace:\n-        return re.match('^std::(%s)?%s<.*>$' % (_versioned_namespace, template_name), type) is not None\n-    return re.match('^std::%s<.*>$' % template_name, type) is not None\n+        return re.match('^std::(%s)?%s<.*>$' % (_versioned_namespace, template_name), x) is not None\n+    return re.match('^std::%s<.*>$' % template_name, x) is not None\n \n def strip_versioned_namespace(typename):\n     global _versioned_namespace\n@@ -413,17 +415,26 @@ class StdTuplePrinter:\n     \"Print a std::tuple\"\n \n     class _iterator(Iterator):\n+        @staticmethod\n+        def _is_nonempty_tuple (nodes):\n+            if len (nodes) == 2:\n+                if is_specialization_of (nodes[1].type, '__tuple_base'):\n+                    return True\n+            elif len (nodes) == 1:\n+                return True\n+            elif len (nodes) == 0:\n+                return False\n+            raise ValueError(\"Top of tuple tree does not consist of a single node.\")\n+\n         def __init__ (self, head):\n             self.head = head\n \n             # Set the base class as the initial head of the\n             # tuple.\n             nodes = self.head.type.fields ()\n-            if len (nodes) == 1:\n+            if self._is_nonempty_tuple (nodes):\n                 # Set the actual head to the first pair.\n                 self.head  = self.head.cast (nodes[0].type)\n-            elif len (nodes) != 0:\n-                raise ValueError(\"Top of tuple tree does not consist of a single node.\")\n             self.count = 0\n \n         def __iter__ (self):"}, {"sha": "c38635579949edba76b7cfd35c5d4ab33c8c3b91", "filename": "libstdc++-v3/testsuite/20_util/tuple/dr2729.cc", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478490f681da504e75723828d9f1b3b09928b5e5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fdr2729.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478490f681da504e75723828d9f1b3b09928b5e5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fdr2729.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fdr2729.cc?ref=478490f681da504e75723828d9f1b3b09928b5e5", "patch": "@@ -0,0 +1,179 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile { target c++11 } }\n+\n+#include <tuple>\n+#include <testsuite_tr1.h>\n+\n+using std::tuple;\n+using std::pair;\n+using __gnu_test::assign::AnyAssign;\n+using __gnu_test::assign::DelAnyAssign;\n+using __gnu_test::assign::DelCopyAssign;\n+using __gnu_test::CopyConsOnlyType;\n+\n+// Copy assignment:\n+template<typename T>\n+constexpr bool copy() { return std::is_copy_assignable<T>::value; }\n+\n+// Move assigmment:\n+template<typename T>\n+constexpr bool move() { return std::is_move_assignable<T>::value; }\n+\n+static_assert( copy<tuple<>>(), \"\");\n+static_assert( move<tuple<>>(), \"\");\n+\n+static_assert( copy<tuple<int>>(), \"\");\n+static_assert( copy<tuple<AnyAssign>>(), \"\");\n+static_assert( copy<tuple<int, int>>(), \"\");\n+static_assert( copy<tuple<AnyAssign, AnyAssign>>(), \"\");\n+static_assert( copy<tuple<int, AnyAssign>>(), \"\");\n+static_assert( copy<tuple<AnyAssign, int>>(), \"\");\n+static_assert( copy<tuple<int, int, int>>(), \"\");\n+static_assert( copy<tuple<AnyAssign, AnyAssign, AnyAssign>>(), \"\");\n+static_assert( copy<tuple<int, AnyAssign, AnyAssign>>(), \"\");\n+static_assert( copy<tuple<AnyAssign, int, AnyAssign>>(), \"\");\n+static_assert( copy<tuple<AnyAssign, AnyAssign, int>>(), \"\");\n+\n+static_assert( move<tuple<int>>(), \"\");\n+static_assert( move<tuple<AnyAssign>>(), \"\");\n+static_assert( move<tuple<int, int>>(), \"\");\n+static_assert( move<tuple<AnyAssign, AnyAssign>>(), \"\");\n+static_assert( move<tuple<int, AnyAssign>>(), \"\");\n+static_assert( move<tuple<AnyAssign, int>>(), \"\");\n+static_assert( move<tuple<int, int, int>>(), \"\");\n+static_assert( move<tuple<AnyAssign, AnyAssign, AnyAssign>>(), \"\");\n+static_assert( move<tuple<int, AnyAssign, AnyAssign>>(), \"\");\n+static_assert( move<tuple<AnyAssign, int, AnyAssign>>(), \"\");\n+static_assert( move<tuple<AnyAssign, AnyAssign, int>>(), \"\");\n+\n+static_assert( ! copy<tuple<DelCopyAssign>>(), \"\");\n+static_assert( ! copy<tuple<DelCopyAssign, int>>(), \"\");\n+static_assert( ! copy<tuple<int, DelCopyAssign>>(), \"\");\n+static_assert( ! copy<tuple<DelCopyAssign, int, int>>(), \"\");\n+static_assert( ! copy<tuple<int, DelCopyAssign, int>>(), \"\");\n+static_assert( ! copy<tuple<int, int, DelCopyAssign>>(), \"\");\n+\n+static_assert( move<tuple<DelCopyAssign>>(), \"\");\n+static_assert( move<tuple<DelCopyAssign, int>>(), \"\");\n+static_assert( move<tuple<int, DelCopyAssign>>(), \"\");\n+static_assert( move<tuple<DelCopyAssign, int, int>>(), \"\");\n+static_assert( move<tuple<int, DelCopyAssign, int>>(), \"\");\n+static_assert( move<tuple<int, int, DelCopyAssign>>(), \"\");\n+\n+static_assert( ! move<tuple<CopyConsOnlyType>>(), \"\");\n+static_assert( ! move<tuple<CopyConsOnlyType, int>>(), \"\");\n+static_assert( ! move<tuple<int, CopyConsOnlyType>>(), \"\");\n+static_assert( ! move<tuple<CopyConsOnlyType, int, int>>(), \"\");\n+static_assert( ! move<tuple<int, CopyConsOnlyType, int>>(), \"\");\n+static_assert( ! move<tuple<int, int, CopyConsOnlyType>>(), \"\");\n+\n+// Assignment from different types of tuple (and pair):\n+template<typename To, typename From>\n+constexpr bool assign() { return std::is_assignable<To&, From>::value; }\n+\n+// 0-tuples\n+static_assert( ! assign<tuple<>, tuple<int>>(), \"\" );\n+static_assert( ! assign<tuple<>, const tuple<int>&>(), \"\" );\n+\n+// 1-tuples\n+static_assert( ! assign<tuple<int>, tuple<>>(), \"\" );\n+static_assert( ! assign<tuple<int>, const tuple<>&>(), \"\" );\n+static_assert( ! assign<tuple<AnyAssign>, tuple<>>(), \"\" );\n+static_assert( ! assign<tuple<AnyAssign>, tuple<int, int>>(), \"\" );\n+static_assert( ! assign<tuple<AnyAssign>, pair<int, int>>(), \"\" );\n+\n+static_assert( ! assign<tuple<void*>, tuple<int>>(), \"\" );\n+static_assert( ! assign<tuple<void*>, const tuple<int>&>(), \"\" );\n+\n+static_assert( assign<tuple<long>, tuple<int>>(), \"\" );\n+static_assert( assign<tuple<long>, tuple<int>&>(), \"\" );\n+static_assert( assign<tuple<long>, const tuple<int>>(), \"\" );\n+static_assert( assign<tuple<long>, const tuple<int>&>(), \"\" );\n+\n+// 2-tuples\n+static_assert( assign<tuple<long, long>, tuple<int, int>>(), \"\" );\n+static_assert( assign<tuple<long, long>, tuple<int, int>&>(), \"\" );\n+static_assert( assign<tuple<long, long>, const tuple<int, int>>(), \"\" );\n+static_assert( assign<tuple<long, long>, const tuple<int, int>&>(), \"\" );\n+\n+static_assert( assign<tuple<long, long>, pair<int, int>>(), \"\" );\n+static_assert( assign<tuple<long, long>, const pair<int, int>&>(), \"\" );\n+static_assert( assign<tuple<long, long>, pair<int, int>>(), \"\" );\n+static_assert( assign<tuple<long, long>, const pair<int, int>&&>(), \"\" );\n+\n+static_assert( assign<tuple<DelCopyAssign, AnyAssign>,\n+\t\t      tuple<DelCopyAssign, int>>(), \"\" );\n+static_assert( ! assign<tuple<DelCopyAssign, AnyAssign>,\n+\t\t\ttuple<DelCopyAssign, int>&>(), \"\" );\n+static_assert( ! assign<tuple<DelCopyAssign, AnyAssign>,\n+\t\t\tconst tuple<DelCopyAssign, int>&>(), \"\" );\n+static_assert( ! assign<tuple<DelCopyAssign, AnyAssign>,\n+\t\t\tconst tuple<DelCopyAssign, int>&&>(), \"\" );\n+\n+static_assert( assign<tuple<AnyAssign, DelCopyAssign>,\n+\t\t      tuple<int, DelCopyAssign>>(), \"\" );\n+static_assert( ! assign<tuple<AnyAssign, DelCopyAssign>,\n+\t\t\ttuple<int, DelCopyAssign>&>(), \"\" );\n+static_assert( ! assign<tuple<AnyAssign, DelCopyAssign>,\n+\t\t\tconst tuple<int, DelCopyAssign>&>(), \"\" );\n+static_assert( ! assign<tuple<AnyAssign, DelCopyAssign>,\n+\t\t\tconst tuple<int, DelCopyAssign>&&>(), \"\" );\n+\n+static_assert( ! assign<tuple<void*, int>,\n+\t\t\ttuple<int, int>>(), \"\" );\n+static_assert( ! assign<tuple<void*, int>,\n+\t\t\tconst tuple<int, int>&>(), \"\" );\n+\n+static_assert( assign<tuple<DelCopyAssign, AnyAssign>,\n+\t\t      pair<DelCopyAssign, int>>(), \"\" );\n+static_assert( ! assign<tuple<DelCopyAssign, AnyAssign>,\n+\t\t\tpair<DelCopyAssign, int>&>(), \"\" );\n+static_assert( ! assign<tuple<DelCopyAssign, AnyAssign>,\n+\t\t\tconst pair<DelCopyAssign, int>&>(), \"\" );\n+static_assert( ! assign<tuple<DelCopyAssign, AnyAssign>,\n+\t\t\tconst pair<DelCopyAssign, int>&&>(), \"\" );\n+\n+static_assert( assign<tuple<AnyAssign, DelCopyAssign>,\n+\t\t      pair<int, DelCopyAssign>>(), \"\" );\n+static_assert( ! assign<tuple<AnyAssign, DelCopyAssign>,\n+\t\t\tpair<int, DelCopyAssign>&>(), \"\" );\n+static_assert( ! assign<tuple<AnyAssign, DelCopyAssign>,\n+\t\t\tconst pair<int, DelCopyAssign>&>(), \"\" );\n+static_assert( ! assign<tuple<AnyAssign, DelCopyAssign>,\n+\t\t\tconst pair<int, DelCopyAssign>&&>(), \"\" );\n+\n+static_assert( ! assign<tuple<void*, int>,\n+\t\t\tpair<int, int>>(), \"\" );\n+static_assert( ! assign<tuple<void*, int>,\n+\t\t\tconst pair<int, int>&>(), \"\" );\n+\n+// 3-tuples\n+static_assert( assign<tuple<AnyAssign, DelCopyAssign, AnyAssign>,\n+\t\t      tuple<int, DelCopyAssign, int>>(), \"\" );\n+static_assert( ! assign<tuple<AnyAssign, DelCopyAssign, AnyAssign>,\n+\t\t\ttuple<int, DelCopyAssign, int>&>(), \"\" );\n+static_assert( ! assign<tuple<AnyAssign, DelCopyAssign, AnyAssign>,\n+\t\t\tconst tuple<int, DelCopyAssign, int>&>(), \"\" );\n+static_assert( ! assign<tuple<AnyAssign, DelCopyAssign, AnyAssign>,\n+\t\t\tconst tuple<int, DelCopyAssign, int>&&>(), \"\" );\n+\n+static_assert( ! assign<tuple<int, void*, int>,\n+\t\t\ttuple<int, int, int>>(), \"\" );\n+static_assert( ! assign<tuple<int, void*, int>,\n+\t\t\tconst tuple<int, int, int>&>(), \"\" );"}, {"sha": "d55028268eb32c0808bfa733e6bbaa62f7c0eac7", "filename": "libstdc++-v3/testsuite/20_util/tuple/element_access/get_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478490f681da504e75723828d9f1b3b09928b5e5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Felement_access%2Fget_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478490f681da504e75723828d9f1b3b09928b5e5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Felement_access%2Fget_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Felement_access%2Fget_neg.cc?ref=478490f681da504e75723828d9f1b3b09928b5e5", "patch": "@@ -17,7 +17,7 @@\n \n // { dg-options \"-fno-show-column\" }\n // { dg-do compile { target c++14 } }\n-// { dg-error \"in range\" \"\" { target *-*-* } 1297 }\n+// { dg-prune-output \"tuple index is in range\" }\n \n #include <tuple>\n "}]}