{"sha": "655f2eb93e47f4996700fe6dd0524a151504144c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU1ZjJlYjkzZTQ3ZjQ5OTY3MDBmZTZkZDA1MjRhMTUxNTA0MTQ0Yw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-09-11T21:15:50Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-09-11T21:15:50Z"}, "message": "ia64-protos.h (fr_nonimmediate_operand): Declare.\n\n        * config/ia64/ia64-protos.h (fr_nonimmediate_operand): Declare.\n        * config/ia64/ia64.c (fr_nonimmediate_operand): New.\n        (ia64_override_options): Prevent optimizing division for both\n        latency and throughput.\n        (rtx_needs_barrier): Handle frcpa.\n        * config/ia64/ia64.h (MASK_INLINE_DIV_LAT): New.\n        (MASK_INLINE_DIV_THR, TARGET_INLINE_DIV_LAT): New.\n        (TARGET_INLINE_DIV_THR, TARGET_INLINE_DIV): New.\n        (TARGET_SWITCHES): Add -minline-divide-min-latency and\n        -minline-divide-max-throughput.\n        (PREDICATE_CODES): Update.\n        * config/ia64/ia64.md (extendsidi2): Remove * from f case.\n        (zero_extendsidi2): Likewise.  Fix typo in f case insn.\n        (extendsfdf2): Add cases for gr<->fr and fr<->mem.\n        (extendsftf2): Likewise.\n        (extenddftf2): Likewise.\n        (fix_trunctfdi2_alts): New.\n        (fixuns_trunctfdi2_alts): New.\n        (madd*4): Rename from madd*3.\n        (divsi3, modsi3, udivsi3, umodsi3): New.\n        (divsi3_internal): New.\n        (divdi3, moddi3, udivdi3, umoddi3): New.\n        (divdi3_internal_lat, divdi3_internal_thr): New.\n        (multf3_alts, maddtf4_alts, nmaddtf4_alts): New.\n        (recip_approx): New.\n\nFrom-SVN: r36330", "tree": {"sha": "1fa29ab43ac1000672083f26717b269a9733da10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fa29ab43ac1000672083f26717b269a9733da10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/655f2eb93e47f4996700fe6dd0524a151504144c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/655f2eb93e47f4996700fe6dd0524a151504144c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/655f2eb93e47f4996700fe6dd0524a151504144c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/655f2eb93e47f4996700fe6dd0524a151504144c/comments", "author": null, "committer": null, "parents": [{"sha": "b5d7770c3e686d58e4ce1e1b49c35eec2c0475bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5d7770c3e686d58e4ce1e1b49c35eec2c0475bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5d7770c3e686d58e4ce1e1b49c35eec2c0475bb"}], "stats": {"total": 582, "additions": 552, "deletions": 30}, "files": [{"sha": "31d94b4b8f5d5951182504b03a470aeda3b5e88c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/655f2eb93e47f4996700fe6dd0524a151504144c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/655f2eb93e47f4996700fe6dd0524a151504144c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=655f2eb93e47f4996700fe6dd0524a151504144c", "patch": "@@ -1,3 +1,31 @@\n+2000-09-11  Richard Henderson  <rth@cygnus.com>\n+\n+\t* config/ia64/ia64-protos.h (fr_nonimmediate_operand): Declare.\n+\t* config/ia64/ia64.c (fr_nonimmediate_operand): New.\n+\t(ia64_override_options): Prevent optimizing division for both\n+\tlatency and throughput.\n+\t(rtx_needs_barrier): Handle frcpa.\n+\t* config/ia64/ia64.h (MASK_INLINE_DIV_LAT): New.\n+\t(MASK_INLINE_DIV_THR, TARGET_INLINE_DIV_LAT): New.\n+\t(TARGET_INLINE_DIV_THR, TARGET_INLINE_DIV): New.\n+\t(TARGET_SWITCHES): Add -minline-divide-min-latency and\n+\t-minline-divide-max-throughput.\n+\t(PREDICATE_CODES): Update.\n+\t* config/ia64/ia64.md (extendsidi2): Remove * from f case.\n+\t(zero_extendsidi2): Likewise.  Fix typo in f case insn.\n+\t(extendsfdf2): Add cases for gr<->fr and fr<->mem.\n+\t(extendsftf2): Likewise.\n+\t(extenddftf2): Likewise.\n+\t(fix_trunctfdi2_alts): New.\n+\t(fixuns_trunctfdi2_alts): New.\n+\t(madd*4): Rename from madd*3.\n+\t(divsi3, modsi3, udivsi3, umodsi3): New.\n+\t(divsi3_internal): New.\n+\t(divdi3, moddi3, udivdi3, umoddi3): New.\n+\t(divdi3_internal_lat, divdi3_internal_thr): New.\n+\t(multf3_alts, maddtf4_alts, nmaddtf4_alts): New.\n+\t(recip_approx): New.\n+\n 2000-09-11  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* print-rtl.c (debug_call_placeholder_verbose): New variable."}, {"sha": "d213b4180f8b8aeb6c057daaa5e3533debb037d6", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/655f2eb93e47f4996700fe6dd0524a151504144c/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/655f2eb93e47f4996700fe6dd0524a151504144c/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=655f2eb93e47f4996700fe6dd0524a151504144c", "patch": "@@ -38,6 +38,7 @@ extern int gr_register_operand PARAMS((rtx, enum machine_mode));\n extern int fr_register_operand PARAMS((rtx, enum machine_mode));\n extern int grfr_register_operand PARAMS((rtx, enum machine_mode));\n extern int gr_nonimmediate_operand PARAMS((rtx, enum machine_mode));\n+extern int fr_nonimmediate_operand PARAMS((rtx, enum machine_mode));\n extern int grfr_nonimmediate_operand PARAMS((rtx, enum machine_mode));\n extern int gr_reg_or_0_operand PARAMS((rtx, enum machine_mode));\n extern int gr_reg_or_5bit_operand PARAMS((rtx, enum machine_mode));"}, {"sha": "57de975c8701fb217a6ecabc753a127977ce9f37", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/655f2eb93e47f4996700fe6dd0524a151504144c/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/655f2eb93e47f4996700fe6dd0524a151504144c/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=655f2eb93e47f4996700fe6dd0524a151504144c", "patch": "@@ -397,6 +397,26 @@ gr_nonimmediate_operand (op, mode)\n   return 1;\n }\n \n+/* Return 1 if OP is a nonimmediate operand that is (or could be) a FR reg.  */\n+\n+int\n+fr_nonimmediate_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (! nonimmediate_operand (op, mode))\n+    return 0;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  if (GET_CODE (op) == REG)\n+    {\n+      unsigned int regno = REGNO (op);\n+      if (regno < FIRST_PSEUDO_REGISTER)\n+\treturn FR_REGNO_P (regno);\n+    }\n+  return 1;\n+}\n+\n /* Return 1 if OP is a nonimmediate operand that is a GR/FR reg.  */\n \n int\n@@ -3484,6 +3504,12 @@ ia64_override_options ()\n   if (TARGET_AUTO_PIC)\n     target_flags |= MASK_CONST_GP;\n \n+  if (TARGET_INLINE_DIV_LAT && TARGET_INLINE_DIV_THR)\n+    {\n+      warning (\"cannot optimize division for both latency and throughput\");\n+      target_flags &= ~MASK_INLINE_DIV_THR;\n+    }\n+\n   if (ia64_fixed_range_string)\n     fix_range (ia64_fixed_range_string);\n \n@@ -3971,6 +3997,11 @@ rtx_needs_barrier (x, flags, pred)\n \tcase 21: /* flushrs */\n           break;\n \n+\tcase 5: /* recip_approx */\n+\t  need_barrier = rtx_needs_barrier (XVECEXP (x, 0, 0), flags, pred);\n+\t  need_barrier |= rtx_needs_barrier (XVECEXP (x, 0, 1), flags, pred);\n+\t  break;\n+\n         case 13: /* cmpxchg_acq */\n \t  need_barrier = rtx_needs_barrier (XVECEXP (x, 0, 1), flags, pred);\n \t  need_barrier |= rtx_needs_barrier (XVECEXP (x, 0, 2), flags, pred);"}, {"sha": "1f975f3913dd139cd2cca1c16b08489e15efb71c", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/655f2eb93e47f4996700fe6dd0524a151504144c/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/655f2eb93e47f4996700fe6dd0524a151504144c/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=655f2eb93e47f4996700fe6dd0524a151504144c", "patch": "@@ -63,6 +63,10 @@ extern int target_flags;\n \n #define MASK_AUTO_PIC\t0x00000200\t/* generate automatically PIC */\n \n+#define MASK_INLINE_DIV_LAT 0x00000400\t/* inline div, min latency.  */\n+\n+#define MASK_INLINE_DIV_THR 0x00000800\t/* inline div, max throughput.  */\n+\n #define MASK_DWARF2_ASM 0x40000000\t/* test dwarf2 line info via gas.  */\n \n #define TARGET_BIG_ENDIAN\t(target_flags & MASK_BIG_ENDIAN)\n@@ -85,6 +89,13 @@ extern int target_flags;\n \n #define TARGET_AUTO_PIC\t\t(target_flags & MASK_AUTO_PIC)\n \n+#define TARGET_INLINE_DIV_LAT\t(target_flags & MASK_INLINE_DIV_LAT)\n+\n+#define TARGET_INLINE_DIV_THR\t(target_flags & MASK_INLINE_DIV_THR)\n+\n+#define TARGET_INLINE_DIV \\\n+  (target_flags & (MASK_INLINE_DIV_LAT | MASK_INLINE_DIV_THR))\n+\n #define TARGET_DWARF2_ASM\t(target_flags & MASK_DWARF2_ASM)\n \n /* This macro defines names of command options to set and clear bits in\n@@ -123,6 +134,10 @@ extern int target_flags;\n       N_(\"gp is constant (but save/restore gp on indirect calls)\") },\t\\\n   { \"auto-pic\",\t\tMASK_AUTO_PIC,\t\t\t\t\t\\\n       N_(\"Generate self-relocatable code\") },\t\t\t\t\\\n+  { \"inline-divide-min-latency\", MASK_INLINE_DIV_LAT,\t\t\t\\\n+      N_(\"Generate inline division, optimize for latency\") },\t\t\\\n+  { \"inline-divide-max-throughput\", MASK_INLINE_DIV_THR,\t\t\\\n+      N_(\"Generate inline division, optimize for throughput\") },\t\\\n   { \"dwarf2-asm\", \tMASK_DWARF2_ASM,\t\t\t\t\\\n       N_(\"Enable Dwarf 2 line debug info via GNU as\")},\t\t\t\\\n   { \"no-dwarf2-asm\", \t-MASK_DWARF2_ASM,\t\t\t\t\\\n@@ -2646,6 +2661,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n { \"fr_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n { \"grfr_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n { \"gr_nonimmediate_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n+{ \"fr_nonimmediate_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n { \"grfr_nonimmediate_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n { \"gr_reg_or_0_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n { \"gr_reg_or_5bit_operand\", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}},\t\\"}, {"sha": "8593bf620542a65fd3c4641b1a2345dde45f0c55", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 476, "deletions": 30, "changes": 506, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/655f2eb93e47f4996700fe6dd0524a151504144c/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/655f2eb93e47f4996700fe6dd0524a151504144c/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=655f2eb93e47f4996700fe6dd0524a151504144c", "patch": "@@ -57,6 +57,7 @@\n ;;\t2\tgr_restore\n ;;\t3\tfr_spill\n ;;\t4\tfr_restore\n+;;\t5\trecip_approx\n ;;\t8\tpopcnt\n ;;\t12\tmf\n ;;\t13\tcmpxchg_acq\n@@ -950,8 +951,8 @@\n   [(set_attr \"type\" \"I\")])\n \n (define_insn \"extendsidi2\"\n-  [(set (match_operand:DI 0 \"grfr_register_operand\" \"=r,*f\")\n-\t(sign_extend:DI (match_operand:SI 1 \"grfr_register_operand\" \"r,*f\")))]\n+  [(set (match_operand:DI 0 \"grfr_register_operand\" \"=r,?f\")\n+\t(sign_extend:DI (match_operand:SI 1 \"grfr_register_operand\" \"r,f\")))]\n   \"\"\n   \"@\n    sxt4 %0 = %1\n@@ -979,14 +980,14 @@\n   [(set_attr \"type\" \"I,M\")])\n \n (define_insn \"zero_extendsidi2\"\n-  [(set (match_operand:DI 0 \"grfr_register_operand\" \"=r,r,*f\")\n+  [(set (match_operand:DI 0 \"grfr_register_operand\" \"=r,r,?f\")\n \t(zero_extend:DI\n-\t  (match_operand:SI 1 \"grfr_nonimmediate_operand\" \"r,m,*f\")))]\n+\t  (match_operand:SI 1 \"grfr_nonimmediate_operand\" \"r,m,f\")))]\n   \"\"\n   \"@\n    zxt4 %0 = %1\n    ld4%O1 %0 = %1%P1\n-   fsxt.r %0 = f1, %1%B0\"\n+   fmix.r %0 = f0, %1%B0\"\n   [(set_attr \"type\" \"I,M,F\")])\n \n ;; Convert between floating point types of different sizes.\n@@ -997,34 +998,53 @@\n ;; would let combine merge the thing into adjacent insns.\n \n (define_insn_and_split \"extendsfdf2\"\n-  [(set (match_operand:DF 0 \"fr_register_operand\" \"=f,f\")\n-\t(float_extend:DF (match_operand:SF 1 \"fr_register_operand\" \"0,f\")))]\n+  [(set (match_operand:DF 0 \"grfr_nonimmediate_operand\" \"=f,f,f,f,m,*r\")\n+\t(float_extend:DF\n+\t  (match_operand:SF 1 \"grfr_nonimmediate_operand\" \"0,f,m,*r,f,f\")))]\n   \"\"\n-  \"mov %0 = %1\"\n+  \"@\n+   mov %0 = %1\n+   mov %0 = %1\n+   ldfs %0 = %1%P1\n+   setf.s %0 = %1\n+   stfd %0 = %1%P0\n+   getf.d %0 = %1\"\n   \"reload_completed\"\n   [(set (match_dup 0) (float_extend:DF (match_dup 1)))]\n   \"if (true_regnum (operands[0]) == true_regnum (operands[1])) DONE;\"\n-  [(set_attr \"type\" \"F\")])\n+  [(set_attr \"type\" \"F,F,M,M,M,M\")])\n \n (define_insn_and_split \"extendsftf2\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f,f\")\n-\t(float_extend:TF (match_operand:SF 1 \"fr_register_operand\" \"0,f\")))]\n+  [(set (match_operand:TF 0 \"fr_nonimmediate_operand\" \"=f,f,f,f,Q\")\n+\t(float_extend:TF\n+\t  (match_operand:SF 1 \"grfr_nonimmediate_operand\" \"0,f,Q,*r,f\")))]\n   \"\"\n-  \"mov %0 = %1\"\n+  \"@\n+   mov %0 = %1\n+   mov %0 = %1\n+   ldfs %0 = %1%P1\n+   setf.s %0 = %1\n+   stfe %0 = %1%P0\"\n   \"reload_completed\"\n   [(set (match_dup 0) (float_extend:TF (match_dup 1)))]\n   \"if (true_regnum (operands[0]) == true_regnum (operands[1])) DONE;\"\n-  [(set_attr \"type\" \"F\")])\n+  [(set_attr \"type\" \"F,F,M,M,M\")])\n \n (define_insn_and_split \"extenddftf2\"\n-  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f,f\")\n-\t(float_extend:TF (match_operand:DF 1 \"fr_register_operand\" \"0,f\")))]\n+  [(set (match_operand:TF 0 \"fr_nonimmediate_operand\" \"=f,f,f,f,Q\")\n+\t(float_extend:TF\n+\t  (match_operand:DF 1 \"grfr_nonimmediate_operand\" \"0,f,Q,*r,f\")))]\n   \"\"\n-  \"mov %0 = %1\"\n+  \"@\n+   mov %0 = %1\n+   mov %0 = %1\n+   ldfd %0 = %1%P1\n+   setf.d %0 = %1\n+   stfe %0 = %1%P0\"\n   \"reload_completed\"\n   [(set (match_dup 0) (float_extend:TF (match_dup 1)))]\n   \"if (true_regnum (operands[0]) == true_regnum (operands[1])) DONE;\"\n-  [(set_attr \"type\" \"F\")])\n+  [(set_attr \"type\" \"F,F,M,M,M\")])\n \n (define_insn \"truncdfsf2\"\n   [(set (match_operand:SF 0 \"fr_register_operand\" \"=f\")\n@@ -1077,6 +1097,14 @@\n   \"fcvt.fx.trunc %0 = %1%B0\"\n   [(set_attr \"type\" \"F\")])\n \n+(define_insn \"fix_trunctfdi2_alts\"\n+  [(set (match_operand:DI 0 \"fr_register_operand\" \"=f\")\n+\t(fix:DI (match_operand:TF 1 \"fr_register_operand\" \"f\")))\n+   (use (match_operand:SI 2 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"fcvt.fx.trunc.s%2 %0 = %1%B0\"\n+  [(set_attr \"type\" \"F\")])\n+\n ;; Convert between unsigned integer types and floating point.\n \n (define_insn \"floatunsdisf2\"\n@@ -1120,6 +1148,14 @@\n   \"\"\n   \"fcvt.fxu.trunc %0 = %1%B0\"\n   [(set_attr \"type\" \"F\")])\n+\n+(define_insn \"fixuns_trunctfdi2_alts\"\n+  [(set (match_operand:DI 0 \"fr_register_operand\" \"=f\")\n+\t(unsigned_fix:DI (match_operand:TF 1 \"fr_register_operand\" \"f\")))\n+   (use (match_operand:SI 2 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"fcvt.fxu.trunc.s%2 %0 = %1%B0\"\n+  [(set_attr \"type\" \"F\")])\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -1400,7 +1436,7 @@\n   \"xma.l %0 = %1, %2, f0%B0\"\n   [(set_attr \"type\" \"F\")])\n \n-(define_insn \"*maddsi3\"\n+(define_insn \"maddsi4\"\n   [(set (match_operand:SI 0 \"fr_register_operand\" \"=f\")\n \t(plus:SI (mult:SI (match_operand:SI 1 \"grfr_register_operand\" \"f\")\n \t\t\t  (match_operand:SI 2 \"grfr_register_operand\" \"f\"))\n@@ -1481,6 +1517,172 @@\n   operands[3] = gen_reg_rtx (CCmode);\n }\")\n \n+(define_expand \"divsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(div:SI (match_operand:SI 1 \"general_operand\" \"\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"\")))]\n+  \"TARGET_INLINE_DIV\"\n+  \"\n+{\n+  rtx op1_tf, op2_tf, op0_tf, op0_di, twon34;\n+\n+  op0_tf = gen_reg_rtx (TFmode);\n+  op0_di = gen_reg_rtx (DImode);\n+\n+  if (CONSTANT_P (operands[1]))\n+    operands[1] = force_reg (SImode, operands[1]);\n+  op1_tf = gen_reg_rtx (TFmode);\n+  expand_float (op1_tf, operands[1], 0);\n+\n+  if (CONSTANT_P (operands[2]))\n+    operands[2] = force_reg (SImode, operands[2]);\n+  op2_tf = gen_reg_rtx (TFmode);\n+  expand_float (op2_tf, operands[2], 0);\n+\n+  /* 2^-34 */\n+#if 0\n+  twon34 = (CONST_DOUBLE_FROM_REAL_VALUE\n+\t    (REAL_VALUE_FROM_TARGET_SINGLE (0x2e800000), TFmode));\n+  twon34 = force_reg (TFmode, twon34);\n+#else\n+  twon34 = gen_reg_rtx (TFmode);\n+  convert_move (twon34, force_const_mem (SFmode, CONST_DOUBLE_FROM_REAL_VALUE (REAL_VALUE_FROM_TARGET_SINGLE (0x2e800000), SFmode)), 0);\n+#endif\n+\n+  emit_insn (gen_divsi3_internal (op0_tf, op1_tf, op2_tf, twon34));\n+\n+  emit_insn (gen_fix_trunctfdi2_alts (op0_di, op0_tf, const1_rtx));\n+  emit_move_insn (operands[0], gen_lowpart (SImode, op0_di));\n+  DONE;\n+}\")\n+\n+(define_expand \"modsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(mod:SI (match_operand:SI 1 \"general_operand\" \"\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"\")))]\n+  \"TARGET_INLINE_DIV\"\n+  \"\n+{\n+  rtx op2_neg, op1_di, div;\n+\n+  div = gen_reg_rtx (SImode);\n+  emit_insn (gen_divsi3 (div, operands[1], operands[2]));\n+\n+  op2_neg = expand_unop (SImode, neg_optab, operands[2], NULL_RTX, 0);\n+\n+  /* This is a trick to get us to reuse the value that we're sure to\n+     have already copied to the FP regs.  */\n+  op1_di = gen_reg_rtx (DImode);\n+  convert_move (op1_di, operands[1], 0);\n+\n+  emit_insn (gen_maddsi4 (operands[0], div, op2_neg,\n+\t\t\t  gen_lowpart (SImode, op1_di)));\n+  DONE;\n+}\")\n+\n+(define_expand \"udivsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(udiv:SI (match_operand:SI 1 \"general_operand\" \"\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"\")))]\n+  \"TARGET_INLINE_DIV\"\n+  \"\n+{\n+  rtx op1_tf, op2_tf, op0_tf, op0_di, twon34;\n+\n+  op0_tf = gen_reg_rtx (TFmode);\n+  op0_di = gen_reg_rtx (DImode);\n+\n+  if (CONSTANT_P (operands[1]))\n+    operands[1] = force_reg (SImode, operands[1]);\n+  op1_tf = gen_reg_rtx (TFmode);\n+  expand_float (op1_tf, operands[1], 1);\n+\n+  if (CONSTANT_P (operands[2]))\n+    operands[2] = force_reg (SImode, operands[2]);\n+  op2_tf = gen_reg_rtx (TFmode);\n+  expand_float (op2_tf, operands[2], 1);\n+\n+  /* 2^-34 */\n+#if 0\n+  twon34 = (CONST_DOUBLE_FROM_REAL_VALUE\n+\t    (REAL_VALUE_FROM_TARGET_SINGLE (0x2e800000), TFmode));\n+  twon34 = force_reg (TFmode, twon34);\n+#else\n+  twon34 = gen_reg_rtx (TFmode);\n+  convert_move (twon34, force_const_mem (SFmode, CONST_DOUBLE_FROM_REAL_VALUE (REAL_VALUE_FROM_TARGET_SINGLE (0x2e800000), SFmode)), 0);\n+#endif\n+\n+  emit_insn (gen_divsi3_internal (op0_tf, op1_tf, op2_tf, twon34));\n+\n+  emit_insn (gen_fixuns_trunctfdi2_alts (op0_di, op0_tf, const1_rtx));\n+  emit_move_insn (operands[0], gen_lowpart (SImode, op0_di));\n+  DONE;\n+}\")\n+\n+(define_expand \"umodsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(umod:SI (match_operand:SI 1 \"general_operand\" \"\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"\")))]\n+  \"TARGET_INLINE_DIV\"\n+  \"\n+{\n+  rtx op2_neg, op1_di, div;\n+\n+  div = gen_reg_rtx (SImode);\n+  emit_insn (gen_udivsi3 (div, operands[1], operands[2]));\n+\n+  op2_neg = expand_unop (SImode, neg_optab, operands[2], NULL_RTX, 0);\n+\n+  /* This is a trick to get us to reuse the value that we're sure to\n+     have already copied to the FP regs.  */\n+  op1_di = gen_reg_rtx (DImode);\n+  convert_move (op1_di, operands[1], 1);\n+\n+  emit_insn (gen_maddsi4 (operands[0], div, op2_neg,\n+\t\t\t  gen_lowpart (SImode, op1_di)));\n+  DONE;\n+}\")\n+\n+(define_insn_and_split \"divsi3_internal\"\n+  [(set (match_operand:TF 0 \"fr_register_operand\" \"=&f\")\n+\t(float:TF (div:SI (match_operand:TF 1 \"fr_register_operand\" \"f\")\n+\t\t\t  (match_operand:TF 2 \"fr_register_operand\" \"f\"))))\n+   (clobber (match_scratch:TF 4 \"=&f\"))\n+   (clobber (match_scratch:TF 5 \"=&f\"))\n+   (clobber (match_scratch:CC 6 \"=c\"))\n+   (use (match_operand:TF 3 \"fr_register_operand\" \"f\"))]\n+  \"TARGET_INLINE_DIV\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0) (div:TF (const_int 1) (match_dup 2)))\n+\t      (set (match_dup 6) (unspec:CC [(match_dup 1) (match_dup 2)] 5))\n+\t      (use (const_int 1))])\n+   (cond_exec (ne (match_dup 6) (const_int 0))\n+     (parallel [(set (match_dup 4) (mult:TF (match_dup 1) (match_dup 0)))\n+\t\t(use (const_int 1))]))\n+   (cond_exec (ne (match_dup 6) (const_int 0))\n+     (parallel [(set (match_dup 5)\n+\t\t     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 0)))\n+\t\t\t      (match_dup 7)))\n+\t\t(use (const_int 1))]))\n+   (cond_exec (ne (match_dup 6) (const_int 0))\n+     (parallel [(set (match_dup 4)\n+\t\t     (plus:TF (mult:TF (match_dup 5) (match_dup 4))\n+\t\t\t      (match_dup 4)))\n+\t\t(use (const_int 1))]))\n+   (cond_exec (ne (match_dup 6) (const_int 0))\n+     (parallel [(set (match_dup 5)\n+\t\t     (plus:TF (mult:TF (match_dup 5) (match_dup 5))\n+\t\t\t      (match_dup 3)))\n+\t\t(use (const_int 1))]))\n+   (cond_exec (ne (match_dup 6) (const_int 0))\n+     (parallel [(set (match_dup 0)\n+\t\t     (plus:TF (mult:TF (match_dup 5) (match_dup 4))\n+\t\t\t      (match_dup 4)))\n+\t\t(use (const_int 1))]))\n+  ] \n+  \"operands[7] = CONST1_RTX (TFmode);\"\n+  [(set_attr \"predicable\" \"no\")])\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -1557,7 +1759,7 @@\n \n ;; ??? Maybe we should change how adds are canonicalized.\n \n-(define_insn \"*madddi3\"\n+(define_insn \"madddi4\"\n   [(set (match_operand:DI 0 \"fr_register_operand\" \"=f\")\n \t(plus:DI (mult:DI (match_operand:DI 1 \"grfr_register_operand\" \"f\")\n \t\t\t  (match_operand:DI 2 \"grfr_register_operand\" \"f\"))\n@@ -1572,10 +1774,10 @@\n \n ;; We have to use nonmemory_operand for operand 4, to ensure that the\n ;; validate_changes call inside eliminate_regs will always succeed.  If it\n-;; doesn't succeed, then this remain a madddi3 pattern, and will be reloaded\n+;; doesn't succeed, then this remain a madddi4 pattern, and will be reloaded\n ;; incorrectly.\n \n-(define_insn \"*madddi3_elim\"\n+(define_insn \"*madddi4_elim\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n \t(plus:DI (plus:DI (mult:DI (match_operand:DI 1 \"register_operand\" \"f\")\n \t\t\t\t   (match_operand:DI 2 \"register_operand\" \"f\"))\n@@ -1734,6 +1936,208 @@\n   \"popcnt %0 = %1\"\n   [(set_attr \"type\" \"I\")])\n \n+(define_expand \"divdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(div:DI (match_operand:DI 1 \"general_operand\" \"\")\n+\t\t(match_operand:DI 2 \"general_operand\" \"\")))]\n+  \"TARGET_INLINE_DIV\"\n+  \"\n+{\n+  rtx op1_tf, op2_tf, op0_tf;\n+\n+  op0_tf = gen_reg_rtx (TFmode);\n+\n+  if (CONSTANT_P (operands[1]))\n+    operands[1] = force_reg (DImode, operands[1]);\n+  op1_tf = gen_reg_rtx (TFmode);\n+  expand_float (op1_tf, operands[1], 0);\n+\n+  if (CONSTANT_P (operands[2]))\n+    operands[2] = force_reg (DImode, operands[2]);\n+  op2_tf = gen_reg_rtx (TFmode);\n+  expand_float (op2_tf, operands[2], 0);\n+\n+  if (TARGET_INLINE_DIV_LAT)\n+    emit_insn (gen_divdi3_internal_lat (op0_tf, op1_tf, op2_tf));\n+  else\n+    emit_insn (gen_divdi3_internal_thr (op0_tf, op1_tf, op2_tf));\n+\n+  emit_insn (gen_fix_trunctfdi2_alts (operands[0], op0_tf, const1_rtx));\n+  DONE;\n+}\")\n+\n+(define_expand \"moddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(mod:SI (match_operand:DI 1 \"general_operand\" \"\")\n+\t\t(match_operand:DI 2 \"general_operand\" \"\")))]\n+  \"TARGET_INLINE_DIV\"\n+  \"\n+{\n+  rtx op2_neg, div;\n+\n+  div = gen_reg_rtx (DImode);\n+  emit_insn (gen_divdi3 (div, operands[1], operands[2]));\n+\n+  op2_neg = expand_unop (DImode, neg_optab, operands[2], NULL_RTX, 0);\n+\n+  emit_insn (gen_madddi4 (operands[0], div, op2_neg, operands[1]));\n+  DONE;\n+}\")\n+\n+(define_expand \"udivdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(udiv:DI (match_operand:DI 1 \"general_operand\" \"\")\n+\t\t (match_operand:DI 2 \"general_operand\" \"\")))]\n+  \"TARGET_INLINE_DIV\"\n+  \"\n+{\n+  rtx op1_tf, op2_tf, op0_tf;\n+\n+  op0_tf = gen_reg_rtx (TFmode);\n+\n+  if (CONSTANT_P (operands[1]))\n+    operands[1] = force_reg (DImode, operands[1]);\n+  op1_tf = gen_reg_rtx (TFmode);\n+  expand_float (op1_tf, operands[1], 1);\n+\n+  if (CONSTANT_P (operands[2]))\n+    operands[2] = force_reg (DImode, operands[2]);\n+  op2_tf = gen_reg_rtx (TFmode);\n+  expand_float (op2_tf, operands[2], 1);\n+\n+  if (TARGET_INLINE_DIV_LAT)\n+    emit_insn (gen_divdi3_internal_lat (op0_tf, op1_tf, op2_tf));\n+  else\n+    emit_insn (gen_divdi3_internal_thr (op0_tf, op1_tf, op2_tf));\n+\n+  emit_insn (gen_fixuns_trunctfdi2_alts (operands[0], op0_tf, const1_rtx));\n+  DONE;\n+}\")\n+\n+(define_expand \"umoddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(umod:DI (match_operand:DI 1 \"general_operand\" \"\")\n+\t\t (match_operand:DI 2 \"general_operand\" \"\")))]\n+  \"TARGET_INLINE_DIV\"\n+  \"\n+{\n+  rtx op2_neg, div;\n+\n+  div = gen_reg_rtx (DImode);\n+  emit_insn (gen_udivdi3 (div, operands[1], operands[2]));\n+\n+  op2_neg = expand_unop (DImode, neg_optab, operands[2], NULL_RTX, 0);\n+\n+  emit_insn (gen_madddi4 (operands[0], div, op2_neg, operands[1]));\n+  DONE;\n+}\")\n+\n+(define_insn_and_split \"divdi3_internal_lat\"\n+  [(set (match_operand:TF 0 \"fr_register_operand\" \"=&f\")\n+\t(float:TF (div:SI (match_operand:TF 1 \"fr_register_operand\" \"f\")\n+\t\t\t  (match_operand:TF 2 \"fr_register_operand\" \"f\"))))\n+   (clobber (match_scratch:TF 3 \"=&f\"))\n+   (clobber (match_scratch:TF 4 \"=&f\"))\n+   (clobber (match_scratch:TF 5 \"=&f\"))\n+   (clobber (match_scratch:CC 6 \"=c\"))]\n+  \"TARGET_INLINE_DIV_LAT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0) (div:TF (const_int 1) (match_dup 2)))\n+\t      (set (match_dup 6) (unspec:CC [(match_dup 1) (match_dup 2)] 5))\n+\t      (use (const_int 1))])\n+   (cond_exec (ne (match_dup 6) (const_int 0))\n+     (parallel [(set (match_dup 3)\n+\t\t     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 0)))\n+\t\t\t      (match_dup 7)))\n+\t\t(use (const_int 1))]))\n+   (cond_exec (ne (match_dup 6) (const_int 0))\n+     (parallel [(set (match_dup 4) (mult:TF (match_dup 1) (match_dup 0)))\n+\t\t(use (const_int 1))]))\n+   (cond_exec (ne (match_dup 6) (const_int 0))\n+     (parallel [(set (match_dup 5) (mult:TF (match_dup 3) (match_dup 3)))\n+\t\t(use (const_int 1))]))\n+   (cond_exec (ne (match_dup 6) (const_int 0))\n+     (parallel [(set (match_dup 4)\n+\t\t     (plus:TF (mult:TF (match_dup 3) (match_dup 4))\n+\t\t\t      (match_dup 4)))\n+\t\t(use (const_int 1))]))\n+   (cond_exec (ne (match_dup 6) (const_int 0))\n+     (parallel [(set (match_dup 0)\n+\t\t     (plus:TF (mult:TF (match_dup 3) (match_dup 0))\n+\t\t\t      (match_dup 0)))\n+\t\t(use (const_int 1))]))\n+   (cond_exec (ne (match_dup 6) (const_int 0))\n+     (parallel [(set (match_dup 3)\n+\t\t     (plus:TF (mult:TF (match_dup 5) (match_dup 4))\n+\t\t\t      (match_dup 4)))\n+\t\t(use (const_int 1))]))\n+   (cond_exec (ne (match_dup 6) (const_int 0))\n+     (parallel [(set (match_dup 0)\n+\t\t     (plus:TF (mult:TF (match_dup 5) (match_dup 0))\n+\t\t\t      (match_dup 0)))\n+\t\t(use (const_int 1))]))\n+   (cond_exec (ne (match_dup 6) (const_int 0))\n+     (parallel [(set (match_dup 4)\n+\t\t     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 3)))\n+\t\t\t      (match_dup 1)))\n+\t\t(use (const_int 1))]))\n+   (cond_exec (ne (match_dup 6) (const_int 0))\n+     (parallel [(set (match_dup 0)\n+\t\t     (plus:TF (mult:TF (match_dup 4) (match_dup 0))\n+\t\t\t      (match_dup 3)))\n+\t\t(use (const_int 1))]))\n+  ] \n+  \"operands[7] = CONST1_RTX (TFmode);\"\n+  [(set_attr \"predicable\" \"no\")])\n+\n+(define_insn_and_split \"divdi3_internal_thr\"\n+  [(set (match_operand:TF 0 \"fr_register_operand\" \"=&f\")\n+\t(float:TF (div:SI (match_operand:TF 1 \"fr_register_operand\" \"f\")\n+\t\t\t  (match_operand:TF 2 \"fr_register_operand\" \"f\"))))\n+   (clobber (match_scratch:TF 3 \"=&f\"))\n+   (clobber (match_scratch:TF 4 \"=f\"))\n+   (clobber (match_scratch:CC 5 \"=c\"))]\n+  \"TARGET_INLINE_DIV_THR\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0) (div:TF (const_int 1) (match_dup 2)))\n+\t      (set (match_dup 5) (unspec:CC [(match_dup 1) (match_dup 2)] 5))\n+\t      (use (const_int 1))])\n+   (cond_exec (ne (match_dup 5) (const_int 0))\n+     (parallel [(set (match_dup 3)\n+\t\t     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 0)))\n+\t\t\t      (match_dup 6)))\n+\t\t(use (const_int 1))]))\n+   (cond_exec (ne (match_dup 5) (const_int 0))\n+     (parallel [(set (match_dup 0)\n+\t\t     (plus:TF (mult:TF (match_dup 3) (match_dup 0))\n+\t\t\t      (match_dup 0)))\n+\t\t(use (const_int 1))]))\n+   (cond_exec (ne (match_dup 5) (const_int 0))\n+     (parallel [(set (match_dup 3) (mult:TF (match_dup 3) (match_dup 3)))\n+\t\t(use (const_int 1))]))\n+   (cond_exec (ne (match_dup 5) (const_int 0))\n+     (parallel [(set (match_dup 0)\n+\t\t     (plus:TF (mult:TF (match_dup 3) (match_dup 0))\n+\t\t\t      (match_dup 0)))\n+\t\t(use (const_int 1))]))\n+   (cond_exec (ne (match_dup 5) (const_int 0))\n+     (parallel [(set (match_dup 3) (mult:TF (match_dup 0) (match_dup 1)))\n+\t\t(use (const_int 1))]))\n+   (cond_exec (ne (match_dup 5) (const_int 0))\n+     (parallel [(set (match_dup 4)\n+\t\t     (plus:TF (neg:TF (mult:TF (match_dup 2) (match_dup 3)))\n+\t\t\t      (match_dup 1)))\n+\t\t(use (const_int 1))]))\n+   (cond_exec (ne (match_dup 5) (const_int 0))\n+     (parallel [(set (match_dup 0)\n+\t\t     (plus:TF (mult:TF (match_dup 4) (match_dup 0))\n+\t\t\t      (match_dup 3)))\n+\t\t(use (const_int 1))]))\n+  ] \n+  \"operands[6] = CONST1_RTX (TFmode);\"\n+  [(set_attr \"predicable\" \"no\")])\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -1802,7 +2206,7 @@\n   \"fmax %0 = %1, %F2%B0\"\n   [(set_attr \"type\" \"F\")])\n \n-(define_insn \"*maddsf3\"\n+(define_insn \"*maddsf4\"\n   [(set (match_operand:SF 0 \"fr_register_operand\" \"=f\")\n \t(plus:SF (mult:SF (match_operand:SF 1 \"fr_register_operand\" \"f\")\n \t\t\t  (match_operand:SF 2 \"fr_register_operand\" \"f\"))\n@@ -1811,7 +2215,7 @@\n   \"fma.s %0 = %1, %2, %F3%B0\"\n   [(set_attr \"type\" \"F\")])\n \n-(define_insn \"*msubsf3\"\n+(define_insn \"*msubsf4\"\n   [(set (match_operand:SF 0 \"fr_register_operand\" \"=f\")\n \t(minus:SF (mult:SF (match_operand:SF 1 \"fr_register_operand\" \"f\")\n \t\t\t   (match_operand:SF 2 \"fr_register_operand\" \"f\"))\n@@ -1830,7 +2234,7 @@\n \n ;; ??? Is it possible to canonicalize this as (minus (reg) (mult))?\n \n-(define_insn \"*nmaddsf3\"\n+(define_insn \"*nmaddsf4\"\n   [(set (match_operand:SF 0 \"fr_register_operand\" \"=f\")\n \t(plus:SF (neg:SF (mult:SF (match_operand:SF 1 \"fr_register_operand\" \"f\")\n \t\t\t\t  (match_operand:SF 2 \"fr_register_operand\" \"f\")))\n@@ -1907,7 +2311,7 @@\n   \"fmax %0 = %1, %F2%B0\"\n   [(set_attr \"type\" \"F\")])\n \n-(define_insn \"*madddf3\"\n+(define_insn \"*madddf4\"\n   [(set (match_operand:DF 0 \"fr_register_operand\" \"=f\")\n \t(plus:DF (mult:DF (match_operand:DF 1 \"fr_register_operand\" \"f\")\n \t\t\t  (match_operand:DF 2 \"fr_register_operand\" \"f\"))\n@@ -1916,7 +2320,7 @@\n   \"fma.d %0 = %1, %2, %F3%B0\"\n   [(set_attr \"type\" \"F\")])\n \n-(define_insn \"*msubdf3\"\n+(define_insn \"*msubdf4\"\n   [(set (match_operand:DF 0 \"fr_register_operand\" \"=f\")\n \t(minus:DF (mult:DF (match_operand:DF 1 \"fr_register_operand\" \"f\")\n \t\t\t   (match_operand:DF 2 \"fr_register_operand\" \"f\"))\n@@ -1935,7 +2339,7 @@\n \n ;; ??? Is it possible to canonicalize this as (minus (reg) (mult))?\n \n-(define_insn \"*nmadddf3\"\n+(define_insn \"*nmadddf4\"\n   [(set (match_operand:DF 0 \"fr_register_operand\" \"=f\")\n \t(plus:DF (neg:DF (mult:DF (match_operand:DF 1 \"fr_register_operand\" \"f\")\n \t\t\t\t  (match_operand:DF 2 \"fr_register_operand\" \"f\")))\n@@ -1974,6 +2378,15 @@\n   \"fmpy %0 = %F1, %F2%B0\"\n   [(set_attr \"type\" \"F\")])\n \n+(define_insn \"*multf3_alts\"\n+  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n+\t(mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n+\t\t (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))\n+   (use (match_operand:SI 3 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"fmpy.s%3 %0 = %F1, %F2%B0\"\n+  [(set_attr \"type\" \"F\")])\n+\n (define_insn \"abstf2\"\n   [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n \t(abs:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")))]\n@@ -2011,7 +2424,7 @@\n   \"fmax %0 = %F1, %F2%B0\"\n   [(set_attr \"type\" \"F\")])\n \n-(define_insn \"*maddtf3\"\n+(define_insn \"*maddtf4\"\n   [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n \t(plus:TF (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t\t  (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))\n@@ -2020,7 +2433,17 @@\n   \"fma %0 = %F1, %F2, %F3%B0\"\n   [(set_attr \"type\" \"F\")])\n \n-(define_insn \"*msubtf3\"\n+(define_insn \"*maddtf4_alts\"\n+  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n+\t(plus:TF (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n+\t\t\t  (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))\n+\t\t (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\")))\n+   (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"fma.s%4 %0 = %F1, %F2, %F3%B0\"\n+  [(set_attr \"type\" \"F\")])\n+\n+(define_insn \"*msubtf4\"\n   [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n \t(minus:TF (mult:TF (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n \t\t\t   (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\"))\n@@ -2039,7 +2462,7 @@\n \n ;; ??? Is it possible to canonicalize this as (minus (reg) (mult))?\n \n-(define_insn \"*nmaddtf3\"\n+(define_insn \"*nmaddtf4\"\n   [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n \t(plus:TF (neg:TF (mult:TF\n \t\t\t  (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n@@ -2048,6 +2471,29 @@\n   \"\"\n   \"fnma %0 = %F1, %F2, %F3%B0\"\n   [(set_attr \"type\" \"F\")])\n+\n+(define_insn \"*nmaddtf4_alts\"\n+  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n+\t(plus:TF (neg:TF (mult:TF\n+\t\t\t  (match_operand:TF 1 \"tfreg_or_fp01_operand\" \"fG\")\n+\t\t\t  (match_operand:TF 2 \"tfreg_or_fp01_operand\" \"fG\")))\n+\t\t (match_operand:TF 3 \"tfreg_or_fp01_operand\" \"fG\")))\n+   (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"fnma.s%4 %0 = %F1, %F2, %F3%B0\"\n+  [(set_attr \"type\" \"F\")])\n+\n+(define_insn \"*recip_approx\"\n+  [(set (match_operand:TF 0 \"fr_register_operand\" \"=f\")\n+\t(div:TF (const_int 1)\n+\t\t(match_operand:TF 3 \"fr_register_operand\" \"f\")))\n+   (set (match_operand:CC 1 \"register_operand\" \"=c\")\n+\t(unspec:CC [(match_operand:TF 2 \"fr_register_operand\" \"f\")\n+\t\t    (match_dup 3)] 5))\n+   (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"frcpa.s%4 %0, %1 = %2, %3\"\n+  [(set_attr \"type\" \"F\")])\n \f\n ;; ::::::::::::::::::::\n ;; ::"}]}