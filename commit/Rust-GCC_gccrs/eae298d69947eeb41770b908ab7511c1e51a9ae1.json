{"sha": "eae298d69947eeb41770b908ab7511c1e51a9ae1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFlMjk4ZDY5OTQ3ZWViNDE3NzBiOTA4YWI3NTExYzFlNTFhOWFlMQ==", "commit": {"author": {"name": "Christian Bruel", "email": "christian.bruel@st.com", "date": "2014-01-13T09:16:48Z"}, "committer": {"name": "Christian Bruel", "email": "chrbr@gcc.gnu.org", "date": "2014-01-13T09:16:48Z"}, "message": "sh-mem.cc (sh_expand_cmpnstr): Unroll small sizes and optimized non constant lengths.\n\n2014-01-13  Christian Bruel  <christian.bruel@st.com>\n\n\t* config/sh/sh-mem.cc (sh_expand_cmpnstr): Unroll small sizes and\n\t  optimized non constant lengths.\n\nFrom-SVN: r206575", "tree": {"sha": "ba383bb1770240e8f9c02e39fabaa0562498ebbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba383bb1770240e8f9c02e39fabaa0562498ebbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eae298d69947eeb41770b908ab7511c1e51a9ae1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eae298d69947eeb41770b908ab7511c1e51a9ae1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eae298d69947eeb41770b908ab7511c1e51a9ae1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eae298d69947eeb41770b908ab7511c1e51a9ae1/comments", "author": null, "committer": null, "parents": [{"sha": "698da88a864c2d693d68cb6018a36bd9781687a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/698da88a864c2d693d68cb6018a36bd9781687a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/698da88a864c2d693d68cb6018a36bd9781687a9"}], "stats": {"total": 225, "additions": 137, "deletions": 88}, "files": [{"sha": "dda0eb3abaa4edd3a7a29c1500ed2aa00cd9ddf8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae298d69947eeb41770b908ab7511c1e51a9ae1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae298d69947eeb41770b908ab7511c1e51a9ae1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eae298d69947eeb41770b908ab7511c1e51a9ae1", "patch": "@@ -1,3 +1,8 @@\n+2014-01-13  Christian Bruel  <christian.bruel@st.com>\n+\n+\t* config/sh/sh-mem.cc (sh_expand_cmpnstr): Unroll small sizes and\n+\t  optimized non constant lengths.\n+\n 2014-01-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR libgomp/59194"}, {"sha": "e29ff775449bf74e871dab255ba72abb4b4f61fc", "filename": "gcc/config/sh/sh-mem.cc", "status": "modified", "additions": 118, "deletions": 85, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae298d69947eeb41770b908ab7511c1e51a9ae1/gcc%2Fconfig%2Fsh%2Fsh-mem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae298d69947eeb41770b908ab7511c1e51a9ae1/gcc%2Fconfig%2Fsh%2Fsh-mem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-mem.cc?ref=eae298d69947eeb41770b908ab7511c1e51a9ae1", "patch": "@@ -324,7 +324,6 @@ sh_expand_cmpnstr (rtx *operands)\n   rtx addr2 = operands[2];\n   rtx s1_addr = copy_addr_to_reg (XEXP (addr1, 0));\n   rtx s2_addr = copy_addr_to_reg (XEXP (addr2, 0));\n-  rtx tmp0 = gen_reg_rtx (SImode);\n   rtx tmp1 = gen_reg_rtx (SImode);\n   rtx tmp2 = gen_reg_rtx (SImode);\n \n@@ -334,98 +333,132 @@ sh_expand_cmpnstr (rtx *operands)\n   rtx L_end_loop_byte = gen_label_rtx ();\n \n   rtx len = force_reg (SImode, operands[3]);\n-  int constp = (CONST_INT_P (operands[3]));\n-  int bytes = (constp ? INTVAL (operands[3]) : 0);\n-  int witers = bytes / 4;\n+  int constp = CONST_INT_P (operands[3]);\n \n-  /* We could still loop on a register count. Not found very\n-     convincing to optimize yet.  */\n-  if (! constp)\n-    return false;\n-\n-  if (witers > 1)\n+  /* Loop on a register count. */\n+  if (constp)\n     {\n-      rtx L_loop_long = gen_label_rtx ();\n-      rtx L_end_loop_long = gen_label_rtx ();\n+      rtx tmp0 = gen_reg_rtx (SImode);\n       rtx tmp3 = gen_reg_rtx (SImode);\n       rtx lenw = gen_reg_rtx (SImode);\n-      int align = INTVAL (operands[4]);\n-\n-      emit_move_insn (tmp0, const0_rtx);\n-\n-      if (align < 4)\n-\t{\n-\t  emit_insn (gen_iorsi3 (tmp1, s1_addr, s2_addr));\n-\t  emit_insn (gen_tstsi_t (GEN_INT (3), tmp1));\n-\t  jump = emit_jump_insn (gen_branch_false (L_loop_byte));\n-\t  add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n-\t}\n-\n-      addr1 = adjust_automodify_address (addr1, SImode, s1_addr, 0);\n-      addr2 = adjust_automodify_address (addr2, SImode, s2_addr, 0);\n-\n-      /* word count. Do we have iterations ? */\n-      emit_insn (gen_lshrsi3 (lenw, len, GEN_INT (2)));\n-\n-      /*start long loop.  */\n-      emit_label (L_loop_long);\n-\n-      /* tmp2 is aligned, OK to load.  */\n-      emit_move_insn (tmp2, addr2);\n-      emit_move_insn (s2_addr, plus_constant (Pmode, s2_addr, 4));\n-\n-      /* tmp1 is aligned, OK to load.  */\n-      emit_move_insn (tmp1, addr1);\n-      emit_move_insn (s1_addr, plus_constant (Pmode, s1_addr, 4));\n-\n-      /* Is there a 0 byte ?  */\n-      emit_insn (gen_andsi3 (tmp3, tmp2, tmp1));\n-\n-      emit_insn (gen_cmpstr_t (tmp0, tmp3));\n-      jump = emit_jump_insn (gen_branch_true (L_end_loop_long));\n-      add_int_reg_note (jump, REG_BR_PROB, prob_unlikely);\n \n-      emit_insn (gen_cmpeqsi_t (tmp1, tmp2));\n-      jump = emit_jump_insn (gen_branch_false (L_end_loop_long));\n-      add_int_reg_note (jump, REG_BR_PROB, prob_unlikely);\n-\n-      if (TARGET_SH2)\n-\temit_insn (gen_dect (lenw, lenw));\n-      else\n-\t{\n-\t  emit_insn (gen_addsi3 (lenw, lenw, GEN_INT (-1)));\n-\t  emit_insn (gen_tstsi_t (lenw, lenw));\n-\t}\n-      jump = emit_jump_insn (gen_branch_false (L_loop_long));\n-      add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n-\n-      /* end loop.  Reached max iterations.  */\n-      if (bytes % 4 == 0)\n-\t{\n-\t  /* Done.  */\n-\t  jump = emit_jump_insn (gen_jump_compact (L_return));\n-\t  emit_barrier_after (jump);\n-\t}\n-      else\n-\t{\n-\t  /* Remaining bytes to read.   */\n-\t  emit_move_insn (len, GEN_INT (bytes % 4));\n-\t  jump = emit_jump_insn (gen_jump_compact (L_loop_byte));\n-\t  emit_barrier_after (jump);\n-\t}\n-\n-      emit_label (L_end_loop_long);\n-\n-      /* Remaining bytes to read.   */\n-      emit_move_insn (len, GEN_INT (4));\n+      rtx L_loop_long = gen_label_rtx ();\n+      rtx L_end_loop_long = gen_label_rtx ();\n+      rtx L_small = gen_label_rtx ();\n \n-      /* Found last word.  Restart it byte per byte. */\n-      emit_move_insn (s1_addr, plus_constant (Pmode, s1_addr, -4));\n-      emit_move_insn (s2_addr, plus_constant (Pmode, s2_addr, -4));\n+      int align = INTVAL (operands[4]);\n+      int bytes = INTVAL (operands[3]);\n+      int witers = bytes / 4;\n+\n+      if (witers > 1)\n+        {\n+          addr1 = adjust_automodify_address (addr1, SImode, s1_addr, 0);\n+          addr2 = adjust_automodify_address (addr2, SImode, s2_addr, 0);\n+\n+          emit_move_insn (tmp0, const0_rtx);\n+\n+          if (align < 4)\n+            {\n+              emit_insn (gen_iorsi3 (tmp1, s1_addr, s2_addr));\n+              emit_insn (gen_tstsi_t (GEN_INT (3), tmp1));\n+              jump = emit_jump_insn (gen_branch_false (L_loop_byte));\n+              add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n+            }\n+\n+          /* word count. Do we have iterations ? */\n+          emit_insn (gen_lshrsi3 (lenw, len, GEN_INT (2)));\n+\n+          /*start long loop.  */\n+          emit_label (L_loop_long);\n+\n+          /* tmp2 is aligned, OK to load.  */\n+          emit_move_insn (tmp2, addr2);\n+          emit_move_insn (s2_addr, plus_constant (Pmode, s2_addr,\n+                                                  GET_MODE_SIZE (SImode)));\n+\n+          /* tmp1 is aligned, OK to load.  */\n+          emit_move_insn (tmp1, addr1);\n+          emit_move_insn (s1_addr, plus_constant (Pmode, s1_addr,\n+                                                  GET_MODE_SIZE (SImode)));\n+\n+          /* Is there a 0 byte ?  */\n+          emit_insn (gen_andsi3 (tmp3, tmp2, tmp1));\n+\n+          emit_insn (gen_cmpstr_t (tmp0, tmp3));\n+          jump = emit_jump_insn (gen_branch_true (L_end_loop_long));\n+          add_int_reg_note (jump, REG_BR_PROB, prob_unlikely);\n+\n+          emit_insn (gen_cmpeqsi_t (tmp1, tmp2));\n+          jump = emit_jump_insn (gen_branch_false (L_end_loop_long));\n+          add_int_reg_note (jump, REG_BR_PROB, prob_unlikely);\n+\n+          if (TARGET_SH2)\n+            emit_insn (gen_dect (lenw, lenw));\n+          else\n+            {\n+              emit_insn (gen_addsi3 (lenw, lenw, GEN_INT (-1)));\n+              emit_insn (gen_tstsi_t (lenw, lenw));\n+            }\n+\n+          jump = emit_jump_insn (gen_branch_false (L_loop_long));\n+          add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n+\n+          /* end loop.  Reached max iterations.  */\n+          if (bytes % 4 == 0)\n+            {\n+              /* Done.  */\n+              jump = emit_jump_insn (gen_jump_compact (L_return));\n+              emit_barrier_after (jump);\n+            }\n+          else\n+            {\n+              /* Remaining bytes to read.   */\n+              jump = emit_jump_insn (gen_jump_compact (L_small));\n+              emit_barrier_after (jump);\n+            }\n+\n+          emit_label (L_end_loop_long);\n+\n+          /* Found last word.  Restart it byte per byte. */\n+          bytes =  4;\n+          emit_move_insn (s1_addr, plus_constant (Pmode, s1_addr,\n+                                                  -GET_MODE_SIZE (SImode)));\n+          emit_move_insn (s2_addr, plus_constant (Pmode, s2_addr,\n+                                                  -GET_MODE_SIZE (SImode)));\n+        }\n+\n+      emit_label (L_small);\n+\n+      gcc_assert (bytes <= 7);\n+\n+      addr1 = adjust_automodify_address (addr1, QImode, s1_addr, 0);\n+      addr2 = adjust_automodify_address (addr2, QImode, s2_addr, 0);\n+\n+      while (bytes--)\n+        {\n+          emit_insn (gen_extendqisi2 (tmp1, addr1));\n+          emit_insn (gen_extendqisi2 (tmp2, addr2));\n+\n+          emit_insn (gen_cmpeqsi_t (tmp2, const0_rtx));\n+          jump = emit_jump_insn (gen_branch_true (L_end_loop_byte));\n+          add_int_reg_note (jump, REG_BR_PROB, prob_unlikely);\n+\n+          emit_insn (gen_cmpeqsi_t (tmp1, tmp2));\n+          if (flag_delayed_branch)\n+            emit_insn (gen_zero_extendqisi2 (tmp2, gen_lowpart (QImode, tmp2)));\n+          jump = emit_jump_insn (gen_branch_false (L_end_loop_byte));\n+          add_int_reg_note (jump, REG_BR_PROB, prob_unlikely);\n+\n+          addr1 = adjust_address (addr1, QImode, GET_MODE_SIZE (QImode));\n+          addr2 = adjust_address (addr2, QImode, GET_MODE_SIZE (QImode));\n+        }\n+\n+      jump = emit_jump_insn (gen_jump_compact( L_end_loop_byte));\n+      emit_barrier_after (jump);\n     }\n \n-  addr1 = adjust_address (addr1, QImode, 0);\n-  addr2 = adjust_address (addr2, QImode, 0);\n+  addr1 = adjust_automodify_address (addr1, QImode, s1_addr, 0);\n+  addr2 = adjust_automodify_address (addr2, QImode, s2_addr, 0);\n \n   emit_label (L_loop_byte);\n "}, {"sha": "b22f872643702afdad3276fdb503241fdd514836", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae298d69947eeb41770b908ab7511c1e51a9ae1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae298d69947eeb41770b908ab7511c1e51a9ae1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eae298d69947eeb41770b908ab7511c1e51a9ae1", "patch": "@@ -1,3 +1,7 @@\n+2014-01-13  Christian Bruel  <christian.bruel@st.com>\n+\n+\t* gcc.target/sh/cmpstrn.c: New case.\n+\n 2014-01-13  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.dg/vect/vect-simd-clone-10.c: Add dg-do run."}, {"sha": "3a1d0d1519fffb8c99a02fb9dc0aaf420e95acff", "filename": "gcc/testsuite/gcc.target/sh/cmpstrn.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae298d69947eeb41770b908ab7511c1e51a9ae1/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fcmpstrn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae298d69947eeb41770b908ab7511c1e51a9ae1/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fcmpstrn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fcmpstrn.c?ref=eae298d69947eeb41770b908ab7511c1e51a9ae1", "patch": "@@ -6,16 +6,23 @@\n /* { dg-final { scan-assembler-not \"jmp\" } } */\n /* { dg-final { scan-assembler-times \"cmp/str\" 1 } } */\n \n-/* Test that the cmp/str loop is optimized out.  */\n-test01(const char *s1, const char *s2, int n)\n+/* Test that cmp/str is not used for small lengths.  */\n+test01(const char *s1)\n {\n   return __builtin_strncmp (s1, \"abcde\", 3);\n }\n \n /* Test that the cmp/str loop is used.  */\n-test02(const char *s1, const char *s2, int n)\n+test02(const char *s1)\n {\n   return __builtin_strncmp (s1, \"abcdefghi\", 8);\n }\n \n+/* Test that no call is generated  */\n+test03(const char *s1, int n)\n+{\n+  return __builtin_strncmp (s1, \"abcde\", n);\n+}\n+\n+\n "}]}