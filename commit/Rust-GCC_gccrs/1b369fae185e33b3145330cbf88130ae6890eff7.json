{"sha": "1b369fae185e33b3145330cbf88130ae6890eff7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWIzNjlmYWUxODVlMzNiMzE0NTMzMGNiZjg4MTMwYWU2ODkwZWZmNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2006-01-17T02:17:16Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2006-01-17T02:17:16Z"}, "message": "backport: Makefile.in (TREE_INLINE_H): New.\n\n        Merge from gomp branch:\n        * Makefile.in (TREE_INLINE_H): New.  Use it as needed.\n        * tree-inline.h (struct copy_body_data): Move from tree-inline.c\n        and rename from struct inline_data.  Rename callee* to dst*;\n        caller* to src*; add copy_decl hook, transform_call_graph_edges,\n        transform_new_cfg, transform_return_to_modify, and\n        transform_lang_insert_block flags; remove cloning_p, versioning_p,\n        update_clones_p.\n        (copy_body_r, insert_decl_map, remap_decl, remap_type): Declare.\n        (copy_decl_for_dup): Remove.\n        * tree-inline.c (struct inline_data): Move to header.\n        (insert_decl_map): Export.\n        (remap_decl): Update for member name changes.  Use copy_decl hook.\n        Allow for replacement to be a non-decl.  Remove dead code.\n        (remap_type_1): Check for existing mapping.\n        (remap_type): Export.\n        (remap_decls): Update for member name changes.\n        (remap_block, copy_bb, copy_cfg_body, copy_generic_body): Likewise.\n        (copy_body, setup_one_parameter, declare_return_variable): Likewise.\n        (expand_call_inline, optimize_inline_calls, clone_body): Likewise.\n        (copy_tree_r, mark_local_for_remap_r, unsave_expr_now): Likewise.\n        (tree_function_versioning, build_duplicate_type): Likewise.\n        (copy_body_r): Likewise.  Export.\n        (copy_decl_for_dup): Split into ...\n        (copy_decl_for_dup_finish, copy_decl_to_var,\n        copy_decl_no_change, copy_decl_maybe_to_var): ... these.\n        (replace_ref_tree, inlining_p): Remove.\n\nFrom-SVN: r109797", "tree": {"sha": "67bce86a2863e0c4b505af9791d46dadcd34e2bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67bce86a2863e0c4b505af9791d46dadcd34e2bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b369fae185e33b3145330cbf88130ae6890eff7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b369fae185e33b3145330cbf88130ae6890eff7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b369fae185e33b3145330cbf88130ae6890eff7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b369fae185e33b3145330cbf88130ae6890eff7/comments", "author": null, "committer": null, "parents": [{"sha": "04578e6489394756890267456daa107a58f56fa7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04578e6489394756890267456daa107a58f56fa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04578e6489394756890267456daa107a58f56fa7"}], "stats": {"total": 787, "additions": 400, "deletions": 387}, "files": [{"sha": "0925a5c0ab2fc4d7c49afc9e563dca354b318d43", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b369fae185e33b3145330cbf88130ae6890eff7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b369fae185e33b3145330cbf88130ae6890eff7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1b369fae185e33b3145330cbf88130ae6890eff7", "patch": "@@ -1,3 +1,33 @@\n+2006-01-16  Richard Henderson  <rth@redhat.com>\n+\n+\tMerge from gomp branch:\n+\t* Makefile.in (TREE_INLINE_H): New.  Use it as needed.\n+\t* tree-inline.h (struct copy_body_data): Move from tree-inline.c\n+\tand rename from struct inline_data.  Rename callee* to dst*; \n+\tcaller* to src*; add copy_decl hook, transform_call_graph_edges,\n+\ttransform_new_cfg, transform_return_to_modify, and\n+\ttransform_lang_insert_block flags; remove cloning_p, versioning_p,\n+\tupdate_clones_p.\n+\t(copy_body_r, insert_decl_map, remap_decl, remap_type): Declare.\n+\t(copy_decl_for_dup): Remove.\n+\t* tree-inline.c (struct inline_data): Move to header.\n+\t(insert_decl_map): Export.\n+\t(remap_decl): Update for member name changes.  Use copy_decl hook.\n+\tAllow for replacement to be a non-decl.  Remove dead code.\n+\t(remap_type_1): Check for existing mapping.\n+\t(remap_type): Export.\n+\t(remap_decls): Update for member name changes.\n+\t(remap_block, copy_bb, copy_cfg_body, copy_generic_body): Likewise.\n+\t(copy_body, setup_one_parameter, declare_return_variable): Likewise.\n+\t(expand_call_inline, optimize_inline_calls, clone_body): Likewise.\n+\t(copy_tree_r, mark_local_for_remap_r, unsave_expr_now): Likewise.\n+\t(tree_function_versioning, build_duplicate_type): Likewise.\n+\t(copy_body_r): Likewise.  Export.\n+\t(copy_decl_for_dup): Split into ...\n+\t(copy_decl_for_dup_finish, copy_decl_to_var,\n+\tcopy_decl_no_change, copy_decl_maybe_to_var): ... these.\n+\t(replace_ref_tree, inlining_p): Remove.\n+\n 2006-01-16  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* ifcvt.c (if_convert): Make it static."}, {"sha": "479014114c14c25248e63fa98bc662870b52fdfd", "filename": "gcc/Makefile.in", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b369fae185e33b3145330cbf88130ae6890eff7/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b369fae185e33b3145330cbf88130ae6890eff7/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1b369fae185e33b3145330cbf88130ae6890eff7", "patch": "@@ -792,6 +792,7 @@ SCEV_H = tree-scalar-evolution.h $(GGC_H) tree-chrec.h $(PARAMS_H)\n LAMBDA_H = lambda.h tree.h vec.h $(GGC_H)\n TREE_DATA_REF_H = tree-data-ref.h $(LAMBDA_H)\n VARRAY_H = varray.h $(MACHMODE_H) $(SYSTEM_H) coretypes.h $(TM_H)\n+TREE_INLINE_H = tree-inline.h varray.h $(SPLAY_TREE_H)\n \n #\f\n # Now figure out from those variables how to compile and link.\n@@ -1532,7 +1533,7 @@ c-incpath.o: c-incpath.c c-incpath.h $(CONFIG_H) $(SYSTEM_H) $(CPPLIB_H) \\\n \n c-decl.o : c-decl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(RTL_H) $(C_TREE_H) $(GGC_H) $(TARGET_H) $(FLAGS_H) function.h output.h \\\n-    $(EXPR_H) debug.h toplev.h intl.h $(TM_P_H) tree-inline.h $(TIMEVAR_H) \\\n+    $(EXPR_H) debug.h toplev.h intl.h $(TM_P_H) $(TREE_INLINE_H) $(TIMEVAR_H) \\\n     opts.h $(C_PRAGMA_H) gt-c-decl.h $(CGRAPH_H) $(HASHTAB_H) libfuncs.h \\\n     except.h $(LANGHOOKS_DEF_H) $(TREE_DUMP_H) $(C_COMMON_H) $(CPPLIB_H) \\\n     $(DIAGNOSTIC_H) input.h langhooks.h $(TREE_GIMPLE_H) tree-mudflap.h  \\\n@@ -1544,7 +1545,7 @@ c-typeck.o : c-typeck.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n c-lang.o : c-lang.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(C_TREE_H) $(DIAGNOSTIC_H) \\\n     $(GGC_H) langhooks.h $(LANGHOOKS_DEF_H) $(C_COMMON_H) gtype-c.h \\\n-    c-objc-common.h $(C_PRAGMA_H) c-common.def tree-inline.h\n+    c-objc-common.h $(C_PRAGMA_H) c-common.def $(TREE_INLINE_H)\n stub-objc.o : stub-objc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \\\n     $(C_COMMON_H)\n c-lex.o : c-lex.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n@@ -1556,7 +1557,7 @@ c-ppoutput.o : c-ppoutput.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n     $(C_PRAGMA_H)\n c-objc-common.o : c-objc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n     $(TM_H) $(TREE_H) $(C_TREE_H) $(RTL_H) insn-config.h $(INTEGRATE_H) \\\n-    function.h $(FLAGS_H) toplev.h tree-inline.h $(DIAGNOSTIC_H) $(VARRAY_H) \\\n+    function.h $(FLAGS_H) toplev.h $(TREE_INLINE_H) $(DIAGNOSTIC_H) $(VARRAY_H) \\\n     langhooks.h $(GGC_H) $(TARGET_H) $(C_PRETTY_PRINT_H) c-objc-common.h \\\n     tree-mudflap.h\n c-aux-info.o : c-aux-info.c  $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n@@ -1596,7 +1597,7 @@ c-common.o : c-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n \t$(GGC_H) $(EXPR_H) $(TM_P_H) builtin-types.def builtin-attrs.def \\\n \t$(DIAGNOSTIC_H) gt-c-common.h langhooks.h $(VARRAY_H) $(RTL_H) \\\n \t$(TARGET_H) $(C_TREE_H) tree-iterator.h langhooks.h tree-mudflap.h \\\n-\tintl.h opts.h real.h $(CPPLIB_H) tree-inline.h $(HASHTAB_H) \\\n+\tintl.h opts.h real.h $(CPPLIB_H) $(TREE_INLINE_H) $(HASHTAB_H) \\\n \t$(BUILTINS_DEF)\n \n c-pretty-print.o : c-pretty-print.c $(C_PRETTY_PRINT_H) \\\n@@ -1605,7 +1606,7 @@ c-pretty-print.o : c-pretty-print.c $(C_PRETTY_PRINT_H) \\\n \n c-opts.o : c-opts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\t\t\\\n         $(TREE_H) $(C_PRAGMA_H) $(FLAGS_H) toplev.h langhooks.h\t\t\\\n-        tree-inline.h $(DIAGNOSTIC_H) intl.h debug.h $(C_COMMON_H)\t\\\n+        $(TREE_INLINE_H) $(DIAGNOSTIC_H) intl.h debug.h $(C_COMMON_H)\t\\\n         opts.h options.h $(MKDEPS_H) c-incpath.h cppdefault.h\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) \\\n \t\t$< $(OUTPUT_OPTION) @TARGET_SYSTEM_ROOT_DEFINE@\n@@ -1625,7 +1626,7 @@ c-format.o : c-format.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) la\n \n c-semantics.o : c-semantics.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n \t$(TREE_H) $(FLAGS_H) toplev.h output.h $(RTL_H) $(GGC_H) \\\n-\t$(PREDICT_H) tree-inline.h $(C_COMMON_H) except.h function.h \\\n+\t$(PREDICT_H) $(TREE_INLINE_H) $(C_COMMON_H) except.h function.h \\\n \tlanghooks.h $(SPLAY_TREE_H) $(TIMEVAR_H) $(TREE_GIMPLE_H) \\\n \t$(VARRAY_H)\n \n@@ -1767,7 +1768,7 @@ convert.o: convert.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(FLAGS_H) convert.h toplev.h langhooks.h real.h\n \n langhooks.o : langhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   $(TREE_H) toplev.h tree-inline.h $(RTL_H) insn-config.h $(INTEGRATE_H) \\\n+   $(TREE_H) toplev.h $(TREE_INLINE_H) $(RTL_H) insn-config.h $(INTEGRATE_H) \\\n    langhooks.h $(LANGHOOKS_DEF_H) $(FLAGS_H) $(GGC_H) $(DIAGNOSTIC_H) intl.h \\\n    $(TREE_GIMPLE_H)\n tree.o : tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n@@ -1781,7 +1782,7 @@ tree-dump.o: tree-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n tree-inline.o : tree-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(RTL_H) $(EXPR_H) $(FLAGS_H) $(PARAMS_H) input.h insn-config.h \\\n    $(VARRAY_H) $(HASHTAB_H) $(SPLAY_TREE_H) toplev.h \\\n-   langhooks.h tree-inline.h $(CGRAPH_H) intl.h function.h $(TREE_GIMPLE_H) \\\n+   langhooks.h $(TREE_INLINE_H) $(CGRAPH_H) intl.h function.h $(TREE_GIMPLE_H) \\\n    debug.h $(DIAGNOSTIC_H) $(TREE_FLOW_H) tree-iterator.h tree-mudflap.h \\\n    ipa-prop.h\n print-tree.o : print-tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n@@ -1799,19 +1800,19 @@ tree-ssa.o : tree-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    toplev.h function.h $(TIMEVAR_H) $(TM_H) coretypes.h \\\n    $(TREE_DUMP_H) langhooks.h tree-pass.h $(BASIC_BLOCK_H) bitmap.h \\\n    $(FLAGS_H) $(GGC_H) hard-reg-set.h $(HASHTAB_H) pointer-set.h \\\n-   $(TREE_GIMPLE_H) tree-inline.h $(VARRAY_H)\n+   $(TREE_GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H)\n tree-into-ssa.o : tree-into-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h $(DIAGNOSTIC_H) \\\n    function.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    langhooks.h domwalk.h tree-pass.h $(GGC_H) $(PARAMS_H) $(BASIC_BLOCK_H) \\\n    bitmap.h $(CFGLOOP_H) $(FLAGS_H) hard-reg-set.h $(HASHTAB_H) \\\n-   $(TREE_GIMPLE_H) tree-inline.h $(VARRAY_H)\n+   $(TREE_GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H)\n tree-outof-ssa.o : tree-outof-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h $(DIAGNOSTIC_H) \\\n    function.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    langhooks.h tree-pass.h $(TREE_SSA_LIVE_H) $(BASIC_BLOCK_H) bitmap.h \\\n    $(FLAGS_H) $(GGC_H) hard-reg-set.h $(HASHTAB_H) $(TREE_GIMPLE_H) \\\n-   tree-inline.h $(VARRAY_H) toplev.h\n+   $(TREE_INLINE_H) $(VARRAY_H) toplev.h\n tree-ssa-dse.o : tree-ssa-dse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n    $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) domwalk.h $(FLAGS_H) \\\n@@ -1861,18 +1862,18 @@ domwalk.o : domwalk.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n tree-ssa-live.o : tree-ssa-live.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(DIAGNOSTIC_H) function.h $(TIMEVAR_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_SSA_LIVE_H) $(BASIC_BLOCK_H) \\\n-   bitmap.h $(FLAGS_H) $(HASHTAB_H) $(TREE_GIMPLE_H) tree-inline.h \\\n+   bitmap.h $(FLAGS_H) $(HASHTAB_H) $(TREE_GIMPLE_H) $(TREE_INLINE_H) \\\n    $(VARRAY_H) toplev.h\n tree-ssa-copyrename.o : tree-ssa-copyrename.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(DIAGNOSTIC_H) function.h $(TIMEVAR_H) tree-pass.h \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_SSA_LIVE_H) $(BASIC_BLOCK_H) \\\n    bitmap.h $(FLAGS_H) $(HASHTAB_H) langhooks.h $(TREE_GIMPLE_H) \\\n-   tree-inline.h\n+   $(TREE_INLINE_H)\n tree-ssa-pre.o : tree-ssa-pre.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) $(CFGLOOP_H) \\\n    alloc-pool.h $(BASIC_BLOCK_H) bitmap.h $(HASHTAB_H) $(TREE_GIMPLE_H) \\\n-   tree-inline.h tree-iterator.h\n+   $(TREE_INLINE_H) tree-iterator.h\n tree-vn.o : tree-vn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) \\\n    $(TREE_H) $(TREE_FLOW_H) $(HASHTAB_H) langhooks.h tree-pass.h \\\n    $(TREE_DUMP_H) $(DIAGNOSTIC_H)\n@@ -1903,9 +1904,9 @@ tree-ssa-sink.o : tree-ssa-sink.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) alloc-pool.h \\\n    $(BASIC_BLOCK_H) bitmap.h $(CFGLOOP_H) $(FIBHEAP_H) $(HASHTAB_H) \\\n-   langhooks.h real.h $(TREE_GIMPLE_H) tree-inline.h tree-iterator.h\n+   langhooks.h real.h $(TREE_GIMPLE_H) $(TREE_INLINE_H) tree-iterator.h\n tree-nested.o: tree-nested.c $(CONFIG_H) $(SYSTEM_H) $(TM_H) $(TREE_H) \\\n-   $(RTL_H) $(TM_P_H) function.h $(TREE_DUMP_H) tree-inline.h \\\n+   $(RTL_H) $(TM_P_H) function.h $(TREE_DUMP_H) $(TREE_INLINE_H) \\\n    tree-iterator.h $(TREE_GIMPLE_H) $(CGRAPH_H) $(EXPR_H) langhooks.h \\\n    $(GGC_H) gt-tree-nested.h coretypes.h $(TREE_FLOW_H)\n tree-if-conv.o: tree-if-conv.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n@@ -1917,23 +1918,23 @@ tree-iterator.o : tree-iterator.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n    coretypes.h $(GGC_H) tree-iterator.h $(TREE_GIMPLE_H) gt-tree-iterator.h\n tree-dfa.o : tree-dfa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h $(DIAGNOSTIC_H) \\\n-   tree-inline.h $(HASHTAB_H) pointer-set.h $(FLAGS_H) function.h \\\n+   $(TREE_INLINE_H) $(HASHTAB_H) pointer-set.h $(FLAGS_H) function.h \\\n    $(TIMEVAR_H) convert.h $(TM_H) coretypes.h langhooks.h $(TREE_DUMP_H) \\\n    tree-pass.h $(PARAMS_H) $(CGRAPH_H) $(BASIC_BLOCK_H) hard-reg-set.h \\\n    $(TREE_GIMPLE_H) \n tree-ssa-operands.o : tree-ssa-operands.c $(TREE_FLOW_H) $(CONFIG_H) \\\n-   $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) errors.h tree-inline.h \\\n+   $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) errors.h $(TREE_INLINE_H) \\\n    $(FLAGS_H) function.h $(TM_H) $(TIMEVAR_H) tree-pass.h toplev.h \\\n    gt-tree-ssa-operands.h coretypes.h langhooks.h tree-ssa-opfinalize.h \\\n    $(IPA_REFERENCE_H)\n tree-eh.o : tree-eh.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_H) $(FLAGS_H) function.h except.h langhooks.h \\\n    $(GGC_H) tree-pass.h coretypes.h $(TIMEVAR_H) $(TM_P_H) \\\n-   $(TREE_DUMP_H) tree-inline.h tree-iterator.h toplev.h\n+   $(TREE_DUMP_H) $(TREE_INLINE_H) tree-iterator.h toplev.h\n tree-ssa-loop.o : tree-ssa-loop.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) \\\n    output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n-   tree-pass.h $(FLAGS_H) tree-inline.h $(SCEV_H) $(BASIC_BLOCK_H) \\\n+   tree-pass.h $(FLAGS_H) $(TREE_INLINE_H) $(SCEV_H) $(BASIC_BLOCK_H) \\\n    hard-reg-set.h\n tree-ssa-loop-unswitch.o : tree-ssa-loop-unswitch.c $(TREE_FLOW_H) \\\n    $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) \\\n@@ -1942,20 +1943,20 @@ tree-ssa-loop-unswitch.o : tree-ssa-loop-unswitch.c $(TREE_FLOW_H) \\\n tree-ssa-address.o : tree-ssa-address.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) \\\n    output.h diagnostic.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n-   tree-pass.h $(FLAGS_H) tree-inline.h $(RECOG_H) insn-config.h $(EXPR_H) \\\n+   tree-pass.h $(FLAGS_H) $(TREE_INLINE_H) $(RECOG_H) insn-config.h $(EXPR_H) \\\n    gt-tree-ssa-address.h $(GGC_H)\n tree-ssa-loop-niter.o : tree-ssa-loop-niter.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(PARAMS_H) \\\n-   tree-inline.h output.h $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n+   $(TREE_INLINE_H) output.h $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    $(FLAGS_H) tree-pass.h $(SCEV_H) $(TREE_DATA_REF_H) $(BASIC_BLOCK_H) \\\n    $(GGC_H) hard-reg-set.h tree-chrec.h intl.h\n tree-ssa-loop-ivcanon.o : tree-ssa-loop-ivcanon.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(PARAMS_H) \\\n-   tree-inline.h output.h $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n+   $(TREE_INLINE_H) output.h $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    $(FLAGS_H) tree-pass.h $(SCEV_H) $(BASIC_BLOCK_H) $(GGC_H) hard-reg-set.h \\\n    tree-chrec.h\n tree-ssa-loop-ch.o : tree-ssa-loop-ch.c $(TREE_FLOW_H) $(CONFIG_H) \\\n-   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) tree-inline.h \\\n+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(TREE_INLINE_H) \\\n    output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    tree-pass.h $(FLAGS_H) $(BASIC_BLOCK_H) hard-reg-set.h\n tree-ssa-loop-ivopts.o : tree-ssa-loop-ivopts.c $(TREE_FLOW_H) $(CONFIG_H) \\\n@@ -1977,39 +1978,39 @@ tree-ssa-math-opts.o : tree-ssa-math-opts.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(TIMEVAR_H) tree-pass.h $(TM_H) $(FLAGS_H) \\\n    alloc-pool.h $(BASIC_BLOCK_H) $(TARGET_H)\n tree-ssa-alias.o : tree-ssa-alias.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n-   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) tree-inline.h $(FLAGS_H) \\\n+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) $(TREE_INLINE_H) $(FLAGS_H) \\\n    function.h $(TIMEVAR_H) convert.h $(TM_H) coretypes.h langhooks.h \\\n    $(TREE_DUMP_H) tree-pass.h $(PARAMS_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \\\n    hard-reg-set.h $(TREE_GIMPLE_H) vec.h tree-ssa-structalias.h \\\n    $(IPA_TYPE_ESCAPE_H)\n tree-ssa-reassoc.o : tree-ssa-reassoc.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) errors.h $(TIMEVAR_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) tree-iterator.h\\\n-   $(BASIC_BLOCK_H) $(TREE_GIMPLE_H) tree-inline.h vec.h \\\n+   $(BASIC_BLOCK_H) $(TREE_GIMPLE_H) $(TREE_INLINE_H) vec.h \\\n    alloc-pool.h\n tree-optimize.o : tree-optimize.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h $(DIAGNOSTIC_H) \\\n    $(FLAGS_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) toplev.h \\\n-   function.h langhooks.h $(FLAGS_H) $(CGRAPH_H) tree-inline.h \\\n+   function.h langhooks.h $(FLAGS_H) $(CGRAPH_H) $(TREE_INLINE_H) \\\n    tree-mudflap.h $(GGC_H) $(CGRAPH_H) tree-pass.h $(CFGLOOP_H) \\\n    $(BASIC_BLOCK_H) graph.h hard-reg-set.h\n c-gimplify.o : c-gimplify.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n    $(C_TREE_H) $(C_COMMON_H) $(DIAGNOSTIC_H) $(TREE_GIMPLE_H) $(VARRAY_H) \\\n    $(FLAGS_H) langhooks.h toplev.h $(RTL_H) $(TREE_FLOW_H) $(LANGHOOKS_DEF_H) \\\n    $(TM_H) coretypes.h $(C_PRETTY_PRINT_H) $(CGRAPH_H) $(BASIC_BLOCK_H) \\\n-   hard-reg-set.h $(TREE_DUMP_H) tree-inline.h\n+   hard-reg-set.h $(TREE_DUMP_H) $(TREE_INLINE_H)\n gimplify.o : gimplify.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n-   $(DIAGNOSTIC_H) $(TREE_GIMPLE_H) tree-inline.h $(VARRAY_H) langhooks.h \\\n+   $(DIAGNOSTIC_H) $(TREE_GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H) langhooks.h \\\n    $(LANGHOOKS_DEF_H) $(TREE_FLOW_H) $(CGRAPH_H) $(TIMEVAR_H) $(TM_H) \\\n    coretypes.h except.h $(FLAGS_H) $(RTL_H) function.h $(EXPR_H) output.h \\\n    $(GGC_H) gt-gimplify.h $(HASHTAB_H) real.h $(TARGET_H) toplev.h\n gimple-low.o : gimple-low.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n-   $(DIAGNOSTIC_H) $(TREE_GIMPLE_H) tree-inline.h $(VARRAY_H) langhooks.h \\\n+   $(DIAGNOSTIC_H) $(TREE_GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H) langhooks.h \\\n    $(LANGHOOKS_DEF_H) $(TREE_FLOW_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\\n    except.h $(FLAGS_H) $(RTL_H) function.h $(EXPR_H) tree-pass.h \\\n    $(HASHTAB_H) toplev.h\n tree-browser.o : tree-browser.c tree-browser.def $(CONFIG_H) $(SYSTEM_H) \\\n-   $(TREE_H) tree-inline.h $(DIAGNOSTIC_H) $(HASHTAB_H) \\\n+   $(TREE_H) $(TREE_INLINE_H) $(DIAGNOSTIC_H) $(HASHTAB_H) \\\n    $(TM_H) coretypes.h\n tree-chrec.o: tree-chrec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(GGC_H) $(TREE_H) real.h $(SCEV_H) tree-pass.h $(PARAMS_H) \\\n@@ -2051,12 +2052,12 @@ tree-object-size.o: tree-object-size.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n tree-gimple.o : tree-gimple.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(EXPR_H) \\\n    $(RTL_H) $(TREE_GIMPLE_H) $(TM_H) coretypes.h bitmap.h $(GGC_H) \\\n    output.h $(TREE_FLOW_H)\n-tree-mudflap.o : $(CONFIG_H) $(SYSTEM_H) $(TREE_H) tree-inline.h \\\n+tree-mudflap.o : $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TREE_INLINE_H) \\\n    $(TREE_GIMPLE_H) $(DIAGNOSTIC_H) $(HASHTAB_H) langhooks.h tree-mudflap.h \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(CGRAPH_H) $(GGC_H) \\\n    gt-tree-mudflap.h $(BASIC_BLOCK_H) $(FLAGS_H) function.h hard-reg-set.h \\\n    $(RTL_H) $(TM_P_H) $(TREE_FLOW_H) toplev.h\n-tree-nomudflap.o : $(CONFIG_H) $(SYSTEM_H) $(TREE_H) tree-inline.h \\\n+tree-nomudflap.o : $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TREE_INLINE_H) \\\n    $(C_TREE_H) $(C_COMMON_H) $(TREE_GIMPLE_H) $(DIAGNOSTIC_H) $(HASHTAB_H) \\\n    output.h $(VARRAY_H) langhooks.h tree-mudflap.h $(TM_H) coretypes.h \\\n    $(GGC_H) gt-tree-mudflap.h tree-pass.h toplev.h\n@@ -2098,7 +2099,7 @@ passes.o : passes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(PARAMS_H) $(TM_P_H) reload.h dwarf2asm.h $(TARGET_H) \\\n    langhooks.h insn-flags.h $(CFGLAYOUT_H) real.h $(CFGLOOP_H) \\\n    hosthooks.h $(CGRAPH_H) $(COVERAGE_H) tree-pass.h $(TREE_DUMP_H) \\\n-   $(GGC_H) $(INTEGRATE_H) $(CPPLIB_H) opts.h tree-flow.h tree-inline.h\n+   $(GGC_H) $(INTEGRATE_H) $(CPPLIB_H) opts.h tree-flow.h $(TREE_INLINE_H)\n \n main.o : main.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h\n \n@@ -2220,9 +2221,9 @@ simplify-rtx.o : simplify-rtx.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n cgraph.o : cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    langhooks.h toplev.h $(FLAGS_H) $(GGC_H) $(TARGET_H) $(CGRAPH_H) \\\n    gt-cgraph.h output.h intl.h $(BASIC_BLOCK_H) debug.h $(HASHTAB_H) \\\n-   tree-inline.h $(VARRAY_H) tree-dump.h\n+   $(TREE_INLINE_H) $(VARRAY_H) tree-dump.h\n cgraphunit.o : cgraphunit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   $(TREE_H) langhooks.h tree-inline.h toplev.h $(FLAGS_H) $(GGC_H) \\\n+   $(TREE_H) langhooks.h $(TREE_INLINE_H) toplev.h $(FLAGS_H) $(GGC_H) \\\n    $(TARGET_H) $(CGRAPH_H) intl.h pointer-set.h function.h $(TREE_GIMPLE_H) \\\n    $(TREE_FLOW_H) tree-pass.h $(C_COMMON_H) debug.h $(DIAGNOSTIC_H) \\\n    $(FIBHEAP_H) output.h $(PARAMS_H) $(RTL_H) $(TIMEVAR_H) ipa-prop.h\n@@ -2235,23 +2236,23 @@ ipa-cp.o : ipa-cp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n    tree-flow.h $(TM_H) tree-pass.h $(FLAGS_H) $(TREE_H) \\\n    diagnostic.h\n ipa-inline.o : ipa-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   $(TREE_H) langhooks.h tree-inline.h $(FLAGS_H) $(CGRAPH_H) intl.h \\\n+   $(TREE_H) langhooks.h $(TREE_INLINE_H) $(FLAGS_H) $(CGRAPH_H) intl.h \\\n    $(DIAGNOSTIC_H) $(FIBHEAP_H) $(PARAMS_H) $(TIMEVAR_H) tree-pass.h \\\n    $(COVERAGE_H) $(HASHTAB_H)\n ipa-utils.o : ipa-utils.c $(IPA_UTILS_H) $(CONFIG_H) $(SYSTEM_H) \\\n-   coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) tree-inline.h langhooks.h \\\n+   coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(C_COMMON_H) $(TREE_GIMPLE_H) \\\n    $(CGRAPH_H) output.h $(FLAGS_H) tree-pass.h $(DIAGNOSTIC_H) \n ipa-reference.o : ipa-reference.c $(CONFIG_H) $(SYSTEM_H) \\\n-   coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) tree-inline.h langhooks.h \\\n+   coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(IPA_REFERENCE_H) $(IPA_UTILS_H) $(C_COMMON_H) \\\n    $(TREE_GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) tree-pass.h $(DIAGNOSTIC_H)  \n ipa-pure-const.o : ipa-pure-const.c $(CONFIG_H) $(SYSTEM_H) \\\n-   coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) tree-inline.h langhooks.h \\\n+   coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(IPA_UTILS_H) $(C_COMMON_H) \\\n    $(TREE_GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) tree-pass.h $(DIAGNOSTIC_H)  \n ipa-type-escape.o : ipa-type-escape.c $(CONFIG_H) $(SYSTEM_H) \\\n-   coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) tree-inline.h langhooks.h \\\n+   coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(IPA_TYPE_ESCAPE_H) $(IPA_UTILS_H) $(C_COMMON_H) \\\n    $(TREE_GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) tree-pass.h $(DIAGNOSTIC_H)  \n coverage.o : coverage.c $(GCOV_IO_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n@@ -2295,7 +2296,7 @@ tree-ssa-ccp.o : tree-ssa-ccp.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(TREE_DUMP_H) $(BASIC_BLOCK_H) tree-pass.h langhooks.h \\\n    tree-ssa-propagate.h $(FLAGS_H) $(TARGET_H)\n tree-sra.o : tree-sra.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) \\\n-    $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) tree-inline.h \\\n+    $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) $(TREE_INLINE_H) \\\n     $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_GIMPLE_H) \\\n     langhooks.h tree-pass.h $(FLAGS_H) $(EXPR_H) $(BASIC_BLOCK_H) \\\n     bitmap.h $(GGC_H) hard-reg-set.h $(OBSTACK_H) $(PARAMS_H) $(TARGET_H)"}, {"sha": "7030b92b89d331e15bbfaa7ed9af474d70034b64", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 255, "deletions": 342, "changes": 597, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b369fae185e33b3145330cbf88130ae6890eff7/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b369fae185e33b3145330cbf88130ae6890eff7/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=1b369fae185e33b3145330cbf88130ae6890eff7", "patch": "@@ -34,7 +34,6 @@ Boston, MA 02110-1301, USA.  */\n #include \"insn-config.h\"\n #include \"varray.h\"\n #include \"hashtab.h\"\n-#include \"splay-tree.h\"\n #include \"langhooks.h\"\n #include \"basic-block.h\"\n #include \"tree-iterator.h\"\n@@ -55,7 +54,7 @@ Boston, MA 02110-1301, USA.  */\n    non-gimple trees.  */\n #include \"tree-gimple.h\"\n \n-/* Inlining, Saving, Cloning\n+/* Inlining, Cloning, Versioning, Parallelization\n \n    Inlining: a function body is duplicated, but the PARM_DECLs are\n    remapped into VAR_DECLs, and non-void RETURN_EXPRs become\n@@ -64,21 +63,24 @@ Boston, MA 02110-1301, USA.  */\n    to the info for the caller; the eh_region info in copied throwing\n    statements and RESX_EXPRs is adjusted accordingly.\n \n-   Saving: make a semantically-identical copy of the function body.\n-   Necessary when we want to generate code for the body (a destructive\n-   operation), but we expect to need this body in the future (e.g. for\n-   inlining into another function).\n-\n    Cloning: (only in C++) We have one body for a con/de/structor, and\n    multiple function decls, each with a unique parameter list.\n    Duplicate the body, using the given splay tree; some parameters\n    will become constants (like 0 or 1).\n \n+   Versioning: a function body is duplicated and the result is a new\n+   function rather than into blocks of an existing function as with\n+   inlining.  Some parameters will become constants.\n+\n+   Parallelization: a region of a function is duplicated resulting in\n+   a new function.  Variables may be replaced with complex expressions\n+   to enable shared variable semantics.\n+\n    All of these will simultaneously lookup any callgraph edges.  If\n    we're going to inline the duplicated function body, and the given\n    function has some cloned callgraph nodes (one for each place this\n    function will be inlined) those callgraph edges will be duplicated.\n-   If we're saving or cloning the body, those callgraph edges will be\n+   If we're cloning the body, those callgraph edges will be\n    updated to point into the new body.  (Note that the original\n    callgraph node and edge list will not be altered.)\n \n@@ -103,71 +105,29 @@ int flag_inline_trees = 0;\n    o Provide heuristics to clamp inlining of recursive template\n      calls?  */\n \n-/* Data required for function inlining.  */\n-\n-typedef struct inline_data\n-{\n-  /* FUNCTION_DECL for function being inlined.  */\n-  tree callee;\n-  /* FUNCTION_DECL for function being inlined into.  */\n-  tree caller;\n-  /* struct function for function being inlined.  */\n-  struct function *callee_cfun;\n-  /* The VAR_DECL for the return value.  */\n-  tree retvar;\n-  /* The map from local declarations in the inlined function to\n-     equivalents in the function into which it is being inlined.  */\n-  splay_tree decl_map;\n-  /* We use the same mechanism to build clones that we do to perform\n-     inlining.  However, there are a few places where we need to\n-     distinguish between those two situations.  This flag is true if\n-     we are cloning, rather than inlining.  */\n-  bool cloning_p;\n-  /* Versioning function is slightly different from inlining. */\n-  bool versioning_p;\n-  /* If set, the call_stmt of edges in clones of caller functions will\n-     be updated.  */\n-  bool update_clones_p;\n-  /* Callgraph node of function we are inlining into.  */\n-  struct cgraph_node *node;\n-  /* Callgraph node of currently inlined function.  */\n-  struct cgraph_node *current_node;\n-  /* Current BLOCK.  */\n-  tree block;\n-  varray_type ipa_info;\n-  /* Exception region the inlined call lie in.  */\n-  int eh_region;\n-  /* Take region number in the function being copied, add this value and\n-     get eh region number of the duplicate in the function we inline into.  */\n-  int eh_region_offset;\n-} inline_data;\n-\n /* Prototypes.  */\n \n-static tree declare_return_variable (inline_data *, tree, tree, tree *);\n-static tree copy_body_r (tree *, int *, void *);\n-static tree copy_generic_body (inline_data *);\n+static tree declare_return_variable (copy_body_data *, tree, tree, tree *);\n+static tree copy_generic_body (copy_body_data *);\n static bool inlinable_function_p (tree);\n-static tree remap_decl (tree, inline_data *);\n-static tree remap_type (tree, inline_data *);\n-static void remap_block (tree *, inline_data *);\n-static tree remap_decl (tree, inline_data *);\n-static tree remap_decls (tree, inline_data *);\n-static void copy_bind_expr (tree *, int *, inline_data *);\n+static void remap_block (tree *, copy_body_data *);\n+static tree remap_decls (tree, copy_body_data *);\n+static void copy_bind_expr (tree *, int *, copy_body_data *);\n static tree mark_local_for_remap_r (tree *, int *, void *);\n static void unsave_expr_1 (tree);\n static tree unsave_r (tree *, int *, void *);\n static void declare_inline_vars (tree, tree);\n static void remap_save_expr (tree *, void *, int *);\n-static bool replace_ref_tree (inline_data *, tree *);\n-static inline bool inlining_p (inline_data *);\n static void add_lexical_block (tree current_block, tree new_block);\n+static tree copy_decl_to_var (tree, copy_body_data *);\n+static tree copy_decl_no_change (tree, copy_body_data *);\n+static tree copy_decl_maybe_to_var (tree, copy_body_data *);\n \n /* Insert a tree->tree mapping for ID.  Despite the name suggests\n    that the trees should be variables, it is used for more than that.  */\n \n-static void\n-insert_decl_map (inline_data *id, tree key, tree value)\n+void\n+insert_decl_map (copy_body_data *id, tree key, tree value)\n {\n   splay_tree_insert (id->decl_map, (splay_tree_key) key,\n \t\t     (splay_tree_value) value);\n@@ -181,14 +141,14 @@ insert_decl_map (inline_data *id, tree key, tree value)\n \n /* Remap DECL during the copying of the BLOCK tree for the function.  */\n \n-static tree\n-remap_decl (tree decl, inline_data *id)\n+tree\n+remap_decl (tree decl, copy_body_data *id)\n {\n   splay_tree_node n;\n   tree fn;\n \n   /* We only remap local variables in the current function.  */\n-  fn = id->callee;\n+  fn = id->src_fn;\n \n   /* See if we have remapped this declaration.  */\n \n@@ -199,14 +159,16 @@ remap_decl (tree decl, inline_data *id)\n   if (!n)\n     {\n       /* Make a copy of the variable or label.  */\n-      tree t;\n-      t = copy_decl_for_dup (decl, fn, id->caller, id->versioning_p);\n+      tree t = id->copy_decl (decl, id);\n      \n       /* Remember it, so that if we encounter this local entity again\n \t we can reuse this copy.  Do this early because remap_type may\n \t need this decl for TYPE_STUB_DECL.  */\n       insert_decl_map (id, decl, t);\n \n+      if (!DECL_P (t))\n+\treturn t;\n+\n       /* Remap types, if necessary.  */\n       TREE_TYPE (t) = remap_type (TREE_TYPE (t), id);\n       if (TREE_CODE (t) == TYPE_DECL)\n@@ -224,42 +186,33 @@ remap_decl (tree decl, inline_data *id)\n \t    walk_tree (&DECL_QUALIFIER (t), copy_body_r, id, NULL);\n \t}\n \n-#if 0\n-      /* FIXME handle anon aggrs.  */\n-      if (! DECL_NAME (t) && TREE_TYPE (t)\n-\t  && lang_hooks.tree_inlining.anon_aggr_type_p (TREE_TYPE (t)))\n-\t{\n-\t  /* For a VAR_DECL of anonymous type, we must also copy the\n-\t     member VAR_DECLS here and rechain the DECL_ANON_UNION_ELEMS.  */\n-\t  tree members = NULL;\n-\t  tree src;\n-\n-\t  for (src = DECL_ANON_UNION_ELEMS (t); src;\n-\t       src = TREE_CHAIN (src))\n-\t    {\n-\t      tree member = remap_decl (TREE_VALUE (src), id);\n-\n-\t      gcc_assert (!TREE_PURPOSE (src));\n-\t      members = tree_cons (NULL, member, members);\n-\t    }\n-\t  DECL_ANON_UNION_ELEMS (t) = nreverse (members);\n-\t}\n-#endif\n-\n-      /* Remember it, so that if we encounter this local entity\n-\t again we can reuse this copy.  */\n-      insert_decl_map (id, decl, t);\n       return t;\n     }\n \n   return unshare_expr ((tree) n->value);\n }\n \n static tree\n-remap_type_1 (tree type, inline_data *id)\n+remap_type_1 (tree type, copy_body_data *id)\n {\n+  splay_tree_node node;\n   tree new, t;\n \n+  if (type == NULL)\n+    return type;\n+\n+  /* See if we have remapped this type.  */\n+  node = splay_tree_lookup (id->decl_map, (splay_tree_key) type);\n+  if (node)\n+    return (tree) node->value;\n+\n+  /* The type only needs remapping if it's variably modified.  */\n+  if (! variably_modified_type_p (type, id->src_fn))\n+    {\n+      insert_decl_map (id, type, type);\n+      return type;\n+    }\n+\n   /* We do need a copy.  build and register it now.  If this is a pointer or\n      reference type, remap the designated type and make a new pointer or\n      reference type.  */\n@@ -362,8 +315,8 @@ remap_type_1 (tree type, inline_data *id)\n   return new;\n }\n \n-static tree\n-remap_type (tree type, inline_data *id)\n+tree\n+remap_type (tree type, copy_body_data *id)\n {\n   splay_tree_node node;\n \n@@ -376,7 +329,7 @@ remap_type (tree type, inline_data *id)\n     return (tree) node->value;\n \n   /* The type only needs remapping if it's variably modified.  */\n-  if (! variably_modified_type_p (type, id->callee))\n+  if (! variably_modified_type_p (type, id->src_fn))\n     {\n       insert_decl_map (id, type, type);\n       return type;\n@@ -386,7 +339,7 @@ remap_type (tree type, inline_data *id)\n }\n \n static tree\n-remap_decls (tree decls, inline_data *id)\n+remap_decls (tree decls, copy_body_data *id)\n {\n   tree old_var;\n   tree new_decls = NULL_TREE;\n@@ -399,7 +352,7 @@ remap_decls (tree decls, inline_data *id)\n       /* We can not chain the local static declarations into the unexpanded_var_list\n          as we can't duplicate them or break one decl rule.  Go ahead and link\n          them into unexpanded_var_list.  */\n-      if (!lang_hooks.tree_inlining.auto_var_in_fn_p (old_var, id->callee)\n+      if (!lang_hooks.tree_inlining.auto_var_in_fn_p (old_var, id->src_fn)\n \t  && !DECL_EXTERNAL (old_var))\n \t{\n \t  cfun->unexpanded_var_list = tree_cons (NULL_TREE, old_var,\n@@ -430,7 +383,7 @@ remap_decls (tree decls, inline_data *id)\n    therein.  And hook the new block into the block-tree.  */\n \n static void\n-remap_block (tree *block, inline_data *id)\n+remap_block (tree *block, copy_body_data *id)\n {\n   tree old_block;\n   tree new_block;\n@@ -447,19 +400,18 @@ remap_block (tree *block, inline_data *id)\n   /* Remap its variables.  */\n   BLOCK_VARS (new_block) = remap_decls (BLOCK_VARS (old_block), id);\n \n-  fn = id->caller;\n-  if (id->cloning_p)\n-    /* We're building a clone; DECL_INITIAL is still\n-       error_mark_node, and current_binding_level is the parm\n-       binding level.  */\n+  fn = id->dst_fn;\n+\n+  if (id->transform_lang_insert_block)\n     lang_hooks.decls.insert_block (new_block);\n+\n   /* Remember the remapped block.  */\n   insert_decl_map (id, old_block, new_block);\n }\n \n /* Copy the whole block tree and root it in id->block.  */\n static tree\n-remap_blocks (tree block, inline_data *id)\n+remap_blocks (tree block, copy_body_data *id)\n {\n   tree t;\n   tree new = block;\n@@ -490,7 +442,7 @@ copy_statement_list (tree *tp)\n }\n \n static void\n-copy_bind_expr (tree *tp, int *walk_subtrees, inline_data *id)\n+copy_bind_expr (tree *tp, int *walk_subtrees, copy_body_data *id)\n {\n   tree block = BIND_EXPR_BLOCK (*tp);\n   /* Copy (and replace) the statement.  */\n@@ -508,13 +460,13 @@ copy_bind_expr (tree *tp, int *walk_subtrees, inline_data *id)\n }\n \n /* Called from copy_body_id via walk_tree.  DATA is really an\n-   `inline_data *'.  */\n+   `copy_body_data *'.  */\n \n-static tree\n+tree\n copy_body_r (tree *tp, int *walk_subtrees, void *data)\n {\n-  inline_data *id = (inline_data *) data;\n-  tree fn = id->callee;\n+  copy_body_data *id = (copy_body_data *) data;\n+  tree fn = id->src_fn;\n   tree new_block;\n \n   /* Begin by recognizing trees that we'll completely rewrite for the\n@@ -523,9 +475,10 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n      into an edge).  Further down, we'll handle trees that get\n      duplicated and/or tweaked.  */\n \n-  /* If this is a RETURN_STMT, change it into an EXPR_STMT and a\n-     GOTO_STMT with the RET_LABEL as its target.  */\n-  if (TREE_CODE (*tp) == RETURN_EXPR && inlining_p (id))\n+  /* When requested, RETURN_EXPRs should be transformed to just the\n+     contained MODIFY_EXPR.  The branch semantics of the return will\n+     be handled elsewhere by manipulating the CFG rather than a statement.  */\n+  if (TREE_CODE (*tp) == RETURN_EXPR && id->transform_return_to_modify)\n     {\n       tree assignment = TREE_OPERAND (*tp, 0);\n \n@@ -569,7 +522,7 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n     remap_save_expr (tp, id->decl_map, walk_subtrees);\n   else if (TREE_CODE (*tp) == LABEL_DECL\n \t   && (! DECL_CONTEXT (*tp)\n-\t       || decl_function_context (*tp) == id->callee))\n+\t       || decl_function_context (*tp) == id->src_fn))\n     /* These may need to be remapped for EH handling.  */\n     *tp = remap_decl (*tp, id);\n   else if (TREE_CODE (*tp) == BIND_EXPR)\n@@ -627,8 +580,7 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t\t}\n \t    }\n \t}\n-      else if (TREE_CODE (*tp) == INDIRECT_REF\n-\t       && !id->versioning_p)\n+      else if (TREE_CODE (*tp) == INDIRECT_REF)\n \t{\n \t  /* Get rid of *& from inline substitutions that can happen when a\n \t     pointer argument is an ADDR_EXPR.  */\n@@ -662,7 +614,7 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \n       /* Here is the \"usual case\".  Copy this tree node, and then\n \t tweak some special cases.  */\n-      copy_tree_r (tp, walk_subtrees, id->versioning_p ? data : NULL);\n+      copy_tree_r (tp, walk_subtrees, NULL);\n        \n       /* If EXPR has block defined, map it to newly constructed block.\n          When inlining we want EXPRs without block appear in the block\n@@ -716,7 +668,7 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n    later  */\n \n static basic_block\n-copy_bb (inline_data *id, basic_block bb, int frequency_scale, int count_scale)\n+copy_bb (copy_body_data *id, basic_block bb, int frequency_scale, int count_scale)\n {\n   block_stmt_iterator bsi, copy_bsi;\n   basic_block copy_basic_block;\n@@ -749,45 +701,49 @@ copy_bb (inline_data *id, basic_block bb, int frequency_scale, int count_scale)\n \t     callgraph edges and update or duplicate them.  */\n \t  if (call && (decl = get_callee_fndecl (call)))\n \t    {\n-\t      if (!id->versioning_p)\n+\t      struct cgraph_node *node;\n+\t      struct cgraph_edge *edge;\n+\t     \n+\t      switch (id->transform_call_graph_edges)\n \t\t{\n-\t\t  struct cgraph_edge *edge;\n-\n-\t\t  /* We're cloning or inlining this body; duplicate the\n-\t\t     associate callgraph nodes.  */\n-\t\t  edge = cgraph_edge (id->current_node, orig_stmt);\n+\t\tcase CB_CGE_DUPLICATE:\n+\t\t  edge = cgraph_edge (id->src_node, orig_stmt);\n \t\t  if (edge)\n-\t\t    cgraph_clone_edge (edge, id->node, stmt,\n+\t\t    cgraph_clone_edge (edge, id->dst_node, stmt,\n \t\t\t\t       REG_BR_PROB_BASE, 1, true);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* Update the call_expr on the edges from the new version\n-\t\t     to its callees. */\n-\t\t  struct cgraph_edge *edge;\n-\t\t  edge = cgraph_edge (id->node, orig_stmt);\n-\t\t  if (edge)\n+\t\t  break;\n+\n+\t\tcase CB_CGE_MOVE_CLONES:\n+\t\t  for (node = id->dst_node->next_clone;\n+\t\t       node;\n+\t\t       node = node->next_clone)\n \t\t    {\n+\t\t      edge = cgraph_edge (node, orig_stmt);\n+\t\t      gcc_assert (edge);\n \t\t      edge->call_stmt = stmt;\n-\t\t      if (id->update_clones_p)\n-\t\t\t{\n-\t\t\t  struct cgraph_node *n;\n-\t\t\t  for (n = id->node->next_clone; n; n = n->next_clone)\n-\t\t            cgraph_edge (n, orig_stmt)->call_stmt = stmt;\n-\t\t\t}\n-\t\t     }\n+\t\t    }\n+\t\t  /* FALLTHRU */\n+\n+\t\tcase CB_CGE_MOVE:\n+\t\t  edge = cgraph_edge (id->dst_node, orig_stmt);\n+\t\t  if (edge)\n+\t\t    edge->call_stmt = stmt;\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n \t\t}\n \t    }\n \t  /* If you think we can abort here, you are wrong.\n \t     There is no region 0 in tree land.  */\n-\t  gcc_assert (lookup_stmt_eh_region_fn (id->callee_cfun, orig_stmt)\n+\t  gcc_assert (lookup_stmt_eh_region_fn (id->src_cfun, orig_stmt)\n \t\t      != 0);\n \n \t  if (tree_could_throw_p (stmt))\n \t    {\n-\t      int region = lookup_stmt_eh_region_fn (id->callee_cfun, orig_stmt);\n+\t      int region = lookup_stmt_eh_region_fn (id->src_cfun, orig_stmt);\n \t      /* Add an entry for the copied tree in the EH hashtable.\n-\t\t When saving or cloning or versioning, use the hashtable in\n+\t\t When cloning or versioning, use the hashtable in\n \t\t cfun, and just copy the EH number.  When inlining, use the\n \t\t hashtable in the caller, and adjust the region number.  */\n \t      if (region > 0)\n@@ -797,7 +753,7 @@ copy_bb (inline_data *id, basic_block bb, int frequency_scale, int count_scale)\n \t\t and there is a \"current region,\"\n \t\t then associate this tree with the current region\n \t\t and add edges associated with this region.  */\n-\t      if ((lookup_stmt_eh_region_fn (id->callee_cfun,\n+\t      if ((lookup_stmt_eh_region_fn (id->src_cfun,\n \t\t\t\t\t     orig_stmt) <= 0\n \t\t   && id->eh_region > 0)\n \t\t  && tree_could_throw_p (stmt))\n@@ -882,19 +838,19 @@ copy_edges_for_bb (basic_block bb, int count_scale)\n static tree\n remap_decl_1 (tree decl, void *data)\n {\n-  return remap_decl (decl, (inline_data *) data);\n+  return remap_decl (decl, (copy_body_data *) data);\n }\n \n /* Make a copy of the body of FN so that it can be inserted inline in\n    another function.  Walks FN via CFG, returns new fndecl.  */\n \n static tree\n-copy_cfg_body (inline_data * id, gcov_type count, int frequency,\n+copy_cfg_body (copy_body_data * id, gcov_type count, int frequency,\n \t       basic_block entry_block_map, basic_block exit_block_map)\n {\n-  tree callee_fndecl = id->callee;\n+  tree callee_fndecl = id->src_fn;\n   /* Original cfun for the callee, doesn't change.  */\n-  struct function *callee_cfun = DECL_STRUCT_FUNCTION (callee_fndecl);\n+  struct function *src_cfun = DECL_STRUCT_FUNCTION (callee_fndecl);\n   /* Copy, built by this function.  */\n   struct function *new_cfun;\n   /* Place to copy from; when a copy of the function was saved off earlier,\n@@ -903,19 +859,18 @@ copy_cfg_body (inline_data * id, gcov_type count, int frequency,\n     (struct function *) ggc_alloc_cleared (sizeof (struct function));\n   basic_block bb;\n   tree new_fndecl = NULL;\n-  bool versioning_or_cloning;\n   int count_scale, frequency_scale;\n \n-  if (ENTRY_BLOCK_PTR_FOR_FUNCTION (callee_cfun)->count)\n+  if (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count)\n     count_scale = (REG_BR_PROB_BASE * count\n-\t\t   / ENTRY_BLOCK_PTR_FOR_FUNCTION (callee_cfun)->count);\n+\t\t   / ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count);\n   else\n     count_scale = 1;\n \n-  if (ENTRY_BLOCK_PTR_FOR_FUNCTION (callee_cfun)->frequency)\n+  if (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->frequency)\n     frequency_scale = (REG_BR_PROB_BASE * frequency\n \t\t       /\n-\t\t       ENTRY_BLOCK_PTR_FOR_FUNCTION (callee_cfun)->frequency);\n+\t\t       ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->frequency);\n   else\n     frequency_scale = count_scale;\n \n@@ -928,14 +883,11 @@ copy_cfg_body (inline_data * id, gcov_type count, int frequency,\n \n   *cfun_to_copy = *DECL_STRUCT_FUNCTION (callee_fndecl);\n \n-  id->callee_cfun = cfun_to_copy;\n+  id->src_cfun = cfun_to_copy;\n \n-  /* If saving or cloning a function body, create new basic_block_info\n-     and label_to_block_maps.  Otherwise, we're duplicating a function\n-     body for inlining; insert our new blocks and labels into the\n-     existing varrays.  */\n-  versioning_or_cloning = (id->cloning_p || id->versioning_p);\n-  if (versioning_or_cloning)\n+  /* If requested, create new basic_block_info and label_to_block_maps.\n+     Otherwise, insert our new blocks and labels into the existing cfg.  */\n+  if (id->transform_new_cfg)\n     {\n       new_cfun =\n \t(struct function *) ggc_alloc_cleared (sizeof (struct function));\n@@ -948,16 +900,16 @@ copy_cfg_body (inline_data * id, gcov_type count, int frequency,\n       init_empty_tree_cfg ();\n \n       ENTRY_BLOCK_PTR->count =\n-\t(ENTRY_BLOCK_PTR_FOR_FUNCTION (callee_cfun)->count * count_scale /\n+\t(ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count * count_scale /\n \t REG_BR_PROB_BASE);\n       ENTRY_BLOCK_PTR->frequency =\n-\t(ENTRY_BLOCK_PTR_FOR_FUNCTION (callee_cfun)->frequency *\n+\t(ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->frequency *\n \t frequency_scale / REG_BR_PROB_BASE);\n       EXIT_BLOCK_PTR->count =\n-\t(EXIT_BLOCK_PTR_FOR_FUNCTION (callee_cfun)->count * count_scale /\n+\t(EXIT_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count * count_scale /\n \t REG_BR_PROB_BASE);\n       EXIT_BLOCK_PTR->frequency =\n-\t(EXIT_BLOCK_PTR_FOR_FUNCTION (callee_cfun)->frequency *\n+\t(EXIT_BLOCK_PTR_FOR_FUNCTION (src_cfun)->frequency *\n \t frequency_scale / REG_BR_PROB_BASE);\n \n       entry_block_map = ENTRY_BLOCK_PTR;\n@@ -967,16 +919,13 @@ copy_cfg_body (inline_data * id, gcov_type count, int frequency,\n   ENTRY_BLOCK_PTR_FOR_FUNCTION (cfun_to_copy)->aux = entry_block_map;\n   EXIT_BLOCK_PTR_FOR_FUNCTION (cfun_to_copy)->aux = exit_block_map;\n \n-\n   /* Duplicate any exception-handling regions.  */\n   if (cfun->eh)\n     {\n-      if (versioning_or_cloning)\n+      if (id->transform_new_cfg)\n         init_eh_for_function ();\n-      id->eh_region_offset = duplicate_eh_regions (cfun_to_copy,\n-\t\t     \t\t\t\t   remap_decl_1,\n-\t\t\t\t\t\t   id, id->eh_region);\n-      gcc_assert (inlining_p (id) || !id->eh_region_offset);\n+      id->eh_region_offset\n+\t= duplicate_eh_regions (cfun_to_copy, remap_decl_1, id, id->eh_region);\n     }\n   /* Use aux pointers to map the original blocks to copy.  */\n   FOR_EACH_BB_FN (bb, cfun_to_copy)\n@@ -987,7 +936,7 @@ copy_cfg_body (inline_data * id, gcov_type count, int frequency,\n   FOR_ALL_BB_FN (bb, cfun_to_copy)\n     bb->aux = NULL;\n \n-  if (versioning_or_cloning)\n+  if (id->transform_new_cfg)\n     pop_cfun ();\n \n   return new_fndecl;\n@@ -997,10 +946,10 @@ copy_cfg_body (inline_data * id, gcov_type count, int frequency,\n    another function.  */\n \n static tree\n-copy_generic_body (inline_data *id)\n+copy_generic_body (copy_body_data *id)\n {\n   tree body;\n-  tree fndecl = id->callee;\n+  tree fndecl = id->src_fn;\n \n   body = DECL_SAVED_TREE (fndecl);\n   walk_tree (&body, copy_body_r, id, NULL);\n@@ -1009,10 +958,10 @@ copy_generic_body (inline_data *id)\n }\n \n static tree\n-copy_body (inline_data *id, gcov_type count, int frequency,\n+copy_body (copy_body_data *id, gcov_type count, int frequency,\n \t   basic_block entry_block_map, basic_block exit_block_map)\n {\n-  tree fndecl = id->callee;\n+  tree fndecl = id->src_fn;\n   tree body;\n \n   /* If this body has a CFG, walk CFG and copy.  */\n@@ -1039,7 +988,7 @@ self_inlining_addr_expr (tree value, tree fn)\n }\n \n static void\n-setup_one_parameter (inline_data *id, tree p, tree value, tree fn,\n+setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n \t\t     basic_block bb, tree *vars)\n {\n   tree init_stmt;\n@@ -1074,7 +1023,7 @@ setup_one_parameter (inline_data *id, tree p, tree value, tree fn,\n   /* Make an equivalent VAR_DECL.  Note that we must NOT remap the type\n      here since the type of this decl must be visible to the calling\n      function.  */\n-  var = copy_decl_for_dup (p, fn, id->caller, /*versioning=*/false);\n+  var = copy_decl_to_var (p, id);\n \n   /* See if the frontend wants to pass this by invisible reference.  If\n      so, our new VAR_DECL will have REFERENCE_TYPE, and we need to\n@@ -1148,7 +1097,7 @@ setup_one_parameter (inline_data *id, tree p, tree value, tree fn,\n    top of the stack in ID from the ARGS (presented as a TREE_LIST).  */\n \n static void\n-initialize_inlined_parameters (inline_data *id, tree args, tree static_chain,\n+initialize_inlined_parameters (copy_body_data *id, tree args, tree static_chain,\n \t\t\t       tree fn, basic_block bb)\n {\n   tree parms;\n@@ -1204,11 +1153,11 @@ initialize_inlined_parameters (inline_data *id, tree args, tree static_chain,\n    holds the result as seen by the caller.  */\n \n static tree\n-declare_return_variable (inline_data *id, tree return_slot_addr,\n+declare_return_variable (copy_body_data *id, tree return_slot_addr,\n \t\t\t tree modify_dest, tree *use_p)\n {\n-  tree callee = id->callee;\n-  tree caller = id->caller;\n+  tree callee = id->src_fn;\n+  tree caller = id->dst_fn;\n   tree result = DECL_RESULT (callee);\n   tree callee_type = TREE_TYPE (result);\n   tree caller_type = TREE_TYPE (TREE_TYPE (callee));\n@@ -1288,7 +1237,7 @@ declare_return_variable (inline_data *id, tree return_slot_addr,\n \n   gcc_assert (TREE_CODE (TYPE_SIZE_UNIT (callee_type)) == INTEGER_CST);\n \n-  var = copy_decl_for_dup (result, callee, caller, /*versioning=*/false);\n+  var = copy_decl_to_var (result, id);\n \n   DECL_SEEN_IN_BIND_EXPR_P (var) = 1;\n   DECL_STRUCT_FUNCTION (caller)->unexpanded_var_list\n@@ -1913,7 +1862,7 @@ add_lexical_block (tree current_block, tree new_block)\n static bool\n expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n {\n-  inline_data *id;\n+  copy_body_data *id;\n   tree t;\n   tree use_retvar;\n   tree fn;\n@@ -1930,11 +1879,10 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n   bool successfully_inlined = FALSE;\n   tree t_step;\n   tree var;\n-  struct cgraph_node *old_node;\n   tree decl;\n \n   /* See what we've got.  */\n-  id = (inline_data *) data;\n+  id = (copy_body_data *) data;\n   t = *tp;\n \n   /* Set input_location here so we get the right instantiation context\n@@ -1970,10 +1918,10 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n \n   /* Objective C and fortran still calls tree_rest_of_compilation directly.\n      Kill this check once this is fixed.  */\n-  if (!id->current_node->analyzed)\n+  if (!id->dst_node->analyzed)\n     goto egress;\n \n-  cg_edge = cgraph_edge (id->current_node, stmt);\n+  cg_edge = cgraph_edge (id->dst_node, stmt);\n \n   /* Constant propagation on argument done during previous inlining\n      may create new direct call.  Produce an edge for it.  */\n@@ -1986,7 +1934,7 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n          constant propagating arguments.  In all other cases we hit a bug\n          (incorrect node sharing is most common reason for missing edges.  */\n       gcc_assert (dest->needed || !flag_unit_at_a_time);\n-      cgraph_create_edge (id->node, dest, stmt,\n+      cgraph_create_edge (id->dst_node, dest, stmt,\n \t\t\t  bb->count, bb->loop_depth)->inline_failed\n \t= N_(\"originally indirect function call not considered for inlining\");\n       goto egress;\n@@ -2019,7 +1967,7 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n   fn = cg_edge->callee->decl;\n \n #ifdef ENABLE_CHECKING\n-  if (cg_edge->callee->decl != id->node->decl)\n+  if (cg_edge->callee->decl != id->dst_node->decl)\n     verify_cgraph_node (cg_edge->callee);\n #endif\n \n@@ -2068,10 +2016,11 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n   /* Initialize the parameters.  */\n   args = TREE_OPERAND (t, 1);\n \n-  initialize_inlined_parameters (id, args, TREE_OPERAND (t, 2), fn, bb);\n-\n   /* Record the function we are about to inline.  */\n-  id->callee = fn;\n+  id->src_fn = fn;\n+  id->src_node = cg_edge->callee;\n+\n+  initialize_inlined_parameters (id, args, TREE_OPERAND (t, 2), fn, bb);\n \n   if (DECL_INITIAL (fn))\n     add_lexical_block (id->block, remap_blocks (DECL_INITIAL (fn), id));\n@@ -2112,25 +2061,15 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n   if (decl && !return_slot_addr && decl != modify_dest)\n     declare_inline_vars (id->block, decl);\n \n-  /* After we've initialized the parameters, we insert the body of the\n-     function itself.  */\n-  old_node = id->current_node;\n-\n-  /* Anoint the callee-to-be-duplicated as the \"current_node.\"  When\n-     CALL_EXPRs within callee are duplicated, the edges from callee to\n-     callee's callees (caller's grandchildren) will be cloned.  */\n-  id->current_node = cg_edge->callee;\n-\n   /* This is it.  Duplicate the callee body.  Assume callee is\n      pre-gimplified.  Note that we must not alter the caller\n      function in any way before this point, as this CALL_EXPR may be\n      a self-referential call; if we're calling ourselves, we need to\n      duplicate our body before altering anything.  */\n   copy_body (id, bb->count, bb->frequency, bb, return_block);\n-  id->current_node = old_node;\n \n   /* Add local vars in this inlined callee to caller.  */\n-  t_step = id->callee_cfun->unexpanded_var_list;\n+  t_step = id->src_cfun->unexpanded_var_list;\n   for (; t_step; t_step = TREE_CHAIN (t_step))\n     {\n       var = TREE_VALUE (t_step);\n@@ -2193,7 +2132,7 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n    to the CALL_EXPR, not the tree itself.  */\n \n static bool\n-gimple_expand_calls_inline (basic_block bb, inline_data *id)\n+gimple_expand_calls_inline (basic_block bb, copy_body_data *id)\n {\n   block_stmt_iterator bsi;\n \n@@ -2220,7 +2159,7 @@ gimple_expand_calls_inline (basic_block bb, inline_data *id)\n void\n optimize_inline_calls (tree fn)\n {\n-  inline_data id;\n+  copy_body_data id;\n   tree prev_fn;\n   basic_block bb;\n   /* There is no point in performing inlining if errors have already\n@@ -2232,15 +2171,22 @@ optimize_inline_calls (tree fn)\n   /* Clear out ID.  */\n   memset (&id, 0, sizeof (id));\n \n-  id.current_node = id.node = cgraph_node (fn);\n-  id.caller = fn;\n+  id.src_node = id.dst_node = cgraph_node (fn);\n+  id.dst_fn = fn;\n   /* Or any functions that aren't finished yet.  */\n   prev_fn = NULL_TREE;\n   if (current_function_decl)\n     {\n-      id.caller = current_function_decl;\n+      id.dst_fn = current_function_decl;\n       prev_fn = current_function_decl;\n     }\n+\n+  id.copy_decl = copy_decl_maybe_to_var;\n+  id.transform_call_graph_edges = CB_CGE_DUPLICATE;\n+  id.transform_new_cfg = false;\n+  id.transform_return_to_modify = true;\n+  id.transform_lang_insert_block = false;\n+\n   push_gimplify_context ();\n \n   /* Reach the trees by walking over the CFG, and note the\n@@ -2252,7 +2198,6 @@ optimize_inline_calls (tree fn)\n   FOR_EACH_BB (bb)\n     gimple_expand_calls_inline (bb, &id);\n \n-\n   pop_gimplify_context (NULL);\n   /* Renumber the (code) basic_blocks consecutively.  */\n   compact_blocks ();\n@@ -2263,10 +2208,10 @@ optimize_inline_calls (tree fn)\n     {\n       struct cgraph_edge *e;\n \n-      verify_cgraph_node (id.node);\n+      verify_cgraph_node (id.dst_node);\n \n       /* Double check that we inlined everything we are supposed to inline.  */\n-      for (e = id.node->callees; e; e = e->next_callee)\n+      for (e = id.dst_node->callees; e; e = e->next_callee)\n \tgcc_assert (e->inline_failed);\n     }\n #endif\n@@ -2284,19 +2229,21 @@ optimize_inline_calls (tree fn)\n void\n clone_body (tree clone, tree fn, void *arg_map)\n {\n-  inline_data id;\n+  copy_body_data id;\n \n   /* Clone the body, as if we were making an inline call.  But, remap the\n      parameters in the callee to the parameters of caller.  */\n   memset (&id, 0, sizeof (id));\n-  id.caller = clone;\n-  id.callee = fn;\n-  id.callee_cfun = DECL_STRUCT_FUNCTION (fn);\n+  id.src_fn = fn;\n+  id.dst_fn = clone;\n+  id.src_cfun = DECL_STRUCT_FUNCTION (fn);\n   id.decl_map = (splay_tree)arg_map;\n \n-  /* Cloning is treated slightly differently from inlining.  Set\n-     CLONING_P so that it's clear which operation we're performing.  */\n-  id.cloning_p = true;\n+  id.copy_decl = copy_decl_no_change;\n+  id.transform_call_graph_edges = CB_CGE_DUPLICATE;\n+  id.transform_new_cfg = true;\n+  id.transform_return_to_modify = false;\n+  id.transform_lang_insert_block = true;\n \n   /* We're not inside any EH region.  */\n   id.eh_region = -1;\n@@ -2311,7 +2258,6 @@ tree\n copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n {\n   enum tree_code code = TREE_CODE (*tp);\n-  inline_data *id = (inline_data *) data;\n \n   /* We make copies of most nodes.  */\n   if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code))\n@@ -2324,11 +2270,6 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n       tree chain = TREE_CHAIN (*tp);\n       tree new;\n \n-      if (id && id->versioning_p && replace_ref_tree (id, tp))\n-\t{\n-\t  *walk_subtrees = 0;\n-\t  return NULL_TREE;\n-\t}\n       /* Copy the node.  */\n       new = copy_node (*tp);\n \n@@ -2413,13 +2354,13 @@ remap_save_expr (tree *tp, void *st_, int *walk_subtrees)\n \n /* Called via walk_tree.  If *TP points to a DECL_STMT for a local label,\n    copies the declaration and enters it in the splay_tree in DATA (which is\n-   really an `inline_data *').  */\n+   really an `copy_body_data *').  */\n \n static tree\n mark_local_for_remap_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t\t\tvoid *data)\n {\n-  inline_data *id = (inline_data *) data;\n+  copy_body_data *id = (copy_body_data *) data;\n \n   /* Don't walk into types.  */\n   if (TYPE_P (*tp))\n@@ -2430,9 +2371,7 @@ mark_local_for_remap_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n       tree decl = TREE_OPERAND (*tp, 0);\n \n       /* Copy the decl and remember the copy.  */\n-      insert_decl_map (id, decl,\n-\t\t       copy_decl_for_dup (decl, DECL_CONTEXT (decl),\n-\t\t\t\t\t  DECL_CONTEXT (decl),  /*versioning=*/false));\n+      insert_decl_map (id, decl, id->copy_decl (decl, id));\n     }\n \n   return NULL_TREE;\n@@ -2470,7 +2409,7 @@ unsave_expr_1 (tree expr)\n static tree\n unsave_r (tree *tp, int *walk_subtrees, void *data)\n {\n-  inline_data *id = (inline_data *) data;\n+  copy_body_data *id = (copy_body_data *) data;\n   splay_tree st = id->decl_map;\n   splay_tree_node n;\n \n@@ -2510,18 +2449,24 @@ unsave_r (tree *tp, int *walk_subtrees, void *data)\n tree\n unsave_expr_now (tree expr)\n {\n-  inline_data id;\n+  copy_body_data id;\n \n   /* There's nothing to do for NULL_TREE.  */\n   if (expr == 0)\n     return expr;\n \n   /* Set up ID.  */\n   memset (&id, 0, sizeof (id));\n-  id.callee = current_function_decl;\n-  id.caller = current_function_decl;\n+  id.src_fn = current_function_decl;\n+  id.dst_fn = current_function_decl;\n   id.decl_map = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);\n \n+  id.copy_decl = copy_decl_no_change;\n+  id.transform_call_graph_edges = CB_CGE_DUPLICATE;\n+  id.transform_new_cfg = false;\n+  id.transform_return_to_modify = false;\n+  id.transform_lang_insert_block = false;\n+\n   /* Walk the tree once to find local labels.  */\n   walk_tree_without_duplicates (&expr, mark_local_for_remap_r, &id);\n \n@@ -2568,47 +2513,12 @@ declare_inline_vars (tree block, tree vars)\n \n \n /* Copy NODE (which must be a DECL).  The DECL originally was in the FROM_FN,\n-   but now it will be in the TO_FN.  VERSIONING means that this function \n-   is used by the versioning utility (not inlining or cloning).  */\n+   but now it will be in the TO_FN.  PARM_TO_VAR means enable PARM_DECL to\n+   VAR_DECL translation.  */\n \n-tree\n-copy_decl_for_dup (tree decl, tree from_fn, tree to_fn, bool versioning)\n+static tree\n+copy_decl_for_dup_finish (copy_body_data *id, tree decl, tree copy)\n {\n-  tree copy;\n-\n-  gcc_assert (DECL_P (decl));\n-  /* Copy the declaration.  */\n-  if (!versioning\n-      && (TREE_CODE (decl) == PARM_DECL\n-\t  || TREE_CODE (decl) == RESULT_DECL))\n-    {\n-      tree type = TREE_TYPE (decl);\n-\n-      /* For a parameter or result, we must make an equivalent VAR_DECL,\n-\t not a new PARM_DECL.  */\n-      copy = build_decl (VAR_DECL, DECL_NAME (decl), type);\n-      TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (decl);\n-      TREE_READONLY (copy) = TREE_READONLY (decl);\n-      TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (decl);\n-      DECL_COMPLEX_GIMPLE_REG_P (copy) = DECL_COMPLEX_GIMPLE_REG_P (decl);\n-    }\n-  else\n-    {\n-      copy = copy_node (decl);\n-      /* The COPY is not abstract; it will be generated in TO_FN.  */\n-      DECL_ABSTRACT (copy) = 0;\n-      lang_hooks.dup_lang_specific_decl (copy);\n-\n-      /* TREE_ADDRESSABLE isn't used to indicate that a label's\n-\t address has been taken; it's for internal bookkeeping in\n-\t expand_goto_internal.  */\n-      if (TREE_CODE (copy) == LABEL_DECL)\n-\t{\n-\t  TREE_ADDRESSABLE (copy) = 0;\n-\t  LABEL_DECL_UID (copy) = -1;\n-\t}\n-    }\n-\n   /* Don't generate debug information for the copy if we wouldn't have\n      generated it for the copy either.  */\n   DECL_ARTIFICIAL (copy) = DECL_ARTIFICIAL (decl);\n@@ -2630,7 +2540,7 @@ copy_decl_for_dup (tree decl, tree from_fn, tree to_fn, bool versioning)\n   if (!DECL_CONTEXT (decl))\n     /* Globals stay global.  */\n     ;\n-  else if (DECL_CONTEXT (decl) != from_fn)\n+  else if (DECL_CONTEXT (decl) != id->src_fn)\n     /* Things that weren't in the scope of the function we're inlining\n        from aren't in the scope we're inlining to, either.  */\n     ;\n@@ -2641,14 +2551,64 @@ copy_decl_for_dup (tree decl, tree from_fn, tree to_fn, bool versioning)\n   else\n     /* Ordinary automatic local variables are now in the scope of the\n        new function.  */\n-    DECL_CONTEXT (copy) = to_fn;\n+    DECL_CONTEXT (copy) = id->dst_fn;\n \n   return copy;\n }\n \n+static tree\n+copy_decl_to_var (tree decl, copy_body_data *id)\n+{\n+  tree copy, type;\n+\n+  gcc_assert (TREE_CODE (decl) == PARM_DECL\n+\t      || TREE_CODE (decl) == RESULT_DECL);\n+\n+  type = TREE_TYPE (decl);\n+\n+  copy = build_decl (VAR_DECL, DECL_NAME (decl), type);\n+  TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (decl);\n+  TREE_READONLY (copy) = TREE_READONLY (decl);\n+  TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (decl);\n+  DECL_COMPLEX_GIMPLE_REG_P (copy) = DECL_COMPLEX_GIMPLE_REG_P (decl);\n+\n+  return copy_decl_for_dup_finish (id, decl, copy);\n+}\n+\n+static tree\n+copy_decl_no_change (tree decl, copy_body_data *id)\n+{\n+  tree copy;\n+\n+  copy = copy_node (decl);\n+\n+  /* The COPY is not abstract; it will be generated in DST_FN.  */\n+  DECL_ABSTRACT (copy) = 0;\n+  lang_hooks.dup_lang_specific_decl (copy);\n+\n+  /* TREE_ADDRESSABLE isn't used to indicate that a label's address has\n+     been taken; it's for internal bookkeeping in expand_goto_internal.  */\n+  if (TREE_CODE (copy) == LABEL_DECL)\n+    {\n+      TREE_ADDRESSABLE (copy) = 0;\n+      LABEL_DECL_UID (copy) = -1;\n+    }\n+\n+  return copy_decl_for_dup_finish (id, decl, copy);\n+}\n+\n+static tree\n+copy_decl_maybe_to_var (tree decl, copy_body_data *id)\n+{\n+  if (TREE_CODE (decl) == PARM_DECL || TREE_CODE (decl) == RESULT_DECL)\n+    return copy_decl_to_var (decl, id);\n+  else\n+    return copy_decl_no_change (decl, id);\n+}\n+\n /* Return a copy of the function's argument tree.  */\n static tree\n-copy_arguments_for_versioning (tree orig_parm, inline_data * id)\n+copy_arguments_for_versioning (tree orig_parm, copy_body_data * id)\n {\n   tree *arg_copy, *parg;\n \n@@ -2665,7 +2625,7 @@ copy_arguments_for_versioning (tree orig_parm, inline_data * id)\n \n /* Return a copy of the function's static chain.  */\n static tree\n-copy_static_chain (tree static_chain, inline_data * id)\n+copy_static_chain (tree static_chain, copy_body_data * id)\n {\n   tree *chain_copy, *pvar;\n \n@@ -2709,7 +2669,7 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n {\n   struct cgraph_node *old_version_node;\n   struct cgraph_node *new_version_node;\n-  inline_data id;\n+  copy_body_data id;\n   tree p, new_fndecl;\n   unsigned i;\n   struct ipa_replace_map *replace_info;\n@@ -2732,8 +2692,7 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n \n   /* Generate a new name for the new version. */\n   if (!update_clones)\n-    DECL_NAME (new_decl) =\n-      create_tmp_var_name (NULL);\n+    DECL_NAME (new_decl) = create_tmp_var_name (NULL);\n   /* Create a new SYMBOL_REF rtx for the new name. */\n   if (DECL_RTL (old_decl) != NULL)\n     {\n@@ -2746,19 +2705,20 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n   /* Prepare the data structures for the tree copy.  */\n   memset (&id, 0, sizeof (id));\n   \n-  /* The new version. */\n-  id.node = new_version_node;\n-  \n-  /* The old version. */\n-  id.current_node = cgraph_node (old_decl);\n-  \n-  id.versioning_p = true;\n-  id.update_clones_p = update_clones;\n   id.decl_map = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);\n-  id.caller = new_decl;\n-  id.callee = old_decl;\n-  id.callee_cfun = DECL_STRUCT_FUNCTION (old_decl);\n+  id.src_fn = old_decl;\n+  id.dst_fn = new_decl;\n+  id.src_node = old_version_node;\n+  id.dst_node = new_version_node;\n+  id.src_cfun = DECL_STRUCT_FUNCTION (old_decl);\n   \n+  id.copy_decl = copy_decl_no_change;\n+  id.transform_call_graph_edges\n+    = update_clones ? CB_CGE_MOVE_CLONES : CB_CGE_MOVE;\n+  id.transform_new_cfg = true;\n+  id.transform_return_to_modify = false;\n+  id.transform_lang_insert_block = false;\n+\n   current_function_decl = new_decl;\n   \n   /* Copy the function's static chain.  */\n@@ -2777,17 +2737,15 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n     for (i = 0; i < VARRAY_ACTIVE_SIZE (tree_map); i++)\n       {\n \treplace_info = VARRAY_GENERIC_PTR (tree_map, i);\n-\tif (replace_info->replace_p && !replace_info->ref_p)\n+\tif (replace_info->replace_p)\n \t  insert_decl_map (&id, replace_info->old_tree,\n \t\t\t   replace_info->new_tree);\n-\telse if (replace_info->replace_p && replace_info->ref_p)\n-\t  id.ipa_info = tree_map;\n       }\n   \n-  DECL_INITIAL (new_decl) = remap_blocks (DECL_INITIAL (id.callee), &id);\n+  DECL_INITIAL (new_decl) = remap_blocks (DECL_INITIAL (id.src_fn), &id);\n   \n   /* Renumber the lexical scoping (non-code) blocks consecutively.  */\n-  number_blocks (id.caller);\n+  number_blocks (id.dst_fn);\n   \n   if (DECL_STRUCT_FUNCTION (old_decl)->unexpanded_var_list != NULL_TREE)\n     /* Add local vars.  */\n@@ -2838,62 +2796,17 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n   return;\n }\n \n-/*  Replace an INDIRECT_REF tree of a given DECL tree with a new \n-    given tree.\n-    ID->ipa_info keeps the old tree and the new tree.  \n-    TP points to the INDIRECT REF tree.  Return true if \n-    the trees were replaced.  */\n-static bool\n-replace_ref_tree (inline_data * id, tree * tp)\n-{\n-  bool replaced = false;\n-  tree new;\n-\n-  if (id->ipa_info && VARRAY_ACTIVE_SIZE (id->ipa_info) > 0)\n-    {\n-      unsigned i;\n-\n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (id->ipa_info); i++)\n-\t{\n-\t  struct ipa_replace_map *replace_info;\n-\t  replace_info = VARRAY_GENERIC_PTR (id->ipa_info, i);\n-\n-\t  if (replace_info->replace_p && replace_info->ref_p)\n-\t    {\n-\t      tree old_tree = replace_info->old_tree;\n-\t      tree new_tree = replace_info->new_tree;\n-\n-\t      if (TREE_CODE (*tp) == INDIRECT_REF\n-\t\t  && TREE_OPERAND (*tp, 0) == old_tree)\n-\t\t{\n-\t\t  new = copy_node (new_tree);\n-\t\t  *tp = new;\n-\t\t  replaced = true;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-  return replaced;\n-}\n-\n-/* Return true if we are inlining.  */\n-static inline bool\n-inlining_p (inline_data * id)\n-{\n-  return (!id->cloning_p && !id->versioning_p);\n-}\n-\n /* Duplicate a type, fields and all.  */\n \n tree\n build_duplicate_type (tree type)\n {\n-  inline_data id;\n+  struct copy_body_data id;\n \n   memset (&id, 0, sizeof (id));\n-  id.callee = current_function_decl;\n-  id.caller = current_function_decl;\n-  id.callee_cfun = cfun;\n+  id.src_fn = current_function_decl;\n+  id.dst_fn = current_function_decl;\n+  id.src_cfun = cfun;\n   id.decl_map = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);\n \n   type = remap_type_1 (type, &id);"}, {"sha": "d731752a3cd3f20b1fca647af4986892f25cbada", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 72, "deletions": 3, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b369fae185e33b3145330cbf88130ae6890eff7/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b369fae185e33b3145330cbf88130ae6890eff7/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=1b369fae185e33b3145330cbf88130ae6890eff7", "patch": "@@ -23,8 +23,78 @@ Boston, MA 02110-1301, USA.  */\n #define GCC_TREE_INLINE_H\n \n #include \"varray.h\"\n+#include \"splay-tree.h\"\n+\n+\n+/* Data required for function body duplication.  */\n+\n+typedef struct copy_body_data\n+{\n+  /* FUNCTION_DECL for function being inlined, or in general the\n+     source function providing the original trees.  */\n+  tree src_fn;\n+  /* FUNCTION_DECL for function being inlined into, or in general\n+     the destination function receiving the new trees.  */\n+  tree dst_fn;\n+  /* Callgraph node of the source function.  */\n+  struct cgraph_node *src_node;\n+  /* Callgraph node of the destination function.  */\n+  struct cgraph_node *dst_node;\n+  /* struct function for function being inlined.  Usually this is the same\n+     as DECL_STRUCT_FUNCTION (src_fn), but can be different if saved_cfg\n+     and saved_eh are in use.  */\n+  struct function *src_cfun;\n+\n+  /* The VAR_DECL for the return value.  */\n+  tree retvar;\n+  /* The map from local declarations in the inlined function to\n+     equivalents in the function into which it is being inlined.  */\n+  splay_tree decl_map;\n+\n+  /* Create a new decl to replace DECL in the destination function.  */\n+  tree (*copy_decl) (tree, struct copy_body_data *);\n+\n+  /* Current BLOCK.  */\n+  tree block;\n+\n+  /* Exception region the inlined call lie in.  */\n+  int eh_region;\n+  /* Take region number in the function being copied, add this value and\n+     get eh region number of the duplicate in the function we inline into.  */\n+  int eh_region_offset;\n+\n+  /* We use the same mechanism do all sorts of different things.  Rather\n+     than enumerating the different cases, we categorize the behaviour\n+     in the various situations.  */\n+\n+  /* Indicate the desired behaviour wrt call graph edges.  We can either\n+     duplicate the edge (inlining, cloning), move the edge (versioning,\n+     parallelization), or move the edges of the clones (saving).  */\n+  enum copy_body_cge_which {\n+    CB_CGE_DUPLICATE,\n+    CB_CGE_MOVE,\n+    CB_CGE_MOVE_CLONES\n+  } transform_call_graph_edges;\n+\n+  /* True if a new CFG should be created.  False for inlining, true for\n+     everything else.  */\n+  bool transform_new_cfg;\n+\n+  /* True if RETURN_EXPRs should be transformed to just the contained\n+     MODIFY_EXPR.  The branch semantics of the return will be handled\n+     by manipulating the CFG rather than a statement.  */\n+  bool transform_return_to_modify;\n+\n+  /* True if lang_hooks.decls.insert_block should be invoked when\n+     duplicating BLOCK nodes.  */\n+  bool transform_lang_insert_block;\n+} copy_body_data;\n+\n /* Function prototypes.  */\n \n+extern tree copy_body_r (tree *, int *, void *);\n+extern void insert_decl_map (copy_body_data *, tree, tree);\n+\n void optimize_inline_calls (tree);\n bool tree_inlinable_function_p (tree);\n tree copy_tree_r (tree *, int *, void *);\n@@ -37,9 +107,8 @@ int estimate_num_insns (tree expr);\n bool tree_versionable_function_p (tree);\n void tree_function_versioning (tree, tree, varray_type, bool);\n \n-/* Copy a declaration when one function is substituted inline into\n-   another.  It is used also for versioning.  */\n-extern tree copy_decl_for_dup (tree, tree, tree, bool);\n+extern tree remap_decl (tree decl, copy_body_data *id);\n+extern tree remap_type (tree type, copy_body_data *id);\n \n /* 0 if we should not perform inlining.\n    1 if we should expand functions calls inline at the tree level."}]}