{"sha": "7aba0f0be51554e0fbd8d93f22c0a90c59498c3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2FiYTBmMGJlNTE1NTRlMGZiZDhkOTNmMjJjMGE5MGM1OTQ5OGMzYg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-01-04T00:00:20Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-01-04T00:00:20Z"}, "message": "(block_alloc): Generalize tying so we can tie any operand with the output unless some operand must be in the same register as the output...\n\n(block_alloc): Generalize tying so we can tie any operand with the\noutput unless some operand must be in the same register as the output,\nin which case only try tying that operand.\n\nFrom-SVN: r3075", "tree": {"sha": "e7912d819891a73c74c38bc664f9e122f6df7e2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7912d819891a73c74c38bc664f9e122f6df7e2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7aba0f0be51554e0fbd8d93f22c0a90c59498c3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7aba0f0be51554e0fbd8d93f22c0a90c59498c3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7aba0f0be51554e0fbd8d93f22c0a90c59498c3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7aba0f0be51554e0fbd8d93f22c0a90c59498c3b/comments", "author": null, "committer": null, "parents": [{"sha": "2151a093e30b2d7b1122924810d0427b8a438ca9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2151a093e30b2d7b1122924810d0427b8a438ca9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2151a093e30b2d7b1122924810d0427b8a438ca9"}], "stats": {"total": 96, "additions": 56, "deletions": 40}, "files": [{"sha": "3b892c667c66e957eaef682d271fcf29cf6024c6", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 56, "deletions": 40, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aba0f0be51554e0fbd8d93f22c0a90c59498c3b/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aba0f0be51554e0fbd8d93f22c0a90c59498c3b/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=7aba0f0be51554e0fbd8d93f22c0a90c59498c3b", "patch": "@@ -1142,7 +1142,15 @@ block_alloc (b)\n \t     Suitable insns are those with at least two operands and where\n \t     operand 0 is an output that is a register that is not\n \t     earlyclobber.\n-\t     For a commutative operation, try (set reg0 (arithop ... reg1)).\n+\n+\t     We can tie operand 0 with some operand that dies in this insn.\n+\t     First look for operands that are required to be in the same\n+\t     register as operand 0.  If we find such, only try tying that\n+\t     operand or one that can be put into that operand if the\n+\t     operation is commutative.  If we don't find an operand\n+\t     that is required to be in the same register as operand 0,\n+\t     we can tie with any operand.\n+\n \t     Subregs in place of regs are also ok.\n \n \t     If tying is done, WIN is set nonzero.  */\n@@ -1158,56 +1166,64 @@ block_alloc (b)\n #endif\n \t      )\n \t    {\n-\t      r0 = recog_operand[0];\n-\t      r1 = recog_operand[1];\n-\n-\t      /* If the first operand is an address, find a register in it.\n-\t\t There may be more than one register, but we only try one of\n-\t\t them.  */\n-\t      if (\n #ifdef REGISTER_CONSTRAINTS\n-\t\t  insn_operand_constraint[insn_code_number][1][0] == 'p'\n-#else\n-\t\t  insn_operand_address_p[insn_code_number][1]\n+\t      int must_match_0 = -1;\n+\n+\n+\t      for (i = 1; i < insn_n_operands[insn_code_number]; i++)\n+\t\tif (requires_inout_p\n+\t\t    (insn_operand_constraint[insn_code_number][i]))\n+\t\t  must_match_0 = i;\n #endif\n-\t\t  )\n-\t\twhile (GET_CODE (r1) == PLUS || GET_CODE (r1) == MULT)\n-\t\t  r1 = XEXP (r1, 0);\n \n-\t      if (GET_CODE (r0) == REG || GET_CODE (r0) == SUBREG)\n+\t      r0 = recog_operand[0];\n+\t      for (i = 1; i < insn_n_operands[insn_code_number]; i++)\n \t\t{\n-\t\t  /* We have two priorities for hard register preferences.\n-\t\t     If we have a move insn or an insn whose first input can\n-\t\t     only be in the same register as the output, give\n-\t\t     priority to an equivalence found from that insn.  */\n #ifdef REGISTER_CONSTRAINTS\n-\t\t  int may_save_copy\n-\t\t    = ((SET_DEST (body) == r0 && SET_SRC (body) == r1)\n-\t\t       || (r1 == recog_operand[1]\n-\t\t\t   && (requires_inout_p (insn_operand_constraint[insn_code_number][1]))));\n-#else\n-\t\t  int may_save_copy = 0;\n+\t\t  /* Skip this operand if we found an operand that\n+\t\t     must match operand 0 and this operand isn't it\n+\t\t     and can't be made to be it by commutativity.  */\n+\n+\t\t  if (must_match_0 >= 0 && i != must_match_0\n+\t\t      && ! (i == must_match_0 + 1\n+\t\t\t    && insn_operand_constraint[insn_code_number][i-1][0] == '%')\n+\t\t      && ! (i == must_match_0 - 1\n+\t\t\t    && insn_operand_constraint[insn_code_number][i][0] == '%'))\n+\t\t    continue;\n #endif\n \n-\t\t  if (GET_CODE (r1) == REG || GET_CODE (r1) == SUBREG)\n-\t\t    win = combine_regs (r1, r0, may_save_copy,\n-\t\t\t\t\tinsn_number, insn, 0);\n+\t\t  r1 = recog_operand[i];\n \n-\t\t  if (win == 0\n-\t\t      && insn_n_operands[insn_code_number] > 2\n+\t\t  /* If the operand is an address, find a register in it.\n+\t\t     There may be more than one register, but we only try one\n+\t\t     of them.  */\n+\t\t  if (\n #ifdef REGISTER_CONSTRAINTS\n-\t\t      && insn_operand_constraint[insn_code_number][1][0] == '%'\n+\t\t      insn_operand_constraint[insn_code_number][i][0] == 'p'\n #else\n-\t\t      && GET_CODE (PATTERN (insn)) == SET\n-\t\t      && (GET_RTX_CLASS (GET_CODE (SET_SRC (PATTERN (insn))))\n-\t\t\t  == 'c')\n-\t\t      && rtx_equal_p (recog_operand[2],\n-\t\t\t\t      XEXP (SET_SRC (PATTERN (insn)), 0))\n+\t\t      insn_operand_address_p[insn_code_number][i]\n #endif\n-\t\t      && (r1 = recog_operand[2],\n-\t\t\t  GET_CODE (r1) == REG || GET_CODE (r1) == SUBREG))\n-\t\t    win = combine_regs (r1, r0, may_save_copy,\n-\t\t\t\t\tinsn_number, insn, 0);\n+\t\t      )\n+\t\t    while (GET_CODE (r1) == PLUS || GET_CODE (r1) == MULT)\n+\t\t      r1 = XEXP (r1, 0);\n+\n+\t\t  if (GET_CODE (r0) == REG || GET_CODE (r0) == SUBREG)\n+\t\t    {\n+\t\t      /* We have two priorities for hard register preferences.\n+\t\t\t If we have a move insn or an insn whose first input\n+\t\t\t can only be in the same register as the output, give\n+\t\t\t priority to an equivalence found from that insn.  */\n+\t\t      int may_save_copy\n+\t\t\t= ((SET_DEST (body) == r0 && SET_SRC (body) == r1)\n+#ifdef REGISTER_CONSTRAINTS\n+\t\t\t   || (r1 == recog_operand[i] && must_match_0 >= 0)\n+#endif\n+\t\t\t   );\n+\t\t      \n+\t\t      if (GET_CODE (r1) == REG || GET_CODE (r1) == SUBREG)\n+\t\t\twin = combine_regs (r1, r0, may_save_copy,\n+\t\t\t\t\t    insn_number, insn, 0);\n+\t\t    }\n \t\t}\n \t    }\n "}]}