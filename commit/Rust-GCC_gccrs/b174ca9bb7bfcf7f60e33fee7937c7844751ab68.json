{"sha": "b174ca9bb7bfcf7f60e33fee7937c7844751ab68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE3NGNhOWJiN2JmY2Y3ZjYwZTMzZmVlNzkzN2M3ODQ0NzUxYWI2OA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-04-30T12:11:18Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-04-30T12:11:18Z"}, "message": "Remove unintended part of r270680 commit.\n\nFrom-SVN: r270691", "tree": {"sha": "f5cf1542c14c0abaa7b26e972fbd93e14f02b7a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5cf1542c14c0abaa7b26e972fbd93e14f02b7a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b174ca9bb7bfcf7f60e33fee7937c7844751ab68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b174ca9bb7bfcf7f60e33fee7937c7844751ab68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b174ca9bb7bfcf7f60e33fee7937c7844751ab68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b174ca9bb7bfcf7f60e33fee7937c7844751ab68/comments", "author": null, "committer": null, "parents": [{"sha": "d7b0896b2392b803679ac5ca88087b5c3ecede7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7b0896b2392b803679ac5ca88087b5c3ecede7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7b0896b2392b803679ac5ca88087b5c3ecede7e"}], "stats": {"total": 53, "additions": 7, "deletions": 46}, "files": [{"sha": "4a8cf6f847fd21296df3fb548db4a55ee8871fef", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 7, "deletions": 46, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b174ca9bb7bfcf7f60e33fee7937c7844751ab68/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b174ca9bb7bfcf7f60e33fee7937c7844751ab68/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=b174ca9bb7bfcf7f60e33fee7937c7844751ab68", "patch": "@@ -1615,31 +1615,13 @@ encode_tree_to_bitpos (tree expr, unsigned char *ptr, int bitlen, int bitpos,\n \t\t       unsigned int total_bytes)\n {\n   unsigned int first_byte = bitpos / BITS_PER_UNIT;\n+  tree tmp_int = expr;\n   bool sub_byte_op_p = ((bitlen % BITS_PER_UNIT)\n \t\t\t|| (bitpos % BITS_PER_UNIT)\n \t\t\t|| !int_mode_for_size (bitlen, 0).exists ());\n-  bool empty_ctor_p\n-    = (TREE_CODE (expr) == CONSTRUCTOR\n-       && CONSTRUCTOR_NELTS (expr) == 0\n-       && TYPE_SIZE_UNIT (TREE_TYPE (expr))\n-\t\t       && tree_fits_uhwi_p (TYPE_SIZE_UNIT (TREE_TYPE (expr))));\n \n   if (!sub_byte_op_p)\n-    {\n-      if (first_byte >= total_bytes)\n-\treturn false;\n-      total_bytes -= first_byte;\n-      if (empty_ctor_p)\n-\t{\n-\t  unsigned HOST_WIDE_INT rhs_bytes\n-\t    = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (expr)));\n-\t  if (rhs_bytes > total_bytes)\n-\t    return false;\n-\t  memset (ptr + first_byte, '\\0', rhs_bytes);\n-\t  return true;\n-\t}\n-      return native_encode_expr (expr, ptr + first_byte, total_bytes) != 0;\n-    }\n+    return native_encode_expr (tmp_int, ptr + first_byte, total_bytes) != 0;\n \n   /* LITTLE-ENDIAN\n      We are writing a non byte-sized quantity or at a position that is not\n@@ -1685,29 +1667,14 @@ encode_tree_to_bitpos (tree expr, unsigned char *ptr, int bitlen, int bitpos,\n \n   /* We must be dealing with fixed-size data at this point, since the\n      total size is also fixed.  */\n-  unsigned int byte_size;\n-  if (empty_ctor_p)\n-    {\n-      unsigned HOST_WIDE_INT rhs_bytes\n-\t= tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (expr)));\n-      if (rhs_bytes > total_bytes)\n-\treturn false;\n-      byte_size = rhs_bytes;\n-    }\n-  else\n-    {\n-      fixed_size_mode mode\n-\t= as_a <fixed_size_mode> (TYPE_MODE (TREE_TYPE (expr)));\n-      byte_size = GET_MODE_SIZE (mode);\n-    }\n+  fixed_size_mode mode = as_a <fixed_size_mode> (TYPE_MODE (TREE_TYPE (expr)));\n   /* Allocate an extra byte so that we have space to shift into.  */\n-  byte_size++;\n+  unsigned int byte_size = GET_MODE_SIZE (mode) + 1;\n   unsigned char *tmpbuf = XALLOCAVEC (unsigned char, byte_size);\n   memset (tmpbuf, '\\0', byte_size);\n   /* The store detection code should only have allowed constants that are\n-     accepted by native_encode_expr or empty ctors.  */\n-  if (!empty_ctor_p\n-      && native_encode_expr (expr, tmpbuf, byte_size - 1) == 0)\n+     accepted by native_encode_expr.  */\n+  if (native_encode_expr (expr, tmpbuf, byte_size - 1) == 0)\n     gcc_unreachable ();\n \n   /* The native_encode_expr machinery uses TYPE_MODE to determine how many\n@@ -4197,8 +4164,7 @@ lhs_valid_for_store_merging_p (tree lhs)\n   tree_code code = TREE_CODE (lhs);\n \n   if (code == ARRAY_REF || code == ARRAY_RANGE_REF || code == MEM_REF\n-      || code == COMPONENT_REF || code == BIT_FIELD_REF\n-      || DECL_P (lhs))\n+      || code == COMPONENT_REF || code == BIT_FIELD_REF)\n     return true;\n \n   return false;\n@@ -4212,11 +4178,6 @@ static bool\n rhs_valid_for_store_merging_p (tree rhs)\n {\n   unsigned HOST_WIDE_INT size;\n-  if (TREE_CODE (rhs) == CONSTRUCTOR\n-      && CONSTRUCTOR_NELTS (rhs) == 0\n-      && TYPE_SIZE_UNIT (TREE_TYPE (rhs))\n-      && tree_fits_uhwi_p (TYPE_SIZE_UNIT (TREE_TYPE (rhs))))\n-    return true;\n   return (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (rhs))).is_constant (&size)\n \t  && native_encode_expr (rhs, NULL, size) != 0);\n }"}]}