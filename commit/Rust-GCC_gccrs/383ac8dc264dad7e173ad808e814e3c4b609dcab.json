{"sha": "383ac8dc264dad7e173ad808e814e3c4b609dcab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzgzYWM4ZGMyNjRkYWQ3ZTE3M2FkODA4ZTgxNGUzYzRiNjA5ZGNhYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-11-08T15:46:58Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-11-08T15:46:58Z"}, "message": "re PR tree-optimization/78821 (GCC7: Copying whole 32 bits structure field by field not optimised into copying whole 32 bits at once)\n\n\tPR tree-optimization/78821\n\t* gimple-ssa-store-merging.c (struct store_operand_info): Add bit_not_p\n\tdata member.\n\t(store_operand_info::store_operand_info): Initialize it to false.\n\t(pass_store_merging::terminate_all_aliasing_chains): Rewritten to use\n\tref_maybe_used_by_stmt_p and stmt_may_clobber_ref_p on lhs of each\n\tstore in the group, and if chain_info is non-NULL, to ignore altogether\n\tthat chain.\n\t(compatible_load_p): Fail if bit_not_p does not match.\n\t(imm_store_chain_info::output_merged_store): Handle bit_not_p loads.\n\t(handled_load): Fill in bit_not_p.  Handle BIT_NOT_EXPR.\n\t(pass_store_merging::process_store): Adjust\n\tterminate_all_aliasing_chains calls to pass NULL in all current spots,\n\tcall terminate_all_aliasing_chains newly when adding a store into\n\ta chain with non-NULL chain_info.\n\n\t* gcc.dg/store_merging_2.c: Expect 3 store mergings instead of 2.\n\t* gcc.dg/store_merging_13.c (f7, f8, f9, f10, f11, f12, f13): New\n\tfunctions.\n\t(main): Test also those.  Expect 13 store mergings instead of 6.\n\t* gcc.dg/store_merging_14.c (f7, f8, f9): New functions.\n\t(main): Test also those.  Expect 9 store mergings instead of 6.\n\nFrom-SVN: r254536", "tree": {"sha": "d8ee3fb831dd90541d0114b71ab2b990661f2d41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8ee3fb831dd90541d0114b71ab2b990661f2d41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/383ac8dc264dad7e173ad808e814e3c4b609dcab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/383ac8dc264dad7e173ad808e814e3c4b609dcab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/383ac8dc264dad7e173ad808e814e3c4b609dcab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/383ac8dc264dad7e173ad808e814e3c4b609dcab/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a14ab2c3467950ccaad000864164a62d24129dd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a14ab2c3467950ccaad000864164a62d24129dd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a14ab2c3467950ccaad000864164a62d24129dd5"}], "stats": {"total": 335, "additions": 284, "deletions": 51}, "files": [{"sha": "7b13408ddfffb5eb817d707d72e31a28a6b8cb4c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/383ac8dc264dad7e173ad808e814e3c4b609dcab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/383ac8dc264dad7e173ad808e814e3c4b609dcab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=383ac8dc264dad7e173ad808e814e3c4b609dcab", "patch": "@@ -1,3 +1,21 @@\n+2017-11-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/78821\n+\t* gimple-ssa-store-merging.c (struct store_operand_info): Add bit_not_p\n+\tdata member.\n+\t(store_operand_info::store_operand_info): Initialize it to false.\n+\t(pass_store_merging::terminate_all_aliasing_chains): Rewritten to use\n+\tref_maybe_used_by_stmt_p and stmt_may_clobber_ref_p on lhs of each\n+\tstore in the group, and if chain_info is non-NULL, to ignore altogether\n+\tthat chain.\n+\t(compatible_load_p): Fail if bit_not_p does not match.\n+\t(imm_store_chain_info::output_merged_store): Handle bit_not_p loads.\n+\t(handled_load): Fill in bit_not_p.  Handle BIT_NOT_EXPR.\n+\t(pass_store_merging::process_store): Adjust\n+\tterminate_all_aliasing_chains calls to pass NULL in all current spots,\n+\tcall terminate_all_aliasing_chains newly when adding a store into\n+\ta chain with non-NULL chain_info.\n+\n 2017-11-08  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_can_eliminate): Simplify logic."}, {"sha": "34c9e7cf421c0c84859ff9f1b50d35bcd7428b5a", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 54, "deletions": 48, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/383ac8dc264dad7e173ad808e814e3c4b609dcab/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/383ac8dc264dad7e173ad808e814e3c4b609dcab/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=383ac8dc264dad7e173ad808e814e3c4b609dcab", "patch": "@@ -183,12 +183,13 @@ struct store_operand_info\n   unsigned HOST_WIDE_INT bitregion_start;\n   unsigned HOST_WIDE_INT bitregion_end;\n   gimple *stmt;\n+  bool bit_not_p;\n   store_operand_info ();\n };\n \n store_operand_info::store_operand_info ()\n   : val (NULL_TREE), base_addr (NULL_TREE), bitsize (0), bitpos (0),\n-    bitregion_start (0), bitregion_end (0), stmt (NULL)\n+    bitregion_start (0), bitregion_end (0), stmt (NULL), bit_not_p (false)\n {\n }\n \n@@ -910,8 +911,7 @@ class pass_store_merging : public gimple_opt_pass\n \n   void process_store (gimple *);\n   bool terminate_and_process_all_chains ();\n-  bool terminate_all_aliasing_chains (imm_store_chain_info **,\n-\t\t\t\t      gimple *);\n+  bool terminate_all_aliasing_chains (imm_store_chain_info **, gimple *);\n   bool terminate_and_release_chain (imm_store_chain_info *);\n }; // class pass_store_merging\n \n@@ -930,13 +930,9 @@ pass_store_merging::terminate_and_process_all_chains ()\n   return ret;\n }\n \n-/* Terminate all chains that are affected by the assignment to DEST, appearing\n-   in statement STMT and ultimately points to the object BASE.  Return true if\n-   at least one aliasing chain was terminated.  BASE and DEST are allowed to\n-   be NULL_TREE.  In that case the aliasing checks are performed on the whole\n-   statement rather than a particular operand in it.  VAR_OFFSET_P signifies\n-   whether STMT represents a store to BASE offset by a variable amount.\n-   If that is the case we have to terminate any chain anchored at BASE.  */\n+/* Terminate all chains that are affected by the statement STMT.\n+   CHAIN_INFO is the chain we should ignore from the checks if\n+   non-NULL.  */\n \n bool\n pass_store_merging::terminate_all_aliasing_chains (imm_store_chain_info\n@@ -949,14 +945,18 @@ pass_store_merging::terminate_all_aliasing_chains (imm_store_chain_info\n   if (!gimple_vuse (stmt))\n     return false;\n \n-  /* Check if the assignment destination (BASE) is part of a store chain.\n-     This is to catch non-constant stores to destinations that may be part\n-     of a chain.  */\n-  if (chain_info)\n+  for (imm_store_chain_info *next = m_stores_head, *cur = next; cur; cur = next)\n     {\n+      next = cur->next;\n+\n+      /* We already checked all the stores in chain_info and terminated the\n+\t chain if necessary.  Skip it here.  */\n+      if (chain_info && *chain_info == cur)\n+\tcontinue;\n+\n       store_immediate_info *info;\n       unsigned int i;\n-      FOR_EACH_VEC_ELT ((*chain_info)->m_store_info, i, info)\n+      FOR_EACH_VEC_ELT (cur->m_store_info, i, info)\n \t{\n \t  if (ref_maybe_used_by_stmt_p (stmt, gimple_assign_lhs (info->stmt))\n \t      || stmt_may_clobber_ref_p (stmt, gimple_assign_lhs (info->stmt)))\n@@ -966,37 +966,13 @@ pass_store_merging::terminate_all_aliasing_chains (imm_store_chain_info\n \t\t  fprintf (dump_file, \"stmt causes chain termination:\\n\");\n \t\t  print_gimple_stmt (dump_file, stmt, 0);\n \t\t}\n-\t      terminate_and_release_chain (*chain_info);\n+\t      terminate_and_release_chain (cur);\n \t      ret = true;\n \t      break;\n \t    }\n \t}\n     }\n \n-  /* Check for aliasing with all other store chains.  */\n-  for (imm_store_chain_info *next = m_stores_head, *cur = next; cur; cur = next)\n-    {\n-      next = cur->next;\n-\n-      /* We already checked all the stores in chain_info and terminated the\n-\t chain if necessary.  Skip it here.  */\n-      if (chain_info && (*chain_info) == cur)\n-\tcontinue;\n-\n-      /* We can't use the base object here as that does not reliably exist.\n-\t Build a ao_ref from the base object address (if we know the\n-\t minimum and maximum offset and the maximum size we could improve\n-\t things here).  */\n-      ao_ref chain_ref;\n-      ao_ref_init_from_ptr_and_size (&chain_ref, cur->base_addr, NULL_TREE);\n-      if (ref_maybe_used_by_stmt_p (stmt, &chain_ref)\n-\t  || stmt_may_clobber_ref_p_1 (stmt, &chain_ref))\n-\t{\n-\t  terminate_and_release_chain (cur);\n-\t  ret = true;\n-\t}\n-    }\n-\n   return ret;\n }\n \n@@ -1053,6 +1029,7 @@ compatible_load_p (merged_store_group *merged_store,\n {\n   store_immediate_info *infof = merged_store->stores[0];\n   if (!info->ops[idx].base_addr\n+      || info->ops[idx].bit_not_p != infof->ops[idx].bit_not_p\n       || (info->ops[idx].bitpos - infof->ops[idx].bitpos\n \t  != info->bitpos - infof->bitpos)\n       || !operand_equal_p (info->ops[idx].base_addr,\n@@ -1755,6 +1732,19 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \t\t      gimple_seq_add_stmt_without_update (&seq, stmt);\n \t\t    }\n \t\t  ops[j] = gimple_assign_lhs (stmt);\n+\t\t  if (op.bit_not_p)\n+\t\t    {\n+\t\t      stmt = gimple_build_assign (make_ssa_name (int_type),\n+\t\t\t\t\t\t  BIT_NOT_EXPR, ops[j]);\n+\t\t      gimple_set_location (stmt, load_loc);\n+\t\t      ops[j] = gimple_assign_lhs (stmt);\n+\n+\t\t      if (gsi_bb (load_gsi[j]))\n+\t\t\tgimple_seq_add_stmt_without_update (&load_seq[j],\n+\t\t\t\t\t\t\t    stmt);\n+\t\t      else\n+\t\t\tgimple_seq_add_stmt_without_update (&seq, stmt);\n+\t\t    }\n \t\t}\n \t      else\n \t\tops[j] = native_interpret_expr (int_type,\n@@ -2100,9 +2090,23 @@ handled_load (gimple *stmt, store_operand_info *op,\n \t      unsigned HOST_WIDE_INT bitregion_start,\n \t      unsigned HOST_WIDE_INT bitregion_end)\n {\n-  if (!is_gimple_assign (stmt) || !gimple_vuse (stmt))\n+  if (!is_gimple_assign (stmt))\n     return false;\n-  if (gimple_assign_load_p (stmt)\n+  if (gimple_assign_rhs_code (stmt) == BIT_NOT_EXPR)\n+    {\n+      tree rhs1 = gimple_assign_rhs1 (stmt);\n+      if (TREE_CODE (rhs1) == SSA_NAME\n+\t  && has_single_use (rhs1)\n+\t  && handled_load (SSA_NAME_DEF_STMT (rhs1), op, bitsize, bitpos,\n+\t\t\t   bitregion_start, bitregion_end))\n+\t{\n+\t  op->bit_not_p = !op->bit_not_p;\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+  if (gimple_vuse (stmt)\n+      && gimple_assign_load_p (stmt)\n       && !stmt_can_throw_internal (stmt)\n       && !gimple_has_volatile_ops (stmt))\n     {\n@@ -2119,6 +2123,7 @@ handled_load (gimple *stmt, store_operand_info *op,\n \t{\n \t  op->stmt = stmt;\n \t  op->val = mem;\n+\t  op->bit_not_p = false;\n \t  return true;\n \t}\n     }\n@@ -2202,16 +2207,16 @@ pass_store_merging::process_store (gimple *stmt)\n \t  }\n     }\n \n-  struct imm_store_chain_info **chain_info = NULL;\n-  if (base_addr)\n-    chain_info = m_stores.get (base_addr);\n-\n   if (invalid)\n     {\n-      terminate_all_aliasing_chains (chain_info, stmt);\n+      terminate_all_aliasing_chains (NULL, stmt);\n       return;\n     }\n \n+  struct imm_store_chain_info **chain_info = NULL;\n+  if (base_addr)\n+    chain_info = m_stores.get (base_addr);\n+\n   store_immediate_info *info;\n   if (chain_info)\n     {\n@@ -2225,6 +2230,7 @@ pass_store_merging::process_store (gimple *stmt)\n \t  print_gimple_stmt (dump_file, stmt, 0);\n \t}\n       (*chain_info)->m_store_info.safe_push (info);\n+      terminate_all_aliasing_chains (chain_info, stmt);\n       /* If we reach the limit of stores to merge in a chain terminate and\n \t process the chain now.  */\n       if ((*chain_info)->m_store_info.length ()\n@@ -2239,7 +2245,7 @@ pass_store_merging::process_store (gimple *stmt)\n     }\n \n   /* Store aliases any existing chain?  */\n-  terminate_all_aliasing_chains (chain_info, stmt);\n+  terminate_all_aliasing_chains (NULL, stmt);\n   /* Start a new chain.  */\n   struct imm_store_chain_info *new_chain\n     = new imm_store_chain_info (m_stores_head, base_addr);"}, {"sha": "ca2f9c7e708471eb3fa64c8748a9e4739b38eab1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/383ac8dc264dad7e173ad808e814e3c4b609dcab/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/383ac8dc264dad7e173ad808e814e3c4b609dcab/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=383ac8dc264dad7e173ad808e814e3c4b609dcab", "patch": "@@ -1,3 +1,13 @@\n+2017-11-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/78821\n+\t* gcc.dg/store_merging_2.c: Expect 3 store mergings instead of 2.\n+\t* gcc.dg/store_merging_13.c (f7, f8, f9, f10, f11, f12, f13): New\n+\tfunctions.\n+\t(main): Test also those.  Expect 13 store mergings instead of 6.\n+\t* gcc.dg/store_merging_14.c (f7, f8, f9): New functions.\n+\t(main): Test also those.  Expect 9 store mergings instead of 6.\n+\n 2017-11-08  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* gcc.target/aarch64/dwarf-cfa-reg.c: Update."}, {"sha": "6ee0a9c2c805baa4ce937769fe76f4a7ac2df8e9", "filename": "gcc/testsuite/gcc.dg/store_merging_13.c", "status": "modified", "additions": 140, "deletions": 1, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/383ac8dc264dad7e173ad808e814e3c4b609dcab/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/383ac8dc264dad7e173ad808e814e3c4b609dcab/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_13.c?ref=383ac8dc264dad7e173ad808e814e3c4b609dcab", "patch": "@@ -104,6 +104,90 @@ f6 (struct S *p, struct S *q)\n   p->g = pg;\n }\n \n+__attribute__((noipa)) void\n+f7 (struct S *__restrict p, struct S *__restrict q)\n+{\n+  p->a |= q->a;\n+  p->b |= q->b;\n+  p->c |= q->c;\n+  p->d |= q->d;\n+  p->e |= q->e;\n+  p->f |= q->f;\n+  p->g |= q->g;\n+}\n+\n+__attribute__((noipa)) void\n+f8 (struct S *__restrict p, struct S *__restrict q)\n+{\n+  p->a &= q->a;\n+  p->b &= q->b;\n+  p->c &= q->c;\n+  p->d &= q->d;\n+  p->e &= q->e;\n+  p->f &= q->f;\n+  p->g &= q->g;\n+}\n+\n+__attribute__((noipa)) void\n+f9 (struct S *__restrict p, struct S *__restrict q)\n+{\n+  p->a ^= q->a;\n+  p->b ^= q->b;\n+  p->c ^= q->c;\n+  p->d ^= q->d;\n+  p->e ^= q->e;\n+  p->f ^= q->f;\n+  p->g ^= q->g;\n+}\n+\n+__attribute__((noipa)) void\n+f10 (struct S *__restrict p, struct S *__restrict q)\n+{\n+  p->a = ~q->a;\n+  p->b = ~q->b;\n+  p->c = ~q->c;\n+  p->d = ~q->d;\n+  p->e = ~q->e;\n+  p->f = ~q->f;\n+  p->g = ~q->g;\n+}\n+\n+__attribute__((noipa)) void\n+f11 (struct S *__restrict p, struct S *__restrict q)\n+{\n+  p->a = p->a | (unsigned char) ~q->a;\n+  p->b = p->b | (unsigned char) ~q->b;\n+  p->c = p->c | (unsigned short) ~q->c;\n+  p->d = p->d | (unsigned char) ~q->d;\n+  p->e = p->e | (unsigned char) ~q->e;\n+  p->f = p->f | (unsigned char) ~q->f;\n+  p->g = p->g | (unsigned char) ~q->g;\n+}\n+\n+__attribute__((noipa)) void\n+f12 (struct S *__restrict p, struct S *__restrict q)\n+{\n+  p->a = p->a & (unsigned char) ~q->a;\n+  p->b = p->b & (unsigned char) ~q->b;\n+  p->c = p->c & (unsigned short) ~q->c;\n+  p->d = p->d & (unsigned char) ~q->d;\n+  p->e = p->e & (unsigned char) ~q->e;\n+  p->f = p->f & (unsigned char) ~q->f;\n+  p->g = p->g & (unsigned char) ~q->g;\n+}\n+\n+__attribute__((noipa)) void\n+f13 (struct S *__restrict p, struct S *__restrict q)\n+{\n+  p->a = p->a ^ (unsigned char) ~q->a;\n+  p->b = p->b ^ (unsigned char) ~q->b;\n+  p->c = p->c ^ (unsigned short) ~q->c;\n+  p->d = p->d ^ (unsigned char) ~q->d;\n+  p->e = p->e ^ (unsigned char) ~q->e;\n+  p->f = p->f ^ (unsigned char) ~q->f;\n+  p->g = p->g ^ (unsigned char) ~q->g;\n+}\n+\n struct S s = { 20, 21, 22, 23, 24, 25, 26, 27 };\n struct S t = { 0x71, 0x72, 0x7f04, 0x78, 0x31, 0x32, 0x34, 0xf1f2f3f4f5f6f7f8ULL };\n struct S u = { 28, 29, 30, 31, 32, 33, 34, 35 };\n@@ -151,7 +235,62 @@ main ()\n       || s.e != (40 ^ 0x31) || s.f != (41 ^ 0x32)\n       || s.g != (42 ^ 0x34) || s.h != 27)\n     __builtin_abort ();\n+  f3 (&s, &v);\n+  f7 (&s, &t);\n+  asm volatile (\"\" : : : \"memory\");\n+  if (s.a != (36 | 0x71) || s.b != (37 | 0x72)\n+      || s.c != (38 | 0x7f04) || s.d != (39 | 0x78)\n+      || s.e != (40 | 0x31) || s.f != (41 | 0x32)\n+      || s.g != (42 | 0x34) || s.h != 27)\n+    __builtin_abort ();\n+  f3 (&s, &u);\n+  f8 (&s, &t);\n+  asm volatile (\"\" : : : \"memory\");\n+  if (s.a != (28 & 0x71) || s.b != (29 & 0x72)\n+      || s.c != (30 & 0x7f04) || s.d != (31 & 0x78)\n+      || s.e != (32 & 0x31) || s.f != (33 & 0x32)\n+      || s.g != (34 & 0x34) || s.h != 27)\n+    __builtin_abort ();\n+  f2 (&s, &v);\n+  f9 (&s, &t);\n+  asm volatile (\"\" : : : \"memory\");\n+  if (s.a != (36 ^ 0x71) || s.b != (37 ^ 0x72)\n+      || s.c != (38 ^ 0x7f04) || s.d != (39 ^ 0x78)\n+      || s.e != (40 ^ 0x31) || s.f != (41 ^ 0x32)\n+      || s.g != (42 ^ 0x34) || s.h != 27)\n+    __builtin_abort ();\n+  f10 (&s, &u);\n+  asm volatile (\"\" : : : \"memory\");\n+  if (s.a != (unsigned char) ~28 || s.b != (unsigned char) ~29\n+      || s.c != (unsigned short) ~30 || s.d != (unsigned char) ~31\n+      || s.e != (unsigned char) ~32 || s.f != (unsigned char) ~33\n+      || s.g != (unsigned char) ~34 || s.h != 27)\n+    __builtin_abort ();\n+  f3 (&s, &v);\n+  f11 (&s, &t);\n+  asm volatile (\"\" : : : \"memory\");\n+  if (s.a != (36 | (unsigned char) ~0x71) || s.b != (37 | (unsigned char) ~0x72)\n+      || s.c != (38 | (unsigned short) ~0x7f04) || s.d != (39 | (unsigned char) ~0x78)\n+      || s.e != (40 | (unsigned char) ~0x31) || s.f != (41 | (unsigned char) ~0x32)\n+      || s.g != (42 | (unsigned char) ~0x34) || s.h != 27)\n+    __builtin_abort ();\n+  f3 (&s, &u);\n+  f12 (&s, &t);\n+  asm volatile (\"\" : : : \"memory\");\n+  if (s.a != (28 & (unsigned char) ~0x71) || s.b != (29 & (unsigned char) ~0x72)\n+      || s.c != (30 & (unsigned short) ~0x7f04) || s.d != (31 & (unsigned char) ~0x78)\n+      || s.e != (32 & (unsigned char) ~0x31) || s.f != (33 & (unsigned char) ~0x32)\n+      || s.g != (34 & (unsigned char) ~0x34) || s.h != 27)\n+    __builtin_abort ();\n+  f2 (&s, &v);\n+  f13 (&s, &t);\n+  asm volatile (\"\" : : : \"memory\");\n+  if (s.a != (36 ^ (unsigned char) ~0x71) || s.b != (37 ^ (unsigned char) ~0x72)\n+      || s.c != (38 ^ (unsigned short) ~0x7f04) || s.d != (39 ^ (unsigned char) ~0x78)\n+      || s.e != (40 ^ (unsigned char) ~0x31) || s.f != (41 ^ (unsigned char) ~0x32)\n+      || s.g != (42 ^ (unsigned char) ~0x34) || s.h != 27)\n+    __builtin_abort ();\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Merging successful\" 6 \"store-merging\" } } */\n+/* { dg-final { scan-tree-dump-times \"Merging successful\" 13 \"store-merging\" } } */"}, {"sha": "3885acb10a25157757e8c0e90fdff5fac87794e4", "filename": "gcc/testsuite/gcc.dg/store_merging_14.c", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/383ac8dc264dad7e173ad808e814e3c4b609dcab/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/383ac8dc264dad7e173ad808e814e3c4b609dcab/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_14.c?ref=383ac8dc264dad7e173ad808e814e3c4b609dcab", "patch": "@@ -104,6 +104,42 @@ f6 (struct S *p, struct S *q)\n   p->g = pg;\n }\n \n+__attribute__((noipa)) void\n+f7 (struct S *__restrict p, struct S *__restrict q)\n+{\n+  p->a |= q->a;\n+  p->b |= q->b;\n+  p->c |= q->c;\n+  p->d |= q->d;\n+  p->e |= q->e;\n+  p->f |= q->f;\n+  p->g |= q->g;\n+}\n+\n+__attribute__((noipa)) void\n+f8 (struct S *__restrict p, struct S *__restrict q)\n+{\n+  p->a &= q->a;\n+  p->b &= q->b;\n+  p->c &= q->c;\n+  p->d &= q->d;\n+  p->e &= q->e;\n+  p->f &= q->f;\n+  p->g &= q->g;\n+}\n+\n+__attribute__((noipa)) void\n+f9 (struct S *__restrict p, struct S *__restrict q)\n+{\n+  p->a ^= q->a;\n+  p->b ^= q->b;\n+  p->c ^= q->c;\n+  p->d ^= q->d;\n+  p->e ^= q->e;\n+  p->f ^= q->f;\n+  p->g ^= q->g;\n+}\n+\n struct S s = { 72, 20, 21, 73, 22, 23, 24, 25, 26, 74, 27 };\n struct S t = { 75, 0x71, 0x72, 76, 0x7f04, 0x78, 0x31, 0x32, 0x34, 77, 0xf1f2f3f4f5f6f7f8ULL };\n struct S u = { 78, 28, 29, 79, 30, 31, 32, 33, 34, 80, 35 };\n@@ -146,6 +182,30 @@ main ()\n   f2 (&s, &v);\n   f6 (&s, &t);\n   asm volatile (\"\" : : : \"memory\");\n+  if (s.i != 72 || s.a != (36 ^ 0x71) || s.b != (37 ^ 0x72) || s.j != 73\n+      || s.c != (38 ^ 0x7f04) || s.d != (39 ^ 0x78)\n+      || s.e != (40 ^ 0x31) || s.f != (41 ^ 0x32)\n+      || s.g != (42 ^ 0x34) || s.k != 74 || s.h != 27)\n+    __builtin_abort ();\n+  f3 (&s, &v);\n+  f7 (&s, &t);\n+  asm volatile (\"\" : : : \"memory\");\n+  if (s.i != 72 || s.a != (36 | 0x71) || s.b != (37 | 0x72) || s.j != 73\n+      || s.c != (38 | 0x7f04) || s.d != (39 | 0x78)\n+      || s.e != (40 | 0x31) || s.f != (41 | 0x32)\n+      || s.g != (42 | 0x34) || s.k != 74 || s.h != 27)\n+    __builtin_abort ();\n+  f3 (&s, &u);\n+  f8 (&s, &t);\n+  asm volatile (\"\" : : : \"memory\");\n+  if (s.i != 72 || s.a != (28 & 0x71) || s.b != (29 & 0x72) || s.j != 73\n+      || s.c != (30 & 0x7f04) || s.d != (31 & 0x78)\n+      || s.e != (32 & 0x31) || s.f != (33 & 0x32)\n+      || s.g != (34 & 0x34) || s.k != 74 || s.h != 27)\n+    __builtin_abort ();\n+  f2 (&s, &v);\n+  f9 (&s, &t);\n+  asm volatile (\"\" : : : \"memory\");\n   if (s.i != 72 || s.a != (36 ^ 0x71) || s.b != (37 ^ 0x72) || s.j != 73\n       || s.c != (38 ^ 0x7f04) || s.d != (39 ^ 0x78)\n       || s.e != (40 ^ 0x31) || s.f != (41 ^ 0x32)\n@@ -154,4 +214,4 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Merging successful\" 6 \"store-merging\" } } */\n+/* { dg-final { scan-tree-dump-times \"Merging successful\" 9 \"store-merging\" } } */"}, {"sha": "19de3e2e0b53c70d533478366a5909df3a8cb373", "filename": "gcc/testsuite/gcc.dg/store_merging_2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/383ac8dc264dad7e173ad808e814e3c4b609dcab/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/383ac8dc264dad7e173ad808e814e3c4b609dcab/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_2.c?ref=383ac8dc264dad7e173ad808e814e3c4b609dcab", "patch": "@@ -77,4 +77,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Merging successful\" 2 \"store-merging\" } } */\n+/* { dg-final { scan-tree-dump-times \"Merging successful\" 3 \"store-merging\" } } */"}]}