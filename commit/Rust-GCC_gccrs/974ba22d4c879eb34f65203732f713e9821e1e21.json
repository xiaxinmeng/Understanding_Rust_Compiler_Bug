{"sha": "974ba22d4c879eb34f65203732f713e9821e1e21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc0YmEyMmQ0Yzg3OWViMzRmNjUyMDM3MzJmNzEzZTk4MjFlMWUyMQ==", "commit": {"author": {"name": "Greta Yorsh", "email": "greta.yorsh@arm.com", "date": "2013-04-16T17:04:22Z"}, "committer": {"name": "Greta Yorsh", "email": "gretay@gcc.gnu.org", "date": "2013-04-16T17:04:22Z"}, "message": "Prologue/epilogue using STRD/LDRD in ARM mode\n\n2013-04-16  Greta Yorsh  <Greta.Yorsh at arm.com>\n\n\t* config/arm/arm.c (emit_multi_reg_push): New declaration\n\tfor an existing function.\n\t(arm_emit_strd_push): New function.\n\t(arm_expand_prologue): Used here.\n\t(arm_emit_ldrd_pop): New function.\n\t(arm_expand_epilogue): Used here.\n\t(arm_get_frame_offsets): Update condition.\n\t(arm_emit_multi_reg_pop): Add a special case for load of a single\n\tregister with writeback.\n\nFrom-SVN: r198004", "tree": {"sha": "45bf347d1680794c5dcc41aee0dff88ab7c35ab2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45bf347d1680794c5dcc41aee0dff88ab7c35ab2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/974ba22d4c879eb34f65203732f713e9821e1e21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/974ba22d4c879eb34f65203732f713e9821e1e21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/974ba22d4c879eb34f65203732f713e9821e1e21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/974ba22d4c879eb34f65203732f713e9821e1e21/comments", "author": null, "committer": null, "parents": [{"sha": "5e8e2af44b799830fa85976c874a38ed6b0b364c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e8e2af44b799830fa85976c874a38ed6b0b364c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e8e2af44b799830fa85976c874a38ed6b0b364c"}], "stats": {"total": 302, "additions": 300, "deletions": 2}, "files": [{"sha": "92b4a77fbcaebedd8ddf23b27dd1f26038c3fd2e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/974ba22d4c879eb34f65203732f713e9821e1e21/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/974ba22d4c879eb34f65203732f713e9821e1e21/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=974ba22d4c879eb34f65203732f713e9821e1e21", "patch": "@@ -1,3 +1,15 @@\n+2013-04-16  Greta Yorsh  <Greta.Yorsh at arm.com>\n+\n+\t* config/arm/arm.c (emit_multi_reg_push): New declaration\n+\tfor an existing function.\n+\t(arm_emit_strd_push): New function.\n+\t(arm_expand_prologue): Used here.\n+\t(arm_emit_ldrd_pop): New function.\n+\t(arm_expand_epilogue): Used here.\n+\t(arm_get_frame_offsets): Update condition.\n+\t(arm_emit_multi_reg_pop): Add a special case for load of a single\n+\tregister with writeback.\n+\n 2013-04-16  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* doc/invoke.texi (i386 Option): Reword -mstack-protector-guard"}, {"sha": "bac709f1fa372cbe1955322ef71a402996f666fb", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 288, "deletions": 2, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/974ba22d4c879eb34f65203732f713e9821e1e21/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/974ba22d4c879eb34f65203732f713e9821e1e21/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=974ba22d4c879eb34f65203732f713e9821e1e21", "patch": "@@ -173,6 +173,7 @@ static rtx arm_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n static tree arm_builtin_decl (unsigned, bool);\n static void emit_constant_insn (rtx cond, rtx pattern);\n static rtx emit_set_insn (rtx, rtx);\n+static rtx emit_multi_reg_push (unsigned long);\n static int arm_arg_partial_bytes (cumulative_args_t, enum machine_mode,\n \t\t\t\t  tree, bool);\n static rtx arm_function_arg (cumulative_args_t, enum machine_mode,\n@@ -16693,6 +16694,148 @@ thumb2_emit_strd_push (unsigned long saved_regs_mask)\n   return;\n }\n \n+/* STRD in ARM mode requires consecutive registers.  This function emits STRD\n+   whenever possible, otherwise it emits single-word stores.  The first store\n+   also allocates stack space for all saved registers, using writeback with\n+   post-addressing mode.  All other stores use offset addressing.  If no STRD\n+   can be emitted, this function emits a sequence of single-word stores,\n+   and not an STM as before, because single-word stores provide more freedom\n+   scheduling and can be turned into an STM by peephole optimizations.  */\n+static void\n+arm_emit_strd_push (unsigned long saved_regs_mask)\n+{\n+  int num_regs = 0;\n+  int i, j, dwarf_index  = 0;\n+  int offset = 0;\n+  rtx dwarf = NULL_RTX;\n+  rtx insn = NULL_RTX;\n+  rtx tmp, mem;\n+\n+  /* TODO: A more efficient code can be emitted by changing the\n+     layout, e.g., first push all pairs that can use STRD to keep the\n+     stack aligned, and then push all other registers.  */\n+  for (i = 0; i <= LAST_ARM_REGNUM; i++)\n+    if (saved_regs_mask & (1 << i))\n+      num_regs++;\n+\n+  gcc_assert (!(saved_regs_mask & (1 << SP_REGNUM)));\n+  gcc_assert (!(saved_regs_mask & (1 << PC_REGNUM)));\n+  gcc_assert (num_regs > 0);\n+\n+  /* Create sequence for DWARF info.  */\n+  dwarf = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (num_regs + 1));\n+\n+  /* For dwarf info, we generate explicit stack update.  */\n+  tmp = gen_rtx_SET (VOIDmode,\n+                     stack_pointer_rtx,\n+                     plus_constant (Pmode, stack_pointer_rtx, -4 * num_regs));\n+  RTX_FRAME_RELATED_P (tmp) = 1;\n+  XVECEXP (dwarf, 0, dwarf_index++) = tmp;\n+\n+  /* Save registers.  */\n+  offset = - 4 * num_regs;\n+  j = 0;\n+  while (j <= LAST_ARM_REGNUM)\n+    if (saved_regs_mask & (1 << j))\n+      {\n+        if ((j % 2 == 0)\n+            && (saved_regs_mask & (1 << (j + 1))))\n+          {\n+            /* Current register and previous register form register pair for\n+               which STRD can be generated.  */\n+            if (offset < 0)\n+              {\n+                /* Allocate stack space for all saved registers.  */\n+                tmp = plus_constant (Pmode, stack_pointer_rtx, offset);\n+                tmp = gen_rtx_PRE_MODIFY (Pmode, stack_pointer_rtx, tmp);\n+                mem = gen_frame_mem (DImode, tmp);\n+                offset = 0;\n+              }\n+            else if (offset > 0)\n+              mem = gen_frame_mem (DImode,\n+                                   plus_constant (Pmode,\n+                                                  stack_pointer_rtx,\n+                                                  offset));\n+            else\n+              mem = gen_frame_mem (DImode, stack_pointer_rtx);\n+\n+            tmp = gen_rtx_SET (DImode, mem, gen_rtx_REG (DImode, j));\n+            RTX_FRAME_RELATED_P (tmp) = 1;\n+            tmp = emit_insn (tmp);\n+\n+            /* Record the first store insn.  */\n+            if (dwarf_index == 1)\n+              insn = tmp;\n+\n+            /* Generate dwarf info.  */\n+            mem = gen_frame_mem (SImode,\n+                                 plus_constant (Pmode,\n+                                                stack_pointer_rtx,\n+                                                offset));\n+            tmp = gen_rtx_SET (SImode, mem, gen_rtx_REG (SImode, j));\n+            RTX_FRAME_RELATED_P (tmp) = 1;\n+            XVECEXP (dwarf, 0, dwarf_index++) = tmp;\n+\n+            mem = gen_frame_mem (SImode,\n+                                 plus_constant (Pmode,\n+                                                stack_pointer_rtx,\n+                                                offset + 4));\n+            tmp = gen_rtx_SET (SImode, mem, gen_rtx_REG (SImode, j + 1));\n+            RTX_FRAME_RELATED_P (tmp) = 1;\n+            XVECEXP (dwarf, 0, dwarf_index++) = tmp;\n+\n+            offset += 8;\n+            j += 2;\n+          }\n+        else\n+          {\n+            /* Emit a single word store.  */\n+            if (offset < 0)\n+              {\n+                /* Allocate stack space for all saved registers.  */\n+                tmp = plus_constant (Pmode, stack_pointer_rtx, offset);\n+                tmp = gen_rtx_PRE_MODIFY (Pmode, stack_pointer_rtx, tmp);\n+                mem = gen_frame_mem (SImode, tmp);\n+                offset = 0;\n+              }\n+            else if (offset > 0)\n+              mem = gen_frame_mem (SImode,\n+                                   plus_constant (Pmode,\n+                                                  stack_pointer_rtx,\n+                                                  offset));\n+            else\n+              mem = gen_frame_mem (SImode, stack_pointer_rtx);\n+\n+            tmp = gen_rtx_SET (SImode, mem, gen_rtx_REG (SImode, j));\n+            RTX_FRAME_RELATED_P (tmp) = 1;\n+            tmp = emit_insn (tmp);\n+\n+            /* Record the first store insn.  */\n+            if (dwarf_index == 1)\n+              insn = tmp;\n+\n+            /* Generate dwarf info.  */\n+            mem = gen_frame_mem (SImode,\n+                                 plus_constant(Pmode,\n+                                               stack_pointer_rtx,\n+                                               offset));\n+            tmp = gen_rtx_SET (SImode, mem, gen_rtx_REG (SImode, j));\n+            RTX_FRAME_RELATED_P (tmp) = 1;\n+            XVECEXP (dwarf, 0, dwarf_index++) = tmp;\n+\n+            offset += 4;\n+            j += 1;\n+          }\n+      }\n+    else\n+      j++;\n+\n+  /* Attach dwarf info to the first insn we generate.  */\n+  gcc_assert (insn != NULL_RTX);\n+  add_reg_note (insn, REG_FRAME_RELATED_EXPR, dwarf);\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+}\n+\n /* Generate and emit an insn that we will recognize as a push_multi.\n    Unfortunately, since this insn does not reflect very well the actual\n    semantics of the operation, we need to annotate the insn for the benefit\n@@ -16892,6 +17035,17 @@ arm_emit_multi_reg_pop (unsigned long saved_regs_mask)\n     if (saved_regs_mask & (1 << i))\n       {\n         reg = gen_rtx_REG (SImode, i);\n+        if ((num_regs == 1) && emit_update && !return_in_pc)\n+          {\n+            /* Emit single load with writeback.  */\n+            tmp = gen_frame_mem (SImode,\n+                                 gen_rtx_POST_INC (Pmode,\n+                                                   stack_pointer_rtx));\n+            tmp = emit_insn (gen_rtx_SET (VOIDmode, reg, tmp));\n+            REG_NOTES (tmp) = alloc_reg_note (REG_CFA_RESTORE, reg, dwarf);\n+            return;\n+          }\n+\n         tmp = gen_rtx_SET (VOIDmode,\n                            reg,\n                            gen_frame_mem\n@@ -17123,6 +17277,129 @@ thumb2_emit_ldrd_pop (unsigned long saved_regs_mask)\n   return;\n }\n \n+/* LDRD in ARM mode needs consecutive registers as operands.  This function\n+   emits LDRD whenever possible, otherwise it emits single-word loads. It uses\n+   offset addressing and then generates one separate stack udpate. This provides\n+   more scheduling freedom, compared to writeback on every load.  However,\n+   if the function returns using load into PC directly\n+   (i.e., if PC is in SAVED_REGS_MASK), the stack needs to be updated\n+   before the last load.  TODO: Add a peephole optimization to recognize\n+   the new epilogue sequence as an LDM instruction whenever possible.  TODO: Add\n+   peephole optimization to merge the load at stack-offset zero\n+   with the stack update instruction using load with writeback\n+   in post-index addressing mode.  */\n+static void\n+arm_emit_ldrd_pop (unsigned long saved_regs_mask)\n+{\n+  int j = 0;\n+  int offset = 0;\n+  rtx par = NULL_RTX;\n+  rtx dwarf = NULL_RTX;\n+  rtx tmp, mem;\n+\n+  /* Restore saved registers.  */\n+  gcc_assert (!((saved_regs_mask & (1 << SP_REGNUM))));\n+  j = 0;\n+  while (j <= LAST_ARM_REGNUM)\n+    if (saved_regs_mask & (1 << j))\n+      {\n+        if ((j % 2) == 0\n+            && (saved_regs_mask & (1 << (j + 1)))\n+            && (j + 1) != PC_REGNUM)\n+          {\n+            /* Current register and next register form register pair for which\n+               LDRD can be generated. PC is always the last register popped, and\n+               we handle it separately.  */\n+            if (offset > 0)\n+              mem = gen_frame_mem (DImode,\n+                                   plus_constant (Pmode,\n+                                                  stack_pointer_rtx,\n+                                                  offset));\n+            else\n+              mem = gen_frame_mem (DImode, stack_pointer_rtx);\n+\n+            tmp = gen_rtx_SET (DImode, gen_rtx_REG (DImode, j), mem);\n+            RTX_FRAME_RELATED_P (tmp) = 1;\n+            tmp = emit_insn (tmp);\n+\n+            /* Generate dwarf info.  */\n+\n+            dwarf = alloc_reg_note (REG_CFA_RESTORE,\n+                                    gen_rtx_REG (SImode, j),\n+                                    NULL_RTX);\n+            dwarf = alloc_reg_note (REG_CFA_RESTORE,\n+                                    gen_rtx_REG (SImode, j + 1),\n+                                    dwarf);\n+\n+            REG_NOTES (tmp) = dwarf;\n+\n+            offset += 8;\n+            j += 2;\n+          }\n+        else if (j != PC_REGNUM)\n+          {\n+            /* Emit a single word load.  */\n+            if (offset > 0)\n+              mem = gen_frame_mem (SImode,\n+                                   plus_constant (Pmode,\n+                                                  stack_pointer_rtx,\n+                                                  offset));\n+            else\n+              mem = gen_frame_mem (SImode, stack_pointer_rtx);\n+\n+            tmp = gen_rtx_SET (SImode, gen_rtx_REG (SImode, j), mem);\n+            RTX_FRAME_RELATED_P (tmp) = 1;\n+            tmp = emit_insn (tmp);\n+\n+            /* Generate dwarf info.  */\n+            REG_NOTES (tmp) = alloc_reg_note (REG_CFA_RESTORE,\n+                                              gen_rtx_REG (SImode, j),\n+                                              NULL_RTX);\n+\n+            offset += 4;\n+            j += 1;\n+          }\n+        else /* j == PC_REGNUM */\n+          j++;\n+      }\n+    else\n+      j++;\n+\n+  /* Update the stack.  */\n+  if (offset > 0)\n+    {\n+      tmp = gen_rtx_SET (Pmode,\n+                         stack_pointer_rtx,\n+                         plus_constant (Pmode,\n+                                        stack_pointer_rtx,\n+                                        offset));\n+      RTX_FRAME_RELATED_P (tmp) = 1;\n+      emit_insn (tmp);\n+      offset = 0;\n+    }\n+\n+  if (saved_regs_mask & (1 << PC_REGNUM))\n+    {\n+      /* Only PC is to be popped.  */\n+      par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));\n+      XVECEXP (par, 0, 0) = ret_rtx;\n+      tmp = gen_rtx_SET (SImode,\n+                         gen_rtx_REG (SImode, PC_REGNUM),\n+                         gen_frame_mem (SImode,\n+                                        gen_rtx_POST_INC (SImode,\n+                                                          stack_pointer_rtx)));\n+      RTX_FRAME_RELATED_P (tmp) = 1;\n+      XVECEXP (par, 0, 1) = tmp;\n+      par = emit_jump_insn (par);\n+\n+      /* Generate dwarf info.  */\n+      dwarf = alloc_reg_note (REG_CFA_RESTORE,\n+                              gen_rtx_REG (SImode, PC_REGNUM),\n+                              NULL_RTX);\n+      REG_NOTES (par) = dwarf;\n+    }\n+}\n+\n /* Calculate the size of the return value that is passed in registers.  */\n static unsigned\n arm_size_return_regs (void)\n@@ -17332,9 +17609,10 @@ arm_get_frame_offsets (void)\n \t  /* If it is safe to use r3, then do so.  This sometimes\n \t     generates better code on Thumb-2 by avoiding the need to\n \t     use 32-bit push/pop instructions.  */\n- \t  if (! any_sibcall_uses_r3 ()\n+          if (! any_sibcall_uses_r3 ()\n \t      && arm_size_return_regs () <= 12\n-\t      && (offsets->saved_regs_mask & (1 << 3)) == 0)\n+\t      && (offsets->saved_regs_mask & (1 << 3)) == 0\n+              && (TARGET_THUMB2 || !current_tune->prefer_ldrd_strd))\n \t    {\n \t      reg = 3;\n \t    }\n@@ -17766,6 +18044,12 @@ arm_expand_prologue (void)\n             {\n               thumb2_emit_strd_push (live_regs_mask);\n             }\n+          else if (TARGET_ARM\n+                   && !TARGET_APCS_FRAME\n+                   && !IS_INTERRUPT (func_type))\n+            {\n+              arm_emit_strd_push (live_regs_mask);\n+            }\n           else\n             {\n               insn = emit_multi_reg_push (live_regs_mask);\n@@ -23952,6 +24236,8 @@ arm_expand_epilogue (bool really_return)\n             {\n               if (TARGET_THUMB2)\n                 thumb2_emit_ldrd_pop (saved_regs_mask);\n+              else if (TARGET_ARM && !IS_INTERRUPT (func_type))\n+                arm_emit_ldrd_pop (saved_regs_mask);\n               else\n                 arm_emit_multi_reg_pop (saved_regs_mask);\n             }"}]}