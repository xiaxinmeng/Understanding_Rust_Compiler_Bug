{"sha": "912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTEyZjJkYWNkZjI0YzVkZGUwYTVhODc5YzcwZmJkOGJhNmY0NWZhMw==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2006-01-27T22:23:32Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2006-01-27T22:23:32Z"}, "message": "re PR rtl-optimization/24762 ([killloop-branch] code motion of non-invariant expressions with hard registers.)\n\n2006-01-27  Daniel Berlin  <dberlin@dberlin.org>\n\t    Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\tPR rtl-optimization/24762 \n\t* doc/tm.texi: Added TARGET_EXTRA_LIVE_ON_ENTRY.\n\t* targhooks.c (hook_void_bitmap): New hook prototype.\n\t* targhoohs.h (hook_void_bitmap): Ditto.\n\t* bitmap.h (bitmap_head_def): Moved to coretypes.h.\n\t* coretypes.h (bitmap_head_def): Moved from bitmap.h.\n\t* target.h (live_on_entry): New function pointer.\n\t* df-scan.c (df_all_hard_regs): Removed.\n\t(df_scan_dump, df_hard_reg_init): Removed df_all_hard_regs.\n\t(df_scan_free_internal): Added df->entry_block_defs.\n\t(df_scan_alloc): Ditto.\n\t(df_scan_dump): Ditto.\n\t(df_uses_record): Plumbed flag field properly thru calls.\n\tRecord EH_RETURN_DATA_REGNO in eh blocks unconditionally.\n\tThis part fixes PR24762.\n\t(df_bb_refs_record): Added code to make the frame and arg\n\tpointers live in EH blocks.\n\t(df_refs_record): Added call to df_record_entry_block_defs.\n\t(df_record_entry_block_defs): New function.\n\t* df-core.c: Added comments to describe new artifical defs.\n\t* df.h (DF_REF_DIES_AFTER_THIS_USE): New flag in enum df_ref_flags.\n\t(entry_block_defs): New field in struct df.\n\t(df_all_hard_regs): Deleted.\n\t* target-def.h: Added TARGET_EXTRA_LIVE_ON_ENTRY.\n\t* df-problems.c (df_ru_bb_local_compute_process_def):\n\tAdded code to handle artifical defs in the entry to a function.\n\t(df_ru_bb_local_compute): Ditto.\n\t(df_rd_bb_local_compute_process_def):  Ditto.\n\t(df_rd_bb_local_compute): Ditto.\n\t(df_lr_bb_local_compute): Ditto.\n\t(df_ur_bb_local_compute): Ditto.\n\t(df_urec_bb_local_compute):  Ditto.\n\t(df_chain_create_bb):  Ditto.\n\t(df_ur_local_finalize):\tRemoved entry.\n\t(df_urec_init): Ditto.\n\t(df_urec_local_finalize): Ditto.\n\t(df_ri_bb_compute): Added detection of last use of pseudos.\n\t* Makefile.in (df-scan.o): Updated dependencies.\n\t* config/mips/mips-protos.h (mips_set_live_on_entry): Added.\n\t* config/mips/mips.c (mips_set_live_on_entry): Added.\n\t* config/mips/mips.c (TARGET_EXTRA_LIVE_ON_ENTRY): Added value\n\tfor target hook.\n\t* dce.c (marked_insn_p): Added code to handle artifical defs.\n\n\nCo-Authored-By: Kenneth Zadeck <zadeck@naturalbridge.com>\n\nFrom-SVN: r110312", "tree": {"sha": "abaa3980317c102c364cc5e69f9d31a4c7517c10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abaa3980317c102c364cc5e69f9d31a4c7517c10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7744bbe369fed74daa92a7ca77c724f5feab5f27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7744bbe369fed74daa92a7ca77c724f5feab5f27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7744bbe369fed74daa92a7ca77c724f5feab5f27"}], "stats": {"total": 628, "additions": 440, "deletions": 188}, "files": [{"sha": "867b674c2d8bec7ce5f2ec90ebd46b79a6b14806", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3", "patch": "@@ -1,3 +1,50 @@\n+2006-01-27  Daniel Berlin  <dberlin@dberlin.org>\n+\t    Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\tPR rtl-optimization/24762 \n+\t* doc/tm.texi: Added TARGET_EXTRA_LIVE_ON_ENTRY.\n+\t* targhooks.c (hook_void_bitmap): New hook prototype.\n+\t* targhoohs.h (hook_void_bitmap): Ditto.\n+\t* bitmap.h (bitmap_head_def): Moved to coretypes.h.\n+\t* coretypes.h (bitmap_head_def): Moved from bitmap.h.\n+\t* target.h (live_on_entry): New function pointer.\n+\t* df-scan.c (df_all_hard_regs): Removed.\n+\t(df_scan_dump, df_hard_reg_init): Removed df_all_hard_regs.\n+\t(df_scan_free_internal): Added df->entry_block_defs.\n+\t(df_scan_alloc): Ditto.\n+\t(df_scan_dump): Ditto.\n+\t(df_uses_record): Plumbed flag field properly thru calls.\n+\tRecord EH_RETURN_DATA_REGNO in eh blocks unconditionally.\n+\tThis part fixes PR24762.\n+\t(df_bb_refs_record): Added code to make the frame and arg\n+\tpointers live in EH blocks.\n+\t(df_refs_record): Added call to df_record_entry_block_defs.\n+\t(df_record_entry_block_defs): New function.\n+\t* df-core.c: Added comments to describe new artifical defs.\n+\t* df.h (DF_REF_DIES_AFTER_THIS_USE): New flag in enum df_ref_flags.\n+\t(entry_block_defs): New field in struct df.\n+\t(df_all_hard_regs): Deleted.\n+\t* target-def.h: Added TARGET_EXTRA_LIVE_ON_ENTRY.\n+\t* df-problems.c (df_ru_bb_local_compute_process_def):\n+\tAdded code to handle artifical defs in the entry to a function.\n+\t(df_ru_bb_local_compute): Ditto.\n+\t(df_rd_bb_local_compute_process_def):  Ditto.\n+\t(df_rd_bb_local_compute): Ditto.\n+\t(df_lr_bb_local_compute): Ditto.\n+\t(df_ur_bb_local_compute): Ditto.\n+\t(df_urec_bb_local_compute):  Ditto.\n+\t(df_chain_create_bb):  Ditto.\n+\t(df_ur_local_finalize):\tRemoved entry.\n+\t(df_urec_init): Ditto.\n+\t(df_urec_local_finalize): Ditto.\n+\t(df_ri_bb_compute): Added detection of last use of pseudos.\n+\t* Makefile.in (df-scan.o): Updated dependencies.\n+\t* config/mips/mips-protos.h (mips_set_live_on_entry): Added.\n+\t* config/mips/mips.c (mips_set_live_on_entry): Added.\n+\t* config/mips/mips.c (TARGET_EXTRA_LIVE_ON_ENTRY): Added value\n+\tfor target hook.\n+\t* dce.c (marked_insn_p): Added code to handle artifical defs.\n+\n 2006-01-27  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/emmintrin.h (_mm_cvtsd_f64): Add missing Intel"}, {"sha": "e28677ca3ce56a301e625ecd7852f1398d7f81af", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3", "patch": "@@ -2337,9 +2337,9 @@ df-problems.o : df-problems.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    hard-reg-set.h $(BASIC_BLOCK_H) $(DF_H) bitmap.h sbitmap.h $(TM_P_H) \\\n    $(FLAGS_H) output.h\n df-scan.o : df-scan.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n-   insn-config.h $(RECOG_H) $(FUNCTION_H) $(REGS_H) alloc-pool.h hard-reg-set.h \\\n-   $(BASIC_BLOCK_H) $(DF_H) bitmap.h sbitmap.h $(TM_P_H) $(FLAGS_H) \\\n-   output.h\n+   insn-config.h $(RECOG_H) $(FUNCTION_H) $(REGS_H) alloc-pool.h \\\n+   hard-reg-set.h $(BASIC_BLOCK_H) $(DF_H) bitmap.h sbitmap.h $(TM_P_H) \\\n+   $(FLAGS_H) $(TARGET_H) $(TARGET_DEF_H) $(TREE_H) output.h tree-pass.h \n var-tracking.o : var-tracking.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) hard-reg-set.h insn-config.h reload.h $(FLAGS_H) \\\n    $(BASIC_BLOCK_H) output.h sbitmap.h alloc-pool.h $(FIBHEAP_H) $(HASHTAB_H) \\"}, {"sha": "216616d0b79e04792184b31abec755ecdd0be314", "filename": "gcc/bitmap.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3", "patch": "@@ -77,8 +77,6 @@ typedef struct bitmap_head_def GTY(()) {\n } bitmap_head;\n \n \n-typedef struct bitmap_head_def *bitmap;\n-\n /* Global data */\n extern bitmap_element bitmap_zero_bits;\t/* Zero bitmap element */\n extern bitmap_obstack bitmap_default_obstack;   /* Default bitmap obstack */"}, {"sha": "59dbc64fbbfce7d6c1906cab6c9d21e976b578e6", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3", "patch": "@@ -119,6 +119,7 @@ extern bool mips_legitimate_address_p (enum machine_mode, rtx, int);\n extern rtx mips_unspec_address (rtx, enum mips_symbol_type);\n extern bool mips_legitimize_address (rtx *, enum machine_mode);\n extern bool mips_legitimize_move (enum machine_mode, rtx, rtx);\n+extern void mips_set_live_on_entry (void *);\n \n extern int m16_uimm3_b (rtx, enum machine_mode);\n extern int m16_simm4_1 (rtx, enum machine_mode);"}, {"sha": "fea14a7af40947c29d31e18afd4e1849f17a7e6e", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3", "patch": "@@ -56,6 +56,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"cfglayout.h\"\n #include \"sched-int.h\"\n #include \"tree-gimple.h\"\n+#include \"bitmap.h\"\n \n /* True if X is an unspec wrapper around a SYMBOL_REF or LABEL_REF.  */\n #define UNSPEC_ADDRESS_P(X)\t\t\t\t\t\\\n@@ -407,6 +408,7 @@ static rtx mips_expand_builtin_compare (enum mips_builtin_type,\n \t\t\t\t\trtx, tree);\n static rtx mips_expand_builtin_bposge (enum mips_builtin_type, rtx);\n static void mips_encode_section_info (tree, rtx, int);\n+static void mips_extra_live_on_entry (bitmap);\n \n /* Structure to be filled in by compute_frame_size with register\n    save masks, and offsets for the current function.  */\n@@ -1160,6 +1162,12 @@ static struct mips_rtx_cost_data const mips_rtx_cost_data[PROCESSOR_MAX] =\n #undef TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE mips_attribute_table\n \n+#undef TARGET_EXTRA_LIVE_ON_ENTRY\n+/* With -mabicalls (which is the default on GNU/Linux),\n+   PIC_FUNCTION_ADDR_REGNUM is live on function entry and is to\n+   initialize $28, which is PIC_OFFSET_TABLE_REGNUM.  */\n+#define TARGET_EXTRA_LIVE_ON_ENTRY mips_extra_live_on_entry\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Classify symbol X, which must be a SYMBOL_REF or a LABEL_REF.  */\n@@ -10764,5 +10772,16 @@ mips_encode_section_info (tree decl, rtx rtl, int first)\n       SYMBOL_REF_FLAGS (symbol) |= SYMBOL_FLAG_LONG_CALL;\n     }\n }\n+\n+/* Implement TARGET_EXTRA_LIVE_ON_ENTRY.  TARGET_ABICALLS makes\n+   PIC_FUNCTION_ADDR_REGNUM live on entry to a function.  */\n+\n+static void\n+mips_extra_live_on_entry (bitmap regs)\n+{\n+  if (!TARGET_ABICALLS)\n+    bitmap_set_bit (regs, PIC_FUNCTION_ADDR_REGNUM);\n+}\n+\n \f\n #include \"gt-mips.h\""}, {"sha": "6173bd8e8feafa98a2aee22ceceab1e9fe74f3f3", "filename": "gcc/coretypes.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3", "patch": "@@ -37,6 +37,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #ifndef USED_FOR_TARGET\n \n+struct bitmap_head_def;\n+typedef struct bitmap_head_def *bitmap;\n struct rtx_def;\n typedef struct rtx_def *rtx;\n struct rtvec_def;"}, {"sha": "416406b68f158361334153e5d4fb8ffb8ee1fe1c", "filename": "gcc/df-core.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3", "patch": "@@ -205,18 +205,23 @@ There are 4 ways to obtain access to refs:\n    defs and uses are only there if DF_HARD_REGS was specified when the\n    df instance was created.\n  \n-   Artificial defs and uses occur at the beginning blocks that are the\n-   destination of eh edges.  The defs come from the registers\n-   specified in EH_RETURN_DATA_REGNO and the uses come from the\n-   registers specified in ED_USES.  Logically these defs and uses\n-   should really occur along the eh edge, but there is no convienent\n-   way to do this.  Artificial edges that occur at the beginning of\n-   the block have the DF_REF_AT_TOP flag set.\n-   \n-   Artificial uses also occur at the end of all blocks.  These arise\n-   from the hard registers that are always live, such as the stack\n-   register and are put there to keep the code from forgetting about\n-   them.\n+   Artificial defs and uses occur both at the beginning and ends of blocks.\n+\n+     For blocks that area at the destination of eh edges, the\n+     artificial uses and defs occur at the beginning.  The defs relate\n+     to the registers specified in EH_RETURN_DATA_REGNO and the uses\n+     relate to the registers specified in ED_USES.  Logically these\n+     defs and uses should really occur along the eh edge, but there is\n+     no convenient way to do this.  Artificial edges that occur at the\n+     beginning of the block have the DF_REF_AT_TOP flag set.\n+\n+     Artificial uses occur at the end of all blocks.  These arise from\n+     the hard registers that are always live, such as the stack\n+     register and are put there to keep the code from forgetting about\n+     them.\n+\n+     Artifical defs occur at the end of the entry block.  These arise\n+     from registers that are live at entry to the function.\n \n 2) All of the uses and defs associated with each pseudo or hard\n    register are linked in a bidirectional chain.  These are called"}, {"sha": "2d3fc10e33fc17df73c6c0e854666df1da6e6413", "filename": "gcc/df-problems.c", "status": "modified", "additions": 146, "deletions": 127, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3", "patch": "@@ -298,7 +298,7 @@ struct df_ru_problem_data\n   unsigned int use_sites_size;  /* Size of use_sites.  */\n   /* The set of defs to regs invalidated by call.  */\n   bitmap sparse_invalidated_by_call;  \n-  /* The set of defs to regs invalidate by call for ru.  */  \n+  /* The set of defs to regs invalidated by call for ru.  */  \n   bitmap dense_invalidated_by_call;   \n };\n \n@@ -429,37 +429,41 @@ df_ru_alloc (struct dataflow *dflow, bitmap blocks_to_rescan)\n static void\n df_ru_bb_local_compute_process_def (struct dataflow *dflow,\n \t\t\t\t    struct df_ru_bb_info *bb_info, \n-\t\t\t\t    struct df_ref *def)\n+\t\t\t\t    struct df_ref *def,\n+\t\t\t\t    enum df_ref_flags top_flag)\n {\n   struct df *df = dflow->df;\n   while (def)\n     {\n-      unsigned int regno = DF_REF_REGNO (def);\n-      unsigned int begin = DF_REG_USE_GET (df, regno)->begin;\n-      unsigned int n_uses = DF_REG_USE_GET (df, regno)->n_refs;\n-      if (!bitmap_bit_p (seen_in_block, regno))\n+      if (top_flag == (DF_REF_FLAGS (def) & DF_REF_AT_TOP))\n \t{\n-\t  /* The first def for regno, causes the kill info to be\n-\t     generated and the gen information to cleared.  */\n-\t  if (!bitmap_bit_p (seen_in_insn, regno))\n+\t  unsigned int regno = DF_REF_REGNO (def);\n+\t  unsigned int begin = DF_REG_USE_GET (df, regno)->begin;\n+\t  unsigned int n_uses = DF_REG_USE_GET (df, regno)->n_refs;\n+\t  if (!bitmap_bit_p (seen_in_block, regno))\n \t    {\n-\t      if (n_uses > DF_SPARSE_THRESHOLD)\n-\t\t{\n-\t\t  bitmap_set_bit (bb_info->sparse_kill, regno);\n-\t\t  bitmap_clear_range (bb_info->gen, begin, n_uses);\n-\t\t}\n-\t      else\n+\t      /* The first def for regno, causes the kill info to be\n+\t\t generated and the gen information to cleared.  */\n+\t      if (!bitmap_bit_p (seen_in_insn, regno))\n \t\t{\n-\t\t  struct df_ru_problem_data *problem_data =\n-\t\t    (struct df_ru_problem_data *) dflow->problem_data;\n-\t\t  bitmap uses = \n-\t\t    df_ref_bitmap (problem_data->use_sites, regno, \n-\t\t\t\t   begin, n_uses);\n-\t\t  bitmap_ior_into (bb_info->kill, uses);\n-\t\t  bitmap_and_compl_into (bb_info->gen, uses);\n+\t\t  if (n_uses > DF_SPARSE_THRESHOLD)\n+\t\t    {\n+\t\t      bitmap_set_bit (bb_info->sparse_kill, regno);\n+\t\t      bitmap_clear_range (bb_info->gen, begin, n_uses);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      struct df_ru_problem_data * problem_data =\n+\t\t\t(struct df_ru_problem_data *)dflow->problem_data;\n+\t\t      bitmap uses = \n+\t\t\tdf_ref_bitmap (problem_data->use_sites, regno, \n+\t\t\t\t       begin, n_uses);\n+\t\t      bitmap_ior_into (bb_info->kill, uses);\n+\t\t      bitmap_and_compl_into (bb_info->gen, uses);\n+\t\t    }\n \t\t}\n+\t      bitmap_set_bit (seen_in_insn, regno);\n \t    }\n-\t  bitmap_set_bit (seen_in_insn, regno);\n \t}\n       def = def->next_ref;\n     }\n@@ -508,11 +512,9 @@ df_ru_bb_local_compute (struct dataflow *dflow, unsigned int bb_index)\n \t\t\t\t      df_get_artificial_uses (df, bb_index),\n \t\t\t\t      DF_REF_AT_TOP);\n #endif\n-\n-  /* Process the artificial defs first since these are at the top of\n-     the block.  */\n   df_ru_bb_local_compute_process_def (dflow, bb_info, \n-\t\t\t\t      df_get_artificial_defs (df, bb_index));\n+\t\t\t\t      df_get_artificial_defs (df, bb_index),\n+\t\t\t\t      DF_REF_AT_TOP);\n \n   FOR_BB_INSNS (bb, insn)\n     {\n@@ -521,7 +523,7 @@ df_ru_bb_local_compute (struct dataflow *dflow, unsigned int bb_index)\n \tcontinue;\n \n       df_ru_bb_local_compute_process_def (dflow, bb_info, \n-\t\t\t\t\t  DF_INSN_UID_GET (df, uid)->defs);\n+\t\t\t\t\t  DF_INSN_UID_GET (df, uid)->defs, 0);\n \n       /* The use processing must happen after the defs processing even\n \t though the uses logically happen first since the defs clear\n@@ -537,6 +539,9 @@ df_ru_bb_local_compute (struct dataflow *dflow, unsigned int bb_index)\n   /* Process the hardware registers that are always live.  */\n   df_ru_bb_local_compute_process_use (bb_info, \n \t\t\t\t      df_get_artificial_uses (df, bb_index), 0);\n+\n+  df_ru_bb_local_compute_process_def (dflow, bb_info, \n+\t\t\t\t      df_get_artificial_defs (df, bb_index), 0);\n }\n \n \n@@ -948,45 +953,49 @@ df_rd_alloc (struct dataflow *dflow, bitmap blocks_to_rescan)\n static void\n df_rd_bb_local_compute_process_def (struct dataflow *dflow,\n \t\t\t\t    struct df_rd_bb_info *bb_info, \n-\t\t\t\t    struct df_ref *def)\n+\t\t\t\t    struct df_ref *def,\n+\t\t\t\t    enum df_ref_flags top_flag)\n {\n   struct df *df = dflow->df;\n   while (def)\n     {\n-      unsigned int regno = DF_REF_REGNO (def);\n-      unsigned int begin = DF_REG_DEF_GET (df, regno)->begin;\n-      unsigned int n_defs = DF_REG_DEF_GET (df, regno)->n_refs;\n-      \n-      /* Only the last def(s) for a regno in the block has any\n-\t effect.  */ \n-      if (!bitmap_bit_p (seen_in_block, regno))\n+      if (top_flag == (DF_REF_FLAGS (def) & DF_REF_AT_TOP))\n \t{\n-\t  /* The first def for regno in insn gets to knock out the\n-\t     defs from other instructions.  */\n-\t  if (!bitmap_bit_p (seen_in_insn, regno))\n+\t  unsigned int regno = DF_REF_REGNO (def);\n+\t  unsigned int begin = DF_REG_DEF_GET (df, regno)->begin;\n+\t  unsigned int n_defs = DF_REG_DEF_GET (df, regno)->n_refs;\n+\t  \n+\t  /* Only the last def(s) for a regno in the block has any\n+\t     effect.  */ \n+\t  if (!bitmap_bit_p (seen_in_block, regno))\n \t    {\n-\t      if (n_defs > DF_SPARSE_THRESHOLD)\n-\t\t{\n-\t\t  bitmap_set_bit (bb_info->sparse_kill, regno);\n-\t\t  bitmap_clear_range (bb_info->gen, begin, n_defs);\n-\t\t}\n-\t      else\n+\t      /* The first def for regno in insn gets to knock out the\n+\t\t defs from other instructions.  */\n+\t      if (!bitmap_bit_p (seen_in_insn, regno))\n \t\t{\n-\t\t  struct df_rd_problem_data *problem_data =\n-\t\t    (struct df_rd_problem_data *) dflow->problem_data;\n-\t\t  bitmap defs = \n-\t\t    df_ref_bitmap (problem_data->def_sites, regno, \n-\t\t\t\t   begin, n_defs);\n-\t\t  bitmap_ior_into (bb_info->kill, defs);\n-\t\t  bitmap_and_compl_into (bb_info->gen, defs);\n+\t\t  if (n_defs > DF_SPARSE_THRESHOLD)\n+\t\t    {\n+\t\t      bitmap_set_bit (bb_info->sparse_kill, regno);\n+\t\t      bitmap_clear_range(bb_info->gen, begin, n_defs);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      struct df_rd_problem_data * problem_data =\n+\t\t\t(struct df_rd_problem_data *)dflow->problem_data;\n+\t\t      bitmap defs = \n+\t\t\tdf_ref_bitmap (problem_data->def_sites, regno, \n+\t\t\t\t       begin, n_defs);\n+\t\t      bitmap_ior_into (bb_info->kill, defs);\n+\t\t      bitmap_and_compl_into (bb_info->gen, defs);\n+\t\t    }\n \t\t}\n+\t      \n+\t      bitmap_set_bit (seen_in_insn, regno);\n+\t      /* All defs for regno in the instruction may be put into\n+\t\t the gen set.  */\n+\t      if (! (DF_REF_FLAGS (def) & DF_REF_CLOBBER))\n+\t\tbitmap_set_bit (bb_info->gen, DF_REF_ID (def));\n \t    }\n-\t  \n-\t  bitmap_set_bit (seen_in_insn, regno);\n-\t  /* All defs for regno in the instruction may be put into\n-\t     the gen set.  */\n-\t  if (! (DF_REF_FLAGS (def) & DF_REF_CLOBBER))\n-\t    bitmap_set_bit (bb_info->gen, DF_REF_ID (def));\n \t}\n       def = def->next_ref;\n     }\n@@ -1005,6 +1014,9 @@ df_rd_bb_local_compute (struct dataflow *dflow, unsigned int bb_index)\n   bitmap_clear (seen_in_block);\n   bitmap_clear (seen_in_insn);\n \n+  df_rd_bb_local_compute_process_def (dflow, bb_info, \n+\t\t\t\t      df_get_artificial_defs (df, bb_index), 0);\n+\n   FOR_BB_INSNS_REVERSE (bb, insn)\n     {\n       unsigned int uid = INSN_UID (insn);\n@@ -1013,7 +1025,7 @@ df_rd_bb_local_compute (struct dataflow *dflow, unsigned int bb_index)\n \tcontinue;\n \n       df_rd_bb_local_compute_process_def (dflow, bb_info, \n-\t\t\t\t\t  DF_INSN_UID_GET (df, uid)->defs);\n+\t\t\t\t\t  DF_INSN_UID_GET (df, uid)->defs, 0);\n \n       /* This complex dance with the two bitmaps is required because\n \t instructions can assign twice to the same pseudo.  This\n@@ -1025,10 +1037,12 @@ df_rd_bb_local_compute (struct dataflow *dflow, unsigned int bb_index)\n       bitmap_clear (seen_in_insn);\n     }\n \n-  /* Process the artificial defs last since we are going backwards\n-     thur the block and these are logically at the start.  */\n+  /* Process the artificial defs at the top of the block last since we\n+     are going backwards through the block and these are logically at\n+     the start.  */\n   df_rd_bb_local_compute_process_def (dflow, bb_info, \n-\t\t\t\t      df_get_artificial_defs (df, bb_index));\n+\t\t\t\t      df_get_artificial_defs (df, bb_index),\n+\t\t\t\t      DF_REF_AT_TOP);\n }\n \n \n@@ -1395,6 +1409,15 @@ df_lr_bb_local_compute (struct dataflow *dflow,\n   struct df_ref *def;\n   struct df_ref *use;\n \n+  /* Process the registers set in an exception handler.  */\n+  for (def = df_get_artificial_defs (df, bb_index); def; def = def->next_ref)\n+    if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP) == 0)\n+      {\n+\tunsigned int dregno = DF_REF_REGNO (def);\n+\tbitmap_set_bit (bb_info->def, dregno);\n+\tbitmap_clear_bit (bb_info->use, dregno);\n+      }\n+\n   /* Process the hardware registers that are always live.  */\n   for (use = df_get_artificial_uses (df, bb_index); use; use = use->next_ref)\n     /* Add use to set of uses in this BB.  */\n@@ -1455,12 +1478,13 @@ df_lr_bb_local_compute (struct dataflow *dflow,\n \n   /* Process the registers set in an exception handler.  */\n   for (def = df_get_artificial_defs (df, bb_index); def; def = def->next_ref)\n-    {\n-      unsigned int dregno = DF_REF_REGNO (def);\n-      bitmap_set_bit (bb_info->def, dregno);\n-      bitmap_clear_bit (bb_info->use, dregno);\n-    }\n-\n+    if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n+      {\n+\tunsigned int dregno = DF_REF_REGNO (def);\n+\tbitmap_set_bit (bb_info->def, dregno);\n+\tbitmap_clear_bit (bb_info->use, dregno);\n+      }\n+  \n #ifdef EH_USES\n   /* Process the uses that are live into an exception handler.  */\n   for (use = df_get_artificial_uses (df, bb_index); use; use = use->next_ref)\n@@ -1783,6 +1807,17 @@ df_ur_bb_local_compute (struct dataflow *dflow, unsigned int bb_index)\n   bitmap_clear (seen_in_block);\n   bitmap_clear (seen_in_insn);\n \n+  for (def = df_get_artificial_defs (df, bb_index); def; def = def->next_ref)\n+    if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP) == 0)\n+      {\n+\tunsigned int regno = DF_REF_REGNO (def);\n+\tif (!bitmap_bit_p (seen_in_block, regno))\n+\t  {\n+\t    bitmap_set_bit (seen_in_block, regno);\n+\t    bitmap_set_bit (bb_info->gen, regno);\n+\t  }\n+      }\n+\n   FOR_BB_INSNS_REVERSE (bb, insn)\n     {\n       unsigned int uid = INSN_UID (insn);\n@@ -1808,14 +1843,15 @@ df_ur_bb_local_compute (struct dataflow *dflow, unsigned int bb_index)\n     }\n \n   for (def = df_get_artificial_defs (df, bb_index); def; def = def->next_ref)\n-    {\n-      unsigned int regno = DF_REF_REGNO (def);\n-      if (!bitmap_bit_p (seen_in_block, regno))\n-\t{\n-\t  bitmap_set_bit (seen_in_block, regno);\n-\t  bitmap_set_bit (bb_info->gen, regno);\n-\t}\n-    }\n+    if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n+      {\n+\tunsigned int regno = DF_REF_REGNO (def);\n+\tif (!bitmap_bit_p (seen_in_block, regno))\n+\t  {\n+\t    bitmap_set_bit (seen_in_block, regno);\n+\t    bitmap_set_bit (bb_info->gen, regno);\n+\t  }\n+      }\n }\n \n \n@@ -1875,9 +1911,6 @@ df_ur_local_finalize (struct dataflow *dflow, bitmap all_blocks)\n       struct df_ur_bb_info *bb_info = df_ur_get_bb_info (dflow, bb_index);\n       struct df_lr_bb_info *bb_lr_info = df_lr_get_bb_info (lr_dflow, bb_index);\n       \n-      bitmap_ior_into (bb_info->in, df_all_hard_regs);\n-      bitmap_ior_into (bb_info->out, df_all_hard_regs);\n-\n       /* No register may reach a location where it is not used.  Thus\n \t we trim the rr result to the places where it is used.  */\n       bitmap_and_into (bb_info->in, bb_lr_info->in);\n@@ -2336,11 +2369,12 @@ df_urec_bb_local_compute (struct dataflow *dflow, unsigned int bb_index)\n   struct df_ref *def;\n \n   for (def = df_get_artificial_defs (df, bb_index); def; def = def->next_ref)\n-    {\n-      unsigned int regno = DF_REF_REGNO (def);\n-      bitmap_set_bit (bb_info->gen, regno);\n-    }\n-\n+    if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n+      {\n+\tunsigned int regno = DF_REF_REGNO (def);\n+\tbitmap_set_bit (bb_info->gen, regno);\n+      }\n+  \n   FOR_BB_INSNS (bb, insn)\n     {\n       if (INSN_P (insn))\n@@ -2357,6 +2391,14 @@ df_urec_bb_local_compute (struct dataflow *dflow, unsigned int bb_index)\n \t    }\n \t}\n     }\n+\n+  for (def = df_get_artificial_defs (df, bb_index); def; def = def->next_ref)\n+    if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP) == 0)\n+      {\n+\tunsigned int regno = DF_REF_REGNO (def);\n+\tbitmap_set_bit (bb_info->gen, regno);\n+      }\n+\n }\n \n \n@@ -2424,32 +2466,8 @@ df_urec_init (struct dataflow *dflow, bitmap all_blocks)\n     {\n       struct df_urec_bb_info *bb_info = df_urec_get_bb_info (dflow, bb_index);\n \n-      /* FIXME: This is a hack, it has been copied over from\n-\t make_accurate_live_analysis by Vlad.  Most likely it is necessary\n-\t because the generation of gen and kill information for hardware\n-\t registers in ur is a subset of what is really necessary and what\n-\t is done for the lr problem.  */\n-      \n-      /* Inside the register allocator, partial availability is only\n-\t allowed for the psuedo registers.  To implement this, the rr is\n-\t initially iored with a mask ones for the hard registers and zeros\n-\t for the pseudos before being iterated.  This means that each\n-\t hardware register will be live unless explicitly killed by some\n-\t statement.  Eventually most of these bit will die because the\n-\t results of rr are anded with the results of lr before being used.\n-\t Outside of register allocation, a more conservative strategy of\n-\t completely ignoring the unintialized registers is imployed in the\n-\t finalizer function.  */\n-      if (df_state & DF_SCAN_GLOBAL)\n-\t{\n-\t  bitmap_ior (bb_info->out, bb_info->gen, df_all_hard_regs);\n-\t  bitmap_copy (bb_info->in, df_all_hard_regs);\n-\t}\n-      else\n-\t{\n-\t  bitmap_copy (bb_info->out, bb_info->gen);\n-\t  bitmap_clear (bb_info->in);\n-\t}\n+      bitmap_copy (bb_info->out, bb_info->gen);\n+      bitmap_clear (bb_info->in);\n     }\n }\n \n@@ -2489,12 +2507,6 @@ df_urec_local_finalize (struct dataflow *dflow, bitmap all_blocks)\n #endif\n \t}\n \n-      if (!(df_state & DF_SCAN_GLOBAL))\n-\t{\n-\t  bitmap_ior_into (bb_info->in, df_all_hard_regs);\n-\t  bitmap_ior_into (bb_info->out, df_all_hard_regs);\n-\t}\n-\n       /* No register may reach a location where it is not used.  Thus\n \t we trim the rr result to the places where it is used.  */\n       bitmap_and_into (bb_info->in, bb_lr_info->in);\n@@ -2830,7 +2842,7 @@ df_chain_create_bb_process_use (struct dataflow *dflow,\n   \n   while (use)\n     {\n-      /* Do not want to go thur this for an uninitialized var.  */\n+      /* Do not want to go through this for an uninitialized var.  */\n       unsigned int uregno = DF_REF_REGNO (use);\n       int count = DF_REG_DEF_GET (df, uregno)->n_refs;\n       if (count)\n@@ -2891,14 +2903,15 @@ df_chain_create_bb (struct dataflow *dflow,\n #endif\n \n   for (def = df_get_artificial_defs (df, bb_index); def; def = def->next_ref)\n-    {\n-      unsigned int dregno = DF_REF_REGNO (def);\n-      bitmap_clear_range (cpy, \n-\t\t\t  DF_REG_DEF_GET (df, dregno)->begin, \n-\t\t\t  DF_REG_DEF_GET (df, dregno)->n_refs);\n-      if (! (DF_REF_FLAGS (def) & DF_REF_CLOBBER))\n-\tbitmap_set_bit (cpy, DF_REF_ID (def));\n-    }\n+    if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n+      {\n+\tunsigned int dregno = DF_REF_REGNO (def);\n+\tbitmap_clear_range (cpy, \n+\t\t\t    DF_REG_DEF_GET (df, dregno)->begin, \n+\t\t\t    DF_REG_DEF_GET (df, dregno)->n_refs);\n+\tif (! (DF_REF_FLAGS (def) & DF_REF_CLOBBER))\n+\t  bitmap_set_bit (cpy, DF_REF_ID (def));\n+      }\n   \n   /* Process the regular instructions next.  */\n   FOR_BB_INSNS (bb, insn)\n@@ -3136,8 +3149,14 @@ df_ri_bb_compute (struct dataflow *dflow, unsigned int bb_index, bitmap live)\n \t{\n \t  unsigned int uregno = DF_REF_REGNO (use);\n \n-\t  /* This register is now live.  */\n-\t  bitmap_set_bit (live, uregno);\n+\t  if (!bitmap_bit_p (live, uregno))\n+\t    {\n+\t      use->flags |= DF_REF_DIES_AFTER_THIS_USE;\n+\t      /* This register is now live.  */\n+\t      bitmap_set_bit (live, uregno);\n+\t    }\n+\t  else\n+\t    use->flags &= ~DF_REF_DIES_AFTER_THIS_USE;\n \t}\n \n       /* Increment lifetimes of all live registers.  */"}, {"sha": "affc6df739ef4e4837dc269feb34291edbe8855f", "filename": "gcc/df-scan.c", "status": "modified", "additions": 169, "deletions": 40, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3", "patch": "@@ -46,6 +46,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"sbitmap.h\"\n #include \"bitmap.h\"\n #include \"timevar.h\"\n+#include \"tree.h\"\n+#include \"target.h\"\n+#include \"target-def.h\"\n #include \"df.h\"\n \n #ifndef HAVE_epilogue\n@@ -82,8 +85,6 @@ bitmap df_invalidated_by_call = NULL;\n /* Initialize ur_in and ur_out as if all hard registers were partially\n    available.  */\n \n-bitmap df_all_hard_regs = NULL;\n-\n static void df_ref_record (struct dataflow *, rtx, rtx *, \n \t\t\t   basic_block, rtx, enum df_ref_type,\n \t\t\t   enum df_ref_flags, bool record_live);\n@@ -99,6 +100,7 @@ static void df_refs_record (struct dataflow *, bitmap);\n static struct df_ref *df_ref_create_structure (struct dataflow *, rtx, rtx *, \n \t\t\t\t\t       basic_block, rtx, enum df_ref_type, \n \t\t\t\t\t       enum df_ref_flags);\n+static void df_record_entry_block_defs (struct dataflow *);\n static void df_record_exit_block_uses (struct dataflow *);\n static void df_grow_reg_info (struct dataflow *, struct df_ref_info *);\n static void df_grow_ref_info (struct df_ref_info *, unsigned int);\n@@ -148,6 +150,7 @@ df_scan_free_internal (struct dataflow *dflow)\n   dflow->block_info_size = 0;\n \n   BITMAP_FREE (df->hardware_regs_used);\n+  BITMAP_FREE (df->entry_block_defs);\n   BITMAP_FREE (df->exit_block_uses);\n \n   free_alloc_pool (dflow->block_pool);\n@@ -252,6 +255,7 @@ df_scan_alloc (struct dataflow *dflow, bitmap blocks_to_rescan)\n     }\n \n   df->hardware_regs_used = BITMAP_ALLOC (NULL);\n+  df->entry_block_defs = BITMAP_ALLOC (NULL);\n   df->exit_block_uses = BITMAP_ALLOC (NULL);\n }\n \n@@ -284,12 +288,12 @@ df_scan_dump (struct dataflow *dflow ATTRIBUTE_UNUSED, FILE *file ATTRIBUTE_UNUS\n   struct df *df = dflow->df;\n   int i;\n \n-  fprintf (file, \"  all hard regs \\t\");\n-  dump_bitmap (file, df_all_hard_regs);\n   fprintf (file, \"  invalidated by call \\t\");\n   dump_bitmap (file, df_invalidated_by_call);\n   fprintf (file, \"  hardware regs used \\t\");\n   dump_bitmap (file, df->hardware_regs_used);\n+  fprintf (file, \"  entry block uses \\t\");\n+  dump_bitmap (file, df->entry_block_defs);\n   fprintf (file, \"  exit block uses \\t\");\n   dump_bitmap (file, df->exit_block_uses);\n   fprintf (file, \"  regs ever live \\t\");\n@@ -1247,7 +1251,7 @@ df_uses_record (struct dataflow *dflow, rtx *loc, enum df_ref_type ref_type,\n       {\n \trtx dst = SET_DEST (x);\n \tgcc_assert (!(flags & DF_REF_IN_NOTE));\n-\tdf_uses_record (dflow, &SET_SRC (x), DF_REF_REG_USE, bb, insn, 0);\n+\tdf_uses_record (dflow, &SET_SRC (x), DF_REF_REG_USE, bb, insn, flags);\n \n \tswitch (GET_CODE (dst))\n \t  {\n@@ -1256,7 +1260,7 @@ df_uses_record (struct dataflow *dflow, rtx *loc, enum df_ref_type ref_type,\n \t\t{\n \t\t  df_uses_record (dflow, &SUBREG_REG (dst), \n \t\t\t\t  DF_REF_REG_USE, bb,\n-\t\t\t\t  insn, DF_REF_READ_WRITE);\n+\t\t\t\t  insn, flags | DF_REF_READ_WRITE);\n \t\t  break;\n \t\t}\n \t      /* Fall through.  */\n@@ -1269,7 +1273,7 @@ df_uses_record (struct dataflow *dflow, rtx *loc, enum df_ref_type ref_type,\n \t    case MEM:\n \t      df_uses_record (dflow, &XEXP (dst, 0),\n \t\t\t      DF_REF_REG_MEM_STORE,\n-\t\t\t      bb, insn, 0);\n+\t\t\t      bb, insn, flags);\n \t      break;\n \t    case STRICT_LOW_PART:\n \t      {\n@@ -1290,9 +1294,9 @@ df_uses_record (struct dataflow *dflow, rtx *loc, enum df_ref_type ref_type,\n \t\t\t      DF_REF_REG_USE, bb, insn,\n \t\t\t      DF_REF_READ_WRITE);\n \t      df_uses_record (dflow, &XEXP (dst, 1), \n-\t\t\t      DF_REF_REG_USE, bb, insn, 0);\n+\t\t\t      DF_REF_REG_USE, bb, insn, flags);\n \t      df_uses_record (dflow, &XEXP (dst, 2), \n-\t\t\t      DF_REF_REG_USE, bb, insn, 0);\n+\t\t\t      DF_REF_REG_USE, bb, insn, flags);\n \t      dst = XEXP (dst, 0);\n \t      break;\n \t    default:\n@@ -1342,7 +1346,7 @@ df_uses_record (struct dataflow *dflow, rtx *loc, enum df_ref_type ref_type,\n \n \t    for (j = 0; j < ASM_OPERANDS_INPUT_LENGTH (x); j++)\n \t      df_uses_record (dflow, &ASM_OPERANDS_INPUT (x, j),\n-\t\t\t      DF_REF_REG_USE, bb, insn, 0);\n+\t\t\t      DF_REF_REG_USE, bb, insn, flags);\n \t    return;\n \t  }\n \tbreak;\n@@ -1355,8 +1359,9 @@ df_uses_record (struct dataflow *dflow, rtx *loc, enum df_ref_type ref_type,\n     case PRE_MODIFY:\n     case POST_MODIFY:\n       /* Catch the def of the register being modified.  */\n+      flags |= DF_REF_READ_WRITE;\n       df_ref_record (dflow, XEXP (x, 0), &XEXP (x, 0), bb, insn, \n-\t\t     DF_REF_REG_DEF, DF_REF_READ_WRITE, true);\n+\t\t     DF_REF_REG_DEF, flags, true);\n \n       /* ... Fall through to handle uses ...  */\n \n@@ -1562,41 +1567,65 @@ df_bb_refs_record (struct dataflow *dflow, basic_block bb)\n     {\n       unsigned int i;\n       /* Mark the registers that will contain data for the handler.  */\n-      if (current_function_calls_eh_return)\n-\tfor (i = 0; ; ++i)\n-\t  {\n-\t    unsigned regno = EH_RETURN_DATA_REGNO (i);\n-\t    if (regno == INVALID_REGNUM)\n-\t      break;\n-\t    df_ref_record (dflow, regno_reg_rtx[i], &regno_reg_rtx[i], bb, NULL, \n-\t\t           DF_REF_REG_DEF, DF_REF_ARTIFICIAL | DF_REF_AT_TOP, false);\n-\t  }\n+      for (i = 0; ; ++i)\n+\t{\n+\t  unsigned regno = EH_RETURN_DATA_REGNO (i);\n+\t  if (regno == INVALID_REGNUM)\n+\t    break;\n+\t  df_ref_record (dflow, regno_reg_rtx[i], &regno_reg_rtx[i], bb, NULL,\n+\t\t\t DF_REF_REG_DEF, DF_REF_ARTIFICIAL | DF_REF_AT_TOP,\n+\t\t\t false);\n+\t}\n     }\n #endif\n \n-#ifdef EH_USES\n-  /*  This code is putting in a artificial ref for the use at the TOP\n-      of the block that receives the exception.  It is too cumbersome\n-      to actually put the ref on the edge.  We could either model this\n-      at the top of the receiver block or the bottom of the sender\n-      block.\n-\n-      The bottom of the sender block is problematic because not all\n-      out-edges of the a block are eh-edges.  However, it is true that\n-      all edges into a block are either eh-edges or none of them are\n-      eh-edges.  Thus, we can model this at the top of the eh-receiver\n-      for all of the edges at once. */\n+\n   if ((df->flags & DF_HARD_REGS)\n       && df_has_eh_preds (bb))\n     {\n+#ifdef EH_USES\n       unsigned int i;\n+      /* This code is putting in a artificial ref for the use at the\n+\t TOP of the block that receives the exception.  It is too\n+\t cumbersome to actually put the ref on the edge.  We could\n+\t either model this at the top of the receiver block or the\n+\t bottom of the sender block.\n+\n+         The bottom of the sender block is problematic because not all\n+         out-edges of the a block are eh-edges.  However, it is true\n+         that all edges into a block are either eh-edges or none of\n+         them are eh-edges.  Thus, we can model this at the top of the\n+         eh-receiver for all of the edges at once. */\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (EH_USES (i))\n \t  df_uses_record (dflow, &regno_reg_rtx[i], \n-\t\t\t\t   DF_REF_REG_USE, EXIT_BLOCK_PTR, NULL,\n-\t\t\t\t   DF_REF_ARTIFICIAL | DF_REF_AT_TOP);\n-    }\n+\t\t\t  DF_REF_REG_USE, EXIT_BLOCK_PTR, NULL,\n+\t\t\t  DF_REF_ARTIFICIAL | DF_REF_AT_TOP);\n+#endif\n+\n+      /* The following code (down thru the arg_pointer seting APPEARS\n+\t to be necessary because there is nothing that actually\n+\t describes what the exception handling code may actually need\n+\t to keep alive.  */\n+      if (reload_completed)\n+\t{\n+\t  if (frame_pointer_needed)\n+\t    {\n+\t      df_uses_record (dflow, &regno_reg_rtx[FRAME_POINTER_REGNUM],\n+\t\t\t      DF_REF_REG_USE, bb, NULL, DF_REF_ARTIFICIAL);\n+#if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n+\t      df_uses_record (dflow, &regno_reg_rtx[HARD_FRAME_POINTER_REGNUM],\n+\t\t\t      DF_REF_REG_USE, bb, NULL, DF_REF_ARTIFICIAL);\n+#endif\n+\t    }\n+#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n+\t  if (fixed_regs[ARG_POINTER_REGNUM])\n+\t    df_uses_record (dflow, &regno_reg_rtx[ARG_POINTER_REGNUM],\n+\t\t\t    DF_REF_REG_USE, bb, NULL, \n+\t\t\t    DF_REF_ARTIFICIAL);\n #endif\n+\t}\n+    }\n \n   if ((df->flags & DF_HARD_REGS) \n       && bb->index >= NUM_FIXED_BLOCKS)\n@@ -1652,6 +1681,9 @@ df_refs_record (struct dataflow *dflow, bitmap blocks)\n \n   if (bitmap_bit_p (blocks, EXIT_BLOCK))\n     df_record_exit_block_uses (dflow);\n+\n+  if (bitmap_bit_p (blocks, ENTRY_BLOCK))\n+    df_record_entry_block_defs (dflow);\n }\n \n \n@@ -1679,6 +1711,108 @@ df_mark_reg (rtx reg, void *vset)\n     }\n }\n \n+\n+/* Record the (conservative) set of hard registers that are defined on\n+   entry to the function.  */\n+\n+static void\n+df_record_entry_block_defs (struct dataflow * dflow)\n+{\n+  unsigned int i; \n+  bitmap_iterator bi;\n+  rtx r;\n+  struct df * df = dflow->df;\n+\n+  bitmap_clear (df->entry_block_defs);\n+\n+  if (! (df->flags & DF_HARD_REGS))\n+    return;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      if (FUNCTION_ARG_REGNO_P (i))\n+#ifdef INCOMING_REGNO\n+\tbitmap_set_bit (df->entry_block_defs, INCOMING_REGNO (i));\n+#else\n+\tbitmap_set_bit (df->entry_block_defs, i);\n+#endif\n+    }\n+      \n+  /* Once the prologue has been generated, all of these registers\n+     should just show up in the first regular block.  */\n+  if (HAVE_prologue && epilogue_completed)\n+    {\n+      /* Defs for the callee saved registers are inserted so that the\n+\t pushes have some defining location.  */\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif ((call_used_regs[i] == 0) && (regs_ever_live[i]))\n+\t  bitmap_set_bit (df->entry_block_defs, i);\n+    }\n+  else\n+    {\n+      if (REG_P (INCOMING_RETURN_ADDR_RTX))\n+\tbitmap_set_bit (df->entry_block_defs, REGNO (INCOMING_RETURN_ADDR_RTX));\n+            \n+      /* If STATIC_CHAIN_INCOMING_REGNUM == STATIC_CHAIN_REGNUM\n+\t only STATIC_CHAIN_REGNUM is defined.  If they are different,\n+\t we only care about the STATIC_CHAIN_INCOMING_REGNUM.  */\n+#ifdef STATIC_CHAIN_INCOMING_REGNUM\n+      bitmap_set_bit (df->entry_block_defs, STATIC_CHAIN_INCOMING_REGNUM);\n+#else \n+#ifdef STATIC_CHAIN_REGNUM\n+      bitmap_set_bit (df->entry_block_defs, STATIC_CHAIN_REGNUM);\n+#endif\n+#endif\n+      \n+      r = TARGET_STRUCT_VALUE_RTX (current_function_decl, true);\n+      if (r && REG_P (r))\n+\tbitmap_set_bit (df->entry_block_defs, REGNO (r));\n+    }\n+\n+  /* These registers are live everywhere.  */\n+  if (!reload_completed)\n+    {\n+      /* Any reference to any pseudo before reload is a potential\n+\t reference of the frame pointer.  */\n+      bitmap_set_bit (df->entry_block_defs, FRAME_POINTER_REGNUM);\n+\n+#ifdef EH_USES\n+      /* The ia-64, the only machine that uses this, does not define these \n+\t until after reload.  */\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (EH_USES (i))\n+\t  {\n+\t    bitmap_set_bit (df->entry_block_defs, i);\n+\t  }\n+#endif\n+      \n+#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n+      /* Pseudos with argument area equivalences may require\n+\t reloading via the argument pointer.  */\n+      if (fixed_regs[ARG_POINTER_REGNUM])\n+\tbitmap_set_bit (df->entry_block_defs, ARG_POINTER_REGNUM);\n+#endif\n+\t  \n+#ifdef PIC_OFFSET_TABLE_REGNUM\n+      /* Any constant, or pseudo with constant equivalences, may\n+\t require reloading from memory using the pic register.  */\n+      if ((unsigned) PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM\n+\t  && fixed_regs[PIC_OFFSET_TABLE_REGNUM])\n+\tbitmap_set_bit (df->entry_block_defs, PIC_OFFSET_TABLE_REGNUM);\n+#endif\n+    }\n+\n+  (*targetm.live_on_entry) (df->entry_block_defs);\n+\n+  EXECUTE_IF_SET_IN_BITMAP (df->entry_block_defs, 0, i, bi)\n+    {\n+      df_ref_record (dflow, regno_reg_rtx[i], &regno_reg_rtx[i], \n+\t\t     ENTRY_BLOCK_PTR, NULL, \n+\t\t     DF_REF_REG_DEF, DF_REF_ARTIFICIAL , false);\n+    }\n+}\n+\n+\n /* Record the set of hard registers that are used in the exit block.  */\n \n static void\n@@ -1827,10 +1961,5 @@ df_hard_reg_init (void)\n     if (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n       bitmap_set_bit (df_invalidated_by_call, i);\n   \n-  df_all_hard_regs = BITMAP_ALLOC (&persistent_obstack);\n-  \n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    bitmap_set_bit (df_all_hard_regs, i);\n-  \n   initialized = true;\n }"}, {"sha": "8c5108e3693f8c049cd4467592960e8293790c11", "filename": "gcc/df.h", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3", "patch": "@@ -211,7 +211,12 @@ enum df_ref_flags\n     DF_REF_IN_NOTE = 16,\n \n     /* This flag is set if this ref is really a clobber, and not a def.  */\n-    DF_REF_CLOBBER = 32\n+    DF_REF_CLOBBER = 32,\n+\n+    /* True if ref is dead (i.e. the next ref is a def or clobber or\n+       the end of the function.)  This is only valid the RI problem\n+       has been set in this df instance.  */\n+    DF_REF_DIES_AFTER_THIS_USE = 64\n   };\n \n \n@@ -223,7 +228,10 @@ struct df_ref\n   rtx reg;\t\t\t/* The register referenced.  */\n   unsigned int regno;           /* The register number referenced.  */\n   basic_block bb;               /* Basic block containing the instruction. */\n-  rtx insn;\t\t\t/* Insn containing ref.  NB: THIS MAY BE NULL.  */\n+\n+  /* Insn containing ref. This will be null if this is an artificial\n+     reference.  */\n+  rtx insn;\n   rtx *loc;\t\t\t/* The location of the reg.  */\n   struct df_link *chain;\t/* Head of def-use, use-def.  */\n   unsigned int id;\t\t/* Location in table.  */\n@@ -316,6 +324,7 @@ struct df\n   struct df_insn_info **insns;   /* Insn table, indexed by insn UID.  */\n   unsigned int insns_size;       /* Size of insn table.  */\n   bitmap hardware_regs_used;     /* The set of hardware registers used.  */\n+  bitmap entry_block_defs;       /* The set of hardware registers live on entry to the function.  */\n   bitmap exit_block_uses;        /* The set of hardware registers used in exit block.  */\n };\n \n@@ -422,8 +431,6 @@ extern bitmap df_invalidated_by_call;\n /* Initialize ur_in and ur_out as if all hard registers were partially\n available.  */\n \n-extern bitmap df_all_hard_regs;\n-\n /* The way that registers are processed, especially hard registers,\n    changes as the compilation proceeds. These states are passed to\n    df_set_state to control this processing.  */"}, {"sha": "d60fc13c476cea999957402c53b702cdc5788ade", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3", "patch": "@@ -4481,6 +4481,15 @@ as the @code{sibcall} md pattern can not fail, or fall over to a\n may vary greatly between different architectures.\n @end deftypefn\n \n+@deftypefn {Target Hook} void TARGET_EXTRA_LIVE_ON_ENTRY (bitmap *@var{regs})\n+Add any hard registers to @var{regs} that are live on entry to the\n+function.  This hook only needs to be defined to provide registers that\n+cannot be found by examination of FUNCTION_ARG_REGNO_P, the callee saved\n+registers, STATIC_CHAIN_INCOMING_REGNUM, STATIC_CHAIN_REGNUM,\n+TARGET_STRUCT_VALUE_RTX, FRAME_POINTER_REGNUM, EH_USES,\n+FRAME_POINTER_REGNUM, ARG_POINTER_REGNUM, and the PIC_OFFSET_TABLE_REGNUM.\n+@end deftypefn\n+\n @node Stack Smashing Protection\n @subsection Stack smashing protection\n @cindex stack smashing protection"}, {"sha": "759910149d38aa86767782f6372ab5e3f91dc1a6", "filename": "gcc/target-def.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3", "patch": "@@ -185,6 +185,10 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n #define TARGET_ASM_FILE_END hook_void_void\n #endif\n \n+#ifndef TARGET_EXTRA_LIVE_ON_ENTRY\n+#define TARGET_EXTRA_LIVE_ON_ENTRY hook_void_bitmap\n+#endif\n+\n #ifndef TARGET_ASM_FILE_START_APP_OFF\n #define TARGET_ASM_FILE_START_APP_OFF false\n #endif\n@@ -625,6 +629,7 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n   TARGET_INVALID_BINARY_OP,\t\t\t\\\n   TARGET_SECONDARY_RELOAD,\t\t\t\\\n   TARGET_CXX,\t\t\t\t\t\\\n+  TARGET_EXTRA_LIVE_ON_ENTRY,                    \\\n   TARGET_UNWIND_TABLES_DEFAULT,\t\t\t\\\n   TARGET_HAVE_NAMED_SECTIONS,\t\t\t\\\n   TARGET_HAVE_CTORS_DTORS,\t\t\t\\"}, {"sha": "36f2463b0b558001bf669b02c3ceb89d1ac2a779", "filename": "gcc/target.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3", "patch": "@@ -703,6 +703,11 @@ struct gcc_target\n        target modifications).  */\n     void (*adjust_class_at_definition) (tree type);\n   } cxx;\n+  \n+  /* For targets that need to mark extra registers as live on entry to\n+     the function, they should define this target hook and set their\n+     bits in the bitmap passed in. */  \n+  void (*live_on_entry) (bitmap); \n \n   /* True if unwinding tables should be generated by default.  */\n   bool unwind_tables_default;"}, {"sha": "f6289c8977e7a25050a8273b461a7053f5b0523c", "filename": "gcc/targhooks.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3", "patch": "@@ -337,6 +337,11 @@ hook_int_CUMULATIVE_ARGS_mode_tree_bool_0 (\n   return 0;\n }\n \n+void \n+hook_void_bitmap (bitmap regs ATTRIBUTE_UNUSED)\n+{\n+}\n+\n const char *\n hook_invalid_arg_for_unprototyped_fn (\n \ttree typelist ATTRIBUTE_UNUSED,"}, {"sha": "05d1addc327f8d1ad1a2072b9ac6c85e6cb48991", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=912f2dacdf24c5dde0a5a879c70fbd8ba6f45fa3", "patch": "@@ -74,3 +74,4 @@ extern rtx default_internal_arg_pointer (void);\n extern enum reg_class default_secondary_reload (bool, rtx, enum reg_class,\n \t\t\t\t\t\tenum machine_mode,\n \t\t\t\t\t\tsecondary_reload_info *);\n+extern void hook_void_bitmap (bitmap);"}]}