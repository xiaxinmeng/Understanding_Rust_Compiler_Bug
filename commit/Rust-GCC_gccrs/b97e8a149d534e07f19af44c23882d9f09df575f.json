{"sha": "b97e8a149d534e07f19af44c23882d9f09df575f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk3ZThhMTQ5ZDUzNGUwN2YxOWFmNDRjMjM4ODJkOWYwOWRmNTc1Zg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-07-04T00:43:26Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-07-04T00:43:26Z"}, "message": "cp-tree.h (struct lang_decl): Overhaul.\n\n\t* cp-tree.h (struct lang_decl): Overhaul.\n\t(struct lang_decl_flags): Remove.\n\t(struct lang_decl_base): New.\n\t(struct lang_decl_min): New.\n\t(struct lang_decl_fn): New.\n\t(struct lang_decl_ns): New.\n\t(CAN_HAVE_FULL_LANG_DECL_P): Replace with LANG_DECL_HAS_MIN.\n\t(LANG_DECL_MIN_CHECK): New.\n\t(LANG_DECL_FN_CHECK): New.\n\t(LANG_DECL_NS_CHECK): New.\n\t(STRIP_TEMPLATE): New.\n\t(NON_THUNK_FUNCTION_CHECK): Remove.\n\t(DECL_DECLARES_FUNCTION_P): New.\n\t(lots): Adjust.\n\t* lex.c (retrofit_lang_decl, cxx_dup_lang_specific_decl): Adjust.\n\t* decl.c (push_local_name, duplicate_decls): Adjust.\n\t* decl2.c (start_objects): Don't set u2sel.\n\t* semantics.c (finish_omp_threadprivate): Adjust.\n\t* class.c (build_clone): Don't do much on TEMPLATE_DECLs.\n\t(decl_cloned_function_p): Out-of-line implementation of macros.\n\t(clone_function_decl, adjust_clone_args): Use DECL_CLONED_FUNCTION_P.\n\t* mangle.c (write_unqualified_name): Don't check function flags\n\ton non-functions.\n\t* method.c (make_alias_for): Don't set DECL_CLONED_FUNCTION.\n\t* pt.c (build_template_decl): Don't set function flags.\n\t(check_default_tmpl_args): Check that it's a function.\n\t(instantiate_template): Use DECL_ABSTRACT_ORIGIN to find the\n\tcloned template.\n\n\t* pt.c (tsubst_decl) [FUNCTION_DECL]: Don't tsubst\n\tDECL_CLONED_FUNCTION.\n\n\t* cp-tree.h (struct lang_type_class): Move sorted_fields here.\n\t* class.c (finish_struct_1): Adjust.\n\t* ptree.c (cxx_print_decl, cxx_print_type): Adjust.\n\t* search.c (lookup_field_1): Adjust.\n\n\t* cp-tree.h (CLASSTYPE_INLINE_FRIENDS): Remove.\n\t* decl.c (finish_method): Don't add to it.\n\t* class.c (fixup_pending_inline): Remove.\n\t(fixup_inline_methods): Remove.\n\t(finish_struct_1): Don't call it.\n\n\t* error.c (dump_function_name): Handle null name.\n\nFrom-SVN: r149217", "tree": {"sha": "9605692ffc98995bbab96bc7e30193329746fca0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9605692ffc98995bbab96bc7e30193329746fca0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b97e8a149d534e07f19af44c23882d9f09df575f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b97e8a149d534e07f19af44c23882d9f09df575f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b97e8a149d534e07f19af44c23882d9f09df575f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b97e8a149d534e07f19af44c23882d9f09df575f/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "07302a1bb6c0842e0bf214ec7d551a99c76efa8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07302a1bb6c0842e0bf214ec7d551a99c76efa8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07302a1bb6c0842e0bf214ec7d551a99c76efa8f"}], "stats": {"total": 816, "additions": 435, "deletions": 381}, "files": [{"sha": "257dca4c29f28ce64d9fa3b2f9eb5ebea52c2ad0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b97e8a149d534e07f19af44c23882d9f09df575f", "patch": "@@ -1,3 +1,50 @@\n+2009-07-03  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-tree.h (struct lang_decl): Overhaul.\n+\t(struct lang_decl_flags): Remove.\n+\t(struct lang_decl_base): New.\n+\t(struct lang_decl_min): New.\n+\t(struct lang_decl_fn): New.\n+\t(struct lang_decl_ns): New.\n+\t(CAN_HAVE_FULL_LANG_DECL_P): Replace with LANG_DECL_HAS_MIN.\n+\t(LANG_DECL_MIN_CHECK): New.\n+\t(LANG_DECL_FN_CHECK): New.\n+\t(LANG_DECL_NS_CHECK): New.\n+\t(STRIP_TEMPLATE): New.\n+\t(NON_THUNK_FUNCTION_CHECK): Remove.\n+\t(DECL_DECLARES_FUNCTION_P): New.\n+\t(lots): Adjust.\n+\t* lex.c (retrofit_lang_decl, cxx_dup_lang_specific_decl): Adjust.\n+\t* decl.c (push_local_name, duplicate_decls): Adjust.\n+\t* decl2.c (start_objects): Don't set u2sel.\n+\t* semantics.c (finish_omp_threadprivate): Adjust.\n+\t* class.c (build_clone): Don't do much on TEMPLATE_DECLs.\n+\t(decl_cloned_function_p): Out-of-line implementation of macros.\n+\t(clone_function_decl, adjust_clone_args): Use DECL_CLONED_FUNCTION_P.\n+\t* mangle.c (write_unqualified_name): Don't check function flags\n+\ton non-functions.\n+\t* method.c (make_alias_for): Don't set DECL_CLONED_FUNCTION.\n+\t* pt.c (build_template_decl): Don't set function flags.\n+\t(check_default_tmpl_args): Check that it's a function.\n+\t(instantiate_template): Use DECL_ABSTRACT_ORIGIN to find the\n+\tcloned template.\n+\n+\t* pt.c (tsubst_decl) [FUNCTION_DECL]: Don't tsubst\n+\tDECL_CLONED_FUNCTION.\n+\n+\t* cp-tree.h (struct lang_type_class): Move sorted_fields here.\n+\t* class.c (finish_struct_1): Adjust.\n+\t* ptree.c (cxx_print_decl, cxx_print_type): Adjust.\n+\t* search.c (lookup_field_1): Adjust.\n+\n+\t* cp-tree.h (CLASSTYPE_INLINE_FRIENDS): Remove.\n+\t* decl.c (finish_method): Don't add to it.\n+\t* class.c (fixup_pending_inline): Remove.\n+\t(fixup_inline_methods): Remove.\n+\t(finish_struct_1): Don't call it.\n+\n+\t* error.c (dump_function_name): Handle null name.\n+\n 2009-07-02  Mark Mitchell  <mark@codesourcery.com>\n \n \t* typeck.c (cp_build_binary_op): Move warnings about use of NULL"}, {"sha": "4668c68d00885e27817c0e04f5be7c7668853d37", "filename": "gcc/cp/class.c", "status": "modified", "additions": 78, "deletions": 99, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=b97e8a149d534e07f19af44c23882d9f09df575f", "patch": "@@ -151,8 +151,6 @@ static void check_bases_and_members (tree);\n static tree create_vtable_ptr (tree, tree *);\n static void include_empty_classes (record_layout_info);\n static void layout_class_type (tree, tree *);\n-static void fixup_pending_inline (tree);\n-static void fixup_inline_methods (tree);\n static void propagate_binfo_offsets (tree, tree);\n static void layout_virtual_bases (record_layout_info, splay_tree);\n static void build_vbase_offset_vtbl_entries (tree, vtbl_init_data *);\n@@ -3799,12 +3797,27 @@ build_clone (tree fn, tree name)\n \n   /* Copy the function.  */\n   clone = copy_decl (fn);\n-  /* Remember where this function came from.  */\n-  DECL_CLONED_FUNCTION (clone) = fn;\n-  DECL_ABSTRACT_ORIGIN (clone) = fn;\n   /* Reset the function name.  */\n   DECL_NAME (clone) = name;\n   SET_DECL_ASSEMBLER_NAME (clone, NULL_TREE);\n+  /* Remember where this function came from.  */\n+  DECL_ABSTRACT_ORIGIN (clone) = fn;\n+  /* Make it easy to find the CLONE given the FN.  */\n+  TREE_CHAIN (clone) = TREE_CHAIN (fn);\n+  TREE_CHAIN (fn) = clone;\n+\n+  /* If this is a template, do the rest on the DECL_TEMPLATE_RESULT.  */\n+  if (TREE_CODE (clone) == TEMPLATE_DECL)\n+    {\n+      tree result = build_clone (DECL_TEMPLATE_RESULT (clone), name);\n+      DECL_TEMPLATE_RESULT (clone) = result;\n+      DECL_TEMPLATE_INFO (result) = copy_node (DECL_TEMPLATE_INFO (result));\n+      DECL_TI_TEMPLATE (result) = clone;\n+      TREE_TYPE (clone) = TREE_TYPE (result);\n+      return clone;\n+    }\n+\n+  DECL_CLONED_FUNCTION (clone) = fn;\n   /* There's no pending inline data for this function.  */\n   DECL_PENDING_INLINE_INFO (clone) = NULL;\n   DECL_PENDING_INLINE_P (clone) = 0;\n@@ -3852,61 +3865,79 @@ build_clone (tree fn, tree name)\n \t\t\t\t\t   TYPE_ATTRIBUTES (TREE_TYPE (fn)));\n     }\n \n-  /* Copy the function parameters.  But, DECL_ARGUMENTS on a TEMPLATE_DECL\n-     aren't function parameters; those are the template parameters.  */\n-  if (TREE_CODE (clone) != TEMPLATE_DECL)\n+  /* Copy the function parameters.  */\n+  DECL_ARGUMENTS (clone) = copy_list (DECL_ARGUMENTS (clone));\n+  /* Remove the in-charge parameter.  */\n+  if (DECL_HAS_IN_CHARGE_PARM_P (clone))\n+    {\n+      TREE_CHAIN (DECL_ARGUMENTS (clone))\n+\t= TREE_CHAIN (TREE_CHAIN (DECL_ARGUMENTS (clone)));\n+      DECL_HAS_IN_CHARGE_PARM_P (clone) = 0;\n+    }\n+  /* And the VTT parm, in a complete [cd]tor.  */\n+  if (DECL_HAS_VTT_PARM_P (fn))\n     {\n-      DECL_ARGUMENTS (clone) = copy_list (DECL_ARGUMENTS (clone));\n-      /* Remove the in-charge parameter.  */\n-      if (DECL_HAS_IN_CHARGE_PARM_P (clone))\n+      if (DECL_NEEDS_VTT_PARM_P (clone))\n+\tDECL_HAS_VTT_PARM_P (clone) = 1;\n+      else\n \t{\n \t  TREE_CHAIN (DECL_ARGUMENTS (clone))\n \t    = TREE_CHAIN (TREE_CHAIN (DECL_ARGUMENTS (clone)));\n-\t  DECL_HAS_IN_CHARGE_PARM_P (clone) = 0;\n-\t}\n-      /* And the VTT parm, in a complete [cd]tor.  */\n-      if (DECL_HAS_VTT_PARM_P (fn))\n-\t{\n-\t  if (DECL_NEEDS_VTT_PARM_P (clone))\n-\t    DECL_HAS_VTT_PARM_P (clone) = 1;\n-\t  else\n-\t    {\n-\t      TREE_CHAIN (DECL_ARGUMENTS (clone))\n-\t\t= TREE_CHAIN (TREE_CHAIN (DECL_ARGUMENTS (clone)));\n-\t      DECL_HAS_VTT_PARM_P (clone) = 0;\n-\t    }\n+\t  DECL_HAS_VTT_PARM_P (clone) = 0;\n \t}\n+    }\n \n-      for (parms = DECL_ARGUMENTS (clone); parms; parms = TREE_CHAIN (parms))\n-\t{\n-\t  DECL_CONTEXT (parms) = clone;\n-\t  cxx_dup_lang_specific_decl (parms);\n-\t}\n+  for (parms = DECL_ARGUMENTS (clone); parms; parms = TREE_CHAIN (parms))\n+    {\n+      DECL_CONTEXT (parms) = clone;\n+      cxx_dup_lang_specific_decl (parms);\n     }\n \n   /* Create the RTL for this function.  */\n   SET_DECL_RTL (clone, NULL_RTX);\n   rest_of_decl_compilation (clone, /*top_level=*/1, at_eof);\n \n-  /* Make it easy to find the CLONE given the FN.  */\n-  TREE_CHAIN (clone) = TREE_CHAIN (fn);\n-  TREE_CHAIN (fn) = clone;\n+  if (pch_file)\n+    note_decl_for_pch (clone);\n \n-  /* If this is a template, handle the DECL_TEMPLATE_RESULT as well.  */\n-  if (TREE_CODE (clone) == TEMPLATE_DECL)\n-    {\n-      tree result;\n+  return clone;\n+}\n \n-      DECL_TEMPLATE_RESULT (clone)\n-\t= build_clone (DECL_TEMPLATE_RESULT (clone), name);\n-      result = DECL_TEMPLATE_RESULT (clone);\n-      DECL_TEMPLATE_INFO (result) = copy_node (DECL_TEMPLATE_INFO (result));\n-      DECL_TI_TEMPLATE (result) = clone;\n+/* Implementation of DECL_CLONED_FUNCTION and DECL_CLONED_FUNCTION_P, do\n+   not invoke this function directly.\n+\n+   For a non-thunk function, returns the address of the slot for storing\n+   the function it is a clone of.  Otherwise returns NULL_TREE.\n+\n+   If JUST_TESTING, looks through TEMPLATE_DECL and returns NULL if\n+   cloned_function is unset.  This is to support the separate\n+   DECL_CLONED_FUNCTION and DECL_CLONED_FUNCTION_P modes; using the latter\n+   on a template makes sense, but not the former.  */\n+\n+tree *\n+decl_cloned_function_p (const_tree decl, bool just_testing)\n+{\n+  tree *ptr;\n+  if (just_testing)\n+    decl = STRIP_TEMPLATE (decl);\n+\n+  if (TREE_CODE (decl) != FUNCTION_DECL\n+      || !DECL_LANG_SPECIFIC (decl)\n+      || DECL_LANG_SPECIFIC (decl)->u.fn.thunk_p)\n+    {\n+#if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n+      if (!just_testing)\n+\tlang_check_failed (__FILE__, __LINE__, __FUNCTION__);\n+      else\n+#endif\n+\treturn NULL;\n     }\n-  else if (pch_file)\n-    note_decl_for_pch (clone);\n \n-  return clone;\n+  ptr = &DECL_LANG_SPECIFIC (decl)->u.fn.u5.cloned_function;\n+  if (just_testing && *ptr == NULL_TREE)\n+    return NULL;\n+  else\n+    return ptr;\n }\n \n /* Produce declarations for all appropriate clones of FN.  If\n@@ -3920,7 +3951,7 @@ clone_function_decl (tree fn, int update_method_vec_p)\n \n   /* Avoid inappropriate cloning.  */\n   if (TREE_CHAIN (fn)\n-      && DECL_CLONED_FUNCTION (TREE_CHAIN (fn)))\n+      && DECL_CLONED_FUNCTION_P (TREE_CHAIN (fn)))\n     return;\n \n   if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (fn))\n@@ -3977,7 +4008,7 @@ adjust_clone_args (tree decl)\n {\n   tree clone;\n \n-  for (clone = TREE_CHAIN (decl); clone && DECL_CLONED_FUNCTION (clone);\n+  for (clone = TREE_CHAIN (decl); clone && DECL_CLONED_FUNCTION_P (clone);\n        clone = TREE_CHAIN (clone))\n     {\n       tree orig_clone_parms = TYPE_ARG_TYPES (TREE_TYPE (clone));\n@@ -4447,54 +4478,6 @@ create_vtable_ptr (tree t, tree* virtuals_p)\n   return NULL_TREE;\n }\n \n-/* Fixup the inline function given by INFO now that the class is\n-   complete.  */\n-\n-static void\n-fixup_pending_inline (tree fn)\n-{\n-  if (DECL_PENDING_INLINE_INFO (fn))\n-    {\n-      tree args = DECL_ARGUMENTS (fn);\n-      while (args)\n-\t{\n-\t  DECL_CONTEXT (args) = fn;\n-\t  args = TREE_CHAIN (args);\n-\t}\n-    }\n-}\n-\n-/* Fixup the inline methods and friends in TYPE now that TYPE is\n-   complete.  */\n-\n-static void\n-fixup_inline_methods (tree type)\n-{\n-  tree method = TYPE_METHODS (type);\n-  VEC(tree,gc) *friends;\n-  unsigned ix;\n-\n-  if (method && TREE_CODE (method) == TREE_VEC)\n-    {\n-      if (TREE_VEC_ELT (method, 1))\n-\tmethod = TREE_VEC_ELT (method, 1);\n-      else if (TREE_VEC_ELT (method, 0))\n-\tmethod = TREE_VEC_ELT (method, 0);\n-      else\n-\tmethod = TREE_VEC_ELT (method, 2);\n-    }\n-\n-  /* Do inline member functions.  */\n-  for (; method; method = TREE_CHAIN (method))\n-    fixup_pending_inline (method);\n-\n-  /* Do friends.  */\n-  for (friends = CLASSTYPE_INLINE_FRIENDS (type), ix = 0;\n-       VEC_iterate (tree, friends, ix, method); ix++)\n-    fixup_pending_inline (method);\n-  CLASSTYPE_INLINE_FRIENDS (type) = NULL;\n-}\n-\n /* Add OFFSET to all base types of BINFO which is a base in the\n    hierarchy dominated by T.\n \n@@ -5219,8 +5202,6 @@ finish_struct_1 (tree t)\n   TYPE_SIZE (t) = NULL_TREE;\n   CLASSTYPE_PRIMARY_BINFO (t) = NULL_TREE;\n \n-  fixup_inline_methods (t);\n-\n   /* Make assumptions about the class; we'll reset the flags if\n      necessary.  */\n   CLASSTYPE_EMPTY_P (t) = 1;\n@@ -5332,9 +5313,7 @@ finish_struct_1 (tree t)\n       add_fields_to_record_type (TYPE_FIELDS (t), field_vec, 0);\n       qsort (field_vec->elts, n_fields, sizeof (tree),\n \t     field_decl_cmp);\n-      if (! DECL_LANG_SPECIFIC (TYPE_MAIN_DECL (t)))\n-\tretrofit_lang_decl (TYPE_MAIN_DECL (t));\n-      DECL_SORTED_FIELDS (TYPE_MAIN_DECL (t)) = field_vec;\n+      CLASSTYPE_SORTED_FIELDS (t) = field_vec;\n     }\n \n   /* Complain if one of the field types requires lower visibility.  */"}, {"sha": "50ed2ea162d1c0a43ea0338b0285ab6ac8f8a008", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 214, "deletions": 177, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b97e8a149d534e07f19af44c23882d9f09df575f", "patch": "@@ -199,21 +199,13 @@ framework extensions, you must include this file before toplev.h, not after.\n   TREE_CHECK(NODE,BOUND_TEMPLATE_TEMPLATE_PARM)\n \n #if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n-#define NON_THUNK_FUNCTION_CHECK(NODE) __extension__\t\t\t\\\n-({  __typeof(NODE) const __t = (NODE);\t\t\t\t\t\\\n-    if (TREE_CODE (__t) != FUNCTION_DECL &&\t\t\t\t\\\n-\tTREE_CODE (__t) != TEMPLATE_DECL && __t->decl_common.lang_specific\t\\\n-\t&& __t->decl_common.lang_specific->decl_flags.thunk_p)\t\t\t\\\n-      tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__, 0);\t\\\n-    __t; })\n #define THUNK_FUNCTION_CHECK(NODE) __extension__\t\t\t\\\n ({  __typeof (NODE) const __t = (NODE);\t\t\t\t\t\\\n-    if (TREE_CODE (__t) != FUNCTION_DECL || !__t->decl_common.lang_specific\t\\\n-\t|| !__t->decl_common.lang_specific->decl_flags.thunk_p)\t\t\\\n+    if (TREE_CODE (__t) != FUNCTION_DECL || !__t->decl_common.lang_specific \\\n+\t|| !__t->decl_common.lang_specific->u.fn.thunk_p)\t\t\\\n       tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__, 0);\t\\\n      __t; })\n #else\n-#define NON_THUNK_FUNCTION_CHECK(NODE) (NODE)\n #define THUNK_FUNCTION_CHECK(NODE) (NODE)\n #endif\n \f\n@@ -1160,6 +1152,10 @@ struct GTY(()) lang_type_class {\n      as a list of adopted protocols or a pointer to a corresponding\n      @interface.  See objc/objc-act.h for details.  */\n   tree objc_info;\n+  /* sorted_fields is sorted based on a pointer, so we need to be able\n+     to resort it if pointers get rearranged.  */\n+  struct sorted_fields_type * GTY ((reorder (\"resort_sorted_fields\")))\n+    sorted_fields;\n };\n \n struct GTY(()) lang_type_ptrmem {\n@@ -1197,13 +1193,6 @@ struct GTY(()) lang_type {\n \n #endif /* ENABLE_TREE_CHECKING */\n \n-/* Fields used for storing information before the class is defined.\n-   After the class is defined, these fields hold other information.  */\n-\n-/* VEC(tree) of friends which were defined inline in this class\n-   definition.  */\n-#define CLASSTYPE_INLINE_FRIENDS(NODE) CLASSTYPE_PURE_VIRTUALS (NODE)\n-\n /* Nonzero for _CLASSTYPE means that operator delete is defined.  */\n #define TYPE_GETS_DELETE(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->gets_delete)\n #define TYPE_GETS_REG_DELETE(NODE) (TYPE_GETS_DELETE (NODE) & 1)\n@@ -1563,142 +1552,188 @@ struct GTY(()) lang_type {\n \n /* The binding level associated with the namespace.  */\n #define NAMESPACE_LEVEL(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.u.level)\n+  (LANG_DECL_NS_CHECK (NODE)->level)\n \f\n+/* Flags shared by all forms of DECL_LANG_SPECIFIC.\n \n-/* If a DECL has DECL_LANG_SPECIFIC, it is either a lang_decl_flags or\n-   a lang_decl (which has lang_decl_flags as its initial prefix).\n-   This macro is nonzero for tree nodes whose DECL_LANG_SPECIFIC is\n-   the full lang_decl, and not just lang_decl_flags.  Keep these\n-   checks in ascending code order.  */\n-#define CAN_HAVE_FULL_LANG_DECL_P(NODE)\t\t\t\\\n-  (!(TREE_CODE (NODE) == FIELD_DECL\t\t\t\\\n-     || TREE_CODE (NODE) == VAR_DECL\t\t\t\\\n-     || TREE_CODE (NODE) == CONST_DECL\t\t\t\\\n-     || TREE_CODE (NODE) == USING_DECL))\n+   Some of the flags live here only to make lang_decl_min/fn smaller.  Do\n+   not make this struct larger than 32 bits; instead, make sel smaller.  */\n \n-struct GTY(()) lang_decl_flags {\n+struct GTY(()) lang_decl_base {\n+  unsigned selector : 16;   /* Larger than necessary for faster access.  */\n   ENUM_BITFIELD(languages) language : 4;\n+  unsigned use_template : 2;\n+  unsigned not_really_extern : 1;\t   /* var or fn */\n+  unsigned initialized_in_class : 1;\t   /* var or fn */\n+  unsigned repo_available_p : 1;\t   /* var or fn */\n+  unsigned threadprivate_or_deleted_p : 1; /* var or fn */\n+  unsigned anticipated_p : 1;\t\t   /* fn or type */\n+  unsigned friend_attr : 1;\t\t   /* fn or type */\n+  unsigned template_conv_p : 1;\t\t   /* template only? */\n+  unsigned u2sel : 1;\n+  /* 2 spare bits */\n+};\n+\n+/* True for DECL codes which have template info and access.  */\n+#define LANG_DECL_HAS_MIN(NODE)\t\t\t\\\n+  (TREE_CODE (NODE) == FUNCTION_DECL\t\t\\\n+   || TREE_CODE (NODE) == FIELD_DECL\t\t\\\n+   || TREE_CODE (NODE) == VAR_DECL\t\t\\\n+   || TREE_CODE (NODE) == CONST_DECL\t\t\\\n+   || TREE_CODE (NODE) == TYPE_DECL\t\t\\\n+   || TREE_CODE (NODE) == TEMPLATE_DECL\t\t\\\n+   || TREE_CODE (NODE) == USING_DECL)\n+\n+/* DECL_LANG_SPECIFIC for the above codes.  */\n+\n+struct GTY(()) lang_decl_min {\n+  struct lang_decl_base base;\n+\n+  /* In a FUNCTION_DECL for which DECL_THUNK_P holds, this is\n+     THUNK_ALIAS.\n+     In a FUNCTION_DECL for which DECL_THUNK_P does not hold,\n+     VAR_DECL, TYPE_DECL, or TEMPLATE_DECL, this is\n+     DECL_TEMPLATE_INFO.  */\n+  tree template_info;\n+\n+  union lang_decl_u2 {\n+    /* In a FUNCTION_DECL for which DECL_THUNK_P holds, this is\n+       THUNK_VIRTUAL_OFFSET.\n+       Otherwise this is DECL_ACCESS.  */\n+    tree GTY ((tag (\"0\"))) access;\n+\n+    /* For VAR_DECL in function, this is DECL_DISCRIMINATOR.  */\n+    int GTY ((tag (\"1\"))) discriminator;\n+  } GTY ((desc (\"%0.u.base.u2sel\"))) u2;\n+};\n+\n+/* Additional DECL_LANG_SPECIFIC information for functions.  */\n+\n+struct GTY(()) lang_decl_fn {\n+  struct lang_decl_min min;\n+\n+  /* In an overloaded operator, this is the value of\n+     DECL_OVERLOADED_OPERATOR_P.  */\n+  ENUM_BITFIELD (tree_code) operator_code : 16;\n+\n   unsigned global_ctor_p : 1;\n   unsigned global_dtor_p : 1;\n-  unsigned anticipated_p : 1;\n-  unsigned template_conv_p : 1;\n-\n-  unsigned operator_attr : 1;\n   unsigned constructor_attr : 1;\n   unsigned destructor_attr : 1;\n-  unsigned friend_attr : 1;\n+  unsigned assignment_operator_p : 1;\n   unsigned static_function : 1;\n   unsigned pure_virtual : 1;\n+  unsigned defaulted_p : 1;\n+\n   unsigned has_in_charge_parm_p : 1;\n   unsigned has_vtt_parm_p : 1;\n-\n-  unsigned deferred : 1;\n-  unsigned use_template : 2;\n+  unsigned pending_inline_p : 1;\n   unsigned nonconverting : 1;\n-  unsigned not_really_extern : 1;\n-  unsigned initialized_in_class : 1;\n-  unsigned assignment_operator_p : 1;\n-  unsigned u1sel : 1;\n-\n-  unsigned u2sel : 1;\n-  unsigned can_be_full : 1;\n   unsigned thunk_p : 1;\n   unsigned this_thunk_p : 1;\n-  unsigned repo_available_p : 1;\n   unsigned hidden_friend_p : 1;\n-  unsigned threadprivate_or_deleted_p : 1;\n-  unsigned defaulted_p : 1;\n+  unsigned deferred : 1;\n+  /* No spare bits; consider adding to lang_decl_base instead.  */\n \n-  union lang_decl_u {\n-    /* In a FUNCTION_DECL for which DECL_THUNK_P holds, this is\n-       THUNK_ALIAS.\n-       In a FUNCTION_DECL for which DECL_THUNK_P does not hold,\n-       VAR_DECL, TYPE_DECL, or TEMPLATE_DECL, this is\n-       DECL_TEMPLATE_INFO.  */\n-    tree GTY ((tag (\"0\"))) template_info;\n+  /* For a non-thunk function decl, this is a tree list of\n+     friendly classes. For a thunk function decl, it is the\n+     thunked to function decl.  */\n+  tree befriending_classes;\n \n-    /* In a NAMESPACE_DECL, this is NAMESPACE_LEVEL.  */\n-    struct cp_binding_level * GTY ((tag (\"1\"))) level;\n-  } GTY ((desc (\"%1.u1sel\"))) u;\n+  /* For a non-virtual FUNCTION_DECL, this is\n+     DECL_FRIEND_CONTEXT.  For a virtual FUNCTION_DECL for which\n+     DECL_THIS_THUNK_P does not hold, this is DECL_THUNKS. Both\n+     this pointer and result pointer adjusting thunks are\n+     chained here.  This pointer thunks to return pointer thunks\n+     will be chained on the return pointer thunk.  */\n+  tree context;\n \n-  union lang_decl_u2 {\n-    /* In a FUNCTION_DECL for which DECL_THUNK_P holds, this is\n-       THUNK_VIRTUAL_OFFSET.\n-       Otherwise this is DECL_ACCESS.  */\n-    tree GTY ((tag (\"0\"))) access;\n+  union lang_decl_u5\n+  {\n+    /* In a non-thunk FUNCTION_DECL or TEMPLATE_DECL, this is\n+       DECL_CLONED_FUNCTION.  */\n+    tree GTY ((tag (\"0\"))) cloned_function;\n \n-    /* For VAR_DECL in function, this is DECL_DISCRIMINATOR.  */\n-    int GTY ((tag (\"1\"))) discriminator;\n-  } GTY ((desc (\"%1.u2sel\"))) u2;\n+    /* In a FUNCTION_DECL for which THUNK_P holds this is the\n+       THUNK_FIXED_OFFSET.  */\n+    HOST_WIDE_INT GTY ((tag (\"1\"))) fixed_offset;\n+  } GTY ((desc (\"%1.thunk_p\"))) u5;\n+\n+  union lang_decl_u3\n+  {\n+    struct cp_token_cache * GTY ((tag (\"1\"))) pending_inline_info;\n+    struct language_function * GTY ((tag (\"0\")))\n+      saved_language_function;\n+  } GTY ((desc (\"%1.pending_inline_p\"))) u;\n+\n+};\n+\n+/* DECL_LANG_SPECIFIC for namespaces.  */\n+\n+struct GTY(()) lang_decl_ns {\n+  struct lang_decl_base base;\n+  struct cp_binding_level *level;\n };\n \n-/* sorted_fields is sorted based on a pointer, so we need to be able\n-   to resort it if pointers get rearranged.  */\n+/* DECL_LANG_SPECIFIC for all types.  It would be nice to just make this a\n+   union rather than a struct containing a union as its only field, but\n+   tree.h declares it as a struct.  */\n \n struct GTY(()) lang_decl {\n-  struct lang_decl_flags decl_flags;\n-\n-  union lang_decl_u4\n-    {\n-      struct full_lang_decl\n-      {\n-\t/* In an overloaded operator, this is the value of\n-\t   DECL_OVERLOADED_OPERATOR_P.  */\n-\tENUM_BITFIELD (tree_code) operator_code : 16;\n-\n-\tunsigned u3sel : 1;\n-\tunsigned pending_inline_p : 1;\n-\tunsigned spare : 14;\n-\n-\t/* For a non-thunk function decl, this is a tree list of\n-\t   friendly classes. For a thunk function decl, it is the\n-\t   thunked to function decl.  */\n-\ttree befriending_classes;\n-\n-\t/* For a non-virtual FUNCTION_DECL, this is\n-\t   DECL_FRIEND_CONTEXT.  For a virtual FUNCTION_DECL for which\n-\t   DECL_THIS_THUNK_P does not hold, this is DECL_THUNKS. Both\n-\t   this pointer and result pointer adjusting thunks are\n-\t   chained here.  This pointer thunks to return pointer thunks\n-\t   will be chained on the return pointer thunk.  */\n-\ttree context;\n-\n-\tunion lang_decl_u5\n-\t{\n-\t  /* In a non-thunk FUNCTION_DECL or TEMPLATE_DECL, this is\n-\t     DECL_CLONED_FUNCTION.  */\n-\t  tree GTY ((tag (\"0\"))) cloned_function;\n-\n-\t  /* In a FUNCTION_DECL for which THUNK_P holds this is the\n-\t     THUNK_FIXED_OFFSET.  */\n-\t  HOST_WIDE_INT GTY ((tag (\"1\"))) fixed_offset;\n-\t} GTY ((desc (\"%0.decl_flags.thunk_p\"))) u5;\n-\n-\tunion lang_decl_u3\n-\t{\n-\t  struct sorted_fields_type * GTY ((tag (\"0\"), reorder (\"resort_sorted_fields\")))\n-\t       sorted_fields;\n-\t  struct cp_token_cache * GTY ((tag (\"2\"))) pending_inline_info;\n-\t  struct language_function * GTY ((tag (\"1\")))\n-\t       saved_language_function;\n-\t} GTY ((desc (\"%1.u3sel + %1.pending_inline_p\"))) u;\n-      } GTY ((tag (\"1\"))) f;\n-  } GTY ((desc (\"%1.decl_flags.can_be_full\"))) u;\n+  union GTY((desc (\"%h.base.selector\"))) lang_decl_u {\n+    struct lang_decl_base GTY ((default)) base;\n+    struct lang_decl_min GTY((tag (\"0\"))) min;\n+    struct lang_decl_fn GTY ((tag (\"1\"))) fn;\n+    struct lang_decl_ns GTY((tag (\"2\"))) ns;\n+  } u;\n };\n \n+/* Looks through a template (if present) to find what it declares.  */\n+#define STRIP_TEMPLATE(NODE) \\\n+  (TREE_CODE (NODE) == TEMPLATE_DECL ? DECL_TEMPLATE_RESULT (NODE) : NODE)\n+\n #if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n \n+#define LANG_DECL_MIN_CHECK(NODE) __extension__\t\t\t\\\n+({ struct lang_decl *lt = DECL_LANG_SPECIFIC (NODE);\t\t\\\n+   if (!LANG_DECL_HAS_MIN (NODE))\t\t\t\t\\\n+     lang_check_failed (__FILE__, __LINE__, __FUNCTION__);\t\\\n+   &lt->u.min; })\n+\n+/* We want to be able to check DECL_CONSTRUCTOR_P and such on a function\n+   template, not just on a FUNCTION_DECL.  So when looking for things in\n+   lang_decl_fn, look down through a TEMPLATE_DECL into its result.  */\n+#define LANG_DECL_FN_CHECK(NODE) __extension__\t\t\t\t\\\n+({ struct lang_decl *lt = DECL_LANG_SPECIFIC (STRIP_TEMPLATE (NODE));\t\\\n+   if (!DECL_DECLARES_FUNCTION_P (NODE) || lt->u.base.selector != 1)\t\\\n+     lang_check_failed (__FILE__, __LINE__, __FUNCTION__);\t\t\\\n+   &lt->u.fn; })\n+\n+#define LANG_DECL_NS_CHECK(NODE) __extension__\t\t\t\t\\\n+({ struct lang_decl *lt = DECL_LANG_SPECIFIC (NODE);\t\t\t\\\n+   if (TREE_CODE (NODE) != NAMESPACE_DECL || lt->u.base.selector != 2)\t\\\n+     lang_check_failed (__FILE__, __LINE__, __FUNCTION__);\t\t\\\n+   &lt->u.ns; })\n+\n #define LANG_DECL_U2_CHECK(NODE, TF) __extension__\t\t\\\n ({  struct lang_decl *lt = DECL_LANG_SPECIFIC (NODE);\t\t\\\n-    if (lt->decl_flags.u2sel != TF)\t\t\t\t\\\n+    if (lt->u.base.u2sel != TF)\t\t\t\t\t\\\n       lang_check_failed (__FILE__, __LINE__, __FUNCTION__);\t\\\n-    &lt->decl_flags.u2; })\n+    &lt->u.min.u2; })\n \n #else\n \n+#define LANG_DECL_MIN_CHECK(NODE) \\\n+  (&DECL_LANG_SPECIFIC (NODE)->u.min)\n+\n+#define LANG_DECL_FN_CHECK(NODE) \\\n+  (&DECL_LANG_SPECIFIC (NODE)->u.fn)\n+\n+#define LANG_DECL_NS_CHECK(NODE) \\\n+  (&DECL_LANG_SPECIFIC (NODE)->u.ns)\n+\n #define LANG_DECL_U2_CHECK(NODE, TF) \\\n-  (&DECL_LANG_SPECIFIC (NODE)->decl_flags.u2)\n+  (&DECL_LANG_SPECIFIC (NODE)->u.min.u2)\n \n #endif /* ENABLE_TREE_CHECKING */\n \n@@ -1713,17 +1748,17 @@ struct GTY(()) lang_decl {\n    we do create DECL_LANG_SPECIFIC for variables with non-C++ linkage.  */\n #define DECL_LANGUAGE(NODE)\t\t\t\t\\\n   (DECL_LANG_SPECIFIC (NODE)\t\t\t\t\\\n-   ? DECL_LANG_SPECIFIC (NODE)->decl_flags.language\t\\\n+   ? DECL_LANG_SPECIFIC (NODE)->u.base.language\t\t\\\n    : (TREE_CODE (NODE) == FUNCTION_DECL\t\t\t\\\n       ? lang_c : lang_cplusplus))\n \n /* Set the language linkage for NODE to LANGUAGE.  */\n #define SET_DECL_LANGUAGE(NODE, LANGUAGE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.language = (LANGUAGE))\n+  (DECL_LANG_SPECIFIC (NODE)->u.base.language = (LANGUAGE))\n \n /* For FUNCTION_DECLs: nonzero means that this function is a constructor.  */\n #define DECL_CONSTRUCTOR_P(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.constructor_attr)\n+  (LANG_DECL_FN_CHECK (NODE)->constructor_attr)\n \n /* Nonzero if NODE (a FUNCTION_DECL) is a constructor for a complete\n    object.  */\n@@ -1741,7 +1776,8 @@ struct GTY(()) lang_decl {\n    specialized in-charge constructor or the specialized not-in-charge\n    constructor.  */\n #define DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P(NODE)\t\t\\\n-  (DECL_CONSTRUCTOR_P (NODE) && !DECL_CLONED_FUNCTION_P (NODE))\n+  (DECL_DECLARES_FUNCTION_P (NODE) && DECL_CONSTRUCTOR_P (NODE) \\\n+   && !DECL_CLONED_FUNCTION_P (NODE))\n \n /* Nonzero if NODE (a FUNCTION_DECL) is a copy constructor.  */\n #define DECL_COPY_CONSTRUCTOR_P(NODE) \\\n@@ -1753,13 +1789,14 @@ struct GTY(()) lang_decl {\n \n /* Nonzero if NODE is a destructor.  */\n #define DECL_DESTRUCTOR_P(NODE)\t\t\t\t\\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.destructor_attr)\n+  (LANG_DECL_FN_CHECK (NODE)->destructor_attr)\n \n /* Nonzero if NODE (a FUNCTION_DECL) is a destructor, but not the\n    specialized in-charge constructor, in-charge deleting constructor,\n    or the base destructor.  */\n #define DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P(NODE)\t\t\t\\\n-  (DECL_DESTRUCTOR_P (NODE) && !DECL_CLONED_FUNCTION_P (NODE))\n+  (DECL_DECLARES_FUNCTION_P (NODE) && DECL_DESTRUCTOR_P (NODE)\t\\\n+   && !DECL_CLONED_FUNCTION_P (NODE))\n \n /* Nonzero if NODE (a FUNCTION_DECL) is a destructor for a complete\n    object.  */\n@@ -1781,17 +1818,11 @@ struct GTY(()) lang_decl {\n \n /* Nonzero if NODE (a FUNCTION_DECL) is a cloned constructor or\n    destructor.  */\n-#define DECL_CLONED_FUNCTION_P(NODE)\t\t\t\\\n-  ((TREE_CODE (NODE) == FUNCTION_DECL\t\t\t\\\n-    || TREE_CODE (NODE) == TEMPLATE_DECL)\t\t\\\n-   && DECL_LANG_SPECIFIC (NODE)\t\t\t\t\\\n-   && !DECL_LANG_SPECIFIC (NODE)->decl_flags.thunk_p\t\\\n-   && DECL_CLONED_FUNCTION (NODE) != NULL_TREE)\n+#define DECL_CLONED_FUNCTION_P(NODE) (!!decl_cloned_function_p (NODE, true))\n \n /* If DECL_CLONED_FUNCTION_P holds, this is the function that was\n    cloned.  */\n-#define DECL_CLONED_FUNCTION(NODE) \\\n-  (DECL_LANG_SPECIFIC (NON_THUNK_FUNCTION_CHECK(NODE))->u.f.u5.cloned_function)\n+#define DECL_CLONED_FUNCTION(NODE) (*decl_cloned_function_p (NODE, false))\n \n /* Perform an action for each clone of FN, if FN is a function with\n    clones.  This macro should be used like:\n@@ -1818,7 +1849,7 @@ struct GTY(()) lang_decl {\n \n /* Nonzero if the VTT parm has been added to NODE.  */\n #define DECL_HAS_VTT_PARM_P(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.has_vtt_parm_p)\n+  (LANG_DECL_FN_CHECK (NODE)->has_vtt_parm_p)\n \n /* Nonzero if NODE is a FUNCTION_DECL for which a VTT parameter is\n    required.  */\n@@ -1840,11 +1871,11 @@ struct GTY(()) lang_decl {\n    conversion operator to a type dependent on the innermost template\n    args.  */\n #define DECL_TEMPLATE_CONV_FN_P(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.template_conv_p)\n+  (DECL_LANG_SPECIFIC (TEMPLATE_DECL_CHECK (NODE))->u.base.template_conv_p)\n \n /* Set the overloaded operator code for NODE to CODE.  */\n #define SET_OVERLOADED_OPERATOR_CODE(NODE, CODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->u.f.operator_code = (CODE))\n+  (LANG_DECL_FN_CHECK (NODE)->operator_code = (CODE))\n \n /* If NODE is an overloaded operator, then this returns the TREE_CODE\n    associated with the overloaded operator.\n@@ -1855,17 +1886,17 @@ struct GTY(()) lang_decl {\n    to test whether or not NODE is an overloaded operator.  */\n #define DECL_OVERLOADED_OPERATOR_P(NODE)\t\t\\\n   (IDENTIFIER_OPNAME_P (DECL_NAME (NODE))\t\t\\\n-   ? DECL_LANG_SPECIFIC (NODE)->u.f.operator_code : ERROR_MARK)\n+   ? LANG_DECL_FN_CHECK (NODE)->operator_code : ERROR_MARK)\n \n /* Nonzero if NODE is an assignment operator (including += and such).  */\n #define DECL_ASSIGNMENT_OPERATOR_P(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.assignment_operator_p)\n+  (LANG_DECL_FN_CHECK (NODE)->assignment_operator_p)\n \n /* For FUNCTION_DECLs: nonzero means that this function is a\n    constructor or a destructor with an extra in-charge parameter to\n    control whether or not virtual bases are constructed.  */\n #define DECL_HAS_IN_CHARGE_PARM_P(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.has_in_charge_parm_p)\n+  (LANG_DECL_FN_CHECK (NODE)->has_in_charge_parm_p)\n \n /* Nonzero if DECL is a declaration of __builtin_constant_p.  */\n #define DECL_IS_BUILTIN_CONSTANT_P(NODE)\t\t\\\n@@ -1917,20 +1948,21 @@ struct GTY(()) lang_decl {\n    rather than outside the class.  This is used for both static member\n    VAR_DECLS, and FUNCTION_DECLS that are defined in the class.  */\n #define DECL_INITIALIZED_IN_CLASS_P(DECL) \\\n- (DECL_LANG_SPECIFIC (DECL)->decl_flags.initialized_in_class)\n+  (DECL_LANG_SPECIFIC (VAR_OR_FUNCTION_DECL_CHECK (DECL)) \\\n+   ->u.base.initialized_in_class)\n \n /* Nonzero for DECL means that this decl is just a friend declaration,\n    and should not be added to the list of members for this class.  */\n-#define DECL_FRIEND_P(NODE) (DECL_LANG_SPECIFIC (NODE)->decl_flags.friend_attr)\n+#define DECL_FRIEND_P(NODE) (DECL_LANG_SPECIFIC (NODE)->u.base.friend_attr)\n \n /* A TREE_LIST of the types which have befriended this FUNCTION_DECL.  */\n #define DECL_BEFRIENDING_CLASSES(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->u.f.befriending_classes)\n+  (LANG_DECL_FN_CHECK (NODE)->befriending_classes)\n \n /* Nonzero for FUNCTION_DECL means that this decl is a static\n    member function.  */\n #define DECL_STATIC_FUNCTION_P(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.static_function)\n+  (LANG_DECL_FN_CHECK (NODE)->static_function)\n \n /* Nonzero for FUNCTION_DECL means that this decl is a non-static\n    member function.  */\n@@ -1940,7 +1972,7 @@ struct GTY(()) lang_decl {\n /* Nonzero for FUNCTION_DECL means that this decl is a member function\n    (static or non-static).  */\n #define DECL_FUNCTION_MEMBER_P(NODE) \\\n- (DECL_NONSTATIC_MEMBER_FUNCTION_P (NODE) || DECL_STATIC_FUNCTION_P (NODE))\n+  (DECL_NONSTATIC_MEMBER_FUNCTION_P (NODE) || DECL_STATIC_FUNCTION_P (NODE))\n \n /* Nonzero for FUNCTION_DECL means that this member function\n    has `this' as const X *const.  */\n@@ -1968,12 +2000,12 @@ struct GTY(()) lang_decl {\n /* Nonzero for _DECL means that this constructor or conversion function is\n    non-converting.  */\n #define DECL_NONCONVERTING_P(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.nonconverting)\n+  (LANG_DECL_FN_CHECK (NODE)->nonconverting)\n \n /* Nonzero for FUNCTION_DECL means that this member function is a pure\n    virtual function.  */\n #define DECL_PURE_VIRTUAL_P(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.pure_virtual)\n+  (LANG_DECL_FN_CHECK (NODE)->pure_virtual)\n \n /* True (in a FUNCTION_DECL) if NODE is a virtual function that is an\n    invalid overrider for a function from a base class.  Once we have\n@@ -1984,27 +2016,26 @@ struct GTY(()) lang_decl {\n \n /* The thunks associated with NODE, a FUNCTION_DECL.  */\n #define DECL_THUNKS(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->u.f.context)\n+  (LANG_DECL_FN_CHECK (NODE)->context)\n \n /* Nonzero if NODE is a thunk, rather than an ordinary function.  */\n #define DECL_THUNK_P(NODE)\t\t\t\\\n   (TREE_CODE (NODE) == FUNCTION_DECL\t\t\\\n    && DECL_LANG_SPECIFIC (NODE)\t\t\t\\\n-   && DECL_LANG_SPECIFIC (NODE)->decl_flags.thunk_p)\n+   && LANG_DECL_FN_CHECK (NODE)->thunk_p)\n \n /* Set DECL_THUNK_P for node.  */\n #define SET_DECL_THUNK_P(NODE, THIS_ADJUSTING)\t\t\t\\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.thunk_p = 1,\t\t\\\n-   DECL_LANG_SPECIFIC (NODE)->u.f.u3sel = 1,\t\t\t\\\n-   DECL_LANG_SPECIFIC (NODE)->decl_flags.this_thunk_p = (THIS_ADJUSTING))\n+  (LANG_DECL_FN_CHECK (NODE)->thunk_p = 1,\t\t\t\\\n+   LANG_DECL_FN_CHECK (NODE)->this_thunk_p = (THIS_ADJUSTING))\n \n /* Nonzero if NODE is a this pointer adjusting thunk.  */\n #define DECL_THIS_THUNK_P(NODE)\t\t\t\\\n-  (DECL_THUNK_P (NODE) && DECL_LANG_SPECIFIC (NODE)->decl_flags.this_thunk_p)\n+  (DECL_THUNK_P (NODE) && LANG_DECL_FN_CHECK (NODE)->this_thunk_p)\n \n /* Nonzero if NODE is a result pointer adjusting thunk.  */\n #define DECL_RESULT_THUNK_P(NODE)\t\t\t\\\n-  (DECL_THUNK_P (NODE) && !DECL_LANG_SPECIFIC (NODE)->decl_flags.this_thunk_p)\n+  (DECL_THUNK_P (NODE) && !LANG_DECL_FN_CHECK (NODE)->this_thunk_p)\n \n /* Nonzero if NODE is a FUNCTION_DECL, but not a thunk.  */\n #define DECL_NON_THUNK_FUNCTION_P(NODE)\t\t\t\t\\\n@@ -2021,7 +2052,7 @@ struct GTY(()) lang_decl {\n /* True iff DECL is an entity with vague linkage whose definition is\n    available in this translation unit.  */\n #define DECL_REPO_AVAILABLE_P(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.repo_available_p)\n+  (DECL_LANG_SPECIFIC (NODE)->u.base.repo_available_p)\n \n /* Nonzero if this DECL is the __PRETTY_FUNCTION__ variable in a\n    template function.  */\n@@ -2040,13 +2071,14 @@ struct GTY(()) lang_decl {\n \n    the DECL_FRIEND_CONTEXT for `f' will be `S'.  */\n #define DECL_FRIEND_CONTEXT(NODE)\t\t\t\t\\\n-  ((DECL_FRIEND_P (NODE) && !DECL_FUNCTION_MEMBER_P (NODE))\t\\\n-   ? DECL_LANG_SPECIFIC (NODE)->u.f.context\t\t\t\\\n+  ((DECL_DECLARES_FUNCTION_P (NODE)\t\t\t\t\\\n+    && DECL_FRIEND_P (NODE) && !DECL_FUNCTION_MEMBER_P (NODE))\t\\\n+   ? LANG_DECL_FN_CHECK (NODE)->context\t\t\t\t\\\n    : NULL_TREE)\n \n /* Set the DECL_FRIEND_CONTEXT for NODE to CONTEXT.  */\n #define SET_DECL_FRIEND_CONTEXT(NODE, CONTEXT) \\\n-  (DECL_LANG_SPECIFIC (NODE)->u.f.context = (CONTEXT))\n+  (LANG_DECL_FN_CHECK (NODE)->context = (CONTEXT))\n \n /* NULL_TREE in DECL_CONTEXT represents the global namespace.  */\n #define CP_DECL_CONTEXT(NODE) \\\n@@ -2153,21 +2185,21 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n    the class definition.  We have saved away the text of the function,\n    but have not yet processed it.  */\n #define DECL_PENDING_INLINE_P(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->u.f.pending_inline_p)\n+  (LANG_DECL_FN_CHECK (NODE)->pending_inline_p)\n \n /* If DECL_PENDING_INLINE_P holds, this is the saved text of the\n    function.  */\n #define DECL_PENDING_INLINE_INFO(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->u.f.u.pending_inline_info)\n+  (LANG_DECL_FN_CHECK (NODE)->u.pending_inline_info)\n \n-/* For a TYPE_DECL: if this structure has many fields, we'll sort them\n+/* For a class type: if this structure has many fields, we'll sort them\n    and put them into a TREE_VEC.  */\n-#define DECL_SORTED_FIELDS(NODE) \\\n-  (DECL_LANG_SPECIFIC (TYPE_DECL_CHECK (NODE))->u.f.u.sorted_fields)\n+#define CLASSTYPE_SORTED_FIELDS(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->sorted_fields)\n \n /* True if on the deferred_fns (see decl2.c) list.  */\n #define DECL_DEFERRED_FN(DECL) \\\n-  (DECL_LANG_SPECIFIC (DECL)->decl_flags.deferred)\n+  (LANG_DECL_FN_CHECK (DECL)->deferred)\n \n /* If non-NULL for a VAR_DECL, FUNCTION_DECL, TYPE_DECL or\n    TEMPLATE_DECL, the entity is either a template specialization (if\n@@ -2190,7 +2222,7 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n    will be non-NULL, but DECL_USE_TEMPLATE will be zero.  */\n #define DECL_TEMPLATE_INFO(NODE) \\\n   (DECL_LANG_SPECIFIC (VAR_TEMPL_TYPE_OR_FUNCTION_DECL_CHECK (NODE)) \\\n-   ->decl_flags.u.template_info)\n+   ->u.min.template_info)\n \n /* For a VAR_DECL, indicates that the variable is actually a\n    non-static data member of anonymous union that has been promoted to\n@@ -2440,8 +2472,8 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n \n /* In a FUNCTION_DECL, the saved language-specific per-function data.  */\n #define DECL_SAVED_FUNCTION_DATA(NODE)\t\t\t\\\n-  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE))\t\\\n-   ->u.f.u.saved_language_function)\n+  (LANG_DECL_FN_CHECK (FUNCTION_DECL_CHECK (NODE))\t\\\n+   ->u.saved_language_function)\n \n /* Indicates an indirect_expr is for converting a reference.  */\n #define REFERENCE_REF_P(NODE) \\\n@@ -2617,26 +2649,26 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    declared inside a class.  In the latter case DECL_HIDDEN_FRIEND_P\n    will be set.  */\n #define DECL_ANTICIPATED(NODE) \\\n-  (DECL_LANG_SPECIFIC (DECL_COMMON_CHECK (NODE))->decl_flags.anticipated_p)\n+  (DECL_LANG_SPECIFIC (DECL_COMMON_CHECK (NODE))->u.base.anticipated_p)\n \n /* Nonzero if NODE is a FUNCTION_DECL which was declared as a friend\n    within a class but has not been declared in the surrounding scope.\n    The function is invisible except via argument dependent lookup.  */\n #define DECL_HIDDEN_FRIEND_P(NODE) \\\n-  (DECL_LANG_SPECIFIC (DECL_COMMON_CHECK (NODE))->decl_flags.hidden_friend_p)\n+  (LANG_DECL_FN_CHECK (DECL_COMMON_CHECK (NODE))->hidden_friend_p)\n \n /* Nonzero if DECL has been declared threadprivate by\n    #pragma omp threadprivate.  */\n #define CP_DECL_THREADPRIVATE_P(DECL) \\\n-  (DECL_LANG_SPECIFIC (VAR_DECL_CHECK (DECL))->decl_flags.threadprivate_or_deleted_p)\n+  (DECL_LANG_SPECIFIC (VAR_DECL_CHECK (DECL))->u.base.threadprivate_or_deleted_p)\n \n /* Nonzero if DECL was declared with '= delete'.  */\n #define DECL_DELETED_FN(DECL) \\\n-  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (DECL))->decl_flags.threadprivate_or_deleted_p)\n+  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (DECL))->u.base.threadprivate_or_deleted_p)\n \n /* Nonzero if DECL was declared with '= default'.  */\n #define DECL_DEFAULTED_FN(DECL) \\\n-  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (DECL))->decl_flags.defaulted_p)\n+  (LANG_DECL_FN_CHECK (DECL)->defaulted_p)\n \n /* Record whether a typedef for type `int' was actually `signed int'.  */\n #define C_TYPEDEF_EXPLICITLY_SIGNED(EXP) DECL_LANG_FLAG_1 (EXP)\n@@ -3046,11 +3078,11 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n \n /* Nonzero if the FUNCTION_DECL is a global constructor.  */\n #define DECL_GLOBAL_CTOR_P(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.global_ctor_p)\n+  (LANG_DECL_FN_CHECK (NODE)->global_ctor_p)\n \n /* Nonzero if the FUNCTION_DECL is a global destructor.  */\n #define DECL_GLOBAL_DTOR_P(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.global_dtor_p)\n+  (LANG_DECL_FN_CHECK (NODE)->global_dtor_p)\n \n /* Accessor macros for C++ template decl nodes.  */\n \n@@ -3151,6 +3183,10 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define DECL_DECLARES_TYPE_P(NODE) \\\n   (TREE_CODE (NODE) == TYPE_DECL || DECL_CLASS_TEMPLATE_P (NODE))\n \n+/* Nonzero if NODE declares a function.  */\n+#define DECL_DECLARES_FUNCTION_P(NODE) \\\n+  (TREE_CODE (NODE) == FUNCTION_DECL || DECL_FUNCTION_TEMPLATE_P (NODE))\n+\n /* Nonzero if NODE is the typedef implicitly generated for a type when\n    the type is declared.  In C++, `struct S {};' is roughly\n    equivalent to `struct S {}; typedef struct S S;' in C.\n@@ -3204,7 +3240,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n \n    If DECL_USE_TEMPLATE is nonzero, then DECL_TEMPLATE_INFO will also\n    be non-NULL.  */\n-#define DECL_USE_TEMPLATE(NODE) (DECL_LANG_SPECIFIC (NODE)->decl_flags.use_template)\n+#define DECL_USE_TEMPLATE(NODE) (DECL_LANG_SPECIFIC (NODE)->u.base.use_template)\n \n /* Like DECL_USE_TEMPLATE, but for class types.  */\n #define CLASSTYPE_USE_TEMPLATE(NODE) \\\n@@ -3277,7 +3313,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    current translation unit; it indicates whether or not we should emit the\n    decl at the end of compilation if it is defined and needed.  */\n #define DECL_NOT_REALLY_EXTERN(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.not_really_extern)\n+  (DECL_LANG_SPECIFIC (NODE)->u.base.not_really_extern)\n \n #define DECL_REALLY_EXTERN(NODE) \\\n   (DECL_EXTERNAL (NODE) && ! DECL_NOT_REALLY_EXTERN (NODE))\n@@ -3324,7 +3360,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n /* An integer indicating how many bytes should be subtracted from the\n    this or result pointer when this function is called.  */\n #define THUNK_FIXED_OFFSET(DECL) \\\n-  (DECL_LANG_SPECIFIC (THUNK_FUNCTION_CHECK (DECL))->u.f.u5.fixed_offset)\n+  (DECL_LANG_SPECIFIC (THUNK_FUNCTION_CHECK (DECL))->u.fn.u5.fixed_offset)\n \n /* A tree indicating how to perform the virtual adjustment. For a this\n    adjusting thunk it is the number of bytes to be added to the vtable\n@@ -3341,12 +3377,12 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n \n /* A thunk which is equivalent to another thunk.  */\n #define THUNK_ALIAS(DECL) \\\n-  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (DECL))->decl_flags.u.template_info)\n+  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (DECL))->u.min.template_info)\n \n /* For thunk NODE, this is the FUNCTION_DECL thunked to.  It is\n    possible for the target to be a thunk too.  */\n #define THUNK_TARGET(NODE)\t\t\t\t\\\n-  (DECL_LANG_SPECIFIC (NODE)->u.f.befriending_classes)\n+  (LANG_DECL_FN_CHECK (NODE)->befriending_classes)\n \n /* True for a SCOPE_REF iff the \"template\" keyword was used to\n    indicate that the qualified name denotes a template.  */\n@@ -4258,6 +4294,7 @@ extern bool type_has_user_provided_constructor  (tree);\n extern bool type_has_user_provided_default_constructor (tree);\n extern bool defaultable_fn_p\t\t\t(tree);\n extern void fixup_type_variants\t\t\t(tree);\n+extern tree* decl_cloned_function_p\t\t(const_tree, bool);\n extern void clone_function_decl\t\t\t(tree, int);\n extern void adjust_clone_args\t\t\t(tree);\n "}, {"sha": "dc2ef1eb30cd027006e298e22f5bb8e046d4054f", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b97e8a149d534e07f19af44c23882d9f09df575f", "patch": "@@ -873,7 +873,7 @@ push_local_name (tree decl)\n \t{\n \t  if (!DECL_LANG_SPECIFIC (decl))\n \t    retrofit_lang_decl (decl);\n-\t  DECL_LANG_SPECIFIC (decl)->decl_flags.u2sel = 1;\n+\t  DECL_LANG_SPECIFIC (decl)->u.base.u2sel = 1;\n \t  if (DECL_LANG_SPECIFIC (t))\n \t    DECL_DISCRIMINATOR (decl) = DECL_DISCRIMINATOR (t) + 1;\n \t  else\n@@ -1786,9 +1786,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t{\n \t  DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n \t  DECL_SOURCE_LOCATION (newdecl) = DECL_SOURCE_LOCATION (olddecl);\n-\t  if (CAN_HAVE_FULL_LANG_DECL_P (newdecl)\n-\t      && DECL_LANG_SPECIFIC (newdecl)\n-\t      && DECL_LANG_SPECIFIC (olddecl))\n+\t  if (TREE_CODE (newdecl) == FUNCTION_DECL)\n \t    {\n \t      DECL_SAVED_TREE (newdecl) = DECL_SAVED_TREE (olddecl);\n \t      DECL_STRUCT_FUNCTION (newdecl) = DECL_STRUCT_FUNCTION (olddecl);\n@@ -1894,24 +1892,27 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n       /* Don't really know how much of the language-specific\n \t values we should copy from old to new.  */\n       DECL_IN_AGGR_P (newdecl) = DECL_IN_AGGR_P (olddecl);\n-      DECL_LANG_SPECIFIC (newdecl)->decl_flags.u2 =\n-\tDECL_LANG_SPECIFIC (olddecl)->decl_flags.u2;\n-      DECL_NONCONVERTING_P (newdecl) = DECL_NONCONVERTING_P (olddecl);\n       DECL_REPO_AVAILABLE_P (newdecl) = DECL_REPO_AVAILABLE_P (olddecl);\n-      if (DECL_TEMPLATE_INFO (newdecl))\n-\tnew_template_info = DECL_TEMPLATE_INFO (newdecl);\n-      DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);\n       DECL_INITIALIZED_IN_CLASS_P (newdecl)\n \t|= DECL_INITIALIZED_IN_CLASS_P (olddecl);\n-      olddecl_friend = DECL_FRIEND_P (olddecl);\n-      hidden_friend = (DECL_ANTICIPATED (olddecl)\n-\t\t       && DECL_HIDDEN_FRIEND_P (olddecl)\n-\t\t       && newdecl_is_friend);\n \n-      /* Only functions have DECL_BEFRIENDING_CLASSES.  */\n+      if (LANG_DECL_HAS_MIN (newdecl))\n+\t{\n+\t  DECL_LANG_SPECIFIC (newdecl)->u.min.u2 =\n+\t    DECL_LANG_SPECIFIC (olddecl)->u.min.u2;\n+\t  if (DECL_TEMPLATE_INFO (newdecl))\n+\t    new_template_info = DECL_TEMPLATE_INFO (newdecl);\n+\t  DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);\n+\t}\n+      /* Only functions have these fields.  */\n       if (TREE_CODE (newdecl) == FUNCTION_DECL\n \t  || DECL_FUNCTION_TEMPLATE_P (newdecl))\n \t{\n+\t  DECL_NONCONVERTING_P (newdecl) = DECL_NONCONVERTING_P (olddecl);\n+\t  olddecl_friend = DECL_FRIEND_P (olddecl);\n+\t  hidden_friend = (DECL_ANTICIPATED (olddecl)\n+\t\t\t   && DECL_HIDDEN_FRIEND_P (olddecl)\n+\t\t\t   && newdecl_is_friend);\n \t  DECL_BEFRIENDING_CLASSES (newdecl)\n \t    = chainon (DECL_BEFRIENDING_CLASSES (newdecl),\n \t\t       DECL_BEFRIENDING_CLASSES (olddecl));\n@@ -12582,16 +12583,6 @@ finish_method (tree decl)\n \n   DECL_INITIAL (fndecl) = old_initial;\n \n-  /* We used to check if the context of FNDECL was different from\n-     current_class_type as another way to get inside here.  This didn't work\n-     for String.cc in libg++.  */\n-  if (DECL_FRIEND_P (fndecl))\n-    {\n-      VEC_safe_push (tree, gc, CLASSTYPE_INLINE_FRIENDS (current_class_type),\n-\t\t     fndecl);\n-      decl = void_type_node;\n-    }\n-\n   return decl;\n }\n \f"}, {"sha": "6be57a66781e0882d073c8ffead1105ec86d8a8b", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=b97e8a149d534e07f19af44c23882d9f09df575f", "patch": "@@ -2634,7 +2634,6 @@ start_objects (int method_type, int initp)\n     DECL_GLOBAL_CTOR_P (current_function_decl) = 1;\n   else\n     DECL_GLOBAL_DTOR_P (current_function_decl) = 1;\n-  DECL_LANG_SPECIFIC (current_function_decl)->decl_flags.u2sel = 1;\n \n   body = begin_compound_stmt (BCS_FN_BODY);\n "}, {"sha": "850f4069a17ebb2d34382bcdb2a9923f3315dace", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=b97e8a149d534e07f19af44c23882d9f09df575f", "patch": "@@ -1406,7 +1406,7 @@ dump_function_name (tree t, int flags)\n       pp_cxx_ws_string (cxx_pp, \"operator\");\n       dump_type (TREE_TYPE (TREE_TYPE (t)), flags);\n     }\n-  else if (IDENTIFIER_OPNAME_P (name))\n+  else if (name && IDENTIFIER_OPNAME_P (name))\n     pp_cxx_tree_identifier (cxx_pp, name);\n   else\n     dump_decl (name, flags);"}, {"sha": "5effd7a0d77f4444eb473ed1961aa58a81b941f9", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=b97e8a149d534e07f19af44c23882d9f09df575f", "patch": "@@ -532,19 +532,20 @@ retrofit_lang_decl (tree t)\n {\n   struct lang_decl *ld;\n   size_t size;\n-\n-  if (CAN_HAVE_FULL_LANG_DECL_P (t))\n-    size = sizeof (struct lang_decl);\n+  int sel;\n+\n+  if (TREE_CODE (t) == FUNCTION_DECL)\n+    sel = 1, size = sizeof (struct lang_decl_fn);\n+  else if (TREE_CODE (t) == NAMESPACE_DECL)\n+    sel = 2, size = sizeof (struct lang_decl_ns);\n+  else if (LANG_DECL_HAS_MIN (t))\n+    sel = 0, size = sizeof (struct lang_decl_min);\n   else\n-    size = sizeof (struct lang_decl_flags);\n+    gcc_unreachable ();\n \n   ld = GGC_CNEWVAR (struct lang_decl, size);\n \n-  ld->decl_flags.can_be_full = CAN_HAVE_FULL_LANG_DECL_P (t) ? 1 : 0;\n-  ld->decl_flags.u1sel = TREE_CODE (t) == NAMESPACE_DECL ? 1 : 0;\n-  ld->decl_flags.u2sel = 0;\n-  if (ld->decl_flags.can_be_full)\n-    ld->u.f.u3sel = TREE_CODE (t) == FUNCTION_DECL ? 1 : 0;\n+  ld->u.base.selector = sel;\n \n   DECL_LANG_SPECIFIC (t) = ld;\n   if (current_lang_name == lang_name_cplusplus\n@@ -572,10 +573,15 @@ cxx_dup_lang_specific_decl (tree node)\n   if (! DECL_LANG_SPECIFIC (node))\n     return;\n \n-  if (!CAN_HAVE_FULL_LANG_DECL_P (node))\n-    size = sizeof (struct lang_decl_flags);\n+  if (TREE_CODE (node) == FUNCTION_DECL)\n+    size = sizeof (struct lang_decl_fn);\n+  else if (TREE_CODE (node) == NAMESPACE_DECL)\n+    size = sizeof (struct lang_decl_ns);\n+  else if (LANG_DECL_HAS_MIN (node))\n+    size = sizeof (struct lang_decl_min);\n   else\n-    size = sizeof (struct lang_decl);\n+    gcc_unreachable ();\n+\n   ld = GGC_NEWVAR (struct lang_decl, size);\n   memcpy (ld, DECL_LANG_SPECIFIC (node), size);\n   DECL_LANG_SPECIFIC (node) = ld;"}, {"sha": "fe2f6fd89b945bb99fd21d8482575f914b89621c", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 38, "deletions": 27, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=b97e8a149d534e07f19af44c23882d9f09df575f", "patch": "@@ -1088,43 +1088,54 @@ write_unqualified_name (const tree decl)\n {\n   MANGLE_TRACE_TREE (\"unqualified-name\", decl);\n \n-  if (DECL_LANG_SPECIFIC (decl) != NULL && DECL_CONSTRUCTOR_P (decl))\n-    write_special_name_constructor (decl);\n-  else if (DECL_LANG_SPECIFIC (decl) != NULL && DECL_DESTRUCTOR_P (decl))\n-    write_special_name_destructor (decl);\n-  else if (DECL_NAME (decl) == NULL_TREE)\n+  if (DECL_NAME (decl) == NULL_TREE)\n     {\n       gcc_assert (DECL_ASSEMBLER_NAME_SET_P (decl));\n       write_source_name (DECL_ASSEMBLER_NAME (decl));\n+      return;\n     }\n-  else if (DECL_CONV_FN_P (decl))\n+  else if (DECL_DECLARES_FUNCTION_P (decl))\n     {\n-      /* Conversion operator. Handle it right here.\n-\t   <operator> ::= cv <type>  */\n-      tree type;\n-      if (decl_is_template_id (decl, NULL))\n+      bool found = true;\n+      if (DECL_CONSTRUCTOR_P (decl))\n+\twrite_special_name_constructor (decl);\n+      else if (DECL_DESTRUCTOR_P (decl))\n+\twrite_special_name_destructor (decl);\n+      else if (DECL_CONV_FN_P (decl))\n \t{\n-\t  tree fn_type;\n-\t  fn_type = get_mostly_instantiated_function_type (decl);\n-\t  type = TREE_TYPE (fn_type);\n+\t  /* Conversion operator. Handle it right here.\n+\t     <operator> ::= cv <type>  */\n+\t  tree type;\n+\t  if (decl_is_template_id (decl, NULL))\n+\t    {\n+\t      tree fn_type;\n+\t      fn_type = get_mostly_instantiated_function_type (decl);\n+\t      type = TREE_TYPE (fn_type);\n+\t    }\n+\t  else\n+\t    type = DECL_CONV_FN_TYPE (decl);\n+\t  write_conversion_operator_name (type);\n+\t}\n+      else if (DECL_OVERLOADED_OPERATOR_P (decl))\n+\t{\n+\t  operator_name_info_t *oni;\n+\t  if (DECL_ASSIGNMENT_OPERATOR_P (decl))\n+\t    oni = assignment_operator_name_info;\n+\t  else\n+\t    oni = operator_name_info;\n+\n+\t  write_string (oni[DECL_OVERLOADED_OPERATOR_P (decl)].mangled_name);\n \t}\n       else\n-\ttype = DECL_CONV_FN_TYPE (decl);\n-      write_conversion_operator_name (type);\n-    }\n-  else if (DECL_OVERLOADED_OPERATOR_P (decl))\n-    {\n-      operator_name_info_t *oni;\n-      if (DECL_ASSIGNMENT_OPERATOR_P (decl))\n-\toni = assignment_operator_name_info;\n-      else\n-\toni = operator_name_info;\n+\tfound = false;\n \n-      write_string (oni[DECL_OVERLOADED_OPERATOR_P (decl)].mangled_name);\n+      if (found)\n+\treturn;\n     }\n-  else if (VAR_OR_FUNCTION_DECL_P (decl) && ! TREE_PUBLIC (decl)\n-\t   && DECL_NAMESPACE_SCOPE_P (decl)\n-\t   && decl_linkage (decl) == lk_internal)\n+\n+  if (VAR_OR_FUNCTION_DECL_P (decl) && ! TREE_PUBLIC (decl)\n+      && DECL_NAMESPACE_SCOPE_P (decl)\n+      && decl_linkage (decl) == lk_internal)\n     {\n       MANGLE_TRACE_TREE (\"local-source-name\", decl);\n       write_char ('L');"}, {"sha": "4e22a20851053c8a7af726fae12411abf979a9de", "filename": "gcc/cp/method.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=b97e8a149d534e07f19af44c23882d9f09df575f", "patch": "@@ -277,7 +277,6 @@ make_alias_for (tree function, tree newid)\n   DECL_SAVED_FUNCTION_DATA (alias) = NULL;\n   DECL_DESTRUCTOR_P (alias) = 0;\n   DECL_CONSTRUCTOR_P (alias) = 0;\n-  DECL_CLONED_FUNCTION (alias) = NULL_TREE;\n   DECL_EXTERNAL (alias) = 0;\n   DECL_ARTIFICIAL (alias) = 1;\n   DECL_NO_STATIC_CHAIN (alias) = 1;"}, {"sha": "b93c811ed5aceae873d7129df62d73105f845438", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b97e8a149d534e07f19af44c23882d9f09df575f", "patch": "@@ -3458,17 +3458,6 @@ build_template_decl (tree decl, tree parms, bool member_template_p)\n   DECL_TEMPLATE_PARMS (tmpl) = parms;\n   DECL_CONTEXT (tmpl) = DECL_CONTEXT (decl);\n   DECL_MEMBER_TEMPLATE_P (tmpl) = member_template_p;\n-  if (DECL_LANG_SPECIFIC (decl))\n-    {\n-      DECL_STATIC_FUNCTION_P (tmpl) = DECL_STATIC_FUNCTION_P (decl);\n-      DECL_CONSTRUCTOR_P (tmpl) = DECL_CONSTRUCTOR_P (decl);\n-      DECL_DESTRUCTOR_P (tmpl) = DECL_DESTRUCTOR_P (decl);\n-      DECL_NONCONVERTING_P (tmpl) = DECL_NONCONVERTING_P (decl);\n-      DECL_ASSIGNMENT_OPERATOR_P (tmpl) = DECL_ASSIGNMENT_OPERATOR_P (decl);\n-      if (DECL_OVERLOADED_OPERATOR_P (decl))\n-\tSET_OVERLOADED_OPERATOR_CODE (tmpl,\n-\t\t\t\t      DECL_OVERLOADED_OPERATOR_P (decl));\n-    }\n \n   return tmpl;\n }\n@@ -3792,6 +3781,7 @@ check_default_tmpl_args (tree decl, tree parms, int is_primary,\n   if (current_class_type\n       && !TYPE_BEING_DEFINED (current_class_type)\n       && DECL_LANG_SPECIFIC (decl)\n+      && DECL_DECLARES_FUNCTION_P (decl)\n       /* If this is either a friend defined in the scope of the class\n \t or a member function.  */\n       && (DECL_FUNCTION_MEMBER_P (decl)\n@@ -8594,13 +8584,8 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \tDECL_SAVED_TREE (r) = NULL_TREE;\n \tDECL_STRUCT_FUNCTION (r) = NULL;\n \tTREE_USED (r) = 0;\n-\tif (DECL_CLONED_FUNCTION (r))\n-\t  {\n-\t    DECL_CLONED_FUNCTION (r) = tsubst (DECL_CLONED_FUNCTION (t),\n-\t\t\t\t\t       args, complain, t);\n-\t    TREE_CHAIN (r) = TREE_CHAIN (DECL_CLONED_FUNCTION (r));\n-\t    TREE_CHAIN (DECL_CLONED_FUNCTION (r)) = r;\n-\t  }\n+\t/* We'll re-clone as appropriate in instantiate_template.  */\n+\tDECL_CLONED_FUNCTION (r) = NULL_TREE;\n \n \t/* Set up the DECL_TEMPLATE_INFO for R.  There's no need to do\n \t   this in the special friend case mentioned above where\n@@ -12330,8 +12315,10 @@ instantiate_template (tree tmpl, tree orig_args, tsubst_flags_t complain)\n       tree spec;\n       tree clone;\n \n-      spec = instantiate_template (DECL_CLONED_FUNCTION (tmpl), targ_ptr,\n-\t\t\t\t   complain);\n+      /* Use DECL_ABSTRACT_ORIGIN because only FUNCTION_DECLs have\n+\t DECL_CLONED_FUNCTION.  */\n+      spec = instantiate_template (DECL_ABSTRACT_ORIGIN (tmpl),\n+\t\t\t\t   targ_ptr, complain);\n       if (spec == error_mark_node)\n \treturn error_mark_node;\n "}, {"sha": "ec7a4712ba1b75666cbf2b052fcbf0898db3a15a", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=b97e8a149d534e07f19af44c23882d9f09df575f", "patch": "@@ -65,10 +65,6 @@ cxx_print_decl (FILE *file, tree node, int indent)\n       && DECL_PENDING_INLINE_INFO (node))\n     fprintf (file, \" pending-inline-info %p\",\n \t     (void *) DECL_PENDING_INLINE_INFO (node));\n-  if (TREE_CODE (node) == TYPE_DECL\n-      && DECL_SORTED_FIELDS (node))\n-    fprintf (file, \" sorted-fields %p\",\n-\t     (void *) DECL_SORTED_FIELDS (node));\n   if ((TREE_CODE (node) == FUNCTION_DECL || TREE_CODE (node) == VAR_DECL)\n       && DECL_TEMPLATE_INFO (node))\n     fprintf (file, \" template-info %p\",\n@@ -95,13 +91,6 @@ cxx_print_type (FILE *file, tree node, int indent)\n \tprint_node (file, \"throws\", TYPE_RAISES_EXCEPTIONS (node), indent + 4);\n       return;\n \n-    case RECORD_TYPE:\n-    case UNION_TYPE:\n-      indent_to (file, indent + 4);\n-      fprintf (file, \"full-name \\\"%s\\\"\",\n-\t       type_as_string (node, TFF_CLASS_KEY_OR_ENUM));\n-      break;\n-\n     default:\n       return;\n     }\n@@ -113,6 +102,10 @@ cxx_print_type (FILE *file, tree node, int indent)\n   if (! CLASS_TYPE_P (node))\n     return;\n \n+  indent_to (file, indent + 4);\n+  fprintf (file, \"full-name \\\"%s\\\"\",\n+\t   type_as_string (node, TFF_CLASS_KEY_OR_ENUM));\n+\n   indent_to (file, indent + 3);\n \n   if (TYPE_NEEDS_CONSTRUCTING (node))\n@@ -140,6 +133,9 @@ cxx_print_type (FILE *file, tree node, int indent)\n     fputs (\" delete[]\", file);\n   if (TYPE_HAS_ASSIGN_REF (node))\n     fputs (\" this=(X&)\", file);\n+  if (CLASSTYPE_SORTED_FIELDS (node))\n+    fprintf (file, \" sorted-fields %p\",\n+\t     (void *) CLASSTYPE_SORTED_FIELDS (node));\n \n   if (TREE_CODE (node) == RECORD_TYPE)\n     {"}, {"sha": "c50cc4a0841154ea68a5aafb2fd7eb8b51b32215", "filename": "gcc/cp/search.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=b97e8a149d534e07f19af44c23882d9f09df575f", "patch": "@@ -395,12 +395,10 @@ lookup_field_1 (tree type, tree name, bool want_type)\n        The TYPE_FIELDS of TYPENAME_TYPE is its TYPENAME_TYPE_FULLNAME.  */\n     return NULL_TREE;\n \n-  if (TYPE_NAME (type)\n-      && DECL_LANG_SPECIFIC (TYPE_NAME (type))\n-      && DECL_SORTED_FIELDS (TYPE_NAME (type)))\n+  if (CLASSTYPE_SORTED_FIELDS (type))\n     {\n-      tree *fields = &DECL_SORTED_FIELDS (TYPE_NAME (type))->elts[0];\n-      int lo = 0, hi = DECL_SORTED_FIELDS (TYPE_NAME (type))->len;\n+      tree *fields = &CLASSTYPE_SORTED_FIELDS (type)->elts[0];\n+      int lo = 0, hi = CLASSTYPE_SORTED_FIELDS (type)->len;\n       int i;\n \n       while (lo < hi)"}, {"sha": "59a5312bca873eeac5aedbc67ab665351f71f411", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=b97e8a149d534e07f19af44c23882d9f09df575f", "patch": "@@ -3861,7 +3861,7 @@ finish_omp_threadprivate (tree vars)\n \t      /* Make sure that DECL_DISCRIMINATOR_P continues to be true\n \t\t after the allocation of the lang_decl structure.  */\n \t      if (DECL_DISCRIMINATOR_P (v))\n-\t\tDECL_LANG_SPECIFIC (v)->decl_flags.u2sel = 1;\n+\t\tDECL_LANG_SPECIFIC (v)->u.base.u2sel = 1;\n \t    }\n \n \t  if (! DECL_THREAD_LOCAL_P (v))"}, {"sha": "23ea945293014c7e456e4610b2ffd74bb29cab3e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b97e8a149d534e07f19af44c23882d9f09df575f", "patch": "@@ -1,3 +1,7 @@\n+2009-07-03  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/template/pure1.C: Expect another error.\n+\n 2009-07-03  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/40640"}, {"sha": "68dbe6bf0f5355ba09c646a4b30aace09b759d70", "filename": "gcc/testsuite/g++.dg/template/pure1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpure1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b97e8a149d534e07f19af44c23882d9f09df575f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpure1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpure1.C?ref=b97e8a149d534e07f19af44c23882d9f09df575f", "patch": "@@ -2,5 +2,5 @@\n \n struct A\n {\n-  template<int> void foo() = 1; // { dg-error \"pure\" }\n+  template<int> void foo() = 1; // { dg-error \"pure|non-virtual\" }\n };"}]}