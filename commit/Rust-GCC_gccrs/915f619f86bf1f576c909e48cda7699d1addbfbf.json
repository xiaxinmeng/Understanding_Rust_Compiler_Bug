{"sha": "915f619f86bf1f576c909e48cda7699d1addbfbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE1ZjYxOWY4NmJmMWY1NzZjOTA5ZTQ4Y2RhNzY5OWQxYWRkYmZiZg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-04-06T18:11:25Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-04-06T18:11:25Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r695", "tree": {"sha": "4adc19d14c38605b45cc1cb5a34773d790a9c6b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4adc19d14c38605b45cc1cb5a34773d790a9c6b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/915f619f86bf1f576c909e48cda7699d1addbfbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/915f619f86bf1f576c909e48cda7699d1addbfbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/915f619f86bf1f576c909e48cda7699d1addbfbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/915f619f86bf1f576c909e48cda7699d1addbfbf/comments", "author": null, "committer": null, "parents": [{"sha": "c468d2d0cd1cb26c4d7cecf85e2fa9724afd3ba0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c468d2d0cd1cb26c4d7cecf85e2fa9724afd3ba0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c468d2d0cd1cb26c4d7cecf85e2fa9724afd3ba0"}], "stats": {"total": 183, "additions": 120, "deletions": 63}, "files": [{"sha": "0791082f6b815c7a591e9b1ad14d43216cb1cd59", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/915f619f86bf1f576c909e48cda7699d1addbfbf/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/915f619f86bf1f576c909e48cda7699d1addbfbf/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=915f619f86bf1f576c909e48cda7699d1addbfbf", "patch": "@@ -131,6 +131,9 @@ extern int target_flags;\n /* Width of a word, in units (bytes).  */\n #define UNITS_PER_WORD 4\n \n+/* Type used for ptrdiff_t, as a string used in a declaration.  */\n+#define PTRDIFF_TYPE \"int\"\n+\n /* Type used for wchar_t, as a string used in a declaration.  */\n #define WCHAR_TYPE \"short unsigned int\"\n "}, {"sha": "6584320f8c32cac00d7f5b32396240730d3f356f", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 92, "deletions": 48, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/915f619f86bf1f576c909e48cda7699d1addbfbf/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/915f619f86bf1f576c909e48cda7699d1addbfbf/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=915f619f86bf1f576c909e48cda7699d1addbfbf", "patch": "@@ -491,8 +491,9 @@ eligible_for_epilogue_delay (trial, slot)\n   if (get_attr_length (trial) != 1)\n     return 0;\n \n-  /* In the case of a true leaf function, anything can\n-     go into the delay slot.  */\n+  /* In the case of a true leaf function, anything can go into the delay slot.\n+     A delay slot only exists however if the frame size is zero, otherwise\n+     we will put an insn to adjust the stack after the return.  */\n   if (leaf_function)\n     {\n       if (leaf_return_peephole_ok ())\n@@ -505,13 +506,10 @@ eligible_for_epilogue_delay (trial, slot)\n   pat = PATTERN (trial);\n   if (GET_CODE (SET_DEST (pat)) != REG\n       || REGNO (SET_DEST (pat)) == 0\n-      || (leaf_function\n-\t  && REGNO (SET_DEST (pat)) < 32\n-\t  && REGNO (SET_DEST (pat)) >= 16)\n-      || (! leaf_function\n-\t  && (REGNO (SET_DEST (pat)) >= 32\n-\t      || REGNO (SET_DEST (pat)) < 24)))\n+      || REGNO (SET_DEST (pat)) >= 32\n+      || REGNO (SET_DEST (pat)) < 24)\n     return 0;\n+\n   src = SET_SRC (pat);\n   if (arith_operand (src, GET_MODE (src)))\n     return GET_MODE_SIZE (GET_MODE (src)) <= GET_MODE_SIZE (SImode);\n@@ -946,9 +944,9 @@ singlemove_string (operands)\n     {\n       int i = INTVAL (operands[1]);\n \n-      /* If all low order 12 bits are clear, then we only need a single\n+      /* If all low order 10 bits are clear, then we only need a single\n \t sethi insn to load the constant.  */\n-      if (i & 0x00000FFF)\n+      if ((i & 0x000003FF) != 0)\n \treturn \"sethi %%hi(%a1),%0\\n\\tor %0,%%lo(%a1),%0\";\n       else\n \treturn \"sethi %%hi(%a1),%0\";\n@@ -1841,48 +1839,63 @@ compute_last_arg_offset ()\n   return 4096;\n }\n \n+/* Output code for the function prologue.  */\n+\n void\n output_function_prologue (file, size, leaf_function)\n      FILE *file;\n      int size;\n+     int leaf_function;\n {\n   if (leaf_function)\n     frame_base_name = \"%sp+80\";\n   else\n     frame_base_name = \"%fp\";\n \n+  /* Need to use actual_fsize, since we are also allocating\n+     space for our callee (and our own register save area).  */\n   actual_fsize = compute_frame_size (size, leaf_function);\n \n   fprintf (file, \"\\t!#PROLOGUE# 0\\n\");\n-  if (actual_fsize == 0) /* do nothing.  */ ;\n-  else if (actual_fsize < 4096)\n+  if (actual_fsize == 0)\n+    /* do nothing.  */ ;\n+  else if (actual_fsize <= 4096)\n     {\n       if (! leaf_function)\n \tfprintf (file, \"\\tsave %%sp,-%d,%%sp\\n\", actual_fsize);\n       else\n \tfprintf (file, \"\\tadd %%sp,-%d,%%sp\\n\", actual_fsize);\n     }\n-  else if (! leaf_function)\n+  else if (actual_fsize <= 8192)\n     {\n-      /* Need to use actual_fsize, since we are also allocating space for\n-\t our callee (and our own register save area).  */\n-      fprintf (file, \"\\tsethi %%hi(%d),%%g1\\n\\tor %%g1,%%lo(%d),%%g1\\n\",\n-\t       -actual_fsize, -actual_fsize);\n-      fprintf (file, \"\\tsave %%sp,%%g1,%%sp\\n\");\n+      /* For frames in the range 4097..8192, we can use just two insns.  */\n+      if (! leaf_function)\n+\t{\n+\t  fprintf (file, \"\\tsave %%sp,-4096,%%sp\\n\");\n+\t  fprintf (file, \"\\tadd %%sp,-%d,%%sp\\n\", actual_fsize - 4096);\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \"\\tadd %%sp,-4096,%%sp\\n\");\n+\t  fprintf (file, \"\\tadd %%sp,-%d,%%sp\\n\", actual_fsize - 4096);\n+\t}\n     }\n   else\n     {\n-      /* The rest of the support for this case hasn't been implemented,\n-\t but FRAME_POINTER_REQUIRED is supposed to prevent it from arising,\n-\t by checking the frame size.  */\n-      abort ();\n-\n-      /* Put pointer to parameters into %g4, and allocate\n-\t frame space using result computed into %g1.  actual_fsize\n-\t used instead of apparent_fsize for reasons stated above.  */\n-      fprintf (file, \"\\tsethi %%hi(%d),%%g1\\n\\tor %%g1,%%lo(%d),%%g1\\n\",\n-\t       -actual_fsize, -actual_fsize);\n-      fprintf (file, \"\\tadd %%sp,64,%%g4\\n\\tadd %%sp,%%g1,%%sp\\n\");\n+      if (! leaf_function)\n+\t{\n+\t  fprintf (file, \"\\tsethi %%hi(-%d),%%g1\\n\", actual_fsize);\n+\t  if ((actual_fsize & 0x3ff) != 0)\n+\t    fprintf (file, \"\\tor %%g1,%%lo(-%d),%%g1\\n\", actual_fsize);\n+\t  fprintf (file, \"\\tsave %%sp,%%g1,%%sp\\n\");\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \"\\tsethi %%hi(-%d),%%g1\\n\", actual_fsize);\n+\t  if ((actual_fsize & 0x3ff) != 0)\n+\t    fprintf (file, \"\\tor %%g1,%%lo(-%d),%%g1\\n\", actual_fsize);\n+\t  fprintf (file, \"\\tadd %%sp,%%g1,%%sp\\n\");\n+\t}\n     }\n \n   /* If doing anything with PIC, do it now.  */\n@@ -1922,6 +1935,8 @@ output_function_prologue (file, size, leaf_function)\n     }\n }\n \n+/* Output code for the function epilogue.  */\n+\n void\n output_function_epilogue (file, size, leaf_function)\n      FILE *file;\n@@ -1982,24 +1997,30 @@ output_function_epilogue (file, size, leaf_function)\n \t  else\n \t    fprintf (file, \"\\t%s\\n\\trestore\\n\", ret);\n \t}\n-      else if (actual_fsize < 4096)\n+      /* All of the following cases are for leaf functions.  */\n+      else if (current_function_epilogue_delay_list)\n \t{\n-\t  if (current_function_epilogue_delay_list)\n-\t    {\n-\t      fprintf (file, \"\\t%s\\n\", ret);\n-\t      final_scan_insn (XEXP (current_function_epilogue_delay_list, 0),\n-\t\t\t       file, 1, 0, 1);\n-\t    }\n-\t  else\n-\t    fprintf (file, \"\\t%s\\n\\tadd %%sp,%d,%%sp\\n\", ret, actual_fsize);\n-\t}\n-      else\n-\t{\n-\t  if (current_function_epilogue_delay_list)\n+\t  /* eligible_for_epilogue_delay_slot ensures that if this is a\n+\t     leaf function, then we will only have insn in the delay slot\n+\t     if the frame size is zero, thus no adjust for the stack is\n+\t     needed here.  */\n+\t  if (actual_fsize != 0)\n \t    abort ();\n-\t  fprintf (file, \"\\tsethi %%hi(%d),%%g1\\n\\tor %%g1,%%lo(%d),%%g1\\n\\t%s\\n\\tadd %%sp,%%g1,%%sp\\n\",\n-\t\t   actual_fsize, actual_fsize, ret);\n+\t  fprintf (file, \"\\t%s\\n\", ret);\n+\t  final_scan_insn (XEXP (current_function_epilogue_delay_list, 0),\n+\t\t\t   file, 1, 0, 1);\n \t}\n+      else if (actual_fsize <= 4096)\n+\tfprintf (file, \"\\t%s\\n\\tsub %%sp,-%d,%%sp\\n\", ret, actual_fsize);\n+      else if (actual_fsize <= 8192)\n+\tfprintf (file, \"\\tsub %%sp,-4096,%%sp\\n\\t%s\\n\\tsub %%sp,-%d,%%sp\\n\",\n+\t\t ret, actual_fsize - 4096);\n+      else if ((actual_fsize & 0x3ff) == 0)\n+\tfprintf (file, \"\\tsethi %%hi(%d),%%g1\\n\\t%s\\n\\tadd %%sp,%%g1,%%sp\\n\",\n+\t\t actual_fsize, ret);\n+      else\t\t \n+\tfprintf (file, \"\\tsethi %%hi(%d),%%g1\\n\\tor %%g1,%%lo(%d),%%g1\\n\\t%s\\n\\tadd %%sp,%%g1,%%sp\\n\",\n+\t\t actual_fsize, actual_fsize, ret);\n       target_flags |= old_target_epilogue;\n     }\n }\n@@ -2146,20 +2167,43 @@ output_return (operands)\n     }\n   else if (leaf_function)\n     {\n+      /* If we didn't allocate a frame pointer for the current function,\n+\t the stack pointer might have been adjusted.  Output code to\n+\t restore it now.  */\n+\n       operands[0] = gen_rtx (CONST_INT, VOIDmode, actual_fsize);\n-      if (actual_fsize < 4096)\n+\n+      /* Use sub of negated value in first two cases instead of add to\n+\t allow actual_fsize == 4096.  */\n+\n+      if (actual_fsize <= 4096)\n \t{\n \t  if (current_function_returns_struct)\n-\t    return \"jmp %%o7+12\\n\\tadd %%sp,%0,%%sp\";\n+\t    return \"jmp %%o7+12\\n\\tsub %%sp,-%0,%%sp\";\n \t  else\n-\t    return \"retl\\n\\tadd %%sp,%0,%%sp\";\n+\t    return \"retl\\n\\tsub %%sp,-%0,%%sp\";\n \t}\n-      else\n+      else if (actual_fsize <= 8192)\n \t{\n+\t  operands[0] = gen_rtx (CONST_INT, VOIDmode, actual_fsize - 4096);\n \t  if (current_function_returns_struct)\n+\t    return \"sub %%sp,-4096,%%sp\\n\\tjmp %%o7+12\\n\\tsub %%sp,-%0,%%sp\";\n+\t  else\n+\t    return \"sub %%sp,-4096,%%sp\\n\\tretl\\n\\tsub %%sp,-%0,%%sp\";\n+\t}\n+      else if (current_function_returns_struct)\n+\t{\n+\t  if ((actual_fsize & 0x3ff) != 0)\n \t    return \"sethi %%hi(%a0),%%g1\\n\\tor %%g1,%%lo(%a0),%%g1\\n\\tjmp %%o7+12\\n\\tadd %%sp,%%g1,%%sp\";\n \t  else\n+\t    return \"sethi %%hi(%a0),%%g1\\n\\tjmp %%o7+12\\n\\tadd %%sp,%%g1,%%sp\";\n+\t}\n+      else\n+\t{\n+\t  if ((actual_fsize & 0x3ff) != 0)\n \t    return \"sethi %%hi(%a0),%%g1\\n\\tor %%g1,%%lo(%a0),%%g1\\n\\tretl\\n\\tadd %%sp,%%g1,%%sp\";\n+\t  else\n+\t    return \"sethi %%hi(%a0),%%g1\\n\\tretl\\n\\tadd %%sp,%%g1,%%sp\";\n \t}\n     }\n   else"}, {"sha": "410fe64a2687cb510cc1fbdc6126ebca12939602", "filename": "gcc/jump.c", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/915f619f86bf1f576c909e48cda7699d1addbfbf/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/915f619f86bf1f576c909e48cda7699d1addbfbf/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=915f619f86bf1f576c909e48cda7699d1addbfbf", "patch": "@@ -116,7 +116,6 @@ int simplejump_p ();\n \n extern rtx gen_jump ();\n \n-void squeeze_notes ();\n static void mark_jump_label ();\n void delete_jump ();\n static void delete_from_jump_chain ();\n@@ -1429,8 +1428,8 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \n \t\t\t/* Don't move NOTEs for blocks or loops; shift them\n \t\t\t   outside the ranges, where they'll stay put.  */\n-\t\t\tsqueeze_notes (range1beg, range1end);\n-\t\t\tsqueeze_notes (range2beg, range2end);\n+\t\t\trange1beg = squeeze_notes (range1beg, range1end);\n+\t\t\trange2beg = squeeze_notes (range2beg, range2end);\n \n \t\t\t/* Get current surrounds of the 2 ranges.  */\n \t\t\trange1before = PREV_INSN (range1beg);\n@@ -1824,10 +1823,12 @@ duplicate_loop_exit_test (loop_start)\n }\n \f\n /* Move all block-beg, block-end, loop-beg, loop-cont, loop-vtop, and\n-   loop-end notes between START and END out before START.  Assume neither\n-   START nor END is such a note.  */\n+   loop-end notes between START and END out before START.  Assume that\n+   END is not such a note.  START may be such a note.  Returns the value\n+   of the new starting insn, which may be different if the original start\n+   was such a note.  */\n \n-void\n+rtx\n squeeze_notes (start, end)\n      rtx start, end;\n {\n@@ -1845,15 +1846,22 @@ squeeze_notes (start, end)\n \t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_CONT\n \t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_VTOP))\n \t{\n-\t  rtx prev = PREV_INSN (insn);\n-\t  PREV_INSN (insn) = PREV_INSN (start);\n-\t  NEXT_INSN (insn) = start;\n-\t  NEXT_INSN (PREV_INSN (insn)) = insn;\n-\t  PREV_INSN (NEXT_INSN (insn)) = insn;\n-\t  NEXT_INSN (prev) = next;\n-\t  PREV_INSN (next) = prev;\n+\t  if (insn == start)\n+\t    start = next;\n+\t  else\n+\t    {\n+\t      rtx prev = PREV_INSN (insn);\n+\t      PREV_INSN (insn) = PREV_INSN (start);\n+\t      NEXT_INSN (insn) = start;\n+\t      NEXT_INSN (PREV_INSN (insn)) = insn;\n+\t      PREV_INSN (NEXT_INSN (insn)) = insn;\n+\t      NEXT_INSN (prev) = next;\n+\t      PREV_INSN (next) = prev;\n+\t    }\n \t}\n     }\n+\n+  return start;\n }\n \f\n /* Compare the instructions before insn E1 with those before E2"}, {"sha": "4f255ef24cddba96cf4937bc7f1a2e899315066b", "filename": "gcc/loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/915f619f86bf1f576c909e48cda7699d1addbfbf/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/915f619f86bf1f576c909e48cda7699d1addbfbf/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=915f619f86bf1f576c909e48cda7699d1addbfbf", "patch": "@@ -2294,7 +2294,7 @@ find_and_verify_loops (f)\n \n \t\t       /* Include the BARRIER after INSN and copy the\n \t\t\t  block after LOC.  */\n-\t\t       squeeze_notes (new_label, NEXT_INSN (insn));\n+\t\t       new_label = squeeze_notes (new_label, NEXT_INSN (insn));\n \t\t       reorder_insns (new_label, NEXT_INSN (insn), loc);\n \n \t\t       /* All those insns are now in TARGET_LOOP_NUM.  */"}, {"sha": "6936302917f0e12d6264394b7211dfb83ca00473", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/915f619f86bf1f576c909e48cda7699d1addbfbf/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/915f619f86bf1f576c909e48cda7699d1addbfbf/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=915f619f86bf1f576c909e48cda7699d1addbfbf", "patch": "@@ -617,6 +617,7 @@ extern enum rtx_code unsigned_condition ();\n extern enum rtx_code signed_condition ();\n extern rtx plus_constant (), plus_constant_for_output ();\n extern rtx find_equiv_reg ();\n+extern rtx squeeze_notes ();\n extern rtx delete_insn ();\n extern void delete_jump ();\n extern rtx get_label_before ();"}, {"sha": "a999cb4f40201062acc201fd889bcf03fa283f02", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/915f619f86bf1f576c909e48cda7699d1addbfbf/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/915f619f86bf1f576c909e48cda7699d1addbfbf/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=915f619f86bf1f576c909e48cda7699d1addbfbf", "patch": "@@ -3752,7 +3752,8 @@ expand_end_case (orig_index)\n #endif\n \t}\n \n-      reorder_insns (NEXT_INSN (before_case), get_last_insn (),\n+      before_case = squeeze_notes (NEXT_INSN (before_case), get_last_insn ());\n+      reorder_insns (before_case, get_last_insn (),\n \t\t     thiscase->data.case_stmt.start);\n     }\n   if (thiscase->exit_label)"}]}