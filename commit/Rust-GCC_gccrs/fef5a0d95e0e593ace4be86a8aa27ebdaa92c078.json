{"sha": "fef5a0d95e0e593ace4be86a8aa27ebdaa92c078", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVmNWEwZDk1ZTBlNTkzYWNlNGJlODZhOGFhMjdlYmRhYTkyYzA3OA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-08-08T09:18:40Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-08-08T09:18:40Z"}, "message": "builtins.c (c_getstr, [...]): Export.\n\n2014-08-08  Richard Biener  <rguenther@suse.de>\n\n\t* builtins.c (c_getstr, readonly_data_expr, init_target_chars,\n\ttarget_percent, target_percent_s): Export.\n\t(var_decl_component_p, fold_builtin_memory_op, fold_builtin_memset,\n\tfold_builtin_bzero, fold_builtin_strcpy, fold_builtin_strncpy,\n\tfold_builtin_strcat, fold_builtin_fputs, fold_builtin_memory_chk,\n\tfold_builtin_stxcpy_chk, fold_builtin_stxncpy_chk,\n\tfold_builtin_sprintf_chk_1, fold_builtin_snprintf_chk_1):\n\tMove to gimple-fold.c.\n\t(fold_builtin_2): Remove handling of bzero, fputs, fputs_unlocked,\n\tstrcat and strcpy.\n\t(fold_builtin_3): Remove handling of memset, bcopy, memcpy,\n\tmempcpy, memmove, strncpy, strcpy_chk and stpcpy_chk.\n\t(fold_builtin_4): Remove handling of memcpy_chk, mempcpy_chk,\n\tmemmove_chk, memset_chk, strncpy_chk and stpncpy_chk.\n\t(rewrite_call_expr_array): Remove.\n\t(fold_builtin_sprintf_chk): Likewise.\n\t(fold_builtin_snprintf_chk): Likewise.\n\t(fold_builtin_varargs): Remove handling of sprintf_chk,\n\tvsprintf_chk, snprintf_chk and vsnprintf_chk.\n\t(gimple_fold_builtin_sprintf_chk): Remove.\n\t(gimple_fold_builtin_snprintf_chk): Likewise.\n\t(gimple_fold_builtin_varargs): Likewise.\n\t(fold_call_stmt): Do not call gimple_fold_builtin_varargs.\n\t* predict.c (optimize_bb_for_size_p): Handle NULL bb.\n\t* gimple.c (gimple_seq_add_seq_without_update): New function.\n\t* gimple.h (gimple_seq_add_seq_without_update): Declare.\n\t* gimple-fold.c: Include output.h.\n\t(gsi_replace_with_seq_vops): New function, split out from ...\n\t(gimplify_and_update_call_from_tree): ... here.\n\t(replace_call_with_value): New function.\n\t(replace_call_with_call_and_fold): Likewise.\n\t(var_decl_component_p): Moved from builtins.c.\n\t(gimple_fold_builtin_memory_op): Moved from builtins.c\n\tfold_builtin_memory_op and rewritten to GIMPLE.\n\t(gimple_fold_builtin_memset): Likewise.\n\t(gimple_fold_builtin_strcpy): Likewise.\n\t(gimple_fold_builtin_strncpy): Likewise.\n\t(gimple_fold_builtin_strcat): Likewise.\n\t(gimple_fold_builtin_fputs): Likewise.\n\t(gimple_fold_builtin_memory_chk): Likewise.\n\t(gimple_fold_builtin_stxcpy_chk): Likewise.\n\t(gimple_fold_builtin_stxncpy_chk): Likewise.\n\t(gimple_fold_builtin_snprintf_chk): Likewise.\n\t(gimple_fold_builtin_sprintf_chk): Likewise.\n\t(gimple_fold_builtin_strlen): New function.\n\t(gimple_fold_builtin_with_strlen): New function split out from\n\tgimple_fold_builtin.\n\t(gimple_fold_builtin): Change signature and handle\n\tbzero, memset, bcopy, memcpy, mempcpy and memmove folding\n\there.  Call gimple_fold_builtin_with_strlen.\n\t(gimple_fold_call): Adjust.\n\n\t* gcc.dg/strlenopt-8.c: Remove XFAIL.\n\t* gcc.dg/tree-prof/stringop-2.c: Adjust.\n\t* gfortran.dg/array_memcpy_4.f90: Likewise.\n\t* gfortran.dg/trim_optimize_1.f90: Likewise.\n\t* gfortran.dg/trim_optimize_2.f90: Likewise.\n\nFrom-SVN: r213753", "tree": {"sha": "621bf63e4a68ad2ac887a0c87d72c5746a320a34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/621bf63e4a68ad2ac887a0c87d72c5746a320a34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "322d490e02ff3008949d14370e651c89290465a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/322d490e02ff3008949d14370e651c89290465a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/322d490e02ff3008949d14370e651c89290465a6"}], "stats": {"total": 3239, "additions": 1659, "deletions": 1580}, "files": [{"sha": "3c5cc47cdba0473941cd5ca65293abf11ab7713a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fef5a0d95e0e593ace4be86a8aa27ebdaa92c078", "patch": "@@ -1,3 +1,57 @@\n+2014-08-08  Richard Biener  <rguenther@suse.de>\n+\n+\t* builtins.c (c_getstr, readonly_data_expr, init_target_chars,\n+\ttarget_percent, target_percent_s): Export.\n+\t(var_decl_component_p, fold_builtin_memory_op, fold_builtin_memset,\n+\tfold_builtin_bzero, fold_builtin_strcpy, fold_builtin_strncpy,\n+\tfold_builtin_strcat, fold_builtin_fputs, fold_builtin_memory_chk,\n+\tfold_builtin_stxcpy_chk, fold_builtin_stxncpy_chk,\n+\tfold_builtin_sprintf_chk_1, fold_builtin_snprintf_chk_1):\n+\tMove to gimple-fold.c.\n+\t(fold_builtin_2): Remove handling of bzero, fputs, fputs_unlocked,\n+\tstrcat and strcpy.\n+\t(fold_builtin_3): Remove handling of memset, bcopy, memcpy,\n+\tmempcpy, memmove, strncpy, strcpy_chk and stpcpy_chk.\n+\t(fold_builtin_4): Remove handling of memcpy_chk, mempcpy_chk,\n+\tmemmove_chk, memset_chk, strncpy_chk and stpncpy_chk.\n+\t(rewrite_call_expr_array): Remove.\n+\t(fold_builtin_sprintf_chk): Likewise.\n+\t(fold_builtin_snprintf_chk): Likewise.\n+\t(fold_builtin_varargs): Remove handling of sprintf_chk,\n+\tvsprintf_chk, snprintf_chk and vsnprintf_chk.\n+\t(gimple_fold_builtin_sprintf_chk): Remove.\n+\t(gimple_fold_builtin_snprintf_chk): Likewise.\n+\t(gimple_fold_builtin_varargs): Likewise.\n+\t(fold_call_stmt): Do not call gimple_fold_builtin_varargs.\n+\t* predict.c (optimize_bb_for_size_p): Handle NULL bb.\n+\t* gimple.c (gimple_seq_add_seq_without_update): New function.\n+\t* gimple.h (gimple_seq_add_seq_without_update): Declare.\n+\t* gimple-fold.c: Include output.h.\n+\t(gsi_replace_with_seq_vops): New function, split out from ...\n+\t(gimplify_and_update_call_from_tree): ... here.\n+\t(replace_call_with_value): New function.\n+\t(replace_call_with_call_and_fold): Likewise.\n+\t(var_decl_component_p): Moved from builtins.c.\n+\t(gimple_fold_builtin_memory_op): Moved from builtins.c\n+\tfold_builtin_memory_op and rewritten to GIMPLE.\n+\t(gimple_fold_builtin_memset): Likewise.\n+\t(gimple_fold_builtin_strcpy): Likewise.\n+\t(gimple_fold_builtin_strncpy): Likewise.\n+\t(gimple_fold_builtin_strcat): Likewise.\n+\t(gimple_fold_builtin_fputs): Likewise.\n+\t(gimple_fold_builtin_memory_chk): Likewise.\n+\t(gimple_fold_builtin_stxcpy_chk): Likewise.\n+\t(gimple_fold_builtin_stxncpy_chk): Likewise.\n+\t(gimple_fold_builtin_snprintf_chk): Likewise.\n+\t(gimple_fold_builtin_sprintf_chk): Likewise.\n+\t(gimple_fold_builtin_strlen): New function.\n+\t(gimple_fold_builtin_with_strlen): New function split out from\n+\tgimple_fold_builtin.\n+\t(gimple_fold_builtin): Change signature and handle\n+\tbzero, memset, bcopy, memcpy, mempcpy and memmove folding\n+\there.  Call gimple_fold_builtin_with_strlen.\n+\t(gimple_fold_call): Adjust.\n+\n 2014-08-08  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \n \t* calls.c (precompute_arguments): Check"}, {"sha": "c1bd263471660f64b1cc909e9041213c4b4ca62f", "filename": "gcc/builtins.c", "status": "modified", "additions": 9, "deletions": 1294, "changes": 1303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=fef5a0d95e0e593ace4be86a8aa27ebdaa92c078", "patch": "@@ -86,7 +86,6 @@ builtin_info_type builtin_info;\n /* Non-zero if __builtin_constant_p should be folded right away.  */\n bool force_folding_builtin_constant_p;\n \n-static const char *c_getstr (tree);\n static rtx c_readstr (const char *, enum machine_mode);\n static int target_char_cast (tree, char *);\n static rtx get_memory_rtx (tree, tree);\n@@ -148,7 +147,6 @@ static tree rewrite_call_expr (location_t, tree, int, tree, int, ...);\n static bool validate_arg (const_tree, enum tree_code code);\n static bool integer_valued_real_p (tree);\n static tree fold_trunc_transparent_mathfn (location_t, tree, tree);\n-static bool readonly_data_expr (tree);\n static rtx expand_builtin_fabs (tree, rtx, rtx);\n static rtx expand_builtin_signbit (tree, rtx);\n static tree fold_builtin_sqrt (location_t, tree, tree);\n@@ -164,7 +162,6 @@ static tree fold_builtin_ceil (location_t, tree, tree);\n static tree fold_builtin_round (location_t, tree, tree);\n static tree fold_builtin_int_roundingfn (location_t, tree, tree);\n static tree fold_builtin_bitop (tree, tree);\n-static tree fold_builtin_memory_op (location_t, tree, tree, tree, tree, bool, int);\n static tree fold_builtin_strchr (location_t, tree, tree, tree);\n static tree fold_builtin_memchr (location_t, tree, tree, tree, tree);\n static tree fold_builtin_memcmp (location_t, tree, tree, tree);\n@@ -205,18 +202,16 @@ static void maybe_emit_free_warning (tree);\n static tree fold_builtin_object_size (tree, tree);\n static tree fold_builtin_strcat_chk (location_t, tree, tree, tree, tree);\n static tree fold_builtin_strncat_chk (location_t, tree, tree, tree, tree, tree);\n-static tree fold_builtin_sprintf_chk (location_t, tree, enum built_in_function);\n static tree fold_builtin_printf (location_t, tree, tree, tree, bool, enum built_in_function);\n static tree fold_builtin_fprintf (location_t, tree, tree, tree, tree, bool,\n \t\t\t\t  enum built_in_function);\n-static bool init_target_chars (void);\n \n static unsigned HOST_WIDE_INT target_newline;\n-static unsigned HOST_WIDE_INT target_percent;\n+unsigned HOST_WIDE_INT target_percent;\n static unsigned HOST_WIDE_INT target_c;\n static unsigned HOST_WIDE_INT target_s;\n static char target_percent_c[3];\n-static char target_percent_s[3];\n+char target_percent_s[3];\n static char target_percent_s_newline[4];\n static tree do_mpfr_arg1 (tree, tree, int (*)(mpfr_ptr, mpfr_srcptr, mp_rnd_t),\n \t\t\t  const REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *, bool);\n@@ -634,7 +629,7 @@ c_strlen (tree src, int only_value)\n /* Return a char pointer for a C string if it is a string constant\n    or sum of string constant and integer constant.  */\n \n-static const char *\n+const char *\n c_getstr (tree src)\n {\n   tree offset_node;\n@@ -8496,503 +8491,6 @@ fold_builtin_exponent (location_t loc, tree fndecl, tree arg,\n   return NULL_TREE;\n }\n \n-/* Return true if VAR is a VAR_DECL or a component thereof.  */\n-\n-static bool\n-var_decl_component_p (tree var)\n-{\n-  tree inner = var;\n-  while (handled_component_p (inner))\n-    inner = TREE_OPERAND (inner, 0);\n-  return SSA_VAR_P (inner);\n-}\n-\n-/* Fold function call to builtin memset.  Return\n-   NULL_TREE if no simplification can be made.  */\n-\n-static tree\n-fold_builtin_memset (location_t loc, tree dest, tree c, tree len,\n-\t\t     tree type, bool ignore)\n-{\n-  tree var, ret, etype;\n-  unsigned HOST_WIDE_INT length, cval;\n-\n-  if (! validate_arg (dest, POINTER_TYPE)\n-      || ! validate_arg (c, INTEGER_TYPE)\n-      || ! validate_arg (len, INTEGER_TYPE))\n-    return NULL_TREE;\n-\n-  if (! tree_fits_uhwi_p (len))\n-    return NULL_TREE;\n-\n-  /* If the LEN parameter is zero, return DEST.  */\n-  if (integer_zerop (len))\n-    return omit_one_operand_loc (loc, type, dest, c);\n-\n-  if (TREE_CODE (c) != INTEGER_CST || TREE_SIDE_EFFECTS (dest))\n-    return NULL_TREE;\n-\n-  var = dest;\n-  STRIP_NOPS (var);\n-  if (TREE_CODE (var) != ADDR_EXPR)\n-    return NULL_TREE;\n-\n-  var = TREE_OPERAND (var, 0);\n-  if (TREE_THIS_VOLATILE (var))\n-    return NULL_TREE;\n-\n-  etype = TREE_TYPE (var);\n-  if (TREE_CODE (etype) == ARRAY_TYPE)\n-    etype = TREE_TYPE (etype);\n-\n-  if (!INTEGRAL_TYPE_P (etype)\n-      && !POINTER_TYPE_P (etype))\n-    return NULL_TREE;\n-\n-  if (! var_decl_component_p (var))\n-    return NULL_TREE;\n-\n-  length = tree_to_uhwi (len);\n-  if (GET_MODE_SIZE (TYPE_MODE (etype)) != length\n-      || get_pointer_alignment (dest) / BITS_PER_UNIT < length)\n-    return NULL_TREE;\n-\n-  if (length > HOST_BITS_PER_WIDE_INT / BITS_PER_UNIT)\n-    return NULL_TREE;\n-\n-  if (integer_zerop (c))\n-    cval = 0;\n-  else\n-    {\n-      if (CHAR_BIT != 8 || BITS_PER_UNIT != 8 || HOST_BITS_PER_WIDE_INT > 64)\n-\treturn NULL_TREE;\n-\n-      cval = TREE_INT_CST_LOW (c);\n-      cval &= 0xff;\n-      cval |= cval << 8;\n-      cval |= cval << 16;\n-      cval |= (cval << 31) << 1;\n-    }\n-\n-  ret = build_int_cst_type (etype, cval);\n-  var = build_fold_indirect_ref_loc (loc,\n-\t\t\t\t fold_convert_loc (loc,\n-\t\t\t\t\t\t   build_pointer_type (etype),\n-\t\t\t\t\t\t   dest));\n-  ret = build2 (MODIFY_EXPR, etype, var, ret);\n-  if (ignore)\n-    return ret;\n-\n-  return omit_one_operand_loc (loc, type, dest, ret);\n-}\n-\n-/* Fold function call to builtin memset.  Return\n-   NULL_TREE if no simplification can be made.  */\n-\n-static tree\n-fold_builtin_bzero (location_t loc, tree dest, tree size, bool ignore)\n-{\n-  if (! validate_arg (dest, POINTER_TYPE)\n-      || ! validate_arg (size, INTEGER_TYPE))\n-    return NULL_TREE;\n-\n-  if (!ignore)\n-    return NULL_TREE;\n-\n-  /* New argument list transforming bzero(ptr x, int y) to\n-     memset(ptr x, int 0, size_t y).   This is done this way\n-     so that if it isn't expanded inline, we fallback to\n-     calling bzero instead of memset.  */\n-\n-  return fold_builtin_memset (loc, dest, integer_zero_node,\n-\t\t\t      fold_convert_loc (loc, size_type_node, size),\n-\t\t\t      void_type_node, ignore);\n-}\n-\n-/* Fold function call to builtin mem{{,p}cpy,move}.  Return\n-   NULL_TREE if no simplification can be made.\n-   If ENDP is 0, return DEST (like memcpy).\n-   If ENDP is 1, return DEST+LEN (like mempcpy).\n-   If ENDP is 2, return DEST+LEN-1 (like stpcpy).\n-   If ENDP is 3, return DEST, additionally *SRC and *DEST may overlap\n-   (memmove).   */\n-\n-static tree\n-fold_builtin_memory_op (location_t loc, tree dest, tree src,\n-\t\t\ttree len, tree type, bool ignore, int endp)\n-{\n-  tree destvar, srcvar, expr;\n-\n-  if (! validate_arg (dest, POINTER_TYPE)\n-      || ! validate_arg (src, POINTER_TYPE)\n-      || ! validate_arg (len, INTEGER_TYPE))\n-    return NULL_TREE;\n-\n-  /* If the LEN parameter is zero, return DEST.  */\n-  if (integer_zerop (len))\n-    return omit_one_operand_loc (loc, type, dest, src);\n-\n-  /* If SRC and DEST are the same (and not volatile), return\n-     DEST{,+LEN,+LEN-1}.  */\n-  if (operand_equal_p (src, dest, 0))\n-    expr = len;\n-  else\n-    {\n-      tree srctype, desttype;\n-      unsigned int src_align, dest_align;\n-      tree off0;\n-\n-      /* Build accesses at offset zero with a ref-all character type.  */\n-      off0 = build_int_cst (build_pointer_type_for_mode (char_type_node,\n-\t\t\t\t\t\t\t ptr_mode, true), 0);\n-\n-      /* If we can perform the copy efficiently with first doing all loads\n-         and then all stores inline it that way.  Currently efficiently\n-\t means that we can load all the memory into a single integer\n-\t register which is what MOVE_MAX gives us.  */\n-      src_align = get_pointer_alignment (src);\n-      dest_align = get_pointer_alignment (dest);\n-      if (tree_fits_uhwi_p (len)\n-\t  && compare_tree_int (len, MOVE_MAX) <= 0\n-\t  /* ???  Don't transform copies from strings with known length this\n-\t     confuses the tree-ssa-strlen.c.  This doesn't handle\n-\t     the case in gcc.dg/strlenopt-8.c which is XFAILed for that\n-\t     reason.  */\n-\t  && !c_strlen (src, 2))\n-\t{\n-\t  unsigned ilen = tree_to_uhwi (len);\n-\t  if (exact_log2 (ilen) != -1)\n-\t    {\n-\t      tree type = lang_hooks.types.type_for_size (ilen * 8, 1);\n-\t      if (type\n-\t\t  && TYPE_MODE (type) != BLKmode\n-\t\t  && (GET_MODE_SIZE (TYPE_MODE (type)) * BITS_PER_UNIT\n-\t\t      == ilen * 8)\n-\t\t  /* If the pointers are not aligned we must be able to\n-\t\t     emit an unaligned load.  */\n-\t\t  && ((src_align >= GET_MODE_ALIGNMENT (TYPE_MODE (type))\n-\t\t       && dest_align >= GET_MODE_ALIGNMENT (TYPE_MODE (type)))\n-\t\t      || !SLOW_UNALIGNED_ACCESS (TYPE_MODE (type),\n-\t\t\t\t\t\t MIN (src_align, dest_align))))\n-\t\t{\n-\t\t  tree srctype = type;\n-\t\t  tree desttype = type;\n-\t\t  if (src_align < GET_MODE_ALIGNMENT (TYPE_MODE (type)))\n-\t\t    srctype = build_aligned_type (type, src_align);\n-\t\t  if (dest_align < GET_MODE_ALIGNMENT (TYPE_MODE (type)))\n-\t\t    desttype = build_aligned_type (type, dest_align);\n-\t\t  if (!ignore)\n-\t\t    dest = builtin_save_expr (dest);\n-\t\t  expr = build2 (MODIFY_EXPR, type,\n-\t\t\t\t fold_build2 (MEM_REF, desttype, dest, off0),\n-\t\t\t\t fold_build2 (MEM_REF, srctype, src, off0));\n-\t\t  goto done;\n-\t\t}\n-\t    }\n-\t}\n-\n-      if (endp == 3)\n-\t{\n-\t  /* Both DEST and SRC must be pointer types.\n-\t     ??? This is what old code did.  Is the testing for pointer types\n-\t     really mandatory?\n-\n-\t     If either SRC is readonly or length is 1, we can use memcpy.  */\n-\t  if (!dest_align || !src_align)\n-\t    return NULL_TREE;\n-\t  if (readonly_data_expr (src)\n-\t      || (tree_fits_uhwi_p (len)\n-\t\t  && (MIN (src_align, dest_align) / BITS_PER_UNIT\n-\t\t      >= tree_to_uhwi (len))))\n-\t    {\n-\t      tree fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n-\t      if (!fn)\n-\t\treturn NULL_TREE;\n-              return build_call_expr_loc (loc, fn, 3, dest, src, len);\n-\t    }\n-\n-\t  /* If *src and *dest can't overlap, optimize into memcpy as well.  */\n-\t  if (TREE_CODE (src) == ADDR_EXPR\n-\t      && TREE_CODE (dest) == ADDR_EXPR)\n-\t    {\n-\t      tree src_base, dest_base, fn;\n-\t      HOST_WIDE_INT src_offset = 0, dest_offset = 0;\n-\t      HOST_WIDE_INT size = -1;\n-\t      HOST_WIDE_INT maxsize = -1;\n-\n-\t      srcvar = TREE_OPERAND (src, 0);\n-\t      src_base = get_ref_base_and_extent (srcvar, &src_offset,\n-\t\t\t\t\t\t  &size, &maxsize);\n-\t      destvar = TREE_OPERAND (dest, 0);\n-\t      dest_base = get_ref_base_and_extent (destvar, &dest_offset,\n-\t\t\t\t\t\t   &size, &maxsize);\n-\t      if (tree_fits_uhwi_p (len))\n-\t\tmaxsize = tree_to_uhwi (len);\n-\t      else\n-\t\tmaxsize = -1;\n-\t      src_offset /= BITS_PER_UNIT;\n-\t      dest_offset /= BITS_PER_UNIT;\n-\t      if (SSA_VAR_P (src_base)\n-\t\t  && SSA_VAR_P (dest_base))\n-\t\t{\n-\t\t  if (operand_equal_p (src_base, dest_base, 0)\n-\t\t      && ranges_overlap_p (src_offset, maxsize,\n-\t\t\t\t\t   dest_offset, maxsize))\n-\t\t    return NULL_TREE;\n-\t\t}\n-\t      else if (TREE_CODE (src_base) == MEM_REF\n-\t\t       && TREE_CODE (dest_base) == MEM_REF)\n-\t\t{\n-\t\t  if (! operand_equal_p (TREE_OPERAND (src_base, 0),\n-\t\t\t\t\t TREE_OPERAND (dest_base, 0), 0))\n-\t\t    return NULL_TREE;\n-\t\t  offset_int off = mem_ref_offset (src_base) + src_offset;\n-\t\t  if (!wi::fits_shwi_p (off))\n-\t\t    return NULL_TREE;\n-\t\t  src_offset = off.to_shwi ();\n-\n-\t\t  off = mem_ref_offset (dest_base) + dest_offset;\n-\t\t  if (!wi::fits_shwi_p (off))\n-\t\t    return NULL_TREE;\n-\t\t  dest_offset = off.to_shwi ();\n-\t\t  if (ranges_overlap_p (src_offset, maxsize,\n-\t\t\t\t\tdest_offset, maxsize))\n-\t\t    return NULL_TREE;\n-\t\t}\n-\t      else\n-\t\treturn NULL_TREE;\n-\n-\t      fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n-\t      if (!fn)\n-\t\treturn NULL_TREE;\n-\t      return build_call_expr_loc (loc, fn, 3, dest, src, len);\n-\t    }\n-\n-\t  /* If the destination and source do not alias optimize into\n-\t     memcpy as well.  */\n-\t  if ((is_gimple_min_invariant (dest)\n-\t       || TREE_CODE (dest) == SSA_NAME)\n-\t      && (is_gimple_min_invariant (src)\n-\t\t  || TREE_CODE (src) == SSA_NAME))\n-\t    {\n-\t      ao_ref destr, srcr;\n-\t      ao_ref_init_from_ptr_and_size (&destr, dest, len);\n-\t      ao_ref_init_from_ptr_and_size (&srcr, src, len);\n-\t      if (!refs_may_alias_p_1 (&destr, &srcr, false))\n-\t\t{\n-\t\t  tree fn;\n-\t\t  fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n-\t\t  if (!fn)\n-\t\t    return NULL_TREE;\n-\t\t  return build_call_expr_loc (loc, fn, 3, dest, src, len);\n-\t\t}\n-\t    }\n-\n-\t  return NULL_TREE;\n-\t}\n-\n-      if (!tree_fits_shwi_p (len))\n-\treturn NULL_TREE;\n-      /* FIXME:\n-         This logic lose for arguments like (type *)malloc (sizeof (type)),\n-         since we strip the casts of up to VOID return value from malloc.\n-\t Perhaps we ought to inherit type from non-VOID argument here?  */\n-      STRIP_NOPS (src);\n-      STRIP_NOPS (dest);\n-      if (!POINTER_TYPE_P (TREE_TYPE (src))\n-\t  || !POINTER_TYPE_P (TREE_TYPE (dest)))\n-\treturn NULL_TREE;\n-      /* In the following try to find a type that is most natural to be\n-\t used for the memcpy source and destination and that allows\n-\t the most optimization when memcpy is turned into a plain assignment\n-\t using that type.  In theory we could always use a char[len] type\n-\t but that only gains us that the destination and source possibly\n-\t no longer will have their address taken.  */\n-      /* As we fold (void *)(p + CST) to (void *)p + CST undo this here.  */\n-      if (TREE_CODE (src) == POINTER_PLUS_EXPR)\n-\t{\n-\t  tree tem = TREE_OPERAND (src, 0);\n-\t  STRIP_NOPS (tem);\n-\t  if (tem != TREE_OPERAND (src, 0))\n-\t    src = build1 (NOP_EXPR, TREE_TYPE (tem), src);\n-\t}\n-      if (TREE_CODE (dest) == POINTER_PLUS_EXPR)\n-\t{\n-\t  tree tem = TREE_OPERAND (dest, 0);\n-\t  STRIP_NOPS (tem);\n-\t  if (tem != TREE_OPERAND (dest, 0))\n-\t    dest = build1 (NOP_EXPR, TREE_TYPE (tem), dest);\n-\t}\n-      srctype = TREE_TYPE (TREE_TYPE (src));\n-      if (TREE_CODE (srctype) == ARRAY_TYPE\n-\t  && !tree_int_cst_equal (TYPE_SIZE_UNIT (srctype), len))\n-\t{\n-\t  srctype = TREE_TYPE (srctype);\n-\t  STRIP_NOPS (src);\n-\t  src = build1 (NOP_EXPR, build_pointer_type (srctype), src);\n-\t}\n-      desttype = TREE_TYPE (TREE_TYPE (dest));\n-      if (TREE_CODE (desttype) == ARRAY_TYPE\n-\t  && !tree_int_cst_equal (TYPE_SIZE_UNIT (desttype), len))\n-\t{\n-\t  desttype = TREE_TYPE (desttype);\n-\t  STRIP_NOPS (dest);\n-\t  dest = build1 (NOP_EXPR, build_pointer_type (desttype), dest);\n-\t}\n-      if (TREE_ADDRESSABLE (srctype)\n-\t  || TREE_ADDRESSABLE (desttype))\n-\treturn NULL_TREE;\n-\n-      /* Make sure we are not copying using a floating-point mode or\n-         a type whose size possibly does not match its precision.  */\n-      if (FLOAT_MODE_P (TYPE_MODE (desttype))\n-\t  || TREE_CODE (desttype) == BOOLEAN_TYPE\n-\t  || TREE_CODE (desttype) == ENUMERAL_TYPE)\n-\tdesttype = bitwise_type_for_mode (TYPE_MODE (desttype));\n-      if (FLOAT_MODE_P (TYPE_MODE (srctype))\n-\t  || TREE_CODE (srctype) == BOOLEAN_TYPE\n-\t  || TREE_CODE (srctype) == ENUMERAL_TYPE)\n-\tsrctype = bitwise_type_for_mode (TYPE_MODE (srctype));\n-      if (!srctype)\n-\tsrctype = desttype;\n-      if (!desttype)\n-\tdesttype = srctype;\n-      if (!srctype)\n-\treturn NULL_TREE;\n-\n-      src_align = get_pointer_alignment (src);\n-      dest_align = get_pointer_alignment (dest);\n-      if (dest_align < TYPE_ALIGN (desttype)\n-\t  || src_align < TYPE_ALIGN (srctype))\n-\treturn NULL_TREE;\n-\n-      if (!ignore)\n-        dest = builtin_save_expr (dest);\n-\n-      destvar = dest;\n-      STRIP_NOPS (destvar);\n-      if (TREE_CODE (destvar) == ADDR_EXPR\n-\t  && var_decl_component_p (TREE_OPERAND (destvar, 0))\n-\t  && tree_int_cst_equal (TYPE_SIZE_UNIT (desttype), len))\n-\tdestvar = fold_build2 (MEM_REF, desttype, destvar, off0);\n-      else\n-\tdestvar = NULL_TREE;\n-\n-      srcvar = src;\n-      STRIP_NOPS (srcvar);\n-      if (TREE_CODE (srcvar) == ADDR_EXPR\n-\t  && var_decl_component_p (TREE_OPERAND (srcvar, 0))\n-\t  && tree_int_cst_equal (TYPE_SIZE_UNIT (srctype), len))\n-\t{\n-\t  if (!destvar\n-\t      || src_align >= TYPE_ALIGN (desttype))\n-\t    srcvar = fold_build2 (MEM_REF, destvar ? desttype : srctype,\n-\t\t\t\t  srcvar, off0);\n-\t  else if (!STRICT_ALIGNMENT)\n-\t    {\n-\t      srctype = build_aligned_type (TYPE_MAIN_VARIANT (desttype),\n-\t\t\t\t\t    src_align);\n-\t      srcvar = fold_build2 (MEM_REF, srctype, srcvar, off0);\n-\t    }\n-\t  else\n-\t    srcvar = NULL_TREE;\n-\t}\n-      else\n-\tsrcvar = NULL_TREE;\n-\n-      if (srcvar == NULL_TREE && destvar == NULL_TREE)\n-\treturn NULL_TREE;\n-\n-      if (srcvar == NULL_TREE)\n-\t{\n-\t  STRIP_NOPS (src);\n-\t  if (src_align >= TYPE_ALIGN (desttype))\n-\t    srcvar = fold_build2 (MEM_REF, desttype, src, off0);\n-\t  else\n-\t    {\n-\t      if (STRICT_ALIGNMENT)\n-\t\treturn NULL_TREE;\n-\t      srctype = build_aligned_type (TYPE_MAIN_VARIANT (desttype),\n-\t\t\t\t\t    src_align);\n-\t      srcvar = fold_build2 (MEM_REF, srctype, src, off0);\n-\t    }\n-\t}\n-      else if (destvar == NULL_TREE)\n-\t{\n-\t  STRIP_NOPS (dest);\n-\t  if (dest_align >= TYPE_ALIGN (srctype))\n-\t    destvar = fold_build2 (MEM_REF, srctype, dest, off0);\n-\t  else\n-\t    {\n-\t      if (STRICT_ALIGNMENT)\n-\t\treturn NULL_TREE;\n-\t      desttype = build_aligned_type (TYPE_MAIN_VARIANT (srctype),\n-\t\t\t\t\t     dest_align);\n-\t      destvar = fold_build2 (MEM_REF, desttype, dest, off0);\n-\t    }\n-\t}\n-\n-      expr = build2 (MODIFY_EXPR, TREE_TYPE (destvar), destvar, srcvar);\n-    }\n-\n-done:\n-  if (ignore)\n-    return expr;\n-\n-  if (endp == 0 || endp == 3)\n-    return omit_one_operand_loc (loc, type, dest, expr);\n-\n-  if (expr == len)\n-    expr = NULL_TREE;\n-\n-  if (endp == 2)\n-    len = fold_build2_loc (loc, MINUS_EXPR, TREE_TYPE (len), len,\n-\t\t       ssize_int (1));\n-\n-  dest = fold_build_pointer_plus_loc (loc, dest, len);\n-  dest = fold_convert_loc (loc, type, dest);\n-  if (expr)\n-    dest = omit_one_operand_loc (loc, type, dest, expr);\n-  return dest;\n-}\n-\n-/* Fold function call to builtin strcpy with arguments DEST and SRC.\n-   If LEN is not NULL, it represents the length of the string to be\n-   copied.  Return NULL_TREE if no simplification can be made.  */\n-\n-tree\n-fold_builtin_strcpy (location_t loc, tree fndecl, tree dest, tree src, tree len)\n-{\n-  tree fn;\n-\n-  if (!validate_arg (dest, POINTER_TYPE)\n-      || !validate_arg (src, POINTER_TYPE))\n-    return NULL_TREE;\n-\n-  /* If SRC and DEST are the same (and not volatile), return DEST.  */\n-  if (operand_equal_p (src, dest, 0))\n-    return fold_convert_loc (loc, TREE_TYPE (TREE_TYPE (fndecl)), dest);\n-\n-  if (optimize_function_for_size_p (cfun))\n-    return NULL_TREE;\n-\n-  fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n-  if (!fn)\n-    return NULL_TREE;\n-\n-  if (!len)\n-    {\n-      len = c_strlen (src, 1);\n-      if (! len || TREE_SIDE_EFFECTS (len))\n-\treturn NULL_TREE;\n-    }\n-\n-  len = fold_convert_loc (loc, size_type_node, len);\n-  len = size_binop_loc (loc, PLUS_EXPR, len, build_int_cst (size_type_node, 1));\n-  return fold_convert_loc (loc, TREE_TYPE (TREE_TYPE (fndecl)),\n-\t\t\t   build_call_expr_loc (loc, fn, 3, dest, src, len));\n-}\n-\n /* Fold function call to builtin stpcpy with arguments DEST and SRC.\n    Return NULL_TREE if no simplification can be made.  */\n \n@@ -9034,55 +8532,6 @@ fold_builtin_stpcpy (location_t loc, tree fndecl, tree dest, tree src)\n   return dest;\n }\n \n-/* Fold function call to builtin strncpy with arguments DEST, SRC, and LEN.\n-   If SLEN is not NULL, it represents the length of the source string.\n-   Return NULL_TREE if no simplification can be made.  */\n-\n-tree\n-fold_builtin_strncpy (location_t loc, tree fndecl, tree dest,\n-\t\t      tree src, tree len, tree slen)\n-{\n-  tree fn;\n-\n-  if (!validate_arg (dest, POINTER_TYPE)\n-      || !validate_arg (src, POINTER_TYPE)\n-      || !validate_arg (len, INTEGER_TYPE))\n-    return NULL_TREE;\n-\n-  /* If the LEN parameter is zero, return DEST.  */\n-  if (integer_zerop (len))\n-    return omit_one_operand_loc (loc, TREE_TYPE (TREE_TYPE (fndecl)), dest, src);\n-\n-  /* We can't compare slen with len as constants below if len is not a\n-     constant.  */\n-  if (len == 0 || TREE_CODE (len) != INTEGER_CST)\n-    return NULL_TREE;\n-\n-  if (!slen)\n-    slen = c_strlen (src, 1);\n-\n-  /* Now, we must be passed a constant src ptr parameter.  */\n-  if (slen == 0 || TREE_CODE (slen) != INTEGER_CST)\n-    return NULL_TREE;\n-\n-  slen = size_binop_loc (loc, PLUS_EXPR, slen, ssize_int (1));\n-\n-  /* We do not support simplification of this case, though we do\n-     support it when expanding trees into RTL.  */\n-  /* FIXME: generate a call to __builtin_memset.  */\n-  if (tree_int_cst_lt (slen, len))\n-    return NULL_TREE;\n-\n-  /* OK transform into builtin memcpy.  */\n-  fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n-  if (!fn)\n-    return NULL_TREE;\n-\n-  len = fold_convert_loc (loc, size_type_node, len);\n-  return fold_convert_loc (loc, TREE_TYPE (TREE_TYPE (fndecl)),\n-\t\t\t   build_call_expr_loc (loc, fn, 3, dest, src, len));\n-}\n-\n /* Fold function call to builtin memchr.  ARG1, ARG2 and LEN are the\n    arguments to the call, and TYPE is its return type.\n    Return NULL_TREE if no simplification can be made.  */\n@@ -10707,21 +10156,9 @@ fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1, bool ignore)\n     CASE_FLT_FN (BUILT_IN_MODF):\n       return fold_builtin_modf (loc, arg0, arg1, type);\n \n-    case BUILT_IN_BZERO:\n-      return fold_builtin_bzero (loc, arg0, arg1, ignore);\n-\n-    case BUILT_IN_FPUTS:\n-      return fold_builtin_fputs (loc, arg0, arg1, ignore, false, NULL_TREE);\n-\n-    case BUILT_IN_FPUTS_UNLOCKED:\n-      return fold_builtin_fputs (loc, arg0, arg1, ignore, true, NULL_TREE);\n-\n     case BUILT_IN_STRSTR:\n       return fold_builtin_strstr (loc, arg0, arg1, type);\n \n-    case BUILT_IN_STRCAT:\n-      return fold_builtin_strcat (loc, arg0, arg1, NULL_TREE);\n-\n     case BUILT_IN_STRSPN:\n       return fold_builtin_strspn (loc, arg0, arg1);\n \n@@ -10736,9 +10173,6 @@ fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1, bool ignore)\n     case BUILT_IN_RINDEX:\n       return fold_builtin_strrchr (loc, arg0, arg1, type);\n \n-    case BUILT_IN_STRCPY:\n-      return fold_builtin_strcpy (loc, fndecl, arg0, arg1, NULL_TREE);\n-\n     case BUILT_IN_STPCPY:\n       if (ignore)\n \t{\n@@ -10866,31 +10300,9 @@ fold_builtin_3 (location_t loc, tree fndecl,\n \treturn do_mpfr_remquo (arg0, arg1, arg2);\n     break;\n \n-    case BUILT_IN_MEMSET:\n-      return fold_builtin_memset (loc, arg0, arg1, arg2, type, ignore);\n-\n-    case BUILT_IN_BCOPY:\n-      return fold_builtin_memory_op (loc, arg1, arg0, arg2,\n-\t\t\t\t     void_type_node, true, /*endp=*/3);\n-\n-    case BUILT_IN_MEMCPY:\n-      return fold_builtin_memory_op (loc, arg0, arg1, arg2,\n-\t\t\t\t     type, ignore, /*endp=*/0);\n-\n-    case BUILT_IN_MEMPCPY:\n-      return fold_builtin_memory_op (loc, arg0, arg1, arg2,\n-\t\t\t\t     type, ignore, /*endp=*/1);\n-\n-    case BUILT_IN_MEMMOVE:\n-      return fold_builtin_memory_op (loc, arg0, arg1, arg2,\n-\t\t\t\t     type, ignore, /*endp=*/3);\n-\n     case BUILT_IN_STRNCAT:\n       return fold_builtin_strncat (loc, arg0, arg1, arg2);\n \n-    case BUILT_IN_STRNCPY:\n-      return fold_builtin_strncpy (loc, fndecl, arg0, arg1, arg2, NULL_TREE);\n-\n     case BUILT_IN_STRNCMP:\n       return fold_builtin_strncmp (loc, arg0, arg1, arg2);\n \n@@ -10907,11 +10319,6 @@ fold_builtin_3 (location_t loc, tree fndecl,\n     case BUILT_IN_SNPRINTF:\n       return fold_builtin_snprintf (loc, arg0, arg1, arg2, NULL_TREE, ignore);\n \n-    case BUILT_IN_STRCPY_CHK:\n-    case BUILT_IN_STPCPY_CHK:\n-      return fold_builtin_stxcpy_chk (loc, fndecl, arg0, arg1, arg2, NULL_TREE,\n-\t\t\t\t      ignore, fcode);\n-\n     case BUILT_IN_STRCAT_CHK:\n       return fold_builtin_strcat_chk (loc, fndecl, arg0, arg1, arg2);\n \n@@ -10961,19 +10368,6 @@ fold_builtin_4 (location_t loc, tree fndecl,\n \n   switch (fcode)\n     {\n-    case BUILT_IN_MEMCPY_CHK:\n-    case BUILT_IN_MEMPCPY_CHK:\n-    case BUILT_IN_MEMMOVE_CHK:\n-    case BUILT_IN_MEMSET_CHK:\n-      return fold_builtin_memory_chk (loc, fndecl, arg0, arg1, arg2, arg3,\n-\t\t\t\t      NULL_TREE, ignore,\n-\t\t\t\t      DECL_FUNCTION_CODE (fndecl));\n-\n-    case BUILT_IN_STRNCPY_CHK:\n-    case BUILT_IN_STPNCPY_CHK:\n-      return fold_builtin_stxncpy_chk (loc, arg0, arg1, arg2, arg3, NULL_TREE,\n-                                       ignore, fcode);\n-\n     case BUILT_IN_STRNCAT_CHK:\n       return fold_builtin_strncat_chk (loc, fndecl, arg0, arg1, arg2, arg3);\n \n@@ -11070,25 +10464,6 @@ rewrite_call_expr_valist (location_t loc, int oldnargs, tree *args,\n   return build_call_expr_loc_array (loc, fndecl, nargs, buffer);\n }\n \n-/* Construct a new CALL_EXPR to FNDECL using the tail of the argument\n-   list ARGS along with N new arguments specified as the \"...\"\n-   parameters.  SKIP is the number of arguments in ARGS to be omitted.\n-   OLDNARGS is the number of elements in ARGS.  */\n-\n-static tree\n-rewrite_call_expr_array (location_t loc, int oldnargs, tree *args,\n-\t\t\t int skip, tree fndecl, int n, ...)\n-{\n-  va_list ap;\n-  tree t;\n-\n-  va_start (ap, n);\n-  t = rewrite_call_expr_valist (loc, oldnargs, args, skip, fndecl, n, ap);\n-  va_end (ap);\n-\n-  return t;\n-}\n-\n /* Return true if FNDECL shouldn't be folded right now.\n    If a built-in function has an inline attribute always_inline\n    wrapper, defer folding it after always_inline functions have\n@@ -11321,7 +10696,7 @@ default_expand_builtin (tree exp ATTRIBUTE_UNUSED,\n /* Returns true is EXP represents data that would potentially reside\n    in a readonly section.  */\n \n-static bool\n+bool\n readonly_data_expr (tree exp)\n {\n   STRIP_NOPS (exp);\n@@ -11594,8 +10969,8 @@ fold_builtin_strpbrk (location_t loc, tree s1, tree s2, tree type)\n     }\n }\n \n-/* Simplify a call to the strcat builtin.  DST and SRC are the arguments\n-   to the call.\n+/* Simplify a call to the strncat builtin.  DST, SRC, and LEN are the\n+   arguments to the call.\n \n    Return NULL_TREE if no simplification was possible, otherwise return the\n    simplified form of the call as a tree.\n@@ -11612,79 +10987,8 @@ fold_builtin_strpbrk (location_t loc, tree s1, tree s2, tree type)\n    COMPOUND_EXPR in the chain will contain the tree for the simplified\n    form of the builtin function call.  */\n \n-tree\n-fold_builtin_strcat (location_t loc ATTRIBUTE_UNUSED, tree dst, tree src,\n-\t\t     tree len)\n-{\n-  if (!validate_arg (dst, POINTER_TYPE)\n-      || !validate_arg (src, POINTER_TYPE))\n-    return NULL_TREE;\n-  else\n-    {\n-      const char *p = c_getstr (src);\n-\n-      /* If the string length is zero, return the dst parameter.  */\n-      if (p && *p == '\\0')\n-\treturn dst;\n-\n-      if (optimize_insn_for_speed_p ())\n-\t{\n-\t  /* See if we can store by pieces into (dst + strlen(dst)).  */\n-\t  tree newdst, call;\n-\t  tree strlen_fn = builtin_decl_implicit (BUILT_IN_STRLEN);\n-\t  tree memcpy_fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n-\n-\t  if (!strlen_fn || !memcpy_fn)\n-\t    return NULL_TREE;\n-\n-\t  /* If the length of the source string isn't computable don't\n-\t     split strcat into strlen and memcpy.  */\n-\t  if (! len)\n-\t    len = c_strlen (src, 1);\n-\t  if (! len || TREE_SIDE_EFFECTS (len))\n-\t    return NULL_TREE;\n-\n-\t  /* Stabilize the argument list.  */\n-\t  dst = builtin_save_expr (dst);\n-\n-\t  /* Create strlen (dst).  */\n-\t  newdst = build_call_expr_loc (loc, strlen_fn, 1, dst);\n-\t  /* Create (dst p+ strlen (dst)).  */\n-\n-\t  newdst = fold_build_pointer_plus_loc (loc, dst, newdst);\n-\t  newdst = builtin_save_expr (newdst);\n-\n-\t  len = fold_convert_loc (loc, size_type_node, len);\n-\t  len = size_binop_loc (loc, PLUS_EXPR, len,\n-\t\t\t\tbuild_int_cst (size_type_node, 1));\n-\n-\t  call = build_call_expr_loc (loc, memcpy_fn, 3, newdst, src, len);\n-\t  return build2 (COMPOUND_EXPR, TREE_TYPE (dst), call, dst);\n-\t}\n-      return NULL_TREE;\n-    }\n-}\n-\n-/* Simplify a call to the strncat builtin.  DST, SRC, and LEN are the\n-   arguments to the call.\n-\n-   Return NULL_TREE if no simplification was possible, otherwise return the\n-   simplified form of the call as a tree.\n-\n-   The simplified form may be a constant or other expression which\n-   computes the same value, but in a more efficient manner (including\n-   calls to other builtin functions).\n-\n-   The call may contain arguments which need to be evaluated, but\n-   which are not useful to determine the result of the call.  In\n-   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n-   COMPOUND_EXPR will be an argument which must be evaluated.\n-   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n-   COMPOUND_EXPR in the chain will contain the tree for the simplified\n-   form of the builtin function call.  */\n-\n-static tree\n-fold_builtin_strncat (location_t loc, tree dst, tree src, tree len)\n+static tree\n+fold_builtin_strncat (location_t loc, tree dst, tree src, tree len)\n {\n   if (!validate_arg (dst, POINTER_TYPE)\n       || !validate_arg (src, POINTER_TYPE)\n@@ -11822,84 +11126,6 @@ fold_builtin_strcspn (location_t loc, tree s1, tree s2)\n     }\n }\n \n-/* Fold a call to the fputs builtin.  ARG0 and ARG1 are the arguments\n-   to the call.  IGNORE is true if the value returned\n-   by the builtin will be ignored.  UNLOCKED is true is true if this\n-   actually a call to fputs_unlocked.  If LEN in non-NULL, it represents\n-   the known length of the string.  Return NULL_TREE if no simplification\n-   was possible.  */\n-\n-tree\n-fold_builtin_fputs (location_t loc, tree arg0, tree arg1,\n-\t\t    bool ignore, bool unlocked, tree len)\n-{\n-  /* If we're using an unlocked function, assume the other unlocked\n-     functions exist explicitly.  */\n-  tree const fn_fputc = (unlocked\n-\t\t\t ? builtin_decl_explicit (BUILT_IN_FPUTC_UNLOCKED)\n-\t\t\t : builtin_decl_implicit (BUILT_IN_FPUTC));\n-  tree const fn_fwrite = (unlocked\n-\t\t\t  ? builtin_decl_explicit (BUILT_IN_FWRITE_UNLOCKED)\n-\t\t\t  : builtin_decl_implicit (BUILT_IN_FWRITE));\n-\n-  /* If the return value is used, don't do the transformation.  */\n-  if (!ignore)\n-    return NULL_TREE;\n-\n-  /* Verify the arguments in the original call.  */\n-  if (!validate_arg (arg0, POINTER_TYPE)\n-      || !validate_arg (arg1, POINTER_TYPE))\n-    return NULL_TREE;\n-\n-  if (! len)\n-    len = c_strlen (arg0, 0);\n-\n-  /* Get the length of the string passed to fputs.  If the length\n-     can't be determined, punt.  */\n-  if (!len\n-      || TREE_CODE (len) != INTEGER_CST)\n-    return NULL_TREE;\n-\n-  switch (compare_tree_int (len, 1))\n-    {\n-    case -1: /* length is 0, delete the call entirely .  */\n-      return omit_one_operand_loc (loc, integer_type_node,\n-\t\t\t       integer_zero_node, arg1);;\n-\n-    case 0: /* length is 1, call fputc.  */\n-      {\n-\tconst char *p = c_getstr (arg0);\n-\n-\tif (p != NULL)\n-\t  {\n- \t    if (fn_fputc)\n-\t      return build_call_expr_loc (loc, fn_fputc, 2,\n-\t\t\t\t\t  build_int_cst\n-\t\t\t\t\t    (integer_type_node, p[0]), arg1);\n-\t    else\n-\t      return NULL_TREE;\n-\t  }\n-      }\n-      /* FALLTHROUGH */\n-    case 1: /* length is greater than 1, call fwrite.  */\n-      {\n-\t/* If optimizing for size keep fputs.  */\n-\tif (optimize_function_for_size_p (cfun))\n-\t  return NULL_TREE;\n-\t/* New argument list transforming fputs(string, stream) to\n-\t   fwrite(string, 1, len, stream).  */\n-\tif (fn_fwrite)\n-\t  return build_call_expr_loc (loc, fn_fwrite, 4, arg0,\n-\t\t\t\t  size_one_node, len, arg1);\n-\telse\n-\t  return NULL_TREE;\n-      }\n-    default:\n-      gcc_unreachable ();\n-    }\n-  return NULL_TREE;\n-}\n-\n /* Fold the next_arg or va_start call EXP. Returns true if there was an error\n    produced.  False otherwise.  This is done so that we don't output the error\n    or warning twice or three times.  */\n@@ -12571,240 +11797,6 @@ fold_builtin_object_size (tree ptr, tree ost)\n   return NULL_TREE;\n }\n \n-/* Fold a call to the __mem{cpy,pcpy,move,set}_chk builtin.\n-   DEST, SRC, LEN, and SIZE are the arguments to the call.\n-   IGNORE is true, if return value can be ignored.  FCODE is the BUILT_IN_*\n-   code of the builtin.  If MAXLEN is not NULL, it is maximum length\n-   passed as third argument.  */\n-\n-tree\n-fold_builtin_memory_chk (location_t loc, tree fndecl,\n-\t\t\t tree dest, tree src, tree len, tree size,\n-\t\t\t tree maxlen, bool ignore,\n-\t\t\t enum built_in_function fcode)\n-{\n-  tree fn;\n-\n-  if (!validate_arg (dest, POINTER_TYPE)\n-      || !validate_arg (src,\n-\t\t\t(fcode == BUILT_IN_MEMSET_CHK\n-\t\t\t ? INTEGER_TYPE : POINTER_TYPE))\n-      || !validate_arg (len, INTEGER_TYPE)\n-      || !validate_arg (size, INTEGER_TYPE))\n-    return NULL_TREE;\n-\n-  /* If SRC and DEST are the same (and not volatile), return DEST\n-     (resp. DEST+LEN for __mempcpy_chk).  */\n-  if (fcode != BUILT_IN_MEMSET_CHK && operand_equal_p (src, dest, 0))\n-    {\n-      if (fcode != BUILT_IN_MEMPCPY_CHK)\n-\treturn omit_one_operand_loc (loc, TREE_TYPE (TREE_TYPE (fndecl)),\n-\t\t\t\t dest, len);\n-      else\n-\t{\n-\t  tree temp = fold_build_pointer_plus_loc (loc, dest, len);\n-\t  return fold_convert_loc (loc, TREE_TYPE (TREE_TYPE (fndecl)), temp);\n-\t}\n-    }\n-\n-  if (! tree_fits_uhwi_p (size))\n-    return NULL_TREE;\n-\n-  if (! integer_all_onesp (size))\n-    {\n-      if (! tree_fits_uhwi_p (len))\n-\t{\n-\t  /* If LEN is not constant, try MAXLEN too.\n-\t     For MAXLEN only allow optimizing into non-_ocs function\n-\t     if SIZE is >= MAXLEN, never convert to __ocs_fail ().  */\n-\t  if (maxlen == NULL_TREE || ! tree_fits_uhwi_p (maxlen))\n-\t    {\n-\t      if (fcode == BUILT_IN_MEMPCPY_CHK && ignore)\n-\t\t{\n-\t\t  /* (void) __mempcpy_chk () can be optimized into\n-\t\t     (void) __memcpy_chk ().  */\n-\t\t  fn = builtin_decl_explicit (BUILT_IN_MEMCPY_CHK);\n-\t\t  if (!fn)\n-\t\t    return NULL_TREE;\n-\n-\t\t  return build_call_expr_loc (loc, fn, 4, dest, src, len, size);\n-\t\t}\n-\t      return NULL_TREE;\n-\t    }\n-\t}\n-      else\n-\tmaxlen = len;\n-\n-      if (tree_int_cst_lt (size, maxlen))\n-\treturn NULL_TREE;\n-    }\n-\n-  fn = NULL_TREE;\n-  /* If __builtin_mem{cpy,pcpy,move,set}_chk is used, assume\n-     mem{cpy,pcpy,move,set} is available.  */\n-  switch (fcode)\n-    {\n-    case BUILT_IN_MEMCPY_CHK:\n-      fn = builtin_decl_explicit (BUILT_IN_MEMCPY);\n-      break;\n-    case BUILT_IN_MEMPCPY_CHK:\n-      fn = builtin_decl_explicit (BUILT_IN_MEMPCPY);\n-      break;\n-    case BUILT_IN_MEMMOVE_CHK:\n-      fn = builtin_decl_explicit (BUILT_IN_MEMMOVE);\n-      break;\n-    case BUILT_IN_MEMSET_CHK:\n-      fn = builtin_decl_explicit (BUILT_IN_MEMSET);\n-      break;\n-    default:\n-      break;\n-    }\n-\n-  if (!fn)\n-    return NULL_TREE;\n-\n-  return build_call_expr_loc (loc, fn, 3, dest, src, len);\n-}\n-\n-/* Fold a call to the __st[rp]cpy_chk builtin.\n-   DEST, SRC, and SIZE are the arguments to the call.\n-   IGNORE is true if return value can be ignored.  FCODE is the BUILT_IN_*\n-   code of the builtin.  If MAXLEN is not NULL, it is maximum length of\n-   strings passed as second argument.  */\n-\n-tree\n-fold_builtin_stxcpy_chk (location_t loc, tree fndecl, tree dest,\n-\t\t\t tree src, tree size,\n-\t\t\t tree maxlen, bool ignore,\n-\t\t\t enum built_in_function fcode)\n-{\n-  tree len, fn;\n-\n-  if (!validate_arg (dest, POINTER_TYPE)\n-      || !validate_arg (src, POINTER_TYPE)\n-      || !validate_arg (size, INTEGER_TYPE))\n-    return NULL_TREE;\n-\n-  /* If SRC and DEST are the same (and not volatile), return DEST.  */\n-  if (fcode == BUILT_IN_STRCPY_CHK && operand_equal_p (src, dest, 0))\n-    return fold_convert_loc (loc, TREE_TYPE (TREE_TYPE (fndecl)), dest);\n-\n-  if (! tree_fits_uhwi_p (size))\n-    return NULL_TREE;\n-\n-  if (! integer_all_onesp (size))\n-    {\n-      len = c_strlen (src, 1);\n-      if (! len || ! tree_fits_uhwi_p (len))\n-\t{\n-\t  /* If LEN is not constant, try MAXLEN too.\n-\t     For MAXLEN only allow optimizing into non-_ocs function\n-\t     if SIZE is >= MAXLEN, never convert to __ocs_fail ().  */\n-\t  if (maxlen == NULL_TREE || ! tree_fits_uhwi_p (maxlen))\n-\t    {\n-\t      if (fcode == BUILT_IN_STPCPY_CHK)\n-\t\t{\n-\t\t  if (! ignore)\n-\t\t    return NULL_TREE;\n-\n-\t\t  /* If return value of __stpcpy_chk is ignored,\n-\t\t     optimize into __strcpy_chk.  */\n-\t\t  fn = builtin_decl_explicit (BUILT_IN_STRCPY_CHK);\n-\t\t  if (!fn)\n-\t\t    return NULL_TREE;\n-\n-\t\t  return build_call_expr_loc (loc, fn, 3, dest, src, size);\n-\t\t}\n-\n-\t      if (! len || TREE_SIDE_EFFECTS (len))\n-\t\treturn NULL_TREE;\n-\n-\t      /* If c_strlen returned something, but not a constant,\n-\t\t transform __strcpy_chk into __memcpy_chk.  */\n-\t      fn = builtin_decl_explicit (BUILT_IN_MEMCPY_CHK);\n-\t      if (!fn)\n-\t\treturn NULL_TREE;\n-\n-\t      len = fold_convert_loc (loc, size_type_node, len);\n-\t      len = size_binop_loc (loc, PLUS_EXPR, len,\n-\t\t\t\t    build_int_cst (size_type_node, 1));\n-\t      return fold_convert_loc (loc, TREE_TYPE (TREE_TYPE (fndecl)),\n-\t\t\t\t       build_call_expr_loc (loc, fn, 4,\n-\t\t\t\t\t\t\tdest, src, len, size));\n-\t    }\n-\t}\n-      else\n-\tmaxlen = len;\n-\n-      if (! tree_int_cst_lt (maxlen, size))\n-\treturn NULL_TREE;\n-    }\n-\n-  /* If __builtin_st{r,p}cpy_chk is used, assume st{r,p}cpy is available.  */\n-  fn = builtin_decl_explicit (fcode == BUILT_IN_STPCPY_CHK\n-\t\t\t      ? BUILT_IN_STPCPY : BUILT_IN_STRCPY);\n-  if (!fn)\n-    return NULL_TREE;\n-\n-  return build_call_expr_loc (loc, fn, 2, dest, src);\n-}\n-\n-/* Fold a call to the __st{r,p}ncpy_chk builtin.  DEST, SRC, LEN, and SIZE\n-   are the arguments to the call.  If MAXLEN is not NULL, it is maximum\n-   length passed as third argument. IGNORE is true if return value can be\n-   ignored. FCODE is the BUILT_IN_* code of the builtin. */\n-\n-tree\n-fold_builtin_stxncpy_chk (location_t loc, tree dest, tree src,\n-\t\t\t  tree len, tree size, tree maxlen, bool ignore,\n-\t\t\t  enum built_in_function fcode)\n-{\n-  tree fn;\n-\n-  if (!validate_arg (dest, POINTER_TYPE)\n-      || !validate_arg (src, POINTER_TYPE)\n-      || !validate_arg (len, INTEGER_TYPE)\n-      || !validate_arg (size, INTEGER_TYPE))\n-    return NULL_TREE;\n-\n-  if (fcode == BUILT_IN_STPNCPY_CHK && ignore)\n-    {\n-       /* If return value of __stpncpy_chk is ignored,\n-          optimize into __strncpy_chk.  */\n-       fn = builtin_decl_explicit (BUILT_IN_STRNCPY_CHK);\n-       if (fn)\n-         return build_call_expr_loc (loc, fn, 4, dest, src, len, size);\n-    }\n-\n-  if (! tree_fits_uhwi_p (size))\n-    return NULL_TREE;\n-\n-  if (! integer_all_onesp (size))\n-    {\n-      if (! tree_fits_uhwi_p (len))\n-\t{\n-\t  /* If LEN is not constant, try MAXLEN too.\n-\t     For MAXLEN only allow optimizing into non-_ocs function\n-\t     if SIZE is >= MAXLEN, never convert to __ocs_fail ().  */\n-\t  if (maxlen == NULL_TREE || ! tree_fits_uhwi_p (maxlen))\n-\t    return NULL_TREE;\n-\t}\n-      else\n-\tmaxlen = len;\n-\n-      if (tree_int_cst_lt (size, maxlen))\n-\treturn NULL_TREE;\n-    }\n-\n-  /* If __builtin_st{r,p}ncpy_chk is used, assume st{r,p}ncpy is available.  */\n-  fn = builtin_decl_explicit (fcode == BUILT_IN_STPNCPY_CHK\n-\t\t\t      ? BUILT_IN_STPNCPY : BUILT_IN_STRNCPY);\n-  if (!fn)\n-    return NULL_TREE;\n-\n-  return build_call_expr_loc (loc, fn, 3, dest, src, len);\n-}\n-\n /* Fold a call to the __strcat_chk builtin FNDECL.  DEST, SRC, and SIZE\n    are the arguments to the call.  */\n \n@@ -12888,201 +11880,6 @@ fold_builtin_strncat_chk (location_t loc, tree fndecl,\n   return build_call_expr_loc (loc, fn, 3, dest, src, len);\n }\n \n-/* Fold a call EXP to __{,v}sprintf_chk having NARGS passed as ARGS.\n-   Return NULL_TREE if a normal call should be emitted rather than\n-   expanding the function inline.  FCODE is either BUILT_IN_SPRINTF_CHK\n-   or BUILT_IN_VSPRINTF_CHK.  */\n-\n-static tree\n-fold_builtin_sprintf_chk_1 (location_t loc, int nargs, tree *args,\n-\t\t\t    enum built_in_function fcode)\n-{\n-  tree dest, size, len, fn, fmt, flag;\n-  const char *fmt_str;\n-\n-  /* Verify the required arguments in the original call.  */\n-  if (nargs < 4)\n-    return NULL_TREE;\n-  dest = args[0];\n-  if (!validate_arg (dest, POINTER_TYPE))\n-    return NULL_TREE;\n-  flag = args[1];\n-  if (!validate_arg (flag, INTEGER_TYPE))\n-    return NULL_TREE;\n-  size = args[2];\n-  if (!validate_arg (size, INTEGER_TYPE))\n-    return NULL_TREE;\n-  fmt = args[3];\n-  if (!validate_arg (fmt, POINTER_TYPE))\n-    return NULL_TREE;\n-\n-  if (! tree_fits_uhwi_p (size))\n-    return NULL_TREE;\n-\n-  len = NULL_TREE;\n-\n-  if (!init_target_chars ())\n-    return NULL_TREE;\n-\n-  /* Check whether the format is a literal string constant.  */\n-  fmt_str = c_getstr (fmt);\n-  if (fmt_str != NULL)\n-    {\n-      /* If the format doesn't contain % args or %%, we know the size.  */\n-      if (strchr (fmt_str, target_percent) == 0)\n-\t{\n-\t  if (fcode != BUILT_IN_SPRINTF_CHK || nargs == 4)\n-\t    len = build_int_cstu (size_type_node, strlen (fmt_str));\n-\t}\n-      /* If the format is \"%s\" and first ... argument is a string literal,\n-\t we know the size too.  */\n-      else if (fcode == BUILT_IN_SPRINTF_CHK\n-\t       && strcmp (fmt_str, target_percent_s) == 0)\n-\t{\n-\t  tree arg;\n-\n-\t  if (nargs == 5)\n-\t    {\n-\t      arg = args[4];\n-\t      if (validate_arg (arg, POINTER_TYPE))\n-\t\t{\n-\t\t  len = c_strlen (arg, 1);\n-\t\t  if (! len || ! tree_fits_uhwi_p (len))\n-\t\t    len = NULL_TREE;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  if (! integer_all_onesp (size))\n-    {\n-      if (! len || ! tree_int_cst_lt (len, size))\n-\treturn NULL_TREE;\n-    }\n-\n-  /* Only convert __{,v}sprintf_chk to {,v}sprintf if flag is 0\n-     or if format doesn't contain % chars or is \"%s\".  */\n-  if (! integer_zerop (flag))\n-    {\n-      if (fmt_str == NULL)\n-\treturn NULL_TREE;\n-      if (strchr (fmt_str, target_percent) != NULL\n-\t  && strcmp (fmt_str, target_percent_s))\n-\treturn NULL_TREE;\n-    }\n-\n-  /* If __builtin_{,v}sprintf_chk is used, assume {,v}sprintf is available.  */\n-  fn = builtin_decl_explicit (fcode == BUILT_IN_VSPRINTF_CHK\n-\t\t\t      ? BUILT_IN_VSPRINTF : BUILT_IN_SPRINTF);\n-  if (!fn)\n-    return NULL_TREE;\n-\n-  return rewrite_call_expr_array (loc, nargs, args, 4, fn, 2, dest, fmt);\n-}\n-\n-/* Fold a call EXP to __{,v}sprintf_chk.  Return NULL_TREE if\n-   a normal call should be emitted rather than expanding the function\n-   inline.  FCODE is either BUILT_IN_SPRINTF_CHK or BUILT_IN_VSPRINTF_CHK.  */\n-\n-static tree\n-fold_builtin_sprintf_chk (location_t loc, tree exp,\n-\t\t\t  enum built_in_function fcode)\n-{\n-  return fold_builtin_sprintf_chk_1 (loc, call_expr_nargs (exp),\n-\t\t\t\t     CALL_EXPR_ARGP (exp), fcode);\n-}\n-\n-/* Fold a call EXP to {,v}snprintf having NARGS passed as ARGS.  Return\n-   NULL_TREE if a normal call should be emitted rather than expanding\n-   the function inline.  FCODE is either BUILT_IN_SNPRINTF_CHK or\n-   BUILT_IN_VSNPRINTF_CHK.  If MAXLEN is not NULL, it is maximum length\n-   passed as second argument.  */\n-\n-static tree\n-fold_builtin_snprintf_chk_1 (location_t loc, int nargs, tree *args,\n-\t\t\t     tree maxlen, enum built_in_function fcode)\n-{\n-  tree dest, size, len, fn, fmt, flag;\n-  const char *fmt_str;\n-\n-  /* Verify the required arguments in the original call.  */\n-  if (nargs < 5)\n-    return NULL_TREE;\n-  dest = args[0];\n-  if (!validate_arg (dest, POINTER_TYPE))\n-    return NULL_TREE;\n-  len = args[1];\n-  if (!validate_arg (len, INTEGER_TYPE))\n-    return NULL_TREE;\n-  flag = args[2];\n-  if (!validate_arg (flag, INTEGER_TYPE))\n-    return NULL_TREE;\n-  size = args[3];\n-  if (!validate_arg (size, INTEGER_TYPE))\n-    return NULL_TREE;\n-  fmt = args[4];\n-  if (!validate_arg (fmt, POINTER_TYPE))\n-    return NULL_TREE;\n-\n-  if (! tree_fits_uhwi_p (size))\n-    return NULL_TREE;\n-\n-  if (! integer_all_onesp (size))\n-    {\n-      if (! tree_fits_uhwi_p (len))\n-\t{\n-\t  /* If LEN is not constant, try MAXLEN too.\n-\t     For MAXLEN only allow optimizing into non-_ocs function\n-\t     if SIZE is >= MAXLEN, never convert to __ocs_fail ().  */\n-\t  if (maxlen == NULL_TREE || ! tree_fits_uhwi_p (maxlen))\n-\t    return NULL_TREE;\n-\t}\n-      else\n-\tmaxlen = len;\n-\n-      if (tree_int_cst_lt (size, maxlen))\n-\treturn NULL_TREE;\n-    }\n-\n-  if (!init_target_chars ())\n-    return NULL_TREE;\n-\n-  /* Only convert __{,v}snprintf_chk to {,v}snprintf if flag is 0\n-     or if format doesn't contain % chars or is \"%s\".  */\n-  if (! integer_zerop (flag))\n-    {\n-      fmt_str = c_getstr (fmt);\n-      if (fmt_str == NULL)\n-\treturn NULL_TREE;\n-      if (strchr (fmt_str, target_percent) != NULL\n-\t  && strcmp (fmt_str, target_percent_s))\n-\treturn NULL_TREE;\n-    }\n-\n-  /* If __builtin_{,v}snprintf_chk is used, assume {,v}snprintf is\n-     available.  */\n-  fn = builtin_decl_explicit (fcode == BUILT_IN_VSNPRINTF_CHK\n-\t\t\t      ? BUILT_IN_VSNPRINTF : BUILT_IN_SNPRINTF);\n-  if (!fn)\n-    return NULL_TREE;\n-\n-  return rewrite_call_expr_array (loc, nargs, args, 5, fn, 3, dest, len, fmt);\n-}\n-\n-/* Fold a call EXP to {,v}snprintf.  Return NULL_TREE if\n-   a normal call should be emitted rather than expanding the function\n-   inline.  FCODE is either BUILT_IN_SNPRINTF_CHK or\n-   BUILT_IN_VSNPRINTF_CHK.  If MAXLEN is not NULL, it is maximum length\n-   passed as second argument.  */\n-\n-static tree\n-fold_builtin_snprintf_chk (location_t loc, tree exp, tree maxlen,\n-\t\t\t   enum built_in_function fcode)\n-{\n-  return fold_builtin_snprintf_chk_1 (loc, call_expr_nargs (exp),\n-\t\t\t\t      CALL_EXPR_ARGP (exp), maxlen, fcode);\n-}\n-\n /* Builtins with folding operations that operate on \"...\" arguments\n    need special handling; we need to store the arguments in a convenient\n    data structure before attempting any folding.  Fortunately there are\n@@ -13099,16 +11896,6 @@ fold_builtin_varargs (location_t loc, tree fndecl, tree exp,\n \n   switch (fcode)\n     {\n-    case BUILT_IN_SPRINTF_CHK:\n-    case BUILT_IN_VSPRINTF_CHK:\n-      ret = fold_builtin_sprintf_chk (loc, exp, fcode);\n-      break;\n-\n-    case BUILT_IN_SNPRINTF_CHK:\n-    case BUILT_IN_VSNPRINTF_CHK:\n-      ret = fold_builtin_snprintf_chk (loc, exp, NULL_TREE, fcode);\n-      break;\n-\n     case BUILT_IN_FPCLASSIFY:\n       ret = fold_builtin_fpclassify (loc, exp);\n       break;\n@@ -13376,7 +12163,7 @@ fold_builtin_fprintf (location_t loc, tree fndecl, tree fp,\n \n /* Initialize format string characters in the target charset.  */\n \n-static bool\n+bool\n init_target_chars (void)\n {\n   static bool init;\n@@ -13993,76 +12780,6 @@ do_mpc_arg2 (tree arg0, tree arg1, tree type, int do_nonfinite,\n   return result;\n }\n \n-/* Fold a call STMT to __{,v}sprintf_chk.  Return NULL_TREE if\n-   a normal call should be emitted rather than expanding the function\n-   inline.  FCODE is either BUILT_IN_SPRINTF_CHK or BUILT_IN_VSPRINTF_CHK.  */\n-\n-static tree\n-gimple_fold_builtin_sprintf_chk (gimple stmt, enum built_in_function fcode)\n-{\n-  int nargs = gimple_call_num_args (stmt);\n-\n-  return fold_builtin_sprintf_chk_1 (gimple_location (stmt), nargs,\n-\t\t\t\t     (nargs > 0\n-\t\t\t\t      ? gimple_call_arg_ptr (stmt, 0)\n-\t\t\t\t      : &error_mark_node), fcode);\n-}\n-\n-/* Fold a call STMT to {,v}snprintf.  Return NULL_TREE if\n-   a normal call should be emitted rather than expanding the function\n-   inline.  FCODE is either BUILT_IN_SNPRINTF_CHK or\n-   BUILT_IN_VSNPRINTF_CHK.  If MAXLEN is not NULL, it is maximum length\n-   passed as second argument.  */\n-\n-tree\n-gimple_fold_builtin_snprintf_chk (gimple stmt, tree maxlen,\n-                                  enum built_in_function fcode)\n-{\n-  int nargs = gimple_call_num_args (stmt);\n-\n-  return fold_builtin_snprintf_chk_1 (gimple_location (stmt), nargs,\n-\t\t\t\t      (nargs > 0\n-\t\t\t\t       ? gimple_call_arg_ptr (stmt, 0)\n-\t\t\t\t       : &error_mark_node), maxlen, fcode);\n-}\n-\n-/* Builtins with folding operations that operate on \"...\" arguments\n-   need special handling; we need to store the arguments in a convenient\n-   data structure before attempting any folding.  Fortunately there are\n-   only a few builtins that fall into this category.  FNDECL is the\n-   function, EXP is the CALL_EXPR for the call, and IGNORE is true if the\n-   result of the function call is ignored.  */\n-\n-static tree\n-gimple_fold_builtin_varargs (tree fndecl, gimple stmt,\n-\t\t\t     bool ignore ATTRIBUTE_UNUSED)\n-{\n-  enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n-  tree ret = NULL_TREE;\n-\n-  switch (fcode)\n-    {\n-    case BUILT_IN_SPRINTF_CHK:\n-    case BUILT_IN_VSPRINTF_CHK:\n-      ret = gimple_fold_builtin_sprintf_chk (stmt, fcode);\n-      break;\n-\n-    case BUILT_IN_SNPRINTF_CHK:\n-    case BUILT_IN_VSNPRINTF_CHK:\n-      ret = gimple_fold_builtin_snprintf_chk (stmt, NULL_TREE, fcode);\n-\n-    default:\n-      break;\n-    }\n-  if (ret)\n-    {\n-      ret = build1 (NOP_EXPR, TREE_TYPE (ret), ret);\n-      TREE_NO_WARNING (ret) = 1;\n-      return ret;\n-    }\n-  return NULL_TREE;\n-}\n-\n /* A wrapper function for builtin folding that prevents warnings for\n    \"statement without effect\" and the like, caused by removing the\n    call node earlier than the warning is generated.  */\n@@ -14093,8 +12810,6 @@ fold_call_stmt (gimple stmt, bool ignore)\n \t{\n \t  if (nargs <= MAX_ARGS_TO_FOLD_BUILTIN)\n \t    ret = fold_builtin_n (loc, fndecl, args, nargs, ignore);\n-\t  if (!ret)\n-\t    ret = gimple_fold_builtin_varargs (fndecl, stmt, ignore);\n \t  if (ret)\n \t    {\n \t      /* Propagate location information from original call to"}, {"sha": "cac2de6a06fa5bdb6efd4134833dbd70487c2000", "filename": "gcc/builtins.h", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=fef5a0d95e0e593ace4be86a8aa27ebdaa92c078", "patch": "@@ -71,29 +71,23 @@ extern void expand_builtin_trap (void);\n extern rtx expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n extern enum built_in_function builtin_mathfn_code (const_tree);\n extern tree fold_builtin_expect (location_t, tree, tree, tree);\n-extern tree fold_builtin_strcpy (location_t, tree, tree, tree, tree);\n-extern tree fold_builtin_strncpy (location_t, tree, tree, tree, tree, tree);\n extern tree fold_fma (location_t, tree, tree, tree, tree);\n extern bool avoid_folding_inline_builtin (tree);\n extern tree fold_call_expr (location_t, tree, bool);\n extern tree fold_builtin_call_array (location_t, tree, tree, int, tree *);\n extern bool validate_gimple_arglist (const_gimple, ...);\n extern rtx default_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n-extern tree fold_builtin_strcat (location_t, tree, tree, tree);\n-extern tree fold_builtin_fputs (location_t, tree, tree, bool, bool, tree);\n extern bool fold_builtin_next_arg (tree, bool);\n-extern tree fold_builtin_memory_chk (location_t, tree, tree, tree, tree, tree,\n-\t\t\t\t     tree, bool, enum built_in_function);\n-extern tree fold_builtin_stxcpy_chk (location_t, tree, tree, tree, tree, tree,\n-\t\t\t\t     bool, enum built_in_function);\n-extern tree fold_builtin_stxncpy_chk (location_t, tree, tree, tree, tree, tree,\n-\t\t\t\t      bool, enum built_in_function);\n-extern tree gimple_fold_builtin_snprintf_chk (gimple, tree,\n-\t\t\t\t\t      enum built_in_function);\n extern tree do_mpc_arg2 (tree, tree, tree, int, int (*)(mpc_ptr, mpc_srcptr, mpc_srcptr, mpc_rnd_t));\n extern tree fold_call_stmt (gimple, bool);\n extern void set_builtin_user_assembler_name (tree decl, const char *asmspec);\n extern bool is_simple_builtin (tree);\n extern bool is_inexpensive_builtin (tree);\n \n+extern bool readonly_data_expr (tree exp);\n+extern const char *c_getstr (tree);\n+extern bool init_target_chars (void);\n+extern unsigned HOST_WIDE_INT target_percent;\n+extern char target_percent_s[3];\n+\n #endif"}, {"sha": "76a243a3ee0acfc74a18bb7e9fe0a735a91d4e42", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1558, "deletions": 267, "changes": 1825, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=fef5a0d95e0e593ace4be86a8aa27ebdaa92c078", "patch": "@@ -54,6 +54,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify-me.h\"\n #include \"dbgcnt.h\"\n #include \"builtins.h\"\n+#include \"output.h\"\n \n /* Return true when DECL can be referenced from current unit.\n    FROM_DECL (if non-null) specify constructor of variable DECL was taken from.\n@@ -626,6 +627,79 @@ fold_gimple_cond (gimple stmt)\n   return false;\n }\n \n+\n+/* Replace a statement at *SI_P with a sequence of statements in STMTS,\n+   adjusting the replacement stmts location and virtual operands.\n+   If the statement has a lhs the last stmt in the sequence is expected\n+   to assign to that lhs.  */\n+\n+static void\n+gsi_replace_with_seq_vops (gimple_stmt_iterator *si_p, gimple_seq stmts)\n+{\n+  gimple stmt = gsi_stmt (*si_p);\n+\n+  if (gimple_has_location (stmt))\n+    annotate_all_with_location (stmts, gimple_location (stmt));\n+\n+  /* First iterate over the replacement statements backward, assigning\n+     virtual operands to their defining statements.  */\n+  gimple laststore = NULL;\n+  for (gimple_stmt_iterator i = gsi_last (stmts);\n+       !gsi_end_p (i); gsi_prev (&i))\n+    {\n+      gimple new_stmt = gsi_stmt (i);\n+      if ((gimple_assign_single_p (new_stmt)\n+\t   && !is_gimple_reg (gimple_assign_lhs (new_stmt)))\n+\t  || (is_gimple_call (new_stmt)\n+\t      && (gimple_call_flags (new_stmt)\n+\t\t  & (ECF_NOVOPS | ECF_PURE | ECF_CONST | ECF_NORETURN)) == 0))\n+\t{\n+\t  tree vdef;\n+\t  if (!laststore)\n+\t    vdef = gimple_vdef (stmt);\n+\t  else\n+\t    vdef = make_ssa_name (gimple_vop (cfun), new_stmt);\n+\t  gimple_set_vdef (new_stmt, vdef);\n+\t  if (vdef && TREE_CODE (vdef) == SSA_NAME)\n+\t    SSA_NAME_DEF_STMT (vdef) = new_stmt;\n+\t  laststore = new_stmt;\n+\t}\n+    }\n+\n+  /* Second iterate over the statements forward, assigning virtual\n+     operands to their uses.  */\n+  tree reaching_vuse = gimple_vuse (stmt);\n+  for (gimple_stmt_iterator i = gsi_start (stmts);\n+       !gsi_end_p (i); gsi_next (&i))\n+    {\n+      gimple new_stmt = gsi_stmt (i);\n+      /* If the new statement possibly has a VUSE, update it with exact SSA\n+\t name we know will reach this one.  */\n+      if (gimple_has_mem_ops (new_stmt))\n+\tgimple_set_vuse (new_stmt, reaching_vuse);\n+      gimple_set_modified (new_stmt, true);\n+      if (gimple_vdef (new_stmt))\n+\treaching_vuse = gimple_vdef (new_stmt);\n+    }\n+\n+  /* If the new sequence does not do a store release the virtual\n+     definition of the original statement.  */\n+  if (reaching_vuse\n+      && reaching_vuse == gimple_vuse (stmt))\n+    {\n+      tree vdef = gimple_vdef (stmt);\n+      if (vdef\n+\t  && TREE_CODE (vdef) == SSA_NAME)\n+\t{\n+\t  unlink_stmt_vdef (stmt);\n+\t  release_ssa_name (vdef);\n+\t}\n+    }\n+\n+  /* Finally replace the original statement with the sequence.  */\n+  gsi_replace_with_seq (si_p, stmts, false);\n+}\n+\n /* Convert EXPR into a GIMPLE value suitable for substitution on the\n    RHS of an assignment.  Insert the necessary statements before\n    iterator *SI_P.  The statement at *SI_P, which must be a GIMPLE_CALL\n@@ -643,8 +717,6 @@ gimplify_and_update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n   gimple stmt, new_stmt;\n   gimple_stmt_iterator i;\n   gimple_seq stmts = NULL;\n-  gimple laststore;\n-  tree reaching_vuse;\n \n   stmt = gsi_stmt (*si_p);\n \n@@ -681,240 +753,1431 @@ gimplify_and_update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n \n   pop_gimplify_context (NULL);\n \n-  if (gimple_has_location (stmt))\n-    annotate_all_with_location (stmts, gimple_location (stmt));\n+  gsi_replace_with_seq_vops (si_p, stmts);\n+}\n \n-  /* First iterate over the replacement statements backward, assigning\n-     virtual operands to their defining statements.  */\n-  laststore = NULL;\n-  for (i = gsi_last (stmts); !gsi_end_p (i); gsi_prev (&i))\n+\n+/* Replace the call at *GSI with the gimple value VAL.  */\n+\n+static void\n+replace_call_with_value (gimple_stmt_iterator *gsi, tree val)\n+{\n+  gimple stmt = gsi_stmt (*gsi);\n+  tree lhs = gimple_call_lhs (stmt);\n+  gimple repl;\n+  if (lhs)\n     {\n-      new_stmt = gsi_stmt (i);\n-      if ((gimple_assign_single_p (new_stmt)\n-\t   && !is_gimple_reg (gimple_assign_lhs (new_stmt)))\n-\t  || (is_gimple_call (new_stmt)\n-\t      && (gimple_call_flags (new_stmt)\n-\t\t  & (ECF_NOVOPS | ECF_PURE | ECF_CONST | ECF_NORETURN)) == 0))\n+      if (!useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (val)))\n+\tval = fold_convert (TREE_TYPE (lhs), val);\n+      repl = gimple_build_assign (lhs, val);\n+    }\n+  else\n+    repl = gimple_build_nop ();\n+  tree vdef = gimple_vdef (stmt);\n+  if (vdef && TREE_CODE (vdef) == SSA_NAME)\n+    {\n+      unlink_stmt_vdef (stmt);\n+      release_ssa_name (vdef);\n+    }\n+  gsi_replace (gsi, repl, true);\n+}\n+\n+/* Replace the call at *GSI with the new call REPL and fold that\n+   again.  */\n+\n+static void\n+replace_call_with_call_and_fold (gimple_stmt_iterator *gsi, gimple repl)\n+{\n+  gimple stmt = gsi_stmt (*gsi);\n+  gimple_call_set_lhs (repl, gimple_call_lhs (stmt));\n+  gimple_set_location (repl, gimple_location (stmt));\n+  if (gimple_vdef (stmt)\n+      && TREE_CODE (gimple_vdef (stmt)) == SSA_NAME)\n+    {\n+      gimple_set_vdef (repl, gimple_vdef (stmt));\n+      gimple_set_vuse (repl, gimple_vuse (stmt));\n+      SSA_NAME_DEF_STMT (gimple_vdef (repl)) = repl;\n+    }\n+  gsi_replace (gsi, repl, true);\n+  fold_stmt (gsi);\n+}\n+\n+/* Return true if VAR is a VAR_DECL or a component thereof.  */\n+\n+static bool\n+var_decl_component_p (tree var)\n+{\n+  tree inner = var;\n+  while (handled_component_p (inner))\n+    inner = TREE_OPERAND (inner, 0);\n+  return SSA_VAR_P (inner);\n+}\n+\n+/* Fold function call to builtin mem{{,p}cpy,move}.  Return\n+   NULL_TREE if no simplification can be made.\n+   If ENDP is 0, return DEST (like memcpy).\n+   If ENDP is 1, return DEST+LEN (like mempcpy).\n+   If ENDP is 2, return DEST+LEN-1 (like stpcpy).\n+   If ENDP is 3, return DEST, additionally *SRC and *DEST may overlap\n+   (memmove).   */\n+\n+static bool\n+gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n+\t\t\t       tree dest, tree src, int endp)\n+{\n+  gimple stmt = gsi_stmt (*gsi);\n+  tree lhs = gimple_call_lhs (stmt);\n+  tree len = gimple_call_arg (stmt, 2);\n+  tree destvar, srcvar;\n+  location_t loc = gimple_location (stmt);\n+\n+  /* If the LEN parameter is zero, return DEST.  */\n+  if (integer_zerop (len))\n+    {\n+      gimple repl;\n+      if (gimple_call_lhs (stmt))\n+\trepl = gimple_build_assign (gimple_call_lhs (stmt), dest);\n+      else\n+\trepl = gimple_build_nop ();\n+      tree vdef = gimple_vdef (stmt);\n+      if (vdef && TREE_CODE (vdef) == SSA_NAME)\n \t{\n-\t  tree vdef;\n-\t  if (!laststore)\n-\t    vdef = gimple_vdef (stmt);\n+\t  unlink_stmt_vdef (stmt);\n+\t  release_ssa_name (vdef);\n+\t}\n+      gsi_replace (gsi, repl, true);\n+      return true;\n+    }\n+\n+  /* If SRC and DEST are the same (and not volatile), return\n+     DEST{,+LEN,+LEN-1}.  */\n+  if (operand_equal_p (src, dest, 0))\n+    {\n+      unlink_stmt_vdef (stmt);\n+      if (gimple_vdef (stmt) && TREE_CODE (gimple_vdef (stmt)) == SSA_NAME)\n+\trelease_ssa_name (gimple_vdef (stmt));\n+      if (!lhs)\n+\t{\n+\t  gsi_replace (gsi, gimple_build_nop (), true);\n+\t  return true;\n+\t}\n+      goto done;\n+    }\n+  else\n+    {\n+      tree srctype, desttype;\n+      unsigned int src_align, dest_align;\n+      tree off0;\n+\n+      /* Build accesses at offset zero with a ref-all character type.  */\n+      off0 = build_int_cst (build_pointer_type_for_mode (char_type_node,\n+\t\t\t\t\t\t\t ptr_mode, true), 0);\n+\n+      /* If we can perform the copy efficiently with first doing all loads\n+         and then all stores inline it that way.  Currently efficiently\n+\t means that we can load all the memory into a single integer\n+\t register which is what MOVE_MAX gives us.  */\n+      src_align = get_pointer_alignment (src);\n+      dest_align = get_pointer_alignment (dest);\n+      if (tree_fits_uhwi_p (len)\n+\t  && compare_tree_int (len, MOVE_MAX) <= 0\n+\t  /* ???  Don't transform copies from strings with known length this\n+\t     confuses the tree-ssa-strlen.c.  This doesn't handle\n+\t     the case in gcc.dg/strlenopt-8.c which is XFAILed for that\n+\t     reason.  */\n+\t  && !c_strlen (src, 2))\n+\t{\n+\t  unsigned ilen = tree_to_uhwi (len);\n+\t  if (exact_log2 (ilen) != -1)\n+\t    {\n+\t      tree type = lang_hooks.types.type_for_size (ilen * 8, 1);\n+\t      if (type\n+\t\t  && TYPE_MODE (type) != BLKmode\n+\t\t  && (GET_MODE_SIZE (TYPE_MODE (type)) * BITS_PER_UNIT\n+\t\t      == ilen * 8)\n+\t\t  /* If the destination pointer is not aligned we must be able\n+\t\t     to emit an unaligned store.  */\n+\t\t  && (dest_align >= GET_MODE_ALIGNMENT (TYPE_MODE (type))\n+\t\t      || !SLOW_UNALIGNED_ACCESS (TYPE_MODE (type), dest_align)))\n+\t\t{\n+\t\t  tree srctype = type;\n+\t\t  tree desttype = type;\n+\t\t  if (src_align < GET_MODE_ALIGNMENT (TYPE_MODE (type)))\n+\t\t    srctype = build_aligned_type (type, src_align);\n+\t\t  tree srcmem = fold_build2 (MEM_REF, srctype, src, off0);\n+\t\t  tree tem = fold_const_aggregate_ref (srcmem);\n+\t\t  if (tem)\n+\t\t    srcmem = tem;\n+\t\t  else if (src_align < GET_MODE_ALIGNMENT (TYPE_MODE (type))\n+\t\t\t   && SLOW_UNALIGNED_ACCESS (TYPE_MODE (type),\n+\t\t\t\t\t\t     src_align))\n+\t\t    srcmem = NULL_TREE;\n+\t\t  if (srcmem)\n+\t\t    {\n+\t\t      gimple new_stmt;\n+\t\t      if (is_gimple_reg_type (TREE_TYPE (srcmem)))\n+\t\t\t{\n+\t\t\t  new_stmt = gimple_build_assign (NULL_TREE, srcmem);\n+\t\t\t  if (gimple_in_ssa_p (cfun))\n+\t\t\t    srcmem = make_ssa_name (TREE_TYPE (srcmem),\n+\t\t\t\t\t\t    new_stmt);\n+\t\t\t  else\n+\t\t\t    srcmem = create_tmp_reg (TREE_TYPE (srcmem),\n+\t\t\t\t\t\t     NULL);\n+\t\t\t  gimple_assign_set_lhs (new_stmt, srcmem);\n+\t\t\t  gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n+\t\t\t  gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n+\t\t\t}\n+\t\t      if (dest_align < GET_MODE_ALIGNMENT (TYPE_MODE (type)))\n+\t\t\tdesttype = build_aligned_type (type, dest_align);\n+\t\t      new_stmt\n+\t\t\t= gimple_build_assign (fold_build2 (MEM_REF, desttype,\n+\t\t\t\t\t\t\t    dest, off0),\n+\t\t\t\t\t       srcmem);\n+\t\t      gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n+\t\t      gimple_set_vdef (new_stmt, gimple_vdef (stmt));\n+\t\t      if (gimple_vdef (new_stmt)\n+\t\t\t  && TREE_CODE (gimple_vdef (new_stmt)) == SSA_NAME)\n+\t\t\tSSA_NAME_DEF_STMT (gimple_vdef (new_stmt)) = new_stmt;\n+\t\t      if (!lhs)\n+\t\t\t{\n+\t\t\t  gsi_replace (gsi, new_stmt, true);\n+\t\t\t  return true;\n+\t\t\t}\n+\t\t      gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n+\t\t      goto done;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (endp == 3)\n+\t{\n+\t  /* Both DEST and SRC must be pointer types.\n+\t     ??? This is what old code did.  Is the testing for pointer types\n+\t     really mandatory?\n+\n+\t     If either SRC is readonly or length is 1, we can use memcpy.  */\n+\t  if (!dest_align || !src_align)\n+\t    return false;\n+\t  if (readonly_data_expr (src)\n+\t      || (tree_fits_uhwi_p (len)\n+\t\t  && (MIN (src_align, dest_align) / BITS_PER_UNIT\n+\t\t      >= tree_to_uhwi (len))))\n+\t    {\n+\t      tree fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n+\t      if (!fn)\n+\t\treturn false;\n+\t      gimple_call_set_fndecl (stmt, fn);\n+\t      gimple_call_set_arg (stmt, 0, dest);\n+\t      gimple_call_set_arg (stmt, 1, src);\n+\t      fold_stmt (gsi);\n+\t      return true;\n+\t    }\n+\n+\t  /* If *src and *dest can't overlap, optimize into memcpy as well.  */\n+\t  if (TREE_CODE (src) == ADDR_EXPR\n+\t      && TREE_CODE (dest) == ADDR_EXPR)\n+\t    {\n+\t      tree src_base, dest_base, fn;\n+\t      HOST_WIDE_INT src_offset = 0, dest_offset = 0;\n+\t      HOST_WIDE_INT size = -1;\n+\t      HOST_WIDE_INT maxsize = -1;\n+\n+\t      srcvar = TREE_OPERAND (src, 0);\n+\t      src_base = get_ref_base_and_extent (srcvar, &src_offset,\n+\t\t\t\t\t\t  &size, &maxsize);\n+\t      destvar = TREE_OPERAND (dest, 0);\n+\t      dest_base = get_ref_base_and_extent (destvar, &dest_offset,\n+\t\t\t\t\t\t   &size, &maxsize);\n+\t      if (tree_fits_uhwi_p (len))\n+\t\tmaxsize = tree_to_uhwi (len);\n+\t      else\n+\t\tmaxsize = -1;\n+\t      src_offset /= BITS_PER_UNIT;\n+\t      dest_offset /= BITS_PER_UNIT;\n+\t      if (SSA_VAR_P (src_base)\n+\t\t  && SSA_VAR_P (dest_base))\n+\t\t{\n+\t\t  if (operand_equal_p (src_base, dest_base, 0)\n+\t\t      && ranges_overlap_p (src_offset, maxsize,\n+\t\t\t\t\t   dest_offset, maxsize))\n+\t\t    return false;\n+\t\t}\n+\t      else if (TREE_CODE (src_base) == MEM_REF\n+\t\t       && TREE_CODE (dest_base) == MEM_REF)\n+\t\t{\n+\t\t  if (! operand_equal_p (TREE_OPERAND (src_base, 0),\n+\t\t\t\t\t TREE_OPERAND (dest_base, 0), 0))\n+\t\t    return false;\n+\t\t  offset_int off = mem_ref_offset (src_base) + src_offset;\n+\t\t  if (!wi::fits_shwi_p (off))\n+\t\t    return false;\n+\t\t  src_offset = off.to_shwi ();\n+\n+\t\t  off = mem_ref_offset (dest_base) + dest_offset;\n+\t\t  if (!wi::fits_shwi_p (off))\n+\t\t    return false;\n+\t\t  dest_offset = off.to_shwi ();\n+\t\t  if (ranges_overlap_p (src_offset, maxsize,\n+\t\t\t\t\tdest_offset, maxsize))\n+\t\t    return false;\n+\t\t}\n+\t      else\n+\t\treturn false;\n+\n+\t      fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n+\t      if (!fn)\n+\t\treturn false;\n+\t      gimple_call_set_fndecl (stmt, fn);\n+\t      gimple_call_set_arg (stmt, 0, dest);\n+\t      gimple_call_set_arg (stmt, 1, src);\n+\t      fold_stmt (gsi);\n+\t      return true;\n+\t    }\n+\n+\t  /* If the destination and source do not alias optimize into\n+\t     memcpy as well.  */\n+\t  if ((is_gimple_min_invariant (dest)\n+\t       || TREE_CODE (dest) == SSA_NAME)\n+\t      && (is_gimple_min_invariant (src)\n+\t\t  || TREE_CODE (src) == SSA_NAME))\n+\t    {\n+\t      ao_ref destr, srcr;\n+\t      ao_ref_init_from_ptr_and_size (&destr, dest, len);\n+\t      ao_ref_init_from_ptr_and_size (&srcr, src, len);\n+\t      if (!refs_may_alias_p_1 (&destr, &srcr, false))\n+\t\t{\n+\t\t  tree fn;\n+\t\t  fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n+\t\t  if (!fn)\n+\t\t    return false;\n+\t\t  gimple_call_set_fndecl (stmt, fn);\n+\t\t  gimple_call_set_arg (stmt, 0, dest);\n+\t\t  gimple_call_set_arg (stmt, 1, src);\n+\t\t  fold_stmt (gsi);\n+\t\t  return true;\n+\t\t}\n+\t    }\n+\n+\t  return false;\n+\t}\n+\n+      if (!tree_fits_shwi_p (len))\n+\treturn false;\n+      /* FIXME:\n+         This logic lose for arguments like (type *)malloc (sizeof (type)),\n+         since we strip the casts of up to VOID return value from malloc.\n+\t Perhaps we ought to inherit type from non-VOID argument here?  */\n+      STRIP_NOPS (src);\n+      STRIP_NOPS (dest);\n+      if (!POINTER_TYPE_P (TREE_TYPE (src))\n+\t  || !POINTER_TYPE_P (TREE_TYPE (dest)))\n+\treturn false;\n+      /* In the following try to find a type that is most natural to be\n+\t used for the memcpy source and destination and that allows\n+\t the most optimization when memcpy is turned into a plain assignment\n+\t using that type.  In theory we could always use a char[len] type\n+\t but that only gains us that the destination and source possibly\n+\t no longer will have their address taken.  */\n+      /* As we fold (void *)(p + CST) to (void *)p + CST undo this here.  */\n+      if (TREE_CODE (src) == POINTER_PLUS_EXPR)\n+\t{\n+\t  tree tem = TREE_OPERAND (src, 0);\n+\t  STRIP_NOPS (tem);\n+\t  if (tem != TREE_OPERAND (src, 0))\n+\t    src = build1 (NOP_EXPR, TREE_TYPE (tem), src);\n+\t}\n+      if (TREE_CODE (dest) == POINTER_PLUS_EXPR)\n+\t{\n+\t  tree tem = TREE_OPERAND (dest, 0);\n+\t  STRIP_NOPS (tem);\n+\t  if (tem != TREE_OPERAND (dest, 0))\n+\t    dest = build1 (NOP_EXPR, TREE_TYPE (tem), dest);\n+\t}\n+      srctype = TREE_TYPE (TREE_TYPE (src));\n+      if (TREE_CODE (srctype) == ARRAY_TYPE\n+\t  && !tree_int_cst_equal (TYPE_SIZE_UNIT (srctype), len))\n+\t{\n+\t  srctype = TREE_TYPE (srctype);\n+\t  STRIP_NOPS (src);\n+\t  src = build1 (NOP_EXPR, build_pointer_type (srctype), src);\n+\t}\n+      desttype = TREE_TYPE (TREE_TYPE (dest));\n+      if (TREE_CODE (desttype) == ARRAY_TYPE\n+\t  && !tree_int_cst_equal (TYPE_SIZE_UNIT (desttype), len))\n+\t{\n+\t  desttype = TREE_TYPE (desttype);\n+\t  STRIP_NOPS (dest);\n+\t  dest = build1 (NOP_EXPR, build_pointer_type (desttype), dest);\n+\t}\n+      if (TREE_ADDRESSABLE (srctype)\n+\t  || TREE_ADDRESSABLE (desttype))\n+\treturn false;\n+\n+      /* Make sure we are not copying using a floating-point mode or\n+         a type whose size possibly does not match its precision.  */\n+      if (FLOAT_MODE_P (TYPE_MODE (desttype))\n+\t  || TREE_CODE (desttype) == BOOLEAN_TYPE\n+\t  || TREE_CODE (desttype) == ENUMERAL_TYPE)\n+\tdesttype = bitwise_type_for_mode (TYPE_MODE (desttype));\n+      if (FLOAT_MODE_P (TYPE_MODE (srctype))\n+\t  || TREE_CODE (srctype) == BOOLEAN_TYPE\n+\t  || TREE_CODE (srctype) == ENUMERAL_TYPE)\n+\tsrctype = bitwise_type_for_mode (TYPE_MODE (srctype));\n+      if (!srctype)\n+\tsrctype = desttype;\n+      if (!desttype)\n+\tdesttype = srctype;\n+      if (!srctype)\n+\treturn false;\n+\n+      src_align = get_pointer_alignment (src);\n+      dest_align = get_pointer_alignment (dest);\n+      if (dest_align < TYPE_ALIGN (desttype)\n+\t  || src_align < TYPE_ALIGN (srctype))\n+\treturn false;\n+\n+      destvar = dest;\n+      STRIP_NOPS (destvar);\n+      if (TREE_CODE (destvar) == ADDR_EXPR\n+\t  && var_decl_component_p (TREE_OPERAND (destvar, 0))\n+\t  && tree_int_cst_equal (TYPE_SIZE_UNIT (desttype), len))\n+\tdestvar = fold_build2 (MEM_REF, desttype, destvar, off0);\n+      else\n+\tdestvar = NULL_TREE;\n+\n+      srcvar = src;\n+      STRIP_NOPS (srcvar);\n+      if (TREE_CODE (srcvar) == ADDR_EXPR\n+\t  && var_decl_component_p (TREE_OPERAND (srcvar, 0))\n+\t  && tree_int_cst_equal (TYPE_SIZE_UNIT (srctype), len))\n+\t{\n+\t  if (!destvar\n+\t      || src_align >= TYPE_ALIGN (desttype))\n+\t    srcvar = fold_build2 (MEM_REF, destvar ? desttype : srctype,\n+\t\t\t\t  srcvar, off0);\n+\t  else if (!STRICT_ALIGNMENT)\n+\t    {\n+\t      srctype = build_aligned_type (TYPE_MAIN_VARIANT (desttype),\n+\t\t\t\t\t    src_align);\n+\t      srcvar = fold_build2 (MEM_REF, srctype, srcvar, off0);\n+\t    }\n \t  else\n-\t    vdef = make_ssa_name (gimple_vop (cfun), new_stmt);\n-\t  gimple_set_vdef (new_stmt, vdef);\n-\t  if (vdef && TREE_CODE (vdef) == SSA_NAME)\n-\t    SSA_NAME_DEF_STMT (vdef) = new_stmt;\n-\t  laststore = new_stmt;\n+\t    srcvar = NULL_TREE;\n+\t}\n+      else\n+\tsrcvar = NULL_TREE;\n+\n+      if (srcvar == NULL_TREE && destvar == NULL_TREE)\n+\treturn false;\n+\n+      if (srcvar == NULL_TREE)\n+\t{\n+\t  STRIP_NOPS (src);\n+\t  if (src_align >= TYPE_ALIGN (desttype))\n+\t    srcvar = fold_build2 (MEM_REF, desttype, src, off0);\n+\t  else\n+\t    {\n+\t      if (STRICT_ALIGNMENT)\n+\t\treturn false;\n+\t      srctype = build_aligned_type (TYPE_MAIN_VARIANT (desttype),\n+\t\t\t\t\t    src_align);\n+\t      srcvar = fold_build2 (MEM_REF, srctype, src, off0);\n+\t    }\n+\t}\n+      else if (destvar == NULL_TREE)\n+\t{\n+\t  STRIP_NOPS (dest);\n+\t  if (dest_align >= TYPE_ALIGN (srctype))\n+\t    destvar = fold_build2 (MEM_REF, srctype, dest, off0);\n+\t  else\n+\t    {\n+\t      if (STRICT_ALIGNMENT)\n+\t\treturn false;\n+\t      desttype = build_aligned_type (TYPE_MAIN_VARIANT (srctype),\n+\t\t\t\t\t     dest_align);\n+\t      destvar = fold_build2 (MEM_REF, desttype, dest, off0);\n+\t    }\n+\t}\n+\n+      gimple new_stmt;\n+      if (is_gimple_reg_type (TREE_TYPE (srcvar)))\n+\t{\n+\t  new_stmt = gimple_build_assign (NULL_TREE, srcvar);\n+\t  if (gimple_in_ssa_p (cfun))\n+\t    srcvar = make_ssa_name (TREE_TYPE (srcvar), new_stmt);\n+\t  else\n+\t    srcvar = create_tmp_reg (TREE_TYPE (srcvar), NULL);\n+\t  gimple_assign_set_lhs (new_stmt, srcvar);\n+\t  gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n+\t  gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n+\t}\n+      new_stmt = gimple_build_assign (destvar, srcvar);\n+      gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n+      gimple_set_vdef (new_stmt, gimple_vdef (stmt));\n+      if (gimple_vdef (new_stmt)\n+\t  && TREE_CODE (gimple_vdef (new_stmt)) == SSA_NAME)\n+\tSSA_NAME_DEF_STMT (gimple_vdef (new_stmt)) = new_stmt;\n+      if (!lhs)\n+\t{\n+\t  gsi_replace (gsi, new_stmt, true);\n+\t  return true;\n \t}\n+      gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n+    }\n+\n+done:\n+  if (endp == 0 || endp == 3)\n+    len = NULL_TREE;\n+  else if (endp == 2)\n+    len = fold_build2_loc (loc, MINUS_EXPR, TREE_TYPE (len), len,\n+\t\t\t   ssize_int (1));\n+  if (endp == 2 || endp == 1)\n+    dest = fold_build_pointer_plus_loc (loc, dest, len);\n+\n+  dest = force_gimple_operand_gsi (gsi, dest, false, NULL_TREE, true,\n+\t\t\t\t   GSI_SAME_STMT);\n+  gimple repl = gimple_build_assign (lhs, dest);\n+  gsi_replace (gsi, repl, true);\n+  return true;\n+}\n+\n+/* Fold function call to builtin memset or bzero at *GSI setting the\n+   memory of size LEN to VAL.  Return whether a simplification was made.  */\n+\n+static bool\n+gimple_fold_builtin_memset (gimple_stmt_iterator *gsi, tree c, tree len)\n+{\n+  gimple stmt = gsi_stmt (*gsi);\n+  tree etype;\n+  unsigned HOST_WIDE_INT length, cval;\n+\n+  /* If the LEN parameter is zero, return DEST.  */\n+  if (integer_zerop (len))\n+    {\n+      replace_call_with_value (gsi, gimple_call_arg (stmt, 0));\n+      return true;\n+    }\n+\n+  if (! tree_fits_uhwi_p (len))\n+    return false;\n+\n+  if (TREE_CODE (c) != INTEGER_CST)\n+    return false;\n+\n+  tree dest = gimple_call_arg (stmt, 0);\n+  tree var = dest;\n+  if (TREE_CODE (var) != ADDR_EXPR)\n+    return false;\n+\n+  var = TREE_OPERAND (var, 0);\n+  if (TREE_THIS_VOLATILE (var))\n+    return false;\n+\n+  etype = TREE_TYPE (var);\n+  if (TREE_CODE (etype) == ARRAY_TYPE)\n+    etype = TREE_TYPE (etype);\n+\n+  if (!INTEGRAL_TYPE_P (etype)\n+      && !POINTER_TYPE_P (etype))\n+    return NULL_TREE;\n+\n+  if (! var_decl_component_p (var))\n+    return NULL_TREE;\n+\n+  length = tree_to_uhwi (len);\n+  if (GET_MODE_SIZE (TYPE_MODE (etype)) != length\n+      || get_pointer_alignment (dest) / BITS_PER_UNIT < length)\n+    return NULL_TREE;\n+\n+  if (length > HOST_BITS_PER_WIDE_INT / BITS_PER_UNIT)\n+    return NULL_TREE;\n+\n+  if (integer_zerop (c))\n+    cval = 0;\n+  else\n+    {\n+      if (CHAR_BIT != 8 || BITS_PER_UNIT != 8 || HOST_BITS_PER_WIDE_INT > 64)\n+\treturn NULL_TREE;\n+\n+      cval = TREE_INT_CST_LOW (c);\n+      cval &= 0xff;\n+      cval |= cval << 8;\n+      cval |= cval << 16;\n+      cval |= (cval << 31) << 1;\n+    }\n+\n+  var = fold_build2 (MEM_REF, etype, dest, build_int_cst (ptr_type_node, 0));\n+  gimple store = gimple_build_assign (var, build_int_cst_type (etype, cval));\n+  gimple_set_vuse (store, gimple_vuse (stmt));\n+  tree vdef = gimple_vdef (stmt);\n+  if (vdef && TREE_CODE (vdef) == SSA_NAME)\n+    {\n+      gimple_set_vdef (store, gimple_vdef (stmt));\n+      SSA_NAME_DEF_STMT (gimple_vdef (stmt)) = store;\n+    }\n+  gsi_insert_before (gsi, store, GSI_SAME_STMT);\n+  if (gimple_call_lhs (stmt))\n+    {\n+      gimple asgn = gimple_build_assign (gimple_call_lhs (stmt), dest);\n+      gsi_replace (gsi, asgn, true);\n+    }\n+  else\n+    {\n+      gimple_stmt_iterator gsi2 = *gsi;\n+      gsi_prev (gsi);\n+      gsi_remove (&gsi2, true);\n     }\n \n-  /* Second iterate over the statements forward, assigning virtual\n-     operands to their uses.  */\n-  reaching_vuse = gimple_vuse (stmt);\n-  for (i = gsi_start (stmts); !gsi_end_p (i); gsi_next (&i))\n+  return true;\n+}\n+\n+\n+/* Return the string length, maximum string length or maximum value of\n+   ARG in LENGTH.\n+   If ARG is an SSA name variable, follow its use-def chains.  If LENGTH\n+   is not NULL and, for TYPE == 0, its value is not equal to the length\n+   we determine or if we are unable to determine the length or value,\n+   return false.  VISITED is a bitmap of visited variables.\n+   TYPE is 0 if string length should be returned, 1 for maximum string\n+   length and 2 for maximum value ARG can have.  */\n+\n+static bool\n+get_maxval_strlen (tree arg, tree *length, bitmap visited, int type)\n+{\n+  tree var, val;\n+  gimple def_stmt;\n+\n+  if (TREE_CODE (arg) != SSA_NAME)\n+    {\n+      /* We can end up with &(*iftmp_1)[0] here as well, so handle it.  */\n+      if (TREE_CODE (arg) == ADDR_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (arg, 0)) == ARRAY_REF\n+\t  && integer_zerop (TREE_OPERAND (TREE_OPERAND (arg, 0), 1)))\n+\t{\n+\t  tree aop0 = TREE_OPERAND (TREE_OPERAND (arg, 0), 0);\n+\t  if (TREE_CODE (aop0) == INDIRECT_REF\n+\t      && TREE_CODE (TREE_OPERAND (aop0, 0)) == SSA_NAME)\n+\t    return get_maxval_strlen (TREE_OPERAND (aop0, 0),\n+\t\t\t\t      length, visited, type);\n+\t}\n+\n+      if (type == 2)\n+\t{\n+\t  val = arg;\n+\t  if (TREE_CODE (val) != INTEGER_CST\n+\t      || tree_int_cst_sgn (val) < 0)\n+\t    return false;\n+\t}\n+      else\n+\tval = c_strlen (arg, 1);\n+      if (!val)\n+\treturn false;\n+\n+      if (*length)\n+\t{\n+\t  if (type > 0)\n+\t    {\n+\t      if (TREE_CODE (*length) != INTEGER_CST\n+\t\t  || TREE_CODE (val) != INTEGER_CST)\n+\t\treturn false;\n+\n+\t      if (tree_int_cst_lt (*length, val))\n+\t\t*length = val;\n+\t      return true;\n+\t    }\n+\t  else if (simple_cst_equal (val, *length) != 1)\n+\t    return false;\n+\t}\n+\n+      *length = val;\n+      return true;\n+    }\n+\n+  /* If ARG is registered for SSA update we cannot look at its defining\n+     statement.  */\n+  if (name_registered_for_update_p (arg))\n+    return false;\n+\n+  /* If we were already here, break the infinite cycle.  */\n+  if (!bitmap_set_bit (visited, SSA_NAME_VERSION (arg)))\n+    return true;\n+\n+  var = arg;\n+  def_stmt = SSA_NAME_DEF_STMT (var);\n+\n+  switch (gimple_code (def_stmt))\n+    {\n+      case GIMPLE_ASSIGN:\n+        /* The RHS of the statement defining VAR must either have a\n+           constant length or come from another SSA_NAME with a constant\n+           length.  */\n+        if (gimple_assign_single_p (def_stmt)\n+            || gimple_assign_unary_nop_p (def_stmt))\n+          {\n+            tree rhs = gimple_assign_rhs1 (def_stmt);\n+            return get_maxval_strlen (rhs, length, visited, type);\n+          }\n+\telse if (gimple_assign_rhs_code (def_stmt) == COND_EXPR)\n+\t  {\n+\t    tree op2 = gimple_assign_rhs2 (def_stmt);\n+\t    tree op3 = gimple_assign_rhs3 (def_stmt);\n+\t    return get_maxval_strlen (op2, length, visited, type)\n+\t\t   && get_maxval_strlen (op3, length, visited, type);\n+          }\n+        return false;\n+\n+      case GIMPLE_PHI:\n+\t{\n+\t  /* All the arguments of the PHI node must have the same constant\n+\t     length.  */\n+\t  unsigned i;\n+\n+\t  for (i = 0; i < gimple_phi_num_args (def_stmt); i++)\n+          {\n+            tree arg = gimple_phi_arg (def_stmt, i)->def;\n+\n+            /* If this PHI has itself as an argument, we cannot\n+               determine the string length of this argument.  However,\n+               if we can find a constant string length for the other\n+               PHI args then we can still be sure that this is a\n+               constant string length.  So be optimistic and just\n+               continue with the next argument.  */\n+            if (arg == gimple_phi_result (def_stmt))\n+              continue;\n+\n+            if (!get_maxval_strlen (arg, length, visited, type))\n+              return false;\n+          }\n+        }\n+        return true;\n+\n+      default:\n+        return false;\n+    }\n+}\n+\n+\n+/* Fold function call to builtin strcpy with arguments DEST and SRC.\n+   If LEN is not NULL, it represents the length of the string to be\n+   copied.  Return NULL_TREE if no simplification can be made.  */\n+\n+static bool\n+gimple_fold_builtin_strcpy (gimple_stmt_iterator *gsi,\n+\t\t\t    location_t loc, tree dest, tree src, tree len)\n+{\n+  tree fn;\n+\n+  /* If SRC and DEST are the same (and not volatile), return DEST.  */\n+  if (operand_equal_p (src, dest, 0))\n+    {\n+      replace_call_with_value (gsi, dest);\n+      return true;\n+    }\n+\n+  if (optimize_function_for_size_p (cfun))\n+    return false;\n+\n+  fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n+  if (!fn)\n+    return false;\n+\n+  if (!len)\n+    {\n+      len = c_strlen (src, 1);\n+      if (! len || TREE_SIDE_EFFECTS (len))\n+\treturn NULL_TREE;\n+    }\n+\n+  len = fold_convert_loc (loc, size_type_node, len);\n+  len = size_binop_loc (loc, PLUS_EXPR, len, build_int_cst (size_type_node, 1));\n+  len = force_gimple_operand_gsi (gsi, len, true,\n+\t\t\t\t  NULL_TREE, true, GSI_SAME_STMT);\n+  gimple repl = gimple_build_call (fn, 3, dest, src, len);\n+  replace_call_with_call_and_fold (gsi, repl);\n+  return true;\n+}\n+\n+/* Fold function call to builtin strncpy with arguments DEST, SRC, and LEN.\n+   If SLEN is not NULL, it represents the length of the source string.\n+   Return NULL_TREE if no simplification can be made.  */\n+\n+static bool\n+gimple_fold_builtin_strncpy (gimple_stmt_iterator *gsi, location_t loc,\n+\t\t\t     tree dest, tree src, tree len, tree slen)\n+{\n+  tree fn;\n+\n+  /* If the LEN parameter is zero, return DEST.  */\n+  if (integer_zerop (len))\n+    {\n+      replace_call_with_value (gsi, dest);\n+      return true;\n+    }\n+\n+  /* We can't compare slen with len as constants below if len is not a\n+     constant.  */\n+  if (len == 0 || TREE_CODE (len) != INTEGER_CST)\n+    return false;\n+\n+  if (!slen)\n+    slen = c_strlen (src, 1);\n+\n+  /* Now, we must be passed a constant src ptr parameter.  */\n+  if (slen == 0 || TREE_CODE (slen) != INTEGER_CST)\n+    return false;\n+\n+  slen = size_binop_loc (loc, PLUS_EXPR, slen, ssize_int (1));\n+\n+  /* We do not support simplification of this case, though we do\n+     support it when expanding trees into RTL.  */\n+  /* FIXME: generate a call to __builtin_memset.  */\n+  if (tree_int_cst_lt (slen, len))\n+    return false;\n+\n+  /* OK transform into builtin memcpy.  */\n+  fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n+  if (!fn)\n+    return false;\n+\n+  len = fold_convert_loc (loc, size_type_node, len);\n+  len = force_gimple_operand_gsi (gsi, len, true,\n+\t\t\t\t  NULL_TREE, true, GSI_SAME_STMT);\n+  gimple repl = gimple_build_call (fn, 3, dest, src, len);\n+  replace_call_with_call_and_fold (gsi, repl);\n+  return true;\n+}\n+\n+/* Simplify a call to the strcat builtin.  DST and SRC are the arguments\n+   to the call.\n+\n+   Return NULL_TREE if no simplification was possible, otherwise return the\n+   simplified form of the call as a tree.\n+\n+   The simplified form may be a constant or other expression which\n+   computes the same value, but in a more efficient manner (including\n+   calls to other builtin functions).\n+\n+   The call may contain arguments which need to be evaluated, but\n+   which are not useful to determine the result of the call.  In\n+   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n+   COMPOUND_EXPR will be an argument which must be evaluated.\n+   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n+   COMPOUND_EXPR in the chain will contain the tree for the simplified\n+   form of the builtin function call.  */\n+\n+static bool\n+gimple_fold_builtin_strcat (gimple_stmt_iterator *gsi,\n+\t\t\t    location_t loc ATTRIBUTE_UNUSED, tree dst, tree src,\n+\t\t\t    tree len)\n+{\n+  gimple stmt = gsi_stmt (*gsi);\n+\n+  const char *p = c_getstr (src);\n+\n+  /* If the string length is zero, return the dst parameter.  */\n+  if (p && *p == '\\0')\n+    {\n+      replace_call_with_value (gsi, dst);\n+      return true;\n+    }\n+\n+  if (!optimize_bb_for_speed_p (gimple_bb (stmt)))\n+    return false;\n+\n+  /* See if we can store by pieces into (dst + strlen(dst)).  */\n+  tree newdst;\n+  tree strlen_fn = builtin_decl_implicit (BUILT_IN_STRLEN);\n+  tree memcpy_fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n+\n+  if (!strlen_fn || !memcpy_fn)\n+    return false;\n+\n+  /* If the length of the source string isn't computable don't\n+     split strcat into strlen and memcpy.  */\n+  if (! len)\n+    len = c_strlen (src, 1);\n+  if (! len || TREE_SIDE_EFFECTS (len))\n+    return false;\n+\n+  /* Create strlen (dst).  */\n+  gimple_seq stmts = NULL, stmts2;\n+  gimple repl = gimple_build_call (strlen_fn, 1, dst);\n+  gimple_set_location (repl, loc);\n+  if (gimple_in_ssa_p (cfun))\n+    newdst = make_ssa_name (size_type_node, NULL);\n+  else\n+    newdst = create_tmp_reg (size_type_node, NULL);\n+  gimple_call_set_lhs (repl, newdst);\n+  gimple_seq_add_stmt_without_update (&stmts, repl);\n+\n+  /* Create (dst p+ strlen (dst)).  */\n+  newdst = fold_build_pointer_plus_loc (loc, dst, newdst);\n+  newdst = force_gimple_operand (newdst, &stmts2, true, NULL_TREE);\n+  gimple_seq_add_seq_without_update (&stmts, stmts2);\n+\n+  len = fold_convert_loc (loc, size_type_node, len);\n+  len = size_binop_loc (loc, PLUS_EXPR, len,\n+\t\t\tbuild_int_cst (size_type_node, 1));\n+  len = force_gimple_operand (len, &stmts2, true, NULL_TREE);\n+  gimple_seq_add_seq_without_update (&stmts, stmts2);\n+\n+  repl = gimple_build_call (memcpy_fn, 3, newdst, src, len);\n+  gimple_seq_add_stmt_without_update (&stmts, repl);\n+  if (gimple_call_lhs (stmt))\n+    {\n+      repl = gimple_build_assign (gimple_call_lhs (stmt), dst);\n+      gimple_seq_add_stmt_without_update (&stmts, repl);\n+      gsi_replace_with_seq_vops (gsi, stmts);\n+      /* gsi now points at the assignment to the lhs, get a\n+         stmt iterator to the memcpy call.\n+\t ???  We can't use gsi_for_stmt as that doesn't work when the\n+\t CFG isn't built yet.  */\n+      gimple_stmt_iterator gsi2 = *gsi;\n+      gsi_prev (&gsi2);\n+      fold_stmt (&gsi2);\n+    }\n+  else\n+    {\n+      gsi_replace_with_seq_vops (gsi, stmts);\n+      fold_stmt (gsi);\n+    }\n+  return true;\n+}\n+\n+/* Fold a call to the fputs builtin.  ARG0 and ARG1 are the arguments\n+   to the call.  IGNORE is true if the value returned\n+   by the builtin will be ignored.  UNLOCKED is true is true if this\n+   actually a call to fputs_unlocked.  If LEN in non-NULL, it represents\n+   the known length of the string.  Return NULL_TREE if no simplification\n+   was possible.  */\n+\n+static bool\n+gimple_fold_builtin_fputs (gimple_stmt_iterator *gsi,\n+\t\t\t   location_t loc ATTRIBUTE_UNUSED,\n+\t\t\t   tree arg0, tree arg1,\n+\t\t\t   bool ignore, bool unlocked, tree len)\n+{\n+  /* If we're using an unlocked function, assume the other unlocked\n+     functions exist explicitly.  */\n+  tree const fn_fputc = (unlocked\n+\t\t\t ? builtin_decl_explicit (BUILT_IN_FPUTC_UNLOCKED)\n+\t\t\t : builtin_decl_implicit (BUILT_IN_FPUTC));\n+  tree const fn_fwrite = (unlocked\n+\t\t\t  ? builtin_decl_explicit (BUILT_IN_FWRITE_UNLOCKED)\n+\t\t\t  : builtin_decl_implicit (BUILT_IN_FWRITE));\n+\n+  /* If the return value is used, don't do the transformation.  */\n+  if (!ignore)\n+    return false;\n+\n+  if (! len)\n+    len = c_strlen (arg0, 0);\n+\n+  /* Get the length of the string passed to fputs.  If the length\n+     can't be determined, punt.  */\n+  if (!len\n+      || TREE_CODE (len) != INTEGER_CST)\n+    return false;\n+\n+  switch (compare_tree_int (len, 1))\n+    {\n+    case -1: /* length is 0, delete the call entirely .  */\n+      replace_call_with_value (gsi, integer_zero_node);\n+      return true;\n+\n+    case 0: /* length is 1, call fputc.  */\n+      {\n+\tconst char *p = c_getstr (arg0);\n+\tif (p != NULL)\n+\t  {\n+\t    if (!fn_fputc)\n+\t      return false;\n+\n+\t    gimple repl = gimple_build_call (fn_fputc, 2,\n+\t\t\t\t\t     build_int_cst\n+\t\t\t\t\t     (integer_type_node, p[0]), arg1);\n+\t    replace_call_with_call_and_fold (gsi, repl);\n+\t    return true;\n+\t  }\n+      }\n+      /* FALLTHROUGH */\n+    case 1: /* length is greater than 1, call fwrite.  */\n+      {\n+\t/* If optimizing for size keep fputs.  */\n+\tif (optimize_function_for_size_p (cfun))\n+\t  return false;\n+\t/* New argument list transforming fputs(string, stream) to\n+\t   fwrite(string, 1, len, stream).  */\n+\tif (!fn_fwrite)\n+\t  return false;\n+\n+\tgimple repl = gimple_build_call (fn_fwrite, 4, arg0,\n+\t\t\t\t\t size_one_node, len, arg1);\n+\treplace_call_with_call_and_fold (gsi, repl);\n+\treturn true;\n+      }\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return false;\n+}\n+\n+/* Fold a call to the __mem{cpy,pcpy,move,set}_chk builtin.\n+   DEST, SRC, LEN, and SIZE are the arguments to the call.\n+   IGNORE is true, if return value can be ignored.  FCODE is the BUILT_IN_*\n+   code of the builtin.  If MAXLEN is not NULL, it is maximum length\n+   passed as third argument.  */\n+\n+static bool\n+gimple_fold_builtin_memory_chk (gimple_stmt_iterator *gsi,\n+\t\t\t\tlocation_t loc,\n+\t\t\t\ttree dest, tree src, tree len, tree size,\n+\t\t\t\ttree maxlen, bool ignore,\n+\t\t\t\tenum built_in_function fcode)\n+{\n+  tree fn;\n+\n+  /* If SRC and DEST are the same (and not volatile), return DEST\n+     (resp. DEST+LEN for __mempcpy_chk).  */\n+  if (fcode != BUILT_IN_MEMSET_CHK && operand_equal_p (src, dest, 0))\n+    {\n+      if (fcode != BUILT_IN_MEMPCPY_CHK)\n+\t{\n+\t  replace_call_with_value (gsi, dest);\n+\t  return true;\n+\t}\n+      else\n+\t{\n+\t  tree temp = fold_build_pointer_plus_loc (loc, dest, len);\n+\t  temp = force_gimple_operand_gsi (gsi, temp,\n+\t\t\t\t\t   false, NULL_TREE, true,\n+\t\t\t\t\t   GSI_SAME_STMT);\n+\t  replace_call_with_value (gsi, temp);\n+\t  return true;\n+\t}\n+    }\n+\n+  if (! tree_fits_uhwi_p (size))\n+    return false;\n+\n+  if (! integer_all_onesp (size))\n+    {\n+      if (! tree_fits_uhwi_p (len))\n+\t{\n+\t  /* If LEN is not constant, try MAXLEN too.\n+\t     For MAXLEN only allow optimizing into non-_ocs function\n+\t     if SIZE is >= MAXLEN, never convert to __ocs_fail ().  */\n+\t  if (maxlen == NULL_TREE || ! tree_fits_uhwi_p (maxlen))\n+\t    {\n+\t      if (fcode == BUILT_IN_MEMPCPY_CHK && ignore)\n+\t\t{\n+\t\t  /* (void) __mempcpy_chk () can be optimized into\n+\t\t     (void) __memcpy_chk ().  */\n+\t\t  fn = builtin_decl_explicit (BUILT_IN_MEMCPY_CHK);\n+\t\t  if (!fn)\n+\t\t    return false;\n+\n+\t\t  gimple repl = gimple_build_call (fn, 4, dest, src, len, size);\n+\t\t  replace_call_with_call_and_fold (gsi, repl);\n+\t\t  return true;\n+\t\t}\n+\t      return false;\n+\t    }\n+\t}\n+      else\n+\tmaxlen = len;\n+\n+      if (tree_int_cst_lt (size, maxlen))\n+\treturn false;\n+    }\n+\n+  fn = NULL_TREE;\n+  /* If __builtin_mem{cpy,pcpy,move,set}_chk is used, assume\n+     mem{cpy,pcpy,move,set} is available.  */\n+  switch (fcode)\n+    {\n+    case BUILT_IN_MEMCPY_CHK:\n+      fn = builtin_decl_explicit (BUILT_IN_MEMCPY);\n+      break;\n+    case BUILT_IN_MEMPCPY_CHK:\n+      fn = builtin_decl_explicit (BUILT_IN_MEMPCPY);\n+      break;\n+    case BUILT_IN_MEMMOVE_CHK:\n+      fn = builtin_decl_explicit (BUILT_IN_MEMMOVE);\n+      break;\n+    case BUILT_IN_MEMSET_CHK:\n+      fn = builtin_decl_explicit (BUILT_IN_MEMSET);\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  if (!fn)\n+    return false;\n+\n+  gimple repl = gimple_build_call (fn, 3, dest, src, len);\n+  replace_call_with_call_and_fold (gsi, repl);\n+  return true;\n+}\n+\n+/* Fold a call to the __st[rp]cpy_chk builtin.\n+   DEST, SRC, and SIZE are the arguments to the call.\n+   IGNORE is true if return value can be ignored.  FCODE is the BUILT_IN_*\n+   code of the builtin.  If MAXLEN is not NULL, it is maximum length of\n+   strings passed as second argument.  */\n+\n+static bool\n+gimple_fold_builtin_stxcpy_chk (gimple_stmt_iterator *gsi,\n+\t\t\t\tlocation_t loc, tree dest,\n+\t\t\t\ttree src, tree size,\n+\t\t\t\ttree maxlen, bool ignore,\n+\t\t\t\tenum built_in_function fcode)\n+{\n+  tree len, fn;\n+\n+  /* If SRC and DEST are the same (and not volatile), return DEST.  */\n+  if (fcode == BUILT_IN_STRCPY_CHK && operand_equal_p (src, dest, 0))\n+    {\n+      replace_call_with_value (gsi, dest);\n+      return true;\n+    }\n+\n+  if (! tree_fits_uhwi_p (size))\n+    return false;\n+\n+  if (! integer_all_onesp (size))\n+    {\n+      len = c_strlen (src, 1);\n+      if (! len || ! tree_fits_uhwi_p (len))\n+\t{\n+\t  /* If LEN is not constant, try MAXLEN too.\n+\t     For MAXLEN only allow optimizing into non-_ocs function\n+\t     if SIZE is >= MAXLEN, never convert to __ocs_fail ().  */\n+\t  if (maxlen == NULL_TREE || ! tree_fits_uhwi_p (maxlen))\n+\t    {\n+\t      if (fcode == BUILT_IN_STPCPY_CHK)\n+\t\t{\n+\t\t  if (! ignore)\n+\t\t    return false;\n+\n+\t\t  /* If return value of __stpcpy_chk is ignored,\n+\t\t     optimize into __strcpy_chk.  */\n+\t\t  fn = builtin_decl_explicit (BUILT_IN_STRCPY_CHK);\n+\t\t  if (!fn)\n+\t\t    return false;\n+\n+\t\t  gimple repl = gimple_build_call (fn, 3, dest, src, size);\n+\t\t  replace_call_with_call_and_fold (gsi, repl);\n+\t\t  return true;\n+\t\t}\n+\n+\t      if (! len || TREE_SIDE_EFFECTS (len))\n+\t\treturn false;\n+\n+\t      /* If c_strlen returned something, but not a constant,\n+\t\t transform __strcpy_chk into __memcpy_chk.  */\n+\t      fn = builtin_decl_explicit (BUILT_IN_MEMCPY_CHK);\n+\t      if (!fn)\n+\t\treturn false;\n+\n+\t      len = fold_convert_loc (loc, size_type_node, len);\n+\t      len = size_binop_loc (loc, PLUS_EXPR, len,\n+\t\t\t\t    build_int_cst (size_type_node, 1));\n+\t      len = force_gimple_operand_gsi (gsi, len, true, NULL_TREE,\n+\t\t\t\t\t      true, GSI_SAME_STMT);\n+\t      gimple repl = gimple_build_call (fn, 4, dest, src, len, size);\n+\t      replace_call_with_call_and_fold (gsi, repl);\n+\t      return true;\n+\t    }\n+\t}\n+      else\n+\tmaxlen = len;\n+\n+      if (! tree_int_cst_lt (maxlen, size))\n+\treturn false;\n+    }\n+\n+  /* If __builtin_st{r,p}cpy_chk is used, assume st{r,p}cpy is available.  */\n+  fn = builtin_decl_explicit (fcode == BUILT_IN_STPCPY_CHK\n+\t\t\t      ? BUILT_IN_STPCPY : BUILT_IN_STRCPY);\n+  if (!fn)\n+    return false;\n+\n+  gimple repl = gimple_build_call (fn, 2, dest, src);\n+  replace_call_with_call_and_fold (gsi, repl);\n+  return true;\n+}\n+\n+/* Fold a call to the __st{r,p}ncpy_chk builtin.  DEST, SRC, LEN, and SIZE\n+   are the arguments to the call.  If MAXLEN is not NULL, it is maximum\n+   length passed as third argument. IGNORE is true if return value can be\n+   ignored. FCODE is the BUILT_IN_* code of the builtin. */\n+\n+static bool\n+gimple_fold_builtin_stxncpy_chk (gimple_stmt_iterator *gsi,\n+\t\t\t\t tree dest, tree src,\n+\t\t\t\t tree len, tree size, tree maxlen, bool ignore,\n+\t\t\t\t enum built_in_function fcode)\n+{\n+  tree fn;\n+\n+  if (fcode == BUILT_IN_STPNCPY_CHK && ignore)\n     {\n-      new_stmt = gsi_stmt (i);\n-      /* If the new statement possibly has a VUSE, update it with exact SSA\n-\t name we know will reach this one.  */\n-      if (gimple_has_mem_ops (new_stmt))\n-\tgimple_set_vuse (new_stmt, reaching_vuse);\n-      gimple_set_modified (new_stmt, true);\n-      if (gimple_vdef (new_stmt))\n-\treaching_vuse = gimple_vdef (new_stmt);\n+       /* If return value of __stpncpy_chk is ignored,\n+          optimize into __strncpy_chk.  */\n+       fn = builtin_decl_explicit (BUILT_IN_STRNCPY_CHK);\n+       if (fn)\n+\t {\n+\t   gimple repl = gimple_build_call (fn, 4, dest, src, len, size);\n+\t   replace_call_with_call_and_fold (gsi, repl);\n+\t   return true;\n+\t }\n     }\n \n-  /* If the new sequence does not do a store release the virtual\n-     definition of the original statement.  */\n-  if (reaching_vuse\n-      && reaching_vuse == gimple_vuse (stmt))\n+  if (! tree_fits_uhwi_p (size))\n+    return false;\n+\n+  if (! integer_all_onesp (size))\n     {\n-      tree vdef = gimple_vdef (stmt);\n-      if (vdef\n-\t  && TREE_CODE (vdef) == SSA_NAME)\n+      if (! tree_fits_uhwi_p (len))\n \t{\n-\t  unlink_stmt_vdef (stmt);\n-\t  release_ssa_name (vdef);\n+\t  /* If LEN is not constant, try MAXLEN too.\n+\t     For MAXLEN only allow optimizing into non-_ocs function\n+\t     if SIZE is >= MAXLEN, never convert to __ocs_fail ().  */\n+\t  if (maxlen == NULL_TREE || ! tree_fits_uhwi_p (maxlen))\n+\t    return false;\n \t}\n+      else\n+\tmaxlen = len;\n+\n+      if (tree_int_cst_lt (size, maxlen))\n+\treturn false;\n     }\n \n-  /* Finally replace the original statement with the sequence.  */\n-  gsi_replace_with_seq (si_p, stmts, false);\n+  /* If __builtin_st{r,p}ncpy_chk is used, assume st{r,p}ncpy is available.  */\n+  fn = builtin_decl_explicit (fcode == BUILT_IN_STPNCPY_CHK\n+\t\t\t      ? BUILT_IN_STPNCPY : BUILT_IN_STRNCPY);\n+  if (!fn)\n+    return false;\n+\n+  gimple repl = gimple_build_call (fn, 3, dest, src, len);\n+  replace_call_with_call_and_fold (gsi, repl);\n+  return true;\n }\n \n-/* Return the string length, maximum string length or maximum value of\n-   ARG in LENGTH.\n-   If ARG is an SSA name variable, follow its use-def chains.  If LENGTH\n-   is not NULL and, for TYPE == 0, its value is not equal to the length\n-   we determine or if we are unable to determine the length or value,\n-   return false.  VISITED is a bitmap of visited variables.\n-   TYPE is 0 if string length should be returned, 1 for maximum string\n-   length and 2 for maximum value ARG can have.  */\n+/* Fold a call EXP to {,v}snprintf having NARGS passed as ARGS.  Return\n+   NULL_TREE if a normal call should be emitted rather than expanding\n+   the function inline.  FCODE is either BUILT_IN_SNPRINTF_CHK or\n+   BUILT_IN_VSNPRINTF_CHK.  If MAXLEN is not NULL, it is maximum length\n+   passed as second argument.  */\n \n static bool\n-get_maxval_strlen (tree arg, tree *length, bitmap visited, int type)\n+gimple_fold_builtin_snprintf_chk (gimple_stmt_iterator *gsi,\n+\t\t\t\t  tree maxlen, enum built_in_function fcode)\n {\n-  tree var, val;\n-  gimple def_stmt;\n+  gimple stmt = gsi_stmt (*gsi);\n+  tree dest, size, len, fn, fmt, flag;\n+  const char *fmt_str;\n \n-  if (TREE_CODE (arg) != SSA_NAME)\n-    {\n-      /* We can end up with &(*iftmp_1)[0] here as well, so handle it.  */\n-      if (TREE_CODE (arg) == ADDR_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (arg, 0)) == ARRAY_REF\n-\t  && integer_zerop (TREE_OPERAND (TREE_OPERAND (arg, 0), 1)))\n-\t{\n-\t  tree aop0 = TREE_OPERAND (TREE_OPERAND (arg, 0), 0);\n-\t  if (TREE_CODE (aop0) == INDIRECT_REF\n-\t      && TREE_CODE (TREE_OPERAND (aop0, 0)) == SSA_NAME)\n-\t    return get_maxval_strlen (TREE_OPERAND (aop0, 0),\n-\t\t\t\t      length, visited, type);\n-\t}\n+  /* Verify the required arguments in the original call.  */\n+  if (gimple_call_num_args (stmt) < 5)\n+    return false;\n \n-      if (type == 2)\n+  dest = gimple_call_arg (stmt, 0);\n+  len = gimple_call_arg (stmt, 1);\n+  flag = gimple_call_arg (stmt, 2);\n+  size = gimple_call_arg (stmt, 3);\n+  fmt = gimple_call_arg (stmt, 4);\n+\n+  if (! tree_fits_uhwi_p (size))\n+    return false;\n+\n+  if (! integer_all_onesp (size))\n+    {\n+      if (! tree_fits_uhwi_p (len))\n \t{\n-\t  val = arg;\n-\t  if (TREE_CODE (val) != INTEGER_CST\n-\t      || tree_int_cst_sgn (val) < 0)\n+\t  /* If LEN is not constant, try MAXLEN too.\n+\t     For MAXLEN only allow optimizing into non-_ocs function\n+\t     if SIZE is >= MAXLEN, never convert to __ocs_fail ().  */\n+\t  if (maxlen == NULL_TREE || ! tree_fits_uhwi_p (maxlen))\n \t    return false;\n \t}\n       else\n-\tval = c_strlen (arg, 1);\n-      if (!val)\n-\treturn false;\n+\tmaxlen = len;\n \n-      if (*length)\n-\t{\n-\t  if (type > 0)\n-\t    {\n-\t      if (TREE_CODE (*length) != INTEGER_CST\n-\t\t  || TREE_CODE (val) != INTEGER_CST)\n-\t\treturn false;\n+      if (tree_int_cst_lt (size, maxlen))\n+\treturn false;\n+    }\n \n-\t      if (tree_int_cst_lt (*length, val))\n-\t\t*length = val;\n-\t      return true;\n-\t    }\n-\t  else if (simple_cst_equal (val, *length) != 1)\n-\t    return false;\n-\t}\n+  if (!init_target_chars ())\n+    return false;\n \n-      *length = val;\n-      return true;\n+  /* Only convert __{,v}snprintf_chk to {,v}snprintf if flag is 0\n+     or if format doesn't contain % chars or is \"%s\".  */\n+  if (! integer_zerop (flag))\n+    {\n+      fmt_str = c_getstr (fmt);\n+      if (fmt_str == NULL)\n+\treturn false;\n+      if (strchr (fmt_str, target_percent) != NULL\n+\t  && strcmp (fmt_str, target_percent_s))\n+\treturn false;\n     }\n \n-  /* If ARG is registered for SSA update we cannot look at its defining\n-     statement.  */\n-  if (name_registered_for_update_p (arg))\n+  /* If __builtin_{,v}snprintf_chk is used, assume {,v}snprintf is\n+     available.  */\n+  fn = builtin_decl_explicit (fcode == BUILT_IN_VSNPRINTF_CHK\n+\t\t\t      ? BUILT_IN_VSNPRINTF : BUILT_IN_SNPRINTF);\n+  if (!fn)\n     return false;\n \n-  /* If we were already here, break the infinite cycle.  */\n-  if (!bitmap_set_bit (visited, SSA_NAME_VERSION (arg)))\n-    return true;\n+  /* Replace the called function and the first 5 argument by 3 retaining\n+     trailing varargs.  */\n+  gimple_call_set_fndecl (stmt, fn);\n+  gimple_call_set_fntype (stmt, TREE_TYPE (fn));\n+  gimple_call_set_arg (stmt, 0, dest);\n+  gimple_call_set_arg (stmt, 1, len);\n+  gimple_call_set_arg (stmt, 2, fmt);\n+  for (unsigned i = 3; i < gimple_call_num_args (stmt) - 2; ++i)\n+    gimple_call_set_arg (stmt, i, gimple_call_arg (stmt, i + 2));\n+  gimple_set_num_ops (stmt, gimple_num_ops (stmt) - 2);\n+  fold_stmt (gsi);\n+  return true;\n+}\n \n-  var = arg;\n-  def_stmt = SSA_NAME_DEF_STMT (var);\n+/* Fold a call EXP to __{,v}sprintf_chk having NARGS passed as ARGS.\n+   Return NULL_TREE if a normal call should be emitted rather than\n+   expanding the function inline.  FCODE is either BUILT_IN_SPRINTF_CHK\n+   or BUILT_IN_VSPRINTF_CHK.  */\n \n-  switch (gimple_code (def_stmt))\n-    {\n-      case GIMPLE_ASSIGN:\n-        /* The RHS of the statement defining VAR must either have a\n-           constant length or come from another SSA_NAME with a constant\n-           length.  */\n-        if (gimple_assign_single_p (def_stmt)\n-            || gimple_assign_unary_nop_p (def_stmt))\n-          {\n-            tree rhs = gimple_assign_rhs1 (def_stmt);\n-            return get_maxval_strlen (rhs, length, visited, type);\n-          }\n-\telse if (gimple_assign_rhs_code (def_stmt) == COND_EXPR)\n-\t  {\n-\t    tree op2 = gimple_assign_rhs2 (def_stmt);\n-\t    tree op3 = gimple_assign_rhs3 (def_stmt);\n-\t    return get_maxval_strlen (op2, length, visited, type)\n-\t\t   && get_maxval_strlen (op3, length, visited, type);\n-          }\n-        return false;\n+static bool\n+gimple_fold_builtin_sprintf_chk (gimple_stmt_iterator *gsi,\n+\t\t\t\t enum built_in_function fcode)\n+{\n+  gimple stmt = gsi_stmt (*gsi);\n+  tree dest, size, len, fn, fmt, flag;\n+  const char *fmt_str;\n+  unsigned nargs = gimple_call_num_args (stmt);\n \n-      case GIMPLE_PHI:\n+  /* Verify the required arguments in the original call.  */\n+  if (nargs < 4)\n+    return false;\n+  dest = gimple_call_arg (stmt, 0);\n+  flag = gimple_call_arg (stmt, 1);\n+  size = gimple_call_arg (stmt, 2);\n+  fmt = gimple_call_arg (stmt, 3);\n+\n+  if (! tree_fits_uhwi_p (size))\n+    return false;\n+\n+  len = NULL_TREE;\n+\n+  if (!init_target_chars ())\n+    return false;\n+\n+  /* Check whether the format is a literal string constant.  */\n+  fmt_str = c_getstr (fmt);\n+  if (fmt_str != NULL)\n+    {\n+      /* If the format doesn't contain % args or %%, we know the size.  */\n+      if (strchr (fmt_str, target_percent) == 0)\n \t{\n-\t  /* All the arguments of the PHI node must have the same constant\n-\t     length.  */\n-\t  unsigned i;\n+\t  if (fcode != BUILT_IN_SPRINTF_CHK || nargs == 4)\n+\t    len = build_int_cstu (size_type_node, strlen (fmt_str));\n+\t}\n+      /* If the format is \"%s\" and first ... argument is a string literal,\n+\t we know the size too.  */\n+      else if (fcode == BUILT_IN_SPRINTF_CHK\n+\t       && strcmp (fmt_str, target_percent_s) == 0)\n+\t{\n+\t  tree arg;\n \n-\t  for (i = 0; i < gimple_phi_num_args (def_stmt); i++)\n-          {\n-            tree arg = gimple_phi_arg (def_stmt, i)->def;\n+\t  if (nargs == 5)\n+\t    {\n+\t      arg = gimple_call_arg (stmt, 4);\n+\t      if (POINTER_TYPE_P (TREE_TYPE (arg)))\n+\t\t{\n+\t\t  len = c_strlen (arg, 1);\n+\t\t  if (! len || ! tree_fits_uhwi_p (len))\n+\t\t    len = NULL_TREE;\n+\t\t}\n+\t    }\n+\t}\n+    }\n \n-            /* If this PHI has itself as an argument, we cannot\n-               determine the string length of this argument.  However,\n-               if we can find a constant string length for the other\n-               PHI args then we can still be sure that this is a\n-               constant string length.  So be optimistic and just\n-               continue with the next argument.  */\n-            if (arg == gimple_phi_result (def_stmt))\n-              continue;\n+  if (! integer_all_onesp (size))\n+    {\n+      if (! len || ! tree_int_cst_lt (len, size))\n+\treturn false;\n+    }\n \n-            if (!get_maxval_strlen (arg, length, visited, type))\n-              return false;\n-          }\n-        }\n-        return true;\n+  /* Only convert __{,v}sprintf_chk to {,v}sprintf if flag is 0\n+     or if format doesn't contain % chars or is \"%s\".  */\n+  if (! integer_zerop (flag))\n+    {\n+      if (fmt_str == NULL)\n+\treturn false;\n+      if (strchr (fmt_str, target_percent) != NULL\n+\t  && strcmp (fmt_str, target_percent_s))\n+\treturn false;\n+    }\n \n-      default:\n-        return false;\n+  /* If __builtin_{,v}sprintf_chk is used, assume {,v}sprintf is available.  */\n+  fn = builtin_decl_explicit (fcode == BUILT_IN_VSPRINTF_CHK\n+\t\t\t      ? BUILT_IN_VSPRINTF : BUILT_IN_SPRINTF);\n+  if (!fn)\n+    return false;\n+\n+  /* Replace the called function and the first 4 argument by 2 retaining\n+     trailing varargs.  */\n+  gimple_call_set_fndecl (stmt, fn);\n+  gimple_call_set_fntype (stmt, TREE_TYPE (fn));\n+  gimple_call_set_arg (stmt, 0, dest);\n+  gimple_call_set_arg (stmt, 1, fmt);\n+  for (unsigned i = 2; i < gimple_call_num_args (stmt) - 2; ++i)\n+    gimple_call_set_arg (stmt, i, gimple_call_arg (stmt, i + 2));\n+  gimple_set_num_ops (stmt, gimple_num_ops (stmt) - 2);\n+  fold_stmt (gsi);\n+  return true;\n+}\n+\n+\n+/* Fold a call to __builtin_strlen with known length LEN.  */\n+\n+static bool\n+gimple_fold_builtin_strlen (gimple_stmt_iterator *gsi, tree len)\n+{\n+  if (!len)\n+    {\n+      gimple stmt = gsi_stmt (*gsi);\n+      len = c_strlen (gimple_call_arg (stmt, 0), 0);\n     }\n+  if (!len)\n+    return false;\n+  replace_call_with_value (gsi, len);\n+  return true;\n }\n \n \n-/* Fold builtin call in statement STMT.  Returns a simplified tree.\n-   We may return a non-constant expression, including another call\n-   to a different function and with different arguments, e.g.,\n-   substituting memcpy for strcpy when the string length is known.\n-   Note that some builtins expand into inline code that may not\n-   be valid in GIMPLE.  Callers must take care.  */\n+/* Fold builtins at *GSI with knowledge about a length argument.  */\n \n-static tree\n-gimple_fold_builtin (gimple stmt)\n+static bool\n+gimple_fold_builtin_with_strlen (gimple_stmt_iterator *gsi)\n {\n-  tree result, val[3];\n-  tree callee, a;\n+  gimple stmt = gsi_stmt (*gsi);\n+  tree val[3];\n+  tree a;\n   int arg_idx, type;\n   bitmap visited;\n   bool ignore;\n-  int nargs;\n   location_t loc = gimple_location (stmt);\n \n   ignore = (gimple_call_lhs (stmt) == NULL);\n \n-  /* First try the generic builtin folder.  If that succeeds, return the\n-     result directly.  */\n-  result = fold_call_stmt (stmt, ignore);\n-  if (result)\n-    {\n-      if (ignore)\n-\tSTRIP_NOPS (result);\n-      else\n-\tresult = fold_convert (gimple_call_return_type (stmt), result);\n-      return result;\n-    }\n-\n-  /* Ignore MD builtins.  */\n-  callee = gimple_call_fndecl (stmt);\n-  if (DECL_BUILT_IN_CLASS (callee) == BUILT_IN_MD)\n-    return NULL_TREE;\n-\n-  /* Give up for always_inline inline builtins until they are\n-     inlined.  */\n-  if (avoid_folding_inline_builtin (callee))\n-    return NULL_TREE;\n-\n-  /* If the builtin could not be folded, and it has no argument list,\n-     we're done.  */\n-  nargs = gimple_call_num_args (stmt);\n-  if (nargs == 0)\n-    return NULL_TREE;\n-\n   /* Limit the work only for builtins we know how to simplify.  */\n+  tree callee = gimple_call_fndecl (stmt);\n   switch (DECL_FUNCTION_CODE (callee))\n     {\n     case BUILT_IN_STRLEN:\n@@ -949,132 +2212,163 @@ gimple_fold_builtin (gimple stmt)\n       type = 2;\n       break;\n     default:\n-      return NULL_TREE;\n+      return false;\n     }\n \n+  int nargs = gimple_call_num_args (stmt);\n   if (arg_idx >= nargs)\n-    return NULL_TREE;\n+    return false;\n \n   /* Try to use the dataflow information gathered by the CCP process.  */\n   visited = BITMAP_ALLOC (NULL);\n   bitmap_clear (visited);\n \n   memset (val, 0, sizeof (val));\n   a = gimple_call_arg (stmt, arg_idx);\n-  if (!get_maxval_strlen (a, &val[arg_idx], visited, type))\n+  if (!get_maxval_strlen (a, &val[arg_idx], visited, type)\n+      || !is_gimple_val (val[arg_idx]))\n     val[arg_idx] = NULL_TREE;\n \n   BITMAP_FREE (visited);\n \n-  result = NULL_TREE;\n   switch (DECL_FUNCTION_CODE (callee))\n     {\n     case BUILT_IN_STRLEN:\n-      if (val[0] && nargs == 1)\n-\t{\n-\t  tree new_val =\n-              fold_convert (TREE_TYPE (gimple_call_lhs (stmt)), val[0]);\n-\n-\t  /* If the result is not a valid gimple value, or not a cast\n-\t     of a valid gimple value, then we cannot use the result.  */\n-\t  if (is_gimple_val (new_val)\n-\t      || (CONVERT_EXPR_P (new_val)\n-\t\t  && is_gimple_val (TREE_OPERAND (new_val, 0))))\n-\t    return new_val;\n-\t}\n-      break;\n+      return gimple_fold_builtin_strlen (gsi, val[0]);\n \n     case BUILT_IN_STRCPY:\n-      if (val[1] && is_gimple_val (val[1]) && nargs == 2)\n-\tresult = fold_builtin_strcpy (loc, callee,\n-                                      gimple_call_arg (stmt, 0),\n-                                      gimple_call_arg (stmt, 1),\n-\t\t\t\t      val[1]);\n-      break;\n+      return gimple_fold_builtin_strcpy (gsi, loc,\n+\t\t\t\t\t gimple_call_arg (stmt, 0),\n+\t\t\t\t\t gimple_call_arg (stmt, 1),\n+\t\t\t\t\t val[1]);\n \n     case BUILT_IN_STRNCPY:\n-      if (val[1] && is_gimple_val (val[1]) && nargs == 3)\n-\tresult = fold_builtin_strncpy (loc, callee,\n-                                       gimple_call_arg (stmt, 0),\n-                                       gimple_call_arg (stmt, 1),\n-                                       gimple_call_arg (stmt, 2),\n-\t\t\t\t       val[1]);\n-      break;\n+      return gimple_fold_builtin_strncpy (gsi, loc,\n+\t\t\t\t\t  gimple_call_arg (stmt, 0),\n+\t\t\t\t\t  gimple_call_arg (stmt, 1),\n+\t\t\t\t\t  gimple_call_arg (stmt, 2),\n+\t\t\t\t\t  val[1]);\n \n     case BUILT_IN_STRCAT:\n-      if (val[1] && is_gimple_val (val[1]) && nargs == 2)\n-\tresult = fold_builtin_strcat (loc, gimple_call_arg (stmt, 0),\n-\t\t\t\t      gimple_call_arg (stmt, 1),\n-\t\t\t\t      val[1]);\n-      break;\n+      return gimple_fold_builtin_strcat (gsi, loc, gimple_call_arg (stmt, 0),\n+\t\t\t\t\t gimple_call_arg (stmt, 1),\n+\t\t\t\t\t val[1]);\n \n     case BUILT_IN_FPUTS:\n-      if (nargs == 2)\n-\tresult = fold_builtin_fputs (loc, gimple_call_arg (stmt, 0),\n-\t\t\t\t     gimple_call_arg (stmt, 1),\n-\t\t\t\t     ignore, false, val[0]);\n-      break;\n+      return gimple_fold_builtin_fputs (gsi, loc, gimple_call_arg (stmt, 0),\n+\t\t\t\t\tgimple_call_arg (stmt, 1),\n+\t\t\t\t\tignore, false, val[0]);\n \n     case BUILT_IN_FPUTS_UNLOCKED:\n-      if (nargs == 2)\n-\tresult = fold_builtin_fputs (loc, gimple_call_arg (stmt, 0),\n-\t\t\t\t     gimple_call_arg (stmt, 1),\n-\t\t\t\t     ignore, true, val[0]);\n-      break;\n+      return gimple_fold_builtin_fputs (gsi, loc, gimple_call_arg (stmt, 0),\n+\t\t\t\t\tgimple_call_arg (stmt, 1),\n+\t\t\t\t\tignore, true, val[0]);\n \n     case BUILT_IN_MEMCPY_CHK:\n     case BUILT_IN_MEMPCPY_CHK:\n     case BUILT_IN_MEMMOVE_CHK:\n     case BUILT_IN_MEMSET_CHK:\n-      if (val[2] && is_gimple_val (val[2]) && nargs == 4)\n-\tresult = fold_builtin_memory_chk (loc, callee,\n-                                          gimple_call_arg (stmt, 0),\n-                                          gimple_call_arg (stmt, 1),\n-                                          gimple_call_arg (stmt, 2),\n-                                          gimple_call_arg (stmt, 3),\n-\t\t\t\t\t  val[2], ignore,\n-\t\t\t\t\t  DECL_FUNCTION_CODE (callee));\n-      break;\n+      return gimple_fold_builtin_memory_chk (gsi, loc,\n+\t\t\t\t\t     gimple_call_arg (stmt, 0),\n+\t\t\t\t\t     gimple_call_arg (stmt, 1),\n+\t\t\t\t\t     gimple_call_arg (stmt, 2),\n+\t\t\t\t\t     gimple_call_arg (stmt, 3),\n+\t\t\t\t\t     val[2], ignore,\n+\t\t\t\t\t     DECL_FUNCTION_CODE (callee));\n \n     case BUILT_IN_STRCPY_CHK:\n     case BUILT_IN_STPCPY_CHK:\n-      if (val[1] && is_gimple_val (val[1]) && nargs == 3)\n-\tresult = fold_builtin_stxcpy_chk (loc, callee,\n-                                          gimple_call_arg (stmt, 0),\n-                                          gimple_call_arg (stmt, 1),\n-                                          gimple_call_arg (stmt, 2),\n-\t\t\t\t\t  val[1], ignore,\n-\t\t\t\t\t  DECL_FUNCTION_CODE (callee));\n-      break;\n+      return gimple_fold_builtin_stxcpy_chk (gsi, loc,\n+\t\t\t\t\t     gimple_call_arg (stmt, 0),\n+\t\t\t\t\t     gimple_call_arg (stmt, 1),\n+\t\t\t\t\t     gimple_call_arg (stmt, 2),\n+\t\t\t\t\t     val[1], ignore,\n+\t\t\t\t\t     DECL_FUNCTION_CODE (callee));\n \n     case BUILT_IN_STRNCPY_CHK:\n     case BUILT_IN_STPNCPY_CHK:\n-      if (val[2] && is_gimple_val (val[2]) && nargs == 4)\n-\tresult = fold_builtin_stxncpy_chk (loc, gimple_call_arg (stmt, 0),\n-                                           gimple_call_arg (stmt, 1),\n-                                           gimple_call_arg (stmt, 2),\n-                                           gimple_call_arg (stmt, 3),\n-\t\t\t\t\t   val[2], ignore,\n-\t\t\t\t\t   DECL_FUNCTION_CODE (callee));\n-      break;\n+      return gimple_fold_builtin_stxncpy_chk (gsi,\n+\t\t\t\t\t      gimple_call_arg (stmt, 0),\n+\t\t\t\t\t      gimple_call_arg (stmt, 1),\n+\t\t\t\t\t      gimple_call_arg (stmt, 2),\n+\t\t\t\t\t      gimple_call_arg (stmt, 3),\n+\t\t\t\t\t      val[2], ignore,\n+\t\t\t\t\t      DECL_FUNCTION_CODE (callee));\n \n     case BUILT_IN_SNPRINTF_CHK:\n     case BUILT_IN_VSNPRINTF_CHK:\n-      if (val[1] && is_gimple_val (val[1]))\n-\tresult = gimple_fold_builtin_snprintf_chk (stmt, val[1],\n-                                                   DECL_FUNCTION_CODE (callee));\n-      break;\n+      return gimple_fold_builtin_snprintf_chk (gsi, val[1],\n+\t\t\t\t\t       DECL_FUNCTION_CODE (callee));\n \n     default:\n       gcc_unreachable ();\n     }\n \n-  if (result && ignore)\n-    result = fold_ignored_result (result);\n-  return result;\n+  return false;\n }\n \n \n+/* Fold the non-target builtin at *GSI and return whether any simplification\n+   was made.  */\n+\n+static bool\n+gimple_fold_builtin (gimple_stmt_iterator *gsi)\n+{\n+  gimple stmt = gsi_stmt (*gsi);\n+  tree callee = gimple_call_fndecl (stmt);\n+\n+  /* Give up for always_inline inline builtins until they are\n+     inlined.  */\n+  if (avoid_folding_inline_builtin (callee))\n+    return false;\n+\n+  if (gimple_fold_builtin_with_strlen (gsi))\n+    return true;\n+\n+  switch (DECL_FUNCTION_CODE (callee))\n+    {\n+    case BUILT_IN_BZERO:\n+      return gimple_fold_builtin_memset (gsi, integer_zero_node,\n+\t\t\t\t\t gimple_call_arg (stmt, 1));\n+    case BUILT_IN_MEMSET:\n+      return gimple_fold_builtin_memset (gsi,\n+\t\t\t\t\t gimple_call_arg (stmt, 1),\n+\t\t\t\t\t gimple_call_arg (stmt, 2));\n+    case BUILT_IN_BCOPY:\n+      return gimple_fold_builtin_memory_op (gsi, gimple_call_arg (stmt, 1),\n+\t\t\t\t\t    gimple_call_arg (stmt, 0), 3);\n+    case BUILT_IN_MEMCPY:\n+      return gimple_fold_builtin_memory_op (gsi, gimple_call_arg (stmt, 0),\n+\t\t\t\t\t    gimple_call_arg (stmt, 1), 0);\n+    case BUILT_IN_MEMPCPY:\n+      return gimple_fold_builtin_memory_op (gsi, gimple_call_arg (stmt, 0),\n+\t\t\t\t\t    gimple_call_arg (stmt, 1), 1);\n+    case BUILT_IN_MEMMOVE:\n+      return gimple_fold_builtin_memory_op (gsi, gimple_call_arg (stmt, 0),\n+\t\t\t\t\t    gimple_call_arg (stmt, 1), 3);\n+    case BUILT_IN_SPRINTF_CHK:\n+    case BUILT_IN_VSPRINTF_CHK:\n+      return gimple_fold_builtin_sprintf_chk (gsi, DECL_FUNCTION_CODE (callee));\n+    default:;\n+    }\n+\n+  /* Try the generic builtin folder.  */\n+  bool ignore = (gimple_call_lhs (stmt) == NULL);\n+  tree result = fold_call_stmt (stmt, ignore);\n+  if (result)\n+    {\n+      if (ignore)\n+\tSTRIP_NOPS (result);\n+      else\n+\tresult = fold_convert (gimple_call_return_type (stmt), result);\n+      if (!update_call_from_tree (gsi, result))\n+\tgimplify_and_update_call_from_tree (gsi, result);\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n /* Attempt to fold a call statement referenced by the statement iterator GSI.\n    The statement may be replaced by another statement, e.g., if the call\n    simplifies to a constant value. Return true if any changes were made.\n@@ -1186,16 +2480,13 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n \n   /* Check for builtins that CCP can handle using information not\n      available in the generic fold routines.  */\n-  if (gimple_call_builtin_p (stmt))\n+  if (gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))\n+    {\n+      if (gimple_fold_builtin (gsi))\n+        changed = true;\n+    }\n+  else if (gimple_call_builtin_p (stmt, BUILT_IN_MD))\n     {\n-      tree result = gimple_fold_builtin (stmt);\n-      if (result)\n-\t{\n-          if (!update_call_from_tree (gsi, result))\n-\t    gimplify_and_update_call_from_tree (gsi, result);\n-\t  changed = true;\n-\t}\n-      else if (gimple_call_builtin_p (stmt, BUILT_IN_MD))\n \tchanged |= targetm.gimple_fold_builtin (gsi);\n     }\n   else if (gimple_call_internal_p (stmt))"}, {"sha": "2104dd67e03914ac2fa867d833199596a5b8754f", "filename": "gcc/gimple.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=fef5a0d95e0e593ace4be86a8aa27ebdaa92c078", "patch": "@@ -1178,6 +1178,21 @@ gimple_seq_add_seq (gimple_seq *dst_p, gimple_seq src)\n   gsi_insert_seq_after (&si, src, GSI_NEW_STMT);\n }\n \n+/* Append sequence SRC to the end of sequence *DST_P.  If *DST_P is\n+   NULL, a new sequence is allocated.  This function is\n+   similar to gimple_seq_add_seq, but does not scan the operands.  */\n+\n+void\n+gimple_seq_add_seq_without_update (gimple_seq *dst_p, gimple_seq src)\n+{\n+  gimple_stmt_iterator si;\n+  if (src == NULL)\n+    return;\n+\n+  si = gsi_last (*dst_p);\n+  gsi_insert_seq_after_without_update (&si, src, GSI_NEW_STMT);\n+}\n+\n /* Determine whether to assign a location to the statement GS.  */\n \n static bool"}, {"sha": "a517dee65d533f7a1c822d45189df8b326185a98", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=fef5a0d95e0e593ace4be86a8aa27ebdaa92c078", "patch": "@@ -1226,6 +1226,7 @@ gimple gimple_build_predict (enum br_predictor, enum prediction);\n extern void gimple_seq_add_stmt (gimple_seq *, gimple);\n extern void gimple_seq_add_stmt_without_update (gimple_seq *, gimple);\n void gimple_seq_add_seq (gimple_seq *, gimple_seq);\n+void gimple_seq_add_seq_without_update (gimple_seq *, gimple_seq);\n extern void annotate_all_with_location_after (gimple_seq, gimple_stmt_iterator,\n \t\t\t\t\t      location_t);\n extern void annotate_all_with_location (gimple_seq, location_t);"}, {"sha": "03657c9a829363433b19508d6c57de4a2084da27", "filename": "gcc/predict.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=fef5a0d95e0e593ace4be86a8aa27ebdaa92c078", "patch": "@@ -339,7 +339,8 @@ optimize_function_for_speed_p (struct function *fun)\n bool\n optimize_bb_for_size_p (const_basic_block bb)\n {\n-  return optimize_function_for_size_p (cfun) || !maybe_hot_bb_p (cfun, bb);\n+  return (optimize_function_for_size_p (cfun)\n+\t  || (bb && !maybe_hot_bb_p (cfun, bb)));\n }\n \n /* Return TRUE when BB should be optimized for speed.  */"}, {"sha": "bd881d33d47de3ad91542621783793b69dacb643", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fef5a0d95e0e593ace4be86a8aa27ebdaa92c078", "patch": "@@ -1,3 +1,11 @@\n+2014-08-08  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/strlenopt-8.c: Remove XFAIL.\n+\t* gcc.dg/tree-prof/stringop-2.c: Adjust.\n+\t* gfortran.dg/array_memcpy_4.f90: Likewise.\n+\t* gfortran.dg/trim_optimize_1.f90: Likewise.\n+\t* gfortran.dg/trim_optimize_2.f90: Likewise.\n+\n 2014-08-08  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \n \t* gcc.dg/zero_sign_ext_test.c: New test."}, {"sha": "3aaf660a12ccd940396527c6568325b7da694292", "filename": "gcc/testsuite/gcc.dg/strlenopt-8.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-8.c?ref=fef5a0d95e0e593ace4be86a8aa27ebdaa92c078", "patch": "@@ -43,8 +43,8 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen\" } } */\n /* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n /* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n /* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */"}, {"sha": "47ebfb058b4dcbd06dd10e1fbf980ce1a54ccc1c", "filename": "gcc/testsuite/gcc.dg/tree-prof/stringop-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-2.c?ref=fef5a0d95e0e593ace4be86a8aa27ebdaa92c078", "patch": "@@ -19,6 +19,6 @@ main()\n }\n /* { dg-final-use { scan-ipa-dump \"Single value 4 stringop\" \"profile\"} } */\n /* The versioned memset of size 4 should be optimized to an assignment.  */\n-/* { dg-final-use { scan-tree-dump \"a\\\\\\[0\\\\\\] = 168430090\" \"optimized\"} } */\n+/* { dg-final-use { scan-tree-dump \"MEM\\\\\\[\\\\(void .\\\\)&a\\\\\\] = 168430090\" \"optimized\"} } */\n /* { dg-final-use { cleanup-tree-dump \"optimized\" } } */\n /* { dg-final-use { cleanup-ipa-dump \"profile\" } } */"}, {"sha": "4a794fae2a150b5089d27df6cfc30a45bff4e4cf", "filename": "gcc/testsuite/gfortran.dg/array_memcpy_4.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memcpy_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memcpy_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memcpy_4.f90?ref=fef5a0d95e0e593ace4be86a8aa27ebdaa92c078", "patch": "@@ -9,5 +9,5 @@\n \n   d = s\n end\n-! { dg-final { scan-tree-dump-times \"MEM.*d\\\\\\] = MEM\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"memcpy\" 1 \"original\" } }\n ! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "e208a50b0d72a5e53e63b59b8a328d27d0fefb6a", "filename": "gcc/testsuite/gfortran.dg/trim_optimize_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Ftestsuite%2Fgfortran.dg%2Ftrim_optimize_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Ftestsuite%2Fgfortran.dg%2Ftrim_optimize_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftrim_optimize_1.f90?ref=fef5a0d95e0e593ace4be86a8aa27ebdaa92c078", "patch": "@@ -11,6 +11,6 @@ program main\n   if (c /= 'abc') call abort\n end program main\n \n-! { dg-final { scan-tree-dump-times \"memmove\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"memmove\" 3 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"string_trim\" 0 \"original\" } }\n ! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "2ac36d11d7d337098fc9ef2df3f0663a1ccc5888", "filename": "gcc/testsuite/gfortran.dg/trim_optimize_2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Ftestsuite%2Fgfortran.dg%2Ftrim_optimize_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef5a0d95e0e593ace4be86a8aa27ebdaa92c078/gcc%2Ftestsuite%2Fgfortran.dg%2Ftrim_optimize_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftrim_optimize_2.f90?ref=fef5a0d95e0e593ace4be86a8aa27ebdaa92c078", "patch": "@@ -32,6 +32,6 @@ subroutine foo\n   end subroutine foo\n end program main\n \n-! { dg-final { scan-tree-dump-times \"memmove\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"memmove\" 6 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"string_trim\" 0 \"original\" } }\n ! { dg-final { cleanup-tree-dump \"original\" } }"}]}