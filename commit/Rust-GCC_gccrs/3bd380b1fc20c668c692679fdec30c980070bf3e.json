{"sha": "3bd380b1fc20c668c692679fdec30c980070bf3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JkMzgwYjFmYzIwYzY2OGM2OTI2NzlmZGVjMzBjOTgwMDcwYmYzZQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "1999-01-13T15:28:22Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "1999-01-13T15:28:22Z"}, "message": "[multiple changes]\n\nThu Jan 11 18:37:50 1999  Vladimir N. Makarov  <vmakarov@cygnus.com>\n\t* invoke.texi (-mcpu=740, -mcpu=750): New options.\n        (-m(no-)multiple, -m(no-)string): Describe cases for PPC740 &\n\tPPC750.\n1999-01-11  Michael Meissner  <meissner@cygnus.com>\n\t* config/rs6000/rs6000.h ({ASM,CPP}_CPU_SPEC): Add support for all\n\tmachines supported with -mcpu=xxx.\n\t(processor_type): Add PROCESSOR_PPC750.\n\t(ADJUST_PRIORITY): Call rs6000_adjust_priority.\n\t(RTX_COSTS): Supply costs for 750 multiply/divide operations.\n\t(rs6000_adjust_priority): Add declaration.\n\t* config/rs6000/rs6000.c (rs6000_override_options):\n\t-mcpu={750,740} now sets the processor type as 750, not 603.\n\tAllow -mmultiple and -mstring on little endian 750 systems.\n\t(rs6000_adjust_priority): Stub for now.\n\t(get_issue_rate): The PowerPC 750 can issue 2 instructions/cycle.\n\t* config/rs6000/rs6000.md (function/cpu attributes): Add initial\n\tppc750 support.\n\t* config/rs6000/sysv4.h (STRICT_ALIGNMENT): Don't force strict\n\talignment if little endian.\n\t(CC1_SPEC): Pass -mstrict-align if little endian, and not\n\toverridden.\n\t(CC1_ENDIAN_{LITTLE,BIG,DEFAULT}_SPEC): Endian specific configs.\n\t(SUBTARGET_EXTRA_SPECS): Add cc1 endian specs.\n\t* config/rs6000/{sysv4,eabi}le.h (CC1_ENDIAN_DEFAULT_SPEC):\n\tOverride, default is little endian.\n\t* config/rs6000/t-ppcgas (MULTILIB_*): Delete obsolete Solaris\n\tmultilibs.\n\nFrom-SVN: r24654", "tree": {"sha": "f5af86c4ea21ca17a9b9280d3d4a408a3c9f6d4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5af86c4ea21ca17a9b9280d3d4a408a3c9f6d4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bd380b1fc20c668c692679fdec30c980070bf3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd380b1fc20c668c692679fdec30c980070bf3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bd380b1fc20c668c692679fdec30c980070bf3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd380b1fc20c668c692679fdec30c980070bf3e/comments", "author": null, "committer": null, "parents": [{"sha": "c11145f6995c09869e75cd7946bea6b2f0ca969d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c11145f6995c09869e75cd7946bea6b2f0ca969d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c11145f6995c09869e75cd7946bea6b2f0ca969d"}], "stats": {"total": 408, "additions": 260, "deletions": 148}, "files": [{"sha": "b36115dc433f200c6bed6ab1ba50d5ec7e5ec3b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 50, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd380b1fc20c668c692679fdec30c980070bf3e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd380b1fc20c668c692679fdec30c980070bf3e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3bd380b1fc20c668c692679fdec30c980070bf3e", "patch": "@@ -1,53 +1,3 @@\n-Wed Jan 13 16:16:44 1999  Catherine Moore  <clm@cygnus.com>\n-\n-        * config/arm.c (output_func_epilogue):  Check TARGET_ABORT_NORETURN\n-        before generating a call to abort for volatile functions.\n-        * config/arm.h (ARM_FLAG_ABORT_NORETURN):  Define.\n-        (TARGET_ABORT_NORETURN):  Define.\n-        (abort-on-noreturn):  New option.\n-\n-Wed Jan 13 13:30:08 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n-\n-\t* cccp.c (xstrdup): Renamed from `savestring'.  All callers changed.\n-\tRemove prototype which we get from libiberty.h.\n-\n-\t* collect2.c (xstrdup): Likewise.\n-\n-\t* genextract.c (xstrdup): Likewise for `copystr'.\n-\t(mybzero): Remove it and use `memset' instead.\n-\n-\t* genoutput.c (mybcopy, mybzero): Remove these.  All callers changed\n-\tto use `memcpy' and `memset' instead.\n-\n-\t* genrecog.c (xstrdup): Renamed from `copystr'.  All callers\n- \tchanged.  Remove prototype.\n-\t(mybcopy, mybzero): Remove these and use memcpy/memset.\n-\n-Wed Jan 13 00:59:04 1999  Jeffrey A Law  (law@cygnus.com)\n-\n-\t* mips.h (LOAD_EXTEND_OP): Correct for SImode and CCmode moves when\n-\tgenerating code for TARGET_64BIT.\n-\n-Tue Jan 12 14:05:37 1999   David Edelsohn  <edelsohn@mhpcc.edu>\n-\n-\t* rs6000.c (print_operand, cases 'm' and 'M'): Do not depend on\n-\tHOST_WIDE_INT word-size.\n-\t(rs6000_stack_info): Remove redundant alignment of fpmem.\n-\n-Tue Jan 12 14:05:37 1999   Richard Henderson  <rth@cygnus.com>\n-\n-\t* rs6000.c (short_cint_operand): Remove CONSTANT_P_RTX handling.\n-\t(u_short_cint_operand, reg_or_cint_operand, logical_operand): Likewise.\n-\t(input_operand): Adjust CONSTANT_P_RTX handling.\n-\t* rs6000.h (PREDICATE_CODES): Remove CONSTANT_P_RTX references.\n-\t* rs6000.md (movsi): Adjust CONSTANT_P_RTX handling.\n-\t(movhi, movqi): Remove CONSANT_P_RTX handling.\n-\t(movdi): Adjust CONSTANT_P_RTX handling.\n-\n-Tue Jan 12 10:23:24 1999  Stan Cox  <scox@cygnus.com>\n-\n-\t* mips.md (call_value_internal3c): New pattern for -mips16 -mlong-calls.\n-\n 1999-01-12  Manfred Hollstein  <manfred@s-direktnet.de>\n \n \t* m68k/mot3300.h (ADD_MISSING_POSIX, ADD_MISSING_XOPEN): Define to\n@@ -107,6 +57,43 @@ Mon Jan 11 22:36:01 1999  Richard Henderson  <rth@cygnus.com>\n \t* graph.c, haifa-sched.c, local-alloc.c, regclass.c: Likewise.\n \t* regmove.c, reload1.c, reorg.c, sched.c: Likewise.\n \n+Thu Jan 11 18:37:50 1999  Vladimir N. Makarov  <vmakarov@cygnus.com>\n+\n+\t* invoke.texi (-mcpu=740, -mcpu=750): New options.\n+        (-m(no-)multiple, -m(no-)string): Describe cases for PPC740 &\n+\tPPC750.\n+\t\n+1999-01-11  Michael Meissner  <meissner@cygnus.com>\n+\n+\t* config/rs6000/rs6000.h ({ASM,CPP}_CPU_SPEC): Add support for all\n+\tmachines supported with -mcpu=xxx.\n+\t(processor_type): Add PROCESSOR_PPC750.\n+\t(ADJUST_PRIORITY): Call rs6000_adjust_priority.\n+\t(RTX_COSTS): Supply costs for 750 multiply/divide operations.\n+\t(rs6000_adjust_priority): Add declaration.\n+\t\n+\t* config/rs6000/rs6000.c (rs6000_override_options):\n+\t-mcpu={750,740} now sets the processor type as 750, not 603.\n+\tAllow -mmultiple and -mstring on little endian 750 systems.\n+\t(rs6000_adjust_priority): Stub for now.\n+\t(get_issue_rate): The PowerPC 750 can issue 2 instructions/cycle.\n+\n+\t* config/rs6000/rs6000.md (function/cpu attributes): Add initial\n+\tppc750 support.\n+\n+\t* config/rs6000/sysv4.h (STRICT_ALIGNMENT): Don't force strict\n+\talignment if little endian.\n+\t(CC1_SPEC): Pass -mstrict-align if little endian, and not\n+\toverridden.\n+\t(CC1_ENDIAN_{LITTLE,BIG,DEFAULT}_SPEC): Endian specific configs.\n+\t(SUBTARGET_EXTRA_SPECS): Add cc1 endian specs.\n+\n+\t* config/rs6000/{sysv4,eabi}le.h (CC1_ENDIAN_DEFAULT_SPEC):\n+\tOverride, default is little endian.\n+\n+\t* config/rs6000/t-ppcgas (MULTILIB_*): Delete obsolete Solaris\n+\tmultilibs.\n+\n Sat Jan  9 23:54:09 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gcc.c (xstrerror): Renamed from my_strerror.  All callers"}, {"sha": "97e2b7c6e8538a97a83cb00b97e8c905306c0c40", "filename": "gcc/config/rs6000/eabile.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd380b1fc20c668c692679fdec30c980070bf3e/gcc%2Fconfig%2Frs6000%2Feabile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd380b1fc20c668c692679fdec30c980070bf3e/gcc%2Fconfig%2Frs6000%2Feabile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Feabile.h?ref=3bd380b1fc20c668c692679fdec30c980070bf3e", "patch": "@@ -28,6 +28,9 @@ Boston, MA 02111-1307, USA.  */\n #undef\tCPP_ENDIAN_DEFAULT_SPEC\n #define\tCPP_ENDIAN_DEFAULT_SPEC \"%(cpp_endian_little)\"\n \n+#undef\tCC1_ENDIAN_DEFAULT_SPEC\n+#define\tCC1_ENDIAN_DEFAULT_SPEC \"%(cc1_endian_little)\"\n+\n #undef\tLINK_TARGET_SPEC\n #define\tLINK_TARGET_SPEC \"\\\n %{mbig: -oformat elf32-powerpc } %{mbig-endian: -oformat elf32-powerpc } \\"}, {"sha": "afb17f902c2d86c87fd0a3ea309df334a88d373b", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 77, "deletions": 16, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd380b1fc20c668c692679fdec30c980070bf3e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd380b1fc20c668c692679fdec30c980070bf3e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=3bd380b1fc20c668c692679fdec30c980070bf3e", "patch": "@@ -234,6 +234,12 @@ rs6000_override_options (default_cpu)\n \t {\"620\", PROCESSOR_PPC620,\n \t    MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n \t    POWER_MASKS | MASK_PPC_GPOPT},\n+\t {\"740\", PROCESSOR_PPC750,\n+ \t    MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n+ \t    POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n+\t {\"750\", PROCESSOR_PPC750,\n+ \t    MASK_POWERPC | MASK_PPC_GFXOPT | MASK_NEW_MNEMONICS,\n+ \t    POWER_MASKS | MASK_PPC_GPOPT | MASK_POWERPC64},\n \t {\"801\", PROCESSOR_MPCCORE,\n \t    MASK_POWERPC | MASK_SOFT_FLOAT | MASK_NEW_MNEMONICS,\n \t    POWER_MASKS | POWERPC_OPT_MASKS | MASK_POWERPC64},\n@@ -297,9 +303,12 @@ rs6000_override_options (default_cpu)\n   if (TARGET_STRING_SET)\n     target_flags = (target_flags & ~MASK_STRING) | string;\n \n-  /* Don't allow -mmultiple or -mstring on little endian systems, because the\n-     hardware doesn't support the instructions used in little endian mode */\n-  if (!BYTES_BIG_ENDIAN)\n+  /* Don't allow -mmultiple or -mstring on little endian systems unless the cpu\n+     is a 750, because the hardware doesn't support the instructions used in\n+     little endian mode, and causes an alignment trap.  The 750 does not cause\n+     an alignment trap (except when the target is unaligned).  */\n+\n+  if (!BYTES_BIG_ENDIAN && rs6000_cpu != PROCESSOR_PPC750)\n     {\n       if (TARGET_MULTIPLE)\n \t{\n@@ -497,7 +506,8 @@ short_cint_operand (op, mode)\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return ((GET_CODE (op) == CONST_INT\n-\t   && (unsigned HOST_WIDE_INT) (INTVAL (op) + 0x8000) < 0x10000));\n+\t   && (unsigned HOST_WIDE_INT) (INTVAL (op) + 0x8000) < 0x10000)\n+\t  || GET_CODE (op) == CONSTANT_P_RTX);\n }\n \n /* Similar for a unsigned D field.  */\n@@ -508,7 +518,8 @@ u_short_cint_operand (op, mode)\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return ((GET_CODE (op) == CONST_INT\n-\t   && (INTVAL (op) & (~ (HOST_WIDE_INT) 0xffff)) == 0));\n+\t   && (INTVAL (op) & (~ (HOST_WIDE_INT) 0xffff)) == 0)\n+\t  || GET_CODE (op) == CONSTANT_P_RTX);\n }\n \n /* Return 1 if OP is a CONST_INT that cannot fit in a signed D field.  */\n@@ -596,6 +607,7 @@ reg_or_cint_operand (op, mode)\n     enum machine_mode mode;\n {\n      return (GET_CODE (op) == CONST_INT\n+\t     || GET_CODE (op) == CONSTANT_P_RTX\n \t     || gpc_reg_operand (op, mode));\n }\n \n@@ -880,7 +892,8 @@ logical_operand (op, mode)\n   return (gpc_reg_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT\n \t      && ((INTVAL (op) & (~ (HOST_WIDE_INT) 0xffff)) == 0\n-\t\t  || (INTVAL (op) & 0xffff) == 0)));\n+\t\t  || (INTVAL (op) & 0xffff) == 0))\n+\t  || GET_CODE (op) == CONSTANT_P_RTX);\n }\n \n /* Return 1 if C is a constant that is not a logical operand (as\n@@ -1106,10 +1119,6 @@ input_operand (op, mode)\n   if (memory_operand (op, mode))\n     return 1;\n \n-  /* Only a tiny bit of handling for CONSTANT_P_RTX is necessary.  */\n-  if (GET_CODE (op) == CONST && GET_CODE (XEXP (op, 0)) == CONSTANT_P_RTX)\n-    return 1;\n-\n   /* For floating-point, easy constants are valid.  */\n   if (GET_MODE_CLASS (mode) == MODE_FLOAT\n       && CONSTANT_P (op)\n@@ -1119,6 +1128,7 @@ input_operand (op, mode)\n   /* Allow any integer constant.  */\n   if (GET_MODE_CLASS (mode) == MODE_INT\n       && (GET_CODE (op) == CONST_INT\n+\t  || GET_CODE (op) == CONSTANT_P_RTX\n \t  || GET_CODE (op) == CONST_DOUBLE))\n     return 1;\n \n@@ -2746,15 +2756,15 @@ print_operand (file, x, code)\n       /* If the high bit is set and the low bit is not, the value is zero.\n \t If the high bit is zero, the value is the first 1 bit we find from\n \t the left.  */\n-      if ((val & 0x80000000) && ((val & 1) == 0))\n+      if (val < 0 && (val & 1) == 0)\n \t{\n \t  putc ('0', file);\n \t  return;\n \t}\n-      else if ((val & 0x80000000) == 0)\n+      else if (val >= 0)\n \t{\n \t  for (i = 1; i < 32; i++)\n-\t    if ((val <<= 1) & 0x80000000)\n+\t    if ((val <<= 1) < 0)\n \t      break;\n \t  fprintf (file, \"%d\", i);\n \t  return;\n@@ -2781,7 +2791,7 @@ print_operand (file, x, code)\n       /* If the low bit is set and the high bit is not, the value is 31.\n \t If the low bit is zero, the value is the first 1 bit we find from\n \t the right.  */\n-      if ((val & 1) && ((val & 0x80000000) == 0))\n+      if ((val & 1) && val >= 0)\n \t{\n \t  fputs (\"31\", file);\n \t  return;\n@@ -2801,7 +2811,7 @@ print_operand (file, x, code)\n       /* Otherwise, look for the first 0 bit from the left.  The result is its\n \t number minus 1. We know the high-order bit is one.  */\n       for (i = 0; i < 32; i++)\n-\tif (((val <<= 1) & 0x80000000) == 0)\n+\tif ((val <<= 1) >= 0)\n \t  break;\n \n       fprintf (file, \"%d\", i);\n@@ -3447,6 +3457,7 @@ rs6000_stack_info ()\n \t}\n     }\n \n+\n   /* Determine if we need to save the link register */\n   if (regs_ever_live[65]\n       || (DEFAULT_ABI == ABI_AIX && profile_flag)\n@@ -3473,6 +3484,13 @@ rs6000_stack_info ()\n \tinfo_ptr->cr_size = reg_size;\n     }\n \n+  /* Ensure that fp_save_offset will be aligned to an 8-byte boundary. */\n+  if (info_ptr->fpmem_p)\n+    {\n+      info_ptr->gp_size = RS6000_ALIGN (info_ptr->gp_size, 8);\n+      info_ptr->main_size = RS6000_ALIGN (info_ptr->main_size, 8);\n+    }\n+\n   /* Determine various sizes */\n   info_ptr->reg_size     = reg_size;\n   info_ptr->fixed_size   = RS6000_SAVE_AREA;\n@@ -3526,7 +3544,6 @@ rs6000_stack_info ()\n       break;\n     }\n \n-  /* Ensure that fpmem_offset will be aligned to an 8-byte boundary. */\n   if (info_ptr->fpmem_p\n       && (info_ptr->main_save_offset - info_ptr->fpmem_size) % 8)\n     info_ptr->fpmem_size += reg_size;\n@@ -5118,6 +5135,48 @@ rs6000_adjust_cost (insn, link, dep_insn, cost)\n   return cost;\n }\n \n+/* A C statement (sans semicolon) to update the integer scheduling priority\n+   INSN_PRIORITY (INSN).  Reduce the priority to execute the INSN earlier,\n+   increase the priority to execute INSN later.  Do not define this macro if\n+   you do not need to adjust the scheduling priorities of insns.  */\n+\n+int\n+rs6000_adjust_priority (insn, priority)\n+     rtx insn;\n+     int priority;\n+{\n+  /* On machines (like the 750) which have asymetric integer units, where one\n+     integer unit can do multiply and divides and the other can't, reduce the\n+     priority of multiply/divide so it is scheduled before other integer\n+     operationss.  */\n+\n+#if 0\n+  if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+    return priority;\n+\n+  if (GET_CODE (PATTERN (insn)) == USE)\n+    return priority;\n+\n+  switch (rs6000_cpu_attr) {\n+  case CPU_PPC750:\n+    switch (get_attr_type (insn))\n+      {\n+      default:\n+\tbreak;\n+\n+      case TYPE_IMUL:\n+      case TYPE_IDIV:\n+\tfprintf (stderr, \"priority was %#x (%d) before adjustment\\n\", priority, priority);\n+\tif (priority >= 0 && priority < 0x01000000)\n+\t  priority >>= 3;\n+\tbreak;\n+      }\n+  }\n+#endif\n+\n+  return priority;\n+}\n+\n /* Return how many instructions the machine can issue per cycle */\n int get_issue_rate()\n {\n@@ -5130,6 +5189,8 @@ int get_issue_rate()\n     return 3;       /* ? */\n   case CPU_PPC603:\n     return 2; \n+  case CPU_PPC750:\n+    return 2; \n   case CPU_PPC604:\n     return 4;\n   case CPU_PPC620:"}, {"sha": "3872fdd4e9ee412537c696a9d439049b5520265d", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 41, "deletions": 20, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd380b1fc20c668c692679fdec30c980070bf3e/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd380b1fc20c668c692679fdec30c980070bf3e/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=3bd380b1fc20c668c692679fdec30c980070bf3e", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for IBM RS/6000.\n-   Copyright (C) 1992, 93-8, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 93-7, 1998 Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n This file is part of GNU CC.\n@@ -81,6 +81,9 @@ Boston, MA 02111-1307, USA.  */\n %{mcpu=604: -D_ARCH_PPC} \\\n %{mcpu=604e: -D_ARCH_PPC} \\\n %{mcpu=620: -D_ARCH_PPC} \\\n+%{mcpu=740: -D_ARCH_PPC} \\\n+%{mcpu=750: -D_ARCH_PPC} \\\n+%{mcpu=801: -D_ARCH_PPC} \\\n %{mcpu=821: -D_ARCH_PPC} \\\n %{mcpu=823: -D_ARCH_PPC} \\\n %{mcpu=860: -D_ARCH_PPC}\"\n@@ -134,6 +137,8 @@ Boston, MA 02111-1307, USA.  */\n %{mcpu=604: -mppc} \\\n %{mcpu=604e: -mppc} \\\n %{mcpu=620: -mppc} \\\n+%{mcpu=740: -mppc} \\\n+%{mcpu=750: -mppc} \\\n %{mcpu=821: -mppc} \\\n %{mcpu=823: -mppc} \\\n %{mcpu=860: -mppc}\"\n@@ -391,15 +396,18 @@ extern int target_flags;\n \n /* Processor type.  Order must match cpu attribute in MD file.  */\n enum processor_type\n- {PROCESSOR_RIOS1,\n-  PROCESSOR_RIOS2,\n-  PROCESSOR_MPCCORE,\n-  PROCESSOR_PPC403,\n-  PROCESSOR_PPC601,\n-  PROCESSOR_PPC603,\n-  PROCESSOR_PPC604,\n-  PROCESSOR_PPC604e,\n-  PROCESSOR_PPC620};\n+ {\n+   PROCESSOR_RIOS1,\n+   PROCESSOR_RIOS2,\n+   PROCESSOR_MPCCORE,\n+   PROCESSOR_PPC403,\n+   PROCESSOR_PPC601,\n+   PROCESSOR_PPC603,\n+   PROCESSOR_PPC604,\n+   PROCESSOR_PPC604e,\n+   PROCESSOR_PPC620,\n+   PROCESSOR_PPC750\n+ };\n \n extern enum processor_type rs6000_cpu;\n \n@@ -855,6 +863,14 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n #define ADJUST_COST(INSN,LINK,DEP_INSN,COST)\t\t\t\t\\\n   (COST) = rs6000_adjust_cost (INSN,LINK,DEP_INSN,COST)\n \n+/* A C statement (sans semicolon) to update the integer scheduling priority\n+   INSN_PRIORITY (INSN).  Reduce the priority to execute the INSN earlier,\n+   increase the priority to execute INSN later.  Do not define this macro if\n+   you do not need to adjust the scheduling priorities of insns.  */\n+\n+#define ADJUST_PRIORITY(INSN)\t\t\t\t\t\t\\\n+  INSN_PRIORITY (INSN) = rs6000_adjust_priority (INSN, INSN_PRIORITY (INSN))\n+\n /* Define this macro to change register usage conditional on target flags.\n    Set MQ register fixed (already call_used) if not POWER architecture\n    (RIOS1, RIOS2, RSC, and PPC601) so that it will not be allocated.\n@@ -2280,6 +2296,7 @@ do {                                                                    \\\n       case PROCESSOR_PPC601:\t\t\t\t\t\t\\\n         return COSTS_N_INSNS (5);\t\t\t\t\t\\\n       case PROCESSOR_PPC603:\t\t\t\t\t\t\\\n+      case PROCESSOR_PPC750:\t\t\t\t\t\t\\\n         return (GET_CODE (XEXP (X, 1)) != CONST_INT\t\t\t\\\n \t\t? COSTS_N_INSNS (5)\t\t\t\t\t\\\n \t\t: INTVAL (XEXP (X, 1)) >= -256 && INTVAL (XEXP (X, 1)) <= 255 \\\n@@ -2315,6 +2332,8 @@ do {                                                                    \\\n       case PROCESSOR_PPC604e:\t\t\t\t\t\t\\\n       case PROCESSOR_PPC620:\t\t\t\t\t\t\\\n \treturn COSTS_N_INSNS (20);\t\t\t\t\t\\\n+      case PROCESSOR_PPC750:\t\t\t\t\t\t\\\n+        return COSTS_N_INSNS (19);\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n   case FFS:\t\t\t\t\t\t\t\t\\\n     return COSTS_N_INSNS (4);\t\t\t\t\t\t\\\n@@ -3169,15 +3188,15 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Define the codes that are matched by predicates in rs6000.c.  */\n \n #define PREDICATE_CODES\t\t\t\t\t\t\\\n-  {\"short_cint_operand\", {CONST_INT}},\t\t\t\t\\\n-  {\"u_short_cint_operand\", {CONST_INT}},\t\t\t\\\n+  {\"short_cint_operand\", {CONST_INT, CONSTANT_P_RTX}},\t\t\\\n+  {\"u_short_cint_operand\", {CONST_INT, CONSTANT_P_RTX}},\t\\\n   {\"non_short_cint_operand\", {CONST_INT}},\t\t\t\\\n   {\"gpc_reg_operand\", {SUBREG, REG}},\t\t\t\t\\\n   {\"cc_reg_operand\", {SUBREG, REG}},\t\t\t\t\\\n-  {\"reg_or_short_operand\", {SUBREG, REG, CONST_INT}}, \t\t\\\n+  {\"reg_or_short_operand\", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}}, \\\n   {\"reg_or_neg_short_operand\", {SUBREG, REG, CONST_INT}},\t\\\n-  {\"reg_or_u_short_operand\", {SUBREG, REG, CONST_INT}}, \t\\\n-  {\"reg_or_cint_operand\", {SUBREG, REG, CONST_INT}}, \t\t\\\n+  {\"reg_or_u_short_operand\", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}}, \\\n+  {\"reg_or_cint_operand\", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}}, \\\n   {\"got_operand\", {SYMBOL_REF, CONST, LABEL_REF}},\t\t\\\n   {\"got_no_const_operand\", {SYMBOL_REF, LABEL_REF}},\t\t\\\n   {\"easy_fp_constant\", {CONST_DOUBLE}},\t\t\t\t\\\n@@ -3186,19 +3205,20 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"volatile_mem_operand\", {MEM}},\t\t\t\t\\\n   {\"offsettable_addr_operand\", {REG, SUBREG, PLUS}},\t\t\\\n   {\"mem_or_easy_const_operand\", {SUBREG, MEM, CONST_DOUBLE}},\t\\\n-  {\"add_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"add_operand\", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}},\t\\\n   {\"non_add_cint_operand\", {CONST_INT}},\t\t\t\\\n-  {\"and_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"and64_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\\\n-  {\"logical_operand\", {SUBREG, REG, CONST_INT}}, \t\t\\\n+  {\"and_operand\", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}},\t\\\n+  {\"and64_operand\", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX,\t\\\n+\t\t     CONST_DOUBLE}},\t\t\t\t\\\n+  {\"logical_operand\", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}}, \\\n   {\"non_logical_cint_operand\", {CONST_INT}},\t\t\t\\\n   {\"mask_operand\", {CONST_INT}},\t\t\t\t\\\n   {\"mask64_operand\", {CONST_INT, CONST_DOUBLE}},\t\t\\\n   {\"count_register_operand\", {REG}},\t\t\t\t\\\n   {\"fpmem_operand\", {REG}},\t\t\t\t\t\\\n   {\"call_operand\", {SYMBOL_REF, REG}},\t\t\t\t\\\n   {\"current_file_function_operand\", {SYMBOL_REF}},\t\t\\\n-  {\"input_operand\", {SUBREG, MEM, REG, CONST_INT, \t\t\\\n+  {\"input_operand\", {SUBREG, MEM, REG, CONST_INT, CONSTANT_P_RTX, \\\n \t\t     CONST_DOUBLE, SYMBOL_REF}}, \t\t\\\n   {\"load_multiple_operation\", {PARALLEL}},\t\t\t\\\n   {\"store_multiple_operation\", {PARALLEL}},\t\t\t\\\n@@ -3306,6 +3326,7 @@ extern void output_ascii ();\n extern void rs6000_gen_section_name ();\n extern void output_function_profiler ();\n extern int rs6000_adjust_cost ();\n+extern int rs6000_adjust_priority ();\n extern void rs6000_trampoline_template ();\n extern int rs6000_trampoline_size ();\n extern void rs6000_initialize_trampoline ();"}, {"sha": "6fb83723bffbb0f5d388c84c90dd975b65cfd10e", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 45, "deletions": 31, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd380b1fc20c668c692679fdec30c980070bf3e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd380b1fc20c668c692679fdec30c980070bf3e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=3bd380b1fc20c668c692679fdec30c980070bf3e", "patch": "@@ -1,5 +1,5 @@\n ;; Machine description for IBM RISC System 6000 (POWER) for GNU C compiler\n-;; Copyright (C) 1990, 91-98, 1999 Free Software Foundation, Inc.\n+;; Copyright (C) 1990, 91-97, 1998 Free Software Foundation, Inc.\n ;; Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n ;; This file is part of GNU CC.\n@@ -40,7 +40,7 @@\n ;; Processor type -- this attribute must exactly match the processor_type\n ;; enumeration in rs6000.h.\n \n-(define_attr \"cpu\" \"rios1,rios2,mpccore,ppc403,ppc601,ppc603,ppc604,ppc604e,ppc620\"\n+(define_attr \"cpu\" \"rios1,rios2,mpccore,ppc403,ppc601,ppc603,ppc604,ppc604e,ppc620,ppc750\"\n   (const (symbol_ref \"rs6000_cpu_attr\")))\n \n ; (define_function_unit NAME MULTIPLICITY SIMULTANEITY\n@@ -50,24 +50,49 @@\n ; (POWER and 601 use Integer Unit)\n (define_function_unit \"lsu\" 1 0\n   (and (eq_attr \"type\" \"load\")\n-       (eq_attr \"cpu\" \"mpccore,ppc603,ppc604,ppc604e,ppc620\"))\n+       (eq_attr \"cpu\" \"mpccore,ppc603,ppc604,ppc604e,ppc620,ppc750\"))\n   2 1)\n \n (define_function_unit \"lsu\" 1 0\n   (and (eq_attr \"type\" \"store,fpstore\")\n-       (eq_attr \"cpu\" \"mpccore,ppc603,ppc604,ppc604e,ppc620\"))\n+       (eq_attr \"cpu\" \"mpccore,ppc603,ppc604,ppc604e,ppc620,ppc750\"))\n   1 1)\n \n (define_function_unit \"lsu\" 1 0\n   (and (eq_attr \"type\" \"fpload\")\n-       (eq_attr \"cpu\" \"mpccore,ppc603\"))\n+       (eq_attr \"cpu\" \"mpccore,ppc603,ppc750\"))\n   2 1)\n \n (define_function_unit \"lsu\" 1 0\n   (and (eq_attr \"type\" \"fpload\")\n        (eq_attr \"cpu\" \"ppc604,ppc604e,ppc620\"))\n   3 1)\n \n+; PPC750 has two integer units: a primary one which can perform all\n+; operations and a secondary one which is fed in lock step with the first\n+; and can perform \"simple\" integer operations.  \n+; To catch this we define a 'dummy' imuldiv-unit that is also needed\n+; for the complex insns. \n+(define_function_unit \"iu2\" 2 0\n+  (and (eq_attr \"type\" \"integer\")\n+       (eq_attr \"cpu\" \"ppc750\"))\n+  1 1)\n+\n+(define_function_unit \"iu2\" 2 0\n+  (and (eq_attr \"type\" \"imul\")\n+       (eq_attr \"cpu\" \"ppc750\"))\n+  4 2)\n+\n+(define_function_unit \"imuldiv\" 1 0\n+  (and (eq_attr \"type\" \"imul\")\n+       (eq_attr \"cpu\" \"ppc750\"))\n+  4 2)\n+\n+(define_function_unit \"imuldiv\" 1 0\n+  (and (eq_attr \"type\" \"idiv\")\n+       (eq_attr \"cpu\" \"ppc750\"))\n+  19 19)\n+\n (define_function_unit \"iu\" 1 0\n   (and (eq_attr \"type\" \"load\")\n        (eq_attr \"cpu\" \"rios1,ppc403,ppc601\"))\n@@ -218,7 +243,7 @@\n \n (define_function_unit \"iu\" 1 0\n   (and (eq_attr \"type\" \"compare,delayed_compare\")\n-       (eq_attr \"cpu\" \"mpccore,ppc403,ppc601,ppc603,ppc604,ppc604e,ppc620\"))\n+       (eq_attr \"cpu\" \"mpccore,ppc403,ppc601,ppc603,ppc604,ppc604e,ppc620,ppc750\"))\n   3 1)\n \n (define_function_unit \"iu2\" 2 0   \n@@ -228,7 +253,7 @@\n \n (define_function_unit \"iu2\" 2 0\n   (and (eq_attr \"type\" \"compare,delayed_compare\")\n-       (eq_attr \"cpu\" \"ppc604,ppc604e,ppc620\"))\n+       (eq_attr \"cpu\" \"ppc604,ppc604e,ppc620,ppc750\"))\n   1 1)\n \n ; fp compare uses fp unit\n@@ -255,7 +280,7 @@\n ; fp compare uses fp unit\n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"fpcompare\")\n-       (eq_attr \"cpu\" \"ppc601,ppc603,ppc604,ppc604e,ppc620\"))\n+       (eq_attr \"cpu\" \"ppc601,ppc603,ppc604,ppc604e,ppc620,ppc750\"))\n   5 1)\n \n (define_function_unit \"fpu\" 1 0\n@@ -270,7 +295,7 @@\n \n (define_function_unit \"bpu\" 1 0\n   (and (eq_attr \"type\" \"mtjmpr\")\n-       (eq_attr \"cpu\" \"mpccore,ppc403,ppc601,ppc603,ppc604,ppc604e,ppc620\"))\n+       (eq_attr \"cpu\" \"mpccore,ppc403,ppc601,ppc603,ppc604,ppc604e,ppc620,ppc750\"))\n   4 1)\n \n ; all jumps/branches are executing on the bpu, in 1 cycle, for all machines.\n@@ -300,7 +325,7 @@\n \n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"fp\")\n-       (eq_attr \"cpu\" \"ppc603,ppc604,ppc604e,ppc620\"))\n+       (eq_attr \"cpu\" \"ppc603,ppc604,ppc604e,ppc620,ppc750\"))\n   3 1)\n \n (define_function_unit \"fpu\" 1 0\n@@ -316,7 +341,7 @@\n ; is this true?\n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"dmul\")\n-       (eq_attr \"cpu\" \"ppc603\"))\n+       (eq_attr \"cpu\" \"ppc603,ppc750\"))\n   4 2)\n \n (define_function_unit \"fpu\" 1 0\n@@ -351,7 +376,7 @@\n \n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"ddiv\")\n-       (eq_attr \"cpu\" \"ppc601,ppc604,ppc604e,ppc620\"))\n+       (eq_attr \"cpu\" \"ppc601,ppc604,ppc604e,ppc620,ppc750\"))\n   31 31)\n \n (define_function_unit \"fpu\" 1 0\n@@ -5399,14 +5424,6 @@\n   if (GET_CODE (operands[1]) == CONST_DOUBLE)\n     operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n \n-  /* Only a tiny bit of handling for CONSTANT_P_RTX is necessary.  */\n-  if (GET_CODE (operands[1]) == CONST\n-      && GET_CODE (XEXP (operands[1], 0)) == CONSTANT_P_RTX)\n-    {\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n-      DONE;\n-    }\n-\n   /* Use default pattern for address of ELF small data */\n   if (TARGET_ELF\n       && (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n@@ -5428,7 +5445,8 @@\n       && !flag_pic\n       && CONSTANT_P (operands[1])\n       && GET_CODE (operands[1]) != HIGH\n-      && GET_CODE (operands[1]) != CONST_INT)\n+      && GET_CODE (operands[1]) != CONST_INT\n+      && GET_CODE (operands[1]) != CONSTANT_P_RTX)\n     {\n       rtx target = (reload_completed || reload_in_progress)\n \t\t\t? operands[0] : gen_reg_rtx (SImode);\n@@ -5482,6 +5500,7 @@\n   if ((!TARGET_WINDOWS_NT || DEFAULT_ABI != ABI_NT)\n       && CONSTANT_P (operands[1])\n       && GET_CODE (operands[1]) != CONST_INT\n+      && GET_CODE (operands[1]) != CONSTANT_P_RTX\n       && GET_CODE (operands[1]) != HIGH\n       && ! LEGITIMATE_CONSTANT_POOL_ADDRESS_P (operands[1]))\n     {\n@@ -5580,7 +5599,8 @@\n     operands[1] = force_reg (HImode, operands[1]);\n \n   if (CONSTANT_P (operands[1])\n-      && GET_CODE (operands[1]) != CONST_INT)\n+      && GET_CODE (operands[1]) != CONST_INT\n+      && GET_CODE (operands[1]) != CONSTANT_P_RTX)\n     {\n       operands[1] = force_const_mem (HImode, operands[1]);\n       if (! memory_address_p (HImode, XEXP (operands[1], 0))\n@@ -5616,7 +5636,8 @@\n     operands[1] = force_reg (QImode, operands[1]);\n \n   if (CONSTANT_P (operands[1])\n-      && GET_CODE (operands[1]) != CONST_INT)\n+      && GET_CODE (operands[1]) != CONST_INT\n+      && GET_CODE (operands[1]) != CONSTANT_P_RTX)\n     {\n       operands[1] = force_const_mem (QImode, operands[1]);\n       if (! memory_address_p (QImode, XEXP (operands[1], 0))\n@@ -6016,18 +6037,11 @@\n \t )\n     operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n \n-  /* Only a tiny bit of handling for CONSTANT_P_RTX is necessary.  */\n-  if (GET_CODE (operands[1]) == CONST\n-      && GET_CODE (XEXP (operands[1], 0)) == CONSTANT_P_RTX)\n-    {\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n-      DONE;\n-    }\n-\n   if (TARGET_64BIT\n       && CONSTANT_P (operands[1])\n #if HOST_BITS_PER_WIDE_INT == 32\n       && GET_CODE (operands[1]) != CONST_INT\n+      && GET_CODE (operands[1]) != CONSTANT_P_RTX\n #endif\n       && ! easy_fp_constant (operands[1], DImode)\n       && ! LEGITIMATE_CONSTANT_POOL_ADDRESS_P (operands[1]))"}, {"sha": "7262c3d3492795efea32d52381378938073e790b", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd380b1fc20c668c692679fdec30c980070bf3e/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd380b1fc20c668c692679fdec30c980070bf3e/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=3bd380b1fc20c668c692679fdec30c980070bf3e", "patch": "@@ -393,12 +393,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* Define this macro to be the value 1 if instructions will fail to\n    work if given data not on the nominal alignment.  If instructions\n-   will merely go slower in that case, define this macro as 0.\n-\n-   Note, little endian systems trap on unaligned addresses, so never\n-   turn off strict alignment in that case. */\n+   will merely go slower in that case, define this macro as 0.  */\n #undef\tSTRICT_ALIGNMENT\n-#define\tSTRICT_ALIGNMENT (TARGET_STRICT_ALIGN || TARGET_LITTLE_ENDIAN)\n+#define\tSTRICT_ALIGNMENT (TARGET_STRICT_ALIGN)\n \n /* Alignment in bits of the stack boundary.  Note, in order to allow building\n    one set of libraries with -mno-eabi instead of eabi libraries and non-eabi\n@@ -975,16 +972,38 @@ do {\t\t\t\t\t\t\t\t\t\\\n %{memb} %{!memb: %{msdata: -memb} %{msdata=eabi: -memb}} \\\n %{mlittle} %{mlittle-endian} %{mbig} %{mbig-endian} \\\n %{!mlittle: %{!mlittle-endian: %{!mbig: %{!mbig-endian: \\\n-    %{mcall-solaris: -mlittle -msolaris} %{mcall-linux: -mbig} }}}}\"\n+    %{mcall-solaris: -mlittle -msolaris} \\\n+    %{mcall-linux: -mbig} }}}}\"\n+\n+#ifndef CC1_ENDIAN_BIG_SPEC\n+#define CC1_ENDIAN_BIG_SPEC \"\"\n+#endif\n+\n+#ifndef CC1_ENDIAN_LITTLE_SPEC\n+#define CC1_ENDIAN_LITTLE_SPEC \"\\\n+%{!mstrict-align: %{!mno-strict-align: \\\n+\t-mstrict-align \\\n+}}\"\n+#endif\n+\n+#ifndef CC1_ENDIAN_DEFAULT_SPEC\n+#define CC1_ENDIAN_DEFAULT_SPEC \"%(cc1_endian_big_spec)\"\n+#endif\n \n #undef CC1_SPEC\n /* Pass -G xxx to the compiler and set correct endian mode */\n #define CC1_SPEC \"%{G*} \\\n+%{mlittle: %(cc1_endian_little)} %{!mlittle: %{mlittle-endian: %(cc1_endian_little)}} \\\n+%{mbig: %(cc1_endian_big)} %{!mbig: %{mbig-endian: %(cc1_endian_big)}} \\\n %{!mlittle: %{!mlittle-endian: %{!mbig: %{!mbig-endian: \\\n-    %{mcall-nt: -mlittle } \\\n-    %{mcall-aixdesc: -mbig } \\\n-    %{mcall-solaris: -mlittle } \\\n-    %{mcall-linux: -mbig} }}}} \\\n+    %{mcall-nt: -mlittle %{cc1_endian_little} } \\\n+    %{mcall-aixdesc: -mbig %{cc1_endian_big} } \\\n+    %{mcall-solaris: -mlittle %{cc1_endian_little} } \\\n+    %{mcall-linux: -mbig %{cc1_endian_big}}} \\\n+    %{!mcall-nt: %{!mcall-aixdesc: %{!mcall-solaris: %{!mcall-linux: \\\n+\t    %(cc1_endian_default) \\\n+    }}}} \\\n+}}} \\\n %{mcall-solaris: -mregnames } \\\n %{mno-sdata: -msdata=none } \\\n %{meabi: %{!mcall-*: -mcall-sysv }} \\\n@@ -1068,7 +1087,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n #undef\tLINK_TARGET_SPEC\n #define\tLINK_TARGET_SPEC \"\\\n %{mlittle: -oformat elf32-powerpcle } %{mlittle-endian: -oformat elf32-powerpcle } \\\n-%{!mlittle: %{!mlittle-endian: %{!mbig: %{!mbig-endian: %{mcall-solaris: -oformat elf32-powerpcle}}}}}\"\n+%{!mlittle: %{!mlittle-endian: %{!mbig: %{!mbig-endian: \\\n+    %{mcall-solaris: -oformat elf32-powerpcle}}}}}\"\n \n /* Any specific OS flags */\n #ifndef LINK_OS_SPEC\n@@ -1419,6 +1439,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n   { \"link_os_linux\",\t\tLINK_OS_LINUX_SPEC },\t\t\t\\\n   { \"link_os_solaris\",\t\tLINK_OS_SOLARIS_SPEC },\t\t\t\\\n   { \"link_os_default\",\t\tLINK_OS_DEFAULT_SPEC },\t\t\t\\\n+  { \"cc1_endian_big\",\t\tCC1_ENDIAN_BIG_SPEC },\t\t\t\\\n+  { \"cc1_endian_little\",\tCC1_ENDIAN_LITTLE_SPEC },\t\t\\\n+  { \"cc1_endian_default\",\tCC1_ENDIAN_DEFAULT_SPEC },\t\t\\\n   { \"cpp_endian_big\",\t\tCPP_ENDIAN_BIG_SPEC },\t\t\t\\\n   { \"cpp_endian_little\",\tCPP_ENDIAN_LITTLE_SPEC },\t\t\\\n   { \"cpp_endian_solaris\",\tCPP_ENDIAN_SOLARIS_SPEC },\t\t\\"}, {"sha": "1e21acd7b8659bd7106fa3e32a431ff3e65fdb6b", "filename": "gcc/config/rs6000/sysv4le.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd380b1fc20c668c692679fdec30c980070bf3e/gcc%2Fconfig%2Frs6000%2Fsysv4le.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd380b1fc20c668c692679fdec30c980070bf3e/gcc%2Fconfig%2Frs6000%2Fsysv4le.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4le.h?ref=3bd380b1fc20c668c692679fdec30c980070bf3e", "patch": "@@ -28,6 +28,9 @@ Boston, MA 02111-1307, USA.  */\n #undef\tCPP_ENDIAN_DEFAULT_SPEC\n #define\tCPP_ENDIAN_DEFAULT_SPEC \"%(cpp_endian_little)\"\n \n+#undef\tCC1_ENDIAN_DEFAULT_SPEC\n+#define\tCC1_ENDIAN_DEFAULT_SPEC \"%(cc1_endian_little)\"\n+\n #undef\tLINK_TARGET_SPEC\n #define\tLINK_TARGET_SPEC \"\\\n %{mbig: -oformat elf32-powerpc } %{mbig-endian: -oformat elf32-powerpc } \\"}, {"sha": "8ea37beebd5e5abe1d1a3ae719da5e4cf2c0c38f", "filename": "gcc/config/rs6000/t-ppcgas", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd380b1fc20c668c692679fdec30c980070bf3e/gcc%2Fconfig%2Frs6000%2Ft-ppcgas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd380b1fc20c668c692679fdec30c980070bf3e/gcc%2Fconfig%2Frs6000%2Ft-ppcgas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-ppcgas?ref=3bd380b1fc20c668c692679fdec30c980070bf3e", "patch": "@@ -3,17 +3,14 @@\n \n MULTILIB_OPTIONS\t= msoft-float \\\n \t\t\t  mlittle/mbig \\\n-\t\t\t  mcall-sysv/mcall-aix/mcall-solaris/mcall-linux\n+\t\t\t  mcall-sysv/mcall-aix/mcall-linux\n \n MULTILIB_DIRNAMES\t= nof \\\n \t\t\t  le be \\\n-\t\t\t  cs ca sol lin\n+\t\t\t  cs ca lin\n \n MULTILIB_EXTRA_OPTS\t= mrelocatable-lib mno-eabi mstrict-align\n-MULTILIB_EXCEPTIONS\t= *mbig/*mcall-solaris* \\\n-\t\t\t  *mlittle/*mcall-solaris* \\\n-\t\t\t  *msoft-float/*mcall-solaris* \\\n-\t\t\t  *mbig/*mcall-linux* \\\n+MULTILIB_EXCEPTIONS\t= *mbig/*mcall-linux* \\\n \t\t\t  *mlittle/*mcall-linux* \\\n \t\t\t  *msoft-float/*mcall-linux*\n "}, {"sha": "f930e9d292d8bae5c157e1cd570287723b397669", "filename": "gcc/invoke.texi", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd380b1fc20c668c692679fdec30c980070bf3e/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd380b1fc20c668c692679fdec30c980070bf3e/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=3bd380b1fc20c668c692679fdec30c980070bf3e", "patch": "@@ -4285,13 +4285,13 @@ Set architecture type, register usage, choice of mnemonics, and\n instruction scheduling parameters for machine type @var{cpu_type}.\n Supported values for @var{cpu_type} are @samp{rs6000}, @samp{rios1},\n @samp{rios2}, @samp{rsc}, @samp{601}, @samp{602}, @samp{603},\n-@samp{603e}, @samp{604}, @samp{604e}, @samp{620}, @samp{power},\n-@samp{power2}, @samp{powerpc}, @samp{403}, @samp{505}, @samp{801},\n-@samp{821}, @samp{823}, and @samp{860} and @samp{common}.\n-@samp{-mcpu=power}, @samp{-mcpu=power2}, and @samp{-mcpu=powerpc}\n-specify generic POWER, POWER2 and pure PowerPC (i.e., not MPC601)\n-architecture machine types, with an appropriate, generic processor model\n-assumed for scheduling purposes.@refill\n+@samp{603e}, @samp{604}, @samp{604e}, @samp{620}, @samp{740},\n+@samp{750}, @samp{power}, @samp{power2}, @samp{powerpc}, @samp{403},\n+@samp{505}, @samp{801}, @samp{821}, @samp{823}, and @samp{860} and\n+@samp{common}.  @samp{-mcpu=power}, @samp{-mcpu=power2}, and\n+@samp{-mcpu=powerpc} specify generic POWER, POWER2 and pure PowerPC\n+(i.e., not MPC601) architecture machine types, with an appropriate,\n+generic processor model assumed for scheduling purposes.@refill\n \n @c overfull hbox here --bob 22 jul96\n @c original text between ignore ... end ignore\n@@ -4435,17 +4435,20 @@ instructions and the store multiple word instructions.  These\n instructions are generated by default on POWER systems, and not\n generated on PowerPC systems.  Do not use @samp{-mmultiple} on little\n endian PowerPC systems, since those instructions do not work when the\n-processor is in little endian mode.\n+processor is in little endian mode.  The exceptions are PPC740 and\n+PPC750 which permit the instructions usage in little endian mode.\n \n @item -mstring\n @itemx -mno-string\n @kindex -mstring\n-Generate code that uses (does not use) the load string instructions and the\n-store string word instructions to save multiple registers and do small block\n-moves.  These instructions are generated by default on POWER systems, and not\n-generated on PowerPC systems.  Do not use @samp{-mstring} on little endian\n-PowerPC systems, since those instructions do not work when the processor is in\n-little endian mode.\n+Generate code that uses (does not use) the load string instructions\n+and the store string word instructions to save multiple registers and\n+do small block moves.  These instructions are generated by default on\n+POWER systems, and not generated on PowerPC systems.  Do not use\n+@samp{-mstring} on little endian PowerPC systems, since those\n+instructions do not work when the processor is in little endian mode.\n+The exceptions are PPC740 and PPC750 which permit the instructions\n+usage in little endian mode.\n \n @item -mupdate\n @itemx -mno-update"}]}