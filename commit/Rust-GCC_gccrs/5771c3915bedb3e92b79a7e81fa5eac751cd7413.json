{"sha": "5771c3915bedb3e92b79a7e81fa5eac751cd7413", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc3MWMzOTE1YmVkYjNlOTJiNzlhN2U4MWZhNWVhYzc1MWNkNzQxMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-10-03T07:29:42Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-10-03T07:29:42Z"}, "message": "re PR libgomp/61200 (internal compiler error: Segmentation fault, assert & openmp)\n\n\tPR libgomp/61200\n\t* omp-low.c (taskreg_contexts): New variable.\n\t(scan_omp_parallel): Push newly created context into taskreg_contexts\n\tvector and move record layout code to finish_taskreg_scan.\n\t(scan_omp_task): Likewise.\n\t(finish_taskreg_scan): New function.\n\t(execute_lower_omp): Call finish_taskreg_scan on all taskreg_contexts\n\tvector elements and release it.\n\n\t* c-c++-common/gomp/pr61200.c: New test.\n\n\t* testsuite/libgomp.c/pr61200.c: New test.\n\nFrom-SVN: r215835", "tree": {"sha": "c8064d52e6ef0cbb4a3d77e534901e6b120a766e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8064d52e6ef0cbb4a3d77e534901e6b120a766e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5771c3915bedb3e92b79a7e81fa5eac751cd7413", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5771c3915bedb3e92b79a7e81fa5eac751cd7413", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5771c3915bedb3e92b79a7e81fa5eac751cd7413", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5771c3915bedb3e92b79a7e81fa5eac751cd7413/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "661fb5ddb8d4232135a61227e7db2d1de8e458ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/661fb5ddb8d4232135a61227e7db2d1de8e458ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/661fb5ddb8d4232135a61227e7db2d1de8e458ac"}], "stats": {"total": 202, "additions": 192, "deletions": 10}, "files": [{"sha": "9326c8fda28b52da409f18154737dbd8b30b368e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5771c3915bedb3e92b79a7e81fa5eac751cd7413/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5771c3915bedb3e92b79a7e81fa5eac751cd7413/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5771c3915bedb3e92b79a7e81fa5eac751cd7413", "patch": "@@ -1,5 +1,14 @@\n 2014-10-03  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR libgomp/61200\n+\t* omp-low.c (taskreg_contexts): New variable.\n+\t(scan_omp_parallel): Push newly created context into taskreg_contexts\n+\tvector and move record layout code to finish_taskreg_scan.\n+\t(scan_omp_task): Likewise.\n+\t(finish_taskreg_scan): New function.\n+\t(execute_lower_omp): Call finish_taskreg_scan on all taskreg_contexts\n+\tvector elements and release it.\n+\n \tPR target/62128\n \t* config/i386/i386.c (expand_vec_perm_palignr): If op1, op0 order\n \tof palignr arguments can't be used due to min 0 or max - min"}, {"sha": "06db877291f81ca25fd1e1728513363fe31ce4ee", "filename": "gcc/omp-low.c", "status": "modified", "additions": 75, "deletions": 10, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5771c3915bedb3e92b79a7e81fa5eac751cd7413/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5771c3915bedb3e92b79a7e81fa5eac751cd7413/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=5771c3915bedb3e92b79a7e81fa5eac751cd7413", "patch": "@@ -204,6 +204,7 @@ static int taskreg_nesting_level;\n static int target_nesting_level;\n static struct omp_region *root_omp_region;\n static bitmap task_shared_vars;\n+static vec<omp_context *> taskreg_contexts;\n \n static void scan_omp (gimple_seq *, omp_context *);\n static tree scan_omp_1_op (tree *, int *, void *);\n@@ -2097,6 +2098,7 @@ scan_omp_parallel (gimple_stmt_iterator *gsi, omp_context *outer_ctx)\n     }\n \n   ctx = new_omp_context (stmt, outer_ctx);\n+  taskreg_contexts.safe_push (ctx);\n   if (taskreg_nesting_level > 1)\n     ctx->is_nested = true;\n   ctx->field_map = splay_tree_new (splay_tree_compare_pointers, 0, 0);\n@@ -2116,11 +2118,6 @@ scan_omp_parallel (gimple_stmt_iterator *gsi, omp_context *outer_ctx)\n \n   if (TYPE_FIELDS (ctx->record_type) == NULL)\n     ctx->record_type = ctx->receiver_decl = NULL;\n-  else\n-    {\n-      layout_type (ctx->record_type);\n-      fixup_child_record_type (ctx);\n-    }\n }\n \n /* Scan an OpenMP task directive.  */\n@@ -2131,7 +2128,6 @@ scan_omp_task (gimple_stmt_iterator *gsi, omp_context *outer_ctx)\n   omp_context *ctx;\n   tree name, t;\n   gimple stmt = gsi_stmt (*gsi);\n-  location_t loc = gimple_location (stmt);\n \n   /* Ignore task directives with empty bodies.  */\n   if (optimize > 0\n@@ -2142,6 +2138,7 @@ scan_omp_task (gimple_stmt_iterator *gsi, omp_context *outer_ctx)\n     }\n \n   ctx = new_omp_context (stmt, outer_ctx);\n+  taskreg_contexts.safe_push (ctx);\n   if (taskreg_nesting_level > 1)\n     ctx->is_nested = true;\n   ctx->field_map = splay_tree_new (splay_tree_compare_pointers, 0, 0);\n@@ -2179,8 +2176,71 @@ scan_omp_task (gimple_stmt_iterator *gsi, omp_context *outer_ctx)\n       t = build_int_cst (long_integer_type_node, 1);\n       gimple_omp_task_set_arg_align (stmt, t);\n     }\n+}\n+\n+\n+/* If any decls have been made addressable during scan_omp,\n+   adjust their fields if needed, and layout record types\n+   of parallel/task constructs.  */\n+\n+static void\n+finish_taskreg_scan (omp_context *ctx)\n+{\n+  if (ctx->record_type == NULL_TREE)\n+    return;\n+\n+  /* If any task_shared_vars were needed, verify all\n+     OMP_CLAUSE_SHARED clauses on GIMPLE_OMP_{PARALLEL,TASK}\n+     statements if use_pointer_for_field hasn't changed\n+     because of that.  If it did, update field types now.  */\n+  if (task_shared_vars)\n+    {\n+      tree c;\n+\n+      for (c = gimple_omp_taskreg_clauses (ctx->stmt);\n+\t   c; c = OMP_CLAUSE_CHAIN (c))\n+\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SHARED)\n+\t  {\n+\t    tree decl = OMP_CLAUSE_DECL (c);\n+\n+\t    /* Global variables don't need to be copied,\n+\t       the receiver side will use them directly.  */\n+\t    if (is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx)))\n+\t      continue;\n+\t    if (!bitmap_bit_p (task_shared_vars, DECL_UID (decl))\n+\t\t|| !use_pointer_for_field (decl, ctx))\n+\t      continue;\n+\t    tree field = lookup_field (decl, ctx);\n+\t    if (TREE_CODE (TREE_TYPE (field)) == POINTER_TYPE\n+\t\t&& TREE_TYPE (TREE_TYPE (field)) == TREE_TYPE (decl))\n+\t      continue;\n+\t    TREE_TYPE (field) = build_pointer_type (TREE_TYPE (decl));\n+\t    TREE_THIS_VOLATILE (field) = 0;\n+\t    DECL_USER_ALIGN (field) = 0;\n+\t    DECL_ALIGN (field) = TYPE_ALIGN (TREE_TYPE (field));\n+\t    if (TYPE_ALIGN (ctx->record_type) < DECL_ALIGN (field))\n+\t      TYPE_ALIGN (ctx->record_type) = DECL_ALIGN (field);\n+\t    if (ctx->srecord_type)\n+\t      {\n+\t\ttree sfield = lookup_sfield (decl, ctx);\n+\t\tTREE_TYPE (sfield) = TREE_TYPE (field);\n+\t\tTREE_THIS_VOLATILE (sfield) = 0;\n+\t\tDECL_USER_ALIGN (sfield) = 0;\n+\t\tDECL_ALIGN (sfield) = DECL_ALIGN (field);\n+\t\tif (TYPE_ALIGN (ctx->srecord_type) < DECL_ALIGN (sfield))\n+\t\t  TYPE_ALIGN (ctx->srecord_type) = DECL_ALIGN (sfield);\n+\t      }\n+\t  }\n+    }\n+\n+  if (gimple_code (ctx->stmt) == GIMPLE_OMP_PARALLEL)\n+    {\n+      layout_type (ctx->record_type);\n+      fixup_child_record_type (ctx);\n+    }\n   else\n     {\n+      location_t loc = gimple_location (ctx->stmt);\n       tree *p, vla_fields = NULL_TREE, *q = &vla_fields;\n       /* Move VLA fields to the end.  */\n       p = &TYPE_FIELDS (ctx->record_type);\n@@ -2200,12 +2260,12 @@ scan_omp_task (gimple_stmt_iterator *gsi, omp_context *outer_ctx)\n       fixup_child_record_type (ctx);\n       if (ctx->srecord_type)\n \tlayout_type (ctx->srecord_type);\n-      t = fold_convert_loc (loc, long_integer_type_node,\n-\t\t\tTYPE_SIZE_UNIT (ctx->record_type));\n-      gimple_omp_task_set_arg_size (stmt, t);\n+      tree t = fold_convert_loc (loc, long_integer_type_node,\n+\t\t\t\t TYPE_SIZE_UNIT (ctx->record_type));\n+      gimple_omp_task_set_arg_size (ctx->stmt, t);\n       t = build_int_cst (long_integer_type_node,\n \t\t\t TYPE_ALIGN_UNIT (ctx->record_type));\n-      gimple_omp_task_set_arg_align (stmt, t);\n+      gimple_omp_task_set_arg_align (ctx->stmt, t);\n     }\n }\n \n@@ -10560,6 +10620,8 @@ static unsigned int\n execute_lower_omp (void)\n {\n   gimple_seq body;\n+  int i;\n+  omp_context *ctx;\n \n   /* This pass always runs, to provide PROP_gimple_lomp.\n      But there is nothing to do unless -fopenmp is given.  */\n@@ -10572,6 +10634,9 @@ execute_lower_omp (void)\n   body = gimple_body (current_function_decl);\n   scan_omp (&body, NULL);\n   gcc_assert (taskreg_nesting_level == 0);\n+  FOR_EACH_VEC_ELT (taskreg_contexts, i, ctx)\n+    finish_taskreg_scan (ctx);\n+  taskreg_contexts.release ();\n \n   if (all_contexts->root)\n     {"}, {"sha": "aad6c16260cd4c8d0e9261a46649644390db31af", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5771c3915bedb3e92b79a7e81fa5eac751cd7413/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5771c3915bedb3e92b79a7e81fa5eac751cd7413/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5771c3915bedb3e92b79a7e81fa5eac751cd7413", "patch": "@@ -1,5 +1,8 @@\n 2014-10-03  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR libgomp/61200\n+\t* c-c++-common/gomp/pr61200.c: New test.\n+\n \tPR target/62128\n \t* gcc.dg/torture/vshuf-16.inc (TESTS): Add 2 new permutations.\n \t* gcc.dg/torture/vshuf-32.inc (TESTS): Add 5 new permutations."}, {"sha": "d0d699dfa0b7bb8a272ba9e4a9c8bae0ed11cca8", "filename": "gcc/testsuite/c-c++-common/gomp/pr61200.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5771c3915bedb3e92b79a7e81fa5eac751cd7413/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr61200.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5771c3915bedb3e92b79a7e81fa5eac751cd7413/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr61200.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr61200.c?ref=5771c3915bedb3e92b79a7e81fa5eac751cd7413", "patch": "@@ -0,0 +1,13 @@\n+/* PR libgomp/61200 */\n+\n+int\n+main ()\n+{\n+  int var = 1;\n+  #pragma omp parallel\n+    if (var != 1)\n+      __builtin_abort ();\n+  #pragma omp task shared(var)\n+    var = 2;\n+  return 0;\n+}"}, {"sha": "0bf7cbe8be5a3d506cb7a100d3538ee734318b55", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5771c3915bedb3e92b79a7e81fa5eac751cd7413/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5771c3915bedb3e92b79a7e81fa5eac751cd7413/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=5771c3915bedb3e92b79a7e81fa5eac751cd7413", "patch": "@@ -1,3 +1,8 @@\n+2014-10-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR libgomp/61200\n+\t* testsuite/libgomp.c/pr61200.c: New test.\n+\n 2014-09-18  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/63248"}, {"sha": "ba3ed37e0405292867c8ecae4be394130a742d3c", "filename": "libgomp/testsuite/libgomp.c/pr61200.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5771c3915bedb3e92b79a7e81fa5eac751cd7413/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr61200.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5771c3915bedb3e92b79a7e81fa5eac751cd7413/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr61200.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr61200.c?ref=5771c3915bedb3e92b79a7e81fa5eac751cd7413", "patch": "@@ -0,0 +1,87 @@\n+/* PR libgomp/61200 */\n+/* { dg-do run } */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+\n+volatile int x;\n+\n+void\n+foo ()\n+{\n+  int var = 1;\n+  int i;\n+\n+  for (i = 0; i < 2; i++)\n+    {\n+      if (i == 1)\n+\t{\n+\t  #pragma omp parallel num_threads(2)\n+\t    if (x)\n+\t      var++;\n+\t    else\n+\t      {\n+\t\t#pragma omp single\n+\t\t  sleep (2);\n+\t      }\n+\t}\n+      else\n+\t{\n+\t  #pragma omp task shared(var)\n+\t  {\n+\t    sleep (1);\n+\t    var = 2;\n+\t  }\n+\t}\n+    }\n+  #pragma omp taskwait\n+  if (var != 2)\n+    abort ();\n+}\n+\n+void\n+bar ()\n+{\n+  int var = 1;\n+  int i;\n+\n+  for (i = 0; i < 2; i++)\n+    {\n+      if (i == 0)\n+\t{\n+\t  #pragma omp task shared(var)\n+\t  {\n+\t    sleep (1);\n+\t    var = 2;\n+\t  }\n+\t}\n+      else\n+\t{\n+\t  #pragma omp parallel num_threads(2)\n+\t    if (x)\n+\t      var++;\n+\t    else\n+\t      {\n+\t\t#pragma omp single\n+\t\t  sleep (2);\n+\t      }\n+\t}\n+    }\n+  #pragma omp taskwait\n+  if (var != 2)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  omp_set_nested (1);\n+  #pragma omp parallel num_threads(2)\n+    #pragma omp single\n+      foo ();\n+  #pragma omp parallel num_threads(2)\n+    #pragma omp single\n+      bar ();\n+  return 0;\n+}"}]}