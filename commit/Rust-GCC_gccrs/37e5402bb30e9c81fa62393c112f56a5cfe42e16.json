{"sha": "37e5402bb30e9c81fa62393c112f56a5cfe42e16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdlNTQwMmJiMzBlOWM4MWZhNjIzOTNjMTEyZjU2YTVjZmU0MmUxNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-10-06T14:06:04Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-10-06T14:06:04Z"}, "message": "invoke.texi (-fprofile-report): Document.\n\n\n\t* doc/invoke.texi (-fprofile-report): Document.\n\t* common.opt (-fprofile-report): New option.\n\t* toplev.c (finalize): Call dump_profile_report.\n\t* toplev.h (profile_report): Declare.\n\t* passes.c (profile_record): New static var.\n\t(check_profile_consistency): New function.\n\t(dump_profile_record): New function.\n\t(execute_one_ipa_transform_pass): Call check_profile_consistency.\n\t(execute_one_pass): Likewise.\n\nFrom-SVN: r192161", "tree": {"sha": "e1e42815c9499f0b95c3a5198d14934740fd2fc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1e42815c9499f0b95c3a5198d14934740fd2fc1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37e5402bb30e9c81fa62393c112f56a5cfe42e16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37e5402bb30e9c81fa62393c112f56a5cfe42e16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37e5402bb30e9c81fa62393c112f56a5cfe42e16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37e5402bb30e9c81fa62393c112f56a5cfe42e16/comments", "author": null, "committer": null, "parents": [{"sha": "5e25600e6e4c363389f3d09b2c5065f339381556", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e25600e6e4c363389f3d09b2c5065f339381556", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e25600e6e4c363389f3d09b2c5065f339381556"}], "stats": {"total": 248, "additions": 247, "deletions": 1}, "files": [{"sha": "649f45eebb93e1be071656a39e957fafd1a8a79c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37e5402bb30e9c81fa62393c112f56a5cfe42e16/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37e5402bb30e9c81fa62393c112f56a5cfe42e16/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=37e5402bb30e9c81fa62393c112f56a5cfe42e16", "patch": "@@ -1,3 +1,15 @@\n+2012-10-06  Jan Hubicka  <jh@suse.cz>\n+\n+\t* doc/invoke.texi (-fprofile-report): Document.\n+\t* common.opt (-fprofile-report): New option.\n+\t* toplev.c (finalize): Call dump_profile_report.\n+\t* toplev.h (profile_report): Declare.\n+\t* passes.c (profile_record): New static var.\n+\t(check_profile_consistency): New function.\n+\t(dump_profile_record): New function.\n+\t(execute_one_ipa_transform_pass): Call check_profile_consistency.\n+\t(execute_one_pass): Likewise.\n+\n 2012-10-06  Jan Hubicka  <jh@suse.cz>\n \n \tPR lto/54790 "}, {"sha": "6de670b8ae536e4e886d0ff2ee97af6439ebbe65", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37e5402bb30e9c81fa62393c112f56a5cfe42e16/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37e5402bb30e9c81fa62393c112f56a5cfe42e16/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=37e5402bb30e9c81fa62393c112f56a5cfe42e16", "patch": "@@ -1654,6 +1654,10 @@ fprofile-values\n Common Report Var(flag_profile_values)\n Insert code to profile values of expressions\n \n+fprofile-report\n+Common Report Var(profile_report)\n+Report on consistency of profile\n+\n frandom-seed\n Common Var(common_deferred_options) Defer\n "}, {"sha": "711c15133733ebbf4a62e436a1817765695efaaa", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37e5402bb30e9c81fa62393c112f56a5cfe42e16/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37e5402bb30e9c81fa62393c112f56a5cfe42e16/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=37e5402bb30e9c81fa62393c112f56a5cfe42e16", "patch": "@@ -388,7 +388,7 @@ Objective-C and Objective-C++ Dialects}.\n -fno-toplevel-reorder -fno-trapping-math -fno-zero-initialized-in-bss @gol\n -fomit-frame-pointer -foptimize-register-move -foptimize-sibling-calls @gol\n -fpartial-inlining -fpeel-loops -fpredictive-commoning @gol\n--fprefetch-loop-arrays @gol\n+-fprefetch-loop-arrays -fprofile-report @gol\n -fprofile-correction -fprofile-dir=@var{path} -fprofile-generate @gol\n -fprofile-generate=@var{path} @gol\n -fprofile-use -fprofile-use=@var{path} -fprofile-values @gol\n@@ -5153,6 +5153,11 @@ allocation for the WPA phase only.\n Makes the compiler print some statistics about permanent memory\n allocation before or after interprocedural optimization.\n \n+@item -fprofile-report\n+@opindex fprofile-report\n+Makes the compiler print some statistics about consistency of the\n+(estimated) profile and effect of individual passes.\n+\n @item -fstack-usage\n @opindex fstack-usage\n Makes the compiler output stack usage information for the program, on a"}, {"sha": "1b0a196702055a364cc7443b325b8ab2cd7a510a", "filename": "gcc/passes.c", "status": "modified", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37e5402bb30e9c81fa62393c112f56a5cfe42e16/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37e5402bb30e9c81fa62393c112f56a5cfe42e16/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=37e5402bb30e9c81fa62393c112f56a5cfe42e16", "patch": "@@ -1778,6 +1778,209 @@ execute_function_dump (void *data ATTRIBUTE_UNUSED)\n     }\n }\n \n+/* Make statistic about profile consistency.  */\n+\n+struct profile_record\n+{\n+  int num_mismatched_freq_in[2];\n+  int num_mismatched_freq_out[2];\n+  int num_mismatched_count_in[2];\n+  int num_mismatched_count_out[2];\n+  bool run;\n+  gcov_type time[2];\n+  int size[2];\n+};\n+\n+static struct profile_record *profile_record;\n+\n+static void\n+check_profile_consistency (int index, int subpass, bool run)\n+{\n+  basic_block bb;\n+  edge_iterator ei;\n+  edge e;\n+  int sum;\n+  gcov_type lsum;\n+\n+  if (index == -1)\n+    return;\n+  if (!profile_record)\n+    profile_record = XCNEWVEC (struct profile_record,\n+\t\t\t       passes_by_id_size);\n+  gcc_assert (index < passes_by_id_size && index >= 0);\n+  gcc_assert (subpass < 2);\n+  profile_record[index].run |= run;\n+\n+  FOR_ALL_BB (bb)\n+   {\n+      if (bb != EXIT_BLOCK_PTR_FOR_FUNCTION (cfun)\n+\t  && profile_status != PROFILE_ABSENT)\n+\t{\n+\t  sum = 0;\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    sum += e->probability;\n+\t  if (EDGE_COUNT (bb->succs) && abs (sum - REG_BR_PROB_BASE) > 100)\n+\t    profile_record[index].num_mismatched_freq_out[subpass]++;\n+\t  lsum = 0;\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    lsum += e->count;\n+\t  if (EDGE_COUNT (bb->succs)\n+\t      && (lsum - bb->count > 100 || lsum - bb->count < -100))\n+\t    profile_record[index].num_mismatched_count_out[subpass]++;\n+\t}\n+      if (bb != ENTRY_BLOCK_PTR_FOR_FUNCTION (cfun)\n+\t  && profile_status != PROFILE_ABSENT)\n+\t{\n+\t  sum = 0;\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    sum += EDGE_FREQUENCY (e);\n+\t  if (abs (sum - bb->frequency) > 100\n+\t      || (MAX (sum, bb->frequency) > 10\n+\t\t  && abs ((sum - bb->frequency) * 100 / (MAX (sum, bb->frequency) + 1)) > 10))\n+\t    profile_record[index].num_mismatched_freq_in[subpass]++;\n+\t  lsum = 0;\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    lsum += e->count;\n+\t  if (lsum - bb->count > 100 || lsum - bb->count < -100)\n+\t    profile_record[index].num_mismatched_count_in[subpass]++;\n+\t}\n+      if (bb == ENTRY_BLOCK_PTR_FOR_FUNCTION (cfun)\n+\t  || bb == EXIT_BLOCK_PTR_FOR_FUNCTION (cfun))\n+\tcontinue;\n+      if ((cfun && (cfun->curr_properties & PROP_trees)))\n+\t{\n+\t  gimple_stmt_iterator i;\n+\n+\t  for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n+\t    {\n+\t      profile_record[index].size[subpass]\n+\t\t += estimate_num_insns (gsi_stmt (i), &eni_size_weights);\n+\t      if (profile_status == PROFILE_READ)\n+\t\tprofile_record[index].time[subpass]\n+\t\t   += estimate_num_insns (gsi_stmt (i),\n+\t\t\t\t\t  &eni_time_weights) * bb->count;\n+\t      else if (profile_status == PROFILE_GUESSED)\n+\t\tprofile_record[index].time[subpass]\n+\t\t   += estimate_num_insns (gsi_stmt (i),\n+\t\t\t\t\t  &eni_time_weights) * bb->frequency;\n+\t    }\n+\t}\n+      else if (cfun && (cfun->curr_properties & PROP_rtl))\n+\t{\n+\t  rtx insn;\n+\t  for (insn = NEXT_INSN (BB_HEAD (bb)); insn && insn != NEXT_INSN (BB_END (bb));\n+\t       insn = NEXT_INSN (insn))\n+\t    if (INSN_P (insn))\n+\t      {\n+\t\tprofile_record[index].size[subpass]\n+\t\t   += insn_rtx_cost (PATTERN (insn), false);\n+\t\tif (profile_status == PROFILE_READ)\n+\t\t  profile_record[index].time[subpass]\n+\t\t     += insn_rtx_cost (PATTERN (insn), true) * bb->count;\n+\t\telse if (profile_status == PROFILE_GUESSED)\n+\t\t  profile_record[index].time[subpass]\n+\t\t     += insn_rtx_cost (PATTERN (insn), true) * bb->frequency;\n+\t      }\n+\t}\n+   }\n+}\n+\n+/* Output profile consistency.  */\n+\n+void\n+dump_profile_report (void)\n+{\n+  int i, j;\n+  int last_freq_in = 0, last_count_in = 0, last_freq_out = 0, last_count_out = 0;\n+  gcov_type last_time, last_size;\n+  double rel_time_change, rel_size_change;\n+  int last_reported;\n+\n+  if (!profile_record)\n+    return;\n+  fprintf (stderr, \"\\nProfile consistency report:\\n\\n\");\n+  fprintf (stderr, \"Pass name                        |mismatch in |mismated out|Overall\\n\");\n+  fprintf (stderr, \"                                 |freq count  |freq count  |size   time\\n\");\n+\t   \n+  for (i = 0; i < passes_by_id_size; i++)\n+    for (j = 0 ; j < 2; j++)\n+      if (profile_record[i].run)\n+\t{\n+\t  if (last_time)\n+\t    rel_time_change = (profile_record[i].time[j]\n+\t\t\t       - (double)last_time) * 100 / (double)last_time;\n+\t  else\n+\t    rel_time_change = 0;\n+\t  if (last_size)\n+\t    rel_size_change = (profile_record[i].size[j]\n+\t\t\t       - (double)last_size) * 100 / (double)last_size;\n+\t  else\n+\t    rel_size_change = 0;\n+\n+\t  if (profile_record[i].num_mismatched_freq_in[j] != last_freq_in\n+\t      || profile_record[i].num_mismatched_freq_out[j] != last_freq_out\n+\t      || profile_record[i].num_mismatched_count_in[j] != last_count_in\n+\t      || profile_record[i].num_mismatched_count_out[j] != last_count_out\n+\t      || rel_time_change || rel_size_change)\n+\t    {\n+\t      last_reported = i;\n+              fprintf (stderr, \"%-20s %s\",\n+\t\t       passes_by_id [i]->name,\n+\t\t       j ? \"(after TODO)\" : \"            \");\n+\t      if (profile_record[i].num_mismatched_freq_in[j] != last_freq_in)\n+\t\tfprintf (stderr, \"| %+5i\",\n+\t\t         profile_record[i].num_mismatched_freq_in[j]\n+\t\t\t  - last_freq_in);\n+\t      else\n+\t\tfprintf (stderr, \"|      \");\n+\t      if (profile_record[i].num_mismatched_count_in[j] != last_count_in)\n+\t\tfprintf (stderr, \" %+5i\",\n+\t\t         profile_record[i].num_mismatched_count_in[j]\n+\t\t\t  - last_count_in);\n+\t      else\n+\t\tfprintf (stderr, \"      \");\n+\t      if (profile_record[i].num_mismatched_freq_out[j] != last_freq_out)\n+\t\tfprintf (stderr, \"| %+5i\",\n+\t\t         profile_record[i].num_mismatched_freq_out[j]\n+\t\t\t  - last_freq_out);\n+\t      else\n+\t\tfprintf (stderr, \"|      \");\n+\t      if (profile_record[i].num_mismatched_count_out[j] != last_count_out)\n+\t\tfprintf (stderr, \" %+5i\",\n+\t\t         profile_record[i].num_mismatched_count_out[j]\n+\t\t\t  - last_count_out);\n+\t      else\n+\t\tfprintf (stderr, \"      \");\n+\n+\t      /* Size/time units change across gimple and RTL.  */\n+\t      if (i == pass_expand.pass.static_pass_number)\n+\t\tfprintf (stderr, \"|----------\");\n+\t      else\n+\t\t{\n+\t\t  if (rel_size_change)\n+\t\t    fprintf (stderr, \"| %+8.4f%%\", rel_size_change);\n+\t\t  else\n+\t\t    fprintf (stderr, \"|          \");\n+\t\t  if (rel_time_change)\n+\t\t    fprintf (stderr, \" %+8.4f%%\", rel_time_change);\n+\t\t}\n+\t      fprintf (stderr, \"\\n\");\n+\t      last_freq_in = profile_record[i].num_mismatched_freq_in[j];\n+\t      last_freq_out = profile_record[i].num_mismatched_freq_out[j];\n+\t      last_count_in = profile_record[i].num_mismatched_count_in[j];\n+\t      last_count_out = profile_record[i].num_mismatched_count_out[j];\n+\t    }\n+\t  else if (j && last_reported != i)\n+\t    {\n+\t      last_reported = i;\n+              fprintf (stderr, \"%-20s ------------|            |            |\\n\",\n+\t\t       passes_by_id [i]->name);\n+\t    }\n+\t  last_time = profile_record[i].time[j];\n+\t  last_size = profile_record[i].size[j];\n+\t}\n+}\n+\n /* Perform all TODO actions that ought to be done on each function.  */\n \n static void\n@@ -2042,9 +2245,14 @@ execute_one_ipa_transform_pass (struct cgraph_node *node,\n   if (pass->tv_id != TV_NONE)\n     timevar_pop (pass->tv_id);\n \n+  if (profile_report && cfun && (cfun->curr_properties & PROP_cfg))\n+    check_profile_consistency (pass->static_pass_number, 0, true);\n+\n   /* Run post-pass cleanup and verification.  */\n   execute_todo (todo_after);\n   verify_interpass_invariants ();\n+  if (profile_report && cfun && (cfun->curr_properties & PROP_cfg))\n+    check_profile_consistency (pass->static_pass_number, 1, true);\n \n   do_per_function (execute_function_dump, NULL);\n   pass_fini_dump_file (pass);\n@@ -2144,6 +2352,13 @@ execute_one_pass (struct opt_pass *pass)\n \n   if (!gate_status)\n     {\n+      /* Run so passes selectively disabling themselves on a given function\n+\t are not miscounted.  */\n+      if (profile_report && cfun && (cfun->curr_properties & PROP_cfg))\n+\t{\n+          check_profile_consistency (pass->static_pass_number, 0, false);\n+          check_profile_consistency (pass->static_pass_number, 1, false);\n+\t}\n       current_pass = NULL;\n       return false;\n     }\n@@ -2210,8 +2425,14 @@ execute_one_pass (struct opt_pass *pass)\n       clean_graph_dump_file (dump_file_name);\n     }\n \n+  if (profile_report && cfun && (cfun->curr_properties & PROP_cfg))\n+    check_profile_consistency (pass->static_pass_number, 0, true);\n+\n   /* Run post-pass cleanup and verification.  */\n   execute_todo (todo_after | pass->todo_flags_finish);\n+  if (profile_report && cfun && (cfun->curr_properties & PROP_cfg))\n+    check_profile_consistency (pass->static_pass_number, 1, true);\n+\n   verify_interpass_invariants ();\n   do_per_function (execute_function_dump, NULL);\n   if (pass->type == IPA_PASS)"}, {"sha": "04c173681019a14b8448448b6983451afb47b9d1", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37e5402bb30e9c81fa62393c112f56a5cfe42e16/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37e5402bb30e9c81fa62393c112f56a5cfe42e16/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=37e5402bb30e9c81fa62393c112f56a5cfe42e16", "patch": "@@ -1815,6 +1815,9 @@ finalize (bool no_backend)\n   if (mem_report)\n     dump_memory_report (true);\n \n+  if (dump_profile_report)\n+    dump_profile_report ();\n+\n   /* Language-specific end of compilation actions.  */\n   lang_hooks.finish ();\n }"}, {"sha": "9a41e075371793202a079851ed03fb4a6bc86455", "filename": "gcc/toplev.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37e5402bb30e9c81fa62393c112f56a5cfe42e16/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37e5402bb30e9c81fa62393c112f56a5cfe42e16/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=37e5402bb30e9c81fa62393c112f56a5cfe42e16", "patch": "@@ -49,6 +49,7 @@ extern void emit_debug_global_declarations (tree *, int);\n extern void write_global_declarations (void);\n \n extern void dump_memory_report (bool);\n+extern void dump_profile_report (void);\n \n extern void target_reinit (void);\n "}]}