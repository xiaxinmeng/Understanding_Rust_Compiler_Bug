{"sha": "fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmEyMjAwY2JiMWVmNWE2YTdiZGI5YTViYTcwOGM3NDAwZWI2YjQwNA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-11-02T01:31:18Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-11-02T01:31:18Z"}, "message": "call.c (null_ptr_cst_p): Use maybe_constant_value.\n\n\t* call.c (null_ptr_cst_p): Use maybe_constant_value.\n\t(set_up_extended_ref_temp): Support constant initialization.\n\t(initialize_reference): Adjust.\n\t* class.c (check_bitfield_decl): Use cxx_constant_value.\n\t* cvt.c (ocp_convert): Don't use integral_constant_value when\n\tconverting to class type.\n\t* decl.c (finish_case_label): Use maybe_constant_value.\n\t(build_init_list_var_init): Support constant initialization.\n\t(check_initializer): Likewise.  Reorganize.\n\t(cp_finish_decl): Likewise.\n\t(expand_static_init): Likewise.\n\t(compute_array_index_type): Use maybe_constant_value.\n\tAdd complain parm.\n\t(create_array_type_for_decl, grokdeclarator): Pass it.\n\t(build_enumerator): Use cxx_constant_value.\n\t* decl2.c (grokfield): Use maybe_constant_init.\n\t* except.c (check_noexcept_r): Handle constexpr.\n\t(build_noexcept_spec): Use maybe_constant_value.\n\t* init.c (expand_default_init): Support constant initialization.\n\t(build_vec_init): Likewise.\n\t(constant_value_1): Adjust.\n\t(build_new_1): Adjust.\n\t* parser.c (cp_parser_constant_expression): Allow non-integral\n\tin C++0x mode.\n\t(cp_parser_direct_declarator): Don't fold yet in C++0x mode.\n\t(cp_parser_initializer_clause): Toss folded result if non-constant.\n\t* pt.c (fold_decl_constant_value): Remove.\n\t(convert_nontype_argument): Use maybe_constant_value.  Give clearer\n\terror about overflow.\n\t(tsubst): Move array bounds handling into compute_array_index_type.\n\t(value_dependent_expression_p): Handle constant CALL_EXPR.\n\t* semantics.c (finish_static_assert): Use maybe_constant_value.\n\t(ensure_literal_type_for_constexpr_object): Make sure type is complete.\n\t(potential_constant_expression): Use maybe_constant_value.\n\t* tree.c (cast_valid_in_integral_constant_expression_p): Any cast\n\tis potentially valid in C++0x.\n\t* typeck2.c (store_init_value): Handle constant init.\n\t(check_narrowing): Use maybe_constant_value.\n\t(build_functional_cast): Set TREE_CONSTANT on literal T().\n\t* cp-tree.h (DECL_INTEGRAL_CONSTANT_VAR_P): Remove.\n\t(LOOKUP_ALREADY_DIGESTED): New.\n\t(compute_array_index_type): Adjust prototype.\n\nFrom-SVN: r166167", "tree": {"sha": "6c2db2fc090bec484b5ef60fbe416d72e1c7b6a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c2db2fc090bec484b5ef60fbe416d72e1c7b6a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/comments", "author": null, "committer": null, "parents": [{"sha": "c41095db2f17d8e8695bfab2a582b8f99639633f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c41095db2f17d8e8695bfab2a582b8f99639633f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c41095db2f17d8e8695bfab2a582b8f99639633f"}], "stats": {"total": 2180, "additions": 1919, "deletions": 261}, "files": [{"sha": "2e9f535bef283d89f608c3bc446b2165feb2bbf0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -1,6 +1,53 @@\n 2010-11-01  Gabriel Dos Reis  <gdr@cse.tamu.edu>\n \t    Jason Merrill  <jason@redhat.com>\n \n+\t* call.c (null_ptr_cst_p): Use maybe_constant_value.\n+\t(set_up_extended_ref_temp): Support constant initialization.\n+\t(initialize_reference): Adjust.\n+\t* class.c (check_bitfield_decl): Use cxx_constant_value.\n+\t* cvt.c (ocp_convert): Don't use integral_constant_value when\n+\tconverting to class type.\n+\t* decl.c (finish_case_label): Use maybe_constant_value.\n+\t(build_init_list_var_init): Support constant initialization.\n+\t(check_initializer): Likewise.  Reorganize.\n+\t(cp_finish_decl): Likewise.\n+\t(expand_static_init): Likewise.\n+\t(compute_array_index_type): Use maybe_constant_value.\n+\tAdd complain parm.\n+\t(create_array_type_for_decl, grokdeclarator): Pass it.\n+\t(build_enumerator): Use cxx_constant_value.\n+\t* decl2.c (grokfield): Use maybe_constant_init.\n+\t* except.c (check_noexcept_r): Handle constexpr.\n+\t(build_noexcept_spec): Use maybe_constant_value.\n+\t* init.c (expand_default_init): Support constant initialization.\n+\t(build_vec_init): Likewise.\n+\t(constant_value_1): Adjust.\n+\t(build_new_1): Adjust.\n+\t* parser.c (cp_parser_constant_expression): Allow non-integral\n+\tin C++0x mode.\n+\t(cp_parser_direct_declarator): Don't fold yet in C++0x mode.\n+\t(cp_parser_initializer_clause): Toss folded result if non-constant.\n+\t* pt.c (fold_decl_constant_value): Remove.\n+\t(convert_nontype_argument): Use maybe_constant_value.  Give clearer\n+\terror about overflow.\n+\t(tsubst): Move array bounds handling into compute_array_index_type.\n+\t(value_dependent_expression_p): Handle constant CALL_EXPR.\n+\t(tsubst_decl): Don't set\n+\tDECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P yet.\n+\t(tsubst_expr) [DECL_EXPR]: Pass it into cp_finish_decl.\n+\t(instantiate_decl): Here too.\n+\t* semantics.c (finish_static_assert): Use maybe_constant_value.\n+\t(ensure_literal_type_for_constexpr_object): Make sure type is complete.\n+\t(potential_constant_expression): Use maybe_constant_value.\n+\t* tree.c (cast_valid_in_integral_constant_expression_p): Any cast\n+\tis potentially valid in C++0x.\n+\t* typeck2.c (store_init_value): Handle constant init.\n+\t(check_narrowing): Use maybe_constant_value.\n+\t(build_functional_cast): Set TREE_CONSTANT on literal T().\n+\t* cp-tree.h (DECL_INTEGRAL_CONSTANT_VAR_P): Remove.\n+\t(LOOKUP_ALREADY_DIGESTED): New.\n+\t(compute_array_index_type): Adjust prototype.\n+\n \t* semantics.c (constexpr_call): New datatype.\n \t(constexpr_call_table): New global table.\n \t(constexpr_call_hash): New."}, {"sha": "a1c8682fe6c047013415428710e7e29b29bdccba", "filename": "gcc/cp/call.c", "status": "modified", "additions": 44, "deletions": 11, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -466,15 +466,24 @@ null_ptr_cst_p (tree t)\n      A null pointer constant is an integral constant expression\n      (_expr.const_) rvalue of integer type that evaluates to zero or\n      an rvalue of type std::nullptr_t. */\n-  t = integral_constant_value (t);\n-  if (t == null_node\n-      || NULLPTR_TYPE_P (TREE_TYPE (t)))\n+  if (NULLPTR_TYPE_P (TREE_TYPE (t)))\n     return true;\n-  if (CP_INTEGRAL_TYPE_P (TREE_TYPE (t)) && integer_zerop (t))\n+  if (CP_INTEGRAL_TYPE_P (TREE_TYPE (t)))\n     {\n-      STRIP_NOPS (t);\n-      if (!TREE_OVERFLOW (t))\n-\treturn true;\n+      if (cxx_dialect >= cxx0x)\n+\t{\n+\t  t = fold_non_dependent_expr (t);\n+\t  t = maybe_constant_value (t);\n+\t  if (TREE_CONSTANT (t) && integer_zerop (t))\n+\t    return true;\n+\t}\n+      else\n+\t{\n+\t  t = integral_constant_value (t);\n+\t  STRIP_NOPS (t);\n+\t  if (integer_zerop (t) && !TREE_OVERFLOW (t))\n+\t    return true;\n+\t}\n     }\n   return false;\n }\n@@ -7907,9 +7916,32 @@ set_up_extended_ref_temp (tree decl, tree expr, tree *cleanup, tree *initp)\n      VAR.  */\n   if (TREE_CODE (expr) != TARGET_EXPR)\n     expr = get_target_expr (expr);\n-  /* Create the INIT_EXPR that will initialize the temporary\n-     variable.  */\n-  init = build2 (INIT_EXPR, type, var, expr);\n+\n+  /* If the initializer is constant, put it in DECL_INITIAL so we get\n+     static initialization and use in constant expressions.  */\n+  init = maybe_constant_init (expr);\n+  if (TREE_CONSTANT (init))\n+    {\n+      if (literal_type_p (type) && CP_TYPE_CONST_NON_VOLATILE_P (type))\n+\t{\n+\t  /* 5.19 says that a constant expression can include an\n+\t     lvalue-rvalue conversion applied to \"a glvalue of literal type\n+\t     that refers to a non-volatile temporary object initialized\n+\t     with a constant expression\".  Rather than try to communicate\n+\t     that this VAR_DECL is a temporary, just mark it constexpr.\n+\n+\t     Currently this is only useful for initializer_list temporaries,\n+\t     since reference vars can't appear in constant expressions.  */\n+\t  DECL_DECLARED_CONSTEXPR_P (var) = true;\n+\t  TREE_CONSTANT (var) = true;\n+\t}\n+      DECL_INITIAL (var) = init;\n+      init = NULL_TREE;\n+    }\n+  else\n+    /* Create the INIT_EXPR that will initialize the temporary\n+       variable.  */\n+    init = build2 (INIT_EXPR, type, var, expr);\n   if (at_function_scope_p ())\n     {\n       add_decl_expr (var);\n@@ -8067,7 +8099,8 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup,\n \t\t\t\t\tbuild_pointer_type (base_conv_type),\n \t\t\t\t\t/*check_access=*/true,\n \t\t\t\t\t/*nonnull=*/true, complain);\n-\t      expr = build2 (COMPOUND_EXPR, TREE_TYPE (expr), init, expr);\n+\t      if (init)\n+\t\texpr = build2 (COMPOUND_EXPR, TREE_TYPE (expr), init, expr);\n \t    }\n \t  else\n \t    /* Take the address of EXPR.  */"}, {"sha": "217450c82c76b395b4d982db61db79f5d483cc97", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -2802,7 +2802,7 @@ check_bitfield_decl (tree field)\n       STRIP_NOPS (w);\n \n       /* detect invalid field size.  */\n-      w = integral_constant_value (w);\n+      w = cxx_constant_value (w);\n \n       if (TREE_CODE (w) != INTEGER_CST)\n \t{"}, {"sha": "e408ef7ea6ecf582bcff28cd1e0ee84ebaff2aa2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -2207,23 +2207,6 @@ struct GTY((variable_size)) lang_decl {\n #define DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P(NODE) \\\n   (TREE_LANG_FLAG_2 (VAR_DECL_CHECK (NODE)))\n \n-/* Nonzero for a VAR_DECL that can be used in an integral constant\n-   expression.\n-\n-      [expr.const]\n-\n-      An integral constant-expression can only involve ... const\n-      variables of static or enumeration types initialized with\n-      constant expressions ...\n-\n-   The standard does not require that the expression be non-volatile.\n-   G++ implements the proposed correction in DR 457.  */\n-#define DECL_INTEGRAL_CONSTANT_VAR_P(NODE)\t\t\\\n-  (TREE_CODE (NODE) == VAR_DECL\t\t\t\t\\\n-   && CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (NODE))\t\\\n-   && INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (NODE))\t\\\n-   && DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (NODE))\n-\n /* Nonzero if the DECL was initialized in the class definition itself,\n    rather than outside the class.  This is used for both static member\n    VAR_DECLS, and FUNCTION_DECLS that are defined in the class.  */\n@@ -4235,6 +4218,9 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, TYPENAME_FLAG };\n    another mechanism.  Exiting early also avoids problems with trying\n    to perform argument conversions when the class isn't complete yet.  */\n #define LOOKUP_SPECULATIVE (LOOKUP_LIST_ONLY << 1)\n+/* Used in calls to store_init_value to suppress its usual call to\n+   digest_init.  */\n+#define LOOKUP_ALREADY_DIGESTED (LOOKUP_SPECULATIVE << 1)\n \n #define LOOKUP_NAMESPACES_ONLY(F)  \\\n   (((F) & LOOKUP_PREFER_NAMESPACES) && !((F) & LOOKUP_PREFER_TYPES))\n@@ -4826,7 +4812,7 @@ extern tree static_fn_type\t\t\t(tree);\n extern void revert_static_member_fn\t\t(tree);\n extern void fixup_anonymous_aggr\t\t(tree);\n extern int check_static_variable_definition\t(tree, tree);\n-extern tree compute_array_index_type\t\t(tree, tree);\n+extern tree compute_array_index_type\t\t(tree, tree, tsubst_flags_t);\n extern tree check_default_argument\t\t(tree, tree);\n typedef int (*walk_namespaces_fn)\t\t(tree, void *);\n extern int walk_namespaces\t\t\t(walk_namespaces_fn,\n@@ -5258,6 +5244,7 @@ extern tree ensure_literal_type_for_constexpr_object (tree);\n extern tree cxx_constant_value (tree);\n extern tree maybe_constant_value (tree);\n extern tree maybe_constant_init (tree);\n+extern bool is_sub_constant_expr (tree);\n extern bool reduced_constant_expression_p (tree);\n \n enum {"}, {"sha": "d2d6f4acdf94a21a57d7217a0c0215b5bb199cc4", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -609,7 +609,10 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n       return error_mark_node;\n     }\n \n-  e = integral_constant_value (e);\n+  /* FIXME remove when moving to c_fully_fold model.  */\n+  /* FIXME do we still need this test?  */\n+  if (!CLASS_TYPE_P (type))\n+    e = integral_constant_value (e);\n   if (error_operand_p (e))\n     return error_mark_node;\n "}, {"sha": "fb5ca7ff6f9cd7e9d9e13500642f10ed6b69ae46", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 168, "deletions": 82, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -2936,9 +2936,9 @@ finish_case_label (location_t loc, tree low_value, tree high_value)\n     return error_mark_node;\n \n   if (low_value)\n-    low_value = decl_constant_value (low_value);\n+    low_value = cxx_constant_value (low_value);\n   if (high_value)\n-    high_value = decl_constant_value (high_value);\n+    high_value = cxx_constant_value (high_value);\n \n   r = c_add_case_label (loc, switch_stack->cases, cond,\n \t\t\tSWITCH_STMT_TYPE (switch_stack->switch_stmt),\n@@ -4530,16 +4530,15 @@ grok_reference_init (tree decl, tree type, tree init, tree *cleanup)\n    grok_reference_init.  */\n \n static tree\n-build_init_list_var_init (tree decl, tree type, tree init, tree *cleanup)\n+build_init_list_var_init (tree decl, tree type, tree init, tree *array_init,\n+\t\t\t  tree *cleanup)\n {\n   tree aggr_init, array, arrtype;\n   init = perform_implicit_conversion (type, init, tf_warning_or_error);\n   if (error_operand_p (init))\n     return error_mark_node;\n \n   aggr_init = TARGET_EXPR_INITIAL (init);\n-  init = build2 (INIT_EXPR, type, decl, init);\n-\n   array = AGGR_INIT_EXPR_ARG (aggr_init, 1);\n   arrtype = TREE_TYPE (array);\n   STRIP_NOPS (array);\n@@ -4549,12 +4548,10 @@ build_init_list_var_init (tree decl, tree type, tree init, tree *cleanup)\n      static variable and we don't need to do anything here.  */\n   if (decl && TREE_CODE (array) == TARGET_EXPR)\n     {\n-      tree subinit;\n-      tree var = set_up_extended_ref_temp (decl, array, cleanup, &subinit);\n+      tree var = set_up_extended_ref_temp (decl, array, cleanup, array_init);\n       var = build_address (var);\n       var = convert (arrtype, var);\n       AGGR_INIT_EXPR_ARG (aggr_init, 1) = var;\n-      init = build2 (COMPOUND_EXPR, TREE_TYPE (init), subinit, init);\n     }\n   return init;\n }\n@@ -5250,6 +5247,7 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n {\n   tree type = TREE_TYPE (decl);\n   tree init_code = NULL;\n+  tree extra_init = NULL_TREE;\n   tree core_type;\n \n   /* Things that are going to be initialized need to have complete\n@@ -5304,16 +5302,21 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n       gcc_assert (init != NULL_TREE);\n       init = NULL_TREE;\n     }\n-  else if (!DECL_EXTERNAL (decl) && TREE_CODE (type) == REFERENCE_TYPE)\n+  else if (!init && DECL_REALLY_EXTERN (decl))\n+    ;\n+  else if (TREE_CODE (type) == REFERENCE_TYPE)\n     init = grok_reference_init (decl, type, init, cleanup);\n-  else if (init)\n+  else if (init || TYPE_NEEDS_CONSTRUCTING (type))\n     {\n+      if (!init)\n+\tcheck_for_uninitialized_const_var (decl);\n       /* Do not reshape constructors of vectors (they don't need to be\n \t reshaped.  */\n-      if (BRACE_ENCLOSED_INITIALIZER_P (init))\n+      else if (BRACE_ENCLOSED_INITIALIZER_P (init))\n \t{\n \t  if (is_std_init_list (type))\n-\t    return build_init_list_var_init (decl, type, init, cleanup);\n+\t    init = build_init_list_var_init (decl, type, init,\n+\t\t\t\t\t     &extra_init, cleanup);\n \t  else if (TYPE_NON_AGGREGATE_CLASS (type))\n \t    {\n \t      /* Don't reshape if the class has constructors.  */\n@@ -5340,9 +5343,46 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n \n       if (TYPE_NEEDS_CONSTRUCTING (type)\n \t  || (CLASS_TYPE_P (type)\n-\t      && !BRACE_ENCLOSED_INITIALIZER_P (init)))\n-\treturn build_aggr_init_full_exprs (decl, init, flags);\n-      else if (TREE_CODE (init) != TREE_VEC)\n+\t      && !(init && BRACE_ENCLOSED_INITIALIZER_P (init))))\n+\t{\n+\t  init_code = build_aggr_init_full_exprs (decl, init, flags);\n+\n+\t  /* If this is a constexpr initializer, expand_default_init will\n+\t     have returned an INIT_EXPR rather than a CALL_EXPR.  In that\n+\t     case, pull the initializer back out and pass it down into\n+\t     store_init_value.  */\n+\t  while (TREE_CODE (init_code) == EXPR_STMT\n+\t\t || TREE_CODE (init_code) == CONVERT_EXPR)\n+\t    init_code = TREE_OPERAND (init_code, 0);\n+\t  if (TREE_CODE (init_code) == INIT_EXPR)\n+\t    {\n+\t      init = TREE_OPERAND (init_code, 1);\n+\t      init_code = NULL_TREE;\n+\t      /* Don't call digest_init; it's unnecessary and will complain\n+\t\t about aggregate initialization of non-aggregate classes.  */\n+\t      flags |= LOOKUP_ALREADY_DIGESTED;\n+\t    }\n+\t  else if (DECL_DECLARED_CONSTEXPR_P (decl))\n+\t    {\n+\t      /* Declared constexpr, but no suitable initializer; massage\n+\t\t init appropriately so we can pass it into store_init_value\n+\t\t for the error.  */\n+\t      if (init && BRACE_ENCLOSED_INITIALIZER_P (init))\n+\t\tinit = finish_compound_literal (type, init);\n+\t      else if (CLASS_TYPE_P (type)\n+\t\t       && (!init || TREE_CODE (init) == TREE_LIST))\n+\t\t{\n+\t\t  init = build_functional_cast (type, init, tf_none);\n+\t\t  if (init != error_mark_node)\n+\t\t    TARGET_EXPR_DIRECT_INIT_P (init) = true;\n+\t\t}\n+\t      init_code = NULL_TREE;\n+\t    }\n+\t  else\n+\t    init = NULL_TREE;\n+\t}\n+\n+      if (init && TREE_CODE (init) != TREE_VEC)\n \t{\n \t  init_code = store_init_value (decl, init, flags);\n \t  if (pedantic && TREE_CODE (type) == ARRAY_TYPE\n@@ -5354,28 +5394,39 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n \t  init = NULL;\n \t}\n     }\n-  else if (DECL_EXTERNAL (decl))\n-    ;\n-  else if (TYPE_P (type) && TYPE_NEEDS_CONSTRUCTING (type))\n-    {\n-      check_for_uninitialized_const_var (decl);\n-      return build_aggr_init_full_exprs (decl, init, flags);\n-    }\n-  else if (MAYBE_CLASS_TYPE_P (core_type = strip_array_types (type)))\n+  else\n     {\n-      if (CLASSTYPE_READONLY_FIELDS_NEED_INIT (core_type)\n-\t  || CLASSTYPE_REF_FIELDS_NEED_INIT (core_type))\n+      if (CLASS_TYPE_P (core_type = strip_array_types (type))\n+\t  && (CLASSTYPE_READONLY_FIELDS_NEED_INIT (core_type)\n+\t      || CLASSTYPE_REF_FIELDS_NEED_INIT (core_type)))\n \tdiagnose_uninitialized_cst_or_ref_member (core_type, /*using_new=*/false,\n \t\t\t\t\t\t  /*complain=*/true);\n \n       check_for_uninitialized_const_var (decl);\n     }\n-  else\n-    check_for_uninitialized_const_var (decl);\n \n   if (init && init != error_mark_node)\n     init_code = build2 (INIT_EXPR, type, decl, init);\n \n+  if (extra_init)\n+    init_code = add_stmt_to_compound (extra_init, init_code);\n+\n+  if (init_code && DECL_IN_AGGR_P (decl))\n+    {\n+      static int explained = 0;\n+\n+      if (cxx_dialect < cxx0x)\n+\terror (\"initializer invalid for static member with constructor\");\n+      else\n+\terror (\"non-constant in-class initialization invalid for static \"\n+\t       \"member %qD\", decl);\n+      if (!explained)\n+\t{\n+\t  error (\"(an out of class initialization is required)\");\n+\t  explained = 1;\n+\t}\n+    }\n+\n   return init_code;\n }\n \n@@ -5746,7 +5797,22 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t    DECL_INITIAL (decl) = NULL_TREE;\n \t}\n     }\n-    \n+\n+  if (init && TREE_CODE (decl) == VAR_DECL)\n+    {\n+      DECL_NONTRIVIALLY_INITIALIZED_P (decl) = 1;\n+      /* FIXME we rely on TREE_CONSTANT below; basing that on\n+\t init_const_expr_p is probably wrong for C++0x.  */\n+      if (init_const_expr_p)\n+\t{\n+\t  /* Set these flags now for C++98 templates.  We'll update the\n+\t     flags in store_init_value for instantiations and C++0x.  */\n+\t  DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl) = 1;\n+\t  if (decl_maybe_constant_var_p (decl))\n+\t    TREE_CONSTANT (decl) = 1;\n+\t}\n+    }\n+\n   if (processing_template_decl)\n     {\n       bool type_dependent_p;\n@@ -5763,22 +5829,16 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t  DECL_INITIAL (decl) = NULL_TREE;\n \t}\n \n-      if (init && init_const_expr_p && TREE_CODE (decl) == VAR_DECL)\n-\t{\n-\t  DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl) = 1;\n-\t  if (DECL_INTEGRAL_CONSTANT_VAR_P (decl))\n-\t    TREE_CONSTANT (decl) = 1;\n-\t}\n-\n       /* Generally, initializers in templates are expanded when the\n-\t template is instantiated.  But, if DECL is an integral\n-\t constant static data member, then it can be used in future\n-\t integral constant expressions, and its value must be\n-\t available. */\n+\t template is instantiated.  But, if DECL is a variable constant\n+\t then it can be used in future constant expressions, so its value\n+\t must be available. */\n       if (!(init\n \t    && DECL_CLASS_SCOPE_P (decl)\n-\t    && DECL_INTEGRAL_CONSTANT_VAR_P (decl)\n+\t    /* We just set TREE_CONSTANT appropriately; see above.  */\n+\t    && TREE_CONSTANT (decl)\n \t    && !type_dependent_p\n+\t    /* FIXME non-value-dependent constant expression  */\n \t    && !value_dependent_init_p (init)))\n \t{\n \t  if (init)\n@@ -5892,16 +5952,6 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t\terror (\"Java object %qD not allocated with %<new%>\", decl);\n \t      init = NULL_TREE;\n \t    }\n-\t  if (init)\n-\t    {\n-\t      DECL_NONTRIVIALLY_INITIALIZED_P (decl) = 1;\n-\t      if (init_const_expr_p)\n-\t\t{\n-\t\t  DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl) = 1;\n-\t\t  if (DECL_INTEGRAL_CONSTANT_VAR_P (decl))\n-\t\t    TREE_CONSTANT (decl) = 1;\n-\t\t}\n-\t    }\n \t  init = check_initializer (decl, init, flags, &cleanup);\n \t  /* Thread-local storage cannot be dynamically initialized.  */\n \t  if (DECL_THREAD_LOCAL_P (decl) && init)\n@@ -6407,9 +6457,8 @@ expand_static_init (tree decl, tree init)\n   gcc_assert (TREE_CODE (decl) == VAR_DECL);\n   gcc_assert (TREE_STATIC (decl));\n \n-  /* Some variables require no initialization.  */\n+  /* Some variables require no dynamic initialization.  */\n   if (!init\n-      && !TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl))\n       && TYPE_HAS_TRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n     return;\n \n@@ -7417,36 +7466,67 @@ check_static_variable_definition (tree decl, tree type)\n    name of the thing being declared.  */\n \n tree\n-compute_array_index_type (tree name, tree size)\n+compute_array_index_type (tree name, tree size, tsubst_flags_t complain)\n {\n   tree type;\n   tree itype;\n+  tree osize = size;\n   tree abi_1_itype = NULL_TREE;\n \n   if (error_operand_p (size))\n     return error_mark_node;\n \n   type = TREE_TYPE (size);\n-  /* The array bound must be an integer type.  */\n-  if (!dependent_type_p (type) && !INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (type))\n+  /* type_dependent_expression_p? */\n+  if (!dependent_type_p (type))\n     {\n-      if (name)\n-\terror (\"size of array %qD has non-integral type %qT\", name, type);\n+      mark_rvalue_use (size);\n+\n+      if (cxx_dialect < cxx0x && TREE_CODE (size) == NOP_EXPR\n+\t  && TREE_SIDE_EFFECTS (size))\n+\t/* In C++98, we mark a non-constant array bound with a magic\n+\t   NOP_EXPR with TREE_SIDE_EFFECTS; don't fold in that case.  */;\n       else\n-\terror (\"size of array has non-integral type %qT\", type);\n-      size = integer_one_node;\n-      type = TREE_TYPE (size);\n+\t{\n+\t  size = fold_non_dependent_expr (size);\n+\n+\t  if (CLASS_TYPE_P (type)\n+\t      && CLASSTYPE_LITERAL_P (type))\n+\t    {\n+\t      size = build_expr_type_conversion (WANT_INT, size, true);\n+\t      if (size == error_mark_node)\n+\t\treturn error_mark_node;\n+\t      type = TREE_TYPE (size);\n+\t    }\n+\n+\t  size = maybe_constant_value (size);\n+\t}\n+\n+      if (error_operand_p (size))\n+\treturn error_mark_node;\n+\n+      /* The array bound must be an integer type.  */\n+      if (!INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (type))\n+\t{\n+\t  if (!(complain & tf_error))\n+\t    return error_mark_node;\n+\t  if (name)\n+\t    error (\"size of array %qD has non-integral type %qT\", name, type);\n+\t  else\n+\t    error (\"size of array has non-integral type %qT\", type);\n+\t  size = integer_one_node;\n+\t  type = TREE_TYPE (size);\n+\t}\n     }\n \n   /* A type is dependent if it is...an array type constructed from any\n      dependent type or whose size is specified by a constant expression\n      that is value-dependent.  */\n   /* We can only call value_dependent_expression_p on integral constant\n-     expressions; the parser adds a dummy NOP_EXPR with TREE_SIDE_EFFECTS\n-     set if this isn't one.  */\n+     expressions; treat non-constant expressions as dependent, too.  */\n   if (processing_template_decl\n       && (dependent_type_p (type)\n-\t  || TREE_SIDE_EFFECTS (size) || value_dependent_expression_p (size)))\n+\t  || !TREE_CONSTANT (size) || value_dependent_expression_p (size)))\n     {\n       /* We cannot do any checking for a SIZE that isn't known to be\n \t constant. Just build the index type and mark that it requires\n@@ -7467,17 +7547,7 @@ compute_array_index_type (tree name, tree size)\n        would have, but with TYPE_CANONICAL set to the \"right\"\n        value that the current ABI would provide. */\n     abi_1_itype = build_index_type (build_min (MINUS_EXPR, sizetype,\n-\t\t\t\t\t       size, integer_one_node));\n-\n-  /* The size might be the result of a cast.  */\n-  STRIP_TYPE_NOPS (size);\n-\n-  size = mark_rvalue_use (size);\n-\n-  /* It might be a const variable or enumeration constant.  */\n-  size = integral_constant_value (size);\n-  if (error_operand_p (size))\n-    return error_mark_node;\n+\t\t\t\t\t       osize, integer_one_node));\n \n   /* Normally, the array-bound will be a constant.  */\n   if (TREE_CODE (size) == INTEGER_CST)\n@@ -7489,24 +7559,37 @@ compute_array_index_type (tree name, tree size)\n       /* An array must have a positive number of elements.  */\n       if (INT_CST_LT (size, integer_zero_node))\n \t{\n+\t  if (!(complain & tf_error))\n+\t    return error_mark_node;\n \t  if (name)\n \t    error (\"size of array %qD is negative\", name);\n \t  else\n \t    error (\"size of array is negative\");\n \t  size = integer_one_node;\n \t}\n-      /* As an extension we allow zero-sized arrays.  We always allow\n-\t them in system headers because glibc uses them.  */\n-      else if (integer_zerop (size) && !in_system_header)\n+      /* As an extension we allow zero-sized arrays.  */\n+      else if (integer_zerop (size))\n \t{\n-\t  if (name)\n+\t  if (!(complain & tf_error))\n+\t    /* We must fail if performing argument deduction (as\n+\t       indicated by the state of complain), so that\n+\t       another substitution can be found.  */\n+\t    return error_mark_node;\n+\t  else if (in_system_header)\n+\t    /* Allow them in system headers because glibc uses them.  */;\n+\t  else if (name)\n \t    pedwarn (input_location, OPT_pedantic, \"ISO C++ forbids zero-size array %qD\", name);\n \t  else\n \t    pedwarn (input_location, OPT_pedantic, \"ISO C++ forbids zero-size array\");\n \t}\n     }\n-  else if (TREE_CONSTANT (size))\n+  else if (TREE_CONSTANT (size)\n+\t   /* We don't allow VLAs at non-function scopes, or during\n+\t      tentative template substitution.  */\n+\t   || !at_function_scope_p () || !(complain & tf_error))\n     {\n+      if (!(complain & tf_error))\n+\treturn error_mark_node;\n       /* `(int) &fn' is not a valid array bound.  */\n       if (name)\n \terror (\"size of array %qD is not an integral constant-expression\",\n@@ -7562,6 +7645,8 @@ compute_array_index_type (tree name, tree size)\n       else if (TREE_CODE (itype) == INTEGER_CST\n \t       && TREE_OVERFLOW (itype))\n \t{\n+\t  if (!(complain & tf_error))\n+\t    return error_mark_node;\n \t  error (\"overflow in array dimension\");\n \t  TREE_OVERFLOW (itype) = 0;\n \t}\n@@ -7673,7 +7758,7 @@ create_array_type_for_decl (tree name, tree type, tree size)\n \n   /* Figure out the index type for the array.  */\n   if (size)\n-    itype = compute_array_index_type (name, size);\n+    itype = compute_array_index_type (name, size, tf_warning_or_error);\n \n   /* [dcl.array]\n      T is called the array element type; this type shall not be [...] an\n@@ -9411,7 +9496,8 @@ grokdeclarator (const cp_declarator *declarator,\n \tif (!staticp && TREE_CODE (type) == ARRAY_TYPE\n \t    && TYPE_DOMAIN (type) == NULL_TREE)\n \t  {\n-\t    tree itype = compute_array_index_type (dname, integer_zero_node);\n+\t    tree itype = compute_array_index_type (dname, integer_zero_node,\n+\t\t\t\t\t\t   tf_warning_or_error);\n \t    type = build_cplus_array_type (TREE_TYPE (type), itype);\n \t  }\n \n@@ -11732,7 +11818,7 @@ build_enumerator (tree name, tree value, tree enumtype, location_t loc)\n       /* Validate and default VALUE.  */\n       if (value != NULL_TREE)\n \t{\n-\t  value = integral_constant_value (value);\n+\t  value = cxx_constant_value (value);\n \n \t  if (TREE_CODE (value) == INTEGER_CST)\n \t    {"}, {"sha": "0003601823c4db29c2928db08d209649273553ba", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -923,8 +923,7 @@ grokfield (const cp_declarator *declarator,\n \t{\n \t  if (TREE_CODE (init) == CONSTRUCTOR)\n \t    init = digest_init (TREE_TYPE (value), init);\n-\t  else\n-\t    init = integral_constant_value (init);\n+\t  init = maybe_constant_init (init);\n \n \t  if (init != error_mark_node && !TREE_CONSTANT (init))\n \t    {"}, {"sha": "f02096ed122cc056e346c39343215ade393ad181", "filename": "gcc/cp/except.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -1054,15 +1054,20 @@ check_noexcept_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n \n       STRIP_NOPS (fn);\n       if (TREE_CODE (fn) == ADDR_EXPR)\n+\tfn = TREE_OPERAND (fn, 0);\n+      if (TREE_CODE (fn) == FUNCTION_DECL)\n \t{\n \t  /* We do use TREE_NOTHROW for ABI internals like __dynamic_cast,\n \t     and for C library functions known not to throw.  */\n-\t  fn = TREE_OPERAND (fn, 0);\n-\t  if (TREE_CODE (fn) == FUNCTION_DECL\n-\t      && DECL_EXTERN_C_P (fn)\n+\t  if (DECL_EXTERN_C_P (fn)\n \t      && (DECL_ARTIFICIAL (fn)\n \t\t  || nothrow_libfn_p (fn)))\n \t    return TREE_NOTHROW (fn) ? NULL_TREE : fn;\n+\t  /* A call to a constexpr function is noexcept if the call\n+\t     is a constant expression.  */\n+\t  if (DECL_DECLARED_CONSTEXPR_P (fn)\n+\t      && is_sub_constant_expr (t))\n+\t    return NULL_TREE;\n \t}\n       if (!TYPE_NOTHROW_P (type))\n \treturn fn;\n@@ -1195,9 +1200,15 @@ type_throw_all_p (const_tree type)\n tree\n build_noexcept_spec (tree expr, int complain)\n {\n-  expr = perform_implicit_conversion_flags (boolean_type_node, expr,\n-\t\t\t\t\t    complain,\n-\t\t\t\t\t    LOOKUP_NORMAL);\n+  /* This isn't part of the signature, so don't bother trying to evaluate\n+     it until instantiation.  */\n+  if (!processing_template_decl)\n+    {\n+      expr = cxx_constant_value (expr);\n+      expr = perform_implicit_conversion_flags (boolean_type_node, expr,\n+\t\t\t\t\t\tcomplain,\n+\t\t\t\t\t\tLOOKUP_NORMAL);\n+    }\n   if (expr == boolean_true_node)\n     return noexcept_true_spec;\n   else if (expr == boolean_false_node)"}, {"sha": "d632816c654c1a54b1dff36b987b3c9096f99216", "filename": "gcc/cp/init.c", "status": "modified", "additions": 93, "deletions": 34, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -1440,8 +1440,20 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags,\n   if (parms != NULL)\n     release_tree_vector (parms);\n \n+  if (exp == true_exp && TREE_CODE (rval) == CALL_EXPR)\n+    {\n+      tree fn = get_callee_fndecl (rval);\n+      if (DECL_DECLARED_CONSTEXPR_P (fn))\n+\t{\n+\t  tree e = maybe_constant_value (rval);\n+\t  if (TREE_CONSTANT (e))\n+\t    rval = build2 (INIT_EXPR, type, exp, e);\n+\t}\n+    }\n+\n+  /* FIXME put back convert_to_void?  */\n   if (TREE_SIDE_EFFECTS (rval))\n-    finish_expr_stmt (convert_to_void (rval, ICV_CAST, complain));\n+    finish_expr_stmt (rval);\n }\n \n /* This function is responsible for initializing EXP with INIT\n@@ -1708,36 +1720,18 @@ constant_value_1 (tree decl, bool integral_p)\n {\n   while (TREE_CODE (decl) == CONST_DECL\n \t || (integral_p\n-\t     ? DECL_INTEGRAL_CONSTANT_VAR_P (decl)\n+\t     ? decl_constant_var_p (decl)\n \t     : (TREE_CODE (decl) == VAR_DECL\n \t\t&& CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (decl)))))\n     {\n       tree init;\n-      /* Static data members in template classes may have\n-\t non-dependent initializers.  References to such non-static\n-\t data members are not value-dependent, so we must retrieve the\n-\t initializer here.  The DECL_INITIAL will have the right type,\n-\t but will not have been folded because that would prevent us\n-\t from performing all appropriate semantic checks at\n-\t instantiation time.  */\n-      if (DECL_CLASS_SCOPE_P (decl)\n-\t  && CLASSTYPE_TEMPLATE_INFO (DECL_CONTEXT (decl))\n-\t  && uses_template_parms (CLASSTYPE_TI_ARGS\n-\t\t\t\t  (DECL_CONTEXT (decl))))\n-\t{\n-\t  ++processing_template_decl;\n-\t  init = fold_non_dependent_expr (DECL_INITIAL (decl));\n-\t  --processing_template_decl;\n-\t}\n-      else\n-\t{\n-\t  /* If DECL is a static data member in a template\n-\t     specialization, we must instantiate it here.  The\n-\t     initializer for the static data member is not processed\n-\t     until needed; we need it now.  */\n-\t  mark_used (decl);\n-\t  init = DECL_INITIAL (decl);\n-\t}\n+      /* If DECL is a static data member in a template\n+\t specialization, we must instantiate it here.  The\n+\t initializer for the static data member is not processed\n+\t until needed; we need it now.  */\n+      mark_used (decl);\n+      mark_rvalue_use (decl);\n+      init = DECL_INITIAL (decl);\n       if (init == error_mark_node)\n \t{\n \t  if (DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl))\n@@ -1758,8 +1752,9 @@ constant_value_1 (tree decl, bool integral_p)\n \tinit = TREE_VALUE (init);\n       if (!init\n \t  || !TREE_TYPE (init)\n+\t  || uses_template_parms (init)\n \t  || (integral_p\n-\t      ? !INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (init))\n+\t      ? false\n \t      : (!TREE_CONSTANT (init)\n \t\t /* Do not return an aggregate constant (of which\n \t\t    string literals are a special case), as we do not\n@@ -2302,7 +2297,7 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n \t      tree arraytype, domain;\n \t      vecinit = VEC_index (tree, *init, 0);\n \t      if (TREE_CONSTANT (nelts))\n-\t\tdomain = compute_array_index_type (NULL_TREE, nelts);\n+\t\tdomain = compute_array_index_type (NULL_TREE, nelts, complain);\n \t      else\n \t\t{\n \t\t  domain = NULL_TREE;\n@@ -2878,6 +2873,8 @@ build_vec_init (tree base, tree maxindex, tree init,\n   tree try_block = NULL_TREE;\n   int num_initialized_elts = 0;\n   bool is_global;\n+  tree const_init = NULL_TREE;\n+  tree obase = base;\n   bool xvalue = false;\n \n   if (TREE_CODE (atype) == ARRAY_TYPE && TYPE_DOMAIN (atype))\n@@ -2986,26 +2983,75 @@ build_vec_init (tree base, tree maxindex, tree init,\n       try_block = begin_try_block ();\n     }\n \n+  /* Maybe pull out constant value when from_array? */\n+\n   if (init != NULL_TREE && TREE_CODE (init) == CONSTRUCTOR)\n     {\n       /* Do non-default initialization of non-trivial arrays resulting from\n \t brace-enclosed initializers.  */\n       unsigned HOST_WIDE_INT idx;\n-      tree elt;\n+      tree field, elt;\n+      /* Should we try to create a constant initializer?  */\n+      bool try_const = (literal_type_p (inner_elt_type)\n+\t\t\t|| TYPE_HAS_CONSTEXPR_CTOR (inner_elt_type));\n+      bool saw_non_const = false;\n+      bool saw_const = false;\n+      /* If we're initializing a static array, we want to do static\n+\t initialization of any elements with constant initializers even if\n+\t some are non-constant.  */\n+      bool do_static_init = (DECL_P (obase) && TREE_STATIC (obase));\n+      VEC(constructor_elt,gc) *new_vec;\n       from_array = 0;\n \n-      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (init), idx, elt)\n+      if (try_const)\n+\tnew_vec = VEC_alloc (constructor_elt, gc, CONSTRUCTOR_NELTS (init));\n+      else\n+\tnew_vec = NULL;\n+\n+      FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (init), idx, field, elt)\n \t{\n \t  tree baseref = build1 (INDIRECT_REF, type, base);\n+\t  tree one_init;\n \n \t  num_initialized_elts++;\n \n \t  current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n \t  if (MAYBE_CLASS_TYPE_P (type) || TREE_CODE (type) == ARRAY_TYPE)\n-\t    finish_expr_stmt (build_aggr_init (baseref, elt, 0, complain));\n+\t    one_init = build_aggr_init (baseref, elt, 0, complain);\n \t  else\n-\t    finish_expr_stmt (cp_build_modify_expr (baseref, NOP_EXPR,\n-                                                    elt, complain));\n+\t    one_init = cp_build_modify_expr (baseref, NOP_EXPR,\n+\t\t\t\t\t     elt, complain);\n+\n+\t  if (try_const)\n+\t    {\n+\t      tree e = one_init;\n+\t      if (TREE_CODE (e) == EXPR_STMT)\n+\t\te = TREE_OPERAND (e, 0);\n+\t      if (TREE_CODE (e) == CONVERT_EXPR\n+\t\t  && VOID_TYPE_P (TREE_TYPE (e)))\n+\t\te = TREE_OPERAND (e, 0);\n+\t      e = maybe_constant_init (e);\n+\t      if (reduced_constant_expression_p (e))\n+\t\t{\n+\t\t  CONSTRUCTOR_APPEND_ELT (new_vec, field, e);\n+\t\t  if (do_static_init)\n+\t\t    one_init = NULL_TREE;\n+\t\t  else\n+\t\t    one_init = build2 (INIT_EXPR, type, baseref, e);\n+\t\t  saw_const = true;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (do_static_init)\n+\t\t    CONSTRUCTOR_APPEND_ELT (new_vec, field,\n+\t\t\t\t\t    build_zero_init (TREE_TYPE (e),\n+\t\t\t\t\t\t\t     NULL_TREE, true));\n+\t\t  saw_non_const = true;\n+\t\t}\n+\t    }\n+\n+\t  if (one_init)\n+\t    finish_expr_stmt (one_init);\n \t  current_stmt_tree ()->stmts_are_full_exprs_p = 0;\n \n \t  finish_expr_stmt (cp_build_unary_op (PREINCREMENT_EXPR, base, 0,\n@@ -3014,6 +3060,16 @@ build_vec_init (tree base, tree maxindex, tree init,\n                                                complain));\n \t}\n \n+      if (try_const)\n+\t{\n+\t  if (!saw_non_const)\n+\t    const_init = build_constructor (atype, new_vec);\n+\t  else if (do_static_init && saw_const)\n+\t    DECL_INITIAL (obase) = build_constructor (atype, new_vec);\n+\t  else\n+\t    VEC_free (constructor_elt, gc, new_vec);\n+\t}\n+\n       /* Clear out INIT so that we don't get confused below.  */\n       init = NULL_TREE;\n     }\n@@ -3161,6 +3217,9 @@ build_vec_init (tree base, tree maxindex, tree init,\n     }\n \n   current_stmt_tree ()->stmts_are_full_exprs_p = destroy_temps;\n+\n+  if (const_init)\n+    return build2 (INIT_EXPR, atype, obase, const_init);\n   return stmt_expr;\n }\n "}, {"sha": "90277603eebb070b519714d7a2458a470b0e15ed", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -7176,7 +7176,8 @@ cp_parser_constant_expression (cp_parser* parser,\n   saved_non_integral_constant_expression_p = parser->non_integral_constant_expression_p;\n   /* We are now parsing a constant-expression.  */\n   parser->integral_constant_expression_p = true;\n-  parser->allow_non_integral_constant_expression_p = allow_non_constant_p;\n+  parser->allow_non_integral_constant_expression_p\n+    = (allow_non_constant_p || cxx_dialect >= cxx0x);\n   parser->non_integral_constant_expression_p = false;\n   /* Although the grammar says \"conditional-expression\", we parse an\n      \"assignment-expression\", which also permits \"throw-expression\"\n@@ -7195,7 +7196,8 @@ cp_parser_constant_expression (cp_parser* parser,\n     = saved_allow_non_integral_constant_expression_p;\n   if (allow_non_constant_p)\n     *non_constant_p = parser->non_integral_constant_expression_p;\n-  else if (parser->non_integral_constant_expression_p)\n+  else if (parser->non_integral_constant_expression_p\n+\t   && cxx_dialect < cxx0x)\n     expression = error_mark_node;\n   parser->non_integral_constant_expression_p\n     = saved_non_integral_constant_expression_p;\n@@ -14975,8 +14977,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t= cp_parser_constant_expression (parser,\n \t\t\t\t\t\t /*allow_non_constant=*/true,\n \t\t\t\t\t\t &non_constant_p);\n-\t      if (!non_constant_p)\n-\t\tbounds = fold_non_dependent_expr (bounds);\n+\t      if (!non_constant_p || cxx_dialect >= cxx0x)\n+\t\t/* OK */;\n \t      /* Normally, the array bound must be an integral constant\n \t\t expression.  However, as an extension, we allow VLAs\n \t\t in function scopes as long as they aren't part of a\n@@ -16408,7 +16410,15 @@ cp_parser_initializer_clause (cp_parser* parser, bool* non_constant_p)\n \t\t\t\t\t/*allow_non_constant_p=*/true,\n \t\t\t\t\tnon_constant_p);\n       if (!*non_constant_p)\n-\tinitializer = fold_non_dependent_expr (initializer);\n+\t{\n+\t  /* We only want to fold if this is really a constant\n+\t     expression.  FIXME Actually, we don't want to fold here, but in\n+\t     cp_finish_decl.  */\n+\t  tree folded = fold_non_dependent_expr (initializer);\n+\t  folded = maybe_constant_value (folded);\n+\t  if (TREE_CONSTANT (folded))\n+\t    initializer = folded;\n+\t}\n     }\n   else\n     initializer = cp_parser_braced_list (parser, non_constant_p);"}, {"sha": "d3c1c1ce8a31449d53d44f7ee72d4e9d8fc4b36a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 71, "deletions": 79, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -4845,29 +4845,6 @@ fold_non_dependent_expr (tree expr)\n   return fold_non_dependent_expr_sfinae (expr, tf_error);\n }\n \n-/* EXPR is an expression which is used in a constant-expression context.\n-   For instance, it could be a VAR_DECL with a constant initializer.\n-   Extract the innermost constant expression.\n-\n-   This is basically a more powerful version of\n-   integral_constant_value, which can be used also in templates where\n-   initializers can maintain a syntactic rather than semantic form\n-   (even if they are non-dependent, for access-checking purposes).  */\n-\n-static tree\n-fold_decl_constant_value (tree expr)\n-{\n-  tree const_expr = expr;\n-  do\n-    {\n-      expr = fold_non_dependent_expr (const_expr);\n-      const_expr = integral_constant_value (expr);\n-    }\n-  while (expr != const_expr);\n-\n-  return expr;\n-}\n-\n /* Subroutine of convert_nontype_argument. Converts EXPR to TYPE, which\n    must be a function or a pointer-to-function type, as specified\n    in [temp.arg.nontype]: disambiguate EXPR if it is an overload set,\n@@ -5069,23 +5046,23 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n   if (INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n     {\n       tree t = build_integral_nontype_arg_conv (type, expr, complain);\n-      t = fold_decl_constant_value (t);\n+      t = maybe_constant_value (t);\n       if (t != error_mark_node)\n \texpr = t;\n \n       if (!same_type_ignoring_top_level_qualifiers_p (type, TREE_TYPE (expr)))\n \treturn error_mark_node;\n \n-      /* Conversion was allowed: fold it to a bare integer constant.  */\n-      expr = fold (expr);\n-\n       /* Notice that there are constant expressions like '4 % 0' which\n \t do not fold into integer constants.  */\n       if (TREE_CODE (expr) != INTEGER_CST)\n \t{\n \t  if (complain & tf_error)\n-\t    error (\"%qE is not a valid template argument for type %qT \"\n-\t\t   \"because it is a non-constant expression\", expr, type);\n+\t    {\n+\t      error (\"%qE is not a valid template argument for type %qT \"\n+\t\t     \"because it is a non-constant expression\", expr, type);\n+\t      cxx_constant_value (expr);\n+\t    }\n \t  return NULL_TREE;\n \t}\n     }\n@@ -9637,8 +9614,9 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t\tRETURN (error_mark_node);\n \t      }\n \t    type = complete_type (type);\n-\t    DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (r)\n-\t      = DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (t);\n+\t    /* Wait until cp_finish_decl to set this again, to handle\n+\t       circular dependency (template/instantiate6.C). */\n+\t    DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (r) = 0;\n \t    type = check_var_type (DECL_NAME (r), type);\n \n \t    if (DECL_HAS_VALUE_EXPR_P (t))\n@@ -10125,9 +10103,6 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    && !TREE_TYPE (max))\n \t  TREE_TYPE (max) = TREE_TYPE (TREE_OPERAND (max, 0));\n \n-\tmax = mark_rvalue_use (max);\n-\tmax = fold_decl_constant_value (max);\n-\n \t/* If we're in a partial instantiation, preserve the magic NOP_EXPR\n \t   with TREE_SIDE_EFFECTS that indicates this is not an integral\n \t   constant expression.  */\n@@ -10138,38 +10113,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    TREE_SIDE_EFFECTS (max) = 1;\n \t  }\n \n-\tif (TREE_CODE (max) != INTEGER_CST\n-\t    && !at_function_scope_p ()\n-\t    && !TREE_SIDE_EFFECTS (max)\n-\t    && !value_dependent_expression_p (max))\n-\t  {\n-\t    if (complain & tf_error)\n-\t      error (\"array bound is not an integer constant\");\n-\t    return error_mark_node;\n-\t  }\n-\n-\t/* [temp.deduct]\n-\n-\t   Type deduction may fail for any of the following\n-\t   reasons:\n-\n-\t     Attempting to create an array with a size that is\n-\t     zero or negative.  */\n-\tif (integer_zerop (max) && !(complain & tf_error))\n-\t  /* We must fail if performing argument deduction (as\n-\t     indicated by the state of complain), so that\n-\t     another substitution can be found.  */\n-\t  return error_mark_node;\n-\telse if (TREE_CODE (max) == INTEGER_CST\n-\t\t && INT_CST_LT (max, integer_zero_node))\n-\t  {\n-\t    if (complain & tf_error)\n-\t      error (\"creating array with negative size (%qE)\", max);\n-\n-\t    return error_mark_node;\n-\t  }\n-\n-\treturn compute_array_index_type (NULL_TREE, max);\n+\treturn compute_array_index_type (NULL_TREE, max, complain);\n       }\n \n     case TEMPLATE_TYPE_PARM:\n@@ -11658,10 +11602,10 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \n     case DECL_EXPR:\n       {\n-\ttree decl;\n+\ttree decl, pattern_decl;\n \ttree init;\n \n-\tdecl = DECL_EXPR_DECL (t);\n+\tpattern_decl = decl = DECL_EXPR_DECL (t);\n \tif (TREE_CODE (decl) == LABEL_DECL)\n \t  finish_label_decl (DECL_NAME (decl));\n \telse if (TREE_CODE (decl) == USING_DECL)\n@@ -11698,6 +11642,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t\t  finish_anon_union (decl);\n \t\telse\n \t\t  {\n+\t\t    int const_init = false;\n \t\t    maybe_push_decl (decl);\n \t\t    if (TREE_CODE (decl) == VAR_DECL\n \t\t\t&& DECL_PRETTY_FUNCTION_P (decl))\n@@ -11730,7 +11675,10 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t\t\t  init = t;\n \t\t      }\n \n-\t\t    cp_finish_decl (decl, init, false, NULL_TREE, 0);\n+\t\t    if (TREE_CODE (decl) == VAR_DECL)\n+\t\t      const_init = (DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P\n+\t\t\t\t    (pattern_decl));\n+\t\t    cp_finish_decl (decl, init, const_init, NULL_TREE, 0);\n \t\t  }\n \t      }\n \t  }\n@@ -16894,6 +16842,7 @@ instantiate_decl (tree d, int defer_ok,\n \t{\n \t  tree ns;\n \t  tree init;\n+\t  bool const_init = false;\n \n \t  ns = decl_namespace_context (d);\n \t  push_nested_namespace (ns);\n@@ -16902,7 +16851,11 @@ instantiate_decl (tree d, int defer_ok,\n \t\t\t      args,\n \t\t\t      tf_warning_or_error, NULL_TREE,\n \t\t\t      /*integral_constant_expression_p=*/false);\n-\t  cp_finish_decl (d, init, /*init_const_expr_p=*/false,\n+\t  /* Make sure the initializer is still constant, in case of\n+\t     circular dependency (template/instantiate6.C). */\n+\t  const_init\n+\t    = DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (code_pattern);\n+\t  cp_finish_decl (d, init, /*init_const_expr_p=*/const_init,\n \t\t\t  /*asmspec_tree=*/NULL_TREE,\n \t\t\t  LOOKUP_ONLYCONVERTING);\n \t  pop_nested_class ();\n@@ -16973,14 +16926,16 @@ instantiate_decl (tree d, int defer_ok,\n   if (TREE_CODE (d) == VAR_DECL)\n     {\n       tree init;\n+      bool const_init = false;\n \n       /* Clear out DECL_RTL; whatever was there before may not be right\n \t since we've reset the type of the declaration.  */\n       SET_DECL_RTL (d, NULL);\n       DECL_IN_AGGR_P (d) = 0;\n \n       /* The initializer is placed in DECL_INITIAL by\n-\t regenerate_decl_from_template.  Pull it out so that\n+\t regenerate_decl_from_template so we don't need to\n+\t push/pop_access_scope again here.  Pull it out so that\n \t cp_finish_decl can process it.  */\n       init = DECL_INITIAL (d);\n       DECL_INITIAL (d) = NULL_TREE;\n@@ -16993,7 +16948,8 @@ instantiate_decl (tree d, int defer_ok,\n \n       /* Enter the scope of D so that access-checking works correctly.  */\n       push_nested_class (DECL_CONTEXT (d));\n-      cp_finish_decl (d, init, false, NULL_TREE, 0);\n+      const_init = DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (code_pattern);\n+      cp_finish_decl (d, init, const_init, NULL_TREE, 0);\n       pop_nested_class ();\n     }\n   else if (TREE_CODE (d) == FUNCTION_DECL)\n@@ -17633,6 +17589,23 @@ dependent_scope_p (tree scope)\n    [temp.dep.constexpr].  EXPRESSION is already known to be a constant\n    expression.  */\n \n+/* FIXME this predicate is not appropriate for general expressions; the\n+   predicates we want instead are \"valid constant expression, value\n+   dependent or not?\", \"really constant expression, not value dependent?\"\n+   and \"instantiation-dependent?\".  Try to integrate with\n+   potential_constant_expression?\n+\n+   fold_non_dependent_expr: fold if constant and not type-dependent and not value-dependent.\n+     (what about instantiation-dependent constant-expressions?)\n+   is_late_template_attribute: defer if instantiation-dependent.\n+   compute_array_index_type: proceed if constant and not t- or v-dependent\n+     if instantiation-dependent, need to remember full expression\n+   uses_template_parms: FIXME - need to audit callers\n+   tsubst_decl [function_decl]: Why is this using value_dependent_expression_p?\n+   dependent_type_p [array_type]: dependent if index type is dependent\n+     (or non-constant?)\n+   static_assert - instantiation-dependent */\n+\n bool\n value_dependent_expression_p (tree expression)\n {\n@@ -17689,7 +17662,8 @@ value_dependent_expression_p (tree expression)\n \t    /* If there are no operands, it must be an expression such\n \t       as \"int()\". This should not happen for aggregate types\n \t       because it would form non-constant expressions.  */\n-\t    gcc_assert (INTEGRAL_OR_ENUMERATION_TYPE_P (type));\n+\t    gcc_assert (cxx_dialect >= cxx0x\n+\t\t\t|| INTEGRAL_OR_ENUMERATION_TYPE_P (type));\n \n \t    return false;\n \t  }\n@@ -17733,12 +17707,6 @@ value_dependent_expression_p (tree expression)\n       return (value_dependent_expression_p (TREE_OPERAND (expression, 0))\n \t      || value_dependent_expression_p (TREE_OPERAND (expression, 1)));\n \n-    case CALL_EXPR:\n-      /* A CALL_EXPR may appear in a constant expression if it is a\n-\t call to a builtin function, e.g., __builtin_constant_p.  All\n-\t such calls are value-dependent.  */\n-      return true;\n-\n     case NONTYPE_ARGUMENT_PACK:\n       /* A NONTYPE_ARGUMENT_PACK is value-dependent if any packed argument\n          is value-dependent.  */\n@@ -17771,6 +17739,30 @@ value_dependent_expression_p (tree expression)\n \t\t|| has_value_dependent_address (op));\n       }\n \n+    case CALL_EXPR:\n+      {\n+\ttree fn = get_callee_fndecl (expression);\n+\tint i, nargs;\n+\tif (!fn && value_dependent_expression_p (CALL_EXPR_FN (expression)))\n+\t  return true;\n+\tnargs = call_expr_nargs (expression);\n+\tfor (i = 0; i < nargs; ++i)\n+\t  {\n+\t    tree op = CALL_EXPR_ARG (expression, i);\n+\t    /* In a call to a constexpr member function, look through the\n+\t       implicit ADDR_EXPR on the object argument so that it doesn't\n+\t       cause the call to be considered value-dependent.  We also\n+\t       look through it in potential_constant_expression.  */\n+\t    if (i == 0 && fn && DECL_DECLARED_CONSTEXPR_P (fn)\n+\t\t&& DECL_NONSTATIC_MEMBER_FUNCTION_P (fn)\n+\t\t&& TREE_CODE (op) == ADDR_EXPR)\n+\t      op = TREE_OPERAND (op, 0);\n+\t    if (value_dependent_expression_p (op))\n+\t      return true;\n+\t  }\n+\treturn false;\n+      }\n+\n     default:\n       /* A constant expression is value-dependent if any subexpression is\n \t value-dependent.  */"}, {"sha": "709e44cb94835db5e4bf4d2eb7ba474dd7564e21", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -328,6 +328,8 @@ build_typeid (tree exp)\n   if (processing_template_decl)\n     return build_min (TYPEID_EXPR, const_type_info_type_node, exp);\n \n+  /* FIXME when integrating with c_fully_fold, mark\n+     resolves_to_fixed_type_p case as a non-constant expression.  */\n   if (TREE_CODE (exp) == INDIRECT_REF\n       && TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == POINTER_TYPE\n       && TYPE_POLYMORPHIC_P (TREE_TYPE (exp))"}, {"sha": "397d383f650e45a2a4eb3316f77d253238f6e170", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -4618,6 +4618,7 @@ finish_static_assert (tree condition, tree message, location_t location,\n   /* Fold the expression and convert it to a boolean value. */\n   condition = fold_non_dependent_expr (condition);\n   condition = cp_convert (boolean_type_node, condition);\n+  condition = maybe_constant_value (condition);\n \n   if (TREE_CODE (condition) == INTEGER_CST && !integer_zerop (condition))\n     /* Do nothing; the condition is satisfied. */\n@@ -4632,7 +4633,10 @@ finish_static_assert (tree condition, tree message, location_t location,\n         /* Report the error. */\n         error (\"static assertion failed: %E\", message);\n       else if (condition && condition != error_mark_node)\n-        error (\"non-constant condition for static assertion\");\n+\t{\n+\t  error (\"non-constant condition for static assertion\");\n+\t  cxx_constant_value (condition);\n+\t}\n       input_location = saved_loc;\n     }\n }\n@@ -5273,7 +5277,9 @@ ensure_literal_type_for_constexpr_object (tree decl)\n {\n   tree type = TREE_TYPE (decl);\n   if (TREE_CODE (decl) == VAR_DECL && DECL_DECLARED_CONSTEXPR_P (decl)\n-      && !processing_template_decl && !literal_type_p (type))\n+      && !processing_template_decl\n+      /* The call to complete_type is just for initializer_list.  */\n+      && !literal_type_p (complete_type (type)))\n     {\n       error (\"the type %qT of constexpr variable %qD is not literal\",\n              type, decl);\n@@ -6837,6 +6843,17 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant)\n     return r;\n }\n \n+/* Returns true if T is a valid subexpression of a constant expression,\n+   even if it isn't itself a constant expression.  */\n+\n+bool\n+is_sub_constant_expr (tree t)\n+{\n+  bool non_constant_p = false;\n+  cxx_eval_constant_expression (NULL, t, true, false, &non_constant_p);\n+  return !non_constant_p;\n+}\n+\n /* If T represents a constant expression returns its reduced value.\n    Otherwise return error_mark_node.  If T is dependent, then\n    return NULL.  */\n@@ -7257,7 +7274,7 @@ potential_constant_expression (tree t, tsubst_flags_t flags)\n     case TRUNC_MOD_EXPR:\n     case CEIL_MOD_EXPR:\n     case ROUND_MOD_EXPR:\n-      if (integer_zerop (decl_constant_value (TREE_OPERAND (t, 1))))\n+      if (integer_zerop (maybe_constant_value (TREE_OPERAND (t, 1))))\n \treturn false;\n       else\n \tgoto binary;"}, {"sha": "e55b5bc6f2a50f608ebb889633d1bfa49785fe00", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -3235,6 +3235,7 @@ bool\n cast_valid_in_integral_constant_expression_p (tree type)\n {\n   return (INTEGRAL_OR_ENUMERATION_TYPE_P (type)\n+\t  || cxx_dialect >= cxx0x\n \t  || dependent_type_p (type)\n \t  || type == error_mark_node);\n }"}, {"sha": "0da32786e05b577af505679eb9b00d71487396cc", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -1930,6 +1930,9 @@ decay_conversion (tree exp)\n       return error_mark_node;\n     }\n \n+  /* FIXME remove? at least need to remember that this isn't really a\n+     constant expression if EXP isn't decl_constant_var_p, like with\n+     C_MAYBE_CONST_EXPR.  */\n   exp = decl_constant_value (exp);\n   if (error_operand_p (exp))\n     return error_mark_node;"}, {"sha": "f1bd16e290c35916a1690c63283c9fd9162c0fd5", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -714,9 +714,6 @@ store_init_value (tree decl, tree init, int flags)\n \n   if (MAYBE_CLASS_TYPE_P (type))\n     {\n-      gcc_assert (!type_has_nontrivial_copy_init (type)\n-\t\t  || TREE_CODE (init) == CONSTRUCTOR);\n-\n       if (TREE_CODE (init) == TREE_LIST)\n \t{\n \t  error (\"constructor syntax used, but no constructor declared \"\n@@ -743,8 +740,32 @@ store_init_value (tree decl, tree init, int flags)\n \n   /* End of special C++ code.  */\n \n-  /* Digest the specified initializer into an expression.  */\n-  value = digest_init_flags (type, init, flags);\n+  if (flags & LOOKUP_ALREADY_DIGESTED)\n+    value = init;\n+  else\n+    /* Digest the specified initializer into an expression.  */\n+    value = digest_init_flags (type, init, flags);\n+\n+  /* In C++0x constant expression is a semantic, not syntactic, property.\n+     In C++98, make sure that what we thought was a constant expression at\n+     template definition time is still constant.  */\n+  if ((cxx_dialect >= cxx0x\n+       || DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl))\n+      && (decl_maybe_constant_var_p (decl)\n+\t  || TREE_STATIC (decl)))\n+    {\n+      bool const_init;\n+      value = fold_non_dependent_expr (value);\n+      value = maybe_constant_init (value);\n+      if (DECL_DECLARED_CONSTEXPR_P (decl))\n+\t/* Diagnose a non-constant initializer for constexpr.  */\n+\tvalue = cxx_constant_value (value);\n+      const_init = (reduced_constant_expression_p (value)\n+\t\t    || error_operand_p (value));\n+      DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl) = const_init;\n+      TREE_CONSTANT (decl) = const_init && decl_maybe_constant_var_p (decl);\n+    }\n+\n   /* If the initializer is not a constant, fill in DECL_INITIAL with\n      the bits that are constant, and then return an expression that\n      will perform the dynamic initialization.  */\n@@ -769,8 +790,7 @@ check_narrowing (tree type, tree init)\n   bool ok = true;\n   REAL_VALUE_TYPE d;\n \n-  if (DECL_P (init))\n-    init = decl_constant_value (init);\n+  init = maybe_constant_value (init);\n \n   if (TREE_CODE (type) == INTEGER_TYPE\n       && TREE_CODE (ftype) == REAL_TYPE)\n@@ -1632,7 +1652,11 @@ build_functional_cast (tree exp, tree parms, tsubst_flags_t complain)\n       && !TYPE_HAS_USER_CONSTRUCTOR (type))\n     {\n       exp = build_value_init (type, complain);\n-      return get_target_expr (exp);\n+      exp = get_target_expr (exp);\n+      /* FIXME this is wrong */\n+      if (literal_type_p (type))\n+\tTREE_CONSTANT (exp) = true;\n+      return exp;\n     }\n \n   /* Call the constructor.  */"}, {"sha": "90aca237f339a9b83a55e97d681cbd0fb60643aa", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -1,4 +1,82 @@\n 2010-11-01  Jason Merrill  <jason@redhat.com>\n+\t    Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* g++.dg/cpp0x/constexpr-array-ptr.C: New.\n+\t* g++.dg/cpp0x/constexpr-array-ptr2.C: New.\n+\t* g++.dg/cpp0x/constexpr-array-ptr3.C: New.\n+\t* g++.dg/cpp0x/constexpr-array-ptr4.C: New.\n+\t* g++.dg/cpp0x/constexpr-array-ptr5.C: New.\n+\t* g++.dg/cpp0x/constexpr-array-ptr6.C: New.\n+\t* g++.dg/cpp0x/constexpr-array.C: New.\n+\t* g++.dg/cpp0x/constexpr-base.C: New.\n+\t* g++.dg/cpp0x/constexpr-complex.C: New.\n+\t* g++.dg/cpp0x/constexpr-data1.C: New.\n+\t* g++.dg/cpp0x/constexpr-data2.C: New.\n+\t* g++.dg/cpp0x/constexpr-deref.C: New.\n+\t* g++.dg/cpp0x/constexpr-diag1.C: New.\n+\t* g++.dg/cpp0x/constexpr-eh-spec.C: New.\n+\t* g++.dg/cpp0x/constexpr-ellipsis.C: New.\n+\t* g++.dg/cpp0x/constexpr-ellipsis2.C: New.\n+\t* g++.dg/cpp0x/constexpr-empty.C: New.\n+\t* g++.dg/cpp0x/constexpr-empty2.C: New.\n+\t* g++.dg/cpp0x/constexpr-empty3.C: New.\n+\t* g++.dg/cpp0x/constexpr-empty4.C: New.\n+\t* g++.dg/cpp0x/constexpr-empty5.C: New.\n+\t* g++.dg/cpp0x/constexpr-ex1.C: New.\n+\t* g++.dg/cpp0x/constexpr-ex2.C: New.\n+\t* g++.dg/cpp0x/constexpr-ex3.C: New.\n+\t* g++.dg/cpp0x/constexpr-ex4.C: New.\n+\t* g++.dg/cpp0x/constexpr-explicit-inst.C: New.\n+\t* g++.dg/cpp0x/constexpr-fnptr.C: New.\n+\t* g++.dg/cpp0x/constexpr-function1.C: New.\n+\t* g++.dg/cpp0x/constexpr-function2.C: New.\n+\t* g++.dg/cpp0x/constexpr-function3.C: New.\n+\t* g++.dg/cpp0x/constexpr-ice.C: New.\n+\t* g++.dg/cpp0x/constexpr-initlist.C: New.\n+\t* g++.dg/cpp0x/constexpr-neg1.C: New.\n+\t* g++.dg/cpp0x/constexpr-noexcept.C: New.\n+\t* g++.dg/cpp0x/constexpr-noexcept2.C: New.\n+\t* g++.dg/cpp0x/constexpr-noexcept3.C: New.\n+\t* g++.dg/cpp0x/constexpr-noexcept4.C: New.\n+\t* g++.dg/cpp0x/constexpr-non-const-arg.C: New.\n+\t* g++.dg/cpp0x/constexpr-nonlit.C: New.\n+\t* g++.dg/cpp0x/constexpr-nonlit2.C: New.\n+\t* g++.dg/cpp0x/constexpr-nullptr.C: New.\n+\t* g++.dg/cpp0x/constexpr-object1.C: New.\n+\t* g++.dg/cpp0x/constexpr-object2.C: New.\n+\t* g++.dg/cpp0x/constexpr-overflow.C: New.\n+\t* g++.dg/cpp0x/constexpr-pedantic.C: New.\n+\t* g++.dg/cpp0x/constexpr-pos1.C: New.\n+\t* g++.dg/cpp0x/constexpr-potential1.C: New.\n+\t* g++.dg/cpp0x/constexpr-ptrmem.C: New.\n+\t* g++.dg/cpp0x/constexpr-pure.C: New.\n+\t* g++.dg/cpp0x/constexpr-static.C: New.\n+\t* g++.dg/cpp0x/constexpr-static2.C: New.\n+\t* g++.dg/cpp0x/constexpr-static3.C: New.\n+\t* g++.dg/cpp0x/constexpr-static4.C: New.\n+\t* g++.dg/cpp0x/constexpr-static5.C: New.\n+\t* g++.dg/cpp0x/constexpr-static6.C: New.\n+\t* g++.dg/cpp0x/constexpr-string.C: New.\n+\t* g++.dg/cpp0x/constexpr-switch.C: New.\n+\t* g++.dg/cpp0x/constexpr-targ.C: New.\n+\t* g++.dg/cpp0x/constexpr-throw.C: New.\n+\t* g++.dg/cpp0x/constexpr-typeid.C: New.\n+\t* g++.dg/cpp0x/constexpr-union.C: New.\n+\t* g++.dg/cpp0x/constexpr-value.C: New.\n+\t* g++.dg/cpp0x/constexpr-value2.C: New.\n+\t* g++.dg/cpp0x/constexpr-variadic.C: New.\n+\t* g++.dg/cpp0x/initlist5.C: Use constexpr.\n+\t* g++.dg/cpp0x/static_assert3.C: Add expected error.\n+\t* g++.dg/other/fold1.C: Likewise.\n+\t* g++.dg/parse/crash36.C: Likewise.\n+\t* g++.dg/parse/constant4.C: Adjust expected error.\n+\t* g++.dg/template/arg5.C: Likewise.\n+\t* g++.dg/template/non-dependent10.C: Likewise.\n+\t* g++.dg/template/qualified-id3.C: Likewise.\n+\t* g++.dg/warn/overflow-warn-1.C: Likewise.\n+\t* g++.dg/warn/overflow-warn-3.C: Likewise.\n+\t* g++.dg/warn/overflow-warn-4.C: Likewise.\n+\t* g++.old-deja/g++.pt/crash10.C: Likewise.\n \n \t* g++.dg/cpp0x/constexpr-ctor2.C: New.\n "}, {"sha": "36939e1afe14cc34757d0d4937790936622c93d8", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-array-ptr.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,15 @@\n+// { dg-options -std=c++0x }\n+\n+template<class T>\n+constexpr T do_get(T* x, int n) {\n+  return x[n - 1];\n+}\n+\n+template<class T, int N>\n+constexpr T get(T (&x)[N]) {\n+  return do_get(x, N);\n+}\n+\n+constexpr int arr_i[] = {1};\n+constexpr auto var = get(arr_i); // #2\n+static_assert(var == arr_i[0], \"Error\");"}, {"sha": "7cf733445d91d9338cfd39516f8a314792285a06", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-array-ptr2.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr2.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,21 @@\n+// { dg-options -std=c++0x }\n+\n+template<class T>\n+struct IsNegative {\n+  int dummy; // Workaround for empty class problem\n+  constexpr IsNegative() : dummy(0) {}\n+  constexpr bool operator()(const T& x) {\n+    return x < T(0);\n+  }\n+};\n+\n+template<class T, int N, class Pred>\n+constexpr bool has_neg(T (&x)[N], Pred p) {\n+  return p(x[0]) || p(x[1]);\n+}\n+\n+constexpr int a[] = {1, -2};\n+\n+constexpr auto answer = has_neg(a, IsNegative<int>{}); // #1\n+\n+static_assert(answer, \"Error\");"}, {"sha": "f84cb52577417fca6edf916ebe4935ed7373104a", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-array-ptr3.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr3.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,19 @@\n+// { dg-options -std=c++0x }\n+\n+constexpr bool is_negative(int x) {\n+  return x < 0;\n+};\n+\n+constexpr bool do_has_neg(const int* x, bool(*p)(int)) {\n+ return p(x[0]) || p(x[1]);  // Line 6\n+}\n+\n+constexpr bool has_neg(const int (&x)[2], bool(*p)(int)) {\n+ return do_has_neg(x, p); // Line 10\n+}\n+\n+constexpr int a[] = {1, -2};\n+\n+constexpr auto answer = has_neg(a, is_negative); // Line 15\n+\n+static_assert(answer, \"Error\");"}, {"sha": "697d2d9f708bf2932fd736f252b1c1f8d85575e1", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-array-ptr4.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr4.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,23 @@\n+// { dg-options -std=c++0x }\n+\n+constexpr const int do_last(const int* x, int n) {\n+ return x[n - 1];\n+}\n+\n+struct IsNegative {\n+  constexpr bool operator()(const int& x) {\n+    return x < 0;\n+  }\n+};\n+\n+template<int N, class Pred>\n+constexpr bool has_neg(const int (&x)[N], Pred p) {\n+  return p(do_last(x, N)); // Line 13\n+}\n+\n+constexpr int a[] = {1, -2};\n+\n+constexpr auto answer = has_neg(a, IsNegative{}); // Line 18\n+\n+static_assert(answer, \"Error\");\n+"}, {"sha": "d58f254f6c8d404722ba5dc1578b1328ff743173", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-array-ptr5.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr5.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,32 @@\n+// { dg-options -std=c++0x }\n+\n+template<class T>\n+constexpr T do_last(T* x, int n) {\n+ return x[n - 1]; //\n+}\n+\n+template<class T, int N>\n+constexpr T last(T (&x)[N]) {\n+ return do_last(x, N);\n+}\n+\n+constexpr bool is_negative(int x) { return x < 0; }\n+\n+template<class T>\n+struct IsNegative {\n+  constexpr bool operator()(const T& x) {\n+    return x < T(0);\n+  }\n+};\n+\n+template<class T, int N, class Pred>\n+constexpr bool has_neg(T (&x)[N], Pred p) {\n+  return p(last(x)); // Line 22\n+}\n+\n+constexpr int a[] = {1, -2};\n+\n+constexpr auto answer1 = has_neg(a, IsNegative<int>{}); // Line 27\n+constexpr auto answer2 = has_neg(a, is_negative);\n+\n+static_assert(answer2 == answer1, \"Error\");"}, {"sha": "17dd6e50be91bd4d846c45557a174dfc9289984f", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-array-ptr6.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr6.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,18 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+typedef decltype(sizeof(char)) size_type;\n+\n+template<class T, size_type N>\n+constexpr size_type size(T (&)[N]) { return N; }\n+\n+double array_double[] = { 1.0, 2.0, 3.0 };\n+\n+constexpr auto sz_d = size(array_double);\n+\n+static_assert(sz_d == 3, \"Array size failure\");\n+\n+void f(bool (&param)[2]) {\n+  static_assert(size(param) == 2, \"Array size failure\"); // Line 13\n+  short data[] = {-1, 2, -45, 6, 88, 99, -345};\n+  static_assert(size(data) == 7, \"Array size failure\");\n+}"}, {"sha": "e37400a8bda87a9510a7113dd40d14eefbeb2fed", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-array.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,15 @@\n+// { dg-options -std=c++0x }\n+// { dg-final { scan-assembler-not \"static_initialization\" } }\n+\n+struct A\n+{\n+  int i;\n+  constexpr A(): i(0) { }\n+};\n+\n+struct B\n+{\n+  A a[4];\n+};\n+\n+extern const B b{};"}, {"sha": "774df318ab6669bf1213b124b4c2cdeeb22a9ae2", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-base.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-base.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-base.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-base.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,17 @@\n+// Test base/member class and static_assert with constexpr\n+// { dg-options -std=c++0x }\n+\n+struct A {\n+  int i;\n+  constexpr A(int _i): i(_i) { }\n+};\n+struct B: A {\n+  A a;\n+  int j;\n+  constexpr B(int _ib, int _ia, int _j): A(_ib), a(_ia), j(_j) { }\n+};\n+\n+constexpr B b (12, 24, 36);\n+\n+#define SA(X) static_assert (X, #X)\n+SA(b.i==12 && b.a.i==24 && b.j==36);"}, {"sha": "fbaae5dcd5e051c0349393abd46d0ae4310de43b", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-complex.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-complex.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-complex.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-complex.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,17 @@\n+// Make sure C99 complex works with constexpr\n+// { dg-options -std=c++0x }\n+\n+struct complex\n+{\n+  typedef float value_type;\n+  typedef __complex__ float _ComplexT;\n+\n+  constexpr complex(_ComplexT __z) : _M_value(__z) { }\n+\n+  constexpr complex(float __r = 0.0f, float __i = 0.0f)\n+  : _M_value(__r + __i * 1.0fi) { }\n+\n+private:\n+  _ComplexT _M_value;\n+};\n+constexpr complex c1;"}, {"sha": "7d7a33d4296bcb39227720d4455becd718a92913", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-data1.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-data1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-data1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-data1.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do \"compile\" }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// From N2235\n+\n+// 1\n+struct A2\n+{\n+  static const int eights = 888;\n+  static constexpr int nines = 999;\n+};\n+\n+A2 a;\n+\n+// 2\n+struct pixel\n+{\n+  int x, y;\n+};\n+constexpr pixel ur = { 1294, 1024 }; // OK\n+\n+// p4\n+struct Length\n+{\n+   explicit constexpr Length(int i = 0) : val(i) { }\n+private:\n+   int val;\n+};\n+\n+constexpr int myabs(int x)\n+{ return x < 0 ? -x : x; }    // OK\n+\n+Length l(myabs(-97)); // OK\n+\n+// p6\n+class debug_flag\n+{\n+public:\n+   explicit debug_flag(bool);\n+   constexpr bool is_on(); // { dg-error \"enclosing class .* not a literal type\" }\n+private:\n+   bool flag;\n+};"}, {"sha": "4d4ce780f3675ce7498062f9846f50f299b7d968", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-data2.C", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-data2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-data2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-data2.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,48 @@\n+// { dg-do \"compile\" }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+template<typename _Tp, _Tp v>\n+  struct A3\n+  {\n+    typedef _Tp value_type;\n+    typedef A3<value_type,v> type;\n+\n+    static constexpr value_type value = v;\n+\n+    constexpr operator value_type() { return value; }\n+  };\n+\n+// Partial specialization.\n+template<typename _Tp, _Tp v>\n+  struct A3<_Tp*, v>\n+  {\n+    typedef _Tp* value_type;\n+    typedef A3<value_type,v> type;\n+\n+    static constexpr value_type value = v;\n+\n+    constexpr operator value_type() { return value; }\n+  };\n+\n+// Explicit specialization.\n+template<>\n+  struct A3<unsigned short, 0>\n+  {\n+    typedef unsigned short value_type;\n+    typedef A3<value_type, 0> type;\n+\n+    static constexpr value_type value = 0;\n+\n+    constexpr operator value_type() { return value; }\n+  };\n+\n+// Explicitly instantiate.\n+template struct A3<int, 415>;\n+\n+// Extern explicitly instantiate.\n+extern template struct A3<int, 510>;\n+\n+// Use.\n+A3<int, 1111> a31;\n+// FIXME should this be an error?\n+A3<char, 9999> a32;\t\t// { dg-warning \"overflow\" }"}, {"sha": "7363e98ecb8f94cc2328bac77de01306f9f3398f", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-deref.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-deref.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-deref.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-deref.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,16 @@\n+// { dg-options -std=c++0x }\n+\n+struct A\n+{\n+  const int *p[2];\n+};\n+\n+constexpr const int * f(const int *p) { return p; }\n+\n+int main()\n+{\n+  constexpr int i = 42;\n+  constexpr int j = *&i;\t   // OK\n+  constexpr int k = *A{{&i}}.p[0]; // OK\n+  constexpr int l = *f(&i);\t   // OK\n+}"}, {"sha": "a3706d6ec8090691fb37dff0130f5754407b4f6c", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-diag1.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-diag1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-diag1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-diag1.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,21 @@\n+// Test that we explain why a template instantiation isn't constexpr\n+// { dg-options -std=c++0x }\n+// { dg-prune-output \"not a constexpr function\" }\n+\n+template <class T>\n+struct A\n+{\n+  T t;\n+  constexpr int f() { return 42; }\n+};\n+\n+struct B { B(); operator int(); };\n+\n+constexpr A<int> ai = { 42 };\n+constexpr int i = ai.f();\n+\n+constexpr int b = A<B>().f();\t// { dg-error \"enclosing class\" }\n+\n+template <class T>\n+constexpr int f (T t) { return 42; }\n+constexpr int x = f(B());\t// { dg-error \"parameter\" }"}, {"sha": "6d231fafadbcd1210d9c1b3cf31e59dcb05ecfe4", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-eh-spec.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-eh-spec.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-eh-spec.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-eh-spec.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,9 @@\n+// { dg-options -std=c++0x }\n+template<class T> class my_limits {\n+public:\n+  static constexpr T min() throw() { return T(); }\n+  static constexpr T max() noexcept { return T(); }\n+};\n+\n+constexpr double var_min = my_limits<double>::min(); // #1  OK\n+constexpr double var_max = my_limits<double>::max(); // #2 Error"}, {"sha": "5d090b541d4674d0c641e4d319f7ec255b3b6505", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-ellipsis.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ellipsis.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ellipsis.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ellipsis.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,5 @@\n+// { dg-options -std=c++0x }\n+constexpr int ellipsis(...) { return 1; }\n+\n+constexpr int ellipsis_c = ellipsis(); // OK\n+constexpr int ellipsis_c2 = ellipsis(42); // Internal error"}, {"sha": "0bb6904061f9a62aa8dee4359cc55d28052cc303", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-ellipsis2.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ellipsis2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ellipsis2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ellipsis2.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,12 @@\n+// { dg-options -std=c++0x }\n+\n+struct A\n+{\n+  A();\n+  A(const A&);\n+  bool empty();\n+};\n+\n+constexpr int ellipsis(...) { return 1; }\n+\n+static_assert(ellipsis(A().empty()), \"Error\"); // { dg-error \"non-constant condition|empty\" }"}, {"sha": "a9fc4388a34b18e67a3075fa2fc7dbfe4f93a5d1", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-empty.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-empty.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-empty.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-empty.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,7 @@\n+// { dg-options -std=c++0x }\n+\n+struct Empty {};\n+\n+constexpr bool f(Empty) { return true; }\n+\n+constexpr bool x(f(Empty{}));"}, {"sha": "ef21211944730bc8d67bbca4278a5bff2f1ef928", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-empty2.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-empty2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-empty2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-empty2.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,7 @@\n+// { dg-options -std=c++0x }\n+\n+struct IsLiteral {};\n+\n+constexpr IsLiteral bar(IsLiteral x) { return x; }\n+\n+constexpr auto xy = bar(IsLiteral()); // #1  Error, but should be OK"}, {"sha": "e0026fcc76030767ea172dda25a223b18e2b4c0a", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-empty3.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-empty3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-empty3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-empty3.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,9 @@\n+// { dg-options -std=c++0x }\n+\n+struct IsLiteral {};\n+\n+constexpr auto ab = IsLiteral();\n+\n+constexpr IsLiteral bar(IsLiteral x) { return x; }\n+\n+constexpr auto xy = bar(ab);"}, {"sha": "b07f924649d636fcd6597f4f577cfd7249f7e00c", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-empty4.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-empty4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-empty4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-empty4.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,34 @@\n+// { dg-options -std=c++0x }\n+\n+typedef decltype(sizeof(char)) size_type;\n+\n+template<class T, size_type N, class Pred>\n+constexpr size_type do_find_if_or_stop(T (&x)[N], size_type i, Pred p);\n+\n+template<class T, size_type N, class Pred>\n+constexpr size_type do_find_if(T (&x)[N], size_type i, Pred p) {\n+  return p(x[i]) ? i : do_find_if_or_stop(x, i + 1, p);  // line 8\n+}\n+\n+template<class T, size_type N, class Pred>\n+constexpr size_type do_find_if_or_stop(T (&x)[N], size_type i, Pred p) {\n+  return i == N ? N : do_find_if(x, i, p);\n+} // Line 14\n+\n+template<class T, size_type N, class Pred>\n+constexpr size_type find_if(T (&x)[N], Pred p) {\n+\treturn do_find_if(x, 0, p); // Line 18\n+}\n+\n+constexpr long items_long[] = {1, 2, 3, 4, -5, 6, -7, 8};\n+\n+template<class T>\n+struct IsNegative {\n+\tconstexpr bool operator()(const T& x) {\n+\t\treturn x < T(0);\n+\t}\n+};\n+\n+constexpr auto pos1 = find_if(items_long, IsNegative<long>{}); // Line 30\n+\n+static_assert(pos1 == 4, \"find_if failure\");"}, {"sha": "9bd9aa583dcac63618f7a3ee6c20db2588ecb6ec", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-empty5.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-empty5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-empty5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-empty5.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,7 @@\n+// { dg-options -std=c++0x }\n+\n+struct A { };\n+struct B: A { };\n+\n+constexpr B b { };\n+constexpr A a = b;"}, {"sha": "f2b53846ecb03d452064f56e260ef717a1ad9b6f", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-ex1.C", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ex1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ex1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ex1.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,94 @@\n+// { dg-do \"compile\" }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// From N2235\n+\n+// 4.1 constant-expression functions\n+// 1 examples\n+\n+\n+\n+\n+\n+// 2 defined before first use\n+// NOTE: this is only needed in contexts that require a constant-expression\n+struct S {\n+    constexpr int twice();\n+    constexpr int t();\t\t// { dg-message \"used but never defined\" }\n+private:\n+    static constexpr int val;  // constexpr variable\n+};\n+constexpr int S::val = 7;\n+constexpr int S::twice() { return val + val; }\n+constexpr S s = { };\n+int x1 = s.twice();     // ok\n+int x2 = s.t();         // error: S::t() not defined\n+constexpr int x2a = s.t();     // { dg-error \"S::t\" } error: S::t() not defined\n+constexpr int ff();     // ok\n+constexpr int gg();     // ok\n+int x3 = ff();          // error: ff() not defined\n+constexpr int x3a = ff();      // { dg-error \"ff\" } error: ff() not defined\n+constexpr int ff() { return 1; }        // too late\n+constexpr int gg() { return 2; }\n+int x4 = gg();  // ok\n+\n+\n+// 4.2 const-expression data\n+\n+// 2\n+// storage  not allocated untill address taken\n+constexpr double x = 9484.748;\n+const double* p = &x;          // the &x forces x into memory\n+\n+// 4.3 constant-expression constructors\n+\n+// 1\n+struct complex {\n+   constexpr complex(double r, double i) : re(r), im(i) { }\n+   constexpr double real() { return re; }\n+   constexpr double imag() { return im; }\n+private:\n+   double re;\n+   double im;\n+};\n+constexpr complex I(0, 1);  // OK -- literal complex\n+\n+\n+// 2 invoked with non-const args\n+double x5 = 1.0;\n+constexpr complex unit(x5, 0);\t// { dg-error \"x5|argument\" } error: x5 non-constant\n+const complex one(x5, 0);   // OK, \u2018\u2018ordinary const\u2019\u2019 -- dynamic\n+                           //   initialization\n+constexpr double xx = I.real(); // OK\n+complex z(2, 4);           // OK -- ordinary variable\n+\n+// 3\n+constexpr complex v[] = {\n+     complex(0, 0), complex(1, 1), complex(2, 2)\n+};\n+constexpr double x6 = v[2].real(); // OK\n+\n+// 4 \n+  constexpr int i = 98;\n+  typedef __INTPTR_TYPE__ intptr_t;\n+  constexpr intptr_t ip = (intptr_t) &i;\t// { dg-error \"constant\" }\n+\n+// 4.3.2 copy-constructor\n+constexpr complex operator+(complex z, complex w)\n+{\n+  return complex(z.real() + w.real(), z.imag() + w.imag()); // fine\n+}\n+constexpr complex I2 = I + I;                 // OK\n+struct resource {\n+  int id;\n+  constexpr resource(int i) : id(i) { }       // fine\n+  resource(const resource& r) : id(r.id)      // oops, not constexpr\n+  {\n+    //cout << id << \" copied\" << endl;\n+  }\n+};\n+constexpr resource f(resource d)\n+{ return d; }                  // { dg-error \"not .constexpr\" }\n+constexpr resource d = f(9);   // { dg-error \"resource\" }\n+\n+// 4.4 floating-point constant expressions"}, {"sha": "5896c20f80fbbd9795d74a644efc25cc65f6bada", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-ex2.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ex2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ex2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ex2.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,23 @@\n+// { dg-do \"compile\" }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// From N2235\n+\n+// 4.5.3 constant expressions\n+\n+// p 4\n+struct A {\n+  constexpr A(int i) : val(i) { }\n+  constexpr operator int() { return val; }\n+  constexpr operator long() { return -1; }\n+private:\n+  int val;\n+};\n+\n+template<int I> struct X { static const int i = I; };\n+constexpr A a = 42;\n+\n+X<a> x;\t    // OK: unique conversion to int\n+int ar[X<a>::i]; // also OK\n+int ary[a]; // { dg-error \"ambiguous|conversion|array\" } ambiguous conversion\n+"}, {"sha": "597603c39a47cfa306e0e9a7b0f219932b9a6148", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-ex3.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ex3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ex3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ex3.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,30 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+#define SA(X) static_assert (X, #X)\n+\n+struct A\n+{\n+  int i;\n+  constexpr A(int _i) { i = _i; } // { dg-error \"empty body|uninitialized member\" }\n+};\n+\n+template <class T>\n+struct B\n+{\n+  T t;\n+  constexpr B(T _t): t(_t) { }\n+};\n+\n+B<int> b(1);\n+SA(b.t==1);\t\t\t// { dg-error \"non-constant condition|'b'\" }\n+constexpr B<int> b2(1);\n+SA(b2.t==1);\n+\n+template <class T>\n+constexpr T f(T a, T b)\n+{\n+  typedef T myT;\n+  return a + b;\n+}\n+\n+SA(f(1,2)==3);"}, {"sha": "4214f5c52ded2e1a93dd03d2eb9345a3c254cea7", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-ex4.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ex4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ex4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ex4.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,16 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+struct A\n+{\n+  constexpr A(int) { }\n+  constexpr operator int() { return 1; };\n+};\n+\n+template <class T>\n+struct B\n+{\n+  static constexpr A a = A(1);\n+  int ar[a];\n+};\n+\n+B<int> b;"}, {"sha": "8f0da0af0c53f6ef56ee01443646c449ac315bbb", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-explicit-inst.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-explicit-inst.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-explicit-inst.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-explicit-inst.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,9 @@\n+// { dg-options -std=c++0x }\n+\n+template<class T> constexpr inline T bar(T x) { return x; }\n+\n+template short bar(short x); // #EI\n+\n+constexpr auto yz = bar(0); // OK\n+constexpr auto ab = bar(short()); // #1 Error, but should be OK\n+constexpr auto mn = bar(short{}); // #2 Error, but should be OK"}, {"sha": "4c84d827f074a6f4885fbf286ddecafe83851d1e", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-fnptr.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-fnptr.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-fnptr.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-fnptr.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,7 @@\n+// { dg-options -std=c++0x }\n+\n+constexpr bool is_negative(int x) { return x < 0; }\n+\n+constexpr bool check(int x, bool (*p)(int)) { return p(x); }  // #1\n+\n+static_assert(check(-2, is_negative), \"Error\");"}, {"sha": "afe964b420f4cc4f06e5142c6ddb85d21759d941", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-function1.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-function1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-function1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-function1.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do \"compile\" }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// From N2235\n+\n+constexpr int veryabs(int x) { return x < 0 ? -x : x; }\n+\n+constexpr long long_max() { return 2147483647; }\n+\n+constexpr int verysquare(int x) { return x * x; }"}, {"sha": "5e0c101b2ba8e20bbb68de3b66cdf8ce2e56fe04", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-function2.C", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-function2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-function2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-function2.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,50 @@\n+// { dg-do \"compile\" }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// From N2235\n+\n+// Mess with the builtin by redeclaring.\n+constexpr int abs(int x) { return x < 0 ? -x : x; }\n+\n+extern \"C\"\n+{\n+  constexpr float\n+  squaref(float x) { return x * x; }\n+}\n+\n+// implicitly inline, already: warn?\n+inline constexpr double\n+squared(double x) { return x * x; }\n+\n+constexpr int squarei(int x) { return x * x; }\n+extern const int side;\n+constexpr int area = squarei(side); // { dg-error \"side|argument\" }\n+// error: squarei(side) is not a constant expression\n+\n+int next(constexpr int x) // { dg-error \"parameter\" }\n+{ return x + 1; }\n+\n+constexpr void f(int x)       // { dg-error \"return type .void\" }\n+{ /* ... */ }\n+\n+constexpr int prev(int x)\n+{ return --x; }               // { dg-error \"--\" }\n+\n+constexpr int g(int x, int n) // error: body not just \u2018\u2018return expr\u2019\u2019\n+{\n+   int r = 1;\n+   while (--n > 0) r *= x;\n+   return r;\n+} // { dg-error \"not a return-statement\" }\n+\n+constexpr int\n+bar(int x, int y) { return x + y + x * y; } // { dg-error \"previously\" }\n+\n+int bar(int x, int y)\t     // { dg-error \"redefinition\" }\n+{ return x * 2 + 3 * y; }\n+\n+constexpr int twice(int x);  // { dg-message \"never defined\" }\n+enum { bufsz = twice(256) }; // { dg-error \"\" } twice() isn\u2019t (yet) defined\n+\n+constexpr int fac(int x)\n+{ return x > 2 ? x * fac(x - 1) : 1; } // OK"}, {"sha": "07981fbf5df54d06e0267660197045fb014197cd", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-function3.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-function3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-function3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-function3.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,30 @@\n+// { dg-do \"compile\" }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// From N2235\n+\n+// function template 1\n+template<typename T>\n+  constexpr int bytesize(T t)\n+  { return sizeof (t); }        // OK\n+\n+char buf[bytesize(0)];          // OK -- not C99 VLA\n+\n+\n+// function template 2\n+template<typename _Tp>\n+  constexpr _Tp\n+  square(_Tp x) { return x; }\n+\n+// Explicit specialization\n+template<>\n+  constexpr unsigned long\n+  square(unsigned long x) { return x * x; }\n+\n+// Explicit instantiation\n+template int square(int);\n+\n+class A { };\n+template A square(A);\n+\n+template long square(long);"}, {"sha": "3b72484a00558e9c0143b3979eb2db7854c5e557", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-ice.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ice.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ice.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ice.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,11 @@\n+// We used to crash on this instead of giving a decent error.\n+// { dg-options -std=c++0x }\n+\n+struct A { int i; };\n+\n+struct B {\n+  const A *a;\n+  constexpr B(const A& a): a(&a) { }\n+};\n+\n+constexpr B b{A{42}};\t\t// { dg-error \"constant|expansion\" }"}, {"sha": "6854e7341b743b95a4b703753a2ab32f43def8c6", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-initlist.C", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-initlist.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-initlist.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-initlist.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,65 @@\n+// { dg-options -std=c++0x }\n+// { dg-do run }\n+\n+namespace xstd {\n+\n+typedef decltype(sizeof(char)) size_t;\n+\n+template<class E>\n+class initializer_list {\n+private:\n+\tsize_t sz;\n+\tconst E* start;\n+\n+public:\n+\ttypedef E value_type;\n+  typedef const E& reference;\n+  typedef const E& const_reference;\n+  typedef size_t size_type;\n+  typedef const E* iterator;\n+  typedef const E* const_iterator;\n+\n+  constexpr initializer_list() : sz(), start(nullptr) {}\n+\n+  template<size_t N>\n+  constexpr initializer_list(const E(&array)[N]) : sz(N), start(array) {}\n+\n+  constexpr size_t size() { return sz; }\n+\n+  constexpr const E* begin() { return start; }\n+\n+  constexpr const E* end() { return start + sz; }\n+};\n+\n+template<class E, size_t N>\n+constexpr initializer_list<E> make_list(const E(&array)[N]) {\n+\treturn initializer_list<E>(array);\n+}\n+\n+template<class E>\n+E min(initializer_list<E> list)\n+{\n+  //\tstatic_assert(list.size() > 0, \"Invalid list\");\n+\tauto it = list.begin();\n+\tE result = *it;\n+\tfor (++it; it != list.end(); ++it) {\n+\t\tif (*it < result) {\n+\t\t\tresult = *it;\n+\t\t}\n+\t}\n+\treturn result;\n+}\n+\n+}\n+\n+constexpr int global_i[] = {2, 4, -5, 6, 10};\n+constexpr xstd::initializer_list<int> list(global_i);\n+#define SA(X) static_assert(X, #X)\n+SA(list.size() == 5);\n+SA(list.begin()[2] == -5);\n+SA(list.end()[-1] == 10);\n+\n+int main() {\n+  if (xstd::min(xstd::make_list(global_i)) != -5)\n+    return 1;\n+}"}, {"sha": "ce01f8b5d4420aaf43de8d3957b671594ef6742d", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-neg1.C", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-neg1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-neg1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-neg1.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,69 @@\n+// Negative examples from N3092 (FCD)\n+// { dg-options -std=c++0x }\n+\n+// OK: declaration\n+constexpr int square(int x);\t// { dg-message \"never defined\" }\n+\n+// error: pixel is a type\n+constexpr struct pixel {\n+  int x;\n+  int y;\n+  // OK: declaration\n+  constexpr pixel(int);\n+};\t\t\t\t// { dg-error \"constexpr\" }\n+constexpr pixel::pixel(int a)\n+// OK: definition\n+  : x(square(a)), y(square(a))\t// { dg-error \"square\" }\n+{ }\n+\n+// error: square not defined, so small(2) not constant (5.19), so constexpr\n+// not satisfied\n+constexpr pixel small(2);\t// { dg-error \"\" }\n+\n+// error: not for parameters\n+int next(constexpr int x) {\t// { dg-error \"parameter\" }\n+  return x + 1;\n+}\n+\n+// error: not a definition\n+extern constexpr int memsz;\t// { dg-error \"definition\" }\n+\n+// error: return type is void\n+constexpr void f(int x)\t\t// { dg-error \"void\" }\n+{ /* ... */ }\n+// error: use of decrement\n+constexpr int prev(int x)\n+{ return --x; }\t\t\t// { dg-error \"-- x\" }\n+\n+// error: body not just return expr\n+constexpr int g(int x, int n) {\n+  int r = 1;\n+  while (--n > 0) r *= x;\n+  return r;\n+} // { dg-error \"body of constexpr function\" }\n+\n+class debug_flag {\n+public:\n+  explicit debug_flag(bool);\n+  constexpr bool is_on();\t// { dg-error \"not a literal type\" } debug_flag not literal type\n+private:\n+  bool flag;\n+};\n+// OK\n+constexpr int bar(int x, int y) // { dg-error \"previously defined here\" }\n+{ return x + y + x*y; }\n+// ...\n+// error: redefinition of bar\n+int bar(int x, int y)\t\t// { dg-error \"redefinition\" }\n+{ return x * 2 + 3 * y; }\n+\n+struct pixel2 {\t   // { dg-message \"no user-provided default constructor\" }\n+  int x, y;\n+};\n+constexpr pixel2 ur = { 1294, 1024 };// OK\n+constexpr pixel2 origin;\t     // { dg-error \"uninitialized const\" }\n+\n+constexpr const int* addr(const int& ir) { return &ir; } // OK\n+\n+// error, initializer for constexpr variable not a constant\n+extern constexpr const int* tp = addr(5); // { dg-error \"\" }"}, {"sha": "0476f90965455a4fffb4b6492b2efd068f7fa41f", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-noexcept.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-noexcept.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-noexcept.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-noexcept.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,13 @@\n+// { dg-options -std=c++0x }\n+\n+template<class T>\n+struct is_funny {\n+  static constexpr bool value = false;\n+};\n+\n+template<class T>\n+constexpr T value(T t) noexcept(is_funny<T>::value) { return t; } // Line 7\n+\n+constexpr bool ok = noexcept(value(42));\n+\n+static_assert(ok, \"Assertion failure\");"}, {"sha": "95a1443fa2820e0ba3fab0958565a7470eed7872", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-noexcept2.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-noexcept2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-noexcept2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-noexcept2.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,14 @@\n+// { dg-options -std=c++0x }\n+\n+template<class T>\n+constexpr T value(T t) { return t; }\n+\n+template<class T>\n+struct is_funny {\n+  static constexpr bool value = false;\n+};\n+\n+template<class T>\n+void eval() noexcept(value(is_funny<T>::value)) {}\n+\n+constexpr bool ok = noexcept(eval<int>()); // line 12"}, {"sha": "6e76ea8fa0b5519f7f12f6cf45e0734ab005886d", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-noexcept3.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-noexcept3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-noexcept3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-noexcept3.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,7 @@\n+// { dg-options -std=c++0x }\n+\n+constexpr int f(int i) { return i; }\n+#define SA(X) static_assert (X, #X)\n+SA(noexcept(f(42)));\n+int j;\n+SA(!noexcept(f(j)));"}, {"sha": "119d4e1673052982852bbcdc85d793cdf42fca8a", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-noexcept4.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-noexcept4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-noexcept4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-noexcept4.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,14 @@\n+// { dg-options -std=c++0x }\n+// A call is noexcept if it is a valid subexpression of a constant\n+// expression, even if it is not itself a constant expression.\n+\n+#define SA(X) static_assert(X,#X)\n+\n+constexpr const int* f(const int *p) { return p; }\n+\n+int main()\n+{\n+  constexpr int i = 42;\n+  SA(noexcept(*f(&i)));\n+  SA(noexcept(f(&i)));\n+}"}, {"sha": "2c53595833ea864dcf71841c4918913f02611748", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-non-const-arg.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-non-const-arg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-non-const-arg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-non-const-arg.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,24 @@\n+// Example from issue 1125 drafting; D() and v were well-formed with the\n+// wording approved in Rapperswil, now seems they should be ill-formed.\n+// { dg-options \"-std=c++0x -pedantic-errors\" }\n+\n+struct B {\n+  constexpr B(int x) : i(0) { }    // \"x\" is unused\n+  int i;\n+};\n+\n+int global; // not constant\n+\n+struct D : B {\n+  constexpr D() : B(global) { }   // { dg-error \"global|argument\" }\n+};\n+\n+struct A2 {\n+  constexpr A2(bool b, int x) : m(b ? 42 : x) { }\n+  int m;\n+};\n+\n+// ok, constructor call initializes m with the value 42 after substitution\n+constexpr int v = A2(true, global).m; // { dg-error \"global\" }\n+// error: initializer for m is \"x\", which is non-constant\n+constexpr int w = A2(false, global).m; // { dg-error \"global\" }"}, {"sha": "9104c8afac6414248acfefa6287c46430134f968", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-nonlit.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-nonlit.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-nonlit.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-nonlit.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,13 @@\n+// FIXME this is currently invalid, but seems like it should be OK\n+// { dg-options -std=c++0x }\n+\n+struct A { A() { } };\n+\n+template<class T>\n+constexpr bool ignore(T&&) { return true; }\n+\n+static_assert(ignore(10), \"Error\"); // OK\n+\n+A s;\n+\n+static_assert(ignore(s), \"Error\"); // Currently an error"}, {"sha": "21e8bd509619120013e0101aa017e6866c6c4e42", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-nonlit2.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-nonlit2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-nonlit2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-nonlit2.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,19 @@\n+// { dg-options -std=c++0x }\n+\n+struct A\n+{\n+  ~A();\n+};\n+\n+template<class T>\n+struct W {\n+  T t;\n+  template<class U>\n+  constexpr W(U&& u) : t(u) {}\n+};\n+\n+template <class T>\n+constexpr W<T> make_w(T& w) { return W<T>(w); }\n+\n+A a;\n+constexpr auto w = make_w(a);\t// { dg-error \"\" }"}, {"sha": "7ac53db489ca15a78fef84b1b6448e75ca078af5", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-nullptr.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-nullptr.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-nullptr.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,6 @@\n+// { dg-options -std=c++0x }\n+\n+constexpr int zero() { return 0; }\n+\n+void* ptr1 = zero(); // #1\n+constexpr void* ptr2 = zero(); // #2"}, {"sha": "c635fd0d2a6f16ee1ff02b6a155e9fd4d5ebdb06", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-object1.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-object1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-object1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-object1.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,31 @@\n+// { dg-do \"compile\" }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// From N2235\n+\n+// 4.5.2 semantics\n+\n+// p 1 constexpr specifier\n+// objects, static const data\n+struct A1 { };\t   // { dg-message \"no user-provided default constructor\" }\n+\n+constexpr int i1 = 1024;\n+constexpr A1 a1 = A1();\n+\n+// error: not a definition\n+extern constexpr int i2; // { dg-error \"definition\" }\n+\n+// error: missing initializer\n+constexpr A1 a2; // { dg-error \"uninitialized const\" }\n+\n+// error: duplicate cv\n+const constexpr A1 a3 = A1(); // { dg-error \"both .const. and .constexpr. cannot\" }\n+\n+volatile constexpr A1 a4 = A1(); // { dg-error \"both .volatile. and .constexpr. cannot\" }\n+\n+// error: on type declaration\n+constexpr struct pixel\n+{\n+  int x;\n+  int y;\n+};\t\t     // { dg-error \"cannot be used for type declarations\" }"}, {"sha": "3590bb8d744d3a64efeade9c6a71f9ef622ebfc1", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-object2.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-object2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-object2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-object2.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do \"compile\" }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+constexpr int verysquare(int x) { return x * x; }\n+\n+const double mass = 9.8;\n+constexpr double energy = mass * verysquare(56.6); // { dg-error \"mass\" \"\" { xfail *-*-* } }\n+\n+int arr[(int)mass];\t\t// { dg-error \"mass\" \"\" { xfail *-*-* } }\n+\n+float array[verysquare(9)];         // OK -- not C99 VLA\n+\n+extern const int medium;\n+const int high = verysquare(medium); // OK -- dynamic initialization\n+\n+enum { Max = verysquare(7) };      // OK"}, {"sha": "9b3b1fa0ea564e1dce971f2007e4f7a75e217c47", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-overflow.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-overflow.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-overflow.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-overflow.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,6 @@\n+// { dg-options \"-std=c++0x -w\" }\n+\n+#include <limits.h>\n+extern constexpr int max_s = INT_MAX + 1;  // { dg-error \"\" }\n+extern constexpr unsigned max_u = UINT_MAX + 1u;  // OK\n+extern constexpr int abs_s = -INT_MIN;  // { dg-error \"\" } overflows on 2's complement machines"}, {"sha": "dc393d75915eb864017a1e148962e16886a7ec46", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-pedantic.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-pedantic.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-pedantic.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-pedantic.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,16 @@\n+// The FCD doesn't allow typedefs and static_assert in constexpr functions,\n+// but it should.\n+// { dg-options \"-std=c++0x -pedantic\" }\n+\n+template <class T>\n+constexpr T f(T t)\n+{\n+  typedef T T2;\t\t\t     // { dg-warning \"constexpr\" \"\" { xfail *-*-* } }\n+  static_assert (T2(0) == T(0), \"\"); // { dg-warning \"constexpr\" \"\" { xfail *-*-* } }\n+  return t;\n+}\n+\n+int main()\n+{\n+  constexpr int i = f(42);\n+}"}, {"sha": "775080acce69cd8b00dc4e8df60287b09b6c9eb3", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-pos1.C", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-pos1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-pos1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-pos1.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,60 @@\n+// Positive examples from N3092 (FCD)\n+// { dg-options -std=c++0x }\n+\n+#define SA(X) static_assert(X, #X)\n+\n+constexpr int bufsz = 1024; // OK: definition\n+SA (bufsz == 1024);\n+\n+constexpr int square(int x); // OK: declaration\n+\n+struct pixel {\n+  int x;\n+  int y;\n+  // OK: declaration\n+  constexpr pixel(int);\n+};\n+constexpr pixel::pixel(int a) // OK: definition\n+  : x(square(a)), y(square(a))\n+{ }\n+\n+constexpr int square(int x) // OK: definition\n+{ return x * x; }\n+\n+constexpr pixel large(4); // OK: square defined\n+SA(large.x == 16 && large.y==16);\n+\n+constexpr long long_max() // OK\n+{ return 2147483647; }\n+\n+SA(long_max() == 2147483647);\n+\n+constexpr int abs(int x) // OK\n+{ return x < 0 ? -x : x; }\n+\n+SA(abs(-1) == 1);\n+SA(abs(24) == 24);\n+\n+struct Length {\n+  explicit constexpr Length(int i = 0) : val(i) { }\n+private:\n+  int val;\n+};\n+\n+constexpr Length l1;\n+constexpr Length l2(12);\n+\n+struct pixel2 {\n+  int x, y;\n+};\n+constexpr pixel2 ur = { 1294, 1024 };// OK\n+\n+SA(ur.x == 1294 && ur.y == 1024);\n+\n+constexpr const int* addr(const int& ir) { return &ir; } // OK\n+static const int x = 5;\n+extern constexpr const int* xp = addr(x); // OK: (const int*)&(const int&)x\n+\t\t\t\t\t  // is an address contant expression\n+SA(xp == &x);\n+extern constexpr int x2 = *addr(5);\n+SA(x2 == 5);"}, {"sha": "e933506b8a16e10550bc154245d282ec97c354c5", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-potential1.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-potential1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-potential1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-potential1.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,7 @@\n+// { dg-options -std=c++0x }\n+// We decided in Rapperswil that it's OK if any value of decide can produce\n+// a constant expression.\n+\n+constexpr int may_throw(bool decide) {\n+  return decide ? 42 : throw -1;\n+}"}, {"sha": "f6ed2f40afb573ab57f79ffaa77c0300e4531092", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-ptrmem.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ptrmem.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ptrmem.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ptrmem.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,20 @@\n+// { dg-options -std=c++0x }\n+\n+struct C { // literal type\n+  int m;\n+  int n;\n+  constexpr C(int m) : m(m), n(-m) {}\n+  constexpr bool is_neg() { return m < 0; }\n+};\n+\n+constexpr bool check1(const C& c, int C:: *pm) { return c.*pm < 0; } // #1\n+\n+constexpr bool check2(const C* pc, bool (C::*pm)() const) { return\n+(pc->*pm)(); } // #2\n+\n+constexpr C c(-1);\n+\n+static_assert(!check1(c, &C::n), \"Error\");\n+static_assert(check1(c, &C::m), \"Error\");\n+\n+static_assert(check2(&c, &C::is_neg), \"Error\");"}, {"sha": "e17e02a422079ffe6366b9975cb92ff6c900e43c", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-pure.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-pure.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-pure.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-pure.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,13 @@\n+// { dg-options -std=c++0x }\n+\n+struct A\n+{\n+  virtual void f() = 0;\n+};\n+\n+struct B: A\n+{\n+  void f() { }\n+};\n+\n+B b;"}, {"sha": "8ed2b5e82edc7f01d80c72cd46402cface602128", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-static.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-static.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-static.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-static.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,24 @@\n+// Test for constant initialization of non-literal class (e.g. mutex)\n+// { dg-options \"-std=c++0x -save-temps\" }\n+// { dg-do run }\n+\n+struct A\n+{\n+  int i;\n+  constexpr A(int _i): i(_i) { }\n+  A(const A&);\t\t       // non-trivial copy ctor makes A non-literal\n+};\n+\n+A a(42);\t    // constexpr constructor allows constant initialization\n+A ar[3] = { { 1 }, { 2 }, { 3 } };\n+// { dg-final { scan-assembler-not \"static_initialization\" } }\n+// { dg-final cleanup-saved-temps }\n+\n+int main()\n+{\n+  if (a.i != 42\n+      || ar[0].i != 1\n+      || ar[1].i != 2\n+      || ar[2].i != 3)\n+    return 1;\n+}"}, {"sha": "67c35308024132fd2e5340b3d741eb9d5ab74d61", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-static2.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-static2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-static2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-static2.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,11 @@\n+// { dg-options -std=c++0x }\n+struct IsLiteral {};\n+\n+struct ShouldBeLiteral {\n+  constexpr ShouldBeLiteral(int){}\n+};\n+\n+struct StaticDataMember {\n+  static constexpr IsLiteral one = IsLiteral(); // #1\n+  static constexpr ShouldBeLiteral two= ShouldBeLiteral(-1); // #2\n+};"}, {"sha": "dccdc854b395beb3368576f69cd974195869fa0e", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-static3.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-static3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-static3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-static3.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,18 @@\n+// Test for constant initialization of class with vtable\n+// { dg-options \"-std=c++0x -save-temps\" }\n+// { dg-final { scan-assembler-not \"static_initialization\" } }\n+// { dg-final cleanup-saved-temps }\n+// { dg-do run }\n+\n+int r = 1;\n+// implicit default constructor for A and B is constexpr\n+struct A { virtual void f() {} };\n+struct B: A { virtual void f() { r = 0; } };\n+\n+B b;\n+\n+int main()\n+{\n+  b.f();\n+  return r;\n+}"}, {"sha": "8189fc5de479679fcc433a835d286d7e0fee0d28", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-static4.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-static4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-static4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-static4.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,20 @@\n+// { dg-options -std=c++0x }\n+// { dg-do run }\n+\n+extern \"C\" void abort ();\n+extern int ar[2];\n+\n+int f()\n+{\n+  if (ar[0] != 42 || ar[1] != 0)\n+    abort ();\n+  return 1;\n+}\n+\n+int i = f();\n+\n+int ar[2] = { 42, i };\n+\n+int main()\n+{\n+}"}, {"sha": "cb553a25fe8b48d78f8c8b12764881480a99378c", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-static5.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-static5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-static5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-static5.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,17 @@\n+// { dg-options -std=c++0x }\n+\n+template <class T>\n+struct A\n+{\n+  constexpr static T t;\n+};\n+template <class T>\n+constexpr T A<T>::t = T();\t// { dg-error \"not literal\" }\n+\n+struct B\n+{\n+  ~B();\n+};\n+\n+B b = A<B>::t;\n+"}, {"sha": "a34704d839c4d1f1fbb4b2f5b052299e72042bc0", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-static6.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-static6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-static6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-static6.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,21 @@\n+// { dg-options -std=c++0x }\n+\n+struct B\n+{\n+  constexpr operator int() { return 4; }\n+};\n+\n+template <int I>\n+struct C;\n+\n+template<>\n+struct C<4> { typedef int TP; };\n+\n+template <class T>\n+struct A\n+{\n+  constexpr static B t = B();\n+  C<t>::TP tp;\n+};\n+\n+A<B> a;"}, {"sha": "e76d00d7e63045346749775e2c0c7483260472a4", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-string.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-string.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-string.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-string.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,5 @@\n+// { dg-options -std=c++0x }\n+\n+constexpr char c1 = \"hi\"[1];\n+constexpr char c2 = \"hi\"[2];\n+constexpr char c3 = \"hi\"[3];\t// { dg-error \"out of bound\" }"}, {"sha": "d229304e419c1d3816b1b071f8cfcd6993685dd2", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-switch.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-switch.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-switch.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-switch.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,13 @@\n+// { dg-options -std=c++0x }\n+\n+template<class T>\n+constexpr T value(T t = T()) { return t; }\n+\n+enum us_enum { us_item = value<short>() }; // OK\n+\n+void func(us_enum n) {\n+  switch (n) {\n+  case value(us_item): ; // #1 Error\n+  default: ;\n+  }\n+}"}, {"sha": "0c8c73d2e1d059deb747452442b62047f760e2b5", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-targ.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-targ.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-targ.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-targ.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,13 @@\n+// { dg-options -std=c++0x }\n+\n+struct A\n+{\n+  constexpr operator double() { return 1.0; }\n+};\n+\n+template <int I>\n+struct B\n+{ };\n+\n+constexpr A a { };\n+B<a> b;\t\t\t\t// { dg-error \"template argument|invalid type\" }"}, {"sha": "345b24097b13fc29b5696e55e87e95a054ec18ed", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-throw.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-throw.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-throw.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-throw.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,8 @@\n+// { dg-options -std=c++0x }\n+\n+constexpr int may_throw(bool decide) {\n+\treturn decide ? 42 : throw -1; // { dg-error \"throw\" }\n+}\n+\n+constexpr int x = may_throw(false); // { dg-error \"may_throw\" }\n+constexpr int y = may_throw(true);"}, {"sha": "b523bb38cc1b49162209f0f760495f20e307c28a", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-typeid.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-typeid.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-typeid.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-typeid.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,10 @@\n+// { dg-options -std=c++0x }\n+\n+#include <typeinfo>\n+\n+struct A { virtual void f(); };\n+\n+extern constexpr const std::type_info* p1 = &typeid(int);\n+extern constexpr const std::type_info* p2 = &typeid(A);\n+// typeid-expression whose operand is of a polymorphic class type\n+extern constexpr const std::type_info* p3 = &typeid((A())); // { dg-error \"\" \"\" { xfail *-*-* } }"}, {"sha": "b4613058ee0beee511593e5824eca72d01e8761f", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-union.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-union.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-union.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-union.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,16 @@\n+// Test that we don't have to deal with type punning\n+// FIXME Mike Miller thinks it should work\n+// { dg-options -std=c++0x }\n+\n+union U\n+{\n+  float f;\n+  unsigned char ca[sizeof(float)];\n+};\n+\n+constexpr U u = { 1.0 };\n+constexpr float f = u.f;\n+constexpr unsigned char c = u.ca[0]; // { dg-error \"U::ca\" }\n+\n+constexpr double d = 1.0;\n+constexpr unsigned char c2 = (unsigned char&)d; // { dg-error \"char. glvalue\" }"}, {"sha": "85799d90b6843443fe77113f1ac39aaa48c6926f", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-value.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-value.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-value.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-value.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,10 @@\n+// { dg-options -std=c++0x }\n+\n+struct HopefullyLiteral {\n+  HopefullyLiteral() = default; // Should be a constexpr c'tor as of 12.1/6 and 8.4.2/4\n+};\n+\n+constexpr HopefullyLiteral var1{}; // OK\n+constexpr HopefullyLiteral var2 = HopefullyLiteral{}; // #1\n+constexpr HopefullyLiteral var3 = HopefullyLiteral(); // #2\n+constexpr HopefullyLiteral var4 = HopefullyLiteral(var3); // #3"}, {"sha": "1b0e28f162dcb6667d781f9908643ca4cf8c45f2", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-value2.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-value2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-value2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-value2.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,19 @@\n+// { dg-options -std=c++0x }\n+\n+template<class T>\n+constexpr T value_init() { return T(); }\n+\n+template<class T>\n+constexpr inline T bar(T x) { return x; }\n+\n+union EmptyUnion {};\n+union Union1 { int i; };\n+union Union3 { double d; int i; char* c; };\n+\n+constexpr auto u1 = value_init<EmptyUnion>();\n+constexpr auto u2 = value_init<Union1>();\n+constexpr auto u3 = value_init<Union3>();\n+constexpr auto u4 = bar(EmptyUnion{});\n+constexpr auto u5 = bar(Union1{});\n+constexpr auto u6 = bar(Union3{});\n+constexpr auto u7 = bar(u1);"}, {"sha": "5d0ad05941e071a35c862a5777e5e7927327db6d", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-variadic.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-variadic.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-variadic.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-variadic.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -0,0 +1,9 @@\n+// { dg-options -std=c++0x }\n+template<class... T>\n+constexpr bool variadics(T&&...) { return true; }\n+\n+struct IsLiteral {};\n+\n+constexpr bool variadic_var = variadics(0, true, 1.2, IsLiteral{}); // Error, so below\n+\n+int main() {}"}, {"sha": "32caac38251ae9bda880541139fbbef595be463e", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist5.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -23,5 +23,5 @@ int k {}; // initialize to 0\n // PR c++/36963\n double d = 1.1;\n float fa[] = { d, 1.1 };      // { dg-error \"narrowing conversion of 'd'\" }\n-const double d2 = 1.1;\n+constexpr double d2 = 1.1;\n float fa2[] = { d2, 1.1 };"}, {"sha": "1ff2ffc94f7096e9696e8ade6a4f24f8806b8258", "filename": "gcc/testsuite/g++.dg/cpp0x/static_assert3.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fstatic_assert3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fstatic_assert3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fstatic_assert3.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -1,3 +1,4 @@\n // { dg-options \"-std=c++0x\" }\n static_assert(7 / 0, \"X\"); // { dg-error \"non-constant condition\" }\n // { dg-warning \"division by zero\" \"\" { target *-*-* } 2 }\n+// { dg-error \"7 / 0.. is not a constant expression\" \"\" { target *-*-* } 2 }"}, {"sha": "23d34546e0b108e2d70a7086b2813717459b62e3", "filename": "gcc/testsuite/g++.dg/other/fold1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ffold1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ffold1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ffold1.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -4,5 +4,5 @@\n struct A\n {\n     static const int i = i;  // { dg-error \"not declared\" }\n-    int x[i];\n+    int x[i];\t\t     // { dg-error \"constant-expression\" }\n };"}, {"sha": "b2c112ce714a2b8367c42b5ed81e52fdad001d6e", "filename": "gcc/testsuite/g++.dg/parse/constant4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fconstant4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fconstant4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fconstant4.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -18,7 +18,7 @@ void Foo ()\n   \n   static const unsigned J = X<T>::J;\n   \n-  Y<J> j; // { dg-error \"non-constant\" \"\" }\n+  Y<J> j; // { dg-error \"constant\" \"\" }\n }\n \n struct A "}, {"sha": "a5a142c2e0f1b871f9721f167473ece92be38c32", "filename": "gcc/testsuite/g++.dg/parse/crash36.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash36.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash36.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash36.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -9,4 +9,4 @@ template <typename... T> struct A\t// { dg-warning \"variadic templates\" }\n   static const int i = sizeof (++t);\t// { dg-error \"was not declared in this scope\" }\n };\n \n-int x[A <int>::i];\n+int x[A <int>::i];\t\t// { dg-error \"constant-expression\" }"}, {"sha": "87cbd0268238957ccc84d830f9ba04da14d71cae", "filename": "gcc/testsuite/g++.dg/template/arg5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farg5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farg5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farg5.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -5,5 +5,5 @@ template<bool> struct A;\n \n template<int> void foo()\n {\n-  A<__builtin_constant_p(.)> a;  // { dg-error \"template argument\" }\n+  A<__builtin_constant_p(.)> a;  // { dg-error \"template argument|invalid\" }\n }"}, {"sha": "1891cad304cc539df1e26e2f0a0f1bd318413f6e", "filename": "gcc/testsuite/g++.dg/template/non-dependent10.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent10.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -18,5 +18,5 @@ struct X\n template <class T>\n struct Foo\n {\n-  X<&S::f> x;\t// { dg-error \"convert|no type\" }\n+  X<&S::f> x;\t// { dg-error \"convert|no matches\" }\n };"}, {"sha": "1fc1cc320506b5d86ad214b762c6dfb500974690", "filename": "gcc/testsuite/g++.dg/template/qualified-id3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualified-id3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualified-id3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualified-id3.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -3,7 +3,7 @@\n template <const int N> struct A { };\n template <class T> struct B {\n   static const int c;\n-  typedef A<B<T>::c> C;\t\t// { dg-error \"non-constant\" }\n+  typedef A<B<T>::c> C;\t\t// { dg-error \"constant expression\" }\n };\n template <class T> const int B<T>::c = sizeof (T);\n "}, {"sha": "17bd06783dc088b212aa468e6392e6f9e3daf33b", "filename": "gcc/testsuite/g++.dg/warn/overflow-warn-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-1.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -13,7 +13,7 @@ enum e {\n      in the standard).  */\n   E2 = 2 || 1 / 0, /* { dg-bogus \"warning: division by zero\" \"\" { xfail *-*-* } 14 } */\n   E3 = 1 / 0, /* { dg-warning \"division by zero\" } */\n-  /* { dg-error \"enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n+  /* { dg-error \"enumerator value for 'E3' is not an integer constant|not a constant expression\" \"enum error\" { target *-*-* } 15 } */\n   /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n      whole expression violates the constraints.  */\n   E4 = 0 * (1 / 0), /* { dg-warning \"division by zero\" } */"}, {"sha": "ce03a9781e4bcb138f61c1081e6601b83194020e", "filename": "gcc/testsuite/g++.dg/warn/overflow-warn-3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-3.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -13,7 +13,7 @@ enum e {\n      in the standard).  */\n   E2 = 2 || 1 / 0, /* { dg-bogus \"warning: division by zero\" \"\" { xfail *-*-* } 14 } */\n   E3 = 1 / 0, /* { dg-warning \"division by zero\" } */\n-  /* { dg-error \"enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n+  /* { dg-error \"enumerator value for 'E3' is not an integer constant|not a constant expression\" \"enum error\" { target *-*-* } 15 } */\n   /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n      whole expression violates the constraints.  */\n   E4 = 0 * (1 / 0), /* { dg-warning \"division by zero\" } */"}, {"sha": "0c916d0929c2eaadf21bf9029286a5fc99819fe6", "filename": "gcc/testsuite/g++.dg/warn/overflow-warn-4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-4.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -13,7 +13,7 @@ enum e {\n      in the standard).  */\n   E2 = 2 || 1 / 0, /* { dg-bogus \"warning: division by zero\" \"\" { xfail *-*-* } 14 } */\n   E3 = 1 / 0, /* { dg-warning \"division by zero\" } */\n-  /* { dg-error \"enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n+  /* { dg-error \"enumerator value for 'E3' is not an integer constant|not a constant expression\" \"enum error\" { target *-*-* } 15 } */\n   /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n      whole expression violates the constraints.  */\n   E4 = 0 * (1 / 0), /* { dg-warning \"division by zero\" } */"}, {"sha": "af0e919fe5f4e10c074cd9c3d2b0c56d135fdc24", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash10.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash10.C?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -4,7 +4,7 @@ template<int M, int N>\n class GCD {\n public:\n   enum { val = (N == 0) ? M : GCD<N, M % N>::val }; // { dg-warning \"division\" \"division\" }\n-// { dg-error \"not a valid\" \"valid\" { target *-*-* } 6 }\n+// { dg-error \"constant expression\" \"valid\" { target *-*-* } 6 }\n };\n \n int main() {"}, {"sha": "c7617690fe2bd3f43c27180d763fe90d52ba7208", "filename": "libstdc++-v3/testsuite/20_util/ratio/cons/cons_overflow_neg.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fratio%2Fcons%2Fcons_overflow_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fratio%2Fcons%2Fcons_overflow_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fratio%2Fcons%2Fcons_overflow_neg.cc?ref=fa2200cbb1ef5a6a7bdb9a5ba708c7400eb6b404", "patch": "@@ -51,3 +51,6 @@ test04()\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 46 }\n // { dg-error \"denominator cannot be zero\" \"\" { target *-*-* } 153 }\n // { dg-error \"out of range\" \"\" { target *-*-* } 154 }\n+// { dg-error \"constant expression\" \"\" { target *-*-* } 59 }\n+// { dg-error \"not a member\" \"\" { target *-*-* } 162 }\n+// { dg-error \"not a valid template argument\" \"\" { target *-*-* } 164 }"}]}