{"sha": "39dfb55a01f2182839d6537fbfc56361f9d1e008", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzlkZmI1NWEwMWYyMTgyODM5ZDY1MzdmYmZjNTYzNjFmOWQxZTAwOA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-08-25T15:00:44Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-08-25T15:00:44Z"}, "message": "version.c: Bump for new snapshot.\n\n        * version.c: Bump for new snapshot.\n\n        * local-alloc.c (update_equiv_regs): All the target to reject\n        promotion of some REG_EQUAL to REG_EQUIV notes.\n        * pa.h (DONT_RECORD_EQUIVALENCE): Define.\nFixes some c-torture failures, also improves generated code.\n\n        * pa.c (secondary_reload_class): (mem (mem ... )) does not need\n        secondary reloads.\nFixes 094.fpppp/twldrv.f abort.\n\n        * pa.c (hppa_builtin_saveregs): Emit a blockage insn after the\n        store of the argument registers.\nFixes c-torture failure.\n\n        * fold-const.c (multiple_of_p): New function.\n        (fold): Turn some cases of *_DIV_EXPR into EXACT_DIV_EXPR.\nOne of the performance patches from the g77 folks.\n\nFrom-SVN: r14915", "tree": {"sha": "323997d9502c515d35fc7ddcee0665d6c52285a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/323997d9502c515d35fc7ddcee0665d6c52285a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39dfb55a01f2182839d6537fbfc56361f9d1e008", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39dfb55a01f2182839d6537fbfc56361f9d1e008", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39dfb55a01f2182839d6537fbfc56361f9d1e008", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39dfb55a01f2182839d6537fbfc56361f9d1e008/comments", "author": null, "committer": null, "parents": [{"sha": "d78778ebf903a8b405a54d863af499626cb76b11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d78778ebf903a8b405a54d863af499626cb76b11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d78778ebf903a8b405a54d863af499626cb76b11"}], "stats": {"total": 195, "additions": 194, "deletions": 1}, "files": [{"sha": "316692683826be576e38192511b9518eaf9566b9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39dfb55a01f2182839d6537fbfc56361f9d1e008/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39dfb55a01f2182839d6537fbfc56361f9d1e008/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=39dfb55a01f2182839d6537fbfc56361f9d1e008", "patch": "@@ -1,3 +1,22 @@\n+Mon Aug 25 08:55:00 1997  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* version.c: Bump for new snapshot.\n+\n+\t* local-alloc.c (update_equiv_regs): All the target to reject\n+\tpromotion of some REG_EQUAL to REG_EQUIV notes.\n+\t* pa.h (DONT_RECORD_EQUIVALENCE): Define.\n+\n+\t* pa.c (secondary_reload_class): (mem (mem ... )) does not need\n+\tsecondary reloads.\n+\n+\t* pa.c (hppa_builtin_saveregs): Emit a blockage insn after the\n+\tstore of the argument registers.\n+\n+Mon Aug 25 08:39:02 1997  Craig Burley  (burley@gnu.ai.mit.edu)\n+\n+\t* fold-const.c (multiple_of_p): New function.\n+\t(fold): Turn some cases of *_DIV_EXPR into EXACT_DIV_EXPR.\n+\n Mon Aug 25 01:47:41 1997  Jeffrey A Law  (law@cygnus.com)\n \n \t* expr.h (insn_gen_function): Temporarily remove prototype."}, {"sha": "b809f4c8dbf8d4a203555c1ca096f0f8484ae0f3", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39dfb55a01f2182839d6537fbfc56361f9d1e008/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39dfb55a01f2182839d6537fbfc56361f9d1e008/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=39dfb55a01f2182839d6537fbfc56361f9d1e008", "patch": "@@ -4195,6 +4195,15 @@ secondary_reload_class (class, mode, in)\n   else\n     regno = -1;\n \n+  /* If we have something like (mem (mem (...)), we can safely assume the\n+     inner MEM will end up in a general register after reloading, so there's\n+     no need for a secondary reload.  */\n+  if (GET_CODE (in) == MEM\n+      && GET_CODE (XEXP (in, 0)) == MEM)\n+    return NO_REGS;\n+\n+  /* Handle out of range displacement for integer mode loads/stores of\n+     FP registers.  */\n   if (((regno >= FIRST_PSEUDO_REGISTER || regno == -1)\n        && GET_MODE_CLASS (mode) == MODE_INT\n        && FP_REG_CLASS_P (class))\n@@ -4223,6 +4232,7 @@ secondary_reload_class (class, mode, in)\n \t\t\t|| GET_CODE (XEXP (tmp, 0)) == LABEL_REF)\n \t\t       && GET_CODE (XEXP (tmp, 1)) == CONST_INT);\n         break;\n+\n       default:\n         is_symbolic = 0;\n         break;\n@@ -4291,6 +4301,17 @@ hppa_builtin_saveregs (arglist)\n \t\t  plus_constant (current_function_internal_arg_pointer, -16));\n   move_block_from_reg (23, dest, 4, 4 * UNITS_PER_WORD);\n \n+  /* move_block_from_reg will emit code to store the argument registers\n+     individually as scalar stores.\n+\n+     However, other insns may later load from the same addresses for\n+     a struture load (passing a struct to a varargs routine).\n+\n+     The alias code assumes that such aliasing can never happen, so we\n+     have to keep memory referencing insns from moving up beyond the\n+     last argument register store.  So we emit a blockage insn here.  */\n+  emit_insn (gen_blockage ());\n+\n   if (flag_check_memory_usage)\n     emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n \t\t       dest, ptr_mode,"}, {"sha": "79bbac3d6692334790c7400161ff0e003e85a9ef", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39dfb55a01f2182839d6537fbfc56361f9d1e008/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39dfb55a01f2182839d6537fbfc56361f9d1e008/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=39dfb55a01f2182839d6537fbfc56361f9d1e008", "patch": "@@ -793,6 +793,20 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n   (!TARGET_SNAKE && (CLASS) == FP_REGS ? 1 :\t\t\t\t\\\n    ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+/* We do not want to record equivalences for expressions which are\n+   likely to cause a spill of %r1 if they are used by reload.\n+\n+   Nor do we want to record an equivalence of a constant expression\n+   that the target can not handle appearing in an insn, but which\n+   also must be accepted by LEGITIMATE_CONSTANT_P.\n+\n+   On the PA, these two goals are the same -- don't record any equivalences\n+   for symbolic operands that are not read_only_operands.  */\n+#define DONT_RECORD_EQUIVALENCE(NOTE) \\\n+  (symbolic_operand (XEXP (NOTE, 0), VOIDmode) \\\n+   && !read_only_operand (XEXP (NOTE, 0), VOIDmode))\n+\n \f\n /* Stack layout; function entry, exit and calling.  */\n "}, {"sha": "10b13f33f7c76239dc79d7778e30e4869a37e9ca", "filename": "gcc/fold-const.c", "status": "modified", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39dfb55a01f2182839d6537fbfc56361f9d1e008/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39dfb55a01f2182839d6537fbfc56361f9d1e008/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=39dfb55a01f2182839d6537fbfc56361f9d1e008", "patch": "@@ -91,6 +91,7 @@ static tree fold_range_test\tPROTO((tree));\n static tree unextend\t\tPROTO((tree, int, int, tree));\n static tree fold_truthop\tPROTO((enum tree_code, tree, tree, tree));\n static tree strip_compound_expr PROTO((tree, tree));\n+static int multiple_of_p\tPROTO((tree, tree, tree));\n \n #ifndef BRANCH_COST\n #define BRANCH_COST 1\n@@ -4548,6 +4549,17 @@ fold (expr)\n       if (integer_zerop (arg1))\n \treturn t;\n \n+      /* If arg0 is a multiple of arg1, then rewrite to the fastest div\n+\t operation, EXACT_DIV_EXPR.\n+\n+\t Note that only CEIL_DIV_EXPR is rewritten now, only because the\n+\t others seem to be faster in some cases.  This is probably just\n+\t due to more work being done to optimize others in expmed.c than on\n+\t EXACT_DIV_EXPR.  */\n+      if (code == CEIL_DIV_EXPR\n+\t  && multiple_of_p (type, arg0, arg1))\n+\treturn fold (build (EXACT_DIV_EXPR, type, arg0, arg1));\n+\n       /* If we have ((a / C1) / C2) where both division are the same type, try\n \t to simplify.  First see if C1 * C2 overflows or not.  */\n       if (TREE_CODE (arg0) == code && TREE_CODE (arg1) == INTEGER_CST\n@@ -5723,3 +5735,104 @@ fold (expr)\n       return t;\n     } /* switch (code) */\n }\n+\n+/* Determine if first argument is a multiple of second argument.\n+   Return 0 if it is not, or is not easily determined to so be.\n+\n+   An example of the sort of thing we care about (at this point --\n+   this routine could surely be made more general, and expanded\n+   to do what the *_DIV_EXPR's fold() cases do now) is discovering\n+   that\n+\n+     SAVE_EXPR (I) * SAVE_EXPR (J * 8)\n+\n+   is a multiple of\n+\n+     SAVE_EXPR (J * 8)\n+\n+   when we know that the two `SAVE_EXPR (J * 8)' nodes are the\n+   same node (which means they will have the same value at run\n+   time, even though we don't know when they'll be assigned).\n+\n+   This code also handles discovering that\n+\n+     SAVE_EXPR (I) * SAVE_EXPR (J * 8)\n+\n+   is a multiple of\n+\n+     8\n+\n+   (of course) so we don't have to worry about dealing with a\n+   possible remainder.\n+\n+   Note that we _look_ inside a SAVE_EXPR only to determine\n+   how it was calculated; it is not safe for fold() to do much\n+   of anything else with the internals of a SAVE_EXPR, since\n+   fold() cannot know when it will be evaluated at run time.\n+   For example, the latter example above _cannot_ be implemented\n+   as\n+\n+     SAVE_EXPR (I) * J\n+\n+   or any variant thereof, since the value of J at evaluation time\n+   of the original SAVE_EXPR is not necessarily the same at the time\n+   the new expression is evaluated.  The only optimization of this\n+   sort that would be valid is changing\n+\n+     SAVE_EXPR (I) * SAVE_EXPR (SAVE_EXPR (J) * 8)\n+   divided by\n+     8\n+\n+   to\n+\n+     SAVE_EXPR (I) * SAVE_EXPR (J)\n+\n+   (where the same SAVE_EXPR (J) is used in the original and the\n+   transformed version).  */\n+\n+static int\n+multiple_of_p (type, top, bottom)\n+     tree type;\n+     tree top;\n+     tree bottom;\n+{\n+  if (operand_equal_p (top, bottom, 0))\n+    return 1;\n+\n+  if (TREE_CODE (type) != INTEGER_TYPE)\n+    return 0;\n+\n+  switch (TREE_CODE (top))\n+    {\n+    case MULT_EXPR:\n+      return (multiple_of_p (type, TREE_OPERAND (top, 0), bottom)\n+\t      || multiple_of_p (type, TREE_OPERAND (top, 1), bottom));\n+\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      return (multiple_of_p (type, TREE_OPERAND (top, 0), bottom)\n+\t      && multiple_of_p (type, TREE_OPERAND (top, 1), bottom));\n+\n+    case NOP_EXPR:\n+      /* Punt if conversion from non-integral or wider integral type.  */\n+      if ((TREE_CODE (TREE_TYPE (TREE_OPERAND (top, 0))) != INTEGER_TYPE)\n+\t  || (TYPE_PRECISION (type)\n+\t      < TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (top, 0)))))\n+\treturn 0;\n+      /* Fall through. */\n+    case SAVE_EXPR:\n+      return multiple_of_p (type, TREE_OPERAND (top, 0), bottom);\n+\n+    case INTEGER_CST:\n+      if ((TREE_CODE (bottom) != INTEGER_CST)\n+\t  || (tree_int_cst_sgn (top) < 0)\n+\t  || (tree_int_cst_sgn (bottom) < 0))\n+\treturn 0;\n+      return integer_zerop (const_binop (TRUNC_MOD_EXPR,\n+\t\t\t\t\t top, bottom, 0));\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\f"}, {"sha": "677801e8696820d5107b0059651a75ffeba99e25", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39dfb55a01f2182839d6537fbfc56361f9d1e008/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39dfb55a01f2182839d6537fbfc56361f9d1e008/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=39dfb55a01f2182839d6537fbfc56361f9d1e008", "patch": "@@ -1048,6 +1048,22 @@ update_equiv_regs ()\n \n       note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n \n+#ifdef DONT_RECORD_EQUIVALENCE\n+      /* Allow the target to reject promotions of some REG_EQUAL notes to\n+\t REG_EQUIV notes.\n+\n+\t In some cases this can improve register allocation if the existence\n+\t of the REG_EQUIV note is likely to increase the lifetime of a register\n+\t that is likely to be spilled.\n+\n+\t It may also be necessary if the target can't handle certain constant\n+\t expressions appearing randomly in insns, but for whatever reason\n+\t those expressions must be considered legitimate constant expressions\n+\t to prevent them from being forced into memory.  */\n+      if (note && DONT_RECORD_EQUIVALENCE (note))\n+        note = NULL;\n+#endif\n+\n       /* Record this insn as initializing this register.  */\n       reg_equiv_init_insn[regno] = insn;\n "}, {"sha": "d5e4c9fffa4fe3721b9c4cd1904dc320538b1f93", "filename": "gcc/tm.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39dfb55a01f2182839d6537fbfc56361f9d1e008/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39dfb55a01f2182839d6537fbfc56361f9d1e008/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=39dfb55a01f2182839d6537fbfc56361f9d1e008", "patch": "@@ -4177,6 +4177,16 @@ an immediate operand on the target machine.  You can assume that\n @var{x} satisfies @code{CONSTANT_P}, so you need not check this.  In fact,\n @samp{1} is a suitable definition for this macro on machines where\n anything @code{CONSTANT_P} is valid.@refill\n+\n+@findex DONT_RECORD_EQUIVALENCE\n+@item DONT_RECORD_EQUIVALENCE (@var{note})\n+A C expression that is nonzero if the @code{REG_EQUAL} note @var{x} should not\n+be promoted to a @code{REG_EQUIV} note.\n+\n+Define this macro if @var{note} refers to a constant that must be accepted\n+by @code{LEGITIMATE_CONSTANT_P}, but must not appear as an immediate operand.\n+\n+Most machine descriptions do not need to define this macro.\n @end table\n \n @node Condition Code"}, {"sha": "ae1e4155d2f42c530be9d38b26459e7cedb9b345", "filename": "gcc/version.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39dfb55a01f2182839d6537fbfc56361f9d1e008/gcc%2Fversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39dfb55a01f2182839d6537fbfc56361f9d1e008/gcc%2Fversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fversion.c?ref=39dfb55a01f2182839d6537fbfc56361f9d1e008", "patch": "@@ -1 +1 @@\n-char *version_string = \"egcs-2.90.01 970821 (gcc2-970802 experimental)\";\n+char *version_string = \"egcs-2.90.02 970825 (gcc2-970802 experimental)\";"}]}