{"sha": "58595203f2ded150884358ebe299c034fffee588", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg1OTUyMDNmMmRlZDE1MDg4NDM1OGViZTI5OWMwMzRmZmZlZTU4OA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-11-16T03:42:28Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-11-16T03:42:28Z"}, "message": "cp-tree.h (build_enumerator): Change prototype.\n\n\t* cp-tree.h (build_enumerator): Change prototype.\n\t* decl.c (enum_next_value): Remove.\n\t(enum_overflow): Likewise.\n\t(init_decl_processing): Don't register enum_next_value as a root.\n\t(start_enum): Clear TYPE_VALUES for a redefined enum.\n\t(finish_enum): Reset the type of enumeration constants.\n\t(build_enumerator): Fix indentation.  Don't copy CONST_DECLs when\n\twe don't need to.  Maintain the TYPE_VALUES list and look there\n\tfor the previously defined enumeration constant.  Let enumeration\n\tconstants have the type of their values until the enumeration type\n\tis complete.\n\t* parse.y (enumlist_opt, enumlist, enumerator): Don't return a value.\n\t(structsp): Adjust.\n\t* parse.c: Regenerated.\n\t* pt.c (tsubst_enum): Adjust according to build_enumerator changes.\n\nFrom-SVN: r30544", "tree": {"sha": "8f024553e6c99a48931c5be3c4695973b30b2879", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f024553e6c99a48931c5be3c4695973b30b2879"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58595203f2ded150884358ebe299c034fffee588", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58595203f2ded150884358ebe299c034fffee588", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58595203f2ded150884358ebe299c034fffee588", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58595203f2ded150884358ebe299c034fffee588/comments", "author": null, "committer": null, "parents": [{"sha": "ff9655e94b9b1d3483abb43ae26e1393dc8829a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff9655e94b9b1d3483abb43ae26e1393dc8829a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff9655e94b9b1d3483abb43ae26e1393dc8829a1"}], "stats": {"total": 1849, "additions": 926, "deletions": 923}, "files": [{"sha": "47a88b7b9c0e2e379e0da6acd7b29babf94ab196", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58595203f2ded150884358ebe299c034fffee588/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58595203f2ded150884358ebe299c034fffee588/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=58595203f2ded150884358ebe299c034fffee588", "patch": "@@ -3480,7 +3480,7 @@ extern tree xref_tag_from_type\t\t\tPROTO((tree, tree, int));\n extern void xref_basetypes\t\t\tPROTO((tree, tree, tree, tree));\n extern tree start_enum\t\t\t\tPROTO((tree));\n extern tree finish_enum\t\t\t\tPROTO((tree));\n-extern tree build_enumerator\t\t\tPROTO((tree, tree, tree));\n+extern void build_enumerator\t\t\tPROTO((tree, tree, tree));\n extern int start_function\t\t\tPROTO((tree, tree, tree, int));\n extern void expand_start_early_try_stmts\tPROTO((void));\n extern void store_parm_decls\t\t\tPROTO((void));"}, {"sha": "11073f93ddb76ed33d16c703ce82cfae0c74f6f6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 114, "deletions": 88, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58595203f2ded150884358ebe299c034fffee588/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58595203f2ded150884358ebe299c034fffee588/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=58595203f2ded150884358ebe299c034fffee588", "patch": "@@ -290,15 +290,6 @@ tree static_aggregates;\n \n tree integer_two_node, integer_three_node;\n \n-/* While defining an enum type, this is 1 plus the last enumerator\n-   constant value.  */\n-\n-static tree enum_next_value;\n-\n-/* Nonzero means that there was overflow computing enum_next_value.  */\n-\n-static int enum_overflow;\n-\n /* Parsing a function declarator leaves here a chain of structure\n    and enum types declared in the parmlist.  */\n \n@@ -6336,7 +6327,6 @@ init_decl_processing ()\n   ggc_add_tree_root (&static_dtors, 1);\n   ggc_add_tree_root (&lastiddecl, 1);\n \n-  ggc_add_tree_root (&enum_next_value, 1);\n   ggc_add_tree_root (&last_function_parm_tags, 1);\n   ggc_add_tree_root (&current_function_return_value, 1);\n   ggc_add_tree_root (&current_function_parms, 1);\n@@ -12328,6 +12318,8 @@ start_enum (name)\n     {\n       cp_error (\"multiple definition of `%#T'\", enumtype);\n       cp_error_at (\"previous definition here\", enumtype);\n+      /* Clear out TYPE_VALUES, and start again.  */\n+      TYPE_VALUES (enumtype) = NULL_TREE;\n     }\n   else\n     {\n@@ -12338,10 +12330,6 @@ start_enum (name)\n   if (current_class_type)\n     TREE_ADDRESSABLE (b->tags) = 1;\n \n-  /* We don't copy this value because build_enumerator needs to do it.  */\n-  enum_next_value = integer_zero_node;\n-  enum_overflow = 0;\n-\n   GNU_xref_decl (current_function_decl, enumtype);\n   return enumtype;\n }\n@@ -12372,6 +12360,14 @@ finish_enum (enumtype)\n \t     constant.  */\n \t  decl = TREE_VALUE (pair);\n \n+\t  /* [dcl.enum]\n+\n+\t     Following the closing brace of an enum-specifier, each\n+\t     enumerator has the type of its enumeration.  Prior to the\n+\t     closing brace, the type of each enumerator is the type of\n+\t     its initializing value.  */\n+\t  TREE_TYPE (decl) = enumtype;\n+\n \t  /* The DECL_INITIAL will be NULL if we are processing a\n \t     template declaration and this enumeration constant had no\n \t     explicit initializer.  */\n@@ -12474,101 +12470,131 @@ finish_enum (enumtype)\n }\n \n /* Build and install a CONST_DECL for an enumeration constant of the\n-   enumeration type TYPE whose NAME and VALUE (if any) are provided.\n+   enumeration type ENUMTYPE whose NAME and VALUE (if any) are provided.\n    Assignment of sequential values by default is handled here.  */\n \n-tree\n-build_enumerator (name, value, type)\n+void\n+build_enumerator (name, value, enumtype)\n      tree name;\n      tree value;\n-     tree type;\n+     tree enumtype;\n {\n-  tree decl, result;\n+  tree decl;\n   tree context;\n+  tree type;\n+  tree values;\n \n   /* Remove no-op casts from the value.  */\n   if (value)\n     STRIP_TYPE_NOPS (value);\n \n- if (! processing_template_decl)\n-   {\n-     /* Validate and default VALUE.  */\n-     if (value != NULL_TREE)\n-       {\n-\t if (TREE_READONLY_DECL_P (value))\n-\t   value = decl_constant_value (value);\n-\n-\t if (TREE_CODE (value) == INTEGER_CST)\n-\t   {\n-\t     value = default_conversion (value);\n-\t     constant_expression_warning (value);\n-\t   }\n-\t else\n-\t   {\n-\t     cp_error (\"enumerator value for `%D' not integer constant\", name);\n-\t     value = NULL_TREE;\n-\t   }\n-       }\n-\n-     /* Default based on previous value.  */\n-     if (value == NULL_TREE && ! processing_template_decl)\n-       {\n-\t value = enum_next_value;\n-\t if (enum_overflow)\n-\t   cp_error (\"overflow in enumeration values at `%D'\", name);\n-       }\n-\n-     /* Remove no-op casts from the value.  */\n-     if (value)\n-       STRIP_TYPE_NOPS (value);\n+  if (! processing_template_decl)\n+    {\n+      /* Validate and default VALUE.  */\n+      if (value != NULL_TREE)\n+\t{\n+\t  if (TREE_READONLY_DECL_P (value))\n+\t    value = decl_constant_value (value);\n+\n+\t  if (TREE_CODE (value) == INTEGER_CST)\n+\t    {\n+\t      value = default_conversion (value);\n+\t      constant_expression_warning (value);\n+\t    }\n+\t  else\n+\t    {\n+\t      cp_error (\"enumerator value for `%D' not integer constant\", name);\n+\t      value = NULL_TREE;\n+\t    }\n+\t}\n+\n+      /* Default based on previous value.  */\n+      if (value == NULL_TREE && ! processing_template_decl)\n+\t{\n+\t  tree prev_value;\n+\n+\t  if (TYPE_VALUES (enumtype))\n+\t    {\n+\t      /* The next value is the previous value ... */\n+\t      prev_value = DECL_INITIAL (TREE_VALUE (TYPE_VALUES (enumtype)));\n+\t      /* ... plus one.  */\n+\t      value = build_binary_op_nodefault (PLUS_EXPR,\n+\t\t\t\t\t\t prev_value,\n+\t\t\t\t\t\t integer_one_node,\n+\t\t\t\t\t\t PLUS_EXPR);\n+\t      \n+\t      if (tree_int_cst_lt (value, prev_value))\n+\t\tcp_error (\"overflow in enumeration values at `%D'\", name);\n+\t    }\n+\t  else\n+\t    value = integer_zero_node;\n+\t}\n+\n+      /* Remove no-op casts from the value.  */\n+      if (value)\n+\tSTRIP_TYPE_NOPS (value);\n #if 0\n-     /* To fix MAX_VAL enum consts. (bkoz)  */\n-     TREE_TYPE (value) = integer_type_node;\n+      /* To fix MAX_VAL enum consts. (bkoz)  */\n+      TREE_TYPE (value) = integer_type_node;\n #endif\n-   }\n+    }\n \n- /* We always have to copy here; not all INTEGER_CSTs are unshared.\n-    Even in other cases, we will later (in finish_enum) be setting the\n-    type of VALUE.  */\n- if (value != NULL_TREE)\n-   value = copy_node (value);\n+  /* We always have to copy here; not all INTEGER_CSTs are unshared.\n+     Even in other cases, we will later (in finish_enum) be setting\n+     the type of VALUE.  But, we don't need to make a copy if this\n+     VALUE is one of the enumeration constants for this same\n+     enumeration type.  */\n+  for (values = TYPE_VALUES (enumtype); values; values = TREE_CHAIN (values))\n+    if (TREE_VALUE (values) == value)\n+      break;\n+  /* If we didn't break out of the loop, then we do need a copy.  */\n+  if (!values && value)\n+    value = copy_node (value);\n \n   /* C++ associates enums with global, function, or class declarations.  */\n- \n- context = current_scope ();\n- if (context && context == current_class_type)\n-   /* This enum declaration is local to the class.  */\n-   decl = build_lang_decl (CONST_DECL, name, type);\n- else\n-   /* It's a global enum, or it's local to a function.  (Note local to\n+  context = current_scope ();\n+\n+  /* Build the actual enumeration constant.  Note that the enumeration\n+    constants have the type of their initializers until the\n+    enumeration is complete:\n+\n+      [ dcl.enum ]\n+\n+      Following the closing brace of an enum-specifier, each enumer-\n+      ator has the type of its enumeration.  Prior to the closing\n+      brace, the type of each enumerator is the type of its\n+      initializing value.\n+\n+    In finish_enum we will reset the type.  Of course, if we're\n+    processing a template, there may be no value.   */\n+  type = value ? TREE_TYPE (value) : NULL_TREE;\n+\n+  if (context && context == current_class_type)\n+    /* This enum declaration is local to the class.  We need the full\n+      lang_decl so that we can record DECL_CLASS_CONTEXT, for example.  */\n+    decl = build_lang_decl (CONST_DECL, name, type);\n+  else\n+    /* It's a global enum, or it's local to a function.  (Note local to\n       a function could mean local to a class method.  */\n-   decl = build_decl (CONST_DECL, name, type);\n+    decl = build_decl (CONST_DECL, name, type);\n \n- DECL_CONTEXT (decl) = FROB_CONTEXT (context);\n- DECL_INITIAL (decl) = value;\n- TREE_READONLY (decl) = 1;\n+  DECL_CONTEXT (decl) = FROB_CONTEXT (context);\n+  DECL_INITIAL (decl) = value;\n+  TREE_READONLY (decl) = 1;\n \n- if (context && context == current_class_type)\n-   /* In something like `struct S { enum E { i = 7 }; };' we put `i'\n+  if (context && context == current_class_type)\n+    /* In something like `struct S { enum E { i = 7 }; };' we put `i'\n       on the TYPE_FIELDS list for `S'.  (That's so that you can say\n       things like `S::i' later.)  */\n-   finish_member_declaration (decl);\n- else\n-   {\n-     pushdecl (decl);\n-     GNU_xref_decl (current_function_decl, decl);\n-   }\n-\n- if (! processing_template_decl)\n-   {\n-     /* Set basis for default for next value.  */\n-     enum_next_value = build_binary_op_nodefault (PLUS_EXPR, value,\n-\t\t\t\t\t\t  integer_one_node, PLUS_EXPR);\n-     enum_overflow = tree_int_cst_lt (enum_next_value, value);\n-   }\n-\n-  result = tree_cons (name, decl, NULL_TREE);\n-  return result;\n+    finish_member_declaration (decl);\n+  else\n+    {\n+      pushdecl (decl);\n+      GNU_xref_decl (current_function_decl, decl);\n+    }\n+\n+  /* Add this enumeration constant to the list for this type.  */\n+  TYPE_VALUES (enumtype) = tree_cons (name, decl, TYPE_VALUES (enumtype));\n }\n \n \f"}, {"sha": "7d54c52df1a9886b637ab973d3dbdf0db7959fcc", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 805, "deletions": 815, "changes": 1620, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58595203f2ded150884358ebe299c034fffee588/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58595203f2ded150884358ebe299c034fffee588/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=58595203f2ded150884358ebe299c034fffee588"}, {"sha": "de8b450272b1664d01548df6ebc6ddfdf58aa0ae", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58595203f2ded150884358ebe299c034fffee588/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58595203f2ded150884358ebe299c034fffee588/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=58595203f2ded150884358ebe299c034fffee588", "patch": "@@ -215,7 +215,6 @@ empty_parms ()\n %type <ttype> component_declarator component_declarator0\n %type <ttype> notype_component_declarator notype_component_declarator0\n %type <ttype> after_type_component_declarator after_type_component_declarator0\n-%type <ttype> enumlist_opt enumlist enumerator\n %type <ttype> absdcl cv_qualifiers\n %type <ttype> direct_abstract_declarator conversion_declarator\n %type <ttype> new_declarator direct_new_declarator\n@@ -2062,17 +2061,15 @@ structsp:\n \t\t{ $<ttype>$ = current_enum_type;\n \t\t  current_enum_type = start_enum ($2); }\n \t  enumlist_opt '}'\n-\t\t{ TYPE_VALUES (current_enum_type) = $5;\n-\t\t  $$.t = finish_enum (current_enum_type);\n+\t\t{ $$.t = finish_enum (current_enum_type);\n \t\t  $$.new_type_flag = 1;\n \t\t  current_enum_type = $<ttype>4;\n \t\t  check_for_missing_semicolon ($$.t); }\n \t| ENUM '{'\n \t\t{ $<ttype>$ = current_enum_type;\n \t\t  current_enum_type = start_enum (make_anon_name ()); }\n \t  enumlist_opt '}'\n-                { TYPE_VALUES (current_enum_type) = $4;\n-\t\t  $$.t = finish_enum (current_enum_type);\n+                { $$.t = finish_enum (current_enum_type);\n \t\t  $$.new_type_flag = 1;\n \t\t  current_enum_type = $<ttype>3;\n \t\t  check_for_missing_semicolon ($$.t); }\n@@ -2578,7 +2575,6 @@ notype_component_declarator:\n enumlist_opt:\n \t  enumlist maybecomma_warn\n \t| maybecomma_warn\n-\t  { $$ = NULL_TREE; }\n \t;\n \n /* We chain the enumerators in reverse order.\n@@ -2588,14 +2584,13 @@ enumlist_opt:\n enumlist:\n \t  enumerator\n \t| enumlist ',' enumerator\n-\t\t{ TREE_CHAIN ($3) = $$; $$ = $3; }\n \t;\n \n enumerator:\n \t  identifier\n-\t\t{ $$ = build_enumerator ($$, NULL_TREE, current_enum_type); }\n+\t\t{ build_enumerator ($1, NULL_TREE, current_enum_type); }\n \t| identifier '=' expr_no_commas\n-\t\t{ $$ = build_enumerator ($$, $3, current_enum_type); }\n+\t\t{ build_enumerator ($1, $3, current_enum_type); }\n \t;\n \n /* ANSI new-type-id (5.3.4) */"}, {"sha": "7e72accd62f0874942d404044445966d7fee5c8f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58595203f2ded150884358ebe299c034fffee588/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58595203f2ded150884358ebe299c034fffee588/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=58595203f2ded150884358ebe299c034fffee588", "patch": "@@ -9737,8 +9737,7 @@ tsubst_enum (tag, newtag, args)\n   for (e = TYPE_VALUES (tag); e; e = TREE_CHAIN (e))\n     {\n       tree value;\n-      tree elt;\n-\n+      \n       /* Note that in a template enum, the TREE_VALUE is the\n \t CONST_DECL, not the corresponding INTEGER_CST.  */\n       value = tsubst_expr (DECL_INITIAL (TREE_VALUE (e)), \n@@ -9749,14 +9748,7 @@ tsubst_enum (tag, newtag, args)\n       set_current_access_from_decl (TREE_VALUE (e));\n \n       /* Actually build the enumerator itself.  */\n-      elt = build_enumerator (TREE_PURPOSE (e), value, newtag); \n-\n-      /* We save the enumerators we have built so far in the\n-\t TYPE_VALUES so that if the enumeration constants for\n-\t subsequent enumerators involve those for previous ones,\n-\t tsubst_copy will be able to find them.  */\n-      TREE_CHAIN (elt) = TYPE_VALUES (newtag);\n-      TYPE_VALUES (newtag) = elt;\n+      build_enumerator (TREE_PURPOSE (e), value, newtag); \n     }\n \n   finish_enum (newtag);"}]}