{"sha": "628c189edb5aae6b4e1d416a92cbd0cb9f68586f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI4YzE4OWVkYjVhYWU2YjRlMWQ0MTZhOTJjYmQwY2I5ZjY4NTg2Zg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-03-27T23:00:22Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-03-27T23:00:22Z"}, "message": "gimplify.c (mark_addressable): Export.\n\n2009-03-27  Richard Guenther  <rguenther@suse.de>\n\n\t* gimplify.c (mark_addressable): Export.\n\t* tree-flow.h (mark_addressable): Declare.\n\t* tree-ssa-loop-manip.c (create_iv): Mark the base addressable.\n\t* tree-ssa.c (verify_phi_args): Verify that address taken\n\tvariables have TREE_ADDRESSABLE set.\n\n2009-03-27  Richard Guenther  <rguenther@suse.de>\n\n\t* fold-const.c (build_fold_addr_expr_with_type_1): Rename back to ...\n\t(build_fold_addr_expr_with_type): ... this.  Remove in_fold handling.\n\tDo not mark decls TREE_ADDRESSABLE.\n\t(build_fold_addr_expr): Adjust.\n\t(fold_addr_expr): Remove.\n\t(fold_unary): Use build_fold_addr_expr.\n\t(fold_comparison): Likewise.\n\t(split_address_to_core_and_offset): Likewise.\n\t* coverage.c (tree_coverage_counter_addr): Mark the array decl\n\tTREE_ADDRESSABLE.\n\t* gimplify.c (mark_addressable): Do not exclude RESULT_DECLs.\n\t(gimplify_modify_expr_to_memcpy): Mark source and destination\n\taddressable.\n\t* omp-low.c (create_omp_child_function): Mark the object decl\n\tTREE_ADDRESSABLE.\n\t(lower_rec_input_clauses): Mark the var we take the address of\n\tTREE_ADDRESSABLE.\n\t(lower_omp_taskreg): Mark the sender decl TREE_ADDRESSABLE.\n\n\tfortran/\n\t* trans-array.c (gfc_conv_descriptor_data_addr): Use\n\tgfc_build_addr_expr instead of build_fold_addr_expr.\n\t(gfc_trans_allocate_array_storage, gfc_trans_array_constructor_value,\n\tgfc_trans_constant_array_constructor, gfc_conv_array_data,\n\tgfc_conv_expr_descriptor, gfc_conv_array_parameter): Likewise.\n\t* trans-expr.c (gfc_conv_missing_dummy, gfc_conv_variable,\n\tgfc_conv_function_val, gfc_conv_operator_assign,\n\tgfc_conv_subref_array_arg, gfc_conv_function_call,\n\tgfc_conv_expr_reference, gfc_trans_scalar_assign): Likewise.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_exponent,\n\tgfc_conv_intrinsic_ctime, gfc_conv_intrinsic_fdate,\n\tgfc_conv_intrinsic_ttynam, gfc_conv_intrinsic_minmax_char,\n\tgfc_conv_intrinsic_fraction, gfc_conv_intrinsic_spacing,\n\tgfc_conv_intrinsic_rrspacing, gfc_conv_intrinsic_set_exponent,\n\tgfc_conv_intrinsic_array_transfer, gfc_conv_intrinsic_transfer,\n\tgfc_conv_intrinsic_si_kind, gfc_conv_intrinsic_trim): Likewise.\n\t* trans-io.c (gfc_trans_io_runtime_check, set_parameter_ref,\n\tgfc_convert_array_to_string, gfc_trans_open, gfc_trans_close,\n\tbuild_filepos, gfc_trans_inquire, gfc_trans_wait,\n\tnml_get_addr_expr, transfer_namelist_element, build_dt,\n\tgfc_trans_dt_end, transfer_array_component, transfer_expr,\n\ttransfer_array_desc, gfc_trans_transfer): Likewise.\n\t* trans-stmt.c (gfc_trans_allocate, gfc_trans_deallocate): Likewise.\n\t* trans.c (gfc_build_addr_expr): Mark the base of the address\n\tTREE_ADDRESSABLE.\n\nFrom-SVN: r145142", "tree": {"sha": "1d480e401b2ea473d780770388aea56b9a1a1c68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d480e401b2ea473d780770388aea56b9a1a1c68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/628c189edb5aae6b4e1d416a92cbd0cb9f68586f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/628c189edb5aae6b4e1d416a92cbd0cb9f68586f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/628c189edb5aae6b4e1d416a92cbd0cb9f68586f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0387122d055068bd3f76eb14f3b5f2ee77f21aee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0387122d055068bd3f76eb14f3b5f2ee77f21aee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0387122d055068bd3f76eb14f3b5f2ee77f21aee"}], "stats": {"total": 249, "additions": 134, "deletions": 115}, "files": [{"sha": "8eb30acb90d5215019ed59b7d9b5abcdf06fd1b3", "filename": "gcc/coverage.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=628c189edb5aae6b4e1d416a92cbd0cb9f68586f", "patch": "@@ -459,6 +459,8 @@ tree_coverage_counter_addr (unsigned counter, unsigned no)\n   gcc_assert (no < fn_n_ctrs[counter] - fn_b_ctrs[counter]);\n   no += prg_n_ctrs[counter] + fn_b_ctrs[counter];\n \n+  TREE_ADDRESSABLE (tree_ctr_tables[counter]) = 1;\n+\n   /* \"no\" here is an array index, scaled to bytes later.  */\n   return build_fold_addr_expr (build4 (ARRAY_REF, gcov_type_node,\n \t\t\t\t       tree_ctr_tables[counter],"}, {"sha": "4ca91a22d980123455dce4cc3200897d06afa9d9", "filename": "gcc/fold-const.c", "status": "modified", "additions": 9, "deletions": 46, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=628c189edb5aae6b4e1d416a92cbd0cb9f68586f", "patch": "@@ -7937,11 +7937,10 @@ fold_view_convert_expr (tree type, tree expr)\n }\n \n /* Build an expression for the address of T.  Folds away INDIRECT_REF\n-   to avoid confusing the gimplify process.  When IN_FOLD is true\n-   avoid modifications of T.  */\n+   to avoid confusing the gimplify process.  */\n \n-static tree\n-build_fold_addr_expr_with_type_1 (tree t, tree ptrtype, bool in_fold)\n+tree\n+build_fold_addr_expr_with_type (tree t, tree ptrtype)\n {\n   /* The size of the object is not relevant when talking about its address.  */\n   if (TREE_CODE (t) == WITH_SIZE_EXPR)\n@@ -7956,56 +7955,20 @@ build_fold_addr_expr_with_type_1 (tree t, tree ptrtype, bool in_fold)\n       if (TREE_TYPE (t) != ptrtype)\n \tt = build1 (NOP_EXPR, ptrtype, t);\n     }\n-  else if (!in_fold)\n-    {\n-      tree base = t;\n-\n-      while (handled_component_p (base))\n-\tbase = TREE_OPERAND (base, 0);\n-\n-      if (DECL_P (base))\n-\tTREE_ADDRESSABLE (base) = 1;\n-\n-      t = build1 (ADDR_EXPR, ptrtype, t);\n-    }\n   else\n     t = build1 (ADDR_EXPR, ptrtype, t);\n \n   return t;\n }\n \n-/* Build an expression for the address of T with type PTRTYPE.  This\n-   function modifies the input parameter 'T' by sometimes setting the\n-   TREE_ADDRESSABLE flag.  */\n-\n-tree\n-build_fold_addr_expr_with_type (tree t, tree ptrtype)\n-{\n-  return build_fold_addr_expr_with_type_1 (t, ptrtype, false);\n-}\n-\n-/* Build an expression for the address of T.  This function modifies\n-   the input parameter 'T' by sometimes setting the TREE_ADDRESSABLE\n-   flag.  When called from fold functions, use fold_addr_expr instead.  */\n+/* Build an expression for the address of T.  */\n \n tree\n build_fold_addr_expr (tree t)\n-{\n-  return build_fold_addr_expr_with_type_1 (t, \n-\t\t\t\t\t   build_pointer_type (TREE_TYPE (t)),\n-\t\t\t\t\t   false);\n-}\n-\n-/* Same as build_fold_addr_expr, builds an expression for the address\n-   of T, but avoids touching the input node 't'.  Fold functions\n-   should use this version.  */\n-\n-static tree\n-fold_addr_expr (tree t)\n {\n   tree ptrtype = build_pointer_type (TREE_TYPE (t));\n \n-  return build_fold_addr_expr_with_type_1 (t, ptrtype, true);\n+  return build_fold_addr_expr_with_type (t, ptrtype);\n }\n \n /* Fold a unary expression of code CODE and type TYPE with operand\n@@ -8245,7 +8208,7 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \t  if (! offset && bitpos == 0\n \t      && TYPE_MAIN_VARIANT (TREE_TYPE (type))\n \t\t  == TYPE_MAIN_VARIANT (TREE_TYPE (base)))\n-\t    return fold_convert (type, fold_addr_expr (base));\n+\t    return fold_convert (type, build_fold_addr_expr (base));\n         }\n \n       if (TREE_CODE (op0) == MODIFY_EXPR\n@@ -9155,9 +9118,9 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n \t\t       && operand_equal_p (offset0, offset1, 0))))\n \t{\n \t  if (indirect_base0)\n-\t    base0 = fold_addr_expr (base0);\n+\t    base0 = build_fold_addr_expr (base0);\n \t  if (indirect_base1)\n-\t    base1 = fold_addr_expr (base1);\n+\t    base1 = build_fold_addr_expr (base1);\n \t  return fold_build2 (code, type, base0, base1);\n \t}\n     }\n@@ -15829,7 +15792,7 @@ split_address_to_core_and_offset (tree exp,\n       core = get_inner_reference (TREE_OPERAND (exp, 0), &bitsize, pbitpos,\n \t\t\t\t  poffset, &mode, &unsignedp, &volatilep,\n \t\t\t\t  false);\n-      core = fold_addr_expr (core);\n+      core = build_fold_addr_expr (core);\n     }\n   else\n     {"}, {"sha": "09084fba1c169a419cd83e6257cf1b742d468a35", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=628c189edb5aae6b4e1d416a92cbd0cb9f68586f", "patch": "@@ -1,3 +1,31 @@\n+2009-03-27  Richard Guenther  <rguenther@suse.de>\n+\n+\t* trans-array.c (gfc_conv_descriptor_data_addr): Use\n+\tgfc_build_addr_expr instead of build_fold_addr_expr.\n+\t(gfc_trans_allocate_array_storage, gfc_trans_array_constructor_value,\n+\tgfc_trans_constant_array_constructor, gfc_conv_array_data,\n+\tgfc_conv_expr_descriptor, gfc_conv_array_parameter): Likewise.\n+\t* trans-expr.c (gfc_conv_missing_dummy, gfc_conv_variable,\n+\tgfc_conv_function_val, gfc_conv_operator_assign,\n+\tgfc_conv_subref_array_arg, gfc_conv_function_call,\n+\tgfc_conv_expr_reference, gfc_trans_scalar_assign): Likewise.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_exponent,\n+\tgfc_conv_intrinsic_ctime, gfc_conv_intrinsic_fdate,\n+\tgfc_conv_intrinsic_ttynam, gfc_conv_intrinsic_minmax_char,\n+\tgfc_conv_intrinsic_fraction, gfc_conv_intrinsic_spacing,\n+\tgfc_conv_intrinsic_rrspacing, gfc_conv_intrinsic_set_exponent,\n+\tgfc_conv_intrinsic_array_transfer, gfc_conv_intrinsic_transfer,\n+\tgfc_conv_intrinsic_si_kind, gfc_conv_intrinsic_trim): Likewise.\n+\t* trans-io.c (gfc_trans_io_runtime_check, set_parameter_ref,\n+\tgfc_convert_array_to_string, gfc_trans_open, gfc_trans_close,\n+\tbuild_filepos, gfc_trans_inquire, gfc_trans_wait,\n+\tnml_get_addr_expr, transfer_namelist_element, build_dt,\n+\tgfc_trans_dt_end, transfer_array_component, transfer_expr,\n+\ttransfer_array_desc, gfc_trans_transfer): Likewise.\n+\t* trans-stmt.c (gfc_trans_allocate, gfc_trans_deallocate): Likewise.\n+\t* trans.c (gfc_build_addr_expr): Mark the base of the address\n+\tTREE_ADDRESSABLE.\n+\n 2009-03-27  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.h (enum init_local_real.): Add GFC_INIT_REAL_SNAN."}, {"sha": "6f750e63d849a22bf9a99765513854cc0e6f9aa7", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=628c189edb5aae6b4e1d416a92cbd0cb9f68586f", "patch": "@@ -194,7 +194,7 @@ gfc_conv_descriptor_data_addr (tree desc)\n   gcc_assert (DATA_FIELD == 0);\n \n   t = fold_build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n-  return build_fold_addr_expr (t);\n+  return gfc_build_addr_expr (NULL_TREE, t);\n }\n \n tree\n@@ -533,7 +533,7 @@ gfc_trans_allocate_array_storage (stmtblock_t * pre, stmtblock_t * post,\n \t  tmp = build_array_type (gfc_get_element_type (TREE_TYPE (desc)),\n \t\t\t\t  tmp);\n \t  tmp = gfc_create_var (tmp, \"A\");\n-\t  tmp = build_fold_addr_expr (tmp);\n+\t  tmp = gfc_build_addr_expr (NULL_TREE, tmp);\n \t  gfc_conv_descriptor_data_set (pre, desc, tmp);\n \t}\n       else\n@@ -1281,8 +1281,8 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t      tmp = gfc_conv_descriptor_data_get (desc);\n \t      tmp = build_fold_indirect_ref (tmp);\n \t      tmp = gfc_build_array_ref (tmp, *poffset, NULL);\n-\t      tmp = build_fold_addr_expr (tmp);\n-\t      init = build_fold_addr_expr (init);\n+\t      tmp = gfc_build_addr_expr (NULL_TREE, tmp);\n+\t      init = gfc_build_addr_expr (NULL_TREE, init);\n \n \t      size = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (type));\n \t      bound = build_int_cst (NULL_TREE, n * size);\n@@ -1683,7 +1683,7 @@ gfc_trans_constant_array_constructor (gfc_loopinfo * loop,\n   info = &ss->data.info;\n \n   info->descriptor = tmp;\n-  info->data = build_fold_addr_expr (tmp);\n+  info->data = gfc_build_addr_expr (NULL_TREE, tmp);\n   info->offset = gfc_index_zero_node;\n \n   for (i = 0; i < info->dimen; i++)\n@@ -2136,7 +2136,7 @@ gfc_conv_array_data (tree descriptor)\n       else\n         {\n           /* Descriptorless arrays.  */\n-\t  return build_fold_addr_expr (descriptor);\n+\t  return gfc_build_addr_expr (NULL_TREE, descriptor);\n         }\n     }\n   else\n@@ -4836,7 +4836,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t    {\n \t      /* We pass full arrays directly.  This means that pointers and\n \t\t allocatable arrays should also work.  */\n-\t      se->expr = build_fold_addr_expr (desc);\n+\t      se->expr = gfc_build_addr_expr (NULL_TREE, desc);\n \t    }\n \t  else\n \t    {\n@@ -4867,7 +4867,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \n \t  /* For pointer assignments pass the descriptor directly.  */\n \t  se->ss = secss;\n-\t  se->expr = build_fold_addr_expr (se->expr);\n+\t  se->expr = gfc_build_addr_expr (NULL_TREE, se->expr);\n \t  gfc_conv_expr (se, expr);\n \t  return;\n \t}\n@@ -5189,7 +5189,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n     {\n       /* Get a pointer to the new descriptor.  */\n       if (se->want_pointer)\n-\tse->expr = build_fold_addr_expr (desc);\n+\tse->expr = gfc_build_addr_expr (NULL_TREE, desc);\n       else\n \tse->expr = desc;\n     }\n@@ -5255,7 +5255,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77,\n           if (sym->attr.dummy || POINTER_TYPE_P (TREE_TYPE (tmp)))\n             se->expr = tmp;\n           else\n-\t    se->expr = build_fold_addr_expr (tmp);\n+\t    se->expr = gfc_build_addr_expr (NULL_TREE, tmp);\n \t  return;\n         }\n       if (sym->attr.allocatable)\n@@ -5275,7 +5275,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77,\n     {\n       /* Result of the enclosing function.  */\n       gfc_conv_expr_descriptor (se, expr, ss);\n-      se->expr = build_fold_addr_expr (se->expr);\n+      se->expr = gfc_build_addr_expr (NULL_TREE, se->expr);\n \n       if (g77 && TREE_TYPE (TREE_TYPE (se->expr)) != NULL_TREE\n \t      && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (TREE_TYPE (se->expr))))"}, {"sha": "89fcadf547cfbff632a35a76a8bc601525116463", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=628c189edb5aae6b4e1d416a92cbd0cb9f68586f", "patch": "@@ -164,7 +164,7 @@ gfc_conv_missing_dummy (gfc_se * se, gfc_expr * arg, gfc_typespec ts, int kind)\n       tmp = build3 (COND_EXPR, TREE_TYPE (tmp), present, tmp,\n \t\t    fold_convert (TREE_TYPE (tmp), integer_one_node));\n       tmp = gfc_evaluate_now (tmp, &se->pre);\n-      se->expr = build_fold_addr_expr (tmp);\n+      se->expr = gfc_build_addr_expr (NULL_TREE, tmp);\n     }\n   else\n     {\n@@ -603,7 +603,7 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \t  if (!sym->attr.dummy && !sym->attr.proc_pointer)\n \t    {\n \t      gcc_assert (TREE_CODE (se->expr) == FUNCTION_DECL);\n-\t      se->expr = build_fold_addr_expr (se->expr);\n+\t      se->expr = gfc_build_addr_expr (NULL_TREE, se->expr);\n \t    }\n \t  return;\n \t}\n@@ -705,7 +705,7 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n       if (expr->ts.type == BT_CHARACTER)\n \tgfc_conv_string_parameter (se);\n       else \n-\tse->expr = build_fold_addr_expr (se->expr);\n+\tse->expr = gfc_build_addr_expr (NULL_TREE, se->expr);\n     }\n }\n \n@@ -1519,7 +1519,7 @@ gfc_conv_function_val (gfc_se * se, gfc_symbol * sym)\n       if (!POINTER_TYPE_P (TREE_TYPE (tmp)))\n \t{\n \t  gcc_assert (TREE_CODE (tmp) == FUNCTION_DECL);\n-\t  tmp = build_fold_addr_expr (tmp);\n+\t  tmp = gfc_build_addr_expr (NULL_TREE, tmp);\n \t}\n     }\n   se->expr = tmp;\n@@ -1547,8 +1547,8 @@ gfc_conv_operator_assign (gfc_se *lse, gfc_se *rse, gfc_symbol *sym)\n   gfc_add_block_to_block (&block, &rse->pre);\n \n   /* Build the argument list for the call, including hidden string lengths.  */\n-  args = gfc_chainon_list (NULL_TREE, build_fold_addr_expr (lse->expr));\n-  args = gfc_chainon_list (args, build_fold_addr_expr (rse->expr));\n+  args = gfc_chainon_list (NULL_TREE, gfc_build_addr_expr (NULL_TREE, lse->expr));\n+  args = gfc_chainon_list (args, gfc_build_addr_expr (NULL_TREE, rse->expr));\n   if (lse->string_length != NULL_TREE)\n     args = gfc_chainon_list (args, lse->string_length);\n   if (rse->string_length != NULL_TREE)\n@@ -2371,7 +2371,7 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr,\n   if (g77)\n     parmse->expr = gfc_conv_descriptor_data_get (parmse->expr);\n   else\n-    parmse->expr = build_fold_addr_expr (parmse->expr);\n+    parmse->expr = gfc_build_addr_expr (NULL_TREE, parmse->expr);\n \n   return;\n }\n@@ -2666,7 +2666,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t  && fsym && fsym->attr.target)\n \t\t{\n \t\t  gfc_conv_expr (&parmse, e);\n-\t\t  parmse.expr = build_fold_addr_expr (parmse.expr);\n+\t\t  parmse.expr = gfc_build_addr_expr (NULL_TREE, parmse.expr);\n \t\t}\n \t      else\n \t\t{\n@@ -2680,7 +2680,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t indirection. The null pointer already contains\n \t\t\t this level of indirection.  */\n \t\t      parm_kind = SCALAR_POINTER;\n-\t\t      parmse.expr = build_fold_addr_expr (parmse.expr);\n+\t\t      parmse.expr = gfc_build_addr_expr (NULL_TREE, parmse.expr);\n \t\t    }\n \t\t}\n \t    }\n@@ -2881,7 +2881,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \n \t  /* Pass the temporary as the first argument.  */\n \t  tmp = info->descriptor;\n-\t  tmp = build_fold_addr_expr (tmp);\n+\t  tmp = gfc_build_addr_expr (NULL_TREE, tmp);\n \t  retargs = gfc_chainon_list (retargs, tmp);\n \t}\n       else if (ts.type == BT_CHARACTER)\n@@ -2897,7 +2897,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t      var = gfc_create_var (type, \"pstr\");\n \n \t      /* Provide an address expression for the function arguments.  */\n-\t      var = build_fold_addr_expr (var);\n+\t      var = gfc_build_addr_expr (NULL_TREE, var);\n \t    }\n \t  else\n \t    var = gfc_conv_string_tmp (se, type, len);\n@@ -2909,7 +2909,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t  gcc_assert (gfc_option.flag_f2c && ts.type == BT_COMPLEX);\n \n \t  type = gfc_get_complex_type (ts.kind);\n-\t  var = build_fold_addr_expr (gfc_create_var (type, \"cmplx\"));\n+\t  var = gfc_build_addr_expr (NULL_TREE, gfc_create_var (type, \"cmplx\"));\n \t  retargs = gfc_chainon_list (retargs, var);\n \t}\n \n@@ -2945,7 +2945,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t  TREE_TYPE (sym->backend_decl)\n \t\t= build_function_type (integer_type_node,\n \t\t      TYPE_ARG_TYPES (TREE_TYPE (sym->backend_decl)));\n-\t  se->expr = build_fold_addr_expr (sym->backend_decl);\n+\t  se->expr = gfc_build_addr_expr (NULL_TREE, sym->backend_decl);\n \t}\n       else\n \tTREE_TYPE (TREE_TYPE (TREE_TYPE (se->expr))) = integer_type_node;\n@@ -4010,7 +4010,7 @@ gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr)\n   gfc_add_block_to_block (&se->pre, &se->post);\n \n   /* Take the address of that value.  */\n-  se->expr = build_fold_addr_expr (var);\n+  se->expr = gfc_build_addr_expr (NULL_TREE, var);\n }\n \n \n@@ -4226,8 +4226,8 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n       if (r_is_var)\n \t{\n \t  cond = fold_build2 (EQ_EXPR, boolean_type_node,\n-\t\t\t      build_fold_addr_expr (lse->expr),\n-\t\t\t      build_fold_addr_expr (rse->expr));\n+\t\t\t      gfc_build_addr_expr (NULL_TREE, lse->expr),\n+\t\t\t      gfc_build_addr_expr (NULL_TREE, rse->expr));\n \t  cond = gfc_evaluate_now (cond, &lse->pre);\n \t}\n "}, {"sha": "beb03d9bb736c68e3a98c742b3e03fa6036814ed", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=628c189edb5aae6b4e1d416a92cbd0cb9f68586f", "patch": "@@ -807,7 +807,7 @@ gfc_conv_intrinsic_exponent (gfc_se *se, gfc_expr *expr)\n \n   res = gfc_create_var (integer_type_node, NULL);\n   tmp = build_call_expr (built_in_decls[frexp], 2, arg,\n-\t\t\t build_fold_addr_expr (res));\n+\t\t\t gfc_build_addr_expr (NULL_TREE, res));\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   type = gfc_typenode_for_spec (&expr->ts);\n@@ -1375,8 +1375,8 @@ gfc_conv_intrinsic_ctime (gfc_se * se, gfc_expr * expr)\n   len = gfc_create_var (gfc_get_int_type (8), \"len\");\n \n   gfc_conv_intrinsic_function_args (se, expr, &args[2], num_args - 2);\n-  args[0] = build_fold_addr_expr (var);\n-  args[1] = build_fold_addr_expr (len);\n+  args[0] = gfc_build_addr_expr (NULL_TREE, var);\n+  args[1] = gfc_build_addr_expr (NULL_TREE, len);\n \n   fndecl = build_addr (gfor_fndecl_ctime, current_function_decl);\n   tmp = build_call_array (TREE_TYPE (TREE_TYPE (gfor_fndecl_ctime)),\n@@ -1413,8 +1413,8 @@ gfc_conv_intrinsic_fdate (gfc_se * se, gfc_expr * expr)\n   len = gfc_create_var (gfc_get_int_type (4), \"len\");\n \n   gfc_conv_intrinsic_function_args (se, expr, &args[2], num_args - 2);\n-  args[0] = build_fold_addr_expr (var);\n-  args[1] = build_fold_addr_expr (len);\n+  args[0] = gfc_build_addr_expr (NULL_TREE, var);\n+  args[1] = gfc_build_addr_expr (NULL_TREE, len);\n \n   fndecl = build_addr (gfor_fndecl_fdate, current_function_decl);\n   tmp = build_call_array (TREE_TYPE (TREE_TYPE (gfor_fndecl_fdate)),\n@@ -1453,8 +1453,8 @@ gfc_conv_intrinsic_ttynam (gfc_se * se, gfc_expr * expr)\n   len = gfc_create_var (gfc_get_int_type (4), \"len\");\n \n   gfc_conv_intrinsic_function_args (se, expr, &args[2], num_args - 2);\n-  args[0] = build_fold_addr_expr (var);\n-  args[1] = build_fold_addr_expr (len);\n+  args[0] = gfc_build_addr_expr (NULL_TREE, var);\n+  args[1] = gfc_build_addr_expr (NULL_TREE, len);\n \n   fndecl = build_addr (gfor_fndecl_ttynam, current_function_decl);\n   tmp = build_call_array (TREE_TYPE (TREE_TYPE (gfor_fndecl_ttynam)),\n@@ -1577,7 +1577,7 @@ gfc_conv_intrinsic_minmax_char (gfc_se * se, gfc_expr * expr, int op)\n \n   /* Create the result variables.  */\n   len = gfc_create_var (gfc_charlen_type_node, \"len\");\n-  args[0] = build_fold_addr_expr (len);\n+  args[0] = gfc_build_addr_expr (NULL_TREE, len);\n   var = gfc_create_var (gfc_get_pchar_type (expr->ts.kind), \"pstr\");\n   args[1] = gfc_build_addr_expr (ppvoid_type_node, var);\n   args[2] = build_int_cst (NULL_TREE, op);\n@@ -3124,7 +3124,7 @@ gfc_conv_intrinsic_fraction (gfc_se * se, gfc_expr * expr)\n   tmp = gfc_create_var (integer_type_node, NULL);\n   se->expr = build_call_expr (built_in_decls[frexp], 2,\n \t\t\t      fold_convert (type, arg),\n-\t\t\t      build_fold_addr_expr (tmp));\n+\t\t\t      gfc_build_addr_expr (NULL_TREE, tmp));\n   se->expr = fold_convert (type, se->expr);\n }\n \n@@ -3232,7 +3232,7 @@ gfc_conv_intrinsic_spacing (gfc_se * se, gfc_expr * expr)\n   /* Build the block for s /= 0.  */\n   gfc_start_block (&block);\n   tmp = build_call_expr (built_in_decls[frexp], 2, arg,\n-\t\t\t build_fold_addr_expr (e));\n+\t\t\t gfc_build_addr_expr (NULL_TREE, e));\n   gfc_add_expr_to_block (&block, tmp);\n \n   tmp = fold_build2 (MINUS_EXPR, integer_type_node, e, prec);\n@@ -3310,7 +3310,7 @@ gfc_conv_intrinsic_rrspacing (gfc_se * se, gfc_expr * expr)\n \n   gfc_start_block (&block);\n   tmp = build_call_expr (built_in_decls[frexp], 2, arg,\n-\t\t\t build_fold_addr_expr (e));\n+\t\t\t gfc_build_addr_expr (NULL_TREE, e));\n   gfc_add_expr_to_block (&block, tmp);\n \n   tmp = fold_build2 (MINUS_EXPR, integer_type_node,\n@@ -3393,7 +3393,7 @@ gfc_conv_intrinsic_set_exponent (gfc_se * se, gfc_expr * expr)\n   tmp = gfc_create_var (integer_type_node, NULL);\n   tmp = build_call_expr (built_in_decls[frexp], 2,\n \t\t\t fold_convert (type, args[0]),\n-\t\t\t build_fold_addr_expr (tmp));\n+\t\t\t gfc_build_addr_expr (NULL_TREE, tmp));\n   se->expr = build_call_expr (built_in_decls[scalbn], 2, tmp,\n \t\t\t      fold_convert (integer_type_node, args[1]));\n   se->expr = fold_convert (type, se->expr);\n@@ -3713,7 +3713,7 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n       if (arg->expr->expr_type == EXPR_VARIABLE\n \t      && arg->expr->ref->u.ar.type != AR_FULL)\n \t{\n-\t  tmp = build_fold_addr_expr (argse.expr);\n+\t  tmp = gfc_build_addr_expr (NULL_TREE, argse.expr);\n \n \t  if (gfc_option.warn_array_temp)\n \t    gfc_warning (\"Creating array temporary at %L\", &expr->where);\n@@ -3954,7 +3954,7 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n       ptr = convert (build_pointer_type (mold_type), source);\n \n       /* Use memcpy to do the transfer.  */\n-      tmp = build_fold_addr_expr (tmpdecl);\n+      tmp = gfc_build_addr_expr (NULL_TREE, tmpdecl);\n       tmp = build_call_expr (built_in_decls[BUILT_IN_MEMCPY], 3,\n \t\t\t     fold_convert (pvoid_type_node, tmp),\n \t\t\t     fold_convert (pvoid_type_node, ptr),\n@@ -4127,7 +4127,7 @@ gfc_conv_intrinsic_si_kind (gfc_se *se, gfc_expr *expr)\n \n   /* The argument to SELECTED_INT_KIND is INTEGER(4).  */\n   type = gfc_get_int_type (4); \n-  arg = build_fold_addr_expr (fold_convert (type, arg));\n+  arg = gfc_build_addr_expr (NULL_TREE, fold_convert (type, arg));\n \n   /* Convert it to the required type.  */\n   type = gfc_typenode_for_spec (&expr->ts);\n@@ -4203,7 +4203,7 @@ gfc_conv_intrinsic_trim (gfc_se * se, gfc_expr * expr)\n   len = gfc_create_var (gfc_get_int_type (4), \"len\");\n \n   gfc_conv_intrinsic_function_args (se, expr, &args[2], num_args - 2);\n-  args[0] = build_fold_addr_expr (len);\n+  args[0] = gfc_build_addr_expr (NULL_TREE, len);\n   args[1] = addr;\n \n   if (expr->ts.kind == 1)"}, {"sha": "40cb1f28d43def5a01f253dd6f08c6005f4e0524", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=628c189edb5aae6b4e1d416a92cbd0cb9f68586f", "patch": "@@ -239,7 +239,7 @@ gfc_trans_io_runtime_check (tree cond, tree var, int error_code,\n   /* The code to generate the error.  */\n   gfc_start_block (&block);\n   \n-  arg1 = build_fold_addr_expr (var);\n+  arg1 = gfc_build_addr_expr (NULL_TREE, var);\n   \n   arg2 = build_int_cst (integer_type_node, error_code),\n   \n@@ -530,7 +530,7 @@ set_parameter_ref (stmtblock_t *block, stmtblock_t *postblock,\n   if (TYPE_MODE (TREE_TYPE (se.expr))\n       == TYPE_MODE (TREE_TYPE (TREE_TYPE (p->field))))\n     {\n-      addr = convert (TREE_TYPE (p->field), build_fold_addr_expr (se.expr));\n+      addr = convert (TREE_TYPE (p->field), gfc_build_addr_expr (NULL_TREE, se.expr));\n \n       /* If this is for the iostat variable initialize the\n \t user variable to LIBERROR_OK which is zero.  */\n@@ -552,7 +552,7 @@ set_parameter_ref (stmtblock_t *block, stmtblock_t *postblock,\n \tgfc_add_modify (block, tmpvar,\n \t\t\t     build_int_cst (TREE_TYPE (tmpvar), LIBERROR_OK));\n \n-      addr = build_fold_addr_expr (tmpvar);\n+      addr = gfc_build_addr_expr (NULL_TREE, tmpvar);\n \t/* After the I/O operation, we set the variable from the temporary.  */\n       tmp = convert (TREE_TYPE (se.expr), tmpvar);\n       gfc_add_modify (postblock, se.expr, tmp);\n@@ -621,7 +621,7 @@ gfc_convert_array_to_string (gfc_se * se, gfc_expr * e)\n     {\n       size = fold_build2 (MINUS_EXPR, gfc_array_index_type, size,\n \t\tTREE_OPERAND (se->expr, 1));\n-      se->expr = build_fold_addr_expr (se->expr);\n+      se->expr = gfc_build_addr_expr (NULL_TREE, se->expr);\n     }\n \n   tmp = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n@@ -966,7 +966,7 @@ gfc_trans_open (gfc_code * code)\n   else\n     set_parameter_const (&block, var, IOPARM_common_unit, 0);\n \n-  tmp = build_fold_addr_expr (var);\n+  tmp = gfc_build_addr_expr (NULL_TREE, var);\n   tmp = build_call_expr (iocall[IOCALL_OPEN], 1, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n@@ -1018,7 +1018,7 @@ gfc_trans_close (gfc_code * code)\n   else\n     set_parameter_const (&block, var, IOPARM_common_unit, 0);\n \n-  tmp = build_fold_addr_expr (var);\n+  tmp = gfc_build_addr_expr (NULL_TREE, var);\n   tmp = build_call_expr (iocall[IOCALL_CLOSE], 1, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n@@ -1068,7 +1068,7 @@ build_filepos (tree function, gfc_code * code)\n   else\n     set_parameter_const (&block, var, IOPARM_common_unit, 0);\n \n-  tmp = build_fold_addr_expr (var);\n+  tmp = gfc_build_addr_expr (NULL_TREE, var);\n   tmp = build_call_expr (function, 1, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n@@ -1325,7 +1325,7 @@ gfc_trans_inquire (gfc_code * code)\n   else\n     set_parameter_const (&block, var, IOPARM_common_unit, 0);\n \n-  tmp = build_fold_addr_expr (var);\n+  tmp = gfc_build_addr_expr (NULL_TREE, var);\n   tmp = build_call_expr (iocall[IOCALL_INQUIRE], 1, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n@@ -1374,7 +1374,7 @@ gfc_trans_wait (gfc_code * code)\n   if (p->unit)\n     set_parameter_value (&block, var, IOPARM_common_unit, p->unit);\n \n-  tmp = build_fold_addr_expr (var);\n+  tmp = gfc_build_addr_expr (NULL_TREE, var);\n   tmp = build_call_expr (iocall[IOCALL_WAIT], 1, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n@@ -1488,7 +1488,7 @@ nml_get_addr_expr (gfc_symbol * sym, gfc_component * c,\n \n   /* Now build the address expression.  */\n \n-  tmp = build_fold_addr_expr (tmp);\n+  tmp = gfc_build_addr_expr (NULL_TREE, tmp);\n \n   /* If scalar dummy, resolve indirect reference now.  */\n \n@@ -1581,7 +1581,7 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n      The call for the scalar part transfers:\n      (address, name, type, kind or string_length, dtype)  */\n \n-  dt_parm_addr = build_fold_addr_expr (dt_parm);\n+  dt_parm_addr = gfc_build_addr_expr (NULL_TREE, dt_parm);\n \n   if (ts->type == BT_CHARACTER)\n     tmp = ts->cl->backend_decl;\n@@ -1791,7 +1791,7 @@ build_dt (tree function, gfc_code * code)\n   else\n     set_parameter_const (&block, var, IOPARM_common_flags, mask);\n \n-  tmp = build_fold_addr_expr (var);\n+  tmp = gfc_build_addr_expr (NULL_TREE, var);\n   tmp = build_call_expr (function, 1, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n@@ -1871,7 +1871,7 @@ gfc_trans_dt_end (gfc_code * code)\n       gcc_unreachable ();\n     }\n \n-  tmp = build_fold_addr_expr (dt_parm);\n+  tmp = gfc_build_addr_expr (NULL_TREE, dt_parm);\n   tmp = build_call_expr (function, 1, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n   gfc_add_block_to_block (&block, dt_post_end_block);\n@@ -1955,7 +1955,7 @@ transfer_array_component (tree expr, gfc_component * cm, locus * where)\n \n   /* Now se.expr contains an element of the array.  Take the address and pass\n      it to the IO routines.  */\n-  tmp = build_fold_addr_expr (se.expr);\n+  tmp = gfc_build_addr_expr (NULL_TREE, se.expr);\n   transfer_expr (&se, &cm->ts, tmp, NULL);\n \n   /* We are done now with the loop body.  Wrap up the scalarizer and\n@@ -2053,7 +2053,7 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr, gfc_code * code)\n \t    }\n \t  arg3 = build_int_cst (NULL_TREE, kind);\n \t  function = iocall[IOCALL_X_CHARACTER_WIDE];\n-\t  tmp = build_fold_addr_expr (dt_parm);\n+\t  tmp = gfc_build_addr_expr (NULL_TREE, dt_parm);\n \t  tmp = build_call_expr (function, 4, tmp, addr_expr, arg2, arg3);\n \t  gfc_add_expr_to_block (&se->pre, tmp);\n \t  gfc_add_block_to_block (&se->pre, &se->post);\n@@ -2093,7 +2093,7 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr, gfc_code * code)\n           else\n             {\n               if (!c->attr.pointer)\n-                tmp = build_fold_addr_expr (tmp);\n+                tmp = gfc_build_addr_expr (NULL_TREE, tmp);\n               transfer_expr (se, &c->ts, tmp, code);\n             }\n \t}\n@@ -2103,7 +2103,7 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr, gfc_code * code)\n       internal_error (\"Bad IO basetype (%d)\", ts->type);\n     }\n \n-  tmp = build_fold_addr_expr (dt_parm);\n+  tmp = gfc_build_addr_expr (NULL_TREE, dt_parm);\n   tmp = build_call_expr (function, 3, tmp, addr_expr, arg2);\n   gfc_add_expr_to_block (&se->pre, tmp);\n   gfc_add_block_to_block (&se->pre, &se->post);\n@@ -2126,7 +2126,7 @@ transfer_array_desc (gfc_se * se, gfc_typespec * ts, tree addr_expr)\n \n   kind_arg = build_int_cst (NULL_TREE, ts->kind);\n \n-  tmp = build_fold_addr_expr (dt_parm);\n+  tmp = gfc_build_addr_expr (NULL_TREE, dt_parm);\n   tmp = build_call_expr (iocall[IOCALL_X_ARRAY], 4,\n \t\t\t tmp, addr_expr, kind_arg, charlen_arg);\n   gfc_add_expr_to_block (&se->pre, tmp);\n@@ -2198,7 +2198,7 @@ gfc_trans_transfer (gfc_code * code)\n \t    {\n \t      /* Get the descriptor.  */\n \t      gfc_conv_expr_descriptor (&se, expr, ss);\n-\t      tmp = build_fold_addr_expr (se.expr);\n+\t      tmp = gfc_build_addr_expr (NULL_TREE, se.expr);\n \t    }\n \n \t  transfer_array_desc (&se, &expr->ts, tmp);"}, {"sha": "75eeb333d6209adb97949e9f48c5ff3c0a9a9871", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=628c189edb5aae6b4e1d416a92cbd0cb9f68586f", "patch": "@@ -3893,7 +3893,7 @@ gfc_trans_allocate (gfc_code * code)\n       tree gfc_int4_type_node = gfc_get_int_type (4);\n \n       stat = gfc_create_var (gfc_int4_type_node, \"stat\");\n-      pstat = build_fold_addr_expr (stat);\n+      pstat = gfc_build_addr_expr (NULL_TREE, stat);\n \n       error_label = gfc_build_label_decl (NULL_TREE);\n       TREE_USED (error_label) = 1;\n@@ -3999,11 +3999,11 @@ gfc_trans_deallocate (gfc_code * code)\n \n       /* Variable used with the library call.  */\n       stat = gfc_create_var (gfc_int4_type_node, \"stat\");\n-      pstat = build_fold_addr_expr (stat);\n+      pstat = gfc_build_addr_expr (NULL_TREE, stat);\n \n       /* Running total of possible deallocation failures.  */\n       astat = gfc_create_var (gfc_int4_type_node, \"astat\");\n-      apstat = build_fold_addr_expr (astat);\n+      apstat = gfc_build_addr_expr (NULL_TREE, astat);\n \n       /* Initialize astat to 0.  */\n       gfc_add_modify (&block, astat, build_int_cst (TREE_TYPE (astat), 0));"}, {"sha": "3dc2d8f44429e0629eb53eb15258c841c318d836", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=628c189edb5aae6b4e1d416a92cbd0cb9f68586f", "patch": "@@ -293,8 +293,9 @@ gfc_build_addr_expr (tree type, tree t)\n     }\n   else\n     {\n-      if (DECL_P (t))\n-        TREE_ADDRESSABLE (t) = 1;\n+      tree base = get_base_address (t);\n+      if (base && DECL_P (base))\n+        TREE_ADDRESSABLE (base) = 1;\n       t = fold_build1 (ADDR_EXPR, natural_type, t);\n     }\n "}, {"sha": "842ef378a9dfd5e7117a568daf59d538ff39ea2c", "filename": "gcc/gimplify.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=628c189edb5aae6b4e1d416a92cbd0cb9f68586f", "patch": "@@ -107,12 +107,14 @@ static enum gimplify_status gimplify_compound_expr (tree *, gimple_seq *, bool);\n \n /* Mark X addressable.  Unlike the langhook we expect X to be in gimple\n    form and we don't do any syntax checking.  */\n-static void\n+void\n mark_addressable (tree x)\n {\n   while (handled_component_p (x))\n     x = TREE_OPERAND (x, 0);\n-  if (TREE_CODE (x) != VAR_DECL && TREE_CODE (x) != PARM_DECL)\n+  if (TREE_CODE (x) != VAR_DECL\n+      && TREE_CODE (x) != PARM_DECL\n+      && TREE_CODE (x) != RESULT_DECL)\n     return ;\n   TREE_ADDRESSABLE (x) = 1;\n }\n@@ -3056,9 +3058,11 @@ gimplify_modify_expr_to_memcpy (tree *expr_p, tree size, bool want_value,\n   to = TREE_OPERAND (*expr_p, 0);\n   from = TREE_OPERAND (*expr_p, 1);\n \n+  mark_addressable (from);\n   from_ptr = build_fold_addr_expr (from);\n   gimplify_arg (&from_ptr, seq_p, EXPR_LOCATION (*expr_p));\n \n+  mark_addressable (to);\n   to_ptr = build_fold_addr_expr (to);\n   gimplify_arg (&to_ptr, seq_p, EXPR_LOCATION (*expr_p));\n "}, {"sha": "c56915f6546646086c1ae2b5575c7a93740e913d", "filename": "gcc/omp-low.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=628c189edb5aae6b4e1d416a92cbd0cb9f68586f", "patch": "@@ -1595,6 +1595,7 @@ create_omp_child_function (omp_context *ctx, bool task_copy)\n       DECL_ARG_TYPE (t) = ptr_type_node;\n       DECL_CONTEXT (t) = current_function_decl;\n       TREE_USED (t) = 1;\n+      TREE_ADDRESSABLE (t) = 1;\n       TREE_CHAIN (t) = DECL_ARGUMENTS (decl);\n       DECL_ARGUMENTS (decl) = t;\n     }\n@@ -2316,6 +2317,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  x = create_tmp_var_raw (TREE_TYPE (TREE_TYPE (new_var)),\n \t\t\t\t\t  name);\n \t\t  gimple_add_tmp_var (x);\n+\t\t  TREE_ADDRESSABLE (x) = 1;\n \t\t  x = build_fold_addr_expr_with_type (x, TREE_TYPE (new_var));\n \t\t}\n \t      else\n@@ -6344,6 +6346,7 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n       ctx->sender_decl\n \t= create_tmp_var (ctx->srecord_type ? ctx->srecord_type\n \t\t\t  : ctx->record_type, \".omp_data_o\");\n+      TREE_ADDRESSABLE (ctx->sender_decl) = 1;\n       gimple_omp_taskreg_set_data_arg (stmt, ctx->sender_decl);\n     }\n "}, {"sha": "c5b9bd79e3a913f0806f03d9a84310a84d1825f0", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=628c189edb5aae6b4e1d416a92cbd0cb9f68586f", "patch": "@@ -1145,6 +1145,7 @@ tree force_gimple_operand (tree, gimple_seq *, bool, tree);\n tree force_gimple_operand_gsi (gimple_stmt_iterator *, tree, bool, tree,\n \t\t\t       bool, enum gsi_iterator_update);\n tree gimple_fold_indirect_ref (tree);\n+void mark_addressable (tree);\n \n /* In tree-ssa-structalias.c */\n bool find_what_p_points_to (tree);"}, {"sha": "c1514bf25f8cc8d53d37eb084d3abb97fbd6b126", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=628c189edb5aae6b4e1d416a92cbd0cb9f68586f", "patch": "@@ -99,6 +99,8 @@ create_iv (tree base, tree step, tree var, struct loop *loop,\n     }\n   if (POINTER_TYPE_P (TREE_TYPE (base)))\n     {\n+      if (TREE_CODE (base) == ADDR_EXPR)\n+\tmark_addressable (TREE_OPERAND (base, 0));\n       step = fold_convert (sizetype, step);\n       if (incr_op == MINUS_EXPR)\n \tstep = fold_build1 (NEGATE_EXPR, sizetype, step);"}, {"sha": "ee3df246dea4667d8bcd451a56777aaa667fac98", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/628c189edb5aae6b4e1d416a92cbd0cb9f68586f/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=628c189edb5aae6b4e1d416a92cbd0cb9f68586f", "patch": "@@ -478,6 +478,21 @@ verify_phi_args (gimple phi, basic_block bb, basic_block *definition_block)\n \t\t\t     op_p, phi, e->flags & EDGE_ABNORMAL, NULL);\n \t}\n \n+      if (TREE_CODE (op) == ADDR_EXPR)\n+\t{\n+\t  tree base = TREE_OPERAND (op, 0);\n+\t  while (handled_component_p (base))\n+\t    base = TREE_OPERAND (base, 0);\n+\t  if ((TREE_CODE (base) == VAR_DECL\n+\t       || TREE_CODE (base) == PARM_DECL\n+\t       || TREE_CODE (base) == RESULT_DECL)\n+\t      && !TREE_ADDRESSABLE (base))\n+\t    {\n+\t      error (\"address taken, but ADDRESSABLE bit not set\");\n+\t      err = true;\n+\t    }\n+\t}\n+\n       if (e->dest != bb)\n \t{\n \t  error (\"wrong edge %d->%d for PHI argument\","}]}