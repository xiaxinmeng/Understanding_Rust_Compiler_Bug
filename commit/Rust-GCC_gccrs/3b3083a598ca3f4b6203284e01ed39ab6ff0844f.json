{"sha": "3b3083a598ca3f4b6203284e01ed39ab6ff0844f", "node_id": "C_kwDOANBUbNoAKDNiMzA4M2E1OThjYTNmNGI2MjAzMjg0ZTAxZWQzOWFiNmZmMDg0NGY", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2022-10-18T14:07:27Z"}, "committer": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2022-10-18T14:07:27Z"}, "message": "c: C2x enums wider than int [PR36113]\n\nC2x has two enhancements to enumerations: allowing enumerations whose\nvalues do not all fit in int (similar to an existing extension), and\nallowing an underlying type to be specified (as in C++).  This patch\nimplements the first of those enhancements.\n\nApart from adjusting diagnostics to reflect this being a standard\nfeature, there are some semantics differences from the previous\nextension:\n\n* The standard feature gives all the values of such an enum the\n  enumerated type (while keeping type int if that can represent all\n  values of the enumeration), where previously GCC only gave those\n  values outside the range of int the enumerated type.  This change\n  was previously requested in PR 36113; it seems unlikely that people\n  are depending on the detail of the previous extension that some\n  enumerators had different types to others depending on whether their\n  values could be represented as int, and this patch makes the change\n  to types of enumerators unconditionally (if that causes problems in\n  practice we could always make it conditional on C2x mode instead).\n\n* The types *while the enumeration is being defined*, for enumerators\n  that can't be represented as int, are now based more directly on the\n  types of the expressions used, rather than a possibly different type\n  with the right precision constructed using c_common_type_for_size.\n  Again, this change is made unconditionally.\n\n* Where overflow (or wraparound to 0, in the case of an unsigned type)\n  when 1 is implicitly added to determine the value of the next\n  enumerator was previously an error, it now results in a wider type\n  with the same signedness (as the while-being-defined type of the\n  previous enumerator) being chosen, if available.\n\nWhen a type is chosen in such an overflow case, or when a type is\nchosen for the underlying integer type of the enumeration, it's\npossible that (unsigned) __int128 is chosen.  Although C2x allows for\nsuch types wider than intmax_t to be considered extended integer\ntypes, we don't have various features required to do so (integer\nconstant suffixes; sufficient library support would also be needed to\ndefine the associated macros for printf/scanf conversions, and\n<stdint.h> typedef names would need to be defined).  Thus, there are\nalso pedwarns for exceeding the range of intmax_t / uintmax_t, as\nwhile in principle exceeding that range is OK, it's only OK in a\ncontext where the relevant types meet the requirements for extended\ninteger types, which does not currently apply here.\n\nBootstrapped with no regressions for x86_64-pc-linux-gnu.  Also\nmanually checked diagnostics for c2x-enum-3.c with -m32 to confirm the\ndiagnostics in that { target { ! int128 } } test are as expected.\n\n\tPR c/36113\n\ngcc/c-family/\n\t* c-common.cc (c_common_type_for_size): Add fallback to\n\twidest_unsigned_literal_type_node or\n\twidest_integer_literal_type_node for precision that may not\n\texactly match the precision of those types.\n\ngcc/c/\n\t* c-decl.cc (finish_enum): If any enumerators do not fit in int,\n\tconvert all to the type of the enumeration.  pedwarn if no integer\n\ttype fits all enumerators and default to\n\twidest_integer_literal_type_node in that case.  Otherwise pedwarn\n\tfor type wider than intmax_t.\n\t(build_enumerator): pedwarn for enumerators outside the range of\n\tuintmax_t or intmax_t, and otherwise use pedwarn_c11 for\n\tenumerators outside the range of int.  On overflow, attempt to\n\tfind a wider type that can hold the value of the next enumerator.\n\tDo not convert value to type determined with\n\tc_common_type_for_size.\n\ngcc/testsuite/\n\t* gcc.dg/c11-enum-1.c, gcc.dg/c11-enum-2.c, gcc.dg/c11-enum-3.c,\n\tgcc.dg/c2x-enum-1.c, gcc.dg/c2x-enum-2.c, gcc.dg/c2x-enum-3.c,\n\tgcc.dg/c2x-enum-4.c, gcc.dg/c2x-enum-5.c: New tests.\n\t* gcc.dg/pr30260.c: Explicitly use -std=gnu11.  Update expected\n\tdiagnostics.\n\t* gcc.dg/torture/pr25183.c: Update expected diagnostics.", "tree": {"sha": "cb707729ccecc7099e5028f9af50de3ef128931c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb707729ccecc7099e5028f9af50de3ef128931c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b3083a598ca3f4b6203284e01ed39ab6ff0844f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b3083a598ca3f4b6203284e01ed39ab6ff0844f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b3083a598ca3f4b6203284e01ed39ab6ff0844f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "656b2338c8f248d9205b6e9d5e4d9cc43228dd5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/656b2338c8f248d9205b6e9d5e4d9cc43228dd5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/656b2338c8f248d9205b6e9d5e4d9cc43228dd5e"}], "stats": {"total": 355, "additions": 309, "deletions": 46}, "files": [{"sha": "cd54c517b18bff6191ac8ac3c0e0d282375cc178", "filename": "gcc/c-family/c-common.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Fc-family%2Fc-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Fc-family%2Fc-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.cc?ref=3b3083a598ca3f4b6203284e01ed39ab6ff0844f", "patch": "@@ -2298,6 +2298,10 @@ c_common_type_for_size (unsigned int bits, int unsignedp)\n   if (bits <= TYPE_PRECISION (intDI_type_node))\n     return unsignedp ? unsigned_intDI_type_node : intDI_type_node;\n \n+  if (bits <= TYPE_PRECISION (widest_integer_literal_type_node))\n+    return (unsignedp ? widest_unsigned_literal_type_node\n+\t    : widest_integer_literal_type_node);\n+\n   return NULL_TREE;\n }\n "}, {"sha": "bcb4d7b66fe2989b55640d2e5171f0aa7c63f628", "filename": "gcc/c/c-decl.cc", "status": "modified", "additions": 98, "deletions": 39, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Fc%2Fc-decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Fc%2Fc-decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.cc?ref=3b3083a598ca3f4b6203284e01ed39ab6ff0844f", "patch": "@@ -9385,6 +9385,10 @@ finish_enum (tree enumtype, tree values, tree attributes)\n   precision = MAX (tree_int_cst_min_precision (minnode, sign),\n \t\t   tree_int_cst_min_precision (maxnode, sign));\n \n+  bool wider_than_int =\n+    (tree_int_cst_lt (minnode, TYPE_MIN_VALUE (integer_type_node))\n+     || tree_int_cst_lt (TYPE_MAX_VALUE (integer_type_node), maxnode));\n+\n   /* If the precision of the type was specified with an attribute and it\n      was too small, give an error.  Otherwise, use it.  */\n   if (TYPE_PRECISION (enumtype) && lookup_attribute (\"mode\", attributes))\n@@ -9407,9 +9411,20 @@ finish_enum (tree enumtype, tree values, tree attributes)\n       tem = c_common_type_for_size (precision, sign == UNSIGNED ? 1 : 0);\n       if (tem == NULL)\n \t{\n-\t  warning (0, \"enumeration values exceed range of largest integer\");\n-\t  tem = long_long_integer_type_node;\n-\t}\n+\t  /* This should only occur when both signed and unsigned\n+\t     values of maximum precision occur among the\n+\t     enumerators.  */\n+\t  pedwarn (input_location, 0,\n+\t\t   \"enumeration values exceed range of largest integer\");\n+\t  tem = widest_integer_literal_type_node;\n+\t}\n+      else if (precision > TYPE_PRECISION (intmax_type_node)\n+\t       && !tree_int_cst_lt (minnode, TYPE_MIN_VALUE (intmax_type_node))\n+\t       && !tree_int_cst_lt (TYPE_MAX_VALUE (uintmax_type_node),\n+\t\t\t\t    maxnode))\n+\tpedwarn (input_location, OPT_Wpedantic,\n+\t\t \"enumeration values exceed range of %qs\",\n+\t\t sign == UNSIGNED ? \"uintmax_t\" : \"intmax_t\");\n     }\n   else\n     tem = sign == UNSIGNED ? unsigned_type_node : integer_type_node;\n@@ -9439,17 +9454,17 @@ finish_enum (tree enumtype, tree values, tree attributes)\n \n \t  TREE_TYPE (enu) = enumtype;\n \n-\t  /* The ISO C Standard mandates enumerators to have type int,\n-\t     even though the underlying type of an enum type is\n-\t     unspecified.  However, GCC allows enumerators of any\n-\t     integer type as an extensions.  build_enumerator()\n-\t     converts any enumerators that fit in an int to type int,\n-\t     to avoid promotions to unsigned types when comparing\n-\t     integers with enumerators that fit in the int range.\n-\t     When -pedantic is given, build_enumerator() would have\n-\t     already warned about those that don't fit. Here we\n-\t     convert the rest to the enumerator type. */\n-\t  if (TREE_TYPE (ini) != integer_type_node)\n+\t  /* Before C2X, the ISO C Standard mandates enumerators to\n+\t     have type int, even though the underlying type of an enum\n+\t     type is unspecified.  However, C2X allows enumerators of\n+\t     any integer type, and if an enumeration has any\n+\t     enumerators wider than int, all enumerators have the\n+\t     enumerated type after it is parsed.  Any enumerators that\n+\t     fit in int are given type int in build_enumerator (which\n+\t     is the correct type while the enumeration is being\n+\t     parsed), so no conversions are needed here if all\n+\t     enumerators fit in int.  */\n+\t  if (wider_than_int)\n \t    ini = convert (enumtype, ini);\n \n \t  DECL_INITIAL (enu) = ini;\n@@ -9517,7 +9532,7 @@ tree\n build_enumerator (location_t decl_loc, location_t loc,\n \t\t  struct c_enum_contents *the_enum, tree name, tree value)\n {\n-  tree decl, type;\n+  tree decl;\n \n   /* Validate and default VALUE.  */\n \n@@ -9568,21 +9583,45 @@ build_enumerator (location_t decl_loc, location_t loc,\n     }\n   /* Even though the underlying type of an enum is unspecified, the\n      type of enumeration constants is explicitly defined as int\n-     (6.4.4.3/2 in the C99 Standard).  GCC allows any integer type as\n-     an extension.  */\n-  else if (!int_fits_type_p (value, integer_type_node))\n-    pedwarn (loc, OPT_Wpedantic,\n-\t     \"ISO C restricts enumerator values to range of %<int%>\");\n-\n-  /* The ISO C Standard mandates enumerators to have type int, even\n-     though the underlying type of an enum type is unspecified.\n-     However, GCC allows enumerators of any integer type as an\n-     extensions.  Here we convert any enumerators that fit in an int\n-     to type int, to avoid promotions to unsigned types when comparing\n-     integers with enumerators that fit in the int range.  When\n-     -pedantic is given, we would have already warned about those that\n-     don't fit. We have to do this here rather than in finish_enum\n-     because this value may be used to define more enumerators.  */\n+     (6.4.4.3/2 in the C99 Standard).  C2X allows any integer type, and\n+     GCC allows such types for older standards as an extension.  */\n+  bool warned_range = false;\n+  if (!int_fits_type_p (value,\n+\t\t\t(TYPE_UNSIGNED (TREE_TYPE (value))\n+\t\t\t ? uintmax_type_node\n+\t\t\t : intmax_type_node)))\n+    /* GCC does not consider its types larger than intmax_t to be\n+       extended integer types (although C2X would permit such types to\n+       be considered extended integer types if all the features\n+       required by <stdint.h> and <inttypes.h> macros, such as support\n+       for integer constants and I/O, were present), so diagnose if\n+       such a wider type is used.  (If the wider type arose from a\n+       constant of such a type, that will also have been diagnosed,\n+       but this is the only diagnostic in the case where it arises\n+       from choosing a wider type automatically when adding 1\n+       overflows.)  */\n+    warned_range = pedwarn (loc, OPT_Wpedantic,\n+\t\t\t    \"enumerator value outside the range of %qs\",\n+\t\t\t    (TYPE_UNSIGNED (TREE_TYPE (value))\n+\t\t\t     ? \"uintmax_t\"\n+\t\t\t     : \"intmax_t\"));\n+  if (!warned_range && !int_fits_type_p (value, integer_type_node))\n+    pedwarn_c11 (loc, OPT_Wpedantic,\n+\t\t \"ISO C restricts enumerator values to range of %<int%> \"\n+\t\t \"before C2X\");\n+\n+  /* The ISO C Standard mandates enumerators to have type int before\n+     C2X, even though the underlying type of an enum type is\n+     unspecified.  C2X allows enumerators of any integer type.  During\n+     the parsing of the enumeration, C2X specifies that constants\n+     representable in int have type int, constants not representable\n+     in int have the type of the given expression if any, and\n+     constants not representable in int and derived by adding 1 to the\n+     previous constant have the type of that constant unless the\n+     addition would overflow or wraparound, in which case a wider type\n+     of the same signedness is chosen automatically; after the\n+     enumeration is parsed, all the constants have the type of the\n+     enumeration if any do not fit in int.  */\n   if (int_fits_type_p (value, integer_type_node))\n     value = convert (integer_type_node, value);\n \n@@ -9591,18 +9630,38 @@ build_enumerator (location_t decl_loc, location_t loc,\n     = build_binary_op (EXPR_LOC_OR_LOC (value, input_location),\n \t\t       PLUS_EXPR, value, integer_one_node, false);\n   the_enum->enum_overflow = tree_int_cst_lt (the_enum->enum_next_value, value);\n+  if (the_enum->enum_overflow)\n+    {\n+      /* Choose a wider type with the same signedness if\n+\t available.  */\n+      int prec = TYPE_PRECISION (TREE_TYPE (value)) + 1;\n+      bool unsignedp = TYPE_UNSIGNED (TREE_TYPE (value));\n+      tree new_type = (unsignedp\n+\t\t       ? long_unsigned_type_node\n+\t\t       : long_integer_type_node);\n+      if (prec > TYPE_PRECISION (new_type))\n+\tnew_type = (unsignedp\n+\t\t    ? long_long_unsigned_type_node\n+\t\t    : long_long_integer_type_node);\n+      if (prec > TYPE_PRECISION (new_type))\n+\tnew_type = (unsignedp\n+\t\t    ? widest_unsigned_literal_type_node\n+\t\t    : widest_integer_literal_type_node);\n+      if (prec <= TYPE_PRECISION (new_type))\n+\t{\n+\t  the_enum->enum_overflow = false;\n+\t  the_enum->enum_next_value\n+\t    = build_binary_op (EXPR_LOC_OR_LOC (value, input_location),\n+\t\t\t       PLUS_EXPR, convert (new_type, value),\n+\t\t\t       integer_one_node, false);\n+\t  gcc_assert (!tree_int_cst_lt (the_enum->enum_next_value, value));\n+\t}\n+    }\n \n   /* Now create a declaration for the enum value name.  */\n \n-  type = TREE_TYPE (value);\n-  type = c_common_type_for_size (MAX (TYPE_PRECISION (type),\n-\t\t\t\t      TYPE_PRECISION (integer_type_node)),\n-\t\t\t\t (TYPE_PRECISION (type)\n-\t\t\t\t  >= TYPE_PRECISION (integer_type_node)\n-\t\t\t\t  && TYPE_UNSIGNED (type)));\n-\n-  decl = build_decl (decl_loc, CONST_DECL, name, type);\n-  DECL_INITIAL (decl) = convert (type, value);\n+  decl = build_decl (decl_loc, CONST_DECL, name, TREE_TYPE (value));\n+  DECL_INITIAL (decl) = value;\n   pushdecl (decl);\n \n   return tree_cons (decl, value, NULL_TREE);"}, {"sha": "571041d5962ad3e584dc4df551c436e9ef044d33", "filename": "gcc/testsuite/gcc.dg/c11-enum-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-enum-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-enum-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-enum-1.c?ref=3b3083a598ca3f4b6203284e01ed39ab6ff0844f", "patch": "@@ -0,0 +1,14 @@\n+/* Test C2x enumerations with values not representable in int are diagnosed for\n+   C11.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+enum e1 { e1a = -__LONG_LONG_MAX__ - 1 }; /* { dg-error \"ISO C restricts enumerator values\" } */\n+\n+enum e2 { e2a = __LONG_LONG_MAX__ }; /* { dg-error \"ISO C restricts enumerator values\" } */\n+\n+enum e3 { e3a = (unsigned int) -1 }; /* { dg-error \"ISO C restricts enumerator values\" } */\n+\n+enum e4 { e4a = (long long) -__INT_MAX__ - 1, e4b = (unsigned int) __INT_MAX__ };\n+\n+enum e5 { e5a = __INT_MAX__, e5b }; /* { dg-error \"ISO C restricts enumerator values\" } */"}, {"sha": "5b07c8d4b12f3ed961e3486bb719a277c277d9d1", "filename": "gcc/testsuite/gcc.dg/c11-enum-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-enum-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-enum-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-enum-2.c?ref=3b3083a598ca3f4b6203284e01ed39ab6ff0844f", "patch": "@@ -0,0 +1,14 @@\n+/* Test C2x enumerations with values not representable in int are diagnosed for\n+   C11.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c11 -pedantic\" } */\n+\n+enum e1 { e1a = -__LONG_LONG_MAX__ - 1 }; /* { dg-warning \"ISO C restricts enumerator values\" } */\n+\n+enum e2 { e2a = __LONG_LONG_MAX__ }; /* { dg-warning \"ISO C restricts enumerator values\" } */\n+\n+enum e3 { e3a = (unsigned int) -1 }; /* { dg-warning \"ISO C restricts enumerator values\" } */\n+\n+enum e4 { e4a = (long long) -__INT_MAX__ - 1, e4b = (unsigned int) __INT_MAX__ };\n+\n+enum e5 { e5a = __INT_MAX__, e5b }; /* { dg-warning \"ISO C restricts enumerator values\" } */"}, {"sha": "8266d4ea347d26d6a4de454c9bc75777b5086204", "filename": "gcc/testsuite/gcc.dg/c11-enum-3.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-enum-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-enum-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-enum-3.c?ref=3b3083a598ca3f4b6203284e01ed39ab6ff0844f", "patch": "@@ -0,0 +1,14 @@\n+/* Test C2x enumerations with values not representable in int are not diagnosed\n+   for C11 with -pedantic-errors -Wno-c11-c2x-compat.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c11 -pedantic-errors -Wno-c11-c2x-compat\" } */\n+\n+enum e1 { e1a = -__LONG_LONG_MAX__ - 1 };\n+\n+enum e2 { e2a = __LONG_LONG_MAX__ };\n+\n+enum e3 { e3a = (unsigned int) -1 };\n+\n+enum e4 { e4a = (long long) -__INT_MAX__ - 1, e4b = (unsigned int) __INT_MAX__ };\n+\n+enum e5 { e5a = __INT_MAX__, e5b };"}, {"sha": "c4371faaceebcaa30231d2c767d95eef83b335a1", "filename": "gcc/testsuite/gcc.dg/c2x-enum-1.c", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-1.c?ref=3b3083a598ca3f4b6203284e01ed39ab6ff0844f", "patch": "@@ -0,0 +1,104 @@\n+/* Test C2x enumerations with values not representable in int.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+/* Check a type while defining an enum (via a diagnostic for incompatible\n+   pointer types if the wrong type was chosen).  */\n+#define TYPE_CHECK(cst, type)\t\t\t\t\t\t\\\n+  cst ## _type_check = sizeof (1 ? (type *) 0 : (typeof (cst) *) 0)\n+\n+/* Test various explicit values not representable in int.  */\n+\n+enum e1 { e1a = -__LONG_LONG_MAX__ - 1, TYPE_CHECK (e1a, long long),\n+\t  e1b = 0, TYPE_CHECK (e1b, int),\n+\t  e1c = __LONG_LONG_MAX__, TYPE_CHECK (e1c, long long),\n+\t  e1d = 1, TYPE_CHECK (e1d, int) };\n+extern enum e1 e1v;\n+extern typeof (e1a) e1v;\n+extern typeof (e1b) e1v;\n+extern typeof (e1c) e1v;\n+extern typeof (e1d) e1v;\n+static_assert (sizeof (enum e1) >= sizeof (long long));\n+static_assert (e1a == -__LONG_LONG_MAX__ - 1);\n+static_assert (e1b == 0);\n+static_assert (e1c == __LONG_LONG_MAX__);\n+static_assert (e1d == 1);\n+static_assert (e1a < 0);\n+static_assert (e1c > 0);\n+\n+/* This is a test where values are representable in int.  */\n+enum e2 { e2a = (long long) -__INT_MAX__ - 1, TYPE_CHECK (e2a, int),\n+\t  e2b = (unsigned int) __INT_MAX__, TYPE_CHECK (e2b, int),\n+\t  e2c = 2, TYPE_CHECK (e2c, int) };\n+extern int e2v;\n+extern typeof (e2a) e2v;\n+extern typeof (e2b) e2v;\n+extern typeof (e2c) e2v;\n+static_assert (e2a == -__INT_MAX__ - 1);\n+static_assert (e2b == __INT_MAX__);\n+static_assert (e2c == 2);\n+static_assert (e2a < 0);\n+static_assert (e2b > 0);\n+\n+enum e3 { e3a = 0, TYPE_CHECK (e3a, int),\n+\t  e3b = (unsigned int) -1, TYPE_CHECK (e3b, unsigned int) };\n+extern enum e3 e3v;\n+extern typeof (e3a) e3v;\n+extern typeof (e3b) e3v;\n+static_assert (e3a == 0u);\n+static_assert (e3b == (unsigned int) -1);\n+static_assert (e3b > 0);\n+\n+/* Test handling of overflow and wraparound (choosing a wider type).  */\n+#if __LONG_LONG_MAX__ > __INT_MAX__\n+enum e4 { e4a = __INT_MAX__,\n+\t  e4b, e4c, e4d = ((typeof (e4b)) -1) < 0,\n+\t  e4e = (unsigned int) -1,\n+\t  e4f, e4g = ((typeof (e4e)) -1) > 0,\n+\t  TYPE_CHECK (e4a, int), TYPE_CHECK (e4e, unsigned int) };\n+extern enum e4 e4v;\n+extern typeof (e4a) e4v;\n+extern typeof (e4b) e4v;\n+extern typeof (e4c) e4v;\n+extern typeof (e4d) e4v;\n+extern typeof (e4e) e4v;\n+extern typeof (e4f) e4v;\n+extern typeof (e4g) e4v;\n+static_assert (e4a == __INT_MAX__);\n+static_assert (e4b == (long long) __INT_MAX__ + 1);\n+static_assert (e4c == (long long) __INT_MAX__ + 2);\n+static_assert (e4f == (unsigned long long) (unsigned int) -1 + 1);\n+/* Verify the type chosen on overflow of a signed type while parsing was\n+   signed.  */\n+static_assert (e4d == 1);\n+/* Verify the type chosen on wraparound of an unsigned type while parsing was\n+   unsigned.  */\n+static_assert (e4g == 1);\n+#endif\n+\n+/* Likewise, for overflow from long to long long.  */\n+#if __LONG_LONG_MAX__ > __LONG_MAX__\n+enum e5 { e5a = __LONG_MAX__,\n+\t  e5b, e5c, e5d = ((typeof (e5b)) -1) < 0,\n+\t  e5e = (unsigned long) -1,\n+\t  e5f, e5g = ((typeof (e5e)) -1) > 0,\n+\t  TYPE_CHECK (e5a, long), TYPE_CHECK (e5e, unsigned long) };\n+extern enum e5 e5v;\n+extern typeof (e5a) e5v;\n+extern typeof (e5b) e5v;\n+extern typeof (e5c) e5v;\n+extern typeof (e5d) e5v;\n+extern typeof (e5e) e5v;\n+extern typeof (e5f) e5v;\n+extern typeof (e5g) e5v;\n+static_assert (e5a == __LONG_MAX__);\n+static_assert (e5b == (long long) __LONG_MAX__ + 1);\n+static_assert (e5c == (long long) __LONG_MAX__ + 2);\n+static_assert (e5f == (unsigned long long) (unsigned long) -1 + 1);\n+/* Verify the type chosen on overflow of a signed type while parsing was\n+   signed.  */\n+static_assert (e5d == 1);\n+/* Verify the type chosen on wraparound of an unsigned type while parsing was\n+   unsigned.  */\n+static_assert (e5g == 1);\n+#endif"}, {"sha": "15dcf9ac7794ba5ce35f4ec5b6da86e1fe960cf6", "filename": "gcc/testsuite/gcc.dg/c2x-enum-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-2.c?ref=3b3083a598ca3f4b6203284e01ed39ab6ff0844f", "patch": "@@ -0,0 +1,14 @@\n+/* Test C2x enumerations with values not representable in int.  Test values\n+   outside the range of standard or extended integer types are diagnosed, even\n+   when they can be represented in __int128.  */\n+/* { dg-do compile { target int128 } } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+enum e1 { e1a = __LONG_LONG_MAX__, e1b }; /* { dg-error \"enumerator value outside the range\" } */\n+\n+enum e2 { e2a = __LONG_LONG_MAX__ * 2ULL + 1ULL, e2b }; /* { dg-error \"enumerator value outside the range\" } */\n+\n+/* Likewise, when it's the enum as a whole that can't fit in any standard or\n+   extended type, but the individual enumerators fit (some fitting a signed\n+   type and some fitting an unsigned type).  */\n+enum e3 { e3a = -__LONG_LONG_MAX__ - 1, e3b = __LONG_LONG_MAX__ * 2ULL + 1ULL }; /* { dg-error \"enumeration values exceed range of 'intmax_t'\" } */"}, {"sha": "532d9776d3a27d7fa9a2f92d8fd2d1d413d25fb7", "filename": "gcc/testsuite/gcc.dg/c2x-enum-3.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-3.c?ref=3b3083a598ca3f4b6203284e01ed39ab6ff0844f", "patch": "@@ -0,0 +1,14 @@\n+/* Test C2x enumerations with values not representable in int.  Test values\n+   outside the range of standard or extended integer types are diagnosed,\n+   when __int128 is unsupported.  */\n+/* { dg-do compile { target { ! int128 } } } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+enum e1 { e1a = __LONG_LONG_MAX__, e1b }; /* { dg-error \"overflow in enumeration values\" } */\n+\n+enum e2 { e2a = __LONG_LONG_MAX__ * 2ULL + 1ULL, e2b }; /* { dg-error \"overflow in enumeration values\" } */\n+\n+/* Likewise, when it's the enum as a whole that can't fit in any standard or\n+   extended type, but the individual enumerators fit (some fitting a signed\n+   type and some fitting an unsigned type).  */\n+enum e3 { e3a = -__LONG_LONG_MAX__ - 1, e3b = __LONG_LONG_MAX__ * 2ULL + 1ULL }; /* { dg-error \"enumeration values exceed range of largest integer\" } */"}, {"sha": "c2e58bfe750ca670bd55efc971f53fa1763a26e2", "filename": "gcc/testsuite/gcc.dg/c2x-enum-4.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-4.c?ref=3b3083a598ca3f4b6203284e01ed39ab6ff0844f", "patch": "@@ -0,0 +1,14 @@\n+/* Test C2x enumerations with values not representable in int.  Test overflow\n+   of __int128 is diagnosed.  */\n+/* { dg-do compile { target { int128 } } } */\n+/* { dg-options \"-std=c2x\" } */\n+\n+enum e1 { e1a = (__int128) (((unsigned __int128) -1) >> 1), e1b }; /* { dg-error \"overflow in enumeration values\" } */\n+\n+enum e2 { e2a = (unsigned __int128) -1, e2b }; /* { dg-error \"overflow in enumeration values\" } */\n+\n+/* Likewise, when it's the enum as a whole that can't fit in __int128 or\n+   unsigned __int128, but the individual enumerators fit (some fitting __int128\n+   and some fitting unsigned __int128).  */\n+enum e3 { e3a = -(__int128) (((unsigned __int128) -1) >> 1) - 1,\n+\t  e3b = (unsigned __int128) -1 }; /* { dg-warning \"enumeration values exceed range of largest integer\" } */"}, {"sha": "a4290f04525e8dc1427a0b36f790212428e70d7b", "filename": "gcc/testsuite/gcc.dg/c2x-enum-5.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-enum-5.c?ref=3b3083a598ca3f4b6203284e01ed39ab6ff0844f", "patch": "@@ -0,0 +1,12 @@\n+/* Test C2x enumerations with values not representable in int.  Test\n+   -Wc11-c2x-compat warnings.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors -Wc11-c2x-compat\" } */\n+\n+enum e1 { e1a = -__LONG_LONG_MAX__ - 1 }; /* { dg-warning \"ISO C restricts enumerator values\" } */\n+\n+enum e2 { e2a = __LONG_LONG_MAX__ }; /* { dg-warning \"ISO C restricts enumerator values\" } */\n+\n+enum e3 { e3a = (unsigned int) -1 }; /* { dg-warning \"ISO C restricts enumerator values\" } */\n+\n+enum e4 { e4a = (long long) -__INT_MAX__ - 1, e4b = (unsigned int) __INT_MAX__ };"}, {"sha": "3fac38ed7f3bf610449686248f8fc94fbcec01b7", "filename": "gcc/testsuite/gcc.dg/pr30260.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr30260.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr30260.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr30260.c?ref=3b3083a598ca3f4b6203284e01ed39ab6ff0844f", "patch": "@@ -1,6 +1,6 @@\n /* PR 30260  */\n /* { dg-do link } */\n-/* { dg-options \"-pedantic -O\" } */\n+/* { dg-options \"-std=gnu11 -pedantic -O\" } */\n #include <limits.h>\n \n void link_error (void);\n@@ -30,5 +30,5 @@ int main(void)\n   return 0;\n }\n \n-enum E1 { e10 = INT_MAX, e11 }; /* { dg-error \"overflow in enumeration values\" } */\n-enum E2 { e20 = (unsigned) INT_MAX, e21 }; /* { dg-error \"overflow in enumeration values\" } */\n+enum E1 { e10 = INT_MAX, e11 }; /* { dg-warning \"ISO C restricts enumerator values to range of 'int' before C2X\" } */\n+enum E2 { e20 = (unsigned) INT_MAX, e21 }; /* { dg-warning \"ISO C restricts enumerator values to range of 'int' before C2X\" } */"}, {"sha": "84b4c8f8d44bcc2306acb9b357ac31ec9fbeee3d", "filename": "gcc/testsuite/gcc.dg/torture/pr25183.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr25183.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b3083a598ca3f4b6203284e01ed39ab6ff0844f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr25183.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr25183.c?ref=3b3083a598ca3f4b6203284e01ed39ab6ff0844f", "patch": "@@ -3,10 +3,10 @@\n \n enum err {\n   err_IO = 0x8a450000, /* { dg-warning \"int\" } */\n-  err_NM,\n-  err_EOF,\n-  err_SE,\n-  err_PT\n+  err_NM, /* { dg-warning \"int\" } */\n+  err_EOF, /* { dg-warning \"int\" } */\n+  err_SE, /* { dg-warning \"int\" } */\n+  err_PT /* { dg-warning \"int\" } */\n };\n static enum err E_;\n int error()"}]}