{"sha": "a6db99a61a86814241b66a17a65633338d86cc17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZkYjk5YTYxYTg2ODE0MjQxYjY2YTE3YTY1NjMzMzM4ZDg2Y2MxNw==", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2020-03-27T18:56:40Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-12T08:29:33Z"}, "message": "[Ada] Fix anonymous-to-named access type implicit conversion legality checking\n\n2020-06-12  Steve Baird  <baird@adacore.com>\n\ngcc/ada/\n\n\t* sem_res.adb (Valid_Conversion): The simpler cases of\n\tviolations of the aforementioned 8.6 rule are already handled\n\tcorrectly. These include cases where the operand of the type\n\tconversion is an access parameter or a stand-alone object of an\n\tanonymous access type. Add code to detect violations where the\n\toperand of the type conversion is an access discriminant whose\n\taccessibility level is tied to one of the other simpler cases.\n\tThis is implemented in a new function,\n\tValid_Conversion.Is_Discrim_Of_Bad_Access_Conversion_Argument,\n\twhich is called in place of the previous test.", "tree": {"sha": "2e600748283905f7142edace79244d1769f067a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e600748283905f7142edace79244d1769f067a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6db99a61a86814241b66a17a65633338d86cc17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6db99a61a86814241b66a17a65633338d86cc17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6db99a61a86814241b66a17a65633338d86cc17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6db99a61a86814241b66a17a65633338d86cc17/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3483a77e5dd55112bd97543c8dd00275c16b345", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3483a77e5dd55112bd97543c8dd00275c16b345", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3483a77e5dd55112bd97543c8dd00275c16b345"}], "stats": {"total": 89, "additions": 83, "deletions": 6}, "files": [{"sha": "0290c53d41301a77a96f08d49f8caf6b66d5ef0b", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 83, "deletions": 6, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6db99a61a86814241b66a17a65633338d86cc17/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6db99a61a86814241b66a17a65633338d86cc17/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=a6db99a61a86814241b66a17a65633338d86cc17", "patch": "@@ -12482,6 +12482,18 @@ package body Sem_Res is\n       --  are not rechecked because type visbility may lead to spurious errors,\n       --  but conversions in an actual for a formal object must be checked.\n \n+      function Is_Discrim_Of_Bad_Access_Conversion_Argument\n+        (Expr : Node_Id) return Boolean;\n+      --  Implicit anonymous-to-named access type conversions are not allowed\n+      --  if the \"statically deeper than\" relationship does not apply to the\n+      --  type of the conversion operand. See RM 8.6(28.1) and AARM 8.6(28.d).\n+      --  We deal with most such cases elsewhere so that we can emit more\n+      --  specific error messages (e.g., if the operand is an access parameter\n+      --  or a saooaaat (stand-alone object of an anonymous access type)), but\n+      --  here is where we catch the case where the operand is an access\n+      --  discriminant selected from a dereference of another such \"bad\"\n+      --  conversion argument.\n+\n       function Valid_Tagged_Conversion\n         (Target_Type : Entity_Id;\n          Opnd_Type   : Entity_Id) return Boolean;\n@@ -12584,6 +12596,74 @@ package body Sem_Res is\n          end if;\n       end In_Instance_Code;\n \n+      --------------------------------------------------\n+      -- Is_Discrim_Of_Bad_Access_Conversion_Argument --\n+      --------------------------------------------------\n+\n+      function Is_Discrim_Of_Bad_Access_Conversion_Argument\n+        (Expr : Node_Id) return Boolean\n+      is\n+         Exp_Type : Entity_Id := Base_Type (Etype (Expr));\n+         pragma Assert (Is_Access_Type (Exp_Type));\n+\n+         Associated_Node : Node_Id;\n+         Deref_Prefix : Node_Id;\n+      begin\n+         if not Is_Anonymous_Access_Type (Exp_Type) then\n+            return False;\n+         end if;\n+\n+         pragma Assert (Is_Itype (Exp_Type));\n+         Associated_Node := Associated_Node_For_Itype (Exp_Type);\n+\n+         if Nkind (Associated_Node) /= N_Discriminant_Specification then\n+            return False; -- not the type of an access discriminant\n+         end if;\n+\n+         --  return False if Expr not of form <prefix>.all.Some_Component\n+\n+         if (Nkind (Expr) /= N_Selected_Component)\n+           or else (Nkind (Prefix (Expr)) /= N_Explicit_Dereference)\n+         then\n+            --  conditional expressions, declare expressions ???\n+            return False;\n+         end if;\n+\n+         Deref_Prefix := Prefix (Prefix (Expr));\n+         Exp_Type := Base_Type (Etype (Deref_Prefix));\n+\n+         --  The \"statically deeper relationship\" does not apply\n+         --  to generic formal access types, so a prefix of such\n+         --  a type is a \"bad\" prefix.\n+\n+         if Is_Generic_Formal (Exp_Type) then\n+            return True;\n+\n+         --  The \"statically deeper relationship\" does apply to\n+         --  any other named access type.\n+\n+         elsif not Is_Anonymous_Access_Type (Exp_Type) then\n+            return False;\n+         end if;\n+\n+         pragma Assert (Is_Itype (Exp_Type));\n+         Associated_Node := Associated_Node_For_Itype (Exp_Type);\n+\n+         --  The \"statically deeper relationship\" applies to some\n+         --  anonymous access types and not to others. Return\n+         --  True for the cases where it does not apply. Also check\n+         --  recursively for the\n+         --     <prefix>.all.Access_Discrim.all.Access_Discrim case,\n+         --  where the correct result depends on <prefix>.\n+\n+         return Nkind_In (Associated_Node,\n+           N_Procedure_Specification, -- access parameter\n+           N_Function_Specification,  -- access parameter\n+           N_Object_Declaration       -- saooaaat\n+           )\n+           or else Is_Discrim_Of_Bad_Access_Conversion_Argument (Deref_Prefix);\n+      end Is_Discrim_Of_Bad_Access_Conversion_Argument;\n+\n       ----------------------------\n       -- Valid_Array_Conversion --\n       ----------------------------\n@@ -13133,13 +13213,10 @@ package body Sem_Res is\n                         & \"not allowed\", Operand);\n                      return False;\n \n-                  --  This is a case where there's an enclosing object whose\n-                  --  to which the \"statically deeper than\" relationship does\n-                  --  not apply (such as an access discriminant selected from\n-                  --  a dereference of an access parameter).\n+                  --  Detect access discriminant values that are illegal\n+                  --  implicit anonymous-to-named access conversion operands.\n \n-                  elsif Object_Access_Level (Operand)\n-                          = Scope_Depth (Standard_Standard)\n+                  elsif Is_Discrim_Of_Bad_Access_Conversion_Argument (Operand)\n                   then\n                      Conversion_Error_N\n                        (\"implicit conversion of anonymous access value \""}]}