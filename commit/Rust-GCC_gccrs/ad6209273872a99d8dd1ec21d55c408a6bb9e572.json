{"sha": "ad6209273872a99d8dd1ec21d55c408a6bb9e572", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ2MjA5MjczODcyYTk5ZDhkZDFlYzIxZDU1YzQwOGE2YmI5ZTU3Mg==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-10-16T21:27:22Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-10-16T21:27:22Z"}, "message": "In testsuite/: 2010-10-16 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn testsuite/:\n2010-10-16  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc.dg/gnu-api-2-class.m: New.\n        * objc.dg/gnu-api-2-objc.m: New.\n\nFrom-SVN: r165564", "tree": {"sha": "f429e367887aea27814bf3a3997efb7901371632", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f429e367887aea27814bf3a3997efb7901371632"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad6209273872a99d8dd1ec21d55c408a6bb9e572", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad6209273872a99d8dd1ec21d55c408a6bb9e572", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad6209273872a99d8dd1ec21d55c408a6bb9e572", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad6209273872a99d8dd1ec21d55c408a6bb9e572/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6c5c7efd6bbca80cb28fffd24600cbb58436f808", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c5c7efd6bbca80cb28fffd24600cbb58436f808", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c5c7efd6bbca80cb28fffd24600cbb58436f808"}], "stats": {"total": 688, "additions": 688, "deletions": 0}, "files": [{"sha": "06cc2bf453c52ebba0f1f61d51ca8847f5ad6213", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad6209273872a99d8dd1ec21d55c408a6bb9e572/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad6209273872a99d8dd1ec21d55c408a6bb9e572/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ad6209273872a99d8dd1ec21d55c408a6bb9e572", "patch": "@@ -1,3 +1,8 @@\n+2010-10-16  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc.dg/gnu-api-2-class.m: New.\n+\t* objc.dg/gnu-api-2-objc.m: New.\n+\n 2010-10-16  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc.dg/gnu-api-2-ivar.m: New."}, {"sha": "5e0df7e81b17b79b259bf7843997941fdb877093", "filename": "gcc/testsuite/objc.dg/gnu-api-2-class.m", "status": "added", "additions": 441, "deletions": 0, "changes": 441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad6209273872a99d8dd1ec21d55c408a6bb9e572/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-api-2-class.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad6209273872a99d8dd1ec21d55c408a6bb9e572/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-api-2-class.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-api-2-class.m?ref=ad6209273872a99d8dd1ec21d55c408a6bb9e572", "patch": "@@ -0,0 +1,441 @@\n+/* Test the Modern GNU Objective-C Runtime API.\n+\n+  This is test 'class', covering all functions starting with 'class'.  */\n+\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* To get the modern GNU Objective-C Runtime API, you include\n+   objc/runtime.h.  */\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+@interface MyRootClass\n+{ Class isa; }\n++ alloc;\n+- init;\n+@end\n+\n+@implementation MyRootClass\n++ alloc { return class_createInstance (self, 0); }\n+- init  { return self; }\n+@end\n+\n+@protocol MyProtocol\n+- (id) variable;\n+@end\n+\n+@protocol MySecondProtocol\n+- (id) setVariable: (id)value;\n+@end\n+\n+@interface MySubClass : MyRootClass <MyProtocol>\n+{ id variable_ivar; }\n+- (void) setVariable: (id)value;\n+- (id) variable;\n+@end\n+\n+@implementation MySubClass\n+- (void) setVariable: (id)value { variable_ivar = value; }\n+- (id) variable { return variable_ivar; }\n+@end\n+\n+@interface DifferentClass : MyRootClass\n+- (id) myClass;\n+- (id) self;\n+@end\n+\n+@implementation DifferentClass\n+- (id) myClass { return object_getClass (self); }\n+- (id) self { return self; }\n+@end\n+\n+@interface MySubClass (MySelf)\n+- (id) mySelf;\n+@end\n+\n+int main(int argc, void **args)\n+{\n+  /* Functions are tested in alphabetical order.  */\n+\n+  printf (\"Testing class_addIvar ()...\\n\");\n+  {\n+    Class new_class = objc_allocateClassPair (objc_getClass (\"MySubClass\"), \"MySubSubClass\", 0);\n+\n+    if (new_class == Nil)\n+      abort ();\n+    \n+    if (! class_addIvar (new_class, \"variable2_ivar\", sizeof (id),\n+\t\t\t __alignof__ (id), @encode (id)))\n+      abort ();\n+\n+    if (! class_addIvar (new_class, \"variable3_ivar\", sizeof (unsigned char),\n+\t\t\t __alignof__ (unsigned char), @encode (unsigned char)))\n+      abort ();\n+\n+    if (! class_addIvar (new_class, \"variable4_ivar\", sizeof (unsigned long),\n+\t\t\t __alignof__ (unsigned long), @encode (unsigned long)))\n+      abort ();\n+\n+    objc_registerClassPair (new_class);    \n+\n+    {\n+      MySubClass *o = [[objc_getClass (\"MySubSubClass\") alloc] init];\n+      Ivar variable2 = class_getInstanceVariable (objc_getClass (\"MySubSubClass\"), \"variable2_ivar\");\n+      Ivar variable3 = class_getInstanceVariable (objc_getClass (\"MySubSubClass\"), \"variable3_ivar\");\n+      Ivar variable4 = class_getInstanceVariable (objc_getClass (\"MySubSubClass\"), \"variable4_ivar\");\n+\n+      if (variable2 == NULL  || variable3 == NULL  ||  variable4 == NULL)\n+\tabort ();\n+      \n+      if (strcmp (ivar_getName (variable2), \"variable2_ivar\") != 0)\n+\tabort ();\n+\n+      if (strcmp (ivar_getName (variable3), \"variable3_ivar\") != 0)\n+\tabort ();\n+\n+      if (strcmp (ivar_getName (variable4), \"variable4_ivar\") != 0)\n+\tabort ();\n+\n+      {\n+\tunsigned char *var3 = (unsigned char *)((char *)o + ivar_getOffset (variable3));\n+\tunsigned long *var4 = (unsigned long *)((char *)o + ivar_getOffset (variable4));\n+\n+\tobject_setIvar (o, variable2, new_class);\n+\t*var3 = 230;\n+\t*var4 = 89000L;\n+\n+\tif (object_getIvar (o, variable2) != new_class)\n+\t  abort ();\n+\n+\tif (*var3 != 230)\n+\t  abort ();\n+\n+\tif (*var4 != 89000L)\n+\t  abort ();\n+      }\n+    }\n+  }\n+\n+  printf (\"Testing class_addMethod ()...\\n\");\n+  {\n+    Class new_class = objc_allocateClassPair (objc_getClass (\"MyRootClass\"), \"MySubClass2\", 0);\n+    Method method1 = class_getInstanceMethod (objc_getClass (\"MySubClass\"), @selector (setVariable:));\n+    Method method2 = class_getInstanceMethod (objc_getClass (\"MySubClass\"), @selector (variable));\n+\n+    if (new_class == Nil)\n+      abort ();\n+    \n+    if (! class_addIvar (new_class, \"variable_ivar\", sizeof (id),\n+\t\t\t __alignof__ (id), @encode (id)))\n+      abort ();\n+\n+    if (! class_addMethod (new_class, @selector (setVariable:), method_getImplementation (method1),\n+\t\t\t   method_getTypeEncoding (method1)))\n+      abort ();\n+\n+    if (! class_addMethod (new_class, @selector (variable), method_getImplementation (method2),\n+\t\t\t   method_getTypeEncoding (method2)))\n+      abort ();\n+\n+    objc_registerClassPair (new_class);    \n+\n+    /* Now, MySubClass2 is basically the same as MySubClass!  We'll\n+       use the variable and setVariable: methods on it.  */\n+    {\n+      MySubClass *o = (MySubClass *)[[objc_getClass (\"MySubClass2\") alloc] init];\n+\n+      [o setVariable: o];\n+\n+      if ([o variable] != o)\n+\tabort ();\n+    }\n+  }\n+\n+  printf (\"Testing class_addProtocol ()...\\n\");\n+  {\n+    if (!class_addProtocol (objc_getClass (\"MySubClass\"), @protocol (MySecondProtocol)))\n+      abort ();\n+    \n+    if (!class_conformsToProtocol (objc_getClass (\"MySubClass\"), @protocol (MyProtocol)))\n+      abort ();\n+\n+    if (!class_conformsToProtocol (objc_getClass (\"MySubClass\"), @protocol (MySecondProtocol)))\n+      abort ();\n+  }\n+\n+  printf (\"Testing class_conformsToProtocol ()...\\n\");\n+  {\n+    if (class_conformsToProtocol (objc_getClass (\"MyRootClass\"), @protocol (MyProtocol)))\n+      abort ();\n+\n+    if (!class_conformsToProtocol (objc_getClass (\"MySubClass\"), @protocol (MyProtocol)))\n+      abort ();\n+  }\n+\n+  printf (\"Testing class_copyIvarList ()...\\n\");\n+  {\n+    unsigned int count;\n+    Ivar * list = class_copyIvarList (objc_getClass (\"MySubClass\"), &count);\n+\n+    if (count != 1)\n+      abort ();\n+\n+    if (strcmp (ivar_getName (list[0]), \"variable_ivar\") != 0)\n+      abort ();\n+    \n+    if (list[1] != NULL)\n+      abort ();\n+  }\n+\n+  printf (\"Testing class_copyMethodList ()...\\n\");\n+  {\n+    unsigned int count;\n+    Method * list = class_copyMethodList (objc_getClass (\"MySubClass\"), &count);\n+\n+    if (count != 2)\n+      abort ();\n+    \n+    if (! ((strcmp (sel_getName (method_getName (list[0])), \"variable\") == 0\n+\t    && strcmp (sel_getName (method_getName (list[1])), \"setVariable:\") == 0)\n+\t   || (strcmp (sel_getName (method_getName (list[0])), \"setVariable:\") == 0\n+\t       && strcmp (sel_getName (method_getName (list[1])), \"variable\") == 0)))\n+      abort ();\n+    \n+    if (list[2] != NULL)\n+      abort ();\n+  }\n+\n+  /* TODO: Test new ABI (when available).  */\n+  printf (\"Testing class_copyPropertyList ()...\\n\");\n+  {\n+    unsigned int count;\n+    Property * list = class_copyPropertyList (objc_getClass (\"MySubClass\"), &count);\n+\n+    if (count != 0  ||  list != NULL)\n+      abort ();\n+  }\n+\n+  printf (\"Testing class_copyProtocolList ()...\\n\");\n+  {\n+    unsigned int count;\n+    Protocol ** list = class_copyProtocolList (objc_getClass (\"MySubClass\"), &count);\n+\n+    /* Remember that we added MySecondProtocol in the test above.  */\n+    if (count != 2)\n+      abort ();\n+\n+    if (! ((strcmp (protocol_getName (list[0]), \"MyProtocol\") == 0\n+\t    && strcmp (protocol_getName (list[1]), \"MySecondProtocol\") == 0)\n+\t   || (strcmp (protocol_getName (list[0]), \"MySecondProtocol\") == 0\n+\t       && strcmp (protocol_getName (list[1]), \"MyProtocol\") == 0)))\n+      abort ();\n+    \n+    if (list[2] != NULL)\n+      abort ();\n+  }\n+\n+  printf (\"Testing class_createInstance ()...\\n\");\n+  {\n+    MySubClass *object = [[MySubClass alloc] init];\n+\n+    [object setVariable: object];\n+    if ([object variable] != object)\n+      abort ();\n+  }\n+\n+  printf (\"Testing class_getClassMethod ()...\\n\");\n+  {\n+    Method method = class_getClassMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t  @selector(alloc));\n+\n+    if (method == NULL)\n+      abort ();\n+\n+    if (strcmp (sel_getName (method_getName (method)), \"alloc\") != 0)\n+      abort ();\n+\n+    if (class_getClassMethod (objc_getClass (\"MySubClass\"), \n+\t\t\t      @selector(variable)))\n+      abort ();\n+  }\n+\n+  printf (\"Testing class_getClassVariable ()...\\n\");\n+  {\n+    if (class_getClassVariable (objc_getClass (\"MySubClass\"), \"variable_ivar\"))\n+      abort ();\n+  }\n+\n+  printf (\"Testing class_getInstanceMethod ()...\\n\");\n+  {\n+    Method method = class_getInstanceMethod (objc_getClass (\"MySubClass\"), \n+\t\t\t\t\t     @selector(variable));\n+\n+    if (method == NULL)\n+      abort ();\n+\n+    if (strcmp (sel_getName (method_getName (method)), \"variable\") != 0)\n+      abort ();\n+\n+    if (class_getInstanceMethod (objc_getClass (\"MySubClass\"), \n+\t\t\t\t @selector(alloc)))\n+      abort ();\n+  }\n+\n+  printf (\"Testing class_getInstanceSize ()...\\n\");\n+  {\n+    if (class_getInstanceSize (objc_getClass (\"MyRootClass\")) != sizeof (struct objc_object))\n+      abort ();\n+  }\n+\n+  printf (\"Testing class_getInstanceVariable ()...\\n\");\n+  {\n+    Ivar variable = class_getInstanceVariable (objc_getClass (\"MySubClass\"), \"variable_ivar\");\n+\n+    if (variable == NULL)\n+      abort ();\n+\n+    if (strcmp (ivar_getName (variable), \"variable_ivar\") != 0)\n+      abort ();\n+\n+    if (class_getInstanceVariable (objc_getClass (\"MySubClass\"), \"variable_ivar_no\"))\n+      abort ();\n+  }\n+\n+  printf (\"Testing class_getIvarLayout ()...\\n\");\n+  {\n+    if (class_getIvarLayout (objc_getClass (\"MyRootClass\")) != NULL)\n+      abort ();\n+  }\n+\n+  printf (\"Testing class_getMethodImplementation ()...\\n\");\n+  {\n+    MySubClass *object = [[MySubClass alloc] init];\n+    IMP imp = class_getMethodImplementation (objc_getClass (\"MySubClass\"), \n+\t\t\t\t\t     @selector(variable));\n+\n+    if (imp == NULL)\n+      abort ();\n+\n+    [object setVariable: object];\n+\n+    if ((*imp)(object, @selector(variable)) != object)\n+      abort ();\n+  }\n+\n+  /* This function does not exist with the GNU runtime.  */\n+  /* printf (\"Testing class_getMethodImplementation_stret ()...\\n\"); */\n+\n+  printf (\"Testing class_getName ()...\\n\");\n+  {\n+    if (strcmp (class_getName (objc_getClass (\"MyRootClass\")),\n+\t\t\"MyRootClass\") != 0)\n+      abort ();\n+  }\n+\n+  /* TODO: Test new ABI (when available).  */\n+  printf (\"Testing class_getProperty ()...\\n\");\n+  {\n+    if (class_getProperty (objc_getClass (\"MyRootClass\"), \"property\") != NULL)\n+      abort ();\n+  }\n+\n+  printf (\"Testing class_getSuperclass ()...\\n\");\n+  {\n+    MySubClass *object = [[MySubClass alloc] init];\n+    if (class_getSuperclass (object_getClass (object)) != objc_getClass (\"MyRootClass\"))\n+      abort ();\n+  }\n+\n+  printf (\"Testing class_getVersion ()...\\n\");\n+  {\n+    if (class_getVersion (objc_getClass (\"MySubClass\")) != 0)\n+      abort ();\n+  }\n+\n+   printf (\"Testing class_getWeakIvarLayout ()...\\n\");\n+  {\n+    if (class_getWeakIvarLayout (objc_getClass (\"MyRootClass\")) != NULL)\n+      abort ();\n+  }\n+\n+  printf (\"Testing class_isMetaClass ()...\\n\");\n+  {\n+    MySubClass *object = [[MySubClass alloc] init];\n+    if (class_isMetaClass (object_getClass (object)) \n+\t|| ! class_isMetaClass (object_getClass (object_getClass (object))))\n+      abort ();\n+  }\n+\n+  printf (\"Testing class_replaceMethod ()...\\n\");\n+  {\n+    Method new_method = class_getInstanceMethod (objc_getClass (\"DifferentClass\"),\n+\t\t\t\t\t\t @selector (myClass));\n+    Method old_method = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t\t @selector (variable));\n+    const char *new_types = method_getTypeEncoding (new_method);\n+    IMP new_imp = method_getImplementation (new_method);\n+    const char *old_types = method_getTypeEncoding (old_method);\n+    IMP old_imp = class_replaceMethod (objc_getClass (\"MySubClass\"), @selector (variable),\n+\t\t\t\t       method_getImplementation (new_method),\n+\t\t\t\t       method_getTypeEncoding (new_method));\n+    MySubClass *o = [[MySubClass alloc] init];\n+\n+    [o setVariable: o];\n+\n+    /* Try the new method implementation.  */\n+    if ([o variable] != objc_getClass (\"MySubClass\"))\n+      abort ();\n+\n+    /* Put the original method back.  */\n+    class_replaceMethod (objc_getClass (\"MySubClass\"), @selector (variable),\n+\t\t\t old_imp, old_types);\n+\n+    /* Test it's back to what it was.  */\n+    if ([o variable] != o)\n+      abort ();    \n+\n+    {\n+      DifferentClass *o = [[DifferentClass alloc] init];\n+\n+      /* Finally, try adding a new method.  */\n+      class_replaceMethod (objc_getClass (\"DifferentClass\"), @selector (mySelf),\n+\t\t\t   new_imp, new_types);\n+      \n+      if ([(MySubClass*)o mySelf] != objc_getClass (\"DifferentClass\"))\n+\tabort ();\n+    }\n+  }\n+\n+  printf (\"Testing class_respondsToSelector ()...\\n\");\n+  {\n+    if (! class_respondsToSelector (objc_getClass (\"MySubClass\"), @selector(setVariable:)))\n+      abort ();\n+\n+    if (class_respondsToSelector (objc_getClass (\"MyRootClass\"), @selector(setVariable:)))\n+      abort ();\n+  }\n+\n+  /* This is not really implemented with the GNU runtime.  */\n+  /* printf (\"Testing class_setIvarLayout ()...\\n\"); */\n+\n+  printf (\"Testing class_setVersion ()...\\n\");\n+  {\n+    class_setVersion (objc_getClass (\"MySubClass\"), 45);\n+    \n+    if (class_getVersion (objc_getClass (\"MySubClass\")) != 45)\n+      abort ();\n+\n+    class_setVersion (objc_getClass (\"MySubClass\"), 46);\n+\n+    if (class_getVersion (objc_getClass (\"MySubClass\")) != 46)\n+      abort ();\n+  }\n+\n+  /* This is not really implemented with the GNU runtime.  */\n+  /* printf (\"Testing class_setWeakIvarLayout ()...\\n\"); */\n+\n+  return 0;\n+}"}, {"sha": "802e5c8609644c3a441a7449d2479c8eeb868587", "filename": "gcc/testsuite/objc.dg/gnu-api-2-objc.m", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad6209273872a99d8dd1ec21d55c408a6bb9e572/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-api-2-objc.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad6209273872a99d8dd1ec21d55c408a6bb9e572/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-api-2-objc.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-api-2-objc.m?ref=ad6209273872a99d8dd1ec21d55c408a6bb9e572", "patch": "@@ -0,0 +1,242 @@\n+/* Test the Modern GNU Objective-C Runtime API.\n+\n+  This is test 'objc', covering all functions starting with 'objc'.  */\n+\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* To get the modern GNU Objective-C Runtime API, you include\n+   objc/runtime.h.  */\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+@interface MyRootClass\n+{ Class isa; }\n++ alloc;\n+- init;\n+@end\n+\n+@implementation MyRootClass\n++ alloc { return class_createInstance (self, 0); }\n+- init  { return self; }\n+@end\n+\n+@protocol MyProtocol\n+- (id) variable;\n+@end\n+\n+@protocol MySecondProtocol\n+- (id) setVariable: (id)value;\n+@end\n+\n+@interface MySubClass : MyRootClass <MyProtocol>\n+{ id variable_ivar; }\n+- (void) setVariable: (id)value;\n+- (id) variable;\n+@end\n+\n+@implementation MySubClass\n+- (void) setVariable: (id)value { variable_ivar = value; }\n+- (id) variable { return variable_ivar; }\n+@end\n+\n+\n+int main(int argc, void **args)\n+{\n+  /* Functions are tested in alphabetical order.  */\n+\n+  printf (\"Testing objc_allocateClassPair ()...\\n\");\n+  {\n+    Class new_root_class = objc_allocateClassPair (Nil, \"MyNewRootClass\", 0);\n+    Class new_class = objc_allocateClassPair (objc_getClass (\"MyRootClass\"), \"MyNewSubClass\", 0);\n+\n+    /* A new root class would obviously need at least an 'isa'\n+       instance variable.  We don't add it so we never actually\n+       instantiate an instance of the class, which wouldn't work.  */\n+\n+    objc_registerClassPair (new_root_class);\n+    objc_registerClassPair (new_class);\n+\n+    if (strcmp (class_getName (new_class), \"MyNewSubClass\") != 0)\n+      abort ();\n+\n+    if (class_getSuperclass (new_class) != objc_getClass (\"MyRootClass\"))\n+      abort ();\n+\n+    if (strcmp (class_getName (new_root_class), \"MyNewRootClass\") != 0)\n+      abort ();\n+\n+    if (class_getSuperclass (new_root_class) != Nil)\n+      abort ();\n+\n+    {\n+      MySubClass *o = [[objc_getClass (\"MyNewSubClass\") alloc] init];\n+      \n+      if (object_getClass (o) != objc_getClass (\"MyNewSubClass\"))\n+\tabort ();\n+    }\n+  }\n+\n+  printf (\"Testing objc_copyProtocolList ()...\\n\");\n+  {\n+    /* Make sure both our two protocols are known to the runtime.  */\n+    id my_protocol = @protocol (MyProtocol);\n+    id my_second_protocol = @protocol (MySecondProtocol);\n+    unsigned int count;\n+    Protocol ** list = objc_copyProtocolList (&count);\n+\n+    if (count != 2)\n+      abort ();\n+\n+    if (! ((strcmp (protocol_getName (list[0]), \"MyProtocol\") == 0\n+\t    && strcmp (protocol_getName (list[1]), \"MySecondProtocol\") == 0)\n+\t   || (strcmp (protocol_getName (list[0]), \"MySecondProtocol\") == 0\n+\t       && strcmp (protocol_getName (list[1]), \"MyProtocol\") == 0)))\n+      abort ();\n+    \n+    if (list[2] != NULL)\n+      abort ();\n+  }\n+\n+  printf (\"Testing objc_disposeClassPair ()...\\n\");\n+  {\n+    Method method = class_getInstanceMethod (objc_getClass (\"MySubClass\"), @selector (setVariable:));\n+    Class new_class = objc_allocateClassPair (objc_getClass (\"MyRootClass\"), \"MyNewSubClass\", 0);\n+\n+    /* Add a bit of everything to the class to exercise undoing all these changes.  */\n+\n+    /* Instance variable.  */\n+    class_addIvar (new_class, \"my_variable\", sizeof (float), __alignof__ (float), @encode (float));\n+\n+    /* Instance method.  */\n+    class_addMethod (new_class, @selector (setVariable:), method_getImplementation (method),\n+\t\t     method_getTypeEncoding (method));\n+\n+    /* Class method.  */\n+    class_addMethod (object_getClass (new_class), @selector (setVariable:), method_getImplementation (method),\n+\t\t     method_getTypeEncoding (method));\n+\n+    /* Protocol.  */\n+    class_addProtocol (new_class, @protocol (MyProtocol));\n+\n+    objc_disposeClassPair (new_class);\n+  }\n+\n+  /* This function currently does not exist with the GNU runtime.  */\n+  /* printf (\"Testing objc_duplicateClass ()...\\n\"); */\n+\n+  /* TODO - Test it when implemented in the GNU Runtime */\n+  /*  printf (\"Testing objc_getAssociatedObject ()...\\n\");  */\n+\n+  printf (\"Testing objc_getClass ()...\\n\");\n+  {\n+    if (strcmp (class_getName (objc_getClass (\"MySubClass\")),\n+\t\t\"MySubClass\") != 0)\n+      abort ();\n+  }\n+\n+  printf (\"Testing objc_getClassList ()...\\n\");\n+  {\n+    Class *list;\n+    int i, count, other_count;\n+    count = objc_getClassList (NULL, 0);\n+\n+    /* count most likely will be 5, (MyRootClass, MySubClass,\n+       Protocol, Object, NXConstantString).  */\n+    if (count < 3)\n+      abort ();\n+    \n+    list = malloc (sizeof (Class) * count);\n+    other_count = objc_getClassList (list, count);\n+\n+    if (other_count != count)\n+      abort ();\n+\n+    /* Spot-check: search for class 'MyRootClass' in the list.  */\n+    for (i = 0; i < count; i++)\n+      {\n+\tif (strcmp (class_getName (list[i]), \"MyRootClass\") == 0)\n+\t  break;\n+      }\n+    if (i == count)\n+      abort ();\n+\n+    /* Spot-check: search for class 'MySubClass' in the list.  */\n+    for (i = 0; i < count; i++)\n+      {\n+\tif (strcmp (class_getName (list[i]), \"MySubClass\") == 0)\n+\t  break;\n+      }\n+    if (i == count)\n+      abort ();\n+\n+    /* Spot-check: search for class 'Protocol' in the list.  */\n+    for (i = 0; i < count; i++)\n+      {\n+\tif (strcmp (class_getName (list[i]), \"Protocol\") == 0)\n+\t  break;\n+      }\n+    if (i == count)\n+      abort ();\n+  }\n+\n+  /* This function does not exist with the GNU runtime.  */\n+  /* printf (\"Testing objc_getFutureClass ()...\\n\"); */\n+\n+  printf (\"Testing objc_getMetaClass ()...\\n\");\n+  {\n+    if (! class_isMetaClass (objc_getMetaClass (\"MyRootClass\")))\n+      abort ();\n+  }\n+\n+  printf (\"Testing objc_getProtocol ()...\\n\");\n+  {\n+    if (! protocol_isEqual (objc_getProtocol (\"MyProtocol\"), @protocol (MyProtocol)))\n+      abort ();\n+  }\n+\n+  printf (\"Testing objc_getRequiredClass ()...\\n\");\n+  {\n+    if (strcmp (class_getName (objc_getRequiredClass (\"MyRootClass\")),\n+\t\t\"MyRootClass\") != 0)\n+      abort ();\n+  }\n+\n+  printf (\"Testing objc_lookupClass ()...\\n\");\n+  {\n+    if (strcmp (class_getName (objc_lookupClass (\"MyRootClass\")),\n+\t\t\"MyRootClass\") != 0)\n+      abort ();\n+  }\n+\n+  /* This function does not exist with the GNU runtime.  */\n+  /* printf (\"Testing objc_setFutureClass ()...\\n\"); */\n+\n+  printf (\"Testing objc_registerClassPair ()...\\n\");\n+  {\n+    Class new_class = objc_allocateClassPair (objc_getClass (\"MySubClass\"), \"MySubSubClass\", 0);\n+\n+    class_addProtocol (new_class, @protocol (MySecondProtocol));\n+    \n+    objc_registerClassPair (new_class);\n+    \n+    if (strcmp (class_getName (new_class), \"MySubSubClass\") != 0)\n+      abort ();\n+\n+    if (class_getSuperclass (new_class) != objc_getClass (\"MySubClass\"))\n+      abort ();\n+\n+    if (! class_conformsToProtocol (new_class, @protocol (MySecondProtocol)))\n+      abort ();\n+  }\n+\n+  /* TODO - Test it when implemented in the GNU Runtime */\n+  /*  printf (\"Testing objc_removeAssociatedObjects ()...\\n\");  */\n+\n+  /* TODO - Test it when implemented in the GNU Runtime */\n+  /*  printf (\"Testing objc_setAssociatedObject ()...\\n\");  */\n+\n+  return 0;\n+}"}]}