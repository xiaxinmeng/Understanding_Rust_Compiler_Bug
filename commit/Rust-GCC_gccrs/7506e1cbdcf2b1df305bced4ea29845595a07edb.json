{"sha": "7506e1cbdcf2b1df305bced4ea29845595a07edb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzUwNmUxY2JkY2YyYjFkZjMwNWJjZWQ0ZWEyOTg0NTU5NWEwN2VkYg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-04-23T23:15:54Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-04-23T23:15:54Z"}, "message": "tree-phinodes.c (reserve_phi_args_for_new_edge, [...]): Use phi_nodes_ptr.\n\n\t* tree-phinodes.c (reserve_phi_args_for_new_edge, remove_phi_node):\n\tUse phi_nodes_ptr.\n\t(create_phi_node): Use set_phi_nodes.\n\t* omp-low.c (expand_omp_parallel): Use bb_stmt_list.\n\t* tree-if-conv.c (process_phi_nodes): Use set_phi_nodes.\n\t(combine_blocks):  Use bb_stmt_list and set_bb_stmt_list.\n\t* tree-flow-inline.h (phi_nodes, set_phi_nodes,\n\t(bsi_start, bsi_last): Use bb_stmt_list.\n\t(phi_nodes_ptr, bb_stmt_list, set_bb_stmt_list): New functions.\n\t* cfgexpand.c (expand_gimple_basic_block): Use bb_stmt_list.\n\tTraverse the statements using tsi iterator.\n\t* basic-block.h (struct basic_block_def): Fields stmt_list\n\tand phi_nodes moved to ...\n\t(struct tree_bb_info): ... new structure.\n\t* tree-cfg.c (create_bb): Allocate il.tree.  Use set_bb_stmt_list.\n\t(tree_merge_blocks): Use bb_stmt_list and set_bb_stmt_list.\n\t(remove_bb): Handle blocks with NULL stmt list.  Clear il.tree field.\n\t(tree_verify_flow_info): Verify that il.tree is not set for\n\tentry and exit block.\n\t(tree_split_block): Use set_bb_stmt_list.\n\nFrom-SVN: r124086", "tree": {"sha": "916f5481a2d49b54e7ca5e6359ffeb9231fdbe30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/916f5481a2d49b54e7ca5e6359ffeb9231fdbe30"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7506e1cbdcf2b1df305bced4ea29845595a07edb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7506e1cbdcf2b1df305bced4ea29845595a07edb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7506e1cbdcf2b1df305bced4ea29845595a07edb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7506e1cbdcf2b1df305bced4ea29845595a07edb/comments", "author": null, "committer": null, "parents": [{"sha": "933e4fe7ae88e0e652148df2ed24b4c7b27a76f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/933e4fe7ae88e0e652148df2ed24b4c7b27a76f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/933e4fe7ae88e0e652148df2ed24b4c7b27a76f9"}], "stats": {"total": 232, "additions": 149, "deletions": 83}, "files": [{"sha": "54823d09a1d9792740c3c4427e0b0be2a6eae691", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7506e1cbdcf2b1df305bced4ea29845595a07edb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7506e1cbdcf2b1df305bced4ea29845595a07edb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7506e1cbdcf2b1df305bced4ea29845595a07edb", "patch": "@@ -1,3 +1,26 @@\n+2007-04-23  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-phinodes.c (reserve_phi_args_for_new_edge, remove_phi_node):\n+\tUse phi_nodes_ptr.\n+\t(create_phi_node): Use set_phi_nodes.\n+\t* omp-low.c (expand_omp_parallel): Use bb_stmt_list.\n+\t* tree-if-conv.c (process_phi_nodes): Use set_phi_nodes.\n+\t(combine_blocks):  Use bb_stmt_list and set_bb_stmt_list.\n+\t* tree-flow-inline.h (phi_nodes, set_phi_nodes,\n+\t(bsi_start, bsi_last): Use bb_stmt_list.\n+\t(phi_nodes_ptr, bb_stmt_list, set_bb_stmt_list): New functions.\n+\t* cfgexpand.c (expand_gimple_basic_block): Use bb_stmt_list.\n+\tTraverse the statements using tsi iterator.\n+\t* basic-block.h (struct basic_block_def): Fields stmt_list\n+\tand phi_nodes moved to ...\n+\t(struct tree_bb_info): ... new structure.\n+\t* tree-cfg.c (create_bb): Allocate il.tree.  Use set_bb_stmt_list.\n+\t(tree_merge_blocks): Use bb_stmt_list and set_bb_stmt_list.\n+\t(remove_bb): Handle blocks with NULL stmt list.  Clear il.tree field.\n+\t(tree_verify_flow_info): Verify that il.tree is not set for\n+\tentry and exit block.\n+\t(tree_split_block): Use set_bb_stmt_list.\n+\n 2007-04-23  Mike Stump  <mrs@apple.com>\n \n \t* config/i386/i386.c (ix86_tune_features"}, {"sha": "bfdec0e550ecd63c8951d24bfd5204df232be867", "filename": "gcc/basic-block.h", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7506e1cbdcf2b1df305bced4ea29845595a07edb/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7506e1cbdcf2b1df305bced4ea29845595a07edb/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=7506e1cbdcf2b1df305bced4ea29845595a07edb", "patch": "@@ -213,9 +213,6 @@ struct rtl_bb_info;\n /* Basic block information indexed by block number.  */\n struct basic_block_def GTY((chain_next (\"%h.next_bb\"), chain_prev (\"%h.prev_bb\")))\n {\n-  /* Pointers to the first and last trees of the block.  */\n-  tree stmt_list;\n-\n   /* The edges into and out of the block.  */\n   VEC(edge,gc) *preds;\n   VEC(edge,gc) *succs;\n@@ -234,12 +231,10 @@ struct basic_block_def GTY((chain_next (\"%h.next_bb\"), chain_prev (\"%h.prev_bb\")\n   struct basic_block_def *next_bb;\n \n   union basic_block_il_dependent {\n+      struct tree_bb_info * GTY ((tag (\"0\"))) tree;\n       struct rtl_bb_info * GTY ((tag (\"1\"))) rtl;\n     } GTY ((desc (\"((%1.flags & BB_RTL) != 0)\"))) il;\n \n-  /* Chain of PHI nodes for this block.  */\n-  tree phi_nodes;\n-\n   /* Expected number of executions: calculated in profile.c.  */\n   gcov_type count;\n \n@@ -277,6 +272,15 @@ struct rtl_bb_info GTY(())\n   int visited;\n };\n \n+struct tree_bb_info GTY(())\n+{\n+  /* Pointers to the first and last trees of the block.  */\n+  tree stmt_list;\n+\n+  /* Chain of PHI nodes for this block.  */\n+  tree phi_nodes;\n+};\n+\n typedef struct basic_block_def *basic_block;\n \n DEF_VEC_P(basic_block);"}, {"sha": "23cf4477ed4a5fe2a86f8b5e94d6531de6cb0e42", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7506e1cbdcf2b1df305bced4ea29845595a07edb/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7506e1cbdcf2b1df305bced4ea29845595a07edb/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=7506e1cbdcf2b1df305bced4ea29845595a07edb", "patch": "@@ -1439,7 +1439,8 @@ expand_gimple_tailcall (basic_block bb, tree stmt, bool *can_fallthru)\n static basic_block\n expand_gimple_basic_block (basic_block bb)\n {\n-  block_stmt_iterator bsi = bsi_start (bb);\n+  tree_stmt_iterator tsi;\n+  tree stmts = bb_stmt_list (bb);\n   tree stmt = NULL;\n   rtx note, last;\n   edge e;\n@@ -1452,11 +1453,13 @@ expand_gimple_basic_block (basic_block bb)\n \t       bb->index);\n     }\n \n+  bb->il.tree = NULL;\n   init_rtl_bb_info (bb);\n   bb->flags |= BB_RTL;\n \n-  if (!bsi_end_p (bsi))\n-    stmt = bsi_stmt (bsi);\n+  tsi = tsi_start (stmts);\n+  if (!tsi_end_p (tsi))\n+    stmt = tsi_stmt (tsi);\n \n   if (stmt && TREE_CODE (stmt) == LABEL_EXPR)\n     {\n@@ -1469,7 +1472,7 @@ expand_gimple_basic_block (basic_block bb)\n       BB_HEAD (bb) = NEXT_INSN (last);\n       if (NOTE_P (BB_HEAD (bb)))\n \tBB_HEAD (bb) = NEXT_INSN (BB_HEAD (bb));\n-      bsi_next (&bsi);\n+      tsi_next (&tsi);\n       note = emit_note_after (NOTE_INSN_BASIC_BLOCK, BB_HEAD (bb));\n \n       maybe_dump_rtl_for_tree_stmt (stmt, last);\n@@ -1493,9 +1496,9 @@ expand_gimple_basic_block (basic_block bb)\n \tei_next (&ei);\n     }\n \n-  for (; !bsi_end_p (bsi); bsi_next (&bsi))\n+  for (; !tsi_end_p (tsi); tsi_next (&tsi))\n     {\n-      tree stmt = bsi_stmt (bsi);\n+      tree stmt = tsi_stmt (tsi);\n       basic_block new_bb;\n \n       if (!stmt)"}, {"sha": "ef29e96c271f64c17c694b91c4002d56e8776312", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7506e1cbdcf2b1df305bced4ea29845595a07edb/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7506e1cbdcf2b1df305bced4ea29845595a07edb/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=7506e1cbdcf2b1df305bced4ea29845595a07edb", "patch": "@@ -2495,7 +2495,7 @@ expand_omp_parallel (struct omp_region *region)\n       /* Declare local variables needed in CHILD_CFUN.  */\n       block = DECL_INITIAL (child_fn);\n       BLOCK_VARS (block) = list2chain (child_cfun->unexpanded_var_list);\n-      DECL_SAVED_TREE (child_fn) = single_succ (entry_bb)->stmt_list;\n+      DECL_SAVED_TREE (child_fn) = bb_stmt_list (single_succ (entry_bb));\n \n       /* Reset DECL_CONTEXT on locals and function arguments.  */\n       for (t = BLOCK_VARS (block); t; t = TREE_CHAIN (t))"}, {"sha": "191d3101c549038565b64eea7e652afc669b224e", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 59, "deletions": 53, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7506e1cbdcf2b1df305bced4ea29845595a07edb/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7506e1cbdcf2b1df305bced4ea29845595a07edb/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=7506e1cbdcf2b1df305bced4ea29845595a07edb", "patch": "@@ -368,7 +368,8 @@ create_bb (void *h, void *e, basic_block after)\n \n   bb->index = last_basic_block;\n   bb->flags = BB_NEW;\n-  bb->stmt_list = h ? (tree) h : alloc_stmt_list ();\n+  bb->il.tree = GGC_CNEW (struct tree_bb_info);\n+  set_bb_stmt_list (bb, h ? (tree) h : alloc_stmt_list ());\n \n   /* Add the new block to the linked list of blocks.  */\n   link_block (bb, after);\n@@ -1306,9 +1307,9 @@ tree_merge_blocks (basic_block a, basic_block b)\n     }\n \n   /* Merge the chains.  */\n-  last = tsi_last (a->stmt_list);\n-  tsi_link_after (&last, b->stmt_list, TSI_NEW_STMT);\n-  b->stmt_list = NULL;\n+  last = tsi_last (bb_stmt_list (a));\n+  tsi_link_after (&last, bb_stmt_list (b), TSI_NEW_STMT);\n+  set_bb_stmt_list (b, NULL_TREE);\n }\n \n \n@@ -1944,57 +1945,60 @@ remove_bb (basic_block bb)\n     }\n \n   /* Remove all the instructions in the block.  */\n-  for (i = bsi_start (bb); !bsi_end_p (i);)\n+  if (bb_stmt_list (bb) != NULL_TREE)\n     {\n-      tree stmt = bsi_stmt (i);\n-      if (TREE_CODE (stmt) == LABEL_EXPR\n-          && (FORCED_LABEL (LABEL_EXPR_LABEL (stmt))\n-\t      || DECL_NONLOCAL (LABEL_EXPR_LABEL (stmt))))\n+      for (i = bsi_start (bb); !bsi_end_p (i);)\n \t{\n-\t  basic_block new_bb;\n-\t  block_stmt_iterator new_bsi;\n+\t  tree stmt = bsi_stmt (i);\n+\t  if (TREE_CODE (stmt) == LABEL_EXPR\n+\t      && (FORCED_LABEL (LABEL_EXPR_LABEL (stmt))\n+\t\t  || DECL_NONLOCAL (LABEL_EXPR_LABEL (stmt))))\n+\t    {\n+\t      basic_block new_bb;\n+\t      block_stmt_iterator new_bsi;\n+\n+\t      /* A non-reachable non-local label may still be referenced.\n+\t\t But it no longer needs to carry the extra semantics of\n+\t\t non-locality.  */\n+\t      if (DECL_NONLOCAL (LABEL_EXPR_LABEL (stmt)))\n+\t\t{\n+\t\t  DECL_NONLOCAL (LABEL_EXPR_LABEL (stmt)) = 0;\n+\t\t  FORCED_LABEL (LABEL_EXPR_LABEL (stmt)) = 1;\n+\t\t}\n \n-\t  /* A non-reachable non-local label may still be referenced.\n-\t     But it no longer needs to carry the extra semantics of\n-\t     non-locality.  */\n-\t  if (DECL_NONLOCAL (LABEL_EXPR_LABEL (stmt)))\n+\t      new_bb = bb->prev_bb;\n+\t      new_bsi = bsi_start (new_bb);\n+\t      bsi_remove (&i, false);\n+\t      bsi_insert_before (&new_bsi, stmt, BSI_NEW_STMT);\n+\t    }\n+\t  else\n \t    {\n-\t      DECL_NONLOCAL (LABEL_EXPR_LABEL (stmt)) = 0;\n-\t      FORCED_LABEL (LABEL_EXPR_LABEL (stmt)) = 1;\n+\t      /* Release SSA definitions if we are in SSA.  Note that we\n+\t\t may be called when not in SSA.  For example,\n+\t\t final_cleanup calls this function via\n+\t\t cleanup_tree_cfg.  */\n+\t      if (gimple_in_ssa_p (cfun))\n+\t\trelease_defs (stmt);\n+\n+\t      bsi_remove (&i, true);\n \t    }\n \n-\t  new_bb = bb->prev_bb;\n-\t  new_bsi = bsi_start (new_bb);\n-\t  bsi_remove (&i, false);\n-\t  bsi_insert_before (&new_bsi, stmt, BSI_NEW_STMT);\n-\t}\n-      else\n-        {\n-\t  /* Release SSA definitions if we are in SSA.  Note that we\n-\t     may be called when not in SSA.  For example,\n-\t     final_cleanup calls this function via\n-\t     cleanup_tree_cfg.  */\n-\t  if (gimple_in_ssa_p (cfun))\n-\t    release_defs (stmt);\n-\n-\t  bsi_remove (&i, true);\n-\t}\n-\n-      /* Don't warn for removed gotos.  Gotos are often removed due to\n-\t jump threading, thus resulting in bogus warnings.  Not great,\n-\t since this way we lose warnings for gotos in the original\n-\t program that are indeed unreachable.  */\n-      if (TREE_CODE (stmt) != GOTO_EXPR && EXPR_HAS_LOCATION (stmt) && !loc)\n-\t{\n+\t  /* Don't warn for removed gotos.  Gotos are often removed due to\n+\t     jump threading, thus resulting in bogus warnings.  Not great,\n+\t     since this way we lose warnings for gotos in the original\n+\t     program that are indeed unreachable.  */\n+\t  if (TREE_CODE (stmt) != GOTO_EXPR && EXPR_HAS_LOCATION (stmt) && !loc)\n+\t    {\n #ifdef USE_MAPPED_LOCATION\n-\t  if (EXPR_HAS_LOCATION (stmt))\n-\t    loc = EXPR_LOCATION (stmt);\n+\t      if (EXPR_HAS_LOCATION (stmt))\n+\t\tloc = EXPR_LOCATION (stmt);\n #else\n-\t  source_locus t;\n-\t  t = EXPR_LOCUS (stmt);\n-\t  if (t && LOCATION_LINE (*t) > 0)\n-\t    loc = t;\n+\t      source_locus t;\n+\t      t = EXPR_LOCUS (stmt);\n+\t      if (t && LOCATION_LINE (*t) > 0)\n+\t\tloc = t;\n #endif\n+\t    }\n \t}\n     }\n \n@@ -2011,6 +2015,7 @@ remove_bb (basic_block bb)\n #endif\n \n   remove_phi_nodes_and_edges_for_unreachable_block (bb);\n+  bb->il.tree = NULL;\n }\n \n \n@@ -3651,15 +3656,15 @@ tree_verify_flow_info (void)\n   edge e;\n   edge_iterator ei;\n \n-  if (ENTRY_BLOCK_PTR->stmt_list)\n+  if (ENTRY_BLOCK_PTR->il.tree)\n     {\n-      error (\"ENTRY_BLOCK has a statement list associated with it\");\n+      error (\"ENTRY_BLOCK has IL associated with it\");\n       err = 1;\n     }\n \n-  if (EXIT_BLOCK_PTR->stmt_list)\n+  if (EXIT_BLOCK_PTR->il.tree)\n     {\n-      error (\"EXIT_BLOCK has a statement list associated with it\");\n+      error (\"EXIT_BLOCK has IL associated with it\");\n       err = 1;\n     }\n \n@@ -4200,7 +4205,7 @@ tree_split_block (basic_block bb, void *stmt)\n {\n   block_stmt_iterator bsi;\n   tree_stmt_iterator tsi_tgt;\n-  tree act;\n+  tree act, list;\n   basic_block new_bb;\n   edge e;\n   edge_iterator ei;\n@@ -4240,8 +4245,9 @@ tree_split_block (basic_block bb, void *stmt)\n      brings ugly quadratic memory consumption in the inliner.  \n      (We are still quadratic since we need to update stmt BB pointers,\n      sadly.)  */\n-  new_bb->stmt_list = tsi_split_statement_list_before (&bsi.tsi);\n-  for (tsi_tgt = tsi_start (new_bb->stmt_list);\n+  list = tsi_split_statement_list_before (&bsi.tsi);\n+  set_bb_stmt_list (new_bb, list);\n+  for (tsi_tgt = tsi_start (list);\n        !tsi_end_p (tsi_tgt); tsi_next (&tsi_tgt))\n     change_bb_for_stmt (tsi_stmt (tsi_tgt), new_bb);\n "}, {"sha": "dc4b2d16a515a6facdf8a5230a66dabeef08d2cc", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7506e1cbdcf2b1df305bced4ea29845595a07edb/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7506e1cbdcf2b1df305bced4ea29845595a07edb/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=7506e1cbdcf2b1df305bced4ea29845595a07edb", "patch": "@@ -637,7 +637,19 @@ addresses_taken (tree stmt)\n static inline tree\n phi_nodes (basic_block bb)\n {\n-  return bb->phi_nodes;\n+  gcc_assert (!(bb->flags & BB_RTL));\n+  if (!bb->il.tree)\n+    return NULL;\n+  return bb->il.tree->phi_nodes;\n+}\n+\n+/* Return pointer to the list of PHI nodes for basic block BB.  */\n+\n+static inline tree *\n+phi_nodes_ptr (basic_block bb)\n+{\n+  gcc_assert (!(bb->flags & BB_RTL));\n+  return &bb->il.tree->phi_nodes;\n }\n \n /* Set list of phi nodes of a basic block BB to L.  */\n@@ -647,7 +659,8 @@ set_phi_nodes (basic_block bb, tree l)\n {\n   tree phi;\n \n-  bb->phi_nodes = l;\n+  gcc_assert (!(bb->flags & BB_RTL));\n+  bb->il.tree->phi_nodes = l;\n   for (phi = l; phi; phi = PHI_CHAIN (phi))\n     set_bb_for_stmt (phi, bb);\n }\n@@ -746,20 +759,37 @@ phi_ssa_name_p (tree t)\n \n /*  -----------------------------------------------------------------------  */\n \n+/* Returns the list of statements in BB.  */\n+\n+static inline tree\n+bb_stmt_list (basic_block bb)\n+{\n+  gcc_assert (!(bb->flags & BB_RTL));\n+  return bb->il.tree->stmt_list;\n+}\n+\n+/* Sets the list of statements in BB to LIST.  */\n+\n+static inline void\n+set_bb_stmt_list (basic_block bb, tree list)\n+{\n+  gcc_assert (!(bb->flags & BB_RTL));\n+  bb->il.tree->stmt_list = list;\n+}\n+\n /* Return a block_stmt_iterator that points to beginning of basic\n    block BB.  */\n static inline block_stmt_iterator\n bsi_start (basic_block bb)\n {\n   block_stmt_iterator bsi;\n-  if (bb->stmt_list)\n-    bsi.tsi = tsi_start (bb->stmt_list);\n-  else\n+  if (bb->index < NUM_FIXED_BLOCKS)\n     {\n-      gcc_assert (bb->index < NUM_FIXED_BLOCKS);\n       bsi.tsi.ptr = NULL;\n       bsi.tsi.container = NULL;\n     }\n+  else\n+    bsi.tsi = tsi_start (bb_stmt_list (bb));\n   bsi.bb = bb;\n   return bsi;\n }\n@@ -784,14 +814,14 @@ static inline block_stmt_iterator\n bsi_last (basic_block bb)\n {\n   block_stmt_iterator bsi;\n-  if (bb->stmt_list)\n-    bsi.tsi = tsi_last (bb->stmt_list);\n-  else\n+\n+  if (bb->index < NUM_FIXED_BLOCKS)\n     {\n-      gcc_assert (bb->index < NUM_FIXED_BLOCKS);\n       bsi.tsi.ptr = NULL;\n       bsi.tsi.container = NULL;\n     }\n+  else\n+    bsi.tsi = tsi_last (bb_stmt_list (bb));\n   bsi.bb = bb;\n   return bsi;\n }"}, {"sha": "580848eb06a0cae0d76b3398330879ae30163a9a", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7506e1cbdcf2b1df305bced4ea29845595a07edb/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7506e1cbdcf2b1df305bced4ea29845595a07edb/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=7506e1cbdcf2b1df305bced4ea29845595a07edb", "patch": "@@ -865,7 +865,7 @@ process_phi_nodes (struct loop *loop)\n \t  release_phi_node (phi);\n \t  phi = next;\n \t}\n-      bb->phi_nodes = NULL;\n+      set_phi_nodes (bb, NULL_TREE);\n     }\n   return;\n }\n@@ -960,9 +960,9 @@ combine_blocks (struct loop *loop)\n \t}\n \n       /* Update stmt list.  */\n-      last = tsi_last (merge_target_bb->stmt_list);\n-      tsi_link_after (&last, bb->stmt_list, TSI_NEW_STMT);\n-      bb->stmt_list = alloc_stmt_list ();\n+      last = tsi_last (bb_stmt_list (merge_target_bb));\n+      tsi_link_after (&last, bb_stmt_list (bb), TSI_NEW_STMT);\n+      set_bb_stmt_list (bb, NULL);\n \n       delete_basic_block (bb);\n     }"}, {"sha": "e77f4884d727d6a81ceb58f30ce3590f092999ff", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7506e1cbdcf2b1df305bced4ea29845595a07edb/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7506e1cbdcf2b1df305bced4ea29845595a07edb/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=7506e1cbdcf2b1df305bced4ea29845595a07edb", "patch": "@@ -313,7 +313,7 @@ reserve_phi_args_for_new_edge (basic_block bb)\n   int len = EDGE_COUNT (bb->preds);\n   int cap = ideal_phi_node_len (len + 4);\n \n-  for (loc = &(bb->phi_nodes);\n+  for (loc = phi_nodes_ptr (bb);\n        *loc;\n        loc = &PHI_CHAIN (*loc))\n     {\n@@ -354,7 +354,7 @@ create_phi_node (tree var, basic_block bb)\n \n   /* Add the new PHI node to the list of PHI nodes for block BB.  */\n   PHI_CHAIN (phi) = phi_nodes (bb);\n-  bb->phi_nodes = phi;\n+  set_phi_nodes (bb, phi);\n \n   /* Associate BB to the PHI node.  */\n   set_bb_for_stmt (phi, bb);\n@@ -458,7 +458,7 @@ remove_phi_node (tree phi, tree prev, bool release_lhs_p)\n     }\n   else\n     {\n-      for (loc = &(bb_for_stmt (phi)->phi_nodes);\n+      for (loc = phi_nodes_ptr (bb_for_stmt (phi));\n \t   *loc != phi;\n \t   loc = &PHI_CHAIN (*loc))\n \t;"}]}