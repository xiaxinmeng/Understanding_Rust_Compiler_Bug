{"sha": "b3587b99fb85f57feaff63b3c37cd15e79ec7804", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM1ODdiOTlmYjg1ZjU3ZmVhZmY2M2IzYzM3Y2QxNWU3OWVjNzgwNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-04-23T15:25:26Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-04-23T15:25:26Z"}, "message": "ipa-icf.c (sem_item::compare_attributes): New function.\n\n\n\t* ipa-icf.c (sem_item::compare_attributes): New function.\n\t(sem_item::compare_referenced_symbol_properties): Compare variable\n\tattributes.\n\t(sem_item::hash_referenced_symbol_properties): Record DECL_ALIGN.\n\t(sem_function::param_used_p): New function.\n\t(sem_function::equals_wpa): Fix attribute comparsion; match\n\tparameter type codes; do not compare paremter flags when\n\tthey are not used; compare edge flags; compare indirect calls.\n\t(sem_item::update_hash_by_addr_refs): Hash reference type.\n\t(sem_function::equals_private): Do not match DECL_ATTRIBUTES.\n\t(sem_variable::equals_wpa): Do not match DECL_ALIGN; match\n\treference use type.\n\t(sem_item_optimizer::update_hash_by_addr_refs): Use param_used_p.\n\t* ipa-icf.h (compare_attributes, param_used_p): Declare.\n\nFrom-SVN: r222374", "tree": {"sha": "d6b15aa51b46d77748d8d4c072013fffecdf527f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6b15aa51b46d77748d8d4c072013fffecdf527f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3587b99fb85f57feaff63b3c37cd15e79ec7804", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3587b99fb85f57feaff63b3c37cd15e79ec7804", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3587b99fb85f57feaff63b3c37cd15e79ec7804", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3587b99fb85f57feaff63b3c37cd15e79ec7804/comments", "author": null, "committer": null, "parents": [{"sha": "9f468990e1a033fb5b2616238e86e78d2506fdfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f468990e1a033fb5b2616238e86e78d2506fdfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f468990e1a033fb5b2616238e86e78d2506fdfd"}], "stats": {"total": 198, "additions": 152, "deletions": 46}, "files": [{"sha": "2d2b97a0bac00de3d1c0b1f30b3087f73dbecf8e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3587b99fb85f57feaff63b3c37cd15e79ec7804/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3587b99fb85f57feaff63b3c37cd15e79ec7804/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b3587b99fb85f57feaff63b3c37cd15e79ec7804", "patch": "@@ -1,3 +1,20 @@\n+2015-04-23  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-icf.c (sem_item::compare_attributes): New function.\n+\t(sem_item::compare_referenced_symbol_properties): Compare variable\n+\tattributes.\n+\t(sem_item::hash_referenced_symbol_properties): Record DECL_ALIGN.\n+\t(sem_function::param_used_p): New function.\n+\t(sem_function::equals_wpa): Fix attribute comparsion; match\n+\tparameter type codes; do not compare paremter flags when\n+\tthey are not used; compare edge flags; compare indirect calls.\n+\t(sem_item::update_hash_by_addr_refs): Hash reference type.\n+\t(sem_function::equals_private): Do not match DECL_ATTRIBUTES.\n+\t(sem_variable::equals_wpa): Do not match DECL_ALIGN; match\n+\treference use type.\n+\t(sem_item_optimizer::update_hash_by_addr_refs): Use param_used_p.\n+\t* ipa-icf.h (compare_attributes, param_used_p): Declare.\n+\n 2015-04-23  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-icf.c (symbol_compare_collection::symbol_compare_collection):"}, {"sha": "5336744fc2fb2ac1ac4594caceaf4543e8979eee", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 129, "deletions": 46, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3587b99fb85f57feaff63b3c37cd15e79ec7804/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3587b99fb85f57feaff63b3c37cd15e79ec7804/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=b3587b99fb85f57feaff63b3c37cd15e79ec7804", "patch": "@@ -350,6 +350,57 @@ sem_function::get_hash (void)\n   return hash;\n }\n \n+/* Return ture if A1 and A2 represent equivalent function attribute lists.\n+   Based on comp_type_attributes.  */\n+\n+bool\n+sem_item::compare_attributes (const_tree a1, const_tree a2)\n+{\n+  const_tree a;\n+  if (a1 == a2)\n+    return true;\n+  for (a = a1; a != NULL_TREE; a = TREE_CHAIN (a))\n+    {\n+      const struct attribute_spec *as;\n+      const_tree attr;\n+\n+      as = lookup_attribute_spec (get_attribute_name (a));\n+      /* TODO: We can introduce as->affects_decl_identity\n+\t and as->affects_decl_reference_identity if attribute mismatch\n+\t gets a common reason to give up on merging.  It may not be worth\n+\t the effort.\n+\t For example returns_nonnull affects only references, while\n+\t optimize attribute can be ignored because it is already lowered\n+\t into flags representation and compared separately.  */\n+      if (!as)\n+        continue;\n+\n+      attr = lookup_attribute (as->name, CONST_CAST_TREE (a2));\n+      if (!attr || !attribute_value_equal (a, attr))\n+        break;\n+    }\n+  if (!a)\n+    {\n+      for (a = a2; a != NULL_TREE; a = TREE_CHAIN (a))\n+\t{\n+\t  const struct attribute_spec *as;\n+\n+\t  as = lookup_attribute_spec (get_attribute_name (a));\n+\t  if (!as)\n+\t    continue;\n+\n+\t  if (!lookup_attribute (as->name, CONST_CAST_TREE (a1)))\n+\t    break;\n+\t  /* We don't need to compare trees again, as we did this\n+\t     already in first loop.  */\n+\t}\n+      if (!a)\n+        return true;\n+    }\n+  /* TODO: As in comp_type_attributes we may want to introduce target hook.  */\n+  return false;\n+}\n+\n /* Compare properties of symbols N1 and N2 that does not affect semantics of\n    symbol itself but affects semantics of its references from USED_BY (which\n    may be NULL if it is unknown).  If comparsion is false, symbols\n@@ -414,6 +465,21 @@ sem_item::compare_referenced_symbol_properties (symtab_node *used_by,\n \t      || opt_for_fn (used_by->decl, flag_devirtualize)))\n \treturn return_false_with_msg\n \t\t (\"references to virtual tables can not be merged\");\n+\n+      if (address && DECL_ALIGN (n1->decl) != DECL_ALIGN (n2->decl))\n+\treturn return_false_with_msg (\"alignment mismatch\");\n+\n+      /* For functions we compare attributes in equals_wpa, because we do\n+\t not know what attributes may cause codegen differences, but for\n+\t variables just compare attributes for references - the codegen\n+\t for constructors is affected only by those attributes that we lower\n+\t to explicit representation (such as DECL_ALIGN or DECL_SECTION).  */\n+      if (!compare_attributes (DECL_ATTRIBUTES (n1->decl),\n+\t\t\t       DECL_ATTRIBUTES (n2->decl)))\n+\treturn return_false_with_msg (\"different var decl attributes\");\n+      if (comp_type_attributes (TREE_TYPE (n1->decl),\n+\t\t\t\tTREE_TYPE (n2->decl)) != 1)\n+\treturn return_false_with_msg (\"different var type attributes\");\n     }\n \n   /* When matching virtual tables, be sure to also match information\n@@ -451,6 +517,8 @@ sem_item::hash_referenced_symbol_properties (symtab_node *ref,\n   else if (is_a <varpool_node *> (ref))\n     {\n       hstate.add_flag (DECL_VIRTUAL_P (ref->decl));\n+      if (address)\n+\thstate.add_int (DECL_ALIGN (ref->decl));\n     }\n }\n \n@@ -509,6 +577,23 @@ bool sem_function::compare_edge_flags (cgraph_edge *e1, cgraph_edge *e2)\n   return true;\n }\n \n+/* Return true if parameter I may be used.  */\n+\n+bool\n+sem_function::param_used_p (unsigned int i)\n+{\n+  if (ipa_node_params_sum == NULL)\n+    return false;\n+\n+  struct ipa_node_params *parms_info = IPA_NODE_REF (get_node ());\n+\n+  if (parms_info->descriptors.is_empty ()\n+      || parms_info->descriptors.length () <= i)\n+     return true;\n+\n+  return ipa_is_param_used (IPA_NODE_REF (get_node ()), i);\n+}\n+\n /* Fast equality function based on knowledge known in WPA.  */\n \n bool\n@@ -541,6 +626,10 @@ sem_function::equals_wpa (sem_item *item,\n   if (DECL_CXX_DESTRUCTOR_P (decl) != DECL_CXX_DESTRUCTOR_P (item->decl))\n     return return_false_with_msg (\"DECL_CXX_DESTRUCTOR mismatch\");\n \n+  /* TODO: pure/const flags mostly matters only for references, except for\n+     the fact that codegen takes LOOPING flag as a hint that loops are\n+     finite.  We may arrange the code to always pick leader that has least\n+     specified flags and then this can go into comparing symbol properties.  */\n   if (flags_from_decl_or_type (decl) != flags_from_decl_or_type (item->decl))\n     return return_false_with_msg (\"decl_or_type flags are different\");\n \n@@ -599,9 +688,15 @@ sem_function::equals_wpa (sem_item *item,\n       if (!arg_types[i] || !m_compared_func->arg_types[i])\n \treturn return_false_with_msg (\"NULL argument type\");\n \n+      /* We always need to match types so we are sure the callin conventions\n+\t are compatible.  */\n       if (!func_checker::compatible_types_p (arg_types[i],\n \t\t\t\t\t     m_compared_func->arg_types[i]))\n \treturn return_false_with_msg (\"argument type is different\");\n+\n+      /* On used arguments we need to do a bit more of work.  */\n+      if (!param_used_p (i))\n+\tcontinue;\n       if (POINTER_TYPE_P (arg_types[i])\n \t  && (TYPE_RESTRICT (arg_types[i])\n \t      != TYPE_RESTRICT (m_compared_func->arg_types[i])))\n@@ -617,19 +712,21 @@ sem_function::equals_wpa (sem_item *item,\n   if (node->num_references () != item->node->num_references ())\n     return return_false_with_msg (\"different number of references\");\n \n+  /* Checking function attributes.\n+     This is quadratic in number of attributes  */\n   if (comp_type_attributes (TREE_TYPE (decl),\n \t\t\t    TREE_TYPE (item->decl)) != 1)\n     return return_false_with_msg (\"different type attributes\");\n+  if (!compare_attributes (DECL_ATTRIBUTES (decl),\n+\t\t\t   DECL_ATTRIBUTES (item->decl)))\n+    return return_false_with_msg (\"different decl attributes\");\n \n   /* The type of THIS pointer type memory location for\n      ipa-polymorphic-call-analysis.  */\n   if (opt_for_fn (decl, flag_devirtualize)\n       && (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE\n           || TREE_CODE (TREE_TYPE (item->decl)) == METHOD_TYPE)\n-      && (ipa_node_params_sum == NULL\n-\t  || IPA_NODE_REF (get_node ())->descriptors.is_empty ()\n-\t  || ipa_is_param_used (IPA_NODE_REF (get_node ()),\n-\t\t\t\t0))\n+      && param_used_p (0)\n       && compare_polymorphic_p ())\n     {\n       if (TREE_CODE (TREE_TYPE (decl)) != TREE_CODE (TREE_TYPE (item->decl)))\n@@ -645,6 +742,9 @@ sem_function::equals_wpa (sem_item *item,\n     {\n       item->node->iterate_reference (i, ref2);\n \n+      if (ref->use != ref2->use)\n+\treturn return_false_with_msg (\"reference use mismatch\");\n+\n       if (!compare_symbol_references (ignored_nodes, ref->referred,\n \t\t\t\t      ref2->referred,\n \t\t\t\t      ref->address_matters_p ()))\n@@ -659,13 +759,30 @@ sem_function::equals_wpa (sem_item *item,\n       if (!compare_symbol_references (ignored_nodes, e1->callee,\n \t\t\t\t      e2->callee, false))\n \treturn false;\n+      if (!compare_edge_flags (e1, e2))\n+\treturn false;\n \n       e1 = e1->next_callee;\n       e2 = e2->next_callee;\n     }\n \n   if (e1 || e2)\n-    return return_false_with_msg (\"different number of edges\");\n+    return return_false_with_msg (\"different number of calls\");\n+\n+  e1 = dyn_cast <cgraph_node *> (node)->indirect_calls;\n+  e2 = dyn_cast <cgraph_node *> (item->node)->indirect_calls;\n+\n+  while (e1 && e2)\n+    {\n+      if (!compare_edge_flags (e1, e2))\n+\treturn false;\n+\n+      e1 = e1->next_callee;\n+      e2 = e2->next_callee;\n+    }\n+\n+  if (e1 || e2)\n+    return return_false_with_msg (\"different number of indirect calls\");\n \n   return true;\n }\n@@ -687,6 +804,7 @@ sem_item::update_hash_by_addr_refs (hash_map <symtab_node *,\n \n   for (unsigned i = 0; node->iterate_reference (i, ref); i++)\n     {\n+      hstate.add_int (ref->use);\n       hash_referenced_symbol_properties (ref->referred, hstate,\n \t\t\t\t\t ref->use == IPA_REF_ADDR);\n       if (ref->address_matters_p () || !m_symtab_node_map.get (ref->referred))\n@@ -796,45 +914,11 @@ sem_function::equals_private (sem_item *item,\n   if (!equals_wpa (item, ignored_nodes))\n     return false;\n \n-  /* Checking function arguments.  */\n-  tree decl1 = DECL_ATTRIBUTES (decl);\n-  tree decl2 = DECL_ATTRIBUTES (m_compared_func->decl);\n-\n   m_checker = new func_checker (decl, m_compared_func->decl,\n \t\t\t\tcompare_polymorphic_p (),\n \t\t\t\tfalse,\n \t\t\t\t&refs_set,\n \t\t\t\t&m_compared_func->refs_set);\n-  while (decl1)\n-    {\n-      if (decl2 == NULL)\n-\treturn return_false ();\n-\n-      if (get_attribute_name (decl1) != get_attribute_name (decl2))\n-\treturn return_false ();\n-\n-      tree attr_value1 = TREE_VALUE (decl1);\n-      tree attr_value2 = TREE_VALUE (decl2);\n-\n-      if (attr_value1 && attr_value2)\n-\t{\n-\t  bool ret = m_checker->compare_operand (TREE_VALUE (attr_value1),\n-\t\t\t\t\t\t TREE_VALUE (attr_value2));\n-\t  if (!ret)\n-\t    return return_false_with_msg (\"attribute values are different\");\n-\t}\n-      else if (!attr_value1 && !attr_value2)\n-\t{}\n-      else\n-\treturn return_false ();\n-\n-      decl1 = TREE_CHAIN (decl1);\n-      decl2 = TREE_CHAIN (decl2);\n-    }\n-\n-  if (decl1 != decl2)\n-    return return_false();\n-\n   for (arg1 = DECL_ARGUMENTS (decl),\n        arg2 = DECL_ARGUMENTS (m_compared_func->decl);\n        arg1; arg1 = DECL_CHAIN (arg1), arg2 = DECL_CHAIN (arg2))\n@@ -1748,8 +1832,8 @@ sem_variable::equals_wpa (sem_item *item,\n   if (DECL_TLS_MODEL (decl) || DECL_TLS_MODEL (item->decl))\n     return return_false_with_msg (\"TLS model\");\n \n-  if (DECL_ALIGN (decl) != DECL_ALIGN (item->decl))\n-    return return_false_with_msg (\"alignment mismatch\");\n+  /* DECL_ALIGN is safe to merge, because we will always chose the largest\n+     alignment out of all aliases.  */\n \n   if (DECL_VIRTUAL_P (decl) != DECL_VIRTUAL_P (item->decl))\n     return return_false_with_msg (\"Virtual flag mismatch\");\n@@ -1775,6 +1859,9 @@ sem_variable::equals_wpa (sem_item *item,\n     {\n       item->node->iterate_reference (i, ref2);\n \n+      if (ref->use != ref2->use)\n+\treturn return_false_with_msg (\"reference use mismatch\");\n+\n       if (!compare_symbol_references (ignored_nodes,\n \t\t\t\t      ref->referred, ref2->referred,\n \t\t\t\t      ref->address_matters_p ()))\n@@ -2601,15 +2688,11 @@ sem_item_optimizer::update_hash_by_addr_refs ()\n       m_items[i]->update_hash_by_addr_refs (m_symtab_node_map);\n       if (m_items[i]->type == FUNC)\n \t{\n-\t  cgraph_node *cnode = dyn_cast <cgraph_node *> (m_items[i]->node);\n-\n \t  if (TREE_CODE (TREE_TYPE (m_items[i]->decl)) == METHOD_TYPE\n \t      && contains_polymorphic_type_p\n \t\t   (method_class_type (TREE_TYPE (m_items[i]->decl)))\n \t      && (DECL_CXX_CONSTRUCTOR_P (m_items[i]->decl)\n-\t\t  || ((ipa_node_params_sum == NULL\n-\t\t       || IPA_NODE_REF (cnode)->descriptors.is_empty ()\n-\t\t       || ipa_is_param_used (IPA_NODE_REF (cnode), 0))\n+\t\t  || (static_cast<sem_function *> (m_items[i])->param_used_p (0)\n \t\t      && static_cast<sem_function *> (m_items[i])\n \t\t\t   ->compare_polymorphic_p ())))\n \t     {"}, {"sha": "8ad09df4c8aec2eb4a17b9f80fea5799493e25b6", "filename": "gcc/ipa-icf.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3587b99fb85f57feaff63b3c37cd15e79ec7804/gcc%2Fipa-icf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3587b99fb85f57feaff63b3c37cd15e79ec7804/gcc%2Fipa-icf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.h?ref=b3587b99fb85f57feaff63b3c37cd15e79ec7804", "patch": "@@ -256,6 +256,9 @@ class sem_item\n \t\t\t\t\t            symtab_node *n2,\n \t\t\t\t\t            bool address);\n \n+  /* Compare two attribute lists.  */\n+  static bool compare_attributes (const_tree list1, const_tree list2);\n+\n   /* Hash properties compared by compare_referenced_symbol_properties.  */\n   void hash_referenced_symbol_properties (symtab_node *ref,\n \t\t\t\t\t  inchash::hash &hstate,\n@@ -356,6 +359,9 @@ class sem_function: public sem_item\n   /* Array of structures for all basic blocks.  */\n   vec <ipa_icf_gimple::sem_bb *> bb_sorted;\n \n+  /* Return true if parameter I may be used.  */\n+  bool param_used_p (unsigned int i);\n+\n private:\n   /* Calculates hash value based on a BASIC_BLOCK.  */\n   hashval_t get_bb_hash (const ipa_icf_gimple::sem_bb *basic_block);"}]}