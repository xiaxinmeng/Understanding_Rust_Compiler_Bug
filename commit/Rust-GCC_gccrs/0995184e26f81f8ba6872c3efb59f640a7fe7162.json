{"sha": "0995184e26f81f8ba6872c3efb59f640a7fe7162", "node_id": "C_kwDOANBUbNoAKDA5OTUxODRlMjZmODFmOGJhNjg3MmMzZWZiNTlmNjQwYTdmZTcxNjI", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-11-18T00:16:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-18T00:16:47Z"}, "message": "Merge #810\n\n810: Fix MethodCalls for covariant impl blocks r=philberty a=philberty\n\nI think we need to research more into how we probe for potential candidates\r\nfor method calls. This fixes a few bugs going on in #808 one where the \r\ncanonical path was empty and one where we fail to probe directly on the\r\nreceiver of reference types to impl blocks but we must be able to also support\r\nthat autoderef means that a receiver's root type might actually be the type we\r\ncare about for example a reference to a generic type-parameter and we probe\r\nits bounds for candidates for example. Lets consult the rustc code and references on this.\r\n\r\nFixes #808\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "01e0e210f795a5fbf25c386aae758d0336ccad8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01e0e210f795a5fbf25c386aae758d0336ccad8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0995184e26f81f8ba6872c3efb59f640a7fe7162", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhlZtvCRBK7hj4Ov3rIwAAlxYIADa16X6ykSJIN0eEEYn71rLV\n/NAj1/+RFG2LS+ysTxgMSSRAswULt8XJsw7smwvz5dOI0olEwBUwEzLxKRMulu+w\n/GQEQ9wt8678akywTG9xFaXtLqeqGgZrQKRGznX1reh+neixd1olpKpxFRme8iHR\nZYgtmgGOLu4cKOhgQOBZSKCsE6keSzjE7msc7bVLLVU160/LQx7/9hho69FFbYWM\nwhAIBCcxwHTiVjBv4RvnDd/FykWxcpwlChAKrutyuuAKeN05WoKB9jsJau0O2c2m\nAPbu5XzlejvgWnVexVfXZrFYkcsft/MboxQ8a3B6pbPaccGyBIEJ96tUE8J2VUg=\n=mkx8\n-----END PGP SIGNATURE-----\n", "payload": "tree 01e0e210f795a5fbf25c386aae758d0336ccad8c\nparent 63fc39600ce2640e9c4d07e00e162c2529b1820a\nparent db832831ed15ad25aec99a7d4a87b7019e5f1aa4\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1637194607 +0000\ncommitter GitHub <noreply@github.com> 1637194607 +0000\n\nMerge #810\n\n810: Fix MethodCalls for covariant impl blocks r=philberty a=philberty\n\nI think we need to research more into how we probe for potential candidates\r\nfor method calls. This fixes a few bugs going on in #808 one where the \r\ncanonical path was empty and one where we fail to probe directly on the\r\nreceiver of reference types to impl blocks but we must be able to also support\r\nthat autoderef means that a receiver's root type might actually be the type we\r\ncare about for example a reference to a generic type-parameter and we probe\r\nits bounds for candidates for example. Lets consult the rustc code and references on this.\r\n\r\nFixes #808\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0995184e26f81f8ba6872c3efb59f640a7fe7162", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0995184e26f81f8ba6872c3efb59f640a7fe7162", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0995184e26f81f8ba6872c3efb59f640a7fe7162/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63fc39600ce2640e9c4d07e00e162c2529b1820a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63fc39600ce2640e9c4d07e00e162c2529b1820a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63fc39600ce2640e9c4d07e00e162c2529b1820a"}, {"sha": "db832831ed15ad25aec99a7d4a87b7019e5f1aa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db832831ed15ad25aec99a7d4a87b7019e5f1aa4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db832831ed15ad25aec99a7d4a87b7019e5f1aa4"}], "stats": {"total": 162, "additions": 140, "deletions": 22}, "files": [{"sha": "f0e9bc338254227701a39ee6c75d0abe91535ff7", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0995184e26f81f8ba6872c3efb59f640a7fe7162/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0995184e26f81f8ba6872c3efb59f640a7fe7162/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=0995184e26f81f8ba6872c3efb59f640a7fe7162", "patch": "@@ -86,6 +86,7 @@ GRS_OBJS = \\\n     rust/rust-hir-const-fold.o \\\n     rust/rust-hir-type-check-type.o \\\n     rust/rust-hir-type-check-struct.o \\\n+    rust/rust-substitution-mapper.o \\\n     rust/rust-lint-marklive.o \\\n     rust/rust-hir-type-check-path.o \\\n     rust/rust-compile-intrinsic.o \\"}, {"sha": "2bcf79d3decb424171b5ce5ee618dcf6d237503f", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0995184e26f81f8ba6872c3efb59f640a7fe7162/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0995184e26f81f8ba6872c3efb59f640a7fe7162/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=0995184e26f81f8ba6872c3efb59f640a7fe7162", "patch": "@@ -101,6 +101,7 @@ class ResolveTypeToCanonicalPath : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n+  // FIXME this should really only take AST::TypeNoBounds&\n   static CanonicalPath resolve (AST::Type &type,\n \t\t\t\tbool include_generic_args = true,\n \t\t\t\tbool type_resolve_generic_args = true)\n@@ -121,6 +122,8 @@ class ResolveTypeToCanonicalPath : public ResolverBase\n       }\n   }\n \n+  void visit (AST::ReferenceType &ref) override;\n+\n   void visit (AST::TypePathSegmentGeneric &seg) override;\n \n   void visit (AST::TypePathSegment &seg) override;"}, {"sha": "9a0d349a2fd553b6622b94074d2b0c917642ca41", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0995184e26f81f8ba6872c3efb59f640a7fe7162/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0995184e26f81f8ba6872c3efb59f640a7fe7162/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=0995184e26f81f8ba6872c3efb59f640a7fe7162", "patch": "@@ -439,8 +439,10 @@ ResolveTypeToCanonicalPath::visit (AST::TypePathSegmentGeneric &seg)\n \n   if (!seg.has_generic_args ())\n     {\n-      result = CanonicalPath::new_seg (seg.get_node_id (),\n-\t\t\t\t       seg.get_ident_segment ().as_string ());\n+      auto ident_segment\n+\t= CanonicalPath::new_seg (seg.get_node_id (),\n+\t\t\t\t  seg.get_ident_segment ().as_string ());\n+      result = result.append (ident_segment);\n       return;\n     }\n \n@@ -454,14 +456,18 @@ ResolveTypeToCanonicalPath::visit (AST::TypePathSegmentGeneric &seg)\n     {\n       std::string generics\n \t= canonicalize_generic_args (seg.get_generic_args ());\n-      result = CanonicalPath::new_seg (seg.get_node_id (),\n-\t\t\t\t       seg.get_ident_segment ().as_string ()\n-\t\t\t\t\t + \"::\" + generics);\n+      auto generic_segment\n+\t= CanonicalPath::new_seg (seg.get_node_id (),\n+\t\t\t\t  seg.get_ident_segment ().as_string ()\n+\t\t\t\t    + \"::\" + generics);\n+      result = result.append (generic_segment);\n       return;\n     }\n \n-  result = CanonicalPath::new_seg (seg.get_node_id (),\n-\t\t\t\t   seg.get_ident_segment ().as_string ());\n+  auto ident_segment\n+    = CanonicalPath::new_seg (seg.get_node_id (),\n+\t\t\t      seg.get_ident_segment ().as_string ());\n+  result = result.append (ident_segment);\n }\n \n void\n@@ -481,6 +487,24 @@ ResolveTypeToCanonicalPath::visit (AST::TypePathSegment &seg)\n   result = result.append (ident_seg);\n }\n \n+void\n+ResolveTypeToCanonicalPath::visit (AST::ReferenceType &ref)\n+{\n+  auto inner_type\n+    = ResolveTypeToCanonicalPath::resolve (*ref.get_type_referenced ().get (),\n+\t\t\t\t\t   include_generic_args_flag,\n+\t\t\t\t\t   type_resolve_generic_args_flag);\n+\n+  std::string segment_string (\"&\");\n+  if (ref.get_has_mut ())\n+    segment_string += \"mut \";\n+\n+  segment_string += inner_type.get ();\n+\n+  auto ident_seg = CanonicalPath::new_seg (ref.get_node_id (), segment_string);\n+  result = result.append (ident_seg);\n+}\n+\n // rust-ast-resolve-expr.h\n \n void"}, {"sha": "9eef755e1407fbd58ce149bf3a46130778cfc509", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0995184e26f81f8ba6872c3efb59f640a7fe7162/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0995184e26f81f8ba6872c3efb59f640a7fe7162/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=0995184e26f81f8ba6872c3efb59f640a7fe7162", "patch": "@@ -265,15 +265,29 @@ class TypeCheckExpr : public TypeCheckBase\n     bool probe_impls = !receiver_is_generic;\n     bool ignore_mandatory_trait_items = !receiver_is_generic;\n \n+    auto probe_type = probe_impls ? receiver_tyty : root;\n     auto candidates\n-      = PathProbeType::Probe (root, expr.get_method_name ().get_segment (),\n+      = PathProbeType::Probe (probe_type,\n+\t\t\t      expr.get_method_name ().get_segment (),\n \t\t\t      probe_impls, probe_bounds,\n \t\t\t      ignore_mandatory_trait_items);\n     if (candidates.empty ())\n       {\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"failed to resolve the PathExprSegment to any item\");\n-\treturn;\n+\tif (probe_impls)\n+\t  {\n+\t    candidates\n+\t      = PathProbeType::Probe (root,\n+\t\t\t\t      expr.get_method_name ().get_segment (),\n+\t\t\t\t      probe_impls, probe_bounds,\n+\t\t\t\t      ignore_mandatory_trait_items);\n+\t  }\n+\n+\tif (candidates.empty ())\n+\t  {\n+\t    rust_error_at (expr.get_locus (),\n+\t\t\t   \"failed to resolve the PathExprSegment to any item\");\n+\t    return;\n+\t  }\n       }\n \n     std::vector<Adjustment> adjustments;\n@@ -295,6 +309,10 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn;\n       }\n \n+    // Get the adjusted self\n+    Adjuster adj (receiver_tyty);\n+    TyTy::BaseType *adjusted_self = adj.adjust_type (adjustments);\n+\n     // store the adjustments for code-generation to know what to do\n     context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),\n \t\t\t\t\tstd::move (adjustments));\n@@ -401,7 +419,8 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n \n     TyTy::BaseType *function_ret_tyty\n-      = TyTy::TypeCheckMethodCallExpr::go (lookup, expr, context);\n+      = TyTy::TypeCheckMethodCallExpr::go (lookup, expr, adjusted_self,\n+\t\t\t\t\t   context);\n     if (function_ret_tyty == nullptr\n \t|| function_ret_tyty->get_kind () == TyTy::TypeKind::ERROR)\n       {"}, {"sha": "a439416b698df6cea1f7d3ace58002601d151341", "filename": "gcc/rust/typecheck/rust-substitution-mapper.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0995184e26f81f8ba6872c3efb59f640a7fe7162/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0995184e26f81f8ba6872c3efb59f640a7fe7162/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.cc?ref=0995184e26f81f8ba6872c3efb59f640a7fe7162", "patch": "@@ -0,0 +1,49 @@\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-substitution-mapper.h\"\n+#include \"rust-hir-type-check.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+TyTy::BaseType *\n+SubstMapperInternal::Resolve (TyTy::BaseType *base,\n+\t\t\t      TyTy::SubstitutionArgumentMappings &mappings)\n+{\n+  SubstMapperInternal mapper (base->get_ref (), mappings);\n+  base->accept_vis (mapper);\n+  rust_assert (mapper.resolved != nullptr);\n+\n+  // insert these new implict types into the context\n+  bool is_fn = mapper.resolved->get_kind () == TyTy::TypeKind::FNDEF;\n+  bool is_adt = mapper.resolved->get_kind () == TyTy::TypeKind::ADT;\n+  bool is_param = mapper.resolved->get_kind () == TyTy::TypeKind::PARAM;\n+  if (!is_fn && !is_adt && !is_param)\n+    {\n+      auto context = TypeCheckContext::get ();\n+      context->insert_type (\n+\tAnalysis::NodeMapping (0, 0, mapper.resolved->get_ty_ref (), 0),\n+\tmapper.resolved);\n+    }\n+\n+  return mapper.resolved;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "0932038d8c2554f8d9fcfeff6822b7ed36c1b65a", "filename": "gcc/rust/typecheck/rust-substitution-mapper.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0995184e26f81f8ba6872c3efb59f640a7fe7162/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0995184e26f81f8ba6872c3efb59f640a7fe7162/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h?ref=0995184e26f81f8ba6872c3efb59f640a7fe7162", "patch": "@@ -154,13 +154,7 @@ class SubstMapperInternal : public TyTy::TyVisitor\n {\n public:\n   static TyTy::BaseType *Resolve (TyTy::BaseType *base,\n-\t\t\t\t  TyTy::SubstitutionArgumentMappings &mappings)\n-  {\n-    SubstMapperInternal mapper (base->get_ref (), mappings);\n-    base->accept_vis (mapper);\n-    rust_assert (mapper.resolved != nullptr);\n-    return mapper.resolved;\n-  }\n+\t\t\t\t  TyTy::SubstitutionArgumentMappings &mappings);\n \n   void visit (TyTy::FnType &type) override\n   {"}, {"sha": "30804273f753db8230bca10c6d63cb6797f816f2", "filename": "gcc/rust/typecheck/rust-tyty-call.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0995184e26f81f8ba6872c3efb59f640a7fe7162/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0995184e26f81f8ba6872c3efb59f640a7fe7162/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h?ref=0995184e26f81f8ba6872c3efb59f640a7fe7162", "patch": "@@ -88,9 +88,10 @@ class TypeCheckMethodCallExpr : private TyVisitor\n public:\n   // Resolve the Method parameters and return back the return type\n   static BaseType *go (BaseType *ref, HIR::MethodCallExpr &call,\n+\t\t       TyTy::BaseType *adjusted_self,\n \t\t       Resolver::TypeCheckContext *context)\n   {\n-    TypeCheckMethodCallExpr checker (call, context);\n+    TypeCheckMethodCallExpr checker (call, adjusted_self, context);\n     ref->accept_vis (checker);\n     return checker.resolved;\n   }\n@@ -125,13 +126,15 @@ class TypeCheckMethodCallExpr : private TyVisitor\n \n private:\n   TypeCheckMethodCallExpr (HIR::MethodCallExpr &c,\n+\t\t\t   TyTy::BaseType *adjusted_self,\n \t\t\t   Resolver::TypeCheckContext *context)\n-    : resolved (nullptr), call (c), context (context),\n-      mappings (Analysis::Mappings::get ())\n+    : resolved (nullptr), call (c), adjusted_self (adjusted_self),\n+      context (context), mappings (Analysis::Mappings::get ())\n   {}\n \n   BaseType *resolved;\n   HIR::MethodCallExpr &call;\n+  TyTy::BaseType *adjusted_self;\n   Resolver::TypeCheckContext *context;\n   Analysis::Mappings *mappings;\n };"}, {"sha": "add4dbe695a685c39bdb0c2c1ff3d6c97b8bc1e1", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0995184e26f81f8ba6872c3efb59f640a7fe7162/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0995184e26f81f8ba6872c3efb59f640a7fe7162/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=0995184e26f81f8ba6872c3efb59f640a7fe7162", "patch": "@@ -2786,6 +2786,8 @@ TypeCheckCallExpr::visit (FnPtr &type)\n void\n TypeCheckMethodCallExpr::visit (FnType &type)\n {\n+  adjusted_self->unify (type.get_self_type ());\n+\n   // +1 for the receiver self\n   size_t num_args_to_call = call.num_params () + 1;\n   if (num_args_to_call != type.num_params ())"}, {"sha": "bfbf774fd05e1a2bc9aed1e02c5e048d9271b8a4", "filename": "gcc/testsuite/rust/compile/torture/issue-808.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0995184e26f81f8ba6872c3efb59f640a7fe7162/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-808.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0995184e26f81f8ba6872c3efb59f640a7fe7162/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-808.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-808.rs?ref=0995184e26f81f8ba6872c3efb59f640a7fe7162", "patch": "@@ -0,0 +1,23 @@\n+pub trait Foo {\n+    type Target;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    fn bar(&self) -> &Self::Target;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .Foo::bar.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+impl<T> Foo for &T {\n+    type Target = T;\n+\n+    fn bar(&self) -> &T {\n+        *self\n+    }\n+}\n+\n+pub fn main() {\n+    let a: i32 = 123;\n+    let b: &i32 = &a;\n+\n+    b.bar();\n+}"}]}