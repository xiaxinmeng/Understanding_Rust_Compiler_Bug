{"sha": "06199618c1c047366fdafd2b0fafdace1fb44abc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDYxOTk2MThjMWMwNDczNjZmZGFmZDJiMGZhZmRhY2UxZmI0NGFiYw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-12-18T22:49:57Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-12-18T22:49:57Z"}, "message": "PR middle-end/83373 - False positive reported by -Wstringop-overflow\n\nPR middle-end/83373 - False positive reported by -Wstringop-overflow\nPR tree-optimization/78450 - strlen(s) return value can be assumed to be less than the size of s\n\ngcc/ChangeLog:\n\n\tPR middle-end/83373\n\tPR tree-optimization/78450\n\t* tree-ssa-strlen.c (maybe_set_strlen_range): New function.\n\t(handle_builtin_strlen): Call it.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/83373\n\tPR tree-optimization/78450\n\t* gcc.dg/pr83373.c: New test.\n\t* gcc.dg/strlenopt-36.c: New test.\n\t* gcc.dg/strlenopt-37.c: New test.\n\nFrom-SVN: r255790", "tree": {"sha": "a0d1d0ffb97b3a497c587d6dd9e1ecfd092a08ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0d1d0ffb97b3a497c587d6dd9e1ecfd092a08ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06199618c1c047366fdafd2b0fafdace1fb44abc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06199618c1c047366fdafd2b0fafdace1fb44abc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06199618c1c047366fdafd2b0fafdace1fb44abc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06199618c1c047366fdafd2b0fafdace1fb44abc/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "adaefe2a50b56505b9745955da5231cd87ce9d8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adaefe2a50b56505b9745955da5231cd87ce9d8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adaefe2a50b56505b9745955da5231cd87ce9d8a"}], "stats": {"total": 259, "additions": 259, "deletions": 0}, "files": [{"sha": "d165b5ccf410f4bca19bfb896df3bfecaf1e3865", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06199618c1c047366fdafd2b0fafdace1fb44abc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06199618c1c047366fdafd2b0fafdace1fb44abc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06199618c1c047366fdafd2b0fafdace1fb44abc", "patch": "@@ -1,3 +1,10 @@\n+2017-12-18  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/83373\n+\tPR tree-optimization/78450\n+\t* tree-ssa-strlen.c (maybe_set_strlen_range): New function.\n+\t(handle_builtin_strlen): Call it.\n+\n 2017-12-18  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR rtl-optimization/83424"}, {"sha": "eb2eba70d6698bf3ea88e0253f8f5167f11de28e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06199618c1c047366fdafd2b0fafdace1fb44abc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06199618c1c047366fdafd2b0fafdace1fb44abc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=06199618c1c047366fdafd2b0fafdace1fb44abc", "patch": "@@ -1,3 +1,11 @@\n+2017-12-18  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/83373\n+\tPR tree-optimization/78450\n+\t* gcc.dg/pr83373.c: New test.\n+\t* gcc.dg/strlenopt-36.c: New test.\n+\t* gcc.dg/strlenopt-37.c: New test.\n+\n 2017-12-18  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/83116"}, {"sha": "6b0de0997c0485c8650735ab1cb7c4dfa9e4e2a8", "filename": "gcc/testsuite/gcc.dg/pr83373.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06199618c1c047366fdafd2b0fafdace1fb44abc/gcc%2Ftestsuite%2Fgcc.dg%2Fpr83373.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06199618c1c047366fdafd2b0fafdace1fb44abc/gcc%2Ftestsuite%2Fgcc.dg%2Fpr83373.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr83373.c?ref=06199618c1c047366fdafd2b0fafdace1fb44abc", "patch": "@@ -0,0 +1,33 @@\n+/* PR middle-end/83373 - False positive reported by -Wstringop-overflow\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wstringop-overflow\" }  */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+char buf[100];\n+\n+void get_data (char*);\n+\n+__attribute__ ((nonnull(1, 2)))\n+inline char* my_strcpy (char* dst, const char* src, size_t size)\n+{\n+  size_t len = __builtin_strlen (src);\n+  if (len < size)\n+    __builtin_memcpy (dst, src, len + 1);\n+  else\n+    {\n+      __builtin_memcpy (dst, src, size - 1); /* { dg-bogus \"\\\\\\[-Wstringop-oveflow]\" } */\n+      dst[size - 1] = '\\0';\n+    }\n+\n+  return dst;\n+}\n+\n+void test(void)\n+{\n+  char data[20] = \"12345\";\n+\n+  get_data (data);\n+\n+  my_strcpy (buf, data, sizeof buf);\n+}"}, {"sha": "d6fcca26b976bc79a5ce50635ab99618cad78aa4", "filename": "gcc/testsuite/gcc.dg/strlenopt-36.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06199618c1c047366fdafd2b0fafdace1fb44abc/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-36.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06199618c1c047366fdafd2b0fafdace1fb44abc/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-36.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-36.c?ref=06199618c1c047366fdafd2b0fafdace1fb44abc", "patch": "@@ -0,0 +1,86 @@\n+/* PR tree-optimization/78450 - strlen(s) return value can be assumed\n+   to be less than the size of s\n+   { dg-do compile }\n+   { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+#include \"strlenopt.h\"\n+\n+extern char a7[7], a6[6], a5[5], a4[4], a3[3], a2[2], a1[1];\n+extern char a0[0];   /* Intentionally not tested here.  */\n+extern char ax[];    /* Same.  */\n+\n+struct MemArrays {\n+  char a7[7], a6[6], a5[5], a4[4], a3[3], a2[2], a1[1];\n+  char a0[0];   /* Not tested here.  */\n+};\n+\n+struct NestedMemArrays {\n+  struct { char a7[7]; } ma7;\n+  struct { char a6[6]; } ma6;\n+  struct { char a5[5]; } ma5;\n+  struct { char a4[4]; } ma4;\n+  struct { char a3[3]; } ma3;\n+  struct { char a2[2]; } ma2;\n+  struct { char a1[1]; } ma1;\n+  struct { char a0[0]; } ma0;\n+  char last;\n+};\n+\n+extern void failure_on_line (int);\n+\n+#define TEST_FAIL(line)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    failure_on_line (line);\t\t\t\t\\\n+  } while (0)\n+\n+#define T(expr)\t\t\t\t\t\t\\\n+  if (!(expr)) TEST_FAIL (__LINE__); else (void)0\n+\n+\n+void test_array (void)\n+{\n+  T (strlen (a7) < sizeof a7);\n+  T (strlen (a6) < sizeof a6);\n+  T (strlen (a5) < sizeof a5);\n+  T (strlen (a4) < sizeof a4);\n+  T (strlen (a3) < sizeof a3);\n+\n+  /* The following two calls are folded too early which defeats\n+     the strlen() optimization.\n+    T (strlen (a2) == 1);\n+    T (strlen (a1) == 0);  */\n+}\n+\n+void test_memarray (struct MemArrays *ma)\n+{\n+  T (strlen (ma->a7) < sizeof ma->a7);\n+  T (strlen (ma->a6) < sizeof ma->a6);\n+  T (strlen (ma->a5) < sizeof ma->a5);\n+  T (strlen (ma->a4) < sizeof ma->a4);\n+  T (strlen (ma->a3) < sizeof ma->a3);\n+\n+  /* The following two calls are folded too early which defeats\n+     the strlen() optimization.\n+  T (strlen (ma->a2) == 1);\n+  T (strlen (ma->a1) == 0);  */\n+}\n+\n+/* Verify that the range of strlen(A) of a last struct member is\n+   set even when the array is the sole member of a struct as long\n+   as the struct itself is a member of another struct.  The converse\n+   is tested in stlenopt-37.c.  */\n+void test_nested_memarray (struct NestedMemArrays *ma)\n+{\n+  T (strlen (ma->ma7.a7) < sizeof ma->ma7.a7);\n+  T (strlen (ma->ma6.a6) < sizeof ma->ma6.a6);\n+  T (strlen (ma->ma5.a5) < sizeof ma->ma5.a5);\n+  T (strlen (ma->ma4.a4) < sizeof ma->ma4.a4);\n+  T (strlen (ma->ma3.a3) < sizeof ma->ma3.a3);\n+\n+  /* The following two calls are folded too early which defeats\n+     the strlen() optimization.\n+  T (strlen (ma->ma2.a2) == 1);\n+  T (strlen (ma->ma1.a1) == 0);  */\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"failure_on_line\" \"optimized\" } } */"}, {"sha": "865653c18d3410da25fc9973e01ddfca562ce755", "filename": "gcc/testsuite/gcc.dg/strlenopt-37.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06199618c1c047366fdafd2b0fafdace1fb44abc/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-37.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06199618c1c047366fdafd2b0fafdace1fb44abc/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-37.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-37.c?ref=06199618c1c047366fdafd2b0fafdace1fb44abc", "patch": "@@ -0,0 +1,83 @@\n+/* PR tree-optimization/78450 - strlen(s) return value can be assumed\n+   to be less than the size of s\n+   { dg-do compile }\n+   { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+#include \"strlenopt.h\"\n+\n+extern char ax[];\n+\n+struct MemArray7 { char a7[7]; };\n+struct MemArray6 { char a6[6]; };\n+struct MemArray5 { char a5[5]; };\n+struct MemArray4 { char a4[4]; };\n+struct MemArray3 { char a3[3]; };\n+struct MemArray2 { char a2[2]; };\n+struct MemArray1 { char a1[1]; };\n+struct MemArray0 { int n; char a0[0]; };\n+struct MemArrayX { int n; char ax[]; };\n+\n+struct MemArrays\n+{\n+  struct MemArray7 *ma7;\n+  struct MemArray6 *ma6;\n+  struct MemArray5 *ma5;\n+  struct MemArray4 *ma4;\n+  struct MemArray3 *ma3;\n+  struct MemArray2 *ma2;\n+  struct MemArray1 *ma1;\n+  struct MemArray0 *ma0;\n+  struct MemArrayX *max;\n+};\n+\n+extern void if_stmt_on_line (int);\n+extern void else_stmt_on_line (int);\n+\n+#define T(expr)\t\t\t\t\t\t\t\t\\\n+  (!!(expr) ? if_stmt_on_line (__LINE__) : else_stmt_on_line (__LINE__))\n+\n+void test_memarray_lt (struct MemArrays *p)\n+{\n+  T (strlen (p->ma7->a7) < sizeof p->ma7->a7);\n+  T (strlen (p->ma6->a6) < sizeof p->ma6->a6);\n+  T (strlen (p->ma5->a5) < sizeof p->ma5->a5);\n+  T (strlen (p->ma4->a4) < sizeof p->ma4->a4);\n+  T (strlen (p->ma3->a3) < sizeof p->ma3->a3);\n+  T (strlen (p->ma2->a2) < sizeof p->ma2->a2);\n+  T (strlen (p->ma1->a1) < sizeof p->ma1->a1);\n+\n+  T (strlen (p->ma0->a0) < 1);\n+  T (strlen (p->max->ax) < 1);\n+}\n+\n+void test_memarray_eq (struct MemArrays *p)\n+{\n+  T (strlen (p->ma7->a7) == sizeof p->ma7->a7);\n+  T (strlen (p->ma6->a6) == sizeof p->ma6->a6);\n+  T (strlen (p->ma5->a5) == sizeof p->ma5->a5);\n+  T (strlen (p->ma4->a4) == sizeof p->ma4->a4);\n+  T (strlen (p->ma3->a3) == sizeof p->ma3->a3);\n+  T (strlen (p->ma2->a2) == sizeof p->ma2->a2);\n+  T (strlen (p->ma1->a1) == sizeof p->ma1->a1);\n+\n+  T (strlen (p->ma0->a0) == 1);\n+  T (strlen (p->max->ax) == 1);\n+}\n+\n+void test_memarray_gt (struct MemArrays *p)\n+{\n+  T (strlen (p->ma7->a7) > sizeof p->ma7->a7);\n+  T (strlen (p->ma6->a6) > sizeof p->ma6->a6);\n+  T (strlen (p->ma5->a5) > sizeof p->ma5->a5);\n+  T (strlen (p->ma4->a4) > sizeof p->ma4->a4);\n+  T (strlen (p->ma3->a3) > sizeof p->ma3->a3);\n+  T (strlen (p->ma2->a2) > sizeof p->ma2->a2);\n+  T (strlen (p->ma1->a1) > sizeof p->ma1->a1);\n+\n+  T (strlen (p->ma0->a0) > 1);\n+  T (strlen (p->max->ax) > 1);\n+ }\n+\n+/* Verify that no if or else statements have been eliminated.\n+   { dg-final { scan-tree-dump-times \"if_stmt_on_line\" 27 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"else_stmt_on_line\" 27 \"optimized\" } }  */"}, {"sha": "0386883a74902eedaca6466b9a08113a1179472f", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06199618c1c047366fdafd2b0fafdace1fb44abc/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06199618c1c047366fdafd2b0fafdace1fb44abc/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=06199618c1c047366fdafd2b0fafdace1fb44abc", "patch": "@@ -1152,6 +1152,44 @@ adjust_last_stmt (strinfo *si, gimple *stmt, bool is_strcat)\n   update_stmt (last.stmt);\n }\n \n+/* For an LHS that is an SSA_NAME and for strlen() argument SRC, set\n+   LHS range info to [0, N] if SRC refers to a character array A[N]\n+   with unknown length bounded by N.  */\n+\n+static void\n+maybe_set_strlen_range (tree lhs, tree src)\n+{\n+  if (TREE_CODE (lhs) != SSA_NAME)\n+    return;\n+\n+  if (TREE_CODE (src) == SSA_NAME)\n+    {\n+      gimple *def = SSA_NAME_DEF_STMT (src);\n+      if (is_gimple_assign (def)\n+\t  && gimple_assign_rhs_code (def) == ADDR_EXPR)\n+\tsrc = gimple_assign_rhs1 (def);\n+    }\n+\n+  if (TREE_CODE (src) != ADDR_EXPR)\n+    return;\n+\n+  /* The last array member of a struct can be bigger than its size\n+     suggests if it's treated as a poor-man's flexible array member.  */\n+  src = TREE_OPERAND (src, 0);\n+  if (TREE_CODE (TREE_TYPE (src)) != ARRAY_TYPE\n+      || array_at_struct_end_p (src))\n+    return;\n+\n+  tree type = TREE_TYPE (src);\n+  if (tree dom = TYPE_DOMAIN (type))\n+    if (tree maxval = TYPE_MAX_VALUE (dom))\n+      {\n+\twide_int max = wi::to_wide (maxval);\n+\twide_int min = wi::zero (max.get_precision ());\n+\tset_range_info (lhs, VR_RANGE, min, max);\n+      }\n+}\n+\n /* Handle a strlen call.  If strlen of the argument is known, replace\n    the strlen call with the known value, otherwise remember that strlen\n    of the argument is stored in the lhs SSA_NAME.  */\n@@ -1262,6 +1300,10 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n       set_strinfo (idx, si);\n       find_equal_ptrs (src, idx);\n \n+      /* For SRC that is an array of N elements, set LHS's range\n+\t to [0, N].  */\n+      maybe_set_strlen_range (lhs, src);\n+\n       if (strlen_to_stridx)\n \t{\n \t  location_t loc = gimple_location (stmt);"}]}