{"sha": "a2f9e6e3d98efadc420e0b8327a3f45c3f65689b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJmOWU2ZTNkOThlZmFkYzQyMGUwYjgzMjdhM2Y0NWMzZjY1Njg5Yg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2019-10-31T16:07:09Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-10-31T16:07:09Z"}, "message": "[arm] Avoid using negative offsets for 'immediate' addresses when compiling for Thumb2\n\nThumb2 code now uses the Arm implementation of legitimize_address.\nThat code has a case to handle addresses that are absolute CONST_INT\nvalues, which is a common use case in deeply embedded targets (eg:\nvoid *p = (void*)0x12345678).  Since thumb has very limited negative\noffsets from a constant, we want to avoid forming a CSE base that will\nthen be used with a negative value.\n\nThis was reported upstream originally in\nhttps://gcc.gnu.org/ml/gcc-help/2019-10/msg00122.html\n\nFor example,\n\nvoid test1(void) {\n  volatile uint32_t * const p = (uint32_t *) 0x43fe1800;\n\n  p[3] = 1;\n  p[4] = 2;\n  p[1] = 3;\n  p[7] = 4;\n  p[0] = 6;\n}\n\nWith the new code, instead of \n\n        ldr     r3, .L2\n        subw    r2, r3, #2035\n        movs    r1, #1\n        str     r1, [r2]\n        subw    r2, r3, #2031\n        movs    r1, #2\n        str     r1, [r2]\n        subw    r2, r3, #2043\n        movs    r1, #3\n        str     r1, [r2]\n        subw    r2, r3, #2019\n        movs    r1, #4\n        subw    r3, r3, #2047\n        str     r1, [r2]\n        movs    r2, #6\n        str     r2, [r3]\n        bx      lr\n\n\nWe now get\n\n        ldr     r3, .L2\n        movs    r2, #1\n        str     r2, [r3, #2060]\n        movs    r2, #2\n        str     r2, [r3, #2064]\n        movs    r2, #3\n        str     r2, [r3, #2052]\n        movs    r2, #4\n        str     r2, [r3, #2076]\n        movs    r2, #6\n        str     r2, [r3, #2048]\n        bx      lr\n\n\n\t* config/arm/arm.c (arm_legitimize_address): Don't form negative\n\toffsets from a CONST_INT address when TARGET_THUMB2.\n\nFrom-SVN: r277677", "tree": {"sha": "f67c73040697b238524982807f04a014984b094e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f67c73040697b238524982807f04a014984b094e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2f9e6e3d98efadc420e0b8327a3f45c3f65689b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2f9e6e3d98efadc420e0b8327a3f45c3f65689b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2f9e6e3d98efadc420e0b8327a3f45c3f65689b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2f9e6e3d98efadc420e0b8327a3f45c3f65689b/comments", "author": null, "committer": null, "parents": [{"sha": "d84b9ad53fed75590c3ebc6e38bd49db3b201128", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d84b9ad53fed75590c3ebc6e38bd49db3b201128", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d84b9ad53fed75590c3ebc6e38bd49db3b201128"}], "stats": {"total": 22, "additions": 15, "deletions": 7}, "files": [{"sha": "66b7a1422519afa53eb08da7a84efe5b67ce6d94", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2f9e6e3d98efadc420e0b8327a3f45c3f65689b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2f9e6e3d98efadc420e0b8327a3f45c3f65689b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a2f9e6e3d98efadc420e0b8327a3f45c3f65689b", "patch": "@@ -1,3 +1,8 @@\n+2019-10-31  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/arm.c (arm_legitimize_address): Don't form negative offsets\n+\tfrom a CONST_INT address when TARGET_THUMB2.\n+\n 2019-10-31  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/arm.md (add_not_cin): New insn."}, {"sha": "eddd3ca93ed62915bee3a3f5a396f0be069bd31f", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2f9e6e3d98efadc420e0b8327a3f45c3f65689b/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2f9e6e3d98efadc420e0b8327a3f45c3f65689b/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=a2f9e6e3d98efadc420e0b8327a3f45c3f65689b", "patch": "@@ -9039,17 +9039,20 @@ arm_legitimize_address (rtx x, rtx orig_x, machine_mode mode)\n       HOST_WIDE_INT mask, base, index;\n       rtx base_reg;\n \n-      /* ldr and ldrb can use a 12-bit index, ldrsb and the rest can only\n-         use a 8-bit index. So let's use a 12-bit index for SImode only and\n-         hope that arm_gen_constant will enable ldrb to use more bits. */\n+      /* LDR and LDRB can use a 12-bit index, ldrsb and the rest can\n+\t only use a 8-bit index. So let's use a 12-bit index for\n+\t SImode only and hope that arm_gen_constant will enable LDRB\n+\t to use more bits. */\n       bits = (mode == SImode) ? 12 : 8;\n       mask = (1 << bits) - 1;\n       base = INTVAL (x) & ~mask;\n       index = INTVAL (x) & mask;\n-      if (bit_count (base & 0xffffffff) > (32 - bits)/2)\n-        {\n-\t  /* It'll most probably be more efficient to generate the base\n-\t     with more bits set and use a negative index instead. */\n+      if (TARGET_ARM && bit_count (base & 0xffffffff) > (32 - bits)/2)\n+\t{\n+\t  /* It'll most probably be more efficient to generate the\n+\t     base with more bits set and use a negative index instead.\n+\t     Don't do this for Thumb as negative offsets are much more\n+\t     limited.  */\n \t  base |= mask;\n \t  index -= mask;\n \t}"}]}