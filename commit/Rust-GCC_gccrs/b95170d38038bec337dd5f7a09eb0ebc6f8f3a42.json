{"sha": "b95170d38038bec337dd5f7a09eb0ebc6f8f3a42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk1MTcwZDM4MDM4YmVjMzM3ZGQ1ZjdhMDllYjBlYmM2ZjhmM2E0Mg==", "commit": {"author": {"name": "Ville Voutilainen", "email": "ville.voutilainen@gmail.com", "date": "2015-08-08T22:57:13Z"}, "committer": {"name": "Ville Voutilainen", "email": "ville@gcc.gnu.org", "date": "2015-08-08T22:57:13Z"}, "message": "Implement N4279, Improved insertion interface for unique-key maps.\n\n2015-08-09  Ville Voutilainen  <ville.voutilainen@gmail.com>\n\n\tImplement N4279, Improved insertion interface for unique-key maps.\n\t* include/bits/stl_map.h (try_emplace, insert_or_assign): New.\n\t* include/bits/stl_tree.h (_M_get_insert_unique_pos,\n\t_M_get_insert_equal_pos, _M_get_insert_hint_unique_pos,\n\t_M_get_insert_hint_equal_pos): Make public.\n\t* include/bits/unordered_map.h (try_emplace, insert_or_assign): New.\n\t* testsuite/23_containers/map/modifiers/insert_or_assign/1.cc:\n\tLikewise.\n\t* testsuite/23_containers/map/modifiers/try_emplace/1.cc: Likewise.\n\t* testsuite/23_containers/unordered_map/modifiers/insert_or_assign.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_map/modifiers/try_emplace.cc:\n\tLikewise.\n\nFrom-SVN: r226743", "tree": {"sha": "ae95c860f7ec2ca9538a596d7fdb30ceddcf540e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae95c860f7ec2ca9538a596d7fdb30ceddcf540e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b95170d38038bec337dd5f7a09eb0ebc6f8f3a42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b95170d38038bec337dd5f7a09eb0ebc6f8f3a42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b95170d38038bec337dd5f7a09eb0ebc6f8f3a42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b95170d38038bec337dd5f7a09eb0ebc6f8f3a42/comments", "author": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0920fa2df270f349c27c3b2f9de8f2f5e617f82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0920fa2df270f349c27c3b2f9de8f2f5e617f82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0920fa2df270f349c27c3b2f9de8f2f5e617f82"}], "stats": {"total": 1697, "additions": 1696, "deletions": 1}, "files": [{"sha": "cc875a46ee54e47ead63d3c07d91ee29e27ae3e1", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95170d38038bec337dd5f7a09eb0ebc6f8f3a42/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95170d38038bec337dd5f7a09eb0ebc6f8f3a42/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b95170d38038bec337dd5f7a09eb0ebc6f8f3a42", "patch": "@@ -1,3 +1,19 @@\n+2015-08-09  Ville Voutilainen  <ville.voutilainen@gmail.com>\n+\n+\tImplement N4279, Improved insertion interface for unique-key maps.\n+\t* include/bits/stl_map.h (try_emplace, insert_or_assign): New.\n+\t* include/bits/stl_tree.h (_M_get_insert_unique_pos,\n+\t_M_get_insert_equal_pos, _M_get_insert_hint_unique_pos,\n+\t_M_get_insert_hint_equal_pos): Make public.\n+\t* include/bits/unordered_map.h (try_emplace, insert_or_assign): New.\n+\t* testsuite/23_containers/map/modifiers/insert_or_assign/1.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/map/modifiers/try_emplace/1.cc: Likewise.\n+\t* testsuite/23_containers/unordered_map/modifiers/insert_or_assign.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/unordered_map/modifiers/try_emplace.cc:\n+\tLikewise.\n+\n 2015-08-08  Ville Voutilainen  <ville.voutilainen@gmail.com>\n \n \tImplement N4089 Safe conversions in unique_ptr<T[]> (LWG 2118)"}, {"sha": "68ab6da51f5f60acdc72215be6f2eef05550810f", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95170d38038bec337dd5f7a09eb0ebc6f8f3a42/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95170d38038bec337dd5f7a09eb0ebc6f8f3a42/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=b95170d38038bec337dd5f7a09eb0ebc6f8f3a42", "patch": "@@ -591,7 +591,123 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t\t\t\t\t     std::forward<_Args>(__args)...);\n \t}\n #endif\n+#if __cplusplus > 201402L\n+      /**\n+       *  @brief Attempts to build and insert a std::pair into the %map.\n+       *\n+       *  @param __k    Key to use for finding a possibly existing pair in\n+       *                the map.\n+       *  @param __args  Arguments used to generate the .second for a new pair \n+       *                instance.\n+       *\n+       *  @return  A pair, of which the first element is an iterator that points\n+       *           to the possibly inserted pair, and the second is a bool that\n+       *           is true if the pair was actually inserted.\n+       *\n+       *  This function attempts to build and insert a (key, value) %pair into\n+       *  the %map.\n+       *  A %map relies on unique keys and thus a %pair is only inserted if its\n+       *  first element (the key) is not already present in the %map.\n+       *  If a %pair is not inserted, this function has no effect.\n+       *\n+       *  Insertion requires logarithmic time.\n+       */\n+      template <typename... _Args>\n+        pair<iterator, bool>\n+        try_emplace(const key_type& __k, _Args&&... __args)\n+        {\n+          iterator __i = lower_bound(__k);\n+          if (__i == end() || key_comp()(__k, (*__i).first))\n+            {\n+              __i = emplace_hint(__i, std::piecewise_construct,\n+                                 std::forward_as_tuple(__k),\n+                                 std::forward_as_tuple(\n+                                   std::forward<_Args>(__args)...));\n+              return {__i, true};\n+            }\n+          return {__i, false};\n+        }\n+\n+      // move-capable overload\n+      template <typename... _Args>\n+        pair<iterator, bool>\n+        try_emplace(key_type&& __k, _Args&&... __args)\n+        {\n+          iterator __i = lower_bound(__k);\n+          if (__i == end() || key_comp()(__k, (*__i).first))\n+            {\n+              __i = emplace_hint(__i, std::piecewise_construct,\n+                                 std::forward_as_tuple(std::move(__k)),\n+                                 std::forward_as_tuple(\n+                                   std::forward<_Args>(__args)...));\n+              return {__i, true};\n+            }\n+          return {__i, false};\n+        }\n \n+      /**\n+       *  @brief Attempts to build and insert a std::pair into the %map.\n+       *\n+       *  @param  __hint  An iterator that serves as a hint as to where the\n+       *                  pair should be inserted.\n+       *  @param __k    Key to use for finding a possibly existing pair in\n+       *                the map.\n+       *  @param __args  Arguments used to generate the .second for a new pair \n+       *                instance.\n+       *  @return An iterator that points to the element with key of the\n+       *          std::pair built from @a __args (may or may not be that\n+       *          std::pair).\n+       *\n+       *  This function is not concerned about whether the insertion took place,\n+       *  and thus does not return a boolean like the single-argument \n+       *  try_emplace() does. However, if insertion did not take place,\n+       *  this function has no effect.\n+       *  Note that the first parameter is only a hint and can potentially\n+       *  improve the performance of the insertion process. A bad hint would\n+       *  cause no gains in efficiency.\n+       *\n+       *  See\n+       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints\n+       *  for more on @a hinting.\n+       *\n+       *  Insertion requires logarithmic time (if the hint is not taken).\n+       */\n+      template <typename... _Args>\n+        iterator\n+        try_emplace(const_iterator __hint, const key_type& __k,\n+                    _Args&&... __args)\n+        {\n+          iterator __i;\n+          auto __true_hint = _M_t._M_get_insert_hint_unique_pos(__hint, __k);\n+          if (__true_hint.second)\n+            __i = emplace_hint(iterator(__true_hint.second),\n+                               std::piecewise_construct,\n+                               std::forward_as_tuple(__k),\n+                               std::forward_as_tuple(\n+                                 std::forward<_Args>(__args)...));\n+          else\n+            __i = iterator(__true_hint.first);\n+          return __i;\n+        }\n+\n+      // move-capable overload\n+      template <typename... _Args>\n+        iterator\n+        try_emplace(const_iterator __hint, key_type&& __k, _Args&&... __args)\n+        {\n+          iterator __i;\n+          auto __true_hint = _M_t._M_get_insert_hint_unique_pos(__hint, __k);\n+          if (__true_hint.second)\n+            __i = emplace_hint(iterator(__true_hint.second),\n+                               std::piecewise_construct,\n+                               std::forward_as_tuple(std::move(__k)),\n+                               std::forward_as_tuple(\n+                                 std::forward<_Args>(__args)...));\n+          else\n+            __i = iterator(__true_hint.first);\n+          return __i;\n+        }\n+#endif\n       /**\n        *  @brief Attempts to insert a std::pair into the %map.\n \n@@ -688,6 +804,122 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n         insert(_InputIterator __first, _InputIterator __last)\n         { _M_t._M_insert_unique(__first, __last); }\n \n+#if __cplusplus > 201402L\n+      /**\n+       *  @brief Attempts to insert or assign a std::pair into the %map.\n+       *  @param __k    Key to use for finding a possibly existing pair in\n+       *                the map.\n+       *  @param __obj  Argument used to generate the .second for a pair \n+       *                instance.\n+       *\n+       *  @return  A pair, of which the first element is an iterator that \n+       *           points to the possibly inserted pair, and the second is \n+       *           a bool that is true if the pair was actually inserted.\n+       *\n+       *  This function attempts to insert a (key, value) %pair into the %map.\n+       *  A %map relies on unique keys and thus a %pair is only inserted if its\n+       *  first element (the key) is not already present in the %map.\n+       *  If the %pair was already in the %map, the .second of the %pair\n+       *  is assigned from __obj.\n+       *\n+       *  Insertion requires logarithmic time.\n+       */\n+      template <typename _Obj>\n+        pair<iterator, bool>\n+        insert_or_assign(const key_type& __k, _Obj&& __obj)\n+        {\n+          iterator __i = lower_bound(__k);\n+          if (__i == end() || key_comp()(__k, (*__i).first))\n+            {\n+              __i = emplace_hint(__i, std::piecewise_construct,\n+                                 std::forward_as_tuple(__k),\n+                                 std::forward_as_tuple(\n+                                   std::forward<_Obj>(__obj)));\n+              return {__i, true};\n+            }\n+          (*__i).second = std::forward<_Obj>(__obj);\n+          return {__i, false};\n+        }\n+\n+      // move-capable overload\n+      template <typename _Obj>\n+        pair<iterator, bool>\n+        insert_or_assign(key_type&& __k, _Obj&& __obj)\n+        {\n+          iterator __i = lower_bound(__k);\n+          if (__i == end() || key_comp()(__k, (*__i).first))\n+            {\n+              __i = emplace_hint(__i, std::piecewise_construct,\n+                                 std::forward_as_tuple(std::move(__k)),\n+                                 std::forward_as_tuple(\n+                                   std::forward<_Obj>(__obj)));\n+              return {__i, true};\n+            }\n+          (*__i).second = std::forward<_Obj>(__obj);\n+          return {__i, false};\n+        }\n+\n+      /**\n+       *  @brief Attempts to insert or assign a std::pair into the %map.\n+       *  @param  __hint  An iterator that serves as a hint as to where the\n+       *                  pair should be inserted.\n+       *  @param __k    Key to use for finding a possibly existing pair in\n+       *                the map.\n+       *  @param __obj  Argument used to generate the .second for a pair \n+       *                instance.\n+       *\n+       *  @return An iterator that points to the element with key of\n+       *           @a __x (may or may not be the %pair passed in).\n+       *\n+       *  This function attempts to insert a (key, value) %pair into the %map.\n+       *  A %map relies on unique keys and thus a %pair is only inserted if its\n+       *  first element (the key) is not already present in the %map.\n+       *  If the %pair was already in the %map, the .second of the %pair\n+       *  is assigned from __obj.\n+       *\n+       *  Insertion requires logarithmic time.\n+       */\n+      template <typename _Obj>\n+        iterator\n+        insert_or_assign(const_iterator __hint,\n+                         const key_type& __k, _Obj&& __obj)\n+        {\n+          iterator __i;\n+          auto __true_hint = _M_t._M_get_insert_hint_unique_pos(__hint, __k);\n+          if (__true_hint.second)\n+            {\n+              return emplace_hint(iterator(__true_hint.second),\n+                                  std::piecewise_construct,\n+                                  std::forward_as_tuple(__k),\n+                                  std::forward_as_tuple(\n+                                    std::forward<_Obj>(__obj)));\n+            }\n+          __i = iterator(__true_hint.first);\n+          (*__i).second = std::forward<_Obj>(__obj);\n+          return __i;\n+        }\n+\n+      // move-capable overload\n+      template <typename _Obj>\n+        iterator\n+        insert_or_assign(const_iterator __hint, key_type&& __k, _Obj&& __obj)\n+        {\n+          iterator __i;\n+          auto __true_hint = _M_t._M_get_insert_hint_unique_pos(__hint, __k);\n+          if (__true_hint.second)\n+            {\n+              return emplace_hint(iterator(__true_hint.second),\n+                                  std::piecewise_construct,\n+                                  std::forward_as_tuple(std::move(__k)),\n+                                  std::forward_as_tuple(\n+                                    std::forward<_Obj>(__obj)));\n+            }\n+          __i = iterator(__true_hint.first);\n+          (*__i).second = std::forward<_Obj>(__obj);\n+          return __i;\n+        }\n+#endif\n+\n #if __cplusplus >= 201103L\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 130. Associative erase should return an iterator."}, {"sha": "6132aaf480aca7bddfd6c1f2a165b698542a78dc", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95170d38038bec337dd5f7a09eb0ebc6f8f3a42/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95170d38038bec337dd5f7a09eb0ebc6f8f3a42/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=b95170d38038bec337dd5f7a09eb0ebc6f8f3a42", "patch": "@@ -731,7 +731,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef std::reverse_iterator<iterator>       reverse_iterator;\n       typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n \n-    private:\n       pair<_Base_ptr, _Base_ptr>\n       _M_get_insert_unique_pos(const key_type& __k);\n \n@@ -746,6 +745,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_get_insert_hint_equal_pos(const_iterator __pos,\n \t\t\t\t   const key_type& __k);\n \n+    private:\n #if __cplusplus >= 201103L\n       template<typename _Arg, typename _NodeGen>\n         iterator"}, {"sha": "15d4b8bfeeee7671b1346d277feb70f43324c20d", "filename": "libstdc++-v3/include/bits/unordered_map.h", "status": "modified", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95170d38038bec337dd5f7a09eb0ebc6f8f3a42/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95170d38038bec337dd5f7a09eb0ebc6f8f3a42/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h?ref=b95170d38038bec337dd5f7a09eb0ebc6f8f3a42", "patch": "@@ -410,6 +410,122 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \templace_hint(const_iterator __pos, _Args&&... __args)\n \t{ return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }\n \n+\n+#if __cplusplus > 201402L\n+      /**\n+       *  @brief Attempts to build and insert a std::pair into the\n+       *  %unordered_map.\n+       *\n+       *  @param __k    Key to use for finding a possibly existing pair in\n+       *                the unordered_map.\n+       *  @param __args  Arguments used to generate the .second for a \n+       *                new pair instance.\n+       *\n+       *  @return  A pair, of which the first element is an iterator that points\n+       *           to the possibly inserted pair, and the second is a bool that\n+       *           is true if the pair was actually inserted.\n+       *\n+       *  This function attempts to build and insert a (key, value) %pair into\n+       *  the %unordered_map.\n+       *  An %unordered_map relies on unique keys and thus a %pair is only\n+       *  inserted if its first element (the key) is not already present in the\n+       *  %unordered_map.\n+       *  If a %pair is not inserted, this function has no effect.\n+       *\n+       *  Insertion requires amortized constant time.\n+       */\n+      template <typename... _Args>\n+        pair<iterator, bool>\n+        try_emplace(const key_type& __k, _Args&&... __args)\n+        {\n+          iterator __i = find(__k);\n+          if (__i == end())\n+            {\n+              __i = emplace(std::piecewise_construct,\n+                            std::forward_as_tuple(__k),\n+                            std::forward_as_tuple(\n+                              std::forward<_Args>(__args)...))\n+                .first;\n+              return {__i, true};\n+            }\n+          return {__i, false};\n+        }\n+\n+      // move-capable overload\n+      template <typename... _Args>\n+        pair<iterator, bool>\n+        try_emplace(key_type&& __k, _Args&&... __args)\n+        {\n+          iterator __i = find(__k);\n+          if (__i == end())\n+            {\n+              __i = emplace(std::piecewise_construct,\n+                            std::forward_as_tuple(std::move(__k)),\n+                            std::forward_as_tuple(\n+                              std::forward<_Args>(__args)...))\n+                .first;\n+              return {__i, true};\n+            }\n+          return {__i, false};\n+        }\n+\n+      /**\n+       *  @brief Attempts to build and insert a std::pair into the\n+       *  %unordered_map.\n+       *\n+       *  @param  __hint  An iterator that serves as a hint as to where the pair\n+       *                should be inserted.\n+       *  @param __k    Key to use for finding a possibly existing pair in\n+       *                the unordered_map.\n+       *  @param __args  Arguments used to generate the .second for a \n+       *                new pair instance.\n+       *  @return An iterator that points to the element with key of the\n+       *          std::pair built from @a __args (may or may not be that\n+       *          std::pair).\n+       *\n+       *  This function is not concerned about whether the insertion took place,\n+       *  and thus does not return a boolean like the single-argument emplace()\n+       *  does. However, if insertion did not take place,\n+       *  this function has no effect.\n+       *  Note that the first parameter is only a hint and can potentially\n+       *  improve the performance of the insertion process. A bad hint would\n+       *  cause no gains in efficiency.\n+       *\n+       *  See\n+       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints\n+       *  for more on @a hinting.\n+       *\n+       *  Insertion requires amortized constant time.\n+       */\n+      template <typename... _Args>\n+        iterator\n+        try_emplace(const_iterator __hint, const key_type& __k,\n+                    _Args&&... __args)\n+        {\n+          iterator __i = find(__k);\n+          if (__i == end())\n+            __i = emplace_hint(__hint, std::piecewise_construct,\n+                               std::forward_as_tuple(__k),\n+                               std::forward_as_tuple(\n+                                 std::forward<_Args>(__args)...));\n+          return __i;\n+        }\n+\n+      // move-capable overload\n+      template <typename... _Args>\n+        iterator\n+        try_emplace(const_iterator __hint, key_type&& __k, _Args&&... __args)\n+        {\n+          iterator __i = find(__k);\n+          if (__i == end())\n+            __i = emplace_hint(__hint, std::piecewise_construct,\n+                               std::forward_as_tuple(std::move(__k)),\n+                               std::forward_as_tuple(\n+                                 std::forward<_Args>(__args)...));\n+          return __i;\n+        }\n+#endif\n+\n       //@{\n       /**\n        *  @brief Attempts to insert a std::pair into the %unordered_map.\n@@ -499,6 +615,124 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       insert(initializer_list<value_type> __l)\n       { _M_h.insert(__l); }\n \n+\n+#if __cplusplus > 201402L\n+      /**\n+       *  @brief Attempts to insert a std::pair into the %unordered_map.\n+       *  @param __k    Key to use for finding a possibly existing pair in\n+       *                the map.\n+       *  @param __obj  Argument used to generate the .second for a pair \n+       *                instance.\n+       *\n+       *  @return  A pair, of which the first element is an iterator that \n+       *           points to the possibly inserted pair, and the second is \n+       *           a bool that is true if the pair was actually inserted.\n+       *\n+       *  This function attempts to insert a (key, value) %pair into the\n+       *  %unordered_map. An %unordered_map relies on unique keys and thus a\n+       *  %pair is only inserted if its first element (the key) is not already\n+       *  present in the %unordered_map.\n+       *  If the %pair was already in the %unordered_map, the .second of \n+       *  the %pair is assigned from __obj.\n+       *\n+       *  Insertion requires amortized constant time.\n+       */\n+      template <typename _Obj>\n+        pair<iterator, bool>\n+        insert_or_assign(const key_type& __k, _Obj&& __obj)\n+        {\n+          iterator __i = find(__k);\n+          if (__i == end())\n+            {\n+              __i = emplace(std::piecewise_construct,\n+                            std::forward_as_tuple(__k),\n+                            std::forward_as_tuple(std::forward<_Obj>(__obj)))\n+                .first;\n+              return {__i, true};\n+            }\n+          (*__i).second = std::forward<_Obj>(__obj);\n+          return {__i, false};\n+        }\n+\n+      // move-capable overload\n+      template <typename _Obj>\n+        pair<iterator, bool>\n+        insert_or_assign(key_type&& __k, _Obj&& __obj)\n+        {\n+          iterator __i = find(__k);\n+          if (__i == end())\n+            {\n+              __i = emplace(std::piecewise_construct,\n+                            std::forward_as_tuple(std::move(__k)),\n+                            std::forward_as_tuple(std::forward<_Obj>(__obj)))\n+                .first;\n+              return {__i, true};\n+            }\n+          (*__i).second = std::forward<_Obj>(__obj);\n+          return {__i, false};\n+        }\n+\n+      /**\n+       *  @brief Attempts to insert a std::pair into the %unordered_map.\n+       *  @param  __hint  An iterator that serves as a hint as to where the\n+       *                  pair should be inserted.\n+       *  @param __k    Key to use for finding a possibly existing pair in\n+       *                the unordered_map.\n+       *  @param __obj  Argument used to generate the .second for a pair \n+       *                instance.\n+       *  @return An iterator that points to the element with key of\n+       *           @a __x (may or may not be the %pair passed in).\n+       *\n+       *  This function is not concerned about whether the insertion took place,\n+       *  and thus does not return a boolean like the single-argument insert()\n+       *  does.         \n+       *  If the %pair was already in the %unordered map, the .second of\n+       *  the %pair is assigned from __obj.\n+       *  Note that the first parameter is only a hint and can\n+       *  potentially improve the performance of the insertion process.  A bad\n+       *  hint would cause no gains in efficiency.\n+       *\n+       *  See\n+       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints\n+       *  for more on @a hinting.\n+       *\n+       *  Insertion requires amortized constant time.\n+       */\n+      template <typename _Obj>\n+        iterator\n+        insert_or_assign(const_iterator __hint, const key_type& __k,\n+                         _Obj&& __obj)\n+        {\n+          iterator __i = find(__k);\n+          if (__i == end())\n+            {\n+              return emplace_hint(__hint, std::piecewise_construct,\n+                                  std::forward_as_tuple(__k),\n+                                  std::forward_as_tuple(\n+                                    std::forward<_Obj>(__obj)));\n+            }\n+          (*__i).second = std::forward<_Obj>(__obj);\n+          return __i;\n+        }\n+\n+      // move-capable overload\n+      template <typename _Obj>\n+        iterator\n+        insert_or_assign(const_iterator __hint, key_type&& __k, _Obj&& __obj)\n+        {\n+          iterator __i = find(__k);\n+          if (__i == end())\n+            {\n+              return emplace_hint(__hint, std::piecewise_construct,\n+                                  std::forward_as_tuple(std::move(__k)),\n+                                  std::forward_as_tuple(\n+                                    std::forward<_Obj>(__obj)));\n+            }\n+          (*__i).second = std::forward<_Obj>(__obj);\n+          return __i;\n+        }\n+#endif\n+\n       //@{\n       /**\n        *  @brief Erases an element from an %unordered_map."}, {"sha": "56e4ce081064bf966dee8ac35e644171f12a5cce", "filename": "libstdc++-v3/testsuite/23_containers/map/modifiers/insert_or_assign/1.cc", "status": "added", "additions": 299, "deletions": 0, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95170d38038bec337dd5f7a09eb0ebc6f8f3a42/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Finsert_or_assign%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95170d38038bec337dd5f7a09eb0ebc6f8f3a42/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Finsert_or_assign%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Finsert_or_assign%2F1.cc?ref=b95170d38038bec337dd5f7a09eb0ebc6f8f3a42", "patch": "@@ -0,0 +1,299 @@\n+// { dg-options \"-std=gnu++17\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <utility>\n+#include <map>\n+#include <testsuite_hooks.h>\n+\n+\n+bool test __attribute__((unused)) = true;\n+\n+struct Val\n+{\n+  bool moved_from_ctor = false;\n+  bool moved_from_assign = false;\n+  int val;\n+  Val(int val = 0) : val(val) {}\n+  Val(const Val& other) : val(other.val)\n+  {\n+  }\n+  Val(Val&& other) : val(other.val)\n+  {\n+    other.moved_from_ctor = true;\n+  }\n+  Val& operator=(Val&& other)\n+  {\n+    val = other.val;\n+    other.moved_from_assign = true;\n+  }\n+  Val& operator=(const Val& other)\n+  {\n+    val = other.val;\n+  }\n+};\n+\n+bool operator<(const Val& a, const Val& b)\n+{\n+  return a.val < b.val;\n+}\n+\n+void test01()\n+{\n+  typedef std::map<int, Val> Map;\n+  Map m;\n+  auto res1 = m.insert_or_assign(0, Val(5));\n+  VERIFY(res1.second);\n+  VERIFY(res1.first != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.insert_or_assign(0, std::move(v1));\n+  VERIFY(!res2.second);\n+  VERIFY(res2.first == res1.first);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  v1.moved_from_assign = false;\n+  auto res3 = m.insert_or_assign(1, std::move(v1));\n+  VERIFY(res3.first != res1.first && res3.first != m.end());\n+  VERIFY(res3.second);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test02()\n+{\n+  typedef std::map<int, Val> Map;\n+  Map m;\n+  auto res1 = m.insert_or_assign(m.begin(), 0, Val(5));\n+  VERIFY(res1 != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.insert_or_assign(m.begin(), 0, std::move(v1));\n+  VERIFY(res2 == res1);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  v1.moved_from_assign = false;\n+  auto res3 = m.insert_or_assign(m.begin(), 1, std::move(v1));\n+  VERIFY(res3 != res1 && res3 != m.end());\n+  VERIFY(m[0].val == 6);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test03()\n+{\n+  typedef std::map<Val, Val> Map;\n+  Map m;\n+  auto res1 = m.insert_or_assign(0, Val(5));\n+  VERIFY(res1.second);\n+  VERIFY(res1.first != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val k1{0};\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.insert_or_assign(std::move(k1), std::move(v1));\n+  VERIFY(!res2.second);\n+  VERIFY(res2.first == res1.first);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(!k1.moved_from_ctor);\n+  VERIFY(!k1.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  Val k2{1};\n+  v1.moved_from_assign = false;\n+  auto res3 = m.insert_or_assign(std::move(k2), std::move(v1));\n+  VERIFY(res3.first != res1.first && res3.first != m.end());\n+  VERIFY(res3.second);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(k2.moved_from_ctor);\n+  VERIFY(!k2.moved_from_assign);\n+  VERIFY(v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test04()\n+{\n+  typedef std::map<Val, Val> Map;\n+  Map m;\n+  auto res1 = m.insert_or_assign(m.begin(), 0, Val(5));\n+  VERIFY(res1 != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val k1{0};\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.insert_or_assign(m.begin(), std::move(k1), std::move(v1));\n+  VERIFY(res2 == res1);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(!k1.moved_from_ctor);\n+  VERIFY(!k1.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  Val k2{1};\n+  v1.moved_from_assign = false;\n+  auto res3 = m.insert_or_assign(m.begin(), std::move(k2), std::move(v1));\n+  VERIFY(res3 != res1 && res3 != m.end());\n+  VERIFY(m[0].val == 6);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(k2.moved_from_ctor);\n+  VERIFY(!k2.moved_from_assign);\n+  VERIFY(v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test05()\n+{\n+  typedef std::map<int, Val> Map;\n+  Map m;\n+  auto res1 = m.insert_or_assign(0, Val(5));\n+  VERIFY(res1.second);\n+  VERIFY(res1.first != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.insert_or_assign(0, v1);\n+  VERIFY(!res2.second);\n+  VERIFY(res2.first == res1.first);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  auto res3 = m.insert_or_assign(1, v1);\n+  VERIFY(res3.first != res1.first && res3.first != m.end());\n+  VERIFY(res3.second);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test06()\n+{\n+  typedef std::map<int, Val> Map;\n+  Map m;\n+  auto res1 = m.insert_or_assign(m.begin(), 0, Val(5));\n+  VERIFY(res1 != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.insert_or_assign(m.begin(), 0, v1);\n+  VERIFY(res2 == res1);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  auto res3 = m.insert_or_assign(m.begin(), 1, v1);\n+  VERIFY(res3 != res1 && res3 != m.end());\n+  VERIFY(m[0].val == 6);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test07()\n+{\n+  typedef std::map<Val, Val> Map;\n+  Map m;\n+  auto res1 = m.insert_or_assign(0, Val(5));\n+  VERIFY(res1.second);\n+  VERIFY(res1.first != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val k1{0};\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.insert_or_assign(k1, v1);\n+  VERIFY(!res2.second);\n+  VERIFY(res2.first == res1.first);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(!k1.moved_from_ctor);\n+  VERIFY(!k1.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  Val k2{1};\n+  auto res3 = m.insert_or_assign(k2, v1);\n+  VERIFY(res3.first != res1.first && res3.first != m.end());\n+  VERIFY(res3.second);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(!k2.moved_from_ctor);\n+  VERIFY(!k2.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test08()\n+{\n+  typedef std::map<Val, Val> Map;\n+  Map m;\n+  auto res1 = m.insert_or_assign(m.begin(), 0, Val(5));\n+  VERIFY(res1 != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val k1{0};\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.insert_or_assign(m.begin(), k1, v1);\n+  VERIFY(res2 == res1);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(!k1.moved_from_ctor);\n+  VERIFY(!k1.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  Val k2{1};\n+  auto res3 = m.insert_or_assign(m.begin(), k2, v1);\n+  VERIFY(res3 != res1 && res3 != m.end());\n+  VERIFY(m[0].val == 6);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(!k2.moved_from_ctor);\n+  VERIFY(!k2.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  test06();\n+  test07();\n+  test08();\n+  return 0;\n+}"}, {"sha": "c8c777bb85f0b5ab9989d6039a4d2e4c388b2205", "filename": "libstdc++-v3/testsuite/23_containers/map/modifiers/try_emplace/1.cc", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95170d38038bec337dd5f7a09eb0ebc6f8f3a42/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Ftry_emplace%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95170d38038bec337dd5f7a09eb0ebc6f8f3a42/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Ftry_emplace%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Ftry_emplace%2F1.cc?ref=b95170d38038bec337dd5f7a09eb0ebc6f8f3a42", "patch": "@@ -0,0 +1,291 @@\n+// { dg-options \"-std=gnu++17\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <utility>\n+#include <map>\n+#include <testsuite_hooks.h>\n+\n+\n+bool test __attribute__((unused)) = true;\n+\n+struct Val\n+{\n+  bool moved_from_ctor = false;\n+  bool moved_from_assign = false;\n+  int val;\n+  Val(int val = 0) : val(val) {}\n+  Val(const Val& other) : val(other.val)\n+  {\n+  }\n+  Val(Val&& other) : val(other.val)\n+  {\n+    other.moved_from_ctor = true;\n+  }\n+  Val& operator=(Val&& other)\n+  {\n+    val = other.val;\n+    other.moved_from_assign = true;\n+  }\n+};\n+\n+bool operator<(const Val& a, const Val& b)\n+{\n+  return a.val < b.val;\n+}\n+\n+void test01()\n+{\n+  typedef std::map<int, Val> Map;\n+  Map m;\n+  auto res1 = m.try_emplace(0, Val(5));\n+  VERIFY(res1.second);\n+  VERIFY(res1.first != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.try_emplace(0, std::move(v1));\n+  VERIFY(!res2.second);\n+  VERIFY(res2.first == res1.first);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  auto res3 = m.try_emplace(1, std::move(v1));\n+  VERIFY(res3.first != res1.first && res3.first != m.end());\n+  VERIFY(res3.second);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test02()\n+{\n+  typedef std::map<int, Val> Map;\n+  Map m;\n+  auto res1 = m.try_emplace(m.begin(), 0, Val(5));\n+  VERIFY(res1 != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.try_emplace(m.begin(), 0, std::move(v1));\n+  VERIFY(res2 == res1);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  auto res3 = m.try_emplace(m.begin(), 1, std::move(v1));\n+  VERIFY(res3 != res1 && res3 != m.end());\n+  VERIFY(m[0].val == 5);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test03()\n+{\n+  typedef std::map<Val, Val> Map;\n+  Map m;\n+  auto res1 = m.try_emplace(0, Val(5));\n+  VERIFY(res1.second);\n+  VERIFY(res1.first != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val k1{0};\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.try_emplace(std::move(k1), std::move(v1));\n+  VERIFY(!res2.second);\n+  VERIFY(res2.first == res1.first);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(!k1.moved_from_ctor);\n+  VERIFY(!k1.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  Val k2{1};\n+  auto res3 = m.try_emplace(std::move(k2), std::move(v1));\n+  VERIFY(res3.first != res1.first && res3.first != m.end());\n+  VERIFY(res3.second);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(k2.moved_from_ctor);\n+  VERIFY(!k2.moved_from_assign);\n+  VERIFY(v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test04()\n+{\n+  typedef std::map<Val, Val> Map;\n+  Map m;\n+  auto res1 = m.try_emplace(m.begin(), 0, Val(5));\n+  VERIFY(res1 != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val k1{0};\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.try_emplace(m.begin(), std::move(k1), std::move(v1));\n+  VERIFY(res2 == res1);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(!k1.moved_from_ctor);\n+  VERIFY(!k1.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  Val k2{1};\n+  auto res3 = m.try_emplace(m.begin(), std::move(k2), std::move(v1));\n+  VERIFY(res3 != res1 && res3 != m.end());\n+  VERIFY(m[0].val == 5);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(k2.moved_from_ctor);\n+  VERIFY(!k2.moved_from_assign);\n+  VERIFY(v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test05()\n+{\n+  typedef std::map<int, Val> Map;\n+  Map m;\n+  auto res1 = m.try_emplace(0, Val(5));\n+  VERIFY(res1.second);\n+  VERIFY(res1.first != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.try_emplace(0, v1);\n+  VERIFY(!res2.second);\n+  VERIFY(res2.first == res1.first);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  auto res3 = m.try_emplace(1, v1);\n+  VERIFY(res3.first != res1.first && res3.first != m.end());\n+  VERIFY(res3.second);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test06()\n+{\n+  typedef std::map<int, Val> Map;\n+  Map m;\n+  auto res1 = m.try_emplace(m.begin(), 0, Val(5));\n+  VERIFY(res1 != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.try_emplace(m.begin(), 0, v1);\n+  VERIFY(res2 == res1);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  auto res3 = m.try_emplace(m.begin(), 1, v1);\n+  VERIFY(res3 != res1 && res3 != m.end());\n+  VERIFY(m[0].val == 5);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test07()\n+{\n+  typedef std::map<Val, Val> Map;\n+  Map m;\n+  auto res1 = m.try_emplace(0, Val(5));\n+  VERIFY(res1.second);\n+  VERIFY(res1.first != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val k1{0};\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.try_emplace(k1, v1);\n+  VERIFY(!res2.second);\n+  VERIFY(res2.first == res1.first);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(!k1.moved_from_ctor);\n+  VERIFY(!k1.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  Val k2{1};\n+  auto res3 = m.try_emplace(k2, v1);\n+  VERIFY(res3.first != res1.first && res3.first != m.end());\n+  VERIFY(res3.second);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(!k2.moved_from_ctor);\n+  VERIFY(!k2.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test08()\n+{\n+  typedef std::map<Val, Val> Map;\n+  Map m;\n+  auto res1 = m.try_emplace(m.begin(), 0, Val(5));\n+  VERIFY(res1 != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val k1{0};\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.try_emplace(m.begin(), k1, v1);\n+  VERIFY(res2 == res1);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(!k1.moved_from_ctor);\n+  VERIFY(!k1.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  Val k2{1};\n+  auto res3 = m.try_emplace(m.begin(), k2, v1);\n+  VERIFY(res3 != res1 && res3 != m.end());\n+  VERIFY(m[0].val == 5);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(!k2.moved_from_ctor);\n+  VERIFY(!k2.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  test06();\n+  test07();\n+  test08();\n+  return 0;\n+}"}, {"sha": "efb9fba52e27d84d244563495b8726c7df98694a", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/insert_or_assign.cc", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95170d38038bec337dd5f7a09eb0ebc6f8f3a42/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2Finsert_or_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95170d38038bec337dd5f7a09eb0ebc6f8f3a42/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2Finsert_or_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2Finsert_or_assign.cc?ref=b95170d38038bec337dd5f7a09eb0ebc6f8f3a42", "patch": "@@ -0,0 +1,315 @@\n+// { dg-options \"-std=gnu++17\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <utility>\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+\n+\n+bool test __attribute__((unused)) = true;\n+\n+struct Val\n+{\n+  bool moved_from_ctor = false;\n+  bool moved_from_assign = false;\n+  int val;\n+  Val(int val = 0) : val(val) {}\n+  Val(const Val& other) : val(other.val)\n+  {\n+  }\n+  Val(Val&& other) : val(other.val)\n+  {\n+    other.moved_from_ctor = true;\n+  }\n+  Val& operator=(Val&& other)\n+  {\n+    val = other.val;\n+    other.moved_from_assign = true;\n+  }\n+  Val& operator=(const Val& other)\n+  {\n+    val = other.val;\n+  }\n+};\n+\n+bool operator==(const Val& a, const Val& b)\n+{\n+  return a.val == b.val;\n+}\n+\n+namespace std\n+{\n+  template <> struct hash<Val>\n+   {\n+     using result_type = size_t;\n+     using argument_type = Val;\n+\n+     size_t\n+     operator()(const Val& t) const\n+       noexcept\n+     {\n+       return hash<int>{}(t.val);\n+     }\n+   };\n+}\n+\n+void test01()\n+{\n+  typedef std::unordered_map<int, Val> Map;\n+  Map m;\n+  auto res1 = m.insert_or_assign(0, Val(5));\n+  VERIFY(res1.second);\n+  VERIFY(res1.first != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.insert_or_assign(0, std::move(v1));\n+  VERIFY(!res2.second);\n+  VERIFY(res2.first == res1.first);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  v1.moved_from_assign = false;\n+  auto res3 = m.insert_or_assign(1, std::move(v1));\n+  VERIFY(res3.first != res1.first && res3.first != m.end());\n+  VERIFY(res3.second);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test02()\n+{\n+  typedef std::unordered_map<int, Val> Map;\n+  Map m;\n+  auto res1 = m.insert_or_assign(m.begin(), 0, Val(5));\n+  VERIFY(res1 != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.insert_or_assign(m.begin(), 0, std::move(v1));\n+  VERIFY(res2 == res1);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  v1.moved_from_assign = false;\n+  auto res3 = m.insert_or_assign(m.begin(), 1, std::move(v1));\n+  VERIFY(res3 != res1 && res3 != m.end());\n+  VERIFY(m[0].val == 6);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test03()\n+{\n+  typedef std::unordered_map<Val, Val> Map;\n+  Map m;\n+  auto res1 = m.insert_or_assign(0, Val(5));\n+  VERIFY(res1.second);\n+  VERIFY(res1.first != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val k1{0};\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.insert_or_assign(std::move(k1), std::move(v1));\n+  VERIFY(!res2.second);\n+  VERIFY(res2.first == res1.first);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(!k1.moved_from_ctor);\n+  VERIFY(!k1.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  Val k2{1};\n+  v1.moved_from_assign = false;\n+  auto res3 = m.insert_or_assign(std::move(k2), std::move(v1));\n+  VERIFY(res3.first != res1.first && res3.first != m.end());\n+  VERIFY(res3.second);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(k2.moved_from_ctor);\n+  VERIFY(!k2.moved_from_assign);\n+  VERIFY(v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test04()\n+{\n+  typedef std::unordered_map<Val, Val> Map;\n+  Map m;\n+  auto res1 = m.insert_or_assign(m.begin(), 0, Val(5));\n+  VERIFY(res1 != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val k1{0};\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.insert_or_assign(m.begin(), std::move(k1), std::move(v1));\n+  VERIFY(res2 == res1);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(!k1.moved_from_ctor);\n+  VERIFY(!k1.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  Val k2{1};\n+  v1.moved_from_assign = false;\n+  auto res3 = m.insert_or_assign(m.begin(), std::move(k2), std::move(v1));\n+  VERIFY(res3 != res1 && res3 != m.end());\n+  VERIFY(m[0].val == 6);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(k2.moved_from_ctor);\n+  VERIFY(!k2.moved_from_assign);\n+  VERIFY(v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test05()\n+{\n+  typedef std::unordered_map<int, Val> Map;\n+  Map m;\n+  auto res1 = m.insert_or_assign(0, Val(5));\n+  VERIFY(res1.second);\n+  VERIFY(res1.first != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.insert_or_assign(0, v1);\n+  VERIFY(!res2.second);\n+  VERIFY(res2.first == res1.first);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  auto res3 = m.insert_or_assign(1, v1);\n+  VERIFY(res3.first != res1.first && res3.first != m.end());\n+  VERIFY(res3.second);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test06()\n+{\n+  typedef std::unordered_map<int, Val> Map;\n+  Map m;\n+  auto res1 = m.insert_or_assign(m.begin(), 0, Val(5));\n+  VERIFY(res1 != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.insert_or_assign(m.begin(), 0, v1);\n+  VERIFY(res2 == res1);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  auto res3 = m.insert_or_assign(m.begin(), 1, v1);\n+  VERIFY(res3 != res1 && res3 != m.end());\n+  VERIFY(m[0].val == 6);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test07()\n+{\n+  typedef std::unordered_map<Val, Val> Map;\n+  Map m;\n+  auto res1 = m.insert_or_assign(0, Val(5));\n+  VERIFY(res1.second);\n+  VERIFY(res1.first != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val k1{0};\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.insert_or_assign(k1, v1);\n+  VERIFY(!res2.second);\n+  VERIFY(res2.first == res1.first);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(!k1.moved_from_ctor);\n+  VERIFY(!k1.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  Val k2{1};\n+  auto res3 = m.insert_or_assign(k2, v1);\n+  VERIFY(res3.first != res1.first && res3.first != m.end());\n+  VERIFY(res3.second);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(!k2.moved_from_ctor);\n+  VERIFY(!k2.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test08()\n+{\n+  typedef std::unordered_map<Val, Val> Map;\n+  Map m;\n+  auto res1 = m.insert_or_assign(m.begin(), 0, Val(5));\n+  VERIFY(res1 != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val k1{0};\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.insert_or_assign(m.begin(), k1, v1);\n+  VERIFY(res2 == res1);\n+  VERIFY(m[0].val == 6);\n+  VERIFY(!k1.moved_from_ctor);\n+  VERIFY(!k1.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  Val k2{1};\n+  auto res3 = m.insert_or_assign(m.begin(), k2, v1);\n+  VERIFY(res3 != res1 && res3 != m.end());\n+  VERIFY(m[0].val == 6);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(!k2.moved_from_ctor);\n+  VERIFY(!k2.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  test06();\n+  test07();\n+  test08();\n+  return 0;\n+}"}, {"sha": "82b01059a668ef9c21751da3117d33bf99b677ac", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/try_emplace.cc", "status": "added", "additions": 308, "deletions": 0, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b95170d38038bec337dd5f7a09eb0ebc6f8f3a42/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2Ftry_emplace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b95170d38038bec337dd5f7a09eb0ebc6f8f3a42/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2Ftry_emplace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2Ftry_emplace.cc?ref=b95170d38038bec337dd5f7a09eb0ebc6f8f3a42", "patch": "@@ -0,0 +1,308 @@\n+// { dg-options \"-std=gnu++17\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <utility>\n+#include <unordered_map>\n+#include <functional>\n+#include <testsuite_hooks.h>\n+\n+\n+bool test __attribute__((unused)) = true;\n+\n+struct Val\n+{\n+  bool moved_from_ctor = false;\n+  bool moved_from_assign = false;\n+  int val;\n+  Val(int val = 0) : val(val) {}\n+  Val(const Val& other) : val(other.val)\n+  {\n+  }\n+  Val(Val&& other) : val(other.val)\n+  {\n+    other.moved_from_ctor = true;\n+  }\n+  Val& operator=(Val&& other)\n+  {\n+    val = other.val;\n+    other.moved_from_assign = true;\n+  }\n+};\n+\n+bool operator==(const Val& a, const Val& b)\n+{\n+  return a.val == b.val;\n+}\n+\n+namespace std\n+{\n+  template <> struct hash<Val>\n+   {\n+     using result_type = size_t;\n+     using argument_type = Val;\n+\n+     size_t\n+     operator()(const Val& t) const\n+       noexcept\n+     {\n+       return hash<int>{}(t.val);\n+     }\n+   };\n+}\n+\n+void test01()\n+{\n+  typedef std::unordered_map<int, Val> Map;\n+  Map m;\n+  auto res1 = m.try_emplace(0, Val(5));\n+  VERIFY(res1.second);\n+  VERIFY(res1.first != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.try_emplace(0, std::move(v1));\n+  VERIFY(!res2.second);\n+  VERIFY(res2.first == res1.first);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  auto res3 = m.try_emplace(1, std::move(v1));\n+  VERIFY(res3.first != res1.first && res3.first != m.end());\n+  VERIFY(res3.second);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test02()\n+{\n+  typedef std::unordered_map<int, Val> Map;\n+  Map m;\n+  auto res1 = m.try_emplace(m.begin(), 0, Val(5));\n+  VERIFY(res1 != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.try_emplace(m.begin(), 0, std::move(v1));\n+  VERIFY(res2 == res1);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  auto res3 = m.try_emplace(m.begin(), 1, std::move(v1));\n+  VERIFY(res3 != res1 && res3 != m.end());\n+  VERIFY(m[0].val == 5);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test03()\n+{\n+  typedef std::unordered_map<Val, Val> Map;\n+  Map m;\n+  auto res1 = m.try_emplace(0, Val(5));\n+  VERIFY(res1.second);\n+  VERIFY(res1.first != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val k1{0};\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.try_emplace(std::move(k1), std::move(v1));\n+  VERIFY(!res2.second);\n+  VERIFY(res2.first == res1.first);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(!k1.moved_from_ctor);\n+  VERIFY(!k1.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  Val k2{1};\n+  auto res3 = m.try_emplace(std::move(k2), std::move(v1));\n+  VERIFY(res3.first != res1.first && res3.first != m.end());\n+  VERIFY(res3.second);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(k2.moved_from_ctor);\n+  VERIFY(!k2.moved_from_assign);\n+  VERIFY(v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test04()\n+{\n+  typedef std::unordered_map<Val, Val> Map;\n+  Map m;\n+  auto res1 = m.try_emplace(m.begin(), 0, Val(5));\n+  VERIFY(res1 != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val k1{0};\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.try_emplace(m.begin(), std::move(k1), std::move(v1));\n+  VERIFY(res2 == res1);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(!k1.moved_from_ctor);\n+  VERIFY(!k1.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  Val k2{1};\n+  auto res3 = m.try_emplace(m.begin(), std::move(k2), std::move(v1));\n+  VERIFY(res3 != res1 && res3 != m.end());\n+  VERIFY(m[0].val == 5);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(k2.moved_from_ctor);\n+  VERIFY(!k2.moved_from_assign);\n+  VERIFY(v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test05()\n+{\n+  typedef std::unordered_map<int, Val> Map;\n+  Map m;\n+  auto res1 = m.try_emplace(0, Val(5));\n+  VERIFY(res1.second);\n+  VERIFY(res1.first != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.try_emplace(0, std::move(v1));\n+  VERIFY(!res2.second);\n+  VERIFY(res2.first == res1.first);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  auto res3 = m.try_emplace(1, std::move(v1));\n+  VERIFY(res3.first != res1.first && res3.first != m.end());\n+  VERIFY(res3.second);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test06()\n+{\n+  typedef std::unordered_map<int, Val> Map;\n+  Map m;\n+  auto res1 = m.try_emplace(m.begin(), 0, Val(5));\n+  VERIFY(res1 != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.try_emplace(m.begin(), 0, std::move(v1));\n+  VERIFY(res2 == res1);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  auto res3 = m.try_emplace(m.begin(), 1, std::move(v1));\n+  VERIFY(res3 != res1 && res3 != m.end());\n+  VERIFY(m[0].val == 5);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test07()\n+{\n+  typedef std::unordered_map<Val, Val> Map;\n+  Map m;\n+  auto res1 = m.try_emplace(0, Val(5));\n+  VERIFY(res1.second);\n+  VERIFY(res1.first != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val k1{0};\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.try_emplace(k1, v1);\n+  VERIFY(!res2.second);\n+  VERIFY(res2.first == res1.first);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(!k1.moved_from_ctor);\n+  VERIFY(!k1.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  Val k2{1};\n+  auto res3 = m.try_emplace(k2, v1);\n+  VERIFY(res3.first != res1.first && res3.first != m.end());\n+  VERIFY(res3.second);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(!k2.moved_from_ctor);\n+  VERIFY(!k2.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+void test08()\n+{\n+  typedef std::unordered_map<Val, Val> Map;\n+  Map m;\n+  auto res1 = m.try_emplace(m.begin(), 0, Val(5));\n+  VERIFY(res1 != m.end());\n+  VERIFY(m[0].val == 5);\n+  Val k1{0};\n+  Val v1{6};\n+  VERIFY(m.size() == 1);\n+  auto res2 = m.try_emplace(m.begin(), k1, v1);\n+  VERIFY(res2 == res1);\n+  VERIFY(m[0].val == 5);\n+  VERIFY(!k1.moved_from_ctor);\n+  VERIFY(!k1.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 1);\n+  Val k2{1};\n+  auto res3 = m.try_emplace(m.begin(), k2, v1);\n+  VERIFY(res3 != res1 && res3 != m.end());\n+  VERIFY(m[0].val == 5);\n+  VERIFY(m[1].val == 6);\n+  VERIFY(!k2.moved_from_ctor);\n+  VERIFY(!k2.moved_from_assign);\n+  VERIFY(!v1.moved_from_ctor);\n+  VERIFY(!v1.moved_from_assign);\n+  VERIFY(m.size() == 2);\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  test06();\n+  test07();\n+  test08();\n+  return 0;\n+}"}]}