{"sha": "c22940cd7cb1bb5d23e496acc843a74d44ee050a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzIyOTQwY2Q3Y2IxYmI1ZDIzZTQ5NmFjYzg0M2E3NGQ0NGVlMDUwYQ==", "commit": {"author": {"name": "Thomas Neumann", "email": "tneumann@users.sourceforge.net", "date": "2007-06-06T20:18:47Z"}, "committer": {"name": "Thomas Neumann", "email": "tneumann@gcc.gnu.org", "date": "2007-06-06T20:18:47Z"}, "message": "tree-ssa-alias-warnings.c (maybe_add_match): Cast according to the coding conventions.\n\n\t* tree-ssa-alias-warnings.c (maybe_add_match): Cast according to the\n\tcoding conventions.\n\t(add_key): Likewise.\n\t* tree-ssa.c (init_tree_ssa): Use type safe memory macros.\n\t* tree-ssa-ccp.c (ccp_fold_builtin): Avoid using C++ keywords as\n\tvariable names.\n\t* tree-ssa-coalesce.c (find_coalesce_pair): Use type safe memory macros.\n\t(add_cost_one_coalesce): Likewise.\n\t* tree-ssa-copy.c (merge_alias_info): Avoid using C++ keywords as\n\tvariable names. Rename orig to orig_name for consistency.\n\t* tree-ssa-dom.c (dom_thread_across_edge): Cast according to the coding\n\tconventions.\n\t(cprop_into_successor_phis): Avoid using C++ keywords as variable names.\n\t(record_equivalences_from_stmt): Likewise.\n\t* tree-ssa-dse.c (dse_initialize_block_local_data): Cast according to\n\tthe coding conventions.\n\t(memory_ssa_name_same): Likewise.\n\t(dse_optimize_stmt): Likewise.\n\t(dse_record_phis): Likewise.\n\t(dse_finalize_block): Likewise.\n\t* tree-ssa-loop-im.c (outermost_invariant_loop_expr): Avoid using C++\n\tkeywords as variable names.\n\t(may_move_till): Cast according to the coding conventions.\n\t(force_move_till_expr): Avoid using C++ keywords as variable names.\n\t(force_move_till): Cast according to the coding conventions.\n\t(memref_hash): Likewise.\n\t(memref_eq): Likewise.\n\t(gather_mem_refs_stmt): Likewise.\n\t* tree-ssa-loop-ivopts.c (contains_abnormal_ssa_name_p): Avoid using C++\n\tkeywords as variable names.\n\t(idx_find_step): Cast according to the coding conventions.\n\t(idx_record_use): Likewise.\n\t(find_depends): Likewise.\n\t(prepare_decl_rtl): Likewise.\n\t(mbc_entry_hash): Likewise.\n\t(mbc_entry_eq): Likewise.\n\t* tree-ssa-loop-niter.c (SWAP): Use the correct the type for tmp.\n\t(simplify_replace_tree): Avoid using C++ keywords as variable names.\n\t(idx_infer_loop_bounds): Cast according to the coding conventions.\n\t* tree-ssa-loop-prefetch.c (idx_analyze_ref): Likewise.\n\t* tree-ssa-math-opts.c (occ_new ): Likwise.\n\t* tree-ssanames.c (duplicate_ssa_name_ptr_info): Use type safe memory\n\tmacros.\n\t* tree-ssa-operands.c (add_def_op): Avoid using C++ keywords as variable\n\tnames.\n\t(add_use_op): Likewise.\n\t(add_vop): Likewise.\n\t(add_vuse_op): Likewise.\n\t(add_vdef_op): Likewise.\n\t(get_expr_operands): Likewise.\n\t(push_stmt_changes): Use type safe memory macros.\n\t* tree-ssa-phiopt.c (replace_phi_edge_with_variable): Avoid using C++\n\tkeywords as variable names.\n\t(conditional_replacement): Likewise.\n\t(minmax_replacement): Likewise.\n\t(abs_replacement): Likewise.\n\t* tree-ssa-pre.c (create_expression_by_pieces): Cast according to the\n\tcoding conventions.\n\t(insert_fake_stores): Avoid using C++ keywords as variable names.\n\t* tree-ssa-reassoc.c (add_to_ops_vec): Cast according to the coding\n\tconventions.\n\t* tree-ssa-structalias.c (heapvar_lookup): Likewise.\n\t(heapvar_insert): Use type safe memory macros.\n\t(new_var_info): Cast according to the coding conventions.\n\t(new_constraint): Likewise.\n\t(remove_preds_and_fake_succs): Use type safe memory macros.\n\t* tree-ssa-threadupdate.c (thread_block): Cast according to the coding\n\tconventions.\n\t(thread_single_edge): Likewise.\n\nFrom-SVN: r125504", "tree": {"sha": "dbd2a770edf06b4cba42ed3ad603008a8875ec43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbd2a770edf06b4cba42ed3ad603008a8875ec43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c22940cd7cb1bb5d23e496acc843a74d44ee050a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c22940cd7cb1bb5d23e496acc843a74d44ee050a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c22940cd7cb1bb5d23e496acc843a74d44ee050a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c22940cd7cb1bb5d23e496acc843a74d44ee050a/comments", "author": {"login": "neumannt", "id": 25097991, "node_id": "MDQ6VXNlcjI1MDk3OTkx", "avatar_url": "https://avatars.githubusercontent.com/u/25097991?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neumannt", "html_url": "https://github.com/neumannt", "followers_url": "https://api.github.com/users/neumannt/followers", "following_url": "https://api.github.com/users/neumannt/following{/other_user}", "gists_url": "https://api.github.com/users/neumannt/gists{/gist_id}", "starred_url": "https://api.github.com/users/neumannt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neumannt/subscriptions", "organizations_url": "https://api.github.com/users/neumannt/orgs", "repos_url": "https://api.github.com/users/neumannt/repos", "events_url": "https://api.github.com/users/neumannt/events{/privacy}", "received_events_url": "https://api.github.com/users/neumannt/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "266a2cbaecc5fd00fb6002da6dd19352f3b99292", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/266a2cbaecc5fd00fb6002da6dd19352f3b99292", "html_url": "https://github.com/Rust-GCC/gccrs/commit/266a2cbaecc5fd00fb6002da6dd19352f3b99292"}], "stats": {"total": 411, "additions": 246, "deletions": 165}, "files": [{"sha": "c4a7680557af4d4ec02697b99177940b81d3e138", "filename": "gcc/ChangeLog", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c22940cd7cb1bb5d23e496acc843a74d44ee050a", "patch": "@@ -1,3 +1,76 @@\n+2007-06-06  Thomas Neumann  <tneumann@users.sourceforge.net>\n+\n+\t* tree-ssa-alias-warnings.c (maybe_add_match): Cast according to the\n+\tcoding conventions.\n+\t(add_key): Likewise.\n+\t* tree-ssa.c (init_tree_ssa): Use type safe memory macros.\n+\t* tree-ssa-ccp.c (ccp_fold_builtin): Avoid using C++ keywords as\n+\tvariable names.\n+\t* tree-ssa-coalesce.c (find_coalesce_pair): Use type safe memory macros.\n+\t(add_cost_one_coalesce): Likewise.\n+\t* tree-ssa-copy.c (merge_alias_info): Avoid using C++ keywords as\n+\tvariable names. Rename orig to orig_name for consistency.\n+\t* tree-ssa-dom.c (dom_thread_across_edge): Cast according to the coding\n+\tconventions.\n+\t(cprop_into_successor_phis): Avoid using C++ keywords as variable names.\n+\t(record_equivalences_from_stmt): Likewise.\n+\t* tree-ssa-dse.c (dse_initialize_block_local_data): Cast according to\n+\tthe coding conventions.\n+\t(memory_ssa_name_same): Likewise.\n+\t(dse_optimize_stmt): Likewise.\n+\t(dse_record_phis): Likewise.\n+\t(dse_finalize_block): Likewise.\n+\t* tree-ssa-loop-im.c (outermost_invariant_loop_expr): Avoid using C++\n+\tkeywords as variable names.\n+\t(may_move_till): Cast according to the coding conventions.\n+\t(force_move_till_expr): Avoid using C++ keywords as variable names.\n+\t(force_move_till): Cast according to the coding conventions.\n+\t(memref_hash): Likewise.\n+\t(memref_eq): Likewise.\n+\t(gather_mem_refs_stmt): Likewise.\n+\t* tree-ssa-loop-ivopts.c (contains_abnormal_ssa_name_p): Avoid using C++\n+\tkeywords as variable names.\n+\t(idx_find_step): Cast according to the coding conventions.\n+\t(idx_record_use): Likewise.\n+\t(find_depends): Likewise.\n+\t(prepare_decl_rtl): Likewise.\n+\t(mbc_entry_hash): Likewise.\n+\t(mbc_entry_eq): Likewise.\n+\t* tree-ssa-loop-niter.c (SWAP): Use the correct the type for tmp.\n+\t(simplify_replace_tree): Avoid using C++ keywords as variable names.\n+\t(idx_infer_loop_bounds): Cast according to the coding conventions.\n+\t* tree-ssa-loop-prefetch.c (idx_analyze_ref): Likewise.\n+\t* tree-ssa-math-opts.c (occ_new ): Likwise.\n+\t* tree-ssanames.c (duplicate_ssa_name_ptr_info): Use type safe memory\n+\tmacros.\n+\t* tree-ssa-operands.c (add_def_op): Avoid using C++ keywords as variable\n+\tnames.\n+\t(add_use_op): Likewise.\n+\t(add_vop): Likewise.\n+\t(add_vuse_op): Likewise.\n+\t(add_vdef_op): Likewise.\n+\t(get_expr_operands): Likewise.\n+\t(push_stmt_changes): Use type safe memory macros.\n+\t* tree-ssa-phiopt.c (replace_phi_edge_with_variable): Avoid using C++\n+\tkeywords as variable names.\n+\t(conditional_replacement): Likewise.\n+\t(minmax_replacement): Likewise.\n+\t(abs_replacement): Likewise.\n+\t* tree-ssa-pre.c (create_expression_by_pieces): Cast according to the\n+\tcoding conventions.\n+\t(insert_fake_stores): Avoid using C++ keywords as variable names.\n+\t* tree-ssa-reassoc.c (add_to_ops_vec): Cast according to the coding\n+\tconventions.\n+\t* tree-ssa-structalias.c (heapvar_lookup): Likewise.\n+\t(heapvar_insert): Use type safe memory macros.\n+\t(new_var_info): Cast according to the coding conventions.\n+\t(new_constraint): Likewise.\n+\t(remove_preds_and_fake_succs): Use type safe memory macros.\n+\t* tree-ssa-threadupdate.c (thread_block): Cast according to the coding\n+\tconventions.\n+\t(thread_single_edge): Likewise.\n+\t(thread_through_loop_header): Likewise.\n+\n 2007-06-06  Eric Christopher  <echristo@apple.com>\n \n \t* config/i386/i386.c (override_options): Move handling"}, {"sha": "4f83de4742a463dfaa8583a57a670f0d29028ee0", "filename": "gcc/tree-ssa-alias-warnings.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-alias-warnings.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-alias-warnings.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias-warnings.c?ref=c22940cd7cb1bb5d23e496acc843a74d44ee050a", "patch": "@@ -379,7 +379,7 @@ match (htab_t ref_map, tree key)\n static inline void\n maybe_add_match (htab_t ref_map, struct tree_map *key)\n {\n-  struct tree_map *found = htab_find (ref_map, key);\n+  struct tree_map *found = (struct tree_map *) htab_find (ref_map, key);\n \n   if (found && !found->to)\n     found->to = key->to;\n@@ -392,7 +392,7 @@ static void\n add_key (htab_t ht, tree t, alloc_pool references_pool)\n {\n   void **slot;\n-  struct tree_map *tp = pool_alloc (references_pool);\n+  struct tree_map *tp = (struct tree_map *) pool_alloc (references_pool);\n \n   tp->base.from = t;\n   tp->to = NULL_TREE;"}, {"sha": "3b275babf66bc0b6249633e8f02fa993a0e0bb53", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=c22940cd7cb1bb5d23e496acc843a74d44ee050a", "patch": "@@ -2395,14 +2395,14 @@ ccp_fold_builtin (tree stmt, tree fn)\n     case BUILT_IN_STRLEN:\n       if (val[0])\n \t{\n-\t  tree new = fold_convert (TREE_TYPE (fn), val[0]);\n+\t  tree new_val = fold_convert (TREE_TYPE (fn), val[0]);\n \n \t  /* If the result is not a valid gimple value, or not a cast\n \t     of a valid gimple value, then we can not use the result.  */\n-\t  if (is_gimple_val (new)\n-\t      || (is_gimple_cast (new)\n-\t\t  && is_gimple_val (TREE_OPERAND (new, 0))))\n-\t    return new;\n+\t  if (is_gimple_val (new_val)\n+\t      || (is_gimple_cast (new_val)\n+\t\t  && is_gimple_val (TREE_OPERAND (new_val, 0))))\n+\t    return new_val;\n \t}\n       break;\n "}, {"sha": "04f97cf1462761071e7868b4667db23888e21d94", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=c22940cd7cb1bb5d23e496acc843a74d44ee050a", "patch": "@@ -260,7 +260,7 @@ find_coalesce_pair (coalesce_list_p cl, int p1, int p2, bool create)\n   if (create && !pair)\n     {\n       gcc_assert (cl->sorted == NULL);\n-      pair = xmalloc (sizeof (struct coalesce_pair));\n+      pair = XNEW (struct coalesce_pair);\n       pair->first_element = p.first_element;\n       pair->second_element = p.second_element;\n       pair->cost = 0;\n@@ -276,7 +276,7 @@ add_cost_one_coalesce (coalesce_list_p cl, int p1, int p2)\n {\n   cost_one_pair_p pair;\n \n-  pair = xmalloc (sizeof (struct cost_one_pair_d));\n+  pair = XNEW (struct cost_one_pair_d);\n   pair->first_element = p1;\n   pair->second_element = p2;\n   pair->next = cl->cost_one_list;"}, {"sha": "97c4c03343c908e4165bd1bb8ff3743f2105d184", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=c22940cd7cb1bb5d23e496acc843a74d44ee050a", "patch": "@@ -199,31 +199,31 @@ may_propagate_copy_into_asm (tree dest)\n    they both share the same memory tags.  */\n \n void\n-merge_alias_info (tree orig, tree new)\n+merge_alias_info (tree orig_name, tree new_name)\n {\n-  tree new_sym = SSA_NAME_VAR (new);\n-  tree orig_sym = SSA_NAME_VAR (orig);\n+  tree new_sym = SSA_NAME_VAR (new_name);\n+  tree orig_sym = SSA_NAME_VAR (orig_name);\n   var_ann_t new_ann = var_ann (new_sym);\n   var_ann_t orig_ann = var_ann (orig_sym);\n \n   /* No merging necessary when memory partitions are involved.  */\n-  if (factoring_name_p (new))\n+  if (factoring_name_p (new_name))\n     {\n       gcc_assert (!is_gimple_reg (orig_sym));\n       return;\n     }\n-  else if (factoring_name_p (orig))\n+  else if (factoring_name_p (orig_name))\n     {\n       gcc_assert (!is_gimple_reg (new_sym));\n       return;\n     }\n \n-  gcc_assert (POINTER_TYPE_P (TREE_TYPE (orig)));\n-  gcc_assert (POINTER_TYPE_P (TREE_TYPE (new)));\n+  gcc_assert (POINTER_TYPE_P (TREE_TYPE (orig_name)));\n+  gcc_assert (POINTER_TYPE_P (TREE_TYPE (new_name)));\n \n #if defined ENABLE_CHECKING\n-  gcc_assert (lang_hooks.types_compatible_p (TREE_TYPE (orig),\n-\t\t\t\t\t     TREE_TYPE (new)));\n+  gcc_assert (lang_hooks.types_compatible_p (TREE_TYPE (orig_name),\n+\t\t\t\t\t     TREE_TYPE (new_name)));\n \n   /* If the pointed-to alias sets are different, these two pointers\n      would never have the same memory tag.  In this case, NEW should\n@@ -259,10 +259,10 @@ merge_alias_info (tree orig, tree new)\n      Since we cannot distinguish one case from another in this\n      function, we can only make sure that if P_i and Q_j have\n      flow-sensitive information, they should be compatible.  */\n-  if (SSA_NAME_PTR_INFO (orig) && SSA_NAME_PTR_INFO (new))\n+  if (SSA_NAME_PTR_INFO (orig_name) && SSA_NAME_PTR_INFO (new_name))\n     {\n-      struct ptr_info_def *orig_ptr_info = SSA_NAME_PTR_INFO (orig);\n-      struct ptr_info_def *new_ptr_info = SSA_NAME_PTR_INFO (new);\n+      struct ptr_info_def *orig_ptr_info = SSA_NAME_PTR_INFO (orig_name);\n+      struct ptr_info_def *new_ptr_info = SSA_NAME_PTR_INFO (new_name);\n \n       /* Note that pointer NEW and ORIG may actually have different\n \t pointed-to variables (e.g., PR 18291 represented in"}, {"sha": "0241155de0fe4b33c1c38e6a84a57f05e332067d", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=c22940cd7cb1bb5d23e496acc843a74d44ee050a", "patch": "@@ -569,7 +569,7 @@ dom_thread_across_edge (struct dom_walk_data *walk_data, edge e)\n       walk_data->global_data = dummy_cond;\n     }\n \n-  thread_across_edge (walk_data->global_data, e, false,\n+  thread_across_edge ((tree) walk_data->global_data, e, false,\n \t\t      &const_and_copies_stack,\n \t\t      simplify_stmt_for_jump_threading);\n }\n@@ -1239,26 +1239,26 @@ cprop_into_successor_phis (basic_block bb)\n       indx = e->dest_idx;\n       for ( ; phi; phi = PHI_CHAIN (phi))\n \t{\n-\t  tree new;\n+\t  tree new_val;\n \t  use_operand_p orig_p;\n-\t  tree orig;\n+\t  tree orig_val;\n \n \t  /* The alternative may be associated with a constant, so verify\n \t     it is an SSA_NAME before doing anything with it.  */\n \t  orig_p = PHI_ARG_DEF_PTR (phi, indx);\n-\t  orig = USE_FROM_PTR (orig_p);\n-\t  if (TREE_CODE (orig) != SSA_NAME)\n+\t  orig_val = USE_FROM_PTR (orig_p);\n+\t  if (TREE_CODE (orig_val) != SSA_NAME)\n \t    continue;\n \n \t  /* If we have *ORIG_P in our constant/copy table, then replace\n \t     ORIG_P with its value in our constant/copy table.  */\n-\t  new = SSA_NAME_VALUE (orig);\n-\t  if (new\n-\t      && new != orig\n-\t      && (TREE_CODE (new) == SSA_NAME\n-\t\t  || is_gimple_min_invariant (new))\n-\t      && may_propagate_copy (orig, new))\n-\t    propagate_value (orig_p, new);\n+\t  new_val = SSA_NAME_VALUE (orig_val);\n+\t  if (new_val\n+\t      && new_val != orig_val\n+\t      && (TREE_CODE (new_val) == SSA_NAME\n+\t\t  || is_gimple_min_invariant (new_val))\n+\t      && may_propagate_copy (orig_val, new_val))\n+\t    propagate_value (orig_p, new_val);\n \t}\n     }\n }\n@@ -1591,7 +1591,7 @@ record_equivalences_from_stmt (tree stmt, int may_optimize_p, stmt_ann_t ann)\n       && !is_gimple_reg (lhs))\n     {\n       tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n-      tree new;\n+      tree new_stmt;\n \n       /* FIXME: If the LHS of the assignment is a bitfield and the RHS\n          is a constant, we need to adjust the constant to fit into the\n@@ -1617,13 +1617,13 @@ record_equivalences_from_stmt (tree stmt, int may_optimize_p, stmt_ann_t ann)\n       if (rhs)\n \t{\n \t  /* Build a new statement with the RHS and LHS exchanged.  */\n-\t  new = build_gimple_modify_stmt (rhs, lhs);\n+\t  new_stmt = build_gimple_modify_stmt (rhs, lhs);\n \n-\t  create_ssa_artificial_load_stmt (new, stmt);\n+\t  create_ssa_artificial_load_stmt (new_stmt, stmt);\n \n \t  /* Finally enter the statement into the available expression\n \t     table.  */\n-\t  lookup_avail_expr (new, true);\n+\t  lookup_avail_expr (new_stmt, true);\n \t}\n     }\n }"}, {"sha": "1be41275d111a85f746be439e1474488f31f3881", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=c22940cd7cb1bb5d23e496acc843a74d44ee050a", "patch": "@@ -168,7 +168,8 @@ dse_initialize_block_local_data (struct dom_walk_data *walk_data,\n \t\t\t\t bool recycled)\n {\n   struct dse_block_local_data *bd\n-    = VEC_last (void_p, walk_data->block_data_stack);\n+    = (struct dse_block_local_data *)\n+\tVEC_last (void_p, walk_data->block_data_stack);\n \n   /* If we are given a recycled block local data structure, ensure any\n      bitmap associated with the block is cleared.  */\n@@ -190,7 +191,7 @@ static tree\n memory_ssa_name_same (tree *expr_p, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t\t      void *data)\n {\n-  struct address_walk_data *walk_data = data;\n+  struct address_walk_data *walk_data = (struct address_walk_data *) data;\n   tree expr = *expr_p;\n   tree def_stmt;\n   basic_block def_bb;\n@@ -615,8 +616,10 @@ dse_optimize_stmt (struct dom_walk_data *walk_data,\n \t\t   block_stmt_iterator bsi)\n {\n   struct dse_block_local_data *bd\n-    = VEC_last (void_p, walk_data->block_data_stack);\n-  struct dse_global_data *dse_gd = walk_data->global_data;\n+    = (struct dse_block_local_data *)\n+\tVEC_last (void_p, walk_data->block_data_stack);\n+  struct dse_global_data *dse_gd\n+    = (struct dse_global_data *) walk_data->global_data;\n   tree stmt = bsi_stmt (bsi);\n   stmt_ann_t ann = stmt_ann (stmt);\n \n@@ -722,8 +725,10 @@ static void\n dse_record_phis (struct dom_walk_data *walk_data, basic_block bb)\n {\n   struct dse_block_local_data *bd\n-    = VEC_last (void_p, walk_data->block_data_stack);\n-  struct dse_global_data *dse_gd = walk_data->global_data;\n+    = (struct dse_block_local_data *)\n+\tVEC_last (void_p, walk_data->block_data_stack);\n+  struct dse_global_data *dse_gd\n+    = (struct dse_global_data *) walk_data->global_data;\n   tree phi;\n \n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n@@ -738,8 +743,10 @@ dse_finalize_block (struct dom_walk_data *walk_data,\n \t\t    basic_block bb ATTRIBUTE_UNUSED)\n {\n   struct dse_block_local_data *bd\n-    = VEC_last (void_p, walk_data->block_data_stack);\n-  struct dse_global_data *dse_gd = walk_data->global_data;\n+    = (struct dse_block_local_data *)\n+\tVEC_last (void_p, walk_data->block_data_stack);\n+  struct dse_global_data *dse_gd\n+    = (struct dse_global_data *) walk_data->global_data;\n   bitmap stores = dse_gd->stores;\n   unsigned int i;\n   bitmap_iterator bi;"}, {"sha": "5b00cf6421767e0c5d52de985cbb0298bdcd2551", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=c22940cd7cb1bb5d23e496acc843a74d44ee050a", "patch": "@@ -330,7 +330,7 @@ outermost_invariant_loop (tree def, struct loop *loop)\n static struct loop *\n outermost_invariant_loop_expr (tree expr, struct loop *loop)\n {\n-  enum tree_code_class class = TREE_CODE_CLASS (TREE_CODE (expr));\n+  enum tree_code_class codeclass = TREE_CODE_CLASS (TREE_CODE (expr));\n   unsigned i, nops;\n   struct loop *max_loop = superloop_at_depth (loop, 1), *aloop;\n \n@@ -339,11 +339,11 @@ outermost_invariant_loop_expr (tree expr, struct loop *loop)\n       || is_gimple_min_invariant (expr))\n     return outermost_invariant_loop (expr, loop);\n \n-  if (class != tcc_unary\n-      && class != tcc_binary\n-      && class != tcc_expression\n-      && class != tcc_vl_exp\n-      && class != tcc_comparison)\n+  if (codeclass != tcc_unary\n+      && codeclass != tcc_binary\n+      && codeclass != tcc_expression\n+      && codeclass != tcc_vl_exp\n+      && codeclass != tcc_comparison)\n     return NULL;\n \n   nops = TREE_OPERAND_LENGTH (expr);\n@@ -883,7 +883,7 @@ move_computations (void)\n static bool\n may_move_till (tree ref, tree *index, void *data)\n {\n-  struct loop *loop = data, *max_loop;\n+  struct loop *loop = (struct loop*) data, *max_loop;\n \n   /* If REF is an array reference, check also that the step and the lower\n      bound is invariant in LOOP.  */\n@@ -914,7 +914,7 @@ may_move_till (tree ref, tree *index, void *data)\n static void\n force_move_till_expr (tree expr, struct loop *orig_loop, struct loop *loop)\n {\n-  enum tree_code_class class = TREE_CODE_CLASS (TREE_CODE (expr));\n+  enum tree_code_class codeclass = TREE_CODE_CLASS (TREE_CODE (expr));\n   unsigned i, nops;\n \n   if (TREE_CODE (expr) == SSA_NAME)\n@@ -927,11 +927,11 @@ force_move_till_expr (tree expr, struct loop *orig_loop, struct loop *loop)\n       return;\n     }\n \n-  if (class != tcc_unary\n-      && class != tcc_binary\n-      && class != tcc_expression\n-      && class != tcc_vl_exp\n-      && class != tcc_comparison)\n+  if (codeclass != tcc_unary\n+      && codeclass != tcc_binary\n+      && codeclass != tcc_expression\n+      && codeclass != tcc_vl_exp\n+      && codeclass != tcc_comparison)\n     return;\n \n   nops = TREE_OPERAND_LENGTH (expr);\n@@ -953,7 +953,7 @@ static bool\n force_move_till (tree ref, tree *index, void *data)\n {\n   tree stmt;\n-  struct fmt_data *fmt_data = data;\n+  struct fmt_data *fmt_data = (struct fmt_data *) data;\n \n   if (TREE_CODE (ref) == ARRAY_REF)\n     {\n@@ -1285,9 +1285,7 @@ loop_suitable_for_sm (struct loop *loop ATTRIBUTE_UNUSED,\n static hashval_t\n memref_hash (const void *obj)\n {\n-  const struct mem_ref *mem = obj;\n-\n-  return mem->hash;\n+  return ((const struct mem_ref *) obj)->hash;\n }\n \n /* An equality function for struct mem_ref object OBJ1 with\n@@ -1296,7 +1294,7 @@ memref_hash (const void *obj)\n static int\n memref_eq (const void *obj1, const void *obj2)\n {\n-  const struct mem_ref *mem1 = obj1;\n+  const struct mem_ref *mem1 = (const struct mem_ref *) obj1;\n \n   return operand_equal_p (mem1->mem, (tree) obj2, 0);\n }\n@@ -1359,7 +1357,7 @@ gather_mem_refs_stmt (struct loop *loop, htab_t mem_refs,\n   slot = htab_find_slot_with_hash (mem_refs, *mem, hash, INSERT);\n \n   if (*slot)\n-    ref = *slot;\n+    ref = (struct mem_ref *) *slot;\n   else\n     {\n       ref = XNEW (struct mem_ref);"}, {"sha": "326c4dbcf7926387387a68011ec87f657b413e6b", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=c22940cd7cb1bb5d23e496acc843a74d44ee050a", "patch": "@@ -634,13 +634,13 @@ bool\n contains_abnormal_ssa_name_p (tree expr)\n {\n   enum tree_code code;\n-  enum tree_code_class class;\n+  enum tree_code_class codeclass;\n \n   if (!expr)\n     return false;\n \n   code = TREE_CODE (expr);\n-  class = TREE_CODE_CLASS (code);\n+  codeclass = TREE_CODE_CLASS (code);\n \n   if (code == SSA_NAME)\n     return SSA_NAME_OCCURS_IN_ABNORMAL_PHI (expr) != 0;\n@@ -654,7 +654,7 @@ contains_abnormal_ssa_name_p (tree expr)\n \t\t\t    idx_contains_abnormal_ssa_name_p,\n \t\t\t    NULL);\n \n-  switch (class)\n+  switch (codeclass)\n     {\n     case tcc_binary:\n     case tcc_comparison:\n@@ -711,7 +711,7 @@ niter_for_exit (struct ivopts_data *data, edge exit)\n       *pointer_map_insert (data->niters, exit) = niter;\n     }\n   else\n-    niter = *slot;\n+    niter = (tree) *slot;\n \n   return niter;\n }\n@@ -1295,7 +1295,7 @@ struct ifs_ivopts_data\n static bool\n idx_find_step (tree base, tree *idx, void *data)\n {\n-  struct ifs_ivopts_data *dta = data;\n+  struct ifs_ivopts_data *dta = (struct ifs_ivopts_data *) data;\n   struct iv *iv;\n   tree step, iv_base, iv_step, lbound, off;\n   struct loop *loop = dta->ivopts_data->current_loop;\n@@ -1374,8 +1374,9 @@ idx_find_step (tree base, tree *idx, void *data)\n \n static bool\n idx_record_use (tree base, tree *idx,\n-\t\tvoid *data)\n+\t\tvoid *vdata)\n {\n+  struct ivopts_data *data = (struct ivopts_data *) vdata;\n   find_interesting_uses_op (data, *idx);\n   if (TREE_CODE (base) == ARRAY_REF)\n     {\n@@ -1905,7 +1906,7 @@ static struct ivopts_data *fd_ivopts_data;\n static tree\n find_depends (tree *expr_p, int *ws ATTRIBUTE_UNUSED, void *data)\n {\n-  bitmap *depends_on = data;\n+  bitmap *depends_on = (bitmap *) data;\n   struct version_info *info;\n \n   if (TREE_CODE (*expr_p) != SSA_NAME)\n@@ -2402,7 +2403,7 @@ prepare_decl_rtl (tree *expr_p, int *ws, void *data)\n {\n   tree obj = NULL_TREE;\n   rtx x = NULL_RTX;\n-  int *regno = data;\n+  int *regno = (int *) data;\n \n   switch (TREE_CODE (*expr_p))\n     {\n@@ -2756,7 +2757,7 @@ struct mbc_entry\n static hashval_t\n mbc_entry_hash (const void *entry)\n {\n-  const struct mbc_entry *e = entry;\n+  const struct mbc_entry *e = (const struct mbc_entry *) entry;\n \n   return 57 * (hashval_t) e->mode + (hashval_t) (e->cst % 877);\n }\n@@ -2766,8 +2767,8 @@ mbc_entry_hash (const void *entry)\n static int\n mbc_entry_eq (const void *entry1, const void *entry2)\n {\n-  const struct mbc_entry *e1 = entry1;\n-  const struct mbc_entry *e2 = entry2;\n+  const struct mbc_entry *e1 = (const struct mbc_entry *) entry1;\n+  const struct mbc_entry *e2 = (const struct mbc_entry *) entry2;\n \n   return (e1->mode == e2->mode\n \t  && e1->cst == e2->cst);"}, {"sha": "11e90a791b1a0190c72718cd92c3fa79e8afe233", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=c22940cd7cb1bb5d23e496acc843a74d44ee050a", "patch": "@@ -44,7 +44,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tree-inline.h\"\n #include \"gmp.h\"\n \n-#define SWAP(X, Y) do { void *tmp = (X); (X) = (Y); (Y) = tmp; } while (0)\n+#define SWAP(X, Y) do { affine_iv *tmp = (X); (X) = (Y); (Y) = tmp; } while (0)\n \n /* The maximum number of dominator BBs we search for conditions\n    of loop header copies we use for simplifying a conditional\n@@ -1324,7 +1324,7 @@ number_of_iterations_cond (struct loop *loop,\n /* Substitute NEW for OLD in EXPR and fold the result.  */\n \n static tree\n-simplify_replace_tree (tree expr, tree old, tree new)\n+simplify_replace_tree (tree expr, tree old, tree new_tree)\n {\n   unsigned i, n;\n   tree ret = NULL_TREE, e, se;\n@@ -1334,7 +1334,7 @@ simplify_replace_tree (tree expr, tree old, tree new)\n \n   if (expr == old\n       || operand_equal_p (expr, old, 0))\n-    return unshare_expr (new);\n+    return unshare_expr (new_tree);\n \n   if (!EXPR_P (expr) && !GIMPLE_STMT_P (expr))\n     return expr;\n@@ -1343,7 +1343,7 @@ simplify_replace_tree (tree expr, tree old, tree new)\n   for (i = 0; i < n; i++)\n     {\n       e = TREE_OPERAND (expr, i);\n-      se = simplify_replace_tree (e, old, new);\n+      se = simplify_replace_tree (e, old, new_tree);\n       if (e == se)\n \tcontinue;\n \n@@ -2509,7 +2509,7 @@ struct ilb_data\n static bool\n idx_infer_loop_bounds (tree base, tree *idx, void *dta)\n {\n-  struct ilb_data *data = dta;\n+  struct ilb_data *data = (struct ilb_data *) dta;\n   tree ev, init, step;\n   tree low, high, type, next;\n   bool sign, upper = data->reliable, at_end = false;"}, {"sha": "64f45a856ed97f74093d26ab0a4510451e3df195", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=c22940cd7cb1bb5d23e496acc843a74d44ee050a", "patch": "@@ -343,7 +343,7 @@ struct ar_data\n static bool\n idx_analyze_ref (tree base, tree *index, void *data)\n {\n-  struct ar_data *ar_data = data;\n+  struct ar_data *ar_data = (struct ar_data *) data;\n   tree ibase, step, stepsize;\n   HOST_WIDE_INT istep, idelta = 0, imult = 1;\n   affine_iv iv;"}, {"sha": "fe67993f8dc17f9c1c807e9bf5dc5ebfd9352011", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=c22940cd7cb1bb5d23e496acc843a74d44ee050a", "patch": "@@ -151,7 +151,7 @@ occ_new (basic_block bb, struct occurrence *children)\n {\n   struct occurrence *occ;\n \n-  occ = bb->aux = pool_alloc (occ_pool);\n+  bb->aux = occ = (struct occurrence *) pool_alloc (occ_pool);\n   memset (occ, 0, sizeof (struct occurrence));\n \n   occ->bb = bb;"}, {"sha": "d015a569cd28c46ed75834d8fbda92a0ffbff0b5", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=c22940cd7cb1bb5d23e496acc843a74d44ee050a", "patch": "@@ -592,13 +592,13 @@ set_virtual_use_link (use_operand_p ptr, tree stmt)\n static inline def_optype_p \n add_def_op (tree *op, def_optype_p last)\n {\n-  def_optype_p new;\n+  def_optype_p new_def;\n \n-  new = alloc_def ();\n-  DEF_OP_PTR (new) = op;\n-  last->next = new;\n-  new->next = NULL;\n-  return new;\n+  new_def = alloc_def ();\n+  DEF_OP_PTR (new_def) = op;\n+  last->next = new_def;\n+  new_def->next = NULL;\n+  return new_def;\n }\n \n \n@@ -607,14 +607,14 @@ add_def_op (tree *op, def_optype_p last)\n static inline use_optype_p\n add_use_op (tree stmt, tree *op, use_optype_p last)\n {\n-  use_optype_p new;\n+  use_optype_p new_use;\n \n-  new = alloc_use ();\n-  USE_OP_PTR (new)->use = op;\n-  link_imm_use_stmt (USE_OP_PTR (new), *op, stmt);\n-  last->next = new;\n-  new->next = NULL;\n-  return new;\n+  new_use = alloc_use ();\n+  USE_OP_PTR (new_use)->use = op;\n+  link_imm_use_stmt (USE_OP_PTR (new_use), *op, stmt);\n+  last->next = new_use;\n+  new_use->next = NULL;\n+  return new_use;\n }\n \n \n@@ -625,22 +625,23 @@ add_use_op (tree stmt, tree *op, use_optype_p last)\n static inline voptype_p\n add_vop (tree stmt, tree op, int num, voptype_p prev)\n {\n-  voptype_p new;\n+  voptype_p new_vop;\n   int x;\n \n-  new = alloc_vop (num);\n+  new_vop = alloc_vop (num);\n   for (x = 0; x < num; x++)\n     {\n-      VUSE_OP_PTR (new, x)->prev = NULL;\n-      SET_VUSE_OP (new, x, op);\n-      VUSE_OP_PTR (new, x)->use = &new->usev.uses[x].use_var;\n-      link_imm_use_stmt (VUSE_OP_PTR (new, x), new->usev.uses[x].use_var, stmt);\n+      VUSE_OP_PTR (new_vop, x)->prev = NULL;\n+      SET_VUSE_OP (new_vop, x, op);\n+      VUSE_OP_PTR (new_vop, x)->use = &new_vop->usev.uses[x].use_var;\n+      link_imm_use_stmt (VUSE_OP_PTR (new_vop, x),\n+\t\t\t new_vop->usev.uses[x].use_var, stmt);\n     }\n \n   if (prev)\n-    prev->next = new;\n-  new->next = NULL;\n-  return new;\n+    prev->next = new_vop;\n+  new_vop->next = NULL;\n+  return new_vop;\n }\n \n \n@@ -650,9 +651,9 @@ add_vop (tree stmt, tree op, int num, voptype_p prev)\n static inline voptype_p\n add_vuse_op (tree stmt, tree op, int num, voptype_p last)\n {\n-  voptype_p new = add_vop (stmt, op, num, last);\n-  VDEF_RESULT (new) = NULL_TREE;\n-  return new;\n+  voptype_p new_vop = add_vop (stmt, op, num, last);\n+  VDEF_RESULT (new_vop) = NULL_TREE;\n+  return new_vop;\n }\n \n \n@@ -662,9 +663,9 @@ add_vuse_op (tree stmt, tree op, int num, voptype_p last)\n static inline voptype_p\n add_vdef_op (tree stmt, tree op, int num, voptype_p last)\n {\n-  voptype_p new = add_vop (stmt, op, num, last);\n-  VDEF_RESULT (new) = op;\n-  return new;\n+  voptype_p new_vop = add_vop (stmt, op, num, last);\n+  VDEF_RESULT (new_vop) = op;\n+  return new_vop;\n }\n   \n \n@@ -2059,15 +2060,15 @@ static void\n get_expr_operands (tree stmt, tree *expr_p, int flags)\n {\n   enum tree_code code;\n-  enum tree_code_class class;\n+  enum tree_code_class codeclass;\n   tree expr = *expr_p;\n   stmt_ann_t s_ann = stmt_ann (stmt);\n \n   if (expr == NULL)\n     return;\n \n   code = TREE_CODE (expr);\n-  class = TREE_CODE_CLASS (code);\n+  codeclass = TREE_CODE_CLASS (code);\n \n   switch (code)\n     {\n@@ -2284,11 +2285,11 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n       return;\n \n     default:\n-      if (class == tcc_unary)\n+      if (codeclass == tcc_unary)\n \tgoto do_unary;\n-      if (class == tcc_binary || class == tcc_comparison)\n+      if (codeclass == tcc_binary || codeclass == tcc_comparison)\n \tgoto do_binary;\n-      if (class == tcc_constant || class == tcc_type)\n+      if (codeclass == tcc_constant || codeclass == tcc_type)\n \treturn;\n     }\n \n@@ -2794,7 +2795,7 @@ push_stmt_changes (tree *stmt_p)\n   if (TREE_CODE (stmt) == PHI_NODE)\n     return;\n \n-  buf = xmalloc (sizeof *buf);\n+  buf = XNEW (struct scb_d);\n   memset (buf, 0, sizeof *buf);\n \n   buf->stmt_p = stmt_p;"}, {"sha": "0c756d915cc138e5290ea278209bd6edc9493bd9", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=c22940cd7cb1bb5d23e496acc843a74d44ee050a", "patch": "@@ -322,14 +322,14 @@ empty_block_p (basic_block bb)\n \n static void\n replace_phi_edge_with_variable (basic_block cond_block,\n-\t\t\t\tedge e, tree phi, tree new)\n+\t\t\t\tedge e, tree phi, tree new_tree)\n {\n   basic_block bb = bb_for_stmt (phi);\n   basic_block block_to_remove;\n   block_stmt_iterator bsi;\n \n   /* Change the PHI argument to new.  */\n-  SET_USE (PHI_ARG_DEF_PTR (phi, e->dest_idx), new);\n+  SET_USE (PHI_ARG_DEF_PTR (phi, e->dest_idx), new_tree);\n \n   /* Remove the empty basic block.  */\n   if (EDGE_SUCC (cond_block, 0)->dest == bb)\n@@ -377,7 +377,7 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n {\n   tree result;\n   tree old_result = NULL;\n-  tree new, cond;\n+  tree new_stmt, cond;\n   block_stmt_iterator bsi;\n   edge true_edge, false_edge;\n   tree new_var = NULL;\n@@ -470,7 +470,7 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n       || (e1 == true_edge && integer_onep (arg1))\n       || (e1 == false_edge && integer_zerop (arg1)))\n     {\n-      new = build_gimple_modify_stmt (new_var1, cond);\n+      new_stmt = build_gimple_modify_stmt (new_var1, cond);\n     }\n   else\n     {\n@@ -514,19 +514,19 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n \t  tmp = create_tmp_var (TREE_TYPE (op0), NULL);\n \t  add_referenced_var (tmp);\n \t  cond_tmp = make_ssa_name (tmp, NULL);\n-\t  new = build_gimple_modify_stmt (cond_tmp, op0);\n-\t  SSA_NAME_DEF_STMT (cond_tmp) = new;\n+\t  new_stmt = build_gimple_modify_stmt (cond_tmp, op0);\n+\t  SSA_NAME_DEF_STMT (cond_tmp) = new_stmt;\n \n-\t  bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n+\t  bsi_insert_after (&bsi, new_stmt, BSI_NEW_STMT);\n \t  cond = fold_convert (TREE_TYPE (result), cond_tmp);\n \t}\n \n-      new = build_gimple_modify_stmt (new_var1, cond);\n+      new_stmt = build_gimple_modify_stmt (new_var1, cond);\n     }\n \n-  bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n+  bsi_insert_after (&bsi, new_stmt, BSI_NEW_STMT);\n \n-  SSA_NAME_DEF_STMT (new_var1) = new;\n+  SSA_NAME_DEF_STMT (new_var1) = new_stmt;\n \n   replace_phi_edge_with_variable (cond_bb, e1, phi, new_var1);\n \n@@ -624,7 +624,7 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n \t\t    tree arg0, tree arg1)\n {\n   tree result, type;\n-  tree cond, new;\n+  tree cond, new_stmt;\n   edge true_edge, false_edge;\n   enum tree_code cmp, minmax, ass_code;\n   tree smaller, larger, arg_true, arg_false;\n@@ -853,10 +853,10 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n \n   /* Emit the statement to compute min/max.  */\n   result = duplicate_ssa_name (PHI_RESULT (phi), NULL);\n-  new = build_gimple_modify_stmt (result, build2 (minmax, type, arg0, arg1));\n-  SSA_NAME_DEF_STMT (result) = new;\n+  new_stmt = build_gimple_modify_stmt (result, build2 (minmax, type, arg0, arg1));\n+  SSA_NAME_DEF_STMT (result) = new_stmt;\n   bsi = bsi_last (cond_bb);\n-  bsi_insert_before (&bsi, new, BSI_NEW_STMT);\n+  bsi_insert_before (&bsi, new_stmt, BSI_NEW_STMT);\n \n   replace_phi_edge_with_variable (cond_bb, e1, phi, result);\n   return true;\n@@ -874,7 +874,7 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n \t\t tree phi, tree arg0, tree arg1)\n {\n   tree result;\n-  tree new, cond;\n+  tree new_stmt, cond;\n   block_stmt_iterator bsi;\n   edge true_edge, false_edge;\n   tree assign;\n@@ -965,24 +965,24 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n     lhs = result;\n \n   /* Build the modify expression with abs expression.  */\n-  new = build_gimple_modify_stmt (lhs,\n-\t\t\t\t  build1 (ABS_EXPR, TREE_TYPE (lhs), rhs));\n-  SSA_NAME_DEF_STMT (lhs) = new;\n+  new_stmt = build_gimple_modify_stmt (lhs,\n+\t\t\t\t       build1 (ABS_EXPR, TREE_TYPE (lhs), rhs));\n+  SSA_NAME_DEF_STMT (lhs) = new_stmt;\n \n   bsi = bsi_last (cond_bb);\n-  bsi_insert_before (&bsi, new, BSI_NEW_STMT);\n+  bsi_insert_before (&bsi, new_stmt, BSI_NEW_STMT);\n \n   if (negate)\n     {\n       /* Get the right BSI.  We want to insert after the recently\n \t added ABS_EXPR statement (which we know is the first statement\n \t in the block.  */\n-      new = build_gimple_modify_stmt (result,\n-\t\t\t\t      build1 (NEGATE_EXPR, TREE_TYPE (lhs),\n-\t\t\t\t\t      lhs));\n-      SSA_NAME_DEF_STMT (result) = new;\n+      new_stmt = build_gimple_modify_stmt (result,\n+\t\t\t\t           build1 (NEGATE_EXPR, TREE_TYPE (lhs),\n+\t\t\t\t\t           lhs));\n+      SSA_NAME_DEF_STMT (result) = new_stmt;\n \n-      bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n+      bsi_insert_after (&bsi, new_stmt, BSI_NEW_STMT);\n     }\n \n   replace_phi_edge_with_variable (cond_bb, e1, phi, result);"}, {"sha": "72af731999bc5e13b12632359ed2b569acb13e17", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=c22940cd7cb1bb5d23e496acc843a74d44ee050a", "patch": "@@ -2290,7 +2290,7 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \tgenfn = find_or_generate_expression (block, fn, stmts);\n \n \tnargs = call_expr_nargs (expr);\n-\tbuffer = alloca (nargs * sizeof (tree));\n+\tbuffer = (tree*) alloca (nargs * sizeof (tree));\n \n \tfor (i = 0; i < nargs; i++)\n \t  {\n@@ -3196,7 +3196,7 @@ insert_fake_stores (void)\n \t      def_operand_p defp;\n \t      tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n \t      tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n-\t      tree new;\n+\t      tree new_tree;\n \t      bool notokay = false;\n \n \t      FOR_EACH_SSA_DEF_OPERAND (defp, stmt, iter, SSA_OP_VIRTUAL_DEFS)\n@@ -3220,16 +3220,16 @@ insert_fake_stores (void)\n \t\t  get_var_ann (storetemp);\n \t\t}\n \n-\t      new = poolify_modify_stmt (storetemp, lhs);\n+\t      new_tree = poolify_modify_stmt (storetemp, lhs);\n \n-\t      lhs = make_ssa_name (storetemp, new);\n-\t      GIMPLE_STMT_OPERAND (new, 0) = lhs;\n-\t      create_ssa_artificial_load_stmt (new, stmt);\n+\t      lhs = make_ssa_name (storetemp, new_tree);\n+\t      GIMPLE_STMT_OPERAND (new_tree, 0) = lhs;\n+\t      create_ssa_artificial_load_stmt (new_tree, stmt);\n \n-\t      NECESSARY (new) = 0;\n-\t      VEC_safe_push (tree, heap, inserted_exprs, new);\n-\t      VEC_safe_push (tree, heap, need_creation, new);\n-\t      bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n+\t      NECESSARY (new_tree) = 0;\n+\t      VEC_safe_push (tree, heap, inserted_exprs, new_tree);\n+\t      VEC_safe_push (tree, heap, need_creation, new_tree);\n+\t      bsi_insert_after (&bsi, new_tree, BSI_NEW_STMT);\n \t    }\n \t}\n     }"}, {"sha": "bc0de6db0b0f2eb41a6278d919d7bbad5934e1f5", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=c22940cd7cb1bb5d23e496acc843a74d44ee050a", "patch": "@@ -337,7 +337,7 @@ sort_by_operand_rank (const void *pa, const void *pb)\n static void\n add_to_ops_vec (VEC(operand_entry_t, heap) **ops, tree op)\n {\n-  operand_entry_t oe = pool_alloc (operand_entry_pool);\n+  operand_entry_t oe = (operand_entry_t) pool_alloc (operand_entry_pool);\n \n   oe->op = op;\n   oe->rank = get_rank (op);"}, {"sha": "48f85b77b5a15b3d4d6a06853a4053bc59eced9e", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=c22940cd7cb1bb5d23e496acc843a74d44ee050a", "patch": "@@ -328,7 +328,8 @@ heapvar_lookup (tree from)\n   struct tree_map *h, in;\n   in.base.from = from;\n \n-  h = htab_find_with_hash (heapvar_for_stmt, &in, htab_hash_pointer (from));\n+  h = (struct tree_map *) htab_find_with_hash (heapvar_for_stmt, &in,\n+\t\t\t\t\t       htab_hash_pointer (from));\n   if (h)\n     return h->to;\n   return NULL_TREE;\n@@ -343,7 +344,7 @@ heapvar_insert (tree from, tree to)\n   struct tree_map *h;\n   void **loc;\n \n-  h = ggc_alloc (sizeof (struct tree_map));\n+  h = GGC_NEW (struct tree_map);\n   h->hash = htab_hash_pointer (from);\n   h->base.from = from;\n   h->to = to;\n@@ -357,7 +358,7 @@ heapvar_insert (tree from, tree to)\n static varinfo_t\n new_var_info (tree t, unsigned int id, const char *name)\n {\n-  varinfo_t ret = pool_alloc (variable_info_pool);\n+  varinfo_t ret = (varinfo_t) pool_alloc (variable_info_pool);\n \n   ret->id = id;\n   ret->name = name;\n@@ -513,7 +514,7 @@ static constraint_t\n new_constraint (const struct constraint_expr lhs,\n \t\tconst struct constraint_expr rhs)\n {\n-  constraint_t ret = pool_alloc (constraint_pool);\n+  constraint_t ret = (constraint_t) pool_alloc (constraint_pool);\n   ret->lhs = lhs;\n   ret->rhs = rhs;\n   return ret;\n@@ -4762,7 +4763,7 @@ remove_preds_and_fake_succs (constraint_graph_t graph)\n   /* Now reallocate the size of the successor list as, and blow away\n      the predecessor bitmaps.  */\n   graph->size = VEC_length (varinfo_t, varmap);\n-  graph->succs = xrealloc (graph->succs, graph->size * sizeof (bitmap));\n+  graph->succs = XRESIZEVEC (bitmap, graph->succs, graph->size);\n \n   free (graph->implicit_preds);\n   graph->implicit_preds = NULL;"}, {"sha": "f5a524ac922a36c5f382f1545c7f99a47bf61cbe", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=c22940cd7cb1bb5d23e496acc843a74d44ee050a", "patch": "@@ -533,7 +533,7 @@ thread_block (basic_block bb, bool noloop_only)\n   if (loop->header == bb)\n     {\n       e = loop_latch_edge (loop);\n-      e2 = e->aux;\n+      e2 = (edge) e->aux;\n \n       if (e2 && loop_exit_edge_p (loop, e2))\n \t{\n@@ -546,7 +546,7 @@ thread_block (basic_block bb, bool noloop_only)\n      efficient lookups.  */\n   FOR_EACH_EDGE (e, ei, bb->preds)\n     {\n-      e2 = e->aux;\n+      e2 = (edge) e->aux;\n \n       if (!e2\n \t  /* If NOLOOP_ONLY is true, we only allow threading through the\n@@ -560,7 +560,7 @@ thread_block (basic_block bb, bool noloop_only)\n \t}\n \n       update_bb_profile_for_threading (e->dest, EDGE_FREQUENCY (e),\n-\t\t\t\t       e->count, e->aux);\n+\t\t\t\t       e->count, (edge) e->aux);\n \n       /* Insert the outgoing edge into the hash table if it is not\n \t already in the hash table.  */\n@@ -573,7 +573,7 @@ thread_block (basic_block bb, bool noloop_only)\n      DO_NOT_DUPLICATE attribute.  */\n   if (all)\n     {\n-      edge e = EDGE_PRED (bb, 0)->aux;\n+      edge e = (edge) EDGE_PRED (bb, 0)->aux;\n       lookup_redirection_data (e, NULL, NO_INSERT)->do_not_duplicate = true;\n     }\n \n@@ -623,7 +623,7 @@ static basic_block\n thread_single_edge (edge e)\n {\n   basic_block bb = e->dest;\n-  edge eto = e->aux;\n+  edge eto = (edge) e->aux;\n   struct redirection_data rd;\n   struct local_info local_info;\n \n@@ -822,7 +822,7 @@ thread_through_loop_header (struct loop *loop, bool may_peel_loop_headers)\n \n   if (latch->aux)\n     {\n-      tgt_edge = latch->aux;\n+      tgt_edge = (edge) latch->aux;\n       tgt_bb = tgt_edge->dest;\n     }\n   else if (!may_peel_loop_headers\n@@ -845,7 +845,7 @@ thread_through_loop_header (struct loop *loop, bool may_peel_loop_headers)\n \t      goto fail;\n \t    }\n \n-\t  tgt_edge = e->aux;\n+\t  tgt_edge = (edge) e->aux;\n \t  atgt_bb = tgt_edge->dest;\n \t  if (!tgt_bb)\n \t    tgt_bb = atgt_bb;"}, {"sha": "821440dafde14bc6c2d276d98ce9b4a68b9749e4", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=c22940cd7cb1bb5d23e496acc843a74d44ee050a", "patch": "@@ -799,7 +799,7 @@ var_ann_hash (const void *item)\n void\n init_tree_ssa (void)\n {\n-  cfun->gimple_df = ggc_alloc_cleared (sizeof (struct gimple_df));\n+  cfun->gimple_df = GGC_CNEW (struct gimple_df);\n   cfun->gimple_df->referenced_vars = htab_create_ggc (20, int_tree_map_hash, \n \t\t\t\t     \t\t      int_tree_map_eq, NULL);\n   cfun->gimple_df->default_defs = htab_create_ggc (20, int_tree_map_hash, "}, {"sha": "899ac82b0d19460c580700defc7f59941839c9a0", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22940cd7cb1bb5d23e496acc843a74d44ee050a/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=c22940cd7cb1bb5d23e496acc843a74d44ee050a", "patch": "@@ -266,7 +266,7 @@ duplicate_ssa_name_ptr_info (tree name, struct ptr_info_def *ptr_info)\n   if (!ptr_info)\n     return;\n \n-  new_ptr_info = ggc_alloc (sizeof (struct ptr_info_def));\n+  new_ptr_info = GGC_NEW (struct ptr_info_def);\n   *new_ptr_info = *ptr_info;\n \n   if (ptr_info->pt_vars)"}]}