{"sha": "57688950b9328cbb4a9c21eb3199f9132b5119d3", "node_id": "C_kwDOANBUbNoAKDU3Njg4OTUwYjkzMjhjYmI0YTljMjFlYjMxOTlmOTEzMmI1MTE5ZDM", "commit": {"author": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2023-03-17T12:58:58Z"}, "committer": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2023-03-17T13:07:20Z"}, "message": "LRA: Implement combining secondary memory reload and original insn\n\nLRA creates secondary memory reload insns but do not try to combine it\nwith the original insn.  This patch implements a simple insn combining\nfor such cases in LRA.\n\n        PR rtl-optimization/109052\n\ngcc/ChangeLog:\n\n\t* lra-constraints.cc: Include hooks.h.\n\t(combine_reload_insn): New function.\n\t(lra_constraints): Call it.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/i386/pr109052.c: New.", "tree": {"sha": "813adcb540e45b87fd571cc6370c443262dcff13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/813adcb540e45b87fd571cc6370c443262dcff13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57688950b9328cbb4a9c21eb3199f9132b5119d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57688950b9328cbb4a9c21eb3199f9132b5119d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57688950b9328cbb4a9c21eb3199f9132b5119d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57688950b9328cbb4a9c21eb3199f9132b5119d3/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "daf20b4b83615d61bf1793e8edcd64681275e598", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daf20b4b83615d61bf1793e8edcd64681275e598", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daf20b4b83615d61bf1793e8edcd64681275e598"}], "stats": {"total": 109, "additions": 109, "deletions": 0}, "files": [{"sha": "95b534e1a70dc13ed0e7ba927fd29b31ff6cd5b6", "filename": "gcc/lra-constraints.cc", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57688950b9328cbb4a9c21eb3199f9132b5119d3/gcc%2Flra-constraints.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57688950b9328cbb4a9c21eb3199f9132b5119d3/gcc%2Flra-constraints.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.cc?ref=57688950b9328cbb4a9c21eb3199f9132b5119d3", "patch": "@@ -110,6 +110,7 @@\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"backend.h\"\n+#include \"hooks.h\"\n #include \"target.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n@@ -5001,6 +5002,96 @@ contains_reloaded_insn_p (int regno)\n   return false;\n }\n \n+/* Try combine secondary memory reload insn FROM for insn TO into TO insn.\n+   FROM should be a load insn (usually a secondary memory reload insn).  Return\n+   TRUE in case of success.  */\n+static bool\n+combine_reload_insn (rtx_insn *from, rtx_insn *to)\n+{\n+  bool ok_p;\n+  rtx_insn *saved_insn;\n+  rtx set, from_reg, to_reg, op;\n+  enum reg_class to_class, from_class;\n+  int n, nop;\n+  signed char changed_nops[MAX_RECOG_OPERANDS + 1];\n+  lra_insn_recog_data_t id = lra_get_insn_recog_data (to);\n+  struct lra_static_insn_data *static_id = id->insn_static_data;\n+  \n+  /* Check conditions for second memory reload and original insn:  */\n+  if ((targetm.secondary_memory_needed\n+       == hook_bool_mode_reg_class_t_reg_class_t_false)\n+      || NEXT_INSN (from) != to || CALL_P (to)\n+      || id->used_insn_alternative == LRA_UNKNOWN_ALT\n+      || (set = single_set (from)) == NULL_RTX)\n+    return false;\n+  from_reg = SET_DEST (set);\n+  to_reg = SET_SRC (set);\n+  /* Ignore optional reloads: */\n+  if (! REG_P (from_reg) || ! REG_P (to_reg)\n+      || bitmap_bit_p (&lra_optional_reload_pseudos, REGNO (from_reg)))\n+    return false;\n+  to_class = lra_get_allocno_class (REGNO (to_reg));\n+  from_class = lra_get_allocno_class (REGNO (from_reg));\n+  /* Check that reload insn is a load:  */\n+  if (to_class != NO_REGS || from_class == NO_REGS)\n+    return false;\n+  for (n = nop = 0; nop < static_id->n_operands; nop++)\n+    {\n+      if (static_id->operand[nop].type != OP_IN)\n+\tcontinue;\n+      op = *id->operand_loc[nop];\n+      if (!REG_P (op) || REGNO (op) != REGNO (from_reg))\n+\tcontinue;\n+      *id->operand_loc[nop] = to_reg;\n+      changed_nops[n++] = nop;\n+    }\n+  changed_nops[n] = -1;\n+  lra_update_dups (id, changed_nops);\n+  lra_update_insn_regno_info (to);\n+  ok_p = recog_memoized (to) >= 0;\n+  if (ok_p)\n+    {\n+      /* Check that combined insn does not need any reloads: */\n+      saved_insn = curr_insn;\n+      curr_insn = to;\n+      curr_id = lra_get_insn_recog_data (curr_insn);\n+      curr_static_id = curr_id->insn_static_data;\n+      ok_p = !curr_insn_transform (true);\n+      curr_insn = saved_insn;\n+      curr_id = lra_get_insn_recog_data (curr_insn);\n+      curr_static_id = curr_id->insn_static_data;\n+    }\n+  if (ok_p)\n+    {\n+      id->used_insn_alternative = -1;\n+      lra_push_insn_and_update_insn_regno_info (to);\n+      if (lra_dump_file != NULL)\n+\t{\n+\t  fprintf (lra_dump_file, \"    Use combined insn:\\n\");\n+\t  dump_insn_slim (lra_dump_file, to);\n+\t}\n+      return true;\n+    }\n+  if (lra_dump_file != NULL)\n+    {\n+      fprintf (lra_dump_file, \"    Failed combined insn:\\n\");\n+      dump_insn_slim (lra_dump_file, to);\n+    }\n+  for (int i = 0; i < n; i++)\n+    {\n+      nop = changed_nops[i];\n+      *id->operand_loc[nop] = from_reg;\n+    }\n+  lra_update_dups (id, changed_nops);\n+  lra_update_insn_regno_info (to);\n+  if (lra_dump_file != NULL)\n+    {\n+      fprintf (lra_dump_file, \"    Restoring insn after failed combining:\\n\");\n+      dump_insn_slim (lra_dump_file, to);\n+    }\n+  return false;\n+}\n+\n /* Entry function of LRA constraint pass.  Return true if the\n    constraint pass did change the code.\t */\n bool\n@@ -5010,6 +5101,7 @@ lra_constraints (bool first_p)\n   int i, hard_regno, new_insns_num;\n   unsigned int min_len, new_min_len, uid;\n   rtx set, x, reg, dest_reg;\n+  rtx_insn *original_insn;\n   basic_block last_bb;\n   bitmap_iterator bi;\n \n@@ -5119,6 +5211,7 @@ lra_constraints (bool first_p)\n   new_insns_num = 0;\n   last_bb = NULL;\n   changed_p = false;\n+  original_insn = NULL;\n   while ((new_min_len = lra_insn_stack_length ()) != 0)\n     {\n       curr_insn = lra_pop_insn ();\n@@ -5133,7 +5226,12 @@ lra_constraints (bool first_p)\n \t{\n \t  min_len = new_min_len;\n \t  new_insns_num = 0;\n+\t  original_insn = curr_insn;\n \t}\n+      else if (combine_reload_insn (curr_insn, original_insn))\n+\t{\n+\t  continue;\n+        }\n       if (new_insns_num > MAX_RELOAD_INSNS_NUMBER)\n \tinternal_error\n \t  (\"maximum number of generated reload insns per insn achieved (%d)\","}, {"sha": "d4d7f9b05ca2730ff5ebd9a265436996de493fcc", "filename": "gcc/testsuite/gcc.target/i386/pr109052.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57688950b9328cbb4a9c21eb3199f9132b5119d3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr109052.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57688950b9328cbb4a9c21eb3199f9132b5119d3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr109052.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr109052.c?ref=57688950b9328cbb4a9c21eb3199f9132b5119d3", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-O2 -mfpmath=both -msse2\" } */\n+\n+double foo (double a)\n+{\n+  double tmp = a;\n+  asm (\"\" : \"+t\" (tmp));\n+  return a * tmp;\n+}\n+\n+/* { dg-final { scan-assembler-times \"movsd\\t\" 1 } } */"}]}