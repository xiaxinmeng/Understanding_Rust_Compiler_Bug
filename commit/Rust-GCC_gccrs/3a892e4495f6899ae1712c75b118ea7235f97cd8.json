{"sha": "3a892e4495f6899ae1712c75b118ea7235f97cd8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E4OTJlNDQ5NWY2ODk5YWUxNzEyYzc1YjExOGVhNzIzNWY5N2NkOA==", "commit": {"author": {"name": "Andreas Krebbel", "email": "Andreas.Krebbel@de.ibm.com", "date": "2009-11-27T13:12:25Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2009-11-27T13:12:25Z"}, "message": "s390.c (last_scheduled_insn): New variable.\n\n2009-11-27  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n\n\t* config/s390/s390.c (last_scheduled_insn): New variable.\n\t(s390_fpload_toreg, s390_z10_prevent_earlyload_conflicts): New\n\tfunctions.\n\t(s390_sched_reorder, s390_sched_variable_issue): New functions.\n\t(TARGET_SCHED_VARIABLE_ISSUE, TARGET_SCHED_REORDER): Target hooks\n\tdefined.\n\nFrom-SVN: r154705", "tree": {"sha": "e92062393288f7b5967200dc8a12e4ed5747186e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e92062393288f7b5967200dc8a12e4ed5747186e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a892e4495f6899ae1712c75b118ea7235f97cd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a892e4495f6899ae1712c75b118ea7235f97cd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a892e4495f6899ae1712c75b118ea7235f97cd8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a892e4495f6899ae1712c75b118ea7235f97cd8/comments", "author": null, "committer": null, "parents": [{"sha": "d815d34e463182d0112bdf81f38df55eef2ed6de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d815d34e463182d0112bdf81f38df55eef2ed6de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d815d34e463182d0112bdf81f38df55eef2ed6de"}], "stats": {"total": 132, "additions": 131, "deletions": 1}, "files": [{"sha": "be1f203ef08181c4e73b45f6e811e6ee22b1bb62", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a892e4495f6899ae1712c75b118ea7235f97cd8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a892e4495f6899ae1712c75b118ea7235f97cd8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a892e4495f6899ae1712c75b118ea7235f97cd8", "patch": "@@ -1,3 +1,12 @@\n+2009-11-27  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n+\n+\t* config/s390/s390.c (last_scheduled_insn): New variable.\n+\t(s390_fpload_toreg, s390_z10_prevent_earlyload_conflicts): New\n+\tfunctions.\n+\t(s390_sched_reorder, s390_sched_variable_issue): New functions.\n+\t(TARGET_SCHED_VARIABLE_ISSUE, TARGET_SCHED_REORDER): Target hooks\n+\tdefined.\n+\n 2009-11-27  Michael Matz  <matz@suse.de>\n \n \tPR c++/41906"}, {"sha": "40bb24555a810bcf5731466edbbdd427167b8bf7", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 122, "deletions": 1, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a892e4495f6899ae1712c75b118ea7235f97cd8/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a892e4495f6899ae1712c75b118ea7235f97cd8/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=3a892e4495f6899ae1712c75b118ea7235f97cd8", "patch": "@@ -224,6 +224,9 @@ struct processor_costs z10_cost =\n \n extern int reload_completed;\n \n+/* Kept up to date using the SCHED_VARIABLE_ISSUE hook.  */\n+static rtx last_scheduled_insn;\n+\n /* Structure used to hold the components of a S/390 memory\n    address.  A legitimate address on S/390 is of the general\n    form\n@@ -8895,7 +8898,7 @@ s390_trampoline_init (rtx m_tramp, tree fndecl, rtx cxt)\n {\n   rtx fnaddr = XEXP (DECL_RTL (fndecl), 0);\n   rtx mem;\n-  \n+\n   emit_block_move (m_tramp, assemble_trampoline_template (),\n \t\t   GEN_INT (2*UNITS_PER_WORD), BLOCK_OP_NORMAL);\n \n@@ -10038,6 +10041,119 @@ s390_reorg (void)\n     }\n }\n \n+/* Return true if INSN is a fp load insn writing register REGNO.  */\n+static inline bool\n+s390_fpload_toreg (rtx insn, unsigned int regno)\n+{\n+  rtx set;\n+  enum attr_type flag = s390_safe_attr_type (insn);\n+\n+  if (flag != TYPE_FLOADSF && flag != TYPE_FLOADDF)\n+    return false;\n+\n+  set = single_set (insn);\n+\n+  if (set == NULL_RTX)\n+    return false;\n+\n+  if (!REG_P (SET_DEST (set)) || !MEM_P (SET_SRC (set)))\n+    return false;\n+\n+  if (REGNO (SET_DEST (set)) != regno)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* This value describes the distance to be avoided between an\n+   aritmetic fp instruction and an fp load writing the same register.\n+   Z10_EARLYLOAD_DISTANCE - 1 as well as Z10_EARLYLOAD_DISTANCE + 1 is\n+   fine but the exact value has to be avoided. Otherwise the FP\n+   pipeline will throw an exception causing a major penalty.  */\n+#define Z10_EARLYLOAD_DISTANCE 7\n+\n+/* Rearrange the ready list in order to avoid the situation described\n+   for Z10_EARLYLOAD_DISTANCE.  A problematic load instruction is\n+   moved to the very end of the ready list.  */\n+static void\n+s390_z10_prevent_earlyload_conflicts (rtx *ready, int *nready_p)\n+{\n+  unsigned int regno;\n+  int nready = *nready_p;\n+  rtx tmp;\n+  int i;\n+  rtx insn;\n+  rtx set;\n+  enum attr_type flag;\n+  int distance;\n+\n+  /* Skip DISTANCE - 1 active insns.  */\n+  for (insn = last_scheduled_insn, distance = Z10_EARLYLOAD_DISTANCE - 1;\n+       distance > 0 && insn != NULL_RTX;\n+       distance--, insn = prev_active_insn (insn))\n+    if (CALL_P (insn) || JUMP_P (insn))\n+      return;\n+\n+  if (insn == NULL_RTX)\n+    return;\n+\n+  set = single_set (insn);\n+\n+  if (set == NULL_RTX || !REG_P (SET_DEST (set))\n+      || GET_MODE_CLASS (GET_MODE (SET_DEST (set))) != MODE_FLOAT)\n+    return;\n+\n+  flag = s390_safe_attr_type (insn);\n+\n+  if (flag == TYPE_FLOADSF || flag == TYPE_FLOADDF)\n+    return;\n+\n+  regno = REGNO (SET_DEST (set));\n+  i = nready - 1;\n+\n+  while (!s390_fpload_toreg (ready[i], regno) && i > 0)\n+    i--;\n+\n+  if (!i)\n+    return;\n+\n+  tmp = ready[i];\n+  memmove (&ready[1], &ready[0], sizeof (rtx) * i);\n+  ready[0] = tmp;\n+}\n+\n+/* This function is called via hook TARGET_SCHED_REORDER before\n+   issueing one insn from list READY which contains *NREADYP entries.\n+   For target z10 it reorders load instructions to avoid early load\n+   conflicts in the floating point pipeline  */\n+static int\n+s390_sched_reorder (FILE *file ATTRIBUTE_UNUSED, int verbose ATTRIBUTE_UNUSED,\n+\t\t    rtx *ready, int *nreadyp, int clock ATTRIBUTE_UNUSED)\n+{\n+  if (s390_tune == PROCESSOR_2097_Z10)\n+    if (reload_completed && *nreadyp > 1)\n+      s390_z10_prevent_earlyload_conflicts (ready, nreadyp);\n+\n+  return s390_issue_rate ();\n+}\n+\n+/* This function is called via hook TARGET_SCHED_VARIABLE_ISSUE after\n+   the scheduler has issued INSN.  It stores the last issued insn into\n+   last_scheduled_insn in order to make it available for\n+   s390_sched_reorder.  */\n+static int\n+s390_sched_variable_issue (FILE *file ATTRIBUTE_UNUSED,\n+                           int verbose ATTRIBUTE_UNUSED,\n+                         rtx insn, int more)\n+{\n+  last_scheduled_insn = insn;\n+\n+  if (GET_CODE (PATTERN (insn)) != USE\n+      && GET_CODE (PATTERN (insn)) != CLOBBER)\n+    return more - 1;\n+  else\n+    return more;\n+}\n \n /* Initialize GCC target structure.  */\n \n@@ -10095,6 +10211,11 @@ s390_reorg (void)\n #undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD s390_first_cycle_multipass_dfa_lookahead\n \n+#undef TARGET_SCHED_VARIABLE_ISSUE\n+#define TARGET_SCHED_VARIABLE_ISSUE s390_sched_variable_issue\n+#undef TARGET_SCHED_REORDER\n+#define TARGET_SCHED_REORDER s390_sched_reorder\n+\n #undef TARGET_CANNOT_COPY_INSN_P\n #define TARGET_CANNOT_COPY_INSN_P s390_cannot_copy_insn_p\n #undef TARGET_RTX_COSTS"}]}