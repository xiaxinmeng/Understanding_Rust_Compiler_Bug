{"sha": "a1c54ebfb79e62e27a10a1f8170ae9f8a95558bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFjNTRlYmZiNzllNjJlMjdhMTBhMWY4MTcwYWU5ZjhhOTU1NThiZg==", "commit": {"author": {"name": "Matthew Wahab", "email": "matthew.wahab@arm.com", "date": "2015-08-26T13:20:18Z"}, "committer": {"name": "Matthew Wahab", "email": "mwahab@gcc.gnu.org", "date": "2015-08-26T13:20:18Z"}, "message": "arm-builtins.c (def_mbuiltin): Use ARM_FSET macro.\n\n2015-08-26  Matthew Wahab  <matthew.wahab@arm.com>\n\n\t* config/arm/arm-builtins.c (def_mbuiltin): Use ARM_FSET macro.\n\t(struct builtin_description): Change type of mask to unsigned\n\tlong.\n\t* config/arm/arm-protos.h (insn_flags): Declare as type\n\tarm_feature_set.\n\t(tune_flags): Likewise.\n\t* config/arm/arm.c (feature_count): New.\n\t(insn_flags): Define as type arm_feature_set.\n\t(tune_flags): Likewise.\n\t(struct processors): Define field flags as type arm_feature_set.\n\t(all_cores): Update for change to struct processors.\n\t(all_architectures): Likewise.\n\t(arm_option_check_internal): Use arm_feature_set and ARM_FSET\n\tmacros.\n\t(arm_option_override_internal): Likewise.\n\t(arm_option_override): Likewise.\n\nFrom-SVN: r227217", "tree": {"sha": "5497e7112124d203d22eee7758c05a731f069913", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5497e7112124d203d22eee7758c05a731f069913"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1c54ebfb79e62e27a10a1f8170ae9f8a95558bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1c54ebfb79e62e27a10a1f8170ae9f8a95558bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1c54ebfb79e62e27a10a1f8170ae9f8a95558bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1c54ebfb79e62e27a10a1f8170ae9f8a95558bf/comments", "author": null, "committer": null, "parents": [{"sha": "4ecade433a2a578ae25b6eaf7d235bcdb71cee06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ecade433a2a578ae25b6eaf7d235bcdb71cee06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ecade433a2a578ae25b6eaf7d235bcdb71cee06"}], "stats": {"total": 162, "additions": 101, "deletions": 61}, "files": [{"sha": "f017b69ef0482aae8017f7a03147d3046bf7a40f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c54ebfb79e62e27a10a1f8170ae9f8a95558bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c54ebfb79e62e27a10a1f8170ae9f8a95558bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1c54ebfb79e62e27a10a1f8170ae9f8a95558bf", "patch": "@@ -1,3 +1,22 @@\n+2015-08-26  Matthew Wahab  <matthew.wahab@arm.com>\n+\n+\t* config/arm/arm-builtins.c (def_mbuiltin): Use ARM_FSET macro.\n+\t(struct builtin_description): Change type of mask to unsigned\n+\tlong.\n+\t* config/arm/arm-protos.h (insn_flags): Declare as type\n+\tarm_feature_set.\n+\t(tune_flags): Likewise.\n+\t* config/arm/arm.c (feature_count): New.\n+\t(insn_flags): Define as type arm_feature_set.\n+\t(tune_flags): Likewise.\n+\t(struct processors): Define field flags as type arm_feature_set.\n+\t(all_cores): Update for change to struct processors.\n+\t(all_architectures): Likewise.\n+\t(arm_option_check_internal): Use arm_feature_set and ARM_FSET\n+\tmacros.\n+\t(arm_option_override_internal): Likewise.\n+\t(arm_option_override): Likewise.\n+\n 2015-08-26  Marcus Shawcroft  <marcus.shawcroft@arm.com>\n \t    Jiong Wang  <jiong.wang@arm.com>\n "}, {"sha": "7f90416c5a38b78d94bf2a5875b090c1d8b939fa", "filename": "gcc/config/arm/arm-builtins.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c54ebfb79e62e27a10a1f8170ae9f8a95558bf/gcc%2Fconfig%2Farm%2Farm-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c54ebfb79e62e27a10a1f8170ae9f8a95558bf/gcc%2Fconfig%2Farm%2Farm-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-builtins.c?ref=a1c54ebfb79e62e27a10a1f8170ae9f8a95558bf", "patch": "@@ -1101,10 +1101,10 @@ arm_init_neon_builtins (void)\n #undef NUM_DREG_TYPES\n #undef NUM_QREG_TYPES\n \n-#define def_mbuiltin(MASK, NAME, TYPE, CODE)\t\t\t\t\\\n+#define def_mbuiltin(FLAG, NAME, TYPE, CODE)\t\t\t\t\\\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      if ((MASK) & insn_flags)\t\t\t\t\t\t\\\n+      if (ARM_FSET_HAS_CPU1 (insn_flags, (FLAG)))\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t  tree bdecl;\t\t\t\t\t\t\t\\\n \t  bdecl = add_builtin_function ((NAME), (TYPE), (CODE),\t\t\\\n@@ -1116,7 +1116,7 @@ arm_init_neon_builtins (void)\n \n struct builtin_description\n {\n-  const unsigned int       mask;\n+  const unsigned long      mask;\n   const enum insn_code     icode;\n   const char * const       name;\n   const enum arm_builtins  code;"}, {"sha": "8df312f3c6764927f5558f4de00455638d809bbb", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c54ebfb79e62e27a10a1f8170ae9f8a95558bf/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c54ebfb79e62e27a10a1f8170ae9f8a95558bf/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=a1c54ebfb79e62e27a10a1f8170ae9f8a95558bf", "patch": "@@ -521,11 +521,11 @@ typedef struct\n \n /* The bits in this mask specify which\n    instructions we are allowed to generate.  */\n-extern unsigned long insn_flags;\n+extern arm_feature_set insn_flags;\n \n /* The bits in this mask specify which instruction scheduling options should\n    be used.  */\n-extern unsigned long tune_flags;\n+extern arm_feature_set tune_flags;\n \n /* Nonzero if this chip supports the ARM Architecture 3M extensions.  */\n extern int arm_arch3m;"}, {"sha": "df27ce0adc6dcfafa3b1dab0e5f0f71c72e87952", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 77, "deletions": 56, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c54ebfb79e62e27a10a1f8170ae9f8a95558bf/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c54ebfb79e62e27a10a1f8170ae9f8a95558bf/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=a1c54ebfb79e62e27a10a1f8170ae9f8a95558bf", "patch": "@@ -97,6 +97,7 @@ static void arm_add_gc_roots (void);\n static int arm_gen_constant (enum rtx_code, machine_mode, rtx,\n \t\t\t     HOST_WIDE_INT, rtx, rtx, int, int);\n static unsigned bit_count (unsigned long);\n+static unsigned feature_count (const arm_feature_set*);\n static int arm_address_register_rtx_p (rtx, int);\n static int arm_legitimate_index_p (machine_mode, rtx, RTX_CODE, int);\n static bool is_called_in_ARM_mode (tree);\n@@ -767,11 +768,11 @@ static int thumb_call_reg_needed;\n \n /* The bits in this mask specify which\n    instructions we are allowed to generate.  */\n-unsigned long insn_flags = 0;\n+arm_feature_set insn_flags = ARM_FSET_EMPTY;\n \n /* The bits in this mask specify which instruction scheduling options should\n    be used.  */\n-unsigned long tune_flags = 0;\n+arm_feature_set tune_flags = ARM_FSET_EMPTY;\n \n /* The highest ARM architecture version supported by the\n    target.  */\n@@ -927,7 +928,7 @@ struct processors\n   enum processor_type core;\n   const char *arch;\n   enum base_architecture base_arch;\n-  const unsigned long flags;\n+  const arm_feature_set flags;\n   const struct tune_params *const tune;\n };\n \n@@ -2196,10 +2197,10 @@ static const struct processors all_cores[] =\n   /* ARM Cores */\n #define ARM_CORE(NAME, X, IDENT, ARCH, FLAGS, COSTS) \\\n   {NAME, IDENT, #ARCH, BASE_ARCH_##ARCH,\t  \\\n-    FLAGS, &arm_##COSTS##_tune},\n+   ARM_FSET_MAKE_CPU1 (FLAGS), &arm_##COSTS##_tune},\n #include \"arm-cores.def\"\n #undef ARM_CORE\n-  {NULL, arm_none, NULL, BASE_ARCH_0, 0, NULL}\n+  {NULL, arm_none, NULL, BASE_ARCH_0, ARM_FSET_EMPTY, NULL}\n };\n \n static const struct processors all_architectures[] =\n@@ -2209,10 +2210,10 @@ static const struct processors all_architectures[] =\n      from the core.  */\n \n #define ARM_ARCH(NAME, CORE, ARCH, FLAGS) \\\n-  {NAME, CORE, #ARCH, BASE_ARCH_##ARCH, FLAGS, NULL},\n+  {NAME, CORE, #ARCH, BASE_ARCH_##ARCH, ARM_FSET_MAKE_CPU1 (FLAGS), NULL},\n #include \"arm-arches.def\"\n #undef ARM_ARCH\n-  {NULL, arm_none, NULL, BASE_ARCH_0, 0, NULL}\n+  {NULL, arm_none, NULL, BASE_ARCH_0, ARM_FSET_EMPTY, NULL}\n };\n \n \n@@ -2278,6 +2279,14 @@ bit_count (unsigned long value)\n   return count;\n }\n \n+/* Return the number of features in feature-set SET.  */\n+static unsigned\n+feature_count (const arm_feature_set * set)\n+{\n+  return (bit_count (ARM_FSET_CPU1 (*set))\n+\t  + bit_count (ARM_FSET_CPU2 (*set)));\n+}\n+\n typedef struct\n {\n   machine_mode mode;\n@@ -2703,7 +2712,7 @@ arm_option_check_internal (struct gcc_options *opts)\n \n   /* Make sure that the processor choice does not conflict with any of the\n      other command line choices.  */\n-  if (TARGET_ARM_P (flags) && !(insn_flags & FL_NOTM))\n+  if (TARGET_ARM_P (flags) && !ARM_FSET_HAS_CPU1 (insn_flags, FL_NOTM))\n     error (\"target CPU does not support ARM mode\");\n \n   /* TARGET_BACKTRACE calls leaf_function_p, which causes a crash if done\n@@ -2803,7 +2812,8 @@ static void\n arm_option_override_internal (struct gcc_options *opts,\n \t\t\t      struct gcc_options *opts_set)\n {\n-  if (TARGET_THUMB_P (opts->x_target_flags) && !(insn_flags & FL_THUMB))\n+  if (TARGET_THUMB_P (opts->x_target_flags)\n+      && !(ARM_FSET_HAS_CPU1 (insn_flags, FL_THUMB)))\n     {\n       warning (0, \"target CPU does not support THUMB instructions\");\n       opts->x_target_flags &= ~MASK_THUMB;\n@@ -2890,8 +2900,13 @@ arm_option_override (void)\n     {\n       if (arm_selected_cpu)\n \t{\n+\t  const arm_feature_set tuning_flags = ARM_FSET_MAKE_CPU1 (FL_TUNE);\n+\t  arm_feature_set selected_flags;\n+\t  ARM_FSET_XOR (selected_flags, arm_selected_cpu->flags,\n+\t\t\tarm_selected_arch->flags);\n+\t  ARM_FSET_EXCLUDE (selected_flags, selected_flags, tuning_flags);\n \t  /* Check for conflict between mcpu and march.  */\n-\t  if ((arm_selected_cpu->flags ^ arm_selected_arch->flags) & ~FL_TUNE)\n+\t  if (!ARM_FSET_IS_EMPTY (selected_flags))\n \t    {\n \t      warning (0, \"switch -mcpu=%s conflicts with -march=%s switch\",\n \t\t       arm_selected_cpu->name, arm_selected_arch->name);\n@@ -2915,7 +2930,7 @@ arm_option_override (void)\n   if (!arm_selected_cpu)\n     {\n       const struct processors * sel;\n-      unsigned int        sought;\n+      arm_feature_set sought = ARM_FSET_EMPTY;;\n \n       arm_selected_cpu = &all_cores[TARGET_CPU_DEFAULT];\n       if (!arm_selected_cpu->name)\n@@ -2935,26 +2950,27 @@ arm_option_override (void)\n \n       /* Now check to see if the user has specified some command line\n \t switch that require certain abilities from the cpu.  */\n-      sought = 0;\n \n       if (TARGET_INTERWORK || TARGET_THUMB)\n \t{\n-\t  sought |= (FL_THUMB | FL_MODE32);\n+\t  ARM_FSET_ADD_CPU1 (sought, FL_THUMB);\n+\t  ARM_FSET_ADD_CPU1 (sought, FL_MODE32);\n \n \t  /* There are no ARM processors that support both APCS-26 and\n \t     interworking.  Therefore we force FL_MODE26 to be removed\n \t     from insn_flags here (if it was set), so that the search\n \t     below will always be able to find a compatible processor.  */\n-\t  insn_flags &= ~FL_MODE26;\n+\t  ARM_FSET_DEL_CPU1 (insn_flags, FL_MODE26);\n \t}\n \n-      if (sought != 0 && ((sought & insn_flags) != sought))\n+      if (!ARM_FSET_IS_EMPTY (sought)\n+\t  && !(ARM_FSET_CPU_SUBSET (sought, insn_flags)))\n \t{\n \t  /* Try to locate a CPU type that supports all of the abilities\n \t     of the default CPU, plus the extra abilities requested by\n \t     the user.  */\n \t  for (sel = all_cores; sel->name != NULL; sel++)\n-\t    if ((sel->flags & sought) == (sought | insn_flags))\n+\t    if (ARM_FSET_CPU_SUBSET (sought, sel->flags))\n \t      break;\n \n \t  if (sel->name == NULL)\n@@ -2974,19 +2990,23 @@ arm_option_override (void)\n \t\t command line options we scan the array again looking\n \t\t for a best match.  */\n \t      for (sel = all_cores; sel->name != NULL; sel++)\n-\t\tif ((sel->flags & sought) == sought)\n-\t\t  {\n-\t\t    unsigned count;\n-\n-\t\t    count = bit_count (sel->flags & insn_flags);\n-\n-\t\t    if (count >= current_bit_count)\n-\t\t      {\n-\t\t\tbest_fit = sel;\n-\t\t\tcurrent_bit_count = count;\n-\t\t      }\n-\t\t  }\n+\t\t{\n+\t\t  arm_feature_set required = ARM_FSET_EMPTY;\n+\t\t  ARM_FSET_UNION (required, sought, insn_flags);\n+\t\t  if (ARM_FSET_CPU_SUBSET (required, sel->flags))\n+\t\t    {\n+\t\t      unsigned count;\n+\t\t      arm_feature_set flags;\n+\t\t      ARM_FSET_INTER (flags, sel->flags, insn_flags);\n+\t\t      count = feature_count (&flags);\n \n+\t\t      if (count >= current_bit_count)\n+\t\t\t{\n+\t\t\t  best_fit = sel;\n+\t\t\t  current_bit_count = count;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n \t      gcc_assert (best_fit);\n \t      sel = best_fit;\n \t    }\n@@ -3014,7 +3034,8 @@ arm_option_override (void)\n \n   /* BPABI targets use linker tricks to allow interworking on cores\n      without thumb support.  */\n-  if (TARGET_INTERWORK && !((insn_flags & FL_THUMB) || TARGET_BPABI))\n+  if (TARGET_INTERWORK\n+      && !(ARM_FSET_HAS_CPU1 (insn_flags, FL_THUMB) || TARGET_BPABI))\n     {\n       warning (0, \"target CPU does not support interworking\" );\n       target_flags &= ~MASK_INTERWORK;\n@@ -3039,34 +3060,34 @@ arm_option_override (void)\n     warning (0, \"passing floating point arguments in fp regs not yet supported\");\n \n   /* Initialize boolean versions of the flags, for use in the arm.md file.  */\n-  arm_arch3m = (insn_flags & FL_ARCH3M) != 0;\n-  arm_arch4 = (insn_flags & FL_ARCH4) != 0;\n-  arm_arch4t = arm_arch4 & ((insn_flags & FL_THUMB) != 0);\n-  arm_arch5 = (insn_flags & FL_ARCH5) != 0;\n-  arm_arch5e = (insn_flags & FL_ARCH5E) != 0;\n-  arm_arch6 = (insn_flags & FL_ARCH6) != 0;\n-  arm_arch6k = (insn_flags & FL_ARCH6K) != 0;\n-  arm_arch6kz = arm_arch6k && (insn_flags & FL_ARCH6KZ);\n-  arm_arch_notm = (insn_flags & FL_NOTM) != 0;\n+  arm_arch3m = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH3M);\n+  arm_arch4 = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH4);\n+  arm_arch4t = arm_arch4 && (ARM_FSET_HAS_CPU1 (insn_flags, FL_THUMB));\n+  arm_arch5 = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH5);\n+  arm_arch5e = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH5E);\n+  arm_arch6 = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH6);\n+  arm_arch6k = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH6K);\n+  arm_arch6kz = arm_arch6k && ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH6KZ);\n+  arm_arch_notm = ARM_FSET_HAS_CPU1 (insn_flags, FL_NOTM);\n   arm_arch6m = arm_arch6 && !arm_arch_notm;\n-  arm_arch7 = (insn_flags & FL_ARCH7) != 0;\n-  arm_arch7em = (insn_flags & FL_ARCH7EM) != 0;\n-  arm_arch8 = (insn_flags & FL_ARCH8) != 0;\n-  arm_arch_thumb2 = (insn_flags & FL_THUMB2) != 0;\n-  arm_arch_xscale = (insn_flags & FL_XSCALE) != 0;\n-\n-  arm_ld_sched = (tune_flags & FL_LDSCHED) != 0;\n-  arm_tune_strongarm = (tune_flags & FL_STRONG) != 0;\n-  arm_tune_wbuf = (tune_flags & FL_WBUF) != 0;\n-  arm_tune_xscale = (tune_flags & FL_XSCALE) != 0;\n-  arm_arch_iwmmxt = (insn_flags & FL_IWMMXT) != 0;\n-  arm_arch_iwmmxt2 = (insn_flags & FL_IWMMXT2) != 0;\n-  arm_arch_thumb_hwdiv = (insn_flags & FL_THUMB_DIV) != 0;\n-  arm_arch_arm_hwdiv = (insn_flags & FL_ARM_DIV) != 0;\n-  arm_arch_no_volatile_ce = (insn_flags & FL_NO_VOLATILE_CE) != 0;\n+  arm_arch7 = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH7);\n+  arm_arch7em = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH7EM);\n+  arm_arch8 = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH8);\n+  arm_arch_thumb2 = ARM_FSET_HAS_CPU1 (insn_flags, FL_THUMB2);\n+  arm_arch_xscale = ARM_FSET_HAS_CPU1 (insn_flags, FL_XSCALE);\n+\n+  arm_ld_sched = ARM_FSET_HAS_CPU1 (tune_flags, FL_LDSCHED);\n+  arm_tune_strongarm = ARM_FSET_HAS_CPU1 (tune_flags, FL_STRONG);\n+  arm_tune_wbuf = ARM_FSET_HAS_CPU1 (tune_flags, FL_WBUF);\n+  arm_tune_xscale = ARM_FSET_HAS_CPU1 (tune_flags, FL_XSCALE);\n+  arm_arch_iwmmxt = ARM_FSET_HAS_CPU1 (insn_flags, FL_IWMMXT);\n+  arm_arch_iwmmxt2 = ARM_FSET_HAS_CPU1 (insn_flags, FL_IWMMXT2);\n+  arm_arch_thumb_hwdiv = ARM_FSET_HAS_CPU1 (insn_flags, FL_THUMB_DIV);\n+  arm_arch_arm_hwdiv = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARM_DIV);\n+  arm_arch_no_volatile_ce = ARM_FSET_HAS_CPU1 (insn_flags, FL_NO_VOLATILE_CE);\n   arm_tune_cortex_a9 = (arm_tune == cortexa9) != 0;\n-  arm_arch_crc = (insn_flags & FL_CRC32) != 0;\n-  arm_m_profile_small_mul = (insn_flags & FL_SMALLMUL) != 0;\n+  arm_arch_crc = ARM_FSET_HAS_CPU1 (insn_flags, FL_CRC32);\n+  arm_m_profile_small_mul = ARM_FSET_HAS_CPU1 (insn_flags, FL_SMALLMUL);\n \n   /* V5 code we generate is completely interworking capable, so we turn off\n      TARGET_INTERWORK here to avoid many tests later on.  */\n@@ -3158,7 +3179,7 @@ arm_option_override (void)\n \n   /* For arm2/3 there is no need to do any scheduling if we are doing\n      software floating-point.  */\n-  if (TARGET_SOFT_FLOAT && (tune_flags & FL_MODE32) == 0)\n+  if (TARGET_SOFT_FLOAT && !ARM_FSET_HAS_CPU1 (tune_flags, FL_MODE32))\n     flag_schedule_insns = flag_schedule_insns_after_reload = 0;\n \n   /* Use the cp15 method if it is available.  */"}]}