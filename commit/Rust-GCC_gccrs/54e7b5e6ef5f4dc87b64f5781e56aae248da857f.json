{"sha": "54e7b5e6ef5f4dc87b64f5781e56aae248da857f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTRlN2I1ZTZlZjVmNGRjODdiNjRmNTc4MWU1NmFhZTI0OGRhODU3Zg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-04T20:37:02Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-04T20:37:02Z"}, "message": "(emit_no_conflict_block): Don't move target to itself if that takes multiple insns.\n\n(emit_no_conflict_block): Don't move target to itself\nif that takes multiple insns.\n(expand_binop): For complex mult and div, avoid fetching operand\ncomponents more than once from memory.\n\nFrom-SVN: r3647", "tree": {"sha": "d2dc58d8eabd78accc4928c18160187cdada96ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2dc58d8eabd78accc4928c18160187cdada96ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54e7b5e6ef5f4dc87b64f5781e56aae248da857f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54e7b5e6ef5f4dc87b64f5781e56aae248da857f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54e7b5e6ef5f4dc87b64f5781e56aae248da857f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54e7b5e6ef5f4dc87b64f5781e56aae248da857f/comments", "author": null, "committer": null, "parents": [{"sha": "b6a10c9fe17597c7870f182aa505e7bf77aab429", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6a10c9fe17597c7870f182aa505e7bf77aab429", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6a10c9fe17597c7870f182aa505e7bf77aab429"}], "stats": {"total": 51, "additions": 39, "deletions": 12}, "files": [{"sha": "65a56cdca932910a28245d2b576c0b2bb5a518ce", "filename": "gcc/optabs.c", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54e7b5e6ef5f4dc87b64f5781e56aae248da857f/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54e7b5e6ef5f4dc87b64f5781e56aae248da857f/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=54e7b5e6ef5f4dc87b64f5781e56aae248da857f", "patch": "@@ -916,16 +916,21 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n \t  if (imag0 && imag1)\n \t    {\n-\t      rtx temp =\n-\t\texpand_binop (submode, sub_optab,\n-\t\t\t      expand_binop (submode, binoptab, real0,\n-\t\t\t\t\t    real1, 0, unsignedp, methods),\n-\t\t\t      expand_binop (submode, binoptab, imag0,\n-\t\t\t\t\t    imag1, 0, unsignedp, methods),\n-\t\t\t      realr, unsignedp, methods);\n+\t      /* Don't fetch these from memory more than once.  */\n+\t      real0 = force_reg (submode, real0);\n+\t      real1 = force_reg (submode, real1);\n+\t      imag0 = force_reg (submode, imag0);\n+\t      imag1 = force_reg (submode, imag1);\n+\n+\t      res = expand_binop (submode, sub_optab,\n+\t\t\t\t  expand_binop (submode, binoptab, real0,\n+\t\t\t\t\t\treal1, 0, unsignedp, methods),\n+\t\t\t\t  expand_binop (submode, binoptab, imag0,\n+\t\t\t\t\t\timag1, 0, unsignedp, methods),\n+\t\t\t\t  realr, unsignedp, methods);\n \n-\t      if (temp != realr)\n-\t\temit_move_insn (realr, temp);\n+\t      if (res != realr)\n+\t\temit_move_insn (realr, res);\n \n \t      res = expand_binop (submode, add_optab,\n \t\t\t\t  expand_binop (submode, binoptab,\n@@ -940,6 +945,10 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t    }\n \t  else\n \t    {\n+\t      /* Don't fetch these from memory more than once.  */\n+\t      real0 = force_reg (submode, real0);\n+\t      real1 = force_reg (submode, real1);\n+\n \t      res = expand_binop (submode, binoptab, real0, real1,\n \t\t\t\t  realr, unsignedp, methods);\n \t      if (res != realr)\n@@ -961,6 +970,10 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t  \n \t  if (! imag1)\n \t    {\t/* (a+ib) / (c+i0) = (a/c) + i(b/c) */\n+\n+\t      /* Don't fetch these from memory more than once.  */\n+\t      real1 = force_reg (submode, real1);\n+\n \t      /* Simply divide the real and imaginary parts by `c' */\n \t      res = expand_binop (submode, binoptab, real0, real1,\n \t\t\t\t  realr, unsignedp, methods);\n@@ -981,6 +994,13 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t      \n \t      optab mulopt = unsignedp ? umul_widen_optab : smul_optab;\n \n+\t      /* Don't fetch these from memory more than once.  */\n+\t      real0 = force_reg (submode, real0);\n+\t      real1 = force_reg (submode, real1);\n+\t      if (imag0)\n+\t\timag0 = force_reg (submode, imag0);\n+\t      imag1 = force_reg (submode, imag1);\n+\n \t      /* Divisor: c*c + d*d */\n \t      divisor = expand_binop (submode, add_optab,\n \t\t\t\t      expand_binop (submode, mulopt,\n@@ -1984,9 +2004,16 @@ emit_no_conflict_block (insns, target, op0, op1, equiv)\n \t\t\t\t    REG_NOTES (insn));\n     }\n \n-  last = emit_move_insn (target, target);\n-  if (equiv)\n-    REG_NOTES (last) = gen_rtx (EXPR_LIST, REG_EQUAL, equiv, REG_NOTES (last));\n+  if (mov_optab->handlers[(int) GET_MODE (target)].insn_code\n+      != CODE_FOR_nothing)\n+    {\n+      last = emit_move_insn (target, target);\n+      if (equiv)\n+\tREG_NOTES (last)\n+\t  = gen_rtx (EXPR_LIST, REG_EQUAL, equiv, REG_NOTES (last));\n+    }\n+  else\n+    last = get_last_insn ();\n \n   if (prev == 0)\n     first = get_insns ();"}]}