{"sha": "31a0c8251b9fb551d9979988e5e63df8bcc1d65f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFhMGM4MjUxYjlmYjU1MWQ5OTc5OTg4ZTVlNjNkZjhiY2MxZDY1Zg==", "commit": {"author": {"name": "Dmitry Plotnikov", "email": "dplotnikov@ispras.ru", "date": "2011-06-22T11:57:52Z"}, "committer": {"name": "Alexander Monakov", "email": "amonakov@gcc.gnu.org", "date": "2011-06-22T11:57:52Z"}, "message": "arm.c (neon_immediate_valid_for_shift): New function.\n\n2011-06-22  Dmitry Plotnikov  <dplotnikov@ispras.ru>\n\tDmitry Melnik  <dm@ispras.ru>\n\n\t* config/arm/arm.c (neon_immediate_valid_for_shift): New function.\n\t(neon_output_shift_immediate): Ditto.\n\t* config/arm/arm-protos.h (neon_immediate_valid_for_shift): New\n\tprototype.\n\t(neon_output_shift_immediate): Ditto.\n\t* config/arm/neon.md (vashl<mode>3): Modified constraint.\n\t(vashr<mode>3_imm): New insn pattern.\n\t(vlshr<mode>3_imm): Ditto.\n\t(vashr<mode>3): Modified constraint.\n\t(vlshr<mode>3): Ditto.\n\t* config/arm/predicates.md (imm_for_neon_lshift_operand): New\n\tpredicate.\n\t(imm_for_neon_rshift_operand): Ditto.\n\t(imm_lshift_or_reg_neon): Ditto.\n\t(imm_rshift_or_reg_neon): Ditto.\n\n\t* optabs.c (init_optabs): Init optab codes for vashl, vashr, vlshr.\n\ntestsuite:\n\n\t* gcc.target/arm/neon-vshr-imm-1.c: New testcase.\n\t* gcc.target/arm/neon-vshl-imm-1.c: New testcase.\n\t* gcc.target/arm/neon-vlshr-imm-1.c: New testcase.\n\n\nCo-Authored-By: Dmitry Melnik <dm@ispras.ru>\n\nFrom-SVN: r175293", "tree": {"sha": "377aee52f4ebe050c91bd7309e7509eaf305f3ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/377aee52f4ebe050c91bd7309e7509eaf305f3ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31a0c8251b9fb551d9979988e5e63df8bcc1d65f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31a0c8251b9fb551d9979988e5e63df8bcc1d65f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31a0c8251b9fb551d9979988e5e63df8bcc1d65f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31a0c8251b9fb551d9979988e5e63df8bcc1d65f/comments", "author": null, "committer": null, "parents": [{"sha": "1da9434b4ba81839aa43dfb53344a6dbfb0e314f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1da9434b4ba81839aa43dfb53344a6dbfb0e314f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1da9434b4ba81839aa43dfb53344a6dbfb0e314f"}], "stats": {"total": 244, "additions": 231, "deletions": 13}, "files": [{"sha": "9a075199c5e558f6f715d2598d057d9c4e6f922f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31a0c8251b9fb551d9979988e5e63df8bcc1d65f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31a0c8251b9fb551d9979988e5e63df8bcc1d65f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=31a0c8251b9fb551d9979988e5e63df8bcc1d65f", "patch": "@@ -1,3 +1,24 @@\n+2011-06-22  Dmitry Plotnikov  <dplotnikov@ispras.ru>\n+\tDmitry Melnik  <dm@ispras.ru>\n+\n+\t* config/arm/arm.c (neon_immediate_valid_for_shift): New function.\n+\t(neon_output_shift_immediate): Ditto.\n+\t* config/arm/arm-protos.h (neon_immediate_valid_for_shift): New\n+\tprototype.\n+\t(neon_output_shift_immediate): Ditto.\n+\t* config/arm/neon.md (vashl<mode>3): Modified constraint.\n+\t(vashr<mode>3_imm): New insn pattern.\n+\t(vlshr<mode>3_imm): Ditto.\n+\t(vashr<mode>3): Modified constraint.\n+\t(vlshr<mode>3): Ditto.\n+\t* config/arm/predicates.md (imm_for_neon_lshift_operand): New\n+\tpredicate.\n+\t(imm_for_neon_rshift_operand): Ditto.\n+\t(imm_lshift_or_reg_neon): Ditto.\n+\t(imm_rshift_or_reg_neon): Ditto.\n+\n+\t* optabs.c (init_optabs): Init optab codes for vashl, vashr, vlshr.\n+\n 2011-06-22  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree-ssa-ccp.c (evaluate_stmt): Try bitwise tracking for"}, {"sha": "3eb21778123bd4f1827caf55bcda690b055d6647", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31a0c8251b9fb551d9979988e5e63df8bcc1d65f/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31a0c8251b9fb551d9979988e5e63df8bcc1d65f/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=31a0c8251b9fb551d9979988e5e63df8bcc1d65f", "patch": "@@ -66,8 +66,12 @@ extern int vfp3_const_double_rtx (rtx);\n extern int neon_immediate_valid_for_move (rtx, enum machine_mode, rtx *, int *);\n extern int neon_immediate_valid_for_logic (rtx, enum machine_mode, int, rtx *,\n \t\t\t\t\t   int *);\n+extern int neon_immediate_valid_for_shift (rtx, enum machine_mode, rtx *,\n+\t\t\t\t\t   int *, bool);\n extern char *neon_output_logic_immediate (const char *, rtx *,\n \t\t\t\t\t  enum machine_mode, int, int);\n+extern char *neon_output_shift_immediate (const char *, char, rtx *,\n+\t\t\t\t\t  enum machine_mode, int, bool);\n extern void neon_pairwise_reduce (rtx, rtx, enum machine_mode,\n \t\t\t\t  rtx (*) (rtx, rtx, rtx));\n extern rtx neon_make_constant (rtx);"}, {"sha": "efffcf814057a24cee7127eec589921be6781ca5", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31a0c8251b9fb551d9979988e5e63df8bcc1d65f/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31a0c8251b9fb551d9979988e5e63df8bcc1d65f/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=31a0c8251b9fb551d9979988e5e63df8bcc1d65f", "patch": "@@ -8608,6 +8608,66 @@ neon_immediate_valid_for_logic (rtx op, enum machine_mode mode, int inverse,\n   return 1;\n }\n \n+/* Return TRUE if rtx OP is legal for use in a VSHR or VSHL instruction.  If\n+   the immediate is valid, write a constant suitable for using as an operand\n+   to VSHR/VSHL to *MODCONST and the corresponding element width to\n+   *ELEMENTWIDTH. ISLEFTSHIFT is for determine left or right shift,\n+   because they have different limitations.  */\n+\n+int\n+neon_immediate_valid_for_shift (rtx op, enum machine_mode mode,\n+\t\t\t\trtx *modconst, int *elementwidth,\n+\t\t\t\tbool isleftshift)\n+{\n+  unsigned int innersize = GET_MODE_SIZE (GET_MODE_INNER (mode));\n+  unsigned int n_elts = CONST_VECTOR_NUNITS (op), i;\n+  unsigned HOST_WIDE_INT last_elt = 0;\n+  unsigned HOST_WIDE_INT maxshift;\n+\n+  /* Split vector constant out into a byte vector.  */\n+  for (i = 0; i < n_elts; i++)\n+    {\n+      rtx el = CONST_VECTOR_ELT (op, i);\n+      unsigned HOST_WIDE_INT elpart;\n+\n+      if (GET_CODE (el) == CONST_INT)\n+        elpart = INTVAL (el);\n+      else if (GET_CODE (el) == CONST_DOUBLE)\n+        return 0;\n+      else\n+        gcc_unreachable ();\n+\n+      if (i != 0 && elpart != last_elt)\n+        return 0;\n+\n+      last_elt = elpart;\n+    }\n+\n+  /* Shift less than element size.  */\n+  maxshift = innersize * 8;\n+\n+  if (isleftshift)\n+    {\n+      /* Left shift immediate value can be from 0 to <size>-1.  */\n+      if (last_elt >= maxshift)\n+        return 0;\n+    }\n+  else\n+    {\n+      /* Right shift immediate value can be from 1 to <size>.  */\n+      if (last_elt == 0 || last_elt > maxshift)\n+\treturn 0;\n+    }\n+\n+  if (elementwidth)\n+    *elementwidth = innersize * 8;\n+\n+  if (modconst)\n+    *modconst = CONST_VECTOR_ELT (op, 0);\n+\n+  return 1;\n+}\n+\n /* Return a string suitable for output of Neon immediate logic operation\n    MNEM.  */\n \n@@ -8630,6 +8690,28 @@ neon_output_logic_immediate (const char *mnem, rtx *op2, enum machine_mode mode,\n   return templ;\n }\n \n+/* Return a string suitable for output of Neon immediate shift operation\n+   (VSHR or VSHL) MNEM.  */\n+\n+char *\n+neon_output_shift_immediate (const char *mnem, char sign, rtx *op2,\n+\t\t\t     enum machine_mode mode, int quad,\n+\t\t\t     bool isleftshift)\n+{\n+  int width, is_valid;\n+  static char templ[40];\n+\n+  is_valid = neon_immediate_valid_for_shift (*op2, mode, op2, &width, isleftshift);\n+  gcc_assert (is_valid != 0);\n+\n+  if (quad)\n+    sprintf (templ, \"%s.%c%d\\t%%q0, %%q1, %%2\", mnem, sign, width);\n+  else\n+    sprintf (templ, \"%s.%c%d\\t%%P0, %%P1, %%2\", mnem, sign, width);\n+\n+  return templ;\n+}\n+\n /* Output a sequence of pairwise operations to implement a reduction.\n    NOTE: We do \"too much work\" here, because pairwise operations work on two\n    registers-worth of operands in one go. Unfortunately we can't exploit those"}, {"sha": "2c109e09ac6c22a35a3972d0c0f081a00123c794", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 61, "deletions": 13, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31a0c8251b9fb551d9979988e5e63df8bcc1d65f/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31a0c8251b9fb551d9979988e5e63df8bcc1d65f/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=31a0c8251b9fb551d9979988e5e63df8bcc1d65f", "patch": "@@ -969,17 +969,59 @@\n ; SImode elements.\n \n (define_insn \"vashl<mode>3\"\n+  [(set (match_operand:VDQIW 0 \"s_register_operand\" \"=w,w\")\n+\t(ashift:VDQIW (match_operand:VDQIW 1 \"s_register_operand\" \"w,w\")\n+\t\t      (match_operand:VDQIW 2 \"imm_lshift_or_reg_neon\" \"w,Dn\")))]\n+  \"TARGET_NEON\"\n+  {\n+    switch (which_alternative)\n+      {\n+        case 0: return \"vshl.<V_s_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\";\n+        case 1: return neon_output_shift_immediate (\"vshl\", 'i', &operands[2],\n+                         \t\t\t    <MODE>mode,\n+\t\t\t\t\t\t    VALID_NEON_QREG_MODE (<MODE>mode),\n+\t\t\t\t\t\t    true);\n+        default: gcc_unreachable ();\n+      }\n+  }\n+  [(set (attr \"neon_type\")\n+      (if_then_else (ne (symbol_ref \"<Is_d_reg>\") (const_int 0))\n+                    (const_string \"neon_vshl_ddd\")\n+                    (const_string \"neon_shift_3\")))]\n+)\n+\n+(define_insn \"vashr<mode>3_imm\"\n   [(set (match_operand:VDQIW 0 \"s_register_operand\" \"=w\")\n-\t(ashift:VDQIW (match_operand:VDQIW 1 \"s_register_operand\" \"w\")\n-\t\t      (match_operand:VDQIW 2 \"s_register_operand\" \"w\")))]\n+\t(ashiftrt:VDQIW (match_operand:VDQIW 1 \"s_register_operand\" \"w\")\n+\t\t\t(match_operand:VDQIW 2 \"imm_for_neon_rshift_operand\" \"Dn\")))]\n   \"TARGET_NEON\"\n-  \"vshl.<V_s_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n+  {\n+    return neon_output_shift_immediate (\"vshr\", 's', &operands[2],\n+\t\t\t\t\t<MODE>mode, VALID_NEON_QREG_MODE (<MODE>mode),\n+\t\t\t\t\tfalse);\n+  }\n   [(set (attr \"neon_type\")\n       (if_then_else (ne (symbol_ref \"<Is_d_reg>\") (const_int 0))\n                     (const_string \"neon_vshl_ddd\")\n                     (const_string \"neon_shift_3\")))]\n )\n \n+(define_insn \"vlshr<mode>3_imm\"\n+  [(set (match_operand:VDQIW 0 \"s_register_operand\" \"=w\")\n+\t(lshiftrt:VDQIW (match_operand:VDQIW 1 \"s_register_operand\" \"w\")\n+\t\t\t(match_operand:VDQIW 2 \"imm_for_neon_rshift_operand\" \"Dn\")))]\n+  \"TARGET_NEON\"\n+  {\n+    return neon_output_shift_immediate (\"vshr\", 'u', &operands[2],\n+\t\t\t\t\t<MODE>mode, VALID_NEON_QREG_MODE (<MODE>mode),\n+\t\t\t\t\tfalse);\n+  }              \n+  [(set (attr \"neon_type\")\n+\t(if_then_else (ne (symbol_ref \"<Is_d_reg>\") (const_int 0))\n+\t\t      (const_string \"neon_vshl_ddd\")\n+\t\t      (const_string \"neon_shift_3\")))]\n+)\n+\n ; Used for implementing logical shift-right, which is a left-shift by a negative\n ; amount, with signed operands. This is essentially the same as ashl<mode>3\n ; above, but using an unspec in case GCC tries anything tricky with negative\n@@ -1017,28 +1059,34 @@\n (define_expand \"vashr<mode>3\"\n   [(set (match_operand:VDQIW 0 \"s_register_operand\" \"\")\n \t(ashiftrt:VDQIW (match_operand:VDQIW 1 \"s_register_operand\" \"\")\n-\t\t\t(match_operand:VDQIW 2 \"s_register_operand\" \"\")))]\n+\t\t\t(match_operand:VDQIW 2 \"imm_rshift_or_reg_neon\" \"\")))]\n   \"TARGET_NEON\"\n {\n   rtx neg = gen_reg_rtx (<MODE>mode);\n-\n-  emit_insn (gen_neg<mode>2 (neg, operands[2]));\n-  emit_insn (gen_ashl<mode>3_signed (operands[0], operands[1], neg));\n-\n+  if (REG_P (operands[2]))\n+    {\n+      emit_insn (gen_neg<mode>2 (neg, operands[2]));\n+      emit_insn (gen_ashl<mode>3_signed (operands[0], operands[1], neg));\n+    }\n+  else\n+    emit_insn (gen_vashr<mode>3_imm (operands[0], operands[1], operands[2]));\n   DONE;\n })\n \n (define_expand \"vlshr<mode>3\"\n   [(set (match_operand:VDQIW 0 \"s_register_operand\" \"\")\n \t(lshiftrt:VDQIW (match_operand:VDQIW 1 \"s_register_operand\" \"\")\n-\t\t\t(match_operand:VDQIW 2 \"s_register_operand\" \"\")))]\n+\t\t\t(match_operand:VDQIW 2 \"imm_rshift_or_reg_neon\" \"\")))]\n   \"TARGET_NEON\"\n {\n   rtx neg = gen_reg_rtx (<MODE>mode);\n-\n-  emit_insn (gen_neg<mode>2 (neg, operands[2]));\n-  emit_insn (gen_ashl<mode>3_unsigned (operands[0], operands[1], neg));\n-\n+  if (REG_P (operands[2]))\n+    {\n+      emit_insn (gen_neg<mode>2 (neg, operands[2]));\n+      emit_insn (gen_ashl<mode>3_unsigned (operands[0], operands[1], neg));\n+    }\n+  else\n+    emit_insn (gen_vlshr<mode>3_imm (operands[0], operands[1], operands[2]));\n   DONE;\n })\n "}, {"sha": "ec5de6921e7577725edc440bef268c2d1f895a65", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31a0c8251b9fb551d9979988e5e63df8bcc1d65f/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31a0c8251b9fb551d9979988e5e63df8bcc1d65f/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=31a0c8251b9fb551d9979988e5e63df8bcc1d65f", "patch": "@@ -585,6 +585,26 @@\n   return neon_immediate_valid_for_move (op, mode, NULL, NULL);\n })\n \n+(define_predicate \"imm_for_neon_lshift_operand\"\n+  (match_code \"const_vector\")\n+{\n+  return neon_immediate_valid_for_shift (op, mode, NULL, NULL, true);\n+})\n+\n+(define_predicate \"imm_for_neon_rshift_operand\"\n+  (match_code \"const_vector\")\n+{\n+  return neon_immediate_valid_for_shift (op, mode, NULL, NULL, false);\n+})\n+\n+(define_predicate \"imm_lshift_or_reg_neon\"\n+  (ior (match_operand 0 \"s_register_operand\")\n+       (match_operand 0 \"imm_for_neon_lshift_operand\")))\n+\n+(define_predicate \"imm_rshift_or_reg_neon\"\n+  (ior (match_operand 0 \"s_register_operand\")\n+       (match_operand 0 \"imm_for_neon_rshift_operand\")))\n+\n (define_predicate \"imm_for_neon_logic_operand\"\n   (match_code \"const_vector\")\n {"}, {"sha": "bf15ab4fbc6e9e2bb1b04272d519001d519d5cd9", "filename": "gcc/optabs.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31a0c8251b9fb551d9979988e5e63df8bcc1d65f/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31a0c8251b9fb551d9979988e5e63df8bcc1d65f/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=31a0c8251b9fb551d9979988e5e63df8bcc1d65f", "patch": "@@ -5925,6 +5925,9 @@ init_optabs (void)\n   init_optab (usashl_optab, US_ASHIFT);\n   init_optab (ashr_optab, ASHIFTRT);\n   init_optab (lshr_optab, LSHIFTRT);\n+  init_optabv (vashl_optab, ASHIFT);\n+  init_optabv (vashr_optab, ASHIFTRT);\n+  init_optabv (vlshr_optab, LSHIFTRT);\n   init_optab (rotl_optab, ROTATE);\n   init_optab (rotr_optab, ROTATERT);\n   init_optab (smin_optab, SMIN);"}, {"sha": "75796207b6a2d22d978a8cd625bad792b789748e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31a0c8251b9fb551d9979988e5e63df8bcc1d65f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31a0c8251b9fb551d9979988e5e63df8bcc1d65f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=31a0c8251b9fb551d9979988e5e63df8bcc1d65f", "patch": "@@ -1,3 +1,10 @@\n+2011-06-22  Dmitry Plotnikov  <dplotnikov@ispras.ru>\n+\tDmitry Melnik  <dm@ispras.ru>\n+\n+\t* gcc.target/arm/neon-vshr-imm-1.c: New testcase.\n+\t* gcc.target/arm/neon-vshl-imm-1.c: New testcase.\n+\t* gcc.target/arm/neon-vlshr-imm-1.c: New testcase.\n+\n 2011-06-22  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.dg/torture/tls/run-le.c: Skip for -pie on alpha*-*-linux*."}, {"sha": "e6663716804b6cbb7cb9c6c7db7308fc3a449767", "filename": "gcc/testsuite/gcc.target/arm/neon-vlshr-imm-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31a0c8251b9fb551d9979988e5e63df8bcc1d65f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vlshr-imm-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31a0c8251b9fb551d9979988e5e63df8bcc1d65f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vlshr-imm-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vlshr-imm-1.c?ref=31a0c8251b9fb551d9979988e5e63df8bcc1d65f", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-O2 -mfpu=neon -mfloat-abi=softfp -ftree-vectorize\" } */\n+/* { dg-final { scan-assembler \"vshr\\.u32.*#3\" } } */\n+\n+/* Verify that VSHR immediate is used.  */\n+void f1(int n, unsigned int x[], unsigned int y[]) {\n+  int i;\n+  for (i = 0; i < n; ++i)\n+    y[i] = x[i] >> 3;\n+}"}, {"sha": "913d5959bedf3464485914719cc89defe4b2af40", "filename": "gcc/testsuite/gcc.target/arm/neon-vshl-imm-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31a0c8251b9fb551d9979988e5e63df8bcc1d65f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vshl-imm-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31a0c8251b9fb551d9979988e5e63df8bcc1d65f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vshl-imm-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vshl-imm-1.c?ref=31a0c8251b9fb551d9979988e5e63df8bcc1d65f", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-O2 -mfpu=neon -mfloat-abi=softfp -ftree-vectorize\" } */\n+/* { dg-final { scan-assembler \"vshl\\.i32.*#3\" } } */\n+\n+/* Verify that VSHR immediate is used.  */\n+void f1(int n, int x[], int y[]) {\n+  int i;\n+  for (i = 0; i < n; ++i)\n+    y[i] = x[i] << 3;\n+}"}, {"sha": "82a3c5cfb24fd4958c84d3f2223d8ea0620d0743", "filename": "gcc/testsuite/gcc.target/arm/neon-vshr-imm-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31a0c8251b9fb551d9979988e5e63df8bcc1d65f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vshr-imm-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31a0c8251b9fb551d9979988e5e63df8bcc1d65f/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vshr-imm-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vshr-imm-1.c?ref=31a0c8251b9fb551d9979988e5e63df8bcc1d65f", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-O2 -mfpu=neon -mfloat-abi=softfp -ftree-vectorize\" } */\n+/* { dg-final { scan-assembler \"vshr\\.s32.*#3\" } } */\n+\n+/* Verify that VSHR immediate is used.  */\n+void f1(int n, int x[], int y[]) {\n+  int i;\n+  for (i = 0; i < n; ++i)\n+    y[i] = x[i] >> 3;\n+}"}]}