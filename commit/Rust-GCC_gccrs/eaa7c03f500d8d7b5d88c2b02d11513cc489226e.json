{"sha": "eaa7c03f500d8d7b5d88c2b02d11513cc489226e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFhN2MwM2Y1MDBkOGQ3YjVkODhjMmIwMmQxMTUxM2NjNDg5MjI2ZQ==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2001-01-04T23:53:54Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2001-01-04T23:53:54Z"}, "message": "c-common.c (SIZE_TYPE, WCHAR_TYPE): Define.\n\n\t* c-common.c (SIZE_TYPE, WCHAR_TYPE): Define.\n\t(flag_short_double, flag_short_wchar): Define.\n\t(c_common_nodes_and_builtins): Create many tree nodes shared\n\tbetween C and C++ here instead of in cp/decl.c and ...\n\t* c-decl.c (init_decl_processing): ... here.\n\t(SIZE_TYPE, WCHAR_TYPE): Don't define.\n\t(flag_short_double, flag_short_wchar): Don't define.\n\t(record_builtin_type): New function.\n\t(build_void_list_node): New function.\n\t* c-common.h (flag_short_double, flag_short_wchar,\n\trecord_builtin_type, build_void_list_node): Declare.\n\ncp:\n\t* decl.c (SIZE_TYPE, PTRDIFF_TYPE, WCHAR_TYPE): Don't define.\n\t(record_builtin_type): Make non-static.\n\t(flag_short_double): Don't declare.\n\t(init_decl_processing): Remove the creation of many tree nodes now\n\tin c_common_nodes_and_builtins.\n\t(build_void_list_node): New function.\n\t* decl2.c (flag_short_double, flag_short_wchar): Don't define.\n\t* cp-tree.h (flag_short_wchar): Don't declare.\n\nFrom-SVN: r38695", "tree": {"sha": "d40c8e23aa4989def74861335c33e8a8a73520fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d40c8e23aa4989def74861335c33e8a8a73520fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eaa7c03f500d8d7b5d88c2b02d11513cc489226e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaa7c03f500d8d7b5d88c2b02d11513cc489226e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaa7c03f500d8d7b5d88c2b02d11513cc489226e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaa7c03f500d8d7b5d88c2b02d11513cc489226e/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2a5f96bbfae7b9b30d76246c1cd58fe80dddd2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2a5f96bbfae7b9b30d76246c1cd58fe80dddd2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2a5f96bbfae7b9b30d76246c1cd58fe80dddd2c"}], "stats": {"total": 529, "additions": 234, "deletions": 295}, "files": [{"sha": "0bf3db3e750443922fa8dda18a896de448def040", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa7c03f500d8d7b5d88c2b02d11513cc489226e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa7c03f500d8d7b5d88c2b02d11513cc489226e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eaa7c03f500d8d7b5d88c2b02d11513cc489226e", "patch": "@@ -1,3 +1,17 @@\n+2001-01-04  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* c-common.c (SIZE_TYPE, WCHAR_TYPE): Define.\n+\t(flag_short_double, flag_short_wchar): Define.\n+\t(c_common_nodes_and_builtins): Create many tree nodes shared\n+\tbetween C and C++ here instead of in cp/decl.c and ...\n+\t* c-decl.c (init_decl_processing): ... here.\n+\t(SIZE_TYPE, WCHAR_TYPE): Don't define.\n+\t(flag_short_double, flag_short_wchar): Don't define.\n+\t(record_builtin_type): New function.\n+\t(build_void_list_node): New function.\n+\t* c-common.h (flag_short_double, flag_short_wchar,\n+\trecord_builtin_type, build_void_list_node): Declare.\n+\n Thu Jan  4 21:09:47 2001  J\"orn Rennecke <amylaar@redhat.com>\n \n \t* integrate.c (expand_inline_function): Don't put a virtual"}, {"sha": "577aa20c776a92d3e8b96537448fe7c3aa5fac5b", "filename": "gcc/c-common.c", "status": "modified", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa7c03f500d8d7b5d88c2b02d11513cc489226e/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa7c03f500d8d7b5d88c2b02d11513cc489226e/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=eaa7c03f500d8d7b5d88c2b02d11513cc489226e", "patch": "@@ -41,6 +41,20 @@ cpp_reader *parse_in;\t\t/* Declared in c-lex.h.  */\n #undef WCHAR_TYPE_SIZE\n #define WCHAR_TYPE_SIZE TYPE_PRECISION (wchar_type_node)\n \n+/* We let tm.h override the types used here, to handle trivial differences\n+   such as the choice of unsigned int or long unsigned int for size_t.\n+   When machines start needing nontrivial differences in the size type,\n+   it would be best to do something here to figure out automatically\n+   from other information what type to use.  */\n+\n+#ifndef SIZE_TYPE\n+#define SIZE_TYPE \"long unsigned int\"\n+#endif\n+\n+#ifndef WCHAR_TYPE\n+#define WCHAR_TYPE \"int\"\n+#endif\n+\n #ifndef PTRDIFF_TYPE\n #define PTRDIFF_TYPE \"long int\"\n #endif\n@@ -172,6 +186,14 @@ int flag_no_builtin;\n \n int flag_no_nonansi_builtin;\n \n+/* Nonzero means give `double' the same size as `float'.  */\n+\n+int flag_short_double;\n+\n+/* Nonzero means give `wchar_t' the same size as `short'.  */\n+\n+int flag_short_wchar;\n+\n /* If non-NULL, dump the tree structure for the entire translation\n    unit to this file.  */\n \n@@ -5096,6 +5118,8 @@ lang_get_alias_set (t)\n void\n c_common_nodes_and_builtins ()\n {\n+  int wchar_type_size;\n+  tree array_domain_type;\n   tree temp;\n   tree memcpy_ftype, memset_ftype, strlen_ftype;\n   tree bzero_ftype, bcmp_ftype, puts_ftype, printf_ftype;\n@@ -5122,6 +5146,140 @@ c_common_nodes_and_builtins ()\n   tree va_list_ref_type_node;\n   tree va_list_arg_type_node;\n \n+  /* Define `int' and `char' first so that dbx will output them first.  */\n+  record_builtin_type (RID_INT, NULL_PTR, integer_type_node);\n+  record_builtin_type (RID_CHAR, \"char\", char_type_node);\n+\n+  /* `signed' is the same as `int'.  FIXME: the declarations of \"signed\",\n+     \"unsigned long\", \"long long unsigned\" and \"unsigned short\" were in C++\n+     but not C.  Are the conditionals here needed?  */\n+  if (c_language == clk_cplusplus)\n+    record_builtin_type (RID_SIGNED, NULL_PTR, integer_type_node);\n+  record_builtin_type (RID_LONG, \"long int\", long_integer_type_node);\n+  record_builtin_type (RID_UNSIGNED, \"unsigned int\", unsigned_type_node);\n+  record_builtin_type (RID_MAX, \"long unsigned int\",\n+\t\t       long_unsigned_type_node);\n+  if (c_language == clk_cplusplus)\n+    record_builtin_type (RID_MAX, \"unsigned long\", long_unsigned_type_node);\n+  record_builtin_type (RID_MAX, \"long long int\",\n+\t\t       long_long_integer_type_node);\n+  record_builtin_type (RID_MAX, \"long long unsigned int\",\n+\t\t       long_long_unsigned_type_node);\n+  if (c_language == clk_cplusplus)\n+    record_builtin_type (RID_MAX, \"long long unsigned\",\n+\t\t\t long_long_unsigned_type_node);\n+  record_builtin_type (RID_SHORT, \"short int\", short_integer_type_node);\n+  record_builtin_type (RID_MAX, \"short unsigned int\",\n+\t\t       short_unsigned_type_node);\n+  if (c_language == clk_cplusplus)\n+    record_builtin_type (RID_MAX, \"unsigned short\",\n+\t\t\t short_unsigned_type_node);\n+\n+  /* Define both `signed char' and `unsigned char'.  */\n+  record_builtin_type (RID_MAX, \"signed char\", signed_char_type_node);\n+  record_builtin_type (RID_MAX, \"unsigned char\", unsigned_char_type_node);\n+\n+  /* These are types that type_for_size and type_for_mode use.  */\n+  pushdecl (build_decl (TYPE_DECL, NULL_TREE, intQI_type_node));\n+  pushdecl (build_decl (TYPE_DECL, NULL_TREE, intHI_type_node));\n+  pushdecl (build_decl (TYPE_DECL, NULL_TREE, intSI_type_node));\n+  pushdecl (build_decl (TYPE_DECL, NULL_TREE, intDI_type_node));\n+#if HOST_BITS_PER_WIDE_INT >= 64\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"__int128_t\"), intTI_type_node));\n+#endif\n+  pushdecl (build_decl (TYPE_DECL, NULL_TREE, unsigned_intQI_type_node));\n+  pushdecl (build_decl (TYPE_DECL, NULL_TREE, unsigned_intHI_type_node));\n+  pushdecl (build_decl (TYPE_DECL, NULL_TREE, unsigned_intSI_type_node));\n+  pushdecl (build_decl (TYPE_DECL, NULL_TREE, unsigned_intDI_type_node));\n+#if HOST_BITS_PER_WIDE_INT >= 64\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"__uint128_t\"), unsigned_intTI_type_node));\n+#endif\n+\n+  /* Create the widest literal types.  */\n+  widest_integer_literal_type_node\n+    = make_signed_type (HOST_BITS_PER_WIDE_INT * 2);\n+  pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n+\t\t\twidest_integer_literal_type_node));\n+\n+  widest_unsigned_literal_type_node\n+    = make_unsigned_type (HOST_BITS_PER_WIDE_INT * 2);\n+  pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n+\t\t\twidest_unsigned_literal_type_node));\n+\n+  /* `unsigned long' is the standard type for sizeof.\n+     Note that stddef.h uses `unsigned long',\n+     and this must agree, even if long and int are the same size.  */\n+  c_size_type_node =\n+    TREE_TYPE (identifier_global_value (get_identifier (SIZE_TYPE)));\n+  signed_size_type_node = signed_type (c_size_type_node);\n+  if (flag_traditional)\n+    c_size_type_node = signed_size_type_node;\n+  set_sizetype (c_size_type_node);\n+\n+  build_common_tree_nodes_2 (flag_short_double);\n+\n+  record_builtin_type (RID_FLOAT, NULL_PTR, float_type_node);\n+  record_builtin_type (RID_DOUBLE, NULL_PTR, double_type_node);\n+  record_builtin_type (RID_MAX, \"long double\", long_double_type_node);\n+\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex int\"),\n+\t\t\tcomplex_integer_type_node));\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex float\"),\n+\t\t\tcomplex_float_type_node));\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex double\"),\n+\t\t\tcomplex_double_type_node));\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex long double\"),\n+\t\t\tcomplex_long_double_type_node));\n+\n+  record_builtin_type (RID_VOID, NULL_PTR, void_type_node);\n+\n+  void_list_node = build_void_list_node ();\n+\n+  /* Make a type to be the domain of a few array types\n+     whose domains don't really matter.\n+     200 is small enough that it always fits in size_t\n+     and large enough that it can hold most function names for the\n+     initializations of __FUNCTION__ and __PRETTY_FUNCTION__.  */\n+  array_domain_type = build_index_type (size_int (200));\n+\n+  /* Make a type for arrays of characters.\n+     With luck nothing will ever really depend on the length of this\n+     array type.  */\n+  char_array_type_node\n+    = build_array_type (char_type_node, array_domain_type);\n+\n+  /* Likewise for arrays of ints.  */\n+  int_array_type_node\n+    = build_array_type (integer_type_node, array_domain_type);\n+\n+#ifdef MD_INIT_BUILTINS\n+  MD_INIT_BUILTINS;\n+#endif\n+\n+  /* This is special for C++ so functions can be overloaded.  */\n+  wchar_type_node = get_identifier (flag_short_wchar\n+\t\t\t\t    ? \"short unsigned int\"\n+\t\t\t\t    : WCHAR_TYPE);\n+  wchar_type_node = TREE_TYPE (identifier_global_value (wchar_type_node));\n+  wchar_type_size = TYPE_PRECISION (wchar_type_node);\n+  if (c_language == clk_cplusplus)\n+    {\n+      if (TREE_UNSIGNED (wchar_type_node))\n+\twchar_type_node = make_unsigned_type (wchar_type_size);\n+      else\n+\twchar_type_node = make_signed_type (wchar_type_size);\n+      record_builtin_type (RID_WCHAR, \"wchar_t\", wchar_type_node);\n+    }\n+  else\n+    {\n+      signed_wchar_type_node = signed_type (wchar_type_node);\n+      unsigned_wchar_type_node = unsigned_type (wchar_type_node);\n+    }\n+\n+  /* This is for wide string constants.  */\n+  wchar_array_type_node\n+    = build_array_type (wchar_type_node, array_domain_type);\n+\n   string_type_node = build_pointer_type (char_type_node);\n   const_string_type_node\n     = build_pointer_type (build_type_variant (char_type_node, 1, 0));"}, {"sha": "adee309ce3b4c952483aae2a1b9bef00826508dc", "filename": "gcc/c-common.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa7c03f500d8d7b5d88c2b02d11513cc489226e/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa7c03f500d8d7b5d88c2b02d11513cc489226e/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=eaa7c03f500d8d7b5d88c2b02d11513cc489226e", "patch": "@@ -351,6 +351,14 @@ extern c_language_kind c_language;\n \n extern int flag_const_strings;\n \n+/* Nonzero means give `double' the same size as `float'.  */\n+\n+extern int flag_short_double;\n+\n+/* Nonzero means give `wchar_t' the same size as `short'.  */\n+\n+extern int flag_short_wchar;\n+\n /* Warn about *printf or *scanf format/argument anomalies. */\n \n extern int warn_format;\n@@ -463,6 +471,9 @@ extern int warn_long_long;\n extern tree (*make_fname_decl)                  PARAMS ((tree, const char *, int));\n \n extern tree identifier_global_value\t\tPARAMS ((tree));\n+extern void record_builtin_type\t\t\tPARAMS ((enum rid,\n+\t\t\t\t\t\t\t const char *, tree));\n+extern tree build_void_list_node\t\tPARAMS ((void));\n \n extern void declare_function_name\t\tPARAMS ((void));\n extern void decl_attributes\t\t\tPARAMS ((tree, tree, tree));"}, {"sha": "c813d3e42de6911767c5edce1bfd0b395c42a5a0", "filename": "gcc/c-decl.c", "status": "modified", "additions": 26, "deletions": 139, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa7c03f500d8d7b5d88c2b02d11513cc489226e/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa7c03f500d8d7b5d88c2b02d11513cc489226e/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=eaa7c03f500d8d7b5d88c2b02d11513cc489226e", "patch": "@@ -52,20 +52,6 @@ enum decl_context\n   BITFIELD,\t\t\t/* Likewise but with specified width */\n   TYPENAME};\t\t\t/* Typename (inside cast or sizeof)  */\n \n-/* We let tm.h override the types used here, to handle trivial differences\n-   such as the choice of unsigned int or long unsigned int for size_t.\n-   When machines start needing nontrivial differences in the size type,\n-   it would be best to do something here to figure out automatically\n-   from other information what type to use.  */\n-\n-#ifndef SIZE_TYPE\n-#define SIZE_TYPE \"long unsigned int\"\n-#endif\n-\n-#ifndef WCHAR_TYPE\n-#define WCHAR_TYPE \"int\"\n-#endif\n-\n \f\n /* Nonzero if we have seen an invalid cross reference\n    to a struct, union, or enum, but not yet printed the message.  */\n@@ -304,14 +290,6 @@ static void c_expand_body               PARAMS ((tree, int));\n \n int flag_cond_mismatch;\n \n-/* Nonzero means give `double' the same size as `float'.  */\n-\n-int flag_short_double;\n-\n-/* Nonzero means give `wchar_t' the same size as `short'.  */\n-\n-int flag_short_wchar;\n-\n /* Nonzero means don't recognize the keyword `asm'.  */\n \n int flag_no_asm;\n@@ -2962,9 +2940,6 @@ init_decl_processing ()\n {\n   register tree endlink;\n   tree ptr_ftype_void, ptr_ftype_ptr;\n-  int wchar_type_size;\n-  tree array_domain_type;\n-  tree t;\n \n   current_function_decl = NULL;\n   named_labels = NULL;\n@@ -2977,96 +2952,7 @@ init_decl_processing ()\n \n   build_common_tree_nodes (flag_signed_char);\n \n-  /* Define `int' and `char' first so that dbx will output them first.  */\n-  pushdecl (build_decl (TYPE_DECL, ridpointers[(int) RID_INT],\n-\t\t\tinteger_type_node));\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"char\"),\n-\t\t\tchar_type_node));\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"long int\"),\n-\t\t\tlong_integer_type_node));\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"unsigned int\"),\n-\t\t\tunsigned_type_node));\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"long unsigned int\"),\n-\t\t\tlong_unsigned_type_node));\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"long long int\"),\n-\t\t\tlong_long_integer_type_node));\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"long long unsigned int\"),\n-\t\t\tlong_long_unsigned_type_node));\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"short int\"),\n-\t\t\tshort_integer_type_node));\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"short unsigned int\"),\n-\t\t\tshort_unsigned_type_node));\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"signed char\"),\n-\t\t\tsigned_char_type_node));\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"unsigned char\"),\n-\t\t\tunsigned_char_type_node));\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, intQI_type_node));\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, intHI_type_node));\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, intSI_type_node));\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, intDI_type_node));\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, intTI_type_node));\n-#endif\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, unsigned_intQI_type_node));\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, unsigned_intHI_type_node));\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, unsigned_intSI_type_node));\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, unsigned_intDI_type_node));\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, unsigned_intTI_type_node));\n-#endif\n-\n-  /* `unsigned long' is the standard type for sizeof.\n-     Traditionally, use a signed type.\n-     Note that stddef.h uses `unsigned long',\n-     and this must agree, even if long and int are the same size.  */\n-  t = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (SIZE_TYPE)));\n-  signed_size_type_node = signed_type (t);\n-  if (flag_traditional && TREE_UNSIGNED (t))\n-    t = signed_type (t);\n-\n-  c_size_type_node = t;\n-  set_sizetype (t);\n-\n-  /* Create the widest literal types.  */\n-  widest_integer_literal_type_node\n-    = make_signed_type (HOST_BITS_PER_WIDE_INT * 2);\n-  widest_unsigned_literal_type_node\n-    = make_unsigned_type (HOST_BITS_PER_WIDE_INT * 2);\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n-\t\t\twidest_integer_literal_type_node));\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n-\t\t\twidest_unsigned_literal_type_node));\n-\n-  build_common_tree_nodes_2 (flag_short_double);\n-\n-  pushdecl (build_decl (TYPE_DECL, ridpointers[(int) RID_FLOAT],\n-\t\t\tfloat_type_node));\n-  pushdecl (build_decl (TYPE_DECL, ridpointers[(int) RID_DOUBLE],\n-\t\t\tdouble_type_node));\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"long double\"),\n-\t\t\tlong_double_type_node));\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex int\"),\n-\t\t\tcomplex_integer_type_node));\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex float\"),\n-\t\t\tcomplex_float_type_node));\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex double\"),\n-\t\t\tcomplex_double_type_node));\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex long double\"),\n-\t\t\tcomplex_long_double_type_node));\n-  pushdecl (build_decl (TYPE_DECL,\n-\t\t\tridpointers[(int) RID_VOID], void_type_node));\n-\n-#ifdef MD_INIT_BUILTINS\n-  MD_INIT_BUILTINS;\n-#endif\n-\n-  wchar_type_node = get_identifier (flag_short_wchar\n-\t\t\t\t    ? \"short unsigned int\"\n-\t\t\t\t    : WCHAR_TYPE);\n-  wchar_type_node = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (wchar_type_node));\n-  wchar_type_size = TYPE_PRECISION (wchar_type_node);\n-  signed_wchar_type_node = signed_type (wchar_type_node);\n-  unsigned_wchar_type_node = unsigned_type (wchar_type_node);\n+  c_common_nodes_and_builtins ();\n \n   boolean_type_node = integer_type_node;\n   boolean_true_node = integer_one_node;\n@@ -3085,30 +2971,6 @@ init_decl_processing ()\n   c_bool_true_node = build_int_2 (1, 0);\n   TREE_TYPE (c_bool_true_node) = c_bool_type_node;\n \n-  /* Make a type to be the domain of a few array types\n-     whose domains don't really matter.\n-     200 is small enough that it always fits in size_t\n-     and large enough that it can hold most function names for the\n-     initializations of __FUNCTION__ and __PRETTY_FUNCTION__.  */\n-  array_domain_type = build_index_type (build_int_2 (200, 0));\n-\n-  /* make a type for arrays of characters.\n-     With luck nothing will ever really depend on the length of this\n-     array type.  */\n-  char_array_type_node = build_array_type (char_type_node, array_domain_type);\n-\n-  /* Likewise for arrays of ints.  */\n-  int_array_type_node\n-    = build_array_type (integer_type_node, array_domain_type);\n-\n-  /* This is for wide string constants.  */\n-  wchar_array_type_node\n-    = build_array_type (wchar_type_node, array_domain_type);\n-\n-  void_list_node = tree_cons (NULL_TREE, void_type_node, NULL_TREE);\n-\n-  c_common_nodes_and_builtins ();\n-\n   endlink = void_list_node;\n   ptr_ftype_void = build_function_type (ptr_type_node, endlink);\n   ptr_ftype_ptr\n@@ -7190,3 +7052,28 @@ identifier_global_value\t(t)\n {\n   return IDENTIFIER_GLOBAL_VALUE (t);\n }\n+\n+/* Record a builtin type for C.  If NAME is non-NULL, it is the name used;\n+   otherwise the name is found in ridpointers from RID_INDEX.  */\n+\n+void\n+record_builtin_type (rid_index, name, type)\n+     enum rid rid_index;\n+     const char *name;\n+     tree type;\n+{\n+  tree id;\n+  if (name == 0)\n+    id = ridpointers[(int) rid_index];\n+  else\n+    id = get_identifier (name);\n+  pushdecl (build_decl (TYPE_DECL, id, type));\n+}\n+\n+/* Build the void_list_node (void_type_node having been created).  */\n+tree\n+build_void_list_node ()\n+{\n+  tree t = build_tree_list (NULL_TREE, void_type_node);\n+  return t;\n+}"}, {"sha": "73bf967bddf34c4bf19463c48b0671b97fde08e0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa7c03f500d8d7b5d88c2b02d11513cc489226e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa7c03f500d8d7b5d88c2b02d11513cc489226e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=eaa7c03f500d8d7b5d88c2b02d11513cc489226e", "patch": "@@ -1,3 +1,14 @@\n+2001-01-04  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* decl.c (SIZE_TYPE, PTRDIFF_TYPE, WCHAR_TYPE): Don't define.\n+\t(record_builtin_type): Make non-static.\n+\t(flag_short_double): Don't declare.\n+\t(init_decl_processing): Remove the creation of many tree nodes now\n+\tin c_common_nodes_and_builtins.\n+\t(build_void_list_node): New function.\n+\t* decl2.c (flag_short_double, flag_short_wchar): Don't define.\n+\t* cp-tree.h (flag_short_wchar): Don't declare.\n+\n 2001-01-04  Mark Mitchell  <mark@codesourcery.com>\n \n \t* call.c (build_conv): Don't use build1 for USER_CONV."}, {"sha": "0da2283af7712b4cc338e6be12245a60c35229c8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa7c03f500d8d7b5d88c2b02d11513cc489226e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa7c03f500d8d7b5d88c2b02d11513cc489226e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=eaa7c03f500d8d7b5d88c2b02d11513cc489226e", "patch": "@@ -1,6 +1,6 @@\n /* Definitions for C++ parsing and type checking.\n-   Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n+   2000, 2001 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -1131,10 +1131,6 @@ extern int flag_default_inline;\n    version 0.  */\n extern int name_mangling_version;\n \n-/* Nonzero if wchar_t should be `unsigned short' instead of whatever it\n-   would normally be, for use with WINE.  */\n-extern int flag_short_wchar;\n-\n /* Nonzero if squashed mangling is to be performed.\n    This uses the B and K codes to reference previously seen class types\n    and class qualifiers.       */"}, {"sha": "636b50c43d6ed15718abbcea308be226cc646276", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 11, "deletions": 140, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa7c03f500d8d7b5d88c2b02d11513cc489226e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa7c03f500d8d7b5d88c2b02d11513cc489226e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=eaa7c03f500d8d7b5d88c2b02d11513cc489226e", "patch": "@@ -62,24 +62,6 @@ extern int (*valid_lang_attribute) PARAMS ((tree, tree, tree, tree));\n #endif\n #endif\n \n-/* We let tm.h override the types used here, to handle trivial differences\n-   such as the choice of unsigned int or long unsigned int for size_t.\n-   When machines start needing nontrivial differences in the size type,\n-   it would be best to do something here to figure out automatically\n-   from other information what type to use.  */\n-\n-#ifndef SIZE_TYPE\n-#define SIZE_TYPE \"long unsigned int\"\n-#endif\n-\n-#ifndef PTRDIFF_TYPE\n-#define PTRDIFF_TYPE \"long int\"\n-#endif\n-\n-#ifndef WCHAR_TYPE\n-#define WCHAR_TYPE \"int\"\n-#endif\n-\n static tree grokparms\t\t\t\tPARAMS ((tree));\n static const char *redeclaration_error_message\tPARAMS ((tree, tree));\n \n@@ -109,7 +91,6 @@ static tree lookup_tag PARAMS ((enum tree_code, tree,\n \t\t\t      struct binding_level *, int));\n static void set_identifier_type_value_with_scope\n \tPARAMS ((tree, tree, struct binding_level *));\n-static void record_builtin_type PARAMS ((enum rid, const char *, tree));\n static void record_unknown_type PARAMS ((tree, const char *));\n static tree build_library_fn_1 PARAMS ((tree, enum tree_code, tree));\n static int member_function_or_else PARAMS ((tree, tree, enum overload_flags));\n@@ -334,10 +315,6 @@ int flag_hosted = 1;\n \n int flag_noniso_default_format_attributes = 1;\n \n-/* Nonzero means give `double' the same size as `float'.  */\n-\n-extern int flag_short_double;\n-\n /* Nonzero if we want to conserve space in the .o files.  We do this\n    by putting uninitialized data and runtime initialized data into\n    .common instead of .data at the expense of not flagging multiple\n@@ -6153,7 +6130,7 @@ end_only_namespace_names ()\n    in the array RID_POINTERS.  NAME is the name used when looking\n    up the builtin type.  TYPE is the _TYPE node for the builtin type.  */\n \n-static void\n+void\n record_builtin_type (rid_index, name, type)\n      enum rid rid_index;\n      const char *name;\n@@ -6309,8 +6286,6 @@ void\n init_decl_processing ()\n {\n   tree fields[20];\n-  int wchar_type_size;\n-  tree array_domain_type;\n \n   /* Check to see that the user did not specify an invalid combination\n      of command-line options.  */\n@@ -6382,67 +6357,7 @@ init_decl_processing ()\n       pushdecl (fake_std_node);\n     }\n \n-  /* Define `int' and `char' first so that dbx will output them first.  */\n-  record_builtin_type (RID_INT, NULL_PTR, integer_type_node);\n-  record_builtin_type (RID_CHAR, \"char\", char_type_node);\n-\n-  /* `signed' is the same as `int' */\n-  record_builtin_type (RID_SIGNED, NULL_PTR, integer_type_node);\n-  record_builtin_type (RID_LONG, \"long int\", long_integer_type_node);\n-  record_builtin_type (RID_UNSIGNED, \"unsigned int\", unsigned_type_node);\n-  record_builtin_type (RID_MAX, \"long unsigned int\",\n-\t\t       long_unsigned_type_node);\n-  record_builtin_type (RID_MAX, \"unsigned long\", long_unsigned_type_node);\n-  record_builtin_type (RID_MAX, \"long long int\",\n-\t\t       long_long_integer_type_node);\n-  record_builtin_type (RID_MAX, \"long long unsigned int\",\n-\t\t       long_long_unsigned_type_node);\n-  record_builtin_type (RID_MAX, \"long long unsigned\",\n-\t\t       long_long_unsigned_type_node);\n-  record_builtin_type (RID_SHORT, \"short int\", short_integer_type_node);\n-  record_builtin_type (RID_MAX, \"short unsigned int\",\n-\t\t       short_unsigned_type_node);\n-  record_builtin_type (RID_MAX, \"unsigned short\",\n-\t\t       short_unsigned_type_node);\n-\n-  /* Define both `signed char' and `unsigned char'.  */\n-  record_builtin_type (RID_MAX, \"signed char\", signed_char_type_node);\n-  record_builtin_type (RID_MAX, \"unsigned char\", unsigned_char_type_node);\n-\n-  /* `unsigned long' is the standard type for sizeof.\n-     Note that stddef.h uses `unsigned long',\n-     and this must agree, even if long and int are the same size.  */\n-  c_size_type_node =\n-    TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (SIZE_TYPE)));\n-  signed_size_type_node = signed_type (c_size_type_node);\n-  set_sizetype (c_size_type_node);\n-\n-  /* Create the widest literal types. */\n-  widest_integer_literal_type_node = make_signed_type (HOST_BITS_PER_WIDE_INT * 2);\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n-\t\t\twidest_integer_literal_type_node));\n-\n-  widest_unsigned_literal_type_node = make_unsigned_type (HOST_BITS_PER_WIDE_INT * 2);\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n-\t\t\twidest_unsigned_literal_type_node));\n-\n-  /* These are types that type_for_size and type_for_mode use.  */\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, intQI_type_node));\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, intHI_type_node));\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, intSI_type_node));\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, intDI_type_node));\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"__int128_t\"), intTI_type_node));\n-#endif\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, unsigned_intQI_type_node));\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, unsigned_intHI_type_node));\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, unsigned_intSI_type_node));\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, unsigned_intDI_type_node));\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"__uint128_t\"), unsigned_intTI_type_node));\n-#endif\n-\n-  build_common_tree_nodes_2 (flag_short_double);\n+  c_common_nodes_and_builtins ();\n \n   java_byte_type_node = record_builtin_java_type (\"__java_byte\", 8);\n   java_short_type_node = record_builtin_java_type (\"__java_short\", 16);\n@@ -6470,42 +6385,9 @@ init_decl_processing ()\n   TREE_TYPE (boolean_true_node) = boolean_type_node;\n \n   signed_size_zero_node = build_int_2 (0, 0);\n-  record_builtin_type (RID_FLOAT, NULL_PTR, float_type_node);\n-  record_builtin_type (RID_DOUBLE, NULL_PTR, double_type_node);\n-  record_builtin_type (RID_MAX, \"long double\", long_double_type_node);\n-\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex int\"),\n-\t\t\tcomplex_integer_type_node));\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex float\"),\n-\t\t\tcomplex_float_type_node));\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex double\"),\n-\t\t\tcomplex_double_type_node));\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex long double\"),\n-\t\t\tcomplex_long_double_type_node));\n-\n   TREE_TYPE (signed_size_zero_node) = make_signed_type (TYPE_PRECISION (sizetype));\n \n-  record_builtin_type (RID_VOID, NULL_PTR, void_type_node);\n-  void_list_node = build_tree_list (NULL_TREE, void_type_node);\n-  TREE_PARMLIST (void_list_node) = 1;\n-\n   empty_except_spec = build_tree_list (NULL_TREE, NULL_TREE);\n-  /* Make a type to be the domain of a few array types\n-     whose domains don't really matter.\n-     200 is small enough that it always fits in size_t.  */\n-  array_domain_type = build_index_type (size_int (200));\n-\n-  /* Make a type for arrays of characters.\n-     With luck nothing will ever really depend on the length of this\n-     array type.  */\n-  char_array_type_node\n-    = build_array_type (char_type_node, array_domain_type);\n-\n-  /* Likewise for arrays of ints.  */\n-  int_array_type_node\n-    = build_array_type (integer_type_node, array_domain_type);\n-\n-  c_common_nodes_and_builtins ();\n \n #if 0\n   record_builtin_type (RID_MAX, NULL_PTR, string_type_node);\n@@ -6529,10 +6411,6 @@ init_decl_processing ()\n   void_ftype_ptr\n     = build_exception_variant (void_ftype_ptr, empty_except_spec);\n \n-#ifdef MD_INIT_BUILTINS\n-  MD_INIT_BUILTINS;\n-#endif\n-\n   /* C++ extensions */\n \n   unknown_type_node = make_node (UNKNOWN_TYPE);\n@@ -6548,22 +6426,6 @@ init_decl_processing ()\n   TYPE_POINTER_TO (unknown_type_node) = unknown_type_node;\n   TYPE_REFERENCE_TO (unknown_type_node) = unknown_type_node;\n \n-  /* This is special for C++ so functions can be overloaded.  */\n-  wchar_type_node = get_identifier (flag_short_wchar\n-\t\t\t\t    ? \"short unsigned int\"\n-\t\t\t\t    : WCHAR_TYPE);\n-  wchar_type_node = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (wchar_type_node));\n-  wchar_type_size = TYPE_PRECISION (wchar_type_node);\n-  if (TREE_UNSIGNED (wchar_type_node))\n-    wchar_type_node = make_unsigned_type (wchar_type_size);\n-  else\n-    wchar_type_node = make_signed_type (wchar_type_size);\n-  record_builtin_type (RID_WCHAR, \"wchar_t\", wchar_type_node);\n-\n-  /* This is for wide string constants.  */\n-  wchar_array_type_node\n-    = build_array_type (wchar_type_node, array_domain_type);\n-\n   if (flag_vtable_thunks)\n     {\n       /* Make sure we get a unique function type, so we can give\n@@ -14661,6 +14523,15 @@ identifier_global_value\t(t)\n   return IDENTIFIER_GLOBAL_VALUE (t);\n }\n \n+/* Build the void_list_node (void_type_node having been created).  */\n+tree\n+build_void_list_node ()\n+{\n+  tree t = build_tree_list (NULL_TREE, void_type_node);\n+  TREE_PARMLIST (t) = 1;\n+  return t;\n+}\n+\n static int\n cp_missing_noreturn_ok_p (decl)\n      tree decl;"}, {"sha": "1a38f4488ffcb87ab9df93a946a62e48f7bc4dd0", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa7c03f500d8d7b5d88c2b02d11513cc489226e/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa7c03f500d8d7b5d88c2b02d11513cc489226e/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=eaa7c03f500d8d7b5d88c2b02d11513cc489226e", "patch": "@@ -1,6 +1,6 @@\n /* Process declarations and variables for C compiler.\n    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   1999, 2000, 2001 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -144,10 +144,6 @@ static tree decl_namespace_list;\n \n int flag_cond_mismatch;\n \n-/* Nonzero means give `double' the same size as `float'.  */\n-\n-int flag_short_double;\n-\n /* Nonzero means don't recognize the keyword `asm'.  */\n \n int flag_no_asm;\n@@ -453,11 +449,6 @@ int max_tinst_depth = 50;\n    arguments.  */\n int name_mangling_version = 2;\n \n-/* Nonzero if wchar_t should be `unsigned short' instead of whatever it\n-   would normally be, for use with WINE.  */\n-\n-int flag_short_wchar;\n-\n /* Nonzero if squashed mangling is to be performed. \n    This uses the B and K codes to reference previously seen class types \n    and class qualifiers.       */"}]}