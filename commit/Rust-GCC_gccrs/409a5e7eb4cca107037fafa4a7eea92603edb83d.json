{"sha": "409a5e7eb4cca107037fafa4a7eea92603edb83d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA5YTVlN2ViNGNjYTEwNzAzN2ZhZmE0YTdlZWE5MjYwM2VkYjgzZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-12-22T01:15:33Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-12-22T01:15:33Z"}, "message": "libgo: Update to revision 15193:6fdc1974457c of master library.\n\nFrom-SVN: r194692", "tree": {"sha": "06f36bbef6fae78278f799194ad0df8ba2dabaa1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06f36bbef6fae78278f799194ad0df8ba2dabaa1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/409a5e7eb4cca107037fafa4a7eea92603edb83d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/409a5e7eb4cca107037fafa4a7eea92603edb83d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/409a5e7eb4cca107037fafa4a7eea92603edb83d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/409a5e7eb4cca107037fafa4a7eea92603edb83d/comments", "author": null, "committer": null, "parents": [{"sha": "7e9268b4cf01ab87d9b602f592ed2e2facfadda9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e9268b4cf01ab87d9b602f592ed2e2facfadda9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e9268b4cf01ab87d9b602f592ed2e2facfadda9"}], "stats": {"total": 3118, "additions": 2433, "deletions": 685}, "files": [{"sha": "52537f98bfba7de5ebaf5bcd4a1b808b869b48da", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -1,4 +1,4 @@\n-c031aa767edf\n+6fdc1974457c\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "b97a82e549f3130673fd9f7ef478cdcdbfa11d15", "filename": "libgo/Makefile.am", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -502,6 +502,7 @@ runtime_files = \\\n \truntime/go-unwind.c \\\n \truntime/chan.c \\\n \truntime/cpuprof.c \\\n+\truntime/env_posix.c \\\n \truntime/lfstack.c \\\n \t$(runtime_lock_files) \\\n \truntime/mcache.c \\\n@@ -1657,6 +1658,13 @@ else\n syscall_lsf_file =\n endif\n \n+# GNU/Linux specific utimesnano support.\n+if LIBGO_IS_LINUX\n+syscall_utimesnano_file = go/syscall/libcall_linux_utimesnano.go\n+else\n+syscall_utimesnano_file = go/syscall/libcall_posix_utimesnano.go\n+endif\n+\n go_base_syscall_files = \\\n \tgo/syscall/env_unix.go \\\n \tgo/syscall/syscall_errno.go \\\n@@ -1679,6 +1687,7 @@ go_base_syscall_files = \\\n \t$(syscall_uname_file) \\\n \t$(syscall_netlink_file) \\\n \t$(syscall_lsf_file) \\\n+\t$(syscall_utimesnano_file) \\\n \t$(GO_LIBCALL_OS_FILE) \\\n \t$(GO_LIBCALL_OS_ARCH_FILE) \\\n \t$(GO_SYSCALL_OS_FILE) \\"}, {"sha": "fe18b74e2ae27bd5cc1d8e5e764d97daa6a4d661", "filename": "libgo/Makefile.in", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -213,12 +213,13 @@ am__objects_5 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-type-float.lo go-type-identity.lo go-type-interface.lo \\\n \tgo-type-string.lo go-typedesc-equal.lo go-typestring.lo \\\n \tgo-unsafe-new.lo go-unsafe-newarray.lo go-unsafe-pointer.lo \\\n-\tgo-unwind.lo chan.lo cpuprof.lo lfstack.lo $(am__objects_1) \\\n-\tmcache.lo mcentral.lo $(am__objects_2) mfinal.lo mfixalloc.lo \\\n-\tmgc0.lo mheap.lo msize.lo panic.lo parfor.lo print.lo proc.lo \\\n-\truntime.lo signal_unix.lo thread.lo yield.lo $(am__objects_3) \\\n-\tiface.lo malloc.lo map.lo mprof.lo reflect.lo runtime1.lo \\\n-\tsema.lo sigqueue.lo string.lo time.lo $(am__objects_4)\n+\tgo-unwind.lo chan.lo cpuprof.lo env_posix.lo lfstack.lo \\\n+\t$(am__objects_1) mcache.lo mcentral.lo $(am__objects_2) \\\n+\tmfinal.lo mfixalloc.lo mgc0.lo mheap.lo msize.lo panic.lo \\\n+\tparfor.lo print.lo proc.lo runtime.lo signal_unix.lo thread.lo \\\n+\tyield.lo $(am__objects_3) iface.lo malloc.lo map.lo mprof.lo \\\n+\treflect.lo runtime1.lo sema.lo sigqueue.lo string.lo time.lo \\\n+\t$(am__objects_4)\n am_libgo_la_OBJECTS = $(am__objects_5)\n libgo_la_OBJECTS = $(am_libgo_la_OBJECTS)\n libgo_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n@@ -835,6 +836,7 @@ runtime_files = \\\n \truntime/go-unwind.c \\\n \truntime/chan.c \\\n \truntime/cpuprof.c \\\n+\truntime/env_posix.c \\\n \truntime/lfstack.c \\\n \t$(runtime_lock_files) \\\n \truntime/mcache.c \\\n@@ -1840,6 +1842,10 @@ go_unicode_utf8_files = \\\n \n # GNU/Linux specific socket filters.\n @LIBGO_IS_LINUX_TRUE@syscall_lsf_file = go/syscall/lsf_linux.go\n+@LIBGO_IS_LINUX_FALSE@syscall_utimesnano_file = go/syscall/libcall_posix_utimesnano.go\n+\n+# GNU/Linux specific utimesnano support.\n+@LIBGO_IS_LINUX_TRUE@syscall_utimesnano_file = go/syscall/libcall_linux_utimesnano.go\n go_base_syscall_files = \\\n \tgo/syscall/env_unix.go \\\n \tgo/syscall/syscall_errno.go \\\n@@ -1862,6 +1868,7 @@ go_base_syscall_files = \\\n \t$(syscall_uname_file) \\\n \t$(syscall_netlink_file) \\\n \t$(syscall_lsf_file) \\\n+\t$(syscall_utimesnano_file) \\\n \t$(GO_LIBCALL_OS_FILE) \\\n \t$(GO_LIBCALL_OS_ARCH_FILE) \\\n \t$(GO_SYSCALL_OS_FILE) \\\n@@ -2418,6 +2425,7 @@ distclean-compile:\n \n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/chan.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpuprof.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/env_posix.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/getncpu-bsd.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/getncpu-irix.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/getncpu-linux.Plo@am__quote@\n@@ -3027,6 +3035,13 @@ cpuprof.lo: runtime/cpuprof.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cpuprof.lo `test -f 'runtime/cpuprof.c' || echo '$(srcdir)/'`runtime/cpuprof.c\n \n+env_posix.lo: runtime/env_posix.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT env_posix.lo -MD -MP -MF $(DEPDIR)/env_posix.Tpo -c -o env_posix.lo `test -f 'runtime/env_posix.c' || echo '$(srcdir)/'`runtime/env_posix.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/env_posix.Tpo $(DEPDIR)/env_posix.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/env_posix.c' object='env_posix.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o env_posix.lo `test -f 'runtime/env_posix.c' || echo '$(srcdir)/'`runtime/env_posix.c\n+\n lfstack.lo: runtime/lfstack.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT lfstack.lo -MD -MP -MF $(DEPDIR)/lfstack.Tpo -c -o lfstack.lo `test -f 'runtime/lfstack.c' || echo '$(srcdir)/'`runtime/lfstack.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/lfstack.Tpo $(DEPDIR)/lfstack.Plo"}, {"sha": "91d263a62343abf4f351f50d78c7f7bdd09bfa02", "filename": "libgo/go/builtin/builtin.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -124,8 +124,8 @@ func append(slice []Type, elems ...Type) []Type\n func copy(dst, src []Type) int\n \n // The delete built-in function deletes the element with the specified key\n-// (m[key]) from the map. If there is no such element, delete is a no-op.\n-// If m is nil, delete panics.\n+// (m[key]) from the map. If m is nil or there is no such element, delete\n+// is a no-op.\n func delete(m map[Type]Type1, key Type)\n \n // The len built-in function returns the length of v, according to its type:"}, {"sha": "d357fe361a55ed0bad4f1637e7c014ffc32e2146", "filename": "libgo/go/compress/flate/deflate.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -22,7 +22,7 @@ const (\n \tlogMaxOffsetSize   = 15  // Standard DEFLATE\n \tminMatchLength     = 3   // The smallest match that the compressor looks for\n \tmaxMatchLength     = 258 // The longest match for the compressor\n-\tminOffsetSize      = 1   // The shortest offset that makes any sence\n+\tminOffsetSize      = 1   // The shortest offset that makes any sense\n \n \t// The maximum number of tokens we put into a single flat block, just too\n \t// stop things from getting too large."}, {"sha": "e0027cac23b145e523566fde4d5efb30e4d92ed3", "filename": "libgo/go/crypto/cipher/example_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fcrypto%2Fcipher%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fcrypto%2Fcipher%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fexample_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -241,7 +241,7 @@ func ExampleStreamReader() {\n \n \t// Note that this example is simplistic in that it omits any\n \t// authentication of the encrypted data. It you were actually to use\n-\t// StreamReader in this manner, an attacker could flip arbitary bits in\n+\t// StreamReader in this manner, an attacker could flip arbitrary bits in\n \t// the output.\n }\n \n@@ -278,6 +278,6 @@ func ExampleStreamWriter() {\n \n \t// Note that this example is simplistic in that it omits any\n \t// authentication of the encrypted data. It you were actually to use\n-\t// StreamReader in this manner, an attacker could flip arbitary bits in\n+\t// StreamReader in this manner, an attacker could flip arbitrary bits in\n \t// the decrypted result.\n }"}, {"sha": "b2d6fe3d552bb03efb436b3e6c376d132ddfb570", "filename": "libgo/go/crypto/x509/x509_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -439,7 +439,7 @@ func TestECDSA(t *testing.T) {\n \t\t\tt.Errorf(\"%d: public key algorithm is %v, want ECDSA\", i, pka)\n \t\t}\n \t\tif err = cert.CheckSignatureFrom(cert); err != nil {\n-\t\t\tt.Errorf(\"%d: certificate verfication failed: %s\", i, err)\n+\t\t\tt.Errorf(\"%d: certificate verification failed: %s\", i, err)\n \t\t}\n \t}\n }\n@@ -519,7 +519,7 @@ func TestVerifyCertificateWithDSASignature(t *testing.T) {\n \t}\n \t// test cert is self-signed\n \tif err = cert.CheckSignatureFrom(cert); err != nil {\n-\t\tt.Fatalf(\"DSA Certificate verfication failed: %s\", err)\n+\t\tt.Fatalf(\"DSA Certificate verification failed: %s\", err)\n \t}\n }\n "}, {"sha": "c38ba7c849264036cc454873b38af736b5d1ad92", "filename": "libgo/go/database/sql/fakedb_test.go", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -42,9 +42,10 @@ type fakeDriver struct {\n type fakeDB struct {\n \tname string\n \n-\tmu     sync.Mutex\n-\tfree   []*fakeConn\n-\ttables map[string]*table\n+\tmu      sync.Mutex\n+\tfree    []*fakeConn\n+\ttables  map[string]*table\n+\tbadConn bool\n }\n \n type table struct {\n@@ -83,6 +84,7 @@ type fakeConn struct {\n \tstmtsMade   int\n \tstmtsClosed int\n \tnumPrepare  int\n+\tbad         bool\n }\n \n func (c *fakeConn) incrStat(v *int) {\n@@ -122,7 +124,9 @@ func init() {\n \n // Supports dsn forms:\n //    <dbname>\n-//    <dbname>;<opts>  (no currently supported options)\n+//    <dbname>;<opts>  (only currently supported option is `badConn`,\n+//                      which causes driver.ErrBadConn to be returned on\n+//                      every other conn.Begin())\n func (d *fakeDriver) Open(dsn string) (driver.Conn, error) {\n \tparts := strings.Split(dsn, \";\")\n \tif len(parts) < 1 {\n@@ -135,7 +139,12 @@ func (d *fakeDriver) Open(dsn string) (driver.Conn, error) {\n \td.mu.Lock()\n \td.openCount++\n \td.mu.Unlock()\n-\treturn &fakeConn{db: db}, nil\n+\tconn := &fakeConn{db: db}\n+\n+\tif len(parts) >= 2 && parts[1] == \"badConn\" {\n+\t\tconn.bad = true\n+\t}\n+\treturn conn, nil\n }\n \n func (d *fakeDriver) getDB(name string) *fakeDB {\n@@ -199,7 +208,20 @@ func (db *fakeDB) columnType(table, column string) (typ string, ok bool) {\n \treturn \"\", false\n }\n \n+func (c *fakeConn) isBad() bool {\n+\t// if not simulating bad conn, do nothing\n+\tif !c.bad {\n+\t\treturn false\n+\t}\n+\t// alternate between bad conn and not bad conn\n+\tc.db.badConn = !c.db.badConn\n+\treturn c.db.badConn\n+}\n+\n func (c *fakeConn) Begin() (driver.Tx, error) {\n+\tif c.isBad() {\n+\t\treturn nil, driver.ErrBadConn\n+\t}\n \tif c.currTx != nil {\n \t\treturn nil, errors.New(\"already in a transaction\")\n \t}"}, {"sha": "e7c7780ef2e685ed9456cec45c2dbcd7cd6ffcbe", "filename": "libgo/go/database/sql/sql.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -266,7 +266,7 @@ func (db *DB) connIfFree(wanted driver.Conn) (conn driver.Conn, ok bool) {\n var putConnHook func(*DB, driver.Conn)\n \n // putConn adds a connection to the db's free pool.\n-// err is optionally the last error that occured on this connection.\n+// err is optionally the last error that occurred on this connection.\n func (db *DB) putConn(c driver.Conn, err error) {\n \tif err == driver.ErrBadConn {\n \t\t// Don't reuse bad connections.\n@@ -426,7 +426,7 @@ func (db *DB) begin() (tx *Tx, err error) {\n \ttxi, err := ci.Begin()\n \tif err != nil {\n \t\tdb.putConn(ci, err)\n-\t\treturn nil, fmt.Errorf(\"sql: failed to Begin transaction: %v\", err)\n+\t\treturn nil, err\n \t}\n \treturn &Tx{\n \t\tdb:  db,"}, {"sha": "b702b850ec2ff486d4d0b686159ed619dfa7db7c", "filename": "libgo/go/database/sql/sql_test.go", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -402,6 +402,39 @@ func TestTxQueryInvalid(t *testing.T) {\n \t}\n }\n \n+// Tests fix for issue 4433, that retries in Begin happen when\n+// conn.Begin() returns ErrBadConn\n+func TestTxErrBadConn(t *testing.T) {\n+\tdb, err := Open(\"test\", fakeDBName+\";badConn\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Open: %v\", err)\n+\t}\n+\tif _, err := db.Exec(\"WIPE\"); err != nil {\n+\t\tt.Fatalf(\"exec wipe: %v\", err)\n+\t}\n+\tdefer closeDB(t, db)\n+\texec(t, db, \"CREATE|t1|name=string,age=int32,dead=bool\")\n+\tstmt, err := db.Prepare(\"INSERT|t1|name=?,age=?\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Stmt, err = %v, %v\", stmt, err)\n+\t}\n+\tdefer stmt.Close()\n+\ttx, err := db.Begin()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Begin = %v\", err)\n+\t}\n+\ttxs := tx.Stmt(stmt)\n+\tdefer txs.Close()\n+\t_, err = txs.Exec(\"Bobby\", 7)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Exec = %v\", err)\n+\t}\n+\terr = tx.Commit()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Commit = %v\", err)\n+\t}\n+}\n+\n // Tests fix for issue 2542, that we release a lock when querying on\n // a closed connection.\n func TestIssue2542Deadlock(t *testing.T) {"}, {"sha": "eb3d72f7126d766d2c26e916df468ee28df56375", "filename": "libgo/go/debug/elf/file.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -272,7 +272,8 @@ func NewFile(r io.ReaderAt) (*File, error) {\n \t\tshnum = int(hdr.Shnum)\n \t\tshstrndx = int(hdr.Shstrndx)\n \t}\n-\tif shstrndx < 0 || shstrndx >= shnum {\n+\n+\tif shnum > 0 && shoff > 0 && (shstrndx < 0 || shstrndx >= shnum) {\n \t\treturn nil, &FormatError{0, \"invalid ELF shstrndx\", shstrndx}\n \t}\n \n@@ -367,6 +368,10 @@ func NewFile(r io.ReaderAt) (*File, error) {\n \t\tf.Sections[i] = s\n \t}\n \n+\tif len(f.Sections) == 0 {\n+\t\treturn f, nil\n+\t}\n+\n \t// Load section header string table.\n \tshstrtab, err := f.Sections[shstrndx].Data()\n \tif err != nil {"}, {"sha": "f9aa7265af09f9cd8d81f83df933e1aeb7fb6f18", "filename": "libgo/go/debug/elf/file_test.go", "status": "modified", "additions": 57, "deletions": 2, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -5,10 +5,14 @@\n package elf\n \n import (\n+\t\"bytes\"\n+\t\"compress/gzip\"\n \t\"debug/dwarf\"\n \t\"encoding/binary\"\n+\t\"io\"\n \t\"net\"\n \t\"os\"\n+\t\"path\"\n \t\"reflect\"\n \t\"runtime\"\n \t\"testing\"\n@@ -121,15 +125,49 @@ var fileTests = []fileTest{\n \t\t},\n \t\t[]string{\"libc.so.6\"},\n \t},\n+\t{\n+\t\t\"testdata/hello-world-core.gz\",\n+\t\tFileHeader{ELFCLASS64, ELFDATA2LSB, EV_CURRENT, ELFOSABI_NONE, 0x0, binary.LittleEndian, ET_CORE, EM_X86_64, 0x0},\n+\t\t[]SectionHeader{},\n+\t\t[]ProgHeader{\n+\t\t\t{Type: PT_NOTE, Flags: 0x0, Off: 0x3f8, Vaddr: 0x0, Paddr: 0x0, Filesz: 0x8ac, Memsz: 0x0, Align: 0x0},\n+\t\t\t{Type: PT_LOAD, Flags: PF_X + PF_R, Off: 0x1000, Vaddr: 0x400000, Paddr: 0x0, Filesz: 0x0, Memsz: 0x1000, Align: 0x1000},\n+\t\t\t{Type: PT_LOAD, Flags: PF_R, Off: 0x1000, Vaddr: 0x401000, Paddr: 0x0, Filesz: 0x1000, Memsz: 0x1000, Align: 0x1000},\n+\t\t\t{Type: PT_LOAD, Flags: PF_W + PF_R, Off: 0x2000, Vaddr: 0x402000, Paddr: 0x0, Filesz: 0x1000, Memsz: 0x1000, Align: 0x1000},\n+\t\t\t{Type: PT_LOAD, Flags: PF_X + PF_R, Off: 0x3000, Vaddr: 0x7f54078b8000, Paddr: 0x0, Filesz: 0x0, Memsz: 0x1b5000, Align: 0x1000},\n+\t\t\t{Type: PT_LOAD, Flags: 0x0, Off: 0x3000, Vaddr: 0x7f5407a6d000, Paddr: 0x0, Filesz: 0x0, Memsz: 0x1ff000, Align: 0x1000},\n+\t\t\t{Type: PT_LOAD, Flags: PF_R, Off: 0x3000, Vaddr: 0x7f5407c6c000, Paddr: 0x0, Filesz: 0x4000, Memsz: 0x4000, Align: 0x1000},\n+\t\t\t{Type: PT_LOAD, Flags: PF_W + PF_R, Off: 0x7000, Vaddr: 0x7f5407c70000, Paddr: 0x0, Filesz: 0x2000, Memsz: 0x2000, Align: 0x1000},\n+\t\t\t{Type: PT_LOAD, Flags: PF_W + PF_R, Off: 0x9000, Vaddr: 0x7f5407c72000, Paddr: 0x0, Filesz: 0x5000, Memsz: 0x5000, Align: 0x1000},\n+\t\t\t{Type: PT_LOAD, Flags: PF_X + PF_R, Off: 0xe000, Vaddr: 0x7f5407c77000, Paddr: 0x0, Filesz: 0x0, Memsz: 0x22000, Align: 0x1000},\n+\t\t\t{Type: PT_LOAD, Flags: PF_W + PF_R, Off: 0xe000, Vaddr: 0x7f5407e81000, Paddr: 0x0, Filesz: 0x3000, Memsz: 0x3000, Align: 0x1000},\n+\t\t\t{Type: PT_LOAD, Flags: PF_W + PF_R, Off: 0x11000, Vaddr: 0x7f5407e96000, Paddr: 0x0, Filesz: 0x3000, Memsz: 0x3000, Align: 0x1000},\n+\t\t\t{Type: PT_LOAD, Flags: PF_R, Off: 0x14000, Vaddr: 0x7f5407e99000, Paddr: 0x0, Filesz: 0x1000, Memsz: 0x1000, Align: 0x1000},\n+\t\t\t{Type: PT_LOAD, Flags: PF_W + PF_R, Off: 0x15000, Vaddr: 0x7f5407e9a000, Paddr: 0x0, Filesz: 0x2000, Memsz: 0x2000, Align: 0x1000},\n+\t\t\t{Type: PT_LOAD, Flags: PF_W + PF_R, Off: 0x17000, Vaddr: 0x7fff79972000, Paddr: 0x0, Filesz: 0x23000, Memsz: 0x23000, Align: 0x1000},\n+\t\t\t{Type: PT_LOAD, Flags: PF_X + PF_R, Off: 0x3a000, Vaddr: 0x7fff799f8000, Paddr: 0x0, Filesz: 0x1000, Memsz: 0x1000, Align: 0x1000},\n+\t\t\t{Type: PT_LOAD, Flags: PF_X + PF_R, Off: 0x3b000, Vaddr: 0xffffffffff600000, Paddr: 0x0, Filesz: 0x1000, Memsz: 0x1000, Align: 0x1000},\n+\t\t},\n+\t\tnil,\n+\t},\n }\n \n func TestOpen(t *testing.T) {\n \tfor i := range fileTests {\n \t\ttt := &fileTests[i]\n \n-\t\tf, err := Open(tt.file)\n+\t\tvar f *File\n+\t\tvar err error\n+\t\tif path.Ext(tt.file) == \".gz\" {\n+\t\t\tvar r io.ReaderAt\n+\t\t\tif r, err = decompress(tt.file); err == nil {\n+\t\t\t\tf, err = NewFile(r)\n+\t\t\t}\n+\t\t} else {\n+\t\t\tf, err = Open(tt.file)\n+\t\t}\n \t\tif err != nil {\n-\t\t\tt.Error(err)\n+\t\t\tt.Errorf(\"cannot open file %s: %v\", tt.file, err)\n \t\t\tcontinue\n \t\t}\n \t\tif !reflect.DeepEqual(f.FileHeader, tt.hdr) {\n@@ -175,6 +213,23 @@ func TestOpen(t *testing.T) {\n \t}\n }\n \n+// elf.NewFile requires io.ReaderAt, which compress/gzip cannot\n+// provide. Decompress the file to a bytes.Reader.\n+func decompress(gz string) (io.ReaderAt, error) {\n+\tin, err := os.Open(gz)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer in.Close()\n+\tr, err := gzip.NewReader(in)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tvar out bytes.Buffer\n+\t_, err = io.Copy(&out, r)\n+\treturn bytes.NewReader(out.Bytes()), err\n+}\n+\n type relocationTestEntry struct {\n \tentryNumber int\n \tentry       *dwarf.Entry"}, {"sha": "806af6edbc23bd0db45a9b1adfae9418ca6a969a", "filename": "libgo/go/debug/elf/testdata/hello-world-core.gz", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fhello-world-core.gz", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fhello-world-core.gz", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ftestdata%2Fhello-world-core.gz?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d"}, {"sha": "1faecb6648061986846062a472c72908844d1e4e", "filename": "libgo/go/encoding/csv/writer.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -92,10 +92,17 @@ func (w *Writer) Write(record []string) (err error) {\n }\n \n // Flush writes any buffered data to the underlying io.Writer.\n+// To check if an error occurred during the Flush, call Error.\n func (w *Writer) Flush() {\n \tw.w.Flush()\n }\n \n+// Error reports any error that has occurred during a previous Write or Flush.\n+func (w *Writer) Error() error {\n+\t_, err := w.w.Write(nil)\n+\treturn err\n+}\n+\n // WriteAll writes multiple CSV records to w using Write and then calls Flush.\n func (w *Writer) WriteAll(records [][]string) (err error) {\n \tfor _, record := range records {"}, {"sha": "03ca6b093c03b6ebc169330b88ca24d1570ea52c", "filename": "libgo/go/encoding/csv/writer_test.go", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fcsv%2Fwriter_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -6,6 +6,7 @@ package csv\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"testing\"\n )\n \n@@ -42,3 +43,30 @@ func TestWrite(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+type errorWriter struct{}\n+\n+func (e errorWriter) Write(b []byte) (int, error) {\n+\treturn 0, errors.New(\"Test\")\n+}\n+\n+func TestError(t *testing.T) {\n+\tb := &bytes.Buffer{}\n+\tf := NewWriter(b)\n+\tf.Write([]string{\"abc\"})\n+\tf.Flush()\n+\terr := f.Error()\n+\n+\tif err != nil {\n+\t\tt.Errorf(\"Unexpected error: %s\\n\", err)\n+\t}\n+\n+\tf = NewWriter(errorWriter{})\n+\tf.Write([]string{\"abc\"})\n+\tf.Flush()\n+\terr = f.Error()\n+\n+\tif err == nil {\n+\t\tt.Error(\"Error should not be nil\")\n+\t}\n+}"}, {"sha": "a80d9f9195fd930c4c067c0c9786fe2593c13fa8", "filename": "libgo/go/encoding/gob/decode.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -62,15 +62,15 @@ func overflow(name string) error {\n // Used only by the Decoder to read the message length.\n func decodeUintReader(r io.Reader, buf []byte) (x uint64, width int, err error) {\n \twidth = 1\n-\t_, err = r.Read(buf[0:width])\n-\tif err != nil {\n+\tn, err := io.ReadFull(r, buf[0:width])\n+\tif n == 0 {\n \t\treturn\n \t}\n \tb := buf[0]\n \tif b <= 0x7f {\n \t\treturn uint64(b), width, nil\n \t}\n-\tn := -int(int8(b))\n+\tn = -int(int8(b))\n \tif n > uint64Size {\n \t\terr = errBadUint\n \t\treturn"}, {"sha": "b46dac96f5df8ef2821ec22a5f7c225d241640e2", "filename": "libgo/go/encoding/json/decode.go", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -125,13 +125,12 @@ func (d *decodeState) unmarshal(v interface{}) (err error) {\n \t}()\n \n \trv := reflect.ValueOf(v)\n-\tpv := rv\n-\tif pv.Kind() != reflect.Ptr || pv.IsNil() {\n+\tif rv.Kind() != reflect.Ptr || rv.IsNil() {\n \t\treturn &InvalidUnmarshalError{reflect.TypeOf(v)}\n \t}\n \n \td.scan.reset()\n-\t// We decode rv not pv.Elem because the Unmarshaler interface\n+\t// We decode rv not rv.Elem because the Unmarshaler interface\n \t// test must be applied at the top level of the value.\n \td.value(rv)\n \treturn d.savedError\n@@ -423,17 +422,12 @@ func (d *decodeState) object(v reflect.Value) {\n \tv = pv\n \n \t// Decoding into nil interface?  Switch to non-reflect code.\n-\tiv := v\n-\tif iv.Kind() == reflect.Interface {\n-\t\tiv.Set(reflect.ValueOf(d.objectInterface()))\n+\tif v.Kind() == reflect.Interface {\n+\t\tv.Set(reflect.ValueOf(d.objectInterface()))\n \t\treturn\n \t}\n \n \t// Check type of target: struct or map[string]T\n-\tvar (\n-\t\tmv reflect.Value\n-\t\tsv reflect.Value\n-\t)\n \tswitch v.Kind() {\n \tcase reflect.Map:\n \t\t// map must have string type\n@@ -442,17 +436,15 @@ func (d *decodeState) object(v reflect.Value) {\n \t\t\td.saveError(&UnmarshalTypeError{\"object\", v.Type()})\n \t\t\tbreak\n \t\t}\n-\t\tmv = v\n-\t\tif mv.IsNil() {\n-\t\t\tmv.Set(reflect.MakeMap(t))\n+\t\tif v.IsNil() {\n+\t\t\tv.Set(reflect.MakeMap(t))\n \t\t}\n \tcase reflect.Struct:\n-\t\tsv = v\n \tdefault:\n \t\td.saveError(&UnmarshalTypeError{\"object\", v.Type()})\n \t}\n \n-\tif !mv.IsValid() && !sv.IsValid() {\n+\tif !v.IsValid() {\n \t\td.off--\n \t\td.next() // skip over { } in input\n \t\treturn\n@@ -484,8 +476,8 @@ func (d *decodeState) object(v reflect.Value) {\n \t\tvar subv reflect.Value\n \t\tdestring := false // whether the value is wrapped in a string to be decoded first\n \n-\t\tif mv.IsValid() {\n-\t\t\telemType := mv.Type().Elem()\n+\t\tif v.Kind() == reflect.Map {\n+\t\t\telemType := v.Type().Elem()\n \t\t\tif !mapElem.IsValid() {\n \t\t\t\tmapElem = reflect.New(elemType).Elem()\n \t\t\t} else {\n@@ -494,7 +486,7 @@ func (d *decodeState) object(v reflect.Value) {\n \t\t\tsubv = mapElem\n \t\t} else {\n \t\t\tvar f *field\n-\t\t\tfields := cachedTypeFields(sv.Type())\n+\t\t\tfields := cachedTypeFields(v.Type())\n \t\t\tfor i := range fields {\n \t\t\t\tff := &fields[i]\n \t\t\t\tif ff.name == key {\n@@ -506,7 +498,7 @@ func (d *decodeState) object(v reflect.Value) {\n \t\t\t\t}\n \t\t\t}\n \t\t\tif f != nil {\n-\t\t\t\tsubv = sv\n+\t\t\t\tsubv = v\n \t\t\t\tdestring = f.quoted\n \t\t\t\tfor _, i := range f.index {\n \t\t\t\t\tif subv.Kind() == reflect.Ptr {\n@@ -519,7 +511,7 @@ func (d *decodeState) object(v reflect.Value) {\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// To give a good error, a quick scan for unexported fields in top level.\n-\t\t\t\tst := sv.Type()\n+\t\t\t\tst := v.Type()\n \t\t\t\tfor i := 0; i < st.NumField(); i++ {\n \t\t\t\t\tf := st.Field(i)\n \t\t\t\t\tif f.PkgPath != \"\" && strings.EqualFold(f.Name, key) {\n@@ -546,8 +538,8 @@ func (d *decodeState) object(v reflect.Value) {\n \t\t}\n \t\t// Write value back to map;\n \t\t// if using struct, subv points into struct already.\n-\t\tif mv.IsValid() {\n-\t\t\tmv.SetMapIndex(reflect.ValueOf(key), subv)\n+\t\tif v.Kind() == reflect.Map {\n+\t\t\tv.SetMapIndex(reflect.ValueOf(key), subv)\n \t\t}\n \n \t\t// Next token must be , or }."}, {"sha": "c0c2e329bfe2d0fc300d8ef7c612aab7a4c31b03", "filename": "libgo/go/exp/gotype/gotype_test.go", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -25,7 +25,9 @@ func runTest(t *testing.T, path string) {\n \t} else {\n \t\t// package directory\n \t\t// TODO(gri) gotype should use the build package instead\n-\t\tpkg, err := build.Import(path, \"\", 0)\n+\t\tctxt := build.Default\n+\t\tctxt.CgoEnabled = false\n+\t\tpkg, err := ctxt.Import(path, \"\", 0)\n \t\tif err != nil {\n \t\t\tt.Errorf(\"build.Import error for path = %s: %s\", path, err)\n \t\t\treturn\n@@ -50,7 +52,7 @@ var tests = []string{\n \n \t// directories\n \t// Note: packages that don't typecheck yet are commented out\n-\t// \"archive/tar\", // investigate\n+\t\"archive/tar\",\n \t\"archive/zip\",\n \n \t\"bufio\",\n@@ -77,13 +79,13 @@ var tests = []string{\n \t\"crypto/md5\",\n \t\"crypto/rand\",\n \t\"crypto/rc4\",\n-\t// \"crypto/rsa\", // investigate (GOARCH=386)\n+\t// \"crypto/rsa\", // intermittent failure: /home/gri/go2/src/pkg/crypto/rsa/pkcs1v15.go:21:27: undeclared name: io\n \t\"crypto/sha1\",\n \t\"crypto/sha256\",\n \t\"crypto/sha512\",\n \t\"crypto/subtle\",\n \t\"crypto/tls\",\n-\t// \"crypto/x509\", // investigate\n+\t\"crypto/x509\",\n \t\"crypto/x509/pkix\",\n \n \t\"database/sql\",\n@@ -99,9 +101,9 @@ var tests = []string{\n \t\"encoding/asn1\",\n \t\"encoding/base32\",\n \t\"encoding/base64\",\n-\t// \"encoding/binary\", // complex() doesn't work yet\n+\t\"encoding/binary\",\n \t\"encoding/csv\",\n-\t// \"encoding/gob\", // complex() doesn't work yet\n+\t\"encoding/gob\",\n \t\"encoding/hex\",\n \t\"encoding/json\",\n \t\"encoding/pem\",\n@@ -117,15 +119,15 @@ var tests = []string{\n \n \t\"go/ast\",\n \t\"go/build\",\n-\t// \"go/doc\", // variadic parameters don't work yet fully\n+\t\"go/doc\",\n \t\"go/format\",\n \t\"go/parser\",\n \t\"go/printer\",\n \t\"go/scanner\",\n \t\"go/token\",\n \n \t\"hash/adler32\",\n-\t// \"hash/crc32\", // investigate\n+\t\"hash/crc32\",\n \t\"hash/crc64\",\n \t\"hash/fnv\",\n \n@@ -139,65 +141,65 @@ var tests = []string{\n \t\"index/suffixarray\",\n \n \t\"io\",\n-\t// \"io/ioutil\", // investigate\n+\t\"io/ioutil\",\n \n \t\"log\",\n \t\"log/syslog\",\n \n \t\"math\",\n-\t// \"math/big\", // investigate\n-\t// \"math/cmplx\", // complex doesn't work yet\n+\t\"math/big\",\n+\t\"math/cmplx\",\n \t\"math/rand\",\n \n \t\"mime\",\n \t\"mime/multipart\",\n \n-\t// \"net\", // depends on C files\n+\t// \"net\", // c:\\go\\root\\src\\pkg\\net\\interface_windows.go:54:13: invalid operation: division by zero\n \t\"net/http\",\n \t\"net/http/cgi\",\n-\t// \"net/http/fcgi\", // investigate\n+\t\"net/http/fcgi\",\n \t\"net/http/httptest\",\n \t\"net/http/httputil\",\n-\t// \"net/http/pprof\", // investigate\n+\t\"net/http/pprof\",\n \t\"net/mail\",\n-\t// \"net/rpc\", // investigate\n+\t\"net/rpc\",\n \t\"net/rpc/jsonrpc\",\n \t\"net/smtp\",\n \t\"net/textproto\",\n \t\"net/url\",\n \n-\t// \"path\", // variadic parameters don't work yet fully\n-\t// \"path/filepath\", // investigate\n+\t\"path\",\n+\t\"path/filepath\",\n \n-\t// \"reflect\", // investigate\n+\t// \"reflect\", // unsafe.Sizeof must return size > 0 for pointer types\n \n \t\"regexp\",\n \t\"regexp/syntax\",\n \n \t\"runtime\",\n-\t// \"runtime/cgo\", // import \"C\"\n+\t\"runtime/cgo\",\n \t\"runtime/debug\",\n \t\"runtime/pprof\",\n \n \t\"sort\",\n-\t// \"strconv\", // investigate\n+\t// \"strconv\", // bug in switch case duplicate detection\n \t\"strings\",\n \n-\t// \"sync\", // platform-specific files\n-\t// \"sync/atomic\", // platform-specific files\n+\t\"sync\",\n+\t\"sync/atomic\",\n \n-\t// \"syscall\", // platform-specific files\n+\t// \"syscall\", c:\\go\\root\\src\\pkg\\syscall\\syscall_windows.go:35:16: cannot convert EINVAL (constant 536870951) to error\n \n \t\"testing\",\n \t\"testing/iotest\",\n \t\"testing/quick\",\n \n \t\"text/scanner\",\n \t\"text/tabwriter\",\n-\t// \"text/template\", // variadic parameters don't work yet fully\n-\t// \"text/template/parse\", // variadic parameters don't work yet fully\n+\t\"text/template\",\n+\t\"text/template/parse\",\n \n-\t// \"time\", // platform-specific files\n+\t// \"time\", // local const decls without initialization expressions\n \t\"unicode\",\n \t\"unicode/utf16\",\n \t\"unicode/utf8\","}, {"sha": "9404a3465bf410aa6aeeb2bc5027897231d98102", "filename": "libgo/go/exp/locale/collate/build/trie.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Ftrie.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Ftrie.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Flocale%2Fcollate%2Fbuild%2Ftrie.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -20,7 +20,7 @@ import (\n \n const (\n \tblockSize   = 64\n-\tblockOffset = 2 // Substract 2 blocks to compensate for the 0x80 added to continuation bytes.\n+\tblockOffset = 2 // Subtract 2 blocks to compensate for the 0x80 added to continuation bytes.\n )\n \n type trieHandle struct {"}, {"sha": "def822d8e1c34da4bd7f4e7582dee5a13a78b01e", "filename": "libgo/go/exp/norm/iter.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Fnorm%2Fiter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Fnorm%2Fiter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fiter.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -179,7 +179,7 @@ doNorm:\n \ti.rb.src.copySlice(out[outCopyStart:], inCopyStart, i.p)\n \tif !i.rb.insertDecomposed(out[i.outStart:outp]) {\n \t\t// Start over to prevent decompositions from crossing segment boundaries.\n-\t\t// This is a rare occurance.\n+\t\t// This is a rare occurrence.\n \t\ti.p = i.inStart\n \t\ti.info = i.rb.f.info(i.rb.src, i.p)\n \t}"}, {"sha": "1a118f2d14d12a90e09aaae47f7f94dd6f2e4a94", "filename": "libgo/go/exp/norm/normalize_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -31,7 +31,7 @@ func runPosTests(t *testing.T, name string, f Form, fn positionFunc, tests []Pos\n \t\t}\n \t\trunes := []rune(test.buffer)\n \t\tif rb.nrune != len(runes) {\n-\t\t\tt.Errorf(\"%s:%d: reorder buffer lenght is %d; want %d\", name, i, rb.nrune, len(runes))\n+\t\t\tt.Errorf(\"%s:%d: reorder buffer length is %d; want %d\", name, i, rb.nrune, len(runes))\n \t\t\tcontinue\n \t\t}\n \t\tfor j, want := range runes {"}, {"sha": "52c88b039a2495ebef7bbf2a8ff130c15e35940e", "filename": "libgo/go/exp/norm/triegen.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Fnorm%2Ftriegen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Fnorm%2Ftriegen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftriegen.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -21,7 +21,7 @@ import (\n \n const (\n \tblockSize        = 64\n-\tblockOffset      = 2 // Substract two blocks to compensate for the 0x80 added to continuation bytes.\n+\tblockOffset      = 2 // Subtract two blocks to compensate for the 0x80 added to continuation bytes.\n \tmaxSparseEntries = 16\n )\n "}, {"sha": "ed636ee2a4f148a179347def2166d307a515164a", "filename": "libgo/go/exp/types/builtins.go", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Fbuiltins.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Fbuiltins.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fbuiltins.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -128,13 +128,51 @@ func (check *checker) builtin(x *operand, call *ast.CallExpr, bin *builtin, iota\n \t\tx.mode = novalue\n \n \tcase _Complex:\n+\t\tif !check.complexArg(x) {\n+\t\t\tgoto Error\n+\t\t}\n+\n \t\tvar y operand\n \t\tcheck.expr(&y, args[1], nil, iota)\n \t\tif y.mode == invalid {\n \t\t\tgoto Error\n \t\t}\n-\t\t// TODO(gri) handle complex(a, b) like (a + toImag(b))\n-\t\tunimplemented()\n+\t\tif !check.complexArg(&y) {\n+\t\t\tgoto Error\n+\t\t}\n+\n+\t\tcheck.convertUntyped(x, y.typ)\n+\t\tif x.mode == invalid {\n+\t\t\tgoto Error\n+\t\t}\n+\t\tcheck.convertUntyped(&y, x.typ)\n+\t\tif y.mode == invalid {\n+\t\t\tgoto Error\n+\t\t}\n+\n+\t\tif !isIdentical(x.typ, y.typ) {\n+\t\t\tcheck.invalidArg(x.pos(), \"mismatched types %s and %s\", x.typ, y.typ)\n+\t\t\tgoto Error\n+\t\t}\n+\n+\t\ttyp := underlying(x.typ).(*Basic)\n+\t\tif x.mode == constant && y.mode == constant {\n+\t\t\tx.val = binaryOpConst(x.val, toImagConst(y.val), token.ADD, typ)\n+\t\t} else {\n+\t\t\tx.mode = value\n+\t\t}\n+\n+\t\tswitch typ.Kind {\n+\t\tcase Float32:\n+\t\t\tx.typ = Typ[Complex64]\n+\t\tcase Float64:\n+\t\t\tx.typ = Typ[Complex128]\n+\t\tcase UntypedInt, UntypedRune, UntypedFloat:\n+\t\t\tx.typ = Typ[UntypedComplex]\n+\t\tdefault:\n+\t\t\tcheck.invalidArg(x.pos(), \"float32 or float64 arguments expected\")\n+\t\t\tgoto Error\n+\t\t}\n \n \tcase _Copy:\n \t\t// TODO(gri) implements checks\n@@ -361,3 +399,12 @@ func unparen(x ast.Expr) ast.Expr {\n \t}\n \treturn x\n }\n+\n+func (check *checker) complexArg(x *operand) bool {\n+\tt, _ := underlying(x.typ).(*Basic)\n+\tif t != nil && (t.Info&IsFloat != 0 || t.Kind == UntypedInt || t.Kind == UntypedRune) {\n+\t\treturn true\n+\t}\n+\tcheck.invalidArg(x.pos(), \"%s must be a float32, float64, or an untyped non-complex numeric constant\", x)\n+\treturn false\n+}"}, {"sha": "d44c8fb61d22d12d37ffe1fad9e950c84b2465b6", "filename": "libgo/go/exp/types/const.go", "status": "modified", "additions": 99, "deletions": 27, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fconst.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -49,12 +49,17 @@ func (nilType) String() string {\n \treturn \"nil\"\n }\n \n-// Frequently used constants.\n+// Implementation-specific constants.\n+// TODO(gri) These need to go elsewhere.\n+const (\n+\tintBits = 32\n+\tptrBits = 64\n+)\n+\n+// Frequently used values.\n var (\n-\tzeroConst     = int64(0)\n-\toneConst      = int64(1)\n-\tminusOneConst = int64(-1)\n-\tnilConst      = nilType{}\n+\tnilConst  = nilType{}\n+\tzeroConst = int64(0)\n )\n \n // int64 bounds\n@@ -74,7 +79,7 @@ func normalizeIntConst(x *big.Int) interface{} {\n }\n \n // normalizeRatConst returns the smallest constant representation\n-// for the specific value of x; either an int64, *big.Int value,\n+// for the specific value of x; either an int64, *big.Int,\n // or *big.Rat value.\n //\n func normalizeRatConst(x *big.Rat) interface{} {\n@@ -84,15 +89,15 @@ func normalizeRatConst(x *big.Rat) interface{} {\n \treturn x\n }\n \n-// normalizeComplexConst returns the smallest constant representation\n-// for the specific value of x; either an int64, *big.Int value, *big.Rat,\n-// or complex value.\n+// newComplex returns the smallest constant representation\n+// for the specific value re + im*i; either an int64, *big.Int,\n+// *big.Rat, or complex value.\n //\n-func normalizeComplexConst(x complex) interface{} {\n-\tif x.im.Sign() == 0 {\n-\t\treturn normalizeRatConst(x.re)\n+func newComplex(re, im *big.Rat) interface{} {\n+\tif im.Sign() == 0 {\n+\t\treturn normalizeRatConst(re)\n \t}\n-\treturn x\n+\treturn complex{re, im}\n }\n \n // makeRuneConst returns the int64 code point for the rune literal\n@@ -140,7 +145,7 @@ func makeComplexConst(lit string) interface{} {\n \tn := len(lit)\n \tif n > 0 && lit[n-1] == 'i' {\n \t\tif im, ok := new(big.Rat).SetString(lit[0 : n-1]); ok {\n-\t\t\treturn normalizeComplexConst(complex{big.NewRat(0, 1), im})\n+\t\t\treturn newComplex(big.NewRat(0, 1), im)\n \t\t}\n \t}\n \treturn nil\n@@ -157,6 +162,22 @@ func makeStringConst(lit string) interface{} {\n \treturn nil\n }\n \n+// toImagConst returns the constant complex(0, x) for a non-complex x.\n+func toImagConst(x interface{}) interface{} {\n+\tvar im *big.Rat\n+\tswitch x := x.(type) {\n+\tcase int64:\n+\t\tim = big.NewRat(x, 1)\n+\tcase *big.Int:\n+\t\tim = new(big.Rat).SetFrac(x, int1)\n+\tcase *big.Rat:\n+\t\tim = x\n+\tdefault:\n+\t\tunreachable()\n+\t}\n+\treturn complex{rat0, im}\n+}\n+\n // isZeroConst reports whether the value of constant x is 0.\n // x must be normalized.\n //\n@@ -186,9 +207,6 @@ func isNegConst(x interface{}) bool {\n // of precision.\n //\n func isRepresentableConst(x interface{}, as BasicKind) bool {\n-\tconst intBits = 32 // TODO(gri) implementation-specific constant\n-\tconst ptrBits = 64 // TODO(gri) implementation-specific constant\n-\n \tswitch x := x.(type) {\n \tcase bool:\n \t\treturn as == Bool || as == UntypedBool\n@@ -370,13 +388,71 @@ func is63bit(x int64) bool {\n \treturn -1<<62 <= x && x <= 1<<62-1\n }\n \n+// unaryOpConst returns the result of the constant evaluation op x where x is of the given type.\n+func unaryOpConst(x interface{}, op token.Token, typ *Basic) interface{} {\n+\tswitch op {\n+\tcase token.ADD:\n+\t\treturn x // nothing to do\n+\tcase token.SUB:\n+\t\tswitch x := x.(type) {\n+\t\tcase int64:\n+\t\t\tif z := -x; z != x {\n+\t\t\t\treturn z // no overflow\n+\t\t\t}\n+\t\t\t// overflow - need to convert to big.Int\n+\t\t\treturn normalizeIntConst(new(big.Int).Neg(big.NewInt(x)))\n+\t\tcase *big.Int:\n+\t\t\treturn normalizeIntConst(new(big.Int).Neg(x))\n+\t\tcase *big.Rat:\n+\t\t\treturn normalizeRatConst(new(big.Rat).Neg(x))\n+\t\tcase complex:\n+\t\t\treturn newComplex(new(big.Rat).Neg(x.re), new(big.Rat).Neg(x.im))\n+\t\t}\n+\tcase token.XOR:\n+\t\tvar z big.Int\n+\t\tswitch x := x.(type) {\n+\t\tcase int64:\n+\t\t\tz.Not(big.NewInt(x))\n+\t\tcase *big.Int:\n+\t\t\tz.Not(x)\n+\t\tdefault:\n+\t\t\tunreachable()\n+\t\t}\n+\t\t// For unsigned types, the result will be negative and\n+\t\t// thus \"too large\": We must limit the result size to\n+\t\t// the type's size.\n+\t\tif typ.Info&IsUnsigned != 0 {\n+\t\t\ts := uint(typ.Size) * 8\n+\t\t\tif s == 0 {\n+\t\t\t\t// platform-specific type\n+\t\t\t\t// TODO(gri) this needs to be factored out\n+\t\t\t\tswitch typ.Kind {\n+\t\t\t\tcase Uint:\n+\t\t\t\t\ts = intBits\n+\t\t\t\tcase Uintptr:\n+\t\t\t\t\ts = ptrBits\n+\t\t\t\tdefault:\n+\t\t\t\t\tunreachable()\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t// z &^= (-1)<<s\n+\t\t\tz.AndNot(&z, new(big.Int).Lsh(big.NewInt(-1), s))\n+\t\t}\n+\t\treturn normalizeIntConst(&z)\n+\tcase token.NOT:\n+\t\treturn !x.(bool)\n+\t}\n+\tunreachable()\n+\treturn nil\n+}\n+\n // binaryOpConst returns the result of the constant evaluation x op y;\n-// both operands must be of the same \"kind\" (boolean, numeric, or string).\n-// If intDiv is true, division (op == token.QUO) is using integer division\n+// both operands must be of the same constant \"kind\" (boolean, numeric, or string).\n+// If typ is an integer type, division (op == token.QUO) is using integer division\n // (and the result is guaranteed to be integer) rather than floating-point\n // division. Division by zero leads to a run-time panic.\n //\n-func binaryOpConst(x, y interface{}, op token.Token, intDiv bool) interface{} {\n+func binaryOpConst(x, y interface{}, op token.Token, typ *Basic) interface{} {\n \tx, y = matchConst(x, y)\n \n \tswitch x := x.(type) {\n@@ -387,8 +463,6 @@ func binaryOpConst(x, y interface{}, op token.Token, intDiv bool) interface{} {\n \t\t\treturn x && y\n \t\tcase token.LOR:\n \t\t\treturn x || y\n-\t\tdefault:\n-\t\t\tunreachable()\n \t\t}\n \n \tcase int64:\n@@ -415,7 +489,7 @@ func binaryOpConst(x, y interface{}, op token.Token, intDiv bool) interface{} {\n \t\tcase token.REM:\n \t\t\treturn x % y\n \t\tcase token.QUO:\n-\t\t\tif intDiv {\n+\t\t\tif typ.Info&IsInteger != 0 {\n \t\t\t\treturn x / y\n \t\t\t}\n \t\t\treturn normalizeRatConst(new(big.Rat).SetFrac(big.NewInt(x), big.NewInt(y)))\n@@ -427,8 +501,6 @@ func binaryOpConst(x, y interface{}, op token.Token, intDiv bool) interface{} {\n \t\t\treturn x ^ y\n \t\tcase token.AND_NOT:\n \t\t\treturn x &^ y\n-\t\tdefault:\n-\t\t\tunreachable()\n \t\t}\n \n \tcase *big.Int:\n@@ -444,7 +516,7 @@ func binaryOpConst(x, y interface{}, op token.Token, intDiv bool) interface{} {\n \t\tcase token.REM:\n \t\t\tz.Rem(x, y)\n \t\tcase token.QUO:\n-\t\t\tif intDiv {\n+\t\t\tif typ.Info&IsInteger != 0 {\n \t\t\t\tz.Quo(x, y)\n \t\t\t} else {\n \t\t\t\treturn normalizeRatConst(new(big.Rat).SetFrac(x, y))\n@@ -517,7 +589,7 @@ func binaryOpConst(x, y interface{}, op token.Token, intDiv bool) interface{} {\n \t\tdefault:\n \t\t\tunreachable()\n \t\t}\n-\t\treturn normalizeComplexConst(complex{&re, &im})\n+\t\treturn newComplex(&re, &im)\n \n \tcase string:\n \t\tif op == token.ADD {"}, {"sha": "b1b6436968aaa90b684ffd6b5f73f4c04c04acbc", "filename": "libgo/go/exp/types/errors.go", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Ferrors.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Ferrors.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ferrors.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -266,15 +266,8 @@ func writeType(buf *bytes.Buffer, typ Type) {\n \t\tbuf.WriteByte('*')\n \t\twriteType(buf, t.Base)\n \n-\tcase *tuple:\n-\t\tbuf.WriteByte('(')\n-\t\tfor i, typ := range t.list {\n-\t\t\tif i > 0 {\n-\t\t\t\tbuf.WriteString(\"; \")\n-\t\t\t}\n-\t\t\twriteType(buf, typ)\n-\t\t}\n-\t\tbuf.WriteByte(')')\n+\tcase *Result:\n+\t\twriteParams(buf, t.Values, false)\n \n \tcase *Signature:\n \t\tbuf.WriteString(\"func\")"}, {"sha": "2f5f2b3f1ec6bde71466b6609874fa29928381d1", "filename": "libgo/go/exp/types/expr.go", "status": "modified", "additions": 112, "deletions": 44, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Fexpr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Fexpr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fexpr.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -19,7 +19,6 @@ import (\n // - at the moment, iota is passed around almost everywhere - in many places we know it cannot be used\n \n // TODO(gri) API issues\n-// - clients need access to result type information (tuples)\n // - clients need access to constant values\n // - clients need access to built-in type information\n \n@@ -212,21 +211,11 @@ func (check *checker) unary(x *operand, op token.Token) {\n \t}\n \n \tif x.mode == constant {\n-\t\tswitch op {\n-\t\tcase token.ADD:\n-\t\t\t// nothing to do\n-\t\tcase token.SUB:\n-\t\t\tx.val = binaryOpConst(zeroConst, x.val, token.SUB, false)\n-\t\tcase token.XOR:\n-\t\t\tx.val = binaryOpConst(minusOneConst, x.val, token.XOR, false)\n-\t\tcase token.NOT:\n-\t\t\tx.val = !x.val.(bool)\n-\t\tdefault:\n-\t\t\tunreachable() // operators where checked by check.op\n-\t\t}\n+\t\ttyp := underlying(x.typ).(*Basic)\n+\t\tx.val = unaryOpConst(x.val, op, typ)\n \t\t// Typed constants must be representable in\n \t\t// their type after each constant operation.\n-\t\tcheck.isRepresentable(x, underlying(x.typ).(*Basic))\n+\t\tcheck.isRepresentable(x, typ)\n \t\treturn\n \t}\n \n@@ -304,6 +293,8 @@ func (check *checker) convertUntyped(x *operand, target Type) {\n \t\tif !x.isNil() {\n \t\t\tgoto Error\n \t\t}\n+\tdefault:\n+\t\tunreachable()\n \t}\n \n \tx.typ = target\n@@ -332,7 +323,7 @@ func (check *checker) comparison(x, y *operand, op token.Token) {\n \t}\n \n \tif !valid {\n-\t\tcheck.invalidOp(x.pos(), \"cannot compare %s and %s\", x, y)\n+\t\tcheck.invalidOp(x.pos(), \"cannot compare %s %s %s\", x, op, y)\n \t\tx.mode = invalid\n \t\treturn\n \t}\n@@ -465,10 +456,11 @@ func (check *checker) binary(x, y *operand, op token.Token, hint Type) {\n \t}\n \n \tif x.mode == constant && y.mode == constant {\n-\t\tx.val = binaryOpConst(x.val, y.val, op, isInteger(x.typ))\n+\t\ttyp := underlying(x.typ).(*Basic)\n+\t\tx.val = binaryOpConst(x.val, y.val, op, typ)\n \t\t// Typed constants must be representable in\n \t\t// their type after each constant operation.\n-\t\tcheck.isRepresentable(x, underlying(x.typ).(*Basic))\n+\t\tcheck.isRepresentable(x, typ)\n \t\treturn\n \t}\n \n@@ -554,9 +546,15 @@ func (check *checker) indexedElts(elts []ast.Expr, typ Type, length int64, iota\n \treturn max\n }\n \n-func (check *checker) argument(sig *Signature, i int, arg ast.Expr) {\n+// argument typechecks passing an argument arg (if arg != nil) or\n+// x (if arg == nil) to the i'th parameter of the given signature.\n+// If passSlice is set, the argument is followed by ... in the call.\n+//\n+func (check *checker) argument(sig *Signature, i int, arg ast.Expr, x *operand, passSlice bool) {\n+\t// determine parameter\n \tvar par *ast.Object\n-\tif n := len(sig.Params); i < n {\n+\tn := len(sig.Params)\n+\tif i < n {\n \t\tpar = sig.Params[i]\n \t} else if sig.IsVariadic {\n \t\tpar = sig.Params[n-1]\n@@ -565,16 +563,32 @@ func (check *checker) argument(sig *Signature, i int, arg ast.Expr) {\n \t\treturn\n \t}\n \n-\t// TODO(gri) deal with ... last argument\n-\tvar z, x operand\n+\t// determine argument\n+\tvar z operand\n \tz.mode = variable\n-\tz.expr = nil            // TODO(gri) can we do better here?\n-\tz.typ = par.Type.(Type) // TODO(gri) should become something like checkObj(&z, ...) eventually\n-\tcheck.expr(&x, arg, z.typ, -1)\n+\tz.expr = nil // TODO(gri) can we do better here? (for good error messages)\n+\tz.typ = par.Type.(Type)\n+\n+\tif arg != nil {\n+\t\tcheck.expr(x, arg, z.typ, -1)\n+\t}\n \tif x.mode == invalid {\n \t\treturn // ignore this argument\n \t}\n-\tcheck.assignOperand(&z, &x)\n+\n+\t// check last argument of the form x...\n+\tif passSlice {\n+\t\tif i+1 != n {\n+\t\t\tcheck.errorf(x.pos(), \"can only use ... with matching parameter\")\n+\t\t\treturn // ignore this argument\n+\t\t}\n+\t\t// spec: \"If the final argument is assignable to a slice type []T,\n+\t\t// it may be passed unchanged as the value for a ...T parameter if\n+\t\t// the argument is followed by ...\"\n+\t\tz.typ = &Slice{Elt: z.typ} // change final parameter type to []T\n+\t}\n+\n+\tcheck.assignOperand(&z, x)\n }\n \n func (check *checker) recordType(x *operand) {\n@@ -584,7 +598,7 @@ func (check *checker) recordType(x *operand) {\n }\n \n // rawExpr typechecks expression e and initializes x with the expression\n-// value or type. If an error occured, x.mode is set to invalid.\n+// value or type. If an error occurred, x.mode is set to invalid.\n // A hint != nil is used as operand type for untyped shifted operands;\n // iota >= 0 indicates that the expression is part of a constant declaration.\n // cycleOk indicates whether it is ok for a type expression to refer to itself.\n@@ -653,7 +667,7 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t\tx.typ = obj.Type.(Type)\n \n \tcase *ast.Ellipsis:\n-\t\t// ellipses are handled explictly where they are legal\n+\t\t// ellipses are handled explicitly where they are legal\n \t\t// (array composite literals and parameter lists)\n \t\tcheck.errorf(e.Pos(), \"invalid use of '...'\")\n \t\tgoto Error\n@@ -1052,25 +1066,79 @@ func (check *checker) rawExpr(x *operand, e ast.Expr, hint Type, iota int, cycle\n \t\t\tcheck.conversion(x, e, x.typ, iota)\n \t\t} else if sig, ok := underlying(x.typ).(*Signature); ok {\n \t\t\t// check parameters\n-\t\t\t// TODO(gri)\n-\t\t\t// - deal with single multi-valued function arguments: f(g())\n-\t\t\t// - variadic functions only partially addressed\n-\t\t\tfor i, arg := range e.Args {\n-\t\t\t\tcheck.argument(sig, i, arg)\n+\n+\t\t\t// If we have a trailing ... at the end of the parameter\n+\t\t\t// list, the last argument must match the parameter type\n+\t\t\t// []T of a variadic function parameter x ...T.\n+\t\t\tpassSlice := false\n+\t\t\tif e.Ellipsis.IsValid() {\n+\t\t\t\tif sig.IsVariadic {\n+\t\t\t\t\tpassSlice = true\n+\t\t\t\t} else {\n+\t\t\t\t\tcheck.errorf(e.Ellipsis, \"cannot use ... in call to %s\", e.Fun)\n+\t\t\t\t\t// ok to continue\n+\t\t\t\t}\n \t\t\t}\n \n-\t\t\t// determine result\n-\t\t\tx.mode = value\n-\t\t\tif len(sig.Results) == 1 {\n-\t\t\t\tx.typ = sig.Results[0].Type.(Type)\n+\t\t\t// If we have a single argument that is a function call\n+\t\t\t// we need to handle it separately. Determine if this\n+\t\t\t// is the case without checking the argument.\n+\t\t\tvar call *ast.CallExpr\n+\t\t\tif len(e.Args) == 1 {\n+\t\t\t\tcall, _ = unparen(e.Args[0]).(*ast.CallExpr)\n+\t\t\t}\n+\n+\t\t\tn := 0 // parameter count\n+\t\t\tif call != nil {\n+\t\t\t\t// We have a single argument that is a function call.\n+\t\t\t\tcheck.expr(x, call, nil, -1)\n+\t\t\t\tif x.mode == invalid {\n+\t\t\t\t\tgoto Error // TODO(gri): we can do better\n+\t\t\t\t}\n+\t\t\t\tif t, _ := x.typ.(*Result); t != nil {\n+\t\t\t\t\t// multiple result values\n+\t\t\t\t\tn = len(t.Values)\n+\t\t\t\t\tfor i, obj := range t.Values {\n+\t\t\t\t\t\tx.mode = value\n+\t\t\t\t\t\tx.expr = nil // TODO(gri) can we do better here? (for good error messages)\n+\t\t\t\t\t\tx.typ = obj.Type.(Type)\n+\t\t\t\t\t\tcheck.argument(sig, i, nil, x, passSlice && i+1 == n)\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\t// single result value\n+\t\t\t\t\tn = 1\n+\t\t\t\t\tcheck.argument(sig, 0, nil, x, passSlice)\n+\t\t\t\t}\n+\n \t\t\t} else {\n-\t\t\t\t// TODO(gri) change Signature representation to use tuples,\n-\t\t\t\t//           then this conversion is not required\n-\t\t\t\tlist := make([]Type, len(sig.Results))\n-\t\t\t\tfor i, obj := range sig.Results {\n-\t\t\t\t\tlist[i] = obj.Type.(Type)\n+\t\t\t\t// We don't have a single argument or it is not a function call.\n+\t\t\t\tn = len(e.Args)\n+\t\t\t\tfor i, arg := range e.Args {\n+\t\t\t\t\tcheck.argument(sig, i, arg, x, passSlice && i+1 == n)\n \t\t\t\t}\n-\t\t\t\tx.typ = &tuple{list: list}\n+\t\t\t}\n+\n+\t\t\t// determine if we have enough arguments\n+\t\t\tif sig.IsVariadic {\n+\t\t\t\t// a variadic function accepts an \"empty\"\n+\t\t\t\t// last argument: count one extra\n+\t\t\t\tn++\n+\t\t\t}\n+\t\t\tif n < len(sig.Params) {\n+\t\t\t\tcheck.errorf(e.Fun.Pos(), \"too few arguments in call to %s\", e.Fun)\n+\t\t\t\t// ok to continue\n+\t\t\t}\n+\n+\t\t\t// determine result\n+\t\t\tswitch len(sig.Results) {\n+\t\t\tcase 0:\n+\t\t\t\tx.mode = novalue\n+\t\t\tcase 1:\n+\t\t\t\tx.mode = value\n+\t\t\t\tx.typ = sig.Results[0].Type.(Type)\n+\t\t\tdefault:\n+\t\t\t\tx.mode = value\n+\t\t\t\tx.typ = &Result{Values: sig.Results}\n \t\t\t}\n \n \t\t} else if bin, ok := x.typ.(*builtin); ok {\n@@ -1216,14 +1284,14 @@ func (check *checker) rawTyp(e ast.Expr, cycleOk, nilOk bool) Type {\n }\n \n // typOrNil is like rawExpr but reports an error if e doesn't represents a type or the predeclared value nil.\n-// It returns e's type, nil, or Typ[Invalid] if an error occured.\n+// It returns e's type, nil, or Typ[Invalid] if an error occurred.\n //\n func (check *checker) typOrNil(e ast.Expr, cycleOk bool) Type {\n \treturn check.rawTyp(e, cycleOk, true)\n }\n \n // typ is like rawExpr but reports an error if e doesn't represents a type.\n-// It returns e's type, or Typ[Invalid] if an error occured.\n+// It returns e's type, or Typ[Invalid] if an error occurred.\n //\n func (check *checker) typ(e ast.Expr, cycleOk bool) Type {\n \treturn check.rawTyp(e, cycleOk, false)"}, {"sha": "f8ddd84b5426aceb68ae6902299f9d2a30d235ba", "filename": "libgo/go/exp/types/operand.go", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Foperand.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Foperand.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Foperand.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -182,7 +182,14 @@ func (x *operand) isAssignable(T Type) bool {\n \tif isUntyped(Vu) {\n \t\tswitch t := Tu.(type) {\n \t\tcase *Basic:\n-\t\t\treturn x.mode == constant && isRepresentableConst(x.val, t.Kind)\n+\t\t\tif x.mode == constant {\n+\t\t\t\treturn isRepresentableConst(x.val, t.Kind)\n+\t\t\t}\n+\t\t\t// The result of a comparison is an untyped boolean,\n+\t\t\t// but may not be a constant.\n+\t\t\tif Vb, _ := Vu.(*Basic); Vb != nil {\n+\t\t\t\treturn Vb.Kind == UntypedBool && isBoolean(Tu)\n+\t\t\t}\n \t\tcase *Interface:\n \t\t\treturn x.isNil() || len(t.Methods) == 0\n \t\tcase *Pointer, *Signature, *Slice, *Map, *Chan:"}, {"sha": "ff6825ba3b44ac99bbf6201bb582e39b89100995", "filename": "libgo/go/exp/types/predicates.go", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Fpredicates.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Fpredicates.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fpredicates.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -225,25 +225,28 @@ func deref(typ Type) Type {\n }\n \n // defaultType returns the default \"typed\" type for an \"untyped\" type;\n-// it returns the argument typ for all other types.\n+// it returns the incoming type for all other types. If there is no\n+// corresponding untyped type, the result is Typ[Invalid].\n+//\n func defaultType(typ Type) Type {\n \tif t, ok := typ.(*Basic); ok {\n-\t\tvar k BasicKind\n+\t\tk := Invalid\n \t\tswitch t.Kind {\n+\t\t// case UntypedNil:\n+\t\t//      There is no default type for nil. For a good error message,\n+\t\t//      catch this case before calling this function.\n \t\tcase UntypedBool:\n \t\t\tk = Bool\n-\t\tcase UntypedRune:\n-\t\t\tk = Rune\n \t\tcase UntypedInt:\n \t\t\tk = Int\n+\t\tcase UntypedRune:\n+\t\t\tk = Rune\n \t\tcase UntypedFloat:\n \t\t\tk = Float64\n \t\tcase UntypedComplex:\n \t\t\tk = Complex128\n \t\tcase UntypedString:\n \t\t\tk = String\n-\t\tdefault:\n-\t\t\tunreachable()\n \t\t}\n \t\ttyp = Typ[k]\n \t}"}, {"sha": "7f9d45eb9874edfff6232af2c1a6364720095577", "filename": "libgo/go/exp/types/stmt.go", "status": "modified", "additions": 55, "deletions": 17, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Fstmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Fstmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fstmt.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -12,9 +12,9 @@ import (\n )\n \n func (check *checker) assignOperand(z, x *operand) {\n-\tif t, ok := x.typ.(*tuple); ok {\n+\tif t, ok := x.typ.(*Result); ok {\n \t\t// TODO(gri) elsewhere we use \"assignment count mismatch\" (consolidate)\n-\t\tcheck.errorf(x.pos(), \"%d-valued expression %s used as single value\", len(t.list), x)\n+\t\tcheck.errorf(x.pos(), \"%d-valued expression %s used as single value\", len(t.Values), x)\n \t\tx.mode = invalid\n \t\treturn\n \t}\n@@ -95,7 +95,12 @@ func (check *checker) assign1to1(lhs, rhs ast.Expr, x *operand, decl bool, iota\n \t\tif x.mode != invalid {\n \t\t\ttyp = x.typ\n \t\t\tif obj.Kind == ast.Var && isUntyped(typ) {\n-\t\t\t\ttyp = defaultType(typ)\n+\t\t\t\tif x.isNil() {\n+\t\t\t\t\tcheck.errorf(x.pos(), \"use of untyped nil\")\n+\t\t\t\t\tx.mode = invalid\n+\t\t\t\t} else {\n+\t\t\t\t\ttyp = defaultType(typ)\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tobj.Type = typ\n@@ -177,12 +182,12 @@ func (check *checker) assignNtoM(lhs, rhs []ast.Expr, decl bool, iota int) {\n \t\t\treturn\n \t\t}\n \n-\t\tif t, ok := x.typ.(*tuple); ok && len(lhs) == len(t.list) {\n+\t\tif t, ok := x.typ.(*Result); ok && len(lhs) == len(t.Values) {\n \t\t\t// function result\n \t\t\tx.mode = value\n-\t\t\tfor i, typ := range t.list {\n+\t\t\tfor i, obj := range t.Values {\n \t\t\t\tx.expr = nil // TODO(gri) should do better here\n-\t\t\t\tx.typ = typ\n+\t\t\t\tx.typ = obj.Type.(Type)\n \t\t\t\tcheck.assign1to1(lhs[i], nil, &x, decl, iota)\n \t\t\t}\n \t\t\treturn\n@@ -427,25 +432,58 @@ func (check *checker) stmt(s ast.Stmt) {\n \tcase *ast.SwitchStmt:\n \t\tcheck.optionalStmt(s.Init)\n \t\tvar x operand\n-\t\tif s.Tag != nil {\n-\t\t\tcheck.expr(&x, s.Tag, nil, -1)\n-\t\t} else {\n-\t\t\t// TODO(gri) should provide a position (see IncDec) for good error messages\n-\t\t\tx.mode = constant\n-\t\t\tx.typ = Typ[UntypedBool]\n-\t\t\tx.val = true\n+\t\ttag := s.Tag\n+\t\tif tag == nil {\n+\t\t\t// use fake true tag value and position it at the opening { of the switch\n+\t\t\ttag = &ast.Ident{NamePos: s.Body.Lbrace, Name: \"true\", Obj: Universe.Lookup(\"true\")}\n \t\t}\n+\t\tcheck.expr(&x, tag, nil, -1)\n \n \t\tcheck.multipleDefaults(s.Body.List)\n+\t\tseen := make(map[interface{}]token.Pos)\n \t\tfor _, s := range s.Body.List {\n \t\t\tclause, _ := s.(*ast.CaseClause)\n \t\t\tif clause == nil {\n \t\t\t\tcontinue // error reported before\n \t\t\t}\n-\t\t\tfor _, expr := range clause.List {\n-\t\t\t\tvar y operand\n-\t\t\t\tcheck.expr(&y, expr, nil, -1)\n-\t\t\t\t// TODO(gri) x and y must be comparable\n+\t\t\tif x.mode != invalid {\n+\t\t\t\tfor _, expr := range clause.List {\n+\t\t\t\t\tx := x // copy of x (don't modify original)\n+\t\t\t\t\tvar y operand\n+\t\t\t\t\tcheck.expr(&y, expr, nil, -1)\n+\t\t\t\t\tif y.mode == invalid {\n+\t\t\t\t\t\tcontinue // error reported before\n+\t\t\t\t\t}\n+\t\t\t\t\t// If we have a constant case value, it must appear only\n+\t\t\t\t\t// once in the switch statement. Determine if there is a\n+\t\t\t\t\t// duplicate entry, but only report an error if there are\n+\t\t\t\t\t// no other errors.\n+\t\t\t\t\tvar dupl token.Pos\n+\t\t\t\t\tif y.mode == constant {\n+\t\t\t\t\t\t// TODO(gri) This code doesn't work correctly for\n+\t\t\t\t\t\t//           large integer, floating point, or\n+\t\t\t\t\t\t//           complex values - the respective struct\n+\t\t\t\t\t\t//           comparisons are shallow. Need to use a\n+\t\t\t\t\t\t//           hash function to index the map.\n+\t\t\t\t\t\tdupl = seen[y.val]\n+\t\t\t\t\t\tseen[y.val] = y.pos()\n+\t\t\t\t\t}\n+\t\t\t\t\t// TODO(gri) The convertUntyped call pair below appears in other places. Factor!\n+\t\t\t\t\t// Order matters: By comparing y against x, error positions are at the case values.\n+\t\t\t\t\tcheck.convertUntyped(&y, x.typ)\n+\t\t\t\t\tif y.mode == invalid {\n+\t\t\t\t\t\tcontinue // error reported before\n+\t\t\t\t\t}\n+\t\t\t\t\tcheck.convertUntyped(&x, y.typ)\n+\t\t\t\t\tif x.mode == invalid {\n+\t\t\t\t\t\tcontinue // error reported before\n+\t\t\t\t\t}\n+\t\t\t\t\tcheck.comparison(&y, &x, token.EQL)\n+\t\t\t\t\tif y.mode != invalid && dupl.IsValid() {\n+\t\t\t\t\t\tcheck.errorf(y.pos(), \"%s is duplicate case (previous at %s)\",\n+\t\t\t\t\t\t\t&y, check.fset.Position(dupl))\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t}\n \t\t\tcheck.stmtList(clause.Body)\n \t\t}"}, {"sha": "a9518530decb76ff55e6dc2070d08a0a528bb5ce", "filename": "libgo/go/exp/types/testdata/builtins.src", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fbuiltins.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fbuiltins.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fbuiltins.src?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -46,10 +46,33 @@ func _close() {\n }\n \n func _complex() {\n-\t_0 := complex /* ERROR \"argument\" */ ()\n-\t_1 := complex /* ERROR \"argument\" */ (1)\n-\t_2 := complex(1, 2)\n-\t// TODO(gri) add tests checking types\n+\tvar i32 int32\n+\tvar f32 float32\n+\tvar f64 float64\n+\tvar c64 complex64\n+\t_ = complex /* ERROR \"argument\" */ ()\n+\t_ = complex /* ERROR \"argument\" */ (1)\n+\t_ = complex(true /* ERROR \"invalid argument\" */ , 0)\n+\t_ = complex(i32 /* ERROR \"invalid argument\" */ , 0)\n+\t_ = complex(\"foo\" /* ERROR \"invalid argument\" */ , 0)\n+\t_ = complex(c64 /* ERROR \"invalid argument\" */ , 0)\n+\t_ = complex(0, true /* ERROR \"invalid argument\" */ )\n+\t_ = complex(0, i32 /* ERROR \"invalid argument\" */ )\n+\t_ = complex(0, \"foo\" /* ERROR \"invalid argument\" */ )\n+\t_ = complex(0, c64 /* ERROR \"invalid argument\" */ )\n+\t_ = complex(f32, f32)\n+\t_ = complex(f32, 1)\n+\t_ = complex(f32, 1.0)\n+\t_ = complex(f32, 'a')\n+\t_ = complex(f64, f64)\n+\t_ = complex(f64, 1)\n+\t_ = complex(f64, 1.0)\n+\t_ = complex(f64, 'a')\n+\t_ = complex(f32 /* ERROR \"mismatched types\" */, f64)\n+\t_ = complex(f64 /* ERROR \"mismatched types\" */, f32)\n+\t_ = complex(1, 1)\n+\t_ = complex(1, 1.1)\n+\t_ = complex(1, 'a')\n \tcomplex /* ERROR \"not used\" */ (1, 2)\n }\n "}, {"sha": "3baed67505cfed4d6e1f5cf4659b37f7a7949b98", "filename": "libgo/go/exp/types/testdata/decls1.src", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fdecls1.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fdecls1.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fdecls1.src?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -46,7 +46,7 @@ var (\n \ts14 = i << j /* ERROR \"must be unsigned\" */ \n \ts18 = math.Pi * 10.0\n \ts19 = s1 /* ERROR \"cannot call\" */ ()\n- \ts20 = f0 /* ERROR \"used as single value\" */ ()\n+ \ts20 = f0 /* ERROR \"no value\" */ ()\n \ts21 = f6(1, s1, i)\n \ts22 = f6(1, s1, uu /* ERROR \"cannot assign\" */ )\n \t\n@@ -68,7 +68,7 @@ var (\n \tt17 math /* ERROR \"not a type\" */ .Pi\n \tt18 float64 = math.Pi * 10.0\n \tt19 int = t1 /* ERROR \"cannot call\" */ ()\n-\tt20 int = f0 /* ERROR \"used as single value\" */ ()\n+\tt20 int = f0 /* ERROR \"no value\" */ ()\n )\n \n // Various more complex expressions\n@@ -94,6 +94,7 @@ var (\n \tv10 byte = 1024 /* ERROR \"overflows\" */\n \tv11 = xx/yy*yy - xx\n \tv12 = true && false\n+\tv13 = nil /* ERROR \"use of untyped nil\" */\n )\n \n // Multiple assignment expressions"}, {"sha": "8b2eb04f292b95b49114909eb6485d50be340bcc", "filename": "libgo/go/exp/types/testdata/expr0.src", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr0.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr0.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr0.src?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -63,6 +63,7 @@ var (\n \tu16 = &u0\n \tu17 = *u16\n \tu18 = <-u16 /* ERROR \"cannot receive\" */\n+\tu19 = ^uint(0)\n \n \t// float64\n \tf0 = float64(1)\n@@ -131,5 +132,4 @@ var (\n \tch7 = <-ch\n \tch8 = <-rc\n \tch9 = <-sc /* ERROR \"cannot receive\" */\n-\n-)\n\\ No newline at end of file\n+)"}, {"sha": "674be4005dd5c0a34c394a003d33f0de17a77c9b", "filename": "libgo/go/exp/types/testdata/expr2.src", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr2.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr2.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr2.src?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -6,6 +6,17 @@\n \n package expr2\n \n+func _bool() {\n+\tconst t = true == true\n+\tconst f = true == false\n+\t_ = t /* ERROR \"cannot compare\" */ < f\n+\t_ = 0 /* ERROR \"cannot convert\" */ == t\n+\tvar b bool\n+\tvar x, y float32\n+\tb = x < y\n+\t_ = struct{b bool}{x < y}\n+}\n+\n // corner cases\n var (\n \tv0 = nil /* ERROR \"cannot compare\" */ == nil"}, {"sha": "35905c4972022df284807c695c659ffdf3f4c3d3", "filename": "libgo/go/exp/types/testdata/expr3.src", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr3.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr3.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexpr3.src?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -286,3 +286,64 @@ func type_asserts() {\n \t_ = t.(T2 /* ERROR \"wrong type for method m\" */ )\n \t_ = t.(I2 /* ERROR \"wrong type for method m\" */ )\n }\n+\n+func f0() {}\n+func f1(x int) {}\n+func f2(u float32, s string) {}\n+func fs(s []byte) {}\n+func fv(x ...int) {}\n+func fi(x ... interface{}) {}\n+\n+func g0() {}\n+func g1() int { return 0}\n+func g2() (u float32, s string) { return }\n+func gs() []byte { return nil }\n+\n+func _calls() {\n+\tvar x int\n+\tvar y float32\n+\tvar s []int\n+\n+\tf0()\n+\t_ = f0 /* ERROR \"used as value\" */ ()\n+\tf0(g0 /* ERROR \"too many arguments\" */ )\n+\n+\tf1(0)\n+\tf1(x)\n+\tf1(10.0)\n+\tf1 /* ERROR \"too few arguments\" */ ()\n+\tf1(x, y /* ERROR \"too many arguments\" */ )\n+\tf1(s /* ERROR \"cannot assign\" */ )\n+\tf1(x ... /* ERROR \"cannot use ...\" */ )\n+\tf1(g0 /* ERROR \"used as value\" */ ())\n+\tf1(g1())\n+\t// f1(g2()) // TODO(gri) missing position in error message\n+\n+\tf2 /* ERROR \"too few arguments\" */ ()\n+\tf2 /* ERROR \"too few arguments\" */ (3.14)\n+\tf2(3.14, \"foo\")\n+\tf2(x /* ERROR \"cannot assign\" */ , \"foo\")\n+\tf2(g0 /* ERROR \"used as value\" */ ())\n+\tf2 /* ERROR \"too few arguments\" */ (g1 /* ERROR \"cannot assign\" */ ())\n+\tf2(g2())\n+\n+\tfs /* ERROR \"too few arguments\" */ ()\n+\tfs(g0 /* ERROR \"used as value\" */ ())\n+\tfs(g1 /* ERROR \"cannot assign\" */ ())\n+\t// fs(g2()) // TODO(gri) missing position in error message\n+\tfs(gs())\n+\n+\tfv()\n+\tfv(1, 2.0, x)\n+\tfv(s /* ERROR \"cannot assign\" */ )\n+\tfv(s...)\n+\tfv(1, s /* ERROR \"can only use ... with matching parameter\" */ ...)\n+\tfv(gs /* ERROR \"cannot assign\" */ ())\n+\tfv(gs /* ERROR \"cannot assign\" */ ()...)\n+\n+\tfi()\n+\tfi(1, 2.0, x, 3.14, \"foo\")\n+\tfi(g2())\n+\tfi(0, g2)\n+\tfi(0, g2 /* ERROR \"2-valued expression\" */ ())\n+}\n\\ No newline at end of file"}, {"sha": "c0e023671bc8bb89f3a2ab9153434f000b32a266", "filename": "libgo/go/exp/types/testdata/stmt0.src", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fstmt0.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fstmt0.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fstmt0.src?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -101,7 +101,31 @@ func _switches() {\n \tdefault /* ERROR \"multiple defaults\" */ :\n \t}\n \n-\t// TODO(gri) more tests\n+\tswitch {\n+\tcase 1  /* ERROR \"cannot convert\" */ :\n+\t}\n+\n+\tswitch int32(x) {\n+\tcase 1, 2:\n+\tcase x /* ERROR \"cannot compare\" */ :\n+\t}\n+\n+\tswitch x {\n+\tcase 1 /* ERROR \"overflows int\" */ << 100:\n+\t}\n+\n+\tswitch x {\n+\tcase 1:\n+\tcase 1 /* ERROR \"duplicate case\" */ :\n+\tcase 2, 3, 4:\n+\tcase 1 /* ERROR \"duplicate case\" */ :\n+\t}\n+\n+\t// TODO(gri) duplicate 64bit values that don't fit into an int64 are not yet detected\n+\tswitch uint64(x) {\n+\tcase 1<<64-1:\n+\tcase 1<<64-1:\n+\t}\n }\n \n type I interface {"}, {"sha": "6e4a98783eed6323626af20bf3bc83d753b71637", "filename": "libgo/go/exp/types/types.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -141,15 +141,15 @@ type Pointer struct {\n \tBase Type\n }\n \n-// A tuple represents a multi-value function return.\n-// TODO(gri) use better name to avoid confusion (Go doesn't have tuples).\n-type tuple struct {\n+// A Result represents a (multi-value) function call result.\n+// TODO(gri) consider using an empty Result (Values == nil)\n+//           as representation for the novalue operand mode.\n+type Result struct {\n \timplementsType\n-\tlist []Type\n+\tValues ObjList // Signature.Results of the function called\n }\n \n // A Signature represents a user-defined function type func(...) (...).\n-// TODO(gri) consider using \"tuples\" to represent parameters and results (see comment on tuples).\n type Signature struct {\n \timplementsType\n \tRecv       *ast.Object // nil if not a method"}, {"sha": "361f63634e556c4a10885af2a770f531a679613e", "filename": "libgo/go/exp/types/types_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -155,7 +155,7 @@ var testExprs = []testEntry{\n \tdup(\"-f(10, 20)\"),\n \tdup(\"f(x + y, +3.1415)\"),\n \t{\"func(a, b int) {}\", \"(func literal)\"},\n-\t{\"func(a, b int) []int {}()[x]\", \"(func literal)()[x]\"},\n+\t{\"func(a, b int) []int {}(1, 2)[x]\", \"(func literal)(1, 2)[x]\"},\n \t{\"[]int{1, 2, 3}\", \"(composite literal)\"},\n \t{\"[]int{1, 2, 3}[x:]\", \"(composite literal)[x:]\"},\n \t{\"i.([]string)\", \"i.(...)\"},"}, {"sha": "ab064658d7c39a4e1896955031b0be6025a801c9", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -476,6 +476,11 @@ var fmttests = []struct {\n \n \t// Used to crash because nByte didn't allow for a sign.\n \t{\"%b\", int64(-1 << 63), \"-1000000000000000000000000000000000000000000000000000000000000000\"},\n+\n+\t// Complex fmt used to leave the plus flag set for future entries in the array\n+\t// causing +2+0i and +3+0i instead of 2+0i and 3+0i.\n+\t{\"%v\", []complex64{1, 2, 3}, \"[(1+0i) (2+0i) (3+0i)]\"},\n+\t{\"%v\", []complex128{1, 2, 3}, \"[(1+0i) (2+0i) (3+0i)]\"},\n }\n \n func TestSprintf(t *testing.T) {"}, {"sha": "c3d7605fe8e5fbc140c9f7c704c74d5edd13c930", "filename": "libgo/go/fmt/format.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Ffmt%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Ffmt%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fformat.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -396,7 +396,7 @@ func (f *fmt) fmt_f64(v float64) { f.formatFloat(v, 'f', doPrec(f, 6), 64) }\n // fmt_g64 formats a float64 in the 'f' or 'e' form according to size.\n func (f *fmt) fmt_g64(v float64) { f.formatFloat(v, 'g', doPrec(f, -1), 64) }\n \n-// fmt_g64 formats a float64 in the 'f' or 'E' form according to size.\n+// fmt_G64 formats a float64 in the 'f' or 'E' form according to size.\n func (f *fmt) fmt_G64(v float64) { f.formatFloat(v, 'G', doPrec(f, -1), 64) }\n \n // fmt_fb64 formats a float64 in the form -123p3 (exponent is power of 2).\n@@ -428,6 +428,7 @@ func (f *fmt) fmt_fb32(v float32) { f.formatFloat(float64(v), 'b', 0, 32) }\n func (f *fmt) fmt_c64(v complex64, verb rune) {\n \tf.buf.WriteByte('(')\n \tr := real(v)\n+\toldPlus := f.plus\n \tfor i := 0; ; i++ {\n \t\tswitch verb {\n \t\tcase 'e':\n@@ -447,13 +448,15 @@ func (f *fmt) fmt_c64(v complex64, verb rune) {\n \t\tf.plus = true\n \t\tr = imag(v)\n \t}\n+\tf.plus = oldPlus\n \tf.buf.Write(irparenBytes)\n }\n \n // fmt_c128 formats a complex128 according to the verb.\n func (f *fmt) fmt_c128(v complex128, verb rune) {\n \tf.buf.WriteByte('(')\n \tr := real(v)\n+\toldPlus := f.plus\n \tfor i := 0; ; i++ {\n \t\tswitch verb {\n \t\tcase 'e':\n@@ -473,5 +476,6 @@ func (f *fmt) fmt_c128(v complex128, verb rune) {\n \t\tf.plus = true\n \t\tr = imag(v)\n \t}\n+\tf.plus = oldPlus\n \tf.buf.Write(irparenBytes)\n }"}, {"sha": "6a282c81f1dcebaf27ca6a57f2b366aa6c1ad4ec", "filename": "libgo/go/fmt/scan.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Ffmt%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Ffmt%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -337,7 +337,10 @@ func (r *readRune) readByte() (b byte, err error) {\n \t\tr.pending--\n \t\treturn\n \t}\n-\t_, err = r.reader.Read(r.pendBuf[0:1])\n+\tn, err := io.ReadFull(r.reader, r.pendBuf[0:1])\n+\tif n != 1 {\n+\t\treturn 0, err\n+\t}\n \treturn r.pendBuf[0], err\n }\n "}, {"sha": "bf533d1d24faf8cfd66d19ccbfb7c9a40ceaff75", "filename": "libgo/go/go/ast/ast.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fast.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -555,7 +555,7 @@ type (\n \n \t// A DeclStmt node represents a declaration in a statement list.\n \tDeclStmt struct {\n-\t\tDecl Decl\n+\t\tDecl Decl // *GenDecl with CONST, TYPE, or VAR token\n \t}\n \n \t// An EmptyStmt node represents an empty statement."}, {"sha": "a1644256819b9a153c12a4912520e68a2c50dec6", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -222,6 +222,8 @@ var cgoEnabled = map[string]bool{\n \t\"linux/arm\":     true,\n \t\"netbsd/386\":    true,\n \t\"netbsd/amd64\":  true,\n+\t\"openbsd/386\":   true,\n+\t\"openbsd/amd64\": true,\n \t\"windows/386\":   true,\n \t\"windows/amd64\": true,\n }\n@@ -424,6 +426,13 @@ func (ctxt *Context) Import(path string, srcDir string, mode ImportMode) (*Packa\n \t\tif strings.HasPrefix(path, \"/\") {\n \t\t\treturn p, fmt.Errorf(\"import %q: cannot import absolute path\", path)\n \t\t}\n+\n+\t\t// tried records the location of unsucsessful package lookups\n+\t\tvar tried struct {\n+\t\t\tgoroot string\n+\t\t\tgopath []string\n+\t\t}\n+\n \t\t// Determine directory from import path.\n \t\tif ctxt.GOROOT != \"\" {\n \t\t\tdir := ctxt.joinPath(ctxt.GOROOT, \"src\", \"pkg\", path)\n@@ -435,6 +444,7 @@ func (ctxt *Context) Import(path string, srcDir string, mode ImportMode) (*Packa\n \t\t\t\tp.Root = ctxt.GOROOT\n \t\t\t\tgoto Found\n \t\t\t}\n+\t\t\ttried.goroot = dir\n \t\t}\n \t\tfor _, root := range ctxt.gopath() {\n \t\t\tdir := ctxt.joinPath(root, \"src\", path)\n@@ -445,8 +455,28 @@ func (ctxt *Context) Import(path string, srcDir string, mode ImportMode) (*Packa\n \t\t\t\tp.Root = root\n \t\t\t\tgoto Found\n \t\t\t}\n+\t\t\ttried.gopath = append(tried.gopath, dir)\n+\t\t}\n+\n+\t\t// package was not found\n+\t\tvar paths []string\n+\t\tif tried.goroot != \"\" {\n+\t\t\tpaths = append(paths, fmt.Sprintf(\"\\t%s (from $GOROOT)\", tried.goroot))\n+\t\t} else {\n+\t\t\tpaths = append(paths, \"\\t($GOROOT not set)\")\n+\t\t}\n+\t\tvar i int\n+\t\tvar format = \"\\t%s (from $GOPATH)\"\n+\t\tfor ; i < len(tried.gopath); i++ {\n+\t\t\tif i > 0 {\n+\t\t\t\tformat = \"\\t%s\"\n+\t\t\t}\n+\t\t\tpaths = append(paths, fmt.Sprintf(format, tried.gopath[i]))\n+\t\t}\n+\t\tif i == 0 {\n+\t\t\tpaths = append(paths, \"\\t($GOPATH not set)\")\n \t\t}\n-\t\treturn p, fmt.Errorf(\"import %q: cannot find package\", path)\n+\t\treturn p, fmt.Errorf(\"cannot find package %q in any of:\\n%s\", path, strings.Join(paths, \"\\n\"))\n \t}\n \n Found:"}, {"sha": "c4b7e6ae6e17d0f24487aa4e503d0af7b1c925c1", "filename": "libgo/go/go/doc/comment.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -229,7 +229,8 @@ type block struct {\n var nonAlphaNumRx = regexp.MustCompile(`[^a-zA-Z0-9]`)\n \n func anchorID(line string) string {\n-\treturn nonAlphaNumRx.ReplaceAllString(line, \"_\")\n+\t// Add a \"hdr-\" prefix to avoid conflicting with IDs used for package symbols.\n+\treturn \"hdr-\" + nonAlphaNumRx.ReplaceAllString(line, \"_\")\n }\n \n // ToHTML converts comment text to formatted HTML."}, {"sha": "9fc0b415f0d4ab98bf73e5cec1a9d0ec158a5222", "filename": "libgo/go/go/doc/example.go", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -119,8 +119,29 @@ func playExample(file *ast.File, body *ast.BlockStmt) *ast.File {\n \t\treturn nil\n \t}\n \n-\t// Find unresolved identifiers\n+\t// Find top-level declarations in the file.\n+\ttopDecls := make(map[*ast.Object]bool)\n+\tfor _, decl := range file.Decls {\n+\t\tswitch d := decl.(type) {\n+\t\tcase *ast.FuncDecl:\n+\t\t\ttopDecls[d.Name.Obj] = true\n+\t\tcase *ast.GenDecl:\n+\t\t\tfor _, spec := range d.Specs {\n+\t\t\t\tswitch s := spec.(type) {\n+\t\t\t\tcase *ast.TypeSpec:\n+\t\t\t\t\ttopDecls[s.Name.Obj] = true\n+\t\t\t\tcase *ast.ValueSpec:\n+\t\t\t\t\tfor _, id := range s.Names {\n+\t\t\t\t\t\ttopDecls[id.Obj] = true\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Find unresolved identifiers and uses of top-level declarations.\n \tunresolved := make(map[string]bool)\n+\tusesTopDecl := false\n \tast.Inspect(body, func(n ast.Node) bool {\n \t\t// For an expression like fmt.Println, only add \"fmt\" to the\n \t\t// set of unresolved names.\n@@ -130,11 +151,19 @@ func playExample(file *ast.File, body *ast.BlockStmt) *ast.File {\n \t\t\t}\n \t\t\treturn false\n \t\t}\n-\t\tif id, ok := n.(*ast.Ident); ok && id.Obj == nil {\n-\t\t\tunresolved[id.Name] = true\n+\t\tif id, ok := n.(*ast.Ident); ok {\n+\t\t\tif id.Obj == nil {\n+\t\t\t\tunresolved[id.Name] = true\n+\t\t\t} else if topDecls[id.Obj] {\n+\t\t\t\tusesTopDecl = true\n+\t\t\t}\n \t\t}\n \t\treturn true\n \t})\n+\tif usesTopDecl {\n+\t\t// We don't support examples that are not self-contained (yet).\n+\t\treturn nil\n+\t}\n \n \t// Remove predeclared identifiers from unresolved list.\n \tfor n := range unresolved {"}, {"sha": "65b0e4e4b79b9b37d6116f6e5a452935a158645e", "filename": "libgo/go/go/format/format.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fgo%2Fformat%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fgo%2Fformat%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fformat%2Fformat.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -46,7 +46,7 @@ func Node(dst io.Writer, fset *token.FileSet, node interface{}) error {\n \t// Sort imports if necessary.\n \tif file != nil && hasUnsortedImports(file) {\n \t\t// Make a copy of the AST because ast.SortImports is destructive.\n-\t\t// TODO(gri) Do this more efficently.\n+\t\t// TODO(gri) Do this more efficiently.\n \t\tvar buf bytes.Buffer\n \t\terr := config.Fprint(&buf, fset, file)\n \t\tif err != nil {"}, {"sha": "3bed0cc6572c6beb30d5a561ce06f19686a80b3b", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -83,7 +83,7 @@ func (p *printer) setComment(g *ast.CommentGroup) {\n \t// don't overwrite any pending comment in the p.comment cache\n \t// (there may be a pending comment when a line comment is\n \t// immediately followed by a lead comment with no other\n-\t// tokens inbetween)\n+\t// tokens between)\n \tif p.commentOffset == infinity {\n \t\tp.nextComment() // get comment ready for use\n \t}"}, {"sha": "f5d999561862581049092f0473c3767c53a19229", "filename": "libgo/go/go/token/position.go", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -295,9 +295,9 @@ type FileSet struct {\n \n // NewFileSet creates a new file set.\n func NewFileSet() *FileSet {\n-\ts := new(FileSet)\n-\ts.base = 1 // 0 == NoPos\n-\treturn s\n+\treturn &FileSet{\n+\t\tbase: 1, // 0 == NoPos\n+\t}\n }\n \n // Base returns the minimum base offset that must be provided to\n@@ -367,19 +367,25 @@ func searchFiles(a []*File, x int) int {\n }\n \n func (s *FileSet) file(p Pos) *File {\n+\ts.mutex.RLock()\n \t// common case: p is in last file\n \tif f := s.last; f != nil && f.base <= int(p) && int(p) <= f.base+f.size {\n+\t\ts.mutex.RUnlock()\n \t\treturn f\n \t}\n \t// p is not in last file - search all files\n \tif i := searchFiles(s.files, int(p)); i >= 0 {\n \t\tf := s.files[i]\n \t\t// f.base <= int(p) by definition of searchFiles\n \t\tif int(p) <= f.base+f.size {\n-\t\t\ts.last = f\n+\t\t\ts.mutex.RUnlock()\n+\t\t\ts.mutex.Lock()\n+\t\t\ts.last = f // race is ok - s.last is only a cache\n+\t\t\ts.mutex.Unlock()\n \t\t\treturn f\n \t\t}\n \t}\n+\ts.mutex.RUnlock()\n \treturn nil\n }\n \n@@ -389,21 +395,17 @@ func (s *FileSet) file(p Pos) *File {\n //\n func (s *FileSet) File(p Pos) (f *File) {\n \tif p != NoPos {\n-\t\ts.mutex.RLock()\n \t\tf = s.file(p)\n-\t\ts.mutex.RUnlock()\n \t}\n \treturn\n }\n \n // Position converts a Pos in the fileset into a general Position.\n func (s *FileSet) Position(p Pos) (pos Position) {\n \tif p != NoPos {\n-\t\ts.mutex.RLock()\n \t\tif f := s.file(p); f != nil {\n \t\t\tpos = f.position(p)\n \t\t}\n-\t\ts.mutex.RUnlock()\n \t}\n \treturn\n }"}, {"sha": "1d36c22268d3f6b94b3bde4448e0bac9c84576cd", "filename": "libgo/go/go/token/position_test.go", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fgo%2Ftoken%2Fposition_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fgo%2Ftoken%2Fposition_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fposition_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -6,6 +6,8 @@ package token\n \n import (\n \t\"fmt\"\n+\t\"math/rand\"\n+\t\"sync\"\n \t\"testing\"\n )\n \n@@ -179,3 +181,52 @@ func TestFiles(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+// FileSet.File should return nil if Pos is past the end of the FileSet.\n+func TestFileSetPastEnd(t *testing.T) {\n+\tfset := NewFileSet()\n+\tfor _, test := range tests {\n+\t\tfset.AddFile(test.filename, fset.Base(), test.size)\n+\t}\n+\tif f := fset.File(Pos(fset.Base())); f != nil {\n+\t\tt.Errorf(\"expected nil, got %v\", f)\n+\t}\n+}\n+\n+func TestFileSetCacheUnlikely(t *testing.T) {\n+\tfset := NewFileSet()\n+\toffsets := make(map[string]int)\n+\tfor _, test := range tests {\n+\t\toffsets[test.filename] = fset.Base()\n+\t\tfset.AddFile(test.filename, fset.Base(), test.size)\n+\t}\n+\tfor file, pos := range offsets {\n+\t\tf := fset.File(Pos(pos))\n+\t\tif f.Name() != file {\n+\t\t\tt.Errorf(\"expecting %q at position %d, got %q\", file, pos, f.Name())\n+\t\t}\n+\t}\n+}\n+\n+// issue 4345. Test concurrent use of FileSet.Pos does not trigger a\n+// race in the FileSet position cache.\n+func TestFileSetRace(t *testing.T) {\n+\tfset := NewFileSet()\n+\tfor i := 0; i < 100; i++ {\n+\t\tfset.AddFile(fmt.Sprintf(\"file-%d\", i), fset.Base(), 1031)\n+\t}\n+\tmax := int32(fset.Base())\n+\tvar stop sync.WaitGroup\n+\tr := rand.New(rand.NewSource(7))\n+\tfor i := 0; i < 2; i++ {\n+\t\tr := rand.New(rand.NewSource(r.Int63()))\n+\t\tstop.Add(1)\n+\t\tgo func() {\n+\t\t\tfor i := 0; i < 1000; i++ {\n+\t\t\t\tfset.Position(Pos(r.Int31n(max)))\n+\t\t\t}\n+\t\t\tstop.Done()\n+\t\t}()\n+\t}\n+\tstop.Wait()\n+}"}, {"sha": "859adaf1b710a132b2ab07860daad9a98dfcef0b", "filename": "libgo/go/io/io.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fio%2Fio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fio%2Fio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fio.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -468,6 +468,11 @@ func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err error) {\n \toff += s.base\n \tif max := s.limit - off; int64(len(p)) > max {\n \t\tp = p[0:max]\n+\t\tn, err = s.r.ReadAt(p, off)\n+\t\tif err == nil {\n+\t\t\terr = EOF\n+\t\t}\n+\t\treturn n, err\n \t}\n \treturn s.r.ReadAt(p, off)\n }"}, {"sha": "f3ec050fad9ed1de7c5b9c60038f4c0186c74d3c", "filename": "libgo/go/io/io_test.go", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fio%2Fio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fio%2Fio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fio_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -203,3 +203,35 @@ func TestTeeReader(t *testing.T) {\n \t\tt.Errorf(\"closed tee: ReadFull(r, dst) = %d, %v; want 0, EPIPE\", n, err)\n \t}\n }\n+\n+func TestSectionReader_ReadAt(tst *testing.T) {\n+\tdat := \"a long sample data, 1234567890\"\n+\ttests := []struct {\n+\t\tdata   string\n+\t\toff    int\n+\t\tn      int\n+\t\tbufLen int\n+\t\tat     int\n+\t\texp    string\n+\t\terr    error\n+\t}{\n+\t\t{data: \"\", off: 0, n: 10, bufLen: 2, at: 0, exp: \"\", err: EOF},\n+\t\t{data: dat, off: 0, n: len(dat), bufLen: 0, at: 0, exp: \"\", err: nil},\n+\t\t{data: dat, off: len(dat), n: 1, bufLen: 1, at: 0, exp: \"\", err: EOF},\n+\t\t{data: dat, off: 0, n: len(dat) + 2, bufLen: len(dat), at: 0, exp: dat, err: nil},\n+\t\t{data: dat, off: 0, n: len(dat), bufLen: len(dat) / 2, at: 0, exp: dat[:len(dat)/2], err: nil},\n+\t\t{data: dat, off: 0, n: len(dat), bufLen: len(dat), at: 0, exp: dat, err: nil},\n+\t\t{data: dat, off: 0, n: len(dat), bufLen: len(dat) / 2, at: 2, exp: dat[2 : 2+len(dat)/2], err: nil},\n+\t\t{data: dat, off: 3, n: len(dat), bufLen: len(dat) / 2, at: 2, exp: dat[5 : 5+len(dat)/2], err: nil},\n+\t\t{data: dat, off: 3, n: len(dat) / 2, bufLen: len(dat)/2 - 2, at: 2, exp: dat[5 : 5+len(dat)/2-2], err: nil},\n+\t\t{data: dat, off: 3, n: len(dat) / 2, bufLen: len(dat)/2 + 2, at: 2, exp: dat[5 : 5+len(dat)/2-2], err: EOF},\n+\t}\n+\tfor i, t := range tests {\n+\t\tr := strings.NewReader(t.data)\n+\t\ts := NewSectionReader(r, int64(t.off), int64(t.n))\n+\t\tbuf := make([]byte, t.bufLen)\n+\t\tif n, err := s.ReadAt(buf, int64(t.at)); n != len(t.exp) || string(buf[:n]) != t.exp || err != t.err {\n+\t\t\ttst.Fatalf(\"%d: ReadAt(%d) = %q, %v; expected %q, %v\", i, t.at, buf[:n], err, t.exp, t.err)\n+\t\t}\n+\t}\n+}"}, {"sha": "67d7103ee44a93896217adebcca33fd26abd11bd", "filename": "libgo/go/log/syslog/syslog_test.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -20,13 +20,14 @@ var serverAddr string\n \n func runSyslog(c net.PacketConn, done chan<- string) {\n \tvar buf [4096]byte\n-\tvar rcvd string = \"\"\n+\tvar rcvd string\n \tfor {\n-\t\tn, _, err := c.ReadFrom(buf[0:])\n-\t\tif err != nil || n == 0 {\n+\t\tc.SetReadDeadline(time.Now().Add(100 * time.Millisecond))\n+\t\tn, _, err := c.ReadFrom(buf[:])\n+\t\trcvd += string(buf[:n])\n+\t\tif err != nil {\n \t\t\tbreak\n \t\t}\n-\t\trcvd += string(buf[0:n])\n \t}\n \tdone <- rcvd\n }\n@@ -37,7 +38,6 @@ func startServer(done chan<- string) {\n \t\tlog.Fatalf(\"net.ListenPacket failed udp :0 %v\", e)\n \t}\n \tserverAddr = c.LocalAddr().String()\n-\tc.SetReadDeadline(time.Now().Add(100 * time.Millisecond))\n \tgo runSyslog(c, done)\n }\n "}, {"sha": "0d8b10f67fa0125aec765ae1378a610d67106cd5", "filename": "libgo/go/math/all_test.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fmath%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fmath%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fall_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -2281,6 +2281,13 @@ func TestLog2(t *testing.T) {\n \t\t\tt.Errorf(\"Log2(%g) = %g, want %g\", vflogSC[i], f, logSC[i])\n \t\t}\n \t}\n+\tfor i := -1074; i <= 1023; i++ {\n+\t\tf := Ldexp(1, i)\n+\t\tl := Log2(f)\n+\t\tif l != float64(i) {\n+\t\t\tt.Errorf(\"Log2(2**%d) = %g, want %d\", i, l, i)\n+\t\t}\n+\t}\n }\n \n func TestModf(t *testing.T) {"}, {"sha": "63a4536e2a0b387f4b77a4f535d92485014bf1a2", "filename": "libgo/go/math/big/int.go", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fmath%2Fbig%2Fint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fmath%2Fbig%2Fint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fint.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -51,6 +51,13 @@ func (z *Int) SetInt64(x int64) *Int {\n \treturn z\n }\n \n+// SetUint64 sets z to x and returns z.\n+func (z *Int) SetUint64(x uint64) *Int {\n+\tz.abs = z.abs.setUint64(uint64(x))\n+\tz.neg = false\n+\treturn z\n+}\n+\n // NewInt allocates and returns a new Int set to x.\n func NewInt(x int64) *Int {\n \treturn new(Int).SetInt64(x)\n@@ -519,6 +526,19 @@ func (x *Int) Int64() int64 {\n \treturn v\n }\n \n+// Uint64 returns the int64 representation of x.\n+// If x cannot be represented in an uint64, the result is undefined.\n+func (x *Int) Uint64() uint64 {\n+\tif len(x.abs) == 0 {\n+\t\treturn 0\n+\t}\n+\tv := uint64(x.abs[0])\n+\tif _W == 32 && len(x.abs) > 1 {\n+\t\tv |= uint64(x.abs[1]) << 32\n+\t}\n+\treturn v\n+}\n+\n // SetString sets z to the value of s, interpreted in the given base,\n // and returns z and a boolean indicating success. If SetString fails,\n // the value of z is undefined but the returned value is nil."}, {"sha": "fd6d152b39de8516dd40269085bb691b5656aaf5", "filename": "libgo/go/math/big/int_test.go", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -1135,6 +1135,36 @@ func TestInt64(t *testing.T) {\n \t}\n }\n \n+var uint64Tests = []uint64{\n+\t0,\n+\t1,\n+\t4294967295,\n+\t4294967296,\n+\t8589934591,\n+\t8589934592,\n+\t9223372036854775807,\n+\t9223372036854775808,\n+\t18446744073709551615, // 1<<64 - 1\n+}\n+\n+func TestUint64(t *testing.T) {\n+\tin := new(Int)\n+\tfor i, testVal := range uint64Tests {\n+\t\tin.SetUint64(testVal)\n+\t\tout := in.Uint64()\n+\n+\t\tif out != testVal {\n+\t\t\tt.Errorf(\"#%d got %d want %d\", i, out, testVal)\n+\t\t}\n+\n+\t\tstr := fmt.Sprint(testVal)\n+\t\tstrOut := in.String()\n+\t\tif strOut != str {\n+\t\t\tt.Errorf(\"#%d.String got %s want %s\", i, strOut, str)\n+\t\t}\n+\t}\n+}\n+\n var bitwiseTests = []struct {\n \tx, y                 string\n \tand, or, xor, andNot string"}, {"sha": "9d09f97b77bf275c73bf3d6270ed98e7236d7d66", "filename": "libgo/go/math/big/nat.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -826,7 +826,7 @@ func (x nat) string(charset string) string {\n \n // Convert words of q to base b digits in s. If q is large, it is recursively \"split in half\"\n // by nat/nat division using tabulated divisors. Otherwise, it is converted iteratively using\n-// repeated nat/Word divison.\n+// repeated nat/Word division.\n //\n // The iterative method processes n Words by n divW() calls, each of which visits every Word in the\n // incrementally shortened q for a total of n + (n-1) + (n-2) ... + 2 + 1, or n(n+1)/2 divW()'s."}, {"sha": "d880ec2040d4d2b7d451c604718d2958a7ed13d6", "filename": "libgo/go/math/log10.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fmath%2Flog10.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fmath%2Flog10.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Flog10.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -26,5 +26,6 @@ func Log2(x float64) float64 {\n }\n \n func log2(x float64) float64 {\n-\treturn Log(x) * (1 / Ln2)\n+\tfrac, exp := Frexp(x)\n+\treturn Log(frac)*(1/Ln2) + float64(exp)\n }"}, {"sha": "aeaf8e568adc06bbb5e8b687cf192064e6a048d0", "filename": "libgo/go/net/cgo_openbsd.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fcgo_openbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fcgo_openbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fcgo_openbsd.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package net\n+\n+/*\n+#include <netdb.h>\n+*/\n+import \"C\"\n+\n+func cgoAddrInfoFlags() C.int {\n+\treturn C.AI_CANONNAME\n+}"}, {"sha": "a4d96a86d127ba1d94efab4f647c58edead54d5d", "filename": "libgo/go/net/cgo_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fcgo_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fcgo_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fcgo_unix.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux netbsd\n+// +build darwin freebsd linux netbsd openbsd\n \n package net\n "}, {"sha": "f733a81a3b2c301f84be8008d36096b444884401", "filename": "libgo/go/net/conn_test.go", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fconn_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fconn_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fconn_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -17,8 +17,8 @@ var connTests = []struct {\n \taddr string\n }{\n \t{\"tcp\", \"127.0.0.1:0\"},\n-\t{\"unix\", \"/tmp/gotest.net\"},\n-\t{\"unixpacket\", \"/tmp/gotest.net\"},\n+\t{\"unix\", \"/tmp/gotest.net1\"},\n+\t{\"unixpacket\", \"/tmp/gotest.net2\"},\n }\n \n func TestConnAndListener(t *testing.T) {\n@@ -41,7 +41,13 @@ func TestConnAndListener(t *testing.T) {\n \t\t\treturn\n \t\t}\n \t\tln.Addr()\n-\t\tdefer ln.Close()\n+\t\tdefer func(ln net.Listener, net, addr string) {\n+\t\t\tln.Close()\n+\t\t\tswitch net {\n+\t\t\tcase \"unix\", \"unixpacket\":\n+\t\t\t\tos.Remove(addr)\n+\t\t\t}\n+\t\t}(ln, tt.net, tt.addr)\n \n \t\tdone := make(chan int)\n \t\tgo transponder(t, ln, done)\n@@ -68,10 +74,6 @@ func TestConnAndListener(t *testing.T) {\n \t\t}\n \n \t\t<-done\n-\t\tswitch tt.net {\n-\t\tcase \"unix\", \"unixpacket\":\n-\t\t\tos.Remove(tt.addr)\n-\t\t}\n \t}\n }\n "}, {"sha": "c1eb983cc0f882a642accb41bbb38fccd1b8fe4d", "filename": "libgo/go/net/dial.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fdial.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fdial.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -238,7 +238,7 @@ func ListenPacket(net, laddr string) (PacketConn, error) {\n \t\tif a != nil {\n \t\t\tla = a.(*UnixAddr)\n \t\t}\n-\t\treturn DialUnix(net, la, nil)\n+\t\treturn ListenUnixgram(net, la)\n \t}\n \treturn nil, UnknownNetworkError(net)\n }"}, {"sha": "f30dee301645607d97ad4ed6250c8ca91547b432", "filename": "libgo/go/net/dial_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fdial_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fdial_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -240,7 +240,8 @@ func TestDialTimeoutFDLeak(t *testing.T) {\n \t\terr  error\n \t}\n \tdials := listenerBacklog + 100\n-\tmaxGoodConnect := listenerBacklog + 5 // empirically 131 good ones (of 128). who knows?\n+\t// used to be listenerBacklog + 5, but was found to be unreliable, issue 4384.\n+\tmaxGoodConnect := listenerBacklog + runtime.NumCPU()*10\n \tresc := make(chan connErr)\n \tfor i := 0; i < dials; i++ {\n \t\tgo func() {"}, {"sha": "5ee0804c7da9fc2d3fc4db76d91e28d8688df565", "filename": "libgo/go/net/http/client.go", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -98,7 +98,9 @@ func (c *Client) send(req *Request) (*Response, error) {\n \t\treturn nil, err\n \t}\n \tif c.Jar != nil {\n-\t\tc.Jar.SetCookies(req.URL, resp.Cookies())\n+\t\tif rc := resp.Cookies(); len(rc) > 0 {\n+\t\t\tc.Jar.SetCookies(req.URL, rc)\n+\t\t}\n \t}\n \treturn resp, err\n }\n@@ -120,7 +122,10 @@ func (c *Client) send(req *Request) (*Response, error) {\n // Generally Get, Post, or PostForm will be used instead of Do.\n func (c *Client) Do(req *Request) (resp *Response, err error) {\n \tif req.Method == \"GET\" || req.Method == \"HEAD\" {\n-\t\treturn c.doFollowingRedirects(req)\n+\t\treturn c.doFollowingRedirects(req, shouldRedirectGet)\n+\t}\n+\tif req.Method == \"POST\" || req.Method == \"PUT\" {\n+\t\treturn c.doFollowingRedirects(req, shouldRedirectPost)\n \t}\n \treturn c.send(req)\n }\n@@ -166,14 +171,24 @@ func send(req *Request, t RoundTripper) (resp *Response, err error) {\n \n // True if the specified HTTP status code is one for which the Get utility should\n // automatically redirect.\n-func shouldRedirect(statusCode int) bool {\n+func shouldRedirectGet(statusCode int) bool {\n \tswitch statusCode {\n \tcase StatusMovedPermanently, StatusFound, StatusSeeOther, StatusTemporaryRedirect:\n \t\treturn true\n \t}\n \treturn false\n }\n \n+// True if the specified HTTP status code is one for which the Post utility should\n+// automatically redirect.\n+func shouldRedirectPost(statusCode int) bool {\n+\tswitch statusCode {\n+\tcase StatusFound, StatusSeeOther:\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n // Get issues a GET to the specified URL.  If the response is one of the following\n // redirect codes, Get follows the redirect, up to a maximum of 10 redirects:\n //\n@@ -214,12 +229,10 @@ func (c *Client) Get(url string) (resp *Response, err error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn c.doFollowingRedirects(req)\n+\treturn c.doFollowingRedirects(req, shouldRedirectGet)\n }\n \n-func (c *Client) doFollowingRedirects(ireq *Request) (resp *Response, err error) {\n-\t// TODO: if/when we add cookie support, the redirected request shouldn't\n-\t// necessarily supply the same cookies as the original.\n+func (c *Client) doFollowingRedirects(ireq *Request, shouldRedirect func(int) bool) (resp *Response, err error) {\n \tvar base *url.URL\n \tredirectChecker := c.CheckRedirect\n \tif redirectChecker == nil {\n@@ -238,6 +251,9 @@ func (c *Client) doFollowingRedirects(ireq *Request) (resp *Response, err error)\n \t\tif redirect != 0 {\n \t\t\treq = new(Request)\n \t\t\treq.Method = ireq.Method\n+\t\t\tif ireq.Method == \"POST\" || ireq.Method == \"PUT\" {\n+\t\t\t\treq.Method = \"GET\"\n+\t\t\t}\n \t\t\treq.Header = make(Header)\n \t\t\treq.URL, err = base.Parse(urlStr)\n \t\t\tif err != nil {\n@@ -321,7 +337,7 @@ func (c *Client) Post(url string, bodyType string, body io.Reader) (resp *Respon\n \t\treturn nil, err\n \t}\n \treq.Header.Set(\"Content-Type\", bodyType)\n-\treturn c.send(req)\n+\treturn c.doFollowingRedirects(req, shouldRedirectPost)\n }\n \n // PostForm issues a POST to the specified URL, with data's keys and\n@@ -371,5 +387,5 @@ func (c *Client) Head(url string) (resp *Response, err error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn c.doFollowingRedirects(req)\n+\treturn c.doFollowingRedirects(req, shouldRedirectGet)\n }"}, {"sha": "9514a4b961058ebfc965cf9fe1672fb8c6caa8a0", "filename": "libgo/go/net/http/client_test.go", "status": "modified", "additions": 116, "deletions": 2, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -7,6 +7,7 @@\n package http_test\n \n import (\n+\t\"bytes\"\n \t\"crypto/tls\"\n \t\"crypto/x509\"\n \t\"errors\"\n@@ -246,6 +247,52 @@ func TestRedirects(t *testing.T) {\n \t}\n }\n \n+func TestPostRedirects(t *testing.T) {\n+\tvar log struct {\n+\t\tsync.Mutex\n+\t\tbytes.Buffer\n+\t}\n+\tvar ts *httptest.Server\n+\tts = httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tlog.Lock()\n+\t\tfmt.Fprintf(&log.Buffer, \"%s %s \", r.Method, r.RequestURI)\n+\t\tlog.Unlock()\n+\t\tif v := r.URL.Query().Get(\"code\"); v != \"\" {\n+\t\t\tcode, _ := strconv.Atoi(v)\n+\t\t\tif code/100 == 3 {\n+\t\t\t\tw.Header().Set(\"Location\", ts.URL)\n+\t\t\t}\n+\t\t\tw.WriteHeader(code)\n+\t\t}\n+\t}))\n+\ttests := []struct {\n+\t\tsuffix string\n+\t\twant   int // response code\n+\t}{\n+\t\t{\"/\", 200},\n+\t\t{\"/?code=301\", 301},\n+\t\t{\"/?code=302\", 200},\n+\t\t{\"/?code=303\", 200},\n+\t\t{\"/?code=404\", 404},\n+\t}\n+\tfor _, tt := range tests {\n+\t\tres, err := Post(ts.URL+tt.suffix, \"text/plain\", strings.NewReader(\"Some content\"))\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tif res.StatusCode != tt.want {\n+\t\t\tt.Errorf(\"POST %s: status code = %d; want %d\", tt.suffix, res.StatusCode, tt.want)\n+\t\t}\n+\t}\n+\tlog.Lock()\n+\tgot := log.String()\n+\tlog.Unlock()\n+\twant := \"POST / POST /?code=301 POST /?code=302 GET / POST /?code=303 GET / POST /?code=404 \"\n+\tif got != want {\n+\t\tt.Errorf(\"Log differs.\\n Got: %q\\nWant: %q\", got, want)\n+\t}\n+}\n+\n var expectedCookies = []*Cookie{\n \t{Name: \"ChocolateChip\", Value: \"tasty\"},\n \t{Name: \"First\", Value: \"Hit\"},\n@@ -304,6 +351,9 @@ type TestJar struct {\n func (j *TestJar) SetCookies(u *url.URL, cookies []*Cookie) {\n \tj.m.Lock()\n \tdefer j.m.Unlock()\n+\tif j.perURL == nil {\n+\t\tj.perURL = make(map[string][]*Cookie)\n+\t}\n \tj.perURL[u.Host] = cookies\n }\n \n@@ -334,8 +384,9 @@ func TestRedirectCookiesJar(t *testing.T) {\n \tvar ts *httptest.Server\n \tts = httptest.NewServer(echoCookiesRedirectHandler)\n \tdefer ts.Close()\n-\tc := &Client{}\n-\tc.Jar = &TestJar{perURL: make(map[string][]*Cookie)}\n+\tc := &Client{\n+\t\tJar: new(TestJar),\n+\t}\n \tu, _ := url.Parse(ts.URL)\n \tc.Jar.SetCookies(u, []*Cookie{expectedCookies[0]})\n \tresp, err := c.Get(ts.URL)\n@@ -364,6 +415,69 @@ func matchReturnedCookies(t *testing.T, expected, given []*Cookie) {\n \t}\n }\n \n+func TestJarCalls(t *testing.T) {\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tpathSuffix := r.RequestURI[1:]\n+\t\tif r.RequestURI == \"/nosetcookie\" {\n+\t\t\treturn // dont set cookies for this path\n+\t\t}\n+\t\tSetCookie(w, &Cookie{Name: \"name\" + pathSuffix, Value: \"val\" + pathSuffix})\n+\t\tif r.RequestURI == \"/\" {\n+\t\t\tRedirect(w, r, \"http://secondhost.fake/secondpath\", 302)\n+\t\t}\n+\t}))\n+\tdefer ts.Close()\n+\tjar := new(RecordingJar)\n+\tc := &Client{\n+\t\tJar: jar,\n+\t\tTransport: &Transport{\n+\t\t\tDial: func(_ string, _ string) (net.Conn, error) {\n+\t\t\t\treturn net.Dial(\"tcp\", ts.Listener.Addr().String())\n+\t\t\t},\n+\t\t},\n+\t}\n+\t_, err := c.Get(\"http://firsthost.fake/\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t_, err = c.Get(\"http://firsthost.fake/nosetcookie\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tgot := jar.log.String()\n+\twant := `Cookies(\"http://firsthost.fake/\")\n+SetCookie(\"http://firsthost.fake/\", [name=val])\n+Cookies(\"http://secondhost.fake/secondpath\")\n+SetCookie(\"http://secondhost.fake/secondpath\", [namesecondpath=valsecondpath])\n+Cookies(\"http://firsthost.fake/nosetcookie\")\n+`\n+\tif got != want {\n+\t\tt.Errorf(\"Got Jar calls:\\n%s\\nWant:\\n%s\", got, want)\n+\t}\n+}\n+\n+// RecordingJar keeps a log of calls made to it, without\n+// tracking any cookies.\n+type RecordingJar struct {\n+\tmu  sync.Mutex\n+\tlog bytes.Buffer\n+}\n+\n+func (j *RecordingJar) SetCookies(u *url.URL, cookies []*Cookie) {\n+\tj.logf(\"SetCookie(%q, %v)\\n\", u, cookies)\n+}\n+\n+func (j *RecordingJar) Cookies(u *url.URL) []*Cookie {\n+\tj.logf(\"Cookies(%q)\\n\", u)\n+\treturn nil\n+}\n+\n+func (j *RecordingJar) logf(format string, args ...interface{}) {\n+\tj.mu.Lock()\n+\tdefer j.mu.Unlock()\n+\tfmt.Fprintf(&j.log, format, args...)\n+}\n+\n func TestStreamingGet(t *testing.T) {\n \tsay := make(chan string)\n \tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {"}, {"sha": "0c03e5b2b75c5ff82ced1de40071d3392908122f", "filename": "libgo/go/net/http/pprof/pprof.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -34,9 +34,8 @@\n //\n //\tgo tool pprof http://localhost:6060/debug/pprof/block\n //\n-// Or to view all available profiles:\n-//\n-//\tgo tool pprof http://localhost:6060/debug/pprof/\n+// To view all available profiles, open http://localhost:6060/debug/pprof/\n+// in your browser.\n //\n // For a study of the facility in action, visit\n //"}, {"sha": "ffdd6a892dab7f2f1265c87ea983fff293b53176", "filename": "libgo/go/net/http/readrequest_test.go", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fhttp%2Freadrequest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fhttp%2Freadrequest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Freadrequest_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -247,6 +247,54 @@ var reqTests = []reqTest{\n \t\tnoTrailer,\n \t\tnoError,\n \t},\n+\n+\t// SSDP Notify request. golang.org/issue/3692\n+\t{\n+\t\t\"NOTIFY * HTTP/1.1\\r\\nServer: foo\\r\\n\\r\\n\",\n+\t\t&Request{\n+\t\t\tMethod: \"NOTIFY\",\n+\t\t\tURL: &url.URL{\n+\t\t\t\tPath: \"*\",\n+\t\t\t},\n+\t\t\tProto:      \"HTTP/1.1\",\n+\t\t\tProtoMajor: 1,\n+\t\t\tProtoMinor: 1,\n+\t\t\tHeader: Header{\n+\t\t\t\t\"Server\": []string{\"foo\"},\n+\t\t\t},\n+\t\t\tClose:         false,\n+\t\t\tContentLength: 0,\n+\t\t\tRequestURI:    \"*\",\n+\t\t},\n+\n+\t\tnoBody,\n+\t\tnoTrailer,\n+\t\tnoError,\n+\t},\n+\n+\t// OPTIONS request. Similar to golang.org/issue/3692\n+\t{\n+\t\t\"OPTIONS * HTTP/1.1\\r\\nServer: foo\\r\\n\\r\\n\",\n+\t\t&Request{\n+\t\t\tMethod: \"OPTIONS\",\n+\t\t\tURL: &url.URL{\n+\t\t\t\tPath: \"*\",\n+\t\t\t},\n+\t\t\tProto:      \"HTTP/1.1\",\n+\t\t\tProtoMajor: 1,\n+\t\t\tProtoMinor: 1,\n+\t\t\tHeader: Header{\n+\t\t\t\t\"Server\": []string{\"foo\"},\n+\t\t\t},\n+\t\t\tClose:         false,\n+\t\t\tContentLength: 0,\n+\t\t\tRequestURI:    \"*\",\n+\t\t},\n+\n+\t\tnoBody,\n+\t\tnoTrailer,\n+\t\tnoError,\n+\t},\n }\n \n func TestReadRequest(t *testing.T) {"}, {"sha": "1de4171239dee718aee6bdb9b492a5c69c9b3a86", "filename": "libgo/go/net/http/serve_test.go", "status": "modified", "additions": 65, "deletions": 5, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -918,15 +918,19 @@ func TestZeroLengthPostAndResponse(t *testing.T) {\n \t}\n }\n \n+func TestHandlerPanicNil(t *testing.T) {\n+\ttestHandlerPanic(t, false, nil)\n+}\n+\n func TestHandlerPanic(t *testing.T) {\n-\ttestHandlerPanic(t, false)\n+\ttestHandlerPanic(t, false, \"intentional death for testing\")\n }\n \n func TestHandlerPanicWithHijack(t *testing.T) {\n-\ttestHandlerPanic(t, true)\n+\ttestHandlerPanic(t, true, \"intentional death for testing\")\n }\n \n-func testHandlerPanic(t *testing.T, withHijack bool) {\n+func testHandlerPanic(t *testing.T, withHijack bool, panicValue interface{}) {\n \t// Unlike the other tests that set the log output to ioutil.Discard\n \t// to quiet the output, this test uses a pipe.  The pipe serves three\n \t// purposes:\n@@ -955,7 +959,7 @@ func testHandlerPanic(t *testing.T, withHijack bool) {\n \t\t\t}\n \t\t\tdefer rwc.Close()\n \t\t}\n-\t\tpanic(\"intentional death for testing\")\n+\t\tpanic(panicValue)\n \t}))\n \tdefer ts.Close()\n \n@@ -968,7 +972,7 @@ func testHandlerPanic(t *testing.T, withHijack bool) {\n \t\t_, err := pr.Read(buf)\n \t\tpr.Close()\n \t\tif err != nil {\n-\t\t\tt.Fatal(err)\n+\t\t\tt.Error(err)\n \t\t}\n \t\tdone <- true\n \t}()\n@@ -978,6 +982,10 @@ func testHandlerPanic(t *testing.T, withHijack bool) {\n \t\tt.Logf(\"expected an error\")\n \t}\n \n+\tif panicValue == nil {\n+\t\treturn\n+\t}\n+\n \tselect {\n \tcase <-done:\n \t\treturn\n@@ -1288,6 +1296,58 @@ For:\n \tts.Close()\n }\n \n+func TestOptions(t *testing.T) {\n+\turic := make(chan string, 2) // only expect 1, but leave space for 2\n+\tmux := NewServeMux()\n+\tmux.HandleFunc(\"/\", func(w ResponseWriter, r *Request) {\n+\t\turic <- r.RequestURI\n+\t})\n+\tts := httptest.NewServer(mux)\n+\tdefer ts.Close()\n+\n+\tconn, err := net.Dial(\"tcp\", ts.Listener.Addr().String())\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer conn.Close()\n+\n+\t// An OPTIONS * request should succeed.\n+\t_, err = conn.Write([]byte(\"OPTIONS * HTTP/1.1\\r\\nHost: foo.com\\r\\n\\r\\n\"))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tbr := bufio.NewReader(conn)\n+\tres, err := ReadResponse(br, &Request{Method: \"OPTIONS\"})\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif res.StatusCode != 200 {\n+\t\tt.Errorf(\"Got non-200 response to OPTIONS *: %#v\", res)\n+\t}\n+\n+\t// A GET * request on a ServeMux should fail.\n+\t_, err = conn.Write([]byte(\"GET * HTTP/1.1\\r\\nHost: foo.com\\r\\n\\r\\n\"))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tres, err = ReadResponse(br, &Request{Method: \"GET\"})\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif res.StatusCode != 400 {\n+\t\tt.Errorf(\"Got non-400 response to GET *: %#v\", res)\n+\t}\n+\n+\tres, err = Get(ts.URL + \"/second\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tres.Body.Close()\n+\tif got := <-uric; got != \"/second\" {\n+\t\tt.Errorf(\"Handler saw request for %q; want /second\", got)\n+\t}\n+}\n+\n // goTimeout runs f, failing t if f takes more than ns to complete.\n func goTimeout(t *testing.T, d time.Duration, f func()) {\n \tch := make(chan bool, 2)"}, {"sha": "89a46f06bb2054de05454ba457222e38ae64e41e", "filename": "libgo/go/net/http/server.go", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -702,24 +702,19 @@ func (c *conn) closeWriteAndWait() {\n // Serve a new connection.\n func (c *conn) serve() {\n \tdefer func() {\n-\t\terr := recover()\n-\t\tif err == nil {\n-\t\t\treturn\n+\t\tif err := recover(); err != nil {\n+\t\t\tconst size = 4096\n+\t\t\tbuf := make([]byte, size)\n+\t\t\tbuf = buf[:runtime.Stack(buf, false)]\n+\t\t\tlog.Printf(\"http: panic serving %v: %v\\n%s\", c.remoteAddr, err, buf)\n \t\t}\n-\n-\t\tconst size = 4096\n-\t\tbuf := make([]byte, size)\n-\t\tbuf = buf[:runtime.Stack(buf, false)]\n-\t\tlog.Printf(\"http: panic serving %v: %v\\n%s\", c.remoteAddr, err, buf)\n-\n-\t\tif c.rwc != nil { // may be nil if connection hijacked\n-\t\t\tc.rwc.Close()\n+\t\tif !c.hijacked() {\n+\t\t\tc.close()\n \t\t}\n \t}()\n \n \tif tlsConn, ok := c.rwc.(*tls.Conn); ok {\n \t\tif err := tlsConn.Handshake(); err != nil {\n-\t\t\tc.close()\n \t\t\treturn\n \t\t}\n \t\tc.tlsState = new(tls.ConnectionState)\n@@ -770,6 +765,9 @@ func (c *conn) serve() {\n \t\tif handler == nil {\n \t\t\thandler = DefaultServeMux\n \t\t}\n+\t\tif req.RequestURI == \"*\" && req.Method == \"OPTIONS\" {\n+\t\t\thandler = globalOptionsHandler{}\n+\t\t}\n \n \t\t// HTTP cannot have multiple simultaneous active requests.[*]\n \t\t// Until the server replies to this request, it can't read another,\n@@ -788,7 +786,6 @@ func (c *conn) serve() {\n \t\t\tbreak\n \t\t}\n \t}\n-\tc.close()\n }\n \n func (w *response) sendExpectationFailed() {\n@@ -1085,6 +1082,11 @@ func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {\n // ServeHTTP dispatches the request to the handler whose\n // pattern most closely matches the request URL.\n func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {\n+\tif r.RequestURI == \"*\" {\n+\t\tw.Header().Set(\"Connection\", \"close\")\n+\t\tw.WriteHeader(StatusBadRequest)\n+\t\treturn\n+\t}\n \th, _ := mux.Handler(r)\n \th.ServeHTTP(w, r)\n }\n@@ -1408,6 +1410,22 @@ func (tw *timeoutWriter) WriteHeader(code int) {\n \ttw.w.WriteHeader(code)\n }\n \n+// globalOptionsHandler responds to \"OPTIONS *\" requests.\n+type globalOptionsHandler struct{}\n+\n+func (globalOptionsHandler) ServeHTTP(w ResponseWriter, r *Request) {\n+\tw.Header().Set(\"Content-Length\", \"0\")\n+\tif r.ContentLength != 0 {\n+\t\t// Read up to 4KB of OPTIONS body (as mentioned in the\n+\t\t// spec as being reserved for future use), but anything\n+\t\t// over that is considered a waste of server resources\n+\t\t// (or an attack) and we abort and close the connection,\n+\t\t// courtesy of MaxBytesReader's EOF behavior.\n+\t\tmb := MaxBytesReader(w, r.Body, 4<<10)\n+\t\tio.Copy(ioutil.Discard, mb)\n+\t}\n+}\n+\n // loggingConn is used for debugging.\n type loggingConn struct {\n \tname string"}, {"sha": "d0505bf13f041918a2ebcb727ba54564aa3b27b3", "filename": "libgo/go/net/http/transport.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -144,6 +144,9 @@ func (t *Transport) RoundTrip(req *Request) (resp *Response, err error) {\n \t\t}\n \t\treturn rt.RoundTrip(req)\n \t}\n+\tif req.URL.Host == \"\" {\n+\t\treturn nil, errors.New(\"http: no Host in request URL\")\n+\t}\n \ttreq := &transportRequest{Request: req}\n \tcm, err := t.connectMethodForRequest(treq)\n \tif err != nil {\n@@ -739,6 +742,7 @@ WaitResponse:\n \t\tcase err := <-writeErrCh:\n \t\t\tif err != nil {\n \t\t\t\tre = responseAndError{nil, err}\n+\t\t\t\tpc.close()\n \t\t\t\tbreak WaitResponse\n \t\t\t}\n \t\tcase <-pconnDeadCh:"}, {"sha": "c37ef13a4163bb7ad8b26117ec33e977eb889df5", "filename": "libgo/go/net/http/transport_test.go", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -778,6 +778,45 @@ func TestTransportPersistConnLeak(t *testing.T) {\n \t}\n }\n \n+// golang.org/issue/4531: Transport leaks goroutines when\n+// request.ContentLength is explicitly short\n+func TestTransportPersistConnLeakShortBody(t *testing.T) {\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t}))\n+\tdefer ts.Close()\n+\n+\ttr := &Transport{}\n+\tc := &Client{Transport: tr}\n+\n+\tn0 := runtime.NumGoroutine()\n+\tbody := []byte(\"Hello\")\n+\tfor i := 0; i < 20; i++ {\n+\t\treq, err := NewRequest(\"POST\", ts.URL, bytes.NewReader(body))\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\treq.ContentLength = int64(len(body) - 2) // explicitly short\n+\t\t_, err = c.Do(req)\n+\t\tif err == nil {\n+\t\t\tt.Fatal(\"Expect an error from writing too long of a body.\")\n+\t\t}\n+\t}\n+\tnhigh := runtime.NumGoroutine()\n+\ttr.CloseIdleConnections()\n+\ttime.Sleep(50 * time.Millisecond)\n+\truntime.GC()\n+\tnfinal := runtime.NumGoroutine()\n+\n+\tgrowth := nfinal - n0\n+\n+\t// We expect 0 or 1 extra goroutine, empirically.  Allow up to 5.\n+\t// Previously we were leaking one per numReq.\n+\tt.Logf(\"goroutine growth: %d -> %d -> %d (delta: %d)\", n0, nhigh, nfinal, growth)\n+\tif int(growth) > 5 {\n+\t\tt.Error(\"too many new goroutines\")\n+\t}\n+}\n+\n // This used to crash; http://golang.org/issue/3266\n func TestTransportIdleConnCrash(t *testing.T) {\n \ttr := &Transport{}\n@@ -1062,6 +1101,20 @@ func TestTransportAltProto(t *testing.T) {\n \t}\n }\n \n+func TestTransportNoHost(t *testing.T) {\n+\ttr := &Transport{}\n+\t_, err := tr.RoundTrip(&Request{\n+\t\tHeader: make(Header),\n+\t\tURL: &url.URL{\n+\t\t\tScheme: \"http\",\n+\t\t},\n+\t})\n+\twant := \"http: no Host in request URL\"\n+\tif got := fmt.Sprint(err); got != want {\n+\t\tt.Errorf(\"error = %v; want %q\", err, want)\n+\t}\n+}\n+\n var proxyFromEnvTests = []struct {\n \tenv     string\n \twanturl string"}, {"sha": "ff29e24a9a257f16d01663cd63fc2a1521fc6ccc", "filename": "libgo/go/net/packetconn_test.go", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fpacketconn_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fpacketconn_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fpacketconn_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -24,6 +24,15 @@ var packetConnTests = []struct {\n }\n \n func TestPacketConn(t *testing.T) {\n+\tcloser := func(c net.PacketConn, net, addr1, addr2 string) {\n+\t\tc.Close()\n+\t\tswitch net {\n+\t\tcase \"unixgram\":\n+\t\t\tos.Remove(addr1)\n+\t\t\tos.Remove(addr2)\n+\t\t}\n+\t}\n+\n \tfor _, tt := range packetConnTests {\n \t\tvar wb []byte\n \t\tnetstr := strings.Split(tt.net, \":\")\n@@ -39,7 +48,7 @@ func TestPacketConn(t *testing.T) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tid := os.Getpid() & 0xffff\n-\t\t\twb = newICMPEchoRequest(id, 1, 128, []byte(\"IP PACKETCONN TEST \"))\n+\t\t\twb = newICMPEchoRequest(id, 1, 128, []byte(\"IP PACKETCONN TEST\"))\n \t\tcase \"unixgram\":\n \t\t\tswitch runtime.GOOS {\n \t\t\tcase \"plan9\", \"windows\":\n@@ -60,7 +69,7 @@ func TestPacketConn(t *testing.T) {\n \t\tc1.SetDeadline(time.Now().Add(100 * time.Millisecond))\n \t\tc1.SetReadDeadline(time.Now().Add(100 * time.Millisecond))\n \t\tc1.SetWriteDeadline(time.Now().Add(100 * time.Millisecond))\n-\t\tdefer c1.Close()\n+\t\tdefer closer(c1, netstr[0], tt.addr1, tt.addr2)\n \n \t\tc2, err := net.ListenPacket(tt.net, tt.addr2)\n \t\tif err != nil {\n@@ -70,7 +79,7 @@ func TestPacketConn(t *testing.T) {\n \t\tc2.SetDeadline(time.Now().Add(100 * time.Millisecond))\n \t\tc2.SetReadDeadline(time.Now().Add(100 * time.Millisecond))\n \t\tc2.SetWriteDeadline(time.Now().Add(100 * time.Millisecond))\n-\t\tdefer c2.Close()\n+\t\tdefer closer(c2, netstr[0], tt.addr1, tt.addr2)\n \n \t\tif _, err := c1.WriteTo(wb, c2.LocalAddr()); err != nil {\n \t\t\tt.Fatalf(\"net.PacketConn.WriteTo failed: %v\", err)\n@@ -86,12 +95,6 @@ func TestPacketConn(t *testing.T) {\n \t\tif _, _, err := c1.ReadFrom(rb1); err != nil {\n \t\t\tt.Fatalf(\"net.PacketConn.ReadFrom failed: %v\", err)\n \t\t}\n-\n-\t\tswitch netstr[0] {\n-\t\tcase \"unixgram\":\n-\t\t\tos.Remove(tt.addr1)\n-\t\t\tos.Remove(tt.addr2)\n-\t\t}\n \t}\n }\n "}, {"sha": "d99de3f138c47de80c97e50640e060203142f230", "filename": "libgo/go/net/protoconn_test.go", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fprotoconn_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fprotoconn_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fprotoconn_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -263,9 +263,10 @@ func TestUnixConnSpecificMethods(t *testing.T) {\n \t\treturn\n \t}\n \n-\tp1, p2 := \"/tmp/gotest.net1\", \"/tmp/gotest.net2\"\n+\tp1, p2, p3 := \"/tmp/gotest.net1\", \"/tmp/gotest.net2\", \"/tmp/gotest.net3\"\n \tos.Remove(p1)\n \tos.Remove(p2)\n+\tos.Remove(p3)\n \n \ta1, err := net.ResolveUnixAddr(\"unixgram\", p1)\n \tif err != nil {\n@@ -305,9 +306,30 @@ func TestUnixConnSpecificMethods(t *testing.T) {\n \tdefer c2.Close()\n \tdefer os.Remove(p2)\n \n+\ta3, err := net.ResolveUnixAddr(\"unixgram\", p3)\n+\tif err != nil {\n+\t\tt.Errorf(\"net.ResolveUnixAddr failed: %v\", err)\n+\t\treturn\n+\t}\n+\tc3, err := net.ListenUnixgram(\"unixgram\", a3)\n+\tif err != nil {\n+\t\tt.Errorf(\"net.ListenUnixgram failed: %v\", err)\n+\t\treturn\n+\t}\n+\tc3.LocalAddr()\n+\tc3.RemoteAddr()\n+\tc3.SetDeadline(time.Now().Add(100 * time.Millisecond))\n+\tc3.SetReadDeadline(time.Now().Add(100 * time.Millisecond))\n+\tc3.SetWriteDeadline(time.Now().Add(100 * time.Millisecond))\n+\tc3.SetReadBuffer(2048)\n+\tc3.SetWriteBuffer(2048)\n+\tdefer c3.Close()\n+\tdefer os.Remove(p3)\n+\n \twb := []byte(\"UNIXCONN TEST\")\n \trb1 := make([]byte, 128)\n \trb2 := make([]byte, 128)\n+\trb3 := make([]byte, 128)\n \tif _, _, err := c1.WriteMsgUnix(wb, nil, a2); err != nil {\n \t\tt.Errorf(\"net.UnixConn.WriteMsgUnix failed: %v\", err)\n \t\treturn\n@@ -324,9 +346,22 @@ func TestUnixConnSpecificMethods(t *testing.T) {\n \t\tt.Errorf(\"net.UnixConn.ReadFromUnix failed: %v\", err)\n \t\treturn\n \t}\n-\n-\t// TODO: http://golang.org/issue/3875\n-\tnet.ListenUnixgram(\"unixgram\", nil)\n+\tif _, err := c3.WriteToUnix(wb, a1); err != nil {\n+\t\tt.Errorf(\"net.UnixConn.WriteToUnix failed: %v\", err)\n+\t\treturn\n+\t}\n+\tif _, _, err := c1.ReadFromUnix(rb1); err != nil {\n+\t\tt.Errorf(\"net.UnixConn.ReadFromUnix failed: %v\", err)\n+\t\treturn\n+\t}\n+\tif _, err := c2.WriteToUnix(wb, a3); err != nil {\n+\t\tt.Errorf(\"net.UnixConn.WriteToUnix failed: %v\", err)\n+\t\treturn\n+\t}\n+\tif _, _, err := c3.ReadFromUnix(rb3); err != nil {\n+\t\tt.Errorf(\"net.UnixConn.ReadFromUnix failed: %v\", err)\n+\t\treturn\n+\t}\n \n \tif f, err := c1.File(); err != nil {\n \t\tt.Errorf(\"net.UnixConn.File failed: %v\", err)"}, {"sha": "4b9177877018b3d597ae55b032074d0206a982e3", "filename": "libgo/go/net/smtp/smtp.go", "status": "modified", "additions": 57, "deletions": 8, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fsmtp%2Fsmtp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fsmtp%2Fsmtp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsmtp%2Fsmtp.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -13,6 +13,7 @@ package smtp\n import (\n \t\"crypto/tls\"\n \t\"encoding/base64\"\n+\t\"errors\"\n \t\"io\"\n \t\"net\"\n \t\"net/textproto\"\n@@ -33,7 +34,10 @@ type Client struct {\n \t// map of supported extensions\n \text map[string]string\n \t// supported auth mechanisms\n-\tauth []string\n+\tauth       []string\n+\tlocalName  string // the name to use in HELO/EHLO\n+\tdidHello   bool   // whether we've said HELO/EHLO\n+\thelloError error  // the error from the hello\n }\n \n // Dial returns a new Client connected to an SMTP server at addr.\n@@ -55,12 +59,33 @@ func NewClient(conn net.Conn, host string) (*Client, error) {\n \t\ttext.Close()\n \t\treturn nil, err\n \t}\n-\tc := &Client{Text: text, conn: conn, serverName: host}\n-\terr = c.ehlo()\n-\tif err != nil {\n-\t\terr = c.helo()\n+\tc := &Client{Text: text, conn: conn, serverName: host, localName: \"localhost\"}\n+\treturn c, nil\n+}\n+\n+// hello runs a hello exchange if needed.\n+func (c *Client) hello() error {\n+\tif !c.didHello {\n+\t\tc.didHello = true\n+\t\terr := c.ehlo()\n+\t\tif err != nil {\n+\t\t\tc.helloError = c.helo()\n+\t\t}\n+\t}\n+\treturn c.helloError\n+}\n+\n+// Hello sends a HELO or EHLO to the server as the given host name.\n+// Calling this method is only necessary if the client needs control\n+// over the host name used.  The client will introduce itself as \"localhost\"\n+// automatically otherwise.  If Hello is called, it must be called before\n+// any of the other methods.\n+func (c *Client) Hello(localName string) error {\n+\tif c.didHello {\n+\t\treturn errors.New(\"smtp: Hello called after other methods\")\n \t}\n-\treturn c, err\n+\tc.localName = localName\n+\treturn c.hello()\n }\n \n // cmd is a convenience function that sends a command and returns the response\n@@ -79,14 +104,14 @@ func (c *Client) cmd(expectCode int, format string, args ...interface{}) (int, s\n // server does not support ehlo.\n func (c *Client) helo() error {\n \tc.ext = nil\n-\t_, _, err := c.cmd(250, \"HELO localhost\")\n+\t_, _, err := c.cmd(250, \"HELO %s\", c.localName)\n \treturn err\n }\n \n // ehlo sends the EHLO (extended hello) greeting to the server. It\n // should be the preferred greeting for servers that support it.\n func (c *Client) ehlo() error {\n-\t_, msg, err := c.cmd(250, \"EHLO localhost\")\n+\t_, msg, err := c.cmd(250, \"EHLO %s\", c.localName)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -113,6 +138,9 @@ func (c *Client) ehlo() error {\n // StartTLS sends the STARTTLS command and encrypts all further communication.\n // Only servers that advertise the STARTTLS extension support this function.\n func (c *Client) StartTLS(config *tls.Config) error {\n+\tif err := c.hello(); err != nil {\n+\t\treturn err\n+\t}\n \t_, _, err := c.cmd(220, \"STARTTLS\")\n \tif err != nil {\n \t\treturn err\n@@ -128,6 +156,9 @@ func (c *Client) StartTLS(config *tls.Config) error {\n // does not necessarily indicate an invalid address. Many servers\n // will not verify addresses for security reasons.\n func (c *Client) Verify(addr string) error {\n+\tif err := c.hello(); err != nil {\n+\t\treturn err\n+\t}\n \t_, _, err := c.cmd(250, \"VRFY %s\", addr)\n \treturn err\n }\n@@ -136,6 +167,9 @@ func (c *Client) Verify(addr string) error {\n // A failed authentication closes the connection.\n // Only servers that advertise the AUTH extension support this function.\n func (c *Client) Auth(a Auth) error {\n+\tif err := c.hello(); err != nil {\n+\t\treturn err\n+\t}\n \tencoding := base64.StdEncoding\n \tmech, resp, err := a.Start(&ServerInfo{c.serverName, c.tls, c.auth})\n \tif err != nil {\n@@ -178,6 +212,9 @@ func (c *Client) Auth(a Auth) error {\n // parameter.\n // This initiates a mail transaction and is followed by one or more Rcpt calls.\n func (c *Client) Mail(from string) error {\n+\tif err := c.hello(); err != nil {\n+\t\treturn err\n+\t}\n \tcmdStr := \"MAIL FROM:<%s>\"\n \tif c.ext != nil {\n \t\tif _, ok := c.ext[\"8BITMIME\"]; ok {\n@@ -227,6 +264,9 @@ func SendMail(addr string, a Auth, from string, to []string, msg []byte) error {\n \tif err != nil {\n \t\treturn err\n \t}\n+\tif err := c.hello(); err != nil {\n+\t\treturn err\n+\t}\n \tif ok, _ := c.Extension(\"STARTTLS\"); ok {\n \t\tif err = c.StartTLS(nil); err != nil {\n \t\t\treturn err\n@@ -267,6 +307,9 @@ func SendMail(addr string, a Auth, from string, to []string, msg []byte) error {\n // Extension also returns a string that contains any parameters the\n // server specifies for the extension.\n func (c *Client) Extension(ext string) (bool, string) {\n+\tif err := c.hello(); err != nil {\n+\t\treturn false, \"\"\n+\t}\n \tif c.ext == nil {\n \t\treturn false, \"\"\n \t}\n@@ -278,12 +321,18 @@ func (c *Client) Extension(ext string) (bool, string) {\n // Reset sends the RSET command to the server, aborting the current mail\n // transaction.\n func (c *Client) Reset() error {\n+\tif err := c.hello(); err != nil {\n+\t\treturn err\n+\t}\n \t_, _, err := c.cmd(250, \"RSET\")\n \treturn err\n }\n \n // Quit sends the QUIT command and closes the connection to the server.\n func (c *Client) Quit() error {\n+\tif err := c.hello(); err != nil {\n+\t\treturn err\n+\t}\n \t_, _, err := c.cmd(221, \"QUIT\")\n \tif err != nil {\n \t\treturn err"}, {"sha": "8317428cb8706818dd8de2fe762064d37be22918", "filename": "libgo/go/net/smtp/smtp_test.go", "status": "modified", "additions": 213, "deletions": 16, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fsmtp%2Fsmtp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Fsmtp%2Fsmtp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsmtp%2Fsmtp_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -69,14 +69,14 @@ func (f faker) SetReadDeadline(time.Time) error  { return nil }\n func (f faker) SetWriteDeadline(time.Time) error { return nil }\n \n func TestBasic(t *testing.T) {\n-\tbasicServer = strings.Join(strings.Split(basicServer, \"\\n\"), \"\\r\\n\")\n-\tbasicClient = strings.Join(strings.Split(basicClient, \"\\n\"), \"\\r\\n\")\n+\tserver := strings.Join(strings.Split(basicServer, \"\\n\"), \"\\r\\n\")\n+\tclient := strings.Join(strings.Split(basicClient, \"\\n\"), \"\\r\\n\")\n \n \tvar cmdbuf bytes.Buffer\n \tbcmdbuf := bufio.NewWriter(&cmdbuf)\n \tvar fake faker\n-\tfake.ReadWriter = bufio.NewReadWriter(bufio.NewReader(strings.NewReader(basicServer)), bcmdbuf)\n-\tc := &Client{Text: textproto.NewConn(fake)}\n+\tfake.ReadWriter = bufio.NewReadWriter(bufio.NewReader(strings.NewReader(server)), bcmdbuf)\n+\tc := &Client{Text: textproto.NewConn(fake), localName: \"localhost\"}\n \n \tif err := c.helo(); err != nil {\n \t\tt.Fatalf(\"HELO failed: %s\", err)\n@@ -88,6 +88,7 @@ func TestBasic(t *testing.T) {\n \t\tt.Fatalf(\"Second EHLO failed: %s\", err)\n \t}\n \n+\tc.didHello = true\n \tif ok, args := c.Extension(\"aUtH\"); !ok || args != \"LOGIN PLAIN\" {\n \t\tt.Fatalf(\"Expected AUTH supported\")\n \t}\n@@ -143,8 +144,8 @@ Goodbye.`\n \n \tbcmdbuf.Flush()\n \tactualcmds := cmdbuf.String()\n-\tif basicClient != actualcmds {\n-\t\tt.Fatalf(\"Got:\\n%s\\nExpected:\\n%s\", actualcmds, basicClient)\n+\tif client != actualcmds {\n+\t\tt.Fatalf(\"Got:\\n%s\\nExpected:\\n%s\", actualcmds, client)\n \t}\n }\n \n@@ -187,8 +188,8 @@ QUIT\n `\n \n func TestNewClient(t *testing.T) {\n-\tnewClientServer = strings.Join(strings.Split(newClientServer, \"\\n\"), \"\\r\\n\")\n-\tnewClientClient = strings.Join(strings.Split(newClientClient, \"\\n\"), \"\\r\\n\")\n+\tserver := strings.Join(strings.Split(newClientServer, \"\\n\"), \"\\r\\n\")\n+\tclient := strings.Join(strings.Split(newClientClient, \"\\n\"), \"\\r\\n\")\n \n \tvar cmdbuf bytes.Buffer\n \tbcmdbuf := bufio.NewWriter(&cmdbuf)\n@@ -197,7 +198,7 @@ func TestNewClient(t *testing.T) {\n \t\treturn cmdbuf.String()\n \t}\n \tvar fake faker\n-\tfake.ReadWriter = bufio.NewReadWriter(bufio.NewReader(strings.NewReader(newClientServer)), bcmdbuf)\n+\tfake.ReadWriter = bufio.NewReadWriter(bufio.NewReader(strings.NewReader(server)), bcmdbuf)\n \tc, err := NewClient(fake, \"fake.host\")\n \tif err != nil {\n \t\tt.Fatalf(\"NewClient: %v\\n(after %v)\", err, out())\n@@ -213,8 +214,8 @@ func TestNewClient(t *testing.T) {\n \t}\n \n \tactualcmds := out()\n-\tif newClientClient != actualcmds {\n-\t\tt.Fatalf(\"Got:\\n%s\\nExpected:\\n%s\", actualcmds, newClientClient)\n+\tif client != actualcmds {\n+\t\tt.Fatalf(\"Got:\\n%s\\nExpected:\\n%s\", actualcmds, client)\n \t}\n }\n \n@@ -231,13 +232,13 @@ QUIT\n `\n \n func TestNewClient2(t *testing.T) {\n-\tnewClient2Server = strings.Join(strings.Split(newClient2Server, \"\\n\"), \"\\r\\n\")\n-\tnewClient2Client = strings.Join(strings.Split(newClient2Client, \"\\n\"), \"\\r\\n\")\n+\tserver := strings.Join(strings.Split(newClient2Server, \"\\n\"), \"\\r\\n\")\n+\tclient := strings.Join(strings.Split(newClient2Client, \"\\n\"), \"\\r\\n\")\n \n \tvar cmdbuf bytes.Buffer\n \tbcmdbuf := bufio.NewWriter(&cmdbuf)\n \tvar fake faker\n-\tfake.ReadWriter = bufio.NewReadWriter(bufio.NewReader(strings.NewReader(newClient2Server)), bcmdbuf)\n+\tfake.ReadWriter = bufio.NewReadWriter(bufio.NewReader(strings.NewReader(server)), bcmdbuf)\n \tc, err := NewClient(fake, \"fake.host\")\n \tif err != nil {\n \t\tt.Fatalf(\"NewClient: %v\", err)\n@@ -251,8 +252,8 @@ func TestNewClient2(t *testing.T) {\n \n \tbcmdbuf.Flush()\n \tactualcmds := cmdbuf.String()\n-\tif newClient2Client != actualcmds {\n-\t\tt.Fatalf(\"Got:\\n%s\\nExpected:\\n%s\", actualcmds, newClient2Client)\n+\tif client != actualcmds {\n+\t\tt.Fatalf(\"Got:\\n%s\\nExpected:\\n%s\", actualcmds, client)\n \t}\n }\n \n@@ -269,3 +270,199 @@ var newClient2Client = `EHLO localhost\n HELO localhost\n QUIT\n `\n+\n+func TestHello(t *testing.T) {\n+\n+\tif len(helloServer) != len(helloClient) {\n+\t\tt.Fatalf(\"Hello server and client size mismatch\")\n+\t}\n+\n+\tfor i := 0; i < len(helloServer); i++ {\n+\t\tserver := strings.Join(strings.Split(baseHelloServer+helloServer[i], \"\\n\"), \"\\r\\n\")\n+\t\tclient := strings.Join(strings.Split(baseHelloClient+helloClient[i], \"\\n\"), \"\\r\\n\")\n+\t\tvar cmdbuf bytes.Buffer\n+\t\tbcmdbuf := bufio.NewWriter(&cmdbuf)\n+\t\tvar fake faker\n+\t\tfake.ReadWriter = bufio.NewReadWriter(bufio.NewReader(strings.NewReader(server)), bcmdbuf)\n+\t\tc, err := NewClient(fake, \"fake.host\")\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"NewClient: %v\", err)\n+\t\t}\n+\t\tc.localName = \"customhost\"\n+\t\terr = nil\n+\n+\t\tswitch i {\n+\t\tcase 0:\n+\t\t\terr = c.Hello(\"customhost\")\n+\t\tcase 1:\n+\t\t\terr = c.StartTLS(nil)\n+\t\t\tif err.Error() == \"502 Not implemented\" {\n+\t\t\t\terr = nil\n+\t\t\t}\n+\t\tcase 2:\n+\t\t\terr = c.Verify(\"test@example.com\")\n+\t\tcase 3:\n+\t\t\tc.tls = true\n+\t\t\tc.serverName = \"smtp.google.com\"\n+\t\t\terr = c.Auth(PlainAuth(\"\", \"user\", \"pass\", \"smtp.google.com\"))\n+\t\tcase 4:\n+\t\t\terr = c.Mail(\"test@example.com\")\n+\t\tcase 5:\n+\t\t\tok, _ := c.Extension(\"feature\")\n+\t\t\tif ok {\n+\t\t\t\tt.Errorf(\"Expected FEATURE not to be supported\")\n+\t\t\t}\n+\t\tcase 6:\n+\t\t\terr = c.Reset()\n+\t\tcase 7:\n+\t\t\terr = c.Quit()\n+\t\tcase 8:\n+\t\t\terr = c.Verify(\"test@example.com\")\n+\t\t\tif err != nil {\n+\t\t\t\terr = c.Hello(\"customhost\")\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"Want error, got none\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\tdefault:\n+\t\t\tt.Fatalf(\"Unhandled command\")\n+\t\t}\n+\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"Command %d failed: %v\", i, err)\n+\t\t}\n+\n+\t\tbcmdbuf.Flush()\n+\t\tactualcmds := cmdbuf.String()\n+\t\tif client != actualcmds {\n+\t\t\tt.Errorf(\"Got:\\n%s\\nExpected:\\n%s\", actualcmds, client)\n+\t\t}\n+\t}\n+}\n+\n+var baseHelloServer = `220 hello world\n+502 EH?\n+250-mx.google.com at your service\n+250 FEATURE\n+`\n+\n+var helloServer = []string{\n+\t\"\",\n+\t\"502 Not implemented\\n\",\n+\t\"250 User is valid\\n\",\n+\t\"235 Accepted\\n\",\n+\t\"250 Sender ok\\n\",\n+\t\"\",\n+\t\"250 Reset ok\\n\",\n+\t\"221 Goodbye\\n\",\n+\t\"250 Sender ok\\n\",\n+}\n+\n+var baseHelloClient = `EHLO customhost\n+HELO customhost\n+`\n+\n+var helloClient = []string{\n+\t\"\",\n+\t\"STARTTLS\\n\",\n+\t\"VRFY test@example.com\\n\",\n+\t\"AUTH PLAIN AHVzZXIAcGFzcw==\\n\",\n+\t\"MAIL FROM:<test@example.com>\\n\",\n+\t\"\",\n+\t\"RSET\\n\",\n+\t\"QUIT\\n\",\n+\t\"VRFY test@example.com\\n\",\n+}\n+\n+func TestSendMail(t *testing.T) {\n+\tserver := strings.Join(strings.Split(sendMailServer, \"\\n\"), \"\\r\\n\")\n+\tclient := strings.Join(strings.Split(sendMailClient, \"\\n\"), \"\\r\\n\")\n+\tvar cmdbuf bytes.Buffer\n+\tbcmdbuf := bufio.NewWriter(&cmdbuf)\n+\tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Unable to to create listener: %v\", err)\n+\t}\n+\tdefer l.Close()\n+\n+\t// prevent data race on bcmdbuf\n+\tvar done = make(chan struct{})\n+\tgo func(data []string) {\n+\n+\t\tdefer close(done)\n+\n+\t\tconn, err := l.Accept()\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"Accept error: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t\tdefer conn.Close()\n+\n+\t\ttc := textproto.NewConn(conn)\n+\t\tfor i := 0; i < len(data) && data[i] != \"\"; i++ {\n+\t\t\ttc.PrintfLine(data[i])\n+\t\t\tfor len(data[i]) >= 4 && data[i][3] == '-' {\n+\t\t\t\ti++\n+\t\t\t\ttc.PrintfLine(data[i])\n+\t\t\t}\n+\t\t\tif data[i] == \"221 Goodbye\" {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tread := false\n+\t\t\tfor !read || data[i] == \"354 Go ahead\" {\n+\t\t\t\tmsg, err := tc.ReadLine()\n+\t\t\t\tbcmdbuf.Write([]byte(msg + \"\\r\\n\"))\n+\t\t\t\tread = true\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"Read error: %v\", err)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tif data[i] == \"354 Go ahead\" && msg == \".\" {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}(strings.Split(server, \"\\r\\n\"))\n+\n+\terr = SendMail(l.Addr().String(), nil, \"test@example.com\", []string{\"other@example.com\"}, []byte(strings.Replace(`From: test@example.com\n+To: other@example.com\n+Subject: SendMail test\n+\n+SendMail is working for me.\n+`, \"\\n\", \"\\r\\n\", -1)))\n+\n+\tif err != nil {\n+\t\tt.Errorf(\"%v\", err)\n+\t}\n+\n+\t<-done\n+\tbcmdbuf.Flush()\n+\tactualcmds := cmdbuf.String()\n+\tif client != actualcmds {\n+\t\tt.Errorf(\"Got:\\n%s\\nExpected:\\n%s\", actualcmds, client)\n+\t}\n+}\n+\n+var sendMailServer = `220 hello world\n+502 EH?\n+250 mx.google.com at your service\n+250 Sender ok\n+250 Receiver ok\n+354 Go ahead\n+250 Data ok\n+221 Goodbye\n+`\n+\n+var sendMailClient = `EHLO localhost\n+HELO localhost\n+MAIL FROM:<test@example.com>\n+RCPT TO:<other@example.com>\n+DATA\n+From: test@example.com\n+To: other@example.com\n+Subject: SendMail test\n+\n+SendMail is working for me.\n+.\n+QUIT\n+`"}, {"sha": "713820c6659ad35786a44837e254219c763c8f8f", "filename": "libgo/go/net/unixsock_plan9.go", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Funixsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Funixsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Funixsock_plan9.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -64,21 +64,21 @@ func (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err\n \treturn 0, 0, syscall.EPLAN9\n }\n \n-// CloseRead shuts down the reading side of the Unix domain\n-// connection.  Most callers should just use Close.\n+// CloseRead shuts down the reading side of the Unix domain connection.\n+// Most callers should just use Close.\n func (c *UnixConn) CloseRead() error {\n \treturn syscall.EPLAN9\n }\n \n-// CloseWrite shuts down the writing side of the Unix domain\n-// connection.  Most callers should just use Close.\n+// CloseWrite shuts down the writing side of the Unix domain connection.\n+// Most callers should just use Close.\n func (c *UnixConn) CloseWrite() error {\n \treturn syscall.EPLAN9\n }\n \n // DialUnix connects to the remote address raddr on the network net,\n-// which must be \"unix\" or \"unixgram\".  If laddr is not nil, it is\n-// used as the local address for the connection.\n+// which must be \"unix\", \"unixgram\" or \"unixpacket\".  If laddr is not\n+// nil, it is used as the local address for the connection.\n func DialUnix(net string, laddr, raddr *UnixAddr) (*UnixConn, error) {\n \treturn dialUnix(net, laddr, raddr, noDeadline)\n }\n@@ -93,7 +93,8 @@ func dialUnix(net string, laddr, raddr *UnixAddr, deadline time.Time) (*UnixConn\n type UnixListener struct{}\n \n // ListenUnix announces on the Unix domain socket laddr and returns a\n-// Unix listener.  Net must be \"unix\" (stream sockets).\n+// Unix listener.  The network net must be \"unix\", \"unixgram\" or\n+// \"unixpacket\".\n func ListenUnix(net string, laddr *UnixAddr) (*UnixListener, error) {\n \treturn nil, syscall.EPLAN9\n }\n@@ -134,8 +135,8 @@ func (l *UnixListener) File() (*os.File, error) {\n \n // ListenUnixgram listens for incoming Unix datagram packets addressed\n // to the local address laddr.  The returned connection c's ReadFrom\n-// and WriteTo methods can be used to receive and send UDP packets\n-// with per-packet addressing.  The network net must be \"unixgram\".\n-func ListenUnixgram(net string, laddr *UnixAddr) (*UDPConn, error) {\n+// and WriteTo methods can be used to receive and send packets with\n+// per-packet addressing.  The network net must be \"unixgram\".\n+func ListenUnixgram(net string, laddr *UnixAddr) (*UnixConn, error) {\n \treturn nil, syscall.EPLAN9\n }"}, {"sha": "653190c203cbb5ddfdc2ef7b13835cd5fe6d655f", "filename": "libgo/go/net/unixsock_posix.go", "status": "modified", "additions": 74, "deletions": 73, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Funixsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Funixsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Funixsock_posix.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -9,29 +9,27 @@\n package net\n \n import (\n+\t\"errors\"\n \t\"os\"\n \t\"syscall\"\n \t\"time\"\n )\n \n-func unixSocket(net string, laddr, raddr *UnixAddr, mode string, deadline time.Time) (fd *netFD, err error) {\n+func unixSocket(net string, laddr, raddr *UnixAddr, mode string, deadline time.Time) (*netFD, error) {\n \tvar sotype int\n \tswitch net {\n-\tdefault:\n-\t\treturn nil, UnknownNetworkError(net)\n \tcase \"unix\":\n \t\tsotype = syscall.SOCK_STREAM\n \tcase \"unixgram\":\n \t\tsotype = syscall.SOCK_DGRAM\n \tcase \"unixpacket\":\n \t\tsotype = syscall.SOCK_SEQPACKET\n+\tdefault:\n+\t\treturn nil, UnknownNetworkError(net)\n \t}\n \n \tvar la, ra syscall.Sockaddr\n \tswitch mode {\n-\tdefault:\n-\t\tpanic(\"unixSocket mode \" + mode)\n-\n \tcase \"dial\":\n \t\tif laddr != nil {\n \t\t\tla = &syscall.SockaddrUnix{Name: laddr.Name}\n@@ -41,15 +39,10 @@ func unixSocket(net string, laddr, raddr *UnixAddr, mode string, deadline time.T\n \t\t} else if sotype != syscall.SOCK_DGRAM || laddr == nil {\n \t\t\treturn nil, &OpError{Op: mode, Net: net, Err: errMissingAddress}\n \t\t}\n-\n \tcase \"listen\":\n-\t\tif laddr == nil {\n-\t\t\treturn nil, &OpError{mode, net, nil, errMissingAddress}\n-\t\t}\n \t\tla = &syscall.SockaddrUnix{Name: laddr.Name}\n-\t\tif raddr != nil {\n-\t\t\treturn nil, &OpError{Op: mode, Net: net, Addr: raddr, Err: &AddrError{Err: \"unexpected remote address\", Addr: raddr.String()}}\n-\t\t}\n+\tdefault:\n+\t\treturn nil, errors.New(\"unknown mode: \" + mode)\n \t}\n \n \tf := sockaddrToUnix\n@@ -59,15 +52,16 @@ func unixSocket(net string, laddr, raddr *UnixAddr, mode string, deadline time.T\n \t\tf = sockaddrToUnixpacket\n \t}\n \n-\tfd, err = socket(net, syscall.AF_UNIX, sotype, 0, false, la, ra, deadline, f)\n+\tfd, err := socket(net, syscall.AF_UNIX, sotype, 0, false, la, ra, deadline, f)\n \tif err != nil {\n-\t\tgoto Error\n+\t\tgoto error\n \t}\n \treturn fd, nil\n \n-Error:\n+error:\n \taddr := raddr\n-\tif mode == \"listen\" {\n+\tswitch mode {\n+\tcase \"listen\":\n \t\taddr = laddr\n \t}\n \treturn nil, &OpError{Op: mode, Net: net, Addr: addr, Err: err}\n@@ -108,21 +102,21 @@ func sotypeToNet(sotype int) string {\n \treturn \"\"\n }\n \n-// UnixConn is an implementation of the Conn interface\n-// for connections to Unix domain sockets.\n+// UnixConn is an implementation of the Conn interface for connections\n+// to Unix domain sockets.\n type UnixConn struct {\n \tconn\n }\n \n func newUnixConn(fd *netFD) *UnixConn { return &UnixConn{conn{fd}} }\n \n-// ReadFromUnix reads a packet from c, copying the payload into b.\n-// It returns the number of bytes copied into b and the source address\n-// of the packet.\n+// ReadFromUnix reads a packet from c, copying the payload into b.  It\n+// returns the number of bytes copied into b and the source address of\n+// the packet.\n //\n-// ReadFromUnix can be made to time out and return\n-// an error with Timeout() == true after a fixed time limit;\n-// see SetDeadline and SetReadDeadline.\n+// ReadFromUnix can be made to time out and return an error with\n+// Timeout() == true after a fixed time limit; see SetDeadline and\n+// SetReadDeadline.\n func (c *UnixConn) ReadFromUnix(b []byte) (n int, addr *UnixAddr, err error) {\n \tif !c.ok() {\n \t\treturn 0, nil, syscall.EINVAL\n@@ -144,12 +138,28 @@ func (c *UnixConn) ReadFrom(b []byte) (n int, addr Addr, err error) {\n \treturn n, uaddr.toAddr(), err\n }\n \n+// ReadMsgUnix reads a packet from c, copying the payload into b and\n+// the associated out-of-band data into oob.  It returns the number of\n+// bytes copied into b, the number of bytes copied into oob, the flags\n+// that were set on the packet, and the source address of the packet.\n+func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error) {\n+\tif !c.ok() {\n+\t\treturn 0, 0, 0, nil, syscall.EINVAL\n+\t}\n+\tn, oobn, flags, sa, err := c.fd.ReadMsg(b, oob)\n+\tswitch sa := sa.(type) {\n+\tcase *syscall.SockaddrUnix:\n+\t\taddr = &UnixAddr{sa.Name, sotypeToNet(c.fd.sotype)}\n+\t}\n+\treturn\n+}\n+\n // WriteToUnix writes a packet to addr via c, copying the payload from b.\n //\n-// WriteToUnix can be made to time out and return\n-// an error with Timeout() == true after a fixed time limit;\n-// see SetDeadline and SetWriteDeadline.\n-// On packet-oriented connections, write timeouts are rare.\n+// WriteToUnix can be made to time out and return an error with\n+// Timeout() == true after a fixed time limit; see SetDeadline and\n+// SetWriteDeadline.  On packet-oriented connections, write timeouts\n+// are rare.\n func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (n int, err error) {\n \tif !c.ok() {\n \t\treturn 0, syscall.EINVAL\n@@ -173,26 +183,9 @@ func (c *UnixConn) WriteTo(b []byte, addr Addr) (n int, err error) {\n \treturn c.WriteToUnix(b, a)\n }\n \n-// ReadMsgUnix reads a packet from c, copying the payload into b\n-// and the associated out-of-band data into oob.\n-// It returns the number of bytes copied into b, the number of\n-// bytes copied into oob, the flags that were set on the packet,\n-// and the source address of the packet.\n-func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error) {\n-\tif !c.ok() {\n-\t\treturn 0, 0, 0, nil, syscall.EINVAL\n-\t}\n-\tn, oobn, flags, sa, err := c.fd.ReadMsg(b, oob)\n-\tswitch sa := sa.(type) {\n-\tcase *syscall.SockaddrUnix:\n-\t\taddr = &UnixAddr{sa.Name, sotypeToNet(c.fd.sotype)}\n-\t}\n-\treturn\n-}\n-\n-// WriteMsgUnix writes a packet to addr via c, copying the payload from b\n-// and the associated out-of-band data from oob.  It returns the number\n-// of payload and out-of-band bytes written.\n+// WriteMsgUnix writes a packet to addr via c, copying the payload\n+// from b and the associated out-of-band data from oob.  It returns\n+// the number of payload and out-of-band bytes written.\n func (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err error) {\n \tif !c.ok() {\n \t\treturn 0, 0, syscall.EINVAL\n@@ -226,36 +219,44 @@ func (c *UnixConn) CloseWrite() error {\n }\n \n // DialUnix connects to the remote address raddr on the network net,\n-// which must be \"unix\" or \"unixgram\".  If laddr is not nil, it is used\n-// as the local address for the connection.\n+// which must be \"unix\", \"unixgram\" or \"unixpacket\".  If laddr is not\n+// nil, it is used as the local address for the connection.\n func DialUnix(net string, laddr, raddr *UnixAddr) (*UnixConn, error) {\n \treturn dialUnix(net, laddr, raddr, noDeadline)\n }\n \n func dialUnix(net string, laddr, raddr *UnixAddr, deadline time.Time) (*UnixConn, error) {\n+\tswitch net {\n+\tcase \"unix\", \"unixgram\", \"unixpacket\":\n+\tdefault:\n+\t\treturn nil, UnknownNetworkError(net)\n+\t}\n \tfd, err := unixSocket(net, laddr, raddr, \"dial\", deadline)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \treturn newUnixConn(fd), nil\n }\n \n-// UnixListener is a Unix domain socket listener.\n-// Clients should typically use variables of type Listener\n-// instead of assuming Unix domain sockets.\n+// UnixListener is a Unix domain socket listener.  Clients should\n+// typically use variables of type Listener instead of assuming Unix\n+// domain sockets.\n type UnixListener struct {\n \tfd   *netFD\n \tpath string\n }\n \n-// ListenUnix announces on the Unix domain socket laddr and returns a Unix listener.\n-// Net must be \"unix\" (stream sockets).\n+// ListenUnix announces on the Unix domain socket laddr and returns a\n+// Unix listener.  The network net must be \"unix\", \"unixgram\" or\n+// \"unixpacket\".\n func ListenUnix(net string, laddr *UnixAddr) (*UnixListener, error) {\n-\tif net != \"unix\" && net != \"unixgram\" && net != \"unixpacket\" {\n+\tswitch net {\n+\tcase \"unix\", \"unixgram\", \"unixpacket\":\n+\tdefault:\n \t\treturn nil, UnknownNetworkError(net)\n \t}\n-\tif laddr != nil {\n-\t\tladdr = &UnixAddr{laddr.Name, net} // make our own copy\n+\tif laddr == nil {\n+\t\treturn nil, &OpError{\"listen\", net, nil, errMissingAddress}\n \t}\n \tfd, err := unixSocket(net, laddr, nil, \"listen\", noDeadline)\n \tif err != nil {\n@@ -269,8 +270,8 @@ func ListenUnix(net string, laddr *UnixAddr) (*UnixListener, error) {\n \treturn &UnixListener{fd, laddr.Name}, nil\n }\n \n-// AcceptUnix accepts the next incoming call and returns the new connection\n-// and the remote address.\n+// AcceptUnix accepts the next incoming call and returns the new\n+// connection and the remote address.\n func (l *UnixListener) AcceptUnix() (*UnixConn, error) {\n \tif l == nil || l.fd == nil {\n \t\treturn nil, syscall.EINVAL\n@@ -283,8 +284,8 @@ func (l *UnixListener) AcceptUnix() (*UnixConn, error) {\n \treturn c, nil\n }\n \n-// Accept implements the Accept method in the Listener interface;\n-// it waits for the next call and returns a generic Conn.\n+// Accept implements the Accept method in the Listener interface; it\n+// waits for the next call and returns a generic Conn.\n func (l *UnixListener) Accept() (c Conn, err error) {\n \tc1, err := l.AcceptUnix()\n \tif err != nil {\n@@ -293,8 +294,8 @@ func (l *UnixListener) Accept() (c Conn, err error) {\n \treturn c1, nil\n }\n \n-// Close stops listening on the Unix address.\n-// Already accepted connections are not closed.\n+// Close stops listening on the Unix address.  Already accepted\n+// connections are not closed.\n func (l *UnixListener) Close() error {\n \tif l == nil || l.fd == nil {\n \t\treturn syscall.EINVAL\n@@ -328,16 +329,16 @@ func (l *UnixListener) SetDeadline(t time.Time) (err error) {\n \treturn setDeadline(l.fd, t)\n }\n \n-// File returns a copy of the underlying os.File, set to blocking mode.\n-// It is the caller's responsibility to close f when finished.\n+// File returns a copy of the underlying os.File, set to blocking\n+// mode.  It is the caller's responsibility to close f when finished.\n // Closing l does not affect f, and closing f does not affect l.\n func (l *UnixListener) File() (f *os.File, err error) { return l.fd.dup() }\n \n-// ListenUnixgram listens for incoming Unix datagram packets addressed to the\n-// local address laddr.  The returned connection c's ReadFrom\n-// and WriteTo methods can be used to receive and send UDP\n-// packets with per-packet addressing.  The network net must be \"unixgram\".\n-func ListenUnixgram(net string, laddr *UnixAddr) (*UDPConn, error) {\n+// ListenUnixgram listens for incoming Unix datagram packets addressed\n+// to the local address laddr.  The returned connection c's ReadFrom\n+// and WriteTo methods can be used to receive and send packets with\n+// per-packet addressing.  The network net must be \"unixgram\".\n+func ListenUnixgram(net string, laddr *UnixAddr) (*UnixConn, error) {\n \tswitch net {\n \tcase \"unixgram\":\n \tdefault:\n@@ -350,5 +351,5 @@ func ListenUnixgram(net string, laddr *UnixAddr) (*UDPConn, error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn newUDPConn(fd), nil\n+\treturn newUnixConn(fd), nil\n }"}, {"sha": "71758fe49e00997be3458ea2c0dfc20b704f379b", "filename": "libgo/go/net/url/url.go", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Furl%2Furl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Furl%2Furl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Furl%2Furl.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -361,6 +361,11 @@ func parse(rawurl string, viaRequest bool) (url *URL, err error) {\n \t}\n \turl = new(URL)\n \n+\tif rawurl == \"*\" {\n+\t\turl.Path = \"*\"\n+\t\treturn\n+\t}\n+\n \t// Split off possible leading \"http:\", \"mailto:\", etc.\n \t// Cannot contain escaped characters.\n \tif url.Scheme, rest, err = getscheme(rawurl); err != nil {\n@@ -572,23 +577,33 @@ func resolvePath(basepath string, refpath string) string {\n \tif len(base) == 0 {\n \t\tbase = []string{\"\"}\n \t}\n+\n+\trm := true\n \tfor idx, ref := range refs {\n \t\tswitch {\n \t\tcase ref == \".\":\n-\t\t\tbase[len(base)-1] = \"\"\n+\t\t\tif idx == 0 {\n+\t\t\t\tbase[len(base)-1] = \"\"\n+\t\t\t\trm = true\n+\t\t\t} else {\n+\t\t\t\trm = false\n+\t\t\t}\n \t\tcase ref == \"..\":\n \t\t\tnewLen := len(base) - 1\n \t\t\tif newLen < 1 {\n \t\t\t\tnewLen = 1\n \t\t\t}\n \t\t\tbase = base[0:newLen]\n-\t\t\tbase[len(base)-1] = \"\"\n+\t\t\tif rm {\n+\t\t\t\tbase[len(base)-1] = \"\"\n+\t\t\t}\n \t\tdefault:\n \t\t\tif idx == 0 || base[len(base)-1] == \"\" {\n \t\t\t\tbase[len(base)-1] = ref\n \t\t\t} else {\n \t\t\t\tbase = append(base, ref)\n \t\t\t}\n+\t\t\trm = false\n \t\t}\n \t}\n \treturn strings.Join(base, \"/\")"}, {"sha": "4d3545dadb74f7a3e11945a99472fb7ffbfa66ba", "filename": "libgo/go/net/url/url_test.go", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Furl%2Furl_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fnet%2Furl%2Furl_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Furl%2Furl_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -277,7 +277,7 @@ func TestParse(t *testing.T) {\n \n const pathThatLooksSchemeRelative = \"//not.a.user@not.a.host/just/a/path\"\n \n-var parseRequestUrlTests = []struct {\n+var parseRequestURLTests = []struct {\n \turl           string\n \texpectedValid bool\n }{\n@@ -289,10 +289,11 @@ var parseRequestUrlTests = []struct {\n \t{\"//not.a.user@%66%6f%6f.com/just/a/path/also\", true},\n \t{\"foo.html\", false},\n \t{\"../dir/\", false},\n+\t{\"*\", true},\n }\n \n func TestParseRequestURI(t *testing.T) {\n-\tfor _, test := range parseRequestUrlTests {\n+\tfor _, test := range parseRequestURLTests {\n \t\t_, err := ParseRequestURI(test.url)\n \t\tvalid := err == nil\n \t\tif valid != test.expectedValid {\n@@ -536,6 +537,15 @@ var resolveReferenceTests = []struct {\n \t{\"http://foo.com/bar/baz\", \"../../../../../quux\", \"http://foo.com/quux\"},\n \t{\"http://foo.com/bar\", \"..\", \"http://foo.com/\"},\n \t{\"http://foo.com/bar/baz\", \"./..\", \"http://foo.com/\"},\n+\t// \"..\" in the middle (issue 3560)\n+\t{\"http://foo.com/bar/baz\", \"quux/dotdot/../tail\", \"http://foo.com/bar/quux/tail\"},\n+\t{\"http://foo.com/bar/baz\", \"quux/./dotdot/../tail\", \"http://foo.com/bar/quux/tail\"},\n+\t{\"http://foo.com/bar/baz\", \"quux/./dotdot/.././tail\", \"http://foo.com/bar/quux/tail\"},\n+\t{\"http://foo.com/bar/baz\", \"quux/./dotdot/./../tail\", \"http://foo.com/bar/quux/tail\"},\n+\t{\"http://foo.com/bar/baz\", \"quux/./dotdot/dotdot/././../../tail\", \"http://foo.com/bar/quux/tail\"},\n+\t{\"http://foo.com/bar/baz\", \"quux/./dotdot/dotdot/./.././../tail\", \"http://foo.com/bar/quux/tail\"},\n+\t{\"http://foo.com/bar/baz\", \"quux/./dotdot/dotdot/dotdot/./../../.././././tail\", \"http://foo.com/bar/quux/tail\"},\n+\t{\"http://foo.com/bar/baz\", \"quux/./dotdot/../dotdot/../dot/./tail/..\", \"http://foo.com/bar/quux/dot\"},\n \n \t// \".\" and \"..\" in the base aren't special\n \t{\"http://foo.com/dot/./dotdot/../foo/bar\", \"../baz\", \"http://foo.com/dot/./dotdot/../baz\"},"}, {"sha": "db7fc72b8a4d11d4993d1aba53994c86422760b9", "filename": "libgo/go/os/env.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fos%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fos%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fenv.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -9,7 +9,7 @@ package os\n import \"syscall\"\n \n // Expand replaces ${var} or $var in the string based on the mapping function.\n-// Invocations of undefined variables are replaced with the empty string.\n+// For example, os.ExpandEnv(s) is equivalent to os.Expand(s, os.Getenv).\n func Expand(s string, mapping func(string) string) string {\n \tbuf := make([]byte, 0, 2*len(s))\n \t// ${} is all ASCII, so bytes are fine for this operation."}, {"sha": "b979fed97f7f9c77a336b4aff2e791c5d9b2e035", "filename": "libgo/go/os/file_posix.go", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fos%2Ffile_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fos%2Ffile_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_posix.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -153,12 +153,10 @@ func (f *File) Sync() (err error) {\n // less precise time unit.\n // If there is an error, it will be of type *PathError.\n func Chtimes(name string, atime time.Time, mtime time.Time) error {\n-\tvar utimes [2]syscall.Timeval\n-\tatime_ns := atime.Unix()*1e9 + int64(atime.Nanosecond())\n-\tmtime_ns := mtime.Unix()*1e9 + int64(mtime.Nanosecond())\n-\tutimes[0] = syscall.NsecToTimeval(atime_ns)\n-\tutimes[1] = syscall.NsecToTimeval(mtime_ns)\n-\tif e := syscall.Utimes(name, utimes[0:]); e != nil {\n+\tvar utimes [2]syscall.Timespec\n+\tutimes[0] = syscall.NsecToTimespec(atime.UnixNano())\n+\tutimes[1] = syscall.NsecToTimespec(mtime.UnixNano())\n+\tif e := syscall.UtimesNano(name, utimes[0:]); e != nil {\n \t\treturn &PathError{\"chtimes\", name, e}\n \t}\n \treturn nil"}, {"sha": "e1e2777ff06889abcc46a4f302aa540446ac6c3b", "filename": "libgo/go/os/user/lookup_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin freebsd linux netbsd\n+// +build darwin freebsd linux netbsd openbsd\n // +build cgo\n \n package user"}, {"sha": "a6a659c403144baf12fb249cc9fe51e8d61b3732", "filename": "libgo/go/regexp/all_test.go", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fregexp%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fregexp%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fall_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -31,53 +31,52 @@ var good_re = []string{\n \t`\\!\\\\`,\n }\n \n-/*\n type stringError struct {\n \tre  string\n-\terr error\n+\terr string\n }\n \n var bad_re = []stringError{\n-\t{`*`, ErrBareClosure},\n-\t{`+`, ErrBareClosure},\n-\t{`?`, ErrBareClosure},\n-\t{`(abc`, ErrUnmatchedLpar},\n-\t{`abc)`, ErrUnmatchedRpar},\n-\t{`x[a-z`, ErrUnmatchedLbkt},\n-\t{`abc]`, ErrUnmatchedRbkt},\n-\t{`[z-a]`, ErrBadRange},\n-\t{`abc\\`, ErrExtraneousBackslash},\n-\t{`a**`, ErrBadClosure},\n-\t{`a*+`, ErrBadClosure},\n-\t{`a??`, ErrBadClosure},\n-\t{`\\x`, ErrBadBackslash},\n-}\n-*/\n-\n-func compileTest(t *testing.T, expr string, error error) *Regexp {\n+\t{`*`, \"missing argument to repetition operator: `*`\"},\n+\t{`+`, \"missing argument to repetition operator: `+`\"},\n+\t{`?`, \"missing argument to repetition operator: `?`\"},\n+\t{`(abc`, \"missing closing ): `(abc`\"},\n+\t{`abc)`, \"unexpected ): `abc)`\"},\n+\t{`x[a-z`, \"missing closing ]: `[a-z`\"},\n+\t{`[z-a]`, \"invalid character class range: `z-a`\"},\n+\t{`abc\\`, \"trailing backslash at end of expression\"},\n+\t{`a**`, \"invalid nested repetition operator: `**`\"},\n+\t{`a*+`, \"invalid nested repetition operator: `*+`\"},\n+\t{`\\x`, \"invalid escape sequence: `\\\\x`\"},\n+}\n+\n+func compileTest(t *testing.T, expr string, error string) *Regexp {\n \tre, err := Compile(expr)\n-\tif err != error {\n+\tif error == \"\" && err != nil {\n \t\tt.Error(\"compiling `\", expr, \"`; unexpected error: \", err.Error())\n \t}\n+\tif error != \"\" && err == nil {\n+\t\tt.Error(\"compiling `\", expr, \"`; missing error\")\n+\t} else if error != \"\" && !strings.Contains(err.Error(), error) {\n+\t\tt.Error(\"compiling `\", expr, \"`; wrong error: \", err.Error(), \"; want \", error)\n+\t}\n \treturn re\n }\n \n func TestGoodCompile(t *testing.T) {\n \tfor i := 0; i < len(good_re); i++ {\n-\t\tcompileTest(t, good_re[i], nil)\n+\t\tcompileTest(t, good_re[i], \"\")\n \t}\n }\n \n-/*\n func TestBadCompile(t *testing.T) {\n \tfor i := 0; i < len(bad_re); i++ {\n \t\tcompileTest(t, bad_re[i].re, bad_re[i].err)\n \t}\n }\n-*/\n \n func matchTest(t *testing.T, test *FindTest) {\n-\tre := compileTest(t, test.pat, nil)\n+\tre := compileTest(t, test.pat, \"\")\n \tif re == nil {\n \t\treturn\n \t}"}, {"sha": "335f7395d93995b6ee64d13f5c99aaf6dd8ba335", "filename": "libgo/go/regexp/syntax/parse.go", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -42,11 +42,9 @@ const (\n \tErrMissingParen          ErrorCode = \"missing closing )\"\n \tErrMissingRepeatArgument ErrorCode = \"missing argument to repetition operator\"\n \tErrTrailingBackslash     ErrorCode = \"trailing backslash at end of expression\"\n+\tErrUnexpectedParen       ErrorCode = \"unexpected )\"\n )\n \n-// TODO: Export for Go 1.1.\n-const errUnexpectedParen ErrorCode = \"unexpected )\"\n-\n func (e ErrorCode) String() string {\n \treturn string(e)\n }\n@@ -1167,13 +1165,13 @@ func (p *parser) parseRightParen() error {\n \n \tn := len(p.stack)\n \tif n < 2 {\n-\t\treturn &Error{errUnexpectedParen, p.wholeRegexp}\n+\t\treturn &Error{ErrUnexpectedParen, p.wholeRegexp}\n \t}\n \tre1 := p.stack[n-1]\n \tre2 := p.stack[n-2]\n \tp.stack = p.stack[:n-2]\n \tif re2.Op != opLeftParen {\n-\t\treturn &Error{errUnexpectedParen, p.wholeRegexp}\n+\t\treturn &Error{ErrUnexpectedParen, p.wholeRegexp}\n \t}\n \t// Restore flags at time of paren.\n \tp.flags = re2.Flags"}, {"sha": "1a9c41b85a89d3bb56861bc9a096c17679a7679d", "filename": "libgo/go/strconv/ftoa.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fstrconv%2Fftoa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fstrconv%2Fftoa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fftoa.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -255,7 +255,7 @@ func roundShortest(d *decimal, mant uint64, exp int, flt *floatInfo) {\n \n \t// d = mant << (exp - mantbits)\n \t// Next highest floating point number is mant+1 << exp-mantbits.\n-\t// Our upper bound is halfway inbetween, mant*2+1 << exp-mantbits-1.\n+\t// Our upper bound is halfway between, mant*2+1 << exp-mantbits-1.\n \tupper := new(decimal)\n \tupper.Assign(mant*2 + 1)\n \tupper.Shift(exp - int(flt.mantbits) - 1)\n@@ -265,7 +265,7 @@ func roundShortest(d *decimal, mant uint64, exp int, flt *floatInfo) {\n \t// unless mant-1 drops the significant bit and exp is not the minimum exp,\n \t// in which case the next lowest is mant*2-1 << exp-mantbits-1.\n \t// Either way, call it mantlo << explo-mantbits.\n-\t// Our lower bound is halfway inbetween, mantlo*2+1 << explo-mantbits-1.\n+\t// Our lower bound is halfway between, mantlo*2+1 << explo-mantbits-1.\n \tvar mantlo uint64\n \tvar explo int\n \tif mant > 1<<flt.mantbits || exp == minexp {"}, {"sha": "0f89aa9ee3847d3c8b6997a4609b4d3cc3cc2a22", "filename": "libgo/go/syscall/env_plan9.go", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fsyscall%2Fenv_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fsyscall%2Fenv_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fenv_plan9.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -12,14 +12,17 @@ import (\n )\n \n var (\n-\t// envOnce guards initialization by copyenv, which populates env.\n+\t// envOnce guards copyenv, which populates env.\n \tenvOnce sync.Once\n \n \t// envLock guards env.\n \tenvLock sync.RWMutex\n \n \t// env maps from an environment variable to its value.\n-\tenv map[string]string\n+\tenv = make(map[string]string)\n+\n+\terrZeroLengthKey = errors.New(\"zero length key\")\n+\terrShortWrite    = errors.New(\"i/o count too small\")\n )\n \n func readenv(key string) (string, error) {\n@@ -47,12 +50,18 @@ func writeenv(key, value string) error {\n \t\treturn err\n \t}\n \tdefer Close(fd)\n-\t_, err = Write(fd, []byte(value))\n-\treturn err\n+\tb := []byte(value)\n+\tn, err := Write(fd, b)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif n != len(b) {\n+\t\treturn errShortWrite\n+\t}\n+\treturn nil\n }\n \n func copyenv() {\n-\tenv = make(map[string]string)\n \tfd, err := Open(\"/env\", O_RDONLY)\n \tif err != nil {\n \t\treturn\n@@ -72,25 +81,27 @@ func copyenv() {\n }\n \n func Getenv(key string) (value string, found bool) {\n-\tenvOnce.Do(copyenv)\n \tif len(key) == 0 {\n \t\treturn \"\", false\n \t}\n \n \tenvLock.RLock()\n \tdefer envLock.RUnlock()\n \n-\tv, ok := env[key]\n-\tif !ok {\n+\tif v, ok := env[key]; ok {\n+\t\treturn v, true\n+\t}\n+\tv, err := readenv(key)\n+\tif err != nil {\n \t\treturn \"\", false\n \t}\n+\tenv[key] = v\n \treturn v, true\n }\n \n func Setenv(key, value string) error {\n-\tenvOnce.Do(copyenv)\n \tif len(key) == 0 {\n-\t\treturn errors.New(\"zero length key\")\n+\t\treturn errZeroLengthKey\n \t}\n \n \tenvLock.Lock()\n@@ -105,8 +116,6 @@ func Setenv(key, value string) error {\n }\n \n func Clearenv() {\n-\tenvOnce.Do(copyenv) // prevent copyenv in Getenv/Setenv\n-\n \tenvLock.Lock()\n \tdefer envLock.Unlock()\n \n@@ -115,9 +124,10 @@ func Clearenv() {\n }\n \n func Environ() []string {\n-\tenvOnce.Do(copyenv)\n \tenvLock.RLock()\n \tdefer envLock.RUnlock()\n+\n+\tenvOnce.Do(copyenv)\n \ta := make([]string, len(env))\n \ti := 0\n \tfor k, v := range env {"}, {"sha": "043ab0d7135d8e0ce1bde2da3615ad214388c6f1", "filename": "libgo/go/syscall/libcall_linux_utimesnano.go", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fsyscall%2Flibcall_linux_utimesnano.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fsyscall%2Flibcall_linux_utimesnano.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_linux_utimesnano.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// GNU/Linux version of UtimesNano.\n+\n+package syscall\n+\n+import \"unsafe\"\n+\n+//sys\tutimensat(dirfd int, path string, times *[2]Timespec, flags int) (err error)\n+//utimensat(dirfd int, path *byte, times *[2]Timespec, flags int) int\n+func UtimesNano(path string, ts []Timespec) (err error) {\n+\tif len(ts) != 2 {\n+\t\treturn EINVAL\n+\t}\n+\terr = utimensat(_AT_FDCWD, path, (*[2]Timespec)(unsafe.Pointer(&ts[0])), 0)\n+\tif err != ENOSYS {\n+\t\treturn err\n+\t}\n+\t// If the utimensat syscall isn't available (utimensat was added to Linux\n+\t// in 2.6.22, Released, 8 July 2007) then fall back to utimes\n+\tvar tv [2]Timeval\n+\tfor i := 0; i < 2; i++ {\n+\t\ttv[i].Sec = Timeval_sec_t(ts[i].Sec)\n+\t\ttv[i].Usec = Timeval_usec_t(ts[i].Nsec / 1000)\n+\t}\n+\treturn utimes(path, (*[2]Timeval)(unsafe.Pointer(&tv[0])))\n+}"}, {"sha": "e0751f5467d46abe9b7f61386975472fce3618f5", "filename": "libgo/go/syscall/libcall_posix_utimesnano.go", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fsyscall%2Flibcall_posix_utimesnano.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fsyscall%2Flibcall_posix_utimesnano.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_posix_utimesnano.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// General POSIX version of UtimesNano.\n+\n+package syscall\n+\n+import \"unsafe\"\n+\n+func UtimesNano(path string, ts []Timespec) error {\n+\t// TODO: The BSDs can do utimensat with SYS_UTIMENSAT but it\n+\t// isn't supported by darwin so this uses utimes instead\n+\tif len(ts) != 2 {\n+\t\treturn EINVAL\n+\t}\n+\t// Not as efficient as it could be because Timespec and\n+\t// Timeval have different types in the different OSes\n+\ttv := [2]Timeval{\n+\t\tNsecToTimeval(TimespecToNsec(ts[0])),\n+\t\tNsecToTimeval(TimespecToNsec(ts[1])),\n+\t}\n+\treturn utimes(path, (*[2]Timeval)(unsafe.Pointer(&tv[0])))\n+}"}, {"sha": "c4f2125140efc00fd78ec18ace122b509eac7dfe", "filename": "libgo/go/syscall/syscall.go", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fsyscall%2Fsyscall.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Fsyscall%2Fsyscall.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -3,10 +3,15 @@\n // license that can be found in the LICENSE file.\n \n // Package syscall contains an interface to the low-level operating system\n-// primitives.  The details vary depending on the underlying system.\n-// Its primary use is inside other packages that provide a more portable\n-// interface to the system, such as \"os\", \"time\" and \"net\".  Use those\n-// packages rather than this one if you can.\n+// primitives.  The details vary depending on the underlying system, and\n+// by default, godoc will display the syscall documentation for the current\n+// system.  If you want godoc to display syscall documentation for another\n+// system, set $GOOS and $GOARCH to the desired system.  For example, if\n+// you want to view documentation for freebsd/arm on linux/amd64, set $GOOS\n+// to freebsd and $GOARCH to arm.\n+// The primary use of syscall is inside other packages that provide a more\n+// portable interface to the system, such as \"os\", \"time\" and \"net\".  Use\n+// those packages rather than this one if you can.\n // For details of the functions and data types in this package consult\n // the manuals for the appropriate operating system.\n // These calls return err == nil to indicate success; otherwise"}, {"sha": "dc97255965e06da0a229603ae26b35aec2ee1edd", "filename": "libgo/go/testing/example.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Ftesting%2Fexample.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Ftesting%2Fexample.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fexample.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -24,7 +24,7 @@ func RunExamples(matchString func(pat, str string) (bool, error), examples []Int\n \n \tvar eg InternalExample\n \n-\tstdout, stderr := os.Stdout, os.Stderr\n+\tstdout := os.Stdout\n \n \tfor _, eg = range examples {\n \t\tmatched, err := matchString(*match, eg.Name)\n@@ -39,19 +39,19 @@ func RunExamples(matchString func(pat, str string) (bool, error), examples []Int\n \t\t\tfmt.Printf(\"=== RUN: %s\\n\", eg.Name)\n \t\t}\n \n-\t\t// capture stdout and stderr\n+\t\t// capture stdout\n \t\tr, w, err := os.Pipe()\n \t\tif err != nil {\n \t\t\tfmt.Fprintln(os.Stderr, err)\n \t\t\tos.Exit(1)\n \t\t}\n-\t\tos.Stdout, os.Stderr = w, w\n+\t\tos.Stdout = w\n \t\toutC := make(chan string)\n \t\tgo func() {\n \t\t\tbuf := new(bytes.Buffer)\n \t\t\t_, err := io.Copy(buf, r)\n \t\t\tif err != nil {\n-\t\t\t\tfmt.Fprintf(stderr, \"testing: copying pipe: %v\\n\", err)\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"testing: copying pipe: %v\\n\", err)\n \t\t\t\tos.Exit(1)\n \t\t\t}\n \t\t\toutC <- buf.String()\n@@ -62,9 +62,9 @@ func RunExamples(matchString func(pat, str string) (bool, error), examples []Int\n \t\teg.F()\n \t\tdt := time.Now().Sub(t0)\n \n-\t\t// close pipe, restore stdout/stderr, get output\n+\t\t// close pipe, restore stdout, get output\n \t\tw.Close()\n-\t\tos.Stdout, os.Stderr = stdout, stderr\n+\t\tos.Stdout = stdout\n \t\tout := <-outC\n \n \t\t// report any errors"}, {"sha": "417e8f8d7a80a7f5ead3158fe9c8f2035d1d98bb", "filename": "libgo/go/time/format.go", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Ftime%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Ftime%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fformat.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -854,9 +854,15 @@ func Parse(layout, value string) (Time, error) {\n \t\t\tzoneName = p\n \n \t\tcase stdFracSecond0:\n-\t\t\tndigit := std >> stdArgShift\n-\t\t\tnsec, rangeErrString, err = parseNanoseconds(value, 1+ndigit)\n-\t\t\tvalue = value[1+ndigit:]\n+\t\t\t// stdFracSecond0 requires the exact number of digits as specified in\n+\t\t\t// the layout.\n+\t\t\tndigit := 1 + (std >> stdArgShift)\n+\t\t\tif len(value) < ndigit {\n+\t\t\t\terr = errBad\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tnsec, rangeErrString, err = parseNanoseconds(value, ndigit)\n+\t\t\tvalue = value[ndigit:]\n \n \t\tcase stdFracSecond9:\n \t\t\tif len(value) < 2 || value[0] != '.' || value[1] < '0' || '9' < value[1] {\n@@ -934,8 +940,7 @@ func parseNanoseconds(value string, nbytes int) (ns int, rangeErrString string,\n \t\terr = errBad\n \t\treturn\n \t}\n-\tns, err = atoi(value[1:nbytes])\n-\tif err != nil {\n+\tif ns, err = atoi(value[1:nbytes]); err != nil {\n \t\treturn\n \t}\n \tif ns < 0 || 1e9 <= ns {"}, {"sha": "0224fed4bdfcb88355051fc9e10551ba8536701b", "filename": "libgo/go/time/time_test.go", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Ftime%2Ftime_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Ftime%2Ftime_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime_test.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -469,7 +469,7 @@ type ParseTest struct {\n \tvalue      string\n \thasTZ      bool // contains a time zone\n \thasWD      bool // contains a weekday\n-\tyearSign   int  // sign of year\n+\tyearSign   int  // sign of year, -1 indicates the year is not present in the format\n \tfracDigits int  // number of digits of fractional second\n }\n \n@@ -514,6 +514,13 @@ var parseTests = []ParseTest{\n \t{\"\", \"2006-01-02 15:04:05.999999999 -0700 MST\", \"2010-02-04 21:00:57.0123 -0800 PST\", true, false, 1, 4},\n \t{\"\", \"2006-01-02 15:04:05.9999 -0700 MST\", \"2010-02-04 21:00:57.012345678 -0800 PST\", true, false, 1, 9},\n \t{\"\", \"2006-01-02 15:04:05.999999999 -0700 MST\", \"2010-02-04 21:00:57.012345678 -0800 PST\", true, false, 1, 9},\n+\n+\t// issue 4502.\n+\t{\"\", StampNano, \"Feb  4 21:00:57.012345678\", false, false, -1, 9},\n+\t{\"\", \"Jan _2 15:04:05.999\", \"Feb  4 21:00:57.012300000\", false, false, -1, 4},\n+\t{\"\", \"Jan _2 15:04:05.999\", \"Feb  4 21:00:57.012345678\", false, false, -1, 9},\n+\t{\"\", \"Jan _2 15:04:05.999999999\", \"Feb  4 21:00:57.0123\", false, false, -1, 4},\n+\t{\"\", \"Jan _2 15:04:05.999999999\", \"Feb  4 21:00:57.012345678\", false, false, -1, 9},\n }\n \n func TestParse(t *testing.T) {\n@@ -549,7 +556,7 @@ func TestRubyParse(t *testing.T) {\n \n func checkTime(time Time, test *ParseTest, t *testing.T) {\n \t// The time should be Thu Feb  4 21:00:57 PST 2010\n-\tif test.yearSign*time.Year() != 2010 {\n+\tif test.yearSign >= 0 && test.yearSign*time.Year() != 2010 {\n \t\tt.Errorf(\"%s: bad year: %d not %d\", test.name, time.Year(), 2010)\n \t}\n \tif time.Month() != February {\n@@ -630,6 +637,9 @@ var parseErrorTests = []ParseErrorTest{\n \t{\"Mon Jan _2 15:04:05.000 2006\", \"Thu Feb  4 23:00:59x01 2010\", \"cannot parse\"},\n \t{\"Mon Jan _2 15:04:05.000 2006\", \"Thu Feb  4 23:00:59.xxx 2010\", \"cannot parse\"},\n \t{\"Mon Jan _2 15:04:05.000 2006\", \"Thu Feb  4 23:00:59.-123 2010\", \"fractional second out of range\"},\n+\t// issue 4502. StampNano requires exactly 9 digits of precision.\n+\t{StampNano, \"Dec  7 11:22:01.000000\", `cannot parse \".000000\" as \".000000000\"`},\n+\t{StampNano, \"Dec  7 11:22:01.0000000000\", \"extra text: 0\"},\n }\n \n func TestParseErrors(t *testing.T) {"}, {"sha": "a5a2de218ef1a909b8441e060071db5b07e7117c", "filename": "libgo/go/time/zoneinfo_read.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Ftime%2Fzoneinfo_read.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fgo%2Ftime%2Fzoneinfo_read.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fzoneinfo_read.go?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -174,7 +174,7 @@ func loadZoneData(bytes []byte) (l *Location, err error) {\n \t\t}\n \t}\n \n-\t// Commited to succeed.\n+\t// Committed to succeed.\n \tl = &Location{zone: zone, tx: tx}\n \n \t// Fill in the cache with information about right now,"}, {"sha": "ca358ac12a766b783a316dca8b442c45ed8d7905", "filename": "libgo/merge.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fmerge.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fmerge.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmerge.sh?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -163,7 +163,7 @@ done\n   done\n done\n \n-runtime=\"chan.c cpuprof.c lock_futex.c lock_sema.c mcache.c mcentral.c mfinal.c mfixalloc.c mgc0.c mheap.c msize.c panic.c print.c proc.c race.h runtime.c runtime.h signal_unix.c malloc.h malloc.goc mprof.goc parfor.c runtime1.goc sema.goc sigqueue.goc string.goc time.goc\"\n+runtime=\"chan.c cpuprof.c env_posix.c lock_futex.c lock_sema.c mcache.c mcentral.c mfinal.c mfixalloc.c mgc0.c mgc0.h mheap.c msize.c panic.c print.c proc.c race.h runtime.c runtime.h signal_unix.c malloc.h malloc.goc mprof.goc parfor.c runtime1.goc sema.goc sigqueue.goc string.goc time.goc\"\n for f in $runtime; do\n   merge_c $f $f\n done"}, {"sha": "31f417935304ae46c26e0dbea6c93468306d7992", "filename": "libgo/runtime/env_posix.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Fenv_posix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Fenv_posix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fenv_posix.c?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin freebsd linux netbsd openbsd windows\n+\n+#include \"runtime.h\"\n+#include \"array.h\"\n+\n+extern Slice syscall_Envs asm (\"syscall.Envs\");\n+\n+const byte*\n+runtime_getenv(const char *s)\n+{\n+\tint32 i, j, len;\n+\tconst byte *v, *bs;\n+\tString* envv;\n+\tint32 envc;\n+\n+\tbs = (const byte*)s;\n+\tlen = runtime_findnull(bs);\n+\tenvv = (String*)syscall_Envs.__values;\n+\tenvc = syscall_Envs.__count;\n+\tfor(i=0; i<envc; i++){\n+\t\tif(envv[i].len <= len)\n+\t\t\tcontinue;\n+\t\tv = (const byte*)envv[i].str;\n+\t\tfor(j=0; j<len; j++)\n+\t\t\tif(bs[j] != v[j])\n+\t\t\t\tgoto nomatch;\n+\t\tif(v[len] != '=')\n+\t\t\tgoto nomatch;\n+\t\treturn v+len+1;\n+\tnomatch:;\n+\t}\n+\treturn nil;\n+}"}, {"sha": "17f73d4f569ff1f1c73b8195f445c41df24e8aa8", "filename": "libgo/runtime/go-trampoline.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Fgo-trampoline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Fgo-trampoline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-trampoline.c?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -106,8 +106,8 @@ __go_allocate_trampoline (uintptr_t size, void *closure)\n    no other references to it.  */\n \n void\n-runtime_trampoline_scan (void (*addroot) (byte *, uintptr))\n+runtime_trampoline_scan (void (*addroot) (Obj))\n {\n   if (trampoline_page != NULL)\n-    addroot ((byte *) &trampoline_page, sizeof trampoline_page);\n+    addroot ((Obj){(byte *) &trampoline_page, sizeof trampoline_page, 0});\n }"}, {"sha": "2a614e5a186d03ce6b4ea9ab8f06ff5f8f8b39f6", "filename": "libgo/runtime/malloc.goc", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Fmalloc.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Fmalloc.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.goc?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -491,7 +491,7 @@ runtime_MHeap_SysAlloc(MHeap *h, uintptr n)\n static Lock settype_lock;\n \n void\n-runtime_settype_flush(M *m, bool sysalloc)\n+runtime_settype_flush(M *mp, bool sysalloc)\n {\n \tuintptr *buf, *endbuf;\n \tuintptr size, ofs, j, t;\n@@ -503,8 +503,8 @@ runtime_settype_flush(M *m, bool sysalloc)\n \tuintptr typ, p;\n \tMSpan *s;\n \n-\tbuf = m->settype_buf;\n-\tendbuf = buf + m->settype_bufsize;\n+\tbuf = mp->settype_buf;\n+\tendbuf = buf + mp->settype_bufsize;\n \n \truntime_lock(&settype_lock);\n \twhile(buf < endbuf) {\n@@ -602,32 +602,32 @@ runtime_settype_flush(M *m, bool sysalloc)\n \t}\n \truntime_unlock(&settype_lock);\n \n-\tm->settype_bufsize = 0;\n+\tmp->settype_bufsize = 0;\n }\n \n // It is forbidden to use this function if it is possible that\n // explicit deallocation via calling runtime_free(v) may happen.\n void\n runtime_settype(void *v, uintptr t)\n {\n-\tM *m1;\n+\tM *mp;\n \tuintptr *buf;\n \tuintptr i;\n \tMSpan *s;\n \n \tif(t == 0)\n \t\truntime_throw(\"settype: zero type\");\n \n-\tm1 = runtime_m();\n-\tbuf = m1->settype_buf;\n-\ti = m1->settype_bufsize;\n+\tmp = runtime_m();\n+\tbuf = mp->settype_buf;\n+\ti = mp->settype_bufsize;\n \tbuf[i+0] = (uintptr)v;\n \tbuf[i+1] = t;\n \ti += 2;\n-\tm1->settype_bufsize = i;\n+\tmp->settype_bufsize = i;\n \n-\tif(i == nelem(m1->settype_buf)) {\n-\t\truntime_settype_flush(m1, false);\n+\tif(i == nelem(mp->settype_buf)) {\n+\t\truntime_settype_flush(mp, false);\n \t}\n \n \tif(DebugTypeAtBlockEnd) {"}, {"sha": "710484edecf33042fca131108d07ff1b9ee71d47", "filename": "libgo/runtime/malloc.h", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Fmalloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Fmalloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.h?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -468,17 +468,25 @@ enum\n \tFlagNoGC = 1<<2,\t// must not free or scan for pointers\n };\n \n+typedef struct Obj Obj;\n+struct Obj\n+{\n+\tbyte\t*p;\t// data pointer\n+\tuintptr\tn;\t// size of data in bytes\n+\tuintptr\tti;\t// type info\n+};\n+\n void\truntime_MProf_Malloc(void*, uintptr);\n void\truntime_MProf_Free(void*, uintptr);\n void\truntime_MProf_GC(void);\n-void\truntime_MProf_Mark(void (*addroot)(byte *, uintptr));\n+void\truntime_MProf_Mark(void (*addroot)(Obj));\n int32\truntime_gcprocs(void);\n void\truntime_helpgc(int32 nproc);\n void\truntime_gchelper(void);\n \n struct __go_func_type;\n bool\truntime_getfinalizer(void *p, bool del, void (**fn)(void*), const struct __go_func_type **ft);\n-void\truntime_walkfintab(void (*fn)(void*), void (*scan)(byte *, uintptr));\n+void\truntime_walkfintab(void (*fn)(void*), void (*scan)(Obj));\n \n enum\n {\n@@ -494,3 +502,6 @@ enum\n void\truntime_gc_m_ptr(Eface*);\n \n void\truntime_memorydump(void);\n+\n+void\truntime_time_scan(void (*)(Obj));\n+void\truntime_trampoline_scan(void (*)(Obj));"}, {"sha": "7c906daf3476fab45c19c05dee4fd224f1aac16c", "filename": "libgo/runtime/mfinal.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Fmfinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Fmfinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmfinal.c?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -193,7 +193,7 @@ runtime_getfinalizer(void *p, bool del, void (**fn)(void*), const struct __go_fu\n }\n \n void\n-runtime_walkfintab(void (*fn)(void*), void (*addroot)(byte *, uintptr))\n+runtime_walkfintab(void (*fn)(void*), void (*addroot)(Obj))\n {\n \tvoid **key;\n \tvoid **ekey;\n@@ -206,8 +206,8 @@ runtime_walkfintab(void (*fn)(void*), void (*addroot)(byte *, uintptr))\n \t\tfor(; key < ekey; key++)\n \t\t\tif(*key != nil && *key != ((void*)-1))\n \t\t\t\tfn(*key);\n-\t\taddroot((byte*)&fintab[i].fkey, sizeof(void*));\n-\t\taddroot((byte*)&fintab[i].val, sizeof(void*));\n+\t\taddroot((Obj){(byte*)&fintab[i].fkey, sizeof(void*), 0});\n+\t\taddroot((Obj){(byte*)&fintab[i].val, sizeof(void*), 0});\n \t\truntime_unlock(&fintab[i]);\n \t}\n }"}, {"sha": "698400b0c50eb79849e715e5082324f572c75747", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 392, "deletions": 158, "changes": 550, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -9,6 +9,7 @@\n #include \"runtime.h\"\n #include \"arch.h\"\n #include \"malloc.h\"\n+#include \"mgc0.h\"\n #include \"race.h\"\n \n #ifdef USING_SPLIT_STACK\n@@ -24,11 +25,13 @@ extern void * __splitstack_find_context (void *context[10], size_t *, void **,\n enum {\n \tDebug = 0,\n \tDebugMark = 0,  // run second pass to check mark\n-\tDataBlock = 8*1024,\n \n \t// Four bits per word (see #defines below).\n \twordsPerBitmapWord = sizeof(void*)*8/4,\n \tbitShift = sizeof(void*)*8/4,\n+\n+\thandoffThreshold = 4,\n+\tIntermediateBufferCapacity = 64,\n };\n \n // Bits in per-word bitmap.\n@@ -81,12 +84,16 @@ uint32 runtime_worldsema = 1;\n \n static int32 gctrace;\n \n+// The size of Workbuf is N*PageSize.\n typedef struct Workbuf Workbuf;\n struct Workbuf\n {\n-\tLFNode node; // must be first\n+#define SIZE (2*PageSize-sizeof(LFNode)-sizeof(uintptr))\n+\tLFNode  node; // must be first\n \tuintptr nobj;\n-\tbyte *obj[512-(sizeof(LFNode)+sizeof(uintptr))/sizeof(byte*)];\n+\tObj     obj[SIZE/sizeof(Obj) - 1];\n+\tuint8   _padding[SIZE%sizeof(Obj) + sizeof(Obj)];\n+#undef SIZE\n };\n \n typedef struct Finalizer Finalizer;\n@@ -120,13 +127,6 @@ static Workbuf* getfull(Workbuf*);\n static void\tputempty(Workbuf*);\n static Workbuf* handoff(Workbuf*);\n \n-typedef struct GcRoot GcRoot;\n-struct GcRoot\n-{\n-\tbyte *p;\n-\tuintptr n;\n-};\n-\n static struct {\n \tuint64\tfull;  // lock-free list of full blocks\n \tuint64\tempty; // lock-free list of empty blocks\n@@ -143,77 +143,122 @@ static struct {\n \tbyte\t*chunk;\n \tuintptr\tnchunk;\n \n-\tGcRoot\t*roots;\n+\tObj\t*roots;\n \tuint32\tnroot;\n \tuint32\trootcap;\n } work;\n \n-// scanblock scans a block of n bytes starting at pointer b for references\n-// to other objects, scanning any it finds recursively until there are no\n-// unscanned objects left.  Instead of using an explicit recursion, it keeps\n-// a work list in the Workbuf* structures and loops in the main function\n-// body.  Keeping an explicit work list is easier on the stack allocator and\n-// more efficient.\n+enum {\n+\t// TODO(atom): to be expanded in a next CL\n+\tGC_DEFAULT_PTR = GC_NUM_INSTR,\n+};\n+\n+// PtrTarget and BitTarget are structures used by intermediate buffers.\n+// The intermediate buffers hold GC data before it\n+// is moved/flushed to the work buffer (Workbuf).\n+// The size of an intermediate buffer is very small,\n+// such as 32 or 64 elements.\n+struct PtrTarget\n+{\n+\tvoid *p;\n+\tuintptr ti;\n+};\n+\n+struct BitTarget\n+{\n+\tvoid *p;\n+\tuintptr ti;\n+\tuintptr *bitp, shift;\n+};\n+\n+struct BufferList\n+{\n+\tstruct PtrTarget ptrtarget[IntermediateBufferCapacity];\n+\tstruct BitTarget bittarget[IntermediateBufferCapacity];\n+\tstruct BufferList *next;\n+};\n+static struct BufferList *bufferList;\n+\n+static Lock lock;\n+\n+// flushptrbuf moves data from the PtrTarget buffer to the work buffer.\n+// The PtrTarget buffer contains blocks irrespective of whether the blocks have been marked or scanned,\n+// while the work buffer contains blocks which have been marked\n+// and are prepared to be scanned by the garbage collector.\n+//\n+// _wp, _wbuf, _nobj are input/output parameters and are specifying the work buffer.\n+// bitbuf holds temporary data generated by this function.\n+//\n+// A simplified drawing explaining how the todo-list moves from a structure to another:\n+//\n+//     scanblock\n+//  (find pointers)\n+//    Obj ------> PtrTarget (pointer targets)\n+//     \u2191          |\n+//     |          | flushptrbuf (1st part,\n+//     |          | find block start)\n+//     |          \u2193\n+//     `--------- BitTarget (pointer targets and the corresponding locations in bitmap)\n+//  flushptrbuf\n+//  (2nd part, mark and enqueue)\n static void\n-scanblock(byte *b, uintptr n)\n+flushptrbuf(struct PtrTarget *ptrbuf, uintptr n, Obj **_wp, Workbuf **_wbuf, uintptr *_nobj, struct BitTarget *bitbuf)\n {\n-\tbyte *obj, *arena_start, *arena_used, *p;\n-\tvoid **vp;\n-\tuintptr size, *bitp, bits, shift, i, j, x, xbits, off, nobj, nproc;\n+\tbyte *p, *arena_start, *obj;\n+\tuintptr size, *bitp, bits, shift, j, x, xbits, off, nobj, ti;\n \tMSpan *s;\n \tPageID k;\n-\tvoid **wp;\n+\tObj *wp;\n \tWorkbuf *wbuf;\n-\tbool keepworking;\n-\n-\tif((intptr)n < 0) {\n-\t\truntime_printf(\"scanblock %p %D\\n\", b, (int64)n);\n-\t\truntime_throw(\"scanblock\");\n-\t}\n+\tstruct PtrTarget *ptrbuf_end;\n+\tstruct BitTarget *bitbufpos, *bt;\n \n-\t// Memory arena parameters.\n \tarena_start = runtime_mheap.arena_start;\n-\tarena_used = runtime_mheap.arena_used;\n-\tnproc = work.nproc;\n \n-\twbuf = nil;  // current work buffer\n-\twp = nil;  // storage for next queued pointer (write pointer)\n-\tnobj = 0;  // number of queued objects\n+\twp = *_wp;\n+\twbuf = *_wbuf;\n+\tnobj = *_nobj;\n \n-\t// Scanblock helpers pass b==nil.\n-\t// Procs needs to return to make more\n-\t// calls to scanblock.  But if work.nproc==1 then\n-\t// might as well process blocks as soon as we\n-\t// have them.\n-\tkeepworking = b == nil || work.nproc == 1;\n+\tptrbuf_end = ptrbuf + n;\n \n-\t// Align b to a word boundary.\n-\toff = (uintptr)b & (PtrSize-1);\n-\tif(off != 0) {\n-\t\tb += PtrSize - off;\n-\t\tn -= PtrSize - off;\n+\t// If buffer is nearly full, get a new one.\n+\tif(wbuf == nil || nobj+n >= nelem(wbuf->obj)) {\n+\t\tif(wbuf != nil)\n+\t\t\twbuf->nobj = nobj;\n+\t\twbuf = getempty(wbuf);\n+\t\twp = wbuf->obj;\n+\t\tnobj = 0;\n+\n+\t\tif(n >= nelem(wbuf->obj))\n+\t\t\truntime_throw(\"ptrbuf has to be smaller than WorkBuf\");\n \t}\n \n-\tfor(;;) {\n-\t\t// Each iteration scans the block b of length n, queueing pointers in\n-\t\t// the work buffer.\n-\t\tif(Debug > 1)\n-\t\t\truntime_printf(\"scanblock %p %D\\n\", b, (int64)n);\n+\t// TODO(atom): This block is a branch of an if-then-else statement.\n+\t//             The single-threaded branch may be added in a next CL.\n+\t{\n+\t\t// Multi-threaded version.\n \n-\t\tvp = (void**)b;\n-\t\tn >>= (2+PtrSize/8);  /* n /= PtrSize (4 or 8) */\n-\t\tfor(i=0; i<(uintptr)n; i++) {\n-\t\t\tobj = (byte*)vp[i];\n+\t\tbitbufpos = bitbuf;\n \n-\t\t\t// Words outside the arena cannot be pointers.\n-\t\t\tif((byte*)obj < arena_start || (byte*)obj >= arena_used)\n-\t\t\t\tcontinue;\n+\t\twhile(ptrbuf < ptrbuf_end) {\n+\t\t\tobj = ptrbuf->p;\n+\t\t\tti = ptrbuf->ti;\n+\t\t\tptrbuf++;\n+\n+\t\t\t// obj belongs to interval [mheap.arena_start, mheap.arena_used).\n+\t\t\tif(Debug > 1) {\n+\t\t\t\tif(obj < runtime_mheap.arena_start || obj >= runtime_mheap.arena_used)\n+\t\t\t\t\truntime_throw(\"object is outside of mheap\");\n+\t\t\t}\n \n \t\t\t// obj may be a pointer to a live object.\n \t\t\t// Try to find the beginning of the object.\n \n \t\t\t// Round down to word boundary.\n-\t\t\tobj = (void*)((uintptr)obj & ~((uintptr)PtrSize-1));\n+\t\t\tif(((uintptr)obj & ((uintptr)PtrSize-1)) != 0) {\n+\t\t\t\tobj = (void*)((uintptr)obj & ~((uintptr)PtrSize-1));\n+\t\t\t\tti = 0;\n+\t\t\t}\n \n \t\t\t// Find bits for this word.\n \t\t\toff = (uintptr*)obj - (uintptr*)arena_start;\n@@ -226,6 +271,8 @@ scanblock(byte *b, uintptr n)\n \t\t\tif((bits & (bitAllocated|bitBlockBoundary)) != 0)\n \t\t\t\tgoto found;\n \n+\t\t\tti = 0;\n+\n \t\t\t// Pointing just past the beginning?\n \t\t\t// Scan backward a little to find a block boundary.\n \t\t\tfor(j=shift; j-->0; ) {\n@@ -246,13 +293,13 @@ scanblock(byte *b, uintptr n)\n \t\t\ts = runtime_mheap.map[x];\n \t\t\tif(s == nil || k < s->start || k - s->start >= s->npages || s->state != MSpanInUse)\n \t\t\t\tcontinue;\n-\t\t\tp =  (byte*)((uintptr)s->start<<PageShift);\n+\t\t\tp = (byte*)((uintptr)s->start<<PageShift);\n \t\t\tif(s->sizeclass == 0) {\n \t\t\t\tobj = p;\n \t\t\t} else {\n \t\t\t\tif((byte*)obj >= (byte*)s->limit)\n \t\t\t\t\tcontinue;\n-\t\t\t\tsize = runtime_class_to_size[s->sizeclass];\n+\t\t\t\tsize = s->elemsize;\n \t\t\t\tint32 i = ((byte*)obj - p)/size;\n \t\t\t\tobj = p+i*size;\n \t\t\t}\n@@ -265,81 +312,203 @@ scanblock(byte *b, uintptr n)\n \t\t\tbits = xbits >> shift;\n \n \t\tfound:\n-\t\t\t// If another proc wants a pointer, give it some.\n-\t\t\tif(work.nwait > 0 && nobj > 4 && work.full == 0) {\n-\t\t\t\twbuf->nobj = nobj;\n-\t\t\t\twbuf = handoff(wbuf);\n-\t\t\t\tnobj = wbuf->nobj;\n-\t\t\t\twp = (void**)(wbuf->obj + nobj);\n-\t\t\t}\n-\n \t\t\t// Now we have bits, bitp, and shift correct for\n \t\t\t// obj pointing at the base of the object.\n \t\t\t// Only care about allocated and not marked.\n \t\t\tif((bits & (bitAllocated|bitMarked)) != bitAllocated)\n \t\t\t\tcontinue;\n-\t\t\tif(nproc == 1)\n-\t\t\t\t*bitp |= bitMarked<<shift;\n-\t\t\telse {\n-\t\t\t\tfor(;;) {\n-\t\t\t\t\tx = *bitp;\n-\t\t\t\t\tif(x & (bitMarked<<shift))\n-\t\t\t\t\t\tgoto continue_obj;\n-\t\t\t\t\tif(runtime_casp((void**)bitp, (void*)x, (void*)(x|(bitMarked<<shift))))\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n+\n+\t\t\t*bitbufpos = (struct BitTarget){obj, ti, bitp, shift};\n+\t\t\tbitbufpos++;\n+\t\t}\n+\n+\t\truntime_lock(&lock);\n+\t\tfor(bt=bitbuf; bt<bitbufpos; bt++){\n+\t\t\txbits = *bt->bitp;\n+\t\t\tbits = xbits >> bt->shift;\n+\t\t\tif((bits & bitMarked) != 0)\n+\t\t\t\tcontinue;\n+\n+\t\t\t// Mark the block\n+\t\t\t*bt->bitp = xbits | (bitMarked << bt->shift);\n \n \t\t\t// If object has no pointers, don't need to scan further.\n \t\t\tif((bits & bitNoPointers) != 0)\n \t\t\t\tcontinue;\n \n+\t\t\tobj = bt->p;\n+\n+\t\t\t// Ask span about size class.\n+\t\t\t// (Manually inlined copy of MHeap_Lookup.)\n+\t\t\tx = (uintptr)obj >> PageShift;\n+\t\t\tif(sizeof(void*) == 8)\n+\t\t\t\tx -= (uintptr)arena_start>>PageShift;\n+\t\t\ts = runtime_mheap.map[x];\n+\n \t\t\tPREFETCH(obj);\n \n-\t\t\t// If buffer is full, get a new one.\n-\t\t\tif(wbuf == nil || nobj >= nelem(wbuf->obj)) {\n-\t\t\t\tif(wbuf != nil)\n-\t\t\t\t\twbuf->nobj = nobj;\n-\t\t\t\twbuf = getempty(wbuf);\n-\t\t\t\twp = (void**)(wbuf->obj);\n-\t\t\t\tnobj = 0;\n-\t\t\t}\n-\t\t\t*wp++ = obj;\n+\t\t\t*wp = (Obj){obj, s->elemsize, bt->ti};\n+\t\t\twp++;\n \t\t\tnobj++;\n-\t\tcontinue_obj:;\n \t\t}\n+\t\truntime_unlock(&lock);\n+\n+\t\t// If another proc wants a pointer, give it some.\n+\t\tif(work.nwait > 0 && nobj > handoffThreshold && work.full == 0) {\n+\t\t\twbuf->nobj = nobj;\n+\t\t\twbuf = handoff(wbuf);\n+\t\t\tnobj = wbuf->nobj;\n+\t\t\twp = wbuf->obj + nobj;\n+\t\t}\n+\t}\n+\n+\t*_wp = wp;\n+\t*_wbuf = wbuf;\n+\t*_nobj = nobj;\n+}\n+\n+// Program that scans the whole block and treats every block element as a potential pointer\n+static uintptr defaultProg[2] = {PtrSize, GC_DEFAULT_PTR};\n+\n+// scanblock scans a block of n bytes starting at pointer b for references\n+// to other objects, scanning any it finds recursively until there are no\n+// unscanned objects left.  Instead of using an explicit recursion, it keeps\n+// a work list in the Workbuf* structures and loops in the main function\n+// body.  Keeping an explicit work list is easier on the stack allocator and\n+// more efficient.\n+//\n+// wbuf: current work buffer\n+// wp:   storage for next queued pointer (write pointer)\n+// nobj: number of queued objects\n+static void\n+scanblock(Workbuf *wbuf, Obj *wp, uintptr nobj, bool keepworking)\n+{\n+\tbyte *b, *arena_start, *arena_used;\n+\tuintptr n, i, end_b;\n+\tvoid *obj;\n+\n+\t// TODO(atom): to be expanded in a next CL\n+\tstruct Frame {uintptr count, b; uintptr *loop_or_ret;};\n+\tstruct Frame stack_top;\n+\n+\tuintptr *pc;\n+\n+\tstruct BufferList *scanbuffers;\n+\tstruct PtrTarget *ptrbuf, *ptrbuf_end;\n+\tstruct BitTarget *bitbuf;\n+\n+\tstruct PtrTarget *ptrbufpos;\n+\n+\t// End of local variable declarations.\n+\n+\tif(sizeof(Workbuf) % PageSize != 0)\n+\t\truntime_throw(\"scanblock: size of Workbuf is suboptimal\");\n+\n+\t// Memory arena parameters.\n+\tarena_start = runtime_mheap.arena_start;\n+\tarena_used = runtime_mheap.arena_used;\n+\n+\t// Allocate ptrbuf, bitbuf\n+\t{\n+\t\truntime_lock(&lock);\n+\n+\t\tif(bufferList == nil) {\n+\t\t\tbufferList = runtime_SysAlloc(sizeof(*bufferList));\n+\t\t\tbufferList->next = nil;\n+\t\t}\n+\t\tscanbuffers = bufferList;\n+\t\tbufferList = bufferList->next;\n+\n+\t\tptrbuf = &scanbuffers->ptrtarget[0];\n+\t\tptrbuf_end = &scanbuffers->ptrtarget[0] + nelem(scanbuffers->ptrtarget);\n+\t\tbitbuf = &scanbuffers->bittarget[0];\n+\n+\t\truntime_unlock(&lock);\n+\t}\n+\n+\tptrbufpos = ptrbuf;\n+\n+\tgoto next_block;\n \n+\tfor(;;) {\n+\t\t// Each iteration scans the block b of length n, queueing pointers in\n+\t\t// the work buffer.\n+\t\tif(Debug > 1) {\n+\t\t\truntime_printf(\"scanblock %p %D\\n\", b, (int64)n);\n+\t\t}\n+\n+\t\t// TODO(atom): to be replaced in a next CL\n+\t\tpc = defaultProg;\n+\n+\t\tpc++;\n+\t\tstack_top.b = (uintptr)b;\n+\n+\t\tend_b = (uintptr)b + n - PtrSize;\n+\n+\tnext_instr:\n+\t\t// TODO(atom): to be expanded in a next CL\n+\t\tswitch(pc[0]) {\n+\t\tcase GC_DEFAULT_PTR:\n+\t\t\twhile(true) {\n+\t\t\t\ti = stack_top.b;\n+\t\t\t\tif(i > end_b)\n+\t\t\t\t\tgoto next_block;\n+\t\t\t\tstack_top.b += PtrSize;\n+\n+\t\t\t\tobj = *(byte**)i;\n+\t\t\t\tif((byte*)obj >= arena_start && (byte*)obj < arena_used) {\n+\t\t\t\t\t*ptrbufpos = (struct PtrTarget){obj, 0};\n+\t\t\t\t\tptrbufpos++;\n+\t\t\t\t\tif(ptrbufpos == ptrbuf_end)\n+\t\t\t\t\t\tgoto flush_buffers;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\tdefault:\n+\t\t\truntime_throw(\"scanblock: invalid GC instruction\");\n+\t\t\treturn;\n+\t\t}\n+\n+\tflush_buffers:\n+\t\tflushptrbuf(ptrbuf, ptrbufpos-ptrbuf, &wp, &wbuf, &nobj, bitbuf);\n+\t\tptrbufpos = ptrbuf;\n+\t\tgoto next_instr;\n+\n+\tnext_block:\n \t\t// Done scanning [b, b+n).  Prepare for the next iteration of\n-\t\t// the loop by setting b and n to the parameters for the next block.\n+\t\t// the loop by setting b, n to the parameters for the next block.\n \n-\t\t// Fetch b from the work buffer.\n \t\tif(nobj == 0) {\n-\t\t\tif(!keepworking) {\n-\t\t\t\tif(wbuf)\n-\t\t\t\t\tputempty(wbuf);\n-\t\t\t\treturn;\n+\t\t\tflushptrbuf(ptrbuf, ptrbufpos-ptrbuf, &wp, &wbuf, &nobj, bitbuf);\n+\t\t\tptrbufpos = ptrbuf;\n+\n+\t\t\tif(nobj == 0) {\n+\t\t\t\tif(!keepworking) {\n+\t\t\t\t\tif(wbuf)\n+\t\t\t\t\t\tputempty(wbuf);\n+\t\t\t\t\tgoto endscan;\n+\t\t\t\t}\n+\t\t\t\t// Emptied our buffer: refill.\n+\t\t\t\twbuf = getfull(wbuf);\n+\t\t\t\tif(wbuf == nil)\n+\t\t\t\t\tgoto endscan;\n+\t\t\t\tnobj = wbuf->nobj;\n+\t\t\t\twp = wbuf->obj + wbuf->nobj;\n \t\t\t}\n-\t\t\t// Emptied our buffer: refill.\n-\t\t\twbuf = getfull(wbuf);\n-\t\t\tif(wbuf == nil)\n-\t\t\t\treturn;\n-\t\t\tnobj = wbuf->nobj;\n-\t\t\twp = (void**)(wbuf->obj + wbuf->nobj);\n \t\t}\n-\t\tb = *--wp;\n-\t\tnobj--;\n \n-\t\t// Ask span about size class.\n-\t\t// (Manually inlined copy of MHeap_Lookup.)\n-\t\tx = (uintptr)b>>PageShift;\n-\t\tif(sizeof(void*) == 8)\n-\t\t\tx -= (uintptr)arena_start>>PageShift;\n-\t\ts = runtime_mheap.map[x];\n-\t\tif(s->sizeclass == 0)\n-\t\t\tn = s->npages<<PageShift;\n-\t\telse\n-\t\t\tn = runtime_class_to_size[s->sizeclass];\n+\t\t// Fetch b from the work buffer.\n+\t\t--wp;\n+\t\tb = wp->p;\n+\t\tn = wp->n;\n+\t\tnobj--;\n \t}\n+\n+endscan:\n+\truntime_lock(&lock);\n+\tscanbuffers->next = bufferList;\n+\tbufferList = scanbuffers;\n+\truntime_unlock(&lock);\n }\n \n // debug_scanblock is the debug copy of scanblock.\n@@ -386,13 +555,12 @@ debug_scanblock(byte *b, uintptr n)\n \t\t\tcontinue;\n \n \t\tp =  (byte*)((uintptr)s->start<<PageShift);\n+\t\tsize = s->elemsize;\n \t\tif(s->sizeclass == 0) {\n \t\t\tobj = p;\n-\t\t\tsize = (uintptr)s->npages<<PageShift;\n \t\t} else {\n \t\t\tif((byte*)obj >= (byte*)s->limit)\n \t\t\t\tcontinue;\n-\t\t\tsize = runtime_class_to_size[s->sizeclass];\n \t\t\tint32 i = ((byte*)obj - p)/size;\n \t\t\tobj = p+i*size;\n \t\t}\n@@ -421,11 +589,74 @@ debug_scanblock(byte *b, uintptr n)\n \t}\n }\n \n+// Append obj to the work buffer.\n+// _wbuf, _wp, _nobj are input/output parameters and are specifying the work buffer.\n+static void\n+enqueue(Obj obj, Workbuf **_wbuf, Obj **_wp, uintptr *_nobj)\n+{\n+\tuintptr nobj, off;\n+\tObj *wp;\n+\tWorkbuf *wbuf;\n+\n+\tif(Debug > 1)\n+\t\truntime_printf(\"append obj(%p %D %p)\\n\", obj.p, (int64)obj.n, obj.ti);\n+\n+\t// Align obj.b to a word boundary.\n+\toff = (uintptr)obj.p & (PtrSize-1);\n+\tif(off != 0) {\n+\t\tobj.p += PtrSize - off;\n+\t\tobj.n -= PtrSize - off;\n+\t\tobj.ti = 0;\n+\t}\n+\n+\tif(obj.p == nil || obj.n == 0)\n+\t\treturn;\n+\n+\t// Load work buffer state\n+\twp = *_wp;\n+\twbuf = *_wbuf;\n+\tnobj = *_nobj;\n+\n+\t// If another proc wants a pointer, give it some.\n+\tif(work.nwait > 0 && nobj > handoffThreshold && work.full == 0) {\n+\t\twbuf->nobj = nobj;\n+\t\twbuf = handoff(wbuf);\n+\t\tnobj = wbuf->nobj;\n+\t\twp = wbuf->obj + nobj;\n+\t}\n+\n+\t// If buffer is full, get a new one.\n+\tif(wbuf == nil || nobj >= nelem(wbuf->obj)) {\n+\t\tif(wbuf != nil)\n+\t\t\twbuf->nobj = nobj;\n+\t\twbuf = getempty(wbuf);\n+\t\twp = wbuf->obj;\n+\t\tnobj = 0;\n+\t}\n+\n+\t*wp = obj;\n+\twp++;\n+\tnobj++;\n+\n+\t// Save work buffer state\n+\t*_wp = wp;\n+\t*_wbuf = wbuf;\n+\t*_nobj = nobj;\n+}\n+\n static void\n markroot(ParFor *desc, uint32 i)\n {\n+\tObj *wp;\n+\tWorkbuf *wbuf;\n+\tuintptr nobj;\n+\n \tUSED(&desc);\n-\tscanblock(work.roots[i].p, work.roots[i].n);\n+\twp = nil;\n+\twbuf = nil;\n+\tnobj = 0;\n+\tenqueue(work.roots[i], &wbuf, &wp, &nobj);\n+\tscanblock(wbuf, wp, nobj, false);\n }\n \n // Get an empty work buffer off the work.empty list,\n@@ -520,25 +751,24 @@ handoff(Workbuf *b)\n }\n \n static void\n-addroot(byte *p, uintptr n)\n+addroot(Obj obj)\n {\n \tuint32 cap;\n-\tGcRoot *new;\n+\tObj *new;\n \n \tif(work.nroot >= work.rootcap) {\n-\t\tcap = PageSize/sizeof(GcRoot);\n+\t\tcap = PageSize/sizeof(Obj);\n \t\tif(cap < 2*work.rootcap)\n \t\t\tcap = 2*work.rootcap;\n-\t\tnew = (GcRoot*)runtime_SysAlloc(cap*sizeof(GcRoot));\n+\t\tnew = (Obj*)runtime_SysAlloc(cap*sizeof(Obj));\n \t\tif(work.roots != nil) {\n-\t\t\truntime_memmove(new, work.roots, work.rootcap*sizeof(GcRoot));\n-\t\t\truntime_SysFree(work.roots, work.rootcap*sizeof(GcRoot));\n+\t\t\truntime_memmove(new, work.roots, work.rootcap*sizeof(Obj));\n+\t\t\truntime_SysFree(work.roots, work.rootcap*sizeof(Obj));\n \t\t}\n \t\twork.roots = new;\n \t\twork.rootcap = cap;\n \t}\n-\twork.roots[work.nroot].p = p;\n-\twork.roots[work.nroot].n = n;\n+\twork.roots[work.nroot] = obj;\n \twork.nroot++;\n }\n \n@@ -582,11 +812,11 @@ addstackroots(G *gp)\n \t\t}\n \t}\n \tif(sp != nil) {\n-\t\taddroot(sp, spsize);\n+\t\taddroot((Obj){sp, spsize, 0});\n \t\twhile((sp = __splitstack_find(next_segment, next_sp,\n \t\t\t\t\t      &spsize, &next_segment,\n \t\t\t\t\t      &next_sp, &initial_sp)) != nil)\n-\t\t\taddroot(sp, spsize);\n+\t\t\taddroot((Obj){sp, spsize, 0});\n \t}\n #else\n \tM *mp;\n@@ -608,9 +838,9 @@ addstackroots(G *gp)\n \t}\n \ttop = (byte*)gp->gcinitial_sp + gp->gcstack_size;\n \tif(top > bottom)\n-\t\taddroot(bottom, top - bottom);\n+\t\taddroot((Obj){bottom, top - bottom, 0});\n \telse\n-\t\taddroot(top, bottom - top);\n+\t\taddroot((Obj){top, bottom - top, 0});\n #endif\n }\n \n@@ -624,7 +854,7 @@ addfinroots(void *v)\n \t\truntime_throw(\"mark - finalizer inconsistency\");\n \n \t// do not mark the finalizer block itself.  just mark the things it points at.\n-\taddroot(v, size);\n+\taddroot((Obj){v, size, 0});\n }\n \n static struct root_list* roots;\n@@ -656,15 +886,15 @@ addroots(void)\n \t\t\tvoid *decl = pr->decl;\n \t\t\tif(decl == nil)\n \t\t\t\tbreak;\n-\t\t\taddroot(decl, pr->size);\n+\t\t\taddroot((Obj){decl, pr->size, 0});\n \t\t\tpr++;\n \t\t}\n \t}\n \n-\taddroot((byte*)&runtime_m0, sizeof runtime_m0);\n-\taddroot((byte*)&runtime_g0, sizeof runtime_g0);\n-\taddroot((byte*)&runtime_allg, sizeof runtime_allg);\n-\taddroot((byte*)&runtime_allm, sizeof runtime_allm);\n+\taddroot((Obj){(byte*)&runtime_m0, sizeof runtime_m0, 0});\n+\taddroot((Obj){(byte*)&runtime_g0, sizeof runtime_g0, 0});\n+\taddroot((Obj){(byte*)&runtime_allg, sizeof runtime_allg, 0});\n+\taddroot((Obj){(byte*)&runtime_allm, sizeof runtime_allm, 0});\n \truntime_MProf_Mark(addroot);\n \truntime_time_scan(addroot);\n \truntime_trampoline_scan(addroot);\n@@ -680,12 +910,14 @@ addroots(void)\n \t\t\t\tbreak;\n \t\t\tcase MTypes_Words:\n \t\t\tcase MTypes_Bytes:\n-\t\t\t\taddroot((byte*)&s->types.data, sizeof(void*));\n+\t\t\t\t// TODO(atom): consider using defaultProg instead of 0\n+\t\t\t\taddroot((Obj){(byte*)&s->types.data, sizeof(void*), 0});\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t}\n \n+\t// stacks\n \tfor(gp=runtime_allg; gp!=nil; gp=gp->alllink) {\n \t\tswitch(gp->status){\n \t\tdefault:\n@@ -709,9 +941,9 @@ addroots(void)\n \truntime_walkfintab(addfinroots, addroot);\n \n \tfor(fb=allfin; fb; fb=fb->alllink)\n-\t\taddroot((byte*)fb->fin, fb->cnt*sizeof(fb->fin[0]));\n+\t\taddroot((Obj){(byte*)fb->fin, fb->cnt*sizeof(fb->fin[0]), 0});\n \n-\taddroot((byte*)&work, sizeof work);\n+\taddroot((Obj){(byte*)&work, sizeof work, 0});\n }\n \n static bool\n@@ -955,8 +1187,9 @@ runtime_gchelper(void)\n {\n \t// parallel mark for over gc roots\n \truntime_parfordo(work.markfor);\n+\n \t// help other threads scan secondary blocks\n-\tscanblock(nil, 0);\n+\tscanblock(nil, nil, 0, true);\n \n \tif(DebugMark) {\n \t\t// wait while the main thread executes mark(debug_scanblock)\n@@ -983,16 +1216,16 @@ static int32 gcpercent = -2;\n static void\n stealcache(void)\n {\n-\tM *m;\n+\tM *mp;\n \n-\tfor(m=runtime_allm; m; m=m->alllink)\n-\t\truntime_MCache_ReleaseAll(m->mcache);\n+\tfor(mp=runtime_allm; mp; mp=mp->alllink)\n+\t\truntime_MCache_ReleaseAll(mp->mcache);\n }\n \n static void\n cachestats(GCStats *stats)\n {\n-\tM *m;\n+\tM *mp;\n \tMCache *c;\n \tuint32 i;\n \tuint64 stacks_inuse;\n@@ -1003,17 +1236,17 @@ cachestats(GCStats *stats)\n \t\truntime_memclr((byte*)stats, sizeof(*stats));\n \tstacks_inuse = 0;\n \tstacks_sys = runtime_stacks_sys;\n-\tfor(m=runtime_allm; m; m=m->alllink) {\n-\t\tc = m->mcache;\n+\tfor(mp=runtime_allm; mp; mp=mp->alllink) {\n+\t\tc = mp->mcache;\n \t\truntime_purgecachedstats(c);\n-\t\t// stacks_inuse += m->stackalloc->inuse;\n-\t\t// stacks_sys += m->stackalloc->sys;\n+\t\t// stacks_inuse += mp->stackalloc->inuse;\n+\t\t// stacks_sys += mp->stackalloc->sys;\n \t\tif(stats) {\n-\t\t\tsrc = (uint64*)&m->gcstats;\n+\t\t\tsrc = (uint64*)&mp->gcstats;\n \t\t\tdst = (uint64*)stats;\n \t\t\tfor(i=0; i<sizeof(*stats)/sizeof(uint64); i++)\n \t\t\t\tdst[i] += src[i];\n-\t\t\truntime_memclr((byte*)&m->gcstats, sizeof(m->gcstats));\n+\t\t\truntime_memclr((byte*)&mp->gcstats, sizeof(mp->gcstats));\n \t\t}\n \t\tfor(i=0; i<nelem(c->local_by_size); i++) {\n \t\t\tmstats.by_size[i].nmalloc += c->local_by_size[i].nmalloc;\n@@ -1100,7 +1333,7 @@ gc(struct gc_args *args)\n \tint64 t0, t1, t2, t3;\n \tuint64 heap0, heap1, obj0, obj1;\n \tGCStats stats;\n-\tM *m1;\n+\tM *mp;\n \tuint32 i;\n \n \truntime_semacquire(&runtime_worldsema);\n@@ -1116,8 +1349,8 @@ gc(struct gc_args *args)\n \tm->gcing = 1;\n \truntime_stoptheworld();\n \n-\tfor(m1=runtime_allm; m1; m1=m1->alllink)\n-\t\truntime_settype_flush(m1, false);\n+\tfor(mp=runtime_allm; mp; mp=mp->alllink)\n+\t\truntime_settype_flush(mp, false);\n \n \theap0 = 0;\n \tobj0 = 0;\n@@ -1127,26 +1360,27 @@ gc(struct gc_args *args)\n \t\tobj0 = mstats.nmalloc - mstats.nfree;\n \t}\n \n+\tm->locks++;\t// disable gc during mallocs in parforalloc\n+\tif(work.markfor == nil)\n+\t\twork.markfor = runtime_parforalloc(MaxGcproc);\n+\tif(work.sweepfor == nil)\n+\t\twork.sweepfor = runtime_parforalloc(MaxGcproc);\n+\tm->locks--;\n+\n \twork.nwait = 0;\n \twork.ndone = 0;\n \twork.debugmarkdone = 0;\n \twork.nproc = runtime_gcprocs();\n \taddroots();\n-\tm->locks++;\t// disable gc during mallocs in parforalloc\n-\tif(work.markfor == nil)\n-\t\twork.markfor = runtime_parforalloc(MaxGcproc);\n \truntime_parforsetup(work.markfor, work.nproc, work.nroot, nil, false, markroot);\n-\tif(work.sweepfor == nil)\n-\t\twork.sweepfor = runtime_parforalloc(MaxGcproc);\n \truntime_parforsetup(work.sweepfor, work.nproc, runtime_mheap.nspan, nil, true, sweepspan);\n-\tm->locks--;\n \tif(work.nproc > 1) {\n \t\truntime_noteclear(&work.alldone);\n \t\truntime_helpgc(work.nproc);\n \t}\n \n \truntime_parfordo(work.markfor);\n-\tscanblock(nil, 0);\n+\tscanblock(nil, nil, 0, true);\n \n \tif(DebugMark) {\n \t\tfor(i=0; i<work.nroot; i++)"}, {"sha": "a2798ef34e2c7ccfc41183fa15bec3c8cc17f079", "filename": "libgo/runtime/mgc0.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Fmgc0.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Fmgc0.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.h?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Garbage collector (GC)\n+\n+// GC instruction opcodes.\n+//\n+// The opcode of an instruction is followed by zero or more\n+// arguments to the instruction.\n+//\n+// Meaning of arguments:\n+//   off      Offset (in bytes) from the start of the current object\n+//   objgc    Pointer to GC info of an object\n+//   len      Length of an array\n+//   elemsize Size (in bytes) of an element\n+//   size     Size (in bytes)\n+enum {\n+\tGC_END,         // End of object, loop or subroutine. Args: none\n+\tGC_PTR,         // A typed pointer. Args: (off, objgc)\n+\tGC_APTR,        // Pointer to an arbitrary object. Args: (off)\n+\tGC_ARRAY_START, // Start an array with a fixed length. Args: (off, len, elemsize)\n+\tGC_ARRAY_NEXT,  // The next element of an array. Args: none\n+\tGC_CALL,        // Call a subroutine. Args: (off, objgc)\n+\tGC_MAP_PTR,     // Go map. Args: (off, MapType*)\n+\tGC_STRING,      // Go string. Args: (off)\n+\tGC_EFACE,       // interface{}. Args: (off)\n+\tGC_IFACE,       // interface{...}. Args: (off)\n+\tGC_SLICE,       // Go slice. Args: (off, objgc)\n+\tGC_REGION,      // A region/part of the current object. Args: (off, size, objgc)\n+\n+\tGC_NUM_INSTR,   // Number of instruction opcodes\n+};\n+\n+enum {\n+\t// Size of GC's fixed stack.\n+\t//\n+\t// The current GC implementation permits:\n+\t//  - at most 1 stack allocation because of GC_CALL\n+\t//  - at most GC_STACK_CAPACITY allocations because of GC_ARRAY_START\n+\tGC_STACK_CAPACITY = 8,\t\n+};"}, {"sha": "8b3a195b8906af7da50128fc98a746fcc3a9c551", "filename": "libgo/runtime/mprof.goc", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Fmprof.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Fmprof.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmprof.goc?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -362,13 +362,13 @@ func MemProfile(p Slice, include_inuse_zero bool) (n int, ok bool) {\n }\n \n void\n-runtime_MProf_Mark(void (*addroot)(byte *, uintptr))\n+runtime_MProf_Mark(void (*addroot)(Obj))\n {\n \t// buckhash is not allocated via mallocgc.\n-\taddroot((byte*)&mbuckets, sizeof mbuckets);\n-\taddroot((byte*)&bbuckets, sizeof bbuckets);\n-\taddroot((byte*)&addrhash, sizeof addrhash);\n-\taddroot((byte*)&addrfree, sizeof addrfree);\n+\taddroot((Obj){(byte*)&mbuckets, sizeof mbuckets, 0});\n+\taddroot((Obj){(byte*)&bbuckets, sizeof bbuckets, 0});\n+\taddroot((Obj){(byte*)&addrhash, sizeof addrhash, 0});\n+\taddroot((Obj){(byte*)&addrfree, sizeof addrfree, 0});\n }\n \n // Must match BlockProfileRecord in debug.go.\n@@ -412,18 +412,18 @@ struct TRecord {\n \n func ThreadCreateProfile(p Slice) (n int, ok bool) {\n \tTRecord *r;\n-\tM *first, *m;\n+\tM *first, *mp;\n \t\n \tfirst = runtime_atomicloadp(&runtime_allm);\n \tn = 0;\n-\tfor(m=first; m; m=m->alllink)\n+\tfor(mp=first; mp; mp=mp->alllink)\n \t\tn++;\n \tok = false;\n \tif(n <= p.__count) {\n \t\tok = true;\n \t\tr = (TRecord*)p.__values;\n-\t\tfor(m=first; m; m=m->alllink) {\n-\t\t\truntime_memmove(r->stk, m->createstack, sizeof r->stk);\n+\t\tfor(mp=first; mp; mp=mp->alllink) {\n+\t\t\truntime_memmove(r->stk, mp->createstack, sizeof r->stk);\n \t\t\tr++;\n \t\t}\n \t}\n@@ -471,11 +471,11 @@ func Stack(b Slice, all bool) (n int) {\n }\n \n static void\n-saveg(G *g, TRecord *r)\n+saveg(G *gp, TRecord *r)\n {\n \tint32 n;\n \n-\tif(g == runtime_g())\n+\tif(gp == runtime_g())\n \t\tn = runtime_callers(0, r->stk, nelem(r->stk));\n \telse {\n \t\t// FIXME: Not implemented."}, {"sha": "9b229d6bf462bfcef427a4d5e8bdf9a0981f8693", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -555,13 +555,13 @@ schedlock(void)\n static void\n schedunlock(void)\n {\n-\tM *m;\n+\tM *mp;\n \n-\tm = mwakeup;\n+\tmp = mwakeup;\n \tmwakeup = nil;\n \truntime_unlock(&runtime_sched);\n-\tif(m != nil)\n-\t\truntime_notewakeup(&m->havenextg);\n+\tif(mp != nil)\n+\t\truntime_notewakeup(&mp->havenextg);\n }\n \n void"}, {"sha": "ecd804de6863961eac83375aaf2ba687347a094e", "filename": "libgo/runtime/runtime.c", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Fruntime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Fruntime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.c?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -79,33 +79,6 @@ runtime_goenvs_unix(void)\n \tsyscall_Envs.__capacity = n;\n }\n \n-const byte*\n-runtime_getenv(const char *s)\n-{\n-\tint32 i, j, len;\n-\tconst byte *v, *bs;\n-\tString* envv;\n-\tint32 envc;\n-\n-\tbs = (const byte*)s;\n-\tlen = runtime_findnull(bs);\n-\tenvv = (String*)syscall_Envs.__values;\n-\tenvc = syscall_Envs.__count;\n-\tfor(i=0; i<envc; i++){\n-\t\tif(envv[i].len <= len)\n-\t\t\tcontinue;\n-\t\tv = (const byte*)envv[i].str;\n-\t\tfor(j=0; j<len; j++)\n-\t\t\tif(bs[j] != v[j])\n-\t\t\t\tgoto nomatch;\n-\t\tif(v[len] != '=')\n-\t\t\tgoto nomatch;\n-\t\treturn v+len+1;\n-\tnomatch:;\n-\t}\n-\treturn nil;\n-}\n-\n int32\n runtime_atoi(const byte *p)\n {"}, {"sha": "c5cd3a08f4583c4dcf27947860507f61c1a176df", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -599,9 +599,6 @@ enum\n \tUseSpanType = 1,\n };\n \n-void\truntime_time_scan(void (*)(byte*, uintptr));\n-void\truntime_trampoline_scan(void (*)(byte *, uintptr));\n-\n void\truntime_setsig(int32, bool, bool);\n #define runtime_setitimer setitimer\n "}, {"sha": "d4973611d4eb7167f987ad6e4c7677aef82b7454", "filename": "libgo/runtime/time.goc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Ftime.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/409a5e7eb4cca107037fafa4a7eea92603edb83d/libgo%2Fruntime%2Ftime.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Ftime.goc?ref=409a5e7eb4cca107037fafa4a7eea92603edb83d", "patch": "@@ -255,7 +255,7 @@ siftdown(int32 i)\n }\n \n void\n-runtime_time_scan(void (*addroot)(byte*, uintptr))\n+runtime_time_scan(void (*addroot)(Obj))\n {\n-\taddroot((byte*)&timers, sizeof timers);\n+\taddroot((Obj){(byte*)&timers, sizeof timers, 0});\n }"}]}