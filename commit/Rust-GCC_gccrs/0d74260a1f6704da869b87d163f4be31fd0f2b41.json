{"sha": "0d74260a1f6704da869b87d163f4be31fd0f2b41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ3NDI2MGExZjY3MDRkYTg2OWI4N2QxNjNmNGJlMzFmZDBmMmI0MQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-12-17T00:15:07Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-12-17T00:15:07Z"}, "message": "recog: Add a class for propagating into insns\n\nThis patch adds yet another way of propagating into an instruction and\nsimplifying the result.  (The net effect of the series is to keep the\ntotal number of propagation approaches the same though, since a later\npatch removes the fwprop.c routines.)\n\nOne of the drawbacks of the validate_replace_* routines is that\nthey only do simple simplifications, mostly canonicalisations:\n\n  /* Do changes needed to keep rtx consistent.  Don't do any other\n     simplifications, as it is not our job.  */\n  if (simplify)\n    simplify_while_replacing (loc, to, object, op0_mode);\n\nBut substituting can often lead to real simplification opportunities.\nsimplify-rtx.c:simplify_replace_rtx does fully simplify the result,\nbut it only operates on specific rvalues rather than full instruction\npatterns.  It is also nondestructive, which means that it returns a\nnew rtx whenever a substitution or simplification was possible.\nThis can create quite a bit of garbage rtl in the context of a\nspeculative recog, where changing the contents of a pointer is\noften enough.\n\nThe new routines are therefore supposed to provide simplify_replace_rtx-\nstyle substitution in recog.  They go to some effort to prevent garbage\nrtl from being created.\n\nAt the moment, the new routines fail if the pattern would still refer\nto the old \"from\" value in some way.  That might be unnecessary in\nsome contexts; if so, it could be put behind a configuration parameter.\n\ngcc/\n\t* recog.h (insn_propagation): New class.\n\t* recog.c (insn_propagation::apply_to_mem_1): New function.\n\t(insn_propagation::apply_to_rvalue_1): Likewise.\n\t(insn_propagation::apply_to_lvalue_1): Likewise.\n\t(insn_propagation::apply_to_pattern_1): Likewise.\n\t(insn_propagation::apply_to_pattern): Likewise.\n\t(insn_propagation::apply_to_rvalue): Likewise.", "tree": {"sha": "ecb8e15bf6da3cd0a8a96cc22819679f05ec439c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecb8e15bf6da3cd0a8a96cc22819679f05ec439c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d74260a1f6704da869b87d163f4be31fd0f2b41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d74260a1f6704da869b87d163f4be31fd0f2b41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d74260a1f6704da869b87d163f4be31fd0f2b41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d74260a1f6704da869b87d163f4be31fd0f2b41/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb74135dd35213f800f434df92b2835ce49f8ea6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb74135dd35213f800f434df92b2835ce49f8ea6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb74135dd35213f800f434df92b2835ce49f8ea6"}], "stats": {"total": 480, "additions": 480, "deletions": 0}, "files": [{"sha": "e9aa1ba253d006220042f3f5106f38b363ab88d3", "filename": "gcc/recog.c", "status": "modified", "additions": 380, "deletions": 0, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d74260a1f6704da869b87d163f4be31fd0f2b41/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d74260a1f6704da869b87d163f4be31fd0f2b41/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=0d74260a1f6704da869b87d163f4be31fd0f2b41", "patch": "@@ -997,6 +997,386 @@ validate_simplify_insn (rtx_insn *insn)\n   return ((num_changes_pending () > 0) && (apply_change_group () > 0));\n }\n \n+/* Try to process the address of memory expression MEM.  Return true on\n+   success; leave the caller to clean up on failure.  */\n+\n+bool\n+insn_propagation::apply_to_mem_1 (rtx mem)\n+{\n+  auto old_num_changes = num_validated_changes ();\n+  mem_depth += 1;\n+  bool res = apply_to_rvalue_1 (&XEXP (mem, 0));\n+  mem_depth -= 1;\n+  if (!res)\n+    return false;\n+\n+  if (old_num_changes != num_validated_changes ()\n+      && should_check_mems\n+      && !check_mem (old_num_changes, mem))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Try to process the rvalue expression at *LOC.  Return true on success;\n+   leave the caller to clean up on failure.  */\n+\n+bool\n+insn_propagation::apply_to_rvalue_1 (rtx *loc)\n+{\n+  rtx x = *loc;\n+  enum rtx_code code = GET_CODE (x);\n+  machine_mode mode = GET_MODE (x);\n+\n+  auto old_num_changes = num_validated_changes ();\n+  if (from && GET_CODE (x) == GET_CODE (from) && rtx_equal_p (x, from))\n+    {\n+      /* Don't replace register asms in asm statements; we mustn't\n+\t change the user's register allocation.  */\n+      if (REG_P (x)\n+\t  && HARD_REGISTER_P (x)\n+\t  && register_asm_p (x)\n+\t  && asm_noperands (PATTERN (insn)) > 0)\n+\treturn false;\n+\n+      if (should_unshare)\n+\tvalidate_unshare_change (insn, loc, to, 1);\n+      else\n+\tvalidate_change (insn, loc, to, 1);\n+      if (mem_depth && !REG_P (to) && !CONSTANT_P (to))\n+\t{\n+\t  /* We're substituting into an address, but TO will have the\n+\t     form expected outside an address.  Canonicalize it if\n+\t     necessary.  */\n+\t  insn_propagation subprop (insn);\n+\t  subprop.mem_depth += 1;\n+\t  if (!subprop.apply_to_rvalue (loc))\n+\t    gcc_unreachable ();\n+\t  if (should_unshare\n+\t      && num_validated_changes () != old_num_changes + 1)\n+\t    {\n+\t      /* TO is owned by someone else, so create a copy and\n+\t\t return TO to its original form.  */\n+\t      rtx to = copy_rtx (*loc);\n+\t      cancel_changes (old_num_changes);\n+\t      validate_change (insn, loc, to, 1);\n+\t    }\n+\t}\n+      num_replacements += 1;\n+      should_unshare = true;\n+      result_flags |= UNSIMPLIFIED;\n+      return true;\n+    }\n+\n+  /* Recursively apply the substitution and see if we can simplify\n+     the result.  This specifically shouldn't use simplify_gen_* for\n+     speculative simplifications, since we want to avoid generating new\n+     expressions where possible.  */\n+  auto old_result_flags = result_flags;\n+  rtx newx = NULL_RTX;\n+  bool recurse_p = false;\n+  switch (GET_RTX_CLASS (code))\n+    {\n+    case RTX_UNARY:\n+      {\n+\tmachine_mode op0_mode = GET_MODE (XEXP (x, 0));\n+\tif (!apply_to_rvalue_1 (&XEXP (x, 0)))\n+\t  return false;\n+\tif (from && old_num_changes == num_validated_changes ())\n+\t  return true;\n+\n+\tnewx = simplify_unary_operation (code, mode, XEXP (x, 0), op0_mode);\n+\tbreak;\n+      }\n+\n+    case RTX_BIN_ARITH:\n+    case RTX_COMM_ARITH:\n+      {\n+\tif (!apply_to_rvalue_1 (&XEXP (x, 0))\n+\t    || !apply_to_rvalue_1 (&XEXP (x, 1)))\n+\t  return false;\n+\tif (from && old_num_changes == num_validated_changes ())\n+\t  return true;\n+\n+\tif (GET_RTX_CLASS (code) == RTX_COMM_ARITH\n+\t    && swap_commutative_operands_p (XEXP (x, 0), XEXP (x, 1)))\n+\t  newx = simplify_gen_binary (code, mode, XEXP (x, 1), XEXP (x, 0));\n+\telse\n+\t  newx = simplify_binary_operation (code, mode,\n+\t\t\t\t\t    XEXP (x, 0), XEXP (x, 1));\n+\tbreak;\n+      }\n+\n+    case RTX_COMPARE:\n+    case RTX_COMM_COMPARE:\n+      {\n+\tmachine_mode op_mode = (GET_MODE (XEXP (x, 0)) != VOIDmode\n+\t\t\t\t? GET_MODE (XEXP (x, 0))\n+\t\t\t\t: GET_MODE (XEXP (x, 1)));\n+\tif (!apply_to_rvalue_1 (&XEXP (x, 0))\n+\t    || !apply_to_rvalue_1 (&XEXP (x, 1)))\n+\t  return false;\n+\tif (from && old_num_changes == num_validated_changes ())\n+\t  return true;\n+\n+\tnewx = simplify_relational_operation (code, mode, op_mode,\n+\t\t\t\t\t      XEXP (x, 0), XEXP (x, 1));\n+\tbreak;\n+      }\n+\n+    case RTX_TERNARY:\n+    case RTX_BITFIELD_OPS:\n+      {\n+\tmachine_mode op0_mode = GET_MODE (XEXP (x, 0));\n+\tif (!apply_to_rvalue_1 (&XEXP (x, 0))\n+\t    || !apply_to_rvalue_1 (&XEXP (x, 1))\n+\t    || !apply_to_rvalue_1 (&XEXP (x, 2)))\n+\t  return false;\n+\tif (from && old_num_changes == num_validated_changes ())\n+\t  return true;\n+\n+\tnewx = simplify_ternary_operation (code, mode, op0_mode,\n+\t\t\t\t\t   XEXP (x, 0), XEXP (x, 1),\n+\t\t\t\t\t   XEXP (x, 2));\n+\tbreak;\n+      }\n+\n+    case RTX_EXTRA:\n+      if (code == SUBREG)\n+\t{\n+\t  machine_mode inner_mode = GET_MODE (SUBREG_REG (x));\n+\t  if (!apply_to_rvalue_1 (&SUBREG_REG (x)))\n+\t    return false;\n+\t  if (from && old_num_changes == num_validated_changes ())\n+\t    return true;\n+\n+\t  rtx inner = SUBREG_REG (x);\n+\t  newx = simplify_subreg (mode, inner, inner_mode, SUBREG_BYTE (x));\n+\t  /* Reject the same cases that simplify_gen_subreg would.  */\n+\t  if (!newx\n+\t      && (GET_CODE (inner) == SUBREG\n+\t\t  || GET_CODE (inner) == CONCAT\n+\t\t  || GET_MODE (inner) == VOIDmode\n+\t\t  || !validate_subreg (mode, inner_mode,\n+\t\t\t\t       inner, SUBREG_BYTE (x))))\n+\t    {\n+\t      failure_reason = \"would create an invalid subreg\";\n+\t      return false;\n+\t    }\n+\t  break;\n+\t}\n+      else\n+\trecurse_p = true;\n+      break;\n+\n+    case RTX_OBJ:\n+      if (code == LO_SUM)\n+\t{\n+\t  if (!apply_to_rvalue_1 (&XEXP (x, 0))\n+\t      || !apply_to_rvalue_1 (&XEXP (x, 1)))\n+\t    return false;\n+\t  if (from && old_num_changes == num_validated_changes ())\n+\t    return true;\n+\n+\t  /* (lo_sum (high x) y) -> y where x and y have the same base.  */\n+\t  rtx op0 = XEXP (x, 0);\n+\t  rtx op1 = XEXP (x, 1);\n+\t  if (GET_CODE (op0) == HIGH)\n+\t    {\n+\t      rtx base0, base1, offset0, offset1;\n+\t      split_const (XEXP (op0, 0), &base0, &offset0);\n+\t      split_const (op1, &base1, &offset1);\n+\t      if (rtx_equal_p (base0, base1))\n+\t\tnewx = op1;\n+\t    }\n+\t}\n+      else if (code == REG)\n+\t{\n+\t  if (from && REG_P (from) && reg_overlap_mentioned_p (x, from))\n+\t    {\n+\t      failure_reason = \"inexact register overlap\";\n+\t      return false;\n+\t    }\n+\t}\n+      else if (code == MEM)\n+\treturn apply_to_mem_1 (x);\n+      else\n+\trecurse_p = true;\n+      break;\n+\n+    case RTX_CONST_OBJ:\n+      break;\n+\n+    case RTX_AUTOINC:\n+      if (from && reg_overlap_mentioned_p (XEXP (x, 0), from))\n+\t{\n+\t  failure_reason = \"is subject to autoinc\";\n+\t  return false;\n+\t}\n+      recurse_p = true;\n+      break;\n+\n+    case RTX_MATCH:\n+    case RTX_INSN:\n+      gcc_unreachable ();\n+    }\n+\n+  if (recurse_p)\n+    {\n+      const char *fmt = GET_RTX_FORMAT (code);\n+      for (int i = 0; fmt[i]; i++)\n+\tswitch (fmt[i])\n+\t  {\n+\t  case 'E':\n+\t    for (int j = 0; j < XVECLEN (x, i); j++)\n+\t      if (!apply_to_rvalue_1 (&XVECEXP (x, i, j)))\n+\t\treturn false;\n+\t    break;\n+\n+\t  case 'e':\n+\t    if (XEXP (x, i) && !apply_to_rvalue_1 (&XEXP (x, i)))\n+\t      return false;\n+\t    break;\n+\t  }\n+    }\n+  else if (newx && !rtx_equal_p (x, newx))\n+    {\n+      /* All substitutions made by OLD_NUM_CHANGES onwards have been\n+\t simplified.  */\n+      result_flags = ((result_flags & ~UNSIMPLIFIED)\n+\t\t      | (old_result_flags & UNSIMPLIFIED));\n+\n+      if (should_note_simplifications)\n+\tnote_simplification (old_num_changes, old_result_flags, x, newx);\n+\n+      /* There's no longer any point unsharing the substitutions made\n+\t for subexpressions, since we'll just copy this one instead.  */\n+      bool unshare = false;\n+      for (int i = old_num_changes; i < num_changes; ++i)\n+\t{\n+\t  unshare |= changes[i].unshare;\n+\t  changes[i].unshare = false;\n+\t}\n+      if (unshare)\n+\tvalidate_unshare_change (insn, loc, newx, 1);\n+      else\n+\tvalidate_change (insn, loc, newx, 1);\n+    }\n+\n+  return true;\n+}\n+\n+/* Try to process the lvalue expression at *LOC.  Return true on success;\n+   leave the caller to clean up on failure.  */\n+\n+bool\n+insn_propagation::apply_to_lvalue_1 (rtx dest)\n+{\n+  rtx old_dest = dest;\n+  while (GET_CODE (dest) == SUBREG\n+\t || GET_CODE (dest) == ZERO_EXTRACT\n+\t || GET_CODE (dest) == STRICT_LOW_PART)\n+    {\n+      if (GET_CODE (dest) == ZERO_EXTRACT\n+\t  && (!apply_to_rvalue_1 (&XEXP (dest, 1))\n+\t      || !apply_to_rvalue_1 (&XEXP (dest, 2))))\n+\treturn false;\n+      dest = XEXP (dest, 0);\n+    }\n+\n+  if (MEM_P (dest))\n+    return apply_to_mem_1 (dest);\n+\n+  /* Check whether the substitution is safe in the presence of this lvalue.  */\n+  if (!from\n+      || dest == old_dest\n+      || !REG_P (dest)\n+      || !reg_overlap_mentioned_p (dest, from))\n+    return true;\n+\n+  if (SUBREG_P (old_dest)\n+      && SUBREG_REG (old_dest) == dest\n+      && !read_modify_subreg_p (old_dest))\n+    return true;\n+\n+  failure_reason = \"is part of a read-write destination\";\n+  return false;\n+}\n+\n+/* Try to process the instruction pattern at *LOC.  Return true on success;\n+   leave the caller to clean up on failure.  */\n+\n+bool\n+insn_propagation::apply_to_pattern_1 (rtx *loc)\n+{\n+  rtx body = *loc;\n+  switch (GET_CODE (body))\n+    {\n+    case COND_EXEC:\n+      return (apply_to_rvalue_1 (&COND_EXEC_TEST (body))\n+\t      && apply_to_pattern_1 (&COND_EXEC_CODE (body)));\n+\n+    case PARALLEL:\n+      {\n+\tint last = XVECLEN (body, 0) - 1;\n+\tfor (int i = 0; i < last; ++i)\n+\t  if (!apply_to_pattern_1 (&XVECEXP (body, 0, i)))\n+\t    return false;\n+\treturn apply_to_pattern_1 (&XVECEXP (body, 0, last));\n+      }\n+\n+    case ASM_OPERANDS:\n+      for (int i = 0, len = ASM_OPERANDS_INPUT_LENGTH (body); i < len; ++i)\n+\tif (!apply_to_rvalue_1 (&ASM_OPERANDS_INPUT (body, i)))\n+\t  return false;\n+      return true;\n+\n+    case CLOBBER:\n+      return apply_to_lvalue_1 (XEXP (body, 0));\n+\n+    case SET:\n+      return (apply_to_lvalue_1 (SET_DEST (body))\n+\t      && apply_to_rvalue_1 (&SET_SRC (body)));\n+\n+    default:\n+      /* All the other possibilities never store and can use a normal\n+\t rtx walk.  This includes:\n+\n+\t - USE\n+\t - TRAP_IF\n+\t - PREFETCH\n+\t - UNSPEC\n+\t - UNSPEC_VOLATILE.  */\n+      return apply_to_rvalue_1 (loc);\n+    }\n+}\n+\n+/* Apply this insn_propagation object's simplification or substitution\n+   to the instruction pattern at LOC.  */\n+\n+bool\n+insn_propagation::apply_to_pattern (rtx *loc)\n+{\n+  unsigned int num_changes = num_validated_changes ();\n+  bool res = apply_to_pattern_1 (loc);\n+  if (!res)\n+    cancel_changes (num_changes);\n+  return res;\n+}\n+\n+/* Apply this insn_propagation object's simplification or substitution\n+   to the rvalue expression at LOC.  */\n+\n+bool\n+insn_propagation::apply_to_rvalue (rtx *loc)\n+{\n+  unsigned int num_changes = num_validated_changes ();\n+  bool res = apply_to_rvalue_1 (loc);\n+  if (!res)\n+    cancel_changes (num_changes);\n+  return res;\n+}\n+\n /* Check whether INSN matches a specific alternative of an .md pattern.  */\n \n bool"}, {"sha": "d6af2aa66d9b285791a3de3707ebd7ee1e35b6a5", "filename": "gcc/recog.h", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d74260a1f6704da869b87d163f4be31fd0f2b41/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d74260a1f6704da869b87d163f4be31fd0f2b41/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=0d74260a1f6704da869b87d163f4be31fd0f2b41", "patch": "@@ -82,6 +82,106 @@ alternative_class (const operand_alternative *alt, int i)\n   return alt[i].matches >= 0 ? alt[alt[i].matches].cl : alt[i].cl;\n }\n \n+/* A class for substituting one rtx for another within an instruction,\n+   or for recursively simplifying the instruction as-is.  Derived classes\n+   can record or filter certain decisions.  */\n+\n+class insn_propagation : public simplify_context\n+{\n+public:\n+  /* Assignments for RESULT_FLAGS.\n+\n+     UNSIMPLIFIED is true if a substitution has been made inside an rtx\n+     X and if neither X nor its parent expressions could be simplified.\n+\n+     FIRST_SPARE_RESULT is the first flag available for derived classes.  */\n+  static const uint16_t UNSIMPLIFIED = 1U << 0;\n+  static const uint16_t FIRST_SPARE_RESULT = 1U << 1;\n+\n+  insn_propagation (rtx_insn *);\n+  insn_propagation (rtx_insn *, rtx, rtx, bool = true);\n+  bool apply_to_pattern (rtx *);\n+  bool apply_to_rvalue (rtx *);\n+\n+  /* Return true if we should accept a substitution into the address of\n+     memory expression MEM.  Undoing changes OLD_NUM_CHANGES and up restores\n+     MEM's original address.  */\n+  virtual bool check_mem (int /*old_num_changes*/,\n+\t\t\t  rtx /*mem*/) { return true; }\n+\n+  /* Note that we've simplified OLD_RTX into NEW_RTX.  When substituting,\n+     this only happens if a substitution occured within OLD_RTX.\n+     Undoing OLD_NUM_CHANGES and up will restore the old form of OLD_RTX.\n+     OLD_RESULT_FLAGS is the value that RESULT_FLAGS had before processing\n+     OLD_RTX.  */\n+  virtual void note_simplification (int /*old_num_changes*/,\n+\t\t\t\t    uint16_t /*old_result_flags*/,\n+\t\t\t\t    rtx /*old_rtx*/, rtx /*new_rtx*/) {}\n+\n+private:\n+  bool apply_to_mem_1 (rtx);\n+  bool apply_to_lvalue_1 (rtx);\n+  bool apply_to_rvalue_1 (rtx *);\n+  bool apply_to_pattern_1 (rtx *);\n+\n+public:\n+  /* The instruction that we are simplifying or propagating into.  */\n+  rtx_insn *insn;\n+\n+  /* If FROM is nonnull, we're replacing FROM with TO, otherwise we're\n+     just doing a recursive simplification.  */\n+  rtx from;\n+  rtx to;\n+\n+  /* The number of times that we have replaced FROM with TO.  */\n+  unsigned int num_replacements;\n+\n+  /* A bitmask of flags that describe the result of the simplificiation;\n+     see above for details.  */\n+  uint16_t result_flags : 16;\n+\n+  /* True if we should unshare TO when making the next substitution,\n+     false if we can use TO itself.  */\n+  uint16_t should_unshare : 1;\n+\n+  /* True if we should call check_mem after substituting into a memory.  */\n+  uint16_t should_check_mems : 1;\n+\n+  /* True if we should call note_simplification after each simplification.  */\n+  uint16_t should_note_simplifications : 1;\n+\n+  /* For future expansion.  */\n+  uint16_t spare : 13;\n+\n+  /* Gives the reason that a substitution failed, for debug purposes.  */\n+  const char *failure_reason;\n+};\n+\n+/* Try to replace FROM with TO in INSN.  SHARED_P is true if TO is shared\n+   with other instructions, false if INSN can use TO directly.  */\n+\n+inline insn_propagation::insn_propagation (rtx_insn *insn, rtx from, rtx to,\n+\t\t\t\t\t   bool shared_p)\n+  : insn (insn),\n+    from (from),\n+    to (to),\n+    num_replacements (0),\n+    result_flags (0),\n+    should_unshare (shared_p),\n+    should_check_mems (false),\n+    should_note_simplifications (false),\n+    spare (0),\n+    failure_reason (nullptr)\n+{\n+}\n+\n+/* Try to simplify INSN without performing a substitution.  */\n+\n+inline insn_propagation::insn_propagation (rtx_insn *insn)\n+  : insn_propagation (insn, NULL_RTX, NULL_RTX)\n+{\n+}\n+\n extern void init_recog (void);\n extern void init_recog_no_volatile (void);\n extern int check_asm_operands (rtx);"}]}