{"sha": "481e1176d7614dcd519e50c488a155312280913e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgxZTExNzZkNzYxNGRjZDUxOWU1MGM0ODhhMTU1MzEyMjgwOTEzZQ==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2010-08-11T10:04:43Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2010-08-11T10:04:43Z"}, "message": "opts.h (struct cl_option_handler_func): Make handler take cl_decoded_option structure as parameter, not individual elements.\n\n\t* opts.h (struct cl_option_handler_func): Make handler take\n\tcl_decoded_option structure as parameter, not individual elements.\n\t(struct cl_option_handlers): Make callbacks take cl_decoded_option\n\tstructure as parameter, not individual elements.\n\t(handle_option): Take cl_decoded_option structure as parameter,\n\tnot individual elements.\n\t(handle_generated_option): Declare.\n\t* opts-common.c (handle_option): Take cl_decoded_option structure\n\tas parameter, not individual elements.  Update calls to callback\n\tand handler functions.\n\t(handle_generated_option): New.\n\t(read_cmdline_option): Update calls to callback functions and\n\thandle_option.\n\t* opts.c (common_handle_option, complain_wrong_lang,\n\tunknown_option_callback, post_handling_callback,\n\tlang_handle_option, target_handle_option): Take cl_decoded_option\n\tstructure as parameter, not individual elements.\n\t(lang_handle_option, target_handle_option, common_handle_option):\n\tAssert option has at most one argument.\n\t(enable_warning_as_error): Call handle_generated_option instead of\n\thandle_option.  Do not pass -Werror argument as argument of\n\tgenerated option.\n\nc-family:\n\t* c-opts.c (c_common_handle_option): Call handle_generated_option\n\tinstead of handle_option.\n\nFrom-SVN: r163095", "tree": {"sha": "48318d1dff4b32ecb5516a974e71f0e815752ba3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48318d1dff4b32ecb5516a974e71f0e815752ba3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/481e1176d7614dcd519e50c488a155312280913e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/481e1176d7614dcd519e50c488a155312280913e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/481e1176d7614dcd519e50c488a155312280913e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/481e1176d7614dcd519e50c488a155312280913e/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3abeaf8f89f246f481c869a09d0715a2762bde28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3abeaf8f89f246f481c869a09d0715a2762bde28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3abeaf8f89f246f481c869a09d0715a2762bde28"}], "stats": {"total": 195, "additions": 145, "deletions": 50}, "files": [{"sha": "ea4a0bba96073c16e168c50673e18bbf23a064e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481e1176d7614dcd519e50c488a155312280913e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481e1176d7614dcd519e50c488a155312280913e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=481e1176d7614dcd519e50c488a155312280913e", "patch": "@@ -1,3 +1,28 @@\n+2010-08-11  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* opts.h (struct cl_option_handler_func): Make handler take\n+\tcl_decoded_option structure as parameter, not individual elements.\n+\t(struct cl_option_handlers): Make callbacks take cl_decoded_option\n+\tstructure as parameter, not individual elements.\n+\t(handle_option): Take cl_decoded_option structure as parameter,\n+\tnot individual elements.\n+\t(handle_generated_option): Declare.\n+\t* opts-common.c (handle_option): Take cl_decoded_option structure\n+\tas parameter, not individual elements.  Update calls to callback\n+\tand handler functions.\n+\t(handle_generated_option): New.\n+\t(read_cmdline_option): Update calls to callback functions and\n+\thandle_option.\n+\t* opts.c (common_handle_option, complain_wrong_lang,\n+\tunknown_option_callback, post_handling_callback,\n+\tlang_handle_option, target_handle_option): Take cl_decoded_option\n+\tstructure as parameter, not individual elements.\n+\t(lang_handle_option, target_handle_option, common_handle_option):\n+\tAssert option has at most one argument.\n+\t(enable_warning_as_error): Call handle_generated_option instead of\n+\thandle_option.  Do not pass -Werror argument as argument of\n+\tgenerated option.\n+\n 2010-08-10  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* config/pa/linux-atomic.c (SUBWORD_VAL_CAS): Instantiate with"}, {"sha": "ce4fa365388b0c6332f8b8589f79e2272406d778", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481e1176d7614dcd519e50c488a155312280913e/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481e1176d7614dcd519e50c488a155312280913e/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=481e1176d7614dcd519e50c488a155312280913e", "patch": "@@ -1,3 +1,8 @@\n+2010-08-11  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-opts.c (c_common_handle_option): Call handle_generated_option\n+\tinstead of handle_option.\n+\n 2010-08-08  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* c-pragma.c (add_to_renaming_pragma_list): Fix call to VEC_safe_push."}, {"sha": "b46b0a04908ff505ffb66581d2af9ded8698e093", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481e1176d7614dcd519e50c488a155312280913e/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481e1176d7614dcd519e50c488a155312280913e/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=481e1176d7614dcd519e50c488a155312280913e", "patch": "@@ -437,8 +437,8 @@ c_common_handle_option (size_t scode, const char *arg, int value,\n     case OPT_Wall:\n       warn_unused = value;\n       set_Wformat (value);\n-      handle_option (OPT_Wimplicit, NULL, value, c_family_lang_mask, kind,\n-\t\t     handlers);\n+      handle_generated_option (OPT_Wimplicit, NULL, value,\n+\t\t\t       c_family_lang_mask, kind, handlers);\n       warn_char_subscripts = value;\n       warn_missing_braces = value;\n       warn_parentheses = value;\n@@ -539,11 +539,11 @@ c_common_handle_option (size_t scode, const char *arg, int value,\n     case OPT_Wimplicit:\n       gcc_assert (value == 0 || value == 1);\n       if (warn_implicit_int == -1)\n-\thandle_option (OPT_Wimplicit_int, NULL, value,\n-\t\t       c_family_lang_mask, kind, handlers);\n+\thandle_generated_option (OPT_Wimplicit_int, NULL, value,\n+\t\t\t\t c_family_lang_mask, kind, handlers);\n       if (warn_implicit_function_declaration == -1)\n-\thandle_option (OPT_Wimplicit_function_declaration, NULL, value,\n-\t\t       c_family_lang_mask, kind, handlers);\n+\thandle_generated_option (OPT_Wimplicit_function_declaration, NULL,\n+\t\t\t\t value, c_family_lang_mask, kind, handlers);\n       break;\n \n     case OPT_Wimport:"}, {"sha": "6125dfae44d4efc278d3efa1d9242750be237469", "filename": "gcc/opts-common.c", "status": "modified", "additions": 65, "deletions": 15, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481e1176d7614dcd519e50c488a155312280913e/gcc%2Fopts-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481e1176d7614dcd519e50c488a155312280913e/gcc%2Fopts-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts-common.c?ref=481e1176d7614dcd519e50c488a155312280913e", "patch": "@@ -496,17 +496,19 @@ prune_options (int *argcp, char ***argvp)\n   free (options);\n }\n \n-/* Handle option OPT_INDEX, and argument ARG, for the language\n-   indicated by LANG_MASK, using the handlers in HANDLERS.  VALUE is\n-   the option value as for the value field of cl_decoded_option.  KIND\n-   is the diagnostic_t if this is a diagnostics option, DK_UNSPECIFIED\n-   otherwise.  Returns false if the switch was invalid.  */\n+/* Handle option DECODED for the language indicated by LANG_MASK,\n+   using the handlers in HANDLERS.  KIND is the diagnostic_t if this\n+   is a diagnostics option, DK_UNSPECIFIED otherwise.  Returns false\n+   if the switch was invalid.  */\n \n bool\n-handle_option (size_t opt_index, const char *arg, int value,\n+handle_option (const struct cl_decoded_option *decoded,\n \t       unsigned int lang_mask, int kind,\n \t       const struct cl_option_handlers *handlers)\n {\n+  size_t opt_index = decoded->opt_index;\n+  const char *arg = decoded->arg;\n+  int value = decoded->value;\n   const struct cl_option *option = &cl_options[opt_index];\n   size_t i;\n \n@@ -516,17 +518,68 @@ handle_option (size_t opt_index, const char *arg, int value,\n   for (i = 0; i < handlers->num_handlers; i++)\n     if (option->flags & handlers->handlers[i].mask)\n       {\n-\tif (!handlers->handlers[i].handler (opt_index, arg, value,\n+\tif (!handlers->handlers[i].handler (decoded,\n \t\t\t\t\t    lang_mask, kind, handlers))\n \t  return false;\n \telse\n-\t  handlers->post_handling_callback (opt_index, arg, value,\n+\t  handlers->post_handling_callback (decoded,\n \t\t\t\t\t    handlers->handlers[i].mask);\n       }\n   \n   return true;\n }\n \n+/* Like handle_option, but OPT_INDEX, ARG and VALUE describe the\n+   option instead of DECODED.  This is used for callbacks when one\n+   option implies another instead of an option being decoded from the\n+   command line.  */\n+\n+bool\n+handle_generated_option (size_t opt_index, const char *arg, int value,\n+\t\t\t unsigned int lang_mask, int kind,\n+\t\t\t const struct cl_option_handlers *handlers)\n+{\n+  const struct cl_option *option = &cl_options[opt_index];\n+  struct cl_decoded_option decoded;\n+\n+  decoded.opt_index = opt_index;\n+  decoded.arg = arg;\n+  decoded.canonical_option[2] = NULL;\n+  decoded.canonical_option[3] = NULL;\n+  decoded.value = value;\n+  decoded.errors = 0;\n+\n+  if (arg)\n+    {\n+      if (option->flags & CL_SEPARATE)\n+\t{\n+\t  decoded.orig_option_with_args_text = concat (option->opt_text, \" \",\n+\t\t\t\t\t\t       arg, NULL);\n+\t  decoded.canonical_option[0] = option->opt_text;\n+\t  decoded.canonical_option[1] = arg;\n+\t  decoded.canonical_option_num_elements = 2;\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (option->flags & CL_JOINED);\n+\t  decoded.orig_option_with_args_text = concat (option->opt_text, arg,\n+\t\t\t\t\t\t       NULL);\n+\t  decoded.canonical_option[0] = decoded.orig_option_with_args_text;\n+\t  decoded.canonical_option[1] = NULL;\n+\t  decoded.canonical_option_num_elements = 1;\n+\t}\n+    }\n+  else\n+    {\n+      decoded.orig_option_with_args_text = option->opt_text;\n+      decoded.canonical_option[0] = option->opt_text;\n+      decoded.canonical_option[1] = NULL;\n+      decoded.canonical_option_num_elements = 1;\n+    }\n+\n+  return handle_option (&decoded, lang_mask, kind, handlers);\n+}\n+\n /* Handle the switch DECODED for the language indicated by LANG_MASK,\n    using the handlers in *HANDLERS.  */\n \n@@ -540,10 +593,8 @@ read_cmdline_option (struct cl_decoded_option *decoded,\n \n   if (decoded->opt_index == OPT_SPECIAL_unknown)\n     {\n-      opt = decoded->arg;\n-\n-      if (handlers->unknown_option_callback (opt))\n-\terror (\"unrecognized command line option %qs\", opt);\n+      if (handlers->unknown_option_callback (decoded))\n+\terror (\"unrecognized command line option %qs\", decoded->arg);\n       return;\n     }\n \n@@ -559,7 +610,7 @@ read_cmdline_option (struct cl_decoded_option *decoded,\n \n   if (decoded->errors & CL_ERR_WRONG_LANG)\n     {\n-      handlers->wrong_lang_callback (opt, option, lang_mask);\n+      handlers->wrong_lang_callback (decoded, lang_mask);\n       return;\n     }\n \n@@ -581,8 +632,7 @@ read_cmdline_option (struct cl_decoded_option *decoded,\n \n   gcc_assert (!decoded->errors);\n \n-  if (!handle_option (decoded->opt_index, decoded->arg, decoded->value,\n-\t\t      lang_mask, DK_UNSPECIFIED, handlers))\n+  if (!handle_option (decoded, lang_mask, DK_UNSPECIFIED, handlers))\n     error (\"unrecognized command line option %qs\", opt);\n }\n "}, {"sha": "6e5280587500b0cbc33b16d615ac9e76187c94b0", "filename": "gcc/opts.c", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481e1176d7614dcd519e50c488a155312280913e/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481e1176d7614dcd519e50c488a155312280913e/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=481e1176d7614dcd519e50c488a155312280913e", "patch": "@@ -372,12 +372,12 @@ bool flag_warn_unused_result = false;\n const char **in_fnames;\n unsigned num_in_fnames;\n \n-static bool common_handle_option (size_t scode, const char *arg, int value,\n+static bool common_handle_option (const struct cl_decoded_option *decoded,\n \t\t\t\t  unsigned int lang_mask, int kind,\n \t\t\t\t  const struct cl_option_handlers *handlers);\n static void handle_param (const char *);\n static char *write_langs (unsigned int lang_mask);\n-static void complain_wrong_lang (const char *, const struct cl_option *,\n+static void complain_wrong_lang (const struct cl_decoded_option *,\n \t\t\t\t unsigned int lang_mask);\n static void set_debug_level (enum debug_info_type type, int extended,\n \t\t\t     const char *arg);\n@@ -410,11 +410,14 @@ write_langs (unsigned int mask)\n   return result;\n }\n \n-/* Complain that switch OPT_INDEX does not apply to this front end.  */\n+/* Complain that switch DECODED does not apply to this front end (mask\n+   LANG_MASK).  */\n static void\n-complain_wrong_lang (const char *text, const struct cl_option *option,\n+complain_wrong_lang (const struct cl_decoded_option *decoded,\n \t\t     unsigned int lang_mask)\n {\n+  const struct cl_option *option = &cl_options[decoded->opt_index];\n+  const char *text = decoded->orig_option_with_args_text;\n   char *ok_langs, *bad_lang;\n \n   if (!lang_hooks.complain_wrong_lang_p (option))\n@@ -461,12 +464,14 @@ void print_ignored_options (void)\n   input_location = saved_loc;\n }\n \n-/* Handle an unknown option ARG, returning true if an error should be\n+/* Handle an unknown option DECODED, returning true if an error should be\n    given.  */\n \n static bool\n-unknown_option_callback (const char *opt)\n+unknown_option_callback (const struct cl_decoded_option *decoded)\n {\n+  const char *opt = decoded->arg;\n+\n   if (opt[1] == 'W' && opt[2] == 'n' && opt[3] == 'o' && opt[4] == '-')\n     {\n       /* We don't generate warnings for unknown -Wno-* options unless\n@@ -478,41 +483,44 @@ unknown_option_callback (const char *opt)\n     return true;\n }\n \n-/* Note that an option (index OPT_INDEX, argument ARG, value VALUE)\n-   has been successfully handled with a handler for mask MASK.  */\n+/* Note that an option DECODED has been successfully handled with a\n+   handler for mask MASK.  */\n \n static void\n-post_handling_callback (size_t opt_index ATTRIBUTE_UNUSED,\n-\t\t\tconst char *arg ATTRIBUTE_UNUSED,\n-\t\t\tint value ATTRIBUTE_UNUSED,\n+post_handling_callback (const struct cl_decoded_option *decoded ATTRIBUTE_UNUSED,\n \t\t\tunsigned int mask ATTRIBUTE_UNUSED)\n {\n #ifdef ENABLE_LTO\n-  lto_register_user_option (opt_index, arg, value, mask);\n+  lto_register_user_option (decoded->opt_index, decoded->arg,\n+\t\t\t    decoded->value, mask);\n #endif\n }\n \n /* Handle a front-end option; arguments and return value as for\n    handle_option.  */\n \n static bool\n-lang_handle_option (size_t opt_index, const char *arg, int value,\n+lang_handle_option (const struct cl_decoded_option *decoded,\n \t\t    unsigned int lang_mask ATTRIBUTE_UNUSED, int kind,\n \t\t    const struct cl_option_handlers *handlers)\n {\n-  return lang_hooks.handle_option (opt_index, arg, value, kind, handlers);\n+  gcc_assert (decoded->canonical_option_num_elements <= 2);\n+  return lang_hooks.handle_option (decoded->opt_index, decoded->arg,\n+\t\t\t\t   decoded->value, kind, handlers);\n }\n \n /* Handle a back-end option; arguments and return value as for\n    handle_option.  */\n \n static bool\n-target_handle_option (size_t opt_index, const char *arg, int value,\n-\t\t    unsigned int lang_mask ATTRIBUTE_UNUSED, int kind,\n-\t\t    const struct cl_option_handlers *handlers ATTRIBUTE_UNUSED)\n+target_handle_option (const struct cl_decoded_option *decoded,\n+\t\t      unsigned int lang_mask ATTRIBUTE_UNUSED, int kind,\n+\t\t      const struct cl_option_handlers *handlers ATTRIBUTE_UNUSED)\n {\n+  gcc_assert (decoded->canonical_option_num_elements <= 2);\n   gcc_assert (kind == DK_UNSPECIFIED);\n-  return targetm.handle_option (opt_index, arg, value);\n+  return targetm.handle_option (decoded->opt_index, decoded->arg,\n+\t\t\t\tdecoded->value);\n }\n \n /* Handle FILENAME from the command line.  */\n@@ -1387,16 +1395,21 @@ print_specific_help (unsigned int include_flags,\n /* Handle target- and language-independent options.  Return zero to\n    generate an \"unknown option\" message.  Only options that need\n    extra handling need to be listed here; if you simply want\n-   VALUE assigned to a variable, it happens automatically.  */\n+   DECODED->value assigned to a variable, it happens automatically.  */\n \n static bool\n-common_handle_option (size_t scode, const char *arg, int value,\n+common_handle_option (const struct cl_decoded_option *decoded,\n \t\t      unsigned int lang_mask, int kind ATTRIBUTE_UNUSED,\n \t\t      const struct cl_option_handlers *handlers)\n {\n+  size_t scode = decoded->opt_index;\n+  const char *arg = decoded->arg;\n+  int value = decoded->value;\n   static bool verbose = false;\n   enum opt_code code = (enum opt_code) scode;\n \n+  gcc_assert (decoded->canonical_option_num_elements <= 2);\n+\n   switch (code)\n     {\n     case OPT__param:\n@@ -2358,8 +2371,8 @@ enable_warning_as_error (const char *arg, int value, unsigned int lang_mask,\n \n \t  /* -Werror=foo implies -Wfoo.  */\n \t  if (option->var_type == CLVC_BOOLEAN)\n-\t    handle_option (option_index, arg, value, lang_mask, (int)kind,\n-\t\t\t   handlers);\n+\t    handle_generated_option (option_index, NULL, value, lang_mask,\n+\t\t\t\t     (int)kind, handlers);\n \n \t  if (warning_as_error_callback)\n \t    warning_as_error_callback (option_index);"}, {"sha": "d6412c3035d444e396183790b341665b318d6134", "filename": "gcc/opts.h", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481e1176d7614dcd519e50c488a155312280913e/gcc%2Fopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481e1176d7614dcd519e50c488a155312280913e/gcc%2Fopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.h?ref=481e1176d7614dcd519e50c488a155312280913e", "patch": "@@ -142,7 +142,7 @@ struct cl_decoded_option\n struct cl_option_handler_func\n {\n   /* The function called to handle the option.  */\n-  bool (*handler) (size_t opt_index, const char *arg, int value,\n+  bool (*handler) (const struct cl_decoded_option *decoded,\n \t\t   unsigned int lang_mask, int kind,\n \t\t   const struct cl_option_handlers *handlers);\n \n@@ -159,17 +159,16 @@ struct cl_option_handlers\n      error for it, and possibly store information to diagnose the\n      option at a later point.  Return true if an error should be\n      given, false otherwise.  */\n-  bool (*unknown_option_callback) (const char *opt);\n+  bool (*unknown_option_callback) (const struct cl_decoded_option *decoded);\n \n   /* Callback to handle, and possibly diagnose, an option for another\n      language.  */\n-  void (*wrong_lang_callback) (const char *text,\n-\t\t\t       const struct cl_option *option,\n+  void (*wrong_lang_callback) (const struct cl_decoded_option *decoded,\n \t\t\t       unsigned int lang_mask);\n \n   /* Callback to call after the successful handling of any option.  */\n-  void (*post_handling_callback) (size_t opt_index, const char *arg,\n-\t\t\t\t  int value, unsigned int mask);\n+  void (*post_handling_callback) (const struct cl_decoded_option *decoded,\n+\t\t\t\t  unsigned int mask);\n \n   /* The number of individual handlers.  */\n   size_t num_handlers;\n@@ -200,9 +199,12 @@ extern void decode_options (unsigned int argc, const char **argv,\n extern int option_enabled (int opt_idx);\n extern bool get_option_state (int, struct cl_option_state *);\n extern void set_option (int opt_index, int value, const char *arg, int);\n-bool handle_option (size_t opt_index, const char *arg, int value,\n+bool handle_option (const struct cl_decoded_option *decoded,\n \t\t    unsigned int lang_mask, int kind,\n \t\t    const struct cl_option_handlers *handlers);\n+bool handle_generated_option (size_t opt_index, const char *arg, int value,\n+\t\t\t      unsigned int lang_mask, int kind,\n+\t\t\t      const struct cl_option_handlers *handlers);\n extern void read_cmdline_option (struct cl_decoded_option *decoded,\n \t\t\t\t unsigned int lang_mask,\n \t\t\t\t const struct cl_option_handlers *handlers);"}]}