{"sha": "dba6874f46dba090fba16254dc0163e204904899", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJhNjg3NGY0NmRiYTA5MGZiYTE2MjU0ZGMwMTYzZTIwNDkwNDg5OQ==", "commit": {"author": {"name": "Jim Meyering", "email": "meyering@gcc.gnu.org", "date": "1993-05-11T23:23:34Z"}, "committer": {"name": "Jim Meyering", "email": "meyering@gcc.gnu.org", "date": "1993-05-11T23:23:34Z"}, "message": "Initial revision\n\nFrom-SVN: r4427", "tree": {"sha": "c3452ed0799cc01ca9875b9880da3b1e64d36ae8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3452ed0799cc01ca9875b9880da3b1e64d36ae8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dba6874f46dba090fba16254dc0163e204904899", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dba6874f46dba090fba16254dc0163e204904899", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dba6874f46dba090fba16254dc0163e204904899", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dba6874f46dba090fba16254dc0163e204904899/comments", "author": null, "committer": null, "parents": [{"sha": "17d47597a772387033e651e13476b2f16db243a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17d47597a772387033e651e13476b2f16db243a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17d47597a772387033e651e13476b2f16db243a1"}], "stats": {"total": 466, "additions": 466, "deletions": 0}, "files": [{"sha": "b83b35d277b839e413ca3e136b34ce4ed7e680c2", "filename": "gcc/alloca.c", "status": "added", "additions": 466, "deletions": 0, "changes": 466, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dba6874f46dba090fba16254dc0163e204904899/gcc%2Falloca.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dba6874f46dba090fba16254dc0163e204904899/gcc%2Falloca.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloca.c?ref=dba6874f46dba090fba16254dc0163e204904899", "patch": "@@ -0,0 +1,466 @@\n+/* alloca.c -- allocate automatically reclaimed memory\n+   (Mostly) portable public-domain implementation -- D A Gwyn\n+\n+   This implementation of the PWB library alloca function,\n+   which is used to allocate space off the run-time stack so\n+   that it is automatically reclaimed upon procedure exit,\n+   was inspired by discussions with J. Q. Johnson of Cornell.\n+   J.Otto Tennant <jot@cray.com> contributed the Cray support.\n+\n+   There are some preprocessor constants that can\n+   be defined when compiling for your specific system, for\n+   improved efficiency; however, the defaults should be okay.\n+\n+   The general concept of this implementation is to keep\n+   track of all alloca-allocated blocks, and reclaim any\n+   that are found to be deeper in the stack than the current\n+   invocation.  This heuristic does not reclaim storage as\n+   soon as it becomes invalid, but it will do so eventually.\n+\n+   As a special case, alloca(0) reclaims storage without\n+   allocating any.  It is a good idea to use alloca(0) in\n+   your main control loop, etc. to force garbage collection.  */\n+\n+#ifdef HAVE_CONFIG_H\n+#include \"config.h\"\n+#endif\n+\n+/* If compiling with GCC, this file's not needed.  */\n+#ifndef alloca\n+\n+#ifdef emacs\n+#ifdef static\n+/* actually, only want this if static is defined as \"\"\n+   -- this is for usg, in which emacs must undefine static\n+   in order to make unexec workable\n+   */\n+#ifndef STACK_DIRECTION\n+you\n+lose\n+-- must know STACK_DIRECTION at compile-time\n+#endif /* STACK_DIRECTION undefined */\n+#endif /* static */\n+#endif /* emacs */\n+\n+#ifdef emacs\n+#define free xfree\n+#endif\n+\n+/* If your stack is a linked list of frames, you have to\n+   provide an \"address metric\" ADDRESS_FUNCTION macro.  */\n+\n+#ifdef CRAY\n+long i00afunc ();\n+#define ADDRESS_FUNCTION(arg) (char *) i00afunc (&(arg))\n+#else\n+#define ADDRESS_FUNCTION(arg) &(arg)\n+#endif\n+\n+#if __STDC__\n+typedef void *pointer;\n+#else\n+typedef char *pointer;\n+#endif\n+\n+#define\tNULL\t0\n+\n+extern pointer xmalloc ();\n+\n+/* Define STACK_DIRECTION if you know the direction of stack\n+   growth for your system; otherwise it will be automatically\n+   deduced at run-time.\n+\n+   STACK_DIRECTION > 0 => grows toward higher addresses\n+   STACK_DIRECTION < 0 => grows toward lower addresses\n+   STACK_DIRECTION = 0 => direction of growth unknown  */\n+\n+#ifndef STACK_DIRECTION\n+#define\tSTACK_DIRECTION\t0\t/* Direction unknown.  */\n+#endif\n+\n+#if STACK_DIRECTION != 0\n+\n+#define\tSTACK_DIR\tSTACK_DIRECTION\t/* Known at compile-time.  */\n+\n+#else /* STACK_DIRECTION == 0; need run-time code.  */\n+\n+static int stack_dir;\t\t/* 1 or -1 once known.  */\n+#define\tSTACK_DIR\tstack_dir\n+\n+static void\n+find_stack_direction ()\n+{\n+  static char *addr = NULL;\t/* Address of first `dummy', once known.  */\n+  auto char dummy;\t\t/* To get stack address.  */\n+\n+  if (addr == NULL)\n+    {\t\t\t\t/* Initial entry.  */\n+      addr = ADDRESS_FUNCTION (dummy);\n+\n+      find_stack_direction ();\t/* Recurse once.  */\n+    }\n+  else\n+    {\n+      /* Second entry.  */\n+      if (ADDRESS_FUNCTION (dummy) > addr)\n+\tstack_dir = 1;\t\t/* Stack grew upward.  */\n+      else\n+\tstack_dir = -1;\t\t/* Stack grew downward.  */\n+    }\n+}\n+\n+#endif /* STACK_DIRECTION == 0 */\n+\n+/* An \"alloca header\" is used to:\n+   (a) chain together all alloca'ed blocks;\n+   (b) keep track of stack depth.\n+\n+   It is very important that sizeof(header) agree with malloc\n+   alignment chunk size.  The following default should work okay.  */\n+\n+#ifndef\tALIGN_SIZE\n+#define\tALIGN_SIZE\tsizeof(double)\n+#endif\n+\n+typedef union hdr\n+{\n+  char align[ALIGN_SIZE];\t/* To force sizeof(header).  */\n+  struct\n+    {\n+      union hdr *next;\t\t/* For chaining headers.  */\n+      char *deep;\t\t/* For stack depth measure.  */\n+    } h;\n+} header;\n+\n+static header *last_alloca_header = NULL;\t/* -> last alloca header.  */\n+\n+/* Return a pointer to at least SIZE bytes of storage,\n+   which will be automatically reclaimed upon exit from\n+   the procedure that called alloca.  Originally, this space\n+   was supposed to be taken from the current stack frame of the\n+   caller, but that method cannot be made to work for some\n+   implementations of C, for example under Gould's UTX/32.  */\n+\n+pointer\n+alloca (size)\n+     unsigned size;\n+{\n+  auto char probe;\t\t/* Probes stack depth: */\n+  register char *depth = ADDRESS_FUNCTION (probe);\n+\n+#if STACK_DIRECTION == 0\n+  if (STACK_DIR == 0)\t\t/* Unknown growth direction.  */\n+    find_stack_direction ();\n+#endif\n+\n+  /* Reclaim garbage, defined as all alloca'd storage that\n+     was allocated from deeper in the stack than currently. */\n+\n+  {\n+    register header *hp;\t/* Traverses linked list.  */\n+\n+    for (hp = last_alloca_header; hp != NULL;)\n+      if ((STACK_DIR > 0 && hp->h.deep > depth)\n+\t  || (STACK_DIR < 0 && hp->h.deep < depth))\n+\t{\n+\t  register header *np = hp->h.next;\n+\n+\t  free ((pointer) hp);\t/* Collect garbage.  */\n+\n+\t  hp = np;\t\t/* -> next header.  */\n+\t}\n+      else\n+\tbreak;\t\t\t/* Rest are not deeper.  */\n+\n+    last_alloca_header = hp;\t/* -> last valid storage.  */\n+  }\n+\n+  if (size == 0)\n+    return NULL;\t\t/* No allocation required.  */\n+\n+  /* Allocate combined header + user data storage.  */\n+\n+  {\n+    register pointer new = xmalloc (sizeof (header) + size);\n+    /* Address of header.  */\n+\n+    ((header *) new)->h.next = last_alloca_header;\n+    ((header *) new)->h.deep = depth;\n+\n+    last_alloca_header = (header *) new;\n+\n+    /* User storage begins just after header.  */\n+\n+    return (pointer) ((char *) new + sizeof (header));\n+  }\n+}\n+\n+#ifdef CRAY\n+\n+#ifdef DEBUG_I00AFUNC\n+#include <stdio.h>\n+#endif\n+\n+#ifndef CRAY_STACK\n+#define CRAY_STACK\n+#ifndef CRAY2\n+/* Stack structures for CRAY-1, CRAY X-MP, and CRAY Y-MP */\n+struct stack_control_header\n+  {\n+    long shgrow:32;\t\t/* Number of times stack has grown.  */\n+    long shaseg:32;\t\t/* Size of increments to stack.  */\n+    long shhwm:32;\t\t/* High water mark of stack.  */\n+    long shsize:32;\t\t/* Current size of stack (all segments).  */\n+  };\n+\n+/* The stack segment linkage control information occurs at\n+   the high-address end of a stack segment.  (The stack\n+   grows from low addresses to high addresses.)  The initial\n+   part of the stack segment linkage control information is\n+   0200 (octal) words.  This provides for register storage\n+   for the routine which overflows the stack.  */\n+\n+struct stack_segment_linkage\n+  {\n+    long ss[0200];\t\t/* 0200 overflow words.  */\n+    long sssize:32;\t\t/* Number of words in this segment.  */\n+    long ssbase:32;\t\t/* Offset to stack base.  */\n+    long:32;\n+    long sspseg:32;\t\t/* Offset to linkage control of previous\n+\t\t\t\t   segment of stack.  */\n+    long:32;\n+    long sstcpt:32;\t\t/* Pointer to task common address block.  */\n+    long sscsnm;\t\t/* Private control structure number for\n+\t\t\t\t   microtasking.  */\n+    long ssusr1;\t\t/* Reserved for user.  */\n+    long ssusr2;\t\t/* Reserved for user.  */\n+    long sstpid;\t\t/* Process ID for pid based multi-tasking.  */\n+    long ssgvup;\t\t/* Pointer to multitasking thread giveup.  */\n+    long sscray[7];\t\t/* Reserved for Cray Research.  */\n+    long ssa0;\n+    long ssa1;\n+    long ssa2;\n+    long ssa3;\n+    long ssa4;\n+    long ssa5;\n+    long ssa6;\n+    long ssa7;\n+    long sss0;\n+    long sss1;\n+    long sss2;\n+    long sss3;\n+    long sss4;\n+    long sss5;\n+    long sss6;\n+    long sss7;\n+  };\n+\n+#else /* CRAY2 */\n+/* The following structure defines the vector of words\n+   returned by the STKSTAT library routine.  */\n+struct stk_stat\n+  {\n+    long now;\t\t\t/* Current total stack size.  */\n+    long maxc;\t\t\t/* Amount of contiguous space which would\n+\t\t\t\t   be required to satisfy the maximum\n+\t\t\t\t   stack demand to date.  */\n+    long high_water;\t\t/* Stack high-water mark.  */\n+    long overflows;\t\t/* Number of stack overflow ($STKOFEN) calls.  */\n+    long hits;\t\t\t/* Number of internal buffer hits.  */\n+    long extends;\t\t/* Number of block extensions.  */\n+    long stko_mallocs;\t\t/* Block allocations by $STKOFEN.  */\n+    long underflows;\t\t/* Number of stack underflow calls ($STKRETN).  */\n+    long stko_free;\t\t/* Number of deallocations by $STKRETN.  */\n+    long stkm_free;\t\t/* Number of deallocations by $STKMRET.  */\n+    long segments;\t\t/* Current number of stack segments.  */\n+    long maxs;\t\t\t/* Maximum number of stack segments so far.  */\n+    long pad_size;\t\t/* Stack pad size.  */\n+    long current_address;\t/* Current stack segment address.  */\n+    long current_size;\t\t/* Current stack segment size.  This\n+\t\t\t\t   number is actually corrupted by STKSTAT to\n+\t\t\t\t   include the fifteen word trailer area.  */\n+    long initial_address;\t/* Address of initial segment.  */\n+    long initial_size;\t\t/* Size of initial segment.  */\n+  };\n+\n+/* The following structure describes the data structure which trails\n+   any stack segment.  I think that the description in 'asdef' is\n+   out of date.  I only describe the parts that I am sure about.  */\n+\n+struct stk_trailer\n+  {\n+    long this_address;\t\t/* Address of this block.  */\n+    long this_size;\t\t/* Size of this block (does not include\n+\t\t\t\t   this trailer).  */\n+    long unknown2;\n+    long unknown3;\n+    long link;\t\t\t/* Address of trailer block of previous\n+\t\t\t\t   segment.  */\n+    long unknown5;\n+    long unknown6;\n+    long unknown7;\n+    long unknown8;\n+    long unknown9;\n+    long unknown10;\n+    long unknown11;\n+    long unknown12;\n+    long unknown13;\n+    long unknown14;\n+  };\n+\n+#endif /* CRAY2 */\n+#endif /* not CRAY_STACK */\n+\n+#ifdef CRAY2\n+/* Determine a \"stack measure\" for an arbitrary ADDRESS.\n+   I doubt that \"lint\" will like this much. */\n+\n+static long\n+i00afunc (long *address)\n+{\n+  struct stk_stat status;\n+  struct stk_trailer *trailer;\n+  long *block, size;\n+  long result = 0;\n+\n+  /* We want to iterate through all of the segments.  The first\n+     step is to get the stack status structure.  We could do this\n+     more quickly and more directly, perhaps, by referencing the\n+     $LM00 common block, but I know that this works.  */\n+\n+  STKSTAT (&status);\n+\n+  /* Set up the iteration.  */\n+\n+  trailer = (struct stk_trailer *) (status.current_address\n+\t\t\t\t    + status.current_size\n+\t\t\t\t    - 15);\n+\n+  /* There must be at least one stack segment.  Therefore it is\n+     a fatal error if \"trailer\" is null.  */\n+\n+  if (trailer == 0)\n+    abort ();\n+\n+  /* Discard segments that do not contain our argument address.  */\n+\n+  while (trailer != 0)\n+    {\n+      block = (long *) trailer->this_address;\n+      size = trailer->this_size;\n+      if (block == 0 || size == 0)\n+\tabort ();\n+      trailer = (struct stk_trailer *) trailer->link;\n+      if ((block <= address) && (address < (block + size)))\n+\tbreak;\n+    }\n+\n+  /* Set the result to the offset in this segment and add the sizes\n+     of all predecessor segments.  */\n+\n+  result = address - block;\n+\n+  if (trailer == 0)\n+    {\n+      return result;\n+    }\n+\n+  do\n+    {\n+      if (trailer->this_size <= 0)\n+\tabort ();\n+      result += trailer->this_size;\n+      trailer = (struct stk_trailer *) trailer->link;\n+    }\n+  while (trailer != 0);\n+\n+  /* We are done.  Note that if you present a bogus address (one\n+     not in any segment), you will get a different number back, formed\n+     from subtracting the address of the first block.  This is probably\n+     not what you want.  */\n+\n+  return (result);\n+}\n+\n+#else /* not CRAY2 */\n+/* Stack address function for a CRAY-1, CRAY X-MP, or CRAY Y-MP.\n+   Determine the number of the cell within the stack,\n+   given the address of the cell.  The purpose of this\n+   routine is to linearize, in some sense, stack addresses\n+   for alloca.  */\n+\n+static long\n+i00afunc (long address)\n+{\n+  long stkl = 0;\n+\n+  long size, pseg, this_segment, stack;\n+  long result = 0;\n+\n+  struct stack_segment_linkage *ssptr;\n+\n+  /* Register B67 contains the address of the end of the\n+     current stack segment.  If you (as a subprogram) store\n+     your registers on the stack and find that you are past\n+     the contents of B67, you have overflowed the segment.\n+\n+     B67 also points to the stack segment linkage control\n+     area, which is what we are really interested in.  */\n+\n+  stkl = CRAY_STACKSEG_END ();\n+  ssptr = (struct stack_segment_linkage *) stkl;\n+\n+  /* If one subtracts 'size' from the end of the segment,\n+     one has the address of the first word of the segment.\n+\n+     If this is not the first segment, 'pseg' will be\n+     nonzero.  */\n+\n+  pseg = ssptr->sspseg;\n+  size = ssptr->sssize;\n+\n+  this_segment = stkl - size;\n+\n+  /* It is possible that calling this routine itself caused\n+     a stack overflow.  Discard stack segments which do not\n+     contain the target address.  */\n+\n+  while (!(this_segment <= address && address <= stkl))\n+    {\n+#ifdef DEBUG_I00AFUNC\n+      fprintf (stderr, \"%011o %011o %011o\\n\", this_segment, address, stkl);\n+#endif\n+      if (pseg == 0)\n+\tbreak;\n+      stkl = stkl - pseg;\n+      ssptr = (struct stack_segment_linkage *) stkl;\n+      size = ssptr->sssize;\n+      pseg = ssptr->sspseg;\n+      this_segment = stkl - size;\n+    }\n+\n+  result = address - this_segment;\n+\n+  /* If you subtract pseg from the current end of the stack,\n+     you get the address of the previous stack segment's end.\n+     This seems a little convoluted to me, but I'll bet you save\n+     a cycle somewhere.  */\n+\n+  while (pseg != 0)\n+    {\n+#ifdef DEBUG_I00AFUNC\n+      fprintf (stderr, \"%011o %011o\\n\", pseg, size);\n+#endif\n+      stkl = stkl - pseg;\n+      ssptr = (struct stack_segment_linkage *) stkl;\n+      size = ssptr->sssize;\n+      pseg = ssptr->sspseg;\n+      result += size;\n+    }\n+  return (result);\n+}\n+\n+#endif /* not CRAY2 */\n+#endif /* CRAY */\n+\n+#endif /* no alloca */"}]}