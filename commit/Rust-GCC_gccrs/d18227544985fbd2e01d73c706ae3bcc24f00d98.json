{"sha": "d18227544985fbd2e01d73c706ae3bcc24f00d98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE4MjI3NTQ0OTg1ZmJkMmUwMWQ3M2M3MDZhZTNiY2MyNGYwMGQ5OA==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@redhat.com", "date": "2004-06-24T02:00:25Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-06-24T02:00:25Z"}, "message": "fold-const.c (make_range): Cleanup type checking through function.\n\n2004-06-23  Eric Christopher  <echristo@redhat.com>\n\n\t* fold-const.c (make_range): Cleanup type checking through function.\n\tRemove orig_type. Replace with checks to exp_type and arg0_type.\n\tClarify comment when converting from unsigned to signed.\n\nFrom-SVN: r83576", "tree": {"sha": "957de3a0167524a08e54227f00aeb391cb8965f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/957de3a0167524a08e54227f00aeb391cb8965f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d18227544985fbd2e01d73c706ae3bcc24f00d98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d18227544985fbd2e01d73c706ae3bcc24f00d98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d18227544985fbd2e01d73c706ae3bcc24f00d98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d18227544985fbd2e01d73c706ae3bcc24f00d98/comments", "author": {"login": "echristo", "id": 327308, "node_id": "MDQ6VXNlcjMyNzMwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/327308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/echristo", "html_url": "https://github.com/echristo", "followers_url": "https://api.github.com/users/echristo/followers", "following_url": "https://api.github.com/users/echristo/following{/other_user}", "gists_url": "https://api.github.com/users/echristo/gists{/gist_id}", "starred_url": "https://api.github.com/users/echristo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/echristo/subscriptions", "organizations_url": "https://api.github.com/users/echristo/orgs", "repos_url": "https://api.github.com/users/echristo/repos", "events_url": "https://api.github.com/users/echristo/events{/privacy}", "received_events_url": "https://api.github.com/users/echristo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2ac23d05c0467d9a3b49ec8795ae783626c73914", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ac23d05c0467d9a3b49ec8795ae783626c73914", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ac23d05c0467d9a3b49ec8795ae783626c73914"}], "stats": {"total": 131, "additions": 69, "deletions": 62}, "files": [{"sha": "37889f0952732885d55830a2bae822ca432f9f2c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18227544985fbd2e01d73c706ae3bcc24f00d98/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18227544985fbd2e01d73c706ae3bcc24f00d98/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d18227544985fbd2e01d73c706ae3bcc24f00d98", "patch": "@@ -1,3 +1,9 @@\n+2004-06-23  Eric Christopher  <echristo@redhat.com>\n+\n+\t* fold-const.c (make_range): Cleanup type checking through function.\n+\tRemove orig_type. Replace with checks to exp_type and arg0_type.\n+\tClarify comment when converting from unsigned to signed.\n+\n 2004-06-23  Eric Christopher  <echristo@redhat.com>\n \n \t* config/mips/mips.c (mips_use_dfa_pipeline_interface): Add R3000."}, {"sha": "0dd5973d55d248b743fbac90e71111b218a197e3", "filename": "gcc/fold-const.c", "status": "modified", "additions": 63, "deletions": 62, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18227544985fbd2e01d73c706ae3bcc24f00d98/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18227544985fbd2e01d73c706ae3bcc24f00d98/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=d18227544985fbd2e01d73c706ae3bcc24f00d98", "patch": "@@ -2265,7 +2265,7 @@ combine_comparisons (enum tree_code code, enum tree_code lcode,\n     }\n    else if (flag_trapping_math)\n      {\n-\t/* Check that the original operation and the optimized ones will trap \n+\t/* Check that the original operation and the optimized ones will trap\n \t   under the same condition.  */\n \tbool ltrap = (lcompcode & COMPCODE_UNORD) == 0\n \t\t     && (lcompcode != COMPCODE_EQ)\n@@ -3532,8 +3532,8 @@ static tree\n make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n {\n   enum tree_code code;\n-  tree arg0 = NULL_TREE, arg1 = NULL_TREE, type = NULL_TREE;\n-  tree orig_type = NULL_TREE;\n+  tree arg0 = NULL_TREE, arg1 = NULL_TREE;\n+  tree exp_type = NULL_TREE, arg0_type = NULL_TREE;\n   int in_p, n_in_p;\n   tree low, high, n_low, n_high;\n \n@@ -3549,6 +3549,7 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n   while (1)\n     {\n       code = TREE_CODE (exp);\n+      exp_type = TREE_TYPE (exp);\n \n       if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code)))\n \t{\n@@ -3557,19 +3558,14 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t  if (TREE_CODE_CLASS (code) == '<'\n \t      || TREE_CODE_CLASS (code) == '1'\n \t      || TREE_CODE_CLASS (code) == '2')\n-\t    type = TREE_TYPE (arg0);\n+\t    arg0_type = TREE_TYPE (arg0);\n \t  if (TREE_CODE_CLASS (code) == '2'\n \t      || TREE_CODE_CLASS (code) == '<'\n \t      || (TREE_CODE_CLASS (code) == 'e'\n \t\t  && TREE_CODE_LENGTH (code) > 1))\n \t    arg1 = TREE_OPERAND (exp, 1);\n \t}\n \n-      /* Set ORIG_TYPE as soon as TYPE is non-null so that we do not\n-\t lose a cast by accident.  */\n-      if (type != NULL_TREE && orig_type == NULL_TREE)\n-\torig_type = type;\n-\n       switch (code)\n \t{\n \tcase TRUTH_NOT_EXPR:\n@@ -3612,16 +3608,15 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t      abort ();\n \t    }\n \n-\t  exp = arg0;\n-\n \t  /* If this is an unsigned comparison, we also know that EXP is\n \t     greater than or equal to zero.  We base the range tests we make\n \t     on that fact, so we record it here so we can parse existing\n-\t     range tests.  */\n-\t  if (TYPE_UNSIGNED (type) && (low == 0 || high == 0))\n+\t     range tests.  We test arg0_type since often the return type\n+\t     of, e.g. EQ_EXPR, is boolean.  */\n+\t  if (TYPE_UNSIGNED (arg0_type) && (low == 0 || high == 0))\n \t    {\n \t      if (! merge_ranges (&n_in_p, &n_low, &n_high, in_p, low, high,\n-\t\t\t\t  1, fold_convert (type, integer_zero_node),\n+\t\t\t\t  1, fold_convert (arg0_type, integer_zero_node),\n \t\t\t\t  NULL_TREE))\n \t\tbreak;\n \n@@ -3635,27 +3630,29 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t\t  in_p = ! in_p;\n \t\t  high = range_binop (MINUS_EXPR, NULL_TREE, low, 0,\n \t\t\t\t      integer_one_node, 0);\n-\t\t  low = fold_convert (type, integer_zero_node);\n+\t\t  low = fold_convert (arg0_type, integer_zero_node);\n \t\t}\n \t    }\n+\n+\t  exp = arg0;\n \t  continue;\n \n \tcase NEGATE_EXPR:\n \t  /* (-x) IN [a,b] -> x in [-b, -a]  */\n-\t  n_low = range_binop (MINUS_EXPR, type,\n-\t\t\t       fold_convert (type, integer_zero_node),\n+\t  n_low = range_binop (MINUS_EXPR, exp_type,\n+\t\t\t       fold_convert (exp_type, integer_zero_node),\n \t\t\t       0, high, 1);\n-\t  n_high = range_binop (MINUS_EXPR, type,\n-\t\t\t\tfold_convert (type, integer_zero_node),\n+\t  n_high = range_binop (MINUS_EXPR, exp_type,\n+\t\t\t\tfold_convert (exp_type, integer_zero_node),\n \t\t\t\t0, low, 0);\n \t  low = n_low, high = n_high;\n \t  exp = arg0;\n \t  continue;\n \n \tcase BIT_NOT_EXPR:\n \t  /* ~ X -> -X - 1  */\n-\t  exp = build2 (MINUS_EXPR, type, negate_expr (arg0),\n-\t\t\tfold_convert (type, integer_one_node));\n+\t  exp = build2 (MINUS_EXPR, exp_type, negate_expr (arg0),\n+\t\t\tfold_convert (exp_type, integer_one_node));\n \t  continue;\n \n \tcase PLUS_EXPR:  case MINUS_EXPR:\n@@ -3667,9 +3664,9 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t     the bounds don't overflow.  For unsigned, overflow is defined\n \t     and this is exactly the right thing.  */\n \t  n_low = range_binop (code == MINUS_EXPR ? PLUS_EXPR : MINUS_EXPR,\n-\t\t\t       type, low, 0, arg1, 0);\n+\t\t\t       arg0_type, low, 0, arg1, 0);\n \t  n_high = range_binop (code == MINUS_EXPR ? PLUS_EXPR : MINUS_EXPR,\n-\t\t\t\ttype, high, 1, arg1, 0);\n+\t\t\t\targ0_type, high, 1, arg1, 0);\n \t  if ((n_low != 0 && TREE_OVERFLOW (n_low))\n \t      || (n_high != 0 && TREE_OVERFLOW (n_high)))\n \t    break;\n@@ -3678,9 +3675,9 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t     value thus making n_high < n_low, and normalize it.  */\n \t  if (n_low && n_high && tree_int_cst_lt (n_high, n_low))\n \t    {\n-\t      low = range_binop (PLUS_EXPR, type, n_high, 0,\n+\t      low = range_binop (PLUS_EXPR, arg0_type, n_high, 0,\n \t\t\t\t integer_one_node, 0);\n-\t      high = range_binop (MINUS_EXPR, type, n_low, 0,\n+\t      high = range_binop (MINUS_EXPR, arg0_type, n_low, 0,\n \t\t\t\t  integer_one_node, 0);\n \n \t      /* If the range is of the form +/- [ x+1, x ], we won't\n@@ -3700,46 +3697,50 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t  continue;\n \n \tcase NOP_EXPR:  case NON_LVALUE_EXPR:  case CONVERT_EXPR:\n-\t  if (TYPE_PRECISION (type) > TYPE_PRECISION (orig_type))\n+\t  if (TYPE_PRECISION (arg0_type) > TYPE_PRECISION (exp_type))\n \t    break;\n \n-\t  if (! INTEGRAL_TYPE_P (type)\n-\t      || (low != 0 && ! int_fits_type_p (low, type))\n-\t      || (high != 0 && ! int_fits_type_p (high, type)))\n+\t  if (! INTEGRAL_TYPE_P (arg0_type)\n+\t      || (low != 0 && ! int_fits_type_p (low, arg0_type))\n+\t      || (high != 0 && ! int_fits_type_p (high, arg0_type)))\n \t    break;\n \n \t  n_low = low, n_high = high;\n \n \t  if (n_low != 0)\n-\t    n_low = fold_convert (type, n_low);\n+\t    n_low = fold_convert (arg0_type, n_low);\n \n \t  if (n_high != 0)\n-\t    n_high = fold_convert (type, n_high);\n+\t    n_high = fold_convert (arg0_type, n_high);\n \n-\t  /* If we're converting from an unsigned to a signed type,\n-\t     we will be doing the comparison as unsigned.  The tests above\n-\t     have already verified that LOW and HIGH are both positive.\n \n-\t     So we have to make sure that the original unsigned value will\n-\t     be interpreted as positive.  */\n-\t  if (TYPE_UNSIGNED (type) && ! TYPE_UNSIGNED (TREE_TYPE (exp)))\n+\t  /* If we're converting arg0 from an unsigned type, to exp,\n+\t     a signed type,  we will be doing the compairson as unsigned.\n+\t     The tests above have already verified that LOW and HIGH\n+\t     are both positive.\n+\n+\t     So we have to ensure that we will handle large unsigned\n+\t     values the same way that the current signed bounds treat\n+\t     negative values.  */\n+\n+\t  if (!TYPE_UNSIGNED (exp_type) && TYPE_UNSIGNED (arg0_type))\n \t    {\n-\t      tree equiv_type = lang_hooks.types.type_for_mode\n-\t\t(TYPE_MODE (type), 1);\n \t      tree high_positive;\n+\t      tree equiv_type = lang_hooks.types.type_for_mode\n+\t\t(TYPE_MODE (arg0_type), 1);\n \n \t      /* A range without an upper bound is, naturally, unbounded.\n \t\t Since convert would have cropped a very large value, use\n \t\t the max value for the destination type.  */\n \t      high_positive\n \t\t= TYPE_MAX_VALUE (equiv_type) ? TYPE_MAX_VALUE (equiv_type)\n-\t\t  : TYPE_MAX_VALUE (type);\n+\t\t: TYPE_MAX_VALUE (arg0_type);\n \n-\t      if (TYPE_PRECISION (type) == TYPE_PRECISION (TREE_TYPE (exp)))\n-\t        high_positive = fold (build2 (RSHIFT_EXPR, type,\n-\t\t\t\t\t      fold_convert (type,\n+\t      if (TYPE_PRECISION (exp_type) == TYPE_PRECISION (arg0_type))\n+\t\thigh_positive = fold (build2 (RSHIFT_EXPR, arg0_type,\n+\t\t\t\t\t      fold_convert (arg0_type,\n \t\t\t\t\t\t\t    high_positive),\n-\t\t\t\t\t      fold_convert (type,\n+\t\t\t\t\t      fold_convert (arg0_type,\n \t\t\t\t\t\t\t    integer_one_node)));\n \n \t      /* If the low bound is specified, \"and\" the range with the\n@@ -3749,7 +3750,7 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t\t{\n \t\t  if (! merge_ranges (&n_in_p, &n_low, &n_high,\n \t\t\t\t      1, n_low, n_high, 1,\n-\t\t\t\t      fold_convert (type, integer_zero_node),\n+\t\t\t\t      fold_convert (arg0_type, integer_zero_node),\n \t\t\t\t      high_positive))\n \t\t    break;\n \n@@ -3761,7 +3762,7 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t\t     that will be interpreted as negative.  */\n \t\t  if (! merge_ranges (&n_in_p, &n_low, &n_high,\n \t\t\t\t      0, n_low, n_high, 1,\n-\t\t\t\t      fold_convert (type, integer_zero_node),\n+\t\t\t\t      fold_convert (arg0_type, integer_zero_node),\n \t\t\t\t      high_positive))\n \t\t    break;\n \n@@ -5594,7 +5595,7 @@ fold_inf_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n \t not appropriate if we are in gimple form.  */\n       if (in_gimple_form)\n \treturn NULL_TREE;\n-\t\n+\n       temp = fold (build2 (neg ? LT_EXPR : GT_EXPR, type,\n \t\t\t   arg0, build_real (TREE_TYPE (arg0), max)));\n       return fold (build1 (TRUTH_NOT_EXPR, type, temp));\n@@ -5760,7 +5761,7 @@ fold_div_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n    equality/inequality test, then return a simplified form of\n    the test using shifts and logical operations.  Otherwise return\n    NULL.  TYPE is the desired result type.  */\n- \n+\n tree\n fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n \t\t      tree result_type)\n@@ -5777,7 +5778,7 @@ fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n       arg1 = TREE_OPERAND (arg0, 1);\n       arg0 = TREE_OPERAND (arg0, 0);\n \n-      /* This requires us to invert the code.  */ \n+      /* This requires us to invert the code.  */\n       code = (code == EQ_EXPR ? NE_EXPR : EQ_EXPR);\n     }\n \n@@ -5793,7 +5794,7 @@ fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n       int ops_unsigned;\n       tree signed_type, unsigned_type, intermediate_type;\n       tree arg00;\n-  \n+\n       /* If we have (A & C) != 0 where C is the sign bit of A, convert\n \t this into A < 0.  Similarly for (A & C) == 0 into A >= 0.  */\n       arg00 = sign_bit_p (TREE_OPERAND (arg0, 0), TREE_OPERAND (arg0, 1));\n@@ -5809,7 +5810,7 @@ fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n \t\t\t       fold_convert (stype, integer_zero_node)));\n \t}\n \n-      /* Otherwise we have (A & C) != 0 where C is a single bit, \n+      /* Otherwise we have (A & C) != 0 where C is a single bit,\n \t convert that into ((A >> C2) & 1).  Where C2 = log2(C).\n \t Similarly for (A & C) == 0.  */\n \n@@ -5904,7 +5905,7 @@ tree_swap_operands_p (tree arg0, tree arg1, bool reorder)\n     return 0;\n   if (TREE_CONSTANT (arg0))\n     return 1;\n-    \n+\n   if (optimize_size)\n     return 0;\n \n@@ -6890,7 +6891,7 @@ fold (tree expr)\n \t      tree mask0 = TREE_OPERAND (arg0, 1);\n \t      tree mask1 = TREE_OPERAND (arg1, 1);\n \t      tree tem = fold (build1 (BIT_NOT_EXPR, type, mask0));\n-\t      \n+\n \t      if (operand_equal_p (tem, mask1, 0))\n \t\t{\n \t\t  tem = fold (build2 (BIT_XOR_EXPR, type,\n@@ -7582,7 +7583,7 @@ fold (tree expr)\n       /* The argument to invert_truthvalue must have Boolean type.  */\n       if (TREE_CODE (TREE_TYPE (arg0)) != BOOLEAN_TYPE)\n           arg0 = fold_convert (boolean_type_node, arg0);\n-      \n+\n       /* Note that the operand of this must be an int\n \t and its values must be 0 or 1.\n \t (\"true\" is a fixed value perhaps depending on the language,\n@@ -7953,7 +7954,7 @@ fold (tree expr)\n \t}\n \n       /* Comparisons with the highest or lowest possible integer of\n-\t the specified size will have known values. \n+\t the specified size will have known values.\n \n \t This is quite similar to fold_relational_hi_lo; however, my\n \t attempts to share the code have been nothing but trouble.\n@@ -9802,7 +9803,7 @@ nondestructive_fold_binary_to_constant (enum tree_code code, tree type,\n \t  return tem;\n \t}\n       return NULL_TREE;\n-      \n+\n     case MINUS_EXPR:\n       /* Fold &x - &x.  This can happen from &x.foo - &x.\n          This is unsafe for certain floats even in non-IEEE formats.\n@@ -9834,7 +9835,7 @@ nondestructive_fold_binary_to_constant (enum tree_code code, tree type,\n \treturn omit_one_operand (type, op1, op0);\n \n       goto binary;\n-\t\n+\n     case TRUNC_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n     case FLOOR_DIV_EXPR:\n@@ -10013,7 +10014,7 @@ nondestructive_fold_binary_to_constant (enum tree_code code, tree type,\n \n /* Given the components of a unary expression CODE, TYPE and OP0,\n    attempt to fold the expression to a constant without modifying\n-   TYPE or OP0. \n+   TYPE or OP0.\n \n    If the expression could be simplified to a constant, then return\n    the constant.  If the expression would not be simplified to a\n@@ -10113,7 +10114,7 @@ fold_read_from_constant_string (tree exp)\n \t{\n \t  tree low_bound = array_ref_low_bound (exp);\n \t  index = fold_convert (sizetype, TREE_OPERAND (exp, 1));\n-\t  \n+\n \t  /* Optimize the special-case of a zero lower bound.\n \n \t     We convert the low_bound to sizetype to avoid some problems\n@@ -10173,7 +10174,7 @@ fold_negate_const (tree arg0, tree type)\n   else\n     abort ();\n #endif\n-    \n+\n   return t;\n }\n \n@@ -10226,7 +10227,7 @@ fold_abs_const (tree arg0, tree type)\n   else\n     abort ();\n #endif\n-    \n+\n   return t;\n }\n \n@@ -10251,7 +10252,7 @@ fold_not_const (tree arg0, tree type)\n   else\n     abort ();\n #endif\n-    \n+\n   return t;\n }\n "}]}