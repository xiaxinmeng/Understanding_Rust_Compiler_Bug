{"sha": "10f26de9155b71a2bd5055060004420939cf7a2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBmMjZkZTkxNTViNzFhMmJkNTA1NTA2MDAwNDQyMDkzOWNmN2EyZA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-04-05T16:56:09Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-04-05T16:56:09Z"}, "message": "PR libstdc++/87431 re-adjust never-valueless optimizations\n\nAvoid creating arbitrarily large objects on the stack when emplacing\ntrivially copyable objects into a variant. Currently we provide the\nstrong exception-safety guarantee for all trivially copyable types, by\nconstructing a second variant and then doing a non-throwing move\nassignment from the temporary. This patch restricts that behaviour to\ntrivially copyable types that are no larger than 256 bytes. For larger\ntypes the object will be emplaced directly into the variant, and if its\ninitialization throws then the variant becomes valueless.\n\nAlso implement Antony Polukhin's suggestion to whitelist specific types\nthat are not trivially copyable but can be efficiently move-assigned.\nEmplacing those types will never cause a variant to become valueless.\nThe whitelisted types are: std::shared_ptr, std::weak_ptr,\nstd::unique_ptr, std::function, and std::any. Additionally,\nstd::basic_string, std::vector, and __gnu_debug::vector are whitelisted\nif their allocator traits give them a non-throwing move assignment\noperator. Specifically, this means std::string is whitelisted, but\nstd::pmr::string is not.\n\nAs part of this patch, additional if-constexpr branches are added for\nthe cases where the initialization is known to be non-throwing (so the\noverhead of the try-catch block can be avoided) and where a scalar is\nbeing produced by a potentially-throwing conversion operator (so that\nthe overhead of constructing and move-assigning a variant is avoided).\nThese changes should have no semantic effect, just better codegen.\n\n\tPR libstdc++/87431 (again)\n\t* include/bits/basic_string.h (__variant::_Never_valueless_alt):\n\tDefine partial specialization for basic_string.\n\t* include/bits/shared_ptr.h (_Never_valueless_alt): Likewise for\n\tshared_ptr and weak_ptr.\n\t* include/bits/std_function.h (_Never_valueless_alt): Likewise for\n\tfunction.\n\t* include/bits/stl_vector.h (_Never_valueless_alt): Likewise for\n\tvector.\n\t* include/bits/unique_ptr.h (_Never_valueless_alt): Likewise for\n\tunique_ptr.\n\t* include/debug/vector (_Never_valueless_alt): Likewise for debug\n\tvector.\n\t* include/std/any (_Never_valueless_alt): Define explicit\n\tspecialization for any.\n\t* include/std/variant (_Never_valueless_alt): Define primary template.\n\t(__never_valueless): Use _Never_valueless_alt instead of\n\tis_trivially_copyable.\n\t(variant::emplace<N>(Args&&...)): Add special case for non-throwing\n\tinitializations to avoid try-catch overhead. Add special case for\n\tscalars produced by potentially-throwing conversions. Use\n\t_Never_valueless_alt instead of is_trivially_copyable for the\n\tremaining strong exception-safety cases.\n\t(variant::emplace<N>(initializer_list<U>, Args&&...)): Likewise.\n\t* testsuite/20_util/variant/87431.cc: Run both test functions.\n\t* testsuite/20_util/variant/exception_safety.cc: New test.\n\t* testsuite/20_util/variant/run.cc: Use pmr::string instead of string,\n\tso the variant becomes valueless.\n\nFrom-SVN: r270170", "tree": {"sha": "6fd2fa00ef8b06187c1b138b6560ff685cfdad65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fd2fa00ef8b06187c1b138b6560ff685cfdad65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10f26de9155b71a2bd5055060004420939cf7a2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10f26de9155b71a2bd5055060004420939cf7a2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10f26de9155b71a2bd5055060004420939cf7a2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10f26de9155b71a2bd5055060004420939cf7a2d/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34facf20abc583e66764733263f8412929f9eaf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34facf20abc583e66764733263f8412929f9eaf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34facf20abc583e66764733263f8412929f9eaf9"}], "stats": {"total": 473, "additions": 415, "deletions": 58}, "files": [{"sha": "a34428f762b8264cb469e5db88b38067ae37b73e", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=10f26de9155b71a2bd5055060004420939cf7a2d", "patch": "@@ -1,3 +1,34 @@\n+2019-04-05  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/87431 (again)\n+\t* include/bits/basic_string.h (__variant::_Never_valueless_alt):\n+\tDefine partial specialization for basic_string.\n+\t* include/bits/shared_ptr.h (_Never_valueless_alt): Likewise for\n+\tshared_ptr and weak_ptr.\n+\t* include/bits/std_function.h (_Never_valueless_alt): Likewise for\n+\tfunction.\n+\t* include/bits/stl_vector.h (_Never_valueless_alt): Likewise for\n+\tvector.\n+\t* include/bits/unique_ptr.h (_Never_valueless_alt): Likewise for\n+\tunique_ptr.\n+\t* include/debug/vector (_Never_valueless_alt): Likewise for debug\n+\tvector.\n+\t* include/std/any (_Never_valueless_alt): Define explicit\n+\tspecialization for any.\n+\t* include/std/variant (_Never_valueless_alt): Define primary template.\n+\t(__never_valueless): Use _Never_valueless_alt instead of\n+\tis_trivially_copyable.\n+\t(variant::emplace<N>(Args&&...)): Add special case for non-throwing\n+\tinitializations to avoid try-catch overhead. Add special case for\n+\tscalars produced by potentially-throwing conversions. Use\n+\t_Never_valueless_alt instead of is_trivially_copyable for the\n+\tremaining strong exception-safety cases.\n+\t(variant::emplace<N>(initializer_list<U>, Args&&...)): Likewise.\n+\t* testsuite/20_util/variant/87431.cc: Run both test functions.\n+\t* testsuite/20_util/variant/exception_safety.cc: New test.\n+\t* testsuite/20_util/variant/run.cc: Use pmr::string instead of string,\n+\tso the variant becomes valueless.\n+\n 2019-04-03  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/85184"}, {"sha": "20a56277a57dc6f3356b6cd8ecab3f6144c4535f", "filename": "libstdc++-v3/include/bits/basic_string.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h?ref=10f26de9155b71a2bd5055060004420939cf7a2d", "patch": "@@ -6800,7 +6800,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct __is_fast_hash<hash<u32string>> : std::false_type\n     { };\n \n-#if __cplusplus > 201103L\n+#if __cplusplus >= 201402L\n \n #define __cpp_lib_string_udls 201304\n \n@@ -6843,7 +6843,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   } // inline namespace string_literals\n   } // inline namespace literals\n \n-#endif // __cplusplus > 201103L\n+#if __cplusplus >= 201703L\n+  namespace __detail::__variant\n+  {\n+    template<typename> struct _Never_valueless_alt; // see <variant>\n+\n+    // Provide the strong exception-safety guarantee when emplacing a\n+    // basic_string into a variant, but only if move assignment cannot throw.\n+    template<typename _Tp, typename _Traits, typename _Alloc>\n+      struct _Never_valueless_alt<std::basic_string<_Tp, _Traits, _Alloc>>\n+      : std::is_nothrow_move_assignable<std::basic_string<_Tp, _Traits, _Alloc>>\n+      { };\n+  }  // namespace __detail::__variant\n+#endif // C++17\n+#endif // C++14\n \n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std"}, {"sha": "2d53478f1f4fd04de3e161fb2c4b7d98fde06646", "filename": "libstdc++-v3/include/bits/shared_ptr.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h?ref=10f26de9155b71a2bd5055060004420939cf7a2d", "patch": "@@ -732,6 +732,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // @} group pointer_abstractions\n \n+#if __cplusplus >= 201703L\n+  namespace __detail::__variant\n+  {\n+    template<typename> struct _Never_valueless_alt; // see <variant>\n+\n+    // Provide the strong exception-safety guarantee when emplacing a\n+    // shared_ptr into a variant.\n+    template<typename _Tp>\n+      struct _Never_valueless_alt<std::shared_ptr<_Tp>>\n+      : std::true_type\n+      { };\n+\n+    // Provide the strong exception-safety guarantee when emplacing a\n+    // weak_ptr into a variant.\n+    template<typename _Tp>\n+      struct _Never_valueless_alt<std::weak_ptr<_Tp>>\n+      : std::true_type\n+      { };\n+  }  // namespace __detail::__variant\n+#endif // C++17\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace\n "}, {"sha": "b70ed564d11a2bda4f34bcc23c3340c1fa7db17f", "filename": "libstdc++-v3/include/bits/std_function.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_function.h?ref=10f26de9155b71a2bd5055060004420939cf7a2d", "patch": "@@ -787,9 +787,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y) noexcept\n     { __x.swap(__y); }\n \n+#if __cplusplus >= 201703L\n+  namespace __detail::__variant\n+  {\n+    template<typename> struct _Never_valueless_alt; // see <variant>\n+\n+    // Provide the strong exception-safety guarantee when emplacing a\n+    // function into a variant.\n+    template<typename _Signature>\n+      struct _Never_valueless_alt<std::function<_Signature>>\n+      : std::true_type\n+      { };\n+  }  // namespace __detail::__variant\n+#endif // C++17\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n \n #endif // C++11\n-\n #endif // _GLIBCXX_STD_FUNCTION_H"}, {"sha": "dd9382d254d54c25a85901579d9173d455ecd580", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=10f26de9155b71a2bd5055060004420939cf7a2d", "patch": "@@ -1938,6 +1938,21 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     { __x.swap(__y); }\n \n _GLIBCXX_END_NAMESPACE_CONTAINER\n+\n+#if __cplusplus >= 201703L\n+  namespace __detail::__variant\n+  {\n+    template<typename> struct _Never_valueless_alt; // see <variant>\n+\n+    // Provide the strong exception-safety guarantee when emplacing a\n+    // vector into a variant, but only if move assignment cannot throw.\n+    template<typename _Tp, typename _Alloc>\n+      struct _Never_valueless_alt<_GLIBCXX_STD_C::vector<_Tp, _Alloc>>\n+      : std::is_nothrow_move_assignable<_GLIBCXX_STD_C::vector<_Tp, _Alloc>>\n+      { };\n+  }  // namespace __detail::__variant\n+#endif // C++17\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n "}, {"sha": "963e4eb7d4402b54bf186e7f7f220eaaa648c3bc", "filename": "libstdc++-v3/include/bits/unique_ptr.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h?ref=10f26de9155b71a2bd5055060004420939cf7a2d", "patch": "@@ -866,6 +866,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // @} group pointer_abstractions\n \n+#if __cplusplus >= 201703L\n+  namespace __detail::__variant\n+  {\n+    template<typename> struct _Never_valueless_alt; // see <variant>\n+\n+    // Provide the strong exception-safety guarantee when emplacing a\n+    // unique_ptr into a variant.\n+    template<typename _Tp, typename _Del>\n+      struct _Never_valueless_alt<std::unique_ptr<_Tp, _Del>>\n+      : std::true_type\n+      { };\n+  }  // namespace __detail::__variant\n+#endif // C++17\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace\n "}, {"sha": "56b5e140fd348028cc54e74f0e8af8e030342c4e", "filename": "libstdc++-v3/include/debug/vector", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector?ref=10f26de9155b71a2bd5055060004420939cf7a2d", "patch": "@@ -801,6 +801,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t _Sequence, std::random_access_iterator_tag>& __it)\n     { return std::__niter_base(__it.base()); }\n \n+#if __cplusplus >= 201703L\n+  namespace __detail::__variant\n+  {\n+    template<typename> struct _Never_valueless_alt; // see <variant>\n+\n+    // Provide the strong exception-safety guarantee when emplacing a\n+    // vector into a variant, but only if move assignment cannot throw.\n+    template<typename _Tp, typename _Alloc>\n+      struct _Never_valueless_alt<__debug::vector<_Tp, _Alloc>>\n+      : std::is_nothrow_move_assignable<__debug::vector<_Tp, _Alloc>>\n+      { };\n+  }  // namespace __detail::__variant\n+#endif // C++17\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n "}, {"sha": "b0553dccf22448025603acabd7c34d5a113b4de5", "filename": "libstdc++-v3/include/std/any", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fany", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fany", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fany?ref=10f26de9155b71a2bd5055060004420939cf7a2d", "patch": "@@ -614,9 +614,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   /// @}\n \n+  namespace __detail::__variant\n+  {\n+    template<typename> struct _Never_valueless_alt; // see <variant>\n+\n+    // Provide the strong exception-safety guarantee when emplacing an\n+    // any into a variant.\n+    template<>\n+      struct _Never_valueless_alt<std::any>\n+      : std::true_type\n+      { };\n+  }  // namespace __detail::__variant\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n \n-#endif // C++14\n-\n+#endif // C++17\n #endif // _GLIBCXX_ANY"}, {"sha": "e52aa403009ea361698e57fc4a2028b5a3fb42b4", "filename": "libstdc++-v3/include/std/variant", "status": "modified", "additions": 95, "deletions": 50, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant?ref=10f26de9155b71a2bd5055060004420939cf7a2d", "patch": "@@ -327,11 +327,31 @@ namespace __variant\n       _Variadic_union<_Rest...> _M_rest;\n     };\n \n+  // _Never_valueless_alt is true for variant alternatives that can\n+  // always be placed in a variant without it becoming valueless.\n+\n+  // For suitably-small, trivially copyable types we can create temporaries\n+  // on the stack and then memcpy them into place.\n+  template<typename _Tp>\n+    struct _Never_valueless_alt\n+    : __and_<bool_constant<sizeof(_Tp) <= 256>, is_trivially_copyable<_Tp>>\n+    { };\n+\n+  // Specialize _Never_valueless_alt for other types which have a\n+  // non-throwing and cheap move assignment operator, so that emplacing\n+  // the type will provide the strong exception-safety guarantee,\n+  // by creating and moving a temporary.\n+  // Whether _Never_valueless_alt<T> is true or not affects the ABI of a\n+  // variant using that alternative, so we can't change the value later!\n+\n+  // True if every alternative in _Types... can be emplaced in a variant\n+  // without it becoming valueless. If this is true, variant<_Types...>\n+  // can never be valueless, which enables some minor optimizations.\n   template <typename... _Types>\n-  constexpr bool __never_valueless()\n-  {\n-    return (is_trivially_copyable_v<_Types> && ...);\n-  }\n+    constexpr bool __never_valueless()\n+    {\n+      return (_Never_valueless_alt<_Types>::value && ...);\n+    }\n \n   // Defines index and the dtor, possibly trivial.\n   template<bool __trivially_destructible, typename... _Types>\n@@ -776,19 +796,19 @@ namespace __variant\n     { return __v._M_storage(); }\n \n   template <typename _Maybe_variant_cookie, typename _Variant>\n-  struct _Extra_visit_slot_needed\n-  {\n-    template <typename> struct _Variant_never_valueless;\n+    struct _Extra_visit_slot_needed\n+    {\n+      template <typename> struct _Variant_never_valueless;\n \n-    template <typename... _Types>\n-    struct _Variant_never_valueless<variant<_Types...>>\n-      : bool_constant<__never_valueless<_Types...>()> {};\n+      template <typename... _Types>\n+\tstruct _Variant_never_valueless<variant<_Types...>>\n+\t: bool_constant<__never_valueless<_Types...>()> {};\n \n-    static constexpr bool value =\n-      (is_same_v<_Maybe_variant_cookie, __variant_cookie>\n-       || is_same_v<_Maybe_variant_cookie, __variant_idx_cookie>)\n-      && !_Variant_never_valueless<__remove_cvref_t<_Variant>>::value;\n-  };\n+      static constexpr bool value =\n+\t(is_same_v<_Maybe_variant_cookie, __variant_cookie>\n+\t || is_same_v<_Maybe_variant_cookie, __variant_idx_cookie>)\n+\t&& !_Variant_never_valueless<__remove_cvref_t<_Variant>>::value;\n+    };\n \n   // Used for storing multi-dimensional vtable.\n   template<typename _Tp, size_t... _Dimensions>\n@@ -1329,31 +1349,45 @@ namespace __variant\n \t  static_assert(_Np < sizeof...(_Types),\n \t\t\t\"The index should be in [0, number of alternatives)\");\n \t  using type = variant_alternative_t<_Np, variant>;\n-\t  // If constructing the value can throw but move assigning it can't,\n-\t  // construct in a temporary and then move assign from it. This gives\n-\t  // the strong exception safety guarantee, ensuring we never become\n-\t  // valueless.\n-\t  if constexpr (is_trivially_copyable_v<type>\n-\t      && !is_nothrow_constructible_v<type, _Args...>)\n+\t  // Provide the strong exception-safety guarantee when possible,\n+\t  // to avoid becoming valueless.\n+\t  if constexpr (is_nothrow_constructible_v<type, _Args...>)\n+\t    {\n+\t      this->_M_reset();\n+\t      __variant_construct_by_index<_Np>(*this,\n+\t\t  std::forward<_Args>(__args)...);\n+\t    }\n+\t  else if constexpr (is_scalar_v<type>)\n+\t    {\n+\t      // This might invoke a potentially-throwing conversion operator:\n+\t      const type __tmp(std::forward<_Args>(__args)...);\n+\t      // But these steps won't throw:\n+\t      this->_M_reset();\n+\t      __variant_construct_by_index<_Np>(*this, __tmp);\n+\t    }\n+\t  else if constexpr (__detail::__variant::_Never_valueless_alt<type>())\n \t    {\n-\t      // If move assignment cannot throw then we can provide the\n-\t      // strong exception safety guarantee, and never become valueless.\n+\t      // This construction might throw:\n \t      variant __tmp(in_place_index<_Np>,\n \t\t\t    std::forward<_Args>(__args)...);\n+\t      // But _Never_valueless_alt<type> means this won't:\n \t      *this = std::move(__tmp);\n-\t      return std::get<_Np>(*this);\n \t    }\n-\n-\t  this->_M_reset();\n-\t  __try\n-\t    {\n-\t      __variant_construct_by_index<_Np>(*this,\n-\t        std::forward<_Args>(__args)...);\n-\t    }\n-\t  __catch (...)\n+\t  else\n \t    {\n-\t      this->_M_index = variant_npos;\n-\t      __throw_exception_again;\n+\t      // This case only provides the basic exception-safety guarantee,\n+\t      // i.e. the variant can become valueless.\n+\t      this->_M_reset();\n+\t      __try\n+\t\t{\n+\t\t  __variant_construct_by_index<_Np>(*this,\n+\t\t    std::forward<_Args>(__args)...);\n+\t\t}\n+\t      __catch (...)\n+\t\t{\n+\t\t  this->_M_index = variant_npos;\n+\t\t  __throw_exception_again;\n+\t\t}\n \t    }\n \t  return std::get<_Np>(*this);\n \t}\n@@ -1367,28 +1401,39 @@ namespace __variant\n \t  static_assert(_Np < sizeof...(_Types),\n \t\t\t\"The index should be in [0, number of alternatives)\");\n \t  using type = variant_alternative_t<_Np, variant>;\n-\t  if constexpr (is_trivially_copyable_v<type>\n-\t      && !is_nothrow_constructible_v<type, initializer_list<_Up>,\n-\t\t\t\t\t     _Args...>)\n+\t  // Provide the strong exception-safety guarantee when possible,\n+\t  // to avoid becoming valueless.\n+\t  if constexpr (is_nothrow_constructible_v<type,\n+\t\t\t\t\t\t   initializer_list<_Up>&,\n+\t\t\t\t\t\t   _Args...>)\n \t    {\n-\t      // If move assignment cannot throw then we can provide the\n-\t      // strong exception safety guarantee, and never become valueless.\n+\t      this->_M_reset();\n+\t      __variant_construct_by_index<_Np>(*this, __il,\n+\t\t  std::forward<_Args>(__args)...);\n+\t    }\n+\t  else if constexpr (__detail::__variant::_Never_valueless_alt<type>())\n+\t    {\n+\t      // This construction might throw:\n \t      variant __tmp(in_place_index<_Np>, __il,\n \t\t\t    std::forward<_Args>(__args)...);\n+\t      // But _Never_valueless_alt<type> means this won't:\n \t      *this = std::move(__tmp);\n-\t      return std::get<_Np>(*this);\n \t    }\n-\n-\t  this->_M_reset();\n-\t  __try\n-\t    {\n-\t      __variant_construct_by_index<_Np>(*this, __il,\n-\t\tstd::forward<_Args>(__args)...);\n-\t    }\n-\t  __catch (...)\n+\t  else\n \t    {\n-\t      this->_M_index = variant_npos;\n-\t      __throw_exception_again;\n+\t      // This case only provides the basic exception-safety guarantee,\n+\t      // i.e. the variant can become valueless.\n+\t      this->_M_reset();\n+\t      __try\n+\t\t{\n+\t\t  __variant_construct_by_index<_Np>(*this, __il,\n+\t\t    std::forward<_Args>(__args)...);\n+\t\t}\n+\t      __catch (...)\n+\t\t{\n+\t\t  this->_M_index = variant_npos;\n+\t\t  __throw_exception_again;\n+\t\t}\n \t    }\n \t  return std::get<_Np>(*this);\n \t}"}, {"sha": "bf92564cf926ff3dd658cded5b9d5c30e1eaba3a", "filename": "libstdc++-v3/testsuite/20_util/variant/87431.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2F87431.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2F87431.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2F87431.cc?ref=10f26de9155b71a2bd5055060004420939cf7a2d", "patch": "@@ -68,4 +68,5 @@ int\n main()\n {\n   test01();\n+  test02();\n }"}, {"sha": "7e1b0f3bed1bbf58145792652ad9b341175ee376", "filename": "libstdc++-v3/testsuite/20_util/variant/exception_safety.cc", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fexception_safety.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fexception_safety.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fexception_safety.cc?ref=10f26de9155b71a2bd5055060004420939cf7a2d", "patch": "@@ -0,0 +1,178 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+#include <variant>\n+#include <vector>\n+#include <string>\n+#include <memory_resource>\n+#include <memory>\n+#include <functional>\n+#include <any>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+#if _GLIBCXX_USE_CXX11_ABI\n+  std::variant<int, std::pmr::string, std::pmr::vector<int>> v(1);\n+  VERIFY( v.index() == 0 );\n+\n+  try\n+  {\n+    std::pmr::string s = \"how long is a piece of SSO string?\";\n+    v.emplace<1>(s, std::pmr::null_memory_resource());\n+    VERIFY( false );\n+  }\n+  catch(const std::bad_alloc&)\n+  {\n+    VERIFY( v.valueless_by_exception() );\n+  }\n+\n+  v.emplace<0>(2);\n+  VERIFY( v.index() == 0 );\n+\n+  try\n+  {\n+    v.emplace<2>({1, 2, 3}, std::pmr::null_memory_resource());\n+    VERIFY( false );\n+  }\n+  catch(const std::bad_alloc&)\n+  {\n+    VERIFY( v.valueless_by_exception() );\n+  }\n+#endif\n+}\n+\n+void\n+test02()\n+{\n+  struct X\n+  {\n+    X(int i) : i(1) { if (i > 2) throw 3; }\n+    X(std::initializer_list<int> l) : i(2) { if (l.size() > 2) throw 3; }\n+    int i;\n+  };\n+  static_assert( std::is_trivially_copyable_v<X> );\n+\n+  std::variant<std::monostate, int, X> v(111);\n+  VERIFY( v.index() == 1 );\n+\n+  try\n+  {\n+    v.emplace<X>(3);\n+    VERIFY( false );\n+  }\n+  catch(int)\n+  {\n+    VERIFY( !v.valueless_by_exception() );\n+    VERIFY( v.index() == 1 );\n+    VERIFY( std::get<int>(v) == 111 );\n+  }\n+\n+  v.emplace<X>(1);\n+  VERIFY( v.index() == 2 );\n+  VERIFY( std::get<X>(v).i == 1 );\n+\n+  try\n+  {\n+    v.emplace<X>(3);\n+    VERIFY( false );\n+  }\n+  catch(int)\n+  {\n+    VERIFY( !v.valueless_by_exception() );\n+    VERIFY( v.index() == 2 );\n+    VERIFY( std::get<X>(v).i == 1 );\n+  }\n+\n+  try\n+  {\n+    v.emplace<X>({1, 2, 3});\n+    VERIFY( false );\n+  }\n+  catch(int)\n+  {\n+    VERIFY( !v.valueless_by_exception() );\n+    VERIFY( v.index() == 2 );\n+    VERIFY( std::get<X>(v).i == 1 );\n+  }\n+}\n+\n+template<typename T, typename V>\n+  bool bad_emplace(V& v)\n+  {\n+    struct X {\n+      operator T() const { throw 1; }\n+    };\n+\n+    const auto index = v.index();\n+\n+    try\n+    {\n+      if (std::is_same_v<T, std::any>)\n+      {\n+\t// Need to test std::any differently, because emplace<std::any>(X{})\n+\t// would create a std::any with a contained X, instead of using\n+\t// X::operator any() to convert to std::any.\n+\tstruct ThrowOnCopy {\n+\t  ThrowOnCopy() { }\n+\t  ThrowOnCopy(const ThrowOnCopy&) { throw 1; }\n+\t} t;\n+\tv.template emplace<std::any>(t);\n+      }\n+      else\n+\tv.template emplace<T>(X{});\n+    }\n+    catch (int)\n+    {\n+      return v.index() == index;\n+    }\n+    return false;\n+  }\n+\n+void\n+test03()\n+{\n+  struct TriviallyCopyable { int i = 0; };\n+\n+  std::variant<std::monostate, int, TriviallyCopyable, std::optional<int>,\n+    std::string, std::vector<int>, std::function<void()>, std::any,\n+    std::shared_ptr<int>, std::weak_ptr<int>, std::unique_ptr<int>> v(1);\n+  VERIFY( v.index() == 1 );\n+\n+  VERIFY( bad_emplace<int>(v) );\n+  VERIFY( bad_emplace<TriviallyCopyable>(v) );\n+  VERIFY( bad_emplace<std::optional<int>>(v) );\n+  VERIFY( bad_emplace<std::string>(v) );\n+  VERIFY( bad_emplace<std::vector<int>>(v) );\n+  VERIFY( bad_emplace<std::function<void()>>(v) );\n+  VERIFY( bad_emplace<std::any>(v) );\n+  VERIFY( bad_emplace<std::shared_ptr<int>>(v) );\n+  VERIFY( bad_emplace<std::weak_ptr<int>>(v) );\n+  VERIFY( bad_emplace<std::unique_ptr<int>>(v) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "3ca375d374e592e8f3dd6c32835ed627fe9c5f15", "filename": "libstdc++-v3/testsuite/20_util/variant/run.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Frun.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f26de9155b71a2bd5055060004420939cf7a2d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Frun.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Frun.cc?ref=10f26de9155b71a2bd5055060004420939cf7a2d", "patch": "@@ -22,6 +22,7 @@\n #include <string>\n #include <vector>\n #include <unordered_set>\n+#include <memory_resource>\n #include <testsuite_hooks.h>\n \n using namespace std;\n@@ -376,7 +377,7 @@ void test_visit()\n \n void test_hash()\n {\n-  unordered_set<variant<int, string>> s;\n+  unordered_set<variant<int, pmr::string>> s;\n   VERIFY(s.emplace(3).second);\n   VERIFY(s.emplace(\"asdf\").second);\n   VERIFY(s.emplace().second);\n@@ -388,12 +389,12 @@ void test_hash()\n   {\n     struct A\n     {\n-      operator string()\n+      operator pmr::string()\n       {\n         throw nullptr;\n       }\n     };\n-    variant<int, string> v;\n+    variant<int, pmr::string> v;\n     try\n       {\n         v.emplace<1>(A{});"}]}