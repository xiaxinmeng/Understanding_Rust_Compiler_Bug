{"sha": "03bf2c237c6288caef6e014895f989f963b9f711", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNiZjJjMjM3YzYyODhjYWVmNmUwMTQ4OTVmOTg5Zjk2M2I5ZjcxMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-10-19T19:54:06Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-19T19:54:06Z"}, "message": "langhooks.h (LANG_HOOKS_HONOR_READONLY): New macro.\n\n\t* langhooks.h (LANG_HOOKS_HONOR_READONLY): New macro.\n\t* toplev.h (struct lang_hooks): New field HONOR_READONLY.\n\t* emit-rtl.c (set_mem_attributes): Set RTX_UNCHANGING_P from\n\tTREE_READONLY and TYPE_READONLY if lang_hooks.honor_readonly.\n\tSet alignment from type if INDIRECT_REF.\n\t(adjust_address_1, offset_address): Simplify alignment compuitation.\n\t* expr.c (expand_expr, case INDIRECT_REF): Don't set RTX_UNCHANGING_P\n\there; done by set_mem_attributes.\n\nFrom-SVN: r46361", "tree": {"sha": "eb97caf1841ebd1fecf7e7517af209b7ec0318b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb97caf1841ebd1fecf7e7517af209b7ec0318b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03bf2c237c6288caef6e014895f989f963b9f711", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03bf2c237c6288caef6e014895f989f963b9f711", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03bf2c237c6288caef6e014895f989f963b9f711", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03bf2c237c6288caef6e014895f989f963b9f711/comments", "author": null, "committer": null, "parents": [{"sha": "91ea4f8ddfb30a1274e951d43ac4d79eb5c63e9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91ea4f8ddfb30a1274e951d43ac4d79eb5c63e9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91ea4f8ddfb30a1274e951d43ac4d79eb5c63e9e"}], "stats": {"total": 56, "additions": 31, "deletions": 25}, "files": [{"sha": "0c724c34456c124d9aba05994d4ff2590345de69", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03bf2c237c6288caef6e014895f989f963b9f711/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03bf2c237c6288caef6e014895f989f963b9f711/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03bf2c237c6288caef6e014895f989f963b9f711", "patch": "@@ -1,3 +1,14 @@\n+Fri Oct 19 15:24:39 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* langhooks.h (LANG_HOOKS_HONOR_READONLY): New macro.\n+\t* toplev.h (struct lang_hooks): New field HONOR_READONLY.\n+\t* emit-rtl.c (set_mem_attributes): Set RTX_UNCHANGING_P from\n+\tTREE_READONLY and TYPE_READONLY if lang_hooks.honor_readonly.\n+\tSet alignment from type if INDIRECT_REF.\n+\t(adjust_address_1, offset_address): Simplify alignment compuitation.\n+\t* expr.c (expand_expr, case INDIRECT_REF): Don't set RTX_UNCHANGING_P\n+\there; done by set_mem_attributes.\n+\n 2001-10-19  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* Makefile.in (rtlanal.o): Depend on $(TM_P_H)."}, {"sha": "45fd406f4c981a3db66ea54e16605c0d10d2a879", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03bf2c237c6288caef6e014895f989f963b9f711/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03bf2c237c6288caef6e014895f989f963b9f711/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=03bf2c237c6288caef6e014895f989f963b9f711", "patch": "@@ -1672,13 +1672,11 @@ set_mem_attributes (ref, t, objectp)\n      front-end routine).  */\n   set_mem_alias_set (ref, get_alias_set (t));\n \n-  /* It is incorrect to set RTX_UNCHANGING_P from TREE_READONLY (type)\n-     here, because, in C and C++, the fact that a location is accessed\n-     through a const expression does not mean that the value there can\n-     never change.  */\n-\n   MEM_VOLATILE_P (ref) = TYPE_VOLATILE (type);\n   MEM_IN_STRUCT_P (ref) = AGGREGATE_TYPE_P (type);\n+  RTX_UNCHANGING_P (ref)\n+    |= (lang_hooks.honor_readonly\n+\t&& (TYPE_READONLY (type) || TREE_READONLY (t)));\n \n   /* If we are making an object of this type, we know that it is a scalar if\n      the type is not an aggregate.  */\n@@ -1717,6 +1715,10 @@ set_mem_attributes (ref, t, objectp)\n \t ? GEN_INT (tree_low_cst (TYPE_SIZE_UNIT (TREE_TYPE (t)), 1))\n \t : 0, DECL_ALIGN (t) / BITS_PER_UNIT);\n \n+  /* If this is an INDIRECT_REF, we know its alignment.  */\n+  if (TREE_CODE (t) == INDIRECT_REF)\n+    set_mem_align (ref, TYPE_ALIGN (type) / BITS_PER_UNIT);\n+\n   /* Now see if we can say more about whether it's an aggregate or\n      scalar.  If we already know it's an aggregate, don't bother.  */\n   if (MEM_IN_STRUCT_P (ref))\n@@ -1860,14 +1862,11 @@ adjust_address_1 (memref, mode, offset, validate)\n   if (memoffset)\n     memoffset = GEN_INT (offset + INTVAL (memoffset));\n \n-  /* If the offset is negative, don't try to update the alignment.  If it's\n-     zero, the alignment hasn't changed.  Otherwise, the known alignment may\n-     be less strict.  */\n-  if (offset < 0)\n-    memalign = 1;\n-\n-  while (offset > 0 && (offset % memalign) != 0)\n-    memalign >>= 1;\n+  /* Compute the new alignment by taking the MIN of the alignment and the\n+     lowest-order set bit in OFFSET, but don't change the alignment if OFFSET\n+     if zero.  */\n+  if (offset != 0)\n+    memalign = MIN (memalign, offset & -offset);\n \n   MEM_ATTRS (new)\n     = get_mem_attrs (MEM_ALIAS_SET (memref), MEM_DECL (memref), memoffset,\n@@ -1893,15 +1892,11 @@ offset_address (memref, offset, pow2)\n   rtx new = change_address_1 (memref, VOIDmode,\n \t\t\t      gen_rtx_PLUS (Pmode, XEXP (memref, 0),\n \t\t\t\t\t    force_reg (Pmode, offset)), 1);\n-  unsigned int memalign = MEM_ALIGN (memref);\n \n   /* Update the alignment to reflect the offset.  Reset the offset, which\n      we don't know.  */\n-  while (pow2 % memalign != 0)\n-    memalign >>= 1;\n-\n   MEM_ATTRS (new) = get_mem_attrs (MEM_ALIAS_SET (memref), MEM_DECL (memref),\n-\t\t\t\t   0, 0, memalign);\n+\t\t\t\t   0, 0, MIN (MEM_ALIGN (memref), pow2));\n   return new;\n }\n   "}, {"sha": "3290b39496d1abce1b1c7a5271c459e5410115f3", "filename": "gcc/expr.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03bf2c237c6288caef6e014895f989f963b9f711/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03bf2c237c6288caef6e014895f989f963b9f711/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=03bf2c237c6288caef6e014895f989f963b9f711", "patch": "@@ -6812,13 +6812,6 @@ expand_expr (exp, target, tmode, modifier)\n \ttemp = gen_rtx_MEM (mode, op0);\n \tset_mem_attributes (temp, exp, 0);\n \n-\t/* It is incorrect to set RTX_UNCHANGING_P from TREE_READONLY\n-\t   here, because, in C and C++, the fact that a location is accessed\n-\t   through a pointer to const does not mean that the value there can\n-\t   never change.  Languages where it can never change should\n-\t   also set TREE_STATIC.  */\n-\tRTX_UNCHANGING_P (temp) = TREE_READONLY (exp) & TREE_STATIC (exp);\n-\n \t/* If we are writing to this object and its type is a record with\n \t   readonly fields, we must mark it as readonly so it will\n \t   conflict with readonly references to those fields.  */"}, {"sha": "e3067fb261104db0c9e775ecabcc59cb5e228924", "filename": "gcc/langhooks.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03bf2c237c6288caef6e014895f989f963b9f711/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03bf2c237c6288caef6e014895f989f963b9f711/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=03bf2c237c6288caef6e014895f989f963b9f711", "patch": "@@ -39,6 +39,9 @@ Boston, MA 02111-1307, USA.  */\n #ifndef LANG_HOOKS_POST_OPTIONS\n #define LANG_HOOKS_POST_OPTIONS NULL\n #endif\n+#ifndef LANG_HOOKS_HONOR_READONLY\n+#define LANG_HOOKS_HONOR_READONLY 0\n+#endif\n \n /* Declarations of default tree inlining hooks.  */\n tree tree_inlining_default_hook_walk_subtrees PARAMS ((tree*, int *,\n@@ -108,6 +111,7 @@ int tree_inlining_default_hook_anon_aggr_type_p PARAMS ((tree));\n   LANG_HOOKS_INIT_OPTIONS, \\\n   LANG_HOOKS_DECODE_OPTION, \\\n   LANG_HOOKS_POST_OPTIONS, \\\n+  LANG_HOOKS_HONOR_READONLY, \\\n   LANG_HOOKS_TREE_INLINING_INITIALIZER \\\n }\n "}, {"sha": "c9b60ee2c3ed97d9df30f54fb2212b930c944cc1", "filename": "gcc/toplev.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03bf2c237c6288caef6e014895f989f963b9f711/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03bf2c237c6288caef6e014895f989f963b9f711/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=03bf2c237c6288caef6e014895f989f963b9f711", "patch": "@@ -166,6 +166,9 @@ struct lang_hooks\n   /* Called when all command line options have been processed.  */\n   void (*post_options) PARAMS ((void));\n \n+  /* Nonzero if TYPE_READONLY and TREE_READONLY should always be honored.  */\n+  int honor_readonly;\n+\n   struct lang_hooks_for_tree_inlining tree_inlining;\n \n   /* Whenever you add entries here, make sure you adjust langhooks.h"}]}