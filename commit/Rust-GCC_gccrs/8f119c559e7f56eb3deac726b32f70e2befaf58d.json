{"sha": "8f119c559e7f56eb3deac726b32f70e2befaf58d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGYxMTljNTU5ZTdmNTZlYjNkZWFjNzI2YjMyZjcwZTJiZWZhZjU4ZA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2019-11-05T09:50:39Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2019-11-05T09:50:39Z"}, "message": "Move vrp_set_zero_nonzero_bits from tree-vrp.c into vr-values.c, and make it use wi_set_zero_nonzero_bits.\n\nMove vrp_set_zero_nonzero_bits from tree-vrp.c into vr-values.c, and\nmake it use wi_set_zero_nonzero_bits.  Remove the now redundant\nwide_int_range_set_zero_nonzero_bits.\n\nFrom-SVN: r277818", "tree": {"sha": "cd490dd53c93b6b91bc8ed05f5282ad41b52ddbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd490dd53c93b6b91bc8ed05f5282ad41b52ddbb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f119c559e7f56eb3deac726b32f70e2befaf58d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f119c559e7f56eb3deac726b32f70e2befaf58d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f119c559e7f56eb3deac726b32f70e2befaf58d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f119c559e7f56eb3deac726b32f70e2befaf58d/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "16a3a930ce83bc199bdae9c7e98914783c3ef534", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16a3a930ce83bc199bdae9c7e98914783c3ef534", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16a3a930ce83bc199bdae9c7e98914783c3ef534"}], "stats": {"total": 115, "additions": 44, "deletions": 71}, "files": [{"sha": "87b108057390c044cde92417b1db209362b82d1d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f119c559e7f56eb3deac726b32f70e2befaf58d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f119c559e7f56eb3deac726b32f70e2befaf58d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8f119c559e7f56eb3deac726b32f70e2befaf58d", "patch": "@@ -1,3 +1,14 @@\n+2019-11-05  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* range-op.cc (wi_set_zero_nonzero_bits): Remove static qualifier.\n+\t* range-op.h (wi_set_zero_nonzero_bits): New prototype.\n+\t* tree-vrp.h (vrp_set_zero_nonzero_bits): Remove.\n+\t* tree-vrp.c (wide_int_range_set_zero_nonzero_bits): Remove.\n+\t(vrp_set_zero_nonzero_bits): Move to...\n+\t* vr-values.c (vr_set_zero_nonzero_bits): ...here.\n+\t(vr_values::simplify_bit_ops_using_ranges): Rename\n+\tvrp_set_zero_nonzero_bits to vr_set_zero_nonzero_bits.\n+\n 2019-11-05  Martin Liska  <mliska@suse.cz>\n \n \tPR c++/92339"}, {"sha": "56e8a20ad9e1aa019fdae72bdb8aac544f04c222", "filename": "gcc/range-op.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f119c559e7f56eb3deac726b32f70e2befaf58d/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f119c559e7f56eb3deac726b32f70e2befaf58d/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=8f119c559e7f56eb3deac726b32f70e2befaf58d", "patch": "@@ -1847,7 +1847,7 @@ wi_optimize_and_or (value_range_base &r,\n // for all numbers in the range the bit is 1, otherwise it might be 0\n // or 1.\n \n-static void\n+void\n wi_set_zero_nonzero_bits (tree type,\n \t\t\t  const wide_int &lb, const wide_int &ub,\n \t\t\t  wide_int &maybe_nonzero,"}, {"sha": "e531b9182637eaa8b64eaf1a415696fe1c4dfa32", "filename": "gcc/range-op.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f119c559e7f56eb3deac726b32f70e2befaf58d/gcc%2Frange-op.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f119c559e7f56eb3deac726b32f70e2befaf58d/gcc%2Frange-op.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.h?ref=8f119c559e7f56eb3deac726b32f70e2befaf58d", "patch": "@@ -82,7 +82,10 @@ class range_operator\n };\n \n extern range_operator *range_op_handler (enum tree_code code, tree type);\n-\n extern void range_cast (value_range_base &, tree type);\n+extern void wi_set_zero_nonzero_bits (tree type,\n+\t\t\t\t      const wide_int &, const wide_int &,\n+\t\t\t\t      wide_int &maybe_nonzero,\n+\t\t\t\t      wide_int &mustbe_nonzero);\n \n #endif // GCC_RANGE_OP_H"}, {"sha": "e1d5c7cb98cb0e922663be43921063cfe34df178", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f119c559e7f56eb3deac726b32f70e2befaf58d/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f119c559e7f56eb3deac726b32f70e2befaf58d/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=8f119c559e7f56eb3deac726b32f70e2befaf58d", "patch": "@@ -1260,69 +1260,6 @@ value_range_base::value_inside_range (tree val) const\n     return !!cmp2;\n }\n \n-/* For range [LB, UB] compute two wide_int bit masks.\n-\n-   In the MAY_BE_NONZERO bit mask, if some bit is unset, it means that\n-   for all numbers in the range the bit is 0, otherwise it might be 0\n-   or 1.\n-\n-   In the MUST_BE_NONZERO bit mask, if some bit is set, it means that\n-   for all numbers in the range the bit is 1, otherwise it might be 0\n-   or 1.  */\n-\n-static inline void\n-wide_int_range_set_zero_nonzero_bits (signop sign,\n-\t\t\t\t      const wide_int &lb, const wide_int &ub,\n-\t\t\t\t      wide_int &may_be_nonzero,\n-\t\t\t\t      wide_int &must_be_nonzero)\n-{\n-  may_be_nonzero = wi::minus_one (lb.get_precision ());\n-  must_be_nonzero = wi::zero (lb.get_precision ());\n-\n-  if (wi::eq_p (lb, ub))\n-    {\n-      may_be_nonzero = lb;\n-      must_be_nonzero = may_be_nonzero;\n-    }\n-  else if (wi::ge_p (lb, 0, sign) || wi::lt_p (ub, 0, sign))\n-    {\n-      wide_int xor_mask = lb ^ ub;\n-      may_be_nonzero = lb | ub;\n-      must_be_nonzero = lb & ub;\n-      if (xor_mask != 0)\n-\t{\n-\t  wide_int mask = wi::mask (wi::floor_log2 (xor_mask), false,\n-\t\t\t\t    may_be_nonzero.get_precision ());\n-\t  may_be_nonzero = may_be_nonzero | mask;\n-\t  must_be_nonzero = wi::bit_and_not (must_be_nonzero, mask);\n-\t}\n-    }\n-}\n-\n-/* value_range wrapper for wide_int_range_set_zero_nonzero_bits above.\n-\n-   Return TRUE if VR was a constant range and we were able to compute\n-   the bit masks.  */\n-\n-bool\n-vrp_set_zero_nonzero_bits (const tree expr_type,\n-\t\t\t   const value_range_base *vr,\n-\t\t\t   wide_int *may_be_nonzero,\n-\t\t\t   wide_int *must_be_nonzero)\n-{\n-  if (!range_int_cst_p (vr))\n-    {\n-      *may_be_nonzero = wi::minus_one (TYPE_PRECISION (expr_type));\n-      *must_be_nonzero = wi::zero (TYPE_PRECISION (expr_type));\n-      return false;\n-    }\n-  wide_int_range_set_zero_nonzero_bits (TYPE_SIGN (expr_type),\n-\t\t\t\t\twi::to_wide (vr->min ()),\n-\t\t\t\t\twi::to_wide (vr->max ()),\n-\t\t\t\t\t*may_be_nonzero, *must_be_nonzero);\n-  return true;\n-}\n-\n /* Create two value-ranges in *VR0 and *VR1 from the anti-range *AR\n    so that *VR0 U *VR1 == *AR.  Returns true if that is possible,\n    false otherwise.  If *AR can be represented with a single range"}, {"sha": "0bf33caba85cc8f8c7726ff48bacbbab23f22913", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f119c559e7f56eb3deac726b32f70e2befaf58d/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f119c559e7f56eb3deac726b32f70e2befaf58d/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=8f119c559e7f56eb3deac726b32f70e2befaf58d", "patch": "@@ -299,8 +299,6 @@ void range_fold_binary_expr (value_range_base *, enum tree_code, tree type,\n extern bool vrp_operand_equal_p (const_tree, const_tree);\n extern enum value_range_kind intersect_range_with_nonzero_bits\n   (enum value_range_kind, wide_int *, wide_int *, const wide_int &, signop);\n-extern bool vrp_set_zero_nonzero_bits (const tree, const value_range_base *,\n-\t\t\t\t       wide_int *, wide_int *);\n \n extern bool find_case_label_range (gswitch *, tree, tree, size_t *, size_t *);\n extern bool find_case_label_index (gswitch *, size_t, tree, size_t *);"}, {"sha": "d1713bf4e0ee215bed126e8e9c2806c8461200e4", "filename": "gcc/vr-values.c", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f119c559e7f56eb3deac726b32f70e2befaf58d/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f119c559e7f56eb3deac726b32f70e2befaf58d/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=8f119c559e7f56eb3deac726b32f70e2befaf58d", "patch": "@@ -3341,6 +3341,30 @@ vr_values::simplify_abs_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n   return false;\n }\n \n+/* value_range wrapper for wi_set_zero_nonzero_bits.\n+\n+   Return TRUE if VR was a constant range and we were able to compute\n+   the bit masks.  */\n+\n+static bool\n+vr_set_zero_nonzero_bits (const tree expr_type,\n+\t\t\t  const value_range_base *vr,\n+\t\t\t  wide_int *may_be_nonzero,\n+\t\t\t  wide_int *must_be_nonzero)\n+{\n+  if (range_int_cst_p (vr))\n+    {\n+      wi_set_zero_nonzero_bits (expr_type,\n+\t\t\t\twi::to_wide (vr->min ()),\n+\t\t\t\twi::to_wide (vr->max ()),\n+\t\t\t\t*may_be_nonzero, *must_be_nonzero);\n+      return true;\n+    }\n+  *may_be_nonzero = wi::minus_one (TYPE_PRECISION (expr_type));\n+  *must_be_nonzero = wi::zero (TYPE_PRECISION (expr_type));\n+  return false;\n+}\n+\n /* Optimize away redundant BIT_AND_EXPR and BIT_IOR_EXPR.\n    If all the bits that are being cleared by & are already\n    known to be zero from VR, or all the bits that are being\n@@ -3373,11 +3397,11 @@ vr_values::simplify_bit_ops_using_ranges (gimple_stmt_iterator *gsi,\n   else\n     return false;\n \n-  if (!vrp_set_zero_nonzero_bits (TREE_TYPE (op0), &vr0, &may_be_nonzero0,\n-\t\t\t\t  &must_be_nonzero0))\n+  if (!vr_set_zero_nonzero_bits (TREE_TYPE (op0), &vr0, &may_be_nonzero0,\n+\t\t\t\t &must_be_nonzero0))\n     return false;\n-  if (!vrp_set_zero_nonzero_bits (TREE_TYPE (op1), &vr1, &may_be_nonzero1,\n-\t\t\t\t  &must_be_nonzero1))\n+  if (!vr_set_zero_nonzero_bits (TREE_TYPE (op1), &vr1, &may_be_nonzero1,\n+\t\t\t\t &must_be_nonzero1))\n     return false;\n \n   switch (gimple_assign_rhs_code (stmt))"}]}