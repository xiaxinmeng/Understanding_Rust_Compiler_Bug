{"sha": "ea31c98daba7d3459dc5500049876fe0a71a89d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWEzMWM5OGRhYmE3ZDM0NTlkYzU1MDAwNDk4NzZmZTBhNzFhODlkMw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-01-21T23:05:52Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-01-21T23:05:52Z"}, "message": "libgo: fix building, and some testing, on Solaris\n    \n    Restore some of the fixes that were applied to golang_org/x/net/lif\n    but were lost when 1.12 moved the directory to internal/x/net/lif.\n    \n    Add support for reading /proc to fetch argc/argv/env for c-archive mode.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/158640\n\nFrom-SVN: r268130", "tree": {"sha": "9dc7ee584a37d93ea00455a5ec27d75fa464bf58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9dc7ee584a37d93ea00455a5ec27d75fa464bf58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea31c98daba7d3459dc5500049876fe0a71a89d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea31c98daba7d3459dc5500049876fe0a71a89d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea31c98daba7d3459dc5500049876fe0a71a89d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea31c98daba7d3459dc5500049876fe0a71a89d3/comments", "author": null, "committer": null, "parents": [{"sha": "a9647bf912b9d2eeb9297bb96d5274eb8c9ed75c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9647bf912b9d2eeb9297bb96d5274eb8c9ed75c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9647bf912b9d2eeb9297bb96d5274eb8c9ed75c"}], "stats": {"total": 155, "additions": 136, "deletions": 19}, "files": [{"sha": "8f423293d94c2782777c0e2a2e019d349313ea58", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea31c98daba7d3459dc5500049876fe0a71a89d3/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea31c98daba7d3459dc5500049876fe0a71a89d3/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=ea31c98daba7d3459dc5500049876fe0a71a89d3", "patch": "@@ -1,4 +1,4 @@\n-e7427654f3af83e1feea727a62a97172d7721403\n+0c870ba6b3b43e0e56231f40c56b58dad0e36d9e\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "b9ff88c2452f33099423ddeb71337487b1ec9c10", "filename": "libgo/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea31c98daba7d3459dc5500049876fe0a71a89d3/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea31c98daba7d3459dc5500049876fe0a71a89d3/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=ea31c98daba7d3459dc5500049876fe0a71a89d3", "patch": "@@ -1082,7 +1082,7 @@ $(eval $(call PACKAGE_template,internal/x/net/lif))\n internal_x_net_lif_lo = \\\n \tinternal/x/net/lif.lo\n internal_x_net_lif_check = \\\n-\tinternal_org/x/net/lif/check\n+\tinternal/x/net/lif/check\n \n endif\n "}, {"sha": "abda06437f737c46df7ec994bef39964e913ebff", "filename": "libgo/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea31c98daba7d3459dc5500049876fe0a71a89d3/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea31c98daba7d3459dc5500049876fe0a71a89d3/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=ea31c98daba7d3459dc5500049876fe0a71a89d3", "patch": "@@ -1131,7 +1131,7 @@ extra_check_libs_cmd_vet_internal_cfg = $(abs_builddir)/libgotool.a\n @LIBGO_IS_SOLARIS_TRUE@\tinternal/x/net/lif.lo\n \n @LIBGO_IS_SOLARIS_TRUE@internal_x_net_lif_check = \\\n-@LIBGO_IS_SOLARIS_TRUE@\tinternal_org/x/net/lif/check\n+@LIBGO_IS_SOLARIS_TRUE@\tinternal/x/net/lif/check\n \n TPACKAGES = $(shell cat $(srcdir)/check-packages.txt)\n TEST_PACKAGES = $(addsuffix /check,$(TPACKAGES)) \\"}, {"sha": "ea7541456bd7bae3947d7624cc0742e829948d45", "filename": "libgo/go/internal/x/net/lif/syscall.go", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea31c98daba7d3459dc5500049876fe0a71a89d3/libgo%2Fgo%2Finternal%2Fx%2Fnet%2Flif%2Fsyscall.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea31c98daba7d3459dc5500049876fe0a71a89d3/libgo%2Fgo%2Finternal%2Fx%2Fnet%2Flif%2Fsyscall.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fx%2Fnet%2Flif%2Fsyscall.go?ref=ea31c98daba7d3459dc5500049876fe0a71a89d3", "patch": "@@ -11,18 +11,12 @@ import (\n \t\"unsafe\"\n )\n \n-//go:cgo_import_dynamic libc_ioctl ioctl \"libc.so\"\n-\n-//go:linkname procIoctl libc_ioctl\n-\n-var procIoctl uintptr\n-\n-func sysvicall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (uintptr, uintptr, syscall.Errno)\n+//extern __go_ioctl_ptr\n+func libc_ioctl(int32, int32, unsafe.Pointer) int32\n \n func ioctl(s, ioc uintptr, arg unsafe.Pointer) error {\n-\t_, _, errno := sysvicall6(uintptr(unsafe.Pointer(&procIoctl)), 3, s, ioc, uintptr(arg), 0, 0, 0)\n-\tif errno != 0 {\n-\t\treturn error(errno)\n+\tif libc_ioctl(int32(s), int32(ioc), arg) < 0 {\n+\t\treturn syscall.GetErrno()\n \t}\n \treturn nil\n }"}, {"sha": "0d9ed2f821ae9db0c5a14744ff7bd26f84da901d", "filename": "libgo/go/internal/x/net/lif/zsys_solaris.go", "status": "renamed", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea31c98daba7d3459dc5500049876fe0a71a89d3/libgo%2Fgo%2Finternal%2Fx%2Fnet%2Flif%2Fzsys_solaris.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea31c98daba7d3459dc5500049876fe0a71a89d3/libgo%2Fgo%2Finternal%2Fx%2Fnet%2Flif%2Fzsys_solaris.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fx%2Fnet%2Flif%2Fzsys_solaris.go?ref=ea31c98daba7d3459dc5500049876fe0a71a89d3", "patch": "@@ -3,6 +3,8 @@\n \n package lif\n \n+import \"unsafe\"\n+\n const (\n \tsysAF_UNSPEC = 0x0\n \tsysAF_INET   = 0x2\n@@ -67,7 +69,6 @@ const (\n \n type lifnum struct {\n \tFamily    uint16\n-\tPad_cgo_0 [2]byte\n \tFlags     int32\n \tCount     int32\n }\n@@ -81,16 +82,13 @@ type lifreq struct {\n \n type lifconf struct {\n \tFamily    uint16\n-\tPad_cgo_0 [2]byte\n \tFlags     int32\n \tLen       int32\n-\tPad_cgo_1 [4]byte\n-\tLifcu     [8]byte\n+\tLifcu     [unsafe.Sizeof(unsafe.Pointer(nil))]byte\n }\n \n type lifIfinfoReq struct {\n \tMaxhops      uint8\n-\tPad_cgo_0    [3]byte\n \tReachtime    uint32\n \tReachretrans uint32\n \tMaxmtu       uint32", "previous_filename": "libgo/go/internal/x/net/lif/zsys_solaris_amd64.go"}, {"sha": "2f89c7cbf43eda41ec937b124a84060ca6b15f52", "filename": "libgo/go/runtime/signal_unix.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea31c98daba7d3459dc5500049876fe0a71a89d3/libgo%2Fgo%2Fruntime%2Fsignal_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea31c98daba7d3459dc5500049876fe0a71a89d3/libgo%2Fgo%2Fruntime%2Fsignal_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal_unix.go?ref=ea31c98daba7d3459dc5500049876fe0a71a89d3", "patch": "@@ -441,7 +441,10 @@ func raisebadsignal(sig uint32, c *sigctxt) {\n \t//\n \t// On FreeBSD, the libthr sigaction code prevents\n \t// this from working so we fall through to raise.\n-\tif GOOS != \"freebsd\" && (isarchive || islibrary) && handler == _SIG_DFL && c.sigcode() != _SI_USER {\n+\t//\n+\t// The argument above doesn't hold for SIGPIPE, which won't\n+\t// necessarily be re-raised if we return.\n+\tif GOOS != \"freebsd\" && (isarchive || islibrary) && handler == _SIG_DFL && c.sigcode() != _SI_USER && sig != _SIGPIPE {\n \t\treturn\n \t}\n "}, {"sha": "4f4763947e488bc6367f8fa666608e01ca638f2f", "filename": "libgo/runtime/go-libmain.c", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea31c98daba7d3459dc5500049876fe0a71a89d3/libgo%2Fruntime%2Fgo-libmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea31c98daba7d3459dc5500049876fe0a71a89d3/libgo%2Fruntime%2Fgo-libmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-libmain.c?ref=ea31c98daba7d3459dc5500049876fe0a71a89d3", "patch": "@@ -11,11 +11,129 @@\n #include <stdlib.h>\n #include <time.h>\n #include <unistd.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n \n #include \"runtime.h\"\n #include \"array.h\"\n #include \"arch.h\"\n \n+#if defined(__sun) && defined(__SVR4)\n+\n+/* Read a file into memory on Solaris, returning an malloc'ed buffer\n+   and setting *SIZE to its size.  */\n+\n+static char *\n+read_file (const char *fn, size_t *size)\n+{\n+  struct stat st;\n+  char *buf;\n+  int o;\n+  ssize_t got;\n+\n+  if (stat (fn, &st) < 0)\n+    return NULL;\n+  buf = malloc ((size_t) st.st_size);\n+  if (buf == NULL)\n+    return NULL;\n+  o = open (fn, O_RDONLY);\n+  if (o < 0)\n+    {\n+      free (buf);\n+      return NULL;\n+    }\n+  got = read (o, buf, st.st_size);\n+  close (o);\n+  if (got != st.st_size)\n+    {\n+      free (buf);\n+      return NULL;\n+    }\n+\n+  *size = (size_t) got;\n+  return buf;\n+}\n+\n+/* On Solaris we don't get passed argc/argv, but we can fetch it from\n+   /proc/PID/cmdline.  */\n+\n+static void\n+read_cmdline (int *argc, char ***argv)\n+{\n+  pid_t pid;\n+  char fn[50];\n+  char *argbuf;\n+  size_t argsize;\n+  char *envbuf;\n+  size_t envsize;\n+  char *p;\n+  int i;\n+  int ac;\n+\n+  *argc = 0;\n+  *argv = NULL;\n+\n+  pid = getpid ();\n+  snprintf (fn, sizeof fn, \"/proc/%ld/cmdline\", (long) pid);\n+  argbuf = read_file (fn, &argsize);\n+  if (argbuf == NULL)\n+    return;\n+\n+  snprintf (fn, sizeof fn, \"/proc/%ld/environ\", (long) pid);\n+  envbuf = read_file (fn, &envsize);\n+  if (envbuf == NULL)\n+    {\n+      free (argbuf);\n+      return;\n+    }\n+\n+  i = 0;\n+  for (p = argbuf; p < argbuf + argsize; p++)\n+    if (*p == '\\0')\n+      ++i;\n+  ac = i;\n+  ++i; // For trailing NULL.\n+  for (p = envbuf; p < envbuf + envsize; p++)\n+    if (*p == '\\0')\n+      ++i;\n+  ++i; // For trailing NULL.\n+\n+  *argv = (char **) malloc (i * sizeof (char *));\n+  if (*argv == NULL)\n+    {\n+      free (argbuf);\n+      free (envbuf);\n+      return;\n+    }\n+\n+  *argc = ac;\n+  (*argv)[0] = argbuf;\n+  i = 0;\n+  for (p = argbuf; p < argbuf + argsize; p++)\n+    {\n+      if (*p == '\\0')\n+\t{\n+\t  ++i;\n+\t  (*argv)[i] = p + 1;\n+\t}\n+    }\n+  (*argv)[i] = NULL;\n+  ++i;\n+  (*argv)[i] = envbuf;\n+  for (p = envbuf; p < envbuf + envsize; p++)\n+    {\n+      if (*p == '\\0')\n+\t{\n+\t  ++i;\n+\t  (*argv)[i] = p + 1;\n+\t}\n+    }\n+  (*argv)[i] = NULL;\n+}\n+\n+#endif /* defined(__sun) && defined(__SVR4) */\n+\n /* This is used when building a standalone Go library using the Go\n    command's -buildmode=c-archive or -buildmode=c-shared option.  It\n    starts up the Go code as a global constructor but does not take any\n@@ -64,6 +182,10 @@ __go_init (int argc, char **argv, char** env __attribute__ ((unused)))\n   struct args *a;\n   pthread_t tid;\n \n+#if defined(__sun) && defined(__SVR4)\n+  read_cmdline (&argc, &argv);\n+#endif\n+\n   runtime_isarchive = true;\n \n   setIsCgo ();"}]}