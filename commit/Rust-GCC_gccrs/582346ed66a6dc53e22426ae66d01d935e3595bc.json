{"sha": "582346ed66a6dc53e22426ae66d01d935e3595bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgyMzQ2ZWQ2NmE2ZGM1M2UyMjQyNmFlNjZkMDFkOTM1ZTM1OTViYw==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2010-10-20T20:15:07Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-10-20T20:15:07Z"}, "message": "ifcvt.c (noce_emit_cmove): If both of the values are SUBREGs...\n\n\t* ifcvt.c (noce_emit_cmove): If both of the values are SUBREGs, try\n\temitting the conditional move in the inner mode of the SUBREG.\n\nFrom-SVN: r165735", "tree": {"sha": "6a8239d64dc65925957fb1ccbe0060db0f992701", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a8239d64dc65925957fb1ccbe0060db0f992701"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/582346ed66a6dc53e22426ae66d01d935e3595bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/582346ed66a6dc53e22426ae66d01d935e3595bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/582346ed66a6dc53e22426ae66d01d935e3595bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/582346ed66a6dc53e22426ae66d01d935e3595bc/comments", "author": null, "committer": null, "parents": [{"sha": "ab177ad53847e22cc5aaf10ffc319060c633cc4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab177ad53847e22cc5aaf10ffc319060c633cc4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab177ad53847e22cc5aaf10ffc319060c633cc4f"}], "stats": {"total": 68, "additions": 64, "deletions": 4}, "files": [{"sha": "beed4542a945866f5d0429a9243f77e5019d6d82", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/582346ed66a6dc53e22426ae66d01d935e3595bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/582346ed66a6dc53e22426ae66d01d935e3595bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=582346ed66a6dc53e22426ae66d01d935e3595bc", "patch": "@@ -1,3 +1,8 @@\n+2010-10-20  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* ifcvt.c (noce_emit_cmove): If both of the values are SUBREGs, try\n+\temitting the conditional move in the inner mode of the SUBREG.\n+\n 2010-10-20  Anatoly Sokolov  <aesok@post.ru>\n \n \t* config/ia64/ia64.h (PREFERRED_RELOAD_CLASS): Remove macros."}, {"sha": "15f76e39e79bca014857c83c4a5044f85a01b10f", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 59, "deletions": 4, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/582346ed66a6dc53e22426ae66d01d935e3595bc/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/582346ed66a6dc53e22426ae66d01d935e3595bc/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=582346ed66a6dc53e22426ae66d01d935e3595bc", "patch": "@@ -1337,6 +1337,9 @@ static rtx\n noce_emit_cmove (struct noce_if_info *if_info, rtx x, enum rtx_code code,\n \t\t rtx cmp_a, rtx cmp_b, rtx vfalse, rtx vtrue)\n {\n+  rtx target;\n+  int unsignedp;\n+\n   /* If earliest == jump, try to build the cmove insn directly.\n      This is helpful when combine has created some complex condition\n      (like for alpha's cmovlbs) that we can't hope to regenerate\n@@ -1371,10 +1374,62 @@ noce_emit_cmove (struct noce_if_info *if_info, rtx x, enum rtx_code code,\n     return NULL_RTX;\n \n #if HAVE_conditional_move\n-  return emit_conditional_move (x, code, cmp_a, cmp_b, VOIDmode,\n-\t\t\t\tvtrue, vfalse, GET_MODE (x),\n-\t\t\t        (code == LTU || code == GEU\n-\t\t\t\t || code == LEU || code == GTU));\n+  unsignedp = (code == LTU || code == GEU\n+\t       || code == LEU || code == GTU);\n+\n+  target = emit_conditional_move (x, code, cmp_a, cmp_b, VOIDmode,\n+\t\t\t\t  vtrue, vfalse, GET_MODE (x),\n+\t\t\t\t  unsignedp);\n+  if (target)\n+    return target;\n+\n+  /* We might be faced with a situation like:\n+\n+     x = (reg:M TARGET)\n+     vtrue = (subreg:M (reg:N VTRUE) BYTE)\n+     vfalse = (subreg:M (reg:N VFALSE) BYTE)\n+\n+     We can't do a conditional move in mode M, but it's possible that we\n+     could do a conditional move in mode N instead and take a subreg of\n+     the result.\n+\n+     If we can't create new pseudos, though, don't bother.  */\n+  if (reload_completed)\n+    return NULL_RTX;\n+\n+  if (GET_CODE (vtrue) == SUBREG && GET_CODE (vfalse) == SUBREG)\n+    {\n+      rtx reg_vtrue = SUBREG_REG (vtrue);\n+      rtx reg_vfalse = SUBREG_REG (vfalse);\n+      unsigned int byte_vtrue = SUBREG_BYTE (vtrue);\n+      unsigned int byte_vfalse = SUBREG_BYTE (vfalse);\n+      rtx promoted_target;\n+\n+      if (GET_MODE (reg_vtrue) != GET_MODE (reg_vfalse)\n+\t  || byte_vtrue != byte_vfalse\n+\t  || (SUBREG_PROMOTED_VAR_P (vtrue)\n+\t      != SUBREG_PROMOTED_VAR_P (vfalse))\n+\t  || (SUBREG_PROMOTED_UNSIGNED_P (vtrue)\n+\t      != SUBREG_PROMOTED_UNSIGNED_P (vfalse)))\n+\treturn NULL_RTX;\n+\n+      promoted_target = gen_reg_rtx (GET_MODE (reg_vtrue));\n+\n+      target = emit_conditional_move (promoted_target, code, cmp_a, cmp_b,\n+\t\t\t\t      VOIDmode, reg_vtrue, reg_vfalse,\n+\t\t\t\t      GET_MODE (reg_vtrue), unsignedp);\n+      /* Nope, couldn't do it in that mode either.  */\n+      if (!target)\n+\treturn NULL_RTX;\n+\n+      target = gen_rtx_SUBREG (GET_MODE (vtrue), promoted_target, byte_vtrue);\n+      SUBREG_PROMOTED_VAR_P (target) = SUBREG_PROMOTED_VAR_P (vtrue);\n+      SUBREG_PROMOTED_UNSIGNED_SET (target, SUBREG_PROMOTED_UNSIGNED_P (vtrue));\n+      emit_move_insn (x, target);\n+      return x;\n+    }\n+  else\n+    return NULL_RTX;\n #else\n   /* We'll never get here, as noce_process_if_block doesn't call the\n      functions involved.  Ifdef code, however, should be discouraged"}]}