{"sha": "1a10bd84a5d103f6e1fdcd960f8377e3d099d773", "node_id": "C_kwDOANBUbNoAKDFhMTBiZDg0YTVkMTAzZjZlMWZkY2Q5NjBmODM3N2UzZDA5OWQ3NzM", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-07-24T17:42:11Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-07-25T06:45:21Z"}, "message": "frange class to represent floating point ranges\n\nThis implements a basic frange class to represent floating point\nranges.  Although it is meant to be a base for further development, it\nis enough to handle relations and propagate NAN and other properties.\n\nFor ranger clients to become floating point aware, we still need the\nrange-op entries, which I will submit later this week.  Since those\nentries require specialized FP knowledge, I will ask for a review from\nthe FP experts before committing.\n\nOnce range-op entries come live, all ranger clients that have been\nconverted to the type agnostic vrange API will become FP aware: evrp,\nDOM, the threaders, loop-ch, etc.  (Still missing is loop unswitching,\nas a lot of the int_range* temporaries should be Value_Range.  I don't\nhave enough cycles to convert loop unswitching, but could gladly give\nguidance.  It should be straightforward for those familiar with the\ncode ;-)).\n\nSamples things we handle:\n\n* We can set the FP properties (!NAN, !INF, etc) at assignment from\n  constants (and propagate them throughout the CFG):\n\n  float z = 0.0;\n  if (__builtin_isnan (z))\n    link_error ();\n\n* The relation oracle works in tandem with the FP ranges:\n\n      if (x > y)\n       ;\n      else if (!__builtin_isnan (x) && !__builtin_isnan (y))\n       {\n         // If x and y are not NAN, the x <= y relationship holds, and the\n         // following conditional can be folded away.\n         if (x <= y)\n           bar ();\n       }\n\n* We know the true side of all ordered conditionals (except !=)\n  implies !NAN:\n\n  if (x > y)\n    {\n      if (__builtin_isnan (x) || __builtin_isnan (y))\n        link_error ();\n    }\n\nRange-ops also works correctly with -ffinite-math-only, and avoids\nchecking for NANs, etc.\n\nI believe this is enough to get a fully fleshed out floating point\nsupport for evrp and friends, but doing so is beyond my limited FP\nknowledge.  For example, frange could be enhanced to track constant\nendpoints, and we could track other FP properties aside from NAN.\nFurther discussion is gladly welcome.\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* value-range-pretty-print.cc (vrange_printer::visit): New.\n\t(vrange_printer::print_frange_prop): New.\n\t* value-range-pretty-print.h (class vrange_printer): Add visit and\n\tprint_frange_prop.\n\t* value-range-storage.h (vrange_allocator::alloc_vrange): Handle frange.\n\t(vrange_allocator::alloc_frange): New.\n\t* value-range.cc (vrange::operator=): Handle frange.\n\t(vrange::operator==): Same.\n\t(frange::accept): New.\n\t(frange::set): New.\n\t(frange::normalize_kind): New.\n\t(frange::union_): New.\n\t(frange::intersect): New.\n\t(frange::operator=): New.\n\t(frange::operator==): New.\n\t(frange::supports_type_p): New.\n\t(frange::verify_range): New.\n\t* value-range.h (enum value_range_discriminator): Handle frange.\n\t(class fp_prop): New.\n\t(FP_PROP_ACCESSOR): New.\n\t(class frange_props): New.\n\t(FRANGE_PROP_ACCESSOR): New.\n\t(class frange): New.\n\t(Value_Range::init): Handle frange.\n\t(Value_Range::operator=): Same.\n\t(Value_Range::supports_type_p): Same.\n\t(frange_props::operator==): New.\n\t(frange_props::union_): New.\n\t(frange_props::intersect): New\n\t(frange::frange): New.\n\t(frange::type): New.\n\t(frange::set_varying): New.\n\t(frange::set_undefined): New.", "tree": {"sha": "718038b157e964efcc5a502cdfcea6f636783a52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/718038b157e964efcc5a502cdfcea6f636783a52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a10bd84a5d103f6e1fdcd960f8377e3d099d773", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a10bd84a5d103f6e1fdcd960f8377e3d099d773", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a10bd84a5d103f6e1fdcd960f8377e3d099d773", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a10bd84a5d103f6e1fdcd960f8377e3d099d773/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75d20d6c84c12bedd65a904e462f02f0b9eb3f77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75d20d6c84c12bedd65a904e462f02f0b9eb3f77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75d20d6c84c12bedd65a904e462f02f0b9eb3f77"}], "stats": {"total": 459, "additions": 452, "deletions": 7}, "files": [{"sha": "485612fe67c2bea7c2def83a85d31f964e08431b", "filename": "gcc/value-range-pretty-print.cc", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a10bd84a5d103f6e1fdcd960f8377e3d099d773/gcc%2Fvalue-range-pretty-print.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a10bd84a5d103f6e1fdcd960f8377e3d099d773/gcc%2Fvalue-range-pretty-print.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-pretty-print.cc?ref=1a10bd84a5d103f6e1fdcd960f8377e3d099d773", "patch": "@@ -109,3 +109,44 @@ vrange_printer::print_irange_bitmasks (const irange &r) const\n   print_hex (nz, buf);\n   pp_string (pp, buf);\n }\n+\n+// Print an frange.\n+\n+void\n+vrange_printer::visit (const frange &r) const\n+{\n+  pp_string (pp, \"[frange] \");\n+  if (r.undefined_p ())\n+    {\n+      pp_string (pp, \"UNDEFINED\");\n+      return;\n+    }\n+  dump_generic_node (pp, r.type (), 0, TDF_NONE, false);\n+  pp_string (pp, \" \");\n+  if (r.varying_p ())\n+    {\n+      pp_string (pp, \"VARYING\");\n+      return;\n+    }\n+  print_frange_prop (\"NAN\", r.get_nan ());\n+  print_frange_prop (\"INF\", r.get_inf ());\n+  print_frange_prop (\"NINF\", r.get_ninf ());\n+}\n+\n+// Print the FP properties in an frange.\n+\n+void\n+vrange_printer::print_frange_prop (const char *str, const fp_prop &prop) const\n+{\n+  if (prop.varying_p ())\n+    return;\n+\n+  if (prop.yes_p ())\n+    pp_string (pp, str);\n+  else if (prop.no_p ())\n+    {\n+      pp_character (pp, '!');\n+      pp_string (pp, str);\n+    }\n+  pp_character (pp, ' ');\n+}"}, {"sha": "c1c7c4244ccbb015b73134a14c461e3168a47719", "filename": "gcc/value-range-pretty-print.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a10bd84a5d103f6e1fdcd960f8377e3d099d773/gcc%2Fvalue-range-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a10bd84a5d103f6e1fdcd960f8377e3d099d773/gcc%2Fvalue-range-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-pretty-print.h?ref=1a10bd84a5d103f6e1fdcd960f8377e3d099d773", "patch": "@@ -27,9 +27,11 @@ class vrange_printer : public vrange_visitor\n   vrange_printer (pretty_printer *pp_) : pp (pp_) { }\n   void visit (const unsupported_range &) const override;\n   void visit (const irange &) const override;\n+  void visit (const frange &) const override;\n private:\n   void print_irange_bound (tree bound) const;\n   void print_irange_bitmasks (const irange &) const;\n+  void print_frange_prop (const char *str, const fp_prop &) const;\n \n   pretty_printer *pp;\n };"}, {"sha": "5a3336b673bc2c56da060a305e5875a60d11905d", "filename": "gcc/value-range-storage.h", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a10bd84a5d103f6e1fdcd960f8377e3d099d773/gcc%2Fvalue-range-storage.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a10bd84a5d103f6e1fdcd960f8377e3d099d773/gcc%2Fvalue-range-storage.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-storage.h?ref=1a10bd84a5d103f6e1fdcd960f8377e3d099d773", "patch": "@@ -39,6 +39,7 @@ class vrange_allocator\n   template <typename T> T *clone (const T &src);\n private:\n   irange *alloc_irange (unsigned pairs);\n+  frange *alloc_frange ();\n   void operator= (const vrange_allocator &) = delete;\n };\n \n@@ -142,7 +143,9 @@ vrange_allocator::alloc_vrange (tree type)\n {\n   if (irange::supports_p (type))\n     return alloc_irange (2);\n-\n+  if (frange::supports_p (type))\n+    return alloc_frange ();\n+  return NULL;\n   gcc_unreachable ();\n }\n \n@@ -164,6 +167,13 @@ vrange_allocator::alloc_irange (unsigned num_pairs)\n   return new (r) irange (mem, num_pairs);\n }\n \n+inline frange *\n+vrange_allocator::alloc_frange ()\n+{\n+  void *r = alloc (sizeof (frange));\n+  return new (r) frange ();\n+}\n+\n // Return a clone of an irange.\n \n template <>\n@@ -175,6 +185,17 @@ vrange_allocator::clone <irange> (const irange &src)\n   return r;\n }\n \n+// Return a clone of an frange.\n+\n+template <>\n+inline frange *\n+vrange_allocator::clone <frange> (const frange &src)\n+{\n+  frange *r = alloc_frange ();\n+  *r = src;\n+  return r;\n+}\n+\n // Return a clone of a vrange.\n \n template <>\n@@ -183,7 +204,9 @@ vrange_allocator::clone <vrange> (const vrange &src)\n {\n   if (is_a <irange> (src))\n     return clone <irange> (as_a <irange> (src));\n-\n+  if (is_a <frange> (src))\n+    return clone <frange> (as_a <frange> (src));\n+  return NULL;\n   gcc_unreachable ();\n }\n "}, {"sha": "e49b06d10380818a51fe12bc91eb1f08916d4e03", "filename": "gcc/value-range.cc", "status": "modified", "additions": 191, "deletions": 4, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a10bd84a5d103f6e1fdcd960f8377e3d099d773/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a10bd84a5d103f6e1fdcd960f8377e3d099d773/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=1a10bd84a5d103f6e1fdcd960f8377e3d099d773", "patch": "@@ -195,12 +195,12 @@ vrange &\n vrange::operator= (const vrange &src)\n {\n   if (is_a <irange> (src))\n-    {\n-      as_a <irange> (*this) = as_a <irange> (src);\n-      return *this;\n-    }\n+    as_a <irange> (*this) = as_a <irange> (src);\n+  else if (is_a <frange> (src))\n+    as_a <frange> (*this) = as_a <frange> (src);\n   else\n     gcc_unreachable ();\n+  return *this;\n }\n \n // Equality operator for generic ranges.\n@@ -210,6 +210,8 @@ vrange::operator== (const vrange &src) const\n {\n   if (is_a <irange> (src))\n     return as_a <irange> (*this) == as_a <irange> (src);\n+  if (is_a <frange> (src))\n+    return as_a <frange> (*this) == as_a <frange> (src);\n   gcc_unreachable ();\n }\n \n@@ -252,6 +254,191 @@ unsupported_range::unsupported_range ()\n   set_undefined ();\n }\n \n+void\n+frange::accept (const vrange_visitor &v) const\n+{\n+  v.visit (*this);\n+}\n+\n+// Setter for franges.  Currently only singletons are supported.\n+\n+void\n+frange::set (tree min, tree max, value_range_kind kind)\n+{\n+  gcc_checking_assert (kind == VR_RANGE);\n+  gcc_checking_assert (operand_equal_p (min, max));\n+  gcc_checking_assert (TREE_CODE (min) == REAL_CST);\n+\n+  m_kind = kind;\n+  m_type = TREE_TYPE (min);\n+\n+  REAL_VALUE_TYPE *const cst = TREE_REAL_CST_PTR (min);\n+  if (real_isnan (cst))\n+    m_props.nan_set_yes ();\n+  else\n+    m_props.nan_set_no ();\n+\n+  if (real_isinf (cst))\n+    {\n+      if (real_isneg (cst))\n+\t{\n+\t  m_props.inf_set_no ();\n+\t  m_props.ninf_set_yes ();\n+\t}\n+      else\n+\t{\n+\t  m_props.inf_set_yes ();\n+\t  m_props.ninf_set_no ();\n+\t}\n+    }\n+  else\n+    {\n+      m_props.inf_set_no ();\n+      m_props.ninf_set_no ();\n+    }\n+\n+  if (flag_checking)\n+    verify_range ();\n+}\n+\n+// Normalize range to VARYING or UNDEFINED, or vice versa.\n+//\n+// A range with no known properties can be dropped to VARYING.\n+// Similarly, a VARYING with any properties should be dropped to a\n+// VR_RANGE.  Normalizing ranges upon changing them ensures there is\n+// only one representation for a given range.\n+\n+void\n+frange::normalize_kind ()\n+{\n+  if (m_kind == VR_RANGE)\n+    {\n+      // No FP properties set means varying.\n+      if (m_props.nan_varying_p ()\n+\t  && m_props.inf_varying_p ()\n+\t  && m_props.ninf_varying_p ())\n+\t{\n+\t  set_varying (m_type);\n+\t  return;\n+\t}\n+      // Undefined is viral.\n+      if (m_props.nan_undefined_p ()\n+\t  || m_props.inf_undefined_p ()\n+\t  || m_props.ninf_undefined_p ())\n+\t{\n+\t  set_undefined ();\n+\t  return;\n+\t}\n+    }\n+  else if (m_kind == VR_VARYING)\n+    {\n+      // If a VARYING has any FP properties, it's no longer VARYING.\n+      if (!m_props.nan_varying_p ()\n+\t  || !m_props.inf_varying_p ()\n+\t  || !m_props.ninf_varying_p ())\n+\tm_kind = VR_RANGE;\n+    }\n+}\n+\n+bool\n+frange::union_ (const vrange &v)\n+{\n+  const frange &r = as_a <frange> (v);\n+\n+  if (r.undefined_p () || varying_p ())\n+    return false;\n+  if (undefined_p () || r.varying_p ())\n+    {\n+      *this = r;\n+      return true;\n+    }\n+\n+  bool ret = m_props.union_ (r.m_props);\n+  normalize_kind ();\n+\n+  if (flag_checking)\n+    verify_range ();\n+  return ret;\n+}\n+\n+bool\n+frange::intersect (const vrange &v)\n+{\n+  const frange &r = as_a <frange> (v);\n+\n+  if (undefined_p () || r.varying_p ())\n+    return false;\n+  if (r.undefined_p ())\n+    {\n+      set_undefined ();\n+      return true;\n+    }\n+  if (varying_p ())\n+    {\n+      *this = r;\n+      return true;\n+    }\n+\n+  bool ret = m_props.intersect (r.m_props);\n+  normalize_kind ();\n+\n+  if (flag_checking)\n+    verify_range ();\n+  return ret;\n+}\n+\n+frange &\n+frange::operator= (const frange &src)\n+{\n+  m_kind = src.m_kind;\n+  m_type = src.m_type;\n+  m_props = src.m_props;\n+\n+  if (flag_checking)\n+    verify_range ();\n+  return *this;\n+}\n+\n+bool\n+frange::operator== (const frange &src) const\n+{\n+  if (m_kind == src.m_kind)\n+    {\n+      if (undefined_p ())\n+\treturn true;\n+\n+      if (varying_p ())\n+\treturn types_compatible_p (m_type, src.m_type);\n+\n+      return m_props == src.m_props;\n+    }\n+  return false;\n+}\n+\n+bool\n+frange::supports_type_p (tree type) const\n+{\n+  return supports_p (type);\n+}\n+\n+void\n+frange::verify_range ()\n+{\n+  if (undefined_p ())\n+    {\n+      gcc_checking_assert (m_props.undefined_p ());\n+      return;\n+    }\n+  else if (varying_p ())\n+    {\n+      gcc_checking_assert (m_props.varying_p ());\n+      return;\n+    }\n+\n+  gcc_checking_assert (m_kind == VR_RANGE);\n+  gcc_checking_assert (!m_props.varying_p () && !m_props.undefined_p ());\n+}\n+\n // Here we copy between any two irange's.  The ranges can be legacy or\n // multi-ranges, and copying between any combination works correctly.\n "}, {"sha": "e43fbe30f2743b0edb10a1b09d9ab9274b669a26", "filename": "gcc/value-range.h", "status": "modified", "additions": 193, "deletions": 1, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a10bd84a5d103f6e1fdcd960f8377e3d099d773/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a10bd84a5d103f6e1fdcd960f8377e3d099d773/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=1a10bd84a5d103f6e1fdcd960f8377e3d099d773", "patch": "@@ -45,6 +45,8 @@ enum value_range_discriminator\n {\n   // Range holds an integer or pointer.\n   VR_IRANGE,\n+  // Floating point range.\n+  VR_FRANGE,\n   // Range holds an unsupported type.\n   VR_UNKNOWN\n };\n@@ -252,6 +254,117 @@ class unsupported_range : public vrange\n   virtual void accept (const vrange_visitor &v) const override;\n };\n \n+// Floating point property to represent possible values of a NAN, INF, etc.\n+\n+class fp_prop\n+{\n+public:\n+  enum kind {\n+    UNDEFINED\t= 0x0,\t\t// Prop is impossible.\n+    YES\t\t= 0x1,\t\t// Prop is definitely set.\n+    NO\t\t= 0x2,\t\t// Prop is definitely not set.\n+    VARYING\t= (YES | NO)\t// Prop may hold.\n+  };\n+  fp_prop (kind f) : m_kind (f) { }\n+  bool varying_p () const { return m_kind == VARYING; }\n+  bool undefined_p () const { return m_kind == UNDEFINED; }\n+  bool yes_p () const { return m_kind == YES; }\n+  bool no_p () const { return m_kind == NO; }\n+private:\n+  unsigned char m_kind : 2;\n+};\n+\n+// Accessors for individual FP properties.\n+\n+#define FP_PROP_ACCESSOR(NAME) \\\n+  void NAME##_set_varying () { u.bits.NAME = fp_prop::VARYING; }\t\\\n+  void NAME##_set_yes () { u.bits.NAME = fp_prop::YES; }\t\\\n+  void NAME##_set_no () { u.bits.NAME = fp_prop::NO; }\t\\\n+  bool NAME##_varying_p () const { return u.bits.NAME == fp_prop::VARYING; } \\\n+  bool NAME##_undefined_p () const { return u.bits.NAME == fp_prop::UNDEFINED; } \\\n+  bool NAME##_yes_p () const { return u.bits.NAME == fp_prop::YES; }\t\\\n+  bool NAME##_no_p () const { return u.bits.NAME == fp_prop::NO; } \\\n+  fp_prop get_##NAME () const\t\t\t\t   \\\n+  { return fp_prop ((fp_prop::kind) u.bits.NAME); } \\\n+  void set_##NAME (fp_prop::kind f) { u.bits.NAME = f; }\n+\n+// Aggregate of all the FP properties in an frange packed into one\n+// structure to save space.  Using explicit fp_prop's in the frange,\n+// would take one byte per property because of padding.  Instead, we\n+// can save all properties into one byte.\n+\n+class frange_props\n+{\n+public:\n+  frange_props () { set_varying (); }\n+  void set_varying () { u.bytes = 0xff; }\n+  void set_undefined () { u.bytes = 0; }\n+  bool varying_p () { return u.bytes == 0xff; }\n+  bool undefined_p () { return u.bytes == 0; }\n+  bool union_ (const frange_props &other);\n+  bool intersect (const frange_props &other);\n+  bool operator== (const frange_props &other) const;\n+  FP_PROP_ACCESSOR(nan)\n+  FP_PROP_ACCESSOR(inf)\n+  FP_PROP_ACCESSOR(ninf)\n+private:\n+  union {\n+    struct {\n+      unsigned char nan : 2;\n+      unsigned char inf : 2;\n+      unsigned char ninf : 2;\n+    } bits;\n+    unsigned char bytes;\n+  } u;\n+};\n+\n+// Accessors for getting/setting all FP properties at once.\n+\n+#define FRANGE_PROP_ACCESSOR(NAME)\t\t\t\t\\\n+  fp_prop get_##NAME () const { return m_props.get_##NAME (); }\t\\\n+  void set_##NAME (fp_prop::kind f)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    m_props.set_##NAME (f);\t\t\t\t\t\\\n+    normalize_kind ();\t\t\t\t\t\t\\\n+  }\n+\n+// A floating point range.\n+\n+class frange : public vrange\n+{\n+  friend class frange_storage_slot;\n+public:\n+  frange ();\n+  frange (const frange &);\n+  static bool supports_p (tree type)\n+  {\n+    // Disabled until floating point range-ops come live.\n+    return 0 && SCALAR_FLOAT_TYPE_P (type);\n+  }\n+  virtual tree type () const override;\n+  virtual void set (tree, tree, value_range_kind = VR_RANGE) override;\n+  virtual void set_varying (tree type) override;\n+  virtual void set_undefined () override;\n+  virtual bool union_ (const vrange &) override;\n+  virtual bool intersect (const vrange &) override;\n+  virtual bool supports_type_p (tree type) const override;\n+  virtual void accept (const vrange_visitor &v) const override;\n+  frange& operator= (const frange &);\n+  bool operator== (const frange &) const;\n+  bool operator!= (const frange &r) const { return !(*this == r); }\n+\n+  // Each fp_prop can be accessed with get_PROP() and set_PROP().\n+  FRANGE_PROP_ACCESSOR(nan)\n+  FRANGE_PROP_ACCESSOR(inf)\n+  FRANGE_PROP_ACCESSOR(ninf)\n+private:\n+  void verify_range ();\n+  void normalize_kind ();\n+\n+  frange_props m_props;\n+  tree m_type;\n+};\n+\n // is_a<> and as_a<> implementation for vrange.\n \n // Anything we haven't specialized is a hard fail.\n@@ -297,10 +410,18 @@ is_a <irange> (vrange &v)\n   return v.m_discriminator == VR_IRANGE;\n }\n \n+template <>\n+inline bool\n+is_a <frange> (vrange &v)\n+{\n+  return v.m_discriminator == VR_FRANGE;\n+}\n+\n class vrange_visitor\n {\n public:\n   virtual void visit (const irange &) const { }\n+  virtual void visit (const frange &) const { }\n   virtual void visit (const unsupported_range &) const { }\n };\n \n@@ -360,6 +481,7 @@ class Value_Range\n   unsupported_range m_unsupported;\n   vrange *m_vrange;\n   int_range_max m_irange;\n+  frange m_frange;\n };\n \n inline\n@@ -401,6 +523,8 @@ Value_Range::init (tree type)\n \n   if (irange::supports_p (type))\n     m_vrange = &m_irange;\n+  else if (frange::supports_p (type))\n+    m_vrange = &m_frange;\n   else\n     m_vrange = &m_unsupported;\n }\n@@ -426,6 +550,11 @@ Value_Range::operator= (const vrange &r)\n       m_irange = as_a <irange> (r);\n       m_vrange = &m_irange;\n     }\n+  else if (is_a <frange> (r))\n+    {\n+      m_frange = as_a <frange> (r);\n+      m_vrange = &m_frange;\n+    }\n   else\n     gcc_unreachable ();\n \n@@ -461,7 +590,7 @@ Value_Range::operator const vrange &() const\n inline bool\n Value_Range::supports_type_p (tree type)\n {\n-  return irange::supports_p (type);\n+  return irange::supports_p (type) || frange::supports_p (type);\n }\n \n // Returns true for an old-school value_range as described above.\n@@ -881,6 +1010,69 @@ irange::normalize_kind ()\n     }\n }\n \n+\n+// Supporting methods for frange.\n+\n+inline bool\n+frange_props::operator== (const frange_props &other) const\n+{\n+  return u.bytes == other.u.bytes;\n+}\n+\n+inline bool\n+frange_props::union_ (const frange_props &other)\n+{\n+  unsigned char saved = u.bytes;\n+  u.bytes |= other.u.bytes;\n+  return u.bytes != saved;\n+}\n+\n+inline bool\n+frange_props::intersect (const frange_props &other)\n+{\n+  unsigned char saved = u.bytes;\n+  u.bytes &= other.u.bytes;\n+  return u.bytes != saved;\n+}\n+\n+inline\n+frange::frange ()\n+{\n+  m_discriminator = VR_FRANGE;\n+  m_type = nullptr;\n+  set_undefined ();\n+}\n+\n+inline\n+frange::frange (const frange &src)\n+{\n+  m_discriminator = VR_FRANGE;\n+  *this = src;\n+}\n+\n+inline tree\n+frange::type () const\n+{\n+  return m_type;\n+}\n+\n+inline void\n+frange::set_varying (tree type)\n+{\n+  m_kind = VR_VARYING;\n+  m_type = type;\n+  m_props.set_varying ();\n+}\n+\n+inline void\n+frange::set_undefined ()\n+{\n+  m_kind = VR_UNDEFINED;\n+  m_type = NULL;\n+  m_props.set_undefined ();\n+}\n+\n+\n // Return the maximum value for TYPE.\n \n inline tree"}]}