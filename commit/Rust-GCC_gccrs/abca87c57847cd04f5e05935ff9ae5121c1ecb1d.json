{"sha": "abca87c57847cd04f5e05935ff9ae5121c1ecb1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJjYTg3YzU3ODQ3Y2QwNGY1ZTA1OTM1ZmY5YWU1MTIxYzFlY2IxZA==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2020-08-27T16:17:06Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2020-08-27T16:18:33Z"}, "message": "rs6000: Support ELFv2 sibcall for indirect calls [PR96787]\n\nPrior to P10, ELFv2 hasn't implemented nonlocal sibcalls.  Now that we do,\nwe need to be sure that r12 is set up prior to such a call.\n\n2020-08-27  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\tPR target/96787\n\t* config/rs6000/rs6000.c (rs6000_sibcall_aix): Support\n\tindirect call for ELFv2.\n\ngcc/testsuite/\n\n\tPR target/96787\n\t* gcc.target/powerpc/pr96787-1.c: New.\n\t* gcc.target/powerpc/pr96787-2.c: New.", "tree": {"sha": "c77f5ea76e81b89c641e943c6a9e89f2f8c163fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c77f5ea76e81b89c641e943c6a9e89f2f8c163fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abca87c57847cd04f5e05935ff9ae5121c1ecb1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abca87c57847cd04f5e05935ff9ae5121c1ecb1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abca87c57847cd04f5e05935ff9ae5121c1ecb1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abca87c57847cd04f5e05935ff9ae5121c1ecb1d/comments", "author": null, "committer": null, "parents": [{"sha": "c336eda750d4e7a0827fedf995da955d6d88d5ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c336eda750d4e7a0827fedf995da955d6d88d5ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c336eda750d4e7a0827fedf995da955d6d88d5ca"}], "stats": {"total": 92, "additions": 91, "deletions": 1}, "files": [{"sha": "09545278dcf8dc0c4a0bc21d0a81b614006b08e7", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abca87c57847cd04f5e05935ff9ae5121c1ecb1d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abca87c57847cd04f5e05935ff9ae5121c1ecb1d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=abca87c57847cd04f5e05935ff9ae5121c1ecb1d", "patch": "@@ -24833,14 +24833,27 @@ rs6000_sibcall_aix (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n {\n   rtx call[2];\n   rtx insn;\n+  rtx r12 = NULL_RTX;\n+  rtx func_addr = func_desc;\n \n   gcc_assert (INTVAL (cookie) == 0);\n \n   if (global_tlsarg)\n     tlsarg = global_tlsarg;\n \n+  /* For ELFv2, r12 and CTR need to hold the function address\n+     for an indirect call.  */\n+  if (GET_CODE (func_desc) != SYMBOL_REF && DEFAULT_ABI == ABI_ELFv2)\n+    {\n+      r12 = gen_rtx_REG (Pmode, 12);\n+      if (!rtx_equal_p (r12, func_desc))\n+\temit_move_insn (r12, func_desc);\n+      func_addr = gen_rtx_REG (Pmode, CTR_REGNO);\n+      emit_move_insn (func_addr, r12);\n+    }\n+\n   /* Create the call.  */\n-  call[0] = gen_rtx_CALL (VOIDmode, gen_rtx_MEM (SImode, func_desc), tlsarg);\n+  call[0] = gen_rtx_CALL (VOIDmode, gen_rtx_MEM (SImode, func_addr), tlsarg);\n   if (value != NULL_RTX)\n     call[0] = gen_rtx_SET (value, call[0]);\n \n@@ -24853,6 +24866,10 @@ rs6000_sibcall_aix (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n   if (!rs6000_pcrel_p (cfun))\n     use_reg (&CALL_INSN_FUNCTION_USAGE (insn),\n \t     gen_rtx_REG (Pmode, TOC_REGNUM));\n+\n+  /* Note use of r12.  */\n+  if (r12)\n+    use_reg (&CALL_INSN_FUNCTION_USAGE (insn), r12);\n }\n \n /* Expand code to perform a call under the SYSV4 ABI.  */"}, {"sha": "3c58e63797f3c61bf5a7dfa8e2b47bcf8d82152c", "filename": "gcc/testsuite/gcc.target/powerpc/pr96787-1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abca87c57847cd04f5e05935ff9ae5121c1ecb1d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96787-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abca87c57847cd04f5e05935ff9ae5121c1ecb1d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96787-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96787-1.c?ref=abca87c57847cd04f5e05935ff9ae5121c1ecb1d", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_elfv2 } */\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power10\" } */\n+\n+/* Verify that we generate an indirect sibcall for ELFv2 on P10 and\n+   later, with r12 and CTR containing the function address.  PR96787.  */\n+\n+extern int f (int);\n+\n+int main ()\n+{\n+  if (f (3) != 6)\n+    return 1;\n+  return 0;\n+}\n+\n+\n+int g (int a)\n+{\n+  return a * 2;\n+}\n+\n+\n+int h (int a)\n+{\n+  return a + 2;\n+}\n+\n+int __attribute__((__noinline__)) f (int a)\n+{\n+  int (*x) (int) = a % 2 ? &g : &h;\n+  (*x) (a);\n+}\n+\n+/* { dg-final { scan-assembler {\\mmtctr 12\\M} } } */\n+/* { dg-final { scan-assembler {\\mbctr\\M} } } */\n+/* { dg-final { scan-assembler-not {\\mbctrl\\M} } } */"}, {"sha": "b10ab7a8ce824966873459a8055efd927b2c9742", "filename": "gcc/testsuite/gcc.target/powerpc/pr96787-2.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abca87c57847cd04f5e05935ff9ae5121c1ecb1d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96787-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abca87c57847cd04f5e05935ff9ae5121c1ecb1d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96787-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96787-2.c?ref=abca87c57847cd04f5e05935ff9ae5121c1ecb1d", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target power10_hw } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power10\" } */\n+\n+/* Verify that we generate an indirect sibcall for ELFv2 on P10 and\n+   later, with r12 and CTR containing the function address.  PR96787.  */\n+\n+extern void abort (void);\n+extern int f (int);\n+\n+int main ()\n+{\n+  if (f (3) != 6)\n+    abort ();\n+  return 0;\n+}\n+\n+\n+int g (int a)\n+{\n+  return a * 2;\n+}\n+\n+\n+int h (int a)\n+{\n+  return a + 2;\n+}\n+\n+int __attribute__((__noinline__)) f (int a)\n+{\n+  int (*x) (int) = a % 2 ? &g : &h;\n+  (*x) (a);\n+}\n+"}]}