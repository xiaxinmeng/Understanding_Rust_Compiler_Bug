{"sha": "a25321ca06f61e5aeadc00923249f83af72059c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI1MzIxY2EwNmY2MWU1YWVhZGMwMDkyMzI0OWY4M2FmNzIwNTljNQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-04-08T14:40:19Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-04-08T14:40:19Z"}, "message": "libstdc++: Reimplement range adaptors [PR99433]\n\nThis rewrites our range adaptor implementation for more comprehensible\nerror messages, improved SFINAE behavior and conformance to P2281.\n\nThe diagnostic improvements mostly come from using appropriately named\nfunctors instead of lambdas in the generic implementation of partial\napplication and composition of range adaptors, and in the definition of\neach of the standard range adaptors.  This makes their pretty printed\ntypes much shorter and more self-descriptive.\n\nThe improved SFINAE behavior comes from constraining the range adaptors'\nmember functions appropriately.  This improvement fixes PR99433, and is\nalso necessary in order to implement the wording changes of P2281.\n\nFinally, P2281 clarified that partial application and composition of\nrange adaptors behaves like a perfect forwarding call wrapper.  This\npatch implements this, except that we don't bother adding overloads for\nforwarding captured state entities as non-const lvalues, since it seems\nsufficient to handle the const lvalue and non-const rvalue cases for now,\ngiven the current set of standard range adaptors.  But such overloads\ncan be easily added if they turn out to be needed.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/99433\n\t* include/std/ranges (__adaptor::__maybe_refwrap): Remove.\n\t(__adaptor::__adaptor_invocable): New concept.\n\t(__adaptor::__adaptor_partial_app_viable): New concept.\n\t(__adaptor::_RangeAdaptorClosure): Rewrite, turning it into a\n\tnon-template base class.\n\t(__adaptor::_RangeAdaptor): Rewrite, turning it into a CRTP base\n\tclass template.\n\t(__adaptor::_Partial): New class template that represents\n\tpartial application of a range adaptor non-closure.\n\t(__adaptor::__pipe_invocable): New concept.\n\t(__adaptor::_Pipe): New class template.\n\t(__detail::__can_ref_view): New concept.\n\t(__detail::__can_subrange): New concept.\n\t(all): Replace the lambda here with ...\n\t(_All): ... this functor.  Add appropriate constraints.\n\t(__detail::__can_filter_view): New concept.\n\t(filter, _Filter): As in all/_All.\n\t(__detail::__can_transform): New concept.\n\t(transform, _Transform): As in all/_All.\n\t(__detail::__can_take_view): New concept.\n\t(take, _Take): As in all/_All.\n\t(__detail::__can_take_while_view): New concept.\n\t(take_while, _TakeWhile): As in all/_All.\n\t(__detail::__can_drop_view): New concept.\n\t(drop, _Drop): As in all/_All.\n\t(__detail::__can_drop_while_view): New concept.\n\t(drop_while, _DropWhile): As in all/_All.\n\t(__detail::__can_join_view): New concept.\n\t(join, _Join): As in all/_All.\n\t(__detail::__can_split_view): New concept.\n\t(split, _Split): As in all/_All.  Rename template parameter\n\t_Fp to _Pattern.\n\t(__detail::__already_common): New concept.\n\t(__detail::__can_common_view): New concept.\n\t(common, _Common): As in all/_All.\n\t(__detail::__can_reverse_view): New concept.\n\t(reverse, _Reverse): As in all/_All.\n\t(__detail::__can_elements_view): New concept.\n\t(elements, _Elements): As in all/_All.\n\t(keys, values): Adjust.\n\t* testsuite/std/ranges/adaptors/99433.cc: New test.\n\t* testsuite/std/ranges/adaptors/all.cc: No longer expect that\n\tadding empty range adaptor closure objects to a pipeline doesn't\n\tincrease the size of the pipeline.\n\t(test05): New test.\n\t* testsuite/std/ranges/adaptors/common.cc (test03): New test.\n\t* testsuite/std/ranges/adaptors/drop.cc (test09): New test.\n\t* testsuite/std/ranges/adaptors/drop_while.cc (test04): New test.\n\t* testsuite/std/ranges/adaptors/elements.cc (test04): New test.\n\t* testsuite/std/ranges/adaptors/filter.cc (test06): New test.\n\t* testsuite/std/ranges/adaptors/join.cc (test09): New test.\n\t* testsuite/std/ranges/adaptors/p2281.cc: New test.\n\t* testsuite/std/ranges/adaptors/reverse.cc (test07): New test.\n\t* testsuite/std/ranges/adaptors/split.cc (test01, test04):\n\tAdjust.\n\t(test09): New test.\n\t* testsuite/std/ranges/adaptors/split_neg.cc (test01): Adjust\n\texpected error message.\n\t(test02): Likewise.  Extend test.\n\t* testsuite/std/ranges/adaptors/take.cc (test06): New test.\n\t* testsuite/std/ranges/adaptors/take_while.cc (test05): New test.\n\t* testsuite/std/ranges/adaptors/transform.cc (test07, test08):\n\tNew test.", "tree": {"sha": "8e0dc3d20909bdd9520423eebb28ae0700a566ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e0dc3d20909bdd9520423eebb28ae0700a566ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a25321ca06f61e5aeadc00923249f83af72059c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a25321ca06f61e5aeadc00923249f83af72059c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a25321ca06f61e5aeadc00923249f83af72059c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a25321ca06f61e5aeadc00923249f83af72059c5/comments", "author": null, "committer": null, "parents": [{"sha": "860c5caf8cbb87055c02b1e77d04f658d2c75880", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/860c5caf8cbb87055c02b1e77d04f658d2c75880", "html_url": "https://github.com/Rust-GCC/gccrs/commit/860c5caf8cbb87055c02b1e77d04f658d2c75880"}], "stats": {"total": 1033, "additions": 784, "deletions": 249}, "files": [{"sha": "978578197dc050efaf85a89d5657007cc43b5880", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 436, "deletions": 239, "changes": 675, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=a25321ca06f61e5aeadc00923249f83af72059c5", "patch": "@@ -724,168 +724,172 @@ namespace __detail\n \n } // namespace __detail\n \n-namespace views\n+namespace views::__adaptor\n {\n-  namespace __adaptor\n+  // True if the range adaptor _Adaptor can be applied with _Args.\n+  template<typename _Adaptor, typename... _Args>\n+    concept __adaptor_invocable\n+      = requires { std::declval<_Adaptor>()(declval<_Args>()...); };\n+\n+  // True if the range adaptor non-closure _Adaptor can be partially applied\n+  // with _Args.\n+  template<typename _Adaptor, typename... _Args>\n+    concept __adaptor_partial_app_viable = (_Adaptor::_S_arity > 1)\n+      && (sizeof...(_Args) == _Adaptor::_S_arity - 1)\n+      && (constructible_from<decay_t<_Args>, _Args> && ...);\n+\n+  template<typename _Adaptor, typename... _Args>\n+    struct _Partial;\n+\n+  template<typename _Lhs, typename _Rhs>\n+    struct _Pipe;\n+\n+  // The base class of every range adaptor closure.\n+  struct _RangeAdaptorClosure\n   {\n-    template<typename _Tp>\n-      inline constexpr auto\n-      __maybe_refwrap(_Tp& __arg)\n-      { return reference_wrapper<_Tp>{__arg}; }\n+    // range | adaptor is equivalent to adaptor(range).\n+    template<typename _Self, typename _Range>\n+      requires derived_from<remove_cvref_t<_Self>, _RangeAdaptorClosure>\n+\t&& __adaptor_invocable<_Self, _Range>\n+      friend constexpr auto\n+      operator|(_Range&& __r, _Self&& __self)\n+      { return std::forward<_Self>(__self)(std::forward<_Range>(__r)); }\n+\n+    // Compose the adaptors __lhs and __rhs into a pipeline, returning\n+    // another range adaptor closure object.\n+    template<typename _Lhs, typename _Rhs>\n+      requires derived_from<_Lhs, _RangeAdaptorClosure>\n+\t&& derived_from<_Rhs, _RangeAdaptorClosure>\n+      friend constexpr auto\n+      operator|(_Lhs __lhs, _Rhs __rhs)\n+      { return _Pipe<_Lhs, _Rhs>{std::move(__lhs), std::move(__rhs)}; }\n+  };\n \n-    template<typename _Tp>\n-      inline constexpr auto\n-      __maybe_refwrap(const _Tp& __arg)\n-      { return reference_wrapper<const _Tp>{__arg}; }\n+  // The base class of every range adaptor non-closure.\n+  //\n+  // The static data member _Derived::_S_arity must contain the total number of\n+  // arguments that the adaptor takes, and the class _Derived must introduce\n+  // _RangeAdaptor::operator() into the class scope via a using-declaration.\n+  template<typename _Derived>\n+    struct _RangeAdaptor\n+    {\n+      // Partially apply the arguments __args to the range adaptor _Derived,\n+      // returning a range adaptor closure object.\n+      template<typename... _Args>\n+\trequires __adaptor_partial_app_viable<_Derived, _Args...>\n+\tconstexpr auto\n+\toperator()(_Args&&... __args) const\n+\t{\n+\t  return _Partial<_Derived, decay_t<_Args>...>{std::forward<_Args>(__args)...};\n+\t}\n+    };\n \n-    template<typename _Tp>\n-      inline constexpr decltype(auto)\n-      __maybe_refwrap(_Tp&& __arg)\n-      { return std::forward<_Tp>(__arg); }\n+  // A range adaptor closure that represents partial application of\n+  // the range adaptor _Adaptor with arguments _Args.\n+  template<typename _Adaptor, typename... _Args>\n+    struct _Partial : _RangeAdaptorClosure\n+    {\n+      tuple<_Args...> _M_args;\n \n-    template<typename _Callable>\n-      struct _RangeAdaptorClosure;\n+      constexpr\n+      _Partial(_Args... __args)\n+\t: _M_args(std::move(__args)...)\n+      { }\n \n-    template<typename _Callable>\n-      struct _RangeAdaptor\n-      {\n-      protected:\n-\t[[no_unique_address]]\n-\t  __detail::__maybe_present_t<!is_default_constructible_v<_Callable>,\n-\t\t\t\t      _Callable> _M_callable;\n+      // Invoke _Adaptor with arguments __r, _M_args... according to the\n+      // value category of the range adaptor closure object.\n+      template<typename _Range>\n+\trequires __adaptor_invocable<_Adaptor, _Range, const _Args&...>\n+\tconstexpr auto\n+\toperator()(_Range&& __r) const &\n+\t{\n+\t  auto __forwarder = [&__r] (const auto&... __args) {\n+\t    return _Adaptor{}(std::forward<_Range>(__r), __args...);\n+\t  };\n+\t  return std::apply(__forwarder, _M_args);\n+\t}\n \n-      public:\n-\tconstexpr\n-\t_RangeAdaptor(const _Callable& = {})\n-\t  requires is_default_constructible_v<_Callable>\n-\t{ }\n+      template<typename _Range>\n+\trequires __adaptor_invocable<_Adaptor, _Range, _Args...>\n+\tconstexpr auto\n+\toperator()(_Range&& __r) &&\n+\t{\n+\t  auto __forwarder = [&__r] (auto&... __args) {\n+\t    return _Adaptor{}(std::forward<_Range>(__r), std::move(__args)...);\n+\t  };\n+\t  return std::apply(__forwarder, _M_args);\n+\t}\n \n-\tconstexpr\n-\t_RangeAdaptor(_Callable __callable)\n-\t  requires (!is_default_constructible_v<_Callable>)\n-\t  : _M_callable(std::move(__callable))\n-\t{ }\n+      template<typename _Range>\n+\tconstexpr auto\n+\toperator()(_Range&& __r) const && = delete;\n+    };\n \n-\ttemplate<typename... _Args>\n-\t  requires (sizeof...(_Args) >= 1)\n-\t  constexpr auto\n-\t  operator()(_Args&&... __args) const\n-\t  {\n-\t    // [range.adaptor.object]: If a range adaptor object accepts more\n-\t    // than one argument, then the following expressions are equivalent:\n-\t    //\n-\t    //   (1) adaptor(range, args...)\n-\t    //   (2) adaptor(args...)(range)\n-\t    //   (3) range | adaptor(args...)\n-\t    //\n-\t    // In this case, adaptor(args...) is a range adaptor closure object.\n-\t    //\n-\t    // We handle (1) and (2) here, and (3) is just a special case of a\n-\t    // more general case already handled by _RangeAdaptorClosure.\n-\t    if constexpr (is_invocable_v<_Callable, _Args...>)\n-\t      {\n-\t\tstatic_assert(sizeof...(_Args) != 1,\n-\t\t\t      \"a _RangeAdaptor that accepts only one argument \"\n-\t\t\t      \"should be defined as a _RangeAdaptorClosure\");\n-\t\t// Here we handle adaptor(range, args...) -- just forward all\n-\t\t// arguments to the underlying adaptor routine.\n-\t\treturn _Callable{}(std::forward<_Args>(__args)...);\n-\t      }\n-\t    else\n-\t      {\n-\t\t// Here we handle adaptor(args...)(range).\n-\t\t// Given args..., we return a _RangeAdaptorClosure that takes a\n-\t\t// range argument, such that (2) is equivalent to (1).\n-\t\t//\n-\t\t// We need to be careful about how we capture args... in this\n-\t\t// closure.  By using __maybe_refwrap, we capture lvalue\n-\t\t// references by reference (through a reference_wrapper) and\n-\t\t// otherwise capture by value.\n-\t\tauto __closure\n-\t\t  = [...__args(__maybe_refwrap(std::forward<_Args>(__args)))]\n-\t\t    <typename _Range> (_Range&& __r) {\n-\t\t      // This static_cast has two purposes: it forwards a\n-\t\t      // reference_wrapper<T> capture as a T&, and otherwise\n-\t\t      // forwards the captured argument as an rvalue.\n-\t\t      return _Callable{}(std::forward<_Range>(__r),\n-\t\t\t       (static_cast<unwrap_reference_t\n-\t\t\t\t\t    <remove_const_t<decltype(__args)>>>\n-\t\t\t\t(__args))...);\n-\t\t    };\n-\t\tusing _ClosureType = decltype(__closure);\n-\t\treturn _RangeAdaptorClosure<_ClosureType>(std::move(__closure));\n-\t      }\n-\t  }\n-      };\n+  // A lightweight specialization of the above primary template for\n+  // the common case where _Adaptor accepts a single extra argument.\n+  template<typename _Adaptor, typename _Arg>\n+    struct _Partial<_Adaptor, _Arg> : _RangeAdaptorClosure\n+    {\n+      _Arg _M_arg;\n \n-    template<typename _Callable>\n-      _RangeAdaptor(_Callable) -> _RangeAdaptor<_Callable>;\n+      constexpr\n+      _Partial(_Arg __arg)\n+\t: _M_arg(std::move(__arg))\n+      { }\n \n-    template<typename _Callable>\n-      struct _RangeAdaptorClosure : public _RangeAdaptor<_Callable>\n-      {\n-\tusing _RangeAdaptor<_Callable>::_RangeAdaptor;\n+      template<typename _Range>\n+\trequires __adaptor_invocable<_Adaptor, _Range, const _Arg&>\n+\tconstexpr auto\n+\toperator()(_Range&& __r) const &\n+\t{ return _Adaptor{}(std::forward<_Range>(__r), _M_arg); }\n+\n+      template<typename _Range>\n+\trequires __adaptor_invocable<_Adaptor, _Range, _Arg>\n+\tconstexpr auto\n+\toperator()(_Range&& __r) &&\n+\t{ return _Adaptor{}(std::forward<_Range>(__r), std::move(_M_arg)); }\n+\n+      template<typename _Range>\n+\tconstexpr auto\n+\toperator()(_Range&& __r) const && = delete;\n+    };\n \n-\ttemplate<viewable_range _Range>\n-\t  requires requires { declval<_Callable>()(declval<_Range>()); }\n-\t  constexpr auto\n-\t  operator()(_Range&& __r) const\n-\t  {\n-\t    if constexpr (is_default_constructible_v<_Callable>)\n-\t      return _Callable{}(std::forward<_Range>(__r));\n-\t    else\n-\t      return this->_M_callable(std::forward<_Range>(__r));\n-\t  }\n+  template<typename _Lhs, typename _Rhs, typename _Range>\n+    concept __pipe_invocable\n+      = requires { std::declval<_Rhs>()(std::declval<_Lhs>()(std::declval<_Range>())); };\n \n-\ttemplate<viewable_range _Range>\n-\t  requires requires { declval<_Callable>()(declval<_Range>()); }\n-\t  friend constexpr auto\n-\t  operator|(_Range&& __r, const _RangeAdaptorClosure& __o)\n-\t  { return __o(std::forward<_Range>(__r)); }\n+  // A range adaptor closure that represents composition of the range\n+  // adaptor closures _Lhs and _Rhs.\n+  template<typename _Lhs, typename _Rhs>\n+    struct _Pipe : _RangeAdaptorClosure\n+    {\n+      [[no_unique_address]] _Lhs _M_lhs;\n+      [[no_unique_address]] _Rhs _M_rhs;\n \n-\ttemplate<typename _Tp>\n-\t  friend constexpr auto\n-\t  operator|(const _RangeAdaptorClosure<_Tp>& __x,\n-\t\t    const _RangeAdaptorClosure& __y)\n-\t  {\n-\t    if constexpr (is_default_constructible_v<_Tp>\n-\t\t\t  && is_default_constructible_v<_Callable>)\n-\t      {\n-\t\tauto __closure = [] <typename _Up> (_Up&& __e) {\n-\t\t  return std::forward<_Up>(__e) | decltype(__x){} | decltype(__y){};\n-\t\t};\n-\t\treturn _RangeAdaptorClosure<decltype(__closure)>(__closure);\n-\t      }\n-\t    else if constexpr (is_default_constructible_v<_Tp>\n-\t\t\t       && !is_default_constructible_v<_Callable>)\n-\t      {\n-\t\tauto __closure = [__y] <typename _Up> (_Up&& __e) {\n-\t\t  return std::forward<_Up>(__e) | decltype(__x){} | __y;\n-\t\t};\n-\t\treturn _RangeAdaptorClosure<decltype(__closure)>(__closure);\n-\t      }\n-\t    else if constexpr (!is_default_constructible_v<_Tp>\n-\t\t\t       && is_default_constructible_v<_Callable>)\n-\t      {\n-\t\tauto __closure = [__x] <typename _Up> (_Up&& __e) {\n-\t\t  return std::forward<_Up>(__e) | __x | decltype(__y){};\n-\t\t};\n-\t\treturn _RangeAdaptorClosure<decltype(__closure)>(__closure);\n-\t      }\n-\t    else\n-\t      {\n-\t\tauto __closure = [__x, __y] <typename _Up> (_Up&& __e) {\n-\t\t  return std::forward<_Up>(__e) | __x | __y;\n-\t\t};\n-\t\treturn _RangeAdaptorClosure<decltype(__closure)>(__closure);\n-\t      }\n-\t  }\n-      };\n+      constexpr\n+      _Pipe(_Lhs __lhs, _Rhs __rhs)\n+\t: _M_lhs(std::move(__lhs)), _M_rhs(std::move(__rhs))\n+      { }\n \n-    template<typename _Callable>\n-      _RangeAdaptorClosure(_Callable) -> _RangeAdaptorClosure<_Callable>;\n-  } // namespace __adaptor\n-} // namespace views\n+      // Invoke _M_rhs(_M_lhs(__r)) according to the value category of this\n+      // range adaptor closure object.\n+      template<typename _Range>\n+\trequires __pipe_invocable<const _Lhs&, const _Rhs&, _Range>\n+\tconstexpr auto\n+\toperator()(_Range&& __r) const &\n+\t{ return _M_rhs(_M_lhs(std::forward<_Range>(__r))); }\n+\n+      template<typename _Range>\n+\trequires __pipe_invocable<_Lhs, _Rhs, _Range>\n+\tconstexpr auto\n+\toperator()(_Range&& __r) &&\n+\t{ return std::move(_M_rhs)(std::move(_M_lhs)(std::forward<_Range>(__r))); }\n+\n+      template<typename _Range>\n+\tconstexpr auto\n+\toperator()(_Range&& __r) const && = delete;\n+    };\n+} // namespace views::__adaptor\n \n   template<range _Range> requires is_object_v<_Range>\n     class ref_view : public view_interface<ref_view<_Range>>\n@@ -941,20 +945,37 @@ namespace views\n \n   namespace views\n   {\n-    inline constexpr __adaptor::_RangeAdaptorClosure all\n-      = [] <viewable_range _Range> (_Range&& __r)\n-      {\n-\tif constexpr (view<decay_t<_Range>>)\n-\t  return std::forward<_Range>(__r);\n-\telse if constexpr (requires { ref_view{std::forward<_Range>(__r)}; })\n-\t  return ref_view{std::forward<_Range>(__r)};\n-\telse\n-\t  return subrange{std::forward<_Range>(__r)};\n-      };\n+    namespace __detail\n+    {\n+      template<typename _Range>\n+\tconcept __can_ref_view = requires { ref_view{std::declval<_Range>()}; };\n+\n+      template<typename _Range>\n+\tconcept __can_subrange = requires { subrange{std::declval<_Range>()}; };\n+    } // namespace __detail\n+\n+    struct _All : __adaptor::_RangeAdaptorClosure\n+    {\n+      template<viewable_range _Range>\n+\trequires view<decay_t<_Range>>\n+\t  || __detail::__can_ref_view<_Range>\n+\t  || __detail::__can_subrange<_Range>\n+\tconstexpr auto\n+\toperator()(_Range&& __r) const\n+\t{\n+\t  if constexpr (view<decay_t<_Range>>)\n+\t    return std::forward<_Range>(__r);\n+\t  else if constexpr (__detail::__can_ref_view<_Range>)\n+\t    return ref_view{std::forward<_Range>(__r)};\n+\t  else\n+\t    return subrange{std::forward<_Range>(__r)};\n+\t}\n+    };\n+\n+    inline constexpr _All all;\n \n     template<viewable_range _Range>\n       using all_t = decltype(all(std::declval<_Range>()));\n-\n   } // namespace views\n \n   // XXX: the following algos are copied from ranges_algo.h to avoid a circular\n@@ -1305,11 +1326,28 @@ namespace views\n \n   namespace views\n   {\n-    inline constexpr __adaptor::_RangeAdaptor filter\n-      = [] <viewable_range _Range, typename _Pred> (_Range&& __r, _Pred&& __p)\n-      {\n-\treturn filter_view{std::forward<_Range>(__r), std::forward<_Pred>(__p)};\n-      };\n+    namespace __detail\n+    {\n+      template<typename _Range, typename _Pred>\n+\tconcept __can_filter_view\n+\t  = requires { filter_view{std::declval<_Range>(), std::declval<_Pred>()}; };\n+    } // namespace __detail\n+\n+    struct _Filter : __adaptor::_RangeAdaptor<_Filter>\n+    {\n+      template<viewable_range _Range, typename _Pred>\n+\trequires __detail::__can_filter_view<_Range, _Pred>\n+\tconstexpr auto\n+\toperator()(_Range&& __r, _Pred&& __p) const\n+\t{\n+\t  return filter_view{std::forward<_Range>(__r), std::forward<_Pred>(__p)};\n+\t}\n+\n+      using _RangeAdaptor<_Filter>::operator();\n+      static constexpr int _S_arity = 2;\n+    };\n+\n+    inline constexpr _Filter filter;\n   } // namespace views\n \n   template<input_range _Vp, copy_constructible _Fp>\n@@ -1653,11 +1691,28 @@ namespace views\n \n   namespace views\n   {\n-    inline constexpr __adaptor::_RangeAdaptor transform\n-      = [] <viewable_range _Range, typename _Fp> (_Range&& __r, _Fp&& __f)\n-      {\n-\treturn transform_view{std::forward<_Range>(__r), std::forward<_Fp>(__f)};\n-      };\n+    namespace __detail\n+    {\n+      template<typename _Range, typename _Fp>\n+\tconcept __can_transform_view\n+\t  = requires { transform_view{std::declval<_Range>(), std::declval<_Fp>()}; };\n+    } // namespace __detail\n+\n+    struct _Transform : __adaptor::_RangeAdaptor<_Transform>\n+    {\n+      template<viewable_range _Range, typename _Fp>\n+\trequires __detail::__can_transform_view<_Range, _Fp>\n+\tconstexpr auto\n+\toperator()(_Range&& __r, _Fp&& __f) const\n+\t{\n+\t  return transform_view{std::forward<_Range>(__r), std::forward<_Fp>(__f)};\n+\t}\n+\n+      using _RangeAdaptor<_Transform>::operator();\n+      static constexpr int _S_arity = 2;\n+    };\n+\n+    inline constexpr _Transform transform;\n   } // namespace views\n \n   template<view _Vp>\n@@ -1816,11 +1871,28 @@ namespace views\n \n   namespace views\n   {\n-    inline constexpr __adaptor::_RangeAdaptor take\n-      = [] <viewable_range _Range, typename _Tp> (_Range&& __r, _Tp&& __n)\n-      {\n-\treturn take_view{std::forward<_Range>(__r), std::forward<_Tp>(__n)};\n-      };\n+    namespace __detail\n+    {\n+      template<typename _Range, typename _Tp>\n+\tconcept __can_take_view\n+\t  = requires { take_view{std::declval<_Range>(), std::declval<_Tp>()}; };\n+    } // namespace __detail\n+\n+    struct _Take : __adaptor::_RangeAdaptor<_Take>\n+    {\n+      template<viewable_range _Range, typename _Tp>\n+\trequires __detail::__can_take_view<_Range, _Tp>\n+\tconstexpr auto\n+\toperator()(_Range&& __r, _Tp&& __n) const\n+\t{\n+\t  return take_view{std::forward<_Range>(__r), std::forward<_Tp>(__n)};\n+\t}\n+\n+      using _RangeAdaptor<_Take>::operator();\n+      static constexpr int _S_arity = 2;\n+    };\n+\n+    inline constexpr _Take take;\n   } // namespace views\n \n   template<view _Vp, typename _Pred>\n@@ -1918,11 +1990,28 @@ namespace views\n \n   namespace views\n   {\n-    inline constexpr __adaptor::_RangeAdaptor take_while\n-      = [] <viewable_range _Range, typename _Pred> (_Range&& __r, _Pred&& __p)\n-      {\n-\treturn take_while_view{std::forward<_Range>(__r), std::forward<_Pred>(__p)};\n-      };\n+    namespace __detail\n+    {\n+      template<typename _Range, typename _Pred>\n+\tconcept __can_take_while_view\n+\t  = requires { take_while_view{std::declval<_Range>(), std::declval<_Pred>()}; };\n+    } // namespace __detail\n+\n+    struct _TakeWhile : __adaptor::_RangeAdaptor<_TakeWhile>\n+    {\n+      template<viewable_range _Range, typename _Pred>\n+\trequires __detail::__can_take_while_view<_Range, _Pred>\n+\tconstexpr auto\n+\toperator()(_Range&& __r, _Pred&& __p) const\n+\t{\n+\t  return take_while_view{std::forward<_Range>(__r), std::forward<_Pred>(__p)};\n+\t}\n+\n+      using _RangeAdaptor<_TakeWhile>::operator();\n+      static constexpr int _S_arity = 2;\n+    };\n+\n+    inline constexpr _TakeWhile take_while;\n   } // namespace views\n \n   template<view _Vp>\n@@ -2020,11 +2109,28 @@ namespace views\n \n   namespace views\n   {\n-    inline constexpr __adaptor::_RangeAdaptor drop\n-      = [] <viewable_range _Range, typename _Tp> (_Range&& __r, _Tp&& __n)\n-      {\n-\treturn drop_view{std::forward<_Range>(__r), std::forward<_Tp>(__n)};\n-      };\n+    namespace __detail\n+    {\n+      template<typename _Range, typename _Tp>\n+\tconcept __can_drop_view\n+\t  = requires { drop_view{std::declval<_Range>(), std::declval<_Tp>()}; };\n+    } // namespace __detail\n+\n+    struct _Drop : __adaptor::_RangeAdaptor<_Drop>\n+    {\n+      template<viewable_range _Range, typename _Tp>\n+\trequires __detail::__can_drop_view<_Range, _Tp>\n+\tconstexpr auto\n+\toperator()(_Range&& __r, _Tp&& __n) const\n+\t{\n+\t  return drop_view{std::forward<_Range>(__r), std::forward<_Tp>(__n)};\n+\t}\n+\n+      using _RangeAdaptor<_Drop>::operator();\n+      static constexpr int _S_arity = 2;\n+    };\n+\n+    inline constexpr _Drop drop;\n   } // namespace views\n \n   template<view _Vp, typename _Pred>\n@@ -2085,12 +2191,29 @@ namespace views\n \n   namespace views\n   {\n-    inline constexpr __adaptor::_RangeAdaptor drop_while\n-      = [] <viewable_range _Range, typename _Pred> (_Range&& __r, _Pred&& __p)\n-      {\n-\treturn drop_while_view{std::forward<_Range>(__r),\n-\t\t\t       std::forward<_Pred>(__p)};\n-      };\n+    namespace __detail\n+    {\n+      template<typename _Range, typename _Pred>\n+\tconcept __can_drop_while_view\n+\t  = requires { drop_while_view{std::declval<_Range>(), std::declval<_Pred>()}; };\n+    } // namespace __detail\n+\n+    struct _DropWhile : __adaptor::_RangeAdaptor<_DropWhile>\n+    {\n+      template<viewable_range _Range, typename _Pred>\n+\trequires __detail::__can_drop_while_view<_Range, _Pred>\n+\tconstexpr auto\n+\toperator()(_Range&& __r, _Pred&& __p) const\n+\t{\n+\t  return drop_while_view{std::forward<_Range>(__r),\n+\t\t\t\t std::forward<_Pred>(__p)};\n+\t}\n+\n+      using _RangeAdaptor<_DropWhile>::operator();\n+      static constexpr int _S_arity = 2;\n+    };\n+\n+    inline constexpr _DropWhile drop_while;\n   } // namespace views\n \n   template<input_range _Vp>\n@@ -2409,13 +2532,27 @@ namespace views\n \n   namespace views\n   {\n-    inline constexpr __adaptor::_RangeAdaptorClosure join\n-      = [] <viewable_range _Range> (_Range&& __r)\n-      {\n-\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n-\t// 3474. Nesting join_views is broken because of CTAD\n-\treturn join_view<views::all_t<_Range>>{std::forward<_Range>(__r)};\n-      };\n+    namespace __detail\n+    {\n+      template<typename _Range>\n+\tconcept __can_join_view\n+\t  = requires { join_view<all_t<_Range>>{std::declval<_Range>()}; };\n+    } // namespace __detail\n+\n+    struct _Join : __adaptor::_RangeAdaptorClosure\n+    {\n+      template<viewable_range _Range>\n+\trequires __detail::__can_join_view<_Range>\n+\tconstexpr auto\n+\toperator()(_Range&& __r) const\n+\t{\n+\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t  // 3474. Nesting join_views is broken because of CTAD\n+\t  return join_view<all_t<_Range>>{std::forward<_Range>(__r)};\n+\t}\n+    };\n+\n+    inline constexpr _Join join;\n   } // namespace views\n \n   namespace __detail\n@@ -2784,21 +2921,38 @@ namespace views\n       }\n     };\n \n-  template<typename _Range, typename _Pred>\n-    split_view(_Range&&, _Pred&&)\n-      -> split_view<views::all_t<_Range>, views::all_t<_Pred>>;\n+  template<typename _Range, typename _Pattern>\n+    split_view(_Range&&, _Pattern&&)\n+      -> split_view<views::all_t<_Range>, views::all_t<_Pattern>>;\n \n   template<input_range _Range>\n     split_view(_Range&&, range_value_t<_Range>)\n       -> split_view<views::all_t<_Range>, single_view<range_value_t<_Range>>>;\n \n   namespace views\n   {\n-    inline constexpr __adaptor::_RangeAdaptor split\n-      = [] <viewable_range _Range, typename _Fp> (_Range&& __r, _Fp&& __f)\n-      {\n-\treturn split_view{std::forward<_Range>(__r), std::forward<_Fp>(__f)};\n-      };\n+    namespace __detail\n+    {\n+      template<typename _Range, typename _Pattern>\n+\tconcept __can_split_view\n+\t  = requires { split_view{std::declval<_Range>(), std::declval<_Pattern>()}; };\n+    } // namespace __detail\n+\n+    struct _Split : __adaptor::_RangeAdaptor<_Split>\n+    {\n+      template<viewable_range _Range, typename _Pattern>\n+\trequires __detail::__can_split_view<_Range, _Pattern>\n+\tconstexpr auto\n+\toperator()(_Range&& __r, _Pattern&& __f) const\n+\t{\n+\t  return split_view{std::forward<_Range>(__r), std::forward<_Pattern>(__f)};\n+\t}\n+\n+      using _RangeAdaptor<_Split>::operator();\n+      static constexpr int _S_arity = 2;\n+    };\n+\n+    inline constexpr _Split split;\n   } // namespace views\n \n   namespace views\n@@ -2911,16 +3065,33 @@ namespace views\n \n   namespace views\n   {\n-    inline constexpr __adaptor::_RangeAdaptorClosure common\n-      = [] <viewable_range _Range> (_Range&& __r)\n-      {\n-\tif constexpr (common_range<_Range>\n-\t\t      && requires { views::all(std::forward<_Range>(__r)); })\n-\t  return views::all(std::forward<_Range>(__r));\n-\telse\n-\t  return common_view{std::forward<_Range>(__r)};\n-      };\n+    namespace __detail\n+    {\n+      template<typename _Range>\n+\tconcept __already_common = common_range<_Range>\n+\t  && requires { views::all(std::declval<_Range>()); };\n+\n+      template<typename _Range>\n+\tconcept __can_common_view\n+\t  = requires { common_view{std::declval<_Range>()}; };\n+    } // namespace __detail\n+\n+    struct _Common : __adaptor::_RangeAdaptorClosure\n+    {\n+      template<viewable_range _Range>\n+\trequires __detail::__already_common<_Range>\n+\t  || __detail::__can_common_view<_Range>\n+\tconstexpr auto\n+\toperator()(_Range&& __r) const\n+\t{\n+\t  if constexpr (__detail::__already_common<_Range>)\n+\t    return views::all(std::forward<_Range>(__r));\n+\t  else\n+\t    return common_view{std::forward<_Range>(__r)};\n+\t}\n+    };\n \n+    inline constexpr _Common common;\n   } // namespace views\n \n   template<view _Vp>\n@@ -3016,27 +3187,40 @@ namespace views\n \n       template<typename _Vp>\n \tinline constexpr bool __is_reverse_view<reverse_view<_Vp>> = true;\n-    }\n \n-    inline constexpr __adaptor::_RangeAdaptorClosure reverse\n-      = [] <viewable_range _Range> (_Range&& __r)\n-      {\n-\tusing _Tp = remove_cvref_t<_Range>;\n-\tif constexpr (__detail::__is_reverse_view<_Tp>)\n-\t  return std::forward<_Range>(__r).base();\n-\telse if constexpr (__detail::__is_reversible_subrange<_Tp>)\n-\t  {\n-\t    using _Iter = decltype(ranges::begin(__r).base());\n-\t    if constexpr (sized_range<_Tp>)\n-\t      return subrange<_Iter, _Iter, subrange_kind::sized>\n-\t\t      (__r.end().base(), __r.begin().base(), __r.size());\n-\t    else\n-\t      return subrange<_Iter, _Iter, subrange_kind::unsized>\n-\t\t      (__r.end().base(), __r.begin().base());\n-\t  }\n-\telse\n-\t  return reverse_view{std::forward<_Range>(__r)};\n-      };\n+      template<typename _Range>\n+\tconcept __can_reverse_view\n+\t  = requires { reverse_view{std::declval<_Range>()}; };\n+    } // namespace __detail\n+\n+    struct _Reverse : __adaptor::_RangeAdaptorClosure\n+    {\n+      template<viewable_range _Range>\n+\trequires __detail::__is_reverse_view<remove_cvref_t<_Range>>\n+\t  || __detail::__is_reversible_subrange<remove_cvref_t<_Range>>\n+\t  || __detail::__can_reverse_view<_Range>\n+\tconstexpr auto\n+\toperator()(_Range&& __r) const\n+\t{\n+\t  using _Tp = remove_cvref_t<_Range>;\n+\t  if constexpr (__detail::__is_reverse_view<_Tp>)\n+\t    return std::forward<_Range>(__r).base();\n+\t  else if constexpr (__detail::__is_reversible_subrange<_Tp>)\n+\t    {\n+\t      using _Iter = decltype(ranges::begin(__r).base());\n+\t      if constexpr (sized_range<_Tp>)\n+\t\treturn subrange<_Iter, _Iter, subrange_kind::sized>\n+\t\t\t{__r.end().base(), __r.begin().base(), __r.size()};\n+\t      else\n+\t\treturn subrange<_Iter, _Iter, subrange_kind::unsized>\n+\t\t\t{__r.end().base(), __r.begin().base()};\n+\t    }\n+\t  else\n+\t    return reverse_view{std::forward<_Range>(__r)};\n+\t}\n+    };\n+\n+    inline constexpr _Reverse reverse;\n   } // namespace views\n \n   namespace __detail\n@@ -3335,16 +3519,29 @@ namespace views\n \n   namespace views\n   {\n+    namespace __detail\n+    {\n+      template<size_t _Nm, typename _Range>\n+\tconcept __can_elements_view\n+\t  = requires { elements_view<all_t<_Range>, _Nm>{std::declval<_Range>()}; };\n+    } // namespace __detail\n+\n     template<size_t _Nm>\n-    inline constexpr __adaptor::_RangeAdaptorClosure elements\n-      = [] <viewable_range _Range> (_Range&& __r)\n+      struct _Elements : __adaptor::_RangeAdaptorClosure\n       {\n-\tusing _El = elements_view<views::all_t<_Range>, _Nm>;\n-\treturn _El{std::forward<_Range>(__r)};\n+\ttemplate<viewable_range _Range>\n+\t  requires __detail::__can_elements_view<_Nm, _Range>\n+\t  constexpr auto\n+\t  operator()(_Range&& __r) const\n+\t  {\n+\t    return elements_view<all_t<_Range>, _Nm>{std::forward<_Range>(__r)};\n+\t  }\n       };\n \n-    inline constexpr __adaptor::_RangeAdaptorClosure keys = elements<0>;\n-    inline constexpr __adaptor::_RangeAdaptorClosure values = elements<1>;\n+    template<size_t _Nm>\n+      inline constexpr _Elements<_Nm> elements;\n+    inline constexpr auto keys = elements<0>;\n+    inline constexpr auto values = elements<1>;\n   } // namespace views\n \n } // namespace ranges"}, {"sha": "b9d17942e176d0821d4774733eae804aa6ddfc2c", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/99433.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2F99433.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2F99433.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2F99433.cc?ref=a25321ca06f61e5aeadc00923249f83af72059c5", "patch": "@@ -0,0 +1,41 @@\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// PR libstdc++/99433\n+\n+#include <ranges>\n+#include <vector>\n+\n+template <typename underlying_adaptor_t>\n+struct deep\n+{\n+  underlying_adaptor_t adaptor;\n+\n+  template <typename range_t>\n+  friend auto operator|(range_t &range, deep const &me)\n+  {\n+   return me.adaptor(range[0]);\n+  }\n+};\n+\n+auto f = [] (auto nucl) { return nucl + ' '; };\n+auto complement = deep{std::views::transform(f)};\n+std::vector<std::vector<char>> foo{};\n+auto v = foo | complement;"}, {"sha": "42913ad38a303ce89cb97beca01d2ff3c673ae5f", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/all.cc", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fall.cc?ref=a25321ca06f61e5aeadc00923249f83af72059c5", "patch": "@@ -103,6 +103,12 @@ static_assert(std::is_empty_v<decltype(views::common\n \t\t\t\t       | views::common\n \t\t\t\t       | views::keys\n \t\t\t\t       | views::reverse)>);\n+#if 0\n+// Adding empty range adaptor closure objects to a pipeline used to not\n+// increase the size of the pipeline, but now that our range adaptor closure\n+// objects derive from a common empty base class, [[no_unique_address]] can no\n+// longer make two empty adjacent range adaptor closure objects occupy the same\n+// data member address.\n static_assert(sizeof(decltype(views::take(5) | views::drop(5)))\n \t      == sizeof(decltype(views::take(5)\n \t\t\t\t | views::join\n@@ -111,6 +117,18 @@ static_assert(sizeof(decltype(views::take(5) | views::drop(5)))\n \t\t\t\t | views::keys\n \t\t\t\t | views::drop(5)\n \t\t\t\t | views::reverse)));\n+#endif\n+\n+template<auto all = views::all>\n+void\n+test05()\n+{\n+  // Verify SFINAE behavior.\n+  static_assert(!requires { all(); });\n+  static_assert(!requires { all(0, 0); });\n+  static_assert(!requires { all(0); });\n+  static_assert(!requires { 0 | all; });\n+}\n \n int\n main()\n@@ -119,4 +137,5 @@ main()\n   test02();\n   static_assert(test03());\n   static_assert(test04());\n+  test05();\n }"}, {"sha": "085e8ff907dd80d3965e230cf15de97ab704d83f", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/common.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fcommon.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fcommon.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fcommon.cc?ref=a25321ca06f61e5aeadc00923249f83af72059c5", "patch": "@@ -60,9 +60,21 @@ test02()\n   VERIFY( std::count(v2.begin(), v2.end(), 1) == 2);\n }\n \n+template<auto common = views::common>\n+void\n+test03()\n+{\n+  // Verify SFINAE behavior.\n+  static_assert(!requires { common(); });\n+  static_assert(!requires { common(0, 0); });\n+  static_assert(!requires { common(0); });\n+  static_assert(!requires { 0 | common; });\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n+  test03();\n }"}, {"sha": "c0525109bd1be31e2c55594f0c850f49ba40216e", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/drop.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fdrop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fdrop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fdrop.cc?ref=a25321ca06f61e5aeadc00923249f83af72059c5", "patch": "@@ -258,6 +258,23 @@ test08()\n   VERIFY( ra_test_wrapper<long>::increment_count == 0 );\n }\n \n+template<auto drop = views::drop>\n+void\n+test09()\n+{\n+  // Verify SFINAE behavior.\n+  extern int x[5];\n+  int* n = 0;\n+  static_assert(!requires { drop(); });\n+  static_assert(!requires { drop(x, n, n); });\n+  static_assert(!requires { drop(x, n); });\n+  static_assert(!requires { drop(n)(x); });\n+  static_assert(!requires { x | (drop(n) | views::all); });\n+  static_assert(!requires { (drop(n) | views::all)(x); });\n+  static_assert(!requires { drop | views::all; });\n+  static_assert(!requires { views::all | drop; });\n+}\n+\n int\n main()\n {\n@@ -269,4 +286,5 @@ main()\n   test06();\n   test07();\n   test08();\n+  test09();\n }"}, {"sha": "58489d54f8965e9fef2052beada7d8369f8b46f4", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/drop_while.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fdrop_while.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fdrop_while.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fdrop_while.cc?ref=a25321ca06f61e5aeadc00923249f83af72059c5", "patch": "@@ -89,11 +89,29 @@ test03()\n   VERIFY( ranges::equal(v, (int[]){3,4,5}) );\n }\n \n+template<auto drop_while = views::drop_while>\n+void\n+test04()\n+{\n+  // Verify SFINAE behavior.\n+  extern int x[5];\n+  auto p = [] (int*) { return true; };\n+  static_assert(!requires { drop_while(); });\n+  static_assert(!requires { drop_while(x, p, p); });\n+  static_assert(!requires { drop_while(x, p); });\n+  static_assert(!requires { drop_while(p)(x); });\n+  static_assert(!requires { x | (drop_while(p) | views::all); });\n+  static_assert(!requires { (drop_while(p) | views::all)(x); });\n+  static_assert(!requires { drop_while | views::all; });\n+  static_assert(!requires { views::all | drop_while; });\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n   test03<forward_iterator_wrapper>();\n   test03<random_access_iterator_wrapper>();\n+  test04();\n }"}, {"sha": "b0d122f8db5f2dc59bd658baa813bf8c1f149c10", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/elements.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Felements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Felements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Felements.cc?ref=a25321ca06f61e5aeadc00923249f83af72059c5", "patch": "@@ -89,10 +89,22 @@ test03()\n   VERIFY( (next(b_const, 2) - b_const) == 2 );\n }\n \n+template<auto elements = views::elements<0>>\n+void\n+test04()\n+{\n+  // Verify SFINAE behavior.\n+  static_assert(!requires { elements(); });\n+  static_assert(!requires { elements(0, 0); });\n+  static_assert(!requires { elements(0); });\n+  static_assert(!requires { 0 | elements; });\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n   test03();\n+  test04();\n }"}, {"sha": "e0f6b8d4c4b439e8f8d2c46ac7d536fc77d82bbe", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/filter.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ffilter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ffilter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ffilter.cc?ref=a25321ca06f61e5aeadc00923249f83af72059c5", "patch": "@@ -123,6 +123,23 @@ test05()\n   VERIFY( ranges::equal(v, (int[]){2,4}) );\n }\n \n+template<auto filter = views::filter>\n+void\n+test06()\n+{\n+  // Verify SFINAE behavior.\n+  extern int x[5];\n+  auto p = [] (int*) { return true; };\n+  static_assert(!requires { filter(); });\n+  static_assert(!requires { filter(x, p, p); });\n+  static_assert(!requires { filter(x, p); });\n+  static_assert(!requires { filter(p)(x); });\n+  static_assert(!requires { x | (filter(p) | views::all); });\n+  static_assert(!requires { (filter(p) | views::all)(x); });\n+  static_assert(!requires { filter | views::all; });\n+  static_assert(!requires { views::all | filter; });\n+}\n+\n int\n main()\n {\n@@ -132,4 +149,5 @@ main()\n   test04();\n   test05<forward_iterator_wrapper>();\n   test05<random_access_iterator_wrapper>();\n+  test06();\n }"}, {"sha": "fb06a7698afc1d75fc598858d126934d9ff01556", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/join.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fjoin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fjoin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fjoin.cc?ref=a25321ca06f61e5aeadc00923249f83af72059c5", "patch": "@@ -149,6 +149,17 @@ test08()\n   VERIFY( i->a == 5 );\n }\n \n+template<auto join = views::join>\n+void\n+test09()\n+{\n+  // Verify SFINAE behavior.\n+  static_assert(!requires { join(); });\n+  static_assert(!requires { join(0, 0); });\n+  static_assert(!requires { join(0); });\n+  static_assert(!requires { 0 | join; });\n+}\n+\n int\n main()\n {\n@@ -160,4 +171,5 @@ main()\n   test06();\n   test07();\n   test08();\n+  test09();\n }"}, {"sha": "c916a5ea8b7a9eb0f08aadb83339e45f6a45b853", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/p2281.cc", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fp2281.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fp2281.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fp2281.cc?ref=a25321ca06f61e5aeadc00923249f83af72059c5", "patch": "@@ -0,0 +1,83 @@\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <ranges>\n+#include <string>\n+#include <string_view>\n+#include <testsuite_hooks.h>\n+\n+namespace ranges = std::ranges;\n+namespace views = std::ranges::views;\n+\n+// Verify P2281 changes to the forwarding semantics of partial application\n+// and composition of range adaptor objects.\n+\n+void\n+test01()\n+{\n+  auto split_into_strings = [] (auto p) {\n+    return views::split(p) | views::transform([](auto r){\n+      return std::string(r.begin(), ranges::next(r.begin(), r.end()));\n+    });\n+  };\n+  constexpr std::string_view s = \"hello world\";\n+  constexpr std::string_view p = \" \";\n+  constexpr auto v1 = s | split_into_strings(p);\n+  constexpr auto v2 = split_into_strings(p)(s);\n+  VERIFY( ranges::equal(v1, (std::string_view[]){\"hello\", \"world\"}) );\n+  VERIFY( ranges::equal(v2, (std::string_view[]){\"hello\", \"world\"}) );\n+}\n+\n+struct move_only_range\n+{\n+  move_only_range() { }\n+  move_only_range(move_only_range&&);\n+  move_only_range& operator=(move_only_range&&);\n+  move_only_range(const move_only_range&) = delete;\n+  move_only_range& operator=(const move_only_range&) = delete;\n+  char* begin();\n+  char* end();\n+};\n+\n+template<>\n+  inline constexpr bool std::ranges::enable_view<move_only_range> = true;\n+\n+template<auto split = views::split>\n+void\n+test02()\n+{\n+  std::string_view s;\n+  move_only_range p;\n+  static_assert(requires { s | split(std::move(p)); });\n+  static_assert(requires { split(std::move(p))(s); });\n+  static_assert(requires { split(std::move(p)) | views::all; });\n+  static_assert(requires { views::all | split(std::move(p)); });\n+  static_assert(!requires { split(p); });\n+  static_assert(!requires { split(p) | views::all; });\n+  static_assert(!requires { views::all | split(p); });\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "47e34eb6581fe2ea763370aabe5eb6e49473c288", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/reverse.cc", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Freverse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Freverse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Freverse.cc?ref=a25321ca06f61e5aeadc00923249f83af72059c5", "patch": "@@ -138,7 +138,8 @@ namespace test_ns\n   void make_reverse_iterator(T&&) {}\n } // namespace test_ns\n \n-void test06()\n+void\n+test06()\n {\n   // Check that views::reverse works and does not use ADL which could lead\n   // to accidentally finding test_ns::make_reverse_iterator(A*).\n@@ -149,6 +150,17 @@ void test06()\n   static_assert( std::ranges::range<const V> );\n }\n \n+template<auto reverse = views::reverse>\n+void\n+test07()\n+{\n+  // Verify SFINAE behavior.\n+  static_assert(!requires { reverse(); });\n+  static_assert(!requires { reverse(0, 0); });\n+  static_assert(!requires { reverse(0); });\n+  static_assert(!requires { 0 | reverse; });\n+}\n+\n int\n main()\n {\n@@ -158,4 +170,5 @@ main()\n   test04();\n   test05();\n   test06();\n+  test07();\n }"}, {"sha": "b9fb3728708adb2ff89f41775819d91bdfa7070c", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/split.cc", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fsplit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fsplit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fsplit.cc?ref=a25321ca06f61e5aeadc00923249f83af72059c5", "patch": "@@ -39,7 +39,7 @@ test01()\n {\n   auto x = \"the  quick  brown  fox\"sv;\n   auto p = std::string{\"  \"};\n-  auto v = x | views::split(p);\n+  auto v = x | views::split(views::all(p)); // views::all is needed here after P2281.\n   auto i = v.begin();\n   VERIFY( ranges::equal(*i++, \"the\"sv) );\n   VERIFY( ranges::equal(*i++, \"quick\"sv) );\n@@ -83,7 +83,7 @@ test04()\n   static_assert(!ranges::view<decltype(p)>);\n   static_assert(std::same_as<decltype(p | views::all),\n \t\t\t     ranges::ref_view<decltype(p)>>);\n-  auto v = x | views::split(p);\n+  auto v = x | views::split(views::all(p)); // views::all is needed here after P2281.\n   auto i = v.begin();\n   VERIFY( ranges::equal(*i++, \"the\"sv) );\n   VERIFY( ranges::equal(*i++, \"quick\"sv) );\n@@ -152,6 +152,36 @@ test08()\n   VERIFY( i == v.end() );\n }\n \n+template<auto split = views::split>\n+void\n+test09()\n+{\n+  // Verify SFINAE behavior.\n+  std::string s, p;\n+  static_assert(!requires { split(); });\n+  static_assert(!requires { split(s, p, 0); });\n+  static_assert(!requires { split(p)(); });\n+  static_assert(!requires { s | split; });\n+\n+  static_assert(!requires { s | split(p); });\n+  static_assert(!requires { split(p)(s); });\n+  static_assert(!requires { s | (split(p) | views::all); });\n+  static_assert(!requires { (split(p) | views::all)(s); });\n+\n+  static_assert(requires { s | split(views::all(p)); });\n+  static_assert(requires { split(views::all(p))(s); });\n+  static_assert(requires { s | (split(views::all(p)) | views::all); });\n+  static_assert(requires { (split(views::all(p)) | views::all)(s); });\n+\n+  auto adapt = split(p);\n+  static_assert(requires { s | adapt; });\n+  static_assert(requires { adapt(s); });\n+\n+  auto adapt2 = split(p) | views::all;\n+  static_assert(requires { s | adapt2; });\n+  static_assert(requires { adapt2(s); });\n+}\n+\n int\n main()\n {\n@@ -163,4 +193,5 @@ main()\n   test06();\n   test07();\n   test08();\n+  test09();\n }"}, {"sha": "4229314a9dc5e47e5499093d4fb13a99f0590993", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/split_neg.cc", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fsplit_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fsplit_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fsplit_neg.cc?ref=a25321ca06f61e5aeadc00923249f83af72059c5", "patch": "@@ -30,20 +30,16 @@ test01()\n {\n   using namespace std::literals;\n   auto x = \"the  quick  brown  fox\"sv;\n-  auto v = views::split(x, std::initializer_list<char>{' ', ' '});\n-  v.begin(); // { dg-error \"\" }\n+  auto v = views::split(x, std::initializer_list<char>{' ', ' '}); // { dg-error \"no match\" }\n }\n \n void\n test02()\n {\n   using namespace std::literals;\n   auto x = \"the  quick  brown  fox\"sv;\n-  auto v = x | views::split(std::initializer_list<char>{' ', ' '}); // { dg-error \"no match\" }\n-  v.begin();\n+  auto v1 = views::split(std::initializer_list<char>{' ', ' '})(x); // { dg-error \"deleted\" }\n+  auto v2 = x | views::split(std::initializer_list<char>{' ', ' '}); // { dg-error \"no match\" }\n }\n \n // { dg-prune-output \"in requirements\" }\n-// { dg-error \"deduction failed\" \"\" { target *-*-* } 0 }\n-// { dg-error \"no match\" \"\" { target *-*-* } 0 }\n-// { dg-error \"constraint failure\" \"\" { target *-*-* } 0 }"}, {"sha": "55f748247376308d69fab014fb971679281dbe9d", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/take.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ftake.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ftake.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ftake.cc?ref=a25321ca06f61e5aeadc00923249f83af72059c5", "patch": "@@ -100,6 +100,23 @@ test05()\n   b = ranges::end(v);\n }\n \n+template<auto take = views::take>\n+void\n+test06()\n+{\n+  // Verify SFINAE behavior.\n+  extern int x[5];\n+  int* n = 0;\n+  static_assert(!requires { take(); });\n+  static_assert(!requires { take(x, n, n); });\n+  static_assert(!requires { take(x, n); });\n+  static_assert(!requires { take(n)(x); });\n+  static_assert(!requires { x | (take(n) | views::all); });\n+  static_assert(!requires { (take(n) | views::all)(x); });\n+  static_assert(!requires { take | views::all; });\n+  static_assert(!requires { views::all | take; });\n+}\n+\n int\n main()\n {\n@@ -108,4 +125,5 @@ main()\n   test03();\n   test04();\n   test05();\n+  test06();\n }"}, {"sha": "1ab8df3bc62b266c308e9f1e5c4b226aead34609", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/take_while.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ftake_while.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ftake_while.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ftake_while.cc?ref=a25321ca06f61e5aeadc00923249f83af72059c5", "patch": "@@ -79,11 +79,29 @@ test04()\n   static_assert(!ranges::range<decltype(v) const>);\n }\n \n+template<auto take_while = views::take_while>\n+void\n+test05()\n+{\n+  // Verify SFINAE behavior.\n+  extern int x[5];\n+  auto p = [] (int*) { return true; };\n+  static_assert(!requires { take_while(); });\n+  static_assert(!requires { take_while(x, p, p); });\n+  static_assert(!requires { take_while(x, p); });\n+  static_assert(!requires { take_while(p)(x); });\n+  static_assert(!requires { x | (take_while(p) | views::all); });\n+  static_assert(!requires { (take_while(p) | views::all)(x); });\n+  static_assert(!requires { take_while | views::all; });\n+  static_assert(!requires { views::all | take_while; });\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n   test03();\n   test04();\n+  test05();\n }"}, {"sha": "ab2f28a2111683b2769e49680d214238c310edd3", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/transform.cc", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ftransform.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25321ca06f61e5aeadc00923249f83af72059c5/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ftransform.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ftransform.cc?ref=a25321ca06f61e5aeadc00923249f83af72059c5", "patch": "@@ -145,6 +145,33 @@ test06()\n   VERIFY( (next(b_const, 2) - b_const) == 2 );\n }\n \n+void\n+test07()\n+{\n+  int x[] = {1,2,3,4,5};\n+  auto v1 = views::transform([] (auto& x) { return &x; });\n+  auto v2 = views::transform([] (auto x) { return *x; });\n+  auto v = x | (v1 | v2);\n+  VERIFY( ranges::equal(v, x) );\n+}\n+\n+template<auto transform = views::transform>\n+void\n+test08()\n+{\n+  // Verify SFINAE behavior.\n+  extern int x[5];\n+  auto f = [] (int* e) { return e; };\n+  static_assert(!requires { transform(); });\n+  static_assert(!requires { transform(x, f, f); });\n+  static_assert(!requires { transform(x, f); });\n+  static_assert(!requires { transform(f)(x); });\n+  static_assert(!requires { x | (transform(f) | views::all); });\n+  static_assert(!requires { (transform(f) | views::all)(x); });\n+  static_assert(!requires { transform | views::all; });\n+  static_assert(!requires { views::all | transform; });\n+}\n+\n int\n main()\n {\n@@ -154,4 +181,6 @@ main()\n   test04();\n   test05();\n   test06();\n+  test07();\n+  test08();\n }"}]}