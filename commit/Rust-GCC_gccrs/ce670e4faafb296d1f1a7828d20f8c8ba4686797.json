{"sha": "ce670e4faafb296d1f1a7828d20f8c8ba4686797", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2U2NzBlNGZhYWZiMjk2ZDFmMWE3ODI4ZDIwZjhjOGJhNDY4Njc5Nw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-18T13:17:34Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-09T12:41:42Z"}, "message": "tree-optimization/97832 - handle associatable chains in SLP discovery\n\nThis makes SLP discovery handle associatable (including mixed\nplus/minus) chains better by swapping operands across the whole\nchain.  To work this adds caching of the 'matches' lanes for\nfailed SLP discovery attempts, thereby fixing a failed SLP\ndiscovery for the slp-pr98855.cc testcase which results in\nbuilding an operand from scalars as expected.  Unfortunately\nthis makes us trip over the cost threshold so I'm XFAILing the\ntestcase for now.\n\nFor BB vectorization all this doesn't work because we have no way\nto distinguish good from bad associations as we eventually build\noperands from scalars and thus not fail in the classical sense.\n\n2021-05-31  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/97832\n\t* tree-vectorizer.h (_slp_tree::failed): New.\n\t* tree-vect-slp.c (_slp_tree::_slp_tree): Initialize\n\tfailed member.\n\t(_slp_tree::~_slp_tree): Free failed.\n\t(vect_build_slp_tree): Retain failed nodes and record\n\tmatches in them, copying that back out when running\n\tinto a cached fail.  Dump start and end of discovery.\n\t(dt_sort_cmp): New.\n\t(vect_build_slp_tree_2): Handle associatable chains\n\ttogether doing more aggressive operand swapping.\n\n\t* gcc.dg/vect/pr97832-1.c: New testcase.\n\t* gcc.dg/vect/pr97832-2.c: Likewise.\n\t* gcc.dg/vect/pr97832-3.c: Likewise.\n\t* g++.dg/vect/slp-pr98855.cc: XFAIL.", "tree": {"sha": "32e1806d019c44ba59b0fef020ccd2c661ce69d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32e1806d019c44ba59b0fef020ccd2c661ce69d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce670e4faafb296d1f1a7828d20f8c8ba4686797", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce670e4faafb296d1f1a7828d20f8c8ba4686797", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce670e4faafb296d1f1a7828d20f8c8ba4686797", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce670e4faafb296d1f1a7828d20f8c8ba4686797/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13a39886940331149173b25d6ebde0850668d8b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13a39886940331149173b25d6ebde0850668d8b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13a39886940331149173b25d6ebde0850668d8b9"}], "stats": {"total": 570, "additions": 560, "deletions": 10}, "files": [{"sha": "b101032669899760ce007401ad331e179455c335", "filename": "gcc/testsuite/g++.dg/vect/slp-pr98855.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce670e4faafb296d1f1a7828d20f8c8ba4686797/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fslp-pr98855.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce670e4faafb296d1f1a7828d20f8c8ba4686797/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fslp-pr98855.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fslp-pr98855.cc?ref=ce670e4faafb296d1f1a7828d20f8c8ba4686797", "patch": "@@ -81,4 +81,6 @@ void encrypt_n(const uint8_t in[], uint8_t out[], size_t blocks, uint32_t *EK)\n     }\n }\n \n-// { dg-final { scan-tree-dump-times \"not vectorized: vectorization is not profitable\" 2 \"slp1\" { target x86_64-*-* i?86-*-* } } }\n+// This used to work on { target x86_64-*-* i?86-*-* } but a fix in SLP\n+// discovery makes us trip over the threshold again.\n+// { dg-final { scan-tree-dump-times \"not vectorized: vectorization is not profitable\" 2 \"slp1\" { xfail *-*-* } } }"}, {"sha": "063fc7bd717e980518025fb48e4c47aa38538220", "filename": "gcc/testsuite/gcc.dg/vect/pr97832-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce670e4faafb296d1f1a7828d20f8c8ba4686797/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr97832-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce670e4faafb296d1f1a7828d20f8c8ba4686797/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr97832-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr97832-1.c?ref=ce670e4faafb296d1f1a7828d20f8c8ba4686797", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-Ofast\" } */\n+/* { dg-require-effective-target vect_double } */\n+\n+double a[1024], b[1024], c[1024];\n+\n+void foo()\n+{\n+  for (int i = 0; i < 256; ++i)\n+    {\n+      a[2*i] = a[2*i] + b[2*i] - c[2*i];\n+      a[2*i+1] = a[2*i+1] - b[2*i+1] - c[2*i+1];\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump \"vectorizing stmts using SLP\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump \"Loop contains only SLP stmts\" \"vect\" } } */"}, {"sha": "4f0578120eecc4aed62d295cfe85f82e6cf71565", "filename": "gcc/testsuite/gcc.dg/vect/pr97832-2.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce670e4faafb296d1f1a7828d20f8c8ba4686797/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr97832-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce670e4faafb296d1f1a7828d20f8c8ba4686797/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr97832-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr97832-2.c?ref=ce670e4faafb296d1f1a7828d20f8c8ba4686797", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-Ofast\" } */\n+/* { dg-require-effective-target vect_double } */\n+\n+void foo1x1(double* restrict y, const double* restrict x, int clen)\n+{\n+  int xi = clen & 2;\n+  double f_re = x[0+xi+0];\n+  double f_im = x[4+xi+0];\n+  int clen2 = (clen+xi) * 2;\n+#pragma GCC unroll 0\n+  for (int c = 0; c < clen2; c += 8) {\n+    // y[c] = y[c] - x[c]*conj(f);\n+#pragma GCC unroll 4\n+    for (int k = 0; k < 4; ++k) {\n+      double x_re = x[c+0+k];\n+      double x_im = x[c+4+k];\n+      double y_re = y[c+0+k];\n+      double y_im = y[c+4+k];\n+      y_re = y_re - x_re * f_re - x_im * f_im;;\n+      y_im = y_im + x_re * f_im - x_im * f_re;\n+      y[c+0+k] = y_re;\n+      y[c+4+k] = y_im;\n+    }\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump \"vectorizing stmts using SLP\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump \"Loop contains only SLP stmts\" \"vect\" } } */"}, {"sha": "ad1225ddbaae661ada33100cc7b27ca0247e5bbb", "filename": "gcc/testsuite/gcc.dg/vect/pr97832-3.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce670e4faafb296d1f1a7828d20f8c8ba4686797/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr97832-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce670e4faafb296d1f1a7828d20f8c8ba4686797/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr97832-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr97832-3.c?ref=ce670e4faafb296d1f1a7828d20f8c8ba4686797", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-Ofast\" } */\n+/* { dg-require-effective-target vect_double } */\n+\n+void foo(double* restrict y, const double* restrict x0, const double* restrict x1, int clen)\n+{\n+  int xi = clen & 2;\n+  double f00_re = x0[0+xi+0];\n+  double f10_re = x1[0+xi+0];\n+  double f01_re = x0[0+xi+1];\n+  double f11_re = x1[0+xi+1];\n+  double f00_im = x0[4+xi+0];\n+  double f10_im = x1[4+xi+0];\n+  double f01_im = x0[4+xi+1];\n+  double f11_im = x1[4+xi+1];\n+  int clen2 = (clen+xi) * 2;\n+  double* y0 = &y[0];\n+  double* y1 = &y[clen2];\n+  #pragma GCC unroll 0\n+  for (int c = 0; c < clen2; c += 8) {\n+    // y0[c] = y0[c] - x0[c]*conj(f00) - x1[c]*conj(f10);\n+    // y1[c] = y1[c] - x0[c]*conj(f01) - x1[c]*conj(f11);\n+    #pragma GCC unroll 4\n+    for (int k = 0; k < 4; ++k) {\n+      double x0_re = x0[c+0+k];\n+      double x0_im = x0[c+4+k];\n+      double y0_re = y0[c+0+k];\n+      double y0_im = y0[c+4+k];\n+      double y1_re = y1[c+0+k];\n+      double y1_im = y1[c+4+k];\n+      y0_re = y0_re - x0_re * f00_re - x0_im * f00_im;\n+      y0_im = y0_im + x0_re * f00_im - x0_im * f00_re;\n+      y1_re = y1_re - x0_re * f01_re - x0_im * f01_im;\n+      y1_im = y1_im + x0_re * f01_im - x0_im * f01_re;\n+      double x1_re = x1[c+0+k];\n+      double x1_im = x1[c+4+k];\n+      y0_re = y0_re - x1_re * f10_re - x1_im * f10_im;\n+      y0_im = y0_im + x1_re * f10_im - x1_im * f10_re;\n+      y1_re = y1_re - x1_re * f11_re - x1_im * f11_im;\n+      y1_im = y1_im + x1_re * f11_im - x1_im * f11_re;\n+      y0[c+0+k] = y0_re;\n+      y0[c+4+k] = y0_im;\n+      y1[c+0+k] = y1_re;\n+      y1[c+4+k] = y1_im;\n+    }\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump \"vectorizing stmts using SLP\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump \"Loop contains only SLP stmts\" \"vect\" } } */"}, {"sha": "17509e622a5fb206d3d72e440c6e73d1b82e2d9c", "filename": "gcc/testsuite/gcc.dg/vect/slp-50.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce670e4faafb296d1f1a7828d20f8c8ba4686797/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-50.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce670e4faafb296d1f1a7828d20f8c8ba4686797/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-50.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-50.c?ref=ce670e4faafb296d1f1a7828d20f8c8ba4686797", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-ffast-math\" } */\n+\n+typedef int Quantum;\n+typedef struct {\n+  Quantum blue, green;\n+} PixelPacket;\n+PixelPacket *EnhanceImage_image_q;\n+int EnhanceImage_image_x;\n+float EnhanceImage_image_distance_squared_total_weight;\n+void EnhanceImage_image_distance_squared()\n+{\n+  float zero_1;\n+  for (; EnhanceImage_image_x; EnhanceImage_image_x++) {\n+      EnhanceImage_image_distance_squared_total_weight += 5.0;\n+      EnhanceImage_image_q->green = EnhanceImage_image_q->blue =\n+\t  zero_1 + EnhanceImage_image_distance_squared_total_weight / 2 - 1;\n+      EnhanceImage_image_q++;\n+  }\n+}"}, {"sha": "1915d74070b9fae21fa30dfa6a05e86157ac712e", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 436, "deletions": 9, "changes": 445, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce670e4faafb296d1f1a7828d20f8c8ba4686797/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce670e4faafb296d1f1a7828d20f8c8ba4686797/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=ce670e4faafb296d1f1a7828d20f8c8ba4686797", "patch": "@@ -52,6 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n \n static bool vectorizable_slp_permutation (vec_info *, gimple_stmt_iterator *,\n \t\t\t\t\t  slp_tree, stmt_vector_for_cost *);\n+static void vect_print_slp_tree (dump_flags_t, dump_location_t, slp_tree);\n \n static object_allocator<_slp_tree> *slp_tree_pool;\n static slp_tree slp_first_node;\n@@ -108,6 +109,7 @@ _slp_tree::_slp_tree ()\n   SLP_TREE_VECTYPE (this) = NULL_TREE;\n   SLP_TREE_REPRESENTATIVE (this) = NULL;\n   SLP_TREE_REF_COUNT (this) = 1;\n+  this->failed = NULL;\n   this->max_nunits = 1;\n   this->lanes = 0;\n }\n@@ -129,6 +131,8 @@ _slp_tree::~_slp_tree ()\n   SLP_TREE_VEC_DEFS (this).release ();\n   SLP_TREE_LOAD_PERMUTATION (this).release ();\n   SLP_TREE_LANE_PERMUTATION (this).release ();\n+  if (this->failed)\n+    free (failed);\n }\n \n /* Recursively free the memory allocated for the SLP tree rooted at NODE.  */\n@@ -1414,6 +1418,30 @@ bst_traits::equal (value_type existing, value_type candidate)\n   return true;\n }\n \n+/* ???  This was std::pair<std::pair<tree_code, vect_def_type>, tree>\n+   but then vec::insert does memmove and that's not compatible with\n+   std::pair.  */\n+struct chain_op_t\n+{\n+  chain_op_t (tree_code code_, vect_def_type dt_, tree op_)\n+      : code (code_), dt (dt_), op (op_) {}\n+  tree_code code;\n+  vect_def_type dt;\n+  tree op;\n+};\n+\n+/* Comparator for sorting associatable chains.  */\n+\n+static int\n+dt_sort_cmp (const void *op1_, const void *op2_, void *)\n+{\n+  auto *op1 = (const chain_op_t *) op1_;\n+  auto *op2 = (const chain_op_t *) op2_;\n+  if (op1->dt != op2->dt)\n+    return (int)op1->dt - (int)op2->dt;\n+  return (int)op1->code - (int)op2->code;\n+}\n+\n typedef hash_map <vec <stmt_vec_info>, slp_tree,\n \t\t  simple_hashmap_traits <bst_traits, slp_tree> >\n   scalar_stmts_to_slp_tree_map_t;\n@@ -1436,14 +1464,16 @@ vect_build_slp_tree (vec_info *vinfo,\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location, \"re-using %sSLP tree %p\\n\",\n-\t\t\t *leader ? \"\" : \"failed \", *leader);\n-      if (*leader)\n+\t\t\t !(*leader)->failed ? \"\" : \"failed \", *leader);\n+      if (!(*leader)->failed)\n \t{\n \t  SLP_TREE_REF_COUNT (*leader)++;\n \t  vect_update_max_nunits (max_nunits, (*leader)->max_nunits);\n \t  stmts.release ();\n+\t  return *leader;\n \t}\n-      return *leader;\n+      memcpy (matches, (*leader)->failed, sizeof (bool) * group_size);\n+      return NULL;\n     }\n \n   /* Seed the bst_map with a stub node to be filled by vect_build_slp_tree_2\n@@ -1458,34 +1488,42 @@ vect_build_slp_tree (vec_info *vinfo,\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"SLP discovery limit exceeded\\n\");\n-      bool existed_p = bst_map->put (stmts, NULL);\n-      gcc_assert (existed_p);\n       /* Mark the node invalid so we can detect those when still in use\n \t as backedge destinations.  */\n       SLP_TREE_SCALAR_STMTS (res) = vNULL;\n       SLP_TREE_DEF_TYPE (res) = vect_uninitialized_def;\n-      vect_free_slp_tree (res);\n+      res->failed = XNEWVEC (bool, group_size);\n+      memset (res->failed, 0, sizeof (bool) * group_size);\n       memset (matches, 0, sizeof (bool) * group_size);\n       return NULL;\n     }\n   --*limit;\n \n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"starting SLP discovery for node %p\\n\", res);\n+\n   poly_uint64 this_max_nunits = 1;\n   slp_tree res_ = vect_build_slp_tree_2 (vinfo, res, stmts, group_size,\n \t\t\t\t\t&this_max_nunits,\n \t\t\t\t\tmatches, limit, tree_size, bst_map);\n   if (!res_)\n     {\n-      bool existed_p = bst_map->put (stmts, NULL);\n-      gcc_assert (existed_p);\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"SLP discovery for node %p failed\\n\", res);\n       /* Mark the node invalid so we can detect those when still in use\n \t as backedge destinations.  */\n       SLP_TREE_SCALAR_STMTS (res) = vNULL;\n       SLP_TREE_DEF_TYPE (res) = vect_uninitialized_def;\n-      vect_free_slp_tree (res);\n+      res->failed = XNEWVEC (bool, group_size);\n+      memcpy (res->failed, matches, sizeof (bool) * group_size);\n     }\n   else\n     {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"SLP discovery for node %p succeeded\\n\", res);\n       gcc_assert (res_ == res);\n       res->max_nunits = this_max_nunits;\n       vect_update_max_nunits (max_nunits, this_max_nunits);\n@@ -1495,6 +1533,48 @@ vect_build_slp_tree (vec_info *vinfo,\n   return res_;\n }\n \n+/* Helper for building an associated SLP node chain.  */\n+\n+static void\n+vect_slp_build_two_operator_nodes (slp_tree perm,\n+\t\t\t\t   slp_tree op0, slp_tree op1,\n+\t\t\t\t   stmt_vec_info oper1, stmt_vec_info oper2,\n+\t\t\t\t   vec<std::pair<unsigned, unsigned> > lperm)\n+{\n+  unsigned group_size = SLP_TREE_LANES (op1);\n+  tree vectype = SLP_TREE_VECTYPE (op1);\n+\n+  slp_tree child1 = new _slp_tree;\n+  SLP_TREE_DEF_TYPE (child1) = vect_internal_def;\n+  SLP_TREE_VECTYPE (child1) = vectype;\n+  SLP_TREE_LANES (child1) = group_size;\n+  SLP_TREE_CHILDREN (child1).create (2);\n+  SLP_TREE_CHILDREN (child1).quick_push (op0);\n+  SLP_TREE_CHILDREN (child1).quick_push (op1);\n+  SLP_TREE_REPRESENTATIVE (child1) = oper1;\n+\n+  slp_tree child2 = new _slp_tree;\n+  SLP_TREE_DEF_TYPE (child2) = vect_internal_def;\n+  SLP_TREE_VECTYPE (child2) = vectype;\n+  SLP_TREE_LANES (child2) = group_size;\n+  SLP_TREE_CHILDREN (child2).create (2);\n+  SLP_TREE_CHILDREN (child2).quick_push (op0);\n+  SLP_TREE_REF_COUNT (op0)++;\n+  SLP_TREE_CHILDREN (child2).quick_push (op1);\n+  SLP_TREE_REF_COUNT (op1)++;\n+  SLP_TREE_REPRESENTATIVE (child2) = oper2;\n+\n+  SLP_TREE_DEF_TYPE (perm) = vect_internal_def;\n+  SLP_TREE_CODE (perm) = VEC_PERM_EXPR;\n+  SLP_TREE_VECTYPE (perm) = vectype;\n+  SLP_TREE_LANES (perm) = group_size;\n+  /* ???  We should set this NULL but that's not expected.  */\n+  SLP_TREE_REPRESENTATIVE (perm) = oper1;\n+  SLP_TREE_LANE_PERMUTATION (perm) = lperm;\n+  SLP_TREE_CHILDREN (perm).quick_push (child1);\n+  SLP_TREE_CHILDREN (perm).quick_push (child2);\n+}\n+\n /* Recursively build an SLP tree starting from NODE.\n    Fail (and return a value not equal to zero) if def-stmts are not\n    isomorphic, require data permutation or are of unsupported types of\n@@ -1672,6 +1752,353 @@ vect_build_slp_tree_2 (vec_info *vinfo, slp_tree node,\n       SLP_TREE_CHILDREN (node).quick_push (vnode);\n       return node;\n     }\n+  /* When discovery reaches an associatable operation see whether we can\n+     improve that to match up lanes in a way superior to the operand\n+     swapping code which at most looks at two defs.\n+     ???  For BB vectorization we cannot do the brute-force search\n+     for matching as we can succeed by means of builds from scalars\n+     and have no good way to \"cost\" one build against another.  */\n+  else if (is_a <loop_vec_info> (vinfo)\n+\t   /* ???  We don't handle !vect_internal_def defs below.  */\n+\t   && STMT_VINFO_DEF_TYPE (stmt_info) == vect_internal_def\n+\t   && is_gimple_assign (stmt_info->stmt)\n+\t   && (associative_tree_code (gimple_assign_rhs_code (stmt_info->stmt))\n+\t       || gimple_assign_rhs_code (stmt_info->stmt) == MINUS_EXPR)\n+\t   && ((FLOAT_TYPE_P (vectype) && flag_associative_math)\n+\t       || (INTEGRAL_TYPE_P (TREE_TYPE (vectype))\n+\t\t   && TYPE_OVERFLOW_WRAPS (TREE_TYPE (vectype)))))\n+    {\n+      /* See if we have a chain of (mixed) adds or subtracts or other\n+\t associatable ops.  */\n+      enum tree_code code = gimple_assign_rhs_code (stmt_info->stmt);\n+      if (code == MINUS_EXPR)\n+\tcode = PLUS_EXPR;\n+      stmt_vec_info other_op_stmt_info = NULL;\n+      stmt_vec_info op_stmt_info = NULL;\n+      unsigned chain_len = 0;\n+      auto_vec<chain_op_t> chain;\n+      auto_vec<std::pair<tree_code, gimple *> > worklist;\n+      auto_vec<vec<chain_op_t> > chains (group_size);\n+      auto_vec<slp_tree, 4> children;\n+      bool hard_fail = true;\n+      for (unsigned lane = 0; lane < group_size; ++lane)\n+\t{\n+\t  /* For each lane linearize the addition/subtraction (or other\n+\t     uniform associatable operation) expression tree.  */\n+\t  worklist.safe_push (std::make_pair (code, stmts[lane]->stmt));\n+\t  while (!worklist.is_empty ())\n+\t    {\n+\t      auto entry = worklist.pop ();\n+\t      gassign *stmt = as_a <gassign *> (entry.second);\n+\t      enum tree_code in_code = entry.first;\n+\t      enum tree_code this_code = gimple_assign_rhs_code (stmt);\n+\t      /* Pick some stmts suitable for SLP_TREE_REPRESENTATIVE.  */\n+\t      if (!op_stmt_info\n+\t\t  && gimple_assign_rhs_code (stmt) == code)\n+\t\top_stmt_info = vinfo->lookup_stmt (stmt);\n+\t      else if (!other_op_stmt_info\n+\t\t       && gimple_assign_rhs_code (stmt) == MINUS_EXPR)\n+\t\tother_op_stmt_info = vinfo->lookup_stmt (stmt);\n+\t      for (unsigned opnum = 1; opnum <= 2; ++opnum)\n+\t\t{\n+\t\t  tree op = gimple_op (stmt, opnum);\n+\t\t  vect_def_type dt;\n+\t\t  stmt_vec_info def_stmt_info;\n+\t\t  bool res = vect_is_simple_use (op, vinfo, &dt, &def_stmt_info);\n+\t\t  gcc_assert (res);\n+\t\t  gimple *use_stmt;\n+\t\t  use_operand_p use_p;\n+\t\t  if (dt == vect_internal_def\n+\t\t      && single_imm_use (op, &use_p, &use_stmt)\n+\t\t      && is_gimple_assign (def_stmt_info->stmt)\n+\t\t      && (gimple_assign_rhs_code (def_stmt_info->stmt) == code\n+\t\t\t  || (code == PLUS_EXPR\n+\t\t\t      && (gimple_assign_rhs_code (def_stmt_info->stmt)\n+\t\t\t\t  == MINUS_EXPR))))\n+\t\t    {\n+\t\t      tree_code op_def_code = this_code;\n+\t\t      if (op_def_code == MINUS_EXPR && opnum == 1)\n+\t\t\top_def_code = PLUS_EXPR;\n+\t\t      if (in_code == MINUS_EXPR)\n+\t\t\top_def_code\n+\t\t\t  = op_def_code == PLUS_EXPR ? MINUS_EXPR : PLUS_EXPR;\n+\t\t      worklist.safe_push (std::make_pair (op_def_code,\n+\t\t\t\t\t\t\t  def_stmt_info->stmt));\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      tree_code op_def_code = this_code;\n+\t\t      if (op_def_code == MINUS_EXPR && opnum == 1)\n+\t\t\top_def_code = PLUS_EXPR;\n+\t\t      if (in_code == MINUS_EXPR)\n+\t\t\top_def_code\n+\t\t\t  = op_def_code == PLUS_EXPR ? MINUS_EXPR : PLUS_EXPR;\n+\t\t      chain.safe_push (chain_op_t (op_def_code, dt, op));\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  if (chain.length () == 2)\n+\t    {\n+\t      /* In a chain of just two elements resort to the regular\n+\t\t operand swapping scheme.  If we run into a length\n+\t\t mismatch still hard-FAIL.  */\n+\t      if (chain_len == 0)\n+\t\thard_fail = false;\n+\t      break;\n+\t    }\n+\t  else if (chain_len == 0)\n+\t    chain_len = chain.length ();\n+\t  else if (chain.length () != chain_len)\n+\t    /* ???  Here we could slip in magic to compensate with\n+\t       neutral operands.  */\n+\t    break;\n+\t  chains.quick_push (chain.copy ());\n+\t  chain.truncate (0);\n+\t}\n+      if (chains.length () == group_size)\n+\t{\n+\t  /* Now we have a set of chains with the same length.  */\n+\t  /* 1. pre-sort according to def_type and operation.  */\n+\t  for (unsigned lane = 0; lane < group_size; ++lane)\n+\t    chains[lane].sort (dt_sort_cmp, vinfo);\n+\t  if (dump_enabled_p ())\n+\t    {\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"pre-sorted chains of %s\\n\",\n+\t\t\t       get_tree_code_name (code));\n+\t      for (unsigned lane = 0; lane < group_size; ++lane)\n+\t\t{\n+\t\t  for (unsigned opnum = 0; opnum < chain_len; ++opnum)\n+\t\t    dump_printf (MSG_NOTE, \"%s %T \",\n+\t\t\t\t get_tree_code_name (chains[lane][opnum].code),\n+\t\t\t\t chains[lane][opnum].op);\n+\t\t  dump_printf (MSG_NOTE, \"\\n\");\n+\t\t}\n+\t    }\n+\t  /* 2. try to build children nodes, associating as necessary.  */\n+\t  for (unsigned n = 0; n < chain_len; ++n)\n+\t    {\n+\t      vect_def_type dt = chains[0][n].dt;\n+\t      unsigned lane;\n+\t      for (lane = 0; lane < group_size; ++lane)\n+\t\tif (chains[lane][n].dt != dt)\n+\t\t  {\n+\t\t    if (dt == vect_constant_def\n+\t\t\t&& chains[lane][n].dt == vect_external_def)\n+\t\t      dt = vect_external_def;\n+\t\t    else if (dt == vect_external_def\n+\t\t\t     && chains[lane][n].dt == vect_constant_def)\n+\t\t      ;\n+\t\t    else\n+\t\t      break;\n+\t\t  }\n+\t      if (lane != group_size)\n+\t\t{\n+\t\t  if (dump_enabled_p ())\n+\t\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t     \"giving up on chain due to mismatched \"\n+\t\t\t\t     \"def types\\n\");\n+\t\t  goto out;\n+\t\t}\n+\t      if (dt == vect_constant_def\n+\t\t  || dt == vect_external_def)\n+\t\t{\n+\t\t/* We can always build those.  Might want to sort last\n+\t\t   or defer building.  */\n+\t\t   vec<tree> ops;\n+\t\t   ops.create (group_size);\n+\t\t   for (lane = 0; lane < group_size; ++lane)\n+\t\t     ops.quick_push (chains[lane][n].op);\n+\t\t   slp_tree child = vect_create_new_slp_node (ops);\n+\t\t   SLP_TREE_DEF_TYPE (child) = dt;\n+\t\t   children.safe_push (child);\n+\t\t}\n+\t      else if (dt != vect_internal_def)\n+\t\t{\n+\t\t  /* Not sure, we might need sth special.\n+\t\t     gcc.dg/vect/pr96854.c,\n+\t\t     gfortran.dg/vect/fast-math-pr37021.f90\n+\t\t     and gfortran.dg/vect/pr61171.f trigger.  */\n+\t\t  /* Soft-fail for now.  */\n+\t\t  hard_fail = false;\n+\t\t  goto out;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  vec<stmt_vec_info> op_stmts;\n+\t\t  op_stmts.create (group_size);\n+\t\t  slp_tree child = NULL;\n+\t\t  /* Brute-force our way.  We have to consider a lane\n+\t\t     failing after fixing an earlier fail up in the\n+\t\t     SLP discovery recursion.  So track the current\n+\t\t     permute per lane.  */\n+\t\t  unsigned *perms = XALLOCAVEC (unsigned, group_size);\n+\t\t  memset (perms, 0, sizeof (unsigned) * group_size);\n+\t\t  do\n+\t\t    {\n+\t\t      op_stmts.truncate (0);\n+\t\t      for (lane = 0; lane < group_size; ++lane)\n+\t\t\top_stmts.quick_push\n+\t\t\t  (vinfo->lookup_def (chains[lane][n].op));\n+\t\t      child = vect_build_slp_tree (vinfo, op_stmts,\n+\t\t\t\t\t\t   group_size, &this_max_nunits,\n+\t\t\t\t\t\t   matches, limit,\n+\t\t\t\t\t\t   &this_tree_size, bst_map);\n+\t\t      /* ???  We're likely getting too many fatal mismatches\n+\t\t\t here so maybe we want to ignore them (but then we\n+\t\t\t have no idea which lanes fatally mismatched).  */\n+\t\t      if (child || !matches[0])\n+\t\t\tbreak;\n+\t\t      /* Swap another lane we have not yet matched up into\n+\t\t\t lanes that did not match.  If we run out of\n+\t\t\t permute possibilities for a lane terminate the\n+\t\t\t search.  */\n+\t\t      bool term = false;\n+\t\t      for (lane = 1; lane < group_size; ++lane)\n+\t\t\tif (!matches[lane])\n+\t\t\t  {\n+\t\t\t    if (n + perms[lane] + 1 == chain_len)\n+\t\t\t      {\n+\t\t\t\tterm = true;\n+\t\t\t\tbreak;\n+\t\t\t      }\n+\t\t\t    std::swap (chains[lane][n],\n+\t\t\t\t       chains[lane][n + perms[lane] + 1]);\n+\t\t\t    perms[lane]++;\n+\t\t\t  }\n+\t\t      if (term)\n+\t\t\tbreak;\n+\t\t    }\n+\t\t  while (1);\n+\t\t  if (!child)\n+\t\t    {\n+\t\t      if (dump_enabled_p ())\n+\t\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t\t \"failed to match up op %d\\n\", n);\n+\t\t      op_stmts.release ();\n+\t\t      goto out;\n+\t\t    }\n+\t\t  if (dump_enabled_p ())\n+\t\t    {\n+\t\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t       \"matched up op %d to\\n\", n);\n+\t\t      vect_print_slp_tree (MSG_NOTE, vect_location, child);\n+\t\t    }\n+\t\t  children.safe_push (child);\n+\t\t}\n+\t    }\n+\t  /* 3. build SLP nodes to combine the chain.  */\n+\t  for (unsigned lane = 0; lane < group_size; ++lane)\n+\t    if (chains[lane][0].code != code)\n+\t      {\n+\t\t/* See if there's any alternate all-PLUS entry.  */\n+\t\tunsigned n;\n+\t\tfor (n = 1; n < chain_len; ++n)\n+\t\t  {\n+\t\t    for (lane = 0; lane < group_size; ++lane)\n+\t\t      if (chains[lane][n].code != code)\n+\t\t\tbreak;\n+\t\t    if (lane == group_size)\n+\t\t      break;\n+\t\t  }\n+\t\tif (n != chain_len)\n+\t\t  {\n+\t\t    /* Swap that in at first position.  */\n+\t\t    std::swap (children[0], children[n]);\n+\t\t    for (lane = 0; lane < group_size; ++lane)\n+\t\t      std::swap (chains[lane][0], chains[lane][n]);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    /* ???  When this triggers and we end up with two\n+\t\t       vect_constant/external_def up-front things break (ICE)\n+\t\t       spectacularly finding an insertion place for the\n+\t\t       all-constant op.  We should have a fully\n+\t\t       vect_internal_def operand though(?) so we can swap\n+\t\t       that into first place and then prepend the all-zero\n+\t\t       constant.  */\n+\t\t    if (dump_enabled_p ())\n+\t\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t       \"inserting constant zero to compensate \"\n+\t\t\t\t       \"for (partially) negated first \"\n+\t\t\t\t       \"operand\\n\");\n+\t\t    chain_len++;\n+\t\t    for (lane = 0; lane < group_size; ++lane)\n+\t\t      chains[lane].safe_insert\n+\t\t\t(0, chain_op_t (code, vect_constant_def, NULL_TREE));\n+\t\t    vec<tree> zero_ops;\n+\t\t    zero_ops.create (group_size);\n+\t\t    zero_ops.quick_push (build_zero_cst (TREE_TYPE (vectype)));\n+\t\t    for (lane = 1; lane < group_size; ++lane)\n+\t\t      zero_ops.quick_push (zero_ops[0]);\n+\t\t    slp_tree zero = vect_create_new_slp_node (zero_ops);\n+\t\t    SLP_TREE_DEF_TYPE (zero) = vect_constant_def;\n+\t\t    children.safe_insert (0, zero);\n+\t\t  }\n+\t\tbreak;\n+\t      }\n+\t  for (unsigned i = 1; i < children.length (); ++i)\n+\t    {\n+\t      slp_tree op0 = children[i - 1];\n+\t      slp_tree op1 = children[i];\n+\t      bool this_two_op = false;\n+\t      for (unsigned lane = 0; lane < group_size; ++lane)\n+\t\tif (chains[lane][i].code != chains[0][i].code)\n+\t\t  {\n+\t\t    this_two_op = true;\n+\t\t    break;\n+\t\t  }\n+\t      slp_tree child;\n+\t      if (i == children.length () - 1)\n+\t\tchild = vect_create_new_slp_node (node, stmts, 2);\n+\t      else\n+\t\tchild = vect_create_new_slp_node (2, ERROR_MARK);\n+\t      if (this_two_op)\n+\t\t{\n+\t\t  vec<std::pair<unsigned, unsigned> > lperm;\n+\t\t  lperm.create (group_size);\n+\t\t  for (unsigned lane = 0; lane < group_size; ++lane)\n+\t\t    lperm.quick_push (std::make_pair\n+\t\t      (chains[lane][i].code != chains[0][i].code, lane));\n+\t\t  vect_slp_build_two_operator_nodes (child, op0, op1,\n+\t\t\t\t\t\t     (chains[0][i].code == code\n+\t\t\t\t\t\t      ? op_stmt_info\n+\t\t\t\t\t\t      : other_op_stmt_info),\n+\t\t\t\t\t\t     (chains[0][i].code == code\n+\t\t\t\t\t\t      ? other_op_stmt_info\n+\t\t\t\t\t\t      : op_stmt_info),\n+\t\t\t\t\t\t     lperm);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  SLP_TREE_DEF_TYPE (child) = vect_internal_def;\n+\t\t  SLP_TREE_VECTYPE (child) = vectype;\n+\t\t  SLP_TREE_LANES (child) = group_size;\n+\t\t  SLP_TREE_CHILDREN (child).quick_push (op0);\n+\t\t  SLP_TREE_CHILDREN (child).quick_push (op1);\n+\t\t  SLP_TREE_REPRESENTATIVE (child)\n+\t\t    = (chains[0][i].code == code\n+\t\t       ? op_stmt_info : other_op_stmt_info);\n+\t\t}\n+\t      children[i] = child;\n+\t    }\n+\t  *tree_size += this_tree_size + 1;\n+\t  *max_nunits = this_max_nunits;\n+\t  while (!chains.is_empty ())\n+\t    chains.pop ().release ();\n+\t  return node;\n+\t}\n+out:\n+      while (!children.is_empty ())\n+\tvect_free_slp_tree (children.pop ());\n+      while (!chains.is_empty ())\n+\tchains.pop ().release ();\n+      /* Hard-fail, otherwise we might run into quadratic processing of the\n+\t chains starting one stmt into the chain again.  */\n+      if (hard_fail)\n+\treturn NULL;\n+      /* Fall thru to normal processing.  */\n+    }\n \n   /* Get at the operands, verifying they are compatible.  */\n   vec<slp_oprnd_info> oprnds_info = vect_create_oprnd_info (nops, group_size);"}, {"sha": "1fb46c6ba14da5a67f24d22c479708154ac65293", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce670e4faafb296d1f1a7828d20f8c8ba4686797/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce670e4faafb296d1f1a7828d20f8c8ba4686797/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=ce670e4faafb296d1f1a7828d20f8c8ba4686797", "patch": "@@ -167,6 +167,11 @@ struct _slp_tree {\n \n   int vertex;\n \n+  /* If not NULL this is a cached failed SLP discovery attempt with\n+     the lanes that failed during SLP discovery as 'false'.  This is\n+     a copy of the matches array.  */\n+  bool *failed;\n+\n   /* Allocate from slp_tree_pool.  */\n   static void *operator new (size_t);\n "}]}