{"sha": "6dca194d4b556dfe27cb7865142ad595f3a96c95", "node_id": "C_kwDOANBUbNoAKDZkY2ExOTRkNGI1NTZkZmUyN2NiNzg2NTE0MmFkNTk1ZjNhOTZjOTU", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-10-11T09:12:50Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-10-11T14:13:30Z"}, "message": "early-name-resolver: Add simple macro name resolution\n\nThis name resolver performs the same macro name resolution as what was\npreviously done by the AttrVisitor visitor and macro expander.\n\nIt also resolves macro expressions in builtin-macros properly, as well\nas expanded AST nodes when necessary.", "tree": {"sha": "ab6f92fd5f5ae883b15107bbdd54fdc2ee950f05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab6f92fd5f5ae883b15107bbdd54fdc2ee950f05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6dca194d4b556dfe27cb7865142ad595f3a96c95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dca194d4b556dfe27cb7865142ad595f3a96c95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dca194d4b556dfe27cb7865142ad595f3a96c95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dca194d4b556dfe27cb7865142ad595f3a96c95/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "113f73f368277deeea546f6133f7c85bcccb30f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/113f73f368277deeea546f6133f7c85bcccb30f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/113f73f368277deeea546f6133f7c85bcccb30f7"}], "stats": {"total": 1355, "additions": 1320, "deletions": 35}, "files": [{"sha": "d7d6e88055bedcdd948b3d8021e1dfaa24b38afb", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dca194d4b556dfe27cb7865142ad595f3a96c95/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dca194d4b556dfe27cb7865142ad595f3a96c95/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=6dca194d4b556dfe27cb7865142ad595f3a96c95", "patch": "@@ -88,6 +88,7 @@ GRS_OBJS = \\\n     rust/rust-ast-lower-base.o \\\n     rust/rust-ast-lower-pattern.o \\\n     rust/rust-ast-lower-item.o \\\n+    rust/rust-early-name-resolver.o \\\n     rust/rust-name-resolver.o \\\n     rust/rust-ast-resolve.o \\\n     rust/rust-ast-resolve-base.o \\"}, {"sha": "5e4eac599701df88a506828740ae3ef3011fd0ba", "filename": "gcc/rust/expand/rust-attribute-visitor.cc", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dca194d4b556dfe27cb7865142ad595f3a96c95/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dca194d4b556dfe27cb7865142ad595f3a96c95/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc?ref=6dca194d4b556dfe27cb7865142ad595f3a96c95", "patch": "@@ -2877,16 +2877,6 @@ AttrVisitor::visit (AST::MacroRulesDefinition &rules_def)\n       rules_def.mark_for_strip ();\n       return;\n     }\n-\n-  // I don't think any macro rules can be stripped in any way\n-\n-  auto path = Resolver::CanonicalPath::new_seg (rules_def.get_node_id (),\n-\t\t\t\t\t\trules_def.get_rule_name ());\n-  expander.resolver->get_macro_scope ().insert (path, rules_def.get_node_id (),\n-\t\t\t\t\t\trules_def.get_locus ());\n-  expander.mappings->insert_macro_def (&rules_def);\n-  rust_debug_loc (rules_def.get_locus (), \"inserting macro def: [%s]\",\n-\t\t  path.get ().c_str ());\n }\n \n void"}, {"sha": "706b5d4f21892ae827ede327d1003572ee48c375", "filename": "gcc/rust/expand/rust-macro-builtins.cc", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dca194d4b556dfe27cb7865142ad595f3a96c95/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dca194d4b556dfe27cb7865142ad595f3a96c95/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc?ref=6dca194d4b556dfe27cb7865142ad595f3a96c95", "patch": "@@ -24,6 +24,7 @@\n #include \"rust-macro-invoc-lexer.h\"\n #include \"rust-lex.h\"\n #include \"rust-parse.h\"\n+#include \"rust-early-name-resolver.h\"\n #include \"rust-attribute-visitor.h\"\n \n namespace Rust {\n@@ -70,9 +71,11 @@ try_expand_macro_expression (AST::Expr *expr, MacroExpander *expander)\n {\n   rust_assert (expander);\n \n-  auto vis = Rust::AttrVisitor (*expander);\n-  expr->accept_vis (vis);\n-  return expander->take_expanded_fragment (vis);\n+  auto attr_visitor = Rust::AttrVisitor (*expander);\n+  auto early_name_resolver = Resolver::EarlyNameResolver ();\n+  expr->accept_vis (early_name_resolver);\n+  expr->accept_vis (attr_visitor);\n+  return expander->take_expanded_fragment (attr_visitor);\n }\n \n /* Expand and then extract a string literal from the macro */"}, {"sha": "96b74daead95471942584499ef2da907125dac3d", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dca194d4b556dfe27cb7865142ad595f3a96c95/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dca194d4b556dfe27cb7865142ad595f3a96c95/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=6dca194d4b556dfe27cb7865142ad595f3a96c95", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-diagnostics.h\"\n #include \"rust-parse.h\"\n #include \"rust-attribute-visitor.h\"\n+#include \"rust-early-name-resolver.h\"\n \n namespace Rust {\n AST::ASTFragment\n@@ -138,32 +139,17 @@ MacroExpander::expand_invoc (AST::MacroInvocation &invoc, bool has_semicolon)\n   //      - else is unreachable\n   //  - derive container macro - unreachable\n \n-  // lookup the rules for this macro\n-  NodeId resolved_node = UNKNOWN_NODEID;\n-  NodeId source_node = UNKNOWN_NODEID;\n-  if (has_semicolon)\n-    source_node = invoc.get_macro_node_id ();\n-  else\n-    source_node = invoc.get_pattern_node_id ();\n-  auto seg\n-    = Resolver::CanonicalPath::new_seg (source_node,\n-\t\t\t\t\tinvoc_data.get_path ().as_string ());\n-\n-  bool found = resolver->get_macro_scope ().lookup (seg, &resolved_node);\n-  if (!found)\n-    {\n-      rust_error_at (invoc.get_locus (), \"unknown macro: [%s]\",\n-\t\t     seg.get ().c_str ());\n-      return;\n-    }\n+  auto fragment = AST::ASTFragment::create_error ();\n+  invoc_data.set_expander (this);\n \n   // lookup the rules\n   AST::MacroRulesDefinition *rules_def = nullptr;\n-  bool ok = mappings->lookup_macro_def (resolved_node, &rules_def);\n-  rust_assert (ok);\n+  bool ok = mappings->lookup_macro_invocation (invoc, &rules_def);\n \n-  auto fragment = AST::ASTFragment::create_error ();\n-  invoc_data.set_expander (this);\n+  // If there's no rule associated with the invocation, we can simply return\n+  // early. The early name resolver will have already emitted an error.\n+  if (!ok)\n+    return;\n \n   if (rules_def->is_builtin ())\n     fragment"}, {"sha": "c45a3bc07a83eb26cf4276ba12fb474cc738c115", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dca194d4b556dfe27cb7865142ad595f3a96c95/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dca194d4b556dfe27cb7865142ad595f3a96c95/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=6dca194d4b556dfe27cb7865142ad595f3a96c95", "patch": "@@ -25,6 +25,7 @@\n #include \"rust-ast.h\"\n #include \"rust-macro.h\"\n #include \"rust-hir-map.h\"\n+#include \"rust-early-name-resolver.h\"\n #include \"rust-name-resolver.h\"\n #include \"rust-macro-invoc-lexer.h\"\n \n@@ -323,10 +324,13 @@ struct MacroExpander\n     AST::ASTFragment old_fragment = std::move (expanded_fragment);\n     auto accumulator = std::vector<AST::SingleASTNode> ();\n     expanded_fragment = AST::ASTFragment::create_error ();\n+    auto early_name_resolver = Resolver::EarlyNameResolver ();\n \n     for (auto &node : old_fragment.get_nodes ())\n       {\n \texpansion_depth++;\n+\n+\tnode.accept_vis (early_name_resolver);\n \tnode.accept_vis (vis);\n \t// we'll decide the next move according to the outcome of the macro\n \t// expansion"}, {"sha": "6b1f1e9c52f8a824f833f5706525a637f5cf1a62", "filename": "gcc/rust/resolve/rust-early-name-resolver.cc", "status": "added", "additions": 1087, "deletions": 0, "changes": 1087, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dca194d4b556dfe27cb7865142ad595f3a96c95/gcc%2Frust%2Fresolve%2Frust-early-name-resolver.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dca194d4b556dfe27cb7865142ad595f3a96c95/gcc%2Frust%2Fresolve%2Frust-early-name-resolver.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-early-name-resolver.cc?ref=6dca194d4b556dfe27cb7865142ad595f3a96c95", "patch": "@@ -0,0 +1,1087 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-early-name-resolver.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-name-resolver.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+EarlyNameResolver::EarlyNameResolver ()\n+  : resolver (*Resolver::get ()), mappings (*Analysis::Mappings::get ())\n+{}\n+\n+void\n+EarlyNameResolver::go (AST::Crate &crate)\n+{\n+  // FIXME: Is that valid? Why is the regular name resolution doing\n+  // mappings->get_next_node_id()?\n+  resolver.get_macro_scope ().push (crate.get_node_id ());\n+\n+  for (auto &item : crate.items)\n+    item->accept_vis (*this);\n+\n+  // FIXME: Should we pop the macro scope?\n+}\n+\n+void\n+EarlyNameResolver::resolve_generic_args (AST::GenericArgs &generic_args)\n+{\n+  for (auto &arg : generic_args.get_generic_args ())\n+    arg.accept_vis (*this);\n+\n+  for (auto &arg : generic_args.get_binding_args ())\n+    arg.get_type ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::resolve_qualified_path_type (AST::QualifiedPathType &path)\n+{\n+  path.get_type ()->accept_vis (*this);\n+\n+  if (path.has_as_clause ())\n+    path.get_as_type_path ().accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::Token &tok)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::DelimTokenTree &delim_tok_tree)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::AttrInputMetaItemContainer &input)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::IdentifierExpr &ident_expr)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::Lifetime &lifetime)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::LifetimeParam &lifetime_param)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::ConstGenericParam &const_param)\n+{}\n+\n+// FIXME: ARTHUR: Do we need to perform macro resolution for paths as well?\n+// std::arch::asm!()?\n+void\n+EarlyNameResolver::visit (AST::PathInExpression &path)\n+{\n+  for (auto &segment : path.get_segments ())\n+    if (segment.has_generic_args ())\n+      resolve_generic_args (segment.get_generic_args ());\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::TypePathSegment &segment)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::TypePathSegmentGeneric &segment)\n+{\n+  if (segment.has_generic_args ())\n+    resolve_generic_args (segment.get_generic_args ());\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::TypePathSegmentFunction &segment)\n+{\n+  for (auto &type : segment.get_type_path_function ().get_params ())\n+    type->accept_vis (*this);\n+\n+  segment.get_type_path_function ().get_return_type ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::TypePath &path)\n+{\n+  for (auto &seg : path.get_segments ())\n+    seg->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::QualifiedPathInExpression &path)\n+{\n+  resolve_qualified_path_type (path.get_qualified_path_type ());\n+\n+  for (auto &segment : path.get_segments ())\n+    if (segment.has_generic_args ())\n+      resolve_generic_args (segment.get_generic_args ());\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::QualifiedPathInType &path)\n+{\n+  resolve_qualified_path_type (path.get_qualified_path_type ());\n+\n+  for (auto &segment : path.get_segments ())\n+    segment->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::LiteralExpr &expr)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::AttrInputLiteral &attr_input)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::MetaItemLitExpr &meta_item)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::MetaItemPathLit &meta_item)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::BorrowExpr &expr)\n+{\n+  expr.get_borrowed_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::DereferenceExpr &expr)\n+{\n+  expr.get_dereferenced_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::ErrorPropagationExpr &expr)\n+{\n+  expr.get_propagating_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::NegationExpr &expr)\n+{\n+  expr.get_negated_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::ArithmeticOrLogicalExpr &expr)\n+{\n+  expr.get_left_expr ()->accept_vis (*this);\n+  expr.get_right_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::ComparisonExpr &expr)\n+{\n+  expr.get_left_expr ()->accept_vis (*this);\n+  expr.get_right_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::LazyBooleanExpr &expr)\n+{\n+  expr.get_left_expr ()->accept_vis (*this);\n+  expr.get_right_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::TypeCastExpr &expr)\n+{\n+  expr.get_casted_expr ()->accept_vis (*this);\n+  expr.get_type_to_cast_to ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::AssignmentExpr &expr)\n+{\n+  expr.get_left_expr ()->accept_vis (*this);\n+  expr.get_right_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::CompoundAssignmentExpr &expr)\n+{\n+  expr.get_left_expr ()->accept_vis (*this);\n+  expr.get_right_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::GroupedExpr &expr)\n+{\n+  expr.get_expr_in_parens ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::ArrayElemsValues &elems)\n+{\n+  for (auto &expr : elems.get_values ())\n+    expr->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::ArrayElemsCopied &elems)\n+{\n+  elems.get_elem_to_copy ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::ArrayExpr &expr)\n+{\n+  expr.get_array_elems ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::ArrayIndexExpr &expr)\n+{\n+  expr.get_array_expr ()->accept_vis (*this);\n+  expr.get_index_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::TupleExpr &expr)\n+{\n+  for (auto &elem : expr.get_tuple_elems ())\n+    elem->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::TupleIndexExpr &expr)\n+{\n+  expr.get_tuple_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::StructExprStruct &expr)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::StructExprFieldIdentifier &field)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::StructExprFieldIdentifierValue &field)\n+{\n+  field.get_value ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::StructExprFieldIndexValue &field)\n+{\n+  field.get_value ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::StructExprStructFields &expr)\n+{\n+  for (auto &field : expr.get_fields ())\n+    field->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::StructExprStructBase &expr)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::CallExpr &expr)\n+{\n+  expr.get_function_expr ()->accept_vis (*this);\n+  for (auto &param : expr.get_params ())\n+    param->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::MethodCallExpr &expr)\n+{\n+  expr.get_receiver_expr ()->accept_vis (*this);\n+  for (auto &param : expr.get_params ())\n+    param->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::FieldAccessExpr &expr)\n+{\n+  expr.get_receiver_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::ClosureExprInner &expr)\n+{\n+  expr.get_definition_expr ()->accept_vis (*this);\n+\n+  for (auto &param : expr.get_params ())\n+    param.get_type ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::BlockExpr &expr)\n+{\n+  for (auto &stmt : expr.get_statements ())\n+    stmt->accept_vis (*this);\n+\n+  if (expr.has_tail_expr ())\n+    expr.get_tail_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::ClosureExprInnerTyped &expr)\n+{\n+  expr.get_definition_block ()->accept_vis (*this);\n+\n+  for (auto &param : expr.get_params ())\n+    param.get_type ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::ContinueExpr &expr)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::BreakExpr &expr)\n+{\n+  if (expr.has_break_expr ())\n+    expr.get_break_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::RangeFromToExpr &expr)\n+{\n+  expr.get_from_expr ()->accept_vis (*this);\n+  expr.get_to_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::RangeFromExpr &expr)\n+{\n+  expr.get_from_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::RangeToExpr &expr)\n+{\n+  expr.get_to_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::RangeFullExpr &expr)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::RangeFromToInclExpr &expr)\n+{\n+  expr.get_from_expr ()->accept_vis (*this);\n+  expr.get_to_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::RangeToInclExpr &expr)\n+{\n+  expr.get_to_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::ReturnExpr &expr)\n+{\n+  if (expr.has_returned_expr ())\n+    expr.get_returned_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::UnsafeBlockExpr &expr)\n+{\n+  expr.get_block_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::LoopExpr &expr)\n+{\n+  expr.get_loop_block ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::WhileLoopExpr &expr)\n+{\n+  expr.get_predicate_expr ()->accept_vis (*this);\n+  expr.get_loop_block ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::WhileLetLoopExpr &expr)\n+{\n+  expr.get_scrutinee_expr ()->accept_vis (*this);\n+  expr.get_loop_block ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::ForLoopExpr &expr)\n+{\n+  expr.get_iterator_expr ()->accept_vis (*this);\n+  expr.get_loop_block ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::IfExpr &expr)\n+{\n+  expr.get_condition_expr ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::IfExprConseqElse &expr)\n+{\n+  expr.get_condition_expr ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+  expr.get_else_block ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::IfExprConseqIf &expr)\n+{\n+  expr.get_condition_expr ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+  expr.get_conseq_if_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::IfExprConseqIfLet &expr)\n+{\n+  expr.get_condition_expr ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+  expr.get_conseq_if_let_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::IfLetExpr &expr)\n+{\n+  expr.get_value_expr ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::IfLetExprConseqElse &expr)\n+{\n+  expr.get_value_expr ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+  expr.get_else_block ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::IfLetExprConseqIf &expr)\n+{\n+  expr.get_value_expr ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+  expr.get_conseq_if_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::IfLetExprConseqIfLet &expr)\n+{\n+  expr.get_value_expr ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+  expr.get_conseq_if_let_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::MatchExpr &expr)\n+{\n+  expr.get_scrutinee_expr ()->accept_vis (*this);\n+  for (auto &match_arm : expr.get_match_cases ())\n+    {\n+      if (match_arm.get_arm ().has_match_arm_guard ())\n+\tmatch_arm.get_arm ().get_guard_expr ()->accept_vis (*this);\n+\n+      for (auto &pattern : match_arm.get_arm ().get_patterns ())\n+\tpattern->accept_vis (*this);\n+\n+      match_arm.get_expr ()->accept_vis (*this);\n+    }\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::AwaitExpr &expr)\n+{\n+  expr.get_awaited_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::AsyncBlockExpr &expr)\n+{\n+  expr.get_block_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::TypeParam &param)\n+{\n+  for (auto &bound : param.get_type_param_bounds ())\n+    bound->accept_vis (*this);\n+\n+  if (param.has_type ())\n+    param.get_type ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::LifetimeWhereClauseItem &item)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::TypeBoundWhereClauseItem &item)\n+{\n+  for (auto &bound : item.get_type_param_bounds ())\n+    bound->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::Method &method)\n+{\n+  if (method.has_generics ())\n+    for (auto &generic : method.get_generic_params ())\n+      generic->accept_vis (*this);\n+\n+  if (method.get_self_param ().has_type ())\n+    method.get_self_param ().get_type ()->accept_vis (*this);\n+\n+  for (auto &param : method.get_function_params ())\n+    param.get_type ()->accept_vis (*this);\n+\n+  if (method.has_return_type ())\n+    method.get_return_type ()->accept_vis (*this);\n+\n+  method.get_definition ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::Module &module)\n+{\n+  for (auto &item : module.get_items ())\n+    item->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::ExternCrate &crate)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::UseTreeGlob &use_tree)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::UseTreeList &use_tree)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::UseTreeRebind &use_tree)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::UseDeclaration &use_decl)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::Function &function)\n+{\n+  if (function.has_generics ())\n+    for (auto &generic : function.get_generic_params ())\n+      generic->accept_vis (*this);\n+\n+  for (auto &param : function.get_function_params ())\n+    param.get_type ()->accept_vis (*this);\n+\n+  if (function.has_return_type ())\n+    function.get_return_type ()->accept_vis (*this);\n+\n+  function.get_definition ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::TypeAlias &type_alias)\n+{\n+  type_alias.get_type_aliased ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::StructStruct &struct_item)\n+{\n+  for (auto &field : struct_item.get_fields ())\n+    field.get_field_type ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::TupleStruct &tuple_struct)\n+{\n+  for (auto &field : tuple_struct.get_fields ())\n+    field.get_field_type ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::EnumItem &item)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::EnumItemTuple &item)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::EnumItemStruct &item)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::EnumItemDiscriminant &item)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::Enum &enum_item)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::Union &union_item)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::ConstantItem &const_item)\n+{\n+  const_item.get_type ()->accept_vis (*this);\n+  const_item.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::StaticItem &static_item)\n+{\n+  static_item.get_type ()->accept_vis (*this);\n+  static_item.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::TraitItemFunc &item)\n+{\n+  auto &decl = item.get_trait_function_decl ();\n+\n+  if (decl.has_return_type ())\n+    decl.get_return_type ()->accept_vis (*this);\n+\n+  for (auto &generic : decl.get_generic_params ())\n+    generic->accept_vis (*this);\n+\n+  for (auto &param : decl.get_function_params ())\n+    param.get_type ()->accept_vis (*this);\n+\n+  if (item.has_definition ())\n+    item.get_definition ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::TraitItemMethod &item)\n+{\n+  // FIXME: Can we factor this with the above function?\n+  auto &decl = item.get_trait_method_decl ();\n+\n+  if (decl.has_return_type ())\n+    decl.get_return_type ()->accept_vis (*this);\n+\n+  for (auto &generic : decl.get_generic_params ())\n+    generic->accept_vis (*this);\n+\n+  for (auto &param : decl.get_function_params ())\n+    param.get_type ()->accept_vis (*this);\n+\n+  if (item.has_definition ())\n+    item.get_definition ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::TraitItemConst &item)\n+{\n+  item.get_type ()->accept_vis (*this);\n+\n+  if (item.has_expr ())\n+    item.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::TraitItemType &item)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::Trait &trait)\n+{\n+  for (auto &item : trait.get_trait_items ())\n+    item->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::InherentImpl &impl)\n+{\n+  impl.get_type ()->accept_vis (*this);\n+\n+  for (auto &generic : impl.get_generic_params ())\n+    generic->accept_vis (*this);\n+\n+  for (auto &item : impl.get_impl_items ())\n+    item->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::TraitImpl &impl)\n+{\n+  impl.get_type ()->accept_vis (*this);\n+\n+  for (auto &generic : impl.get_generic_params ())\n+    generic->accept_vis (*this);\n+\n+  for (auto &item : impl.get_impl_items ())\n+    item->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::ExternalStaticItem &item)\n+{\n+  item.get_type ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::ExternalFunctionItem &item)\n+{\n+  for (auto &generic : item.get_generic_params ())\n+    generic->accept_vis (*this);\n+\n+  for (auto &param : item.get_function_params ())\n+    param.get_type ()->accept_vis (*this);\n+\n+  if (item.has_return_type ())\n+    item.get_return_type ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::ExternBlock &block)\n+{\n+  for (auto &item : block.get_extern_items ())\n+    item->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::MacroMatchFragment &match)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::MacroMatchRepetition &match)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::MacroMatcher &matcher)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::MacroRulesDefinition &rules_def)\n+{\n+  auto path = CanonicalPath::new_seg (rules_def.get_node_id (),\n+\t\t\t\t      rules_def.get_rule_name ());\n+  resolver.get_macro_scope ().insert (path, rules_def.get_node_id (),\n+\t\t\t\t      rules_def.get_locus ());\n+  mappings.insert_macro_def (&rules_def);\n+  rust_debug_loc (rules_def.get_locus (), \"inserting macro def: [%s]\",\n+\t\t  path.get ().c_str ());\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::MacroInvocation &invoc)\n+{\n+  auto &invoc_data = invoc.get_invoc_data ();\n+  auto has_semicolon = invoc.has_semicolon ();\n+\n+  // ??\n+  // switch on type of macro:\n+  //  - '!' syntax macro (inner switch)\n+  //      - procedural macro - \"A token-based function-like macro\"\n+  //      - 'macro_rules' (by example/pattern-match) macro? or not? \"an\n+  // AST-based function-like macro\"\n+  //      - else is unreachable\n+  //  - attribute syntax macro (inner switch)\n+  //  - procedural macro attribute syntax - \"A token-based attribute\n+  // macro\"\n+  //      - legacy macro attribute syntax? - \"an AST-based attribute macro\"\n+  //      - non-macro attribute: mark known\n+  //      - else is unreachable\n+  //  - derive macro (inner switch)\n+  //      - derive or legacy derive - \"token-based\" vs \"AST-based\"\n+  //      - else is unreachable\n+  //  - derive container macro - unreachable\n+\n+  // lookup the rules for this macro\n+  NodeId resolved_node = UNKNOWN_NODEID;\n+  NodeId source_node = UNKNOWN_NODEID;\n+  if (has_semicolon)\n+    source_node = invoc.get_macro_node_id ();\n+  else\n+    source_node = invoc.get_pattern_node_id ();\n+  auto seg\n+    = CanonicalPath::new_seg (source_node, invoc_data.get_path ().as_string ());\n+\n+  bool found = resolver.get_macro_scope ().lookup (seg, &resolved_node);\n+  if (!found)\n+    {\n+      rust_error_at (invoc.get_locus (), \"unknown macro: [%s]\",\n+\t\t     seg.get ().c_str ());\n+      return;\n+    }\n+\n+  // lookup the rules\n+  AST::MacroRulesDefinition *rules_def = nullptr;\n+  bool ok = mappings.lookup_macro_def (resolved_node, &rules_def);\n+  rust_assert (ok);\n+\n+  mappings.insert_macro_invocation (invoc, rules_def);\n+}\n+\n+// FIXME: ARTHUR: Do we need to resolve these as well here?\n+\n+void\n+EarlyNameResolver::visit (AST::MetaItemPath &meta_item)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::MetaItemSeq &meta_item)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::MetaWord &meta_item)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::MetaNameValueStr &meta_item)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::MetaListPaths &meta_item)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::MetaListNameValueStr &meta_item)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::LiteralPattern &pattern)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::IdentifierPattern &pattern)\n+{\n+  if (pattern.has_pattern_to_bind ())\n+    pattern.get_pattern_to_bind ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::WildcardPattern &pattern)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::RangePatternBoundLiteral &bound)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::RangePatternBoundPath &bound)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::RangePatternBoundQualPath &bound)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::RangePattern &pattern)\n+{\n+  pattern.get_lower_bound ()->accept_vis (*this);\n+  pattern.get_upper_bound ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::ReferencePattern &pattern)\n+{\n+  pattern.get_referenced_pattern ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::StructPatternFieldTuplePat &field)\n+{\n+  field.get_index_pattern ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::StructPatternFieldIdentPat &field)\n+{\n+  field.get_ident_pattern ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::StructPatternFieldIdent &field)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::StructPattern &pattern)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::TupleStructItemsNoRange &tuple_items)\n+{\n+  for (auto &pattern : tuple_items.get_patterns ())\n+    pattern->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::TupleStructItemsRange &tuple_items)\n+{\n+  for (auto &pattern : tuple_items.get_lower_patterns ())\n+    pattern->accept_vis (*this);\n+  for (auto &pattern : tuple_items.get_upper_patterns ())\n+    pattern->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::TupleStructPattern &pattern)\n+{\n+  pattern.get_items ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::TuplePatternItemsMultiple &tuple_items)\n+{\n+  for (auto &pattern : tuple_items.get_patterns ())\n+    pattern->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::TuplePatternItemsRanged &tuple_items)\n+{\n+  for (auto &pattern : tuple_items.get_lower_patterns ())\n+    pattern->accept_vis (*this);\n+  for (auto &pattern : tuple_items.get_upper_patterns ())\n+    pattern->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::TuplePattern &pattern)\n+{\n+  pattern.get_items ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::GroupedPattern &pattern)\n+{\n+  pattern.get_pattern_in_parens ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::SlicePattern &pattern)\n+{\n+  for (auto &item : pattern.get_items ())\n+    item->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::EmptyStmt &stmt)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::LetStmt &stmt)\n+{\n+  if (stmt.has_type ())\n+    stmt.get_type ()->accept_vis (*this);\n+\n+  if (stmt.has_init_expr ())\n+    stmt.get_init_expr ()->accept_vis (*this);\n+\n+  stmt.get_pattern ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::ExprStmtWithoutBlock &stmt)\n+{\n+  stmt.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::ExprStmtWithBlock &stmt)\n+{\n+  stmt.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+EarlyNameResolver::visit (AST::TraitBound &bound)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::ImplTraitType &type)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::TraitObjectType &type)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::ParenthesisedType &type)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::ImplTraitTypeOneBound &type)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::TraitObjectTypeOneBound &type)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::TupleType &type)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::NeverType &type)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::RawPointerType &type)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::ReferenceType &type)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::ArrayType &type)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::SliceType &type)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::InferredType &type)\n+{}\n+\n+void\n+EarlyNameResolver::visit (AST::BareFunctionType &type)\n+{\n+  for (auto &param : type.get_function_params ())\n+    param.get_type ()->accept_vis (*this);\n+\n+  if (type.has_return_type ())\n+    type.get_return_type ()->accept_vis (*this);\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "c53ab9f3d6ae29b9ae55cb415e466fe014eabc16", "filename": "gcc/rust/resolve/rust-early-name-resolver.h", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dca194d4b556dfe27cb7865142ad595f3a96c95/gcc%2Frust%2Fresolve%2Frust-early-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dca194d4b556dfe27cb7865142ad595f3a96c95/gcc%2Frust%2Fresolve%2Frust-early-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-early-name-resolver.h?ref=6dca194d4b556dfe27cb7865142ad595f3a96c95", "patch": "@@ -0,0 +1,210 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_EARLY_NAME_RESOLVER_H\n+#define RUST_EARLY_NAME_RESOLVER_H\n+\n+#include \"rust-name-resolver.h\"\n+#include \"rust-system.h\"\n+#include \"rust-ast.h\"\n+#include \"rust-ast-visitor.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class EarlyNameResolver : public AST::ASTVisitor\n+{\n+public:\n+  EarlyNameResolver ();\n+\n+  void go (AST::Crate &crate);\n+\n+private:\n+  Resolver &resolver;\n+  Analysis::Mappings &mappings;\n+\n+  /**\n+   * Early name-resolve generic args, which can be macro invocations\n+   */\n+  void resolve_generic_args (AST::GenericArgs &generic_args);\n+\n+  /**\n+   * Early name-resolve a qualified path type, which can contain macro\n+   * invocations\n+   */\n+  void resolve_qualified_path_type (AST::QualifiedPathType &path);\n+\n+  virtual void visit (AST::Token &tok);\n+  virtual void visit (AST::DelimTokenTree &delim_tok_tree);\n+  virtual void visit (AST::AttrInputMetaItemContainer &input);\n+  virtual void visit (AST::IdentifierExpr &ident_expr);\n+  virtual void visit (AST::Lifetime &lifetime);\n+  virtual void visit (AST::LifetimeParam &lifetime_param);\n+  virtual void visit (AST::ConstGenericParam &const_param);\n+  virtual void visit (AST::PathInExpression &path);\n+  virtual void visit (AST::TypePathSegment &segment);\n+  virtual void visit (AST::TypePathSegmentGeneric &segment);\n+  virtual void visit (AST::TypePathSegmentFunction &segment);\n+  virtual void visit (AST::TypePath &path);\n+  virtual void visit (AST::QualifiedPathInExpression &path);\n+  virtual void visit (AST::QualifiedPathInType &path);\n+  virtual void visit (AST::LiteralExpr &expr);\n+  virtual void visit (AST::AttrInputLiteral &attr_input);\n+  virtual void visit (AST::MetaItemLitExpr &meta_item);\n+  virtual void visit (AST::MetaItemPathLit &meta_item);\n+  virtual void visit (AST::BorrowExpr &expr);\n+  virtual void visit (AST::DereferenceExpr &expr);\n+  virtual void visit (AST::ErrorPropagationExpr &expr);\n+  virtual void visit (AST::NegationExpr &expr);\n+  virtual void visit (AST::ArithmeticOrLogicalExpr &expr);\n+  virtual void visit (AST::ComparisonExpr &expr);\n+  virtual void visit (AST::LazyBooleanExpr &expr);\n+  virtual void visit (AST::TypeCastExpr &expr);\n+  virtual void visit (AST::AssignmentExpr &expr);\n+  virtual void visit (AST::CompoundAssignmentExpr &expr);\n+  virtual void visit (AST::GroupedExpr &expr);\n+  virtual void visit (AST::ArrayElemsValues &elems);\n+  virtual void visit (AST::ArrayElemsCopied &elems);\n+  virtual void visit (AST::ArrayExpr &expr);\n+  virtual void visit (AST::ArrayIndexExpr &expr);\n+  virtual void visit (AST::TupleExpr &expr);\n+  virtual void visit (AST::TupleIndexExpr &expr);\n+  virtual void visit (AST::StructExprStruct &expr);\n+  virtual void visit (AST::StructExprFieldIdentifier &field);\n+  virtual void visit (AST::StructExprFieldIdentifierValue &field);\n+  virtual void visit (AST::StructExprFieldIndexValue &field);\n+  virtual void visit (AST::StructExprStructFields &expr);\n+  virtual void visit (AST::StructExprStructBase &expr);\n+  virtual void visit (AST::CallExpr &expr);\n+  virtual void visit (AST::MethodCallExpr &expr);\n+  virtual void visit (AST::FieldAccessExpr &expr);\n+  virtual void visit (AST::ClosureExprInner &expr);\n+  virtual void visit (AST::BlockExpr &expr);\n+  virtual void visit (AST::ClosureExprInnerTyped &expr);\n+  virtual void visit (AST::ContinueExpr &expr);\n+  virtual void visit (AST::BreakExpr &expr);\n+  virtual void visit (AST::RangeFromToExpr &expr);\n+  virtual void visit (AST::RangeFromExpr &expr);\n+  virtual void visit (AST::RangeToExpr &expr);\n+  virtual void visit (AST::RangeFullExpr &expr);\n+  virtual void visit (AST::RangeFromToInclExpr &expr);\n+  virtual void visit (AST::RangeToInclExpr &expr);\n+  virtual void visit (AST::ReturnExpr &expr);\n+  virtual void visit (AST::UnsafeBlockExpr &expr);\n+  virtual void visit (AST::LoopExpr &expr);\n+  virtual void visit (AST::WhileLoopExpr &expr);\n+  virtual void visit (AST::WhileLetLoopExpr &expr);\n+  virtual void visit (AST::ForLoopExpr &expr);\n+  virtual void visit (AST::IfExpr &expr);\n+  virtual void visit (AST::IfExprConseqElse &expr);\n+  virtual void visit (AST::IfExprConseqIf &expr);\n+  virtual void visit (AST::IfExprConseqIfLet &expr);\n+  virtual void visit (AST::IfLetExpr &expr);\n+  virtual void visit (AST::IfLetExprConseqElse &expr);\n+  virtual void visit (AST::IfLetExprConseqIf &expr);\n+  virtual void visit (AST::IfLetExprConseqIfLet &expr);\n+  virtual void visit (AST::MatchExpr &expr);\n+  virtual void visit (AST::AwaitExpr &expr);\n+  virtual void visit (AST::AsyncBlockExpr &expr);\n+  virtual void visit (AST::TypeParam &param);\n+  virtual void visit (AST::LifetimeWhereClauseItem &item);\n+  virtual void visit (AST::TypeBoundWhereClauseItem &item);\n+  virtual void visit (AST::Method &method);\n+  virtual void visit (AST::Module &module);\n+  virtual void visit (AST::ExternCrate &crate);\n+  virtual void visit (AST::UseTreeGlob &use_tree);\n+  virtual void visit (AST::UseTreeList &use_tree);\n+  virtual void visit (AST::UseTreeRebind &use_tree);\n+  virtual void visit (AST::UseDeclaration &use_decl);\n+  virtual void visit (AST::Function &function);\n+  virtual void visit (AST::TypeAlias &type_alias);\n+  virtual void visit (AST::StructStruct &struct_item);\n+  virtual void visit (AST::TupleStruct &tuple_struct);\n+  virtual void visit (AST::EnumItem &item);\n+  virtual void visit (AST::EnumItemTuple &item);\n+  virtual void visit (AST::EnumItemStruct &item);\n+  virtual void visit (AST::EnumItemDiscriminant &item);\n+  virtual void visit (AST::Enum &enum_item);\n+  virtual void visit (AST::Union &union_item);\n+  virtual void visit (AST::ConstantItem &const_item);\n+  virtual void visit (AST::StaticItem &static_item);\n+  virtual void visit (AST::TraitItemFunc &item);\n+  virtual void visit (AST::TraitItemMethod &item);\n+  virtual void visit (AST::TraitItemConst &item);\n+  virtual void visit (AST::TraitItemType &item);\n+  virtual void visit (AST::Trait &trait);\n+  virtual void visit (AST::InherentImpl &impl);\n+  virtual void visit (AST::TraitImpl &impl);\n+  virtual void visit (AST::ExternalStaticItem &item);\n+  virtual void visit (AST::ExternalFunctionItem &item);\n+  virtual void visit (AST::ExternBlock &block);\n+  virtual void visit (AST::MacroMatchFragment &match);\n+  virtual void visit (AST::MacroMatchRepetition &match);\n+  virtual void visit (AST::MacroMatcher &matcher);\n+  virtual void visit (AST::MacroRulesDefinition &rules_def);\n+  virtual void visit (AST::MacroInvocation &macro_invoc);\n+  virtual void visit (AST::MetaItemPath &meta_item);\n+  virtual void visit (AST::MetaItemSeq &meta_item);\n+  virtual void visit (AST::MetaWord &meta_item);\n+  virtual void visit (AST::MetaNameValueStr &meta_item);\n+  virtual void visit (AST::MetaListPaths &meta_item);\n+  virtual void visit (AST::MetaListNameValueStr &meta_item);\n+  virtual void visit (AST::LiteralPattern &pattern);\n+  virtual void visit (AST::IdentifierPattern &pattern);\n+  virtual void visit (AST::WildcardPattern &pattern);\n+  virtual void visit (AST::RangePatternBoundLiteral &bound);\n+  virtual void visit (AST::RangePatternBoundPath &bound);\n+  virtual void visit (AST::RangePatternBoundQualPath &bound);\n+  virtual void visit (AST::RangePattern &pattern);\n+  virtual void visit (AST::ReferencePattern &pattern);\n+  virtual void visit (AST::StructPatternFieldTuplePat &field);\n+  virtual void visit (AST::StructPatternFieldIdentPat &field);\n+  virtual void visit (AST::StructPatternFieldIdent &field);\n+  virtual void visit (AST::StructPattern &pattern);\n+  virtual void visit (AST::TupleStructItemsNoRange &tuple_items);\n+  virtual void visit (AST::TupleStructItemsRange &tuple_items);\n+  virtual void visit (AST::TupleStructPattern &pattern);\n+  virtual void visit (AST::TuplePatternItemsMultiple &tuple_items);\n+  virtual void visit (AST::TuplePatternItemsRanged &tuple_items);\n+  virtual void visit (AST::TuplePattern &pattern);\n+  virtual void visit (AST::GroupedPattern &pattern);\n+  virtual void visit (AST::SlicePattern &pattern);\n+  virtual void visit (AST::EmptyStmt &stmt);\n+  virtual void visit (AST::LetStmt &stmt);\n+  virtual void visit (AST::ExprStmtWithoutBlock &stmt);\n+  virtual void visit (AST::ExprStmtWithBlock &stmt);\n+  virtual void visit (AST::TraitBound &bound);\n+  virtual void visit (AST::ImplTraitType &type);\n+  virtual void visit (AST::TraitObjectType &type);\n+  virtual void visit (AST::ParenthesisedType &type);\n+  virtual void visit (AST::ImplTraitTypeOneBound &type);\n+  virtual void visit (AST::TraitObjectTypeOneBound &type);\n+  virtual void visit (AST::TupleType &type);\n+  virtual void visit (AST::NeverType &type);\n+  virtual void visit (AST::RawPointerType &type);\n+  virtual void visit (AST::ReferenceType &type);\n+  virtual void visit (AST::ArrayType &type);\n+  virtual void visit (AST::SliceType &type);\n+  virtual void visit (AST::InferredType &type);\n+  virtual void visit (AST::BareFunctionType &type);\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_EARLY_NAME_RESOLVER_H"}, {"sha": "b2214b1d7648fb9eb564cc24b9da788de3a784e9", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dca194d4b556dfe27cb7865142ad595f3a96c95/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dca194d4b556dfe27cb7865142ad595f3a96c95/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=6dca194d4b556dfe27cb7865142ad595f3a96c95", "patch": "@@ -38,6 +38,7 @@\n #include \"rust-imports.h\"\n #include \"rust-extern-crate.h\"\n #include \"rust-attributes.h\"\n+#include \"rust-early-name-resolver.h\"\n \n #include \"diagnostic.h\"\n #include \"input.h\"\n@@ -783,6 +784,9 @@ Session::injection (AST::Crate &crate)\n void\n Session::expansion (AST::Crate &crate)\n {\n+  /* We need to name resolve macros and imports here */\n+  Resolver::EarlyNameResolver ().go (crate);\n+\n   rust_debug (\"started expansion\");\n \n   /* rustc has a modification to windows PATH temporarily here, which may end"}]}