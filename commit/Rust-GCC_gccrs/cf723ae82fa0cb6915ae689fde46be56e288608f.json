{"sha": "cf723ae82fa0cb6915ae689fde46be56e288608f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y3MjNhZTgyZmEwY2I2OTE1YWU2ODlmZGU0NmJlNTZlMjg4NjA4Zg==", "commit": {"author": {"name": "Tan Shengguo", "email": "shengguo@sunnorth.com.cn", "date": "2006-10-16T02:13:06Z"}, "committer": {"name": "Chen Liqin", "email": "liqin@gcc.gnu.org", "date": "2006-10-16T02:13:06Z"}, "message": "crti.asm: add pic support.\n\n        * config/score/crti.asm: add pic support.\n        * config/score/crtn.asm: add pic support.\n        * config/score/score.h: remove builtin_define(\"__pic__\").\n        * config/score/score.c: add TARGET_RTX_COST macro.\n        * config/score/score.md: PIC support for call/sibcall pattern.\n        * config/score/mul-div.S: add pic support.\n        * config/score/t-score-elf: update MULTILIB_OPTIONS.\n        * ChangeLog: add shengguo as another score maintainer.\n        * config.sub: add score support in it.\n\nFrom-SVN: r117771", "tree": {"sha": "36ecf1de84b364717f7c04621ad8fbaf05e24bc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36ecf1de84b364717f7c04621ad8fbaf05e24bc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf723ae82fa0cb6915ae689fde46be56e288608f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf723ae82fa0cb6915ae689fde46be56e288608f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf723ae82fa0cb6915ae689fde46be56e288608f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf723ae82fa0cb6915ae689fde46be56e288608f/comments", "author": null, "committer": null, "parents": [{"sha": "c05b443868b215036a8d9ba52a1d2f62b2f25fc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c05b443868b215036a8d9ba52a1d2f62b2f25fc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c05b443868b215036a8d9ba52a1d2f62b2f25fc1"}], "stats": {"total": 826, "additions": 645, "deletions": 181}, "files": [{"sha": "841905daca09b8ed559096650c69e24aa4c2dab2", "filename": "ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf723ae82fa0cb6915ae689fde46be56e288608f/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf723ae82fa0cb6915ae689fde46be56e288608f/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=cf723ae82fa0cb6915ae689fde46be56e288608f", "patch": "@@ -1,3 +1,7 @@\n+2006-10-16  Tan Shengguo  <shengguo@sunnorth.com.cn>\n+\n+\t* MAINTAINERS: Add Tan Shengguo as score port maintainer.\n+\n 2006-10-10  Brooks Moses  <bmoses@stanford.edu>\n \n \t* Makefile.def: Added pdf target handling."}, {"sha": "5f1057239091305ac1b51a57f40f432485432008", "filename": "config.sub", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf723ae82fa0cb6915ae689fde46be56e288608f/config.sub", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf723ae82fa0cb6915ae689fde46be56e288608f/config.sub", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config.sub?ref=cf723ae82fa0cb6915ae689fde46be56e288608f", "patch": "@@ -909,6 +909,10 @@ case $basic_machine in\n \tsb1el)\n \t\tbasic_machine=mipsisa64sb1el-unknown\n \t\t;;\n+        score | score-*)\n+                basic_machine=score-sunplus\n+                os=-elf\n+                ;;\n \tsei)\n \t\tbasic_machine=mips-sei\n \t\tos=-seiux"}, {"sha": "2408596b213b0819316e4297e495ec333179a2f7", "filename": "gcc/config/score/crti.asm", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf723ae82fa0cb6915ae689fde46be56e288608f/gcc%2Fconfig%2Fscore%2Fcrti.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf723ae82fa0cb6915ae689fde46be56e288608f/gcc%2Fconfig%2Fscore%2Fcrti.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fcrti.asm?ref=cf723ae82fa0cb6915ae689fde46be56e288608f", "patch": "@@ -35,7 +35,8 @@\n # This file makes a stack frame for the contents of the .init and\n # .fini sections.\n \n-.section .init,\"ax\", @progbits\n+#ifndef __pic__\n+.section .init, \"ax\", @progbits\n         .weak   _start\n         .ent    _start\n         .frame  r0, 0, r3, 0\n@@ -81,5 +82,62 @@ _init:\n _fini:\n         addi    r0, -32\n         sw      r3, [r0, 20]\n+#else\n+.section .init, \"ax\", @progbits\n+        .set    pic\n+        .weak   _start\n+        .ent    _start\n+        .frame  r0, 0, r3, 0\n+        .mask   0x00000000,0\n+_start:\n+        la      r28, _gp\n+        la      r8, __bss_start\n+        la      r9, __bss_end__\n+        sub!    r9, r8\n+        srli!   r9, 2\n+        addi    r9, -1\n+        mtsr    r9, sr0\n+        li      r9, 0\n+1:\n+        sw      r9, [r8]+, 4\n+        bcnz    1b\n+        la      r0, _stack\n+#       jl      _init\n+#       la      r4, _end\n+#       jl      _init_argv\n+        ldiu!   r4, 0\n+        ldiu!   r5, 0\n+#       jl      main\n+        la      r29, main\n+        brl     r29\n+#       jl      exit\n+        la      r29, exit\n+        brl     r29\n+        .end    _start\n+\n+        .weak   _init_argv\n+        .ent\n+        .frame  r0, 0, r3, 0\n+        .mask   0x00000000, 0\n+_init_argv:\n+        ldiu!   r4, 0\n+        ldiu!   r5, 0\n+        j       main\n+        .end    _init_argv\n+\n+        .globl  _init\n+        .type   _init, %function\n+_init:\n+        addi    r0, -32\n+        sw      r3, [r0, 20]\n+\n+.section .fini, \"ax\", @progbits\n+        .globl  _fini\n+        .type   _fini, %function\n+_fini:\n+        addi    r0, -32\n+        sw      r3, [r0, 20]\n+\n+#endif\n \n "}, {"sha": "5048a99e435a3600a447d62a3e66f863db91e69c", "filename": "gcc/config/score/crtn.asm", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf723ae82fa0cb6915ae689fde46be56e288608f/gcc%2Fconfig%2Fscore%2Fcrtn.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf723ae82fa0cb6915ae689fde46be56e288608f/gcc%2Fconfig%2Fscore%2Fcrtn.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fcrtn.asm?ref=cf723ae82fa0cb6915ae689fde46be56e288608f", "patch": "@@ -35,6 +35,7 @@\n # This file makes sure that the .init and .fini sections do in\n # fact return.\n \n+#ifndef __pic__\n .section .init, \"ax\", @progbits\n         lw      r3, [r0, 20]\n         addi    r0, 32\n@@ -44,4 +45,18 @@\n         lw      r3, [r0, 20]\n         addi    r0, 32\n         br      r3\n+#else\n+        .set    pic\n+.section .init, \"ax\", @progbits\n+        lw      r3, [r0, 20]\n+        addi    r0, 32\n+        br      r3\n+\n+        .set    pic\n+.section .fini, \"ax\", @progbits\n+        lw      r3, [r0, 20]\n+        addi    r0, 32\n+        br      r3\n+#endif\n+\n "}, {"sha": "4dabe96f9745d8e444dea10bd912eacfcbde507c", "filename": "gcc/config/score/mul-div.S", "status": "modified", "additions": 327, "deletions": 145, "changes": 472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf723ae82fa0cb6915ae689fde46be56e288608f/gcc%2Fconfig%2Fscore%2Fmul-div.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf723ae82fa0cb6915ae689fde46be56e288608f/gcc%2Fconfig%2Fscore%2Fmul-div.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fmul-div.S?ref=cf723ae82fa0cb6915ae689fde46be56e288608f", "patch": "@@ -29,196 +29,378 @@\n #define t1 r9\n #define t2 r10\n #define t3 r11\n-\n #define t4 r22\n \n-#if defined(__scorebe__)\n-#define LIBGCC1_BIG_ENDIAN\n-#define out_H        v0\n-#define out_L        v1\n-#define in0_H        a0\n-#define in0_L        a1\n-#define in1_H        a2\n-#define in1_L        a3\n-#elif defined(__scorele__)\n-#define out_H        v1\n-#define out_L        v0\n-#define in0_H        a1\n-#define in0_L        a0\n-#define in1_H        a3\n-#define in1_L        a2\n-#else\n-#err  \"must specify S+core endian!\"\n-#endif\n-\n+#ifndef __pic__\n #if !defined(L_mulsi3) && !defined(L_divsi3)\n-               .text\n-               .global _flush_cache\n+       .text\n+       .global _flush_cache\n _flush_cache:\n-                srli    r9, r5, 4\n-                mv      r8, r4\n-                mtsr    r9, sr0\n+        srli    r9, r5, 4\n+        mv      r8, r4\n+        mtsr    r9, sr0\n 1:\n-                cache   0xe, [r8, 0]                  # write back invalid dcache\n-                addi    r8, 16\n-                bcnz    1b\n-                mfcr    r8, cr4\n-                bittst! r8, 0x3                       # if LDM is enable, write back LDM\n-                beq!    6f\n-                ldi     r10, 0\n-                cache   0xc, [r10, 0]\n+        cache   0xe, [r8, 0]            # write back invalid dcache\n+        addi    r8, 16\n+        bcnz    1b\n+        mfcr    r8, cr4\n+        bittst! r8, 0x3                 # if LDM is enable, write back LDM\n+        beq!    6f\n+        ldi     r10, 0\n+        cache   0xc, [r10, 0]\n 6:\n-                bittst! r8, 0x2                       # if LIM is enable, refill it\n-                beq!    7f\n-                cache   0x4, [r10, 0]\n+        bittst! r8, 0x2                 # if LIM is enable, refill it\n+        beq!    7f\n+        cache   0x4, [r10, 0]\n 7:\n-                #nop!\n-                #nop!\n-                #nop!\n-                #nop!\n-                #nop!\n-                mv      r8, r4\n-                mtsr    r9, sr0\n+        #nop!\n+        #nop!\n+        #nop!\n+        #nop!\n+        #nop!\n+        mv      r8, r4\n+        mtsr    r9, sr0\n 2:\n-                cache   0x2, [r8, 0]                  # invalid unlock icache\n-                #nop!\n-                #nop!\n-                #nop!\n-                #nop!\n-                #nop!\n-                addi    r8, 16\n-                bcnz    2b\n-                br      r3\n+        cache   0x2, [r8, 0]            # invalid unlock icache\n+        #nop!\n+        #nop!\n+        #nop!\n+        #nop!\n+        #nop!\n+        addi    r8, 16\n+        bcnz    2b\n+        br      r3\n #endif\n \n /* FUNCTION\n    (U) INT32 v0 = __mulsi3 ((U) INT32 a0, (U) INT32 a1);\n    REGISTERS:\n-        use             t0\n-        modify          a0\n-                        a1        -> become 0\n+        use     t0\n+        modify  a0\n+        a1      -> become 0\n    NOTE:\n-         this seems to give better performance to just rotate and add.  */\n+   this seems to give better performance to just rotate and add.  */\n \n #ifdef L_mulsi3\n-                .text\n-                .global __umulsi3\n-                .global __mulsi3\n-                /* signed multiplication (32x32)  */\n-                .ent    __mulsi3\n+        .text\n+        .global __umulsi3\n+        .global __mulsi3\n+        /* signed multiplication (32x32)  */\n+        .ent    __mulsi3\n __umulsi3:\n __mulsi3:\n-                li      t1, 0\n+        li      t1, 0\n __mulsi3_loop:\n-                andri.c t0, a1, 1                 /* t0 = multiplier[0]     */\n-                srli    a1, a1, 1                 /* a1 /= 2                */\n-                beq     __mulsi3_loop2            /* skip if (t0 == 0)      */\n-                add     t1, t1, a0                /* add multiplicand       */\n+        andri.c t0, a1, 1               # t0 = multiplier[0]\n+        srli    a1, a1, 1               # a1 /= 2\n+        beq     __mulsi3_loop2          # skip if (t0 == 0)\n+        add     t1, t1, a0              # add multiplicand\n __mulsi3_loop2:\n-                slli    a0, a0, 1                 /* multiplicand mul 2     */\n-                cmpi.c  a1, 0\n-                bne     __mulsi3_loop\n-                mv      r4, t1\n-                br      ra\n-                .end    __mulsi3\n+        slli    a0, a0, 1               # multiplicand mul 2\n+        cmpi.c  a1, 0\n+        bne     __mulsi3_loop\n+        mv      r4, t1\n+        br      ra\n+        .end    __mulsi3\n #endif /* L_mulsi3 */\n \n-\n /* FUNCTION\n    UINT32 (v0) = __udivsi3 (UINT32 (a0), UINT32 (a1));\n    INT32 (v0) = __divsi3 (INT32 (a0),  INT32 (a1));\n    UINT32 (v0) = __umodsi3 (UINT32 (a0), UINT32 (a1));\n    INT32 (v0) = __modsi3 (INT32 (a0),  INT32 (a1));\n    DESCRIPTION\n-        performs 32-bit division/modulo.\n+   performs 32-bit division/modulo.\n    REGISTERS\n-        used        t0        bit-index\n-                    t1\n-        modify      a0         becomes remainer  */\n+   used t0      bit-index\n+        t1\n+   modify a0    becomes remainer  */\n #ifdef L_divsi3\n-                .text\n-                .global __udivsi3\n-                .global __umodsi3\n-                .global __divsi3\n-                .global __modsi3\n-\n-                /* unsigned division  */\n-                .ent    __udivsi3\n+        .text\n+        .global __udivsi3\n+        .global __umodsi3\n+        .global __divsi3\n+        .global __modsi3\n+\n+        /* unsigned division  */\n+        .ent    __udivsi3\n __udivsi3:\n-                li      t4, 0\n-                cmpi.c  a1, 0\n-                beq     __uds_exit\n-                li      t0, 1\n-                blt     __uds_ok\n+        li      t4, 0\n+        cmpi.c  a1, 0\n+        beq     __uds_exit\n+        li      t0, 1\n+        blt     __uds_ok\n __uds_normalize:\n-                cmp.c   a0, a1\n-                bcc     __uds_ok\n-                slli    a1, a1, 1\n-                slli    t0, t0, 1\n-                cmpi.c  a1, 0\n-                bge     __uds_normalize\n+        cmp.c   a0, a1\n+        bcc     __uds_ok\n+        slli    a1, a1, 1\n+        slli    t0, t0, 1\n+        cmpi.c  a1, 0\n+        bge     __uds_normalize\n __uds_ok:\n __uds_loop2:\n-                cmp.c   a0, a1\n-                bcc     __uds_loop3\n-                sub     a0, a0, a1\n-                or      t4, t4, t0\n+        cmp.c   a0, a1\n+        bcc     __uds_loop3\n+        sub     a0, a0, a1\n+        or      t4, t4, t0\n __uds_loop3:\n-                srli    t0, t0, 1\n-                srli    a1, a1, 1\n-                cmpi.c  t0, 0\n-                bne     __uds_loop2\n+        srli    t0, t0, 1\n+        srli    a1, a1, 1\n+        cmpi.c  t0, 0\n+        bne     __uds_loop2\n __uds_exit:\n-                mv      a1, a0\n-                mv      r4, t4\n-                br      ra\n-                .end    __udivsi3\n+        mv      a1, a0\n+        mv      r4, t4\n+        br      ra\n+        .end    __udivsi3\n \n-                /* unsigned modulus  */\n-                .ent    __umodsi3\n+        /* unsigned modulus  */\n+        .ent    __umodsi3\n __umodsi3:\n-                mv      t3, ra\n-                jl      __udivsi3\n-                mv      r4, a1\n-                br      t3\n-                .end    __umodsi3\n-\n-                /* abs and div  */\n-                .ent    __orgsi3\n+        mv      t3, ra\n+        jl      __udivsi3\n+        mv      r4, a1\n+        br      t3\n+        .end    __umodsi3\n+\n+        /* abs and div  */\n+        .ent    __orgsi3\n __orgsi3:\n-                cmpi.c  a0, 0\n-                bge     __orgsi3_a0p\n-                neg     a0, a0\n+        cmpi.c  a0, 0\n+        bge     __orgsi3_a0p\n+        neg     a0, a0\n __orgsi3_a0p:\n-                cmpi.c  a1, 0\n-                bge     __udivsi3\n-                neg     a1, a1\n-                b       __udivsi3                /* goto udivsi3  */\n-                .end    __orgsi3\n-\n-                /* signed division  */\n-                .ent    __divsi3\n+        cmpi.c  a1, 0\n+        bge     __udivsi3\n+        neg     a1, a1\n+        b       __udivsi3               # goto udivsi3\n+        .end    __orgsi3\n+\n+        /* signed division  */\n+        .ent    __divsi3\n __divsi3:\n-                mv      t3, ra\n-                xor     t2, a0, a1\n-                jl      __orgsi3\n+        mv      t3, ra\n+        xor     t2, a0, a1\n+        jl      __orgsi3\n __divsi3_adjust:\n-                cmpi.c  t2, 0\n-                bge     __divsi3_exit\n-                neg     r4, r4\n+        cmpi.c  t2, 0\n+        bge     __divsi3_exit\n+        neg     r4, r4\n __divsi3_exit:\n-                br      t3\n-                .end    __divsi3\n+        br      t3\n+        .end    __divsi3\n \n-                /* signed modulus  */\n-                .ent    __modsi3\n+        /* signed modulus  */\n+        .ent    __modsi3\n __modsi3:\n-                mv      t3, ra\n-                mv      t2, a0\n-                jl      __orgsi3\n-                mv      r4, a1\n-                b       __divsi3_adjust\n-                .end    __modsi3\n+        mv      t3, ra\n+        mv      t2, a0\n+        jl      __orgsi3\n+        mv      r4, a1\n+        b       __divsi3_adjust\n+        .end    __modsi3\n \n #endif /* L_divsi3 */\n+#else /* -fPIC */\n+#if !defined(L_mulsi3) && !defined(L_divsi3)\n+        .set pic\n+        .text\n+        .global _flush_cache\n+_flush_cache:\n+        addi    r0, -8                  # pic used\n+        .cpload r29                     # pic used\n+        srli    r9, r5, 4\n+        mv      r8, r4\n+        mtsr    r9, sr0\n+1:\n+        cache   0xe, [r8, 0]            # write back invalid dcache\n+        addi    r8, 16\n+        bcnz    1b\n+        mfcr    r8, cr4\n+        bittst! r8, 0x3                 # if LDM is enable, write back LDM\n+        beq!    6f\n+        ldi     r10, 0\n+        cache   0xc, [r10, 0]\n+6:\n+        bittst! r8, 0x2                 # if LIM is enable, refill it\n+        beq!    7f\n+        cache   0x4, [r10, 0]\n+7:\n+        #nop!\n+        #nop!\n+        #nop!\n+        #nop!\n+        #nop!\n+        mv      r8, r4\n+        mtsr    r9, sr0\n+2:\n+        cache   0x2, [r8, 0]            # invalid unlock icache\n+        #nop!\n+        #nop!\n+        #nop!\n+        #nop!\n+        #nop!\n+        addi    r8, 16\n+        bcnz    2b\n+        .cprestore      12              # pic used\n+        addi    r0, 8                   # pic used\n+        br      r3\n+#endif\n+\n+/* FUNCTION\n+   (U) INT32 v0 = __mulsi3 ((U) INT32 a0, (U) INT32 a1);\n+   REGISTERS:\n+        use     t0\n+        modify  a0\n+        a1      -> become 0\n+   NOTE:\n+   this seems to give better performance to just rotate and add.  */\n+\n+#ifdef L_mulsi3\n+        .set pic\n+        .text\n+        .global __umulsi3\n+        .global __mulsi3\n+        /* signed multiplication (32x32)  */\n+        .ent    __mulsi3\n+__umulsi3:\n+__mulsi3:\n+        addi    r0, -8                  # pic used\n+        .cpload r29                     # pic used\n+        li      t1, 0\n+__mulsi3_loop:\n+        andri.c t0, a1, 1               # t0 = multiplier[0]\n+        srli    a1, a1, 1               # a1 /= 2\n+        beq     __mulsi3_loop2          # skip if (t0 == 0)\n+        add     t1, t1, a0              # add multiplicand\n+__mulsi3_loop2:\n+        slli    a0, a0, 1               # multiplicand mul 2\n+        cmpi.c  a1, 0\n+        bne     __mulsi3_loop\n+        mv      r4, t1\n+        .cprestore 12                   # pic used\n+        addi    r0, 8                   # pic used\n+        br      ra\n+        .end    __mulsi3\n+#endif /* L_mulsi3 */\n+\n+/* FUNCTION\n+   UINT32 (v0) = __udivsi3 (UINT32 (a0), UINT32 (a1));\n+   INT32 (v0) = __divsi3 (INT32 (a0),  INT32 (a1));\n+   UINT32 (v0) = __umodsi3 (UINT32 (a0), UINT32 (a1));\n+   INT32 (v0) = __modsi3 (INT32 (a0),  INT32 (a1));\n+   DESCRIPTION\n+   performs 32-bit division/modulo.\n+   REGISTERS\n+   used t0      bit-index\n+        t1\n+   modify a0    becomes remainer  */\n+#ifdef L_divsi3\n+        .set pic\n+        .text\n+        .global __udivsi3\n+        .global __umodsi3\n+        .global __divsi3\n+        .global __modsi3\n \n+        /* unsigned division  */\n+        .ent    __udivsi3\n+__udivsi3:\n+        addi    r0, -8                  # pic used\n+        .cpload r29                     # pic used\n+        li      t4, 0\n+        cmpi.c  a1, 0\n+        beq     __uds_exit\n+        li      t0, 1\n+        blt     __uds_ok\n+__uds_normalize:\n+        cmp.c   a0, a1\n+        bcc     __uds_ok\n+        slli    a1, a1, 1\n+        slli    t0, t0, 1\n+        cmpi.c  a1, 0\n+        bge     __uds_normalize\n+__uds_ok:\n+__uds_loop2:\n+        cmp.c   a0, a1\n+        bcc     __uds_loop3\n+        sub     a0, a0, a1\n+        or      t4, t4, t0\n+__uds_loop3:\n+        srli    t0, t0, 1\n+        srli    a1, a1, 1\n+        cmpi.c  t0, 0\n+        bne     __uds_loop2\n+__uds_exit:\n+        mv      a1, a0\n+        mv      r4, t4\n+        .cprestore 12                   # pic used\n+        addi    r0, 8                   # pic used\n+        br      ra\n+        .end    __udivsi3\n+\n+        /* unsigned modulus  */\n+        .ent    __umodsi3\n+__umodsi3:\n+        addi    r0, -8                  # pic used\n+        .cpload r29                     # pic used\n+        li      t1, 0\n+        mv      t3, ra\n+#       jl      __udivsi3\n+        la      r29, __udivsi3\n+        brl     r29\n+        mv      r4, a1\n+        .cprestore 12                   # pic used\n+        addi    r0, 8                   # pic used\n+        br      t3\n+        .end    __umodsi3\n+\n+        /* abs and div  */\n+        .ent    __orgsi3\n+__orgsi3:\n+        cmpi.c  a0, 0\n+        bge     __orgsi3_a0p\n+        neg     a0, a0\n+__orgsi3_a0p:\n+        cmpi.c  a1, 0\n+        bge     __udivsi3\n+        neg     a1, a1\n+        b       __udivsi3               # goto udivsi3\n+        .end    __orgsi3\n+\n+        /* signed division  */\n+        .ent    __divsi3\n+__divsi3:\n+        addi    r0, -8                  # pic used\n+        .cpload r29                     # pic used\n+        mv      t3, ra\n+        xor     t2, a0, a1\n+#       jl      __orgsi3\n+        la      r29, __orgsi3\n+        brl     r29\n+__divsi3_adjust:\n+        cmpi.c  t2, 0\n+        bge     __divsi3_exit\n+        neg     r4, r4\n+__divsi3_exit:\n+        .cprestore 12                   # pic used\n+        addi    r0, 8                   # pic used\n+        br      t3\n+        .end    __divsi3\n+\n+        /* signed modulus  */\n+        .ent    __modsi3\n+__modsi3:\n+        addi    r0, -8                  # pic used\n+        .cpload r29                     # pic used\n+        mv      t3, ra\n+        mv      t2, a0\n+#       jl      __orgsi3\n+        la      r29, __orgsi3\n+        brl     r29\n+        mv      r4, a1\n+        b       __divsi3_adjust\n+        .end    __modsi3\n+\n+#endif /*L_divsi3 */\n+#endif"}, {"sha": "323d40d1cbd72353d33a78e820e06a619d9dea29", "filename": "gcc/config/score/score.c", "status": "modified", "additions": 183, "deletions": 21, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf723ae82fa0cb6915ae689fde46be56e288608f/gcc%2Fconfig%2Fscore%2Fscore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf723ae82fa0cb6915ae689fde46be56e288608f/gcc%2Fconfig%2Fscore%2Fscore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.c?ref=cf723ae82fa0cb6915ae689fde46be56e288608f", "patch": "@@ -60,63 +60,71 @@\n #define CE_REG_CLASS_P(C) \\\n   ((C) == HI_REG || (C) == LO_REG || (C) == CE_REGS)\n \n-static int score_arg_partial_bytes (const CUMULATIVE_ARGS *cum,\n-                                    enum machine_mode mode,\n-                                    tree type, int named);\n+static int score_arg_partial_bytes (const CUMULATIVE_ARGS *,\n+                                    enum machine_mode, tree, int);\n+\n+static int score_symbol_insns (enum score_symbol_type);\n+\n+static int score_address_insns (rtx, enum machine_mode);\n+\n+static bool score_rtx_costs (rtx, int, int, int *);\n \n #undef  TARGET_ASM_FILE_START\n-#define TARGET_ASM_FILE_START                   th_asm_file_start\n+#define TARGET_ASM_FILE_START           th_asm_file_start\n \n #undef  TARGET_ASM_FILE_END\n-#define TARGET_ASM_FILE_END                     th_asm_file_end\n+#define TARGET_ASM_FILE_END             th_asm_file_end\n \n #undef  TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE            th_function_prologue\n+#define TARGET_ASM_FUNCTION_PROLOGUE    th_function_prologue\n \n #undef  TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE            th_function_epilogue\n+#define TARGET_ASM_FUNCTION_EPILOGUE    th_function_epilogue\n \n #undef  TARGET_SCHED_ISSUE_RATE\n-#define TARGET_SCHED_ISSUE_RATE                 th_issue_rate\n+#define TARGET_SCHED_ISSUE_RATE         th_issue_rate\n \n #undef TARGET_ASM_SELECT_RTX_SECTION\n-#define TARGET_ASM_SELECT_RTX_SECTION           th_select_rtx_section\n+#define TARGET_ASM_SELECT_RTX_SECTION   th_select_rtx_section\n \n #undef  TARGET_IN_SMALL_DATA_P\n-#define TARGET_IN_SMALL_DATA_P                  th_in_small_data_p\n+#define TARGET_IN_SMALL_DATA_P          th_in_small_data_p\n \n #undef  TARGET_FUNCTION_OK_FOR_SIBCALL\n-#define TARGET_FUNCTION_OK_FOR_SIBCALL          th_function_ok_for_sibcall\n+#define TARGET_FUNCTION_OK_FOR_SIBCALL  th_function_ok_for_sibcall\n \n #undef TARGET_STRICT_ARGUMENT_NAMING\n-#define TARGET_STRICT_ARGUMENT_NAMING           th_strict_argument_naming\n+#define TARGET_STRICT_ARGUMENT_NAMING   th_strict_argument_naming\n \n #undef TARGET_ASM_OUTPUT_MI_THUNK\n-#define TARGET_ASM_OUTPUT_MI_THUNK              th_output_mi_thunk\n+#define TARGET_ASM_OUTPUT_MI_THUNK      th_output_mi_thunk\n \n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n-#define TARGET_ASM_CAN_OUTPUT_MI_THUNK       hook_bool_tree_hwi_hwi_tree_true\n+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK  hook_bool_tree_hwi_hwi_tree_true\n \n #undef TARGET_PROMOTE_FUNCTION_ARGS\n-#define TARGET_PROMOTE_FUNCTION_ARGS            hook_bool_tree_true\n+#define TARGET_PROMOTE_FUNCTION_ARGS    hook_bool_tree_true\n \n #undef TARGET_PROMOTE_FUNCTION_RETURN\n-#define TARGET_PROMOTE_FUNCTION_RETURN          hook_bool_tree_true\n+#define TARGET_PROMOTE_FUNCTION_RETURN  hook_bool_tree_true\n \n #undef TARGET_PROMOTE_PROTOTYPES\n-#define TARGET_PROMOTE_PROTOTYPES               hook_bool_tree_true\n+#define TARGET_PROMOTE_PROTOTYPES       hook_bool_tree_true\n \n #undef TARGET_MUST_PASS_IN_STACK\n-#define TARGET_MUST_PASS_IN_STACK               must_pass_in_stack_var_size\n+#define TARGET_MUST_PASS_IN_STACK       must_pass_in_stack_var_size\n \n #undef TARGET_ARG_PARTIAL_BYTES\n-#define TARGET_ARG_PARTIAL_BYTES                score_arg_partial_bytes\n+#define TARGET_ARG_PARTIAL_BYTES        score_arg_partial_bytes\n \n #undef TARGET_PASS_BY_REFERENCE\n-#define TARGET_PASS_BY_REFERENCE                score_pass_by_reference\n+#define TARGET_PASS_BY_REFERENCE        score_pass_by_reference\n \n #undef TARGET_RETURN_IN_MEMORY\n-#define TARGET_RETURN_IN_MEMORY                 score_return_in_memory\n+#define TARGET_RETURN_IN_MEMORY         score_return_in_memory\n+\n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS                score_rtx_costs\n \n /* Implement TARGET_RETURN_IN_MEMORY.  In S+core,\n    small structures are returned in a register.\n@@ -880,6 +888,160 @@ score_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n   return 12;\n }\n \n+/* Return the number of instructions needed to load a symbol of the\n+   given type into a register.  */\n+static int\n+score_symbol_insns (enum score_symbol_type type)\n+{\n+  switch (type)\n+    {\n+    case SYMBOL_GENERAL:\n+      return 2;\n+\n+    case SYMBOL_SMALL_DATA:\n+      return 1;\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Return the number of instructions needed to load or store a value\n+   of mode MODE at X.  Return 0 if X isn't valid for MODE.  */\n+static int\n+score_address_insns (rtx x, enum machine_mode mode)\n+{\n+  struct score_address_info addr;\n+  int factor;\n+\n+  if (mode == BLKmode)\n+    /* BLKmode is used for single unaligned loads and stores.  */\n+    factor = 1;\n+  else\n+    /* Each word of a multi-word value will be accessed individually.  */\n+    factor = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\n+  if (mda_classify_address (&addr, mode, x, false))\n+    switch (addr.type)\n+      {\n+      case ADD_REG:\n+      case ADD_CONST_INT:\n+        return factor;\n+\n+      case ADD_SYMBOLIC:\n+        return factor * score_symbol_insns (addr.symbol_type);\n+      }\n+  return 0;\n+}\n+\n+/* Implement TARGET_RTX_COSTS macro.  */\n+static bool\n+score_rtx_costs (rtx x, int code, int outer_code, int *total)\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      /* These can be used anywhere. */\n+      *total = 0;\n+      return true;\n+\n+      /* Otherwise fall through to the handling below because\n+         we'll need to construct the constant.  */\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+    case CONST_DOUBLE:\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case MEM:\n+      {\n+        /* If the address is legitimate, return the number of\n+           instructions it needs, otherwise use the default handling.  */\n+        int n = score_address_insns (XEXP (x, 0), GET_MODE (x));\n+        if (n > 0)\n+          {\n+            *total = COSTS_N_INSNS (n + 1);\n+            return true;\n+          }\n+        return false;\n+      }\n+\n+    case FFS:\n+      *total = COSTS_N_INSNS (6);\n+      return true;\n+\n+    case NOT:\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case AND:\n+    case IOR:\n+    case XOR:\n+      if (mode == DImode)\n+        {\n+          *total = COSTS_N_INSNS (2);\n+          return true;\n+        }\n+      return false;\n+\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      if (mode == DImode)\n+        {\n+          *total = COSTS_N_INSNS ((GET_CODE (XEXP (x, 1)) == CONST_INT)\n+                                  ? 4 : 12);\n+          return true;\n+        }\n+      return false;\n+\n+    case ABS:\n+      *total = COSTS_N_INSNS (4);\n+      return true;\n+\n+    case PLUS:\n+    case MINUS:\n+      if (mode == DImode)\n+        {\n+          *total = COSTS_N_INSNS (4);\n+          return true;\n+        }\n+      return false;\n+\n+    case NEG:\n+      if (mode == DImode)\n+        {\n+          *total = COSTS_N_INSNS (4);\n+          return true;\n+        }\n+      return false;\n+\n+    case MULT:\n+      *total = COSTS_N_INSNS (12);\n+      return true;\n+\n+    case DIV:\n+    case MOD:\n+    case UDIV:\n+    case UMOD:\n+      *total = COSTS_N_INSNS (33);\n+      return true;\n+\n+    case SIGN_EXTEND:\n+      *total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case ZERO_EXTEND:\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Implement ASM_OUTPUT_EXTERNAL macro.  */\n int\n score_output_external (FILE *file ATTRIBUTE_UNUSED,"}, {"sha": "342901806fd4a7cbd5b7e3402d85571cda419d0a", "filename": "gcc/config/score/score.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf723ae82fa0cb6915ae689fde46be56e288608f/gcc%2Fconfig%2Fscore%2Fscore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf723ae82fa0cb6915ae689fde46be56e288608f/gcc%2Fconfig%2Fscore%2Fscore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.h?ref=cf723ae82fa0cb6915ae689fde46be56e288608f", "patch": "@@ -54,9 +54,10 @@ extern GTY(()) rtx cmp_op1;\n       builtin_define (\"__scorebe__\");           \\\n     if (TARGET_SCORE5U)                         \\\n       builtin_define (\"__score5u__\");           \\\n+    else                                        \\\n+      builtin_define (\"__score7__\");            \\\n   } while (0)\n \n-\n #define TARGET_DEFAULT         MASK_SCORE7\n \n #define TARGET_VERSION \\"}, {"sha": "856ea1065bd7b472ff9c459af4e49de630990c93", "filename": "gcc/config/score/score.md", "status": "modified", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf723ae82fa0cb6915ae689fde46be56e288608f/gcc%2Fconfig%2Fscore%2Fscore.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf723ae82fa0cb6915ae689fde46be56e288608f/gcc%2Fconfig%2Fscore%2Fscore.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.md?ref=cf723ae82fa0cb6915ae689fde46be56e288608f", "patch": "@@ -114,7 +114,7 @@\n         (match_operand:HI 1 \"general_operand\" \"i,d,m,d,*x,d,*a,d\"))]\n   \"\"\n {\n-  switch(which_alternative)\n+  switch (which_alternative)\n     {\n     case 0: return mdp_limm (operands);\n     case 1: return mdp_move (operands);\n@@ -1076,10 +1076,23 @@\n   [(call (mem:SI (match_operand:SI 0 \"call_insn_operand\" \"t,Z\"))\n          (match_operand 1 \"\" \"\"))\n    (clobber (reg:SI RT_REGNUM))]\n-  \"SIBLING_CALL_P (insn) && !flag_pic\"\n-  \"@\n-   br%S0   %0\n-   j       %0\"\n+  \"SIBLING_CALL_P (insn)\"\n+{\n+  if (!flag_pic) \n+    switch (which_alternative) \n+      {\n+      case 0: return \\\"br%S0   %0\\\";\n+      case 1: return \\\"j       %0\\\";\n+      default: gcc_unreachable ();\n+      }\n+  else\n+    switch (which_alternative) \n+      {\n+      case 0: return \\\"mv      r29, %0\\;.cpadd  r29\\;br      r29\\\";\n+      case 1: return \\\"la      r29, %0\\;br      r29\\\";\n+      default: gcc_unreachable ();\n+      }\n+}\n   [(set_attr \"type\" \"call\")])\n \n (define_expand \"sibcall_value\"\n@@ -1097,10 +1110,23 @@\n         (call (mem:SI (match_operand:SI 1 \"call_insn_operand\" \"t,Z\"))\n               (match_operand 2 \"\" \"\")))\n    (clobber (reg:SI RT_REGNUM))]\n-  \"SIBLING_CALL_P(insn) && !flag_pic\"\n-  \"@\n-   br%S1   %1\n-   j       %1\"\n+  \"SIBLING_CALL_P (insn)\"\n+{\n+  if (!flag_pic) \n+    switch (which_alternative) \n+      {\n+      case 0: return \\\"br%S1   %1\\\";\n+      case 1: return \\\"j       %1\\\";\n+      default: gcc_unreachable ();\n+      }\n+  else\n+    switch (which_alternative) \n+      {\n+      case 0: return \\\"mv      r29, %1\\;.cpadd  r29\\;br      r29\\\";\n+      case 1: return \\\"la      r29, %1\\;br      r29\\\";\n+      default: gcc_unreachable ();\n+      }\n+}\n   [(set_attr \"type\" \"call\")])\n \n (define_expand \"call\"\n@@ -1126,7 +1152,12 @@\n       default: gcc_unreachable ();\n       }\n   else\n-    return \\\"la      r29, %0\\;brl     r29\\\";\n+     switch (which_alternative)\n+      {\n+      case 0: return \\\"mv      r29, %0\\;.cpadd  r29\\;brl     r29\\\";\n+      case 1: return \\\"la      r29, %0\\;brl     r29\\\";\n+      default: gcc_unreachable ();\n+      }\n }\n   [(set_attr \"type\" \"call\")])\n \n@@ -1155,7 +1186,12 @@\n       default: gcc_unreachable ();\n       }\n   else\n-    return \\\"la      r29, %1\\;brl     r29\\\";\n+    switch (which_alternative)\n+      {\n+      case 0: return \\\"mv      r29, %1\\;.cpadd  r29\\;brl     r29\\\";\n+      case 1: return \\\"la      r29, %1\\;brl     r29\\\";\n+      default: gcc_unreachable ();\n+      }\n }\n   [(set_attr \"type\" \"call\")])\n \n@@ -1198,7 +1234,7 @@\n   \"\"\n   \"*\n    if (flag_pic)\n-     return \\\"mv!     r29, %0\\;.cpadd  r29\\;br%S0   r29\\\";\n+     return \\\"mv      r29, %0\\;.cpadd  r29\\;br      r29\\\";\n    else\n      return \\\"br%S0   %0\\\";\n   \""}, {"sha": "2590b67686f44ad5e1192be3778c21c8972bd931", "filename": "gcc/config/score/t-score-elf", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf723ae82fa0cb6915ae689fde46be56e288608f/gcc%2Fconfig%2Fscore%2Ft-score-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf723ae82fa0cb6915ae689fde46be56e288608f/gcc%2Fconfig%2Fscore%2Ft-score-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Ft-score-elf?ref=cf723ae82fa0cb6915ae689fde46be56e288608f", "patch": "@@ -35,7 +35,9 @@ dp-bit.c: $(srcdir)/config/fp-bit.c\n # without the $gp register.\n TARGET_LIBGCC2_CFLAGS = -G 0\n \n-MULTILIB_OPTIONS = mel mSCORE7\n+MULTILIB_OPTIONS = fPIC mel mSCORE7\n+MULTILIB_MATCHES = fPIC=fpic\n+\n EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crti.o crtn.o\n \n LIBGCC = stmp-multilib"}]}