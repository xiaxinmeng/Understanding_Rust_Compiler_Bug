{"sha": "6cec5cb56a426a0d2526b9ea3bde04fc0fc21e5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNlYzVjYjU2YTQyNmEwZDI1MjZiOWVhM2JkZTA0ZmMwZmMyMWU1Yw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2005-09-26T08:42:57Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2005-09-26T08:42:57Z"}, "message": "re PR middle-end/15855 (g++ crash with -O2 and -O3 on input file)\n\n2005-09-26  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/15855\n\t* decl2.c (do_static_destruction): Remove.\n\t(finish_static_initialization_or_destruction): Likewise.\n\t(DECL_EFFECTIVE_INIT_PRIORITY): New macro.\n\t(NEEDS_GUARD_P): Likewise.\n\t(do_static_initialization): Rename to\n\tdo_static_initialization_or_destruction.  Process all\n\tinitializers/destructors and handle common conditionalizing.\n\t(start_static_initialization_or_destruction): Rename to\n\tone_static_initialization_or_destruction.  Handle only\n\tdecl-specific conditionalizing.\n\t(cp_finish_file): Call do_static_initialization_or_destruction.\n\nFrom-SVN: r104642", "tree": {"sha": "648f10df42593f49ba0272c32c14700dbb481473", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/648f10df42593f49ba0272c32c14700dbb481473"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cec5cb56a426a0d2526b9ea3bde04fc0fc21e5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cec5cb56a426a0d2526b9ea3bde04fc0fc21e5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cec5cb56a426a0d2526b9ea3bde04fc0fc21e5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cec5cb56a426a0d2526b9ea3bde04fc0fc21e5c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9727e468b1f04524bc4ff08bf96673e3eba55e45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9727e468b1f04524bc4ff08bf96673e3eba55e45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9727e468b1f04524bc4ff08bf96673e3eba55e45"}], "stats": {"total": 225, "additions": 123, "deletions": 102}, "files": [{"sha": "44109ef82f54925e44ec91ca342314c8b0090a96", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cec5cb56a426a0d2526b9ea3bde04fc0fc21e5c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cec5cb56a426a0d2526b9ea3bde04fc0fc21e5c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6cec5cb56a426a0d2526b9ea3bde04fc0fc21e5c", "patch": "@@ -1,3 +1,18 @@\n+2005-09-26  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/15855\n+\t* decl2.c (do_static_destruction): Remove.\n+\t(finish_static_initialization_or_destruction): Likewise.\n+\t(DECL_EFFECTIVE_INIT_PRIORITY): New macro.\n+\t(NEEDS_GUARD_P): Likewise.\n+\t(do_static_initialization): Rename to\n+\tdo_static_initialization_or_destruction.  Process all\n+\tinitializers/destructors and handle common conditionalizing.\n+\t(start_static_initialization_or_destruction): Rename to\n+\tone_static_initialization_or_destruction.  Handle only\n+\tdecl-specific conditionalizing.\n+\t(cp_finish_file): Call do_static_initialization_or_destruction.\n+\n 2005-09-22  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/21983"}, {"sha": "1e812838435f5226fb5aa7d2cf0ac061a7e6c615", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 108, "deletions": 102, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cec5cb56a426a0d2526b9ea3bde04fc0fc21e5c/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cec5cb56a426a0d2526b9ea3bde04fc0fc21e5c/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=6cec5cb56a426a0d2526b9ea3bde04fc0fc21e5c", "patch": "@@ -73,10 +73,8 @@ static void finish_objects (int, int, tree);\n static tree start_static_storage_duration_function (unsigned);\n static void finish_static_storage_duration_function (tree);\n static priority_info get_priority_info (int);\n-static void do_static_initialization (tree, tree);\n-static void do_static_destruction (tree);\n-static tree start_static_initialization_or_destruction (tree, int);\n-static void finish_static_initialization_or_destruction (tree);\n+static void do_static_initialization_or_destruction (tree, bool);\n+static void one_static_initialization_or_destruction (tree, tree, bool);\n static void generate_ctor_or_dtor_function (bool, int, location_t *);\n static int generate_ctor_and_dtor_functions_for_priority (splay_tree_node,\n \t\t\t\t\t\t\t  void *);\n@@ -2316,33 +2314,34 @@ get_priority_info (int priority)\n   return pi;\n }\n \n+/* The effective initialization priority of a DECL.  */\n+\n+#define DECL_EFFECTIVE_INIT_PRIORITY(decl)\t\t\t\t      \\\n+\t((!DECL_HAS_INIT_PRIORITY_P (decl) || DECL_INIT_PRIORITY (decl) == 0) \\\n+\t ? DEFAULT_INIT_PRIORITY : DECL_INIT_PRIORITY (decl))\n+\n+/* Wether a DECL needs a guard to protect it against multiple\n+   initialization.  */\n+\n+#define NEEDS_GUARD_P(decl) (TREE_PUBLIC (decl) && (DECL_COMMON (decl)      \\\n+\t\t\t\t\t\t    || DECL_ONE_ONLY (decl) \\\n+\t\t\t\t\t\t    || DECL_WEAK (decl)))\n+\n /* Set up to handle the initialization or destruction of DECL.  If\n    INITP is nonzero, we are initializing the variable.  Otherwise, we\n    are destroying it.  */\n \n-static tree\n-start_static_initialization_or_destruction (tree decl, int initp)\n+static void\n+one_static_initialization_or_destruction (tree decl, tree init, bool initp)\n {\n   tree guard_if_stmt = NULL_TREE;\n-  int priority = 0;\n-  tree cond;\n   tree guard;\n-  tree init_cond;\n-  priority_info pi;\n-\n-    /* Figure out the priority for this declaration.  */\n-  if (DECL_HAS_INIT_PRIORITY_P (decl))\n-    priority = DECL_INIT_PRIORITY (decl);\n-  if (!priority)\n-    priority = DEFAULT_INIT_PRIORITY;\n \n-  /* Remember that we had an initialization or finalization at this\n-     priority.  */\n-  pi = get_priority_info (priority);\n-  if (initp)\n-    pi->initializations_p = 1;\n-  else\n-    pi->destructions_p = 1;\n+  /* If we are supposed to destruct and there's a trivial destructor,\n+     nothing has to be done.  */\n+  if (!initp\n+      && TYPE_HAS_TRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n+    return;\n \n   /* Trick the compiler into thinking we are at the file and line\n      where DECL was declared so that error-messages make sense, and so\n@@ -2368,27 +2367,13 @@ start_static_initialization_or_destruction (tree decl, int initp)\n       DECL_STATIC_FUNCTION_P (current_function_decl) = 1;\n     }\n \n-  /* Conditionalize this initialization on being in the right priority\n-     and being initializing/finalizing appropriately.  */\n-  guard_if_stmt = begin_if_stmt ();\n-  cond = cp_build_binary_op (EQ_EXPR,\n-\t\t\t     priority_decl,\n-\t\t\t     build_int_cst (NULL_TREE, priority));\n-  init_cond = initp ? integer_one_node : integer_zero_node;\n-  init_cond = cp_build_binary_op (EQ_EXPR,\n-\t\t\t\t  initialize_p_decl,\n-\t\t\t\t  init_cond);\n-  cond = cp_build_binary_op (TRUTH_ANDIF_EXPR, cond, init_cond);\n-\n   /* Assume we don't need a guard.  */\n   guard = NULL_TREE;\n   /* We need a guard if this is an object with external linkage that\n      might be initialized in more than one place.  (For example, a\n      static data member of a template, when the data member requires\n      construction.)  */\n-  if (TREE_PUBLIC (decl) && (DECL_COMMON (decl)\n-\t\t\t     || DECL_ONE_ONLY (decl)\n-\t\t\t     || DECL_WEAK (decl)))\n+  if (NEEDS_GUARD_P (decl))\n     {\n       tree guard_cond;\n \n@@ -2425,84 +2410,109 @@ start_static_initialization_or_destruction (tree decl, int initp)\n \t\t\t\t\t\t/*noconvert=*/1),\n \t\t\t\tinteger_zero_node);\n \n-      cond = cp_build_binary_op (TRUTH_ANDIF_EXPR, cond, guard_cond);\n+      guard_if_stmt = begin_if_stmt ();\n+      finish_if_stmt_cond (guard_cond, guard_if_stmt);\n     }\n \n-  finish_if_stmt_cond (cond, guard_if_stmt);\n \n   /* If we're using __cxa_atexit, we have not already set the GUARD,\n      so we must do so now.  */\n   if (guard && initp && flag_use_cxa_atexit)\n     finish_expr_stmt (set_guard (guard));\n \n-  return guard_if_stmt;\n-}\n+  /* Perform the initialization or destruction.  */\n+  if (initp)\n+    {\n+      if (init)\n+        finish_expr_stmt (init);\n \n-/* We've just finished generating code to do an initialization or\n-   finalization.  GUARD_IF_STMT is the if-statement we used to guard\n-   the initialization.  */\n+      /* If we're using __cxa_atexit, register a function that calls the\n+         destructor for the object.  */\n+      if (flag_use_cxa_atexit)\n+        finish_expr_stmt (register_dtor_fn (decl));\n+    }\n+  else\n+    finish_expr_stmt (build_cleanup (decl));\n \n-static void\n-finish_static_initialization_or_destruction (tree guard_if_stmt)\n-{\n-  finish_then_clause (guard_if_stmt);\n-  finish_if_stmt (guard_if_stmt);\n+  /* Finish the guard if-stmt, if necessary.  */\n+  if (guard)\n+    {\n+      finish_then_clause (guard_if_stmt);\n+      finish_if_stmt (guard_if_stmt);\n+    }\n \n   /* Now that we're done with DECL we don't need to pretend to be a\n      member of its class any longer.  */\n   DECL_CONTEXT (current_function_decl) = NULL_TREE;\n   DECL_STATIC_FUNCTION_P (current_function_decl) = 0;\n }\n \n-/* Generate code to do the initialization of DECL, a VAR_DECL with\n-   static storage duration.  The initialization is INIT.  */\n+/* Generate code to do the initialization or destruction of the decls in VARS,\n+   a TREE_LIST of VAR_DECL with static storage duration.\n+   Whether initialization or destruction is performed is specified by INITP.  */\n \n static void\n-do_static_initialization (tree decl, tree init)\n+do_static_initialization_or_destruction (tree vars, bool initp)\n {\n-  tree guard_if_stmt;\n-\n-  /* Set up for the initialization.  */\n-  guard_if_stmt\n-    = start_static_initialization_or_destruction (decl,\n-\t\t\t\t\t\t  /*initp=*/1);\n-\n-  /* Perform the initialization.  */\n-  if (init)\n-    finish_expr_stmt (init);\n-\n-  /* If we're using __cxa_atexit, register a function that calls the\n-     destructor for the object.  */\n-  if (flag_use_cxa_atexit)\n-    finish_expr_stmt (register_dtor_fn (decl));\n+  tree node, init_if_stmt, cond;\n \n-  /* Finish up.  */\n-  finish_static_initialization_or_destruction (guard_if_stmt);\n-}\n-\n-/* Generate code to do the static destruction of DECL.  If DECL may be\n-   initialized more than once in different object files, GUARD is the\n-   guard variable to check.  PRIORITY is the priority for the\n-   destruction.  */\n-\n-static void\n-do_static_destruction (tree decl)\n-{\n-  tree guard_if_stmt;\n-\n-  /* If we're using __cxa_atexit, then destructors are registered\n-     immediately after objects are initialized.  */\n-  gcc_assert (!flag_use_cxa_atexit);\n-\n-  /* If we don't need a destructor, there's nothing to do.  */\n-  if (TYPE_HAS_TRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n-    return;\n+  /* Build the outer if-stmt to check for initialization or destruction.  */\n+  init_if_stmt = begin_if_stmt ();\n+  cond = initp ? integer_one_node : integer_zero_node;\n+  cond = cp_build_binary_op (EQ_EXPR,\n+\t\t\t\t  initialize_p_decl,\n+\t\t\t\t  cond);\n+  finish_if_stmt_cond (cond, init_if_stmt);\n+\n+  node = vars;\n+  do {\n+    tree decl = TREE_VALUE (node);\n+    tree priority_if_stmt;\n+    int priority;\n+    priority_info pi;\n+\n+    /* If we don't need a destructor, there's nothing to do.  Avoid\n+       creating a possibly empty if-stmt.  */\n+    if (!initp && TYPE_HAS_TRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n+      {\n+\tnode = TREE_CHAIN (node);\n+\tcontinue;\n+      }\n \n-  /* Actually do the destruction.  */\n-  guard_if_stmt = start_static_initialization_or_destruction (decl,\n-\t\t\t\t\t\t\t      /*initp=*/0);\n-  finish_expr_stmt (build_cleanup (decl));\n-  finish_static_initialization_or_destruction (guard_if_stmt);\n+    /* Remember that we had an initialization or finalization at this\n+       priority.  */\n+    priority = DECL_EFFECTIVE_INIT_PRIORITY (decl);\n+    pi = get_priority_info (priority);\n+    if (initp)\n+      pi->initializations_p = 1;\n+    else\n+      pi->destructions_p = 1;\n+\n+    /* Conditionalize this initialization on being in the right priority\n+       and being initializing/finalizing appropriately.  */\n+    priority_if_stmt = begin_if_stmt ();\n+    cond = cp_build_binary_op (EQ_EXPR,\n+\t\t\t       priority_decl,\n+\t\t\t       build_int_cst (NULL_TREE, priority));\n+    finish_if_stmt_cond (cond, priority_if_stmt);\n+\n+    /* Process initializers with same priority.  */\n+    for (; node\n+\t   && DECL_EFFECTIVE_INIT_PRIORITY (TREE_VALUE (node)) == priority;\n+\t node = TREE_CHAIN (node))\n+      /* Do one initialization or destruction.  */\n+      one_static_initialization_or_destruction (TREE_VALUE (node),\n+\t\t\t\t \t\tTREE_PURPOSE (node), initp);\n+\n+    /* Finish up the priority if-stmt body.  */\n+    finish_then_clause (priority_if_stmt);\n+    finish_if_stmt (priority_if_stmt);\n+\n+  } while (node);\n+\n+  /* Finish up the init/destruct if-stmt body.  */\n+  finish_then_clause (init_if_stmt);\n+  finish_if_stmt (init_if_stmt);\n }\n \n /* VARS is a list of variables with static storage duration which may\n@@ -2900,8 +2910,6 @@ cp_finish_file (void)\n \n       if (vars)\n \t{\n-\t  tree v;\n-\n \t  /* We need to start a new initialization function each time\n \t     through the loop.  That's because we need to know which\n \t     vtables have been referenced, and TREE_SYMBOL_REFERENCED\n@@ -2920,21 +2928,19 @@ cp_finish_file (void)\n \t  write_out_vars (vars);\n \n \t  /* First generate code to do all the initializations.  */\n-\t  for (v = vars; v; v = TREE_CHAIN (v))\n-\t    do_static_initialization (TREE_VALUE (v),\n-\t\t\t\t      TREE_PURPOSE (v));\n+\t  if (vars)\n+\t    do_static_initialization_or_destruction (vars, /*initp=*/true);\n \n \t  /* Then, generate code to do all the destructions.  Do these\n \t     in reverse order so that the most recently constructed\n \t     variable is the first destroyed.  If we're using\n \t     __cxa_atexit, then we don't need to do this; functions\n \t     were registered at initialization time to destroy the\n \t     local statics.  */\n-\t  if (!flag_use_cxa_atexit)\n+\t  if (!flag_use_cxa_atexit && vars)\n \t    {\n \t      vars = nreverse (vars);\n-\t      for (v = vars; v; v = TREE_CHAIN (v))\n-\t\tdo_static_destruction (TREE_VALUE (v));\n+\t      do_static_initialization_or_destruction (vars, /*initp=*/false);\n \t    }\n \t  else\n \t    vars = NULL_TREE;"}]}