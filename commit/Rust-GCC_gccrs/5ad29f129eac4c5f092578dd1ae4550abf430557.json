{"sha": "5ad29f129eac4c5f092578dd1ae4550abf430557", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFkMjlmMTI5ZWFjNGM1ZjA5MjU3OGRkMWFlNDU1MGFiZjQzMDU1Nw==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2013-03-25T14:41:37Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2013-03-25T14:41:37Z"}, "message": "arm.c (arm_emit_load_exclusive): Add acq parameter.\n\n2013-03-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n\n\t* config/arm/arm.c (arm_emit_load_exclusive): Add acq parameter.\n\tEmit load-acquire versions when acq is true.\n\t(arm_emit_store_exclusive): Add rel parameter.\n\tEmit store-release versions when rel is true.\n\t(arm_split_compare_and_swap): Use acquire-release instructions\n\tinstead.\n\tof barriers when appropriate.\n\t(arm_split_atomic_op): Likewise.\n\t* config/arm/arm.h (TARGET_HAVE_LDACQ): New macro.\n\t* config/arm/unspecs.md (VUNSPEC_LAX): New unspec.\n\t(VUNSPEC_SLX): Likewise.\n\t(VUNSPEC_LDA): Likewise.\n\t(VUNSPEC_STL): Likewise.\n\t* config/arm/sync.md (atomic_load<mode>): New pattern.\n\t(atomic_store<mode>): Likewise.\n\t(arm_load_acquire_exclusive<mode>): Likewise.\n\t(arm_load_acquire_exclusivesi): Likewise.\n\t(arm_load_acquire_exclusivedi): Likewise.\n\t(arm_store_release_exclusive<mode>): Likewise.\n\nFrom-SVN: r197046", "tree": {"sha": "cdf161b0c85b58ca6485f683a6aee55bcc1831f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cdf161b0c85b58ca6485f683a6aee55bcc1831f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ad29f129eac4c5f092578dd1ae4550abf430557", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ad29f129eac4c5f092578dd1ae4550abf430557", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ad29f129eac4c5f092578dd1ae4550abf430557", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ad29f129eac4c5f092578dd1ae4550abf430557/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "03a7dddbdb976cfbc51b5fd64a2fc993e0328398", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03a7dddbdb976cfbc51b5fd64a2fc993e0328398", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03a7dddbdb976cfbc51b5fd64a2fc993e0328398"}], "stats": {"total": 241, "additions": 216, "deletions": 25}, "files": [{"sha": "8c3ac959a3142fd2ed042e5cd6f1c1aae94124e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad29f129eac4c5f092578dd1ae4550abf430557/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad29f129eac4c5f092578dd1ae4550abf430557/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ad29f129eac4c5f092578dd1ae4550abf430557", "patch": "@@ -1,3 +1,25 @@\n+2013-03-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* config/arm/arm.c (arm_emit_load_exclusive): Add acq parameter.\n+\tEmit load-acquire versions when acq is true.\n+\t(arm_emit_store_exclusive): Add rel parameter.\n+\tEmit store-release versions when rel is true.\n+\t(arm_split_compare_and_swap): Use acquire-release instructions\n+\tinstead.\n+\tof barriers when appropriate.\n+\t(arm_split_atomic_op): Likewise.\n+\t* config/arm/arm.h (TARGET_HAVE_LDACQ): New macro.\n+\t* config/arm/unspecs.md (VUNSPEC_LAX): New unspec.\n+\t(VUNSPEC_SLX): Likewise.\n+\t(VUNSPEC_LDA): Likewise.\n+\t(VUNSPEC_STL): Likewise.\n+\t* config/arm/sync.md (atomic_load<mode>): New pattern.\n+\t(atomic_store<mode>): Likewise.\n+\t(arm_load_acquire_exclusive<mode>): Likewise.\n+\t(arm_load_acquire_exclusivesi): Likewise.\n+\t(arm_load_acquire_exclusivedi): Likewise.\n+\t(arm_store_release_exclusive<mode>): Likewise.\n+\n 2013-03-25  Catherine Moore  <clm@codesourcery.com>\n \n \t* config/mips/constraints.md (u, Udb7 Uead, Uean, Uesp, Uib3,"}, {"sha": "d70df4da070808aaf060bea21661a6fcac950044", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 95, "deletions": 25, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad29f129eac4c5f092578dd1ae4550abf430557/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad29f129eac4c5f092578dd1ae4550abf430557/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=5ad29f129eac4c5f092578dd1ae4550abf430557", "patch": "@@ -26225,39 +26225,71 @@ arm_post_atomic_barrier (enum memmodel model)\n     emit_insn (gen_memory_barrier ());\n }\n \n-/* Emit the load-exclusive and store-exclusive instructions.  */\n+/* Emit the load-exclusive and store-exclusive instructions.\n+   Use acquire and release versions if necessary.  */\n \n static void\n-arm_emit_load_exclusive (enum machine_mode mode, rtx rval, rtx mem)\n+arm_emit_load_exclusive (enum machine_mode mode, rtx rval, rtx mem, bool acq)\n {\n   rtx (*gen) (rtx, rtx);\n \n-  switch (mode)\n+  if (acq)\n     {\n-    case QImode: gen = gen_arm_load_exclusiveqi; break;\n-    case HImode: gen = gen_arm_load_exclusivehi; break;\n-    case SImode: gen = gen_arm_load_exclusivesi; break;\n-    case DImode: gen = gen_arm_load_exclusivedi; break;\n-    default:\n-      gcc_unreachable ();\n+      switch (mode)\n+        {\n+        case QImode: gen = gen_arm_load_acquire_exclusiveqi; break;\n+        case HImode: gen = gen_arm_load_acquire_exclusivehi; break;\n+        case SImode: gen = gen_arm_load_acquire_exclusivesi; break;\n+        case DImode: gen = gen_arm_load_acquire_exclusivedi; break;\n+        default:\n+          gcc_unreachable ();\n+        }\n+    }\n+  else\n+    {\n+      switch (mode)\n+        {\n+        case QImode: gen = gen_arm_load_exclusiveqi; break;\n+        case HImode: gen = gen_arm_load_exclusivehi; break;\n+        case SImode: gen = gen_arm_load_exclusivesi; break;\n+        case DImode: gen = gen_arm_load_exclusivedi; break;\n+        default:\n+          gcc_unreachable ();\n+        }\n     }\n \n   emit_insn (gen (rval, mem));\n }\n \n static void\n-arm_emit_store_exclusive (enum machine_mode mode, rtx bval, rtx rval, rtx mem)\n+arm_emit_store_exclusive (enum machine_mode mode, rtx bval, rtx rval,\n+                          rtx mem, bool rel)\n {\n   rtx (*gen) (rtx, rtx, rtx);\n \n-  switch (mode)\n+  if (rel)\n     {\n-    case QImode: gen = gen_arm_store_exclusiveqi; break;\n-    case HImode: gen = gen_arm_store_exclusivehi; break;\n-    case SImode: gen = gen_arm_store_exclusivesi; break;\n-    case DImode: gen = gen_arm_store_exclusivedi; break;\n-    default:\n-      gcc_unreachable ();\n+      switch (mode)\n+        {\n+        case QImode: gen = gen_arm_store_release_exclusiveqi; break;\n+        case HImode: gen = gen_arm_store_release_exclusivehi; break;\n+        case SImode: gen = gen_arm_store_release_exclusivesi; break;\n+        case DImode: gen = gen_arm_store_release_exclusivedi; break;\n+        default:\n+          gcc_unreachable ();\n+        }\n+    }\n+  else\n+    {\n+      switch (mode)\n+        {\n+        case QImode: gen = gen_arm_store_exclusiveqi; break;\n+        case HImode: gen = gen_arm_store_exclusivehi; break;\n+        case SImode: gen = gen_arm_store_exclusivesi; break;\n+        case DImode: gen = gen_arm_store_exclusivedi; break;\n+        default:\n+          gcc_unreachable ();\n+        }\n     }\n \n   emit_insn (gen (bval, rval, mem));\n@@ -26293,6 +26325,15 @@ arm_expand_compare_and_swap (rtx operands[])\n   mod_f = operands[7];\n   mode = GET_MODE (mem);\n \n+  /* Normally the succ memory model must be stronger than fail, but in the\n+     unlikely event of fail being ACQUIRE and succ being RELEASE we need to\n+     promote succ to ACQ_REL so that we don't lose the acquire semantics.  */\n+\n+  if (TARGET_HAVE_LDACQ\n+      && INTVAL (mod_f) == MEMMODEL_ACQUIRE\n+      && INTVAL (mod_s) == MEMMODEL_RELEASE)\n+    mod_s = GEN_INT (MEMMODEL_ACQ_REL);\n+\n   switch (mode)\n     {\n     case QImode:\n@@ -26367,7 +26408,19 @@ arm_split_compare_and_swap (rtx operands[])\n   scratch = operands[7];\n   mode = GET_MODE (mem);\n \n-  arm_pre_atomic_barrier (mod_s);\n+  bool use_acquire = TARGET_HAVE_LDACQ\n+                     && !(mod_s == MEMMODEL_RELAXED\n+                          || mod_s == MEMMODEL_CONSUME\n+                          || mod_s == MEMMODEL_RELEASE);\n+\n+  bool use_release = TARGET_HAVE_LDACQ\n+                     && !(mod_s == MEMMODEL_RELAXED\n+                          || mod_s == MEMMODEL_CONSUME\n+                          || mod_s == MEMMODEL_ACQUIRE);\n+\n+  /* Checks whether a barrier is needed and emits one accordingly.  */\n+  if (!(use_acquire || use_release))\n+    arm_pre_atomic_barrier (mod_s);\n \n   label1 = NULL_RTX;\n   if (!is_weak)\n@@ -26377,15 +26430,15 @@ arm_split_compare_and_swap (rtx operands[])\n     }\n   label2 = gen_label_rtx ();\n \n-  arm_emit_load_exclusive (mode, rval, mem);\n+  arm_emit_load_exclusive (mode, rval, mem, use_acquire);\n \n   cond = arm_gen_compare_reg (NE, rval, oldval, scratch);\n   x = gen_rtx_NE (VOIDmode, cond, const0_rtx);\n   x = gen_rtx_IF_THEN_ELSE (VOIDmode, x,\n \t\t\t    gen_rtx_LABEL_REF (Pmode, label2), pc_rtx);\n   emit_unlikely_jump (gen_rtx_SET (VOIDmode, pc_rtx, x));\n \n-  arm_emit_store_exclusive (mode, scratch, mem, newval);\n+  arm_emit_store_exclusive (mode, scratch, mem, newval, use_release);\n \n   /* Weak or strong, we want EQ to be true for success, so that we\n      match the flags that we got from the compare above.  */\n@@ -26404,7 +26457,9 @@ arm_split_compare_and_swap (rtx operands[])\n   if (mod_f != MEMMODEL_RELAXED)\n     emit_label (label2);\n \n-  arm_post_atomic_barrier (mod_s);\n+  /* Checks whether a barrier is needed and emits one accordingly.  */\n+  if (!(use_acquire || use_release))\n+    arm_post_atomic_barrier (mod_s);\n \n   if (mod_f == MEMMODEL_RELAXED)\n     emit_label (label2);\n@@ -26419,7 +26474,19 @@ arm_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,\n   enum machine_mode wmode = (mode == DImode ? DImode : SImode);\n   rtx label, x;\n \n-  arm_pre_atomic_barrier (model);\n+  bool use_acquire = TARGET_HAVE_LDACQ\n+                     && !(model == MEMMODEL_RELAXED\n+                          || model == MEMMODEL_CONSUME\n+                          || model == MEMMODEL_RELEASE);\n+\n+  bool use_release = TARGET_HAVE_LDACQ\n+                     && !(model == MEMMODEL_RELAXED\n+                          || model == MEMMODEL_CONSUME\n+                          || model == MEMMODEL_ACQUIRE);\n+\n+  /* Checks whether a barrier is needed and emits one accordingly.  */\n+  if (!(use_acquire || use_release))\n+    arm_pre_atomic_barrier (model);\n \n   label = gen_label_rtx ();\n   emit_label (label);\n@@ -26432,7 +26499,7 @@ arm_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,\n     old_out = new_out;\n   value = simplify_gen_subreg (wmode, value, mode, 0);\n \n-  arm_emit_load_exclusive (mode, old_out, mem);\n+  arm_emit_load_exclusive (mode, old_out, mem, use_acquire);\n \n   switch (code)\n     {\n@@ -26480,12 +26547,15 @@ arm_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,\n       break;\n     }\n \n-  arm_emit_store_exclusive (mode, cond, mem, gen_lowpart (mode, new_out));\n+  arm_emit_store_exclusive (mode, cond, mem, gen_lowpart (mode, new_out),\n+                            use_release);\n \n   x = gen_rtx_NE (VOIDmode, cond, const0_rtx);\n   emit_unlikely_jump (gen_cbranchsi4 (x, cond, const0_rtx, label));\n \n-  arm_post_atomic_barrier (model);\n+  /* Checks whether a barrier is needed and emits one accordingly.  */\n+  if (!(use_acquire || use_release))\n+    arm_post_atomic_barrier (model);\n }\n \f\n #define MAX_VECT_LEN 16"}, {"sha": "39eb2a15c1a418d4c2d5d0fecb9a4dbd010936bb", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad29f129eac4c5f092578dd1ae4550abf430557/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad29f129eac4c5f092578dd1ae4550abf430557/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=5ad29f129eac4c5f092578dd1ae4550abf430557", "patch": "@@ -350,6 +350,9 @@ extern void (*arm_lang_output_object_attributes_hook)(void);\n #define TARGET_HAVE_LDREXD\t(((arm_arch6k && TARGET_ARM) || arm_arch7) \\\n \t\t\t\t && arm_arch_notm)\n \n+/* Nonzero if this chip supports load-acquire and store-release.  */\n+#define TARGET_HAVE_LDACQ\t(TARGET_ARM_ARCH >= 8)\n+\n /* Nonzero if integer division instructions supported.  */\n #define TARGET_IDIV\t\t((TARGET_ARM && arm_arch_arm_hwdiv) \\\n \t\t\t\t || (TARGET_THUMB2 && arm_arch_thumb_hwdiv))"}, {"sha": "980234836c95d5f13f663687bdbe5f8338171094", "filename": "gcc/config/arm/sync.md", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad29f129eac4c5f092578dd1ae4550abf430557/gcc%2Fconfig%2Farm%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad29f129eac4c5f092578dd1ae4550abf430557/gcc%2Fconfig%2Farm%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fsync.md?ref=5ad29f129eac4c5f092578dd1ae4550abf430557", "patch": "@@ -65,6 +65,42 @@\n    (set_attr \"conds\" \"unconditional\")\n    (set_attr \"predicable\" \"no\")])\n \n+(define_insn \"atomic_load<mode>\"\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"=r\")\n+    (unspec_volatile:QHSI\n+      [(match_operand:QHSI 1 \"arm_sync_memory_operand\" \"Q\")\n+       (match_operand:SI 2 \"const_int_operand\")]\t\t;; model\n+      VUNSPEC_LDA))]\n+  \"TARGET_HAVE_LDACQ\"\n+  {\n+    enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n+    if (model == MEMMODEL_RELAXED\n+        || model == MEMMODEL_CONSUME\n+        || model == MEMMODEL_RELEASE)\n+      return \\\"ldr<sync_sfx>\\\\t%0, %1\\\";\n+    else\n+      return \\\"lda<sync_sfx>\\\\t%0, %1\\\";\n+  }\n+)\n+\n+(define_insn \"atomic_store<mode>\"\n+  [(set (match_operand:QHSI 0 \"memory_operand\" \"=Q\")\n+    (unspec_volatile:QHSI\n+      [(match_operand:QHSI 1 \"general_operand\" \"r\")\n+       (match_operand:SI 2 \"const_int_operand\")]\t\t;; model\n+      VUNSPEC_STL))]\n+  \"TARGET_HAVE_LDACQ\"\n+  {\n+    enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n+    if (model == MEMMODEL_RELAXED\n+        || model == MEMMODEL_CONSUME\n+        || model == MEMMODEL_ACQUIRE)\n+      return \\\"str<sync_sfx>\\t%1, %0\\\";\n+    else\n+      return \\\"stl<sync_sfx>\\t%1, %0\\\";\n+  }\n+)\n+\n ;; Note that ldrd and vldr are *not* guaranteed to be single-copy atomic,\n ;; even for a 64-bit aligned address.  Instead we use a ldrexd unparied\n ;; with a store.\n@@ -327,6 +363,16 @@\n   \"ldrex<sync_sfx>%?\\t%0, %C1\"\n   [(set_attr \"predicable\" \"yes\")])\n \n+(define_insn \"arm_load_acquire_exclusive<mode>\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+        (zero_extend:SI\n+\t  (unspec_volatile:NARROW\n+\t    [(match_operand:NARROW 1 \"mem_noofs_operand\" \"Ua\")]\n+\t    VUNSPEC_LAX)))]\n+  \"TARGET_HAVE_LDACQ\"\n+  \"ldaex<sync_sfx>%?\\\\t%0, %C1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n (define_insn \"arm_load_exclusivesi\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(unspec_volatile:SI\n@@ -336,6 +382,15 @@\n   \"ldrex%?\\t%0, %C1\"\n   [(set_attr \"predicable\" \"yes\")])\n \n+(define_insn \"arm_load_acquire_exclusivesi\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(unspec_volatile:SI\n+\t  [(match_operand:SI 1 \"mem_noofs_operand\" \"Ua\")]\n+\t  VUNSPEC_LAX))]\n+  \"TARGET_HAVE_LDACQ\"\n+  \"ldaex%?\\t%0, %C1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n (define_insn \"arm_load_exclusivedi\"\n   [(set (match_operand:DI 0 \"s_register_operand\" \"=r\")\n \t(unspec_volatile:DI\n@@ -345,6 +400,15 @@\n   \"ldrexd%?\\t%0, %H0, %C1\"\n   [(set_attr \"predicable\" \"yes\")])\n \n+(define_insn \"arm_load_acquire_exclusivedi\"\n+  [(set (match_operand:DI 0 \"s_register_operand\" \"=r\")\n+\t(unspec_volatile:DI\n+\t  [(match_operand:DI 1 \"mem_noofs_operand\" \"Ua\")]\n+\t  VUNSPEC_LAX))]\n+  \"TARGET_HAVE_LDACQ && ARM_DOUBLEWORD_ALIGN\"\n+  \"ldaexd%?\\t%0, %H0, %C1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n (define_insn \"arm_store_exclusive<mode>\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n \t(unspec_volatile:SI [(const_int 0)] VUNSPEC_SC))\n@@ -368,3 +432,31 @@\n     return \"strex<sync_sfx>%?\\t%0, %2, %C1\";\n   }\n   [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"arm_store_release_exclusivedi\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n+\t(unspec_volatile:SI [(const_int 0)] VUNSPEC_SLX))\n+   (set (match_operand:DI 1 \"mem_noofs_operand\" \"=Ua\")\n+\t(unspec_volatile:DI\n+\t  [(match_operand:DI 2 \"s_register_operand\" \"r\")]\n+\t  VUNSPEC_SLX))]\n+  \"TARGET_HAVE_LDACQ && ARM_DOUBLEWORD_ALIGN\"\n+  {\n+    rtx value = operands[2];\n+    /* See comment in arm_store_exclusive<mode> above.  */\n+    gcc_assert ((REGNO (value) & 1) == 0 || TARGET_THUMB2);\n+    operands[3] = gen_rtx_REG (SImode, REGNO (value) + 1);\n+    return \"stlexd%?\\t%0, %2, %3, %C1\";\n+  }\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"arm_store_release_exclusive<mode>\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n+\t(unspec_volatile:SI [(const_int 0)] VUNSPEC_SLX))\n+   (set (match_operand:QHSI 1 \"mem_noofs_operand\" \"=Ua\")\n+\t(unspec_volatile:QHSI\n+\t  [(match_operand:QHSI 2 \"s_register_operand\" \"r\")]\n+\t  VUNSPEC_SLX))]\n+  \"TARGET_HAVE_LDACQ\"\n+  \"stlex<sync_sfx>%?\\t%0, %2, %C1\"\n+  [(set_attr \"predicable\" \"yes\")])"}, {"sha": "508603cf6c8c8b6f480d8dfcc1879ba78776b181", "filename": "gcc/config/arm/unspecs.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad29f129eac4c5f092578dd1ae4550abf430557/gcc%2Fconfig%2Farm%2Funspecs.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad29f129eac4c5f092578dd1ae4550abf430557/gcc%2Fconfig%2Farm%2Funspecs.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funspecs.md?ref=5ad29f129eac4c5f092578dd1ae4550abf430557", "patch": "@@ -139,6 +139,10 @@\n   VUNSPEC_ATOMIC_OP\t; Represent an atomic operation.\n   VUNSPEC_LL\t\t; Represent a load-register-exclusive.\n   VUNSPEC_SC\t\t; Represent a store-register-exclusive.\n+  VUNSPEC_LAX\t\t; Represent a load-register-acquire-exclusive.\n+  VUNSPEC_SLX\t\t; Represent a store-register-release-exclusive.\n+  VUNSPEC_LDA\t\t; Represent a store-register-acquire.\n+  VUNSPEC_STL\t\t; Represent a store-register-release.\n ])\n \n ;; Enumerators for NEON unspecs."}]}