{"sha": "a5abb241f3c53daf6ebbb82992b5227fcdb750c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVhYmIyNDFmM2M1M2RhZjZlYmJiODI5OTJiNTIyN2ZjZGI3NTBjNQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2006-10-31T18:09:19Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T18:09:19Z"}, "message": "sem_elab.ads, [...] (Check_Elab_Assign): New procedure Add new calls to this procedure during traversal\n\n2006-10-31  Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_elab.ads, sem_elab.adb (Check_Elab_Assign): New procedure\n\tAdd new calls to this procedure during traversal\n\t(Activate_Elaborate_All_Desirable): Do not set elaboration flag on\n\tanother unit if expansion is disabled.\n\nFrom-SVN: r118309", "tree": {"sha": "24a69d825715b38bc694418ae9828e437a7f4ecc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24a69d825715b38bc694418ae9828e437a7f4ecc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5abb241f3c53daf6ebbb82992b5227fcdb750c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5abb241f3c53daf6ebbb82992b5227fcdb750c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5abb241f3c53daf6ebbb82992b5227fcdb750c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5abb241f3c53daf6ebbb82992b5227fcdb750c5/comments", "author": null, "committer": null, "parents": [{"sha": "67f3c450aa496462153743af600814121234b63c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67f3c450aa496462153743af600814121234b63c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67f3c450aa496462153743af600814121234b63c"}], "stats": {"total": 336, "additions": 289, "deletions": 47}, "files": [{"sha": "2e4b5c8fc79738be5004db0231cc232395ad3b2d", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 277, "deletions": 41, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5abb241f3c53daf6ebbb82992b5227fcdb750c5/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5abb241f3c53daf6ebbb82992b5227fcdb750c5/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=a5abb241f3c53daf6ebbb82992b5227fcdb750c5", "patch": "@@ -403,6 +403,13 @@ package body Sem_Elab is\n    --  Start of processing for Activate_Elaborate_All_Desirable\n \n    begin\n+      --  Do not set binder indication if expansion is disabled, as when\n+      --  compiling a generic unit.\n+\n+      if not Expander_Active then\n+         return;\n+      end if;\n+\n       Itm := First (CI);\n       while Present (Itm) loop\n          if Nkind (Itm) = N_With_Clause then\n@@ -1150,15 +1157,14 @@ package body Sem_Elab is\n          Write_Eol;\n       end if;\n \n-      --  Climb up the tree to make sure we are not inside a\n-      --  default expression of a parameter specification or\n-      --  a record component, since in both these cases, we\n-      --  will be doing the actual call later, not now, and it\n-      --  is at the time of the actual call (statically speaking)\n-      --  that we must do our static check, not at the time of\n-      --  its initial analysis). However, we have to check calls\n-      --  within component definitions (e.g., a function call\n-      --  that determines an array component bound), so we\n+      --  Climb up the tree to make sure we are not inside default expression\n+      --  of a parameter specification or a record component, since in both\n+      --  these cases, we will be doing the actual call later, not now, and it\n+      --  is at the time of the actual call (statically speaking) that we must\n+      --  do our static check, not at the time of its initial analysis).\n+\n+      --  However, we have to check calls within component definitions (e.g., a\n+      --  function call that determines an array component bound), so we\n       --  terminate the loop in that case.\n \n       P := Parent (N);\n@@ -1327,8 +1333,8 @@ package body Sem_Elab is\n                         return;\n \n                      --  Static model, call is not in elaboration code, we\n-                     --  never need to worry, because in the static model\n-                     --  the top level caller always takes care of things.\n+                     --  never need to worry, because in the static model the\n+                     --  top level caller always takes care of things.\n \n                      else\n                         return;\n@@ -1422,11 +1428,18 @@ package body Sem_Elab is\n          Process_Init_Proc : declare\n             Unit_Decl : constant Node_Id := Unit_Declaration_Node (Ent);\n \n-            function Process (Nod : Node_Id) return Traverse_Result;\n-            --  Find subprogram calls within body of init_proc for\n-            --  Traverse instantiation below.\n+            function Find_Init_Call (Nod : Node_Id) return Traverse_Result;\n+            --  Find subprogram calls within body of Init_Proc for Traverse\n+            --  instantiation below.\n \n-            function Process (Nod : Node_Id) return Traverse_Result is\n+            procedure Traverse_Body is new Traverse_Proc (Find_Init_Call);\n+            --  Traversal procedure to find all calls with body of Init_Proc\n+\n+            --------------------\n+            -- Find_Init_Call --\n+            --------------------\n+\n+            function Find_Init_Call (Nod : Node_Id) return Traverse_Result is\n                Func : Entity_Id;\n \n             begin\n@@ -1446,9 +1459,7 @@ package body Sem_Elab is\n                else\n                   return OK;\n                end if;\n-            end Process;\n-\n-            procedure Traverse_Body is new Traverse_Proc (Process);\n+            end Find_Init_Call;\n \n          --  Start of processing for Process_Init_Proc\n \n@@ -1460,6 +1471,205 @@ package body Sem_Elab is\n       end if;\n    end Check_Elab_Call;\n \n+   -----------------------\n+   -- Check_Elab_Assign --\n+   -----------------------\n+\n+   procedure Check_Elab_Assign (N : Node_Id) is\n+      Ent  : Entity_Id;\n+      Scop : Entity_Id;\n+\n+      Pkg_Spec : Entity_Id;\n+      Pkg_Body : Entity_Id;\n+\n+   begin\n+      --  For record or array component, check prefix. If it is an access\n+      --  type, then there is nothing to do (we do not know what is being\n+      --  assigned), but otherwise this is an assignment to the prefix.\n+\n+      if Nkind (N) = N_Indexed_Component\n+           or else\n+         Nkind (N) = N_Selected_Component\n+           or else\n+         Nkind (N) = N_Slice\n+      then\n+         if not Is_Access_Type (Etype (Prefix (N))) then\n+            Check_Elab_Assign (Prefix (N));\n+         end if;\n+\n+         return;\n+      end if;\n+\n+      --  For type conversion, check expression\n+\n+      if Nkind (N) = N_Type_Conversion then\n+         Check_Elab_Assign (Expression (N));\n+         return;\n+      end if;\n+\n+      --  Nothing to do if this is not an entity reference otherwise get entity\n+\n+      if Is_Entity_Name (N) then\n+         Ent := Entity (N);\n+      else\n+         return;\n+      end if;\n+\n+      --  What we are looking for is a reference in the body of a package that\n+      --  modifies a variable declared in the visible part of the package spec.\n+\n+      if Present (Ent)\n+        and then Comes_From_Source (N)\n+        and then not Suppress_Elaboration_Warnings (Ent)\n+        and then Ekind (Ent) = E_Variable\n+        and then not In_Private_Part (Ent)\n+        and then Is_Library_Level_Entity (Ent)\n+      then\n+         Scop := Current_Scope;\n+         loop\n+            if No (Scop) or else Scop = Standard_Standard then\n+               return;\n+            elsif Ekind (Scop) = E_Package\n+              and then Is_Compilation_Unit (Scop)\n+            then\n+               exit;\n+            else\n+               Scop := Scope (Scop);\n+            end if;\n+         end loop;\n+\n+         --  Here Scop points to the containing library package\n+\n+         Pkg_Spec := Scop;\n+         Pkg_Body := Body_Entity (Pkg_Spec);\n+\n+         --  All OK if the package has an Elaborate_Body pragma\n+\n+         if Has_Pragma_Elaborate_Body (Scop) then\n+            return;\n+         end if;\n+\n+         --  OK if entity being modified is not in containing package spec\n+\n+         if not In_Same_Source_Unit (Scop, Ent) then\n+            return;\n+         end if;\n+\n+         --  All OK if entity appears in generic package or generic instance.\n+         --  We just get too messed up trying to give proper warnings in the\n+         --  presence of generics. Better no message than a junk one.\n+\n+         Scop := Scope (Ent);\n+         while Present (Scop) and then Scop /= Pkg_Spec loop\n+            if Ekind (Scop) = E_Generic_Package then\n+               return;\n+            elsif Ekind (Scop) = E_Package\n+              and then Is_Generic_Instance (Scop)\n+            then\n+               return;\n+            end if;\n+\n+            Scop := Scope (Scop);\n+         end loop;\n+\n+         --  All OK if in task, don't issue warnings there\n+\n+         if In_Task_Activation then\n+            return;\n+         end if;\n+\n+         --  OK if no package body\n+\n+         if No (Pkg_Body) then\n+            return;\n+         end if;\n+\n+         --  OK if reference is not in package body\n+\n+         if not In_Same_Source_Unit (Pkg_Body, N) then\n+            return;\n+         end if;\n+\n+         --  OK if package body has no handled statement sequence\n+\n+         declare\n+            HSS : constant Node_Id :=\n+                    Handled_Statement_Sequence (Declaration_Node (Pkg_Body));\n+         begin\n+            if No (HSS) or else not Comes_From_Source (HSS) then\n+               return;\n+            end if;\n+         end;\n+\n+         --  We definitely have a case of a modification of an entity in\n+         --  the package spec from the elaboration code of the package body.\n+         --  We may not give the warning (because there are some additional\n+         --  checks to avoid too many false positives), but it would be a good\n+         --  idea for the binder to try to keep the body elaboration close to\n+         --  the spec elaboration.\n+\n+         Set_Elaborate_Body_Desirable (Pkg_Spec);\n+\n+         --  All OK in gnat mode (we know what we are doing)\n+\n+         if GNAT_Mode then\n+            return;\n+         end if;\n+\n+         --  All OK if warnings suppressed on the entity\n+\n+         if Warnings_Off (Ent) then\n+            return;\n+         end if;\n+\n+         --  All OK if all warnings suppressed\n+\n+         if Warning_Mode = Suppress then\n+            return;\n+         end if;\n+\n+         --  All OK if elaboration checks suppressed for entity\n+\n+         if Checks_May_Be_Suppressed (Ent)\n+           and then Is_Check_Suppressed (Ent, Elaboration_Check)\n+         then\n+            return;\n+         end if;\n+\n+         --  OK if the entity is initialized. Note that the No_Initialization\n+         --  flag usually means that the initialization has been rewritten into\n+         --  assignments, but that still counts for us.\n+\n+         declare\n+            Decl : constant Node_Id := Declaration_Node (Ent);\n+         begin\n+            if Nkind (Decl) = N_Object_Declaration\n+              and then (Present (Expression (Decl))\n+                          or else No_Initialization (Decl))\n+            then\n+               return;\n+            end if;\n+         end;\n+\n+         --  Here is where we give the warning\n+\n+         Error_Msg_Sloc := Sloc (Ent);\n+\n+         Error_Msg_NE\n+           (\"?elaboration code may access& before it is initialized\",\n+            N, Ent);\n+         Error_Msg_NE\n+           (\"\\?suggest adding pragma Elaborate_Body to spec of &\",\n+            N, Scop);\n+         Error_Msg_N\n+           (\"\\?or an explicit initialization could be added #\", N);\n+\n+         if not All_Errors_Mode then\n+            Set_Suppress_Elaboration_Warnings (Ent);\n+         end if;\n+      end if;\n+   end Check_Elab_Assign;\n+\n    ----------------------\n    -- Check_Elab_Calls --\n    ----------------------\n@@ -1690,16 +1900,22 @@ package body Sem_Elab is\n       Sbody : Node_Id;\n       Ebody : Entity_Id;\n \n-      function Process (N : Node_Id) return Traverse_Result;\n-      --  Function applied to each node as we traverse the body.\n-      --  Checks for call that needs checking, and if so checks\n-      --  it. Always returns OK, so entire tree is traversed.\n+      function Find_Elab_Reference (N : Node_Id) return Traverse_Result;\n+      --  Function applied to each node as we traverse the body. Checks for\n+      --  call or entity reference that needs checking, and if so checks it.\n+      --  Always returns OK, so entire tree is traversed, except that as\n+      --  described below subprogram bodies are skipped for now.\n+\n+      procedure Traverse is new Atree.Traverse_Proc (Find_Elab_Reference);\n+      --  Traverse procedure using above Find_Elab_Reference function\n+\n+      -------------------------\n+      -- Find_Elab_Reference --\n+      -------------------------\n \n-      -------------\n-      -- Process --\n-      -------------\n+      function Find_Elab_Reference (N : Node_Id) return Traverse_Result is\n+         Actual : Node_Id;\n \n-      function Process (N : Node_Id) return Traverse_Result is\n       begin\n          --  If user has specified that there are no entry calls in elaboration\n          --  code, do not trace past an accept statement, because the rendez-\n@@ -1711,12 +1927,27 @@ package body Sem_Elab is\n          then\n             return Abandon;\n \n-         --  If we have a subprogram call, check it\n+            --  If we have a function call, check it\n \n-         elsif Nkind (N) = N_Function_Call\n-           or else Nkind (N) = N_Procedure_Call_Statement\n-         then\n+         elsif Nkind (N) = N_Function_Call then\n+            Check_Elab_Call (N, Outer_Scope);\n+            return OK;\n+\n+         --  If we have a procedure call, check the call, and also check\n+         --  arguments that are assignments (OUT or IN OUT mode formals).\n+\n+         elsif Nkind (N) = N_Procedure_Call_Statement then\n             Check_Elab_Call (N, Outer_Scope);\n+\n+            Actual := First_Actual (N);\n+            while Present (Actual) loop\n+               if Known_To_Be_Assigned (Actual) then\n+                  Check_Elab_Assign (Actual);\n+               end if;\n+\n+               Next_Actual (Actual);\n+            end loop;\n+\n             return OK;\n \n          --  If we have a generic instantiation, check it\n@@ -1741,13 +1972,16 @@ package body Sem_Elab is\n          then\n             return Skip;\n \n+         elsif Nkind (N) = N_Assignment_Statement\n+           and then Comes_From_Source (N)\n+         then\n+            Check_Elab_Assign (Name (N));\n+            return OK;\n+\n          else\n             return OK;\n          end if;\n-      end Process;\n-\n-      procedure Traverse is new Atree.Traverse_Proc;\n-      --  Traverse procedure using above Process function\n+      end Find_Elab_Reference;\n \n    --  Start of processing for Check_Internal_Call_Continue\n \n@@ -1893,13 +2127,14 @@ package body Sem_Elab is\n \n                   Set_Elaboration_Flag (Sbody, E);\n \n-                  --  Kill current value indication. This is necessary\n-                  --  because the tests of this flag are inserted out of\n-                  --  sequence and must not pick up bogus indications of\n-                  --  the wrong constant value. Also, this is never a true\n-                  --  constant, since one way or another, it gets reset.\n+                  --  Kill current value indication. This is necessary because\n+                  --  the tests of this flag are inserted out of sequence and\n+                  --  must not pick up bogus indications of the wrong constant\n+                  --  value. Also, this is never a true constant, since one way\n+                  --  or another, it gets reset.\n \n                   Set_Current_Value    (Ent, Empty);\n+                  Set_Last_Assignment  (Ent, Empty);\n                   Set_Is_True_Constant (Ent, False);\n                   Pop_Scope;\n                end;\n@@ -2118,6 +2353,7 @@ package body Sem_Elab is\n       --  We only perform detailed checks in all tasks are library level\n       --  entities. If the master is a subprogram or task, activation will\n       --  depend on the activation of the master itself.\n+\n       --  Should dynamic checks be added in the more general case???\n \n       if Ekind (Enclosing) /= E_Package then\n@@ -2252,8 +2488,8 @@ package body Sem_Elab is\n          --  object is the first actual in the call.\n \n          declare\n-            Typ  : constant Entity_Id :=\n-                     Etype (First (Parameter_Associations (Call)));\n+            Typ : constant Entity_Id :=\n+                    Etype (First (Parameter_Associations (Call)));\n          begin\n             Elab_Unit := Scope (Typ);\n             while (Present (Elab_Unit))"}, {"sha": "db7db675880bf1ba1c25fb97c2959956193a451a", "filename": "gcc/ada/sem_elab.ads", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5abb241f3c53daf6ebbb82992b5227fcdb750c5/gcc%2Fada%2Fsem_elab.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5abb241f3c53daf6ebbb82992b5227fcdb750c5/gcc%2Fada%2Fsem_elab.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.ads?ref=a5abb241f3c53daf6ebbb82992b5227fcdb750c5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1997-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1997-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -120,11 +120,11 @@ package Sem_Elab is\n    --  corresponding bodies.\n \n    procedure Check_Elab_Call (N : Node_Id; Outer_Scope : Entity_Id := Empty);\n-   --  Check a call for possible elaboration problems. N is either an\n-   --  N_Function_Call or N_Procedure_Call_Statement node, and Outer\n-   --  indicates whether this is an outer level call from Sem_Res\n-   --  (Outer_Scope set to Empty), or an internal recursive call\n-   --  (Outer_Scope set to entity of outermost call, see body).\n+   --  Check a call for possible elaboration problems. The node N is either\n+   --  an N_Function_Call or N_Procedure_Call_Statement node. The Outer_Scope\n+   --  argument indicates whether this is an outer level call from Sem_Res\n+   --  (Outer_Scope set to Empty), or an internal recursive call (Outer_Scope\n+   --  set to entity of outermost call, see body).\n \n    procedure Check_Elab_Calls;\n    --  Not all the processing for Check_Elab_Call can be done at the time\n@@ -133,6 +133,12 @@ package Sem_Elab is\n    --  instantiated. The Check_Elab_Calls procedure cleans up these waiting\n    --  checks. It is called once after the completion of instantiation.\n \n+   procedure Check_Elab_Assign (N : Node_Id);\n+   --  N is either the left side of an assignment, or a procedure argument for\n+   --  a mode OUT or IN OUT formal. This procedure checks for a possible case\n+   --  of access to an entity from elaboration code before the entity has been\n+   --  initialized, and issues appropriate warnings.\n+\n    procedure Check_Elab_Instantiation\n      (N           : Node_Id;\n       Outer_Scope : Entity_Id := Empty);"}]}