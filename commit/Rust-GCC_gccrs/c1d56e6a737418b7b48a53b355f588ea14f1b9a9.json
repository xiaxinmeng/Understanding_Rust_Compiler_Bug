{"sha": "c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFkNTZlNmE3Mzc0MThiN2I0OGE1M2IzNTVmNTg4ZWExNGYxYjlhOQ==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-02-04T21:34:22Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-02-04T22:04:48Z"}, "message": "d: Merge upstream dmd 46133f761, druntime 0fd4364c\n\nD front-end changes:\n\n - Backported built-in function handling from upstream.\n\n - Added new intrinsic `byteswap(ushort)`.\n\nDruntime changes:\n\n - Update intrinsic modules core.bitop, core.checkedint, core.simd,\n   core.vararg, and core.volatile.\n\n - Backport platform-specific fixes for runtime modules core.cpuid,\n   core.internal.traits, and rt.lifetime.\n\n - Backport openbsd fixes for core.stdc.stdio.\n\n - Backport solaris fixes for core.sys.posix.locale, and\n   core.thread.osthread (PR98910).\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd 46133f761.\n\t* d-builtins.cc (d_build_builtins_module): Set builtins as BUILTINgcc.\n\t(maybe_set_builtin_1): Likewise.\n\t* d-frontend.cc (eval_builtin): Adjust condition for early return.\n\t* intrinsics.cc (maybe_set_intrinsic): Set intrinsics as BUILTINgcc.\n\t(maybe_expand_intrinsic): Add case for INTRINSIC_BSWAP16.\n\t* intrinsics.def (INTRINSIC_BT): Update signature.\n\t(INTRINSIC_BT64): Likewise.\n\t(INTRINSIC_BSWAP16): New intrinsic.\n\t(INTRINSIC_VLOAD8): Update module.\n\t(INTRINSIC_VLOAD16): Likewise.\n\t(INTRINSIC_VLOAD32): Likewise.\n\t(INTRINSIC_VLOAD64): Likewise.\n\t(INTRINSIC_VSTORE8): Likewise.\n\t(INTRINSIC_VSTORE16): Likewise.\n\t(INTRINSIC_VSTORE32): Likewise.\n\t(INTRINSIC_VSTORE64): Likewise.\n\t(INTRINSIC_ADDS): Update signature.\n\t(INTRINSIC_ADDSL): Likewise.\n\t(INTRINSIC_ADDU): Likewise.\n\t(INTRINSIC_ADDUL): Likewise.\n\t(INTRINSIC_SUBS): Likewise.\n\t(INTRINSIC_SUBSL): Likewise.\n\t(INTRINSIC_SUBU): Likewise.\n\t(INTRINSIC_SUBUL): Likewise.\n\t(INTRINSIC_MULS): Likewise.\n\t(INTRINSIC_MULSL): Likewise.\n\t(INTRINSIC_MULU): Likewise.\n\t(INTRINSIC_MULUI): Likewise.\n\t(INTRINSIC_MULUL): Likewise.\n\t(INTRINSIC_NEGS): Likewise.\n\t(INTRINSIC_NEGSL): Likewise.\n\nlibphobos/ChangeLog:\n\n\tPR d/98910\n\t* libdruntime/MERGE: Merge upstream druntime 0fd4364c.\n\t* libdruntime/Makefile.am (DRUNTIME_DSOURCES): Add core/volatile.d.\n\t* libdruntime/Makefile.in: Regenerate.\n\t* testsuite/libphobos.allocations/tls_gc_integration.d: Update test.\n\ngcc/testsuite/ChangeLog:\n\n\t* gdc.dg/intrinsics.d: Update test.", "tree": {"sha": "5c225e580416206cdd237db00cbf63d030067662", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c225e580416206cdd237db00cbf63d030067662"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce5720447c69286599b96bae53ae854b1bbe41fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce5720447c69286599b96bae53ae854b1bbe41fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce5720447c69286599b96bae53ae854b1bbe41fa"}], "stats": {"total": 2098, "additions": 1329, "deletions": 769}, "files": [{"sha": "c45edc2fa3fd57dd3a5b1a72c3fc1a349c7609e6", "filename": "gcc/d/d-builtins.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/gcc%2Fd%2Fd-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/gcc%2Fd%2Fd-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-builtins.cc?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -566,7 +566,7 @@ d_build_builtins_module (Module *m)\n \t\t\t\t   STCextern, tf);\n       DECL_LANG_SPECIFIC (decl) = build_lang_decl (func);\n       func->csym = decl;\n-      func->builtin = BUILTINyes;\n+      func->builtin = BUILTINgcc;\n \n       members->push (func);\n     }\n@@ -706,7 +706,7 @@ maybe_set_builtin_1 (Dsymbol *d)\n \t  /* Found a match, tell the frontend this is a builtin.  */\n \t  DECL_LANG_SPECIFIC (t) = build_lang_decl (fd);\n \t  fd->csym = t;\n-\t  fd->builtin = BUILTINyes;\n+\t  fd->builtin = BUILTINgcc;\n \t  return;\n \t}\n     }"}, {"sha": "84c70f8ee6a3f6bdbecd33df3aaef7ebce5c50e7", "filename": "gcc/d/d-frontend.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/gcc%2Fd%2Fd-frontend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/gcc%2Fd%2Fd-frontend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-frontend.cc?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -158,7 +158,7 @@ isBuiltin (FuncDeclaration *fd)\n Expression *\n eval_builtin (Loc loc, FuncDeclaration *fd, Expressions *arguments)\n {\n-  if (fd->builtin != BUILTINyes)\n+  if (fd->builtin == BUILTINunimp)\n     return NULL;\n \n   tree decl = get_symbol_decl (fd);"}, {"sha": "89397c836e2d2f8ffabfd6a98be01121e83492d9", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -1,4 +1,4 @@\n-5e2a81d9cbcd653d9eed52344d664e72ba1355bc\n+46133f76172c26c89e2ebf9cd058cd1f1e8807ed\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "6a3ec9e7d5c4457abba65c4259edf6aea59c55c3", "filename": "gcc/d/dmd/declaration.h", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/gcc%2Fd%2Fdmd%2Fdeclaration.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/gcc%2Fd%2Fdmd%2Fdeclaration.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.h?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -503,9 +503,43 @@ enum ILS\n \n enum BUILTIN\n {\n-    BUILTINunknown = -1,        // not known if this is a builtin\n-    BUILTINno,                  // this is not a builtin\n-    BUILTINyes                  // this is a builtin\n+    BUILTINunknown = 255,   /// not known if this is a builtin\n+    BUILTINunimp = 0,       /// this is not a builtin\n+    BUILTINgcc,             /// this is a GCC builtin\n+    BUILTINllvm,            /// this is an LLVM builtin\n+    BUILTINsin,\n+    BUILTINcos,\n+    BUILTINtan,\n+    BUILTINsqrt,\n+    BUILTINfabs,\n+    BUILTINldexp,\n+    BUILTINlog,\n+    BUILTINlog2,\n+    BUILTINlog10,\n+    BUILTINexp,\n+    BUILTINexpm1,\n+    BUILTINexp2,\n+    BUILTINround,\n+    BUILTINfloor,\n+    BUILTINceil,\n+    BUILTINtrunc,\n+    BUILTINcopysign,\n+    BUILTINpow,\n+    BUILTINfmin,\n+    BUILTINfmax,\n+    BUILTINfma,\n+    BUILTINisnan,\n+    BUILTINisinfinity,\n+    BUILTINisfinite,\n+    BUILTINbsf,\n+    BUILTINbsr,\n+    BUILTINbswap,\n+    BUILTINpopcnt,\n+    BUILTINyl2x,\n+    BUILTINyl2xp1,\n+    BUILTINtoPrecFloat,\n+    BUILTINtoPrecDouble,\n+    BUILTINtoPrecReal\n };\n \n Expression *eval_builtin(Loc loc, FuncDeclaration *fd, Expressions *arguments);"}, {"sha": "f868790f9e73dd4f5a9274f91c8e6a6fdf82a5ef", "filename": "gcc/d/dmd/dinterpret.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/gcc%2Fd%2Fdmd%2Fdinterpret.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/gcc%2Fd%2Fdmd%2Fdinterpret.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdinterpret.c?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -6801,7 +6801,7 @@ Expression *evaluateIfBuiltin(UnionExp *pue, InterState *istate, Loc loc,\n     size_t nargs = arguments ? arguments->length : 0;\n     if (!pthis)\n     {\n-        if (isBuiltin(fd) == BUILTINyes)\n+        if (isBuiltin(fd) != BUILTINunimp)\n         {\n             Expressions args;\n             args.setDim(nargs);"}, {"sha": "322a293cf09100d8740fe0c87f3149b972babd6b", "filename": "gcc/d/dmd/idgen.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/gcc%2Fd%2Fdmd%2Fidgen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/gcc%2Fd%2Fdmd%2Fidgen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fidgen.c?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -291,6 +291,8 @@ Msgtable msgtable[] =\n     { \"entrypoint\", \"__entrypoint\" },\n \n     // varargs implementation\n+    { \"stdc\", NULL },\n+    { \"stdarg\", NULL },\n     { \"va_start\", NULL },\n \n     // Builtin functions\n@@ -304,16 +306,52 @@ Msgtable msgtable[] =\n     { \"_sqrt\", \"sqrt\" },\n     { \"_pow\", \"pow\" },\n     { \"atan2\", NULL },\n+    { \"rint\", NULL },\n+    { \"ldexp\", NULL },\n     { \"rndtol\", NULL },\n+    { \"exp\", NULL },\n     { \"expm1\", NULL },\n     { \"exp2\", NULL },\n     { \"yl2x\", NULL },\n     { \"yl2xp1\", NULL },\n+    { \"log\", NULL },\n+    { \"log2\", NULL },\n+    { \"log10\", NULL },\n+    { \"round\", NULL },\n+    { \"floor\", NULL },\n+    { \"trunc\", NULL },\n+    { \"fmax\", NULL },\n+    { \"fmin\", NULL },\n+    { \"fma\", NULL },\n+    { \"isnan\", NULL },\n+    { \"isInfinity\", NULL },\n+    { \"isfinite\", NULL },\n+    { \"ceil\", NULL },\n+    { \"copysign\", NULL },\n     { \"fabs\", NULL },\n+    { \"toPrec\", NULL },\n+    { \"simd\", NULL },\n+    { \"__prefetch\", NULL },\n+    { \"__simd_sto\", NULL },\n+    { \"__simd\", NULL },\n+    { \"__simd_ib\", NULL },\n     { \"bitop\", NULL },\n     { \"bsf\", NULL },\n     { \"bsr\", NULL },\n+    { \"btc\", NULL },\n+    { \"btr\", NULL },\n+    { \"bts\", NULL },\n     { \"bswap\", NULL },\n+    { \"_volatile\", \"volatile\" },\n+    { \"volatileLoad\", NULL },\n+    { \"volatileStore\", NULL },\n+    { \"_popcnt\", NULL },\n+    { \"inp\", NULL },\n+    { \"inpl\", NULL },\n+    { \"inpw\", NULL },\n+    { \"outp\", NULL },\n+    { \"outpl\", NULL },\n+    { \"outpw\", NULL },\n \n     // Traits\n     { \"isAbstractClass\", NULL },"}, {"sha": "4cdf362e598224387ba471898b3d347297da0f40", "filename": "gcc/d/dmd/root/ctfloat.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.h?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -29,6 +29,24 @@ struct CTFloat\n     static real_t fabs(real_t x);\n     static real_t ldexp(real_t n, int exp);\n \n+    static real_t round(real_t x);\n+    static real_t floor(real_t x);\n+    static real_t ceil(real_t x);\n+    static real_t trunc(real_t x);\n+    static real_t log(real_t x);\n+    static real_t log2(real_t x);\n+    static real_t log10(real_t x);\n+    static real_t pow(real_t x, real_t y);\n+    static real_t exp(real_t x);\n+    static real_t expm1(real_t x);\n+    static real_t exp2(real_t x);\n+\n+    static real_t fmin(real_t x, real_t y);\n+    static real_t fmax(real_t x, real_t y);\n+    static real_t copysign(real_t x, real_t s);\n+\n+    static real_t fma(real_t x, real_t y, real_t z);\n+\n     static bool isIdentical(real_t a, real_t b);\n     static bool isNaN(real_t r);\n     static bool isSNaN(real_t r);"}, {"sha": "7f97c1d1fa8d7804bb89531e12867403473f01fa", "filename": "gcc/d/intrinsics.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/gcc%2Fd%2Fintrinsics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/gcc%2Fd%2Fintrinsics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fintrinsics.cc?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -81,7 +81,7 @@ maybe_set_intrinsic (FuncDeclaration *decl)\n \n   /* The builtin flag is updated only if we can evaluate the intrinsic\n      at compile-time.  Such as the math or bitop intrinsics.  */\n-  decl->builtin = BUILTINno;\n+  decl->builtin = BUILTINunimp;\n \n   /* Check if it's a compiler intrinsic.  We only require that any\n      internally recognised intrinsics are declared in a module with\n@@ -177,12 +177,12 @@ maybe_set_intrinsic (FuncDeclaration *decl)\n \t\t built-in function.  It could be `int pow(int, int)'.  */\n \t      tree rettype = TREE_TYPE (TREE_TYPE (decl->csym));\n \t      if (mathfn_built_in (rettype, BUILT_IN_POW) != NULL_TREE)\n-\t\tdecl->builtin = BUILTINyes;\n+\t\tdecl->builtin = BUILTINgcc;\n \t      break;\n \t    }\n \n \t    default:\n-\t      decl->builtin = BUILTINyes;\n+\t      decl->builtin = BUILTINgcc;\n \t      break;\n \t    }\n \n@@ -809,6 +809,7 @@ maybe_expand_intrinsic (tree callexp)\n     case INTRINSIC_ROR_TIARG:\n       return expand_intrinsic_rotate (intrinsic, callexp);\n \n+    case INTRINSIC_BSWAP16:\n     case INTRINSIC_BSWAP32:\n     case INTRINSIC_BSWAP64:\n     case INTRINSIC_CEIL:"}, {"sha": "dc6b104f6d5608eb4e62b113e26f722ff42eb3b1", "filename": "gcc/d/intrinsics.def", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/gcc%2Fd%2Fintrinsics.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/gcc%2Fd%2Fintrinsics.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fintrinsics.def?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -42,17 +42,18 @@ DEF_D_BUILTIN (NONE, NONE, 0, 0, 0)\n \n DEF_D_BUILTIN (BSF, NONE, \"bsf\", \"core.bitop\", \"FNaNbNiNfkZi\")\n DEF_D_BUILTIN (BSR, NONE, \"bsr\", \"core.bitop\", \"FNaNbNiNfkZi\")\n-DEF_D_BUILTIN (BT, NONE, \"bt\", \"core.bitop\", \"FNaNbNixPkkZi\")\n+DEF_D_BUILTIN (BT, NONE, \"bt\", \"core.bitop\", \"FNaNbNiMxPkkZi\")\n DEF_D_BUILTIN (BTC, NONE, \"btc\", \"core.bitop\", \"FNaNbNiPkkZi\")\n DEF_D_BUILTIN (BTR, NONE, \"btr\", \"core.bitop\", \"FNaNbNiPkkZi\")\n DEF_D_BUILTIN (BTS, NONE, \"bts\", \"core.bitop\", \"FNaNbNiPkkZi\")\n DEF_D_BUILTIN (BSF64, NONE, \"bsf\", \"core.bitop\", \"FNaNbNiNfmZi\")\n DEF_D_BUILTIN (BSR64, NONE, \"bsr\", \"core.bitop\", \"FNaNbNiNfmZi\")\n-DEF_D_BUILTIN (BT64, NONE, \"bt\", \"core.bitop\", \"FNaNbNixPmmZi\")\n+DEF_D_BUILTIN (BT64, NONE, \"bt\", \"core.bitop\", \"FNaNbNiMxPmmZi\")\n DEF_D_BUILTIN (BTC64, NONE, \"btc\", \"core.bitop\", \"FNaNbNiPmmZi\")\n DEF_D_BUILTIN (BTR64, NONE, \"btr\", \"core.bitop\", \"FNaNbNiPmmZi\")\n DEF_D_BUILTIN (BTS64, NONE, \"bts\", \"core.bitop\", \"FNaNbNiPmmZi\")\n \n+DEF_D_BUILTIN (BSWAP16, BSWAP16, \"byteswap\", \"core.bitop\", \"FNaNbNiNftZt\")\n DEF_D_BUILTIN (BSWAP32, BSWAP32, \"bswap\", \"core.bitop\", \"FNaNbNiNfkZk\")\n DEF_D_BUILTIN (BSWAP64, BSWAP64, \"bswap\", \"core.bitop\", \"FNaNbNiNfmZm\")\n \n@@ -64,32 +65,34 @@ DEF_D_BUILTIN (ROL_TIARG, NONE, \"rol\", \"core.bitop\", \"FNaI1TZI1T\")\n DEF_D_BUILTIN (ROR, NONE, \"ror\", \"core.bitop\", \"FNaI1TkZI1T\")\n DEF_D_BUILTIN (ROR_TIARG, NONE, \"ror\", \"core.bitop\", \"FNaI1TZI1T\")\n \n-DEF_D_BUILTIN (VLOAD8, NONE, \"volatileLoad\", \"core.bitop\", \"FNbNiNfPhZh\")\n-DEF_D_BUILTIN (VLOAD16, NONE, \"volatileLoad\", \"core.bitop\", \"FNbNiNfPtZt\")\n-DEF_D_BUILTIN (VLOAD32, NONE, \"volatileLoad\", \"core.bitop\", \"FNbNiNfPkZk\")\n-DEF_D_BUILTIN (VLOAD64, NONE, \"volatileLoad\", \"core.bitop\", \"FNbNiNfPmZm\")\n-DEF_D_BUILTIN (VSTORE8, NONE, \"volatileStore\", \"core.bitop\", \"FNbNiNfPhhZv\")\n-DEF_D_BUILTIN (VSTORE16, NONE, \"volatileStore\", \"core.bitop\", \"FNbNiNfPttZv\")\n-DEF_D_BUILTIN (VSTORE32, NONE, \"volatileStore\", \"core.bitop\", \"FNbNiNfPkkZv\")\n-DEF_D_BUILTIN (VSTORE64, NONE, \"volatileStore\", \"core.bitop\", \"FNbNiNfPmmZv\")\n+/* core.volatile intrinsics.  */\n+\n+DEF_D_BUILTIN (VLOAD8, NONE, \"volatileLoad\", \"core.volatile\", \"FNbNiNfPhZh\")\n+DEF_D_BUILTIN (VLOAD16, NONE, \"volatileLoad\", \"core.volatile\", \"FNbNiNfPtZt\")\n+DEF_D_BUILTIN (VLOAD32, NONE, \"volatileLoad\", \"core.volatile\", \"FNbNiNfPkZk\")\n+DEF_D_BUILTIN (VLOAD64, NONE, \"volatileLoad\", \"core.volatile\", \"FNbNiNfPmZm\")\n+DEF_D_BUILTIN (VSTORE8, NONE, \"volatileStore\", \"core.volatile\", \"FNbNiNfPhhZv\")\n+DEF_D_BUILTIN (VSTORE16, NONE, \"volatileStore\", \"core.volatile\", \"FNbNiNfPttZv\")\n+DEF_D_BUILTIN (VSTORE32, NONE, \"volatileStore\", \"core.volatile\", \"FNbNiNfPkkZv\")\n+DEF_D_BUILTIN (VSTORE64, NONE, \"volatileStore\", \"core.volatile\", \"FNbNiNfPmmZv\")\n \n /* core.checkedint intrinsics.  */\n \n-DEF_D_BUILTIN (ADDS, NONE, \"adds\", \"core.checkedint\", \"FNaNbNiNfiiKbZi\")\n-DEF_D_BUILTIN (ADDSL, NONE, \"adds\", \"core.checkedint\", \"FNaNbNiNfllKbZl\")\n-DEF_D_BUILTIN (ADDU, NONE, \"addu\", \"core.checkedint\", \"FNaNbNiNfkkKbZk\")\n-DEF_D_BUILTIN (ADDUL, NONE, \"addu\", \"core.checkedint\", \"FNaNbNiNfmmKbZm\")\n-DEF_D_BUILTIN (SUBS, NONE, \"subs\", \"core.checkedint\", \"FNaNbNiNfiiKbZi\")\n-DEF_D_BUILTIN (SUBSL, NONE, \"subs\", \"core.checkedint\", \"FNaNbNiNfllKbZl\")\n-DEF_D_BUILTIN (SUBU, NONE, \"subu\", \"core.checkedint\", \"FNaNbNiNfkkKbZk\")\n-DEF_D_BUILTIN (SUBUL, NONE, \"subu\", \"core.checkedint\", \"FNaNbNiNfmmKbZm\")\n-DEF_D_BUILTIN (MULS, NONE, \"muls\", \"core.checkedint\", \"FNaNbNiNfiiKbZi\")\n-DEF_D_BUILTIN (MULSL, NONE, \"muls\", \"core.checkedint\", \"FNaNbNiNfllKbZl\")\n-DEF_D_BUILTIN (MULU, NONE, \"mulu\", \"core.checkedint\", \"FNaNbNiNfkkKbZk\")\n-DEF_D_BUILTIN (MULUI, NONE, \"mulu\", \"core.checkedint\", \"FNaNbNiNfmkKbZm\")\n-DEF_D_BUILTIN (MULUL, NONE, \"mulu\", \"core.checkedint\", \"FNaNbNiNfmmKbZm\")\n-DEF_D_BUILTIN (NEGS, NONE, \"negs\", \"core.checkedint\", \"FNaNbNiNfiKbZi\")\n-DEF_D_BUILTIN (NEGSL, NONE, \"negs\", \"core.checkedint\", \"FNaNbNiNflKbZl\")\n+DEF_D_BUILTIN (ADDS, NONE, \"adds\", \"core.checkedint\", \"FiiKbZi\")\n+DEF_D_BUILTIN (ADDSL, NONE, \"adds\", \"core.checkedint\", \"FllKbZl\")\n+DEF_D_BUILTIN (ADDU, NONE, \"addu\", \"core.checkedint\", \"FkkKbZk\")\n+DEF_D_BUILTIN (ADDUL, NONE, \"addu\", \"core.checkedint\", \"FmmKbZm\")\n+DEF_D_BUILTIN (SUBS, NONE, \"subs\", \"core.checkedint\", \"FiiKbZi\")\n+DEF_D_BUILTIN (SUBSL, NONE, \"subs\", \"core.checkedint\", \"FllKbZl\")\n+DEF_D_BUILTIN (SUBU, NONE, \"subu\", \"core.checkedint\", \"FkkKbZk\")\n+DEF_D_BUILTIN (SUBUL, NONE, \"subu\", \"core.checkedint\", \"FmmKbZm\")\n+DEF_D_BUILTIN (MULS, NONE, \"muls\", \"core.checkedint\", \"FiiKbZi\")\n+DEF_D_BUILTIN (MULSL, NONE, \"muls\", \"core.checkedint\", \"FllKbZl\")\n+DEF_D_BUILTIN (MULU, NONE, \"mulu\", \"core.checkedint\", \"FkkKbZk\")\n+DEF_D_BUILTIN (MULUI, NONE, \"mulu\", \"core.checkedint\", \"FmkKbZm\")\n+DEF_D_BUILTIN (MULUL, NONE, \"mulu\", \"core.checkedint\", \"FmmKbZm\")\n+DEF_D_BUILTIN (NEGS, NONE, \"negs\", \"core.checkedint\", \"FiKbZi\")\n+DEF_D_BUILTIN (NEGSL, NONE, \"negs\", \"core.checkedint\", \"FlKbZl\")\n \n /* core.math intrinsics.  */\n "}, {"sha": "d9ccc0ec5cedb01796c8acb3735a45249f28a8f2", "filename": "gcc/testsuite/gdc.dg/intrinsics.d", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/gcc%2Ftestsuite%2Fgdc.dg%2Fintrinsics.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/gcc%2Ftestsuite%2Fgdc.dg%2Fintrinsics.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fintrinsics.d?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -3,6 +3,7 @@\n import core.bitop;\n import core.checkedint;\n import core.math;\n+import core.volatile;\n import core.stdc.stdarg;\n \n //////////////////////////////////////////////////////\n@@ -24,6 +25,8 @@ int test_btc(size_t *a, size_t b) { return btc(a, b); }\n int test_btr(size_t *a, size_t b) { return btr(a, b); }\n // { dg-final { scan-tree-dump-not \" <retval> = bts \" \"original\" } }\n int test_bts(size_t *a, size_t b) { return bts(a, b); }\n+// { dg-final { scan-tree-dump \" __builtin_bswap16 \" \"original\" } }\n+ushort test_byteswap(ushort a) { return byteswap(a); }\n // { dg-final { scan-tree-dump \" __builtin_bswap32 \" \"original\" } }\n uint test_bswap(uint a) { return bswap(a); }\n // { dg-final { scan-tree-dump \" __builtin_bswap64 \" \"original\" } }"}, {"sha": "a4a9a940baf74c6e05342cc2598ad8c827a56ada", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -1,4 +1,4 @@\n-9d0c8364450064d0b6e68da4384f8acd19eb454f\n+0fd4364c4a4eb2ce0ebb8f613092c5bed7a63bf9\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/druntime repository."}, {"sha": "945271e028f9db8b1fd442329126547ea5a8eaa2", "filename": "libphobos/libdruntime/Makefile.am", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.am?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -182,21 +182,22 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tcore/sync/rwmutex.d core/sync/semaphore.d core/thread/context.d \\\n \tcore/thread/fiber.d core/thread/osthread.d core/thread/package.d \\\n \tcore/thread/threadbase.d core/thread/threadgroup.d core/thread/types.d \\\n-\tcore/time.d core/vararg.d gc/bits.d gc/config.d gc/gcinterface.d \\\n-\tgc/impl/conservative/gc.d gc/impl/manual/gc.d gc/os.d gc/pooltable.d \\\n-\tgc/proxy.d gcc/attribute.d gcc/backtrace.d gcc/builtins.d gcc/deh.d \\\n-\tgcc/emutls.d gcc/gthread.d gcc/sections/android.d \\\n-\tgcc/sections/elf_shared.d gcc/sections/osx.d gcc/sections/package.d \\\n-\tgcc/sections/win32.d gcc/sections/win64.d gcc/unwind/arm.d \\\n-\tgcc/unwind/arm_common.d gcc/unwind/c6x.d gcc/unwind/generic.d \\\n-\tgcc/unwind/package.d gcc/unwind/pe.d object.d rt/aApply.d rt/aApplyR.d \\\n-\trt/aaA.d rt/adi.d rt/arrayassign.d rt/arraycast.d rt/arraycat.d \\\n-\trt/cast_.d rt/config.d rt/critical_.d rt/deh.d rt/dmain2.d \\\n-\trt/invariant.d rt/lifetime.d rt/memory.d rt/minfo.d rt/monitor_.d \\\n-\trt/obj.d rt/qsort.d rt/sections.d rt/switch_.d rt/tlsgc.d \\\n-\trt/util/array.d rt/util/container/array.d rt/util/container/common.d \\\n-\trt/util/container/hashtab.d rt/util/container/treap.d rt/util/random.d \\\n-\trt/util/typeinfo.d rt/util/utf.d\n+\tcore/time.d core/vararg.d core/volatile.d gc/bits.d gc/config.d \\\n+\tgc/gcinterface.d gc/impl/conservative/gc.d gc/impl/manual/gc.d gc/os.d \\\n+\tgc/pooltable.d gc/proxy.d gcc/attribute.d gcc/backtrace.d \\\n+\tgcc/builtins.d gcc/deh.d gcc/emutls.d gcc/gthread.d \\\n+\tgcc/sections/android.d gcc/sections/elf_shared.d gcc/sections/osx.d \\\n+\tgcc/sections/package.d gcc/sections/win32.d gcc/sections/win64.d \\\n+\tgcc/unwind/arm.d gcc/unwind/arm_common.d gcc/unwind/c6x.d \\\n+\tgcc/unwind/generic.d gcc/unwind/package.d gcc/unwind/pe.d object.d \\\n+\trt/aApply.d rt/aApplyR.d rt/aaA.d rt/adi.d rt/arrayassign.d \\\n+\trt/arraycast.d rt/arraycat.d rt/cast_.d rt/config.d rt/critical_.d \\\n+\trt/deh.d rt/dmain2.d rt/invariant.d rt/lifetime.d rt/memory.d \\\n+\trt/minfo.d rt/monitor_.d rt/obj.d rt/qsort.d rt/sections.d \\\n+\trt/switch_.d rt/tlsgc.d rt/util/array.d rt/util/container/array.d \\\n+\trt/util/container/common.d rt/util/container/hashtab.d \\\n+\trt/util/container/treap.d rt/util/random.d rt/util/typeinfo.d \\\n+\trt/util/utf.d\n \n DRUNTIME_DSOURCES_STDCXX = core/stdcpp/exception.d \\\n \tcore/stdcpp/typeinfo.d"}, {"sha": "06c02961c866d80f9f6f3382bff81196ca563ede", "filename": "libphobos/libdruntime/Makefile.in", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.in?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -206,14 +206,14 @@ am__objects_1 = core/atomic.lo core/attribute.lo core/bitop.lo \\\n \tcore/thread/context.lo core/thread/fiber.lo \\\n \tcore/thread/osthread.lo core/thread/package.lo \\\n \tcore/thread/threadbase.lo core/thread/threadgroup.lo \\\n-\tcore/thread/types.lo core/time.lo core/vararg.lo gc/bits.lo \\\n-\tgc/config.lo gc/gcinterface.lo gc/impl/conservative/gc.lo \\\n-\tgc/impl/manual/gc.lo gc/os.lo gc/pooltable.lo gc/proxy.lo \\\n-\tgcc/attribute.lo gcc/backtrace.lo gcc/builtins.lo gcc/deh.lo \\\n-\tgcc/emutls.lo gcc/gthread.lo gcc/sections/android.lo \\\n-\tgcc/sections/elf_shared.lo gcc/sections/osx.lo \\\n-\tgcc/sections/package.lo gcc/sections/win32.lo \\\n-\tgcc/sections/win64.lo gcc/unwind/arm.lo \\\n+\tcore/thread/types.lo core/time.lo core/vararg.lo \\\n+\tcore/volatile.lo gc/bits.lo gc/config.lo gc/gcinterface.lo \\\n+\tgc/impl/conservative/gc.lo gc/impl/manual/gc.lo gc/os.lo \\\n+\tgc/pooltable.lo gc/proxy.lo gcc/attribute.lo gcc/backtrace.lo \\\n+\tgcc/builtins.lo gcc/deh.lo gcc/emutls.lo gcc/gthread.lo \\\n+\tgcc/sections/android.lo gcc/sections/elf_shared.lo \\\n+\tgcc/sections/osx.lo gcc/sections/package.lo \\\n+\tgcc/sections/win32.lo gcc/sections/win64.lo gcc/unwind/arm.lo \\\n \tgcc/unwind/arm_common.lo gcc/unwind/c6x.lo \\\n \tgcc/unwind/generic.lo gcc/unwind/package.lo gcc/unwind/pe.lo \\\n \tobject.lo rt/aApply.lo rt/aApplyR.lo rt/aaA.lo rt/adi.lo \\\n@@ -808,21 +808,22 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tcore/sync/rwmutex.d core/sync/semaphore.d core/thread/context.d \\\n \tcore/thread/fiber.d core/thread/osthread.d core/thread/package.d \\\n \tcore/thread/threadbase.d core/thread/threadgroup.d core/thread/types.d \\\n-\tcore/time.d core/vararg.d gc/bits.d gc/config.d gc/gcinterface.d \\\n-\tgc/impl/conservative/gc.d gc/impl/manual/gc.d gc/os.d gc/pooltable.d \\\n-\tgc/proxy.d gcc/attribute.d gcc/backtrace.d gcc/builtins.d gcc/deh.d \\\n-\tgcc/emutls.d gcc/gthread.d gcc/sections/android.d \\\n-\tgcc/sections/elf_shared.d gcc/sections/osx.d gcc/sections/package.d \\\n-\tgcc/sections/win32.d gcc/sections/win64.d gcc/unwind/arm.d \\\n-\tgcc/unwind/arm_common.d gcc/unwind/c6x.d gcc/unwind/generic.d \\\n-\tgcc/unwind/package.d gcc/unwind/pe.d object.d rt/aApply.d rt/aApplyR.d \\\n-\trt/aaA.d rt/adi.d rt/arrayassign.d rt/arraycast.d rt/arraycat.d \\\n-\trt/cast_.d rt/config.d rt/critical_.d rt/deh.d rt/dmain2.d \\\n-\trt/invariant.d rt/lifetime.d rt/memory.d rt/minfo.d rt/monitor_.d \\\n-\trt/obj.d rt/qsort.d rt/sections.d rt/switch_.d rt/tlsgc.d \\\n-\trt/util/array.d rt/util/container/array.d rt/util/container/common.d \\\n-\trt/util/container/hashtab.d rt/util/container/treap.d rt/util/random.d \\\n-\trt/util/typeinfo.d rt/util/utf.d\n+\tcore/time.d core/vararg.d core/volatile.d gc/bits.d gc/config.d \\\n+\tgc/gcinterface.d gc/impl/conservative/gc.d gc/impl/manual/gc.d gc/os.d \\\n+\tgc/pooltable.d gc/proxy.d gcc/attribute.d gcc/backtrace.d \\\n+\tgcc/builtins.d gcc/deh.d gcc/emutls.d gcc/gthread.d \\\n+\tgcc/sections/android.d gcc/sections/elf_shared.d gcc/sections/osx.d \\\n+\tgcc/sections/package.d gcc/sections/win32.d gcc/sections/win64.d \\\n+\tgcc/unwind/arm.d gcc/unwind/arm_common.d gcc/unwind/c6x.d \\\n+\tgcc/unwind/generic.d gcc/unwind/package.d gcc/unwind/pe.d object.d \\\n+\trt/aApply.d rt/aApplyR.d rt/aaA.d rt/adi.d rt/arrayassign.d \\\n+\trt/arraycast.d rt/arraycat.d rt/cast_.d rt/config.d rt/critical_.d \\\n+\trt/deh.d rt/dmain2.d rt/invariant.d rt/lifetime.d rt/memory.d \\\n+\trt/minfo.d rt/monitor_.d rt/obj.d rt/qsort.d rt/sections.d \\\n+\trt/switch_.d rt/tlsgc.d rt/util/array.d rt/util/container/array.d \\\n+\trt/util/container/common.d rt/util/container/hashtab.d \\\n+\trt/util/container/treap.d rt/util/random.d rt/util/typeinfo.d \\\n+\trt/util/utf.d\n \n DRUNTIME_DSOURCES_STDCXX = core/stdcpp/exception.d \\\n \tcore/stdcpp/typeinfo.d\n@@ -1178,6 +1179,7 @@ core/thread/threadgroup.lo: core/thread/$(am__dirstamp)\n core/thread/types.lo: core/thread/$(am__dirstamp)\n core/time.lo: core/$(am__dirstamp)\n core/vararg.lo: core/$(am__dirstamp)\n+core/volatile.lo: core/$(am__dirstamp)\n gc/$(am__dirstamp):\n \t@$(MKDIR_P) gc\n \t@: > gc/$(am__dirstamp)"}, {"sha": "25b5cd515b23a5b729ef75e46fc12394dbc4a6d9", "filename": "libphobos/libdruntime/core/bitop.d", "status": "modified", "additions": 69, "deletions": 76, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2Fcore%2Fbitop.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2Fcore%2Fbitop.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fbitop.d?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -267,7 +267,7 @@ unittest\n  * (No longer an intrisic - the compiler recognizes the patterns\n  * in the body.)\n  */\n-int bt(in size_t* p, size_t bitnum) pure @system\n+int bt(const scope size_t* p, size_t bitnum) pure @system\n {\n     static if (size_t.sizeof == 8)\n         return ((p[bitnum >> 6] & (1L << (bitnum & 63)))) != 0;\n@@ -494,26 +494,62 @@ struct BitRange\n     testIt(100, 6, 45, 89, 92, 99);\n }\n \n+/**\n+ * Swaps bytes in a 2 byte ushort.\n+ * Params:\n+ *      x = value\n+ * Returns:\n+ *      `x` with bytes swapped\n+ */\n+pragma(inline, false)\n+ushort byteswap(ushort x) pure\n+{\n+    /* Calling it bswap(ushort) would break existing code that calls bswap(uint).\n+     *\n+     * This pattern is meant to be recognized by the dmd code generator.\n+     * Don't change it without checking that an XCH instruction is still\n+     * used to implement it.\n+     * Inlining may also throw it off.\n+     */\n+    return cast(ushort) (((x >> 8) & 0xFF) | ((x << 8) & 0xFF00u));\n+}\n+\n+///\n+unittest\n+{\n+    assert(byteswap(cast(ushort)0xF234) == 0x34F2);\n+    static ushort xx = 0xF234;\n+    assert(byteswap(xx) == 0x34F2);\n+}\n+\n /**\n  * Swaps bytes in a 4 byte uint end-to-end, i.e. byte 0 becomes\n  * byte 3, byte 1 becomes byte 2, byte 2 becomes byte 1, byte 3\n  * becomes byte 0.\n  */\n uint bswap(uint v) pure;\n \n+///\n+unittest\n+{\n+    assert(bswap(0x01020304u) == 0x04030201u);\n+    static uint xx = 0x10203040u;\n+    assert(bswap(xx) == 0x40302010u);\n+}\n+\n /**\n  * Swaps bytes in an 8 byte ulong end-to-end, i.e. byte 0 becomes\n  * byte 7, byte 1 becomes byte 6, etc.\n+ * This is meant to be recognized by the compiler as an intrinsic.\n  */\n-ulong bswap(ulong v) pure\n-{\n-    auto sv = Split64(v);\n-\n-    const temp = sv.lo;\n-    sv.lo = bswap(sv.hi);\n-    sv.hi = bswap(temp);\n+ulong bswap(ulong v) pure;\n \n-    return (cast(ulong) sv.hi << 32) | sv.lo;\n+///\n+unittest\n+{\n+    assert(bswap(0x01020304_05060708uL) == 0x08070605_04030201uL);\n+    static ulong xx = 0x10203040_50607080uL;\n+    assert(bswap(xx) == 0x80706050_40302010uL);\n }\n \n version (DigitalMars) version (AnyX86) @system // not pure\n@@ -722,57 +758,14 @@ version (DigitalMars) version (AnyX86)\n }\n \n \n-/*************************************\n- * Read/write value from/to the memory location indicated by ptr.\n- *\n- * These functions are recognized by the compiler, and calls to them are guaranteed\n- * to not be removed (as dead assignment elimination or presumed to have no effect)\n- * or reordered in the same thread.\n- *\n- * These reordering guarantees are only made with regards to other\n- * operations done through these functions; the compiler is free to reorder regular\n- * loads/stores with regards to loads/stores done through these functions.\n- *\n- * This is useful when dealing with memory-mapped I/O (MMIO) where a store can\n- * have an effect other than just writing a value, or where sequential loads\n- * with no intervening stores can retrieve\n- * different values from the same location due to external stores to the location.\n- *\n- * These functions will, when possible, do the load/store as a single operation. In\n- * general, this is possible when the size of the operation is less than or equal to\n- * $(D (void*).sizeof), although some targets may support larger operations. If the\n- * load/store cannot be done as a single operation, multiple smaller operations will be used.\n- *\n- * These are not to be conflated with atomic operations. They do not guarantee any\n- * atomicity. This may be provided by coincidence as a result of the instructions\n- * used on the target, but this should not be relied on for portable programs.\n- * Further, no memory fences are implied by these functions.\n- * They should not be used for communication between threads.\n- * They may be used to guarantee a write or read cycle occurs at a specified address.\n- */\n-\n-ubyte  volatileLoad(ubyte * ptr);\n-ushort volatileLoad(ushort* ptr);  /// ditto\n-uint   volatileLoad(uint  * ptr);  /// ditto\n-ulong  volatileLoad(ulong * ptr);  /// ditto\n-\n-void volatileStore(ubyte * ptr, ubyte  value);   /// ditto\n-void volatileStore(ushort* ptr, ushort value);   /// ditto\n-void volatileStore(uint  * ptr, uint   value);   /// ditto\n-void volatileStore(ulong * ptr, ulong  value);   /// ditto\n-\n-@system unittest\n+deprecated(\"volatileLoad has been moved to core.volatile. Use core.volatile.volatileLoad instead.\")\n {\n-    alias TT(T...) = T;\n+    public import core.volatile : volatileLoad;\n+}\n \n-    foreach (T; TT!(ubyte, ushort, uint, ulong))\n-    {\n-        T u;\n-        T* p = &u;\n-        volatileStore(p, 1);\n-        T r = volatileLoad(p);\n-        assert(r == u);\n-    }\n+deprecated(\"volatileStore has been moved to core.volatile. Use core.volatile.volatileStore instead.\")\n+{\n+    public import core.volatile : volatileStore;\n }\n \n \n@@ -954,51 +947,51 @@ version (D_InlineAsm_X86_64)\n  *  Bitwise rotate `value` left (`rol`) or right (`ror`) by\n  *  `count` bit positions.\n  */\n-pure T rol(T)(in T value, in uint count)\n+pure T rol(T)(const T value, const uint count)\n     if (__traits(isIntegral, T) && __traits(isUnsigned, T))\n {\n     assert(count < 8 * T.sizeof);\n-    return cast(T) ((value << count) | (value >> (-count & (T.sizeof * 8 - 1))));\n+    return cast(T) ((value << count) | (value >> (T.sizeof * 8 - count)));\n }\n /// ditto\n-pure T ror(T)(in T value, in uint count)\n+pure T ror(T)(const T value, const uint count)\n     if (__traits(isIntegral, T) && __traits(isUnsigned, T))\n {\n     assert(count < 8 * T.sizeof);\n-    return cast(T) ((value >> count) | (value << (-count & (T.sizeof * 8 - 1))));\n+    return cast(T) ((value >> count) | (value << (T.sizeof * 8 - count)));\n }\n /// ditto\n-pure T rol(uint count, T)(in T value)\n+pure T rol(uint count, T)(const T value)\n     if (__traits(isIntegral, T) && __traits(isUnsigned, T))\n {\n     static assert(count < 8 * T.sizeof);\n-    return cast(T) ((value << count) | (value >> (-count & (T.sizeof * 8 - 1))));\n+    return cast(T) ((value << count) | (value >> (T.sizeof * 8 - count)));\n }\n /// ditto\n-pure T ror(uint count, T)(in T value)\n+pure T ror(uint count, T)(const T value)\n     if (__traits(isIntegral, T) && __traits(isUnsigned, T))\n {\n     static assert(count < 8 * T.sizeof);\n-    return cast(T) ((value >> count) | (value << (-count & (T.sizeof * 8 - 1))));\n+    return cast(T) ((value >> count) | (value << (T.sizeof * 8 - count)));\n }\n \n ///\n unittest\n {\n-    ubyte a = 0b10101010U;\n-    ulong b = ulong.max;\n+    ubyte a = 0b11110000U;\n+    ulong b = ~1UL;\n \n-    assert(rol(a, 1) == 0b01010101);\n-    assert(ror(a, 1) == 0b01010101);\n-    assert(rol(a, 3) == 0b01010101);\n-    assert(ror(a, 3) == 0b01010101);\n+    assert(rol(a, 1) == 0b11100001);\n+    assert(ror(a, 1) == 0b01111000);\n+    assert(rol(a, 3) == 0b10000111);\n+    assert(ror(a, 3) == 0b00011110);\n \n     assert(rol(a, 0) == a);\n     assert(ror(a, 0) == a);\n \n-    assert(rol(b, 63) == ulong.max);\n-    assert(ror(b, 63) == ulong.max);\n+    assert(rol(b, 63) == ~(1UL << 63));\n+    assert(ror(b, 63) == ~2UL);\n \n-    assert(rol!3(a) == 0b01010101);\n-    assert(ror!3(a) == 0b01010101);\n+    assert(rol!3(a) == 0b10000111);\n+    assert(ror!3(a) == 0b00011110);\n }"}, {"sha": "57209adcbebdf08e6f13c802546770cbb887ac57", "filename": "libphobos/libdruntime/core/checkedint.d", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2Fcore%2Fcheckedint.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2Fcore%2Fcheckedint.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fcheckedint.d?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -47,7 +47,7 @@ pure:\n  */\n \n pragma(inline, true)\n-int adds(int x, int y, ref bool overflow)\n+int adds()(int x, int y, ref bool overflow)\n {\n     long r = cast(long)x + cast(long)y;\n     if (r < int.min || r > int.max)\n@@ -75,7 +75,7 @@ unittest\n \n /// ditto\n pragma(inline, true)\n-long adds(long x, long y, ref bool overflow)\n+long adds()(long x, long y, ref bool overflow)\n {\n     long r = cast(ulong)x + cast(ulong)y;\n     if (x <  0 && y <  0 && r >= 0 ||\n@@ -106,7 +106,7 @@ static if (is(cent))\n {\n /// ditto\n pragma(inline, true)\n-cent adds(cent x, cent y, ref bool overflow)\n+cent adds()(cent x, cent y, ref bool overflow)\n {\n     cent r = cast(ucent)x + cast(ucent)y;\n     if (x <  0 && y <  0 && r >= 0 ||\n@@ -149,7 +149,7 @@ unittest\n  */\n \n pragma(inline, true)\n-uint addu(uint x, uint y, ref bool overflow)\n+uint addu()(uint x, uint y, ref bool overflow)\n {\n     immutable uint r = x + y;\n     if (r < x || r < y)\n@@ -177,7 +177,7 @@ unittest\n \n /// ditto\n pragma(inline, true)\n-ulong addu(ulong x, ulong y, ref bool overflow)\n+ulong addu()(ulong x, ulong y, ref bool overflow)\n {\n     immutable ulong r = x + y;\n     if (r < x || r < y)\n@@ -207,7 +207,7 @@ static if (is(ucent))\n {\n /// ditto\n pragma(inline, true)\n-ucent addu(ucent x, ucent y, ref bool overflow)\n+ucent addu()(ucent x, ucent y, ref bool overflow)\n {\n     immutable ucent r = x + y;\n     if (r < x || r < y)\n@@ -249,7 +249,7 @@ unittest\n  */\n \n pragma(inline, true)\n-int subs(int x, int y, ref bool overflow)\n+int subs()(int x, int y, ref bool overflow)\n {\n     immutable long r = cast(long)x - cast(long)y;\n     if (r < int.min || r > int.max)\n@@ -277,7 +277,7 @@ unittest\n \n /// ditto\n pragma(inline, true)\n-long subs(long x, long y, ref bool overflow)\n+long subs()(long x, long y, ref bool overflow)\n {\n     immutable long r = cast(ulong)x - cast(ulong)y;\n     if (x <  0 && y >= 0 && r >= 0 ||\n@@ -310,7 +310,7 @@ static if (is(cent))\n {\n /// ditto\n pragma(inline, true)\n-cent subs(cent x, cent y, ref bool overflow)\n+cent subs()(cent x, cent y, ref bool overflow)\n {\n     immutable cent r = cast(ucent)x - cast(ucent)y;\n     if (x <  0 && y >= 0 && r >= 0 ||\n@@ -355,7 +355,7 @@ unittest\n  */\n \n pragma(inline, true)\n-uint subu(uint x, uint y, ref bool overflow)\n+uint subu()(uint x, uint y, ref bool overflow)\n {\n     if (x < y)\n         overflow = true;\n@@ -383,7 +383,7 @@ unittest\n \n /// ditto\n pragma(inline, true)\n-ulong subu(ulong x, ulong y, ref bool overflow)\n+ulong subu()(ulong x, ulong y, ref bool overflow)\n {\n     if (x < y)\n         overflow = true;\n@@ -412,7 +412,7 @@ static if (is(ucent))\n {\n /// ditto\n pragma(inline, true)\n-ucent subu(ucent x, ucent y, ref bool overflow)\n+ucent subu()(ucent x, ucent y, ref bool overflow)\n {\n     if (x < y)\n         overflow = true;\n@@ -450,7 +450,7 @@ unittest\n  */\n \n pragma(inline, true)\n-int negs(int x, ref bool overflow)\n+int negs()(int x, ref bool overflow)\n {\n     if (x == int.min)\n         overflow = true;\n@@ -474,7 +474,7 @@ unittest\n \n /// ditto\n pragma(inline, true)\n-long negs(long x, ref bool overflow)\n+long negs()(long x, ref bool overflow)\n {\n     if (x == long.min)\n         overflow = true;\n@@ -500,7 +500,7 @@ static if (is(cent))\n {\n /// ditto\n pragma(inline, true)\n-cent negs(cent x, ref bool overflow)\n+cent negs()(cent x, ref bool overflow)\n {\n     if (x == cent.min)\n         overflow = true;\n@@ -538,7 +538,7 @@ unittest\n  */\n \n pragma(inline, true)\n-int muls(int x, int y, ref bool overflow)\n+int muls()(int x, int y, ref bool overflow)\n {\n     long r = cast(long)x * cast(long)y;\n     if (r < int.min || r > int.max)\n@@ -568,11 +568,13 @@ unittest\n \n /// ditto\n pragma(inline, true)\n-long muls(long x, long y, ref bool overflow)\n+long muls()(long x, long y, ref bool overflow)\n {\n     immutable long r = cast(ulong)x * cast(ulong)y;\n     enum not0or1 = ~1L;\n-    if ((x & not0or1) && ((r == y)? r : (r / x) != y))\n+    if ((x & not0or1) &&\n+        ((r == y) ? r != 0\n+                  : (r == 0x8000_0000_0000_0000 && x == -1L) || ((r / x) != y)))\n         overflow = true;\n     return r;\n }\n@@ -604,7 +606,7 @@ static if (is(cent))\n {\n /// ditto\n pragma(inline, true)\n-cent muls(cent x, cent y, ref bool overflow)\n+cent muls()(cent x, cent y, ref bool overflow)\n {\n     immutable cent r = cast(ucent)x * cast(ucent)y;\n     enum not0or1 = ~1L;\n@@ -652,7 +654,7 @@ unittest\n  */\n \n pragma(inline, true)\n-uint mulu(uint x, uint y, ref bool overflow)\n+uint mulu()(uint x, uint y, ref bool overflow)\n {\n     immutable ulong r = ulong(x) * ulong(y);\n     if (r >> 32)\n@@ -682,7 +684,7 @@ unittest\n \n /// ditto\n pragma(inline, true)\n-ulong mulu(ulong x, uint y, ref bool overflow)\n+ulong mulu()(ulong x, uint y, ref bool overflow)\n {\n     ulong r = x * y;\n     if (x >> 32 &&\n@@ -693,7 +695,7 @@ ulong mulu(ulong x, uint y, ref bool overflow)\n \n /// ditto\n pragma(inline, true)\n-ulong mulu(ulong x, ulong y, ref bool overflow)\n+ulong mulu()(ulong x, ulong y, ref bool overflow)\n {\n     immutable ulong r = x * y;\n     if ((x | y) >> 32 &&\n@@ -751,7 +753,7 @@ static if (is(ucent))\n {\n /// ditto\n pragma(inline, true)\n-ucent mulu(ucent x, ucent y, ref bool overflow)\n+ucent mulu()(ucent x, ucent y, ref bool overflow)\n {\n     immutable ucent r = x * y;\n     if (x && (r / x) != y)"}, {"sha": "e31f776d7eec673d351c0df743791fe909f23b82", "filename": "libphobos/libdruntime/core/cpuid.d", "status": "modified", "additions": 36, "deletions": 33, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2Fcore%2Fcpuid.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2Fcore%2Fcpuid.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fcpuid.d?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -56,6 +56,9 @@\n \n module core.cpuid;\n \n+version (GNU) version = GNU_OR_LDC;\n+version (LDC) version = GNU_OR_LDC;\n+\n @trusted:\n nothrow:\n @nogc:\n@@ -318,10 +321,10 @@ private:\n struct CpuFeatures\n {\n     bool probablyIntel; // true = _probably_ an Intel processor, might be faking\n-    bool probablyAMD; // true = _probably_ an AMD processor\n+    bool probablyAMD; // true = _probably_ an AMD or Hygon processor\n     string processorName;\n-    char [12] vendorID;\n-    char [48] processorNameBuffer;\n+    char [12] vendorID = 0;\n+    char [48] processorNameBuffer = 0;\n     uint features = 0;     // mmx, sse, sse2, hyperthreading, etc\n     uint miscfeatures = 0; // sse3, etc.\n     uint extfeatures = 0;  // HLE, AVX2, RTM, etc.\n@@ -426,7 +429,7 @@ CpuFeatures* getCpuFeatures() @nogc nothrow\n     }\n \n \n-version (GNU) {\n+version (GNU_OR_LDC) {\n     version (X86)\n         enum supportedX86 = true;\n     else version (X86_64)\n@@ -509,12 +512,12 @@ void getcacheinfoCPUID2()\n     // for old single-core CPUs.\n     uint numinfos = 1;\n     do {\n-        version (GNU) asm pure nothrow @nogc {\n+        version (GNU_OR_LDC) asm pure nothrow @nogc {\n             \"cpuid\" : \"=a\" (a[0]), \"=b\" (a[1]), \"=c\" (a[2]), \"=d\" (a[3]) : \"a\" (2);\n         } else asm pure nothrow @nogc {\n             mov EAX, 2;\n             cpuid;\n-            mov a, EAX;\n+            mov a+0, EAX;\n             mov a+4, EBX;\n             mov a+8, ECX;\n             mov a+12, EDX;\n@@ -553,7 +556,7 @@ void getcacheinfoCPUID4()\n     int cachenum = 0;\n     for (;;) {\n         uint a, b, number_of_sets;\n-        version (GNU) asm pure nothrow @nogc {\n+        version (GNU_OR_LDC) asm pure nothrow @nogc {\n             \"cpuid\" : \"=a\" (a), \"=b\" (b), \"=c\" (number_of_sets) : \"a\" (4), \"c\" (cachenum) : \"edx\";\n         } else asm pure nothrow @nogc {\n             mov EAX, 4;\n@@ -593,7 +596,7 @@ void getcacheinfoCPUID4()\n void getAMDcacheinfo()\n {\n     uint dummy, c5, c6, d6;\n-    version (GNU) asm pure nothrow @nogc {\n+    version (GNU_OR_LDC) asm pure nothrow @nogc {\n         \"cpuid\" : \"=a\" (dummy), \"=c\" (c5) : \"a\" (0x8000_0005) : \"ebx\", \"edx\";\n     } else asm pure nothrow @nogc {\n         mov EAX, 0x8000_0005; // L1 cache\n@@ -612,7 +615,7 @@ void getAMDcacheinfo()\n         // AMD K6-III or K6-2+ or later.\n         ubyte numcores = 1;\n         if (max_extended_cpuid >= 0x8000_0008) {\n-            version (GNU) asm pure nothrow @nogc {\n+            version (GNU_OR_LDC) asm pure nothrow @nogc {\n                 \"cpuid\" : \"=a\" (dummy), \"=c\" (numcores) : \"a\" (0x8000_0008) : \"ebx\", \"edx\";\n             } else asm pure nothrow @nogc {\n                 mov EAX, 0x8000_0008;\n@@ -623,7 +626,7 @@ void getAMDcacheinfo()\n             if (numcores>cpuFeatures.maxCores) cpuFeatures.maxCores = numcores;\n         }\n \n-        version (GNU) asm pure nothrow @nogc {\n+        version (GNU_OR_LDC) asm pure nothrow @nogc {\n             \"cpuid\" : \"=a\" (dummy), \"=c\" (c6), \"=d\" (d6) : \"a\" (0x8000_0006) : \"ebx\";\n         } else asm pure nothrow @nogc {\n             mov EAX, 0x8000_0006; // L2/L3 cache\n@@ -652,7 +655,7 @@ void getCpuInfo0B()\n     int threadsPerCore;\n     uint a, b, c, d;\n     do {\n-        version (GNU) asm pure nothrow @nogc {\n+        version (GNU_OR_LDC) asm pure nothrow @nogc {\n             \"cpuid\" : \"=a\" (a), \"=b\" (b), \"=c\" (c), \"=d\" (d) : \"a\" (0x0B), \"c\" (level);\n         } else asm pure nothrow @nogc {\n             mov EAX, 0x0B;\n@@ -684,7 +687,7 @@ void cpuidX86()\n \n     uint a, b, c, d;\n     uint* venptr = cast(uint*)cf.vendorID.ptr;\n-    version (GNU)\n+    version (GNU_OR_LDC)\n     {\n         asm pure nothrow @nogc {\n             \"cpuid\" : \"=a\" (max_cpuid), \"=b\" (venptr[0]), \"=d\" (venptr[1]), \"=c\" (venptr[2]) : \"a\" (0);\n@@ -729,9 +732,9 @@ void cpuidX86()\n \n \n     cf.probablyIntel = cf.vendorID == \"GenuineIntel\";\n-    cf.probablyAMD = cf.vendorID == \"AuthenticAMD\";\n+    cf.probablyAMD = (cf.vendorID == \"AuthenticAMD\" || cf.vendorID == \"HygonGenuine\");\n     uint apic = 0; // brand index, apic id\n-    version (GNU) asm pure nothrow @nogc {\n+    version (GNU_OR_LDC) asm pure nothrow @nogc {\n         \"cpuid\" : \"=a\" (a), \"=b\" (apic), \"=c\" (cf.miscfeatures), \"=d\" (cf.features) : \"a\" (1);\n     } else {\n         asm pure nothrow @nogc {\n@@ -754,7 +757,7 @@ void cpuidX86()\n \n     if (max_cpuid >= 7)\n     {\n-        version (GNU) asm pure nothrow @nogc {\n+        version (GNU_OR_LDC) asm pure nothrow @nogc {\n             \"cpuid\" : \"=a\" (a), \"=b\" (cf.extfeatures), \"=c\" (c) : \"a\" (7), \"c\" (0) : \"edx\";\n         } else {\n             uint ext;\n@@ -770,8 +773,11 @@ void cpuidX86()\n \n     if (cf.miscfeatures & OSXSAVE_BIT)\n     {\n-        version (GNU) asm pure nothrow @nogc {\n-            \"xgetbv\" : \"=a\" (a), \"=d\" (d) : \"c\" (0);\n+        version (GNU_OR_LDC) asm pure nothrow @nogc {\n+            /* Old assemblers do not recognize xgetbv, and there is no easy way\n+             * to conditionally compile based on the assembler used, so use the\n+             * raw .byte sequence instead.  */\n+            \".byte 0x0f, 0x01, 0xd0\" : \"=a\" (a), \"=d\" (d) : \"c\" (0);\n         } else asm pure nothrow @nogc {\n             mov ECX, 0;\n             xgetbv;\n@@ -784,7 +790,7 @@ void cpuidX86()\n     cf.amdfeatures = 0;\n     cf.amdmiscfeatures = 0;\n     if (max_extended_cpuid >= 0x8000_0001) {\n-        version (GNU) asm pure nothrow @nogc {\n+        version (GNU_OR_LDC) asm pure nothrow @nogc {\n             \"cpuid\" : \"=a\" (a), \"=c\" (cf.amdmiscfeatures), \"=d\" (cf.amdfeatures) : \"a\" (0x8000_0001) : \"ebx\";\n         } else {\n             asm pure nothrow @nogc {\n@@ -805,7 +811,7 @@ void cpuidX86()\n         cf.maxCores = 1;\n         if (hyperThreadingBit) {\n             // determine max number of cores for AMD\n-            version (GNU) asm pure nothrow @nogc {\n+            version (GNU_OR_LDC) asm pure nothrow @nogc {\n                 \"cpuid\" : \"=a\" (a), \"=c\" (c) : \"a\" (0x8000_0008) : \"ebx\", \"edx\";\n             } else asm pure nothrow @nogc {\n                 mov EAX, 0x8000_0008;\n@@ -818,7 +824,7 @@ void cpuidX86()\n \n     if (max_extended_cpuid >= 0x8000_0004) {\n         uint* pnb = cast(uint*)cf.processorNameBuffer.ptr;\n-        version (GNU)\n+        version (GNU_OR_LDC)\n         {\n             asm pure nothrow @nogc {\n                 \"cpuid\" : \"=a\" (pnb[0]), \"=b\" (pnb[1]), \"=c\" (pnb[ 2]), \"=d\" (pnb[ 3]) : \"a\" (0x8000_0002);\n@@ -950,7 +956,7 @@ void cpuidX86()\n         else cf.maxThreads = cf.maxCores;\n \n         if (cf.probablyAMD && max_extended_cpuid >= 0x8000_001E) {\n-            version (GNU) asm pure nothrow @nogc {\n+            version (GNU_OR_LDC) asm pure nothrow @nogc {\n                 \"cpuid\" : \"=a\" (a), \"=b\" (b) : \"a\" (0x8000_001E) : \"ecx\", \"edx\";\n             } else {\n                 asm pure nothrow @nogc {\n@@ -974,21 +980,18 @@ bool hasCPUID()\n     else\n     {\n         uint flags;\n-        version (GNU)\n+        version (GNU_OR_LDC)\n         {\n             // http://wiki.osdev.org/CPUID#Checking_CPUID_availability\n-            // ASM template supports both AT&T and Intel syntax.\n             asm nothrow @nogc { \"\n-                pushf{l|d}                 # Save EFLAGS\n-                pushf{l|d}                 # Store EFLAGS\n-                xor{l $0x00200000, (%%esp)| dword ptr [esp], 0x00200000}\n-                                           # Invert the ID bit in stored EFLAGS\n-                popf{l|d}                  # Load stored EFLAGS (with ID bit inverted)\n-                pushf{l|d}                 # Store EFLAGS again (ID bit may or may not be inverted)\n-                pop {%%}eax                # eax = modified EFLAGS (ID bit may or may not be inverted)\n-                xor {(%%esp), %%eax|eax, [esp]}\n-                                           # eax = whichever bits were changed\n-                popf{l|d}                  # Restore original EFLAGS\n+                pushfl                    # Save EFLAGS\n+                pushfl                    # Store EFLAGS\n+                xorl $0x00200000, (%%esp) # Invert the ID bit in stored EFLAGS\n+                popfl                     # Load stored EFLAGS (with ID bit inverted)\n+                pushfl                    # Store EFLAGS again (ID bit may or may not be inverted)\n+                popl %%eax                # eax = modified EFLAGS (ID bit may or may not be inverted)\n+                xorl (%%esp), %%eax       # eax = whichever bits were changed\n+                popfl                     # Restore original EFLAGS\n                 \" : \"=a\" (flags);\n             }\n         }"}, {"sha": "9f79dd014b884a99be7ee8f32a0b9c94826d19cc", "filename": "libphobos/libdruntime/core/internal/traits.d", "status": "modified", "additions": 142, "deletions": 10, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2Fcore%2Finternal%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2Fcore%2Finternal%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Ftraits.d?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -8,10 +8,16 @@\n  */\n module core.internal.traits;\n \n-/// taken from std.typetuple.TypeTuple\n-template TypeTuple(TList...)\n+alias AliasSeq(TList...) = TList;\n+\n+template Fields(T)\n {\n-    alias TypeTuple = TList;\n+    static if (is(T == struct) || is(T == union))\n+        alias Fields = typeof(T.tupleof[0 .. $ - __traits(isNested, T)]);\n+    else static if (is(T == class))\n+        alias Fields = typeof(T.tupleof);\n+    else\n+        alias Fields = AliasSeq!T;\n }\n \n T trustedCast(T, U)(auto ref U u) @trusted pure nothrow\n@@ -109,17 +115,17 @@ template staticIota(int beg, int end)\n     {\n         static if (beg >= end)\n         {\n-            alias staticIota = TypeTuple!();\n+            alias staticIota = AliasSeq!();\n         }\n         else\n         {\n-            alias staticIota = TypeTuple!(+beg);\n+            alias staticIota = AliasSeq!(+beg);\n         }\n     }\n     else\n     {\n         enum mid = beg + (end - beg) / 2;\n-        alias staticIota = TypeTuple!(staticIota!(beg, mid), staticIota!(mid, end));\n+        alias staticIota = AliasSeq!(staticIota!(beg, mid), staticIota!(mid, end));\n     }\n }\n \n@@ -235,24 +241,150 @@ template hasElaborateCopyConstructor(T...)\n         enum bool hasElaborateCopyConstructor = false;\n }\n \n+template hasUnsharedIndirections(T)\n+{\n+    static if (is(T == immutable))\n+        enum hasUnsharedIndirections = false;\n+    else static if (is(T == struct) || is(T == union))\n+        enum hasUnsharedIndirections = anySatisfy!(.hasUnsharedIndirections, Fields!T);\n+    else static if (is(T : E[N], E, size_t N))\n+        enum hasUnsharedIndirections = is(E == void) ? false : hasUnsharedIndirections!E;\n+    else static if (isFunctionPointer!T)\n+        enum hasUnsharedIndirections = false;\n+    else static if (isPointer!T)\n+        enum hasUnsharedIndirections = !is(T : shared(U)*, U) && !is(T : immutable(U)*, U);\n+    else static if (isDynamicArray!T)\n+        enum hasUnsharedIndirections = !is(T : shared(V)[], V) && !is(T : immutable(V)[], V);\n+    else static if (is(T == class) || is(T == interface))\n+        enum hasUnsharedIndirections = !is(T : shared(W), W);\n+    else\n+        enum hasUnsharedIndirections = isDelegate!T || __traits(isAssociativeArray, T); // TODO: how to handle these?\n+}\n+\n+unittest\n+{\n+    static struct Foo { shared(int)* val; }\n+\n+    static assert(!hasUnsharedIndirections!(immutable(char)*));\n+    static assert(!hasUnsharedIndirections!(string));\n+\n+    static assert(!hasUnsharedIndirections!(Foo));\n+    static assert( hasUnsharedIndirections!(Foo*));\n+    static assert(!hasUnsharedIndirections!(shared(Foo)*));\n+    static assert(!hasUnsharedIndirections!(immutable(Foo)*));\n+}\n+\n+enum bool isAggregateType(T) = is(T == struct) || is(T == union) ||\n+                               is(T == class) || is(T == interface);\n+\n+enum bool isPointer(T) = is(T == U*, U) && !isAggregateType!T;\n+\n+enum bool isDynamicArray(T) = is(DynamicArrayTypeOf!T) && !isAggregateType!T;\n+\n+template OriginalType(T)\n+{\n+    template Impl(T)\n+    {\n+        static if (is(T U == enum)) alias Impl = OriginalType!U;\n+        else                        alias Impl =              T;\n+    }\n+\n+    alias OriginalType = ModifyTypePreservingTQ!(Impl, T);\n+}\n+\n+template DynamicArrayTypeOf(T)\n+{\n+    static if (is(AliasThisTypeOf!T AT) && !is(AT[] == AT))\n+        alias X = DynamicArrayTypeOf!AT;\n+    else\n+        alias X = OriginalType!T;\n+\n+    static if (is(Unqual!X : E[], E) && !is(typeof({ enum n = X.length; })))\n+        alias DynamicArrayTypeOf = X;\n+    else\n+        static assert(0, T.stringof ~ \" is not a dynamic array\");\n+}\n+\n+private template AliasThisTypeOf(T)\n+    if (isAggregateType!T)\n+{\n+    alias members = __traits(getAliasThis, T);\n+\n+    static if (members.length == 1)\n+        alias AliasThisTypeOf = typeof(__traits(getMember, T.init, members[0]));\n+    else\n+        static assert(0, T.stringof~\" does not have alias this type\");\n+}\n+\n+template isFunctionPointer(T...)\n+    if (T.length == 1)\n+{\n+    static if (is(T[0] U) || is(typeof(T[0]) U))\n+    {\n+        static if (is(U F : F*) && is(F == function))\n+            enum bool isFunctionPointer = true;\n+        else\n+            enum bool isFunctionPointer = false;\n+    }\n+    else\n+        enum bool isFunctionPointer = false;\n+}\n+\n+template isDelegate(T...)\n+    if (T.length == 1)\n+{\n+    static if (is(typeof(& T[0]) U : U*) && is(typeof(& T[0]) U == delegate))\n+    {\n+        // T is a (nested) function symbol.\n+        enum bool isDelegate = true;\n+    }\n+    else static if (is(T[0] W) || is(typeof(T[0]) W))\n+    {\n+        // T is an expression or a type.  Take the type of it and examine.\n+        enum bool isDelegate = is(W == delegate);\n+    }\n+    else\n+        enum bool isDelegate = false;\n+}\n+\n // std.meta.Filter\n template Filter(alias pred, TList...)\n {\n     static if (TList.length == 0)\n     {\n-        alias Filter = TypeTuple!();\n+        alias Filter = AliasSeq!();\n     }\n     else static if (TList.length == 1)\n     {\n         static if (pred!(TList[0]))\n-            alias Filter = TypeTuple!(TList[0]);\n+            alias Filter = AliasSeq!(TList[0]);\n         else\n-            alias Filter = TypeTuple!();\n+            alias Filter = AliasSeq!();\n+    }\n+    /* The next case speeds up compilation by reducing\n+     * the number of Filter instantiations\n+     */\n+    else static if (TList.length == 2)\n+    {\n+        static if (pred!(TList[0]))\n+        {\n+            static if (pred!(TList[1]))\n+                alias Filter = AliasSeq!(TList[0], TList[1]);\n+            else\n+                alias Filter = AliasSeq!(TList[0]);\n+        }\n+        else\n+        {\n+            static if (pred!(TList[1]))\n+                alias Filter = AliasSeq!(TList[1]);\n+            else\n+                alias Filter = AliasSeq!();\n+        }\n     }\n     else\n     {\n         alias Filter =\n-            TypeTuple!(\n+            AliasSeq!(\n                 Filter!(pred, TList[ 0  .. $/2]),\n                 Filter!(pred, TList[$/2 ..  $ ]));\n     }"}, {"sha": "11a471183193f64289bb4ea9b01a83a35036ce8b", "filename": "libphobos/libdruntime/core/simd.d", "status": "modified", "additions": 623, "deletions": 473, "changes": 1096, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2Fcore%2Fsimd.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2Fcore%2Fsimd.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsimd.d?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -5,9 +5,10 @@\n  *\n  * Source: $(DRUNTIMESRC core/_simd.d)\n  *\n- * Copyright: Copyright Digital Mars 2012.\n- * License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n- * Authors:   $(WEB digitalmars.com, Walter Bright),\n+ * Copyright: Copyright Digital Mars 2012-2020\n+ * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n+ * Authors:   $(HTTP digitalmars.com, Walter Bright),\n+ * Source:    $(DRUNTIMESRC core/_simd.d)\n  */\n \n module core.simd;\n@@ -38,470 +39,523 @@ template Vector(T)\n \n /* Handy aliases\n  */\n-static if (is(Vector!(void[8])))    alias Vector!(void[8])  void8;          ///\n-static if (is(Vector!(double[1])))  alias Vector!(double[1]) double1;       ///\n-static if (is(Vector!(float[2])))   alias Vector!(float[2])  float2;        ///\n-static if (is(Vector!(byte[8])))    alias Vector!(byte[8])  byte8;          ///\n-static if (is(Vector!(ubyte[8])))   alias Vector!(ubyte[8]) ubyte8;         ///\n-static if (is(Vector!(short[4])))   alias Vector!(short[4])  short4;        ///\n-static if (is(Vector!(ushort[4])))  alias Vector!(ushort[4]) ushort4;       ///\n-static if (is(Vector!(int[2])))     alias Vector!(int[2])    int2;          ///\n-static if (is(Vector!(uint[2])))    alias Vector!(uint[2])   uint2;         ///\n-static if (is(Vector!(long[1])))    alias Vector!(long[1])   long1;         ///\n-static if (is(Vector!(ulong[1])))   alias Vector!(ulong[1])  ulong1;        ///\n-\n-static if (is(Vector!(void[16])))   alias Vector!(void[16])  void16;        ///\n-static if (is(Vector!(double[2])))  alias Vector!(double[2]) double2;       ///\n-static if (is(Vector!(float[4])))   alias Vector!(float[4])  float4;        ///\n-static if (is(Vector!(byte[16])))   alias Vector!(byte[16])  byte16;        ///\n-static if (is(Vector!(ubyte[16])))  alias Vector!(ubyte[16]) ubyte16;       ///\n-static if (is(Vector!(short[8])))   alias Vector!(short[8])  short8;        ///\n-static if (is(Vector!(ushort[8])))  alias Vector!(ushort[8]) ushort8;       ///\n-static if (is(Vector!(int[4])))     alias Vector!(int[4])    int4;          ///\n-static if (is(Vector!(uint[4])))    alias Vector!(uint[4])   uint4;         ///\n-static if (is(Vector!(long[2])))    alias Vector!(long[2])   long2;         ///\n-static if (is(Vector!(ulong[2])))   alias Vector!(ulong[2])  ulong2;        ///\n-\n-static if (is(Vector!(void[32])))   alias Vector!(void[32])   void32;        ///\n-static if (is(Vector!(double[4])))  alias Vector!(double[4])  double4;       ///\n-static if (is(Vector!(float[8])))   alias Vector!(float[8])   float8;        ///\n-static if (is(Vector!(byte[32])))   alias Vector!(byte[32])   byte32;        ///\n-static if (is(Vector!(ubyte[32])))  alias Vector!(ubyte[32])  ubyte32;       ///\n-static if (is(Vector!(short[16])))  alias Vector!(short[16])  short16;       ///\n-static if (is(Vector!(ushort[16]))) alias Vector!(ushort[16]) ushort16;      ///\n-static if (is(Vector!(int[8])))     alias Vector!(int[8])     int8;          ///\n-static if (is(Vector!(uint[8])))    alias Vector!(uint[8])    uint8;         ///\n-static if (is(Vector!(long[4])))    alias Vector!(long[4])    long4;         ///\n-static if (is(Vector!(ulong[4])))   alias Vector!(ulong[4])   ulong4;        ///\n+static if (is(Vector!(void[8])))    alias Vector!(void[8])    void8;        ///\n+static if (is(Vector!(double[1])))  alias Vector!(double[1])  double1;      ///\n+static if (is(Vector!(float[2])))   alias Vector!(float[2])   float2;       ///\n+static if (is(Vector!(byte[8])))    alias Vector!(byte[8])    byte8;        ///\n+static if (is(Vector!(ubyte[8])))   alias Vector!(ubyte[8])   ubyte8;       ///\n+static if (is(Vector!(short[4])))   alias Vector!(short[4])   short4;       ///\n+static if (is(Vector!(ushort[4])))  alias Vector!(ushort[4])  ushort4;      ///\n+static if (is(Vector!(int[2])))     alias Vector!(int[2])     int2;         ///\n+static if (is(Vector!(uint[2])))    alias Vector!(uint[2])    uint2;        ///\n+static if (is(Vector!(long[1])))    alias Vector!(long[1])    long1;        ///\n+static if (is(Vector!(ulong[1])))   alias Vector!(ulong[1])   ulong1;       ///\n+\n+static if (is(Vector!(void[16])))   alias Vector!(void[16])   void16;       ///\n+static if (is(Vector!(double[2])))  alias Vector!(double[2])  double2;      ///\n+static if (is(Vector!(float[4])))   alias Vector!(float[4])   float4;       ///\n+static if (is(Vector!(byte[16])))   alias Vector!(byte[16])   byte16;       ///\n+static if (is(Vector!(ubyte[16])))  alias Vector!(ubyte[16])  ubyte16;      ///\n+static if (is(Vector!(short[8])))   alias Vector!(short[8])   short8;       ///\n+static if (is(Vector!(ushort[8])))  alias Vector!(ushort[8])  ushort8;      ///\n+static if (is(Vector!(int[4])))     alias Vector!(int[4])     int4;         ///\n+static if (is(Vector!(uint[4])))    alias Vector!(uint[4])    uint4;        ///\n+static if (is(Vector!(long[2])))    alias Vector!(long[2])    long2;        ///\n+static if (is(Vector!(ulong[2])))   alias Vector!(ulong[2])   ulong2;       ///\n+\n+static if (is(Vector!(void[32])))   alias Vector!(void[32])   void32;       ///\n+static if (is(Vector!(double[4])))  alias Vector!(double[4])  double4;      ///\n+static if (is(Vector!(float[8])))   alias Vector!(float[8])   float8;       ///\n+static if (is(Vector!(byte[32])))   alias Vector!(byte[32])   byte32;       ///\n+static if (is(Vector!(ubyte[32])))  alias Vector!(ubyte[32])  ubyte32;      ///\n+static if (is(Vector!(short[16])))  alias Vector!(short[16])  short16;      ///\n+static if (is(Vector!(ushort[16]))) alias Vector!(ushort[16]) ushort16;     ///\n+static if (is(Vector!(int[8])))     alias Vector!(int[8])     int8;         ///\n+static if (is(Vector!(uint[8])))    alias Vector!(uint[8])    uint8;        ///\n+static if (is(Vector!(long[4])))    alias Vector!(long[4])    long4;        ///\n+static if (is(Vector!(ulong[4])))   alias Vector!(ulong[4])   ulong4;       ///\n+\n+static if (is(Vector!(void[64])))   alias Vector!(void[64])   void64;       ///\n+static if (is(Vector!(double[8])))  alias Vector!(double[8])  double8;      ///\n+static if (is(Vector!(float[16])))  alias Vector!(float[16])  float16;      ///\n+static if (is(Vector!(byte[64])))   alias Vector!(byte[64])   byte64;       ///\n+static if (is(Vector!(ubyte[64])))  alias Vector!(ubyte[64])  ubyte64;      ///\n+static if (is(Vector!(short[32])))  alias Vector!(short[32])  short32;      ///\n+static if (is(Vector!(ushort[32]))) alias Vector!(ushort[32]) ushort32;     ///\n+static if (is(Vector!(int[16])))    alias Vector!(int[16])    int16;        ///\n+static if (is(Vector!(uint[16])))   alias Vector!(uint[16])   uint16;       ///\n+static if (is(Vector!(long[8])))    alias Vector!(long[8])    long8;        ///\n+static if (is(Vector!(ulong[8])))   alias Vector!(ulong[8])   ulong8;       ///\n \n version (D_SIMD)\n {\n-  /** XMM opcodes that conform to the following:\n-   *\n-   *  opcode xmm1,xmm2/mem\n-   *\n-   * and do not have side effects (i.e. do not write to memory).\n-   */\n-  enum XMM\n-  {\n-    ADDSS = 0xF30F58,\n-    ADDSD = 0xF20F58,\n-    ADDPS = 0x000F58,\n-    ADDPD = 0x660F58,\n-    PADDB = 0x660FFC,\n-    PADDW = 0x660FFD,\n-    PADDD = 0x660FFE,\n-    PADDQ = 0x660FD4,\n-\n-    SUBSS = 0xF30F5C,\n-    SUBSD = 0xF20F5C,\n-    SUBPS = 0x000F5C,\n-    SUBPD = 0x660F5C,\n-    PSUBB = 0x660FF8,\n-    PSUBW = 0x660FF9,\n-    PSUBD = 0x660FFA,\n-    PSUBQ = 0x660FFB,\n-\n-    MULSS = 0xF30F59,\n-    MULSD = 0xF20F59,\n-    MULPS = 0x000F59,\n-    MULPD = 0x660F59,\n-    PMULLW = 0x660FD5,\n-\n-    DIVSS = 0xF30F5E,\n-    DIVSD = 0xF20F5E,\n-    DIVPS = 0x000F5E,\n-    DIVPD = 0x660F5E,\n-\n-    PAND  = 0x660FDB,\n-    POR   = 0x660FEB,\n-\n-    UCOMISS = 0x000F2E,\n-    UCOMISD = 0x660F2E,\n-\n-    XORPS = 0x000F57,\n-    XORPD = 0x660F57,\n-\n-    // Use STO and LOD instead of MOV to distinguish the direction\n-    STOSS  = 0xF30F11,\n-    STOSD  = 0xF20F11,\n-    STOAPS = 0x000F29,\n-    STOAPD = 0x660F29,\n-    STODQA = 0x660F7F,\n-    STOD   = 0x660F7E,        // MOVD reg/mem64, xmm   66 0F 7E /r\n-    STOQ   = 0x660FD6,\n-\n-    LODSS  = 0xF30F10,\n-    LODSD  = 0xF20F10,\n-    LODAPS = 0x000F28,\n-    LODAPD = 0x660F28,\n-    LODDQA = 0x660F6F,\n-    LODD   = 0x660F6E,        // MOVD xmm, reg/mem64   66 0F 6E /r\n-    LODQ   = 0xF30F7E,\n-\n-    LODDQU   = 0xF30F6F,      // MOVDQU xmm1, xmm2/mem128  F3 0F 6F /r\n-    STODQU   = 0xF30F7F,      // MOVDQU xmm1/mem128, xmm2  F3 0F 7F /r\n-    MOVDQ2Q  = 0xF20FD6,      // MOVDQ2Q mmx, xmm          F2 0F D6 /r\n-    MOVHLPS  = 0x0F12,        // MOVHLPS xmm1, xmm2        0F 12 /r\n-    LODHPD   = 0x660F16,\n-    STOHPD   = 0x660F17,      // MOVHPD mem64, xmm         66 0F 17 /r\n-    LODHPS   = 0x0F16,\n-    STOHPS   = 0x0F17,\n-    MOVLHPS  = 0x0F16,\n-    LODLPD   = 0x660F12,\n-    STOLPD   = 0x660F13,\n-    LODLPS   = 0x0F12,\n-    STOLPS   = 0x0F13,\n-    MOVMSKPD = 0x660F50,\n-    MOVMSKPS = 0x0F50,\n-    MOVNTDQ  = 0x660FE7,\n-    MOVNTI   = 0x0FC3,\n-    MOVNTPD  = 0x660F2B,\n-    MOVNTPS  = 0x0F2B,\n-    MOVNTQ   = 0x0FE7,\n-    MOVQ2DQ  = 0xF30FD6,\n-    LODUPD   = 0x660F10,\n-    STOUPD   = 0x660F11,\n-    LODUPS   = 0x0F10,\n-    STOUPS   = 0x0F11,\n-\n-    PACKSSDW = 0x660F6B,\n-    PACKSSWB = 0x660F63,\n-    PACKUSWB = 0x660F67,\n-    PADDSB = 0x660FEC,\n-    PADDSW = 0x660FED,\n-    PADDUSB = 0x660FDC,\n-    PADDUSW = 0x660FDD,\n-    PANDN = 0x660FDF,\n-    PCMPEQB = 0x660F74,\n-    PCMPEQD = 0x660F76,\n-    PCMPEQW = 0x660F75,\n-    PCMPGTB = 0x660F64,\n-    PCMPGTD = 0x660F66,\n-    PCMPGTW = 0x660F65,\n-    PMADDWD = 0x660FF5,\n-    PSLLW = 0x660FF1,\n-    PSLLD = 0x660FF2,\n-    PSLLQ = 0x660FF3,\n-    PSRAW = 0x660FE1,\n-    PSRAD = 0x660FE2,\n-    PSRLW = 0x660FD1,\n-    PSRLD = 0x660FD2,\n-    PSRLQ = 0x660FD3,\n-    PSUBSB = 0x660FE8,\n-    PSUBSW = 0x660FE9,\n-    PSUBUSB = 0x660FD8,\n-    PSUBUSW = 0x660FD9,\n-    PUNPCKHBW = 0x660F68,\n-    PUNPCKHDQ = 0x660F6A,\n-    PUNPCKHWD = 0x660F69,\n-    PUNPCKLBW = 0x660F60,\n-    PUNPCKLDQ = 0x660F62,\n-    PUNPCKLWD = 0x660F61,\n-    PXOR = 0x660FEF,\n-    ANDPD = 0x660F54,\n-    ANDPS = 0x0F54,\n-    ANDNPD = 0x660F55,\n-    ANDNPS = 0x0F55,\n-    CMPPS = 0x0FC2,\n-    CMPPD = 0x660FC2,\n-    CMPSD = 0xF20FC2,\n-    CMPSS = 0xF30FC2,\n-    COMISD = 0x660F2F,\n-    COMISS = 0x0F2F,\n-    CVTDQ2PD = 0xF30FE6,\n-    CVTDQ2PS = 0x0F5B,\n-    CVTPD2DQ = 0xF20FE6,\n-    CVTPD2PI = 0x660F2D,\n-    CVTPD2PS = 0x660F5A,\n-    CVTPI2PD = 0x660F2A,\n-    CVTPI2PS = 0x0F2A,\n-    CVTPS2DQ = 0x660F5B,\n-    CVTPS2PD = 0x0F5A,\n-    CVTPS2PI = 0x0F2D,\n-    CVTSD2SI = 0xF20F2D,\n-    CVTSD2SS = 0xF20F5A,\n-    CVTSI2SD = 0xF20F2A,\n-    CVTSI2SS = 0xF30F2A,\n-    CVTSS2SD = 0xF30F5A,\n-    CVTSS2SI = 0xF30F2D,\n-    CVTTPD2PI = 0x660F2C,\n-    CVTTPD2DQ = 0x660FE6,\n-    CVTTPS2DQ = 0xF30F5B,\n-    CVTTPS2PI = 0x0F2C,\n-    CVTTSD2SI = 0xF20F2C,\n-    CVTTSS2SI = 0xF30F2C,\n-    MASKMOVDQU = 0x660FF7,\n-    MASKMOVQ = 0x0FF7,\n-    MAXPD = 0x660F5F,\n-    MAXPS = 0x0F5F,\n-    MAXSD = 0xF20F5F,\n-    MAXSS = 0xF30F5F,\n-    MINPD = 0x660F5D,\n-    MINPS = 0x0F5D,\n-    MINSD = 0xF20F5D,\n-    MINSS = 0xF30F5D,\n-    ORPD = 0x660F56,\n-    ORPS = 0x0F56,\n-    PAVGB = 0x660FE0,\n-    PAVGW = 0x660FE3,\n-    PMAXSW = 0x660FEE,\n-    //PINSRW = 0x660FC4,\n-    PMAXUB = 0x660FDE,\n-    PMINSW = 0x660FEA,\n-    PMINUB = 0x660FDA,\n-    //PMOVMSKB = 0x660FD7,\n-    PMULHUW = 0x660FE4,\n-    PMULHW = 0x660FE5,\n-    PMULUDQ = 0x660FF4,\n-    PSADBW = 0x660FF6,\n-    PUNPCKHQDQ = 0x660F6D,\n-    PUNPCKLQDQ = 0x660F6C,\n-    RCPPS = 0x0F53,\n-    RCPSS = 0xF30F53,\n-    RSQRTPS = 0x0F52,\n-    RSQRTSS = 0xF30F52,\n-    SQRTPD = 0x660F51,\n-    SHUFPD = 0x660FC6,\n-    SHUFPS = 0x0FC6,\n-    SQRTPS = 0x0F51,\n-    SQRTSD = 0xF20F51,\n-    SQRTSS = 0xF30F51,\n-    UNPCKHPD = 0x660F15,\n-    UNPCKHPS = 0x0F15,\n-    UNPCKLPD = 0x660F14,\n-    UNPCKLPS = 0x0F14,\n-\n-    PSHUFD = 0x660F70,\n-    PSHUFHW = 0xF30F70,\n-    PSHUFLW = 0xF20F70,\n-    PSHUFW = 0x0F70,\n-    PSLLDQ = 0x07660F73,\n-    PSRLDQ = 0x03660F73,\n-\n-    //PREFETCH = 0x0F18,\n-\n-// SSE3 Pentium 4 (Prescott)\n-\n-    ADDSUBPD = 0x660FD0,\n-    ADDSUBPS = 0xF20FD0,\n-    HADDPD   = 0x660F7C,\n-    HADDPS   = 0xF20F7C,\n-    HSUBPD   = 0x660F7D,\n-    HSUBPS   = 0xF20F7D,\n-    MOVDDUP  = 0xF20F12,\n-    MOVSHDUP = 0xF30F16,\n-    MOVSLDUP = 0xF30F12,\n-    LDDQU    = 0xF20FF0,\n-    MONITOR  = 0x0F01C8,\n-    MWAIT    = 0x0F01C9,\n-\n-// SSSE3\n-    PALIGNR = 0x660F3A0F,\n-    PHADDD = 0x660F3802,\n-    PHADDW = 0x660F3801,\n-    PHADDSW = 0x660F3803,\n-    PABSB = 0x660F381C,\n-    PABSD = 0x660F381E,\n-    PABSW = 0x660F381D,\n-    PSIGNB = 0x660F3808,\n-    PSIGND = 0x660F380A,\n-    PSIGNW = 0x660F3809,\n-    PSHUFB = 0x660F3800,\n-    PMADDUBSW = 0x660F3804,\n-    PMULHRSW = 0x660F380B,\n-    PHSUBD = 0x660F3806,\n-    PHSUBW = 0x660F3805,\n-    PHSUBSW = 0x660F3807,\n-\n-// SSE4.1\n-\n-    BLENDPD   = 0x660F3A0D,\n-    BLENDPS   = 0x660F3A0C,\n-    BLENDVPD  = 0x660F3815,\n-    BLENDVPS  = 0x660F3814,\n-    DPPD      = 0x660F3A41,\n-    DPPS      = 0x660F3A40,\n-    EXTRACTPS = 0x660F3A17,\n-    INSERTPS  = 0x660F3A21,\n-    MPSADBW   = 0x660F3A42,\n-    PBLENDVB  = 0x660F3810,\n-    PBLENDW   = 0x660F3A0E,\n-    PEXTRD    = 0x660F3A16,\n-    PEXTRQ    = 0x660F3A16,\n-    PINSRB    = 0x660F3A20,\n-    PINSRD    = 0x660F3A22,\n-    PINSRQ    = 0x660F3A22,\n-\n-    MOVNTDQA = 0x660F382A,\n-    PACKUSDW = 0x660F382B,\n-    PCMPEQQ = 0x660F3829,\n-    PEXTRB = 0x660F3A14,\n-    PHMINPOSUW = 0x660F3841,\n-    PMAXSB = 0x660F383C,\n-    PMAXSD = 0x660F383D,\n-    PMAXUD = 0x660F383F,\n-    PMAXUW = 0x660F383E,\n-    PMINSB = 0x660F3838,\n-    PMINSD = 0x660F3839,\n-    PMINUD = 0x660F383B,\n-    PMINUW = 0x660F383A,\n-    PMOVSXBW = 0x660F3820,\n-    PMOVSXBD = 0x660F3821,\n-    PMOVSXBQ = 0x660F3822,\n-    PMOVSXWD = 0x660F3823,\n-    PMOVSXWQ = 0x660F3824,\n-    PMOVSXDQ = 0x660F3825,\n-    PMOVZXBW = 0x660F3830,\n-    PMOVZXBD = 0x660F3831,\n-    PMOVZXBQ = 0x660F3832,\n-    PMOVZXWD = 0x660F3833,\n-    PMOVZXWQ = 0x660F3834,\n-    PMOVZXDQ = 0x660F3835,\n-    PMULDQ   = 0x660F3828,\n-    PMULLD   = 0x660F3840,\n-    PTEST    = 0x660F3817,\n-\n-    ROUNDPD = 0x660F3A09,\n-    ROUNDPS = 0x660F3A08,\n-    ROUNDSD = 0x660F3A0B,\n-    ROUNDSS = 0x660F3A0A,\n-\n-// SSE4.2\n-    PCMPESTRI  = 0x660F3A61,\n-    PCMPESTRM  = 0x660F3A60,\n-    PCMPISTRI  = 0x660F3A63,\n-    PCMPISTRM  = 0x660F3A62,\n-    PCMPGTQ    = 0x660F3837,\n-    //CRC32\n-\n-// SSE4a (AMD only)\n-    // EXTRQ,INSERTQ,MOVNTSD,MOVNTSS\n-\n-// POPCNT and LZCNT (have their own CPUID bits)\n-    POPCNT     = 0xF30FB8,\n-    // LZCNT\n-  }\n-\n-  /**\n-   * Generate two operand instruction with XMM 128 bit operands.\n-   *\n-   * This is a compiler magic function - it doesn't behave like\n-   * regular D functions.\n-   *\n-   * Parameters:\n-   *      opcode  any of the XMM opcodes; it must be a compile time constant\n-   *      op1     first operand\n-   *      op2     second operand\n-   * Returns:\n-   *      result of opcode\n-   */\n-  pure @safe void16 __simd(XMM opcode, void16 op1, void16 op2);\n-\n-  /**\n-   * Unary SIMD instructions.\n-   */\n-  pure @safe void16 __simd(XMM opcode, void16 op1);\n-  pure @safe void16 __simd(XMM opcode, double d);       ///\n-  pure @safe void16 __simd(XMM opcode, float f);        ///\n-\n-  /****\n-   * For instructions:\n-   * CMPPD, CMPSS, CMPSD, CMPPS,\n-   * PSHUFD, PSHUFHW, PSHUFLW,\n-   * BLENDPD, BLENDPS, DPPD, DPPS,\n-   * MPSADBW, PBLENDW,\n-   * ROUNDPD, ROUNDPS, ROUNDSD, ROUNDSS\n-   * Parameters:\n-   *      opcode  any of the above XMM opcodes; it must be a compile time constant\n-   *      op1     first operand\n-   *      op2     second operand\n-   *      imm8    third operand; must be a compile time constant\n-   * Returns:\n-   *      result of opcode\n-   */\n-  pure @safe void16 __simd(XMM opcode, void16 op1, void16 op2, ubyte imm8);\n-\n-  /***\n-   * For instructions with the imm8 version:\n-   * PSLLD, PSLLQ, PSLLW, PSRAD, PSRAW, PSRLD, PSRLQ, PSRLW,\n-   * PSRLDQ, PSLLDQ\n-   * Parameters:\n-   *      opcode  any of the XMM opcodes; it must be a compile time constant\n-   *      op1     first operand\n-   *      imm8    second operand; must be a compile time constant\n-   * Returns:\n-   *      result of opcode\n-   */\n-  pure @safe void16 __simd_ib(XMM opcode, void16 op1, ubyte imm8);\n-\n-  /*****\n-   * For \"store\" operations of the form:\n-   *    op1 op= op2\n-   * Returns:\n-   *    op2\n-   * These cannot be marked as pure, as semantic() doesn't check them.\n-   */\n-  @safe void16 __simd_sto(XMM opcode, void16 op1, void16 op2);\n-  @safe void16 __simd_sto(XMM opcode, double op1, void16 op2); ///\n-  @safe void16 __simd_sto(XMM opcode, float op1, void16 op2);  ///\n-\n-  /* The following use overloading to ensure correct typing.\n-   * Compile with inlining on for best performance.\n-   */\n-\n-  pure @safe short8 pcmpeq()(short8 v1, short8 v2)\n-  {\n-      return __simd(XMM.PCMPEQW, v1, v2);\n-  }\n-\n-  pure @safe ushort8 pcmpeq()(ushort8 v1, ushort8 v2)\n-  {\n-      return __simd(XMM.PCMPEQW, v1, v2);\n-  }\n-\n-  /*********************\n-   * Emit prefetch instruction.\n-   * Params:\n-   *    address = address to be prefetched\n-   *    writeFetch = true for write fetch, false for read fetch\n-   *    locality = 0..3 (0 meaning least local, 3 meaning most local)\n-   * Note:\n-   *    The Intel mappings are:\n-   *    $(TABLE\n-   *    $(THEAD writeFetch, locality, Instruction)\n-   *    $(TROW false, 0, prefetchnta)\n-   *    $(TROW false, 1, prefetch2)\n-   *    $(TROW false, 2, prefetch1)\n-   *    $(TROW false, 3, prefetch0)\n-   *    $(TROW false, 0, prefetchw)\n-   *    $(TROW false, 1, prefetchw)\n-   *    $(TROW false, 2, prefetchw)\n-   *    $(TROW false, 3, prefetchw)\n-   *    )\n-   */\n-  void prefetch(bool writeFetch, ubyte locality)(const(void)* address)\n-  {\n+    /** XMM opcodes that conform to the following:\n+    *\n+    *  opcode xmm1,xmm2/mem\n+    *\n+    * and do not have side effects (i.e. do not write to memory).\n+    */\n+    enum XMM\n+    {\n+        ADDSS = 0xF30F58,\n+        ADDSD = 0xF20F58,\n+        ADDPS = 0x000F58,\n+        ADDPD = 0x660F58,\n+        PADDB = 0x660FFC,\n+        PADDW = 0x660FFD,\n+        PADDD = 0x660FFE,\n+        PADDQ = 0x660FD4,\n+\n+        SUBSS = 0xF30F5C,\n+        SUBSD = 0xF20F5C,\n+        SUBPS = 0x000F5C,\n+        SUBPD = 0x660F5C,\n+        PSUBB = 0x660FF8,\n+        PSUBW = 0x660FF9,\n+        PSUBD = 0x660FFA,\n+        PSUBQ = 0x660FFB,\n+\n+        MULSS = 0xF30F59,\n+        MULSD = 0xF20F59,\n+        MULPS = 0x000F59,\n+        MULPD = 0x660F59,\n+        PMULLW = 0x660FD5,\n+\n+        DIVSS = 0xF30F5E,\n+        DIVSD = 0xF20F5E,\n+        DIVPS = 0x000F5E,\n+        DIVPD = 0x660F5E,\n+\n+        PAND  = 0x660FDB,\n+        POR   = 0x660FEB,\n+\n+        UCOMISS = 0x000F2E,\n+        UCOMISD = 0x660F2E,\n+\n+        XORPS = 0x000F57,\n+        XORPD = 0x660F57,\n+\n+        // Use STO and LOD instead of MOV to distinguish the direction\n+        // (Destination is first operand, Source is second operand)\n+        STOSS  = 0xF30F11,        /// MOVSS xmm1/m32, xmm2\n+        STOSD  = 0xF20F11,        /// MOVSD xmm1/m64, xmm2\n+        STOAPS = 0x000F29,        /// MOVAPS xmm2/m128, xmm1\n+        STOAPD = 0x660F29,        /// MOVAPD xmm2/m128, xmm1\n+        STODQA = 0x660F7F,        /// MOVDQA xmm2/m128, xmm1\n+        STOD   = 0x660F7E,        /// MOVD reg/mem64, xmm   66 0F 7E /r\n+        STOQ   = 0x660FD6,        /// MOVQ xmm2/m64, xmm1\n+\n+        LODSS  = 0xF30F10,        /// MOVSS xmm1, xmm2/m32\n+        LODSD  = 0xF20F10,        /// MOVSD xmm1, xmm2/m64\n+        LODAPS = 0x000F28,        /// MOVAPS xmm1, xmm2/m128\n+        LODAPD = 0x660F28,        /// MOVAPD xmm1, xmm2/m128\n+        LODDQA = 0x660F6F,        /// MOVDQA xmm1, xmm2/m128\n+        LODD   = 0x660F6E,        /// MOVD xmm, reg/mem64   66 0F 6E /r\n+        LODQ   = 0xF30F7E,        /// MOVQ xmm1, xmm2/m64\n+\n+        LODDQU   = 0xF30F6F,      /// MOVDQU xmm1, xmm2/mem128  F3 0F 6F /r\n+        STODQU   = 0xF30F7F,      /// MOVDQU xmm1/mem128, xmm2  F3 0F 7F /r\n+        MOVDQ2Q  = 0xF20FD6,      /// MOVDQ2Q mmx, xmm          F2 0F D6 /r\n+        MOVHLPS  = 0x0F12,        /// MOVHLPS xmm1, xmm2        0F 12 /r\n+        LODHPD   = 0x660F16,      /// MOVHPD xmm1, m64\n+        STOHPD   = 0x660F17,      /// MOVHPD mem64, xmm1        66 0F 17 /r\n+        LODHPS   = 0x0F16,        /// MOVHPS xmm1, m64\n+        STOHPS   = 0x0F17,        /// MOVHPS m64, xmm1\n+        MOVLHPS  = 0x0F16,        /// MOVLHPS xmm1, xmm2\n+        LODLPD   = 0x660F12,      /// MOVLPD xmm1, m64\n+        STOLPD   = 0x660F13,      /// MOVLPD m64, xmm1\n+        LODLPS   = 0x0F12,        /// MOVLPS xmm1, m64\n+        STOLPS   = 0x0F13,        /// MOVLPS m64, xmm1\n+        MOVMSKPD = 0x660F50,      /// MOVMSKPD reg, xmm\n+        MOVMSKPS = 0x0F50,        /// MOVMSKPS reg, xmm\n+        MOVNTDQ  = 0x660FE7,      /// MOVNTDQ m128, xmm1\n+        MOVNTI   = 0x0FC3,        /// MOVNTI m32, r32\n+        MOVNTPD  = 0x660F2B,      /// MOVNTPD m128, xmm1\n+        MOVNTPS  = 0x0F2B,        /// MOVNTPS m128, xmm1\n+        MOVNTQ   = 0x0FE7,        /// MOVNTQ m64, mm\n+        MOVQ2DQ  = 0xF30FD6,      /// MOVQ2DQ\n+        LODUPD   = 0x660F10,      /// MOVUPD xmm1, xmm2/m128\n+        STOUPD   = 0x660F11,      /// MOVUPD xmm2/m128, xmm1\n+        LODUPS   = 0x0F10,        /// MOVUPS xmm1, xmm2/m128\n+        STOUPS   = 0x0F11,        /// MOVUPS xmm2/m128, xmm1\n+\n+        PACKSSDW = 0x660F6B,\n+        PACKSSWB = 0x660F63,\n+        PACKUSWB = 0x660F67,\n+        PADDSB = 0x660FEC,\n+        PADDSW = 0x660FED,\n+        PADDUSB = 0x660FDC,\n+        PADDUSW = 0x660FDD,\n+        PANDN = 0x660FDF,\n+        PCMPEQB = 0x660F74,\n+        PCMPEQD = 0x660F76,\n+        PCMPEQW = 0x660F75,\n+        PCMPGTB = 0x660F64,\n+        PCMPGTD = 0x660F66,\n+        PCMPGTW = 0x660F65,\n+        PMADDWD = 0x660FF5,\n+        PSLLW = 0x660FF1,\n+        PSLLD = 0x660FF2,\n+        PSLLQ = 0x660FF3,\n+        PSRAW = 0x660FE1,\n+        PSRAD = 0x660FE2,\n+        PSRLW = 0x660FD1,\n+        PSRLD = 0x660FD2,\n+        PSRLQ = 0x660FD3,\n+        PSUBSB = 0x660FE8,\n+        PSUBSW = 0x660FE9,\n+        PSUBUSB = 0x660FD8,\n+        PSUBUSW = 0x660FD9,\n+        PUNPCKHBW = 0x660F68,\n+        PUNPCKHDQ = 0x660F6A,\n+        PUNPCKHWD = 0x660F69,\n+        PUNPCKLBW = 0x660F60,\n+        PUNPCKLDQ = 0x660F62,\n+        PUNPCKLWD = 0x660F61,\n+        PXOR = 0x660FEF,\n+        ANDPD = 0x660F54,\n+        ANDPS = 0x0F54,\n+        ANDNPD = 0x660F55,\n+        ANDNPS = 0x0F55,\n+        CMPPS = 0x0FC2,\n+        CMPPD = 0x660FC2,\n+        CMPSD = 0xF20FC2,\n+        CMPSS = 0xF30FC2,\n+        COMISD = 0x660F2F,\n+        COMISS = 0x0F2F,\n+        CVTDQ2PD = 0xF30FE6,\n+        CVTDQ2PS = 0x0F5B,\n+        CVTPD2DQ = 0xF20FE6,\n+        CVTPD2PI = 0x660F2D,\n+        CVTPD2PS = 0x660F5A,\n+        CVTPI2PD = 0x660F2A,\n+        CVTPI2PS = 0x0F2A,\n+        CVTPS2DQ = 0x660F5B,\n+        CVTPS2PD = 0x0F5A,\n+        CVTPS2PI = 0x0F2D,\n+        CVTSD2SI = 0xF20F2D,\n+        CVTSD2SS = 0xF20F5A,\n+        CVTSI2SD = 0xF20F2A,\n+        CVTSI2SS = 0xF30F2A,\n+        CVTSS2SD = 0xF30F5A,\n+        CVTSS2SI = 0xF30F2D,\n+        CVTTPD2PI = 0x660F2C,\n+        CVTTPD2DQ = 0x660FE6,\n+        CVTTPS2DQ = 0xF30F5B,\n+        CVTTPS2PI = 0x0F2C,\n+        CVTTSD2SI = 0xF20F2C,\n+        CVTTSS2SI = 0xF30F2C,\n+        MASKMOVDQU = 0x660FF7,\n+        MASKMOVQ = 0x0FF7,\n+        MAXPD = 0x660F5F,\n+        MAXPS = 0x0F5F,\n+        MAXSD = 0xF20F5F,\n+        MAXSS = 0xF30F5F,\n+        MINPD = 0x660F5D,\n+        MINPS = 0x0F5D,\n+        MINSD = 0xF20F5D,\n+        MINSS = 0xF30F5D,\n+        ORPD = 0x660F56,\n+        ORPS = 0x0F56,\n+        PAVGB = 0x660FE0,\n+        PAVGW = 0x660FE3,\n+        PMAXSW = 0x660FEE,\n+        //PINSRW = 0x660FC4,\n+        PMAXUB = 0x660FDE,\n+        PMINSW = 0x660FEA,\n+        PMINUB = 0x660FDA,\n+        //PMOVMSKB = 0x660FD7,\n+        PMULHUW = 0x660FE4,\n+        PMULHW = 0x660FE5,\n+        PMULUDQ = 0x660FF4,\n+        PSADBW = 0x660FF6,\n+        PUNPCKHQDQ = 0x660F6D,\n+        PUNPCKLQDQ = 0x660F6C,\n+        RCPPS = 0x0F53,\n+        RCPSS = 0xF30F53,\n+        RSQRTPS = 0x0F52,\n+        RSQRTSS = 0xF30F52,\n+        SQRTPD = 0x660F51,\n+        SHUFPD = 0x660FC6,\n+        SHUFPS = 0x0FC6,\n+        SQRTPS = 0x0F51,\n+        SQRTSD = 0xF20F51,\n+        SQRTSS = 0xF30F51,\n+        UNPCKHPD = 0x660F15,\n+        UNPCKHPS = 0x0F15,\n+        UNPCKLPD = 0x660F14,\n+        UNPCKLPS = 0x0F14,\n+\n+        PSHUFD = 0x660F70,\n+        PSHUFHW = 0xF30F70,\n+        PSHUFLW = 0xF20F70,\n+        PSHUFW = 0x0F70,\n+        PSLLDQ = 0x07660F73,\n+        PSRLDQ = 0x03660F73,\n+\n+        //PREFETCH = 0x0F18,\n+\n+        // SSE3 Pentium 4 (Prescott)\n+\n+        ADDSUBPD = 0x660FD0,\n+        ADDSUBPS = 0xF20FD0,\n+        HADDPD   = 0x660F7C,\n+        HADDPS   = 0xF20F7C,\n+        HSUBPD   = 0x660F7D,\n+        HSUBPS   = 0xF20F7D,\n+        MOVDDUP  = 0xF20F12,\n+        MOVSHDUP = 0xF30F16,\n+        MOVSLDUP = 0xF30F12,\n+        LDDQU    = 0xF20FF0,\n+        MONITOR  = 0x0F01C8,\n+        MWAIT    = 0x0F01C9,\n+\n+        // SSSE3\n+        PALIGNR = 0x660F3A0F,\n+        PHADDD = 0x660F3802,\n+        PHADDW = 0x660F3801,\n+        PHADDSW = 0x660F3803,\n+        PABSB = 0x660F381C,\n+        PABSD = 0x660F381E,\n+        PABSW = 0x660F381D,\n+        PSIGNB = 0x660F3808,\n+        PSIGND = 0x660F380A,\n+        PSIGNW = 0x660F3809,\n+        PSHUFB = 0x660F3800,\n+        PMADDUBSW = 0x660F3804,\n+        PMULHRSW = 0x660F380B,\n+        PHSUBD = 0x660F3806,\n+        PHSUBW = 0x660F3805,\n+        PHSUBSW = 0x660F3807,\n+\n+        // SSE4.1\n+\n+        BLENDPD   = 0x660F3A0D,\n+        BLENDPS   = 0x660F3A0C,\n+        BLENDVPD  = 0x660F3815,\n+        BLENDVPS  = 0x660F3814,\n+        DPPD      = 0x660F3A41,\n+        DPPS      = 0x660F3A40,\n+        EXTRACTPS = 0x660F3A17,\n+        INSERTPS  = 0x660F3A21,\n+        MPSADBW   = 0x660F3A42,\n+        PBLENDVB  = 0x660F3810,\n+        PBLENDW   = 0x660F3A0E,\n+        PEXTRD    = 0x660F3A16,\n+        PEXTRQ    = 0x660F3A16,\n+        PINSRB    = 0x660F3A20,\n+        PINSRD    = 0x660F3A22,\n+        PINSRQ    = 0x660F3A22,\n+\n+        MOVNTDQA = 0x660F382A,\n+        PACKUSDW = 0x660F382B,\n+        PCMPEQQ = 0x660F3829,\n+        PEXTRB = 0x660F3A14,\n+        PHMINPOSUW = 0x660F3841,\n+        PMAXSB = 0x660F383C,\n+        PMAXSD = 0x660F383D,\n+        PMAXUD = 0x660F383F,\n+        PMAXUW = 0x660F383E,\n+        PMINSB = 0x660F3838,\n+        PMINSD = 0x660F3839,\n+        PMINUD = 0x660F383B,\n+        PMINUW = 0x660F383A,\n+        PMOVSXBW = 0x660F3820,\n+        PMOVSXBD = 0x660F3821,\n+        PMOVSXBQ = 0x660F3822,\n+        PMOVSXWD = 0x660F3823,\n+        PMOVSXWQ = 0x660F3824,\n+        PMOVSXDQ = 0x660F3825,\n+        PMOVZXBW = 0x660F3830,\n+        PMOVZXBD = 0x660F3831,\n+        PMOVZXBQ = 0x660F3832,\n+        PMOVZXWD = 0x660F3833,\n+        PMOVZXWQ = 0x660F3834,\n+        PMOVZXDQ = 0x660F3835,\n+        PMULDQ   = 0x660F3828,\n+        PMULLD   = 0x660F3840,\n+        PTEST    = 0x660F3817,\n+\n+        ROUNDPD = 0x660F3A09,\n+        ROUNDPS = 0x660F3A08,\n+        ROUNDSD = 0x660F3A0B,\n+        ROUNDSS = 0x660F3A0A,\n+\n+        // SSE4.2\n+        PCMPESTRI  = 0x660F3A61,\n+        PCMPESTRM  = 0x660F3A60,\n+        PCMPISTRI  = 0x660F3A63,\n+        PCMPISTRM  = 0x660F3A62,\n+        PCMPGTQ    = 0x660F3837,\n+        //CRC32\n+\n+        // SSE4a (AMD only)\n+        // EXTRQ,INSERTQ,MOVNTSD,MOVNTSS\n+\n+        // POPCNT and LZCNT (have their own CPUID bits)\n+        POPCNT     = 0xF30FB8,\n+        // LZCNT\n+    }\n+\n+    /**\n+    * Generate two operand instruction with XMM 128 bit operands.\n+    *\n+    * This is a compiler magic function - it doesn't behave like\n+    * regular D functions.\n+    *\n+    * Parameters:\n+    *      opcode = any of the XMM opcodes; it must be a compile time constant\n+    *      op1    = first operand\n+    *      op2    = second operand\n+    * Returns:\n+    *      result of opcode\n+    */\n+    pure @safe void16 __simd(XMM opcode, void16 op1, void16 op2);\n+\n+    ///\n+    unittest\n+    {\n+        float4 a;\n+        a = cast(float4)__simd(XMM.PXOR, a, a);\n+    }\n+\n+    /**\n+    * Unary SIMD instructions.\n+    */\n+    pure @safe void16 __simd(XMM opcode, void16 op1);\n+    pure @safe void16 __simd(XMM opcode, double d);   ///\n+    pure @safe void16 __simd(XMM opcode, float f);    ///\n+\n+    ///\n+    unittest\n+    {\n+        float4 a;\n+        a = cast(float4)__simd(XMM.LODSS, a);\n+    }\n+\n+    /****\n+    * For instructions:\n+    * CMPPD, CMPSS, CMPSD, CMPPS,\n+    * PSHUFD, PSHUFHW, PSHUFLW,\n+    * BLENDPD, BLENDPS, DPPD, DPPS,\n+    * MPSADBW, PBLENDW,\n+    * ROUNDPD, ROUNDPS, ROUNDSD, ROUNDSS\n+    * Parameters:\n+    *      opcode = any of the above XMM opcodes; it must be a compile time constant\n+    *      op1    = first operand\n+    *      op2    = second operand\n+    *      imm8   = third operand; must be a compile time constant\n+    * Returns:\n+    *      result of opcode\n+    */\n+    pure @safe void16 __simd(XMM opcode, void16 op1, void16 op2, ubyte imm8);\n+\n+    ///\n+    unittest\n+    {\n+        float4 a;\n+        a = cast(float4)__simd(XMM.CMPPD, a, a, 0x7A);\n+    }\n+\n+    /***\n+    * For instructions with the imm8 version:\n+    * PSLLD, PSLLQ, PSLLW, PSRAD, PSRAW, PSRLD, PSRLQ, PSRLW,\n+    * PSRLDQ, PSLLDQ\n+    * Parameters:\n+    *      opcode = any of the XMM opcodes; it must be a compile time constant\n+    *      op1    = first operand\n+    *      imm8   = second operand; must be a compile time constant\n+    * Returns:\n+    *      result of opcode\n+    */\n+    pure @safe void16 __simd_ib(XMM opcode, void16 op1, ubyte imm8);\n+\n+    ///\n+    unittest\n+    {\n+        float4 a;\n+        a = cast(float4) __simd_ib(XMM.PSRLQ, a, 0x7A);\n+    }\n+\n+    /*****\n+    * For \"store\" operations of the form:\n+    *    op1 op= op2\n+    * Returns:\n+    *    op2\n+    * These cannot be marked as pure, as semantic() doesn't check them.\n+    */\n+    @safe void16 __simd_sto(XMM opcode, void16 op1, void16 op2);\n+    @safe void16 __simd_sto(XMM opcode, double op1, void16 op2); ///\n+    @safe void16 __simd_sto(XMM opcode, float op1, void16 op2);  ///\n+\n+    ///\n+    unittest\n+    {\n+        void16 a;\n+        float f = 1;\n+        double d = 1;\n+\n+        cast(void)__simd_sto(XMM.STOUPS, a, a);\n+        cast(void)__simd_sto(XMM.STOUPS, f, a);\n+        cast(void)__simd_sto(XMM.STOUPS, d, a);\n+    }\n+\n+    /* The following use overloading to ensure correct typing.\n+    * Compile with inlining on for best performance.\n+    */\n+\n+    pure @safe short8 pcmpeq()(short8 v1, short8 v2)\n+    {\n+        return cast(short8)__simd(XMM.PCMPEQW, v1, v2);\n+    }\n+\n+    pure @safe ushort8 pcmpeq()(ushort8 v1, ushort8 v2)\n+    {\n+        return cast(ushort8)__simd(XMM.PCMPEQW, v1, v2);\n+    }\n+\n+    /*********************\n+    * Emit prefetch instruction.\n+    * Params:\n+    *    address = address to be prefetched\n+    *    writeFetch = true for write fetch, false for read fetch\n+    *    locality = 0..3 (0 meaning least local, 3 meaning most local)\n+    * Note:\n+    *    The Intel mappings are:\n+    *    $(TABLE\n+    *    $(THEAD writeFetch, locality, Instruction)\n+    *    $(TROW false, 0, prefetchnta)\n+    *    $(TROW false, 1, prefetch2)\n+    *    $(TROW false, 2, prefetch1)\n+    *    $(TROW false, 3, prefetch0)\n+    *    $(TROW true, 0, prefetchw)\n+    *    $(TROW true, 1, prefetchw)\n+    *    $(TROW true, 2, prefetchw)\n+    *    $(TROW true, 3, prefetchw)\n+    *    )\n+    */\n+    void prefetch(bool writeFetch, ubyte locality)(const(void)* address)\n+    {\n         static if (writeFetch)\n             __prefetch(address, 4);\n         else static if (locality < 4)\n             __prefetch(address, 3 - locality);\n         else\n             static assert(0, \"0..3 expected for locality\");\n-  }\n+    }\n \n-  private void __prefetch(const(void*) address, ubyte encoding);\n+    private void __prefetch(const(void*) address, ubyte encoding);\n \n-  /*************************************\n-   * Load unaligned vector from address.\n-   * This is a compiler intrinsic.\n-   * Params:\n-   *    p = pointer to vector\n-   * Returns:\n-   *    vector\n-   */\n+    /*************************************\n+    * Load unaligned vector from address.\n+    * This is a compiler intrinsic.\n+    * Params:\n+    *    p = pointer to vector\n+    * Returns:\n+    *    vector\n+    */\n \n-  V loadUnaligned(V)(const V* p)\n+    V loadUnaligned(V)(const V* p)\n         if (is(V == void16) ||\n             is(V == byte16) ||\n             is(V == ubyte16) ||\n@@ -510,28 +564,74 @@ version (D_SIMD)\n             is(V == int4) ||\n             is(V == uint4) ||\n             is(V == long2) ||\n-            is(V == ulong2))\n-  {\n+            is(V == ulong2) ||\n+            is(V == double2) ||\n+            is(V == float4))\n+    {\n         pragma(inline, true);\n         static if (is(V == double2))\n             return cast(V)__simd(XMM.LODUPD, *cast(const void16*)p);\n         else static if (is(V == float4))\n             return cast(V)__simd(XMM.LODUPS, *cast(const void16*)p);\n         else\n             return cast(V)__simd(XMM.LODDQU, *cast(const void16*)p);\n-  }\n-\n-  /*************************************\n-   * Store vector to unaligned address.\n-   * This is a compiler intrinsic.\n-   * Params:\n-   *    p = pointer to vector\n-   *    value = value to store\n-   * Returns:\n-   *    value\n-   */\n-\n-  V storeUnaligned(V)(V* p, V value)\n+    }\n+\n+    @system\n+    unittest\n+    {\n+        // Memory to load into the vector:\n+        // Should have enough data to test all 16-byte alignments, and still\n+        // have room for a 16-byte vector\n+        ubyte[32] data;\n+        foreach (i; 0..data.length)\n+        {\n+            data[i] = cast(ubyte)i;\n+        }\n+\n+        // to test all alignments from 1 ~ 16\n+        foreach (i; 0..16)\n+        {\n+            ubyte* d = &data[i];\n+\n+            void test(T)()\n+            {\n+                // load the data\n+                T v = loadUnaligned(cast(T*)d);\n+\n+                // check that the data was loaded correctly\n+                ubyte* ptrToV = cast(ubyte*)&v;\n+                foreach (j; 0..T.sizeof)\n+                {\n+                    assert(ptrToV[j] == d[j]);\n+                }\n+            }\n+\n+            test!void16();\n+            test!byte16();\n+            test!ubyte16();\n+            test!short8();\n+            test!ushort8();\n+            test!int4();\n+            test!uint4();\n+            test!long2();\n+            test!ulong2();\n+            test!double2();\n+            test!float4();\n+        }\n+    }\n+\n+    /*************************************\n+    * Store vector to unaligned address.\n+    * This is a compiler intrinsic.\n+    * Params:\n+    *    p = pointer to vector\n+    *    value = value to store\n+    * Returns:\n+    *    value\n+    */\n+\n+    V storeUnaligned(V)(V* p, V value)\n         if (is(V == void16) ||\n             is(V == byte16) ||\n             is(V == ubyte16) ||\n@@ -540,14 +640,64 @@ version (D_SIMD)\n             is(V == int4) ||\n             is(V == uint4) ||\n             is(V == long2) ||\n-            is(V == ulong2))\n-  {\n+            is(V == ulong2) ||\n+            is(V == double2) ||\n+            is(V == float4))\n+    {\n         pragma(inline, true);\n         static if (is(V == double2))\n             return cast(V)__simd_sto(XMM.STOUPD, *cast(void16*)p, value);\n         else static if (is(V == float4))\n             return cast(V)__simd_sto(XMM.STOUPS, *cast(void16*)p, value);\n         else\n             return cast(V)__simd_sto(XMM.STODQU, *cast(void16*)p, value);\n-  }\n+    }\n+\n+    @system\n+    unittest\n+    {\n+        // Memory to store the vector to:\n+        // Should have enough data to test all 16-byte alignments, and still\n+        // have room for a 16-byte vector\n+        ubyte[32] data;\n+\n+        // to test all alignments from 1 ~ 16\n+        foreach (i; 0..16)\n+        {\n+            ubyte* d = &data[i];\n+\n+            void test(T)()\n+            {\n+                T v;\n+\n+                // populate v` with data\n+                ubyte* ptrToV = cast(ubyte*)&v;\n+                foreach (j; 0..T.sizeof)\n+                {\n+                    ptrToV[j] = cast(ubyte)j;\n+                }\n+\n+                // store `v` to location pointed to by `d`\n+                storeUnaligned(cast(T*)d, v);\n+\n+                // check that the the data was stored correctly\n+                foreach (j; 0..T.sizeof)\n+                {\n+                    assert(ptrToV[j] == d[j]);\n+                }\n+            }\n+\n+            test!void16();\n+            test!byte16();\n+            test!ubyte16();\n+            test!short8();\n+            test!ushort8();\n+            test!int4();\n+            test!uint4();\n+            test!long2();\n+            test!ulong2();\n+            test!double2();\n+            test!float4();\n+        }\n+    }\n }"}, {"sha": "67011596b1cab1315a1289ed66de69b09c1e9f14", "filename": "libphobos/libdruntime/core/stdc/stdio.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdio.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdio.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdio.d?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -1527,7 +1527,7 @@ else version (OpenBSD)\n     {\n         void __sclearerr()(FILE* p)\n         {\n-            p._flags &= ~(__SERR|__SEOF);\n+            p._flags = p._flags & ~(__SERR|__SEOF);\n         }\n \n         int __sfeof()(FILE* p)"}, {"sha": "18558a2696a2eb89ae6f9205eee283247c010742", "filename": "libphobos/libdruntime/core/sys/posix/locale.d", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Flocale.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Flocale.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Flocale.d?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -415,10 +415,38 @@ else version (Solaris)\n         LC_ALL      = 6,\n     }\n \n+    ///\n+    enum\n+    {\n+        LC_CTYPE_MASK    = (1 << LC_CTYPE),\n+        LC_NUMERIC_MASK  = (1 << LC_NUMERIC),\n+        LC_TIME_MASK     = (1 << LC_TIME),\n+        LC_COLLATE_MASK  = (1 << LC_COLLATE),\n+        LC_MONETARY_MASK = (1 << LC_MONETARY),\n+        LC_MESSAGES_MASK = (1 << LC_MESSAGES),\n+        LC_ALL_MASK      = 0x3f,\n+    }\n+\n+    private struct _LC_locale_t;\n+\n+    ///\n+    alias locale_t = _LC_locale_t**;\n+\n+    ///\n+    enum LC_GLOBAL_LOCALE = (cast(locale_t)-1);\n+\n+    /// Duplicate existing locale\n+    locale_t duplocale(locale_t locale);\n+    /// Free an allocated locale\n+    void     freelocale(locale_t locale);\n     /// Natural language formatting for C\n     lconv*   localeconv();\n+    /// Create a new locale\n+    locale_t newlocale(int mask, const char* locale, locale_t base);\n     /// Set the C library's notion of natural language formatting style\n     char*    setlocale(int category, const char* locale);\n+    /// Set the per-thread locale\n+    locale_t uselocale (locale_t locale);\n }\n else\n     static assert(false, \"unimplemented platform\");"}, {"sha": "defdc9586f148d682a1f8255673a926261caa80c", "filename": "libphobos/libdruntime/core/thread/osthread.d", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fosthread.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fosthread.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fosthread.d?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -1461,14 +1461,6 @@ in (fn)\n     fn(sp);\n }\n \n-version (Solaris)\n-{\n-    import core.sys.solaris.sys.priocntl;\n-    import core.sys.solaris.sys.types;\n-    import core.sys.posix.sys.wait : idtype_t;\n-}\n-\n-\n version (Windows)\n private extern (D) void scanWindowsOnly(scope ScanAllThreadsTypeFn scan, ThreadBase _t) nothrow\n {"}, {"sha": "935b2bdb28704b5b022b453cfdef4c03fa98b152", "filename": "libphobos/libdruntime/core/vararg.d", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2Fcore%2Fvararg.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2Fcore%2Fvararg.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fvararg.d?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -17,3 +17,125 @@\n module core.vararg;\n \n public import core.stdc.stdarg;\n+\n+\n+version (GNU) { /* TypeInfo-based va_arg overload unsupported */ }\n+else:\n+\n+version (ARM)     version = ARM_Any;\n+version (AArch64) version = ARM_Any;\n+version (MIPS32)  version = MIPS_Any;\n+version (MIPS64)  version = MIPS_Any;\n+version (PPC)     version = PPC_Any;\n+version (PPC64)   version = PPC_Any;\n+\n+version (ARM_Any)\n+{\n+    // Darwin uses a simpler varargs implementation\n+    version (OSX) {}\n+    else version (iOS) {}\n+    else version (TVOS) {}\n+    else version (WatchOS) {}\n+    else:\n+\n+    version (ARM)     version = AAPCS32;\n+    version (AArch64) version = AAPCS64;\n+}\n+\n+\n+///\n+alias va_arg = core.stdc.stdarg.va_arg;\n+\n+\n+/**\n+ * Retrieve and store through parmn the next value that is of TypeInfo ti.\n+ * Used when the static type is not known.\n+ */\n+void va_arg()(ref va_list ap, TypeInfo ti, void* parmn)\n+{\n+    version (X86)\n+    {\n+        // Wait until everyone updates to get TypeInfo.talign\n+        //auto talign = ti.talign;\n+        //auto p = cast(void*)(cast(size_t)ap + talign - 1) & ~(talign - 1);\n+        auto p = ap;\n+        auto tsize = ti.tsize;\n+        ap = cast(va_list) (p + tsize.alignUp);\n+        parmn[0..tsize] = p[0..tsize];\n+    }\n+    else version (Win64)\n+    {\n+        version (LDC) enum isLDC = true;\n+        else          enum isLDC = false;\n+\n+        // Wait until everyone updates to get TypeInfo.talign\n+        //auto talign = ti.talign;\n+        //auto p = cast(void*)(cast(size_t)ap + talign - 1) & ~(talign - 1);\n+        auto p = ap;\n+        auto tsize = ti.tsize;\n+        void* q;\n+        if (isLDC && tsize == 16 && cast(TypeInfo_Array) ti)\n+        {\n+            q = p;\n+            ap = cast(va_list) (p + tsize);\n+        }\n+        else\n+        {\n+            q = (tsize > size_t.sizeof || (tsize & (tsize - 1)) != 0) ? *cast(void**) p : p;\n+            ap = cast(va_list) (p + size_t.sizeof);\n+        }\n+        parmn[0..tsize] = q[0..tsize];\n+    }\n+    else version (X86_64)\n+    {\n+        static import core.internal.vararg.sysv_x64;\n+        core.internal.vararg.sysv_x64.va_arg(ap, ti, parmn);\n+    }\n+    else version (AAPCS32)\n+    {\n+        const tsize = ti.tsize;\n+        if (ti.talign >= 8)\n+            ap.__ap = ap.__ap.alignUp!8;\n+        auto p = ap.__ap;\n+        version (BigEndian)\n+            p = adjustForBigEndian(p, tsize);\n+        ap.__ap += tsize.alignUp;\n+        parmn[0..tsize] = p[0..tsize];\n+    }\n+    else version (AAPCS64)\n+    {\n+        static import core.internal.vararg.aarch64;\n+        core.internal.vararg.aarch64.va_arg(ap, ti, parmn);\n+    }\n+    else version (ARM_Any)\n+    {\n+        const tsize = ti.tsize;\n+        auto p = cast(void*) ap;\n+        version (BigEndian)\n+            p = adjustForBigEndian(p, tsize);\n+        ap += tsize.alignUp;\n+        parmn[0..tsize] = p[0..tsize];\n+    }\n+    else version (PPC_Any)\n+    {\n+        if (ti.talign >= 8)\n+            ap = ap.alignUp!8;\n+        const tsize = ti.tsize;\n+        auto p = cast(void*) ap;\n+        version (BigEndian)\n+            p = adjustForBigEndian(p, tsize);\n+        ap += tsize.alignUp;\n+        parmn[0..tsize] = p[0..tsize];\n+    }\n+    else version (MIPS_Any)\n+    {\n+        const tsize = ti.tsize;\n+        auto p = cast(void*) ap;\n+        version (BigEndian)\n+            p = adjustForBigEndian(p, tsize);\n+        ap += tsize.alignUp;\n+        parmn[0..tsize] = p[0..tsize];\n+    }\n+    else\n+        static assert(0, \"Unsupported platform\");\n+}"}, {"sha": "1703450c65fb4d2e3354a17fcb48b9ac8de6a1da", "filename": "libphobos/libdruntime/core/volatile.d", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2Fcore%2Fvolatile.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2Fcore%2Fvolatile.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fvolatile.d?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -0,0 +1,67 @@\n+/**\n+ * This module declares intrinsics for volatile operations.\n+ *\n+ * Copyright: Copyright \u00a9 2019, The D Language Foundation\n+ * License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Authors:   Walter Bright, Ernesto Castellotti\n+ * Source:    $(DRUNTIMESRC core/volatile.d)\n+ */\n+\n+module core.volatile;\n+\n+nothrow:\n+@safe:\n+@nogc:\n+\n+/*************************************\n+ * Read/write value from/to the memory location indicated by ptr.\n+ *\n+ * These functions are recognized by the compiler, and calls to them are guaranteed\n+ * to not be removed (as dead assignment elimination or presumed to have no effect)\n+ * or reordered in the same thread.\n+ *\n+ * These reordering guarantees are only made with regards to other\n+ * operations done through these functions; the compiler is free to reorder regular\n+ * loads/stores with regards to loads/stores done through these functions.\n+ *\n+ * This is useful when dealing with memory-mapped I/O (MMIO) where a store can\n+ * have an effect other than just writing a value, or where sequential loads\n+ * with no intervening stores can retrieve\n+ * different values from the same location due to external stores to the location.\n+ *\n+ * These functions will, when possible, do the load/store as a single operation. In\n+ * general, this is possible when the size of the operation is less than or equal to\n+ * $(D (void*).sizeof), although some targets may support larger operations. If the\n+ * load/store cannot be done as a single operation, multiple smaller operations will be used.\n+ *\n+ * These are not to be conflated with atomic operations. They do not guarantee any\n+ * atomicity. This may be provided by coincidence as a result of the instructions\n+ * used on the target, but this should not be relied on for portable programs.\n+ * Further, no memory fences are implied by these functions.\n+ * They should not be used for communication between threads.\n+ * They may be used to guarantee a write or read cycle occurs at a specified address.\n+ */\n+\n+ubyte  volatileLoad(ubyte * ptr);\n+ushort volatileLoad(ushort* ptr);  /// ditto\n+uint   volatileLoad(uint  * ptr);  /// ditto\n+ulong  volatileLoad(ulong * ptr);  /// ditto\n+\n+void volatileStore(ubyte * ptr, ubyte  value);   /// ditto\n+void volatileStore(ushort* ptr, ushort value);   /// ditto\n+void volatileStore(uint  * ptr, uint   value);   /// ditto\n+void volatileStore(ulong * ptr, ulong  value);   /// ditto\n+\n+@system unittest\n+{\n+    alias TT(T...) = T;\n+\n+    foreach (T; TT!(ubyte, ushort, uint, ulong))\n+    {\n+        T u;\n+        T* p = &u;\n+        volatileStore(p, 1);\n+        T r = volatileLoad(p);\n+        assert(r == u);\n+    }\n+}"}, {"sha": "6a6eb50eefa720b0fc2682701fd4fd7a5bbe9b77", "filename": "libphobos/libdruntime/rt/lifetime.d", "status": "modified", "additions": 40, "deletions": 69, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2Frt%2Flifetime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Flibdruntime%2Frt%2Flifetime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Flifetime.d?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -44,17 +44,9 @@ private\n     }\n }\n \n-private immutable bool callStructDtorsDuringGC;\n-\n extern (C) void lifetime_init()\n {\n     // this is run before static ctors, so it is safe to modify immutables\n-    import rt.config;\n-    string s = rt_configOption(\"callStructDtorsDuringGC\");\n-    if (s != null)\n-        cast() callStructDtorsDuringGC = s[0] == '1' || s[0] == 'y' || s[0] == 'Y';\n-    else\n-        cast() callStructDtorsDuringGC = true;\n }\n \n /**\n@@ -214,9 +206,6 @@ inout(TypeInfo) unqualify(inout(TypeInfo) cti) pure nothrow @nogc\n // size used to store the TypeInfo at the end of an allocation for structs that have a destructor\n size_t structTypeInfoSize(const TypeInfo ti) pure nothrow @nogc\n {\n-    if (!callStructDtorsDuringGC)\n-        return 0;\n-\n     if (ti && typeid(ti) is typeid(TypeInfo_Struct)) // avoid a complete dynamic type cast\n     {\n         auto sti = cast(TypeInfo_Struct)cast(void*)ti;\n@@ -975,7 +964,7 @@ extern (C) void[] _d_newarrayT(const TypeInfo ti, size_t length) pure nothrow\n  */\n extern (C) void[] _d_newarrayiT(const TypeInfo ti, size_t length) pure nothrow\n {\n-    import core.internal.traits : TypeTuple;\n+    import core.internal.traits : AliasSeq;\n \n     void[] result = _d_newarrayU(ti, length);\n     auto tinext = unqualify(ti.next);\n@@ -985,7 +974,7 @@ extern (C) void[] _d_newarrayiT(const TypeInfo ti, size_t length) pure nothrow\n \n     switch (init.length)\n     {\n-    foreach (T; TypeTuple!(ubyte, ushort, uint, ulong))\n+    foreach (T; AliasSeq!(ubyte, ushort, uint, ulong))\n     {\n     case T.sizeof:\n         (cast(T*)result.ptr)[0 .. size * length / T.sizeof] = *cast(T*)init.ptr;\n@@ -2539,48 +2528,42 @@ unittest\n     delete arr1;\n     assert(dtorCount == 7);\n \n-    if (callStructDtorsDuringGC)\n-    {\n-        dtorCount = 0;\n-        S1* s2 = new S1;\n-        GC.runFinalizers((cast(char*)(typeid(S1).xdtor))[0..1]);\n-        assert(dtorCount == 1);\n-        GC.free(s2);\n+    dtorCount = 0;\n+    S1* s2 = new S1;\n+    GC.runFinalizers((cast(char*)(typeid(S1).xdtor))[0..1]);\n+    assert(dtorCount == 1);\n+    GC.free(s2);\n \n-        dtorCount = 0;\n-        const(S1)* s3 = new const(S1);\n-        GC.runFinalizers((cast(char*)(typeid(S1).xdtor))[0..1]);\n-        assert(dtorCount == 1);\n-        GC.free(cast(void*)s3);\n+    dtorCount = 0;\n+    const(S1)* s3 = new const(S1);\n+    GC.runFinalizers((cast(char*)(typeid(S1).xdtor))[0..1]);\n+    assert(dtorCount == 1);\n+    GC.free(cast(void*)s3);\n \n-        dtorCount = 0;\n-        shared(S1)* s4 = new shared(S1);\n-        GC.runFinalizers((cast(char*)(typeid(S1).xdtor))[0..1]);\n-        assert(dtorCount == 1);\n-        GC.free(cast(void*)s4);\n+    dtorCount = 0;\n+    shared(S1)* s4 = new shared(S1);\n+    GC.runFinalizers((cast(char*)(typeid(S1).xdtor))[0..1]);\n+    assert(dtorCount == 1);\n+    GC.free(cast(void*)s4);\n \n-        dtorCount = 0;\n-        const(S1)[] carr1 = new const(S1)[5];\n-        BlkInfo blkinf1 = GC.query(carr1.ptr);\n-        GC.runFinalizers((cast(char*)(typeid(S1).xdtor))[0..1]);\n-        assert(dtorCount == 5);\n-        GC.free(blkinf1.base);\n-    }\n+    dtorCount = 0;\n+    const(S1)[] carr1 = new const(S1)[5];\n+    BlkInfo blkinf1 = GC.query(carr1.ptr);\n+    GC.runFinalizers((cast(char*)(typeid(S1).xdtor))[0..1]);\n+    assert(dtorCount == 5);\n+    GC.free(blkinf1.base);\n \n     dtorCount = 0;\n     S1[] arr2 = new S1[10];\n     arr2.length = 6;\n     arr2.assumeSafeAppend;\n     assert(dtorCount == 4); // destructors run explicitely?\n \n-    if (callStructDtorsDuringGC)\n-    {\n-        dtorCount = 0;\n-        BlkInfo blkinf = GC.query(arr2.ptr);\n-        GC.runFinalizers((cast(char*)(typeid(S1).xdtor))[0..1]);\n-        assert(dtorCount == 6);\n-        GC.free(blkinf.base);\n-    }\n+    dtorCount = 0;\n+    BlkInfo blkinf = GC.query(arr2.ptr);\n+    GC.runFinalizers((cast(char*)(typeid(S1).xdtor))[0..1]);\n+    assert(dtorCount == 6);\n+    GC.free(blkinf.base);\n \n     // associative arrays\n     import rt.aaA : entryDtor;\n@@ -2590,36 +2573,27 @@ unittest\n     S1[int] aa1;\n     aa1[0] = S1(0);\n     aa1[1] = S1(1);\n-    if (callStructDtorsDuringGC)\n-    {\n-        dtorCount = 0;\n-        aa1 = null;\n-        GC.runFinalizers((cast(char*)(&entryDtor))[0..1]);\n-        assert(dtorCount == 2);\n-    }\n+    dtorCount = 0;\n+    aa1 = null;\n+    GC.runFinalizers((cast(char*)(&entryDtor))[0..1]);\n+    assert(dtorCount == 2);\n \n     int[S1] aa2;\n     aa2[S1(0)] = 0;\n     aa2[S1(1)] = 1;\n     aa2[S1(2)] = 2;\n-    if (callStructDtorsDuringGC)\n-    {\n-        dtorCount = 0;\n-        aa2 = null;\n-        GC.runFinalizers((cast(char*)(&entryDtor))[0..1]);\n-        assert(dtorCount == 3);\n-    }\n+    dtorCount = 0;\n+    aa2 = null;\n+    GC.runFinalizers((cast(char*)(&entryDtor))[0..1]);\n+    assert(dtorCount == 3);\n \n     S1[2][int] aa3;\n     aa3[0] = [S1(0),S1(2)];\n     aa3[1] = [S1(1),S1(3)];\n-    if (callStructDtorsDuringGC)\n-    {\n-        dtorCount = 0;\n-        aa3 = null;\n-        GC.runFinalizers((cast(char*)(&entryDtor))[0..1]);\n-        assert(dtorCount == 4);\n-    }\n+    dtorCount = 0;\n+    aa3 = null;\n+    GC.runFinalizers((cast(char*)(&entryDtor))[0..1]);\n+    assert(dtorCount == 4);\n }\n \n // test class finalizers exception handling\n@@ -2661,9 +2635,6 @@ unittest\n debug(SENTINEL) {} else\n unittest\n {\n-    if (!callStructDtorsDuringGC)\n-        return;\n-\n     bool test(E)()\n     {\n         import core.exception;"}, {"sha": "7c084abcaf109617d32d0d288203d52c4f076091", "filename": "libphobos/testsuite/libphobos.allocations/tls_gc_integration.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Ftestsuite%2Flibphobos.allocations%2Ftls_gc_integration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d56e6a737418b7b48a53b355f588ea14f1b9a9/libphobos%2Ftestsuite%2Flibphobos.allocations%2Ftls_gc_integration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Ftestsuite%2Flibphobos.allocations%2Ftls_gc_integration.d?ref=c1d56e6a737418b7b48a53b355f588ea14f1b9a9", "patch": "@@ -1,4 +1,4 @@\n-import core.memory, core.thread, core.bitop;\n+import core.memory, core.thread, core.volatile;\n \n /*\n  * This test repeatedly performs operations on GC-allocated objects which"}]}