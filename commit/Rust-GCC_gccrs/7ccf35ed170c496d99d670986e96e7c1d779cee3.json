{"sha": "7ccf35ed170c496d99d670986e96e7c1d779cee3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NjZjM1ZWQxNzBjNDk2ZDk5ZDY3MDk4NmU5NmU3YzFkNzc5Y2VlMw==", "commit": {"author": {"name": "Dorit Naishlos", "email": "dorit@il.ibm.com", "date": "2004-09-23T14:34:35Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2004-09-23T14:34:35Z"}, "message": "tree.def (ALIGN_INDIRECT_REF, [...]): New tree-codes.\n\n2004-09-23  Dorit Naishlos <dorit@il.ibm.com>\n\n        * tree.def (ALIGN_INDIRECT_REF, MISALIGNED_INDIRECT_REF):\n        New tree-codes.\n        * tree.h (REF_ORIGINAL): Consider ALIGN_INDIRECT_REF and\n        MISALIGNED_INDIRECT_REF.\n        * alias.c (get_alias_set, nonoverlapping_memrefs_p): Likewise.\n        * emit-rtl.c (mem_expr_equal_p, set_mem_attributes_minus_bitpos):\n        Likewise.\n        * expr.c (safe_from_p, expand_expr_real_1, rewrite_address_base)\n        (find_interesting_uses_address): Likewise.\n        * fold-const.c (non_lvalue, operand_equal_p): Likewise.\n        (build_fold_addr_expr_with_type): Likewise.\n        * gimplify.c (gimplify_addr_expr, gimplify_expr): Likewise.\n        * print-rtl.c (print_mem_expr): Likewise.\n        * tree-dump.c (dequeue_and_dump): Likewise.\n        * tree-eh.c (tree_could_trap_p): Likewise.\n        * tree-gimple.c (is_gimple_addressable, get_base_address): Likewise.\n        * tree-pretty-print.c (op_prio, op_symbol, dump_generic_node): Likewise.\n        * tree-ssa-alias.c (find_ptr_dereference, ptr_is_dereferenced_by):\n        Likewise.\n        * tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Likewise.\n        * tree-ssa-dom.c (record_equivalences_from_stmt): Likewise.\n        * tree-ssa-loop-im.c (for_each_index, is_call_clobbered_ref): Likewise.\n        * tree-ssa-loop-ivopts.c (find_interesting_uses_address): Likewise.\n        (add_address_candidates, rewrite_address_base): Likewise.\n        * tree-ssa-operands.c (get_expr_operands, get_indirect_ref_operands):\n        Likewise.\n        * tree.c (staticp, build1_stat): Likewise.\n\n        * tree.def (REALIGN_LOAD_EXPR, REALIGN_STORE_EXPR): New tree-codes.\n        * tree-pretty-print.c (dump_generic_node): Consider REALIGN_LOAD_EXPR.\n        * tree-ssa-operands.c (get_expr_operands): Likewise.\n        * expr.c (expand_expr_real_1): Likewise.\n\n        * optabs.h (vec_realign_store_optab, vec_realign_load_optab): New\n        optabs.\n        (OTI_vec_realign_store, OTI_vec_realign_load): New optab_index values\n        for the new optabs.\n        (expand_ternary_op): New function.\n        * genopinit.c (optabs): Handle the new optabs.\n        * optabs.c (optab_for_tree_code): Add cases for the new tree-codes.\n        (init_optabs): Initialize vec_realign_load_optab.\n        (expand_ternary_op): New functions.\n\n        * target-def.h (TARGET_VECTORIZE): New member for struct gcc_target.\n        (TARGET_VECTORIZE_MISALIGNED_MEM_OK): New member for targetm.vectorize.\n        (TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD): Likewise.\n        (TARGET_VECTORIZE_BUILTIN_MASK_FOR_STORE): Likewise.\n        * target.h (struct vectorize): New member for struct gcc_target.\n        (misaligned_mem_ok): New member for targetm.vectorize.\n        (builtin_mask_for_load): Likewise.\n        (builtin_mask_for_store): Likewise.\n        * targethooks.c (default_vect_misaligned_mem_ok): New function.\n        * targethooks.h (default_vect_misaligned_mem_ok): New function.\n\n        * config/rs6000/altivec.md (build_vector_mask_for_load): New\n        define_expand.\n        (vec_realign_load_v4si, vec_realign_load_v4sf, vec_realign_load_v8hi)\n        (vec_realign_load_v16qi): New define_insn.\n        * config/rs6000/rs6000.h (ALTIVEC_BUILTIN_MASK_FOR_LOAD):\n        (ALTIVEC_BUILTIN_MASK_FOR_STORE): New target builtins.\n        * config/rs6000/rs6000.c (altivec_builtin_mask_for_load):\n        (altivec_builtin_mask_for_store): New variables.\n        (rs6000_builtin_mask_for_load): New function. Implements\n        TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD.\n        (rs6000_builtin_mask_for_store): New function. Implements\n        TARGET_VECTORIZE_BUILTIN_MASK_FOR_STORE.\n        (rs6000_expand_builtin): Expand the target builtins\n        builtin_mask_for_load and builtin_mask_for_store.\n        (altivec_init_builtins): Initialize the new target builtins.\n        * config/i386/i386.c (ix86_misaligned_mem_ok): New function.\n        Implements the target hook TARGET_VECTORIZE_MISALIGNED_MEM_OK.\n\n        * tree-vectorizer.c (vect_create_data_ref): Renamed to\n        vect_create_data_ref_ptr. Returns a pointer instead of an array-ref.\n        (vect_create_addr_base_for_vector_ref): Additional argument (offset).\n        (vectorizable_store): Call vect_create_data_ref_ptr with additional\n        arguments, and create an indirect_ref with its return value data_ref.\n        Check aligned_access_p.\n        (vectorizable_load): Handle misaligned loads, using software-pipelined\n        scheme with REALIGN_LOAD_EXPR and ALIGN_INDIRECT_REF if\n        vec_realign_load_optab is supported, or using a scheme without\n        software-pipelining with MISALIGNED_INDIRECT_REF if the target hook\n        misaligned_mem_ok is supported.\n\n        (vect_finish_stmt_generation): Typo.\n        (vect_enhance_data_refs_alignment): Rename loop_vinfo to loop_info.\n        (vect_analyze_data_refs_alignment): Don't fail vectorization in the\n        presence of misaligned loads.\n        (vect_analyze_data_ref_access): Add check for constant init.\n        (vect_get_symbl_and_dr): Remove duplicate line.\n        * tree-vectorizer.h (DR_MISALIGNMENT): Add comment.\n\nFrom-SVN: r87948", "tree": {"sha": "5b0812849a44aab255ae7d9ac2f99b6111c1359c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b0812849a44aab255ae7d9ac2f99b6111c1359c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ccf35ed170c496d99d670986e96e7c1d779cee3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ccf35ed170c496d99d670986e96e7c1d779cee3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ccf35ed170c496d99d670986e96e7c1d779cee3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ccf35ed170c496d99d670986e96e7c1d779cee3/comments", "author": null, "committer": null, "parents": [{"sha": "d31012b7f85f77fa32fabc5cc19d8063376e83ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d31012b7f85f77fa32fabc5cc19d8063376e83ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d31012b7f85f77fa32fabc5cc19d8063376e83ae"}], "stats": {"total": 1565, "additions": 1398, "deletions": 167}, "files": [{"sha": "65f8c94af6c6568a31c1929321b15b6520255644", "filename": "gcc/ChangeLog", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,3 +1,97 @@\n+2004-09-23  Dorit Naishlos <dorit@il.ibm.com>\n+\n+        * tree.def (ALIGN_INDIRECT_REF, MISALIGNED_INDIRECT_REF):\n+        New tree-codes.\n+        * tree.h (REF_ORIGINAL): Consider ALIGN_INDIRECT_REF and\n+        MISALIGNED_INDIRECT_REF.\n+        * alias.c (get_alias_set, nonoverlapping_memrefs_p): Likewise.\n+        * emit-rtl.c (mem_expr_equal_p, set_mem_attributes_minus_bitpos):\n+        Likewise.\n+        * expr.c (safe_from_p, expand_expr_real_1, rewrite_address_base)\n+        (find_interesting_uses_address): Likewise.\n+        * fold-const.c (non_lvalue, operand_equal_p): Likewise.\n+        (build_fold_addr_expr_with_type): Likewise.\n+        * gimplify.c (gimplify_addr_expr, gimplify_expr): Likewise.\n+        * print-rtl.c (print_mem_expr): Likewise.\n+        * tree-dump.c (dequeue_and_dump): Likewise.\n+        * tree-eh.c (tree_could_trap_p): Likewise.\n+        * tree-gimple.c (is_gimple_addressable, get_base_address): Likewise.\n+        * tree-pretty-print.c (op_prio, op_symbol, dump_generic_node): Likewise.\n+        * tree-ssa-alias.c (find_ptr_dereference, ptr_is_dereferenced_by):\n+        Likewise.\n+        * tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Likewise.\n+        * tree-ssa-dom.c (record_equivalences_from_stmt): Likewise.\n+        * tree-ssa-loop-im.c (for_each_index, is_call_clobbered_ref): Likewise.\n+        * tree-ssa-loop-ivopts.c (find_interesting_uses_address): Likewise.\n+        (add_address_candidates, rewrite_address_base): Likewise.\n+        * tree-ssa-operands.c (get_expr_operands, get_indirect_ref_operands):\n+        Likewise.\n+        * tree.c (staticp, build1_stat): Likewise.\n+\n+        * tree.def (REALIGN_LOAD_EXPR, REALIGN_STORE_EXPR): New tree-codes.\n+        * tree-pretty-print.c (dump_generic_node): Consider REALIGN_LOAD_EXPR.\n+        * tree-ssa-operands.c (get_expr_operands): Likewise.\n+        * expr.c (expand_expr_real_1): Likewise.\n+\n+        * optabs.h (vec_realign_store_optab, vec_realign_load_optab): New\n+        optabs.\n+        (OTI_vec_realign_store, OTI_vec_realign_load): New optab_index values\n+        for the new optabs.\n+        (expand_ternary_op): New function.\n+        * genopinit.c (optabs): Handle the new optabs.\n+        * optabs.c (optab_for_tree_code): Add cases for the new tree-codes.\n+        (init_optabs): Initialize vec_realign_load_optab.\n+        (expand_ternary_op): New functions.\n+\n+        * target-def.h (TARGET_VECTORIZE): New member for struct gcc_target.\n+        (TARGET_VECTORIZE_MISALIGNED_MEM_OK): New member for targetm.vectorize.\n+        (TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD): Likewise.\n+        (TARGET_VECTORIZE_BUILTIN_MASK_FOR_STORE): Likewise.\n+        * target.h (struct vectorize): New member for struct gcc_target.\n+        (misaligned_mem_ok): New member for targetm.vectorize.\n+        (builtin_mask_for_load): Likewise.\n+        (builtin_mask_for_store): Likewise.\n+        * targethooks.c (default_vect_misaligned_mem_ok): New function.\n+        * targethooks.h (default_vect_misaligned_mem_ok): New function.\n+\n+        * config/rs6000/altivec.md (build_vector_mask_for_load): New\n+        define_expand.\n+        (vec_realign_load_v4si, vec_realign_load_v4sf, vec_realign_load_v8hi)\n+        (vec_realign_load_v16qi): New define_insn.\n+        * config/rs6000/rs6000.h (ALTIVEC_BUILTIN_MASK_FOR_LOAD):\n+        (ALTIVEC_BUILTIN_MASK_FOR_STORE): New target builtins.\n+        * config/rs6000/rs6000.c (altivec_builtin_mask_for_load):\n+        (altivec_builtin_mask_for_store): New variables.\n+        (rs6000_builtin_mask_for_load): New function. Implements\n+        TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD.\n+        (rs6000_builtin_mask_for_store): New function. Implements\n+        TARGET_VECTORIZE_BUILTIN_MASK_FOR_STORE.\n+        (rs6000_expand_builtin): Expand the target builtins\n+        builtin_mask_for_load and builtin_mask_for_store.\n+        (altivec_init_builtins): Initialize the new target builtins.\n+        * config/i386/i386.c (ix86_misaligned_mem_ok): New function.\n+        Implements the target hook TARGET_VECTORIZE_MISALIGNED_MEM_OK.\n+\n+        * tree-vectorizer.c (vect_create_data_ref): Renamed to\n+        vect_create_data_ref_ptr. Returns a pointer instead of an array-ref.\n+        (vect_create_addr_base_for_vector_ref): Additional argument (offset).\n+        (vectorizable_store): Call vect_create_data_ref_ptr with additional\n+        arguments, and create an indirect_ref with its return value data_ref.\n+        Check aligned_access_p.\n+        (vectorizable_load): Handle misaligned loads, using software-pipelined\n+        scheme with REALIGN_LOAD_EXPR and ALIGN_INDIRECT_REF if\n+        vec_realign_load_optab is supported, or using a scheme without\n+        software-pipelining with MISALIGNED_INDIRECT_REF if the target hook\n+        misaligned_mem_ok is supported.\n+\n+        (vect_finish_stmt_generation): Typo.\n+        (vect_enhance_data_refs_alignment): Rename loop_vinfo to loop_info.\n+        (vect_analyze_data_refs_alignment): Don't fail vectorization in the\n+        presence of misaligned loads.\n+        (vect_analyze_data_ref_access): Add check for constant init.\n+        (vect_get_symbl_and_dr): Remove duplicate line.\n+        * tree-vectorizer.h (DR_MISALIGNMENT): Add comment.\n+\n 2004-09-23  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* builtins.c: Fix a comment typo."}, {"sha": "e096cbf6bc3d5b654975e636e7906d5eec45c66d", "filename": "gcc/alias.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -450,7 +450,9 @@ get_alias_set (tree t)\n \t}\n \n       /* Check for accesses through restrict-qualified pointers.  */\n-      if (TREE_CODE (inner) == INDIRECT_REF)\n+      if (TREE_CODE (inner) == INDIRECT_REF\n+\t  || TREE_CODE (inner) == ALIGN_INDIRECT_REF\n+\t  || TREE_CODE (inner) == MISALIGNED_INDIRECT_REF)\n \t{\n \t  tree decl = find_base_decl (TREE_OPERAND (inner, 0));\n \n@@ -2006,7 +2008,9 @@ nonoverlapping_memrefs_p (rtx x, rtx y)\n       moffsetx = adjust_offset_for_component_ref (exprx, moffsetx);\n       exprx = t;\n     }\n-  else if (TREE_CODE (exprx) == INDIRECT_REF)\n+  else if (TREE_CODE (exprx) == INDIRECT_REF\n+\t   || TREE_CODE (exprx) == ALIGN_INDIRECT_REF\n+\t   || TREE_CODE (exprx) == MISALIGNED_INDIRECT_REF)\n     {\n       exprx = TREE_OPERAND (exprx, 0);\n       if (flag_argument_noalias < 2\n@@ -2023,7 +2027,9 @@ nonoverlapping_memrefs_p (rtx x, rtx y)\n       moffsety = adjust_offset_for_component_ref (expry, moffsety);\n       expry = t;\n     }\n-  else if (TREE_CODE (expry) == INDIRECT_REF)\n+  else if (TREE_CODE (expry) == INDIRECT_REF\n+           || TREE_CODE (expry) == ALIGN_INDIRECT_REF\n+           || TREE_CODE (expry) == MISALIGNED_INDIRECT_REF)\n     {\n       expry = TREE_OPERAND (expry, 0);\n       if (flag_argument_noalias < 2"}, {"sha": "de8411eb6635ec951cd78f3f6d060f76e86e772b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -868,6 +868,7 @@ static void ix86_expand_strlensi_unroll_1 (rtx, rtx, rtx);\n static int ix86_issue_rate (void);\n static int ix86_adjust_cost (rtx, rtx, rtx, int);\n static int ia32_multipass_dfa_lookahead (void);\n+static bool ix86_misaligned_mem_ok (enum machine_mode);\n static void ix86_init_mmx_sse_builtins (void);\n static rtx x86_this_parameter (tree);\n static void x86_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n@@ -1014,6 +1015,9 @@ static void init_ext_80387_constants (void);\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD \\\n   ia32_multipass_dfa_lookahead\n \n+#undef TARGET_VECTORIZE_MISALIGNED_MEM_OK\n+#define TARGET_VECTORIZE_MISALIGNED_MEM_OK ix86_misaligned_mem_ok\n+\n #undef TARGET_FUNCTION_OK_FOR_SIBCALL\n #define TARGET_FUNCTION_OK_FOR_SIBCALL ix86_function_ok_for_sibcall\n \n@@ -11616,6 +11620,17 @@ ia32_multipass_dfa_lookahead (void)\n }\n \n \f\n+/* Implement the target hook targetm.vectorize.misaligned_mem_ok.  */\n+\n+static bool\n+ix86_misaligned_mem_ok (enum machine_mode mode)\n+{\n+  if (TARGET_MMX && VALID_MMX_REG_MODE (mode))\n+    return true;\n+  else\n+    return false;\n+}\n+\n /* Compute the alignment given to a constant that is being placed in memory.\n    EXP is the constant and ALIGN is the alignment that the object would\n    ordinarily have."}, {"sha": "0eb29b1ea37b9c9eb6fb8acb63e4f7d23fd607c4", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1902,6 +1902,27 @@\n   \"lvsr %0,%y1\"\n   [(set_attr \"type\" \"vecload\")])\n \n+(define_expand \"build_vector_mask_for_load\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=v\")\n+\t(unspec:V16QI [(match_operand 1 \"memory_operand\" \"m\")] 195))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{ \n+  rtx addr;\n+  rtx temp;\n+\n+  if (GET_CODE (operands[1]) != MEM)\n+    abort ();\n+\n+  addr = XEXP (operands[1], 0);\n+  temp = gen_reg_rtx (GET_MODE (addr));\n+  emit_insn (gen_rtx_SET (VOIDmode, temp, \n+\t\t\t  gen_rtx_NEG (GET_MODE (addr), addr)));\n+  emit_insn (gen_altivec_lvsr (operands[0], \n+\t\t\t       gen_rtx_MEM (GET_MODE (operands[1]), temp)));\n+  DONE;\n+}\")\n+\n ;; Parallel some of the LVE* and STV*'s with unspecs because some have\n ;; identical rtl but different instructions-- and gcc gets confused.\n \n@@ -2062,3 +2083,40 @@\n   \"vspltisb %2,0\\;vsubsws %3,%2,%1\\;vmaxsw %0,%1,%3\"\n   [(set_attr \"type\" \"vecsimple\")\n    (set_attr \"length\" \"12\")])\n+\n+(define_insn \"vec_realign_load_v4si\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+        (unspec:V4SI [(match_operand:V4SI 1 \"register_operand\" \"v\")\n+                      (match_operand:V4SI 2 \"register_operand\" \"v\")\n+                      (match_operand:V16QI 3 \"register_operand\" \"v\")] 215))]\n+  \"TARGET_ALTIVEC\"\n+  \"vperm %0,%1,%2,%3\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+(define_insn \"vec_realign_load_v4sf\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n+        (unspec:V4SF [(match_operand:V4SF 1 \"register_operand\" \"v\")\n+                      (match_operand:V4SF 2 \"register_operand\" \"v\")\n+                      (match_operand:V16QI 3 \"register_operand\" \"v\")] 216))]\n+  \"TARGET_ALTIVEC\"\n+  \"vperm %0,%1,%2,%3\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+(define_insn \"vec_realign_load_v8hi\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n+        (unspec:V8HI [(match_operand:V8HI 1 \"register_operand\" \"v\")\n+                      (match_operand:V8HI 2 \"register_operand\" \"v\")\n+                      (match_operand:V16QI 3 \"register_operand\" \"v\")] 217))]\n+  \"TARGET_ALTIVEC\"\n+  \"vperm %0,%1,%2,%3\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+(define_insn \"vec_realign_load_v16qi\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=v\")\n+        (unspec:V16QI [(match_operand:V16QI 1 \"register_operand\" \"v\")\n+                      (match_operand:V16QI 2 \"register_operand\" \"v\")\n+                      (match_operand:V16QI 3 \"register_operand\" \"v\")] 218))]\n+  \"TARGET_ALTIVEC\"\n+  \"vperm %0,%1,%2,%3\"\n+  [(set_attr \"type\" \"vecperm\")])\n+"}, {"sha": "7f448ee0c4b8e07aa481955e28174b39cb58a6ab", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -143,6 +143,11 @@ enum rs6000_dependence_cost rs6000_sched_costly_dep;\n const char *rs6000_sched_insert_nops_str;\n enum rs6000_nop_insertion rs6000_sched_insert_nops;\n \n+/* Support targetm.vectorize.builtin_mask_for_load.  */\n+tree altivec_builtin_mask_for_load;\n+/* Support targetm.vectorize.builtin_mask_for_store.  */\n+tree altivec_builtin_mask_for_store;\n+\n /* Size of long double */\n const char *rs6000_long_double_size_string;\n int rs6000_long_double_type_size;\n@@ -681,6 +686,8 @@ static int redefine_groups (FILE *, int, rtx, rtx);\n static int pad_groups (FILE *, int, rtx, rtx);\n static void rs6000_sched_finish (FILE *, int);\n static int rs6000_use_sched_lookahead (void);\n+static tree rs6000_builtin_mask_for_load (void);\n+static tree rs6000_builtin_mask_for_store (void);\n \n static void rs6000_init_builtins (void);\n static rtx rs6000_expand_unop_builtin (enum insn_code, tree, rtx);\n@@ -905,6 +912,12 @@ static const char alt_reg_names[][8] =\n #undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD rs6000_use_sched_lookahead\n \n+#undef TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD\n+#define TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD rs6000_builtin_mask_for_load\n+\n+#undef TARGET_VECTORIZE_BUILTIN_MASK_FOR_STORE\n+#define TARGET_VECTORIZE_BUILTIN_MASK_FOR_STORE rs6000_builtin_mask_for_store\n+\n #undef TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS rs6000_init_builtins\n \n@@ -1536,6 +1549,26 @@ rs6000_override_options (const char *default_cpu)\n       }\n }\n \n+/* Implement targetm.vectorize.builtin_mask_for_load.  */\n+static tree\n+rs6000_builtin_mask_for_load (void)\n+{\n+  if (TARGET_ALTIVEC)\n+    return altivec_builtin_mask_for_load;\n+  else\n+    return 0;\n+}\n+\n+/* Implement targetm.vectorize.builtin_mask_for_store.  */\n+static tree\n+rs6000_builtin_mask_for_store (void)\n+{\n+  if (TARGET_ALTIVEC)\n+    return altivec_builtin_mask_for_store;\n+  else\n+    return 0;\n+}\n+\n /* Handle generic options of the form -mfoo=yes/no.\n    NAME is the option name.\n    VALUE is the option value.\n@@ -7202,6 +7235,48 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n   rtx ret;\n   bool success;\n \n+  if (fcode == ALTIVEC_BUILTIN_MASK_FOR_LOAD\n+      || fcode == ALTIVEC_BUILTIN_MASK_FOR_STORE)\n+    {\n+      int icode = (int) CODE_FOR_altivec_lvsr;\n+      enum machine_mode tmode = insn_data[icode].operand[0].mode;\n+      enum machine_mode mode = insn_data[icode].operand[1].mode;\n+      tree arg;\n+      rtx op, addr, pat;\n+\n+      if (!TARGET_ALTIVEC)\n+\tabort ();\n+\n+      arg = TREE_VALUE (arglist);\n+      if (TREE_CODE (TREE_TYPE (arg)) != POINTER_TYPE)\n+\tabort ();\n+      op = expand_expr (arg, NULL_RTX, Pmode, EXPAND_NORMAL);\n+      addr = memory_address (mode, op);\n+      if (fcode == ALTIVEC_BUILTIN_MASK_FOR_STORE)\n+\top = addr;\n+      else\n+\t{\n+\t  /* For the load case need to negate the address.  */\n+\t  op = gen_reg_rtx (GET_MODE (addr));\n+\t  emit_insn (gen_rtx_SET (VOIDmode, op,\n+\t\t\t gen_rtx_NEG (GET_MODE (addr), addr)));\n+        }\n+      op = gen_rtx_MEM (mode, op);\n+\n+      if (target == 0\n+\t  || GET_MODE (target) != tmode\n+\t  || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+\ttarget = gen_reg_rtx (tmode);\n+\n+      /*pat = gen_altivec_lvsr (target, op);*/\n+      pat = GEN_FCN (icode) (target, op);\n+      if (!pat)\n+\treturn 0;\n+      emit_insn (pat);\n+\n+      return target;\n+    }\n+\n   if (TARGET_ALTIVEC)\n     {\n       ret = altivec_expand_builtin (exp, target, &success);\n@@ -7691,6 +7766,9 @@ altivec_init_builtins (void)\n     = build_function_type_list (integer_type_node,\n \t\t\t\tpcchar_type_node, NULL_TREE);\n \n+  tree id;\n+  tree decl;\n+\n   def_builtin (MASK_ALTIVEC, \"__builtin_altivec_ld_internal_4sf\", v4sf_ftype_pcfloat,\n \t       ALTIVEC_BUILTIN_LD_INTERNAL_4sf);\n   def_builtin (MASK_ALTIVEC, \"__builtin_altivec_st_internal_4sf\", void_ftype_pfloat_v4sf,\n@@ -7792,6 +7870,24 @@ altivec_init_builtins (void)\n \n       def_builtin (d->mask, d->name, type, d->code);\n     }\n+\n+  /* Initialize target builtin that implements \n+     targetm.vectorize.builtin_mask_for_load.  */\n+  id = get_identifier (\"__builtin_altivec_mask_for_load\");\n+  decl = build_decl (FUNCTION_DECL, id, v16qi_ftype_long_pcvoid);\n+  DECL_BUILT_IN_CLASS (decl) = BUILT_IN_MD;\n+  DECL_FUNCTION_CODE (decl) = ALTIVEC_BUILTIN_MASK_FOR_LOAD;\n+  /* Record the decl. Will be used by rs6000_builtin_mask_for_load.  */\n+  altivec_builtin_mask_for_load = decl;\n+\n+  /* Initialize target builtin that implements \n+     targetm.vectorize.builtin_mask_for_store.  */\n+  id = get_identifier (\"__builtin_altivec_mask_for_store\");\n+  decl = build_decl (FUNCTION_DECL, id, v16qi_ftype_long_pcvoid);\n+  DECL_BUILT_IN_CLASS (decl) = BUILT_IN_MD;\n+  DECL_FUNCTION_CODE (decl) = ALTIVEC_BUILTIN_MASK_FOR_STORE;\n+  /* Record the decl. Will be used by rs6000_builtin_mask_for_store.  */\n+  altivec_builtin_mask_for_store = decl;\n }\n \n static void"}, {"sha": "399f2e22d607c9cb23c67d990a185634c8b25853", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -2822,6 +2822,8 @@ enum rs6000_builtins\n   ALTIVEC_BUILTIN_ABS_V8HI,\n   ALTIVEC_BUILTIN_ABS_V16QI,\n   ALTIVEC_BUILTIN_COMPILETIME_ERROR,\n+  ALTIVEC_BUILTIN_MASK_FOR_LOAD,\n+  ALTIVEC_BUILTIN_MASK_FOR_STORE,\n \n   /* SPE builtins.  */\n   SPE_BUILTIN_EVADDW,"}, {"sha": "2572b8564103c62263f073260b3917ca7b620e1f", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1485,7 +1485,9 @@ mem_expr_equal_p (tree expr1, tree expr2)\n       && mem_expr_equal_p (TREE_OPERAND (expr1, 1), /* field decl */\n \t\t\t   TREE_OPERAND (expr2, 1));\n   \n-  if (TREE_CODE (expr1) == INDIRECT_REF)\n+  if (TREE_CODE (expr1) == INDIRECT_REF\n+      || TREE_CODE (expr1) == ALIGN_INDIRECT_REF\n+      || TREE_CODE (expr1) == MISALIGNED_INDIRECT_REF)\n     return mem_expr_equal_p (TREE_OPERAND (expr1, 0),\n \t\t\t     TREE_OPERAND (expr2, 0));\n \n@@ -1546,8 +1548,19 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \n   /* We can set the alignment from the type if we are making an object,\n      this is an INDIRECT_REF, or if TYPE_ALIGN_OK.  */\n-  if (objectp || TREE_CODE (t) == INDIRECT_REF || TYPE_ALIGN_OK (type))\n+  if (objectp || TREE_CODE (t) == INDIRECT_REF \n+      || TREE_CODE (t) == ALIGN_INDIRECT_REF \n+      || TYPE_ALIGN_OK (type))\n     align = MAX (align, TYPE_ALIGN (type));\n+  else \n+    if (TREE_CODE (t) == MISALIGNED_INDIRECT_REF)\n+      {\n+\tif (integer_zerop (TREE_OPERAND (t, 1)))\n+\t  /* We don't know anything about the alignment.  */\n+\t  align = BITS_PER_UNIT;\n+\telse\n+\t  align = tree_low_cst (TREE_OPERAND (t, 1), 1);\n+      }\n \n   /* If the size is known, we can set that.  */\n   if (TYPE_SIZE_UNIT (type) && host_integerp (TYPE_SIZE_UNIT (type), 1))\n@@ -1672,7 +1685,9 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t\t the size we got from the type?  */\n \t    }\n \t  else if (flag_argument_noalias > 1\n-\t\t   && TREE_CODE (t2) == INDIRECT_REF\n+\t\t   && (TREE_CODE (t2) == INDIRECT_REF \n+\t\t       || TREE_CODE (t2) == ALIGN_INDIRECT_REF\n+\t\t       || TREE_CODE (t2) == MISALIGNED_INDIRECT_REF)\t\n \t\t   && TREE_CODE (TREE_OPERAND (t2, 0)) == PARM_DECL)\n \t    {\n \t      expr = t2;\n@@ -1683,7 +1698,9 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n       /* If this is a Fortran indirect argument reference, record the\n \t parameter decl.  */\n       else if (flag_argument_noalias > 1\n-\t       && TREE_CODE (t) == INDIRECT_REF\n+\t       && (TREE_CODE (t) == INDIRECT_REF\n+\t\t   || TREE_CODE (t) == ALIGN_INDIRECT_REF\n+\t\t   || TREE_CODE (t) == MISALIGNED_INDIRECT_REF)\n \t       && TREE_CODE (TREE_OPERAND (t, 0)) == PARM_DECL)\n \t{\n \t  expr = t;\n@@ -1701,6 +1718,14 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \tsize = plus_constant (size, apply_bitpos / BITS_PER_UNIT);\n     }\n \n+  if (TREE_CODE (t) == ALIGN_INDIRECT_REF)\n+    {\n+      /* Force EXPR and OFFSE to NULL, since we don't know exactly what\n+\t we're overlapping.  */\n+      offset = NULL;\n+      expr = NULL;\n+    }\n+\n   /* Now set the attributes we computed above.  */\n   MEM_ATTRS (ref)\n     = get_mem_attrs (alias, expr, offset, size, align, GET_MODE (ref));"}, {"sha": "96cab626f7b74b6b859befbb8cc2b5515e4b6e1b", "filename": "gcc/expr.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -5829,6 +5829,8 @@ safe_from_p (rtx x, tree exp, int top_p)\n \t    }\n \t  break;\n \n+\tcase MISALIGNED_INDIRECT_REF:\n+\tcase ALIGN_INDIRECT_REF:\n \tcase INDIRECT_REF:\n \t  if (MEM_P (x)\n \t      && alias_sets_conflict_p (MEM_ALIAS_SET (x),\n@@ -6745,11 +6747,17 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  return target;\n \t}\n \n+    case MISALIGNED_INDIRECT_REF:\n+    case ALIGN_INDIRECT_REF:\n     case INDIRECT_REF:\n       {\n \ttree exp1 = TREE_OPERAND (exp, 0);\n \ttree orig;\n \n+\tif (code == MISALIGNED_INDIRECT_REF\n+\t    && !targetm.vectorize.misaligned_mem_ok (mode))\n+\t  abort ();\n+\n \tif (modifier != EXPAND_WRITE)\n \t  {\n \t    tree t;\n@@ -6761,6 +6769,14 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n \top0 = expand_expr (exp1, NULL_RTX, VOIDmode, EXPAND_SUM);\n \top0 = memory_address (mode, op0);\n+\n+\tif (code == ALIGN_INDIRECT_REF)\n+\t  {\n+\t    int align = TYPE_ALIGN_UNIT (type);\n+\t    op0 = gen_rtx_AND (Pmode, op0, GEN_INT (-align));\n+\t    op0 = memory_address (mode, op0);\n+\t  }\n+\n \ttemp = gen_rtx_MEM (mode, op0);\n \n \torig = REF_ORIGINAL (exp);\n@@ -8203,6 +8219,24 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       return expand_expr_real (TREE_OPERAND (exp, 0), original_target, tmode,\n \t\t\t       modifier, alt_rtl);\n \n+    case REALIGN_LOAD_EXPR:\n+      {\n+        tree oprnd0 = TREE_OPERAND (exp, 0); \n+        tree oprnd1 = TREE_OPERAND (exp, 1);\n+        tree oprnd2 = TREE_OPERAND (exp, 2);\n+        rtx op2;\n+\n+        this_optab = optab_for_tree_code (code, type);\n+        expand_operands (oprnd0, oprnd1, NULL_RTX, &op0, &op1, 0);\n+        op2 = expand_expr (oprnd2, NULL_RTX, VOIDmode, 0);\n+        temp = expand_ternary_op (mode, this_optab, op0, op1, op2, \n+\t\t\t\t  target, unsignedp);\n+        if (temp == 0)\n+          abort ();\n+        return temp;\n+      }\n+\n+\n     default:\n       return lang_hooks.expand_expr (exp, original_target, tmode,\n \t\t\t\t     modifier, alt_rtl);"}, {"sha": "7049f4f94757b0fd14f8201626f60370c60844c8", "filename": "gcc/fold-const.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1990,6 +1990,8 @@ non_lvalue (tree x)\n \n   case COMPONENT_REF:\n   case INDIRECT_REF:\n+  case ALIGN_INDIRECT_REF:\n+  case MISALIGNED_INDIRECT_REF:\n   case ARRAY_REF:\n   case ARRAY_RANGE_REF:\n   case BIT_FIELD_REF:\n@@ -2466,6 +2468,8 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n       switch (TREE_CODE (arg0))\n \t{\n \tcase INDIRECT_REF:\n+\tcase ALIGN_INDIRECT_REF:\n+\tcase MISALIGNED_INDIRECT_REF:\n \tcase REALPART_EXPR:\n \tcase IMAGPART_EXPR:\n \t  return operand_equal_p (TREE_OPERAND (arg0, 0),\n@@ -10478,7 +10482,9 @@ build_fold_addr_expr_with_type (tree t, tree ptrtype)\n   if (TREE_CODE (t) == WITH_SIZE_EXPR)\n     t = TREE_OPERAND (t, 0);\n \n-  if (TREE_CODE (t) == INDIRECT_REF)\n+  /* Note: doesn't apply to ALIGN_INDIRECT_REF */\n+  if (TREE_CODE (t) == INDIRECT_REF\n+      || TREE_CODE (t) == MISALIGNED_INDIRECT_REF)\n     {\n       t = TREE_OPERAND (t, 0);\n       if (TREE_TYPE (t) != ptrtype)"}, {"sha": "0d39f67ef75ad2bddb753a93d983d31e8c9f8704", "filename": "gcc/genopinit.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -169,7 +169,9 @@ static const char * const optabs[] =\n   \"cmpmem_optab[$A] = CODE_FOR_$(cmpmem$a$)\",\n   \"vec_set_optab->handlers[$A].insn_code = CODE_FOR_$(vec_set$a$)\",\n   \"vec_extract_optab->handlers[$A].insn_code = CODE_FOR_$(vec_extract$a$)\",\n-  \"vec_init_optab->handlers[$A].insn_code = CODE_FOR_$(vec_init$a$)\" };\n+  \"vec_init_optab->handlers[$A].insn_code = CODE_FOR_$(vec_init$a$)\",\n+  \"vec_realign_store_optab->handlers[$A].insn_code = CODE_FOR_$(vec_realign_store_$a$)\",\n+  \"vec_realign_load_optab->handlers[$A].insn_code = CODE_FOR_$(vec_realign_load_$a$)\" };\n \n static void gen_insn (rtx);\n "}, {"sha": "27744bcb6893452f0f52b6f3e0cb626daa00fcb1", "filename": "gcc/gimplify.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -3052,6 +3052,7 @@ gimplify_addr_expr (tree *expr_p, tree *pre_p, tree *post_p)\n   switch (TREE_CODE (op0))\n     {\n     case INDIRECT_REF:\n+    case MISALIGNED_INDIRECT_REF:\n     do_indirect_ref:\n       /* Check if we are dealing with an expression of the form '&*ptr'.\n \t While the front end folds away '&*ptr' into 'ptr', these\n@@ -3642,6 +3643,8 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  recalculate_side_effects (*expr_p);\n \t  break;\n \n+\tcase ALIGN_INDIRECT_REF:\n+\tcase MISALIGNED_INDIRECT_REF:\n \tcase INDIRECT_REF:\n \t  ret = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n \t\t\t       is_gimple_reg, fb_rvalue);"}, {"sha": "abb69700a04a3f121f5da8dacfac0a0b5133fa84", "filename": "gcc/optabs.c", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -286,6 +286,12 @@ optab_for_tree_code (enum tree_code code, tree type)\n     case MIN_EXPR:\n       return TYPE_UNSIGNED (type) ? umin_optab : smin_optab;\n \n+    case REALIGN_STORE_EXPR:\n+      return vec_realign_store_optab;\n+\n+    case REALIGN_LOAD_EXPR:\n+      return vec_realign_load_optab;\n+\n     default:\n       break;\n     }\n@@ -313,6 +319,88 @@ optab_for_tree_code (enum tree_code code, tree type)\n     }\n }\n \f\n+\n+/* Generate code to perform an operation specified by TERNARY_OPTAB\n+   on operands OP0, OP1 and OP2, with result having machine-mode MODE.\n+\n+   UNSIGNEDP is for the case where we have to widen the operands\n+   to perform the operation.  It says to use zero-extension.\n+\n+   If TARGET is nonzero, the value\n+   is generated there, if it is convenient to do so.\n+   In all cases an rtx is returned for the locus of the value;\n+   this may or may not be TARGET.  */\n+\n+rtx\n+expand_ternary_op (enum machine_mode mode, optab ternary_optab, rtx op0, \n+\t\t   rtx op1, rtx op2, rtx target, int unsignedp) \n+{\n+  int icode = (int) ternary_optab->handlers[(int) mode].insn_code;\n+  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n+  enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n+  enum machine_mode mode2 = insn_data[icode].operand[3].mode;\n+  rtx temp;\n+  rtx pat;\n+  rtx xop0 = op0, xop1 = op1, xop2 = op2;\n+\n+  if (ternary_optab->handlers[(int) mode].insn_code == CODE_FOR_nothing)\n+    abort ();\n+\n+  if (!target\n+      || ! (*insn_data[icode].operand[0].predicate) (target, mode))\n+    temp = gen_reg_rtx (mode);\n+  else\n+    temp = target;\n+\n+  /* In case the insn wants input operands in modes different from\n+     those of the actual operands, convert the operands.  It would\n+     seem that we don't need to convert CONST_INTs, but we do, so\n+     that they're properly zero-extended, sign-extended or truncated\n+     for their mode.  */\n+\n+  if (GET_MODE (op0) != mode0 && mode0 != VOIDmode)\n+    xop0 = convert_modes (mode0,\n+                          GET_MODE (op0) != VOIDmode\n+                          ? GET_MODE (op0) \n+                          : mode,\n+                          xop0, unsignedp);\n+\n+  if (GET_MODE (op1) != mode1 && mode1 != VOIDmode)\n+    xop1 = convert_modes (mode1,\n+                          GET_MODE (op1) != VOIDmode\n+                          ? GET_MODE (op1)\n+                          : mode,\n+                          xop1, unsignedp);\n+\n+  if (GET_MODE (op2) != mode2 && mode2 != VOIDmode)\n+    xop2 = convert_modes (mode2,\n+                          GET_MODE (op2) != VOIDmode\n+                          ? GET_MODE (op2)\n+                          : mode,\n+                          xop2, unsignedp);\n+\n+  /* Now, if insn's predicates don't allow our operands, put them into\n+     pseudo regs.  */\n+  \n+  if (! (*insn_data[icode].operand[1].predicate) (xop0, mode0)\n+      && mode0 != VOIDmode) \n+    xop0 = copy_to_mode_reg (mode0, xop0);\n+  \n+  if (! (*insn_data[icode].operand[2].predicate) (xop1, mode1)\n+      && mode1 != VOIDmode)\n+    xop1 = copy_to_mode_reg (mode1, xop1);\n+    \n+  if (! (*insn_data[icode].operand[3].predicate) (xop2, mode2)\n+      && mode2 != VOIDmode)\n+    xop2 = copy_to_mode_reg (mode2, xop2);\n+    \n+  pat = GEN_FCN (icode) (temp, xop0, xop1, xop2);\n+    \n+  emit_insn (pat);\n+  return temp; \n+}\n+\n+\n /* Like expand_binop, but return a constant rtx if the result can be\n    calculated at compile time.  The arguments and return value are\n    otherwise the same as for expand_binop.  */\n@@ -4657,6 +4745,8 @@ init_optabs (void)\n   vec_extract_optab = init_optab (UNKNOWN);\n   vec_set_optab = init_optab (UNKNOWN);\n   vec_init_optab = init_optab (UNKNOWN);\n+  vec_realign_load_optab = init_optab (UNKNOWN);\n+\n   /* Conversions.  */\n   sext_optab = init_convert_optab (SIGN_EXTEND);\n   zext_optab = init_convert_optab (ZERO_EXTEND);"}, {"sha": "8e895f203c5b48562a0e4caf21d90b5192630f55", "filename": "gcc/optabs.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -228,6 +228,10 @@ enum optab_index\n   OTI_vec_extract,\n   /* Initialize vector operand.  */\n   OTI_vec_init,\n+  /* Extract specified elements from vectors, for vector store.  */\n+  OTI_vec_realign_store,\n+  /* Extract specified elements from vectors, for vector load.  */\n+  OTI_vec_realign_load,\n \n   OTI_MAX\n };\n@@ -330,6 +334,8 @@ extern GTY(()) optab optab_table[OTI_MAX];\n #define vec_set_optab (optab_table[OTI_vec_set])\n #define vec_extract_optab (optab_table[OTI_vec_extract])\n #define vec_init_optab (optab_table[OTI_vec_init])\n+#define vec_realign_store_optab (optab_table[OTI_vec_realign_store])\n+#define vec_realign_load_optab (optab_table[OTI_vec_realign_load])\n \n /* Conversion optabs have their own table and indexes.  */\n enum convert_optab_index\n@@ -405,6 +411,10 @@ extern enum insn_code cmpmem_optab[NUM_MACHINE_MODES];\n \n /* Define functions given in optabs.c.  */\n \n+extern rtx expand_ternary_op (enum machine_mode mode, optab ternary_optab, \n+\t\t\t      rtx op0, rtx op1, rtx op2, rtx target, \n+\t\t\t      int unsignedp);\n+\n /* Expand a binary operation given optab and rtx operands.  */\n extern rtx expand_binop (enum machine_mode, optab, rtx, rtx, rtx, int,\n \t\t\t enum optab_methods);"}, {"sha": "32ef01c88442b8cffa2ab81a0b264e260be52f41", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -102,6 +102,18 @@ print_mem_expr (FILE *outfile, tree expr)\n       print_mem_expr (outfile, TREE_OPERAND (expr, 0));\n       fputs (\")\", outfile);\n     }\n+  else if (TREE_CODE (expr) == ALIGN_INDIRECT_REF)\n+    {\n+      fputs (\" (A*\", outfile);\n+      print_mem_expr (outfile, TREE_OPERAND (expr, 0));\n+      fputs (\")\", outfile);\n+    }\n+  else if (TREE_CODE (expr) == MISALIGNED_INDIRECT_REF)\n+    {\n+      fputs (\" (M*\", outfile);\n+      print_mem_expr (outfile, TREE_OPERAND (expr, 0));\n+      fputs (\")\", outfile);\n+    }\n   else if (TREE_CODE (expr) == RESULT_DECL)\n     fputs (\" <result>\", outfile);\n   else"}, {"sha": "61adf14325a1350969b2755069fbe0710da170aa", "filename": "gcc/target-def.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -273,6 +273,17 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n    TARGET_SCHED_DFA_NEW_CYCLE,\t\t\t\t\t\\\n    TARGET_SCHED_IS_COSTLY_DEPENDENCE}\n \n+#ifndef TARGET_VECTORIZE_MISALIGNED_MEM_OK\n+#define TARGET_VECTORIZE_MISALIGNED_MEM_OK default_vect_misaligned_mem_ok\n+#endif\n+#define TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD 0\n+#define TARGET_VECTORIZE_BUILTIN_MASK_FOR_STORE 0\n+\n+#define TARGET_VECTORIZE                                                \\\n+  {TARGET_VECTORIZE_MISALIGNED_MEM_OK,                                  \\\n+   TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD,\t\t\t\t\\\n+   TARGET_VECTORIZE_BUILTIN_MASK_FOR_STORE}\n+\n /* In except.c */\n #define TARGET_EH_RETURN_FILTER_MODE  default_eh_return_filter_mode\n \n@@ -466,6 +477,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n {\t\t\t\t\t\t\\\n   TARGET_ASM_OUT,\t\t\t\t\\\n   TARGET_SCHED,\t\t\t\t\t\\\n+  TARGET_VECTORIZE,\t\t\t\t\\\n   TARGET_EH_RETURN_FILTER_MODE,\t\t\t\\\n   TARGET_MERGE_DECL_ATTRIBUTES,\t\t\t\\\n   TARGET_MERGE_TYPE_ATTRIBUTES,\t\t\t\\"}, {"sha": "9f766ae18dd2ec27753d05136cdca8a34f6d25c0", "filename": "gcc/target.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -282,6 +282,23 @@ struct gcc_target\n     bool (* is_costly_dependence) (rtx, rtx, rtx, int, int);\n   } sched;\n \n+  /* Functions relating to vectorization.  */\n+  struct vectorize\n+  {\n+    /* The following member value is a pointer to a function called\n+       by the vectorizer, and when expanding a MISALIGNED_INDIREC_REF\n+       expression.  If the hook returns true (false) then a move* pattern\n+       to/from memory can (cannot) be generated for this mode even if the\n+       memory location is unaligned.  */\n+    bool (* misaligned_mem_ok) (enum machine_mode);\n+\n+    /* The following member values are pointers to functions called\n+       by the vectorizer, and return the decl of the target builtin\n+       function.  */\n+    tree (* builtin_mask_for_load) (void);\n+    tree (* builtin_mask_for_store) (void);\n+  } vectorize;\n+\n   /* Return machine mode for filter value.  */\n   enum machine_mode (* eh_return_filter_mode) (void);\n "}, {"sha": "48690a130cf886ce1ba197fa67a4d7b89f1e9f43", "filename": "gcc/targhooks.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -268,6 +268,12 @@ default_scalar_mode_supported_p (enum machine_mode mode)\n     }\n }\n \n+bool\n+default_vect_misaligned_mem_ok (enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return !STRICT_ALIGNMENT;\n+}\n+\n bool\n hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false (\n \tCUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,"}, {"sha": "024a0808e0bc8e05a3b6b492db21616fbee417dc", "filename": "gcc/targhooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -47,6 +47,8 @@ extern void default_unwind_emit (FILE *, rtx);\n \n extern bool default_scalar_mode_supported_p (enum machine_mode);\n \n+extern bool default_vect_misaligned_mem_ok (enum machine_mode);\n+\n /* These are here, and not in hooks.[ch], because not all users of\n    hooks.h include tm.h, and thus we don't have CUMULATIVE_ARGS.  */\n "}, {"sha": "536ccf5cef8f6a3a6dab9299b9c482e475ca3d18", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,3 +1,38 @@\n+2004-09-23  Dorit Naishlos <dorit@il.ibm.com>\n+\n+        * gcc.dg/vect/vect-27.c: Now vectorized on altivec.\n+        * gcc.dg/vect/vect-29.c: Now vectorized on altivec.\n+        * gcc.dg/vect/vect-48.c: Now vectorized on altivec.\n+        * gcc.dg/vect/vect-56.c: Now vectorized on altivec.\n+        * gcc.dg/vect/vect-72.c: New test for altivec and sse2.\n+        * gcc.dg/vect/vect-77.c: Now vectorized on altivec.\n+\n+        * gcc.dg/vect/vect-27a.c: New test for altivec and mmx.\n+        * gcc.dg/vect/vect-29a.c: New test for altivec and mmx.\n+        * gcc.dg/vect/vect-48a.c: New test for altivec and mmx.\n+        * gcc.dg/vect/vect-56a.c: New test for altivec and mmx.\n+        * gcc.dg/vect/vect-72a.c: New test for altivec and mmx.\n+        * gcc.dg/vect/vect-77a.c: New test for altivec and mmx.\n+\n+        * gcc.dg/vect/vect-13.c: Change to run test instead of compile.\n+\n+        * gcc.dg/vect/vect-44.c: Check additional cases.\n+        * gcc.dg/vect/vect-48.c: Check additional cases.\n+\n+        * gcc.dg/vect/vect-26.c: Use sse2 instead of sse.\n+        * gcc.dg/vect/vect-27.c: Use sse2 instead of sse.\n+        * gcc.dg/vect/vect-28.c: Use sse2 instead of sse.\n+        * gcc.dg/vect/vect-29.c: Use sse2 instead of sse.\n+        * gcc.dg/vect/vect-4?.c: Use sse2 instead of sse.\n+        * gcc.dg/vect/vect-75.c: Use sse2 instead of sse.\n+        * gcc.dg/vect/vect-76.c: Use sse2 instead of sse.\n+        * gcc.dg/vect/vect-77.c: Use sse2 instead of sse.\n+        * gcc.dg/vect/vect-78.c: Use sse2 instead of sse.\n+\n+        * gcc.dg/vect/vect-5?.c: Use sse2 instead of sse. Add return 0.\n+        * gcc.dg/vect/vect-60.c: Use sse2 instead of sse. Add return 0.\n+        * gcc.dg/vect/vect-61.c: Use sse2 instead of sse. Add return 0.\n+\n 2004-09-23  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* gcc.dg/tree-ssa/loop-6.c: New test."}, {"sha": "052abe12d182389462de1225bc950f0c178635a2", "filename": "gcc/testsuite/gcc.dg/vect/vect-13.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-13.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,25 +1,41 @@\n-/* { dg-do compile { target powerpc*-*-* i?86-*-* x86_64-*-* } } */\n+/* { dg-do run { target powerpc*-*-* i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n \n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n \n #define N 16\n \n int a[N];\n int results[N] = {0,1,2,3,0,0,0,0,0,0,0,0,12,13,14,15};\n \n-int main ()\n+int main1()\n {\n   int i;\n   int b[N] = {0,1,2,3,-4,-5,-6,-7,-8,-9,-10,-11,12,13,14,15};\n \n-  /* Not vectorizable yet (condition in loop).  */\n+  /* Max pattern.  */\n   for (i = 0; i < N; i++)\n     {\n       a[i] = (b[i] >= 0 ? b[i] : 0);\n     }\n \n+  /* Check results  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (a[i] != results[i])\n+\tabort ();\n+    }\n+\n   return 0;\n }\n \n+int main (void)\n+{\n+  check_vect ();\n+\n+  return main1 ();\n+}\n+\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail i?86-*-* x86_64-*-* } } } */"}, {"sha": "fd21beddb782792ea7e83cd162a27a0760cc9120", "filename": "gcc/testsuite/gcc.dg/vect/vect-26.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-26.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\""}, {"sha": "d2e8c9445599fa0f7ee209ef4c44f2f95d850291", "filename": "gcc/testsuite/gcc.dg/vect/vect-27.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-27.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\"\n@@ -43,5 +43,5 @@ int main (void)\n   return main1 ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail i?86-*-* x86_64-*-* } } } */\n "}, {"sha": "9dd75498676b06cde745a91a6326ac5eec674ce5", "filename": "gcc/testsuite/gcc.dg/vect/vect-27a.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-27a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-27a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-27a.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do run { target powerpc*-*-* } } */\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -mmmx\" { target i?86-*-* x86_64-*-* } } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128\n+\n+/* unaligned load.  */\n+\n+int main1 ()\n+{\n+  int i;\n+  int ia[N];\n+  int ib[N+1];\n+\n+  for (i=0; i < N; i++)\n+    {\n+      ib[i] = i;\n+    }\n+\n+  for (i = 1; i <= N; i++)\n+    {\n+      ia[i-1] = ib[i];\n+    }\n+\n+  /* check results:  */\n+  for (i = 1; i <= N; i++)\n+    {\n+      if (ia[i-1] != ib[i])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+"}, {"sha": "cb8d7cb0c76592d546bc1e632b0b908fc573a9ed", "filename": "gcc/testsuite/gcc.dg/vect/vect-28.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-28.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\""}, {"sha": "c0383c7c8a63e08916b9a9ab56fac1470157b6ac", "filename": "gcc/testsuite/gcc.dg/vect/vect-29.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-29.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\"\n@@ -46,5 +46,5 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail i?86-*-* x86_64-*-* } } } */\n "}, {"sha": "13cd5c9d3f24d34bd5e000cb5ab81feaf28f3447", "filename": "gcc/testsuite/gcc.dg/vect/vect-29a.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-29a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-29a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-29a.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do run { target powerpc*-*-* } } */\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -mmmx\" { target i?86-*-* x86_64-*-* } } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128\n+#define OFF 3\n+\n+/* unaligned load.  */\n+\n+int main1 (int off)\n+{\n+  int i;\n+  int ia[N];\n+  int ib[N+OFF];\n+\n+  for (i = 0; i < N+OFF; i++)\n+    {\n+      ib[i] = i;\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      ia[i] = ib[i+off];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (ia[i] != ib[i+off])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  main1 (0); /* aligned */\n+  main1 (OFF); /* unaligned */\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+"}, {"sha": "2507575ba13c5d98e4d2bf196e2b85d4df48794e", "filename": "gcc/testsuite/gcc.dg/vect/vect-40.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-40.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-40.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-40.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n   \n #include <stdarg.h>\n #include \"tree-vect.h\""}, {"sha": "f54258fab3cc387816944dd35997c3e861956e68", "filename": "gcc/testsuite/gcc.dg/vect/vect-41.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-41.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-41.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-41.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n   \n #include <stdarg.h>\n #include \"tree-vect.h\""}, {"sha": "9d40a37113aa109e307e200a9e204daa1de8c9ad", "filename": "gcc/testsuite/gcc.dg/vect/vect-42.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-42.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-42.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-42.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n   \n #include <stdarg.h>\n #include \"tree-vect.h\""}, {"sha": "eedef268bd517e4cfa697d60e384d76fe89e752c", "filename": "gcc/testsuite/gcc.dg/vect/vect-43.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-43.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-43.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-43.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n   \n #include <stdarg.h>\n #include \"tree-vect.h\""}, {"sha": "8aab2fe07e136c0249cdd9fa121837c6e9cad526", "filename": "gcc/testsuite/gcc.dg/vect/vect-44.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-44.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-44.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-44.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,13 +1,14 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n   \n #include <stdarg.h>\n #include \"tree-vect.h\"\n \n #define N 256\n \n+typedef float afloat __attribute__ ((__aligned__(16)));\n \n void bar (float *pa, float *pb, float *pc) \n {\n@@ -42,13 +43,17 @@ main1 (float * __restrict__ pa, float * __restrict__ pb, float * __restrict__ pc\n int main (void)\n {\n   int i;\n-  float a[N];\n-  float b[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57};\n-  float c[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};\n+  afloat a[N+4];\n+  afloat b[N+4] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69};\n+  afloat c[N+4] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23};\n \n   check_vect ();\n \n   main1 (a,b,c);\n+  main1 (&a[1],b,c);\n+  main1 (a,&b[1],c);\n+  main1 (&a[1],&b[1],&c[1]);\n+\n   return 0;\n }\n "}, {"sha": "bc5d5c843cb199b2e54cfe3fd9c494fcf7417058", "filename": "gcc/testsuite/gcc.dg/vect/vect-45.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-45.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-45.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-45.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n   \n #include <stdarg.h>\n #include \"tree-vect.h\""}, {"sha": "7710c039d50bfddf62b96edbc23913883e5416da", "filename": "gcc/testsuite/gcc.dg/vect/vect-46.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-46.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-46.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-46.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\""}, {"sha": "ccbcccf880de7ccec7a6ea46488e8336faff51d4", "filename": "gcc/testsuite/gcc.dg/vect/vect-47.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-47.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-47.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-47.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\""}, {"sha": "3dfdb9579376505ba7be679ad891190f4fcb6826", "filename": "gcc/testsuite/gcc.dg/vect/vect-48.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-48.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-48.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-48.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n   \n #include <stdarg.h>\n #include \"tree-vect.h\"\n@@ -43,14 +43,16 @@ main1 (afloat * __restrict__ pa, float * __restrict__ pb, float * __restrict__ p\n int main (void)\n {\n   int i;\n-  float a[N];\n-  float b[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57};\n-  float c[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};\n+  afloat a[N];\n+  afloat b[N+1] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60};\n+  afloat c[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};\n \n   check_vect ();\n \n   main1 (a,b,c);\n+  main1 (a,&b[1],c);\n+\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail i?86-*-* x86_64-*-* } } } */"}, {"sha": "0422edcbf6bf4d4bcf4c7a975317a59b02548dbe", "filename": "gcc/testsuite/gcc.dg/vect/vect-48a.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-48a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-48a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-48a.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do run { target powerpc*-*-* } } */\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -mmmx\" { target i?86-*-* x86_64-*-* } } */\n+  \n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 256\n+\n+typedef short ashort __attribute__ ((__aligned__(16)));\n+\n+void bar (short *pa, short *pb, short *pc) \n+{\n+  int i;\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (pa[i] != (pb[i] + pc[i]))\n+\tabort ();\n+    }\n+\n+  return;\n+}\n+\n+\n+int\n+main1 (ashort * __restrict__ pa, short * __restrict__ pb, short * __restrict__ pc)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      pa[i] = pb[i] + pc[i];\n+    }\n+\n+  bar (pa,pb,pc);\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  ashort a[N];\n+  ashort b[N+1] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60};\n+  ashort c[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};\n+\n+  check_vect ();\n+\n+  main1 (a,b,c);\n+  main1 (a,&b[1],c);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "6a2669956a73df989d2af4aaddf6da2638cb37d5", "filename": "gcc/testsuite/gcc.dg/vect/vect-49.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-49.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-49.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-49.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n   \n #include <stdarg.h>\n #include \"tree-vect.h\""}, {"sha": "3b952a3a6c11237c8674e9d4a7341bd29dd59236", "filename": "gcc/testsuite/gcc.dg/vect/vect-50.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-50.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-50.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-50.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n   \n #include <stdarg.h>\n #include \"tree-vect.h\"\n@@ -49,6 +49,7 @@ int main (void)\n   check_vect ();\n \n   main1 (N,a,b,c);\n+  return 0;\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */"}, {"sha": "7804a4c8e8f17c246d117fcd110022c2dc442b8c", "filename": "gcc/testsuite/gcc.dg/vect/vect-51.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-51.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-51.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-51.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n   \n #include <stdarg.h>\n #include \"tree-vect.h\"\n@@ -49,6 +49,7 @@ int main (void)\n   check_vect ();\n \n   main1 (N,a,b,c);\n+  return 0;\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */"}, {"sha": "60d9b79629600883af326334b26c978aa5327b69", "filename": "gcc/testsuite/gcc.dg/vect/vect-52.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-52.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-52.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-52.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n   \n #include <stdarg.h>\n #include \"tree-vect.h\"\n@@ -51,6 +51,7 @@ int main (void)\n \n   main1 (N,a,&b[1],c);\n   main1 (N,a,&b[1],&c[1]);\n+  return 0;\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */"}, {"sha": "e8f17472be0f3c8928dd66a1aa5e5cd782699b47", "filename": "gcc/testsuite/gcc.dg/vect/vect-53.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-53.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-53.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-53.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n   \n #include <stdarg.h>\n #include \"tree-vect.h\"\n@@ -51,6 +51,7 @@ int main (void)\n \n   main1 (N,a,&b[1],c);\n   main1 (N,a,&b[1],&c[1]);\n+  return 0;\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */"}, {"sha": "172feae8d67797cee6c91b667aef018a9023246c", "filename": "gcc/testsuite/gcc.dg/vect/vect-54.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-54.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-54.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-54.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\"\n@@ -50,6 +50,7 @@ int main (void)\n   check_vect ();\n \n   main1 (a,b,c);\n+  return 0;\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */"}, {"sha": "e5c4ba2dbc2a0b7006cef27483c8cdaf46003ba8", "filename": "gcc/testsuite/gcc.dg/vect/vect-55.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-55.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-55.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-55.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\"\n@@ -50,6 +50,7 @@ int main (void)\n   check_vect ();\n \n   main1 (a,b,c);\n+  return 0;\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */"}, {"sha": "9170e49cd2fc2a12a1c27c3b70e49199feef06e8", "filename": "gcc/testsuite/gcc.dg/vect/vect-56.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-56.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-56.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-56.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\"\n@@ -50,6 +50,7 @@ int main (void)\n   check_vect ();\n \n   main1 (a,b,c);\n+  return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail i?86-*-* x86_64-*-* } } } */"}, {"sha": "5d8ed115f18d649453a3f6b5cc4f11aebaaf58e0", "filename": "gcc/testsuite/gcc.dg/vect/vect-56a.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-56a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-56a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-56a.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do run { target powerpc*-*-* } } */\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -mmmx\" { target i?86-*-* x86_64-*-* } } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 256\n+\n+typedef short ashort __attribute__ ((__aligned__(16)));\n+\n+void bar (ashort *pa, ashort *pb, ashort *pc)\n+{\n+  int i;\n+\n+  /* check results:  */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      if (pa[i] != (pb[i+1] + pc[i+1]))\n+\tabort ();\n+    }\n+\n+  return;\n+}\n+\n+\n+int\n+main1 (ashort * __restrict__ pa, ashort * __restrict__ pb, ashort * __restrict__ pc)\n+{\n+  int i;\n+\n+  for (i = 0; i < N/2; i++)\n+    {\n+      pa[i] = pb[i+1] + pc[i+1];\n+    }\n+\n+  bar (pa,pb,pc);\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  ashort a[N];\n+  ashort b[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57};\n+  ashort c[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};\n+\n+  check_vect ();\n+\n+  main1 (a,b,c);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "ce2e74089a4617c464f1a028a6cfd35a19efb7cf", "filename": "gcc/testsuite/gcc.dg/vect/vect-57.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-57.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-57.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-57.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\"\n@@ -50,6 +50,7 @@ int main (void)\n   check_vect ();\n \n   main1 (a,b,c);\n+  return 0;\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */"}, {"sha": "c080c909d1b094a533373cf8c3685086e1ec0f1c", "filename": "gcc/testsuite/gcc.dg/vect/vect-58.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-58.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-58.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-58.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\"\n@@ -51,6 +51,7 @@ int main (void)\n   check_vect ();\n \n   main1 (n,a,b,c);\n+  return 0;\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */"}, {"sha": "4bdd7b401a00d8a82618197ea09374f896d4cec6", "filename": "gcc/testsuite/gcc.dg/vect/vect-59.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-59.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-59.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-59.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\"\n@@ -51,6 +51,7 @@ int main (void)\n   check_vect ();\n \n   main1 (n,a,b,c);\n+  return 0;\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */"}, {"sha": "e19d36e8fef7767787be69ad297ddc498ee22bd7", "filename": "gcc/testsuite/gcc.dg/vect/vect-60.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-60.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-60.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-60.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,8 @@\n+\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\"\n@@ -51,6 +52,7 @@ int main (void)\n   check_vect ();\n \n   main1 (n,a,b,c);\n+  return 0;\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */"}, {"sha": "6df22a61c40569e365f5563bc5f8edb987645288", "filename": "gcc/testsuite/gcc.dg/vect/vect-61.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-61.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-61.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-61.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\"\n@@ -51,6 +51,7 @@ int main (void)\n   check_vect ();\n \n   main1 (n,a,b,c);\n+  return 0;\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */"}, {"sha": "1a2ad070963d8f958347c81ce8594d3838c73c9c", "filename": "gcc/testsuite/gcc.dg/vect/vect-72.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-72.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-72.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-72.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do run { target powerpc*-*-* } } */\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128\n+\n+/* unaligned load.  */\n+\n+int main1 ()\n+{\n+  int i;\n+  char ia[N];\n+  char ib[N+1];\n+\n+  for (i=0; i < N+1; i++)\n+    {\n+      ib[i] = i;\n+    }\n+\n+  for (i = 1; i < N+1; i++)\n+    {\n+      ia[i-1] = ib[i];\n+    }\n+\n+  /* check results:  */\n+  for (i = 1; i <= N; i++)\n+    {\n+      if (ia[i-1] != ib[i])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail i?86-*-* x86_64-*-* } } } */\n+"}, {"sha": "71fda70badc5a51da9380289fdb73762a0e1ff83", "filename": "gcc/testsuite/gcc.dg/vect/vect-72a.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-72a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-72a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-72a.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do run { target powerpc*-*-* } } */\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -mmmx\" { target i?86-*-* x86_64-*-* } } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128\n+\n+/* unaligned load.  */\n+\n+int main1 ()\n+{\n+  int i;\n+  char ia[N];\n+  char ib[N+1];\n+\n+  for (i=0; i < N+1; i++)\n+    {\n+      ib[i] = i;\n+    }\n+\n+  for (i = 1; i < N+1; i++)\n+    {\n+      ia[i-1] = ib[i];\n+    }\n+\n+  /* check results:  */\n+  for (i = 1; i <= N; i++)\n+    {\n+      if (ia[i-1] != ib[i])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+"}, {"sha": "f5fee582d2dc6a244e90a00cd285ba4ca6b1df19", "filename": "gcc/testsuite/gcc.dg/vect/vect-75.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-75.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-75.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-75.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\""}, {"sha": "17d6ff7b52f3b7e897cb196af6d81d4da56f226c", "filename": "gcc/testsuite/gcc.dg/vect/vect-76.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-76.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-76.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-76.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\""}, {"sha": "9f5697d60352ed6b52d5bbe83f84c7881555bd78", "filename": "gcc/testsuite/gcc.dg/vect/vect-77.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-77.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-77.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-77.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\"\n@@ -43,5 +43,5 @@ int main (void)\n }\n \n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail i?86-*-* x86_64-*-* } } } */\n "}, {"sha": "afa0c494d3bf6e26370baff07e605505e1c5c2b0", "filename": "gcc/testsuite/gcc.dg/vect/vect-77a.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-77a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-77a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-77a.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do run { target powerpc*-*-* } } */\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -mmmx\" { target i?86-*-* x86_64-*-* } } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8\n+#define OFF 8\n+\n+typedef int aint __attribute__ ((__aligned__(16)));\n+\n+aint ib[N+OFF] = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10, 14, 22, 26, 34};\n+\n+int main1 (aint *ib, int off)\n+{\n+  int i;\n+  int ia[N];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      ia[i] = ib[i+off];\n+    }\n+\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+     if (ia[i] != ib[i+off])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (ib, 8);\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+"}, {"sha": "75ad3c2984380e773629d1cc4bd125214066d7e6", "filename": "gcc/testsuite/gcc.dg/vect/vect-78.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-78.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run { target powerpc*-*-* } } */\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -maltivec\" { target powerpc*-*-* } } */\n-/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse\" { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-vect-stats -msse2\" { target i?86-*-* x86_64-*-* } } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\""}, {"sha": "fed3bfc4a099d6c22b5bad3e006002505074e45b", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -527,6 +527,8 @@ dequeue_and_dump (dump_info_p di)\n     case TRUTH_NOT_EXPR:\n     case ADDR_EXPR:\n     case INDIRECT_REF:\n+    case ALIGN_INDIRECT_REF:\n+    case MISALIGNED_INDIRECT_REF:\n     case CLEANUP_POINT_EXPR:\n     case SAVE_EXPR:\n     case REALPART_EXPR:"}, {"sha": "b7ed2edc38797f9605bbeb6cde4c32ce41a2ab5d", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1767,6 +1767,8 @@ tree_could_trap_p (tree expr)\n       return !in_array_bounds_p (expr);\n \n     case INDIRECT_REF:\n+    case ALIGN_INDIRECT_REF:\n+    case MISALIGNED_INDIRECT_REF:\n       return !TREE_THIS_NOTRAP (expr);\n \n     case ASM_EXPR:"}, {"sha": "fe707d5fc542861f2e6d01303372d634cff07167", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -323,7 +323,9 @@ is_gimple_addressable (tree t)\n   return (is_gimple_id (t) || handled_component_p (t)\n \t  || TREE_CODE (t) == REALPART_EXPR\n \t  || TREE_CODE (t) == IMAGPART_EXPR\n-\t  || TREE_CODE (t) == INDIRECT_REF);\n+\t  || TREE_CODE (t) == INDIRECT_REF\n+\t  || TREE_CODE (t) == ALIGN_INDIRECT_REF\n+\t  || TREE_CODE (t) == MISALIGNED_INDIRECT_REF);\n }\n \n /* Return true if T is function invariant.  Or rather a restricted\n@@ -563,6 +565,8 @@ get_base_address (tree t)\n   if (SSA_VAR_P (t)\n       || TREE_CODE (t) == STRING_CST\n       || TREE_CODE (t) == CONSTRUCTOR\n+      || TREE_CODE (t) == MISALIGNED_INDIRECT_REF\n+      || TREE_CODE (t) == ALIGN_INDIRECT_REF\n       || TREE_CODE (t) == INDIRECT_REF)\n     return t;\n   else"}, {"sha": "0bb2072f71443c03a8803b33394da1105734e804", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1018,6 +1018,8 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n     case ADDR_EXPR:\n     case PREDECREMENT_EXPR:\n     case PREINCREMENT_EXPR:\n+    case ALIGN_INDIRECT_REF:\n+    case MISALIGNED_INDIRECT_REF:\n     case INDIRECT_REF:\n       if (TREE_CODE (node) == ADDR_EXPR\n \t  && (TREE_CODE (TREE_OPERAND (node, 0)) == STRING_CST\n@@ -1034,6 +1036,13 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t}\n       else\n \tdump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+\n+      if (TREE_CODE (node) == MISALIGNED_INDIRECT_REF)\n+        {\n+          pp_string (buffer, \"{misalignment: \");\n+          dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+          pp_character (buffer, '}');\n+        }\n       break;\n \n     case POSTDECREMENT_EXPR:\n@@ -1451,6 +1460,16 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       is_stmt = false;\n       break;\n \n+    case REALIGN_LOAD_EXPR:\n+      pp_string (buffer, \"REALIGN_LOAD <\");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 2), spc, flags, false);\n+      pp_string (buffer, \">\");\n+      break;\n+      \n     default:\n       NIY;\n     }\n@@ -1710,6 +1729,8 @@ op_prio (tree op)\n     case PREINCREMENT_EXPR:\n     case PREDECREMENT_EXPR:\n     case NEGATE_EXPR:\n+    case ALIGN_INDIRECT_REF:\n+    case MISALIGNED_INDIRECT_REF:\n     case INDIRECT_REF:\n     case ADDR_EXPR:\n     case FLOAT_EXPR:\n@@ -1838,6 +1859,12 @@ op_symbol (tree op)\n     case INDIRECT_REF:\n       return \"*\";\n \n+    case ALIGN_INDIRECT_REF:\n+      return \"A*\";\n+\n+    case MISALIGNED_INDIRECT_REF:\n+      return \"M*\";\n+\n     case TRUNC_DIV_EXPR:\n     case RDIV_EXPR:\n       return \"/\";"}, {"sha": "b0cdddce9682ab754c117f98c849255f9cc7d1bc", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -495,23 +495,26 @@ collect_points_to_info_for (struct alias_info *ai, tree ptr)\n \n \n /* Helper for ptr_is_dereferenced_by.  Called by walk_tree to look for\n-   INDIRECT_REF nodes for the pointer passed in DATA.  */\n+   (ALIGN/MISALIGNED_)INDIRECT_REF nodes for the pointer passed in DATA.  */\n \n static tree\n find_ptr_dereference (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED, void *data)\n {\n   tree ptr = (tree) data;\n \n-  if (TREE_CODE (*tp) == INDIRECT_REF\n+  if ((TREE_CODE (*tp) == INDIRECT_REF\n+       || TREE_CODE (*tp) == ALIGN_INDIRECT_REF\n+       || TREE_CODE (*tp) == MISALIGNED_INDIRECT_REF)\n       && TREE_OPERAND (*tp, 0) == ptr)\n     return *tp;\n \n   return NULL_TREE;\n }\n \n \n-/* Return true if STMT contains INDIRECT_REF <PTR>.  *IS_STORE is set\n-   to 'true' if the dereference is on the LHS of an assignment.  */\n+/* Return true if STMT contains (ALIGN/MISALIGNED_)INDIRECT_REF <PTR>.  \n+   *IS_STORE is set to 'true' if the dereference is on the LHS of an \n+   assignment.  */\n \n static bool\n ptr_is_dereferenced_by (tree ptr, tree stmt, bool *is_store)"}, {"sha": "937a301f523750a4f3fe06db28b581c297546235", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -418,7 +418,9 @@ mark_stmt_if_obviously_necessary (tree stmt, bool aggressive)\n \t  if (is_global_var (lhs))\n \t    mark_stmt_necessary (stmt, true);\n \t}\n-      else if (TREE_CODE (lhs) == INDIRECT_REF)\n+      else if (TREE_CODE (lhs) == INDIRECT_REF\n+\t       || TREE_CODE (lhs) == ALIGN_INDIRECT_REF\n+\t       || TREE_CODE (lhs) == MISALIGNED_INDIRECT_REF)\n \t{\n \t  tree ptr = TREE_OPERAND (lhs, 0);\n \t  struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);"}, {"sha": "aed07e25f3b4a025c355a28658733ced12e502d6", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -2414,7 +2414,9 @@ record_equivalences_from_stmt (tree stmt,\n \t  t = TREE_OPERAND (t, 0);\n \n \t/* Now see if this is a pointer dereference.  */\n-\tif (TREE_CODE (t) == INDIRECT_REF)\n+\tif (TREE_CODE (t) == INDIRECT_REF\n+\t    || TREE_CODE (t) == ALIGN_INDIRECT_REF\n+\t    || TREE_CODE (t) == MISALIGNED_INDIRECT_REF)\n           {\n \t    tree op = TREE_OPERAND (t, 0);\n "}, {"sha": "4aafc815b84f19b7e12b2bba46a704bd0e91f562", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -137,6 +137,8 @@ for_each_index (tree *addr_p, bool (*cbck) (tree, tree *, void *), void *data)\n \tcase SSA_NAME:\n \t  return cbck (*addr_p, addr_p, data);\n \n+\tcase MISALIGNED_INDIRECT_REF:\n+\tcase ALIGN_INDIRECT_REF:\n \tcase INDIRECT_REF:\n \t  nxt = &TREE_OPERAND (*addr_p, 0);\n \t  return cbck (*addr_p, nxt, data);\n@@ -1101,7 +1103,9 @@ is_call_clobbered_ref (tree ref)\n   if (DECL_P (base))\n     return is_call_clobbered (base);\n \n-  if (TREE_CODE (base) == INDIRECT_REF)\n+  if (TREE_CODE (base) == INDIRECT_REF\n+      || TREE_CODE (base) == ALIGN_INDIRECT_REF\n+      || TREE_CODE (base) == MISALIGNED_INDIRECT_REF)\n     {\n       /* Check whether the alias tags associated with the pointer\n \t are call clobbered.  */"}, {"sha": "08a962d09325337845198aec2a98f202433520bc", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1269,7 +1269,9 @@ find_interesting_uses_address (struct ivopts_data *data, tree stmt, tree *op_p)\n       || zero_p (step))\n     goto fail;\n \n-  if (TREE_CODE (base) == INDIRECT_REF)\n+  if (TREE_CODE (base) == INDIRECT_REF\n+      || TREE_CODE (base) == ALIGN_INDIRECT_REF\n+      || TREE_CODE (base) == MISALIGNED_INDIRECT_REF)\n     base = TREE_OPERAND (base, 0);\n   else\n     base = build_addr (base);\n@@ -1699,7 +1701,9 @@ add_address_candidates (struct ivopts_data *data,\n \n       if (base != TREE_OPERAND (iv->base, 0))\n \t{ \n-\t  if (TREE_CODE (base) == INDIRECT_REF)\n+\t  if (TREE_CODE (base) == INDIRECT_REF\n+\t      || TREE_CODE (base) == ALIGN_INDIRECT_REF\n+\t      || TREE_CODE (base) == MISALIGNED_INDIRECT_REF)\n \t    base = TREE_OPERAND (base, 0);\n \t  else\n \t    base = build_addr (base);\n@@ -3826,13 +3830,16 @@ unshare_and_remove_ssa_names (tree ref)\n static void\n rewrite_address_base (block_stmt_iterator *bsi, tree *op, tree with)\n {\n-  tree var = get_base_address (*op), new_var, new_name, copy, name;\n+  tree bvar, var, new_var, new_name, copy, name;\n   tree orig;\n \n+  var = bvar = get_base_address (*op);\n+\n   if (!var || TREE_CODE (with) != SSA_NAME)\n     goto do_rewrite;\n-\n-  if (TREE_CODE (var) == INDIRECT_REF)\n+  if (TREE_CODE (var) == INDIRECT_REF\n+      || TREE_CODE (var) == ALIGN_INDIRECT_REF\n+      || TREE_CODE (var) == MISALIGNED_INDIRECT_REF)\n     var = TREE_OPERAND (var, 0);\n   if (TREE_CODE (var) == SSA_NAME)\n     {\n@@ -3869,12 +3876,20 @@ rewrite_address_base (block_stmt_iterator *bsi, tree *op, tree with)\n do_rewrite:\n \n   orig = NULL_TREE;\n-  if (TREE_CODE (*op) == INDIRECT_REF)\n+  if (TREE_CODE (*op) == INDIRECT_REF\n+      || TREE_CODE (*op) == ALIGN_INDIRECT_REF\n+      || TREE_CODE (*op) == MISALIGNED_INDIRECT_REF)\n     orig = REF_ORIGINAL (*op);\n   if (!orig)\n     orig = unshare_and_remove_ssa_names (*op);\n \n-  *op = build1 (INDIRECT_REF, TREE_TYPE (*op), with);\n+  if (TREE_CODE (bvar) == ALIGN_INDIRECT_REF)\n+    *op = build1 (ALIGN_INDIRECT_REF, TREE_TYPE (*op), with);\n+  else if (TREE_CODE (bvar) == MISALIGNED_INDIRECT_REF)\n+    *op = build2 (MISALIGNED_INDIRECT_REF, TREE_TYPE (*op), with, TREE_OPERAND (*op, 1));\n+  else\n+    *op = build1 (INDIRECT_REF, TREE_TYPE (*op), with);\n+\n   /* Record the original reference, for purposes of alias analysis.  */\n   REF_ORIGINAL (*op) = orig;\n }"}, {"sha": "55e6f8a14465f42cda1a7dc69fd8617955925104", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1009,6 +1009,11 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n       add_stmt_operand (expr_p, stmt, flags);\n       return;\n \n+    case MISALIGNED_INDIRECT_REF:\n+      get_expr_operands (stmt, &TREE_OPERAND (expr, 1), flags);\n+      /* fall through */\n+\n+    case ALIGN_INDIRECT_REF:\n     case INDIRECT_REF:\n       get_indirect_ref_operands (stmt, expr, flags);\n       return;\n@@ -1162,6 +1167,14 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n \treturn;\n       }\n \n+    case REALIGN_LOAD_EXPR:\n+      {\n+\tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n+        get_expr_operands (stmt, &TREE_OPERAND (expr, 1), flags);\n+        get_expr_operands (stmt, &TREE_OPERAND (expr, 2), flags);\n+        return;\n+      }\n+\n     case BLOCK:\n     case FUNCTION_DECL:\n     case EXC_PTR_EXPR:\n@@ -1274,7 +1287,8 @@ get_asm_expr_operands (tree stmt)\n       }\n }\n \n-/* A subroutine of get_expr_operands to handle INDIRECT_REF.  */\n+/* A subroutine of get_expr_operands to handle INDIRECT_REF,\n+   ALIGN_INDIRECT_REF and MISALIGNED_INDIRECT_REF.  */\n \n static void\n get_indirect_ref_operands (tree stmt, tree expr, int flags)"}, {"sha": "b158278d0fd3618f56e7d495b5a3ffaccc7e1e49", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 297, "deletions": 94, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -179,7 +179,8 @@ static bool vect_compute_data_ref_alignment\n static bool vect_analyze_data_ref_access (struct data_reference *);\n static bool vect_get_first_index (tree, tree *);\n static bool vect_can_force_dr_alignment_p (tree, unsigned int);\n-static struct data_reference * vect_analyze_pointer_ref_access (tree, tree, bool);\n+static struct data_reference * vect_analyze_pointer_ref_access \n+  (tree, tree, bool);\n static tree vect_get_base_and_bit_offset\n   (struct data_reference *, tree, tree, loop_vec_info, tree *, bool*);\n static struct data_reference * vect_analyze_pointer_ref_access\n@@ -193,9 +194,11 @@ static tree vect_get_symbl_and_dr\n \n /* Utility functions for the code transformation.  */\n static tree vect_create_destination_var (tree, tree);\n-static tree vect_create_data_ref (tree, block_stmt_iterator *);\n-static tree vect_create_index_for_vector_ref (struct loop *, block_stmt_iterator *);\n-static tree vect_create_addr_base_for_vector_ref (tree, tree *);\n+static tree vect_create_data_ref_ptr \n+  (tree, block_stmt_iterator *, tree, tree *, bool); \n+static tree vect_create_index_for_vector_ref \n+  (struct loop *, block_stmt_iterator *);\n+static tree vect_create_addr_base_for_vector_ref (tree, tree *, tree);\n static tree get_vectype_for_scalar_type (tree);\n static tree vect_get_new_vect_var (tree, enum vect_var_kind, const char *);\n static tree vect_get_vec_def_for_operand (tree, tree);\n@@ -702,8 +705,8 @@ vect_create_index_for_vector_ref (struct loop *loop, block_stmt_iterator *bsi)\n \n    Input:\n    STMT: The statement containing the data reference.\n-   NEW_STMT_LIST: Must be initialized to NULL_TREE or a\n-   statement list.\n+   NEW_STMT_LIST: Must be initialized to NULL_TREE or a statement list.\n+   OFFSET: Optional. If supplied, it is be added to the initial address.\n \n    Output:\n    1. Return an SSA_NAME whose value is the address of the memory location of the\n@@ -715,7 +718,8 @@ vect_create_index_for_vector_ref (struct loop *loop, block_stmt_iterator *bsi)\n \n static tree\n vect_create_addr_base_for_vector_ref (tree stmt,\n-                                      tree *new_stmt_list)\n+                                      tree *new_stmt_list,\n+\t\t\t\t      tree offset)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   struct loop *loop = STMT_VINFO_LOOP (stmt_info);\n@@ -776,7 +780,8 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n \n       dest = create_tmp_var (TREE_TYPE (data_ref_base), \"dataref\");\n       add_referenced_tmp_var (dest);\n-      data_ref_base  = force_gimple_operand (data_ref_base, &new_stmt, false, dest);  \n+      data_ref_base = \n+\tforce_gimple_operand (data_ref_base, &new_stmt, false, dest);  \n       append_to_statement_list_force (new_stmt, new_stmt_list);\n \n       vec_stmt = fold_convert (scalar_array_ptr_type, data_ref_base);\n@@ -794,6 +799,17 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n   init_val = force_gimple_operand (init_oval, &new_stmt, false, dest);  \n   append_to_statement_list_force (new_stmt, new_stmt_list);\n \n+  if (offset)\n+    {\n+      tree tmp = create_tmp_var (TREE_TYPE (init_val), \"offset\");\n+      add_referenced_tmp_var (tmp);\n+      vec_stmt = build2 (PLUS_EXPR, TREE_TYPE (init_val), init_val, offset);\n+      vec_stmt = build2 (MODIFY_EXPR, TREE_TYPE (init_val), tmp, vec_stmt);\n+      init_val = make_ssa_name (tmp, vec_stmt);\n+      TREE_OPERAND (vec_stmt, 0) = init_val;\n+      append_to_statement_list_force (vec_stmt, new_stmt_list);\n+    }\n+\n   array_ref = build4 (ARRAY_REF, scalar_type, array_base, init_val, \n \t\t      NULL_TREE, NULL_TREE);\n   addr_base = build_fold_addr_expr (array_ref);\n@@ -806,6 +822,7 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n   new_temp = make_ssa_name (addr_expr, vec_stmt);\n   TREE_OPERAND (vec_stmt, 0) = new_temp;\n   append_to_statement_list_force (vec_stmt, new_stmt_list);\n+\n   return new_temp;\n }\n \n@@ -856,31 +873,56 @@ vect_align_data_ref (tree stmt)\n }\n \n \n-/* Function vect_create_data_ref.\n+/* Function vect_create_data_ref_ptr.\n \n    Create a memory reference expression for vector access, to be used in a\n-   vector load/store stmt.\n+   vector load/store stmt. The reference is based on a new pointer to vector\n+   type (vp).\n \n    Input:\n-   STMT: a stmt that references memory. expected to be of the form\n-\t MODIFY_EXPR <name, data-ref> or MODIFY_EXPR <data-ref, name>.\n-   BSI: block_stmt_iterator where new stmts can be added.\n+   1. STMT: a stmt that references memory. Expected to be of the form\n+         MODIFY_EXPR <name, data-ref> or MODIFY_EXPR <data-ref, name>.\n+   2. BSI: block_stmt_iterator where new stmts can be added.\n+   3. OFFSET (optional): an offset to be added to the initial address accessed\n+        by the data-ref in STMT.\n+   4. ONLY_INIT: indicate if vp is to be updated in the loop, or remain\n+        pointing to the initial address.\n \n    Output:\n-   1. Declare a new ptr to vector_type, and have it point to the array base.\n-      For example, for vector of type V8HI:\n-      v8hi *p0;\n-      p0 = (v8hi *)&a;\n-   2. Create a data-reference based on the new vector pointer p0, and using\n-      a new index variable 'idx'. Return the expression '(*p0)[idx]'.\n+   1. Declare a new ptr to vector_type, and have it point to the base of the\n+      data reference (initial addressed accessed by the data reference).\n+      For example, for vector of type V8HI, the following code is generated:\n+\n+      v8hi *vp;\n+      vp = (v8hi *)initial_address;\n+\n+      if OFFSET is not supplied:\n+         initial_address = &a[init];\n+      if OFFSET is supplied:\n+         initial_address = &a[init + OFFSET];\n+\n+      Return the initial_address in INITIAL_ADDRESS.\n+\n+   2. Create a data-reference in the loop based on the new vector pointer vp,\n+      and using a new index variable 'idx' as follows:\n+\n+      vp' = vp + update\n+\n+      where if ONLY_INIT is true:\n+         update = zero\n+      and otherwise\n+         update = idx + vector_type_size\n+\n+      Return the pointer vp'.\n+\n \n    FORNOW: handle only aligned and consecutive accesses.  */\n \n static tree\n-vect_create_data_ref (tree stmt, block_stmt_iterator *bsi)\n+vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n+                          tree *initial_address, bool only_init)\n {\n-  tree base_name, data_ref_base, data_ref_base_type;\n-  tree array_type;\n+  tree base_name;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   struct loop *loop = STMT_VINFO_LOOP (stmt_info);\n@@ -897,55 +939,44 @@ vect_create_data_ref (tree stmt, block_stmt_iterator *bsi)\n   tree vec_stmt;\n   tree new_stmt_list = NULL_TREE;\n   tree idx;\n-  tree new_base;\n-  tree data_ref;\n-  edge pe;\n+  edge pe = loop_preheader_edge (loop);\n   basic_block new_bb;\n-\n-  /* FORNOW: make sure the data reference is aligned.  */\n-  vect_align_data_ref (stmt);\n+  tree vect_ptr_init;\n+  tree vectype_size;\n+  tree ptr_update;\n+  tree data_ref_ptr;\n \n   base_name = unshare_expr (DR_BASE_NAME (dr));\n-  data_ref_base = STMT_VINFO_VECT_DR_BASE (stmt_info);\n-  data_ref_base_type = TREE_TYPE (data_ref_base);\n-\n-  array_type = build_array_type (vectype, 0);\n-  TYPE_ALIGN (array_type) = TYPE_ALIGN (data_ref_base_type);\n-  vect_ptr_type = build_pointer_type (array_type);\n-\n   if (vect_debug_details (NULL))\n     {\n+      tree data_ref_base = base_name;\n       fprintf (dump_file, \"create array_ref of type: \");\n       print_generic_expr (dump_file, vectype, TDF_SLIM);\n-    }\n-\n-  /* Create: vectype *p;  */\n-  vect_ptr = vect_get_new_vect_var (vect_ptr_type, vect_pointer_var, \n-\t\t\t\t    get_name (base_name));\n-  add_referenced_tmp_var (vect_ptr);\n-\n-  if (vect_debug_details (NULL))\n-    {\n       if (TREE_CODE (data_ref_base) == VAR_DECL)\n-\tfprintf (dump_file, \"vectorizing a one dimensional array ref: \");\n+        fprintf (dump_file, \"vectorizing a one dimensional array ref: \");\n       else if (TREE_CODE (data_ref_base) == ARRAY_REF)\n-\tfprintf (dump_file, \"vectorizing a multidimensional array ref: \");\n+        fprintf (dump_file, \"vectorizing a multidimensional array ref: \");\n       else if (TREE_CODE (data_ref_base) == COMPONENT_REF)\n-\tfprintf (dump_file, \"vectorizing a record based array ref: \");\n+        fprintf (dump_file, \"vectorizing a record based array ref: \");\n       else if (TREE_CODE (data_ref_base) == SSA_NAME)\n-\tfprintf (dump_file, \"vectorizing a pointer ref: \");\n-      else if (TREE_CODE (data_ref_base) == ADDR_EXPR\n-\t       || TREE_CODE (data_ref_base) == PLUS_EXPR\n-\t       || TREE_CODE (data_ref_base) == MINUS_EXPR)\n-\tfprintf (dump_file, \"vectorizing an address expr: \");\n+        fprintf (dump_file, \"vectorizing a pointer ref: \");\n       print_generic_expr (dump_file, base_name, TDF_SLIM);\n     }\n \n-  /* Handle aliasing:  */\n+  /** (1) Create the new vector-pointer variable:  **/\n+\n+  vect_ptr_type = build_pointer_type (vectype);\n+  vect_ptr = vect_get_new_vect_var (vect_ptr_type, vect_pointer_var,\n+                                    get_name (base_name));\n+  add_referenced_tmp_var (vect_ptr);\n+  \n+  \n+  /** (2) Handle aliasing information of the new vector-pointer:  **/\n+  \n   tag = STMT_VINFO_MEMTAG (stmt_info);\n   gcc_assert (tag);\n   get_var_ann (vect_ptr)->type_mem_tag = tag;\n-\n+  \n   /* Mark for renaming all aliased variables\n      (i.e, the may-aliases of the type-mem-tag).  */\n   nvuses = NUM_VUSES (vuses);\n@@ -969,36 +1000,56 @@ vect_create_data_ref (tree stmt, block_stmt_iterator *bsi)\n       if (TREE_CODE (def) == SSA_NAME)\n         bitmap_set_bit (vars_to_rename, var_ann (SSA_NAME_VAR (def))->uid);\n     }\n-  \n-  pe = loop_preheader_edge (loop);\n \n-  /* Create: (&(base[init_val]) */\n-  new_temp = vect_create_addr_base_for_vector_ref (stmt, &new_stmt_list);\n \n-  pe = loop_preheader_edge (loop); \n-  new_bb = bsi_insert_on_edge_immediate (pe, new_stmt_list); \n-  gcc_assert (!new_bb); \n+  /** (3) Calculate the initial address the vector-pointer, and set\n+          the vector-pointer to point to it before the loop:  **/\n+\n+  /* Create: (&(base[init_val+offset]) in the loop preheader.  */\n+  new_temp = vect_create_addr_base_for_vector_ref (stmt, &new_stmt_list,\n+                                                   offset);\n+  pe = loop_preheader_edge (loop);\n+  new_bb = bsi_insert_on_edge_immediate (pe, new_stmt_list);\n+  gcc_assert (!new_bb);\n+  *initial_address = new_temp;\n \n-  /* p = (vectype_array *) addr_base  */\n+  /* Create: p = (vectype *) initial_base  */\n   vec_stmt = fold_convert (vect_ptr_type, new_temp);\n   vec_stmt = build2 (MODIFY_EXPR, void_type_node, vect_ptr, vec_stmt);\n   new_temp = make_ssa_name (vect_ptr, vec_stmt);\n   TREE_OPERAND (vec_stmt, 0) = new_temp;\n-  new_bb = bsi_insert_on_edge_immediate (pe, vec_stmt); \n-  gcc_assert (!new_bb); \n+  new_bb = bsi_insert_on_edge_immediate (pe, vec_stmt);\n+  gcc_assert (!new_bb);\n+  vect_ptr_init = TREE_OPERAND (vec_stmt, 0);\n+\n+\n+  /** (4) Handle the updating of the vector-pointer inside the loop: **/\n+\n+  if (only_init) /* No update in loop is required.  */\n+    return vect_ptr_init;\n \n-  /*** create data ref: '(*p)[idx]' ***/\n   idx = vect_create_index_for_vector_ref (loop, bsi);\n-  new_base = build_fold_indirect_ref (new_temp);\n-  data_ref = build4 (ARRAY_REF, vectype, new_base, idx, NULL_TREE, NULL_TREE);\n \n-  if (vect_debug_details (NULL))\n-    {\n-      fprintf (dump_file, \"created new data-ref: \");\n-      print_generic_expr (dump_file, data_ref, TDF_SLIM);\n-    }\n+  /* Create: update = idx * vectype_size  */\n+  ptr_update = create_tmp_var (integer_type_node, \"update\");\n+  add_referenced_tmp_var (ptr_update);\n+  vectype_size = build_int_cst (integer_type_node,\n+                                GET_MODE_SIZE (TYPE_MODE (vectype)));\n+  vec_stmt = build2 (MULT_EXPR, integer_type_node, idx, vectype_size);\n+  vec_stmt = build2 (MODIFY_EXPR, void_type_node, ptr_update, vec_stmt);\n+  new_temp = make_ssa_name (ptr_update, vec_stmt);\n+  TREE_OPERAND (vec_stmt, 0) = new_temp;\n+  bsi_insert_before (bsi, vec_stmt, BSI_SAME_STMT);\n \n-  return data_ref;\n+  /* Create: data_ref_ptr = vect_ptr_init + update  */\n+  vec_stmt = build2 (PLUS_EXPR, vect_ptr_type, vect_ptr_init, new_temp);\n+  vec_stmt = build2 (MODIFY_EXPR, void_type_node, vect_ptr, vec_stmt);\n+  new_temp = make_ssa_name (vect_ptr, vec_stmt);\n+  TREE_OPERAND (vec_stmt, 0) = new_temp;\n+  bsi_insert_before (bsi, vec_stmt, BSI_SAME_STMT);\n+  data_ref_ptr = TREE_OPERAND (vec_stmt, 0);\n+\n+  return data_ref_ptr;\n }\n \n \n@@ -1220,8 +1271,8 @@ vect_finish_stmt_generation (tree stmt, tree vec_stmt, block_stmt_iterator *bsi)\n \n   /* Make sure bsi points to the stmt that is being vectorized.  */\n \n-  /* Assumption: any stmts created for the vectorization of smtmt S are\n-     inserted before S. BSI may point to S or some new stmt before it.  */\n+  /* Assumption: any stmts created for the vectorization of stmt S were\n+     inserted before S. BSI is expected to point to S or some new stmt before S.  */\n \n   while (stmt != bsi_stmt (*bsi) && !bsi_end_p (*bsi))\n     bsi_next (bsi);\n@@ -1424,6 +1475,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   struct loop *loop = STMT_VINFO_LOOP (stmt_info);\n   enum machine_mode vec_mode;\n+  tree dummy;\n \n   /* Is vectorizable store? */\n \n@@ -1452,6 +1504,9 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (!STMT_VINFO_DATA_REF (stmt_info))\n     return false;\n \n+  if (!aligned_access_p (STMT_VINFO_DATA_REF (stmt_info)))\n+    return false;\n+\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = store_vec_info_type;\n@@ -1467,7 +1522,10 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   vec_oprnd1 = vect_get_vec_def_for_operand (op, stmt);\n \n   /* Handle def.  */\n-  data_ref = vect_create_data_ref (stmt, bsi);\n+  /* FORNOW: make sure the data reference is aligned.  */\n+  vect_align_data_ref (stmt);\n+  data_ref = vect_create_data_ref_ptr (stmt, bsi, NULL_TREE, &dummy, false);\n+  data_ref = build_fold_indirect_ref (data_ref);\n \n   /* Arguments are ready. create the new vector stmt.  */\n   *vec_stmt = build2 (MODIFY_EXPR, vectype, data_ref, vec_oprnd1);\n@@ -1493,9 +1551,17 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   tree data_ref = NULL;\n   tree op;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   tree new_temp;\n-  enum machine_mode vec_mode;\n+  int mode;\n+  tree init_addr;\n+  tree new_stmt;\n+  tree dummy;\n+  basic_block new_bb;\n+  struct loop *loop = STMT_VINFO_LOOP (stmt_info);\n+  edge pe = loop_preheader_edge (loop);\n+  bool software_pipeline_loads_p = false;\n \n   /* Is vectorizable load? */\n \n@@ -1513,11 +1579,31 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (!STMT_VINFO_DATA_REF (stmt_info))\n     return false;\n \n-  vec_mode = TYPE_MODE (vectype);\n+  mode = (int) TYPE_MODE (vectype);\n+\n   /* FORNOW. In some cases can vectorize even if data-type not supported\n-     (e.g. - data copies).  */\n-  if (mov_optab->handlers[(int)vec_mode].insn_code == CODE_FOR_nothing)\n-    return false;\n+    (e.g. - data copies).  */\n+  if (mov_optab->handlers[mode].insn_code == CODE_FOR_nothing)\n+    {\n+      if (vect_debug_details (loop))\n+\tfprintf (dump_file, \"Aligned load, but unsupported type.\");\n+      return false;\n+    }\n+\n+  if (!aligned_access_p (dr))\n+    {\n+      if (vec_realign_load_optab->handlers[mode].insn_code != CODE_FOR_nothing\n+\t  && (!targetm.vectorize.builtin_mask_for_load\n+\t      || targetm.vectorize.builtin_mask_for_load ()))\n+\tsoftware_pipeline_loads_p = true;\n+      else if (!targetm.vectorize.misaligned_mem_ok (mode))\n+\t{\n+\t  /* Possibly unaligned access, and can't sofware pipeline the loads  */\n+\t  if (vect_debug_details (loop))\n+\t    fprintf (dump_file, \"Arbitrary load not supported.\");\n+\t  return false;\n+\t}\n+    }\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n@@ -1530,19 +1616,130 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (vect_debug_details (NULL))\n     fprintf (dump_file, \"transform load.\");\n \n-  /* Handle def.  */\n-  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+  if (!software_pipeline_loads_p)\n+    {\n+      /* Create:\n+         p = initial_addr;\n+         indx = 0;\n+         loop {\n+           vec_dest = *(p);\n+           indx = indx + 1;\n+         }\n+      */\n+\n+      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+      data_ref = vect_create_data_ref_ptr (stmt, bsi, NULL_TREE, &dummy, false);\n+      if (aligned_access_p (dr))\n+        data_ref = build_fold_indirect_ref (data_ref);\n+      else\n+\t{\n+\t  int mis = DR_MISALIGNMENT (dr);\n+\t  tree tmis = (mis == -1 ?\n+\t\t       integer_zero_node : \n+\t\t       build_int_cst (integer_type_node, mis));\n+\t  tmis = int_const_binop (MULT_EXPR, tmis, \n+\t\t\tbuild_int_cst (integer_type_node, BITS_PER_UNIT), 1);\n+\t  data_ref = build2 (MISALIGNED_INDIRECT_REF, vectype, data_ref, tmis);\n+\t}\n+      new_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, data_ref);\n+      new_temp = make_ssa_name (vec_dest, new_stmt);\n+      TREE_OPERAND (new_stmt, 0) = new_temp;\n+      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+    }\n+  else /* software-pipeline the loads  */\n+    {\n+      /* Create:\n+\t p1 = initial_addr;\n+\t msq_init = *(floor(p1))\n+\t p2 = initial_addr + VS - 1;\n+\t magic = have_builtin ? builtin_result : initial_address;\n+\t indx = 0;\n+\t loop {\n+\t   p2' = p2 + indx * vectype_size\n+\t   lsq = *(floor(p2'))\n+\t   vec_dest = realign_load (msq, lsq, magic)\n+\t   indx = indx + 1;\n+\t   msq = lsq;\n+\t }\n+      */\n+\n+      tree offset;\n+      tree magic;\n+      tree phi_stmt;\n+      tree msq_init;\n+      tree msq, lsq;\n+      tree dataref_ptr;\n+      tree params;\n+\n+      /* <1> Create msq_init = *(floor(p1)) in the loop preheader  */\n+      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+      data_ref = vect_create_data_ref_ptr (stmt, bsi, NULL_TREE, \n+\t\t\t\t\t   &init_addr, true);\n+      data_ref = build1 (ALIGN_INDIRECT_REF, vectype, data_ref);\n+      new_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, data_ref);\n+      new_temp = make_ssa_name (vec_dest, new_stmt);\n+      TREE_OPERAND (new_stmt, 0) = new_temp;\n+      new_bb = bsi_insert_on_edge_immediate (pe, new_stmt);\n+      gcc_assert (!new_bb);\n+      msq_init = TREE_OPERAND (new_stmt, 0);\n+\n+\n+      /* <2> Create lsq = *(floor(p2')) in the loop  */ \n+      offset = build_int_cst (integer_type_node, \n+\t\t\t      GET_MODE_NUNITS (TYPE_MODE (vectype)));\n+      offset = int_const_binop (MINUS_EXPR, offset, integer_one_node, 1);\n+      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+      dataref_ptr = vect_create_data_ref_ptr (stmt, bsi, offset, &dummy, false);\n+      data_ref = build1 (ALIGN_INDIRECT_REF, vectype, dataref_ptr);\n+      new_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, data_ref);\n+      new_temp = make_ssa_name (vec_dest, new_stmt);\n+      TREE_OPERAND (new_stmt, 0) = new_temp;\n+      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+      lsq = TREE_OPERAND (new_stmt, 0);\n+\n+\n+      /* <3> */\n+      if (targetm.vectorize.builtin_mask_for_load)\n+\t{\n+\t  /* Create permutation mask, if required, in loop preheader.  */\n+\t  tree builtin_decl;\n+\t  params = build_tree_list (NULL_TREE, init_addr);\n+\t  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+\t  builtin_decl = targetm.vectorize.builtin_mask_for_load ();\n+\t  new_stmt = build_function_call_expr (builtin_decl, params);\n+\t  new_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, new_stmt);\n+\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n+\t  TREE_OPERAND (new_stmt, 0) = new_temp;\n+\t  new_bb = bsi_insert_on_edge_immediate (pe, new_stmt);\n+\t  gcc_assert (!new_bb);\n+\t  magic = TREE_OPERAND (new_stmt, 0);\n+\t}\n+      else\n+\t{\n+\t  /* Use current address instead of init_addr for reduced reg pressure.  */\n+\t  magic = dataref_ptr;\n+\t}\n \n-  /* Handle use.  */\n-  op = TREE_OPERAND (stmt, 1);\n-  data_ref = vect_create_data_ref (stmt, bsi);\n \n-  /* Arguments are ready. create the new vector stmt.  */\n-  *vec_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, data_ref);\n-  new_temp = make_ssa_name (vec_dest, *vec_stmt);\n-  TREE_OPERAND (*vec_stmt, 0) = new_temp;\n-  vect_finish_stmt_generation (stmt, *vec_stmt, bsi);\n+      /* <4> Create msq = phi <msq_init, lsq> in loop  */ \n+      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+      msq = make_ssa_name (vec_dest, NULL_TREE);\n+      phi_stmt = create_phi_node (msq, loop->header); /* CHECKME */\n+      SSA_NAME_DEF_STMT (msq) = phi_stmt;\n+      add_phi_arg (&phi_stmt, msq_init, loop_preheader_edge (loop));\n+      add_phi_arg (&phi_stmt, lsq, loop_latch_edge (loop));\n+\n \n+      /* <5> Create <vec_dest = realign_load (msq, lsq, magic)> in loop  */\n+      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+      new_stmt = build3 (REALIGN_LOAD_EXPR, vectype, msq, lsq, magic);\n+      new_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, new_stmt);\n+      new_temp = make_ssa_name (vec_dest, new_stmt); \n+      TREE_OPERAND (new_stmt, 0) = new_temp;\n+      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+    }\n+\n+  *vec_stmt = new_stmt;\n   return true;\n }\n \n@@ -2726,7 +2923,7 @@ vect_compute_data_refs_alignment (loop_vec_info loop_vinfo)\n    FOR NOW: No transformation is actually performed. TODO.  */\n \n static void\n-vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo ATTRIBUTE_UNUSED)\n+vect_enhance_data_refs_alignment (loop_vec_info loop_info ATTRIBUTE_UNUSED)\n {\n   /*\n      This pass will require a cost model to guide it whether to apply peeling \n@@ -2824,7 +3021,8 @@ static bool\n vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n {\n   varray_type loop_write_datarefs = LOOP_VINFO_DATAREF_WRITES (loop_vinfo);\n-  varray_type loop_read_datarefs = LOOP_VINFO_DATAREF_READS (loop_vinfo);\n+  /*varray_type loop_read_datarefs = LOOP_VINFO_DATAREF_READS (loop_vinfo);*/\n+\n   unsigned int i;\n \n   if (vect_debug_details (NULL))\n@@ -2864,6 +3062,11 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n \t}\n     }\n \n+  /* The vectorizer now supports misaligned loads, so we don't fail anymore\n+     in the presence of a misaligned read dataref.  For some targets however\n+     it may be preferable not to vectorize in such a case as misaligned\n+     accesses are very costly.  This should be considered in the future.  */\n+/*\n   for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_read_datarefs); i++)\n     {\n       struct data_reference *dr = VARRAY_GENERIC_PTR (loop_read_datarefs, i);\n@@ -2875,6 +3078,7 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n \t  return false;\n \t}\n     }\n+*/\n \n   return true;\n }\n@@ -3158,7 +3362,6 @@ vect_get_symbl_and_dr (tree memref, tree stmt, bool is_read,\n \n     case ARRAY_REF:\n       offset = size_zero_node;\n-      array_base = TREE_OPERAND (memref, 0);\n \n       /* Store the array base in the stmt info. \n \t For one dimensional array ref a[i], the base is a,"}, {"sha": "37c57067914d73416ff97588f5c9e23467ebbe28", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -119,6 +119,7 @@ vinfo_for_stmt (tree stmt)\n /* Info on data references alignment.                              */\n /*-----------------------------------------------------------------*/\n \n+/* The misalignment of the memory access in bytes.  */\n #define DR_MISALIGNMENT(DR)   (DR)->aux\n \n static inline bool"}, {"sha": "a0cb800470fd7d441fb315d110a2246c06da6920", "filename": "gcc/tree.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -1493,6 +1493,8 @@ staticp (tree arg)\n     case BIT_FIELD_REF:\n       return NULL;\n \n+    case MISALIGNED_INDIRECT_REF:\n+    case ALIGN_INDIRECT_REF:\n     case INDIRECT_REF:\n       return TREE_CONSTANT (TREE_OPERAND (arg, 0)) ? arg : NULL;\n \n@@ -2412,6 +2414,8 @@ build1_stat (enum tree_code code, tree type, tree node MEM_STAT_DECL)\n       TREE_READONLY (t) = 0;\n       break;\n \n+    case MISALIGNED_INDIRECT_REF:\n+    case ALIGN_INDIRECT_REF:\n     case INDIRECT_REF:\n       /* Whether a dereference is readonly has nothing to do with whether\n \t its operand is readonly.  */"}, {"sha": "4c1f9861f9ddf4788d8e422546bc428aa3548af2", "filename": "gcc/tree.def", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -366,6 +366,17 @@ DEFTREECODE (BIT_FIELD_REF, \"bit_field_ref\", tcc_reference, 3)\n /* C unary `*' or Pascal `^'.  One operand, an expression for a pointer.  */\n DEFTREECODE (INDIRECT_REF, \"indirect_ref\", tcc_reference, 1)\n \n+/* Like above, but aligns the referenced address (i.e, if the address\n+   in P is not aligned on TYPE_ALIGN boundary, then &(*P) != P).  */\n+DEFTREECODE (ALIGN_INDIRECT_REF, \"align_indirect_ref\", tcc_reference, 1)\n+\n+/* Same as INDIRECT_REF, but also specifies the alignment of the referenced\n+   address:\n+   Operand 0 is the referenced address (a pointer);\n+   Operand 1 is an INTEGER_CST which represents the alignment of the address,\n+   or 0 if the alignment is unknown.  */\n+DEFTREECODE (MISALIGNED_INDIRECT_REF, \"misaligned_indirect_ref\", tcc_reference, 2)\n+\n /* Array indexing.\n    Operand 0 is the array; operand 1 is a (single) array index.\n    Operand 2, if present, is a copy of TYPE_MIN_VALUE of the index.\n@@ -886,6 +897,28 @@ DEFTREECODE (TREE_BINFO, \"tree_binfo\", tcc_exceptional, 0)\n    Operand 1 is the size of the type in the expression.  */\n DEFTREECODE (WITH_SIZE_EXPR, \"with_size_expr\", tcc_expression, 2)\n \n+/* Extract elements from two input vectors Operand 0 and Operand 1\n+   size VS, according to the offset OFF defined by Operand 2 as\n+   follows:\n+   If OFF > 0, the last VS - OFF elements of vector OP0 are concatenated to\n+   the first OFF elements of the vector OP1.\n+   If OFF == 0, then the returned vector is OP1.\n+   On different targets OFF may take different forms; It can be an address, in \n+   which case its low log2(VS)-1 bits define the offset, or it can be a mask \n+   generated by the builtin targetm.vectorize.mask_for_load_builtin_decl.  */\n+DEFTREECODE (REALIGN_LOAD_EXPR, \"realign_load\", tcc_expression, 3)\n+\n+/* Extract elements from two input vectors Operand 0 and Operand 1\n+   size VS, according to the offset OFF defined by Operand 2 as\n+   follows:\n+   If OFF > 0, the last OFF elements of vector OP0 are concatenated to\n+   the first VS - OFF elements of the vector OP1.\n+   If OFF == 0, then the returned vector is OP0.\n+   On different targets OFF may take different forms; It can be an address, in \n+   which case its low log2(VS)-1 bits define the offset, or it can be a mask \n+   generated by the builtin targetm.vectorize.mask_for_store_builtin_decl.  */\n+DEFTREECODE (REALIGN_STORE_EXPR, \"realign_store\", tcc_expression, 3)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "a913d74c589af5a87a24c3a64664312d9db3096c", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ccf35ed170c496d99d670986e96e7c1d779cee3/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=7ccf35ed170c496d99d670986e96e7c1d779cee3", "patch": "@@ -390,7 +390,7 @@ struct tree_common GTY(())\n \t   ..._TYPE\n \n        TREE_THIS_NOTRAP in\n-          INDIRECT_REF, ARRAY_REF, ARRAY_RANGE_REF\n+          (ALIGN/MISALIGNED_)INDIRECT_REF, ARRAY_REF, ARRAY_RANGE_REF\n \n    deprecated_flag:\n \n@@ -901,7 +901,8 @@ extern void tree_operand_check_failed (int, enum tree_code,\n /* Nonzero means this node will not trap.  In an INDIRECT_REF, means\n    accessing the memory pointed to won't generate a trap.  However,\n    this only applies to an object when used appropriately: it doesn't\n-   mean that writing a READONLY mem won't trap.\n+   mean that writing a READONLY mem won't trap. Similarly for\n+   ALIGN_INDIRECT_REF and MISALIGNED_INDIRECT_REF.\n \n    In ARRAY_REF and ARRAY_RANGE_REF means that we know that the index\n    (or slice of the array) always belongs to the range of the array.\n@@ -1145,8 +1146,9 @@ struct tree_vec GTY(())\n #define TREE_OPERAND(NODE, I) TREE_OPERAND_CHECK (NODE, I)\n #define TREE_COMPLEXITY(NODE) (EXPR_CHECK (NODE)->exp.complexity)\n \n-/* In INDIRECT_REF.  */\n-#define REF_ORIGINAL(NODE) TREE_CHAIN (TREE_CHECK (NODE, INDIRECT_REF))\n+/* In INDIRECT_REF, ALIGN_INDIRECT_REF, MISALIGNED_INDIRECT_REF.  */\n+#define REF_ORIGINAL(NODE) TREE_CHAIN (TREE_CHECK3 (NODE, \t\\\n+\tINDIRECT_REF, ALIGN_INDIRECT_REF, MISALIGNED_INDIRECT_REF))\n \n /* In a LABELED_BLOCK_EXPR node.  */\n #define LABELED_BLOCK_LABEL(NODE) \\"}]}