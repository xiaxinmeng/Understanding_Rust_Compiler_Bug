{"sha": "507d0069fa46a93942923e13401657bd6657f09c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA3ZDAwNjlmYTQ2YTkzOTQyOTIzZTEzNDAxNjU3YmQ2NjU3ZjA5Yw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-12-14T10:12:43Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-12-14T10:12:43Z"}, "message": "tm.texi (STACK_CHECK_PROTECT): Document alternate default.\n\n\t* doc/tm.texi (STACK_CHECK_PROTECT): Document alternate default.\n\t* doc/md.texi (check_stack): Clarify.\n\t(probe_stack): Likewise.\n\t* config/rs6000/rs6000.md (UNSPEC_PROBE_STACK): New constant.\n\t(probe_stack): New insn.\n\nFrom-SVN: r155209", "tree": {"sha": "999bee6c97004ffe981f7e2afea48d55dd659425", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/999bee6c97004ffe981f7e2afea48d55dd659425"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/507d0069fa46a93942923e13401657bd6657f09c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/507d0069fa46a93942923e13401657bd6657f09c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/507d0069fa46a93942923e13401657bd6657f09c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/507d0069fa46a93942923e13401657bd6657f09c/comments", "author": null, "committer": null, "parents": [{"sha": "e11ddaf56e62243e381e6c1db50fb53aee23d7e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e11ddaf56e62243e381e6c1db50fb53aee23d7e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e11ddaf56e62243e381e6c1db50fb53aee23d7e2"}], "stats": {"total": 47, "additions": 32, "deletions": 15}, "files": [{"sha": "207095cc2ba9b644ca88e0fe28a8290e49aa2600", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507d0069fa46a93942923e13401657bd6657f09c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507d0069fa46a93942923e13401657bd6657f09c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=507d0069fa46a93942923e13401657bd6657f09c", "patch": "@@ -1,3 +1,11 @@\n+2009-12-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* doc/tm.texi (STACK_CHECK_PROTECT): Document alternate default.\n+\t* doc/md.texi (check_stack): Clarify.\n+\t(probe_stack): Likewise.\n+\t* config/rs6000/rs6000.md (UNSPEC_PROBE_STACK): New constant.\n+\t(probe_stack): New insn.\n+\n 2009-12-14  Ben Elliston  <bje@au.ibm.com>\n \n \t* lto-streamer-in.c (lto_get_builtin_tree): fclass can only be a"}, {"sha": "5e959db7ebcc4e03f6c3630d640b1a949e1de2ce", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507d0069fa46a93942923e13401657bd6657f09c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507d0069fa46a93942923e13401657bd6657f09c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=507d0069fa46a93942923e13401657bd6657f09c", "patch": "@@ -55,6 +55,7 @@\n \n (define_constants\n   [(UNSPEC_FRSP\t\t\t0)\t; frsp for POWER machines\n+   (UNSPEC_PROBE_STACK\t\t4)\t; probe stack memory reference\n    (UNSPEC_TIE\t\t\t5)\t; tie stack contents and stack pointer\n    (UNSPEC_TOCPTR\t\t6)\t; address of a word pointing to the TOC\n    (UNSPEC_TOC\t\t\t7)\t; address of the TOC (more-or-less)\n@@ -12549,6 +12550,13 @@\n   [(unspec_volatile [(const_int 0)] UNSPECV_BLOCK)]\n   \"\"\n   \"\")\n+\n+(define_insn \"probe_stack\"\n+  [(unspec [(match_operand 0 \"memory_operand\" \"=m\")] UNSPEC_PROBE_STACK)]\n+  \"\"\n+  \"{st%U0%X0|stw%U0%X0} 0,%0\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"4\")])\n \f\n ;; Compare insns are next.  Note that the RS/6000 has two types of compares,\n ;; signed & unsigned, and one type of branch."}, {"sha": "5a92a809fc641a5298d6217cdb72119eb500fce4", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507d0069fa46a93942923e13401657bd6657f09c/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507d0069fa46a93942923e13401657bd6657f09c/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=507d0069fa46a93942923e13401657bd6657f09c", "patch": "@@ -5035,21 +5035,20 @@ operations in addition to updating the stack pointer.\n \n @cindex @code{check_stack} instruction pattern\n @item @samp{check_stack}\n-If stack checking cannot be done on your system by probing the stack with\n-a load or store instruction (@pxref{Stack Checking}), define this pattern\n-to perform the needed check and signal an error if the stack has overflowed.\n-The single operand is the address in the stack furthest from the current\n-stack pointer that you need to validate.  Normally, on machines where this\n-pattern is needed, you would obtain the stack limit from a global or\n-thread-specific variable or register.\n+If stack checking (@pxref{Stack Checking}) cannot be done on your system by\n+probing the stack, define this pattern to perform the needed check and signal\n+an error if the stack has overflowed.  The single operand is the address in\n+the stack farthest from the current stack pointer that you need to validate.\n+Normally, on platforms where this pattern is needed, you would obtain the\n+stack limit from a global or thread-specific variable or register.\n \n @cindex @code{probe_stack} instruction pattern\n @item @samp{probe_stack}\n-If stack checking can be done on your system by probing the stack but doing\n-it with a load or store instruction is not optimal (@pxref{Stack Checking}),\n-define this pattern to do the probing differently and signal an error if\n-the stack has overflowed.  The single operand is the memory location in the\n-stack that needs to be probed.\n+If stack checking (@pxref{Stack Checking}) can be done on your system by\n+probing the stack but doing it with a ``store zero'' instruction is not valid\n+or optimal, define this pattern to do the probing differently and signal an\n+error if the stack has overflowed.  The single operand is the memory reference\n+in the stack that needs to be probed.\n \n @cindex @code{nonlocal_goto} instruction pattern\n @item @samp{nonlocal_goto}"}, {"sha": "6a2991777cf1bb4e93c829a3fb234dddacc7b95b", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507d0069fa46a93942923e13401657bd6657f09c/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507d0069fa46a93942923e13401657bd6657f09c/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=507d0069fa46a93942923e13401657bd6657f09c", "patch": "@@ -3574,9 +3574,11 @@ default value of this macro is zero.\n @end defmac\n \n @defmac STACK_CHECK_PROTECT\n-The number of bytes of stack needed to recover from a stack overflow,\n-for languages where such a recovery is supported.  The default value of\n-75 words should be adequate for most machines.\n+The number of bytes of stack needed to recover from a stack overflow, for\n+languages where such a recovery is supported.  The default value of 75 words\n+with the @code{setjmp}/@code{longjmp}-based exception handling mechanism and\n+8192 bytes with other exception handling mechanisms should be adequate for\n+most machines.\n @end defmac\n \n The following macros are relevant only if neither STACK_CHECK_BUILTIN"}]}