{"sha": "8aa23fe306c816b02ff00a1419489b2fd071ae16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFhMjNmZTMwNmM4MTZiMDJmZjAwYTE0MTk0ODliMmZkMDcxYWUxNg==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2007-04-06T09:20:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:20:52Z"}, "message": "exp_dist.ads, [...] (Build_To_Any_Call, [...]): Do an Unchecked_Conversion to handle the passage from the Underlying Type to...\n\n2007-04-06  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_dist.ads, exp_dist.adb (Build_To_Any_Call, Build_From_Any_Call):\n\tDo an Unchecked_Conversion to handle the passage from the Underlying\n\tType to the Base Type when calling Build_To_Any_Call and\n\tBuild_From_Any_Call.\n\t(Build_Actual_Object_Declaration): Set Object's Ekind to E_Variable or\n\tE_Constant, depending upon Variable formal.\n\t(GARLIC_Support.Build_Subprogram_Receiving_Stubs,\n\tPolyORB_Support.Build_Subprogram_Receiving_Stubs): For a formal\n\tparameter that requires an extra constrained parameter, declare\n\ttemporary for actual as a variable, not a constant.\n\t(Add_RACW_Primitive_Declarations_And_Bodies): Generate bodies only when\n\tthe unit being compiled is the one that contains the stub type.\n\tChange primitive operation name for the RACW associated with a RAS\n\tfrom Call to _Call so it cannot clash with any legal identifier.\n\t(PolyORB_Support.Add_RACW_Write_Attribute): Remove unused constant\n\tIs_RAS.\n\t(Append_RACW_Bodies): New subprogram.\n\t(Expand_Receiving_Stubs_Bodies): Pass a 'Stmts' list to\n\tAdd_Receiving_Stubs_To_Declarations functions.\n\tWhen expanding a package body, this list correspond to the\n\tstatements in the HSS at the end of the pacakge.\n\tWhen expanding a package spec, this list correspond to the\n\tspec declarations.\n\t(Add_Receiving_Stubs_To_Declarations): Append the function\n\tregistering the receiving stubs at the end of the 'Stmts' list.\n\t(RCI_Package_Locator): Pass the new Version generic formal when\n\tinstantiating a RCI_Locator package.\n\t(Build_From_Any_Function): To compute the High bound for an\n\tunconstrained array actual, we add the Low bound with the length.\n\tThus we must convert the low bound and the length to an appropriate\n\ttype before doing the sum.\n\t(Build_Subprogram_Receiving_Stubs, PolyORB):\n\t * Retrieve the extra formals parameters at the\n\t   end of the parameter stream.\n\t * Use Move_Any_Value to write back out parameters\n\t   after executing the request as it is more efficient\n\t   than Copy_Any_Value.\n\t * Build the any containing Extra Formals with the\n\t   appropriate typecode.\n\t(PolyORB_Support.Helpers.Append_Record_Traversal): Nothing to do for an\n\tempty Component_List.\n\t(Build_Actual_Object_Declaration): New subprogram. Build and insert into\n\tthe tree the declaration for an object that serves as actual parameter\n\tin server-side stubs.\n\t(GARLIC_Support.Build_Subprogram_Receiving_Stubs,\n\tPolyORB_Support.Build_Subprogram_Receiving_Stubs):\n\tUse Build_Actual_Object_Declaration to prepare the actuals.\n\t(Add_Parameter_To_NVList): Set the parameter mode to In for\n\tExtra Constrained Parameters.\n\t(Build_General_Calling_Stubs): Set the parameter type to boolean for\n\tExtra Constrained parameters.\n\t(Build_To_Any_Function, Build_From_Any_Function,\n\tBuilt_TypeCode_Function): When Typ is implicit, call the correct\n\tfunction with the first not implicit parent type.\n\t(TC_Rec_Add_Process_Element, FA_Rec_Add_Process_Element,\n\t(FA_Ary_Add_Process_Element): When Datum is an Any, we cannot infer the\n\ttypecode from the Etype. Therefore we retrieve the correct typecode\n\twith a call to Get_Any_Type.\n\t(Copy_Specification): Do controlling formal type substitution based on\n\tIs_Controlling_Formal flag, instead of caller-provided object type.\n\t(Build_Subprogram_Calling_Stubs): When retrieveing the original spec for\n\ta RACW primitive operation, we might get a subprogram declaration for an\n\tancestor of the RACW designated type (not for the designated type\n\titself), in the case where this operation is inherited. In this case we\n\thave no easy means of determining the original tagged type for which\n\tthe primitive was declared, so instead we now rely on\n\tCopy_Specification to use the Is_Controlling_Formal flag to determine\n\twhich formals require type substitution.\n\nFrom-SVN: r123565", "tree": {"sha": "0dd48c34b08c529fb9f2e08df639fdaa6fe62e88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0dd48c34b08c529fb9f2e08df639fdaa6fe62e88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8aa23fe306c816b02ff00a1419489b2fd071ae16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aa23fe306c816b02ff00a1419489b2fd071ae16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8aa23fe306c816b02ff00a1419489b2fd071ae16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aa23fe306c816b02ff00a1419489b2fd071ae16/comments", "author": null, "committer": null, "parents": [{"sha": "cc2c4c656715397ac4f815c5b4987c03dd839cbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc2c4c656715397ac4f815c5b4987c03dd839cbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc2c4c656715397ac4f815c5b4987c03dd839cbf"}], "stats": {"total": 1421, "additions": 976, "deletions": 445}, "files": [{"sha": "9e97bb10bf587b321e532466df2242c2aded25fb", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 959, "deletions": 435, "changes": 1394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aa23fe306c816b02ff00a1419489b2fd071ae16/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aa23fe306c816b02ff00a1419489b2fd071ae16/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=8aa23fe306c816b02ff00a1419489b2fd071ae16"}, {"sha": "5e9361c366819fe6d597773099e8662a318fac82", "filename": "gcc/ada/exp_dist.ads", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aa23fe306c816b02ff00a1419489b2fd071ae16/gcc%2Fada%2Fexp_dist.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aa23fe306c816b02ff00a1419489b2fd071ae16/gcc%2Fada%2Fexp_dist.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.ads?ref=8aa23fe306c816b02ff00a1419489b2fd071ae16", "patch": "@@ -44,7 +44,7 @@ package Exp_Dist is\n    procedure Add_RACW_Primitive_Declarations_And_Bodies\n      (Designated_Type : Entity_Id;\n       Insertion_Node  : Node_Id;\n-      Decls           : List_Id);\n+      Body_Decls      : List_Id);\n    --  Add primitive for the stub type, and the RPC receiver. The declarations\n    --  are inserted after insertion_Node, while the bodies are appened at the\n    --  end of Decls.\n@@ -86,21 +86,28 @@ package Exp_Dist is\n    function Copy_Specification\n      (Loc         : Source_Ptr;\n       Spec        : Node_Id;\n-      Object_Type : Entity_Id := Empty;\n-      Stub_Type   : Entity_Id := Empty;\n+      Ctrl_Type   : Entity_Id := Empty;\n       New_Name    : Name_Id   := No_Name) return Node_Id;\n-   --  Build a subprogram specification from another one, or from\n-   --  an access-to-subprogram definition. If Object_Type is not Empty\n-   --  and any access to Object_Type is found, then it is replaced by an\n-   --  access to Stub_Type. If New_Name is given, then it will be used as\n-   --  the name for the newly created spec.\n+   --  Build a subprogram specification from another one, or from an\n+   --  access-to-subprogram definition. If Ctrl_Type is not Empty, and any\n+   --  controlling formal of an anonymous access type is found, then it is\n+   --  replaced by an access to Ctrl_Type. If New_Name is given, then it will\n+   --  be used as the name for the newly created spec.\n \n    function Corresponding_Stub_Type (RACW_Type : Entity_Id) return Entity_Id;\n    --  Return the stub type associated with the given RACW type\n \n-   function Underlying_RACW_Type\n-     (RAS_Typ : Entity_Id) return Entity_Id;\n+   function Underlying_RACW_Type (RAS_Typ : Entity_Id) return Entity_Id;\n    --  Given a remote access-to-subprogram type or its equivalent\n    --  record type, return the RACW type generated to implement it.\n \n+   procedure Append_RACW_Bodies (Decls : List_Id; Spec_Id : Entity_Id);\n+   --  Append the unanalyzed subprogram bodies generated to support RACWs\n+   --  declared in the given package spec (RACW stream subprograms, calling\n+   --  stubs primitive operations) to the given list (which is expected to be\n+   --  the declarations list for the corresponding package body, if there is\n+   --  one). In the case where a body is present, the subprogram bodies must\n+   --  not be generated in the package spec because this would cause an\n+   --  incorrect attempt to freeze Taft amendment types declared in the spec.\n+\n end Exp_Dist;"}]}