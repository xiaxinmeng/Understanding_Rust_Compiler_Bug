{"sha": "6943af07e9a1ba93d78640998520cbcf10f05fd0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk0M2FmMDdlOWExYmE5M2Q3ODY0MDk5ODUyMGNiY2YxMGYwNWZkMA==", "commit": {"author": {"name": "Alexander Monakov", "email": "amonakov@gcc.gnu.org", "date": "2017-01-20T14:04:06Z"}, "committer": {"name": "Alexander Monakov", "email": "amonakov@gcc.gnu.org", "date": "2017-01-20T14:04:06Z"}, "message": "omp-low: introduce omplow_simd_context\n\n\t* omp-low.c (omplow_simd_context): New struct.  Use it...\n\t(lower_rec_simd_input_clauses): ...here and...\n\t(lower_rec_input_clauses): ...here to hold common data.  Adjust all\n\treferences to idx, lane, max_vf, is_simt.\n\nFrom-SVN: r244713", "tree": {"sha": "3268116614da9bd6cf9974f415c84b5813dd44b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3268116614da9bd6cf9974f415c84b5813dd44b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6943af07e9a1ba93d78640998520cbcf10f05fd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6943af07e9a1ba93d78640998520cbcf10f05fd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6943af07e9a1ba93d78640998520cbcf10f05fd0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6943af07e9a1ba93d78640998520cbcf10f05fd0/comments", "author": null, "committer": null, "parents": [{"sha": "7b96920e20d3f3d47f78e7a729b6527698fe732c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b96920e20d3f3d47f78e7a729b6527698fe732c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b96920e20d3f3d47f78e7a729b6527698fe732c"}], "stats": {"total": 127, "additions": 70, "deletions": 57}, "files": [{"sha": "99ee63537ca829d940055445bd2dff59e36a9f22", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6943af07e9a1ba93d78640998520cbcf10f05fd0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6943af07e9a1ba93d78640998520cbcf10f05fd0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6943af07e9a1ba93d78640998520cbcf10f05fd0", "patch": "@@ -1,23 +1,30 @@\n+2017-01-20  Alexander Monakov  <amonakov@ispras.ru>\n+\n+\t* omp-low.c (omplow_simd_context): New struct.  Use it...\n+\t(lower_rec_simd_input_clauses): ...here and...\n+\t(lower_rec_input_clauses): ...here to hold common data.  Adjust all\n+\treferences to idx, lane, max_vf, is_simt.\n+\n 2017-01-20  Graham Markall  <graham.markall@embecosm.com>\n \n \t* config/arc/arc.h (LINK_SPEC): Use arclinux_nps emulation when\n \tmcpu=nps400.\n \n 2017-01-20  Martin Jambor  <mjambor@suse.cz>\n \n-        * hsa.h: Renaed to hsa-common.h.  Adjusted a comment.\n-        * hsa.c: Renaed to hsa-common.c.  Change include of gt-hsa.h to\n-        gt-hsa-common.h.\n-        * Makefile.in (OBJS): Rename hsa.o to hsa-common.o.\n-        (GTFILES): Rename hsa.c to hsa-common.c.\n-        * hsa-brig.c: Change include of hsa.h to hsa-common.h.\n-        * hsa-dump.c: Likewise.\n-        * hsa-gen.c: Likewise.\n-        * hsa-regalloc.c: Likewise.\n-        * ipa-hsa.c: Likewise.\n-        * omp-expand.c: Likewise.\n-        * omp-low.c: Likewise.\n-        * toplev.c: Likewise.\n+\t* hsa.h: Renaed to hsa-common.h.  Adjusted a comment.\n+\t* hsa.c: Renaed to hsa-common.c.  Change include of gt-hsa.h to\n+\tgt-hsa-common.h.\n+\t* Makefile.in (OBJS): Rename hsa.o to hsa-common.o.\n+\t(GTFILES): Rename hsa.c to hsa-common.c.\n+\t* hsa-brig.c: Change include of hsa.h to hsa-common.h.\n+\t* hsa-dump.c: Likewise.\n+\t* hsa-gen.c: Likewise.\n+\t* hsa-regalloc.c: Likewise.\n+\t* ipa-hsa.c: Likewise.\n+\t* omp-expand.c: Likewise.\n+\t* omp-low.c: Likewise.\n+\t* toplev.c: Likewise.\n \n 2017-01-20  Marek Polacek  <polacek@redhat.com>\n "}, {"sha": "15209a3c3544efd3d30dd3db257a2f43a2299c7e", "filename": "gcc/omp-low.c", "status": "modified", "additions": 50, "deletions": 44, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6943af07e9a1ba93d78640998520cbcf10f05fd0/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6943af07e9a1ba93d78640998520cbcf10f05fd0/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=6943af07e9a1ba93d78640998520cbcf10f05fd0", "patch": "@@ -3445,52 +3445,59 @@ omp_clause_aligned_alignment (tree clause)\n   return build_int_cst (integer_type_node, al);\n }\n \n+\n+/* This structure is part of the interface between lower_rec_simd_input_clauses\n+   and lower_rec_input_clauses.  */\n+\n+struct omplow_simd_context {\n+  tree idx;\n+  tree lane;\n+  int max_vf;\n+  bool is_simt;\n+};\n+\n /* Helper function of lower_rec_input_clauses, used for #pragma omp simd\n    privatization.  */\n \n static bool\n-lower_rec_simd_input_clauses (tree new_var, omp_context *ctx, int &max_vf,\n-\t\t\t      tree &idx, tree &lane, tree &ivar, tree &lvar)\n+lower_rec_simd_input_clauses (tree new_var, omp_context *ctx,\n+\t\t\t      omplow_simd_context *sctx, tree &ivar, tree &lvar)\n {\n-  if (max_vf == 0)\n+  if (sctx->max_vf == 0)\n     {\n-      if (omp_find_clause (gimple_omp_for_clauses (ctx->stmt),\n-\t\t\t   OMP_CLAUSE__SIMT_))\n-\tmax_vf = omp_max_simt_vf ();\n-      else\n-\tmax_vf = omp_max_vf ();\n-      if (max_vf > 1)\n+      sctx->max_vf = sctx->is_simt ? omp_max_simt_vf () : omp_max_vf ();\n+      if (sctx->max_vf > 1)\n \t{\n \t  tree c = omp_find_clause (gimple_omp_for_clauses (ctx->stmt),\n \t\t\t\t    OMP_CLAUSE_SAFELEN);\n \t  if (c\n \t      && (TREE_CODE (OMP_CLAUSE_SAFELEN_EXPR (c)) != INTEGER_CST\n \t\t  || tree_int_cst_sgn (OMP_CLAUSE_SAFELEN_EXPR (c)) != 1))\n-\t    max_vf = 1;\n+\t    sctx->max_vf = 1;\n \t  else if (c && compare_tree_int (OMP_CLAUSE_SAFELEN_EXPR (c),\n-\t\t\t\t\t  max_vf) == -1)\n-\t    max_vf = tree_to_shwi (OMP_CLAUSE_SAFELEN_EXPR (c));\n+\t\t\t\t\t  sctx->max_vf) == -1)\n+\t    sctx->max_vf = tree_to_shwi (OMP_CLAUSE_SAFELEN_EXPR (c));\n \t}\n-      if (max_vf > 1)\n+      if (sctx->max_vf > 1)\n \t{\n-\t  idx = create_tmp_var (unsigned_type_node);\n-\t  lane = create_tmp_var (unsigned_type_node);\n+\t  sctx->idx = create_tmp_var (unsigned_type_node);\n+\t  sctx->lane = create_tmp_var (unsigned_type_node);\n \t}\n     }\n-  if (max_vf == 1)\n+  if (sctx->max_vf == 1)\n     return false;\n \n-  tree atype = build_array_type_nelts (TREE_TYPE (new_var), max_vf);\n+  tree atype = build_array_type_nelts (TREE_TYPE (new_var), sctx->max_vf);\n   tree avar = create_tmp_var_raw (atype);\n   if (TREE_ADDRESSABLE (new_var))\n     TREE_ADDRESSABLE (avar) = 1;\n   DECL_ATTRIBUTES (avar)\n     = tree_cons (get_identifier (\"omp simd array\"), NULL,\n \t\t DECL_ATTRIBUTES (avar));\n   gimple_add_tmp_var (avar);\n-  ivar = build4 (ARRAY_REF, TREE_TYPE (new_var), avar, idx,\n+  ivar = build4 (ARRAY_REF, TREE_TYPE (new_var), avar, sctx->idx,\n \t\t NULL_TREE, NULL_TREE);\n-  lvar = build4 (ARRAY_REF, TREE_TYPE (new_var), avar, lane,\n+  lvar = build4 (ARRAY_REF, TREE_TYPE (new_var), avar, sctx->lane,\n \t\t NULL_TREE, NULL_TREE);\n   if (DECL_P (new_var))\n     {\n@@ -3534,14 +3541,13 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n   int pass;\n   bool is_simd = (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n \t\t  && gimple_omp_for_kind (ctx->stmt) & GF_OMP_FOR_SIMD);\n-  bool maybe_simt = is_simd && omp_find_clause (clauses, OMP_CLAUSE__SIMT_);\n-  int max_vf = 0;\n-  tree lane = NULL_TREE, idx = NULL_TREE;\n+  omplow_simd_context sctx = omplow_simd_context ();\n   tree simt_lane = NULL_TREE;\n   tree ivar = NULL_TREE, lvar = NULL_TREE;\n   gimple_seq llist[3] = { };\n \n   copyin_seq = NULL;\n+  sctx.is_simt = is_simd && omp_find_clause (clauses, OMP_CLAUSE__SIMT_);\n \n   /* Set max_vf=1 (which will later enforce safelen=1) in simd loops\n      with data sharing clauses referencing variable sized vars.  That\n@@ -3553,18 +3559,18 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t{\n \tcase OMP_CLAUSE_LINEAR:\n \t  if (OMP_CLAUSE_LINEAR_ARRAY (c))\n-\t    max_vf = 1;\n+\t    sctx.max_vf = 1;\n \t  /* FALLTHRU */\n \tcase OMP_CLAUSE_PRIVATE:\n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n \tcase OMP_CLAUSE_LASTPRIVATE:\n \t  if (is_variable_sized (OMP_CLAUSE_DECL (c)))\n-\t    max_vf = 1;\n+\t    sctx.max_vf = 1;\n \t  break;\n \tcase OMP_CLAUSE_REDUCTION:\n \t  if (TREE_CODE (OMP_CLAUSE_DECL (c)) == MEM_REF\n \t      || is_variable_sized (OMP_CLAUSE_DECL (c)))\n-\t    max_vf = 1;\n+\t    sctx.max_vf = 1;\n \t  break;\n \tdefault:\n \t  continue;\n@@ -4119,8 +4125,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  tree y = lang_hooks.decls.omp_clause_dtor (c, new_var);\n \t\t  if ((TREE_ADDRESSABLE (new_var) || nx || y\n \t\t       || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE)\n-\t\t      && lower_rec_simd_input_clauses (new_var, ctx, max_vf,\n-\t\t\t\t\t\t       idx, lane, ivar, lvar))\n+\t\t      && lower_rec_simd_input_clauses (new_var, ctx, &sctx,\n+\t\t\t\t\t\t       ivar, lvar))\n \t\t    {\n \t\t      if (nx)\n \t\t\tx = lang_hooks.decls.omp_clause_default_ctor\n@@ -4229,8 +4235,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \n \t\t  if ((OMP_CLAUSE_CODE (c) != OMP_CLAUSE_LINEAR\n \t\t       || TREE_ADDRESSABLE (new_var))\n-\t\t      && lower_rec_simd_input_clauses (new_var, ctx, max_vf,\n-\t\t\t\t\t\t       idx, lane, ivar, lvar))\n+\t\t      && lower_rec_simd_input_clauses (new_var, ctx, &sctx,\n+\t\t\t\t\t\t       ivar, lvar))\n \t\t    {\n \t\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINEAR)\n \t\t\t{\n@@ -4312,8 +4318,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t      gcc_assert (DECL_P (new_vard));\n \t\t    }\n \t\t  if (is_simd\n-\t\t      && lower_rec_simd_input_clauses (new_var, ctx, max_vf,\n-\t\t\t\t\t\t       idx, lane, ivar, lvar))\n+\t\t      && lower_rec_simd_input_clauses (new_var, ctx, &sctx,\n+\t\t\t\t\t\t       ivar, lvar))\n \t\t    {\n \t\t      if (new_vard == new_var)\n \t\t\t{\n@@ -4406,14 +4412,14 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t      gcc_assert (DECL_P (new_vard));\n \t\t    }\n \t\t  if (is_simd\n-\t\t      && lower_rec_simd_input_clauses (new_var, ctx, max_vf,\n-\t\t\t\t\t\t       idx, lane, ivar, lvar))\n+\t\t      && lower_rec_simd_input_clauses (new_var, ctx, &sctx,\n+\t\t\t\t\t\t       ivar, lvar))\n \t\t    {\n \t\t      tree ref = build_outer_var_ref (var, ctx);\n \n \t\t      gimplify_assign (unshare_expr (ivar), x, &llist[0]);\n \n-\t\t      if (maybe_simt)\n+\t\t      if (sctx.is_simt)\n \t\t\t{\n \t\t\t  if (!simt_lane)\n \t\t\t    simt_lane = create_tmp_var (unsigned_type_node);\n@@ -4457,22 +4463,22 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t}\n     }\n \n-  if (lane)\n+  if (sctx.lane)\n     {\n       tree uid = create_tmp_var (ptr_type_node, \"simduid\");\n       /* Don't want uninit warnings on simduid, it is always uninitialized,\n \t but we use it not for the value, but for the DECL_UID only.  */\n       TREE_NO_WARNING (uid) = 1;\n       gimple *g\n \t= gimple_build_call_internal (IFN_GOMP_SIMD_LANE, 1, uid);\n-      gimple_call_set_lhs (g, lane);\n+      gimple_call_set_lhs (g, sctx.lane);\n       gimple_stmt_iterator gsi = gsi_start_1 (gimple_omp_body_ptr (ctx->stmt));\n       gsi_insert_before_without_update (&gsi, g, GSI_SAME_STMT);\n       c = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE__SIMDUID_);\n       OMP_CLAUSE__SIMDUID__DECL (c) = uid;\n       OMP_CLAUSE_CHAIN (c) = gimple_omp_for_clauses (ctx->stmt);\n       gimple_omp_for_set_clauses (ctx->stmt, c);\n-      g = gimple_build_assign (lane, INTEGER_CST,\n+      g = gimple_build_assign (sctx.lane, INTEGER_CST,\n \t\t\t       build_int_cst (unsigned_type_node, 0));\n       gimple_seq_add_stmt (ilist, g);\n       /* Emit reductions across SIMT lanes in log_2(simt_vf) steps.  */\n@@ -4488,7 +4494,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t  gimple_seq_add_stmt (dlist, g);\n \n \t  t = build_int_cst (unsigned_type_node, 0);\n-\t  g = gimple_build_assign (idx, INTEGER_CST, t);\n+\t  g = gimple_build_assign (sctx.idx, INTEGER_CST, t);\n \t  gimple_seq_add_stmt (dlist, g);\n \n \t  tree body = create_artificial_label (UNKNOWN_LOCATION);\n@@ -4517,7 +4523,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t    gimple_seq *seq = i == 0 ? ilist : dlist;\n \t    gimple_seq_add_stmt (seq, g);\n \t    tree t = build_int_cst (unsigned_type_node, 0);\n-\t    g = gimple_build_assign (idx, INTEGER_CST, t);\n+\t    g = gimple_build_assign (sctx.idx, INTEGER_CST, t);\n \t    gimple_seq_add_stmt (seq, g);\n \t    tree body = create_artificial_label (UNKNOWN_LOCATION);\n \t    tree header = create_artificial_label (UNKNOWN_LOCATION);\n@@ -4526,10 +4532,10 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t    gimple_seq_add_stmt (seq, gimple_build_label (body));\n \t    gimple_seq_add_seq (seq, llist[i]);\n \t    t = build_int_cst (unsigned_type_node, 1);\n-\t    g = gimple_build_assign (idx, PLUS_EXPR, idx, t);\n+\t    g = gimple_build_assign (sctx.idx, PLUS_EXPR, sctx.idx, t);\n \t    gimple_seq_add_stmt (seq, g);\n \t    gimple_seq_add_stmt (seq, gimple_build_label (header));\n-\t    g = gimple_build_cond (LT_EXPR, idx, vf, body, end);\n+\t    g = gimple_build_cond (LT_EXPR, sctx.idx, vf, body, end);\n \t    gimple_seq_add_stmt (seq, g);\n \t    gimple_seq_add_stmt (seq, gimple_build_label (end));\n \t  }\n@@ -4565,18 +4571,18 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \n   /* If max_vf is non-zero, then we can use only a vectorization factor\n      up to the max_vf we chose.  So stick it into the safelen clause.  */\n-  if (max_vf)\n+  if (sctx.max_vf)\n     {\n       tree c = omp_find_clause (gimple_omp_for_clauses (ctx->stmt),\n \t\t\t\tOMP_CLAUSE_SAFELEN);\n       if (c == NULL_TREE\n \t  || (TREE_CODE (OMP_CLAUSE_SAFELEN_EXPR (c)) == INTEGER_CST\n \t      && compare_tree_int (OMP_CLAUSE_SAFELEN_EXPR (c),\n-\t\t\t\t   max_vf) == 1))\n+\t\t\t\t   sctx.max_vf) == 1))\n \t{\n \t  c = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE_SAFELEN);\n \t  OMP_CLAUSE_SAFELEN_EXPR (c) = build_int_cst (integer_type_node,\n-\t\t\t\t\t\t       max_vf);\n+\t\t\t\t\t\t       sctx.max_vf);\n \t  OMP_CLAUSE_CHAIN (c) = gimple_omp_for_clauses (ctx->stmt);\n \t  gimple_omp_for_set_clauses (ctx->stmt, c);\n \t}"}]}