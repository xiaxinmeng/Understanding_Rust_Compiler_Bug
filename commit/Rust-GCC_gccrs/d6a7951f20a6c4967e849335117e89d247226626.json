{"sha": "d6a7951f20a6c4967e849335117e89d247226626", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZhNzk1MWYyMGE2YzQ5NjdlODQ5MzM1MTE3ZTg5ZDI0NzIyNjYyNg==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2001-12-09T20:13:19Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2001-12-09T20:13:19Z"}, "message": "ChangeLog.2, [...]: Fix spelling errors.\n\n\t* ChangeLog.2, ChangeLog.3, ChangeLog.5, ChangeLog, alias.c,\n\tcfgbuild.c, expmed.c, expr.c, final.c, flow.c, fold-const.c,\n\tfunction.c, config/alpha/alpha.md, config/alpha/vms-ld.c,\n\tconfig/arm/arm.c, config/arm/arm.h, config/c4x/libgcc.S,\n\tconfig/i370/i370.c, config/i386/i386.c,\n\tconfig/i386/i386-interix.h, config/i386/i386.md,\n\tconfig/i386/i386.h, config/i386/netbsd-elf.h, config/ia64/ia64.c,\n\tconfig/m32r/m32r-protos.h, config/mcore/mcore.h,\n\tconfig/rs6000/rs6000.h, config/sparc/linux64.h,\n\tconfig/sparc/sparc.c, config/v850/v850-protos.h,\n\tconfig/cris/cris.h, config/s390/s390.md, config/elfos.h: Fix\n\tspelling errors.\n\nFrom-SVN: r47815", "tree": {"sha": "ae9b31b029da267f3af8b8560c16a915dfd3a79c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae9b31b029da267f3af8b8560c16a915dfd3a79c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6a7951f20a6c4967e849335117e89d247226626", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6a7951f20a6c4967e849335117e89d247226626", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6a7951f20a6c4967e849335117e89d247226626", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6a7951f20a6c4967e849335117e89d247226626/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "617e0e1d1225259b70d0fd9b50783a1e30758934", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/617e0e1d1225259b70d0fd9b50783a1e30758934", "html_url": "https://github.com/Rust-GCC/gccrs/commit/617e0e1d1225259b70d0fd9b50783a1e30758934"}], "stats": {"total": 165, "additions": 90, "deletions": 75}, "files": [{"sha": "44ddefb025a68d281b7c8fdfd91f822ce14de544", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -1,3 +1,18 @@\n+2001-12-09  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* ChangeLog.2, ChangeLog.3, ChangeLog.5, ChangeLog, alias.c,\n+\tcfgbuild.c, expmed.c, expr.c, final.c, flow.c, fold-const.c,\n+\tfunction.c, config/alpha/alpha.md, config/alpha/vms-ld.c,\n+\tconfig/arm/arm.c, config/arm/arm.h, config/c4x/libgcc.S,\n+\tconfig/i370/i370.c, config/i386/i386.c,\n+\tconfig/i386/i386-interix.h, config/i386/i386.md,\n+\tconfig/i386/i386.h, config/i386/netbsd-elf.h, config/ia64/ia64.c,\n+\tconfig/m32r/m32r-protos.h, config/mcore/mcore.h,\n+\tconfig/rs6000/rs6000.h, config/sparc/linux64.h,\n+\tconfig/sparc/sparc.c, config/v850/v850-protos.h,\n+\tconfig/cris/cris.h, config/s390/s390.md, config/elfos.h: Fix\n+\tspelling errors.\n+\n 2001-12-09  Daniel Berlin  <dan@cgsoftware.com>\n \n \t* config/rs6000/rs6000.h (enum rs6000_builtins): Add remaining\n@@ -101,7 +116,7 @@\n \t* arm.h (arm_builtins): Delete ARM_BUILTIN_PREFETCH).\n \t* arm.c (arm_init_builtins): Don't initialize a builtin for\n \t__builtin_prefetch here.\n-\t(arm_expand_builtin): Dont expand __builtin_prefetch here.\n+\t(arm_expand_builtin): Don't expand __builtin_prefetch here.\n \n 2001-12-08  Richard Earnshaw  <rearnsha@arm.com>\n \n@@ -1104,11 +1119,11 @@ objc:\n \n \t* config/rs6000/rs6000.md: Add attribute types vecsimple,\n \tveccomplex, vecfloat, and vecperm, for altivec instructions.\n-\tModify altivec patterns to use approriate attribute type.\n-\tModify altivec patterns to match RTL operations where approriate\n+\tModify altivec patterns to use appropriate attribute type.\n+\tModify altivec patterns to match RTL operations where appropriate\n \t(IE no unspec where we can avoid it).\n \tAdd vector unit scheduling for ppc7450.\n-\tRename patterns to what they are where approriate\n+\tRename patterns to what they are where appropriate\n \t(altivec_vaddfp->addv4sf3, etc)\n \n \t* config/rs6000/rs6000.h (enum rs6000_builtins): Change VRS->VSR."}, {"sha": "e49d764994ae2da25f2775672a9227f7b9df7f56", "filename": "gcc/ChangeLog.2", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2FChangeLog.2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2FChangeLog.2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.2?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -5307,7 +5307,7 @@ Thu Oct 14 01:49:54 1999  Richard Henderson  <rth@cygnus.com>\n \t(NUM_SPECIAL_MODE_PREDS): New.\n \t(find_operand): New.\n \t(validate_pattern): New argument `insn'.  Warn for assignment to\n-\tany predicate accepting non-lvalues.  Conditionaly warn for\n+\tany predicate accepting non-lvalues.  Conditionally warn for\n \tmatch_operand without a mode.  Try much harder to match source\n \tand destination modes on a set.\n \t* tm.texi (SPECIAL_MODE_PREDICATES): Document.\n@@ -14051,7 +14051,7 @@ Fri Jun  4 03:20:40 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t* sh.h (PREDICATE_CODES): Remove braf_label_ref_operand.\n \t* sh.md (casesi_jump_2): Operand1 is now the inside of a\n \tlabel_ref, and has no predicate.\n-\tThe patten has a predicate to guard against invalid substitutions.\n+\tThe pattern has a predicate to guard against invalid substitutions.\n \t(dummy_jump): Delete.\n \t(casesi): Update use of casesi_jump_2.\n "}, {"sha": "c3a4461d4af0ab31e67d1a0754aa0e8950475552", "filename": "gcc/ChangeLog.3", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2FChangeLog.3", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2FChangeLog.3", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.3?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -2667,7 +2667,7 @@ Thu May 25 02:09:10 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n 2000-05-24  Mark Mitchell  <mark@codesourcery.com>\n \n \t* calls.c (expand_call): Handle cleanups in tail-recursion\n-\targuments analagously to cleanups in sibling calls.\n+\targuments analogously to cleanups in sibling calls.\n \n 2000-05-24  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n "}, {"sha": "40eccd1ef84e28d6ba7d9531b33ac7be7ef925a8", "filename": "gcc/ChangeLog.5", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2FChangeLog.5", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2FChangeLog.5", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.5?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -12298,7 +12298,7 @@ Tue Jan 16 17:20:43 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n 2001-01-14  Ralf Baechle <ralf@gnu.org>\n \n \t* config/mips/linux.h (SUBTARGET_CPP_SPEC): Default ABI is 32; change\n-\tSUBTARGET_CPP_SPEC apropriatly.\n+\tSUBTARGET_CPP_SPEC appropriately.\n \n 2001-01-12  Mark Mitchell  <mark@codesourcery.com>\n "}, {"sha": "b39be7311731d8df357d00a5edbea15191252603", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -1751,7 +1751,7 @@ nonoverlapping_component_refs_p (x, y)\n   do\n     {\n       /* The comparison has to be done at a common type, since we don't\n-\t know how the inheritance heirarchy works.  */\n+\t know how the inheritance hierarchy works.  */\n       orig_y = y;\n       do\n \t{"}, {"sha": "4d57917eeca26d8327bcdde69632cac62d9c52e9", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -133,7 +133,7 @@ control_flow_insn_p (insn)\n \n       case BARRIER:\n \t/* It is nonsence to reach barrier when looking for the\n-\t   end of basic block, but before dead code is elliminated\n+\t   end of basic block, but before dead code is eliminated\n \t   this may happen.  */\n \treturn false;\n "}, {"sha": "c9dbbaea7372ead8784c9717026524d1c4d55ad3", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -6633,7 +6633,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   [(set_attr \"length\" \"16\")\n    (set_attr \"type\" \"multi\")])\n \n-;; Close the trap shadow of preceeding instructions.  This is generated\n+;; Close the trap shadow of preceding instructions.  This is generated\n ;; by alpha_reorg.\n \n (define_insn \"trapb\""}, {"sha": "c02fe406d913e16d848ec35d43dea3197b59d0f5", "filename": "gcc/config/alpha/vms-ld.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Falpha%2Fvms-ld.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Falpha%2Fvms-ld.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms-ld.c?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -82,7 +82,7 @@ static char *search_dirs;\n /* Local function declarations.  */\n \n /* Add STR to the list of arguments to pass to the linker. Expand the list as\n-   necessary to accomodate.  */\n+   necessary to accommodate.  */\n static void addarg PARAMS ((const char *));\n \n /* Check to see if NAME is a regular file, i.e. not a directory */"}, {"sha": "98b9230a8e6452dbe7272692789db6283d209934", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -2132,8 +2132,8 @@ current_file_function_operand (sym_ref)\n     return 1;\n \n   /* The current function is always defined within the current compilation\n-     unit.  if it s a weak defintion however, then this may not be the real\n-     defintion of the function, and so we have to say no.  */\n+     unit.  if it s a weak definition however, then this may not be the real\n+     definition of the function, and so we have to say no.  */\n   if (sym_ref == XEXP (DECL_RTL (current_function_decl), 0)\n       && !DECL_WEAK (current_function_decl))\n     return 1;\n@@ -5348,7 +5348,7 @@ move_minipool_fix_forward_ref (mp, max_mp, max_address)\n   /* Save the new entry.  */\n   max_mp = mp;\n \n-  /* Scan over the preceeding entries and adjust their addresses as\n+  /* Scan over the preceding entries and adjust their addresses as\n      required.  */\n   while (mp->prev != NULL\n \t && mp->prev->max_address > mp->max_address - mp->prev->fix_size)\n@@ -5454,7 +5454,7 @@ add_minipool_forward_ref (fix)\n   /* Save the new entry.  */\n   max_mp = mp;\n \n-  /* Scan over the preceeding entries and adjust their addresses as\n+  /* Scan over the preceding entries and adjust their addresses as\n      required.  */\n   while (mp->prev != NULL\n \t && mp->prev->max_address > mp->max_address - mp->prev->fix_size)"}, {"sha": "b27192e9d217f1623aab22d47eedaf5305e86d2e", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -908,7 +908,7 @@ extern const char * structure_size_string;\n #if 0 /* FIXME: The ARM backend has special code to handle structure\n \t returns, and will reserve its own hidden first argument.  So\n \t if this macro is enabled a *second* hidden argument will be\n-\t reserved, which will break binary compatability with old\n+\t reserved, which will break binary compatibility with old\n \t toolchains and also thunk handling.  One day this should be\n \t fixed.  */\n /* RTX for structure returns.  NULL means use a hidden first argument.  */\n@@ -1044,7 +1044,7 @@ extern const char * structure_size_string;\n /* Register and constant classes.  */\n \n /* Register classes: used to be simple, just all ARM regs or all FPU regs\n-   Now that the Thumb is involved it has become more compilcated.  */\n+   Now that the Thumb is involved it has become more complicated.  */\n enum reg_class\n {\n   NO_REGS,\n@@ -1626,7 +1626,7 @@ typedef struct\n    pointer register.  Secondly, the pseudo frame pointer register can always\n    be eliminated; it is replaced with either the stack or the real frame\n    pointer.  Note we have to use {ARM|THUMB}_HARD_FRAME_POINTER_REGNUM\n-   because the defintion of HARD_FRAME_POINTER_REGNUM is not a constant.  */\n+   because the definition of HARD_FRAME_POINTER_REGNUM is not a constant.  */\n \n #define ELIMINABLE_REGS\t\t\t\t\t\t\\\n {{ ARG_POINTER_REGNUM,        STACK_POINTER_REGNUM            },\\"}, {"sha": "96b27d862caa1d8705e7b9ecf73caab9f059f8c2", "filename": "gcc/config/c4x/libgcc.S", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fc4x%2Flibgcc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fc4x%2Flibgcc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Flibgcc.S?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -1021,7 +1021,7 @@ mod3:\n #endif\n \n ;\n-; double to signed long long converion\n+; double to signed long long conversion\n ; input in r2\n ; result in r0,r1\n ;\n@@ -1049,7 +1049,7 @@ ___fix_truncqfhi2:\n #endif\n \n ;\n-; double to unsigned long long converion\n+; double to unsigned long long conversion\n ; input in r2\n ; result in r0,r1\n ;\n@@ -1095,7 +1095,7 @@ ufix1:\n #endif\n \n ;\n-; signed long long to double converion\n+; signed long long to double conversion\n ; input on stack\n ; result in r0\n ;\n@@ -1116,7 +1116,7 @@ ___floathiqf2:\n #endif\n \n ;\n-; unsigned long long to double converion\n+; unsigned long long to double conversion\n ; input on stack\n ; result in r0\n ;\n@@ -1166,7 +1166,7 @@ uflt2:\n #endif\n \n ;\n-; long double to signed long long converion\n+; long double to signed long long conversion\n ; input in r2\n ; result in r0,r1\n ;\n@@ -1195,7 +1195,7 @@ ___fix_trunchfhi2:\n #endif\n \n ;\n-; long double to unsigned long long converion\n+; long double to unsigned long long conversion\n ; input in r2\n ; result in r0,r1\n ;\n@@ -1242,7 +1242,7 @@ ufixh1:\n #endif\n \n ;\n-; signed long long to long double converion\n+; signed long long to long double conversion\n ; input on stack\n ; result in r0\n ;\n@@ -1263,7 +1263,7 @@ ___floathihf2:\n #endif\n \n ;\n-; unsigned long long to double converion\n+; unsigned long long to double conversion\n ; input on stack\n ; result in r0\n ;"}, {"sha": "d4ed6bc105316137071f09447318f79a39c42172", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -1603,7 +1603,7 @@ struct cum_args {int regs;};\n    tricks with the symbol type.  Not good if other tools than binutils\n    are used on the object files.  Since \".global ... .lcomm ...\" works, we\n    use that.  Use .._ALIGNED_COMMON, since gcc whines when we only have\n-   ..._COMMON, and we prefer to whine outselves; BIGGEST_ALIGNMENT is not\n+   ..._COMMON, and we prefer to whine ourselves; BIGGEST_ALIGNMENT is not\n    the one to check.  This done for a.out only.  */\n /* FIXME: I suspect a bug in gcc with alignment.  Do not warn until\n    investigated; it mucks up the testsuite results.  */"}, {"sha": "33e88154af3b9c7ed92bbfeff6668ec91f44715b", "filename": "gcc/config/elfos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Felfos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Felfos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felfos.h?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -358,7 +358,7 @@ const_section ()\t\t\t\t\t\t\\\n      relocations, so they get grouped together and dynamic linker\n      will visit fewer pages in memory.\n    .ro\n-     Marks data read only otherwise.  This is usefull with prelinking\n+     Marks data read only otherwise.  This is useful with prelinking\n      as most of relocations won't be dynamically linked and thus\n      stay read only.\n    .local"}, {"sha": "bbe27823e0ae95f94f5c8f421ed4d74db7695cc0", "filename": "gcc/config/i370/i370.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fi370%2Fi370.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fi370%2Fi370.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.c?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -504,7 +504,7 @@ i370_label_scan ()\n                else \n                  {\n /* XXX hack alert.\n-   Compiling the execption handling (L_eh) in libgcc2.a will trip\n+   Compiling the exception handling (L_eh) in libgcc2.a will trip\n    up right here, with something that looks like\n    (set (pc) (mem:SI (plus:SI (reg/v:SI 1 r1) (const_int 4))))\n       {indirect_jump} "}, {"sha": "1eae08638272d59ad2a3cc33395b975e2811a417", "filename": "gcc/config/i386/i386-interix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fi386%2Fi386-interix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fi386%2Fi386-interix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-interix.h?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -26,7 +26,7 @@ Boston, MA 02111-1307, USA.  */\n \n #define YES_UNDERSCORES\n \n-/* YES_UNDERSCORES must preceed gas.h */\n+/* YES_UNDERSCORES must precede gas.h */\n #include <i386/gas.h>\n /* The rest must follow.  */\n "}, {"sha": "703023acbdfaf554f67fd0cd85e822dacbf5bed8", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -1603,13 +1603,13 @@ classify_argument (mode, type, classes, bit_offset)\n \t  if (classes[i] == X86_64_MEMORY_CLASS)\n \t    return 0;\n \n-\t  /* The X86_64_SSEUP_CLASS should be always preceeded by\n+\t  /* The X86_64_SSEUP_CLASS should be always preceded by\n \t     X86_64_SSE_CLASS.  */\n \t  if (classes[i] == X86_64_SSEUP_CLASS\n \t      && (i == 0 || classes[i - 1] != X86_64_SSE_CLASS))\n \t    classes[i] = X86_64_SSE_CLASS;\n \n-\t  /*  X86_64_X87UP_CLASS should be preceeded by X86_64_X87_CLASS.  */\n+\t  /*  X86_64_X87UP_CLASS should be preceded by X86_64_X87_CLASS.  */\n \t  if (classes[i] == X86_64_X87UP_CLASS\n \t      && (i == 0 || classes[i - 1] != X86_64_X87_CLASS))\n \t    classes[i] = X86_64_SSE_CLASS;\n@@ -2579,7 +2579,7 @@ x86_64_general_operand (op, mode)\n }\n \n /* Return nonzero if OP is general operand representable on x86_64\n-   as eighter sign extended or zero extended constant.  */\n+   as either sign extended or zero extended constant.  */\n \n int\n x86_64_szext_general_operand (op, mode)\n@@ -3475,7 +3475,7 @@ x86_64_sign_extended_value (value)\n \t\t  /* For CM_KERNEL we know that all object resist in the\n \t\t     negative half of 32bits address space.  We may not\n \t\t     accept negative offsets, since they may be just off\n-\t\t     and we may accept pretty large possitive ones.  */\n+\t\t     and we may accept pretty large positive ones.  */\n \t\t  if (ix86_cmodel == CM_KERNEL\n \t\t      && offset > 0\n \t\t      && trunc_int_for_mode (offset, SImode) == offset)\n@@ -3545,7 +3545,7 @@ x86_64_zero_extended_value (value)\n \t      {\n \t\tcase SYMBOL_REF:\n \t\t    return 0;\n-\t\t  /* For small code model we may accept pretty large possitive\n+\t\t  /* For small code model we may accept pretty large positive\n \t\t     offsets, since one bit is available for free.  Negative\n \t\t     offsets are limited by the size of NULL pointer area\n \t\t     specified by the ABI.  */\n@@ -3557,7 +3557,7 @@ x86_64_zero_extended_value (value)\n \t\t    return 1;\n \t          /* ??? For the kernel, we may accept adjustment of\n \t\t     -0x10000000, since we know that it will just convert\n-\t\t     negative address space to possitive, but perhaps this\n+\t\t     negative address space to positive, but perhaps this\n \t\t     is not worthwhile.  */\n \t\t  break;\n \t\tcase LABEL_REF:\n@@ -6635,7 +6635,7 @@ ix86_binary_operator_ok (code, mode, operands)\n \t\t&& rtx_equal_p (operands[0], operands[2]))))\n     return 0;\n   /* If the operation is not commutable and the source 1 is memory, we must\n-     have a matching destionation.  */\n+     have a matching destination.  */\n   if (GET_CODE (operands[1]) == MEM\n       && GET_RTX_CLASS (code) != 'c'\n       && ! rtx_equal_p (operands[0], operands[1]))\n@@ -7572,7 +7572,7 @@ ix86_split_fp_branch (code, op1, op2, target1, target2, tmp)\n \t for UNORDERED.  */\n       probability = split_branch_probability;\n \n-      /* Value of 1 is low enought to make no need for probability\n+      /* Value of 1 is low enough to make no need for probability\n \t to be updated.  Later we may run some experiments and see\n \t if unordered values are more frequent in practice.  */\n       if (bypass)"}, {"sha": "1b24b2fc1da774ff03b3338cf62b22d94a596d17", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -1058,7 +1058,7 @@ extern int ix86_arch;\n /* Register to hold the addressing base for position independent\n    code access to data items.\n    We don't use PIC pointer for 64bit mode.  Define the regnum to\n-   dummy value to prevent gcc from pesimizing code dealing with EBX.\n+   dummy value to prevent gcc from pessimizing code dealing with EBX.\n  */\n #define PIC_OFFSET_TABLE_REGNUM (TARGET_64BIT ? INVALID_REGNUM : 3)\n "}, {"sha": "2ca29e0351f16a711289ba1798cd4ca0ea58ffad", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -5754,7 +5754,7 @@\n ; case of overflows,  the result is messed up.\n ; This pattern also don't hold of 0x8000000000000000, since the value overflows\n ; when negated.\n-; Also carry flag is reversed compared to cmp, so this converison is valid\n+; Also carry flag is reversed compared to cmp, so this conversion is valid\n ; only for comparisons not depending on it.\n (define_insn \"*adddi_4_rex64\"\n   [(set (reg 17)\n@@ -6182,7 +6182,7 @@\n ; case of overflows,  the result is messed up.\n ; This pattern also don't hold of 0x80000000, since the value overflows\n ; when negated.\n-; Also carry flag is reversed compared to cmp, so this converison is valid\n+; Also carry flag is reversed compared to cmp, so this conversion is valid\n ; only for comparisons not depending on it.\n (define_insn \"*addsi_4\"\n   [(set (reg 17)\n@@ -16306,7 +16306,7 @@\n    (set_attr \"mode\" \"DI\")])\n \n \n-;; Placeholder for the conditional moves.  This one is split eighter to SSE\n+;; Placeholder for the conditional moves.  This one is split either to SSE\n ;; based moves emulation or to usual cmove sequence.  Little bit unfortunate\n ;; fact is that compares supported by the cmp??ss instructions are exactly\n ;; swapped of those supported by cmove sequence.\n@@ -17149,7 +17149,7 @@\n ;; many CPUs it is also faster, since special hardware to avoid esp\n ;; dependencies is present.\n \n-;; While some of these converisons may be done using splitters, we use peepholes\n+;; While some of these conversions may be done using splitters, we use peepholes\n ;; in order to allow combine_stack_adjustments pass to see nonobfuscated RTL.\n \n ;; Convert prologue esp subtractions to push."}, {"sha": "cc6f3948539fbdd8cc4cc9d4abf92cf352edbe67", "filename": "gcc/config/i386/netbsd-elf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fi386%2Fnetbsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fi386%2Fnetbsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fnetbsd-elf.h?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -44,7 +44,7 @@ Boston, MA 02111-1307, USA.  */\n         %{!p:crt0%O%s}}} \\\n    %{!shared:crtbegin%O%s} %{shared:crtbeginS%O%s}\"\n \n-/* Provide an ENDFILE_SPEC approrpiate for NetBSD ELF targets.  Here we\n+/* Provide an ENDFILE_SPEC appropriate for NetBSD ELF targets.  Here we\n    add crtend.o, which provides part of the support for getting C++\n    file-scope static objects deconstructed after exiting `main'.  */\n "}, {"sha": "d282b70aebcf794a0284a048d5a3b15cbf94c66e", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -1673,7 +1673,7 @@ ia64_initial_elimination_offset (from, to)\n \n struct spill_fill_data\n {\n-  rtx init_after;\t\t/* point at which to emit intializations */\n+  rtx init_after;\t\t/* point at which to emit initializations */\n   rtx init_reg[2];\t\t/* initial base register */\n   rtx iter_reg[2];\t\t/* the iterator registers */\n   rtx *prev_addr[2];\t\t/* address of last memory use */"}, {"sha": "f76e6b918e249ca1fd0768a69b50926e67a97ed8", "filename": "gcc/config/m32r/m32r-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -19,7 +19,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n /* Function prototypes that cannot exist in v850.h due to dependency\n-   compilcations.  */\n+   complications.  */\n #define Mmode enum machine_mode\n \n extern void   sbss_section\t\t\tPARAMS ((void));"}, {"sha": "09371c47a1695f026d18c100f8ed87ed63228a39", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -66,7 +66,7 @@ Boston, MA 02111-1307, USA.  */\n %{!mbig-endian: -D__MCORELE__}\t\t\t\t\t\t\\\n %{!m210: -D__M340__}\t\t\t\t\t\t\t\\\n \"\n-/* If -m4align is ever re-enabled then add this line to the defintion of CPP_SPEC\n+/* If -m4align is ever re-enabled then add this line to the definition of CPP_SPEC\n    %{!m4align:-D__MCORE_ALIGN_8__} %{m4align:-D__MCORE__ALIGN_4__} */\n \n /* We don't have a -lg library, so don't put it in the list.  */"}, {"sha": "5ccc0aac614cc4e75a11e1822f9ae2d90974551c", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -700,7 +700,7 @@ extern int rs6000_altivec_abi;\n \n #define FIRST_PSEUDO_REGISTER 110\n \n-/* This must be included for pre gcc 3.0 glibc compatability.  */\n+/* This must be included for pre gcc 3.0 glibc compatibility.  */\n #define PRE_GCC3_DWARF_FRAME_REGISTERS 77\n \n /* 1 for registers that have pervasive standard uses"}, {"sha": "ea0edac4929141999ad9d58f45c95f68fb4302af", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -57,7 +57,7 @@\n   (const_string \"integer\"))\n \n ;; Insn are devide in two classes:\n-;;   mem: Insn accesssing memory\n+;;   mem: Insn accessing memory\n ;;   reg: Insn operands all in registers\n \n (define_attr \"atype\" \"reg,mem\""}, {"sha": "b82b31fcdd7965be1a507a608bbd16da80ad2323", "filename": "gcc/config/sparc/linux64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fsparc%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fsparc%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux64.h?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -362,7 +362,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* DWARF bits.  */\n \n /* Follow Irix 6 and not the Dwarf2 draft in using 64-bit offsets. \n-   Obviously the Dwarf2 folks havn't tried to actually build systems\n+   Obviously the Dwarf2 folks haven't tried to actually build systems\n    with their spec.  On a 64-bit system, only 64-bit relocs become\n    RELATIVE relocations.  */\n "}, {"sha": "2807add2849e5e2ae240dd0475081b70c4366d4f", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -2868,7 +2868,7 @@ load_pic_register ()\n   if (! flag_pic)\n     abort ();\n \n-  /* If we havn't emitted the special get_pc helper function, do so now.  */\n+  /* If we haven't emitted the special get_pc helper function, do so now.  */\n   if (get_pc_symbol_name[0] == 0)\n     {\n       int align;"}, {"sha": "a6fb8b92694d57d064530b212908d35473f03829", "filename": "gcc/config/v850/v850-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850-protos.h?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -19,7 +19,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n /* Function prototypes that cannot exist in v850.h due to dependency\n-   compilcations.  */\n+   complications.  */\n #ifndef GCC_V850_PROTOS_H\n #define GCC_V850_PROTOS_H\n "}, {"sha": "8a7b6b91d550bd8b0e91519c257674adccd6d20a", "filename": "gcc/expmed.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -3915,8 +3915,8 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n       if (rem_flag)\n \t{\n \t  /* Try to produce the remainder without producing the quotient.\n-\t     If we seem to have a divmod patten that does not require widening,\n-\t     don't try windening here.  We should really have an WIDEN argument\n+\t     If we seem to have a divmod pattern that does not require widening,\n+\t     don't try widening here.  We should really have an WIDEN argument\n \t     to expand_twoval_binop, since what we'd really like to do here is\n \t     1) try a mod insn in compute_mode\n \t     2) try a divmod insn in compute_mode"}, {"sha": "051dc20a71b9bd34b5396363ea36036d0080b891", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -1924,7 +1924,7 @@ move_block_from_reg (regno, x, nregs, size)\n /* Emit code to move a block SRC to a block DST, where DST is non-consecutive\n    registers represented by a PARALLEL.  SSIZE represents the total size of\n    block SRC in bytes, or -1 if not known.  */\n-/* ??? If SSIZE % UNITS_PER_WORD != 0, we make the blatent assumption that\n+/* ??? If SSIZE % UNITS_PER_WORD != 0, we make the blatant assumption that\n    the balance will be in what would be the low-order memory addresses, i.e.\n    left justified for big endian, right justified for little endian.  This\n    happens to be true for the targets currently using this support.  If this"}, {"sha": "1653138ff9eab097170d16aacb318792f5babafa", "filename": "gcc/final.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -475,7 +475,7 @@ int insn_current_address;\n /* Address of insn being processed in previous iteration.  */\n int insn_last_address;\n \n-/* konwn invariant alignment of insn being processed.  */\n+/* known invariant alignment of insn being processed.  */\n int insn_current_align;\n \n /* After shorten_branches, for any insn, uid_align[INSN_UID (insn)]\n@@ -717,7 +717,7 @@ label_to_alignment (label)\n    For casesi tables, we also want to know worst case minimum amounts of\n    address difference, in case a machine description wants to introduce\n    some common offset that is added to all offsets in a table.\n-   For this purpose, align_fuzz with a growth argument of 0 comuptes the\n+   For this purpose, align_fuzz with a growth argument of 0 computes the\n    appropriate adjustment.  */\n \n /* Compute the maximum delta by which the difference of the addresses of\n@@ -851,7 +851,7 @@ compute_alignments ()\n \n       /* There are two purposes to align block with no fallthru incoming edge:\n \t 1) to avoid fetch stalls when branch destination is near cache boundary\n-\t 2) to improve cache effciency in case the previous block is not executed\n+\t 2) to improve cache efficiency in case the previous block is not executed\n \t    (so it does not need to be in the cache).\n \n \t We to catch first case, we align frequently executed blocks.\n@@ -903,7 +903,7 @@ compute_alignments ()\n    port splits out-of-range conditional branches in MACHINE_DEPENDENT_REORG.\n    In order to do this, it needs proper length information, which it obtains\n    by calling shorten_branches.  This cannot be collapsed with\n-   shorten_branches itself into a single pass unless we also want to intergate\n+   shorten_branches itself into a single pass unless we also want to integrate\n    reorg.c, since the branch splitting exposes new instructions with delay\n    slots.  */\n "}, {"sha": "69147f3409006688cfd33d383d2786eec7d296b7", "filename": "gcc/flow.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -1035,7 +1035,7 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n   new_live_at_end = INITIALIZE_REG_SET (new_live_at_end_head);\n   call_used = INITIALIZE_REG_SET (call_used_head);\n \n-  /* Inconveniently, this is only redily available in hard reg set form.  */\n+  /* Inconveniently, this is only readily available in hard reg set form.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n     if (call_used_regs[i])\n       SET_REGNO_REG_SET (call_used, i);\n@@ -1374,7 +1374,7 @@ initialize_uninitialized_subregs ()\n \t     Its preferable to have an instance of the register's rtl since\n \t     there may be various flags set which we need to duplicate.  \n \t     If we can't find it, its probably an automatic whose initial\n-\t     value doesnt matter, or hopefully something we dont care about. */\n+\t     value doesn't matter, or hopefully something we don't care about. */\n \t  for (i = get_insns (); i && INSN_UID (i) != uid; i = NEXT_INSN (i))\n \t    ;\n \t  if (i != NULL_RTX)\n@@ -2797,7 +2797,7 @@ mark_regno_cond_dead (pbi, regno, cond)\n \n \t  SET_REGNO_REG_SET (pbi->reg_cond_reg, REGNO (XEXP (cond, 0)));\n \n-\t  /* Not unconditionaly dead.  */\n+\t  /* Not unconditionally dead.  */\n \t  return 0;\n \t}\n       else\n@@ -2829,7 +2829,7 @@ mark_regno_cond_dead (pbi, regno, cond)\n \n \t      SET_REGNO_REG_SET (pbi->reg_cond_reg, REGNO (XEXP (cond, 0)));\n \n-\t      /* Not unconditionaly dead.  */\n+\t      /* Not unconditionally dead.  */\n \t      return 0;\n \t    }\n \t}"}, {"sha": "edf934db9bcd0dfd11e6f3e54daec3ddb94ae2df", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -2087,7 +2087,7 @@ struct fc_args\n {\n   tree arg1;\t\t\t/* Input: value to convert.  */\n   tree type;\t\t\t/* Input: type to convert value to.  */\n-  tree t;\t\t\t/* Ouput: result of conversion.  */\n+  tree t;\t\t\t/* Output: result of conversion.  */\n };\n \n /* Function to convert floating-point constants, protected by floating\n@@ -4834,7 +4834,7 @@ fold_binary_op_with_conditional_arg (code, type, cond, arg, cond_first_p)\n      side of the expression to be executed if the condition is true\n      will be pointed to by TRUE_LHS.  Similarly, the right-hand side\n      of the expression to be executed if the condition is true will be\n-     pointed to by TRUE_RHS.  FALSE_LHS and FALSE_RHS are analagous --\n+     pointed to by TRUE_RHS.  FALSE_LHS and FALSE_RHS are analogous --\n      but apply to the expression to be executed if the conditional is\n      false.  */\n   tree *true_lhs;"}, {"sha": "d0e5fd39e17dde4738b48c61f7cbde7e5479b382", "filename": "gcc/function.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a7951f20a6c4967e849335117e89d247226626/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=d6a7951f20a6c4967e849335117e89d247226626", "patch": "@@ -887,7 +887,7 @@ combine_temp_slots ()\n     return;\n \n   /* If there are a lot of temp slots, don't do anything unless\n-     high levels of optimizaton.  */\n+     high levels of optimization.  */\n   if (! flag_expensive_optimizations)\n     for (p = temp_slots, num_slots = 0; p; p = p->next, num_slots++)\n       if (num_slots > 100 || (num_slots > 10 && optimize == 0))\n@@ -3068,7 +3068,7 @@ purge_addressof_1 (loc, insn, force, store, ht)\n \t\t example when the original insn was a MEM in a wider mode,\n \t\t and the note is part of a sign extension of a narrowed\n \t\t version of that MEM.  Gcc testcase compile/990829-1.c can\n-\t\t generate an example of this siutation.  Rather than complain\n+\t\t generate an example of this situation.  Rather than complain\n \t\t we return false, which will prompt our caller to remove the\n \t\t offending note.  */\n \t      return false;\n@@ -3245,7 +3245,7 @@ struct insns_for_mem_walk_info\n      MEMs.  */\n   struct hash_table *ht;\n \n-  /* The INSN we are currently proessing.  */\n+  /* The INSN we are currently processing.  */\n   rtx insn;\n \n   /* Zero if we are walking to find ADDRESSOFs, one if we are walking\n@@ -3396,7 +3396,7 @@ purge_addressof (insns)\n   unshare_all_rtl_again (get_insns ());\n }\n \f\n-/* Convert a SET of a hard subreg to a set of the appropriet hard\n+/* Convert a SET of a hard subreg to a set of the appropriate hard\n    register.  A subroutine of purge_hard_subreg_sets.  */\n \n static void\n@@ -3644,7 +3644,7 @@ instantiate_decl (x, size, valid_only)\n }\n \f\n /* Given a piece of RTX and a pointer to a HOST_WIDE_INT, if the RTX\n-   is a virtual register, return the requivalent hard register and set the\n+   is a virtual register, return the equivalent hard register and set the\n    offset indirectly through the pointer.  Otherwise, return 0.  */\n \n static rtx\n@@ -4927,7 +4927,7 @@ assign_parms (fndecl)\n \t    {\n \t      /* If we end up putting something into the stack,\n \t\t fixup_var_refs_insns will need to make a pass over\n-\t\t all the instructions.  It looks throughs the pending\n+\t\t all the instructions.  It looks through the pending\n \t\t sequences -- but it can't see the ones in the\n \t\t CONVERSION_INSNS, if they're not on the sequence\n \t\t stack.  So, we go back to that sequence, just so that\n@@ -7095,7 +7095,7 @@ emit_return_into_block (bb, line_note)\n \n /* These functions convert the epilogue into a variant that does not modify the\n    stack pointer.  This is used in cases where a function returns an object\n-   whose size is not known until it is computed.  The called function leavs the\n+   whose size is not known until it is computed.  The called function leaves the\n    object on the stack, leaves the stack depressed, and returns a pointer to\n    the object.\n \n@@ -7308,7 +7308,7 @@ keep_stack_depressed (seq)\n   return seq;\n }\n \n-/* SET is a SET from an insn in the epilogue.  P is a pointr to the epi_info\n+/* SET is a SET from an insn in the epilogue.  P is a pointer to the epi_info\n    structure that contains information about what we've seen so far.  We\n    process this SET by either updating that data or by emitting one or \n    more insns.  */\n@@ -7428,7 +7428,7 @@ thread_prologue_and_epilogue_insns (f)\n       seq = gen_sequence ();\n       end_sequence ();\n \n-      /* Can't deal with multiple successsors of the entry block\n+      /* Can't deal with multiple successors of the entry block\n          at the moment.  Function should always have at least one\n          entry point.  */\n       if (!ENTRY_BLOCK_PTR->succ || ENTRY_BLOCK_PTR->succ->succ_next)"}]}