{"sha": "6c420193e86b39a09304b2845335571eefe24d5d", "node_id": "C_kwDOANBUbNoAKDZjNDIwMTkzZTg2YjM5YTA5MzA0YjI4NDUzMzU1NzFlZWZlMjRkNWQ", "commit": {"author": {"name": "Marcel Vollweiler", "email": "marcel@codesourcery.com", "date": "2022-05-20T09:08:36Z"}, "committer": {"name": "Marcel Vollweiler", "email": "marcel@codesourcery.com", "date": "2022-05-20T09:29:32Z"}, "message": "libgomp: Add new runtime routines omp_target_memcpy_async and omp_target_memcpy_rect_async\n\nThis patch adds two new OpenMP runtime routines: omp_target_memcpy_async and\nomp_target_memcpy_rect_async. Both functions are introduced in OpenMP 5.1 as\nasynchronous variants of omp_target_memcpy and omp_target_memcpy_rect.\n\nIn contrast to the synchronous variants, the asynchronous functions have two\nadditional function parameters to allow the specification of task dependences:\n\n\tint depobj_count\n\tomp_depend_t *depobj_list\n\n\tinteger(c_int), value :: depobj_count\n\tinteger(omp_depend_kind), optional :: depobj_list(*)\n\nThe implementation splits the synchronous functions into two parts: (a) check\nand (b) copy. Then (a) is used in the asynchronous functions for the sequential\npart, and the actual copy process (b) is executed in a new created task. The\nsequential part (a) takes into account the requirements for the return values:\n\n\"The routine returns zero if successful. Otherwise, it returns a non-zero\nvalue.\" (omp_target_memcpy_async, OpenMP 5.1 spec, section 3.8.7)\n\n\"An application can determine the number of inclusive dimensions supported by an\nimplementation by passing NULL pointers (or C_NULL_PTR, for Fortran) for both\ndst and src. The routine returns the number of dimensions supported by the\nimplementation for the specified device numbers. No copy operation is\nperformed.\" (omp_target_memcpy_rect_async, OpenMP 5.1 spec, section 3.8.8)\n\nDue to asynchronicity an error is thrown if the asynchronous memcpy is not\nsuccessful (in contrast to the synchronous functions which use a return\nvalue unequal to zero).\n\ngcc/ChangeLog:\n\n\t* omp-low.cc (omp_runtime_api_call): Added target_memcpy_async and\n\ttarget_memcpy_rect_async to omp_runtime_apis array.\n\nlibgomp/ChangeLog:\n\n\t* libgomp.map: Added omp_target_memcpy_async and\n\tomp_target_memcpy_rect_async.\n\t* libgomp.texi: Both functions are now supported.\n\t* omp.h.in: Added omp_target_memcpy_async and\n\tomp_target_memcpy_rect_async.\n\t* omp_lib.f90.in: Added interfaces for both new functions.\n\t* omp_lib.h.in: Likewise.\n\t* target.c (ialias_redirect): Added for GOMP_task.\n\t(omp_target_memcpy): Restructured into check and copy part.\n\t(omp_target_memcpy_check): New helper function for omp_target_memcpy and\n\tomp_target_memcpy_async that checks requirements.\n\t(omp_target_memcpy_copy): New helper function for omp_target_memcpy and\n\tomp_target_memcpy_async that performs the memcpy.\n\t(omp_target_memcpy_async_helper): New helper function that is used in\n\tomp_target_memcpy_async for the asynchronous task.\n\t(omp_target_memcpy_async): Added.\n\t(omp_target_memcpy_rect): Restructured into check and copy part.\n\t(omp_target_memcpy_rect_check): New helper function for\n\tomp_target_memcpy_rect and omp_target_memcpy_rect_async that checks\n\trequirements.\n\t(omp_target_memcpy_rect_copy): New helper function for\n\tomp_target_memcpy_rect and omp_target_memcpy_rect_async that performs\n\tthe memcpy.\n\t(omp_target_memcpy_rect_async_helper): New helper function that is used\n\tin omp_target_memcpy_rect_async for the asynchronous task.\n\t(omp_target_memcpy_rect_async): Added.\n\t* task.c (ialias): Added for GOMP_task.\n\t* testsuite/libgomp.c-c++-common/target-memcpy-async-1.c: New test.\n\t* testsuite/libgomp.c-c++-common/target-memcpy-async-2.c: New test.\n\t* testsuite/libgomp.c-c++-common/target-memcpy-rect-async-1.c: New test.\n\t* testsuite/libgomp.c-c++-common/target-memcpy-rect-async-2.c: New test.\n\t* testsuite/libgomp.fortran/target-memcpy-async-1.f90: New test.\n\t* testsuite/libgomp.fortran/target-memcpy-async-2.f90: New test.\n\t* testsuite/libgomp.fortran/target-memcpy-rect-async-1.f90: New test.\n\t* testsuite/libgomp.fortran/target-memcpy-rect-async-2.f90: New test.", "tree": {"sha": "b19c3d0bd8bacae35e8a6b1e9031e4aa637e219b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b19c3d0bd8bacae35e8a6b1e9031e4aa637e219b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c420193e86b39a09304b2845335571eefe24d5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c420193e86b39a09304b2845335571eefe24d5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c420193e86b39a09304b2845335571eefe24d5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c420193e86b39a09304b2845335571eefe24d5d/comments", "author": null, "committer": null, "parents": [{"sha": "5143faee0d0edfd5849c5f54677cb699bf84a5db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5143faee0d0edfd5849c5f54677cb699bf84a5db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5143faee0d0edfd5849c5f54677cb699bf84a5db"}], "stats": {"total": 1005, "additions": 950, "deletions": 55}, "files": [{"sha": "b0379380df58add1b3366c7d3698a3fdd23449f1", "filename": "gcc/omp-low.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c420193e86b39a09304b2845335571eefe24d5d/gcc%2Fomp-low.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c420193e86b39a09304b2845335571eefe24d5d/gcc%2Fomp-low.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.cc?ref=6c420193e86b39a09304b2845335571eefe24d5d", "patch": "@@ -4011,7 +4011,9 @@ omp_runtime_api_call (const_tree fndecl)\n       \"target_is_accessible\",\n       \"target_is_present\",\n       \"target_memcpy\",\n+      \"target_memcpy_async\",\n       \"target_memcpy_rect\",\n+      \"target_memcpy_rect_async\",\n       NULL,\n       /* Now omp_* calls that are available as omp_* and omp_*_; however, the\n \t DECL_NAME is always omp_* without tailing underscore.  */"}, {"sha": "6334fdcce53f4c1eb247bbdf6b9cf57ba76cd71b", "filename": "libgomp/libgomp.map", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Flibgomp.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Flibgomp.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.map?ref=6c420193e86b39a09304b2845335571eefe24d5d", "patch": "@@ -230,6 +230,8 @@ OMP_5.1.1 {\n   global:\n \tomp_get_mapped_ptr;\n \tomp_target_is_accessible;\n+\tomp_target_memcpy_async;\n+\tomp_target_memcpy_rect_async;\n } OMP_5.1;\n \n GOMP_1.0 {"}, {"sha": "b54555d0ccbfefd2122d07f0718f0f20db316374", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=6c420193e86b39a09304b2845335571eefe24d5d", "patch": "@@ -315,7 +315,7 @@ The OpenMP 4.5 specification is fully supported.\n       routines @tab Y @tab\n @item @code{omp_target_is_accessible} runtime routine @tab Y @tab\n @item @code{omp_target_memcpy_async} and @code{omp_target_memcpy_rect_async}\n-      runtime routines @tab N @tab\n+      runtime routines @tab Y @tab\n @item @code{omp_get_mapped_ptr} runtime routine @tab Y @tab\n @item @code{omp_calloc}, @code{omp_realloc}, @code{omp_aligned_alloc} and\n       @code{omp_aligned_calloc} runtime routines @tab Y @tab"}, {"sha": "c8427fc324ecc85df32b7af719b6f8365ca37b4c", "filename": "libgomp/omp.h.in", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Fomp.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Fomp.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp.h.in?ref=6c420193e86b39a09304b2845335571eefe24d5d", "patch": "@@ -272,13 +272,25 @@ extern int omp_target_is_present (const void *, int) __GOMP_NOTHROW;\n extern int omp_target_memcpy (void *, const void *, __SIZE_TYPE__,\n \t\t\t      __SIZE_TYPE__, __SIZE_TYPE__, int, int)\n   __GOMP_NOTHROW;\n+extern int omp_target_memcpy_async (void *, const void *, __SIZE_TYPE__,\n+\t\t\t\t    __SIZE_TYPE__, __SIZE_TYPE__, int, int,\n+\t\t\t\t    int, omp_depend_t *)\n+  __GOMP_NOTHROW;\n extern int omp_target_memcpy_rect (void *, const void *, __SIZE_TYPE__, int,\n \t\t\t\t   const __SIZE_TYPE__ *,\n \t\t\t\t   const __SIZE_TYPE__ *,\n \t\t\t\t   const __SIZE_TYPE__ *,\n \t\t\t\t   const __SIZE_TYPE__ *,\n \t\t\t\t   const __SIZE_TYPE__ *, int, int)\n   __GOMP_NOTHROW;\n+extern int omp_target_memcpy_rect_async (void *, const void *, __SIZE_TYPE__,\n+\t\t\t\t\t int, const __SIZE_TYPE__ *,\n+\t\t\t\t\t const __SIZE_TYPE__ *,\n+\t\t\t\t\t const __SIZE_TYPE__ *,\n+\t\t\t\t\t const __SIZE_TYPE__ *,\n+\t\t\t\t\t const __SIZE_TYPE__ *, int, int, int,\n+\t\t\t\t\t omp_depend_t *)\n+  __GOMP_NOTHROW;\n extern int omp_target_associate_ptr (const void *, const void *, __SIZE_TYPE__,\n \t\t\t\t     __SIZE_TYPE__, int) __GOMP_NOTHROW;\n extern int omp_target_disassociate_ptr (const void *, int) __GOMP_NOTHROW;"}, {"sha": "8f68a2287bf3c1e6e9890e64ab2b18813d821099", "filename": "libgomp/omp_lib.f90.in", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Fomp_lib.f90.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Fomp_lib.f90.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.f90.in?ref=6c420193e86b39a09304b2845335571eefe24d5d", "patch": "@@ -798,6 +798,22 @@\n           end function omp_target_memcpy\n         end interface\n \n+        interface\n+          function omp_target_memcpy_async (dst, src, length, dst_offset, &\n+                                            src_offset, dst_device_num, &\n+                                            src_device_num, depobj_count, &\n+                                            depobj_list) bind(c)\n+            use, intrinsic :: iso_c_binding, only : c_ptr, c_int, c_size_t\n+            import :: omp_depend_kind\n+            integer(c_int) :: omp_target_memcpy_async\n+            type(c_ptr), value :: dst, src\n+            integer(c_size_t), value :: length, dst_offset, src_offset\n+            integer(c_int), value :: dst_device_num, src_device_num, &\n+                                     depobj_count\n+            integer(omp_depend_kind), optional :: depobj_list(*)\n+          end function omp_target_memcpy_async\n+        end interface\n+\n         interface\n           function omp_target_memcpy_rect (dst,src,element_size, num_dims, &\n                                            volume, dst_offsets, src_offsets, &\n@@ -815,6 +831,30 @@\n           end function omp_target_memcpy_rect\n         end interface\n \n+        interface\n+          function omp_target_memcpy_rect_async (dst,src,element_size,     &\n+                                                 num_dims, volume,         &\n+                                                 dst_offsets, src_offsets, &\n+                                                 dst_dimensions,           &\n+                                                 src_dimensions,           &\n+                                                 dst_device_num,           &\n+                                                 src_device_num,           &\n+                                                 depobj_count,             &\n+                                                 depobj_list) bind(c)\n+            use, intrinsic :: iso_c_binding, only : c_ptr, c_int, c_size_t\n+            import :: omp_depend_kind\n+            integer(c_int) :: omp_target_memcpy_rect_async\n+            type(c_ptr), value :: dst, src\n+            integer(c_size_t), value :: element_size\n+            integer(c_int), value :: num_dims, dst_device_num, src_device_num, &\n+                                     depobj_count\n+            integer(c_size_t), intent(in) :: volume(*), dst_offsets(*),  &\n+                                             src_offsets(*), dst_dimensions(*), &\n+                                             src_dimensions(*)\n+            integer(omp_depend_kind), optional :: depobj_list(*)\n+          end function omp_target_memcpy_rect_async\n+        end interface\n+\n         interface\n           function omp_target_associate_ptr (host_ptr, device_ptr, size, &\n                                              device_offset, device_num) bind(c)"}, {"sha": "68c62662cee31c1cd3b02e1eb679fdefa0109ba5", "filename": "libgomp/omp_lib.h.in", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Fomp_lib.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Fomp_lib.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.h.in?ref=6c420193e86b39a09304b2845335571eefe24d5d", "patch": "@@ -377,6 +377,22 @@\n         end function omp_target_memcpy\n       end interface\n \n+      interface\n+        function omp_target_memcpy_async (dst, src, length, dst_offset,    &\n+     &                              src_offset, dst_device_num,            &\n+     &                              src_device_num, depobj_count,          &\n+     &                              depobj_list) bind(c)\n+          use, intrinsic :: iso_c_binding, only : c_ptr, c_int, c_size_t\n+          import :: omp_depend_kind\n+          integer(c_int) :: omp_target_memcpy_async\n+          type(c_ptr), value :: dst, src\n+          integer(c_size_t), value :: length, dst_offset, src_offset\n+          integer(c_int), value :: dst_device_num, src_device_num\n+          integer(c_int), value :: depobj_count\n+          integer(omp_depend_kind), optional :: depobj_list(*)\n+        end function omp_target_memcpy_async\n+      end interface\n+\n       interface\n         function omp_target_memcpy_rect (dst,src,element_size, num_dims,   &\n      &                                   volume, dst_offsets,              &\n@@ -396,6 +412,31 @@\n         end function omp_target_memcpy_rect\n       end interface\n \n+      interface\n+        function omp_target_memcpy_rect_async (dst,src,element_size,        &\n+     &                                         num_dims, volume,            &\n+     &                                         dst_offsets, src_offsets,    &\n+     &                                         dst_dimensions,              &\n+     &                                         src_dimensions,              &\n+     &                                         dst_device_num,              &\n+     &                                         src_device_num,              &\n+     &                                         depobj_count,                &\n+     &                                         depobj_list) bind(c)\n+          use, intrinsic :: iso_c_binding, only : c_ptr, c_int, c_size_t\n+          import :: omp_depend_kind\n+          integer(c_int) :: omp_target_memcpy_rect_async\n+          type(c_ptr), value :: dst, src\n+          integer(c_size_t), value :: element_size\n+          integer(c_int), value :: num_dims, depobj_count\n+          integer(c_int), value :: dst_device_num, src_device_num\n+          integer(c_size_t), intent(in) :: volume(*), dst_offsets(*)\n+          integer(c_size_t), intent(in) :: src_offsets(*)\n+          integer(c_size_t), intent(in) :: dst_dimensions(*)\n+          integer(c_size_t), intent(in) :: src_dimensions(*)\n+          integer(omp_depend_kind), optional :: depobj_list(*)\n+        end function omp_target_memcpy_rect_async\n+      end interface\n+\n       interface\n         function omp_target_associate_ptr (host_ptr, device_ptr, size,     &\n      &                                     device_offset, device_num)      &"}, {"sha": "ab2191beeb70cdb2ab07acfeb414e4f3729a0f0d", "filename": "libgomp/target.c", "status": "modified", "additions": 236, "deletions": 54, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=6c420193e86b39a09304b2845335571eefe24d5d", "patch": "@@ -49,6 +49,8 @@ static inline void * htab_alloc (size_t size) { return gomp_malloc (size); }\n static inline void htab_free (void *ptr) { free (ptr); }\n #include \"hashtab.h\"\n \n+ialias_redirect (GOMP_task)\n+\n static inline hashval_t\n htab_hash (hash_entry_type element)\n {\n@@ -3355,40 +3357,49 @@ omp_target_is_present (const void *ptr, int device_num)\n   return ret;\n }\n \n-int\n-omp_target_memcpy (void *dst, const void *src, size_t length,\n-\t\t   size_t dst_offset, size_t src_offset, int dst_device_num,\n-\t\t   int src_device_num)\n+static int\n+omp_target_memcpy_check (int dst_device_num, int src_device_num,\n+\t\t\t struct gomp_device_descr **dst_devicep,\n+\t\t\t struct gomp_device_descr **src_devicep)\n {\n-  struct gomp_device_descr *dst_devicep = NULL, *src_devicep = NULL;\n-  bool ret;\n-\n   if (dst_device_num != gomp_get_num_devices ())\n     {\n       if (dst_device_num < 0)\n \treturn EINVAL;\n \n-      dst_devicep = resolve_device (dst_device_num);\n-      if (dst_devicep == NULL)\n+      *dst_devicep = resolve_device (dst_device_num);\n+      if (*dst_devicep == NULL)\n \treturn EINVAL;\n \n-      if (!(dst_devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n-\t  || dst_devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n-\tdst_devicep = NULL;\n+      if (!((*dst_devicep)->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n+\t  || (*dst_devicep)->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n+\t*dst_devicep = NULL;\n     }\n+\n   if (src_device_num != num_devices_openmp)\n     {\n       if (src_device_num < 0)\n \treturn EINVAL;\n \n-      src_devicep = resolve_device (src_device_num);\n-      if (src_devicep == NULL)\n+      *src_devicep = resolve_device (src_device_num);\n+      if (*src_devicep == NULL)\n \treturn EINVAL;\n \n-      if (!(src_devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n-\t  || src_devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n-\tsrc_devicep = NULL;\n+      if (!((*src_devicep)->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n+\t  || (*src_devicep)->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n+\t*src_devicep = NULL;\n     }\n+\n+  return 0;\n+}\n+\n+static int\n+omp_target_memcpy_copy (void *dst, const void *src, size_t length,\n+\t\t\tsize_t dst_offset, size_t src_offset,\n+\t\t\tstruct gomp_device_descr *dst_devicep,\n+\t\t\tstruct gomp_device_descr *src_devicep)\n+{\n+  bool ret;\n   if (src_devicep == NULL && dst_devicep == NULL)\n     {\n       memcpy ((char *) dst + dst_offset, (char *) src + src_offset, length);\n@@ -3424,6 +3435,85 @@ omp_target_memcpy (void *dst, const void *src, size_t length,\n   return EINVAL;\n }\n \n+int\n+omp_target_memcpy (void *dst, const void *src, size_t length, size_t dst_offset,\n+\t\t   size_t src_offset, int dst_device_num, int src_device_num)\n+{\n+  struct gomp_device_descr *dst_devicep = NULL, *src_devicep = NULL;\n+  int ret = omp_target_memcpy_check (dst_device_num, src_device_num,\n+\t\t\t\t     &dst_devicep, &src_devicep);\n+\n+  if (ret)\n+    return ret;\n+\n+  ret = omp_target_memcpy_copy (dst, src, length, dst_offset, src_offset,\n+\t\t\t\tdst_devicep, src_devicep);\n+\n+  return ret;\n+}\n+\n+typedef struct\n+{\n+  void *dst;\n+  const void *src;\n+  size_t length;\n+  size_t dst_offset;\n+  size_t src_offset;\n+  struct gomp_device_descr *dst_devicep;\n+  struct gomp_device_descr *src_devicep;\n+} omp_target_memcpy_data;\n+\n+static void\n+omp_target_memcpy_async_helper (void *args)\n+{\n+  omp_target_memcpy_data *a = args;\n+  if (omp_target_memcpy_copy (a->dst, a->src, a->length, a->dst_offset,\n+\t\t\t      a->src_offset, a->dst_devicep, a->src_devicep))\n+    gomp_fatal (\"omp_target_memcpy failed\");\n+}\n+\n+int\n+omp_target_memcpy_async (void *dst, const void *src, size_t length,\n+\t\t\t size_t dst_offset, size_t src_offset,\n+\t\t\t int dst_device_num, int src_device_num,\n+\t\t\t int depobj_count, omp_depend_t *depobj_list)\n+{\n+  struct gomp_device_descr *dst_devicep = NULL, *src_devicep = NULL;\n+  unsigned int flags = 0;\n+  void *depend[depobj_count + 5];\n+  int i;\n+  int check = omp_target_memcpy_check (dst_device_num, src_device_num,\n+\t\t\t\t       &dst_devicep, &src_devicep);\n+\n+  omp_target_memcpy_data s = {\n+    .dst = dst,\n+    .src = src,\n+    .length = length,\n+    .dst_offset = dst_offset,\n+    .src_offset = src_offset,\n+    .dst_devicep = dst_devicep,\n+    .src_devicep = src_devicep\n+  };\n+\n+  if (check)\n+    return check;\n+\n+  if (depobj_count > 0 && depobj_list != NULL)\n+    {\n+      flags |= GOMP_TASK_FLAG_DEPEND;\n+      depend[0] = 0;\n+      depend[1] = (void *) (uintptr_t) depobj_count;\n+      depend[2] = depend[3] = depend[4] = 0;\n+      for (i = 0; i < depobj_count; ++i)\n+\tdepend[i + 5] = &depobj_list[i];\n+    }\n+\n+  GOMP_task (omp_target_memcpy_async_helper, &s, NULL, sizeof (s),\n+\t     __alignof__ (s), true, flags, depend, 0, NULL);\n+\n+  return 0;\n+}\n+\n static int\n omp_target_memcpy_rect_worker (void *dst, const void *src, size_t element_size,\n \t\t\t       int num_dims, const size_t *volume,\n@@ -3500,50 +3590,36 @@ omp_target_memcpy_rect_worker (void *dst, const void *src, size_t element_size,\n   return 0;\n }\n \n-int\n-omp_target_memcpy_rect (void *dst, const void *src, size_t element_size,\n-\t\t\tint num_dims, const size_t *volume,\n-\t\t\tconst size_t *dst_offsets,\n-\t\t\tconst size_t *src_offsets,\n-\t\t\tconst size_t *dst_dimensions,\n-\t\t\tconst size_t *src_dimensions,\n-\t\t\tint dst_device_num, int src_device_num)\n+static int\n+omp_target_memcpy_rect_check (void *dst, const void *src, int dst_device_num,\n+\t\t\t      int src_device_num,\n+\t\t\t      struct gomp_device_descr **dst_devicep,\n+\t\t\t      struct gomp_device_descr **src_devicep)\n {\n-  struct gomp_device_descr *dst_devicep = NULL, *src_devicep = NULL;\n-\n   if (!dst && !src)\n     return INT_MAX;\n \n-  if (dst_device_num != gomp_get_num_devices ())\n-    {\n-      if (dst_device_num < 0)\n-\treturn EINVAL;\n-\n-      dst_devicep = resolve_device (dst_device_num);\n-      if (dst_devicep == NULL)\n-\treturn EINVAL;\n-\n-      if (!(dst_devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n-\t  || dst_devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n-\tdst_devicep = NULL;\n-    }\n-  if (src_device_num != num_devices_openmp)\n-    {\n-      if (src_device_num < 0)\n-\treturn EINVAL;\n-\n-      src_devicep = resolve_device (src_device_num);\n-      if (src_devicep == NULL)\n-\treturn EINVAL;\n+  int ret = omp_target_memcpy_check (dst_device_num, src_device_num,\n+\t\t\t\t     dst_devicep, src_devicep);\n+  if (ret)\n+    return ret;\n \n-      if (!(src_devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n-\t  || src_devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n-\tsrc_devicep = NULL;\n-    }\n-\n-  if (src_devicep != NULL && dst_devicep != NULL && src_devicep != dst_devicep)\n+  if (*src_devicep != NULL && *dst_devicep != NULL && *src_devicep != *dst_devicep)\n     return EINVAL;\n \n+  return 0;\n+}\n+\n+static int\n+omp_target_memcpy_rect_copy (void *dst, const void *src,\n+\t\t\t     size_t element_size, int num_dims,\n+\t\t\t     const size_t *volume, const size_t *dst_offsets,\n+\t\t\t     const size_t *src_offsets,\n+\t\t\t     const size_t *dst_dimensions,\n+\t\t\t     const size_t *src_dimensions,\n+\t\t\t     struct gomp_device_descr *dst_devicep,\n+\t\t\t     struct gomp_device_descr *src_devicep)\n+{\n   if (src_devicep)\n     gomp_mutex_lock (&src_devicep->lock);\n   else if (dst_devicep)\n@@ -3556,9 +3632,115 @@ omp_target_memcpy_rect (void *dst, const void *src, size_t element_size,\n     gomp_mutex_unlock (&src_devicep->lock);\n   else if (dst_devicep)\n     gomp_mutex_unlock (&dst_devicep->lock);\n+\n+  return ret;\n+}\n+\n+int\n+omp_target_memcpy_rect (void *dst, const void *src, size_t element_size,\n+\t\t\tint num_dims, const size_t *volume,\n+\t\t\tconst size_t *dst_offsets,\n+\t\t\tconst size_t *src_offsets,\n+\t\t\tconst size_t *dst_dimensions,\n+\t\t\tconst size_t *src_dimensions,\n+\t\t\tint dst_device_num, int src_device_num)\n+{\n+  struct gomp_device_descr *dst_devicep = NULL, *src_devicep = NULL;\n+\n+  int check = omp_target_memcpy_rect_check (dst, src, dst_device_num,\n+\t\t\t\t\t    src_device_num, &dst_devicep,\n+\t\t\t\t\t    &src_devicep);\n+\n+  if (check)\n+    return check;\n+\n+  int ret = omp_target_memcpy_rect_copy (dst, src, element_size, num_dims,\n+\t\t\t\t\t volume, dst_offsets, src_offsets,\n+\t\t\t\t\t dst_dimensions, src_dimensions,\n+\t\t\t\t\t dst_devicep, src_devicep);\n+\n   return ret;\n }\n \n+typedef struct\n+{\n+  void *dst;\n+  const void *src;\n+  size_t element_size;\n+  const size_t *volume;\n+  const size_t *dst_offsets;\n+  const size_t *src_offsets;\n+  const size_t *dst_dimensions;\n+  const size_t *src_dimensions;\n+  struct gomp_device_descr *dst_devicep;\n+  struct gomp_device_descr *src_devicep;\n+  int num_dims;\n+} omp_target_memcpy_rect_data;\n+\n+static void\n+omp_target_memcpy_rect_async_helper (void *args)\n+{\n+  omp_target_memcpy_rect_data *a = args;\n+  int ret = omp_target_memcpy_rect_copy (a->dst, a->src, a->element_size,\n+\t\t\t\t\t a->num_dims, a->volume, a->dst_offsets,\n+\t\t\t\t\t a->src_offsets, a->dst_dimensions,\n+\t\t\t\t\t a->src_dimensions, a->dst_devicep,\n+\t\t\t\t\t a->src_devicep);\n+  if (ret)\n+    gomp_fatal (\"omp_target_memcpy_rect failed\");\n+}\n+\n+int\n+omp_target_memcpy_rect_async (void *dst, const void *src, size_t element_size,\n+\t\t\t      int num_dims, const size_t *volume,\n+\t\t\t      const size_t *dst_offsets,\n+\t\t\t      const size_t *src_offsets,\n+\t\t\t      const size_t *dst_dimensions,\n+\t\t\t      const size_t *src_dimensions,\n+\t\t\t      int dst_device_num, int src_device_num,\n+\t\t\t      int depobj_count, omp_depend_t *depobj_list)\n+{\n+  struct gomp_device_descr *dst_devicep = NULL, *src_devicep = NULL;\n+  unsigned flags = 0;\n+  int check = omp_target_memcpy_rect_check (dst, src, dst_device_num,\n+\t\t\t\t\t    src_device_num, &dst_devicep,\n+\t\t\t\t\t    &src_devicep);\n+  void *depend[depobj_count + 5];\n+  int i;\n+\n+  omp_target_memcpy_rect_data s = {\n+    .dst = dst,\n+    .src = src,\n+    .element_size = element_size,\n+    .num_dims = num_dims,\n+    .volume = volume,\n+    .dst_offsets = dst_offsets,\n+    .src_offsets = src_offsets,\n+    .dst_dimensions = dst_dimensions,\n+    .src_dimensions = src_dimensions,\n+    .dst_devicep = dst_devicep,\n+    .src_devicep = src_devicep\n+  };\n+\n+  if (check)\n+    return check;\n+\n+  if (depobj_count > 0 && depobj_list != NULL)\n+    {\n+      flags |= GOMP_TASK_FLAG_DEPEND;\n+      depend[0] = 0;\n+      depend[1] = (void *) (uintptr_t) depobj_count;\n+      depend[2] = depend[3] = depend[4] = 0;\n+      for (i = 0; i < depobj_count; ++i)\n+\tdepend[i + 5] = &depobj_list[i];\n+    }\n+\n+  GOMP_task (omp_target_memcpy_rect_async_helper, &s, NULL, sizeof (s),\n+\t     __alignof__ (s), true, flags, depend, 0, NULL);\n+\n+  return 0;\n+}\n+\n int\n omp_target_associate_ptr (const void *host_ptr, const void *device_ptr,\n \t\t\t  size_t size, size_t device_offset, int device_num)"}, {"sha": "6b11a8f02efefa0700456be042ea26dc32fbfd97", "filename": "libgomp/task.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Ftask.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Ftask.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftask.c?ref=6c420193e86b39a09304b2845335571eefe24d5d", "patch": "@@ -712,6 +712,7 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n     }\n }\n \n+ialias (GOMP_task)\n ialias (GOMP_taskgroup_start)\n ialias (GOMP_taskgroup_end)\n ialias (GOMP_taskgroup_reduction_register)"}, {"sha": "f25c3bb36bd88bef6ced3315d67db264df553bea", "filename": "libgomp/testsuite/libgomp.c-c++-common/target-memcpy-async-1.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-memcpy-async-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-memcpy-async-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-memcpy-async-1.c?ref=6c420193e86b39a09304b2845335571eefe24d5d", "patch": "@@ -0,0 +1,46 @@\n+/* Test for omp_target_memcpy_async without considering dependence objects.  */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int\n+main ()\n+{\n+  int d = omp_get_default_device ();\n+  int id = omp_get_initial_device ();\n+  int q[128], i;\n+  void *p;\n+\n+  if (d < 0 || d >= omp_get_num_devices ())\n+    d = id;\n+\n+  p = omp_target_alloc (130 * sizeof (int), d);\n+  if (p == NULL)\n+    return 0;\n+\n+  for (i = 0; i < 128; i++)\n+    q[i] = i;\n+\n+  if (omp_target_memcpy_async (p, q, 128 * sizeof (int), sizeof (int), 0, d, id,\n+      0, NULL))\n+    abort ();\n+\n+  #pragma omp taskwait\n+\n+  int q2[128];\n+  for (i = 0; i < 128; ++i)\n+    q2[i] = 0;\n+  if (omp_target_memcpy_async (q2, p, 128 * sizeof(int), 0, sizeof (int), id, d,\n+      0, NULL))\n+    abort ();\n+\n+  #pragma omp taskwait\n+\n+  for (i = 0; i < 128; ++i)\n+    if (q2[i] != q[i])\n+      abort ();\n+\n+  omp_target_free (p, d);\n+\n+  return 0;\n+}"}, {"sha": "d1353a5000cb785d464b3ed704d6ba3119808ea1", "filename": "libgomp/testsuite/libgomp.c-c++-common/target-memcpy-async-2.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-memcpy-async-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-memcpy-async-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-memcpy-async-2.c?ref=6c420193e86b39a09304b2845335571eefe24d5d", "patch": "@@ -0,0 +1,74 @@\n+/* Test for omp_target_memcpy_async considering dependence objects.  */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int\n+main ()\n+{\n+  int d = omp_get_default_device ();\n+  int id = omp_get_initial_device ();\n+  int a[128], b[64], c[32], e[16], q[128], i;\n+  void *p;\n+\n+  if (d < 0 || d >= omp_get_num_devices ())\n+    d = id;\n+\n+  p = omp_target_alloc (130 * sizeof (int), d);\n+  if (p == NULL)\n+    return 0;\n+\n+  for (i = 0; i < 128; ++i)\n+    a[i] = i + 1;\n+  for (i = 0; i < 64; ++i)\n+    b[i] = i + 2;\n+  for (i = 0; i < 32; i++)\n+    c[i] = 0;\n+  for (i = 0; i < 16; i++)\n+    e[i] = i + 4;\n+\n+  omp_depend_t obj[2];\n+\n+  #pragma omp parallel num_threads(5)\n+  #pragma omp single\n+  {\n+    #pragma omp task depend(out: p)\n+    omp_target_memcpy (p, a, 128 * sizeof (int), 0, 0, d, id);\n+\n+    #pragma omp task depend(inout: p)\n+    omp_target_memcpy (p, b, 64 * sizeof (int), 0, 0, d, id);\n+\n+    #pragma omp task depend(out: c)\n+    for (i = 0; i < 32; i++)\n+      c[i] = i + 3;\n+\n+    #pragma omp depobj(obj[0]) depend(inout: p)\n+    #pragma omp depobj(obj[1]) depend(in: c)\n+    omp_target_memcpy_async (p, c, 32 * sizeof (int), 0, 0, d, id, 2, obj);\n+\n+    #pragma omp task depend(in: p)\n+    omp_target_memcpy (p, e, 16 * sizeof (int), 0, 0, d, id);\n+  }\n+\n+  #pragma omp taskwait\n+\n+  for (i = 0; i < 128; ++i)\n+    q[i] = 0;\n+  omp_target_memcpy (q, p, 128 * sizeof(int), 0, 0, id, d);\n+  for (i = 0; i < 16; ++i)\n+    if (q[i] != i + 4)\n+      abort ();\n+  for (i = 16; i < 32; ++i)\n+    if (q[i] != i + 3)\n+      abort ();\n+  for (i = 32; i < 64; ++i)\n+    if (q[i] != i + 2)\n+      abort ();\n+  for (i = 64; i < 128; ++i)\n+    if (q[i] != i + 1)\n+      abort ();\n+\n+  omp_target_free (p, d);\n+\n+  return 0;\n+}"}, {"sha": "176bceb4e96b7c27b71d72b920bce0880c6997a4", "filename": "libgomp/testsuite/libgomp.c-c++-common/target-memcpy-rect-async-1.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-memcpy-rect-async-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-memcpy-rect-async-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-memcpy-rect-async-1.c?ref=6c420193e86b39a09304b2845335571eefe24d5d", "patch": "@@ -0,0 +1,68 @@\n+/* Test for omp_target_memcpy_rect_async without considering dependence\n+   objects.  */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+#define NUM_DIMS 3\n+\n+int\n+main ()\n+{\n+  int d = omp_get_default_device ();\n+  int id = omp_get_initial_device ();\n+  int q[128], q2[128], i;\n+  void *p;\n+\n+  if (d < 0 || d >= omp_get_num_devices ())\n+    d = id;\n+\n+  p = omp_target_alloc (130 * sizeof (int), d);\n+  if (p == NULL)\n+    return 0;\n+\n+  if (omp_target_memcpy_rect_async (NULL, NULL, 0, 0, NULL, NULL, NULL, NULL,\n+\t\t\t\t    NULL, d, id, 0, NULL) < 3\n+      || omp_target_memcpy_rect_async (NULL, NULL, 0, 0, NULL, NULL, NULL, NULL,\n+\t\t\t\t       NULL, id, d, 0, NULL) < 3\n+      || omp_target_memcpy_rect_async (NULL, NULL, 0, 0, NULL, NULL, NULL, NULL,\n+\t\t\t\t       NULL, id, id, 0, NULL) < 3)\n+    abort ();\n+\n+  for (i = 0; i < 128; i++)\n+    q[i] = 0;\n+  if (omp_target_memcpy (p, q, 128 * sizeof (int), 0, 0, d, id) != 0)\n+    abort ();\n+\n+  for (i = 0; i < 128; i++)\n+    q[i] = i + 1;\n+\n+  size_t volume[NUM_DIMS] = { 1, 2, 3 };\n+  size_t dst_offsets[NUM_DIMS] = { 0, 0, 0 };\n+  size_t src_offsets[NUM_DIMS] = { 0, 0, 0 };\n+  size_t dst_dimensions[NUM_DIMS] = { 3, 4, 5 };\n+  size_t src_dimensions[NUM_DIMS] = { 2, 3, 4 };\n+\n+  if (omp_target_memcpy_rect_async (p, q, sizeof (int), NUM_DIMS, volume,\n+\t\t\t\t    dst_offsets, src_offsets, dst_dimensions,\n+\t\t\t\t    src_dimensions, d, id, 0, NULL) != 0)\n+    abort ();\n+\n+  #pragma omp taskwait\n+\n+  for (i = 0; i < 128; i++)\n+    q2[i] = 0;\n+  if (omp_target_memcpy (q2, p, 128 * sizeof (int), 0, 0, id, d) != 0)\n+    abort ();\n+\n+  /* q2 is expected to contain: 1 2 3 0 0 5 6 7 0 0 .. 0  */\n+  if (q2[0] != 1 || q2[1] != 2 || q2[2] !=3 || q2[3] != 0 || q2[4] != 0\n+      || q2[5] != 5 || q2[6] != 6 || q2[7] != 7)\n+    abort ();\n+  for (i = 8; i < 128; ++i)\n+    if (q2[i] != 0)\n+      abort ();\n+\n+  omp_target_free (p, d);\n+  return 0;\n+}"}, {"sha": "4a5d80f4502dd1ce5ac12c07b4e2820c3a5f8bbe", "filename": "libgomp/testsuite/libgomp.c-c++-common/target-memcpy-rect-async-2.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-memcpy-rect-async-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-memcpy-rect-async-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-memcpy-rect-async-2.c?ref=6c420193e86b39a09304b2845335571eefe24d5d", "patch": "@@ -0,0 +1,91 @@\n+/* Test for omp_target_memcpy_rect_async considering dependence objects.  */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+#define NUM_DIMS 3\n+\n+int\n+main ()\n+{\n+  int d = omp_get_default_device ();\n+  int id = omp_get_initial_device ();\n+  int a[128], b[64], c[128], e[16], q[128], i;\n+  void *p;\n+\n+  if (d < 0 || d >= omp_get_num_devices ())\n+    d = id;\n+\n+  p = omp_target_alloc (130 * sizeof (int), d);\n+  if (p == NULL)\n+    return 0;\n+\n+  for (i = 0; i < 128; i++)\n+    q[i] = 0;\n+  if (omp_target_memcpy (p, q, 128 * sizeof (int), 0, 0, d, id) != 0)\n+    abort ();\n+\n+  size_t volume[NUM_DIMS] = { 2, 2, 3 };\n+  size_t dst_offsets[NUM_DIMS] = { 0, 0, 0 };\n+  size_t src_offsets[NUM_DIMS] = { 0, 0, 0 };\n+  size_t dst_dimensions[NUM_DIMS] = { 3, 4, 5 };\n+  size_t src_dimensions[NUM_DIMS] = { 2, 3, 4 };\n+\n+  for (i = 0; i < 128; i++)\n+    a[i] = 42;\n+  for (i = 0; i < 64; i++)\n+    b[i] = 24;\n+  for (i = 0; i < 128; i++)\n+    c[i] = 0;\n+  for (i = 0; i < 16; i++)\n+    e[i] = 77;\n+\n+  omp_depend_t obj[2];\n+\n+  #pragma omp parallel num_threads(5)\n+  #pragma omp single\n+  {\n+    #pragma omp task depend (out: p)\n+    omp_target_memcpy (p, a, 128 * sizeof (int), 0, 0, d, id);\n+\n+    #pragma omp task depend(inout: p)\n+    omp_target_memcpy (p, b, 64 * sizeof (int), 0, 0, d, id);\n+\n+    #pragma omp task depend(out: c)\n+    for (i = 0; i < 128; i++)\n+      c[i] = i + 1;\n+\n+    #pragma omp depobj(obj[0]) depend(inout: p)\n+    #pragma omp depobj(obj[1]) depend(in: c)\n+\n+    /*  This produces: 1 2 3 - - 5 6 7 - - at positions 0..9 and\n+\t\t       13 14 15 - - 17 18 19 - - at positions 20..29.  */\n+    omp_target_memcpy_rect_async (p, c, sizeof (int), NUM_DIMS, volume,\n+\t\t\t\t  dst_offsets, src_offsets, dst_dimensions,\n+\t\t\t\t  src_dimensions, d, id, 2, obj);\n+\n+    #pragma omp task depend(in: p)\n+    omp_target_memcpy (p, e, 16 * sizeof (int), 0, 0, d, id);\n+  }\n+\n+  #pragma omp taskwait\n+\n+  if (omp_target_memcpy (q, p, 128 * sizeof(int), 0, 0, id, d) != 0)\n+    abort ();\n+\n+  for (i = 0; i < 16; ++i)\n+    if (q[i] != 77)\n+      abort ();\n+  if (q[20] != 13 || q[21] != 14 || q[22] != 15 || q[25] != 17 || q[26] != 18\n+      || q[27] != 19)\n+    abort ();\n+  for (i = 28; i < 64; ++i)\n+    if (q[i] != 24)\n+      abort ();\n+  for (i = 64; i < 128; ++i)\n+    if (q[i] != 42)\n+      abort ();\n+\n+  omp_target_free (p, d);\n+  return 0;\n+}"}, {"sha": "4679fd2b94a6b2567742467b179cdad947e4f1b6", "filename": "libgomp/testsuite/libgomp.fortran/target-memcpy-async-1.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-memcpy-async-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-memcpy-async-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-memcpy-async-1.f90?ref=6c420193e86b39a09304b2845335571eefe24d5d", "patch": "@@ -0,0 +1,42 @@\n+! Test for omp_target_memcpy_async without considering dependence objects.\n+\n+program main\n+  use omp_lib\n+  use iso_c_binding\n+  implicit none (external, type)\n+  integer :: d, id, i, j\n+  integer, target :: q(0:127), q2(0:127)\n+  type(c_ptr) :: p\n+  integer(omp_depend_kind) :: obj(1:0)\n+\n+  d = omp_get_default_device ()\n+  id = omp_get_initial_device ()\n+\n+  if (d < 0 .or. d >= omp_get_num_devices ()) &\n+    d = id\n+\n+  p = omp_target_alloc (130 * c_sizeof (q), d)\n+  if (.not. c_associated (p)) &\n+    stop 0  ! okay\n+\n+  q = [(i, i = 0, 127)]\n+  if (omp_target_memcpy_async (p, c_loc (q), 128 * sizeof (q(0)), 0_c_size_t, &\n+      0_c_size_t, d, id, 0, obj) /= 0) &\n+    stop 1\n+\n+  !$omp taskwait\n+\n+  q2 = [(0, i = 0, 127)]\n+  if (omp_target_memcpy_async (c_loc (q2), p, 128 * sizeof (q2(0)), 0_c_size_t,&\n+      0_c_size_t, id, d, 0, obj) /= 0) &\n+    stop 2\n+\n+  !$omp taskwait\n+\n+  do j = 0, 127\n+    if (q(j) /= q2(j)) &\n+      stop 3\n+  end do\n+\n+  call omp_target_free (p, d)\n+end program main"}, {"sha": "2aa482ac85a137d209f1b3732fae580d7a8f3d16", "filename": "libgomp/testsuite/libgomp.fortran/target-memcpy-async-2.f90", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-memcpy-async-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-memcpy-async-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-memcpy-async-2.f90?ref=6c420193e86b39a09304b2845335571eefe24d5d", "patch": "@@ -0,0 +1,91 @@\n+! Test for omp_target_memcpy_async considering dependence objects.\n+\n+program main\n+  use omp_lib\n+  use iso_c_binding\n+  implicit none (external, type)\n+  integer :: d, id, i, j\n+  integer, target :: a(0:127), b(0:63), c(0:31), e(0:15), q(0:127)\n+  type(c_ptr) :: p\n+  integer(omp_depend_kind) :: obj(0:1)\n+\n+  d = omp_get_default_device ()\n+  id = omp_get_initial_device ()\n+\n+  if (d < 0 .or. d >= omp_get_num_devices ()) &\n+    d = id\n+\n+  p = omp_target_alloc (130 * c_sizeof (q), d)\n+  if (.not. c_associated (p)) &\n+    stop 0  ! okay\n+\n+  a = [(i + 1, i = 0, 127)]\n+  b = [(i + 2, i = 0, 63)]\n+  c = [(0, i = 0, 31)]\n+  e = [(i + 4, i = 0, 15)]\n+\n+  !$omp parallel num_threads(5)\n+  !$omp single\n+\n+    !$omp task depend(out: p)\n+    if (omp_target_memcpy (p, c_loc (a), 128 * sizeof (a(0)), 0_c_size_t, &\n+                           0_c_size_t, d, id) /= 0) &\n+      stop 1\n+    !$omp end task\n+\n+    !$omp task depend(inout: p)\n+    if (omp_target_memcpy (p, c_loc (b), 64 * sizeof (b(0)), 0_c_size_t, &\n+                           0_c_size_t, d, id) /= 0) &\n+      stop 2\n+    !$omp end task\n+\n+    !$omp task depend(out: c)\n+    do j = 0, 31\n+      c(j) = j + 3\n+    end do\n+    !$omp end task\n+\n+    !$omp depobj(obj(0)) depend(inout: p)\n+    !$omp depobj(obj(1)) depend(in: c)\n+    if (omp_target_memcpy_async (p, c_loc (c), 32 * sizeof (c(0)), 0_c_size_t, &\n+                                 0_c_size_t, d, id, 2, obj) /= 0) &\n+      stop 3\n+\n+    !$omp task depend(in: p)\n+    if (omp_target_memcpy (p, c_loc (e), 16 * sizeof (e(0)), 0_c_size_t, &\n+                           0_c_size_t, d, id) /= 0) &\n+      stop 4\n+    !$omp end task\n+\n+  !$omp end single\n+  !$omp end parallel\n+\n+  !$omp taskwait\n+\n+  q = [(0, i = 0, 127)]\n+  if (omp_target_memcpy (c_loc (q), p, 128 * sizeof (q(0)), 0_c_size_t, &\n+                         0_c_size_t, id, d) /= 0) &\n+    stop 5\n+\n+  do j = 0, 15\n+    if (q(j) /= j+4) &\n+      stop 10\n+  end do\n+\n+  do j = 16, 31\n+    if (q(j) /= j+3) &\n+      stop 11\n+  end do\n+\n+  do j = 32, 63\n+    if (q(j) /= j+2) &\n+      stop 12\n+  end do\n+\n+  do j = 64, 127\n+    if (q(j) /= j+1) &\n+      stop 13\n+  end do\n+\n+  call omp_target_free (p, d)\n+end program main"}, {"sha": "c8c87c5d1e84847ac38e137c72cc72661386d22e", "filename": "libgomp/testsuite/libgomp.fortran/target-memcpy-rect-async-1.f90", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-memcpy-rect-async-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-memcpy-rect-async-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-memcpy-rect-async-1.f90?ref=6c420193e86b39a09304b2845335571eefe24d5d", "patch": "@@ -0,0 +1,86 @@\n+! Test for omp_target_memcpy_rect_async without considering dependence objects.\n+\n+program main\n+  use omp_lib\n+  use iso_c_binding\n+  implicit none (external, type)\n+  integer :: d, id, i, j\n+  integer, target :: q(0:127), q2(0:127)\n+  type(c_ptr) :: p\n+  integer(omp_depend_kind) :: obj(1:0)\n+\n+  integer(kind=c_size_t) :: volume(0:2)\n+  integer(kind=c_size_t) :: dst_offsets(0:2)\n+  integer(kind=c_size_t) :: src_offsets(0:2)\n+  integer(kind=c_size_t) :: dst_dimensions(0:2)\n+  integer(kind=c_size_t) :: src_dimensions(0:2)\n+  integer(kind=c_size_t) :: empty(1:0)\n+\n+  d = omp_get_default_device ()\n+  id = omp_get_initial_device ()\n+\n+  if (d < 0 .or. d >= omp_get_num_devices ()) &\n+    d = id\n+\n+  p = omp_target_alloc (130 * c_sizeof (q), d)\n+  if (.not. c_associated (p)) &\n+    stop 0  ! okay\n+\n+  if (omp_target_memcpy_rect_async (C_NULL_PTR, C_NULL_PTR, 0_c_size_t, 0, &\n+                                    empty, empty, empty, empty,  empty, d, id, &\n+                                    0, obj) < 3 &\n+     .or. omp_target_memcpy_rect_async (C_NULL_PTR, C_NULL_PTR, 0_c_size_t, 0, &\n+                                        empty, empty, empty, empty, empty, &\n+                                        id, d, 0, obj) < 3 &\n+     .or. omp_target_memcpy_rect_async (C_NULL_PTR, C_NULL_PTR, 0_c_size_t, 0, &\n+                                        empty, empty, empty, empty, empty, &\n+                                        id, id, 0, obj) < 3) &\n+    stop 1\n+\n+  q = [(0, i = 0, 127)]\n+  if (omp_target_memcpy (p, c_loc (q), 128 * sizeof (q(0)), 0_c_size_t, &\n+                         0_c_size_t, d, id) /= 0) &\n+    stop 2\n+\n+  q = [(i+1, i = 0, 127)]\n+\n+  volume(2) = 3\n+  volume(1) = 2\n+  volume(0) = 1\n+  dst_offsets(2) = 0\n+  dst_offsets(1) = 0\n+  dst_offsets(0) = 0\n+  src_offsets(2) = 0\n+  src_offsets(1) = 0\n+  src_offsets(0) = 0\n+  dst_dimensions(2) = 5\n+  dst_dimensions(1) = 4\n+  dst_dimensions(0) = 3\n+  src_dimensions(2) = 4\n+  src_dimensions(1) = 3\n+  src_dimensions(0) = 2\n+\n+  if (omp_target_memcpy_rect_async (p, c_loc (q), sizeof (q(0)), 3, volume, &\n+      dst_offsets, src_offsets, dst_dimensions, src_dimensions, d, id, 0, &\n+      obj) /= 0) &\n+    stop 3\n+\n+  !$omp taskwait\n+\n+  q2 = [(0, i = 0, 127)]\n+  if (omp_target_memcpy (c_loc (q2), p, 128 * sizeof (q2(0)), 0_c_size_t, &\n+                         0_c_size_t, id, d) /= 0) &\n+    stop 4\n+\n+  ! q2 is expected to contain: 1 2 3 0 0 5 6 7 0 0 .. 0\n+  if (q2(0) /= 1 .or. q2(1) /= 2 .or. q2(2) /= 3 .or. q2(3) /= 0 &\n+      .or. q2(4) /= 0 .or. q2(5) /= 5 .or. q2(6) /= 6 .or. q2(7) /= 7) &\n+    stop 5\n+\n+  do j = 8, 127\n+    if (q2(j) /= 0) &\n+      stop 6\n+  end do\n+\n+  call omp_target_free (p, d)\n+end program main"}, {"sha": "d0bc5ffa062afb0f47815f311609dd4b6e389951", "filename": "libgomp/testsuite/libgomp.fortran/target-memcpy-rect-async-2.f90", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-memcpy-rect-async-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c420193e86b39a09304b2845335571eefe24d5d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-memcpy-rect-async-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-memcpy-rect-async-2.f90?ref=6c420193e86b39a09304b2845335571eefe24d5d", "patch": "@@ -0,0 +1,117 @@\n+! Test for omp_target_memcpy_rect_async considering dependence objects.\n+\n+program main\n+  use omp_lib\n+  use iso_c_binding\n+  implicit none (external, type)\n+  integer :: d, id, i, j\n+  integer, target :: a(0:127), b(0:63), c(0:127), e(0:15), q(0:127)\n+  type(c_ptr) :: p\n+  integer(omp_depend_kind) :: obj(0:2)\n+\n+  integer(kind=c_size_t) :: volume(0:2)\n+  integer(kind=c_size_t) :: dst_offsets(0:2)\n+  integer(kind=c_size_t) :: src_offsets(0:2)\n+  integer(kind=c_size_t) :: dst_dimensions(0:2)\n+  integer(kind=c_size_t) :: src_dimensions(0:2)\n+\n+  d = omp_get_default_device ()\n+  id = omp_get_initial_device ()\n+\n+  if (d < 0 .or. d >= omp_get_num_devices ()) &\n+    d = id\n+\n+  p = omp_target_alloc (130 * c_sizeof (q), d)\n+  if (.not. c_associated (p)) &\n+    stop 0  ! okay\n+\n+  a = [(42, i = 0, 127)]\n+  b = [(24, i = 0, 63)]\n+  c = [(0, i = 0, 127)]\n+  e = [(77, i = 0, 15)]\n+\n+  volume(2) = 3\n+  volume(1) = 2\n+  volume(0) = 2\n+  dst_offsets(2) = 0\n+  dst_offsets(1) = 0\n+  dst_offsets(0) = 0\n+  src_offsets(2) = 0\n+  src_offsets(1) = 0\n+  src_offsets(0) = 0\n+  dst_dimensions(2) = 5\n+  dst_dimensions(1) = 4\n+  dst_dimensions(0) = 3\n+  src_dimensions(2) = 4\n+  src_dimensions(1) = 3\n+  src_dimensions(0) = 2\n+\n+  !$omp parallel num_threads(5)\n+  !$omp single\n+\n+    !$omp task depend(out: p)\n+    if (omp_target_memcpy (p, c_loc (a), 128 * sizeof (a(0)), 0_c_size_t, &\n+                           0_c_size_t, d, id) /= 0) &\n+      stop 1\n+    !$omp end task\n+\n+    !$omp task depend(inout: p)\n+    if (omp_target_memcpy (p, c_loc (b), 64 * sizeof (b(0)), 0_c_size_t, &\n+                           0_c_size_t, d, id) /= 0) &\n+      stop 2\n+    !$omp end task\n+\n+    !$omp task depend(out: c)\n+    do j = 0, 127\n+      c(j) = j + 1\n+    end do\n+    !$omp end task\n+\n+    !$omp depobj(obj(0)) depend(inout: p)\n+    !$omp depobj(obj(1)) depend(in: c)\n+\n+    ! This produces: 1 2 3 - - 5 6 7 - - at positions 0..9 and\n+    !                13 14 15 - - 17 18 19 - - at positions 20..29.\n+    if (omp_target_memcpy_rect_async (p, c_loc (c), sizeof (c(0)), 3, volume, &\n+                                      dst_offsets, src_offsets, &\n+                                      dst_dimensions, src_dimensions, d, id, &\n+                                      2, obj) /= 0) &\n+      stop 3\n+\n+    !$omp task depend(in: p)\n+    if (omp_target_memcpy (p, c_loc (e), 16 * sizeof (e(0)), 0_c_size_t, &\n+                           0_c_size_t, d, id) /= 0) &\n+      stop 4\n+    !$omp end task\n+\n+  !$omp end single\n+  !$omp end parallel\n+\n+  !$omp taskwait\n+\n+  q = [(0, i = 0, 127)]\n+  if (omp_target_memcpy (c_loc (q), p, 128 * sizeof (q(0)), 0_c_size_t, &\n+                         0_c_size_t, id, d) /= 0) &\n+    stop 5\n+\n+  do j = 0, 15\n+    if (q(j) /= 77) &\n+      stop 6\n+  end do\n+\n+  if (q(20) /= 13 .or. q(21) /= 14 .or. q(22) /= 15 .or. q(25) /= 17 &\n+      .or. q(26) /= 18 .or. q(27) /= 19) &\n+    stop 7\n+\n+  do j = 28, 63\n+    if (q(j) /= 24) &\n+      stop 8\n+  end do\n+\n+  do j = 64, 127\n+    if (q(j) /= 42) &\n+      stop 9\n+  end do\n+\n+  call omp_target_free (p, d)\n+end program main"}]}