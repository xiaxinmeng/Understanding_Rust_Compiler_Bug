{"sha": "48081aae38aa3f86d1c398e70563baf779b0054f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgwODFhYWUzOGFhM2Y4NmQxYzM5OGU3MDU2M2JhZjc3OWIwMDU0Zg==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2008-03-06T17:57:06Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2008-03-06T17:57:06Z"}, "message": "dwarf2out.c (dwarf2out_frame_debug_expr): Consult the dwarf_register_span hook when emitting unwind information for...\n\n\t* dwarf2out.c (dwarf2out_frame_debug_expr): Consult the\n\tdwarf_register_span hook when emitting unwind information for\n\tregister-to-memory saves.\n\t* config/rs6000/rs6000.c (spe_synthesize_frame): Delete.\n\t(rs6000_frame_related): Remove call to spe_synthesize_frame.\n\nFrom-SVN: r132981", "tree": {"sha": "18f4656e1bf5c00f75b60ff3865fa5b950794ce1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18f4656e1bf5c00f75b60ff3865fa5b950794ce1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48081aae38aa3f86d1c398e70563baf779b0054f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48081aae38aa3f86d1c398e70563baf779b0054f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48081aae38aa3f86d1c398e70563baf779b0054f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48081aae38aa3f86d1c398e70563baf779b0054f/comments", "author": null, "committer": null, "parents": [{"sha": "71458b8a12b8b049d0c2c47bd514847477466c0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71458b8a12b8b049d0c2c47bd514847477466c0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71458b8a12b8b049d0c2c47bd514847477466c0f"}], "stats": {"total": 103, "additions": 35, "deletions": 68}, "files": [{"sha": "5b3525037d930576ef3509e83ba6f06fb94ea54a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48081aae38aa3f86d1c398e70563baf779b0054f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48081aae38aa3f86d1c398e70563baf779b0054f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=48081aae38aa3f86d1c398e70563baf779b0054f", "patch": "@@ -1,3 +1,11 @@\n+2008-03-06  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* dwarf2out.c (dwarf2out_frame_debug_expr): Consult the\n+\tdwarf_register_span hook when emitting unwind information for\n+\tregister-to-memory saves.\n+\t* config/rs6000/rs6000.c (spe_synthesize_frame): Delete.\n+\t(rs6000_frame_related): Remove call to spe_synthesize_frame.\n+\n 2008-03-06  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gimplify.c (goa_lhs_expr_p): Allow different ADDR_EXPR nodes"}, {"sha": "781e50e377c05475ffde0c6dd599c9d04eff4e9a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48081aae38aa3f86d1c398e70563baf779b0054f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48081aae38aa3f86d1c398e70563baf779b0054f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=48081aae38aa3f86d1c398e70563baf779b0054f", "patch": "@@ -732,7 +732,6 @@ static const char *rs6000_invalid_within_doloop (const_rtx);\n static rtx rs6000_generate_compare (enum rtx_code);\n static void rs6000_emit_stack_tie (void);\n static void rs6000_frame_related (rtx, rtx, HOST_WIDE_INT, rtx, rtx);\n-static rtx spe_synthesize_frame_save (rtx);\n static bool spe_func_has_64bit_regs_p (void);\n static void emit_frame_save (rtx, rtx, enum machine_mode, unsigned int,\n \t\t\t     int, HOST_WIDE_INT);\n@@ -15386,77 +15385,12 @@ rs6000_frame_related (rtx insn, rtx reg, HOST_WIDE_INT val,\n \t  }\n     }\n \n-  if (TARGET_SPE)\n-    real = spe_synthesize_frame_save (real);\n-\n   RTX_FRAME_RELATED_P (insn) = 1;\n   REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n \t\t\t\t\treal,\n \t\t\t\t\tREG_NOTES (insn));\n }\n \n-/* Given an SPE frame note, return a PARALLEL of SETs with the\n-   original note, plus a synthetic register save.  */\n-\n-static rtx\n-spe_synthesize_frame_save (rtx real)\n-{\n-  rtx synth, offset, reg, real2;\n-\n-  if (GET_CODE (real) != SET\n-      || GET_MODE (SET_SRC (real)) != V2SImode)\n-    return real;\n-\n-  /* For the SPE, registers saved in 64-bits, get a PARALLEL for their\n-     frame related note.  The parallel contains a set of the register\n-     being saved, and another set to a synthetic register (n+1200).\n-     This is so we can differentiate between 64-bit and 32-bit saves.\n-     Words cannot describe this nastiness.  */\n-\n-  gcc_assert (GET_CODE (SET_DEST (real)) == MEM\n-\t      && GET_CODE (XEXP (SET_DEST (real), 0)) == PLUS\n-\t      && GET_CODE (SET_SRC (real)) == REG);\n-\n-  /* Transform:\n-       (set (mem (plus (reg x) (const y)))\n-            (reg z))\n-     into:\n-       (set (mem (plus (reg x) (const y+4)))\n-            (reg z+1200))\n-  */\n-\n-  real2 = copy_rtx (real);\n-  PUT_MODE (SET_DEST (real2), SImode);\n-  reg = SET_SRC (real2);\n-  real2 = replace_rtx (real2, reg, gen_rtx_REG (SImode, REGNO (reg)));\n-  synth = copy_rtx (real2);\n-\n-  if (BYTES_BIG_ENDIAN)\n-    {\n-      offset = XEXP (XEXP (SET_DEST (real2), 0), 1);\n-      real2 = replace_rtx (real2, offset, GEN_INT (INTVAL (offset) + 4));\n-    }\n-\n-  reg = SET_SRC (synth);\n-\n-  synth = replace_rtx (synth, reg,\n-\t\t       gen_rtx_REG (SImode, REGNO (reg) + 1200));\n-\n-  offset = XEXP (XEXP (SET_DEST (synth), 0), 1);\n-  synth = replace_rtx (synth, offset,\n-\t\t       GEN_INT (INTVAL (offset)\n-\t\t\t\t+ (BYTES_BIG_ENDIAN ? 0 : 4)));\n-\n-  RTX_FRAME_RELATED_P (synth) = 1;\n-  RTX_FRAME_RELATED_P (real2) = 1;\n-  if (BYTES_BIG_ENDIAN)\n-    real = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, synth, real2));\n-  else\n-    real = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, real2, synth));\n-\n-  return real;\n-}\n-\n /* Returns an insn that has a vrsave set operation with the\n    appropriate CLOBBERs.  */\n "}, {"sha": "410682b9b1aaddd77cceb544e264b864c69cc931", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48081aae38aa3f86d1c398e70563baf779b0054f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48081aae38aa3f86d1c398e70563baf779b0054f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=48081aae38aa3f86d1c398e70563baf779b0054f", "patch": "@@ -1534,7 +1534,7 @@ static dw_cfa_location cfa_temp;\n static void\n dwarf2out_frame_debug_expr (rtx expr, const char *label)\n {\n-  rtx src, dest;\n+  rtx src, dest, span;\n   HOST_WIDE_INT offset;\n \n   /* If RTX_FRAME_RELATED_P is set on a PARALLEL, process each member of\n@@ -1884,7 +1884,32 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t}\n \n       def_cfa_1 (label, &cfa);\n-      queue_reg_save (label, src, NULL_RTX, offset);\n+      {\n+\tspan = targetm.dwarf_register_span (src);\n+\n+\tif (!span)\n+\t  queue_reg_save (label, src, NULL_RTX, offset);\n+\telse\n+\t  {\n+\t    /* We have a PARALLEL describing where the contents of SRC\n+\t       live.  Queue register saves for each piece of the\n+\t       PARALLEL.  */\n+\t    int par_index;\n+\t    int limit;\n+\t    HOST_WIDE_INT span_offset = offset;\n+\n+\t    gcc_assert (GET_CODE (span) == PARALLEL);\n+\n+\t    limit = XVECLEN (span, 0);\n+\t    for (par_index = 0; par_index < limit; par_index++)\n+\t      {\n+\t\trtx elem = XVECEXP (span, 0, par_index);\n+\n+\t\tqueue_reg_save (label, elem, NULL_RTX, span_offset);\n+\t\tspan_offset += GET_MODE_SIZE (GET_MODE (elem));\n+\t      }\n+\t  }\n+      }\n       break;\n \n     default:"}]}