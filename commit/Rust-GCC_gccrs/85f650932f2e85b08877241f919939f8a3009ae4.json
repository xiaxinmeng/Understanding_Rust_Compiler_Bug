{"sha": "85f650932f2e85b08877241f919939f8a3009ae4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODVmNjUwOTMyZjJlODViMDg4NzcyNDFmOTE5OTM5ZjhhMzAwOWFlNA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2007-02-04T04:11:52Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2007-02-04T04:11:52Z"}, "message": "bitops.md, [...]: Follow spelling conventions.\n\n\t* config/m32c/bitops.md, config/m32c/jump.md,\n\tconfig/m32c/m32c.c, config/m32c/m32c.h, config/m32r/m32r.c,\n\tconfig/m32r/m32r.h, config/m32r/m32r.md,\n\tconfig/m32r/predicates.md, config/m68hc11/larith.asm,\n\tconfig/m68hc11/m68hc11.c, config/m68hc11/m68hc11.h,\n\tconfig/m68k/m68k.h, config/mcore/mcore.md, config/mips/4k.md,\n\tconfig/mips/mips-protos.h, config/mips/mips.c,\n\tconfig/mips/mips.h, config/mips/mips.md, config/mips/mips16.S,\n\tconfig/mn10300/mn10300.h, config/mn10300/predicates.md,\n\tconfig/mt/mt.c, config/mt/mt.h, config/mt/mt.md: Follow\n\tspelling conventions.\n\nFrom-SVN: r121565", "tree": {"sha": "ff5c96fd74ddbd915ef3a28100ba32c1e32246dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff5c96fd74ddbd915ef3a28100ba32c1e32246dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85f650932f2e85b08877241f919939f8a3009ae4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85f650932f2e85b08877241f919939f8a3009ae4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85f650932f2e85b08877241f919939f8a3009ae4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85f650932f2e85b08877241f919939f8a3009ae4/comments", "author": null, "committer": null, "parents": [{"sha": "beeffe367a738b5cdb8add28f809e03a51a84790", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beeffe367a738b5cdb8add28f809e03a51a84790", "html_url": "https://github.com/Rust-GCC/gccrs/commit/beeffe367a738b5cdb8add28f809e03a51a84790"}], "stats": {"total": 250, "additions": 132, "deletions": 118}, "files": [{"sha": "a12d12cbd7616c9abad934331aae043170317053", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -1,3 +1,17 @@\n+2007-02-04  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* config/m32c/bitops.md, config/m32c/jump.md,\n+\tconfig/m32c/m32c.c, config/m32c/m32c.h, config/m32r/m32r.c,\n+\tconfig/m32r/m32r.h, config/m32r/m32r.md,\n+\tconfig/m32r/predicates.md, config/m68hc11/larith.asm,\n+\tconfig/m68hc11/m68hc11.c, config/m68hc11/m68hc11.h,\n+\tconfig/m68k/m68k.h, config/mcore/mcore.md, config/mips/4k.md,\n+\tconfig/mips/mips-protos.h, config/mips/mips.c,\n+\tconfig/mips/mips.h, config/mips/mips.md, config/mips/mips16.S,\n+\tconfig/mn10300/mn10300.h, config/mn10300/predicates.md,\n+\tconfig/mt/mt.c, config/mt/mt.h, config/mt/mt.md: Follow\n+\tspelling conventions.\n+\n 2007-02-03  Douglas Gregor  <doug.gregor@gmail.com>\n \n        * c-opts.c (c_common_post_options): If C++0x mode is enabled, don't"}, {"sha": "33a7058e936525928e8ad9f06ecdbdedd5ab7ea1", "filename": "gcc/config/m32c/bitops.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm32c%2Fbitops.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm32c%2Fbitops.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fbitops.md?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -31,7 +31,7 @@\n ; On the M32C, \"address\" for bit instructions is a regular address,\n ; and the bit number is stored in a separate field.  Thus, we can let\n ; gcc do more interesting things.  However, the M32C cannot set all\n-; the bits in a 16 bit register, which the R8C/M16C can do.\n+; the bits in a 16-bit register, which the R8C/M16C can do.\n \n ; However, it all means that we end up with two sets of patterns, one\n ; for each chip."}, {"sha": "4a358eac40fc91794359bb49573541f3af1c0909", "filename": "gcc/config/m32c/jump.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm32c%2Fjump.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm32c%2Fjump.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fjump.md?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -27,7 +27,7 @@\n        (match_operand:HI 0 \"register_operand\" \"Rhi\"))]\n   \"TARGET_A16\"\n ;  \"jmpi.a\\t%0\"\n-  ; no 16 bit jmpi in r8c\n+  ; no 16-bit jmpi in r8c\n   \"push.b #0 | push.w\\t%0 | rts\"\n   [(set_attr \"flags\" \"x\")]\n   )\n@@ -61,7 +61,7 @@\n   [(set_attr \"flags\" \"n\")]\n )\n \n-; No 16 bit indirect calls on r8c/m16c.  */\n+; No 16-bit indirect calls on r8c/m16c.  */\n (define_insn \"call\"\n   [(call (match_operand:QI 0 \"memory_operand\" \"Si,SaSb,?Rmm\")\n \t (match_operand 1 \"\" \"\"))"}, {"sha": "98e59dd8af7a2c0b59e6eab2eb12841c3b053f73", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -1231,7 +1231,7 @@ static struct\n    calls something else (because we don't know what *that* function\n    might do), but try to be a bit smarter if the handler is a leaf\n    function.  We always save $a0, though, because we use that in the\n-   epilog to copy $fb to $sp.  */\n+   epilogue to copy $fb to $sp.  */\n static int\n need_to_save (int regno)\n {\n@@ -1557,7 +1557,7 @@ m32c_function_arg_regno_p (int r)\n }\n \n /* HImode and PSImode are the two \"native\" modes as far as GCC is\n-   concerned, but the chips also support a 32 bit mode which is used\n+   concerned, but the chips also support a 32-bit mode which is used\n    for some opcodes in R8C/M16C and for reset vectors and such.  */\n #undef TARGET_VALID_POINTER_MODE\n #define TARGET_VALID_POINTER_MODE m32c_valid_pointer_mode\n@@ -1717,8 +1717,8 @@ m32c_initialize_trampoline (rtx tramp, rtx function, rtx chainval)\n       emit_move_insn (A0 (HImode, 0), GEN_INT (0xc475 - 0x10000));\n       emit_move_insn (A0 (HImode, 2), chainval);\n       emit_move_insn (A0 (QImode, 4), GEN_INT (0xfc - 0x100));\n-      /* We use 16 bit addresses here, but store the zero to turn it\n-\t into a 24 bit offset.  */\n+      /* We use 16-bit addresses here, but store the zero to turn it\n+\t into a 24-bit offset.  */\n       emit_move_insn (A0 (HImode, 5), function);\n       emit_move_insn (A0 (QImode, 7), GEN_INT (0x00));\n     }\n@@ -1745,7 +1745,7 @@ m32c_init_libfuncs (void)\n   if (TARGET_A24)\n     {\n       /* We do this because the M32C has an HImode operand, but the\n-\t M16C has an 8 bit operand.  Since gcc looks at the match data\n+\t M16C has an 8-bit operand.  Since gcc looks at the match data\n \t and not the expanded rtl, we have to reset the array so that\n \t the right modes are found. */\n       setcc_gen_code[EQ] = CODE_FOR_seq_24;\n@@ -1905,12 +1905,12 @@ m32c_reg_ok_for_base_p (rtx x, int strict)\n }\n \n /* We have three choices for choosing fb->aN offsets.  If we choose -128,\n-   we need one MOVA -128[fb],aN opcode and 16 bit aN displacements,\n+   we need one MOVA -128[fb],aN opcode and 16-bit aN displacements,\n    like this:\n        EB 4B FF    mova    -128[$fb],$a0\n        D8 0C FF FF mov.w:Q #0,-1[$a0]\n \n-   Alternately, we subtract the frame size, and hopefully use 8 bit aN\n+   Alternately, we subtract the frame size, and hopefully use 8-bit aN\n    displacements:\n        7B F4       stc $fb,$a0\n        77 54 00 01 sub #256,$a0\n@@ -1922,7 +1922,7 @@ m32c_reg_ok_for_base_p (rtx x, int strict)\n \n    We have to subtract *something* so that we have a PLUS rtx to mark\n    that we've done this reload.  The -128 offset will never result in\n-   an 8 bit aN offset, and the payoff for the second case is five\n+   an 8-bit aN offset, and the payoff for the second case is five\n    loads *if* those loads are within 256 bytes of the other end of the\n    frame, so the third case seems best.  Note that we subtract the\n    zero, but detect that in the addhi3 pattern.  */"}, {"sha": "b3d5cec6613613f85d29b734c92afb0a38e684a8", "filename": "gcc/config/m32c/m32c.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm32c%2Fm32c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm32c%2Fm32c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.h?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -29,9 +29,9 @@\n #define STARTFILE_SPEC \"crt0.o%s crtbegin.o%s\"\n \n /* There are four CPU series we support, but they basically break down\n-   into two families - the R8C/M16C families, with 16 bit address\n-   registers and one set of opcodes, and the M32CM/M32C group, with 24\n-   bit address registers and a different set of opcodes.  The\n+   into two families - the R8C/M16C families, with 16-bit address\n+   registers and one set of opcodes, and the M32CM/M32C group, with\n+   24-bit address registers and a different set of opcodes.  The\n    assembler doesn't care except for which opcode set is needed; the\n    big difference is in the memory maps, which we cover in\n    LIB_SPEC.  */\n@@ -139,7 +139,7 @@ machine_function;\n    GCC expects us to have a \"native\" format, so we pick the one that\n    matches \"int\".  Pointers are 16 bits for R8C/M16C (when TARGET_A16\n    is true) and 24 bits for M32CM/M32C (when TARGET_A24 is true), but\n-   24 bit pointers are stored in 32 bit words.  */\n+   24-bit pointers are stored in 32-bit words.  */\n #define BITS_PER_UNIT 8\n #define UNITS_PER_WORD 2\n #define POINTER_SIZE (TARGET_A16 ? 16 : 32)\n@@ -150,7 +150,7 @@ machine_function;\n #define STACK_BOUNDARY (TARGET_A16 ? 8 : 16)\n \n /* We do this because we care more about space than about speed.  For\n-   the chips with 16 bit busses, we could set these to 16 if\n+   the chips with 16-bit busses, we could set these to 16 if\n    desired.  */\n #define FUNCTION_BOUNDARY 8\n #define BIGGEST_ALIGNMENT 8\n@@ -180,9 +180,9 @@ machine_function;\n \n /* Register layout:\n \n-        [r0h][r0l]  $r0  (16 bits, or two 8 bit halves)\n+        [r0h][r0l]  $r0  (16 bits, or two 8-bit halves)\n         [--------]  $r2  (16 bits)\n-        [r1h][r1l]  $r1  (16 bits, or two 8 bit halves)\n+        [r1h][r1l]  $r1  (16 bits, or two 8-bit halves)\n         [--------]  $r3  (16 bits)\n    [---][--------]  $a0  (might be 24 bits)\n    [---][--------]  $a1  (might be 24 bits)\n@@ -665,7 +665,7 @@ typedef struct m32c_cumulative_args\n \n #define STORE_FLAG_VALUE 1\n \n-/* 16 or 24 bit pointers */\n+/* 16- or 24-bit pointers */\n #define Pmode (TARGET_A16 ? HImode : PSImode)\n #define FUNCTION_MODE QImode\n "}, {"sha": "6c9f3e54d62e2e13f9a2627aaa93768f6cf918c3", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -215,7 +215,7 @@ m32r_init (void)\n    indexed by hard register number, and one indexed by mode.  */\n \n /* The purpose of m32r_mode_class is to shrink the range of modes so that\n-   they all fit (as bit numbers) in a 32 bit word (again).  Each real mode is\n+   they all fit (as bit numbers) in a 32-bit word (again).  Each real mode is\n    mapped into one m32r_mode_class mode.  */\n \n enum m32r_mode_class\n@@ -515,7 +515,7 @@ small_data_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   return 0;\n }\n \n-/* Return 1 if OP is a symbol that can use 24 bit addressing.  */\n+/* Return 1 if OP is a symbol that can use 24-bit addressing.  */\n \n int\n addr24_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n@@ -550,7 +550,7 @@ addr24_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   return 0;\n }\n \n-/* Return 1 if OP is a symbol that needs 32 bit addressing.  */\n+/* Return 1 if OP is a symbol that needs 32-bit addressing.  */\n \n int\n addr32_operand (rtx op, enum machine_mode mode)\n@@ -602,7 +602,7 @@ easy_di_const (rtx op)\n   split_double (op, &high_rtx, &low_rtx);\n   high = INTVAL (high_rtx);\n   low = INTVAL (low_rtx);\n-  /* Pick constants loadable with 2 16 bit `ldi' insns.  */\n+  /* Pick constants loadable with 2 16-bit `ldi' insns.  */\n   if (high >= -128 && high <= 127\n       && low >= -128 && low <= 127)\n     return 1;\n@@ -1852,7 +1852,7 @@ m32r_print_operand (FILE * file, rtx x, int code)\n \t Bottom halves.  For symbols output arguments to a seth/add3 pair to\n \t set Top and Bottom halves.  The difference exists because for\n \t constants seth/or3 is more readable but for symbols we need to use\n-\t the same scheme as `ld' and `st' insns (16 bit addend is signed).  */\n+\t the same scheme as `ld' and `st' insns (16-bit addend is signed).  */\n       switch (GET_CODE (x))\n \t{\n \tcase CONST_INT :\n@@ -2181,7 +2181,7 @@ static void\n block_move_call (rtx dest_reg, rtx src_reg, rtx bytes_rtx)\n {\n   /* We want to pass the size as Pmode, which will normally be SImode\n-     but will be DImode if we are using 64 bit longs and pointers.  */\n+     but will be DImode if we are using 64-bit longs and pointers.  */\n   if (GET_MODE (bytes_rtx) != VOIDmode\n       && GET_MODE (bytes_rtx) != Pmode)\n     bytes_rtx = convert_to_mode (Pmode, bytes_rtx, 1);"}, {"sha": "637ed06ff6eea4c13f1e0e7613d30f10cbf11318", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -704,14 +704,14 @@ extern enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n    This macro defines what the ranges are.\n    C is the letter, and VALUE is a constant value.\n    Return 1 if VALUE is in the range specified by C.  */\n-/* 'I' is used for 8 bit signed immediates.\n-   'J' is used for 16 bit signed immediates.\n-   'K' is used for 16 bit unsigned immediates.\n-   'L' is used for 16 bit immediates left shifted by 16 (sign ???).\n-   'M' is used for 24 bit unsigned immediates.\n-   'N' is used for any 32 bit non-symbolic value.\n-   'O' is used for 5 bit unsigned immediates (shift count).\n-   'P' is used for 16 bit signed immediates for compares\n+/* 'I' is used for 8-bit signed immediates.\n+   'J' is used for 16-bit signed immediates.\n+   'K' is used for 16-bit unsigned immediates.\n+   'L' is used for 16-bit immediates left shifted by 16 (sign ???).\n+   'M' is used for 24-bit unsigned immediates.\n+   'N' is used for any 32-bit non-symbolic value.\n+   'O' is used for 5-bit unsigned immediates (shift count).\n+   'P' is used for 16-bit signed immediates for compares\n        (values in the range -32767 to +32768).  */\n \n /* Return true if a value is inside a range.  */\n@@ -1135,7 +1135,7 @@ L2:     .word STATIC\n \n /* Nonzero if the constant value X is a legitimate general operand.\n    We don't allow (plus symbol large-constant) as the relocations can't\n-   describe it.  INTVAL > 32767 handles both 16 bit and 24 bit relocations.\n+   describe it.  INTVAL > 32767 handles both 16-bit and 24-bit relocations.\n    We allow all CONST_DOUBLE's as the md file patterns will force the\n    constant to memory if they can't handle them.  */\n \n@@ -1580,7 +1580,7 @@ extern char m32r_punct_chars[256];\n /* Specify the machine mode that pointers have.\n    After generation of rtl, the compiler makes no further distinction\n    between pointers and any other objects of this machine mode.  */\n-/* ??? The M32R doesn't have full 32 bit pointers, but making this PSImode has\n+/* ??? The M32R doesn't have full 32-bit pointers, but making this PSImode has\n    its own problems (you have to add extendpsisi2 and truncsipsi2).\n    Try to avoid it.  */\n #define Pmode SImode"}, {"sha": "a4db130ece2f0ad862ab4d26c324c3605ed26f5f", "filename": "gcc/config/m32r/m32r.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm32r%2Fm32r.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm32r%2Fm32r.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.md?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -116,8 +116,8 @@\n ;; These fetch units are a hack to get GCC to better pack the instructions\n ;; for the M32Rx processor, which has two execution pipes.\n ;;\n-;; In reality there is only one decoder, which can decode either two 16 bits\n-;; instructions, or a single 32 bits instruction.\n+;; In reality there is only one decoder, which can decode either two 16-bit\n+;; instructions, or a single 32-bit instruction.\n ;;\n ;; Note, \"fetch\" models both the IF and the D pipeline stages.\n ;;\n@@ -444,15 +444,15 @@\n      use 2 byte instructions wherever possible.  We can assume the\n      constant isn't loadable with any of ldi, ld24, or seth.  */\n \n-  /* See if we can load a 24 bit unsigned value and invert it.  */\n+  /* See if we can load a 24-bit unsigned value and invert it.  */\n   if (UINT24_P (~ val))\n     {\n       emit_insn (gen_movsi (operands[0], GEN_INT (~ val)));\n       emit_insn (gen_one_cmplsi2 (operands[0], operands[0]));\n       DONE;\n     }\n \n-  /* See if we can load a 24 bit unsigned value and shift it into place.\n+  /* See if we can load a 24-bit unsigned value and shift it into place.\n      0x01fffffe is just beyond ld24's range.  */\n   for (shift = 1, tmp = 0x01fffffe;\n        shift < 8;\n@@ -488,7 +488,7 @@\n ;; the small data area are indexed off that.  This is done for each reference\n ;; but cse will clean things up for us.  We let the compiler choose the\n ;; register to use so we needn't allocate (and maybe even fix) a special\n-;; register to use.  Since the load and store insns have a 16 bit offset the\n+;; register to use.  Since the load and store insns have a 16-bit offset the\n ;; total size of the data area can be 64K.  However, if the data area lives\n ;; above 16M (24 bits), _SDA_BASE_ will have to be loaded with seth/add3 which\n ;; would then yield 3 instructions to reference an object [though there would\n@@ -531,7 +531,7 @@\n   [(set_attr \"type\" \"int4\")\n    (set_attr \"length\" \"4\")])\n \n-;; 32 bit address support.\n+;; 32-bit address support.\n \n (define_expand \"movsi_addr32\"\n   [(set (match_dup 2)"}, {"sha": "026a3cfc8f3b46ed614d21f53354b9cb912db7f5", "filename": "gcc/config/m32r/predicates.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm32r%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm32r%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fpredicates.md?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -253,7 +253,7 @@\n     }\n })\n \n-;; Return true if OP is a signed 8 bit immediate value.\n+;; Return true if OP is a signed 8-bit immediate value.\n \n (define_predicate \"int8_operand\"\n   (match_code \"const_int\")\n@@ -263,7 +263,7 @@\n   return INT8_P (INTVAL (op));\n })\n \n-;; Return true if OP is an unsigned 16 bit immediate value.\n+;; Return true if OP is an unsigned 16-bit immediate value.\n \n (define_predicate \"uint16_operand\"\n   (match_code \"const_int\")\n@@ -273,7 +273,7 @@\n   return UINT16_P (INTVAL (op));\n })\n \n-;; Return true if OP is a register or signed 16 bit value.\n+;; Return true if OP is a register or signed 16-bit value.\n \n (define_predicate \"reg_or_int16_operand\"\n   (match_code \"reg,subreg,const_int\")\n@@ -285,7 +285,7 @@\n   return INT16_P (INTVAL (op));\n })\n \n-;; Return true if OP is a register or an unsigned 16 bit value.\n+;; Return true if OP is a register or an unsigned 16-bit value.\n \n (define_predicate \"reg_or_uint16_operand\"\n   (match_code \"reg,subreg,const_int\")\n@@ -297,7 +297,7 @@\n   return UINT16_P (INTVAL (op));\n })\n \n-;; Return true if OP is a register or signed 16 bit value for\n+;; Return true if OP is a register or signed 16-bit value for\n ;; compares.\n \n (define_predicate \"reg_or_cmp_int16_operand\"\n@@ -330,7 +330,7 @@\n   return (value != 0) && (UINT16_P (value) || CMP_INT16_P (-value));\n })\n \n-;; Return true if OP is a signed 16 bit immediate value useful in\n+;; Return true if OP is a signed 16-bit immediate value useful in\n ;; comparisons.\n \n (define_predicate \"cmp_int16_operand\""}, {"sha": "7bb06915fcadc49cde95b61cd1e8d870497619b6", "filename": "gcc/config/m68hc11/larith.asm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm68hc11%2Flarith.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm68hc11%2Flarith.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Flarith.asm?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -804,7 +804,7 @@ AB_neg:\n #else\n #ifdef NO_TMP\n \t;\n-\t; 16 bit multiplication without temp memory location.\n+\t; 16-bit multiplication without temp memory location.\n \t; (smaller but slower)\n \t;\n \tpshx\t\t\t; (4)"}, {"sha": "1b14284bc16534a5de9edb9f4aff92882af9fee1", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -382,9 +382,9 @@ create_regs_rtx (void)\n }\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-    - 8 bit values are stored anywhere (except the SP register).\n-    - 16 bit values can be stored in any register whose mode is 16\n-    - 32 bit values can be stored in D, X registers or in a soft register\n+    - 8-bit values are stored anywhere (except the SP register).\n+    - 16-bit values can be stored in any register whose mode is 16\n+    - 32-bit values can be stored in D, X registers or in a soft register\n       (except the last one because we need 2 soft registers)\n     - Values whose size is > 32 bit are not stored in real hard\n       registers.  They may be stored in soft registers if there are"}, {"sha": "2316823ca11087a9721ca0fb825a2492ccb7c824", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -409,9 +409,9 @@ SOFT_REG_FIRST+28, SOFT_REG_FIRST+29,SOFT_REG_FIRST+30,SOFT_REG_FIRST+31\n    ((GET_MODE_SIZE (MODE) + HARD_REG_SIZE - 1) / HARD_REG_SIZE))\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-    - 8 bit values are stored anywhere (except the SP register).\n-    - 16 bit values can be stored in any register whose mode is 16\n-    - 32 bit values can be stored in D, X registers or in a soft register\n+    - 8-bit values are stored anywhere (except the SP register).\n+    - 16-bit values can be stored in any register whose mode is 16\n+    - 32-bit values can be stored in D, X registers or in a soft register\n       (except the last one because we need 2 soft registers)\n     - Values whose size is > 32 bit are not stored in real hard\n       registers.  They may be stored in soft registers if there are\n@@ -461,7 +461,7 @@ enum reg_class\n   D_REGS,\t\t\t/* 16-bit data register */\n   X_REGS,\t\t\t/* 16-bit X register */\n   Y_REGS,\t\t\t/* 16-bit Y register */\n-  SP_REGS,\t\t\t/* 16 bit stack pointer */\n+  SP_REGS,\t\t\t/* 16-bit stack pointer */\n   DA_REGS,\t\t\t/* 8-bit A reg.  */\n   DB_REGS,\t\t\t/* 8-bit B reg.  */\n   Z_REGS,\t\t\t/* 16-bit fake Z register */\n@@ -489,7 +489,7 @@ enum reg_class\n   D_OR_SP_OR_S_REGS,\t\t/* 16-bit soft register or D or SP register */\n   A_OR_S_REGS,\t\t\t/* 16-bit soft register or X, Y registers */\n   D_OR_A_OR_S_REGS,\t\t/* 16-bit soft register or D, X, Y registers */\n-  TMP_REGS,\t\t\t/* 16 bit fake scratch register */\n+  TMP_REGS,\t\t\t/* 16-bit fake scratch register */\n   D_OR_A_OR_TMP_REGS,\t\t/* General scratch register */\n   G_REGS,\t\t\t/* 16-bit general register\n                                    (H_REGS + soft registers) */"}, {"sha": "39a5878089714f1f208389ac254cc11b363cc7c2", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -288,7 +288,7 @@ Boston, MA 02110-1301, USA.  */\n #define PREFERRED_STACK_BOUNDARY (TARGET_COLDFIRE ? 32 : 16)\n \n /* No data type wants to be aligned rounder than this.\n-   Most published ABIs say that ints should be aligned on 16 bit\n+   Most published ABIs say that ints should be aligned on 16-bit\n    boundaries, but CPUs with 32-bit busses get better performance\n    aligned on 32-bit boundaries.  ColdFires without a misalignment\n    module require 32-bit alignment.  */\n@@ -918,7 +918,7 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n \t    || (INTVAL (XEXP (X, 1)) == 8\t\t\\\n \t\t&& (TARGET_COLDFIRE_FPU || !TARGET_COLDFIRE)))))\n \n-/* Coldfire FPU only accepts addressing modes 2-5 */\n+/* ColdFire FPU only accepts addressing modes 2-5.  */\n #define GO_IF_COLDFIRE_FPU_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\\\n { if (LEGITIMATE_BASE_REG_P (X)\t\t\t\t\t\t\\\n       || ((GET_CODE (X) == PRE_DEC || GET_CODE (X) == POST_INC)\t\t\\"}, {"sha": "5be6dc036d8b67c07cf7d1c298756edf44d1dc08", "filename": "gcc/config/mcore/mcore.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmcore%2Fmcore.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmcore%2Fmcore.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.md?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -2657,7 +2657,7 @@\n {\n   if (INTVAL (operands[2]) == 8 && INTVAL (operands[3]) % 8 == 0)\n     {\n-       /* 8 bit field, aligned properly, use the xtrb[0123]+sext sequence.  */\n+       /* 8-bit field, aligned properly, use the xtrb[0123]+sext sequence.  */\n        /* not DONE, not FAIL, but let the RTL get generated....  */\n     }\n   else if (TARGET_W_FIELD)\n@@ -2694,7 +2694,7 @@\n {\n   if (INTVAL (operands[2]) == 8 && INTVAL (operands[3]) % 8 == 0)\n     {\n-       /* 8 bit field, aligned properly, use the xtrb[0123] sequence.  */\n+       /* 8-bit field, aligned properly, use the xtrb[0123] sequence.  */\n        /* Let the template generate some RTL....  */\n     }\n   else if (CONST_OK_FOR_K ((1 << INTVAL (operands[2])) - 1))"}, {"sha": "8e660934ef8ab34f9e1335128472aaaf3f642054", "filename": "gcc/config/mips/4k.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmips%2F4k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmips%2F4k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2F4k.md?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -51,8 +51,8 @@\n   \"r4k_ixu_arith\")\n \n ;; 4Kc/4Km \n-;; unsigned divide - 8/16/24/32 bit operand have latencies  9/17/25/33\n-;;   signed divide - 8/16/24/32 bit operand have latencies 10/18/26/34\n+;; unsigned divide - 8/16/24/32-bit operand have latencies  9/17/25/33\n+;;   signed divide - 8/16/24/32-bit operand have latencies 10/18/26/34\n (define_insn_reservation \"r4k_idiv_4kc\" 34\n   (and (eq_attr \"cpu\" \"4kc\")\n        (and (eq_attr \"type\" \"idiv\")"}, {"sha": "a9fa42ee8159076523cbfbf7954f80f80bcea015", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -3,7 +3,7 @@\n    1999, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n    Contributed by A. Lichnewsky (lich@inria.inria.fr).\n    Changed by Michael Meissner\t(meissner@osf.org).\n-   64 bit r4000 support by Ian Lance Taylor (ian@cygnus.com) and\n+   64-bit r4000 support by Ian Lance Taylor (ian@cygnus.com) and\n    Brendan Eich (brendan@microunity.com).\n \n This file is part of GCC."}, {"sha": "93c482368ae2b2b05ee94c6ed5713e41a7620b19", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -3,7 +3,7 @@\n    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n    Contributed by A. Lichnewsky, lich@inria.inria.fr.\n    Changes by Michael Meissner, meissner@osf.org.\n-   64 bit r4000 support by Ian Lance Taylor, ian@cygnus.com, and\n+   64-bit r4000 support by Ian Lance Taylor, ian@cygnus.com, and\n    Brendan Eich, brendan@microunity.com.\n \n This file is part of GCC.\n@@ -2522,7 +2522,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t      return true;\n \t    }\n \n-\t  /* We can use cmpi for an xor with an unsigned 16 bit value.  */\n+\t  /* We can use cmpi for an xor with an unsigned 16-bit value.  */\n \t  if ((outer_code) == XOR\n \t      && INTVAL (x) >= 0 && INTVAL (x) < 0x10000)\n \t    {\n@@ -2531,7 +2531,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t    }\n \n \t  /* We may be able to use slt or sltu for a comparison with a\n-\t     signed 16 bit value.  (The boundary conditions aren't quite\n+\t     signed 16-bit value.  (The boundary conditions aren't quite\n \t     right, but this is just a heuristic anyhow.)  */\n \t  if (((outer_code) == LT || (outer_code) == LE\n \t       || (outer_code) == GE || (outer_code) == GT\n@@ -2706,7 +2706,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n       return true;\n \n     case SIGN_EXTEND:\n-      /* A sign extend from SImode to DImode in 64 bit mode is often\n+      /* A sign extend from SImode to DImode in 64-bit mode is often\n          zero instructions, because the result can often be used\n          directly by another instruction; we'll call it one.  */\n       if (TARGET_64BIT && mode == DImode\n@@ -2960,7 +2960,7 @@ mips_output_move (rtx dest, rtx src)\n       if (src_code == CONST_INT)\n \t{\n \t  /* Don't use the X format, because that will give out of\n-\t     range numbers for 64 bit hosts and 32 bit targets.  */\n+\t     range numbers for 64-bit hosts and 32-bit targets.  */\n \t  if (!TARGET_MIPS16)\n \t    return \"li\\t%0,%1\\t\\t\\t# %X1\";\n \n@@ -3888,8 +3888,8 @@ function_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       && host_integerp (TYPE_SIZE_UNIT (type), 1)\n       && named)\n     {\n-      /* The Irix 6 n32/n64 ABIs say that if any 64 bit chunk of the\n-\t structure contains a double in its entirety, then that 64 bit\n+      /* The Irix 6 n32/n64 ABIs say that if any 64-bit chunk of the\n+\t structure contains a double in its entirety, then that 64-bit\n \t chunk is passed in a floating point register.  */\n       tree field;\n \n@@ -3905,7 +3905,7 @@ function_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       if (field != 0)\n \t{\n \t  /* Now handle the special case by returning a PARALLEL\n-\t     indicating where each 64 bit chunk goes.  INFO.REG_WORDS\n+\t     indicating where each 64-bit chunk goes.  INFO.REG_WORDS\n \t     chunks are passed in registers.  */\n \t  unsigned int i;\n \t  HOST_WIDE_INT bitpos;\n@@ -6541,7 +6541,7 @@ mips_for_each_saved_reg (HOST_WIDE_INT sp_offset, mips_save_restore_fn fn)\n \n   /* Save registers starting from high to low.  The debuggers prefer at least\n      the return register be stored at func+4, and also it allows us not to\n-     need a nop in the epilog if at least one register is reloaded in\n+     need a nop in the epilogue if at least one register is reloaded in\n      addition to return address.  */\n   offset = cfun->machine->frame.gp_sp_offset - sp_offset;\n   for (regno = GP_REG_LAST; regno >= GP_REG_FIRST; regno--)\n@@ -6645,8 +6645,8 @@ mips_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n #endif\n \n   /* In mips16 mode, we may need to generate a 32 bit to handle\n-     floating point arguments.  The linker will arrange for any 32 bit\n-     functions to call this stub, which will then jump to the 16 bit\n+     floating point arguments.  The linker will arrange for any 32-bit\n+     functions to call this stub, which will then jump to the 16-bit\n      function proper.  */\n   if (TARGET_MIPS16 && !TARGET_SOFT_FLOAT\n       && current_function_args_info.fp_code != 0)\n@@ -7895,7 +7895,7 @@ mips16_fp_args (FILE *file, int fp_code, int from_fp_p)\n   int gparg, fparg;\n   unsigned int f;\n \n-  /* This code only works for the original 32 bit ABI and the O64 ABI.  */\n+  /* This code only works for the original 32-bit ABI and the O64 ABI.  */\n   gcc_assert (TARGET_OLDABI);\n \n   if (from_fp_p)\n@@ -7943,9 +7943,9 @@ mips16_fp_args (FILE *file, int fp_code, int from_fp_p)\n }\n \n /* Build a mips16 function stub.  This is used for functions which\n-   take arguments in the floating point registers.  It is 32 bit code\n+   take arguments in the floating point registers.  It is 32-bit code\n    that moves the floating point args into the general registers, and\n-   then jumps to the 16 bit code.  */\n+   then jumps to the 16-bit code.  */\n \n static void\n build_mips16_function_stub (FILE *file)\n@@ -8040,11 +8040,11 @@ static struct mips16_stub *mips16_stubs;\n \n /* Build a call stub for a mips16 call.  A stub is needed if we are\n    passing any floating point values which should go into the floating\n-   point registers.  If we are, and the call turns out to be to a 32\n-   bit function, the stub will be used to move the values into the\n-   floating point registers before calling the 32 bit function.  The\n-   linker will magically adjust the function call to either the 16 bit\n-   function or the 32 bit stub, depending upon where the function call\n+   point registers.  If we are, and the call turns out to be to a\n+   32-bit function, the stub will be used to move the values into the\n+   floating point registers before calling the 32-bit function.  The\n+   linker will magically adjust the function call to either the 16-bit\n+   function or the 32-bit stub, depending upon where the function call\n    is actually defined.\n \n    Similarly, we need a stub if the return value might come back in a\n@@ -8164,7 +8164,7 @@ build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n     {\n       /* Build a special purpose stub.  When the linker sees a\n \t function call in mips16 code, it will check where the target\n-\t is defined.  If the target is a 32 bit call, the linker will\n+\t is defined.  If the target is a 32-bit call, the linker will\n \t search for the section defined here.  It can tell which\n \t symbol this section is associated with by looking at the\n \t relocation information (the name is unreliable, since this\n@@ -8223,7 +8223,7 @@ build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n \t}\n \n       /* We build the stub code by hand.  That's the only way we can\n-\t do it, since we can't generate 32 bit code during a 16 bit\n+\t do it, since we can't generate 32-bit code during a 16-bit\n \t compilation.  */\n \n       /* We don't want the assembler to insert any nops here.  */"}, {"sha": "de926be4fd8fdfe6f22e525ea047b4633736825b", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -3,7 +3,7 @@\n    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n    Contributed by A. Lichnewsky (lich@inria.inria.fr).\n    Changed by Michael Meissner\t(meissner@osf.org).\n-   64 bit r4000 support by Ian Lance Taylor (ian@cygnus.com) and\n+   64-bit r4000 support by Ian Lance Taylor (ian@cygnus.com) and\n    Brendan Eich (brendan@microunity.com).\n \n This file is part of GCC.\n@@ -83,7 +83,7 @@ struct mips_rtx_cost_data\n \n /* Which ABI to use.  ABI_32 (original 32, or o32), ABI_N32 (n32),\n    ABI_64 (n64) are all defined by SGI.  ABI_O64 is o32 extended\n-   to work on a 64 bit machine.  */\n+   to work on a 64-bit machine.  */\n \n #define ABI_32  0\n #define ABI_N32 1\n@@ -96,7 +96,7 @@ struct mips_rtx_cost_data\n struct mips_cpu_info {\n   /* The 'canonical' name of the processor as far as GCC is concerned.\n      It's typically a manufacturer's prefix followed by a numerical\n-     designation.  It should be lower case.  */\n+     designation.  It should be lowercase.  */\n   const char *name;\n \n   /* The internal processor number that most closely matches this\n@@ -566,7 +566,7 @@ extern const struct mips_rtx_cost_data *mips_cost;\n    ABI for which this is true.  */\n #define ABI_HAS_64BIT_SYMBOLS\t(mips_abi == ABI_64 && !TARGET_SYM32)\n \n-/* ISA has instructions for managing 64 bit fp and gp regs (e.g. mips3).  */\n+/* ISA has instructions for managing 64-bit fp and gp regs (e.g. mips3).  */\n #define ISA_HAS_64BIT_REGS\t(ISA_MIPS3\t\t\t\t\\\n \t\t\t\t || ISA_MIPS4\t\t\t\t\\\n \t\t\t\t || ISA_MIPS64)\n@@ -704,7 +704,7 @@ extern const struct mips_rtx_cost_data *mips_cost;\n #define ISA_HAS_EXT_INS\t\t(ISA_MIPS32R2\t\t\t\t\\\n \t\t\t\t && !TARGET_MIPS16)\n \n-/* ISA has instructions for accessing top part of 64 bit fp regs */\n+/* ISA has instructions for accessing top part of 64-bit fp regs.  */\n #define ISA_HAS_MXHC1\t\t(TARGET_FLOAT64 && ISA_MIPS32R2)\n \n /* True if the result of a load is not available to the next instruction.\n@@ -1123,7 +1123,7 @@ extern const struct mips_rtx_cost_data *mips_cost;\n    on the full register even if a narrower mode is specified.  */\n #define WORD_REGISTER_OPERATIONS\n \n-/* When in 64 bit mode, move insns will sign extend SImode and CCmode\n+/* When in 64-bit mode, move insns will sign extend SImode and CCmode\n    moves.  All other references are zero extended.  */\n #define LOAD_EXTEND_OP(MODE) \\\n   (TARGET_64BIT && ((MODE) == SImode || (MODE) == CCmode) \\\n@@ -1893,8 +1893,8 @@ typedef struct mips_args {\n \n   /* On the mips16, we need to keep track of which floating point\n      arguments were passed in general registers, but would have been\n-     passed in the FP regs if this were a 32 bit function, so that we\n-     can move them to the FP regs if we wind up calling a 32 bit\n+     passed in the FP regs if this were a 32-bit function, so that we\n+     can move them to the FP regs if we wind up calling a 32-bit\n      function.  We record this information in fp_code, encoded in base\n      four.  A zero digit means no floating point argument, a one digit\n      means an SFmode argument, and a two digit means a DFmode argument,"}, {"sha": "a14b449a11dba1ba07fd4d5488d7164739c94247", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -3,7 +3,7 @@\n ;;  1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n ;;  Contributed by   A. Lichnewsky, lich@inria.inria.fr\n ;;  Changes by       Michael Meissner, meissner@osf.org\n-;;  64 bit r4000 support by Ian Lance Taylor, ian@cygnus.com, and\n+;;  64-bit r4000 support by Ian Lance Taylor, ian@cygnus.com, and\n ;;  Brendan Eich, brendan@microunity.com.\n \n ;; This file is part of GCC.\n@@ -1699,8 +1699,8 @@\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"mode\" \"DI\")])\n \n-;; The R4650 supports a 32 bit multiply/ 64 bit accumulate\n-;; instruction.  The HI/LO registers are used as a 64 bit accumulator.\n+;; The R4650 supports a 32-bit multiply/ 64-bit accumulate\n+;; instruction.  The HI/LO registers are used as a 64-bit accumulator.\n \n (define_insn \"madsi\"\n   [(set (match_operand:SI 0 \"register_operand\" \"+l\")\n@@ -3533,8 +3533,8 @@\n ;; the sum of two general registers.  We use two versions for each of\n ;; these four instructions: one where the two general registers are\n ;; SImode, and one where they are DImode.  This is because general\n-;; registers will be in SImode when they hold 32 bit values, but,\n-;; since the 32 bit values are always sign extended, the [ls][wd]xc1\n+;; registers will be in SImode when they hold 32-bit values, but,\n+;; since the 32-bit values are always sign extended, the [ls][wd]xc1\n ;; instructions will still work correctly.\n \n ;; ??? Perhaps it would be better to support these instructions by"}, {"sha": "5894a862f5cd20cb79cdb577fa4028bb4d66d107", "filename": "gcc/config/mips/mips16.S", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmips%2Fmips16.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmips%2Fmips16.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips16.S?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -38,7 +38,7 @@ Boston, MA 02110-1301, USA.  */\n    values using the soft-float calling convention, but do the actual\n    operation using the hard floating point instructions.  */\n \n-/* This file contains 32 bit assembly code.  */\n+/* This file contains 32-bit assembly code.  */\n \t.set nomips16\n \n /* Start a function.  */\n@@ -185,8 +185,8 @@ STARTFN (__mips16_fix_truncsfsi)\n /* The double precision operations.  We need to use different code\n    based on the preprocessor symbol __mips64, because the way in which\n    double precision values will change.  Without __mips64, the value\n-   is passed in two 32 bit registers.  With __mips64, the value is\n-   passed in a single 64 bit register.  */\n+   is passed in two 32-bit registers.  With __mips64, the value is\n+   passed in a single 64-bit register.  */\n \n /* Load the first double precision operand.  */\n \n@@ -425,7 +425,7 @@ STARTFN (__mips16_ret_df)\n #endif\n #endif /* !__mips_single_float */\n \n-/* These functions are used by 16 bit code when calling via a function\n+/* These functions are used by 16-bit code when calling via a function\n    pointer.  They must copy the floating point arguments from the gp\n    regs into the fp regs.  The function to call will be in $2.  The\n    exact set of floating point arguments to copy is encoded in the\n@@ -511,7 +511,7 @@ STARTFN (__mips16_call_stub_10)\n    to use it to hold the return address.\n \n    Note that we do not know whether the function we are calling is 16\n-   bit or 32 bit.  However, it does not matter, because 16 bit\n+   bit or 32 bit.  However, it does not matter, because 16-bit\n    functions always return floating point values in both the gp and\n    the fp regs.  It would be possible to check whether the function\n    being called is 16 bits, in which case the copy is unnecessary;"}, {"sha": "f91db27aaff2bb7e2be24d26d287b2e8c440bb7d", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -90,7 +90,7 @@ extern enum processor_type mn10300_processor;\n /* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n #define PARM_BOUNDARY\t\t32\n \n-/* The stack goes in 32 bit lumps.  */\n+/* The stack goes in 32-bit lumps.  */\n #define STACK_BOUNDARY \t\t32\n \n /* Allocation boundary (in *bits*) for the code of a function."}, {"sha": "096e0b7ef8e1b19a9c875f9b99e1369253f57cab", "filename": "gcc/config/mn10300/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmn10300%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmn10300%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fpredicates.md?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -28,7 +28,7 @@\n \n ;; Return 1 if X is a CONST_INT that is only 8 bits wide.  This is\n ;; used for the btst insn which may examine memory or a register (the\n-;; memory variant only allows an unsigned 8 bit integer).\n+;; memory variant only allows an unsigned 8-bit integer).\n \n (define_predicate \"const_8bit_operand\"\n   (match_code \"const_int\")"}, {"sha": "df5d8f286b29360477a8c55c36a3ec20bb2ddad7", "filename": "gcc/config/mt/mt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmt%2Fmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmt%2Fmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmt%2Fmt.c?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -701,7 +701,7 @@ mt_legitimate_address_p (enum machine_mode mode, rtx xinsn, int strict)\n }\n \n /* Return truth value of whether OP can be used as an operands where a\n-   register or 16 bit unsigned integer is needed.  */\n+   register or 16-bit unsigned integer is needed.  */\n \n int\n uns_arith_operand (rtx op, enum machine_mode mode)\n@@ -713,7 +713,7 @@ uns_arith_operand (rtx op, enum machine_mode mode)\n }\n \n /* Return truth value of whether OP can be used as an operands where a\n-   16 bit integer is needed.  */\n+   16-bit integer is needed.  */\n \n int\n arith_operand (rtx op, enum machine_mode mode)"}, {"sha": "79d94d451c3d363d3a322509549b25e23f81ab9e", "filename": "gcc/config/mt/mt.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmt%2Fmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmt%2Fmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmt%2Fmt.h?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -346,24 +346,24 @@ enum reg_class\n /* For MorphoRISC1:\n \n    `I'\tis used for the range of constants an arithmetic insn can\n-\tactually contain (16 bits signed integers).\n+\tactually contain (16-bit signed integers).\n \n    `J'\tis used for the range which is just zero (ie, $r0).\n \n    `K'\tis used for the range of constants a logical insn can actually\n-\tcontain (16 bit zero-extended integers).\n+\tcontain (16-bit zero-extended integers).\n \n    `L'\tis used for the range of constants that be loaded with lui\n \t(ie, the bottom 16 bits are zero).\n \n    `M'\tis used for the range of constants that take two words to load\n \t(ie, not matched by `I', `K', and `L').\n \n-   `N'\tis used for negative 16 bit constants other than -65536.\n+   `N'\tis used for negative 16-bit constants other than -65536.\n \n-   `O'\tis a 15 bit signed integer.\n+   `O'\tis a 15-bit signed integer.\n \n-   `P'\tis used for positive 16 bit constants.  */\n+   `P'\tis used for positive 16-bit constants.  */\n \n #define SMALL_INT(X) ((unsigned HOST_WIDE_INT) (INTVAL (X) + 0x8000) < 0x10000)\n #define SMALL_INT_UNSIGNED(X) ((unsigned HOST_WIDE_INT) (INTVAL (X)) < 0x10000)"}, {"sha": "0082f7a597ca073e85ec11ad3a7d211dc80b31f0", "filename": "gcc/config/mt/mt.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmt%2Fmt.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f650932f2e85b08877241f919939f8a3009ae4/gcc%2Fconfig%2Fmt%2Fmt.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmt%2Fmt.md?ref=85f650932f2e85b08877241f919939f8a3009ae4", "patch": "@@ -865,7 +865,7 @@\n }\")\n \n \f\n-;; 32 bit Integer arithmetic\n+;; 32-bit Integer arithmetic\n \n ;; Addition\n (define_insn \"addsi3\"\n@@ -903,7 +903,7 @@\n    (set_attr \"type\" \"arith,arith\")])\n \n \f\n-;; 32 bit Integer Shifts and Rotates\n+;; 32-bit Integer Shifts and Rotates\n \n ;; Arithmetic Shift Left\n (define_insn \"ashlsi3\"\n@@ -942,9 +942,9 @@\n    (set_attr \"type\" \"arith,arith\")])\n \n \f\n-;; 32 Bit Integer Logical operations\n+;; 32-Bit Integer Logical operations\n \n-;; Logical AND, 32 bit integers\n+;; Logical AND, 32-bit integers\n (define_insn \"andsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(and:SI (match_operand:SI 1 \"register_operand\" \"%r,r\")\n@@ -956,7 +956,7 @@\n   [(set_attr \"length\" \"4,4\")\n    (set_attr \"type\" \"arith,arith\")])\n \n-;; Inclusive OR, 32 bit integers\n+;; Inclusive OR, 32-bit integers\n (define_insn \"iorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"%r,r\")\n@@ -968,7 +968,7 @@\n   [(set_attr \"length\" \"4,4\")\n    (set_attr \"type\" \"arith,arith\")])\n \n-;; Exclusive OR, 32 bit integers\n+;; Exclusive OR, 32-bit integers\n (define_insn \"xorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"%r,r\")\n@@ -981,7 +981,7 @@\n    (set_attr \"type\" \"arith,arith\")])\n \n \n-;; One's complement, 32 bit integers\n+;; One's complement, 32-bit integers\n (define_insn \"one_cmplsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))]"}]}