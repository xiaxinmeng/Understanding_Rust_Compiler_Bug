{"sha": "c67f312d20e15e5aa18c587693b4ab7e131596c1", "node_id": "C_kwDOANBUbNoAKGM2N2YzMTJkMjBlMTVlNWFhMThjNTg3NjkzYjRhYjdlMTMxNTk2YzE", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2023-03-20T18:48:06Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2023-03-20T18:48:06Z"}, "message": "Rework 128-bit complex multiply and divide.\n\nThis patch reworks how the complex multiply and divide built-in functions are\ndone.  Previously GCC created built-in declarations for doing long double complex\nmultiply and divide when long double is IEEE 128-bit.  However, it did not\nsupport __ibm128 complex multiply and divide if long double is IEEE 128-bit.\n\nThis code does not create the built-in declaration with the changed name.\nInstead, it uses the TARGET_MANGLE_DECL_ASSEMBLER_NAME hook to change the name\nbefore it is written out to the assembler file like it now does for all of the\nother long double built-in functions.\n\n2023-03-20   Michael Meissner  <meissner@linux.ibm.com>\n\ngcc/\n\n\tPR target/109067\n\t* config/rs6000/rs6000.cc (create_complex_muldiv): Delete.\n\t(init_float128_ieee): Delete code to switch complex multiply and divide\n\tfor long double.\n\t(complex_multiply_builtin_code): New helper function.\n\t(complex_divide_builtin_code): Likewise.\n\t(rs6000_mangle_decl_assembler_name): Add support for mangling the name\n\tof complex 128-bit multiply and divide built-in functions.\n\ngcc/testsuite/\n\n\tPR target/109067\n\t* gcc.target/powerpc/divic3-1.c: New test.\n\t* gcc.target/powerpc/divic3-2.c: Likewise.\n\t* gcc.target/powerpc/mulic3-1.c: Likewise.\n\t* gcc.target/powerpc/mulic3-2.c: Likewise.", "tree": {"sha": "8249ecffa76f724bc6fb500d08a2cf5b44934d29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8249ecffa76f724bc6fb500d08a2cf5b44934d29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c67f312d20e15e5aa18c587693b4ab7e131596c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c67f312d20e15e5aa18c587693b4ab7e131596c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c67f312d20e15e5aa18c587693b4ab7e131596c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c67f312d20e15e5aa18c587693b4ab7e131596c1/comments", "author": null, "committer": null, "parents": [{"sha": "4410a08b80cc40342eeaa5b6af824cd4352b218c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4410a08b80cc40342eeaa5b6af824cd4352b218c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4410a08b80cc40342eeaa5b6af824cd4352b218c"}], "stats": {"total": 203, "additions": 156, "deletions": 47}, "files": [{"sha": "fa5f93a874f00e8a1c9054cbc6bc3e5e21ea31bd", "filename": "gcc/config/rs6000/rs6000.cc", "status": "modified", "additions": 64, "deletions": 47, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c67f312d20e15e5aa18c587693b4ab7e131596c1/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c67f312d20e15e5aa18c587693b4ab7e131596c1/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.cc?ref=c67f312d20e15e5aa18c587693b4ab7e131596c1", "patch": "@@ -11154,26 +11154,6 @@ init_float128_ibm (machine_mode mode)\n     }\n }\n \n-/* Create a decl for either complex long double multiply or complex long double\n-   divide when long double is IEEE 128-bit floating point.  We can't use\n-   __multc3 and __divtc3 because the original long double using IBM extended\n-   double used those names.  The complex multiply/divide functions are encoded\n-   as builtin functions with a complex result and 4 scalar inputs.  */\n-\n-static void\n-create_complex_muldiv (const char *name, built_in_function fncode, tree fntype)\n-{\n-  tree fndecl = add_builtin_function (name, fntype, fncode, BUILT_IN_NORMAL,\n-\t\t\t\t      name, NULL_TREE);\n-\n-  set_builtin_decl (fncode, fndecl, true);\n-\n-  if (TARGET_DEBUG_BUILTIN)\n-    fprintf (stderr, \"create complex %s, fncode: %d\\n\", name, (int) fncode);\n-\n-  return;\n-}\n-\n /* Set up IEEE 128-bit floating point routines.  Use different names if the\n    arguments can be passed in a vector register.  The historical PowerPC\n    implementation of IEEE 128-bit floating point used _q_<op> for the names, so\n@@ -11185,32 +11165,6 @@ init_float128_ieee (machine_mode mode)\n {\n   if (FLOAT128_VECTOR_P (mode))\n     {\n-      static bool complex_muldiv_init_p = false;\n-\n-      /* Set up to call __mulkc3 and __divkc3 under -mabi=ieeelongdouble.  If\n-\t we have clone or target attributes, this will be called a second\n-\t time.  We want to create the built-in function only once.  */\n-     if (mode == TFmode && TARGET_IEEEQUAD && !complex_muldiv_init_p)\n-       {\n-\t complex_muldiv_init_p = true;\n-\t built_in_function fncode_mul =\n-\t   (built_in_function) (BUILT_IN_COMPLEX_MUL_MIN + TCmode\n-\t\t\t\t- MIN_MODE_COMPLEX_FLOAT);\n-\t built_in_function fncode_div =\n-\t   (built_in_function) (BUILT_IN_COMPLEX_DIV_MIN + TCmode\n-\t\t\t\t- MIN_MODE_COMPLEX_FLOAT);\n-\n-\t tree fntype = build_function_type_list (complex_long_double_type_node,\n-\t\t\t\t\t\t long_double_type_node,\n-\t\t\t\t\t\t long_double_type_node,\n-\t\t\t\t\t\t long_double_type_node,\n-\t\t\t\t\t\t long_double_type_node,\n-\t\t\t\t\t\t NULL_TREE);\n-\n-\t create_complex_muldiv (\"__mulkc3\", fncode_mul, fntype);\n-\t create_complex_muldiv (\"__divkc3\", fncode_div, fntype);\n-       }\n-\n       set_optab_libfunc (add_optab, mode, \"__addkf3\");\n       set_optab_libfunc (sub_optab, mode, \"__subkf3\");\n       set_optab_libfunc (neg_optab, mode, \"__negkf2\");\n@@ -28228,6 +28182,27 @@ rs6000_starting_frame_offset (void)\n   return RS6000_STARTING_FRAME_OFFSET;\n }\n \f\n+/* Internal function to return the built-in function id for the complex\n+   multiply operation for a given mode.  */\n+\n+static inline built_in_function\n+complex_multiply_builtin_code (machine_mode mode)\n+{\n+  gcc_assert (IN_RANGE (mode, MIN_MODE_COMPLEX_FLOAT, MAX_MODE_COMPLEX_FLOAT));\n+  int func = BUILT_IN_COMPLEX_MUL_MIN + mode - MIN_MODE_COMPLEX_FLOAT;\n+  return (built_in_function) func;\n+}\n+\n+/* Internal function to return the built-in function id for the complex divide\n+   operation for a given mode.  */\n+\n+static inline built_in_function\n+complex_divide_builtin_code (machine_mode mode)\n+{\n+  gcc_assert (IN_RANGE (mode, MIN_MODE_COMPLEX_FLOAT, MAX_MODE_COMPLEX_FLOAT));\n+  int func = BUILT_IN_COMPLEX_DIV_MIN + mode - MIN_MODE_COMPLEX_FLOAT;\n+  return (built_in_function) func;\n+}\n \n /* On 64-bit Linux and Freebsd systems, possibly switch the long double library\n    function names from <foo>l to <foo>f128 if the default long double type is\n@@ -28246,11 +28221,53 @@ rs6000_starting_frame_offset (void)\n    only do this transformation if the __float128 type is enabled.  This\n    prevents us from doing the transformation on older 32-bit ports that might\n    have enabled using IEEE 128-bit floating point as the default long double\n-   type.  */\n+   type.\n+\n+   We also use the TARGET_MANGLE_DECL_ASSEMBLER_NAME hook to change the\n+   function names used for complex multiply and divide to the appropriate\n+   names.  */\n \n static tree\n rs6000_mangle_decl_assembler_name (tree decl, tree id)\n {\n+  /* Handle complex multiply/divide.  For IEEE 128-bit, use __mulkc3 or\n+     __divkc3 and for IBM 128-bit use __multc3 and __divtc3.  */\n+  if (TARGET_FLOAT128_TYPE\n+      && TREE_CODE (decl) == FUNCTION_DECL\n+      && DECL_IS_UNDECLARED_BUILTIN (decl)\n+      && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL)\n+    {\n+      built_in_function id = DECL_FUNCTION_CODE (decl);\n+      const char *newname = NULL;\n+\n+      if (id == complex_multiply_builtin_code (KCmode))\n+\tnewname = \"__mulkc3\";\n+\n+      else if (id == complex_multiply_builtin_code (ICmode))\n+\tnewname = \"__multc3\";\n+\n+      else if (id == complex_multiply_builtin_code (TCmode))\n+\tnewname = (TARGET_IEEEQUAD) ? \"__mulkc3\" : \"__multc3\";\n+\n+      else if (id == complex_divide_builtin_code (KCmode))\n+\tnewname = \"__divkc3\";\n+\n+      else if (id == complex_divide_builtin_code (ICmode))\n+\tnewname = \"__divtc3\";\n+\n+      else if (id == complex_divide_builtin_code (TCmode))\n+\tnewname = (TARGET_IEEEQUAD) ? \"__divkc3\" : \"__divtc3\";\n+\n+      if (newname)\n+\t{\n+\t  if (TARGET_DEBUG_BUILTIN)\n+\t    fprintf (stderr, \"Map complex mul/div => %s\\n\", newname);\n+\n+\t  return get_identifier (newname);\n+\t}\n+    }\n+\n+  /* Map long double built-in functions if long double is IEEE 128-bit.  */\n   if (TARGET_FLOAT128_TYPE && TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\n       && TREE_CODE (decl) == FUNCTION_DECL\n       && DECL_IS_UNDECLARED_BUILTIN (decl)"}, {"sha": "31dac82c25d2c462cc70021b4bc4419417a3715c", "filename": "gcc/testsuite/gcc.target/powerpc/divic3-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c67f312d20e15e5aa18c587693b4ab7e131596c1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdivic3-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c67f312d20e15e5aa18c587693b4ab7e131596c1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdivic3-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdivic3-1.c?ref=c67f312d20e15e5aa18c587693b4ab7e131596c1", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target ppc_float128_sw } */\n+/* { dg-options \"-O2 -mabi=ieeelongdouble -Wno-psabi\" } */\n+\n+/* When GCC is configured with an older library that does not support IEEE\n+   128-bit, it issues a warning if you change the long double type. We use\n+   -Wno-psabi to silence this warning.  Since this is a code generation test,\n+   it does not matter if the library has full IEEE 128-bit support.  */\n+\n+/* Check that complex divide generates the right call for __ibm128 when long\n+   double is IEEE 128-bit floating point.  */\n+\n+typedef _Complex long double c_ibm128_t __attribute__((mode(__IC__)));\n+\n+void\n+divide (c_ibm128_t *p, c_ibm128_t *q, c_ibm128_t *r)\n+{\n+  *p = *q / *r;\n+}\n+\n+/* { dg-final { scan-assembler {\\mbl .*__divtc3\\M} } } */"}, {"sha": "1a5900e627e02550233efa5faea7b4f5c03df913", "filename": "gcc/testsuite/gcc.target/powerpc/divic3-2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c67f312d20e15e5aa18c587693b4ab7e131596c1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdivic3-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c67f312d20e15e5aa18c587693b4ab7e131596c1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdivic3-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdivic3-2.c?ref=c67f312d20e15e5aa18c587693b4ab7e131596c1", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target ppc_float128_sw } */\n+/* { dg-require-effective-target longdouble128 } */\n+/* { dg-options \"-O2 -mabi=ibmlongdouble -Wno-psabi\" } */\n+\n+/* When GCC is configured with an older library that does not support IEEE\n+   128-bit, it issues a warning if you change the long double type. We use\n+   -Wno-psabi to silence this warning.  Since this is a code generation test,\n+   it does not matter if the library has full IEEE 128-bit support.\n+\n+   We also need to require that the default long double is 128-bits, otherwise\n+   the TC/TF modes might not be available.  */\n+\n+/* Check that complex divide generates the right call for __ibm128 when long\n+   double is IBM 128-bit floating point.  */\n+\n+typedef _Complex long double c_ibm128_t __attribute__((mode(__TC__)));\n+\n+void\n+divide (c_ibm128_t *p, c_ibm128_t *q, c_ibm128_t *r)\n+{\n+  *p = *q / *r;\n+}\n+\n+/* { dg-final { scan-assembler {\\mbl .*__divtc3\\M} } } */"}, {"sha": "664f7118167cbaa98b46f3c3587ea332221d10c6", "filename": "gcc/testsuite/gcc.target/powerpc/mulic3-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c67f312d20e15e5aa18c587693b4ab7e131596c1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmulic3-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c67f312d20e15e5aa18c587693b4ab7e131596c1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmulic3-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmulic3-1.c?ref=c67f312d20e15e5aa18c587693b4ab7e131596c1", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target ppc_float128_sw } */\n+/* { dg-options \"-O2 -mabi=ieeelongdouble -Wno-psabi\" } */\n+\n+/* When GCC is configured with an older library that does not support IEEE\n+   128-bit, it issues a warning if you change the long double type. We use\n+   -Wno-psabi to silence this warning.  Since this is a code generation test,\n+   it does not matter if the library has full IEEE 128-bit support.  */\n+\n+/* Check that complex multiply generates the right call for __ibm128 when long\n+   double is IEEE 128-bit floating point.  */\n+\n+typedef _Complex long double c_ibm128_t __attribute__((mode(__IC__)));\n+\n+void\n+multiply (c_ibm128_t *p, c_ibm128_t *q, c_ibm128_t *r)\n+{\n+  *p = *q * *r;\n+}\n+\n+/* { dg-final { scan-assembler {\\mbl .*__multc3\\M} } } */"}, {"sha": "c2c12dcd8179a2290aed6255b473e014f646b523", "filename": "gcc/testsuite/gcc.target/powerpc/mulic3-2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c67f312d20e15e5aa18c587693b4ab7e131596c1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmulic3-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c67f312d20e15e5aa18c587693b4ab7e131596c1/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmulic3-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmulic3-2.c?ref=c67f312d20e15e5aa18c587693b4ab7e131596c1", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target ppc_float128_sw } */\n+/* { dg-require-effective-target longdouble128 } */\n+/* { dg-options \"-O2 -mabi=ibmlongdouble -Wno-psabi\" } */\n+\n+/* When GCC is configured with an older library that does not support IEEE\n+   128-bit, it issues a warning if you change the long double type. We use\n+   -Wno-psabi to silence this warning.  Since this is a code generation test,\n+   it does not matter if the library has full IEEE 128-bit support.\n+\n+   We also need to require that the default long double is 128-bits, otherwise\n+   the TC/TF modes might not be available.  */\n+\n+/* Check that complex multiply generates the right call for __ibm128 when long\n+   double is IBM 128-bit floating point.  */\n+\n+typedef _Complex long double c_ibm128_t __attribute__((mode(__TC__)));\n+\n+void\n+multiply (c_ibm128_t *p, c_ibm128_t *q, c_ibm128_t *r)\n+{\n+  *p = *q * *r;\n+}\n+\n+/* { dg-final { scan-assembler {\\mbl .*__multc3\\M} } } */"}]}