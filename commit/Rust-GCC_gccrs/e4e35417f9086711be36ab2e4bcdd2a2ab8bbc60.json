{"sha": "e4e35417f9086711be36ab2e4bcdd2a2ab8bbc60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRlMzU0MTdmOTA4NjcxMWJlMzZhYjJlNGJjZGQyYTJhYjhiYmM2MA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-02-20T03:16:30Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-02-20T03:16:30Z"}, "message": "re PR libgcj/5696 (natClass.cc run through superclasses of target if they exist while comparing variable types.)\n\n\tFix for PR libgcj/5696:\n\t* verify.cc (is_assignable_from_slow): Never call\n\t_Jv_IsAssignableFrom.\n\t(verify_instructions_0): Added new debug statement.\n\t(state::print): Print information about whether local has\n\tchanged.\n\t(state::merge): Don't call note_variable when merging locals.\n\t(state::set_exception): Removed old FIXME comment.\n\nFrom-SVN: r49886", "tree": {"sha": "0517ab722670c79c7b3bda32ba6a086df54ca9e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0517ab722670c79c7b3bda32ba6a086df54ca9e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4e35417f9086711be36ab2e4bcdd2a2ab8bbc60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4e35417f9086711be36ab2e4bcdd2a2ab8bbc60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4e35417f9086711be36ab2e4bcdd2a2ab8bbc60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4e35417f9086711be36ab2e4bcdd2a2ab8bbc60/comments", "author": null, "committer": null, "parents": [{"sha": "c964d90e21fb7915bad1d386393e6d90641384b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c964d90e21fb7915bad1d386393e6d90641384b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c964d90e21fb7915bad1d386393e6d90641384b8"}], "stats": {"total": 35, "additions": 23, "deletions": 12}, "files": [{"sha": "447ccfb5c31e08ee77becb2da1db0068a0d35c37", "filename": "libjava/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4e35417f9086711be36ab2e4bcdd2a2ab8bbc60/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4e35417f9086711be36ab2e4bcdd2a2ab8bbc60/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=e4e35417f9086711be36ab2e4bcdd2a2ab8bbc60", "patch": "@@ -1,3 +1,14 @@\n+2002-02-19  Tom Tromey  <tromey@redhat.com>\n+\n+\tFix for PR libgcj/5696:\n+\t* verify.cc (is_assignable_from_slow): Never call\n+\t_Jv_IsAssignableFrom.\n+\t(verify_instructions_0): Added new debug statement.\n+\t(state::print): Print information about whether local has\n+\tchanged.\n+\t(state::merge): Don't call note_variable when merging locals.\n+\t(state::set_exception): Removed old FIXME comment.\n+\n 2002-02-18  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n \n \t* java/net/natPlainDatagramSocketImpl.cc (bind): Call setsockopt to"}, {"sha": "36dbcccb8d4fb3646cf3af259d4fef82d5057db0", "filename": "libjava/verify.cc", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4e35417f9086711be36ab2e4bcdd2a2ab8bbc60/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4e35417f9086711be36ab2e4bcdd2a2ab8bbc60/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=e4e35417f9086711be36ab2e4bcdd2a2ab8bbc60", "patch": "@@ -231,21 +231,13 @@ class _Jv_BytecodeVerifier\n \tif (target->isPrimitive () || source->isPrimitive ())\n \t  return false;\n \n-\t// Check array case first because we can have an array whose\n-\t// component type is not prepared; _Jv_IsAssignableFrom\n-\t// doesn't handle this correctly.\n \tif (target->isArray ())\n \t  {\n \t    if (! source->isArray ())\n \t      return false;\n \t    target = target->getComponentType ();\n \t    source = source->getComponentType ();\n \t  }\n-\t// _Jv_IsAssignableFrom can handle a target which is an\n-\t// interface even if it hasn't been prepared.\n-\telse if ((target->state > JV_STATE_LINKED || target->isInterface ())\n-\t\t && source->state > JV_STATE_LINKED)\n-\t  return _Jv_IsAssignableFrom (target, source);\n \telse if (target->isInterface ())\n \t  {\n \t    for (int i = 0; i < source->interface_count; ++i)\n@@ -912,8 +904,6 @@ class _Jv_BytecodeVerifier\n       stack[0] = t;\n       for (int i = stacktop; i < max_stack; ++i)\n \tstack[i] = unsuitable_type;\n-\n-      // FIXME: subroutine handling?\n     }\n \n     // Modify this state to reflect entry into a subroutine.\n@@ -982,8 +972,14 @@ class _Jv_BytecodeVerifier\n \t    {\n \t      if (locals[i].merge (state_old->locals[i], true, verifier))\n \t\t{\n+\t\t  // Note that we don't call `note_variable' here.\n+\t\t  // This change doesn't represent a real change to a\n+\t\t  // local, but rather a merge artifact.  If we're in\n+\t\t  // a subroutine which is called with two\n+\t\t  // incompatible types in a slot that is unused by\n+\t\t  // the subroutine, then we don't want to mark that\n+\t\t  // variable as having been modified.\n \t\t  changed = true;\n-\t\t  note_variable (i);\n \t\t}\n \t    }\n \n@@ -1072,7 +1068,10 @@ class _Jv_BytecodeVerifier\n \tdebug_print (\".\");\n       debug_print (\"    [local] \");\n       for (i = 0; i < max_locals; ++i)\n-\tlocals[i].print ();\n+\t{\n+\t  locals[i].print ();\n+\t  debug_print (local_changed[i] ? \"+\" : \" \");\n+\t}\n       if (subroutine == 0)\n \tdebug_print (\"   | None\");\n       else\n@@ -2055,6 +2054,7 @@ class _Jv_BytecodeVerifier\n \t      verify_fail (\"can't happen: saw state::INVALID\");\n \t    if (PC == state::NO_NEXT)\n \t      break;\n+\t    debug_print (\"== State pop from pending list\\n\");\n \t    // Set up the current state.\n \t    current_state->copy (states[PC], current_method->max_stack,\n \t\t\t\t current_method->max_locals);"}]}