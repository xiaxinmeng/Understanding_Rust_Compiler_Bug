{"sha": "777f7f9a72532980c1b5cfa05a7a1f032807f10f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc3ZjdmOWE3MjUzMjk4MGMxYjVjZmEwNWE3YTFmMDMyODA3ZjEwZg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2006-04-13T23:44:25Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2006-04-13T23:44:25Z"}, "message": "re PR libgomp/26651 ([gomp] #omp for ordered leaks memory)\n\n\tPR 26651\n\t* gimple-low.c (lower_omp_directive): Remove dead code.\n\t(lower_stmt): Do nothing except for openmp, except for OMP_PARALLEL.\n\t* gimplify.c (gimplify_expr): Update for OMP_RETURN, OMP_CONTINUE.\n\t* omp-low.c (struct omp_region): Move to tree-flow.h.\n\t(root_omp_region): Export.\n\t(omp_regions, lookup_omp_region): Remove.\n\t(determine_parallel_type): Update for struct omp_region changes.\n\t(dump_omp_region): Dump regions with block numbers.\n\t(new_omp_region): Take type and block instead of stmt; malloc\n\tinstead of ggc.\n\t(free_omp_region_1, free_omp_regions): New.\n\t(expand_parallel_call): Take entry_stmt as argument; update for\n\tchanges to omp_region.\n\t(remove_exit_barrier): Rewrite to update OMP_RETURN_NOWAIT.\n\t(remove_exit_barriers): New.\n\t(expand_omp_parallel): Update for struct omp_region changes.\n\t(expand_omp_synch): Likewise.\n\t(expand_omp): Likewise.\n\t(expand_omp_for_static_nochunk): Likewise; update for OMP_CONTINUE.\n\t(expand_omp_for_static_chunk): Likewise.\n\t(expand_omp_for): Likewise.\n\t(expand_omp_for_generic): Likewise; emit the proper GOMP_loop_end call.\n\t(expand_omp_sections): Similarly, with GOMP_sections_end.\n\t(expand_omp_single): New.\n\t(build_omp_regions_1): Update for OMP_CONTINUE.\n\t(execute_expand_omp): Call remove_exit_barriers, free_omp_regions.\n\t(lower_omp_sections): Expand with OMP_CONTINUE, do not collect\n\tOMP_SECTIONS_SECTIONS.\n\t(lower_omp_single_simple): Don't emit barrier here.\n\t(lower_omp_single_copy): Likewise.\n\t(lower_omp_single): Fix bindings, and lower to straightline now.\n\t(lower_omp_master, lower_omp_ordered): Likewise.\n\t(lower_omp_critical): Likewise.\n\t(lower_omp_for): Likewise.  Emit OMP_CONTINUE.\n\t* tree-cfg.c (make_edges): Collect an omp_region tree, use it for\n\tomp edges, free it afterward.\n\t(make_omp_sections_edges): Remove.\n\t(is_ctrl_altering_stmt): Don't bother checking flag_openmp.\n\t(move_stmt_r): Handle OMP_CONTINUE.\n\t* tree-flow.h (struct omp_region): Move from omp-low.c.  Switch \n\tstatement pointers to basic blocks.  Add type member.\n\t(root_omp_region, new_omp_region, free_omp_regions): Declare.\n\t* tree-gimple.c (is_gimple_stmt): Handle OMP_RETURN, OMP_CONTINUE.\n\t* tree-inline.c (estimate_num_insns_1): Likewise.\n\t* tree-pretty-print.c (dump_generic_node): Likewise.\n\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n\t* tree.def (OMP_SECTIONS): Remove OMP_SECTIONS_SECTIONS operand.\n\t(OMP_RETURN): Rename from OMP_RETURN_EXPR.\n\t(OMP_CONTINUE): New.\n\t* tree.h (OMP_DIRECTIVE_P): Add OMP_CONTINUE.\n\t(OMP_SECTIONS_SECTIONS): Remove.\n\t(OMP_SECTION_LAST): New.\n\t(OMP_RETURN_NOWAIT): New.\nfortran/\n        * trans-openmp.c (gfc_trans_omp_sections): Adjust for changed\n        number of operands to OMP_SECTIONS.\ntestsuite/\n        * g++.dg/gomp/block-0.C: Update expected matches.\n\nFrom-SVN: r112935", "tree": {"sha": "bb861aba6cb32495b9e9f3ecc9c7b1dab32bf035", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb861aba6cb32495b9e9f3ecc9c7b1dab32bf035"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/777f7f9a72532980c1b5cfa05a7a1f032807f10f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777f7f9a72532980c1b5cfa05a7a1f032807f10f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/777f7f9a72532980c1b5cfa05a7a1f032807f10f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777f7f9a72532980c1b5cfa05a7a1f032807f10f/comments", "author": null, "committer": null, "parents": [{"sha": "a239aa95dc5271ebabed7a98e026b69bc16d9b85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a239aa95dc5271ebabed7a98e026b69bc16d9b85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a239aa95dc5271ebabed7a98e026b69bc16d9b85"}], "stats": {"total": 1237, "additions": 683, "deletions": 554}, "files": [{"sha": "570342cc02b6ca48d662452128d5771b7c6da667", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=777f7f9a72532980c1b5cfa05a7a1f032807f10f", "patch": "@@ -1,3 +1,60 @@\n+2006-04-13  Richard Henderson  <rth@redhat.com>\n+\n+\tPR 26651\n+\t* gimple-low.c (lower_omp_directive): Remove dead code.\n+\t(lower_stmt): Do nothing except for openmp, except for OMP_PARALLEL.\n+\t* gimplify.c (gimplify_expr): Update for OMP_RETURN, OMP_CONTINUE.\n+\t* omp-low.c (struct omp_region): Move to tree-flow.h.\n+\t(root_omp_region): Export.\n+\t(omp_regions, lookup_omp_region): Remove.\n+\t(determine_parallel_type): Update for struct omp_region changes.\n+\t(dump_omp_region): Dump regions with block numbers.\n+\t(new_omp_region): Take type and block instead of stmt; malloc\n+\tinstead of ggc.\n+\t(free_omp_region_1, free_omp_regions): New.\n+\t(expand_parallel_call): Take entry_stmt as argument; update for\n+\tchanges to omp_region.\n+\t(remove_exit_barrier): Rewrite to update OMP_RETURN_NOWAIT.\n+\t(remove_exit_barriers): New.\n+\t(expand_omp_parallel): Update for struct omp_region changes.\n+\t(expand_omp_synch): Likewise.\n+\t(expand_omp): Likewise.\n+\t(expand_omp_for_static_nochunk): Likewise; update for OMP_CONTINUE.\n+\t(expand_omp_for_static_chunk): Likewise.\n+\t(expand_omp_for): Likewise.\n+\t(expand_omp_for_generic): Likewise; emit the proper GOMP_loop_end call.\n+\t(expand_omp_sections): Similarly, with GOMP_sections_end.\n+\t(expand_omp_single): New.\n+\t(build_omp_regions_1): Update for OMP_CONTINUE.\n+\t(execute_expand_omp): Call remove_exit_barriers, free_omp_regions.\n+\t(lower_omp_sections): Expand with OMP_CONTINUE, do not collect\n+\tOMP_SECTIONS_SECTIONS.\n+\t(lower_omp_single_simple): Don't emit barrier here.\n+\t(lower_omp_single_copy): Likewise.\n+\t(lower_omp_single): Fix bindings, and lower to straightline now.\n+\t(lower_omp_master, lower_omp_ordered): Likewise.\n+\t(lower_omp_critical): Likewise.\n+\t(lower_omp_for): Likewise.  Emit OMP_CONTINUE.\n+\t* tree-cfg.c (make_edges): Collect an omp_region tree, use it for\n+\tomp edges, free it afterward.\n+\t(make_omp_sections_edges): Remove.\n+\t(is_ctrl_altering_stmt): Don't bother checking flag_openmp.\n+\t(move_stmt_r): Handle OMP_CONTINUE.\n+\t* tree-flow.h (struct omp_region): Move from omp-low.c.  Switch \n+\tstatement pointers to basic blocks.  Add type member.\n+\t(root_omp_region, new_omp_region, free_omp_regions): Declare.\n+\t* tree-gimple.c (is_gimple_stmt): Handle OMP_RETURN, OMP_CONTINUE.\n+\t* tree-inline.c (estimate_num_insns_1): Likewise.\n+\t* tree-pretty-print.c (dump_generic_node): Likewise.\n+\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n+\t* tree.def (OMP_SECTIONS): Remove OMP_SECTIONS_SECTIONS operand.\n+\t(OMP_RETURN): Rename from OMP_RETURN_EXPR.\n+\t(OMP_CONTINUE): New.\n+\t* tree.h (OMP_DIRECTIVE_P): Add OMP_CONTINUE.\n+\t(OMP_SECTIONS_SECTIONS): Remove.\n+\t(OMP_SECTION_LAST): New.\n+\t(OMP_RETURN_NOWAIT): New.\n+\n 2006-04-13  Roger Sayle  <roger@eyesopen.com>\n \n \t* fold-const.c (native_encode_vector, native_interpret_real):"}, {"sha": "8523b9af6f21ddca80909287725e275afcc73987", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=777f7f9a72532980c1b5cfa05a7a1f032807f10f", "patch": "@@ -1,3 +1,8 @@\n+2006-04-13  Richard Henderson  <rth@redhat.com>\n+\n+\t* trans-openmp.c (gfc_trans_omp_sections): Adjust for changed\n+\tnumber of operands to OMP_SECTIONS.\n+\n 2006-04-08  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* gfortran.texi: Fix typos.  Follow spelling conventions."}, {"sha": "bd57836713a88b041c53b821c036d8c3b2e384a6", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=777f7f9a72532980c1b5cfa05a7a1f032807f10f", "patch": "@@ -1161,7 +1161,7 @@ gfc_trans_omp_sections (gfc_code *code, gfc_omp_clauses *clauses)\n     }\n   stmt = gfc_finish_block (&body);\n \n-  stmt = build3_v (OMP_SECTIONS, stmt, omp_clauses, NULL);\n+  stmt = build2_v (OMP_SECTIONS, stmt, omp_clauses);\n   gfc_add_expr_to_block (&block, stmt);\n \n   return gfc_finish_block (&block);"}, {"sha": "ff6b8b27f30cf79d94ccc57266fd05e198eb077f", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=777f7f9a72532980c1b5cfa05a7a1f032807f10f", "patch": "@@ -159,14 +159,10 @@ lower_stmt_body (tree expr, struct lower_data *data)\n static void\n lower_omp_directive (tree_stmt_iterator *tsi, struct lower_data *data)\n {\n-  tree clause, stmt;\n+  tree stmt;\n   \n   stmt = tsi_stmt (*tsi);\n \n-  clause = (TREE_CODE (stmt) >= OMP_PARALLEL && TREE_CODE (stmt) <= OMP_SINGLE)\n-\t   ? OMP_CLAUSES (stmt)\n-\t   : NULL_TREE;\n-\n   lower_stmt_body (OMP_BODY (stmt), data);\n   tsi_link_before (tsi, stmt, TSI_SAME_STMT);\n   tsi_link_before (tsi, OMP_BODY (stmt), TSI_SAME_STMT);\n@@ -216,17 +212,18 @@ lower_stmt (tree_stmt_iterator *tsi, struct lower_data *data)\n     case GOTO_EXPR:\n     case LABEL_EXPR:\n     case SWITCH_EXPR:\n-    case OMP_RETURN_EXPR:\n-      break;\n-\n-    case OMP_PARALLEL:\n     case OMP_FOR:\n     case OMP_SECTIONS:\n     case OMP_SECTION:\n     case OMP_SINGLE:\n     case OMP_MASTER:\n     case OMP_ORDERED:\n     case OMP_CRITICAL:\n+    case OMP_RETURN:\n+    case OMP_CONTINUE:\n+      break;\n+\n+    case OMP_PARALLEL:\n       lower_omp_directive (tsi, data);\n       return;\n "}, {"sha": "3ee21d865afd90bcca3bae35eee04d5f6f986b7d", "filename": "gcc/gimplify.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=777f7f9a72532980c1b5cfa05a7a1f032807f10f", "patch": "@@ -5587,7 +5587,8 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  ret = gimplify_omp_atomic (expr_p, pre_p);\n \t  break;\n \n-\tcase OMP_RETURN_EXPR:\n+\tcase OMP_RETURN:\n+\tcase OMP_CONTINUE:\n \t  ret = GS_ALL_DONE;\n \t  break;\n "}, {"sha": "5578e474a176ebbb8c15398b08537901c1d3bbfc", "filename": "gcc/omp-low.c", "status": "modified", "additions": 466, "deletions": 485, "changes": 951, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=777f7f9a72532980c1b5cfa05a7a1f032807f10f", "patch": "@@ -54,40 +54,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    scanned for parallel regions which are then moved to a new\n    function, to be invoked by the thread library.  */\n \n-/* Parallel region information.  Every parallel and workshare\n-   directive is enclosed between two markers, the OMP_* directive\n-   and a corresponding OMP_RETURN_EXPR statement.  */\n-\n-struct omp_region GTY(())\n-{\n-  /* The enclosing region.  */\n-  struct omp_region *outer;\n-\n-  /* First child region.  */\n-  struct omp_region *inner;\n-\n-  /* Next peer region.  */\n-  struct omp_region *next;\n-\n-  /* Entry point to this region.  */\n-  tree entry;\n-\n-  /* Exit label from this region.  */\n-  tree exit;\n-\n-  /* Region number.  */\n-  int num;\n-\n-  /* True if this is a combined parallel+workshare region.  */\n-  bool is_combined_parallel;\n-\n-  /* If this is a combined parallel+workshare region, this is a list\n-     of additional arguments needed by the combined parallel+workshare\n-     library call.  */\n-  tree ws_args;\n-};\n-\n-\n /* Context structure.  Used to store information about each parallel\n    directive in the code.  */\n \n@@ -142,8 +108,7 @@ struct omp_for_data\n \n static splay_tree all_contexts;\n static int parallel_nesting_level;\n-static splay_tree omp_regions;\n-static struct omp_region *root_omp_region;\n+struct omp_region *root_omp_region;\n \n static void scan_omp (tree *, omp_context *);\n static void lower_omp (tree *, omp_context *);\n@@ -402,24 +367,25 @@ determine_parallel_type (struct omp_region *region)\n     return;\n \n   /* We only support parallel+for and parallel+sections.  */\n-  if (TREE_CODE (region->entry) != OMP_PARALLEL\n-      || (TREE_CODE (region->inner->entry) != OMP_FOR\n-\t  && TREE_CODE (region->inner->entry) != OMP_SECTIONS))\n+  if (region->type != OMP_PARALLEL\n+      || (region->inner->type != OMP_FOR\n+\t  && region->inner->type != OMP_SECTIONS))\n     return;\n \n   /* Check for perfect nesting PAR_ENTRY_BB -> WS_ENTRY_BB and\n      WS_EXIT_BB -> PAR_EXIT_BB.  */\n-  par_entry_bb = bb_for_stmt (region->entry);\n-  par_exit_bb = bb_for_stmt (region->exit);\n-\n-  ws_entry_bb = bb_for_stmt (region->inner->entry);\n-  ws_exit_bb = bb_for_stmt (region->inner->exit);\n+  par_entry_bb = region->entry;\n+  par_exit_bb = region->exit;\n+  ws_entry_bb = region->inner->entry;\n+  ws_exit_bb = region->inner->exit;\n \n   if (single_succ (par_entry_bb) == ws_entry_bb\n       && single_succ (ws_exit_bb) == par_exit_bb\n       && workshare_safe_to_combine_p (par_entry_bb, ws_entry_bb))\n     {\n-      if (TREE_CODE (region->inner->entry) == OMP_FOR)\n+      tree ws_stmt = last_stmt (region->inner->entry);\n+\n+      if (region->inner->type == OMP_FOR)\n \t{\n \t  /* If this is a combined parallel loop, we need to determine\n \t     whether or not to use the combined library calls.  There\n@@ -430,7 +396,7 @@ determine_parallel_type (struct omp_region *region)\n \t     parallel loop call would still need extra synchronization\n \t     to implement ordered semantics, so there would not be any\n \t     gain in using the combined call.  */\n-\t  tree clauses = OMP_FOR_CLAUSES (region->inner->entry);\n+\t  tree clauses = OMP_FOR_CLAUSES (ws_stmt);\n \t  tree c = find_omp_clause (clauses, OMP_CLAUSE_SCHEDULE);\n \t  if (c == NULL\n \t      || OMP_CLAUSE_SCHEDULE_KIND (c) == OMP_CLAUSE_SCHEDULE_STATIC\n@@ -444,7 +410,7 @@ determine_parallel_type (struct omp_region *region)\n \n       region->is_combined_parallel = true;\n       region->inner->is_combined_parallel = true;\n-      region->ws_args = get_ws_args_for (region->inner->entry);\n+      region->ws_args = get_ws_args_for (ws_stmt);\n     }\n }\n \n@@ -735,14 +701,6 @@ omp_copy_decl (tree var, copy_body_data *cb)\n \n /* Return the parallel region associated with STMT.  */\n \n-static inline struct omp_region *\n-lookup_omp_region (tree stmt)\n-{\n-  splay_tree_node n = splay_tree_lookup (omp_regions, (splay_tree_key) stmt);\n-  return n ? (struct omp_region *) n->value : NULL;\n-}\n-\n-\n /* Debugging dumps for parallel regions.  */\n void dump_omp_region (FILE *, struct omp_region *, int);\n void debug_omp_region (struct omp_region *);\n@@ -753,23 +711,26 @@ void debug_all_omp_regions (void);\n void\n dump_omp_region (FILE *file, struct omp_region *region, int indent)\n {\n-  fprintf (file, \"%*s\", indent, \"\");\n-  print_generic_stmt (file, region->entry, TDF_SLIM);\n+  fprintf (file, \"%*sbb %d: %s\\n\", indent, \"\", region->entry->index,\n+\t   tree_code_name[region->type]);\n \n   if (region->inner)\n     dump_omp_region (file, region->inner, indent + 4);\n \n-  fprintf (file, \"%*s\", indent, \"\");\n+  if (region->cont)\n+    {\n+      fprintf (file, \"%*sbb %d: OMP_CONTINUE\", indent, \"\",\n+\t       region->cont->index);\n+    }\n+    \n   if (region->exit)\n-    print_generic_stmt (file, region->exit, 0);\n+    fprintf (file, \"%*sbb: %d: OMP_RETURN\", indent, \"\",\n+\t     region->exit->index);\n   else\n-    fprintf (file, \"[no exit marker]\\n\");\n+    fprintf (file, \"%*s[no exit marker]\\n\", indent, \"\");\n \n   if (region->next)\n-    {\n-      fprintf (file, \"\\n\");\n-      dump_omp_region (file, region->next, indent);\n-    }\n+    dump_omp_region (file, region->next, indent);\n }\n \n void\n@@ -787,15 +748,14 @@ debug_all_omp_regions (void)\n \n /* Create a new parallel region starting at STMT inside region PARENT.  */\n \n-static struct omp_region *\n-new_omp_region (tree stmt, struct omp_region *parent)\n+struct omp_region *\n+new_omp_region (basic_block bb, enum tree_code type, struct omp_region *parent)\n {\n-  struct omp_region *region = ggc_alloc_cleared (sizeof (*region));\n-  static int num = 0;\n+  struct omp_region *region = xcalloc (1, sizeof (*region));\n \n   region->outer = parent;\n-  region->entry = stmt;\n-  region->num = num++;\n+  region->entry = bb;\n+  region->type = type;\n \n   if (parent)\n     {\n@@ -804,24 +764,45 @@ new_omp_region (tree stmt, struct omp_region *parent)\n       region->next = parent->inner;\n       parent->inner = region;\n     }\n-  else if (omp_regions)\n+  else\n     {\n       /* This is a toplevel region.  Add it to the list of toplevel\n \t regions in ROOT_OMP_REGION.  */\n       region->next = root_omp_region;\n       root_omp_region = region;\n     }\n-  else\n+\n+  return region;\n+}\n+\n+/* Release the memory associated with the region tree rooted at REGION.  */\n+\n+static void\n+free_omp_region_1 (struct omp_region *region)\n+{\n+  struct omp_region *i, *n;\n+\n+  for (i = region->inner; i ; i = n)\n     {\n-      /* Create a new root region with the first region we find.  */\n-      root_omp_region = region;\n-      omp_regions = splay_tree_new (splay_tree_compare_pointers, 0, 0);\n+      n = i->next;\n+      free_omp_region_1 (i);\n     }\n \n-  splay_tree_insert (omp_regions, (splay_tree_key) stmt,\n-\t\t     (splay_tree_value) region);\n+  free (region);\n+}\n \n-  return region;\n+/* Release the memory for the entire omp region tree.  */\n+\n+void\n+free_omp_regions (void)\n+{\n+  struct omp_region *r, *n;\n+  for (r = root_omp_region; r ; r = n)\n+    {\n+      n = r->next;\n+      free_omp_region_1 (r);\n+    }\n+  root_omp_region = NULL;\n }\n \n \n@@ -2033,32 +2014,38 @@ lower_send_shared_vars (tree *ilist, tree *olist, omp_context *ctx)\n    the workshare construct.  */\n \n static void\n-expand_parallel_call (struct omp_region *region, basic_block bb, tree ws_args)\n+expand_parallel_call (struct omp_region *region, basic_block bb,\n+\t\t      tree entry_stmt, tree ws_args)\n {\n   tree t, args, val, cond, c, list, clauses;\n   block_stmt_iterator si;\n   int start_ix;\n \n-  clauses = OMP_PARALLEL_CLAUSES (region->entry);\n+  clauses = OMP_PARALLEL_CLAUSES (entry_stmt);\n   push_gimplify_context ();\n \n   /* Determine what flavor of GOMP_parallel_start we will be\n      emitting.  */\n   start_ix = BUILT_IN_GOMP_PARALLEL_START;\n   if (is_combined_parallel (region))\n     {\n-      tree stmt = region->inner->entry;\n-\n-      if (TREE_CODE (stmt) == OMP_FOR)\n+      switch (region->inner->type)\n \t{\n-\t  struct omp_for_data fd;\n-\t  extract_omp_for_data (stmt, &fd);\n-\t  start_ix = BUILT_IN_GOMP_PARALLEL_LOOP_STATIC_START + fd.sched_kind;\n+\tcase OMP_FOR:\n+\t  {\n+\t    tree stmt = last_stmt (region->inner->entry);\n+\t    struct omp_for_data fd;\n+\t    extract_omp_for_data (stmt, &fd);\n+\t    start_ix = BUILT_IN_GOMP_PARALLEL_LOOP_STATIC_START\n+\t      + fd.sched_kind;\n+\t  }\n+\t  break;\n+\tcase OMP_SECTIONS:\n+\t  start_ix = BUILT_IN_GOMP_PARALLEL_SECTIONS_START;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      else if (TREE_CODE (stmt) == OMP_SECTIONS)\n-\tstart_ix = BUILT_IN_GOMP_PARALLEL_SECTIONS_START;\n-      else\n-\tgcc_unreachable ();\n     }\n \n   /* By default, the value of NUM_THREADS is zero (selected at run time)\n@@ -2142,13 +2129,13 @@ expand_parallel_call (struct omp_region *region, basic_block bb, tree ws_args)\n \n   list = NULL_TREE;\n   args = tree_cons (NULL, val, NULL);\n-  t = OMP_PARALLEL_DATA_ARG (region->entry);\n+  t = OMP_PARALLEL_DATA_ARG (entry_stmt);\n   if (t == NULL)\n     t = null_pointer_node;\n   else\n     t = build_fold_addr_expr (t);\n   args = tree_cons (NULL, t, args);\n-  t = build_fold_addr_expr (OMP_PARALLEL_FN (region->entry));\n+  t = build_fold_addr_expr (OMP_PARALLEL_FN (entry_stmt));\n   args = tree_cons (NULL, t, args);\n \n   if (ws_args)\n@@ -2158,13 +2145,13 @@ expand_parallel_call (struct omp_region *region, basic_block bb, tree ws_args)\n   t = build_function_call_expr (t, args);\n   gimplify_and_add (t, &list);\n \n-  t = OMP_PARALLEL_DATA_ARG (region->entry);\n+  t = OMP_PARALLEL_DATA_ARG (entry_stmt);\n   if (t == NULL)\n     t = null_pointer_node;\n   else\n     t = build_fold_addr_expr (t);\n   args = tree_cons (NULL, t, NULL);\n-  t = build_function_call_expr (OMP_PARALLEL_FN (region->entry), args);\n+  t = build_function_call_expr (OMP_PARALLEL_FN (entry_stmt), args);\n   gimplify_and_add (t, &list);\n \n   t = built_in_decls[BUILT_IN_GOMP_PARALLEL_END];\n@@ -2239,27 +2226,51 @@ remove_exit_barrier (struct omp_region *region)\n {\n   block_stmt_iterator si;\n   basic_block exit_bb;\n+  edge_iterator ei;\n+  edge e;\n   tree t;\n \n-  gcc_assert (TREE_CODE (region->entry) == OMP_PARALLEL);\n-\n-  exit_bb = bb_for_stmt (region->exit);\n+  exit_bb = region->exit;\n \n-  /* The barrier should be immediately before OMP_RETURN_EXPR.\n-     Otherwise, we cannot remove it.  */\n+  /* The last insn in the block will be the parallel's OMP_RETURN.  The\n+     workshare's OMP_RETURN will be in a preceeding block.  The kinds of\n+     statements that can appear in between are extremely limited -- no\n+     memory operations at all.  Here, we allow nothing at all, so the\n+     only thing we allow to preceed this OMP_RETURN is a label.  */\n   si = bsi_last (exit_bb);\n-  t = bsi_stmt (si);\n-  gcc_assert (TREE_CODE (t) == OMP_RETURN_EXPR);\n+  gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_RETURN);\n   bsi_prev (&si);\n-  if (bsi_end_p (si))\n+  if (!bsi_end_p (si) && TREE_CODE (bsi_stmt (si)) != LABEL_EXPR)\n     return;\n \n-  t = bsi_stmt (si);\n-  if (TREE_CODE (t) == CALL_EXPR\n-      && get_callee_fndecl (t) == built_in_decls[BUILT_IN_GOMP_BARRIER])\n-    bsi_remove (&si, true);\n+  FOR_EACH_EDGE (e, ei, exit_bb->preds)\n+    {\n+      si = bsi_last (e->src);\n+      if (bsi_end_p (si))\n+\tcontinue;\n+      t = bsi_stmt (si);\n+      if (TREE_CODE (t) == OMP_RETURN)\n+\tOMP_RETURN_NOWAIT (t) = 1;\n+    }\n }\n \n+static void\n+remove_exit_barriers (struct omp_region *region)\n+{\n+  if (region->type == OMP_PARALLEL)\n+    remove_exit_barrier (region);\n+\n+  if (region->inner)\n+    {\n+      region = region->inner;\n+      remove_exit_barriers (region);\n+      while (region->next)\n+\t{\n+\t  region = region->next;\n+\t  remove_exit_barriers (region);\n+\t}\n+    }\n+}\n \n /* Expand the OpenMP parallel directive starting at REGION.  */\n \n@@ -2270,29 +2281,23 @@ expand_omp_parallel (struct omp_region *region)\n   struct function *child_cfun, *saved_cfun;\n   tree child_fn, block, t, ws_args;\n   block_stmt_iterator si;\n+  tree entry_stmt;\n   edge e;\n \n-  child_fn = OMP_PARALLEL_FN (region->entry);\n+  entry_stmt = last_stmt (region->entry);\n+  child_fn = OMP_PARALLEL_FN (entry_stmt);\n   child_cfun = DECL_STRUCT_FUNCTION (child_fn);\n   saved_cfun = cfun;\n \n-  entry_bb = bb_for_stmt (region->entry);\n-  exit_bb = bb_for_stmt (region->exit);\n+  entry_bb = region->entry;\n+  exit_bb = region->exit;\n \n   if (is_combined_parallel (region))\n-    {\n-      ws_args = region->ws_args;\n-\n-      /* For combined parallel+workshare calls, barriers at the end of\n-\t the function are not necessary and can be removed.  Since the\n-\t caller will have a barrier of its own, the workshare barrier is\n-\t superfluous.  */\n-      remove_exit_barrier (region);\n-    }\n+    ws_args = region->ws_args;\n   else\n     ws_args = NULL_TREE;\n \n-  if (DECL_STRUCT_FUNCTION (OMP_PARALLEL_FN (region->entry))->cfg)\n+  if (child_cfun->cfg)\n     {\n       /* Due to inlining, it may happen that we have already outlined\n \t the region, in which case all we need to do is make the\n@@ -2304,7 +2309,7 @@ expand_omp_parallel (struct omp_region *region)\n       exit_succ_e = single_succ_edge (exit_bb);\n \n       si = bsi_last (entry_bb);\n-      gcc_assert (!bsi_end_p (si) && TREE_CODE (bsi_stmt (si)) == OMP_PARALLEL);\n+      gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_PARALLEL);\n       bsi_remove (&si, true);\n \n       new_bb = entry_bb;\n@@ -2325,7 +2330,7 @@ expand_omp_parallel (struct omp_region *region)\n \t a function call that has been inlined, the original PARM_DECL\n \t .OMP_DATA_I may have been converted into a different local\n \t variable.  In which case, we need to keep the assignment.  */\n-      if (OMP_PARALLEL_DATA_ARG (region->entry))\n+      if (OMP_PARALLEL_DATA_ARG (entry_stmt))\n \t{\n \t  basic_block entry_succ_bb = single_succ (entry_bb);\n \t  block_stmt_iterator si = bsi_start (entry_succ_bb);\n@@ -2337,7 +2342,7 @@ expand_omp_parallel (struct omp_region *region)\n \t  gcc_assert (TREE_CODE (stmt) == MODIFY_EXPR\n \t\t      && TREE_CODE (TREE_OPERAND (stmt, 1)) == ADDR_EXPR\n \t\t      && TREE_OPERAND (TREE_OPERAND (stmt, 1), 0)\n-\t\t\t == OMP_PARALLEL_DATA_ARG (region->entry));\n+\t\t\t == OMP_PARALLEL_DATA_ARG (entry_stmt));\n \n \t  if (TREE_OPERAND (stmt, 0) == DECL_ARGUMENTS (child_fn))\n \t    bsi_remove (&si, true);\n@@ -2377,15 +2382,14 @@ expand_omp_parallel (struct omp_region *region)\n \n       /* Convert OMP_RETURN into a RETURN_EXPR.  */\n       si = bsi_last (exit_bb);\n-      gcc_assert (!bsi_end_p (si)\n-\t          && TREE_CODE (bsi_stmt (si)) == OMP_RETURN_EXPR);\n+      gcc_assert (!bsi_end_p (si) && TREE_CODE (bsi_stmt (si)) == OMP_RETURN);\n       t = build1 (RETURN_EXPR, void_type_node, NULL);\n       bsi_insert_after (&si, t, TSI_SAME_STMT);\n       bsi_remove (&si, true);\n     }\n \n   /* Emit a library call to launch the children threads.  */\n-  expand_parallel_call (region, new_bb, ws_args);\n+  expand_parallel_call (region, new_bb, entry_stmt, ws_args);\n }\n \n \n@@ -2412,7 +2416,7 @@ expand_omp_parallel (struct omp_region *region)\n     If this is a combined omp parallel loop, instead of the call to\n     GOMP_loop_foo_start, we emit 'goto L3'.  */\n \n-static basic_block\n+static void\n expand_omp_for_generic (struct omp_region *region,\n \t\t\tstruct omp_for_data *fd,\n \t\t\tenum built_in_function start_fn,\n@@ -2421,37 +2425,38 @@ expand_omp_for_generic (struct omp_region *region,\n   tree l0, l1, l2, l3;\n   tree type, istart0, iend0, iend;\n   tree t, args, list;\n-  basic_block entry_bb, exit_bb, l0_bb, l1_bb, l2_bb;\n-  edge exit_edge;\n+  basic_block entry_bb, cont_bb, exit_bb, l0_bb, l1_bb, l2_bb, l3_bb;\n   block_stmt_iterator si;\n   bool in_combined_parallel = is_combined_parallel (region);\n \n   type = TREE_TYPE (fd->v);\n \n   istart0 = create_tmp_var (long_integer_type_node, \".istart0\");\n   iend0 = create_tmp_var (long_integer_type_node, \".iend0\");\n+  iend = create_tmp_var (type, NULL);\n   TREE_ADDRESSABLE (istart0) = 1;\n   TREE_ADDRESSABLE (iend0) = 1;\n \n-  l0 = create_artificial_label ();\n-  l1 = create_artificial_label ();\n-  l2 = create_artificial_label ();\n-  l3 = create_artificial_label ();\n-  iend = create_tmp_var (type, NULL);\n-\n-  entry_bb = bb_for_stmt (region->entry);\n+  entry_bb = region->entry;\n+  l0_bb = create_empty_bb (entry_bb);\n   l1_bb = single_succ (entry_bb);\n-  exit_bb = bb_for_stmt (region->exit);\n+  cont_bb = region->cont;\n+  l2_bb = create_empty_bb (cont_bb);\n+  l3_bb = single_succ (cont_bb);\n+  exit_bb = region->exit;\n \n-  si = bsi_last (entry_bb);\n-  gcc_assert (bsi_stmt (si) && TREE_CODE (bsi_stmt (si)) == OMP_FOR);\n-  bsi_remove (&si, true);\n-  list = alloc_stmt_list ();\n+  l0 = tree_block_label (l0_bb);\n+  l1 = tree_block_label (l1_bb);\n+  l2 = tree_block_label (l2_bb);\n+  l3 = tree_block_label (l3_bb);\n \n+  si = bsi_last (entry_bb);\n+  gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_FOR);\n   if (!in_combined_parallel)\n     {\n       /* If this is not a combined parallel loop, emit a call to\n \t GOMP_loop_foo_start in ENTRY_BB.  */\n+      list = alloc_stmt_list ();\n       t = build_fold_addr_expr (iend0);\n       args = tree_cons (NULL, t, NULL);\n       t = build_fold_addr_expr (istart0);\n@@ -2472,15 +2477,12 @@ expand_omp_for_generic (struct omp_region *region,\n       t = build3 (COND_EXPR, void_type_node, t, build_and_jump (&l0),\n \t\t  build_and_jump (&l3));\n       append_to_statement_list (t, &list);\n-      si = bsi_last (entry_bb);\n-      bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n+      bsi_insert_after (&si, list, BSI_SAME_STMT);\n     }\n+  bsi_remove (&si, true);\n \n   /* Iteration setup for sequential loop goes in L0_BB.  */\n   list = alloc_stmt_list ();\n-  t = build1 (LABEL_EXPR, void_type_node, l0);\n-  gimplify_and_add (t, &list);\n-\n   t = fold_convert (type, istart0);\n   t = build2 (MODIFY_EXPR, void_type_node, fd->v, t);\n   gimplify_and_add (t, &list);\n@@ -2489,16 +2491,9 @@ expand_omp_for_generic (struct omp_region *region,\n   t = build2 (MODIFY_EXPR, void_type_node, iend, t);\n   gimplify_and_add (t, &list);\n \n-  l0_bb = create_empty_bb (entry_bb);\n   si = bsi_start (l0_bb);\n   bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n \n-  /* Loop body goes in L1_BB.  */\n-  list = alloc_stmt_list ();\n-  si = bsi_start (l1_bb);\n-  bsi_insert_before (&si, build1 (LABEL_EXPR, void_type_node, l1),\n-\t\t     BSI_CONTINUE_LINKING);\n-\n   /* Code to control the increment and predicate for the sequential\n      loop goes in the first half of EXIT_BB (we split EXIT_BB so\n      that we can inherit all the edges going out of the loop\n@@ -2515,20 +2510,13 @@ expand_omp_for_generic (struct omp_region *region,\n \t      build_and_jump (&l2));\n   append_to_statement_list (t, &list);\n \n-  si = bsi_last (exit_bb);\n-  t = bsi_stmt (si);\n-  gcc_assert (t && TREE_CODE (t) == OMP_RETURN_EXPR);\n+  si = bsi_last (cont_bb);\n+  bsi_insert_after (&si, list, BSI_SAME_STMT);\n+  gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_CONTINUE);\n   bsi_remove (&si, true);\n-  exit_edge = split_block (exit_bb, t);\n-  exit_edge->flags = EDGE_FALSE_VALUE;\n-\n-  si = bsi_last (exit_bb);\n-  bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n \n   /* Emit code to get the next parallel iteration in L2_BB.  */\n   list = alloc_stmt_list ();\n-  t = build1 (LABEL_EXPR, void_type_node, l2);\n-  gimplify_and_add (t, &list);\n \n   t = build_fold_addr_expr (iend0);\n   args = tree_cons (NULL, t, NULL);\n@@ -2540,15 +2528,18 @@ expand_omp_for_generic (struct omp_region *region,\n \t      build_and_jump (&l3));\n   append_to_statement_list (t, &list);\n   \n-  l2_bb = exit_edge->dest;\n   si = bsi_start (l2_bb);\n   bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n \n-  /* Insert exit label on EXIT_EDGE.  */\n-  exit_edge = single_succ_edge (l2_bb);\n-  t = build1 (LABEL_EXPR, void_type_node, l3);\n-  bsi_insert_on_edge_immediate (exit_edge, t);\n-  exit_edge->flags = EDGE_FALSE_VALUE;\n+  /* Add the loop cleanup function.  */\n+  si = bsi_last (exit_bb);\n+  if (OMP_RETURN_NOWAIT (bsi_stmt (si)))\n+    t = built_in_decls[BUILT_IN_GOMP_LOOP_END_NOWAIT];\n+  else\n+    t = built_in_decls[BUILT_IN_GOMP_LOOP_END];\n+  t = build_function_call_expr (t, NULL);\n+  bsi_insert_after (&si, t, BSI_SAME_STMT);\n+  bsi_remove (&si, true);\n \n   /* Connect the new blocks.  */\n   remove_edge (single_succ_edge (entry_bb));\n@@ -2557,14 +2548,17 @@ expand_omp_for_generic (struct omp_region *region,\n   else\n     {\n       make_edge (entry_bb, l0_bb, EDGE_TRUE_VALUE);\n-      make_edge (entry_bb, exit_edge->dest, EDGE_FALSE_VALUE);\n+      make_edge (entry_bb, l3_bb, EDGE_FALSE_VALUE);\n     }\n \n   make_edge (l0_bb, l1_bb, EDGE_FALLTHRU);\n-  make_edge (exit_bb, l1_bb, EDGE_TRUE_VALUE);\n-  make_edge (l2_bb, l0_bb, EDGE_TRUE_VALUE);\n \n-  return exit_edge->dest;\n+  remove_edge (single_succ_edge (cont_bb));\n+  make_edge (cont_bb, l1_bb, EDGE_TRUE_VALUE);\n+  make_edge (cont_bb, l2_bb, EDGE_FALSE_VALUE);\n+\n+  make_edge (l2_bb, l0_bb, EDGE_TRUE_VALUE);\n+  make_edge (l2_bb, l3_bb, EDGE_FALSE_VALUE);\n }\n \n \n@@ -2596,29 +2590,33 @@ expand_omp_for_generic (struct omp_region *region,\n     L2:\n */\n \n-static basic_block\n+static void\n expand_omp_for_static_nochunk (struct omp_region *region,\n \t\t\t       struct omp_for_data *fd)\n {\n   tree l0, l1, l2, n, q, s0, e0, e, t, nthreads, threadid;\n   tree type, utype, list;\n-  basic_block entry_bb, exit_bb, seq_start_bb, body_bb, new_exit_bb;\n+  basic_block entry_bb, exit_bb, seq_start_bb, body_bb, cont_bb;\n+  basic_block fin_bb;\n   block_stmt_iterator si;\n-  edge exit_edge;\n \n-  l0 = create_artificial_label ();\n-  l1 = create_artificial_label ();\n-  l2 = create_artificial_label ();\n-  \n   type = TREE_TYPE (fd->v);\n   utype = lang_hooks.types.unsigned_type (type);\n \n-  entry_bb = bb_for_stmt (region->entry);\n+  entry_bb = region->entry;\n+  seq_start_bb = create_empty_bb (entry_bb);\n   body_bb = single_succ (entry_bb);\n-  exit_bb = bb_for_stmt (region->exit);\n+  cont_bb = region->cont;\n+  fin_bb = single_succ (cont_bb);\n+  exit_bb = region->exit;\n+\n+  l0 = tree_block_label (seq_start_bb);\n+  l1 = tree_block_label (body_bb);\n+  l2 = tree_block_label (fin_bb);\n \n   /* Iteration space partitioning goes in ENTRY_BB.  */\n   list = alloc_stmt_list ();\n+\n   t = built_in_decls[BUILT_IN_OMP_GET_NUM_THREADS];\n   t = build_function_call_expr (t, NULL);\n   t = fold_convert (utype, t);\n@@ -2673,17 +2671,13 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   append_to_statement_list (t, &list);\n \n   si = bsi_last (entry_bb);\n-  gcc_assert (bsi_stmt (si) && TREE_CODE (bsi_stmt (si)) == OMP_FOR);\n+  gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_FOR);\n+  bsi_insert_after (&si, list, BSI_SAME_STMT);\n   bsi_remove (&si, true);\n-  si = bsi_last (entry_bb);\n-  bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n \n   /* Setup code for sequential iteration goes in SEQ_START_BB.  */\n   list = alloc_stmt_list ();\n \n-  t = build1 (LABEL_EXPR, void_type_node, l0);\n-  gimplify_and_add (t, &list);\n-\n   t = fold_convert (type, s0);\n   t = build2 (MULT_EXPR, type, t, fd->step);\n   t = build2 (PLUS_EXPR, type, t, fd->n1);\n@@ -2695,24 +2689,10 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   t = build2 (PLUS_EXPR, type, t, fd->n1);\n   e = get_formal_tmp_var (t, &list);\n \n-  seq_start_bb = create_empty_bb (entry_bb);\n   si = bsi_start (seq_start_bb);\n   bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n \n-  /* Original body goes in BODY_BB.  */\n-  si = bsi_start (body_bb);\n-  t = build1 (LABEL_EXPR, void_type_node, l1);\n-  bsi_insert_before (&si, t, BSI_CONTINUE_LINKING);\n-\n-  /* Split EXIT_BB at the OMP_RETURN.  The code controlling the\n-     sequential loop goes in the original EXIT_BB.  The exit out of\n-     the parallel loop goes in the new block (NEW_EXIT_BB).  */\n-  si = bsi_last (exit_bb);\n-  t = bsi_stmt (si);\n-  bsi_remove (&si, true);\n-  gcc_assert (t && TREE_CODE (t) == OMP_RETURN_EXPR);\n-  exit_edge = split_block (exit_bb, t);\n-  new_exit_bb = exit_edge->dest;\n+  /* The code controlling the sequential loop replaces the OMP_CONTINUE.  */\n   list = alloc_stmt_list ();\n \n   t = build2 (PLUS_EXPR, type, fd->v, fd->step);\n@@ -2725,26 +2705,30 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n \t      build_and_jump (&l2));\n   append_to_statement_list (t, &list);\n \n-  si = bsi_last (exit_bb);\n-  bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n+  si = bsi_last (cont_bb);\n+  gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_CONTINUE);\n+  bsi_insert_after (&si, list, BSI_SAME_STMT);\n+  bsi_remove (&si, true);\n \n-  /* Add the exit label to NEW_EXIT_BB.  */\n-  si = bsi_start (new_exit_bb);\n-  t = build1 (LABEL_EXPR, void_type_node, l2);\n-  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n-  single_succ_edge (new_exit_bb)->flags = EDGE_FALLTHRU;\n+  /* Replace the OMP_RETURN with a barrier, or nothing.  */\n+  si = bsi_last (exit_bb);\n+  if (!OMP_RETURN_NOWAIT (bsi_stmt (si)))\n+    {\n+      list = alloc_stmt_list ();\n+      build_omp_barrier (&list);\n+      bsi_insert_after (&si, list, BSI_SAME_STMT);\n+    }\n+  bsi_remove (&si, true);\n \n   /* Connect all the blocks.  */\n   make_edge (seq_start_bb, body_bb, EDGE_FALLTHRU);\n \n   remove_edge (single_succ_edge (entry_bb));\n-  make_edge (entry_bb, new_exit_bb, EDGE_TRUE_VALUE);\n+  make_edge (entry_bb, fin_bb, EDGE_TRUE_VALUE);\n   make_edge (entry_bb, seq_start_bb, EDGE_FALSE_VALUE);\n \n-  make_edge (exit_bb, body_bb, EDGE_TRUE_VALUE);\n-  find_edge (exit_bb, new_exit_bb)->flags = EDGE_FALSE_VALUE;\n-\n-  return new_exit_bb;\n+  make_edge (cont_bb, body_bb, EDGE_TRUE_VALUE);\n+  find_edge (cont_bb, fin_bb)->flags = EDGE_FALSE_VALUE;\n }\n \n \n@@ -2779,31 +2763,34 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n     L4:\n */\n \n-static basic_block\n+static void\n expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n {\n   tree l0, l1, l2, l3, l4, n, s0, e0, e, t;\n   tree trip, nthreads, threadid;\n   tree type, utype;\n   basic_block entry_bb, exit_bb, body_bb, seq_start_bb, iter_part_bb;\n-  basic_block trip_update_bb, new_exit_bb;\n-  edge exit_edge;\n+  basic_block trip_update_bb, cont_bb, fin_bb;\n   tree list;\n   block_stmt_iterator si;\n \n-  l0 = create_artificial_label ();\n-  l1 = create_artificial_label ();\n-  l2 = create_artificial_label ();\n-  l3 = create_artificial_label ();\n-  l4 = create_artificial_label ();\n-  \n   type = TREE_TYPE (fd->v);\n   utype = lang_hooks.types.unsigned_type (type);\n \n-  entry_bb = bb_for_stmt (region->entry);\n+  entry_bb = region->entry;\n+  iter_part_bb = create_empty_bb (entry_bb);\n+  seq_start_bb = create_empty_bb (iter_part_bb);\n   body_bb = single_succ (entry_bb);\n+  cont_bb = region->cont;\n+  trip_update_bb = create_empty_bb (cont_bb);\n+  fin_bb = single_succ (cont_bb);\n+  exit_bb = region->exit;\n \n-  exit_bb = bb_for_stmt (region->exit);\n+  l0 = tree_block_label (iter_part_bb);\n+  l1 = tree_block_label (seq_start_bb);\n+  l2 = tree_block_label (body_bb);\n+  l3 = tree_block_label (trip_update_bb);\n+  l4 = tree_block_label (fin_bb);\n \n   /* Trip and adjustment setup goes in ENTRY_BB.  */\n   list = alloc_stmt_list ();\n@@ -2849,17 +2836,13 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n   trip = get_initialized_tmp_var (t, &list, NULL);\n \n   si = bsi_last (entry_bb);\n-  gcc_assert (bsi_stmt (si) && TREE_CODE (bsi_stmt (si)) == OMP_FOR);\n+  gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_FOR);\n+  bsi_insert_after (&si, list, BSI_SAME_STMT);\n   bsi_remove (&si, true);\n-  si = bsi_last (entry_bb);\n-  bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n \n   /* Iteration space partitioning goes in ITER_PART_BB.  */\n   list = alloc_stmt_list ();\n \n-  t = build1 (LABEL_EXPR, void_type_node, l0);\n-  gimplify_and_add (t, &list);\n-\n   t = build2 (MULT_EXPR, utype, trip, nthreads);\n   t = build2 (PLUS_EXPR, utype, t, threadid);\n   t = build2 (MULT_EXPR, utype, t, fd->chunk_size);\n@@ -2874,16 +2857,12 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n \t      build_and_jump (&l1), build_and_jump (&l4));\n   append_to_statement_list (t, &list);\n \n-  iter_part_bb = create_empty_bb (entry_bb);\n   si = bsi_start (iter_part_bb);\n   bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n \n   /* Setup code for sequential iteration goes in SEQ_START_BB.  */\n   list = alloc_stmt_list ();\n \n-  t = build1 (LABEL_EXPR, void_type_node, l1);\n-  gimplify_and_add (t, &list);\n-\n   t = fold_convert (type, s0);\n   t = build2 (MULT_EXPR, type, t, fd->step);\n   t = build2 (PLUS_EXPR, type, t, fd->n1);\n@@ -2895,18 +2874,11 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n   t = build2 (PLUS_EXPR, type, t, fd->n1);\n   e = get_formal_tmp_var (t, &list);\n \n-  seq_start_bb = create_empty_bb (iter_part_bb);\n   si = bsi_start (seq_start_bb);\n   bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n \n-  /* Main loop body goes in BODY_BB.  */\n-  si = bsi_start (body_bb);\n-  t = build1 (LABEL_EXPR, void_type_node, l2);\n-  bsi_insert_before (&si, t, BSI_CONTINUE_LINKING);\n-\n-  /* Split EXIT_BB.  The code controlling the sequential loop goes in\n-     the first half.  The trip update code goes into the second half\n-     (TRIP_UPDATE_BB).  */\n+  /* The code controlling the sequential loop goes in CONT_BB,\n+     replacing the OMP_CONTINUE.  */\n   list = alloc_stmt_list ();\n \n   t = build2 (PLUS_EXPR, type, fd->v, fd->step);\n@@ -2919,52 +2891,46 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n \t      build_and_jump (&l2), build_and_jump (&l3));\n   append_to_statement_list (t, &list);\n   \n-  si = bsi_last (exit_bb);\n-  t = bsi_stmt (si);\n-  gcc_assert (t && TREE_CODE (t) == OMP_RETURN_EXPR);\n+  si = bsi_last (cont_bb);\n+  gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_CONTINUE);\n+  bsi_insert_after (&si, list, BSI_SAME_STMT);\n   bsi_remove (&si, true);\n-  exit_edge = split_block (exit_bb, t);\n-  si = bsi_last (exit_bb);\n-  bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n \n   /* Trip update code goes into TRIP_UPDATE_BB.  */\n-  trip_update_bb = exit_edge->dest;\n   list = alloc_stmt_list ();\n \n-  t = build1 (LABEL_EXPR, void_type_node, l3);\n-  gimplify_and_add (t, &list);\n-\n   t = build_int_cst (utype, 1);\n   t = build2 (PLUS_EXPR, utype, trip, t);\n   t = build2 (MODIFY_EXPR, void_type_node, trip, t);\n   gimplify_and_add (t, &list);\n \n   si = bsi_start (trip_update_bb);\n   bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n-  exit_edge = single_succ_edge (trip_update_bb);\n-  exit_edge->flags = EDGE_FALLTHRU;\n-  new_exit_bb = exit_edge->dest;\n \n-  /* Insert exit label on EXIT_EDGE.  */\n-  t = build1 (LABEL_EXPR, void_type_node, l4);\n-  bsi_insert_on_edge_immediate (exit_edge, t);\n+  /* Replace the OMP_RETURN with a barrier, or nothing.  */\n+  si = bsi_last (exit_bb);\n+  if (!OMP_RETURN_NOWAIT (bsi_stmt (si)))\n+    {\n+      list = alloc_stmt_list ();\n+      build_omp_barrier (&list);\n+      bsi_insert_after (&si, list, BSI_SAME_STMT);\n+    }\n+  bsi_remove (&si, true);\n \n   /* Connect the new blocks.  */\n   remove_edge (single_succ_edge (entry_bb));\n   make_edge (entry_bb, iter_part_bb, EDGE_FALLTHRU);\n \n   make_edge (iter_part_bb, seq_start_bb, EDGE_TRUE_VALUE);\n-  make_edge (iter_part_bb, new_exit_bb, EDGE_FALSE_VALUE);\n-  remove_edge (exit_edge);\n+  make_edge (iter_part_bb, fin_bb, EDGE_FALSE_VALUE);\n \n   make_edge (seq_start_bb, body_bb, EDGE_FALLTHRU);\n \n-  make_edge (exit_bb, body_bb, EDGE_TRUE_VALUE);\n-  find_edge (exit_bb, trip_update_bb)->flags = EDGE_FALSE_VALUE;\n+  remove_edge (single_succ_edge (cont_bb));\n+  make_edge (cont_bb, body_bb, EDGE_TRUE_VALUE);\n+  make_edge (cont_bb, trip_update_bb, EDGE_FALSE_VALUE);\n \n   make_edge (trip_update_bb, iter_part_bb, EDGE_FALLTHRU);\n-\n-  return new_exit_bb;\n }\n \n \n@@ -2974,25 +2940,24 @@ static void\n expand_omp_for (struct omp_region *region)\n {\n   struct omp_for_data fd;\n-  basic_block last_bb = NULL;\n \n   push_gimplify_context ();\n \n-  extract_omp_for_data (region->entry, &fd);\n+  extract_omp_for_data (last_stmt (region->entry), &fd);\n \n   if (fd.sched_kind == OMP_CLAUSE_SCHEDULE_STATIC && !fd.have_ordered)\n     {\n       if (fd.chunk_size == NULL)\n-\tlast_bb = expand_omp_for_static_nochunk (region, &fd);\n+\texpand_omp_for_static_nochunk (region, &fd);\n       else\n-\tlast_bb = expand_omp_for_static_chunk (region, &fd);\n+\texpand_omp_for_static_chunk (region, &fd);\n     }\n   else\n     {\n       int fn_index = fd.sched_kind + fd.have_ordered * 4;\n       int start_ix = BUILT_IN_GOMP_LOOP_STATIC_START + fn_index;\n       int next_ix = BUILT_IN_GOMP_LOOP_STATIC_NEXT + fn_index;\n-      last_bb = expand_omp_for_generic (region, &fd, start_ix, next_ix);\n+      expand_omp_for_generic (region, &fd, start_ix, next_ix);\n     }\n \n   pop_gimplify_context (NULL);\n@@ -3029,19 +2994,23 @@ expand_omp_for (struct omp_region *region)\n static void\n expand_omp_sections (struct omp_region *region)\n {\n-  tree label_vec, l0, l1, l2, t, u, v;\n+  tree label_vec, l0, l1, l2, t, u, v, sections_stmt;\n   unsigned i, len;\n-  basic_block entry_bb, exit_bb, l0_bb, l1_bb, default_bb;\n-  edge e, entry_edge, exit_edge;\n-  edge_iterator ei;\n+  basic_block entry_bb, exit_bb, l0_bb, l1_bb, l2_bb, default_bb;\n   block_stmt_iterator si;\n+  struct omp_region *inner;\n+  edge e;\n \n-  entry_bb = bb_for_stmt (region->entry);\n-  exit_bb = bb_for_stmt (region->exit);\n+  entry_bb = region->entry;\n+  l0_bb = create_empty_bb (entry_bb);\n+  l1_bb = region->cont;\n+  l2_bb = single_succ (l1_bb);\n+  default_bb = create_empty_bb (l1_bb->prev_bb);\n+  exit_bb = region->exit;\n \n-  l0 = create_artificial_label ();\n-  l1 = create_artificial_label ();\n-  l2 = create_artificial_label ();\n+  l0 = tree_block_label (l0_bb);\n+  l1 = tree_block_label (l1_bb);\n+  l2 = tree_block_label (l2_bb);\n \n   v = create_tmp_var (unsigned_type_node, \".section\");\n \n@@ -3051,15 +3020,11 @@ expand_omp_sections (struct omp_region *region)\n   len = EDGE_COUNT (entry_bb->succs);\n   label_vec = make_tree_vec (len + 2);\n \n-  /* Split ENTRY_BB.  The call to GOMP_sections_start goes in the\n-     first half.  The second half contains the switch().  */\n+  /* The call to GOMP_sections_start goes in ENTRY_BB, replacing the\n+     OMP_SECTIONS statement.  */\n   si = bsi_last (entry_bb);\n-  t = bsi_stmt (si);\n-  gcc_assert (t && TREE_CODE (t) == OMP_SECTIONS);\n-  bsi_remove (&si, true);\n-  entry_edge = split_block (entry_bb, t);\n-  l0_bb = entry_edge->dest;\n-\n+  sections_stmt = bsi_stmt (si);\n+  gcc_assert (TREE_CODE (sections_stmt) == OMP_SECTIONS);\n   if (!is_combined_parallel (region))\n     {\n       /* If we are not inside a combined parallel+sections region,\n@@ -3069,135 +3034,158 @@ expand_omp_sections (struct omp_region *region)\n       u = built_in_decls[BUILT_IN_GOMP_SECTIONS_START];\n       t = build_function_call_expr (u, t);\n       t = build2 (MODIFY_EXPR, void_type_node, v, t);\n-      si = bsi_last (entry_bb);\n-      bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n+      bsi_insert_after (&si, t, BSI_SAME_STMT);\n     }\n+  bsi_remove (&si, true);\n \n   /* The switch() statement replacing OMP_SECTIONS goes in L0_BB.  */\n-  si = bsi_last (l0_bb);\n-\n-  t = build1 (LABEL_EXPR, void_type_node, l0);\n-  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n+  si = bsi_start (l0_bb);\n \n   t = build3 (SWITCH_EXPR, void_type_node, v, NULL, label_vec);\n   bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n \n   t = build3 (CASE_LABEL_EXPR, void_type_node,\n \t      build_int_cst (unsigned_type_node, 0), NULL, l2);\n   TREE_VEC_ELT (label_vec, 0) = t;\n+  make_edge (l0_bb, l2_bb, 0);\n   \n   /* Convert each OMP_SECTION into a CASE_LABEL_EXPR.  */\n-  i = 1;\n-  FOR_EACH_EDGE (e, ei, l0_bb->succs)\n+  for (inner = region->inner, i = 1; inner; inner = inner->next, ++i)\n     {\n       basic_block s_entry_bb, s_exit_bb;\n \n-      e->flags = 0;\n-      s_entry_bb = e->dest;\n-      si = bsi_last (s_entry_bb);\n-      t = bsi_stmt (si);\n-      gcc_assert (t && TREE_CODE (t) == OMP_SECTION);\n-      s_exit_bb = bb_for_stmt (lookup_omp_region (t)->exit);\n-      bsi_remove (&si, true);\n+      s_entry_bb = inner->entry;\n+      s_exit_bb = inner->exit;\n \n-      t = create_artificial_label ();\n+      t = tree_block_label (s_entry_bb);\n       u = build_int_cst (unsigned_type_node, i);\n       u = build3 (CASE_LABEL_EXPR, void_type_node, u, NULL, t);\n       TREE_VEC_ELT (label_vec, i) = u;\n-      t = build1 (LABEL_EXPR, void_type_node, t);\n+\n       si = bsi_last (s_entry_bb);\n-      bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n-      i++;\n-      single_succ_edge (s_entry_bb)->flags = EDGE_FALLTHRU;\n+      gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_SECTION);\n+      gcc_assert (i < len || OMP_SECTION_LAST (bsi_stmt (si)));\n+      bsi_remove (&si, true);\n \n       si = bsi_last (s_exit_bb);\n-      t = bsi_stmt (si);\n-      gcc_assert (t && TREE_CODE (t) == OMP_RETURN_EXPR);\n+      gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_RETURN);\n       bsi_remove (&si, true);\n+\n+      e = single_pred_edge (s_entry_bb);\n+      e->flags = 0;\n+      redirect_edge_pred (e, l0_bb);\n+\n+      single_succ_edge (s_entry_bb)->flags = EDGE_FALLTHRU;\n       single_succ_edge (s_exit_bb)->flags = EDGE_FALLTHRU;\n     }\n \n   /* Error handling code goes in DEFAULT_BB.  */\n-  default_bb = create_empty_bb (entry_bb);\n-  si = bsi_start (default_bb);\n-  t = create_artificial_label ();\n+  t = tree_block_label (default_bb);\n   u = build3 (CASE_LABEL_EXPR, void_type_node, NULL, NULL, t);\n   TREE_VEC_ELT (label_vec, len + 1) = u;\n-  t = build1 (LABEL_EXPR, void_type_node, t);\n-  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n+  make_edge (l0_bb, default_bb, 0);\n \n+  si = bsi_start (default_bb);\n   t = built_in_decls[BUILT_IN_TRAP];\n   t = build_function_call_expr (t, NULL);\n   bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n \n-  make_edge (l0_bb, default_bb, 0);\n-\n   /* Code to get the next section goes in L1_BB.  */\n-  si = bsi_last (exit_bb);\n-  t = bsi_stmt (si);\n-  gcc_assert (t && TREE_CODE (t) == OMP_RETURN_EXPR);\n-  bsi_remove (&si, true);\n-  exit_edge = split_block (exit_bb, t);\n-  l1_bb = exit_edge->src;\n-  exit_bb = exit_edge->dest;\n-  si = bsi_start (l1_bb);\n-  t = build1 (LABEL_EXPR, void_type_node, l1);\n-  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n+  si = bsi_last (l1_bb);\n+  gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_CONTINUE);\n \n   t = built_in_decls[BUILT_IN_GOMP_SECTIONS_NEXT];\n   t = build_function_call_expr (t, NULL);\n   t = build2 (MODIFY_EXPR, void_type_node, v, t);\n-  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n-\n-  remove_edge (single_succ_edge (l1_bb));\n-  make_edge (l1_bb, l0_bb, EDGE_FALLTHRU);\n+  bsi_insert_after (&si, t, BSI_SAME_STMT);\n+  bsi_remove (&si, true);\n \n-  /* Exit label in EXIT_BB.  */\n+  /* Cleanup function replaces OMP_RETURN in EXIT_BB.  */\n   si = bsi_last (exit_bb);\n-  t = build1 (LABEL_EXPR, void_type_node, l2);\n-  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n-\n-  make_edge (l0_bb, exit_bb, 0);\n-  single_succ_edge (exit_bb)->flags = EDGE_FALLTHRU;\n+  if (OMP_RETURN_NOWAIT (bsi_stmt (si)))\n+    t = built_in_decls[BUILT_IN_GOMP_SECTIONS_END_NOWAIT];\n+  else\n+    t = built_in_decls[BUILT_IN_GOMP_SECTIONS_END];\n+  t = build_function_call_expr (t, NULL);\n+  bsi_insert_after (&si, t, BSI_SAME_STMT);\n+  bsi_remove (&si, true);\n \n+  /* Connect the new blocks.  */\n   if (is_combined_parallel (region))\n     {\n       /* If this was a combined parallel+sections region, we did not\n \t emit a GOMP_sections_start in the entry block, so we just\n \t need to jump to L1_BB to get the next section.  */\n-      remove_edge (single_succ_edge (entry_bb));\n       make_edge (entry_bb, l1_bb, EDGE_FALLTHRU);\n     }\n+  else\n+    make_edge (entry_bb, l0_bb, EDGE_FALLTHRU);\n+\n+  e = single_succ_edge (l1_bb);\n+  redirect_edge_succ (e, l0_bb);\n+  e->flags = EDGE_FALLTHRU;\n }\n \n \n-/* Generic expansion for OpenMP synchronization directives: single,\n-   master, ordered and critical.  All we need to do here is remove the\n-   entry and exit markers for REGION.  */\n+/* Expand code for an OpenMP single directive.  We've already expanded\n+   much of the code, here we simply place the GOMP_barrier call.  */\n+\n+static void\n+expand_omp_single (struct omp_region *region)\n+{\n+  basic_block entry_bb, exit_bb;\n+  block_stmt_iterator si;\n+  bool need_barrier = false;\n+\n+  entry_bb = region->entry;\n+  exit_bb = region->exit;\n+\n+  si = bsi_last (entry_bb);\n+  /* The terminal barrier at the end of a GOMP_single_copy sequence cannot\n+     be removed.  We need to ensure that the thread that entered the single\n+     does not exit before the data is copied out by the other threads.  */\n+  if (find_omp_clause (OMP_SINGLE_CLAUSES (bsi_stmt (si)),\n+\t\t       OMP_CLAUSE_COPYPRIVATE))\n+    need_barrier = true;\n+  gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_SINGLE);\n+  bsi_remove (&si, true);\n+  single_succ_edge (entry_bb)->flags = EDGE_FALLTHRU;\n+\n+  si = bsi_last (exit_bb);\n+  if (!OMP_RETURN_NOWAIT (bsi_stmt (si)) || need_barrier)\n+    {\n+      tree t = alloc_stmt_list ();\n+      build_omp_barrier (&t);\n+      bsi_insert_after (&si, t, BSI_SAME_STMT);\n+    }\n+  bsi_remove (&si, true);\n+  single_succ_edge (exit_bb)->flags = EDGE_FALLTHRU;\n+}\n+\n+\n+/* Generic expansion for OpenMP synchronization directives: master,\n+   ordered and critical.  All we need to do here is remove the entry\n+   and exit markers for REGION.  */\n \n static void\n expand_omp_synch (struct omp_region *region)\n {\n   basic_block entry_bb, exit_bb;\n   block_stmt_iterator si;\n-  tree t;\n \n-  entry_bb = bb_for_stmt (region->entry);\n-  exit_bb = bb_for_stmt (region->exit);\n+  entry_bb = region->entry;\n+  exit_bb = region->exit;\n \n   si = bsi_last (entry_bb);\n-  t = bsi_stmt (si);\n-  gcc_assert (t\n-              && (TREE_CODE (t) == OMP_SINGLE\n-\t\t  || TREE_CODE (t) == OMP_MASTER\n-\t\t  || TREE_CODE (t) == OMP_ORDERED\n-\t\t  || TREE_CODE (t) == OMP_CRITICAL));\n+  gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_SINGLE\n+\t      || TREE_CODE (bsi_stmt (si)) == OMP_MASTER\n+\t      || TREE_CODE (bsi_stmt (si)) == OMP_ORDERED\n+\t      || TREE_CODE (bsi_stmt (si)) == OMP_CRITICAL);\n   bsi_remove (&si, true);\n   single_succ_edge (entry_bb)->flags = EDGE_FALLTHRU;\n \n   si = bsi_last (exit_bb);\n-  t = bsi_stmt (si);\n-  gcc_assert (t && TREE_CODE (t) == OMP_RETURN_EXPR);\n+  gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_RETURN);\n   bsi_remove (&si, true);\n   single_succ_edge (exit_bb)->flags = EDGE_FALLTHRU;\n }\n@@ -3214,47 +3202,41 @@ expand_omp (struct omp_region *region)\n {\n   while (region)\n     {\n-      enum tree_code code = TREE_CODE (region->entry);\n-\n       if (region->inner)\n \texpand_omp (region->inner);\n \n-      switch (code)\n+      switch (region->type)\n \t{\n-\t  case OMP_PARALLEL:\n-\t    expand_omp_parallel (region);\n-\t    break;\n+\tcase OMP_PARALLEL:\n+\t  expand_omp_parallel (region);\n+\t  break;\n \n-\t  case OMP_FOR:\n-\t    expand_omp_for (region);\n-\t    break;\n+\tcase OMP_FOR:\n+\t  expand_omp_for (region);\n+\t  break;\n \n-\t  case OMP_SECTIONS:\n-\t    expand_omp_sections (region);\n-\t    break;\n+\tcase OMP_SECTIONS:\n+\t  expand_omp_sections (region);\n+\t  break;\n \n-\t  case OMP_SECTION:\n-\t    /* Individual omp sections are handled together with their\n-\t       parent OMP_SECTIONS region.  */\n-\t    break;\n+\tcase OMP_SECTION:\n+\t  /* Individual omp sections are handled together with their\n+\t     parent OMP_SECTIONS region.  */\n+\t  break;\n \n-\t  case OMP_SINGLE:\n-\t  case OMP_MASTER:\n-\t  case OMP_ORDERED:\n-\t  case OMP_CRITICAL:\n-\t    expand_omp_synch (region);\n-\t    break;\n+\tcase OMP_SINGLE:\n+\t  expand_omp_single (region);\n+\t  break;\n \n-\t  default:\n-\t    gcc_unreachable ();\n-\t}\n+\tcase OMP_MASTER:\n+\tcase OMP_ORDERED:\n+\tcase OMP_CRITICAL:\n+\t  expand_omp_synch (region);\n+\t  break;\n \n-      /* Expansion adds and removes basic block, edges, creates\n-\t and exposes unreachable regions that need to be cleaned up\n-\t before proceeding.  */\n-      free_dominance_info (CDI_DOMINATORS);\n-      free_dominance_info (CDI_POST_DOMINATORS);\n-      cleanup_tree_cfg ();\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n \n       region = region->next;\n     }\n@@ -3275,41 +3257,38 @@ build_omp_regions_1 (basic_block bb, struct omp_region *parent)\n   if (!bsi_end_p (si) && OMP_DIRECTIVE_P (bsi_stmt (si)))\n     {\n       struct omp_region *region;\n+      enum tree_code code;\n \n       stmt = bsi_stmt (si);\n+      code = TREE_CODE (stmt);\n \n-      if (TREE_CODE (stmt) == OMP_RETURN_EXPR)\n+      if (code == OMP_RETURN)\n \t{\n \t  /* STMT is the return point out of region PARENT.  Mark it\n \t     as the exit point and make PARENT the immediately\n \t     enclosing region.  */\n \t  gcc_assert (parent);\n \t  region = parent;\n-\t  region->exit = stmt;\n+\t  region->exit = bb;\n \t  parent = parent->outer;\n \n \t  /* If REGION is a parallel region, determine whether it is\n \t     a combined parallel+workshare region.  */\n-\t  if (TREE_CODE (region->entry) == OMP_PARALLEL)\n+\t  if (region->type == OMP_PARALLEL)\n \t    determine_parallel_type (region);\n \t}\n+      else if (code == OMP_CONTINUE)\n+\t{\n+\t  gcc_assert (parent);\n+\t  parent->cont = bb;\n+\t}\n       else\n \t{\n \t  /* Otherwise, this directive becomes the parent for a new\n \t     region.  */\n-\t  region = new_omp_region (stmt, parent);\n+\t  region = new_omp_region (bb, code, parent);\n \t  parent = region;\n \t}\n-\n-      gcc_assert (region);\n-      if (omp_regions == NULL)\n-\t{\n-\t  omp_regions = splay_tree_new (splay_tree_compare_pointers, 0, 0);\n-\t  root_omp_region = region;\n-\t}\n-\n-      splay_tree_insert (omp_regions, (splay_tree_key) stmt,\n-\t                 (splay_tree_value) region);\n     }\n \n   for (son = first_dom_son (CDI_DOMINATORS, bb);\n@@ -3325,7 +3304,7 @@ build_omp_regions_1 (basic_block bb, struct omp_region *parent)\n static void\n build_omp_regions (void)\n {\n-  gcc_assert (omp_regions == NULL && root_omp_region == NULL);\n+  gcc_assert (root_omp_region == NULL);\n   calculate_dominance_info (CDI_DOMINATORS);\n   build_omp_regions_1 (ENTRY_BLOCK_PTR, NULL);\n }\n@@ -3338,20 +3317,26 @@ execute_expand_omp (void)\n {\n   build_omp_regions ();\n \n-  if (root_omp_region)\n-    {\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"\\nOMP region tree\\n\\n\");\n-\t  dump_omp_region (dump_file, root_omp_region, 0);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n+  if (!root_omp_region)\n+    return 0;\n \n-      expand_omp (root_omp_region);\n-      splay_tree_delete (omp_regions);\n-      root_omp_region = NULL;\n-      omp_regions = NULL;\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nOMP region tree\\n\\n\");\n+      dump_omp_region (dump_file, root_omp_region, 0);\n+      fprintf (dump_file, \"\\n\");\n     }\n+\n+  remove_exit_barriers (root_omp_region);\n+\n+  expand_omp (root_omp_region);\n+\n+  free_dominance_info (CDI_DOMINATORS);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+  cleanup_tree_cfg ();\n+\n+  free_omp_regions ();\n+\n   return 0;\n }\n \n@@ -3386,14 +3371,12 @@ static void\n lower_omp_sections (tree *stmt_p, omp_context *ctx)\n {\n   tree new_stmt, stmt, body, bind, block, ilist, olist, new_body;\n-  tree dlist, region_exit;\n+  tree t, dlist;\n   tree_stmt_iterator tsi;\n   unsigned i, len;\n \n   stmt = *stmt_p;\n \n-  gcc_assert (OMP_SECTIONS_SECTIONS (stmt) == NULL_TREE);\n-\n   push_gimplify_context ();\n \n   dlist = NULL;\n@@ -3404,41 +3387,34 @@ lower_omp_sections (tree *stmt_p, omp_context *ctx)\n   for (len = 0; !tsi_end_p (tsi); len++, tsi_next (&tsi))\n     continue;\n \n-  /* There are two markers per section and one end marker for the\n-     whole construct.  */\n-  OMP_SECTIONS_SECTIONS (stmt) = make_tree_vec (2 * len + 1);\n-\n   tsi = tsi_start (OMP_SECTIONS_BODY (stmt));\n   body = alloc_stmt_list ();\n   for (i = 0; i < len; i++, tsi_next (&tsi))\n     {\n       omp_context *sctx;\n-      tree sec_start, sec_end, sec_body;\n+      tree sec_start, sec_end;\n \n       sec_start = tsi_stmt (tsi);\n-      sec_body = alloc_stmt_list ();\n       sctx = maybe_lookup_ctx (sec_start);\n       gcc_assert (sctx);\n \n+      append_to_statement_list (sec_start, &body);\n+\n       lower_omp (&OMP_SECTION_BODY (sec_start), sctx);\n-      append_to_statement_list (OMP_SECTION_BODY (sec_start), &sec_body);\n+      append_to_statement_list (OMP_SECTION_BODY (sec_start), &body);\n+      OMP_SECTION_BODY (sec_start) = NULL;\n \n       if (i == len - 1)\n \t{\n \t  tree l = alloc_stmt_list ();\n \t  lower_lastprivate_clauses (OMP_SECTIONS_CLAUSES (stmt), NULL,\n \t\t\t\t     &l, ctx);\n-\t  append_to_statement_list (l, &sec_body);\n+\t  append_to_statement_list (l, &body);\n+\t  OMP_SECTION_LAST (sec_start) = 1;\n \t}\n       \n-      sec_end = make_node (OMP_RETURN_EXPR);\n-\n-      OMP_SECTION_BODY (sec_start) = sec_body;\n-      append_to_statement_list (sec_start, &body);\n+      sec_end = make_node (OMP_RETURN);\n       append_to_statement_list (sec_end, &body);\n-\n-      TREE_VEC_ELT (OMP_SECTIONS_SECTIONS (stmt), i * 2) = sec_start;\n-      TREE_VEC_ELT (OMP_SECTIONS_SECTIONS (stmt), i * 2 + 1) = sec_end;\n     }\n \n   block = make_node (BLOCK);\n@@ -3448,31 +3424,30 @@ lower_omp_sections (tree *stmt_p, omp_context *ctx)\n   olist = NULL_TREE;\n   lower_reduction_clauses (OMP_SECTIONS_CLAUSES (stmt), &olist, ctx);\n \n-  /* Unless there's a nowait clause, add a barrier afterward.  */\n-  if (!find_omp_clause (OMP_SECTIONS_CLAUSES (stmt), OMP_CLAUSE_NOWAIT))\n-    build_omp_barrier (&olist);\n-\n   pop_gimplify_context (NULL_TREE);\n   record_vars_into (ctx->block_vars, ctx->cb.dst_fn);\n \n   new_stmt = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n   TREE_SIDE_EFFECTS (new_stmt) = 1;\n-  OMP_SECTIONS_BODY (stmt) = body;\n-\n-  region_exit = make_node (OMP_RETURN_EXPR);\n \n   new_body = alloc_stmt_list ();\n   append_to_statement_list (ilist, &new_body);\n   append_to_statement_list (stmt, &new_body);\n-  /* ??? The OMP_RETURN doesn't logically belong here, but in\n-     expand_omp_sections we expect this marker to be where the\n-     individual sections join after completing the loop.  */\n-  append_to_statement_list (region_exit, &new_body);\n+  append_to_statement_list (bind, &new_body);\n+\n+  t = make_node (OMP_CONTINUE);\n+  append_to_statement_list (t, &new_body);\n+\n   append_to_statement_list (olist, &new_body);\n   append_to_statement_list (dlist, &new_body);\n-  BIND_EXPR_BODY (new_stmt) = new_body;\n \n-  TREE_VEC_ELT (OMP_SECTIONS_SECTIONS (stmt), 2 * len) = region_exit;\n+  t = make_node (OMP_RETURN);\n+  OMP_RETURN_NOWAIT (t) = !!find_omp_clause (OMP_SECTIONS_CLAUSES (stmt),\n+\t\t\t\t\t     OMP_CLAUSE_NOWAIT);\n+  append_to_statement_list (t, &new_body);\n+\n+  BIND_EXPR_BODY (new_stmt) = new_body;\n+  OMP_SECTIONS_BODY (stmt) = NULL;\n \n   *stmt_p = new_stmt;\n }\n@@ -3499,9 +3474,6 @@ lower_omp_single_simple (tree single_stmt, tree *pre_p)\n   t = build3 (COND_EXPR, void_type_node, t,\n \t      OMP_SINGLE_BODY (single_stmt), NULL);\n   gimplify_and_add (t, pre_p);\n-\n-  if (!find_omp_clause (OMP_SINGLE_CLAUSES (single_stmt), OMP_CLAUSE_NOWAIT))\n-    build_omp_barrier (pre_p);\n }\n \n \n@@ -3585,8 +3557,6 @@ lower_omp_single_copy (tree single_stmt, tree *pre_p, omp_context *ctx)\n \n   t = build1 (LABEL_EXPR, void_type_node, l2);\n   gimplify_and_add (t, pre_p);\n-\n-  build_omp_barrier (pre_p);\n }\n \n \n@@ -3600,29 +3570,34 @@ lower_omp_single (tree *stmt_p, omp_context *ctx)\n   push_gimplify_context ();\n \n   block = make_node (BLOCK);\n-  bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, block);\n+  *stmt_p = bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, block);\n   TREE_SIDE_EFFECTS (bind) = 1;\n \n   lower_rec_input_clauses (OMP_SINGLE_CLAUSES (single_stmt),\n \t\t\t   &BIND_EXPR_BODY (bind), &dlist, ctx);\n   lower_omp (&OMP_SINGLE_BODY (single_stmt), ctx);\n+  maybe_catch_exception (&OMP_SINGLE_BODY (single_stmt));\n+\n+  append_to_statement_list (single_stmt, &BIND_EXPR_BODY (bind));\n \n   if (ctx->record_type)\n     lower_omp_single_copy (single_stmt, &BIND_EXPR_BODY (bind), ctx);\n   else\n     lower_omp_single_simple (single_stmt, &BIND_EXPR_BODY (bind));\n \n+  OMP_SINGLE_BODY (single_stmt) = NULL;\n+\n   append_to_statement_list (dlist, &BIND_EXPR_BODY (bind));\n-  maybe_catch_exception (&BIND_EXPR_BODY (bind));\n-  t = make_node (OMP_RETURN_EXPR);\n+\n+  t = make_node (OMP_RETURN);\n+  OMP_RETURN_NOWAIT (t) = !!find_omp_clause (OMP_SINGLE_CLAUSES (single_stmt),\n+\t\t\t\t\t     OMP_CLAUSE_NOWAIT);\n   append_to_statement_list (t, &BIND_EXPR_BODY (bind));\n+\n   pop_gimplify_context (bind);\n \n   BIND_EXPR_VARS (bind) = chainon (BIND_EXPR_VARS (bind), ctx->block_vars);\n   BLOCK_VARS (block) = BIND_EXPR_VARS (bind);\n-\n-  OMP_SINGLE_BODY (single_stmt) = alloc_stmt_list ();\n-  append_to_statement_list (bind, &OMP_SINGLE_BODY (single_stmt));\n }\n \n \n@@ -3636,30 +3611,33 @@ lower_omp_master (tree *stmt_p, omp_context *ctx)\n   push_gimplify_context ();\n \n   block = make_node (BLOCK);\n-  bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, block);\n+  *stmt_p = bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, block);\n   TREE_SIDE_EFFECTS (bind) = 1;\n \n+  append_to_statement_list (stmt, &BIND_EXPR_BODY (bind));\n+\n   x = built_in_decls[BUILT_IN_OMP_GET_THREAD_NUM];\n   x = build_function_call_expr (x, NULL);\n   x = build2 (EQ_EXPR, boolean_type_node, x, integer_zero_node);\n   x = build3 (COND_EXPR, void_type_node, x, NULL, build_and_jump (&lab));\n   gimplify_and_add (x, &BIND_EXPR_BODY (bind));\n \n   lower_omp (&OMP_MASTER_BODY (stmt), ctx);\n+  maybe_catch_exception (&OMP_MASTER_BODY (stmt));\n   append_to_statement_list (OMP_MASTER_BODY (stmt), &BIND_EXPR_BODY (bind));\n+  OMP_MASTER_BODY (stmt) = NULL;\n \n   x = build1 (LABEL_EXPR, void_type_node, lab);\n   gimplify_and_add (x, &BIND_EXPR_BODY (bind));\n-  maybe_catch_exception (&BIND_EXPR_BODY (bind));\n-  x = make_node (OMP_RETURN_EXPR);\n+\n+  x = make_node (OMP_RETURN);\n+  OMP_RETURN_NOWAIT (x) = 1;\n   append_to_statement_list (x, &BIND_EXPR_BODY (bind));\n+\n   pop_gimplify_context (bind);\n \n   BIND_EXPR_VARS (bind) = chainon (BIND_EXPR_VARS (bind), ctx->block_vars);\n   BLOCK_VARS (block) = BIND_EXPR_VARS (bind);\n-\n-  OMP_MASTER_BODY (stmt) = alloc_stmt_list ();\n-  append_to_statement_list (bind, &OMP_MASTER_BODY (stmt));\n }\n \n \n@@ -3673,29 +3651,32 @@ lower_omp_ordered (tree *stmt_p, omp_context *ctx)\n   push_gimplify_context ();\n \n   block = make_node (BLOCK);\n-  bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, block);\n+  *stmt_p = bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, block);\n   TREE_SIDE_EFFECTS (bind) = 1;\n \n+  append_to_statement_list (stmt, &BIND_EXPR_BODY (bind));\n+\n   x = built_in_decls[BUILT_IN_GOMP_ORDERED_START];\n   x = build_function_call_expr (x, NULL);\n   gimplify_and_add (x, &BIND_EXPR_BODY (bind));\n \n   lower_omp (&OMP_ORDERED_BODY (stmt), ctx);\n+  maybe_catch_exception (&OMP_ORDERED_BODY (stmt));\n   append_to_statement_list (OMP_ORDERED_BODY (stmt), &BIND_EXPR_BODY (bind));\n+  OMP_ORDERED_BODY (stmt) = NULL;\n \n   x = built_in_decls[BUILT_IN_GOMP_ORDERED_END];\n   x = build_function_call_expr (x, NULL);\n   gimplify_and_add (x, &BIND_EXPR_BODY (bind));\n-  maybe_catch_exception (&BIND_EXPR_BODY (bind));\n-  x = make_node (OMP_RETURN_EXPR);\n+\n+  x = make_node (OMP_RETURN);\n+  OMP_RETURN_NOWAIT (x) = 1;\n   append_to_statement_list (x, &BIND_EXPR_BODY (bind));\n+\n   pop_gimplify_context (bind);\n \n   BIND_EXPR_VARS (bind) = chainon (BIND_EXPR_VARS (bind), ctx->block_vars);\n   BLOCK_VARS (block) = BIND_EXPR_VARS (bind);\n-\n-  OMP_ORDERED_BODY (stmt) = alloc_stmt_list ();\n-  append_to_statement_list (bind, &OMP_ORDERED_BODY (stmt));\n }\n \n \n@@ -3766,25 +3747,27 @@ lower_omp_critical (tree *stmt_p, omp_context *ctx)\n   push_gimplify_context ();\n \n   block = make_node (BLOCK);\n-  bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, block);\n+  *stmt_p = bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, block);\n   TREE_SIDE_EFFECTS (bind) = 1;\n \n+  append_to_statement_list (stmt, &BIND_EXPR_BODY (bind));\n+\n   gimplify_and_add (lock, &BIND_EXPR_BODY (bind));\n \n   lower_omp (&OMP_CRITICAL_BODY (stmt), ctx);\n   maybe_catch_exception (&OMP_CRITICAL_BODY (stmt));\n   append_to_statement_list (OMP_CRITICAL_BODY (stmt), &BIND_EXPR_BODY (bind));\n+  OMP_CRITICAL_BODY (stmt) = NULL;\n \n   gimplify_and_add (unlock, &BIND_EXPR_BODY (bind));\n-  t = make_node (OMP_RETURN_EXPR);\n+\n+  t = make_node (OMP_RETURN);\n+  OMP_RETURN_NOWAIT (t) = 1;\n   append_to_statement_list (t, &BIND_EXPR_BODY (bind));\n \n   pop_gimplify_context (bind);\n   BIND_EXPR_VARS (bind) = chainon (BIND_EXPR_VARS (bind), ctx->block_vars);\n   BLOCK_VARS (block) = BIND_EXPR_VARS (bind);\n-\n-  OMP_CRITICAL_BODY (stmt) = alloc_stmt_list ();\n-  append_to_statement_list (bind, &OMP_CRITICAL_BODY (stmt));\n }\n \n \n@@ -3871,30 +3854,28 @@ lower_omp_for (tree *stmt_p, omp_context *ctx)\n   /* Once lowered, extract the bounds and clauses.  */\n   extract_omp_for_data (stmt, &fd);\n \n-  /* Region exit marker goes at the end of the loop body.  */\n-  t = make_node (OMP_RETURN_EXPR);\n-  append_to_statement_list (t, &OMP_FOR_BODY (stmt));\n-  maybe_catch_exception (&OMP_FOR_BODY (stmt));\n   append_to_statement_list (stmt, body_p);\n \n+  maybe_catch_exception (&OMP_FOR_BODY (stmt));\n+  append_to_statement_list (OMP_FOR_BODY (stmt), body_p);\n+\n+  t = make_node (OMP_CONTINUE);\n+  append_to_statement_list (t, body_p);\n+\n   /* After the loop, add exit clauses.  */\n   lower_omp_for_lastprivate (&fd, &dlist, ctx);\n   lower_reduction_clauses (OMP_FOR_CLAUSES (stmt), body_p, ctx);\n   append_to_statement_list (dlist, body_p);\n \n-  /* Add a barrier unless the user specified NOWAIT.  Note that if\n-     this is a combined parallel+loop construct, the barrier will be\n-     optimized away during expansion (see expand_omp_for).  */\n-  if (!fd.have_nowait)\n-    {\n-      tree stmt = alloc_stmt_list ();\n-      build_omp_barrier (&stmt);\n-      append_to_statement_list (stmt, body_p);\n-    }\n+  /* Region exit marker goes at the end of the loop body.  */\n+  t = make_node (OMP_RETURN);\n+  OMP_RETURN_NOWAIT (t) = fd.have_nowait;\n+  append_to_statement_list (t, body_p);\n \n   pop_gimplify_context (NULL_TREE);\n   record_vars_into (ctx->block_vars, ctx->cb.dst_fn);\n \n+  OMP_FOR_BODY (stmt) = NULL_TREE;\n   OMP_FOR_PRE_BODY (stmt) = NULL_TREE;\n   *stmt_p = new_stmt;\n }\n@@ -3959,7 +3940,7 @@ lower_omp_parallel (tree *stmt_p, omp_context *ctx)\n   append_to_statement_list (par_ilist, &new_body);\n   append_to_statement_list (par_body, &new_body);\n   append_to_statement_list (par_olist, &new_body);\n-  t = make_node (OMP_RETURN_EXPR);\n+  t = make_node (OMP_RETURN);\n   append_to_statement_list (t, &new_body);\n   OMP_PARALLEL_BODY (stmt) = new_body;\n \n@@ -4155,8 +4136,8 @@ struct tree_opt_pass pass_lower_omp =\n };\n \f\n /* The following is a utility to diagnose OpenMP structured block violations.\n-   It's part of the \"omplower\" pass, as that's invoked too late.  It should\n-   be invoked by the respective front ends after gimplification.  */\n+   It is not part of the \"omplower\" pass, as that's invoked too late.  It\n+   should be invoked by the respective front ends after gimplification.  */\n \n static splay_tree all_labels;\n "}, {"sha": "69bd3a2e3a909384061b11a8ea82fc33768a0bda", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=777f7f9a72532980c1b5cfa05a7a1f032807f10f", "patch": "@@ -1,3 +1,7 @@\n+2006-04-13  Richard Henderson  <rth@redhat.com>\n+\n+\t* g++.dg/gomp/block-0.C: Update expected matches.\n+\n 2006-04-13  DJ Delorie  <dj@redhat.com>\n \n \t* lib/target-supports.exp (check_effective_target_int32plus): New."}, {"sha": "fa7865d8b93cd1ee54bff983ea841e0e246aef59", "filename": "gcc/testsuite/g++.dg/gomp/block-0.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-0.C?ref=777f7f9a72532980c1b5cfa05a7a1f032807f10f", "patch": "@@ -29,5 +29,5 @@ void foo()\n     }\n }\n \n-// { dg-final { scan-tree-dump-times \"terminate\" 8 \"omplower\" } }\n+// { dg-final { scan-tree-dump-times \"terminate\" 10 \"omplower\" } }\n // { dg-final { cleanup-tree-dump \"omplower\" } }"}, {"sha": "7fa936e0d6b36ca461587ac80a3f63043ef07557", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 52, "deletions": 40, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=777f7f9a72532980c1b5cfa05a7a1f032807f10f", "patch": "@@ -103,7 +103,6 @@ static void make_edges (void);\n static void make_cond_expr_edges (basic_block);\n static void make_switch_expr_edges (basic_block);\n static void make_goto_expr_edges (basic_block);\n-static void make_omp_sections_edges (basic_block);\n static edge tree_redirect_edge_and_branch (edge, basic_block);\n static edge tree_try_redirect_by_replacing_jump (edge, basic_block);\n static unsigned int split_critical_edges (void);\n@@ -447,6 +446,7 @@ static void\n make_edges (void)\n {\n   basic_block bb;\n+  struct omp_region *cur_region = NULL;\n \n   /* Create an edge from entry to the first block with executable\n      statements in it.  */\n@@ -460,7 +460,8 @@ make_edges (void)\n \n       if (last)\n \t{\n-\t  switch (TREE_CODE (last))\n+\t  enum tree_code code = TREE_CODE (last);\n+\t  switch (code)\n \t    {\n \t    case GOTO_EXPR:\n \t      make_goto_expr_edges (bb);\n@@ -522,20 +523,55 @@ make_edges (void)\n \t    case OMP_ORDERED:\n \t    case OMP_CRITICAL:\n \t    case OMP_SECTION:\n+\t      cur_region = new_omp_region (bb, code, cur_region);\n \t      fallthru = true;\n \t      break;\n \n-\t    case OMP_RETURN_EXPR:\n-\t      /* In the case of an OMP_SECTION, we may have already made\n-\t\t an edge in make_omp_sections_edges.  */\n-\t      fallthru = EDGE_COUNT (bb->succs) == 0;\n-\t      break;\n-\n \t    case OMP_SECTIONS:\n-\t      make_omp_sections_edges (bb);\n+\t      cur_region = new_omp_region (bb, code, cur_region);\n \t      fallthru = false;\n \t      break;\n \n+\t    case OMP_RETURN:\n+\t      /* In the case of an OMP_SECTION, the edge will go somewhere\n+\t\t other than the next block.  This will be created later.  */\n+\t      cur_region->exit = bb;\n+\t      fallthru = cur_region->type != OMP_SECTION;\n+\t      cur_region = cur_region->outer;\n+\t      break;\n+\n+\t    case OMP_CONTINUE:\n+\t      cur_region->cont = bb;\n+\t      switch (cur_region->type)\n+\t\t{\n+\t\tcase OMP_FOR:\n+\t\t  /* ??? Technically there should be a some sort of loopback\n+\t\t     edge here, but it goes to a block that doesn't exist yet,\n+\t\t     and without it, updating the ssa form would be a real\n+\t\t     bear.  Fortunately, we don't yet do ssa before expanding\n+\t\t     these nodes.  */\n+\t\t  break;\n+\n+\t\tcase OMP_SECTIONS:\n+\t\t  /* Wire up the edges into and out of the nested sections.  */\n+\t\t  /* ??? Similarly wrt loopback.  */\n+\t\t  {\n+\t\t    struct omp_region *i;\n+\t\t    for (i = cur_region->inner; i ; i = i->next)\n+\t\t      {\n+\t\t\tgcc_assert (i->type == OMP_SECTION);\n+\t\t\tmake_edge (cur_region->entry, i->entry, 0);\n+\t\t\tmake_edge (i->exit, bb, EDGE_FALLTHRU);\n+\t\t      }\n+\t\t  }\n+\t\t  break;\n+\t\t     \n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t      fallthru = true;\n+\t      break;\n+\n \t    default:\n \t      gcc_assert (!stmt_ends_bb_p (last));\n \t      fallthru = true;\n@@ -548,6 +584,9 @@ make_edges (void)\n \tmake_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n     }\n \n+  if (root_omp_region)\n+    free_omp_regions ();\n+\n   /* Fold COND_EXPR_COND of each COND_EXPR.  */\n   fold_cond_expr_cond ();\n \n@@ -556,35 +595,6 @@ make_edges (void)\n }\n \n \n-/* Link an OMP_SECTIONS block to all the OMP_SECTION blocks in its body.  */\n-\n-static void\n-make_omp_sections_edges (basic_block bb)\n-{\n-  basic_block exit_bb;\n-  size_t i, n;\n-  tree vec, stmt;\n-\n-  stmt = last_stmt (bb);\n-  vec = OMP_SECTIONS_SECTIONS (stmt);\n-  n = TREE_VEC_LENGTH (vec);\n-  exit_bb = bb_for_stmt (TREE_VEC_ELT (vec, n - 1));\n-\n-  for (i = 0; i < n - 1; i += 2)\n-    {\n-      basic_block start_bb = bb_for_stmt (TREE_VEC_ELT (vec, i));\n-      basic_block end_bb = bb_for_stmt (TREE_VEC_ELT (vec, i + 1));\n-      make_edge (bb, start_bb, 0);\n-      make_edge (end_bb, exit_bb, EDGE_FALLTHRU);\n-    }\n-\n-  /* Once the CFG has been built, the vector of sections is no longer\n-     useful.  The region can be easily obtained with build_omp_regions.\n-     Furthermore, this sharing of tree expressions is not allowed by the\n-     statement verifier.  */\n-  OMP_SECTIONS_SECTIONS (stmt) = NULL_TREE;\n-}\n-\n /* Create the edges for a COND_EXPR starting at block BB.\n    At this point, both clauses must contain only simple gotos.  */\n \n@@ -2498,7 +2508,7 @@ is_ctrl_altering_stmt (tree t)\n     }\n \n   /* OpenMP directives alter control flow.  */\n-  if (flag_openmp && OMP_DIRECTIVE_P (t))\n+  if (OMP_DIRECTIVE_P (t))\n     return true;\n \n   /* If a statement can throw, it alters control flow.  */\n@@ -4549,7 +4559,9 @@ move_stmt_r (tree *tp, int *walk_subtrees, void *data)\n   if (p->block && IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (t))))\n     TREE_BLOCK (t) = p->block;\n \n-  if (OMP_DIRECTIVE_P (t) && TREE_CODE (t) != OMP_RETURN_EXPR)\n+  if (OMP_DIRECTIVE_P (t)\n+      && TREE_CODE (t) != OMP_RETURN\n+      && TREE_CODE (t) != OMP_CONTINUE)\n     {\n       /* Do not remap variables inside OMP directives.  Variables\n \t referenced in clauses and directive header belong to the"}, {"sha": "cdf38af822f75c7848439af66a4b29ed379db7bc", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=777f7f9a72532980c1b5cfa05a7a1f032807f10f", "patch": "@@ -469,6 +469,51 @@ extern void bsi_insert_after (block_stmt_iterator *, tree,\n \n extern void bsi_replace (const block_stmt_iterator *, tree, bool);\n \n+/*---------------------------------------------------------------------------\n+\t\t\t      OpenMP Region Tree\n+---------------------------------------------------------------------------*/\n+\n+/* Parallel region information.  Every parallel and workshare\n+   directive is enclosed between two markers, the OMP_* directive\n+   and a corresponding OMP_RETURN statement.  */\n+\n+struct omp_region\n+{\n+  /* The enclosing region.  */\n+  struct omp_region *outer;\n+\n+  /* First child region.  */\n+  struct omp_region *inner;\n+\n+  /* Next peer region.  */\n+  struct omp_region *next;\n+\n+  /* Block containing the omp directive as its last stmt.  */\n+  basic_block entry;\n+\n+  /* Block containing the OMP_RETURN as its last stmt.  */\n+  basic_block exit;\n+\n+  /* Block containing the OMP_CONTINUE as its last stmt.  */\n+  basic_block cont;\n+\n+  /* If this is a combined parallel+workshare region, this is a list\n+     of additional arguments needed by the combined parallel+workshare\n+     library call.  */\n+  tree ws_args;\n+\n+  /* The code for the omp directive of this region.  */\n+  enum tree_code type;\n+\n+  /* True if this is a combined parallel+workshare region.  */\n+  bool is_combined_parallel;\n+};\n+\n+extern struct omp_region *root_omp_region;\n+extern struct omp_region *new_omp_region (basic_block, enum tree_code,\n+\t\t\t\t\t  struct omp_region *);\n+extern void free_omp_regions (void);\n+\n /*---------------------------------------------------------------------------\n \t\t\t      Function prototypes\n ---------------------------------------------------------------------------*/"}, {"sha": "7b5202771c3dd216af70948df083a1e033d6996f", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=777f7f9a72532980c1b5cfa05a7a1f032807f10f", "patch": "@@ -224,7 +224,8 @@ is_gimple_stmt (tree t)\n     case OMP_MASTER:\n     case OMP_ORDERED:\n     case OMP_CRITICAL:\n-    case OMP_RETURN_EXPR:\n+    case OMP_RETURN:\n+    case OMP_CONTINUE:\n       /* These are always void.  */\n       return true;\n "}, {"sha": "525009eb73803a024dcb8e16f394b0c3ef4194ba", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=777f7f9a72532980c1b5cfa05a7a1f032807f10f", "patch": "@@ -1603,7 +1603,8 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n     case PHI_NODE:\n     case WITH_SIZE_EXPR:\n     case OMP_CLAUSE:\n-    case OMP_RETURN_EXPR:\n+    case OMP_RETURN:\n+    case OMP_CONTINUE:\n       break;\n \n     /* We don't account constants for now.  Assume that the cost is amortized"}, {"sha": "b86d2ce9077deab387140ed27e987925d3e87c44", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=777f7f9a72532980c1b5cfa05a7a1f032807f10f", "patch": "@@ -1822,8 +1822,15 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       dump_omp_clauses (buffer, OMP_SINGLE_CLAUSES (node), spc, flags);\n       goto dump_omp_body;\n \n-    case OMP_RETURN_EXPR:\n+    case OMP_RETURN:\n       pp_string (buffer, \"OMP_RETURN\");\n+      if (OMP_RETURN_NOWAIT (node))\n+\tpp_string (buffer, \" [nowait]\");\n+      is_expr = false;\n+      break;\n+\n+    case OMP_CONTINUE:\n+      pp_string (buffer, \"OMP_CONTINUE\");\n       is_expr = false;\n       break;\n "}, {"sha": "7ef064718cc842f13085b2a20489e40fee93caab", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=777f7f9a72532980c1b5cfa05a7a1f032807f10f", "patch": "@@ -2096,11 +2096,12 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n     case OMP_PARALLEL:\n     case OMP_SECTIONS:\n     case OMP_FOR:\n-    case OMP_RETURN_EXPR:\n     case OMP_SINGLE:\n     case OMP_MASTER:\n     case OMP_ORDERED:\n     case OMP_CRITICAL:\n+    case OMP_RETURN:\n+    case OMP_CONTINUE:\n       /* Expressions that make no memory references.  */\n       return;\n "}, {"sha": "ffc772fa1735f384c85f0ad31f399a3b5ece1329", "filename": "gcc/tree.def", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=777f7f9a72532980c1b5cfa05a7a1f032807f10f", "patch": "@@ -987,11 +987,8 @@ DEFTREECODE (OMP_FOR, \"omp_for\", tcc_statement, 6)\n \n /* OpenMP - #pragma omp sections [clause1 ... clauseN]\n    Operand 0: OMP_SECTIONS_BODY: Sections body.\n-   Operand 1: OMP_SECTIONS_CLAUSES: List of clauses.\n-   Operand 2: OMP_SECTIONS_SECTIONS: Vector of the different sections\n-\t      in the body.  Only valid after lowering and destroyed\n-\t      after the CFG has been built.  */\n-DEFTREECODE (OMP_SECTIONS, \"omp_sections\", tcc_statement, 3)\n+   Operand 1: OMP_SECTIONS_CLAUSES: List of clauses.  */\n+DEFTREECODE (OMP_SECTIONS, \"omp_sections\", tcc_statement, 2)\n \n /* OpenMP - #pragma omp single\n    Operand 0: OMP_SINGLE_BODY: Single section body.\n@@ -1015,6 +1012,13 @@ DEFTREECODE (OMP_ORDERED, \"omp_ordered\", tcc_statement, 1)\n    Operand 1: OMP_CRITICAL_NAME: Identifier for critical section.  */\n DEFTREECODE (OMP_CRITICAL, \"omp_critical\", tcc_statement, 2)\n \n+/* Return from an OpenMP directive.  */\n+DEFTREECODE (OMP_RETURN, \"omp_return\", tcc_statement, 0)\n+\n+/* OpenMP - An intermediate tree code to mark the location of the\n+   loop or sections iteration in the partially lowered code.  */\n+DEFTREECODE (OMP_CONTINUE, \"omp_continue\", tcc_statement, 0)\n+\n /* OpenMP - #pragma omp atomic\n    Operand 0: The address at which the atomic operation is to be performed.\n \tThis address should be stabilized with save_expr.\n@@ -1026,9 +1030,6 @@ DEFTREECODE (OMP_ATOMIC, \"omp_atomic\", tcc_statement, 2)\n /* OpenMP clauses.  */\n DEFTREECODE (OMP_CLAUSE, \"omp_clause\", tcc_exceptional, 0)\n \n-/* Return from an OpenMP directive.  */\n-DEFTREECODE (OMP_RETURN_EXPR, \"omp_return\", tcc_statement, 0)\n-\n /* Reduction operations. \n    Operations that take a vector of elements and \"reduce\" it to a scalar\n    result (e.g. summing the elements of the vector, finding the minimum over"}, {"sha": "742002a693fccd2e53a884f65536477b44d9b83e", "filename": "gcc/tree.h", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777f7f9a72532980c1b5cfa05a7a1f032807f10f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=777f7f9a72532980c1b5cfa05a7a1f032807f10f", "patch": "@@ -170,14 +170,15 @@ extern const enum tree_code_class tree_code_type[];\n \n #define OMP_DIRECTIVE_P(NODE)\t\t\t\t\\\n     (TREE_CODE (NODE) == OMP_PARALLEL\t\t\t\\\n-     || TREE_CODE (NODE) == OMP_SECTIONS\t\t\\\n-     || TREE_CODE (NODE) == OMP_SECTION\t\t\t\\\n      || TREE_CODE (NODE) == OMP_FOR\t\t\t\\\n-     || TREE_CODE (NODE) == OMP_RETURN_EXPR\t\t\\\n+     || TREE_CODE (NODE) == OMP_SECTIONS\t\t\\\n      || TREE_CODE (NODE) == OMP_SINGLE\t\t\t\\\n+     || TREE_CODE (NODE) == OMP_SECTION\t\t\t\\\n      || TREE_CODE (NODE) == OMP_MASTER\t\t\t\\\n      || TREE_CODE (NODE) == OMP_ORDERED\t\t\t\\\n-     || TREE_CODE (NODE) == OMP_CRITICAL)\n+     || TREE_CODE (NODE) == OMP_CRITICAL\t\t\\\n+     || TREE_CODE (NODE) == OMP_RETURN\t\t\t\\\n+     || TREE_CODE (NODE) == OMP_CONTINUE)\n \n /* Number of argument-words in each kind of tree-node.  */\n \n@@ -437,6 +438,10 @@ struct tree_common GTY(())\n            CALL_EXPR\n        DECL_BY_REFERENCE in\n            PARM_DECL, RESULT_DECL\n+       OMP_RETURN_NOWAIT in\n+\t   OMP_RETURN\n+       OMP_SECTION_LAST in\n+\t   OMP_SECTION\n \n    protected_flag:\n \n@@ -1546,7 +1551,6 @@ struct tree_constructor GTY(())\n \n #define OMP_SECTIONS_BODY(NODE)    TREE_OPERAND (OMP_SECTIONS_CHECK (NODE), 0)\n #define OMP_SECTIONS_CLAUSES(NODE) TREE_OPERAND (OMP_SECTIONS_CHECK (NODE), 1)\n-#define OMP_SECTIONS_SECTIONS(NODE) TREE_OPERAND (OMP_SECTIONS_CHECK (NODE), 2)\n \n #define OMP_SECTION_BODY(NODE)\t   TREE_OPERAND (OMP_SECTION_CHECK (NODE), 0)\n \n@@ -1566,6 +1570,18 @@ struct tree_constructor GTY(())\n \t\t\t\t\t      OMP_CLAUSE_PRIVATE,\t\\\n \t                                      OMP_CLAUSE_COPYPRIVATE), 0)\n \n+/* True on an OMP_SECTION statement that was the last lexical member.\n+   This status is meaningful in the implementation of lastprivate.  */\n+#define OMP_SECTION_LAST(NODE) \\\n+  TREE_PRIVATE (OMP_SECTION_CHECK (NODE))\n+\n+/* True on an OMP_RETURN statement if the return does not require a\n+   thread synchronization via some sort of barrier.  The exact barrier\n+   that would otherwise be emitted is dependent on the OMP statement\n+   with which this return is associated.  */\n+#define OMP_RETURN_NOWAIT(NODE) \\\n+  TREE_PRIVATE (OMP_RETURN_CHECK (NODE))\n+\n /* True on a PRIVATE clause if its decl is kept around for debugging\n    information only and its DECL_VALUE_EXPR is supposed to point\n    to what it has been remapped to.  */"}]}