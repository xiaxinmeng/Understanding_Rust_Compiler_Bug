{"sha": "1465e5cf7a5d32d06a5e57488d65d329a461b7b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ2NWU1Y2Y3YTVkMzJkMDZhNWU1NzQ4OGQ2NWQzMjlhNDYxYjdiOQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-10-01T21:40:28Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-10-01T21:40:28Z"}, "message": "tree-ssa-threadupdate.c (struct redirection_data): Delete outgoing_edge and intermediate_edge fields.\n\n       * tree-ssa-threadupdate.c (struct redirection_data): Delete\n        outgoing_edge and intermediate_edge fields.  Instead store the path.\n        (redirection_data::hash): Hash on the last edge's destination index.\n        (redirection_data::equal): Check the entire thread path.\n        (lookup_redirectio_data): Corresponding changes.\n        (create_edge_and_update_destination_phis): Likewise.\n        (thread_single_edge): Likewise.\n\nFrom-SVN: r203091", "tree": {"sha": "b9816573ae96d66cc97d552043eff5cc35160534", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9816573ae96d66cc97d552043eff5cc35160534"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1465e5cf7a5d32d06a5e57488d65d329a461b7b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1465e5cf7a5d32d06a5e57488d65d329a461b7b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1465e5cf7a5d32d06a5e57488d65d329a461b7b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1465e5cf7a5d32d06a5e57488d65d329a461b7b9/comments", "author": null, "committer": null, "parents": [{"sha": "5c0b30218e3264f0c3381024648aec021f6ca161", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c0b30218e3264f0c3381024648aec021f6ca161", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c0b30218e3264f0c3381024648aec021f6ca161"}], "stats": {"total": 71, "additions": 48, "deletions": 23}, "files": [{"sha": "5738af9f21c9a4a4b2d030b5fc1d28ca326c91c7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1465e5cf7a5d32d06a5e57488d65d329a461b7b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1465e5cf7a5d32d06a5e57488d65d329a461b7b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1465e5cf7a5d32d06a5e57488d65d329a461b7b9", "patch": "@@ -1,3 +1,13 @@\n+2013-10-01  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-threadupdate.c (struct redirection_data): Delete\n+\toutgoing_edge and intermediate_edge fields.  Instead store the path.\n+\t(redirection_data::hash): Hash on the last edge's destination index.\n+\t(redirection_data::equal): Check the entire thread path.\n+\t(lookup_redirectio_data): Corresponding changes.\n+\t(create_edge_and_update_destination_phis): Likewise.\n+\t(thread_single_edge): Likewise.\n+\n 2013-10-01  Joern Rennecke  <joern.rennecke@embecosm.com>\n \t    Diego Novillo <dnovillo@google.com>\n "}, {"sha": "2adea1b5119e2e229f23b50a596a30f6e7dfc9f2", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 38, "deletions": 23, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1465e5cf7a5d32d06a5e57488d65d329a461b7b9/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1465e5cf7a5d32d06a5e57488d65d329a461b7b9/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=1465e5cf7a5d32d06a5e57488d65d329a461b7b9", "patch": "@@ -116,14 +116,11 @@ struct redirection_data : typed_free_remove<redirection_data>\n      targets a single successor of B.  */\n   basic_block dup_block;\n \n-  /* An outgoing edge from B.  DUP_BLOCK will have OUTGOING_EDGE->dest as\n-     its single successor.  */\n-  edge outgoing_edge;\n+  /* The jump threading path.  */\n+  vec<jump_thread_edge *> *path;\n \n-  edge intermediate_edge;\n-\n-  /* A list of incoming edges which we want to thread to\n-     OUTGOING_EDGE->dest.  */\n+  /* A list of incoming edges which we want to thread to the\n+     same path.  */\n   struct el *incoming_edges;\n \n   /* hash_table support.  */\n@@ -133,21 +130,36 @@ struct redirection_data : typed_free_remove<redirection_data>\n   static inline int equal (const value_type *, const compare_type *);\n };\n \n+/* Simple hashing function.  For any given incoming edge E, we're going\n+   to be most concerned with the final destination of its jump thread\n+   path.  So hash on the block index of the final edge in the path.  */\n+\n inline hashval_t\n redirection_data::hash (const value_type *p)\n {\n-  edge e = p->outgoing_edge;\n-  return e->dest->index;\n+  vec<jump_thread_edge *> *path = p->path;\n+  return path->last ()->e->dest->index;\n }\n \n+/* Given two hash table entries, return true if they have the same\n+   jump threading path.  */\n inline int\n redirection_data::equal (const value_type *p1, const compare_type *p2)\n {\n-  edge e1 = p1->outgoing_edge;\n-  edge e2 = p2->outgoing_edge;\n-  edge e3 = p1->intermediate_edge;\n-  edge e4 = p2->intermediate_edge;\n-  return e1 == e2 && e3 == e4;\n+  vec<jump_thread_edge *> *path1 = p1->path;\n+  vec<jump_thread_edge *> *path2 = p2->path;\n+\n+  if (path1->length () != path2->length ())\n+    return false;\n+\n+  for (unsigned int i = 1; i < path1->length (); i++)\n+    {\n+      if ((*path1)[i]->type != (*path2)[i]->type\n+\t  || (*path1)[i]->e != (*path2)[i]->e)\n+\treturn false;\n+    }\n+\n+  return true;\n }\n \n /* Data structure of information to pass to hash table traversal routines.  */\n@@ -259,10 +271,7 @@ lookup_redirection_data (edge e, enum insert_option insert)\n  /* Build a hash table element so we can see if E is already\n      in the table.  */\n   elt = XNEW (struct redirection_data);\n-  /* Right now, if we have a joiner, it is always index 1 into the vector.  */\n-  elt->intermediate_edge\n-    = (*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK ? (*path)[1]->e : NULL;\n-  elt->outgoing_edge = path->last ()->e;\n+  elt->path = path;\n   elt->dup_block = NULL;\n   elt->incoming_edges = NULL;\n \n@@ -356,17 +365,17 @@ static void\n create_edge_and_update_destination_phis (struct redirection_data *rd,\n \t\t\t\t\t basic_block bb)\n {\n-  edge e = make_edge (bb, rd->outgoing_edge->dest, EDGE_FALLTHRU);\n+  edge e = make_edge (bb, rd->path->last ()->e->dest, EDGE_FALLTHRU);\n \n   rescan_loop_exit (e, true, false);\n   e->probability = REG_BR_PROB_BASE;\n   e->count = bb->count;\n \n   /* We have to copy path -- which means creating a new vector as well\n      as all the jump_thread_edge entries.  */\n-  if (rd->outgoing_edge->aux)\n+  if (rd->path->last ()->e->aux)\n     {\n-      vec<jump_thread_edge *> *path = THREAD_PATH (rd->outgoing_edge);\n+      vec<jump_thread_edge *> *path = THREAD_PATH (rd->path->last ()->e);\n       vec<jump_thread_edge *> *copy = new vec<jump_thread_edge *> ();\n \n       /* Sadly, the elements of the vector are pointers and need to\n@@ -388,7 +397,7 @@ create_edge_and_update_destination_phis (struct redirection_data *rd,\n      from the duplicate block, then we will need to add a new argument\n      to them.  The argument should have the same value as the argument\n      associated with the outgoing edge stored in RD.  */\n-  copy_phi_args (e->dest, rd->outgoing_edge, e);\n+  copy_phi_args (e->dest, rd->path->last ()->e, e);\n }\n \n /* Wire up the outgoing edges from the duplicate block and\n@@ -787,7 +796,13 @@ thread_single_edge (edge e)\n   if (e->dest == eto->src)\n     update_bb_profile_for_threading (bb, EDGE_FREQUENCY (e), e->count, eto);\n \n-  rd.outgoing_edge = eto;\n+  vec<jump_thread_edge *> *npath = new vec<jump_thread_edge *> ();\n+  jump_thread_edge *x = new jump_thread_edge (e, EDGE_START_JUMP_THREAD);\n+  npath->safe_push (x);\n+\n+  x = new jump_thread_edge (eto, EDGE_COPY_SRC_BLOCK);\n+  npath->safe_push (x);\n+  rd.path = npath;\n \n   create_block_for_threading (bb, &rd);\n   remove_ctrl_stmt_and_useless_edges (rd.dup_block, NULL);"}]}