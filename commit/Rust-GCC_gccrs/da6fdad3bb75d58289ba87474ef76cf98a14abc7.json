{"sha": "da6fdad3bb75d58289ba87474ef76cf98a14abc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE2ZmRhZDNiYjc1ZDU4Mjg5YmE4NzQ3NGVmNzZjZjk4YTE0YWJjNw==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2004-02-21T13:03:40Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2004-02-21T13:03:40Z"}, "message": "combine.c (can_combine_p): Don't ignore SETs marked with REG_EH_REGION notes.\n\n\t* combine.c (can_combine_p): Don't ignore SETs marked with\n\tREG_EH_REGION notes.\n\t(try_combine): When attemting to fix unrecognized insns, don't\n\tsplit a PARALLEL that contains the original i2.\n\nFrom-SVN: r78220", "tree": {"sha": "a55f76ddd963a0afc1cea4f20bcc6ebc34846d31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a55f76ddd963a0afc1cea4f20bcc6ebc34846d31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da6fdad3bb75d58289ba87474ef76cf98a14abc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da6fdad3bb75d58289ba87474ef76cf98a14abc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da6fdad3bb75d58289ba87474ef76cf98a14abc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da6fdad3bb75d58289ba87474ef76cf98a14abc7/comments", "author": null, "committer": null, "parents": [{"sha": "fe932e504bb0efaaa874d1caffdc25e4d34c5484", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe932e504bb0efaaa874d1caffdc25e4d34c5484", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe932e504bb0efaaa874d1caffdc25e4d34c5484"}], "stats": {"total": 28, "additions": 24, "deletions": 4}, "files": [{"sha": "8c3092affc0454a8cf4631a4906caa26ec73655d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da6fdad3bb75d58289ba87474ef76cf98a14abc7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da6fdad3bb75d58289ba87474ef76cf98a14abc7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=da6fdad3bb75d58289ba87474ef76cf98a14abc7", "patch": "@@ -1,3 +1,10 @@\n+2004-02-21  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* combine.c (can_combine_p): Don't ignore SETs marked with\n+\tREG_EH_REGION notes.\n+\t(try_combine): When attemting to fix unrecognized insns, don't\n+\tsplit a PARALLEL that contains the original i2.\n+\n 2004-02-21  Ziemowit Laski  <zlaski@apple.com>\n \n \t* config/darwin.h (TARGET_OPTION_TRANSLATE_TABLE): Refer to"}, {"sha": "55e7ea33047ea7c78569743750988f98d365423a", "filename": "gcc/combine.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da6fdad3bb75d58289ba87474ef76cf98a14abc7/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da6fdad3bb75d58289ba87474ef76cf98a14abc7/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=da6fdad3bb75d58289ba87474ef76cf98a14abc7", "patch": "@@ -960,6 +960,7 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n       for (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n \t{\n \t  rtx elt = XVECEXP (PATTERN (insn), 0, i);\n+\t  rtx note;\n \n \t  switch (GET_CODE (elt))\n \t    {\n@@ -1010,6 +1011,8 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n \t      /* Ignore SETs whose result isn't used but not those that\n \t\t have side-effects.  */\n \t      if (find_reg_note (insn, REG_UNUSED, SET_DEST (elt))\n+\t\t  && (!(note = find_reg_note (insn, REG_EH_REGION, NULL_RTX))\n+\t\t      || INTVAL (XEXP (note, 0)) <= 0)\n \t\t  && ! side_effects_p (elt))\n \t\tbreak;\n \n@@ -2019,11 +2022,21 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n      we just need the first SET.   This can occur when simplifying a divmod\n      insn.  We *must* test for this case here because the code below that\n      splits two independent SETs doesn't handle this case correctly when it\n-     updates the register status.  Also check the case where the first\n-     SET's destination is unused.  That would not cause incorrect code, but\n-     does cause an unneeded insn to remain.  */\n+     updates the register status.\n \n-  if (insn_code_number < 0 && GET_CODE (newpat) == PARALLEL\n+     It's pointless doing this if we originally had two sets, one from\n+     i3, and one from i2.  Combining then splitting the parallel results\n+     in the original i2 again plus an invalid insn (which we delete).\n+     The net effect is only to move instructions around, which makes\n+     debug info less accurate.\n+\n+     Also check the case where the first SET's destination is unused.\n+     That would not cause incorrect code, but does cause an unneeded\n+     insn to remain.  */\n+\n+  if (insn_code_number < 0\n+      && !(added_sets_2 && i1 == 0)\n+      && GET_CODE (newpat) == PARALLEL\n       && XVECLEN (newpat, 0) == 2\n       && GET_CODE (XVECEXP (newpat, 0, 0)) == SET\n       && GET_CODE (XVECEXP (newpat, 0, 1)) == SET"}]}