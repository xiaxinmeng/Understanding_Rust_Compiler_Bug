{"sha": "2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRiMWFiMmQwNGU2YTdhMzE1OTVlZWU2NmIxZTIxNzdjZTNlM2ZjNg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-11-29T17:15:56Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-11-29T17:15:56Z"}, "message": "cp-tree.h (UNIQUELY_DERIVED_FROM_P): Use lookup base.\n\ncp:\n\t* cp-tree.h (UNIQUELY_DERIVED_FROM_P): Use lookup base.\n\t(ACCESSIBLY_UNIQUELY_DERIVED_FROM_P): Likewise.\n\t(PUBLICLY_UNIQUELY_DERIVED_FROM_P: Likewise.\n\t(DERIVED_FROM_P): Likewise.\n\t(enum base_access): Renumber, add ba_quiet bit mask.\n\t(get_binfo): Remove.\n\t(get_base_distance): Remove.\n\t(binfo_value): Remove.\n\t(ACCESSIBLY_DERIVED_FROM_P): Remove.\n\t* call.c (standard_conversion): Use lookup_base.\n\t* class.c (strictly_overrides): Likewise.\n\t(layout_virtual_bases): Likewise.\n\t(warn_about_ambiguous_direct_bases): Likewise.\n\t(is_base_of_enclosing_class): Likewise.\n\t(add_vcall_offset_vtbl_entries_1): Likewise.\n\t* cvt.c (build_up_reference): Adjust comment.\n\t* init.c (build_member_call): Reformat.\n\t* search.c (get_binfo): Remove.\n\t(get_base_distance_recursive): Remove.\n\t(get_base_distance): Remove.\n\t(lookup_base_r): Tweak.\n\t(lookup_base): Add ba_quiet control. Complete the types here.\n\t(covariant_return_p): Use lookup_base.\n\t* tree.c (binfo_value): Remove.\n\t(maybe_dummy_object): Use lookup_base.\n\t* typeck.c (build_static_cast): Use lookup_base.\n\t(get_delta_difference): Likewise.\n\t* typeck2.c (binfo_or_else): Use lookup_base.\n\t(build_scoped_ref): Add back error_mark_check.\n\t(build_m_component_ref): Use lookup_base.\n\nFrom-SVN: r47444", "tree": {"sha": "624478b68ddb523b54c5fed43f98606f42633e04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/624478b68ddb523b54c5fed43f98606f42633e04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6/comments", "author": null, "committer": null, "parents": [{"sha": "298d914f05b115f26f7e40895f273dfa4fcb7388", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/298d914f05b115f26f7e40895f273dfa4fcb7388", "html_url": "https://github.com/Rust-GCC/gccrs/commit/298d914f05b115f26f7e40895f273dfa4fcb7388"}], "stats": {"total": 488, "additions": 138, "deletions": 350}, "files": [{"sha": "029b0e866e5a85f71431d88aa2466b80cca69da5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6", "patch": "@@ -1,3 +1,36 @@\n+2001-11-28  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cp-tree.h (UNIQUELY_DERIVED_FROM_P): Use lookup base.\n+\t(ACCESSIBLY_UNIQUELY_DERIVED_FROM_P): Likewise.\n+\t(PUBLICLY_UNIQUELY_DERIVED_FROM_P: Likewise.\n+\t(DERIVED_FROM_P): Likewise.\n+\t(enum base_access): Renumber, add ba_quiet bit mask.\n+\t(get_binfo): Remove.\n+\t(get_base_distance): Remove.\n+\t(binfo_value): Remove.\n+\t(ACCESSIBLY_DERIVED_FROM_P): Remove.\n+\t* call.c (standard_conversion): Use lookup_base.\n+\t* class.c (strictly_overrides): Likewise.\n+\t(layout_virtual_bases): Likewise.\n+\t(warn_about_ambiguous_direct_bases): Likewise.\n+\t(is_base_of_enclosing_class): Likewise.\n+\t(add_vcall_offset_vtbl_entries_1): Likewise.\n+\t* cvt.c (build_up_reference): Adjust comment.\n+\t* init.c (build_member_call): Reformat.\n+\t* search.c (get_binfo): Remove.\n+\t(get_base_distance_recursive): Remove.\n+\t(get_base_distance): Remove.\n+\t(lookup_base_r): Tweak.\n+\t(lookup_base): Add ba_quiet control. Complete the types here.\n+\t(covariant_return_p): Use lookup_base.\n+\t* tree.c (binfo_value): Remove.\n+\t(maybe_dummy_object): Use lookup_base.\n+\t* typeck.c (build_static_cast): Use lookup_base.\n+\t(get_delta_difference): Likewise.\n+\t* typeck2.c (binfo_or_else): Use lookup_base.\n+\t(build_scoped_ref): Add back error_mark_check.\n+\t(build_m_component_ref): Use lookup_base.\n+\n 2001-11-29  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* Make-lang.in (c++.generated-manpages): New dummy target."}, {"sha": "fc1395ce5ce7ab9cd7f7a5d2e8c8c395891bdf59", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6", "patch": "@@ -787,7 +787,7 @@ standard_conversion (to, from, expr)\n \t{\n \t  tree fbase = TYPE_OFFSET_BASETYPE (TREE_TYPE (from));\n \t  tree tbase = TYPE_OFFSET_BASETYPE (TREE_TYPE (to));\n-\t  tree binfo = get_binfo (fbase, tbase, 1);\n+\t  tree binfo = lookup_base (tbase, fbase, ba_check, NULL);\n \n \t  if (binfo && !binfo_from_vbase (binfo)\n \t      && (same_type_ignoring_top_level_qualifiers_p\n@@ -835,7 +835,7 @@ standard_conversion (to, from, expr)\n       tree tofn = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (to));\n       tree fbase = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (fromfn)));\n       tree tbase = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (tofn)));\n-      tree binfo = get_binfo (fbase, tbase, 1);\n+      tree binfo = lookup_base (tbase, fbase, ba_check, NULL);\n \n       if (!binfo || binfo_from_vbase (binfo)\n \t  || !same_type_p (TREE_TYPE (fromfn), TREE_TYPE (tofn))"}, {"sha": "97a9da49d8c5f4655bb5d6c5b325997a549cd621", "filename": "gcc/cp/class.c", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6", "patch": "@@ -2669,18 +2669,21 @@ modify_all_vtables (t, vfuns_p, overridden_virtuals)\n }\n \n /* Here, we already know that they match in every respect.\n-   All we have to check is where they had their declarations.  */\n+   All we have to check is where they had their declarations.\n+\n+   Return non-zero iff FNDECL1 is declared in a class which has a\n+   proper base class containing FNDECL2.  We don't care about\n+   ambiguity or accessibility.  */\n \n static int \n strictly_overrides (fndecl1, fndecl2)\n      tree fndecl1, fndecl2;\n {\n-  int distance = get_base_distance (DECL_CONTEXT (fndecl2),\n-\t\t\t\t    DECL_CONTEXT (fndecl1),\n-\t\t\t\t    0, (tree *)0);\n-  if (distance == -2 || distance > 0)\n-    return 1;\n-  return 0;\n+  base_kind kind;\n+  \n+  return (lookup_base (DECL_CONTEXT (fndecl1), DECL_CONTEXT (fndecl2),\n+\t\t       ba_ignore | ba_quiet, &kind)\n+\t  && kind != bk_same_type);\n }\n \n /* Get the base virtual function declarations in T that are either\n@@ -4677,7 +4680,7 @@ layout_virtual_bases (t, offsets)\n   /* Now, go through the TYPE_BINFO hierarchy, setting the\n      BINFO_OFFSETs correctly for all non-primary copies of the virtual\n      bases and their direct and indirect bases.  The ambiguity checks\n-     in get_base_distance depend on the BINFO_OFFSETs being set\n+     in lookup_base depend on the BINFO_OFFSETs being set\n      correctly.  */\n   dfs_walk (TYPE_BINFO (t), dfs_set_offset_for_unshared_vbases, NULL, t);\n \n@@ -4703,7 +4706,8 @@ layout_virtual_bases (t, offsets)\n \t vbases = TREE_CHAIN (vbases))\n       {\n \ttree basetype = BINFO_TYPE (TREE_VALUE (vbases));\n-\tif (get_base_distance (basetype, t, 0, (tree*)0) == -2)\n+\t\n+\tif (!lookup_base (t, basetype, ba_ignore | ba_quiet, NULL))\n \t  cp_warning (\"virtual base `%T' inaccessible in `%T' due to ambiguity\",\n \t\t      basetype, t);\n       }\n@@ -4773,7 +4777,7 @@ warn_about_ambiguous_direct_bases (t)\n     {\n       tree basetype = TYPE_BINFO_BASETYPE (t, i);\n \n-      if (get_base_distance (basetype, t, 0, NULL) == -2)\n+      if (!lookup_base (t, basetype, ba_ignore | ba_quiet, NULL))\n \tcp_warning (\"direct base `%T' inaccessible in `%T' due to ambiguity\",\n \t\t    basetype, t);\n     }\n@@ -6385,7 +6389,7 @@ is_base_of_enclosing_class (base, type)\n {\n   while (type)\n     {\n-      if (get_binfo (base, type, 0))\n+      if (lookup_base (type, base, ba_any, NULL))\n \treturn 1;\n \n       type = get_enclosing_class (type);\n@@ -7889,7 +7893,7 @@ add_vcall_offset_vtbl_entries_1 (binfo, vid)\n \t were multiple copies, there would not be a unique final overrider\n \t and vid->derived would be ill-formed.  */\n       base = DECL_CONTEXT (fn);\n-      base_binfo = get_binfo (base, vid->derived, /*protect=*/0);\n+      base_binfo = lookup_base (vid->derived, base, ba_any, NULL);\n \n       /* Compute the vcall offset.  */\n       /* As mentioned above, the vbase we're working on is a primary base of"}, {"sha": "b7cfa7060185b26c9ea07f69edfc436d4c5bd86d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6", "patch": "@@ -1165,13 +1165,17 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n        && IS_AGGR_TYPE (TREE_TYPE (NODE)))\t\\\n    || IS_AGGR_TYPE (NODE))\n \n-/* Nonzero iff TYPE is uniquely derived from PARENT.  Under MI, PARENT can\n-   be an ambiguous base class of TYPE, and this macro will be false.  */\n-#define UNIQUELY_DERIVED_FROM_P(PARENT, TYPE) (get_base_distance (PARENT, TYPE, 0, (tree *)0) >= 0)\n-#define ACCESSIBLY_DERIVED_FROM_P(PARENT, TYPE) (get_base_distance (PARENT, TYPE, -1, (tree *)0) >= 0)\n-#define ACCESSIBLY_UNIQUELY_DERIVED_P(PARENT, TYPE) (get_base_distance (PARENT, TYPE, 1, (tree *)0) >= 0)\n-#define PUBLICLY_UNIQUELY_DERIVED_P(PARENT, TYPE) (get_base_distance (PARENT, TYPE, 2, (tree *)0) >= 0)\n-#define DERIVED_FROM_P(PARENT, TYPE) (get_base_distance (PARENT, TYPE, 0, (tree *)0) != -1)\n+/* Nonzero iff TYPE is derived from PARENT. Ignores accessibility and\n+   ambiguity issues.  */\n+#define DERIVED_FROM_P(PARENT, TYPE) (lookup_base (TYPE, PARENT, ba_any, NULL))\n+/* Nonzero iff TYPE is uniquely derived from PARENT. Ignores\n+   accessibility.  */\n+#define UNIQUELY_DERIVED_FROM_P(PARENT, TYPE) (lookup_base (TYPE, PARENT, ba_ignore | ba_quiet, NULL))\n+/* Nonzero iff TYPE is accessible in the current scope and uniquely\n+   derived from PARENT.  */\n+#define ACCESSIBLY_UNIQUELY_DERIVED_P(PARENT, TYPE) (lookup_base (TYPE, PARENT, ba_check | ba_quiet, NULL))\n+/* Nonzero iff TYPE is publicly & uniquely derived from PARENT.  */\n+#define PUBLICLY_UNIQUELY_DERIVED_P(PARENT, TYPE) (lookup_base (TYPE, PARENT,  ba_not_special | ba_quiet, NULL))\n \f\n /* This structure provides additional information above and beyond\n    what is provide in the ordinary tree_type.  In the past, we used it\n@@ -1551,8 +1555,7 @@ struct lang_type\n    base can be separately marked.  */\n #define BINFO_UNSHARED_MARKED(NODE) TREE_LANG_FLAG_0(NODE)\n \n-/* Nonzero means marked by DFS or BFS search, including searches\n-   by `get_binfo' and `get_base_distance'.  */\n+/* Nonzero means marked by DFS or BFS search.  */\n #define BINFO_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?CLASSTYPE_MARKED(BINFO_TYPE(NODE)):TREE_LANG_FLAG_0(NODE))\n /* Macros needed because of C compilers that don't allow conditional\n    expressions to be lvalues.  Grr!  */\n@@ -3020,16 +3023,17 @@ typedef enum instantiate_type_flags {\n \n /* The kind of checking we can do looking in a class heirarchy. */\n typedef enum base_access {\n-  ba_any = -2,     /* Do not check access, allow an ambiguous base,\n+  ba_any = 0,      /* Do not check access, allow an ambiguous base,\n \t\t      prefer a non-virtual base */\n-  ba_ignore = -1,  /* Do not check access */\n-  ba_check = 0,    /* Check access */\n-  ba_not_special   /* Do not consider special privilege\n-\t\t      current_class_type might give. */\n+  ba_ignore = 1,   /* Do not check access */\n+  ba_check = 2,    /* Check access */\n+  ba_not_special = 3, /* Do not consider special privilege\n+\t\t         current_class_type might give. */\n+  ba_quiet = 4,    /* Do not issue error messages (bit mask).  */\n } base_access;\n \n /* The kind of base we can find, looking in a class heirarchy.\n-   values <0 indicate we failed. */\n+   Values <0 indicate we failed. */\n typedef enum base_kind {\n   bk_inaccessible = -3,   /* The base is inaccessible */\n   bk_ambig = -2,          /* The base is ambiguous */\n@@ -4005,8 +4009,6 @@ extern int emit_tinfo_decl                      PARAMS((tree *, void *));\n extern tree lookup_base PARAMS ((tree, tree, base_access, base_kind *));\n extern int types_overlap_p\t\t\tPARAMS ((tree, tree));\n extern tree get_vbase\t\t\t\tPARAMS ((tree, tree));\n-extern tree get_binfo\t\t\t\tPARAMS ((tree, tree, int));\n-extern int get_base_distance\t\t\tPARAMS ((tree, tree, int, tree *));\n extern tree get_dynamic_cast_base_type          PARAMS ((tree, tree));\n extern void type_access_control\t\t\tPARAMS ((tree, tree));\n extern void skip_type_access_control            PARAMS ((void));\n@@ -4186,7 +4188,6 @@ extern tree hash_tree_cons\t\t\tPARAMS ((tree, tree, tree));\n extern tree hash_tree_chain\t\t\tPARAMS ((tree, tree));\n extern tree hash_chainon\t\t\tPARAMS ((tree, tree));\n extern tree make_binfo\t\t\t\tPARAMS ((tree, tree, tree, tree));\n-extern tree binfo_value\t\t\t\tPARAMS ((tree, tree));\n extern tree reverse_path\t\t\tPARAMS ((tree));\n extern int count_functions\t\t\tPARAMS ((tree));\n extern int is_overloaded_fn\t\t\tPARAMS ((tree));"}, {"sha": "6eb0a7a153be9fcdb47878f1037bafdfd4f59349", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6", "patch": "@@ -401,7 +401,7 @@ build_up_reference (type, arg, flags, decl)\n       && IS_AGGR_TYPE (argtype)\n       && IS_AGGR_TYPE (target_type))\n     {\n-      /* We go through get_binfo for the access control.  */\n+      /* We go through lookup_base for the access control.  */\n       tree binfo = lookup_base (argtype, target_type, ba_check, NULL);\n       if (binfo == error_mark_node)\n \treturn error_mark_node;"}, {"sha": "06c1c43f38a97240c57f873582e77ca4ba0604f5", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6", "patch": "@@ -1473,7 +1473,8 @@ build_member_call (type, name, parmlist)\n       tree ns = lookup_name (type, 0);\n       if (ns && TREE_CODE (ns) == NAMESPACE_DECL)\n \t{\n-\t  return build_x_function_call (build_offset_ref (type, name), parmlist, current_class_ref);\n+\t  return build_x_function_call (build_offset_ref (type, name),\n+\t\t\t\t\tparmlist, current_class_ref);\n \t}\n     }\n "}, {"sha": "6e5e2e5fdc61c2eaea02706741138c301c137170", "filename": "gcc/cp/search.c", "status": "modified", "additions": 33, "deletions": 264, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6", "patch": "@@ -87,12 +87,8 @@ static tree lookup_field_1 PARAMS ((tree, tree));\n static int is_subobject_of_p PARAMS ((tree, tree, tree));\n static tree dfs_check_overlap PARAMS ((tree, void *));\n static tree dfs_no_overlap_yet PARAMS ((tree, void *));\n-static int get_base_distance_recursive\n-\tPARAMS ((tree, int, int, int, int *, tree *, tree,\n-\t       int, int *, int, int));\n static base_kind lookup_base_r\n-\tPARAMS ((tree, tree, base_access,\n-\t\t int, int, int, tree *));\n+\tPARAMS ((tree, tree, base_access, int, int, int, tree *));\n static int dynamic_cast_base_recurse PARAMS ((tree, tree, int, tree *));\n static tree marked_pushdecls_p PARAMS ((tree, void *));\n static tree unmarked_pushdecls_p PARAMS ((tree, void *));\n@@ -171,237 +167,6 @@ static int n_contexts_saved;\n #endif /* GATHER_STATISTICS */\n \n \f\n-/* Check whether the type given in BINFO is derived from PARENT.  If\n-   it isn't, return 0.  If it is, but the derivation is MI-ambiguous\n-   AND protect != 0, emit an error message and return error_mark_node.\n-\n-   Otherwise, if TYPE is derived from PARENT, return the actual base\n-   information, unless a one of the protection violations below\n-   occurs, in which case emit an error message and return error_mark_node.\n-\n-   If PROTECT is 1, then check if access to a public field of PARENT\n-   would be private.  Also check for ambiguity.  */\n-\n-tree\n-get_binfo (parent, binfo, protect)\n-     register tree parent, binfo;\n-     int protect;\n-{\n-  tree type = NULL_TREE;\n-  int dist;\n-  tree rval = NULL_TREE;\n-  \n-  if (TREE_CODE (parent) == TREE_VEC)\n-    parent = BINFO_TYPE (parent);\n-  else if (! IS_AGGR_TYPE_CODE (TREE_CODE (parent)))\n-    my_friendly_abort (89);\n-\n-  if (TREE_CODE (binfo) == TREE_VEC)\n-    type = BINFO_TYPE (binfo);\n-  else if (IS_AGGR_TYPE_CODE (TREE_CODE (binfo)))\n-    type = binfo;\n-  else\n-    my_friendly_abort (90);\n-  \n-  dist = get_base_distance (parent, binfo, protect, &rval);\n-\n-  if (dist == -3)\n-    {\n-      cp_error (\"fields of `%T' are inaccessible in `%T' due to private inheritance\",\n-\t\tparent, type);\n-      return error_mark_node;\n-    }\n-  else if (dist == -2 && protect)\n-    {\n-      cp_error (\"type `%T' is ambiguous base class for type `%T'\", parent,\n-\t\ttype);\n-      return error_mark_node;\n-    }\n-\n-  return rval;\n-}\n-\n-/* This is the newer depth first get_base_distance routine.  */\n-\n-static int\n-get_base_distance_recursive (binfo, depth, is_private, rval,\n-\t\t\t     rval_private_ptr, new_binfo_ptr, parent,\n-\t\t\t     protect, via_virtual_ptr, via_virtual,\n-\t\t\t     current_scope_in_chain)\n-     tree binfo;\n-     int depth, is_private, rval;\n-     int *rval_private_ptr;\n-     tree *new_binfo_ptr, parent;\n-     int protect, *via_virtual_ptr, via_virtual;\n-     int current_scope_in_chain;\n-{\n-  tree binfos;\n-  int i, n_baselinks;\n-\n-  if (protect == 1\n-      && !current_scope_in_chain\n-      && is_friend (BINFO_TYPE (binfo), current_scope ()))\n-    current_scope_in_chain = 1;\n-\n-  if (BINFO_TYPE (binfo) == parent || binfo == parent)\n-    {\n-      int better = 0;\n-\n-      if (rval == -1)\n-\t/* This is the first time we've found parent.  */\n-\tbetter = 1;\n-      else if (tree_int_cst_equal (BINFO_OFFSET (*new_binfo_ptr),\n-\t\t\t\t   BINFO_OFFSET (binfo))\n-\t       && *via_virtual_ptr && via_virtual)\n-\t{\n-\t  /* A new path to the same vbase.  If this one has better\n-\t     access or is shorter, take it.  */\n-\n-\t  if (protect)\n-\t    better = *rval_private_ptr - is_private;\n-\t  if (better == 0)\n-\t    better = rval - depth;\n-\t}\n-      else\n-\t{\n-\t  /* Ambiguous base class.  */\n-\t  rval = depth = -2;\n-\n-\t  /* If we get an ambiguity between virtual and non-virtual base\n-\t     class, return the non-virtual in case we are ignoring\n-\t     ambiguity.  */\n-\t  better = *via_virtual_ptr - via_virtual;\n-\t}\n-\n-      if (better > 0)\n-\t{\n-\t  rval = depth;\n-\t  *rval_private_ptr = is_private;\n-\t  *new_binfo_ptr = binfo;\n-\t  *via_virtual_ptr = via_virtual;\n-\t}\n-\n-      return rval;\n-    }\n-\n-  binfos = BINFO_BASETYPES (binfo);\n-  n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-  depth += 1;\n-\n-  /* Process base types.  */\n-  for (i = 0; i < n_baselinks; i++)\n-    {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-\n-      int via_private\n-\t= ((protect == 1\n-\t    && (is_private\n-\t\t|| (!TREE_VIA_PUBLIC (base_binfo)\n-\t\t    && !(TREE_VIA_PROTECTED (base_binfo)\n-\t\t\t && current_scope_in_chain)\n-\t\t    && !is_friend (BINFO_TYPE (binfo), current_scope ()))))\n-\t   || (protect > 1\n-\t       && (is_private || !TREE_VIA_PUBLIC (base_binfo))));\n-\n-      int this_virtual = via_virtual || TREE_VIA_VIRTUAL (base_binfo);\n-\n-      rval = get_base_distance_recursive (base_binfo, depth, via_private,\n-\t\t\t\t\t  rval, rval_private_ptr,\n-\t\t\t\t\t  new_binfo_ptr, parent,\n-\t\t\t\t\t  protect, via_virtual_ptr,\n-\t\t\t\t\t  this_virtual,\n-\t\t\t\t\t  current_scope_in_chain);\n-\n-      /* If we've found a non-virtual, ambiguous base class, we don't need\n-\t to keep searching.  */\n-      if (rval == -2 && *via_virtual_ptr == 0)\n-\treturn rval;\n-    }\n-\n-  return rval;\n-}\n-\n-/* Return the number of levels between type PARENT and the type given\n-   in BINFO, following the leftmost path to PARENT not found along a\n-   virtual path, if there are no real PARENTs (all come from virtual\n-   base classes), then follow the shortest public path to PARENT.\n-\n-   Return -1 if TYPE is not derived from PARENT.\n-   Return -2 if PARENT is an ambiguous base class of TYPE, and PROTECT is\n-    non-negative.\n-   Return -3 if PARENT is not accessible in TYPE, and PROTECT is non-zero.\n-\n-   If PATH_PTR is non-NULL, then also build the list of types\n-   from PARENT to TYPE, with TREE_VIA_VIRTUAL and TREE_VIA_PUBLIC\n-   set.\n-\n-   If PROTECT is greater than 1, ignore any special access the current\n-   scope might have when determining whether PARENT is inaccessible.\n-\n-   If BINFO is a binfo, its BINFO_INHERITANCE_CHAIN will be left alone.  */\n-\n-int\n-get_base_distance (parent, binfo, protect, path_ptr)\n-     register tree parent, binfo;\n-     int protect;\n-     tree *path_ptr;\n-{\n-  int rval;\n-  int rval_private = 0;\n-  tree type = NULL_TREE;\n-  tree new_binfo = NULL_TREE;\n-  int via_virtual;\n-  int watch_access = protect;\n-\n-  /* Should we be completing types here?  */\n-  if (TREE_CODE (parent) != TREE_VEC)\n-    parent = complete_type (TYPE_MAIN_VARIANT (parent));\n-  else\n-    complete_type (TREE_TYPE (parent));\n-\n-  if (TREE_CODE (binfo) == TREE_VEC)\n-    type = BINFO_TYPE (binfo);\n-  else if (IS_AGGR_TYPE_CODE (TREE_CODE (binfo)))\n-    {\n-      type = complete_type (binfo);\n-      binfo = TYPE_BINFO (type);\n-\n-      if (path_ptr)\n-\tmy_friendly_assert (BINFO_INHERITANCE_CHAIN (binfo) == NULL_TREE,\n-\t\t\t    980827);\n-    }\n-  else\n-    my_friendly_abort (92);\n-\n-  if (parent == type || parent == binfo)\n-    {\n-      /* If the distance is 0, then we don't really need\n-\t a path pointer, but we shouldn't let garbage go back.  */\n-      if (path_ptr)\n-\t*path_ptr = binfo;\n-      return 0;\n-    }\n-\n-  if (path_ptr && watch_access == 0)\n-    watch_access = 1;\n-\n-  rval = get_base_distance_recursive (binfo, 0, 0, -1,\n-\t\t\t\t      &rval_private, &new_binfo, parent,\n-\t\t\t\t      watch_access, &via_virtual, 0,\n-\t\t\t\t      0);\n-\n-  /* Access restrictions don't count if we found an ambiguous basetype.  */\n-  if (rval == -2 && protect >= 0)\n-    rval_private = 0;\n-\n-  if (rval && protect && rval_private)\n-    return -3;\n-\n-  if (path_ptr)\n-    *path_ptr = new_binfo;\n-  return rval;\n-}\n-\n /* Worker for lookup_base.  BINFO is the binfo we are searching at,\n    BASE is the RECORD_TYPE we are searching for.  ACCESS is the\n    required access checks.  WITHIN_CURRENT_SCOPE, IS_NON_PUBLIC and\n@@ -457,13 +222,11 @@ lookup_base_r (binfo, base, access, within_current_scope,\n \t{\n \t  if (access != ba_any)\n \t    *binfo_ptr = NULL;\n-\t  else if (found != is_virtual)\n+\t  else if (!is_virtual)\n \t    /* Prefer a non-virtual base.  */\n \t    *binfo_ptr = binfo;\n \t  found = bk_ambig;\n \t}\n-      else if (found == bk_via_virtual)\n-\t*binfo_ptr = binfo;\n       \n       return found;\n     }\n@@ -525,10 +288,8 @@ lookup_base_r (binfo, base, access, within_current_scope,\n \t  break;\n \t  \n \tcase bk_via_virtual:\n-\t  my_friendly_assert (found == bk_not_base\n-\t\t\t      || found == bk_via_virtual\n-\t\t\t      || found == bk_inaccessible, 20010723);\n-\t  found = bk;\n+\t  if (found != bk_ambig)\n+\t    found = bk;\n \t  break;\n \t  \n \tcase bk_not_base:\n@@ -541,10 +302,10 @@ lookup_base_r (binfo, base, access, within_current_scope,\n /* Lookup BASE in the hierarchy dominated by T.  Do access checking as\n    ACCESS specifies.  Return the binfo we discover (which might not be\n    canonical).  If KIND_PTR is non-NULL, fill with information about\n-   what kind of base we discoveded.\n+   what kind of base we discovered.\n \n-   Issue an error message if an inaccessible or ambiguous base is\n-   discovered, and return error_mark_node. */\n+   If ba_quiet bit is set in ACCESS, then do not issue an error, and\n+   return NULL_TREE for failure.  */\n \n tree\n lookup_base (t, base, access, kind_ptr)\n@@ -554,33 +315,43 @@ lookup_base (t, base, access, kind_ptr)\n {\n   tree binfo = NULL;\t\t/* The binfo we've found so far. */\n   base_kind bk;\n-\n+  \n   if (t == error_mark_node || base == error_mark_node)\n     {\n       if (kind_ptr)\n \t*kind_ptr = bk_not_base;\n       return error_mark_node;\n     }\n+  my_friendly_assert (TYPE_P (t) && TYPE_P (base), 20011127);\n   \n-  t = TYPE_MAIN_VARIANT (t);\n-  base = TYPE_MAIN_VARIANT (base);\n+  /* Ensure that the types are instantiated.  */\n+  t = complete_type (TYPE_MAIN_VARIANT (t));\n+  base = complete_type (TYPE_MAIN_VARIANT (base));\n   \n-  bk = lookup_base_r (TYPE_BINFO (t), base, access, 0, 0, 0, &binfo);\n+  bk = lookup_base_r (TYPE_BINFO (t), base, access & ~ba_quiet,\n+\t\t      0, 0, 0, &binfo);\n \n   switch (bk)\n     {\n     case bk_inaccessible:\n-      cp_error (\"`%T' is an inaccessible base of `%T'\", base, t);\n-      binfo = error_mark_node;\n+      binfo = NULL_TREE;\n+      if (!(access & ba_quiet))\n+\t{\n+\t  cp_error (\"`%T' is an inaccessible base of `%T'\", base, t);\n+\t  binfo = error_mark_node;\n+\t}\n       break;\n     case bk_ambig:\n       if (access != ba_any)\n \t{\n-\t  cp_error (\"`%T' is an ambiguous base of `%T'\", base, t);\n-\t  binfo = error_mark_node;\n+\t  binfo = NULL_TREE;\n+\t  if (!(access & ba_quiet))\n+\t    {\n+\t      cp_error (\"`%T' is an ambiguous base of `%T'\", base, t);\n+\t      binfo = error_mark_node;\n+\t    }\n \t}\n       break;\n-      \n     default:;\n     }\n   \n@@ -1991,6 +1762,7 @@ covariant_return_p (brettype, drettype)\n      tree brettype, drettype;\n {\n   tree binfo;\n+  base_kind kind;\n \n   if (TREE_CODE (brettype) == FUNCTION_DECL)\n     {\n@@ -2022,16 +1794,13 @@ covariant_return_p (brettype, drettype)\n   if (! IS_AGGR_TYPE (drettype) || ! IS_AGGR_TYPE (brettype))\n     return -1;\n \n-  binfo = get_binfo (brettype, drettype, 1);\n-\n-  /* If we get an error_mark_node from get_binfo, it already complained,\n-     so let's just succeed.  */\n-  if (binfo == error_mark_node)\n+  binfo = lookup_base (drettype, brettype, ba_check | ba_quiet, &kind);\n+  \n+  if (!binfo)\n+    return 0;\n+  if (BINFO_OFFSET_ZEROP (binfo) && kind != bk_via_virtual)\n     return 1;\n-\n-  if (! BINFO_OFFSET_ZEROP (binfo) || TREE_VIA_VIRTUAL (binfo))\n-    return 2;\n-  return 1;\n+  return 2;\n }\n \n /* Check that virtual overrider OVERRIDER is acceptable for base function"}, {"sha": "99d2eab4fd9aeb4349f2f6c592e5c6307d49258f", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6", "patch": "@@ -827,23 +827,6 @@ make_binfo (offset, binfo, vtable, virtuals)\n   return new_binfo;\n }\n \n-/* Return the binfo value for ELEM in TYPE.  */\n-\n-tree\n-binfo_value (elem, type)\n-     tree elem;\n-     tree type;\n-{\n-  if (get_base_distance (elem, type, 0, (tree *)0) == -2)\n-    compiler_error (\"base class `%s' ambiguous in binfo_value\",\n-\t\t    TYPE_NAME_STRING (elem));\n-  if (elem == type)\n-    return TYPE_BINFO (type);\n-  if (TREE_CODE (elem) == RECORD_TYPE && TYPE_BINFO (elem) == type)\n-    return type;\n-  return get_binfo (elem, type, 0);\n-}\n-\n /* Return a TREE_LIST whose TREE_VALUE nodes along the\n    BINFO_INHERITANCE_CHAIN for BINFO, but in the opposite order.  In\n    other words, while the BINFO_INHERITANCE_CHAIN goes from base\n@@ -1833,18 +1816,22 @@ maybe_dummy_object (type, binfop)\n      tree *binfop;\n {\n   tree decl, context;\n-\n+  tree binfo;\n+  \n   if (current_class_type\n-      && get_base_distance (type, current_class_type, 0, binfop) != -1)\n+      && (binfo = lookup_base (current_class_type, type,\n+\t\t\t       ba_ignore | ba_quiet, NULL)))\n     context = current_class_type;\n   else\n     {\n       /* Reference from a nested class member function.  */\n       context = type;\n-      if (binfop)\n-\t*binfop = TYPE_BINFO (type);\n+      binfo = TYPE_BINFO (type);\n     }\n \n+  if (binfop)\n+    *binfop = binfo;\n+  \n   if (current_class_ref && context == current_class_type)\n     decl = current_class_ref;\n   else"}, {"sha": "c3d888c5a1827d76c1feceb5c189235f8303e6e2", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6", "patch": "@@ -5114,12 +5114,12 @@ build_static_cast (type, expr)\n     {\n       /* They're pointers to objects. They must be aggregates that\n          are related non-virtually. */\n-      \n-      tree binfo;\n+      base_kind kind;\n       \n       if (IS_AGGR_TYPE (TREE_TYPE (type)) && IS_AGGR_TYPE (TREE_TYPE (intype))\n-\t  && (binfo = get_binfo (TREE_TYPE (intype), TREE_TYPE (type), 0))\n-\t  && !binfo_from_vbase (binfo))\n+\t  && lookup_base (TREE_TYPE (type), TREE_TYPE (intype),\n+\t\t\t  ba_ignore | ba_quiet, &kind)\n+\t  && kind != bk_via_virtual)\n \tok = 1;\n     }\n   else if (TREE_CODE (intype) != BOOLEAN_TYPE\n@@ -5933,30 +5933,24 @@ get_delta_difference (from, to, force)\n   tree delta = integer_zero_node;\n   tree binfo;\n   tree virt_binfo;\n+  base_kind kind;\n   \n-  if (to == from)\n-    return delta;\n-\n-  /* Should get_base_distance here, so we can check if any thing along\n-     the path is virtual, and we need to make sure we stay inside the\n-     real binfos when going through virtual bases.  Maybe we should\n-     replace virtual bases with BINFO_FOR_VBASE ... (mrs) */\n-  binfo = get_binfo (from, to, 1);\n-  if (binfo == error_mark_node)\n+  binfo = lookup_base (to, from, ba_check, &kind);\n+  if (kind == bk_inaccessible || kind == bk_ambig)\n     {\n       error (\"   in pointer to member function conversion\");\n       return delta;\n     }\n-  if (binfo == 0)\n+  if (!binfo)\n     {\n       if (!force)\n \t{\n \t  error_not_base_type (from, to);\n \t  error (\"   in pointer to member conversion\");\n \t  return delta;\n \t}\n-      binfo = get_binfo (to, from, 1);\n-      if (binfo == 0 || binfo == error_mark_node)\n+      binfo = lookup_base (from, to, ba_check, &kind);\n+      if (binfo == 0)\n \treturn delta;\n       virt_binfo = binfo_from_vbase (binfo);\n       "}, {"sha": "37252ee0bbe1999daeba57b307ff02b7cc8d82b3", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=2db1ab2d04e6a7a31595eee66b1e2177ce3e3fc6", "patch": "@@ -56,20 +56,16 @@ error_not_base_type (basetype, type)\n }\n \n tree\n-binfo_or_else (parent_or_type, type)\n-     tree parent_or_type, type;\n+binfo_or_else (base, type)\n+     tree base, type;\n {\n-  tree binfo;\n-  if (TYPE_MAIN_VARIANT (parent_or_type) == TYPE_MAIN_VARIANT (type))\n-    return TYPE_BINFO (parent_or_type);\n-  if ((binfo = get_binfo (parent_or_type, TYPE_MAIN_VARIANT (type), 0)))\n-    {\n-      if (binfo == error_mark_node)\n-\treturn NULL_TREE;\n-      return binfo;\n-    }\n-  error_not_base_type (parent_or_type, type);\n-  return NULL_TREE;\n+  tree binfo = lookup_base (type, base, ba_ignore, NULL);\n+\n+  if (binfo == error_mark_node)\n+    return NULL_TREE;\n+  else if (!binfo)\n+    error_not_base_type (base, type);\n+  return binfo;\n }\n \n /* According to ARM $7.1.6, \"A `const' object may be initialized, but its\n@@ -1003,6 +999,8 @@ build_scoped_ref (datum, basetype)\n     return error_mark_node;\n   binfo = lookup_base (TREE_TYPE (datum), basetype, ba_check, NULL);\n \n+  if (binfo == error_mark_node)\n+    return error_mark_node;\n   if (!binfo)\n     return error_not_base_type (TREE_TYPE (datum), basetype);\n   \n@@ -1145,8 +1143,9 @@ build_m_component_ref (datum, component)\n       return error_mark_node;\n     }\n \n-  binfo = get_binfo (TYPE_METHOD_BASETYPE (type), objtype, 1);\n-  if (binfo == NULL_TREE)\n+  binfo = lookup_base (objtype, TYPE_METHOD_BASETYPE (type),\n+\t\t       ba_check, NULL);\n+  if (!binfo)\n     {\n       cp_error (\"member type `%T::' incompatible with object type `%T'\",\n \t\tTYPE_METHOD_BASETYPE (type), objtype);"}]}