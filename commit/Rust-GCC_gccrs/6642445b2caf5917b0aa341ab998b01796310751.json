{"sha": "6642445b2caf5917b0aa341ab998b01796310751", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY0MjQ0NWIyY2FmNTkxN2IwYWEzNDFhYjk5OGIwMTc5NjMxMDc1MQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2010-07-12T18:53:25Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2010-07-12T18:53:25Z"}, "message": "hard-reg-set.h (target_hard_regs): New structure.\n\ngcc/\n\t* hard-reg-set.h (target_hard_regs): New structure.\n\t(default_target_hard_regs): Declare.\n\t(this_target_hard_regs): Declare as a variable or define as a macro.\n\t(fixed_regs, fixed_reg_set, call_used_regs, call_really_used_regs)\n\t(call_used_reg_set, call_fixed_reg_set, regs_invalidated_by_call)\n\t(reg_alloc_order, inv_reg_alloc_order, reg_class_contents)\n\t(reg_class_size, reg_class_subclasses, reg_class_subunion)\n\t(reg_class_superunion, reg_names): Redefine as macros.\n\t* reginfo.c (fixed_regs, fixed_reg_set, call_used_regs)\n\t(call_used_reg_set, call_really_used_regs, call_fixed_reg_set)\n\t(regs_invalidated_by_call, reg_alloc_order, inv_reg_alloc_order)\n\t(reg_class_contents, reg_class_size, reg_class_subclasses)\n\t(reg_class_subunion, reg_class_superunion, reg_names): Delete.\n\t(default_target_hard_regs): New variable\n\t(this_target_hard_regs, initial_call_really_used_regs)\n\t(initial_reg_alloc_order): New conditional variables.\n\t(initial_reg_names): New variable.\n\t(init_reg_sets): Assert that initial_call_really_used_regs,\n\tinitial_reg_alloc_order and initial_reg_names\n\tare all the same size as their variable counterparts.  Use them to\n\tinitialize those counterparts.\n\t* target-globals.h (this_target_hard_regs): Declare.\n\t(target_globals): Add a hard_regs field.\n\t(restore_target_globals): Copy the hard_regs field to\n\tthis_target_hard_regs.\n\t* target-globals.c: Include hard-reg-set.h.\n\t(default_target_globals): Initialize the hard_regs field.\n\t(save_target_globals): Likewise.\n\nFrom-SVN: r162089", "tree": {"sha": "ede7c51733a098412f5ed16fc7ef5a103c40df67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ede7c51733a098412f5ed16fc7ef5a103c40df67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6642445b2caf5917b0aa341ab998b01796310751", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6642445b2caf5917b0aa341ab998b01796310751", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6642445b2caf5917b0aa341ab998b01796310751", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6642445b2caf5917b0aa341ab998b01796310751/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5fb0e246f4d16dd1f341cc34ded11eb4813fe50d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fb0e246f4d16dd1f341cc34ded11eb4813fe50d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fb0e246f4d16dd1f341cc34ded11eb4813fe50d"}], "stats": {"total": 289, "additions": 152, "deletions": 137}, "files": [{"sha": "ce599e4a5815973e84560394ec64983ea43b01f7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6642445b2caf5917b0aa341ab998b01796310751/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6642445b2caf5917b0aa341ab998b01796310751/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6642445b2caf5917b0aa341ab998b01796310751", "patch": "@@ -1,3 +1,34 @@\n+2010-07-12  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* hard-reg-set.h (target_hard_regs): New structure.\n+\t(default_target_hard_regs): Declare.\n+\t(this_target_hard_regs): Declare as a variable or define as a macro.\n+\t(fixed_regs, fixed_reg_set, call_used_regs, call_really_used_regs)\n+\t(call_used_reg_set, call_fixed_reg_set, regs_invalidated_by_call)\n+\t(reg_alloc_order, inv_reg_alloc_order, reg_class_contents)\n+\t(reg_class_size, reg_class_subclasses, reg_class_subunion)\n+\t(reg_class_superunion, reg_names): Redefine as macros.\n+\t* reginfo.c (fixed_regs, fixed_reg_set, call_used_regs)\n+\t(call_used_reg_set, call_really_used_regs, call_fixed_reg_set)\n+\t(regs_invalidated_by_call, reg_alloc_order, inv_reg_alloc_order)\n+\t(reg_class_contents, reg_class_size, reg_class_subclasses)\n+\t(reg_class_subunion, reg_class_superunion, reg_names): Delete.\n+\t(default_target_hard_regs): New variable\n+\t(this_target_hard_regs, initial_call_really_used_regs)\n+\t(initial_reg_alloc_order): New conditional variables.\n+\t(initial_reg_names): New variable.\n+\t(init_reg_sets): Assert that initial_call_really_used_regs,\n+\tinitial_reg_alloc_order and initial_reg_names\n+\tare all the same size as their variable counterparts.  Use them to\n+\tinitialize those counterparts.\n+\t* target-globals.h (this_target_hard_regs): Declare.\n+\t(target_globals): Add a hard_regs field.\n+\t(restore_target_globals): Copy the hard_regs field to\n+\tthis_target_hard_regs.\n+\t* target-globals.c: Include hard-reg-set.h.\n+\t(default_target_globals): Initialize the hard_regs field.\n+\t(save_target_globals): Likewise.\n+\n 2010-07-12  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* Makefile.in (target-globals.o): Depend on $(RTL_H)."}, {"sha": "c0379b3bea72a93557beff6ed6daae04d8256f6a", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 89, "deletions": 65, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6642445b2caf5917b0aa341ab998b01796310751/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6642445b2caf5917b0aa341ab998b01796310751/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=6642445b2caf5917b0aa341ab998b01796310751", "patch": "@@ -575,99 +575,123 @@ hard_reg_set_iter_next (hard_reg_set_iterator *iter, unsigned *regno)\n \n /* Define some standard sets of registers.  */\n \n-/* Indexed by hard register number, contains 1 for registers\n-   that are fixed use (stack pointer, pc, frame pointer, etc.).\n-   These are the registers that cannot be used to allocate\n-   a pseudo reg whose life does not cross calls.  */\n-\n-extern char fixed_regs[FIRST_PSEUDO_REGISTER];\n-\n-/* The same info as a HARD_REG_SET.  */\n-\n-extern HARD_REG_SET fixed_reg_set;\n-\n-/* Indexed by hard register number, contains 1 for registers\n-   that are fixed use or are clobbered by function calls.\n-   These are the registers that cannot be used to allocate\n-   a pseudo reg whose life crosses calls.  */\n-\n-extern char call_used_regs[FIRST_PSEUDO_REGISTER];\n-\n-#ifdef CALL_REALLY_USED_REGISTERS\n-extern char call_really_used_regs[];\n-#endif\n-\n-/* The same info as a HARD_REG_SET.  */\n-\n-extern HARD_REG_SET call_used_reg_set;\n-\n-/* Contains registers that are fixed use -- i.e. in fixed_reg_set -- or\n-   a function value return register or TARGET_STRUCT_VALUE_RTX or\n-   STATIC_CHAIN_REGNUM.  These are the registers that cannot hold quantities\n-   across calls even if we are willing to save and restore them.  */\n-\n-extern HARD_REG_SET call_fixed_reg_set;\n-\n /* Indexed by hard register number, contains 1 for registers\n    that are being used for global register decls.\n    These must be exempt from ordinary flow analysis\n    and are also considered fixed.  */\n \n extern char global_regs[FIRST_PSEUDO_REGISTER];\n \n-/* Contains 1 for registers that are set or clobbered by calls.  */\n-/* ??? Ideally, this would be just call_used_regs plus global_regs, but\n-   for someone's bright idea to have call_used_regs strictly include\n-   fixed_regs.  Which leaves us guessing as to the set of fixed_regs\n-   that are actually preserved.  We know for sure that those associated\n-   with the local stack frame are safe, but scant others.  */\n-\n-extern HARD_REG_SET regs_invalidated_by_call;\n-\n /* Call used hard registers which can not be saved because there is no\n    insn for this.  */\n \n extern HARD_REG_SET no_caller_save_reg_set;\n \n-#ifdef REG_ALLOC_ORDER\n-/* Table of register numbers in the order in which to try to use them.  */\n+struct target_hard_regs {\n+  /* Indexed by hard register number, contains 1 for registers\n+     that are fixed use (stack pointer, pc, frame pointer, etc.;.\n+     These are the registers that cannot be used to allocate\n+     a pseudo reg whose life does not cross calls.  */\n+  char x_fixed_regs[FIRST_PSEUDO_REGISTER];\n \n-extern int reg_alloc_order[FIRST_PSEUDO_REGISTER];\n+  /* The same info as a HARD_REG_SET.  */\n+  HARD_REG_SET x_fixed_reg_set;\n \n-/* The inverse of reg_alloc_order.  */\n+  /* Indexed by hard register number, contains 1 for registers\n+     that are fixed use or are clobbered by function calls.\n+     These are the registers that cannot be used to allocate\n+     a pseudo reg whose life crosses calls.  */\n+  char x_call_used_regs[FIRST_PSEUDO_REGISTER];\n \n-extern int inv_reg_alloc_order[FIRST_PSEUDO_REGISTER];\n-#endif\n+  char x_call_really_used_regs[FIRST_PSEUDO_REGISTER];\n+\n+  /* The same info as a HARD_REG_SET.  */\n+  HARD_REG_SET x_call_used_reg_set;\n \n-/* For each reg class, a HARD_REG_SET saying which registers are in it.  */\n+  /* Contains registers that are fixed use -- i.e. in fixed_reg_set -- or\n+     a function value return register or TARGET_STRUCT_VALUE_RTX or\n+     STATIC_CHAIN_REGNUM.  These are the registers that cannot hold quantities\n+     across calls even if we are willing to save and restore them.  */\n+  HARD_REG_SET x_call_fixed_reg_set;\n \n-extern HARD_REG_SET reg_class_contents[N_REG_CLASSES];\n+  /* Contains 1 for registers that are set or clobbered by calls.  */\n+  /* ??? Ideally, this would be just call_used_regs plus global_regs, but\n+     for someone's bright idea to have call_used_regs strictly include\n+     fixed_regs.  Which leaves us guessing as to the set of fixed_regs\n+     that are actually preserved.  We know for sure that those associated\n+     with the local stack frame are safe, but scant others.  */\n+  HARD_REG_SET x_regs_invalidated_by_call;\n \n-/* For each reg class, a boolean saying whether the class contains only\n-   fixed registers.  */\n-extern bool class_only_fixed_regs[N_REG_CLASSES];\n+  /* Table of register numbers in the order in which to try to use them.  */\n+  int x_reg_alloc_order[FIRST_PSEUDO_REGISTER];\n \n-/* For each reg class, number of regs it contains.  */\n+  /* The inverse of reg_alloc_order.  */\n+  int x_inv_reg_alloc_order[FIRST_PSEUDO_REGISTER];\n \n-extern unsigned int reg_class_size[N_REG_CLASSES];\n+  /* For each reg class, a HARD_REG_SET saying which registers are in it.  */\n+  HARD_REG_SET x_reg_class_contents[N_REG_CLASSES];\n \n-/* For each reg class, table listing all the classes contained in it.  */\n+  /* For each reg class, a boolean saying whether the class contains only\n+     fixed registers.  */\n+  bool x_class_only_fixed_regs[N_REG_CLASSES];\n \n-extern enum reg_class reg_class_subclasses[N_REG_CLASSES][N_REG_CLASSES];\n+  /* For each reg class, number of regs it contains.  */\n+  unsigned int x_reg_class_size[N_REG_CLASSES];\n \n-/* For each pair of reg classes,\n-   a largest reg class contained in their union.  */\n+  /* For each reg class, table listing all the classes contained in it.  */\n+  enum reg_class x_reg_class_subclasses[N_REG_CLASSES][N_REG_CLASSES];\n \n-extern enum reg_class reg_class_subunion[N_REG_CLASSES][N_REG_CLASSES];\n+  /* For each pair of reg classes,\n+     a largest reg class contained in their union.  */\n+  enum reg_class x_reg_class_subunion[N_REG_CLASSES][N_REG_CLASSES];\n \n-/* For each pair of reg classes,\n-   the smallest reg class that contains their union.  */\n+  /* For each pair of reg classes,\n+     the smallest reg class that contains their union.  */\n+  enum reg_class x_reg_class_superunion[N_REG_CLASSES][N_REG_CLASSES];\n \n-extern enum reg_class reg_class_superunion[N_REG_CLASSES][N_REG_CLASSES];\n+  /* Vector indexed by hardware reg giving its name.  */\n+  const char *x_reg_names[FIRST_PSEUDO_REGISTER];\n+};\n \n-/* Vector indexed by hardware reg giving its name.  */\n+extern struct target_hard_regs default_target_hard_regs;\n+#if SWITCHABLE_TARGET\n+extern struct target_hard_regs *this_target_hard_regs;\n+#else\n+#define this_target_hard_regs (&default_target_hard_regs)\n+#endif\n \n-extern const char * reg_names[FIRST_PSEUDO_REGISTER];\n+#define fixed_regs \\\n+  (this_target_hard_regs->x_fixed_regs)\n+#define fixed_reg_set \\\n+  (this_target_hard_regs->x_fixed_reg_set)\n+#define call_used_regs \\\n+  (this_target_hard_regs->x_call_used_regs)\n+#define call_really_used_regs \\\n+  (this_target_hard_regs->x_call_really_used_regs)\n+#define call_used_reg_set \\\n+  (this_target_hard_regs->x_call_used_reg_set)\n+#define call_fixed_reg_set \\\n+  (this_target_hard_regs->x_call_fixed_reg_set)\n+#define regs_invalidated_by_call \\\n+  (this_target_hard_regs->x_regs_invalidated_by_call)\n+#define reg_alloc_order \\\n+  (this_target_hard_regs->x_reg_alloc_order)\n+#define inv_reg_alloc_order \\\n+  (this_target_hard_regs->x_inv_reg_alloc_order)\n+#define reg_class_contents \\\n+  (this_target_hard_regs->x_reg_class_contents)\n+#define class_only_fixed_regs \\\n+  (this_target_hard_regs->x_class_only_fixed_regs)\n+#define reg_class_size \\\n+  (this_target_hard_regs->x_reg_class_size)\n+#define reg_class_subclasses \\\n+  (this_target_hard_regs->x_reg_class_subclasses)\n+#define reg_class_subunion \\\n+  (this_target_hard_regs->x_reg_class_subunion)\n+#define reg_class_superunion \\\n+  (this_target_hard_regs->x_reg_class_superunion)\n+#define reg_names \\\n+  (this_target_hard_regs->x_reg_names)\n \n /* Vector indexed by reg class giving its name.  */\n "}, {"sha": "c0a300c69e95e276397f873e30e2fd8ca2ae647a", "filename": "gcc/reginfo.c", "status": "modified", "additions": 25, "deletions": 71, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6642445b2caf5917b0aa341ab998b01796310751/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6642445b2caf5917b0aa341ab998b01796310751/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=6642445b2caf5917b0aa341ab998b01796310751", "patch": "@@ -59,44 +59,22 @@ along with GCC; see the file COPYING3.  If not see\n int max_regno;\n \n \f\n+struct target_hard_regs default_target_hard_regs;\n struct target_regs default_target_regs;\n #if SWITCHABLE_TARGET\n+struct target_hard_regs *this_target_hard_regs = &default_target_hard_regs;\n struct target_regs *this_target_regs = &default_target_regs;\n #endif\n \n-/* Register tables used by many passes.  */\n-\n-/* Indexed by hard register number, contains 1 for registers\n-   that are fixed use (stack pointer, pc, frame pointer, etc.).\n-   These are the registers that cannot be used to allocate\n-   a pseudo reg for general use.  */\n-char fixed_regs[FIRST_PSEUDO_REGISTER];\n-\n-/* Same info as a HARD_REG_SET.  */\n-HARD_REG_SET fixed_reg_set;\n-\n-/* Data for initializing the above.  */\n+/* Data for initializing fixed_regs.  */\n static const char initial_fixed_regs[] = FIXED_REGISTERS;\n \n-/* Indexed by hard register number, contains 1 for registers\n-   that are fixed use or are clobbered by function calls.\n-   These are the registers that cannot be used to allocate\n-   a pseudo reg whose life crosses calls unless we are able\n-   to save/restore them across the calls.  */\n-char call_used_regs[FIRST_PSEUDO_REGISTER];\n-\n-/* Same info as a HARD_REG_SET.  */\n-HARD_REG_SET call_used_reg_set;\n-\n-/* Data for initializing the above.  */\n+/* Data for initializing call_used_regs.  */\n static const char initial_call_used_regs[] = CALL_USED_REGISTERS;\n \n-/* This is much like call_used_regs, except it doesn't have to\n-   be a superset of FIXED_REGISTERS. This vector indicates\n-   what is really call clobbered, and is used when defining\n-   regs_invalidated_by_call.  */\n #ifdef CALL_REALLY_USED_REGISTERS\n-char call_really_used_regs[] = CALL_REALLY_USED_REGISTERS;\n+/* Data for initializing call_really_used_regs.  */\n+static const char initial_call_really_used_regs[] = CALL_REALLY_USED_REGISTERS;\n #endif\n \n #ifdef CALL_REALLY_USED_REGISTERS\n@@ -105,28 +83,12 @@ char call_really_used_regs[] = CALL_REALLY_USED_REGISTERS;\n #define CALL_REALLY_USED_REGNO_P(X)  call_used_regs[X]\n #endif\n \n-\n-/* Contains registers that are fixed use -- i.e. in fixed_reg_set -- or\n-   a function value return register or TARGET_STRUCT_VALUE_RTX or\n-   STATIC_CHAIN_REGNUM.  These are the registers that cannot hold quantities\n-   across calls even if we are willing to save and restore them.  */\n-\n-HARD_REG_SET call_fixed_reg_set;\n-\n /* Indexed by hard register number, contains 1 for registers\n    that are being used for global register decls.\n    These must be exempt from ordinary flow analysis\n    and are also considered fixed.  */\n char global_regs[FIRST_PSEUDO_REGISTER];\n \n-/* Contains 1 for registers that are set or clobbered by calls.  */\n-/* ??? Ideally, this would be just call_used_regs plus global_regs, but\n-   for someone's bright idea to have call_used_regs strictly include\n-   fixed_regs.  Which leaves us guessing as to the set of fixed_regs\n-   that are actually preserved.  We know for sure that those associated\n-   with the local stack frame are safe, but scant others.  */\n-HARD_REG_SET regs_invalidated_by_call;\n-\n /* Same information as REGS_INVALIDATED_BY_CALL but in regset form to be used\n    in dataflow more conveniently.  */\n regset regs_invalidated_by_call_regset;\n@@ -135,21 +97,11 @@ regset regs_invalidated_by_call_regset;\n    should not be reset after each function is compiled.  */\n static bitmap_obstack persistent_obstack;\n \n-/* Table of register numbers in the order in which to try to use them.  */\n+/* Used to initialize reg_alloc_order.  */\n #ifdef REG_ALLOC_ORDER\n-int reg_alloc_order[FIRST_PSEUDO_REGISTER] = REG_ALLOC_ORDER;\n-\n-/* The inverse of reg_alloc_order.  */\n-int inv_reg_alloc_order[FIRST_PSEUDO_REGISTER];\n+static int initial_reg_alloc_order[FIRST_PSEUDO_REGISTER] = REG_ALLOC_ORDER;\n #endif\n \n-/* For each reg class, a HARD_REG_SET saying which registers are in it.  */\n-HARD_REG_SET reg_class_contents[N_REG_CLASSES];\n-\n-/* For each reg class, a boolean saying whether the class contains only\n-   fixed registers.  */\n-bool class_only_fixed_regs[N_REG_CLASSES];\n-\n /* The same information, but as an array of unsigned ints.  We copy from\n    these unsigned ints to the table above.  We do this so the tm.h files\n    do not have to be aware of the wordsize for machines with <= 64 regs.\n@@ -160,22 +112,8 @@ bool class_only_fixed_regs[N_REG_CLASSES];\n static const unsigned int_reg_class_contents[N_REG_CLASSES][N_REG_INTS]\n   = REG_CLASS_CONTENTS;\n \n-/* For each reg class, number of regs it contains.  */\n-unsigned int reg_class_size[N_REG_CLASSES];\n-\n-/* For each reg class, table listing all the classes contained in it.  */\n-enum reg_class reg_class_subclasses[N_REG_CLASSES][N_REG_CLASSES];\n-\n-/* For each pair of reg classes,\n-   a largest reg class contained in their union.  */\n-enum reg_class reg_class_subunion[N_REG_CLASSES][N_REG_CLASSES];\n-\n-/* For each pair of reg classes,\n-   the smallest reg class containing their union.  */\n-enum reg_class reg_class_superunion[N_REG_CLASSES][N_REG_CLASSES];\n-\n /* Array containing all of the register names.  */\n-const char * reg_names[] = REGISTER_NAMES;\n+static const char *const initial_reg_names[] = REGISTER_NAMES;\n \n /* Array containing all of the register class names.  */\n const char * reg_class_names[] = REG_CLASS_NAMES;\n@@ -251,9 +189,25 @@ init_reg_sets (void)\n      CALL_USED_REGISTERS had the right number of initializers.  */\n   gcc_assert (sizeof fixed_regs == sizeof initial_fixed_regs);\n   gcc_assert (sizeof call_used_regs == sizeof initial_call_used_regs);\n+#ifdef CALL_REALLY_USED_REGISTERS\n+  gcc_assert (sizeof call_really_used_regs\n+\t      == sizeof initial_call_really_used_regs);\n+#endif\n+#ifdef REG_ALLOC_ORDER\n+  gcc_assert (sizeof reg_alloc_order == sizeof initial_reg_alloc_order);\n+#endif\n+  gcc_assert (sizeof reg_names == sizeof initial_reg_names);\n \n   memcpy (fixed_regs, initial_fixed_regs, sizeof fixed_regs);\n   memcpy (call_used_regs, initial_call_used_regs, sizeof call_used_regs);\n+#ifdef CALL_REALLY_USED_REGISTERS\n+  memcpy (call_really_used_regs, initial_call_really_used_regs,\n+\t  sizeof call_really_used_regs);\n+#endif\n+#ifdef REG_ALLOC_ORDER\n+  memcpy (reg_alloc_order, initial_reg_alloc_order, sizeof reg_alloc_order);\n+#endif\n+  memcpy (reg_names, initial_reg_names, sizeof reg_names);\n   memset (global_regs, 0, sizeof global_regs);\n }\n "}, {"sha": "b6906ce0cd553b05e3e880087d51e793df0fca21", "filename": "gcc/target-globals.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6642445b2caf5917b0aa341ab998b01796310751/gcc%2Ftarget-globals.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6642445b2caf5917b0aa341ab998b01796310751/gcc%2Ftarget-globals.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-globals.c?ref=6642445b2caf5917b0aa341ab998b01796310751", "patch": "@@ -29,12 +29,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"regs.h\"\n #include \"rtl.h\"\n+#include \"hard-reg-set.h\"\n \n #if SWITCHABLE_TARGET\n struct target_globals default_target_globals = {\n   &default_target_flag_state,\n   &default_target_regs,\n-  &default_target_rtl\n+  &default_target_rtl,\n+  &default_target_hard_regs\n };\n \n struct target_globals *\n@@ -46,6 +48,7 @@ save_target_globals (void)\n   g->flag_state = XCNEW (struct target_flag_state);\n   g->regs = XCNEW (struct target_regs);\n   g->rtl = ggc_alloc_cleared_target_rtl ();\n+  g->hard_regs = XCNEW (struct target_hard_regs);\n   restore_target_globals (g);\n   target_reinit ();\n   return g;"}, {"sha": "913c5120147c57500731c066a28c2e7c7ec3c72b", "filename": "gcc/target-globals.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6642445b2caf5917b0aa341ab998b01796310751/gcc%2Ftarget-globals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6642445b2caf5917b0aa341ab998b01796310751/gcc%2Ftarget-globals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-globals.h?ref=6642445b2caf5917b0aa341ab998b01796310751", "patch": "@@ -24,11 +24,13 @@ along with GCC; see the file COPYING3.  If not see\n extern struct target_flag_state *this_target_flag_state;\n extern struct target_regs *this_target_regs;\n extern struct target_rtl *this_target_rtl;\n+extern struct target_hard_regs *this_target_hard_regs;\n \n struct GTY(()) target_globals {\n   struct target_flag_state *GTY((skip)) flag_state;\n   struct target_regs *GTY((skip)) regs;\n   struct target_rtl *rtl;\n+  struct target_hard_regs *GTY((skip)) hard_regs;\n };\n \n extern struct target_globals default_target_globals;\n@@ -41,6 +43,7 @@ restore_target_globals (struct target_globals *g)\n   this_target_flag_state = g->flag_state;\n   this_target_regs = g->regs;\n   this_target_rtl = g->rtl;\n+  this_target_hard_regs = g->hard_regs;\n }\n #endif\n "}]}